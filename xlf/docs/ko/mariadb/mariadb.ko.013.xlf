<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="mariadb">
    <body>
      <group id="mariadb">
        <trans-unit id="eac677dd94c442abffeabc554e52b2a31856b934" translate="yes" xml:space="preserve">
          <source>Aria</source>
          <target state="translated">Aria</target>
        </trans-unit>
        <trans-unit id="78a9c12d5527e486a382e0dc04bb8f6f4ec0e5e6" translate="yes" xml:space="preserve">
          <source>Aria 1.0 was basically a crash-safe non-transactional version of MyISAM. Aria 1.5 added more concurrency (multiple inserter) and some optimizations.</source>
          <target state="translated">Aria 1.0은 기본적으로 충돌에 안전한 비 트랜잭션 버전의 MyISAM입니다. Aria 1.5는 더 많은 동시성 (다중 삽입 기)과 일부 최적화를 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="c14140e9286ba4988d818c55b894c303e4452fb9" translate="yes" xml:space="preserve">
          <source>Aria Clients and Utilities</source>
          <target state="translated">아리아 클라이언트 및 유틸리티</target>
        </trans-unit>
        <trans-unit id="570c927653941f84d0d0d36918f6cd2abb30c39a" translate="yes" xml:space="preserve">
          <source>Aria Disabling Encryption</source>
          <target state="translated">Aria 비활성화 암호화</target>
        </trans-unit>
        <trans-unit id="598c95736d320fd73e1b1db2e3b45c9e81928341" translate="yes" xml:space="preserve">
          <source>Aria Enabling Encryption</source>
          <target state="translated">Aria 지원 암호화</target>
        </trans-unit>
        <trans-unit id="c2bbacea3665ed42337c4ddd8fc3f50c5778cd0a" translate="yes" xml:space="preserve">
          <source>Aria Encryption</source>
          <target state="translated">아리아 암호화</target>
        </trans-unit>
        <trans-unit id="c317c176fc803358acc993645edbb3c777369935" translate="yes" xml:space="preserve">
          <source>Aria Encryption Keys</source>
          <target state="translated">아리아 암호화 키</target>
        </trans-unit>
        <trans-unit id="705356b38c47052ed3d549119221ee32a5edbe8e" translate="yes" xml:space="preserve">
          <source>Aria Encryption Overview</source>
          <target state="translated">Aria 암호화 개요</target>
        </trans-unit>
        <trans-unit id="9f77a8823b29e8ae696f42be19ccf5085c1031ba" translate="yes" xml:space="preserve">
          <source>Aria FAQ</source>
          <target state="translated">아리아 FAQ</target>
        </trans-unit>
        <trans-unit id="d0f3db0a1c12613164925412f53f80bb1bd478c3" translate="yes" xml:space="preserve">
          <source>Aria Group Commit</source>
          <target state="translated">아리아 그룹 커밋</target>
        </trans-unit>
        <trans-unit id="e0251c358e0f5d2ef585f527bcac9758309dc56e" translate="yes" xml:space="preserve">
          <source>Aria Spatial Indexes</source>
          <target state="translated">아리아 공간 인덱스</target>
        </trans-unit>
        <trans-unit id="89e88830c0020788136fcb3d00b0e1acdfe83525" translate="yes" xml:space="preserve">
          <source>Aria Status Variables</source>
          <target state="translated">아리아 상태 변수</target>
        </trans-unit>
        <trans-unit id="087704a2fe3edc12c0ba51d86c7a07074bc2dd55" translate="yes" xml:space="preserve">
          <source>Aria Storage Engine</source>
          <target state="translated">아리아 스토리지 엔진</target>
        </trans-unit>
        <trans-unit id="1862622e3a65f62918a72983e7b275883b01752b" translate="yes" xml:space="preserve">
          <source>Aria Storage Engine Options</source>
          <target state="translated">아리아 스토리지 엔진 옵션</target>
        </trans-unit>
        <trans-unit id="fdecb941c1641d8d57d50f0aa467f6ce8943c826" translate="yes" xml:space="preserve">
          <source>Aria Storage Engine Options and System Variables</source>
          <target state="translated">Aria 스토리지 엔진 옵션 및 시스템 변수</target>
        </trans-unit>
        <trans-unit id="153aeaeb86ca6c80ccb8afc95f2d49b2971def19" translate="yes" xml:space="preserve">
          <source>Aria Storage Formats</source>
          <target state="translated">아리아 스토리지 형식</target>
        </trans-unit>
        <trans-unit id="0f1d82a64f4a3635de204fac99b2095a3d9c3299" translate="yes" xml:space="preserve">
          <source>Aria System Variables</source>
          <target state="translated">아리아 시스템 변수</target>
        </trans-unit>
        <trans-unit id="e482a118b83fe064c7ac36aec236a818a2a72679" translate="yes" xml:space="preserve">
          <source>Aria Two-step Deadlock Detection</source>
          <target state="translated">아리아 2 단계 교착 상태 탐지</target>
        </trans-unit>
        <trans-unit id="21ff6a27d4ae930a834f96e56dbb7f7dba2969d4" translate="yes" xml:space="preserve">
          <source>Aria benchmarks</source>
          <target state="translated">아리아 벤치 마크</target>
        </trans-unit>
        <trans-unit id="82b275d94da27fbfee110579992cf4e3c5693922" translate="yes" xml:space="preserve">
          <source>Aria can replay almost everything from the log. (Including &lt;code&gt;CREATE&lt;/code&gt;, &lt;code&gt;DROP&lt;/code&gt;, &lt;code&gt;RENAME&lt;/code&gt;, &lt;code&gt;TRUNCATE&lt;/code&gt; tables). Therefore, you make a backup of Aria by just copying the log. The things that can't be replayed (yet) are:</source>
          <target state="translated">Aria는 로그에서 거의 모든 것을 재생할 수 있습니다. ( &lt;code&gt;CREATE&lt;/code&gt; , &lt;code&gt;DROP&lt;/code&gt; , &lt;code&gt;RENAME&lt;/code&gt; , &lt;code&gt;TRUNCATE&lt;/code&gt; 테이블 포함). 따라서 로그를 복사하여 Aria를 백업하십시오. 재생할 수없는 것 (아직)은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b2809b2e93a78030248d3ea3dfffe7a2917cded5" translate="yes" xml:space="preserve">
          <source>Aria data pages in block format have an overhead of 10 bytes/page and 5 bytes/row. Transaction and multiple concurrent-writer support will use an extra overhead of 7 bytes for new rows, 14 bytes for deleted rows and 0 bytes for old compacted rows.</source>
          <target state="translated">블록 형식의 Aria 데이터 페이지는 10 바이트 / 페이지 및 5 바이트 / 행의 오버 헤드를 갖습니다. 트랜잭션 및 다중 동시 작성기 지원은 새 행의 경우 7 바이트, 삭제 된 행의 경우 14 바이트, 오래된 압축 행의 경우 0 바이트의 추가 오버 헤드를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="90d6f1d2cc0a3efafa248b67cc86781b6f63ce88" translate="yes" xml:space="preserve">
          <source>Aria does not currently support the &lt;code&gt;ENCRYPTED&lt;/code&gt; table option. See &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-18049&quot;&gt;MDEV-18049&lt;/a&gt; about that.</source>
          <target state="translated">Aria는 현재 &lt;code&gt;ENCRYPTED&lt;/code&gt; 테이블 옵션을 지원하지 않습니다 . 이에 대해서는 &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-18049&quot;&gt;MDEV-18049를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6f08d171742ee5d81095f143fa327159458b62f5" translate="yes" xml:space="preserve">
          <source>Aria does not currently support the &lt;code&gt;ENCRYPTION_KEY_ID&lt;/code&gt; table option. See &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-18049&quot;&gt;MDEV-18049&lt;/a&gt; about that.</source>
          <target state="translated">Aria는 현재 &lt;code&gt;ENCRYPTION_KEY_ID&lt;/code&gt; 테이블 옵션을 지원하지 않습니다 . 이에 대해서는 &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-18049&quot;&gt;MDEV-18049를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4a818f6820a1b0b346af4213d5e073dede7e89be" translate="yes" xml:space="preserve">
          <source>Aria does not support multiple key caches.</source>
          <target state="translated">Aria는 여러 키 캐시를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ff8cdd216d80b943a797ffad28af356f0a9540bc" translate="yes" xml:space="preserve">
          <source>Aria doesn't support &lt;code&gt;INSERT DELAYED&lt;/code&gt;.</source>
          <target state="translated">Aria는 &lt;code&gt;INSERT DELAYED&lt;/code&gt; 를 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9bf96ecdf4fa80c8e0d6ffa9a6fd99453039d4ee" translate="yes" xml:space="preserve">
          <source>Aria doesn't support MySQL internal RAID (disabled in MyISAM too, it's a deprecated feature).</source>
          <target state="translated">Aria는 MySQL 내부 RAID를 지원하지 않습니다 (MyISAM에서도 비활성화되어 더 이상 사용되지 않는 기능 임).</target>
        </trans-unit>
        <trans-unit id="84b88241ce94dfb642a71a2ca1233ad7cadd1b4c" translate="yes" xml:space="preserve">
          <source>Aria doesn't support indexes on virtual fields.</source>
          <target state="translated">Aria는 가상 필드의 인덱스를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="72acd7640ecf3cf66e17447f2f7f679edb749d40" translate="yes" xml:space="preserve">
          <source>Aria follows the same &lt;a href=&quot;../release-criteria/index&quot;&gt;release criteria&lt;/a&gt; as for &lt;a href=&quot;../mariadb/index&quot;&gt;MariaDB&lt;/a&gt;. Some clarifications, unique for the Aria storage engine:</source>
          <target state="translated">Aria 는 &lt;a href=&quot;../mariadb/index&quot;&gt;MariaDB&lt;/a&gt; 와 동일한 &lt;a href=&quot;../release-criteria/index&quot;&gt;릴리스 기준&lt;/a&gt; 을 따릅니다 . Aria 스토리지 엔진에 고유 한 몇 가지 설명 :</target>
        </trans-unit>
        <trans-unit id="4094f5ede256f52158ea9ed0e4059dbcc9f42e07" translate="yes" xml:space="preserve">
          <source>Aria group commits for speeding up multi-user inserts</source>
          <target state="translated">다중 사용자 삽입 속도를 높이기위한 Aria 그룹 커밋</target>
        </trans-unit>
        <trans-unit id="e3a9fc0e278ba0fc6c5d89420b1b85fbf40e2d8f" translate="yes" xml:space="preserve">
          <source>Aria has a log control file (&lt;code&gt;aria_log_control&lt;/code&gt;) and log files (&lt;code&gt;aria_log.%&lt;/code&gt;). The log files can be automatically purged when not needed or purged on demand (after backup).</source>
          <target state="translated">Aria에는 로그 제어 파일 ( &lt;code&gt;aria_log_control&lt;/code&gt; )과 로그 파일 ( &lt;code&gt;aria_log.%&lt;/code&gt; )이 있습니다. 로그 파일은 필요하지 않거나 필요에 따라 (백업 후) 제거 할 때 자동으로 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1531544b5981032325f5ea6c2c51bef7d4eafe68" translate="yes" xml:space="preserve">
          <source>Aria has one page size for both index and data (defined when Aria is used the first time). MyISAM supports different page sizes per index.</source>
          <target state="translated">Aria는 인덱스와 데이터 모두에 대해 하나의 페이지 크기를 갖습니다 (Aria를 처음 사용할 때 정의). MyISAM은 인덱스마다 다른 페이지 크기를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="d529a4a0c64df33c5268e83052b2eada09202ff7" translate="yes" xml:space="preserve">
          <source>Aria has unit tests of most parts.</source>
          <target state="translated">Aria는 대부분의 부품에 대한 단위 테스트를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="86e0fb1fcb51b848cdfdb970c6e5ed2e15513712" translate="yes" xml:space="preserve">
          <source>Aria index and data file formats should be backwards and forwards compatible to ensure easy upgrades and downgrades.</source>
          <target state="translated">Aria 인덱스 및 데이터 파일 형식은 쉽게 업그레이드 및 다운 그레이드 할 수 있도록 이전 버전과 이전 버전과 호환 가능해야합니다.</target>
        </trans-unit>
        <trans-unit id="229aa38bcc94584b5fe2340d122a304a75c24708" translate="yes" xml:space="preserve">
          <source>Aria is a crash safe MyISAM and more.</source>
          <target state="translated">Aria는 응급 안전 MyISAM 등입니다.</target>
        </trans-unit>
        <trans-unit id="2bc0e98fd10728be0e2dfdea51184c0d4cb20a2e" translate="yes" xml:space="preserve">
          <source>Aria is a storage engine for MySQL&amp;reg; and MariaDB. It was originally developed with the goal of becoming the default transactional &lt;strong&gt;and&lt;/strong&gt; non-transactional storage engine for MariaDB and MySQL.</source>
          <target state="translated">Aria는 MySQL&amp;reg; 및 MariaDB 용 스토리지 엔진입니다. 원래 MariaDB 및 MySQL 의 기본 트랜잭션 &lt;strong&gt;및&lt;/strong&gt; 트랜잭션이 아닌 스토리지 엔진 이 될 목적으로 개발되었습니다 .</target>
        </trans-unit>
        <trans-unit id="ad750142814efbc8dc7032e5769b2a6f4698ef8a" translate="yes" xml:space="preserve">
          <source>Aria is now feature complete according to specification.</source>
          <target state="translated">Aria는 이제 사양에 따라 완성 된 기능입니다.</target>
        </trans-unit>
        <trans-unit id="483b7570c855ad4214b53f784c1f242d4188d1f3" translate="yes" xml:space="preserve">
          <source>Aria storage engine</source>
          <target state="translated">아리아 스토리지 엔진</target>
        </trans-unit>
        <trans-unit id="9d1bb64b5d20695228f2b209543c9a86ea62cab3" translate="yes" xml:space="preserve">
          <source>Aria supports all aspects of MyISAM, except as noted below. This includes external and internal check/repair/compressing of rows, different row formats, different index compress formats, &lt;code&gt;&lt;a href=&quot;../aria_chk/index&quot;&gt;aria_chk&lt;/a&gt;&lt;/code&gt; etc. After a normal shutdown you can copy Aria files between servers.</source>
          <target state="translated">Aria는 아래 언급 된 것을 제외하고 MyISAM의 모든 측면을 지원합니다. 여기에는 행의 외부 및 내부 검사 / 복구 / 압축, 다른 행 형식, 다른 인덱스 압축 형식, &lt;code&gt;&lt;a href=&quot;../aria_chk/index&quot;&gt;aria_chk&lt;/a&gt;&lt;/code&gt; 등이 포함됩니다. 정상적인 종료 후 서버간에 Aria 파일을 복사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ad2a49517bc90ab1960801c2d05a793e37e1af6" translate="yes" xml:space="preserve">
          <source>Aria table information is stored in 2 files: the &lt;code&gt;.MAI&lt;/code&gt; file contains base table information and the index and the &lt;code&gt;.MAD&lt;/code&gt; file contains the data. &lt;code&gt;aria_chk&lt;/code&gt; takes one or more &lt;code&gt;.MAI&lt;/code&gt; files as arguments.</source>
          <target state="translated">Aria 테이블 정보는 2 개의 파일로 저장됩니다. &lt;code&gt;.MAI&lt;/code&gt; 파일은 기본 테이블 정보를 포함하고 인덱스 및 &lt;code&gt;.MAD&lt;/code&gt; 파일은 데이터를 포함합니다. &lt;code&gt;aria_chk&lt;/code&gt; 는 하나 이상의 &lt;code&gt;.MAI&lt;/code&gt; 파일을 인수로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="cf50d6b60ac46faab0e14dcfbf8146c7dcd3ad14" translate="yes" xml:space="preserve">
          <source>Aria uses 8K pages by default (MyISAM uses 1K). This makes Aria a bit faster when using keys of fixed size, but slower when using variable-length packed keys (until we add a directory to index pages).</source>
          <target state="translated">Aria는 기본적으로 8K 페이지를 사용합니다 (MyISAM은 1K 사용). 이렇게하면 고정 크기의 키를 사용할 때 Aria가 약간 빨라지지만 가변 길이 팩 키를 사용할 때는 속도가 느려집니다 (인덱스 페이지에 디렉토리를 추가 할 때까지).</target>
        </trans-unit>
        <trans-unit id="aeccfa0ed52ae84bae8e9d8a67d255d8ad5832ea" translate="yes" xml:space="preserve">
          <source>Aria uses BIG (1G by default) log files.</source>
          <target state="translated">Aria는 BIG (기본적으로 1G) 로그 파일을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f661604d8c0d7185172fc95f20e0a047f734b0a2" translate="yes" xml:space="preserve">
          <source>Aria will automatically notice if you have copied a table from another system and do 'zerofill' for the first access of the table if it was not marked as 'movable'. The reason for using &lt;code&gt;&lt;a href=&quot;../aria_chk/index&quot;&gt;aria_chk --zerofill&lt;/a&gt;&lt;/code&gt; is that you avoid a delay in the MariaDB server for the first access of the table.</source>
          <target state="translated">Aria는 다른 시스템에서 테이블을 복사했는지 자동으로 확인하고 테이블이 '이동 가능'으로 표시되지 않은 경우 테이블의 첫 번째 액세스에 대해 'zerofill'을 수행합니다. &lt;code&gt;&lt;a href=&quot;../aria_chk/index&quot;&gt;aria_chk --zerofill&lt;/a&gt;&lt;/code&gt; 을 사용하는 이유 는 MariaDB 서버에서 테이블에 처음 액세스 할 때 지연이 발생하지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="0972335496dd1f334524f9517e246cf239addb56" translate="yes" xml:space="preserve">
          <source>Aria-related server status variables.</source>
          <target state="translated">아리아 관련 서버 상태 변수.</target>
        </trans-unit>
        <trans-unit id="0f5a5db2a7ed5c1c14708c196a5005e7781fa8f9" translate="yes" xml:space="preserve">
          <source>Aria-related system variables.</source>
          <target state="translated">아리아 관련 시스템 변수.</target>
        </trans-unit>
        <trans-unit id="3c8a96ec4aa9f0741c5c4b8a77344109dbedc604" translate="yes" xml:space="preserve">
          <source>Aria_pagecache_blocks_not_flushed</source>
          <target state="translated">Aria_pagecache_blocks_not_flushed</target>
        </trans-unit>
        <trans-unit id="5b83890bb572e87256a7af180bda817e2b0c010d" translate="yes" xml:space="preserve">
          <source>Aria_pagecache_blocks_unused</source>
          <target state="translated">Aria_pagecache_blocks_unused</target>
        </trans-unit>
        <trans-unit id="18da570300ffec0e7d2b3ab8f542f729f1b8a126" translate="yes" xml:space="preserve">
          <source>Aria_pagecache_blocks_used</source>
          <target state="translated">Aria_pagecache_blocks_used</target>
        </trans-unit>
        <trans-unit id="6702bc07a7c9ba49ba828687a782207670ab69cd" translate="yes" xml:space="preserve">
          <source>Aria_pagecache_read_requests</source>
          <target state="translated">Aria_pagecache_read_requests</target>
        </trans-unit>
        <trans-unit id="956ba14ad7a8a890fd499dd7b7a8210f88cd666a" translate="yes" xml:space="preserve">
          <source>Aria_pagecache_reads</source>
          <target state="translated">Aria_pagecache_reads</target>
        </trans-unit>
        <trans-unit id="cf0a791d1ce6276f44149ea29d76c52f6a864b2a" translate="yes" xml:space="preserve">
          <source>Aria_pagecache_write_requests</source>
          <target state="translated">Aria_pagecache_write_requests</target>
        </trans-unit>
        <trans-unit id="a81afa9a14f0991a4cac4ad7de409f0965897432" translate="yes" xml:space="preserve">
          <source>Aria_pagecache_writes</source>
          <target state="translated">Aria_pagecache_writes</target>
        </trans-unit>
        <trans-unit id="fe6e34da213285359fb4c40fe52dc10d4ef35ac6" translate="yes" xml:space="preserve">
          <source>Aria_transaction_log_syncs</source>
          <target state="translated">Aria_transaction_log_syncs</target>
        </trans-unit>
        <trans-unit id="2771d378b50997ec6716ede26b34cd2ff4fb63a3" translate="yes" xml:space="preserve">
          <source>Arithmetic Examples</source>
          <target state="translated">산술 예</target>
        </trans-unit>
        <trans-unit id="6104f39ed22a2cd32e98536a3447a01c4b9f4781" translate="yes" xml:space="preserve">
          <source>Arithmetic Operators</source>
          <target state="translated">산술 연산자</target>
        </trans-unit>
        <trans-unit id="286df038faaaeac4645e9d64c73a2e654d3db45b" translate="yes" xml:space="preserve">
          <source>Arithmetic operators for addition, subtraction, multiplication, division and the modulo operator</source>
          <target state="translated">덧셈, 뺄셈, 곱셈, 나눗셈 및 모듈로 연산자를위한 산술 연산자</target>
        </trans-unit>
        <trans-unit id="1a0d21145500640fd3f6136eeba595bfe934d364" translate="yes" xml:space="preserve">
          <source>Armenian</source>
          <target state="translated">Armenian</target>
        </trans-unit>
        <trans-unit id="107004472b7ba4e5e31f3082ee1fb5a1239eec61" translate="yes" xml:space="preserve">
          <source>Array</source>
          <target state="translated">Array</target>
        </trans-unit>
        <trans-unit id="238a5476b2b099dbf0d0f2fd0cf448d18972ec8a" translate="yes" xml:space="preserve">
          <source>Array Type</source>
          <target state="translated">배열 유형</target>
        </trans-unit>
        <trans-unit id="c166b94e1775ef5a4ae1f5053e60ef897dc65af2" translate="yes" xml:space="preserve">
          <source>Arrays or objects that are not empty but contain only elements or member values of depth 1 will have a depth of 2.</source>
          <target state="translated">비어 있지 않지만 깊이 1의 요소 또는 멤버 값만 포함하는 배열 또는 객체의 깊이는 2입니다.</target>
        </trans-unit>
        <trans-unit id="8bae3f7d0a461488ced07b3e10ab80d018eb1d8c" translate="yes" xml:space="preserve">
          <source>Arthur</source>
          <target state="translated">Arthur</target>
        </trans-unit>
        <trans-unit id="b4dfb64461687cfd7c298c43d1646f24de9d330a" translate="yes" xml:space="preserve">
          <source>Arthur, Sandra, Peter, John</source>
          <target state="translated">아서, 산드라, 피터, 존</target>
        </trans-unit>
        <trans-unit id="2ec05f61051ffa23287e58cf048c51a69a360db5" translate="yes" xml:space="preserve">
          <source>Articles about Table Elimination, the idea that it is sometimes possible to resolve a query without accessing some of the tables the query refers to.</source>
          <target state="translated">테이블 제거에 관한 기사, 때로는 쿼리가 참조하는 테이블 중 일부에 액세스하지 않고 쿼리를 해결할 수 있다는 아이디어.</target>
        </trans-unit>
        <trans-unit id="b35ddbe75816be89518f26ccc75dbfbcee3802ef" translate="yes" xml:space="preserve">
          <source>Articles about creating, modifying, and maintaining tables in MariaDB.</source>
          <target state="translated">MariaDB에서 테이블 생성, 수정 및 유지 관리에 대한 기사.</target>
        </trans-unit>
        <trans-unit id="a0cd3e2f2fcb1e97ff02c8dd0d2afaab67f74119" translate="yes" xml:space="preserve">
          <source>Articles about joins in MariaDB.</source>
          <target state="translated">MariaDB 가입에 관한 기사.</target>
        </trans-unit>
        <trans-unit id="cf3adf93772dd581f76b1778b4ad3decef3cbc4e" translate="yes" xml:space="preserve">
          <source>Articles about subquery optimizations in MariaDB.</source>
          <target state="translated">MariaDB의 하위 쿼리 최적화에 대한 기사.</target>
        </trans-unit>
        <trans-unit id="2b0a27e1326f774baf060a609a859ee56aefc4c5" translate="yes" xml:space="preserve">
          <source>Articles about the Information Schema</source>
          <target state="translated">정보 스키마에 대한 기사</target>
        </trans-unit>
        <trans-unit id="4ae5498a26795c6d37d84fc0ae56368a1178e6ef" translate="yes" xml:space="preserve">
          <source>Articles of how to setup your MariaDB optimally on different systems</source>
          <target state="translated">다른 시스템에서 MariaDB를 최적으로 설정하는 방법에 대한 기사</target>
        </trans-unit>
        <trans-unit id="d548fc9969699c50a932cbc164154d1ac6f89eef" translate="yes" xml:space="preserve">
          <source>Articles on compiling MariaDB from source</source>
          <target state="translated">소스에서 MariaDB 컴파일에 관한 기사</target>
        </trans-unit>
        <trans-unit id="82e5f78ad097fae2b9f8f76566c6bce3467106b9" translate="yes" xml:space="preserve">
          <source>Articles on compiling MariaDB with extra modules and options</source>
          <target state="translated">추가 모듈 및 옵션으로 MariaDB를 컴파일하는 방법에 대한 기사</target>
        </trans-unit>
        <trans-unit id="b09472ff7eba8416d2d7c82c7947f93deec7b5ea" translate="yes" xml:space="preserve">
          <source>Articles on how to get the most out of MariaDB, including new features.</source>
          <target state="translated">새로운 기능을 포함하여 MariaDB를 최대한 활용하는 방법에 대한 기사.</target>
        </trans-unit>
        <trans-unit id="30058dd39480b3147cd2479fa8cbbe9bf337ea68" translate="yes" xml:space="preserve">
          <source>Articles on the ANALYZE and EXPLAIN statements</source>
          <target state="translated">분석 및 설명문에 대한 기사</target>
        </trans-unit>
        <trans-unit id="49f6701f46ca38c91b11b18e8eaf65ab868da795" translate="yes" xml:space="preserve">
          <source>Articles on the various CREATE statements.</source>
          <target state="translated">다양한 CREATE 문에 대한 기사.</target>
        </trans-unit>
        <trans-unit id="829d7edc242efd22fced0f00485a9f35be33c31d" translate="yes" xml:space="preserve">
          <source>Articles on the various SHOW commands.</source>
          <target state="translated">다양한 SHOW 명령에 대한 기사.</target>
        </trans-unit>
        <trans-unit id="4179f85ad2d075b0339f489b76d0d50cc8e3722d" translate="yes" xml:space="preserve">
          <source>Articles on troubleshooting tips and techniques</source>
          <target state="translated">문제 해결 팁 및 기술에 대한 기사</target>
        </trans-unit>
        <trans-unit id="5d39f3d554bb3c28c850aca4945d3433103e4840" translate="yes" xml:space="preserve">
          <source>Articles on using data-at-rest encryption with the InnoDB and XtraDB storage engines.</source>
          <target state="translated">InnoDB 및 XtraDB 스토리지 엔진에서 미사용 데이터 암호화 사용에 관한 기사.</target>
        </trans-unit>
        <trans-unit id="8a63b45997b31a4875eea6279ff0a2ca978a3461" translate="yes" xml:space="preserve">
          <source>Articles on various DROP commands.</source>
          <target state="translated">다양한 DROP 명령에 대한 기사.</target>
        </trans-unit>
        <trans-unit id="99b51842d0401f9a6de915fe16ea9912efb3ba6f" translate="yes" xml:space="preserve">
          <source>Articles related to starting and stopping MariaDB Server.</source>
          <target state="translated">MariaDB 서버 시작 및 중지와 관련된 기사.</target>
        </trans-unit>
        <trans-unit id="1591a5378bda06cc007fc115c8e46f5e61c4ed49" translate="yes" xml:space="preserve">
          <source>Articles relating to installation issues users might run into</source>
          <target state="translated">사용자가 겪을 수있는 설치 문제와 관련된 기사</target>
        </trans-unit>
        <trans-unit id="6c574afd99b22dae664ffd4a15af058d3b7f69dd" translate="yes" xml:space="preserve">
          <source>Articles relating to installation issues users might run into.</source>
          <target state="translated">사용자가 겪을 수있는 설치 문제와 관련된 기사</target>
        </trans-unit>
        <trans-unit id="00a64c84eb9ba8dfc9bf5ffca0f7222284e217ca" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;TABLES WITH READ LOCK&lt;/code&gt; but also disable all checkpoint writes by transactional table engines. This is useful when doing a disk snapshot of all tables.</source>
          <target state="translated">&lt;code&gt;TABLES WITH READ LOCK&lt;/code&gt; 과 마찬가지로 트랜잭션 테이블 엔진의 모든 체크 포인트 쓰기를 비활성화합니다. 이것은 모든 테이블의 디스크 스냅 샷을 수행 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="17d04e65d740c50f0b3ca4d63db45a61eaa113a2" translate="yes" xml:space="preserve">
          <source>As I have said many times, in many places, BY RANGE is perhaps the only useful variant. And a time series is the most common use for PARTITIONing.</source>
          <target state="translated">내가 여러 번 말했듯이, 많은 곳에서 BY RANGE가 유일하게 유용한 변형 일 것입니다. 그리고 시계열은 파티셔닝에 가장 일반적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d6a8c8aa5a1889b9e23863618ddedb36bc4ab061" translate="yes" xml:space="preserve">
          <source>As S3 is supporting discovery (automatically making tables available that are in S3) this can cause some small performance problems if the S3 engine is enabled.</source>
          <target state="translated">S3가 감지를 지원하므로 (S3에있는 테이블을 자동으로 사용 가능하게 함) S3 엔진이 사용 가능한 경우 약간의 성능 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78b0bd9cb97cdb74a53fe275ef177a549ef88c75" translate="yes" xml:space="preserve">
          <source>As a &lt;a href=&quot;../window-functions/index&quot;&gt;window function&lt;/a&gt;</source>
          <target state="translated">A와 &lt;a href=&quot;../window-functions/index&quot;&gt;윈도우 함수&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6f7d171b9e746d3059fddc08d59962669a4f6de1" translate="yes" xml:space="preserve">
          <source>As a &lt;a href=&quot;../window-functions/index&quot;&gt;window function&lt;/a&gt;:</source>
          <target state="translated">A와 &lt;a href=&quot;../window-functions/index&quot;&gt;윈도우 함수&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="737d9e0fb68f969857bc55ff83f3d4898f19decb" translate="yes" xml:space="preserve">
          <source>As a JDBC table using some commercially available MongoDB JDBC drivers.</source>
          <target state="translated">시중에서 판매되는 MongoDB JDBC 드라이버를 사용하는 JDBC 테이블.</target>
        </trans-unit>
        <trans-unit id="3283f85a99d67700c5d20b74bf0ee71409253372" translate="yes" xml:space="preserve">
          <source>As a JSON table via the MongoDB C or Java Driver.</source>
          <target state="translated">MongoDB C 또는 Java 드라이버를 통한 JSON 테이블.</target>
        </trans-unit>
        <trans-unit id="a333411c33e55065d2cdca63f29d0a147c455ccf" translate="yes" xml:space="preserve">
          <source>As a MONGO table via the MongoDB C Driver.</source>
          <target state="translated">MongoDB C 드라이버를 통한 MONGO 테이블.</target>
        </trans-unit>
        <trans-unit id="eaee95c334a04ceeb02c6236039eea3daa0b3232" translate="yes" xml:space="preserve">
          <source>As a MONGO table via the MongoDB Java Driver.</source>
          <target state="translated">MongoDB Java 드라이버를 통한 MONGO 테이블로.</target>
        </trans-unit>
        <trans-unit id="ca6f46b74a5ecc2c1fd98b60ad4fc67fd231deec" translate="yes" xml:space="preserve">
          <source>As a consequence of this, the &lt;code&gt;TIME&lt;/code&gt; column of &lt;code&gt;SHOW FULL PROCESSLIST&lt;/code&gt; and &lt;code&gt;INFORMATION_SCHEMA.PROCESSLIST&lt;/code&gt; can not be used to determine if a slave is lagging behind. For this, use instead the &lt;code&gt;Seconds_Behind_Master&lt;/code&gt; column in the output of &lt;a href=&quot;../show-slave-status/index&quot;&gt;SHOW SLAVE STATUS&lt;/a&gt;.</source>
          <target state="translated">그 결과 &lt;code&gt;SHOW FULL PROCESSLIST&lt;/code&gt; 및 &lt;code&gt;INFORMATION_SCHEMA.PROCESSLIST&lt;/code&gt; 의 &lt;code&gt;TIME&lt;/code&gt; 열을 사용하여 슬레이브가 지연되는지 확인할 수 없습니다. 이를 위해 &lt;a href=&quot;../show-slave-status/index&quot;&gt;SHOW SLAVE STATUS&lt;/a&gt; 출력에서 &lt;code&gt;Seconds_Behind_Master&lt;/code&gt; 열을 대신 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f1b534065e71aea1a434996e5487bc41e124c781" translate="yes" xml:space="preserve">
          <source>As a consequence, MariaDB behaves a bit differently if it is installed from Debian's and Ubuntu's default repositories.</source>
          <target state="translated">결과적으로 MariaDB가 데비안과 우분투의 기본 리포지토리에서 설치되면 약간 다르게 동작합니다.</target>
        </trans-unit>
        <trans-unit id="e804d02b2afcd42591d66b202adb07f2805b2f05" translate="yes" xml:space="preserve">
          <source>As a final optional step, once your normal mirror has at least &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5533a-release-notes/&quot;&gt;MariaDB 5.5.33a&lt;/a&gt; you can '&lt;code&gt;sudo apt-get upgrade&lt;/code&gt;' to upgrade. To check what version of MariaDB our mirror has, run the following command (after running '&lt;code&gt;sudo apt-get update&lt;/code&gt;'):</source>
          <target state="translated">마지막 선택적 단계로서, 일반 미러에 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5533a-release-notes/&quot;&gt;MariaDB 5.5.33a&lt;/a&gt; 이상 이 있으면 ' &lt;code&gt;sudo apt-get upgrade&lt;/code&gt; '를 사용하여 업그레이드 할 수 있습니다 . 미러에있는 MariaDB 버전을 확인하려면 ' &lt;code&gt;sudo apt-get update&lt;/code&gt; '를 실행 한 후 다음 명령을 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="3782092222c053f32d5842e9c225d7bc08ef0005" translate="yes" xml:space="preserve">
          <source>As a general rule of thumb, hardware should be improved in the following order:</source>
          <target state="translated">일반적으로 하드웨어는 다음 순서로 개선해야합니다.</target>
        </trans-unit>
        <trans-unit id="3689fad5e005b54b4f2ec3db27ac533a63b6ab9a" translate="yes" xml:space="preserve">
          <source>As a result of implementing Table Value Constructors, the &lt;a href=&quot;../values/index&quot;&gt;VALUES function&lt;/a&gt; has been renamed to VALUE().</source>
          <target state="translated">테이블 값 생성자를 구현 한 결과 &lt;a href=&quot;../values/index&quot;&gt;VALUES 함수의&lt;/a&gt; 이름이 VALUE ()로 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="789a39180865bb252c83b2f6621c54f3f8deb2ec" translate="yes" xml:space="preserve">
          <source>As a result of the above changes, the open-for-everyone all-powerful root account is finally gone. And installation scripts will no longer demand that you &amp;ldquo;PLEASE REMEMBER TO SET A PASSWORD FOR THE MariaDB root USER !&amp;rdquo;, because the root account is securely created automatically.</source>
          <target state="translated">위의 변경으로 인해 모든 사람을위한 강력한 루트 계정이 마침내 사라졌습니다. 그리고 루트 계정이 안전하게 자동 생성되기 때문에 설치 스크립트는 더 이상&amp;ldquo;MariaDB 루트 사용자의 암호를 설정해야합니다!&amp;rdquo;를 요구하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dc7af4b02042d71f9b6fdd9fa670b8584716b92a" translate="yes" xml:space="preserve">
          <source>As a result of the above, MariaDB cannot use the index when comparing a string with a numeric value in the example below:</source>
          <target state="translated">위의 결과로 MariaDB는 아래 예에서 문자열을 숫자 값과 비교할 때 색인을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="559a6358b89f02a88cf4eb92f7e72a821e071ae3" translate="yes" xml:space="preserve">
          <source>As a result, you can more-or-less control the join order. For example, let's take this query:</source>
          <target state="translated">결과적으로 조인 순서를 제어 할 수 있습니다. 예를 들어 다음 쿼리를 보자.</target>
        </trans-unit>
        <trans-unit id="fb11b58324142ec4db227224fecbd8f6f6af083e" translate="yes" xml:space="preserve">
          <source>As a rule of thumb, a summary table will have one-tenth the number of rows as the Fact table. (This number is very loose.)</source>
          <target state="translated">일반적으로 요약 테이블에는 팩트 테이블의 행 수의 10 분의 1이 있습니다. (이 숫자는 매우 느슨합니다.)</target>
        </trans-unit>
        <trans-unit id="73b9c21887fec7a36a9cd3fcf0507329c792f89f" translate="yes" xml:space="preserve">
          <source>As a side effect, with the current encryption design, if the &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encrypt_tables&quot;&gt;innodb_encrypt_tables&lt;/a&gt;&lt;/code&gt; system variable is later set to &lt;code&gt;ON&lt;/code&gt;, and InnoDB goes to encrypt the table, then the &lt;a href=&quot;../innodb-background-encryption-threads/index&quot;&gt;InnoDB background encryption threads&lt;/a&gt; will not read this encryption key ID from the &lt;code&gt;.frm&lt;/code&gt; file. Instead, the threads may encrypt the table with the encryption key with ID &lt;code&gt;1&lt;/code&gt;, which is internally considered the default encryption key when no key is specified. For example:</source>
          <target state="translated">부작용으로 현재 암호화 디자인의 경우 &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encrypt_tables&quot;&gt;innodb_encrypt_tables&lt;/a&gt;&lt;/code&gt; 시스템 변수가 나중에 &lt;code&gt;ON&lt;/code&gt; 으로 설정 되고 InnoDB가 테이블을 암호화하면 &lt;a href=&quot;../innodb-background-encryption-threads/index&quot;&gt;InnoDB 백그라운드 암호화 스레드&lt;/a&gt; 는 &lt;code&gt;.frm&lt;/code&gt; 파일 에서이 암호화 키 ID를 읽지 않습니다 . 대신 스레드는 ID가 &lt;code&gt;1&lt;/code&gt; 인 암호화 키를 사용하여 테이블을 암호화 할 수 있으며, 키가 지정되지 않은 경우 내부적으로 기본 암호화 키로 간주됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6f0c6d5371b49ad0d1a2e4a091f3fa7544ef3b82" translate="yes" xml:space="preserve">
          <source>As an &lt;a href=&quot;../aggregate-functions/index&quot;&gt;aggregate function&lt;/a&gt;:</source>
          <target state="translated">AS를 &lt;a href=&quot;../aggregate-functions/index&quot;&gt;집계 함수&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="b71097f132aa16e88528bd7b150c14cc56d4cf52" translate="yes" xml:space="preserve">
          <source>As an aid to portability between different databases, MariaDB supports executable comments. These special comments allow you to embed SQL code which will not execute when run on other databases, but will execute when run on MariaDB.</source>
          <target state="translated">다른 데이터베이스 간의 이식성을 돕기 위해 MariaDB는 실행 가능한 주석을 지원합니다. 이 특수 주석을 사용하면 다른 데이터베이스에서 실행될 때 실행되지 않지만 MariaDB에서 실행될 때 실행되는 SQL 코드를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ef0400edd9dab99b6c073d5876d368401a3a35a" translate="yes" xml:space="preserve">
          <source>As an alternative to the &lt;code&gt;&lt;a href=&quot;../information_schema/index&quot;&gt;INFORMATION_SCHEMA&lt;/a&gt;&lt;/code&gt; tables, the &lt;code&gt;userstat&lt;/code&gt; plugin also adds the &lt;code&gt;&lt;a href=&quot;../show-user-statistics/index&quot;&gt;SHOW USER_STATISTICS&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;../show-client-statistics/index&quot;&gt;SHOW CLIENT_STATISTICS&lt;/a&gt;, the &lt;/code&gt;&lt;a href=&quot;../show-index-statistics/index&quot;&gt;SHOW INDEX_STATISTICS&lt;/a&gt;&lt;code&gt;, and the &lt;/code&gt;&lt;a href=&quot;../show-table-statistics/index&quot;&gt;SHOW TABLE_STATISTICS&lt;/a&gt;&lt;code&gt; statements.&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../information_schema/index&quot;&gt;INFORMATION_SCHEMA&lt;/a&gt;&lt;/code&gt; 테이블 의 대안으로 &lt;code&gt;userstat&lt;/code&gt; 플러그인은 &lt;code&gt;&lt;a href=&quot;../show-user-statistics/index&quot;&gt;SHOW USER_STATISTICS&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../show-client-statistics/index&quot;&gt;SHOW CLIENT_STATISTICS&lt;/a&gt;, the &lt;/code&gt; &lt;a href=&quot;../show-index-statistics/index&quot;&gt;SHOW INDEX_STATISTICS &lt;/a&gt; &lt;code&gt;, and the &lt;/code&gt; &lt;a href=&quot;../show-table-statistics/index&quot;&gt;SHOW TABLE_STATISTICS &lt;/a&gt; &lt;code&gt; statements.&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1c94440904a4e3417abc3b1437b7582fc615f9cd" translate="yes" xml:space="preserve">
          <source>As an alternative, &lt;a href=&quot;../myisamchk/index&quot;&gt;myisamchk&lt;/a&gt; is a commandline tool for checking MyISAM tables when the tables are not being accessed.</source>
          <target state="translated">대안으로, &lt;a href=&quot;../myisamchk/index&quot;&gt;myisamchk&lt;/a&gt; 는 테이블에 액세스하지 않을 때 MyISAM 테이블을 확인하기위한 명령 줄 도구입니다.</target>
        </trans-unit>
        <trans-unit id="7528ddd574ca0520623d9deafe71efe23d97ded4" translate="yes" xml:space="preserve">
          <source>As an alternative, specific accounts can be referenced as follows.</source>
          <target state="translated">대안으로 특정 계정을 다음과 같이 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a792a93130736f8d9cf8a145c9dd8045988e12ee" translate="yes" xml:space="preserve">
          <source>As an alternative, the &lt;code&gt;&lt;a href=&quot;#unix_socket&quot;&gt;unix_socket&lt;/a&gt;&lt;/code&gt; option can also be set to &lt;code&gt;OFF&lt;/code&gt; by pairing the option with the &lt;code&gt;disable&lt;/code&gt;&lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-prefixes&quot;&gt;option prefix&lt;/a&gt;. For example:</source>
          <target state="translated">대안으로, &lt;code&gt;&lt;a href=&quot;#unix_socket&quot;&gt;unix_socket&lt;/a&gt;&lt;/code&gt; 옵션은 옵션과 &lt;code&gt;disable&lt;/code&gt; &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-prefixes&quot;&gt;옵션 접두어&lt;/a&gt; 를 쌍 으로 설정하여 &lt;code&gt;OFF&lt;/code&gt; 로 설정할 수도 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2532f301b8ef9ce43e36a3a4a825dc563a9fc162" translate="yes" xml:space="preserve">
          <source>As an alternative, we can partition the table by both year and month:</source>
          <target state="translated">대안으로, 우리는 연도와 월 단위로 테이블을 분할 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0293c4a83a55bf27b14fa1923b0c514ed794a76" translate="yes" xml:space="preserve">
          <source>As an example, by default, the character &lt;code&gt;y&lt;/code&gt; comes between &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;z&lt;/code&gt;, while in Lithuanian, it's sorted between &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;k&lt;/code&gt;. Similarly, the German phone book order is different to the German dictionary order, so while they share the same character set, the collation is different.</source>
          <target state="translated">예를 들어, 기본적으로 문자 &lt;code&gt;y&lt;/code&gt; 는 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;z&lt;/code&gt; 사이에 있으며 리투아니아어에서는 &lt;code&gt;i&lt;/code&gt; 와 &lt;code&gt;k&lt;/code&gt; 사이에 정렬 됩니다. 마찬가지로 독일어 전화 번호부 순서는 독일어 사전 순서와 다르므로 동일한 문자 집합을 공유하지만 데이터 정렬이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="089fc645cfa86cfdd6978006e9364dcf6e567dc0" translate="yes" xml:space="preserve">
          <source>As an example, here is how I start MariaDB when doing tests on Linux:</source>
          <target state="translated">예를 들어, Linux에서 테스트를 수행 할 때 MariaDB를 시작하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ca1fa6cc1b54ba7fd236b30b2336152194e2dba8" translate="yes" xml:space="preserve">
          <source>As an example, here is how you could display the contents of a &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt; file named &quot;mariadb-bin.000152&quot;:</source>
          <target state="translated">예를 들어, &quot;mariadb-bin.000152&quot;라는 &lt;a href=&quot;../binary-log/index&quot;&gt;이진 로그&lt;/a&gt; 파일 의 내용을 표시하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a1ca7a1aefd7f112f2f76e54cab7a942dcafbfbd" translate="yes" xml:space="preserve">
          <source>As an example, let's assume a routine, created by a superuser who's specified as the &lt;code&gt;DEFINER&lt;/code&gt;, deletes all records from a table. If &lt;code&gt;SQL SECURITY=DEFINER&lt;/code&gt;, anyone running the routine, regardless of whether they have delete privileges, will be able to delete the records. If &lt;code&gt;SQL SECURITY = INVOKER&lt;/code&gt;, the routine will only delete the records if the account invoking the routine has permission to do so.</source>
          <target state="translated">예를 들어, &lt;code&gt;DEFINER&lt;/code&gt; 로 지정된 수퍼 유저가 작성한 루틴 이 테이블에서 모든 레코드를 삭제 한다고 가정 합니다. &lt;code&gt;SQL SECURITY=DEFINER&lt;/code&gt; 인 경우 , 삭제 권한이 있는지 여부에 관계없이 루틴을 실행하는 사람은 누구나 레코드를 삭제할 수 있습니다. 경우 &lt;code&gt;SQL SECURITY = INVOKER&lt;/code&gt; 루틴을 호출하는 계정이 그렇게 할 수있는 권한이있는 경우, 루틴은 레코드 만 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="693541dc59130e978d9efe2ce559476a1a5519bd" translate="yes" xml:space="preserve">
          <source>As an example, one can think of a web shop, which provides real-time peeks into analytics data, like amazon's &quot;people who looked at this item, also looked at ...&quot; , or &quot;*today*'s best sellers in this category are ...&quot;, etc</source>
          <target state="translated">예를 들어, 아마존의 &quot;이 품목을 보거나 ...을 본 사람들&quot;또는 &quot;* 오늘 *의 베스트셀러&quot;와 같은 분석 데이터를 실시간으로 볼 수있는 웹 상점을 생각할 수 있습니다. 이 카테고리는 ... &quot;등입니다.</target>
        </trans-unit>
        <trans-unit id="855b676a8dd51f582878d7e9487f64e0e2b426e8" translate="yes" xml:space="preserve">
          <source>As an extra protection mechanism, the plain-text key file can be encrypted.</source>
          <target state="translated">추가 보호 메커니즘으로 일반 텍스트 키 파일을 암호화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2e148c06f7ddda2dffbd4afcd88ce914f065584" translate="yes" xml:space="preserve">
          <source>As currently implemented by MariaDB and by the SQL Standard, data may be truncated if not correctly cast. It is necessary to &lt;a href=&quot;../cast/index&quot;&gt;CAST&lt;/a&gt; the column to the correct width if the CTE's recursive part produces wider values for a column than the CTE's nonrecursive part. Some other DBMS give an error in this situation, and MariaDB's behavior may change in future - see &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-12325&quot;&gt;MDEV-12325&lt;/a&gt;. See the &lt;a href=&quot;#cast-to-avoid-data-truncation&quot;&gt;examples below&lt;/a&gt;.</source>
          <target state="translated">MariaDB 및 SQL 표준에 의해 현재 구현 된대로 올바르게 캐스트되지 않으면 데이터가 잘릴 수 있습니다. 필요가 &lt;a href=&quot;../cast/index&quot;&gt;CAST&lt;/a&gt; 열팽창 계수의 반복적 부분은 CTE의 재귀 부분보다 넓은 열에 대한 값을 생성하는 경우, 정확한 폭으로 열. 다른 DBMS는이 상황에서 오류를 발생시키고 MariaDB의 동작은 향후 변경 될 수 있습니다 ( &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-12325&quot;&gt;MDEV-12325&lt;/a&gt; 참조) . &lt;a href=&quot;#cast-to-avoid-data-truncation&quot;&gt;아래 예를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8c069a0ae7076cb6be2ff20b19134a55a0f39e27" translate="yes" xml:space="preserve">
          <source>As equiv. INT</source>
          <target state="translated">동등하게. INT</target>
        </trans-unit>
        <trans-unit id="3d6fb13744bb82acdea65718b2c242757600b419" translate="yes" xml:space="preserve">
          <source>As explained above, this works on &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt;, but produces a 1645 error since 10.0.</source>
          <target state="translated">위에서 설명한 것처럼 &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt; 에서는 작동 하지만 10.0 이후 1645 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="cc5e3710c9aa81a73031e6221063ea532365d544" translate="yes" xml:space="preserve">
          <source>As far as Index-only support is concerned, MyRocks distinguishes three kinds of collations:</source>
          <target state="translated">인덱스 전용 지원과 관련하여 MyRocks는 세 가지 유형의 데이터 정렬을 구분합니다.</target>
        </trans-unit>
        <trans-unit id="7deef92620f91db9d89b8f4c3f2b34752a03d9a7" translate="yes" xml:space="preserve">
          <source>As far as automatic table discovery is concerned, the tables, from the server point of view, may appear, disappear, or change structure anytime. Thus the server needs to be able to ask whether a given table exists and what its structure is. It needs to be notified when a table structure changes outside of the server. And it needs to be able to get a list of all (unknown to the server) tables, for statements like &lt;code&gt;SHOW TABLES&lt;/code&gt;. The server does all that by invoking specific methods of the &lt;code&gt;handlerton&lt;/code&gt;:</source>
          <target state="translated">자동 테이블 검색과 관련하여 서버 관점에서 볼 때마다 테이블이 나타나거나 사라지거나 구조가 변경 될 수 있습니다. 따라서 서버는 주어진 테이블이 존재하는지와 그 구조가 무엇인지 물어볼 수 있어야합니다. 서버 외부에서 테이블 구조가 변경되면이를 알려야합니다. 그리고 &lt;code&gt;SHOW TABLES&lt;/code&gt; 와 같은 명령문에 대해 모든 (서버에 알려지지 않은) 테이블 목록을 가져올 수 있어야합니다 . 서버는 &lt;code&gt;handlerton&lt;/code&gt; 특정 메소드를 호출하여 모든 것을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="3599f427f28171376b4d1ee9961527454a03894d" translate="yes" xml:space="preserve">
          <source>As for &lt;code&gt;EXPLAIN&lt;/code&gt;, it will give no indication whether filesort uses priority queue or the generic quicksort and merge algorithm. &lt;code&gt;Using filesort&lt;/code&gt; will be shown in both cases, by both MariaDB and MySQL.</source>
          <target state="translated">&lt;code&gt;EXPLAIN&lt;/code&gt; 에 대해서는 파일 분류 가 우선 순위 대기열을 사용하는지 일반 퀵 정렬 및 병합 알고리즘을 사용하는지 여부를 표시하지 않습니다. &lt;code&gt;Using filesort&lt;/code&gt; 은 MariaDB와 MySQL 모두에 의해 두 경우 모두에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="852550bcc9abade8aa50168e104988fa11f8e431" translate="yes" xml:space="preserve">
          <source>As for ODBC, the columns definition can be omitted and will be retrieved by the discovery process. The restrictions concerning column definitions are the same as for ODBC.</source>
          <target state="translated">ODBC의 경우 열 정의를 생략 할 수 있으며 감지 프로세스에 의해 검색됩니다. 열 정의와 관련된 제한 사항은 ODBC와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="500f79d26146fbd8198cb0e8152b2f2017fcc6de" translate="yes" xml:space="preserve">
          <source>As for execution costs, we're going to read 15 rows from table City, write 15 rows to materialized table, read them back (the optimizer assumes there won't be any duplicates), and then do 15 eq_ref accesses to table Country. In total, we'll do 45 reads and 15 writes.</source>
          <target state="translated">실행 비용에 대해서는 City 테이블에서 15 행을 읽고 구체화 된 테이블에 15 행을 쓰고 다시 읽은 다음 (최적화자는 중복이 없다고 가정) 테이블 Country에 15 개의 eq_ref 액세스를 수행합니다. 총 45 개의 읽기와 15 개의 쓰기를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="2cc23691ab63f73dde851b2827d8cfd94bb0a060" translate="yes" xml:space="preserve">
          <source>As in the example above, the partition ranged from 1992-01-01 to 1998-08-02. Potentially it may be desirable to drop the remaining 1998 rows.</source>
          <target state="translated">위의 예에서와 같이 파티션의 범위는 1992-01-01에서 1998-08-02까지였습니다. 나머지 1998 행을 삭제하는 것이 바람직 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9dce344d61632dedf40dbdd477c029fd7f25c2c" translate="yes" xml:space="preserve">
          <source>As little copying as possible under higher level stages/locks. For example, .frm (dictionary) and .trn (trigger) files should be copying while copying the table data.</source>
          <target state="translated">높은 수준의 단계 / 잠금에서는 가능한 한 적은 복사. 예를 들어, 테이블 데이터를 복사하는 동안 .frm (사전) 및 .trn (트리거) 파일을 복사해야합니다.</target>
        </trans-unit>
        <trans-unit id="a0f83607256b048c7132beb41ff74b13fe0fc22e" translate="yes" xml:space="preserve">
          <source>As long as the table format file &lt;code&gt;tbl_name.frm&lt;/code&gt; is valid, the table can be re-created as an empty table with &lt;code&gt;TRUNCATE TABLE&lt;/code&gt;, even if the data or index files have become corrupted.</source>
          <target state="translated">테이블 형식 파일 &lt;code&gt;tbl_name.frm&lt;/code&gt; 이 유효 하면 데이터 또는 인덱스 파일이 손상된 경우에도 &lt;code&gt;TRUNCATE TABLE&lt;/code&gt; 을 사용 하여 테이블을 빈 테이블로 다시 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="121e5c3b03c2ac77af16d81a26ac4976e5630496" translate="yes" xml:space="preserve">
          <source>As mcsimport is built upon ColumnStore's &lt;a href=&quot;../columnstore-bulk-write-sdk/index&quot;&gt;Bulk Write SDK&lt;/a&gt; it inherits its methods to connect to ColumnStore instances to ingest data. By default mcsimport uses the standard configuration file &lt;em&gt;/usr/local/mariadb/ColumnStore/etc/Columnstore.xml&lt;/em&gt; or if set the one defined through the environment variable &lt;em&gt;COLUMNSTORE_INSTALL_DIR&lt;/em&gt; to connect to the remote Columnstore instance. Individual configurations can be defined through the command line parameter -c. Instructions on how to prepare Columnstore.xml for remote ingestion can be found &lt;a href=&quot;../columnstore-bulk-write-sdk/index#environment-configuration&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">mcsimport는 ColumnStore의 &lt;a href=&quot;../columnstore-bulk-write-sdk/index&quot;&gt;대량 쓰기 SDK를 기반으로&lt;/a&gt; 하므로 데이터를 수집하기 위해 ColumnStore 인스턴스에 연결하는 메소드를 상속합니다. 기본적으로 mcsimport는 표준 구성 파일 &lt;em&gt;/usr/local/mariadb/ColumnStore/etc/Columnstore.xml을 사용&lt;/em&gt; 하거나 환경 변수 &lt;em&gt;COLUMNSTORE_INSTALL_DIR&lt;/em&gt; 을 통해 정의 된 것을 설정 하여 원격 Columnstore 인스턴스에 연결합니다. 개별 구성은 명령 행 매개 변수 -c를 통해 정의 할 수 있습니다. 원격 수집을 위해 Columnstore.xml을 준비하는 방법에 대한 지침은 &lt;a href=&quot;../columnstore-bulk-write-sdk/index#environment-configuration&quot;&gt;여기를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7b784322050d07a83f6459019723a20a836323c6" translate="yes" xml:space="preserve">
          <source>As mcsimport is using the &lt;a href=&quot;../columnstore-bulk-write-sdk/index&quot;&gt;Bulk Write SDK&lt;/a&gt; for the injection, all ports required by the ColumnStore Bulk write SDK need to be accessible from the client executing mcsimport at the target ColumnStore server. These are in particular the TCP ports 8616, 8630, and 8800.</source>
          <target state="translated">mcsimport가 사용되기 때문에 &lt;a href=&quot;../columnstore-bulk-write-sdk/index&quot;&gt;대량 쓰기 SDK&lt;/a&gt; 주입에 대한을의 ColumnStore 대량 쓰기 SDK의 필요에 의해 요구되는 모든 포트는 대상 ColumnStore 서버에서 mcsimport을 실행하는 클라이언트에서 액세스 할 수 있습니다. 이들은 특히 TCP 포트 8616, 8630 및 8800입니다.</target>
        </trans-unit>
        <trans-unit id="35b1eaca7e64761d76fb13b5ac1cdb83080501e4" translate="yes" xml:space="preserve">
          <source>As mentioned &lt;a href=&quot;https://lists.launchpad.net/maria-discuss/msg00698.html&quot;&gt;here&lt;/a&gt; (and in &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-4080&quot;&gt;MDEV-4080&lt;/a&gt; and &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-3882&quot;&gt;MDEV-3882&lt;/a&gt;) sometimes APT will refuse to install MariaDB. Or, if MariaDB is already installed, suggest the removal of MariaDB to apply an upgrade to the &lt;code&gt;mysql-common&lt;/code&gt; or &lt;code&gt;libmysqlclient&lt;/code&gt; packages. This happens whenever the version number of those two packages is higher in the distribution repositories than the versions in the MariaDB repositories. Most MariaDB packages have different names than their MySQL counterparts, but in order for upgrades from MySQL to MariaDB to be successful in APT, those two packages must be named the same. Because they have the same names, APT just checks the version numbers and tries to install what it considers to be the most recent.</source>
          <target state="translated">&lt;a href=&quot;https://lists.launchpad.net/maria-discuss/msg00698.html&quot;&gt;여기에&lt;/a&gt; 언급 된 바와 같이 (그리고 &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-4080&quot;&gt;MDEV-4080&lt;/a&gt; 및 &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-3882&quot;&gt;MDEV-3882에서&lt;/a&gt; ) 때때로 APT는 MariaDB 설치를 거부합니다. 또는 MariaDB가 이미 설치되어있는 경우 MariaDB를 제거하여 &lt;code&gt;mysql-common&lt;/code&gt; 또는 &lt;code&gt;libmysqlclient&lt;/code&gt; 패키지에 업그레이드를 적용 하십시오. 이 두 패키지의 버전 번호가 MariaDB 리포지토리의 버전보다 배포 리포지토리에서 더 높을 때마다 발생합니다. 대부분의 MariaDB 패키지는 MySQL과 다른 이름을 갖지만 APT에서 MySQL에서 MariaDB로 업그레이드하려면 두 패키지의 이름을 동일하게 지정해야합니다. APT는 이름이 같기 때문에 버전 번호 만 확인하고 최신 버전으로 설치하려고합니다.</target>
        </trans-unit>
        <trans-unit id="20d385a6f35afd88ec44ee7ccf414920c6f2cb40" translate="yes" xml:space="preserve">
          <source>As mentioned above, even though InnoDB is allowing the table to be created, there is still an opportunity for errors. Regardless of whether &lt;a href=&quot;../innodb-strict-mode/index&quot;&gt;InnoDB strict mode&lt;/a&gt; is enabled, if a &lt;a href=&quot;../data-manipulation/index&quot;&gt;DML&lt;/a&gt; statement is executed that attempts to write a row that the table's InnoDB row format can't store, then InnoDB will raise an &lt;strong&gt;error&lt;/strong&gt; with this message. This creates a somewhat &lt;em&gt;unsafe&lt;/em&gt; situation, because it means that the application has the chance to encounter an additional error while executing &lt;a href=&quot;../data-manipulation/index&quot;&gt;DML&lt;/a&gt;.</source>
          <target state="translated">위에서 언급했듯이 InnoDB가 테이블 생성을 허용하더라도 여전히 오류가 발생할 수 있습니다. &lt;a href=&quot;../innodb-strict-mode/index&quot;&gt;InnoDB 엄격 모드의&lt;/a&gt; 활성화 여부에 관계없이 , 테이블의 InnoDB 행 형식으로 저장할 수없는 행을 쓰려고 하는 &lt;a href=&quot;../data-manipulation/index&quot;&gt;DML&lt;/a&gt; 문이 실행되면 InnoDB는 이 메시지와 함께 &lt;strong&gt;오류&lt;/strong&gt; 를 &lt;strong&gt;발생시킵니다&lt;/strong&gt; . 이것은 다소 &lt;em&gt;안전하지 않은&lt;/em&gt; 상황을 만듭니다. 이는 애플리케이션이 &lt;a href=&quot;../data-manipulation/index&quot;&gt;DML&lt;/a&gt; 을 실행하는 동안 추가 오류가 발생할 가능성이 있기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="266b7934159b7ea9aa2935c92a6601e537ff41e0" translate="yes" xml:space="preserve">
          <source>As mentioned above, the operation works at partition granularity, which means that a minimal move is 64 million rows. Any table smaller than that will not be redistributed and there may be as much as one full Partition difference in the resulting balance. The redistribute logic does not currently consolidate individually deleted records.</source>
          <target state="translated">위에서 언급했듯이 작업은 파티션 단위로 작동하므로 최소 이동은 6 천 6 백만 행입니다. 이보다 작은 테이블은 재분배되지 않으며 결과 잔액에 최대 파티션 차이가있을 수 있습니다. 재배포 논리는 현재 개별적으로 삭제 된 레코드를 통합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fa568a27590c544dfcbdb9f4cb22a4c526dac2f5" translate="yes" xml:space="preserve">
          <source>As mentioned in the previous section, in &lt;a href=&quot;../what-is-mariadb-101/index&quot;&gt;MariaDB 10.1&lt;/a&gt; and above, Galera Cluster support is actually included in the standard MariaDB Server packages. That means that installing MariaDB Galera Cluster package is the same as installing standard MariaDB Server package in those versions. However, you will also have to install an additional package to obtain the Galera wsrep provider library.</source>
          <target state="translated">이전 섹션에서 언급 한 것처럼 &lt;a href=&quot;../what-is-mariadb-101/index&quot;&gt;MariaDB 10.1&lt;/a&gt; 이상에서 Galera Cluster 지원은 실제로 표준 MariaDB 서버 패키지에 포함되어 있습니다. 즉, MariaDB Galera Cluster 패키지 설치는 해당 버전의 표준 MariaDB 서버 패키지 설치와 동일합니다. 그러나 Galera wsrep 제공자 라이브러리를 얻으려면 추가 패키지를 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="aa2968977a1aa44fbe27e8cf01150da1b8f62dcc" translate="yes" xml:space="preserve">
          <source>As mentioned previously, on most servers upgrading from 10.0 should be painless. However, there are some things that have changed which could affect an upgrade:</source>
          <target state="translated">앞에서 언급했듯이 10.0에서 업그레이드하는 대부분의 서버에서는 고통이 없습니다. 그러나 업그레이드에 영향을 줄 수있는 변경 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8140266e017604701ae56b7856719e92ac1dac10" translate="yes" xml:space="preserve">
          <source>As mentioned previously, on most servers upgrading from 5.5 should be painless. However, there are some things that have changed which could affect an upgrade:</source>
          <target state="translated">앞에서 언급했듯이 5.5에서 업그레이드하는 대부분의 서버에서 어려움이 없어야합니다. 그러나 업그레이드에 영향을 줄 수있는 변경 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c085864f3f895612f111bd199a9ab97697dacea0" translate="yes" xml:space="preserve">
          <source>As noted in &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-4266&quot;&gt;MDEV-4266&lt;/a&gt;, the &lt;code&gt;mariadb-server&lt;/code&gt; and &lt;code&gt;mariadb-client&lt;/code&gt; packages have a minor upgrade issue if you use '&lt;code&gt;apt-get install mariadb-server&lt;/code&gt;' or '&lt;code&gt;apt-get install mariadb-client&lt;/code&gt;' to upgrade them instead of the more common '&lt;code&gt;apt-get upgrade&lt;/code&gt;'. This is because those two packages depend on &lt;code&gt;mariadb-server-5.5&lt;/code&gt; and &lt;code&gt;mariadb-client-5.5&lt;/code&gt; with no specific version of those packages. For example, if you have the &lt;code&gt;mariadb-server&lt;/code&gt; package installed, version 5.5.29 and you install version 5.5.30 of that package it will not automatically upgrade the &lt;code&gt;mariadb-server-5.5&lt;/code&gt; package to version 5.5.30 like you would expect because the 5.5.29 version of that package satisfies the dependency.</source>
          <target state="translated">에서 언급 한 바와 같이 &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-4266&quot;&gt;인 mdev-4266&lt;/a&gt; 의 &lt;code&gt;mariadb-server&lt;/code&gt; 와 &lt;code&gt;mariadb-client&lt;/code&gt; 당신이 사용하는 경우 패키지는 마이너 업그레이드 문제가 ' &lt;code&gt;apt-get install mariadb-server&lt;/code&gt; ' '또는 &lt;code&gt;apt-get install mariadb-client&lt;/code&gt; 더 대신 그들을 업그레이드' 일반적인 ' &lt;code&gt;apt-get upgrade&lt;/code&gt; '. 그 두 패키지 는 특정 버전의 패키지가없는 &lt;code&gt;mariadb-server-5.5&lt;/code&gt; 및 &lt;code&gt;mariadb-client-5.5&lt;/code&gt; 에 의존하기 때문 입니다. 예를 들어, &lt;code&gt;mariadb-server&lt;/code&gt; 패키지 버전 5.5.29가 설치되어 있고 해당 패키지의 버전 5.5.30을 설치하면 &lt;code&gt;mariadb-server-5.5&lt;/code&gt; 가 자동으로 업그레이드되지 않습니다. 해당 패키지의 5.5.29 버전이 종속성을 충족하므로 패키지를 버전 5.5.30으로 업그레이드하십시오.</target>
        </trans-unit>
        <trans-unit id="9837957820579a6eff3f2b0644b5fdeaa80757c4" translate="yes" xml:space="preserve">
          <source>As noted on the Preparing guide, you can installing MariaDB ColumnStore with the use of soft-links. If you have the softlinks be setup at the Data Directory Levels, like mariadb/columnstore/data and mariadb/columnstore/dataX, then your upgrade will happen without any issues. In the case where you have a softlink at the top directory, like /usr/local/mariadb, you will need to upgrade using the binary package. If you updating using the rpm package and tool, this softlink will be deleted when you perform the upgrade process and the upgrade will fail.</source>
          <target state="translated">준비 안내서에 설명 된대로 소프트 링크를 사용하여 MariaDB ColumnStore를 설치할 수 있습니다. mariadb / columnstore / data 및 mariadb / columnstore / dataX와 같은 데이터 디렉토리 수준에서 소프트 링크를 설정 한 경우 문제없이 업그레이드가 수행됩니다. 최상위 디렉토리에 / usr / local / mariadb와 같은 소프트 링크가있는 경우 바이너리 패키지를 사용하여 업그레이드해야합니다. rpm 패키지 및 도구를 사용하여 업데이트하면 업그레이드 프로세스를 수행 할 때이 소프트 링크가 삭제되고 업그레이드가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="7e06237a788a2d4eb70fd1ca14d5a7eb64587c8c" translate="yes" xml:space="preserve">
          <source>As of &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt; PBXT is not built by default any longer.</source>
          <target state="translated">현재 &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt; PBXT은 더 이상 기본적으로 내장되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="43a10ff1dd914f44f186cc54ef80be648389d4dd" translate="yes" xml:space="preserve">
          <source>As of &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt;, the return value is a nonbinary string in the connection &lt;a href=&quot;../data-types-character-sets-and-collations/index&quot;&gt;character set and collation&lt;/a&gt;, determined by the values of the &lt;a href=&quot;../server-system-variables/index#character_set_connection&quot;&gt;character_set_connection&lt;/a&gt; and &lt;a href=&quot;../server-system-variables/index#collation_connection&quot;&gt;collation_connection&lt;/a&gt; system variables. Before 5.5, the return value was a binary string.</source>
          <target state="translated">현재 &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt; , 반환 값은 접속에 이진이 아닌 문자열 &lt;a href=&quot;../data-types-character-sets-and-collations/index&quot;&gt;의 문자 세트 및 정렬&lt;/a&gt; 의 값에 의해 결정 &lt;a href=&quot;../server-system-variables/index#character_set_connection&quot;&gt;character_set_connection을&lt;/a&gt; 하고 &lt;a href=&quot;../server-system-variables/index#collation_connection&quot;&gt;이 collation_connection의&lt;/a&gt; 시스템 변수. 5.5 이전에는 반환 값이 이진 문자열이었습니다.</target>
        </trans-unit>
        <trans-unit id="9bd1778fc1f3aed8328820fb4905ecc958952422" translate="yes" xml:space="preserve">
          <source>As of &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10136-release-notes/&quot;&gt;MariaDB 10.1.36&lt;/a&gt;, &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10218-release-notes/&quot;&gt;MariaDB 10.2.18&lt;/a&gt;, and &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10310-release-notes/&quot;&gt;MariaDB 10.3.10&lt;/a&gt;, &lt;code&gt;&lt;a href=&quot;https://www.stunnel.org&quot;&gt;stunnel&lt;/a&gt;&lt;/code&gt; can be used to encrypt data over the wire. Be sure to have &lt;code&gt;stunnel&lt;/code&gt; installed. You will also need to generate certificates and keys. See &lt;a href=&quot;https://www.stunnel.org/howto.html&quot;&gt;the stunnel documentation&lt;/a&gt; for information on how to do that. Once you have the keys, you will need to add the &lt;code&gt;tkey&lt;/code&gt; and &lt;code&gt;tcert&lt;/code&gt; options to the &lt;code&gt;[sst]&lt;/code&gt; option group in your MariaDB configuration file, such as:</source>
          <target state="translated">현재로 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10136-release-notes/&quot;&gt;MariaDB 10.1.36&lt;/a&gt; , &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10218-release-notes/&quot;&gt;MariaDB 10.2.18&lt;/a&gt; 및 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10310-release-notes/&quot;&gt;MariaDB 10.3.10&lt;/a&gt; , &lt;code&gt;&lt;a href=&quot;https://www.stunnel.org&quot;&gt;stunnel&lt;/a&gt;&lt;/code&gt; 로 유선으로 데이터를 암호화하기 위해 사용될 수있다. &lt;code&gt;stunnel&lt;/code&gt; 이 설치되어 있는지 확인하십시오 . 인증서와 키도 생성해야합니다. 이를 수행하는 방법에 대한 정보 &lt;a href=&quot;https://www.stunnel.org/howto.html&quot;&gt;는 stunnel 문서&lt;/a&gt; 를 참조하십시오 . 당신은 키가 있으면, 당신은 추가해야합니다 &lt;code&gt;tkey&lt;/code&gt; 및 &lt;code&gt;tcert&lt;/code&gt; 받는 옵션 &lt;code&gt;[sst]&lt;/code&gt; 와 같은, 당신의 MariaDB 구성 파일에 옵션 그룹 :</target>
        </trans-unit>
        <trans-unit id="8d21e568620fd5b91c9c92f8e8225bce6e694582" translate="yes" xml:space="preserve">
          <source>As of &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-522-release-notes/&quot;&gt;MariaDB 5.2.2&lt;/a&gt;, the Sphinx storage engine is included in the source, binaries, and packages of MariaDB. SphinxSE is built as a dynamically loadable .so plugin. To use it you need to perform a one-time &lt;code&gt;&lt;a href=&quot;../install-plugin/index&quot;&gt;INSTALL PLUGIN&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">현재 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-522-release-notes/&quot;&gt;MariaDB 5.2.2&lt;/a&gt; 스핑크스 스토리지 엔진은 MariaDB의 소스, 바이너리 및 패키지에 포함된다. SphinxSE는 동적으로로드 가능한 .so 플러그인으로 빌드됩니다. 이를 사용하려면 일회성 &lt;code&gt;&lt;a href=&quot;../install-plugin/index&quot;&gt;INSTALL PLUGIN&lt;/a&gt;&lt;/code&gt; 을 수행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e9018aa1c3ffb533e1d8f957fc0876cc003850f1" translate="yes" xml:space="preserve">
          <source>As of file systems: currently XFS is expected to yield the best performance with MariaDB. However depending on the exact kernel version and version of XFS code in use, one might be affected by &lt;a href=&quot;http://www.mysqlperformanceblog.com/2012/03/15/ext4-vs-xfs-on-ssd/comment-page-1/#comment-903938&quot;&gt;a bug that severely limits XFS performance in concurrent environments&lt;/a&gt;. This has &lt;a href=&quot;https://github.com/torvalds/linux/commit/507630b29f13a3d8689895618b12015308402e22&quot;&gt;been fixed in kernel versions above 3.5&lt;/a&gt; or &lt;a href=&quot;https://rhn.redhat.com/errata/RHSA-2013-0496.html&quot;&gt;RHEL6 kernels kernel-2.6.32-358 or later&lt;/a&gt; (because of &lt;a href=&quot;https://bugzilla.redhat.com/show_bug.cgi?id=807503&quot;&gt;bug 807503 being fixed)&lt;/a&gt;.</source>
          <target state="translated">파일 시스템 기준 : 현재 XFS는 MariaDB와 함께 최고의 성능을 제공 할 것으로 예상됩니다. 그러나 사용중인 XFS 코드의 정확한 커널 버전과 버전에 따라 영향을받을 수 있습니다.&lt;a href=&quot;http://www.mysqlperformanceblog.com/2012/03/15/ext4-vs-xfs-on-ssd/comment-page-1/#comment-903938&quot;&gt; 동시 환경에서 XFS 성능을 심각하게 제한하는 버그의&lt;/a&gt; . 이것은 &lt;a href=&quot;https://bugzilla.redhat.com/show_bug.cgi?id=807503&quot;&gt;버그 807503이 수정&lt;/a&gt; 되었기 때문에 &lt;a href=&quot;https://github.com/torvalds/linux/commit/507630b29f13a3d8689895618b12015308402e22&quot;&gt;3.5&lt;/a&gt; 이상의 커널 버전 또는 &lt;a href=&quot;https://rhn.redhat.com/errata/RHSA-2013-0496.html&quot;&gt;RHEL6 커널 kernel-2.6.32-358 이상 &lt;/a&gt;에서 수정되었습니다 .</target>
        </trans-unit>
        <trans-unit id="050498bbade69928177d51d24ac615de72b18bd0" translate="yes" xml:space="preserve">
          <source>As of version 2.3 &lt;code&gt;--password&lt;/code&gt; can take the password on the command line like &lt;code&gt;--password FOO&lt;/code&gt;. Using &lt;code&gt;--password&lt;/code&gt; alone without giving a password on the command line causes mysqlreport to prompt for a password.</source>
          <target state="translated">버전 2.3부터 &lt;code&gt;--password&lt;/code&gt; 는 명령 줄에서 &lt;code&gt;--password FOO&lt;/code&gt; 와 같은 암호를 사용할 수 있습니다 . 명령 행에서 비밀번호를 제공하지 않고 &lt;code&gt;--password&lt;/code&gt; 만 사용 하면 mysqlreport가 비밀번호를 묻는 프롬프트를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="daae0fea89634d6a1810f547b065f100f47f850f" translate="yes" xml:space="preserve">
          <source>As part of the Preparing for Install, the GlusterFS third party package would have already been installed on all of the PM servers within this system. During the running of postConfigure, the user will be required to enter some Data Replication options based on the type of system you want. Example is number of copies of the Database you would like to have maintained across the PM servers.</source>
          <target state="translated">설치 준비의 일환으로 GlusterFS 타사 패키지는이 시스템의 모든 PM 서버에 이미 설치되었을 것입니다. postConfigure를 실행하는 동안 사용자는 원하는 시스템 유형에 따라 일부 데이터 복제 옵션을 입력해야합니다. 예를 들어 PM 서버에서 유지 관리하려는 데이터베이스의 사본 수입니다.</target>
        </trans-unit>
        <trans-unit id="cbae6eaa9ce0dfba27057c55442f10096a114a71" translate="yes" xml:space="preserve">
          <source>As part of the upgrade process to 1.2.1, the user is required to run the mysql_upgrade script on all of the following nodes.</source>
          <target state="translated">1.2.1 로의 업그레이드 프로세스의 일부로 사용자는 다음 모든 노드에서 mysql_upgrade 스크립트를 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="501ab72dcb947ad6b0c1acf0ba544a3fcf7cb272" translate="yes" xml:space="preserve">
          <source>As part of the upgrade process to 1.2.2, the user is required to run the mysql_upgrade script on all of the following nodes.</source>
          <target state="translated">1.2.2 로의 업그레이드 프로세스의 일부로 사용자는 다음 모든 노드에서 mysql_upgrade 스크립트를 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="08e50c4f6bbff871e150cf2b2ae0105b46d2d036" translate="yes" xml:space="preserve">
          <source>As part of the upgrade process to 1.2.3, the user is required to run the mysql_upgrade script on all of the following nodes.</source>
          <target state="translated">1.2.3으로의 업그레이드 프로세스의 일부로 사용자는 다음 모든 노드에서 mysql_upgrade 스크립트를 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="e15b7ba8bfa11e844d6fb4159ed5bf0c7fcd02a1" translate="yes" xml:space="preserve">
          <source>As part of the upgrade process to 1.2.4, the user is might be required to run the mysql_upgrade script on all of the following nodes.</source>
          <target state="translated">1.2.4 로의 업그레이드 프로세스의 일부로 사용자는 다음 모든 노드에서 mysql_upgrade 스크립트를 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="e1563805b83308ea1e757ddbdbdd36563d3fad39" translate="yes" xml:space="preserve">
          <source>As part of the upgrade process to 1.2.4, the user is required to run the mysql_upgrade script on all of the following nodes.</source>
          <target state="translated">1.2.4 로의 업그레이드 프로세스의 일부로 사용자는 다음 모든 노드에서 mysql_upgrade 스크립트를 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="ecac838ba78d99b358997f2879bb2c3158b9fcde" translate="yes" xml:space="preserve">
          <source>As part of the upgrade process to 1.2.5, the user is might be required to run the mysql_upgrade script on all of the following nodes.</source>
          <target state="translated">1.2.5 로의 업그레이드 프로세스의 일부로 사용자는 다음 모든 노드에서 mysql_upgrade 스크립트를 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="80f370ecb9ab028ca6e6669880eb8f51feee6361" translate="yes" xml:space="preserve">
          <source>As part of the upgrade process to 1.2.5, the user is required to run the mysql_upgrade script on all of the following nodes.</source>
          <target state="translated">1.2.5 로의 업그레이드 프로세스의 일부로 사용자는 다음 모든 노드에서 mysql_upgrade 스크립트를 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="fabd4a805d88ff8267d62083ea9d78c83e5fcaba" translate="yes" xml:space="preserve">
          <source>As part of the upgrade process, the user is required to run the mysql_upgrade script on all of the following nodes.</source>
          <target state="translated">업그레이드 프로세스의 일부로 사용자는 다음 모든 노드에서 mysql_upgrade 스크립트를 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="d2ee89db17ccae51db0d525de047ed796252fc29" translate="yes" xml:space="preserve">
          <source>As part of zerofilling no vital data is removed.</source>
          <target state="translated">제로 채우기의 일부로 중요한 데이터가 제거되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="975d1be7d7b696645fd4e5008fb07ad8195bf0c8" translate="yes" xml:space="preserve">
          <source>As said above, use InnoDB only. However, here is more info on the MyISAM (and hence FULLTEXT, SPATIAL, etc) issues.</source>
          <target state="translated">위에서 말했듯이 InnoDB 만 사용하십시오. 그러나 다음은 MyISAM (및 FULLTEXT, SPATIAL 등) 문제에 대한 자세한 정보입니다.</target>
        </trans-unit>
        <trans-unit id="eaddfa1d0824d47b847c0397d4125b528aeef144" translate="yes" xml:space="preserve">
          <source>As seen above, the entired definition string, including the &quot;CREATE PROCEDURE&quot; (or &quot;FUNCTION&quot;) is kept. The procedure definition string is stored in the table mysql.proc with the name and type as the key, the type being one of the enum (&quot;procedure&quot;,&quot;function&quot;).</source>
          <target state="translated">위에서 볼 수 있듯이 &quot;CREATE PROCEDURE&quot;(또는 &quot;FUNCTION&quot;)를 포함한 전체 정의 문자열이 유지됩니다. 프로 시저 정의 문자열은 이름과 유형을 키로하여 mysql.proc 테이블에 저장되며, 유형은 열거 형 중 하나입니다 ( &quot;procedure&quot;, &quot;function&quot;).</target>
        </trans-unit>
        <trans-unit id="0a85bb41ce4715ea1ad35fc65352a2aa7d675b7b" translate="yes" xml:space="preserve">
          <source>As seen in the example above, both query text and search options should be put into the '&lt;code&gt;WHERE&lt;/code&gt;' clause of the search query column (i.e. the 3rd column); the options are separated by semicolons ('&lt;code&gt;;&lt;/code&gt;') and separate names from values using an equals sign ('&lt;code&gt;=&lt;/code&gt;'). Any number of options can be specified. Available options are:</source>
          <target state="translated">위의 예에서 볼 수 있듯이 쿼리 텍스트와 검색 옵션은 모두 검색 쿼리 열의 ' &lt;code&gt;WHERE&lt;/code&gt; '절에 있어야합니다 (예 : 세 번째 열). 옵션은 세미콜론 ( ' &lt;code&gt;;&lt;/code&gt; ')으로 구분되고 등호 ( ' &lt;code&gt;=&lt;/code&gt; ')를 . 여러 옵션을 지정할 수 있습니다. 사용 가능한 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="864beef47ea6d91b17b50e6fd4220926f74dfd43" translate="yes" xml:space="preserve">
          <source>As specified in the OPTION_LIST or NULL if not specified.</source>
          <target state="translated">OPTION_LIST에 지정된대로 또는 지정되지 않은 경우 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="8656e252c3cb1e680a3347104454fc600c20840b" translate="yes" xml:space="preserve">
          <source>As stated above, consult your distribution's documentation for more information on starting services like MariaDB at system startup.</source>
          <target state="translated">위에서 언급 한 것처럼 시스템 시작시 MariaDB와 같은 서비스 시작에 대한 자세한 내용은 배포판 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="12a43be62bd759e1c5510d032e9c8e2c3aa0b45e" translate="yes" xml:space="preserve">
          <source>As stated, a &lt;code&gt;DELETE&lt;/code&gt; statement with no &lt;code&gt;WHERE&lt;/code&gt; clause deletes all rows. A faster way to do this, when you do not need to know the number of deleted rows, is to use &lt;code&gt;TRUNCATE TABLE&lt;/code&gt;. However, within a transaction or if you have a lock on the table, &lt;code&gt;TRUNCATE TABLE&lt;/code&gt; cannot be used whereas &lt;code&gt;DELETE&lt;/code&gt; can. See &lt;code&gt;&lt;a href=&quot;../truncate-table/index&quot;&gt;TRUNCATE TABLE&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../lock/index&quot;&gt;LOCK&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">언급 한대로 &lt;code&gt;WHERE&lt;/code&gt; 절이 없는 &lt;code&gt;DELETE&lt;/code&gt; 문은 모든 행을 삭제합니다. 삭제 된 행 수를 알 필요가없는 경우 &lt;code&gt;TRUNCATE TABLE&lt;/code&gt; 을 사용하는 것이 가장 빠른 방법 입니다. 그러나 트랜잭션 내에서 또는 테이블에 잠금이있는 경우 &lt;code&gt;TRUNCATE TABLE&lt;/code&gt; 을 사용할 수 없지만 &lt;code&gt;DELETE&lt;/code&gt; 는 사용할 수 있습니다. &lt;code&gt;&lt;a href=&quot;../truncate-table/index&quot;&gt;TRUNCATE TABLE&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../lock/index&quot;&gt;LOCK&lt;/a&gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8fe3911bbc49c21a60408707bd5392dfd065140d" translate="yes" xml:space="preserve">
          <source>As synonym for &lt;code&gt;DESCRIBE&lt;/code&gt; or &lt;code&gt;SHOW COLUMNS FROM&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;DESCRIBE&lt;/code&gt; 또는 &lt;code&gt;SHOW COLUMNS FROM&lt;/code&gt; 의 동의어 :</target>
        </trans-unit>
        <trans-unit id="0bbfda1750693f74b77f6da472454fa81e8ee03a" translate="yes" xml:space="preserve">
          <source>As this is a direct interface to the storage engine, some limitations may apply for what you can do and what happens if the table changes. Here follows some of the common limitations:</source>
          <target state="translated">이는 스토리지 엔진에 대한 직접 인터페이스이므로 수행 할 수있는 작업과 테이블이 변경 될 때 발생하는 작업에 일부 제한이 적용될 수 있습니다. 다음은 일반적인 제한 사항 중 일부입니다.</target>
        </trans-unit>
        <trans-unit id="ff1fe28a91c6bd4c9784f3669c128f02be57d7e8" translate="yes" xml:space="preserve">
          <source>As usual, you can pass other mysqld parameters on the command line, or store them in a my.ini configuraton file and pass &lt;code&gt;--defaults-file=path\to\my.ini&lt;/code&gt;</source>
          <target state="translated">평소와 같이 명령 행에서 다른 mysqld 매개 변수를 전달하거나 my.ini 구성 파일에 저장하고 &lt;code&gt;--defaults-file=path\to\my.ini&lt;/code&gt; 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3317bf53139ccfb690a91afda6691cd7e0b8e5a7" translate="yes" xml:space="preserve">
          <source>As was shown above, Multi Range Read requires sort buffers to operate. The size of the buffers is limited by system variables. If MRR has to process more data than it can fit into its buffer, it will break the scan into multiple passes. The more passes are made, the less is the speedup though, so one needs to balance between having too big buffers (which consume lots of memory) and too small buffers (which limit the possible speedup).</source>
          <target state="translated">위에 표시된 것처럼 Multi Range Read에는 정렬 버퍼가 작동해야합니다. 버퍼의 크기는 시스템 변수에 의해 제한됩니다. MRR이 버퍼에 들어갈 수있는 것보다 많은 데이터를 처리해야하는 경우 스캔을 여러 단계로 나눕니다. 패스가 많을수록 속도가 느려지므로 너무 큰 버퍼 (많은 메모리를 소비)와 너무 작은 버퍼 (가능한 속도 향상을 제한) 사이의 균형을 맞출 필요가 있습니다.</target>
        </trans-unit>
        <trans-unit id="70ec25c9800fd4e2d1173d34d42afa3d9081d3d0" translate="yes" xml:space="preserve">
          <source>As we have seen above, a proper Pivot Table is made from an internal intermediate table resulting from the execution of a &lt;code&gt;GROUP BY&lt;/code&gt; statement. In many cases, it is simpler or desirable to directly specify this when creating the pivot table. This may be because the source is the result of a complex process including filtering and/or joining tables.</source>
          <target state="translated">위에서 살펴본 것처럼 &lt;code&gt;GROUP BY&lt;/code&gt; 문을 실행하면 내부 중간 테이블에서 적절한 피벗 테이블이 만들어집니다 . 대부분의 경우 피벗 테이블을 만들 때 직접 지정하는 것이 더 간단하거나 바람직합니다. 소스는 테이블 필터링 및 / 또는 조인을 포함한 복잡한 프로세스의 결과이기 때문일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53c6dd3755e247586144853b2e77dfb42b805386" translate="yes" xml:space="preserve">
          <source>As we have seen before, the partition engine currently loses the connection string. This is why it was specified as &amp;ldquo;connect&amp;rdquo; in the option list.</source>
          <target state="translated">앞에서 본 것처럼 파티션 엔진은 현재 연결 문자열을 잃습니다. 이것이 옵션 목록에서&amp;ldquo;connect&amp;rdquo;로 지정된 이유입니다.</target>
        </trans-unit>
        <trans-unit id="69f398a3ff8484d08b8132c382ac16ccefbbc531" translate="yes" xml:space="preserve">
          <source>As we have seen, it is also safe to use it to create or drop indexes. Otherwise, a simple rule of thumb is to avoid altering a table definition and better drop and re-create a table whose definition must be modified. Just remember that for outward CONNECT tables, dropping a table does not erase the data and that creating it does not modify existing data.</source>
          <target state="translated">우리가 보았 듯이 인덱스를 생성하거나 삭제하는 데 사용하는 것이 안전합니다. 그렇지 않으면 간단한 경험 규칙은 테이블 정의를 변경하지 말고 정의를 수정해야하는 테이블을 삭제하고 다시 작성하는 것입니다. 외부 CONNECT 테이블의 경우 테이블을 삭제해도 데이터가 삭제되지 않으며 테이블을 작성해도 기존 데이터가 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f264e3a96d5fc94413dbee9f3051bf064e035ec3" translate="yes" xml:space="preserve">
          <source>As with a regular &lt;code&gt;&lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;WHERE&lt;/code&gt; clause can be used for the specific columns returned, and the &lt;code&gt;&lt;a href=&quot;../like/index&quot;&gt;LIKE&lt;/a&gt;&lt;/code&gt; clause with the regular wildcards.</source>
          <target state="translated">일반 &lt;code&gt;&lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt;&lt;/code&gt; 와 마찬가지로 &lt;code&gt;WHERE&lt;/code&gt; 절을 반환 된 특정 열에 사용할 수 있고 &lt;code&gt;&lt;a href=&quot;../like/index&quot;&gt;LIKE&lt;/a&gt;&lt;/code&gt; 절을 일반 와일드 카드와 함께 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="47946a481f3db2b06079d40eaeb7f93d6cbbd834" translate="yes" xml:space="preserve">
          <source>As with core MariaDB, ColumnStore employs &amp;ldquo;saturation semantics&amp;rdquo; on integer values. This means that if a value is inserted into an integer field that is too big/small for it to hold (i.e. it is more negative or more positive than the values indicated above), ColumnStore will &amp;ldquo;saturate&amp;rdquo; that value to the min/max value indicated above as appropriate. For example, for a SMALLINT column, if 32800 is attempted, the actual value inserted will be 32767.</source>
          <target state="translated">핵심 MariaDB와 마찬가지로 ColumnStore는 정수 값에 &quot;포화 의미론&quot;을 사용합니다. 즉, 값을 보유하기에 너무 크거나 작은 정수 필드에 값을 삽입하면 (즉, 위에 표시된 값보다 음수이거나 양수인 경우) ColumnStore는 해당 값을 최소 / 최대로 &quot;포화&quot;합니다. 위에 표시된 값. 예를 들어, SMALLINT 열의 경우 32800을 시도하면 삽입 된 실제 값은 32767입니다.</target>
        </trans-unit>
        <trans-unit id="8d3c224b6680b9ed7c18f4614257db89b4e0e8ed" translate="yes" xml:space="preserve">
          <source>As with most errors, first take a look at the contents of the &lt;a href=&quot;../error-log/index&quot;&gt;MariaDB error log&lt;/a&gt;. If dealing with a deadlock, setting the &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_print_all_deadlocks&quot;&gt;innodb_print_all_deadlocks&lt;/a&gt; option (off by default) will output details of all deadlocks to the error log.</source>
          <target state="translated">대부분의 오류와 마찬가지로 먼저 &lt;a href=&quot;../error-log/index&quot;&gt;MariaDB 오류 로그&lt;/a&gt; 의 내용을 살펴보십시오 . 교착 상태를 처리하는 경우 &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_print_all_deadlocks&quot;&gt;innodb_print_all_deadlocks&lt;/a&gt; 옵션을 설정하면 (기본적으로 해제되어 있음) 모든 교착 상태의 세부 정보가 오류 로그에 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="973309ed386b545e506fd91e7749d07554d3eec5" translate="yes" xml:space="preserve">
          <source>As with other storage engines that support data-at-rest encryption, Aria r...</source>
          <target state="translated">미사용 데이터 암호화를 지원하는 다른 스토리지 엔진과 마찬가지로 Aria r ...</target>
        </trans-unit>
        <trans-unit id="39c5729de0d85dfba132df48fb60e04aa4b2a5fa" translate="yes" xml:space="preserve">
          <source>As with other storage engines that support data-at-rest encryption, Aria relies on an &lt;a href=&quot;../key-management-and-encryption-plugins/index&quot;&gt;Encryption Key Management&lt;/a&gt; plugin to handle its encryption keys. Where the support is available, Aria can use &lt;a href=&quot;../encryption-key-management/index#using-multiple-encryption-keys&quot;&gt;multiple keys&lt;/a&gt;.</source>
          <target state="translated">미사용 데이터 암호화를 지원하는 다른 스토리지 엔진과 마찬가지로 Aria는 &lt;a href=&quot;../key-management-and-encryption-plugins/index&quot;&gt;암호화 키 관리&lt;/a&gt; 플러그인을 사용하여 암호화 키를 처리합니다. 지원이 가능한 경우 Aria는 &lt;a href=&quot;../encryption-key-management/index#using-multiple-encryption-keys&quot;&gt;여러 키를&lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6adb14a28995a23731a1740c569e6bcafc408ce3" translate="yes" xml:space="preserve">
          <source>As with standard JSON tables, discovery is possible, meaning that you can leave CONNECT to define the columns by analyzing the JSON file. Here you could just do:</source>
          <target state="translated">표준 JSON 테이블과 마찬가지로 검색이 가능합니다. 즉, JSON 파일을 분석하여 CONNECT를 유지하여 열을 정의 할 수 있습니다. 여기서 당신은 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="242e30df833a49ac2fb953d0dea4f329e2e2f9d1" translate="yes" xml:space="preserve">
          <source>As you can see from the above, &lt;a href=&quot;../aria_s3_copy/index&quot;&gt;aria_s3_copy&lt;/a&gt; is using the current directory as the database name.</source>
          <target state="translated">위에서 볼 수 있듯이 &lt;a href=&quot;../aria_s3_copy/index&quot;&gt;aria_s3_copy&lt;/a&gt; 는 현재 디렉토리를 데이터베이스 이름으로 사용하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc6a47e007946e75fd4f97fd37fd96d9746778de" translate="yes" xml:space="preserve">
          <source>As you can see from the logging messages, MaxScale detected the &lt;code&gt;&lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt;&lt;/code&gt; statement and streamed it through the CDC Data Adapter to ColumnStore. The CDC Data Adapter then begins logging &lt;code&gt;Read timeout&lt;/code&gt; messages to indicate that it is done streaming and is waiting on additional binary events from the MariaDB Servers.</source>
          <target state="translated">로깅 메시지에서 볼 수 있듯이 MaxScale은 &lt;code&gt;&lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt;&lt;/code&gt; 문을 감지 하여 CDC 데이터 어댑터를 통해 ColumnStore로 스트리밍했습니다. 그런 다음 CDC 데이터 어댑터는 &lt;code&gt;Read timeout&lt;/code&gt; 메시지 로깅을 시작 하여 스트리밍이 완료되었으며 MariaDB 서버에서 추가 2 진 이벤트를 기다리고 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="cdda39432e61fbafb0539a9e1bb685dcc9e7e5c8" translate="yes" xml:space="preserve">
          <source>As you can see in the example above, you don't need to chop off the query line or the command prompt.</source>
          <target state="translated">위의 예에서 볼 수 있듯이 쿼리 줄이나 명령 프롬프트를 잘라낼 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6d1665afa1215cfa95be128aa46311cf24c1ff6c" translate="yes" xml:space="preserve">
          <source>As you can see in the examples above, UNIX_TIMESTAMP(constant-date-string) returns a timestamp with 6 decimals while &lt;a href=&quot;../what-is-mariadb-52/index&quot;&gt;MariaDB 5.2&lt;/a&gt; and before returns it without decimals. This can cause a problem if you are using UNIX_TIMESTAMP() as a partitioning function. You can fix this by using &lt;a href=&quot;../floor/index&quot;&gt;FLOOR&lt;/a&gt;(UNIX_TIMESTAMP(..)) or changing the date string to a date number, like 20080101000000.</source>
          <target state="translated">위의 예에서 볼 수 있듯이 UNIX_TIMESTAMP (constant-date-string)은 소수점 6 자리의 타임 스탬프를 반환하지만 &lt;a href=&quot;../what-is-mariadb-52/index&quot;&gt;MariaDB 5.2&lt;/a&gt; 이전과 그 이전에는 소수점없이 반환합니다. UNIX_TIMESTAMP ()를 파티셔닝 함수로 사용하는 경우 문제가 발생할 수 있습니다. &lt;a href=&quot;../floor/index&quot;&gt;FLOOR&lt;/a&gt; (UNIX_TIMESTAMP (..))를 사용하거나 날짜 문자열을 20080101000000과 같은 날짜 번호로 변경하여이 문제를 해결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b450533de3d2d4dbe83c2267e80f70280fd93b62" translate="yes" xml:space="preserve">
          <source>As you can see, the account holder has made payments on the loan. This amount should be removed from the balance to reflect their paying it down. Issue another &lt;code&gt;&lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt;&lt;/code&gt; statement to modify the balance, removing payments made on the account:</source>
          <target state="translated">보시다시피, 계좌 소유자는 대출금을 지불했습니다. 이 금액은 잔액을 지불하기 위해 잔액에서 제거해야합니다. 다른 &lt;code&gt;&lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt;&lt;/code&gt; 문을 발행 하여 잔액을 수정하고 계정에서 지불 한 금액을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="3a42cb2436e987c3d387293ff14ea31f714879f8" translate="yes" xml:space="preserve">
          <source>As you can see, we used the &lt;a href=&quot;../unix_timestamp/index&quot;&gt;UNIX_TIMESTAMP&lt;/a&gt; function to accomplish the purpose. Also, the first two partitions cover longer periods of time (probably because the logged activities were less intensive).</source>
          <target state="translated">보시다시피, 우리 는 목적을 달성하기 위해 &lt;a href=&quot;../unix_timestamp/index&quot;&gt;UNIX_TIMESTAMP&lt;/a&gt; 함수를 사용했습니다. 또한 처음 두 파티션은 더 긴 시간을 커버합니다 (아마도 기록 된 활동이 덜 집중 되었기 때문일 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="8959dee732c0ff70f58020e22918d1ec99d93fee" translate="yes" xml:space="preserve">
          <source>AsBinary</source>
          <target state="translated">AsBinary</target>
        </trans-unit>
        <trans-unit id="d12cf4ec5aa63bba05843436ae5a0912dcbe4120" translate="yes" xml:space="preserve">
          <source>AsText</source>
          <target state="translated">AsText</target>
        </trans-unit>
        <trans-unit id="c7d3eaf7f9c28b62711f90f56da2aa0307edc3ab" translate="yes" xml:space="preserve">
          <source>AsWKB</source>
          <target state="translated">AsWKB</target>
        </trans-unit>
        <trans-unit id="39fa9518d11e48acecf1ccb2abb9d2c652a63c7a" translate="yes" xml:space="preserve">
          <source>AsWKT</source>
          <target state="translated">AsWKT</target>
        </trans-unit>
        <trans-unit id="cb29014b56220c3e43f334a7904b49ba64204516" translate="yes" xml:space="preserve">
          <source>Asensitive means that the cursor points to the actual underlying data. This kind of cursor is quicker than the alternative, an insensitive cursor, as no data is copied to a temporary table. However, changes to the data being used by the cursor will affect the cursor data.</source>
          <target state="translated">민감 함은 커서가 실제 기본 데이터를 가리키는 것을 의미합니다. 이러한 종류의 커서는 임시 테이블에 데이터가 복사되지 않으므로 다른 커서 인 둔감 한 커서보다 빠릅니다. 그러나 커서가 사용중인 데이터를 변경하면 커서 데이터에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="dc62f0fe25a3933026c2eb641912d0823e5ca491" translate="yes" xml:space="preserve">
          <source>Aspire 8920</source>
          <target state="translated">열망 8920</target>
        </trans-unit>
        <trans-unit id="e03dc251be8fa0a9d0f75257a00fcb55f9bed839" translate="yes" xml:space="preserve">
          <source>Assertion</source>
          <target state="translated">Assertion</target>
        </trans-unit>
        <trans-unit id="b6a83c965f928113fe2616baa10f12143eae0e7b" translate="yes" xml:space="preserve">
          <source>Assign DBRoots to Performance Module</source>
          <target state="translated">DBRoots를 성능 모듈에 할당</target>
        </trans-unit>
        <trans-unit id="442cdb6924f3cd0d6dc206983c89ec45cf96f5ce" translate="yes" xml:space="preserve">
          <source>Assign a password to newly created user</source>
          <target state="translated">새로 작성된 사용자에게 비밀번호 지정</target>
        </trans-unit>
        <trans-unit id="8476daa034c9691f1f7c5f5898f4db97fb55185a" translate="yes" xml:space="preserve">
          <source>Assign password to an existing MariaDB user.</source>
          <target state="translated">기존 MariaDB 사용자에게 암호를 할당하십시오.</target>
        </trans-unit>
        <trans-unit id="f416e64c201b256eef394f752e31b9cff249aad9" translate="yes" xml:space="preserve">
          <source>Assign password to newly created user</source>
          <target state="translated">새로 만든 사용자에게 비밀번호 할당</target>
        </trans-unit>
        <trans-unit id="f455844f27bdc44d3ddb8293d5e00d9bd94ba1b6" translate="yes" xml:space="preserve">
          <source>Assign the value (the signal) to the global variable (&quot;set a flag&quot;) and broadcast a global condition to wake those waiting for a signal.</source>
          <target state="translated">값 (신호)을 전역 변수에 할당하고 ( &quot;플래그 설정&quot;) 신호를 기다리는 사람들을 깨우기 위해 전역 조건을 브로드 캐스트합니다.</target>
        </trans-unit>
        <trans-unit id="0c3b2e734e48b31e93a5981b23f19df0c3c25a75" translate="yes" xml:space="preserve">
          <source>Assignment Operator (:=)</source>
          <target state="translated">할당 연산자 (: =)</target>
        </trans-unit>
        <trans-unit id="8897c9ebcf523fad4ad6c8446723147f4d67d88b" translate="yes" xml:space="preserve">
          <source>Assignment Operator (=)</source>
          <target state="translated">할당 연산자 (=)</target>
        </trans-unit>
        <trans-unit id="7bec00ae67953bf63f8b1b3f8ddf8f9255f79d82" translate="yes" xml:space="preserve">
          <source>Assignment Operators</source>
          <target state="translated">할당 연산자</target>
        </trans-unit>
        <trans-unit id="c2b15f65cd2b40b1fa5f33fc57158d31825a1e0f" translate="yes" xml:space="preserve">
          <source>Assignment and comparison operator</source>
          <target state="translated">할당 및 비교 연산자</target>
        </trans-unit>
        <trans-unit id="46582557d432eddab79efc6d6d71bd24ca1e5c66" translate="yes" xml:space="preserve">
          <source>Assignment is done from left to right. The first cursor field is assigned to the first variable field, the second cursor field is assigned to the second variable field, etc.</source>
          <target state="translated">과제는 왼쪽에서 오른쪽으로 이루어집니다. 첫 번째 커서 필드는 첫 번째 변수 필드에 할당되고 두 번째 커서 필드는 두 번째 변수 필드 등에 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="2a42c6ba10c8a4f7e481e0493fc6c2dbd6674230" translate="yes" xml:space="preserve">
          <source>Assignment is using the &lt;code&gt;:=&lt;/code&gt; operator and the &lt;a href=&quot;../set/index&quot;&gt;SET&lt;/a&gt; command:</source>
          <target state="translated">지정은 &lt;code&gt;:=&lt;/code&gt; 연산자와 &lt;a href=&quot;../set/index&quot;&gt;SET&lt;/a&gt; 명령을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="39671023c69da7c852abacd292e68eeae860a3fe" translate="yes" xml:space="preserve">
          <source>Assignment operator</source>
          <target state="translated">할당 연산자</target>
        </trans-unit>
        <trans-unit id="bcb308733a8ed9e23db1a1b184dfbf8f43ae204c" translate="yes" xml:space="preserve">
          <source>Assignment operator for assigning a value.</source>
          <target state="translated">값을 할당하기위한 할당 연산자</target>
        </trans-unit>
        <trans-unit id="fbd74b7a5486719ed9e3c4b0e758e66f5965a7d8" translate="yes" xml:space="preserve">
          <source>Assignment operator for assigning a value. The value on the right is assigned to the variable on left.</source>
          <target state="translated">값을 할당하기위한 할당 연산자 오른쪽의 값은 왼쪽의 변수에 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="2228fb46e55e96e25047d27f958746cf72498528" translate="yes" xml:space="preserve">
          <source>Assignments are evaluated in left-to-right order, unless the &lt;code&gt;SIMULTANEOUS_ASSIGNMENT&lt;/code&gt;&lt;a href=&quot;../sql-mode/index&quot;&gt;sql_mode&lt;/a&gt; (available from &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1035-release-notes/&quot;&gt;MariaDB 10.3.5&lt;/a&gt;) is set, in which case the UPDATE statement evaluates all assignments simultaneously.</source>
          <target state="translated">&lt;code&gt;SIMULTANEOUS_ASSIGNMENT&lt;/code&gt; &lt;a href=&quot;../sql-mode/index&quot;&gt;sql_mode&lt;/a&gt; ( &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1035-release-notes/&quot;&gt;MariaDB 10.3.5&lt;/a&gt; 에서 사용 가능 )가 설정되어 있지 않으면 할당은 왼쪽에서 오른쪽 순서로 평가됩니다.이 경우 UPDATE 문은 모든 할당을 동시에 평가합니다.</target>
        </trans-unit>
        <trans-unit id="db6e98c1081d6c42fae09de56137b40e54c507f3" translate="yes" xml:space="preserve">
          <source>Assigns a priority level to user@host.</source>
          <target state="translated">user @ host에 우선 순위 레벨을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="42cd152264000fa152679df70543c60690d2e44b" translate="yes" xml:space="preserve">
          <source>Assistant to create tables using a data grid view;</source>
          <target state="translated">데이터 그리드보기를 사용하여 테이블을 작성하는 보조자;</target>
        </trans-unit>
        <trans-unit id="3237b7dfa51323f41c1065c6a2bba48796f50410" translate="yes" xml:space="preserve">
          <source>Assisted discovery</source>
          <target state="translated">보조 발견</target>
        </trans-unit>
        <trans-unit id="dda24e967c5ad35869546b34930714f1b90e09a9" translate="yes" xml:space="preserve">
          <source>Assisted discovery is a lot simpler from the server point of view, a lot more controlled. The table cannot appear or disappear at will, one still needs explicit DDL statements to manipulate it. There is only one new handlerton method that the server uses to discover the table structure when a user has issued an explicit &lt;code&gt;CREATE TABLE&lt;/code&gt; statement without declaring any columns or indexes.</source>
          <target state="translated">지원 검색은 서버의 관점에서 보면 훨씬 간단하고 제어 수준이 훨씬 높습니다. 테이블은 마음대로 표시되거나 사라질 수 없으며, 테이블을 조작하려면 명시적인 DDL 문이 필요합니다. 사용자가 열이나 인덱스를 선언하지 않고 명시 적 &lt;code&gt;CREATE TABLE&lt;/code&gt; 문을 발행했을 때 서버가 테이블 구조를 발견하는 데 사용하는 새로운 핸들러 메소드는 하나뿐입니다 .</target>
        </trans-unit>
        <trans-unit id="3e13e26415301a350c35ea013afb421f94875c30" translate="yes" xml:space="preserve">
          <source>Associated character set.</source>
          <target state="translated">연관된 문자 세트.</target>
        </trans-unit>
        <trans-unit id="0cbb022f64c07e733e953b9181bb55d255a59dd5" translate="yes" xml:space="preserve">
          <source>Associated value.</source>
          <target state="translated">관련 가치.</target>
        </trans-unit>
        <trans-unit id="a6a09d1a40909528d9ab5485a9633a9e2ca03380" translate="yes" xml:space="preserve">
          <source>Assume &lt;code&gt;table1&lt;/code&gt; contains the following trigger:</source>
          <target state="translated">&lt;code&gt;table1&lt;/code&gt; 에 다음과 같은 트리거가 있다고 가정하십시오 .</target>
        </trans-unit>
        <trans-unit id="c2f7804b38e5a4519bab70e6f24e541082b30064" translate="yes" xml:space="preserve">
          <source>Assume instead the server started with the option &lt;code&gt;--binlog-do-db=employees&lt;/code&gt;. The following example &lt;em&gt;is not&lt;/em&gt; logged if statement-based logging is used, and &lt;em&gt;is&lt;/em&gt; logged with row-based logging.</source>
          <target state="translated">대신 서버가 &lt;code&gt;--binlog-do-db=employees&lt;/code&gt; 옵션으로 시작 했다고 가정하십시오 . 다음의 예는 &lt;em&gt;하지 않는&lt;/em&gt; 문 기반 로깅을 사용하는 경우 기록하고 &lt;em&gt;있다&lt;/em&gt; 행 기반 로깅을 기록.</target>
        </trans-unit>
        <trans-unit id="fcddfd72eb18ed8321f88b9bfaa78ed764b8ac75" translate="yes" xml:space="preserve">
          <source>Assume that you left off at ($g, $s) (and have handled that row):</source>
          <target state="translated">($ g, $ s)에 그만두고 (행을 처리했다고 가정) :</target>
        </trans-unit>
        <trans-unit id="d08f19e0d1d4b3fb204a3d41e35727b5548be03e" translate="yes" xml:space="preserve">
          <source>Assume that, given the data above, you want to return the average total for all students. In other words, the average of Chun's 148 (75+73), Esben's 74 (43+31), etc.</source>
          <target state="translated">위의 데이터가 주어지면 모든 학생의 평균 합계를 반환한다고 가정하십시오. 즉, 춘의 평균 148 (75 + 73), 에벤의 74 (43 + 31) 등</target>
        </trans-unit>
        <trans-unit id="880dc2a58caa46cc20b05302f59e4685cf765865" translate="yes" xml:space="preserve">
          <source>Assume the server has started with the option &lt;code&gt;--binlog-ignore-db=employees&lt;/code&gt;. The following example &lt;em&gt;is&lt;/em&gt; logged if statement-based logging is used, and &lt;em&gt;is not&lt;/em&gt; logged with row-based logging.</source>
          <target state="translated">서버가 &lt;code&gt;--binlog-ignore-db=employees&lt;/code&gt; 옵션으로 시작되었다고 가정하십시오 . 명령문 기반 로깅이 사용되는 경우 다음 예제 &lt;em&gt;는&lt;/em&gt; 로깅 되며 행 기반 로깅으로 로깅 &lt;em&gt;되지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c0b319b57da526026fec68db612ec6f650524b50" translate="yes" xml:space="preserve">
          <source>Assuming VS is installed on the machine</source>
          <target state="translated">VS가 시스템에 설치되어 있다고 가정</target>
        </trans-unit>
        <trans-unit id="b8d72438be7ee2fd5c79f8308774efeb96ff9a8a" translate="yes" xml:space="preserve">
          <source>Assuming `rnd` is a FLOAT (or DOUBLE) populated with RAND() and INDEXed:</source>
          <target state="translated">'rnd'가 RAND ()로 채워진 INDEXed FLOAT (또는 DOUBLE)이라고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="d7065fb7d4c9de17ea00ec7722ca95e36b9989ca" translate="yes" xml:space="preserve">
          <source>Assuming a single-byte character-set:</source>
          <target state="translated">1 바이트 문자 세트를 가정하면 :</target>
        </trans-unit>
        <trans-unit id="c10f6cc214e28254d713f79f83b14bcdc3835cd4" translate="yes" xml:space="preserve">
          <source>Assuming you have a bit more than 2G free memory.</source>
          <target state="translated">2G 이상의 여유 메모리가 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="16fd72bd0a7474bcba43260dddf95a050565dc72" translate="yes" xml:space="preserve">
          <source>Assuming you have news articles that need to be purged, and you have a schema something like</source>
          <target state="translated">제거해야 할 뉴스 기사가 있고 다음과 같은 스키마가 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="e1826a9551f43fbbb902112659cbd56504230047" translate="yes" xml:space="preserve">
          <source>Asynchronous connect to server with ability to cancel the operation</source>
          <target state="translated">작업을 취소 할 수있는 서버에 비동기 연결</target>
        </trans-unit>
        <trans-unit id="78fff50455369d50e3a35e79262477652e29734d" translate="yes" xml:space="preserve">
          <source>Asynchronous connection to server with option to cancel the operation</source>
          <target state="translated">작업 취소 옵션이있는 서버에 대한 비동기 연결</target>
        </trans-unit>
        <trans-unit id="fa656916da3eb8588b8d6cbe322826541dd89d68" translate="yes" xml:space="preserve">
          <source>Asynchronous data fetch with ability to cancel the operation</source>
          <target state="translated">작업을 취소 할 수있는 비동기 데이터 가져 오기</target>
        </trans-unit>
        <trans-unit id="866046fd8bad007d24bfc71a94a3b494eb91e34c" translate="yes" xml:space="preserve">
          <source>Asynchronous data synchronization</source>
          <target state="translated">비동기식 데이터 동기화</target>
        </trans-unit>
        <trans-unit id="4cd1ed59e1f15d6e1729be128b6ba8c168ff6af9" translate="yes" xml:space="preserve">
          <source>Asynchronous structure synchronization</source>
          <target state="translated">비동기 구조 동기화</target>
        </trans-unit>
        <trans-unit id="dfe9ab69923fde3b9e6311835cc17837f2cb6b12" translate="yes" xml:space="preserve">
          <source>At COMMIT time (or end of statement, in case of autocommit=1), galera makes one roundtrip to other nodes.</source>
          <target state="translated">COMMIT 시간 (또는 autocommit = 1 인 경우 명령문 종료)에서 galera는 한 노드를 다른 노드로 왕복합니다.</target>
        </trans-unit>
        <trans-unit id="11c1ab595825479097ed5e2d86a25c5d3c2e2809" translate="yes" xml:space="preserve">
          <source>At a technical level, purchasing of a milk carton or container triggers an OLTP query, and inventory reporting is an OLAP query. OLTP data is used for logging, and analysis of OLAP data drives understanding of product losses, replenishment patterns, and equipment failures.</source>
          <target state="translated">기술 수준에서 우유 상자 또는 컨테이너를 구매하면 OLTP 쿼리가 트리거되고 인벤토리보고는 OLAP 쿼리입니다. OLTP 데이터는 로깅 및 OLAP 데이터 분석에 사용되어 제품 손실, 보충 패턴 및 장비 고장을 이해합니다.</target>
        </trans-unit>
        <trans-unit id="21696e714987e6ebcfbd1ef3968f8d544fe82939" translate="yes" xml:space="preserve">
          <source>At a technical level, when an OLTP query is performed to process the customer's purchase, the customer's past and current purchase history is analyzed with an OLAP query to provide promotions tailored to the customer's buying history.</source>
          <target state="translated">기술 수준에서 고객의 구매를 처리하기 위해 OLTP 쿼리를 수행 할 때 고객의 과거 및 현재 구매 내역을 OLAP 쿼리로 분석하여 고객의 구매 내역에 맞는 프로모션을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="958eca4d2aff83e89f87b8481f2633af8bc1cab1" translate="yes" xml:space="preserve">
          <source>At each DROP or ALTER, increase the counter by one.</source>
          <target state="translated">각 DROP 또는 ALTER에서 카운터를 1 씩 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="b9d11a9d1565ddfbeece077abf5353a090768698" translate="yes" xml:space="preserve">
          <source>At its core, mysql-test is very simple. The client program &lt;code&gt;mysqltest&lt;/code&gt; executes a &lt;em&gt;test file&lt;/em&gt; and compares the produced output with the &lt;em&gt;result file&lt;/em&gt;. If the files match, the test is passed; otherwise the test has failed. This approach can be used to test any SQL statement, as well as other executables (with the &lt;code&gt;exec&lt;/code&gt; command).</source>
          <target state="translated">핵심적으로 mysql-test는 매우 간단합니다. 클라이언트 프로그램 &lt;code&gt;mysqltest&lt;/code&gt; 는 &lt;em&gt;테스트 파일을&lt;/em&gt; 실행 하고 생성 된 출력을 &lt;em&gt;결과 파일&lt;/em&gt; 과 비교 &lt;em&gt;합니다&lt;/em&gt; . 파일이 일치하면 테스트가 통과됩니다. 그렇지 않으면 테스트가 실패했습니다. 이 방법을 사용하면 모든 SQL 문과 다른 실행 파일 ( &lt;code&gt;exec&lt;/code&gt; 명령 사용)을 테스트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d285ec43e29278f427ead62fe484df25a9329edd" translate="yes" xml:space="preserve">
          <source>At least one of the 'in_to_exists' or 'materialization' optimizer_switch flags must be 'on'.</source>
          <target state="translated">'in_to_exists'또는 'materialization'optimizer_switch 플래그 중 하나 이상이 'on'이어야합니다.</target>
        </trans-unit>
        <trans-unit id="7672d775bd3a3dc766066e13a48bf53ca479419c" translate="yes" xml:space="preserve">
          <source>At least one partition must be added</source>
          <target state="translated">하나 이상의 파티션을 추가해야합니다</target>
        </trans-unit>
        <trans-unit id="a282d7463d8ff22b81924b04c65c52257829eefc" translate="yes" xml:space="preserve">
          <source>At least one partition must be coalesced</source>
          <target state="translated">최소한 하나의 파티션을 병합해야합니다</target>
        </trans-unit>
        <trans-unit id="50f272c1993cc0bae63775451e823d45579f16b7" translate="yes" xml:space="preserve">
          <source>At least one server for data storage</source>
          <target state="translated">데이터 저장을위한 하나 이상의 서버</target>
        </trans-unit>
        <trans-unit id="6a2f7361c8c7877560010da044889429abc5e8b0" translate="yes" xml:space="preserve">
          <source>At least one symbol, beyond the required &lt;em&gt;x()&lt;/em&gt; - corresponding to an SQL function &lt;em&gt;X())&lt;/em&gt; - is required. These can be &lt;em&gt;x_init()&lt;/em&gt;, &lt;em&gt;x_deinit()&lt;/em&gt;, &lt;em&gt;xxx_reset()&lt;/em&gt;, &lt;em&gt;x_clear()&lt;/em&gt; and &lt;em&gt;x_add()&lt;/em&gt; functions (see &lt;a href=&quot;../creating-user-defined-functions/index&quot;&gt;Creating User-defined Functions&lt;/a&gt;). The &lt;a href=&quot;../mysqld-options/index#-allow-suspicious-udfs&quot;&gt;allow-suspicious-udfs&lt;/a&gt; mysqld option (by default unset) provides a workaround, permitting only one symbol to be used. This is not recommended, as it opens the possibility of loading shared objects that are not legitimate user-defined functions.</source>
          <target state="translated">SQL 함수 &lt;em&gt;X ()에&lt;/em&gt; 해당하는 필수 &lt;em&gt;x ()&lt;/em&gt; 이외의 기호가 하나 이상 필요합니다. 이 될 수 &lt;em&gt;x_init ()&lt;/em&gt; , &lt;em&gt;x_deinit ()&lt;/em&gt; , &lt;em&gt;xxx_reset ()&lt;/em&gt; , &lt;em&gt;x_clear ()&lt;/em&gt; 및 &lt;em&gt;x_add ()&lt;/em&gt; 함수 (참조 &lt;a href=&quot;../creating-user-defined-functions/index&quot;&gt;사용자 정의 함수 만들기&lt;/a&gt; ). 는 &lt;a href=&quot;../mysqld-options/index#-allow-suspicious-udfs&quot;&gt;UDFS-의심스러운-수 있습니다&lt;/a&gt; (기본 설정 해제에 의해) mysqld를 옵션을 사용하는 하나의 기호를 허용, 해결 방법을 제공합니다. 합법적 인 사용자 정의 함수가 아닌 공유 객체를로드 할 가능성이 있으므로 권장하지 않습니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ac4b25e769610447afd7e255571596d90f3a6387" translate="yes" xml:space="preserve">
          <source>At least the &lt;a href=&quot;../handlersocket-configuration-options/index#handlersocket_address&quot;&gt;handlersocket_address&lt;/a&gt;, &lt;a href=&quot;../handlersocket-configuration-options/index#handlersocket_port&quot;&gt;handlersocket_port&lt;/a&gt; and &lt;a href=&quot;../handlersocket-configuration-options/index#handlersocket_port_wr&quot;&gt;handlersocket_port_wr&lt;/a&gt; options need to be set. For example:</source>
          <target state="translated">적어도 &lt;a href=&quot;../handlersocket-configuration-options/index#handlersocket_address&quot;&gt;handlersocket_address&lt;/a&gt; , &lt;a href=&quot;../handlersocket-configuration-options/index#handlersocket_port&quot;&gt;handlersocket_port&lt;/a&gt; 및 &lt;a href=&quot;../handlersocket-configuration-options/index#handlersocket_port_wr&quot;&gt;handlersocket_port_wr&lt;/a&gt; 옵션을 설정해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="46686f9da8681160478b648ee041e6cb97682d87" translate="yes" xml:space="preserve">
          <source>At least the user (&lt;code&gt;-u&lt;/code&gt;) and the database (&lt;code&gt;-d&lt;/code&gt;) must be given, even with wildcards. If no host is provided, `localhost' is assumed. Wildcards (*,?,%,_) are allowed for &lt;em&gt;host&lt;/em&gt;, &lt;em&gt;user&lt;/em&gt; and &lt;em&gt;db&lt;/em&gt;, but be sure to escape them from your shell!! (ie type \* or '*')</source>
          <target state="translated">와일드 카드를 사용하더라도 최소한 사용자 ( &lt;code&gt;-u&lt;/code&gt; )와 데이터베이스 ( &lt;code&gt;-d&lt;/code&gt; )를 제공해야합니다. 호스트가 제공되지 않으면`localhost '로 가정합니다. 와일드 카드 (*,?, %, _)는 &lt;em&gt;host&lt;/em&gt; , &lt;em&gt;user&lt;/em&gt; 및 &lt;em&gt;db에&lt;/em&gt; 허용 되지만 쉘에서 이스케이프해야합니다 !! (예 : \ * 또는 '*')</target>
        </trans-unit>
        <trans-unit id="ac20f300c48add880604e6ba90fc2dd5ac227a67" translate="yes" xml:space="preserve">
          <source>At most Limit rows are returned</source>
          <target state="translated">최대 한도 행이 반환됩니다</target>
        </trans-unit>
        <trans-unit id="628eaf106777ef9e75a4863fca76a89bdd65f4ce" translate="yes" xml:space="preserve">
          <source>At server startup, the server loads and initializes any plugin that is listed in the &lt;code&gt;mysql.plugin&lt;/code&gt; table. This means that a plugin is installed with &lt;code&gt;INSTALL PLUGIN&lt;/code&gt; only once, not every time the server starts. Plugin loading at startup does not occur if the server is started with the &lt;code&gt;--skip-grant-tables&lt;/code&gt; option.</source>
          <target state="translated">서버 시작시 서버는 &lt;code&gt;mysql.plugin&lt;/code&gt; 테이블에 나열된 플러그인을로드하고 초기화 합니다. 이것은 플러그인이 &lt;code&gt;INSTALL PLUGIN&lt;/code&gt; 과 함께 한 번만 설치 되고 서버가 시작될 때마다 설치 되지 않음을 의미합니다. 서버가 &lt;code&gt;--skip-grant-tables&lt;/code&gt; 옵션으로 시작된 경우 시작시 플러그인로드가 발생하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="36d68a8d36cdd168112ea0cd574eef7e924b4dc3" translate="yes" xml:space="preserve">
          <source>At server startup, the server loads and initializes any plugin that is listed in the &lt;code&gt;mysql.plugin&lt;/code&gt; table. This means that a plugin is installed with &lt;code&gt;INSTALL SONAME&lt;/code&gt; only once, not every time the server starts. Plugin loading at startup does not occur if the server is started with the &lt;code&gt;--skip-grant-tables&lt;/code&gt; option.</source>
          <target state="translated">서버 시작시 서버는 &lt;code&gt;mysql.plugin&lt;/code&gt; 테이블에 나열된 플러그인을로드하고 초기화 합니다. 이는 플러그인이 서버를 시작할 때마다가 아니라 &lt;code&gt;INSTALL SONAME&lt;/code&gt; 과 함께 한 번만 설치됨을 의미 합니다. 서버가 &lt;code&gt;--skip-grant-tables&lt;/code&gt; 옵션으로 시작된 경우 시작시 플러그인로드가 발생하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d6e5c497364de87437f2b8260c2a9280a86fa020" translate="yes" xml:space="preserve">
          <source>At startup Aria will check the Aria logs and automatically recover the tables from the last checkpoint if mysqld was not taken down correctly.</source>
          <target state="translated">시작할 때 Aria는 Aria 로그를 확인하고 mysqld가 올바르게 제거되지 않은 경우 마지막 체크 포인트에서 자동으로 테이블을 복구합니다.</target>
        </trans-unit>
        <trans-unit id="f2ed15a915deea8b8b33cbcc5cb2d72f27fcbf8a" translate="yes" xml:space="preserve">
          <source>At that point, the server should be able to read &lt;code&gt;/etc/shadow&lt;/code&gt;.</source>
          <target state="translated">이 시점에서 서버는 &lt;code&gt;/etc/shadow&lt;/code&gt; 를 읽을 수 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="9b32153b66131c92309a809ae663f0a538ae0ada" translate="yes" xml:space="preserve">
          <source>At the end, the delimiter is restored to the default semicolon. The &lt;code&gt;\g&lt;/code&gt; and &lt;code&gt;\G&lt;/code&gt; delimiters can always be used, even when a custom delimiter is specified.</source>
          <target state="translated">결국 구분 기호는 기본 세미콜론으로 복원됩니다. &lt;code&gt;\g&lt;/code&gt; 및 &lt;code&gt;\G&lt;/code&gt; 구분 기호를 항상 사용할 수 있습니다, 사용자 정의 구분 기호가 지정된 경우에도.</target>
        </trans-unit>
        <trans-unit id="1bb3a25734caeae680c895aa6186e0a82520d095" translate="yes" xml:space="preserve">
          <source>At the session level, this variable applies only to executing a query on an individual &lt;a href=&quot;../columnstore-performance-module/index&quot;&gt;PM&lt;/a&gt; and will error if executed on the &lt;a href=&quot;../columnstore-user-module/index&quot;&gt;UM&lt;/a&gt;. The PM must be set up with the local query option during installation.</source>
          <target state="translated">세션 수준에서이 변수는 개별 &lt;a href=&quot;../columnstore-performance-module/index&quot;&gt;PM&lt;/a&gt; 에서 쿼리를 실행할 때만 적용되며 &lt;a href=&quot;../columnstore-user-module/index&quot;&gt;UM에서&lt;/a&gt; 실행될 경우 오류가 발생합니다 . PM은 설치 중에 로컬 쿼리 옵션으로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="e2afff46f0391ed61bbf315bc8c504b4f5c1482c" translate="yes" xml:space="preserve">
          <source>At this point, all installation settings are collected. Click on the &quot;Install&quot; button.</source>
          <target state="translated">이 시점에서 모든 설치 설정이 수집됩니다. &quot;설치&quot;버튼을 클릭하십시오.</target>
        </trans-unit>
        <trans-unit id="3fe5e3e87158e46c44e699825022a0e3d5b588c9" translate="yes" xml:space="preserve">
          <source>At this point, if you issue a &lt;code&gt;&lt;a href=&quot;../count/index&quot;&gt;SELECT COUNT(*)&lt;/a&gt;&lt;/code&gt; statements to MariaDB ColumnStore, you should get following result-sets:</source>
          <target state="translated">이때 &lt;code&gt;&lt;a href=&quot;../count/index&quot;&gt;SELECT COUNT(*)&lt;/a&gt;&lt;/code&gt; 문을 MariaDB ColumnStore에 발행 하면 다음과 같은 결과 집합이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="a71901a544744597c23e448332352badc64187e5" translate="yes" xml:space="preserve">
          <source>At this point, lets try to restart the system</source>
          <target state="translated">이제 시스템을 다시 시작해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="f5244c59e0988df695b8b76653044ba73928b20d" translate="yes" xml:space="preserve">
          <source>At this point, the slave and the master are in sync:</source>
          <target state="translated">이 시점에서 슬레이브와 마스터가 동기화됩니다.</target>
        </trans-unit>
        <trans-unit id="a35d06d7ab2d75217c9fe2f503b608740083b207" translate="yes" xml:space="preserve">
          <source>At this point, we can configure the &lt;code&gt;&lt;a href=&quot;https://linux.die.net/man/8/logrotate&quot;&gt;logrotate&lt;/a&gt;&lt;/code&gt; utility to rotate the log files.</source>
          <target state="translated">이 시점 에서 로그 파일을 회전하도록 &lt;code&gt;&lt;a href=&quot;https://linux.die.net/man/8/logrotate&quot;&gt;logrotate&lt;/a&gt;&lt;/code&gt; 유틸리티를 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dfb8037ef05bc1b5fef0ef430a21ea41da4219be" translate="yes" xml:space="preserve">
          <source>At this point, we can enter the shell and issue commands. First we will need to update the repositories, or no packages will be available. We can also update the packages, in case some of them are newer than the image. Then, we will need to install a text editor; we will need it to edit configuration files. For example:</source>
          <target state="translated">이 시점에서 쉘을 입력하고 명령을 실행할 수 있습니다. 먼저 리포지토리를 업데이트해야합니다. 그렇지 않으면 패키지를 사용할 수 없습니다. 일부 패키지가 이미지보다 최신 인 경우 패키지를 업데이트 할 수도 있습니다. 그런 다음 텍스트 편집기를 설치해야합니다. 구성 파일을 편집하려면 필요합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4c4590f5674765d1e15160b124a0c7a0e581cfa1" translate="yes" xml:space="preserve">
          <source>At this point, we can move onto setting up the MariaDB Server.</source>
          <target state="translated">이제 MariaDB 서버 설정으로 넘어갈 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58aad69c84758a9a42ae44c9d02c3ca7be10bac2" translate="yes" xml:space="preserve">
          <source>At this point, we can restore the backup to the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#datadir&quot;&gt;datadir&lt;/a&gt;&lt;/code&gt;, as you normally would. For example:</source>
          <target state="translated">이 시점에서 평소와 같이 백업을 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#datadir&quot;&gt;datadir&lt;/a&gt;&lt;/code&gt; 로 복원 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ec1087de1ae7da17ea6f35c66d8c629ef94118c6" translate="yes" xml:space="preserve">
          <source>At this point, we have created the bank database and tables, and have loaded the data into the MariaDB Servers, (though we only wrote to &lt;code&gt;Server-1&lt;/code&gt;, as the master server it has replicated the data out to the slaves). We have also created the bank database and tables in MariaDB ColumnStore. The tables on MariaDB ColumnStore are empty at this point.</source>
          <target state="translated">이 시점에서 우리는 은행 데이터베이스와 테이블을 생성하고 MariaDB 서버에 데이터를로드했습니다 ( 마스터 서버는 데이터를 슬레이브에 복제 한 것으로서 &lt;code&gt;Server-1&lt;/code&gt; 에만 기록 했음 ). 또한 MariaDB ColumnStore에 은행 데이터베이스 및 테이블을 만들었습니다. 이 시점에서 MariaDB ColumnStore의 테이블이 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9256233cc45b6ffa88671c4debed52df4426729d" translate="yes" xml:space="preserve">
          <source>At this point, we need to get the replication coordinates of the master from the original backup directory.</source>
          <target state="translated">이제 원본 백업 디렉토리에서 마스터의 복제 좌표를 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="9ca4a4873bfa60861fd2ad1eb842b3ccfa503ec6" translate="yes" xml:space="preserve">
          <source>At this point, you can reconfigure the slaves to use TLS to encrypt replicated data in transit. There are two methods available to do this:</source>
          <target state="translated">이 시점에서 TLS를 사용하여 전송중인 복제 된 데이터를 암호화하도록 슬레이브를 재구성 할 수 있습니다. 이를 수행 할 수있는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a28eb47092eda348d3e65a61374b1d866dd26881" translate="yes" xml:space="preserve">
          <source>At this point, you can restore the backup to the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#datadir&quot;&gt;datadir&lt;/a&gt;&lt;/code&gt;, as you normally would. For example:</source>
          <target state="translated">이 시점에서 평소와 같이 백업을 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#datadir&quot;&gt;datadir&lt;/a&gt;&lt;/code&gt; 로 복원 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9dca97fff8064907870040551a181ddeaed28d74" translate="yes" xml:space="preserve">
          <source>At this point, you can start replication by executing the &lt;code&gt;&lt;a href=&quot;../start-slave/index&quot;&gt;START SLAVE&lt;/a&gt;&lt;/code&gt; statement.</source>
          <target state="translated">이 시점에서 &lt;code&gt;&lt;a href=&quot;../start-slave/index&quot;&gt;START SLAVE&lt;/a&gt;&lt;/code&gt; 문 을 실행하여 복제를 시작할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="25e2aff9323c033701cb837eaadf17021df3526d" translate="yes" xml:space="preserve">
          <source>At this point, you can start replication by executing the &lt;code&gt;&lt;a href=&quot;../start-slave/index&quot;&gt;START SLAVE&lt;/a&gt;&lt;/code&gt; statement. For example:</source>
          <target state="translated">이 시점에서 &lt;code&gt;&lt;a href=&quot;../start-slave/index&quot;&gt;START SLAVE&lt;/a&gt;&lt;/code&gt; 문 을 실행하여 복제를 시작할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5ac1b57ee9b291a2d1653f29afc6b9db7ac661b1" translate="yes" xml:space="preserve">
          <source>At this point, you can use the &lt;code&gt;&lt;a href=&quot;../mysql-command-line-client/index&quot;&gt;mysql&lt;/a&gt;&lt;/code&gt; client to connect to the &lt;code&gt;&lt;a href=&quot;../the-mysql-database-tables/index&quot;&gt;mysql&lt;/a&gt;&lt;/code&gt; database and look at the &lt;a href=&quot;../system-tables/index&quot;&gt;system tables&lt;/a&gt;. For example:</source>
          <target state="translated">이 시점에서 &lt;code&gt;&lt;a href=&quot;../mysql-command-line-client/index&quot;&gt;mysql&lt;/a&gt;&lt;/code&gt; 클라이언트를 사용하여 &lt;code&gt;&lt;a href=&quot;../the-mysql-database-tables/index&quot;&gt;mysql&lt;/a&gt;&lt;/code&gt; 데이터베이스 에 연결 하고 &lt;a href=&quot;../system-tables/index&quot;&gt;시스템 테이블을&lt;/a&gt; 볼 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b18bcdbff53cbe8098f5bd4b58caed4447d7f266" translate="yes" xml:space="preserve">
          <source>At this point, you need to get the replication coordinates of the master from the original backup.</source>
          <target state="translated">이때 원본 백업에서 마스터의 복제 좌표를 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="9f9399cbc7b83b6c73146d17f1777774ebc3e102" translate="yes" xml:space="preserve">
          <source>At view definition time, the view creator must have the privileges needed to use the top-level objects accessed by the view. For example, if the view definition refers to table columns, the creator must have privileges for the columns, as described previously. If the definition refers to a stored function, only the privileges needed to invoke the function can be checked. The privileges required when the function runs can be checked only as it executes: For different invocations of the function, different execution paths within the function might be taken.</source>
          <target state="translated">뷰 정의시 뷰 작성자는 뷰가 액세스하는 최상위 객체를 사용하는 데 필요한 권한을 가지고 있어야합니다. 예를 들어 뷰 정의가 테이블 열을 참조하는 경우 작성자는 앞에서 설명한대로 열에 대한 권한이 있어야합니다. 정의가 저장된 함수를 참조하는 경우 함수를 호출하는 데 필요한 권한 만 확인할 수 있습니다. 함수가 실행될 때 필요한 권한은 실행될 때만 확인할 수 있습니다. 함수를 다르게 호출하려면 함수 내의 다른 실행 경로를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42ffcc1396b46be874ec2602b9fa48416b84e573" translate="yes" xml:space="preserve">
          <source>At-the-end accesses (INSERT chronologically or with AUTO_INCREMENT; range SELECT) -- count as zero hits.</source>
          <target state="translated">최종 액세스 (시간순으로 삽입 또는 AUTO_INCREMENT를 사용하여 범위 선택)-제로 적중으로 계산합니다.</target>
        </trans-unit>
        <trans-unit id="a3f47dd8fd38923ef6c7b09862ebef974894d197" translate="yes" xml:space="preserve">
          <source>Atomic Groups</source>
          <target state="translated">원자 그룹</target>
        </trans-unit>
        <trans-unit id="e7bb08bbdfd18cf2b4324e6ca8135cdcf6fe78a6" translate="yes" xml:space="preserve">
          <source>Atomic Write - a Faster Alternative to innodb_doublewrite</source>
          <target state="translated">원자 쓰기-innodb_doublewrite의 빠른 대안</target>
        </trans-unit>
        <trans-unit id="37fc7309e332a49527682c25dbdb2acdb874dd35" translate="yes" xml:space="preserve">
          <source>Atomic Write Support</source>
          <target state="translated">원자 쓰기 지원</target>
        </trans-unit>
        <trans-unit id="0179861e1f664e13a6bca5b8b27571ecea0b8c8d" translate="yes" xml:space="preserve">
          <source>Atomic Writes</source>
          <target state="translated">원자 쓰기</target>
        </trans-unit>
        <trans-unit id="cf472c046fbfc34ee4fc3c2eb1d281134f859c98" translate="yes" xml:space="preserve">
          <source>Atomic groups are not capturing. To make an atomic group capturing, put it into parentheses:</source>
          <target state="translated">원자 그룹은 캡처하지 않습니다. 원자 그룹을 캡처하려면 괄호 안에 넣으십시오.</target>
        </trans-unit>
        <trans-unit id="68a6f848d46b9f5b4de287baf993fcc819b7212b" translate="yes" xml:space="preserve">
          <source>Atomic groups produce faster false results (i.e. in case when a long subject string does not match the pattern), because the regexp engine saves performance on backtracking. However, don't hurry to put everything into atomic groups. This example demonstrates the difference between atomic and non-atomic match:</source>
          <target state="translated">정규식 엔진이 역 추적 성능을 저장하므로 원자 그룹은 더 빠른 잘못된 결과를 생성합니다 (예 : 긴 제목 문자열이 패턴과 일치하지 않는 경우). 그러나 모든 것을 원자 그룹에 넣는 것을 서두르지 마십시오. 이 예는 원자와 비 원자 일치의 차이점을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="fb898c00058b529954cfbad0e185ebe63c3b235e" translate="yes" xml:space="preserve">
          <source>Attempting to change &lt;code&gt;@@skip_replication&lt;/code&gt; in the middle of a transaction will fail; this is to avoid getting half of a transaction replicated while the other half is not replicated. Be sure to end any current transaction with &lt;code&gt;COMMIT&lt;/code&gt;/&lt;code&gt;ROLLBACK&lt;/code&gt; before changing the variable.</source>
          <target state="translated">트랜잭션 도중에 &lt;code&gt;@@skip_replication&lt;/code&gt; 을 변경하려고 하면 실패합니다. 이는 트랜잭션의 절반이 복제되는 반면 다른 절반은 복제되지 않도록하는 것입니다. 변수를 변경하기 전에 &lt;code&gt;COMMIT&lt;/code&gt; / &lt;code&gt;ROLLBACK&lt;/code&gt; 으로 현재 트랜잭션을 종료하십시오 .</target>
        </trans-unit>
        <trans-unit id="d1d4b2c0fc9993254f00c15f916adad13ec540de" translate="yes" xml:space="preserve">
          <source>Attempting to connect to master.</source>
          <target state="translated">마스터에 연결하려고합니다.</target>
        </trans-unit>
        <trans-unit id="452102a47c874f9a5bba5d95af4361bb1910a07f" translate="yes" xml:space="preserve">
          <source>Attempting to enable TokuDB while Linux Transparent HugePages are enabled will fail with an error such as:</source>
          <target state="translated">Linux Transparent HugePages가 활성화 된 상태에서 TokuDB를 활성화하려고하면 다음과 같은 오류가 발생하여 실패합니다.</target>
        </trans-unit>
        <trans-unit id="faf2e9b56ed57936451abc3c4c51e637baf9dfff" translate="yes" xml:space="preserve">
          <source>Attempting to execute a prepared statement after deallocating it results in an error, as if it was not prepared at all:</source>
          <target state="translated">준비된 명령문을 할당 해제 한 후 실행하려고하면 전혀 준비되지 않은 것처럼 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="30dcc67e6400ca7a54f955d555a92d1d801b7550" translate="yes" xml:space="preserve">
          <source>Attempting to get lock on the table in order to insert rows.</source>
          <target state="translated">행을 삽입하기 위해 테이블을 잠그려고합니다.</target>
        </trans-unit>
        <trans-unit id="77e13e869d04d18300be1a77cf1ce08d331afbc9" translate="yes" xml:space="preserve">
          <source>Attempting to reconnect to the master after a previously failed binary log dump request.</source>
          <target state="translated">이전에 이진 로그 덤프 요청이 실패한 후 마스터에 다시 연결하려고합니다.</target>
        </trans-unit>
        <trans-unit id="7b781ea15681c966fccedbea8cd35b3241d0e217" translate="yes" xml:space="preserve">
          <source>Attempting to reconnect to the master after a previously failed request. After successfully connecting, the state will change to &lt;code&gt;Waiting for master to send event&lt;/code&gt;.</source>
          <target state="translated">이전에 실패한 요청 후 마스터에 다시 연결하려고합니다. 성공적으로 연결되면 상태가 &lt;code&gt;Waiting for master to send event&lt;/code&gt; 변경됩니다 .</target>
        </trans-unit>
        <trans-unit id="0b137f1dd7effe0a21a63722055f95ad75cc4ed0" translate="yes" xml:space="preserve">
          <source>Attempting to set the &lt;code&gt;read_only&lt;/code&gt; variable to 1 will fail if the current session has table locks or transactions pending.</source>
          <target state="translated">현재 세션에 테이블 잠금 또는 보류중인 트랜잭션이있는 경우 &lt;code&gt;read_only&lt;/code&gt; 변수를 1 로 설정하려고 하면 실패합니다.</target>
        </trans-unit>
        <trans-unit id="67c27d17b72214a26141724e0171e675b2634ee8" translate="yes" xml:space="preserve">
          <source>Attempting to set the isolation level within an existing transaction without specifying &lt;code&gt;GLOBAL&lt;/code&gt; or &lt;code&gt;SESSION&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;GLOBAL&lt;/code&gt; 또는 &lt;code&gt;SESSION&lt;/code&gt; 을 지정하지 않고 기존 트랜잭션 내에서 분리 레벨을 설정하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="b358df0451d31df97dbae1338d07fe0afbf45824" translate="yes" xml:space="preserve">
          <source>Attempts to cleanup a transaction</source>
          <target state="translated">트랜잭션 정리 시도</target>
        </trans-unit>
        <trans-unit id="b3b9c517b7328531e8632744be296f912c9f860c" translate="yes" xml:space="preserve">
          <source>Attempts to control the join order inside the materialization nest will be unsuccessful. Example: we want A-C-B-AA:</source>
          <target state="translated">구체화 네스트 내에서 결합 순서를 제어하려는 시도는 실패합니다. 예 : 우리는 ACB-AA를 원합니다 :</target>
        </trans-unit>
        <trans-unit id="8db7e8cffe657361faaaf56deedf7fa4f39ce959" translate="yes" xml:space="preserve">
          <source>Attribute name.</source>
          <target state="translated">속성 이름</target>
        </trans-unit>
        <trans-unit id="45ab686a26a9c623c53a098d31d25c06b4808f79" translate="yes" xml:space="preserve">
          <source>Attribute value.</source>
          <target state="translated">속성 값</target>
        </trans-unit>
        <trans-unit id="4fb472c4a6662868555cc0f8c7e87e209228c73b" translate="yes" xml:space="preserve">
          <source>Attribute values come in different types (numbers, strings, dates, etc.)</source>
          <target state="translated">속성 값은 다른 유형 (숫자, 문자열, 날짜 등)으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="a6652617f2c799eb11ee727b16c5646c48af6905" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attributes</target>
        </trans-unit>
        <trans-unit id="06fa65c0c450de31361f95d6638e01a37b72390d" translate="yes" xml:space="preserve">
          <source>Audit Plugin</source>
          <target state="translated">감사 플러그인</target>
        </trans-unit>
        <trans-unit id="01e7929363cf7b0c9a3f4c0e9c0dfe95ecfbef36" translate="yes" xml:space="preserve">
          <source>Audit Plugin - &lt;code&gt;SQL_ERROR_LOG&lt;/code&gt;</source>
          <target state="translated">감사 플러그인 &lt;code&gt;SQL_ERROR_LOG&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8cbb5472955314464c139b4334285527e166ce29" translate="yes" xml:space="preserve">
          <source>Audit Plugin - &lt;code&gt;server_audit&lt;/code&gt;</source>
          <target state="translated">감사 플러그인 &lt;code&gt;server_audit&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="48016d99c14fe2dddfe998dc4a3e9c6aa3495cac" translate="yes" xml:space="preserve">
          <source>Audit Plugin - QUERY_RESPONSE_TIME_AUDIT</source>
          <target state="translated">감사 플러그인-QUERY_RESPONSE_TIME_AUDIT</target>
        </trans-unit>
        <trans-unit id="be2c5ff0dbce474b84ad9d005ebcb840d4773caf" translate="yes" xml:space="preserve">
          <source>Audit Plugin global variables within MariaDB</source>
          <target state="translated">MariaDB 내 감사 플러그인 전역 변수</target>
        </trans-unit>
        <trans-unit id="e00dc29d6d8af6ec1310dd4fc100dd748090cd42" translate="yes" xml:space="preserve">
          <source>Audit Plugins - Options and System Variables</source>
          <target state="translated">감사 플러그인-옵션 및 시스템 변수</target>
        </trans-unit>
        <trans-unit id="3b0a8d8056d791d3c70bfee374a00dd4e0dd607f" translate="yes" xml:space="preserve">
          <source>Audit log:</source>
          <target state="translated">감사 로그 :</target>
        </trans-unit>
        <trans-unit id="5fcdacdf4c0383119c0c52ba16378dbf94c924d7" translate="yes" xml:space="preserve">
          <source>Augment output with hexadecimal and ASCII event dump.</source>
          <target state="translated">16 진 및 ASCII 이벤트 덤프로 출력을 보강하십시오.</target>
        </trans-unit>
        <trans-unit id="ceafb51e2b0783d53dd620019dff3aa66708a26f" translate="yes" xml:space="preserve">
          <source>Australia</source>
          <target state="translated">Australia</target>
        </trans-unit>
        <trans-unit id="593905b31972f6ffe58325abf98595caf4ebf458" translate="yes" xml:space="preserve">
          <source>Austria</source>
          <target state="translated">Austria</target>
        </trans-unit>
        <trans-unit id="ee1acfa55eb1476c86c5c4a68f256a67b25289ab" translate="yes" xml:space="preserve">
          <source>Authentication</source>
          <target state="translated">Authentication</target>
        </trans-unit>
        <trans-unit id="82656d2a2fb6c8f1a253abb7becf3394411412ee" translate="yes" xml:space="preserve">
          <source>Authentication Options</source>
          <target state="translated">인증 옵션</target>
        </trans-unit>
        <trans-unit id="c865177e0c921a534568f3c9eaaf61496b61a49a" translate="yes" xml:space="preserve">
          <source>Authentication Plugin</source>
          <target state="translated">인증 플러그인</target>
        </trans-unit>
        <trans-unit id="cab7b1bf89e60f26f3f8fdcbc834d26ac2fea195" translate="yes" xml:space="preserve">
          <source>Authentication Plugin - &lt;code&gt;ed25519&lt;/code&gt;</source>
          <target state="translated">인증 플러그인 &lt;code&gt;ed25519&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="994e49e438fe166b7e64580bcbb9d6f21d395b5b" translate="yes" xml:space="preserve">
          <source>Authentication Plugin - &lt;code&gt;gssapi&lt;/code&gt;</source>
          <target state="translated">인증 플러그인 &lt;code&gt;gssapi&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="684097d79ab90ea99c28e17db67a6a4f4a9cc21d" translate="yes" xml:space="preserve">
          <source>Authentication Plugin - &lt;code&gt;named_pipe&lt;/code&gt;</source>
          <target state="translated">인증 플러그인 &lt;code&gt;named_pipe&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c7cfc0e84a59427f6e1c0e032c48e16e45764ada" translate="yes" xml:space="preserve">
          <source>Authentication Plugin - &lt;code&gt;pam&lt;/code&gt;</source>
          <target state="translated">인증 플러그인 &lt;code&gt;pam&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dd8be9f79d9b94cebcbb884aa49a18dc2b8ebca0" translate="yes" xml:space="preserve">
          <source>Authentication Plugin - &lt;code&gt;unix_socket&lt;/code&gt;</source>
          <target state="translated">인증 플러그인 &lt;code&gt;unix_socket&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="014e487926412fc0da03fd7d5809ea03dbb4f6ab" translate="yes" xml:space="preserve">
          <source>Authentication Plugin - GSSAPI</source>
          <target state="translated">인증 플러그인-GSSAPI</target>
        </trans-unit>
        <trans-unit id="98c397da7c73cdc3c4177874362f73987d3ed28d" translate="yes" xml:space="preserve">
          <source>Authentication Plugin - Named Pipe</source>
          <target state="translated">인증 플러그인-명명 된 파이프</target>
        </trans-unit>
        <trans-unit id="c9a3f78e68808addf26dfdfafc3ffc2042951d95" translate="yes" xml:space="preserve">
          <source>Authentication Plugin - PAM</source>
          <target state="translated">인증 플러그인-PAM</target>
        </trans-unit>
        <trans-unit id="b36fb162c37af1a69bae735cafae38752ad4b7b1" translate="yes" xml:space="preserve">
          <source>Authentication Plugin - SHA-256</source>
          <target state="translated">인증 플러그인-SHA-256</target>
        </trans-unit>
        <trans-unit id="7581cf0920bf1aa46e6140f5ed8385ddfaeb03d1" translate="yes" xml:space="preserve">
          <source>Authentication Plugin - Unix Socket</source>
          <target state="translated">인증 플러그인-유닉스 소켓</target>
        </trans-unit>
        <trans-unit id="99ede0d2dfe3fd25156e474f5715329fc7835c48" translate="yes" xml:space="preserve">
          <source>Authentication Plugin - ed25519</source>
          <target state="translated">인증 플러그인-ed25519</target>
        </trans-unit>
        <trans-unit id="24bc5dae4fb02aa5969465cf1c637b6856521629" translate="yes" xml:space="preserve">
          <source>Authentication Plugin - mysql_native_password</source>
          <target state="translated">인증 플러그인-mysql_native_password</target>
        </trans-unit>
        <trans-unit id="8c47c31362fbf5944f1b3bbce124dce729fbdee2" translate="yes" xml:space="preserve">
          <source>Authentication Plugin - mysql_old_password</source>
          <target state="translated">인증 플러그인-mysql_old_password</target>
        </trans-unit>
        <trans-unit id="276423a0ac52e8ba23119b46fe27714e5f4e0741" translate="yes" xml:space="preserve">
          <source>Authentication Plugin API</source>
          <target state="translated">인증 플러그인 API</target>
        </trans-unit>
        <trans-unit id="b60d50fc772390bb737d79bea8c97d24c9c2b966" translate="yes" xml:space="preserve">
          <source>Authentication Plugin Support</source>
          <target state="translated">인증 플러그인 지원</target>
        </trans-unit>
        <trans-unit id="c4cf4f25f0e512b16bb711090bbdc5132f6ba919" translate="yes" xml:space="preserve">
          <source>Authentication Plugins</source>
          <target state="translated">인증 플러그인</target>
        </trans-unit>
        <trans-unit id="679b371a9b85d54e88c102de44b71f4ca42905bd" translate="yes" xml:space="preserve">
          <source>Authentication Plugins - Options and System Variables</source>
          <target state="translated">인증 플러그인-옵션 및 시스템 변수</target>
        </trans-unit>
        <trans-unit id="bcce6ef0de8099cf7ae4af2803acd827b0139bb7" translate="yes" xml:space="preserve">
          <source>Authentication Plugins Installed by Default</source>
          <target state="translated">기본적으로 설치된 인증 플러그인</target>
        </trans-unit>
        <trans-unit id="0857461d8bad3057337e51c894c3357804198cdc" translate="yes" xml:space="preserve">
          <source>Authentication and Privileges</source>
          <target state="translated">인증 및 권한</target>
        </trans-unit>
        <trans-unit id="04c6e8941e95f101d2ca80b1616014b9ac04527c" translate="yes" xml:space="preserve">
          <source>Authentication and TLS</source>
          <target state="translated">인증 및 TLS</target>
        </trans-unit>
        <trans-unit id="b53a7e1381950f8e408961589e9cb816d57d0649" translate="yes" xml:space="preserve">
          <source>Authentication changes in MariaDB 10.4.</source>
          <target state="translated">MariaDB 10.4의 인증 변경.</target>
        </trans-unit>
        <trans-unit id="cf807ef88ac5d10a273c5f07284dc23aca805e7e" translate="yes" xml:space="preserve">
          <source>Authentication from MariaDB 10.4</source>
          <target state="translated">MariaDB 10.4에서 인증</target>
        </trans-unit>
        <trans-unit id="225cbecccc660987ae9778e4074130d695a93511" translate="yes" xml:space="preserve">
          <source>Authentication in MariaDB 10.4 &amp;mdash; understanding the changes (mariadb.org)</source>
          <target state="translated">MariaDB 10.4의 인증-변경 사항 이해 (mariadb.org)</target>
        </trans-unit>
        <trans-unit id="5bc4fd7948470aebd09e18ade46cdac7cf3e368c" translate="yes" xml:space="preserve">
          <source>Authentication plugin used on connection. If empty, uses the &lt;a href=&quot;#authentication-plugin&quot;&gt;default&lt;/a&gt;.</source>
          <target state="translated">연결에 사용되는 인증 플러그인. 비어 있으면 &lt;a href=&quot;#authentication-plugin&quot;&gt;기본값을&lt;/a&gt; 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="808d45b6a09f58b0902aeb90a81b77bfec1c9d9c" translate="yes" xml:space="preserve">
          <source>Authentication plugins allow various authentication methods to be used, and new ones developed.</source>
          <target state="translated">인증 플러그인을 사용하면 다양한 인증 방법을 사용하고 새로운 인증 방법을 개발할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1a4963fd2d473965253cb1468ea79fd31d1a217" translate="yes" xml:space="preserve">
          <source>Authentication string for the authentication plugin.</source>
          <target state="translated">인증 플러그인의 인증 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="d2392cba179a467eb6529b3b43d9021bc3cf538f" translate="yes" xml:space="preserve">
          <source>Authentication using LDAP. See the &lt;code&gt;&lt;a href=&quot;#pam_ldap&quot;&gt;pam_ldap&lt;/a&gt;&lt;/code&gt; PAM module.</source>
          <target state="translated">LDAP를 사용한 인증 &lt;code&gt;&lt;a href=&quot;#pam_ldap&quot;&gt;pam_ldap&lt;/a&gt;&lt;/code&gt; 참조 PAM 모듈을 .</target>
        </trans-unit>
        <trans-unit id="9fe2e174dc52ea476bc7d0c9fedf66fcfd306b3d" translate="yes" xml:space="preserve">
          <source>Authentication using Microsoft's Active Directory. See the &lt;code&gt;&lt;a href=&quot;#pam_lsass&quot;&gt;pam_lsass&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#pam_winbind&quot;&gt;pam_winbind&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#pam_centrifydc&quot;&gt;pam_centrifydc&lt;/a&gt;&lt;/code&gt; PAM modules.</source>
          <target state="translated">Microsoft의 Active Directory를 사용한 인증 &lt;code&gt;&lt;a href=&quot;#pam_lsass&quot;&gt;pam_lsass&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#pam_winbind&quot;&gt;pam_winbind&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#pam_centrifydc&quot;&gt;pam_centrifydc&lt;/a&gt;&lt;/code&gt; 를 참조하십시오. PAM 모듈을 .</target>
        </trans-unit>
        <trans-unit id="ddfef6754bc4da4ba959b58a75b89d1930df0a29" translate="yes" xml:space="preserve">
          <source>Authentication using SSH keys. See the &lt;code&gt;&lt;a href=&quot;#pam_ssh&quot;&gt;pam_ssh&lt;/a&gt;&lt;/code&gt; PAM module.</source>
          <target state="translated">SSH 키를 사용한 인증 &lt;code&gt;&lt;a href=&quot;#pam_ssh&quot;&gt;pam_ssh&lt;/a&gt;&lt;/code&gt; 참조 PAM 모듈을 .</target>
        </trans-unit>
        <trans-unit id="4ff66484b5219a0f67511f4464168c9dc76b67e7" translate="yes" xml:space="preserve">
          <source>Authentication using one-time passwords (even with SMS confirmation!). See the &lt;code&gt;&lt;a href=&quot;#pam_google_authenticator&quot;&gt;pam_google_authenticator&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#pam_securid&quot;&gt;pam_securid&lt;/a&gt;&lt;/code&gt; PAM modules.</source>
          <target state="translated">일회용 비밀번호를 사용한 인증 (SMS 확인으로도)! &lt;code&gt;&lt;a href=&quot;#pam_google_authenticator&quot;&gt;pam_google_authenticator&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#pam_securid&quot;&gt;pam_securid&lt;/a&gt;&lt;/code&gt; 를 참조하십시오. PAM 모듈을 .</target>
        </trans-unit>
        <trans-unit id="5448e38aee587818ae6d7ff1c92bd66c6d04d128" translate="yes" xml:space="preserve">
          <source>Authentication using passwords from &lt;code&gt;/etc/shadow&lt;/code&gt; (indeed, this is what a default PAM configuration usually does). See the &lt;code&gt;&lt;a href=&quot;#pam_unix&quot;&gt;pam_unix&lt;/a&gt;&lt;/code&gt; PAM module.</source>
          <target state="translated">&lt;code&gt;/etc/shadow&lt;/code&gt; 의 비밀번호를 사용한 인증 (실제로 기본 PAM 구성이 수행하는 방식) &lt;code&gt;&lt;a href=&quot;#pam_unix&quot;&gt;pam_unix&lt;/a&gt;&lt;/code&gt; PAM 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="600791ae44355a3f3d2a22d2bea5e9123621566b" translate="yes" xml:space="preserve">
          <source>Authentication with Pluggable Authentication Modules (PAM)</source>
          <target state="translated">PAM (Pluggable Authentication Modules)을 사용한 인증</target>
        </trans-unit>
        <trans-unit id="5e6a30d04176e0cd1e947cd5d89f4d00d57da911" translate="yes" xml:space="preserve">
          <source>Author of the plugin.</source>
          <target state="translated">플러그인 작성자.</target>
        </trans-unit>
        <trans-unit id="4e770b8f40b281a29662d28a3fb0792a561987ce" translate="yes" xml:space="preserve">
          <source>AuthorFN</source>
          <target state="translated">AuthorFN</target>
        </trans-unit>
        <trans-unit id="ec84c73b4169aacc06e3fd00886f4b44260b949e" translate="yes" xml:space="preserve">
          <source>AuthorLN</source>
          <target state="translated">AuthorLN</target>
        </trans-unit>
        <trans-unit id="c614ba7c453cdcd4d21b20e8286c6266c891e0c6" translate="yes" xml:space="preserve">
          <source>Auto</source>
          <target state="translated">Auto</target>
        </trans-unit>
        <trans-unit id="b3358fd26b3315663885c3c61bd945e72251d1ff" translate="yes" xml:space="preserve">
          <source>Auto Disabled</source>
          <target state="translated">자동 비활성화</target>
        </trans-unit>
        <trans-unit id="69955e81f061f10d213d2b93b9572db2a3423766" translate="yes" xml:space="preserve">
          <source>Auto Init</source>
          <target state="translated">자동 초기화</target>
        </trans-unit>
        <trans-unit id="b16fe104173cfe20f3641149aa003c95f382be7b" translate="yes" xml:space="preserve">
          <source>Auto Offline</source>
          <target state="translated">자동 오프라인</target>
        </trans-unit>
        <trans-unit id="8bd4ba810ddda167ad31e736aa73d3f95e1b0082" translate="yes" xml:space="preserve">
          <source>Auto increment for second part of a key behaves as documented (and as it does in MyISAM and other storage engines).</source>
          <target state="translated">키의 두 번째 부분에 대한 자동 증분은 문서화 된대로 (MyISAM 및 기타 스토리지 엔진에서와 같이) 작동합니다.</target>
        </trans-unit>
        <trans-unit id="ee3bed8aff683a1baccb657216b337a83793134c" translate="yes" xml:space="preserve">
          <source>Auto increment key</source>
          <target state="translated">자동 증분 키</target>
        </trans-unit>
        <trans-unit id="b2630a882aec8189ac5d1ea39ff8ff15d5d3e4a8" translate="yes" xml:space="preserve">
          <source>Auto initialization mode during a fault recovery</source>
          <target state="translated">결함 복구 중 자동 초기화 모드</target>
        </trans-unit>
        <trans-unit id="ce3338b334ae1872595553cff4743a6589013026" translate="yes" xml:space="preserve">
          <source>Auto initialization mode during a fault recovery.</source>
          <target state="translated">결함 복구 중 자동 초기화 모드.</target>
        </trans-unit>
        <trans-unit id="baf3410bad969d6cc986486da3e0aaccc845a351" translate="yes" xml:space="preserve">
          <source>Auto start of mysqld</source>
          <target state="translated">mysqld의 자동 시작</target>
        </trans-unit>
        <trans-unit id="33a4b9ef3f9718fe8b3f43665dac08692e579060" translate="yes" xml:space="preserve">
          <source>Auto-increment value in UPDATE conflicts with internally generated values</source>
          <target state="translated">UPDATE의 자동 증가 값이 내부적으로 생성 된 값과 충돌</target>
        </trans-unit>
        <trans-unit id="88334c1e6ebb81214233cb3f7a770e7ace3a7247" translate="yes" xml:space="preserve">
          <source>Auto-incrementing Columns</source>
          <target state="translated">자동 증분 열</target>
        </trans-unit>
        <trans-unit id="5168ef1634d3ed7d589b28f7265ec152bea3c01c" translate="yes" xml:space="preserve">
          <source>Auto_increment</source>
          <target state="translated">Auto_increment</target>
        </trans-unit>
        <trans-unit id="ad40fa2c637f8193b572cdc4fca9c4864eda6ec2" translate="yes" xml:space="preserve">
          <source>Autoincrement</source>
          <target state="translated">Autoincrement</target>
        </trans-unit>
        <trans-unit id="39d11cb93a3564d011529494e7ded61b616eaa75" translate="yes" xml:space="preserve">
          <source>Automated Table Creation on ColumnStore</source>
          <target state="translated">ColumnStore에서 자동 테이블 생성</target>
        </trans-unit>
        <trans-unit id="5adb5f106c3c90d483b0472fb30aaf8582e096e9" translate="yes" xml:space="preserve">
          <source>Automated restart based on excessive swapping</source>
          <target state="translated">과도한 스와핑에 따른 자동 재시작</target>
        </trans-unit>
        <trans-unit id="fc84857aca12b340fe6b4c71508b884fcb046d75" translate="yes" xml:space="preserve">
          <source>Automated system partitioning of columns is provided by ColumnStore. As data is loaded into extent maps, the system will capture and maintain min/max values of column data in that extent map. New rows are appended to each extent map until full at which point a new extent map is created. For column values that are ordered or semi-ordered this allows for very effective data partitioning. By using the min and max values, entire extent maps can be eliminated and not read to filter data. This generally works particularly well for time dimension / series data or similar values that increase over time.</source>
          <target state="translated">열의 자동 시스템 파티셔닝은 ColumnStore에서 제공합니다. 데이터가 범위 맵에로드되면 시스템은 해당 범위 맵에서 열 데이터의 최소 / 최대 값을 캡처하고 유지합니다. 새 범위 맵이 작성 될 때까지 새 범위가 각 범위 맵에 추가됩니다. 순서가 있거나 정렬 된 열 값의 경우 매우 효과적인 데이터 분할이 가능합니다. 최소값과 최대 값을 사용하면 전체 범위 맵을 제거하고 데이터를 필터링하기 위해 읽을 수 없습니다. 이는 일반적으로 시간 차원 / 시리즈 데이터 또는 시간이 지남에 따라 증가하는 유사한 값에 특히 효과적입니다.</target>
        </trans-unit>
        <trans-unit id="a13bde72781b9a33fe1e1f6f732013c354c2bfdd" translate="yes" xml:space="preserve">
          <source>Automatic &quot;reactive&quot; binding between inputs and outputs and extensive prebuilt widgets make it possible to build beautiful, responsive, and powerful applications with minimal effort.</source>
          <target state="translated">입력과 출력 사이의 자동 &quot;반응성&quot;바인딩과 광범위한 사전 빌드 위젯을 사용하면 최소한의 노력으로 아름답고 응답 성이 뛰어나고 강력한 애플리케이션을 구축 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63f691afcde850492f7f1a57d0ca848dd3ccb491" translate="yes" xml:space="preserve">
          <source>Automatic Crash Recovery</source>
          <target state="translated">자동 충돌 복구</target>
        </trans-unit>
        <trans-unit id="6a8b6c8662e85fad099aee226d1832569b19d9e2" translate="yes" xml:space="preserve">
          <source>Automatic Crash Recovery with the Binary Log-Based Transaction Coordinator Log</source>
          <target state="translated">이진 로그 기반 트랜잭션 코디네이터 로그를 사용한 자동 충돌 복구</target>
        </trans-unit>
        <trans-unit id="7f26eb020794ae4288d12c37a56ede30ac5afee0" translate="yes" xml:space="preserve">
          <source>Automatic Crash Recovery with the Memory-Mapped File-Based Transaction Coordinator Log</source>
          <target state="translated">메모리 매핑 된 파일 기반 트랜잭션 코디네이터 로그를 사용한 자동 충돌 복구</target>
        </trans-unit>
        <trans-unit id="0b502f4a1ddc8cff97298ea63f146eeb85f52f56" translate="yes" xml:space="preserve">
          <source>Automatic Creation of New Table Open Cache Instances</source>
          <target state="translated">새 테이블 오픈 캐시 인스턴스 자동 생성</target>
        </trans-unit>
        <trans-unit id="03516261cc7321451b3eaa19dacca1c74d93d7f3" translate="yes" xml:space="preserve">
          <source>Automatic Discovery</source>
          <target state="translated">자동 검색</target>
        </trans-unit>
        <trans-unit id="96135aa8bb94231fce956fd4bd5c88ec5fa81e3b" translate="yes" xml:space="preserve">
          <source>Automatic SQL syntax check</source>
          <target state="translated">자동 SQL 구문 검사</target>
        </trans-unit>
        <trans-unit id="f33e6538e3f64dff5c257719b1e76e459a165dfd" translate="yes" xml:space="preserve">
          <source>Automatic Sharding</source>
          <target state="translated">자동 샤딩</target>
        </trans-unit>
        <trans-unit id="5550683c9c581641faa072035761ffbc3023d756" translate="yes" xml:space="preserve">
          <source>Automatic Values</source>
          <target state="translated">자동 값</target>
        </trans-unit>
        <trans-unit id="f3d704b1f27c833c9e2d3a84925547b481ef301c" translate="yes" xml:space="preserve">
          <source>Automatic check of SQL syntax</source>
          <target state="translated">SQL 구문 자동 점검</target>
        </trans-unit>
        <trans-unit id="e102c1cdd44aea618330d31b76d755410d49d994" translate="yes" xml:space="preserve">
          <source>Automatic crash recovery occurs during startup when MariaDB needs to recover from a crash and &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-tc-heuristic-recover&quot;&gt;--tc-heuristic-recover&lt;/a&gt;&lt;/code&gt; is set to &lt;code&gt;OFF&lt;/code&gt;, which is the default value.</source>
          <target state="translated">MariaDB가 충돌에서 복구해야하고 &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-tc-heuristic-recover&quot;&gt;--tc-heuristic-recover&lt;/a&gt;&lt;/code&gt; 가 기본값 인 &lt;code&gt;OFF&lt;/code&gt; 로 설정된 경우 시작시 자동 충돌 복구가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="bde8509f8c83c5ea22266ec8d8b69da8de2af132" translate="yes" xml:space="preserve">
          <source>Automatic crash recovery.</source>
          <target state="translated">자동 충돌 복구.</target>
        </trans-unit>
        <trans-unit id="661a57263ed4f50223e52728ab0ecd416b0a810d" translate="yes" xml:space="preserve">
          <source>Automatic data report generation and delivery to the requested destination</source>
          <target state="translated">자동 데이터 보고서 생성 및 요청 대상으로 전달</target>
        </trans-unit>
        <trans-unit id="049983f82d1e9a5953437ca76f10e322dd7226eb" translate="yes" xml:space="preserve">
          <source>Automatic increment.</source>
          <target state="translated">자동 증분.</target>
        </trans-unit>
        <trans-unit id="2a93b272bb8372a5c37177d466871bcda8ec82cc" translate="yes" xml:space="preserve">
          <source>Automatic limit for SELECT when using --safe-updates. Default 1000.</source>
          <target state="translated">--safe-updates 사용시 SELECT의 자동 제한. 기본값은 1000입니다.</target>
        </trans-unit>
        <trans-unit id="6b16acf222e5bec7ea5c8517cc6263be7ddd1bcf" translate="yes" xml:space="preserve">
          <source>Automatic limit for rows in a join when using &lt;code&gt;--safe-updates&lt;/code&gt;. Default is 1000000.</source>
          <target state="translated">사용하는 경우 행에 대한 자동 한계 가입 &lt;code&gt;--safe-updates&lt;/code&gt; . 기본값은 1000000입니다.</target>
        </trans-unit>
        <trans-unit id="db1868d05507b7c5d366c3a28d43720061b6f274" translate="yes" xml:space="preserve">
          <source>Automatic membership control, failed nodes drop from the cluster</source>
          <target state="translated">자동 멤버쉽 제어, 클러스터에서 실패한 노드 삭제</target>
        </trans-unit>
        <trans-unit id="e0b8cffce90d703dc07bfe265a32269efc2ffafa" translate="yes" xml:space="preserve">
          <source>Automatic node joining</source>
          <target state="translated">자동 노드 결합</target>
        </trans-unit>
        <trans-unit id="f14921bd38ba33a7712295a05b1f6d39ff3760d4" translate="yes" xml:space="preserve">
          <source>Automatic object grouping by type</source>
          <target state="translated">유형별 자동 객체 그룹화</target>
        </trans-unit>
        <trans-unit id="c56fdd78b343aca06f90011f881f9a4ecbef5216" translate="yes" xml:space="preserve">
          <source>Automatic query round-robin distribution</source>
          <target state="translated">자동 쿼리 라운드 로빈 배포</target>
        </trans-unit>
        <trans-unit id="580ee1d453ae61ba88bd6caa7a8faec9e40dcc2d" translate="yes" xml:space="preserve">
          <source>Automatically set to &lt;code&gt;1&lt;/code&gt; when &lt;a href=&quot;#innodb_use_atomic_writes&quot;&gt;innodb_use_atomic_writes&lt;/a&gt; is set - see &lt;a href=&quot;../fusionio-directfs-atomic-write-support/index&quot;&gt;FusionIO DirectFS atomic write support&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#innodb_use_atomic_writes&quot;&gt;innodb_use_atomic_writes&lt;/a&gt; 가 설정 되면 자동으로 &lt;code&gt;1&lt;/code&gt; 로 설정 &lt;a href=&quot;../fusionio-directfs-atomic-write-support/index&quot;&gt;-FusionIO DirectFS 원자 쓰기 지원 참조&lt;/a&gt; . .</target>
        </trans-unit>
        <trans-unit id="8c9e00736eb86386f39e215b4fa6628cda98af4b" translate="yes" xml:space="preserve">
          <source>Automatically switch to vertical output mode if the result is wider than the terminal width.</source>
          <target state="translated">결과가 터미널 너비보다 넓 으면 자동으로 수직 출력 모드로 전환됩니다.</target>
        </trans-unit>
        <trans-unit id="4cde7e3d2272aba8578247f1453ca0b3e4e46a7c" translate="yes" xml:space="preserve">
          <source>Automation of routine data comparison and synchronization tasks using command line interface</source>
          <target state="translated">명령 행 인터페이스를 사용하여 일상적인 데이터 비교 및 ​​동기화 작업 자동화</target>
        </trans-unit>
        <trans-unit id="662ba4efb7043c1dd2a73188668caa70fc0f8206" translate="yes" xml:space="preserve">
          <source>Available Character Sets</source>
          <target state="translated">사용 가능한 문자 세트</target>
        </trans-unit>
        <trans-unit id="ffa8245f14750c32da3979ac01ae583f90bef5d0" translate="yes" xml:space="preserve">
          <source>Available DEB Packages</source>
          <target state="translated">사용 가능한 DEB 패키지</target>
        </trans-unit>
        <trans-unit id="5f76368e403720e7dace2e7da5df24b0a741ce85" translate="yes" xml:space="preserve">
          <source>Available DEB Packages in &lt;a href=&quot;../what-is-mariadb-101/index&quot;&gt;MariaDB 10.1&lt;/a&gt;</source>
          <target state="translated">사용 가능한 DEB 패키지 &lt;a href=&quot;../what-is-mariadb-101/index&quot;&gt;MariaDB 10.1&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8bdda43096101e744292b3303602e46696d8053a" translate="yes" xml:space="preserve">
          <source>Available DEB Packages in &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt; and &lt;a href=&quot;../what-is-mariadb-103/index&quot;&gt;MariaDB 10.3&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt; 에서 사용 가능한 DEB 패키지 및&lt;a href=&quot;../what-is-mariadb-103/index&quot;&gt; MariaDB 10.3&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="70ec70d0a84bb7fdcd362cd01a1f10d777ffbd34" translate="yes" xml:space="preserve">
          <source>Available DEB Packages in &lt;a href=&quot;../what-is-mariadb-104/index&quot;&gt;MariaDB 10.4&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../what-is-mariadb-104/index&quot;&gt;MariaDB 10.4&lt;/a&gt; 에서 사용 가능한 DEB 패키지</target>
        </trans-unit>
        <trans-unit id="f3119e6b080e25f2c00c492530aeae56f783647e" translate="yes" xml:space="preserve">
          <source>Available DEB Packages in &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt; 에서 사용 가능한 DEB 패키지</target>
        </trans-unit>
        <trans-unit id="7d850fc62b481cec1f39872b52ba106b252fe47f" translate="yes" xml:space="preserve">
          <source>Available Flags</source>
          <target state="translated">사용 가능한 플래그</target>
        </trans-unit>
        <trans-unit id="08cd42dbf224fb1d7ba4c8d71b952c7073d1746b" translate="yes" xml:space="preserve">
          <source>Available HandlerSocket Client Libraries</source>
          <target state="translated">사용 가능한 HandlerSocket 클라이언트 라이브러리</target>
        </trans-unit>
        <trans-unit id="4a9e092d1a4fc7d82b11319f1647c4429c3664e0" translate="yes" xml:space="preserve">
          <source>Available RPM Packages</source>
          <target state="translated">사용 가능한 RPM 패키지</target>
        </trans-unit>
        <trans-unit id="cc61ae6770e09cdb1a9163939631fdf4139c42d4" translate="yes" xml:space="preserve">
          <source>Available RPM Packages in &lt;a href=&quot;../what-is-mariadb-101/index&quot;&gt;MariaDB 10.1&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../what-is-mariadb-101/index&quot;&gt;MariaDB 10.1&lt;/a&gt; 에서 사용 가능한 RPM 패키지</target>
        </trans-unit>
        <trans-unit id="c2e59baefd3ab18813830820d5fbcbf7b9a92f02" translate="yes" xml:space="preserve">
          <source>Available RPM Packages in &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt; and &lt;a href=&quot;../what-is-mariadb-103/index&quot;&gt;MariaDB 10.3&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt; 및 &lt;a href=&quot;../what-is-mariadb-103/index&quot;&gt;MariaDB 10.3&lt;/a&gt; 에서 사용 가능한 RPM 패키지</target>
        </trans-unit>
        <trans-unit id="ddaa95bf9796380402a554cd78f7543305d23c1a" translate="yes" xml:space="preserve">
          <source>Available RPM Packages in &lt;a href=&quot;../what-is-mariadb-104/index&quot;&gt;MariaDB 10.4&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../what-is-mariadb-104/index&quot;&gt;MariaDB 10.4&lt;/a&gt; 에서 사용 가능한 RPM 패키지</target>
        </trans-unit>
        <trans-unit id="0d841e7d8c1688343c9ca7c8e1af4e5773f62dd7" translate="yes" xml:space="preserve">
          <source>Available RPM Packages in &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt; 에서 사용 가능한 RPM 패키지</target>
        </trans-unit>
        <trans-unit id="4c917e478091cc374b36a078748b8d32bc90dd31" translate="yes" xml:space="preserve">
          <source>Available character sets.</source>
          <target state="translated">사용 가능한 문자 세트.</target>
        </trans-unit>
        <trans-unit id="c7ae891e303935d834020d1d9ae935dd6cb11e73" translate="yes" xml:space="preserve">
          <source>Available event timers</source>
          <target state="translated">사용 가능한 이벤트 타이머</target>
        </trans-unit>
        <trans-unit id="0fc0bd18b77daa6380f925ff597465580437524d" translate="yes" xml:space="preserve">
          <source>Available event timers.</source>
          <target state="translated">사용 가능한 이벤트 타이머.</target>
        </trans-unit>
        <trans-unit id="221daddcae68c8e267b84841a5d2008e82466e9e" translate="yes" xml:space="preserve">
          <source>Available since version 3.1.14</source>
          <target state="translated">버전 3.1.14부터 사용 가능</target>
        </trans-unit>
        <trans-unit id="5d40b975c499b3ba350058af3dcd62f666903c1c" translate="yes" xml:space="preserve">
          <source>Avamm</source>
          <target state="translated">Avamm</target>
        </trans-unit>
        <trans-unit id="400b35c3d5cbcbd506a01381311c67bf20a5d769" translate="yes" xml:space="preserve">
          <source>Average length of column value, in bytes. Counted as if one ran &lt;code&gt;SELECT AVG(LENGTH(col))&lt;/code&gt;. This doesn't count &lt;code&gt;NULL&lt;/code&gt; bytes, assumes endspace removal for &lt;code&gt;CHAR(n)&lt;/code&gt;, etc.</source>
          <target state="translated">열 값의 평균 길이 (바이트)입니다. &lt;code&gt;SELECT AVG(LENGTH(col))&lt;/code&gt; 실행 한 것으로 계산됩니다 . 이것은 &lt;code&gt;NULL&lt;/code&gt; 바이트를 계산하지 않으며 &lt;code&gt;CHAR(n)&lt;/code&gt; 등의 끝 공간 제거를 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="4e3dc7f43cc405a2291075e992c4efe11119d066" translate="yes" xml:space="preserve">
          <source>Average number of blocks per record. Values higher than one indicate fragmentation. Use &lt;a href=&quot;../optimize-table/index&quot;&gt;OPTIMIZE TABLE&lt;/a&gt; to defragment.</source>
          <target state="translated">레코드 당 평균 블록 수 1보다 큰 값은 조각화를 나타냅니다. 조각 모음을 하려면 &lt;a href=&quot;../optimize-table/index&quot;&gt;OPTIMIZE TABLE&lt;/a&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="972899d0ebb498cd7a77c88e0cf3681ac2da9f1c" translate="yes" xml:space="preserve">
          <source>Average number of queries per client</source>
          <target state="translated">클라이언트 당 평균 쿼리 수</target>
        </trans-unit>
        <trans-unit id="7c93053218c02d71e8b3f7a1c6a7854cb54eda58" translate="yes" xml:space="preserve">
          <source>Average number of records one will find for given values of (keypart1, keypart2, ..), provided the values will be found in the table.</source>
          <target state="translated">주어진 값 (keypart1, keypart2, ..)에 대해 찾을 수있는 평균 레코드 수는 테이블에서 값을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbbe30c9a8ae673bd2d60009f5858d42fb38315a" translate="yes" xml:space="preserve">
          <source>Average number of records with the same value</source>
          <target state="translated">값이 같은 평균 레코드 수</target>
        </trans-unit>
        <trans-unit id="47ae406dbcf5ac38a523a201d66efc3e8831d89d" translate="yes" xml:space="preserve">
          <source>Average number of seconds to run all queries</source>
          <target state="translated">모든 쿼리를 실행하는 데 걸린 평균 시간 (초)</target>
        </trans-unit>
        <trans-unit id="a5fb4cbc9c5243d894ef3c875eab7253993fdeab" translate="yes" xml:space="preserve">
          <source>Average of the dependent variable (sum(ColumnY)/N), where N is number of rows processed by the query</source>
          <target state="translated">종속 변수의 평균 (sum (ColumnY) / N). 여기서 N은 쿼리로 처리 된 행 수입니다.</target>
        </trans-unit>
        <trans-unit id="db907829303ec1459fa5abfc48190c87a66a96f8" translate="yes" xml:space="preserve">
          <source>Average of the independent variable (sum(ColumnX)/N), where N is number of rows processed by the query</source>
          <target state="translated">독립 변수의 평균 (sum (ColumnX) / N). 여기서 N은 쿼리로 처리 된 행 수입니다.</target>
        </trans-unit>
        <trans-unit id="632a4abeb68d33b7666497bc15dade75f15d3329" translate="yes" xml:space="preserve">
          <source>Average row length in the table.</source>
          <target state="translated">테이블의 평균 행 길이</target>
        </trans-unit>
        <trans-unit id="f06490876e90cf147e474cd529bdbde5a6add05b" translate="yes" xml:space="preserve">
          <source>Average row length, that is &lt;code&gt;DATA_LENGTH&lt;/code&gt; divided by &lt;code&gt;TABLE_ROWS&lt;/code&gt;</source>
          <target state="translated">평균 행 길이, 즉 &lt;code&gt;DATA_LENGTH&lt;/code&gt; 를 &lt;code&gt;TABLE_ROWS&lt;/code&gt; 로 나눈 값</target>
        </trans-unit>
        <trans-unit id="9c21ad42f80347ddca07623302b5eb65086406c0" translate="yes" xml:space="preserve">
          <source>Average row length. For fixed rows, will be the actual length of each row.</source>
          <target state="translated">평균 행 길이 고정 행의 경우 각 행의 실제 길이가됩니다.</target>
        </trans-unit>
        <trans-unit id="4dcedc8b4df508392e34a90353103134d84b6895" translate="yes" xml:space="preserve">
          <source>Average value of a numeric (INT variations, NUMERIC, DECIMAL) column</source>
          <target state="translated">숫자 (INT 변형, NUMERIC, DECIMAL) 열의 평균 값</target>
        </trans-unit>
        <trans-unit id="368fc4df665b1337f66b2937dabd997ab60b40dd" translate="yes" xml:space="preserve">
          <source>Average value since being enabled.</source>
          <target state="translated">활성화 된 이후 평균 값입니다.</target>
        </trans-unit>
        <trans-unit id="e4804fd6ec1eb27c7a59344c4eecf227867b7142" translate="yes" xml:space="preserve">
          <source>Average value since last being reset.</source>
          <target state="translated">마지막으로 재설정 된 이후의 평균 값입니다.</target>
        </trans-unit>
        <trans-unit id="9d074db2193b8e6d4e67bf336acd7c03dc45f433" translate="yes" xml:space="preserve">
          <source>Average wait time of all delete operations that are timed.</source>
          <target state="translated">시간이 지정된 모든 삭제 작업의 평균 대기 시간입니다.</target>
        </trans-unit>
        <trans-unit id="3c2129cbdbaf605519c07dcfad785abf6b837cce" translate="yes" xml:space="preserve">
          <source>Average wait time of all external read locks that are timed.</source>
          <target state="translated">시간이 지정된 모든 외부 읽기 잠금의 평균 대기 시간입니다.</target>
        </trans-unit>
        <trans-unit id="351a556627f9866550e1c74c4c410b0164c95c6e" translate="yes" xml:space="preserve">
          <source>Average wait time of all external write locks that are timed.</source>
          <target state="translated">시간이 지정된 모든 외부 쓰기 잠금의 평균 대기 시간입니다.</target>
        </trans-unit>
        <trans-unit id="084bbc45612933466b7b0d26ed6afd03e95610a2" translate="yes" xml:space="preserve">
          <source>Average wait time of all fetch operations that are timed.</source>
          <target state="translated">시간이 지정된 모든 페치 조작의 평균 대기 시간입니다.</target>
        </trans-unit>
        <trans-unit id="2c02de596b48be7357db657d1faa8b8f39f2ca6d" translate="yes" xml:space="preserve">
          <source>Average wait time of all insert operations that are timed.</source>
          <target state="translated">시간이 지정된 모든 삽입 작업의 평균 대기 시간입니다.</target>
        </trans-unit>
        <trans-unit id="3f94bf97d0643efe50b7fd959819dba835c05d9e" translate="yes" xml:space="preserve">
          <source>Average wait time of all internal concurrent insert write locks that are timed.</source>
          <target state="translated">시간이 지정된 모든 내부 동시 삽입 쓰기 잠금의 평균 대기 시간입니다.</target>
        </trans-unit>
        <trans-unit id="c17e4344e281ed45126a0955f0027356f245ecbb" translate="yes" xml:space="preserve">
          <source>Average wait time of all internal read high priority locks that are timed.</source>
          <target state="translated">시간이 지정된 모든 내부 읽기 우선 순위가 높은 잠금의 평균 대기 시간입니다.</target>
        </trans-unit>
        <trans-unit id="4c9399aff8b3daf86a282b79a2cfa21a65c697ea" translate="yes" xml:space="preserve">
          <source>Average wait time of all internal read no insert locks that are timed.</source>
          <target state="translated">모든 내부 읽기의 평균 대기 시간이 시간 초과 된 삽입 잠금이 없습니다.</target>
        </trans-unit>
        <trans-unit id="0c92173ac40f438ebc8bc96668cd4423f7b6ce44" translate="yes" xml:space="preserve">
          <source>Average wait time of all internal read normal locks that are timed.</source>
          <target state="translated">시간이 지정된 모든 내부 읽기 정상 잠금의 평균 대기 시간입니다.</target>
        </trans-unit>
        <trans-unit id="469161e0fe93897f4ee4116874688386ccfac9cb" translate="yes" xml:space="preserve">
          <source>Average wait time of all internal read with shared locks that are timed.</source>
          <target state="translated">공유 잠금이 설정된 모든 내부 읽기의 평균 대기 시간입니다.</target>
        </trans-unit>
        <trans-unit id="538accf3248f95f554d7af3a3e97c1e27f15aca9" translate="yes" xml:space="preserve">
          <source>Average wait time of all internal write allow write locks that are timed.</source>
          <target state="translated">모든 내부 쓰기 허용 쓰기 잠금의 평균 대기 시간입니다.</target>
        </trans-unit>
        <trans-unit id="53b5b3c0102eee954ad3a3fd0aec1f32a32f8565" translate="yes" xml:space="preserve">
          <source>Average wait time of all internal write delayed locks that are timed.</source>
          <target state="translated">시간이 지정된 모든 내부 쓰기 지연 잠금의 평균 대기 시간입니다.</target>
        </trans-unit>
        <trans-unit id="144ef89161e2e44a67c86fc0a5a7f1a2ae003f56" translate="yes" xml:space="preserve">
          <source>Average wait time of all internal write low priority locks that are timed.</source>
          <target state="translated">모든 내부 쓰기 우선 순위가 낮은 잠금의 평균 대기 시간입니다.</target>
        </trans-unit>
        <trans-unit id="eac3ad8a33a7cc7c5966156f275cf9baff689e3f" translate="yes" xml:space="preserve">
          <source>Average wait time of all internal write normal locks that are timed.</source>
          <target state="translated">시간이 지정된 모든 내부 쓰기 정상 잠금의 평균 대기 시간입니다.</target>
        </trans-unit>
        <trans-unit id="6cc92f0a7ae2f0b87348c4478218e6d9a917086d" translate="yes" xml:space="preserve">
          <source>Average wait time of all miscellaneous operations that are timed.</source>
          <target state="translated">시간이 지정된 모든 기타 작업의 평균 대기 시간입니다.</target>
        </trans-unit>
        <trans-unit id="178e2c60e9d09c8a8b4ca168d9fe287e6b8941de" translate="yes" xml:space="preserve">
          <source>Average wait time of all read operations that are timed.</source>
          <target state="translated">시간이 지정된 모든 읽기 작업의 평균 대기 시간입니다.</target>
        </trans-unit>
        <trans-unit id="52d827cc98922078f4e4f78220471db785bf40ee" translate="yes" xml:space="preserve">
          <source>Average wait time of all update operations that are timed.</source>
          <target state="translated">시간이 지정된 모든 업데이트 작업의 평균 대기 시간입니다.</target>
        </trans-unit>
        <trans-unit id="9f302b7fdb7cd6409ad16a514fa9c29928eea61b" translate="yes" xml:space="preserve">
          <source>Average wait time of all write operations that are timed.</source>
          <target state="translated">시간이 지정된 모든 쓰기 작업의 평균 대기 시간입니다.</target>
        </trans-unit>
        <trans-unit id="285b6e208264dfb3d536bf8456860cf709de6953" translate="yes" xml:space="preserve">
          <source>Average wait time of the summarized events that are timed.</source>
          <target state="translated">시간이 지정된 요약 된 이벤트의 평균 대기 시간입니다.</target>
        </trans-unit>
        <trans-unit id="8c21295cd65b07996f86db2aed8d165cc0714ee3" translate="yes" xml:space="preserve">
          <source>Average wait time of the timed summarized events.</source>
          <target state="translated">시간 요약 된 이벤트의 평균 대기 시간.</target>
        </trans-unit>
        <trans-unit id="65e66ca24a54f18e64d5879b26caecdb9a510fd7" translate="yes" xml:space="preserve">
          <source>Averages, etc.</source>
          <target state="translated">평균 등</target>
        </trans-unit>
        <trans-unit id="cdc93143c600bc908604d885cdc906d44f8df53a" translate="yes" xml:space="preserve">
          <source>Avg</source>
          <target state="translated">Avg</target>
        </trans-unit>
        <trans-unit id="d01e2816a5f107e1bf87b09b605418cc40498c09" translate="yes" xml:space="preserve">
          <source>Avg_row_length</source>
          <target state="translated">Avg_row_length</target>
        </trans-unit>
        <trans-unit id="1881746222eccac3f35970f2df1df9e81b5c3f09" translate="yes" xml:space="preserve">
          <source>Avoiding PROXY table loop</source>
          <target state="translated">PROXY 테이블 루프 피하기</target>
        </trans-unit>
        <trans-unit id="4261da6c7f0cb5713b09d5cc86e642fe6107249b" translate="yes" xml:space="preserve">
          <source>Aways &lt;code&gt;def&lt;/code&gt;.</source>
          <target state="translated">멀리 &lt;code&gt;def&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ae4f281df5a5d0ff3cad6371f76d5c29b6d953ec" translate="yes" xml:space="preserve">
          <source>B</source>
          <target state="translated">B</target>
        </trans-unit>
        <trans-unit id="01ddf968a1c31909b2e290864943bf4f38391933" translate="yes" xml:space="preserve">
          <source>B) Statistics</source>
          <target state="translated">나) 통계</target>
        </trans-unit>
        <trans-unit id="665e6debd1e6182e551de8c48d73c5c97a1946f1" translate="yes" xml:space="preserve">
          <source>B-tree indexes</source>
          <target state="translated">B- 트리 인덱스</target>
        </trans-unit>
        <trans-unit id="9aee58f8d6350b83a9cc46998cb6e021044307c0" translate="yes" xml:space="preserve">
          <source>B-tree indexes also permit leftmost prefixing for searching of rows.</source>
          <target state="translated">B- 트리 인덱스는 또한 행 검색을위한 가장 왼쪽 접두사를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="d5879e6fe32d44b81e73aeb00ab5f9e85fabf948" translate="yes" xml:space="preserve">
          <source>B-tree indexes are used for column comparisons using the &amp;gt;, &amp;gt;=, =, &amp;gt;=, &amp;lt; or BETWEEN operators, as well as for LIKE comparisons that begin with a constant.</source>
          <target state="translated">B- 트리 인덱스는&amp;gt;,&amp;gt; =, =,&amp;gt; =, &amp;lt;또는 BETWEEN 연산자를 사용한 열 비교와 상수로 시작하는 LIKE 비교에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0a68ab5f20adfedd38ab8ef1573bfd3d192a41b4" translate="yes" xml:space="preserve">
          <source>B. The recommended R GUIs are RStudio Desktop, or RStudio Server: &lt;a href=&quot;https://www.rstudio.com/products/rstudio/&quot;&gt;RStudio&lt;/a&gt;</source>
          <target state="translated">B. 권장되는 R GUI는 RStudio Desktop 또는 RStudio Server입니다. &lt;a href=&quot;https://www.rstudio.com/products/rstudio/&quot;&gt;RStudio&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="119780fcfb9504465b3c170ca946e6dcbea8a982" translate="yes" xml:space="preserve">
          <source>BACKUP LOCK</source>
          <target state="translated">백업 잠금</target>
        </trans-unit>
        <trans-unit id="e05f737f6a785a669f82b9370aa5e89924cb3ce8" translate="yes" xml:space="preserve">
          <source>BACKUP LOCK blocks a table from DDL statements. This is mainly intended to be used by tools like &lt;a href=&quot;../mariabackup/index&quot;&gt;mariabackup&lt;/a&gt; that need to ensure there are no DDLs on a table while the table files are opened. For example, for an Aria table that stores data in 3 files with extensions .frm, .MAI and .MAD. Normal read/write operations can continue as normal.</source>
          <target state="translated">BACKUP LOCK은 DDL 문에서 테이블을 차단합니다. 이는 주로 테이블 파일이 열려있는 동안 테이블에 DDL이 없는지 확인해야하는 &lt;a href=&quot;../mariabackup/index&quot;&gt;mariabackup&lt;/a&gt; 과 같은 도구에서 사용하기위한 것 입니다. 예를 들어, 확장자가 .frm, .MAI 및 .MAD 인 3 개의 파일에 데이터를 저장하는 Aria 테이블의 경우. 정상적인 읽기 / 쓰기 작업은 정상적으로 계속 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3f7178db7b616522e563aab0de30c95d4cef4e2" translate="yes" xml:space="preserve">
          <source>BACKUP LOCK requires the &lt;code&gt;&lt;a href=&quot;../grant/index&quot;&gt;RELOAD&lt;/a&gt;&lt;/code&gt; privilege.</source>
          <target state="translated">백업 잠금에는 &lt;code&gt;&lt;a href=&quot;../grant/index&quot;&gt;RELOAD&lt;/a&gt;&lt;/code&gt; 권한이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="538cbfe3319e9c7ec3ace294da3c4d4df2cb4ad0" translate="yes" xml:space="preserve">
          <source>BACKUP STAGE</source>
          <target state="translated">백업 단계</target>
        </trans-unit>
        <trans-unit id="3ce6874e6899cb8500c689e4b1b919e9c02cd192" translate="yes" xml:space="preserve">
          <source>BACKUP TABLE (removed)</source>
          <target state="translated">백업 테이블 (제거됨)</target>
        </trans-unit>
        <trans-unit id="74bc636bb86a69364de0672a8b0749138cad41da" translate="yes" xml:space="preserve">
          <source>BACKUP TABLE was removed in &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt;.</source>
          <target state="translated">백업 테이블이 &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt; 에서 제거되었습니다 .</target>
        </trans-unit>
        <trans-unit id="daaa87849b9d8359f1126a84f8d9e67875dbe5c4" translate="yes" xml:space="preserve">
          <source>BACKUP commands</source>
          <target state="translated">백업 명령</target>
        </trans-unit>
        <trans-unit id="ab45c7f0433deece1a1d92088c14e6a2665bc8c2" translate="yes" xml:space="preserve">
          <source>BACKUP, QUICK</source>
          <target state="translated">백업, 빠른</target>
        </trans-unit>
        <trans-unit id="107ced5d2f4b8f446233bc479c1135a40d7cca0e" translate="yes" xml:space="preserve">
          <source>BANCROFT</source>
          <target state="translated">BANCROFT</target>
        </trans-unit>
        <trans-unit id="6bcefb04d3921089b801c12405f8563eee796aae" translate="yes" xml:space="preserve">
          <source>BARBOUD</source>
          <target state="translated">BARBOUD</target>
        </trans-unit>
        <trans-unit id="50ac6ba7283827ea78f4240345ab1473a6f5041c" translate="yes" xml:space="preserve">
          <source>BDB</source>
          <target state="translated">BDB</target>
        </trans-unit>
        <trans-unit id="84edf28e82b5b254032344c28c85b3b944ae08e2" translate="yes" xml:space="preserve">
          <source>BDB permitted the use of a patched version of the Berkeley DB key-value store. It was a transactional storage engine. Locking was performed at page level.</source>
          <target state="translated">BDB는 Berkeley DB 키-값 저장소의 패치 버전 사용을 허용했습니다. 트랜잭션 스토리지 엔진이었습니다. 페이지 레벨에서 잠금이 수행되었습니다.</target>
        </trans-unit>
        <trans-unit id="d95a02759d514396d5d053a2e6609f72baeb29c0" translate="yes" xml:space="preserve">
          <source>BDB storage engine</source>
          <target state="translated">BDB 스토리지 엔진</target>
        </trans-unit>
        <trans-unit id="e722ab591b6289d98a33c330d9d9c53de91b012a" translate="yes" xml:space="preserve">
          <source>BDB was a storage engine included in old versions of MySQL.</source>
          <target state="translated">BDB는 이전 버전의 MySQL에 포함 된 스토리지 엔진이었습니다.</target>
        </trans-unit>
        <trans-unit id="90a72ea1d2706a588dd39ad58e7cba99ec26696d" translate="yes" xml:space="preserve">
          <source>BEFORE</source>
          <target state="translated">BEFORE</target>
        </trans-unit>
        <trans-unit id="347683f398e688b2299a3815e6ed1ba9314ab5dc" translate="yes" xml:space="preserve">
          <source>BEFORE DELETE (only if a row is being deleted);</source>
          <target state="translated">삭제 전 (행이 삭제되는 경우에만);</target>
        </trans-unit>
        <trans-unit id="aefbecc3e97c162df3951d80d4409ef4ece2b268" translate="yes" xml:space="preserve">
          <source>BEFORE INSERT;</source>
          <target state="translated">삽입하기 전에;</target>
        </trans-unit>
        <trans-unit id="9157996f1175f9576a9776bfd08f7fec558e856d" translate="yes" xml:space="preserve">
          <source>BEFORE UPDATE;</source>
          <target state="translated">업데이트하기 전에;</target>
        </trans-unit>
        <trans-unit id="fdecbfe05f4fdccde8ed74d4a98bfeb1f4420314" translate="yes" xml:space="preserve">
          <source>BEGIN END</source>
          <target state="translated">시작 끝</target>
        </trans-unit>
        <trans-unit id="a9bd23d3ed7059fd84e8f5b0602d9f9b2a3dc803" translate="yes" xml:space="preserve">
          <source>BEL</source>
          <target state="translated">BEL</target>
        </trans-unit>
        <trans-unit id="7897c4e8b4b880406808baf8c35d4404b4417f20" translate="yes" xml:space="preserve">
          <source>BENCHMARK</source>
          <target state="translated">BENCHMARK</target>
        </trans-unit>
        <trans-unit id="dd0cb58b25aedcc24976c1937d094dfd36e9524a" translate="yes" xml:space="preserve">
          <source>BENCHMARK()</source>
          <target state="translated">BENCHMARK()</target>
        </trans-unit>
        <trans-unit id="32a6bb6f5239492cc33ffc5c5fac71a78e2ecf0c" translate="yes" xml:space="preserve">
          <source>BER</source>
          <target state="translated">BER</target>
        </trans-unit>
        <trans-unit id="918aa1208d28c7c33533a748de00b93186b139ed" translate="yes" xml:space="preserve">
          <source>BERTRAND</source>
          <target state="translated">BERTRAND</target>
        </trans-unit>
        <trans-unit id="f8e3370718865431368fd54f746d7da4322cc582" translate="yes" xml:space="preserve">
          <source>BETWEEN</source>
          <target state="translated">BETWEEN</target>
        </trans-unit>
        <trans-unit id="f575d951ae64f5976474b66bd45d4617a5a93ff1" translate="yes" xml:space="preserve">
          <source>BETWEEN AND</source>
          <target state="translated">와 ~ 사이에있는</target>
        </trans-unit>
        <trans-unit id="bd7b807b967db465a50a238da3f2863be5c1017f" translate="yes" xml:space="preserve">
          <source>BETWEEN...AND...</source>
          <target state="translated">BETWEEN...AND...</target>
        </trans-unit>
        <trans-unit id="2d0fe684054a53889de74128877e23cf3189b322" translate="yes" xml:space="preserve">
          <source>BIGINT</source>
          <target state="translated">BIGINT</target>
        </trans-unit>
        <trans-unit id="2038b3a8bd19eb4c36ce640a60755fff1294b791" translate="yes" xml:space="preserve">
          <source>BIGINT is almost never needed. It wastes at least 4 bytes per row (versus INT).</source>
          <target state="translated">BIGINT는 거의 필요하지 않습니다. 행당 최소 4 바이트를 낭비합니다 (INT와 비교).</target>
        </trans-unit>
        <trans-unit id="ed745838fe1478d5c12edde2c6a498fc4f7286f7" translate="yes" xml:space="preserve">
          <source>BIGINT is overkill, but that can't be fixed without changing other tables.</source>
          <target state="translated">BIGINT는 과잉이지만 다른 테이블을 변경하지 않고는 수정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ab6c38aea74109cf148ecf627e479c35852cef35" translate="yes" xml:space="preserve">
          <source>BIGINT, TINY, SHORT (pick the one that will fit the real data)</source>
          <target state="translated">BIGINT, TINY, SHORT (실제 데이터에 맞는 것을 선택하십시오)</target>
        </trans-unit>
        <trans-unit id="aaae2099195a1198825ba58353772ee89b771d3b" translate="yes" xml:space="preserve">
          <source>BIGINT, only reading is supported</source>
          <target state="translated">BIGINT, 읽기만 지원</target>
        </trans-unit>
        <trans-unit id="6883251e065a32f1dd8f3de4feae9bc21c5c18de" translate="yes" xml:space="preserve">
          <source>BIN</source>
          <target state="translated">BIN</target>
        </trans-unit>
        <trans-unit id="85663ae128aacc306c9c29f9d9d60ce1041f5031" translate="yes" xml:space="preserve">
          <source>BIN Table Type</source>
          <target state="translated">BIN 테이블 유형</target>
        </trans-unit>
        <trans-unit id="9d940979f5c77dfc1c5e7d0aa770d2943b298957" translate="yes" xml:space="preserve">
          <source>BIN()</source>
          <target state="translated">BIN()</target>
        </trans-unit>
        <trans-unit id="d05fb01e0b399387c3a28586f5fd296e2670d6a3" translate="yes" xml:space="preserve">
          <source>BINARY</source>
          <target state="translated">BINARY</target>
        </trans-unit>
        <trans-unit id="43a7e188169bd539951ed7e5c28c500bea1c76cd" translate="yes" xml:space="preserve">
          <source>BINARY OPERATOR</source>
          <target state="translated">이진 연산자</target>
        </trans-unit>
        <trans-unit id="aa39fe2f58fccf685b3092ca915ca72413bb2d47" translate="yes" xml:space="preserve">
          <source>BINARY Operator</source>
          <target state="translated">이진 연산자</target>
        </trans-unit>
        <trans-unit id="189c33a71de6674b568c5a8625fd629f832e865a" translate="yes" xml:space="preserve">
          <source>BINARY values are right-padded with &lt;code&gt;0x00&lt;/code&gt; (the zero byte) to the specified length when inserted. The padding is &lt;em&gt;not&lt;/em&gt; removed on select, so this needs to be taken into account when sorting and comparing, where all bytes are significant. The zero byte, &lt;code&gt;0x00&lt;/code&gt; is less than a space for comparison purposes.</source>
          <target state="translated">BINARY 값은 삽입시 지정된 길이까지 &lt;code&gt;0x00&lt;/code&gt; (0 바이트)으로 오른쪽에 채워집니다 . 패딩은 선택시 제거 &lt;em&gt;되지 않으므로&lt;/em&gt; 정렬 및 비교시 모든 바이트가 중요한 경우이를 고려해야합니다. 0 바이트 &lt;code&gt;0x00&lt;/code&gt; 은 비교를위한 공간보다 작습니다.</target>
        </trans-unit>
        <trans-unit id="073f8e2cb98030aa644bff5b1716b69fedb6c224" translate="yes" xml:space="preserve">
          <source>BINARY(M)</source>
          <target state="translated">BINARY(M)</target>
        </trans-unit>
        <trans-unit id="22bd4234becf80465fcbef336472590256e3f6a1" translate="yes" xml:space="preserve">
          <source>BINLOG</source>
          <target state="translated">BINLOG</target>
        </trans-unit>
        <trans-unit id="71eb30528b4e1ffc655ae9ec5265e8aa0ac73d19" translate="yes" xml:space="preserve">
          <source>BINLOG_GTID_POS</source>
          <target state="translated">BINLOG_GTID_POS</target>
        </trans-unit>
        <trans-unit id="5a7df274c223bc1057f9fd21e2813d96f398ee06" translate="yes" xml:space="preserve">
          <source>BINLOG_GTID_POS().</source>
          <target state="translated">BINLOG_GTID_POS().</target>
        </trans-unit>
        <trans-unit id="261b6d70eaf74bf465f2e78c1923e0b93e95e1c8" translate="yes" xml:space="preserve">
          <source>BIT</source>
          <target state="translated">BIT</target>
        </trans-unit>
        <trans-unit id="8d610f05159ee2c420c9b68ae2c57f887ee24fb4" translate="yes" xml:space="preserve">
          <source>BIT_AND</source>
          <target state="translated">BIT_AND</target>
        </trans-unit>
        <trans-unit id="545d23f3d4626754c0b72d3d4c7a693c2c0dfd07" translate="yes" xml:space="preserve">
          <source>BIT_AND()</source>
          <target state="translated">BIT_AND()</target>
        </trans-unit>
        <trans-unit id="99f5290e00d5af43b9a25cebb95de1fcebb3d455" translate="yes" xml:space="preserve">
          <source>BIT_COUNT</source>
          <target state="translated">BIT_COUNT</target>
        </trans-unit>
        <trans-unit id="71b15be9a53fe691ff6208f139b5c3f98c75e263" translate="yes" xml:space="preserve">
          <source>BIT_LENGTH</source>
          <target state="translated">BIT_LENGTH</target>
        </trans-unit>
        <trans-unit id="43f83afe6a63d69b53ce599273dcce3bb150f6de" translate="yes" xml:space="preserve">
          <source>BIT_OR</source>
          <target state="translated">BIT_OR</target>
        </trans-unit>
        <trans-unit id="dc80cc3abefd76f28441d5958b645c29918782ab" translate="yes" xml:space="preserve">
          <source>BIT_OR()</source>
          <target state="translated">BIT_OR()</target>
        </trans-unit>
        <trans-unit id="74aa2926f19b3b12f6146e2f4abb4074486f2d82" translate="yes" xml:space="preserve">
          <source>BIT_XOR</source>
          <target state="translated">BIT_XOR</target>
        </trans-unit>
        <trans-unit id="e3ac6c65000d45e4e8d53f0c7a25059c9d7e82a7" translate="yes" xml:space="preserve">
          <source>BIT_XOR()</source>
          <target state="translated">BIT_XOR()</target>
        </trans-unit>
        <trans-unit id="53368bdaf87c95ad5e5c2378e33a94ac324a8de0" translate="yes" xml:space="preserve">
          <source>BKA join interacts with the MRR functions respecting the following contract. The join procedure calls the MRR function multi_range_read_init passing it the callback functions that allows to initialize reading keys for the records in the join buffer and to iterate over these keys. It also passes the parameters of the buffer for MRR needs allocated within the join buffer space. Then BKA join repeatedly calls the MRR function multi_range_read_next. The function works as an iterator function over the records fetched by index look-ups with the keys produced by a callback function set in the call of multi_range_read_init. A call of the function multi_range_read_next returns the next fetched record through the dedicated record buffer, and the associated reference to the matched record from the join buffer as the output parameter of the function.</source>
          <target state="translated">BKA join은 다음 계약과 관련하여 MRR 기능과 상호 작용합니다. 조인 프로시 저는 MRR 함수 multi_range_read_init를 호출하여 조인 버퍼의 레코드에 대한 읽기 키를 초기화하고 이러한 키를 반복 할 수있는 콜백 함수를 전달합니다. 또한 결합 버퍼 공간 내에 할당 된 MRR 요구에 대한 버퍼의 매개 변수를 전달합니다. 그런 다음 BKA 조인은 MRR 함수 multi_range_read_next를 반복적으로 호출합니다. 이 함수는 multi_range_read_init 호출에서 설정된 콜백 함수에 의해 생성 된 키를 사용하여 인덱스 조회로 가져온 레코드에 대한 반복자 함수로 작동합니다. multi_range_read_next 함수의 호출은 전용 레코드 버퍼를 통해 다음 페치 된 레코드와 함수의 출력 매개 변수로서 결합 버퍼에서 일치하는 레코드에 대한 연관된 ​​참조를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="252078f5d329276b0611a894750005c61ca9f59a" translate="yes" xml:space="preserve">
          <source>BLACKHOLE</source>
          <target state="translated">BLACKHOLE</target>
        </trans-unit>
        <trans-unit id="b8edf3e54b305e7941aea3a1c3d69d80d7980fbd" translate="yes" xml:space="preserve">
          <source>BLACKHOLE and AUTO_INCREMENT</source>
          <target state="translated">BLACKHOLE 및 AUTO_INCREMENT</target>
        </trans-unit>
        <trans-unit id="1ce04f29dadb9973458555f164627f66e504686e" translate="yes" xml:space="preserve">
          <source>BLOB</source>
          <target state="translated">BLOB</target>
        </trans-unit>
        <trans-unit id="446fe38d2884d8cb01eeede1a1a4efdf5abb8bb9" translate="yes" xml:space="preserve">
          <source>BLOB and TEXT Data Types</source>
          <target state="translated">BLOB 및 TEXT 데이터 유형</target>
        </trans-unit>
        <trans-unit id="920672719b14dcc47cc53f3fe2f45a728c5a9a7c" translate="yes" xml:space="preserve">
          <source>BLOB column '%s' can't be used in key specification with the used table type</source>
          <target state="translated">BLOB 열 '% s'은 (는) 사용 된 테이블 형식의 키 사양에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9971475fcc6c053aab0c73b280048088b35c14e8" translate="yes" xml:space="preserve">
          <source>BLOB data</source>
          <target state="translated">BLOB 데이터</target>
        </trans-unit>
        <trans-unit id="fb0551e317ee17fbf9dd2ef14921e02221090dbc" translate="yes" xml:space="preserve">
          <source>BLOB fields</source>
          <target state="translated">BLOB 필드</target>
        </trans-unit>
        <trans-unit id="72c9e59be8fe2fa1b41b70a9da14f0a8b9d95fcd" translate="yes" xml:space="preserve">
          <source>BLOB, VARBINARY(n)</source>
          <target state="translated">BLOB, VARBINARY (n)</target>
        </trans-unit>
        <trans-unit id="9eeb53686a8207eee41c80d57701888aaea66e2e" translate="yes" xml:space="preserve">
          <source>BLOB, VARCHAR(n), use charset=latin1</source>
          <target state="translated">BLOB, VARCHAR (n), charset = latin1 사용</target>
        </trans-unit>
        <trans-unit id="98230c93ceac001ba167fefede7a1fcecbf64692" translate="yes" xml:space="preserve">
          <source>BLOB, VARCHAR(n), use charset=utf8</source>
          <target state="translated">BLOB, VARCHAR (n), charset = utf8 사용</target>
        </trans-unit>
        <trans-unit id="9b10027981f167e51c79d60b819af15b8e8bab7a" translate="yes" xml:space="preserve">
          <source>BLOB/TEXT column '%s' can't have a default value</source>
          <target state="translated">BLOB / TEXT 열 '% s'은 (는) 기본값을 가질 수 없습니다</target>
        </trans-unit>
        <trans-unit id="4fae45ff35dcfee9b41edb2c2e7833fe1efac7e2" translate="yes" xml:space="preserve">
          <source>BLOB/TEXT column '%s' used in key specification without a key length</source>
          <target state="translated">키 길이없이 키 사양에 사용 된 BLOB / TEXT 열 '% s'</target>
        </trans-unit>
        <trans-unit id="6fbd46c0220ac86bf1b05c02f5eee991f021643b" translate="yes" xml:space="preserve">
          <source>BLOBS can also be used to store &lt;a href=&quot;../dynamic-columns/index&quot;&gt;dynamic columns&lt;/a&gt;.</source>
          <target state="translated">BLOBS를 사용하여 &lt;a href=&quot;../dynamic-columns/index&quot;&gt;동적 열&lt;/a&gt; 을 저장할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5789e90210f37e783b104cdd8bda1fbf89c48e15" translate="yes" xml:space="preserve">
          <source>BLOCK all new write locks for all non transactional tables (except statistics and log tables). The command will not wait for tables that are in use by read-only transactions.</source>
          <target state="translated">모든 비 트랜잭션 테이블 (통계 및 로그 테이블 제외)에 대한 모든 새 쓰기 잠금을 차단하십시오. 이 명령은 읽기 전용 트랜잭션에서 사용중인 테이블을 기다리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="948661c7edb84e1f76521bb477622cc237e2446a" translate="yes" xml:space="preserve">
          <source>BLOCK_OFFSET</source>
          <target state="translated">BLOCK_OFFSET</target>
        </trans-unit>
        <trans-unit id="c4c51eeb133480a8ab13e2aac716dc1c49511996" translate="yes" xml:space="preserve">
          <source>BODY</source>
          <target state="translated">BODY</target>
        </trans-unit>
        <trans-unit id="292c7af4fff95bcd09dba6dcdd4b5f6d636b95c8" translate="yes" xml:space="preserve">
          <source>BOOL</source>
          <target state="translated">BOOL</target>
        </trans-unit>
        <trans-unit id="ab68d8e893a82cff70979ba20bec0023dbfe4be3" translate="yes" xml:space="preserve">
          <source>BOOLEAN</source>
          <target state="translated">BOOLEAN</target>
        </trans-unit>
        <trans-unit id="15ee9884969269f46015b0ba8853f36cd84e0de0" translate="yes" xml:space="preserve">
          <source>BOTH</source>
          <target state="translated">BOTH</target>
        </trans-unit>
        <trans-unit id="80d7ba4f26b8a9a8ce964e59d15e074272a70f5b" translate="yes" xml:space="preserve">
          <source>BOUNDARY</source>
          <target state="translated">BOUNDARY</target>
        </trans-unit>
        <trans-unit id="e5d3d21b70c00a962bebb8ef68db5915522c6975" translate="yes" xml:space="preserve">
          <source>BOUNDARY() is a synonym.</source>
          <target state="translated">BOUNDARY ()는 동의어입니다.</target>
        </trans-unit>
        <trans-unit id="dd9f4cf9a37be1add560fc3d0350beef75d56f71" translate="yes" xml:space="preserve">
          <source>BRM extent map</source>
          <target state="translated">BRM 범위 맵</target>
        </trans-unit>
        <trans-unit id="16374ac2b9a2eb53d18fcede0cdf14c4d6e18ba5" translate="yes" xml:space="preserve">
          <source>BS</source>
          <target state="translated">BS</target>
        </trans-unit>
        <trans-unit id="a69dcd9a9893ab875f11e4525fe2f72e89d9f38b" translate="yes" xml:space="preserve">
          <source>BSD Distributions</source>
          <target state="translated">BSD 배포</target>
        </trans-unit>
        <trans-unit id="f791693843b3a95b91bdc036548da14f1327fcff" translate="yes" xml:space="preserve">
          <source>BTREE</source>
          <target state="translated">BTREE</target>
        </trans-unit>
        <trans-unit id="8931ac668e3d61e205d75e36bfe6c40f97906824" translate="yes" xml:space="preserve">
          <source>BTREE is generally the default index type. For &lt;a href=&quot;../memory-storage-engine/index&quot;&gt;MEMORY&lt;/a&gt; tables, HASH is the default. &lt;a href=&quot;../tokudb/index&quot;&gt;TokuDB&lt;/a&gt; uses a particular data structure called &lt;em&gt;fractal trees&lt;/em&gt;, which is optimized for data that do not entirely fit memory.</source>
          <target state="translated">BTREE는 일반적으로 기본 색인 유형입니다. 들어 &lt;a href=&quot;../memory-storage-engine/index&quot;&gt;메모리&lt;/a&gt; 테이블, HASH가 기본값입니다. &lt;a href=&quot;../tokudb/index&quot;&gt;TokuDB&lt;/a&gt; 는 &lt;em&gt;프랙탈 트리&lt;/em&gt; 라는 특정 데이터 구조를 사용하는데 , 이는 메모리에 완전히 맞지 않는 데이터에 최적화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9bf932fde6e76c3fe6861a18d4e7fefe045c77a" translate="yes" xml:space="preserve">
          <source>BTREE, HASH</source>
          <target state="translated">BTREE, 해시</target>
        </trans-unit>
        <trans-unit id="b1b3e75b7eb72eb84496512ab918fbd43c5121c0" translate="yes" xml:space="preserve">
          <source>BTREE, RTREE</source>
          <target state="translated">BTREE, RTREE</target>
        </trans-unit>
        <trans-unit id="308818f0e7082cc6953dc96e5db5289db62e77e4" translate="yes" xml:space="preserve">
          <source>BUFFER</source>
          <target state="translated">BUFFER</target>
        </trans-unit>
        <trans-unit id="5337a56708ff692b5b145b8669bd51a4db1e1f5b" translate="yes" xml:space="preserve">
          <source>BUFFER() is a synonym.</source>
          <target state="translated">BUFFER ()는 동의어입니다.</target>
        </trans-unit>
        <trans-unit id="c7d2b0eb8268f524dc3182a49480b7d27c37a10e" translate="yes" xml:space="preserve">
          <source>BUFFERPOOLSIZE</source>
          <target state="translated">BUFFERPOOLSIZE</target>
        </trans-unit>
        <trans-unit id="64c3f5e89864d5e803ba483fadc3c80068321744" translate="yes" xml:space="preserve">
          <source>BY</source>
          <target state="translated">BY</target>
        </trans-unit>
        <trans-unit id="76e7efc54c030eef399e8d77cc5c6bc801173444" translate="yes" xml:space="preserve">
          <source>Babatunde</source>
          <target state="translated">Babatunde</target>
        </trans-unit>
        <trans-unit id="9b8d68a9088c344e82945c57f6462b36a907cdc8" translate="yes" xml:space="preserve">
          <source>Babbleopia</source>
          <target state="translated">Babbleopia</target>
        </trans-unit>
        <trans-unit id="db141a32e0e72fb23a4cb9e2d46bddf1ec0447fd" translate="yes" xml:space="preserve">
          <source>Back up tables in the given database that match a regular expression:</source>
          <target state="translated">주어진 데이터베이스에서 정규식과 일치하는 테이블을 백업하십시오.</target>
        </trans-unit>
        <trans-unit id="64dd60fe1a049fe6db3eb1369dec2e42bf428e21" translate="yes" xml:space="preserve">
          <source>Background</source>
          <target state="translated">Background</target>
        </trans-unit>
        <trans-unit id="961424d3d02c9e812d525bd9a01fd2adfbe6aeff" translate="yes" xml:space="preserve">
          <source>Background Operations</source>
          <target state="translated">백그라운드 작업</target>
        </trans-unit>
        <trans-unit id="d5749648ba46223f59d0b89a8b145b78a5bba6a3" translate="yes" xml:space="preserve">
          <source>Background SQL execution</source>
          <target state="translated">백그라운드 SQL 실행</target>
        </trans-unit>
        <trans-unit id="330b436bbc9860c67fcbfd6bf0c3261379aab12c" translate="yes" xml:space="preserve">
          <source>Background Setup</source>
          <target state="translated">백그라운드 설정</target>
        </trans-unit>
        <trans-unit id="bd452a7ea759269a521e984eabecb645ce4b2ea6" translate="yes" xml:space="preserve">
          <source>Background information</source>
          <target state="translated">배경 정보</target>
        </trans-unit>
        <trans-unit id="bae885bcf1b1cc7e9bff44178b0203e583e5e14f" translate="yes" xml:space="preserve">
          <source>Background: Mem-Comparable Keys</source>
          <target state="translated">배경 : 멤 비교 키</target>
        </trans-unit>
        <trans-unit id="a2179b27a9f07ee5f72b44094c9f6c242b0377d2" translate="yes" xml:space="preserve">
          <source>Backing Up and Restoring</source>
          <target state="translated">백업 및 복원</target>
        </trans-unit>
        <trans-unit id="245030e8ff3a4d02240daa5658f85d7b8af1177e" translate="yes" xml:space="preserve">
          <source>Backing Up and Restoring Databases</source>
          <target state="translated">데이터베이스 백업 및 복원</target>
        </trans-unit>
        <trans-unit id="09c9b449f78d5ceb4439cae807f06c5c0ce346cd" translate="yes" xml:space="preserve">
          <source>Backing up a single database</source>
          <target state="translated">단일 데이터베이스 백업</target>
        </trans-unit>
        <trans-unit id="6f0d32cfbab54251764f1ed3e4768eed4da74cd5" translate="yes" xml:space="preserve">
          <source>Backing up and restoring MariaDB.</source>
          <target state="translated">MariaDB 백업 및 복원</target>
        </trans-unit>
        <trans-unit id="0a384d8764f591c3e69b9883d717f1cb938824c9" translate="yes" xml:space="preserve">
          <source>Backing up incremental changes of a database</source>
          <target state="translated">데이터베이스의 증분 변경 백업</target>
        </trans-unit>
        <trans-unit id="ece17c63027de8b2d68f60653ff43a262ae98567" translate="yes" xml:space="preserve">
          <source>Backing up the Database Server</source>
          <target state="translated">데이터베이스 서버 백업</target>
        </trans-unit>
        <trans-unit id="08d812f33c26c06b48c15184918824e49c2c07a9" translate="yes" xml:space="preserve">
          <source>Backing up the Incremental Changes</source>
          <target state="translated">증분 변경 백업</target>
        </trans-unit>
        <trans-unit id="d53e04f13a4a4573878dc55ad3418059f598ee77" translate="yes" xml:space="preserve">
          <source>Backreferences match the same text as previously matched by a capturing group. Backreferences can be written using:</source>
          <target state="translated">역 참조는 이전에 캡처 그룹과 일치 한 텍스트와 일치합니다. 역 참조는 다음을 사용하여 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08b5482c8bd1b7e3e1b9794ab56d2e92b40b6230" translate="yes" xml:space="preserve">
          <source>Backreferences to a named subpattern can be written using the .NET syntax &lt;code&gt;\k{name}&lt;/code&gt;, the Perl syntax &lt;code&gt;\k&amp;lt;name&amp;gt;&lt;/code&gt; or &lt;code&gt;\k'name'&lt;/code&gt; or &lt;code&gt;\g{name}&lt;/code&gt;, or the Python syntax &lt;code&gt;(?P=name)&lt;/code&gt;.</source>
          <target state="translated">명명 된 하위 패턴에 대한 역 참조는 .NET 구문 &lt;code&gt;\k{name}&lt;/code&gt; , Perl 구문 &lt;code&gt;\k&amp;lt;name&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;\k'name'&lt;/code&gt; 또는 &lt;code&gt;\g{name}&lt;/code&gt; 또는 Python 구문 &lt;code&gt;(?P=name)&lt;/code&gt; 사용하여 작성할 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="d2255172d2385140daa08ac979b504f1c643e363" translate="yes" xml:space="preserve">
          <source>Backreferences to the subexpressions in the form &lt;code&gt;\N&lt;/code&gt;, where N is a number from 1 to 9:</source>
          <target state="translated">&lt;code&gt;\N&lt;/code&gt; 형식의 하위 표현식에 대한 역 참조 . 여기서 N은 1-9의 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="ba931a5987114c5b17bcd4d8f3970198de940e47" translate="yes" xml:space="preserve">
          <source>Backs up your databases.</source>
          <target state="translated">데이터베이스를 백업합니다.</target>
        </trans-unit>
        <trans-unit id="0daefefa411c975d45940b87e3bdc48739bc3a3e" translate="yes" xml:space="preserve">
          <source>Backslash (&amp;ldquo;\&amp;rdquo;).</source>
          <target state="translated">백 슬래시 (&amp;ldquo;\&amp;rdquo;).</target>
        </trans-unit>
        <trans-unit id="57dcdb00e1a4a9a89c26821a3e4593d21c0bec3d" translate="yes" xml:space="preserve">
          <source>Backslash (&lt;code&gt;\&lt;/code&gt;), if not used as an escape character, must always be escaped. When followed by a character that is not in the above table, backslashes will simply be ignored.</source>
          <target state="translated">이스케이프 문자로 사용되지 않는 경우 백 슬래시 ( &lt;code&gt;\&lt;/code&gt; )는 항상 이스케이프되어야합니다. 위 표에없는 문자가 뒤에 오면 백 슬래시는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="d4801dc3bb97efc4ec45f1462f1a0760055b5085" translate="yes" xml:space="preserve">
          <source>Backslash (\)</source>
          <target state="translated">백 슬래시 (\)</target>
        </trans-unit>
        <trans-unit id="88d130a66de8e5db01660642d9f23e1f0eef97dd" translate="yes" xml:space="preserve">
          <source>Backspace</source>
          <target state="translated">Backspace</target>
        </trans-unit>
        <trans-unit id="84e3bb9dd16cb2ba0f02d7245545feda5e3cabcb" translate="yes" xml:space="preserve">
          <source>Backspace.</source>
          <target state="translated">Backspace.</target>
        </trans-unit>
        <trans-unit id="c403a0978157860df57c83b5f1a499b2daef105e" translate="yes" xml:space="preserve">
          <source>Backstory</source>
          <target state="translated">Backstory</target>
        </trans-unit>
        <trans-unit id="76998d2534a4f8f6deeed23fc5a5b15150c8d8b0" translate="yes" xml:space="preserve">
          <source>Backup Back-End data</source>
          <target state="translated">백업 백엔드 데이터</target>
        </trans-unit>
        <trans-unit id="1f2f063f81cf79b9b9fe59e5777e0ab66ae64508" translate="yes" xml:space="preserve">
          <source>Backup ColumnStore Data Files</source>
          <target state="translated">백업 ColumnStore 데이터 파일</target>
        </trans-unit>
        <trans-unit id="446c7eb5399637e6993d3c9a834a868add1123e3" translate="yes" xml:space="preserve">
          <source>Backup Data in InfiniDB</source>
          <target state="translated">InfiniDB의 백업 데이터</target>
        </trans-unit>
        <trans-unit id="190923c508b14ba613ef66eb70786a96a49790b6" translate="yes" xml:space="preserve">
          <source>Backup Front-End schemas</source>
          <target state="translated">백업 프론트 엔드 스키마</target>
        </trans-unit>
        <trans-unit id="22fd3e13aee0e4b230ce05335151b59f0ec5ed0f" translate="yes" xml:space="preserve">
          <source>Backup Logging</source>
          <target state="translated">백업 로깅</target>
        </trans-unit>
        <trans-unit id="df502e75f436c95bd4c4f2df76e705ca2ef9130c" translate="yes" xml:space="preserve">
          <source>Backup Operation Notes</source>
          <target state="translated">백업 작업 노트</target>
        </trans-unit>
        <trans-unit id="9d90b635c1797cad92f7f81df9ab79fa4b0f4ab1" translate="yes" xml:space="preserve">
          <source>Backup Overview</source>
          <target state="translated">백업 개요</target>
        </trans-unit>
        <trans-unit id="08b8d8b78fafb45a7a26588ada39d7335bd507ff" translate="yes" xml:space="preserve">
          <source>Backup Return Codes</source>
          <target state="translated">백업 리턴 코드</target>
        </trans-unit>
        <trans-unit id="3c59adde5efcd762f42de41140024b7a6ceb5fde" translate="yes" xml:space="preserve">
          <source>Backup Setup</source>
          <target state="translated">백업 설정</target>
        </trans-unit>
        <trans-unit id="d1ea5d95ae41cd51068c61b94b988e392c9707f7" translate="yes" xml:space="preserve">
          <source>Backup Support for MariaDB-Exclusive Features</source>
          <target state="translated">MariaDB 독점 기능에 대한 백업 지원</target>
        </trans-unit>
        <trans-unit id="7f4a2d7fbd1e8f88deaa6abd680127dad19cb48a" translate="yes" xml:space="preserve">
          <source>Backup Tools</source>
          <target state="translated">백업 도구</target>
        </trans-unit>
        <trans-unit id="033968c29993901d042eaf1b3a4e12f154795ad3" translate="yes" xml:space="preserve">
          <source>Backup and Restore Overview</source>
          <target state="translated">백업 및 복원 개요</target>
        </trans-unit>
        <trans-unit id="44a42ccbccfe773b05929ee7978e5bf65b528502" translate="yes" xml:space="preserve">
          <source>Backup and Restore for MariaDB ColumnStore 1.0.x</source>
          <target state="translated">MariaDB ColumnStore 1.0.x의 백업 및 복원</target>
        </trans-unit>
        <trans-unit id="271f98e208aaedf9057fff0c5e5e4ae74a93e417" translate="yes" xml:space="preserve">
          <source>Backup and Restore for MariaDB ColumnStore 1.1.0 onwards</source>
          <target state="translated">MariaDB ColumnStore 1.1.0 이후 백업 및 복원</target>
        </trans-unit>
        <trans-unit id="0c849f6d1a3009e001716fc53efd69e2d84ccdaa" translate="yes" xml:space="preserve">
          <source>Backup and Restore package</source>
          <target state="translated">백업 및 복원 패키지</target>
        </trans-unit>
        <trans-unit id="ab4e5e5a47b82600b4bfb7f07dca23e96ec6fe30" translate="yes" xml:space="preserve">
          <source>Backup and Restore package The Backup and Restore is part of the MariaDB C...</source>
          <target state="translated">백업 및 복원 패키지 백업 및 복원은 MariaDB C의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="53be20b944ebb2f2556e6b9834822f100f659b66" translate="yes" xml:space="preserve">
          <source>Backup assistance. &lt;a href=&quot;../backing-up-and-restoring/index&quot;&gt;Backups&lt;/a&gt; can more easily be run if a server is not actively changing the data. A common scenario is to replicate the data to slave, which is then disconnected from the master with the data in a stable state. Backup is then performed from this server. See &lt;a href=&quot;../replication-as-a-backup-solution/index&quot;&gt;Replication as a Backup Solution&lt;/a&gt;.</source>
          <target state="translated">백업 지원. 서버가 데이터를 적극적으로 변경하지 않으면 &lt;a href=&quot;../backing-up-and-restoring/index&quot;&gt;백업&lt;/a&gt; 을보다 쉽게 ​​실행할 수 있습니다. 일반적인 시나리오는 데이터를 슬레이브에 복제 한 다음 데이터가 안정적인 상태 인 상태에서 마스터와의 연결을 끊는 것입니다. 그런 다음이 서버에서 백업이 수행됩니다. &lt;a href=&quot;../replication-as-a-backup-solution/index&quot;&gt;백업 솔루션으로 복제를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0c0e1a87b8ad2da4546bfd4eae6b2471622714e0" translate="yes" xml:space="preserve">
          <source>Backup before you begin</source>
          <target state="translated">시작하기 전에 백업</target>
        </trans-unit>
        <trans-unit id="7299623c5fb92ca103b9d92838d0dc20843454d6" translate="yes" xml:space="preserve">
          <source>Backup can be achieved by simply copying the Server data directories under /usr/local/mariadb/columnstore/.</source>
          <target state="translated">/ usr / local / mariadb / columnstore / 아래에 서버 데이터 디렉토리를 복사하면 백업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31921f280226175e5c0a64cca4f3f7cc5793afb1" translate="yes" xml:space="preserve">
          <source>Backup can be achieved by simply copying the data directories or using vendor supplied backup or snapshot utilities for those directories. A files and directories in the data&amp;lt;N&amp;gt; directories where N represents a unique directory such as data1, data2, etc for each PM server.</source>
          <target state="translated">단순히 데이터 디렉토리를 복사하거나 해당 디렉토리에 공급 업체 제공 백업 또는 스냅 샷 유틸리티를 사용하여 백업을 수행 할 수 있습니다. data &amp;lt;N&amp;gt; 디렉토리의 파일 및 디렉토리. 여기서 N은 각 PM 서버에 대한 data1, data2 등의 고유 디렉토리를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="31711459e149d3a41ba06d30428ccdc61dbf2c75" translate="yes" xml:space="preserve">
          <source>Backup projects for saving settings for future use</source>
          <target state="translated">나중에 사용하기 위해 설정을 저장하기위한 백업 프로젝트</target>
        </trans-unit>
        <trans-unit id="2cb555ea6f88e999cf76d7fc2b96e96dd0efad79" translate="yes" xml:space="preserve">
          <source>Backup projects to save settings for future use</source>
          <target state="translated">나중에 사용할 수 있도록 설정을 저장하기위한 프로젝트 백업</target>
        </trans-unit>
        <trans-unit id="e78860da1db1fdba9d3104944d86046338e1fcb6" translate="yes" xml:space="preserve">
          <source>Backup scripts may need checking. A MyISAM table can be backed up by copying three files. With InnoDB this is only possible if &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_file_per_table&quot;&gt;innodb_file_per_table&lt;/a&gt; is set to 1. Before &lt;a href=&quot;../what-is-mariadb-100/index&quot;&gt;MariaDB 10.0&lt;/a&gt;, capturing a table or database for copying from production to a development environment was not possible. Change to &lt;a href=&quot;../mysqldump/index&quot;&gt;mysqldump&lt;/a&gt;. Since &lt;a href=&quot;../what-is-mariadb-100/index&quot;&gt;MariaDB 10.0&lt;/a&gt; a hot copy can be created - see &lt;a href=&quot;../backup-and-restore-overview/index&quot;&gt;Backup and restore overview&lt;/a&gt;.</source>
          <target state="translated">백업 스크립트를 확인해야 할 수도 있습니다. 세 개의 파일을 복사하여 MyISAM 테이블을 백업 할 수 있습니다. InnoDB를 사용하면 &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_file_per_table&quot;&gt;innodb_file_per_table&lt;/a&gt; 이 1로 설정된 경우에만 가능합니다 . &lt;a href=&quot;../what-is-mariadb-100/index&quot;&gt;MariaDB 10.0&lt;/a&gt; 이전 에는 프로덕션에서 개발 환경으로 복사 할 테이블 또는 데이터베이스를 캡처 할 수 없었습니다. &lt;a href=&quot;../mysqldump/index&quot;&gt;mysqldump로&lt;/a&gt; 변경하십시오 . &lt;a href=&quot;../what-is-mariadb-100/index&quot;&gt;MariaDB 10.0&lt;/a&gt; 부터 핫 카피를 생성 할 수 있습니다 ( &lt;a href=&quot;../backup-and-restore-overview/index&quot;&gt;백업 및 복원 개요&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="0d55d4a63d3b3eb5acbbab76da76144fe5d0c9d9" translate="yes" xml:space="preserve">
          <source>Backup the ColumnStore data files.</source>
          <target state="translated">ColumnStore 데이터 파일을 백업하십시오.</target>
        </trans-unit>
        <trans-unit id="f8cff0398582da03eae0438e1f58d00689a03dd3" translate="yes" xml:space="preserve">
          <source>Backup the Database and Prepare It</source>
          <target state="translated">데이터베이스 백업 및 준비</target>
        </trans-unit>
        <trans-unit id="b338bc37cf3c0322e7efb7013764ea676b24d5fd" translate="yes" xml:space="preserve">
          <source>Backup the Database on the Cluster's Master Node and Prepare It</source>
          <target state="translated">클러스터의 마스터 노드에서 데이터베이스 백업 및 준비</target>
        </trans-unit>
        <trans-unit id="a9f04aae0216a9c6c943197a62ad0686edf6d81e" translate="yes" xml:space="preserve">
          <source>Backup the Database on the First Cluster's Master Node and Prepare It</source>
          <target state="translated">첫 번째 클러스터의 마스터 노드에서 데이터베이스 백업 및 준비</target>
        </trans-unit>
        <trans-unit id="2cc2841ec0ffe3b1484985f04d9d1544a2b3aefe" translate="yes" xml:space="preserve">
          <source>Backup the MariaDB Server data files</source>
          <target state="translated">MariaDB 서버 데이터 파일 백업</target>
        </trans-unit>
        <trans-unit id="a43921c34942b6507e5849ddb394dadb28eeda8c" translate="yes" xml:space="preserve">
          <source>Backup the MariaDB Server data files.</source>
          <target state="translated">MariaDB 서버 데이터 파일을 백업하십시오.</target>
        </trans-unit>
        <trans-unit id="1cff3d9b13a2a9e0c6307a51b9e838b3d9996bbd" translate="yes" xml:space="preserve">
          <source>Backup, Restore and Import Clients</source>
          <target state="translated">클라이언트 백업, 복원 및 가져 오기</target>
        </trans-unit>
        <trans-unit id="2635ba5dac03bef619332d6b20fd30a6cc8dd6aa" translate="yes" xml:space="preserve">
          <source>Backup/Restore Process for MariaDB ColumnStore 1.0.x</source>
          <target state="translated">MariaDB ColumnStore 1.0.x의 백업 / 복원 프로세스</target>
        </trans-unit>
        <trans-unit id="1c6e8e775825dfd978d7175a1816afd485b94104" translate="yes" xml:space="preserve">
          <source>Backup/Restore Process for MariaDB ColumnStore 1.0.x Backup Overview The h...</source>
          <target state="translated">MariaDB ColumnStore 1.0.x 백업의 백업 / 복원 프로세스 개요</target>
        </trans-unit>
        <trans-unit id="66c35af164d1cc1326249b18872e66a6f0ec84c1" translate="yes" xml:space="preserve">
          <source>Backup/Restore of tables using &lt;a href=&quot;../data-at-rest-encryption/index&quot;&gt;Data-at-Rest Encryption&lt;/a&gt;.</source>
          <target state="translated">미사용 &lt;a href=&quot;../data-at-rest-encryption/index&quot;&gt;데이터 암호화를&lt;/a&gt; 사용한 테이블 백업 / 복원 .</target>
        </trans-unit>
        <trans-unit id="b520ade10944b46d3e600899bcecefc88736ee39" translate="yes" xml:space="preserve">
          <source>Backup/Restore of tables using &lt;a href=&quot;innodb_compression&quot;&gt;InnoDB Page Compression&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;innodb_compression&quot;&gt;InnoDB 페이지 압축을&lt;/a&gt; 사용한 테이블 백업 / 복원 .</target>
        </trans-unit>
        <trans-unit id="9d66743d165e2ce7a4df4db5608eb8d7c1794bff" translate="yes" xml:space="preserve">
          <source>Backup/Restore of tables using the &lt;a href=&quot;../myrocks/index&quot;&gt;MyRocks&lt;/a&gt; storage engine starting with &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10216-release-notes/&quot;&gt;MariaDB 10.2.16&lt;/a&gt; and &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1038-release-notes/&quot;&gt;MariaDB 10.3.8&lt;/a&gt;. See &lt;a href=&quot;../files-backed-up-by-mariabackup/index#myrocks-data-files&quot;&gt;Files Backed up by Mariabackup: MyRocks Data Files&lt;/a&gt; for more information.</source>
          <target state="translated">백업 /를 사용하여 테이블의 복원 &lt;a href=&quot;../myrocks/index&quot;&gt;MyRocks의&lt;/a&gt; 로 시작하는 스토리지 엔진 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10216-release-notes/&quot;&gt;MariaDB 10.2.16&lt;/a&gt; 및 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1038-release-notes/&quot;&gt;MariaDB 10.3.8&lt;/a&gt; . 자세한 정보 &lt;a href=&quot;../files-backed-up-by-mariabackup/index#myrocks-data-files&quot;&gt;는 Mariabackup으로 백업 된 파일 : MyRocks 데이터 파일&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="31e50caa1ee4428adbe51a5a19d3afdb123266b9" translate="yes" xml:space="preserve">
          <source>Backups are then run off the slave without any impact on the master.</source>
          <target state="translated">그런 다음 마스터에 영향을주지 않고 백업이 슬레이브에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="16c4dd20717590ff570d14aebd7ae05ae9b121c5" translate="yes" xml:space="preserve">
          <source>Backups can have a significant effect on a server, and a high-availability master may not be able to be stopped, locked or simply handle the extra load of a backup. Running the backup from a slave has the advantage of being able to shutdown or lock the slave and perform a backup without any impact on the primary server.</source>
          <target state="translated">백업은 서버에 큰 영향을 줄 수 있으며 고 가용성 마스터를 중지하거나 잠 그거나 단순히 추가 백업로드를 처리하지 못할 수 있습니다. 슬레이브에서 백업을 실행하면 슬레이브를 종료하거나 잠그고 기본 서버에 영향을주지 않고 백업을 수행 할 수 있다는 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3dffa78c4ba7e34a0d5efdf49b6e775e7097a8c" translate="yes" xml:space="preserve">
          <source>Bad SQLSTATE: '%s'</source>
          <target state="translated">잘못된 SQLSTATE : '% s'</target>
        </trans-unit>
        <trans-unit id="096fa3dd82441aa153ea25559761504f448be825" translate="yes" xml:space="preserve">
          <source>Bad base64 data as position %u</source>
          <target state="translated">위치 % u로 잘못된 base64 데이터</target>
        </trans-unit>
        <trans-unit id="24f174b15ec6046069e1c298bd150a7ad8007f50" translate="yes" xml:space="preserve">
          <source>Bad handshake</source>
          <target state="translated">나쁜 악수</target>
        </trans-unit>
        <trans-unit id="b2133109e4430bac28d6173aad513fd7877699f2" translate="yes" xml:space="preserve">
          <source>Bad magic header in tc log</source>
          <target state="translated">TC 로그의 잘못된 매직 헤더</target>
        </trans-unit>
        <trans-unit id="308cbc721f9e003c14fdf3cce6d9ca462ae0d567" translate="yes" xml:space="preserve">
          <source>Bad record error processing</source>
          <target state="translated">잘못된 레코드 오류 처리</target>
        </trans-unit>
        <trans-unit id="f91dff423811e8313d0393e272f266d04a8c08ea" translate="yes" xml:space="preserve">
          <source>Bad schema for mysql.ndb_replication table. Message: %s</source>
          <target state="translated">mysql.ndb_replication 테이블에 대한 스키마가 잘못되었습니다. 메시지 : % s</target>
        </trans-unit>
        <trans-unit id="335818a855174729ed536c20c1eafe225f454ad7" translate="yes" xml:space="preserve">
          <source>Bad solution</source>
          <target state="translated">나쁜 해결책</target>
        </trans-unit>
        <trans-unit id="3ae11c725c30009d4d3418bc6b30789feed78322" translate="yes" xml:space="preserve">
          <source>Bahrain</source>
          <target state="translated">Bahrain</target>
        </trans-unit>
        <trans-unit id="e496fd20136d4bb7828ebb0ab925b1bd977208e4" translate="yes" xml:space="preserve">
          <source>Bar</source>
          <target state="translated">Bar</target>
        </trans-unit>
        <trans-unit id="0b376e0dced779e3242bacfc4edea767de2f9fc7" translate="yes" xml:space="preserve">
          <source>Barracuda</source>
          <target state="translated">Barracuda</target>
        </trans-unit>
        <trans-unit id="85665b4e73c78b3511b1d4c2441871e1ae245c98" translate="yes" xml:space="preserve">
          <source>Base directory of the chroot jail in which mysqld operates. The path value should match that of the &lt;code&gt;--chroot&lt;/code&gt; option given to mysqld.</source>
          <target state="translated">mysqld가 작동하는 chroot jail의 기본 디렉토리. 경로 값은 mysqld에 지정된 &lt;code&gt;--chroot&lt;/code&gt; 옵션 의 경로 값과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5902b5e88c9938f457ac1bffb103aff58c3cb173" translate="yes" xml:space="preserve">
          <source>Base directory.</source>
          <target state="translated">기본 디렉토리.</target>
        </trans-unit>
        <trans-unit id="9a7c81857bc82a8bd6be7a9db67d7e72b529947f" translate="yes" xml:space="preserve">
          <source>Base for port numbers. Ports from this number to number+9 are reserved. Should be divisible by 10; if not it will be rounded down. May be set with environment variable MTR_PORT_BASE. If this value is set and is not &quot;auto&quot;, it overrides build-thread.</source>
          <target state="translated">포트 번호의 기준. 이 숫자에서 숫자 + 9까지의 포트는 예약되어 있습니다. 10으로 나눌 수 있어야합니다. 그렇지 않으면 반올림됩니다. 환경 변수 MTR_PORT_BASE로 설정할 수 있습니다. 이 값이 설정되고 &quot;자동&quot;이 아닌 경우 빌드 스레드를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="129732303c7eadbd1d930f5c1b0d69a9b6a1a303" translate="yes" xml:space="preserve">
          <source>Base tables and views share the same namespace within a database, so a database cannot contain a base table and a view that have the same name.</source>
          <target state="translated">기본 테이블과 뷰는 데이터베이스 내에서 동일한 네임 스페이스를 공유하므로 데이터베이스는 기본 테이블과 이름이 같은 뷰를 포함 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="212dcc8545982d640d282c30ca1ba77dfc186314" translate="yes" xml:space="preserve">
          <source>Based on another table/view, used when object tables have a column that contains a list of values</source>
          <target state="translated">객체 테이블에 값 목록이 포함 된 열이있을 때 사용되는 다른 테이블 / 뷰 기반</target>
        </trans-unit>
        <trans-unit id="90e199ad327101b2a1b64a1f08897d3d5e74423e" translate="yes" xml:space="preserve">
          <source>Based on data we got in #1, read the matching records from the second table.</source>
          <target state="translated">우리가 # 1에 얻은 데이터를 기반으로 두 번째 테이블에서 일치하는 레코드를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="5fef2c674a812d1039d76ebf2d010e6a2c54bdb6" translate="yes" xml:space="preserve">
          <source>Based on the Apache common-dbcp2 package this interface enables making connections to DBCP data sources with any JDBC drivers.</source>
          <target state="translated">Apache common-dbcp2 패키지를 기반으로이 인터페이스를 사용하면 모든 JDBC 드라이버를 사용하여 DBCP 데이터 소스에 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd469c56906ea9e74e4f792af86add46cb4f5100" translate="yes" xml:space="preserve">
          <source>Basic Configuration</source>
          <target state="translated">기본 구성</target>
        </trans-unit>
        <trans-unit id="309b5d3b7526301b3a74711200a711f5c78d13ff" translate="yes" xml:space="preserve">
          <source>Basic Execution Data</source>
          <target state="translated">기본 실행 데이터</target>
        </trans-unit>
        <trans-unit id="42178c3abce08822222fb6db33579a87ed12e747" translate="yes" xml:space="preserve">
          <source>Basic Mroonga usage.</source>
          <target state="translated">기본 Mroonga 사용법.</target>
        </trans-unit>
        <trans-unit id="2ef672724e3344e1e6b8ba42ffe4c493223ce808" translate="yes" xml:space="preserve">
          <source>Basic Transactional support-- for supporting remote transactional tables</source>
          <target state="translated">기본 트랜잭션 지원-원격 트랜잭션 테이블 지원</target>
        </trans-unit>
        <trans-unit id="b20cbc384159fd820ed034fd3615298ec09f5902" translate="yes" xml:space="preserve">
          <source>Basic Usage</source>
          <target state="translated">기본 사용법</target>
        </trans-unit>
        <trans-unit id="09174fb3c891da28f3d7b9ca3d482a8f1007119a" translate="yes" xml:space="preserve">
          <source>Basic information about the existing spatial features can be found in the &lt;a href=&quot;../geographic-features/index&quot;&gt;Geographic Features&lt;/a&gt; section of the Knowlegebase. The &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.6/en/spatial-extensions.html&quot;&gt;Spatial Extensions page of the MySQL manual&lt;/a&gt; also applies to MariaDB.</source>
          <target state="translated">기존 공간 기능에 대한 기본 정보 는 Knowlegebase 의 &lt;a href=&quot;../geographic-features/index&quot;&gt;지리적 기능&lt;/a&gt; 섹션 에서 찾을 수 있습니다 . &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.6/en/spatial-extensions.html&quot;&gt;MySQL 매뉴얼&lt;/a&gt; 의 Spatial Extensions 페이지는 MariaDB에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="133d39d5205ac0d151efa114ce1c50100b9f8889" translate="yes" xml:space="preserve">
          <source>Basic information about the existing spatial features can be found in the &lt;a href=&quot;../geographic-features/index&quot;&gt;Geographic Features&lt;/a&gt; section of the Knowlegebase. The &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.6/en/spatial-extensions.html&quot;&gt;Spatial Extensions page of the MySQL manual&lt;/a&gt; also applies to MariaDB.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="166a7f60680dba8e9ad95c9d9310eaf38da6d66e" translate="yes" xml:space="preserve">
          <source>Basic information about the existing spatial features can be found in the G...</source>
          <target state="translated">기존 공간 기능에 대한 기본 정보는 G.</target>
        </trans-unit>
        <trans-unit id="5327904d692c1416b98aebdf497b1acf360e4b30" translate="yes" xml:space="preserve">
          <source>Basic information on MariaDB Galera Cluster.</source>
          <target state="translated">MariaDB Galera Cluster에 대한 기본 정보.</target>
        </trans-unit>
        <trans-unit id="124712dc67d987a8523b17a1ba1df7b689760fcf" translate="yes" xml:space="preserve">
          <source>Basic issues in RAM allocation for MariaDB.</source>
          <target state="translated">MariaDB에 대한 RAM 할당의 기본 문제</target>
        </trans-unit>
        <trans-unit id="9e39c1bf6d19a6e317c669d8bc9466868e62fad8" translate="yes" xml:space="preserve">
          <source>Basic setup</source>
          <target state="translated">기본 설정</target>
        </trans-unit>
        <trans-unit id="1ae1cf1a9f38e9dcca250037517a89540eff5b83" translate="yes" xml:space="preserve">
          <source>Basic transaction control statements.</source>
          <target state="translated">기본 트랜잭션 제어문.</target>
        </trans-unit>
        <trans-unit id="6e521bdc38fc0e7bd46b87934b8873f96368e5af" translate="yes" xml:space="preserve">
          <source>Basic user management</source>
          <target state="translated">기본 사용자 관리</target>
        </trans-unit>
        <trans-unit id="8cc6f6e09f914444702697406829d0d32088568c" translate="yes" xml:space="preserve">
          <source>Basic working examples for Spider</source>
          <target state="translated">스파이더의 기본 작업 예</target>
        </trans-unit>
        <trans-unit id="e4fa49829df55a5a2917268cb4d1657939d75b17" translate="yes" xml:space="preserve">
          <source>Basically it works like this:</source>
          <target state="translated">기본적으로 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="7e9cfbc672125adf2cb5297df34a2ac1ad671a41" translate="yes" xml:space="preserve">
          <source>Basically, the purpose of the MariaDB Audit Plugin is to log the server's activity. For each client session, it records who connected to the server (i.e., user name and host), what queries were executed, and which tables were accessed and server variables that were changed. This information is stored in a rotating log file or it may be sent to the local &lt;code&gt;syslogd&lt;/code&gt;.</source>
          <target state="translated">기본적으로 MariaDB 감사 플러그인의 목적은 서버의 활동을 기록하는 것입니다. 각 클라이언트 세션에 대해 서버에 연결된 사용자 (예 : 사용자 이름 및 호스트), 실행 된 쿼리 및 액세스 된 테이블 및 변경된 서버 변수를 기록합니다. 이 정보는 회전 로그 파일에 저장되거나 로컬 &lt;code&gt;syslogd&lt;/code&gt; 로 전송 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="46fc29e0b91abc72b1eb9ae45281586f2f859fa5" translate="yes" xml:space="preserve">
          <source>Basics of listing, installing and uninstalling plugins.</source>
          <target state="translated">플러그인 나열, 설치 및 제거의 기본 사항.</target>
        </trans-unit>
        <trans-unit id="c87df04a6212fd94333fb48d7e78e47251cb9af4" translate="yes" xml:space="preserve">
          <source>Basque</source>
          <target state="translated">Basque</target>
        </trans-unit>
        <trans-unit id="e6dbb208cf99423d3fe999807394b577c8a888de" translate="yes" xml:space="preserve">
          <source>Batch &lt;code&gt;INSERT&lt;/code&gt; into an empty table (This includes &lt;code&gt;LOAD DATA INFILE&lt;/code&gt;, &lt;code&gt;SELECT... INSERT&lt;/code&gt; and &lt;code&gt;INSERT&lt;/code&gt; (many rows)).</source>
          <target state="translated">빈 테이블에 &lt;code&gt;INSERT&lt;/code&gt; 일괄 처리 ( &lt;code&gt;LOAD DATA INFILE&lt;/code&gt; , &lt;code&gt;SELECT... INSERT&lt;/code&gt; 및 &lt;code&gt;INSERT&lt;/code&gt; (여러 행) 포함)</target>
        </trans-unit>
        <trans-unit id="a584829c53027e5c8a1e2527c1e1359d8aa3b9a2" translate="yes" xml:space="preserve">
          <source>Batch INSERT -- 100-1000 rows is 10 times as fast as INSERTing 1 row at a time (see above)</source>
          <target state="translated">배치 삽입-100-1000 행은 한 번에 1 행 삽입보다 10 배 빠릅니다 (위 참조).</target>
        </trans-unit>
        <trans-unit id="813da9e48abff705bb9ea5fea5a2c9b97fd114d3" translate="yes" xml:space="preserve">
          <source>Batch Key Access Join</source>
          <target state="translated">배치 키 액세스 조인</target>
        </trans-unit>
        <trans-unit id="663e8957df787f697c0d7e25c7f7d8fa22a41dda" translate="yes" xml:space="preserve">
          <source>Batch Keys Access join algorithm performs index look-ups when looking for possible matching candidates provided by the second join operand. With this respect the algorithm behave itself as the regular join algorithm. Yet BKA performs index look-ups for a batch of the records from the join buffer. For conventional database engines like InnoDB/MyISAM it allows to fetch matching candidates in an optimal way. For the engines with remote data store such as FederateX/Spider the algorithm allows to save on transfers between the MySQL node and the data store nodes.</source>
          <target state="translated">배치 키 액세스 조인 알고리즘은 두 번째 조인 피연산자가 제공하는 가능한 일치 후보를 찾을 때 인덱스 조회를 수행합니다. 이와 관련하여 알고리즘은 일반 조인 알고리즘으로 작동합니다. 그러나 BKA는 조인 버퍼에서 레코드 배치에 대한 인덱스 조회를 수행합니다. InnoDB / MyISAM과 같은 기존 데이터베이스 엔진의 경우 일치하는 후보를 최적의 방식으로 가져올 수 있습니다. FederateX / Spider와 같은 원격 데이터 저장소가있는 엔진의 경우 알고리즘을 통해 MySQL 노드와 데이터 저장소 노드 사이의 전송을 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e173c09935e22c7c269df72a2f62c52206d91bda" translate="yes" xml:space="preserve">
          <source>Batch data insert mode with cpimport</source>
          <target state="translated">cpimport를 사용한 배치 데이터 삽입 모드</target>
        </trans-unit>
        <trans-unit id="6d7cb0cdedf6b2c36433843c997e8f9ba6b68c3c" translate="yes" xml:space="preserve">
          <source>Batch insert mode for INSERTS</source>
          <target state="translated">INSERTS의 배치 삽입 모드</target>
        </trans-unit>
        <trans-unit id="4b62cbc9b02435dbd1bf41a023c45991d95aa366" translate="yes" xml:space="preserve">
          <source>Batch load the raw data into a temporary table (`Staging`).</source>
          <target state="translated">원시 데이터를 임시 테이블 (`Staging`)에 일괄로드합니다.</target>
        </trans-unit>
        <trans-unit id="91b775d15c1f33f0bf1efa948f087430792255f1" translate="yes" xml:space="preserve">
          <source>Batch multiple WRITES in auto commit to reduce network round trip</source>
          <target state="translated">자동 커밋에서 여러 WRITES를 일괄 처리하여 네트워크 왕복을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="4d1fbfea853ddea7735c5783bbc2254d71fad6b6" translate="yes" xml:space="preserve">
          <source>Batch table update mode when changes are accumulated and applied explicitly</source>
          <target state="translated">변경 사항이 누적되고 명시 적으로 적용될 때 배치 테이블 업데이트 모드</target>
        </trans-unit>
        <trans-unit id="be921663edd8aec0a62c8f6ea5c07ee260b8eab5" translate="yes" xml:space="preserve">
          <source>Batch-insert ascii or binary files into tables</source>
          <target state="translated">테이블에 ASCII 또는 이진 파일을 일괄 삽입</target>
        </trans-unit>
        <trans-unit id="f74e4d446ff63b741b56e86481aff73821529b32" translate="yes" xml:space="preserve">
          <source>Batched INSERT Statement</source>
          <target state="translated">배치 된 INSERT 문</target>
        </trans-unit>
        <trans-unit id="432a034ab11116a7ca6abc2382c228e4b8eefd7b" translate="yes" xml:space="preserve">
          <source>Batched Key Access</source>
          <target state="translated">배치 된 키 액세스</target>
        </trans-unit>
        <trans-unit id="f85e104adad10e9e6825c02208837c732052c84d" translate="yes" xml:space="preserve">
          <source>Batched Key Access batch size</source>
          <target state="translated">배치 된 키 액세스 배치 크기</target>
        </trans-unit>
        <trans-unit id="b14ace2aefb576be78e976f22c13cf09868b329e" translate="yes" xml:space="preserve">
          <source>Batched Key Access can benefit from rowid sorting in the same way as range access does. If one has a join that uses index lookups:</source>
          <target state="translated">배치 키 액세스는 범위 액세스와 동일한 방식으로 행 ID 정렬을 활용할 수 있습니다. 인덱스 조회를 사용하는 조인이있는 경우 :</target>
        </trans-unit>
        <trans-unit id="dfd2378349bfefe2b594a05a44b928e844f93868" translate="yes" xml:space="preserve">
          <source>Batched Key Access support</source>
          <target state="translated">배치 된 키 액세스 지원</target>
        </trans-unit>
        <trans-unit id="8393a7e7212a8b5b534229d8152f88cf075a2e4f" translate="yes" xml:space="preserve">
          <source>Batched key access</source>
          <target state="translated">배치 된 키 액세스</target>
        </trans-unit>
        <trans-unit id="c7d5d8704a02b9419e15d627561eba7c26c2c3e5" translate="yes" xml:space="preserve">
          <source>Batched normalization</source>
          <target state="translated">배치 정규화</target>
        </trans-unit>
        <trans-unit id="7f44bf6c5e909a46dd0f112c5c95401c184b8290" translate="yes" xml:space="preserve">
          <source>Batching the load of the Fact table</source>
          <target state="translated">팩트 테이블의로드 배치</target>
        </trans-unit>
        <trans-unit id="9aba6084fd7577585963c4dc0f4dbe613c765fea" translate="yes" xml:space="preserve">
          <source>Bath, UK</source>
          <target state="translated">바스, 영국</target>
        </trans-unit>
        <trans-unit id="fa8adc706f1aca554aa2d6051e883a3a55a6509b" translate="yes" xml:space="preserve">
          <source>Bday</source>
          <target state="translated">Bday</target>
        </trans-unit>
        <trans-unit id="ecda56342e18ffff9efa915aa3e6d9ab530c1ca6" translate="yes" xml:space="preserve">
          <source>Be able to use Aria for internal temporary tables in MariaDB (instead of MyISAM).</source>
          <target state="translated">MyISAM 대신 MariaDB의 내부 임시 테이블에 Aria를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98068d4bc4b553d0fa17a8a562e28fca9d22416e" translate="yes" xml:space="preserve">
          <source>Be aware of the two broad kinds of CONNECT tables:</source>
          <target state="translated">두 가지 종류의 CONNECT 테이블에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="3ac1012290a900e5f3502174ea574541917d27cd" translate="yes" xml:space="preserve">
          <source>Be aware that the total memory allocated is about 10% more than the specified size as extra space is also reserved for control structures and buffers. The space must also be contiguous. If you're running a Windows system that loads DLL's at specific addresses, this may cause difficulties.</source>
          <target state="translated">추가 공간도 제어 구조 및 버퍼를 위해 예약되므로 할당 된 총 메모리는 지정된 크기보다 약 10 % 더 큽니다. 공간도 연속적이어야합니다. 특정 주소에 DLL을로드하는 Windows 시스템을 실행하는 경우 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="52f47c2b81dca4cc8d89e8ccbe2863c10063114f" translate="yes" xml:space="preserve">
          <source>Be aware that until Connect 1.5.5, no blanks should be inserted before or after the '&lt;code&gt;=&lt;/code&gt;' and '&lt;code&gt;,&lt;/code&gt;' characters. The option name is all that is between the start of the string or the last '&lt;code&gt;,&lt;/code&gt;' character and the next '&lt;code&gt;=&lt;/code&gt;' character, and the option value is all that is between this '&lt;code&gt;=&lt;/code&gt;' character and the next '&lt;code&gt;,&lt;/code&gt;' or end of string. For instance:</source>
          <target state="translated">Connect 1.5.5까지는 ' &lt;code&gt;=&lt;/code&gt; '및 ' &lt;code&gt;,&lt;/code&gt; '문자 앞뒤에 공백을 삽입해서는 안됩니다 . 옵션 이름은 문자열의 시작 또는 마지막 ' &lt;code&gt;,&lt;/code&gt; '문자와 다음 ' &lt;code&gt;=&lt;/code&gt; '문자 사이에있는 모든 값이며 옵션 값은이 ' &lt;code&gt;=&lt;/code&gt; '문자와 다음 ' &lt;code&gt;,&lt;/code&gt; '또는 끝 사이에있는 모든 것입니다 문자열 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="6081ded969718cc56447a039d81ddfdf0c651ad7" translate="yes" xml:space="preserve">
          <source>Be aware, in particular when using the subdir option, that queries on DIR tables are slow and can last almost forever if made on a directory that contains a great number of files in it and its sub-directories.</source>
          <target state="translated">특히 subdir 옵션을 사용하는 경우 DIR 테이블에 대한 쿼리는 속도가 느리며 많은 수의 파일이 포함 된 디렉토리와 해당 서브 디렉토리에서 수행되는 경우 거의 영구적으로 지속될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a3bbbe8f3011a067f8b778e4609a5fc3c5eaf8f" translate="yes" xml:space="preserve">
          <source>Be careful changing the binary log format dynamically when the server is a slave and &lt;a href=&quot;../parallel-replication/index&quot;&gt;parallel replication&lt;/a&gt; is enabled. If you change the global value dynamically, then that does not also affect the session values of any currently running threads. This can cause problems with &lt;a href=&quot;../parallel-replication/index&quot;&gt;parallel replication&lt;/a&gt;, because the &lt;a href=&quot;../replication-threads/index#worker-threads&quot;&gt;worker threads&lt;/a&gt; will remain running even after &lt;code&gt;&lt;a href=&quot;../stop-slave/index&quot;&gt;STOP SLAVE&lt;/a&gt;&lt;/code&gt; is executed. This can be worked around by resetting the &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#slave_parallel_threads&quot;&gt;slave_parallel_threads&lt;/a&gt;&lt;/code&gt; system variable. For example:</source>
          <target state="translated">서버가 슬레이브이고 &lt;a href=&quot;../parallel-replication/index&quot;&gt;병렬 복제&lt;/a&gt; 가 활성화 된 경우 이진 로그 형식을 동적으로 변경해야합니다 . 전역 값을 동적으로 변경하면 현재 실행중인 스레드의 세션 값에도 영향을 미치지 않습니다. &lt;code&gt;&lt;a href=&quot;../stop-slave/index&quot;&gt;STOP SLAVE&lt;/a&gt;&lt;/code&gt; 가 실행 된 후에도 &lt;a href=&quot;../replication-threads/index#worker-threads&quot;&gt;작업자 스레드&lt;/a&gt; 가 계속 실행 되므로 &lt;a href=&quot;../parallel-replication/index&quot;&gt;병렬 복제에&lt;/a&gt; 문제가 발생할 수 있습니다 . &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#slave_parallel_threads&quot;&gt;slave_parallel_threads&lt;/a&gt;&lt;/code&gt; 시스템 변수를 재설정 하여이 문제를 해결할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="63bdef07391bfa7afae18b0cbbdad9b889d5ebab" translate="yes" xml:space="preserve">
          <source>Be careful to avoid this common mistake, not grouping correctly and returning mismatched data:</source>
          <target state="translated">올바르게 그룹화되지 않고 일치하지 않는 데이터를 반환하지 않고이 일반적인 실수를 피하십시오.</target>
        </trans-unit>
        <trans-unit id="8f72b0a970351c64335fb932565e1a5f198285d3" translate="yes" xml:space="preserve">
          <source>Be careful to process multiple log files in a single connection, especially if one or more of them have any &lt;code&gt;CREATE TEMPORARY TABLE ...&lt;/code&gt; statements. Temporary tables are dropped when the mysql client terminates, so if you are processing multiple log files one at a time (i.e. multiple connections) and one log file creates a temporary table and then a subsequent log file refers to the table you will get an 'unknown table' error.</source>
          <target state="translated">특히 하나 이상의 파일에 &lt;code&gt;CREATE TEMPORARY TABLE ...&lt;/code&gt; 문 이있는 경우 단일 연결에서 여러 로그 파일을 처리해야합니다 . mysql 클라이언트가 종료되면 임시 테이블이 삭제되므로 한 번에 여러 개의 로그 파일을 처리하는 경우 (예 : 여러 개의 연결) 하나의 로그 파일이 임시 테이블을 생성 한 후 후속 로그 파일이 테이블을 참조하면 ' 알 수없는 테이블 오류입니다.</target>
        </trans-unit>
        <trans-unit id="0cb1cfd6ba5b47598a4cd761de13d815d5c15b4d" translate="yes" xml:space="preserve">
          <source>Be careful using the &lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt; statement. Currently the data compatibility is not tested and the modified definition can become incompatible with the data. In particular, Alter modifies the table definition only but does not modify the table data. Consequently, the table type should not be modified this way, except to correct an incorrect definition. Also adding, dropping or modifying columns may be wrong because the default offset values (when not explicitly given by the FLAG option) may be wrong when recompiled with missing columns.</source>
          <target state="translated">&lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt; 문을 사용하여주의하십시오 . 현재 데이터 호환성이 테스트되지 않았으며 수정 된 정의가 데이터와 호환되지 않을 수 있습니다. 특히 Alter는 테이블 정의 만 수정하지만 테이블 데이터는 수정하지 않습니다. 결과적으로 잘못된 정의를 정정하지 않는 한 테이블 유형을 이런 식으로 수정해서는 안됩니다. 또한 누락 된 열로 다시 컴파일 할 때 기본 오프셋 값 (FLAG 옵션으로 명시 적으로 지정되지 않은 경우)이 잘못 될 수 있으므로 열 추가, 삭제 또는 수정이 잘못 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="161f9d9d4f784075e85e4f22610aee0fbd0302d1" translate="yes" xml:space="preserve">
          <source>Be careful when changing the binary log format when using &lt;a href=&quot;../replication/index&quot;&gt;replication&lt;/a&gt;. When you change the binary log format on a server, it only changes the format for that server. Changing the binary log format on a master has no effect on the slave's binary log format. This can cause replication to give inconsistent results or to fail.</source>
          <target state="translated">&lt;a href=&quot;../replication/index&quot;&gt;복제를&lt;/a&gt; 사용할 때 이진 로그 형식을 변경할 때는주의하십시오 . 서버에서 이진 로그 형식을 변경하면 해당 서버의 형식 만 변경됩니다. 마스터에서 이진 로그 형식을 변경해도 슬레이브의 이진 로그 형식에는 영향을 미치지 않습니다. 이로 인해 복제 결과가 일치하지 않거나 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3662a892119edba725046376177ff4169866b513" translate="yes" xml:space="preserve">
          <source>Be more silent.</source>
          <target state="translated">더 침묵하십시오.</target>
        </trans-unit>
        <trans-unit id="7f026aaacd7b32c8d438debc90088ee835fe0a43" translate="yes" xml:space="preserve">
          <source>Be more silent. This option can be given multiple times to produce less and less output. This option results in nontabular output format and escaping of special characters. Escaping may be disabled by using raw mode; see the description for the &lt;code&gt;--raw&lt;/code&gt; option.</source>
          <target state="translated">더 침묵하십시오. 이 옵션은 출력을 줄이려고 여러 번 제공 될 수 있습니다. 이 옵션은 비표 형식의 출력 형식과 특수 문자를 이스케이프 처리합니다. 원시 모드를 사용하여 이스케이프를 비활성화 할 수 있습니다. &lt;code&gt;--raw&lt;/code&gt; 옵션에 대한 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e3249444c47bb364acba86895fb87b5de002eb7d" translate="yes" xml:space="preserve">
          <source>Be more verbose.</source>
          <target state="translated">더 장황하다.</target>
        </trans-unit>
        <trans-unit id="f2240a3fd5eda5a60011158f0645267fa9fe87d9" translate="yes" xml:space="preserve">
          <source>Be more verbose. Give a warning, if kill can't handle signal 0</source>
          <target state="translated">더 장황하다. kill이 신호 0을 처리 할 수없는 경우 경고를 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="e0ff12a164b27f6261be10c425fd20c5cdb9afbe" translate="yes" xml:space="preserve">
          <source>Be silent except for errors.</source>
          <target state="translated">오류를 제외하고는 조용히하십시오.</target>
        </trans-unit>
        <trans-unit id="3edac4cd83398a9167d89c9ae37cd5b5d84dd550" translate="yes" xml:space="preserve">
          <source>Be sure the changes are under the [mysqld] section, not some other section.</source>
          <target state="translated">변경 사항이 다른 섹션이 아닌 [mysqld] 섹션 아래에 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="7877564f1258955c95744bf64bb5aa1f851f7f09" translate="yes" xml:space="preserve">
          <source>Be sure to be pessimistic &amp;mdash; it is painful to ALTER.</source>
          <target state="translated">비관적 인 태도를 취하십시오. ALTER는 고통 스럽습니다.</target>
        </trans-unit>
        <trans-unit id="190ed0ae7806b586afe5c2b120a8e7d1f4308c9a" translate="yes" xml:space="preserve">
          <source>Be sure to check a tablespace's row format before moving it from one server to another. Keep in mind that the default row format can change between major versions of MySQL or MariaDB. See &lt;a href=&quot;../innodb-storage-formats/index#checking-a-tables-row-format&quot;&gt;Checking a Table's Row Format&lt;/a&gt; for information on how to check an InnoDB table's row format.</source>
          <target state="translated">한 서버에서 다른 서버로 테이블 스페이스를 이동하기 전에 테이블 스페이스의 행 형식을 확인하십시오. 기본 행 형식은 주요 버전의 MySQL 또는 MariaDB간에 변경 될 수 있습니다. InnoDB 테이블의 행 형식을 확인하는 방법에 대한 정보 &lt;a href=&quot;../innodb-storage-formats/index#checking-a-tables-row-format&quot;&gt;는 테이블의 행 형식 확인을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d7e5da1b2f65bb1eaface66dc9047459d5265871" translate="yes" xml:space="preserve">
          <source>Be sure to follow the instructions given in the preceding output and create a password for the root user either by using mysqladmin or by running the /usr/bin/mysql_secure_installation script.</source>
          <target state="translated">이전 출력에 제공된 지시 사항을 따르고 mysqladmin을 사용하거나 / usr / bin / mysql_secure_installation 스크립트를 실행하여 루트 사용자의 비밀번호를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="2b19dee2571f262226155ac768147c5509ec7762" translate="yes" xml:space="preserve">
          <source>Be sure to replace &lt;code&gt;-&amp;ndash;ldapserver&lt;/code&gt; and &lt;code&gt;-&amp;ndash;ldapbasedn&lt;/code&gt; with values that are relevant for your environment.</source>
          <target state="translated">&lt;code&gt;-&amp;ndash;ldapserver&lt;/code&gt; 및 &lt;code&gt;-&amp;ndash;ldapbasedn&lt;/code&gt; 을 환경과 관련된 값 으로 바꾸 십시오.</target>
        </trans-unit>
        <trans-unit id="8a855082ee1d13059f5043c2f9ea97a5856b50c4" translate="yes" xml:space="preserve">
          <source>Be sure to replace the following items in the step below:</source>
          <target state="translated">아래 단계에서 다음 항목을 교체하십시오.</target>
        </trans-unit>
        <trans-unit id="4e80f48c004a90076351b14f311e5f6e4c744c6f" translate="yes" xml:space="preserve">
          <source>Be verbose.</source>
          <target state="translated">장황하다.</target>
        </trans-unit>
        <trans-unit id="dd3bed35982b0daf035ba29d0ea1a8b87ca24f65" translate="yes" xml:space="preserve">
          <source>Bear in mind that this option does not enable overwrites. When copying or moving files into the target directory, if Mariabackup finds that the target file already exists, it fails with an error.</source>
          <target state="translated">이 옵션은 덮어 쓰기를 활성화하지 않습니다. 대상 디렉토리로 파일을 복사하거나 이동할 때 Mariabackup이 대상 파일이 이미 존재한다는 것을 발견하면 오류로 실패합니다.</target>
        </trans-unit>
        <trans-unit id="83e83602a9613bbf2b86dab08c5df4c1b174d6c3" translate="yes" xml:space="preserve">
          <source>Bear in mind, before you can restore a backup, you first need to run Mariabackup with the &lt;code&gt;&lt;a href=&quot;#-prepare&quot;&gt;--prepare&lt;/a&gt;&lt;/code&gt; option. In the case of full backups, this makes the files point-in-time consistent. With incremental backups, this applies the deltas to the base backup. Once the backup is prepared, you can run &lt;code&gt;--copy-back&lt;/code&gt; to apply it to MariaDB Server.</source>
          <target state="translated">백업을 복원하기 전에 염두에 곰, 먼저 필요성과 Mariabackup를 실행합니다 &lt;code&gt;&lt;a href=&quot;#-prepare&quot;&gt;--prepare&lt;/a&gt;&lt;/code&gt; 옵션을 선택합니다. 전체 백업의 경우 파일의 특정 시점이 일치합니다. 증분 백업의 경우 델타가 기본 백업에 적용됩니다. 백업이 준비되면 &lt;code&gt;--copy-back&lt;/code&gt; 을 실행 하여 MariaDB 서버에 적용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="379a8a843f715353142da08f997429080f3f4889" translate="yes" xml:space="preserve">
          <source>Bear in mind, before you can restore a backup, you first need to run Mariabackup with the &lt;code&gt;&lt;a href=&quot;#-prepare&quot;&gt;--prepare&lt;/a&gt;&lt;/code&gt; option. In the case of full backups, this makes the files point-in-time consistent. With incremental backups, this applies the deltas to the base backup. Once the backup is prepared, you can run &lt;code&gt;--move-back&lt;/code&gt; to apply it to MariaDB Server.</source>
          <target state="translated">백업을 복원하기 전에 염두에 곰, 먼저 필요성과 Mariabackup를 실행합니다 &lt;code&gt;&lt;a href=&quot;#-prepare&quot;&gt;--prepare&lt;/a&gt;&lt;/code&gt; 옵션을 선택합니다. 전체 백업의 경우 파일의 특정 시점이 일치합니다. 증분 백업의 경우 델타가 기본 백업에 적용됩니다. 백업이 준비되면 &lt;code&gt;--move-back&lt;/code&gt; 을 실행 하여 MariaDB 서버에 적용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f853d9c038b8350b19e18c9d4ab6b0677414f5c8" translate="yes" xml:space="preserve">
          <source>Bear in mind, if you ever need to remove, recreate or otherwise modify the server definition for any reason, you need to also execute a &lt;code&gt;FLUSH TABLES&lt;/code&gt; statement. Otherwise, Spider continues to use the old server definition, which can result in queries raising the error</source>
          <target state="translated">어떤 이유로 서버 정의를 제거, 재 작성 또는 수정해야하는 경우 &lt;code&gt;FLUSH TABLES&lt;/code&gt; 문도 실행해야 합니다. 그렇지 않으면 스파이더는 기존 서버 정의를 계속 사용하므로 쿼리에서 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4edc9d45f68b3c0f4b2820458034eefcc2aa76c2" translate="yes" xml:space="preserve">
          <source>Bear in mind, the release of MariaDB provided by your distribution may not be the same as the version you are trying to install. Additionally, the package managers don't always retrieve all of the packages you need to compile MariaDB. There may be some missed or unlisted in the process. When this is the case, CMake fails during checks with an error message telling you what's missing.</source>
          <target state="translated">배포판에서 제공하는 MariaDB 릴리스는 설치하려는 버전과 동일하지 않을 수 있습니다. 또한 패키지 관리자가 MariaDB를 컴파일하는 데 필요한 모든 패키지를 항상 검색하지는 않습니다. 이 과정에서 일부 누락되거나 미등록 상태 일 수 있습니다. 이 경우 누락 된 사항을 알려주는 오류 메시지와 함께 검사 중에 CMake가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="0f3846d3b2121a48cedb2ed0628064ecd3cd479c" translate="yes" xml:space="preserve">
          <source>Beautiful SQL Editor: You can choose between many available color themes.</source>
          <target state="translated">아름다운 SQL 편집기 : 다양한 색상 테마 중에서 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8ab771d26d0b713ea3f036ff131f216d5f59914" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;--lock-tables&lt;/code&gt; locks tables for each database separately, this option does not guarantee that the tables in the dump file are logically consistent between databases. Tables in different databases may be dumped in completely different states. Use &lt;code&gt;--skip-lock-tables&lt;/code&gt; to disable.</source>
          <target state="translated">때문에 &lt;code&gt;--lock-tables&lt;/code&gt; 각 데이터베이스에 대해 잠금 테이블이 별도로,이 옵션을 보장하지 않습니다 덤프 파일에있는 테이블은 데이터베이스간에 논리적으로 일관성이 있는지. 다른 데이터베이스의 테이블은 완전히 다른 상태로 덤프 될 수 있습니다. &lt;code&gt;--skip-lock-tables&lt;/code&gt; 하려면 --skip-lock-tables 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f34bfd94d04d3fe3a395edf9f75bd98f95be7459" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;DBF&lt;/code&gt; files have a header that contains Meta data about the file, in particular the column description, it is possible to create a table based on an existing &lt;code&gt;DBF&lt;/code&gt; file without giving the column description, for instance:</source>
          <target state="translated">때문에 &lt;code&gt;DBF&lt;/code&gt; 의 파일이 특정 컬럼 설명에, 파일에 대한 메타 데이터가 포함 된 헤더를 가지고, 기존의 기반으로 테이블 만들 수 &lt;code&gt;DBF&lt;/code&gt; 의 예를 들어, 열 설명을 제공하지 않고 파일을 :</target>
        </trans-unit>
        <trans-unit id="30767fc3ba54c1cf0354fae4cd02952312c99564" translate="yes" xml:space="preserve">
          <source>Because AES is a block-level algorithm, padding is used to encode uneven length strings and so the result string length may be calculated using this formula:</source>
          <target state="translated">AES는 블록 레벨 알고리즘이므로 패딩은 고르지 않은 길이의 문자열을 인코딩하는 데 사용되므로 결과 문자열 길이는 다음 공식을 사용하여 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6df735a088e60cc6384273f1145cf55e6134c001" translate="yes" xml:space="preserve">
          <source>Because CONNECT handles many table types; many table type specific options are not in the above list and must be entered using the &lt;code&gt;OPTION_LIST&lt;/code&gt; option. The syntax to use is:</source>
          <target state="translated">CONNECT는 많은 테이블 유형을 처리하기 때문에; 많은 테이블 유형별 옵션이 위의 목록에 &lt;code&gt;OPTION_LIST&lt;/code&gt; 옵션을 사용하여 입력해야합니다 . 사용할 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3bd35966b92100ad79aabc9399e91b718ed6326f" translate="yes" xml:space="preserve">
          <source>Because MariaDB needs to connect to the AWS KMS service, you must ensure that the host has outbound network connectivity over port 443 to AWS and you must ensure that local policies allow the MariaDB server process to make those outbound connections. By default, SELinux restricts MariaDB from making such connections.</source>
          <target state="translated">MariaDB는 AWS KMS 서비스에 연결해야하므로 호스트가 포트 443을 통해 AWS에 대한 아웃 바운드 네트워크 연결을 가지고 있는지 확인해야하며 로컬 정책을 통해 MariaDB 서버 프로세스가 이러한 아웃 바운드 연결을 수행 할 수 있도록해야합니다. 기본적으로 SELinux는 MariaDB가 그러한 연결을하지 못하도록 제한합니다.</target>
        </trans-unit>
        <trans-unit id="ab72d7546de7e995b032a6cf731e33d27fbd3f25" translate="yes" xml:space="preserve">
          <source>Because SYSDATE() can return different values even within the same statement, and is not affected by SET TIMESTAMP, it is non-deterministic and therefore unsafe for replication if statement-based binary logging is used. If that is a problem, you can use row-based logging, or start the server with the mysqld option &lt;a href=&quot;../mysqld-options/index#-sysdate-is-now&quot;&gt;--sysdate-is-now&lt;/a&gt; to cause SYSDATE() to be an alias for NOW(). The non-deterministic nature of SYSDATE() also means that indexes cannot be used for evaluating expressions that refer to it, and that statements using the SYSDATE() function are &lt;a href=&quot;../unsafe-statements-for-replication/index&quot;&gt;unsafe for statement-based replication&lt;/a&gt;.</source>
          <target state="translated">SYSDATE ()는 동일한 명령문 내에서도 다른 값을 리턴 할 수 있으며 SET TIMESTAMP의 영향을받지 않으므로 명령문 기반 이진 로깅이 사용되는 경우 결정적이지 않으므로 복제에 안전하지 않습니다. 이것이 문제이면 행 기반 로깅을 사용하거나 mysqld 옵션 &lt;a href=&quot;../mysqld-options/index#-sysdate-is-now&quot;&gt;--sysdate-is-now&lt;/a&gt; 로 서버를 시작하여 SYSDATE ()를 NOW ()의 별칭으로 만들 수 있습니다. SYSDATE ()의 비 결정적 특성은 인덱스를 참조하는 표현식을 평가하는 데 색인을 사용할 수 없으며 SYSDATE () 함수를 사용하는 명령문 &lt;a href=&quot;../unsafe-statements-for-replication/index&quot;&gt;은 명령문 기반 복제에 안전하지&lt;/a&gt; 않음을 의미 합니다 .</target>
        </trans-unit>
        <trans-unit id="77dbd5630229e272d429612b6530763c53a891d3" translate="yes" xml:space="preserve">
          <source>Because a BLACKHOLE table does not store data, it will not maintain the &lt;code&gt;&lt;a href=&quot;../auto_increment/index&quot;&gt;AUTO_INCREMENT&lt;/a&gt;&lt;/code&gt; value. If you are replicating to a table that can handle &lt;code&gt;AUTO_INCREMENT&lt;/code&gt; columns, and are not explicitly setting the primary key auto-increment value in the &lt;code&gt;&lt;a href=&quot;../insert/index&quot;&gt;INSERT&lt;/a&gt;&lt;/code&gt; query, or using the &lt;code&gt;&lt;a href=&quot;../set/index&quot;&gt;SET&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;../server-system-variables/index#insert_id&quot;&gt;INSERT_ID&lt;/a&gt;&lt;/code&gt; statement, inserts will fail on the slave due to duplicate keys.</source>
          <target state="translated">BLACKHOLE 테이블은 데이터를 저장하지 않으므로 &lt;code&gt;&lt;a href=&quot;../auto_increment/index&quot;&gt;AUTO_INCREMENT&lt;/a&gt;&lt;/code&gt; 값을 유지하지 않습니다 . &lt;code&gt;AUTO_INCREMENT&lt;/code&gt; 열을 처리 할 수있는 테이블에 복제 하고 &lt;code&gt;&lt;a href=&quot;../insert/index&quot;&gt;INSERT&lt;/a&gt;&lt;/code&gt; 쿼리 에서 기본 키 자동 증가 값을 명시 적으로 설정하지 않거나 &lt;code&gt;&lt;a href=&quot;../set/index&quot;&gt;SET&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#insert_id&quot;&gt;INSERT_ID&lt;/a&gt;&lt;/code&gt; 문을 사용 하지 않으면 중복 키로 인해 슬레이브에서 삽입이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="291867235c8ad2871a705b4c3b3a166067642e75" translate="yes" xml:space="preserve">
          <source>Because a combination can be part of the &lt;code&gt;.result&lt;/code&gt; or &lt;code&gt;.rdiff&lt;/code&gt; file name, mtr has to look in many different places for a test result. For example, consider a test &lt;code&gt;foo.test&lt;/code&gt; in the combination pair &lt;code&gt;aa,bb&lt;/code&gt;, that is run in the overlay &lt;em&gt;rty&lt;/em&gt; of the suite &lt;em&gt;qwe&lt;/em&gt;, in other words, for the test that mtr prints as</source>
          <target state="translated">조합은 &lt;code&gt;.result&lt;/code&gt; 또는 &lt;code&gt;.rdiff&lt;/code&gt; 파일 이름 의 일부일 수 있으므로 mtr은 여러 다른 위치에서 테스트 결과를 찾아야합니다. 예를 들어, 조합 쌍 &lt;code&gt;aa,bb&lt;/code&gt; 의 테스트 &lt;code&gt;foo.test&lt;/code&gt; 를 스위트 &lt;em&gt;qwe&lt;/em&gt; 의 오버레이 &lt;em&gt;rty&lt;/em&gt; 에서 실행합니다. 즉, mtr이 다음과 같이 테스트하는 테스트를 고려하십시오.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="38dce809f754a244a7c655c6f0fc6032e5f4d0b4" translate="yes" xml:space="preserve">
          <source>Because all files are handled by the standard input/output functions of the operating system, their size is limited to 2GB, the maximum size handled by standard functions. For some table types, CONNECT can deal with files that are larger than 2GB, or prone to become larger than this limit. These are the &lt;a href=&quot;../connect-dos-and-fix-table-types/index&quot;&gt;FIX&lt;/a&gt;, &lt;a href=&quot;../connect-bin-table-type/index&quot;&gt;BIN&lt;/a&gt; and &lt;a href=&quot;../connect-vec-table-type/index&quot;&gt;VEC&lt;/a&gt; types. To tell connect to use input/output functions dealing with big files, specify the option &lt;code&gt;huge=1&lt;/code&gt; or &lt;code&gt;huge=YES&lt;/code&gt; for that table. Note however that CONNECT cannot randomly access tables having more than 2G records.</source>
          <target state="translated">모든 파일은 운영 체제의 표준 입 / 출력 기능으로 처리되므로 파일 크기는 표준 기능으로 처리되는 최대 크기 인 2GB로 제한됩니다. 일부 테이블 유형의 경우, CONNECT는 2GB보다 크거나이 한계보다 커지기 쉬운 파일을 처리 할 수 ​​있습니다. 이들은입니다 &lt;a href=&quot;../connect-dos-and-fix-table-types/index&quot;&gt;FIX&lt;/a&gt; , &lt;a href=&quot;../connect-bin-table-type/index&quot;&gt;BIN&lt;/a&gt; 및 &lt;a href=&quot;../connect-vec-table-type/index&quot;&gt;VEC&lt;/a&gt; 유형. 큰 파일을 처리하는 입력 / 출력 함수를 사용하도록 connect에 지시하려면 해당 테이블에 대해 &lt;code&gt;huge=1&lt;/code&gt; 또는 &lt;code&gt;huge=YES&lt;/code&gt; 옵션을 지정하십시오 . 그러나 CONNECT는 2G 이상의 레코드가있는 테이블에 무작위로 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2e61286fb6782d228f413eaa11fc6e0ec2a224fc" translate="yes" xml:space="preserve">
          <source>Because catalog tables are processed like the information retrieved by &amp;ldquo;Discovery&amp;rdquo; when table columns are not specified in a Create Table statement, their result set is entirely retrieved and memory allocated.</source>
          <target state="translated">테이블 테이블이 Create Table 문에 지정되지 않은 경우 카탈로그 테이블은&amp;ldquo;Discovery&amp;rdquo;에 의해 검색된 정보와 같이 처리되므로 결과 세트가 완전히 검색되고 메모리가 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="ca28013d41fb981209a19dff87edb99a91b40ca0" translate="yes" xml:space="preserve">
          <source>Because it is an associative memory of finite size, sometimes there will be &quot;misses&quot; that require reaching into real RAM to resolve the lookup. This is costly, so should be avoided.</source>
          <target state="translated">유한 크기의 연관 메모리이기 때문에 때때로 조회를 해결하기 위해 실제 RAM에 도달해야하는 &quot;누락&quot;이있을 수 있습니다. 이것은 비용이 많이들므로 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="15af335938b5fe491690e68ea27a2b5450fb28a0" translate="yes" xml:space="preserve">
          <source>Because it stores all the history, a system-versioned table might grow very large over time. There are many options to trim down the space and remove the old history.</source>
          <target state="translated">모든 히스토리를 저장하므로 시스템 버전 테이블은 시간이 지남에 따라 매우 커질 수 있습니다. 공간을 정리하고 이전 기록을 제거하는 많은 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c2e24fd1b6bad7acb290e086f43ac7d0594ffeb" translate="yes" xml:space="preserve">
          <source>Because most of the useful classes belong to the 'root\cimv2' namespace, this is the default value for WMI tables when the namespace is not specified. Some classes have many properties whose name and type may not be known when creating the table. To find them, you can use the WMI CMI Studio application but his will be rarely required because CONNECT is able to retrieve them.</source>
          <target state="translated">대부분의 유용한 클래스는 'root \ cimv2'네임 스페이스에 속하므로 네임 스페이스가 지정되지 않은 경우 WMI 테이블의 기본값입니다. 일부 클래스에는 테이블을 만들 때 이름과 유형을 알 수없는 많은 속성이 있습니다. 이를 찾으려면 WMI CMI Studio 응용 프로그램을 사용할 수 있지만 CONNECT가 검색 할 수 있기 때문에 거의 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="15a4cf49b7c7cc27a18baffb264600e3d12bab87" translate="yes" xml:space="preserve">
          <source>Because of all the variations, it is hard to get a meaningful benchmark. So, here is some hand-waving instead.</source>
          <target state="translated">모든 변형으로 인해 의미있는 벤치 마크를 얻기가 어렵습니다. 그래서 여기에 손을 흔들며 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8099660c6f6e6e42556c21f039662acb31b9fc9" translate="yes" xml:space="preserve">
          <source>Because of that, &lt;a href=&quot;../myrocks-status-variables/index#rocksdb_wal_group_syncs&quot;&gt;rocksdb_wal_group_syncs&lt;/a&gt; is zero for MariaDB. (Currently, it is only incremented when the binlog is rotated).</source>
          <target state="translated">따라서 MariaDB의 경우 &lt;a href=&quot;../myrocks-status-variables/index#rocksdb_wal_group_syncs&quot;&gt;rockdb_wal_group_syncs&lt;/a&gt; 가 0입니다. (현재는 binlog가 회전 할 때만 증가합니다).</target>
        </trans-unit>
        <trans-unit id="59e23a09e0ac1b9e0694058ca337e3c0503e6499" translate="yes" xml:space="preserve">
          <source>Because of that, generally one cannot use MyRocks and statement-based replication.</source>
          <target state="translated">이 때문에 일반적으로 MyRocks 및 명령문 기반 복제를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c3d68ef2d7896d7b5b6b25cd9b395ab88761d1d8" translate="yes" xml:space="preserve">
          <source>Because of the &quot;scaling&quot;, &quot;hardcoding&quot;, &quot;Condition&quot;, the table name, etc, this PROCEDURE is not truly generic; the code must be modified for each application. Yes, I could have designed it to pass all that stuff in. But what a mess.</source>
          <target state="translated">&quot;스케일링&quot;, &quot;하드 코딩&quot;, &quot;조건&quot;, 테이블 이름 등으로 인해이 절차는 실제로 일반적이지 않습니다. 각 응용 프로그램마다 코드를 수정해야합니다. 예, 모든 것을 전달하도록 설계 할 수있었습니다. 그러나 엉망입니다.</target>
        </trans-unit>
        <trans-unit id="350c2d43e6f476ddef46ec46441033ba76845747" translate="yes" xml:space="preserve">
          <source>Because of the &lt;code&gt;TABLE&lt;/code&gt; option, you may disable query logging and still know who accessed which tables. You might want to disable &lt;code&gt;QUERY&lt;/code&gt; event logging to prevent sensitive data from being logged. Since &lt;em&gt;table&lt;/em&gt; event logging will log who accessed which table, you can still watch for malicious activities with the log. This is often enough to fulfill auditing requirements.</source>
          <target state="translated">&lt;code&gt;TABLE&lt;/code&gt; 옵션으로 인해 쿼리 로깅을 비활성화하고 누가 어떤 테이블에 액세스했는지 알 수 있습니다. 중요한 데이터가 기록되지 않도록 &lt;code&gt;QUERY&lt;/code&gt; 이벤트 로깅 을 사용하지 않을 수 있습니다 . 이후 &lt;em&gt;테이블&lt;/em&gt; 이벤트 로그 기록이있는 테이블을 액세스 누가 기록합니다, 당신은 여전히 로그와 악의적 인 활동을 볼 수 있습니다. 이것은 종종 감사 요구 사항을 충족시키기에 충분합니다.</target>
        </trans-unit>
        <trans-unit id="664c03832d8ea3359ea5a1707f5f9cb24c386b8b" translate="yes" xml:space="preserve">
          <source>Because of the above speed advantages there are many cases, when you need to insert &lt;strong&gt;many&lt;/strong&gt; rows at a time, where it may be faster to create a file locally, add the rows there, and then use &lt;code&gt;LOAD DATA INFILE&lt;/code&gt; to load them; compared to using &lt;code&gt;INSERT&lt;/code&gt; to insert the rows.</source>
          <target state="translated">위의 속도 이점으로 인해 한 번에 &lt;strong&gt;많은&lt;/strong&gt; 행 을 삽입해야 할 경우 파일을 로컬로 작성하고 행을 추가 한 다음 &lt;code&gt;LOAD DATA INFILE&lt;/code&gt; 을 사용 하여로드하는 것이 더 빠를 수 있습니다 . &lt;code&gt;INSERT&lt;/code&gt; 를 사용하여 행 을 삽입하는 것과 비교됩니다 .</target>
        </trans-unit>
        <trans-unit id="8c10aec707fe123f6cf97f8861930910e10a695c" translate="yes" xml:space="preserve">
          <source>Because of the time added by reconstructing the index, this will be valuable only if the time gained by reducing the index size if more than this reconstruction time. This is why this should not be done if the &amp;ldquo;from&amp;rdquo; table is small because there will not be enough row joining to compensate for the additional time. Otherwise, the gain of using a dynamic index is:</source>
          <target state="translated">인덱스를 재구성하여 추가 한 시간으로 인해이 재구성 시간보다 더 큰 경우 인덱스 크기를 줄여서 얻은 시간 인 경우에만 유용합니다. 추가 시간을 보상하기에 충분한 행 조인이 없기 때문에&amp;ldquo;시작&amp;rdquo;테이블이 작 으면 이것이 수행되지 않아야하는 이유입니다. 그렇지 않으면 동적 인덱스 사용의 이점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f179e75017e1ace8b31ed97fb9300052fc262c68" translate="yes" xml:space="preserve">
          <source>Because of these two benefits, it is generally recommended to use global transaction ID for any replication setups based on &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1002-release-notes/&quot;&gt;MariaDB 10.0.2&lt;/a&gt; or later. However, old-style replication continues to work as always, so there is no pressing need to change existing setups. Global transaction ID integrates smoothly with old-style replication, and the two can be used freely together in the same replication hierarchy. There is no special configuration needed of the server to start using global transaction ID. However, it must be explicitly set for a slave server with the appropriate &lt;a href=&quot;../change-master-to/index&quot;&gt;CHANGE MASTER&lt;/a&gt; option; by default old-style replication is used by a replication slave, to maintain backwards compatibility.</source>
          <target state="translated">이러한 두 가지 이점 때문에 일반적으로 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1002-release-notes/&quot;&gt;MariaDB 10.0.2&lt;/a&gt; 이상을 기반으로하는 복제 설정에 전역 트랜잭션 ID를 사용하는 것이 좋습니다 . 그러나 구식 복제는 항상 항상 작동하므로 기존 설정을 변경할 필요가 없습니다. 글로벌 트랜잭션 ID는 구식 복제와 원활하게 통합되며, 두 가지를 동일한 복제 계층에서 자유롭게 함께 사용할 수 있습니다. 글로벌 트랜잭션 ID 사용을 시작하기 위해 서버에 특별한 구성이 필요하지 않습니다. 그러나 적절한 &lt;a href=&quot;../change-master-to/index&quot;&gt;CHANGE MASTER&lt;/a&gt; 옵션 을 사용하여 슬레이브 서버에 대해 명시 적으로 설정해야합니다 . 기본적으로 구식 복제는 이전 버전과의 호환성을 유지하기 위해 복제 슬레이브에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e9e32bb876455ccbb5baa323a6dbe50d392fe176" translate="yes" xml:space="preserve">
          <source>Because of this, an identical statement run on the master and the slave may result in different outcomes if the foreign key relations are not identical on both master and slave This could be the case if the storage engine on one supports cascading deletes (e.g. InnoDB) and the storage engine on the other does not (e.g. MyISAM), or the one has specified a foreign key relation, and the other hasn't.</source>
          <target state="translated">이로 인해 외래 키 관계가 마스터와 슬레이브 모두에서 동일하지 않은 경우 마스터와 슬레이브에서 동일한 명령문 실행으로 인해 다른 결과가 발생할 수 있습니다. 이는 하나의 스토리지 엔진이 계단식 삭제 (예 : InnoDB)를 지원하는 경우에 해당 될 수 있습니다 그리고 다른 쪽의 저장소 엔진은 (예 : MyISAM) 그렇지 않거나 외래 키 관계를 지정했고 다른 쪽은 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d6c7607051e550bbf86fdea41d528067ab59e8d4" translate="yes" xml:space="preserve">
          <source>Because of this, mSQL programs often can be converted relatively easily for use with MySQL by changing the names of their C API functions.</source>
          <target state="translated">이 때문에 mSQL 프로그램은 종종 C API 함수의 이름을 변경하여 MySQL에서 사용하기 위해 비교적 쉽게 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89284b24dd76bae4c691af6de1293301bf27665c" translate="yes" xml:space="preserve">
          <source>Because so many ODBC and JDBC drivers exist and only the main ones have been heavily tested, these table types cannot be ranked as stable. Use them with care in production applications.</source>
          <target state="translated">너무 많은 ODBC 및 JDBC 드라이버가 존재하고 주요 드라이버 만 많이 테스트되었으므로 이러한 테이블 유형은 안정적으로 순위를 매길 수 없습니다. 프로덕션 응용 프로그램에서주의해서 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="58ff18bad4cc37c04812d7ae9164f64819507a8b" translate="yes" xml:space="preserve">
          <source>Because some string values contain a date representation, the corresponding columns are declared as datetime and the date format is specified for them.</source>
          <target state="translated">일부 문자열 값에는 날짜 표현이 포함되어 있으므로 해당 열은 datetime으로 선언되고 날짜 형식이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="f7f68a3be2edef837dd4df0aea69f6dfc05d065a" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;INSERT DELAYED&lt;/code&gt; statement returns immediately, before the rows are inserted, you cannot use &lt;code&gt;LAST_INSERT_ID()&lt;/code&gt; to get the &lt;code&gt;AUTO_INCREMENT&lt;/code&gt; value that the statement might generate.</source>
          <target state="translated">때문에 &lt;code&gt;INSERT DELAYED&lt;/code&gt; 즉시 문 반환하는 행을 삽입하기 전에, 당신은 사용할 수 없습니다 &lt;code&gt;LAST_INSERT_ID()&lt;/code&gt; 얻가하는 &lt;code&gt;AUTO_INCREMENT&lt;/code&gt; 의 문이 생성 될 수 있음을 값입니다.</target>
        </trans-unit>
        <trans-unit id="2cc4fd83788c0a966878cf5056457e65f4bc5275" translate="yes" xml:space="preserve">
          <source>Because the MariaDB server, &lt;code&gt;mysqld&lt;/code&gt;, needs to access the data directory when it runs later, you should either run &lt;code&gt;mysql_install_db&lt;/code&gt; from the same account that will be used for running &lt;code&gt;mysqld&lt;/code&gt; or run it as root and use the &lt;code&gt;--user&lt;/code&gt; option to indicate the user name that &lt;code&gt;mysqld&lt;/code&gt; will run as. It might be necessary to specify other options such as &lt;code&gt;--basedir&lt;/code&gt; or &lt;code&gt;--datadir&lt;/code&gt; if &lt;code&gt;mysql_install_db&lt;/code&gt; does not use the correct locations for the installation directory or data directory. For example:</source>
          <target state="translated">MariaDB 서버 &lt;code&gt;mysqld&lt;/code&gt; 는 나중에 실행될 때 데이터 디렉토리에 액세스해야하므로 &lt;code&gt;mysqld&lt;/code&gt; 를 실행하는 데 사용할 계정과 동일한 계정으로 &lt;code&gt;mysql_install_db&lt;/code&gt; 를 실행 하거나 root로 실행하고 &lt;code&gt;--user&lt;/code&gt; 옵션을 사용하여 사용자를 표시해야합니다. &lt;code&gt;mysqld&lt;/code&gt; 가 실행될 이름 . &lt;code&gt;mysql_install_db&lt;/code&gt; 가 설치 디렉토리 또는 데이터 디렉토리에 올바른 위치를 사용하지 않는 경우 &lt;code&gt;--basedir&lt;/code&gt; 또는 &lt;code&gt;--datadir&lt;/code&gt; 과 같은 다른 옵션을 지정해야 할 수도 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="20f45be23adb9661271776bbc3691d98e74935cf" translate="yes" xml:space="preserve">
          <source>Because the TIMESTAMP value is stored as Epoch Seconds, the timestamp value '1970-01-01 00:00:00' (UTC) is reserved since the second #0 is used to represent '0000-00-00 00:00:00'.</source>
          <target state="translated">TIMESTAMP 값은 Epoch Seconds로 저장되므로 시간 스탬프 값 '1970-01-01 00:00:00'(UTC)은 두 번째 # 0이 '0000-00-00 00:00:00을 나타내는 데 사용되므로 예약됩니다. '.</target>
        </trans-unit>
        <trans-unit id="3c552ec7c513a86a2a38ef69aefca90aedc23d21" translate="yes" xml:space="preserve">
          <source>Because the author column does not appear in the query, the corresponding row was not expanded. This is somewhat strange because this would have been different if we had been working on a table of a different type. However, it is closer to the relational model for which there should not be two identical rows (tuples) in a table. Nevertheless, you should be aware of this somewhat erratic behavior. For instance:</source>
          <target state="translated">작성자 열이 쿼리에 나타나지 않기 때문에 해당 행이 확장되지 않았습니다. 우리가 다른 유형의 테이블에서 작업했다면 이것이 다르기 때문에 이것은 다소 이상합니다. 그러나 테이블에 두 개의 동일한 행 (튜플)이 없어야하는 관계형 모델에 더 가깝습니다. 그럼에도 불구하고, 당신은이 다소 불규칙한 행동을 알고 있어야합니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="f99705d188a460ad777f655f1b61d879e82c240e" translate="yes" xml:space="preserve">
          <source>Because the boys table can be directly used, what can be the use of a proxy table? Well, its main use is to be internally used by other table types such as &lt;a href=&quot;../connect-table-types-tbl-table-type-table-list/index&quot;&gt;TBL&lt;/a&gt;, &lt;a href=&quot;../connect-table-types-xcol-table-type/index&quot;&gt;XCOL&lt;/a&gt;, &lt;a href=&quot;../connect-table-types-occur-table-type/index&quot;&gt;OCCUR&lt;/a&gt;, or &lt;a href=&quot;../connect-table-types-pivot-table-type/index&quot;&gt;PIVOT&lt;/a&gt;. Sure enough, PROXY tables are CONNECT tables, meaning that they can be based on tables of any engines and accessed by table types that need to access CONNECT tables.</source>
          <target state="translated">boys 테이블을 직접 사용할 수 있으므로 프록시 테이블을 사용할 수있는 것은 무엇입니까? 기본 용도는 &lt;a href=&quot;../connect-table-types-tbl-table-type-table-list/index&quot;&gt;TBL&lt;/a&gt; , &lt;a href=&quot;../connect-table-types-xcol-table-type/index&quot;&gt;XCOL&lt;/a&gt; , &lt;a href=&quot;../connect-table-types-occur-table-type/index&quot;&gt;OCCUR&lt;/a&gt; 또는 &lt;a href=&quot;../connect-table-types-pivot-table-type/index&quot;&gt;PIVOT&lt;/a&gt; 과 같은 다른 테이블 유형에서 내부적으로 사용하는 것 입니다. 확실히 PROXY 테이블은 CONNECT 테이블이므로 모든 엔진의 테이블을 기반으로 할 수 있으며 CONNECT 테이블에 액세스해야하는 테이블 유형으로 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a96b5ad836beb9e12a23cfca8b073f7ad2e0826" translate="yes" xml:space="preserve">
          <source>Because the following variable only has a global scope, the global value is returned even when specifying SESSION (in this case by default):</source>
          <target state="translated">다음 변수에는 전역 범위 만 있으므로 SESSION을 지정할 때 (이 경우 기본적으로) 전역 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="acbf78e989ebc3138ee67bcb673153258391c22b" translate="yes" xml:space="preserve">
          <source>Because the partition engine was written before some other engines were added to MariaDB, the way it works is sometime incompatible with these engines, in particular with CONNECT.</source>
          <target state="translated">파티션 엔진은 다른 엔진을 MariaDB에 추가하기 전에 작성 되었기 때문에 작동 방식은 이러한 엔진, 특히 CONNECT와 호환되지 않는 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b04ab9691da832594b0a57d936e07d6b4024d04" translate="yes" xml:space="preserve">
          <source>Because the table is accessed several times, this can make queries last very long except for small tables and is almost unacceptable for big tables. However, if it cannot be avoided, using the memory method is the best choice and can be more than four times faster than the default method. If it is supported by the driver, using a scrollable cursor is slightly slower than using memory but can be an alternative to avoid memory problems when the sub-query returns a huge result set.</source>
          <target state="translated">테이블에 여러 번 액세스하기 때문에 작은 테이블을 제외하고 쿼리를 오래 지속 할 수 있으며 큰 테이블에는 거의 사용할 수 없습니다. 그러나 피할 수없는 경우 메모리 방법을 사용하는 것이 최선의 선택이며 기본 방법보다 4 배 이상 빠를 수 있습니다. 드라이버가 지원하는 경우 스크롤 가능한 커서를 사용하는 것이 메모리를 사용하는 것보다 약간 느리지 만 하위 쿼리가 큰 결과 집합을 반환 할 때 메모리 문제를 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66e96fe86a562564bbe604d1ed20c0c0eaa3093d" translate="yes" xml:space="preserve">
          <source>Because the table is read sequentially when reconstructing the index there no need for MRR.</source>
          <target state="translated">인덱스를 재구성 할 때 테이블을 순차적으로 읽으므로 MRR이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="004cdacce868e10a18a867aabd3c57a4a768654f" translate="yes" xml:space="preserve">
          <source>Because this type is mainly used by CONNECT to handle numeric or decimal fields of ODBC, JDBC and MySQL table types, CONNECT does not provide decimal calculations or comparison by itself. This is why decimal columns of CONNECT tables cannot be indexed.</source>
          <target state="translated">이 유형은 주로 CONNECT에서 ODBC, JDBC 및 MySQL 테이블 유형의 숫자 ​​또는 10 진수 필드를 처리하는 데 사용되므로 10 진수 계산이나 비교 자체를 제공하지 않습니다. CONNECT 테이블의 10 진 열을 색인화 할 수없는 이유입니다.</target>
        </trans-unit>
        <trans-unit id="8ac1e02307e4b93e3c71b5bbcadbbac374668c65" translate="yes" xml:space="preserve">
          <source>Because this would change the first name of both authors as they share the same ISBN.</source>
          <target state="translated">동일한 ISBN을 공유 할 경우 두 저자의 이름이 변경되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="bf6caee32d35076bcf3759bfc81e43ba61a18c57" translate="yes" xml:space="preserve">
          <source>Because we, the MariaDB developers, don't want to add a lot of new features or big code changes to a stable release, not all TokuDB features will be merged at once into MariaDB. Instead they will be added in stages.</source>
          <target state="translated">MariaDB 개발자는 안정적인 릴리스에 많은 새로운 기능이나 큰 코드 변경 사항을 추가하고 싶지 않기 때문에 모든 TokuDB 기능이 MariaDB에 한 번에 병합되는 것은 아닙니다. 대신 단계적으로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="a641f28883d4f1fba174b6f4e9d7998495b7ad6f" translate="yes" xml:space="preserve">
          <source>Because you are upgrading ColumnStore and not uninstalling it, they are not necessary. If at some point you wish to uninstall it, you (or your sysadmin) will have to perform those operations by hand.</source>
          <target state="translated">ColumnStore를 업그레이드하고 제거하지 않기 때문에 필요하지 않습니다. 언젠가 설치 제거를 원할 경우 사용자 (또는 sysadmin)가 수동으로 해당 작업을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="6a9d220b874dd2322d5e3e5666e7dde03ca51bcf" translate="yes" xml:space="preserve">
          <source>Beer</source>
          <target state="translated">Beer</target>
        </trans-unit>
        <trans-unit id="8093334f3c9cf9ab6c8e3a6c4cfce32bedf5b8c3" translate="yes" xml:space="preserve">
          <source>Beer, Beer, Food, Food, Beer</source>
          <target state="translated">맥주, 맥주, 음식, 음식, 맥주</target>
        </trans-unit>
        <trans-unit id="ddea70d3fd7d54a4698a9414e6306c70085d5c45" translate="yes" xml:space="preserve">
          <source>Beer, Car, Beer, Food</source>
          <target state="translated">맥주, 자동차, 맥주, 음식</target>
        </trans-unit>
        <trans-unit id="add5ceaab15de73fb8374fc88a0a8dbdff8a1e2d" translate="yes" xml:space="preserve">
          <source>Beer, Food</source>
          <target state="translated">맥주, 음식</target>
        </trans-unit>
        <trans-unit id="1eba3683a76b747b615ecad2fbff9ea12445a277" translate="yes" xml:space="preserve">
          <source>Beer, Food, Food, Car</source>
          <target state="translated">맥주, 음식, 음식, 자동차</target>
        </trans-unit>
        <trans-unit id="95cd18ba9be1db514519021c901cc938ba892bc6" translate="yes" xml:space="preserve">
          <source>Before &quot;native partitions&quot; (5.7.6), each partition consumed a chunk of memory.</source>
          <target state="translated">&quot;네이티브 파티션&quot;(5.7.6) 이전에는 각 파티션이 메모리 청크를 소비했습니다.</target>
        </trans-unit>
        <trans-unit id="d814b35636db337bab8c5774784f7fbe6915c287" translate="yes" xml:space="preserve">
          <source>Before 10.0.10 the compression type did not default to the &lt;a href=&quot;../tokudb-system-variables/index#tokudb_row_format&quot;&gt;tokudb_row_format&lt;/a&gt; session variable. If &lt;code&gt;COMPRESSION=&lt;/code&gt; was not included in &lt;code&gt;CREATE TABLE&lt;/code&gt; or &lt;code&gt;ALTER TABLE ENGINE=TokuDB&lt;/code&gt; then the TokuDB table was created uncompressed.</source>
          <target state="translated">10.0.10 이전에는 압축 유형이 기본적으로 &lt;a href=&quot;../tokudb-system-variables/index#tokudb_row_format&quot;&gt;tokudb_row_format&lt;/a&gt; 세션 변수 가 아니 었습니다 . 경우 &lt;code&gt;COMPRESSION=&lt;/code&gt; 에 포함되지 않은 &lt;code&gt;CREATE TABLE&lt;/code&gt; 또는 &lt;code&gt;ALTER TABLE ENGINE=TokuDB&lt;/code&gt; 은 다음 TokuDB 테이블이 압축 만들었습니다.</target>
        </trans-unit>
        <trans-unit id="d78e132a2f19a9f1dc14e514aed9ebf2adfaedf1" translate="yes" xml:space="preserve">
          <source>Before 10.0.2, &lt;code&gt;&lt;a href=&quot;../get_lock/index&quot;&gt;GET_LOCK()&lt;/a&gt;&lt;/code&gt; released the existing lock, if any. Since 10.0.2 this does not happen, because multiple locks are allowed.</source>
          <target state="translated">10.0.2 이전에 &lt;code&gt;&lt;a href=&quot;../get_lock/index&quot;&gt;GET_LOCK()&lt;/a&gt;&lt;/code&gt; 은 기존 잠금을 ​​해제했습니다 (있는 경우) . 10.0.2부터는 여러 잠금이 허용되므로이 문제가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="acf632caf8b72701ebbf37fc26b11d1c66673b39" translate="yes" xml:space="preserve">
          <source>Before &lt;a href=&quot;../pbxt/index&quot;&gt;PBXT&lt;/a&gt; has recovered, not all statistics are available. In particular, the statistics relating to PBXT background threads are not available (including the &lt;code&gt;sweep&lt;/code&gt; and &lt;code&gt;chkpnt&lt;/code&gt; statistics).</source>
          <target state="translated">&lt;a href=&quot;../pbxt/index&quot;&gt;PBXT&lt;/a&gt; 가 복구 되기 전에 모든 통계를 사용할 수있는 것은 아닙니다. 특히, PBXT 백그라운드 스레드와 관련된 통계는 사용할 수 없습니다 ( &lt;code&gt;sweep&lt;/code&gt; 및 &lt;code&gt;chkpnt&lt;/code&gt; 통계 포함).</target>
        </trans-unit>
        <trans-unit id="a5efd206d27f83d01d9dd3fb056ddc85cea6ce01" translate="yes" xml:space="preserve">
          <source>Before &lt;a href=&quot;../what-is-mariadb-100/index&quot;&gt;MariaDB 10.0&lt;/a&gt;, InnoDB statistics were not stored on disk, meaning that on server restarts the statistics would need to be recalculated, which is both needless computation, as well as leading to inconsistent query plans.</source>
          <target state="translated">&lt;a href=&quot;../what-is-mariadb-100/index&quot;&gt;MariaDB 10.0&lt;/a&gt; 이전 에는 InnoDB 통계가 디스크에 저장되지 않았습니다. 즉, 서버를 다시 시작할 때 통계를 다시 계산해야하므로 계산이 불필요하며 쿼리 계획이 일관되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="af708520ae494c324a8fc15254b49337de8691f3" translate="yes" xml:space="preserve">
          <source>Before &lt;a href=&quot;../what-is-mariadb-100/index&quot;&gt;MariaDB 10.0&lt;/a&gt;, the MySQL/MariaDB optimizer relied on storage engines (e.g. InnoDB) to provide statistics for the query optimizer. This approach worked; however it had some deficiencies:</source>
          <target state="translated">&lt;a href=&quot;../what-is-mariadb-100/index&quot;&gt;MariaDB 10.0&lt;/a&gt; 이전 에는 MySQL / MariaDB 옵티마이 저가 스토리지 엔진 (예 : InnoDB)에 의존하여 쿼리 옵티 마이저에 대한 통계를 제공했습니다. 이 접근법은 효과가 있었다. 그러나 몇 가지 결함이있었습니다.</target>
        </trans-unit>
        <trans-unit id="573761cf5677aa6a9e9d5738a750df1d52ffc7f9" translate="yes" xml:space="preserve">
          <source>Before &lt;a href=&quot;../what-is-mariadb-100/index&quot;&gt;MariaDB 10.0&lt;/a&gt;, the doublewrite buffer can be moved to a different drive, reducing contention on random reads. Use the &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_doublewrite_file&quot;&gt;innodb_doublewrite_file&lt;/a&gt; system variable to specify a location. Since the doublewrite buffer is mostly sequential writes, a traditional HDD is a better choice than SSD. This variable was removed in &lt;a href=&quot;../what-is-mariadb-100/index&quot;&gt;MariaDB 10.0&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../what-is-mariadb-100/index&quot;&gt;MariaDB 10.0&lt;/a&gt; 이전 에는 이중 쓰기 버퍼를 다른 드라이브로 이동하여 임의 읽기에 대한 경합을 줄입니다. 사용 &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_doublewrite_file&quot;&gt;innodb_doublewrite_file&lt;/a&gt; 위치를 지정하는 시스템 변수를. 이중 쓰기 버퍼는 대부분 순차적 쓰기 작업이므로 기존 HDD가 SSD보다 나은 선택입니다. 이 변수는 &lt;a href=&quot;../what-is-mariadb-100/index&quot;&gt;MariaDB 10.0&lt;/a&gt; 에서 제거되었습니다 .</target>
        </trans-unit>
        <trans-unit id="3c75317cdc9d859984155787a509bf766a061e02" translate="yes" xml:space="preserve">
          <source>Before &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt;, all MariaDB &lt;a href=&quot;../character-sets/index&quot;&gt;collations&lt;/a&gt; were of type &lt;code&gt;PADSPACE&lt;/code&gt;, meaning that VARCHAR (as well as &lt;a href=&quot;../char/index&quot;&gt;CHAR&lt;/a&gt; and &lt;a href=&quot;../text/index&quot;&gt;TEXT&lt;/a&gt; values) are compared without regard for trailing spaces. This does not apply to the &lt;a href=&quot;../like/index&quot;&gt;LIKE&lt;/a&gt; pattern-matching operator, which takes into account trailing spaces. From &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt;, a number of &lt;a href=&quot;../supported-character-sets-and-collations/index#no-pad-collations&quot;&gt;NO PAD collations&lt;/a&gt; are available.</source>
          <target state="translated">&lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt; 이전 에는 모든 MariaDB &lt;a href=&quot;../character-sets/index&quot;&gt;데이터 정렬&lt;/a&gt; 이 &lt;code&gt;PADSPACE&lt;/code&gt; 유형 이었으므로 VARCHAR ( &lt;a href=&quot;../char/index&quot;&gt;CHAR&lt;/a&gt; 및 &lt;a href=&quot;../text/index&quot;&gt;TEXT&lt;/a&gt; 값 뿐만 아니라 )도 후행 공백과 상관없이 비교됩니다. 후행 공백을 고려하는 &lt;a href=&quot;../like/index&quot;&gt;LIKE&lt;/a&gt; 패턴 일치 연산자 에는 적용되지 않습니다 . &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt; 부터 많은 &lt;a href=&quot;../supported-character-sets-and-collations/index#no-pad-collations&quot;&gt;NO PAD 데이터 정렬&lt;/a&gt; 이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="2816fb59ff62d126888f210ce64017a3c38c41db" translate="yes" xml:space="preserve">
          <source>Before &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt;, all MariaDB &lt;a href=&quot;../character-sets/index&quot;&gt;collations&lt;/a&gt; were of type PADSPACE, meaning that TEXT (as well as &lt;a href=&quot;../varchar/index&quot;&gt;VARCHAR&lt;/a&gt; and &lt;a href=&quot;../char/index&quot;&gt;CHAR&lt;/a&gt; values) are compared without regard for trailing spaces. This does not apply to the &lt;a href=&quot;../like/index&quot;&gt;LIKE&lt;/a&gt; pattern-matching operator, which takes into account trailing spaces.</source>
          <target state="translated">&lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt; 이전 에는 모든 MariaDB &lt;a href=&quot;../character-sets/index&quot;&gt;데이터 정렬&lt;/a&gt; 이 PADSPACE 유형이었습니다. 즉, 공백과 상관없이 TEXT ( &lt;a href=&quot;../varchar/index&quot;&gt;VARCHAR&lt;/a&gt; 및 &lt;a href=&quot;../char/index&quot;&gt;CHAR&lt;/a&gt; 값)가 비교됩니다. 후행 공백을 고려하는 &lt;a href=&quot;../like/index&quot;&gt;LIKE&lt;/a&gt; 패턴 일치 연산자 에는 적용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="95a130e143602197511650ca812494f09e0b2976" translate="yes" xml:space="preserve">
          <source>Before &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt;, all collations were of type PADSPACE, meaning that CHAR (as well as &lt;a href=&quot;../varchar/index&quot;&gt;VARCHAR&lt;/a&gt; and &lt;a href=&quot;../text/index&quot;&gt;TEXT&lt;/a&gt;) values are compared without regard for trailing spaces. This does not apply to the &lt;a href=&quot;../like/index&quot;&gt;LIKE&lt;/a&gt; pattern-matching operator, which takes into account trailing spaces.</source>
          <target state="translated">&lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt; 이전 에는 모든 데이터 정렬이 PADSPACE 유형이었습니다. 이는 뒤에 공백을 고려하지 않고 CHAR ( &lt;a href=&quot;../varchar/index&quot;&gt;VARCHAR&lt;/a&gt; 및 &lt;a href=&quot;../text/index&quot;&gt;TEXT&lt;/a&gt; ) 값이 비교 됨을 의미 합니다. 후행 공백을 고려하는 &lt;a href=&quot;../like/index&quot;&gt;LIKE&lt;/a&gt; 패턴 일치 연산자 에는 적용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="eb3e425caa59e525a5b7eec26fb7d32c5903e6c0" translate="yes" xml:space="preserve">
          <source>Before &lt;a href=&quot;../what-is-mariadb-53/index&quot;&gt;MariaDB 5.3&lt;/a&gt;/MySQL 5.6, the temporary table would never have any indexes, and the only way to read records from it would be a full table scan. Starting from the mentioned versions of the server, the optimizer has an option to create an index and use it for joins with other tables.</source>
          <target state="translated">&lt;a href=&quot;../what-is-mariadb-53/index&quot;&gt;MariaDB 5.3&lt;/a&gt; / MySQL 5.6 이전 에는 임시 테이블에 인덱스가 없으며 레코드를 읽는 유일한 방법은 전체 테이블 스캔입니다. 언급 된 서버 버전부터 옵티마이 저는 인덱스를 작성하고 다른 테이블과의 조인에 사용할 수있는 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3511146e313e50710b1370152c315a093dcc4dc5" translate="yes" xml:space="preserve">
          <source>Before &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt; and before MySQL 5.6 one could also set &lt;code&gt;sql_log_bin&lt;/code&gt; as a global variable. This has now been disabled as this was too dangerous as it could damage replication.</source>
          <target state="translated">전에 &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt; 의 MySQL 5.6과 이전에 하나의도 설정할 수 &lt;code&gt;sql_log_bin&lt;/code&gt; 전역 변수로. 복제가 손상 될 수 있으므로 너무 위험하므로이 기능이 비활성화되었습니다.</target>
        </trans-unit>
        <trans-unit id="c272f4203cc4d0468243c5686480086aff57981c" translate="yes" xml:space="preserve">
          <source>Before &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt;, FRAC_SECOND was permitted as a synonym for MICROSECOND.</source>
          <target state="translated">&lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt; 이전 에는 FRAC_SECOND가 MICROSECOND의 동의어로 허용되었습니다.</target>
        </trans-unit>
        <trans-unit id="47056e9b495661522d7aa6c3c8357c2459796700" translate="yes" xml:space="preserve">
          <source>Before &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt;, each use of, for example, &lt;a href=&quot;../lock-tables-and-unlock-tables/index&quot;&gt;LOCK TABLE ... WRITE&lt;/a&gt; would increment &lt;code&gt;In_use&lt;/code&gt; for that table. With the implementation of the metadata locking improvements in &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt;, &lt;code&gt;LOCK TABLE... WRITE&lt;/code&gt; acquires a strong MDL lock, and concurrent connections will wait on this MDL lock, so any subsequent &lt;code&gt;LOCK TABLE... WRITE&lt;/code&gt; will not increment &lt;code&gt;In_use&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt; 이전 에는, 예를 들어, &lt;a href=&quot;../lock-tables-and-unlock-tables/index&quot;&gt;LOCK TABLE ... WRITE&lt;/a&gt; 를 사용할 때마다 해당 테이블의 &lt;code&gt;In_use&lt;/code&gt; 가 증가 합니다. 개선 잠금 메타 데이터의 구현으로 &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt; , &lt;code&gt;LOCK TABLE... WRITE&lt;/code&gt; 강한 MDL 잠금을 획득하고, 동시 연결은 후속 있도록,이 MDL 잠금에 대기 &lt;code&gt;LOCK TABLE... WRITE&lt;/code&gt; 증가하지 않습니다 &lt;code&gt;In_use&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="28cf637be550d82f4fa0e6618b72e1d5676f73eb" translate="yes" xml:space="preserve">
          <source>Before &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt;, only inserted rows could be buffered, so this buffer was called Insert Buffer. The old name still appears in several places, for example in the output of &lt;a href=&quot;../show-engine-innodb-status/index&quot;&gt;SHOW ENGINE INNODB STATUS&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt; 이전 에는 삽입 된 행만 버퍼링 할 수 있으므로이 버퍼를 삽입 버퍼라고합니다. 이전 이름은 여전히 ​​여러 위치에 나타납니다 (예 : &lt;a href=&quot;../show-engine-innodb-status/index&quot;&gt;SHOW ENGINE INNODB STATUS&lt;/a&gt; 출력) .</target>
        </trans-unit>
        <trans-unit id="21fb598183dedf7359de66fd19ef8f58467a8bd5" translate="yes" xml:space="preserve">
          <source>Before &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt;, the DATA DIRECTORY &lt;a href=&quot;../create-table/index#table-options&quot;&gt;table option&lt;/a&gt; was not supported for InnoDB. Since &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt; it is supported, but only in CREATE TABLE. INDEX DIRECTORY has no effect, since InnoDB does not use separate files for indexes. To better balance the workload through several disks, the paths of some InnoDB log files can also be changed.</source>
          <target state="translated">&lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt; 이전 에는 DATA DIRECTORY &lt;a href=&quot;../create-table/index#table-options&quot;&gt;테이블 옵션&lt;/a&gt; 이 InnoDB에 대해 지원되지 않았습니다. &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt; 부터는 CREATE TABLE에서만 지원됩니다. InnoDB는 인덱스에 별도의 파일을 사용하지 않기 때문에 INDEX DIRECTORY는 효과가 없습니다. 여러 디스크를 통해 워크로드의 균형을 맞추기 위해 일부 InnoDB 로그 파일의 경로를 변경할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd330e6d0330a0633cc96add1aea2586a52fb82a" translate="yes" xml:space="preserve">
          <source>Before &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1001-release-notes/&quot;&gt;MariaDB 10.0.1&lt;/a&gt;, it returned a comma-separated list of column numbers, not names.</source>
          <target state="translated">&lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1001-release-notes/&quot;&gt;MariaDB 10.0.1&lt;/a&gt; 이전 에는 이름이 아닌 쉼표로 구분 된 열 번호 목록을 리턴했습니다.</target>
        </trans-unit>
        <trans-unit id="fcdd0b5d773921a038c25913d6b1d74cbf654789" translate="yes" xml:space="preserve">
          <source>Before &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1001-release-notes/&quot;&gt;MariaDB 10.0.1&lt;/a&gt;: Return a comma-separated list of column numbers. After &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1001-release-notes/&quot;&gt;MariaDB 10.0.1&lt;/a&gt;: Return a comma-separated list of column names. The names are quoted with backticks.</source>
          <target state="translated">전 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1001-release-notes/&quot;&gt;MariaDB 10.0.1&lt;/a&gt; 반환 열 번호의 쉼표로 구분 된 목록 :. &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1001-release-notes/&quot;&gt;MariaDB 10.0.1&lt;/a&gt; 이후 : 쉼표로 구분 된 열 이름 목록을 리턴하십시오. 이름은 백틱으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="5347cf5117af83a61eae99ab92fdd2656febb3f4" translate="yes" xml:space="preserve">
          <source>Before &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10015-release-notes/&quot;&gt;MariaDB 10.0.15&lt;/a&gt;, Mroonga was not available by default, and you needed to build the plugin. See the instructions at &lt;a href=&quot;http://mroonga.org/docs/install.html&quot;&gt;http://mroonga.org/docs/install.html&lt;/a&gt;. Since &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10015-release-notes/&quot;&gt;MariaDB 10.0.15&lt;/a&gt;, or once the plugin has been built, enable Mroonga with the following statement:</source>
          <target state="translated">전에 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10015-release-notes/&quot;&gt;MariaDB 10.0.15&lt;/a&gt; , Mroonga는 기본적으로 사용할 수 없습니다, 당신은 플러그인을 구축하는 데 필요한. &lt;a href=&quot;http://mroonga.org/docs/install.html&quot;&gt;http://mroonga.org/docs/install.html&lt;/a&gt; 의 지시 사항을 참조 하십시오 . &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10015-release-notes/&quot;&gt;MariaDB 10.0.15&lt;/a&gt; 이후 또는 플러그인이 빌드되면 다음 명령문으로 Mroonga를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="82ea372872a6dc1495655501a13abfb966ccebc5" translate="yes" xml:space="preserve">
          <source>Before &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1002-release-notes/&quot;&gt;MariaDB 10.0.2&lt;/a&gt;, a connection could only hold a single lock:</source>
          <target state="translated">&lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1002-release-notes/&quot;&gt;MariaDB 10.0.2&lt;/a&gt; 이전 에는 연결이 단일 잠금 만 보유 할 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="79a3c34395a4714694924c1b2f1ac2bf17cdea2b" translate="yes" xml:space="preserve">
          <source>Before &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10023-release-notes/&quot;&gt;MariaDB 10.0.23&lt;/a&gt; and &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1019-release-notes/&quot;&gt;MariaDB 10.1.9&lt;/a&gt;, this function was called Json_Value, but was renamed to avoid clashing with the &lt;a href=&quot;../json_value/index&quot;&gt;JSON_VALUE&lt;/a&gt; function.</source>
          <target state="translated">전에 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10023-release-notes/&quot;&gt;MariaDB 10.0.23&lt;/a&gt; 및 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1019-release-notes/&quot;&gt;MariaDB 10.1.9&lt;/a&gt; ,이 기능은 Json_Value라고했지만,과 충돌하지 않도록 이름이 변경되었습니다 &lt;a href=&quot;../json_value/index&quot;&gt;JSON_VALUE의&lt;/a&gt; 기능.</target>
        </trans-unit>
        <trans-unit id="3b775c4030423e448977d83e51f8f296773e3c9c" translate="yes" xml:space="preserve">
          <source>Before &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10113-release-notes/&quot;&gt;MariaDB 10.1.13&lt;/a&gt;, the &lt;code&gt;CREATE ROLE&lt;/code&gt; statement was not permitted in &lt;a href=&quot;../prepared-statements/index&quot;&gt;prepared statements&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10113-release-notes/&quot;&gt;MariaDB 10.1.13&lt;/a&gt; 이전 에는 &lt;code&gt;CREATE ROLE&lt;/code&gt; 문이 &lt;a href=&quot;../prepared-statements/index&quot;&gt;준비된 명령문&lt;/a&gt; 에서 허용되지 않았습니다 .</target>
        </trans-unit>
        <trans-unit id="a46165e3be738077b72f6d54d84c8da1e15676fd" translate="yes" xml:space="preserve">
          <source>Before &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10113-release-notes/&quot;&gt;MariaDB 10.1.13&lt;/a&gt;, the &lt;code&gt;DROP ROLE&lt;/code&gt; statement was not permitted in &lt;a href=&quot;../prepared-statements/index&quot;&gt;prepared statements&lt;/a&gt;.</source>
          <target state="translated">전에 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10113-release-notes/&quot;&gt;MariaDB 10.1.13&lt;/a&gt; 의 &lt;code&gt;DROP ROLE&lt;/code&gt; 문에서 허용되지 않은 &lt;a href=&quot;../prepared-statements/index&quot;&gt;준비된 문&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c089161897b1bdee908c82446158c2bdb6f9302d" translate="yes" xml:space="preserve">
          <source>Before &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10113-release-notes/&quot;&gt;MariaDB 10.1.13&lt;/a&gt;, the &lt;code&gt;REVOKE role&lt;/code&gt; statement was not permitted in &lt;a href=&quot;../prepared-statements/index&quot;&gt;prepared statements&lt;/a&gt;.</source>
          <target state="translated">전에 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10113-release-notes/&quot;&gt;MariaDB 10.1.13&lt;/a&gt; 의 &lt;code&gt;REVOKE role&lt;/code&gt; 문에서 허용되지 않은 &lt;a href=&quot;../prepared-statements/index&quot;&gt;준비된 문&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="18a058c8a8c930293174b5ff24c52878f82fe7c3" translate="yes" xml:space="preserve">
          <source>Before &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1017-release-notes/&quot;&gt;MariaDB 10.1.7&lt;/a&gt;, MariaDB (as well as versions of MySQL before MySQL 5.7) would silently convert it into a NOT NULL column with a default value of &lt;em&gt;0&lt;/em&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1017-release-notes/&quot;&gt;MariaDB 10.1.7&lt;/a&gt; 이전 에는 MariaDB (및 MySQL 5.7 이전의 MySQL 버전)가이를 기본값 &lt;em&gt;0&lt;/em&gt; 으로 NOT NULL 열로 자동 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="554364c88849236f3769f9b637c89a9d29ed7a5d" translate="yes" xml:space="preserve">
          <source>Before &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1021-release-notes/&quot;&gt;MariaDB 10.2.1&lt;/a&gt;, &lt;code&gt;BLOB&lt;/code&gt; and &lt;code&gt;TEXT&lt;/code&gt; columns could not be assigned a &lt;a href=&quot;../create-table/index#default&quot;&gt;DEFAULT&lt;/a&gt; value. This restriction was lifted in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1021-release-notes/&quot;&gt;MariaDB 10.2.1&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1021-release-notes/&quot;&gt;MariaDB 10.2.1&lt;/a&gt; 이전 에는 &lt;code&gt;BLOB&lt;/code&gt; 및 &lt;code&gt;TEXT&lt;/code&gt; 열에 &lt;a href=&quot;../create-table/index#default&quot;&gt;DEFAULT&lt;/a&gt; 값을 할당 할 수 없었습니다 . 이 제한은 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1021-release-notes/&quot;&gt;MariaDB 10.2.1&lt;/a&gt; 에서 해제되었습니다 .</target>
        </trans-unit>
        <trans-unit id="c82ac367f8198aada18f4a1be0d7d08e204f57a0" translate="yes" xml:space="preserve">
          <source>Before &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1029-release-notes/&quot;&gt;MariaDB 10.2.9&lt;/a&gt;, Mariabackup did not support the &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-export&quot;&gt;--export&lt;/a&gt;&lt;/code&gt; option. See &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-13466&quot;&gt;MDEV-13466&lt;/a&gt; about that. In earlier versions of MariaDB, this means that Mariabackup could not create &lt;code&gt;.cfg&lt;/code&gt; files for &lt;a href=&quot;../innodb-file-per-table-tablespaces/index&quot;&gt;InnoDB file-per-table tablespaces&lt;/a&gt; during the &lt;code&gt;--prepare&lt;/code&gt; stage. You can still &lt;a href=&quot;../innodb-file-per-table-tablespaces/index#copying-transportable-tablespaces&quot;&gt;import file-per-table tablespaces&lt;/a&gt; without the &lt;code&gt;.cfg&lt;/code&gt; files in many cases, so it may still be possible in those versions to &lt;a href=&quot;../partial-backup-and-restore-with-mariabackup/index&quot;&gt;restore partial backups&lt;/a&gt; or to &lt;a href=&quot;index&quot;&gt;restore individual tables and partitions&lt;/a&gt; with just the &lt;code&gt;.ibd&lt;/code&gt; files. If you have a &lt;a href=&quot;../full-backup-and-restore-with-mariabackup/index&quot;&gt;full backup&lt;/a&gt; and you need to create &lt;code&gt;.cfg&lt;/code&gt; files for &lt;a href=&quot;../innodb-file-per-table-tablespaces/index&quot;&gt;InnoDB file-per-table tablespaces&lt;/a&gt;, then you can do so by preparing the backup as usual without the &lt;code&gt;--export&lt;/code&gt; option, and then restoring the backup, and then starting the server. At that point, you can use the server's built-in features to &lt;a href=&quot;../innodb-file-per-table-tablespaces/index#copying-transportable-tablespaces&quot;&gt;copy the transportable tablespaces&lt;/a&gt;.</source>
          <target state="translated">전에 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1029-release-notes/&quot;&gt;MariaDB 10.2.9&lt;/a&gt; , Mariabackup는 지원하지 &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-export&quot;&gt;--export&lt;/a&gt;&lt;/code&gt; 옵션을 선택합니다. 이에 대해서는 &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-13466&quot;&gt;MDEV-13466을&lt;/a&gt; 참조하십시오 . MariaDB의 이전 버전에서,이 방법은 Mariabackup 만들 수 없다는 것을 &lt;code&gt;.cfg&lt;/code&gt; 를 위한 파일 &lt;a href=&quot;../innodb-file-per-table-tablespaces/index&quot;&gt;InnoDB의 파일 당 테이블 테이블을&lt;/a&gt; 동안 &lt;code&gt;--prepare&lt;/code&gt; 단계. 대부분의 경우 &lt;code&gt;.cfg&lt;/code&gt; 파일 없이 &lt;a href=&quot;../innodb-file-per-table-tablespaces/index#copying-transportable-tablespaces&quot;&gt;테이블 당 파일 공간&lt;/a&gt; 을 가져올 수 있으므로 해당 버전에서 &lt;a href=&quot;../partial-backup-and-restore-with-mariabackup/index&quot;&gt;부분 백업&lt;/a&gt; 을 &lt;a href=&quot;index&quot;&gt;복원&lt;/a&gt; 하거나 &lt;code&gt;.ibd&lt;/code&gt; 파일 만으로 개별 테이블 및 파티션 을 복원 할 수 있습니다. 당신이 경우 &lt;a href=&quot;../full-backup-and-restore-with-mariabackup/index&quot;&gt;전체 백업을&lt;/a&gt; 하면 작성해야 &lt;code&gt;.cfg&lt;/code&gt; &lt;a href=&quot;../innodb-file-per-table-tablespaces/index&quot;&gt;InnoDB 테이블 당 테이블 스페이스에&lt;/a&gt; 대한 .cfg 파일을 사용 하면 &lt;code&gt;--export&lt;/code&gt; 옵션 없이 평소와 같이 백업을 준비한 다음 백업 을 복원 한 다음 서버를 시작하여 수행 할 수 있습니다. 이때 서버의 내장 기능을 사용 &lt;a href=&quot;../innodb-file-per-table-tablespaces/index#copying-transportable-tablespaces&quot;&gt;하여 전송 가능한 테이블 스페이스&lt;/a&gt; 를 복사 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="11b9cca8ade586c3ced3430631a1bca12d6ea52d" translate="yes" xml:space="preserve">
          <source>Before &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1036-release-notes/&quot;&gt;MariaDB 10.3.6&lt;/a&gt;, was VARCHAR(128)</source>
          <target state="translated">&lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1036-release-notes/&quot;&gt;MariaDB 10.3.6&lt;/a&gt; 이전 에는 VARCHAR (128)</target>
        </trans-unit>
        <trans-unit id="e2ccdd3ead11e21b64bd2ade5502ee4ff0ae1ce2" translate="yes" xml:space="preserve">
          <source>Before &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1043-release-notes/&quot;&gt;MariaDB 10.4.3&lt;/a&gt;, InnoDB's spatial indexes could not be &lt;a href=&quot;../encryption/index&quot;&gt;encrypted&lt;/a&gt;. If an InnoDB table was encrypted and if it contained spatial indexes, then those indexes would be unencrypted.</source>
          <target state="translated">&lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1043-release-notes/&quot;&gt;MariaDB 10.4.3&lt;/a&gt; 이전 에는 InnoDB의 공간 인덱스를 &lt;a href=&quot;../encryption/index&quot;&gt;암호화&lt;/a&gt; 할 수 없었습니다 . InnoDB 테이블이 암호화되고 공간 인덱스가 포함 된 경우 해당 인덱스는 암호화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b8f4f18c395a9d982eb327fc0ddad73479e1c89c" translate="yes" xml:space="preserve">
          <source>Before &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1043-release-notes/&quot;&gt;MariaDB 10.4.3&lt;/a&gt;, MariaDB did not enable the &lt;code&gt;&lt;a href=&quot;../authentication-plugin-unix-socket/index&quot;&gt;unix_socket&lt;/a&gt;&lt;/code&gt; authentication plugin by default.This is default in Debian, allowing passwordless login.</source>
          <target state="translated">&lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1043-release-notes/&quot;&gt;MariaDB 10.4.3&lt;/a&gt; 이전에는 MariaDB 가 기본적으로 &lt;code&gt;&lt;a href=&quot;../authentication-plugin-unix-socket/index&quot;&gt;unix_socket&lt;/a&gt;&lt;/code&gt; 인증 플러그인을 활성화하지 않았습니다 . 이는 데비안에서는 기본값이며 암호없이 로그인 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d67f50b76d29215feeb30811056eeb8ff735c1b" translate="yes" xml:space="preserve">
          <source>Before &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1047-release-notes/&quot;&gt;MariaDB 10.4.7&lt;/a&gt;, &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10317-release-notes/&quot;&gt;MariaDB 10.3.17&lt;/a&gt;, &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10226-release-notes/&quot;&gt;MariaDB 10.2.26&lt;/a&gt; and &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10141-release-notes/&quot;&gt;MariaDB 10.1.41&lt;/a&gt;, this plugin did &lt;strong&gt;not&lt;/strong&gt; check &lt;a href=&quot;../grant/index&quot;&gt;user privileges&lt;/a&gt;. When it is enabled, &lt;strong&gt;any&lt;/strong&gt; user can query the &lt;code&gt;INFORMATION_SCHEMA.DISKS&lt;/code&gt; table and see all the information it provides.</source>
          <target state="translated">전에 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1047-release-notes/&quot;&gt;MariaDB 10.4.7&lt;/a&gt; , &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10317-release-notes/&quot;&gt;MariaDB 10.3.17&lt;/a&gt; , &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10226-release-notes/&quot;&gt;MariaDB 10.2.26&lt;/a&gt; 및 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10141-release-notes/&quot;&gt;MariaDB 10.1.41&lt;/a&gt; ,이 플러그인은 않았다 &lt;strong&gt;되지&lt;/strong&gt; 확인 &lt;a href=&quot;../grant/index&quot;&gt;사용자 권한을&lt;/a&gt; . 사용 가능한 경우, &lt;strong&gt;모든&lt;/strong&gt; 사용자는 &lt;code&gt;INFORMATION_SCHEMA.DISKS&lt;/code&gt; 테이블을 조회하고 제공하는 모든 정보를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31bf6dc285aa7b0f2e06e1fef32b29d499774fa7" translate="yes" xml:space="preserve">
          <source>Before Engine Condition Push Down patch .</source>
          <target state="translated">엔진 상태 전 푸시 다운 패치.</target>
        </trans-unit>
        <trans-unit id="def24790c5c6e6c413e3de8d6c1e86aaefc2f6f5" translate="yes" xml:space="preserve">
          <source>Before MariaDB 10, the table contained only the &lt;code&gt;EVENT_NAME&lt;/code&gt;, &lt;code&gt;COUNT_READ&lt;/code&gt;, &lt;code&gt;COUNT_WRITE&lt;/code&gt;, &lt;code&gt;SUM_NUMBER_OF_BYTES_READ&lt;/code&gt; and &lt;code&gt;SUM_NUMBER_OF_BYTES_WRITE&lt;/code&gt; columns.</source>
          <target state="translated">MariaDB 10 이전에는 테이블에 &lt;code&gt;EVENT_NAME&lt;/code&gt; , &lt;code&gt;COUNT_READ&lt;/code&gt; , &lt;code&gt;COUNT_WRITE&lt;/code&gt; , &lt;code&gt;SUM_NUMBER_OF_BYTES_READ&lt;/code&gt; 및 &lt;code&gt;SUM_NUMBER_OF_BYTES_WRITE&lt;/code&gt; 열만 포함되었습니다.</target>
        </trans-unit>
        <trans-unit id="22010e42bf71fcb86c56b0a460f3384c246f88f8" translate="yes" xml:space="preserve">
          <source>Before MariaDB 10, the table contained only the &lt;code&gt;FILE_NAME&lt;/code&gt;, &lt;code&gt;EVENT_NAME&lt;/code&gt;, &lt;code&gt;COUNT_READ&lt;/code&gt;, &lt;code&gt;COUNT_WRITE&lt;/code&gt;, &lt;code&gt;SUM_NUMBER_OF_BYTES_READ&lt;/code&gt; and &lt;code&gt;SUM_NUMBER_OF_BYTES_WRITE&lt;/code&gt; columns.</source>
          <target state="translated">MariaDB 10 이전에는 테이블에 &lt;code&gt;FILE_NAME&lt;/code&gt; , &lt;code&gt;EVENT_NAME&lt;/code&gt; , &lt;code&gt;COUNT_READ&lt;/code&gt; , &lt;code&gt;COUNT_WRITE&lt;/code&gt; , &lt;code&gt;SUM_NUMBER_OF_BYTES_READ&lt;/code&gt; 및 &lt;code&gt;SUM_NUMBER_OF_BYTES_WRITE&lt;/code&gt; 열만 포함되었습니다.</target>
        </trans-unit>
        <trans-unit id="f10d7a0bedbc4a37912c8d4ed7b2feb45754d2af" translate="yes" xml:space="preserve">
          <source>Before MariaDB 10, the third step was also performed by the SQL thread; this meant that only one event could execute at a time, and replication was essentially single-threaded. Since MariaDB 10, the third step can optionally be performed by a pool of separate replication worker threads, and thereby potentially increase replication performance by applying multiple events in parallel.</source>
          <target state="translated">MariaDB 10 이전에는 세 번째 단계가 SQL 스레드에서도 수행되었습니다. 즉, 한 번에 하나의 이벤트 만 실행할 수 있으며 복제는 기본적으로 단일 스레드입니다. MariaDB 10부터 세 번째 단계는 별도의 복제 작업자 스레드 풀에서 선택적으로 수행 할 수 있으므로 여러 이벤트를 병렬로 적용하여 복제 성능을 잠재적으로 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="c5da1acaac4070ecbcbba33bbfeea7d4c582d253" translate="yes" xml:space="preserve">
          <source>Before MariaDB can be installed, you also have to import the GPG public key that is used to verify the digital signatures of the packages in our repositories. This allows the &lt;code&gt;apt&lt;/code&gt; utility to verify the integrity of the packages that it installs.</source>
          <target state="translated">MariaDB를 설치하기 전에 리포지토리에있는 패키지의 디지털 서명을 확인하는 데 사용되는 GPG 공개 키를 가져와야합니다. 이를 통해 &lt;code&gt;apt&lt;/code&gt; 유틸리티는 설치 한 패키지의 무결성을 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4c15fb68b8b3813c3796029941c5c1cac58d4f00" translate="yes" xml:space="preserve">
          <source>Before MariaDB can be installed, you also have to import the GPG public key that is used to verify the digital signatures of the packages in our repositories. This allows the &lt;code&gt;yum&lt;/code&gt;, &lt;code&gt;dnf&lt;/code&gt; and &lt;code&gt;rpm&lt;/code&gt; utilities to verify the integrity of the packages that they install.</source>
          <target state="translated">MariaDB를 설치하기 전에 리포지토리에있는 패키지의 디지털 서명을 확인하는 데 사용되는 GPG 공개 키를 가져와야합니다. 이를 통해 &lt;code&gt;yum&lt;/code&gt; , &lt;code&gt;dnf&lt;/code&gt; 및 &lt;code&gt;rpm&lt;/code&gt; 유틸리티는 설치 한 패키지의 무결성을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e16a4e174d06b6fd3933b30b7b1f523ccf395208" translate="yes" xml:space="preserve">
          <source>Before MariaDB can be installed, you also have to import the GPG public key that is used to verify the digital signatures of the packages in our repositories. This allows the the &lt;code&gt;zypper&lt;/code&gt; and &lt;code&gt;rpm&lt;/code&gt; utilities to verify the integrity of the packages that they install.</source>
          <target state="translated">MariaDB를 설치하기 전에 리포지토리에있는 패키지의 디지털 서명을 확인하는 데 사용되는 GPG 공개 키를 가져와야합니다. 이는 &lt;code&gt;zypper&lt;/code&gt; 및 &lt;code&gt;rpm&lt;/code&gt; 유틸리티가 설치 한 패키지의 무결성을 검증 할 수있게합니다 .</target>
        </trans-unit>
        <trans-unit id="12b66af67f84e88a75c74033e8a7842c172862cb" translate="yes" xml:space="preserve">
          <source>Before MySQL 5.1.13, stored procedures that take no arguments required parentheses. In current releases of MariaDB, &lt;code&gt;CALL p()&lt;/code&gt; and &lt;code&gt;CALL p&lt;/code&gt; are equivalent.</source>
          <target state="translated">MySQL 5.1.13 이전에는 인수가없는 저장 프로시 저는 괄호가 필요하지 않습니다. MariaDB의 현재 릴리스에서 &lt;code&gt;CALL p()&lt;/code&gt; 및 &lt;code&gt;CALL p&lt;/code&gt; 는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="4efdfca6792e66179cb9c49955243b14570cd283" translate="yes" xml:space="preserve">
          <source>Before MySQL 5.1.33, a plugin was started with each option set to its default value.</source>
          <target state="translated">MySQL 5.1.33 이전에는 각 옵션이 기본값으로 설정된 플러그인이 시작되었습니다.</target>
        </trans-unit>
        <trans-unit id="dd84a41ccb4823362ea3746384773b6ef6662542" translate="yes" xml:space="preserve">
          <source>Before a modules can be added, the system must be ACTIVE or OFFLINE. Once added, they can be placed in-service with the &lt;em&gt;alterSystem-Enable&lt;/em&gt; command.</source>
          <target state="translated">모듈을 추가하기 전에 시스템이 활성 또는 오프라인 상태 여야합니다. 추가 한 후에는 &lt;em&gt;alterSystem-Enable&lt;/em&gt; 명령을 &lt;em&gt;사용&lt;/em&gt; 하여 서비스 상태로 둘 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0dace6b076e22e8ab003975ae063cbb40881c518" translate="yes" xml:space="preserve">
          <source>Before a row is inserted or updated, all constraints are evaluated in the order they are defined. If any constraint expression returns false, then the row will not be inserted or updated. One can use most deterministic functions in a constraint, including &lt;a href=&quot;../user-defined-functions/index&quot;&gt;UDFs&lt;/a&gt;.</source>
          <target state="translated">행을 삽입하거나 업데이트하기 전에 모든 제약 조건이 정의 된 순서대로 평가됩니다. 제한 조건 표현식이 false를 리턴하면 행이 삽입되거나 업데이트되지 않습니다. &lt;a href=&quot;../user-defined-functions/index&quot;&gt;UDF를&lt;/a&gt; 포함하여 제약 조건에서 대부분의 결정적 함수를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="aa6e0774c80e4578504a5f3f71f4c1fc56233a56" translate="yes" xml:space="preserve">
          <source>Before a row is inserted or updated, all constraints are evaluated in the order they are defined. If any constraint fails, then the row will not be updated. One can use most deterministic functions in a constraint, including &lt;a href=&quot;../user-defined-functions/index&quot;&gt;UDF's&lt;/a&gt;.</source>
          <target state="translated">행을 삽입하거나 업데이트하기 전에 모든 제약 조건이 정의 된 순서대로 평가됩니다. 제약 조건이 실패하면 행이 업데이트되지 않습니다. &lt;a href=&quot;../user-defined-functions/index&quot;&gt;UDF를&lt;/a&gt; 포함하여 제약 조건에서 대부분의 결정적 함수를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="51a85ed18ff7b2d07967a148408dafe65858163d" translate="yes" xml:space="preserve">
          <source>Before a row is inserted or updated, all constraints are evaluated in the order they are defined. If any constraints fails, then the row will not be updated. One can use most deterministic functions in a constraint, including &lt;a href=&quot;../user-defined-functions/index&quot;&gt;UDFs&lt;/a&gt;.</source>
          <target state="translated">행을 삽입하거나 업데이트하기 전에 모든 제약 조건이 정의 된 순서대로 평가됩니다. 제약 조건이 실패하면 행이 업데이트되지 않습니다. &lt;a href=&quot;../user-defined-functions/index&quot;&gt;UDF를&lt;/a&gt; 포함하여 제약 조건에서 대부분의 결정적 함수를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e9e333ede746209a704421d41cabaf88158a01eb" translate="yes" xml:space="preserve">
          <source>Before a row is modified, it is copied into the undo log. Each normal row contains a pointer to the most recent version of the same row in the undo log. Each row in the undo log contains a pointer to previous version, if any. So, each modified row has an history chain.</source>
          <target state="translated">행이 수정되기 전에 실행 취소 로그에 복사됩니다. 각 일반 행에는 실행 취소 로그에있는 동일한 행의 최신 버전에 대한 포인터가 포함됩니다. 실행 취소 로그의 각 행에는 이전 버전에 대한 포인터가 있습니다 (있는 경우). 따라서 수정 된 각 행에는 기록 체인이 있습니다.</target>
        </trans-unit>
        <trans-unit id="64660f4f174b8d423c141495a0350996c17ecc60" translate="yes" xml:space="preserve">
          <source>Before adding modules or DBRoots</source>
          <target state="translated">모듈 또는 DBRoot를 추가하기 전에</target>
        </trans-unit>
        <trans-unit id="13a64ec5d227e4e8699f0930f040222db94d52a6" translate="yes" xml:space="preserve">
          <source>Before any operation with a JDBC driver can be made, CONNECT must initialize the environment that will make working with Java possible. This will consist of:</source>
          <target state="translated">JDBC 드라이버로 작업하기 전에 CONNECT는 Java 작업을 가능하게하는 환경을 초기화해야합니다. 이것은 다음으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="c9f81904ab94ed1b0088e0ff786f5d3a195f845c" translate="yes" xml:space="preserve">
          <source>Before beginning the binary tar file installation you will need your system administrator to set up accounts for you on every MariaDB Columnstore node. The account name &amp;amp; password must be the same on every node. If you change the password on one node, you must change it on every node. The user ID must be the same on every node as well. In the examples below we will use the account name 'mysql' and the password 'mariadb'.</source>
          <target state="translated">이진 tar 파일 설치를 시작하기 전에 시스템 관리자가 모든 MariaDB Columnstore 노드에서 계정을 설정해야합니다. 계정 이름과 비밀번호는 모든 노드에서 동일해야합니다. 한 노드에서 비밀번호를 변경하면 모든 노드에서 비밀번호를 변경해야합니다. 모든 노드에서 사용자 ID가 동일해야합니다. 아래 예에서는 계정 이름 'mysql'과 비밀번호 'mariadb'를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="48991c6ae237196c3153e5c59d35f0b13f8a30a8" translate="yes" xml:space="preserve">
          <source>Before beginning the binary tar file installation you will need your system administrator to set up accounts for you on every MariaDB Columnstore node. The account name must be the same on every node. The password used must be the same on every node. If you subsequently change the password on one node, you must change it on every node. The user-id must be the same on every node as well. In the examples below we will use the account name 'guest' and the password 'mariadb'. Additionally, every node must have a basic Linux server package setup and additionally have expect (and all its dependencies) installed.</source>
          <target state="translated">이진 tar 파일 설치를 시작하기 전에 시스템 관리자가 모든 MariaDB Columnstore 노드에서 계정을 설정해야합니다. 계정 이름은 모든 노드에서 동일해야합니다. 사용 된 비밀번호는 모든 노드에서 동일해야합니다. 이후에 한 노드에서 비밀번호를 변경하면 모든 노드에서 비밀번호를 변경해야합니다. 사용자 ID도 모든 노드에서 동일해야합니다. 아래 예에서는 계정 이름 'guest'와 비밀번호 'mariadb'를 사용합니다. 또한 모든 노드에는 기본 Linux 서버 패키지 설정이 있어야하며 추가로 모든 종속 항목이 설치되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="5123181490c86e90826a845105c85bbdb5031382" translate="yes" xml:space="preserve">
          <source>Before beginning the binary tar file installation you will need your system administrator to set up accounts for you on every MariaDB Columnstore node. The account name must be the same on every node. The password used must be the same on every node. If you subsequently change the password on one node, you must change it on every node. The user-id must be the same on every node as well. In the examples below we will use the account name 'mysql' and the password 'mariadb'. Additionally, every node must have a basic Linux server package setup and additionally have expect (and all its dependencies) installed.</source>
          <target state="translated">이진 tar 파일 설치를 시작하기 전에 시스템 관리자가 모든 MariaDB Columnstore 노드에서 계정을 설정해야합니다. 계정 이름은 모든 노드에서 동일해야합니다. 사용 된 비밀번호는 모든 노드에서 동일해야합니다. 이후에 한 노드에서 비밀번호를 변경하면 모든 노드에서 비밀번호를 변경해야합니다. 사용자 ID도 모든 노드에서 동일해야합니다. 아래 예에서는 계정 이름 'mysql'과 비밀번호 'mariadb'를 사용합니다. 또한 모든 노드에는 기본 Linux 서버 패키지 설정이 있어야하며 추가로 모든 종속 항목이 설치되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="2fc1820e9e68f83d507a6c0153f3aa10a0769cfe" translate="yes" xml:space="preserve">
          <source>Before changing either of these values from their defaults, make sure you understand the impact and how your system currently uses the buffer. Their main reason for existence is to reduce the impact of full table scans, which are usually infrequent, but large, and previously could clear everything from the buffer. Setting a non-zero delay could help in situations where full table scans are performed in quick succession.</source>
          <target state="translated">이 값 중 하나를 기본값에서 변경하기 전에 시스템이 현재 버퍼를 사용하는 영향과 영향을 이해해야합니다. 존재하는 주된 이유는 일반적으로 드물지만 크며 이전에 버퍼에서 모든 항목을 지울 수있는 전체 테이블 스캔의 영향을 줄이는 것입니다. 0이 아닌 지연을 설정하면 전체 테이블 스캔이 빠르게 연속적으로 수행되는 상황에 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11e010fe482dd7fb41b06bfcc708e5f1d3dbf875" translate="yes" xml:space="preserve">
          <source>Before circular replication can begin, you also need to &lt;a href=&quot;../create-user/index&quot;&gt;create a user account&lt;/a&gt; on the MariaDB Server, since it will be acting as replication master to the cluster's slave, and you need to &lt;a href=&quot;../grant/index&quot;&gt;grant&lt;/a&gt; the user account the &lt;code&gt;&lt;a href=&quot;../grant/index#global-privileges&quot;&gt;REPLICATION SLAVE&lt;/a&gt;&lt;/code&gt; privilege. For example:</source>
          <target state="translated">원형 복제가 시작하기 전에, 당신은 또한 할 필요가 &lt;a href=&quot;../create-user/index&quot;&gt;사용자 계정을 만들 수&lt;/a&gt; 는 클러스터의 슬레이브에 복제 마스터 역할을 할 것입니다 때문에, MariaDB 서버에서, 당신은 할 필요가 &lt;a href=&quot;../grant/index&quot;&gt;부여&lt;/a&gt; 사용자가 계정 &lt;code&gt;&lt;a href=&quot;../grant/index#global-privileges&quot;&gt;REPLICATION SLAVE&lt;/a&gt;&lt;/code&gt; 권한을. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e823308c15e362339810744aebb922fbbdece6a7" translate="yes" xml:space="preserve">
          <source>Before circular replication can begin, you also need to &lt;a href=&quot;../create-user/index&quot;&gt;create a user account&lt;/a&gt; on the second cluster's master that the first cluster's slave can use to connect, and you need to &lt;a href=&quot;../grant/index&quot;&gt;grant&lt;/a&gt; the user account the &lt;code&gt;&lt;a href=&quot;../grant/index#global-privileges&quot;&gt;REPLICATION SLAVE&lt;/a&gt;&lt;/code&gt; privilege. For example:</source>
          <target state="translated">원형 복제가 시작하기 전에, 당신은 또한해야 할 &lt;a href=&quot;../create-user/index&quot;&gt;사용자 계정을 만드는&lt;/a&gt; 첫 번째 클러스터의 슬레이브 연결하는 데 사용할 수있는 두 번째 클러스터의 마스터, 당신은 할 필요가 &lt;a href=&quot;../grant/index&quot;&gt;부여&lt;/a&gt; 사용자가 계정 &lt;code&gt;&lt;a href=&quot;../grant/index#global-privileges&quot;&gt;REPLICATION SLAVE&lt;/a&gt;&lt;/code&gt; 권한을. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d76c603ab0e170581339f55de5305e88745acfce" translate="yes" xml:space="preserve">
          <source>Before executing the instruction we also keeps the current default database (if any). If this was changed during execution (i.e. a &lt;a href=&quot;../use/index&quot;&gt;USE&lt;/a&gt; statement has been executed), we restore the current database to the original.</source>
          <target state="translated">명령을 실행하기 전에 현재 기본 데이터베이스 (있는 경우)도 유지합니다. 이것이 실행 중에 변경된 경우 (즉, &lt;a href=&quot;../use/index&quot;&gt;USE&lt;/a&gt; 문이 실행 된 경우) 현재 데이터베이스를 원본으로 복원합니다.</target>
        </trans-unit>
        <trans-unit id="5408b0062709cc5bb6f6234ec24cfb35e91b4017" translate="yes" xml:space="preserve">
          <source>Before histograms were introduced, the optimizer would choose the plan that:</source>
          <target state="translated">히스토그램이 도입되기 전에 옵티마이 저는 다음과 같은 계획을 선택했습니다.</target>
        </trans-unit>
        <trans-unit id="4b7c6db4fb4933d0e5c2ce3f68c56167da43ecd6" translate="yes" xml:space="preserve">
          <source>Before install, make sure you go through the preparation guide to complete the system setup before installs the packages</source>
          <target state="translated">설치하기 전에 패키지를 설치하기 전에 준비 안내서를 통해 시스템 설정을 완료하십시오.</target>
        </trans-unit>
        <trans-unit id="390ec214c36bb0a353ede282e567d378901da662" translate="yes" xml:space="preserve">
          <source>Before installing MariaDB ColumnStore, there is some preparation necessary</source>
          <target state="translated">MariaDB ColumnStore를 설치하기 전에 몇 가지 준비가 필요합니다</target>
        </trans-unit>
        <trans-unit id="e356b9000ac8834c18fae792ea52749dde304792" translate="yes" xml:space="preserve">
          <source>Before installing MariaDB ColumnStore, there is some preparation necessary. You will need to determine the following, refer the MariaDB ColumnStore Architecture Document for additional information.</source>
          <target state="translated">MariaDB ColumnStore를 설치하기 전에 몇 가지 준비가 필요합니다. 다음을 결정해야합니다. 추가 정보는 MariaDB ColumnStore 아키텍처 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4795f2eec6c270da276398e417d4de930e38da9e" translate="yes" xml:space="preserve">
          <source>Before installing MariaDB ColumnStore, there is some preparation necessary. You will need to determine the following. Please refer to the MariaDB ColumnStore Architecture Document for additional information.</source>
          <target state="translated">MariaDB ColumnStore를 설치하기 전에 몇 가지 준비가 필요합니다. 다음을 결정해야합니다. 추가 정보는 MariaDB ColumnStore 아키텍처 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="52ddf13e675dc1770cb3f298beb1bc3a83ff1a49" translate="yes" xml:space="preserve">
          <source>Before making the REST OEM module, the Microsoft Casablanca package must be installed as for compiling MariaDB from source.</source>
          <target state="translated">REST OEM 모듈을 만들기 전에 소스에서 MariaDB를 컴파일 할 때 Microsoft Casablanca 패키지를 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="1ff12a23eed00776a1132b300211447359a42f43" translate="yes" xml:space="preserve">
          <source>Before moving a DBRoot from 1 module to another, the system must be in a STOPPED state. DBRoots cannot be moved while the system is active.</source>
          <target state="translated">한 모듈에서 다른 모듈로 DBRoot를 이동하기 전에 시스템이 STOPPED 상태 여야합니다. 시스템이 활성화되어있는 동안 DBRoot를 이동할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="01e9c0d1bf8a279adc2e503ee4b3d35c16257e21" translate="yes" xml:space="preserve">
          <source>Before sending the results to the user, sort the rows with filesort to get the results in the &lt;a href=&quot;../group-by/index&quot;&gt;GROUP BY&lt;/a&gt; order.</source>
          <target state="translated">결과를 사용자에게 보내기 전에 filesort로 행을 정렬하여 &lt;a href=&quot;../group-by/index&quot;&gt;GROUP BY&lt;/a&gt; 순서로 결과를 가져 오십시오 .</target>
        </trans-unit>
        <trans-unit id="91058f3b419e8a51570712c96e0b7e13520540dd" translate="yes" xml:space="preserve">
          <source>Before starting postConfigure for Non-Distributed Install, please ensure you have installed the MariaDB ColumnStore packages on all the nodes per &lt;a href=&quot;../preparing-for-columnstore-installation-12x/index&quot;&gt;Preparation Steps&lt;/a&gt;. And on the non-pm1 nodes startup the ColumnStore service before running postConfigure.</source>
          <target state="translated">비 분산 설치를위한 postConfigure를 시작하기 전에 &lt;a href=&quot;../preparing-for-columnstore-installation-12x/index&quot;&gt;준비 단계&lt;/a&gt; 마다 모든 노드에 MariaDB ColumnStore 패키지를 설치했는지 확인하십시오 . 그리고 비 pm1 노드 시작시 postConfigure를 실행하기 전에 ColumnStore 서비스를 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="8af9e6c21a939375d0b50f267d1010e3b1a3ce0b" translate="yes" xml:space="preserve">
          <source>Before storing a value to &lt;code&gt;value.x.decimal.value&lt;/code&gt;, one must call &lt;code&gt;mariadb_dyncol_prepare_decimal()&lt;/code&gt; to initialize the space for storage.</source>
          <target state="translated">&lt;code&gt;value.x.decimal.value&lt;/code&gt; 에 값을 저장하기 전에 &lt;code&gt;mariadb_dyncol_prepare_decimal()&lt;/code&gt; 을 호출 하여 저장 공간을 초기화 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f8149dd47507cf2fd5d7c50a40c50f1beddf4b35" translate="yes" xml:space="preserve">
          <source>Before table discovery was introduced, MariaDB used &lt;code&gt;.frm&lt;/code&gt; files to store the table definition. But now the engine can store the table definition (if the engine supports automatic discovery, of course), and &lt;code&gt;.frm&lt;/code&gt; files become redundant. Still, the server &lt;em&gt;can&lt;/em&gt; use &lt;code&gt;.frm&lt;/code&gt; files for such an engine &amp;mdash; but they are no longer the only source of the table definition. Now &lt;code&gt;.frm&lt;/code&gt; files are merely a &lt;em&gt;cache&lt;/em&gt; of the table definition, while the original authoritative table definition is stored in the engine. Like any cache, its purpose is to reduce discovery attempts for a table. The engine decides whether it makes sense to cache table definition in the &lt;code&gt;.frm&lt;/code&gt; file or not (see the second argument for the &lt;code&gt;TABLE_SHARE::init_from_binary_frm_image()&lt;/code&gt;). For example, the &lt;a href=&quot;../archive/index&quot;&gt;Archive&lt;/a&gt; engine uses &lt;code&gt;.frm&lt;/code&gt; cache, while the &lt;a href=&quot;../sequence/index&quot;&gt;Sequence&lt;/a&gt; engine does not. In other words, MariaDB creates &lt;code&gt;.frm&lt;/code&gt; files for &lt;a href=&quot;../archive/index&quot;&gt;Archive&lt;/a&gt; tables, but not for &lt;a href=&quot;../sequence/index&quot;&gt;Sequence&lt;/a&gt; tables.</source>
          <target state="translated">테이블 검색이 도입되기 전에 MariaDB는 &lt;code&gt;.frm&lt;/code&gt; 파일을 사용하여 테이블 정의를 저장했습니다. 그러나 이제 엔진은 테이블 정의를 저장할 수 있으며 (물론 엔진이 자동 검색을 지원하는 경우) &lt;code&gt;.frm&lt;/code&gt; 파일이 중복됩니다. 여전히 서버 &lt;em&gt;는&lt;/em&gt; 이러한 엔진에 &lt;code&gt;.frm&lt;/code&gt; 파일을 사용할 &lt;em&gt;수&lt;/em&gt; 있지만 더 이상 테이블 정의의 유일한 소스는 아닙니다. 이제 &lt;code&gt;.frm&lt;/code&gt; 파일은 단순히 테이블 정의 의 &lt;em&gt;캐시&lt;/em&gt; 인 반면 원래의 신뢰할 수있는 테이블 정의는 엔진에 저장됩니다. 다른 캐시와 마찬가지로 그 목적은 테이블에 대한 감지 시도를 줄이는 것입니다. 엔진은 &lt;code&gt;.frm&lt;/code&gt; 에서 테이블 정의를 캐시하는 것이 적합한 지 여부를 결정합니다.파일인지 아닌지 ( &lt;code&gt;TABLE_SHARE::init_from_binary_frm_image()&lt;/code&gt; 의 두 번째 인수 참조 ) 예를 들어 &lt;a href=&quot;../archive/index&quot;&gt;보관&lt;/a&gt; 엔진은 &lt;code&gt;.frm&lt;/code&gt; 캐시를 사용하지만 &lt;a href=&quot;../sequence/index&quot;&gt;시퀀스&lt;/a&gt; 엔진은 사용하지 않습니다. 즉, MariaDB 는 &lt;a href=&quot;../archive/index&quot;&gt;보관&lt;/a&gt; 테이블에 대해서는 &lt;code&gt;.frm&lt;/code&gt; 파일을 생성 하지만 &lt;a href=&quot;../sequence/index&quot;&gt;시퀀스&lt;/a&gt; 테이블 에는 .frm 파일을 생성 하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b9fafcd358a1a0f9f270cfb9d2f3e1c02f81e9f2" translate="yes" xml:space="preserve">
          <source>Before the MariaDB Server slave can begin replicating from the cluster's master, you need to &lt;a href=&quot;../create-user/index&quot;&gt;create a user account&lt;/a&gt; on the master that the slave can use to connect, and you need to &lt;a href=&quot;../grant/index&quot;&gt;grant&lt;/a&gt; the user account the &lt;code&gt;&lt;a href=&quot;../grant/index#global-privileges&quot;&gt;REPLICATION SLAVE&lt;/a&gt;&lt;/code&gt; privilege. For example:</source>
          <target state="translated">MariaDB 서버 슬레이브가 클러스터 마스터에서 복제를 시작하기 전에 슬레이브에서 연결할 수있는 마스터에 &lt;a href=&quot;../create-user/index&quot;&gt;사용자 계정&lt;/a&gt; 을 생성 해야 하며 사용자 계정에 &lt;code&gt;&lt;a href=&quot;../grant/index#global-privileges&quot;&gt;REPLICATION SLAVE&lt;/a&gt;&lt;/code&gt; 권한 을 &lt;a href=&quot;../grant/index&quot;&gt;부여&lt;/a&gt; 해야합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5ea9d0bfc1bbe24703eeb40afba7c486be60f57f" translate="yes" xml:space="preserve">
          <source>Before the data is dumped into LSM file, it is stored in the MemTable. MemTable doesn't allow computing index cardinalities, but it can provide an approximate number of rows in the table. Use of MemTable data for statistics is controlled by &lt;a href=&quot;../myrocks-system-variables/index#rocksdb_force_compute_memtable_stats&quot;&gt;rocksdb_force_compute_memtable_stats&lt;/a&gt;; the default value is &lt;code&gt;ON&lt;/code&gt;.</source>
          <target state="translated">데이터가 LSM 파일로 덤프되기 전에 MemTable에 저장됩니다. MemTable은 인덱스 카디널리티 계산을 허용하지 않지만 테이블에 대략적인 수의 행을 제공 할 수 있습니다. 에 의해 제어되는 통계 MemTable 데이터의 사용 &lt;a href=&quot;../myrocks-system-variables/index#rocksdb_force_compute_memtable_stats&quot;&gt;rocksdb_force_compute_memtable_stats&lt;/a&gt; ; 기본값은 &lt;code&gt;ON&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f505361471972d6fead524b047fe83aa21cd6371" translate="yes" xml:space="preserve">
          <source>Before the module can be compiled from source, we may need to install some dependencies.</source>
          <target state="translated">소스에서 모듈을 컴파일하기 전에 일부 종속성을 설치해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e6b375bd145932843630b98b1e638b22096173b" translate="yes" xml:space="preserve">
          <source>Before the module can be compiled from source, you may need to install some dependencies.</source>
          <target state="translated">소스에서 모듈을 컴파일하기 전에 일부 종속성을 설치해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="114260ab5071c87377afd413eed13f815b65d986" translate="yes" xml:space="preserve">
          <source>Before the new slave can begin replicating from the master, we need to &lt;a href=&quot;../create-user/index&quot;&gt;create a user account&lt;/a&gt; on the master that the slave can use to connect, and we need to &lt;a href=&quot;../grant/index&quot;&gt;grant&lt;/a&gt; the user account the &lt;code&gt;&lt;a href=&quot;../grant/index#global-privileges&quot;&gt;REPLICATION SLAVE&lt;/a&gt;&lt;/code&gt; privilege. For example:</source>
          <target state="translated">새 슬레이브가 마스터에서 복제를 시작하기 전에 슬레이브 에서 연결할 수있는 마스터에 &lt;a href=&quot;../create-user/index&quot;&gt;사용자 계정&lt;/a&gt; 을 생성 해야 하며 사용자 계정에 &lt;code&gt;&lt;a href=&quot;../grant/index#global-privileges&quot;&gt;REPLICATION SLAVE&lt;/a&gt;&lt;/code&gt; 권한 을 &lt;a href=&quot;../grant/index&quot;&gt;부여&lt;/a&gt; 해야합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9337e205bcb198452adcaa5f4ddc1b89f7ee699f" translate="yes" xml:space="preserve">
          <source>Before the second cluster's slave can begin replicating from the first cluster's master, you need to &lt;a href=&quot;../create-user/index&quot;&gt;create a user account&lt;/a&gt; on the master that the slave can use to connect, and you need to &lt;a href=&quot;../grant/index&quot;&gt;grant&lt;/a&gt; the user account the &lt;code&gt;&lt;a href=&quot;../grant/index#global-privileges&quot;&gt;REPLICATION SLAVE&lt;/a&gt;&lt;/code&gt; privilege. For example:</source>
          <target state="translated">두 번째 클러스터의 슬레이브가 첫 번째 클러스터의 마스터에서 복제를 시작하기 전에 슬레이브에서 연결할 수있는 마스터에 &lt;a href=&quot;../create-user/index&quot;&gt;사용자 계정&lt;/a&gt; 을 생성 해야 하며 사용자 계정에 &lt;code&gt;&lt;a href=&quot;../grant/index#global-privileges&quot;&gt;REPLICATION SLAVE&lt;/a&gt;&lt;/code&gt; 권한 을 &lt;a href=&quot;../grant/index&quot;&gt;부여&lt;/a&gt; 해야합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="600a69f7b5adff6b0c7fcf1fc66c835452234ba5" translate="yes" xml:space="preserve">
          <source>Before upgrading, please &lt;a href=&quot;../mariadb-vs-mysql-compatibility/index&quot;&gt;check if there are any known incompatibilities&lt;/a&gt; between your MySQL release and the MariaDB release you want to move to.</source>
          <target state="translated">업그레이드하기 전에 MySQL 릴리스와 이동하려는 MariaDB 릴리스 사이에 &lt;a href=&quot;../mariadb-vs-mysql-compatibility/index&quot;&gt;알려진 비 호환성이 있는지 확인하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="683a6af6a78b4fd1ea01a9497c8eabc556a01687" translate="yes" xml:space="preserve">
          <source>Before using MariaDB Galera Cluster, we would recommend reading through the &lt;a href=&quot;../mariadb-galera-cluster-known-limitations/index&quot;&gt;known limitations&lt;/a&gt;, so you can be sure that it is appropriate for your application.</source>
          <target state="translated">MariaDB Galera Cluster를 사용하기 전에 &lt;a href=&quot;../mariadb-galera-cluster-known-limitations/index&quot;&gt;알려진 제한&lt;/a&gt; 사항을 읽어 보는 것이 좋습니다 . 따라서 응용 프로그램에 적합한 지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f494e77e4ced1bb96594d5f0eeacdd75a1ed3b54" translate="yes" xml:space="preserve">
          <source>Before using mysqld_multi be sure that you understand the meanings of the options that are passed to the mysqld servers and why you would want to have separate mysqld processes. Beware of the dangers of using multiple mysqld servers with the same data directory. Use separate data directories, unless you know what you are doing. Starting multiple servers with the same data directory does not give you extra performance in a threaded system.</source>
          <target state="translated">mysqld_multi를 사용하기 전에 mysqld 서버에 전달되는 옵션의 의미와 별도의 mysqld 프로세스를 원하는 이유를 이해해야합니다. 동일한 데이터 디렉토리로 여러 mysqld 서버를 사용할 때의 위험에주의하십시오. 수행중인 작업을 모르면 별도의 데이터 디렉토리를 사용하십시오. 동일한 데이터 디렉토리로 여러 서버를 시작해도 스레드 시스템에서 추가 성능이 제공되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="153dbb5d25953cf10983a3e8ea165e623b090b89" translate="yes" xml:space="preserve">
          <source>Before we can use LDAP authentication, we first need to set up our OpenLDAP Server. This is usually done on a server that is completely separate from the database server.</source>
          <target state="translated">LDAP 인증을 사용하려면 먼저 OpenLDAP 서버를 설정해야합니다. 이것은 일반적으로 데이터베이스 서버와 완전히 분리 된 서버에서 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="05c78a5d7108243fa7e71fa73080b49cfb7be759" translate="yes" xml:space="preserve">
          <source>Before we set up replication, we also need to ensure that the MariaDB Server slave is configured properly. This involves the following steps:</source>
          <target state="translated">복제를 설정하기 전에 MariaDB 서버 슬레이브가 올바르게 구성되어 있는지 확인해야합니다. 여기에는 다음 단계가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="9fc9366e5f58d4fa51d128aba97589f16c142d67" translate="yes" xml:space="preserve">
          <source>Before we set up replication, we need to ensure that the cluster is configured properly. This involves the following steps:</source>
          <target state="translated">복제를 설정하기 전에 클러스터가 올바르게 구성되어 있는지 확인해야합니다. 여기에는 다음 단계가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d63fc9497d943ed37e1443fbbc6bd927748b6add" translate="yes" xml:space="preserve">
          <source>Before we set up replication, we need to ensure that the clusters are configured properly. This involves the following steps:</source>
          <target state="translated">복제를 설정하기 전에 클러스터가 올바르게 구성되어 있는지 확인해야합니다. 여기에는 다음 단계가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="510667e11de6e5c06ecaa96fe6eee130352d059c" translate="yes" xml:space="preserve">
          <source>Before we start the server on the new slave, we need to configure it. At the very least, we need to ensure that it has a unique &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-system-variables/index#server_id&quot;&gt;server_id&lt;/a&gt;&lt;/code&gt; value. We also need to make sure other replication settings are what we want them to be, such as the various &lt;a href=&quot;../gtid/index#system-variables-for-global-transaction-id&quot;&gt;GTID system variables&lt;/a&gt;, if those apply in the specific environment.</source>
          <target state="translated">새 슬레이브에서 서버를 시작하기 전에 서버를 구성해야합니다. 최소한 고유 한 &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-system-variables/index#server_id&quot;&gt;server_id&lt;/a&gt;&lt;/code&gt; 값 이 있는지 확인해야 합니다. 또한 특정 환경에 적용되는 경우 다양한 &lt;a href=&quot;../gtid/index#system-variables-for-global-transaction-id&quot;&gt;GTID 시스템 변수&lt;/a&gt; 와 같은 다른 복제 설정이 원하는 것인지 확인해야 합니다.</target>
        </trans-unit>
        <trans-unit id="fe2bc1e44d1b98f7800b77be427efb28b4b701c4" translate="yes" xml:space="preserve">
          <source>Before writing a compressed page into a data file, InnoDB writes it into the &lt;a href=&quot;../innodb-redo-log/index&quot;&gt;redo log&lt;/a&gt;. This ensures that the &lt;a href=&quot;../innodb-redo-log/index&quot;&gt;redo log&lt;/a&gt; can always be used to recover tables after a crash, even if the compression library is updated and some incompatibilities are introduced. But this also means that the &lt;a href=&quot;../innodb-redo-log/index&quot;&gt;redo log&lt;/a&gt; will grow faster and might need more space, or the frequency of checkpoints might need to increase.</source>
          <target state="translated">압축 된 페이지를 데이터 파일에 기록하기 전에 InnoDB는이를 &lt;a href=&quot;../innodb-redo-log/index&quot;&gt;리두 로그에 기록&lt;/a&gt; 합니다. 이렇게하면 압축 라이브러리가 업데이트되고 일부 비 호환성이 도입 되더라도 &lt;a href=&quot;../innodb-redo-log/index&quot;&gt;리두 로그&lt;/a&gt; 를 사용하여 충돌 후 항상 테이블을 복구 할 수 있습니다. 그러나 이는 또한 &lt;a href=&quot;../innodb-redo-log/index&quot;&gt;리두 로그&lt;/a&gt; 가 더 빨리 커지고 더 많은 공간이 필요하거나 체크 포인트 빈도가 증가해야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="eeb111642fe5ac461d8102466fa50ec53cfc6068" translate="yes" xml:space="preserve">
          <source>Before you begin, install the &lt;code&gt;software-properties-common&lt;/code&gt; and &lt;code&gt;devscripts&lt;/code&gt; packages:</source>
          <target state="translated">시작하기 전에 &lt;code&gt;software-properties-common&lt;/code&gt; 및 &lt;code&gt;devscripts&lt;/code&gt; 패키지를 설치하십시오 .</target>
        </trans-unit>
        <trans-unit id="c80aa84c0bb2ca9b3c4d2ff635d0d01dca836dbd" translate="yes" xml:space="preserve">
          <source>Before you begin, install the &lt;code&gt;software-properties-common&lt;/code&gt;, &lt;code&gt;devscripts&lt;/code&gt; and &lt;code&gt;equivs&lt;/code&gt; packages.</source>
          <target state="translated">시작하기 전에 &lt;code&gt;software-properties-common&lt;/code&gt; , &lt;code&gt;devscripts&lt;/code&gt; 및 &lt;code&gt;equivs&lt;/code&gt; 패키지를 설치 하십시오.</target>
        </trans-unit>
        <trans-unit id="ed7ab0fb38d16a2ff9726ad4e96d5ca302e79a36" translate="yes" xml:space="preserve">
          <source>Before you can get Sphinx working with the Sphinx Storage Engine on MariaDB, you need to configure it.</source>
          <target state="translated">MariaDB에서 Sphinx 스토리지 엔진을 사용하여 Sphinx를 사용하려면 먼저이를 구성해야합니다.</target>
        </trans-unit>
        <trans-unit id="ff95d1dc74907f0c9436ea13d5f88bd140089484" translate="yes" xml:space="preserve">
          <source>Before you can get Sphinx working with the Sphinx Storage Engine on MariaDB...</source>
          <target state="translated">Sphinx가 MariaDB에서 Sphinx 스토리지 엔진을 사용하기 전에 ...</target>
        </trans-unit>
        <trans-unit id="68e9617246e8e7aee080d909f123408e6e464096" translate="yes" xml:space="preserve">
          <source>Before you can restore from a backup, you first need to &lt;strong&gt;prepare&lt;/strong&gt; it to make the data files consistent. You can do so with the &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-prepare&quot;&gt;--prepare&lt;/a&gt;&lt;/code&gt; command option.</source>
          <target state="translated">백업에서 복원하려면 먼저 데이터 파일의 일관성을 유지하도록 백업을 &lt;strong&gt;준비&lt;/strong&gt; 해야합니다 . 당신은에 그렇게 할 수 &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-prepare&quot;&gt;--prepare&lt;/a&gt;&lt;/code&gt; 명령 옵션.</target>
        </trans-unit>
        <trans-unit id="030dac81951b9c04cae50b2553f907c665c742b8" translate="yes" xml:space="preserve">
          <source>Before you can restore from a backup, you first need to &lt;strong&gt;prepare&lt;/strong&gt; it to make the data files consistent. You can do so with the &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-prepare&quot;&gt;--prepare&lt;/a&gt;&lt;/code&gt; option.</source>
          <target state="translated">백업에서 복원하려면 먼저 데이터 파일의 일관성을 유지하도록 백업을 &lt;strong&gt;준비&lt;/strong&gt; 해야합니다 . 당신은에 그렇게 할 수 &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-prepare&quot;&gt;--prepare&lt;/a&gt;&lt;/code&gt; 옵션을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="630666c453ec320fbe8f270e5d51d1e08baba23e" translate="yes" xml:space="preserve">
          <source>Before you restart the server, you may also want to set the &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-skip-slave-start&quot;&gt;--skip-slave-start&lt;/a&gt;&lt;/code&gt; option in a server &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;option group&lt;/a&gt; in an &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;option file&lt;/a&gt;. This option prevents the &lt;a href=&quot;../replication-threads/index#threads-on-the-slave&quot;&gt;slave threads&lt;/a&gt; from restarting automatically when the server starts. Instead, they will have to be restarted manually.</source>
          <target state="translated">서버를 다시 시작하기 전에 &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;옵션 파일&lt;/a&gt; 의 서버 &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;옵션 그룹&lt;/a&gt; 에서 &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-skip-slave-start&quot;&gt;--skip-slave-start&lt;/a&gt;&lt;/code&gt; 옵션 을 설정할 수도 있습니다 . 이 옵션은 &lt;a href=&quot;../replication-threads/index#threads-on-the-slave&quot;&gt;슬레이브 스레드를&lt;/a&gt; 방지합니다 은 서버가 시작될 때 가 자동으로 다시 시작되지 합니다. 대신 수동으로 다시 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="8cdf3facea729602667221fa05085124236a1236" translate="yes" xml:space="preserve">
          <source>Before you start building MariaDB, you first need to install the build dependencies required to run the compile. CentOS provides a tool for installing build dependencies. The &lt;code&gt;yum-builddep&lt;/code&gt; utility reads a package and generates a list of the packages required to build from source, then calls YUM to install them for you. In the event that this utility is not available on your system, you can install it through the &lt;code&gt;yum-utils&lt;/code&gt; package. Once you have it, install the MariaDB build dependencies.</source>
          <target state="translated">MariaDB 빌드를 시작하기 전에 먼저 컴파일을 실행하는 데 필요한 빌드 종속성을 설치해야합니다. CentOS는 빌드 종속성을 설치하기위한 도구를 제공합니다. &lt;code&gt;yum-builddep&lt;/code&gt; 유틸리티는 당신을 위해 그 (것)들을 설치 YUM 호출 패키지를 읽고 소스로부터 빌드에 필요한 패키지 목록을 생성합니다. 시스템에서이 유틸리티를 사용할 수없는 경우 &lt;code&gt;yum-utils&lt;/code&gt; 패키지를 통해 설치할 수 있습니다 . 설치가 완료되면 MariaDB 빌드 종속성을 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="66a943c430d4d0b26bbbf82cdd51872bac364646" translate="yes" xml:space="preserve">
          <source>Before you uninstall the plugin, you should ensure that &lt;a href=&quot;../data-at-rest-encryption/index&quot;&gt;data-at-rest encryption&lt;/a&gt; is completely disabled, and that MariaDB no longer needs the plugin to decrypt tables or other files.</source>
          <target state="translated">플러그인을 제거하기 전에 유휴 &lt;a href=&quot;../data-at-rest-encryption/index&quot;&gt;데이터 암호화&lt;/a&gt; 가 완전히 비활성화되어 있고 MariaDB가 더 이상 테이블 또는 기타 파일의 암호를 해독하기 위해 플러그인이 필요하지 않은지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="2162d3262b8841e5b24a3fe24e2c2ed7c8dfdf03" translate="yes" xml:space="preserve">
          <source>Before you upgrade</source>
          <target state="translated">업그레이드하기 전에</target>
        </trans-unit>
        <trans-unit id="59173034beba9c739a6b08064b5b5ba2acbdb16f" translate="yes" xml:space="preserve">
          <source>Before you upgrade, it would be best to take a backup of your database. This is always a good idea to do before an upgrade. We would recommend &lt;a href=&quot;../backup-restore-and-import-clients-percona-xtrabackup/index&quot;&gt;Percona XtraBackup&lt;/a&gt;.</source>
          <target state="translated">업그레이드하기 전에 데이터베이스를 백업하는 것이 가장 좋습니다. 업그레이드하기 전에 항상 수행하는 것이 좋습니다. &lt;a href=&quot;../backup-restore-and-import-clients-percona-xtrabackup/index&quot;&gt;Percona XtraBackup&lt;/a&gt; 을 권장 합니다.</target>
        </trans-unit>
        <trans-unit id="fa4a26b794b64098b81a4c838f968e21c98e79bd" translate="yes" xml:space="preserve">
          <source>Before you upgrade, it would be best to take a backup of your database. This is always a good idea to do before an upgrade. We would recommend &lt;a href=&quot;../mariabackup/index&quot;&gt;Mariabackup&lt;/a&gt;.</source>
          <target state="translated">업그레이드하기 전에 데이터베이스를 백업하는 것이 가장 좋습니다. 업그레이드하기 전에 항상 수행하는 것이 좋습니다. &lt;a href=&quot;../mariabackup/index&quot;&gt;Mariabackup&lt;/a&gt; 을 권장 합니다 .</target>
        </trans-unit>
        <trans-unit id="d802490ad57b4016ac4bd0850535f9562d3349b4" translate="yes" xml:space="preserve">
          <source>Before you use the plugin, you need to create a Customer Master Key (CMK). Create a key using the AWS Console as described in the &lt;a href=&quot;http://docs.aws.amazon.com/kms/latest/developerguide/create-keys.html&quot;&gt;AMS KMS developer guide&lt;/a&gt;.</source>
          <target state="translated">플러그인을 사용하기 전에 CMK (Customer Master Key)를 작성해야합니다. &lt;a href=&quot;http://docs.aws.amazon.com/kms/latest/developerguide/create-keys.html&quot;&gt;AMS KMS 개발자 안내서에&lt;/a&gt; 설명 된대로 AWS 콘솔을 사용하여 키를 생성하십시오 .</target>
        </trans-unit>
        <trans-unit id="4aa6537075618e0fdc8f23a674c05b4b21e8aa24" translate="yes" xml:space="preserve">
          <source>Before you use the plugin, you need to create a Customer Master Key (CMK). Create a key using the AWS Console as described in the &lt;a href=&quot;https://docs.aws.amazon.com/kms/latest/developerguide/create-keys.html&quot;&gt;AMS KMS developer guide&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="237ff8c546874a0f965243dc0af4682a42dab48e" translate="yes" xml:space="preserve">
          <source>Beginning in &lt;a href=&quot;../what-is-mariadb-101/index&quot;&gt;MariaDB 10.1&lt;/a&gt;, &lt;a href=&quot;../what-is-mariadb-galera-cluster/index&quot;&gt;Galera Cluster&lt;/a&gt; ships with the MariaDB Server. Upgrading a Galera Cluster node is very similar to upgrading a server from &lt;a href=&quot;../what-is-mariadb-101/index&quot;&gt;MariaDB 10.1&lt;/a&gt; to &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt;. For more information on that process as well as incompatibilities between versions, see the &lt;a href=&quot;../upgrading-from-mariadb-101-to-mariadb-102/index&quot;&gt;Upgrade Guide&lt;/a&gt;.</source>
          <target state="translated">년부터 &lt;a href=&quot;../what-is-mariadb-101/index&quot;&gt;MariaDB 10.1&lt;/a&gt; , &lt;a href=&quot;../what-is-mariadb-galera-cluster/index&quot;&gt;갈레 클러스터&lt;/a&gt; MariaDB 서버와 함께 제공. Galera Cluster 노드 업그레이드는 서버를 &lt;a href=&quot;../what-is-mariadb-101/index&quot;&gt;MariaDB 10.1&lt;/a&gt; 에서 &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt; 로 업그레이드하는 것과 매우 유사합니다 . 해당 프로세스 및 버전 간 비 호환성에 대한 자세한 내용은 &lt;a href=&quot;../upgrading-from-mariadb-101-to-mariadb-102/index&quot;&gt;업그레이드 안내서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a91446bd6d20134155e9b7c88c569a95befb2c7f" translate="yes" xml:space="preserve">
          <source>Beginning in &lt;a href=&quot;../what-is-mariadb-101/index&quot;&gt;MariaDB 10.1&lt;/a&gt;, &lt;a href=&quot;../what-is-mariadb-galera-cluster/index&quot;&gt;Galera Cluster&lt;/a&gt; ships with the MariaDB Server. Upgrading a Galera Cluster node is very similar to upgrading a server from &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt; to &lt;a href=&quot;../what-is-mariadb-103/index&quot;&gt;MariaDB 10.3&lt;/a&gt;. For more information on that process as well as incompatibilities between versions, see the &lt;a href=&quot;../upgrading-from-mariadb-102-to-mariadb-103/index&quot;&gt;Upgrade Guide&lt;/a&gt;.</source>
          <target state="translated">년부터 &lt;a href=&quot;../what-is-mariadb-101/index&quot;&gt;MariaDB 10.1&lt;/a&gt; , &lt;a href=&quot;../what-is-mariadb-galera-cluster/index&quot;&gt;갈레 클러스터&lt;/a&gt; MariaDB 서버와 함께 제공. Galera Cluster 노드 업그레이드는 서버를 &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt; 에서 &lt;a href=&quot;../what-is-mariadb-103/index&quot;&gt;MariaDB 10.3&lt;/a&gt; 으로 업그레이드하는 것과 매우 유사합니다 . 해당 프로세스 및 버전 간 비 호환성에 대한 자세한 내용은 &lt;a href=&quot;../upgrading-from-mariadb-102-to-mariadb-103/index&quot;&gt;업그레이드 안내서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="98fd0a8c8f34520cd79a58fd8bd83c7f818d4533" translate="yes" xml:space="preserve">
          <source>Beginning in &lt;a href=&quot;../what-is-mariadb-101/index&quot;&gt;MariaDB 10.1&lt;/a&gt;, &lt;a href=&quot;../what-is-mariadb-galera-cluster/index&quot;&gt;Galera Cluster&lt;/a&gt; ships with the MariaDB Server. Upgrading a Galera Cluster node is very similar to upgrading a server from &lt;a href=&quot;../what-is-mariadb-103/index&quot;&gt;MariaDB 10.3&lt;/a&gt; to &lt;a href=&quot;../what-is-mariadb-104/index&quot;&gt;MariaDB 10.4&lt;/a&gt;. For more information on that process as well as incompatibilities between versions, see the &lt;a href=&quot;../upgrading-from-mariadb-103-to-mariadb-104/index&quot;&gt;Upgrade Guide&lt;/a&gt;.</source>
          <target state="translated">년부터 &lt;a href=&quot;../what-is-mariadb-101/index&quot;&gt;MariaDB 10.1&lt;/a&gt; , &lt;a href=&quot;../what-is-mariadb-galera-cluster/index&quot;&gt;갈레 클러스터&lt;/a&gt; MariaDB 서버와 함께 제공. Galera Cluster 노드 업그레이드는 서버를 &lt;a href=&quot;../what-is-mariadb-103/index&quot;&gt;MariaDB 10.3&lt;/a&gt; 에서 &lt;a href=&quot;../what-is-mariadb-104/index&quot;&gt;MariaDB 10.4&lt;/a&gt; 로 업그레이드하는 것과 매우 유사합니다 . 해당 프로세스 및 버전 간 비 호환성에 대한 자세한 내용은 &lt;a href=&quot;../upgrading-from-mariadb-103-to-mariadb-104/index&quot;&gt;업그레이드 안내서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="94abe8fcfb4aa18101b9030e1ab30c04392340a9" translate="yes" xml:space="preserve">
          <source>Beginning in &lt;a href=&quot;../what-is-mariadb-104/index&quot;&gt;MariaDB 10.4&lt;/a&gt;, where the encryption key management plugin supports key rotation the InnoDB Redo Log can also rotate encryption keys. In previous releases, the Redo Log can only use the first encryption key.</source>
          <target state="translated">암호화 키 관리 플러그인이 키 회전을 지원하는 &lt;a href=&quot;../what-is-mariadb-104/index&quot;&gt;MariaDB 10.4&lt;/a&gt; 부터 InnoDB Redo Log는 암호화 키를 회전 할 수도 있습니다. 이전 릴리스에서 Redo Log는 첫 번째 암호화 키만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0bda40a6c986a6deef5116be8dfdb6cc366005d3" translate="yes" xml:space="preserve">
          <source>Beginning in &lt;a href=&quot;../what-is-mariadb-104/index&quot;&gt;MariaDB 10.4&lt;/a&gt;, you can control the ordering of execution on table operations using parentheses.</source>
          <target state="translated">&lt;a href=&quot;../what-is-mariadb-104/index&quot;&gt;MariaDB 10.4&lt;/a&gt; 부터 괄호를 사용하여 테이블 작업에서 실행 순서를 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82c5b2c7a96a800f3df208d835fdf79d61ae2a72" translate="yes" xml:space="preserve">
          <source>Beginning in &lt;a href=&quot;../what-is-mariadb-105/index&quot;&gt;MariaDB 10.5&lt;/a&gt;, there is a fatal error generated when trying to create a generated column whose value can change depending on the &lt;code&gt;&lt;a href=&quot;../sql-mode/index&quot;&gt;SQL Mode&lt;/a&gt;&lt;/code&gt; when its data is &lt;code&gt;PERSISTENT&lt;/code&gt; or indexed.</source>
          <target state="translated">&lt;a href=&quot;../what-is-mariadb-105/index&quot;&gt;MariaDB 10.5&lt;/a&gt; 부터 데이터가 &lt;code&gt;PERSISTENT&lt;/code&gt; 이거나 색인화 될 때 &lt;code&gt;&lt;a href=&quot;../sql-mode/index&quot;&gt;SQL Mode&lt;/a&gt;&lt;/code&gt; 에 따라 값이 변경 될 수있는 생성 된 열을 작성하려고 할 때 치명적인 오류가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="807151f86d011f97aa2abad5e0ddc9d41b2860a4" translate="yes" xml:space="preserve">
          <source>Beginning in &lt;a href=&quot;../what-is-mariadb-53/index&quot;&gt;MariaDB 5.3&lt;/a&gt;, the slave will try to choose a good index among any available:</source>
          <target state="translated">&lt;a href=&quot;../what-is-mariadb-53/index&quot;&gt;MariaDB 5.3&lt;/a&gt; 부터 슬레이브는 사용 가능한 인덱스 중에서 좋은 인덱스를 선택하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="665d58674421bc2d9d257e32d7d6c9558b5372c0" translate="yes" xml:space="preserve">
          <source>Beginning in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1048-release-notes/&quot;&gt;MariaDB 10.4.8&lt;/a&gt;, &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10318-release-notes/&quot;&gt;MariaDB 10.3.18&lt;/a&gt;, and &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10227-release-notes/&quot;&gt;MariaDB 10.2.27&lt;/a&gt; a potentially inconsistent generated column outputs a warning when created or first used (without restricting their creation).</source>
          <target state="translated">후부터 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1048-release-notes/&quot;&gt;MariaDB 10.4.8&lt;/a&gt; , &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10318-release-notes/&quot;&gt;MariaDB 10.3.18&lt;/a&gt; 및 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10227-release-notes/&quot;&gt;MariaDB 10.2.27&lt;/a&gt; 만들거나 처음 사용될 때 잠재적 불일치 발생 열은 (그 생성을 제한하지 않음)에 경고를 출력한다.</target>
        </trans-unit>
        <trans-unit id="ed25d92a536b307f074428d3775326fa49933bfe" translate="yes" xml:space="preserve">
          <source>Beginning in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5521-release-notes/&quot;&gt;MariaDB 5.5.21&lt;/a&gt;, there is a &lt;a href=&quot;../limit-rows-examined/index&quot;&gt;LIMIT ROWS EXAMINED&lt;/a&gt; optimization which provides the means to terminate the execution of &lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt; statements which examine too many rows, and thus use too many resources. See &lt;a href=&quot;../limit-rows-examined/index&quot;&gt;LIMIT ROWS EXAMINED&lt;/a&gt;.</source>
          <target state="translated">년부터 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5521-release-notes/&quot;&gt;MariaDB 5.5.21&lt;/a&gt; 하는이 &lt;a href=&quot;../limit-rows-examined/index&quot;&gt;LIMIT 행 검사&lt;/a&gt; 의 실행을 종료 할 수있는 수단을 제공하는 최적화 &lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt; 너무 많은 리소스를 사용하여 너무 많은 행을 검사하고 문을. &lt;a href=&quot;../limit-rows-examined/index&quot;&gt;LIMIT ROWS EXAMINED를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="85678fc7c0f98ad3e8f8b21587259cb413a2db32" translate="yes" xml:space="preserve">
          <source>Beginning in Aria 2.5, the plan is to focus on improving performance.</source>
          <target state="translated">Aria 2.5부터 계획은 성능 향상에 중점을 둡니다.</target>
        </trans-unit>
        <trans-unit id="05b0f3ece18127cad4bd8bd31b7811c2157a5def" translate="yes" xml:space="preserve">
          <source>Beginning with &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-530-release-notes/&quot;&gt;MariaDB 5.3.0&lt;/a&gt;, the &lt;a href=&quot;../handlersocket/index&quot;&gt;HandlerSocket&lt;/a&gt; plugin is included in both source and binary distributions.</source>
          <target state="translated">부터 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-530-release-notes/&quot;&gt;MariaDB 5.3.0&lt;/a&gt; 의 &lt;a href=&quot;../handlersocket/index&quot;&gt;HandlerSocket의&lt;/a&gt; 플러그인은 소스 및 바이너리 배포판에 모두 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff8b5ef7694348f0cc19cee54186e435ac415867" translate="yes" xml:space="preserve">
          <source>Beginning with &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5531-release-notes/&quot;&gt;MariaDB 5.5.31&lt;/a&gt;, usernames can be up to 80 characters long. From &lt;a href=&quot;../what-is-mariadb-100/index&quot;&gt;MariaDB 10.0&lt;/a&gt; the system tables are all by default this length. However, in order to enable this feature in &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt;, the following schema changes must be made:</source>
          <target state="translated">&lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5531-release-notes/&quot;&gt;MariaDB 5.5.31&lt;/a&gt; 부터 사용자 이름의 길이는 최대 80 자입니다. &lt;a href=&quot;../what-is-mariadb-100/index&quot;&gt;MariaDB 10.0&lt;/a&gt; 부터 시스템 테이블은 기본적으로이 길이입니다. 그러나 &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt; 에서이 기능을 사용 하려면 다음 스키마를 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="c57e9bee4db6237883ff0f7dc209fd4348a221cd" translate="yes" xml:space="preserve">
          <source>Being a write-optimized storage engine, MyRocks has special ways to load data much faster than normal INSERTs would.</source>
          <target state="translated">쓰기 최적화 스토리지 엔진 인 MyRocks에는 일반 INSERT보다 데이터를 훨씬 빠르게로드 할 수있는 특별한 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1931ca362689f7bc645fae991676f6876f72695" translate="yes" xml:space="preserve">
          <source>Being executed by the data source, the (rephrased) command must also respect the data source syntax.</source>
          <target state="translated">데이터 소스에 의해 실행되기 때문에 (복구 된) 명령은 데이터 소스 구문도 존중해야합니다.</target>
        </trans-unit>
        <trans-unit id="ad294cbee1dacfffe91631f0968bed0bf1704bfe" translate="yes" xml:space="preserve">
          <source>Being purged log %s was not found</source>
          <target state="translated">제거 된 로그 % s이 (가) 없습니다.</target>
        </trans-unit>
        <trans-unit id="3aa5f05a2c200e7c9395b0eeffc630ca1ddeea94" translate="yes" xml:space="preserve">
          <source>Being the first field in some index lets the engine find the 'next' value when opening the table.</source>
          <target state="translated">일부 색인의 첫 번째 필드이므로 엔진은 테이블을 열 때 '다음'값을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="027a12c2fc8568e8b70b07ff536faf288a013670" translate="yes" xml:space="preserve">
          <source>Belarus</source>
          <target state="translated">Belarus</target>
        </trans-unit>
        <trans-unit id="2c7205595032bf70cf7a8260e25275d136c5ea00" translate="yes" xml:space="preserve">
          <source>Belarusian</source>
          <target state="translated">Belarusian</target>
        </trans-unit>
        <trans-unit id="5cb4c9d828175ed3931ec52305b32f47173a8e04" translate="yes" xml:space="preserve">
          <source>Belgium</source>
          <target state="translated">Belgium</target>
        </trans-unit>
        <trans-unit id="4a8c75c6bbe98968879a19d9b82f7a930cb0544d" translate="yes" xml:space="preserve">
          <source>Believe Digital Using for back office analytics queries to aggregate multi billions tables in real time</source>
          <target state="translated">백 오피스 분석 쿼리에 디지털을 사용하여 수십억 개의 테이블을 실시간으로 집계</target>
        </trans-unit>
        <trans-unit id="ba8b2c613c93421261d16561e410155f8d153dba" translate="yes" xml:space="preserve">
          <source>Below are generic examples of records that are entered in the audit log for each type of table event:</source>
          <target state="translated">다음은 각 테이블 이벤트 유형에 대해 감사 로그에 입력 된 레코드의 일반적인 예입니다.</target>
        </trans-unit>
        <trans-unit id="f8e63929a67668c25d0563d2f25c68431e96bdfb" translate="yes" xml:space="preserve">
          <source>Below are instructions for creating your own Debian repository. The instructions are based on &lt;a href=&quot;http://www.debian.org/doc/manuals/repository-howto/repository-howto.en.html&quot;&gt;http://www.debian.org/doc/manuals/repository-howto/repository-howto.en.html&lt;/a&gt;</source>
          <target state="translated">다음은 자신 만의 데비안 저장소를 만드는 지침입니다. 지침은 &lt;a href=&quot;http://www.debian.org/doc/manuals/repository-howto/repository-howto.en.html&quot;&gt;http://www.debian.org/doc/manuals/repository-howto/repository-howto.en.html을&lt;/a&gt; 기반으로합니다 .</target>
        </trans-unit>
        <trans-unit id="c34fc27e19ff7bbd89389087da57d62a7cc10a0c" translate="yes" xml:space="preserve">
          <source>Below are instructions for creating your own Debian repository. The instructions are based on &lt;a href=&quot;https://www.debian.org/doc/manuals/repository-howto/repository-howto.en.html&quot;&gt;http://www.debian.org/doc/manuals/repository-howto/repository-howto.en.html&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ec2d944e950e54fb8aa5eacf3ed7a6c5c575c91" translate="yes" xml:space="preserve">
          <source>Below are links to additional documentation on the MariaDB Audit Plugin. They explain in detail how to install, configure and use the Audit Plugin.</source>
          <target state="translated">다음은 MariaDB 감사 플러그인에 대한 추가 설명서 링크입니다. 감사 플러그인을 설치, 구성 및 사용하는 방법에 대해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="3f6ca4db7064b577d90b444cad777bd73d7c8f7d" translate="yes" xml:space="preserve">
          <source>Below are links to some tutorials on MariaDB's site and other sites. They may help you to get more out of the MariaDB Audit Plugin.</source>
          <target state="translated">다음은 MariaDB 사이트 및 기타 사이트의 일부 자습서에 대한 링크입니다. MariaDB 감사 플러그인을 최대한 활용하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b73895ee2818072045aa8b2da335a3aa24c21317" translate="yes" xml:space="preserve">
          <source>Below are links to web log articles on the MariaDB Audit Plugin. You may find them useful in understanding better how to use the Audit Plugin. Since some of these articles are older, they won't include changes and improvements in newer versions. You can rely on the documentation pages listed above for the most current information.</source>
          <target state="translated">다음은 MariaDB 감사 플러그인의 웹 로그 기사에 대한 링크입니다. 감사 플러그인 사용 방법을 더 잘 이해하는 데 도움이 될 수 있습니다. 이 기사 중 일부는 이전 기사이므로 최신 버전의 변경 사항 및 개선 사항은 포함하지 않습니다. 최신 정보는 위에 나열된 설명서 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b013ca1e48e6a77ab0915b32153595b71014d53a" translate="yes" xml:space="preserve">
          <source>Below is a diagram of the &lt;code&gt;MaxScale-2&lt;/code&gt; server configuration:</source>
          <target state="translated">다음은 &lt;code&gt;MaxScale-2&lt;/code&gt; 서버 구성 의 다이어그램입니다 .</target>
        </trans-unit>
        <trans-unit id="d6844076db7ba838c08a769884d1cc3a1f0467d4" translate="yes" xml:space="preserve">
          <source>Below is a generic example of the output for connect events, with placeholders representing data. These are events in which a user connected, disconnected, or tried unsuccessfully to connect to the server.</source>
          <target state="translated">다음은 자리 표시자가 데이터를 나타내는 연결 이벤트 출력의 일반적인 예입니다. 사용자가 서버에 연결하거나 연결을 끊거나 연결에 실패한 이벤트입니다.</target>
        </trans-unit>
        <trans-unit id="7bfa06b9be5245e8348b6653465d4f3f731f98bb" translate="yes" xml:space="preserve">
          <source>Below is a list of all &lt;code&gt;&lt;a href=&quot;../performance-schema/index&quot;&gt;performance_schema&lt;/a&gt;&lt;/code&gt; tables as well as a brief description of each of them.</source>
          <target state="translated">아래는 모든 &lt;code&gt;&lt;a href=&quot;../performance-schema/index&quot;&gt;performance_schema&lt;/a&gt;&lt;/code&gt; 테이블 의 목록 과 각 테이블에 대한 간략한 설명입니다.</target>
        </trans-unit>
        <trans-unit id="887cdcd706c92c5b98829cc2ff1c4544c5881894" translate="yes" xml:space="preserve">
          <source>Below is a list of all &lt;em&gt;optimizer_switch&lt;/em&gt; flags available in MariaDB:</source>
          <target state="translated">다음은 MariaDB에서 사용 가능한 모든 &lt;em&gt;optimizer_switch&lt;/em&gt; 플래그 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="2c078953afc4003102d8bb7ff44c4013083fdd88" translate="yes" xml:space="preserve">
          <source>Below is a list of all status variables related to the Audit Plugin. These cannot be set: These are not to be confused with system variables, which can be set. See &lt;a href=&quot;../server-status-variables/index&quot;&gt;Server Status Variables&lt;/a&gt; for a complete list of status variables that can be viewed with the &lt;a href=&quot;../show-status/index&quot;&gt;SHOW STATUS&lt;/a&gt; statement. See also the &lt;a href=&quot;../full-list-of-mariadb-options-system-and-status-variables/index&quot;&gt;Full list of MariaDB options, system and status variables&lt;/a&gt;.</source>
          <target state="translated">다음은 감사 플러그인과 관련된 모든 상태 변수의 목록입니다. 이것들은 설정 될 수 없습니다 : 이것들은 설정 될 수있는 시스템 변수와 혼동되어서는 안됩니다. &lt;a href=&quot;../show-status/index&quot;&gt;SHOW STATUS&lt;/a&gt; 문 으로 볼 수있는 전체 상태 변수 목록은 &lt;a href=&quot;../server-status-variables/index&quot;&gt;서버 상태 변수&lt;/a&gt; 를 참조하십시오 . &lt;a href=&quot;../full-list-of-mariadb-options-system-and-status-variables/index&quot;&gt;MariaDB 옵션, 시스템 및 상태 변수&lt;/a&gt; 의 전체 목록을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ce044390742fc044edc358c1ae350513af11dec2" translate="yes" xml:space="preserve">
          <source>Below is a list of all system variables related to the Audit Plugin. See &lt;a href=&quot;../server-system-variables/index&quot;&gt;Server System Variables&lt;/a&gt; for a complete list of system variables and instructions on setting them. See also the &lt;a href=&quot;../full-list-of-mariadb-options-system-and-status-variables/index&quot;&gt;full list of MariaDB options, system and status variables&lt;/a&gt;.</source>
          <target state="translated">다음은 감사 플러그인과 관련된 모든 시스템 변수 목록입니다. &lt;a href=&quot;../server-system-variables/index&quot;&gt;시스템 변수&lt;/a&gt; 의 전체 목록과 설정에 대한 지시 사항 은 서버 시스템 변수 를 참조하십시오 . &lt;a href=&quot;../full-list-of-mariadb-options-system-and-status-variables/index&quot;&gt;MariaDB 옵션, 시스템 및 상태 변수&lt;/a&gt; 의 전체 목록을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4e98ad955e0734c22674d58ca7794f504390e1b6" translate="yes" xml:space="preserve">
          <source>Below is a list of the releases of the MariaDB Audit Plugin, the most recent version first, and in which versions of MariaDB each plugin version was included.</source>
          <target state="translated">다음은 가장 최신 버전 인 MariaDB 감사 플러그인의 릴리스 목록이며 각 플러그인 버전에 포함 된 MariaDB 버전입니다.</target>
        </trans-unit>
        <trans-unit id="16b079e05f0eae9174ae76e19ac6387fb9208cef" translate="yes" xml:space="preserve">
          <source>Below is a map showing all types of subqueries allowed in the SQL language, and the optimizer strategies available to handle them.</source>
          <target state="translated">아래는 SQL 언어에서 허용되는 모든 하위 쿼리 유형과이를 처리하는 데 사용할 수있는 최적화 프로그램 전략을 보여주는 맵입니다.</target>
        </trans-unit>
        <trans-unit id="c17fb9405455301fe175e86b3ce7224a67ee4252" translate="yes" xml:space="preserve">
          <source>Below is an example in which a user attempts to execute an &lt;code&gt;UPDATE&lt;/code&gt; statement on a table for which he does not have permission:</source>
          <target state="translated">다음은 사용자 가 권한이없는 테이블 에서 &lt;code&gt;UPDATE&lt;/code&gt; 문 을 실행하려는 예입니다 .</target>
        </trans-unit>
        <trans-unit id="26ce3d7722b4f97cdd795f1588fac41a383306ac" translate="yes" xml:space="preserve">
          <source>Below is an example of a Recursive CTE:</source>
          <target state="translated">아래는 재귀 CTE의 예입니다.</target>
        </trans-unit>
        <trans-unit id="b9324c9dd9f8ffc341e687ad306c0809c3e99dde" translate="yes" xml:space="preserve">
          <source>Below is an example of a system log entry taken from a server which had &lt;a href=&quot;../mariadb-audit-plugin-system-variables/index#server_audit_syslog_ident&quot;&gt;server_audit_syslog_ident&lt;/a&gt; set to the default value of &lt;code&gt;mysql&amp;shy;-server_auditing&lt;/code&gt;, and &lt;a href=&quot;../mariadb-audit-plugin-system-variables/index#server_audit_syslog_info&quot;&gt;server_audit_syslog_info&lt;/a&gt; set to &lt;code&gt;&amp;lt;prod1&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">다음은 &lt;a href=&quot;../mariadb-audit-plugin-system-variables/index#server_audit_syslog_ident&quot;&gt;server_audit_syslog_ident&lt;/a&gt; 가 기본값 &lt;code&gt;mysql&amp;shy;-server_auditing&lt;/code&gt; &lt;a href=&quot;../mariadb-audit-plugin-system-variables/index#server_audit_syslog_info&quot;&gt;server_auditing으로&lt;/a&gt; 설정 되고 server_audit_syslog_info 가 &lt;code&gt;&amp;lt;prod1&amp;gt;&lt;/code&gt; 으로 설정된 서버에서 가져온 시스템 로그 항목의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="e3ce9a80635215be5cce2993f49d87f9c998d471" translate="yes" xml:space="preserve">
          <source>Below is an example of how &lt;code&gt;ITERATE&lt;/code&gt; might be used:</source>
          <target state="translated">아래는 &lt;code&gt;ITERATE&lt;/code&gt; 사용 방법의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="01e85273154318f27470d957d0d7f319a45b1ba7" translate="yes" xml:space="preserve">
          <source>Below is an example of how a user-defined variable may be set:</source>
          <target state="translated">아래는 사용자 정의 변수를 설정하는 방법의 예입니다.</target>
        </trans-unit>
        <trans-unit id="59b5b95f9ca3fc825c55caf981a0d7fefc5fa4a5" translate="yes" xml:space="preserve">
          <source>Below is an example of nested blocks in a stored procedure:</source>
          <target state="translated">다음은 저장 프로 시저에서 중첩 블록의 예입니다.</target>
        </trans-unit>
        <trans-unit id="019c36f613b600402d606b4e2b7f189256aafe92" translate="yes" xml:space="preserve">
          <source>Below is an example using &lt;code&gt;DECLARE HANDLER&lt;/code&gt;:</source>
          <target state="translated">다음은 &lt;code&gt;DECLARE HANDLER&lt;/code&gt; 를 사용하는 예입니다 .</target>
        </trans-unit>
        <trans-unit id="a5d427a86e9e780fc6bed7de50427f7b79142b0e" translate="yes" xml:space="preserve">
          <source>Below is an example using a simple label that is used to exit a &lt;a href=&quot;../loop/index&quot;&gt;LOOP&lt;/a&gt;:</source>
          <target state="translated">다음은 &lt;a href=&quot;../loop/index&quot;&gt;LOOP&lt;/a&gt; 를 종료하는 데 사용되는 간단한 레이블을 사용하는 예입니다 .</target>
        </trans-unit>
        <trans-unit id="822633c790908a37000e58b55f9306fd47452090" translate="yes" xml:space="preserve">
          <source>Below is an example with both &lt;code&gt;TABLE&lt;/code&gt; and &lt;code&gt;QUERY&lt;/code&gt; events logging. For this scenario, suppose there is a &lt;a href=&quot;../create-view/index&quot;&gt;VIEW&lt;/a&gt; in which columns are selected from a few tables in a &lt;code&gt;company&lt;/code&gt; database. The underlying tables are related to sensitive employee information, in particular salaries. Although we may have taken precautions to ensure that only certain user accounts have access to those tables, we will monitor the Audit Plugin logs for anyone who queries them&amp;mdash;directly or indirectly through a view.</source>
          <target state="translated">아래는 &lt;code&gt;TABLE&lt;/code&gt; 및 &lt;code&gt;QUERY&lt;/code&gt; 이벤트 로깅 이 모두 포함 된 예입니다 . 이 시나리오에서는 &lt;code&gt;company&lt;/code&gt; 데이터베이스 의 일부 테이블에서 열을 선택 하는 &lt;a href=&quot;../create-view/index&quot;&gt;VIEW&lt;/a&gt; 가 있다고 가정하십시오 . 기본 테이블은 민감한 직원 정보, 특히 급여와 관련이 있습니다. 특정 사용자 계정 만 해당 테이블에 액세스 할 수 있도록주의를 기울 였지만 뷰를 통해 직접 또는 간접적으로 쿼리하는 사람에 대해 감사 플러그인 로그를 모니터링합니다.</target>
        </trans-unit>
        <trans-unit id="64cf5bb4e6c35f967a6275f2ca3255aedf45be14" translate="yes" xml:space="preserve">
          <source>Below is an example with the &lt;code&gt;WITH&lt;/code&gt; at the top level:</source>
          <target state="translated">다음은 &lt;code&gt;WITH&lt;/code&gt; 레벨이 최상위에 있는 예입니다 .</target>
        </trans-unit>
        <trans-unit id="646dac2166904f4dab5bfc6723f18393fab44c59" translate="yes" xml:space="preserve">
          <source>Below, change /usr/local to the directory of your choice.</source>
          <target state="translated">아래에서 / usr / local을 선택한 디렉토리로 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="617c4ca8be436d0c4dcee302969d8e1c72dae8b1" translate="yes" xml:space="preserve">
          <source>Benchmark Results</source>
          <target state="translated">벤치 마크 결과</target>
        </trans-unit>
        <trans-unit id="6f3b2ca2746598a5c0c336c60d7f1e5542f3b64a" translate="yes" xml:space="preserve">
          <source>Benchmarking</source>
          <target state="translated">Benchmarking</target>
        </trans-unit>
        <trans-unit id="31d75f1568e21787409734dda65a982ecdd3e0fd" translate="yes" xml:space="preserve">
          <source>Benchmarking Aria</source>
          <target state="translated">벤치마킹 아리아</target>
        </trans-unit>
        <trans-unit id="a24eb23296db9be46c123c4b7ece3b6965790aaa" translate="yes" xml:space="preserve">
          <source>Benchmarks for Spider</source>
          <target state="translated">거미에 대한 벤치 마크</target>
        </trans-unit>
        <trans-unit id="3bec6862951a4155095c5aa635a23d57c13442a6" translate="yes" xml:space="preserve">
          <source>Benchmarks, etc, by Karthik Appigatla</source>
          <target state="translated">Karthik Appigatla의 벤치 마크 등</target>
        </trans-unit>
        <trans-unit id="927f40673764a27aad14fdedb385b31e3b85f976" translate="yes" xml:space="preserve">
          <source>Benefits</source>
          <target state="translated">Benefits</target>
        </trans-unit>
        <trans-unit id="062b06ba8e755765c6b049809b7430fd54fe5b21" translate="yes" xml:space="preserve">
          <source>Berlin</source>
          <target state="translated">Berlin</target>
        </trans-unit>
        <trans-unit id="1e1644805c249dee03818d0fa4c38ce84d0c4580" translate="yes" xml:space="preserve">
          <source>Bernadac</source>
          <target state="translated">Bernadac</target>
        </trans-unit>
        <trans-unit id="e77d4d8057e8d99379dd691fb53a79a0971753cc" translate="yes" xml:space="preserve">
          <source>Bernard</source>
          <target state="translated">Bernard</target>
        </trans-unit>
        <trans-unit id="249d5e08fdce66e71b04f2345bb22c53391566d9" translate="yes" xml:space="preserve">
          <source>Bertrand</source>
          <target state="translated">Bertrand</target>
        </trans-unit>
        <trans-unit id="2a2e1dd1bf064a8c6cd0b61f2e53459c6cae4d61" translate="yes" xml:space="preserve">
          <source>Besides automatic password expiry, as determined by &lt;a href=&quot;../server-system-variables/index#default_password_lifetime&quot;&gt;default_password_lifetime&lt;/a&gt;, password expiry times can be set on an individual user basis, overriding the global setting, for example:</source>
          <target state="translated">&lt;a href=&quot;../server-system-variables/index#default_password_lifetime&quot;&gt;default_password_lifetime&lt;/a&gt; 에 의해 결정된 자동 비밀번호 만기 외에 , 비밀번호 만기 시간을 개별 사용자별로 설정하여 글로벌 설정을 대체 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e36b5ec11caf6b04df95115354f8615fd0196bf8" translate="yes" xml:space="preserve">
          <source>Besides automatic password expiry, as determined by &lt;a href=&quot;../server-system-variables/index#default_password_lifetime&quot;&gt;default_password_lifetime&lt;/a&gt;, password expiry times can be set on an individual user basis, overriding the global using the &lt;a href=&quot;../create-user/index&quot;&gt;CREATE USER&lt;/a&gt; or &lt;a href=&quot;../alter-user/index&quot;&gt;ALTER USER&lt;/a&gt; statements, for example:</source>
          <target state="translated">&lt;a href=&quot;../server-system-variables/index#default_password_lifetime&quot;&gt;default_password_lifetime&lt;/a&gt; 에 의해 판별 된 자동 비밀번호 만기 외에 , &lt;a href=&quot;../create-user/index&quot;&gt;CREATE USER&lt;/a&gt; 또는 &lt;a href=&quot;../alter-user/index&quot;&gt;ALTER USER&lt;/a&gt; 문을 사용 하여 글로벌을 대체하여 비밀번호 만기 시간을 개별 사용자별로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8b64d8f4dcbe42513dae96f78af6fbdd9e822bb1" translate="yes" xml:space="preserve">
          <source>Besides test and result files, many other files that affect the testing process in mysql-test</source>
          <target state="translated">테스트 및 결과 파일 외에도 mysql-test의 테스트 프로세스에 영향을 미치는 다른 많은 파일</target>
        </trans-unit>
        <trans-unit id="891083d7894d5ba0da971b013e9e740aaabdb6b4" translate="yes" xml:space="preserve">
          <source>Besides this, RocksDB has its own (low-level) log in &lt;code&gt;#rocksdb/LOG&lt;/code&gt; file.</source>
          <target state="translated">이 외에도 RocksDB에는 &lt;code&gt;#rocksdb/LOG&lt;/code&gt; 파일에 자체 (낮은 수준) 로그가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e065ce9d22426561a553df30c33bc1f62660139" translate="yes" xml:space="preserve">
          <source>Best/required practices when using Galera for High-availability</source>
          <target state="translated">고 가용성을 위해 Galera를 사용할 때 모범 / 필수 사례</target>
        </trans-unit>
        <trans-unit id="f03b60f7e52b7ce49ed1e4f9fa511c452a2185bb" translate="yes" xml:space="preserve">
          <source>Beta</source>
          <target state="translated">Beta</target>
        </trans-unit>
        <trans-unit id="899fa7dd429389d61cb5e59d261c70c39260d24f" translate="yes" xml:space="preserve">
          <source>Beth</source>
          <target state="translated">Beth</target>
        </trans-unit>
        <trans-unit id="283ae842a6a4c1acf316da343c58318b3f082b2f" translate="yes" xml:space="preserve">
          <source>Better INDEX? No. You must get away from reading the entire table to get the 5000th page.</source>
          <target state="translated">더 나은 INDEX? 아니요. 5000 번째 페이지를 얻으려면 전체 테이블을 읽지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="0fa7861e7ce5fb97f64405655a15e20477eb3bfc" translate="yes" xml:space="preserve">
          <source>Better blob handling (than is currently offered in MyISAM, at a minimum).</source>
          <target state="translated">더 나은 얼룩 처리 (최소한 현재 MyISAM에서 제공되는 것보다).</target>
        </trans-unit>
        <trans-unit id="0207ed5047bf2756799b0dfff095e6fd24c58bf5" translate="yes" xml:space="preserve">
          <source>Better hardware is one of the easiest ways to improve performance.</source>
          <target state="translated">더 나은 하드웨어는 성능을 향상시키는 가장 쉬운 방법 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="94b0af315afdef640c0a11145d045b4c30b46b25" translate="yes" xml:space="preserve">
          <source>Better is this...</source>
          <target state="translated">이게 더 나아요 ...</target>
        </trans-unit>
        <trans-unit id="5c5af66748927fa7d37af6d0d5f3c68c8ee2fa2d" translate="yes" xml:space="preserve">
          <source>Better performance with hardware improvements</source>
          <target state="translated">하드웨어 개선으로 성능 향상</target>
        </trans-unit>
        <trans-unit id="0e9cd5f312708f8682bcd814137d34101581b5b1" translate="yes" xml:space="preserve">
          <source>Better practice, and the default in most situations, is to use a separate user, exclusively used for MariaDB. In most distributions, this user is called &lt;code&gt;mysql&lt;/code&gt;.</source>
          <target state="translated">더 나은 방법과 대부분의 경우 기본값은 MariaDB 전용으로 사용되는 별도의 사용자를 사용하는 것입니다. 대부분의 배포에서이 사용자는 &lt;code&gt;mysql&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="99e1d70edc03b63c90a0a0f6b7494e965fa89c66" translate="yes" xml:space="preserve">
          <source>Between &lt;a href=&quot;../tinyint/index&quot;&gt;TINYINT&lt;/a&gt;, &lt;a href=&quot;../smallint/index&quot;&gt;SMALLINT&lt;/a&gt;, &lt;a href=&quot;../mediumint/index&quot;&gt;MEDIUMINT&lt;/a&gt;, &lt;a href=&quot;../int/index&quot;&gt;INT&lt;/a&gt; and &lt;a href=&quot;../bigint/index&quot;&gt;BIGINT&lt;/a&gt;. If lossy conversion is supported, the value from the master will be converted to the maximum or minimum permitted on the slave, which non-lossy conversions require the slave column to be large enough. For example, SMALLINT UNSIGNED can be converted to MEDIUMINT, but not SMALLINT SIGNED.</source>
          <target state="translated">사이 &lt;a href=&quot;../tinyint/index&quot;&gt;TINYINT&lt;/a&gt; , &lt;a href=&quot;../smallint/index&quot;&gt;SMALLINT&lt;/a&gt; , &lt;a href=&quot;../mediumint/index&quot;&gt;MEDIUMINT&lt;/a&gt; , &lt;a href=&quot;../int/index&quot;&gt;INT&lt;/a&gt; 와 &lt;a href=&quot;../bigint/index&quot;&gt;BIGINT&lt;/a&gt; . 손실 변환이 지원되는 경우 마스터의 값은 슬레이브에서 허용되는 최대 값 또는 최소값으로 변환되며, 손실이없는 변환은 슬레이브 열이 충분히 커야합니다. 예를 들어, SMALLINT UNSIGNED는 MEDIUMINT로 변환 할 수 있지만 SMALLINT SIGNED는 변환 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6890f0a43f6198b09f941de7b982ccbeea76b70a" translate="yes" xml:space="preserve">
          <source>Between major releases, there are often substantial changes, even if none of the new features are used. For example, both &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt; and &lt;a href=&quot;../what-is-mariadb-103/index&quot;&gt;MariaDB 10.3&lt;/a&gt; introduce new versions of the redo log.</source>
          <target state="translated">주요 릴리스 간에는 새로운 기능이 사용되지 않더라도 상당한 변경이 이루어집니다. 예를 들어 &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt; 와 &lt;a href=&quot;../what-is-mariadb-103/index&quot;&gt;MariaDB 10.3&lt;/a&gt; 모두 새로운 버전의 리두 로그를 도입합니다.</target>
        </trans-unit>
        <trans-unit id="02fd6c3df61aa563ff83131c77eb574d27da9d0a" translate="yes" xml:space="preserve">
          <source>Between major versions of MariaDB various options supported by &lt;code&gt;OLD_MODE&lt;/code&gt; may be removed. This is intentional as we assume that the application will be fixed to conform with the new MariaDB behavior between releases.</source>
          <target state="translated">주요 버전의 MariaDB 사이에서 &lt;code&gt;OLD_MODE&lt;/code&gt; 가 지원하는 다양한 옵션 이 제거 될 수 있습니다. 이는 릴리스 간 새로운 MariaDB 동작에 맞게 응용 프로그램이 수정 될 것이라고 가정하기 때문에 의도적 인 것입니다.</target>
        </trans-unit>
        <trans-unit id="2f24290eac61990d26646fa90d7194e7765cd4f0" translate="yes" xml:space="preserve">
          <source>Between the hardware and MariaDB sits the operating system, and there are a number of optimizations that can be made at this level</source>
          <target state="translated">하드웨어와 MariaDB 사이에는 운영 체제가 있으며이 수준에서 수행 할 수있는 여러 가지 최적화가 있습니다.</target>
        </trans-unit>
        <trans-unit id="33e1c49aec3eed46501b535a9e915c26d8f1c65f" translate="yes" xml:space="preserve">
          <source>Beware of Proxies that try to implement a &quot;read/write split&quot;. In some situations, a reference to LAST_INSERT_ID() will be sent to a &quot;Slave&quot;.</source>
          <target state="translated">&quot;읽기 / 쓰기 분할&quot;을 구현하려는 프록시에주의하십시오. 경우에 따라 LAST_INSERT_ID ()에 대한 참조가 &quot;슬레이브&quot;로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="dc5d801e981fe70c53d255bab29bbc2a3a6951fb" translate="yes" xml:space="preserve">
          <source>Beware that &lt;code&gt;DROP TABLE&lt;/code&gt; can drop both tables and &lt;a href=&quot;../create-sequence/index&quot;&gt;sequences&lt;/a&gt;. This is mainly done to allow old tools like &lt;a href=&quot;../mysqldump/index&quot;&gt;mysqldump&lt;/a&gt; to work with sequences.</source>
          <target state="translated">조심하십시오 &lt;code&gt;DROP TABLE&lt;/code&gt; 은 테이블을 모두 삭제할 수 있습니다 &lt;a href=&quot;../create-sequence/index&quot;&gt;시퀀스를&lt;/a&gt; . 이것은 주로 &lt;a href=&quot;../mysqldump/index&quot;&gt;mysqldump&lt;/a&gt; 와 같은 오래된 도구 가 시퀀스와 작동하도록하기 위해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="eda6cb74369b0fce31775aa82d862094826f1d7a" translate="yes" xml:space="preserve">
          <source>Beware that the database name in the URL can be interpreted differently depending on the DBMS. For MySQL this is the schema in which the tables are found. However, for Postgresql, this is the catalog and the schema must be specified using the CONNECT dbname option.</source>
          <target state="translated">URL의 데이터베이스 이름은 DBMS에 따라 다르게 해석 될 수 있습니다. MySQL의 경우 이는 테이블이있는 스키마입니다. 그러나 Postgresql의 경우 이는 카탈로그이며 CONNECT dbname 옵션을 사용하여 스키마를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="9b60be54a5e635e9cbd5c300463c5c02e53495b0" translate="yes" xml:space="preserve">
          <source>Beyond 100, you may be interfering replication and SELECTs.</source>
          <target state="translated">100을 넘어 서면 복제 및 SELECT를 방해 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e9e898c6592a8c20a82ed75b471cab220856358" translate="yes" xml:space="preserve">
          <source>Beyond 1000, you are into diminishing returns -- virtually no further performance gains.</source>
          <target state="translated">1000을 넘어 서면 더 이상 수익을 잃게되며 사실상 더 이상의 성능 향상은 없습니다.</target>
        </trans-unit>
        <trans-unit id="0f89f14acd1f158846677f70f3896433a8ceb874" translate="yes" xml:space="preserve">
          <source>Bias -- some rows are more like to be fetched than others.</source>
          <target state="translated">바이어스-일부 행은 다른 행보다 가져 오는 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e8289525a58114578e603905b18c82b91e31c29" translate="yes" xml:space="preserve">
          <source>Big DELETEs</source>
          <target state="translated">큰 삭제</target>
        </trans-unit>
        <trans-unit id="d23c6f8e92826595c5b2e7e63e9f11e79eda104b" translate="yes" xml:space="preserve">
          <source>Big Query Settings</source>
          <target state="translated">큰 쿼리 설정</target>
        </trans-unit>
        <trans-unit id="939f6674aaf831c3b342977c0709ec61d3497914" translate="yes" xml:space="preserve">
          <source>Big Reads</source>
          <target state="translated">큰 읽기</target>
        </trans-unit>
        <trans-unit id="79a89d741118168032c17b081a4dcbce35a35363" translate="yes" xml:space="preserve">
          <source>Big dump of data once an hour, versus continual stream of records.</source>
          <target state="translated">지속적인 레코드 스트림과 비교하여 한 시간에 한 번 큰 데이터 덤프.</target>
        </trans-unit>
        <trans-unit id="56b75fc2dc3ac3b11e4251806a119739d6d32c18" translate="yes" xml:space="preserve">
          <source>Big file tables</source>
          <target state="translated">큰 파일 테이블</target>
        </trans-unit>
        <trans-unit id="58e8a3e5e0d274a1d22a274c0e3376d740989028" translate="yes" xml:space="preserve">
          <source>Big integer (8 bytes)</source>
          <target state="translated">큰 정수 (8 바이트)</target>
        </trans-unit>
        <trans-unit id="9aba8c0c53d36cacdb815612ebd453fc72be67c8" translate="yes" xml:space="preserve">
          <source>Big5 Traditional Chinese</source>
          <target state="translated">Big5 중국어 번체</target>
        </trans-unit>
        <trans-unit id="5514dfc6fc8547c66e3e6f08e1279f0ae358c49c" translate="yes" xml:space="preserve">
          <source>Bigint(&lt;em&gt;n&lt;/em&gt;)</source>
          <target state="translated">Bigint(&lt;em&gt;n&lt;/em&gt;)</target>
        </trans-unit>
        <trans-unit id="3d7346140016dfa40c770fa19ba722af2eb48073" translate="yes" xml:space="preserve">
          <source>Bill</source>
          <target state="translated">Bill</target>
        </trans-unit>
        <trans-unit id="66639f7d455dd71faa9147f5d69e5ce885d8bebd" translate="yes" xml:space="preserve">
          <source>Binary</source>
          <target state="translated">Binary</target>
        </trans-unit>
        <trans-unit id="a85f3ff965cc3e9dfdb2d5c3cced1e972ccb75ff" translate="yes" xml:space="preserve">
          <source>Binary (string)</source>
          <target state="translated">이진 (문자열)</target>
        </trans-unit>
        <trans-unit id="3965b1b1a3bc13bcffdab7b800f780f4d4c307aa" translate="yes" xml:space="preserve">
          <source>Binary Json array</source>
          <target state="translated">이진 Json 배열</target>
        </trans-unit>
        <trans-unit id="69bf89f03b1d348057bb1c3c509bac8c26ec4135" translate="yes" xml:space="preserve">
          <source>Binary Literals</source>
          <target state="translated">이진 리터럴</target>
        </trans-unit>
        <trans-unit id="9763147003aaa4c5891942ebd3b72db5fef5c1ac" translate="yes" xml:space="preserve">
          <source>Binary Log</source>
          <target state="translated">이진 로그</target>
        </trans-unit>
        <trans-unit id="805627f196b273c66872b6d0657a879c3a08ba09" translate="yes" xml:space="preserve">
          <source>Binary Log Dump Thread</source>
          <target state="translated">이진 로그 덤프 스레드</target>
        </trans-unit>
        <trans-unit id="2234299eefcc1999497b4d508531973ea7dfa8cc" translate="yes" xml:space="preserve">
          <source>Binary Log Dump Threads and the Shutdown Process</source>
          <target state="translated">이진 로그 덤프 스레드 및 종료 프로세스</target>
        </trans-unit>
        <trans-unit id="dc02966ddcb230fc990cc810f1ba7c15954ef177" translate="yes" xml:space="preserve">
          <source>Binary Log Filter Options</source>
          <target state="translated">이진 로그 필터 옵션</target>
        </trans-unit>
        <trans-unit id="de7dfd2e30bd42785ca276436301bca6b2e0e01c" translate="yes" xml:space="preserve">
          <source>Binary Log Filters for Replication Masters</source>
          <target state="translated">복제 마스터를위한 이진 로그 필터</target>
        </trans-unit>
        <trans-unit id="e9924d717d86344f1b58260b31833a44a2ec303b" translate="yes" xml:space="preserve">
          <source>Binary Log Format</source>
          <target state="translated">이진 로그 형식</target>
        </trans-unit>
        <trans-unit id="2b1fdbfe8be84085807f4ecbf25354a2b5fe8429" translate="yes" xml:space="preserve">
          <source>Binary Log Formats</source>
          <target state="translated">이진 로그 형식</target>
        </trans-unit>
        <trans-unit id="a7dbbd316fb08236bc20c10fdfcc7b2220dc48d6" translate="yes" xml:space="preserve">
          <source>Binary Log Group Commit and InnoDB Flushing Performance</source>
          <target state="translated">이진 로그 그룹 커밋 및 InnoDB 플러싱 성능</target>
        </trans-unit>
        <trans-unit id="a459c873fc1fbc3ecc9287f041200c1e48d3ceec" translate="yes" xml:space="preserve">
          <source>Binary Log Group Commit and Redo Log Flushing</source>
          <target state="translated">이진 로그 그룹 커밋 및 다시 실행 로그 플러싱</target>
        </trans-unit>
        <trans-unit id="7666e685235bc0e8f9680f5ee5e86afc652af8cd" translate="yes" xml:space="preserve">
          <source>Binary Log Options</source>
          <target state="translated">이진 로그 옵션</target>
        </trans-unit>
        <trans-unit id="e7cc39aaa624835df4441ac1b2e58ccb5ea9a667" translate="yes" xml:space="preserve">
          <source>Binary Log Position</source>
          <target state="translated">이진 로그 위치</target>
        </trans-unit>
        <trans-unit id="e5d30086bf4a991f53984263438595603c786650" translate="yes" xml:space="preserve">
          <source>Binary Log-Based Transaction Coordinator Log</source>
          <target state="translated">이진 로그 기반 트랜잭션 코디네이터 로그</target>
        </trans-unit>
        <trans-unit id="16b69e89f0c0db6f7e27861eb16c24ca9eee969d" translate="yes" xml:space="preserve">
          <source>Binary Logging of Stored Routines</source>
          <target state="translated">저장된 루틴의 이진 로깅</target>
        </trans-unit>
        <trans-unit id="69664ef2502ea11a3179b5524439bda116286668" translate="yes" xml:space="preserve">
          <source>Binary Logs</source>
          <target state="translated">이진 로그</target>
        </trans-unit>
        <trans-unit id="796fc83f8f04565e28ca278841b0df4cf60115cf" translate="yes" xml:space="preserve">
          <source>Binary Source Import</source>
          <target state="translated">이진 소스 가져 오기</target>
        </trans-unit>
        <trans-unit id="5da21d49be0dc8ef6cce85285e9f334c56e89ac2" translate="yes" xml:space="preserve">
          <source>Binary data information</source>
          <target state="translated">이진 데이터 정보</target>
        </trans-unit>
        <trans-unit id="79a58bfc1ee518341a4cf60b5f42223cda7fd348" translate="yes" xml:space="preserve">
          <source>Binary file organized in vectors, in which column values are grouped consecutively, either split in separate files or in a unique file.</source>
          <target state="translated">벡터로 구성된 이진 파일로, 열 값이 연속적으로 그룹화되어 별도의 파일 또는 고유 파일로 분할됩니다.</target>
        </trans-unit>
        <trans-unit id="11bb56e1c5f3e6eff267ead07bea1653d188d946" translate="yes" xml:space="preserve">
          <source>Binary file with numeric values in platform representation, also with columns at fixed offset within records and fixed record length.</source>
          <target state="translated">플랫폼 표현의 숫자 값을 가진 이진 파일과 레코드 내 고정 오프셋의 열 및 고정 레코드 길이.</target>
        </trans-unit>
        <trans-unit id="3664af03b4962f9d3cdb6719d3d0647dcc090bc4" translate="yes" xml:space="preserve">
          <source>Binary geometry implementation. Always 1 in MariaDB.</source>
          <target state="translated">이진 기하학 구현. MariaDB에서는 항상 1입니다.</target>
        </trans-unit>
        <trans-unit id="5bdcb11fa4e9c7f026de8dbb656709c094967b6c" translate="yes" xml:space="preserve">
          <source>Binary large object data types and the corresponding TEXT types.</source>
          <target state="translated">이진 큰 개체 데이터 형식과 해당 TEXT 형식</target>
        </trans-unit>
        <trans-unit id="8a220869c2ec0e31e0093abd6380bfdb6378b9c9" translate="yes" xml:space="preserve">
          <source>Binary large object up to 65,535 bytes.</source>
          <target state="translated">최대 65,535 바이트의 이진 큰 객체.</target>
        </trans-unit>
        <trans-unit id="10a0f05e800a9d80743fbacd32cee00260aad35d" translate="yes" xml:space="preserve">
          <source>Binary literals</source>
          <target state="translated">이진 리터럴</target>
        </trans-unit>
        <trans-unit id="b453fd9726b2b74276211ee9a817519cabe6a81b" translate="yes" xml:space="preserve">
          <source>Binary literals are interpreted as binary strings, and is convenient to represent &lt;code&gt;&lt;a href=&quot;../varbinary/index&quot;&gt;VARBINARY&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../binary/index&quot;&gt;BINARY&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../bit/index&quot;&gt;BIT&lt;/a&gt;&lt;/code&gt; values.</source>
          <target state="translated">이진 리터럴은 이진 문자열로 해석되며 &lt;code&gt;&lt;a href=&quot;../varbinary/index&quot;&gt;VARBINARY&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../binary/index&quot;&gt;BINARY&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../bit/index&quot;&gt;BIT&lt;/a&gt;&lt;/code&gt; 값 을 나타내는 데 편리 합니다.</target>
        </trans-unit>
        <trans-unit id="3692d36bf3c8302777bced16d9b525abde445158" translate="yes" xml:space="preserve">
          <source>Binary literals can be written in one of the following formats</source>
          <target state="translated">이진 리터럴은 다음 형식 중 하나로 쓸 수 있습니다</target>
        </trans-unit>
        <trans-unit id="749b59a635145f5abd13a05ed4c88ad70deeb5b1" translate="yes" xml:space="preserve">
          <source>Binary literals can be written in one of the following formats: &lt;code&gt;b'value'&lt;/code&gt;, &lt;code&gt;B'value'&lt;/code&gt; or &lt;code&gt;0bvalue&lt;/code&gt;, where &lt;code&gt;value&lt;/code&gt; is a string composed by &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt; digits.</source>
          <target state="translated">이진 리터럴은 &lt;code&gt;b'value'&lt;/code&gt; , &lt;code&gt;B'value'&lt;/code&gt; 또는 &lt;code&gt;0bvalue&lt;/code&gt; 형식 중 하나로 쓸 수 있습니다. 여기서 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;0&lt;/code&gt; 과 &lt;code&gt;1&lt;/code&gt; 자리 로 구성된 문자열 입니다.</target>
        </trans-unit>
        <trans-unit id="db9ec03f8a14733c706084b805695a77ddbe41bc" translate="yes" xml:space="preserve">
          <source>Binary log files are mainly used by replication and can also be used with &lt;a href=&quot;../mysqlbinlog/index&quot;&gt;mysqlbinlog&lt;/a&gt; to apply on a backup to get the database up to date.</source>
          <target state="translated">이진 로그 파일은 주로 복제에 사용되며 &lt;a href=&quot;../mysqlbinlog/index&quot;&gt;mysqlbinlog&lt;/a&gt; 와 함께 사용 하여 백업을 적용하여 데이터베이스를 최신 상태로 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d90e68290cc3d4f0dede9c81b9e3e33bcb6360c5" translate="yes" xml:space="preserve">
          <source>Binary log-based transaction coordinator log</source>
          <target state="translated">이진 로그 기반 트랜잭션 코디네이터 로그</target>
        </trans-unit>
        <trans-unit id="ef2ebd70ba6ea7eb9b4c5c81b0b946d97daf3377" translate="yes" xml:space="preserve">
          <source>Binary logging and replication forbid changing the global server %s</source>
          <target state="translated">이진 로깅 및 복제로 글로벌 서버 % s을 (를) 변경할 수 없음</target>
        </trans-unit>
        <trans-unit id="f6e1403892fa3c440be9d49b10ee6b9739f3b705" translate="yes" xml:space="preserve">
          <source>Binary logging can be row-based, statement-based, or a mix of the two. See &lt;a href=&quot;../binary-log-formats/index&quot;&gt;Binary Log Formats&lt;/a&gt; for more details on the formats. If logging is statement-based, it is possible that a statement will have different effects on the master and on the slave.</source>
          <target state="translated">이진 로깅은 행 기반, 명령문 기반 또는이 둘의 혼합 일 수 있습니다. &lt;a href=&quot;../binary-log-formats/index&quot;&gt;형식에&lt;/a&gt; 대한 자세한 내용 은 이진 로그 형식 을 참조하십시오. 로깅이 명령문 기반 인 경우 명령문이 마스터 및 슬레이브에 다른 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58101d1324645c6bcbff6d57f0fc51048ef85cee" translate="yes" xml:space="preserve">
          <source>Binary logging not possible. Message: %s</source>
          <target state="translated">이진 로깅이 불가능합니다. 메시지 : % s</target>
        </trans-unit>
        <trans-unit id="106be2a0d1cac0ea122ea66b41c22b3b7c5d28fd" translate="yes" xml:space="preserve">
          <source>Binary logs</source>
          <target state="translated">이진 로그</target>
        </trans-unit>
        <trans-unit id="4defd7e40b36c9588347730e60d2214392dba0bd" translate="yes" xml:space="preserve">
          <source>Binary logs are stored in a binary, not plain text, format, and so are not viewable with a regular editor. However, MariaDB includes &lt;a href=&quot;../mysqlbinlog/index&quot;&gt;mysqlbinlog&lt;/a&gt;, a commandline tool for plain text processing of binary logs.</source>
          <target state="translated">이진 로그는 일반 텍스트가 아닌 이진으로 저장되므로 일반 편집기로는 볼 수 없습니다. 그러나 MariaDB에는 이진 로그의 일반 텍스트 처리를위한 명령 줄 도구 인 &lt;a href=&quot;../mysqlbinlog/index&quot;&gt;mysqlbinlog가&lt;/a&gt; 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a3cf770fb5904a46016f83a22e64e5ce8d83d3e" translate="yes" xml:space="preserve">
          <source>Binary pseudo charset</source>
          <target state="translated">이진 의사 문자셋</target>
        </trans-unit>
        <trans-unit id="11610f16278b452d4d96af56b10f6af736d8a365" translate="yes" xml:space="preserve">
          <source>Binary value of the InnoDB precise type, representing the data type, character set code and nullability.</source>
          <target state="translated">데이터 유형, 문자 세트 코드 및 널 입력 가능성을 나타내는 InnoDB 정확한 유형의 이진 값입니다.</target>
        </trans-unit>
        <trans-unit id="36487394a6bd2d8e83e177961f6d830ad31d5d5c" translate="yes" xml:space="preserve">
          <source>Binlog Dump</source>
          <target state="translated">빈 로그 덤프</target>
        </trans-unit>
        <trans-unit id="26fa84588c5c5480bcb4c91f58f81620da67d26a" translate="yes" xml:space="preserve">
          <source>Binlog Event Checksum Interoperability</source>
          <target state="translated">Binlog 이벤트 체크섬 상호 운용성</target>
        </trans-unit>
        <trans-unit id="50d1ef7a1fb565b94b4b207f390b61b68e65b28c" translate="yes" xml:space="preserve">
          <source>Binlog Event Checksums</source>
          <target state="translated">Binlog 이벤트 체크섬</target>
        </trans-unit>
        <trans-unit id="3780f8b49c05f62eecf3750326c7fa84fb018312" translate="yes" xml:space="preserve">
          <source>Binlog Position in information_schema.rocksdb_global_info</source>
          <target state="translated">information_schema.rocksdb_global_info의 Binlog 위치</target>
        </trans-unit>
        <trans-unit id="7e81dca8bd4bfd6961aed307aaa86c37e21bf8a8" translate="yes" xml:space="preserve">
          <source>Binlog closed, cannot RESET MASTER</source>
          <target state="translated">빈 로그가 닫히고 마스터를 재설정 할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="aa6a88dc3426f1d86dcc549182733699d2c2ae2c" translate="yes" xml:space="preserve">
          <source>Binlog events can be compressed to save space on disk and in network transfers</source>
          <target state="translated">디스크 및 네트워크 전송 공간을 절약하기 위해 Binlog 이벤트를 압축 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="b8a9c26c7cc7cb9be46d2a98edb3a81dcb0892b3" translate="yes" xml:space="preserve">
          <source>Binlog_bytes_written</source>
          <target state="translated">Binlog_bytes_written</target>
        </trans-unit>
        <trans-unit id="d77c776a4251b2c4aec42aec1769053748972daf" translate="yes" xml:space="preserve">
          <source>Binlog_cache_disk_use</source>
          <target state="translated">Binlog_cache_disk_use</target>
        </trans-unit>
        <trans-unit id="5f77becbfc0768f2c8ee37ae350d8a0e0c2234bf" translate="yes" xml:space="preserve">
          <source>Binlog_cache_use</source>
          <target state="translated">Binlog_cache_use</target>
        </trans-unit>
        <trans-unit id="f9dd46b10c9282cc7fae96c7e058bc591675c26c" translate="yes" xml:space="preserve">
          <source>Binlog_commits</source>
          <target state="translated">Binlog_commits</target>
        </trans-unit>
        <trans-unit id="ea1d86d86caf1990716b6f8900d3595d49a7b09f" translate="yes" xml:space="preserve">
          <source>Binlog_commits= 10K</source>
          <target state="translated">Binlog_commits = 10K</target>
        </trans-unit>
        <trans-unit id="bf312457ffa45d00c84f9d8cf5fbc9b029191f9e" translate="yes" xml:space="preserve">
          <source>Binlog_commits=10K</source>
          <target state="translated">Binlog_commits=10K</target>
        </trans-unit>
        <trans-unit id="bed08892eef8cadb3585ed5e81e840ade052ec86" translate="yes" xml:space="preserve">
          <source>Binlog_group_commit_trigger_count</source>
          <target state="translated">Binlog_group_commit_trigger_count</target>
        </trans-unit>
        <trans-unit id="d50297ffdd1f7e478eabe66580def24cabb474b7" translate="yes" xml:space="preserve">
          <source>Binlog_group_commit_trigger_lock_wait</source>
          <target state="translated">Binlog_group_commit_trigger_lock_wait</target>
        </trans-unit>
        <trans-unit id="5c79c2ca836edb4f3c753539c63076664a1f5260" translate="yes" xml:space="preserve">
          <source>Binlog_group_commit_trigger_timeout</source>
          <target state="translated">Binlog_group_commit_trigger_timeout</target>
        </trans-unit>
        <trans-unit id="1d106a413fae5331cffbef04c4400438171c1933" translate="yes" xml:space="preserve">
          <source>Binlog_group_commits</source>
          <target state="translated">Binlog_group_commits</target>
        </trans-unit>
        <trans-unit id="b564fc2c36bd0dbcb6a207e85162442657c1b23b" translate="yes" xml:space="preserve">
          <source>Binlog_group_commits=1403</source>
          <target state="translated">Binlog_group_commits=1403</target>
        </trans-unit>
        <trans-unit id="265417bccb24f56fe60d5240156030eff42b2547" translate="yes" xml:space="preserve">
          <source>Binlog_group_commits=794</source>
          <target state="translated">Binlog_group_commits=794</target>
        </trans-unit>
        <trans-unit id="17c959eeb285674c9a6b3c0586eb0d49124261a4" translate="yes" xml:space="preserve">
          <source>Binlog_snapshot_file</source>
          <target state="translated">Binlog_snapshot_file</target>
        </trans-unit>
        <trans-unit id="50c16f895036617ba197ecd7e4d05a8c3ae74e48" translate="yes" xml:space="preserve">
          <source>Binlog_snapshot_position</source>
          <target state="translated">Binlog_snapshot_position</target>
        </trans-unit>
        <trans-unit id="6ecc82816839b8df0c26147d88818954d92e7328" translate="yes" xml:space="preserve">
          <source>Binlog_stmt_cache_disk_use</source>
          <target state="translated">Binlog_stmt_cache_disk_use</target>
        </trans-unit>
        <trans-unit id="332092b44ff8a2acd0e74d927cc744e43474f22a" translate="yes" xml:space="preserve">
          <source>Binlog_stmt_cache_use</source>
          <target state="translated">Binlog_stmt_cache_use</target>
        </trans-unit>
        <trans-unit id="72d5f56a6a38fbe1ac61e593f9be58e9f6d1118c" translate="yes" xml:space="preserve">
          <source>Bistro Sk</source>
          <target state="translated">비스트로 Sk</target>
        </trans-unit>
        <trans-unit id="e8835c712451999e0a892ac12f5715c4350423b1" translate="yes" xml:space="preserve">
          <source>Bit</source>
          <target state="translated">Bit</target>
        </trans-unit>
        <trans-unit id="054d23b3a25072459d9beecced0ae3f918896afa" translate="yes" xml:space="preserve">
          <source>Bit Flag</source>
          <target state="translated">비트 플래그</target>
        </trans-unit>
        <trans-unit id="f984f557475643eeec3e25a3548b54d7adcd089a" translate="yes" xml:space="preserve">
          <source>Bit Functions and Operators</source>
          <target state="translated">비트 함수와 연산자</target>
        </trans-unit>
        <trans-unit id="1a19f1cc79ca53dfaaad0e37efe2b89aba8525ce" translate="yes" xml:space="preserve">
          <source>Bit containing the flag for NULL values. Empty if column cannot be NULL.</source>
          <target state="translated">NULL 값에 대한 플래그를 포함하는 비트. 열이 NULL 일 수 없으면 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7616b83bdb34db625a02415858b7d3182df92d8" translate="yes" xml:space="preserve">
          <source>Bit field type</source>
          <target state="translated">비트 필드 타입</target>
        </trans-unit>
        <trans-unit id="6ef619ec813da75a5665ad54c7165dacbee67df4" translate="yes" xml:space="preserve">
          <source>Bit fields are automatically zero-padded from the left to the full length of the bit, so for example in a BIT(4) field, '10' is equivalent to '0010'.</source>
          <target state="translated">비트 필드는 비트의 왼쪽에서 전체 길이까지 자동으로 0으로 채워 지므로 예를 들어 BIT (4) 필드에서 '10'은 '0010'과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bfda5378155545a53d75cf4ff6aa39735aa687b0" translate="yes" xml:space="preserve">
          <source>Bit flag providing information about the foreign key.</source>
          <target state="translated">외래 키에 대한 정보를 제공하는 비트 플래그.</target>
        </trans-unit>
        <trans-unit id="a116d675576347407f915e6f4d2a1d2e2108b65f" translate="yes" xml:space="preserve">
          <source>Bit values can be inserted with &lt;code&gt;b'value'&lt;/code&gt; notation, where &lt;code&gt;value&lt;/code&gt; is the bit value in 0's and 1's.</source>
          <target state="translated">비트 값은 &lt;code&gt;b'value'&lt;/code&gt; 표기법 으로 삽입 할 수 있습니다 . 여기서 &lt;code&gt;value&lt;/code&gt; 는 0과 1의 비트 값입니다.</target>
        </trans-unit>
        <trans-unit id="a36a25a1cccb68c7c87fcd879bbb216973e2de75" translate="yes" xml:space="preserve">
          <source>Bits</source>
          <target state="translated">Bits</target>
        </trans-unit>
        <trans-unit id="efe12f5dfdefd5e2ea49f6f84d65d60b2646be82" translate="yes" xml:space="preserve">
          <source>Bits are examined from right to left, (from low-order to high-order bits). Strings are added to the result from left to right, separated by a separator string (defaults as '&lt;code&gt;,&lt;/code&gt;'). You can optionally limit the number of bits the &lt;code&gt;EXPORT_SET()&lt;/code&gt; function examines using the &lt;code&gt;number_of_bits&lt;/code&gt; option.</source>
          <target state="translated">비트는 오른쪽에서 왼쪽으로 (낮은 순서에서 높은 순서로) 검사됩니다. 문자열은 왼쪽에서 오른쪽으로 결과에 추가되며 구분 기호 문자열로 구분됩니다 (기본값은 ' &lt;code&gt;,&lt;/code&gt; '). &lt;code&gt;number_of_bits&lt;/code&gt; 옵션을 사용하여 &lt;code&gt;EXPORT_SET()&lt;/code&gt; 함수가 검사하는 비트 수를 선택적으로 제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2570939f80f86dc66ccbd35540a8fad9b99c74af" translate="yes" xml:space="preserve">
          <source>Bits are returned as binary, so to display them, either add 0, or use a function such as &lt;a href=&quot;../hex/index&quot;&gt;HEX&lt;/a&gt;, &lt;a href=&quot;../oct/index&quot;&gt;OCT&lt;/a&gt; or &lt;a href=&quot;../bin/index&quot;&gt;BIN&lt;/a&gt; to convert them.</source>
          <target state="translated">비트는 이진수로 반환되므로 비트를 표시하거나 0을 추가하거나 &lt;a href=&quot;../hex/index&quot;&gt;HEX&lt;/a&gt; , &lt;a href=&quot;../oct/index&quot;&gt;OCT&lt;/a&gt; 또는 &lt;a href=&quot;../bin/index&quot;&gt;BIN&lt;/a&gt; 과 같은 함수를 사용 하여 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="17e80e5f71e9b85954b350f117d4dfeb3c5cf70a" translate="yes" xml:space="preserve">
          <source>Bitwise AND</source>
          <target state="translated">비트 AND</target>
        </trans-unit>
        <trans-unit id="ffba6db82603dad8914301fabc35b8806c66bd9d" translate="yes" xml:space="preserve">
          <source>Bitwise AND.</source>
          <target state="translated">비트 AND.</target>
        </trans-unit>
        <trans-unit id="560be194c3ede3724cb44764bbd59f30f25730d7" translate="yes" xml:space="preserve">
          <source>Bitwise AND. Converts the values to binary and compares bits. Only if both the corresponding bits are 1 is the resulting bit also 1.</source>
          <target state="translated">비트 AND. 값을 이진수로 변환하고 비트를 비교합니다. 해당 비트가 모두 1 인 경우에만 결과 비트도 1입니다.</target>
        </trans-unit>
        <trans-unit id="136c3a93310929e09124297eaf66ab9f3782d009" translate="yes" xml:space="preserve">
          <source>Bitwise NOT</source>
          <target state="translated">비트 단위 NOT</target>
        </trans-unit>
        <trans-unit id="8dbd981f89fc4b71891c8127dee59e1ed4da6b41" translate="yes" xml:space="preserve">
          <source>Bitwise NOT. Converts the value to 4 bytes binary and inverts all bits.</source>
          <target state="translated">비트 NOT. 값을 4 바이트 바이너리로 변환하고 모든 비트를 반전시킵니다.</target>
        </trans-unit>
        <trans-unit id="f4be0adcfa81c37e1e7bbf2e23630f30974d164f" translate="yes" xml:space="preserve">
          <source>Bitwise OR</source>
          <target state="translated">비트 OR</target>
        </trans-unit>
        <trans-unit id="f6cce76615b422f50d91d4d2e6ab10761c70e02d" translate="yes" xml:space="preserve">
          <source>Bitwise OR.</source>
          <target state="translated">비트 OR.</target>
        </trans-unit>
        <trans-unit id="c1d9aac29dff01fee03d80ddd6eb468c2985bcd0" translate="yes" xml:space="preserve">
          <source>Bitwise OR. Converts the values to binary and compares bits. If either of the corresponding bits has a value of 1, the resulting bit is also 1.</source>
          <target state="translated">비트 OR. 값을 이진수로 변환하고 비트를 비교합니다. 해당 비트 중 하나의 값이 1이면 결과 비트도 1입니다.</target>
        </trans-unit>
        <trans-unit id="74269e9a4eb117ac43a93ed74bc3c8cd96fd4ff4" translate="yes" xml:space="preserve">
          <source>Bitwise XOR</source>
          <target state="translated">비트 XOR</target>
        </trans-unit>
        <trans-unit id="208853b1399b38924467bde1a53c6b31b3f0d077" translate="yes" xml:space="preserve">
          <source>Bitwise XOR.</source>
          <target state="translated">비트 XOR.</target>
        </trans-unit>
        <trans-unit id="62e6800c7071d72a76bc41ecec995549dcde7b7a" translate="yes" xml:space="preserve">
          <source>Bitwise XOR. Converts the values to binary and compares bits. If one (and only one) of the corresponding bits is 1 is the resulting bit also 1.</source>
          <target state="translated">비트 XOR. 값을 이진수로 변환하고 비트를 비교합니다. 해당 비트 중 하나 (및 하나만)가 1 인 경우 결과 비트도 1입니다.</target>
        </trans-unit>
        <trans-unit id="ace1838a06f8aee366fe9897f22615a7c8331e67" translate="yes" xml:space="preserve">
          <source>Blablacar Using for storing various logs</source>
          <target state="translated">Blablacar 다양한 로그 저장에 사용</target>
        </trans-unit>
        <trans-unit id="9e7249ef83847d4eef8b8373fb7a6a27fbdd56f9" translate="yes" xml:space="preserve">
          <source>Blackhole</source>
          <target state="translated">Blackhole</target>
        </trans-unit>
        <trans-unit id="74512c310fe0afdfa4a40d111147c67fd667927a" translate="yes" xml:space="preserve">
          <source>Blanks after the separator are ignored.</source>
          <target state="translated">구분 기호 뒤의 공백은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="9be81dc89d0e2d687c059ddc4726baa9c792d38f" translate="yes" xml:space="preserve">
          <source>Blobs allocated in big sequential blocks - Less fragmentation over time.</source>
          <target state="translated">큰 순차적 블록으로 할당 된 Blob-시간이 지남에 따라 조각화가 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="af921fde1bcca27fa6d6b372ee7f958178ed199e" translate="yes" xml:space="preserve">
          <source>Blobs are stored so that Aria can easily be extended to have access to any part of a blob with a single fetch in the future.</source>
          <target state="translated">Blob은 향후 단일 페치로 Aria를 쉽게 확장하여 Blob의 모든 부분에 액세스 할 수 있도록 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="ccd0aa97ab51efc35afdbfd6a106a274ba2aa31e" translate="yes" xml:space="preserve">
          <source>Block Hash Join</source>
          <target state="translated">해시 차단</target>
        </trans-unit>
        <trans-unit id="473531bc8bcec1bdaadaced969a223e018c1939d" translate="yes" xml:space="preserve">
          <source>Block Index Hash join known as Batch Key Access Hash (BKAH) join</source>
          <target state="translated">BKAH (배치 키 액세스 해시) 조인으로 알려진 블록 인덱스 해시 조인</target>
        </trans-unit>
        <trans-unit id="775f75a1fd1a8539b9dc9dd6f2556619f467f358" translate="yes" xml:space="preserve">
          <source>Block Index join known as Batch Key Access (BKA) join</source>
          <target state="translated">BKA (배치 키 액세스) 조인으로 알려진 블록 인덱스 조인</target>
        </trans-unit>
        <trans-unit id="fa64d94095a98f3bfd5edd3561af0fc19cd09b47" translate="yes" xml:space="preserve">
          <source>Block Indexing</source>
          <target state="translated">블록 인덱싱</target>
        </trans-unit>
        <trans-unit id="c24495ff47567e5ae19b29b506f6ab09e59b2a12" translate="yes" xml:space="preserve">
          <source>Block Nested Loop (BNL) join</source>
          <target state="translated">블록 중첩 루프 (BNL) 결합</target>
        </trans-unit>
        <trans-unit id="411b72c2787a7b400610f7c6dd2cb412cee0e208" translate="yes" xml:space="preserve">
          <source>Block Nested Loop Hash (BNLH) join</source>
          <target state="translated">블록 중첩 루프 해시 (BNLH) 조인</target>
        </trans-unit>
        <trans-unit id="b8f678935f0c4107ec0388a27f3359b2f98d36ba" translate="yes" xml:space="preserve">
          <source>Block Nested Loop Join</source>
          <target state="translated">블록 중첩 루프 결합</target>
        </trans-unit>
        <trans-unit id="f208eb3e743a433890bb401e77bfeee4ab01bfb5" translate="yes" xml:space="preserve">
          <source>Block based hash join algorithm is a new option to be used for join operations in &lt;a href=&quot;../what-is-mariadb-53/index&quot;&gt;MariaDB 5.3&lt;/a&gt;. It can be employed in the cases when there are equi-join sub-condition for the joined tables, in the other words when equalities of the form t2.f1= e1(t1),...,t2.fn=en(t1) can be extracted from the full join condition. As any block based join algorithm this one used a join buffer filled with the records of the first operand and looks through the records of the second operand to find matches for the records in the buffer.</source>
          <target state="translated">블록 기반 해시 조인 알고리즘은 &lt;a href=&quot;../what-is-mariadb-53/index&quot;&gt;MariaDB 5.3의&lt;/a&gt; 조인 작업에 사용되는 새로운 옵션 입니다. 조인 된 테이블에 대해 동일 조인 하위 조건이있는 경우, 즉 t2.f1 = e1 (t1), ..., t2.fn = en (t1 형식의 등가 인 경우에 사용할 수 있습니다. )은 전체 조인 조건에서 추출 할 수 있습니다. 임의의 블록 기반 결합 알고리즘으로서 이것은 첫 번째 피연산자의 레코드로 채워진 결합 버퍼를 사용하고 두 번째 피연산자의 레코드를 조사하여 버퍼의 레코드와 일치하는 것을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="504012e6d87477468c8855b367e77a109c80c571" translate="yes" xml:space="preserve">
          <source>Block hash join</source>
          <target state="translated">해시 조인 차단</target>
        </trans-unit>
        <trans-unit id="d9a60f158ac68398c1a48912b90d093249e8d61f" translate="yes" xml:space="preserve">
          <source>Block indexing can be done in two ways. Keeping the min/max values existing for each block, or keeping a bitmap allowing knowing what column distinct values are met in each blocks. This second ways often gives a better optimization, except for sorted columns for which both are equivalent. The bitmap approach can be done only on columns having not too many distinct values. This is estimated by the MAX _ DIST option value associated to the column when creating the table. &lt;del&gt;Bitmap block indexing will be used if this number is not greater than the MAXBMP setting for the database&lt;/del&gt;.</source>
          <target state="translated">블록 인덱싱은 두 가지 방법으로 수행 할 수 있습니다. 각 블록에 대해 존재하는 최소 / 최대 값을 유지하거나 각 블록에서 어떤 열 고유 값이 충족되는지 알 수있는 비트 맵을 유지합니다. 이 두 번째 방법은 정렬 된 열을 모두 제외하고 더 나은 최적화를 제공하는 경우가 많습니다. 비트 맵 방식은 고유 값이 너무 많지 않은 열에서만 수행 할 수 있습니다. 이는 테이블 작성시 열과 연관된 MAX _ DIST 옵션 값으로 추정됩니다.&lt;del&gt;이 숫자가 데이터베이스의 MAXBMP 설정보다 크지 않으면 비트 맵 블록 인덱싱이 사용됩니다.&lt;/del&gt;.</target>
        </trans-unit>
        <trans-unit id="1e54394605ac2318f72e70df6c2b9d0f5da5258e" translate="yes" xml:space="preserve">
          <source>Block indexing is internally handled by CONNECT while reading sequentially a table data. This means in particular that when standard indexing is used on a table, block indexing is not used.</source>
          <target state="translated">블록 인덱싱은 테이블 데이터를 순차적으로 읽는 동안 CONNECT에 의해 내부적으로 처리됩니다. 이는 특히 표준 색인 작성이 테이블에서 사용될 때 블록 색인 작성이 사용되지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="7d68535ac6b149e03807b28fe9c0a63783680fe2" translate="yes" xml:space="preserve">
          <source>Block size for data/index blocks in s3</source>
          <target state="translated">s3의 데이터 / 인덱스 블록에 대한 블록 크기</target>
        </trans-unit>
        <trans-unit id="7b18d26e7cda9569b8d6e0997fa1ae899d5dde5b" translate="yes" xml:space="preserve">
          <source>Block-Based Join Algorithms</source>
          <target state="translated">블록 기반 조인 알고리즘</target>
        </trans-unit>
        <trans-unit id="f4d18ffe44f1e55ad3e0c4bb5947000dc3ba4725" translate="yes" xml:space="preserve">
          <source>Block_Size</source>
          <target state="translated">Block_Size</target>
        </trans-unit>
        <trans-unit id="b34c537dc0dbe0e55e7e304f0e28435b353dc534" translate="yes" xml:space="preserve">
          <source>Block_size</source>
          <target state="translated">Block_size</target>
        </trans-unit>
        <trans-unit id="bc3423ebb3c0eeb243dc8366596769d2d96a2215" translate="yes" xml:space="preserve">
          <source>Blocked InnoDB transactions.</source>
          <target state="translated">InnoDB 트랜잭션이 차단되었습니다.</target>
        </trans-unit>
        <trans-unit id="47b9ce58c94503857548eff35ad868a235945e50" translate="yes" xml:space="preserve">
          <source>Blocking transaction ID from the &lt;a href=&quot;../information-schema-innodb_trx-table/index&quot;&gt;INNODB_TRX&lt;/a&gt; table.</source>
          <target state="translated">&lt;a href=&quot;../information-schema-innodb_trx-table/index&quot;&gt;INNODB_TRX&lt;/a&gt; 테이블 에서 트랜잭션 ID를 차단 합니다.</target>
        </trans-unit>
        <trans-unit id="54c45c033f5eb914fae27a646cbd9e23d3750d19" translate="yes" xml:space="preserve">
          <source>Blocks</source>
          <target state="translated">Blocks</target>
        </trans-unit>
        <trans-unit id="1146944ff4d11ddf4fc7e014a56bdf1647ebadc9" translate="yes" xml:space="preserve">
          <source>Blocks &lt;a href=&quot;../create-table/index&quot;&gt;CREATE TABLE&lt;/a&gt;, &lt;a href=&quot;../drop-table/index&quot;&gt;DROP TABLE&lt;/a&gt;, &lt;a href=&quot;../truncate-table/index&quot;&gt;TRUNCATE TABLE&lt;/a&gt;, and &lt;a href=&quot;../rename-table/index&quot;&gt;RENAME TABLE&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../create-table/index&quot;&gt;CREATE TABLE&lt;/a&gt; , &lt;a href=&quot;../drop-table/index&quot;&gt;DROP TABLE&lt;/a&gt; , &lt;a href=&quot;../truncate-table/index&quot;&gt;TRUNCATE TABLE&lt;/a&gt; 및 &lt;a href=&quot;../rename-table/index&quot;&gt;RENAME TABLE을&lt;/a&gt; 차단 합니다.</target>
        </trans-unit>
        <trans-unit id="c415bb554155c5de5d34794a837b38ba0e821d3a" translate="yes" xml:space="preserve">
          <source>Blocks a table from DDL statements.</source>
          <target state="translated">DDL 문에서 테이블을 차단합니다.</target>
        </trans-unit>
        <trans-unit id="4b72c971b8fe16186209849b67255ad0e20249e4" translate="yes" xml:space="preserve">
          <source>Blocks also start off a &lt;strong&gt;new&lt;/strong&gt;&lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt; and the &lt;strong&gt;final rename phase&lt;/strong&gt; of &lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt;. Running ALTER TABLES are not blocked.</source>
          <target state="translated">블록도 시작 &lt;strong&gt;새로운 &lt;/strong&gt;&lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt; 과 &lt;strong&gt;마지막 이름 바꾸기 단계&lt;/strong&gt; 의 &lt;a href=&quot;../alter-table/index&quot;&gt;ALTER 표를&lt;/a&gt; . ALTER TABLES 실행은 차단되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5a7c5f1127513904009e1b1a5f6cd06b451ea22a" translate="yes" xml:space="preserve">
          <source>Blocks purge of redo files for storage engines that needs this (Aria)</source>
          <target state="translated">이를 필요로하는 스토리지 엔진의 리두 파일 제거를 차단합니다 (Aria)</target>
        </trans-unit>
        <trans-unit id="61cebf80a6e21bcb8aa0729a711e6229bf7db752" translate="yes" xml:space="preserve">
          <source>Blocks until the slave has applied all specified updates</source>
          <target state="translated">슬레이브가 지정된 모든 업데이트를 적용 할 때까지 차단</target>
        </trans-unit>
        <trans-unit id="35508a6c944314c2f31c3d03749cc81bebbc2a93" translate="yes" xml:space="preserve">
          <source>Blocks until the slave has applied all specified updates.</source>
          <target state="translated">슬레이브가 지정된 모든 업데이트를 적용 할 때까지 차단합니다.</target>
        </trans-unit>
        <trans-unit id="3d6f07af6a47880eb2e09d60319924b4e90daa41" translate="yes" xml:space="preserve">
          <source>Blocks/Record</source>
          <target state="translated">Blocks/Record</target>
        </trans-unit>
        <trans-unit id="4c5b28bf848b2730609c67e121e5db50bf4be868" translate="yes" xml:space="preserve">
          <source>Blocksize</source>
          <target state="translated">Blocksize</target>
        </trans-unit>
        <trans-unit id="27f6174129d5f723a5a755180e4d51b89152c0f4" translate="yes" xml:space="preserve">
          <source>Blog comment</source>
          <target state="translated">블로그 댓글</target>
        </trans-unit>
        <trans-unit id="f391a0fe72dfa93da37abfa1c316f73d74f21550" translate="yes" xml:space="preserve">
          <source>Blog post &lt;a href=&quot;http://s.petrunia.net/blog/?p=103&quot;&gt;MariaDB 10.1: Better query optimization for ORDER BY &amp;hellip; LIMIT&lt;/a&gt;</source>
          <target state="translated">블로그 게시물 &lt;a href=&quot;http://s.petrunia.net/blog/?p=103&quot;&gt;MariaDB 10.1 : ORDER BY&amp;hellip; LIMIT에 대한 향상된 쿼리 최적화&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c2dcda34df3d392090dc790cd23ef8e020f50dd7" translate="yes" xml:space="preserve">
          <source>Blog post about the development of this feature</source>
          <target state="translated">이 기능의 개발에 대한 블로그 게시물</target>
        </trans-unit>
        <trans-unit id="6234bf7f1bf324260a9fc73a8612450f64809982" translate="yes" xml:space="preserve">
          <source>Blog thread</source>
          <target state="translated">블로그 스레드</target>
        </trans-unit>
        <trans-unit id="42fd304849d14272c43db5ecfda09e389d1ce70f" translate="yes" xml:space="preserve">
          <source>Bloom Filter Parameters</source>
          <target state="translated">블룸 필터 매개 변수</target>
        </trans-unit>
        <trans-unit id="93f2a2bdb1a68a4e1f30e2ed66e26217e9af330a" translate="yes" xml:space="preserve">
          <source>Bloom Filters. See &lt;a href=&quot;../myrocks-and-bloom-filters/index&quot;&gt;myrocks-and-bloom-filters&lt;/a&gt;.</source>
          <target state="translated">블룸 필터. &lt;a href=&quot;../myrocks-and-bloom-filters/index&quot;&gt;myrocks-and-bloom-filters를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2ef5c3248b8cc2ce510585f1ca400351ce9c19fd" translate="yes" xml:space="preserve">
          <source>Bloom filter settings</source>
          <target state="translated">블룸 필터 설정</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
