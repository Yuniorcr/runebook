<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="mariadb">
    <body>
      <group id="mariadb">
        <trans-unit id="9ab1dd65c6ec60581d4f89da9b3c7bda243f9a27" translate="yes" xml:space="preserve">
          <source>The query sent to the server will be:</source>
          <target state="translated">서버로 전송 된 쿼리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="261947ab67879e306d45db54c2b82e72fd304387" translate="yes" xml:space="preserve">
          <source>The query takes 40 seconds over cold cache</source>
          <target state="translated">콜드 캐시보다 쿼리가 40 초 걸립니다</target>
        </trans-unit>
        <trans-unit id="0c9b1c1f646e8730307f68bffc57c9e4cc07246a" translate="yes" xml:space="preserve">
          <source>The query takes more than one hour (we didn't wait longer), which makes it impractical to use subqueries in such cases. The EXPLAIN below shows that the subquery was transformed into a correlated one, which indicates an IN-TO-EXISTS transformation.</source>
          <target state="translated">쿼리는 1 시간 이상 걸리며 (더 이상 기다리지 않음) 이러한 경우 하위 쿼리를 사용하는 것은 실용적이지 않습니다. 아래 EXPLAIN은 하위 쿼리가 상관 관계 쿼리로 변환되어 IN-TO-EXISTS 변환을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9ba4dca94d761ddc0e2896c5c838107b199036b5" translate="yes" xml:space="preserve">
          <source>The query to discuss</source>
          <target state="translated">논의 할 질문</target>
        </trans-unit>
        <trans-unit id="dc69340d948eb3288cbfd0579915b981a85c4a8a" translate="yes" xml:space="preserve">
          <source>The query uses only one table.</source>
          <target state="translated">쿼리는 하나의 테이블 만 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9a5deb133b05d0f4a602953f39914f1328b916e7" translate="yes" xml:space="preserve">
          <source>The query was to find big (l_quantity &amp;gt; 40) orders that were made in January 1993 that took more than 25 days to ship:</source>
          <target state="translated">이 쿼리는 1993 년 1 월에 이루어진 대량 (l_quantity&amp;gt; 40) 주문을 배송하는 데 25 일 이상이 걸렸습니다.</target>
        </trans-unit>
        <trans-unit id="ef51a9988f989257559bb75c81805cc1df1b9479" translate="yes" xml:space="preserve">
          <source>The query will read about 90 rows, which is a big improvement over the 4079 row reads plus 4068 temporary table reads/writes we had before.</source>
          <target state="translated">쿼리는 약 90 개의 행을 읽습니다. 이는 이전에 있었던 4079 개의 행 읽기와 4068 개의 임시 테이블 읽기 / 쓰기에 비해 크게 개선 된 것입니다.</target>
        </trans-unit>
        <trans-unit id="c7ae4e661cd9699033d8dfaf449935dd350cf6d4" translate="yes" xml:space="preserve">
          <source>The query:</source>
          <target state="translated">쿼리 :</target>
        </trans-unit>
        <trans-unit id="7c8cc81855ce4f9470d47431d9374cdc1ad9493e" translate="yes" xml:space="preserve">
          <source>The question is &quot;When was Andrew Johnson president of the US?&quot;.</source>
          <target state="translated">문제는 &quot;앤드류 존슨은 언제 미국 대통령 이었는가?&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="d9185a2a2b174ac535ca2a3c6c5bd1d3329a2442" translate="yes" xml:space="preserve">
          <source>The question mark and the colon after the opening parenthesis create a non-capturing group: &lt;code&gt;(?:...)&lt;/code&gt;.</source>
          <target state="translated">여는 괄호 뒤에 물음표와 콜론이 캡처되지 않은 그룹을 생성합니다 : &lt;code&gt;(?:...)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5de24fd9018e93787fa2bbb80e9293f112ddb08a" translate="yes" xml:space="preserve">
          <source>The queued rows are held only in memory until they are inserted into the table. This means that if you terminate mysqld forcibly (for example, with kill -9) or if mysqld dies unexpectedly, any queued rows that have not been written to disk are lost.</source>
          <target state="translated">큐에 대기 된 행은 테이블에 삽입 될 때까지 메모리에만 보관됩니다. 즉, mysqld를 강제로 종료 (예 : kill -9 사용)하거나 mysqld가 예기치 않게 종료되면 디스크에 기록되지 않은 모든 대기열 행이 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="c9509ad54d613c68e56620a94c79a862941a670b" translate="yes" xml:space="preserve">
          <source>The quick way to get an _estimated_ number of rows for an InnoDB table is</source>
          <target state="translated">InnoDB 테이블에 대해 _estimated_ 개의 행 수를 얻는 빠른 방법은</target>
        </trans-unit>
        <trans-unit id="703e44c283ec893030b5d75df5d77e15ed79f0f6" translate="yes" xml:space="preserve">
          <source>The range key (dt) must be included in any PRIMARY or UNIQUE key.</source>
          <target state="translated">PRIMARY 또는 UNIQUE 키에는 범위 키 (dt)가 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="992222f8fc28caf0a9f22c19967253540a06ccc0" translate="yes" xml:space="preserve">
          <source>The range key (dt) should be last in any keys it is in -- You have already &quot;pruned&quot; with it; it is almost useless in the index, especially at the beginning.</source>
          <target state="translated">범위 키 (dt)는 그 안에있는 모든 키에서 마지막이어야합니다. 이미 &quot;정리 된&quot;키입니다. 색인에서, 특히 처음에는 거의 쓸모가 없습니다.</target>
        </trans-unit>
        <trans-unit id="9e2bf5ba4335fc9b6f6631ad66eecfe724a51f7f" translate="yes" xml:space="preserve">
          <source>The range_base is some positive number (see Limitations). The interval is defined as the difference between two nearby powers of the range base.</source>
          <target state="translated">range_base는 양수입니다 (제한 사항 참조). 구간은 근거리 기반의 두 개의 거듭 제곱의 차이로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="b43197479a987cf4fba48450ff9374f0ba27a881" translate="yes" xml:space="preserve">
          <source>The rank window function allows for ranking or assigning a numeric order value based on the window function definition. Using the Rank() function will result in the same value for ties / equal values and the next rank value skipped. The Dense_Rank() function behaves similarly except the next consecutive number is used after a tie rather than skipped. The Row_Number() function will provide a unique ordering value. The example query shows the Rank() function being applied to rank sales reps by the number of opportunities for Q4 2016.</source>
          <target state="translated">순위 창 함수를 사용하면 창 함수 정의에 따라 숫자 순서 값의 순위를 지정하거나 지정할 수 있습니다. Rank () 함수를 사용하면 동점 / 동일한 값에 대해 동일한 값을 가지며 다음 순위 값을 건너 뜁니다. Dense_Rank () 함수는 다음 연속 번호를 건너 뛰지 않고 동점 다음에 사용하는 것을 제외하고는 유사하게 작동합니다. Row_Number () 함수는 고유 한 순서 값을 제공합니다. 예제 쿼리는 2016 년 4 분기 기회 수에 따라 영업 담당자의 순위를 매기는 데 적용되는 Rank () 함수를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="7672f19621d3eef7146ee2d1dc68b3343f113d8c" translate="yes" xml:space="preserve">
          <source>The ratio of key_reads to key_read_requests should be as low as possible, 1:100 is the highest acceptable, 1:1000 is better, and 1:10 is terrible.</source>
          <target state="translated">key_reads와 key_read_requests의 비율은 가능한 한 낮아야합니다. 1 : 100이 가장 높고 1 : 1000이 더 좋고 1:10이 끔찍합니다.</target>
        </trans-unit>
        <trans-unit id="c49a5ef35c9bc94f1fac002a503c1cc1347f8f4a" translate="yes" xml:space="preserve">
          <source>The read point select is produce with a 10M rows sysbench table</source>
          <target state="translated">판독 포인트 선택은 10M 행 sysbench 테이블로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="58d8ad613c25b1799c1ff217444b45a23581e6f0" translate="yes" xml:space="preserve">
          <source>The readable variable value is the same, regardless if read as a global or session value.</source>
          <target state="translated">읽을 수있는 변수 값은 전역 값으로 읽든 세션 값으로 읽든 상관없이 동일합니다.</target>
        </trans-unit>
        <trans-unit id="4aa9927ab3fec3f221a660f16bdccd94a2981e52" translate="yes" xml:space="preserve">
          <source>The real data type of &lt;code&gt;TYPE OF&lt;/code&gt; and &lt;code&gt;ROW TYPE OF table_name&lt;/code&gt; will become known at the very beginning of the stored routine call. &lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt; or &lt;a href=&quot;../drop-table/index&quot;&gt;DROP TABLE&lt;/a&gt; statements performed inside the current routine on the tables that appear in anchors won't affect the data type of the anchored variables, even if the variable is declared after an &lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt; or &lt;a href=&quot;../drop-table/index&quot;&gt;DROP TABLE&lt;/a&gt; statement.</source>
          <target state="translated">저장된 루틴 호출의 맨 처음에 &lt;code&gt;TYPE OF&lt;/code&gt; 및 &lt;code&gt;ROW TYPE OF table_name&lt;/code&gt; 의 실제 데이터 유형 이 알려집니다. 앵커에 나타나는 테이블에서 현재 루틴 내에서 수행 된 &lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt; 또는 &lt;a href=&quot;../drop-table/index&quot;&gt;DROP TABLE&lt;/a&gt; 문은 변수가 &lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt; 또는 &lt;a href=&quot;../drop-table/index&quot;&gt;DROP TABLE&lt;/a&gt; 문 다음에 선언 된 경우에도 앵커링 된 변수의 데이터 유형에 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ca1b403e63ea6252fb2fdd75228f3d05fb43f5ad" translate="yes" xml:space="preserve">
          <source>The real data type of a &lt;code&gt;ROW TYPE OF cursor_name&lt;/code&gt; variable will become known when execution enters into the block where the variable is declared. Data type instantiation will happen only once. In a cursor &lt;code&gt;ROW TYPE OF&lt;/code&gt; variable that is declared inside a loop, its data type will become known on the very first iteration and won't change on further loop iterations.</source>
          <target state="translated">&lt;code&gt;ROW TYPE OF cursor_name&lt;/code&gt; 변수 의 실제 데이터 유형은 변수가 선언 된 블록에 실행이 입력 될 때 알려지게됩니다. 데이터 유형 인스턴스화는 한 번만 발생합니다. 루프 내에서 선언 된 커서 &lt;code&gt;ROW TYPE OF&lt;/code&gt; 변수에서 해당 데이터 유형은 첫 번째 반복에서 알려지고 추가 루프 반복에서 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="978b9b0f5a4a3e281c9ad0963228d26e815432fd" translate="yes" xml:space="preserve">
          <source>The real problems occur with outward tables, in particular when they are created from already existing files. The first issue is to make the partition table use the correct existing file names. The second one, only for already existing not void tables, is to be sure the partitioning function match the distribution of the data already existing in the files.</source>
          <target state="translated">실제 문제는 특히 기존 파일에서 작성된 경우 외부 테이블에서 발생합니다. 첫 번째 문제는 파티션 테이블이 올바른 기존 파일 이름을 사용하도록하는 것입니다. 두 번째는 이미 존재하지 않는 테이블에 대해서만 분할 기능이 파일에 이미 존재하는 데이터의 분포와 일치하는지 확인하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1814931487da6ac5262c8f982cd87086abe4a515" translate="yes" xml:space="preserve">
          <source>The real work of Flashback is done by &lt;code&gt;mysqlbinlog&lt;/code&gt; with &lt;code&gt;--flashback&lt;/code&gt;. This causes events to be translated: INSERT to DELETE, DELETE to INSERT, and for UPDATEs the before and after images are swapped.</source>
          <target state="translated">Flashback의 실제 작업은 &lt;code&gt;--flashback&lt;/code&gt; 과 함께 &lt;code&gt;mysqlbinlog&lt;/code&gt; 에 의해 수행됩니다 . 이로 인해 이벤트가 INSERT에서 DELETE로, DELETE에서 INSERT로, UPDATE의 경우 전후 이미지가 교환됩니다.</target>
        </trans-unit>
        <trans-unit id="869b864f5c5ead99dd33d7169d93bad5cb043562" translate="yes" xml:space="preserve">
          <source>The reason for the above change is that MariaDB is using the newer &lt;a href=&quot;../aria-storage-engine/index&quot;&gt;Aria&lt;/a&gt; storage engine for disk based temporary files instead of MyISAM. The main benefit of Aria is that it can cache both indexes and rows and thus gives better performance than MyISAM for large queries.</source>
          <target state="translated">위의 변경 이유는 MariaDB가 MyISAM 대신 디스크 기반 임시 파일을 위해 최신 &lt;a href=&quot;../aria-storage-engine/index&quot;&gt;Aria&lt;/a&gt; 스토리지 엔진을 사용하고 있기 때문입니다 . Aria의 주요 이점은 인덱스와 행을 모두 캐시 할 수있어 대규모 쿼리에 대해 MyISAM보다 성능이 향상된다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9e2ef53ca872d2c1ca42375a0cba443e16de9918" translate="yes" xml:space="preserve">
          <source>The reason for the differing results above is that when 0x31 is inserted directly to the column, it's treated as a number (see &lt;a href=&quot;../hexadecimal-literals/index&quot;&gt;Hexadecimal Literals&lt;/a&gt;), while when 0x31 is passed to COALESCE(), it's treated as a string, because:</source>
          <target state="translated">위의 결과가 다른 이유는 0x31이 열에 직접 삽입 될 때 숫자로 처리되고 ( &lt;a href=&quot;../hexadecimal-literals/index&quot;&gt;16 진 리터럴&lt;/a&gt; 참조 ) 0x31이 COALESCE ()에 전달되면 문자열로 처리되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="2bd00847d52fcddbb4f8c0ebe4babf867d79debb" translate="yes" xml:space="preserve">
          <source>The reason for the differing results above is that when 0x31 is inserted directly to the column, it's treated as a number, while when 0x31 is passed to &lt;a href=&quot;../coalesce/index&quot;&gt;COALESCE()&lt;/a&gt;, it's treated as a string, because:</source>
          <target state="translated">위의 결과가 다른 이유는 0x31이 열에 직접 삽입되면 숫자로 처리되고 0x31이 &lt;a href=&quot;../coalesce/index&quot;&gt;COALESCE ()로&lt;/a&gt; 전달되면 문자열로 처리되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="af851afac0210e6a773312ecbbfb53f02fb297e4" translate="yes" xml:space="preserve">
          <source>The reason for the failure will almost certainly be written in the &lt;a href=&quot;../error-log/index&quot;&gt;error log&lt;/a&gt; and, if you are starting MariaDB manually, to the console. By default, the error log is named &lt;em&gt;host-name&lt;/em&gt;.err and is written to the data directory.</source>
          <target state="translated">실패 원인은 거의 확실하게 &lt;a href=&quot;../error-log/index&quot;&gt;오류 로그에 기록&lt;/a&gt; 되며 MariaDB를 수동으로 시작하는 경우 콘솔에 기록됩니다. 기본적으로 오류 로그의 이름은 &lt;em&gt;host-name&lt;/em&gt; .err이며 데이터 디렉토리에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="27ed3e1605cb7ff20bbd86d44cc3d2f22e443de6" translate="yes" xml:space="preserve">
          <source>The reason for this behavior is Vista/Win7 file system redirection. Writes to protected locations (in this case a subdirectory of Program Files) are redirected to the user's so-called &quot;Virtual Store&quot;.</source>
          <target state="translated">이 동작의 이유는 Vista / Win7 파일 시스템 리디렉션입니다. 보호 된 위치 (이 경우 Program Files의 하위 디렉토리)에 대한 쓰기는 사용자의 소위 &quot;가상 저장소&quot;로 리디렉션됩니다.</target>
        </trans-unit>
        <trans-unit id="2bd0a2a7de22af01f40fb210930e50cc63890f06" translate="yes" xml:space="preserve">
          <source>The reason is that MariaDB's build process relies heavily on &lt;code&gt;&lt;a href=&quot;https://cmake.org&quot;&gt;cmake&lt;/a&gt;&lt;/code&gt; for a lot of things. In this specific case, MariaDB's build process relies on &lt;a href=&quot;https://gitlab.kitware.com/cmake/community/wikis/doc/cpack/PackageGenerators&quot;&gt;CMake CPack Package Generators&lt;/a&gt; to build RPMs. The specific package generator that it uses to build RPMs is called &lt;code&gt;&lt;a href=&quot;https://cmake.org/cmake/help/v3.10/module/CPackRPM.html&quot;&gt;CPackRPM&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">그 이유는 MariaDB의 빌드 프로세스 가 많은 것을 위해 &lt;code&gt;&lt;a href=&quot;https://cmake.org&quot;&gt;cmake&lt;/a&gt;&lt;/code&gt; 에 크게 의존 하기 때문입니다. 이 특정한 경우, MariaDB의 빌드 프로세스는 &lt;a href=&quot;https://gitlab.kitware.com/cmake/community/wikis/doc/cpack/PackageGenerators&quot;&gt;CMake CPack 패키지 생성기&lt;/a&gt; 를 사용하여 RPM을 빌드합니다. RPM을 빌드하는 데 사용하는 특정 패키지 생성기를 &lt;code&gt;&lt;a href=&quot;https://cmake.org/cmake/help/v3.10/module/CPackRPM.html&quot;&gt;CPackRPM&lt;/a&gt;&lt;/code&gt; 이라고 합니다 .</target>
        </trans-unit>
        <trans-unit id="fd5679fb1f08e7ba9066ce758f51ff63efefe559" translate="yes" xml:space="preserve">
          <source>The reason is that dropping column &lt;code&gt;a&lt;/code&gt; would result in the new constraint that all values in column &lt;code&gt;b&lt;/code&gt; be unique. In order to drop the column, an explicit &lt;code&gt;DROP PRIMARY KEY&lt;/code&gt; and &lt;code&gt;ADD PRIMARY KEY&lt;/code&gt; would be required. Up until &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1027-release-notes/&quot;&gt;MariaDB 10.2.7&lt;/a&gt;, the column was dropped and the additional constraint applied, resulting in the following structure:</source>
          <target state="translated">그 이유는 열 &lt;code&gt;a&lt;/code&gt; 를 삭제 하면 열 &lt;code&gt;b&lt;/code&gt; 의 모든 값 이 고유 해야한다는 새로운 제약 조건이 생길 수 있기 때문입니다 . 열을 삭제하려면 명시 적 &lt;code&gt;DROP PRIMARY KEY&lt;/code&gt; 및 &lt;code&gt;ADD PRIMARY KEY&lt;/code&gt; 가 필요합니다. &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1027-release-notes/&quot;&gt;MariaDB 10.2.7&lt;/a&gt; 까지 열을 삭제하고 추가 제한 조건을 적용하여 다음 구조를 생성했습니다.</target>
        </trans-unit>
        <trans-unit id="4ec59df6c9e177482e1db6baef0313f3f6642924" translate="yes" xml:space="preserve">
          <source>The reason is the weight between nodes 2 and 6 is &lt;code&gt;10&lt;/code&gt; in &lt;code&gt;oq_graph2&lt;/code&gt;, so the shortest path taking into account &lt;code&gt;weight&lt;/code&gt; is now across more nodes.</source>
          <target state="translated">그 이유는 &lt;code&gt;oq_graph2&lt;/code&gt; 에서 노드 2와 6 사이의 가중치가 &lt;code&gt;10&lt;/code&gt; 이므로 &lt;code&gt;weight&lt;/code&gt; 를 고려한 최단 경로 는 이제 더 많은 노드에 걸쳐 있습니다.</target>
        </trans-unit>
        <trans-unit id="281d491a830750556dc655788ac54898b0806f0a" translate="yes" xml:space="preserve">
          <source>The reason to use &lt;code&gt;--no-defaults&lt;/code&gt; is to ensure that we don't inherit incorrect options from some old my.cnf.</source>
          <target state="translated">&lt;code&gt;--no-defaults&lt;/code&gt; 를 사용하는 이유 는 이전 my.cnf에서 잘못된 옵션을 상속하지 않기 위해서입니다.</target>
        </trans-unit>
        <trans-unit id="bc59373392d64e4692dc4087611eec17faa200c8" translate="yes" xml:space="preserve">
          <source>The reason why only one instead of two rows was returned becomes clear when we see how the floating point squares were evaluated.</source>
          <target state="translated">부동 소수점 제곱이 어떻게 평가되는지 볼 때 두 행 대신 하나만 반환되는 이유가 명확 해집니다.</target>
        </trans-unit>
        <trans-unit id="78db1e4a3f2f6a756c476fd8a1a42f25d174044c" translate="yes" xml:space="preserve">
          <source>The reason why the first argument is returned by such a query is because of tables such as:</source>
          <target state="translated">이러한 쿼리에서 첫 번째 인수가 반환되는 이유는 다음과 같은 테이블 때문입니다.</target>
        </trans-unit>
        <trans-unit id="2dcc0adc076c0cbae785f69f72a56f1276afe984" translate="yes" xml:space="preserve">
          <source>The reason why you may want to have many &lt;code&gt;BEGIN/END&lt;/code&gt; statements instead of just one is that the former will use up less transaction log space.</source>
          <target state="translated">하나 대신 많은 &lt;code&gt;BEGIN/END&lt;/code&gt; 문을 사용 하려는 이유 는 전자가 트랜잭션 로그 공간을 적게 사용하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="afd25ae0533df50367d3121c5f6bc8e2fa4bfdaf" translate="yes" xml:space="preserve">
          <source>The reasons you may want to use InnoDB instead of XtraDB are:</source>
          <target state="translated">XtraDB 대신 InnoDB를 사용하려는 이유는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8b12b08a20c68b146e004d904adaa552fda94c3c" translate="yes" xml:space="preserve">
          <source>The recommended algorithm is &lt;code&gt;AES_CTR&lt;/code&gt;, but this algorithm is only available when MariaDB is built with recent versions of &lt;a href=&quot;https://www.openssl.org/&quot;&gt;OpenSSL&lt;/a&gt;. If the server is built with &lt;a href=&quot;https://www.wolfssl.com/products/wolfssl/&quot;&gt;wolfSSL&lt;/a&gt; or &lt;a href=&quot;https://www.wolfssl.com/products/yassl/&quot;&gt;yaSSL&lt;/a&gt;, then this algorithm is not available. See &lt;a href=&quot;../tls-and-cryptography-libraries-used-by-mariadb/index&quot;&gt;TLS and Cryptography Libraries Used by MariaDB&lt;/a&gt; for more information about which libraries are used on which platforms.</source>
          <target state="translated">권장 알고리즘은 &lt;code&gt;AES_CTR&lt;/code&gt; 이지만이 알고리즘은 MariaDB가 최신 버전의 &lt;a href=&quot;https://www.openssl.org/&quot;&gt;OpenSSL로&lt;/a&gt; 빌드 된 경우에만 사용할 수 있습니다 . 서버가 &lt;a href=&quot;https://www.wolfssl.com/products/wolfssl/&quot;&gt;wolfSSL&lt;/a&gt; 또는 &lt;a href=&quot;https://www.wolfssl.com/products/yassl/&quot;&gt;yaSSL로&lt;/a&gt; 빌드 된 경우이 알고리즘을 사용할 수 없습니다. 어떤 플랫폼에서 어떤 라이브러리가 사용되는지에 대한 자세한 정보는 &lt;a href=&quot;../tls-and-cryptography-libraries-used-by-mariadb/index&quot;&gt;MariaDB&lt;/a&gt; 가 사용하는 TLS 및 암호화 라이브러리를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="499d1aa482447ebea83d5c48b70920477e7910c5" translate="yes" xml:space="preserve">
          <source>The recommended way to quickly check all MyISAM tables:</source>
          <target state="translated">모든 MyISAM 테이블을 빠르게 확인하는 권장 방법 :</target>
        </trans-unit>
        <trans-unit id="09695ae331e1ae118988ef2b184625ac91cdf763" translate="yes" xml:space="preserve">
          <source>The records of the first operand are written into the join buffer one by one until the buffer is full.</source>
          <target state="translated">첫 번째 피연산자의 레코드는 버퍼가 가득 찰 때까지 조인 버퍼에 하나씩 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="603e40929284ab013d6fa107aa4498105d8261aa" translate="yes" xml:space="preserve">
          <source>The records of the second operand are read from the base/temporary table one by one. For every read record r2 of table t2 the join buffer is scanned, and, for any record r1 from the buffer such that r2 matches r1 the concatenation of the interesting fields of r1 and r2 is sent to the result stream of the corresponding partial join.</source>
          <target state="translated">두 번째 피연산자의 레코드는 기본 / 임시 테이블에서 하나씩 읽습니다. 테이블 t2의 모든 판독 레코드 r2에 대해, 결합 버퍼가 스캔되고, r2가 r1과 일치하도록 버퍼로부터의 임의의 레코드 r1에 대해 r1 및 r2의 흥미로운 필드의 연결이 대응하는 부분 결합의 결과 스트림으로 전송된다.</target>
        </trans-unit>
        <trans-unit id="e3546f5c87b27306809d7744ee049be348eefe41" translate="yes" xml:space="preserve">
          <source>The recovery mode should never be set to a value other than zero except in an emergency situation.</source>
          <target state="translated">응급 상황을 제외하고 복구 모드를 0 이외의 값으로 설정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="b0f9fb05017e14283054cc9157c01f328ca74bb6" translate="yes" xml:space="preserve">
          <source>The recursion is done using &lt;code&gt;(?1)&lt;/code&gt; to call for the first parenthesized subpattern, which includes everything except the leading &lt;code&gt;^&lt;/code&gt; and the trailing &lt;code&gt;$&lt;/code&gt;.</source>
          <target state="translated">재귀는 &lt;code&gt;(?1)&lt;/code&gt; 을 사용 하여 첫 번째 괄호로 묶인 하위 패턴을 호출합니다. 여기에는 선행 &lt;code&gt;^&lt;/code&gt; 및 후행 &lt;code&gt;$&lt;/code&gt; 를 제외한 모든 것이 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="8892f7fe089926dde4ac4b4e3a939d4ad3dbd434" translate="yes" xml:space="preserve">
          <source>The redo log group capacity is the total combined size of all InnoDB redo logs. The relevant factors are:</source>
          <target state="translated">리두 로그 그룹 용량은 모든 InnoDB 리두 로그의 총 결합 크기입니다. 관련 요소는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="eff4ded1badf3e43456eca56c8ba6b2ec39a98b2" translate="yes" xml:space="preserve">
          <source>The redo log is used by &lt;a href=&quot;../innodb/index&quot;&gt;InnoDB/XtraDB&lt;/a&gt; during crash recovery. The redo log files have names like &lt;code&gt;ib_logfileN&lt;/code&gt;, where &lt;code&gt;N&lt;/code&gt; is an integer. If the &lt;a href=&quot;../innodb-system-variables/index#innodb_log_group_home_dir&quot;&gt;innodb_log_group_home_dir&lt;/a&gt; system variable is configured, then the redo log files will be created in that directory. Otherwise, they will be created in the directory defined by the &lt;a href=&quot;../server-system-variables/index#datadir&quot;&gt;datadir&lt;/a&gt; system variable.</source>
          <target state="translated">재실행 로그는 응급 복구 중에 &lt;a href=&quot;../innodb/index&quot;&gt;InnoDB / XtraDB&lt;/a&gt; 에서 사용됩니다 . 리두 로그 파일은 &lt;code&gt;ib_logfileN&lt;/code&gt; 과 같은 이름을 가지며 , 여기서 &lt;code&gt;N&lt;/code&gt; 은 정수입니다. 는 IF &lt;a href=&quot;../innodb-system-variables/index#innodb_log_group_home_dir&quot;&gt;innodb_log_group_home_dir의&lt;/a&gt; 시스템 변수가 구성되어, 다음 리두 로그 파일은 해당 디렉토리에 생성됩니다. 그렇지 않으면 &lt;a href=&quot;../server-system-variables/index#datadir&quot;&gt;datadir&lt;/a&gt; 시스템 변수로 정의 된 디렉토리에 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="e4f5330e7810bb346b3ec3c87e6d0813cc671d57" translate="yes" xml:space="preserve">
          <source>The redo log occupancy is the percentage of the InnoDB redo log capacity that is taken up by dirty pages that have not yet been flushed to the physical InnoDB tablespace files in a checkpoint. Therefore, it's determined by the following calculation:</source>
          <target state="translated">리두 로그 점유는 체크 포인트에서 물리적 InnoDB 테이블 스페이스 파일로 아직 플러시되지 않은 더티 페이지가 차지하는 InnoDB 리두 로그 용량의 백분율입니다. 따라서 다음 계산에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="712dd36bc323bc2607045a05ddd2b902a0a4eaae" translate="yes" xml:space="preserve">
          <source>The reference examples above are included in the standard build of MariaDB ColumnStore and so can be used by registering them as user defined aggregate functions. The same can be done for new functions assuming the instance has the updated libraries included. From a mcsmysql prompt:</source>
          <target state="translated">위의 참조 예제는 MariaDB ColumnStore의 표준 빌드에 포함되어 있으므로 사용자 정의 집계 함수로 등록하여 사용할 수 있습니다. 인스턴스에 업데이트 된 라이브러리가 포함되어 있다고 가정하면 새 기능에 대해서도 동일한 작업을 수행 할 수 있습니다. mcsmysql 프롬프트에서 :</target>
        </trans-unit>
        <trans-unit id="46ae100eab0e4654f4b0a22060c1139562612b17" translate="yes" xml:space="preserve">
          <source>The reference that is used to as the key value.</source>
          <target state="translated">키 값으로 사용되는 참조입니다.</target>
        </trans-unit>
        <trans-unit id="78de7d1b69048779cc1242891024d28aa175520a" translate="yes" xml:space="preserve">
          <source>The referenced columns must be a PRIMARY KEY or a UNIQUE index.</source>
          <target state="translated">참조 된 열은 PRIMARY KEY 또는 UNIQUE 인덱스 여야합니다.</target>
        </trans-unit>
        <trans-unit id="61b3bb875cac06ff44029bc30d6c88c4aaf975a5" translate="yes" xml:space="preserve">
          <source>The regular expression for the table name can be negated by prefixing it with a tilde (&amp;ldquo;&lt;code&gt;~&lt;/code&gt;&amp;rdquo;):</source>
          <target state="translated">테이블 이름의 정규식은 물결표 (&amp;ldquo; &lt;code&gt;~&lt;/code&gt; &amp;rdquo;) 로 접두사로 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0b976516e51c2acb7553c4272b275d0e4f4a42f6" translate="yes" xml:space="preserve">
          <source>The regular expression in the above example implements the following BNF grammar:</source>
          <target state="translated">위 예제의 정규식은 다음 BNF 문법을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="27000444f76ac159c10093da425abe717e95fb3e" translate="yes" xml:space="preserve">
          <source>The regular quote character is the backtick character - &lt;code&gt;`&lt;/code&gt;, but if the &lt;code&gt;ANSI_QUOTES&lt;/code&gt;&lt;a href=&quot;../sql-mode/index&quot;&gt;SQL_MODE&lt;/a&gt; option is specified, a regular double quote - &lt;code&gt;&quot;&lt;/code&gt; may be used as well.</source>
          <target state="translated">정규 따옴표 문자는 백틱 문자 ( &lt;code&gt;`&lt;/code&gt; )이지만 &lt;code&gt;ANSI_QUOTES&lt;/code&gt; &lt;a href=&quot;../sql-mode/index&quot;&gt;SQL_MODE&lt;/a&gt; 옵션이 지정된 경우 일반 따옴표 ( &lt;code&gt;&quot;&lt;/code&gt; ) 도 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d26ceade479cff3650e1d980545de76b5ab2c7f" translate="yes" xml:space="preserve">
          <source>The regular server &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;option groups&lt;/a&gt; can also be used for common options that are read by all instances:</source>
          <target state="translated">일반 서버 &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;옵션 그룹&lt;/a&gt; 은 모든 인스턴스가 읽는 공통 옵션에도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="199e143b693ef04e141b826316416f1cfd63514f" translate="yes" xml:space="preserve">
          <source>The related &lt;a href=&quot;../information-schema-innodb_buffer_page/index&quot;&gt;INFORMATION_SCHEMA.INNODB_BUFFER_PAGE&lt;/a&gt; table contains the same information, but with a block id rather than LRU position.</source>
          <target state="translated">관련 &lt;a href=&quot;../information-schema-innodb_buffer_page/index&quot;&gt;INFORMATION_SCHEMA.INNODB_BUFFER_PAGE&lt;/a&gt; 테이블에는 동일한 정보가 있지만 LRU 위치가 아닌 블록 ID가 있습니다.</target>
        </trans-unit>
        <trans-unit id="12e1668b5cbe725da21a49ba3b4e04efe30197af" translate="yes" xml:space="preserve">
          <source>The related &lt;a href=&quot;../information-schema-innodb_buffer_page_lru-table/index&quot;&gt;INFORMATION_SCHEMA.INNODB_BUFFER_PAGE_LRU&lt;/a&gt; table contains the same information, but with an LRU (least recently used) position rather than block id.</source>
          <target state="translated">관련 &lt;a href=&quot;../information-schema-innodb_buffer_page_lru-table/index&quot;&gt;INFORMATION_SCHEMA.INNODB_BUFFER_PAGE_LRU&lt;/a&gt; 테이블에는 동일한 정보가 포함되지만 블록 ID가 아닌 LRU (최근에 사용 된) 위치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4fa1781a4a8445f584092ccd2267bc42810a850" translate="yes" xml:space="preserve">
          <source>The related &lt;a href=&quot;../xtradbinnodb-server-status-variables/index#innodb_available_undo_logs&quot;&gt;innodb_available_undo_logs&lt;/a&gt; status variable stores the total number of available InnoDB undo logs.</source>
          <target state="translated">관련된 &lt;a href=&quot;../xtradbinnodb-server-status-variables/index#innodb_available_undo_logs&quot;&gt;innodb_available_undo_logs&lt;/a&gt; 상태 변수는 사용 가능한 총 InnoDB 실행 취소 로그 수를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="a69415a5311b98dd3194975f4e50252f99167c10" translate="yes" xml:space="preserve">
          <source>The related tables, &lt;a href=&quot;../performance-schema-events_stages_history-table/index&quot;&gt;events_stages_history&lt;/a&gt; and &lt;a href=&quot;../performance-schema-events_stages_history_long-table/index&quot;&gt;events_stages_history_long&lt;/a&gt; derive their values from the current events.</source>
          <target state="translated">관련 테이블 &lt;a href=&quot;../performance-schema-events_stages_history-table/index&quot;&gt;events_stages_history&lt;/a&gt; 및 &lt;a href=&quot;../performance-schema-events_stages_history_long-table/index&quot;&gt;events_stages_history_long&lt;/a&gt; 은 현재 이벤트에서 값을 파생합니다.</target>
        </trans-unit>
        <trans-unit id="30a024b8920d31b75f7418899433da00ce9d86be" translate="yes" xml:space="preserve">
          <source>The related tables, &lt;a href=&quot;../performance-schema-events_statements_history-table/index&quot;&gt;events_statements_history&lt;/a&gt; and &lt;a href=&quot;../performance-schema-events_statements_history_long-table/index&quot;&gt;events_statements_history_long&lt;/a&gt; derive their values from the current events table.</source>
          <target state="translated">관련 테이블 &lt;a href=&quot;../performance-schema-events_statements_history-table/index&quot;&gt;events_statements_history&lt;/a&gt; 및 &lt;a href=&quot;../performance-schema-events_statements_history_long-table/index&quot;&gt;events_statements_history_long&lt;/a&gt; 은 현재 이벤트 테이블에서 해당 값을 파생합니다.</target>
        </trans-unit>
        <trans-unit id="2b17c8cc0363cadb7f8df990105deb08a75565e7" translate="yes" xml:space="preserve">
          <source>The related tables, &lt;a href=&quot;../performance-schema-events_waits_history-table/index&quot;&gt;events_waits_history&lt;/a&gt; and &lt;a href=&quot;../performance-schema-events_waits_history_long-table/index&quot;&gt;events_waits_history_long&lt;/a&gt; derive their values from the current events.</source>
          <target state="translated">관련 테이블 &lt;a href=&quot;../performance-schema-events_waits_history-table/index&quot;&gt;events_waits_history&lt;/a&gt; 및 &lt;a href=&quot;../performance-schema-events_waits_history_long-table/index&quot;&gt;events_waits_history_long&lt;/a&gt; 은 현재 이벤트에서 값을 파생합니다.</target>
        </trans-unit>
        <trans-unit id="9927805c75e7e95885d7c0fee21dedbe361b7a1a" translate="yes" xml:space="preserve">
          <source>The relay log is a set of log files created by a slave during &lt;a href=&quot;../standard-replication/index&quot;&gt;replication&lt;/a&gt;.</source>
          <target state="translated">릴레이 로그는 &lt;a href=&quot;../standard-replication/index&quot;&gt;복제&lt;/a&gt; 중에 슬레이브가 생성 한 로그 파일 세트입니다 .</target>
        </trans-unit>
        <trans-unit id="a45230ee4135d81662e4a0bdf9e24caa0e98de60" translate="yes" xml:space="preserve">
          <source>The relay-log name with a connection_name suffix. The xxxxx is the relay log number. This contains the replication data read from the master.</source>
          <target state="translated">connection_name 접미사가있는 릴레이 로그 이름입니다. xxxxx는 릴레이 로그 번호입니다. 여기에는 마스터에서 읽은 복제 데이터가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="22a8f3640376603ba8cebe0f80cc1405cb5f028d" translate="yes" xml:space="preserve">
          <source>The remainder of a division can be obtained using the &lt;a href=&quot;../mod/index&quot;&gt;MOD&lt;/a&gt; operator.</source>
          <target state="translated">나머지 부서는 &lt;a href=&quot;../mod/index&quot;&gt;MOD&lt;/a&gt; 연산자 를 사용하여 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f5e9472502ac9b48e4b69549e2a88533cd5ee527" translate="yes" xml:space="preserve">
          <source>The remote column name.</source>
          <target state="translated">원격 열 이름</target>
        </trans-unit>
        <trans-unit id="c974a400800b6aa7e70c8edad429046edb9debe8" translate="yes" xml:space="preserve">
          <source>The remote table or view to access. This can be specified within the connection string or using specific CONNECT options.</source>
          <target state="translated">액세스 할 원격 테이블 또는 뷰 연결 문자열 내에서 또는 특정 CONNECT 옵션을 사용하여 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="719664d5913998a6caf1b9b552d8888ca1d9800e" translate="yes" xml:space="preserve">
          <source>The rename operation is done atomically, which means that no other session can access any of the tables while the rename is running. For example, if you have an existing table &lt;code&gt;old_table&lt;/code&gt;, you can create another table &lt;code&gt;new_table&lt;/code&gt; that has the same structure but is empty, and then replace the existing table with the empty one as follows (assuming that &lt;code&gt;backup_table&lt;/code&gt; does not already exist):</source>
          <target state="translated">이름 바꾸기 작업은 원자 적으로 수행되므로 이름 바꾸기가 실행되는 동안 다른 세션에서 테이블에 액세스 할 수 없습니다. 예를 들어 기존 테이블 &lt;code&gt;old_table&lt;/code&gt; 이 있으면 구조는 동일하지만 비어있는 다른 테이블 &lt;code&gt;new_table&lt;/code&gt; 을 만든 다음 기존 테이블을 다음과 같이 빈 테이블로 바꿀 수 있습니다 ( &lt;code&gt;backup_table&lt;/code&gt; 이 이미 존재하지 않는다고 가정 ).</target>
        </trans-unit>
        <trans-unit id="518de981b4195cdef3698908c54fdbf3df43f4f6" translate="yes" xml:space="preserve">
          <source>The replace program is used by &lt;a href=&quot;../msql2mysql/index&quot;&gt;msql2mysql&lt;/a&gt;.</source>
          <target state="translated">replace 프로그램은 &lt;a href=&quot;../msql2mysql/index&quot;&gt;msql2mysql에&lt;/a&gt; 의해 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="793ea842052974769c31474fc7cb26007374317e" translate="yes" xml:space="preserve">
          <source>The replace string can have backreferences to the subexpressions in the form \N, where N is a number from 1 to 9.</source>
          <target state="translated">바꾸기 문자열은 \ N 형식의 하위 표현식에 대한 역 참조를 가질 수 있습니다. 여기서 N은 1에서 9 사이의 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="a74dd606327cd374b7c2062d67a834691407b2fb" translate="yes" xml:space="preserve">
          <source>The replace utility program changes strings in place in files or on the standard input. Invoke replace in one of the following ways:</source>
          <target state="translated">replace 유틸리티 프로그램은 파일 또는 표준 입력에서 문자열을 변경합니다. 다음 방법 중 하나로 replace를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="a2f865947d9383d7ba313090d5b31240731cfb19" translate="yes" xml:space="preserve">
          <source>The replace utility program changes strings in place infiles or on the standard input</source>
          <target state="translated">replace 유틸리티 프로그램은 infile 또는 표준 입력에서 문자열을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="0f308b84dae289cd0044980ca8de1e017dec0407" translate="yes" xml:space="preserve">
          <source>The requested server id %d clashes with the slave startup option --replicate-same-server-id</source>
          <target state="translated">요청 된 서버 ID % d이 (가) 슬레이브 시작 옵션 --replicate-same-server-id와 (과) 충돌합니다</target>
        </trans-unit>
        <trans-unit id="3230462e88b891c1c2a073af42ef2ed4239beeaa" translate="yes" xml:space="preserve">
          <source>The requested value %s for the master delay exceeds the maximum %u</source>
          <target state="translated">마스터 지연에 대한 요청 된 값 % s이 (가) 최대 % u를 초과합니다</target>
        </trans-unit>
        <trans-unit id="a39beaffb53b2654ac34674528c8a6c4ea0940cc" translate="yes" xml:space="preserve">
          <source>The requested value for the heartbeat period exceeds the value of &lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#slave_net_timeout&quot;&gt;slave_net_timeout&lt;/a&gt; seconds. A sensible value for the period should be less than the timeout.</source>
          <target state="translated">하트 비트 기간 동안 요청 된 값이 &lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#slave_net_timeout&quot;&gt;slave_net_timeout&lt;/a&gt; 초 값을 초과합니다 . 해당 기간의 합리적인 값은 시간 초과보다 작아야합니다.</target>
        </trans-unit>
        <trans-unit id="e0533515064be9ec92e3cb31bbe7ed2d64d55d60" translate="yes" xml:space="preserve">
          <source>The requested value for the heartbeat period is either negative or exceeds the maximum allowed (%s seconds).</source>
          <target state="translated">하트 비트 기간에 요청 된 값이 음수이거나 최대 허용 시간 (% s 초)을 초과합니다.</target>
        </trans-unit>
        <trans-unit id="8ddf9ff8103b02aa0caf79fcfdcc17f6939c73a8" translate="yes" xml:space="preserve">
          <source>The requested value for the heartbeat period is less than 1 millisecond. The value is reset to 0, meaning that heartbeating will effectively be disabled.</source>
          <target state="translated">하트 비트 기간 동안 요청 된 값이 1 밀리 초 미만입니다. 값이 0으로 재설정되므로 하트 비트가 효과적으로 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="e938c1db2f621e5bba8932a39f32fb9d07fd8be3" translate="yes" xml:space="preserve">
          <source>The requested view:</source>
          <target state="translated">요청 된보기 :</target>
        </trans-unit>
        <trans-unit id="c14b3bc235ba7b79a8aca63586de3e943b878b93" translate="yes" xml:space="preserve">
          <source>The required parameters include:</source>
          <target state="translated">필수 매개 변수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cd3d4790635d4f86e6b61e54ac15f75cf60907e9" translate="yes" xml:space="preserve">
          <source>The required syntax for an &lt;code&gt;ANY&lt;/code&gt; or &lt;code&gt;SOME&lt;/code&gt; quantified comparison is:</source>
          <target state="translated">&lt;code&gt;ANY&lt;/code&gt; 또는 &lt;code&gt;SOME&lt;/code&gt; 정량화 된 비교에 필요한 구문 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5ca1ae18bca9923b4a2592ed5e3d758bdad2f425" translate="yes" xml:space="preserve">
          <source>The required syntax for the &lt;code&gt;COMMIT&lt;/code&gt; statement is as follows:</source>
          <target state="translated">&lt;code&gt;COMMIT&lt;/code&gt; 문의 필수 구문 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a3eb46f38a3cff19d001caca6aadde05a8bb56ee" translate="yes" xml:space="preserve">
          <source>The resize operation waits until all active transactions and operations are completed, and new transactions and operations that need to access the buffer pool must wait until the resize is complete (although when decreasing the size, access is permitted when defragmenting and withdrawing pages).</source>
          <target state="translated">크기 조정 작업은 모든 활성 트랜잭션 및 작업이 완료 될 때까지 대기하며 버퍼 풀에 액세스해야하는 새 트랜잭션 및 작업은 크기 조정이 완료 될 때까지 기다려야합니다 (크기를 줄이면 페이지 조각 모음 및 철회시 액세스가 허용됨).</target>
        </trans-unit>
        <trans-unit id="d92ebb94027eee210dc5d087b8b7e80489ba972a" translate="yes" xml:space="preserve">
          <source>The resources are tracked per account, which means &lt;code&gt;'user'@'server'&lt;/code&gt;; not per user name or per connection.</source>
          <target state="translated">리소스는 계정별로 추적되며 이는 &lt;code&gt;'user'@'server'&lt;/code&gt; 를 의미 합니다 . 사용자 이름 또는 연결 당이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="0b45c6a4019a87e7cd240e979062a8e0a8638622" translate="yes" xml:space="preserve">
          <source>The response time decreases to 0.04. This is expected because the query latency is increased from multiple network round trips and condition push down is not implemented yet. Sysbench doing a lot of range queries. Just consider for now that this range query can be a badly optimized query.</source>
          <target state="translated">응답 시간이 0.04로 감소합니다. 이는 여러 네트워크 왕복에서 쿼리 대기 시간이 증가하고 조건 푸시 다운이 아직 구현되지 않았기 때문입니다. Sysbench는 많은 범위 쿼리를 수행합니다. 지금은이 범위 쿼리가 잘못 최적화 된 쿼리 일 수 있다는 점을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="68dfc84270791799dad852908ee537b491b703a7" translate="yes" xml:space="preserve">
          <source>The rest of the article is dedicated to *major* upgrades, e.g 10.1.x to 10.2.y.</source>
          <target state="translated">이 기사의 나머지 부분은 * 주요 * 업그레이드 (예 : 10.1.x에서 10.2.y)에 관한 것입니다.</target>
        </trans-unit>
        <trans-unit id="9987352e9c2af8b623311ff99212a02ea3ba6687" translate="yes" xml:space="preserve">
          <source>The rest of the install and setup process is as normal.</source>
          <target state="translated">나머지 설치 및 설정 프로세스는 정상적으로 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="c40251770c4e98d2ab3bad78b95877bb369b332b" translate="yes" xml:space="preserve">
          <source>The rest of this page is a complete reference of dynamic columns in MariaDB</source>
          <target state="translated">이 페이지의 나머지 부분은 MariaDB의 동적 열에 대한 완전한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="147c6e57f78fec9f4293aef9f10edd03a04cb159" translate="yes" xml:space="preserve">
          <source>The restore process for partial backups is quite different than the process for &lt;a href=&quot;../full-backup-and-restore-with-mariabackup/index&quot;&gt;full backups&lt;/a&gt;. A partial backup is not a completely functional data directory. The data dictionary in the &lt;a href=&quot;../innodb-system-tablespaces/index&quot;&gt;InnoDB system tablespace&lt;/a&gt; will still contain entries for the databases and tables that were not included in the backup.</source>
          <target state="translated">부분 백업의 복원 프로세스는 &lt;a href=&quot;../full-backup-and-restore-with-mariabackup/index&quot;&gt;전체 백업&lt;/a&gt; 의 프로세스와 상당히 다릅니다 . 부분 백업은 완전히 작동하는 데이터 디렉토리가 아닙니다. &lt;a href=&quot;../innodb-system-tablespaces/index&quot;&gt;InnoDB 시스템 테이블 스페이스&lt;/a&gt; 의 데이터 사전 에는 여전히 백업에 포함되지 않은 데이터베이스 및 테이블에 대한 항목이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="6d9ded18b2898b606a02e3ed44f4719440778695" translate="yes" xml:space="preserve">
          <source>The restore process for restoring individual tables and/or partitions is quite different than the process for &lt;a href=&quot;../full-backup-and-restore-with-mariabackup/index&quot;&gt;full backups&lt;/a&gt;.</source>
          <target state="translated">개별 테이블 및 / 또는 파티션을 복원하기위한 복원 프로세스는 &lt;a href=&quot;../full-backup-and-restore-with-mariabackup/index&quot;&gt;전체 백업&lt;/a&gt; 프로세스와는 상당히 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="8614fec14fe19846869f0ec5e91d24099426dd42" translate="yes" xml:space="preserve">
          <source>The result (limited by 10):</source>
          <target state="translated">결과 (10으로 제한) :</target>
        </trans-unit>
        <trans-unit id="398a04078169628b7652ad4c5349f802422aabfe" translate="yes" xml:space="preserve">
          <source>The result is a binary string of the same length as &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">결과는 &lt;code&gt;str&lt;/code&gt; 과 길이가 같은 이진 문자열입니다 .</target>
        </trans-unit>
        <trans-unit id="f9d8170d98950c22e6026933d7548298a3e52f98" translate="yes" xml:space="preserve">
          <source>The result is:</source>
          <target state="translated">결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0da60dfdb2a7a4840eb0d44bf35df06f2380b978" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;EXCEPT&lt;/code&gt; is all records of the left &lt;code&gt;SELECT&lt;/code&gt; result except records which are in right &lt;code&gt;SELECT&lt;/code&gt; result set, i.e. it is subtraction of two result sets.</source>
          <target state="translated">&lt;code&gt;EXCEPT&lt;/code&gt; 의 결과는 오른쪽에있는 레코드를 제외한 왼쪽 &lt;code&gt;SELECT&lt;/code&gt; 결과 의 모든 레코드입니다. &lt;code&gt;SELECT&lt;/code&gt; 결과 집합에 즉 두 결과 집합을 뺍니다.</target>
        </trans-unit>
        <trans-unit id="4e9cfc17e20509ebd68875f033eae505fa775584" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;EXCEPT&lt;/code&gt; is all records of the left &lt;code&gt;SELECT&lt;/code&gt; result set except records which are in right &lt;code&gt;SELECT&lt;/code&gt; result set, i.e. it is subtraction of two result sets.</source>
          <target state="translated">&lt;code&gt;EXCEPT&lt;/code&gt; 의 결과는 오른쪽에있는 레코드를 제외한 왼쪽 &lt;code&gt;SELECT&lt;/code&gt; 결과 세트 의 모든 레코드입니다. &lt;code&gt;SELECT&lt;/code&gt; 결과 집합에 즉 두 결과 집합을 뺍니다.</target>
        </trans-unit>
        <trans-unit id="53bafc4323d0cd972718cc5d76e57b98c62dfe3f" translate="yes" xml:space="preserve">
          <source>The result of an intersect is the intersection of right and left &lt;code&gt;SELECT&lt;/code&gt; results, i.e. only records that are present in both result sets will be included in the result of the operation.</source>
          <target state="translated">교차의 결과는 오른쪽과 왼쪽의 교차점입니다 &lt;code&gt;SELECT&lt;/code&gt; 결과 . 즉, 두 결과 세트 모두에 존재하는 레코드 만 작업 결과에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="71c1127f4c630f91933bfbe99db4ba35e6c6f7c8" translate="yes" xml:space="preserve">
          <source>The result of such an architecture is a natural &quot;commit grouping&quot; - If commits are coming faster than the system can sync, they do not stall. Instead, all commits that came since the last sync are logged to the same &quot;active&quot; page, and they all are synced with the next - one - sync. Thus, thought individual commits are delayed, throughput is not decreasing.</source>
          <target state="translated">이러한 아키텍처의 결과는 자연스러운 &quot;커밋 그룹화&quot;입니다. 커밋이 시스템이 동기화 할 수있는 것보다 더 빨리 오는 경우 중단되지 않습니다. 대신 마지막 동기화 이후에 발생한 모든 커밋이 동일한 &quot;활성&quot;페이지에 기록되고 모두 다음 동기화 (동기화)와 동기화됩니다. 따라서 개별 커밋이 지연되고 처리량이 감소하지 않는다고 생각했습니다.</target>
        </trans-unit>
        <trans-unit id="695ebd2a2f4abc718e13f4e240c3e0e3ca577358" translate="yes" xml:space="preserve">
          <source>The result of the &lt;code&gt;UNION&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;UNION&lt;/code&gt; 의 결과 .</target>
        </trans-unit>
        <trans-unit id="4336133041bab26130cc712e91ea4f7c6c2e9921" translate="yes" xml:space="preserve">
          <source>The result of the query is a subset of the complete query, depending on when the query engine detected that the limit was reached. The result may be empty if no result rows could be computed before reaching the limit.</source>
          <target state="translated">쿼리 결과는 쿼리 엔진이 제한에 도달했음을 감지 한 시점에 따라 전체 쿼리의 하위 집합입니다. 한계에 도달하기 전에 결과 행을 계산할 수 없으면 결과가 비어있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69ea20f61c3be549481b1488251ff59008411fa9" translate="yes" xml:space="preserve">
          <source>The result returned by &lt;code&gt;SETVAL()&lt;/code&gt; is &lt;code&gt;next_value&lt;/code&gt; or NULL if the given &lt;code&gt;next_value&lt;/code&gt; and &lt;code&gt;round&lt;/code&gt; is smaller than the current value.</source>
          <target state="translated">주어진 &lt;code&gt;next_value&lt;/code&gt; 및 &lt;code&gt;round&lt;/code&gt; 가 현재 값보다 작은 경우 &lt;code&gt;SETVAL()&lt;/code&gt; 의해 리턴되는 결과 는 &lt;code&gt;next_value&lt;/code&gt; 또는 NULL 입니다.</target>
        </trans-unit>
        <trans-unit id="83e0112c7fd00af03051c84c37129f451dd9253c" translate="yes" xml:space="preserve">
          <source>The result returned by the SELECT statement is:</source>
          <target state="translated">SELECT 문에 의해 리턴되는 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7a6a6ec5e178be42383c85edd995b2c08aba2315" translate="yes" xml:space="preserve">
          <source>The result showing the first partition has been disabled:</source>
          <target state="translated">첫 번째 파티션을 보여주는 결과가 비활성화되었습니다 :</target>
        </trans-unit>
        <trans-unit id="251de5db13293772e2a8c21262749b0cafff456e" translate="yes" xml:space="preserve">
          <source>The result showing the first partition has been dropped:</source>
          <target state="translated">첫 번째 파티션을 보여주는 결과가 삭제되었습니다.</target>
        </trans-unit>
        <trans-unit id="7a5cc65015794fae58f281a3d0b9bb13ab1b9397" translate="yes" xml:space="preserve">
          <source>The result showing the first partition has been enabled:</source>
          <target state="translated">첫 번째 파티션을 보여주는 결과가 활성화되었습니다 :</target>
        </trans-unit>
        <trans-unit id="1f879f0ab5198f41a810081d6ece43a4fd747435" translate="yes" xml:space="preserve">
          <source>The result we get from the new table is:</source>
          <target state="translated">새 테이블에서 얻은 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="16c5b940c2fddef28586699a689b629393751af9" translate="yes" xml:space="preserve">
          <source>The result will be that both the &lt;code&gt;INSERT&lt;/code&gt; and the &lt;code&gt;DROP&lt;/code&gt; will go through as separate transactions so the &lt;code&gt;ROLLBACK&lt;/code&gt; will have no effect.</source>
          <target state="translated">결과적으로 &lt;code&gt;INSERT&lt;/code&gt; 와 &lt;code&gt;DROP&lt;/code&gt; 은 별도의 트랜잭션으로 진행되므로 &lt;code&gt;ROLLBACK&lt;/code&gt; 이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4e00afb986323ba904efea3a982c45371e5a241e" translate="yes" xml:space="preserve">
          <source>The result will be:</source>
          <target state="translated">결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c32f62d90a0bb00b2ec1a6ce99110f9957e90f29" translate="yes" xml:space="preserve">
          <source>The result will have 0 rows. This is because according to the partition function query pruning will only look inside the second partition and will miss the row that is in the wrong partition.</source>
          <target state="translated">결과에는 0 개의 행이 있습니다. 이는 파티션 기능 쿼리에 따라 프룬이 두 번째 파티션 내부 만보고 잘못된 파티션에있는 행을 놓치기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="01be55a0c09b1d115faa58cff213ed7e949d0a99" translate="yes" xml:space="preserve">
          <source>The result:</source>
          <target state="translated">결과:</target>
        </trans-unit>
        <trans-unit id="b37298dfaedd32ebfa6255ad5b63476300818330" translate="yes" xml:space="preserve">
          <source>The resulting module, for instance &lt;code&gt;mongo.so&lt;/code&gt; or &lt;code&gt;mongo.dll&lt;/code&gt;, must be placed in the plugin directory of the MariaDB server. Then, you will be able to use MONGO like tables simply replacing in the CREATE TABLE statement the option &lt;code&gt;TABLE_TYPE=MONGO&lt;/code&gt; with &lt;code&gt;TABLE_TYPE=OEM SUBTYPE=MONGO MODULE=&amp;rsquo;mongo.(so|dll)&amp;rsquo;&lt;/code&gt;. Actually, the module name, here supposedly &amp;lsquo;mongo&amp;rsquo;, can be anything you like.</source>
          <target state="translated">결과 모듈 (예 : &lt;code&gt;mongo.so&lt;/code&gt; 또는 &lt;code&gt;mongo.dll&lt;/code&gt; )은 MariaDB 서버의 플러그인 디렉토리에 있어야합니다. 그런 다음 CREATE TABLE 문에서 &lt;code&gt;TABLE_TYPE=MONGO&lt;/code&gt; 옵션 을 &lt;code&gt;TABLE_TYPE=OEM SUBTYPE=MONGO MODULE=&amp;rsquo;mongo.(so|dll)&amp;rsquo;&lt;/code&gt; 바꾸면 MONGO와 같은 테이블을 사용할 수 있습니다 . 실제로, 여기에서 'mongo'라고 생각되는 모듈 이름은 원하는 것이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="766380be9abf8a248a9dc0fae4cfafd8bc9dc0b3" translate="yes" xml:space="preserve">
          <source>The resulting module, for instance rest.so or rest.dll, must be placed in the plugin directory of the MariaDB server. Then, you will be able to use NoSQL tables simply replacing in the CREATE TABLE statement the TABLE_TYPE option =JSON or XML by TABLE_TYPE=OEM SUBTYPE=REST MODULE=&amp;rsquo;rest.(so|dll)&amp;rsquo;. Actually, the module name, here supposedly &amp;lsquo;rest&amp;rsquo;, can be anything you like.</source>
          <target state="translated">결과 모듈 (예 : rest.so 또는 rest.dll)은 MariaDB 서버의 플러그인 디렉토리에 있어야합니다. 그런 다음 CREATE TABLE 문에서 TABLE_TYPE 옵션 = JSON 또는 XML을 TABLE_TYPE = OEM SUBTYPE = REST MODULE = 'rest. (so | dll)'로 바꾸면 NoSQL 테이블을 사용할 수 있습니다. 실제로, 여기에서 '휴식'으로 추정되는 모듈 이름은 원하는 것이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="134e9001f9eef3a3de399c2589fb034d78785976" translate="yes" xml:space="preserve">
          <source>The results of &lt;code&gt;SHOW WARNINGS&lt;/code&gt; and &lt;code&gt;SHOW COUNT(*) WARNINGS&lt;/code&gt; are directly sent to the client. If you need to access those information in a stored program, you can use the &lt;code&gt;&lt;a href=&quot;../get-diagnostics/index&quot;&gt;GET DIAGNOSTICS&lt;/a&gt;&lt;/code&gt; statement instead.</source>
          <target state="translated">&lt;code&gt;SHOW WARNINGS&lt;/code&gt; 및 &lt;code&gt;SHOW COUNT(*) WARNINGS&lt;/code&gt; 의 결과 는 클라이언트로 직접 전송됩니다. 저장된 프로그램에서 해당 정보에 액세스해야하는 경우 &lt;code&gt;&lt;a href=&quot;../get-diagnostics/index&quot;&gt;GET DIAGNOSTICS&lt;/a&gt;&lt;/code&gt; 문을 대신 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3a30113fae3978b1f717d263c22c29017478a8d0" translate="yes" xml:space="preserve">
          <source>The results show some statistics for the values returned by the query, and propose an optimal data type for the columns. This can be helpful for checking your existing tables, or after importing new data. You may need to try different settings for the arguments so that PROCEDURE ANALYSE() does not suggest the ENUM data type when it is not appropriate.</source>
          <target state="translated">결과는 쿼리에서 반환 된 값에 대한 일부 통계를 표시하고 열에 대한 최적의 데이터 형식을 제안합니다. 기존 테이블을 확인하거나 새 데이터를 가져온 후 유용합니다. PROCEDURE ANALYSE ()가 적절하지 않을 때 ENUM 데이터 유형을 제안하지 않도록 인수에 대해 다른 설정을 시도해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae23359249c0828c9bbf6976690f83f87ee08298" translate="yes" xml:space="preserve">
          <source>The return string is a binary string where the first character is &lt;code&gt;CHAR(128 | key_num)&lt;/code&gt;. If an error occurs, &lt;code&gt;DES_ENCRYPT()&lt;/code&gt; returns &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">리턴 문자열은 첫 번째 문자가 &lt;code&gt;CHAR(128 | key_num)&lt;/code&gt; 이진 문자열 입니다. 오류가 발생하면 &lt;code&gt;DES_ENCRYPT()&lt;/code&gt; 는 &lt;code&gt;NULL&lt;/code&gt; 을 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="2d80655901d1fc1c3b9cde1fd19d935f565e2988" translate="yes" xml:space="preserve">
          <source>The return string is lowercase, and is platform independent, since it does not use functions specific to the operating system. It has a maximum length of 39 characters.</source>
          <target state="translated">리턴 문자열은 소문자이며 운영 체제 고유의 기능을 사용하지 않으므로 플랫폼에 독립적입니다. 최대 길이는 39 자입니다.</target>
        </trans-unit>
        <trans-unit id="2c8a291096229b5d96edd313fb9398165f026bca" translate="yes" xml:space="preserve">
          <source>The return value is 16 bytes in length, or NULL if the argument was NULL.</source>
          <target state="translated">리턴 값은 16 바이트 길이이거나 인수가 NULL 인 경우 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="e0c9ba4e751ad47695e0cb8b3339561ae80fc21d" translate="yes" xml:space="preserve">
          <source>The return value is 41-bytes in length, and the first character is always '*'.</source>
          <target state="translated">반환 값의 길이는 41 바이트이며 첫 문자는 항상 '*'입니다.</target>
        </trans-unit>
        <trans-unit id="a67705ab3b53dd115219738e273c103d6fafb0e5" translate="yes" xml:space="preserve">
          <source>The return value is a 32-hex digit string, and as of &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt;, is a nonbinary string in the connection &lt;a href=&quot;../data-types-character-sets-and-collations/index&quot;&gt;character set and collation&lt;/a&gt;, determined by the values of the &lt;a href=&quot;../server-system-variables/index#character_set_connection&quot;&gt;character_set_connection&lt;/a&gt; and &lt;a href=&quot;../server-system-variables/index#collation_connection&quot;&gt;collation_connection&lt;/a&gt; system variables. Before 5.5, the return value was a binary string.</source>
          <target state="translated">반환 값은 32 진수 문자열이며 &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt; 부터는 &lt;a href=&quot;../server-system-variables/index#character_set_connection&quot;&gt;character_set_connection&lt;/a&gt; 및 &lt;a href=&quot;../server-system-variables/index#collation_connection&quot;&gt;collation_connection&lt;/a&gt; 시스템 변수 의 값에 의해 결정되는 연결 &lt;a href=&quot;../data-types-character-sets-and-collations/index&quot;&gt;문자 세트 및 데이터 정렬&lt;/a&gt; 의 비 이진 문자열입니다 . 5.5 이전에는 반환 값이 이진 문자열이었습니다.</target>
        </trans-unit>
        <trans-unit id="b3493efa90da5a58247500894bca2134d09165e7" translate="yes" xml:space="preserve">
          <source>The return value is a dynamic column blob after the modification.</source>
          <target state="translated">반환 값은 수정 후 동적 열 얼룩입니다.</target>
        </trans-unit>
        <trans-unit id="cb333502081411c845909f304e7aacce837acc6f" translate="yes" xml:space="preserve">
          <source>The return value is a dynamic column blob after the modifications.</source>
          <target state="translated">반환 값은 수정 후 동적 열 얼룩입니다.</target>
        </trans-unit>
        <trans-unit id="e5b65dcf2b223b1a98877182782e731cf1520982" translate="yes" xml:space="preserve">
          <source>The return value is a nonbinary string in the connection &lt;a href=&quot;../data-types-character-sets-and-collations/index&quot;&gt;character set and collation&lt;/a&gt;, determined by the values of the &lt;a href=&quot;../server-system-variables/index#character_set_connection&quot;&gt;character_set_connection&lt;/a&gt; and &lt;a href=&quot;../server-system-variables/index#collation_connection&quot;&gt;collation_connection&lt;/a&gt; system variables.</source>
          <target state="translated">리턴 값은 &lt;a href=&quot;../server-system-variables/index#character_set_connection&quot;&gt;character_set_connection&lt;/a&gt; 및 &lt;a href=&quot;../server-system-variables/index#collation_connection&quot;&gt;collation_connection&lt;/a&gt; 시스템 변수 의 값에 의해 결정되는 연결 &lt;a href=&quot;../data-types-character-sets-and-collations/index&quot;&gt;문자 세트 및 데이터 정렬&lt;/a&gt; 의 비 이진 문자열입니다 .</target>
        </trans-unit>
        <trans-unit id="d2d50d69ce9f245c2ccdaa97d510867db381e72b" translate="yes" xml:space="preserve">
          <source>The return value is always positive, even if a negative &lt;code&gt;TIME&lt;/code&gt; value is provided.</source>
          <target state="translated">음수 &lt;code&gt;TIME&lt;/code&gt; 값이 제공 되더라도 리턴 값은 항상 양수 입니다.</target>
        </trans-unit>
        <trans-unit id="9e134dcff74b4fc62eb577bb6ad735535f561673" translate="yes" xml:space="preserve">
          <source>The return value is suitable for</source>
          <target state="translated">반환 값은</target>
        </trans-unit>
        <trans-unit id="04a582e2f007607fff7c36a573a89a03792039eb" translate="yes" xml:space="preserve">
          <source>The return value's &lt;a href=&quot;../data-types/index&quot;&gt;data type&lt;/a&gt; (for stored functions).</source>
          <target state="translated">반환 값의 &lt;a href=&quot;../data-types/index&quot;&gt;데이터 형식&lt;/a&gt; (저장된 함수의 경우)</target>
        </trans-unit>
        <trans-unit id="a8e7f7fccd6013b61e6ff6c0379d5e12b04cf205" translate="yes" xml:space="preserve">
          <source>The returned (eventually error) message.</source>
          <target state="translated">반환 된 (결과적으로 오류) 메시지.</target>
        </trans-unit>
        <trans-unit id="17d11cb3df06a966daeaef12aa800b080ead9fc9" translate="yes" xml:space="preserve">
          <source>The returned array can be applied other functions. For instance, to get the number of occurrences of an item in a json tree, you can do:</source>
          <target state="translated">반환 된 배열은 다른 함수에 적용될 수 있습니다. 예를 들어, json 트리에서 항목의 발생 횟수를 얻으려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="9fd33f694cd5dbba141a79722f76ae5ba0615df1" translate="yes" xml:space="preserve">
          <source>The returned binary string will be &lt;a href=&quot;../varbinary/index&quot;&gt;VARBINARY(16)&lt;/a&gt; or &lt;a href=&quot;../varbinary/index&quot;&gt;VARBINARY(4)&lt;/a&gt; for IPv6 and IPv4 addresses respectively.</source>
          <target state="translated">반환 된 이진 문자열은 각각 IPv6 및 IPv4 주소에 대해 &lt;a href=&quot;../varbinary/index&quot;&gt;VARBINARY (16)&lt;/a&gt; 또는 &lt;a href=&quot;../varbinary/index&quot;&gt;VARBINARY (4)&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cf022198a51c52421f12688e22624f52d49cd347" translate="yes" xml:space="preserve">
          <source>The returned string value is the created file name. If not specified as an argument, the file name can in some cases be retrieved from the first argument; in such cases the file itself is modified.</source>
          <target state="translated">리턴 된 문자열 값은 작성된 파일 이름입니다. 인수로 지정하지 않으면 파일 이름을 첫 번째 인수에서 검색 할 수 있습니다. 이러한 경우 파일 자체가 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="3b795ace3381e7135bc762300597bcdebc02c56e" translate="yes" xml:space="preserve">
          <source>The reverse function, &lt;a href=&quot;../from_base64/index&quot;&gt;FROM_BASE64()&lt;/a&gt;, decodes an encoded base-64 string.</source>
          <target state="translated">역방향 함수 &lt;a href=&quot;../from_base64/index&quot;&gt;FROM_BASE64 ()는&lt;/a&gt; 인코딩 된베이스 캐릭터 (64)를 디코딩한다.</target>
        </trans-unit>
        <trans-unit id="68a10d6331d7396759735fcac87208862c9517ce" translate="yes" xml:space="preserve">
          <source>The reverse of &lt;code&gt;SELECT INTO OUTFILE&lt;/code&gt; is &lt;a href=&quot;../load-data-into-tables-or-index/index&quot;&gt;LOAD DATA&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;SELECT INTO OUTFILE&lt;/code&gt; 의 역순 은 &lt;a href=&quot;../load-data-into-tables-or-index/index&quot;&gt;LOAD DATA&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6c090a3485d0cb2dc85622ea5da8881b1e5624a0" translate="yes" xml:space="preserve">
          <source>The role of &lt;code&gt;.frm&lt;/code&gt; files</source>
          <target state="translated">&lt;code&gt;.frm&lt;/code&gt; 파일 의 역할</target>
        </trans-unit>
        <trans-unit id="afc4e1fc2bcf43f8319197eca6fdf756c8c9312f" translate="yes" xml:space="preserve">
          <source>The roles that the current user can enable are listed in the &lt;a href=&quot;../information-schema-applicable_roles-table/index&quot;&gt;APPLICABLE_ROLES&lt;/a&gt; Information Schema table.</source>
          <target state="translated">현재 사용자가 사용할 수있는 역할은 &lt;a href=&quot;../information-schema-applicable_roles-table/index&quot;&gt;APPLICABLE_ROLES&lt;/a&gt; 정보 스키마 테이블에 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="444b643d6fad9d7c1b18d9babb797f613f80b786" translate="yes" xml:space="preserve">
          <source>The root cause is that InnoDB has a maximum row size that is roughly equivalent to half of the value of the &lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_page_size&quot;&gt;innodb_page_size&lt;/a&gt;&lt;/code&gt; system variable. See &lt;a href=&quot;../innodb-row-formats-overview/index#maximum-row-size&quot;&gt;InnoDB Row Formats Overview: Maximum Row Size&lt;/a&gt; for more information.</source>
          <target state="translated">근본 원인은 InnoDB의 최대 행 크기가 &lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_page_size&quot;&gt;innodb_page_size&lt;/a&gt;&lt;/code&gt; 시스템 변수 값의 절반에 해당하는 것 입니다. 자세한 내용은 &lt;a href=&quot;../innodb-row-formats-overview/index#maximum-row-size&quot;&gt;InnoDB 행 형식 개요 : 최대 행 크기&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="53501ce9a06b5c989cbba17f4b0ca775753fc860" translate="yes" xml:space="preserve">
          <source>The root/non-root password for the nodes (all nodes must have the same root/non-root password or root/non-root ssh keys must be set up between servers). MariaDB ColumnStore can be installed as root or a non-root user.</source>
          <target state="translated">노드의 루트 / 비 루트 비밀번호 (모든 노드는 동일한 루트 / 비 루트 비밀번호를 가지고 있거나 루트 / 비 루트 ssh 키는 서버간에 설정해야합니다). MariaDB ColumnStore는 루트 또는 비 루트 사용자로 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1fb178f01962f7468e13e0552f07f2290d8c4efc" translate="yes" xml:space="preserve">
          <source>The routine parameters for a 'block' could have be start of this block and start of next block.</source>
          <target state="translated">'블록'에 대한 루틴 매개 변수는이 블록의 시작과 다음 블록의 시작일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53f9e0b574901a26cab7ec6f046e6701ce358334" translate="yes" xml:space="preserve">
          <source>The routine privilege. See &lt;a href=&quot;../grant/index#function-privileges&quot;&gt;Function Privileges&lt;/a&gt; and &lt;a href=&quot;../grant/index#procedure-privileges&quot;&gt;Procedure Privileges&lt;/a&gt; for details.</source>
          <target state="translated">일상적인 특권. 자세한 내용은 &lt;a href=&quot;../grant/index#function-privileges&quot;&gt;기능 권한&lt;/a&gt; 및 &lt;a href=&quot;../grant/index#procedure-privileges&quot;&gt;절차 권한&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3346c61b4b4e985e562c5a22a362a1abbec0c3e3" translate="yes" xml:space="preserve">
          <source>The routine_body consists of a valid SQL procedure statement. This can be a simple statement such as &lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt; or &lt;a href=&quot;../insert/index&quot;&gt;INSERT&lt;/a&gt;, or it can be a compound statement written using &lt;a href=&quot;../begin-end/index&quot;&gt;BEGIN and END&lt;/a&gt;. Compound statements can contain declarations, loops, and other control structure statements. See &lt;a href=&quot;../programmatic-and-compound-statements/index&quot;&gt;Programmatic and Compound Statements&lt;/a&gt; for syntax details.</source>
          <target state="translated">routine_body는 유효한 SQL 프로 시저 명령문으로 구성됩니다. &lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt; 또는 &lt;a href=&quot;../insert/index&quot;&gt;INSERT&lt;/a&gt; 와 같은 간단한 명령문 이거나 &lt;a href=&quot;../begin-end/index&quot;&gt;BEGIN 및 END를&lt;/a&gt; 사용하여 작성된 복합 명령문 일 수 있습니다 . 복합 문에는 선언, 루프 및 기타 제어 구조 문이 포함될 수 있습니다. 구문 세부 사항 은 &lt;a href=&quot;../programmatic-and-compound-statements/index&quot;&gt;프로그램 및 복합 명령문&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="687f62a630be3d53fc3d949803c4e4ebec37a82a" translate="yes" xml:space="preserve">
          <source>The row id (1 to 8,388,608) within the column's extent</source>
          <target state="translated">열 범위 내 행 ID (1-8,388,608)</target>
        </trans-unit>
        <trans-unit id="c0f739a8072fd63a71c49d462dcdaca4819f0cb8" translate="yes" xml:space="preserve">
          <source>The row nodes are by default the children of the table node. However, for instance to eliminate some children nodes that are not real row nodes, the row node name can be specified using the &lt;code&gt;rownode&lt;/code&gt; sub-option of the &lt;code&gt;option_list&lt;/code&gt; option.</source>
          <target state="translated">행 노드는 기본적으로 테이블 노드의 하위입니다. 그러나 실제 행 노드가 아닌 일부 하위 노드를 제거하기 위해 &lt;code&gt;option_list&lt;/code&gt; 옵션 의 &lt;code&gt;rownode&lt;/code&gt; 하위 옵션을 사용하여 행 노드 이름을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8226f93addd3c218454a4d237593b0bf45424e30" translate="yes" xml:space="preserve">
          <source>The row ordinal number in the file. This is different from ROWID for multiple tables, TBL/XCOL/OCCUR/PIVOT tables, XML tables with a multiple column, and for DBF tables where ROWNUM includes soft deleted rows.</source>
          <target state="translated">파일의 행 서수. 이는 다중 테이블, TBL / XCOL / OCCUR / PIVOT 테이블, 다중 컬럼이있는 XML 테이블 및 ROWNUM에 소프트 삭제 된 행이 포함 된 DBF 테이블의 경우 ROWID와 다릅니다.</target>
        </trans-unit>
        <trans-unit id="e32b678b19a21f3c15baf03b0487001075143fa6" translate="yes" xml:space="preserve">
          <source>The row ordinal number in the table. This is not quite equivalent to a virtual column with an auto increment of 1 because rows are renumbered when deleting rows.</source>
          <target state="translated">테이블의 행 서수. 행을 삭제할 때 행의 번호가 재 지정되므로 자동 증분이 1 인 가상 열과는 다릅니다.</target>
        </trans-unit>
        <trans-unit id="fdb51e08b7c3d6f7271e799fb3dcbef30c238e0e" translate="yes" xml:space="preserve">
          <source>The row/s affected value is reported as 1 if a row is inserted, and 2 if a row is updated, unless the API's &lt;code&gt;CLIENT_FOUND_ROWS&lt;/code&gt; flag is set.</source>
          <target state="translated">API의 &lt;code&gt;CLIENT_FOUND_ROWS&lt;/code&gt; 플래그가 설정되어 있지 않으면 행이 삽입되면 영향을받는 행 값은 1로, 행이 업데이트되면 2 로보고 됩니다.</target>
        </trans-unit>
        <trans-unit id="ca98eb76ccca8e7a08cfe86ae0cd2a49a1dfc085" translate="yes" xml:space="preserve">
          <source>The rows will be distributed in the different sub-tables according to the partition function. This can be seen by executing the query:</source>
          <target state="translated">파티션 기능에 따라 행이 다른 서브 테이블에 분배됩니다. 이것은 쿼리를 실행하여 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ad5a963b0622ee1227800dcbf2dd7f9b24f4ef8" translate="yes" xml:space="preserve">
          <source>The rows will be ordered, &quot;closest&quot; first.</source>
          <target state="translated">행은 &quot;가장 가까운&quot;순서로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="e49d5ca9fece6613c94830e9b076b0973a5d65ba" translate="yes" xml:space="preserve">
          <source>The rows will be sorted according to &lt;code&gt;Connection_name&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Connection_name&lt;/code&gt; 에 따라 행이 정렬됩니다 .</target>
        </trans-unit>
        <trans-unit id="12a811eb56df5c15ffc57dd3f966eb57babffe1b" translate="yes" xml:space="preserve">
          <source>The rule is that for each partition the matching file name is internally generated by replacing in the given FILE _ NAME option value the &amp;ldquo;%s&amp;rdquo; part by the partition name.</source>
          <target state="translated">규칙은 각 파티션에 대해 지정된 FILE _ NAME 옵션 값에서&amp;ldquo;% s&amp;rdquo;부분을 파티션 이름으로 바꾸어 일치하는 파일 이름을 내부적으로 생성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3ea3d001f765101bc5e5540d389df1a344d34540" translate="yes" xml:space="preserve">
          <source>The same change needs to be made to the mysqladmin command below in the wait_for_ready() function so that the mariadb start command can properly listen for the server start. In the &lt;strong&gt;wait_for_ready()&lt;/strong&gt; function, after &lt;strong&gt;$bindir/mysqladmin&lt;/strong&gt; add &lt;strong&gt;--defaults-file=/opt/mariadb-data/my.cnf&lt;/strong&gt;. The lines should look like:</source>
          <target state="translated">mariadb start 명령이 서버 시작을 올바르게 수신 할 수 있도록 wait_for_ready () 함수에서 아래의 mysqladmin 명령을 동일하게 변경해야합니다. 에서 &lt;strong&gt;wait_for_ready ()&lt;/strong&gt; 함수 후 &lt;strong&gt;$ BINDIR / mysqladmin 데이터의&lt;/strong&gt; 추가 &lt;strong&gt;--defaults-파일 = / 옵션 / mariadb 데이터 / my.cnf 파일&lt;/strong&gt; . 줄은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="c75912a7b1cdef25b21771d435dce79df915dc58" translate="yes" xml:space="preserve">
          <source>The same information can be queried from the &lt;code&gt;&lt;a href=&quot;../information-schema-character_sets-table/index&quot;&gt;information_schema.CHARACTER_SETS&lt;/a&gt;&lt;/code&gt; table.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../information-schema-character_sets-table/index&quot;&gt;information_schema.CHARACTER_SETS&lt;/a&gt;&lt;/code&gt; 테이블 에서 동일한 정보를 쿼리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="8c63dd682e08bec02028145b313d4e70ba9ef794" translate="yes" xml:space="preserve">
          <source>The same information can be queried from the &lt;code&gt;&lt;a href=&quot;../information-schema-collations-table/index&quot;&gt;information_schema.COLLATIONS&lt;/a&gt;&lt;/code&gt; table.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../information-schema-collations-table/index&quot;&gt;information_schema.COLLATIONS&lt;/a&gt;&lt;/code&gt; 테이블 에서 동일한 정보를 쿼리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="d8779a3cb084b0c7d123f4537ddfaaf69b165ae4" translate="yes" xml:space="preserve">
          <source>The same information in a different format can be found in the &lt;code&gt;&lt;a href=&quot;../mysqldb-table/index&quot;&gt;mysql.db&lt;/a&gt;&lt;/code&gt; table.</source>
          <target state="translated">다른 형식의 동일한 정보는 &lt;code&gt;&lt;a href=&quot;../mysqldb-table/index&quot;&gt;mysql.db&lt;/a&gt;&lt;/code&gt; 테이블 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="aa0b98caa835ee61a5fed8a7226ad1cbd82d279d" translate="yes" xml:space="preserve">
          <source>The same methods described for ODBC tables can be used with JDBC tables.</source>
          <target state="translated">ODBC 테이블에 대해 설명한 것과 동일한 방법을 JDBC 테이블과 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d38c3fb5370c86e5700e8e33d7f53105cf7f2437" translate="yes" xml:space="preserve">
          <source>The same occurs with other types of select statements, for instance:</source>
          <target state="translated">다른 유형의 select 문에서도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="204956c3bd54a087b69c71a00fc6d0ab019cd28c" translate="yes" xml:space="preserve">
          <source>The same option group can appear multiple times.</source>
          <target state="translated">동일한 옵션 그룹이 여러 번 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d49bcc0c4265ddd5b4155fa4ae7992990fe8c26d" translate="yes" xml:space="preserve">
          <source>The same options may also enable TLS on non-standard &lt;a href=&quot;../clients-utilities/index&quot;&gt;clients and utilities&lt;/a&gt; that are linked with either &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.5/en/c-api.html&quot;&gt;libmysqlclient&lt;/a&gt; or &lt;a href=&quot;../mariadb-connector-c/index&quot;&gt;MariaDB Connector/C&lt;/a&gt;.</source>
          <target state="translated">동일한 옵션 으로 &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.5/en/c-api.html&quot;&gt;libmysqlclient&lt;/a&gt; 또는 &lt;a href=&quot;../mariadb-connector-c/index&quot;&gt;MariaDB Connector / C&lt;/a&gt; 와 연결된 비표준 &lt;a href=&quot;../clients-utilities/index&quot;&gt;클라이언트 및 유틸리티&lt;/a&gt; 에서도 TLS를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f57a4c8144ba3ad4d55bbc2510bf0f040913ba99" translate="yes" xml:space="preserve">
          <source>The same outcome, formulated as a Groonga query:</source>
          <target state="translated">동일한 결과가 Groonga 쿼리로 공식화되었습니다.</target>
        </trans-unit>
        <trans-unit id="872aede6507a57d2c9e2181b030995541e99cb07" translate="yes" xml:space="preserve">
          <source>The same procedure can be used if MariaDB starts but SELinux prevents it from functioning correctly. For example, SELinux may prevent &lt;a href=&quot;../pam-authentication-plugin/index&quot;&gt;PAM plugin&lt;/a&gt; from authenticating users. The solution is the same &amp;mdash; enable auditing, switch to permissive, do, whatever SELinux didn't allow you to, create a policy from the audit log.</source>
          <target state="translated">MariaDB가 시작되지만 SELinux가 올바르게 작동하지 못하게하는 경우 동일한 절차를 사용할 수 있습니다. 예를 들어 SELinux는 &lt;a href=&quot;../pam-authentication-plugin/index&quot;&gt;PAM 플러그인&lt;/a&gt; 이 사용자를 인증 하지 못하게 할 수 있습니다 . 솔루션은 동일합니다. 감사를 활성화하고, 허용으로 전환하고, SELinux가 허용하지 않은 모든 것을 감사 로그에서 정책을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="04d6ffb62bb94d4239476195d11d4470ebda8e9d" translate="yes" xml:space="preserve">
          <source>The same result can be obtained with json columns using the json UDF&amp;rsquo;s:</source>
          <target state="translated">json UDF를 사용하여 json 열에서 동일한 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a62dd0e936727afc404f2ac5d28ba0ebf957a8bb" translate="yes" xml:space="preserve">
          <source>The same rules apply when upgrading MariaDB; When upgrading, first take down MariaDB in a clean way and then upgrade. This will allow you to remove the old log files if there are incompatible problems between releases.</source>
          <target state="translated">MariaDB를 업그레이드 할 때도 동일한 규칙이 적용됩니다. 업그레이드 할 때는 먼저 MariaDB를 깔끔하게 정리 한 다음 업그레이드하십시오. 릴리스간에 호환되지 않는 문제가있는 경우 이전 로그 파일을 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d939b9d47b0f5a0fcb2b95e42b346cf8bc9be90d" translate="yes" xml:space="preserve">
          <source>The same sequence table can maintain separate sequences for multiple tables (or separate sequences for different fields in the same table) by adding extra rows.</source>
          <target state="translated">동일한 시퀀스 테이블은 추가 행을 추가하여 여러 테이블에 대해 별도의 시퀀스를 유지하거나 동일한 테이블에서 서로 다른 필드에 대해 별도의 시퀀스를 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="958f6bd9c20264dfb03f6c46729de16865dee7fa" translate="yes" xml:space="preserve">
          <source>The same system could allocate a customer ID for each customer record, and in this case a NULL value would not be permitted.</source>
          <target state="translated">동일한 시스템이 각 고객 레코드에 대해 고객 ID를 할당 할 수 있으며이 경우 NULL 값은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a87234d15cbea511dcaab012505b06d47ab07d6a" translate="yes" xml:space="preserve">
          <source>The same thing using the optional &lt;code&gt;IF EXISTS&lt;/code&gt; clause:</source>
          <target state="translated">선택적인 &lt;code&gt;IF EXISTS&lt;/code&gt; 절을 사용하는 것과 같은 것 :</target>
        </trans-unit>
        <trans-unit id="7ccc54c645166f10971d08b7b976a620fd481a7a" translate="yes" xml:space="preserve">
          <source>The same usb stick (or CD/DVD media) can be used to install a complete server installation onto the harddisk drive using the included Debian installer.</source>
          <target state="translated">동일한 USB 스틱 (또는 CD / DVD 매체)을 사용하여 포함 된 데비안 설치 프로그램을 사용하여 하드 디스크 드라이브에 완전한 서버 설치를 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24cc744fb1fcf09050cf4eb445a12d9159bb03d6" translate="yes" xml:space="preserve">
          <source>The sample configuration file documents the available options. You will need to make at least a few changes. A MariaDB user with permission to access the database must be created. For example:</source>
          <target state="translated">샘플 구성 파일은 사용 가능한 옵션을 문서화합니다. 최소한 몇 가지를 변경해야합니다. 데이터베이스 액세스 권한이있는 MariaDB 사용자를 작성해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dbcf041d52d5aca88363f95a47b7a6ecf58af10f" translate="yes" xml:space="preserve">
          <source>The sample covariance for non-null pairs in a group.</source>
          <target state="translated">그룹에서 null이 아닌 쌍에 대한 표본 공분산입니다.</target>
        </trans-unit>
        <trans-unit id="27e31a56389fc381a8e8f184be379a6a57a14503" translate="yes" xml:space="preserve">
          <source>The sample queries were drawn from &amp;ldquo;Anchor Modeling&amp;rdquo;, a database modeling technique which takes normalization to the extreme. The &lt;a href=&quot;http://www.anchormodeling.com/tiedostot/SU_KTH_Course_Presentation.pdf&quot;&gt;slides&lt;/a&gt; at the &lt;a href=&quot;http://www.anchormodeling.com&quot;&gt;anchor modeling website&lt;/a&gt; have an in-depth explanation of Anchor modeling and its merits, but the part that's important for table elimination can be shown with an example.</source>
          <target state="translated">샘플 쿼리는 데이터베이스 모델링 기술인 &quot;앵커 모델링&quot;에서 가져 왔습니다. &lt;a href=&quot;http://www.anchormodeling.com/tiedostot/SU_KTH_Course_Presentation.pdf&quot;&gt;슬라이드&lt;/a&gt; 상기 &lt;a href=&quot;http://www.anchormodeling.com&quot;&gt;앵커 모델링 웹 사이트&lt;/a&gt; 앵커 모델링 및 그 장점에 대한 자세한 설명이 있지만 테이블 제거에 중요한 부분은 예제와 함께 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2265c8e447c49e7bcd4025ad239a337f92ec7994" translate="yes" xml:space="preserve">
          <source>The sample standard deviation of a numeric (INT variations, NUMERIC, DECIMAL) column</source>
          <target state="translated">숫자 (INT 변형, NUMERIC, DECIMAL) 열의 표본 표준 편차</target>
        </trans-unit>
        <trans-unit id="cae66626d5602986bf1332a5aef118c9f3e1e205" translate="yes" xml:space="preserve">
          <source>The schema (database) name.</source>
          <target state="translated">스키마 (데이터베이스) 이름</target>
        </trans-unit>
        <trans-unit id="7737771f968bc23d196daea14f510640d3bd7531" translate="yes" xml:space="preserve">
          <source>The schema, sample data, and queries are available as an attachment to this article.</source>
          <target state="translated">스키마, 샘플 데이터 및 쿼리는이 기사의 첨부 파일로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="360702e11fa0456fe336b0133bcb2ae1b68263d4" translate="yes" xml:space="preserve">
          <source>The scope of a local variable is within the &lt;code&gt;BEGIN ... END&lt;/code&gt; block where it is declared. The variable can be referred to in blocks nested within the declaring block, except those blocks that declare a variable with the same name.</source>
          <target state="translated">지역 변수의 범위 는 선언 된 &lt;code&gt;BEGIN ... END&lt;/code&gt; 블록 내에 있습니다. 변수는 이름이 같은 변수를 선언하는 블록을 제외하고 선언 블록 내에 중첩 된 블록에서 참조 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8dd3b8910090337dcf693691feb360f1f3623fb" translate="yes" xml:space="preserve">
          <source>The scope of a prepared statement is the session within which it is created. Other sessions cannot see it.</source>
          <target state="translated">준비된 명령문의 범위는 작성되는 세션입니다. 다른 세션에서는 볼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b44d47b0650cafd7ef6ffb988de1cc0c6dceccb5" translate="yes" xml:space="preserve">
          <source>The script &lt;em&gt;quick_installer_multi_server.sh&lt;/em&gt; provides a simple 1 step install of MariaDB ColumnStore bypassing the interactive wizard style interface and works for both root and non-root installs.</source>
          <target state="translated">&lt;em&gt;quick_installer_multi_server.sh&lt;/em&gt; 스크립트 는 대화식 마법사 스타일 인터페이스를 우회하여 MariaDB ColumnStore의 간단한 1 단계 설치를 제공하며 루트 및 비 루트 설치 모두에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="ca470637097987f60070df288aca294da6b77cbe" translate="yes" xml:space="preserve">
          <source>The script below will install the Docker repositories, required kernel modules and packages on the most common Linux distributions:</source>
          <target state="translated">아래 스크립트는 가장 일반적인 Linux 배포판에 Docker 저장소, 필수 커널 모듈 및 패키지를 설치합니다.</target>
        </trans-unit>
        <trans-unit id="7266cb70e4624128888cf4780f93961778a64c82" translate="yes" xml:space="preserve">
          <source>The script can also configure your system to install from the repository of a different version of MariaDB MaxScale if you use the &lt;code&gt;--mariadb-maxscale-version&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;--mariadb-maxscale-version&lt;/code&gt; 옵션 을 사용하는 경우 스크립트는 다른 버전의 MariaDB MaxScale 저장소에서 설치하도록 시스템을 구성 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="836d348bbae10be321013300cc5743c8d4be7515" translate="yes" xml:space="preserve">
          <source>The script can also configure your system to install from the repository of a different version of MariaDB MaxScale if you use the &lt;code&gt;&lt;a href=&quot;#-mariadb-maxscale-version&quot;&gt;--mariadb-maxscale-version&lt;/a&gt;&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#-mariadb-maxscale-version&quot;&gt;--mariadb-maxscale-version&lt;/a&gt;&lt;/code&gt; 옵션 을 사용하는 경우 스크립트는 다른 버전의 MariaDB MaxScale 저장소에서 설치하도록 시스템을 구성 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="11b939d2a9551d5d13a310856eee8ac67a3a34f3" translate="yes" xml:space="preserve">
          <source>The script can also configure your system to install from the repository of a different version of MariaDB if you use the &lt;code&gt;--mariadb-server-version&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;--mariadb-server-version&lt;/code&gt; 옵션 을 사용하는 경우 스크립트는 다른 버전의 MariaDB의 저장소에서 설치하도록 시스템을 구성 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cbffa20a98755fe2daf86909692d2f841ad8c274" translate="yes" xml:space="preserve">
          <source>The script can also configure your system to install from the repository of a different version of MariaDB if you use the &lt;code&gt;&lt;a href=&quot;#-mariadb-server-version&quot;&gt;--mariadb-server-version&lt;/a&gt;&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#-mariadb-server-version&quot;&gt;--mariadb-server-version&lt;/a&gt;&lt;/code&gt; 옵션 을 사용하는 경우 스크립트는 다른 버전의 MariaDB의 저장소에서 설치하도록 시스템을 구성 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a73e685e90cbb1e77606d2b04bd7aae7e997639c" translate="yes" xml:space="preserve">
          <source>The script can be executed in the following way:</source>
          <target state="translated">스크립트는 다음과 같은 방식으로 실행될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6316921ff85d48aa4f5fdf365360dc9197a790c8" translate="yes" xml:space="preserve">
          <source>The script can take several parameters. However, all are optional</source>
          <target state="translated">스크립트는 몇 가지 매개 변수를 사용할 수 있습니다. 그러나 모두 선택 사항입니다</target>
        </trans-unit>
        <trans-unit id="b602aa382fbb753afea66c87a745c657c1bcaea8" translate="yes" xml:space="preserve">
          <source>The script has 4 parameters.</source>
          <target state="translated">스크립트에는 4 개의 매개 변수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6e9920b06df0244a5e27d8f97764c7a611057c7" translate="yes" xml:space="preserve">
          <source>The script quick_installer_single_server.sh provides a simple 1 step install of MariaDB ColumnStore bypassing the interactive wizard style interface and works for both root and non-root installs.</source>
          <target state="translated">quick_installer_single_server.sh 스크립트는 대화식 마법사 스타일 인터페이스를 우회하여 MariaDB ColumnStore의 간단한 1 단계 설치를 제공하며 루트 및 비 루트 설치 모두에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="4b1b445de89da7e7637f72094d299642b2a25992" translate="yes" xml:space="preserve">
          <source>The script supports Linux distributions that are officially supported by MariaDB Corporation's &lt;a href=&quot;https://mariadb.com/products/mariadb-platform-transactional/&quot;&gt;MariaDB TX subscription&lt;/a&gt;. However, a MariaDB TX subscription with MariaDB Corporation is not required to use the MariaDB Package Repository.</source>
          <target state="translated">이 스크립트는 MariaDB Corporation의 &lt;a href=&quot;https://mariadb.com/products/mariadb-platform-transactional/&quot;&gt;MariaDB TX 구독&lt;/a&gt; 에서 공식적으로 지원되는 Linux 배포판을 지원합니다 . 그러나 MariaDB Corporation을 통한 MariaDB TX 구독은 MariaDB 패키지 리포지토리를 사용할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="b0f25ab02527c724a1b8309730819727bfb3ff90" translate="yes" xml:space="preserve">
          <source>The script will also install the GPG public keys used to verify the signature of MariaDB software packages. If you want to avoid that, then you can use the &lt;code&gt;--skip-key-import&lt;/code&gt; option.</source>
          <target state="translated">이 스크립트는 MariaDB 소프트웨어 패키지의 서명을 확인하는 데 사용되는 GPG 공개 키도 설치합니다. 이를 피하려면 &lt;code&gt;--skip-key-import&lt;/code&gt; 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e02e8527ef3c5c45883ce80a965f85007fcb6db7" translate="yes" xml:space="preserve">
          <source>The script will have to set up package repository configuration files, so it will need to be executed as root.</source>
          <target state="translated">스크립트는 패키지 저장소 구성 파일을 설정해야하므로 루트로 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="6cbf4125ee2302a4ed90c4c7ee6184f1c94fcded" translate="yes" xml:space="preserve">
          <source>The script will prompt you to determine which actions to perform.</source>
          <target state="translated">수행 할 작업을 결정하라는 메시지가 스크립트에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="0c30135c8f87f26d14bc2850c5e72a6424552d86" translate="yes" xml:space="preserve">
          <source>The script will then perform an equivalent installation to running postConfigure with the arguments: It will perform an install with these defaults:</source>
          <target state="translated">그런 다음 스크립트는 인수를 사용하여 postConfigure를 실행하는 것과 동등한 설치를 수행합니다. 다음 기본값으로 설치를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="f3aad3e19cd4b498dcca91c5e25bf130a13d6f02" translate="yes" xml:space="preserve">
          <source>The script will will set up 3 different repositories in a single repository configuration file.</source>
          <target state="translated">이 스크립트는 단일 리포지토리 구성 파일에 3 개의 서로 다른 리포지토리를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="6f9bd734980e29a5ae00194d87ec84201c18b725" translate="yes" xml:space="preserve">
          <source>The script will will set up 3 different repositories in a single repository configuration file. The repositories are</source>
          <target state="translated">이 스크립트는 단일 리포지토리 구성 파일에 3 개의 서로 다른 리포지토리를 설정합니다. 리포지토리는</target>
        </trans-unit>
        <trans-unit id="d014432c5c1837d1f625c73580c8f74bcabc7561" translate="yes" xml:space="preserve">
          <source>The scripts are of type 'compile-#cpu#-how_to_build'. Some common scripts-are</source>
          <target state="translated">스크립트는 'compile- # cpu # -how_to_build'유형입니다. 몇 가지 일반적인 스크립트는</target>
        </trans-unit>
        <trans-unit id="b0b50c55b126f4d026a570bfa00e53012b7c706e" translate="yes" xml:space="preserve">
          <source>The scripts do not play nice with non-bash shells such as the Korn Shell (ksh). So if your /bin/sh is pointing at ksh or ksh93, you'll want to change it so that it points at bash.</source>
          <target state="translated">스크립트는 Korn Shell (ksh)과 같은 비 bash 쉘에서는 훌륭하지 않습니다. 따라서 / bin / sh가 ksh 또는 ksh93을 가리키는 경우 bash를 가리 키도록 변경하고 싶을 것입니다.</target>
        </trans-unit>
        <trans-unit id="643a87b1516e95cd27330d5a812f8995b9fc0e60" translate="yes" xml:space="preserve">
          <source>The search for columns in sub tables is done by name and, if they exist with a different name, by their position given by a not null &lt;code&gt;FLAG&lt;/code&gt; option. Column &lt;em&gt;sex&lt;/em&gt; exists only in the English table (&lt;code&gt;FLAG&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;). Its values will null value for the French table.</source>
          <target state="translated">하위 테이블에서 열을 검색하는 작업은 이름 및 다른 이름으로 존재하는 경우 null이 아닌 &lt;code&gt;FLAG&lt;/code&gt; 옵션으로 지정된 위치에 따라 수행됩니다 . 컬럼 &lt;em&gt;섹스&lt;/em&gt; 는 영어 테이블에만 존재합니다 ( &lt;code&gt;FLAG&lt;/code&gt; 는 &lt;code&gt;0&lt;/code&gt; ). 프랑스어 테이블의 값은 널값입니다.</target>
        </trans-unit>
        <trans-unit id="6b680a4f4d06547a3bca55714551484b73cb228a" translate="yes" xml:space="preserve">
          <source>The second (and subsequent) table will be reached into based on the ON clause. (Instead of using commajoin, please write JOINs with the JOIN keyword and ON clause!) In addition, there could be parts of the WHERE clause that are relevant. GROUP/ORDER BY are not to be considered in writing the optimal INDEX for subsequent tables.</source>
          <target state="translated">두 번째 (및 그 이후의) 테이블은 ON 절을 기반으로합니다. (쉼표를 사용하는 대신 JOIN 키워드 및 ON 절을 사용하여 JOIN을 작성하십시오!) 또한 WHERE 절의 일부가 관련 될 수 있습니다. 후속 테이블에 대한 최적의 INDEX를 작성할 때는 GROUP / ORDER BY를 고려하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="f1b79be2df48c6a3a37c87b9b637a7eb2042e25b" translate="yes" xml:space="preserve">
          <source>The second command added text to the &lt;code&gt;/etc/apt/sources.list&lt;/code&gt; file. One of these lines is the repository containing binary packages for MariaDB, the other contains the source packages. The line for the source packages is commented out by default. Open the file using your preferred text editor and uncomment the source repository.</source>
          <target state="translated">두 번째 명령은 &lt;code&gt;/etc/apt/sources.list&lt;/code&gt; 에 텍스트를 추가했습니다. 파일에 . 이 라인 중 하나는 MariaDB 용 바이너리 패키지를 포함하는 저장소이고 다른 하나는 소스 패키지를 포함합니다. 소스 패키지 라인은 기본적으로 주석 처리됩니다. 원하는 텍스트 편집기를 사용하여 파일을 열고 소스 저장소의 주석을 해제하십시오.</target>
        </trans-unit>
        <trans-unit id="51b0b14baaab346e385dae802aae20855cf993eb" translate="yes" xml:space="preserve">
          <source>The second form allows the use of an integer value for days. In such cases, it is interpreted as the number of days to be subtracted from the date or datetime expression expr.</source>
          <target state="translated">두 번째 형식은 며칠 동안 정수 값을 사용할 수있게합니다. 이러한 경우 날짜 또는 날짜 / 시간 표현식 expr에서 빼는 일 수로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="1987a0ca7a85db6fdf651a93bb2c4afb5207b928" translate="yes" xml:space="preserve">
          <source>The second method can be used to tell the server to load the plugin when it starts up. The plugin can be installed this way by providing the &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-plugin-load&quot;&gt;--plugin-load&lt;/a&gt;&lt;/code&gt; or the &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-plugin-load-add&quot;&gt;--plugin-load-add&lt;/a&gt;&lt;/code&gt; options. This can be specified as a command-line argument to &lt;code&gt;&lt;a href=&quot;../mysqld-options/index&quot;&gt;mysqld&lt;/a&gt;&lt;/code&gt; or it can be specified in a relevant server &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;option group&lt;/a&gt; in an &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;option file&lt;/a&gt;.</source>
          <target state="translated">두 번째 방법은 플러그인이 시작될 때 서버에 플러그인을로드하도록 지시하는 데 사용할 수 있습니다. &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-plugin-load&quot;&gt;--plugin-load&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-plugin-load-add&quot;&gt;--plugin-load-add&lt;/a&gt;&lt;/code&gt; 옵션 을 제공하여 플러그인을 이런 방식으로 설치할 수 있습니다 . 이것은 &lt;code&gt;&lt;a href=&quot;../mysqld-options/index&quot;&gt;mysqld&lt;/a&gt;&lt;/code&gt; 에 대한 명령 행 인수로 지정되거나 &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;옵션 파일&lt;/a&gt; 의 관련 서버 &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;옵션 그룹&lt;/a&gt; 에서 지정 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d2213ba362524200ae4622731f15fa9773f24f25" translate="yes" xml:space="preserve">
          <source>The second method can be used to tell the server to load the plugin when it starts up. The plugin can be installed this way by providing the &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-plugin-load&quot;&gt;--plugin-load&lt;/a&gt;&lt;/code&gt; or the &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-plugin-load-add&quot;&gt;--plugin-load-add&lt;/a&gt;&lt;/code&gt; options. This can be specified as a command-line argument to &lt;code&gt;&lt;a href=&quot;../mysqld-options/index&quot;&gt;mysqld&lt;/a&gt;&lt;/code&gt; or it can be specified in a relevant server &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;option group&lt;/a&gt; in an &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;option file&lt;/a&gt;. For example:</source>
          <target state="translated">두 번째 방법은 플러그인이 시작될 때 서버에 플러그인을로드하도록 지시하는 데 사용할 수 있습니다. &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-plugin-load&quot;&gt;--plugin-load&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-plugin-load-add&quot;&gt;--plugin-load-add&lt;/a&gt;&lt;/code&gt; 옵션 을 제공하여 플러그인을 이런 방식으로 설치할 수 있습니다 . 이것은 &lt;code&gt;&lt;a href=&quot;../mysqld-options/index&quot;&gt;mysqld&lt;/a&gt;&lt;/code&gt; 에 대한 명령 행 인수로 지정되거나 &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;옵션 파일&lt;/a&gt; 의 관련 서버 &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;옵션 그룹&lt;/a&gt; 에서 지정 될 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e7ed1159aaa00f0db670962d622ffee502d22d63" translate="yes" xml:space="preserve">
          <source>The second number is the server ID, the same as is also used in old-style replication. It is a 32-bit unsigned integer.</source>
          <target state="translated">두 번째 숫자는 서버 ID이며 이전 스타일 복제에도 사용됩니다. 부호없는 32 비트 정수입니다.</target>
        </trans-unit>
        <trans-unit id="15b2081a4129739092a65b87f57bdb3c0dc62de7" translate="yes" xml:space="preserve">
          <source>The second one, allowing avoiding too complicated partition names, is to create federated servers to access the remote tables (if they do not already exist, else just use them). For instance the first one could be:</source>
          <target state="translated">너무 복잡한 파티션 이름을 피할 수있는 두 번째 방법은 원격 테이블에 액세스 할 페더 레이 티드 서버를 작성하는 것입니다 (아직없는 경우에는 사용). 예를 들어 첫 번째는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c35b5cbd4a25fea649cf293d7e335d7675f6f8b8" translate="yes" xml:space="preserve">
          <source>The second part of the script performs a remote install of all of the other servers in the system, which is for a multi-node install configuration. The installation of the remote nodes are done simultaneously and the remote install logs are placed in /tmp on 'pm1', i.e. &quot;pm1_installer.log&quot;. The actual log file name will be different based on if you are doing an rpm, debian, or binary install. So if postConfigure reports that a failure occurred during the remote server install phase, you can look at these logs in /tmp. The main reasons why this might fail:</source>
          <target state="translated">스크립트의 두 번째 부분은 시스템에있는 다른 모든 서버 (멀티 노드 설치 구성 용)의 원격 설치를 수행합니다. 원격 노드 설치는 동시에 수행되며 원격 설치 로그는 'pm1'의 / tmp (예 : &quot;pm1_installer.log&quot;)에 있습니다. 실제 로그 파일 이름은 rpm, debian 또는 2 진 설치를 수행 중인지에 따라 다릅니다. 따라서 postConfigure가 원격 서버 설치 단계에서 오류가 발생했다고보고하면 / tmp에서 이러한 로그를 볼 수 있습니다. 이것이 실패 할 수있는 주된 이유 :</target>
        </trans-unit>
        <trans-unit id="94b96f684f029f38398b4cfec4c75b312837f2c0" translate="yes" xml:space="preserve">
          <source>The second query just tests that a columnstore table can be queried correctly and should be updated for your local schema as appropriate.</source>
          <target state="translated">두 번째 쿼리는 columnstore 테이블을 올바르게 쿼리 할 수 ​​있고 로컬 스키마에 맞게 업데이트해야하는지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="582066717695d99020f8c64352d42d4b7c9dfbc0" translate="yes" xml:space="preserve">
          <source>The second query returns:</source>
          <target state="translated">두 번째 쿼리는 다음을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="60d35478fa49b7b29c1e2c8d6854311c9b70d354" translate="yes" xml:space="preserve">
          <source>The second query will be checked. The query cache only checks if SQL_NO_CACHE/SQL_CACHE exists after the first SELECT. (More info at &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-6631&quot;&gt;MDEV-6631&lt;/a&gt;)</source>
          <target state="translated">두 번째 쿼리가 확인됩니다. 쿼리 캐시는 첫 번째 SELECT 이후에 SQL_NO_CACHE / SQL_CACHE가 있는지 확인합니다. ( &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-6631&quot;&gt;MDEV-6631에&lt;/a&gt; 대한 자세한 정보 )</target>
        </trans-unit>
        <trans-unit id="726b3f3de75fc477ebd3e9dd1d4abcb7661b321b" translate="yes" xml:space="preserve">
          <source>The second select (with &lt;code&gt;id=2&lt;/code&gt;) has &lt;code&gt;select_type=MATERIALIZED&lt;/code&gt;. This means it will be executed and its results will be stored in a temporary table with a unique key over all columns. The unique key is there to prevent the table from containing any duplicate records.</source>
          <target state="translated">두 번째 선택 ( &lt;code&gt;id=2&lt;/code&gt; )은 &lt;code&gt;select_type=MATERIALIZED&lt;/code&gt; 입니다. 즉, 실행되고 모든 열에 대해 고유 키가있는 결과가 임시 테이블에 저장됩니다. 고유 키는 테이블에 중복 레코드가 포함되지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="6c5189b8b91444e6e4407263b2088c99c6290572" translate="yes" xml:space="preserve">
          <source>The second variable, &lt;a href=&quot;../server-system-variables/index#disconnect_on_expired_password&quot;&gt;disconnect_on_expired_password&lt;/a&gt; determines whether a client is permitted to connect if their password has expired, or whether they are permitted to connect in sandbox mode, able to perform a limited subset of queries related to resetting the password, in particular &lt;a href=&quot;../set-password/index&quot;&gt;SET PASSWORD&lt;/a&gt; and &lt;a href=&quot;../set/index&quot;&gt;SET&lt;/a&gt;.</source>
          <target state="translated">두 번째 변수 인 &lt;a href=&quot;../server-system-variables/index#disconnect_on_expired_password&quot;&gt;disconnect_on_expired_password&lt;/a&gt; 는 비밀번호가 만료 된 경우 클라이언트의 연결이 허용되는지 또는 샌드 박스 모드에서 연결이 허용되는지, 특히 비밀번호 재설정과 관련된 제한된 쿼리 하위 세트 (특히 &lt;a href=&quot;../set-password/index&quot;&gt;SET PASSWORD&lt;/a&gt; 및 &lt;a href=&quot;../set/index&quot;&gt;SET)&lt;/a&gt; 를 수행 할 수 있는지 여부를 판별합니다. .</target>
        </trans-unit>
        <trans-unit id="05e591c70fa73e837bf9c57d7f8380d0ea6cc538" translate="yes" xml:space="preserve">
          <source>The second way is a simplified way in which ODBC is just given the name of a DSN that must have been defined to ODBC or UnixOdbc and that contains the necessary information to establish the connection. Only the user name and password can be specified out of the DSN specification.</source>
          <target state="translated">두 번째 방법은 ODBC 또는 UnixOdbc에 정의되어 있어야하며 연결을 설정하는 데 필요한 정보가 포함 된 DSN의 이름을 ODBC에 제공하는 단순화 된 방법입니다. DSN 스펙에서 사용자 이름과 비밀번호 만 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64d8a29ca1bdd4ef1c05e4623582b2e5819b59bb" translate="yes" xml:space="preserve">
          <source>The second way is to check the slow query log. When one uses &lt;a href=&quot;../slow-query-log-extended-statistics/index&quot;&gt;Extended statistics in the slow query log&lt;/a&gt; and specifies &lt;a href=&quot;../server-system-variables/index#log_slow_verbosity&quot;&gt;log_slow_verbosity=query_plan&lt;/a&gt;, &lt;a href=&quot;../slow-query-log/index&quot;&gt;slow query log&lt;/a&gt; entries look like this</source>
          <target state="translated">두 번째 방법은 느린 쿼리 로그를 확인하는 것입니다. &lt;a href=&quot;../slow-query-log-extended-statistics/index&quot;&gt;느린 쿼리 로그에서 확장 통계를&lt;/a&gt; 사용 하고 &lt;a href=&quot;../server-system-variables/index#log_slow_verbosity&quot;&gt;log_slow_verbosity = query_plan을&lt;/a&gt; 지정 하면 &lt;a href=&quot;../slow-query-log/index&quot;&gt;느린 쿼리 로그&lt;/a&gt; 항목은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d4cd244cb1c82f55dd2127753ad4e42f9dbc6774" translate="yes" xml:space="preserve">
          <source>The second way to limit the cache is to have a maximum size for each set of query results. This prevents a single query with a huge result set taking up most of the available memory and knocking a large number of smaller queries out of the cache. This is determined by the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#query_cache_limit&quot;&gt;query_cache_limit&lt;/a&gt;&lt;/code&gt; server variable.</source>
          <target state="translated">캐시를 제한하는 두 번째 방법은 각 쿼리 결과 집합에 대해 최대 크기를 갖는 것입니다. 이렇게하면 결과 집합이 큰 단일 쿼리가 사용 가능한 메모리의 대부분을 차지하고 캐시에서 많은 수의 작은 쿼리를 중단하는 것을 방지합니다. 이것은 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#query_cache_limit&quot;&gt;query_cache_limit&lt;/a&gt;&lt;/code&gt; 서버 변수에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="78a6472545a4ff4f83c11904dba1813d1fa030c0" translate="yes" xml:space="preserve">
          <source>The secondary key is effectively (email_id, email), hence 'covering' for certain queries.</source>
          <target state="translated">보조 키는 사실상 (email_id, email) 특정 쿼리에 대해 '덮어 쓰기'입니다.</target>
        </trans-unit>
        <trans-unit id="eba54e43e10a262251ccd41bec970e3a17ce604a" translate="yes" xml:space="preserve">
          <source>The segment ID for the extent</source>
          <target state="translated">익스텐트의 세그먼트 ID</target>
        </trans-unit>
        <trans-unit id="5ba08fb42ac36264a83cd20929baaf6fcba62683" translate="yes" xml:space="preserve">
          <source>The select query replies:</source>
          <target state="translated">선택 쿼리가 응답합니다.</target>
        </trans-unit>
        <trans-unit id="8162a916e0e9e0d49ed9c9b79a6a08291a88bca9" translate="yes" xml:space="preserve">
          <source>The select statement may take several tens of seconds to run, depending on how many rows are currently in the table. Regardless, other sessions can select against the table during this time (but they won&amp;rsquo;t be able to see the new column yet). The alter table statement will take less than 1 second (depending on how busy MariaDB is) and during this brief time interval, other table reads will be held off.</source>
          <target state="translated">현재 테이블에있는 행 수에 따라 select 문을 실행하는 데 수십 초가 걸릴 수 있습니다. 어쨌든 다른 세션은이 시간 동안 테이블에 대해 선택할 수 있지만 아직 새 열을 볼 수는 없습니다. alter table 문은 1 초도 걸리지 않으며 (MariaDB 사용량에 따라)이 짧은 시간 간격 동안 다른 테이블 읽기가 보류됩니다.</target>
        </trans-unit>
        <trans-unit id="071d447d271029c2ebade554a95246647ef9a022" translate="yes" xml:space="preserve">
          <source>The select_statement is a &lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt; statement that provides the definition of the view. (When you select from the view, you select in effect using the SELECT statement.) select_statement can select from base tables or other views.</source>
          <target state="translated">select_statement는 뷰의 정의를 제공 하는 &lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt; 문입니다. 뷰에서 선택할 때 SELECT 문을 사용하여 실제로 선택할 수 있습니다. select_statement는 기본 테이블이나 다른 뷰에서 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d93789d84304bad64527e4271f58c2fb68886a37" translate="yes" xml:space="preserve">
          <source>The semantics in stored procedures is &quot;call-by-value&quot;, so we have to evaluate any &quot;func&quot; Items at the point of the CALL or SET, otherwise we would get a kind of &quot;lazy&quot; evaluation with unexpected results with respect to OUT parameters for instance. For this the support function, &lt;code&gt;sp_head.cc:eval_func_item()&lt;/code&gt; is needed.</source>
          <target state="translated">저장 프로 시저의 의미는 &quot;값별 호출&quot;이므로 CALL 또는 SET 지점에서 &quot;기능&quot;항목을 평가해야합니다. 예를 들어 OUT 매개 변수. 이를 위해서는 &lt;code&gt;sp_head.cc:eval_func_item()&lt;/code&gt; 지원 기능 이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="64986b2306fecabcb79bcdbdb0f129d71a04ca30" translate="yes" xml:space="preserve">
          <source>The semi-join property also allows &quot;backwards&quot; execution: we can start from big cities, and check which countries they are in:</source>
          <target state="translated">semi-join 속성은 &quot;뒤로&quot;실행을 허용합니다. 대도시에서 시작하여 해당 국가를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3cdd8042ee6e636d9502b6c06d5b476edeab3861" translate="yes" xml:space="preserve">
          <source>The semisynchronous replication plugin is actually two different plugins--one for the master, and one for the slave. Shared libraries for both plugins are included with MariaDB. Although the plugins' shared libraries distributed with MariaDB by default, the plugin is not actually installed by MariaDB by default prior to &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1033-release-notes/&quot;&gt;MariaDB 10.3.3&lt;/a&gt;. There are two methods that can be used to install the plugin with MariaDB.</source>
          <target state="translated">반 동기식 복제 플러그인은 실제로는 마스터 용 플러그인과 슬레이브 용 플러그인의 두 가지 플러그인입니다. 두 플러그인의 공유 라이브러리는 MariaDB에 포함되어 있습니다. 플러그인의 공유 라이브러리는 기본적으로 MariaDB와 함께 배포되지만 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1033-release-notes/&quot;&gt;MariaDB 10.3.3&lt;/a&gt; 이전에는 실제로 기본적으로 MariaDB에 의해 플러그인이 설치되지 않습니다 . MariaDB와 함께 플러그인을 설치하는 데 사용할 수있는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c23da5ed9eb10c46a610321038bcc570e1520812" translate="yes" xml:space="preserve">
          <source>The separator character used in the &quot;multiple&quot; column, defaults to the comma.</source>
          <target state="translated">&quot;multiple&quot;열에 사용 된 구분 문자는 기본적으로 쉼표로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="a587ef319eb66e6feb59b6c68297d75230bdb212" translate="yes" xml:space="preserve">
          <source>The sequence can be created by specifying workable minimum and maximum values:</source>
          <target state="translated">실행 가능한 최소값과 최대 값을 지정하여 시퀀스를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="131678c3ef512fbdcabb2c010d28416203a08a1d" translate="yes" xml:space="preserve">
          <source>The server ID is set to the server ID of the server where the event group is first logged into the binlog. The sequence number is increased on a server for every event group logged. Since server IDs must be unique for every server, this makes the (server_id, sequence_number) pair, and hence the whole GTID, globally unique.</source>
          <target state="translated">서버 ID는 이벤트 그룹이 binlog에 처음 로그인 한 서버의 서버 ID로 설정됩니다. 시퀀스 번호는 기록 된 모든 이벤트 그룹에 대해 서버에서 증가합니다. 서버 ID는 모든 서버마다 고유해야하므로 (server_id, sequence_number) 쌍이되므로 전체 GTID가 전체적으로 고유합니다.</target>
        </trans-unit>
        <trans-unit id="9ca247b881697d3d3088765e24a9f51342da3ad3" translate="yes" xml:space="preserve">
          <source>The server aborts multiple-table &lt;code&gt;SELECT&lt;/code&gt; statements that probably need to examine more than 1,000,000 row combinations.</source>
          <target state="translated">서버는 1,000,000 개 이상의 행 조합을 검사해야하는 다중 테이블 &lt;code&gt;SELECT&lt;/code&gt; 문을 중단합니다 .</target>
        </trans-unit>
        <trans-unit id="ff51716f92a3cec0b41a2963051fc948d50efd71" translate="yes" xml:space="preserve">
          <source>The server and server tools, like &lt;a href=&quot;../myisamchk/index&quot;&gt;myisamchk&lt;/a&gt; and &lt;a href=&quot;../mysqlhotcopy/index&quot;&gt;mysqlhotcopy&lt;/a&gt; are here.</source>
          <target state="translated">&lt;a href=&quot;../myisamchk/index&quot;&gt;myisamchk&lt;/a&gt; 및 &lt;a href=&quot;../mysqlhotcopy/index&quot;&gt;mysqlhotcopy&lt;/a&gt; 와 같은 서버 및 서버 도구 가 여기에 있습니다.</target>
        </trans-unit>
        <trans-unit id="a53d46ae4c5a5047809936bb76563746030a3b1e" translate="yes" xml:space="preserve">
          <source>The server applies the collation &quot;utf8_germal2_ci&quot; to this string literal.</source>
          <target state="translated">서버는 데이터 정렬 &quot;utf8_germal2_ci&quot;를이 문자열 리터럴에 적용합니다.</target>
        </trans-unit>
        <trans-unit id="e784c500b98b04c41e6980514513208ecf25fa93" translate="yes" xml:space="preserve">
          <source>The server automatically changes the privileges in the &lt;a href=&quot;../mysqlproc-table/index&quot;&gt;mysql.proc&lt;/a&gt; table as required, but will not look out for manual changes.</source>
          <target state="translated">서버 는 필요 에 따라 &lt;a href=&quot;../mysqlproc-table/index&quot;&gt;mysql.proc&lt;/a&gt; 테이블 의 권한을 자동으로 변경 하지만 수동 변경 사항은 찾지 않습니다.</target>
        </trans-unit>
        <trans-unit id="27d429096bb449ea4ecc70c1fd9c6e43c17b4ddc" translate="yes" xml:space="preserve">
          <source>The server can require a specific Certificate Authority (CA) for a client if the client's user account has been defined with &lt;code&gt;REQUIRE ISSUER&lt;/code&gt;. See &lt;a href=&quot;../securing-connections-for-client-and-server/index#requiring-tls&quot;&gt;Securing Connections for Client and Server: Requiring TLS&lt;/a&gt; for more information.</source>
          <target state="translated">클라이언트의 사용자 계정이 &lt;code&gt;REQUIRE ISSUER&lt;/code&gt; 로 정의 된 경우 서버는 클라이언트에 대한 특정 인증 기관 (CA)을 요구할 수 있습니다 . 자세한 정보 &lt;a href=&quot;../securing-connections-for-client-and-server/index#requiring-tls&quot;&gt;는 클라이언트 및 서버 연결 보안 : TLS 필요&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="39c666ab3d52d8058745249b1c6d8357063851c5" translate="yes" xml:space="preserve">
          <source>The server counts the number of read, inserted, modified, and deleted rows during query execution. This takes into account the use of temporary tables, and sorting for intermediate query operations.</source>
          <target state="translated">서버는 쿼리 실행 중 읽기, 삽입, 수정 및 삭제 된 행 수를 계산합니다. 여기에는 임시 테이블 사용 및 중간 쿼리 작업에 대한 정렬이 고려됩니다.</target>
        </trans-unit>
        <trans-unit id="1a6c22ae3fb4afafeaebeea9d655754e0753ae14" translate="yes" xml:space="preserve">
          <source>The server gets the password in clear text which can cause problems if the user is convinced to connect to a malicious server.</source>
          <target state="translated">서버는 일반 텍스트로 암호를 가져 오므로 사용자가 악의적 인 서버에 연결되어있을 경우 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8938fcdb67604d28f261d1f76538706a368883fb" translate="yes" xml:space="preserve">
          <source>The server has the same OS and 'locale' as the current servers</source>
          <target state="translated">서버는 현재 서버와 동일한 OS 및 '로케일'을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="8d3a4643d3f4820209c6ebbba3d80dee759fd3b6" translate="yes" xml:space="preserve">
          <source>The server host.</source>
          <target state="translated">서버 호스트</target>
        </trans-unit>
        <trans-unit id="3b63dc6658727fba56b31dd696d701d28d74c853" translate="yes" xml:space="preserve">
          <source>The server id is a unique number for each MariaDB/MySQL server in your network.</source>
          <target state="translated">서버 ID는 네트워크의 각 MariaDB / MySQL 서버에 대한 고유 번호입니다.</target>
        </trans-unit>
        <trans-unit id="da6728ec92705d862e36ec51f47c8ec2bcd0b2e7" translate="yes" xml:space="preserve">
          <source>The server initially tries to interpret the value of the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#lc_messages_dir&quot;&gt;lc_messages_dir&lt;/a&gt;&lt;/code&gt; system variable as a path to the directory storing the server's &lt;a href=&quot;../error-log/index#error-messages-file&quot;&gt;error message files&lt;/a&gt;. Therefore, it constructs the path to the language's &lt;a href=&quot;../error-log/index#error-messages-file&quot;&gt;error message file&lt;/a&gt; by concatenating the value of the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#lc_messages_dir&quot;&gt;lc_messages_dir&lt;/a&gt;&lt;/code&gt; system variable with the language name of the &lt;a href=&quot;../server-locale/index&quot;&gt;locale&lt;/a&gt; specified by the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#lc_messages&quot;&gt;lc_messages&lt;/a&gt;&lt;/code&gt; system variable .</source>
          <target state="translated">서버는 처음에 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#lc_messages_dir&quot;&gt;lc_messages_dir&lt;/a&gt;&lt;/code&gt; 시스템 변수 의 값을 서버의 &lt;a href=&quot;../error-log/index#error-messages-file&quot;&gt;오류 메시지 파일을&lt;/a&gt; 저장하는 디렉토리의 경로 로 해석하려고 시도 합니다 . 따라서 언어의 경로 구축 &lt;a href=&quot;../error-log/index#error-messages-file&quot;&gt;오류 메시지 파일&lt;/a&gt; 의 값을 연결하여 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#lc_messages_dir&quot;&gt;lc_messages_dir&lt;/a&gt;&lt;/code&gt; 의 의 언어 이름과 시스템 변수 &lt;a href=&quot;../server-locale/index&quot;&gt;로케일&lt;/a&gt; 에 의해 지정된 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#lc_messages&quot;&gt;lc_messages&lt;/a&gt;&lt;/code&gt; 시스템 변수를.</target>
        </trans-unit>
        <trans-unit id="0f917b4763e19974b008f6946d77069c342fd71a" translate="yes" xml:space="preserve">
          <source>The server initially tries to interpret the value of this system variable as a path to the directory storing the server's &lt;a href=&quot;../error-log/index#error-messages-file&quot;&gt;error message files&lt;/a&gt;. Therefore, it constructs the path to the language's &lt;a href=&quot;../error-log/index#error-messages-file&quot;&gt;error message file&lt;/a&gt; by concatenating the value of this system variable with the language name of the &lt;a href=&quot;../server-locale/index&quot;&gt;locale&lt;/a&gt; specified by the &lt;code&gt;&lt;a href=&quot;index#lc_messages&quot;&gt;lc_messages&lt;/a&gt;&lt;/code&gt; system variable .</source>
          <target state="translated">서버는 처음에이 시스템 변수의 값을 서버의 &lt;a href=&quot;../error-log/index#error-messages-file&quot;&gt;오류 메시지 파일을&lt;/a&gt; 저장하는 디렉토리의 경로로 해석하려고 시도 합니다 . 따라서이 시스템 변수의 값을 &lt;code&gt;&lt;a href=&quot;index#lc_messages&quot;&gt;lc_messages&lt;/a&gt;&lt;/code&gt; 시스템 변수에 지정된 &lt;a href=&quot;../server-locale/index&quot;&gt;로케일&lt;/a&gt; 의 언어 이름과 연결 하여 언어 &lt;a href=&quot;../error-log/index#error-messages-file&quot;&gt;오류 메시지 파일&lt;/a&gt; 의 경로를 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="5bee7067c87b568e9b2938c8504738a4c0028d93" translate="yes" xml:space="preserve">
          <source>The server is active, but the performance is degraded. A server is degraded when a NIC is not working.</source>
          <target state="translated">서버가 활성화되었지만 성능이 저하되었습니다. NIC가 작동하지 않으면 서버 성능이 저하됩니다.</target>
        </trans-unit>
        <trans-unit id="31326a460301ef6313488a799b8715fc75b9dbab" translate="yes" xml:space="preserve">
          <source>The server is an embedded server (libmysqld).</source>
          <target state="translated">서버는 내장 서버 (libmysqld)입니다.</target>
        </trans-unit>
        <trans-unit id="92370783af6b882a0f57aae5c22cdfb11b9cb740" translate="yes" xml:space="preserve">
          <source>The server is compiled for debugging.</source>
          <target state="translated">서버는 디버깅을 위해 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="a59a3d5f56c662a889a7378a41c60d37f67ac169" translate="yes" xml:space="preserve">
          <source>The server is compiled to be instrumented with valgrind.</source>
          <target state="translated">서버는 valgrind로 인스트루먼트되도록 컴파일되었습니다.</target>
        </trans-unit>
        <trans-unit id="0b05e097bee90a687cf5707343fccb9db32ece9d" translate="yes" xml:space="preserve">
          <source>The server is configured to load the plugin with the &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-plugin-load&quot;&gt;--plugin-load&lt;/a&gt;&lt;/code&gt; option.</source>
          <target state="translated">서버는 &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-plugin-load&quot;&gt;--plugin-load&lt;/a&gt;&lt;/code&gt; 옵션 을 사용하여 플러그인을로드하도록 구성되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b32af201af3ac1ceb64ae66a85592d224fc6878e" translate="yes" xml:space="preserve">
          <source>The server is configured to load the plugin with the &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-plugin-load-add&quot;&gt;--plugin-load-add&lt;/a&gt;&lt;/code&gt; option.</source>
          <target state="translated">서버는 &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-plugin-load-add&quot;&gt;--plugin-load-add&lt;/a&gt;&lt;/code&gt; 옵션 을 사용하여 플러그인을로드하도록 구성되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec2baeb4bc8e107f55bac3aea337aeda9ad3c095" translate="yes" xml:space="preserve">
          <source>The server is not accessing the tables during the copy process.</source>
          <target state="translated">복사 프로세스 중에 서버가 테이블에 액세스하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a20a662f9d63e578da85765d72d37e0ca21dc6d7" translate="yes" xml:space="preserve">
          <source>The server is not configured as slave; fix in config file or with CHANGE MASTER TO</source>
          <target state="translated">서버가 슬레이브로 구성되지 않았습니다. 구성 파일 또는 CHANGE MASTER TO로 수정</target>
        </trans-unit>
        <trans-unit id="ba6c5f0217c675d466ec4e3b4de72cd7cdcff5f9" translate="yes" xml:space="preserve">
          <source>The server is using a non-default &lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_page_size&quot;&gt;innodb_page_size&lt;/a&gt;&lt;/code&gt; value that is greater than &lt;code&gt;16k&lt;/code&gt;.</source>
          <target state="translated">서버가 &lt;code&gt;16k&lt;/code&gt; 보다 큰 기본값이 아닌 &lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_page_size&quot;&gt;innodb_page_size&lt;/a&gt;&lt;/code&gt; 값을 사용하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e09cb12d8a64b38e750e1c709cf6bd5fb284688" translate="yes" xml:space="preserve">
          <source>The server limits all large&lt;code&gt;SELECT&lt;/code&gt; results to 1,000 rows unless the statement includes a &lt;code&gt;LIMIT&lt;/code&gt; clause.</source>
          <target state="translated">명령문에 &lt;code&gt;LIMIT&lt;/code&gt; 절이 포함되지 않는 한 서버는 모든 대형 &lt;code&gt;SELECT&lt;/code&gt; 결과를 1,000 행으로 제한 합니다.</target>
        </trans-unit>
        <trans-unit id="57ddff2629e4f11f58f57f9a545debf0603d6c12" translate="yes" xml:space="preserve">
          <source>The server parses the whole statement before executing it, so any variables set in this fashion that affect the parser may not have the expected effect. Examples include the charset variables, sql_mode=ansi_quotes, etc.</source>
          <target state="translated">서버는 명령문을 실행하기 전에 전체 명령문을 구문 분석하므로 구문 분석기에 영향을주는이 방식으로 설정된 변수는 예상 된 영향을 미치지 않을 수 있습니다. 예를 들어 문자셋 변수, sql_mode = ansi_quotes 등이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b69ca374e10771e17aa3da0eaffec5bf3bb96cb7" translate="yes" xml:space="preserve">
          <source>The server runs a number of additional processes to handle concurrency scaling. When a client queries the server, the storage engine passes the query to one of these processes, which then break down the SQL request and distributed the various parts to one or more &lt;a href=&quot;#performance-module&quot;&gt;Performance Modules&lt;/a&gt; to process the query and read from storage. The User module then collects the query results and assembles them into the result-set to return to the client.</source>
          <target state="translated">서버는 동시성 확장을 처리하기 위해 여러 가지 추가 프로세스를 실행합니다. 클라이언트가 서버에 쿼리 할 때 스토리지 엔진은 이러한 프로세스 중 하나에 쿼리를 전달한 다음, SQL 요청을 분류하고 다양한 부분을 하나 이상의 &lt;a href=&quot;#performance-module&quot;&gt;성능 모듈&lt;/a&gt; 에 분배 하여 쿼리를 처리하고 스토리지에서 읽습니다. 그런 다음 사용자 모듈은 쿼리 결과를 수집하여 결과 집합으로 어셈블하여 클라이언트로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1d1f5d97732498c53018dc55a27457b3992cf69f" translate="yes" xml:space="preserve">
          <source>The server runs on Win7 64Bit version 10.0.13</source>
          <target state="translated">서버는 Win7 64Bit 버전 10.0.13에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="d674610caa9c0a5c4b9c7755330df7f4322e93af" translate="yes" xml:space="preserve">
          <source>The server uses utf8_german2_ci for comparison.</source>
          <target state="translated">서버는 비교를 위해 utf8_german2_ci를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a9541c19eaea2bcf46c1fc65095ac17a35dee9f4" translate="yes" xml:space="preserve">
          <source>The server verifies a client certificate by checking the client's known &lt;code&gt;SUBJECT&lt;/code&gt; against the &lt;strong&gt;Subject&lt;/strong&gt; attribute in the client's certificate. This is only done for user accounts that have been defined with &lt;code&gt;REQUIRE SUBJECT&lt;/code&gt;. See &lt;a href=&quot;../securing-connections-for-client-and-server/index#requiring-tls&quot;&gt;Securing Connections for Client and Server: Requiring TLS&lt;/a&gt; for more information.</source>
          <target state="translated">서버는 클라이언트 인증서 의 &lt;strong&gt;Subject&lt;/strong&gt; 속성에 대해 클라이언트의 알려진 &lt;code&gt;SUBJECT&lt;/code&gt; 를 확인하여 클라이언트 인증서를 확인합니다 . 이는 &lt;code&gt;REQUIRE SUBJECT&lt;/code&gt; 로 정의 된 사용자 계정에 대해서만 수행됩니다 . &lt;a href=&quot;../securing-connections-for-client-and-server/index#requiring-tls&quot;&gt;클라이언트 및 서버 연결 보안 : TLS 필요를&lt;/a&gt; 참조하십시오 .&lt;strong&gt;&lt;/strong&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ab2cfda1205b4e2df895f98f028a5dbc58c9eeb2" translate="yes" xml:space="preserve">
          <source>The server version.</source>
          <target state="translated">서버 버전.</target>
        </trans-unit>
        <trans-unit id="5edbe8c0100921a12eadad2f0d9c20cdc850c5c8" translate="yes" xml:space="preserve">
          <source>The server was not built with row-based replication</source>
          <target state="translated">서버가 행 기반 복제로 구축되지 않았습니다</target>
        </trans-unit>
        <trans-unit id="c13192fd00a31183ecb5234fd5e103ff533f5709" translate="yes" xml:space="preserve">
          <source>The server will return an &lt;code&gt;ER_ACCOUNT_HAS_BEEN_LOCKED&lt;/code&gt; error when locked users attempt to connect:</source>
          <target state="translated">잠긴 사용자가 연결을 시도하면 서버는 &lt;code&gt;ER_ACCOUNT_HAS_BEEN_LOCKED&lt;/code&gt; 오류 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="942b2ce2d71fb3f71eae46d4bef74ae3b0d26f54" translate="yes" xml:space="preserve">
          <source>The server's id.</source>
          <target state="translated">서버의 ID</target>
        </trans-unit>
        <trans-unit id="b13671330cabfb59e3540282d034e048aad9170b" translate="yes" xml:space="preserve">
          <source>The server's minimum plugin maturity is properly configured, and the plugin is mature enough to be installed.</source>
          <target state="translated">서버의 최소 플러그인 성숙도가 올바르게 구성되었으며 플러그인이 설치 될 수있을 정도로 성숙되었습니다.</target>
        </trans-unit>
        <trans-unit id="5759b6533079aafb2e8b8b875a2b4d04f794e370" translate="yes" xml:space="preserve">
          <source>The server's plugin directory is properly configured, and the plugin's library is in the plugin directory.</source>
          <target state="translated">서버의 플러그인 디렉토리가 올바르게 구성되었으며 플러그인 라이브러리가 플러그인 디렉토리에 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddc8c959664bc21fad2524eb245a75b927b69150" translate="yes" xml:space="preserve">
          <source>The server, when parsing the query, creates a utf8 string literal by converting '&amp;ouml;' from @@character_set_client (cp850) to @@character_set_connection (utf8)</source>
          <target state="translated">서버는 쿼리를 구문 분석 할 때 '&amp;ouml;'를 @@ character_set_client (cp850)에서 @@ character_set_connection (utf8)로 변환하여 utf8 문자열 리터럴을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="07c1e9dcd490b7e09acf28f377509f095a391382" translate="yes" xml:space="preserve">
          <source>The server-side component of the &lt;code&gt;&lt;a href=&quot;../authentication-plugin-gssapi/index&quot;&gt;gssapi&lt;/a&gt;&lt;/code&gt; authentication plugin.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../authentication-plugin-gssapi/index&quot;&gt;gssapi&lt;/a&gt;&lt;/code&gt; 인증 플러그인 의 서버 측 구성 요소입니다 .</target>
        </trans-unit>
        <trans-unit id="46eb4501d2c71d7c860615476f8dba0ebefb75cc" translate="yes" xml:space="preserve">
          <source>The server_id of the current host is unique among your set of master and slave servers</source>
          <target state="translated">현재 호스트의 server_id는 마스터 및 슬레이브 서버 세트에서 고유합니다.</target>
        </trans-unit>
        <trans-unit id="47375aad8ac9bf438f1496dd1071320df289a33c" translate="yes" xml:space="preserve">
          <source>The server_name should be a unique reference to the server. Server definitions are global within the scope of the server, it is not possible to qualify the server definition to a specific database. server_name has a maximum length of 64 characters (names longer than 64 characters are silently truncated), and is case insensitive. You may specify the name as a quoted string.</source>
          <target state="translated">server_name은 서버에 대한 고유 한 참조 여야합니다. 서버 정의는 서버 범위 내에서 전역 적이므로 서버 정의를 특정 데이터베이스로 한정 할 수 없습니다. server_name의 최대 길이는 64 자이며 (64 자보다 긴 이름은 자동으로 잘림) 대소 문자를 구분하지 않습니다. 인용 된 문자열로 이름을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d75c533bf58f167adf8ee680784d85952e19cfb2" translate="yes" xml:space="preserve">
          <source>The service can be interacted with by using the &lt;code&gt;&lt;a href=&quot;https://linux.die.net/man/8/service&quot;&gt;service&lt;/a&gt;&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://linux.die.net/man/8/service&quot;&gt;service&lt;/a&gt;&lt;/code&gt; 명령 을 사용하여 서비스 와 상호 작용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1e91c1f80d356b4109a5c517cfe257629fd8734b" translate="yes" xml:space="preserve">
          <source>The service can be interacted with by using the &lt;code&gt;&lt;a href=&quot;https://www.freedesktop.org/software/systemd/man/systemctl.html&quot;&gt;systemctl&lt;/a&gt;&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://www.freedesktop.org/software/systemd/man/systemctl.html&quot;&gt;systemctl&lt;/a&gt;&lt;/code&gt; 을 사용하여 서비스와 상호 작용할 수 있습니다 명령 .</target>
        </trans-unit>
        <trans-unit id="4d2267dda3b07b9435f51da7b2d9d7bf367a3b60" translate="yes" xml:space="preserve">
          <source>The service definition causes launchd to automatically start MariaDB Server after installation and when the OS boots.</source>
          <target state="translated">서비스 정의로 인해 설치 후 및 OS 부팅시 MariaDB 서버가 자동으로 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="c1bb61261c703cffca80f0c04392dae8955ae8af" translate="yes" xml:space="preserve">
          <source>The service name is &lt;code&gt;mariadb.service&lt;/code&gt;. Aliases to &lt;code&gt;mysql.service&lt;/code&gt; and &lt;code&gt;mysqld.service&lt;/code&gt; are also installed for convenience.</source>
          <target state="translated">서비스 이름은 &lt;code&gt;mariadb.service&lt;/code&gt; 입니다. 편의상 &lt;code&gt;mysql.service&lt;/code&gt; 및 &lt;code&gt;mysqld.service&lt;/code&gt; 의 별칭 도 설치됩니다.</target>
        </trans-unit>
        <trans-unit id="91127807a32533f0d8a3241ca8d8eb7a4981bb14" translate="yes" xml:space="preserve">
          <source>The service principal name can be set by configuring the &lt;code&gt;&lt;a href=&quot;#gssapi_principal_name&quot;&gt;gssapi_principal_name&lt;/a&gt;&lt;/code&gt; system variable. This can be specified as a command-line argument to &lt;code&gt;&lt;a href=&quot;../mysqld-options/index&quot;&gt;mysqld&lt;/a&gt;&lt;/code&gt; or it can be specified in a relevant server &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;option group&lt;/a&gt; in an &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;option file&lt;/a&gt;. For example:</source>
          <target state="translated">서비스 주체 이름은 &lt;code&gt;&lt;a href=&quot;#gssapi_principal_name&quot;&gt;gssapi_principal_name&lt;/a&gt;&lt;/code&gt; 시스템 변수를 구성하여 설정할 수 있습니다 . 이것은 &lt;code&gt;&lt;a href=&quot;../mysqld-options/index&quot;&gt;mysqld&lt;/a&gt;&lt;/code&gt; 에 대한 명령 행 인수로 지정되거나 &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;옵션 파일&lt;/a&gt; 의 관련 서버 &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;옵션 그룹&lt;/a&gt; 에서 지정 될 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="18ebf406b0662f0914fdc98b1721e2436bcc2f6f" translate="yes" xml:space="preserve">
          <source>The session value only affects the current client, and can be changed by the client when required. To set the global value, the SUPER privilege is required, and the change affects any clients that connect from that point on.</source>
          <target state="translated">세션 값은 현재 클라이언트에만 영향을 주며 필요할 때 클라이언트가 변경할 수 있습니다. 글로 z 값을 설정하려면 SUPER 특권이 필요하며 변경 사항은 해당 지점부터 연결하는 모든 클라이언트에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="397b6eee9ed0b0bf0c3c1c093844359ce442f4d7" translate="yes" xml:space="preserve">
          <source>The session variable &lt;code&gt;@@skip_replication&lt;/code&gt; can be changed without requiring special privileges. This makes it possible for normal applications to control it without requiring &lt;code&gt;SUPER&lt;/code&gt; privileges. But it must be kept in mind when using slaves with &lt;code&gt;--replicate-events-marked-for-skip&lt;/code&gt; set different from &lt;code&gt;REPLICATE&lt;/code&gt;, as it allows any connection to do changes that are not replicated.</source>
          <target state="translated">세션 변수 &lt;code&gt;@@skip_replication&lt;/code&gt; 은 특별한 권한없이 변경 될 수 있습니다. 따라서 일반 응용 프로그램에서 &lt;code&gt;SUPER&lt;/code&gt; 권한 없이 제어 할 수 있습니다. 그러나 &lt;code&gt;--replicate-events-marked-for-skip&lt;/code&gt; 이 설정된 슬레이브가 &lt;code&gt;REPLICATE&lt;/code&gt; 와 다르게 설정 되어 있으면 모든 연결에서 복제되지 않은 변경을 수행 할 수 있으므로주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="45491f7196e6a77da28e5dd40f19b5dc38c7b3ad" translate="yes" xml:space="preserve">
          <source>The session variables &lt;a href=&quot;../server-system-variables/index#tmp_table_size&quot;&gt;tmp_table_size&lt;/a&gt; and &lt;a href=&quot;../server-system-variables/index#max_heap_table_size&quot;&gt;max_heap_table_size&lt;/a&gt; influence the size of in-memory temporary tables in the table used for caching. It cannot grow more than the minimum of the above variables values (see the &lt;a href=&quot;#implementation&quot;&gt;Implementation&lt;/a&gt; section for details).</source>
          <target state="translated">세션 변수 &lt;a href=&quot;../server-system-variables/index#tmp_table_size&quot;&gt;tmp_table_size&lt;/a&gt; 및 &lt;a href=&quot;../server-system-variables/index#max_heap_table_size&quot;&gt;max_heap_table_size&lt;/a&gt; 는 캐싱에 사용되는 테이블의 메모리 내 임시 테이블 크기에 영향을줍니다. 위의 변수 값 이상으로 커질 수 없습니다 (자세한 내용은 &lt;a href=&quot;#implementation&quot;&gt;구현&lt;/a&gt; 섹션 참조).</target>
        </trans-unit>
        <trans-unit id="a3dcb5105be25d64fb7e2e8241c9c79baf382cfd" translate="yes" xml:space="preserve">
          <source>The set of alter algorithms can be considered as a hierarchy. The hierarchy is ranked in the following order, with &lt;em&gt;least efficient&lt;/em&gt; algorithm at the top, and &lt;em&gt;most efficient&lt;/em&gt; algorithm at the bottom:</source>
          <target state="translated">대체 알고리즘 세트는 계층 구조로 간주 될 수 있습니다. 계층 구조는 함께, 다음과 같은 순서로 위를 기록하고 &lt;em&gt;적어도 효율적인&lt;/em&gt; 상단의 알고리즘, 그리고 &lt;em&gt;가장 효율적으로&lt;/em&gt; 하단의 알고리즘 :</target>
        </trans-unit>
        <trans-unit id="aa54d2a4735ff3e072dca481e73ba234d63ae61c" translate="yes" xml:space="preserve">
          <source>The set of possible datatypes is mostly the same as that used by the SQL &lt;code&gt;&lt;a href=&quot;../cast/index&quot;&gt;CAST&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../convert/index&quot;&gt;CONVERT&lt;/a&gt;&lt;/code&gt; functions. However, note that there are currently some differences - see &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-597&quot;&gt;MDEV-597&lt;/a&gt;.</source>
          <target state="translated">가능한 데이터 유형 세트는 대부분 SQL &lt;code&gt;&lt;a href=&quot;../cast/index&quot;&gt;CAST&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../convert/index&quot;&gt;CONVERT&lt;/a&gt;&lt;/code&gt; 함수 에서 사용하는 것과 동일 합니다. 그러나 현재 약간의 차이점이 있습니다 ( &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-597&quot;&gt;MDEV-597&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="a4599cc19244c55960b12b530b4440d4c9d61faf" translate="yes" xml:space="preserve">
          <source>The setting is controlled by the &lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#slave_run_triggers_for_rbr&quot;&gt;slave_run_triggers_for_rbr&lt;/a&gt; global variable. It can be also specified as a command-line option or in my.cnf.</source>
          <target state="translated">설정은 &lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#slave_run_triggers_for_rbr&quot;&gt;slave_run_triggers_for_rbr&lt;/a&gt; 전역 변수에 의해 제어됩니다 . 명령 행 옵션 또는 my.cnf에 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b9bc3afc429e6cfd590f12f502b1bb0ec29010c" translate="yes" xml:space="preserve">
          <source>The setting is from 0 to 100, with lower values meaning a lower likelihood of swapping. The default is usually 60 - you can check this by running:</source>
          <target state="translated">설정은 0에서 100 사이이며 값이 낮을수록 스와핑 가능성이 낮습니다. 기본값은 보통 60입니다. 다음을 실행하여이를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0f14770795df0c05bc5fe4910bbabd52a91cbf4" translate="yes" xml:space="preserve">
          <source>The settings in my.cnf or my.ini will not take effect until you restart the server.</source>
          <target state="translated">my.cnf 또는 my.ini의 설정은 서버를 다시 시작할 때까지 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b491c23fd6abd7d375cc08db9f48a51fec39acd6" translate="yes" xml:space="preserve">
          <source>The shared library must be located in the plugin directory (that is, the directory named by the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#plugin_dir&quot;&gt;plugin_dir&lt;/a&gt;&lt;/code&gt; system variable). The library must be in the plugin directory itself, not in a subdirectory. By default, &lt;code&gt;plugin_dir&lt;/code&gt; is plugin directory under the directory named by the &lt;code&gt;pkglibdir&lt;/code&gt; configuration variable, but it can be changed by setting the value of &lt;code&gt;plugin_dir&lt;/code&gt; at server startup. For example, set its value in a &lt;code&gt;my.cnf&lt;/code&gt; file:</source>
          <target state="translated">공유 라이브러리는 플러그인 디렉토리 (즉, &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#plugin_dir&quot;&gt;plugin_dir&lt;/a&gt;&lt;/code&gt; 시스템 변수로 이름이 지정된 디렉토리 )에 있어야 합니다. 라이브러리는 서브 디렉토리가 아닌 플러그인 디렉토리 자체에 있어야합니다. 기본적으로 &lt;code&gt;plugin_dir&lt;/code&gt; 은 &lt;code&gt;pkglibdir&lt;/code&gt; 구성 변수로 명명 된 디렉토리 아래의 플러그인 디렉토리 이지만 서버 시작시 &lt;code&gt;plugin_dir&lt;/code&gt; 의 값을 설정하여 변경할 수 있습니다 . 예를 들어, &lt;code&gt;my.cnf&lt;/code&gt; 파일에 값을 설정 하십시오.</target>
        </trans-unit>
        <trans-unit id="9a926b7084420efb1b34c045379db6cb01fbe34e" translate="yes" xml:space="preserve">
          <source>The shutdown Command and the --wait-for-all-slaves Option</source>
          <target state="translated">shutdown 명령 및 --wait-for-all-slaves 옵션</target>
        </trans-unit>
        <trans-unit id="11fae5deb3202c50148270967b5765d6c0f2ce88" translate="yes" xml:space="preserve">
          <source>The simple way to stage is to ingest for a while, then batch-process what is in `Staging`. But that leads to new records piling up waiting to be staged. To avoid that issue, have 2 processes:</source>
          <target state="translated">준비하는 간단한 방법은 잠시 동안 섭취 한 다음 '스테이징'에있는 것을 일괄 처리하는 것입니다. 그러나 이로 인해 새로운 기록이 준비되기를 기다리고 있습니다. 이 문제를 피하려면 다음 두 가지 프로세스를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="020035ddd634f824af2be9dc5594707e4d5b2af6" translate="yes" xml:space="preserve">
          <source>The simplest case is to compile the storage engine into MariaDB:</source>
          <target state="translated">가장 간단한 경우는 스토리지 엔진을 MariaDB로 컴파일하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2003c248e58a737176e1630299c64f4b8887afa4" translate="yes" xml:space="preserve">
          <source>The simplest form of cpimport command is</source>
          <target state="translated">cpimport 명령의 가장 간단한 형태는</target>
        </trans-unit>
        <trans-unit id="b437e99f0186db5fe204b7a181065ace25af740e" translate="yes" xml:space="preserve">
          <source>The simplest form of the command is:</source>
          <target state="translated">가장 간단한 명령 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="95abdb841f871ec4dc097ba56865e2d08d2befe2" translate="yes" xml:space="preserve">
          <source>The simplest way for testing purposes is probably to setup a new, empty slave server and replicate all of the master's binlogs from the start (this is usually not feasible in a realistic production setup, as the initial binlog files will probably have been purged or take too long to apply).</source>
          <target state="translated">테스트를위한 가장 간단한 방법은 비어있는 새 슬레이브 서버를 설정하고 처음부터 마스터의 모든 binlog를 복제하는 것입니다 (초기 binlog 파일을 제거했거나 가져갈 수 있으므로 실제 프로덕션 설정에서는 일반적으로 불가능합니다) 적용하기에 너무 깁니다).</target>
        </trans-unit>
        <trans-unit id="22692ab3591e35173f814a0a8d13cf639125711e" translate="yes" xml:space="preserve">
          <source>The simplest way to force the join order is to put the tables in the correct order in the &lt;code&gt;FROM&lt;/code&gt; clause and use &lt;code&gt;SELECT STRAIGHT_JOIN&lt;/code&gt; like so:</source>
          <target state="translated">결합 순서를 강제하는 가장 간단한 방법은 &lt;code&gt;FROM&lt;/code&gt; 절 에서 테이블을 올바른 순서로 배치하고 다음과 같이 &lt;code&gt;SELECT STRAIGHT_JOIN&lt;/code&gt; 을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="44ddd242accc2cd607fefe981c43e40aaaec39fb" translate="yes" xml:space="preserve">
          <source>The simplest way to start database from the command line is:</source>
          <target state="translated">명령 행에서 데이터베이스를 시작하는 가장 간단한 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0cbb43e0b274ba2e24a28f9e56ede542fee5bb46" translate="yes" xml:space="preserve">
          <source>The simplest way would be to just leave it at that, and re-read the procedure from the database each time it is called. (And in fact, that's the way the earliest implementation will work.) However, this is not very efficient, and we can do better. The full implementation should work like this:</source>
          <target state="translated">가장 간단한 방법은 그대로두고 데이터베이스가 호출 될 때마다 프로 시저를 다시 읽는 것입니다. (실제로 이것이 가장 빠른 구현 방식이 될 것입니다.) 그러나 이것은 매우 효율적이지 않으며 더 잘할 수 있습니다. 전체 구현은 다음과 같이 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="bab08ea785fd2bf650dbeb0a8308cb1d48994515" translate="yes" xml:space="preserve">
          <source>The situation</source>
          <target state="translated">그 상황</target>
        </trans-unit>
        <trans-unit id="bfaac68c3f3c7ad2ee4637c883347695acd3be8b" translate="yes" xml:space="preserve">
          <source>The size is determined by the &lt;a href=&quot;../performance-schema-system-variables/index#performance_schema_hosts_size&quot;&gt;performance_schema_hosts_size&lt;/a&gt; system variable, which, if set to zero, will disable connection statistics in the hosts table.</source>
          <target state="translated">크기는 &lt;a href=&quot;../performance-schema-system-variables/index#performance_schema_hosts_size&quot;&gt;performance_schema_hosts_size&lt;/a&gt; 시스템 변수에 의해 결정되며, 0으로 설정되면 호스트 테이블에서 연결 통계를 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8610debd41d3d4514fe2008bdc7ba5375845e47a" translate="yes" xml:space="preserve">
          <source>The size number was correct but we don't allow the digit part to be more than 2 billion</source>
          <target state="translated">크기는 정확하지만 숫자 부분이 20 억을 초과 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a489a92aca6ce2987bd61e0be0385ed46d4f1d54" translate="yes" xml:space="preserve">
          <source>The size of each redo log file is configured by the &lt;a href=&quot;../innodb-system-variables/index#innodb_log_file_size&quot;&gt;innodb_log_file_size&lt;/a&gt; system variable.</source>
          <target state="translated">각 리두 로그 파일의 크기는 &lt;a href=&quot;../innodb-system-variables/index#innodb_log_file_size&quot;&gt;innodb_log_file_size&lt;/a&gt; 시스템 변수로 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="4ba9fea4d620b3e4f721f88f2e79e2c388224738" translate="yes" xml:space="preserve">
          <source>The size of each uncolored area roughly corresponds to how important (i.e. frequently used) that kind of subquery is. For example, &lt;code&gt;x IN (SELECT ...)&lt;/code&gt; queries are the most important, and &lt;code&gt;EXISTS (SELECT ...)&lt;/code&gt; are relatively unimportant.</source>
          <target state="translated">색상이없는 각 영역의 크기는 하위 쿼리의 종류가 얼마나 중요한지 (즉, 자주 사용되는) 정도에 해당합니다. 예를 들어, &lt;code&gt;x IN (SELECT ...)&lt;/code&gt; 쿼리가 가장 중요하며 &lt;code&gt;EXISTS (SELECT ...)&lt;/code&gt; 는 상대적으로 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cb6aefb2b981c70c0eaf0cdeaa13dea42cf68602" translate="yes" xml:space="preserve">
          <source>The size of individual partitions depends on the partitioning type. Read and write performance are affected by the partitioning expression. Therefore, these choices should be made carefully.</source>
          <target state="translated">개별 파티션의 크기는 파티션 유형에 따라 다릅니다. 읽기 및 쓰기 성능은 파티셔닝 표현식의 영향을받습니다. 따라서 이러한 선택은 신중하게해야합니다.</target>
        </trans-unit>
        <trans-unit id="39ab6e751302147fc29c3479255c05e01db9ef37" translate="yes" xml:space="preserve">
          <source>The size of the buffer used for index blocks for Aria tables.</source>
          <target state="translated">Aria 테이블의 인덱스 블록에 사용 된 버퍼의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="80dc10d8b63596ab61867a80382d1f6da31b0012" translate="yes" xml:space="preserve">
          <source>The size of the buffer used for transaction log for Aria tables.</source>
          <target state="translated">Aria 테이블의 트랜잭션 로그에 사용 된 버퍼의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="32b9e29a506362b7012e3573e416b498dc37b1e4" translate="yes" xml:space="preserve">
          <source>The size of the core file that mysqld should be able to create. The option value is passed to ulimit -c.</source>
          <target state="translated">mysqld가 생성 할 수있는 코어 파일의 크기. 옵션 값은 ulimit -c로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="7169245dec1c0067bad1ea91a9810383341c4de3" translate="yes" xml:space="preserve">
          <source>The slave &lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#server_id&quot;&gt;server_id&lt;/a&gt; used for &lt;code&gt;--read-from-remote-server&lt;/code&gt;&lt;code&gt;--stop-never&lt;/code&gt;.</source>
          <target state="translated">슬레이브 &lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#server_id&quot;&gt;SERVER_ID&lt;/a&gt; 에 사용 &lt;code&gt;--read-from-remote-server&lt;/code&gt; &lt;code&gt;--stop-never&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="480f5557f3f2e682332637876c7eb733cd5634cf" translate="yes" xml:space="preserve">
          <source>The slave automatically keeps track of the GTID of the last applied event group, as can be seen from the &lt;a href=&quot;#gtid_slave_pos&quot;&gt;gtid_slave_pos&lt;/a&gt; variable:</source>
          <target state="translated">gtid_slave_pos에서 볼 수 있듯이 슬레이브는 마지막으로 적용된 이벤트 그룹의 GTID를 자동으로 추적합니다 &lt;a href=&quot;#gtid_slave_pos&quot;&gt;.&lt;/a&gt; 변수 합니다.</target>
        </trans-unit>
        <trans-unit id="02d68b3e2c4072941811ae6b2292d48ed31d9f0d" translate="yes" xml:space="preserve">
          <source>The slave has a record of the GTID of the last applied transaction from the old master, and since GTIDs are identical across all servers in a replication hierarchy, the slave will just continue from the appropriate point in the new master's binlog.</source>
          <target state="translated">슬레이브는 이전 마스터에서 마지막으로 적용된 트랜잭션의 GTID 레코드를 가지고 있으며, GTID는 복제 계층 구조의 모든 서버에서 동일하므로 슬레이브는 새 마스터의 binlog의 해당 지점에서 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="58273eb00d4958be36aad1dcc028418bb34f3912" translate="yes" xml:space="preserve">
          <source>The slave has three types of replication-related threads: the slave I/O thread, the slave SQL thread, and worker threads, which are only applicable when &lt;a href=&quot;../parallel-replication/index&quot;&gt;parallel replication&lt;/a&gt; is in use.</source>
          <target state="translated">슬레이브에는 세 가지 유형의 복제 관련 스레드가 있습니다. 슬레이브 I / O 스레드, 슬레이브 SQL 스레드 및 작업자 스레드는 &lt;a href=&quot;../parallel-replication/index&quot;&gt;병렬 복제&lt;/a&gt; 가 사용중인 경우에만 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="4fb0613cc07f29a0a34d8a5ec41e3d1a90cafef7" translate="yes" xml:space="preserve">
          <source>The slave is connecting using CHANGE MASTER TO MASTER_AUTO_POSITION = 1, but the master has purged binary logs containing GTIDs that the slave requires.</source>
          <target state="translated">슬레이브가 CHANGE MASTER TO MASTER_AUTO_POSITION = 1을 사용하여 연결하고 있지만 마스터가 슬레이브에 필요한 GTID를 포함하는 이진 로그를 제거했습니다.</target>
        </trans-unit>
        <trans-unit id="76dedd85e6949ed14e07189326159c6a5f125e26" translate="yes" xml:space="preserve">
          <source>The slave keeps track of its current position (the global transaction ID of the last transaction applied) in the &lt;a href=&quot;../mysqlgtid_slave_pos-table/index&quot;&gt;mysql.gtid_slave_pos&lt;/a&gt; system table. If this table is using a transactional storage engine (such as InnoDB, which is the default), then updates to the state are done in the same transaction as the updates to the data. This makes the state crash-safe; if the slave server crashes, crash recovery on restart will make sure that the recorded replication position matches the changes that were actually replicated. This is not the case for old-style replication, where the state is recorded in a file relay-log.info, which is updated independently of the actual data changes and can easily get out of sync if the slave server crashes. (This works for DML to transactional tables; non-transactional tables and DDL in general are not crash-safe in MariaDB.)</source>
          <target state="translated">슬레이브는 현재 위치 (마지막으로 적용된 트랜잭션의 글로벌 트랜잭션 ID)를 추적합니다. &lt;a href=&quot;../mysqlgtid_slave_pos-table/index&quot;&gt; mysql 추적합니다.&lt;/a&gt;시스템 테이블. 이 테이블이 트랜잭션 스토리지 엔진 (예 : InnoDB와 같은 기본값)을 사용하는 경우 상태 업데이트는 데이터 업데이트와 동일한 트랜잭션에서 수행됩니다. 이것은 상태를 충돌로부터 안전하게 만듭니다. 슬레이브 서버가 충돌하는 경우 재시작시 응급 복구는 기록 된 복제 위치가 실제로 복제 된 변경 사항과 일치하는지 확인합니다. 이는 상태가 실제 데이터 변경과 독립적으로 업데이트되고 슬레이브 서버가 충돌하는 경우 쉽게 동기화되지 않을 수있는 relay-log.info 파일에 기록되는 구식 복제의 경우에는 해당되지 않습니다. (이것은 트랜잭션 테이블에 대한 DML에서 작동합니다. 비 트랜잭션 테이블과 DDL은 일반적으로 MariaDB에서 충돌 안전하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="8ad7b70462a54da6718ff2eca64ebf8e2f045194" translate="yes" xml:space="preserve">
          <source>The slave now uses TLS to encrypt data in transit as it replicates it from the master.</source>
          <target state="translated">슬레이브는 이제 TLS를 사용하여 마스터에서 데이터를 복제 할 때 전송중인 데이터를 암호화합니다.</target>
        </trans-unit>
        <trans-unit id="0c5f8f6e9ad4fd9c1b137825c35625f1cc189a01" translate="yes" xml:space="preserve">
          <source>The slave remembers that &lt;code&gt;master_use_gtid=slave_pos|master_pos&lt;/code&gt; was specified and will use it also for subsequent connects, until it is explicitly changed by specifying &lt;code&gt;master_log_file/pos=...&lt;/code&gt; or &lt;code&gt;master_use_gtid=no&lt;/code&gt;. The current value can be seen as the field Using_Gtid of SHOW SLAVE STATUS:</source>
          <target state="translated">슬레이브는 &lt;code&gt;master_use_gtid=slave_pos|master_pos&lt;/code&gt; 가 지정 되었음을 기억하고 master_log_file &lt;code&gt;master_log_file/pos=...&lt;/code&gt; 또는 &lt;code&gt;master_use_gtid=no&lt;/code&gt; 를 지정하여 명시 적으로 변경 될 때까지 후속 연결에도 사용합니다 . 현재 값은 SHOW SLAVE STATUS의 Using_Gtid 필드로 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="608e97cf9d7a3fb2d341a143463c19af29aa03ae" translate="yes" xml:space="preserve">
          <source>The slave remembers the global transaction ID of the last event group applied from the old master. This makes it easy to know where to resume replication on the new master, since the global transaction IDs are known throughout the entire replication hierarchy. This is not the case when using old-style replication; in this case the slave knows only the specific file name and offset of the old master server of the last event applied. There is no simple way to guess from this the correct file name and offset on a new master.</source>
          <target state="translated">슬레이브는 이전 마스터에서 적용된 마지막 이벤트 그룹의 글로벌 트랜잭션 ID를 기억합니다. 글로벌 트랜잭션 ID가 전체 복제 계층 구조에 걸쳐 알려져 있으므로 새 마스터에서 복제를 재개 할 위치를 쉽게 알 수 있습니다. 구식 복제를 사용하는 경우에는 그렇지 않습니다. 이 경우 슬레이브는 마지막으로 적용된 이전 마스터 서버의 특정 파일 이름과 오프셋 만 알고 있습니다. 새로운 마스터에서 올바른 파일 이름과 오프셋을 추측 할 수있는 간단한 방법은 없습니다.</target>
        </trans-unit>
        <trans-unit id="5f8904c5a2a29e3658392cc999b24d5fa22462f1" translate="yes" xml:space="preserve">
          <source>The slave server internally uses the &lt;a href=&quot;../mysqlgtid_slave_pos-table/index&quot;&gt;mysql.gtid_slave_pos table&lt;/a&gt; to store the GTID position (and so preserve the value of &lt;code&gt;@@GLOBAL.gtid_slave_pos&lt;/code&gt; across server restarts). After upgrading a server to 10.0, it is necessary to run &lt;a href=&quot;../mysql_upgrade/index&quot;&gt;mysql_upgrade&lt;/a&gt; (as always) to get the table created.</source>
          <target state="translated">슬레이브 서버는 내부적으로 &lt;a href=&quot;../mysqlgtid_slave_pos-table/index&quot;&gt;mysql.gtid_slave_pos 테이블&lt;/a&gt; 을 사용하여 GTID 위치를 저장합니다 (따라서 서버 재시작시 &lt;code&gt;@@GLOBAL.gtid_slave_pos&lt;/code&gt; 값을 유지함 ). 서버를 10.0으로 업그레이드 한 후 &lt;a href=&quot;../mysql_upgrade/index&quot;&gt;mysql_upgrade&lt;/a&gt; 를 실행 하여 테이블을 생성해야합니다.</target>
        </trans-unit>
        <trans-unit id="4dd19ac659709512dcaf747c1806f19ebbbf6c14" translate="yes" xml:space="preserve">
          <source>The slave server is installed in the normal way. By default, the GTID position for a newly installed server is empty, which makes the slave replicate from the start of the master's binlogs. But if the slave was used for other purposes before, the initial position can be explicitly set to empty first:</source>
          <target state="translated">슬레이브 서버는 일반적인 방식으로 설치됩니다. 기본적으로 새로 설치된 서버의 GTID 위치는 비어 있으므로 슬레이브가 마스터의 binlog 시작 부분에서 복제합니다. 그러나 이전에 슬레이브를 다른 용도로 사용한 경우 초기 위치를 먼저 비어있게 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0050139d9e5276cc7e05ad5961a572ac31765daf" translate="yes" xml:space="preserve">
          <source>The slave will start replication from the current GTID position, run up to and including the event with the GTID specified, and then stop. Note that this stops both the IO thread and the SQL thread (unlike START SLAVE UNTIL MASTER_LOG_FILE/MASTER_LOG_POS, which stops only the SQL thread).</source>
          <target state="translated">슬레이브는 현재 GTID 위치에서 복제를 시작하고 지정된 GTID로 이벤트를 포함하여 실행 한 다음 중지합니다. 이렇게하면 IO 스레드와 SQL 스레드가 모두 중지됩니다 (SQL 스레드 만 중지하는 START SLAVE UNTIL MASTER_LOG_FILE / MASTER_LOG_POS와 달리).</target>
        </trans-unit>
        <trans-unit id="a03e91926064751b8f585a42717b1df6cc45e561" translate="yes" xml:space="preserve">
          <source>The slave's I/O thread receives the &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt; events from the master and writes them to its &lt;a href=&quot;../relay-log/index&quot;&gt;relay log&lt;/a&gt;.</source>
          <target state="translated">슬레이브의 I / O 스레드는 마스터로부터 &lt;a href=&quot;../binary-log/index&quot;&gt;이진 로그&lt;/a&gt; 이벤트를 수신하여 &lt;a href=&quot;../relay-log/index&quot;&gt;릴레이 로그에&lt;/a&gt; 씁니다 .</target>
        </trans-unit>
        <trans-unit id="8dc7218eb164a93a2cb8b03d5737ba8de358eee4" translate="yes" xml:space="preserve">
          <source>The slave's SQL thread reads events from the &lt;a href=&quot;../relay-log/index&quot;&gt;relay log&lt;/a&gt;. What it does with them depends on whether &lt;a href=&quot;../parallel-replication/index&quot;&gt;parallel replication&lt;/a&gt; is in use. If &lt;a href=&quot;../parallel-replication/index&quot;&gt;parallel replication&lt;/a&gt; is not in use, then the SQL thread applies the events to its local copy of the data. If &lt;a href=&quot;../parallel-replication/index&quot;&gt;parallel replication&lt;/a&gt; is in use, then the SQL thread hands off the events to its worker threads to apply in parallel.</source>
          <target state="translated">슬레이브의 SQL 스레드는 &lt;a href=&quot;../relay-log/index&quot;&gt;릴레이 로그&lt;/a&gt; 에서 이벤트를 읽습니다 . 그것들과 함께하는 것은 &lt;a href=&quot;../parallel-replication/index&quot;&gt;병렬 복제&lt;/a&gt; 가 사용 중인지 여부에 달려 있습니다. &lt;a href=&quot;../parallel-replication/index&quot;&gt;병렬 복제&lt;/a&gt; 를 사용하지 않는 경우 SQL 스레드는 이벤트를 로컬 데이터 사본에 적용합니다. 경우 &lt;a href=&quot;../parallel-replication/index&quot;&gt;병렬 복제가&lt;/a&gt; 사용하고, 다음의 작업자 스레드에 이벤트 오프 SQL 쓰레드 손을 병렬로 적용합니다.</target>
        </trans-unit>
        <trans-unit id="20276999d3f71473839373c926080d02087f7489" translate="yes" xml:space="preserve">
          <source>The slave, however, has been set up without InnoDB support, and defaults to MyISAM, so the foreign key restrictions are not in place.</source>
          <target state="translated">그러나 슬레이브는 InnoDB를 지원하지 않고 설정되었으며 기본값은 MyISAM이므로 외래 키 제한이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1e5fd4e308ed72bcb2996358e7a56b2c67672c7d" translate="yes" xml:space="preserve">
          <source>The slope of the least-squares-fit linear equation determined by the (ColumnX, ColumnY) pairs</source>
          <target state="translated">(ColumnX, ColumnY) 쌍으로 결정된 최소 제곱 법 선형 방정식의 기울기</target>
        </trans-unit>
        <trans-unit id="adf20c19c3a8745b194ea386faa17eaa1b355ed9" translate="yes" xml:space="preserve">
          <source>The slow query log can create a lot of I/O, so it can be beneficial to throttle it in some cases. The slow query log can be throttled by configuring the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#log_slow_rate_limit&quot;&gt;log_slow_rate_limit&lt;/a&gt;&lt;/code&gt; system variable. It can be changed dynamically with &lt;code&gt;&lt;a href=&quot;../set/index#global-session&quot;&gt;SET GLOBAL&lt;/a&gt;&lt;/code&gt;. For example:</source>
          <target state="translated">느린 쿼리 로그는 많은 I / O를 생성 할 수 있으므로 경우에 따라 제한하는 것이 좋습니다. &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#log_slow_rate_limit&quot;&gt;log_slow_rate_limit&lt;/a&gt;&lt;/code&gt; 시스템 변수를 구성하여 느린 쿼리 로그를 조절할 수 있습니다 . &lt;code&gt;&lt;a href=&quot;../set/index#global-session&quot;&gt;SET GLOBAL&lt;/a&gt;&lt;/code&gt; 을 사용 하여 동적으로 변경할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="15033a71c014d4899cb7bf7268e6a030cf21dc11" translate="yes" xml:space="preserve">
          <source>The slow query log can either be written to a file on disk, or it can be written to the &lt;code&gt;&lt;a href=&quot;../mysqlslow_log-table/index&quot;&gt;slow_log&lt;/a&gt;&lt;/code&gt; table in the &lt;code&gt;&lt;a href=&quot;../the-mysql-database-tables/index&quot;&gt;mysql&lt;/a&gt;&lt;/code&gt; database. To choose the slow query log output destination, set the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#log_output&quot;&gt;log_output&lt;/a&gt;&lt;/code&gt; system variable.</source>
          <target state="translated">느린 쿼리 로그는 디스크의 파일에 작성되거나 &lt;code&gt;&lt;a href=&quot;../the-mysql-database-tables/index&quot;&gt;mysql&lt;/a&gt;&lt;/code&gt; 데이터베이스 의 &lt;code&gt;&lt;a href=&quot;../mysqlslow_log-table/index&quot;&gt;slow_log&lt;/a&gt;&lt;/code&gt; 테이블에 작성 될 수 있습니다 . 느린 쿼리 로그 출력 대상을 선택하려면 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#log_output&quot;&gt;log_output&lt;/a&gt;&lt;/code&gt; 시스템 변수를 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="6ac78517e7a84a7e2e7026beb5ce1ffc63942f6c" translate="yes" xml:space="preserve">
          <source>The slow query log can either be written to the &lt;code&gt;&lt;a href=&quot;../mysqlslow_log-table/index&quot;&gt;slow_log&lt;/a&gt;&lt;/code&gt; table in the &lt;code&gt;&lt;a href=&quot;../the-mysql-database-tables/index&quot;&gt;mysql&lt;/a&gt;&lt;/code&gt; database by setting the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#log_output&quot;&gt;log_output&lt;/a&gt;&lt;/code&gt; system variable to &lt;code&gt;TABLE&lt;/code&gt;. It can be changed dynamically with &lt;code&gt;&lt;a href=&quot;../set/index#global-session&quot;&gt;SET GLOBAL&lt;/a&gt;&lt;/code&gt;. For example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../server-system-variables/index#log_output&quot;&gt;log_output&lt;/a&gt;&lt;/code&gt; 시스템 변수를 &lt;code&gt;TABLE&lt;/code&gt; 로 설정하면 느린 쿼리 로그를 &lt;code&gt;&lt;a href=&quot;../the-mysql-database-tables/index&quot;&gt;mysql&lt;/a&gt;&lt;/code&gt; 데이터베이스 의 &lt;code&gt;&lt;a href=&quot;../mysqlslow_log-table/index&quot;&gt;slow_log&lt;/a&gt;&lt;/code&gt; 테이블에 쓸 수 있습니다 . &lt;code&gt;&lt;a href=&quot;../set/index#global-session&quot;&gt;SET GLOBAL&lt;/a&gt;&lt;/code&gt; 을 사용 하여 동적으로 변경할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="851878c2ef25450323fa81a6a7926649ed37fa56" translate="yes" xml:space="preserve">
          <source>The slow query log is a record of SQL queries that took a long time to perform.</source>
          <target state="translated">느린 쿼리 로그는 수행하는 데 시간이 오래 걸린 SQL 쿼리 레코드입니다.</target>
        </trans-unit>
        <trans-unit id="f1f518c544b56158e119934d227be89b94e1f94e" translate="yes" xml:space="preserve">
          <source>The slow query log is disabled by default.</source>
          <target state="translated">느린 쿼리 로그는 기본적으로 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="46b75f2eb8aba06aab8f27d163be095d7282c830" translate="yes" xml:space="preserve">
          <source>The slow query log is output to a file by default. However, it can be explicitly chosen by setting the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#log_output&quot;&gt;log_output&lt;/a&gt;&lt;/code&gt; system variable to &lt;code&gt;FILE&lt;/code&gt;. It can be changed dynamically with &lt;code&gt;&lt;a href=&quot;../set/index#global-session&quot;&gt;SET GLOBAL&lt;/a&gt;&lt;/code&gt;. For example:</source>
          <target state="translated">느린 쿼리 로그는 기본적으로 파일로 출력됩니다. 그러나 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#log_output&quot;&gt;log_output&lt;/a&gt;&lt;/code&gt; 시스템 변수를 &lt;code&gt;FILE&lt;/code&gt; 로 설정하여 명시 적으로 선택할 수 있습니다 . &lt;code&gt;&lt;a href=&quot;../set/index#global-session&quot;&gt;SET GLOBAL&lt;/a&gt;&lt;/code&gt; 을 사용 하여 동적으로 변경할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="835234d62847047323d3d9fc1d4015d35ee1e80a" translate="yes" xml:space="preserve">
          <source>The slow query log makes extended statistics available.</source>
          <target state="translated">느린 쿼리 로그는 확장 된 통계를 사용할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="ab367c617975447c263f94d45be08a7cd86998ca" translate="yes" xml:space="preserve">
          <source>The socket's internal file handle.</source>
          <target state="translated">소켓의 내부 파일 핸들</target>
        </trans-unit>
        <trans-unit id="7eece8a51628f7550e564a37f2924316f0112393" translate="yes" xml:space="preserve">
          <source>The solution</source>
          <target state="translated">해결책</target>
        </trans-unit>
        <trans-unit id="708bee47257b61d5aa3917274dbfb88d27e5bbd1" translate="yes" xml:space="preserve">
          <source>The solution for this is to import the key:</source>
          <target state="translated">이를위한 해결책은 키를 가져 오는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0aa3bc64bab5ad47855af5d02c2dc44c933256a1" translate="yes" xml:space="preserve">
          <source>The solution here can usually get the desired information by fetching a single row, or a small number of rows. It is Order(1).</source>
          <target state="translated">여기서 솔루션은 일반적으로 단일 행 또는 적은 수의 행을 페치하여 원하는 정보를 얻을 수 있습니다. 주문 (1)입니다.</target>
        </trans-unit>
        <trans-unit id="3fe2187777f718ca4b48250700ecb9c53a5e79ac" translate="yes" xml:space="preserve">
          <source>The solution is to explicitly specify a value for the &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#datadir&quot;&gt;datadir&lt;/a&gt;&lt;/code&gt; option either on the command line or in one of the supported &lt;a href=&quot;#server-option-groups&quot;&gt;server option groups&lt;/a&gt; in an &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;option file&lt;/a&gt;. For example:</source>
          <target state="translated">이 솔루션은 명시 적으로 값을 지정하는 것입니다 &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#datadir&quot;&gt;datadir&lt;/a&gt;&lt;/code&gt; 명령 행 또는 지원 중 하나에서 두 옵션 &lt;a href=&quot;#server-option-groups&quot;&gt;서버 옵션 그룹&lt;/a&gt; 에서 &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;옵션 파일을&lt;/a&gt; . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3fd3ec8026bdb4771830be2c6834fd34ec8f74c8" translate="yes" xml:space="preserve">
          <source>The solution is to specify a distinct delimiter for the duration of the process, using the DELIMITER command. The delimiter can be any set of characters you choose, but it needs to be a distinctive set of characters that won't cause further confusion. &lt;code&gt;//&lt;/code&gt; is a common choice, and used throughout the knowledgebase.</source>
          <target state="translated">해결책은 DELIMITER 명령을 사용하여 프로세스 기간 동안 고유 한 구분자를 지정하는 것입니다. 구분 기호는 원하는 문자 집합이 될 수 있지만 더 혼동되지 않는 고유 한 문자 집합이어야합니다. &lt;code&gt;//&lt;/code&gt; 는 일반적인 선택이며 지식 기반 전체에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="da10cfacf0d51bbf164c0b7f1174cf469f30fdb2" translate="yes" xml:space="preserve">
          <source>The solution on CentOS 7 with the Oracle JVM is to rename or delete the usagetracker.properties file (to disable it) and then delete the bogus folder it created in the mysql database directory, then restart.</source>
          <target state="translated">Oracle JVM을 사용하는 CentOS 7의 솔루션은 usagetracker.properties 파일의 이름을 바꾸거나 삭제 (사용하지 않도록 설정) 한 다음 mysql 데이터베이스 디렉토리에 작성된 가짜 폴더를 삭제 한 다음 다시 시작하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0c0c0bd0b68a3fac4f25c1faf524a47adb9757a4" translate="yes" xml:space="preserve">
          <source>The solution uses one table for all the EAV stuff. The columns include the searchable fields plus one &lt;a href=&quot;../blob/index&quot;&gt;BLOB&lt;/a&gt;. Searchable fields are declared appropriately (&lt;a href=&quot;../int/index&quot;&gt;INT&lt;/a&gt;, &lt;a href=&quot;../timestamp/index&quot;&gt;TIMESTAMP&lt;/a&gt;, etc). The BLOB contains JSON-encoding of all the extra fields.</source>
          <target state="translated">이 솔루션은 모든 EAV 항목에 대해 하나의 테이블을 사용합니다. 이 열에는 검색 가능한 필드와 하나의 &lt;a href=&quot;../blob/index&quot;&gt;BLOB가 포함&lt;/a&gt; 됩니다. 검색 가능한 필드는 적절하게 선언됩니다 ( &lt;a href=&quot;../int/index&quot;&gt;INT&lt;/a&gt; , &lt;a href=&quot;../timestamp/index&quot;&gt;TIMESTAMP&lt;/a&gt; 등). BLOB에는 모든 추가 필드의 JSON 인코딩이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="dbaecdc5ad2dc22e7065631dc2d74a093c089be9" translate="yes" xml:space="preserve">
          <source>The solutions:</source>
          <target state="translated">솔루션 :</target>
        </trans-unit>
        <trans-unit id="8ac22816ce083e637fe5371c4c4e1ae489e2fac3" translate="yes" xml:space="preserve">
          <source>The source File &lt;code&gt;jmgoem.cpp&lt;/code&gt;:</source>
          <target state="translated">소스 파일 &lt;code&gt;jmgoem.cpp&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5f11841cbba521e836cf87dd86db8969565c36f9" translate="yes" xml:space="preserve">
          <source>The source File tabfic.cpp:</source>
          <target state="translated">소스 파일 tabfic.cpp :</target>
        </trans-unit>
        <trans-unit id="c9ff04c20f528e52837793318c1e0e71d8a44549" translate="yes" xml:space="preserve">
          <source>The source code includes scripts to install the remaining build dependencies. For Ubuntu, they're located in the &lt;code&gt;debian/&lt;/code&gt; directory. Navigate into the repository and run the &lt;code&gt;autobase-deb.sh&lt;/code&gt; script. Then use</source>
          <target state="translated">소스 코드에는 나머지 빌드 종속성을 설치하는 스크립트가 포함되어 있습니다. 우분투의 경우 &lt;code&gt;debian/&lt;/code&gt; 디렉토리에 있습니다. 저장소로 이동하여 &lt;code&gt;autobase-deb.sh&lt;/code&gt; 스크립트를 실행하십시오 . 그런 다음 사용</target>
        </trans-unit>
        <trans-unit id="5f3847bb4de8d5643bcb5e55c717788a112ee4e3" translate="yes" xml:space="preserve">
          <source>The source definition of a table retrieved via &lt;a href=&quot;../connect-table-types-odbc-table-type-accessing-tables-from-other-dbms/index&quot;&gt;ODBC&lt;/a&gt;, &lt;a href=&quot;../connect-jdbc-table-type-accessing-tables-from-other-dbms/index&quot;&gt;JDBC&lt;/a&gt; or the MySQL API or used by a &lt;a href=&quot;../connect-table-types-pivot-table-type/index&quot;&gt;PIVOT&lt;/a&gt; table.</source>
          <target state="translated">&lt;a href=&quot;../connect-table-types-odbc-table-type-accessing-tables-from-other-dbms/index&quot;&gt;ODBC&lt;/a&gt; , &lt;a href=&quot;../connect-jdbc-table-type-accessing-tables-from-other-dbms/index&quot;&gt;JDBC&lt;/a&gt; 또는 MySQL API 를 통해 검색 되거나 &lt;a href=&quot;../connect-table-types-pivot-table-type/index&quot;&gt;PIVOT&lt;/a&gt; 테이블에서 사용되는 테이블의 소스 정의 .</target>
        </trans-unit>
        <trans-unit id="9ace1bf9f4788f5d0efe970d1b39ac892077b041" translate="yes" xml:space="preserve">
          <source>The source files of this new type are currently distributed only with MariaDB version 10.1, 10.2 and 10.3. This MONGO type is available only when compiling MariaDB from source with:</source>
          <target state="translated">이 새로운 유형의 소스 파일은 현재 MariaDB 버전 10.1, 10.2 및 10.3으로 만 배포됩니다. 이 MONGO 유형은 다음을 사용하여 소스에서 MariaDB를 컴파일 할 때만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba3137481da1e313a4929e1ba0442afef6a2cdee" translate="yes" xml:space="preserve">
          <source>The source table &amp;ldquo;Pivot&amp;rdquo; column must not be nullable (there are no such things as a &amp;ldquo;null&amp;rdquo; column) The creation will be refused even is this nullable column actually does not contain null values.</source>
          <target state="translated">소스 테이블 &quot;Pivot&quot;컬럼은 널 입력 가능하지 않아야합니다 ( &quot;널&quot;컬럼과 같은 것은 없습니다).이 널 입력 가능 컬럼에 실제로 널값이 포함되어 있지 않더라도 작성이 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="ea7717964f458bfba580dca9fc554fe1af2b9265" translate="yes" xml:space="preserve">
          <source>The sp_head::execute() method works as follows:</source>
          <target state="translated">sp_head :: execute () 메소드는 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="a288864b3b1512f9e29fdef75c665f2cd18b280d" translate="yes" xml:space="preserve">
          <source>The spare bits in the Date struct &quot;must&quot; be set to 0x3E.</source>
          <target state="translated">Date 구조체의 스페어 비트 &quot;must&quot;은 0x3E로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="bac15182a0fc037d3608987c4fbab9033774224f" translate="yes" xml:space="preserve">
          <source>The special identifiers &lt;code&gt;latest&lt;/code&gt; (for the latest GA release) and &lt;code&gt;beta&lt;/code&gt; (for the latest beta release) are also supported.</source>
          <target state="translated">&lt;code&gt;latest&lt;/code&gt; (최신 GA 릴리스의 경우) 및 &lt;code&gt;beta&lt;/code&gt; (최신 베타 릴리스의 경우) 특수 식별자 도 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="c8200a308da7759daa12fd8c4d5a74ceb156020d" translate="yes" xml:space="preserve">
          <source>The special properties for sequence tables are:</source>
          <target state="translated">시퀀스 테이블의 특수 속성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fbd24c0528eb9a14f9160f2789372869a9f02bdf" translate="yes" xml:space="preserve">
          <source>The special table types supported by CONNECT are the Virtual table type (&lt;a href=&quot;../connect-table-types-vir/index&quot;&gt;VIR&lt;/a&gt; - introduced in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10015-release-notes/&quot;&gt;MariaDB 10.0.15&lt;/a&gt;), Directory Listing table type (DIR), the Windows Management Instrumentation Table Type (WMI), and the &amp;ldquo;Mac Address&amp;rdquo; type (MAC).</source>
          <target state="translated">CONNECT가 지원하는 특수 테이블 유형은 가상 테이블 유형 ( &lt;a href=&quot;../connect-table-types-vir/index&quot;&gt;VIR&lt;/a&gt; - &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10015-release-notes/&quot;&gt;MariaDB 10.0.15에&lt;/a&gt; 도입 ), 디렉토리 목록 테이블 유형 (DIR), WMI (Windows Management Instrumentation Table Type) 및 &quot;Mac 주소&quot;유형 (MAC)입니다. ).</target>
        </trans-unit>
        <trans-unit id="3309b7fd2524366fe5eb2a4e963846a6344197c9" translate="yes" xml:space="preserve">
          <source>The specific connection items are:</source>
          <target state="translated">특정 연결 항목은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="755bc89bec27b631787c8bd4b5f592af5b786f69" translate="yes" xml:space="preserve">
          <source>The specific options that you would need to set would depend on whether you want one-way TLS or two-way TLS, and whether you want to verify the server certificate.</source>
          <target state="translated">설정해야 할 특정 옵션은 단방향 TLS 또는 양방향 TLS를 원하는지 여부와 서버 인증서를 확인할지 여부에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="4bc0721a6c7c35516dd225bd8cafb69bcbee35e3" translate="yes" xml:space="preserve">
          <source>The specific options used when creating tables based on zip files are:</source>
          <target state="translated">zip 파일을 기반으로 테이블을 작성할 때 사용되는 특정 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="192a3e725a16427e9c6cd12aacdfd466b7ff521f" translate="yes" xml:space="preserve">
          <source>The specific privilege, for example &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;REFERENCES&lt;/code&gt;.</source>
          <target state="translated">특정 권한, 예를 들어 &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; 또는 &lt;code&gt;REFERENCES&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d0bf7814b3a03b5aa0d1e42d710ae39158c2e9a" translate="yes" xml:space="preserve">
          <source>The specified defaults have not been used; rather, the implicit column type defaults have been inserted</source>
          <target state="translated">지정된 기본값이 사용되지 않았습니다. 대신 암시 적 열 유형 기본값이 삽입되었습니다.</target>
        </trans-unit>
        <trans-unit id="1b161ef7f969b84d017a0f04ea2e6022f9275a09" translate="yes" xml:space="preserve">
          <source>The speedup for this query is 20 times.</source>
          <target state="translated">이 쿼리의 속도는 20 배입니다.</target>
        </trans-unit>
        <trans-unit id="efad6e2b7cb416cbba24084c66affc62390c2a77" translate="yes" xml:space="preserve">
          <source>The speedup here is practically infinite, because both MySQL and older MariaDB versions cannot complete the query in any reasonable time.</source>
          <target state="translated">MySQL과 이전 MariaDB 버전 모두 합리적인 시간에 쿼리를 완료 할 수 없기 때문에 속도 향상은 사실상 무한합니다.</target>
        </trans-unit>
        <trans-unit id="d2bb8d8487d2a6ee87f3d594f983e4caef159db3" translate="yes" xml:space="preserve">
          <source>The speedup was:</source>
          <target state="translated">속도 향상은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fc59e2009a7c3da59afd88f8209dbe6f2b581651" translate="yes" xml:space="preserve">
          <source>The speedup you get might be minor, or it might be spectacular; it is hard to predict.</source>
          <target state="translated">당신이 얻는 속도는 미미하거나 훌륭 할 수 있습니다. 예측하기 어렵다.</target>
        </trans-unit>
        <trans-unit id="96af3f6def18051995ac33faca5cbaf3e5437cc0" translate="yes" xml:space="preserve">
          <source>The sql_error_log_rotations logs are stored, older are removed.</source>
          <target state="translated">sql_error_log_rotations 로그가 저장되고 이전 로그는 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="cfb2b9356200b9798d647250e73c7fb0f0436174" translate="yes" xml:space="preserve">
          <source>The square brackets also permit a range match, for example, to match any character from a-z, &lt;code&gt;[a-z]&lt;/code&gt; is used. Numeric ranges are also permitted.</source>
          <target state="translated">대괄호는 또한 범위 일치를 허용합니다 (예 : az의 모든 문자와 일치) . &lt;code&gt;[a-z]&lt;/code&gt; 가 사용됩니다. 숫자 범위도 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="57103d29e3d648f37bd500948134adc0abd5cbdc" translate="yes" xml:space="preserve">
          <source>The square root of 1 is</source>
          <target state="translated">1의 제곱근은</target>
        </trans-unit>
        <trans-unit id="59cfacae09b9490b9df16d12df2022db8de089fe" translate="yes" xml:space="preserve">
          <source>The square root of 10 is</source>
          <target state="translated">10의 제곱근은</target>
        </trans-unit>
        <trans-unit id="114b0cfd8305fef3721a3b53adf317ab63af8be3" translate="yes" xml:space="preserve">
          <source>The square root of 2 is</source>
          <target state="translated">2의 제곱근은</target>
        </trans-unit>
        <trans-unit id="9cf6069fd59460c3f1b696094a6f9d09e858fbbb" translate="yes" xml:space="preserve">
          <source>The square root of 3 is</source>
          <target state="translated">3의 제곱근은</target>
        </trans-unit>
        <trans-unit id="2c42109651ced321119a4c6b7d064e0f8a281d2d" translate="yes" xml:space="preserve">
          <source>The square root of 4 is</source>
          <target state="translated">4의 제곱근은</target>
        </trans-unit>
        <trans-unit id="4e65e9508f3922a7f277190fe9984d46ab179742" translate="yes" xml:space="preserve">
          <source>The square root of 5 is</source>
          <target state="translated">5의 제곱근은</target>
        </trans-unit>
        <trans-unit id="858cd1f7468e52188d8944d50e2926a8b99be7d6" translate="yes" xml:space="preserve">
          <source>The square root of 6 is</source>
          <target state="translated">6의 제곱근은</target>
        </trans-unit>
        <trans-unit id="e8f056b908e4969e4d8e7e7cbd6e2cf6c0ea784b" translate="yes" xml:space="preserve">
          <source>The square root of 7 is</source>
          <target state="translated">7의 제곱근은</target>
        </trans-unit>
        <trans-unit id="c90aca565d91d62bd417bcf7f3bde8cc14e9527c" translate="yes" xml:space="preserve">
          <source>The square root of 8 is</source>
          <target state="translated">8의 제곱근은</target>
        </trans-unit>
        <trans-unit id="fa26429d5492d884f0578d9c93480b546012f44f" translate="yes" xml:space="preserve">
          <source>The square root of 9 is</source>
          <target state="translated">9의 제곱근은</target>
        </trans-unit>
        <trans-unit id="5fe91464747540b1cb475bfb96aaa05a439efc36" translate="yes" xml:space="preserve">
          <source>The stable release including these features will be &lt;strong&gt;&lt;a href=&quot;../what-is-mariadb-53/index&quot;&gt;MariaDB 5.3&lt;/a&gt;&lt;/strong&gt;. That being said, we greatly welcome any feedback / bug reports, and will strive to fix any issues found and we will update the feature preview until &lt;a href=&quot;../what-is-mariadb-53/index&quot;&gt;MariaDB 5.3&lt;/a&gt; stable is ready.</source>
          <target state="translated">이러한 기능을 포함한 안정적인 릴리스는 &lt;strong&gt;&lt;a href=&quot;../what-is-mariadb-53/index&quot;&gt;MariaDB 5.3&lt;/a&gt;&lt;/strong&gt; 입니다. 즉, 우리는 모든 피드백 / 버그 보고서를 환영하며 발견 된 모든 문제를 해결하기 위해 노력하고 &lt;a href=&quot;../what-is-mariadb-53/index&quot;&gt;MariaDB 5.3&lt;/a&gt; 안정이 준비 될 때까지 기능 미리보기를 업데이트 할 것 입니다.</target>
        </trans-unit>
        <trans-unit id="cbf4471da7e55cce064c326a322a1953e664eee1" translate="yes" xml:space="preserve">
          <source>The stage the process is currently in.</source>
          <target state="translated">프로세스가 현재 진행중인 단계입니다.</target>
        </trans-unit>
        <trans-unit id="9eedc8fc5ea92bd85759f81fd8e25baf4bcba477" translate="yes" xml:space="preserve">
          <source>The standard ColumnStore RPM and DEB packages are available at &lt;a href=&quot;https://mariadb.com/downloads/columnstore&quot;&gt;https://mariadb.com/downloads/columnstore&lt;/a&gt;. If you need to install ColumnStore without root-level permissions, you must use the binary tarball, which is available at &lt;a href=&quot;https://downloads.mariadb.com/ColumnStore/&quot;&gt;https://downloads.mariadb.com/ColumnStore/&lt;/a&gt;</source>
          <target state="translated">표준 ColumnStore RPM 및 DEB 패키지는 &lt;a href=&quot;https://mariadb.com/downloads/columnstore&quot;&gt;https://mariadb.com/downloads/columnstore&lt;/a&gt; 에서 사용할 수 있습니다 . 루트 수준 권한없이 ColumnStore를 설치해야하는 경우 &lt;a href=&quot;https://downloads.mariadb.com/ColumnStore/&quot;&gt;https://downloads.mariadb.com/ColumnStore/에&lt;/a&gt; 있는 바이너리 tarball을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="0f6a6743c98233bb76cc0f3dc0519533d252a917" translate="yes" xml:space="preserve">
          <source>The standard InnoDB Monitor returns extensive InnoDB information, particularly lock, semaphore, I/O and buffer activity:</source>
          <target state="translated">표준 InnoDB 모니터는 광범위한 InnoDB 정보, 특히 잠금, 세마포어, I / O 및 버퍼 활동을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1c0df5d6c289bc5dac793b6d11b80f0304aceb57" translate="yes" xml:space="preserve">
          <source>The standard SQL specification says that classes beginning with 0, 1, 2, 3, 4, A, B, C, D, E, F and G are reserved for standard-defined classes, while other classes are vendor-specific. It also says that, when the class is standard-defined, subclasses starting with those characters (except for '000') are standard-defined subclasses, while other subclasses are vendor-defined. However, MariaDB and MySQL do not strictly obey this rule.</source>
          <target state="translated">표준 SQL 사양에 따르면 0, 1, 2, 3, 4, A, B, C, D, E, F 및 G로 시작하는 클래스는 표준 정의 클래스 용으로 예약되어 있으며 다른 클래스는 공급 업체별로 지정되어 있습니다. 또한 클래스가 표준 정의 된 경우 해당 문자로 시작하는 서브 클래스 ( '000'제외)는 표준 정의 서브 클래스이고 다른 서브 클래스는 벤더 정의입니다. 그러나 MariaDB와 MySQL은이 규칙을 엄격하게 준수하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b6cfb21104adf59b0f40b825ce359cd7b57ff25a" translate="yes" xml:space="preserve">
          <source>The standard and Galera cluster database servers are the same, except that for Galera Cluster, the wsrep API patch is included. Enable the patch with the CMake configuration options &lt;code&gt;WITH_WSREP&lt;/code&gt; and &lt;code&gt;WITH_INNODB_DISALLOW_WRITES&lt;/code&gt;. To build the database server, &lt;em&gt;cd&lt;/em&gt; into the &lt;em&gt;server/ &lt;/em&gt; directory and run the following commands:</source>
          <target state="translated">Galera Cluster의 경우 wsrep API 패치가 포함 된 것을 제외하고 표준 및 Galera 클러스터 데이터베이스 서버는 동일합니다. CMake 구성 옵션 &lt;code&gt;WITH_WSREP&lt;/code&gt; 및 &lt;code&gt;WITH_INNODB_DISALLOW_WRITES&lt;/code&gt; 로 패치를 활성화하십시오 . 데이터베이스 서버를 빌드하려면 &lt;em&gt;server /&lt;/em&gt; 디렉토리 로 &lt;em&gt;cd&lt;/em&gt; 하고 다음 명령을 실행하십시오.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8437b99cf107a9de6a415ab023c8872523dca140" translate="yes" xml:space="preserve">
          <source>The standard version of the &lt;a href=&quot;https://www.wolfssl.com/products/wolfssl/&quot;&gt;wolfSSL&lt;/a&gt; library has not been certified to meet the FIPS 140-2 standard, but a special &lt;a href=&quot;https://www.wolfssl.com/wolfssl-fips-ready/&quot;&gt;&quot;FIPS-ready&quot;&lt;/a&gt; version has been certified. Unfortunately, the &quot;FIPS-ready&quot; version of wolfSSL uses a license that is incompatible with MariaDB's license, so it cannot be used with MariaDB.</source>
          <target state="translated">&lt;a href=&quot;https://www.wolfssl.com/products/wolfssl/&quot;&gt;wolfSSL&lt;/a&gt; 라이브러리 의 표준 버전은 FIPS 140-2 표준을 충족하도록 인증되지 않았지만 특수한 &lt;a href=&quot;https://www.wolfssl.com/wolfssl-fips-ready/&quot;&gt;&quot;FIPS- 준비&quot;&lt;/a&gt; 버전이 인증되었습니다. 불행히도, &quot;FIPS-ready&quot;버전의 wolfSSL은 MariaDB 라이센스와 호환되지 않는 라이센스를 사용하므로 MariaDB와 함께 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f087ad11cceab9c29c349f93be34d39936f9cb46" translate="yes" xml:space="preserve">
          <source>The start autoincrement value for the table set during CREATE TABLE</source>
          <target state="translated">CREATE TABLE 동안 테이블 세트의 시작 자동 증가 값</target>
        </trans-unit>
        <trans-unit id="faf8810b7c01e172cf17e01d0741feea6b1944c0" translate="yes" xml:space="preserve">
          <source>The start command can take an option of Remove. The Start Remove option is used to remove all data from the enumerated list of dbroots and redistribute the data to the remaining dbroots. This should be done before taking a dbroot out of service in order to preserve the data on that dbroot. The dbroot list is a space delimited list of integers representing the dbroots to be emptied.</source>
          <target state="translated">시작 명령은 제거 옵션을 사용할 수 있습니다. 제거 시작 옵션은 열거 된 dbroot 목록에서 모든 데이터를 제거하고 나머지 dbroot에 데이터를 재분배하는 데 사용됩니다. 해당 dbroot의 데이터를 보존하기 위해 dbroot를 서비스 중단하기 전에 수행해야합니다. dbroot 목록은 비울 dbroot를 나타내는 공백으로 구분 된 정수 목록입니다.</target>
        </trans-unit>
        <trans-unit id="126b366bfa312f6a2b162df1bf93a282c6593e43" translate="yes" xml:space="preserve">
          <source>The state is &quot;Valid&quot; for a normal state, &quot;Invalid&quot; if a cpimport has completed but the table has not yet been accessed (min/max values will be invalid) or &quot;Updating&quot; if there is a DML statement writing to the column</source>
          <target state="translated">cpimport가 완료되었지만 테이블에 아직 액세스하지 않은 경우 (최소 / 최대 값이 유효하지 않음) 열에 쓰는 DML 문이있는 경우 &quot;업데이트&quot;인 경우 정상 상태 인 경우 상태가 &quot;유효 함&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="93ec3f1bc0002753514b1637d31afa6c14908428" translate="yes" xml:space="preserve">
          <source>The state of the SQL driver threads, same as in &lt;code&gt;&lt;a href=&quot;../show-processlist/index&quot;&gt;SHOW PROCESSLIST&lt;/a&gt;&lt;/code&gt;. When the slave is delaying the execution of an event due to &lt;code&gt;MASTER_DELAY&lt;/code&gt;, this field displays: &quot;&lt;code&gt;Waiting until MASTER_DELAY seconds after master executed event&lt;/code&gt;&quot;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../show-processlist/index&quot;&gt;SHOW PROCESSLIST&lt;/a&gt;&lt;/code&gt; 와 동일한 SQL 드라이버 스레드 상태입니다 . 슬레이브가 &lt;code&gt;MASTER_DELAY&lt;/code&gt; 로 인해 이벤트 실행을 지연시키는 경우이 필드에는 &quot; &lt;code&gt;Waiting until MASTER_DELAY seconds after master executed event&lt;/code&gt; &quot;이 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="f5ba35a9018ade2fb145ef0bb40f94abab1633a4" translate="yes" xml:space="preserve">
          <source>The state of the extent (see below)</source>
          <target state="translated">익스텐트 상태 (아래 참조)</target>
        </trans-unit>
        <trans-unit id="ffe70cc3e8f2648640b0365ca80045a9eebb6a6d" translate="yes" xml:space="preserve">
          <source>The state-of-art diagram with zooming and keyboard support</source>
          <target state="translated">확대 / 축소 및 키보드 지원을 갖춘 최신 다이어그램</target>
        </trans-unit>
        <trans-unit id="fcaee188291559a7f9825cdbbe4a190b0f77f3fc" translate="yes" xml:space="preserve">
          <source>The statement 'SET %s' cannot invoke a stored function.</source>
          <target state="translated">'SET % s'문은 저장된 함수를 호출 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e5790416ea3117220ad0ea90910e5217db3fc20c" translate="yes" xml:space="preserve">
          <source>The statement (%lu) has no open cursor.</source>
          <target state="translated">명령문 (% lu)에 열린 커서가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f114a3fd518be77e1eaf3ec8b1107ba7ebad4442" translate="yes" xml:space="preserve">
          <source>The statement being executed.</source>
          <target state="translated">실행중인 명령문</target>
        </trans-unit>
        <trans-unit id="9414164a478b29173dcd6b1054a43aebe0ad5818" translate="yes" xml:space="preserve">
          <source>The statement displays the following output fields:</source>
          <target state="translated">명령문은 다음 출력 필드를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="a817439bdea5db82c3393b439b1f0e0ab79870fe" translate="yes" xml:space="preserve">
          <source>The statement does not automatically restart the slave threads.</source>
          <target state="translated">명령문은 슬레이브 스레드를 자동으로 다시 시작하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eceec852edbc26e2d21efd5622a4a0c877b2fbb9" translate="yes" xml:space="preserve">
          <source>The statement information area contains the following data:</source>
          <target state="translated">명령문 정보 영역에는 다음 데이터가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="ebeaa78fca87c45e16a4a82425fa922f7008c2c9" translate="yes" xml:space="preserve">
          <source>The statement interprets all fields in the file as having the same character-set, regardless of the column data type. To properly interpret file contents, you must ensure that it was written with the correct character-set. If you write a data file with &lt;code&gt;&lt;a href=&quot;../mysqldump/index&quot;&gt;mysqldump -T&lt;/a&gt;&lt;/code&gt; or with the &lt;code&gt;&lt;a href=&quot;../select-into-outfile/index&quot;&gt;SELECT INTO OUTFILE&lt;/a&gt;&lt;/code&gt; statement with the &lt;code&gt;&lt;a href=&quot;../mysql-command-line-client/index&quot;&gt;mysql&lt;/a&gt;&lt;/code&gt; client, be sure to use the &lt;code&gt;--default-character-set&lt;/code&gt; option, so that the output is written with the desired character-set.</source>
          <target state="translated">명령문은 열 데이터 유형에 관계없이 파일의 모든 필드가 동일한 문자 세트를 갖는 것으로 해석합니다. 파일 내용을 올바르게 해석하려면 파일이 올바른 문자 세트로 작성되었는지 확인해야합니다. &lt;code&gt;&lt;a href=&quot;../mysqldump/index&quot;&gt;mysqldump -T&lt;/a&gt;&lt;/code&gt; 를 사용 하거나 &lt;code&gt;&lt;a href=&quot;../mysql-command-line-client/index&quot;&gt;mysql&lt;/a&gt;&lt;/code&gt; 클라이언트 와 함께 &lt;code&gt;&lt;a href=&quot;../select-into-outfile/index&quot;&gt;SELECT INTO OUTFILE&lt;/a&gt;&lt;/code&gt; 문을 사용하여 데이터 파일을 작성하는 경우 출력이 원하는 문자 세트로 작성되도록 &lt;code&gt;--default-character-set&lt;/code&gt; 옵션 을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="024ab57b93aafebda310d6337783098fd4983ec9" translate="yes" xml:space="preserve">
          <source>The statement is unsafe because it uses INSERT DELAYED. This is unsafe because the times when rows are inserted cannot be predicted.</source>
          <target state="translated">INSERT DELAYED를 사용하므로 명령문이 안전하지 않습니다. 행이 삽입되는 시간을 예측할 수 없기 때문에 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6046197f095e7d46644b40685e7b743d4d63f28d" translate="yes" xml:space="preserve">
          <source>The statement is unsafe because it uses a LIMIT clause. This is unsafe because the set of rows included cannot be predicted.</source>
          <target state="translated">이 명령문은 LIMIT 절을 사용하므로 안전하지 않습니다. 포함 된 행 집합을 예측할 수 없기 때문에 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a1974a7057742e53b553249cff562c40d7e79d13" translate="yes" xml:space="preserve">
          <source>The statement is unsafe because it uses the general log, slow query log, or performance_schema table(s). This is unsafe because system tables may differ on slaves.</source>
          <target state="translated">명령문은 일반 로그, 느린 쿼리 로그 또는 performance_schema 테이블을 사용하므로 안전하지 않습니다. 슬레이브에서는 시스템 테이블이 다를 수 있으므로 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="353f8b0a5d08176365b8c5dd2d2de2b75b73fa7b" translate="yes" xml:space="preserve">
          <source>The statement is used by &lt;code&gt;mysqlcheck&lt;/code&gt; (as invoked by &lt;code&gt;mysql_upgrade&lt;/code&gt;).</source>
          <target state="translated">명령문은 &lt;code&gt;mysqlcheck&lt;/code&gt; 에 의해 사용됩니다 ( &lt;code&gt;mysql_upgrade&lt;/code&gt; 에 의해 호출 됨 ).</target>
        </trans-unit>
        <trans-unit id="f5226d3b36f20ce811d482c681f79723419ee0bf" translate="yes" xml:space="preserve">
          <source>The statement list within a &lt;code&gt;REPEAT&lt;/code&gt; statement is repeated until the search_condition is true. Thus, a &lt;code&gt;REPEAT&lt;/code&gt; always enters the loop at least once. statement_list consists of one or more statements, each terminated by a semicolon (i.e., &lt;code&gt;;&lt;/code&gt;) statement delimiter.</source>
          <target state="translated">search_condition이 true가 될 때까지 &lt;code&gt;REPEAT&lt;/code&gt; 문 내의 명령문 목록 이 반복됩니다. 따라서 &lt;code&gt;REPEAT&lt;/code&gt; 는 항상 한 번 이상 루프에 들어갑니다. statement_list는 하나 이상의 명령문으로 구성되며 각 명령문은 세미콜론 (즉, &lt;code&gt;;&lt;/code&gt; ) 명령문 분리 문자로 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="fcec100b4e58aacf2eddca4ac713f668a4301c9d" translate="yes" xml:space="preserve">
          <source>The statement list within a &lt;code&gt;WHILE&lt;/code&gt; statement is repeated as long as the &lt;code&gt;search_condition&lt;/code&gt; is true. statement_list consists of one or more statements. If the loop must be executed at least once, &lt;code&gt;&lt;a href=&quot;../repeat-loop/index&quot;&gt;REPEAT ... LOOP&lt;/a&gt;&lt;/code&gt; can be used instead.</source>
          <target state="translated">&lt;code&gt;search_condition&lt;/code&gt; 이 true이면 &lt;code&gt;WHILE&lt;/code&gt; 문 내의 명령문 목록 이 반복됩니다 . statement_list는 하나 이상의 문으로 구성됩니다. 루프를 한 번 이상 실행해야하는 경우 &lt;code&gt;&lt;a href=&quot;../repeat-loop/index&quot;&gt;REPEAT ... LOOP&lt;/a&gt;&lt;/code&gt; 을 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19254046eb085616bb9d613199f71c38f923475a" translate="yes" xml:space="preserve">
          <source>The statement returns the binlog coordinates pointing at the snapshot.</source>
          <target state="translated">명령문은 스냅 샷을 가리키는 binlog 좌표를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="2bbab5bec6a5730534f03db9ec7e58e05d02df32" translate="yes" xml:space="preserve">
          <source>The statement used to generate the intermediate mysql table.</source>
          <target state="translated">중간 mysql 테이블을 생성하는 데 사용 된 명령문입니다.</target>
        </trans-unit>
        <trans-unit id="2853b03e582bbc49181bdf3acbd8fdf3d6839a17" translate="yes" xml:space="preserve">
          <source>The statement will wait for other sessions that hold table locks. While the attempt to set read_only is waiting, other requests for table locks or transactions will also wait until read_only has been set.</source>
          <target state="translated">명령문은 테이블 잠금을 보유하는 다른 세션을 기다립니다. read_only 설정 시도가 대기중인 동안 테이블 잠금 또는 트랜잭션에 대한 다른 요청도 read_only가 설정 될 때까지 대기합니다.</target>
        </trans-unit>
        <trans-unit id="11e2e129c8a600ce65670e511caae697cb1794b3" translate="yes" xml:space="preserve">
          <source>The statistics are mainly based on groups of index elements of the same value. In a primary key, every index is unique, so every group size is one. In a non-unique index, you may have multiple keys with the same value. A worst-case example would be having large groups with the same value, for example an index on a boolean field.</source>
          <target state="translated">통계는 주로 같은 값의 인덱스 요소 그룹을 기반으로합니다. 기본 키에서 모든 인덱스는 고유하므로 모든 그룹 크기는 1입니다. 고유하지 않은 인덱스에서는 동일한 값을 가진 여러 키가있을 수 있습니다. 최악의 예는 값이 같은 큰 그룹 (예 : 부울 필드의 인덱스)을 갖는 것입니다.</target>
        </trans-unit>
        <trans-unit id="24688ffb09145a6c878c29e1f1d08f19e59f1a68" translate="yes" xml:space="preserve">
          <source>The statistics were supplied through the MySQL Storage Engine Interface, which puts a lot of restrictions on what kind of data is supplied (for example, there is no way to get any data about value distribution in a non-indexed column)</source>
          <target state="translated">통계는 MySQL Storage Engine Interface를 통해 제공되었으며, 이는 어떤 종류의 데이터가 제공되는지에 대해 많은 제한을 두었습니다 (예 : 인덱싱되지 않은 열의 값 분포에 대한 데이터를 가져올 방법이 없음)</target>
        </trans-unit>
        <trans-unit id="03f916e58cdb707870b900dbba9e38b488a07799" translate="yes" xml:space="preserve">
          <source>The status of MariaDB's &lt;code&gt;systemd&lt;/code&gt; service can be obtained by executing the following:</source>
          <target state="translated">MariaDB의 &lt;code&gt;systemd&lt;/code&gt; 서비스 상태 는 다음을 실행하여 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5e634739e9065c7f424368908b24126e9bac0fa" translate="yes" xml:space="preserve">
          <source>The status variable &lt;code&gt;Com_slave_start&lt;/code&gt; is replaced with &lt;a href=&quot;../replication-and-binary-log-status-variables/index#com_start_slave&quot;&gt;Com_start_slave&lt;/a&gt;.</source>
          <target state="translated">상태 변수 &lt;code&gt;Com_slave_start&lt;/code&gt; 가 Com_start_slave 로 대체 &lt;a href=&quot;../replication-and-binary-log-status-variables/index#com_start_slave&quot;&gt;되었습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8f061b67a525f3eece7bb04b24f961c596c05fb6" translate="yes" xml:space="preserve">
          <source>The status variable &lt;code&gt;Com_slave_stop&lt;/code&gt; is replaced with &lt;a href=&quot;../replication-and-binary-log-status-variables/index#com_stop_slave&quot;&gt;Com_stop_slave&lt;/a&gt;.</source>
          <target state="translated">상태 변수 &lt;code&gt;Com_slave_stop&lt;/code&gt; 는 대체됩니다 &lt;a href=&quot;../replication-and-binary-log-status-variables/index#com_stop_slave&quot;&gt;Com_stop_slave&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7fc4c122e63348ed7de2c9c52f98a37933ab493a" translate="yes" xml:space="preserve">
          <source>The status variables &lt;a href=&quot;../cassandra-status-variables/index#cassandra_row_inserts&quot;&gt;Cassandra_row_inserts&lt;/a&gt; and &lt;a href=&quot;../cassandra-status-variables/index#cassandra_row_insert_batches&quot;&gt;Cassandra_row_insert_batches&lt;/a&gt; allow one to see whether inserts are actually batched.</source>
          <target state="translated">상태 변수 &lt;a href=&quot;../cassandra-status-variables/index#cassandra_row_inserts&quot;&gt;Cassandra_row_inserts&lt;/a&gt; 및 &lt;a href=&quot;../cassandra-status-variables/index#cassandra_row_insert_batches&quot;&gt;Cassandra_row_insert_batches를&lt;/a&gt; 사용하면 삽입이 실제로 배치되었는지 여부를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb54ece2b8f3a47f299d10df1a0960c57518d68e" translate="yes" xml:space="preserve">
          <source>The status variables listed on this page relate to encrypting data during transfer with the Transport Layer Security (TLS) protocol. Often, the term Secure Socket Layer (SSL) is used interchangeably with TLS, although strictly speaking, the SSL protocol is a predecessor to TLS and is no longer considered secure.</source>
          <target state="translated">이 페이지에 나열된 상태 변수는 TLS (Transport Layer Security) 프로토콜로 전송하는 동안 데이터를 암호화하는 것과 관련이 있습니다. SSL (Secure Socket Layer)이라는 용어는 TLS와 상호 교환 가능하게 사용되지만 SSL 프로토콜은 TLS의 전신이며 더 이상 안전한 것으로 간주되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ed6404a00884e4a1c814b4fe32b4f8e4142164f0" translate="yes" xml:space="preserve">
          <source>The steps are:</source>
          <target state="translated">단계는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="31b65c15142bcd0f57cbbcf562943709719a016f" translate="yes" xml:space="preserve">
          <source>The steps to create a binary tar file are:</source>
          <target state="translated">이진 tar 파일을 만드는 단계는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b4a82ca06ab4da9938461a9239fcd73cfa612444" translate="yes" xml:space="preserve">
          <source>The steps were checked on a fresh install of Ubuntu 16.04.2 LTS Xenial.</source>
          <target state="translated">이 단계는 Ubuntu 16.04.2 LTS Xenial을 새로 설치했을 때 확인되었습니다.</target>
        </trans-unit>
        <trans-unit id="4ef3cbab2842c4289659fdaee6bc2e608059cb2f" translate="yes" xml:space="preserve">
          <source>The stop file is a temporary file that you create on your system when you want to pause the execution of mysql-test-run. When enabled via the command-line or environment variable options, mysql-test-run will periodically check for the existence of the file and if it exists it will stop until the file is no longer present.</source>
          <target state="translated">중지 파일은 mysql-test-run 실행을 일시 중지하려고 할 때 시스템에서 생성하는 임시 파일입니다. 명령 행 또는 환경 변수 옵션을 통해 활성화되면 mysql-test-run은 파일의 존재 여부를 주기적으로 점검하고 파일이 존재하면 파일이 더 이상 존재하지 않을 때까지 중지합니다.</target>
        </trans-unit>
        <trans-unit id="07492e14f3f26ca26341d54cf54756248b92b200" translate="yes" xml:space="preserve">
          <source>The stopword list is determined as follows:</source>
          <target state="translated">중지 단어 목록은 다음과 같이 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="9b27ec1caca28b6ba37174f6740285c843b4bdcc" translate="yes" xml:space="preserve">
          <source>The storage engine API also allows storage engines to set or limit the logging format, which helps reduce errors with replicating between masters and slaves with different storage engines.</source>
          <target state="translated">스토리지 엔진 API는 또한 스토리지 엔진이 로깅 형식을 설정하거나 제한 할 수 있도록하여 스토리지 엔진이 다른 마스터와 슬레이브 간의 복제로 인한 오류를 줄입니다.</target>
        </trans-unit>
        <trans-unit id="55c0d6cba112145b82dc43b0e94c3abf30c77f5c" translate="yes" xml:space="preserve">
          <source>The storage engine contains a database called &lt;code&gt;performance_schema&lt;/code&gt;, which in turn consists of a number of tables that can be queried with regular SQL statements, returning specific performance information.</source>
          <target state="translated">스토리지 엔진에는 &lt;code&gt;performance_schema&lt;/code&gt; 라는 데이터베이스가 포함되어 있으며,이 데이터베이스는 일반 SQL 문으로 조회 할 수있는 여러 테이블로 구성되어 특정 성능 정보를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="bf394e62b95ac9490cae79c8b0bac6fd3fcc8527" translate="yes" xml:space="preserve">
          <source>The storage engine for the table does not support binary table dump</source>
          <target state="translated">테이블의 스토리지 엔진이 이진 테이블 덤프를 지원하지 않습니다</target>
        </trans-unit>
        <trans-unit id="d5150b01832657277a78bf01eb2a15f22ce7dff1" translate="yes" xml:space="preserve">
          <source>The storage engine for the table doesn't support %s</source>
          <target state="translated">테이블의 스토리지 엔진이 % s를 지원하지 않습니다</target>
        </trans-unit>
        <trans-unit id="60b81ad9091de9e4002b365713d0a708952406ce" translate="yes" xml:space="preserve">
          <source>The storage engine must be installed before it can be used.</source>
          <target state="translated">스토리지 엔진을 사용하려면 먼저 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="f8ca49a9dbef76d353cf03faefcd80e283c4f5aa" translate="yes" xml:space="preserve">
          <source>The storage needed for the above items can add up to the size of the original table, or more in some cases.</source>
          <target state="translated">위의 항목에 필요한 스토리지는 원래 테이블의 크기 이상이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="734f9b47f1b4f563de24fe5c45d639e1316659c8" translate="yes" xml:space="preserve">
          <source>The storage requirements must not change.</source>
          <target state="translated">스토리지 요구 사항은 변경되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="35427761f6138f22852845bcec4a56c6a84e237a" translate="yes" xml:space="preserve">
          <source>The story of handlersocket can be found &lt;a href=&quot;http://yoshinorimatsunobu.blogspot.com/2010/10/using-mysql-as-nosql-story-for.html&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">handlersocket의 이야기는 &lt;a href=&quot;http://yoshinorimatsunobu.blogspot.com/2010/10/using-mysql-as-nosql-story-for.html&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8c0bf476deb67649da422ee60413caad0a95b5ad" translate="yes" xml:space="preserve">
          <source>The story of handlersocket can be found &lt;a href=&quot;https://yoshinorimatsunobu.blogspot.com/2010/10/using-mysql-as-nosql-story-for.html&quot;&gt;here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1f07ae7b2e3fa1c6511f3fd45685fb6f97c1d2d" translate="yes" xml:space="preserve">
          <source>The strategy can handle correlated subqueries.</source>
          <target state="translated">이 전략은 상관 된 하위 쿼리를 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="b90e7bb7ba52bc1f1dd1556dd3a6183171142a0c" translate="yes" xml:space="preserve">
          <source>The strength of the encryption is based on how good the random generator is.</source>
          <target state="translated">암호화의 강도는 랜덤 생성기가 얼마나 좋은지에 따라 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="241e353390ad82dad790b80f7ffddd0d2e682170" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;mariadb-&lt;/code&gt; has to be pre-pended to the version number. For example, to configure your system to install from the repository of &lt;a href=&quot;../what-is-mariadb-103/index&quot;&gt;MariaDB 10.3&lt;/a&gt;, that would be:</source>
          <target state="translated">문자열 &lt;code&gt;mariadb-&lt;/code&gt; 는 버전 번호 앞에 추가 해야합니다. 예를 들어, &lt;a href=&quot;../what-is-mariadb-103/index&quot;&gt;MariaDB 10.3&lt;/a&gt; 저장소에서 설치하도록 시스템을 구성하려면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f1fec95d02430f215e2b5e4b5c78b39b5cc1b32e" translate="yes" xml:space="preserve">
          <source>The string length for the result is given by this formula:</source>
          <target state="translated">결과의 문자열 길이는 다음 공식으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="c1419a8b7811f1b07fe4986c00e4323e4f6090fc" translate="yes" xml:space="preserve">
          <source>The string to &quot;assign&quot; to the DEBUG_SYNC variable can contain:</source>
          <target state="translated">DEBUG_SYNC 변수에 &quot;할당&quot;할 문자열은 다음을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffe8266f76f1b1c763ca02c26a7d4c3a3bc54501" translate="yes" xml:space="preserve">
          <source>The subclass, if it is set, indicates a particular condition, or a particular group of conditions within the class. However the '000' sequence means 'no subclass'.</source>
          <target state="translated">서브 클래스 (설정된 경우)는 특정 조건 또는 클래스 내의 특정 조건 그룹을 나타냅니다. 그러나 '000'시퀀스는 '하위 클래스 없음'을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="9ebe9f4e4ea04fe7823bd4d24c56160b37ef19b1" translate="yes" xml:space="preserve">
          <source>The subquery is located directly or indirectly under an OR operation in the WHERE clause of the outer query.</source>
          <target state="translated">부속 조회는 외부 조회의 WHERE 절에서 OR 조작 아래에 직접 또는 간접적으로 위치합니다.</target>
        </trans-unit>
        <trans-unit id="126481ce1fe901b4c0d5f110d9f8553321acf593" translate="yes" xml:space="preserve">
          <source>The subquery is located in the SELECT or HAVING clauses of the outer query.</source>
          <target state="translated">부속 조회는 외부 조회의 SELECT 또는 HAVING 절에 있습니다.</target>
        </trans-unit>
        <trans-unit id="ecf6423ae5a4f019d8faa753ca6db51708ef0bee" translate="yes" xml:space="preserve">
          <source>The subquery is uncorrelated, that is, we can run it independently of the upper query. The idea of semi-join materialization is to do just that, and fill a temporary table with possible values of the City.country field of big cities, and then do a join with countries in Europe:</source>
          <target state="translated">하위 쿼리는 서로 관련이 없습니다. 즉, 상위 쿼리와 독립적으로 실행할 수 있습니다. semi-join materialization의 아이디어는 바로 그 일을하고 대도시의 City.country 필드 값으로 임시 테이블을 채우고 유럽 국가들과 합류하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="10df935be8a870b55e27c99e3d65302ae801f5c7" translate="yes" xml:space="preserve">
          <source>The subquery itself is a UNION, while the IN predicate may be anywhere in the query where IN is allowed.</source>
          <target state="translated">부속 조회 자체는 UNION 인 반면 IN 술어는 IN이 허용되는 조회의 임의의 위치에있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef45887a49d4bf9f881c6ae0b6b39743fad4cc76" translate="yes" xml:space="preserve">
          <source>The subquery predicate itself is negated.</source>
          <target state="translated">부속 조회 술어 자체는 무효화됩니다.</target>
        </trans-unit>
        <trans-unit id="70c276205760be6fdc340039d0bd26a0b3485fd6" translate="yes" xml:space="preserve">
          <source>The subtype of an &lt;a href=&quot;../connect-table-types-oem/index&quot;&gt;OEM&lt;/a&gt; table type.</source>
          <target state="translated">&lt;a href=&quot;../connect-table-types-oem/index&quot;&gt;OEM&lt;/a&gt; 테이블 유형 의 하위 유형입니다.</target>
        </trans-unit>
        <trans-unit id="d510664b63b4b9eeb82ec521661a2aae0e179dac" translate="yes" xml:space="preserve">
          <source>The sudo configuration file on each node will need to be modified to add in the non-root user. The recommended way is to use the Unix command, visudo. The following example will add the &amp;lsquo;guest&amp;rsquo; user: visudo</source>
          <target state="translated">루트가 아닌 사용자를 추가하려면 각 노드의 sudo 구성 파일을 수정해야합니다. 권장되는 방법은 유닉스 명령 인 visudo를 사용하는 것입니다. 다음 예제는 'guest'사용자를 추가합니다 : visudo</target>
        </trans-unit>
        <trans-unit id="11c32bcaa2a25bf8d19ea0e0a9d554bdd66e018a" translate="yes" xml:space="preserve">
          <source>The sudo configuration file on each node will need to be modified to add in the non-root user. The recommended way is to use the Unix command, visudo. The following example will add the &amp;lsquo;mysql&amp;rsquo; user: visudo</source>
          <target state="translated">루트가 아닌 사용자를 추가하려면 각 노드의 sudo 구성 파일을 수정해야합니다. 권장되는 방법은 유닉스 명령 인 visudo를 사용하는 것입니다. 다음 예제는 'mysql'사용자를 추가합니다 : visudo</target>
        </trans-unit>
        <trans-unit id="f42a9edbc1faba400c2f5a02a61e7381993accd6" translate="yes" xml:space="preserve">
          <source>The sudo configuration on each node will need to allow the new user to run several commands. Add the following lines to your /etc/sudoers file, changing the path of each command if necessary on your system.</source>
          <target state="translated">각 노드의 sudo 구성은 새 사용자가 여러 명령을 실행할 수 있도록해야합니다. 시스템에서 필요한 경우 각 명령의 경로를 변경하여 / etc / sudoers 파일에 다음 행을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="e39f99d4986dc8b7cb8152ff9992d39bfbc4835d" translate="yes" xml:space="preserve">
          <source>The sudo configuration on each node will need to allow the new user to run the chmod, chown, mount, and umount commands. Add the following lines to your /etc/sudoers file, changing the path of each command if necessary on your system.</source>
          <target state="translated">각 노드의 sudo 구성은 새 사용자가 chmod, chown, mount 및 umount 명령을 실행할 수 있도록해야합니다. 시스템에서 필요한 경우 각 명령의 경로를 변경하여 / etc / sudoers 파일에 다음 행을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="36732fe0f3b6e1a8bf44d6b96e2d6a2afafc5899" translate="yes" xml:space="preserve">
          <source>The sudo configuration on each node will need to allow the new user to run the gluster, mount, umount, and chmod commands. Add the following lines to your /etc/sudoers file, changing the paths to those commands if necessary on your system.</source>
          <target state="translated">각 노드의 sudo 구성은 새 사용자가 gluster, mount, umount 및 chmod 명령을 실행할 수 있도록해야합니다. 시스템에서 필요한 경우 해당 명령의 경로를 변경하여 / etc / sudoers 파일에 다음 행을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="fb8c062ec1fac277d22c7ab9a67f892cc41299c3" translate="yes" xml:space="preserve">
          <source>The suffix can be upper or lower-case.</source>
          <target state="translated">접미사는 대문자 또는 소문자 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c155760f364f18fa34bb62a513c3e390d587d873" translate="yes" xml:space="preserve">
          <source>The suffix to use for names of copied databases.</source>
          <target state="translated">복사 된 데이터베이스 이름에 사용할 접미사입니다.</target>
        </trans-unit>
        <trans-unit id="9211ac8a6b4e486c86e4cb27fbcea165b400d532" translate="yes" xml:space="preserve">
          <source>The suggested upgrade procedure is:</source>
          <target state="translated">제안 된 업그레이드 절차는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0ad80536fee89c43f0d72681c4e6eac956187ff8" translate="yes" xml:space="preserve">
          <source>The sum of a numeric (INT variations, NUMERIC, DECIMAL) column</source>
          <target state="translated">숫자 (INT 변형, NUMERIC, DECIMAL) 열의 합</target>
        </trans-unit>
        <trans-unit id="6e30eda6efa57bb431bff13322b44e3679d1c785" translate="yes" xml:space="preserve">
          <source>The super user can disable logging for a connection by &lt;a href=&quot;../set-sql_log_bin/index&quot;&gt;setting SQL_LOG_BIN&lt;/a&gt; to 0. However while this is 0, no changes done in this connection will be replicated to the slaves!</source>
          <target state="translated">수퍼 유저는 &lt;a href=&quot;../set-sql_log_bin/index&quot;&gt;SQL_LOG_BIN&lt;/a&gt; 을 0 으로 설정 하여 연결에 대한 로깅을 비활성화 할 수 있습니다. 그러나이 값이 0 인 경우이 연결에서 수행 된 변경 사항은 슬레이브에 복제되지 않습니다!</target>
        </trans-unit>
        <trans-unit id="250bfb4fcecd38d0409c767338c950ad1fd20751" translate="yes" xml:space="preserve">
          <source>The super user can disable logging to it for a connection by setting &lt;a href=&quot;../server-system-variables/index#sql_log_off&quot;&gt;SQL_LOG_OFF&lt;/a&gt; to 1.</source>
          <target state="translated">수퍼 유저는 &lt;a href=&quot;../server-system-variables/index#sql_log_off&quot;&gt;SQL_LOG_OFF&lt;/a&gt; 를 1 로 설정하여 연결에 대한 로깅을 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2bb83c5ef83b246dc580ba2e80b39be64c11c7d9" translate="yes" xml:space="preserve">
          <source>The support for &lt;code&gt;replicate-...&lt;/code&gt; variables was added in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1002-release-notes/&quot;&gt;MariaDB 10.0.2&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;replicate-...&lt;/code&gt; 변수에 대한 지원 이 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1002-release-notes/&quot;&gt;MariaDB 10.0.2&lt;/a&gt; 에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="d8fa81aba455ecdf6f8519f791cbea656560a98c" translate="yes" xml:space="preserve">
          <source>The support for multiple keys opens up some potential use cases. For example, let's say that a hypothetical key management and encryption plugin is configured to provide two encryption keys. One encryption key might be intended for &quot;low security&quot; tables. It could use short keys, which might not be rotated, and data could be encrypted with a fast encryption algorithm. Another encryption key might be intended for &quot;high security&quot; tables. It could use long keys, which are rotated often, and data could be encrypted with a slower, but more secure encryption algorithm. The user would specify the identifier of the key that they want to use for different tables, only using high level security where it's needed.</source>
          <target state="translated">여러 키를 지원하면 잠재적 인 사용 사례가 열립니다. 예를 들어, 가상 키 관리 및 암호화 플러그인이 두 개의 암호화 키를 제공하도록 구성되었다고 가정 해 봅시다. 하나의 암호화 키는 &quot;보안 수준이 낮은&quot;테이블 용입니다. 회전하지 않을 수도있는 짧은 키를 사용할 수 있으며 빠른 암호화 알고리즘으로 데이터를 암호화 할 수 있습니다. &quot;높은 보안&quot;테이블을위한 다른 암호화 키가있을 수 있습니다. 자주 회전하는 긴 키를 사용할 수 있으며 느리지 만 안전한 암호화 알고리즘으로 데이터를 암호화 할 수 있습니다. 사용자는 필요한 경우 높은 수준의 보안 만 사용하여 다른 테이블에 사용하려는 키의 식별자를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="5d51c0a7b21ffe970c34df4ea8663537c18fb49b" translate="yes" xml:space="preserve">
          <source>The support is transparent. Normally, the connector only needs to be provided the correct user name, and no other parameters are required.</source>
          <target state="translated">지지는 투명하다. 일반적으로 커넥터에는 올바른 사용자 이름 만 제공하면되고 다른 매개 변수는 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c31478871a30906004a9662f70872dcdb49e7a44" translate="yes" xml:space="preserve">
          <source>The supported algorithms are described in more details below.</source>
          <target state="translated">지원되는 알고리즘은 아래에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="200b3d5de4cc7932e8665560e131d8b7f409cb02" translate="yes" xml:space="preserve">
          <source>The supported operations in this category support the non-locking strategy. This strategy can be explicitly chosen by setting the &lt;code&gt;&lt;a href=&quot;../alter-table/index#lock&quot;&gt;LOCK&lt;/a&gt;&lt;/code&gt; clause to &lt;code&gt;NONE&lt;/code&gt;. When this strategy is used, all concurrent DML is permitted.</source>
          <target state="translated">이 범주에서 지원되는 작업은 비 잠금 전략을 지원합니다. 이 전략은 &lt;code&gt;&lt;a href=&quot;../alter-table/index#lock&quot;&gt;LOCK&lt;/a&gt;&lt;/code&gt; 절을 &lt;code&gt;NONE&lt;/code&gt; 으로 설정하여 명시 적으로 선택할 수 있습니다 . 이 전략을 사용하면 모든 동시 DML이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="33906ced4e1ff645e6cffa46608b6c5178ecce44" translate="yes" xml:space="preserve">
          <source>The supported values for &lt;code&gt;--os-type&lt;/code&gt; are:</source>
          <target state="translated">&lt;code&gt;--os-type&lt;/code&gt; 에 지원되는 값 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a3983b79ad20cca22d164df0ec6dff2565a9e159" translate="yes" xml:space="preserve">
          <source>The supported values for &lt;code&gt;--os-version&lt;/code&gt; are entirely dependent on the OS type.</source>
          <target state="translated">&lt;code&gt;--os-version&lt;/code&gt; 에 지원되는 값 은 전적으로 OS 유형에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="d1a1ff241fbd562d61b16df1fe7d9f6db3ee9434" translate="yes" xml:space="preserve">
          <source>The switch to PCRE added a number of features, including recursive patterns, named capture, look-ahead and look-behind assertions, non-capturing groups, non-greedy quantifiers, Unicode character properties, extended syntax for characters and character classes, multi-line matching, and many other.</source>
          <target state="translated">PCRE 로의 전환에는 재귀 패턴, 명명 된 캡처, 미리보기 및 룩 어레이 어설 션, 비 캡처 그룹, 욕심없는 수량 자, 유니 코드 문자 속성, 문자 및 문자 클래스에 대한 확장 구문, 다중 라인 매칭 및 기타 여러 가지.</target>
        </trans-unit>
        <trans-unit id="3bb874a7eac54bf46e51898f7c94da9a774db3ec" translate="yes" xml:space="preserve">
          <source>The symbol &lt;code&gt;mysql_get_server_name()&lt;/code&gt; is something present in the MariaDB source tree and not in the MySQL tree.</source>
          <target state="translated">&lt;code&gt;mysql_get_server_name()&lt;/code&gt; 심볼 은 MySQL 트리가 아닌 MariaDB 소스 트리에 존재합니다.</target>
        </trans-unit>
        <trans-unit id="969bd5fdb1413397c3195c55df239444ac8cd0b2" translate="yes" xml:space="preserve">
          <source>The symbols-file should include the output from: &lt;code&gt;nm --numeric-sort mysqld&lt;/code&gt;. The numeric-dump-file should contain a numeric stack trace from mysqld. If the numeric-dump-file is not given, the stack trace is read from stdin.</source>
          <target state="translated">symbols-file은 &lt;code&gt;nm --numeric-sort mysqld&lt;/code&gt; 의 출력을 포함해야합니다 . 숫자 덤프 파일에는 mysqld의 숫자 스택 추적이 포함되어야합니다. 숫자 덤프 파일이 제공되지 않은 경우 스택 추적은 stdin에서 읽습니다.</target>
        </trans-unit>
        <trans-unit id="162344118ba6ddf7343703d6849ba219df90c26a" translate="yes" xml:space="preserve">
          <source>The symlinking with &lt;code&gt;ln -s&lt;/code&gt; is recommended as it makes it easy to install many MariaDB version at the same time (for easy testing, upgrading, downgrading etc).</source>
          <target state="translated">&lt;code&gt;ln -s&lt;/code&gt; 를 사용한 심볼릭 링크 는 많은 MariaDB 버전을 동시에 쉽게 설치 (테스트, 업그레이드, 다운 그레이드 등)하기 때문에 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="73dbd666681025e4cad38c2b15eac46e0284d818" translate="yes" xml:space="preserve">
          <source>The sync point performs a binary search in a sorted array of actions for this thread.</source>
          <target state="translated">동기 점은이 스레드에 대해 정렬 된 조치 배열로 2 진 검색을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="25cbbb80f41c2a382588011d7888d7fa5a4a3ad3" translate="yes" xml:space="preserve">
          <source>The syntax '%s' is deprecated and will be removed in MariaDB %s. Please use %s instead</source>
          <target state="translated">'% s'구문은 더 이상 사용되지 않으며 MariaDB % s에서 제거됩니다. 대신 % s를 사용하십시오</target>
        </trans-unit>
        <trans-unit id="ba51ac2e7d7c9e66e8d49263476885d67e267125" translate="yes" xml:space="preserve">
          <source>The syntax and meaning of the column input format is the one of the C &lt;strong&gt;scanf&lt;/strong&gt; function.</source>
          <target state="translated">열 입력 형식의 구문과 의미는 C &lt;strong&gt;scanf&lt;/strong&gt; 함수 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="ac5727b3099a1708473dbbf30405396c67abaf36" translate="yes" xml:space="preserve">
          <source>The syntax for LIST COLUMNS is the following:</source>
          <target state="translated">LIST COLUMNS의 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4a50a98f933a9a3c3a0d0799dc5e11aa514ac4ea" translate="yes" xml:space="preserve">
          <source>The syntax for the &lt;code&gt;&lt;a href=&quot;../analyze-table/index&quot;&gt;ANALYZE TABLE&lt;/a&gt;&lt;/code&gt; statement has been extended with the &lt;code&gt;PERSISTENT FOR&lt;/code&gt; clause. This clause allows one to collect engine-independent statistics only for particular columns or indexes. This clause also allows one to collect engine-independent statistics, regardless of the value of the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#use_stat_tables&quot;&gt;use_stat_tables&lt;/a&gt;&lt;/code&gt; system variable. For example:</source>
          <target state="translated">의 구문 &lt;code&gt;&lt;a href=&quot;../analyze-table/index&quot;&gt;ANALYZE TABLE&lt;/a&gt;&lt;/code&gt; 의 문은 함께 확장되었습니다 &lt;code&gt;PERSISTENT FOR&lt;/code&gt; 절. 이 절을 사용하면 특정 열이나 인덱스에 대해서만 엔진 독립적 통계를 수집 할 수 있습니다. 이 절은 또한 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#use_stat_tables&quot;&gt;use_stat_tables&lt;/a&gt;&lt;/code&gt; 시스템 변수 의 값에 관계없이 엔진 독립적 인 통계를 수집 할 수있게 합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1833b2ef5f0015fc6c4642e8464a2baed5347e9b" translate="yes" xml:space="preserve">
          <source>The syntax for the &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; feature was changed to &lt;code&gt;ANALYZE statement&lt;/code&gt;, available since &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1010-release-notes/&quot;&gt;MariaDB 10.1.0&lt;/a&gt;. See &lt;a href=&quot;../analyze-statement/index&quot;&gt;ANALYZE statement&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; 기능 의 구문이 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1010-release-notes/&quot;&gt;MariaDB 10.1.0&lt;/a&gt; 부터 사용 가능한 &lt;code&gt;ANALYZE statement&lt;/code&gt; 으로 변경되었습니다 . &lt;a href=&quot;../analyze-statement/index&quot;&gt;ANALYZE 문을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a8b90249e8865fef625ed7dc553ac826b317389f" translate="yes" xml:space="preserve">
          <source>The syntax for this is:</source>
          <target state="translated">이에 대한 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="89df7dc6bb4bb7bfb64ddff710508f03cebad89a" translate="yes" xml:space="preserve">
          <source>The syntax is</source>
          <target state="translated">문법은</target>
        </trans-unit>
        <trans-unit id="869d833f9b3336891a11a67fcd142e1caac2f566" translate="yes" xml:space="preserve">
          <source>The syntax is:</source>
          <target state="translated">구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6b8f005a1e649f2fde4fc0698d57391bcc37dff0" translate="yes" xml:space="preserve">
          <source>The syntax of &lt;code&gt;RESIGNAL&lt;/code&gt; and its semantics are very similar to &lt;a href=&quot;../signal/index&quot;&gt;SIGNAL&lt;/a&gt;. This statement can only be used within an error &lt;a href=&quot;../declare-handler/index&quot;&gt;HANDLER&lt;/a&gt;. It produces an error, like &lt;a href=&quot;../signal/index&quot;&gt;SIGNAL&lt;/a&gt;. &lt;code&gt;RESIGNAL&lt;/code&gt; clauses are the same as SIGNAL, except that they all are optional, even &lt;a href=&quot;../sqlstate/index&quot;&gt;SQLSTATE&lt;/a&gt;. All the properties which are not specified in &lt;code&gt;RESIGNAL&lt;/code&gt;, will be identical to the properties of the error that was received by the error &lt;a href=&quot;../handler/index&quot;&gt;HANDLER&lt;/a&gt;. For a description of the clauses, see &lt;a href=&quot;../diagnostics-area/index&quot;&gt;diagnostics area&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;RESIGNAL&lt;/code&gt; 과 그 의미 의 구문은 &lt;a href=&quot;../signal/index&quot;&gt;SIGNAL&lt;/a&gt; 과 매우 유사합니다 . 이 명령문은 오류 &lt;a href=&quot;../declare-handler/index&quot;&gt;HANDLER&lt;/a&gt; 내에서만 사용할 수 있습니다 . &lt;a href=&quot;../signal/index&quot;&gt;SIGNAL&lt;/a&gt; 과 같은 오류가 발생 합니다. &lt;code&gt;RESIGNAL&lt;/code&gt; 절은 SIGNAL과 동일하지만 모두 &lt;a href=&quot;../sqlstate/index&quot;&gt;SQLSTATE&lt;/a&gt; 조차 선택적 입니다. &lt;code&gt;RESIGNAL&lt;/code&gt; 에 지정되지 않은 모든 특성 은 오류 &lt;a href=&quot;../handler/index&quot;&gt;HANDLER&lt;/a&gt; 가 수신 한 오류의 특성과 동일합니다 . 절에 대한 설명은 &lt;a href=&quot;../diagnostics-area/index&quot;&gt;진단 영역을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="46322f3b141f5c48c10cc3f4f418b8b3c298e0e8" translate="yes" xml:space="preserve">
          <source>The syntax of &lt;code&gt;my.cnf&lt;/code&gt; template is the same of a normal &lt;code&gt;my.cnf&lt;/code&gt; file, with a few extensions and assumptions. They are:</source>
          <target state="translated">&lt;code&gt;my.cnf&lt;/code&gt; 템플릿 의 구문은 일반적인 &lt;code&gt;my.cnf&lt;/code&gt; 파일과 동일하며 몇 가지 확장명과 가정이 있습니다. 그들은:</target>
        </trans-unit>
        <trans-unit id="10cf0d435edb68a9ddd359753cf41bc14ff8d592" translate="yes" xml:space="preserve">
          <source>The syntax of &lt;code&gt;table_factor&lt;/code&gt; is extended in comparison with the SQL Standard. The latter accepts only &lt;code&gt;table_reference&lt;/code&gt;, not a list of them inside a pair of parentheses.</source>
          <target state="translated">&lt;code&gt;table_factor&lt;/code&gt; 의 구문은 SQL 표준과 비교하여 확장됩니다. 후자는 &lt;code&gt;table_reference&lt;/code&gt; 만 허용 하고 괄호 안에있는 목록은 허용 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fb79d21f43ef6df74b90a9813fefc18d27b9efb9" translate="yes" xml:space="preserve">
          <source>The syntax of the MariaDB option files are:</source>
          <target state="translated">MariaDB 옵션 파일의 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3477ff7bd1c773e1478dbd62a46833c8c4c85651" translate="yes" xml:space="preserve">
          <source>The syntax that includes the &lt;code&gt;UPGRADE DATA DIRECTORY NAME&lt;/code&gt; clause was added in MySQL 5.1.23. It updates the name of the directory associated with the database to use the encoding implemented in MySQL 5.1 for mapping database names to database directory names (see &lt;a href=&quot;../identifier-to-file-name-mapping/index&quot;&gt;Identifier to File Name Mapping&lt;/a&gt;). This clause is for use under these conditions:</source>
          <target state="translated">&lt;code&gt;UPGRADE DATA DIRECTORY NAME&lt;/code&gt; 절 을 포함하는 구문이 MySQL 5.1.23에 추가되었습니다. 데이터베이스 이름을 데이터베이스 디렉토리 이름에 맵핑하기 위해 MySQL 5.1에서 구현 된 인코딩을 사용하도록 데이터베이스와 연관된 디렉토리 이름을 업데이트합니다 ( &lt;a href=&quot;../identifier-to-file-name-mapping/index&quot;&gt;식별자에서 파일 이름 맵핑 참조&lt;/a&gt; ). 이 절은 다음 조건에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="60fa6c5722a7852ccf05e003183794c7e2b8956e" translate="yes" xml:space="preserve">
          <source>The syntax to send a command is rather strange and may seem unnatural. It is possible to use an easier syntax by defining a stored procedure such as:</source>
          <target state="translated">명령을 보내는 구문은 다소 이상하며 부 자연스럽게 보일 수 있습니다. 다음과 같은 저장 프로 시저를 정의하여 더 쉬운 구문을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce959414eb3195bad490cbe091be8ff7a3ff49fb" translate="yes" xml:space="preserve">
          <source>The system assigns the module id as they are added</source>
          <target state="translated">시스템은 모듈 ID를 추가 할 때 할당합니다</target>
        </trans-unit>
        <trans-unit id="4b23906a6e1ee29a37bc4f8569f3b909a8c74dce" translate="yes" xml:space="preserve">
          <source>The system can be upgrade when it was previously installed from the Package Repositories. This will need to be run on each module in the system</source>
          <target state="translated">패키지 리포지토리에서 이전에 시스템을 설치했을 때 시스템을 업그레이드 할 수 있습니다. 시스템의 각 모듈에서 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="e970c70f702bb87073fd0ae51222f3e789621d42" translate="yes" xml:space="preserve">
          <source>The system can be upgraded when it was previously installed from the Package Repositories. This will need to be run on each module in the system</source>
          <target state="translated">패키지 리포지토리에서 이전에 설치했을 때 시스템을 업그레이드 할 수 있습니다. 시스템의 각 모듈에서 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="b301f92999912eb76cd37803f6d830ab1b04975e" translate="yes" xml:space="preserve">
          <source>The system can be upgraded when it was previously installed from the Package Repositories. This will need to be run on each module in the system.</source>
          <target state="translated">패키지 리포지토리에서 이전에 설치했을 때 시스템을 업그레이드 할 수 있습니다. 시스템의 각 모듈에서 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="122f373b145db4fc54ee723c5701510888ebb572" translate="yes" xml:space="preserve">
          <source>The system logging configuration file referenced is a standard syslog configuration file and may be edited to enable and or disable specific levels, for example to disable debug logging and to only log at the specific level in each file:</source>
          <target state="translated">참조 된 시스템 로깅 구성 파일은 표준 syslog 구성 파일이며 특정 수준을 활성화 및 비활성화하도록 편집 할 수 있습니다 (예 : 디버그 로깅을 비활성화하고 각 파일의 특정 수준에서만 로깅).</target>
        </trans-unit>
        <trans-unit id="53be3be416015ce39133de432d295e42940e0c8e" translate="yes" xml:space="preserve">
          <source>The system or server is offline due to a fault.</source>
          <target state="translated">결함으로 인해 시스템 또는 서버가 오프라인 상태입니다.</target>
        </trans-unit>
        <trans-unit id="dfe06cb8894e715cfd000af9110b4023cb803219" translate="yes" xml:space="preserve">
          <source>The system or server was taken offline with the stop or shutdown command.</source>
          <target state="translated">stop 또는 shutdown 명령으로 시스템 또는 서버가 오프라인 상태가되었습니다.</target>
        </trans-unit>
        <trans-unit id="3b6158c3cb0107625e48ba36711ead37dc786a86" translate="yes" xml:space="preserve">
          <source>The system should start cleanly and the data should now be accessible in the database.</source>
          <target state="translated">시스템이 깨끗하게 시작되고 이제 데이터베이스에서 데이터에 액세스 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="0fdeff161da277db5f7fad6a00b487b99f9c2eab" translate="yes" xml:space="preserve">
          <source>The system status shows the status of the system and all equipped servers. To view the system status, use the &lt;em&gt;getSystemStatus&lt;/em&gt; command in &lt;a href=&quot;../mariadb-columnstore-administrative-console/index&quot;&gt;mcsadmin&lt;/a&gt;, or simply use &lt;a href=&quot;../mariadb-columnstore-administrative-console/index&quot;&gt;mcsadmin&lt;/a&gt;&lt;em&gt;getSystemStatus&lt;/em&gt; from the operating system prompt.</source>
          <target state="translated">시스템 상태는 시스템 및 모든 장착 된 서버의 상태를 보여줍니다. 시스템 상태를 보려면 &lt;a href=&quot;../mariadb-columnstore-administrative-console/index&quot;&gt;mcsadmin&lt;/a&gt; 에서 &lt;em&gt;getSystemStatus&lt;/em&gt; 명령을 사용하거나 운영 체제 프롬프트에서 &lt;a href=&quot;../mariadb-columnstore-administrative-console/index&quot;&gt;mcsadmin &lt;/a&gt;&lt;em&gt;getSystemStatus&lt;/em&gt; 를 사용하십시오.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="105bc56965670d20f5722e55a00b99fdbb746939" translate="yes" xml:space="preserve">
          <source>The system supports full MVCC ACID transactional logic via Insert, Update, and Delete statements. The MVCC architecture allows for concurrent query and DML / batch load. Although DML is supported, the system is optimized more for batch inserts and so larger data loads should be achieved through a batch load. The most flexible and optimal way to load data is via the cpimport tool. This tool optimizes the load path and can be run centrally or in parallel on each pm server.</source>
          <target state="translated">시스템은 Insert, Update 및 Delete 문을 통해 전체 MVCC ACID 트랜잭션 논리를 지원합니다. MVCC 아키텍처는 동시 쿼리 및 DML / 배치로드를 허용합니다. DML이 지원되지만 시스템은 배치 삽입에 더 최적화되어 있으므로 배치로드를 통해 더 큰 데이터로드를 달성해야합니다. 데이터를로드하는 가장 유연하고 최적의 방법은 cpimport 도구를 사용하는 것입니다. 이 도구는로드 경로를 최적화하며 각 오후 서버에서 중앙 또는 병렬로 실행될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f63857f682f938afdcf9242329bf7cf968918a35" translate="yes" xml:space="preserve">
          <source>The system tablespace, how to change its size, and the use of raw disk partitions.</source>
          <target state="translated">시스템 테이블 스페이스, 크기 변경 방법 및 원시 디스크 파티션 사용.</target>
        </trans-unit>
        <trans-unit id="c2b2d48c15939674d7c2436fe8c28b4c84be18cc" translate="yes" xml:space="preserve">
          <source>The system time zone is determined when the server starts, and it sets the value of the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#system_time_zone&quot;&gt;system_time_zone&lt;/a&gt;&lt;/code&gt; system variable. The system time zone is usually read from the operating system's environment. You can change the system time zone in several different ways, such as:</source>
          <target state="translated">시스템 시간대는 서버가 시작될 때 결정되며 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#system_time_zone&quot;&gt;system_time_zone&lt;/a&gt;&lt;/code&gt; 시스템 변수 의 값을 설정합니다 . 시스템 시간대는 일반적으로 운영 체제 환경에서 읽습니다. 다음과 같은 여러 가지 방법으로 시스템 시간대를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ca613587423f947272bf0cdefef09169523bb90" translate="yes" xml:space="preserve">
          <source>The system variable %.200s cannot be set in SET STATEMENT.</source>
          <target state="translated">SET STATEMENT에서 시스템 변수 % .200s을 (를) 설정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="cad02b00bf2a70dc3018aac5dc6d12aa8c86b731" translate="yes" xml:space="preserve">
          <source>The system variable %s cannot be set in stored functions or triggers.</source>
          <target state="translated">저장된 기능 또는 트리거에서 시스템 변수 % s을 (를) 설정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e9031bf7c82835f1bcc0ab7b4e311a001fd84eec" translate="yes" xml:space="preserve">
          <source>The system variable %s cannot be set in stored procedures.</source>
          <target state="translated">스토어드 프로 시저에서 시스템 변수 % s을 (를) 설정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f433ec27a801d142c2ed59f1ed2ba9c534c06a51" translate="yes" xml:space="preserve">
          <source>The system variable %s cannot be set when there is an ongoing transaction.</source>
          <target state="translated">트랜잭션이 진행 중이면 시스템 변수 % s을 (를) 설정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="425edfffb920bd1c09247e08064ac4aa17fb0bdd" translate="yes" xml:space="preserve">
          <source>The system variable @@SESSION.GTID_NEXT cannot be 'AUTOMATIC' when @@SESSION.GTID_NEXT_LIST is non-NULL.</source>
          <target state="translated">@@ SESSION.GTID_NEXT_LIST가 NULL이 아닌 경우 시스템 변수 @@ SESSION.GTID_NEXT는 'AUTOMATIC'일 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ea867d3009312486f7d73473a41ea33735697455" translate="yes" xml:space="preserve">
          <source>The system variable @@SESSION.GTID_NEXT cannot change inside a transaction.</source>
          <target state="translated">시스템 변수 @@ SESSION.GTID_NEXT는 트랜잭션 내에서 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9034ca3e7d1f616be8f3b40d0fe6903c9d47ad13" translate="yes" xml:space="preserve">
          <source>The system variable @@SESSION.GTID_NEXT has the value %s, which is not listed in @@SESSION.GTID_NEXT_LIST.</source>
          <target state="translated">시스템 변수 @@ SESSION.GTID_NEXT의 값은 % s이며 @@ SESSION.GTID_NEXT_LIST에 나열되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="68effa8a718a1293087baa01f40534d516fbcd0a" translate="yes" xml:space="preserve">
          <source>The system variable does filter databases, tables, &lt;a href=&quot;../views/index&quot;&gt;views&lt;/a&gt; and &lt;a href=&quot;../triggers/index&quot;&gt;triggers&lt;/a&gt;.</source>
          <target state="translated">시스템 변수는 데이터베이스, 테이블, &lt;a href=&quot;../views/index&quot;&gt;뷰&lt;/a&gt; 및 &lt;a href=&quot;../triggers/index&quot;&gt;트리거를&lt;/a&gt; 필터링 합니다 .</target>
        </trans-unit>
        <trans-unit id="f398c12ef546a8896ef11278663dfc19ffbba82b" translate="yes" xml:space="preserve">
          <source>The system variable does not filter &lt;a href=&quot;../stored-procedures/index&quot;&gt;stored procedures&lt;/a&gt;, &lt;a href=&quot;../stored-functions/index&quot;&gt;stored functions&lt;/a&gt;, and &lt;a href=&quot;../stored-programs-and-views-events/index&quot;&gt;events&lt;/a&gt;. The &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#replicate_do_db&quot;&gt;replicate_do_db&lt;/a&gt;&lt;/code&gt; system variable will need to be used to filter those.</source>
          <target state="translated">시스템 변수는 &lt;a href=&quot;../stored-procedures/index&quot;&gt;저장 프로 시저&lt;/a&gt; , &lt;a href=&quot;../stored-functions/index&quot;&gt;저장 함수&lt;/a&gt; 및 &lt;a href=&quot;../stored-programs-and-views-events/index&quot;&gt;이벤트를&lt;/a&gt; 필터링하지 않습니다 . &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#replicate_do_db&quot;&gt;replicate_do_db&lt;/a&gt;&lt;/code&gt; 의 시스템 변수들을 필터링하는 데 사용되어야합니다.</target>
        </trans-unit>
        <trans-unit id="d3d074d9bf5fdfb242b157e4f705b577beb54230" translate="yes" xml:space="preserve">
          <source>The system variable does not filter &lt;a href=&quot;../stored-procedures/index&quot;&gt;stored procedures&lt;/a&gt;, &lt;a href=&quot;../stored-functions/index&quot;&gt;stored functions&lt;/a&gt;, and &lt;a href=&quot;../stored-programs-and-views-events/index&quot;&gt;events&lt;/a&gt;. The &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#replicate_ignore_db&quot;&gt;replicate_ignore_db&lt;/a&gt;&lt;/code&gt; system variable will need to be used to filter those.</source>
          <target state="translated">시스템 변수는 &lt;a href=&quot;../stored-procedures/index&quot;&gt;저장 프로 시저&lt;/a&gt; , &lt;a href=&quot;../stored-functions/index&quot;&gt;저장 함수&lt;/a&gt; 및 &lt;a href=&quot;../stored-programs-and-views-events/index&quot;&gt;이벤트를&lt;/a&gt; 필터링하지 않습니다 . &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#replicate_ignore_db&quot;&gt;replicate_ignore_db&lt;/a&gt;&lt;/code&gt; 의 시스템 변수들을 필터링하는 데 사용되어야합니다.</target>
        </trans-unit>
        <trans-unit id="c75323b45c27c1c60426a4baa2fa5f4653accade" translate="yes" xml:space="preserve">
          <source>The system variables listed on this page relate to encrypting data during transfer between servers and clients using the Transport Layer Security (TLS) protocol. Often, the term Secure Sockets Layer (SSL) is used interchangeably with TLS, although strictly speaking the SSL protocol is the predecessor of TLS and is no longer considered secure.</source>
          <target state="translated">이 페이지에 나열된 시스템 변수는 TLS (Transport Layer Security) 프로토콜을 사용하여 서버와 클라이언트간에 전송하는 동안 데이터를 암호화하는 것과 관련이 있습니다. SSL (Secure Sockets Layer)이라는 용어는 TLS와 상호 교환 적으로 사용되지만 SSL 프로토콜을 엄격하게 말하면 TLS의 전신이며 더 이상 안전한 것으로 간주되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c09367ed0aff33c1473a819bbc3431ebb03f1fb9" translate="yes" xml:space="preserve">
          <source>The system variables related to the &lt;code&gt;&lt;a href=&quot;../authentication-plugin-gssapi/index&quot;&gt;gssapi&lt;/a&gt;&lt;/code&gt; authentication plugin can be found &lt;a href=&quot;../authentication-plugin-gssapi/index#system-variables&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../authentication-plugin-gssapi/index&quot;&gt;gssapi&lt;/a&gt;&lt;/code&gt; 인증 플러그인 과 관련된 시스템 변수 는 &lt;a href=&quot;../authentication-plugin-gssapi/index#system-variables&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="241897c4c55be7cd80605c6d4f5a1319c979eb28" translate="yes" xml:space="preserve">
          <source>The system variables related to the &lt;code&gt;&lt;a href=&quot;../authentication-plugin-pam/index&quot;&gt;pam&lt;/a&gt;&lt;/code&gt; authentication plugin can be found &lt;a href=&quot;../authentication-plugin-pam/index#system-variables&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../authentication-plugin-pam/index&quot;&gt;pam&lt;/a&gt;&lt;/code&gt; 인증 플러그인 과 관련된 시스템 변수 는 &lt;a href=&quot;../authentication-plugin-pam/index#system-variables&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="388e35ece2e326a1fbc03b86a3ae444fc052c800" translate="yes" xml:space="preserve">
          <source>The system variables related to the &lt;code&gt;&lt;a href=&quot;../aws-key-management-encryption-plugin/index&quot;&gt;aws_key_management&lt;/a&gt;&lt;/code&gt; encryption plugin can be found &lt;a href=&quot;../aws-key-management-encryption-plugin/index#system-variables&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../aws-key-management-encryption-plugin/index&quot;&gt;aws_key_management&lt;/a&gt;&lt;/code&gt; 암호화 플러그인 과 관련된 시스템 변수 는 &lt;a href=&quot;../aws-key-management-encryption-plugin/index#system-variables&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="97ac0b451fc0af1cd13911674bcd1c706bb85f25" translate="yes" xml:space="preserve">
          <source>The system variables related to the &lt;code&gt;&lt;a href=&quot;../cracklib_password_check/index&quot;&gt;cracklib_password_check&lt;/a&gt;&lt;/code&gt; password validation plugin can be found &lt;a href=&quot;../cracklib_password_check/index#system-variables&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../cracklib_password_check/index&quot;&gt;cracklib_password_check&lt;/a&gt;&lt;/code&gt; 비밀번호 유효성 검사 플러그인 과 관련된 시스템 변수 는 &lt;a href=&quot;../cracklib_password_check/index#system-variables&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9e6a10c081998f01168ac320d14ae5a155bc0a57" translate="yes" xml:space="preserve">
          <source>The system variables related to the &lt;code&gt;&lt;a href=&quot;../feedback-plugin/index&quot;&gt;feedback&lt;/a&gt;&lt;/code&gt; plugin can be found &lt;a href=&quot;../feedback-plugin/index#system-variables&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../feedback-plugin/index&quot;&gt;feedback&lt;/a&gt;&lt;/code&gt; 플러그인 과 관련된 시스템 변수 는 &lt;a href=&quot;../feedback-plugin/index#system-variables&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d1f4cfd4baf13f7e650448de8272c9d0d0e93d13" translate="yes" xml:space="preserve">
          <source>The system variables related to the &lt;code&gt;&lt;a href=&quot;../file-key-management-encryption-plugin/index&quot;&gt;file_key_management&lt;/a&gt;&lt;/code&gt; encryption plugin can be found &lt;a href=&quot;../file-key-management-encryption-plugin/index#system-variables&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../file-key-management-encryption-plugin/index&quot;&gt;file_key_management&lt;/a&gt;&lt;/code&gt; 암호화 플러그인 과 관련된 시스템 변수 는 &lt;a href=&quot;../file-key-management-encryption-plugin/index#system-variables&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a49a7b88c1751aa41f9ab9a5aec2f7b224e91b44" translate="yes" xml:space="preserve">
          <source>The system variables related to the &lt;code&gt;&lt;a href=&quot;../query-response-time-plugin/index&quot;&gt;QUERY_RESPONSE_TIME&lt;/a&gt;&lt;/code&gt; information schema plugin can be found &lt;a href=&quot;../query-response-time-plugin/index#system-variables&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../query-response-time-plugin/index&quot;&gt;QUERY_RESPONSE_TIME&lt;/a&gt;&lt;/code&gt; 정보 스키마 플러그인 과 관련된 시스템 변수 는 &lt;a href=&quot;../query-response-time-plugin/index#system-variables&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7ed7ab779754e4b5520faa222aa4b1725fb1d67b" translate="yes" xml:space="preserve">
          <source>The system variables related to the &lt;code&gt;&lt;a href=&quot;../semisynchronous-replication/index&quot;&gt;rpl_semi_sync_master&lt;/a&gt;&lt;/code&gt; replication plugin can be found &lt;a href=&quot;../semisynchronous-replication/index#system-variables&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../semisynchronous-replication/index&quot;&gt;rpl_semi_sync_master&lt;/a&gt;&lt;/code&gt; 복제 플러그인 과 관련된 시스템 변수 는 &lt;a href=&quot;../semisynchronous-replication/index#system-variables&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b72cb2cb62dccfe07374efab9f4dd7fd342cdf7c" translate="yes" xml:space="preserve">
          <source>The system variables related to the &lt;code&gt;&lt;a href=&quot;../semisynchronous-replication/index&quot;&gt;rpl_semi_sync_slave&lt;/a&gt;&lt;/code&gt; replication plugin can be found &lt;a href=&quot;../semisynchronous-replication/index#system-variables&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../semisynchronous-replication/index&quot;&gt;rpl_semi_sync_slave&lt;/a&gt;&lt;/code&gt; 복제 플러그인 과 관련된 시스템 변수 는 &lt;a href=&quot;../semisynchronous-replication/index#system-variables&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e3b972413d7fb8664669831c48ebbfac89a9c3d9" translate="yes" xml:space="preserve">
          <source>The system variables related to the &lt;code&gt;&lt;a href=&quot;../simple_password_check/index&quot;&gt;simple_password_check&lt;/a&gt;&lt;/code&gt; password validation plugin can be found &lt;a href=&quot;../simple_password_check/index#system-variables&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../simple_password_check/index&quot;&gt;simple_password_check&lt;/a&gt;&lt;/code&gt; 비밀번호 유효성 검증 플러그인 과 관련된 시스템 변수 는 &lt;a href=&quot;../simple_password_check/index#system-variables&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9aabed87d6a365bf2c2e65073a4a93501fe56a1d" translate="yes" xml:space="preserve">
          <source>The system variables related to the &lt;code&gt;&lt;a href=&quot;../sql-error-log-plugin/index&quot;&gt;SQL_ERROR_LOG&lt;/a&gt;&lt;/code&gt; audit plugin can be found &lt;a href=&quot;../sql-error-log-plugin/index#system-variables&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../sql-error-log-plugin/index&quot;&gt;SQL_ERROR_LOG&lt;/a&gt;&lt;/code&gt; 감사 플러그인 과 관련된 시스템 변수 는 &lt;a href=&quot;../sql-error-log-plugin/index#system-variables&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a46b5c5c6f2da942d8265113096043c26bbd2045" translate="yes" xml:space="preserve">
          <source>The system, server, or Network Interface Card (NIC) is available to process database requests</source>
          <target state="translated">시스템, 서버 또는 NIC (Network Interface Card)를 사용하여 데이터베이스 요청을 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="fc910c4edd72341fec740b8554df268784ad7672" translate="yes" xml:space="preserve">
          <source>The systemd journal may also contain useful information about startup failures. See &lt;a href=&quot;../systemd/index#systemd-journal&quot;&gt;Systemd: Systemd Journal&lt;/a&gt; for more information.</source>
          <target state="translated">시스템 저널에는 시작 실패에 대한 유용한 정보가 포함될 수도 있습니다. 자세한 내용은 &lt;a href=&quot;../systemd/index#systemd-journal&quot;&gt;Systemd : Systemd Journal&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="788c88d362293043bf03bcf6af2f97c1ef7bb5a2" translate="yes" xml:space="preserve">
          <source>The t1 table in all schemas for all DSN</source>
          <target state="translated">모든 DSN에 대한 모든 스키마의 t1 테이블</target>
        </trans-unit>
        <trans-unit id="57ff025e814c46e36f3d5d51eafe5ec9e0790b99" translate="yes" xml:space="preserve">
          <source>The t1 table in the default or all schema depending on the DSN</source>
          <target state="translated">DSN에 따라 기본 또는 모든 스키마의 t1 테이블</target>
        </trans-unit>
        <trans-unit id="a67ae274234b5083a4f8ee9f891cb73bf7cb5bbf" translate="yes" xml:space="preserve">
          <source>The t1 table of the mydb schema</source>
          <target state="translated">mydb 스키마의 t1 테이블</target>
        </trans-unit>
        <trans-unit id="a87c3bd147ab4ce82de0b69a377ed41f7d85fd09" translate="yes" xml:space="preserve">
          <source>The t1 table of the test schema (test has precedence)</source>
          <target state="translated">테스트 스키마의 t1 테이블 (테스트가 우선 함)</target>
        </trans-unit>
        <trans-unit id="2e14f4251f233bde1f2623900db316edc7ae4429" translate="yes" xml:space="preserve">
          <source>The t1 table of the test schema.</source>
          <target state="translated">테스트 스키마의 t1 테이블</target>
        </trans-unit>
        <trans-unit id="f6e320ed99ac5a4154a82ed7e2a0063e4f131eef" translate="yes" xml:space="preserve">
          <source>The table '%s' is full</source>
          <target state="translated">테이블 '% s'이 (가) 가득 찼습니다</target>
        </trans-unit>
        <trans-unit id="974034aced6f34342ca8be282db5a5a7a12befb5" translate="yes" xml:space="preserve">
          <source>The table &lt;code&gt;jexpw&lt;/code&gt; shows what was bought and the sum and average of amounts for each person and week:</source>
          <target state="translated">&lt;code&gt;jexpw&lt;/code&gt; 테이블 은 구매 한 품목 과 각 사람과 주당 총액 및 평균 금액을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="e6478f6e33eddc900253f5fa0bb9fd113519985e" translate="yes" xml:space="preserve">
          <source>The table &lt;code&gt;mysql.gtid_slave_pos&lt;/code&gt; contains the following fields</source>
          <target state="translated">&lt;code&gt;mysql.gtid_slave_pos&lt;/code&gt; 테이블 에는 다음 필드가 포함되어 있습니다</target>
        </trans-unit>
        <trans-unit id="716855bd16733824a8d35cf782360f138b6ddb6d" translate="yes" xml:space="preserve">
          <source>The table below shows the available system and server statuses.</source>
          <target state="translated">아래 표는 사용 가능한 시스템 및 서버 상태를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="6c117aa76c466d00a560a5ebb4450b078c8a6cc6" translate="yes" xml:space="preserve">
          <source>The table below shows the supported process states.</source>
          <target state="translated">아래 표는 지원되는 프로세스 상태를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="126ae5e517ee5b1509df3aa874563f23d1ce5726" translate="yes" xml:space="preserve">
          <source>The table can be modified directly, or the server started with the option enabled, for example:</source>
          <target state="translated">테이블을 직접 수정하거나 서버를 다음과 같이 옵션을 활성화하여 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a57f4d0d207c15fd0190ad39e69dd58e0919371" translate="yes" xml:space="preserve">
          <source>The table contains the following columns:</source>
          <target state="translated">테이블에는 다음과 같은 열이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3238c1b2d4e8019981125292a0222e5d42f2062" translate="yes" xml:space="preserve">
          <source>The table contains the following fields:</source>
          <target state="translated">테이블에는 다음 필드가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a46e0eb154ddfffac939b7398f6cffc061a6c76" translate="yes" xml:space="preserve">
          <source>The table copy operation creates a lot of &lt;a href=&quot;../innodb-redo-log/index&quot;&gt;InnoDB redo log&lt;/a&gt; writes.</source>
          <target state="translated">테이블 복사 작업은 많은 &lt;a href=&quot;../innodb-redo-log/index&quot;&gt;InnoDB 리두 로그&lt;/a&gt; 쓰기를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="e02d8231f587ca8c6ff5e7e1a89438b770bbf51e" translate="yes" xml:space="preserve">
          <source>The table could be created by:</source>
          <target state="translated">테이블은 다음과 같이 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="449776f83407b56430bf0956670d11e79cc707f4" translate="yes" xml:space="preserve">
          <source>The table definition should be created in the test database on both backend1 and backend2 servers:</source>
          <target state="translated">백엔드 1 및 백엔드 2 서버 모두에서 테스트 데이터베이스에 테이블 정의를 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="2d61515bcfc94116d490567d6e86c4021bb4086f" translate="yes" xml:space="preserve">
          <source>The table does not have FULLTEXT index to support this query</source>
          <target state="translated">이 쿼리를 지원하기 위해 테이블에 FULLTEXT 인덱스가 없습니다.</target>
        </trans-unit>
        <trans-unit id="19825c099b71bf54fcc33bd793b9fa9d0f21b906" translate="yes" xml:space="preserve">
          <source>The table file names are generated differently depending on whether the table is an inward or outward table. For inward tables, for which the file name is not specified, the partition file names are:</source>
          <target state="translated">테이블 파일 이름은 테이블이 내부 테이블인지 외부 테이블인지에 따라 다르게 생성됩니다. 파일 이름이 지정되지 않은 내부 테이블의 경우 파티션 파일 이름은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="db0f40be4e2c86ee3f74fa512a5a901a90b687a1" translate="yes" xml:space="preserve">
          <source>The table files can be found in &lt;a href=&quot;../server-system-variables/index#datadir&quot;&gt;datadir&lt;/a&gt;/databasename (you can execute &lt;code&gt;SELECT @@datadir&lt;/code&gt; to find the correct directory). When copying the files, you should copy all files with the same table_name + various extensions. For example, for an Aria table of name foo, you will have files foo.frm, foo.MAI, foo.MAD and possibly foo.TRG if you have &lt;a href=&quot;../triggers/index&quot;&gt;triggers&lt;/a&gt;.</source>
          <target state="translated">테이블 파일은 &lt;a href=&quot;../server-system-variables/index#datadir&quot;&gt;datadir&lt;/a&gt; / databasename에 있습니다 ( &lt;code&gt;SELECT @@datadir&lt;/code&gt; 을 실행 하여 올바른 디렉토리를 찾을 수 있음). 파일을 복사 할 때 동일한 table_name + 다양한 확장자를 가진 모든 파일을 복사해야합니다. 예를 들어 이름이 foo 인 Aria 테이블의 경우 &lt;a href=&quot;../triggers/index&quot;&gt;트리거&lt;/a&gt; 가있는 경우 foo.frm, foo.MAI, foo.MAD 및 foo.TRG 파일이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="014c529274e796b244e0145519544707b7752edd" translate="yes" xml:space="preserve">
          <source>The table handler does not remember the last used &lt;code&gt;&lt;a href=&quot;../auto_increment/index&quot;&gt;AUTO_INCREMENT&lt;/a&gt;&lt;/code&gt; value, but starts counting from the beginning. This is true even for MyISAM and InnoDB, which normally do not reuse sequence values.</source>
          <target state="translated">테이블 핸들러는 마지막으로 사용한 &lt;code&gt;&lt;a href=&quot;../auto_increment/index&quot;&gt;AUTO_INCREMENT&lt;/a&gt;&lt;/code&gt; 값을 기억하지 않지만 처음부터 계산을 시작합니다. 일반적으로 시퀀스 값을 재사용하지 않는 MyISAM 및 InnoDB의 경우에도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="35e1477ca8a943993b2839ba8d8866b526fb2b6e" translate="yes" xml:space="preserve">
          <source>The table has 0 or 1 rows.</source>
          <target state="translated">테이블에 0 개 또는 1 개의 행이 있습니다.</target>
        </trans-unit>
        <trans-unit id="716f7044ee48fd48209c662debeb125af3b6e390" translate="yes" xml:space="preserve">
          <source>The table has been created as:</source>
          <target state="translated">테이블은 다음과 같이 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="8ffe993edcb38cc64c70819a07acd67176806951" translate="yes" xml:space="preserve">
          <source>The table has many columns that can be stored in overflow pages, such as columns that use the &lt;code&gt;&lt;a href=&quot;../varbinary/index&quot;&gt;VARBINARY&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../varchar/index&quot;&gt;VARCHAR&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../blob/index&quot;&gt;BLOB&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../text/index&quot;&gt;TEXT&lt;/a&gt;&lt;/code&gt; data types.</source>
          <target state="translated">테이블에는 &lt;code&gt;&lt;a href=&quot;../varbinary/index&quot;&gt;VARBINARY&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../varchar/index&quot;&gt;VARCHAR&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../blob/index&quot;&gt;BLOB&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../text/index&quot;&gt;TEXT&lt;/a&gt;&lt;/code&gt; 데이터 유형 을 사용하는 열과 같이 오버 플로우 페이지에 저장할 수있는 많은 열이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c6773a0fe7e0ace460b360c0387da06acc9fb087" translate="yes" xml:space="preserve">
          <source>The table is a MariaDB and MySQL extension, and does not include information about InnoDB tablespaces.</source>
          <target state="translated">이 테이블은 MariaDB 및 MySQL 확장이며 InnoDB 테이블 스페이스에 대한 정보는 포함하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="01fc878b7b81a185d95f1af493f6aa96859a9946" translate="yes" xml:space="preserve">
          <source>The table is a part of the sub query and if the value that is used to match the sub query will be &lt;code&gt;NULL&lt;/code&gt;, we will do a full table scan.</source>
          <target state="translated">테이블은 하위 쿼리의 일부이며 하위 쿼리와 일치하는 데 사용되는 값이 &lt;code&gt;NULL&lt;/code&gt; 인 경우 전체 테이블 스캔을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="f98e11cae2f4093ebad7ec71cce91c4232edba1a" translate="yes" xml:space="preserve">
          <source>The table is contained in one or several files. The file format can be refined by some other options of the command or more often using a specific type as many of those described below. Otherwise, it is a flat text file where columns are placed at a fixed offset within each record, the last column being of variable length.</source>
          <target state="translated">테이블은 하나 이상의 파일에 포함되어 있습니다. 파일 형식은 다른 명령 옵션에 의해 다듬어 지거나 아래에 설명 된 것과 같이 특정 유형을 사용하는 경우가 많습니다. 그렇지 않으면, 열이 각 레코드 내에서 고정 오프셋에 배치되고 마지막 열은 가변 길이 인 플랫 텍스트 파일입니다.</target>
        </trans-unit>
        <trans-unit id="b5f34ee1fc8381d230434645c9773cb630a6c146" translate="yes" xml:space="preserve">
          <source>The table is dropped first (if it existed), after that the &lt;code&gt;CREATE&lt;/code&gt; is done. Because of this, if the &lt;code&gt;CREATE&lt;/code&gt; fails, then the table will not exist anymore after the statement. If the table was used with &lt;code&gt;LOCK TABLES&lt;/code&gt; it will be unlocked.</source>
          <target state="translated">&lt;code&gt;CREATE&lt;/code&gt; 가 완료된 후 테이블이 먼저 삭제됩니다 (존재하는 경우) . 이 때문에 &lt;code&gt;CREATE&lt;/code&gt; 에 실패하면 명령문 다음에 테이블이 더 이상 존재하지 않습니다. 테이블이 &lt;code&gt;LOCK TABLES&lt;/code&gt; 와 함께 사용 된 경우 잠금이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="a66475972dbbe88b441c3ffede82e86bf39fca6e" translate="yes" xml:space="preserve">
          <source>The table is initialized to one row: (UNHEX('00000000000000000000000000000000'), 0), meaning &quot;all addresses are free.</source>
          <target state="translated">테이블은 한 행으로 초기화됩니다 : (UNHEX ( '00000000000000000000000000000000'), 0), &quot;모든 주소는 무료입니다.</target>
        </trans-unit>
        <trans-unit id="d42841af3cee156a8248b7a005680863669ba96b" translate="yes" xml:space="preserve">
          <source>The table is initialized to one row: (ip=0, owner=0), meaning &quot;all addresses are free See the comments in the code for more details.</source>
          <target state="translated">테이블은 한 행으로 초기화됩니다 (ip = 0, owner = 0). &quot;모든 주소는 무료입니다. 자세한 내용은 코드의 주석을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4345c724f1ff086f9b4cb3d0d6b37cad50847b94" translate="yes" xml:space="preserve">
          <source>The table is made from files located in the same directory, and all its sub-directories (sub-foders). The FILE_NAME option is a pattern such as &lt;code&gt;'cash*.log'&lt;/code&gt; that all the table file path/names verify.</source>
          <target state="translated">이 테이블은 동일한 디렉토리에있는 파일과 모든 하위 디렉토리 (하위 폴더)로 구성됩니다. FILE_NAME 옵션은 모든 테이블 파일 경로 / 이름이 확인하는 &lt;code&gt;'cash*.log'&lt;/code&gt; 와 같은 패턴 입니다.</target>
        </trans-unit>
        <trans-unit id="3565fb04ca97c57f1ee802123cf5f9ae0cbdf856" translate="yes" xml:space="preserve">
          <source>The table is made from files located in the same directory. The FILE_NAME option is a pattern such as &lt;code&gt;'cash*.log'&lt;/code&gt; that all the table file path/names verify.</source>
          <target state="translated">테이블은 동일한 디렉토리에있는 파일로 작성됩니다. FILE_NAME 옵션은 모든 테이블 파일 경로 / 이름이 확인하는 &lt;code&gt;'cash*.log'&lt;/code&gt; 와 같은 패턴 입니다.</target>
        </trans-unit>
        <trans-unit id="f2b09dbf623b93fdfc150019e405629107c29522" translate="yes" xml:space="preserve">
          <source>The table is not a standard Information Schema table, and is a MariaDB extension.</source>
          <target state="translated">이 테이블은 표준 정보 스키마 테이블이 아니며 MariaDB 확장입니다.</target>
        </trans-unit>
        <trans-unit id="1b3228bc384b05c714ef8f2d5703984db5bc14d6" translate="yes" xml:space="preserve">
          <source>The table is not a standard Information Schema table, and is a MySQL and MariaDB extension.</source>
          <target state="translated">이 테이블은 표준 정보 스키마 테이블이 아니며 MySQL 및 MariaDB 확장입니다.</target>
        </trans-unit>
        <trans-unit id="c711743f027315386c2be28927a4cdc02d90843b" translate="yes" xml:space="preserve">
          <source>The table is often used in conjunction with the &lt;a href=&quot;../information-schema-innodb_lock_waits-table/index&quot;&gt;INNODB_LOCK_WAITS&lt;/a&gt; and &lt;a href=&quot;../information-schema-innodb_trx-table/index&quot;&gt;INNODB_TRX&lt;/a&gt; tables to diagnose problematic locks and transactions.</source>
          <target state="translated">이 테이블은 종종 &lt;a href=&quot;../information-schema-innodb_lock_waits-table/index&quot;&gt;INNODB_LOCK_WAITS&lt;/a&gt; 및 &lt;a href=&quot;../information-schema-innodb_trx-table/index&quot;&gt;INNODB_TRX&lt;/a&gt; 테이블 과 함께 사용되어 문제가있는 잠금 및 트랜잭션을 진단합니다.</target>
        </trans-unit>
        <trans-unit id="bfd4956375eff99f5f0adb52867a22b0b09fcdf7" translate="yes" xml:space="preserve">
          <source>The table is often used in conjunction with the &lt;a href=&quot;../information-schema-innodb_locks-table/index&quot;&gt;INNODB_LOCKS&lt;/a&gt; and &lt;a href=&quot;../information-schema-innodb_lock_waits-table/index&quot;&gt;INNODB_LOCK_WAITS&lt;/a&gt; tables to diagnose problematic locks and transactions.</source>
          <target state="translated">이 테이블은 종종 &lt;a href=&quot;../information-schema-innodb_locks-table/index&quot;&gt;INNODB_LOCKS&lt;/a&gt; 및 &lt;a href=&quot;../information-schema-innodb_lock_waits-table/index&quot;&gt;INNODB_LOCK_WAITS&lt;/a&gt; 테이블 과 함께 사용되어 문제가있는 잠금 및 트랜잭션을 진단합니다.</target>
        </trans-unit>
        <trans-unit id="7b8c26a24085f3a2f6e75de05f8f2bb14832b937" translate="yes" xml:space="preserve">
          <source>The table is often used in conjunction with the &lt;a href=&quot;../information-schema-innodb_locks-table/index&quot;&gt;INNODB_LOCKS&lt;/a&gt; and &lt;a href=&quot;../information-schema-innodb_trx-table/index&quot;&gt;INNODB_TRX&lt;/a&gt; tables to diagnose problematic locks and transactions.</source>
          <target state="translated">이 테이블은 종종 &lt;a href=&quot;../information-schema-innodb_locks-table/index&quot;&gt;INNODB_LOCKS&lt;/a&gt; 및 &lt;a href=&quot;../information-schema-innodb_trx-table/index&quot;&gt;INNODB_TRX&lt;/a&gt; 테이블 과 함께 사용되어 문제가있는 잠금 및 트랜잭션을 진단합니다.</target>
        </trans-unit>
        <trans-unit id="f1776f091f64ecd64cd8def8d3e0944fc69979b8" translate="yes" xml:space="preserve">
          <source>The table is read locked until one has issued &lt;code&gt;&lt;a href=&quot;../lock-tables-and-unlock-tables/index&quot;&gt;UNLOCK TABLES&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../lock-tables-and-unlock-tables/index&quot;&gt;UNLOCK TABLES&lt;/a&gt;&lt;/code&gt; 를 발행 할 때까지 테이블을 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="2e2e583d18b473906a8a8ff88532c70174396c5a" translate="yes" xml:space="preserve">
          <source>The table is rebuilt, which means that all of the data is reorganized substantially, and the indexes are rebuilt. As a result, the operation is quite expensive.</source>
          <target state="translated">테이블이 다시 작성되므로 모든 데이터가 실질적으로 재구성되고 인덱스가 다시 작성됩니다. 결과적으로 작업이 매우 비쌉니다.</target>
        </trans-unit>
        <trans-unit id="e5a6f457b4db06f90d092c6e35321c2add61828f" translate="yes" xml:space="preserve">
          <source>The table is repeatedly populated and truncated</source>
          <target state="translated">테이블이 반복적으로 채워지고 잘립니다.</target>
        </trans-unit>
        <trans-unit id="5026740229e2dca97cab582f7e7b24632646033e" translate="yes" xml:space="preserve">
          <source>The table is sorted according to the &lt;a href=&quot;../group-by/index&quot;&gt;GROUP BY&lt;/a&gt; expression.</source>
          <target state="translated">테이블은 &lt;a href=&quot;../group-by/index&quot;&gt;GROUP BY&lt;/a&gt; 표현식 에 따라 정렬됩니다 .</target>
        </trans-unit>
        <trans-unit id="ca8a1dc0721b38a6667074d094fe20d0c310072c" translate="yes" xml:space="preserve">
          <source>The table is updated with the new position as part of each transaction committed during replication. This makes it preferable that the table is using the same storage engine as the tables otherwise being modified in the transaction, since otherwise a multi-engine transaction is needed that can reduce performance.</source>
          <target state="translated">복제 중에 커밋 된 각 트랜잭션의 일부로 테이블이 새 위치로 업데이트됩니다. 이는 테이블이 트랜잭션에서 달리 수정되는 테이블과 동일한 스토리지 엔진을 사용하는 것이 바람직합니다. 그렇지 않으면 성능을 저하시킬 수있는 다중 엔진 트랜잭션이 필요하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="537381db9dd6539e2b07a6e90bb4b5c8103157ac" translate="yes" xml:space="preserve">
          <source>The table lists stage events, summarized by account and event name.</source>
          <target state="translated">이 테이블에는 계정 및 이벤트 이름으로 요약 된 단계 이벤트가 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8217c0086c3afdf84755f364f49dd8f9b046eb40" translate="yes" xml:space="preserve">
          <source>The table lists stage events, summarized by host and event name.</source>
          <target state="translated">이 표에는 호스트 및 이벤트 이름으로 요약 된 스테이지 이벤트가 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="34c94908bedf63868b1a7b2808b15b3ff19383ec" translate="yes" xml:space="preserve">
          <source>The table lists stage events, summarized by thread and event name.</source>
          <target state="translated">표에는 스레드 및 이벤트 이름으로 요약 된 스테이지 이벤트가 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0491f266cb8058050e03fc81421be4628c82c594" translate="yes" xml:space="preserve">
          <source>The table lists stage events, summarized by user and event name.</source>
          <target state="translated">이 테이블에는 사용자 및 이벤트 이름으로 요약 된 스테이지 이벤트가 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="221778169f4cd3cf0cede31a955cea311a482719" translate="yes" xml:space="preserve">
          <source>The table must also have the &lt;code&gt;WITH SYSTEM VERSIONING&lt;/code&gt; clause.</source>
          <target state="translated">테이블에는 &lt;code&gt;WITH SYSTEM VERSIONING&lt;/code&gt; 절도 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="1becea5a1cb4e1d3b9bfef805ea2c642fb06521a" translate="yes" xml:space="preserve">
          <source>The table must be initialized to one row: (SmallestAddress, Free)</source>
          <target state="translated">테이블은 한 행으로 초기화되어야합니다. (SmallestAddress, Free)</target>
        </trans-unit>
        <trans-unit id="bd1ed50aae8e32a13dd359b5db48218f9d95d515" translate="yes" xml:space="preserve">
          <source>The table must define a column that corresponds to the Column Family's rowkey.</source>
          <target state="translated">테이블은 열 패밀리의 행 키에 해당하는 열을 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="160f10ea7fc57fe909fba6e6b874175626aac209" translate="yes" xml:space="preserve">
          <source>The table name</source>
          <target state="translated">테이블 이름</target>
        </trans-unit>
        <trans-unit id="cec738f77987cf3e636672da788e423405b76192" translate="yes" xml:space="preserve">
          <source>The table name can be specified in the form &lt;code&gt;db_name&lt;/code&gt;.&lt;code&gt;tbl_name&lt;/code&gt; or, if a default database is selected, in the form &lt;code&gt;tbl_name&lt;/code&gt; (see &lt;a href=&quot;../identifier-qualifiers/index&quot;&gt;Identifier Qualifiers&lt;/a&gt;). This allows to use &lt;a href=&quot;../insert-select/index&quot;&gt;INSERT ... SELECT&lt;/a&gt; to copy rows between different databases.</source>
          <target state="translated">테이블 이름은 &lt;code&gt;db_name&lt;/code&gt; 형식으로 지정할 수 있습니다 . &lt;code&gt;tbl_name&lt;/code&gt; 또는 기본 데이터베이스가 선택된 경우 &lt;code&gt;tbl_name&lt;/code&gt; 형식으로 표시됩니다 ( &lt;a href=&quot;../identifier-qualifiers/index&quot;&gt;식별자 규정 자&lt;/a&gt; 참조 ). 이렇게하면 &lt;a href=&quot;../insert-select/index&quot;&gt;INSERT ... SELECT&lt;/a&gt; 를 사용 하여 다른 데이터베이스간에 행을 복사 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1ddcd18c63179655317ff282139f881349e5b2e5" translate="yes" xml:space="preserve">
          <source>The table name can be specified in the form &lt;code&gt;db_name&lt;/code&gt;.&lt;code&gt;tbl_name&lt;/code&gt; or, if a default database is selected, in the form &lt;code&gt;tbl_name&lt;/code&gt; (see &lt;a href=&quot;../identifier-qualifiers/index&quot;&gt;Identifier Qualifiers&lt;/a&gt;). This allows to use &lt;code&gt;&lt;a href=&quot;../insert-select/index&quot;&gt;REPLACE ... SELECT&lt;/a&gt;&lt;/code&gt; to copy rows between different databases.</source>
          <target state="translated">테이블 이름은 &lt;code&gt;db_name&lt;/code&gt; 형식으로 지정할 수 있습니다 . &lt;code&gt;tbl_name&lt;/code&gt; 또는 기본 데이터베이스가 선택된 경우 &lt;code&gt;tbl_name&lt;/code&gt; 형식으로 표시됩니다 ( &lt;a href=&quot;../identifier-qualifiers/index&quot;&gt;식별자 규정 자&lt;/a&gt; 참조 ). 이를 통해 &lt;code&gt;&lt;a href=&quot;../insert-select/index&quot;&gt;REPLACE ... SELECT&lt;/a&gt;&lt;/code&gt; 를 사용 하여 다른 데이터베이스간에 행을 복사 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cbf0a0000461f6b1fc0e37d1d6e8b64652dda27e" translate="yes" xml:space="preserve">
          <source>The table name for the column</source>
          <target state="translated">열의 테이블 이름</target>
        </trans-unit>
        <trans-unit id="905054fe1aefc5725eea1173de784dd765e8936b" translate="yes" xml:space="preserve">
          <source>The table name.</source>
          <target state="translated">테이블 이름</target>
        </trans-unit>
        <trans-unit id="556d1a9193a128cd9e77fef28b9c65c0c353dbe0" translate="yes" xml:space="preserve">
          <source>The table needs to be existent and in the same structure of the dataframe to export.</source>
          <target state="translated">테이블이 존재하고 내보낼 데이터 프레임의 동일한 구조에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="9d66db273497d48503eb972f63fa8e821de93a26" translate="yes" xml:space="preserve">
          <source>The table object is only closed when &lt;code&gt;HANDLER ... CLOSE&lt;/code&gt; is called by the session, and is not shared by other sessions.</source>
          <target state="translated">테이블 개체는 세션에서 &lt;code&gt;HANDLER ... CLOSE&lt;/code&gt; 를 호출 한 경우에만 닫히고 다른 세션과 공유하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cd543ab067eb32e049d030e4d6c354632780ce9a" translate="yes" xml:space="preserve">
          <source>The table of representation choices says 52 feet of resolution for Deg*10000 and DECIMAL(x,4). Here is how it was calculated: To measuring a diagonal between lat/lng (0,0) and (0.0001,00001) (one 'unit in the last place'): GCDist(0,0,1,1) * 69.172 / 10000 * 5280 = 51.65, where</source>
          <target state="translated">선택 표에 Deg * 10000 및 DECIMAL (x, 4)에 대한 52 피트의 해상도가 표시됩니다. 계산 방법은 다음과 같습니다. 위도 / 경도 (0,0)와 (0.0001,00001) 사이의 대각선을 측정하려면 ( '마지막 위치에있는 하나') : GCDist (0,0,1,1) * 69.172 / 10000 * 5280 = 51.65, 여기서</target>
        </trans-unit>
        <trans-unit id="994b944ef8838fb437c1ec7f41027a157ffdaf0e" translate="yes" xml:space="preserve">
          <source>The table privilege type. See &lt;a href=&quot;../grant/index#table-privileges&quot;&gt;Table Privileges&lt;/a&gt; for details.</source>
          <target state="translated">테이블 권한 유형 자세한 내용은 &lt;a href=&quot;../grant/index#table-privileges&quot;&gt;테이블 권한&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="88802a53bcde63f1b242bab241eee740458cae05" translate="yes" xml:space="preserve">
          <source>The table result is:</source>
          <target state="translated">테이블 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="472dc92dbefa88d0caffb404598228de1d6efb86" translate="yes" xml:space="preserve">
          <source>The table row format affects the checksum value. If the row format changes, the checksum will change. This means that when a table created with a MariaDB/MySQL version is upgraded to another version, the checksum value will probably change.</source>
          <target state="translated">테이블 행 형식은 체크섬 값에 영향을줍니다. 행 형식이 변경되면 체크섬이 변경됩니다. 이것은 MariaDB / MySQL 버전으로 생성 된 테이블이 다른 버전으로 업그레이드 될 때 체크섬 값이 변경 될 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="fafbab5698d58e4df4e7d7f14e75c30f406ee5b0" translate="yes" xml:space="preserve">
          <source>The table should be &lt;a href=&quot;../innodb/index&quot;&gt;InnoDB&lt;/a&gt;, hence it should have a PRIMARY KEY. The entitity_id is the 'natural' PK. Add a small number of other indexes (often 'composite') on the searchable fields. &lt;a href=&quot;../managing-mariadb-partitioning/index&quot;&gt;PARTITIONing&lt;/a&gt; is unlikely to be of any use, unless the Entities should purged after some time. (Example: News Articles)</source>
          <target state="translated">테이블은 &lt;a href=&quot;../innodb/index&quot;&gt;InnoDB&lt;/a&gt; 이므로 PRIMARY KEY가 있어야합니다. entitity_id는 '자연'PK입니다. 검색 가능한 필드에 적은 수의 다른 색인 (종종 '복합')을 추가하십시오. 엔터티가 일정 시간 후에 제거되지 않으면 &lt;a href=&quot;../managing-mariadb-partitioning/index&quot;&gt;파티셔닝&lt;/a&gt; 은 사용되지 않을 것입니다. (예 : 뉴스 기사)</target>
        </trans-unit>
        <trans-unit id="c4517f90a02902b86b3d2d0383787df7c2e83165" translate="yes" xml:space="preserve">
          <source>The table should have a blob column which will be used as storage for dynamic columns:</source>
          <target state="translated">테이블에는 동적 열의 저장소로 사용될 BLOB 열이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="bb86c7c6baa0b8f45876b5b8cc00a6bdab5ec3db" translate="yes" xml:space="preserve">
          <source>The table size is determined at startup by the value of the &lt;a href=&quot;../performance-schema-system-variables/index#performance_schema_accounts_size&quot;&gt;performance_schema_accounts_size&lt;/a&gt; system variable. If this is set to 0, account statistics will be disabled.</source>
          <target state="translated">테이블 크기는 시작시 &lt;a href=&quot;../performance-schema-system-variables/index#performance_schema_accounts_size&quot;&gt;performance_schema_accounts_size&lt;/a&gt; 시스템 변수 의 값에 의해 결정됩니다 . 이 값을 0으로 설정하면 계정 통계가 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="acc03ce54203717c785cbf8dc51f3bceb14e13bf" translate="yes" xml:space="preserve">
          <source>The table size is determined at startup by the value of the &lt;a href=&quot;../performance-schema-system-variables/index#performance_schema_users_size&quot;&gt;performance_schema_users_size&lt;/a&gt; system variable. If this is set to &lt;code&gt;0&lt;/code&gt;, user statistics will be disabled.</source>
          <target state="translated">테이블 크기는 시작시 &lt;a href=&quot;../performance-schema-system-variables/index#performance_schema_users_size&quot;&gt;performance_schema_users_size&lt;/a&gt; 시스템 변수 의 값에 의해 결정됩니다 . 이 값을 &lt;code&gt;0&lt;/code&gt; 으로 설정하면 사용자 통계가 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="c6bdc0aed50e9febf1ecbf1efb08d810b200925c" translate="yes" xml:space="preserve">
          <source>The table structure is identical to the &lt;a href=&quot;../performance-schema-events_stages_current-table/index&quot;&gt;events_stage_current&lt;/a&gt; table structure, and contains the following columns:</source>
          <target state="translated">테이블 구조는 &lt;a href=&quot;../performance-schema-events_stages_current-table/index&quot;&gt;events_stage_current&lt;/a&gt; 테이블 구조와 동일 하며 다음 열을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="f400a9d451e02486fa0f9d860d904f1241a324b0" translate="yes" xml:space="preserve">
          <source>The table structure is identical to the &lt;a href=&quot;../performance-schema-events_statements_current-table/index&quot;&gt;events_statements_current&lt;/a&gt; table structure, and contains the following columns:</source>
          <target state="translated">테이블 구조는 &lt;a href=&quot;../performance-schema-events_statements_current-table/index&quot;&gt;events_statements_current&lt;/a&gt; 테이블 구조와 동일 하며 다음 열을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="f99dc0cebd9dabf474505756104e287958e55b5d" translate="yes" xml:space="preserve">
          <source>The table structure is identical to the &lt;a href=&quot;../performance-schema-events_waits_current-table/index&quot;&gt;events_waits_current&lt;/a&gt; table structure, and contains the following columns:</source>
          <target state="translated">테이블 구조는 &lt;a href=&quot;../performance-schema-events_waits_current-table/index&quot;&gt;events_waits_current&lt;/a&gt; 테이블 구조와 동일 하며 다음 열을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="ec8b016b427ac0eddbaa5f25928a1cd38d0ba254" translate="yes" xml:space="preserve">
          <source>The table structure is identical to the &lt;code&gt;events_stage_current&lt;/code&gt; table structure, and contains the following columns:</source>
          <target state="translated">테이블 구조는 &lt;code&gt;events_stage_current&lt;/code&gt; 테이블 구조와 동일 하며 다음 열을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="9b633874e9ea2aa8f72e2132b23e33d53234e9d0" translate="yes" xml:space="preserve">
          <source>The table to the &quot;left&quot; in a LEFT JOIN usually comes before the &quot;right&quot; table. (By looking at the table definitions, the optimizer may decide that &quot;LEFT&quot; is irrelevant.)</source>
          <target state="translated">LEFT JOIN의 &quot;왼쪽&quot;에있는 테이블은 일반적으로 &quot;오른쪽&quot;테이블 앞에옵니다. (테이블 정의를 보면 옵티마이 저는 &quot;LEFT&quot;가 관련이 없다고 결정할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="a11355b91c087ce45918bc9c5f0b072c75b6115b" translate="yes" xml:space="preserve">
          <source>The table uses an index for which there has been a &lt;a href=&quot;../character-sets/index&quot;&gt;collation&lt;/a&gt; change (rare)</source>
          <target state="translated">&lt;a href=&quot;../character-sets/index&quot;&gt;데이터 정렬&lt;/a&gt; 이 있었던 인덱스가 테이블에 사용됩니다. 변경 (희귀)</target>
        </trans-unit>
        <trans-unit id="015dbd1add9d289253f3b76c81cd52cfdea68ff9" translate="yes" xml:space="preserve">
          <source>The table was a const table (a table with only one possible matching row), but no row was found.</source>
          <target state="translated">테이블이 const 테이블 (가능한 행이 하나만있는 테이블)이지만 행을 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="fe937847465a2878947d6e03079db89cc18a594b" translate="yes" xml:space="preserve">
          <source>The table was a system table (a table with should exactly one row), but no row was found.</source>
          <target state="translated">테이블은 시스템 테이블 (정확히 하나의 행이있는 테이블)이지만 행을 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f65319a3745d3a7d80da2493168dea30b6516aaf" translate="yes" xml:space="preserve">
          <source>The table was detected to be a const table (a table with only one possible matching row) during the early optimization phase, but no row was found.</source>
          <target state="translated">초기 최적화 단계에서 테이블이 const 테이블 (가능한 일치 행이 하나만있는 테이블) 인 것으로 발견되었지만 행을 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3e37560a18f74ac21493b5180377e875e116299a" translate="yes" xml:space="preserve">
          <source>The table we want to analyze is represented by the array value of the &amp;ldquo;data&amp;rdquo; object. Here is how this is specified in the create table statement:</source>
          <target state="translated">우리가 분석하고자하는 테이블은&amp;ldquo;data&amp;rdquo;객체의 배열 값으로 표시됩니다. 테이블 작성 명령문에서이를 지정하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e9a051af77f4e05cb47ef349ba9d9a63920ebe36" translate="yes" xml:space="preserve">
          <source>The table will be accessed with a key over one or more value ranges.</source>
          <target state="translated">테이블은 하나 이상의 값 범위에 대한 키로 액세스됩니다.</target>
        </trans-unit>
        <trans-unit id="b98febff0b6f15fd03dd8d53ac27c2b18d2a217d" translate="yes" xml:space="preserve">
          <source>The table will be copied in S3 into the following locations:</source>
          <target state="translated">테이블이 S3에서 다음 위치로 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="a44881398290ebf59511d40883bd4cf7a488d1ce" translate="yes" xml:space="preserve">
          <source>The table will be displayed as:</source>
          <target state="translated">테이블은 다음과 같이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e0b54c77f3f88d19df047d54e8aa8dc620d36530" translate="yes" xml:space="preserve">
          <source>The table will be rebuilt using the current values of the &lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_file_per_table&quot;&gt;innodb_file_per_table&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_file_format&quot;&gt;innodb_file_format&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_default_row_format&quot;&gt;innodb_default_row_format&lt;/a&gt;&lt;/code&gt; system variables.</source>
          <target state="translated">테이블은 &lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_file_per_table&quot;&gt;innodb_file_per_table&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_file_format&quot;&gt;innodb_file_format&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_default_row_format&quot;&gt;innodb_default_row_format&lt;/a&gt;&lt;/code&gt; 시스템 변수 의 현재 값을 사용하여 재 빌드됩니다 .</target>
        </trans-unit>
        <trans-unit id="dc1c9a8b9807e881a6e296ce9d1e34120c8ba6d0" translate="yes" xml:space="preserve">
          <source>The table_name can be specified with or without the .MYI index extension.</source>
          <target state="translated">table_name은 .MYI 색인 확장자를 사용하거나 사용하지 않고 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f766417d0f7b9c1830115cd0430acacf41de5881" translate="yes" xml:space="preserve">
          <source>The table_usage() procedure gives a the total data disk usage, dictionary disk usage and grand total disk usage per-table. It can be called in several ways, the first gives a total for each table:</source>
          <target state="translated">table_usage () 프로시 저는 총 데이터 디스크 사용량, 사전 디스크 사용량 및 테이블 당 총 디스크 사용량을 제공합니다. 여러 가지 방법으로 호출 할 수 있으며 첫 번째는 각 테이블에 대한 합계를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fd452eb47938ff29366b2fcd7aa41c4dedbb4582" translate="yes" xml:space="preserve">
          <source>The tables referenced in &lt;code&gt;TYPE OF&lt;/code&gt; and &lt;code&gt;ROW TYPE OF&lt;/code&gt; declarations will be checked for existence at the beginning of the stored routine call. &lt;a href=&quot;../create-procedure/index&quot;&gt;CREATE PROCEDURE&lt;/a&gt; or &lt;a href=&quot;../create-function/index&quot;&gt;CREATE FUNCTION&lt;/a&gt; will not check the referenced tables for existence.</source>
          <target state="translated">&lt;code&gt;TYPE OF&lt;/code&gt; 및 &lt;code&gt;ROW TYPE OF&lt;/code&gt; 선언 에서 참조 된 테이블 은 저장된 루틴 호출이 시작될 때 존재하는지 확인합니다. &lt;a href=&quot;../create-procedure/index&quot;&gt;CREATE PROCEDURE&lt;/a&gt; 또는 &lt;a href=&quot;../create-function/index&quot;&gt;CREATE FUNCTION&lt;/a&gt; 은 참조 된 테이블이 존재하는지 확인하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="19513307287a3cbbf3e13c48b99359087bcb3cde" translate="yes" xml:space="preserve">
          <source>The tail of the &lt;a href=&quot;../innodb-redo-log/index&quot;&gt;InnoDB redo log&lt;/a&gt; (i.e. &lt;code&gt;ib_logfileN&lt;/code&gt; files) will be copied for &lt;a href=&quot;../innodb/index&quot;&gt;InnoDB&lt;/a&gt; tables.</source>
          <target state="translated">&lt;a href=&quot;../innodb/index&quot;&gt;InnoDB&lt;/a&gt; 테이블 에 대해 &lt;a href=&quot;../innodb-redo-log/index&quot;&gt;InnoDB 리두 로그&lt;/a&gt; 의 꼬리 (즉 &lt;code&gt;ib_logfileN&lt;/code&gt; 파일)가 복사됩니다 .</target>
        </trans-unit>
        <trans-unit id="ebfad3e67a7be0c6c5cba7993f8eff75a4cbbbd0" translate="yes" xml:space="preserve">
          <source>The tail of the Aria redo log (i.e. &lt;code&gt;aria_log.N&lt;/code&gt; files) will be copied for &lt;a href=&quot;../aria/index&quot;&gt;Aria&lt;/a&gt; tables.</source>
          <target state="translated">&lt;a href=&quot;../aria/index&quot;&gt;Aria&lt;/a&gt; 테이블 의 경우 Aria redo 로그의 꼬리 (예 : &lt;code&gt;aria_log.N&lt;/code&gt; 파일)가 복사됩니다 .</target>
        </trans-unit>
        <trans-unit id="1c33c76665359938699f5845c64a1a3cb9c735fe" translate="yes" xml:space="preserve">
          <source>The target database for &lt;a href=&quot;../connect-table-types-odbc-table-type-accessing-tables-from-other-dbms/index&quot;&gt;ODBC&lt;/a&gt;, &lt;a href=&quot;../connect-jdbc-table-type-accessing-tables-from-other-dbms/index&quot;&gt;JDBC&lt;/a&gt;, &lt;a href=&quot;../connect-table-types-mysql-table-type-accessing-mysqlmariadb-tables/index&quot;&gt;MYSQL&lt;/a&gt;, &lt;a href=&quot;../connect-table-types-catalog-tables/index&quot;&gt;catalog&lt;/a&gt;, and &lt;a href=&quot;../connect-table-types-proxy-table-type/index&quot;&gt;PROXY&lt;/a&gt; based tables. The database concept is sometimes known as a &lt;em&gt;schema&lt;/em&gt;.</source>
          <target state="translated">&lt;a href=&quot;../connect-table-types-odbc-table-type-accessing-tables-from-other-dbms/index&quot;&gt;ODBC&lt;/a&gt; , &lt;a href=&quot;../connect-jdbc-table-type-accessing-tables-from-other-dbms/index&quot;&gt;JDBC&lt;/a&gt; , &lt;a href=&quot;../connect-table-types-mysql-table-type-accessing-mysqlmariadb-tables/index&quot;&gt;MYSQL&lt;/a&gt; , &lt;a href=&quot;../connect-table-types-catalog-tables/index&quot;&gt;카탈로그&lt;/a&gt; 및 &lt;a href=&quot;../connect-table-types-proxy-table-type/index&quot;&gt;PROXY&lt;/a&gt; 기반 테이블 의 대상 데이터베이스 . 데이터베이스 개념을 &lt;em&gt;스키마&lt;/em&gt; 라고도합니다 .</target>
        </trans-unit>
        <trans-unit id="a14832d60012df7d2bf1fcde312442dc2eff7e4e" translate="yes" xml:space="preserve">
          <source>The target table %s of the %s is not insertable-into</source>
          <target state="translated">% s의 목표 테이블 % s을 (를) 삽입 할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="bd14b819cbdba86eb6204a68e4329a2e00cc235b" translate="yes" xml:space="preserve">
          <source>The target table %s of the %s is not updatable</source>
          <target state="translated">% s의 목표 테이블 % s을 (를) 업데이트 할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="5579254256d0a33af64c25f79d61df2fcb391324" translate="yes" xml:space="preserve">
          <source>The target table now contains the first partition from the source table.</source>
          <target state="translated">대상 테이블에는 이제 소스 테이블의 첫 번째 파티션이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="f8e975bc3abae809ec40828ba7ec9a75a479707b" translate="yes" xml:space="preserve">
          <source>The target table or node for &lt;a href=&quot;../connect-table-types-odbc-table-type-accessing-tables-from-other-dbms/index&quot;&gt;ODBC&lt;/a&gt;, &lt;a href=&quot;../connect-jdbc-table-type-accessing-tables-from-other-dbms/index&quot;&gt;JDBC&lt;/a&gt;, &lt;a href=&quot;../connect-table-types-mysql-table-type-accessing-mysqlmariadb-tables/index&quot;&gt;MYSQL&lt;/a&gt;, &lt;a href=&quot;../connect-table-types-proxy-table-type/index&quot;&gt;PROXY&lt;/a&gt;, or &lt;a href=&quot;../connect-table-types-catalog-tables/index&quot;&gt;catalog tables&lt;/a&gt;; or the top node name for &lt;a href=&quot;../connect-xml-table-type/index&quot;&gt;XML&lt;/a&gt; tables.</source>
          <target state="translated">&lt;a href=&quot;../connect-table-types-odbc-table-type-accessing-tables-from-other-dbms/index&quot;&gt;ODBC&lt;/a&gt; , &lt;a href=&quot;../connect-jdbc-table-type-accessing-tables-from-other-dbms/index&quot;&gt;JDBC&lt;/a&gt; , &lt;a href=&quot;../connect-table-types-mysql-table-type-accessing-mysqlmariadb-tables/index&quot;&gt;MYSQL&lt;/a&gt; , &lt;a href=&quot;../connect-table-types-proxy-table-type/index&quot;&gt;PROXY&lt;/a&gt; 또는 &lt;a href=&quot;../connect-table-types-catalog-tables/index&quot;&gt;카탈로그 테이블&lt;/a&gt; 의 대상 테이블 또는 노드 . 또는 &lt;a href=&quot;../connect-xml-table-type/index&quot;&gt;XML&lt;/a&gt; 테이블 의 최상위 노드 이름 .</target>
        </trans-unit>
        <trans-unit id="a1e9187cce71d360269cd62baef0da77df96ea77" translate="yes" xml:space="preserve">
          <source>The task</source>
          <target state="translated">작업</target>
        </trans-unit>
        <trans-unit id="01249eccedc64e66ef4f07c6c0fb339b526b6123" translate="yes" xml:space="preserve">
          <source>The task of scalable server software (and a DBMS like MariaDB is an example of such software) is to maintain top performance with an increasing number of clients. MySQL traditionally assigned a thread for every client connection, and as the number of concurrent users grows this model shows performance drops. Many active threads are a performance killer, because increasing the number of threads leads to extensive context switching, bad locality for CPU caches, and increased contention for hot locks. An ideal solution that would help to reduce context switching is to maintain a lower number of threads than the number of clients. But this number should not be too low either, since we also want to utilize CPUs to their fullest, so ideally, there should be a single active thread for each CPU on the machine.</source>
          <target state="translated">확장 가능한 서버 소프트웨어 (MariaDB와 같은 DBMS는 이러한 소프트웨어의 예)의 임무는 점점 더 많은 클라이언트에서 최고의 성능을 유지하는 것입니다. MySQL은 전통적으로 모든 클라이언트 연결에 스레드를 할당했으며 동시 사용자 수가 증가함에 따라이 모델은 성능 저하를 보여줍니다. 스레드 수를 늘리면 광범위한 컨텍스트 전환, CPU 캐시에 대한 잘못된 지역성 및 핫락에 대한 경합이 증가하기 때문에 많은 활성 스레드가 성능을 저하시킵니다. 컨텍스트 전환을 줄이는 데 도움이되는 이상적인 솔루션은 클라이언트 수보다 적은 수의 스레드를 유지하는 것입니다. 그러나 CPU를 최대한 활용하기를 원하기 때문에이 숫자도 너무 낮아서는 안되므로 이상적으로는 머신의 각 CPU마다 단일 활성 스레드가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="f7932913e589d7dfe66b85c66b1b616172146a40" translate="yes" xml:space="preserve">
          <source>The tb.json file will be changed to:</source>
          <target state="translated">tb.json 파일이 다음과 같이 변경됩니다 :</target>
        </trans-unit>
        <trans-unit id="154a399ac25f4eabeb0034c390f291fd754f467f" translate="yes" xml:space="preserve">
          <source>The technique we have seen above with file partitioning is also available with table partitioning. Companies willing to use as one table data sharded on the company branch servers can, as we have seen, add to the table create definition a special column. For instance:</source>
          <target state="translated">위에서 파일 분할에서 보았던 기술은 테이블 분할에서도 사용할 수 있습니다. 회사 지점 서버에서 샤딩 된 하나의 테이블 데이터로 기꺼이 사용하려는 회사는 앞에서 본 것처럼 테이블에 정의를 추가하여 특수 열을 만들 수 있습니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="35afbe94e586f954b78cfb3e699e0b0e6a66f132" translate="yes" xml:space="preserve">
          <source>The temporary directory. The default is /tmp.</source>
          <target state="translated">임시 디렉토리. 기본값은 / tmp입니다.</target>
        </trans-unit>
        <trans-unit id="9230152bf48578ec733b125cd055e6e33cd04c75" translate="yes" xml:space="preserve">
          <source>The term &quot;default&quot; in the list below refers to the distribution's default relational or MySQL-type database.</source>
          <target state="translated">아래 목록에서 &quot;default&quot;라는 용어는 배포의 기본 관계형 또는 MySQL 유형 데이터베이스를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="cf67beb3579a4e85ca042dc0b4d15256c2baea00" translate="yes" xml:space="preserve">
          <source>The term &quot;optimistic&quot; is used for this mode, because the server optimistically assumes that few conflicts will occur, and that the extra work spent rolling back and retrying conflicting transactions is justified from the gain from running most transactions in parallel.</source>
          <target state="translated">서버가 충돌이 거의 발생하지 않는다고 낙관적으로 가정하고 충돌 트랜잭션을 롤백하고 재 시도하는 추가 작업이 대부분의 트랜잭션을 병렬로 실행함으로써 얻는 이익에서 정당화된다고 낙관적으로 가정하기 때문에 &quot;낙관적&quot;이라는 용어가이 모드에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="dceba5ca9cbf2a94633e5bfd0179ef4122b6994b" translate="yes" xml:space="preserve">
          <source>The term spatially crosses denotes a spatial relation between two given geometries that has the following properties:</source>
          <target state="translated">공간적으로 교차하는 용어는 다음과 같은 특성을 갖는 두 개의 지정된 형상 사이의 공간 관계를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="caae6f84bf042601ed5420d1349913d39e361592" translate="yes" xml:space="preserve">
          <source>The term spatially overlaps is used if two geometries intersect and their intersection results in a geometry of the same dimension but not equal to either of the given geometries.</source>
          <target state="translated">공간적으로 겹침이라는 용어는 두 형상이 교차하고 그 교차로 인해 동일한 치수이지만 동일한 형상과 다른 형상을 생성하는 경우에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e37213627436d6c81ca99f22e64c12eeaa097965" translate="yes" xml:space="preserve">
          <source>The terms 'KEY' and 'INDEX' are generally used interchangeably, and statements should work with either keyword.</source>
          <target state="translated">'KEY'와 'INDEX'라는 용어는 일반적으로 상호 교환 가능하게 사용되며 명령문은 두 키워드와 함께 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="18a66ed77acfc0b679b875b8b663de3211cff7a7" translate="yes" xml:space="preserve">
          <source>The test took 38 seconds, Number of syncs was 1400+400=1800, which gives 45 syncs/sec which looks normal for this slow rotating desktop hdd.</source>
          <target state="translated">테스트는 38 초가 걸렸습니다. 동기화 횟수는 1400 + 400 = 1800으로, 초당 45 번의 동기화 속도를 제공합니다.이 느린 회전 데스크탑 hdd에서는 정상적으로 보입니다.</target>
        </trans-unit>
        <trans-unit id="ebefdb6b71da06b917f1f35197f021b4cc8103ae" translate="yes" xml:space="preserve">
          <source>The the IN predicate matches the row &lt;code&gt;(7, 11, 9)
&lt;/code&gt;, and the result of IN is NULL. Matches where the differing values on either side of the IN arguments are matched by a NULL in the other IN argument, are called &lt;em&gt;partial matches&lt;/em&gt;.</source>
          <target state="translated">IN 술어는 행 &lt;code&gt;(7, 11, 9) &lt;/code&gt; 와 일치하며 IN 의 결과는 NULL입니다. IN 인수의 양쪽에서 다른 값이 다른 IN 인수에서 NULL &lt;em&gt;과 일치하는 일치를 부분 일치&lt;/em&gt; 라고 합니다.</target>
        </trans-unit>
        <trans-unit id="a6eb91d1a0aa3f84f6d6a70668dfb7f6ead7e978" translate="yes" xml:space="preserve">
          <source>The third case (OR across 2 tables) is similar to the second.</source>
          <target state="translated">세 번째 경우 (또는 두 테이블에 걸쳐)는 두 번째 경우와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="facf78a5a7c6cefc8d3d2ee3e3ed483084971b8c" translate="yes" xml:space="preserve">
          <source>The third name, ordered alphabetically (the first name would be offset zero, so the third is offset two):</source>
          <target state="translated">알파벳 순서로 정렬 된 세 번째 이름 (첫 번째 이름은 오프셋 0이므로 세 번째 이름은 오프셋 2) :</target>
        </trans-unit>
        <trans-unit id="eef42da8f7131eba5d47a58293a9fdc97c3d7897" translate="yes" xml:space="preserve">
          <source>The third number is the sequence number. This is a 64-bit unsigned integer that is monotonically increasing for each new event group logged into the binlog.</source>
          <target state="translated">세 번째 숫자는 시퀀스 번호입니다. 이것은 binlog에 로그인 된 각 새 이벤트 그룹에 대해 단조 증가하는 64 비트 부호없는 정수입니다.</target>
        </trans-unit>
        <trans-unit id="4f7e579f57ebc114358a4800fb44aa0e23382f35" translate="yes" xml:space="preserve">
          <source>The third part of postConfigure is the starting up of the system, which consist of starting up of the 'columnstore' service script on each node. If a failure happens during this time frame, do the following to help determine the failure:</source>
          <target state="translated">postConfigure의 세 번째 부분은 시스템 시작이며 각 노드에서 'columnstore'서비스 스크립트 시작으로 구성됩니다. 이 기간 동안 실패가 발생하면 다음을 수행하여 실패를 판별하십시오.</target>
        </trans-unit>
        <trans-unit id="a9d56bdfbf1f7b025cb80914e5bc2d66e4eeb1e7" translate="yes" xml:space="preserve">
          <source>The third string argument is a Json path to the object to be the target of deletion.</source>
          <target state="translated">세 번째 문자열 인수는 삭제 대상이 될 객체의 Json 경로입니다.</target>
        </trans-unit>
        <trans-unit id="d82075de8dd9c6c7bf89c8c3a5c143faab8b18ea" translate="yes" xml:space="preserve">
          <source>The third string argument is a Json path to the target object.</source>
          <target state="translated">세 번째 문자열 인수는 대상 객체에 대한 Json 경로입니다.</target>
        </trans-unit>
        <trans-unit id="fe60558858f79f4df7a8823c4e3604d71a189f8f" translate="yes" xml:space="preserve">
          <source>The thread group has not handled any I/O events since the last check by the timer thread.</source>
          <target state="translated">스레드 그룹은 타이머 스레드에 의한 마지막 확인 이후 I / O 이벤트를 처리하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="a0906400eba9e48d4a3711b6deb0b4febe87c176" translate="yes" xml:space="preserve">
          <source>The thread pool has a feature that allows it to detect if a client connection is executing a long-running query that may be monopolizing its thread group. If a client connection were to monopolize its thread group, then that could prevent other client connections in the thread group from running their queries. In other words, the thread group would appear to be &lt;em&gt;stalled&lt;/em&gt;.</source>
          <target state="translated">스레드 풀에는 클라이언트 연결이 스레드 그룹을 독점 할 수있는 장기 실행 쿼리를 실행 중인지 여부를 감지 할 수있는 기능이 있습니다. 클라이언트 연결이 스레드 그룹을 독점하는 경우 스레드 그룹의 다른 클라이언트 연결이 쿼리를 실행하지 못할 수 있습니다. 즉, 스레드 그룹이 &lt;em&gt;정지 된&lt;/em&gt; 것으로 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="0478f7cd8b7a3dd012f9a904f4b1297739a5c9ec" translate="yes" xml:space="preserve">
          <source>The thread pool has one global thread: a &lt;strong&gt;timer thread&lt;/strong&gt;. The &lt;strong&gt;timer thread&lt;/strong&gt; performs tasks, such as:</source>
          <target state="translated">스레드 풀에는 하나의 전역 스레드 ( &lt;strong&gt;타이머 스레드)가&lt;/strong&gt; 있습니다. &lt;strong&gt;타이머 스레드&lt;/strong&gt; 등의 작업을 수행 :</target>
        </trans-unit>
        <trans-unit id="99b1a015b435f20f4e99abccfb9ecabcb2ecf87e" translate="yes" xml:space="preserve">
          <source>The thread pool's &lt;strong&gt;timer thread&lt;/strong&gt; can create a new &lt;strong&gt;listener thread&lt;/strong&gt; for a thread group when the thread group has more client connection requests that need to be distributed, but the thread group does not currently have a &lt;strong&gt;listener thread&lt;/strong&gt; to distribute them. This can help to ensure that the thread group does not miss client connection requests because it has no &lt;strong&gt;listener thread&lt;/strong&gt;.</source>
          <target state="translated">스레드 그룹에 분배해야하는 클라이언트 연결 요청이 더 많지만 스레드 그룹에 현재 분배 할 &lt;strong&gt;리스너 스레드&lt;/strong&gt; 가없는 경우 스레드 풀의 &lt;strong&gt;타이머 스레드&lt;/strong&gt; 가 스레드 그룹에 대한 새 &lt;strong&gt;리스너 스레드&lt;/strong&gt; 를 작성할 수 있습니다 . 이것은 &lt;strong&gt;리스너 스레드&lt;/strong&gt; 가 없기 때문에 스레드 그룹이 클라이언트 연결 요청을 놓치지 않도록하는 데 도움이됩니다 .&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="715eb4f34a77651c7343ef5b1bfe083b9120a268" translate="yes" xml:space="preserve">
          <source>The thread pool's &lt;strong&gt;timer thread&lt;/strong&gt; can create a new &lt;strong&gt;worker thread&lt;/strong&gt; for a thread group when the thread group is stalled. This can help to ensure that a long query can't monopole its thread group.</source>
          <target state="translated">스레드 풀의 &lt;strong&gt;타이머 스레드&lt;/strong&gt; 는 스레드 그룹이 정지 될 때 스레드 그룹에 대한 새 &lt;strong&gt;작업자 스레드&lt;/strong&gt; 를 만들 수 있습니다 . 이것은 긴 쿼리가 스레드 그룹을 독점 할 수 없도록하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9def9ba504df466ad4c2d01c8a0302e6ff6d25b" translate="yes" xml:space="preserve">
          <source>The thread pool's &lt;strong&gt;timer thread&lt;/strong&gt; creates a new &lt;strong&gt;listener thread&lt;/strong&gt; for a thread group if all of the following conditions are met:</source>
          <target state="translated">다음 조건이 모두 충족되면 스레드 풀의 &lt;strong&gt;타이머 스레드&lt;/strong&gt; 가 스레드 그룹에 대한 새 &lt;strong&gt;리스너 스레드&lt;/strong&gt; 를 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="1f99df136d635e64e24db6bdb53d4b55f2f8bbb5" translate="yes" xml:space="preserve">
          <source>The thread pool's &lt;strong&gt;timer thread&lt;/strong&gt; creates a new &lt;strong&gt;worker thread&lt;/strong&gt; for a thread group if all of the following conditions are met:</source>
          <target state="translated">다음 조건이 모두 충족되면 스레드 풀의 &lt;strong&gt;타이머 스레드&lt;/strong&gt; 가 스레드 그룹에 대한 새 &lt;strong&gt;작업자 스레드&lt;/strong&gt; 를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="6572602b2ab451ac1b712f3e8c7cb6f2a2162525" translate="yes" xml:space="preserve">
          <source>The thread which first started the &lt;code&gt;commit&lt;/code&gt; is performing the actual flush of logs. Other threads set the new goal (LSN) of the next pass (if it is maximum) and wait for the pass end or just wait for the pass end.</source>
          <target state="translated">&lt;code&gt;commit&lt;/code&gt; 을 처음 시작한 스레드 는 실제 로그 플러시를 수행합니다. 다른 스레드는 다음 패스의 새 목표 (LSN)를 설정하고 (최대 인 경우) 패스 엔드를 기다리거나 패스 엔드를 기다립니다.</target>
        </trans-unit>
        <trans-unit id="b08fd970e4df67d300b85c3e935e5ee8e0dc9550" translate="yes" xml:space="preserve">
          <source>The three binary logging formats.</source>
          <target state="translated">세 가지 이진 로깅 형식.</target>
        </trans-unit>
        <trans-unit id="b846d0867c25e605d6bdefaa72ed9e56b78e1aa1" translate="yes" xml:space="preserve">
          <source>The three part partition id (Directory.Segment.DBRoot)</source>
          <target state="translated">세 부분 파티션 ID (Directory.Segment.DBRoot)</target>
        </trans-unit>
        <trans-unit id="04345a188a15ed1e5954a226af9af7f65902c73a" translate="yes" xml:space="preserve">
          <source>The three-character month abbreviation.</source>
          <target state="translated">3 자리 월 약어입니다.</target>
        </trans-unit>
        <trans-unit id="61a678442ced567309fef86055a5f6d2396e2c1e" translate="yes" xml:space="preserve">
          <source>The three-character weekday abbreviation.</source>
          <target state="translated">3 자 평일 약어.</target>
        </trans-unit>
        <trans-unit id="a4afd78aa0d57268464a35657a69cefb0b8afbf5" translate="yes" xml:space="preserve">
          <source>The time in milliseconds spent flushing data log files</source>
          <target state="translated">데이터 로그 파일을 비우는 데 소요 된 시간 (밀리 초)</target>
        </trans-unit>
        <trans-unit id="6966781357195e6acdd7dd44ad706c175d8b6dac" translate="yes" xml:space="preserve">
          <source>The time in milliseconds to flush transaction log files</source>
          <target state="translated">트랜잭션 로그 파일을 비우는 시간 (밀리 초)</target>
        </trans-unit>
        <trans-unit id="6d384580a01d8978712f0500ee899ef29d557a9c" translate="yes" xml:space="preserve">
          <source>The time that defines a slow query can be configured by setting the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#long_query_time&quot;&gt;long_query_time&lt;/a&gt;&lt;/code&gt; system variable. It uses a units of seconds, with an optional milliseconds component. The default value is &lt;code&gt;10&lt;/code&gt;. It can be changed dynamically with &lt;code&gt;&lt;a href=&quot;../set/index#global-session&quot;&gt;SET GLOBAL&lt;/a&gt;&lt;/code&gt;. For example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../server-system-variables/index#long_query_time&quot;&gt;long_query_time&lt;/a&gt;&lt;/code&gt; 시스템 변수를 설정하여 느린 쿼리를 정의하는 시간을 구성 할 수 있습니다 . 선택적인 밀리 초 구성 요소와 함께 초 단위를 사용합니다. 기본값은 &lt;code&gt;10&lt;/code&gt; 입니다. &lt;code&gt;&lt;a href=&quot;../set/index#global-session&quot;&gt;SET GLOBAL&lt;/a&gt;&lt;/code&gt; 을 사용 하여 동적으로 변경할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b1d6643821e3eca94b563d58160b2cb2496d0d9b" translate="yes" xml:space="preserve">
          <source>The time that the backup ended.</source>
          <target state="translated">백업이 종료 된 시간입니다.</target>
        </trans-unit>
        <trans-unit id="4520ef382a67db792f0031e4c1fff5f47588aec5" translate="yes" xml:space="preserve">
          <source>The time that the backup started.</source>
          <target state="translated">백업이 시작된 시간입니다.</target>
        </trans-unit>
        <trans-unit id="56d808b45dc33a5814a74f62c08f1bad1ceff1a9" translate="yes" xml:space="preserve">
          <source>The time the backup takes depends on the size of the databases or tables you're backing up. You can cancel the backup if you need to, as the backup process does not modify the database.</source>
          <target state="translated">백업 시간은 백업중인 데이터베이스 또는 테이블의 크기에 따라 다릅니다. 백업 프로세스는 데이터베이스를 수정하지 않으므로 필요한 경우 백업을 취소 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6c75a4bcc336f1132e19ca298fd09b1b3bd6795" translate="yes" xml:space="preserve">
          <source>The time units containing an underscore are composite; that is, they consist of multiple base time units. For base time units, &lt;code&gt;time_quantity&lt;/code&gt; is an integer number. For composite units, the quantity must be expressed as a string with multiple integer numbers separated by any punctuation character.</source>
          <target state="translated">밑줄을 포함하는 시간 단위는 복합입니다. 즉, 여러 기본 시간 단위로 구성됩니다. 기본 시간 단위의 경우 &lt;code&gt;time_quantity&lt;/code&gt; 는 정수입니다. 복합 단위의 경우 수량은 문장 부호 문자로 구분 된 여러 정수가 포함 된 문자열로 표현되어야합니다.</target>
        </trans-unit>
        <trans-unit id="4dd136efd1e05a813820779eb95120cfda7eb36c" translate="yes" xml:space="preserve">
          <source>The time will be returned in the format &lt;code&gt;hh:mm:ss&lt;/code&gt;, or &lt;code&gt;hhmmss&lt;/code&gt; if used in a numeric calculation.</source>
          <target state="translated">시간은 숫자 계산에 사용되는 경우 &lt;code&gt;hh:mm:ss&lt;/code&gt; 또는 &lt;code&gt;hhmmss&lt;/code&gt; 형식으로 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="4f504d0c005b4ccdd08d184b4b312d0c4b59d09d" translate="yes" xml:space="preserve">
          <source>The times to run this query is as follows:</source>
          <target state="translated">이 쿼리를 실행하는 시간은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d79dfcf3d3a666f37e4346da9fd654185cb96c5d" translate="yes" xml:space="preserve">
          <source>The timestamp field is generally used to define at which moment in time a row was added or updated and by default will automatically be assigned the current datetime when a record is inserted or updated. The automatic properties only apply to the first TIMESTAMP in the record; subsequent TIMESTAMP columns will not be changed.</source>
          <target state="translated">타임 스탬프 필드는 일반적으로 행이 추가되거나 업데이트 된 시점을 정의하는 데 사용되며 기본적으로 레코드가 삽입되거나 업데이트 될 때 현재 날짜 / 시간이 자동으로 할당됩니다. 자동 특성은 레코드의 첫 번째 TIMESTAMP에만 적용됩니다. 후속 TIMESTAMP 열은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7297169f6d32292dd96ff7cba75bb82568a2c52d" translate="yes" xml:space="preserve">
          <source>The timestamp literals are treated as &lt;code&gt;&lt;a href=&quot;../datetime/index&quot;&gt;DATETIME&lt;/a&gt;&lt;/code&gt; literals, because in MariaDB the reange of &lt;code&gt;DATETIME&lt;/code&gt; is closer to the &lt;code&gt;TIMESTAMP&lt;/code&gt; range in the SQL standard.</source>
          <target state="translated">MariaDB에서 &lt;code&gt;DATETIME&lt;/code&gt; 의 범위는 SQL 표준 의 &lt;code&gt;TIMESTAMP&lt;/code&gt; 범위에 더 가깝기 때문에 타임 스탬프 리터럴은 &lt;code&gt;&lt;a href=&quot;../datetime/index&quot;&gt;DATETIME&lt;/a&gt;&lt;/code&gt; 리터럴로 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="f0730e8b943ea87f6feb9e0dd933fc395ca6a6d8" translate="yes" xml:space="preserve">
          <source>The tips in this document apply to MySQL, MariaDB, and Percona.</source>
          <target state="translated">이 문서의 팁은 MySQL, MariaDB 및 Percona에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="471a87f5b96b5fabe0d1493e69a2d5fddac355f0" translate="yes" xml:space="preserve">
          <source>The tool includes 180+ generators, that allow to populate tables with realistic-looking test data. There is an ability to fill tables with IDs, Post codes, Phone numbers, Countries, Credit card numbers, E-mails, etc.</source>
          <target state="translated">이 도구에는 180 개 이상의 생성기가 포함되어있어 실제와 같은 테스트 데이터로 테이블을 채울 수 있습니다. ID, 우편 번호, 전화 번호, 국가, 신용 카드 번호, 전자 메일 등으로 테이블을 채울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3fab4ba9f11b8fbf450ed3606956a543cf12a1e" translate="yes" xml:space="preserve">
          <source>The tool is designed to be run on the system storing the backups. This will automate restoring from backups created by the columnstoreBackup tool.</source>
          <target state="translated">이 도구는 백업을 저장하는 시스템에서 실행되도록 설계되었습니다. columnstoreBackup 도구로 생성 된 백업에서 복원을 자동화합니다.</target>
        </trans-unit>
        <trans-unit id="98f3d3cac073c2a01dd05dc0d29289f2a02ec309" translate="yes" xml:space="preserve">
          <source>The tool should be run from the same server as the subsequent quick install and postConfigure scripts. With no arguments the script will only test the current server. Specify the other servers in the cluster using the &lt;em&gt;--ippaddr&lt;/em&gt; argument to validate those servers are reachable and also configured correctly.</source>
          <target state="translated">이 도구는 후속 빠른 설치 및 postConfigure 스크립트와 동일한 서버에서 실행해야합니다. 인수가 없으면 스크립트는 현재 서버 만 테스트합니다. &lt;em&gt;--ippaddr&lt;/em&gt; 인수를 사용하여 클러스터의 다른 서버를 지정하여 해당 서버에 도달 할 수 있고 올바르게 구성되었는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="47b385b19de00f8ccc8e9398d0bb5d62b75dbbac" translate="yes" xml:space="preserve">
          <source>The tool supports foreign keys for generation of consistent data across multiple tables. It also allows disabling triggers and constraints to avoid interference with database logic.</source>
          <target state="translated">이 도구는 여러 테이블에서 일관된 데이터를 생성하기 위해 외래 키를 지원합니다. 또한 데이터베이스 로직과의 간섭을 피하기 위해 트리거 및 제한 조건을 사용 불가능하게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32941f24285abab82e860f49e1bb5148e31e3753" translate="yes" xml:space="preserve">
          <source>The top part of the GUID/UUID is the bottom part of the current time. The top part is the primary part of what would be used for placing the value in an ordered list (INDEX). This cycles in about 7.16 minutes.</source>
          <target state="translated">GUID / UUID의 상단은 현재 시간의 하단입니다. 상단 부분은 순서 목록 (INDEX)에 값을 배치하는 데 사용되는 주요 부분입니다. 이 과정은 약 7.16 분에 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="17252c2d2164e27eaf5d039be71ab47f2186c374" translate="yes" xml:space="preserve">
          <source>The total length of the partitioning fields is too large</source>
          <target state="translated">분할 필드의 총 길이가 너무 깁니다</target>
        </trans-unit>
        <trans-unit id="69ad911e16ea141bae04aa7cd66b9a77bfd85162" translate="yes" xml:space="preserve">
          <source>The total number of input rows in which both column Y and column X are nonnull</source>
          <target state="translated">Y 열과 X 열이 모두 널이 아닌 총 입력 행 수</target>
        </trans-unit>
        <trans-unit id="ac1611fc456adbcb25f70f41bcd951fe48c0cf86" translate="yes" xml:space="preserve">
          <source>The total number of locks exceeds the lock table size</source>
          <target state="translated">총 잠금 수가 잠금 테이블 크기를 초과합니다</target>
        </trans-unit>
        <trans-unit id="29ef4639dd6fa6edfc13b608dec5b2b648a25acb" translate="yes" xml:space="preserve">
          <source>The total progress of the process (0-100%) (see &lt;a href=&quot;../progress-reporting/index&quot;&gt;Progress Reporting&lt;/a&gt;).</source>
          <target state="translated">프로세스의 전체 진행률 (0-100 %) ( &lt;a href=&quot;../progress-reporting/index&quot;&gt;진행보고&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="9c348bbc6038fb82c92ce70708d051a2688820c0" translate="yes" xml:space="preserve">
          <source>The total_score column represents a running total of the current row, and all previous rows. The window frame in this example expands as the function proceeds.</source>
          <target state="translated">total_score 열은 현재 행과 모든 이전 행의 누계를 나타냅니다. 이 예제의 창 프레임은 기능이 진행됨에 따라 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="436dbec48a3a734727e4e8ba223367e79cfe57a0" translate="yes" xml:space="preserve">
          <source>The total_usage() procedure gives a total disk usage summary for all the columns in ColumnStore with the exception of the columns used for internal maintenance. It is executed using the following query:</source>
          <target state="translated">total_usage () 프로시 저는 내부 유지 보수에 사용 된 열을 제외하고 ColumnStore의 모든 열에 대한 총 디스크 사용량 요약을 제공합니다. 다음 쿼리를 사용하여 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="961737adb4362b8bed9f5a2553c850133ecf261d" translate="yes" xml:space="preserve">
          <source>The transaction coordinator log (tc_log) can be used to recover prepared XA...</source>
          <target state="translated">트랜잭션 조정자 로그 (tc_log)를 사용하여 준비된 XA를 복구 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb0ea38327655415a70e9891ae01098c3ce0a12c" translate="yes" xml:space="preserve">
          <source>The transaction coordinator log (tc_log) is used to coordinate transactions that affect multiple &lt;a href=&quot;../xa-transactions/index&quot;&gt;XA-capable&lt;/a&gt;&lt;a href=&quot;../storage-engines/index&quot;&gt;storage engines&lt;/a&gt;. If you have two or more XA-capable storage engines enabled, then a transaction coordinator log must be available.</source>
          <target state="translated">트랜잭션 코디네이터 로그 (tc_log)는 여러 &lt;a href=&quot;../xa-transactions/index&quot;&gt;XA 가능 &lt;/a&gt;&lt;a href=&quot;../storage-engines/index&quot;&gt;스토리지 엔진에&lt;/a&gt; 영향을 미치는 트랜잭션을 조정하는 데 사용됩니다 . 둘 이상의 XA 가능 스토리지 엔진이 사용 가능한 경우 트랜잭션 조정자 로그를 사용할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="c56865d694126197b3683e0b831c3cc2776b3a27" translate="yes" xml:space="preserve">
          <source>The transaction coordinator log (tc_log) is used to coordinate transactions that affect multiple &lt;a href=&quot;../xa-transactions/index&quot;&gt;XA-capable&lt;/a&gt;&lt;a href=&quot;../storage-engines/index&quot;&gt;storage engines&lt;/a&gt;. One of the main purposes of this log is in crash recovery.</source>
          <target state="translated">트랜잭션 코디네이터 로그 (tc_log)는 여러 &lt;a href=&quot;../xa-transactions/index&quot;&gt;XA 가능 &lt;/a&gt;&lt;a href=&quot;../storage-engines/index&quot;&gt;스토리지 엔진에&lt;/a&gt; 영향을 미치는 트랜잭션을 조정하는 데 사용됩니다 . 이 로그의 주요 목적 중 하나는 응급 복구입니다.</target>
        </trans-unit>
        <trans-unit id="e868b51c9f01e6c7964adb24346750bbcbbf27eb" translate="yes" xml:space="preserve">
          <source>The transaction coordinator log (tc_log) is used to coordinate transactions...</source>
          <target state="translated">트랜잭션 조정자 로그 (tc_log)는 트랜잭션을 조정하는 데 사용됩니다 ...</target>
        </trans-unit>
        <trans-unit id="7e6b231f9097c2831bfc0987ebd9622d0a4c2e75" translate="yes" xml:space="preserve">
          <source>The trickiest part will be the last changes to this file. You need to tell mariadb to use only one cnf file. In the &lt;strong&gt;start&lt;/strong&gt; section after &lt;strong&gt;$bindir/mysqld_safe&lt;/strong&gt; add &lt;strong&gt;--defaults-file=/opt/mariadb-data/my.cnf&lt;/strong&gt;. Finally the lines should look like:</source>
          <target state="translated">가장 어려운 부분은이 파일의 마지막 변경입니다. 하나의 cnf 파일 만 사용하도록 mariadb에 지시해야합니다. 에서 &lt;strong&gt;시작&lt;/strong&gt; 후 섹션 &lt;strong&gt;$ BINDIR / mysqld_safe에의&lt;/strong&gt; 추가 &lt;strong&gt;--defaults-파일 = / 옵션 / mariadb 데이터 / my.cnf 파일&lt;/strong&gt; . 마지막으로 줄은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="12a9181ad2a59c9528a64a440aa090f824e159ff" translate="yes" xml:space="preserve">
          <source>The trigger has:</source>
          <target state="translated">트리거에는 다음이 있습니다.</target>
        </trans-unit>
        <trans-unit id="65a431212f1284ebfb3eed42ddbc05fab890c756" translate="yes" xml:space="preserve">
          <source>The true power of regular expressions is unleashed when the above is combined, to form more complex examples. Regular expression's reputation for complexity stems from the seeming complexity of multiple combined regular expressions, when in reality, it's simply a matter of understanding the characters and how they apply:</source>
          <target state="translated">더 복잡한 예제를 만들기 위해 위의 내용을 결합하면 정규 표현식의 진정한 힘이 발휘됩니다. 복잡성에 대한 정규 표현식의 명성은 여러 조합 된 정규 표현식이 복잡해 보이는 것에서 비롯됩니다. 실제로 문자를 이해하고 적용하는 방법은 단순히 문제입니다.</target>
        </trans-unit>
        <trans-unit id="eac35ee56a4fa4e3aa490013caf5fc80006d9f43" translate="yes" xml:space="preserve">
          <source>The two best algorithms differ in whether they show duplicates.</source>
          <target state="translated">두 가지 최고의 알고리즘은 중복을 표시하는지 여부가 다릅니다.</target>
        </trans-unit>
        <trans-unit id="ba2652b2bfa11fa4fac8e6703101d095ee580317" translate="yes" xml:space="preserve">
          <source>The two broad categories of CONNECT tables</source>
          <target state="translated">CONNECT 테이블의 두 가지 범주</target>
        </trans-unit>
        <trans-unit id="dcb9687624b591117bee21394443c6ad05e5a834" translate="yes" xml:space="preserve">
          <source>The two geometries intersect</source>
          <target state="translated">두 도형이 교차</target>
        </trans-unit>
        <trans-unit id="4f7f557845fd2d2d34ed5ce3ea5ca1391060dc05" translate="yes" xml:space="preserve">
          <source>The two main optimizer switches - &lt;em&gt;materialization&lt;/em&gt; and &lt;em&gt;in_to_exists&lt;/em&gt; cannot be simultaneously off. If both are set to off, the server will issue an error.</source>
          <target state="translated">&lt;em&gt;materialization&lt;/em&gt; 과 &lt;em&gt;in_to_exists&lt;/em&gt; 의 두 가지 주요 옵티 마이저 스위치 는 동시에 끌 수 없습니다. 둘 다 off로 설정되면 서버에서 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ed9292cda814ee417b46f616d2a177873c37488d" translate="yes" xml:space="preserve">
          <source>The two primary non-semi-join strategies are materialization (also called outside-in materialization), and in-to-exists transformation. Materialization is applicable only for non-correlated subqueries, while in-to-exist can be used both for correlated and non-correlated subqueries.</source>
          <target state="translated">두 가지 주요 비-세미-조인 전략은 구체화 (외부 구체화라고도 함)와 존재하는 변형입니다. 구체화는 상관되지 않은 서브 쿼리에만 적용 할 수있는 반면, 존재하는 것은 상관되어있는 서브 쿼리와 상관되지 않은 서브 쿼리 모두에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc72e0b5e250f2d6f5532e53b9dc84c30768a061" translate="yes" xml:space="preserve">
          <source>The two standard row-level locks are &lt;em&gt;share locks&lt;/em&gt;(S) and &lt;em&gt;exclusive locks&lt;/em&gt;(X).</source>
          <target state="translated">두 개의 표준 행 레벨 잠금은 &lt;em&gt;공유 잠금&lt;/em&gt; (S) 및 &lt;em&gt;독점 잠금&lt;/em&gt; (X)입니다.</target>
        </trans-unit>
        <trans-unit id="d59c090865ce628853179ca458e8bbb796e9dd4c" translate="yes" xml:space="preserve">
          <source>The two-letter AM/PM abbreviation (that is, AM is entered as &quot;AM&quot;).</source>
          <target state="translated">두 문자 AM / PM 약어 (AM은 &quot;AM&quot;으로 입력 됨)</target>
        </trans-unit>
        <trans-unit id="6eefcd4ed65f3678ade48069f696f8ae49d98471" translate="yes" xml:space="preserve">
          <source>The type can be one of the following values:</source>
          <target state="translated">유형은 다음 값 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb0a62618720df06451bb460800323b71d743bae" translate="yes" xml:space="preserve">
          <source>The type for all the condition properties is VARCHAR(64), except for MYSQL_ERRNO, whose valid range is 1 to 65534.</source>
          <target state="translated">유효한 조건이 1-65534 인 MYSQL_ERRNO를 제외하고 모든 조건 특성의 유형은 VARCHAR (64)입니다.</target>
        </trans-unit>
        <trans-unit id="a7dcb3f5170ed33d4db4a540c7810071736b0934" translate="yes" xml:space="preserve">
          <source>The type is &lt;em&gt;const&lt;/em&gt;, which means that only one possible result could be returned. Now, returning the same record but searching by their phone number:</source>
          <target state="translated">유형은 &lt;em&gt;const&lt;/em&gt; 이므로 가능한 결과는 하나만 반환 될 수 있습니다. 이제 동일한 레코드를 반환하지만 전화 번호로 검색합니다.</target>
        </trans-unit>
        <trans-unit id="1860eb3bf4b2db311648fca387e761349c7074ec" translate="yes" xml:space="preserve">
          <source>The type of MariaDB's column must match the validation_class of Cassandra's rowkey (datatype matching is covered in more detail below).</source>
          <target state="translated">MariaDB의 열 유형은 Cassandra 행 키의 validation_class와 일치해야합니다 (데이터 유형 일치는 아래에서 자세히 설명합니다).</target>
        </trans-unit>
        <trans-unit id="3a9ceb04af5b00a12fa60da3e19cbd89eb62339f" translate="yes" xml:space="preserve">
          <source>The type of compression (either &quot;None&quot; or &quot;Snappy&quot;)</source>
          <target state="translated">압축 유형 ( &quot;None&quot;또는 &quot;Snappy&quot;)</target>
        </trans-unit>
        <trans-unit id="e460b75cdc5a86d5fb25c52a7146094fbfda572b" translate="yes" xml:space="preserve">
          <source>The types must be mapped as follows:</source>
          <target state="translated">유형은 다음과 같이 맵핑되어야합니다.</target>
        </trans-unit>
        <trans-unit id="8beb97a31f664f2d08f06d619af7c31a2bb8dc2c" translate="yes" xml:space="preserve">
          <source>The typical use case would be that there exists tables that after some time would become fairly inactive, but are still important so that they can not be removed. In that case, an option is to move such a table to an archiving service, which is accessible through an S3 API.</source>
          <target state="translated">일반적인 사용 사례는 일정 시간이 지나면 상당히 비활성 상태이지만 제거 할 수 없도록 여전히 중요한 테이블이 존재한다는 것입니다. 이 경우 S3 API를 통해 액세스 할 수있는 보관 서비스로 이러한 테이블을 이동하는 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c800b35cd71fd70c75a9fc6e09114111bd157c4b" translate="yes" xml:space="preserve">
          <source>The uncompressed data size for the extent calculated as (HWM + 1) * BLOCK_SIZE</source>
          <target state="translated">(HWM + 1) * BLOCK_SIZE로 계산 된 범위의 압축되지 않은 데이터 크기</target>
        </trans-unit>
        <trans-unit id="b142b83102a3dcd66e04e91e1417259df4ac20b0" translate="yes" xml:space="preserve">
          <source>The undo log is not a log file that can be viewed on disk in the usual sense, such as the &lt;a href=&quot;../error-log/index&quot;&gt;error log&lt;/a&gt; or &lt;a href=&quot;../slow-query-log/index&quot;&gt;slow query log&lt;/a&gt;, rather an area of storage.</source>
          <target state="translated">실행 취소 로그는 &lt;a href=&quot;../error-log/index&quot;&gt;오류 로그&lt;/a&gt; 또는 &lt;a href=&quot;../slow-query-log/index&quot;&gt;느린 쿼리 로그&lt;/a&gt; 와 같은 일반적인 의미에서 디스크에서 볼 수있는 로그 파일이 아니라 저장 영역입니다.</target>
        </trans-unit>
        <trans-unit id="6e397cb00fc535ca528e0c47d4974c0c65a0ba79" translate="yes" xml:space="preserve">
          <source>The undo log is usually part of the physical system tablespace, but from &lt;a href=&quot;../what-is-mariadb-100/index&quot;&gt;MariaDB 10.0&lt;/a&gt;, the &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_undo_directory&quot;&gt;innodb_undo_directory&lt;/a&gt; and &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_undo_tablespaces&quot;&gt;innodb_undo_tablespaces&lt;/a&gt; system variables can be used to split into different tablespaces and store in a different location (perhaps on a different storage device).</source>
          <target state="translated">언두 로그는 일반적으로 실제 시스템 테이블의 일부이지만에서 &lt;a href=&quot;../what-is-mariadb-100/index&quot;&gt;MariaDB 10.0&lt;/a&gt; 상기 &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_undo_directory&quot;&gt;innodb_undo_directory&lt;/a&gt; 및 &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_undo_tablespaces&quot;&gt;innodb_undo_tablespaces&lt;/a&gt; 시스템 변수는 (아마도 다른 저장 장치)의 다른 위치에서 다른 테이블로 분리하고 저장하는 데 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="bceb58146d6e397939b612c04da416e17eda3ae9" translate="yes" xml:space="preserve">
          <source>The unhashed form of the digest.</source>
          <target state="translated">해시되지 않은 형태의 다이제스트.</target>
        </trans-unit>
        <trans-unit id="354eb286137203f91f5c5f35ac03471825215275" translate="yes" xml:space="preserve">
          <source>The uninstall script for 1.1.6 requires root access to perform some operations. These operations are the following:</source>
          <target state="translated">1.1.6의 설치 제거 스크립트는 일부 조작을 수행하기 위해 루트 액세스 권한이 필요합니다. 이러한 작업은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7a30d163e548adef5496f6a4b7e56e14cbfb5129" translate="yes" xml:space="preserve">
          <source>The uninstall script for 1.1.7 requires root access to perform some operations. These operations are the following:</source>
          <target state="translated">1.1.7의 설치 제거 스크립트는 일부 조작을 수행하기 위해 루트 액세스 권한이 필요합니다. 이러한 작업은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="684b49e359a614ec90c22b558e0936bc00f486f6" translate="yes" xml:space="preserve">
          <source>The uninstall script for 1.2.x requires root access to perform some operations. These operations are the following:</source>
          <target state="translated">1.2.x의 설치 제거 스크립트는 일부 조작을 수행하기 위해 루트 액세스 권한이 필요합니다. 이러한 작업은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2d70dbd8eabd7f1ae87b048ec8ce06a82bac16e7" translate="yes" xml:space="preserve">
          <source>The unit value may be specified using one of keywords as shown, or with a prefix of SQL_TSI_. For example, DAY and SQL_TSI_DAY both are legal.</source>
          <target state="translated">단위 값은 표시된 키워드 중 하나를 사용하거나 접두어 SQL_TSI_를 사용하여 지정할 수 있습니다. 예를 들어, DAY와 SQL_TSI_DAY는 모두 합법적입니다.</target>
        </trans-unit>
        <trans-unit id="6c714a98a8ef74baaa534059d501db7feccb697a" translate="yes" xml:space="preserve">
          <source>The update log is deprecated and replaced by the binary log; SET SQL_LOG_UPDATE has been ignored. This option will be removed in &lt;a href=&quot;../what-is-mariadb-56/index&quot;&gt;MariaDB 5.6&lt;/a&gt;.</source>
          <target state="translated">업데이트 로그는 더 이상 사용되지 않으며 이진 로그로 대체됩니다. SET SQL_LOG_UPDATE가 무시되었습니다. 이 옵션은 &lt;a href=&quot;../what-is-mariadb-56/index&quot;&gt;MariaDB 5.6&lt;/a&gt; 에서 제거됩니다 .</target>
        </trans-unit>
        <trans-unit id="51c4bda12cbc585b3df4f76b3223b832b7fa4d89" translate="yes" xml:space="preserve">
          <source>The update log is deprecated and replaced by the binary log; SET SQL_LOG_UPDATE has been translated to SET SQL_LOG_BIN. This option will be removed in &lt;a href=&quot;../what-is-mariadb-56/index&quot;&gt;MariaDB 5.6&lt;/a&gt;.</source>
          <target state="translated">업데이트 로그는 더 이상 사용되지 않으며 이진 로그로 대체됩니다. SET SQL_LOG_UPDATE가 SET SQL_LOG_BIN으로 변환되었습니다. 이 옵션은 &lt;a href=&quot;../what-is-mariadb-56/index&quot;&gt;MariaDB 5.6&lt;/a&gt; 에서 제거됩니다 .</target>
        </trans-unit>
        <trans-unit id="f1f1e5316f854038ee91895e029127aaebf2490c" translate="yes" xml:space="preserve">
          <source>The upgrade instructions:</source>
          <target state="translated">업그레이드 지침 :</target>
        </trans-unit>
        <trans-unit id="e0d9e1a6bb570268f17b7258a6858f10b974f991" translate="yes" xml:space="preserve">
          <source>The upgraded versions of dbForge Schema Compare for MySQL, dbForge Data Compare for MySQL, dbForge Query Builder for MySQL and dbForge Data Generator for MySQL are provided with Syntax Check that supports new &lt;a href=&quot;../what-is-mariadb-100/index&quot;&gt;MariaDB 10.0&lt;/a&gt; - 10.1 statements, also additional SQL statements are supported and other improvements were made.</source>
          <target state="translated">업그레이드 된 버전의 dbForge Schema Compare for MySQL, dbForge Data Compare for MySQL, dbForge Query Builder for MySQL 및 dbForge Data Generator for MySQL은 새로운 &lt;a href=&quot;../what-is-mariadb-100/index&quot;&gt;MariaDB 10.0-10.1&lt;/a&gt; 명령문 을 지원하는 구문 검사와 함께 제공되며 추가 SQL 문도 지원되며 기타 개선 사항이 있습니다. 만들어졌다.</target>
        </trans-unit>
        <trans-unit id="fd28f5fe5e429d64468e799e536ef9eea375af10" translate="yes" xml:space="preserve">
          <source>The usable size of the first page is smaller because of the log header. There is a PAGE control structure for each page.</source>
          <target state="translated">첫 번째 페이지의 사용 가능한 크기는 로그 헤더로 인해 더 작습니다. 각 페이지마다 PAGE 제어 구조가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f38f3022c6a12bfdec5df1dc4a54da0fee74348" translate="yes" xml:space="preserve">
          <source>The usage of dynamic replication filters changes somewhat when &lt;a href=&quot;../multi-source-replication/index&quot;&gt;multi-source replication&lt;/a&gt; is in use. By default, the variables are addressed to the default connection, so in a multi-source environment, the required connection needs to be specified. There are two ways to do this.</source>
          <target state="translated">&lt;a href=&quot;../multi-source-replication/index&quot;&gt;다중 소스 복제&lt;/a&gt; 를 사용중인 경우 동적 복제 필터의 사용법이 약간 변경됩니다 . 기본적으로 변수는 기본 연결로 지정되므로 다중 소스 환경에서는 필요한 연결을 지정해야합니다. 이를 수행하는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="02de740a90d0e2d9256c0e3bb6363d7d7113af58" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;LOW_PRIORITY&lt;/code&gt; or &lt;code&gt;HIGH_PRIORITY&lt;/code&gt; for an &lt;code&gt;INSERT&lt;/code&gt; prevents &lt;a href=&quot;../concurrent-inserts/index&quot;&gt;Concurrent Inserts&lt;/a&gt; from being used.</source>
          <target state="translated">&lt;code&gt;INSERT&lt;/code&gt; 에 &lt;code&gt;LOW_PRIORITY&lt;/code&gt; 또는 &lt;code&gt;HIGH_PRIORITY&lt;/code&gt; 를 사용 하면 &lt;a href=&quot;../concurrent-inserts/index&quot;&gt;동시 삽입&lt;/a&gt; 을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7aec7470f45a19e2a6c3f6b12e99b62fe52b6fe9" translate="yes" xml:space="preserve">
          <source>The use of aggregate functions is not allowed. RETURNING cannot be used in multi-table DELETEs.</source>
          <target state="translated">집계 함수는 사용할 수 없습니다. 다중 테이블 DELETE에는 RETURNING을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="19231a11b2bb9f9eeea68cfdfbb314689699f1f9" translate="yes" xml:space="preserve">
          <source>The use of integer latches is controlled using the &lt;a href=&quot;../oqgraph-system-and-status-variables/index#oqgraph_allow_create_integer_latch&quot;&gt;oqgraph_allow_create_integer_latch&lt;/a&gt; system variable.</source>
          <target state="translated">정수 래치의 사용은 &lt;a href=&quot;../oqgraph-system-and-status-variables/index#oqgraph_allow_create_integer_latch&quot;&gt;oqgraph_allow_create_integer_latch&lt;/a&gt; 시스템 변수를 사용하여 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="4b7fbce9fc82b69b06c05cc87f4bf1955a62f6e9" translate="yes" xml:space="preserve">
          <source>The use of the CONNECT engine requires the &lt;code&gt;&lt;a href=&quot;../grant/index#global-privileges&quot;&gt;FILE&lt;/a&gt;&lt;/code&gt; privilege for &lt;a href=&quot;../inward-and-outward-tables/index#outward-tables&quot;&gt;&quot;outward&quot;&lt;/a&gt; tables. This should not be an important restriction. The use of CONNECT &quot;outward&quot; tables on a remote server seems of limited interest without knowing the files existing on it and must be protected anyway. On the other hand, using it on the local client machine is not an issue because it is always possible to create locally a user with the &lt;code&gt;FILE&lt;/code&gt; privilege.</source>
          <target state="translated">CONNECT 엔진을 사용하려면 &lt;a href=&quot;../inward-and-outward-tables/index#outward-tables&quot;&gt;&quot;외부&quot;&lt;/a&gt; 테이블에 대한 &lt;code&gt;&lt;a href=&quot;../grant/index#global-privileges&quot;&gt;FILE&lt;/a&gt;&lt;/code&gt; 특권이 필요합니다 . 이것은 중요한 제한이되어서는 안됩니다. 원격 서버에서 CONNECT &quot;외부&quot;테이블을 사용하는 것은 기존 파일에 대해 알지 못하고 제한적인 것으로 보이며 어쨌든 보호해야합니다. 반면, &lt;code&gt;FILE&lt;/code&gt; 권한을 가진 사용자를 항상 로컬로 작성할 수 있으므로 로컬 클라이언트 시스템에서이를 사용하는 것은 문제가되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="fbc4470cce33cbd5881fa6c44b8e719f502e2b40" translate="yes" xml:space="preserve">
          <source>The use of the temporary tablespaces in InnoDB was introduced in &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt;. In earlier versions, temporary tablespaces exist as part of the InnoDB &lt;a href=&quot;../innodb-system-tablespaces/index&quot;&gt;system&lt;/a&gt; tablespace or were file-per-table depending on the configuration of the &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_file_per_table&quot;&gt;innodb_file_per_table&lt;/a&gt;&lt;/code&gt; system variable.</source>
          <target state="translated">InnoDB에서 임시 테이블 스페이스 사용은 &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt; 에서 도입되었습니다 . 이전 버전에서는 임시 테이블 스페이스가 InnoDB &lt;a href=&quot;../innodb-system-tablespaces/index&quot;&gt;시스템&lt;/a&gt; 테이블 스페이스의 일부로 존재 하거나 &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_file_per_table&quot;&gt;innodb_file_per_table&lt;/a&gt;&lt;/code&gt; 시스템 변수 의 구성에 따라 테이블 당 파일이었습니다 .</target>
        </trans-unit>
        <trans-unit id="eb3bb9bdaaefdd0a70e4f440e6178ed4b4d9b5d1" translate="yes" xml:space="preserve">
          <source>The used &lt;code&gt;HAVING&lt;/code&gt; clause is always false so the &lt;code&gt;SELECT&lt;/code&gt; will return no rows.</source>
          <target state="translated">사용 된 &lt;code&gt;HAVING&lt;/code&gt; 절은 항상 false이므로 &lt;code&gt;SELECT&lt;/code&gt; 는 행을 리턴하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="828e807b8edeb6541869e496884d51562a115a9f" translate="yes" xml:space="preserve">
          <source>The used &lt;code&gt;WHERE&lt;/code&gt; clause is always false so the &lt;code&gt;SELECT&lt;/code&gt; will return no rows. For example: &lt;code&gt;WHERE 1=2&lt;/code&gt;</source>
          <target state="translated">사용 된 &lt;code&gt;WHERE&lt;/code&gt; 절은 항상 false이므로 &lt;code&gt;SELECT&lt;/code&gt; 는 행을 리턴하지 않습니다. 예를 들면 다음과 같습니다. &lt;code&gt;WHERE 1=2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="56413a291d846da7a2a0d8f66bc658dd07681472" translate="yes" xml:space="preserve">
          <source>The used &lt;code&gt;WHERE&lt;/code&gt; clause is always false so the &lt;code&gt;SELECT&lt;/code&gt; will return no rows. This case was detected after we had read all 'const' tables and used the column values as constant in the &lt;code&gt;WHERE&lt;/code&gt; clause. For example: &lt;code&gt;WHERE const_column=5&lt;/code&gt; and &lt;code&gt;const_column&lt;/code&gt; had a value of 4.</source>
          <target state="translated">사용 된 &lt;code&gt;WHERE&lt;/code&gt; 절은 항상 false이므로 &lt;code&gt;SELECT&lt;/code&gt; 는 행을 리턴하지 않습니다. 이 사례는 모든 'const'테이블을 읽은 후 &lt;code&gt;WHERE&lt;/code&gt; 절 에서 열 값을 상수로 사용한 후에 감지되었습니다 . 예를 들면 다음 과 &lt;code&gt;const_column&lt;/code&gt; &lt;code&gt;WHERE const_column=5&lt;/code&gt; 이고 const_column 의 값은 4입니다.</target>
        </trans-unit>
        <trans-unit id="8b560f13e8f1cc766a50767365591f43d6a2779f" translate="yes" xml:space="preserve">
          <source>The used SELECT statements have a different number of columns</source>
          <target state="translated">사용 된 SELECT 문의 열 수가 다릅니다</target>
        </trans-unit>
        <trans-unit id="4584fc0f9ea064520783208c859d174a3a4dd880" translate="yes" xml:space="preserve">
          <source>The used command is not allowed with this MariaDB version</source>
          <target state="translated">이 MariaDB 버전에서는 사용 된 명령을 사용할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="ca64827472fde5893e969f194d543af56ef03034" translate="yes" xml:space="preserve">
          <source>The used storage engine can't index column '%s'</source>
          <target state="translated">사용 된 스토리지 엔진이 열 '% s'을 (를) 인덱싱 할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="ea66022d09327e0057299ebd435898ada59fea76" translate="yes" xml:space="preserve">
          <source>The used table type doesn't support AUTO_INCREMENT columns</source>
          <target state="translated">사용 된 테이블 유형은 AUTO_INCREMENT 컬럼을 지원하지 않습니다</target>
        </trans-unit>
        <trans-unit id="b484e2e7bab7bc89ef6625e8d7a7ab9efa965c65" translate="yes" xml:space="preserve">
          <source>The used table type doesn't support BLOB/TEXT columns</source>
          <target state="translated">사용 된 테이블 유형이 BLOB / TEXT 열을 지원하지 않습니다</target>
        </trans-unit>
        <trans-unit id="341882deffbd7e6b3b0487886e74783c385baab0" translate="yes" xml:space="preserve">
          <source>The used table type doesn't support FULLTEXT indexes</source>
          <target state="translated">사용 된 테이블 유형은 FULLTEXT 인덱스를 지원하지 않습니다</target>
        </trans-unit>
        <trans-unit id="16f47b7af3d353581bad89ad54db0d4678e97f5f" translate="yes" xml:space="preserve">
          <source>The used table type doesn't support SPATIAL indexes</source>
          <target state="translated">사용 된 테이블 유형은 SPATIAL 인덱스를 지원하지 않습니다</target>
        </trans-unit>
        <trans-unit id="6ac37b8aa53882edc77bdaf8267ebda4a597c862" translate="yes" xml:space="preserve">
          <source>The user accesses data in MariaDB (think of a website and a query like:</source>
          <target state="translated">사용자는 MariaDB의 데이터에 액세스합니다 (웹 사이트 및 다음과 같은 쿼리를 생각하십시오).</target>
        </trans-unit>
        <trans-unit id="77388f173571bb6e5cef15418c53e109a52f8389" translate="yes" xml:space="preserve">
          <source>The user account information can also be specified in a supported &lt;a href=&quot;#client-option-groups&quot;&gt;client option group&lt;/a&gt; in an &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;option file&lt;/a&gt;. For example:</source>
          <target state="translated">&lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;옵션 파일&lt;/a&gt; 의 지원되는 &lt;a href=&quot;#client-option-groups&quot;&gt;클라이언트 옵션 그룹&lt;/a&gt; 에서 사용자 계정 정보를 지정할 수도 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8e47f0ad9d20b6109fbecab2fabdc91a746262fc" translate="yes" xml:space="preserve">
          <source>The user account information can be specified with the &lt;code&gt;-user&lt;/code&gt; and &lt;code&gt;--password&lt;/code&gt; command-line options. For example:</source>
          <target state="translated">사용자 계정 정보는 &lt;code&gt;-user&lt;/code&gt; 및 &lt;code&gt;--password&lt;/code&gt; 명령 행 옵션 으로 지정할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e92915ff7c466383178c06884069bdee00667ae8" translate="yes" xml:space="preserve">
          <source>The user account information can be specified with the &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-user&quot;&gt;--user&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-p-password&quot;&gt;--password&lt;/a&gt;&lt;/code&gt; command-line options. For example:</source>
          <target state="translated">사용자 계정 정보는 &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-user&quot;&gt;--user&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-p-password&quot;&gt;--password&lt;/a&gt;&lt;/code&gt; 명령 줄 옵션 으로 지정할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9230676efb5be5ba418a3a07858560aa1ed00b68" translate="yes" xml:space="preserve">
          <source>The user account that performs the backup for the SST needs to have &lt;a href=&quot;../mariabackup-overview/index#authentication-and-privileges&quot;&gt;the same privileges as Mariabackup&lt;/a&gt;, which are the &lt;code&gt;RELOAD&lt;/code&gt; , &lt;code&gt;PROCESS&lt;/code&gt;, &lt;code&gt;LOCK TABLES&lt;/code&gt; and &lt;code&gt;REPLICATION CLIENT&lt;/code&gt;&lt;a href=&quot;../grant/index#global-privileges&quot;&gt;global privileges&lt;/a&gt;. To be safe, you should ensure that these privileges are set on each node in your cluster. &lt;a href=&quot;../backup-restore-and-import-clients-mariadb-backup/index&quot;&gt;Mariabackup&lt;/a&gt; connects locally on the donor node to perform the backup, so the following user should be sufficient:</source>
          <target state="translated">해수면 온도에 대한 수행 백업이 있어야하는 사용자 계정 &lt;a href=&quot;../mariabackup-overview/index#authentication-and-privileges&quot;&gt;Mariabackup과 같은 권한&lt;/a&gt; 있으며, &lt;code&gt;RELOAD&lt;/code&gt; , &lt;code&gt;PROCESS&lt;/code&gt; , &lt;code&gt;LOCK TABLES&lt;/code&gt; 및 &lt;code&gt;REPLICATION CLIENT&lt;/code&gt; &lt;a href=&quot;../grant/index#global-privileges&quot;&gt;글로벌 권한을&lt;/a&gt; . 안전을 위해 이러한 권한이 클러스터의 각 노드에 설정되어 있는지 확인해야합니다. &lt;a href=&quot;../backup-restore-and-import-clients-mariadb-backup/index&quot;&gt;Mariabackup&lt;/a&gt; 은 기증자 노드에서 로컬로 연결하여 백업을 수행하므로 다음 사용자로 충분합니다.</target>
        </trans-unit>
        <trans-unit id="4b77a92880402b3824579e6abafb2d67793d0a3f" translate="yes" xml:space="preserve">
          <source>The user account that performs the backup for the SST needs to have &lt;a href=&quot;../percona-xtrabackup-overview/index#authentication-and-privileges&quot;&gt;the same privileges as Percona XtraBackup&lt;/a&gt;, which are the &lt;code&gt;RELOAD&lt;/code&gt; , &lt;code&gt;PROCESS&lt;/code&gt;, &lt;code&gt;LOCK TABLES&lt;/code&gt; and &lt;code&gt;REPLICATION CLIENT&lt;/code&gt;&lt;a href=&quot;../grant/index#global-privileges&quot;&gt;global privileges&lt;/a&gt;. To be safe, you should ensure that these privileges are set on each node in your cluster. &lt;a href=&quot;../backup-restore-and-import-clients-percona-xtrabackup/index&quot;&gt;Percona XtraBackup&lt;/a&gt; connects locally on the donor node to perform the backup, so the following user should be sufficient:</source>
          <target state="translated">SST에 대한 백업을 수행하는 사용자 계정 &lt;a href=&quot;../percona-xtrabackup-overview/index#authentication-and-privileges&quot;&gt;에는 Percona XtraBackup과 동일한 권한 ( &lt;/a&gt; &lt;code&gt;RELOAD&lt;/code&gt; , &lt;code&gt;PROCESS&lt;/code&gt; , &lt;code&gt;LOCK TABLES&lt;/code&gt; 및 &lt;code&gt;REPLICATION CLIENT&lt;/code&gt; &lt;a href=&quot;../grant/index#global-privileges&quot;&gt;글로벌 권한)&lt;/a&gt; 이 있어야합니다 . 안전을 위해 이러한 권한이 클러스터의 각 노드에 설정되어 있는지 확인해야합니다. &lt;a href=&quot;../backup-restore-and-import-clients-percona-xtrabackup/index&quot;&gt;Percona XtraBackup&lt;/a&gt; 은 기증자 노드에서 로컬로 연결하여 백업을 수행하므로 다음 사용자로 충분합니다.</target>
        </trans-unit>
        <trans-unit id="02ec7853eedfee579bba9676ef5d4c4dd9f90e5c" translate="yes" xml:space="preserve">
          <source>The user account will be referred to as &amp;lt;USER&amp;gt; within this document.</source>
          <target state="translated">이 문서에서는 사용자 계정을 &amp;lt;USER&amp;gt;라고합니다.</target>
        </trans-unit>
        <trans-unit id="ea51010fd922f62ce9467b153cbd282d65031eac" translate="yes" xml:space="preserve">
          <source>The user account would have to have the same name as the operating system user account that is running the &lt;code&gt;mysqld&lt;/code&gt; process. On many systems, this is the user account configured as the &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-user&quot;&gt;user&lt;/a&gt;&lt;/code&gt; option, and it tends to default to &lt;code&gt;mysql&lt;/code&gt;.</source>
          <target state="translated">사용자 계정은 &lt;code&gt;mysqld&lt;/code&gt; 프로세스를 실행하는 운영 체제 사용자 계정과 이름이 같아야 합니다. 많은 시스템에서 이것은 &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-user&quot;&gt;user&lt;/a&gt;&lt;/code&gt; 옵션으로 구성된 사용자 계정 이며 기본값은 &lt;code&gt;mysql&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fedd1095aaf03eab65734e40fc7614a353adae5e" translate="yes" xml:space="preserve">
          <source>The user and password ColumnStore will run as should be consistent across all nodes. MariaDB ColumnStore can be installed as root or an unprivileged user.</source>
          <target state="translated">사용자와 비밀번호 ColumnStore는 모든 노드에서 일관성이 있어야합니다. MariaDB ColumnStore는 루트 또는 권한이없는 사용자로 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="162397540f1011e70349ad28e3efcd3c03c92d4d" translate="yes" xml:space="preserve">
          <source>The user can choose to change these settings after the install is completed if for instance, they want to set up more memory for Joins to utilize. On a single server or combined UM/PM server, it is recommended to not have the combination of these 2 settings over 75% of total memory</source>
          <target state="translated">예를 들어, 조인에 사용할 메모리를 더 많이 설정하려는 경우 설치가 완료된 후 사용자가이 설정을 변경하도록 선택할 수 있습니다. 단일 서버 또는 결합 된 UM / PM 서버에서는 총 메모리의 75 % 이상에서이 두 설정을 조합하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6b75bbb956618456dcb91022b3c510e6ec97b970" translate="yes" xml:space="preserve">
          <source>The user can choose to change these settings after the install is completed, if for instance they want to setup more memory for Joins to utilize. On a single server or combined UM/PM server, it is recommended to not have the combination of these 2 settings over 75% of total memory</source>
          <target state="translated">예를 들어 조인에 사용할 메모리를 추가로 설정하려는 경우 설치가 완료된 후 이러한 설정을 변경하도록 선택할 수 있습니다. 단일 서버 또는 결합 된 UM / PM 서버에서는 총 메모리의 75 % 이상에서이 두 설정을 조합하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b63c836d48146ad5d1f8b693aff90594edbd0f71" translate="yes" xml:space="preserve">
          <source>The user can choose to change these settings after the install is completed, if for instance they want to setup more memory for Joins to utilize. On a single server or combined UM/PM server, it is recommended to not have the combination of these 2 settings over 75% of total memory.</source>
          <target state="translated">예를 들어 조인에 사용할 메모리를 추가로 설정하려는 경우 설치가 완료된 후 이러한 설정을 변경하도록 선택할 수 있습니다. 단일 서버 또는 결합 된 UM / PM 서버에서는 총 메모리의 75 %가 넘는이 두 설정을 조합하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="738b51be6c1905d0b5a5976d51c43ce7f44cf359" translate="yes" xml:space="preserve">
          <source>The user can define time intervals that divide the range 0 to positive infinity into smaller intervals and then collect the number of commands whose execution times fall into each of those intervals.</source>
          <target state="translated">사용자는 0에서 양의 무한대 범위를 더 작은 간격으로 나누는 시간 간격을 정의한 다음 실행 시간이 각 간격에 해당하는 명령 수를 수집 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66a1afd2c0681c52acd7bfe51bf7a7c40141b8a2" translate="yes" xml:space="preserve">
          <source>The user has a column-level privilege on any table in the query</source>
          <target state="translated">사용자는 쿼리의 모든 테이블에 대한 열 수준 권한을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="5901d89b80b0b7e785511deb5b0b736cb59d370b" translate="yes" xml:space="preserve">
          <source>The user is responsible for converting to/from the calling datatype (BINARY(16)) when accessing the stored routine; suggest &lt;a href=&quot;../inet6_aton/index&quot;&gt;INET6_ATON&lt;/a&gt;/&lt;a href=&quot;../inet6_ntoa/index&quot;&gt;INET6_NTOA&lt;/a&gt;.</source>
          <target state="translated">사용자는 저장된 루틴에 액세스 할 때 호출 데이터 유형 (BINARY (16))으로 /에서 변환 할 책임이 있습니다. &lt;a href=&quot;../inet6_aton/index&quot;&gt;INET6_ATON&lt;/a&gt; / &lt;a href=&quot;../inet6_ntoa/index&quot;&gt;INET6_NTOA를&lt;/a&gt; 제안 하십시오 .</target>
        </trans-unit>
        <trans-unit id="a6e7c3948dabdc7ffdd0e01736a2c29f3dc7955d" translate="yes" xml:space="preserve">
          <source>The user is responsible for converting to/from the calling datatype (INT UNSIGNED) when accessing the stored routine; suggest &lt;a href=&quot;../inet_aton/index&quot;&gt;INET_ATON&lt;/a&gt;/&lt;a href=&quot;../inet_ntoa/index&quot;&gt;INET_NTOA&lt;/a&gt;.</source>
          <target state="translated">저장된 루틴에 액세스 할 때 사용자는 호출 데이터 유형 (INT UNSIGNED)으로 /에서 변환 할 책임이 있습니다. &lt;a href=&quot;../inet_aton/index&quot;&gt;INET_ATON&lt;/a&gt; / &lt;a href=&quot;../inet_ntoa/index&quot;&gt;INET_NTOA를&lt;/a&gt; 제안 하십시오 .</target>
        </trans-unit>
        <trans-unit id="4b44878e625adbb42cb64f2b72c01df00ae322e5" translate="yes" xml:space="preserve">
          <source>The user issues an SQL statement against the local federatedX table. This statement is parsed into an item tree</source>
          <target state="translated">사용자는 로컬 federatedX 테이블에 대해 SQL 문을 발행합니다. 이 문장은 아이템 트리로 파싱됩니다.</target>
        </trans-unit>
        <trans-unit id="686f9594f44a2558945a1001f7ee4ae513b6e9a3" translate="yes" xml:space="preserve">
          <source>The user name and host name may be unquoted, quoted as strings using double quotes (&lt;code&gt;&quot;&lt;/code&gt;) or single quotes (&lt;code&gt;'&lt;/code&gt;), or quoted as identifiers using backticks (&lt;code&gt;`&lt;/code&gt;). You must use quotes when using special characters (such as a hyphen) or wildcard characters. If you quote, you must quote the user name and host name separately (for example &lt;code&gt;'user_name'@'host_name'&lt;/code&gt;).</source>
          <target state="translated">사용자 이름과 호스트 이름은 인용 부호가 붙 거나 큰 따옴표 ( &lt;code&gt;&quot;&lt;/code&gt; ) 또는 작은 따옴표 ( &lt;code&gt;'&lt;/code&gt; )를 사용하는 문자열 또는 따옴표 ( &lt;code&gt;`&lt;/code&gt; )를 사용하는 식별자로 인용 될 수 있습니다. 특수 문자 (예 : 하이픈)를 사용할 때는 따옴표를 사용해야합니다. 인용 부호 인 경우 사용자 이름과 호스트 이름을 따로 인용해야합니다 (예 : &lt;code&gt;'user_name'@'host_name'&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="3f8be8b3f8708c00c3328e5b11b7c4b73ded47fb" translate="yes" xml:space="preserve">
          <source>The user name of the MariaDB account to use when invoking &lt;a href=&quot;../mysqladmin/index&quot;&gt;mysqladmin&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../mysqladmin/index&quot;&gt;mysqladmin을&lt;/a&gt; 호출 할 때 사용할 MariaDB 계정의 사용자 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="ecfeaa0367db6bca8dc7fbfc361f44bc757f74b4" translate="yes" xml:space="preserve">
          <source>The user specified as a definer ('%s'@'%s') does not exist</source>
          <target state="translated">정의 자로 지정된 사용자 ( '% s'@ '% s')가 존재하지 않습니다</target>
        </trans-unit>
        <trans-unit id="2d9a79d7d91112a5381685bb5fdf50f8e77bd934" translate="yes" xml:space="preserve">
          <source>The username associated with the process.</source>
          <target state="translated">프로세스와 연관된 사용자 이름입니다.</target>
        </trans-unit>
        <trans-unit id="f014ad0edff9b99acb80304fb776e5864128723d" translate="yes" xml:space="preserve">
          <source>The username. The value &lt;code&gt;'#mysql_system_user#'&lt;/code&gt; appears when there is no username (such as for the slave SQL thread).</source>
          <target state="translated">사용자 이름 사용자 이름이없는 경우 (예 : 슬레이브 SQL 스레드의 경우) &lt;code&gt;'#mysql_system_user#'&lt;/code&gt; 값이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="ef4db1376194f19be6e71b631aca4cd0e6c209dd" translate="yes" xml:space="preserve">
          <source>The usual lifecycle of a page is pool-&amp;gt;active-&amp;gt;syncing-&amp;gt;pool.</source>
          <target state="translated">페이지의 일반적인 라이프 사이클은 풀-&amp;gt; 활성-&amp;gt; 동기화-&amp;gt; 풀입니다.</target>
        </trans-unit>
        <trans-unit id="abb57b73780d348a6730ed64351f7aca02c15f95" translate="yes" xml:space="preserve">
          <source>The value (#) of slave_parallel_threads specifies how many threads will be created in a pool of worker threads used to apply events in parallel for *all* your slaves (this includes &lt;a href=&quot;../multi-source-replication/index&quot;&gt;multi-source replication&lt;/a&gt;). If the value is zero, then no worker threads are created, and old-style replication is used where events are applied inside the SQL thread. Usually the value, if non-zero, should be at least two times the number of multi-source master connections used. It makes little sense to use only a single worker thread for one connection; this will incur some overhead in inter-thread communication between the SQL thread and the worker thread, but with just a single worker thread events can not be applied in parallel anyway.</source>
          <target state="translated">slave_parallel_threads의 값 (#)은 슬레이브의 * all *에 대해 이벤트를 병렬로 적용하는 데 사용되는 작업자 스레드 풀에서 생성 될 스레드 수를 지정합니다 (여러 &lt;a href=&quot;../multi-source-replication/index&quot;&gt;소스 복제 포함&lt;/a&gt; ). 값이 0이면 작업자 스레드가 생성되지 않고 SQL 스레드 내부에서 이벤트가 적용되는 구식 복제가 사용됩니다. 일반적으로 0이 아닌 경우 값은 사용 된 다중 소스 마스터 연결 수의 두 배 이상이어야합니다. 하나의 연결에 단일 작업자 스레드 만 사용하는 것은 의미가 없습니다. 이로 인해 SQL 스레드와 작업자 스레드 간의 스레드 간 통신에 약간의 오버 헤드가 발생하지만 단일 작업자 스레드 이벤트만으로는 병렬로 적용 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="81faa2edf0bda769fcd2baa64154a69875acff3a" translate="yes" xml:space="preserve">
          <source>The value 2 can be used when dealing with files created by another application with no header. The value 3 makes sometimes inserting in the file faster than when the header is at the beginning of the file.</source>
          <target state="translated">헤더없이 다른 응용 프로그램에서 만든 파일을 처리 할 때 값 2를 사용할 수 있습니다. 값이 3이면 헤더가 파일의 시작 부분에있을 때보 다 파일에 더 빨리 삽입되는 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b726cd82e3f8c8ee6b0ae3d699da62e8ae06e28e" translate="yes" xml:space="preserve">
          <source>The value can also be changed dynamically. For example:</source>
          <target state="translated">값을 동적으로 변경할 수도 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9e7363930ebb3e59610198e4a333f961cc7cbd09" translate="yes" xml:space="preserve">
          <source>The value can be set globally or per session, as well as per user or per query (see below). Slave's are not affected by this variable.</source>
          <target state="translated">값은 전체 또는 세션, 사용자 또는 쿼리별로 설정할 수 있습니다 (아래 참조). 슬레이브는이 변수의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0e49599fbee40cb1b7d3ae3572a03be577c54f79" translate="yes" xml:space="preserve">
          <source>The value displayed in the &lt;code&gt;TIME&lt;/code&gt; and &lt;code&gt;TIME_MS&lt;/code&gt; columns is the period of time that the given thread has been in its current state. Thus it can be used to check for example how long a thread has been executing the current query, or for how long it has been idle.</source>
          <target state="translated">&lt;code&gt;TIME&lt;/code&gt; 및 &lt;code&gt;TIME_MS&lt;/code&gt; 열에 표시되는 값 은 주어진 스레드가 현재 상태 인 기간입니다. 따라서 예를 들어 스레드가 현재 쿼리를 실행 한 시간 또는 유휴 상태 인 시간을 확인하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34137ebbb9ab7f40bfb0148ee0fc8c88dbb64470" translate="yes" xml:space="preserve">
          <source>The value evaluated at the row that is offset rows before the current row within the partition; if there is no such row, instead return default. Both offset and default are evaluated with respect to the current row. If omitted, offset defaults to 1 and default to null. LAG provides access to more than one row of a table at the same time without a self-join. Given a series of rows returned from a query and a position of the cursor, LAG provides access to a row at a given physical offset prior to that position.</source>
          <target state="translated">파티션 내 현재 행 앞의 오프셋 행인 행에서 평가 된 값. 그러한 행이 없으면 대신 기본값을 반환하십시오. 오프셋과 기본값은 현재 행과 관련하여 평가됩니다. 생략하면 오프셋의 기본값은 1이고 기본값은 null입니다. LAG는 자체 조인없이 동시에 하나 이상의 테이블 행에 대한 액세스를 제공합니다. 쿼리에서 반환 된 일련의 행과 커서 위치가 주어지면 LAG는 해당 위치 이전에 지정된 물리적 오프셋에서 행에 대한 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9060fc1ac4797eed5cfd33b5138f468e3f56ea2c" translate="yes" xml:space="preserve">
          <source>The value evaluated at the row that is the first row of the window frame (counting from 1); null if no such row.</source>
          <target state="translated">창 프레임의 첫 번째 행인 행에서 평가 된 값 (1부터 계산). 그러한 행이없는 경우는 null</target>
        </trans-unit>
        <trans-unit id="10afee1fa8c827bf215fc3e9159309a4fc75a3a0" translate="yes" xml:space="preserve">
          <source>The value evaluated at the row that is the last row of the window frame (counting from 1); null if no such row.</source>
          <target state="translated">창 프레임의 마지막 행인 행에서 평가 된 값 (1부터 계산). 그러한 행이없는 경우는 null</target>
        </trans-unit>
        <trans-unit id="6213086de4cdc9c76748b5021e72d1b07b4b114e" translate="yes" xml:space="preserve">
          <source>The value evaluated at the row that is the nth row of the window frame (counting from 1); null if no such row.</source>
          <target state="translated">창 프레임의 n 번째 행인 행에서 평가 된 값 (1부터 계산). 그러한 행이없는 경우는 null</target>
        </trans-unit>
        <trans-unit id="bd440c9e9ada59cfa63069baa4755749c99b3948" translate="yes" xml:space="preserve">
          <source>The value for user-id must be the same for all nodes.</source>
          <target state="translated">user-id의 값은 모든 노드에서 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="851224347965371497be16e5f9a54f7f7fc43524" translate="yes" xml:space="preserve">
          <source>The value given for the city column (explicitly or by default) will be used by the partition engine to decide in which partition to insert the rows. It will be ignored by CONNECT (a special column cannot be given a value) but later will return the matching value. For instance:</source>
          <target state="translated">도시 열에 제공된 값 (명시 적으로 또는 기본적으로)은 파티션 엔진에서 행을 삽입 할 파티션을 결정하는 데 사용됩니다. CONNECT (특수 컬럼에는 값을 제공 할 수 없음)에 의해 무시되지만 나중에 일치하는 값을 리턴합니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="68044dd6584dbf857bc2df9773c8711328b0328c" translate="yes" xml:space="preserve">
          <source>The value is a list of engine names, separated by commas (','). Replication of transactions using these engines will automatically create new versions of the mysql.gtid_slave_pos table in the same engine and use that for future transactions (table creation takes place in a background thread). This avoids introducing a cross-engine transaction to update the GTID position. Only transactional storage engines are supported for gtid_pos_auto_engines (this currently means &lt;a href=&quot;../innodb/index&quot;&gt;InnoDB&lt;/a&gt;, &lt;a href=&quot;../tokudb/index&quot;&gt;TokuDB&lt;/a&gt;, or &lt;a href=&quot;../myrocks/index&quot;&gt;MyRocks&lt;/a&gt;).</source>
          <target state="translated">값은 쉼표 ( ',')로 구분 된 엔진 이름 목록입니다. 이러한 엔진을 사용하여 트랜잭션을 복제하면 동일한 엔진에 mysql.gtid_slave_pos 테이블의 새 버전이 자동으로 생성되어 향후 트랜잭션에 사용됩니다 (테이블 작성은 백그라운드 스레드에서 수행됨). 이것은 GTID 위치를 업데이트하기 위해 교차 엔진 트랜잭션을 도입하지 않도록합니다. gtid_pos_auto_engines에는 현재 트랜잭션 스토리지 엔진 만 지원됩니다 (현재 &lt;a href=&quot;../innodb/index&quot;&gt;InnoDB&lt;/a&gt; , &lt;a href=&quot;../tokudb/index&quot;&gt;TokuDB&lt;/a&gt; 또는 &lt;a href=&quot;../myrocks/index&quot;&gt;MyRocks를&lt;/a&gt; 의미 함 ).</target>
        </trans-unit>
        <trans-unit id="8a6c233c0ae296d99a44fd12d2bfa3ed59db8772" translate="yes" xml:space="preserve">
          <source>The value is a numeric percentage value between 0 and 100. To disable a particular threshold use value 0. To disable a threshold alarm, set it to 0.</source>
          <target state="translated">값은 0과 100 사이의 숫자 백분율 값입니다. 특정 임계 값을 비활성화하려면 값 0을 사용하십시오. 임계 값 경보를 비활성화하려면 0으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="b6cd6dbd53149cebf8f2d516176b2a8e584a5318" translate="yes" xml:space="preserve">
          <source>The value is out of the TIMESTAMP range, so no conversion takes place:</source>
          <target state="translated">값이 TIMESTAMP 범위를 벗어 났으므로 변환이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1a42a4edc26dde5c2fe349bd150e8fef370ac783" translate="yes" xml:space="preserve">
          <source>The value is read-only, but it is updated whenever a DML or DDL statement is written to the binary log. The value can be reset by executing &lt;a href=&quot;../reset-master/index&quot;&gt;RESET MASTER&lt;/a&gt;, which will also delete all binary logs. However, note that &lt;a href=&quot;../reset-master/index&quot;&gt;RESET MASTER&lt;/a&gt; does not also reset &lt;a href=&quot;#gtid_slave_pos&quot;&gt;gtid_slave_pos&lt;/a&gt;. Since &lt;a href=&quot;#gtid_current_pos&quot;&gt;gtid_current_pos&lt;/a&gt; is the union of &lt;a href=&quot;#gtid_slave_pos&quot;&gt;gtid_slave_pos&lt;/a&gt; and &lt;code&gt;gtid_binlog_pos&lt;/code&gt;, that means that new GTIDs added to &lt;code&gt;gtid_binlog_pos&lt;/code&gt; can lag behind those in &lt;a href=&quot;#gtid_current_pos&quot;&gt;gtid_current_pos&lt;/a&gt; if &lt;a href=&quot;#gtid_slave_pos&quot;&gt;gtid_slave_pos&lt;/a&gt; contains GTIDs in the same domain with higher sequence numbers. If you want to reset &lt;a href=&quot;#gtid_current_pos&quot;&gt;gtid_current_pos&lt;/a&gt; for a specific GTID domain in cases like this, then you will also have to change &lt;a href=&quot;#gtid_slave_pos&quot;&gt;gtid_slave_pos&lt;/a&gt; in addition to executing &lt;a href=&quot;../reset-master/index&quot;&gt;RESET MASTER&lt;/a&gt;. See &lt;a href=&quot;#gtid_slave_pos&quot;&gt;gtid_slave_pos&lt;/a&gt; for notes on how to change its value.</source>
          <target state="translated">값은 읽기 전용이지만 DML 또는 DDL 문이 이진 로그에 기록 될 때마다 업데이트됩니다. &lt;a href=&quot;../reset-master/index&quot;&gt;RESET MASTER&lt;/a&gt; 를 실행하여 값을 재설정 할 수 있으며 모든 바이너리 로그도 삭제됩니다. 그러나 &lt;a href=&quot;../reset-master/index&quot;&gt;RESET MASTER&lt;/a&gt; 는 &lt;a href=&quot;#gtid_slave_pos&quot;&gt;gtid_slave_pos&lt;/a&gt; 도 재설정하지 않습니다 . 이후 &lt;a href=&quot;#gtid_current_pos&quot;&gt;gtid_current_pos&lt;/a&gt; 의 조합입니다 &lt;a href=&quot;#gtid_slave_pos&quot;&gt;gtid_slave_pos&lt;/a&gt; 및 &lt;code&gt;gtid_binlog_pos&lt;/code&gt; 수단에 추가 된 새 GTIDs 있다는 것을, &lt;code&gt;gtid_binlog_pos&lt;/code&gt; 가 에서 그 뒤쳐 수 &lt;a href=&quot;#gtid_current_pos&quot;&gt;gtid_current_pos&lt;/a&gt; 경우 &lt;a href=&quot;#gtid_slave_pos&quot;&gt;gtid_slave_pos가&lt;/a&gt; 높은 순서 번호와 동일한 도메인에 GTIDs이 포함되어 있습니다. &lt;a href=&quot;#gtid_current_pos&quot;&gt;gtid_current_pos&lt;/a&gt; 를 재설정하려는 경우이와 같은 경우 특정 GTID 도메인의 경우 &lt;a href=&quot;../reset-master/index&quot;&gt;RESET MASTER&lt;/a&gt; 실행 외에도 &lt;a href=&quot;#gtid_slave_pos&quot;&gt;gtid_slave_pos&lt;/a&gt; 를 변경해야합니다 . 값을 변경하는 방법에 대한 참고 사항 은 &lt;a href=&quot;#gtid_slave_pos&quot;&gt;gtid_slave_pos&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4a9a8393689e37b57581733d06c10e255f483a18" translate="yes" xml:space="preserve">
          <source>The value is returned as a string of 40 hex digits, or NULL if the argument was NULL. As of &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt;, the return value is a nonbinary string in the connection &lt;a href=&quot;../data-types-character-sets-and-collations/index&quot;&gt;character set and collation&lt;/a&gt;, determined by the values of the &lt;a href=&quot;../server-system-variables/index#character_set_connection&quot;&gt;character_set_connection&lt;/a&gt; and &lt;a href=&quot;../server-system-variables/index#collation_connection&quot;&gt;collation_connection&lt;/a&gt; system variables. Before 5.5, the return value was a binary string.</source>
          <target state="translated">값은 40 16 진 숫자의 문자열로 리턴되거나 인수가 NULL 인 경우 NULL로 리턴됩니다. 현재 &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt; , 반환 값은 접속에 이진이 아닌 문자열 &lt;a href=&quot;../data-types-character-sets-and-collations/index&quot;&gt;의 문자 세트 및 정렬&lt;/a&gt; 의 값에 의해 결정 &lt;a href=&quot;../server-system-variables/index#character_set_connection&quot;&gt;character_set_connection을&lt;/a&gt; 하고 &lt;a href=&quot;../server-system-variables/index#collation_connection&quot;&gt;이 collation_connection의&lt;/a&gt; 시스템 변수. 5.5 이전에는 반환 값이 이진 문자열이었습니다.</target>
        </trans-unit>
        <trans-unit id="0c772957279782f53160cfdf9ee723ada98d44e1" translate="yes" xml:space="preserve">
          <source>The value of '%s' should be no less than the value of '%s'</source>
          <target state="translated">'% s'의 값은 '% s'의 값보다 작아서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="e2b04363c2e886cdd9644e856755e6db31fcd2ca" translate="yes" xml:space="preserve">
          <source>The value of &lt;a href=&quot;../server-system-variables/index#error_count&quot;&gt;error_count&lt;/a&gt; might be greater than the number of messages displayed by &lt;a href=&quot;../show-warnings/index&quot;&gt;SHOW WARNINGS&lt;/a&gt; if the &lt;a href=&quot;../server-system-variables/index#max_error_count&quot;&gt;max_error_count&lt;/a&gt; system variable is set so low that not all messages are stored.</source>
          <target state="translated">&lt;a href=&quot;../server-system-variables/index#max_error_count&quot;&gt;max_error_count&lt;/a&gt; 시스템 변수가 너무 낮게 설정되어 모든 메시지가 저장되지 않는 경우 &lt;a href=&quot;../server-system-variables/index#error_count&quot;&gt;error_count&lt;/a&gt; 값은 &lt;a href=&quot;../show-warnings/index&quot;&gt;SHOW WARNINGS에&lt;/a&gt; 표시되는 메시지 수보다 클 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d5e93a467293b3a543399607e6453bb36aef6e99" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#warning_count&quot;&gt;warning_count&lt;/a&gt;&lt;/code&gt; might be greater than the number of messages displayed by &lt;code&gt;SHOW WARNINGS&lt;/code&gt; if the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#max_error_count&quot;&gt;max_error_count&lt;/a&gt;&lt;/code&gt; system variable is set so low that not all messages are stored.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../server-system-variables/index#max_error_count&quot;&gt;max_error_count&lt;/a&gt;&lt;/code&gt; 시스템 변수가 너무 낮게 설정되어 모든 메시지가 저장되지 않는 경우 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#warning_count&quot;&gt;warning_count&lt;/a&gt;&lt;/code&gt; 값은 &lt;code&gt;SHOW WARNINGS&lt;/code&gt; 에 표시되는 메시지 수보다 클 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e3ad086516e964fd29c9a04e3a2b056d060d2f86" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;UUID_SHORT()&lt;/code&gt; is guaranteed to be unique if the following conditions hold:</source>
          <target state="translated">다음 조건이 충족되는 경우 &lt;code&gt;UUID_SHORT()&lt;/code&gt; 값은 고유해야합니다.</target>
        </trans-unit>
        <trans-unit id="226ca8075fa5c040093c2202b5f2ef5b61f9f760" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;gtid_current_pos&lt;/code&gt; is read-only, but it is updated whenever a DML or DDL statement is written to the binary log and/or replicated by a slave thread. If you need to reset the value, see the notes on resetting &lt;code&gt;&lt;a href=&quot;#gtid_slave_pos&quot;&gt;gtid_slave_pos&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#gtid_binlog_pos&quot;&gt;gtid_binlog_pos&lt;/a&gt;&lt;/code&gt;, since &lt;code&gt;gtid_current_pos&lt;/code&gt; is formed from the values of those variables.</source>
          <target state="translated">&lt;code&gt;gtid_current_pos&lt;/code&gt; 의 값 은 읽기 전용이지만 DML 또는 DDL 문이 이진 로그에 기록되거나 슬레이브 스레드에 의해 복제 될 때마다 업데이트됩니다. 당신이 값을 다시 설정해야하는 경우, 재설정에 노트를 참조 &lt;code&gt;&lt;a href=&quot;#gtid_slave_pos&quot;&gt;gtid_slave_pos&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#gtid_binlog_pos&quot;&gt;gtid_binlog_pos&lt;/a&gt;&lt;/code&gt; 을 하기 때문에, &lt;code&gt;gtid_current_pos&lt;/code&gt; 이 그 변수의 값 형성된다.</target>
        </trans-unit>
        <trans-unit id="e9407d90cc2d70a9cffe7d714a294a178652ff20" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;master_use_gtid&lt;/code&gt; is saved across server restarts (in master.info). The current value can be seen as the field Using_Gtid in the output of SHOW SLAVE STATUS.</source>
          <target state="translated">&lt;code&gt;master_use_gtid&lt;/code&gt; 의 값은 서버를 다시 시작할 때 (master.info에) 저장됩니다. 현재 값은 SHOW SLAVE STATUS 출력에서 ​​Using_Gtid 필드로 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9b384607b4b0da097f74962dd98bd6e98f3fec2" translate="yes" xml:space="preserve">
          <source>The value of @@GLOBAL.GTID_MODE can only change one step at a time: OFF &amp;lt;-&amp;gt; UPGRADE_STEP_1 &amp;lt;-&amp;gt; UPGRADE_STEP_2 &amp;lt;-&amp;gt; ON. Also note that this value must be stepped up or down simultaneously on all servers; see the Manual for instructions.</source>
          <target state="translated">@@ GLOBAL.GTID_MODE의 값은 한 번에 한 단계 만 변경할 수 있습니다. OFF &amp;lt;-&amp;gt; UPGRADE_STEP_1 &amp;lt;-&amp;gt; UPGRADE_STEP_2 &amp;lt;-&amp;gt; ON. 또한이 값은 모든 서버에서 동시에 단계적으로 증가 또는 감소해야합니다. 지침은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d6941cec082410dc43f3782f106621ea1feeba20" translate="yes" xml:space="preserve">
          <source>The value of @@gtid_binlog_state is preserved by the server across restarts by writing a file MASTER-BIN.state, where MASTER-BIN is the base name of the binlog set with the --log-bin option. This file is written at server shutdown, and re-read at next server start. (In case of a server crash, the data in the MASTER-BIN.state is not correct, and the server instead recovers the correct value during binlog crash recovery by scanning the binlog files and recording each GTID found).</source>
          <target state="translated">@@ gtid_binlog_state의 값은 MASTER-BIN.state 파일을 작성하여 다시 시작하는 동안 서버에 의해 보존됩니다. 여기서 MASTER-BIN은 --log-bin 옵션으로 설정된 binlog의 기본 이름입니다. 이 파일은 서버 종료시 작성되며 다음 서버 시작시 다시 읽습니다. (서버 충돌의 경우, MASTER-BIN.state의 데이터가 올바르지 않으며, 대신 서버는 binlog 파일을 스캔하고 발견 된 각 GTID를 기록하여 binlog 충돌 복구 중에 올바른 값을 복구합니다).</target>
        </trans-unit>
        <trans-unit id="4d98c2c800f4a2f46053fba0ac851045127e2218" translate="yes" xml:space="preserve">
          <source>The value of CURRENT_USER() can differ from the value of &lt;a href=&quot;../user/index&quot;&gt;USER()&lt;/a&gt;. &lt;code&gt;&lt;a href=&quot;../current_role/index&quot;&gt;CURRENT_ROLE()&lt;/a&gt;&lt;/code&gt; returns the current active role.</source>
          <target state="translated">CURRENT_USER () 값은 &lt;a href=&quot;../user/index&quot;&gt;USER ()&lt;/a&gt; 값과 다를 수 있습니다 . &lt;code&gt;&lt;a href=&quot;../current_role/index&quot;&gt;CURRENT_ROLE()&lt;/a&gt;&lt;/code&gt; 은 현재 활성 역할을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="cf9833b14fcd4ef5a1251f0dbb680a0f01286f8f" translate="yes" xml:space="preserve">
          <source>The value of LAST_INSERT_ID() will be consistent across all versions if all rows in the &lt;a href=&quot;../insert/index&quot;&gt;INSERT&lt;/a&gt; or &lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt; statement were successful.</source>
          <target state="translated">&lt;a href=&quot;../insert/index&quot;&gt;INSERT&lt;/a&gt; 또는 &lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt; 문의 모든 행 이 성공한 경우 LAST_INSERT_ID ()의 값은 모든 버전에서 일관됩니다 .</target>
        </trans-unit>
        <trans-unit id="a072cae90edc68abfe233c1bb7df7a07fe318504" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;fs.nr_open&lt;/code&gt; parameter can be changed permanently by setting the value in &lt;code&gt;&lt;a href=&quot;https://linux.die.net/man/5/sysctl.conf&quot;&gt;/etc/sysctl.conf&lt;/a&gt;&lt;/code&gt; and restarting the server.</source>
          <target state="translated">의 값 &lt;code&gt;fs.nr_open&lt;/code&gt; 매개 변수의 값을 설정하여 영구적으로 변경할 수 있습니다 &lt;code&gt;&lt;a href=&quot;https://linux.die.net/man/5/sysctl.conf&quot;&gt;/etc/sysctl.conf&lt;/a&gt;&lt;/code&gt; 에을 하고 서버를 다시 시작.</target>
        </trans-unit>
        <trans-unit id="5bb2583c1a53bee6776a933e423da36169220309" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;fs.nr_open&lt;/code&gt; parameter can be changed temporarily by executing the &lt;code&gt;&lt;a href=&quot;https://linux.die.net/man/8/sysctl&quot;&gt;sysctl&lt;/a&gt;&lt;/code&gt; utility. For example:</source>
          <target state="translated">&lt;code&gt;fs.nr_open&lt;/code&gt; 매개 변수 의 값은 &lt;code&gt;&lt;a href=&quot;https://linux.die.net/man/8/sysctl&quot;&gt;sysctl&lt;/a&gt;&lt;/code&gt; 유틸리티 를 실행하여 임시로 변경할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="96043c4a60d21c8b390efa8a98571e8c5465625e" translate="yes" xml:space="preserve">
          <source>The value of this system variable is constructed from the values of the &lt;code&gt;&lt;a href=&quot;#gtid_binlog_pos&quot;&gt;gtid_binlog_pos&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#gtid_slave_pos&quot;&gt;gtid_slave_pos&lt;/a&gt;&lt;/code&gt; system variables. It gets GTIDs of transactions executed locally from the value of the &lt;code&gt;&lt;a href=&quot;#gtid_binlog_pos&quot;&gt;gtid_binlog_pos&lt;/a&gt;&lt;/code&gt; system variable. It gets GTIDs of replicated transactions from the value of the &lt;code&gt;&lt;a href=&quot;#gtid_slave_pos&quot;&gt;gtid_slave_pos&lt;/a&gt;&lt;/code&gt; system variable.</source>
          <target state="translated">이 시스템 변수의 값은 &lt;code&gt;&lt;a href=&quot;#gtid_binlog_pos&quot;&gt;gtid_binlog_pos&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#gtid_slave_pos&quot;&gt;gtid_slave_pos&lt;/a&gt;&lt;/code&gt; 시스템 변수 의 값으로 구성됩니다 . &lt;code&gt;&lt;a href=&quot;#gtid_binlog_pos&quot;&gt;gtid_binlog_pos&lt;/a&gt;&lt;/code&gt; 시스템 변수 값에서 로컬로 실행 된 트랜잭션의 GTID를 가져옵니다 . &lt;code&gt;&lt;a href=&quot;#gtid_slave_pos&quot;&gt;gtid_slave_pos&lt;/a&gt;&lt;/code&gt; 시스템 변수 값에서 복제 된 트랜잭션의 GTID를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="5f0089db56f96bde10a168f7dbda0a728ad9f345" translate="yes" xml:space="preserve">
          <source>The value returned by &lt;code&gt;TIME_TO_SEC&lt;/code&gt; is of type &lt;code&gt;&lt;a href=&quot;../double/index&quot;&gt;DOUBLE&lt;/a&gt;&lt;/code&gt;. Before &lt;a href=&quot;../what-is-mariadb-53/index&quot;&gt;MariaDB 5.3&lt;/a&gt; (and MySQL 5.6), the type was &lt;code&gt;&lt;a href=&quot;../int/index&quot;&gt;INT&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;../microseconds-in-mariadb/index&quot;&gt;Microseconds in MariaDB&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;TIME_TO_SEC&lt;/code&gt; 에 의해 리턴 된 값 은 &lt;code&gt;&lt;a href=&quot;../double/index&quot;&gt;DOUBLE&lt;/a&gt;&lt;/code&gt; 유형 입니다. 전에 &lt;a href=&quot;../what-is-mariadb-53/index&quot;&gt;MariaDB 5.3&lt;/a&gt; (와 MySQL 5.6), 유형이었다 &lt;code&gt;&lt;a href=&quot;../int/index&quot;&gt;INT&lt;/a&gt;&lt;/code&gt; . &lt;a href=&quot;../microseconds-in-mariadb/index&quot;&gt;MariaDB의 마이크로 초를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e9d7d37a846288ece1135f67ce8d09b1eee5cd44" translate="yes" xml:space="preserve">
          <source>The value specified for computed column '%s' in table '%s' ignored</source>
          <target state="translated">테이블 '% s'의 계산 열 '% s'에 지정된 값이 무시되었습니다.</target>
        </trans-unit>
        <trans-unit id="c0bc388c2f03ce85f031bbbb4c5120d89800a870" translate="yes" xml:space="preserve">
          <source>The values are written in the following format:</source>
          <target state="translated">값은 다음 형식으로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="d0c607b87c89102790cddf7652802c3c8dc0c697" translate="yes" xml:space="preserve">
          <source>The values in this field are only guaranteed to be consistent with the backup if the &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-no-lock&quot;&gt;--no-lock&lt;/a&gt;&lt;/code&gt; option was &lt;strong&gt;not&lt;/strong&gt; provided when the backup was taken.</source>
          <target state="translated">이 필드의 값은 백업을 수행 할 때 &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-no-lock&quot;&gt;--no-lock&lt;/a&gt;&lt;/code&gt; 옵션을 제공 &lt;strong&gt;하지 않은&lt;/strong&gt; 경우에만 백업과 일치하도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="f0bffd583e0b0f9834ba16e20ff846f70bdeb637" translate="yes" xml:space="preserve">
          <source>The values in this file are only guaranteed to be consistent with the backup if the &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-no-lock&quot;&gt;--no-lock&lt;/a&gt;&lt;/code&gt; option was &lt;strong&gt;not&lt;/strong&gt; provided when the backup was taken.</source>
          <target state="translated">이 파일의 값은 백업을 수행 할 때 &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-no-lock&quot;&gt;--no-lock&lt;/a&gt;&lt;/code&gt; 옵션을 제공 &lt;strong&gt;하지 않은&lt;/strong&gt; 경우에만 백업과 일치하도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="d051756f81a1526e4b345fb978c4ca045b81ca24" translate="yes" xml:space="preserve">
          <source>The values of the &lt;a href=&quot;#master_log_file&quot;&gt;MASTER_LOG_FILE&lt;/a&gt; and &lt;a href=&quot;#master_log_pos&quot;&gt;MASTER_LOG_POS&lt;/a&gt; options (i.e. the &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt; position on the master) and most other options are written to either the default &lt;code&gt;master.info&lt;/code&gt; file or the file that is configured by the &lt;a href=&quot;../mysqld-options/index#-master-info-file&quot;&gt;master_info_file&lt;/a&gt; option. The &lt;a href=&quot;../replication-threads/index#slave-io-thread&quot;&gt;slave's I/O thread&lt;/a&gt; keeps this &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt; position updated as it downloads events only when &lt;a href=&quot;#master_use_gtid&quot;&gt;MASTER_USE_GTID&lt;/a&gt; option is set to &lt;code&gt;NO&lt;/code&gt;. Otherwise the file is not updated on a per event basis.</source>
          <target state="translated">&lt;a href=&quot;#master_log_file&quot;&gt;MASTER_LOG_FILE&lt;/a&gt; 및 &lt;a href=&quot;#master_log_pos&quot;&gt;MASTER_LOG_POS&lt;/a&gt; 옵션 의 값 (즉, 마스터 의 &lt;a href=&quot;../binary-log/index&quot;&gt;이진 로그&lt;/a&gt; 위치) 및 대부분의 다른 옵션은 기본 &lt;code&gt;master.info&lt;/code&gt; 파일 또는 &lt;a href=&quot;../mysqld-options/index#-master-info-file&quot;&gt;master_info_file&lt;/a&gt; 옵션으로 구성된 파일에 기록됩니다 . &lt;a href=&quot;../replication-threads/index#slave-io-thread&quot;&gt;슬레이브의 I / O 스레드가&lt;/a&gt; 이 유지 &lt;a href=&quot;../binary-log/index&quot;&gt;바이너리 로그&lt;/a&gt; 는 이벤트 만 다운로드로 업데이트 된 위치를 &lt;a href=&quot;#master_use_gtid&quot;&gt;MASTER_USE_GTID의&lt;/a&gt; 옵션이 설정되어 &lt;code&gt;NO&lt;/code&gt; 를 . 그렇지 않으면 파일이 이벤트별로 업데이트되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dff12faf6fe9a74ee006556703193963b95a3724" translate="yes" xml:space="preserve">
          <source>The values of the &lt;code&gt;&lt;a href=&quot;#relay_log_file&quot;&gt;RELAY_LOG_FILE&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#relay_log_pos&quot;&gt;RELAY_LOG_POS&lt;/a&gt;&lt;/code&gt; options (i.e. the &lt;a href=&quot;../relay-log/index&quot;&gt;relay log&lt;/a&gt; position) are written to either the default &lt;code&gt;relay-log.info&lt;/code&gt; file or the file that is configured by the &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-system-variables/index#relay_log_info_file&quot;&gt;relay_log_info_file&lt;/a&gt;&lt;/code&gt; system variable. The &lt;a href=&quot;../replication-threads/index#slave-sql-thread&quot;&gt;slave's SQL thread&lt;/a&gt; keeps this &lt;a href=&quot;../relay-log/index&quot;&gt;relay log&lt;/a&gt; position updated as it applies events.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#relay_log_file&quot;&gt;RELAY_LOG_FILE&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#relay_log_pos&quot;&gt;RELAY_LOG_POS&lt;/a&gt;&lt;/code&gt; 옵션 의 값 (예 : &lt;a href=&quot;../relay-log/index&quot;&gt;릴레이 로그&lt;/a&gt; 위치)은 기본 &lt;code&gt;relay-log.info&lt;/code&gt; 파일 또는 &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-system-variables/index#relay_log_info_file&quot;&gt;relay_log_info_file&lt;/a&gt;&lt;/code&gt; 시스템 변수로 구성된 파일에 기록됩니다 . &lt;a href=&quot;../replication-threads/index#slave-sql-thread&quot;&gt;슬레이브의 SQL 쓰레드는&lt;/a&gt; 이 유지 &lt;a href=&quot;../relay-log/index&quot;&gt;릴레이 로그&lt;/a&gt; 는 이벤트 적용되는 업데이트 위치를.</target>
        </trans-unit>
        <trans-unit id="1dc5a73746eae6e5732d99d337ae04d03185fe26" translate="yes" xml:space="preserve">
          <source>The values of the INSERT statement must be specified using the standard MariaDB syntax and these values are displayed as MariaDB temporal values. Sure enough, the column formats apply only to the way these values are represented inside the CSV files. Here, the inserted record will be:</source>
          <target state="translated">INSERT 문의 값은 표준 MariaDB 구문을 사용하여 지정해야하며이 값은 MariaDB 시간 값으로 표시됩니다. 확실히, 열 형식은 이러한 값이 CSV 파일 내에 표시되는 방식에만 적용됩니다. 삽입 된 레코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7b0141d7a6bab6103c36c6301a4e9c781e0ce590" translate="yes" xml:space="preserve">
          <source>The values of these variables can be changed by an administrator with the &lt;code&gt;SUPER&lt;/code&gt; privilege, using the &lt;a href=&quot;../set/index&quot;&gt;&lt;code&gt;SET&lt;/code&gt;&lt;/a&gt; statement. Below is an example of how to disable audit logging:</source>
          <target state="translated">이러한 변수의 값은 &lt;a href=&quot;../set/index&quot;&gt; &lt;code&gt;SET&lt;/code&gt; &lt;/a&gt; 문을 사용하여 &lt;code&gt;SUPER&lt;/code&gt; 권한을 가진 관리자가 변경할 수 있습니다 . 다음은 감사 로깅을 비활성화하는 방법의 예입니다.</target>
        </trans-unit>
        <trans-unit id="f7649b50db3e1305cb322b31d34506281d4af40a" translate="yes" xml:space="preserve">
          <source>The values of unknown attributes or attributes with the illegal values cause an error by default. But with &lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt; one can change the storage engine and some previously valid attributes may become unknown &amp;mdash; to the new engine. They are not removed automatically, though, because the table might be altered back to the first engine, and these attributes will be valid again. Still &lt;a href=&quot;../show-create-table/index&quot;&gt;SHOW CREATE TABLE&lt;/a&gt; will comment these unknown attributes out in the output, otherwise they would make a generated &lt;a href=&quot;../create-table/index&quot;&gt;CREATE TABLE&lt;/a&gt; statement invalid.</source>
          <target state="translated">알 수없는 속성 값 또는 잘못된 값을 갖는 속성은 기본적으로 오류를 발생시킵니다. 그러나 &lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt; 을 사용하면 스토리지 엔진을 변경할 수 있으며 이전에 유효한 일부 속성이 새 엔진에 알려지지 않을 수 있습니다. 그러나 테이블이 첫 번째 엔진으로 다시 변경 될 수 있으므로 이러한 속성은 자동으로 제거되지 않습니다. 여전히 &lt;a href=&quot;../show-create-table/index&quot;&gt;SHOW CREATE TABLE&lt;/a&gt; 은 출력에서 ​​알 수없는 속성을 주석 처리하고 그렇지 않으면 생성 된 &lt;a href=&quot;../create-table/index&quot;&gt;CREATE TABLE&lt;/a&gt; 문을 유효하지 않게합니다.</target>
        </trans-unit>
        <trans-unit id="a82fac6863b89f8edb6a960f3639b1586abe71e7" translate="yes" xml:space="preserve">
          <source>The values stands for the value of each of the key columns. For most key types (except for HASH keys in MEMORY storage engine) you can use a prefix subset of it's columns.</source>
          <target state="translated">값은 각 키 열의 값을 나타냅니다. 대부분의 키 유형 (MEMORY 스토리지 엔진의 HASH 키 제외)의 경우 열의 접두사 서브 세트를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8026f8eb127796466c43b13f5e53462d4f7999e8" translate="yes" xml:space="preserve">
          <source>The variable can be changed dynamically without restarting the server. Setting the variable in any way (even to the existing value) forces a rotation of the &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt; (the intention is to avoid having a single binlog where some events are checksummed and others are not).</source>
          <target state="translated">서버를 다시 시작하지 않고도 변수를 동적으로 변경할 수 있습니다. 어떤 식 으로든 (기존 값으로도) 변수를 설정하면 &lt;a href=&quot;../binary-log/index&quot;&gt;이진 로그가&lt;/a&gt; 강제로 회전합니다 (일부 이벤트는 체크섬되고 다른 이벤트는 그렇지 않은 경우 단일 binlog가 발생하지 않도록하는 것입니다).</target>
        </trans-unit>
        <trans-unit id="0fb90f5087ab8f9de1b99e7c47506969f044bd9d" translate="yes" xml:space="preserve">
          <source>The variable can be changed dynamically, but slave SQL threads should be stopped when changing it, and it will take effect when the slaves are running again.</source>
          <target state="translated">변수는 동적으로 변경 될 수 있지만 변경할 때 슬레이브 SQL 스레드를 중지해야하며 슬레이브가 다시 실행될 때 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="31ad2e1aae76d9214e6fa5abf9f6065276ef8c42" translate="yes" xml:space="preserve">
          <source>The variable gtid_binlog_state holds the internal state of the binlog. The state consists of the last GTID ever logged to the binary log for every combination of domain_id and server_id. This information is used by the master to determine whether a given GTID has been logged to the binlog in the past, even if it has later been deleted due to binlog purge. For each domain_id, the last entry in @@gtid_binlog_state is the last GTID logged into binlog, ie. this is the value that appears in @@gtid_binlog_pos.</source>
          <target state="translated">gtid_binlog_state 변수는 binlog의 내부 상태를 보유합니다. 상태는 domain_id와 server_id의 모든 조합에 대해 이진 로그에 기록 된 마지막 GTID로 구성됩니다. 이 정보는 지정된 GTID가 나중에 binlog 제거로 인해 삭제 된 경우에도 과거에 binlog에 기록되었는지 여부를 판별하는 데 사용됩니다. 각 domain_id에 대해 @@ gtid_binlog_state의 마지막 항목은 binlog에 마지막으로 로그인 한 GTID입니다. 이것은 @@ gtid_binlog_pos에 나타나는 값입니다.</target>
        </trans-unit>
        <trans-unit id="301a88295c3faec78f34621840e7333d9530c29c" translate="yes" xml:space="preserve">
          <source>The variables are:</source>
          <target state="translated">변수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="781084706c0ceca7b4b8ce1cbe8bfa446aa22baa" translate="yes" xml:space="preserve">
          <source>The variables, &lt;a href=&quot;../mariadb-audit-plugin-system-variables/index#server_audit_syslog_ident&quot;&gt;server_audit_syslog_ident&lt;/a&gt; and &lt;a href=&quot;../mariadb-audit-plugin-system-variables/index#server_audit_syslog_info&quot;&gt;server_audit_syslog_info&lt;/a&gt; can be used to identify a system log entry made by the audit plugin. If a remote &lt;code&gt;syslogd&lt;/code&gt; service is used for several MariaDB servers, these same variables are also used to identify the MariaDB server.</source>
          <target state="translated">&lt;a href=&quot;../mariadb-audit-plugin-system-variables/index#server_audit_syslog_ident&quot;&gt;server_audit_syslog_ident&lt;/a&gt; 및 &lt;a href=&quot;../mariadb-audit-plugin-system-variables/index#server_audit_syslog_info&quot;&gt;server_audit_syslog_info&lt;/a&gt; 변수를 사용하여 감사 플러그인이 작성한 시스템 로그 항목을 식별 할 수 있습니다. 원격 &lt;code&gt;syslogd&lt;/code&gt; 서비스가 여러 MariaDB 서버에 사용되는 경우 동일한 변수가 MariaDB 서버를 식별하는 데에도 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="94019bcd236da1aa83af652d1242ec8566807dd7" translate="yes" xml:space="preserve">
          <source>The version of MariaDB Server that was backed up.</source>
          <target state="translated">백업 된 MariaDB 서버의 버전입니다.</target>
        </trans-unit>
        <trans-unit id="eb8587f22aca9dffee1ea013a5f8ff1d0f0b3476" translate="yes" xml:space="preserve">
          <source>The version of Mariabackup that performed the backup.</source>
          <target state="translated">백업을 수행 한 Mariabackup의 버전입니다.</target>
        </trans-unit>
        <trans-unit id="226e3095d47b5299a8e926ae71e2ff5213ae0658" translate="yes" xml:space="preserve">
          <source>The version of MySQL in Debian 8 &quot;Jessie&quot; is 5.5. When installing, most users will install the &lt;code&gt;mysql-server&lt;/code&gt; package, which depends on the &lt;code&gt;mysql-server-5.5 package&lt;/code&gt;. In Debian 9 &quot;Stretch&quot; the &lt;code&gt;mysql-server&lt;/code&gt; package depends on a new package called &lt;code&gt;default-mysql-server&lt;/code&gt;. This package in turn depends on &lt;code&gt;mariadb-server-10.1&lt;/code&gt;. There is no &lt;code&gt;default-mysql-server&lt;/code&gt; package in Jessie.</source>
          <target state="translated">데비안 8 &quot;Jessie&quot;의 MySQL 버전은 5.5입니다. 설치시 대부분의 사용자는 &lt;code&gt;mysql-server-5.5 package&lt;/code&gt; 에 따라 &lt;code&gt;mysql-server&lt;/code&gt; 패키지를 설치합니다 . 데비안 9 &quot;스트레치&quot;에서 &lt;code&gt;mysql-server&lt;/code&gt; 패키지는 &lt;code&gt;default-mysql-server&lt;/code&gt; 라는 새로운 패키지에 의존 합니다 . 이 패키지는 &lt;code&gt;mariadb-server-10.1&lt;/code&gt; 에 의존합니다 . Jessie 에는 &lt;code&gt;default-mysql-server&lt;/code&gt; 패키지 가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="e28444eeb5def83e9102beb0bc2c92a50f233310" translate="yes" xml:space="preserve">
          <source>The version of TokuDB in your local MariaDB is available by querying the &lt;a href=&quot;../tokudb-system-and-status-variables/index#tokudb_version&quot;&gt;tokudb_version&lt;/a&gt; status variable. For example:</source>
          <target state="translated">로컬 MariaDB의 TokuDB 버전은 &lt;a href=&quot;../tokudb-system-and-status-variables/index#tokudb_version&quot;&gt;tokudb_version&lt;/a&gt; 상태 변수를 쿼리하여 사용할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3a42a0daf65fba0ce9a039d865b5b3145b795623" translate="yes" xml:space="preserve">
          <source>The very first step is to start the nodes in the first cluster. The first node will have to be &lt;a href=&quot;../getting-started-with-mariadb-galera-cluster/index#bootstrapping-a-new-cluster&quot;&gt;bootstrapped&lt;/a&gt;. The other nodes can be &lt;a href=&quot;../starting-and-stopping-mariadb-starting-and-stopping-mariadb/index&quot;&gt;started normally&lt;/a&gt;.</source>
          <target state="translated">첫 번째 단계는 첫 번째 클러스터에서 노드를 시작하는 것입니다. 첫 번째 노드는 &lt;a href=&quot;../getting-started-with-mariadb-galera-cluster/index#bootstrapping-a-new-cluster&quot;&gt;부트 스트랩&lt;/a&gt; 되어야 합니다. 다른 노드는 &lt;a href=&quot;../starting-and-stopping-mariadb-starting-and-stopping-mariadb/index&quot;&gt;정상적으로 시작할&lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2db53507be704ee7e85a656891cc4d58bc285948" translate="yes" xml:space="preserve">
          <source>The view definition is &quot;frozen&quot; at creation time, so changes to the underlying tables afterwards do not affect the view definition. For example, if a view is defined as SELECT * on a table, new columns added to the table later do not become part of the view. A &lt;a href=&quot;../show-create-view/index&quot;&gt;SHOW CREATE VIEW&lt;/a&gt; shows that such queries are rewritten and column names are included in the view definition.</source>
          <target state="translated">뷰 정의는 작성시 &quot;고정&quot;되므로 기본 테이블을 변경해도 뷰 정의에 영향을 미치지 않습니다. 예를 들어 테이블에서 뷰가 SELECT *로 정의 된 경우 나중에 테이블에 추가 된 새 열은 뷰의 일부가되지 않습니다. &lt;a href=&quot;../show-create-view/index&quot;&gt;SHOW는 VIEW의 CREATE&lt;/a&gt; 같은 쿼리를 다시 작성하고 열 이름이 뷰 정의에 포함되어 있는지 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="54a148f53a038661f7ed8ba8c3706312650d4f66" translate="yes" xml:space="preserve">
          <source>The view definition must be a query that does not return errors at view creation times. However, the base tables used by the views might be altered later and the query may not be valid anymore. In this case, querying the view will result in an error. &lt;a href=&quot;../check-table/index&quot;&gt;CHECK TABLE&lt;/a&gt; helps in finding this kind of problems.</source>
          <target state="translated">뷰 정의는 뷰 생성시 오류를 반환하지 않는 쿼리 여야합니다. 그러나 뷰에서 사용하는 기본 테이블은 나중에 변경되어 쿼리가 더 이상 유효하지 않을 수 있습니다. 이 경우 뷰를 쿼리하면 오류가 발생합니다. &lt;a href=&quot;../check-table/index&quot;&gt;CHECK TABLE&lt;/a&gt; 은 이러한 종류의 문제를 찾는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="534daa41e9a4a940595013354f2915d1c2370f6b" translate="yes" xml:space="preserve">
          <source>The virtual machine is based on:</source>
          <target state="translated">가상 머신은 다음을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="7baf381aeae0078b5d0df5b1d39ea3e00bfa4959" translate="yes" xml:space="preserve">
          <source>The wait point is configured by the &lt;code&gt;&lt;a href=&quot;#rpl_semi_sync_master_wait_point&quot;&gt;rpl_semi_sync_master_wait_point&lt;/a&gt;&lt;/code&gt; system variable. The supported values are:</source>
          <target state="translated">대기 지점은 &lt;code&gt;&lt;a href=&quot;#rpl_semi_sync_master_wait_point&quot;&gt;rpl_semi_sync_master_wait_point&lt;/a&gt;&lt;/code&gt; 시스템 변수로 구성됩니다 . 지원되는 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="26a20f80602d82210f340a9538f998298acdbd00" translate="yes" xml:space="preserve">
          <source>The warnings for the above tables look like this:</source>
          <target state="translated">위 표에 대한 경고는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="78ff5c2b4c346c1d15c5a75f118b7cbb10a2b36c" translate="yes" xml:space="preserve">
          <source>The way CONNECT handles indexing is very specific. All table modifications are done regardless of indexing. Only after a table has been modified, or when an &lt;code&gt;OPTIMIZE TABLE&lt;/code&gt; command is sent are the indexes made. If an error occurs, the corresponding index is not made. However, CONNECT being a non-transactional engine, it is unable to roll back the changes made to the table. The main causes of indexing errors are:</source>
          <target state="translated">CONNECT가 인덱싱을 처리하는 방식은 매우 구체적입니다. 인덱싱에 관계없이 모든 테이블 수정이 수행됩니다. 테이블이 수정 된 후 또는 &lt;code&gt;OPTIMIZE TABLE&lt;/code&gt; 명령이 전송 될 때만 인덱스가 작성됩니다. 오류가 발생하면 해당 색인이 작성되지 않습니다. 그러나 CONNECT는 비 트랜잭션 엔진이므로 테이블의 변경 사항을 롤백 할 수 없습니다. 인덱싱 오류의 주요 원인은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d45c54dc62810e5cad1fd023cdd9e10d7e197068" translate="yes" xml:space="preserve">
          <source>The way it is done is different from what PostgreSQL does. In addition to including in a table some column values of a specific data format (JSON, XML) to be handled by specific functions, CONNECT can directly use JSON, XML or INI files that can be produced by other applications and this is the table definition that describes where and how the contained information must be retrieved.</source>
          <target state="translated">수행 방법은 PostgreSQL과 다릅니다. 특정 함수가 처리 할 특정 데이터 형식 (JSON, XML)의 일부 열 값을 테이블에 포함시키는 것 외에도 CONNECT는 다른 애플리케이션에서 생성 할 수있는 JSON, XML 또는 INI 파일을 직접 사용할 수 있으며 이는 테이블 정의입니다. 포함 된 정보를 검색해야하는 위치와 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="e5b7bc1622f39567f73bc8e77d2ac50fb617c7a5" translate="yes" xml:space="preserve">
          <source>The way it is done is to create the partition table with a table type referring to other tables, &lt;a href=&quot;../connect-table-types-proxy-table-type/index&quot;&gt;PROXY&lt;/a&gt;, &lt;a href=&quot;../connect-table-types-mysql-table-type-accessing-mysqlmariadb-tables/index&quot;&gt;MYSQL&lt;/a&gt;&lt;a href=&quot;../connect-table-types-odbc-table-type-accessing-tables-from-other-dbms/index&quot;&gt;ODBC&lt;/a&gt; or &lt;a href=&quot;../connect-jdbc-table-type-accessing-tables-from-other-dbms/index&quot;&gt;JDBC&lt;/a&gt;. Let us see how this is done on a simple example. Supposing we have created the following tables:</source>
          <target state="translated">수행되는 방법은 다른 테이블 ( &lt;a href=&quot;../connect-table-types-proxy-table-type/index&quot;&gt;PROXY&lt;/a&gt; , &lt;a href=&quot;../connect-table-types-mysql-table-type-accessing-mysqlmariadb-tables/index&quot;&gt;MYSQL &lt;/a&gt;&lt;a href=&quot;../connect-table-types-odbc-table-type-accessing-tables-from-other-dbms/index&quot;&gt;ODBC&lt;/a&gt; 또는 &lt;a href=&quot;../connect-jdbc-table-type-accessing-tables-from-other-dbms/index&quot;&gt;JDBC)을&lt;/a&gt; 참조하는 테이블 유형으로 파티션 테이블을 작성하는 것입니다 . 이것이 간단한 예에서 어떻게 수행되는지 봅시다. 다음 테이블을 작성했다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="b5f49e120dfc8e365cf31e7c8557191283e8b7f3" translate="yes" xml:space="preserve">
          <source>The way it works is that the documents retrieved from MongoDB are serialized and CONNECT uses them as if they were read from a file. This implies serializing by MongoDB and parsing by CONNECT and is not the best performance wise. CONNECT tries its best to reduce the data transfer when a query contains a reduced column list and/or a where clause. This way makes all the possibilities of the JSON table type available, such as calculated arrays.</source>
          <target state="translated">작동 방식은 MongoDB에서 검색된 문서가 직렬화되고 CONNECT가 파일에서 읽은 것처럼이를 사용한다는 것입니다. 이것은 MongoDB의 직렬화와 CONNECT의 구문 분석을 의미하며 최상의 성능은 아닙니다. CONNECT는 쿼리에 축소 된 열 목록 및 / 또는 where 절이 포함 된 경우 데이터 전송을 줄이기 위해 최선을 다합니다. 이렇게하면 계산 된 배열과 같은 JSON 테이블 유형의 모든 가능성을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7f0da641152e3e357bc861b7e87a35426c445b2" translate="yes" xml:space="preserve">
          <source>The way that a replication filter is interpreted can depend on the &lt;a href=&quot;../binary-log-formats/index&quot;&gt;binary log format&lt;/a&gt;.</source>
          <target state="translated">복제 필터를 해석하는 방법은 &lt;a href=&quot;../binary-log-formats/index&quot;&gt;이진 로그 형식&lt;/a&gt; 에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="54c1b6efd6df5661445086c851a4578f4255f123" translate="yes" xml:space="preserve">
          <source>The way this works is by establishing a connection to the external data source and by sending it an SQL statement (or its equivalent using API functions for MONGO) enabling it to execute the original query. To enhance performance, it is necessary to have the remote data source do the maximum processing. This is needed in particular to reduce the amount of data returned by the data source.</source>
          <target state="translated">이것이 작동하는 방식은 외부 데이터 소스에 대한 연결을 설정하고 원래 쿼리를 실행할 수 있도록 SQL 문 (또는 MONGO의 API 함수를 사용하는 동등한 명령문)을 전송하는 것입니다. 성능을 향상 시키려면 원격 데이터 소스가 최대 처리를 수행해야합니다. 이것은 특히 데이터 소스에 의해 리턴되는 데이터의 양을 줄이기 위해 필요합니다.</target>
        </trans-unit>
        <trans-unit id="6615fcf3fb2b8d203d5c7b079560b31a54470e8e" translate="yes" xml:space="preserve">
          <source>The wildcard pattern uses the same semantics as the &lt;code&gt;&lt;a href=&quot;../like/index&quot;&gt;LIKE&lt;/a&gt;&lt;/code&gt; operator. This means that the the following characters have a special meaning:</source>
          <target state="translated">와일드 카드 패턴은 &lt;code&gt;&lt;a href=&quot;../like/index&quot;&gt;LIKE&lt;/a&gt;&lt;/code&gt; 연산자 와 동일한 의미를 사용합니다 . 이는 다음 문자가 특별한 의미를 갖음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d781e1781a5251efa7b49f82f366fac34be1a3b9" translate="yes" xml:space="preserve">
          <source>The wildcard, indicating zero or more characters. It can only appear at the end of a word.</source>
          <target state="translated">0 개 이상의 문자를 나타내는 와일드 카드. 단어의 끝에 만 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bcb5e4b7ea6952f7af893824dc55138a088e35dd" translate="yes" xml:space="preserve">
          <source>The winning entry was submitted by Chris Tooley. He received a Linux-powered &lt;a href=&quot;http://www.system76.com&quot;&gt;System 76&lt;/a&gt; Meerkat NetTop as his prize for suggesting the winning name from Monty Program.</source>
          <target state="translated">우승자는 Chris Tooley에 의해 제출되었습니다. 그는 Monty Program에서 우승을 제안한 공로로 Linux 기반 &lt;a href=&quot;http://www.system76.com&quot;&gt;System 76&lt;/a&gt; Meerkat NetTop을 받았습니다.</target>
        </trans-unit>
        <trans-unit id="2756e09fa7bf060dc1012a8c3cdaa00e76d9776b" translate="yes" xml:space="preserve">
          <source>The winning entry was submitted by Chris Tooley. He received a Linux-powered &lt;a href=&quot;https://www.system76.com&quot;&gt;System 76&lt;/a&gt; Meerkat NetTop as his prize for suggesting the winning name from Monty Program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84ddad0fd1afd381727141b4d01a73eabbb7fdbc" translate="yes" xml:space="preserve">
          <source>The word cannot appear in any row returned.</source>
          <target state="translated">반환 된 행에는 단어가 나타나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5aded93f62ba6a9b82fb0cdacd712cf086d63649" translate="yes" xml:space="preserve">
          <source>The word following contributes negatively to the relevance of the row (which is different to the '-' operator, which specifically excludes the word, or the '&amp;lt;' operator, which still causes the word to contribute positively to the relevance of the row.</source>
          <target state="translated">뒤 따르는 단어는 행의 관련성에 부정적인 영향을 미칩니다 ( '-'연산자 (단어를 제외) 또는 '&amp;lt;'연산자와는 다르게 단어가 여전히 행의 관련성에 긍정적으로 기여 함).</target>
        </trans-unit>
        <trans-unit id="7cd8cef9423a90d7a938398ded6da3e47b60b132" translate="yes" xml:space="preserve">
          <source>The word is mandatory in all rows returned.</source>
          <target state="translated">반환 된 모든 행에서 단어는 필수입니다.</target>
        </trans-unit>
        <trans-unit id="d0248005eaeb90320b2c7adaa1bc9b0235a01460" translate="yes" xml:space="preserve">
          <source>The word that follows has a higher relevance than other words.</source>
          <target state="translated">뒤에 나오는 단어는 다른 단어보다 관련성이 높습니다.</target>
        </trans-unit>
        <trans-unit id="d6bfeb981ddb369f7bc33e1ab60ee137b3eae497" translate="yes" xml:space="preserve">
          <source>The word that follows has a lower relevance than other words, although rows containing it will still match</source>
          <target state="translated">다음 단어는 다른 단어보다 관련성이 낮지 만 단어를 포함하는 행은 여전히 ​​일치합니다.</target>
        </trans-unit>
        <trans-unit id="eef78eca5625c0419895db49b25528d30ff48c2e" translate="yes" xml:space="preserve">
          <source>The work in MariaDB is based on the project description at &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-253&quot;&gt;MDEV-253&lt;/a&gt;.</source>
          <target state="translated">MariaDB의 작업은 &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-253&quot;&gt;MDEV-253&lt;/a&gt; 의 프로젝트 설명을 기반으로합니다 .</target>
        </trans-unit>
        <trans-unit id="65a39c68d8094c8fa26386ca432d634146445501" translate="yes" xml:space="preserve">
          <source>The work-around fix is to delete the ExeMgr entry from the Columnstore.xml file.</source>
          <target state="translated">이 문제를 해결하려면 Columnstore.xml 파일에서 ExeMgr 항목을 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="852b24e448e0395f52f959d42af86054d49b22a6" translate="yes" xml:space="preserve">
          <source>The workaround is to uninstall the &lt;a href=&quot;../password-validation-plugins/index&quot;&gt;password validation plugin&lt;/a&gt; with &lt;code&gt;&lt;a href=&quot;../uninstall-plugin/index&quot;&gt;UNINSTALL PLUGIN&lt;/a&gt;&lt;/code&gt;, and then create the account, and then reinstall the &lt;a href=&quot;../password-validation/index&quot;&gt;password validation plugin&lt;/a&gt; with &lt;code&gt;&lt;a href=&quot;../install-plugin/index&quot;&gt;INSTALL PLUGIN&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">해결 방법은 제거하는 것입니다 &lt;a href=&quot;../password-validation-plugins/index&quot;&gt;암호 유효성 검사 플러그인&lt;/a&gt; 과 &lt;code&gt;&lt;a href=&quot;../uninstall-plugin/index&quot;&gt;UNINSTALL PLUGIN&lt;/a&gt;&lt;/code&gt; 을 한 다음 계정을 만든 다음 다시 설치 &lt;a href=&quot;../password-validation/index&quot;&gt;검증 플러그인 암호&lt;/a&gt; 와 &lt;code&gt;&lt;a href=&quot;../install-plugin/index&quot;&gt;INSTALL PLUGIN&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2776dcd365c1ed2a4a0970ecd75eb408014fc71e" translate="yes" xml:space="preserve">
          <source>The worker threads will be listed as &quot;system user&quot; in &lt;a href=&quot;../show-processlist/index&quot;&gt;SHOW PROCESSLIST&lt;/a&gt;. Their state will show the query they are currently working on, or it can show one of these:</source>
          <target state="translated">작업자 스레드는 &lt;a href=&quot;../show-processlist/index&quot;&gt;SHOW PROCESSLIST&lt;/a&gt; 에 &quot;시스템 사용자&quot;로 표시 됩니다. 해당 상태는 현재 작업중인 쿼리를 표시하거나 다음 중 하나를 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6bce500e428b91cf9e4f92f3d6b097df9e003f31" translate="yes" xml:space="preserve">
          <source>The wrapper class also creates some required items and, in particular, a statement class. Some characteristics of this statement will depend on the options specified when creating the table:</source>
          <target state="translated">랩퍼 클래스는 또한 필수 항목, 특히 명령문 클래스를 작성합니다. 이 명령문의 일부 특성은 테이블을 작성할 때 지정된 옵션에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="9e6b4bc019319cf474e46b44851952a1f3a7b2df" translate="yes" xml:space="preserve">
          <source>The wrapper used by default is specified by the &lt;a href=&quot;../connect-system-variables/index#connect_java_wrapper&quot;&gt;connect_java_wrapper&lt;/a&gt; session variable and is initially set to &lt;code&gt;wrappers/JdbcInterface&lt;/code&gt;. The wrapper to use for a table can also be specified in the option list as a wrapper option of the &amp;ldquo;create table&amp;rdquo; statements.</source>
          <target state="translated">기본적으로 사용되는 랩퍼는 &lt;a href=&quot;../connect-system-variables/index#connect_java_wrapper&quot;&gt;connect_java_wrapper&lt;/a&gt; 세션 변수에 의해 지정되며 처음에는 &lt;code&gt;wrappers/JdbcInterface&lt;/code&gt; 설정됩니다 . 테이블에 사용할 랩퍼는 옵션 테이블에서&amp;ldquo;create table&amp;rdquo;문의 랩퍼 옵션으로 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea882397abe5a95fda0fc02c997eddc9378ce3f6" translate="yes" xml:space="preserve">
          <source>The wrapper_name should be &lt;code&gt;mysql&lt;/code&gt;, and may be quoted with single quotes. Other values for wrapper_name are not currently supported.</source>
          <target state="translated">wrapper_name은 &lt;code&gt;mysql&lt;/code&gt; 이어야하며 작은 따옴표로 인용 될 수 있습니다. wrapper_name의 다른 값은 현재 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3798edfaf2369a283bad89c1ffa98a200bbf9329" translate="yes" xml:space="preserve">
          <source>The write insert a single string into a memory table</source>
          <target state="translated">쓰기는 단일 문자열을 메모리 테이블에 삽입합니다</target>
        </trans-unit>
        <trans-unit id="adb2af73f1a3b4f59dffbc50f9aa1d0115b380aa" translate="yes" xml:space="preserve">
          <source>The xj1 table rows will directly receive the Json object made by the select statement used in the insert statement and the table file will be made as shown (xj1 is pretty=2 by default) Its mode is Jmode=2 because the values inserted are strings even if they denote json objects.</source>
          <target state="translated">xj1 테이블 행은 insert 문에 사용 된 select 문으로 작성된 Json 오브젝트를 직접 수신하고 테이블 파일은 표시된대로 작성됩니다 (기본적으로 xj1은 pretty = 2 임) 삽입 된 값은 문자열이므로 모드는 Jmode = 2입니다. 그것들이 json 객체를 나타내더라도.</target>
        </trans-unit>
        <trans-unit id="3d33bf53fe1ad1a153cc8188f66de9a68a9303fa" translate="yes" xml:space="preserve">
          <source>The xtrabackup-v2 SST method uses the Percona XtraBackup utility for performing SSTs.</source>
          <target state="translated">xtrabackup-v2 SST 방법은 SST를 수행하기 위해 Percona XtraBackup 유틸리티를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="17d551cc87145ca6cf1746c940625725fd1d1c94" translate="yes" xml:space="preserve">
          <source>The y-intercept of the least-squares-fit linear equation determined by the (ColumnX, ColumnY) pairs</source>
          <target state="translated">(ColumnX, ColumnY) 쌍으로 결정된 최소 제곱 법 선형 방정식의 y 절편</target>
        </trans-unit>
        <trans-unit id="f73c229adc2f36429c80e2a792b922e0666856cf" translate="yes" xml:space="preserve">
          <source>The year part in &lt;code&gt;DATE&lt;/code&gt; and &lt;code&gt;DATETIME&lt;/code&gt; literals is determined as follows:</source>
          <target state="translated">&lt;code&gt;DATE&lt;/code&gt; 및 &lt;code&gt;DATETIME&lt;/code&gt; 리터럴 의 연도 부분은 다음과 같이 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="6c08e85cee2c11859b2be15a2539b3ce30d89765" translate="yes" xml:space="preserve">
          <source>The, select the line with customer_id=1</source>
          <target state="translated">customer_id = 1 인 행을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="18f64bdaa5678137758abc681d34a32c31a380d1" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;CHANGED_PAGE_BITMAPS&lt;/code&gt; table was added in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1016-release-notes/&quot;&gt;MariaDB 10.1.6&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;CHANGED_PAGE_BITMAPS&lt;/code&gt; 의 테이블에서 추가되었다 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1016-release-notes/&quot;&gt;MariaDB 10.1.6&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f88142c42172776ba3ba271fa36773e987c6e2fe" translate="yes" xml:space="preserve">
          <source>Their file will be located in the current database directory and their name will default to tablename.type where tablename is the table name and type is the table type folded to lower case. When they are created without using a &lt;code&gt;CREATE TABLE ...  SELECT ...&lt;/code&gt; statement, an empty file is made at create time and they can be populated by further inserts.</source>
          <target state="translated">파일은 현재 데이터베이스 디렉토리에 있으며 이름은 기본적으로 tablename.type입니다. 여기서 tablename은 테이블 이름이고 type은 소문자로 접힌 테이블 유형입니다. &lt;code&gt;CREATE TABLE ... SELECT ...&lt;/code&gt; 문 을 사용하지 않고 작성하면 작성시 빈 파일이 작성되고 추가 삽입으로 채울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="623f8201b455786996a1673daf0d6d29c1cdc529" translate="yes" xml:space="preserve">
          <source>Their intersection is not equal to either of the two given geometries</source>
          <target state="translated">그들의 교차점은 주어진 두 기하학 중 하나와 같지 않습니다</target>
        </trans-unit>
        <trans-unit id="3453382321c97e04a888fee6e7ebaf79206f206d" translate="yes" xml:space="preserve">
          <source>Their intersection results in a geometry that has a dimension that is one less than the maximum dimension of the two given geometries</source>
          <target state="translated">이들의 교차로 인해 주어진 두 형상의 최대 치수보다 1이 작은 형상이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="3cec89f0e8d244b65eff830cb060b29e2898c932" translate="yes" xml:space="preserve">
          <source>Then '&lt;code&gt;sudo apt-get install&lt;/code&gt;' the list of packages to downgrade as given in the applicable section below.</source>
          <target state="translated">그런 다음 아래의 해당 섹션에 제공된대로 다운 그레이드 할 패키지 목록을 ' &lt;code&gt;sudo apt-get install&lt;/code&gt; '하십시오.</target>
        </trans-unit>
        <trans-unit id="6e0ad883317e70efaa70f9a85fac1a41e399fb8b" translate="yes" xml:space="preserve">
          <source>Then '&lt;code&gt;sudo apt-get update&lt;/code&gt;' to get things back to normal</source>
          <target state="translated">그런 다음 ' &lt;code&gt;sudo apt-get update&lt;/code&gt; '를 다시 정상으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="ac7a518a7f7237dcc11299d6a551c7c88558f5fe" translate="yes" xml:space="preserve">
          <source>Then (presumably) re-executing the DELETE will finish the aborted task.</source>
          <target state="translated">그런 다음 (아마도) DELETE를 다시 실행하면 중단 된 작업이 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="1ce2ea059a59acf5171705e8982d701c8f806621" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;mysqld_safe&lt;/code&gt; will also use this value for its own &lt;code&gt;--log-error&lt;/code&gt; option:</source>
          <target state="translated">그런 다음 &lt;code&gt;mysqld_safe&lt;/code&gt; 는이 값을 자체 &lt;code&gt;--log-error&lt;/code&gt; 옵션으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b609efdf1217c1d7b0c7df3f83514e44ba8aa0d9" translate="yes" xml:space="preserve">
          <source>Then add the URL for your Poudriere repository to configuration file:</source>
          <target state="translated">그런 다음 Poudriere 저장소의 URL을 구성 파일에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="3280ed6c70495c8b5bedbf30d61b8510c151fc66" translate="yes" xml:space="preserve">
          <source>Then any &lt;code&gt;mysqld&lt;/code&gt; processes started by that shell will use &lt;code&gt;0027&lt;/code&gt; as both &lt;code&gt;UMASK&lt;/code&gt; and &lt;code&gt;UMASK_DIR&lt;/code&gt;, which will result in a &lt;code&gt;0640&lt;/code&gt; mode for files and a &lt;code&gt;0750&lt;/code&gt; mode for directories.</source>
          <target state="translated">그런 다음 어떤 &lt;code&gt;mysqld&lt;/code&gt; 그 쉘에 의해 시작 프로세스가 사용하는 &lt;code&gt;0027&lt;/code&gt; 을 모두로 &lt;code&gt;UMASK&lt;/code&gt; 및 &lt;code&gt;UMASK_DIR&lt;/code&gt; A의 발생합니다, &lt;code&gt;0640&lt;/code&gt; 파일 모드와 &lt;code&gt;0750&lt;/code&gt; 디렉토리에 대한 모드.</target>
        </trans-unit>
        <trans-unit id="06461f442d33fabeb3698dc7896c49bd3ef49704" translate="yes" xml:space="preserve">
          <source>Then any PAM user in the PAM group &lt;code&gt;dba&lt;/code&gt; would be mapped to the MariaDB user account &lt;code&gt;dba&lt;/code&gt;. But if a PAM user with the name &lt;code&gt;dba&lt;/code&gt; did not also exist, then the &lt;code&gt;pam_user_map&lt;/code&gt; PAM module's debug logging would write errors to the syslog like the following:</source>
          <target state="translated">그러면 PAM 그룹 &lt;code&gt;dba&lt;/code&gt; 의 모든 PAM 사용자가 MariaDB 사용자 계정 &lt;code&gt;dba&lt;/code&gt; 에 매핑됩니다 . 그러나 이름이 &lt;code&gt;dba&lt;/code&gt; 인 PAM 사용자 도 존재하지 않으면 &lt;code&gt;pam_user_map&lt;/code&gt; PAM 모듈의 디버그 로깅은 다음과 같이 syslog에 오류를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="e606ce55ec50251092ad9f8a4b773025d0edf382" translate="yes" xml:space="preserve">
          <source>Then check SELinux's &lt;code&gt;/var/log/audit/audit.log&lt;/code&gt; for log entries that look similar to the following:</source>
          <target state="translated">그런 다음 SELinux의 &lt;code&gt;/var/log/audit/audit.log&lt;/code&gt; 에서 다음과 유사한 로그 항목을 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="092df5133fb909651b202e28258bc6e9e27cfbcb" translate="yes" xml:space="preserve">
          <source>Then compile and install the OEM module with:</source>
          <target state="translated">그런 다음 OEM 모듈을 다음과 같이 컴파일하고 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="077d4e5754dc99d4341bea4d533bde1425d5ae65" translate="yes" xml:space="preserve">
          <source>Then create a connecting table on MariaDB and attempt the same query:</source>
          <target state="translated">그런 다음 MariaDB에 연결 테이블을 만들고 동일한 쿼리를 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="2e90c115395109f27fa4bdfd7aece85651e5af54" translate="yes" xml:space="preserve">
          <source>Then create the table that will retrieve the result of all these tables:</source>
          <target state="translated">그런 다음이 모든 테이블의 결과를 검색 할 테이블을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="f10f58d32d3c2687847410a80a87cc42dfd6c49d" translate="yes" xml:space="preserve">
          <source>Then decompress the backup,</source>
          <target state="translated">그런 다음 백업을 압축 해제하십시오.</target>
        </trans-unit>
        <trans-unit id="a3bf7b18d0419e8ed047c6baa91e2005ecc2de5b" translate="yes" xml:space="preserve">
          <source>Then do a CALL, like in the examples, below.</source>
          <target state="translated">그런 다음 아래 예와 같이 전화를 겁니다.</target>
        </trans-unit>
        <trans-unit id="0adc013892e79fd81bb1d6e4f123db097e406e03" translate="yes" xml:space="preserve">
          <source>Then execute the following SQL with the &lt;a href=&quot;../mysql-command-line-client/index&quot;&gt;&lt;code&gt;mysql&lt;/code&gt;&lt;/a&gt; command line client:</source>
          <target state="translated">그런 다음 &lt;a href=&quot;../mysql-command-line-client/index&quot;&gt; &lt;code&gt;mysql&lt;/code&gt; &lt;/a&gt; 명령 행 클라이언트로 다음 SQL을 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="c26c4d751f7b2d761e611cbb596c526ce3fe4891" translate="yes" xml:space="preserve">
          <source>Then for every row of data retrieved from the foreign database in the result set:</source>
          <target state="translated">그런 다음 결과 세트의 외부 데이터베이스에서 검색된 모든 데이터 행에 대해 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="4bfc83e4728c27731644148726b5809b6a9918eb" translate="yes" xml:space="preserve">
          <source>Then from a shell, run &lt;code&gt;launchctl load /Library/LaunchDaemons/com.mariadb.server.plist&lt;/code&gt; and MariaDB will run immediately, and also upon reboot.</source>
          <target state="translated">그런 다음 셸에서 &lt;code&gt;launchctl load /Library/LaunchDaemons/com.mariadb.server.plist&lt;/code&gt; 를 실행 하면 MariaDB가 즉시 실행되고 재부팅시 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="29f0b3969147ed6c90d5ad70c46e5f8c832d0fab" translate="yes" xml:space="preserve">
          <source>Then grant the &lt;code&gt;spider&lt;/code&gt; user privileges on the example table.</source>
          <target state="translated">그런 다음 예제 테이블 에서 &lt;code&gt;spider&lt;/code&gt; 사용자 권한을 부여하십시오 .</target>
        </trans-unit>
        <trans-unit id="e5dabd724654dc286b3f5dd5ade510b495da363d" translate="yes" xml:space="preserve">
          <source>Then if we ask:</source>
          <target state="translated">우리가 묻는다면 :</target>
        </trans-unit>
        <trans-unit id="09fbc3ba024c89d67d62fc402e0418770471c94a" translate="yes" xml:space="preserve">
          <source>Then install the package, as follows:</source>
          <target state="translated">그런 다음 다음과 같이 패키지를 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="478c4a6b091566e2f064459d23f3a0d8c90e7c95" translate="yes" xml:space="preserve">
          <source>Then let's create a couple users to go into the &lt;code&gt;dba&lt;/code&gt; group:</source>
          <target state="translated">그런 다음 몇 명의 사용자를 만들어 &lt;code&gt;dba&lt;/code&gt; 그룹 으로갑니다 .</target>
        </trans-unit>
        <trans-unit id="94ba922d80dfed995abd051fb425f535f327c6e0" translate="yes" xml:space="preserve">
          <source>Then let's test out our &lt;code&gt;alice&lt;/code&gt; user in the &lt;code&gt;dba&lt;/code&gt; group:</source>
          <target state="translated">그런 다음 &lt;code&gt;dba&lt;/code&gt; 그룹 에서 &lt;code&gt;alice&lt;/code&gt; 사용자를 테스트 하십시오 .</target>
        </trans-unit>
        <trans-unit id="37fe1d41fafb75129597e6ff4eb876c08e75f0f4" translate="yes" xml:space="preserve">
          <source>Then let's test out our &lt;code&gt;gmontee&lt;/code&gt; user in the &lt;code&gt;dba&lt;/code&gt; group:</source>
          <target state="translated">그런 다음 &lt;code&gt;dba&lt;/code&gt; 그룹 에서 &lt;code&gt;gmontee&lt;/code&gt; 사용자를 테스트 하십시오 .</target>
        </trans-unit>
        <trans-unit id="3b925d3b788ad934c46c0ef3214bcf7b5405170f" translate="yes" xml:space="preserve">
          <source>Then look at the summary tables -- you are likely to find some similarities.</source>
          <target state="translated">그런 다음 요약 테이블을 살펴보십시오. 일부 유사점을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64b2b971326611ba39e556f8bfcfc073bc692493" translate="yes" xml:space="preserve">
          <source>Then on the first cluster, you can set up replication by setting &lt;code&gt;&lt;a href=&quot;../gtid/index#gtid_slave_pos&quot;&gt;gtid_slave_pos&lt;/a&gt;&lt;/code&gt; to the GTID that was returned and then executing &lt;code&gt;&lt;a href=&quot;../change-master-to/index&quot;&gt;CHANGE MASTER TO&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">그런 다음 첫 번째 클러스터 에서 gtid_slave_pos를 반환 된 &lt;code&gt;&lt;a href=&quot;../gtid/index#gtid_slave_pos&quot;&gt;gtid_slave_pos&lt;/a&gt;&lt;/code&gt; 로 설정 한 다음 &lt;code&gt;&lt;a href=&quot;../change-master-to/index&quot;&gt;CHANGE MASTER TO&lt;/a&gt;&lt;/code&gt; 를 실행 하여 복제를 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b902071203414071874bed49cb52cd1f68ba6b95" translate="yes" xml:space="preserve">
          <source>Then on the first cluster, you would set &lt;code&gt;master_log_file&lt;/code&gt; and &lt;code&gt;master_log_pos&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;../change-master-to/index&quot;&gt;CHANGE MASTER TO&lt;/a&gt;&lt;/code&gt; command. For example:</source>
          <target state="translated">그런 다음 첫 번째 클러스터 에서 &lt;code&gt;&lt;a href=&quot;../change-master-to/index&quot;&gt;CHANGE MASTER TO&lt;/a&gt;&lt;/code&gt; 에서 &lt;code&gt;master_log_file&lt;/code&gt; 및 &lt;code&gt;master_log_pos&lt;/code&gt; 를 설정합니다 . 명령 합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f10a1a33a21f7b6c2e572583690969f6903313ed" translate="yes" xml:space="preserve">
          <source>Then on the node acting as slave in the cluster, you can set up replication by setting &lt;code&gt;&lt;a href=&quot;../gtid/index#gtid_slave_pos&quot;&gt;gtid_slave_pos&lt;/a&gt;&lt;/code&gt; to the GTID that was returned and then executing &lt;code&gt;&lt;a href=&quot;../change-master-to/index&quot;&gt;CHANGE MASTER TO&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">그런 다음 클러스터에서 슬레이브 역할을하는 노드 에서 gtid_slave_pos를 반환 된 &lt;code&gt;&lt;a href=&quot;../gtid/index#gtid_slave_pos&quot;&gt;gtid_slave_pos&lt;/a&gt;&lt;/code&gt; 로 설정 한 다음 &lt;code&gt;&lt;a href=&quot;../change-master-to/index&quot;&gt;CHANGE MASTER TO&lt;/a&gt;&lt;/code&gt; 를 실행 하여 복제를 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3478322ada5b1040a4a6ded22f77f1be53c5a09d" translate="yes" xml:space="preserve">
          <source>Then on the node acting as slave in the cluster, you would set &lt;code&gt;master_log_file&lt;/code&gt; and &lt;code&gt;master_log_pos&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;../change-master-to/index&quot;&gt;CHANGE MASTER TO&lt;/a&gt;&lt;/code&gt; command. For example:</source>
          <target state="translated">그런 다음 클러스터에서 슬레이브 역할을하는 노드 의 &lt;code&gt;&lt;a href=&quot;../change-master-to/index&quot;&gt;CHANGE MASTER TO&lt;/a&gt;&lt;/code&gt; 명령 에서 &lt;code&gt;master_log_file&lt;/code&gt; 및 &lt;code&gt;master_log_pos&lt;/code&gt; 를 설정 합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="90f2c9e07d637c544ad5ace877e0ff668d0e88b0" translate="yes" xml:space="preserve">
          <source>Then perform bulk summarization using</source>
          <target state="translated">그런 다음을 사용하여 대량 요약을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="b7bf08d3984d105568c8baa8afef2026650497af" translate="yes" xml:space="preserve">
          <source>Then restart MariaDB,</source>
          <target state="translated">그런 다음 MariaDB를 다시 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="45fa83063a4a6ac9e6aa5e62b450298992a27aa9" translate="yes" xml:space="preserve">
          <source>Then run '&lt;code&gt;sudo apt-get update&lt;/code&gt;'</source>
          <target state="translated">그런 다음 ' &lt;code&gt;sudo apt-get update&lt;/code&gt; '를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="32188e371ecba8fe3d526e2ac2bfb954eaaf6f75" translate="yes" xml:space="preserve">
          <source>Then run the update:</source>
          <target state="translated">그런 다음 업데이트를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="480b6f7ba698b1b4880f2d89385f6576a45ef45b" translate="yes" xml:space="preserve">
          <source>Then stop the MariaDB Server and remove the InnoDB tablespace files. In the data directory or the InnoDB data home directory, delete all the &lt;code&gt;ibdata&lt;/code&gt; and &lt;code&gt;ib_log&lt;/code&gt; files as well as any file with an &lt;code&gt;.ibd&lt;/code&gt; or &lt;code&gt;.frm&lt;/code&gt; extension.</source>
          <target state="translated">그런 다음 MariaDB 서버를 중지하고 InnoDB 테이블 스페이스 파일을 제거하십시오. 데이터 디렉토리 또는 InnoDB 데이터 홈 디렉토리에서 모든 &lt;code&gt;ibdata&lt;/code&gt; 및 &lt;code&gt;ib_log&lt;/code&gt; 파일은 물론 확장자 가 &lt;code&gt;.ibd&lt;/code&gt; 또는 &lt;code&gt;.frm&lt;/code&gt; 인 모든 파일을 삭제하십시오 .</target>
        </trans-unit>
        <trans-unit id="bf826766e5422d07b22e9c2af12c7406d831b552" translate="yes" xml:space="preserve">
          <source>Then the FederatedX table is created specifying the newly created Federated server:</source>
          <target state="translated">그런 다음 새로 작성된 Federated 서버를 지정하여 FederatedX 테이블이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="ceb0ca912ecd2fe0e22dce182deac721c82bffd1" translate="yes" xml:space="preserve">
          <source>Then the OS enters the picture. In at least one case (RHEL?), two things seem to be done:</source>
          <target state="translated">그런 다음 OS가 그림으로 들어갑니다. 적어도 하나의 경우 (RHEL?)에는 다음 두 가지가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="fb8c3809fbadf333d12ff7b6df19ada05f13ef18" translate="yes" xml:space="preserve">
          <source>Then the active people in MySQL.</source>
          <target state="translated">그런 다음 MySQL의 활동적인 사람들.</target>
        </trans-unit>
        <trans-unit id="c7cf9358ccc00cccb79dcc95337b7a29d922d553" translate="yes" xml:space="preserve">
          <source>Then the following output would verify that it is working properly:</source>
          <target state="translated">그런 다음 다음 출력이 제대로 작동하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="f0e93bbc0486b1831470287dae9060b3834dc2eb" translate="yes" xml:space="preserve">
          <source>Then transaction T2 will always see the same value for &lt;code&gt;xtradb_table.a&lt;/code&gt; and &lt;code&gt;pbxt_table.b&lt;/code&gt;.</source>
          <target state="translated">그러면 트랜잭션 T2는 항상 &lt;code&gt;xtradb_table.a&lt;/code&gt; 및 &lt;code&gt;pbxt_table.b&lt;/code&gt; 에 대해 동일한 값을 보게 됩니다 .</target>
        </trans-unit>
        <trans-unit id="667091fa26d66ce4951ffcecd63da63dcae39467" translate="yes" xml:space="preserve">
          <source>Then type an SQL statement, end it with &amp;ldquo;;&amp;rdquo;, \g, or \G and press Enter.</source>
          <target state="translated">그런 다음 SQL 문을 입력하고&amp;ldquo;;&amp;rdquo;, \ g 또는 \ G로 끝내고 Enter를 누르십시오.</target>
        </trans-unit>
        <trans-unit id="e4780127fc0aa5e8ceeb2eb0931bf86c1c05c537" translate="yes" xml:space="preserve">
          <source>Then use automake/configure/make to generate the tar file:</source>
          <target state="translated">그런 다음 automake / configure / make를 사용하여 tar 파일을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="dcdf01fa6caa42145108528ca8a3fb5406d6b663" translate="yes" xml:space="preserve">
          <source>Then we can start the adapter by executing the following command.</source>
          <target state="translated">그런 다음 다음 명령을 실행하여 어댑터를 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02ed0888c90dc6c8511ce8ed189cba5ea9183d92" translate="yes" xml:space="preserve">
          <source>Then we pack it and generate the indexes. We use a big sort buffer to speed up generating the index.</source>
          <target state="translated">그런 다음 압축하여 인덱스를 생성합니다. 인덱스 정렬 속도를 높이기 위해 큰 정렬 버퍼를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d82f25734a11c385a2dafa4af0849bdee2f499f5" translate="yes" xml:space="preserve">
          <source>Then we proceed to search for the next record ... and what happens next depends on the storage engine. In some storage engines, data changes are visible immediately, so we will find find the &lt;em&gt;Babatunde, 1100&lt;/em&gt; record that we wrote at the first step, modifying it again, giving Babatunde an undeserved raise. Then we will see Babatunde again and again, looping continually.</source>
          <target state="translated">그런 다음 다음 레코드를 검색합니다. 다음에 발생하는 일은 스토리지 엔진에 따라 다릅니다. 일부 스토리지 엔진에서는 데이터 변경 사항이 즉시 표시되므로 첫 번째 단계에서 작성한 &lt;em&gt;1100 년 Babatunde&lt;/em&gt; 레코드를 찾아서 수정하여 Babatunde에 당연한 인상을주었습니다. 그런 다음 계속해서 반복되는 Babatunde를 보게 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="60800387ea1c4177a427076f82931ec111837660" translate="yes" xml:space="preserve">
          <source>Then we proceed to search for the next record, and find &lt;em&gt;Jolana, 1050&lt;/em&gt;. We instruct the storage engine to update it to be &lt;em&gt;Jolana, 1050+100=1150&lt;/em&gt;.</source>
          <target state="translated">그런 다음 다음 레코드를 검색하고 &lt;em&gt;Jolana, 1050을&lt;/em&gt; 찾으 &lt;em&gt;십시오&lt;/em&gt; . 스토리지 엔진에 &lt;em&gt;Jolana, 1050 + 100 = 1150&lt;/em&gt; 으로 업데이트하도록 지시합니다 .</target>
        </trans-unit>
        <trans-unit id="744af1c1ba47ef756af474da251985cb4459653b" translate="yes" xml:space="preserve">
          <source>Then we would have:</source>
          <target state="translated">그럼 우리는 :</target>
        </trans-unit>
        <trans-unit id="2fda0ab377789217aa94a3e578706d50051164c1" translate="yes" xml:space="preserve">
          <source>Then you can create the functions using this name as the soname parameter.</source>
          <target state="translated">그런 다음이 이름을 soname 매개 변수로 사용하여 함수를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="931825fa219cdcd84bc1e659e9bfc1f8fbee8339" translate="yes" xml:space="preserve">
          <source>Then you can enter a topic as the search string to see the help entry for that topic.</source>
          <target state="translated">그런 다음 주제를 검색 문자열로 입력하여 해당 주제에 대한 도움말 항목을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a357cdb5d0b4fc9bb68a578111f3221b341be3d7" translate="yes" xml:space="preserve">
          <source>Then you can execute the script to pipe it directly into cpimport:</source>
          <target state="translated">그런 다음 스크립트를 실행하여 cpimport로 직접 파이프 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4c260b91eee32ccb2a5baccbd91df85c1b3e53c" translate="yes" xml:space="preserve">
          <source>Then you can send it by opening &lt;code&gt;&lt;a href=&quot;https://mariadb.org/feedback_plugin/post&quot;&gt;https://mariadb.org/feedback_plugin/post&lt;/a&gt;&lt;/code&gt; in your browser, and uploading your generated &lt;code&gt;report.txt&lt;/code&gt;. Or you can do it from the command line with (for example):</source>
          <target state="translated">그런 다음 브라우저에서 &lt;code&gt;&lt;a href=&quot;https://mariadb.org/feedback_plugin/post&quot;&gt;https://mariadb.org/feedback_plugin/post&lt;/a&gt;&lt;/code&gt; 를 열고 생성 된 &lt;code&gt;report.txt&lt;/code&gt; 를 업로드하여 보낼 수 있습니다 . 또는 다음과 같이 명령 행에서 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="29aa4ace74f0b9fb7b82718a00d5d70b68b4fc90" translate="yes" xml:space="preserve">
          <source>Then you can upload the generated &lt;code&gt;report.txt&lt;/code&gt;&lt;a href=&quot;https://mariadb.org/feedback_plugin/post&quot;&gt;here&lt;/a&gt; using your web browser.</source>
          <target state="translated">그런 다음 생성 된 &lt;code&gt;report.txt&lt;/code&gt; 를&lt;a href=&quot;https://mariadb.org/feedback_plugin/post&quot;&gt;여기에&lt;/a&gt; 업로드 할 수 있습니다 웹 브라우저를 사용하여 .</target>
        </trans-unit>
        <trans-unit id="3076ecd65369b90940bb63b37964c7b7a04a79d6" translate="yes" xml:space="preserve">
          <source>Then you could execute the following to grant the relevant privileges:</source>
          <target state="translated">그런 다음 관련 권한을 부여하기 위해 다음을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1fdf8dd1324221b79f5e43f47cd9c917c8fef7aa" translate="yes" xml:space="preserve">
          <source>Then you should check the current position of the master:</source>
          <target state="translated">그런 다음 마스터의 현재 위치를 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="24816e3401a5d32026a6c1984cbf6e236b1b2aee" translate="yes" xml:space="preserve">
          <source>Then you would do things like</source>
          <target state="translated">그럼 당신은 같은 일을 할 것입니다</target>
        </trans-unit>
        <trans-unit id="5586eb0242a1962cfcebb66d6ca37fee8f07aeb3" translate="yes" xml:space="preserve">
          <source>Then you would have to execute the following:</source>
          <target state="translated">그런 다음 다음을 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="8301a7b7772bfde417729c8a4aeba088ba4508fc" translate="yes" xml:space="preserve">
          <source>Then, I started the foreign server:</source>
          <target state="translated">그런 다음 외부 서버를 시작했습니다.</target>
        </trans-unit>
        <trans-unit id="8fa21274eeb5b314a3cfc2e425827b3f900f5e1d" translate="yes" xml:space="preserve">
          <source>Then, I went back to the directory containing the newly compiled mysqld &lt;code&gt;&amp;lt;builddir&amp;gt;/sql/&lt;/code&gt;, started up gdb:</source>
          <target state="translated">그런 다음 새로 컴파일 된 mysqld &lt;code&gt;&amp;lt;builddir&amp;gt;/sql/&lt;/code&gt; 포함하는 디렉토리로 돌아갔습니다. gdb를 시작했습니다.</target>
        </trans-unit>
        <trans-unit id="a45fa3faf21de9d6f25dfbebaad0d18e27d38616" translate="yes" xml:space="preserve">
          <source>Then, apply the incremental changes to the base full backup:</source>
          <target state="translated">그런 다음 증분 변경 사항을 기본 전체 백업에 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="32f4c29ae2773198a011bc0e6111fbdf917b80fc" translate="yes" xml:space="preserve">
          <source>Then, by importing the output file (&lt;code&gt;mysql &amp;lt; flashback.sql&lt;/code&gt;), you can flash your database/table back to the specified time or position.</source>
          <target state="translated">그런 다음 출력 파일 ( &lt;code&gt;mysql &amp;lt; flashback.sql&lt;/code&gt; ) 을 가져 와서 데이터베이스 / 테이블을 지정된 시간이나 위치로 다시 플래시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d4d0f358cdc858b6d7b4fe1537275bde3578684" translate="yes" xml:space="preserve">
          <source>Then, call the &lt;code&gt;autobake-deb.sh&lt;/code&gt; script again to build MariaDB.</source>
          <target state="translated">그런 다음 &lt;code&gt;autobake-deb.sh&lt;/code&gt; 스크립트를 다시 호출하여 MariaDB를 빌드하십시오.</target>
        </trans-unit>
        <trans-unit id="4aa3801adbe820e0f894a121e4bf1281d1a0c73a" translate="yes" xml:space="preserve">
          <source>Then, configure the following on all nodes in the cluster:</source>
          <target state="translated">그런 다음 클러스터의 모든 노드에서 다음을 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="632a708baebf7c82800b6c9b8c2dfb8d09422a83" translate="yes" xml:space="preserve">
          <source>Then, configure the listener for the Avro service to use a specific port:</source>
          <target state="translated">그런 다음 특정 포트를 사용하도록 Avro 서비스의 리스너를 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="0f7460efc9b05775e04a902a02e8ef986fa39ad9" translate="yes" xml:space="preserve">
          <source>Then, configure the replication listener:</source>
          <target state="translated">그런 다음 복제 리스너를 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="9b4d82fcec49f2512c4c36b5ec4a58a5c6d350e7" translate="yes" xml:space="preserve">
          <source>Then, connect to one of the User Modules and create a ColumnStore table with the same name and schema:</source>
          <target state="translated">그런 다음 사용자 모듈 중 하나에 연결하고 동일한 이름과 스키마로 ColumnStore 테이블을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="5b78c2f0b24c6f6e01fbae7c4edb52aaae005ffb" translate="yes" xml:space="preserve">
          <source>Then, copy the &lt;code&gt;.ibd&lt;/code&gt; and &lt;code&gt;.cfg&lt;/code&gt; files for the next partition to the relevant directory for the &lt;code&gt;t2_placeholder&lt;/code&gt; table on the target MariaDB Server:</source>
          <target state="translated">그런 다음 다음 파티션 의 &lt;code&gt;.ibd&lt;/code&gt; 및 &lt;code&gt;.cfg&lt;/code&gt; 파일을 &lt;code&gt;t2_placeholder&lt;/code&gt; 의 관련 디렉토리로 복사하십시오. 대상 MariaDB 서버 테이블 하십시오.</target>
        </trans-unit>
        <trans-unit id="e7c13a6daf51f129d2814c254ba3035f5c13a5d6" translate="yes" xml:space="preserve">
          <source>Then, copy the &lt;code&gt;.ibd&lt;/code&gt; and &lt;code&gt;.cfg&lt;/code&gt; files from the original server to the relevant directory on the target MariaDB Server:</source>
          <target state="translated">그런 다음 &lt;code&gt;.ibd&lt;/code&gt; 및 &lt;code&gt;.cfg&lt;/code&gt; 파일을 원래 서버에서 대상 MariaDB 서버의 관련 디렉토리로 복사하십시오 .</target>
        </trans-unit>
        <trans-unit id="ce8d60d54d422c6dcfb5729cafe857737b0f3636" translate="yes" xml:space="preserve">
          <source>Then, copy the certificate and keys to all nodes in the cluster.</source>
          <target state="translated">그런 다음 인증서와 키를 클러스터의 모든 노드에 복사하십시오.</target>
        </trans-unit>
        <trans-unit id="01d56aaf705aae8ceef1c03dd5ff80fc821aaceb" translate="yes" xml:space="preserve">
          <source>Then, create a replication user for MaxScale and the slave MariaDB Servers and grant the relevant privileges to the user:</source>
          <target state="translated">그런 다음 MaxScale 및 슬레이브 MariaDB 서버에 대한 복제 사용자를 생성하고 사용자에게 관련 권한을 부여하십시오.</target>
        </trans-unit>
        <trans-unit id="afb98742f56e67b6cc68fdc268765333e0f55b6c" translate="yes" xml:space="preserve">
          <source>Then, create a write user for MaxScale on the same servers.</source>
          <target state="translated">그런 다음 동일한 서버에서 MaxScale의 쓰기 사용자를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="a158fa4ad0a4a08b17a1da149dd3cc3f73a080dd" translate="yes" xml:space="preserve">
          <source>Then, ensure that the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#datadir&quot;&gt;datadir&lt;/a&gt;&lt;/code&gt; is empty.</source>
          <target state="translated">그런 다음 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#datadir&quot;&gt;datadir&lt;/a&gt;&lt;/code&gt; 이 이 비어 .</target>
        </trans-unit>
        <trans-unit id="dd154206c7b572457eebc2eec03c87cc837a4fd8" translate="yes" xml:space="preserve">
          <source>Then, execute the &lt;code&gt;&lt;a href=&quot;../change-master-to/index&quot;&gt;CHANGE MASTER&lt;/a&gt;&lt;/code&gt; statement to configure the slave to use TLS. For example:</source>
          <target state="translated">그런 다음 &lt;code&gt;&lt;a href=&quot;../change-master-to/index&quot;&gt;CHANGE MASTER&lt;/a&gt;&lt;/code&gt; 를 실행하십시오. 문을 슬레이브가 TLS를 사용하도록 구성하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c07826feebdf3c7f4e25b72f353036bb5becc1b1" translate="yes" xml:space="preserve">
          <source>Then, execute the following command:</source>
          <target state="translated">그런 다음 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="fee9ecb61dfe86a3410e4bacb899885886f03212" translate="yes" xml:space="preserve">
          <source>Then, execute the following:</source>
          <target state="translated">그런 다음 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="0979400428928c7e501705c5fbf9a9d303ae4654" translate="yes" xml:space="preserve">
          <source>Then, export the newly created user to the keytab file using the &lt;code&gt;&lt;a href=&quot;https://web.mit.edu/kerberos/krb5-1.12/doc/admin/admin_commands/kadmin_local.html&quot;&gt;kadmin&lt;/a&gt;&lt;/code&gt; utility. For example:</source>
          <target state="translated">그런 다음 &lt;code&gt;&lt;a href=&quot;https://web.mit.edu/kerberos/krb5-1.12/doc/admin/admin_commands/kadmin_local.html&quot;&gt;kadmin&lt;/a&gt;&lt;/code&gt; 유틸리티를 사용하여 새로 작성된 사용자를 키탭 파일로 내보내십시오 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="316de7202184dfba63b5d20c22e058c0285fb1ff" translate="yes" xml:space="preserve">
          <source>Then, for each node, perform the following steps:</source>
          <target state="translated">그런 다음 각 노드에 대해 다음 단계를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="7fef33717a271b1fc9a5621a22bd9f19de261835" translate="yes" xml:space="preserve">
          <source>Then, for fixed-size columns (integer, date[time], decimal) it is key_length as shown by &lt;code&gt;EXPLAIN&lt;/code&gt;. For VARCHAR columns, determining the length is tricky (It depends on the values stored in the table. Note that MyRocks encodes VARCHARs with &quot;Variable-Length Space-Padded Encoding&quot; format).</source>
          <target state="translated">그런 다음 고정 크기 열 (정수, 날짜 [시간], 10 진수)의 경우 &lt;code&gt;EXPLAIN&lt;/code&gt; 에 표시된대로 key_length 입니다. VARCHAR 열의 경우 길이를 결정하는 것이 까다 롭습니다 (표에 저장된 값에 따라 다릅니다. MyRocks는 &quot;가변 길이의 공백-패치 인코딩&quot;형식으로 VARCHAR을 인코딩합니다).</target>
        </trans-unit>
        <trans-unit id="ac6f7401f00e03c33cd952b610af47f0ef10ef34" translate="yes" xml:space="preserve">
          <source>Then, for instance:</source>
          <target state="translated">그런 다음 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4025ada6101e231cb773ef6129d5a9e05778936e" translate="yes" xml:space="preserve">
          <source>Then, get back to the window with VM, and run in VM:</source>
          <target state="translated">그런 다음 VM이있는 창으로 돌아가서 VM에서 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="8ef893e66f7f36548bb56517599e140556b338ca" translate="yes" xml:space="preserve">
          <source>Then, if we grep the database directory in the data directory for the newly created &lt;code&gt;t2&lt;/code&gt; table, we can see a number of &lt;code&gt;.ibd&lt;/code&gt; and &lt;code&gt;.cfg&lt;/code&gt; files for the table:</source>
          <target state="translated">그런 다음 새로 만든 &lt;code&gt;t2&lt;/code&gt; 테이블 의 데이터 디렉토리에서 데이터베이스 디렉토리를 grep하면 많은 &lt;code&gt;.ibd&lt;/code&gt; 및 &lt;code&gt;.cfg&lt;/code&gt; 를 볼 수 있습니다. 파일을 .</target>
        </trans-unit>
        <trans-unit id="2f46859cc4c69440b8a5916dbde7805f5f035efc" translate="yes" xml:space="preserve">
          <source>Then, in &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt; and later, execute the following command:</source>
          <target state="translated">그런 다음 &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt; 이상에서 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="f7d42602576aa1e2be0854e2c4568a9415eddcaf" translate="yes" xml:space="preserve">
          <source>Then, issue a &lt;code&gt;&lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt;&lt;/code&gt; statement to see what data is available on the MariaDB Servers for the OLTP operations:</source>
          <target state="translated">그런 다음 &lt;code&gt;&lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt;&lt;/code&gt; 문을 실행하여 OLTP 조작을 위해 MariaDB 서버에서 사용 가능한 데이터를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="473eedeb96a68e04104adb20271dec5f1ca9b47d" translate="yes" xml:space="preserve">
          <source>Then, issue the following statements to create the CDC user and grant it the necessary privileges:</source>
          <target state="translated">그런 다음, 다음 명령문을 발행하여 CDC 사용자를 작성하고 필요한 권한을 부여하십시오.</target>
        </trans-unit>
        <trans-unit id="2e5153391036bc9c4709e3d179070588c993c5f3" translate="yes" xml:space="preserve">
          <source>Then, it's time to transfer the partition from the placeholder to the target table. This can be done with an &lt;code&gt;&lt;a href=&quot;../alter-table/index#exchange-partition&quot;&gt;ALTER TABLE... EXCHANGE PARTITION&lt;/a&gt;&lt;/code&gt; statement:</source>
          <target state="translated">그런 다음 자리 표시 자에서 대상 테이블로 파티션을 전송해야합니다. 이것은 &lt;code&gt;&lt;a href=&quot;../alter-table/index#exchange-partition&quot;&gt;ALTER TABLE... EXCHANGE PARTITION&lt;/a&gt;&lt;/code&gt; 으로 수행 할 수 있습니다. 문 .</target>
        </trans-unit>
        <trans-unit id="5f899263fef2f7762792f156f129d657472810be" translate="yes" xml:space="preserve">
          <source>Then, modify the schema to add a balance column to the &lt;code&gt;bank.loan&lt;/code&gt; table. This column will be used in the ColumnStore examples below.</source>
          <target state="translated">그런 다음 &lt;code&gt;bank.loan&lt;/code&gt; 잔액 열을 추가하도록 스키마를 수정하십시오. 테이블에 . 이 열은 아래의 ColumnStore 예에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="53cc6fcc9c93f089320e5bde9e3347c27ed27c04" translate="yes" xml:space="preserve">
          <source>Then, on all dnf distributions:</source>
          <target state="translated">그런 다음 모든 dnf 배포에서 :</target>
        </trans-unit>
        <trans-unit id="a3b1670afa526ba47f1cd01eb6797a23fa1925c2" translate="yes" xml:space="preserve">
          <source>Then, on the server that will be connecting to the foreign host (client), you create a federated table without specifying the table structure:</source>
          <target state="translated">그런 다음 외부 호스트 (클라이언트)에 연결할 서버에서 테이블 구조를 지정하지 않고 연합 테이블을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="121c8450332450fb4baab53e18d687102dcca9e7" translate="yes" xml:space="preserve">
          <source>Then, once the files are in the proper directory on the target server, use &lt;code&gt;&lt;a href=&quot;../alter-table/index#import-tablespace&quot;&gt;ALTER TABLE ... IMPORT TABLESPACE&lt;/a&gt;&lt;/code&gt; to import the new table's tablespace:</source>
          <target state="translated">그런 다음 파일이 대상 서버의 올바른 디렉토리에 있으면 &lt;code&gt;&lt;a href=&quot;../alter-table/index#import-tablespace&quot;&gt;ALTER TABLE ... IMPORT TABLESPACE&lt;/a&gt;&lt;/code&gt; 를 사용하여 새 테이블의 테이블 스페이스를 가져 오십시오.</target>
        </trans-unit>
        <trans-unit id="610be8188388cc5a618ceaae71cf8eb2d0bac264" translate="yes" xml:space="preserve">
          <source>Then, once the files are in the proper directory on the target server, we need to use &lt;code&gt;&lt;a href=&quot;../alter-table/index#import-tablespace&quot;&gt;ALTER TABLE ... IMPORT TABLESPACE&lt;/a&gt;&lt;/code&gt; to import the new table's tablespace:</source>
          <target state="translated">그런 다음 파일이 대상 서버의 올바른 디렉토리에 있으면 &lt;code&gt;&lt;a href=&quot;../alter-table/index#import-tablespace&quot;&gt;ALTER TABLE ... IMPORT TABLESPACE&lt;/a&gt;&lt;/code&gt; 를 사용하여 새 테이블의 테이블 스페이스를 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="5d375436ff3809bb1392ad4f93444844bf06d81f" translate="yes" xml:space="preserve">
          <source>Then, once we've copied the files, we can release the lock with &lt;code&gt;&lt;a href=&quot;../lock-tables-and-unlock-tables/index&quot;&gt;UNLOCK TABLES&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">그런 다음 파일을 복사하면 &lt;code&gt;&lt;a href=&quot;../lock-tables-and-unlock-tables/index&quot;&gt;UNLOCK TABLES&lt;/a&gt;&lt;/code&gt; 로 잠금을 해제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c0f230e625780cca1919738e3233d8739dcac8cf" translate="yes" xml:space="preserve">
          <source>Then, once you've copied the files, you can release the lock with &lt;code&gt;&lt;a href=&quot;../lock-tables-and-unlock-tables/index&quot;&gt;UNLOCK TABLES&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">그런 다음 파일을 복사 한 후에는 &lt;code&gt;&lt;a href=&quot;../lock-tables-and-unlock-tables/index&quot;&gt;UNLOCK TABLES&lt;/a&gt;&lt;/code&gt; 를 사용 하여 잠금을 해제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a51d51db1d1e4b94db75afd5e5237241641fc32a" translate="yes" xml:space="preserve">
          <source>Then, query the loan to view the updated rows on ColumnStore:</source>
          <target state="translated">그런 다음 대출을 쿼리하여 ColumnStore에서 업데이트 된 행을 봅니다.</target>
        </trans-unit>
        <trans-unit id="6e6e4953bbc6e2c65e9e3fb39149e9c5af80eed8" translate="yes" xml:space="preserve">
          <source>Then, query the updated row to see the changes on ColumnStore:</source>
          <target state="translated">그런 다음 업데이트 된 행을 쿼리하여 ColumnStore의 변경 사항을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="fe2cfa2424735c04804d4ab4017de1c80abb5f61" translate="yes" xml:space="preserve">
          <source>Then, run Mariabackup with one of the options mentioned above:</source>
          <target state="translated">그런 다음 위에서 언급 한 옵션 중 하나를 사용하여 Mariabackup을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="9d3712146f33cd627740599d6173ff324b1431ac" translate="yes" xml:space="preserve">
          <source>Then, run the &lt;code&gt;DELETE FOR PORTION&lt;/code&gt; statement:</source>
          <target state="translated">그런 다음 &lt;code&gt;DELETE FOR PORTION&lt;/code&gt; 문을 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="991127b0bd15e1ae511776ed8bc2051facfb24f7" translate="yes" xml:space="preserve">
          <source>Then, set &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-system-variables/index#encrypt_binlog&quot;&gt;encrypt_binlog=OFF&lt;/a&gt;&lt;/code&gt; in the MariaDB configuration file.</source>
          <target state="translated">그런 다음 MariaDB 구성 파일에서 &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-system-variables/index#encrypt_binlog&quot;&gt;encrypt_binlog=OFF&lt;/a&gt;&lt;/code&gt; 를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="ab7400afd35dc0e80f49add04479e48d35e7834a" translate="yes" xml:space="preserve">
          <source>Then, set &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-system-variables/index#encrypt_binlog&quot;&gt;encrypt_binlog=ON&lt;/a&gt;&lt;/code&gt; in the MariaDB configuration file.</source>
          <target state="translated">그런 다음 MariaDB 구성 파일에서 &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-system-variables/index#encrypt_binlog&quot;&gt;encrypt_binlog=ON&lt;/a&gt;&lt;/code&gt; 을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="5b30cd6b35bd22702ad782cd37c5fa5216d59340" translate="yes" xml:space="preserve">
          <source>Then, set the &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encrypt_log&quot;&gt;innodb_encrypt_log&lt;/a&gt;&lt;/code&gt; system variable to &lt;code&gt;OFF&lt;/code&gt; in a server &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;option group&lt;/a&gt; in an &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;option file&lt;/a&gt;. Once this is done, &lt;a href=&quot;../starting-and-stopping-mariadb-starting-and-stopping-mariadb/index&quot;&gt;restart&lt;/a&gt; the MariaDB Server. When the Server comes back online, it begins writing unencrypted data to the Redo Log.</source>
          <target state="translated">그런 다음 &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;옵션 파일&lt;/a&gt; 의 서버 &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;옵션 그룹&lt;/a&gt; 에서 &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encrypt_log&quot;&gt;innodb_encrypt_log&lt;/a&gt;&lt;/code&gt; 시스템 변수를 &lt;code&gt;OFF&lt;/code&gt; 로 설정 하십시오 . 이 작업이 완료되면 MariaDB 서버를 &lt;a href=&quot;../starting-and-stopping-mariadb-starting-and-stopping-mariadb/index&quot;&gt;다시 시작&lt;/a&gt; 하십시오. 서버가 다시 온라인 상태가되면 암호화되지 않은 데이터를 다시 실행 로그에 쓰기 시작합니다.</target>
        </trans-unit>
        <trans-unit id="7eeb970c96f1c416dc68ba9065b6df6426d60cd0" translate="yes" xml:space="preserve">
          <source>Then, set the &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encryption_rotate_key_age&quot;&gt;innodb_encryption_rotate_key_age&lt;/a&gt;&lt;/code&gt; system variable to &lt;code&gt;1&lt;/code&gt;:</source>
          <target state="translated">그런 다음 &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encryption_rotate_key_age&quot;&gt;innodb_encryption_rotate_key_age&lt;/a&gt;&lt;/code&gt; 시스템 변수를 &lt;code&gt;1&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="29ce3b3027fd1e3341c817a5cc611b6a9b0fda00" translate="yes" xml:space="preserve">
          <source>Then, start MariaDB. When the server starts back up, it checks to recover InnoDB in the event of a crash. Once it is back online, it begins writing encrypted data to the Redo Log.</source>
          <target state="translated">그런 다음 MariaDB를 시작하십시오. 서버가 백업을 시작하면 충돌 발생시 InnoDB 복구를 확인합니다. 다시 온라인 상태가되면 암호화 된 데이터를 Redo Log에 쓰기 시작합니다.</target>
        </trans-unit>
        <trans-unit id="167ae9a3944d689c5036e19fa72310c767d64415" translate="yes" xml:space="preserve">
          <source>Then, start MaxScale:</source>
          <target state="translated">그런 다음 MaxScale을 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="47ce1dfc3ae04527c6ea8d1d306965a5580503fa" translate="yes" xml:space="preserve">
          <source>Then, start the replication slave:</source>
          <target state="translated">그런 다음 복제 슬레이브를 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="3123d6addef22a12e86dc2d0f8f62b1515a85d2f" translate="yes" xml:space="preserve">
          <source>Then, start the server.</source>
          <target state="translated">그런 다음 서버를 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="0106050e49f95d161f25da90e6b097132092258f" translate="yes" xml:space="preserve">
          <source>Then, start the slave:</source>
          <target state="translated">그런 다음 슬레이브를 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="d3689b421563cb89e259d01e91c358d62c1b6486" translate="yes" xml:space="preserve">
          <source>Then, take the snapshot.</source>
          <target state="translated">그런 다음 스냅 샷을 찍습니다.</target>
        </trans-unit>
        <trans-unit id="083ca3adb2243389c0309ae4a6d447eb51441849" translate="yes" xml:space="preserve">
          <source>Then, the file should be formatted or converted to pretty=0. Also, it should not be used directly by JSON UDFs because they parse the whole file, even when only a subset is used. Instead, it should be used by a JSON table created on it. Indeed, JSON tables do not parse the whole document but just the item corresponding to the row they are working on. In addition, indexing can be used by the table as explained previously on this page.</source>
          <target state="translated">그런 다음 파일 형식을 지정하거나 pretty = 0으로 변환해야합니다. 또한 서브 세트 만 사용하는 경우에도 전체 파일을 구문 분석하므로 JSON UDF에서 직접 사용하면 안됩니다. 대신, 생성 된 JSON 테이블에서 사용해야합니다. 실제로 JSON 테이블은 전체 문서를 구문 분석하지 않고 작업중인 행에 해당하는 항목 만 구문 분석합니다. 또한이 페이지에서 앞서 설명한대로 테이블에서 인덱싱을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86bf75cf4561ec9f6260a2f7e177ef7582c9c072" translate="yes" xml:space="preserve">
          <source>Then, this pseudo-code is a good way to delete the rows older than 30 days:</source>
          <target state="translated">그런 다음이 의사 코드는 30 일이 지난 행을 삭제하는 좋은 방법입니다.</target>
        </trans-unit>
        <trans-unit id="cd66461e23be67f240cb55ccd5637f9e3c6a3111" translate="yes" xml:space="preserve">
          <source>Then, to upgrade MariaDB Server:</source>
          <target state="translated">그런 다음 MariaDB 서버를 업그레이드하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="de68fdd2a72be85175b480f8982208291bbf60a9" translate="yes" xml:space="preserve">
          <source>Then, use &lt;code&gt;&lt;a href=&quot;../alter-table/index#discard-tablespace&quot;&gt;ALTER TABLE ... DISCARD TABLESPACE&lt;/a&gt;&lt;/code&gt; to discard the new table's tablespace:</source>
          <target state="translated">그런 다음 &lt;code&gt;&lt;a href=&quot;../alter-table/index#discard-tablespace&quot;&gt;ALTER TABLE ... DISCARD TABLESPACE&lt;/a&gt;&lt;/code&gt; 를 사용하여 새 테이블의 테이블 스페이스를 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="c31d1ec69d8400632d598733abd5ae1361524cfc" translate="yes" xml:space="preserve">
          <source>Then, use the &lt;code&gt;&lt;a href=&quot;../source/index&quot;&gt;SOURCE&lt;/a&gt;&lt;/code&gt; command to load the &lt;code&gt;create-db-cs.sql&lt;/code&gt; file:</source>
          <target state="translated">그런 다음 &lt;code&gt;&lt;a href=&quot;../source/index&quot;&gt;SOURCE&lt;/a&gt;&lt;/code&gt; 명령을 사용하여 &lt;code&gt;create-db-cs.sql&lt;/code&gt; 파일 을로드 하십시오.</target>
        </trans-unit>
        <trans-unit id="e89054762176715f68f981ece9b123e7b8636d3d" translate="yes" xml:space="preserve">
          <source>Then, using this table as a model, we need to create a placeholder of this table with the same structure that does not use partitioning. This can be done with a &lt;code&gt;&lt;a href=&quot;../create-table/index#create-select&quot;&gt;CREATE TABLE... AS SELECT&lt;/a&gt;&lt;/code&gt; statement:</source>
          <target state="translated">그런 다음이 테이블을 모델로 사용하여 파티셔닝을 사용하지 않는 동일한 구조로이 테이블의 자리 표시자를 만들어야합니다. &lt;code&gt;&lt;a href=&quot;../create-table/index#create-select&quot;&gt;CREATE TABLE... AS SELECT&lt;/a&gt;&lt;/code&gt; 문 으로 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="386823360e88428a1cfc7dc1258f1be38a8d0357" translate="yes" xml:space="preserve">
          <source>Then, we can remove the placeholder table from the database:</source>
          <target state="translated">그런 다음 데이터베이스에서 자리 표시 자 테이블을 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f35f10fd9ad2e29d5a91f5a6ba92e5daf528038f" translate="yes" xml:space="preserve">
          <source>Then, we can see the warnings:</source>
          <target state="translated">그러면 경고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="53df7297e47e492a509a810e3b3829250b57e694" translate="yes" xml:space="preserve">
          <source>Then, we could search the data file that belongs to &lt;code&gt;db1.aria_tab&lt;/code&gt; for &lt;code&gt;str1&lt;/code&gt; using a command-line tool, such as &lt;a href=&quot;https://linux.die.net/man/1/strings&quot;&gt;strings&lt;/a&gt;:</source>
          <target state="translated">그런 다음 &lt;a href=&quot;https://linux.die.net/man/1/strings&quot;&gt;문자열&lt;/a&gt; 과 같은 명령 행 도구를 사용하여 &lt;code&gt;db1.aria_tab&lt;/code&gt; 에 속하는 데이터 파일 에서 &lt;code&gt;str1&lt;/code&gt; 을 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9e388f5601bdbd60c741c0dda7e781410998a7e2" translate="yes" xml:space="preserve">
          <source>Then, we need to export the partitioned tablespace from the original server, which follows the same process as exporting non-partitioned tablespaces. That means that we need to use the &lt;code&gt;&lt;a href=&quot;../flush-tables-for-export/index&quot;&gt;FLUSH TABLES ... FOR EXPORT&lt;/a&gt;&lt;/code&gt; statement on the target table:</source>
          <target state="translated">그런 다음 파티션되지 않은 테이블 스페이스를 내보내는 것과 동일한 프로세스를 따르는 원래 서버에서 파티션 된 테이블 스페이스를 내 보내야합니다. 즉 , 대상 테이블 에서 &lt;code&gt;&lt;a href=&quot;../flush-tables-for-export/index&quot;&gt;FLUSH TABLES ... FOR EXPORT&lt;/a&gt;&lt;/code&gt; 문 을 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="dd4de8b1589f5f9eabbbf05e07cf702a0d64766b" translate="yes" xml:space="preserve">
          <source>Then, we need to import the partitioned tablespaces onto the target server. The import process for partitioned tables is more complicated than the import process for non-partitioned tables. To start with, if it doesn't already exist, then we need to create a partitioned table on the target server that matches the partitioned table on the original server:</source>
          <target state="translated">그런 다음 파티션 된 테이블 스페이스를 대상 서버로 가져와야합니다. 파티션 된 테이블의 가져 오기 프로세스는 파티션되지 않은 테이블의 가져 오기 프로세스보다 더 복잡합니다. 먼저 존재하지 않는 경우 대상 서버에서 원래 서버의 파티션 된 테이블과 일치하는 파티션 된 테이블을 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="9f541acaf66a15878047ad8a5393cb11248f7441" translate="yes" xml:space="preserve">
          <source>Then, when executing for instance:</source>
          <target state="translated">그런 다음 예를 들어 실행할 때 :</target>
        </trans-unit>
        <trans-unit id="58f3355216568a55636004382eb2ae7888a25771" translate="yes" xml:space="preserve">
          <source>Then, while our connection still holds the lock on the table, we need to copy the tablespace files and the metadata files to a safe directory:</source>
          <target state="translated">그런 다음 연결은 여전히 ​​테이블에 대한 잠금을 유지하지만 테이블 스페이스 파일과 메타 데이터 파일을 안전한 디렉토리에 복사해야합니다.</target>
        </trans-unit>
        <trans-unit id="8520487ac81c74e48078908728c891ca0af04cc4" translate="yes" xml:space="preserve">
          <source>Then, while your connection still holds the lock on the table, copy the tablespace file and the metadata file to a safe directory:</source>
          <target state="translated">그런 다음 연결이 여전히 테이블에 대한 잠금을 보유한 상태에서 테이블 스페이스 파일과 메타 데이터 파일을 안전한 디렉토리에 복사하십시오.</target>
        </trans-unit>
        <trans-unit id="9111c9c3f952074a86a235de5c357140cab338b7" translate="yes" xml:space="preserve">
          <source>Then, within the (gdb) prompt:</source>
          <target state="translated">그런 다음 (gdb) 프롬프트에서 :</target>
        </trans-unit>
        <trans-unit id="855a625d5622ce07744c7e6185c95c18b4ae193e" translate="yes" xml:space="preserve">
          <source>Then, you can issue a similar &lt;code&gt;&lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt;&lt;/code&gt; statement to the &lt;code&gt;test.t6&lt;/code&gt; table on either of the User Modules for MariaDB ColumnStore to see that the data is now available for OLAP operations:</source>
          <target state="translated">그런 다음 MariaDB ColumnStore의 사용자 모듈 중 하나 에서 &lt;code&gt;test.t6&lt;/code&gt; 테이블 과 유사한 &lt;code&gt;&lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt;&lt;/code&gt; 문을 발행하여 OLAP 조작에 데이터를 사용할 수 있는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0506b7c994670a967019dcfc6ae11f9c4281823" translate="yes" xml:space="preserve">
          <source>Then, you may need to fix the file permissions.</source>
          <target state="translated">그런 다음 파일 권한을 수정해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="87621a93aa764aba4c766c7dd5e7354c1ae9c5de" translate="yes" xml:space="preserve">
          <source>Theoretically, a superuser can read the memory of the MariaDB server process to read the decrypted keys or restart MariaDB with password authentication disabled in order to dump data, or add new users to MariaDB in order to allow a user to connect and dump the data. Resolving these issues is beyond the scope of this document. A user who gains root access to your operating system or root access to your MariaDB server will have the ability to decrypt your data. Plan accordingly.</source>
          <target state="translated">이론적으로, 수퍼 유저는 MariaDB 서버 프로세스의 메모리를 읽어 해독 된 키를 읽거나 암호 인증이 비활성화 된 상태에서 MariaDB를 재시작하여 데이터를 덤프하거나 MariaDB에 새 사용자를 추가하여 사용자가 데이터를 연결하고 덤프 할 수 있도록합니다. 이러한 문제를 해결하는 것은이 문서의 범위를 벗어납니다. 운영 체제에 대한 루트 액세스 권한 또는 MariaDB 서버에 대한 루트 액세스 권한을 가진 사용자는 데이터를 해독 할 수 있습니다. 그에 따라 계획하십시오.</target>
        </trans-unit>
        <trans-unit id="55a2b5b702972442fe31b2dbbe73d84810289242" translate="yes" xml:space="preserve">
          <source>Theoretically, synchronous replication has a number of advantages over asynchronous replication:</source>
          <target state="translated">이론적으로 동기 복제는 비동기 복제에 비해 여러 가지 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c66920867706c5e80cd09d337f58c406c181ea2" translate="yes" xml:space="preserve">
          <source>There are (I think) some other &quot;delays&quot; that avoid some I/O.</source>
          <target state="translated">I / O를 피하는 다른 &quot;지연&quot;이 있다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="d4f4d3fde055fc031dc8f362ac5faab0fadc1a30" translate="yes" xml:space="preserve">
          <source>There are 2 methods for perform the System Configuration and Installation:</source>
          <target state="translated">시스템 구성 및 설치를 수행하는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0cd6049ef58802e5d537988bb0b8859d33984051" translate="yes" xml:space="preserve">
          <source>There are 2 options when configuring the System Module Type: separate and combined</source>
          <target state="translated">시스템 모듈 유형을 구성 할 때 두 가지 옵션이 있습니다 : 개별 및 결합</target>
        </trans-unit>
        <trans-unit id="8b30ef0c65f18203c37ac9c2fed341bb93b099f3" translate="yes" xml:space="preserve">
          <source>There are 2 options when configuring the System Server Type: single and multi</source>
          <target state="translated">시스템 서버 유형을 구성 할 때 단일 및 다중의 두 가지 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="077b0c2ba55432b50c1fbe00995dee362e172387" translate="yes" xml:space="preserve">
          <source>There are 2 options when configuring the storage: internal and external</source>
          <target state="translated">스토리지를 구성 할 때 내부 및 외부의 두 가지 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ca3a12e0be97f3d2e470b86fefe9e6a34b7223b" translate="yes" xml:space="preserve">
          <source>There are 3 Quick Launch Tools that can be used to launch basic systems. These are 1 step command tool where you provide the number of modules or amazon instances and the tool will take care of the rest.</source>
          <target state="translated">기본 시스템을 시작하는 데 사용할 수있는 3 가지 빠른 실행 도구가 있습니다. 이들은 1 단계 명령 도구로, 여러 개의 모듈 또는 Amazon 인스턴스를 제공하고 나머지 도구를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="8ea71e26dc56d03d236a894d949df1f48bbfbd78" translate="yes" xml:space="preserve">
          <source>There are 4 versions of the TLS protocol:</source>
          <target state="translated">TLS 프로토콜에는 4 가지 버전이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d7edd90fe78d81fc9d80726fbe9b0fd210112c0" translate="yes" xml:space="preserve">
          <source>There are &lt;code&gt;NO RELEASE&lt;/code&gt; and &lt;code&gt;AND NO CHAIN&lt;/code&gt; options. By default, commits do not &lt;code&gt;RELEASE&lt;/code&gt; or &lt;code&gt;CHAIN&lt;/code&gt;, but it's possible to change this default behavior with the &lt;a href=&quot;../server-system-variables/index#completion_type&quot;&gt;completion_type&lt;/a&gt; server system variable. In this case, the &lt;code&gt;AND NO CHAIN&lt;/code&gt; and &lt;code&gt;NO RELEASE&lt;/code&gt; options override the server default.</source>
          <target state="translated">있습니다 &lt;code&gt;NO RELEASE&lt;/code&gt; 및 &lt;code&gt;AND NO CHAIN&lt;/code&gt; 옵션. 기본적으로 커밋은 &lt;code&gt;RELEASE&lt;/code&gt; 또는 &lt;code&gt;CHAIN&lt;/code&gt; 이 아니지만 &lt;a href=&quot;../server-system-variables/index#completion_type&quot;&gt;completion_type&lt;/a&gt; 서버 시스템 변수 를 사용하여이 기본 동작을 변경할 수 있습니다 . 이 경우 &lt;code&gt;AND NO CHAIN&lt;/code&gt; 및 &lt;code&gt;NO RELEASE&lt;/code&gt; 옵션은 서버 기본값을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="b56e93072ee20257abac8cc6effcf93a2c3f2c4f" translate="yes" xml:space="preserve">
          <source>There are a a few different ways to move the table to MariaDB:</source>
          <target state="translated">테이블을 MariaDB로 옮기는 몇 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="fbeb5b9ada54a23fe14cd4f4c1daa392a2e0a37a" translate="yes" xml:space="preserve">
          <source>There are a a few different ways to solve this:</source>
          <target state="translated">이 문제를 해결하는 몇 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2b47318491575d8816bd42d0f209ca680d6d5c1" translate="yes" xml:space="preserve">
          <source>There are a few heuristics to try to avoid needless conflicts. If a transaction executed a row lock wait on the master, it will not be run in parallel on the slave. Transactions can also be marked explicitly as potentially conflicting on the master, by setting the variable &lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#skip_parallel_replication&quot;&gt;@@skip_parallel_replication&lt;/a&gt;. More such heuristics may be added in later MariaDB versions. There is a further &lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#slave_parallel_mode&quot;&gt;--slave-parallel-mode&lt;/a&gt; called &quot;aggressive&quot;, where these heuristics are disabled, allowing even more transactions to be applied in parallel.</source>
          <target state="translated">불필요한 갈등을 피하기위한 휴리스틱이 몇 가지 있습니다. 트랜잭션이 마스터에서 행 잠금 대기를 실행 한 경우 슬레이브에서 병렬로 실행되지 않습니다. 변수 &lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#skip_parallel_replication&quot;&gt;@@ skip_parallel_replication&lt;/a&gt; 을 설정하여 트랜잭션이 마스터에서 충돌 가능성이있는 것으로 명시 적으로 표시 될 수도 있습니다 . 더 많은 휴리스틱이 이후 MariaDB 버전에 추가 될 수 있습니다. &quot;공격적&quot;이라는 추가- &lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#slave_parallel_mode&quot;&gt;슬레이브-병렬 모드가&lt;/a&gt; 있으며, 이러한 휴리스틱은 비활성화되어 훨씬 더 많은 트랜잭션을 병렬로 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98fedd12346cd2c5226be06db14b5e4023d99e4c" translate="yes" xml:space="preserve">
          <source>There are a few optional pieces of information that can be included in the slow query log for each query. This optional information can be included by configuring the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#log_slow_verbosity&quot;&gt;log_slow_verbosity&lt;/a&gt;&lt;/code&gt; system variable. It can be changed dynamically with &lt;code&gt;&lt;a href=&quot;../set/index#global-session&quot;&gt;SET GLOBAL&lt;/a&gt;&lt;/code&gt;. For example:</source>
          <target state="translated">각 쿼리의 느린 쿼리 로그에 포함될 수있는 몇 가지 선택적 정보가 있습니다. 이 선택적 정보는 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#log_slow_verbosity&quot;&gt;log_slow_verbosity&lt;/a&gt;&lt;/code&gt; 시스템 변수를 구성하여 포함 할 수 있습니다 . &lt;code&gt;&lt;a href=&quot;../set/index#global-session&quot;&gt;SET GLOBAL&lt;/a&gt;&lt;/code&gt; 을 사용 하여 동적으로 변경할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b07b437c236b3e3d5092af2dfafc25227311f73f" translate="yes" xml:space="preserve">
          <source>There are a few status variables related to the &lt;a href=&quot;../server_audit-mariadb-audit-plugin/index&quot;&gt;MariaDB Audit Plugin&lt;/a&gt;, once it has been &lt;a href=&quot;../mariadb-audit-plugin-entitymdashentity-installation/index&quot;&gt;installed&lt;/a&gt;. These variables can be displayed using the &lt;a href=&quot;../show-status/index&quot;&gt;SHOW STATUS&lt;/a&gt; statement like so:</source>
          <target state="translated">일단 &lt;a href=&quot;../mariadb-audit-plugin-entitymdashentity-installation/index&quot;&gt;설치된 &lt;/a&gt;&lt;a href=&quot;../server_audit-mariadb-audit-plugin/index&quot;&gt;MariaDB 감사 플러그인&lt;/a&gt; 과 관련된 몇 가지 상태 변수 가 있습니다. 이러한 변수는 &lt;a href=&quot;../show-status/index&quot;&gt;SHOW STATUS&lt;/a&gt; 문을 사용하여 다음 과 같이 표시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dcb7e669ac6384979b8b3ab555667a96bf0bf38b" translate="yes" xml:space="preserve">
          <source>There are a few variables that will cause MyRocks to report certain pre-defined estimate numbers to the optimizer:</source>
          <target state="translated">MyRocks가 사전 정의 된 특정 추정값을 옵티 마이저에보고하게하는 몇 가지 변수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a127c526839af017a26319d8d12a21d2f682fb8" translate="yes" xml:space="preserve">
          <source>There are a few ways to see the full list of server system variables:</source>
          <target state="translated">서버 시스템 변수의 전체 목록을 보는 몇 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b0a96c0c81730aabf6e7e4aeda2052e8c703b26" translate="yes" xml:space="preserve">
          <source>There are a few ways to work around this problem.</source>
          <target state="translated">이 문제를 해결하는 몇 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5c40da0224a2912960b5872356823c9cf3d7b39" translate="yes" xml:space="preserve">
          <source>There are a number of &lt;a href=&quot;../server-system-variables/index&quot;&gt;system variables&lt;/a&gt; that are useful to adjust when running myisamchk. They will increase memory usage, and since some are per-session variables, you don't want to increase the general value, but you can either pass an increased value to myisamchk as a commandline option, or with a [myisamchk] section in your &lt;a href=&quot;../configuring-mariadb-with-mycnf/index&quot;&gt;my.cnf&lt;/a&gt; file.</source>
          <target state="translated">myisamchk를 실행할 때 조정하는 데 유용한 여러 &lt;a href=&quot;../server-system-variables/index&quot;&gt;시스템 변수&lt;/a&gt; 가 있습니다. 메모리 사용량이 증가하고 일부는 세션 당 변수이므로 일반 값을 높이고 싶지는 않지만 명령 줄 옵션으로 myisamchk에 값을 전달하거나 [myisamchk] 섹션을 사용하여 &lt;a href=&quot;../configuring-mariadb-with-mycnf/index&quot;&gt;my.cnf&lt;/a&gt; 파일.</target>
        </trans-unit>
        <trans-unit id="a265b8fd4e37e3c8e50081fbf9c3abd298414ab9" translate="yes" xml:space="preserve">
          <source>There are a number of different kinds of compression in MariaDB</source>
          <target state="translated">MariaDB에는 여러 종류의 압축이 있습니다.</target>
        </trans-unit>
        <trans-unit id="08b53f69fbd6739e7afe705e216c0da4b8b12f19" translate="yes" xml:space="preserve">
          <source>There are a number of issues to consider when looking at improving the security of your MariaDB installation. These include:</source>
          <target state="translated">MariaDB 설치의 보안 향상을 고려할 때 고려해야 할 많은 문제가 있습니다. 여기에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="0e3f01093c577ccd94f5651e6bc4385eaead9961" translate="yes" xml:space="preserve">
          <source>There are a number of limitations regarding &lt;a href=&quot;../subqueries/index&quot;&gt;subqueries&lt;/a&gt;, which are discussed below.</source>
          <target state="translated">&lt;a href=&quot;../subqueries/index&quot;&gt;하위 쿼리&lt;/a&gt; 와 관련하여 여러 가지 제한 사항 이 있으며 아래에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="c3b13b0172f5f6840f71ad3c82ddba69eb077a85" translate="yes" xml:space="preserve">
          <source>There are a number of limitations regarding subqueries.</source>
          <target state="translated">하위 쿼리와 관련하여 여러 가지 제한 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbb3cb66de818f1315e51e5840e26522e9f0b4e7" translate="yes" xml:space="preserve">
          <source>There are a number of numeric data types:</source>
          <target state="translated">숫자 데이터 유형에는 여러 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="fec011e477873482331148b9310579208115ed71" translate="yes" xml:space="preserve">
          <source>There are a number of options available in &lt;code&gt;Mariabackup&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Mariabackup&lt;/code&gt; 에는 여러 가지 옵션이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7de7ce991962093d566c0c99ca91ca57e65f57b1" translate="yes" xml:space="preserve">
          <source>There are a number of options that may impact or break replication. Check the following settings to avoid problems.</source>
          <target state="translated">복제에 영향을 주거나 중단 할 수있는 여러 가지 옵션이 있습니다. 문제를 방지하려면 다음 설정을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="2cb7d5ae35f9f9f48138bd9bc879e3f323af33ad" translate="yes" xml:space="preserve">
          <source>There are a number of other rules for identifiers:</source>
          <target state="translated">식별자에 대한 여러 가지 다른 규칙이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0829330a1333cf042f3a4eedb99777603086e1e9" translate="yes" xml:space="preserve">
          <source>There are a number of reasons why an addModule command might fail, missing dependent packages, password or ssh key is not setup, etc. Here are some things to investigate when this 'mcsadmin' command does fail.</source>
          <target state="translated">addModule 명령이 실패하거나 종속 패키지가 누락되거나 암호 또는 ssh 키가 설정되지 않은 등 여러 가지 이유가 있습니다.이 'mcsadmin'명령이 실패한 경우 조사해야 할 몇 가지 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f72043db1340fc9feb5c009998a25cfceeebfba6" translate="yes" xml:space="preserve">
          <source>There are a number of shortcuts to match particular preset character classes. These are matched with the &lt;code&gt;[:character_class:]&lt;/code&gt; pattern (inside a &lt;code&gt;[]&lt;/code&gt; set). The following character classes exist:</source>
          <target state="translated">특정 사전 설정 문자 클래스와 일치하는 여러 가지 단축키가 있습니다. 이들은 &lt;code&gt;[:character_class:]&lt;/code&gt; 패턴 과 일치합니다 ( &lt;code&gt;[]&lt;/code&gt; 세트 내부 ). 다음과 같은 문자 클래스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="27d72fb2b07c6645c2a6ba36e273060449a86a1a" translate="yes" xml:space="preserve">
          <source>There are a number of system variables related to system-versioned tables:</source>
          <target state="translated">시스템 버전 테이블과 관련된 여러 시스템 변수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ebc0699a150db1dd71447d5916cc68d8fde2fa5" translate="yes" xml:space="preserve">
          <source>There are a number of system variables that affect histograms.</source>
          <target state="translated">히스토그램에 영향을 미치는 여러 시스템 변수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d345424f2ca2caca7880ae2039352e8332c99ee2" translate="yes" xml:space="preserve">
          <source>There are a number of tools for working with MyISAM tables. These include:</source>
          <target state="translated">MyISAM 테이블 작업을위한 여러 도구가 있습니다. 여기에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="25d3cc1c4998274e5881baadc25fbd2f238f61e8" translate="yes" xml:space="preserve">
          <source>There are a number of variables that cannot be set on per-query basis. These include:</source>
          <target state="translated">쿼리별로 설정할 수없는 변수가 많이 있습니다. 여기에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="17e4748491091028c49b448bd3ea87e2edfac43e" translate="yes" xml:space="preserve">
          <source>There are a number of variables that control persistent statistics:</source>
          <target state="translated">지속적 통계를 제어하는 ​​여러 변수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c24e407a3b527179c3835c5b59f60c475005ed5e" translate="yes" xml:space="preserve">
          <source>There are a number of ways to backup a MariaDB server.</source>
          <target state="translated">MariaDB 서버를 백업하는 방법에는 여러 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="53ebf0feeedf9ca7b6addce61ddd200d6ce759e4" translate="yes" xml:space="preserve">
          <source>There are a number of ways to give the IAM credentials to the AWS KMS plugin. The plugin supports reading credentials from all standard locations used across the various AWS API clients.</source>
          <target state="translated">AWS KMS 플러그인에 IAM 자격 증명을 제공하는 방법에는 여러 가지가 있습니다. 플러그인은 다양한 AWS API 클라이언트에서 사용되는 모든 표준 위치에서 자격 증명 읽기를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="de80cfbdf1b84a8100b1ea61152b41bf2a10e7fa" translate="yes" xml:space="preserve">
          <source>There are a number of ways to see which plugins are currently active.</source>
          <target state="translated">현재 활성화 된 플러그인을 확인하는 방법에는 여러 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="882476aebe093f46226169c1a09c9d37e6a0865d" translate="yes" xml:space="preserve">
          <source>There are a numerous different methods to base-64 encode a string. The following are used by MariaDB and MySQL:</source>
          <target state="translated">문자열을 base-64로 인코딩하는 방법에는 여러 가지가 있습니다. 다음은 MariaDB 및 MySQL에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="baf6c4ed2f6ea483f1c7a37b58ec9b6bbf6fdd81" translate="yes" xml:space="preserve">
          <source>There are a several options and system variables related to the &lt;a href=&quot;../server_audit-mariadb-audit-plugin/index&quot;&gt;MariaDB Audit Plugin&lt;/a&gt;, once it has been &lt;a href=&quot;../mariadb-audit-plugin-entitymdashentity-installation/index&quot;&gt;installed&lt;/a&gt;. System variables can be displayed using the &lt;a href=&quot;../show-variables/index&quot;&gt;SHOW VARIABLES&lt;/a&gt; statement like so:</source>
          <target state="translated">일단 &lt;a href=&quot;../mariadb-audit-plugin-entitymdashentity-installation/index&quot;&gt;설치된 &lt;/a&gt;&lt;a href=&quot;../server_audit-mariadb-audit-plugin/index&quot;&gt;MariaDB 감사 플러그인&lt;/a&gt; 과 관련된 몇 가지 옵션 및 시스템 변수 가 있습니다. &lt;a href=&quot;../show-variables/index&quot;&gt;SHOW VARIABLES&lt;/a&gt; 문을 사용하여 시스템 변수를 표시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="473821bda12ad4933b13afb8383006c4fac96b18" translate="yes" xml:space="preserve">
          <source>There are a variety of reasons tables need to be converted; they could be any of the following:</source>
          <target state="translated">테이블을 변환해야하는 이유는 여러 가지가 있습니다. 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a94b70abcc8d4cb144e693d5b2f336816c9dd15" translate="yes" xml:space="preserve">
          <source>There are actually a few types of events that may be logged, not just the three common ones mentioned above. A full list of related system variables is detailed on the &lt;a href=&quot;../server_audit-system-variables/index&quot;&gt;Server_Audit System Variables&lt;/a&gt; page, and status variables on the &lt;a href=&quot;../server_audit-status-variables/index&quot;&gt;Server_Audit Status Variables&lt;/a&gt; page of this documentation. Some of the major ones are highlighted below:</source>
          <target state="translated">실제로 위에서 언급 한 세 가지 일반적인 이벤트뿐만 아니라 기록 될 수있는 몇 가지 유형의 이벤트가 있습니다. 관련 시스템 변수의 전체 목록 은이 문서 의 &lt;a href=&quot;../server_audit-system-variables/index&quot;&gt;Server_Audit 시스템 변수&lt;/a&gt; 페이지 및 &lt;a href=&quot;../server_audit-status-variables/index&quot;&gt;Server_Audit 상태 변수&lt;/a&gt; 페이지의 상태 변수에 자세히 설명되어 있습니다. 주요 내용 중 일부가 아래에 강조 표시되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2598a19a625f87724b9393da34d449e31638b98c" translate="yes" xml:space="preserve">
          <source>There are also &lt;code&gt;BUILD&lt;/code&gt; scripts for the most common systems for those that doesn't want to dig into cmake options. These are optimized for in source builds.</source>
          <target state="translated">cmake 옵션을 파고 싶지 않은 시스템을위한 가장 일반적인 시스템을위한 &lt;code&gt;BUILD&lt;/code&gt; 스크립트 도 있습니다. 소스 빌드에 최적화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab3c1a6fd2ce3f9067901e219c8c4adec166b717" translate="yes" xml:space="preserve">
          <source>There are also a number of commands that can be run inside the client. Note that all text commands must be first on line and end with ';'</source>
          <target state="translated">클라이언트 내에서 실행할 수있는 많은 명령이 있습니다. 모든 텍스트 명령은 먼저 온라인 상태 여야하며 ';'로 끝나야합니다.</target>
        </trans-unit>
        <trans-unit id="f1661989ac658d1a11df537b227502a03c59e843" translate="yes" xml:space="preserve">
          <source>There are also further limitations specific to the kind of stored routine.</source>
          <target state="translated">저장 루틴의 종류와 관련된 추가 제한 사항도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ebe89cabae19781966ddb0e5b7843a4db25f424" translate="yes" xml:space="preserve">
          <source>There are also number of shortcuts to match particular preset character names. These are matched with the &lt;code&gt;[.character.]&lt;/code&gt; pattern (inside a &lt;code&gt;[]&lt;/code&gt; set). The following character classes exist:</source>
          <target state="translated">특정 사전 설정 문자 이름과 일치하는 바로 가기도 있습니다. &lt;code&gt;[.character.]&lt;/code&gt; 패턴 과 일치합니다 ( &lt;code&gt;[]&lt;/code&gt; 세트 내부 ). 다음과 같은 문자 클래스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="160fdb8932929dc6fb05f7ce0753b60578f88dce" translate="yes" xml:space="preserve">
          <source>There are also some build scripts in the &lt;em&gt;BUILD/ &lt;/em&gt;directory which may be more convenient to use. For example, the following pre-configures the build options discussed above:</source>
          <target state="translated">&lt;em&gt;BUILD /&lt;/em&gt; 디렉토리에는 사용하기 편리한 빌드 스크립트도 있습니다. 예를 들어, 다음은 위에서 설명한 빌드 옵션을 사전 구성합니다.</target>
        </trans-unit>
        <trans-unit id="3407ff73572890e3dbd273257d6d0067ba4d3597" translate="yes" xml:space="preserve">
          <source>There are also some new options to &lt;code&gt;&lt;a href=&quot;../create-table/index&quot;&gt;CREATE TABLE&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../create-table/index&quot;&gt;CREATE TABLE&lt;/a&gt;&lt;/code&gt; 에는 몇 가지 새로운 옵션이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="69388dac4f740a814cff229eea40362191301aef" translate="yes" xml:space="preserve">
          <source>There are alternative ways to add a new function: writing a native function, which requires modifying and compiling the server source code; or writing a &lt;a href=&quot;../stored-functions/index&quot;&gt;stored function&lt;/a&gt;.</source>
          <target state="translated">새로운 함수를 추가하는 대체 방법이 있습니다. 기본 함수 작성, 서버 소스 코드 수정 및 컴파일이 필요합니다. 또는 &lt;a href=&quot;../stored-functions/index&quot;&gt;저장된 함수&lt;/a&gt; 작성 .</target>
        </trans-unit>
        <trans-unit id="565979692a03fb31c08d248e9e98dfde87cab6e9" translate="yes" xml:space="preserve">
          <source>There are binary installation packages available for RPM and Debian-based distributions, which will pull in all required Galera dependencies.</source>
          <target state="translated">RPM 및 Debian 기반 배포판에 사용할 수있는 이진 설치 패키지가 있으며 필요한 모든 Galera 종속성을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="a85877a70cfccb765fcca47aa303377012856746" translate="yes" xml:space="preserve">
          <source>There are cases when it might make sense to set a different &lt;code&gt;&lt;a href=&quot;../../replication-and-binary-log-system-variables/index#server_id&quot;&gt;server_id&lt;/a&gt;&lt;/code&gt; value on each node in a given cluster. For example, if &lt;code&gt;&lt;a href=&quot;../../replication-and-binary-log-system-variables/index#log_slave_updates&quot;&gt;log_slave_updates=OFF&lt;/a&gt;&lt;/code&gt; is set and if another cluster or a standard MariaDB Server is using &lt;a href=&quot;../../multi-source-replication/index&quot;&gt;multi-source replication&lt;/a&gt; to replicate transactions from each cluster node individually, then it would be required to set a different &lt;code&gt;&lt;a href=&quot;../../replication-and-binary-log-system-variables/index#server_id&quot;&gt;server_id&lt;/a&gt;&lt;/code&gt; value on each node for this to work.</source>
          <target state="translated">주어진 클러스터의 각 노드에서 다른 &lt;code&gt;&lt;a href=&quot;../../replication-and-binary-log-system-variables/index#server_id&quot;&gt;server_id&lt;/a&gt;&lt;/code&gt; 값 을 설정하는 것이 합리적 일 수 있습니다 . 예를 들어, &lt;code&gt;&lt;a href=&quot;../../replication-and-binary-log-system-variables/index#log_slave_updates&quot;&gt;log_slave_updates=OFF&lt;/a&gt;&lt;/code&gt; 가 설정되어 있고 다른 클러스터 또는 표준 MariaDB 서버가 &lt;a href=&quot;../../multi-source-replication/index&quot;&gt;다중 소스 복제&lt;/a&gt; 를 사용하여 각 클러스터 노드에서 개별적으로 트랜잭션을 복제하는 경우이를 위해 각 노드에서 다른 &lt;code&gt;&lt;a href=&quot;../../replication-and-binary-log-system-variables/index#server_id&quot;&gt;server_id&lt;/a&gt;&lt;/code&gt; 값 을 설정해야 합니다. 작업.</target>
        </trans-unit>
        <trans-unit id="d02d213e01ef76e3cd1648620f7e2743b816ab8b" translate="yes" xml:space="preserve">
          <source>There are currently no &lt;a href=&quot;../what-is-mariadb-105/index&quot;&gt;MariaDB 10.5&lt;/a&gt; releases available, and, as a development version, details on this change may change frequently.</source>
          <target state="translated">현재 사용할 수있는 &lt;a href=&quot;../what-is-mariadb-105/index&quot;&gt;MariaDB 10.5&lt;/a&gt; 릴리스가 없으며 개발 버전으로이 변경에 대한 세부 사항이 자주 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c7c508b336fbd0efe330d9d75e0e13f8a98bd7c" translate="yes" xml:space="preserve">
          <source>There are currently no differences between GIS in stable versions of MariaDB and GIS in MySQL. There are, however, some extensions and enhancements being worked on. See &quot;&lt;a href=&quot;../mariadb-plans-gis/index&quot;&gt;MariaDB Plans - GIS&lt;/a&gt;&quot; for more information.</source>
          <target state="translated">안정적인 MariaDB 버전의 GIS와 MySQL의 GIS 사이에는 현재 차이점이 없습니다. 그러나 일부 확장 및 개선 작업이 진행 중입니다. 자세한 내용은 &quot; &lt;a href=&quot;../mariadb-plans-gis/index&quot;&gt;MariaDB 계획-GIS&lt;/a&gt; &quot;를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="967533b5e21487f150bf70ec7b45976f6335a1b4" translate="yes" xml:space="preserve">
          <source>There are currently three options for key management:</source>
          <target state="translated">현재 키 관리에는 세 가지 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="837719cfae089f579ec20deff543c9bfbc45ce20" translate="yes" xml:space="preserve">
          <source>There are currently two affected classes of inconsistencies: character padding and unsigned subtraction:</source>
          <target state="translated">현재 영향을받는 두 가지 불일치 클래스에는 문자 패딩과 부호없는 뺄셈이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb854c6e0160c6aa9c0fbb5b16e0350f02ed6899" translate="yes" xml:space="preserve">
          <source>There are currently two different low-level implementations &amp;ndash; depending on OS. One implementation is designed specifically for Windows which utilizes a native &lt;code&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/api/threadpoolapiset/nf-threadpoolapiset-createthreadpool&quot;&gt;CreateThreadpool&lt;/a&gt;&lt;/code&gt; API. The second implementation is primarily intended to be used in Unix-like systems. Because the implementations are different, some system variables differ between Windows and Unix.</source>
          <target state="translated">OS에 따라 현재 두 가지 저수준 구현이 있습니다. 네이티브 &lt;code&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/api/threadpoolapiset/nf-threadpoolapiset-createthreadpool&quot;&gt;CreateThreadpool&lt;/a&gt;&lt;/code&gt; API 를 사용하는 Windows 용으로 특별히 구현 된 것이 하나 있습니다. 두 번째 구현은 주로 유닉스 계열 시스템에서 사용하기위한 것입니다. 구현이 다르기 때문에 일부 시스템 변수는 Windows와 Unix간에 다릅니다.</target>
        </trans-unit>
        <trans-unit id="bae4db11beb7bce43d2dcdf8a4f1c349aecd6368" translate="yes" xml:space="preserve">
          <source>There are currently two implementations of the transaction coordinator log:</source>
          <target state="translated">트랜잭션 조정자 로그에는 현재 두 가지 구현이 있습니다.</target>
        </trans-unit>
        <trans-unit id="92e2ad18290ce0fd1806aa9842efde89c518ad31" translate="yes" xml:space="preserve">
          <source>There are currently two possibilities to interact from Spark with ColumnStore. The first, is to use the ColumnStoreExporter which is part of the Bulk Data Adapters. ColumnStoreExporter can be used to export dataframes into existing tables in ColumnStore which is magnitudes faster than injecting Dataframes through JDBC. The second way is to use the MariaDB Java Connector and connect through JDBC. This is especially useful to read data from ColumnStore into Spark and to apply changes to ColumnStore's database structure through DDL.</source>
          <target state="translated">Spark에서 ColumnStore와 상호 작용할 수있는 가능성은 현재 두 가지입니다. 첫 번째는 벌크 데이터 어댑터의 일부인 ColumnStoreExporter를 사용하는 것입니다. ColumnStoreExporter를 사용하면 JDBC를 통해 데이터 프레임을 주입하는 것보다 훨씬 빠른 ColumnStore의 기존 테이블로 데이터 프레임을 내보낼 수 있습니다. 두 번째 방법은 MariaDB Java 커넥터를 사용하고 JDBC를 통해 연결하는 것입니다. 이것은 ColumnStore에서 Spark로 데이터를 읽고 DDL을 통해 ColumnStore의 데이터베이스 구조에 변경 사항을 적용하는 데 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="301d2daa1c30d71004dbbd56e6d9c28f5ccccdae" translate="yes" xml:space="preserve">
          <source>There are exceptions where the Fact table must be accessed to retrieve multiple rows. However, you should minimize the number of INDEXes on the table because they are likely to be costly on INSERT.</source>
          <target state="translated">여러 행을 검색하기 위해 팩트 테이블에 액세스해야하는 예외가 있습니다. 그러나 INSERT에 많은 비용이들 수 있으므로 테이블의 INDEX 수를 최소화해야합니다.</target>
        </trans-unit>
        <trans-unit id="bd4b7e15b6190a64e2f37b42b58445ccd4daca0e" translate="yes" xml:space="preserve">
          <source>There are fewer than two threads in the thread group. This is to guarantee that each thread group can have at least two threads, even if &lt;code&gt;&lt;a href=&quot;../thread-pool-system-status-variables/index#thread_pool_max_threads&quot;&gt;thread_pool_max_threads&lt;/a&gt;&lt;/code&gt; has already been reached or exceeded.</source>
          <target state="translated">스레드 그룹에 스레드가 두 개 미만입니다. &lt;code&gt;&lt;a href=&quot;../thread-pool-system-status-variables/index#thread_pool_max_threads&quot;&gt;thread_pool_max_threads&lt;/a&gt;&lt;/code&gt; 에 이미 도달했거나 초과 한 경우에도 각 스레드 그룹에 스레드가 두 개 이상있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="77ff98ec59c7cbc7b14ca6e871e739ceb8d06ddb" translate="yes" xml:space="preserve">
          <source>There are five levels of logging in MariaDB ColumnStore.</source>
          <target state="translated">MariaDB ColumnStore에는 5 가지 레벨의 로깅이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e8f6e40e2b373faa85f051dcb0505cfd713318b" translate="yes" xml:space="preserve">
          <source>There are five supported kinds of attributes:</source>
          <target state="translated">지원되는 5 가지 종류의 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e09257e0aeb8302f9812334038ca4dfd789efb1d" translate="yes" xml:space="preserve">
          <source>There are four cases where pivot must call the server containing the source table or on which the SrcDef statement must be executed:</source>
          <target state="translated">피벗이 소스 테이블을 포함하는 서버를 호출하거나 SrcDef 문을 실행해야하는 네 가지 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="08d7cba983bfc15d4cc6e08bd42d67016e515612" translate="yes" xml:space="preserve">
          <source>There are four counters in the &lt;code&gt;icp&lt;/code&gt; subsystem:</source>
          <target state="translated">&lt;code&gt;icp&lt;/code&gt; 서브 시스템 에는 4 개의 카운터가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f2260487530271968373e34fc0df286b7100bb12" translate="yes" xml:space="preserve">
          <source>There are four main changes relating to authentication:</source>
          <target state="translated">인증과 관련하여 4 가지 주요 변경 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bf00816fd5069b6fb2b6e7bc267ffef488cbc9b" translate="yes" xml:space="preserve">
          <source>There are four main kinds of indexes; primary keys (unique and not null), unique indexes (unique and can be null), plain indexes (not necessarily unique) and full-text indexes (for full-text searching).</source>
          <target state="translated">인덱스에는 4 가지 주요 종류가 있습니다. 기본 키 (고유하지 않고 null이 아님), 고유 인덱스 (고유하고 null 일 수 있음), 일반 인덱스 (유일하지는 않음) 및 전체 텍스트 인덱스 (전체 텍스트 검색 용).</target>
        </trans-unit>
        <trans-unit id="4ecfc29cdee18e4d489ec53b3cede07f137eb8d8" translate="yes" xml:space="preserve">
          <source>There are four parts of it.</source>
          <target state="translated">그것의 네 부분이 있습니다.</target>
        </trans-unit>
        <trans-unit id="158535f4b9cbba29ba54dc13e7545b910f860915" translate="yes" xml:space="preserve">
          <source>There are four semi-join execution strategies:</source>
          <target state="translated">semi-join 실행 전략에는 네 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e633e100b88de39ca93a22bcbcee7bf97dd937bd" translate="yes" xml:space="preserve">
          <source>There are four types of table constraints:</source>
          <target state="translated">테이블 제약 조건에는 네 가지 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c92e9bd2ac2d39d930215f648b692602d15a5056" translate="yes" xml:space="preserve">
          <source>There are four types: the standard InnoDB monitor, the InnoDB Lock Monitor, InnoDB Tablespace Monitor and the InnoDB Table Monitor.</source>
          <target state="translated">표준 InnoDB 모니터, InnoDB 잠금 모니터, InnoDB 테이블 스페이스 모니터 및 InnoDB 테이블 모니터의 네 가지 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="60e37be8007fba15fa986e11c7bbdf0e66e1c211" translate="yes" xml:space="preserve">
          <source>There are limits (3KB?) on how 'wide' an index can be, so &quot;covering&quot; may not be possible.</source>
          <target state="translated">인덱스의 '넓은'범위에 대한 제한 (3KB)이 있으므로 &quot;표지&quot;가 불가능할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8886b588656ebdf18a39d0363da05d75f6cba40" translate="yes" xml:space="preserve">
          <source>There are many PAM modules. The ones described below are the ones that have been seen most often by MariaDB.</source>
          <target state="translated">많은 PAM 모듈이 있습니다. 아래에 설명 된 것은 MariaDB가 가장 자주 본 것입니다.</target>
        </trans-unit>
        <trans-unit id="f37d29b5258f327363e1c05c6de1757c26f04bbb" translate="yes" xml:space="preserve">
          <source>There are many commonly used built-in functions. These are lesser used function for specific needs.</source>
          <target state="translated">일반적으로 사용되는 내장 함수가 많이 있습니다. 이들은 특정 요구에 대해 덜 사용되는 기능입니다.</target>
        </trans-unit>
        <trans-unit id="d657586138c441d8f4913e3f88600aa469a09fb0" translate="yes" xml:space="preserve">
          <source>There are many different ways to migrate from &lt;a href=&quot;https://www.postgresql.org/&quot;&gt;PostgreSQL&lt;/a&gt; to MariaDB. This article will discuss some of those options.</source>
          <target state="translated">&lt;a href=&quot;https://www.postgresql.org/&quot;&gt;PostgreSQL&lt;/a&gt; 에서 MariaDB 로 마이그레이션하는 방법에는 여러 가지가 있습니다 . 이 기사에서는 이러한 옵션 중 일부에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="ae2a34f1e91b00139b4798dc10fa481e53cfcfab" translate="yes" xml:space="preserve">
          <source>There are many other workflows available using CloudWatch, including workflows with alarms and dashboards. Those are beyond the scope of this document.</source>
          <target state="translated">경보 및 대시 보드가있는 워크 플로우를 비롯하여 CloudWatch를 사용하여 사용할 수있는 다른 워크 플로우가 많이 있습니다. 이것들은이 문서의 범위를 벗어납니다.</target>
        </trans-unit>
        <trans-unit id="b131de331b4526c1cdd91a27896d3c13d016e0aa" translate="yes" xml:space="preserve">
          <source>There are many tasks that database administrators (DBAs) have to perform. This section of the MariaDB Documentation provides information on how to do these tasks.</source>
          <target state="translated">데이터베이스 관리자 (DBA)가 수행해야하는 많은 작업이 있습니다. MariaDB 설명서의이 섹션에서는 이러한 작업을 수행하는 방법에 대한 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4596963339525aac9f8c3fbdc1d3ece1fda8ab6c" translate="yes" xml:space="preserve">
          <source>There are many variables in MariaDB that you can use to define what to log and when to log.</source>
          <target state="translated">MariaDB에는 기록 대상 및 기록시기를 정의하는 데 사용할 수있는 많은 변수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="592980e875fe053792eb98b44e63cd6e7f9e8278" translate="yes" xml:space="preserve">
          <source>There are more client connection requests in the thread group's work queue that the &lt;strong&gt;listener thread&lt;/strong&gt; still needs to distribute to &lt;strong&gt;worker threads&lt;/strong&gt;, so the &lt;strong&gt;listener thread&lt;/strong&gt; should not become a &lt;strong&gt;worker thread&lt;/strong&gt;.</source>
          <target state="translated">스레드 그룹의 작업 큐에 &lt;strong&gt;리스너 스레드가&lt;/strong&gt; 여전히 &lt;strong&gt;작업자 스레드&lt;/strong&gt; 로 분배해야하는 클라이언트 연결 요청이 더 많으므로 &lt;strong&gt;리스너 스레드&lt;/strong&gt; 가 &lt;strong&gt;작업자 스레드&lt;/strong&gt; 가되어서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="a71e6290a454436cebcf647af441edc8f49cb25b" translate="yes" xml:space="preserve">
          <source>There are more client connection requests in the thread group's work queue that the &lt;strong&gt;listener thread&lt;/strong&gt; still needs to distribute to &lt;strong&gt;worker threads&lt;/strong&gt;.</source>
          <target state="translated">스레드 그룹의 작업 큐에 &lt;strong&gt;리스너 스레드가&lt;/strong&gt; 여전히 &lt;strong&gt;작업자 스레드&lt;/strong&gt; 로 분배해야하는 클라이언트 연결 요청이 더 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0f54dc08f53e87495cb27dcde90e6d3bf5adf1f9" translate="yes" xml:space="preserve">
          <source>There are more client connection requests in the thread group's work queue that the &lt;strong&gt;listener thread&lt;/strong&gt; still needs to distribute to &lt;strong&gt;worker threads&lt;/strong&gt;. In this case, the new thread is intended to be a &lt;strong&gt;worker thread&lt;/strong&gt;.</source>
          <target state="translated">스레드 그룹의 작업 큐에 &lt;strong&gt;리스너 스레드가&lt;/strong&gt; 여전히 &lt;strong&gt;작업자 스레드&lt;/strong&gt; 로 분배해야하는 클라이언트 연결 요청이 더 있습니다 . 이 경우 새 스레드는 &lt;strong&gt;워커 스레드&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="980499684635bbcf6aeaabf7ca195d45c8016f9e" translate="yes" xml:space="preserve">
          <source>There are more complex alternatives that have a more granular effect, but those are beyond the scope of this document.</source>
          <target state="translated">보다 세분화 된 효과가있는 더 복잡한 대안이 있지만이 문서의 범위를 벗어납니다.</target>
        </trans-unit>
        <trans-unit id="bdec853f4bac66433dd30bfbc89ec81351f3b362" translate="yes" xml:space="preserve">
          <source>There are more condition properties, which are never set for built-in errors. They can only be set via SIGNAL and RESIGNAL statements, and can only be read via GET DIAGNOSTICS - not via the API. Such properties are:</source>
          <target state="translated">내장 오류에 대해 설정되지 않은 조건 속성이 더 있습니다. SIGNAL 및 RESIGNAL 문을 통해서만 설정할 수 있으며 API가 아닌 GET DIAGNOSTICS를 통해서만 읽을 수 있습니다. 이러한 속성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a7f3ab5980e65e3299138e8913c5e122f3fe1bed" translate="yes" xml:space="preserve">
          <source>There are no active &lt;strong&gt;worker threads&lt;/strong&gt; in the thread group.</source>
          <target state="translated">스레드 그룹에 활성 &lt;strong&gt;작업자 스레드&lt;/strong&gt; 가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="1024d521ba84bbf7237c1385bd91e55943451623" translate="yes" xml:space="preserve">
          <source>There are no changes in table or index formats between &lt;a href=&quot;../what-is-mariadb-100/index&quot;&gt;MariaDB 10.0&lt;/a&gt; and &lt;a href=&quot;../what-is-mariadb-101/index&quot;&gt;MariaDB 10.1&lt;/a&gt;, so on most servers the upgrade should be painless.</source>
          <target state="translated">&lt;a href=&quot;../what-is-mariadb-100/index&quot;&gt;MariaDB 10.0&lt;/a&gt; 과 &lt;a href=&quot;../what-is-mariadb-101/index&quot;&gt;MariaDB 10.1&lt;/a&gt; 간에는 테이블 또는 인덱스 형식이 변경되지 않으므로 대부분의 서버에서 업그레이드는 어려움이 없습니다.</target>
        </trans-unit>
        <trans-unit id="feabb402e0dda9f7b306008e2ab8d199198770c2" translate="yes" xml:space="preserve">
          <source>There are no changes in table or index formats between &lt;a href=&quot;../what-is-mariadb-53/index&quot;&gt;MariaDB 5.3&lt;/a&gt; and &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt;, so on most servers the upgrade should be painless.</source>
          <target state="translated">&lt;a href=&quot;../what-is-mariadb-53/index&quot;&gt;MariaDB 5.3&lt;/a&gt; 과 &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt; 간에는 테이블 또는 인덱스 형식이 변경되지 않으므로 대부분의 서버에서 업그레이드는 어려움이 없습니다.</target>
        </trans-unit>
        <trans-unit id="7f1c99cedc3768ccb5096902f026d17219b30a48" translate="yes" xml:space="preserve">
          <source>There are no changes in table or index formats between &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt; and &lt;a href=&quot;../what-is-mariadb-100/index&quot;&gt;MariaDB 10.0&lt;/a&gt;, so on most servers the upgrade should be painless.</source>
          <target state="translated">&lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt; 와 &lt;a href=&quot;../what-is-mariadb-100/index&quot;&gt;MariaDB 10.0&lt;/a&gt; 사이에는 테이블 또는 인덱스 형식이 변경되지 않으므로 대부분의 서버에서 업그레이드는 어려움이 없습니다.</target>
        </trans-unit>
        <trans-unit id="ba89bc9f50744fbfdf2f70157153903deaec9499" translate="yes" xml:space="preserve">
          <source>There are no known CVEs on ColumnStore specific infrastructure outside of the MariaDB Server at this time.</source>
          <target state="translated">현재 MariaDB 서버 외부의 ColumnStore 특정 인프라에는 알려진 CVE가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c7772b18cf8ce5c310f03754f87817d2a1fb065c" translate="yes" xml:space="preserve">
          <source>There are no performance degradations when accessing existing tables on the server. Accessing the S3 table the first time will copy the .frm file from S3 to the local disk, speeding up future accesses to the table.</source>
          <target state="translated">서버의 기존 테이블에 액세스 할 때 성능이 저하되지 않습니다. S3 테이블에 처음 액세스하면 .frm 파일이 S3에서 로컬 디스크로 복사되어 테이블에 대한 향후 액세스 속도가 빨라집니다.</target>
        </trans-unit>
        <trans-unit id="d746c30296ad6cc7780eb23f95f2ee2030c0253f" translate="yes" xml:space="preserve">
          <source>There are no sleeping &lt;strong&gt;worker threads&lt;/strong&gt; in the thread group that the &lt;strong&gt;listener thread&lt;/strong&gt; can wake up.</source>
          <target state="translated">스레드 그룹에는 &lt;strong&gt;리스너 스레드&lt;/strong&gt; 가 깨어날 수 있는 휴면 &lt;strong&gt;작업자 스레드&lt;/strong&gt; 가 없습니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8cb017acdc2968dc620cec877df8511fdc8d9d68" translate="yes" xml:space="preserve">
          <source>There are no sleeping &lt;strong&gt;worker threads&lt;/strong&gt; in the thread group that the &lt;strong&gt;timer thread&lt;/strong&gt; can wake up.</source>
          <target state="translated">스레드 그룹에 &lt;strong&gt;타이머 스레드&lt;/strong&gt; 가 깨울 수 있는 휴면 &lt;strong&gt;작업자 스레드&lt;/strong&gt; 가 없습니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bc62f7cd832e7de4cf9d2754bb01d1e3ae8a8875" translate="yes" xml:space="preserve">
          <source>There are no sleeping &lt;strong&gt;worker threads&lt;/strong&gt; in the thread group that the &lt;strong&gt;worker thread&lt;/strong&gt; can wake up.</source>
          <target state="translated">스레드 그룹에 &lt;strong&gt;작업자 스레드&lt;/strong&gt; 가 깨어날 수 있는 잠자는 &lt;strong&gt;작업자 스레드&lt;/strong&gt; 가 없습니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b718bcb64640fcdeaf25d6a9d7465bd23c2b17a1" translate="yes" xml:space="preserve">
          <source>There are numerous methods to base-64 encode a string. MariaDB uses the following:</source>
          <target state="translated">문자열을 base-64로 인코딩하는 방법은 여러 가지가 있습니다. MariaDB는 다음을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="bbdad0aca8263a858c6c449107e8556bacb706e3" translate="yes" xml:space="preserve">
          <source>There are optimizations that should be made when using MariaDB ColumnStore listed below. As always, please consult with your network administrator for additional optimization considerations for your specific installation needs.</source>
          <target state="translated">아래 나열된 MariaDB ColumnStore를 사용할 때 최적화해야합니다. 항상 그렇듯이 특정 설치 요구에 대한 추가 최적화 고려 사항에 대해서는 네트워크 관리자에게 문의하십시오.</target>
        </trans-unit>
        <trans-unit id="67edb85b85a5167609b91e9e6390cfb93deb402a" translate="yes" xml:space="preserve">
          <source>There are other alternatives for data transfer between R and MariaDB:</source>
          <target state="translated">R과 MariaDB 간 데이터 전송에 대한 다른 대안이 있습니다.</target>
        </trans-unit>
        <trans-unit id="41b091b09982a3c65c06c510679c2675c14c0e6c" translate="yes" xml:space="preserve">
          <source>There are other escape sequences also. Here is a full list:</source>
          <target state="translated">다른 이스케이프 시퀀스도 있습니다. 전체 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d4a54a84b71b569d9ae9d83502ad7f49f56ddf1c" translate="yes" xml:space="preserve">
          <source>There are other options and the &lt;code&gt;mariadb-service-convert&lt;/code&gt; script will attempt to convert these as accurately as possible.</source>
          <target state="translated">다른 옵션이 있으며 &lt;code&gt;mariadb-service-convert&lt;/code&gt; 스크립트는 가능한 한 정확하게 변환하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="98867d5a6cc400d553a8034f68f768e13e8a8a41" translate="yes" xml:space="preserve">
          <source>There are principally two ways to define a PIVOT table:</source>
          <target state="translated">PIVOT 테이블을 정의하는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3374b078946d0d0c01c5cb58bb5174ea8b36fdb8" translate="yes" xml:space="preserve">
          <source>There are pros and cons with both methods:</source>
          <target state="translated">두 가지 방법 모두 장단점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a21acbb7ea53ccb8a70630e3f55a389132015e4e" translate="yes" xml:space="preserve">
          <source>There are quite a few places in MariaDB and MySQL where we use a synchronization pattern like this:</source>
          <target state="translated">MariaDB와 MySQL에는 다음과 같은 동기화 패턴을 사용하는 곳이 꽤 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8c8ca23a552334652ac10ff1bf6ea34314c3fc1" translate="yes" xml:space="preserve">
          <source>There are several card models. ioDrive is older generation, ioDrive2 is newer. SLC sustains more writes. MLC is good enough for normal use.</source>
          <target state="translated">여러 가지 카드 모델이 있습니다. ioDrive는 이전 세대이며 ioDrive2는 최신 버전입니다. SLC는 더 많은 쓰기를 유지합니다. MLC는 정상적인 사용에 충분합니다.</target>
        </trans-unit>
        <trans-unit id="7c99c90dfcca3d367b831e14bec4e17892b8b982" translate="yes" xml:space="preserve">
          <source>There are several different methods to start or stop the MariaDB Server process. There are two primary categories that most of these methods fall into: starting the process with the help of a service manager, and starting the process manually.</source>
          <target state="translated">MariaDB 서버 프로세스를 시작하거나 중지하는 방법에는 여러 가지가 있습니다. 이러한 방법의 대부분은 서비스 관리자의 도움으로 프로세스를 시작하고 수동으로 프로세스를 시작하는 두 가지 주요 범주가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a495ace84e5c80ef0a2a611756569ae7a94f5c2a" translate="yes" xml:space="preserve">
          <source>There are several different methods to start or stop the MariaDB Server process. There are two primary categories that most of these methods fall into: starting the process with the help of a service manager, and starting the process manually. See &lt;a href=&quot;../starting-and-stopping-mariadb-starting-and-stopping-mariadb/index&quot;&gt;Starting and Stopping MariaDB&lt;/a&gt; for more information.</source>
          <target state="translated">MariaDB 서버 프로세스를 시작하거나 중지하는 방법에는 여러 가지가 있습니다. 이러한 방법의 대부분은 서비스 관리자의 도움으로 프로세스를 시작하고 수동으로 프로세스를 시작하는 두 가지 주요 범주가 있습니다. 자세한 내용은 &lt;a href=&quot;../starting-and-stopping-mariadb-starting-and-stopping-mariadb/index&quot;&gt;MariaDB 시작 및 중지&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
