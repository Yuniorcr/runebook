<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="mariadb">
    <body>
      <group id="mariadb">
        <trans-unit id="44e9255939befa76b659bd04d798876762dbdb4f" translate="yes" xml:space="preserve">
          <source>When a transaction updates a row in an InnoDB table, InnoDB's MVCC implementation keeps old versions of the row in the &lt;a href=&quot;../innodb-undo-log/index&quot;&gt;InnoDB undo log&lt;/a&gt;. The old versions are kept at least until all transactions older than the transaction that updated the row are no longer open. At that point, the old versions can be deleted. InnoDB has purge process that is used to delete these old versions.</source>
          <target state="translated">트랜잭션이 InnoDB 테이블에서 행을 업데이트 할 때 InnoDB의 MVCC 구현은 &lt;a href=&quot;../innodb-undo-log/index&quot;&gt;InnoDB 실행 취소 로그&lt;/a&gt; 에 이전 버전의 행을 유지합니다 . 이전 버전은 행을 업데이트 한 트랜잭션보다 오래된 모든 트랜잭션이 더 이상 열려 있지 않을 때까지 유지됩니다. 이때 이전 버전을 삭제할 수 있습니다. InnoDB에는 이러한 이전 버전을 삭제하는 데 사용되는 제거 프로세스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfe5db2ba2b9c94dff176089918117c037493bd8" translate="yes" xml:space="preserve">
          <source>When a user asks for a list of tables in a specific database &amp;mdash; for example, by using &lt;code&gt;SHOW TABLES&lt;/code&gt; or by selecting from &lt;code&gt;INFORMATION_SCHEMA.TABLES&lt;/code&gt; &amp;mdash; the server invokes &lt;strong&gt;discover_table_names()&lt;/strong&gt; method of the &lt;code&gt;handlerton&lt;/code&gt;. For convenience this method, besides the database name in question, gets the list of all files in this database directory, so that the engine can look for table files without doing any filesystem i/o. All discovered tables should be added to the &lt;code&gt;result&lt;/code&gt; collector object. It is defined as</source>
          <target state="translated">사용자가 &lt;code&gt;SHOW TABLES&lt;/code&gt; 를 사용 하거나 &lt;code&gt;INFORMATION_SCHEMA.TABLES&lt;/code&gt; 에서 선택 하는 등의 특정 데이터베이스에서 테이블 목록을 요청 하면 서버는 &lt;code&gt;handlerton&lt;/code&gt; 의 &lt;strong&gt;discover_table_names ()&lt;/strong&gt; 메소드를 호출합니다 . 편의상,이 방법은 문제의 데이터베이스 이름 외에이 데이터베이스 디렉토리의 모든 파일 목록을 가져 와서 엔진이 파일 시스템 i / o를 수행하지 않고 테이블 파일을 찾을 수 있도록합니다. 발견 된 모든 테이블이 &lt;code&gt;result&lt;/code&gt; 콜렉터 오브젝트에 추가되어야 합니다. 다음과 같이 정의됩니다</target>
        </trans-unit>
        <trans-unit id="c11d35cac1732901a7523e5db3810fc0f003191f" translate="yes" xml:space="preserve">
          <source>When a user attempts to log in, the authentication plugin controls how MariaDB Server determines whether the connection is from a legitimate user.</source>
          <target state="translated">사용자가 로그인을 시도하면 인증 플러그인은 MariaDB 서버가 합법적 인 사용자의 연결인지 여부를 결정하는 방법을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="fb7fc148c924496c47928febe8bd898585ee0642" translate="yes" xml:space="preserve">
          <source>When a user sets a role, he, in a sense, has two identities with two associated sets of privileges. But a view (or a stored routine) can have only one definer. So, when a view (or a stored routine) is created with the &lt;code&gt;SQL SECURITY DEFINER&lt;/code&gt;, one can specify whether the definer should be &lt;code&gt;CURRENT_USER&lt;/code&gt; (and the view will have none of the privileges of the user's role) or &lt;code&gt;CURRENT_ROLE&lt;/code&gt; (in this case, the view will use role's privileges, but none of the user's privileges). As a result, sometimes one can create a view that is impossible to use.</source>
          <target state="translated">사용자가 역할을 설정하면 두 가지 관련 권한 집합이있는 두 개의 ID가 있습니다. 그러나 뷰 (또는 저장 루틴)에는 정의자가 하나만있을 수 있습니다. 따라서 &lt;code&gt;SQL SECURITY DEFINER&lt;/code&gt; 를 사용 하여 뷰 (또는 스토어드 루틴)를 작성할 때 정의자가 &lt;code&gt;CURRENT_USER&lt;/code&gt; (및 뷰에 사용자 역할의 특권이 없음) 또는 &lt;code&gt;CURRENT_ROLE&lt;/code&gt; (이 경우, 보기는 역할의 권한을 사용하지만 사용자의 권한은 사용하지 않습니다). 결과적으로 때로는 사용하기 어려운 뷰를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="56d191d23a660457dd4c63e4f616fa4b78eab3f7" translate="yes" xml:space="preserve">
          <source>When a user specifies an alter algorithm for a DDL operation, MariaDB does not necessarily use that specific algorithm for the operation. It interprets the choice in the following way:</source>
          <target state="translated">사용자가 DDL 작업에 대한 대체 알고리즘을 지정하면 MariaDB가 해당 특정 알고리즘을 작업에 반드시 사용할 필요는 없습니다. 다음과 같은 방식으로 선택을 해석합니다.</target>
        </trans-unit>
        <trans-unit id="a0bfd8627ebb0e8339cce23d3b7d86ba35ddf9cf" translate="yes" xml:space="preserve">
          <source>When a value in the column referenced by a foreign key changes and at least one child row exists, MariaDB performs an action which depends on the &lt;code&gt;ON UPDATE&lt;/code&gt; clause of the foreign key.</source>
          <target state="translated">외래 키가 참조하는 열의 값이 변경되고 하나 이상의 자식 행이 존재하면 MariaDB 는 외래 키 의 &lt;code&gt;ON UPDATE&lt;/code&gt; 절에 따라 동작을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="c9346de7a212ce665cb73a7b2382f3d553e035ea" translate="yes" xml:space="preserve">
          <source>When a view is referenced, privileges for objects accessed by the view are checked against the privileges held by the view creator or invoker, depending on whether the SQL SECURITY characteristic is DEFINER or INVOKER, respectively.</source>
          <target state="translated">뷰가 참조되면 SQL SECURITY 특성이 DEFINER인지 INVOKER인지에 따라 뷰가 액세스 한 오브젝트의 특권이 뷰 작성자 또는 호출자가 보유한 특권과 비교하여 점검됩니다.</target>
        </trans-unit>
        <trans-unit id="91014279d22adf77cd5c92317a204489f80cbf99" translate="yes" xml:space="preserve">
          <source>When a wait timed out (even on &lt;code&gt;TIMEOUT 0&lt;/code&gt;), a warning is generated so that it shows up in the test result.</source>
          <target state="translated">대기 시간이 초과되면 ( &lt;code&gt;TIMEOUT 0&lt;/code&gt; 조차도 ) 테스트 결과에 표시되도록 경고가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="52c546975b4c9fbd6e1f457b81c43775c74d169b" translate="yes" xml:space="preserve">
          <source>When accessing the remote table, CONNECT sets the connection charset set to the default local table charset as the FEDERATED engine does.</source>
          <target state="translated">원격 테이블에 액세스 할 때 CONNECT는 FEDERATED 엔진과 같이 연결 문자 세트를 기본 로컬 테이블 문자 세트로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="082aef5585f69fd6fa87873e15d9c26787bde63f" translate="yes" xml:space="preserve">
          <source>When activated, a sync point can</source>
          <target state="translated">활성화되면 동기 점은</target>
        </trans-unit>
        <trans-unit id="f0fe239031ac766fd5ec245813452f6f619b111c" translate="yes" xml:space="preserve">
          <source>When adding a &lt;code&gt;UNIQUE&lt;/code&gt; index on a column (or a set of columns) which have duplicated values, an error will be produced and the statement will be stopped. To suppress the error and force the creation of &lt;code&gt;UNIQUE&lt;/code&gt; indexes, discarding duplicates, the &lt;a href=&quot;../ignore/index&quot;&gt;IGNORE&lt;/a&gt; option can be specified. This can be useful if a column (or a set of columns) should be UNIQUE but it contains duplicate values; however, this technique provides no control on which rows are preserved and which are deleted. Also, note that &lt;code&gt;IGNORE&lt;/code&gt; is accepted but ignored in &lt;code&gt;ALTER TABLE ... EXCHANGE PARTITION&lt;/code&gt; statements.</source>
          <target state="translated">값이 중복 된 열 (또는 열 집합)에 &lt;code&gt;UNIQUE&lt;/code&gt; 인덱스를 추가 하면 오류가 발생하고 명령문이 중지됩니다. 오류를 억제하고 &lt;code&gt;UNIQUE&lt;/code&gt; 인덱스를 작성하여 중복을 삭제하기 위해 &lt;a href=&quot;../ignore/index&quot;&gt;IGNORE&lt;/a&gt; 옵션을 지정할 수 있습니다. 이것은 열 (또는 열 집합)이 UNIQUE 여야하지만 중복 값을 포함하는 경우 유용 할 수 있습니다. 그러나이 기술은 어떤 행이 보존되고 어떤 행이 삭제되는지 제어하지 않습니다. 또한 &lt;code&gt;ALTER TABLE ... EXCHANGE PARTITION&lt;/code&gt; 문 에서는 &lt;code&gt;IGNORE&lt;/code&gt; 가 허용되지만 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="af5fd3455411cc2b954c1f99b38e4ac1648942f8" translate="yes" xml:space="preserve">
          <source>When adding a record to an InnoDB table, here are (roughly) the steps performed to write the data (and PK) and secondary indexes to disk. (I leave out logging, provision for rollback, etc.) First the PRIMARY KEY and data:</source>
          <target state="translated">InnoDB 테이블에 레코드를 추가 할 때, 데이터 (및 PK)와 보조 인덱스를 디스크에 기록하기 위해 수행되는 단계는 거의 같습니다. (로깅, 롤백 제공 등을 생략합니다.) 먼저 기본 키와 데이터 :</target>
        </trans-unit>
        <trans-unit id="1d6e9db724c03f433e10adfd5e78b5bbabd08dc5" translate="yes" xml:space="preserve">
          <source>When all arguments given to the &lt;code&gt;FIELD()&lt;/code&gt; function are strings, they are treated as case-insensitive. When all the arguments are numbers, they are treated as numbers. Otherwise, they are treated as doubles.</source>
          <target state="translated">&lt;code&gt;FIELD()&lt;/code&gt; 함수에 제공된 모든 인수 가 문자열이면 대소 문자를 구분하지 않습니다. 모든 인수가 숫자 인 경우 숫자로 취급됩니다. 그렇지 않으면 복식으로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="f74d780cb7e6aa45f397ce0746844d70737fc3bd" translate="yes" xml:space="preserve">
          <source>When all build prerequisites are met, OQGraph is enabled and compiled automatically. To enable or disable OQGRAPH explicitly, see the generic &lt;a href=&quot;../specifying-what-plugins-to-build/index&quot;&gt;plugin build instructions&lt;/a&gt;.</source>
          <target state="translated">모든 빌드 전제 조건이 충족되면 OQGraph가 사용 가능하고 자동으로 컴파일됩니다. OQGRAPH를 명시 적으로 활성화 또는 비활성화하려면 일반 &lt;a href=&quot;../specifying-what-plugins-to-build/index&quot;&gt;플러그인 빌드 지침을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="311ddc7f2c03f535f5b853fda5fc558da0b8ddf6" translate="yes" xml:space="preserve">
          <source>When all servers are active, then the system status is active. If one or more servers are Man Offline and the others are active, the system is Man Offline. All equipped servers must be active before the system is shown as active.</source>
          <target state="translated">모든 서버가 활성화되면 시스템 상태가 활성화됩니다. 하나 이상의 서버가 오프라인 상태이고 다른 서버가 활성 상태 인 경우 시스템은 오프라인 상태입니다. 시스템이 활성으로 표시되기 전에 모든 장착 된 서버가 활성 상태 여야합니다.</target>
        </trans-unit>
        <trans-unit id="585e17912539f4be9ddec185581de68effd68c74" translate="yes" xml:space="preserve">
          <source>When all the loaded data has been streamed from the MariaDB Servers to ColumnStore, you'll begin to see &lt;code&gt;Read timeout&lt;/code&gt; messages in the output. This means that the &lt;code&gt;mxs_adapter&lt;/code&gt; utility is now waiting on additional binary events to occur on the MariaDB Servers.</source>
          <target state="translated">로드 된 모든 데이터가 MariaDB 서버에서 ColumnStore로 스트리밍 되면 출력에 &lt;code&gt;Read timeout&lt;/code&gt; 메시지가 표시됩니다. 이것은 &lt;code&gt;mxs_adapter&lt;/code&gt; 유틸리티가 MariaDB 서버에서 추가 바이너리 이벤트가 발생하기를 기다리고 있음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="e92b457918d33968e8034c26f7c219dc384d0cf6" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt; is issued, it just modifies the table definition accordingly without changing the data. &lt;a href=&quot;../alter/index&quot;&gt;ALTER&lt;/a&gt; can be used safely to, for instance, modify options such as MAPPED, HUGE or READONLY but with extreme care when modifying column definitions or order options because some column options such as FLAG should also be modified or may become wrong.</source>
          <target state="translated">때 &lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE을&lt;/a&gt; 발행, 그냥 데이터를 변경하지 않고 따라 테이블 정의를 수정합니다. 예를 들어 &lt;a href=&quot;../alter/index&quot;&gt;ALTER&lt;/a&gt; 는 MAPPED, HUGE 또는 READONLY와 같은 옵션을 수정하는 데 안전하게 사용할 수 있지만 FLAG와 같은 일부 열 옵션도 수정되거나 잘못 될 수 있으므로 열 정의 또는 순서 옵션을 수정할 때 특히주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="9670b816c6f0890de847f9b8ec4d0da4e210d822" translate="yes" xml:space="preserve">
          <source>When an InnoDB tablespace has the &lt;code&gt;&lt;a href=&quot;../create-table/index#encrypted&quot;&gt;ENCRYPTED&lt;/a&gt;&lt;/code&gt; table option set to &lt;code&gt;DEFAULT&lt;/code&gt; and the &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encrypt_tables&quot;&gt;innodb_encrypt_tables&lt;/a&gt;&lt;/code&gt; system variable is set to &lt;code&gt;ON&lt;/code&gt; or &lt;code&gt;FORCE&lt;/code&gt;, the tablespace's encryption is automatically managed by the background encryption threads. When you want to disable encryption for these tablespaces, you must ensure that the background encryption threads decrypt the tablespaces before removing the encryption keys. Otherwise, the tablespace remains encrypted and becomes inaccessible once you've removed the keys.</source>
          <target state="translated">InnoDB의 테이블 스페이스는이 때 &lt;code&gt;&lt;a href=&quot;../create-table/index#encrypted&quot;&gt;ENCRYPTED&lt;/a&gt;&lt;/code&gt; 에 테이블 옵션 세트 &lt;code&gt;DEFAULT&lt;/code&gt; 를 하고 &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encrypt_tables&quot;&gt;innodb_encrypt_tables&lt;/a&gt;&lt;/code&gt; 의 시스템 변수로 설정되어 &lt;code&gt;ON&lt;/code&gt; 또는 &lt;code&gt;FORCE&lt;/code&gt; , 테이블 스페이스의 암호화는 자동으로 배경 암호화 스레드에 의해 관리됩니다. 이러한 테이블 스페이스에 대한 암호화를 사용하지 않으려면 암호화 키를 제거하기 전에 백그라운드 암호화 스레드가 테이블 스페이스를 해독해야합니다. 그렇지 않으면 테이블 스페이스는 암호화 된 상태로 유지되며 키를 제거하면 액세스 할 수 없게됩니다.</target>
        </trans-unit>
        <trans-unit id="9f503c9a2fdac79d3536511f7c7cbac34c646da5" translate="yes" xml:space="preserve">
          <source>When an S3 table is opened for the first time (it's not in the table cache) and there is a local .frm file, the S3 engine will check if it's still relevant, and if not, update or delete the .frm file.</source>
          <target state="translated">S3 테이블이 처음으로 열리고 (테이블 캐시에 없음) 로컬 .frm 파일이있는 경우 S3 엔진은 여전히 ​​관련성이 있는지 확인하고 그렇지 않은 경우 .frm 파일을 업데이트하거나 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="b2004334b6e2c867f767cf165bba8a72aa050dd0" translate="yes" xml:space="preserve">
          <source>When an attribute is set, it will be stored with the table definition and shown in the &lt;code&gt;SHOW CREATE TABLE;
&lt;/code&gt;. To remove an attribute from a table definition use &lt;code&gt;ALTER TABLE
&lt;/code&gt; to set its value to a &lt;code&gt;DEFAULT
&lt;/code&gt;.</source>
          <target state="translated">속성이 설정되면 속성이 테이블 정의와 함께 저장되고 &lt;code&gt;SHOW CREATE TABLE; &lt;/code&gt; . 테이블 정의에서 속성을 제거하려면 &lt;code&gt;ALTER TABLE &lt;/code&gt; 을 사용하여 해당 값을 &lt;code&gt;DEFAULT &lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="557526eb8472f8bd6d0a7e916343cf0e6ed3b8d7" translate="yes" xml:space="preserve">
          <source>When an error occurs, one of the error routines is called and an error message is normally sent back to the client immediately. Catching a condition must be done in these error routines (there are quite a few) to prevent them from doing this. We do this by calling a method in the THD's sp_rcontext (if there is one). If a handler is found, this is recorded in the context and the routine returns without sending the error message. The execution loop (sp_head::execute()) checks for this after each statement and invokes the handler that has been found. If several errors or warnings occurs during one statement, only the first is caught, the rest are ignored.</source>
          <target state="translated">오류가 발생하면 오류 루틴 중 하나가 호출되고 일반적으로 오류 메시지가 클라이언트로 즉시 다시 전송됩니다. 이러한 오류 루틴 (조건이 매우 많음)에서 조건을 잡아야이를 수행 할 수 있습니다. THD의 sp_rcontext (있는 경우)에서 메소드를 호출하여이를 수행합니다. 핸들러가 발견되면 컨텍스트에 기록되고 오류 메시지를 보내지 않고 루틴이 리턴됩니다. 실행 루프 (sp_head :: execute ())는 각 명령문 다음에이를 확인하고 발견 된 핸들러를 호출합니다. 한 명령문 동안 여러 오류 또는 경고가 발생하면 첫 번째 명령문 만 포착되고 나머지는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="862911f3610c7e6172c0b21897bc6830cbe94c91" translate="yes" xml:space="preserve">
          <source>When an error raises, in some cases it could be handled by multiple &lt;code&gt;HANDLER&lt;/code&gt;s. For example, there may be an handler for 1050 error, a separate handler for the 42S01 SQLSTATE, and another separate handler for the &lt;code&gt;SQLEXCEPTION&lt;/code&gt; class: in theory all occurrences of &lt;code&gt;HANDLER&lt;/code&gt; may catch the 1050 error, but MariaDB chooses the &lt;code&gt;HANDLER&lt;/code&gt; with the highest precedence. Here are the precedence rules:</source>
          <target state="translated">오류가 발생하면 경우에 따라 여러 &lt;code&gt;HANDLER&lt;/code&gt; 가 처리 할 수 ​​있습니다 . 예를 들어, 1050 오류에 대한 처리기, 42S01 SQLSTATE에 대한 별도의 처리기 및 &lt;code&gt;SQLEXCEPTION&lt;/code&gt; 클래스에 대한 별도의 처리기가 있을 수 있습니다. 이론적으로 &lt;code&gt;HANDLER&lt;/code&gt; 의 모든 발생은 1050 오류를 잡을 수 있지만 MariaDB 는 우선 순위가 가장 높은 &lt;code&gt;HANDLER&lt;/code&gt; 를 선택합니다. . 우선 순위 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4c9c783411eff9a0e6686c93984a62ead4dd476a" translate="yes" xml:space="preserve">
          <source>When an event is logged in its row-based format, many replication filters that affect a database will test the filter against the database that is actually affected by the event.</source>
          <target state="translated">이벤트가 행 기반 형식으로 기록되면 데이터베이스에 영향을주는 많은 복제 필터가 실제로 이벤트의 영향을받는 데이터베이스에 대해 필터를 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="d33a0106fb5c9e478dd1ac5c1260bee6f7ef0578" translate="yes" xml:space="preserve">
          <source>When an event is logged in its statement-based format, many replication filters that affect a database will test the filter against the default database (i.e. the one selected by the &lt;code&gt;&lt;a href=&quot;../use/index&quot;&gt;USE&lt;/a&gt;&lt;/code&gt; statement). This applies to the following replication filters:</source>
          <target state="translated">이벤트가 명령문 기반 형식으로 로깅되면 데이터베이스에 영향을주는 많은 복제 필터가 기본 데이터베이스 (예 : &lt;code&gt;&lt;a href=&quot;../use/index&quot;&gt;USE&lt;/a&gt;&lt;/code&gt; 문에서 선택한 것)에 대해 필터를 테스트합니다 . 이는 다음 복제 필터에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="f51e998cb49e2c11360746b66481adfbcdb06691" translate="yes" xml:space="preserve">
          <source>When an event is logged in its statement-based format, many replication filters that affect a table will test the filter against the table in the default database (i.e. the one selected by the &lt;code&gt;&lt;a href=&quot;../use/index&quot;&gt;USE&lt;/a&gt;&lt;/code&gt; statement). This applies to the following replication filters:</source>
          <target state="translated">이벤트가 명령문 기반 형식으로 로그되면 테이블에 영향을주는 많은 복제 필터가 기본 데이터베이스의 테이블 (예 : &lt;code&gt;&lt;a href=&quot;../use/index&quot;&gt;USE&lt;/a&gt;&lt;/code&gt; 문에서 선택한 것)에 대해 필터를 테스트합니다 . 이는 다음 복제 필터에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="5e1c1e50e4b04dd3b1d1501787dff9d70de06dbb" translate="yes" xml:space="preserve">
          <source>When an index is created, the storage engine may use a configurable buffer in the process. Incrementing the buffer speeds up the index creation. &lt;a href=&quot;../aria/index&quot;&gt;Aria&lt;/a&gt; and &lt;a href=&quot;../myisam/index&quot;&gt;MyISAM&lt;/a&gt; allocate a buffer whose size is defined by &lt;code&gt;&lt;a href=&quot;../aria-server-system-variables/index#aria_sort_buffer_size&quot;&gt;aria_sort_buffer_size&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../myisam-server-system-variables/index#myisam_sort_buffer_size&quot;&gt;myisam_sort_buffer_size&lt;/a&gt;&lt;/code&gt;, also used for &lt;code&gt;&lt;a href=&quot;../repair-table/index&quot;&gt;REPAIR TABLE&lt;/a&gt;&lt;/code&gt;. &lt;a href=&quot;../innodb/index&quot;&gt;InnoDB/XtraDB&lt;/a&gt; allocates three buffers whose size is defined by &lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_sort_buffer_size&quot;&gt;innodb_sort_buffer_size&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">인덱스가 생성되면 스토리지 엔진은 프로세스에서 구성 가능한 버퍼를 사용할 수 있습니다. 버퍼를 늘리면 인덱스 작성 속도가 빨라집니다. &lt;a href=&quot;../aria/index&quot;&gt;Aria&lt;/a&gt; 와 &lt;a href=&quot;../myisam/index&quot;&gt;MyISAM&lt;/a&gt; 은 크기가 &lt;code&gt;&lt;a href=&quot;../aria-server-system-variables/index#aria_sort_buffer_size&quot;&gt;aria_sort_buffer_size&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../myisam-server-system-variables/index#myisam_sort_buffer_size&quot;&gt;myisam_sort_buffer_size&lt;/a&gt;&lt;/code&gt; 에 의해 정의되고 &lt;code&gt;&lt;a href=&quot;../repair-table/index&quot;&gt;REPAIR TABLE&lt;/a&gt;&lt;/code&gt; 에도 사용되는 버퍼를 할당합니다 . &lt;a href=&quot;../innodb/index&quot;&gt;InnoDB / XtraDB&lt;/a&gt; 는 크기가 &lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_sort_buffer_size&quot;&gt;innodb_sort_buffer_size&lt;/a&gt;&lt;/code&gt; 에 의해 정의 된 3 개의 버퍼를 할당 합니다.</target>
        </trans-unit>
        <trans-unit id="e553d203139a19570a55bea2411c466cc15fffdf" translate="yes" xml:space="preserve">
          <source>When an index is recreated, the storage engine may use a configurable buffer in the process. Incrementing the buffer speeds up the index creation. &lt;a href=&quot;../aria/index&quot;&gt;Aria&lt;/a&gt; and &lt;a href=&quot;../myisam/index&quot;&gt;MyISAM&lt;/a&gt; allocate a buffer whose size is defined by &lt;code&gt;&lt;a href=&quot;../aria-server-system-variables/index#aria_sort_buffer_size&quot;&gt;aria_sort_buffer_size&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../myisam-server-system-variables/index#myisam_sort_buffer_size&quot;&gt;myisam_sort_buffer_size&lt;/a&gt;&lt;/code&gt;, also used for &lt;code&gt;&lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">인덱스가 재 작성 될 때 스토리지 엔진은 프로세스에서 구성 가능한 버퍼를 사용할 수 있습니다. 버퍼를 늘리면 인덱스 작성 속도가 빨라집니다. &lt;a href=&quot;../aria/index&quot;&gt;Aria&lt;/a&gt; 와 &lt;a href=&quot;../myisam/index&quot;&gt;MyISAM&lt;/a&gt; 은 크기가 &lt;code&gt;&lt;a href=&quot;../aria-server-system-variables/index#aria_sort_buffer_size&quot;&gt;aria_sort_buffer_size&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../myisam-server-system-variables/index#myisam_sort_buffer_size&quot;&gt;myisam_sort_buffer_size&lt;/a&gt;&lt;/code&gt; 로 정의 된 버퍼를 할당하며 &lt;code&gt;&lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt;&lt;/code&gt; 에도 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e4c5dbadcf198740cbcf188bc1cddf933368ee1a" translate="yes" xml:space="preserve">
          <source>When an unsafe statement is run, the current binary logging format determines how the server responds.</source>
          <target state="translated">안전하지 않은 명령문이 실행될 때 현재 이진 로깅 형식에 따라 서버의 응답 방식이 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="e90559220ef6b78bc32c95bbbfef583927915c14" translate="yes" xml:space="preserve">
          <source>When an xid is added to an active page, the thread of this xid waits for a page's condition until the page is synced. When a syncing slot becomes vacant one of these waiters is awakened to take care of syncing. It syncs the page and signals all waiters that the page is synced. The waiters are counted, and a page may never become active again until waiters==0, which means that is all waiters from the previous sync have noticed that the sync was completed.</source>
          <target state="translated">xid가 활성 페이지에 추가되면이 xid의 스레드는 페이지가 동기화 될 때까지 페이지 상태를 기다립니다. 동기화 슬롯이 비어 있으면이 웨이터 중 하나가 동기화를 처리하기 위해 깨어납니다. 페이지를 동기화하고 모든 웨이터에게 페이지가 동기화되었음을 알립니다. 웨이터가 계산되고, 웨이터가 == 0이 될 때까지 페이지가 다시 활성화되지 않을 수 있습니다. 즉, 이전 동기화의 모든 웨이터가 동기화가 완료되었음을 알았습니다.</target>
        </trans-unit>
        <trans-unit id="b8b89879732016fe566730e8422587c21544eaa7" translate="yes" xml:space="preserve">
          <source>When assigning the same value to several variables, &lt;a href=&quot;../last_value/index&quot;&gt;LAST_VALUE()&lt;/a&gt; can be useful.</source>
          <target state="translated">동일한 값을 여러 변수에 할당 할 때 &lt;a href=&quot;../last_value/index&quot;&gt;LAST_VALUE ()&lt;/a&gt; 가 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa20c15b8fd7e81f9ef75d989ab91440ce239e9a" translate="yes" xml:space="preserve">
          <source>When at least one semisynchronous slave catches up, semisynchronous replication is resumed. This will be reflected in the master's &lt;a href=&quot;../error-log/index&quot;&gt;error log&lt;/a&gt; with messages like the following:</source>
          <target state="translated">적어도 하나의 반동기 슬레이브가 따라 잡으면 반동기 복제가 재개됩니다. 이것은 다음과 같은 메시지와 함께 마스터의 &lt;a href=&quot;../error-log/index&quot;&gt;오류 로그에&lt;/a&gt; 반영됩니다 .</target>
        </trans-unit>
        <trans-unit id="451c71588fe051da570583543e6b03f0399a9384" translate="yes" xml:space="preserve">
          <source>When attempting to add a value that is out of the valid range for the numeric type, MariaDB will react depending on the &lt;a href=&quot;../sql-mode/index#strict-mode&quot;&gt;strict SQL_MODE&lt;/a&gt; setting.</source>
          <target state="translated">숫자 유형의 유효 범위를 벗어난 값을 추가하려고 시도하면 MariaDB는 &lt;a href=&quot;../sql-mode/index#strict-mode&quot;&gt;엄격한 SQL_MODE&lt;/a&gt; 설정 에 따라 반응 합니다.</target>
        </trans-unit>
        <trans-unit id="bbb043b2fe82afbbd6864eca09750a016ddd9ceb" translate="yes" xml:space="preserve">
          <source>When auto-incrementing columns run out of values, &lt;a href=&quot;../insert/index&quot;&gt;INSERT&lt;/a&gt; statements generate duplicate-key errors.</source>
          <target state="translated">자동 증분 열에 값이 부족하면 &lt;a href=&quot;../insert/index&quot;&gt;INSERT&lt;/a&gt; 문에서 중복 키 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="cbff67eb506c370cdd797b07efa44b29e036b5a0" translate="yes" xml:space="preserve">
          <source>When backing up Percona Server, Mariabackup would use backup locks by default. To be specific, backup locks refers to the &lt;code&gt;LOCK TABLES FOR BACKUP&lt;/code&gt; and &lt;code&gt;LOCK BINLOG FOR BACKUP&lt;/code&gt; statements. This option can be used to disable support for Percona Server's backup locks. This option has no effect when the server does not support Percona's backup locks.</source>
          <target state="translated">Percona Server를 백업 할 때 Mariabackup은 기본적으로 백업 잠금을 사용합니다. 구체적으로, 백업 잠금은 &lt;code&gt;LOCK TABLES FOR BACKUP&lt;/code&gt; 및 &lt;code&gt;LOCK BINLOG FOR BACKUP&lt;/code&gt; 문을 나타냅니다. 이 옵션은 Percona Server의 백업 잠금 지원을 비활성화하는 데 사용할 수 있습니다. 서버가 Percona의 백업 잠금을 지원하지 않는 경우이 옵션은 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="01287821860ae6469e3ffd5882298471b3c7bf46" translate="yes" xml:space="preserve">
          <source>When both are used, the qualified table name has precedence over DBNAME . For instance:</source>
          <target state="translated">둘 다 사용되면 규정 된 테이블 이름이 DBNAME보다 우선합니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="20bfc68b03a9d1436e718eeaf9d04c323b8a3b68" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;CURRENT_USER()&lt;/code&gt; in a stored procedure, it returns the owner of the stored procedure, as defined with &lt;code&gt;DEFINER&lt;/code&gt;.</source>
          <target state="translated">저장 프로 시저에서 &lt;code&gt;CURRENT_USER()&lt;/code&gt; 를 호출하면 &lt;code&gt;DEFINER&lt;/code&gt; 로 정의 된 저장 프로 시저의 소유자를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="824ba4e3e4f24eddbc2954b36501750887356408" translate="yes" xml:space="preserve">
          <source>When changing the &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encrypt_tables&quot;&gt;innodb_encrypt_tables&lt;/a&gt;&lt;/code&gt; system variable to &lt;code&gt;FORCE&lt;/code&gt;, InnoDB's background encryption threads encrypt the &lt;a href=&quot;../innodb-system-tablespaces/index&quot;&gt;system&lt;/a&gt; tablespace and any &lt;a href=&quot;../innodb-file-per-table-tablespaces/index&quot;&gt;file-per-table&lt;/a&gt; tablespaces that have the &lt;code&gt;&lt;a href=&quot;../create-table/index#encrypted&quot;&gt;ENCRYPTED&lt;/a&gt;&lt;/code&gt; table option set to &lt;code&gt;DEFAULT&lt;/code&gt;.</source>
          <target state="translated">변화하는 때 &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encrypt_tables&quot;&gt;innodb_encrypt_tables&lt;/a&gt;&lt;/code&gt; 의 에 시스템 변수 &lt;code&gt;FORCE&lt;/code&gt; 를 , 이노의 배경 암호화 스레드는 암호화 &lt;a href=&quot;../innodb-system-tablespaces/index&quot;&gt;시스템&lt;/a&gt; 테이블 및 &lt;a href=&quot;../innodb-file-per-table-tablespaces/index&quot;&gt;파일 테이블 당&lt;/a&gt; 이 테이블 &lt;code&gt;&lt;a href=&quot;../create-table/index#encrypted&quot;&gt;ENCRYPTED&lt;/a&gt;&lt;/code&gt; 표 옵션 세트 &lt;code&gt;DEFAULT&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="191a36b4ea9c34f0849bb9747aba00c1926e8780" translate="yes" xml:space="preserve">
          <source>When changing the &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encrypt_tables&quot;&gt;innodb_encrypt_tables&lt;/a&gt;&lt;/code&gt; system variable to &lt;code&gt;OFF&lt;/code&gt;, InnoDB's background encryption threads decrypt the &lt;a href=&quot;../innodb-system-tablespaces/index&quot;&gt;system&lt;/a&gt; tablespace and any &lt;a href=&quot;../innodb-file-per-table-tablespaces/index&quot;&gt;file-per-table&lt;/a&gt; tablespacs that have the &lt;code&gt;&lt;a href=&quot;../create-table/index#encrypted&quot;&gt;ENCRYPTED&lt;/a&gt;&lt;/code&gt; table option set to &lt;code&gt;DEFAULT&lt;/code&gt;.</source>
          <target state="translated">변화하는 때 &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encrypt_tables&quot;&gt;innodb_encrypt_tables&lt;/a&gt;&lt;/code&gt; 의 에 시스템 변수 &lt;code&gt;OFF&lt;/code&gt; 를 , 이노의 배경 암호화 스레드는 해독 &lt;a href=&quot;../innodb-system-tablespaces/index&quot;&gt;시스템&lt;/a&gt; 테이블 및 &lt;a href=&quot;../innodb-file-per-table-tablespaces/index&quot;&gt;파일 테이블 당&lt;/a&gt; 이 tablespacs &lt;code&gt;&lt;a href=&quot;../create-table/index#encrypted&quot;&gt;ENCRYPTED&lt;/a&gt;&lt;/code&gt; 표 옵션 세트 &lt;code&gt;DEFAULT&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="87c9971cfb7915c49d2351cd2e5a83ac8d9f9110" translate="yes" xml:space="preserve">
          <source>When checksums are disabled on the master (or the master has the old version with no checksums implemented), there is no problem. In this case the binlog format is backwards compatible, and replication works fine.</source>
          <target state="translated">마스터에서 체크섬이 비활성화되어 있거나 마스터에 체크섬이 구현되지 않은 이전 버전이있는 경우 문제가 없습니다. 이 경우 binlog 형식은 이전 버전과 호환되며 복제가 제대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="a52f7069c47a6e00803026491dca4ba106028a68" translate="yes" xml:space="preserve">
          <source>When checksums are enabled, replication slaves will check events received over the network for checksum errors, and will stop with an error if a corrupt event is detected.</source>
          <target state="translated">체크섬이 활성화되면 복제 슬레이브는 네트워크를 통해 수신 된 이벤트에서 체크섬 오류를 확인하고 손상된 이벤트가 감지되면 오류와 함께 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="3344b756006b58336c3bcf1ad0832931871aab12" translate="yes" xml:space="preserve">
          <source>When connecting from Unix client to Windows server with ADO.NET, in an Active Directory domain environment, be aware that .NET Core on Unix does not support principal names in UPN(User Principal Name) form, which is default on Windows (e.g machine$@domain.com) . Thus, upon encountering an authentication exception with &quot;server not found in Kerberos database&quot;, use one of workarounds below</source>
          <target state="translated">ADO.NET을 사용하여 Unix 클라이언트에서 Windows 서버로 연결하는 경우 Active Directory 도메인 환경에서 Unix의 .NET Core는 UPN (User Principal Name) 형식의 주체 이름을 지원하지 않습니다. $@domain.com). 따라서 &quot;Kerberos 데이터베이스에 서버를 찾을 수 없습니다&quot;라는 인증 예외가 발생하면 아래 해결 방법 중 하나를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="340f34f49082634362b5aecad602f8f8e98f243d" translate="yes" xml:space="preserve">
          <source>When connecting through ODBC, the MariaDB Server operates as a client to the foreign database management system. As such, it requires that you configure MariaDB as you would configure native clients for the given database server.</source>
          <target state="translated">ODBC를 통해 연결할 때 MariaDB 서버는 외부 데이터베이스 관리 시스템에 대한 클라이언트로 작동합니다. 따라서 지정된 데이터베이스 서버에 대해 기본 클라이언트를 구성 할 때 MariaDB를 구성해야합니다.</target>
        </trans-unit>
        <trans-unit id="fb986b687fccbe89ea07ac2354c2d481adeb1087" translate="yes" xml:space="preserve">
          <source>When connecting with &lt;code&gt;AND&lt;/code&gt;, parentheses are added to make sure the correct precedence is used.</source>
          <target state="translated">&lt;code&gt;AND&lt;/code&gt; 로 연결할 때 올바른 우선 순위가 사용되도록 괄호가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="60e45535a8b2539623f7dd18543fd4c06cecb1ee" translate="yes" xml:space="preserve">
          <source>When connecting with a &lt;a href=&quot;../clients-utilities/index&quot;&gt;client or utility&lt;/a&gt; to a server as a user account that authenticates with the &lt;code&gt;ed25519&lt;/code&gt; authentication plugin, you may need to tell the client where to find the relevant client authentication plugin by specifying the &lt;code&gt;--plugin-dir&lt;/code&gt; option. For example:</source>
          <target state="translated">와 연결할 때 &lt;a href=&quot;../clients-utilities/index&quot;&gt;클라이언트 또는 유틸리티&lt;/a&gt; 로 인증이있는 사용자 계정으로 서버에 &lt;code&gt;ed25519&lt;/code&gt; 인증 플러그인, 당신이 어디에 지정하여 해당 클라이언트 인증 플러그인을 찾을 수있는 클라이언트를 알려줄 필요가 있습니다 &lt;code&gt;--plugin-dir&lt;/code&gt; 옵션을 선택합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4e18ab0c84980e218c229fefd3b96ac4acbc3444" translate="yes" xml:space="preserve">
          <source>When connecting with a &lt;a href=&quot;../clients-utilities/index&quot;&gt;client or utility&lt;/a&gt; to a server as a user account that authenticates with the &lt;code&gt;gssapi&lt;/code&gt; authentication plugin, you may need to tell the client where to find the relevant client authentication plugin by specifying the &lt;code&gt;--plugin-dir&lt;/code&gt; option. For example:</source>
          <target state="translated">와 연결할 때 &lt;a href=&quot;../clients-utilities/index&quot;&gt;클라이언트 또는 유틸리티&lt;/a&gt; 로 인증이있는 사용자 계정으로 서버에 &lt;code&gt;gssapi&lt;/code&gt; 인증 플러그인, 당신이 어디에 지정하여 해당 클라이언트 인증 플러그인을 찾을 수있는 클라이언트를 알려줄 필요가 있습니다 &lt;code&gt;--plugin-dir&lt;/code&gt; 옵션을 선택합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d6cda4adbcf90fb87cfac4e627e101b1e367bb96" translate="yes" xml:space="preserve">
          <source>When connecting with a &lt;a href=&quot;../clients-utilities/index&quot;&gt;client or utility&lt;/a&gt; to a server as a user account that authenticates with the &lt;code&gt;mysql_native_password&lt;/code&gt; authentication plugin, you may need to tell the client where to find the relevant client authentication plugin by specifying the &lt;code&gt;--plugin-dir&lt;/code&gt; option. For example:</source>
          <target state="translated">와 연결할 때 &lt;a href=&quot;../clients-utilities/index&quot;&gt;클라이언트 또는 유틸리티&lt;/a&gt; 로 인증이있는 사용자 계정으로 서버에 &lt;code&gt;mysql_native_password&lt;/code&gt; 인증 플러그인, 당신이 어디에 지정하여 해당 클라이언트 인증 플러그인을 찾을 수있는 클라이언트를 알려줄 필요가 있습니다 &lt;code&gt;--plugin-dir&lt;/code&gt; 옵션을 선택합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="69705cf9d76963930459c6e6d94cc49e200a329e" translate="yes" xml:space="preserve">
          <source>When connecting with a &lt;a href=&quot;../clients-utilities/index&quot;&gt;client or utility&lt;/a&gt; to a server as a user account that authenticates with the &lt;code&gt;mysql_old_password&lt;/code&gt; authentication plugin, you may need to tell the client where to find the relevant client authentication plugin by specifying the &lt;code&gt;--plugin-dir&lt;/code&gt; option. For example:</source>
          <target state="translated">와 연결할 때 &lt;a href=&quot;../clients-utilities/index&quot;&gt;클라이언트 또는 유틸리티&lt;/a&gt; 로 인증이있는 사용자 계정으로 서버에 &lt;code&gt;mysql_old_password&lt;/code&gt; 인증 플러그인, 당신이 어디에 지정하여 해당 클라이언트 인증 플러그인을 찾을 수있는 클라이언트를 알려줄 필요가 있습니다 &lt;code&gt;--plugin-dir&lt;/code&gt; 옵션을 선택합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="52096532cd060ffe2074acbd8e7b93d1023e3743" translate="yes" xml:space="preserve">
          <source>When connecting with a &lt;a href=&quot;../clients-utilities/index&quot;&gt;client or utility&lt;/a&gt; to a server as a user account that authenticates with the &lt;code&gt;pam&lt;/code&gt; authentication plugin, you may need to tell the client where to find the relevant client authentication plugin by specifying the &lt;code&gt;--plugin-dir&lt;/code&gt; option. For example:</source>
          <target state="translated">와 연결할 때 &lt;a href=&quot;../clients-utilities/index&quot;&gt;클라이언트 또는 유틸리티&lt;/a&gt; 사용하여 인증하는 사용자 계정으로 서버에 &lt;code&gt;pam&lt;/code&gt; 인증 플러그인, 당신은 위치를 지정하여 해당 클라이언트 인증 플러그인을 찾을 수있는 클라이언트를 알려줄 필요가 있습니다 &lt;code&gt;--plugin-dir&lt;/code&gt; 옵션을 선택합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="32cd6b17ba4d6817c225929e50d6f45711ca1a0d" translate="yes" xml:space="preserve">
          <source>When connecting with a &lt;a href=&quot;../clients-utilities/index&quot;&gt;client or utility&lt;/a&gt; to a server as a user account that authenticates with the &lt;code&gt;sha256_password&lt;/code&gt; or &lt;code&gt;caching_sha256_password&lt;/code&gt; authentication plugin, you may need to tell the client where to find the relevant client authentication plugin by specifying the &lt;code&gt;--plugin-dir&lt;/code&gt; option. For example:</source>
          <target state="translated">와 연결할 때 &lt;a href=&quot;../clients-utilities/index&quot;&gt;클라이언트 또는 유틸리티&lt;/a&gt; 사용하여 인증하는 사용자 계정으로 서버에 &lt;code&gt;sha256_password&lt;/code&gt; 가 또는 &lt;code&gt;caching_sha256_password&lt;/code&gt; 인증 플러그인, 당신이 어디에 지정하여 해당 클라이언트 인증 플러그인을 찾을 수있는 클라이언트를 알려줄 필요가 있습니다 &lt;code&gt;--plugin-dir&lt;/code&gt; 옵션을 선택합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d7c87b528d41fe2b3d94d6e92c0df9df0996156a" translate="yes" xml:space="preserve">
          <source>When converted, MariaDB types are converted as:</source>
          <target state="translated">변환시 MariaDB 유형은 다음과 같이 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="143ff075e23cfed99900fbcd53e5be30f3c8558f" translate="yes" xml:space="preserve">
          <source>When creating &lt;a href=&quot;../stored-programs-and-views/index&quot;&gt;stored programs&lt;/a&gt; from the command-line, it is likely you will need to differentiate between the regular delimiter and a delimiter inside a &lt;a href=&quot;../begin-end/index&quot;&gt;BEGIN END&lt;/a&gt; block. To understand better, consider the following example:</source>
          <target state="translated">명령 행에서 &lt;a href=&quot;../stored-programs-and-views/index&quot;&gt;저장된 프로그램&lt;/a&gt; 을 작성할 때 &lt;a href=&quot;../begin-end/index&quot;&gt;BEGIN END&lt;/a&gt; 블록 내에서 일반 분리 문자와 분리 문자를 구별해야합니다 . 더 잘 이해하려면 다음 예를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="e4fb87a919143fac65a67b8f9f6920bc5d094668" translate="yes" xml:space="preserve">
          <source>When creating a new password, if the criteria are not met, the following error is returned:</source>
          <target state="translated">새 비밀번호를 작성할 때 기준에 맞지 않으면 다음 오류가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="333f81ca88d339176246ba2756154fc59f23f89a" translate="yes" xml:space="preserve">
          <source>When creating a standard ODBC table, you should make sure only one source table is specified. Specifying more than one source table must be done only for CONNECT catalog tables (with CATFUNC=tables or columns).</source>
          <target state="translated">표준 ODBC 테이블을 작성할 때 하나의 소스 테이블 만 지정해야합니다. 둘 이상의 소스 테이블 지정은 CONNECT 카탈로그 테이블에 대해서만 수행해야합니다 (CATFUNC = 테이블 또는 열 사용).</target>
        </trans-unit>
        <trans-unit id="43aeed8a429833d331bcfd589bb26a60c4c7d319" translate="yes" xml:space="preserve">
          <source>When creating a table or index, you can specify the name of the column family for it. If the column family doesn't exist, it will be automatically created.</source>
          <target state="translated">테이블이나 인덱스를 만들 때 열 패밀리의 이름을 지정할 수 있습니다. 열 패밀리가 없으면 자동으로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="847ab0c80d1531c29da11bbfaf5efc95f6a4630e" translate="yes" xml:space="preserve">
          <source>When creating or altering a user account with the &lt;code&gt;&lt;a href=&quot;../grant/index&quot;&gt;GRANT&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../create-user/index&quot;&gt;CREATE USER&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../alter-user/index&quot;&gt;ALTER USER&lt;/a&gt;&lt;/code&gt; statements, you can specify the authentication plugin you want the user account to use by providing the &lt;code&gt;IDENTIFIED VIA&lt;/code&gt; clause. By default, when you issue one of these statements for a user account without specifying an authentication plugin, MariaDB uses the &lt;code&gt;&lt;a href=&quot;../authentication-plugin-mysql_native_password/index&quot;&gt;mysql_native_password&lt;/a&gt;&lt;/code&gt; plugin.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../grant/index&quot;&gt;GRANT&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../create-user/index&quot;&gt;CREATE USER&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../alter-user/index&quot;&gt;ALTER USER&lt;/a&gt;&lt;/code&gt; 문 으로 사용자 계정을 만들거나 변경할 때 &lt;code&gt;IDENTIFIED VIA&lt;/code&gt; 절 을 제공하여 사용자 계정에 사용할 인증 플러그인을 지정할 수 있습니다 . 기본적으로 인증 플러그인을 지정하지 않고 사용자 계정에 대해 다음 명령문 중 하나를 발행하면 MariaDB는 &lt;code&gt;&lt;a href=&quot;../authentication-plugin-mysql_native_password/index&quot;&gt;mysql_native_password&lt;/a&gt;&lt;/code&gt; 플러그인을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="6df9b2630844a90d0d23e45b822e52bde88fcb33" translate="yes" xml:space="preserve">
          <source>When creating the file, the connection name is converted to lower case and all special characters in the connection name are converted, the same way as MySQL table names are converted. This is done to make the file name portable across different systems.</source>
          <target state="translated">파일을 만들 때 연결 이름은 소문자로 변환되고 연결 이름의 모든 특수 문자는 MySQL 테이블 이름과 같은 방식으로 변환됩니다. 이것은 여러 시스템에서 파일 이름을 이식 가능하게하기 위해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="3eb4130976f062a937cc61a7f60065ecce05c061" translate="yes" xml:space="preserve">
          <source>When dealing with small tables, the simpler way to enable random access is to specify a rowset size equal or larger than the table size (or the result set size if a push down where clause is used). This means that the whole result is in memory on the first fetch and CONNECT will use it for further positional accesses.</source>
          <target state="translated">작은 테이블을 처리 할 때 임의 액세스를 사용하는 가장 간단한 방법은 테이블 크기와 같거나 큰 행 집합 크기를 지정하는 것입니다 (또는 push down where 절을 사용하는 경우 결과 집합 크기). 이는 전체 결과가 첫 번째 페치에서 메모리에 있고 CONNECT가 추가 위치 액세스에이를 사용함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="b89dd1a5eafb13d84ce28855f70c20335d08c4f4" translate="yes" xml:space="preserve">
          <source>When debug logging is enabled, the &lt;code&gt;pam_user_map&lt;/code&gt; PAM module will write log entries to the &lt;a href=&quot;../authentication-plugin-pam/index#logging&quot;&gt;same syslog location&lt;/a&gt; as other PAM modules, which is typically &lt;code&gt;/var/log/secure&lt;/code&gt; on many systems.</source>
          <target state="translated">디버그 로깅이 활성화되면 &lt;code&gt;pam_user_map&lt;/code&gt; PAM 모듈은 다른 PAM 모듈과 &lt;a href=&quot;../authentication-plugin-pam/index#logging&quot;&gt;동일한 syslog 위치에&lt;/a&gt; 로그 항목을 기록합니다. 일반적으로 많은 시스템에서 &lt;code&gt;/var/log/secure&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5029c58cc60dc291a2d35589ac939e9db9d4fadb" translate="yes" xml:space="preserve">
          <source>When defining a raw disk partition for InnoDB on the Windows operating system, use the same procedure as defined above, but when defining the path for the &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_data_file_path&quot;&gt;innodb_data_file_path&lt;/a&gt;&lt;/code&gt; system variable, use &lt;code&gt;&lt;em&gt;./&lt;/em&gt;&lt;/code&gt; at the start. For example:</source>
          <target state="translated">Windows 운영 체제에서 InnoDB에 대한 원시 디스크 파티션을 정의 할 때는 위에서 정의한 것과 동일한 절차를 사용하지만 &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_data_file_path&quot;&gt;innodb_data_file_path&lt;/a&gt;&lt;/code&gt; 시스템 변수 의 경로를 정의 할 때는 시작시 &lt;code&gt;&lt;em&gt;./&lt;/em&gt;&lt;/code&gt; 를 사용 하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c3e144c5f4d79e0646f8f27a3d6b31f987cf56ff" translate="yes" xml:space="preserve">
          <source>When defining an index on an auto-incrementing column, it must be defined in a way that allows the equivalent of &lt;code&gt;SELECT MAX(col)&lt;/code&gt; lookups on the table.</source>
          <target state="translated">자동 증분 열에서 인덱스를 정의 할 때는 테이블에서 &lt;code&gt;SELECT MAX(col)&lt;/code&gt; 조회 와 동등한 방식으로 정의해야 합니다.</target>
        </trans-unit>
        <trans-unit id="4cd565e8246401f632719000ff77a7a540019b7b" translate="yes" xml:space="preserve">
          <source>When deleting in chunks, be sure to avoid doing a table scan. The code below is good at that; it scans no more than 1001 rows in any one query. (The 1000 is tunable.)</source>
          <target state="translated">청크를 삭제할 때 테이블 스캔을 수행하지 마십시오. 아래 코드는 그 점을 잘 보여줍니다. 하나의 쿼리에서 1001 개 이하의 행을 스캔합니다. (1000은 조정 가능합니다.)</target>
        </trans-unit>
        <trans-unit id="e329825fb47653e8c24cabe06f4c6b439829c7d3" translate="yes" xml:space="preserve">
          <source>When deploying MariaDB ColumnStore with multiple Performance Module nodes, a heartbeat mechanism ensures that all nodes are online and there is transparent failover in the event that a particular node fails. If a node abnormally terminates, in-process queries return an error. Users that receive an error due to Performance Module can resubmit the query. ColumnStore then does the work using the remaining Performance Modules.</source>
          <target state="translated">다중 성능 모듈 노드가있는 MariaDB ColumnStore를 배포 할 때 하트 비트 메커니즘을 통해 모든 노드가 온라인 상태가되고 특정 노드가 실패 할 경우 투명한 장애 조치가 이루어집니다. 노드가 비정상적으로 종료되면 처리 중 쿼리가 오류를 반환합니다. 성능 모듈로 인해 오류가 발생한 사용자는 쿼리를 다시 제출할 수 있습니다. 그런 다음 ColumnStore는 나머지 성능 모듈을 사용하여 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="469ddf3a0dba5297b3d1d7e9289c053773f9cb87" translate="yes" xml:space="preserve">
          <source>When developing this handler, I compiled the FederatedX database with debugging:</source>
          <target state="translated">이 핸들러를 개발할 때 FederatedX 데이터베이스를 디버깅으로 컴파일했습니다.</target>
        </trans-unit>
        <trans-unit id="efac5367408ac2c34fba4e4645a3b570774760ec" translate="yes" xml:space="preserve">
          <source>When displayed in the &lt;a href=&quot;../information-schema-columns-table/index&quot;&gt;INFORMATION_SCHEMA.COLUMNS&lt;/a&gt; table, a default &lt;a href=&quot;../current_timestamp/index&quot;&gt;CURRENT TIMESTAMP&lt;/a&gt; is displayed as &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt; up until &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1022-release-notes/&quot;&gt;MariaDB 10.2.2&lt;/a&gt;, and as &lt;code&gt;current_timestamp()&lt;/code&gt; from &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1023-release-notes/&quot;&gt;MariaDB 10.2.3&lt;/a&gt;, due to to &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt; accepting expressions in the DEFAULT clause.</source>
          <target state="translated">에 표시 할 때 &lt;a href=&quot;../information-schema-columns-table/index&quot;&gt;INFORMATION_SCHEMA.COLUMNS의&lt;/a&gt; 테이블, 기본 &lt;a href=&quot;../current_timestamp/index&quot;&gt;CURRENT TIMESTAMP가&lt;/a&gt; 표시됩니다 &lt;code&gt;CURRENT_TIMESTAMP&lt;/code&gt; 까지 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1022-release-notes/&quot;&gt;MariaDB 10.2.2&lt;/a&gt; , 그리고 &lt;code&gt;current_timestamp()&lt;/code&gt; 에서 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1023-release-notes/&quot;&gt;MariaDB 10.2.3&lt;/a&gt; , 인해에 &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt; DEFAULT 절에서 표현식을 수용.</target>
        </trans-unit>
        <trans-unit id="a22eda2fdd2307ea6245b8eb2720ac539953aab5" translate="yes" xml:space="preserve">
          <source>When displaying it by</source>
          <target state="translated">로 표시 할 때</target>
        </trans-unit>
        <trans-unit id="629c2aa4f358d5805bb99c2f81fefbd86f9731f8" translate="yes" xml:space="preserve">
          <source>When doing many inserts in a row, you should wrap them with &lt;code&gt;BEGIN / END&lt;/code&gt; to avoid doing a full transaction (which includes a disk sync) for every row. For example, doing a begin/end every 1000 inserts will speed up your inserts by almost 1000 times.</source>
          <target state="translated">행에 많은 삽입을 수행 할 때 모든 행에 대해 전체 트랜잭션 (디스크 동기화 포함)을 수행하지 않도록 &lt;code&gt;BEGIN / END&lt;/code&gt; 로 삽입해야합니다 . 예를 들어, 1000 개의 인서트마다 시작 / 종료를 수행하면 인서트 속도가 거의 1000 배 빨라집니다.</target>
        </trans-unit>
        <trans-unit id="21c0585e9ae7304fa00694a7731b021b09fd0d37" translate="yes" xml:space="preserve">
          <source>When doing ref access on IDX1, check $FILTER before reading the full record</source>
          <target state="translated">IDX1에 대한 참조 액세스를 수행 할 때 전체 레코드를 읽기 전에 $ FILTER를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="24f067f06c245d7624e004deca7c2fba634afb05" translate="yes" xml:space="preserve">
          <source>When doing so, nulls do not appear in object text or array lists. However, this does not change the behavior of array calculation nor the result of array count.</source>
          <target state="translated">이렇게하면 개체 텍스트 나 배열 목록에 null이 나타나지 않습니다. 그러나 이것은 배열 계산 동작이나 배열 수의 결과를 변경하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="b17c405501e04f838a82079816cb85d3396de920" translate="yes" xml:space="preserve">
          <source>When doing so, the connection string just contains the name of the predefined Data Source. For instance:</source>
          <target state="translated">그렇게 할 때 연결 문자열에는 사전 정의 된 데이터 소스의 이름 만 포함됩니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="7ca04e32ae6d78ecd5d7af86f6fa39338c6d22ce" translate="yes" xml:space="preserve">
          <source>When doing tests. For instance to check a connection string.</source>
          <target state="translated">테스트를 할 때. 예를 들어 연결 문자열을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="720c5001e5758349682f3ca4fcbec99b652e9c4b" translate="yes" xml:space="preserve">
          <source>When either the XML fragment or the XPath expression is &lt;code&gt;NULL&lt;/code&gt;, the &lt;code&gt;EXTRACTVALUE()&lt;/code&gt; function returns &lt;code&gt;NULL&lt;/code&gt;. When the XML fragment is invalid, it raises a warning Code 1525:</source>
          <target state="translated">XML 단편 또는 XPath 표현식이 &lt;code&gt;NULL&lt;/code&gt; 인 경우 &lt;code&gt;EXTRACTVALUE()&lt;/code&gt; 함수는 &lt;code&gt;NULL&lt;/code&gt; 을 리턴 합니다. . XML 조각이 유효하지 않으면 경고 코드 1525가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="324c4b4688e22ec1b43379ef1b41236d39bde18f" translate="yes" xml:space="preserve">
          <source>When enabled the history of query statistics across all sessions along with execution time, and those stats provided by calgetstats() is stored in a table in the infinidb_querystats schema. Only queries in the following ColumnStore syntax are available for statistics monitoring:</source>
          <target state="translated">실행 시간과 함께 모든 세션에서 쿼리 통계 히스토리를 사용 가능하게하면 calgetstats ()가 제공하는 통계는 infinidb_querystats 스키마의 테이블에 저장됩니다. 통계 모니터링에는 다음 ColumnStore 구문의 쿼리 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c9f2ff4131008f6cb9b0187306159ff1c5ea618" translate="yes" xml:space="preserve">
          <source>When enabled, subtraction results are signed even if the operands are unsigned.</source>
          <target state="translated">사용 가능하면 피연산자가 부호가 없더라도 빼기 결과에 부호가 있습니다.</target>
        </trans-unit>
        <trans-unit id="af8049b6c338af5ce84dc0559fad5be6473b708a" translate="yes" xml:space="preserve">
          <source>When enabled, whether using &lt;code&gt;ON&lt;/code&gt; or &lt;code&gt;AUTO&lt;/code&gt;, Mariabackup retrieves information from the binlog during the backup process. When disabled with &lt;code&gt;OFF&lt;/code&gt;, Mariabackup runs without attempting to retrieve binary log information. You may find this useful when you need to copy data without metadata like the binlog or replication coordinates.</source>
          <target state="translated">&lt;code&gt;ON&lt;/code&gt; 또는 &lt;code&gt;AUTO&lt;/code&gt; 사용 여부에 관계없이 Mariabackup은 백업 프로세스 중에 binlog에서 정보를 검색합니다. &lt;code&gt;OFF&lt;/code&gt; 로 비활성화 된 경우 Mariabackup은 이진 로그 정보를 검색하지 않고 실행됩니다. binlog 또는 복제 좌표와 같은 메타 데이터없이 데이터를 복사해야 할 때이 기능이 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3a9b6e19bd1aa07dfe14b7f61d966a22632795e" translate="yes" xml:space="preserve">
          <source>When encountering a SP_FUNC with parameters in the expression parser, an instance of the new Item_func_sp class is created. Unlike UDFs, we don't have different classes for different return types, since we at this point don't know the type.</source>
          <target state="translated">표현식 구문 분석기에서 매개 변수가있는 SP_FUNC가 발생하면 새 Item_func_sp 클래스의 인스턴스가 작성됩니다. UDF와 달리, 리턴 유형마다 다른 클래스가 없습니다.이 시점에서 유형을 알 수 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="09dd21731e31761a4515475341a4dc4ecd5fe920" translate="yes" xml:space="preserve">
          <source>When encrypting any InnoDB or XtraDB tables, the best practice is also enable encryption for the Redo Log. If you have encrypted InnoDB tables and have not encrypted the Redo Log, data written to an encrypted table may be found unencrypted in the Redo Log.</source>
          <target state="translated">InnoDB 또는 XtraDB 테이블을 암호화 할 때 가장 좋은 방법은 다시 실행 로그에 대한 암호화를 활성화하는 것입니다. InnoDB 테이블을 암호화하고 Redo Log를 암호화하지 않은 경우 암호화 된 테이블에 기록 된 데이터는 Redo Log에서 암호화되지 않은 것으로 발견 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ef9e91b0c084164d1fece5b2ba802fc2183a510" translate="yes" xml:space="preserve">
          <source>When events are filtered due to &lt;code&gt;@@skip_replication&lt;/code&gt;, the filtering happens on the master side; in other words, the event is never sent to the slave. If many events are filtered like this, a slave can sit a long time without receiving any events from the master. This is not a problem in itself, but must be kept in mind when inquiring on the slave about events that are filtered. For example &lt;code&gt;START SLAVE UNTIL &amp;lt;some position&amp;gt;&lt;/code&gt; will stop when the first event that is &lt;strong&gt;not&lt;/strong&gt; filtered is encountered at the given position or beyond. If the event at the given position is filtered, then the slave thread will only stop when the next non-filtered event is encountered. In effect, if an event is filtered, to the slave it appears that it was never written to the binlog on the master.</source>
          <target state="translated">&lt;code&gt;@@skip_replication&lt;/code&gt; 으로 인해 이벤트가 필터링되면 마스터 측에서 필터링이 수행됩니다. 다시 말해, 이벤트는 절대 슬레이브로 전송되지 않습니다. 이와 같이 많은 이벤트가 필터링되는 경우 슬레이브는 마스터로부터 이벤트를 수신하지 않고 오래 앉아있을 수 있습니다. 이것은 그 자체로는 문제가 아니지만 필터링 된 이벤트에 대해 슬레이브에 문의 할 때 명심해야합니다. 예를 들어 &lt;code&gt;START SLAVE UNTIL &amp;lt;some position&amp;gt;&lt;/code&gt; 는 첫 번째 이벤트가 &lt;strong&gt;아닌&lt;/strong&gt; 경우 중지됩니다.&lt;strong&gt;&lt;/strong&gt;주어진 위치 또는 그 이상에서 필터링됩니다. 지정된 위치의 이벤트가 필터링되면 다음 필터링되지 않은 이벤트가 발생할 때만 슬레이브 스레드가 중지됩니다. 실제로 이벤트가 필터링되면 슬레이브에 이벤트가 마스터의 binlog에 기록되지 않은 것으로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="45f6c38743bbd7ce911293b0ff0f75df14b82ffd" translate="yes" xml:space="preserve">
          <source>When events are replicated from a master server to a slave server, the events are always logged into the slave's binlog in the same order that they were read from the master's binlog. Thus, if there is only ever a single master server receiving (non-replication) updates at a time, then the binlog order will be identical on every server in the replication hierarchy.</source>
          <target state="translated">이벤트가 마스터 서버에서 슬레이브 서버로 복제 될 때 이벤트는 항상 마스터의 binlog에서 읽은 순서대로 슬레이브의 binlog에 기록됩니다. 따라서 한 번에 하나의 마스터 서버 (복제 아님) 업데이트 만 수신하는 경우 복제 계층의 모든 서버에서 binlog 순서가 동일합니다.</target>
        </trans-unit>
        <trans-unit id="a3b12c124b994e2e7921f3e7a0146d1de40f91f2" translate="yes" xml:space="preserve">
          <source>When events in the binlog are marked with the &lt;code&gt;@@skip_replication&lt;/code&gt; flag, the flag will be preserved if the events are dumped by the &lt;code&gt;&lt;a href=&quot;../mysqlbinlog/index&quot;&gt;mysqlbinlog&lt;/a&gt;&lt;/code&gt; program and re-applied against a server with the &lt;code&gt;&lt;a href=&quot;../mysql-command-line-client/index&quot;&gt;mysql client&lt;/a&gt;&lt;/code&gt; program. Similarly, the &lt;code&gt;&lt;a href=&quot;../binlog/index&quot;&gt;BINLOG&lt;/a&gt;&lt;/code&gt; statement will preserve the flag from the event being replayed. And a slave which runs with &lt;code&gt;--log-slave-updates&lt;/code&gt; and does not filter events (&lt;code&gt;--replicate-events-marked-for-skip=REPLICATE&lt;/code&gt;) will also preserve the flag in the events logged into the binlog on the slave.</source>
          <target state="translated">binlog의 이벤트에 &lt;code&gt;@@skip_replication&lt;/code&gt; 플래그 가 표시 되면 &lt;code&gt;&lt;a href=&quot;../mysqlbinlog/index&quot;&gt;mysqlbinlog&lt;/a&gt;&lt;/code&gt; 프로그램에 의해 이벤트가 덤프되고 &lt;code&gt;&lt;a href=&quot;../mysql-command-line-client/index&quot;&gt;mysql client&lt;/a&gt;&lt;/code&gt; 프로그램이 있는 서버에 다시 적용되는 경우 플래그가 유지됩니다 . 마찬가지로 &lt;code&gt;&lt;a href=&quot;../binlog/index&quot;&gt;BINLOG&lt;/a&gt;&lt;/code&gt; 문은 재생중인 이벤트에서 플래그를 유지합니다. &lt;code&gt;--log-slave-updates&lt;/code&gt; 로 실행되고 이벤트를 필터링하지 않는 슬레이브 ( &lt;code&gt;--replicate-events-marked-for-skip=REPLICATE&lt;/code&gt; )는 슬레이브의 binlog에 기록 된 이벤트의 플래그도 보존합니다.</target>
        </trans-unit>
        <trans-unit id="a424e8190c2b513ba31315c1ef30a6e38c8d81fe" translate="yes" xml:space="preserve">
          <source>When executing &lt;code&gt;mysqlbinlog&lt;/code&gt; with &lt;code&gt;--flashback&lt;/code&gt;, the Flashback events will be stored in memory. You should make sure your server has enough memory for this feature.</source>
          <target state="translated">&lt;code&gt;--flashback&lt;/code&gt; 과 함께 &lt;code&gt;mysqlbinlog&lt;/code&gt; 를 실행 하면 Flashback 이벤트가 메모리에 저장됩니다. 서버에이 기능을위한 충분한 메모리가 있는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="88bebd9303780860679cfa82a367f09c8c679549" translate="yes" xml:space="preserve">
          <source>When executing this select query, only sub-table xt3 will be used.</source>
          <target state="translated">이 선택 쿼리를 실행할 때 하위 테이블 xt3 만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="234aa8a7e828e70c0c415758e5546404bed7e4a9" translate="yes" xml:space="preserve">
          <source>When executing this statement, the &lt;em&gt;serv2.xml&lt;/em&gt; file will be zipped as /perso.zip&lt;em&gt;. The entry name must be specified as well as the column descriptions that cannot be retrieved from the zip entry file that does not exist yet.&lt;/em&gt;</source>
          <target state="translated">이 명령문을 실행할 때 &lt;em&gt;serv2.xml&lt;/em&gt; 파일은 &lt;em&gt;/perso.zip&lt;/em&gt; 으로 압축됩니다 &lt;em&gt;. 항목 이름과 아직 존재하지 않는 Zip 항목 파일에서 검색 할 수없는 열 설명을 지정해야합니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e836e4ef18d225d3157027e5758c0696adf6d736" translate="yes" xml:space="preserve">
          <source>When explain recording is on, slow query log entries look like this:</source>
          <target state="translated">Explain 기록이 설정되면 느린 쿼리 로그 항목은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ed152cfc5151cea3f6e6370e08d6122388f537cb" translate="yes" xml:space="preserve">
          <source>When finished, you will have an RPM package containing galera library, arbitrator and related files in the current directory. Note: The same set of instructions can be applied to other RPM based platforms to generate galera package.</source>
          <target state="translated">완료되면 현재 디렉토리에 galera 라이브러리, 중재자 및 관련 파일이 포함 된 RPM 패키지가 있습니다. 참고 : galera 패키지를 생성하기 위해 동일한 RPM 세트를 다른 RPM 기반 플랫폼에 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6348c43bad1581ba39cd4b150b1806b749ca39ae" translate="yes" xml:space="preserve">
          <source>When finished, you will have the Debian packages for galera library and arbitrator in the parent directory.</source>
          <target state="translated">완료되면 galera 라이브러리 및 중재자 용 데비안 패키지가 상위 디렉토리에있게됩니다.</target>
        </trans-unit>
        <trans-unit id="c966597e48cbd050b7afc4814bb3d74f767fb2f5" translate="yes" xml:space="preserve">
          <source>When grouping rows, grouping values are compared as if by the &lt;code&gt;&lt;a href=&quot;../equal/index&quot;&gt;=&lt;/a&gt;&lt;/code&gt; operator. For string values, the &lt;code&gt;=&lt;/code&gt; operator ignores trailing whitespace and may normalize characters and ignore case, depending on the &lt;a href=&quot;../data-types-character-sets-and-collations/index&quot;&gt;collation&lt;/a&gt; in use.</source>
          <target state="translated">행을 그룹화 할 때 그룹화 값은 &lt;code&gt;&lt;a href=&quot;../equal/index&quot;&gt;=&lt;/a&gt;&lt;/code&gt; 연산자에 의해 비교됩니다 . 문자열 값의 경우 &lt;code&gt;=&lt;/code&gt; 연산자는 후행 공백을 무시 하고 사용중인 &lt;a href=&quot;../data-types-character-sets-and-collations/index&quot;&gt;데이터 정렬&lt;/a&gt; 에 따라 문자를 정규화하고 대소 문자를 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c33cb302748e09a40cdf3db1c1a37f5b5f2af7a" translate="yes" xml:space="preserve">
          <source>When implicit type conversion takes place.</source>
          <target state="translated">암시 적 유형 변환이 발생할 때.</target>
        </trans-unit>
        <trans-unit id="99c999d088887e1f3825e1f04b1a113c79bdd703" translate="yes" xml:space="preserve">
          <source>When in a &lt;code&gt;CREATE TABLE&lt;/code&gt; statement, the &lt;code&gt;::create()&lt;/code&gt; handler method is called, the table attributes are available in the &lt;code&gt;table_arg-&amp;gt;s-&amp;gt;option_struct&lt;/code&gt;, field attributes - in the &lt;code&gt;option_struct&lt;/code&gt; member of the individual fields (objects of the &lt;code&gt;Field&lt;/code&gt; class), index attributes - in the &lt;code&gt;option_struct&lt;/code&gt; member of the individual keys (objects of the &lt;code&gt;KEY&lt;/code&gt; class).</source>
          <target state="translated">A는 경우에 &lt;code&gt;CREATE TABLE&lt;/code&gt; 문의 &lt;code&gt;::create()&lt;/code&gt; 핸들러 메소드가 호출 될 때, 테이블 속성에서 사용할 수있는 &lt;code&gt;table_arg-&amp;gt;s-&amp;gt;option_struct&lt;/code&gt; , 필드 속성 -에 &lt;code&gt;option_struct&lt;/code&gt; 의 개별 필드 (의 객체의 멤버 &lt;code&gt;Field&lt;/code&gt; 클래스 ), 색인 속성- 개별 키 ( &lt;code&gt;KEY&lt;/code&gt; 클래스의 객체)의 &lt;code&gt;option_struct&lt;/code&gt; 멤버에 있습니다.</target>
        </trans-unit>
        <trans-unit id="6bad385f8e4051b0d9cdceaa2b499653f7a0b5f8" translate="yes" xml:space="preserve">
          <source>When information is accessed that appears in the &lt;em&gt;old&lt;/em&gt; list, it is moved to the top the new list, and everything above moves back one position.</source>
          <target state="translated">&lt;em&gt;이전&lt;/em&gt; 목록에 나타나는 정보에 액세스 하면 새 목록의 맨 위로 이동하고 위의 모든 항목이 한 위치 뒤로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="c05a5d05286dcb8466cab963419a3b611e67b8de" translate="yes" xml:space="preserve">
          <source>When inserting a query inside the query cache or aborting a query cache insert (using the &lt;a href=&quot;../kill/index&quot;&gt;KILL&lt;/a&gt; command for example), a try_lock function waits until the query cache returns; no timeout is used in this case.</source>
          <target state="translated">쿼리 캐시 내에 쿼리를 삽입하거나 쿼리 캐시 삽입을 중단하면 ( 예 : &lt;a href=&quot;../kill/index&quot;&gt;KILL&lt;/a&gt; 명령 사용 ) try_lock 함수는 쿼리 캐시가 반환 될 때까지 기다립니다. 이 경우 시간 초과가 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="396199306c82f8938ef4bd9bde9b53f75748a5c8" translate="yes" xml:space="preserve">
          <source>When inserting big amounts of data, integrity checks are sensibly time-consuming. It is possible to disable the &lt;code&gt;UNIQUE&lt;/code&gt; indexes and the &lt;a href=&quot;../foreign-keys/index&quot;&gt;foreign keys&lt;/a&gt; checks using the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#unique_checks&quot;&gt;unique_checks&lt;/a&gt;&lt;/code&gt; and the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#foreign_key_checks&quot;&gt;foreign_key_checks&lt;/a&gt;&lt;/code&gt; system variables:</source>
          <target state="translated">많은 양의 데이터를 삽입 할 때 무결성 검사는 상당한 시간이 소요됩니다. &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#unique_checks&quot;&gt;unique_checks&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#foreign_key_checks&quot;&gt;foreign_key_checks&lt;/a&gt;&lt;/code&gt; 시스템 변수 를 사용하여 &lt;code&gt;UNIQUE&lt;/code&gt; 인덱스 및 &lt;a href=&quot;../foreign-keys/index&quot;&gt;외래 키&lt;/a&gt; 검사 를 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="acb3e447f198787232619e4a171e98f77c08fa88" translate="yes" xml:space="preserve">
          <source>When inserting new data into MariaDB, the things that take time are: (in order of importance):</source>
          <target state="translated">MariaDB에 새 데이터를 삽입 할 때 시간이 걸리는 작업은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="93c6df44adebd74e234d83a55128e444a0db4613" translate="yes" xml:space="preserve">
          <source>When inserting values to an ODBC table, local values are used and sent to the ODBC table. This does not make any difference when the values are constant but in a query such as:</source>
          <target state="translated">ODBC 테이블에 값을 삽입 할 때 로컬 값이 사용되어 ODBC 테이블로 전송됩니다. 값이 일정하지만 다음과 같은 쿼리에서는 차이가 없습니다.</target>
        </trans-unit>
        <trans-unit id="8ec9d29629a3c4e30ad28083f81d2fc7b32a944a" translate="yes" xml:space="preserve">
          <source>When invoked with the &lt;code&gt;INTERVAL&lt;/code&gt; form of the second argument, &lt;code&gt;ADDDATE()&lt;/code&gt; is a synonym for &lt;code&gt;&lt;a href=&quot;../date_add/index&quot;&gt;DATE_ADD()&lt;/a&gt;&lt;/code&gt;. The related function &lt;code&gt;&lt;a href=&quot;../subdate/index&quot;&gt;SUBDATE()&lt;/a&gt;&lt;/code&gt; is a synonym for &lt;code&gt;&lt;a href=&quot;../date_sub/index&quot;&gt;DATE_SUB()&lt;/a&gt;&lt;/code&gt;. For information on the &lt;code&gt;INTERVAL&lt;/code&gt; unit argument, see the discussion for &lt;code&gt;&lt;a href=&quot;../date_add/index&quot;&gt;DATE_ADD()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">호출되면 &lt;code&gt;INTERVAL&lt;/code&gt; 번째 인수의 형태 &lt;code&gt;ADDDATE()&lt;/code&gt; 동의어이다 &lt;code&gt;&lt;a href=&quot;../date_add/index&quot;&gt;DATE_ADD()&lt;/a&gt;&lt;/code&gt; . 관련 함수 &lt;code&gt;&lt;a href=&quot;../subdate/index&quot;&gt;SUBDATE()&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../date_sub/index&quot;&gt;DATE_SUB()&lt;/a&gt;&lt;/code&gt; 와 동의어입니다 . &lt;code&gt;INTERVAL&lt;/code&gt; 단위 인수 에 대한 정보 는 &lt;code&gt;&lt;a href=&quot;../date_add/index&quot;&gt;DATE_ADD()&lt;/a&gt;&lt;/code&gt; 대한 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ee3c3f3d871a27e21798dd599e57fb0572963743" translate="yes" xml:space="preserve">
          <source>When invoked with the &lt;code&gt;INTERVAL&lt;/code&gt; form of the second argument, &lt;code&gt;SUBDATE()&lt;/code&gt; is a synonym for &lt;code&gt;&lt;a href=&quot;../date_sub/index&quot;&gt;DATE_SUB()&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;../date-and-time-units/index&quot;&gt;Date and Time Units&lt;/a&gt; for a complete list of permitted units.</source>
          <target state="translated">두 번째 인수 의 &lt;code&gt;INTERVAL&lt;/code&gt; 형식으로 호출 될 때 &lt;code&gt;SUBDATE()&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../date_sub/index&quot;&gt;DATE_SUB()&lt;/a&gt;&lt;/code&gt; 의 동의어입니다 . 허용 된 단위의 전체 목록은 &lt;a href=&quot;../date-and-time-units/index&quot;&gt;날짜 및 시간 단위&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b086a218dbf96788ddcdf6f8a7b6a8818e391b75" translate="yes" xml:space="preserve">
          <source>When invoked with the days form of the second argument, MariaDB treats it as an integer number of days to be added to &lt;em&gt;expr&lt;/em&gt;.</source>
          <target state="translated">두 번째 인수의 days 형식으로 호출하면 MariaDB는이를 &lt;em&gt;expr에&lt;/em&gt; 추가 할 정수로 처리합니다 .</target>
        </trans-unit>
        <trans-unit id="feff3f94e0c051e169fd7b24b109591fbed68be3" translate="yes" xml:space="preserve">
          <source>When is Encryption No Help?</source>
          <target state="translated">언제 암호화가 도움이되지 않습니까?</target>
        </trans-unit>
        <trans-unit id="b3cbe387883c5488a2df47236016e123cae2d73d" translate="yes" xml:space="preserve">
          <source>When is it safe to remove old log files?</source>
          <target state="translated">오래된 로그 파일을 언제 제거해도 안전합니까?</target>
        </trans-unit>
        <trans-unit id="ebc31f5928ee0f32671dbf118d294bb50b2022a5" translate="yes" xml:space="preserve">
          <source>When it is useful, the QC is blazingly fast. It would not be hard to create a benchmark that runs 1000x faster.</source>
          <target state="translated">유용 할 때, QC는 엄청나게 빠릅니다. 1000 배 빠르게 실행되는 벤치 마크를 만드는 것은 어렵지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f541721ec0a83d76fa34ce7b7a2b6a12fc89783b" translate="yes" xml:space="preserve">
          <source>When it replaces the original table with the rebuilt table, it may also have to rename the original table using a temporary table name.</source>
          <target state="translated">원래 테이블을 재 빌드 된 테이블로 바꾸면 임시 테이블 이름을 사용하여 원래 테이블의 이름을 바꿔야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a6e1b6eec10e751ef41bf1ceda421a64ab340d4" translate="yes" xml:space="preserve">
          <source>When loading data or inserting rows, Shard-Query examines the data being inserted and sends the row to the appropriate shard. The loader is massively parallel and will load delimited files in chunks in parallel.</source>
          <target state="translated">데이터를로드하거나 행을 삽입 할 때 Shard-Query는 삽입중인 데이터를 검사하여 행을 해당 샤드로 보냅니다. 로더는 대규모 병렬이며 구분 된 파일을 청크로 병렬로로드합니다.</target>
        </trans-unit>
        <trans-unit id="6f3049631bf4a16819cd209adf0b4d4afedd351c" translate="yes" xml:space="preserve">
          <source>When looking up a name in the cache, first check if the global counter is larger than the local copy. If so, clear the cache and return &quot;not found&quot;, and update the local counter; otherwise, lookup as usual.</source>
          <target state="translated">캐시에서 이름을 찾을 때 먼저 글로벌 카운터가 로컬 복사본보다 큰지 확인하십시오. 그렇다면 캐시를 지우고 &quot;찾을 수 없음&quot;을 반환하고 로컬 카운터를 업데이트하십시오. 그렇지 않으면 평소와 같이 조회하십시오.</target>
        </trans-unit>
        <trans-unit id="d74d7a7ac045b374afc5b53dc5404e315e3dc54a" translate="yes" xml:space="preserve">
          <source>When manual heuristic recovery is initiated, MariaDB will ignore information about transactions in the transaction coordinator log during the recovery process. Prepared transactions that are encountered during the recovery process will either be rolled back or committed, depending on the value of &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-tc-heuristic-recover&quot;&gt;--tc-heuristic-recover&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">수동 휴리스틱 복구가 시작되면 MariaDB는 복구 프로세스 중에 트랜잭션 코디네이터 로그의 트랜잭션에 대한 정보를 무시합니다. 복구 프로세스 중 발생하는 준비된 트랜잭션은 &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-tc-heuristic-recover&quot;&gt;--tc-heuristic-recover&lt;/a&gt;&lt;/code&gt; 값에 따라 롤백되거나 커밋 됩니다.</target>
        </trans-unit>
        <trans-unit id="f6544505271e269a7557d409a6077e09eea9e4dc" translate="yes" xml:space="preserve">
          <source>When manual heuristic recovery is initiated, the &lt;a href=&quot;../error-log/index&quot;&gt;error log&lt;/a&gt; will contain a message like this:</source>
          <target state="translated">수동 휴리스틱 복구가 시작되면 &lt;a href=&quot;../error-log/index&quot;&gt;오류 로그에&lt;/a&gt; 다음과 같은 메시지가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="87519d8d013b3f63122681e5304287bb5102fa17" translate="yes" xml:space="preserve">
          <source>When marked with a &amp;lsquo;$&amp;rsquo; the file can be the result returned by a REST query.</source>
          <target state="translated">'$'로 표시되면 파일은 REST 조회에 의해 리턴 된 결과 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59bfeb1ec98d3a6b2e3a3fcea01fd65e66e9e979" translate="yes" xml:space="preserve">
          <source>When mixed logging is enabled, the server uses a combination of statement-based logging and row-based logging. Statement-based logging is used by default, but when the server determines a statement may not be safe for statement-based logging, it will use row-based logging instead. See &lt;a href=&quot;../unsafe-statements-for-statement-based-replication/index#unsafe-statements&quot;&gt;Unsafe Statements for Statement-based Replication: Unsafe Statements&lt;/a&gt; for a list of unsafe statements.</source>
          <target state="translated">혼합 로깅이 활성화되면 서버는 명령문 기반 로깅과 행 기반 로깅의 조합을 사용합니다. 명령문 기반 로깅이 기본적으로 사용되지만 서버가 명령문이 명령문 기반 로깅에 안전하지 않을 수 있다고 판별하면 대신 행 기반 로깅을 사용합니다. &lt;a href=&quot;../unsafe-statements-for-statement-based-replication/index#unsafe-statements&quot;&gt;안전하지 않은 명령문&lt;/a&gt; 목록은 명령문 기반 복제에 대한 안전하지 않은 명령문 : 안전하지 않은 명령문을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8fc2b718faafb846ea1b48749130b980ff52045d" translate="yes" xml:space="preserve">
          <source>When needed, it is possible to specify the keys by giving an alias to the arguments:</source>
          <target state="translated">필요한 경우 인수에 별명을 지정하여 키를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58a6dbc83ccba991bd177a16c4df338022e0cac8" translate="yes" xml:space="preserve">
          <source>When new PM nodes are added to a running instance it may be desirable to redistribute the data in current nodes across all of the nodes. This is not strictly required as ongoing data ingestion will prioritize the new empty nodes for data loading to rebalance the system.</source>
          <target state="translated">새 PM 노드가 실행중인 인스턴스에 추가 될 때 모든 노드에 걸쳐 현재 노드의 데이터를 재분배하는 것이 바람직 할 수 있습니다. 데이터를 지속적으로 수집하면 시스템을 재조정하기 위해 데이터로드를 위해 비어있는 새 노드의 우선 순위가 결정되므로 반드시 필요한 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="1b4a72e3eff178ab778df63f89250c2232a00a1e" translate="yes" xml:space="preserve">
          <source>When new information is accessed that doesn't appear in the list, it is placed at the top of the old list, the oldest item in the old list is removed, and everything else bumps back one position in the list.</source>
          <target state="translated">목록에 표시되지 않은 새 정보에 액세스하면 이전 목록의 맨 위에 배치되고 이전 목록에서 가장 오래된 항목이 제거되고 그 밖의 모든 정보가 목록의 한 위치로 충돌합니다.</target>
        </trans-unit>
        <trans-unit id="4f558caacb469bf38cbfeb90f3297811a6c0ad41" translate="yes" xml:space="preserve">
          <source>When no match if found for a column field the process aborts with a message such as:</source>
          <target state="translated">열 필드에 대해 일치하는 것이 없으면 프로세스는 다음과 같은 메시지와 함께 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="554e0e56511ff20e3c41f18682da877bc16e02af" translate="yes" xml:space="preserve">
          <source>When one creates a sequence, either with &lt;a href=&quot;../create-table/index&quot;&gt;CREATE TABLE&lt;/a&gt; or &lt;a href=&quot;../create-sequence/index&quot;&gt;CREATE SEQUENCE&lt;/a&gt;, one row will be inserted.</source>
          <target state="translated">&lt;a href=&quot;../create-table/index&quot;&gt;CREATE TABLE&lt;/a&gt; 또는 &lt;a href=&quot;../create-sequence/index&quot;&gt;CREATE SEQUENCE를&lt;/a&gt; 사용하여 시퀀스를 만들면 하나의 행이 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="64ea0ed2e2a68e074d7f40e37b79c7d40c4438fe" translate="yes" xml:space="preserve">
          <source>When one of these special options is provided, the server only kills its binary log dump threads after all client threads have been killed, and it only completes the shutdown after the last &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt; has been sent to all connected slaves.</source>
          <target state="translated">이러한 특수 옵션 중 하나가 제공되면 서버는 모든 클라이언트 스레드가 종료 된 후에 만 ​​이진 로그 덤프 스레드를 종료하고 마지막 &lt;a href=&quot;../binary-log/index&quot;&gt;이진 로그&lt;/a&gt; 가 연결된 모든 슬레이브로 전송 된 후에 만 종료를 완료합니다 .</target>
        </trans-unit>
        <trans-unit id="17867dedcc00b616857d0ef23962e2b36e9a232c" translate="yes" xml:space="preserve">
          <source>When one uses row-based replication, the binary log contains row changes. It will have both the changes made by the statement itself, and the changes made by the triggers that were invoked by the statement. Slave server(s) do not need to run triggers for row changes they are applying.</source>
          <target state="translated">행 기반 복제를 사용하면 이진 로그에 행 변경 사항이 포함됩니다. 명령문 자체에 의해 작성된 변경 사항과 명령문에 의해 호출 된 트리거에 의해 작성된 변경 사항이 모두 있습니다. 슬레이브 서버는 적용중인 행 변경에 대해 트리거를 실행할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="43cc4fb62b8864fffbf9082a82a4c76836e195b0" translate="yes" xml:space="preserve">
          <source>When one uses statement-based replication, the binary log contains SQL statements. Slave server(s) execute the SQL statements. Triggers are run on the master and on each slave, independently.</source>
          <target state="translated">명령문 기반 복제를 사용하면 이진 로그에 SQL 문이 포함됩니다. 슬레이브 서버는 SQL 문을 실행합니다. 트리거는 마스터와 각 슬레이브에서 독립적으로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="6cf97d12fda35e38c9096aeef9280af40cd29cb4" translate="yes" xml:space="preserve">
          <source>When one uses transaction-precise history, one can optionally use transaction identifiers in the &lt;code&gt;FOR SYSTEM_TIME&lt;/code&gt; clause:</source>
          <target state="translated">트랜잭션 정확한 히스토리를 사용하는 경우 &lt;code&gt;FOR SYSTEM_TIME&lt;/code&gt; 절 에서 트랜잭션 ID를 선택적으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="35fcaa8245b86d33c5d4283147ac0aef8b5e2636" translate="yes" xml:space="preserve">
          <source>When opening an InnoDB table, there is a check if the tablespace for the table is &lt;a href=&quot;index#devices-that-support-atomic-writes-with-mariadb&quot;&gt;on a device that supports atomic writes&lt;/a&gt; and if yes, it will automatically enable atomic writes for the table. If atomic writes support is not detected, the doublewrite buffer will be used.</source>
          <target state="translated">InnoDB 테이블을 열 때 테이블의 테이블 공간이 &lt;a href=&quot;index#devices-that-support-atomic-writes-with-mariadb&quot;&gt;원자 쓰기를 지원하는 장치에&lt;/a&gt; 있는지 확인하고, 그렇다면 테이블에 대한 원자 쓰기를 자동으로 활성화합니다. 원자 쓰기 지원이 감지되지 않으면 이중 쓰기 버퍼가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="251933502d213000cfdbd37f7523c763110b980a" translate="yes" xml:space="preserve">
          <source>When parallel replication is used, the &lt;a href=&quot;../replication-threads/index#slave-sql-thread&quot;&gt;SQL thread&lt;/a&gt; will read ahead in the relay logs, queueing events in memory while looking for opportunities for executing events in parallel. The &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#slave_parallel_max_queued&quot;&gt;slave_parallel_max_queued&lt;/a&gt;&lt;/code&gt; system variable sets a limit for how much memory it will use for this.</source>
          <target state="translated">병렬 복제가 사용되면 &lt;a href=&quot;../replication-threads/index#slave-sql-thread&quot;&gt;SQL 스레드&lt;/a&gt; 는 릴레이 로그에서 미리 읽은 다음 이벤트를 병렬로 실행할 기회를 찾는 동안 메모리의 이벤트를 큐에 넣습니다. &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#slave_parallel_max_queued&quot;&gt;slave_parallel_max_queued&lt;/a&gt;&lt;/code&gt; 시스템 변수는이에 사용할 메모리의 양에 대한 제한을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="8c427b519177b0bb6318f9bac56dcaf0f442e2c1" translate="yes" xml:space="preserve">
          <source>When parsed locally, you will have errors if no &lt;em&gt;t1&lt;/em&gt; table exists or if it does not have the referenced columns. When &lt;em&gt;t1&lt;/em&gt; does not exist, you can overcome this issue by creating a local dummy &lt;em&gt;t1&lt;/em&gt; table:</source>
          <target state="translated">로컬로 구문 분석 할 때 &lt;em&gt;t1&lt;/em&gt; 테이블이 없거나 참조 된 열이없는 경우 오류가 발생합니다 . 때 &lt;em&gt;T1이&lt;/em&gt; 존재하지 않는, 로컬 더미 만들어이 문제를 극복 할 수 &lt;em&gt;T1을&lt;/em&gt; 테이블을 :</target>
        </trans-unit>
        <trans-unit id="c0323d29649845036fb5ed023bde8c05d26ea6b3" translate="yes" xml:space="preserve">
          <source>When parsing a &lt;a href=&quot;../create-procedure/index&quot;&gt;CREATE PROCEDURE&lt;/a&gt; the parser first initializes the &lt;code&gt;sphead&lt;/code&gt; and &lt;code&gt;spcont&lt;/code&gt; (runtime context) fields in the Lex. The sql_command code for the result of parsing a is &lt;code&gt;SQLCOM_CREATE_PROCEDURE&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../create-procedure/index&quot;&gt;CREATE PROCEDURE를&lt;/a&gt; 구문 분석 할 때 구문 분석기는 먼저 Lex에서 &lt;code&gt;sphead&lt;/code&gt; 및 &lt;code&gt;spcont&lt;/code&gt; (런타임 컨텍스트) 필드를 초기화합니다 . a 구문 분석 결과의 sql_command 코드는 &lt;code&gt;SQLCOM_CREATE_PROCEDURE&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c9f60368248789d07ddc46674b696a54d83bc50a" translate="yes" xml:space="preserve">
          <source>When partitioning a table, the use should decide:</source>
          <target state="translated">테이블을 분할 할 때 다음을 결정해야합니다.</target>
        </trans-unit>
        <trans-unit id="c06cfeeb0c7d73b960d640ea2edb92ed6c2c2f75" translate="yes" xml:space="preserve">
          <source>When password is not set in the my.cnf, this error will be reported:</source>
          <target state="translated">my.cnf에 비밀번호가 설정되어 있지 않으면이 오류가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="89e76936992547a88ad0d037003a576ec113f264" translate="yes" xml:space="preserve">
          <source>When possible, this is the preferred means of access because it does not require all the Java path settings etc. and is faster than using the Java driver.</source>
          <target state="translated">가능하면 모든 Java 경로 설정 등이 필요하지 않고 Java 드라이버를 사용하는 것보다 빠르기 때문에 선호되는 액세스 방법입니다.</target>
        </trans-unit>
        <trans-unit id="2171be7e6b2d93b36bcf52680a5ef9c791df0117" translate="yes" xml:space="preserve">
          <source>When reading, this is not required as the type of the array items is specified for the columns; however, it is required when inserting new rows so CONNECT knows what to insert. For instance:</source>
          <target state="translated">읽을 때 배열 항목의 유형이 열에 지정되어 있으므로 필요하지 않습니다. 그러나 새 행을 삽입 할 때 CONNECT가 삽입 할 내용을 알고 있어야합니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="21d2b233390813f2c226ea23255b6c1e62e98644" translate="yes" xml:space="preserve">
          <source>When ready run one of the following depending on the MySQL version which you want to build with:</source>
          <target state="translated">준비가되면 빌드하려는 MySQL 버전에 따라 다음 중 하나를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="474b2814661ce20e6e3dccf0e14bda5290ff0e51" translate="yes" xml:space="preserve">
          <source>When referring to the default value exactly in &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;INSERT&lt;/code&gt;, you can omit the argument:</source>
          <target state="translated">&lt;code&gt;UPDATE&lt;/code&gt; 또는 &lt;code&gt;INSERT&lt;/code&gt; 에서 기본값을 정확하게 참조 하면 인수를 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="257a88221b323c55d6070d4bfa86dda0c18af5a6" translate="yes" xml:space="preserve">
          <source>When reorganizing a set of partitions they must be in consecutive order</source>
          <target state="translated">파티션 세트를 재구성 할 때 순서가 연속적이어야합니다</target>
        </trans-unit>
        <trans-unit id="6a0dd4f8072e1d504387267033e3bc74845aa71e" translate="yes" xml:space="preserve">
          <source>When repairing, space for twice the size of the data file, available in the same directory as the original file. This is for the original file as well as a copy. This space is not required if the &lt;em&gt;--quick&lt;/em&gt; option is used, in which case only the index file is re-created.</source>
          <target state="translated">복구 할 때 원본 파일과 동일한 디렉토리에서 사용 가능한 데이터 파일 크기의 두 배 공간. 원본 파일 및 사본 용입니다. &lt;em&gt;--quick&lt;/em&gt; 옵션을 사용 하는 경우이 공간이 필요하지 않으며 ,이 경우 인덱스 파일 만 다시 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="b3a8b8ece8a548d7a44705400f9eb09442b5aeb2" translate="yes" xml:space="preserve">
          <source>When restoring the dump, the server will, if logging is turned on, log the queries to the general and &lt;a href=&quot;../slow-query-log/index&quot;&gt;slow query log&lt;/a&gt;. Defaults to on; use --skip-log-queries to disable. Added in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1011-release-notes/&quot;&gt;MariaDB 10.1.1&lt;/a&gt;.</source>
          <target state="translated">덤프를 복원 할 때 서버는 로깅이 설정된 경우 일반 및 &lt;a href=&quot;../slow-query-log/index&quot;&gt;느린 쿼리 로그에 쿼리를 로깅&lt;/a&gt; 합니다. 기본값은 on입니다. 비활성화하려면 --skip-log-queries를 사용하십시오. &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1011-release-notes/&quot;&gt;MariaDB 10.1.1&lt;/a&gt; 에서 추가됨 .</target>
        </trans-unit>
        <trans-unit id="fbfbf96203868654babc733873b63b59932c0f70" translate="yes" xml:space="preserve">
          <source>When row-based logging is enabled, DML statements are &lt;strong&gt;not&lt;/strong&gt; logged to the &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt;. Instead, each insert, update, or delete performed by the statement for each row is logged to the &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt; separately. DDL statements are still logged to the &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt;.</source>
          <target state="translated">행 기반 로깅을 사용하면 DML 문이 &lt;a href=&quot;../binary-log/index&quot;&gt;이진 로그에&lt;/a&gt; 기록 &lt;strong&gt;되지 않습니다&lt;/strong&gt; . 대신, 각 행에 대한 명령문으로 수행 된 각 삽입, 업데이트 또는 삭제는 &lt;a href=&quot;../binary-log/index&quot;&gt;이진 로그에&lt;/a&gt; 별도로 기록 됩니다. DDL 문은 여전히 &lt;a href=&quot;../binary-log/index&quot;&gt;이진 로그에 기록&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="535d88e4db35abb61fa08c23f4bc48d4cfd2b689" translate="yes" xml:space="preserve">
          <source>When row-based replication is used with &lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt; or &lt;a href=&quot;../delete/index&quot;&gt;DELETE&lt;/a&gt;, the slave needs to locate each replicated row based on the value in columns. If the table contains at least one index, an index lookup will be used (otherwise a table scan is needed for each row, which is extremely inefficient for all but the smallest table and generally to be avoided).</source>
          <target state="translated">행 기반 복제가 &lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt; 또는 &lt;a href=&quot;../delete/index&quot;&gt;DELETE&lt;/a&gt; 와 함께 사용되는 경우 경우 슬레이브는 열 값을 기준으로 각 복제 된 행을 찾아야합니다. 테이블에 하나 이상의 인덱스가 포함 된 경우 인덱스 조회가 사용됩니다 (그렇지 않으면 각 행에 대해 테이블 ​​스캔이 필요합니다. 이는 테이블을 제외한 모든 테이블에 대해 매우 비효율적이며 일반적으로 피해야합니다).</target>
        </trans-unit>
        <trans-unit id="9b33ba700483ad2d6712041885b6992765c80110" translate="yes" xml:space="preserve">
          <source>When rows are added or deleted to an InnoDB &lt;a href=&quot;../full-text-indexes/index&quot;&gt;fulltext index&lt;/a&gt;, the index is not immediately re-organized, as this can be an expensive operation. Change statistics are stored in a separate location . The fulltext index is only fully re-organized when an &lt;code&gt;OPTIMIZE TABLE&lt;/code&gt; statement is run.</source>
          <target state="translated">InnoDB &lt;a href=&quot;../full-text-indexes/index&quot;&gt;fulltext index에&lt;/a&gt; 행을 추가하거나 삭제 하면 값 비싼 작업이므로 인덱스가 즉시 재구성되지 않습니다. 변경 통계는 별도의 위치에 저장됩니다. 전체 텍스트 인덱스는 &lt;code&gt;OPTIMIZE TABLE&lt;/code&gt; 문이 실행될 때만 완전히 재구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="7b95a45a6f491da029403ff9f0753f9f7ebd3d3d" translate="yes" xml:space="preserve">
          <source>When rows are deleted from an &lt;a href=&quot;../innodb/index&quot;&gt;InnoDB&lt;/a&gt; table, the rows are simply marked as deleted and not physically deleted. The free space is not returned to the operating system for re-use.</source>
          <target state="translated">&lt;a href=&quot;../innodb/index&quot;&gt;InnoDB&lt;/a&gt; 테이블 에서 행을 삭제하면 행은 삭제 된 것으로 표시되고 실제로 삭제되지는 않습니다. 사용 가능한 공간은 재사용을 위해 운영 체제로 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="59f6218be40b3d3529e47b71467c3ddc64b051ce" translate="yes" xml:space="preserve">
          <source>When rows are deleted, space is not automatically freed. The only way to free space without dropping the table is using &lt;code&gt;ALTER TABLE tbl_name ENGINE = MEMORY&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;../truncate-table/index&quot;&gt;TRUNCATE TABLE&lt;/a&gt;&lt;/code&gt; frees the memory too.</source>
          <target state="translated">행이 삭제되면 공간이 자동으로 해제되지 않습니다. 테이블을 삭제하지 않고 공간을 확보하는 유일한 방법은 &lt;code&gt;ALTER TABLE tbl_name ENGINE = MEMORY&lt;/code&gt; 입니다. &lt;code&gt;&lt;a href=&quot;../truncate-table/index&quot;&gt;TRUNCATE TABLE&lt;/a&gt;&lt;/code&gt; 은 메모리도 해제합니다.</target>
        </trans-unit>
        <trans-unit id="c39e6c4f38a56395d59c0690a7927ecd9a77ef20" translate="yes" xml:space="preserve">
          <source>When running &lt;a href=&quot;../analyze-table/index&quot;&gt;ANALYZE TABLE&lt;/a&gt; twice on a table in which statements or transactions are running, MariaDB blocks the second &lt;a href=&quot;../analyze-table/index&quot;&gt;ANALYZE TABLE&lt;/a&gt; until the statement or transaction is complete. This occurs because the statement or transaction blocks the second &lt;a href=&quot;../analyze-table/index&quot;&gt;ANALYZE TABLE&lt;/a&gt; statement from reloading the table definition, which it must do since the old one was marked as obsolete after the first statement.</source>
          <target state="translated">명령문 또는 트랜잭션이 실행중인 테이블에서 &lt;a href=&quot;../analyze-table/index&quot;&gt;ANALYZE TABLE을&lt;/a&gt; 두 번 실행할 때 MariaDB 는 명령문 또는 트랜잭션이 완료 될 때까지 두 번째 &lt;a href=&quot;../analyze-table/index&quot;&gt;ANALYZE TABLE을&lt;/a&gt; 차단합니다 . 이는 명령문 또는 트랜잭션이 두 번째 &lt;a href=&quot;../analyze-table/index&quot;&gt;ANALYZE TABLE&lt;/a&gt; 문이 테이블 정의를 다시로드하지 못하도록 차단 하므로 이전 명령문이 첫 번째 명령문 이후에 더 이상 사용되지 않는 것으로 표시된 이후에 수행되어야합니다.</target>
        </trans-unit>
        <trans-unit id="0d090f36255e6d55d3cfffdd0ad64e21b1aab934" translate="yes" xml:space="preserve">
          <source>When running &lt;a href=&quot;../sql_modeoracle-from-mariadb-103/index#functions&quot;&gt;Oracle mode from MariaDB 10.3&lt;/a&gt;, &lt;code&gt;LENGTH()&lt;/code&gt; is a synonym for &lt;code&gt;&lt;a href=&quot;../char_length/index&quot;&gt;CHAR_LENGTH()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">실행하는 경우 &lt;a href=&quot;../sql_modeoracle-from-mariadb-103/index#functions&quot;&gt;MariaDB 10.3에서 오라클 모드&lt;/a&gt; , &lt;code&gt;LENGTH()&lt;/code&gt; 동의어입니다 &lt;code&gt;&lt;a href=&quot;../char_length/index&quot;&gt;CHAR_LENGTH()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4b109c4dee69e3f9969887297432f19ac2a58281" translate="yes" xml:space="preserve">
          <source>When running &lt;code&gt;mysqlcheck&lt;/code&gt; with &lt;code&gt;--auto-repair&lt;/code&gt; (as done by &lt;a href=&quot;../upgrading-to-mariadb-from-mysql/index&quot;&gt;mysql_upgrade&lt;/a&gt;), &lt;code&gt;mysqlcheck&lt;/code&gt; will first check all tables and then in a separate phase repair those that failed the check.</source>
          <target state="translated">실행할 때 &lt;code&gt;mysqlcheck&lt;/code&gt; 의 와 &lt;code&gt;--auto-repair&lt;/code&gt; (수행으로 &lt;a href=&quot;../upgrading-to-mariadb-from-mysql/index&quot;&gt;으로 mysql_fix_privilege_tables&lt;/a&gt; ), &lt;code&gt;mysqlcheck&lt;/code&gt; 의는 먼저 별도의 위상 수리 후 확인에 실패하는 사람들을 모든 테이블을 확인하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="c757ed3640cc3df77d8e3a953de1c44a587cac2a" translate="yes" xml:space="preserve">
          <source>When running MariaDB in a server environment it is almost always desirable to have MariaDB start automatically when the server is powered on, for it to stay running while the server is running, and for it to be shutdown gracefully when the server is shut down.</source>
          <target state="translated">서버 환경에서 MariaDB를 실행할 때는 서버 전원을 켤 때 서버가 자동으로 시작되고 서버가 실행되는 동안 계속 실행되고 서버가 종료 될 때 서버가 정상적으로 종료되도록하는 것이 거의 항상 바람직합니다.</target>
        </trans-unit>
        <trans-unit id="7f883bad95d156c0fb180a7363c590ab00666b72" translate="yes" xml:space="preserve">
          <source>When running MariaDB on Windows, InnoDB stores databases and tables in lowercase. When moving databases and tables in a binary format from Windows to a Unix-like system or from a Unix system to Windows, you need to rename these to use lowercase.</source>
          <target state="translated">Windows에서 MariaDB를 실행할 때 InnoDB는 데이터베이스와 테이블을 소문자로 저장합니다. 데이터베이스와 테이블을 이진 형식으로 Windows에서 Unix와 유사한 시스템으로 또는 Unix 시스템에서 Windows로 이동할 때는 소문자를 사용하도록 이름을 바꿔야합니다.</target>
        </trans-unit>
        <trans-unit id="f1913982a02ade635ac82325ba34ca5895e2b962" translate="yes" xml:space="preserve">
          <source>When running Mariabackup on a server that uses replication, you may occasionally encounter locks that block backups. Using this option, it stops slave SQL threads and waits until the &lt;code&gt;Slave_open_temp_tables&lt;/code&gt; in the &lt;code&gt;SHOW STATUS&lt;/code&gt; statement is zero. If there are no open temporary tables, the backup runs, otherwise the SQL thread starts and stops until there are no open temporary tables.</source>
          <target state="translated">복제를 사용하는 서버에서 Mariabackup을 실행할 때 때때로 백업을 차단하는 잠금이 발생할 수 있습니다. 이 옵션을 사용하면 슬레이브 SQL 스레드를 중지 하고 &lt;code&gt;SHOW STATUS&lt;/code&gt; 문의 &lt;code&gt;Slave_open_temp_tables&lt;/code&gt; 가 0이 될 때까지 기다립니다 . 열린 임시 테이블이 없으면 백업이 실행되고 그렇지 않으면 열린 임시 테이블이 없을 때까지 SQL 스레드가 시작 및 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="b6d9c4afc8fb7194b8ea9d983670a48879cab20f" translate="yes" xml:space="preserve">
          <source>When running Mariabackup on a server that uses replication, you may occasionally encounter locks that block backups. With the &lt;code&gt;&lt;a href=&quot;#-safe-slave-backup&quot;&gt;--safe-slave-backup&lt;/a&gt;&lt;/code&gt; option, it waits until the &lt;code&gt;Slave_open_temp_tables&lt;/code&gt; in the &lt;code&gt;SHOW STATUS&lt;/code&gt; statement reaches zero. Using this option, you set how long it waits. It defaults to 300.</source>
          <target state="translated">복제를 사용하는 서버에서 Mariabackup을 실행할 때 때때로 백업을 차단하는 잠금이 발생할 수 있습니다. 으로 &lt;code&gt;&lt;a href=&quot;#-safe-slave-backup&quot;&gt;--safe-slave-backup&lt;/a&gt;&lt;/code&gt; 옵션, 그것은 때까지 대기 &lt;code&gt;Slave_open_temp_tables&lt;/code&gt; 에서 &lt;code&gt;SHOW STATUS&lt;/code&gt; 문 0에 도달. 이 옵션을 사용하여 대기 시간을 설정합니다. 기본값은 300입니다.</target>
        </trans-unit>
        <trans-unit id="63cda66c9bc4c68652c64f01a0edb5fcad280b21" translate="yes" xml:space="preserve">
          <source>When running a cluster or a replication setup via Docker, we will want the containers to use different ports. The fastest way to achieve this is mapping the containers ports to different port on our system. We can do this when creating the containers (&lt;code&gt;docker run&lt;/code&gt; command), by using the &lt;code&gt;-p&lt;/code&gt; option, several times if necessary. For example, for Galera nodes we will use a mapping similar to this one:</source>
          <target state="translated">Docker를 통해 클러스터 또는 복제 설정을 실행할 때 컨테이너가 다른 포트를 사용하기를 원할 것입니다. 이를 달성하는 가장 빠른 방법은 컨테이너 포트를 시스템의 다른 포트에 매핑하는 것입니다. 필요한 경우 &lt;code&gt;-p&lt;/code&gt; 옵션 을 사용하여 컨테이너를 만들 때 ( &lt;code&gt;docker run&lt;/code&gt; 명령) 이를 수행 할 수 있습니다 . 예를 들어 Galera 노드의 경우 다음과 유사한 매핑을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="efddb12d17b6b6c8615af4b7ed730b2a1cf83ea6" translate="yes" xml:space="preserve">
          <source>When running an &lt;code&gt;ALTER TABLE&amp;hellip;ALGORITHM=INPLACE&lt;/code&gt; that rebuilds the table, InnoDB will create an internal &lt;code&gt;#sql-ib&lt;/code&gt; table. For these tables, the &lt;code&gt;.frm&lt;/code&gt; file will be called something else. In order to drop such a table after a server crash, you must rename the &lt;code&gt;#sql*.frm&lt;/code&gt; file to match the &lt;code&gt;#sql-ib*.ibd&lt;/code&gt; file.</source>
          <target state="translated">테이블을 다시 작성 하는 &lt;code&gt;ALTER TABLE&amp;hellip;ALGORITHM=INPLACE&lt;/code&gt; 를 실행할 때 InnoDB는 내부 &lt;code&gt;#sql-ib&lt;/code&gt; 테이블을 만듭니다. 이러한 테이블의 경우 &lt;code&gt;.frm&lt;/code&gt; 파일을 다른 파일이라고합니다. 서버 충돌 후 이러한 테이블을 삭제 하려면 &lt;code&gt;#sql-ib*.ibd&lt;/code&gt; 파일 과 일치하도록 # sql &lt;code&gt;#sql*.frm&lt;/code&gt; 파일의 이름을 바꿔야 합니다.</target>
        </trans-unit>
        <trans-unit id="6d64d6926fa30ee1dbd37cab8d26526627e8c56b" translate="yes" xml:space="preserve">
          <source>When running postConfigure, you will be prompted for the type of storage configuration. Usually the options are 'internal' and 'external'. If GlusterFS is installed, then 'DataRedundancy' will be an option.</source>
          <target state="translated">postConfigure를 실행하면 스토리지 구성 유형을 묻는 메시지가 표시됩니다. 일반적으로 옵션은 '내부'및 '외부'입니다. GlusterFS가 설치되어 있으면 'DataRedundancy'가 옵션이됩니다.</target>
        </trans-unit>
        <trans-unit id="c0991b6e5fba3c14d8504eaeb8e18cb53339a391" translate="yes" xml:space="preserve">
          <source>When running sysbench and maybe other benchmarks, that create many threads on the same machine as the server, it is advisable to run benchmark driver and server on different CPUs to get the realistic results. Running lots of driver threads and only several server threads on the same CPUs will have the effect that OS scheduler will schedule benchmark driver threads to run with much higher probability than the server threads, that is driver will pre-empt the server. Use &quot;taskset &amp;ndash;c&quot; on Linuxes, and &quot;set /affinity&quot; on Windows to separate benchmark driver and server CPUs, as the preferred method to fix this situation.</source>
          <target state="translated">서버와 동일한 시스템에서 많은 스레드를 생성하는 sysbench 및 기타 벤치 마크를 실행할 때 실제 결과를 얻기 위해 다른 CPU에서 벤치 마크 드라이버와 서버를 실행하는 것이 좋습니다. 동일한 CPU에서 많은 드라이버 스레드와 몇 개의 서버 스레드 만 실행하면 OS 스케줄러가 벤치 마크 드라이버 스레드가 서버 스레드보다 훨씬 높은 확률로 실행되도록 예약합니다. 즉, 드라이버가 서버를 선점합니다. Linux에서는 &quot;taskset &amp;ndash;c&quot;를 사용하고 Windows에서는 &quot;set / affinity&quot;를 사용하여이 상황을 해결하는 기본 방법으로 벤치 마크 드라이버와 서버 CPU를 분리하십시오.</target>
        </trans-unit>
        <trans-unit id="0b1f9a93f1ae2f3a71fbdc40f3eb6c443db74690" translate="yes" xml:space="preserve">
          <source>When running sysbench, a good rule of thumb could be to give 1/4 of all CPUs to the sysbench, and 3/4 of CPUs to mysqld. It is also good idea to run sysbench and mysqld on different NUMA nodes, if possible.</source>
          <target state="translated">sysbench를 실행할 때 가장 좋은 방법은 모든 CPU의 1/4을 sysbench에, 3/4의 CPU를 mysqld에 제공하는 것입니다. 가능하면 다른 NUMA 노드에서 sysbench 및 mysqld를 실행하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="be46eee1d17594801c3cdcefffe54627d52fa956" translate="yes" xml:space="preserve">
          <source>When running the MariaDB test suite with the &lt;code&gt;--debug-dbug&lt;/code&gt; command line option, the Debug Sync Facility writes trace messages to the DBUG trace. The following shell commands proved very useful in extracting relevant information:</source>
          <target state="translated">&lt;code&gt;--debug-dbug&lt;/code&gt; 명령 행 옵션으로 MariaDB 테스트 스위트를 실행할 때 디버그 동기화 기능은 추적 메시지를 DBUG 추적에 기록합니다. 다음 셸 명령은 관련 정보를 추출하는 데 매우 유용했습니다.</target>
        </trans-unit>
        <trans-unit id="bc76d17b93e8c57c83308d8ae6b85b45acd75f0c" translate="yes" xml:space="preserve">
          <source>When searching for a query inside the query cache, a try_lock function waits with a timeout of 50ms. If the lock fails, the query isn't executed via the query cache. This timeout is hard coded (&lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-6766&quot;&gt;MDEV-6766&lt;/a&gt; include two variables to tune this timeout).</source>
          <target state="translated">쿼리 캐시 내에서 쿼리를 검색 할 때 try_lock 함수는 시간 초과가 50ms 인 대기합니다. 잠금이 실패하면 쿼리는 쿼리 캐시를 통해 실행되지 않습니다. 이 타임 아웃은 하드 코딩되어 있습니다 ( &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-6766&quot;&gt;MDEV-6766&lt;/a&gt; 에는이 타임 아웃을 조정하기위한 두 개의 변수가 포함되어 있습니다).</target>
        </trans-unit>
        <trans-unit id="f30757beaacdcf476a63d83c09450ec404b498f9" translate="yes" xml:space="preserve">
          <source>When searching on key values you may not find all rows</source>
          <target state="translated">키 값을 검색 할 때 모든 행을 찾지 못할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="116b0fb20b4e24ad08855d63abd5b1640664ff0b" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;assert&lt;/code&gt;, the default, XtraDB will intentionally crash the server when it detects corrupted data in a single-table tablespace, with an assertion failure.</source>
          <target state="translated">&lt;code&gt;assert&lt;/code&gt; 로 설정 하면 기본값 인 XtraDB는 단정 테이블 테이블 스페이스에서 손상된 데이터를 발견하면 어설 션 오류가 발생하여 서버를 의도적으로 중단시킵니다.</target>
        </trans-unit>
        <trans-unit id="e8923008f7ce29a002660fd3bdf0868bdc8f7a77" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;warn&lt;/code&gt;, it will pass corruption as corrupt table instead of crashing, and disable all further I/O (except for deletion) on the table file.</source>
          <target state="translated">&lt;code&gt;warn&lt;/code&gt; 으로 설정하면 손상 대신 충돌 테이블이 손상된 테이블로 전달되고 테이블 파일에서 모든 추가 I / O (삭제 제외)가 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="7e6141255344d3cd9c12a747966a7842fe7c1f83" translate="yes" xml:space="preserve">
          <source>When setting &lt;a href=&quot;../sql-mode/index&quot;&gt;sql_mode=EMPTY_STRING_IS_NULL&lt;/a&gt;, empty strings and NULLs are the same thing. For example:</source>
          <target state="translated">&lt;a href=&quot;../sql-mode/index&quot;&gt;sql_mode = EMPTY_STRING_IS_NULL을&lt;/a&gt; 설정하면 빈 문자열과 NULL이 동일합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="623318bcd87e616bd70e332a8f0830ecd68b336d" translate="yes" xml:space="preserve">
          <source>When setting a system variable, the scope can be specified as either GLOBAL or SESSION.</source>
          <target state="translated">시스템 변수를 설정할 때 범위를 GLOBAL 또는 SESSION으로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15434807f2d9e446caa448dd257c5608cb0653da" translate="yes" xml:space="preserve">
          <source>When setting it dynamically with &lt;code&gt;&lt;a href=&quot;../set/index#global-session&quot;&gt;SET GLOBAL&lt;/a&gt;&lt;/code&gt;, the system variable accepts a comma-separated list of filters.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../set/index#global-session&quot;&gt;SET GLOBAL&lt;/a&gt;&lt;/code&gt; 로 동적으로 설정 하면 시스템 변수는 쉼표로 구분 된 필터 목록을 승인합니다.</target>
        </trans-unit>
        <trans-unit id="55a0cb96e2436e8afbec7caa773a73b6537ee61d" translate="yes" xml:space="preserve">
          <source>When setting it dynamically, it is not possible to specify database names that contain commas. If you need to specify database names that contain commas, then you will need to specify them by either providing the command-line options or configuring them in a server &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;option group&lt;/a&gt; in an &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;option file&lt;/a&gt; when the server is &lt;a href=&quot;../starting-and-stopping-mariadb-starting-and-stopping-mariadb/index&quot;&gt;started&lt;/a&gt;.</source>
          <target state="translated">동적으로 설정하면 쉼표가 포함 된 데이터베이스 이름을 지정할 수 없습니다. 쉼표가 포함 된 데이터베이스 이름을 지정해야하는 경우 서버가 &lt;a href=&quot;../starting-and-stopping-mariadb-starting-and-stopping-mariadb/index&quot;&gt;시작될&lt;/a&gt; 때 명령 행 옵션을 제공하거나 &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;옵션 파일&lt;/a&gt; 의 서버 &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;옵션 그룹&lt;/a&gt; 에서 구성하여이를 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c0396dedb9bd4e4f1e1764858b99187ee63992ac" translate="yes" xml:space="preserve">
          <source>When setting it dynamically, it is not possible to specify database names that contain commas. If you need to specify names or patterns that contain commas, then you will need to specify them by either providing the command-line options or configuring them in a server &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;option group&lt;/a&gt; in an &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;option file&lt;/a&gt; when the server is &lt;a href=&quot;../starting-and-stopping-mariadb-starting-and-stopping-mariadb/index&quot;&gt;started&lt;/a&gt;.</source>
          <target state="translated">동적으로 설정하면 쉼표가 포함 된 데이터베이스 이름을 지정할 수 없습니다. 쉼표가 포함 된 이름 또는 패턴을 지정해야하는 경우, 서버가 &lt;a href=&quot;../starting-and-stopping-mariadb-starting-and-stopping-mariadb/index&quot;&gt;시작될&lt;/a&gt; 때 명령 행 옵션을 제공하거나 &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;옵션 파일&lt;/a&gt; 의 서버 &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;옵션 그룹&lt;/a&gt; 에서 이를 구성하여 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6dc15439b0d2e5ddb446530ddd4bcddefefc6a86" translate="yes" xml:space="preserve">
          <source>When setting it dynamically, it is not possible to specify database or table names or patterns that contain commas. If you need to specify database or table names or patterns that contain commas, then you will need to specify them by either providing the command-line options or configuring them in a server &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;option group&lt;/a&gt; in an &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;option file&lt;/a&gt; when the server is &lt;a href=&quot;../starting-and-stopping-mariadb-starting-and-stopping-mariadb/index&quot;&gt;started&lt;/a&gt;.</source>
          <target state="translated">동적으로 설정하면 쉼표가 포함 된 데이터베이스 또는 테이블 이름 또는 패턴을 지정할 수 없습니다. 쉼표가 포함 된 데이터베이스 또는 테이블 이름 또는 패턴을 지정해야하는 경우, 명령 행 옵션을 제공하거나 서버가 &lt;a href=&quot;../starting-and-stopping-mariadb-starting-and-stopping-mariadb/index&quot;&gt;시작될&lt;/a&gt; 때 &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;옵션 파일&lt;/a&gt; 의 서버 &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;옵션 그룹&lt;/a&gt; 에서 이를 구성하여이를 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="aa17da09cde470311cca5984a01891ccf2134013" translate="yes" xml:space="preserve">
          <source>When setting it dynamically, it is not possible to specify database or table names or patterns that contain commas. If you need to specify database or table names that contain commas, then you will need to specify them by either providing the command-line options or configuring them in a server &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;option group&lt;/a&gt; in an &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;option file&lt;/a&gt; when the server is &lt;a href=&quot;../starting-and-stopping-mariadb-starting-and-stopping-mariadb/index&quot;&gt;started&lt;/a&gt;.</source>
          <target state="translated">동적으로 설정하면 쉼표가 포함 된 데이터베이스 또는 테이블 이름 또는 패턴을 지정할 수 없습니다. 쉼표가 포함 된 데이터베이스 또는 테이블 이름을 지정해야하는 경우, 서버가 &lt;a href=&quot;../starting-and-stopping-mariadb-starting-and-stopping-mariadb/index&quot;&gt;시작될&lt;/a&gt; 때 명령 행 옵션을 제공하거나 &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;옵션 파일&lt;/a&gt; 의 서버 &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;옵션 그룹&lt;/a&gt; 에서 구성하여이를 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="976b8ad4525aeb73094e31e1d0265244a4751905" translate="yes" xml:space="preserve">
          <source>When setting it dynamically, it is not possible to specify database or table names that contain commas. If you need to specify database or table names that contain commas, then you will need to specify them by either providing the command-line options or configuring them in a server &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;option group&lt;/a&gt; in an &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;option file&lt;/a&gt; when the server is &lt;a href=&quot;../starting-and-stopping-mariadb-starting-and-stopping-mariadb/index&quot;&gt;started&lt;/a&gt;.</source>
          <target state="translated">동적으로 설정하면 쉼표가 포함 된 데이터베이스 또는 테이블 이름을 지정할 수 없습니다. 쉼표가 포함 된 데이터베이스 또는 테이블 이름을 지정해야하는 경우, 서버가 &lt;a href=&quot;../starting-and-stopping-mariadb-starting-and-stopping-mariadb/index&quot;&gt;시작될&lt;/a&gt; 때 명령 행 옵션을 제공하거나 &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;옵션 파일&lt;/a&gt; 의 서버 &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;옵션 그룹&lt;/a&gt; 에서 구성하여이를 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f9ec50a8ede28be721efd779bcbc247da0741e28" translate="yes" xml:space="preserve">
          <source>When setting it dynamically, the &lt;a href=&quot;../replication-threads/index#threads-on-the-slave&quot;&gt;slave threads&lt;/a&gt; must be stopped. For example:</source>
          <target state="translated">동적으로 설정할 때 &lt;a href=&quot;../replication-threads/index#threads-on-the-slave&quot;&gt;슬레이브 스레드&lt;/a&gt; 를 중지해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0e050053cb02799b9d6dd09424165775eb18e063" translate="yes" xml:space="preserve">
          <source>When setting it on the command-line or in a server &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;option group&lt;/a&gt; in an &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;option file&lt;/a&gt;, the option does not accept a comma-separated list. If you would like to specify multiple filters, then you need to specify the option multiple times.</source>
          <target state="translated">&lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;옵션 파일&lt;/a&gt; 의 명령 행 또는 서버 &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;옵션 그룹&lt;/a&gt; 에서 설정하는 경우, 옵션은 쉼표로 구분 된 목록을 승인하지 않습니다. 여러 필터를 지정하려면 옵션을 여러 번 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="f02f715bfa093415df5aaee3d7296e8648765349" translate="yes" xml:space="preserve">
          <source>When setting it on the command-line or in a server &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;option group&lt;/a&gt; in an &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;option file&lt;/a&gt;, the option does not accept a comma-separated list. If you would like to specify multiple filters, then you need to specify the option multiple times. For example:</source>
          <target state="translated">&lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;옵션 파일&lt;/a&gt; 의 명령 행 또는 서버 &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;옵션 그룹&lt;/a&gt; 에서 설정하는 경우, 옵션은 쉼표로 구분 된 목록을 승인하지 않습니다. 여러 필터를 지정하려면 옵션을 여러 번 지정해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8d4742a1d78d78f2e7988a3ee4d3de0e061c0717" translate="yes" xml:space="preserve">
          <source>When setting it on the command-line or in a server &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;option group&lt;/a&gt; in an &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;option file&lt;/a&gt;, the system variable does not accept a comma-separated list. If you would like to specify multiple filters, then you need to specify the system variable multiple times.</source>
          <target state="translated">&lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;옵션 파일&lt;/a&gt; 의 명령 행 또는 서버 &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;옵션 그룹&lt;/a&gt; 에서 설정하는 경우 시스템 변수는 쉼표로 구분 된 목록을 허용하지 않습니다. 여러 필터를 지정하려면 시스템 변수를 여러 번 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="28b64fa82ccbf9da93bfae5289bb22544a2c006d" translate="yes" xml:space="preserve">
          <source>When setting it on the command-line or in a server &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;option group&lt;/a&gt; in an &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;option file&lt;/a&gt;, the system variable does not accept a comma-separated list. If you would like to specify multiple filters, then you need to specify the system variable multiple times. For example:</source>
          <target state="translated">&lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;옵션 파일&lt;/a&gt; 의 명령 행 또는 서버 &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;옵션 그룹&lt;/a&gt; 에서 설정하는 경우 시스템 변수는 쉼표로 구분 된 목록을 허용하지 않습니다. 여러 필터를 지정하려면 시스템 변수를 여러 번 지정해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0f5b5cfe250c40d2705a133b613fdabd64653faa" translate="yes" xml:space="preserve">
          <source>When setting several variables using the columns returned by a query, &lt;code&gt;&lt;a href=&quot;../select-into/index&quot;&gt;SELECT INTO&lt;/a&gt;&lt;/code&gt; should be preferred.</source>
          <target state="translated">쿼리에서 반환 된 열을 사용하여 여러 변수를 설정하는 경우 &lt;code&gt;&lt;a href=&quot;../select-into/index&quot;&gt;SELECT INTO&lt;/a&gt;&lt;/code&gt; 가 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="1b32cc35408d8ee87baed93b9c9bcc08442c6d69" translate="yes" xml:space="preserve">
          <source>When setting the &lt;code&gt;&lt;a href=&quot;../change-master-to/index#master_use_gtid&quot;&gt;MASTER_USE_GTID&lt;/a&gt;&lt;/code&gt; replication parameter, you have the option of enabling Global Transaction IDs to use either the &lt;code&gt;current_pos&lt;/code&gt; or &lt;code&gt;slave_pos&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../change-master-to/index#master_use_gtid&quot;&gt;MASTER_USE_GTID&lt;/a&gt;&lt;/code&gt; 복제 매개 변수를 설정할 때 글로벌 트랜잭션 ID가 &lt;code&gt;current_pos&lt;/code&gt; 또는 &lt;code&gt;slave_pos&lt;/code&gt; 값 을 사용하도록 설정하는 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5850968731d432291b21fe0a8c5ab6c8bde43cbd" translate="yes" xml:space="preserve">
          <source>When setting the &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_data_file_path&quot;&gt;innodb_data_file_path&lt;/a&gt;&lt;/code&gt; system variable, you can define a size for each file given. In cases where you need a larger system tablespace, add the &lt;code&gt;autoextend&lt;/code&gt; option to the last value.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_data_file_path&quot;&gt;innodb_data_file_path&lt;/a&gt;&lt;/code&gt; 시스템 변수를 설정할 때 주어진 각 파일의 크기를 정의 할 수 있습니다. 더 큰 시스템 테이블 스페이스가 필요한 경우 &lt;code&gt;autoextend&lt;/code&gt; 옵션을 마지막 값에 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="f6b53ea67368513e6610b9471c12465b50d70de0" translate="yes" xml:space="preserve">
          <source>When setting the &lt;code&gt;&lt;a href=&quot;../thread-pool-system-status-variables/index#thread_pool_size&quot;&gt;thread_pool_size&lt;/a&gt;&lt;/code&gt; system variable's value at system startup, the max value is &lt;code&gt;100000&lt;/code&gt;. However, it is not a good idea to set it that high. When setting its value dynamically, the max value is either &lt;code&gt;128&lt;/code&gt; or the value that was set at system startup--whichever value is higher. It can be changed dynamically with &lt;code&gt;&lt;a href=&quot;../set/index#global-session&quot;&gt;SET GLOBAL&lt;/a&gt;&lt;/code&gt;. For example:</source>
          <target state="translated">시스템 시작시 &lt;code&gt;&lt;a href=&quot;../thread-pool-system-status-variables/index#thread_pool_size&quot;&gt;thread_pool_size&lt;/a&gt;&lt;/code&gt; 시스템 변수의 값을 설정할 때 최대 값은 &lt;code&gt;100000&lt;/code&gt; 입니다. 그러나 그것을 높게 설정하는 것은 좋은 생각이 아닙니다. 값을 동적으로 설정할 때 최대 값은 &lt;code&gt;128&lt;/code&gt; 이거나 시스템 시작시 설정된 값 중 큰 값입니다. &lt;code&gt;&lt;a href=&quot;../set/index#global-session&quot;&gt;SET GLOBAL&lt;/a&gt;&lt;/code&gt; 을 사용 하여 동적으로 변경할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="556a51102be75eefefe7f4f3479ba1773c88477d" translate="yes" xml:space="preserve">
          <source>When setting the variable on the command line or in a configuration file, it is possible to specify engines that are not enabled in the server. The server will then still start if, for example, that engine is no longer used. Attempting to set a non-enabled engine dynamically in a running server (with SET GLOBAL gtid_pos_auto_engines) will still result in an error.</source>
          <target state="translated">명령 행 또는 구성 파일에서 변수를 설정할 때 서버에서 사용할 수없는 엔진을 지정할 수 있습니다. 예를 들어 해당 엔진을 더 이상 사용하지 않으면 서버는 계속 시작됩니다. SET GLOBAL gtid_pos_auto_engines를 사용하여 실행중인 서버에서 사용 불가능한 엔진을 동적으로 설정하려고하면 여전히 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5524b0cbeafb35e0f71773d1e57c8969472ed06e" translate="yes" xml:space="preserve">
          <source>When setting up the data directory, you have the option of either using a shared database directory or creating a unique database directory for each server version. For testing, a common directory is probably easiest. Note that you can only have one &lt;code&gt;mysqld&lt;/code&gt; server running against one data directory.</source>
          <target state="translated">데이터 디렉토리를 설정할 때 공유 데이터베이스 디렉토리를 사용하거나 각 서버 버전에 대해 고유 한 데이터베이스 디렉토리를 작성하는 옵션이 있습니다. 테스트를 위해 공통 디렉토리가 가장 쉽습니다. 하나의 데이터 디렉토리에 대해 하나의 &lt;code&gt;mysqld&lt;/code&gt; 서버 만 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bc99213f11e11ff05648271c61f2b83d864d1b3d" translate="yes" xml:space="preserve">
          <source>When several commands are sent, the execution stops at the end of them or after a command that is in error. To continue after &lt;em&gt;n&lt;/em&gt; errors, set the option maxerr=&lt;em&gt;n&lt;/em&gt; (0 by default) in the option list.</source>
          <target state="translated">여러 명령이 전송되면 명령이 끝날 때 또는 오류가 발생한 명령 후에 실행이 중지됩니다. &lt;em&gt;n&lt;/em&gt; 오류 후에 계속하려면 옵션 목록에서 maxerr = &lt;em&gt;n&lt;/em&gt; (기본적으로 0) 옵션을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="5a4f26c474d11585059f56314b2bc5769f9ea064" translate="yes" xml:space="preserve">
          <source>When several commands are sent, the execution stops at the end of them or after a command that is in error. To continue after n errors, set the option maxerr=&lt;em&gt;n&lt;/em&gt; (0 by default) in the option list.</source>
          <target state="translated">여러 명령이 전송되면 명령이 끝날 때 또는 오류가 발생한 명령 후에 실행이 중지됩니다. n 오류 후에 계속하려면 옵션 목록에서 maxerr = &lt;em&gt;n&lt;/em&gt; (기본적으로 0) 옵션을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="8b16b603e6f2373aa02b50b9b0d60ec6e8cfc25a" translate="yes" xml:space="preserve">
          <source>When slave is up to date, you can then take the &lt;strong&gt;MASTER&lt;/strong&gt; down. This should be on the same connection where you executed &lt;code&gt;&lt;a href=&quot;../flush/index&quot;&gt;FLUSH TABLES WITH READ LOCK&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">슬레이브가 최신 상태이면 &lt;strong&gt;MASTER를&lt;/strong&gt; 중단 할 수 있습니다 . &lt;code&gt;&lt;a href=&quot;../flush/index&quot;&gt;FLUSH TABLES WITH READ LOCK&lt;/a&gt;&lt;/code&gt; 을 실행 한 동일한 연결에 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="03cb9e2a44d4765c4adcb70f9ab7a76c87dbbd0d" translate="yes" xml:space="preserve">
          <source>When spanning colos, you need 3 (or more) data centers in order to be 'always' up, even during a colo failure. With only 2 data centers, Galera can automatically recover from one colo outage, but not the other. (You pick which.)</source>
          <target state="translated">콜로에 걸치면 콜로 장애가 발생하더라도 '항상'작동하려면 3 개 이상의 데이터 센터가 필요합니다. 2 개의 데이터 센터 만 있으면 Galera는 한 콜로 중단에서 자동으로 복구 할 수 있지만 다른 콜로에서는 복구 할 수 없습니다. (당신은 어느 것을 선택합니다.)</target>
        </trans-unit>
        <trans-unit id="cb3104615fbdac2a78e21b1c3a3c83b0898c264e" translate="yes" xml:space="preserve">
          <source>When specified in the create table statement, the subdir option indicates to list, in addition to the files contained in the specified directory, all the files verifying the filename pattern that are contained in sub-directories of the specified directory. For instance, using:</source>
          <target state="translated">테이블 작성 명령문에 지정된 경우, subdir 옵션은 지정된 디렉토리에 포함 된 파일 외에도 지정된 디렉토리의 서브 디렉토리에 포함 된 파일 이름 패턴을 확인하는 모든 파일을 나열하도록 표시합니다. 예를 들어 다음을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3ad09a99cee6273e1f795f3f99b879039c078ae0" translate="yes" xml:space="preserve">
          <source>When specified, the DBNAME create table option is regarded by ODBC tables as the SCHEMA name.</source>
          <target state="translated">지정된 경우 DBNAME 테이블 작성 옵션은 ODBC 테이블에서 SCHEMA 이름으로 간주합니다.</target>
        </trans-unit>
        <trans-unit id="cdb5b754d69a62d342e9393bf4122f4b06ed0b65" translate="yes" xml:space="preserve">
          <source>When specified, the columns of the mysql table must exist in the accessed table with the same name, but can be only a subset of them and specified in a different order. Their type must be a type supported by CONNECT and, if it is not identical to the type of the accessed table matching column, a conversion can be done according to the rules given in &lt;a href=&quot;../connect-data-types/index#data-type-conversion&quot;&gt;Data type conversion&lt;/a&gt;.</source>
          <target state="translated">지정된 경우, mysql 테이블의 컬럼은 동일한 이름의 액세스 된 테이블에 존재해야하지만 이들의 서브 세트 일 수 있으며 다른 순서로 지정할 수 있습니다. 해당 유형은 CONNECT에서 지원하는 유형이어야하며 액세스 된 테이블 일치 열의 유형과 동일하지 않은 경우 &lt;a href=&quot;../connect-data-types/index#data-type-conversion&quot;&gt;데이터 유형 변환에&lt;/a&gt; 제공된 규칙에 따라 변환을 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f24876453a50c5e6057b317305c031cdf886a01f" translate="yes" xml:space="preserve">
          <source>When specifying a column, you can either use just the column name or qualify the column name with the name of the table using &lt;code&gt;tbl_name.col_name&lt;/code&gt;. The qualified form is useful if you are joining multiple tables in the &lt;code&gt;FROM&lt;/code&gt; clause. If you do not qualify the column names when selecting from multiple tables, MariaDB will try to find the column in each table. It is an error if that column name exists in multiple tables.</source>
          <target state="translated">열을 지정할 때 &lt;code&gt;tbl_name.col_name&lt;/code&gt; 을 사용하여 열 이름 만 사용하거나 테이블 이름으로 열 이름을 규정 할 수 있습니다 . &lt;code&gt;FROM&lt;/code&gt; 절 에서 여러 테이블을 조인하는 경우 규정 양식이 유용합니다 . 여러 테이블에서 선택할 때 열 이름을 규정하지 않으면 MariaDB는 각 테이블에서 열을 찾으려고 시도합니다. 해당 열 이름이 여러 테이블에 있으면 오류입니다.</target>
        </trans-unit>
        <trans-unit id="1da6a814c2a1c605382d1834672753f09f0e7cb0" translate="yes" xml:space="preserve">
          <source>When starting mysqld with the pool of threads code you should use</source>
          <target state="translated">스레드 풀 코드로 mysqld를 시작할 때 사용해야합니다</target>
        </trans-unit>
        <trans-unit id="706124ee5fde774f107797409a98b4041c738d07" translate="yes" xml:space="preserve">
          <source>When starting replication with &lt;a href=&quot;../start-slave/index&quot;&gt;START SLAVE&lt;/a&gt;, it is possible to request the slave to run only until a specific GTID position is reached. Once that position is reached, the slave will stop.</source>
          <target state="translated">&lt;a href=&quot;../start-slave/index&quot;&gt;START SLAVE로&lt;/a&gt; 복제를 시작할 때 특정 GTID 위치에 도달 할 때까지만 슬레이브가 실행되도록 요청할 수 있습니다. 해당 위치에 도달하면 슬레이브가 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="f59e5338d04844968c5327ce6541694585bf2589" translate="yes" xml:space="preserve">
          <source>When starting the original master, it's good to start the &lt;code&gt;mysqld&lt;/code&gt; executable with the &lt;code&gt;--with-skip-slave-start&lt;/code&gt; and &lt;code&gt;--read-only&lt;/code&gt; options to ensure that no old slave configurations could cause any conflicts.</source>
          <target state="translated">원래 마스터를 시작할 때 &lt;code&gt;--with-skip-slave-start&lt;/code&gt; 및 &lt;code&gt;--read-only&lt;/code&gt; 옵션으로 &lt;code&gt;mysqld&lt;/code&gt; 실행 파일 을 시작하여 오래된 슬레이브 구성으로 인해 충돌이 발생하지 않도록하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="a517e40deb9741241b6d46b8353d02191726cf31" translate="yes" xml:space="preserve">
          <source>When starting what became the MariaDB project, Monty and the initial developers only planned to work on a next generation &lt;a href=&quot;../myisam-storage-engine/index&quot;&gt;MyISAM&lt;/a&gt; storage engine replacement. This storage engine would be crash safe and eventually support transactions. Monty named the storage engine, and the project, after his daughter, Maria.</source>
          <target state="translated">MariaDB 프로젝트가 된 것을 시작할 때 Monty와 초기 개발자는 차세대 &lt;a href=&quot;../myisam-storage-engine/index&quot;&gt;MyISAM&lt;/a&gt; 스토리지 엔진 교체 작업 만 계획했습니다 . 이 스토리지 엔진은 충돌에 안전하며 결국 트랜잭션을 지원합니다. Monty는 딸 Maria의 이름을 따서 스토리지 엔진과 프로젝트의 이름을 지정했습니다.</target>
        </trans-unit>
        <trans-unit id="2e467ac5680daba957fd15fee3bdab3ccec2c6ba" translate="yes" xml:space="preserve">
          <source>When starting with binary log encryption, MariaDB Server logs a &lt;code&gt;Format_descriptor_log_event&lt;/code&gt; and a &lt;code&gt;START_ENCRYPTION_EVENT&lt;/code&gt;, then encrypts all subsequent events for the binary log.</source>
          <target state="translated">이진 로그 암호화로 시작할 때 MariaDB 서버는 &lt;code&gt;Format_descriptor_log_event&lt;/code&gt; 및 &lt;code&gt;START_ENCRYPTION_EVENT&lt;/code&gt; 를 기록한 다음 이진 로그에 대한 모든 후속 이벤트를 암호화합니다.</target>
        </trans-unit>
        <trans-unit id="2f8e1cc9108ec2c77d16bfca009de71b81c57041" translate="yes" xml:space="preserve">
          <source>When starting, &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt; and beyond automatically detects if any of the supported SSD cards are used.</source>
          <target state="translated">시작할 때 &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt; 이상은 지원되는 SSD 카드가 사용되는지 자동으로 감지합니다.</target>
        </trans-unit>
        <trans-unit id="94ed348aab25911c9ab718ac23eac7f7d2281419" translate="yes" xml:space="preserve">
          <source>When statement-based logging is enabled, statements are logged to the &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt; exactly as they were executed.</source>
          <target state="translated">명령문 기반 로깅이 사용 가능한 경우 명령문은 실행 된 그대로 정확하게 &lt;a href=&quot;../binary-log/index&quot;&gt;2 진 로그에&lt;/a&gt; 로깅됩니다 .</target>
        </trans-unit>
        <trans-unit id="e5d724409c5a84781f84946ab55153cbc2c7c367" translate="yes" xml:space="preserve">
          <source>When string values are compared, they are compared as if by the &lt;code&gt;&lt;a href=&quot;../strcmp/index&quot;&gt;STRCMP&lt;/a&gt;&lt;/code&gt; function. &lt;code&gt;STRCMP&lt;/code&gt; ignores trailing whitespace and may normalize characters and ignore case, depending on the &lt;a href=&quot;../data-types-character-sets-and-collations/index&quot;&gt;collation&lt;/a&gt; in use.</source>
          <target state="translated">문자열 값을 비교할 때 &lt;code&gt;&lt;a href=&quot;../strcmp/index&quot;&gt;STRCMP&lt;/a&gt;&lt;/code&gt; 함수에 의한 것처럼 비교됩니다 . &lt;code&gt;STRCMP&lt;/code&gt; 는 후행 공백을 무시 하고 사용중인 &lt;a href=&quot;../data-types-character-sets-and-collations/index&quot;&gt;데이터 정렬&lt;/a&gt; 에 따라 문자를 정규화하고 대소 문자를 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b35271169dcf70f6d5e0118529c689e6b1dbfd0" translate="yes" xml:space="preserve">
          <source>When summarizing, include &lt;code&gt;COUNT(*) AS ct and SUM(foo) AS sum_foo&lt;/code&gt;. When reporting, the &quot;average&quot; is computed as SUM(sum_foo) / SUM(ct). That is mathematically correct.</source>
          <target state="translated">요약 할 때 &lt;code&gt;COUNT(*) AS ct and SUM(foo) AS sum_foo&lt;/code&gt; . 보고 할 때 &quot;평균&quot;은 SUM (sum_foo) / SUM (ct)로 계산됩니다. 수학적으로 맞습니다.</target>
        </trans-unit>
        <trans-unit id="f7e405734a2ef24babaa25e4296251d3a15dc568" translate="yes" xml:space="preserve">
          <source>When talking about billions of rows in the Fact table, it is essentially mandatory that you &quot;batch&quot; the inserts. There are two main ways:</source>
          <target state="translated">팩트 테이블에서 수십억 행에 대해 이야기 할 때는 반드시 인서트를 &quot;일괄 처리&quot;해야합니다. 두 가지 주요 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c76b5022bc3a00f8ba25a11bfd75663505f40047" translate="yes" xml:space="preserve">
          <source>When testing an expression for a branch (in IF, WHILE, etc)</source>
          <target state="translated">분기에 대한 표현식을 테스트 할 때 (IF, WHILE 등)</target>
        </trans-unit>
        <trans-unit id="4bf0a5749c1a816f0fc12d0ac4f14a77ac5686c4" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;../innodb-system-tablespaces/index&quot;&gt;InnoDB system tablespace&lt;/a&gt; is encrypted, it is represented in this table with the special name: &lt;code&gt;innodb_system&lt;/code&gt;.</source>
          <target state="translated">때 &lt;a href=&quot;../innodb-system-tablespaces/index&quot;&gt;InnoDB의 시스템 테이블 스페이스&lt;/a&gt; 암호화, 그것은 특별한 이름이 테이블에 표시됩니다 : &lt;code&gt;innodb_system&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="5db9e18e5827213b48f9fce09140a7689e260eca" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#skip_replication&quot;&gt;skip_replication&lt;/a&gt; variable is set to true, changes are logged into the &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt; with the flag &lt;code&gt;@@skip_replication&lt;/code&gt; set. Such events will not be replicated by slaves that run with &lt;code&gt;--replicate-events-marked-for-skip&lt;/code&gt; set different from its default of &lt;code&gt;REPLICATE&lt;/code&gt;.</source>
          <target state="translated">때 &lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#skip_replication&quot;&gt;skip_replication의&lt;/a&gt; 변수가 true로 설정되어, 변경 사항은에 로그인 &lt;a href=&quot;../binary-log/index&quot;&gt;바이너리 로그&lt;/a&gt; 플래그로 &lt;code&gt;@@skip_replication&lt;/code&gt; 세트. 이러한 이벤트는 &lt;code&gt;--replicate-events-marked-for-skip&lt;/code&gt; 설정으로 실행되어 기본 &lt;code&gt;REPLICATE&lt;/code&gt; 와 다른 슬레이브에 의해 복제되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7d9f2145480761b46f96446180a0e8fcf3853c4c" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;--wait-for-all-slaves&lt;/code&gt; option is provided, the server only kills its binary log dump threads after all client threads have been killed, and it only completes the shutdown after the last &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt; has been sent to all connected slaves.</source>
          <target state="translated">(가) 때 &lt;code&gt;--wait-for-all-slaves&lt;/code&gt; 옵션이 제공되며, 서버는 바이너리 로그 덤프 스레드를 죽이고 모든 클라이언트 스레드를 죽이고, 그것은 단지 지난 후 종료 완료 한 후에 &lt;a href=&quot;../binary-log/index&quot;&gt;바이너리 로그를&lt;/a&gt; 연결된 모든 슬레이브로 전송되었습니다 .</target>
        </trans-unit>
        <trans-unit id="bd0d389ceb4ec33a4fdae3121afa5107a7714556" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;&lt;a href=&quot;#spider_sync_trx_isolation&quot;&gt;spider_sync_trx_isolation&lt;/a&gt;&lt;/code&gt; system variable is set to &lt;code&gt;0&lt;/code&gt;, Spider disables &lt;code&gt;&lt;a href=&quot;../handler/index&quot;&gt;HANDLER&lt;/a&gt;&lt;/code&gt; conversions to prevent use of the statement on the &lt;code&gt;&lt;a href=&quot;../set-transaction/index#serializable&quot;&gt;SERIALIZABLE&lt;/a&gt;&lt;/code&gt; isolation level. &lt;strong&gt; &lt;code&gt;0&lt;/code&gt; Converts &lt;code&gt;&lt;a href=&quot;../handler/index&quot;&gt;HANDLER&lt;/a&gt;&lt;/code&gt; statements into &lt;code&gt;&lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt;&lt;/code&gt; statements. &lt;/strong&gt;&lt;code&gt;1&lt;/code&gt; Passes &lt;code&gt;&lt;a href=&quot;../handler/index&quot;&gt;HANDLER&lt;/a&gt;&lt;/code&gt; to the remote backend server. &lt;strong&gt; &lt;code&gt;2&lt;/code&gt; Converts SQL statements to &lt;code&gt;&lt;a href=&quot;../handler/index&quot;&gt;HANDLER&lt;/a&gt;&lt;/code&gt; statements. &lt;/strong&gt;&lt;code&gt;3&lt;/code&gt; Converts SQL statements to &lt;code&gt;&lt;a href=&quot;../handler/index&quot;&gt;HANDLER&lt;/a&gt;&lt;/code&gt; statements and &lt;code&gt;&lt;a href=&quot;../handler/index&quot;&gt;HANDLER&lt;/a&gt;&lt;/code&gt; statements to SQL statements.</source>
          <target state="translated">때 &lt;code&gt;&lt;a href=&quot;#spider_sync_trx_isolation&quot;&gt;spider_sync_trx_isolation&lt;/a&gt;&lt;/code&gt; 의 시스템 변수로 설정되어 &lt;code&gt;0&lt;/code&gt; , 거미 비활성화 &lt;code&gt;&lt;a href=&quot;../handler/index&quot;&gt;HANDLER&lt;/a&gt;&lt;/code&gt; 상의 문장의 사용을 방지하기 위해 변환을 &lt;code&gt;&lt;a href=&quot;../set-transaction/index#serializable&quot;&gt;SERIALIZABLE&lt;/a&gt;&lt;/code&gt; 격리 수준을. &lt;strong&gt; &lt;code&gt;0&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt; &lt;code&gt;&lt;a href=&quot;../handler/index&quot;&gt;HANDLER&lt;/a&gt;&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt; 문을 &lt;/strong&gt;&lt;strong&gt; &lt;code&gt;&lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt;&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt; 문 &lt;/strong&gt;&lt;strong&gt;으로 &lt;/strong&gt;&lt;strong&gt;변환 &lt;/strong&gt;&lt;strong&gt;합니다. &lt;/strong&gt; &lt;code&gt;1&lt;/code&gt; 패스 &lt;code&gt;&lt;a href=&quot;../handler/index&quot;&gt;HANDLER&lt;/a&gt;&lt;/code&gt; 원격 백엔드 서버를. &lt;strong&gt; &lt;code&gt;2&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt; SQL 문을 &lt;/strong&gt;&lt;strong&gt; &lt;code&gt;&lt;a href=&quot;../handler/index&quot;&gt;HANDLER&lt;/a&gt;&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt; 문으로 &lt;/strong&gt;&lt;strong&gt;변환 &lt;/strong&gt;&lt;strong&gt;합니다. &lt;/strong&gt; &lt;code&gt;3&lt;/code&gt; SQL 문을 &lt;code&gt;&lt;a href=&quot;../handler/index&quot;&gt;HANDLER&lt;/a&gt;&lt;/code&gt; 문으로 변환 하고 &lt;code&gt;&lt;a href=&quot;../handler/index&quot;&gt;HANDLER&lt;/a&gt;&lt;/code&gt; 문을 SQL 문으로 변환 합니다.&lt;strong&gt; &lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5033396ef78aab5ccbf81a51939ffcc5f99efd51" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; clause is set to &lt;code&gt;INPLACE&lt;/code&gt;, the supported operations are a superset of the operations that are supported when the &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; clause is set to &lt;code&gt;NOCOPY&lt;/code&gt;. Similarly, when the &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; clause is set to &lt;code&gt;NOCOPY&lt;/code&gt;, the supported operations are a superset of the operations that are supported when the &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; clause is set to &lt;code&gt;INSTANT&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 절이로 설정되어 &lt;code&gt;INPLACE&lt;/code&gt; , 지원되는 작업은 때 지원되는 작업의 수퍼 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 절이로 설정되어 &lt;code&gt;NOCOPY&lt;/code&gt; . 마찬가지로, &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 절이 &lt;code&gt;NOCOPY&lt;/code&gt; 로 설정 되면 지원되는 조작은 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 절이 &lt;code&gt;INSTANT&lt;/code&gt; 로 설정 될 때 지원되는 조작의 상위 세트입니다 .</target>
        </trans-unit>
        <trans-unit id="485e3f31f3cd478e3349d8dc9330c5619a1d07c2" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; clause is set to &lt;code&gt;NOCOPY&lt;/code&gt;, the supported operations are a superset of the operations that are supported when the &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; clause is set to &lt;code&gt;INSTANT&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 절이로 설정되어 &lt;code&gt;NOCOPY&lt;/code&gt; , 지원되는 작업은 때 지원되는 작업의 수퍼 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 절이로 설정되어 &lt;code&gt;INSTANT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="807d3f7084ee7ee59d765b5269a3a680d2d25dd6" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;&lt;a href=&quot;../analyze-table/index&quot;&gt;ANALYZE TABLE&lt;/a&gt;&lt;/code&gt; statement is executed, MariaDB makes a call to the table's storage engine, and the storage engine collects its own statistics for the table. The specific behavior depends on the storage engine. For &lt;a href=&quot;../innodb/index&quot;&gt;InnoDB&lt;/a&gt;, see &lt;a href=&quot;../innodb-persistent-statistics/index&quot;&gt;InnoDB Persistent Statistics&lt;/a&gt; for more information.</source>
          <target state="translated">때 &lt;code&gt;&lt;a href=&quot;../analyze-table/index&quot;&gt;ANALYZE TABLE&lt;/a&gt;&lt;/code&gt; 의 문을 실행, MariaDB는 테이블의 스토리지 엔진에 대한 호출을하고, 스토리지 엔진은 테이블에 대한 자체 통계를 수집합니다. 특정 동작은 스토리지 엔진에 따라 다릅니다. 들어 &lt;a href=&quot;../innodb/index&quot;&gt;이노&lt;/a&gt; 참조 &lt;a href=&quot;../innodb-persistent-statistics/index&quot;&gt;이노에게 영구 통계&lt;/a&gt; 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="86c1c3039d12cd79277df66ba34fab0e405d8777" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;&lt;a href=&quot;../analyze-table/index&quot;&gt;ANALYZE TABLE&lt;/a&gt;&lt;/code&gt; statement is executed, MariaDB may also collect engine-independent statistics for the table. The specific behavior depends on the value of the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#use_stat_tables&quot;&gt;use_stat_tables&lt;/a&gt;&lt;/code&gt; system variable. Engine-independent statistics will only be collected by the &lt;code&gt;&lt;a href=&quot;../analyze-table/index&quot;&gt;ANALYZE TABLE&lt;/a&gt;&lt;/code&gt; statement if one of the following is true:</source>
          <target state="translated">때 &lt;code&gt;&lt;a href=&quot;../analyze-table/index&quot;&gt;ANALYZE TABLE&lt;/a&gt;&lt;/code&gt; 의 문을 실행, MariaDB는 테이블에 대한 수집 엔진에 독립적 인 통계도 할 수있다. 구체적인 동작은 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#use_stat_tables&quot;&gt;use_stat_tables&lt;/a&gt;&lt;/code&gt; 시스템 변수 의 값에 따라 다릅니다 . 엔진 독립 통계는 다음 중 하나에 해당하는 경우 &lt;code&gt;&lt;a href=&quot;../analyze-table/index&quot;&gt;ANALYZE TABLE&lt;/a&gt;&lt;/code&gt; 문으로 만 수집됩니다 .</target>
        </trans-unit>
        <trans-unit id="2704fd2b12972b4b2073d241b37889f4e413e863" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;BLOCK_COMMIT&lt;/code&gt;'s stages return, this is the 'backup time'. Everything committed will be in the backup and everything not committed will roll back.</source>
          <target state="translated">때 &lt;code&gt;BLOCK_COMMIT&lt;/code&gt; '백업 시간의 단계가 반환, 이것은이다'. 커밋 된 모든 것이 백업에 있으며 커밋되지 않은 모든 것이 롤백됩니다.</target>
        </trans-unit>
        <trans-unit id="c62cea725d90bc615d0742208dd1b0f87e86b8d7" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;COPY&lt;/code&gt; algorithm is used, MariaDB essentially does the following operations:</source>
          <target state="translated">때 &lt;code&gt;COPY&lt;/code&gt; 알고리즘을 사용, MariaDB는 기본적으로 다음과 같은 작업을 수행합니다</target>
        </trans-unit>
        <trans-unit id="80718e61b14b3f6731511a8ab64a1ff3a220d30e" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;DEFAULT_SYSCONFDIR&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;../generic-build-instructions/index#using-cmake&quot;&gt;cmake&lt;/a&gt;&lt;/code&gt; option was &lt;strong&gt;not&lt;/strong&gt; defined, MariaDB looks for the MariaDB option file in the following locations in the following order:</source>
          <target state="translated">때 &lt;code&gt;DEFAULT_SYSCONFDIR&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;../generic-build-instructions/index#using-cmake&quot;&gt;cmake&lt;/a&gt;&lt;/code&gt; 의 옵션이되었다 &lt;strong&gt;없습니다&lt;/strong&gt; 정의, MariaDB는 다음과 같은 순서대로 다음 위치에서 MariaDB 옵션 파일을 찾습니다 :</target>
        </trans-unit>
        <trans-unit id="2cca3d9ded1a0d157a205248ce4a41c31fa7a5a3" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;DEFAULT_SYSCONFDIR&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;../generic-build-instructions/index#using-cmake&quot;&gt;cmake&lt;/a&gt;&lt;/code&gt; option was defined, MariaDB looks for the MariaDB option file in the following locations in the following order:</source>
          <target state="translated">때 &lt;code&gt;DEFAULT_SYSCONFDIR&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;../generic-build-instructions/index#using-cmake&quot;&gt;cmake&lt;/a&gt;&lt;/code&gt; 의 옵션을 정의, MariaDB는 다음과 같은 순서대로 다음 위치에서 MariaDB 옵션 파일을 찾습니다 :</target>
        </trans-unit>
        <trans-unit id="837138802360528121edad00aa59ff4995c0e8d8" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;IF EXISTS&lt;/code&gt; clause is used, MariaDB will return a warning instead of an error for each specified user that does not exist.</source>
          <target state="translated">때 &lt;code&gt;IF EXISTS&lt;/code&gt; 절을 사용하는, MariaDB가 존재하지 않습니다 지정된 각 사용자에 대한 오류 대신 경고를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4aef87ca9e4c77b704dcc5b7a80f7f721c646972" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;IF NOT EXISTS&lt;/code&gt; clause is used, MariaDB will return a note instead of an error if the specified plugin already exists. See &lt;a href=&quot;../show-warnings/index&quot;&gt;SHOW WARNINGS&lt;/a&gt;.</source>
          <target state="translated">때 &lt;code&gt;IF NOT EXISTS&lt;/code&gt; 절은 사용되는 지정된 플러그인 이미 존재하는 경우, MariaDB 대신 오류로 메모를 반환합니다. &lt;a href=&quot;../show-warnings/index&quot;&gt;경고 표시를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b76565b2d312b8f56b600eded450674700e58d7c" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;IF NOT EXISTS&lt;/code&gt; clause is used, MariaDB will return a warning instead of an error if the specified database already exists.</source>
          <target state="translated">때 &lt;code&gt;IF NOT EXISTS&lt;/code&gt; 절은 사용되는 지정된 데이터베이스가 이미 존재하는 경우, MariaDB는 오류 대신 경고를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f34aa869e55280f83acf0bbf3d44319f7b747768" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;IF NOT EXISTS&lt;/code&gt; clause is used, MariaDB will return a warning instead of an error if the specified role already exists. Cannot be used together with the &lt;code&gt;OR REPLACE&lt;/code&gt; clause.</source>
          <target state="translated">때 &lt;code&gt;IF NOT EXISTS&lt;/code&gt; 절은 사용되는 지정된 역할이 이미 존재하는 경우, MariaDB는 오류 대신 경고를 반환합니다. &lt;code&gt;OR REPLACE&lt;/code&gt; 절 과 함께 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="3cfbb1a295f70b157d14957dd1a3fc2e8ff65b4c" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;IF NOT EXISTS&lt;/code&gt; clause is used, MariaDB will return a warning instead of an error if the specified user already exists.</source>
          <target state="translated">때 &lt;code&gt;IF NOT EXISTS&lt;/code&gt; 절은 사용되는 지정된 사용자가 이미 존재하는 경우, MariaDB는 오류 대신 경고를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5370f0d46288c008f24ccf43a3efeb464a5dbfca" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;INPLACE&lt;/code&gt; algorithm is used, the underlying storage engine uses optimizations to perform the operation while avoiding the table copy and rebuild. However, &lt;code&gt;INPLACE&lt;/code&gt; is a bit of a misnomer, since some operations may still require the table to be rebuilt for some storage engines. Regardless, several operations can be performed without a full copy of the table for some storage engines.</source>
          <target state="translated">때 &lt;code&gt;INPLACE&lt;/code&gt; 의 알고리즘을 사용하고, 기본 스토리지 엔진은 테이블 복사본을 방지하면서 작업을 수행하고 다시 최적화를 사용한다. 그러나 일부 작업에서는 일부 스토리지 엔진에 대해 테이블을 다시 작성해야 할 수도 있기 때문에 &lt;code&gt;INPLACE&lt;/code&gt; 는 약간의 오해입니다. 그럼에도 불구하고 일부 스토리지 엔진에 대한 전체 테이블 사본없이 여러 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04d53440a7508a9130522ec6c38555f0b19781d6" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;MariaDB-server&lt;/code&gt; RPM package is installed, it will create a user and group named &lt;code&gt;mysql&lt;/code&gt;, if it does not already exist.</source>
          <target state="translated">때 &lt;code&gt;MariaDB-server&lt;/code&gt; RPM 패키지가 설치되어, 그것은 사용자 및 그룹 이름이 생성됩니다 &lt;code&gt;mysql&lt;/code&gt; 이미 존재하지 않는 경우.</target>
        </trans-unit>
        <trans-unit id="33527fd33d86a927c14fce399ddd9a7b1f7445de" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;WAIT FOR ALL SLAVES&lt;/code&gt; option is provided, the server only kills its binary log dump threads after all client threads have been killed, and it only completes the shutdown after the last &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt; has been sent to all connected slaves.</source>
          <target state="translated">때 &lt;code&gt;WAIT FOR ALL SLAVES&lt;/code&gt; 옵션이 제공되며, 모든 클라이언트 스레드가 살해 된 후 서버는 바이너리 로그 덤프 스레드를 죽이고, 그리고 마지막 한 후 종료 완료 &lt;a href=&quot;../binary-log/index&quot;&gt;바이너리 로그가&lt;/a&gt; 연결된 모든 슬레이브로 전송되었습니다.</target>
        </trans-unit>
        <trans-unit id="020880351dd1de87bd1a4886dfcb16b1e0a863b9" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;galera_recovery&lt;/code&gt; script runs &lt;code&gt;&lt;a href=&quot;../mysqld-options/index&quot;&gt;mysqld&lt;/a&gt;&lt;/code&gt;, it does not write to the &lt;a href=&quot;../error-log/index&quot;&gt;error log&lt;/a&gt;. Instead, it redirects &lt;code&gt;&lt;a href=&quot;../mysqld-options/index&quot;&gt;mysqld&lt;/a&gt;&lt;/code&gt; log output to a file named with the format &lt;code&gt;/tmp/wsrep_recovery.XXXXXX&lt;/code&gt;, where &lt;code&gt;XXXXXX&lt;/code&gt; is replaced with random characters.</source>
          <target state="translated">때 &lt;code&gt;galera_recovery&lt;/code&gt; 의 스크립트가 실행 &lt;code&gt;&lt;a href=&quot;../mysqld-options/index&quot;&gt;mysqld&lt;/a&gt;&lt;/code&gt; 를을 , 그것은에 기록하지 않는 &lt;a href=&quot;../error-log/index&quot;&gt;오류 로그&lt;/a&gt; . 대신 &lt;code&gt;&lt;a href=&quot;../mysqld-options/index&quot;&gt;mysqld&lt;/a&gt;&lt;/code&gt; 로그 출력을 &lt;code&gt;/tmp/wsrep_recovery.XXXXXX&lt;/code&gt; 형식으로 이름이 지정된 파일로 리디렉션 합니다 . 여기서 &lt;code&gt;XXXXXX&lt;/code&gt; 는 임의의 문자로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="74d1d5fb317365b9f2d6cd9c84ab04a9927e2b92" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;mariadb-server&lt;/code&gt; DEB package is installed, it will create a user and group named &lt;code&gt;mysql&lt;/code&gt;, if they do not already exist.</source>
          <target state="translated">때 &lt;code&gt;mariadb-server&lt;/code&gt; DEB 패키지가 설치, 그것은 사용자 및 그룹 이름이 생성됩니다 &lt;code&gt;mysql&lt;/code&gt; 이미 존재하지 않는 경우.</target>
        </trans-unit>
        <trans-unit id="1678b3e6b5c21010123003f121ae5698b78e78f0" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;no-threads&lt;/code&gt; mode is enabled, the server uses a single thread for all client connections, which is really only usable for debugging.</source>
          <target state="translated">때 &lt;code&gt;no-threads&lt;/code&gt; 모드가 활성화되어, 서버는 디버깅 정말에만 사용할 수있는 모든 클라이언트 연결을위한 단일 스레드를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="528a1721a1756ae85187238a29e5be4e6a76b1fc" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;plugin&lt;/code&gt; column is empty, MariaDB defaults to authenticating accounts with either the &lt;code&gt;&lt;a href=&quot;../authentication-plugin-mysql_native_password/index&quot;&gt;mysql_native_password&lt;/a&gt;&lt;/code&gt; or the &lt;code&gt;&lt;a href=&quot;../authentication-plugin-mysql_old_password/index&quot;&gt;mysql_old_password&lt;/a&gt;&lt;/code&gt; plugins. It decides which based on the hash used in the value for the &lt;code&gt;Password&lt;/code&gt; column. When there's no password set or when the 4.1 password hash is used, (which is 41 characters long), MariaDB uses the &lt;code&gt;&lt;a href=&quot;../authentication-plugin-mysql_native_password/index&quot;&gt;mysql_native_password&lt;/a&gt;&lt;/code&gt; plugin. The &lt;code&gt;&lt;a href=&quot;../authentication-plugin-mysql_old_password/index&quot;&gt;mysql_old_password&lt;/a&gt;&lt;/code&gt; plugin is used with pre-4.1 password hashes, (which are 16 characters long).</source>
          <target state="translated">때 &lt;code&gt;plugin&lt;/code&gt; 열이 비어 인증에 MariaDB 기본값은 하나와 계정 &lt;code&gt;&lt;a href=&quot;../authentication-plugin-mysql_native_password/index&quot;&gt;mysql_native_password&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../authentication-plugin-mysql_old_password/index&quot;&gt;mysql_old_password&lt;/a&gt;&lt;/code&gt; 의 플러그인. &lt;code&gt;Password&lt;/code&gt; 열의 값에 사용 된 해시를 기반으로 결정 합니다. 비밀번호가 설정되어 있지 않거나 4.1 비밀번호 해시 (41 자 길이)를 사용하는 경우 MariaDB는 &lt;code&gt;&lt;a href=&quot;../authentication-plugin-mysql_native_password/index&quot;&gt;mysql_native_password&lt;/a&gt;&lt;/code&gt; 플러그인을 사용합니다 . &lt;code&gt;&lt;a href=&quot;../authentication-plugin-mysql_old_password/index&quot;&gt;mysql_old_password&lt;/a&gt;&lt;/code&gt; 의 플러그인 (16 자 길이) 4.1 이전 암호 해시와 함께 사용된다.</target>
        </trans-unit>
        <trans-unit id="0a34b803719602ba0161e22e9b69f37b653aa2b2" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;pool-of-threads&lt;/code&gt; mode is enabled, the server uses the &lt;a href=&quot;../thread-pool-in-mariadb/index&quot;&gt;thread pool&lt;/a&gt; for client connections.</source>
          <target state="translated">때 &lt;code&gt;pool-of-threads&lt;/code&gt; 모드가 활성화되어, 서버가 사용하는 &lt;a href=&quot;../thread-pool-in-mariadb/index&quot;&gt;스레드 풀&lt;/a&gt; 클라이언트 연결을.</target>
        </trans-unit>
        <trans-unit id="39fc28c9c8280daeb5e2bbb287dff296b66d1f5f" translate="yes" xml:space="preserve">
          <source>When the IF NOT EXISTS clause is used, MariaDB will return a warning instead of an error if the specified function already exists. Cannot be used together with OR REPLACE.</source>
          <target state="translated">IF NOT EXISTS 절을 사용하면 지정된 함수가 이미 존재하는 경우 MariaDB는 오류 대신 경고를 반환합니다. OR REPLACE와 함께 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="fae38416b8ff42cee4b1eabbc009ab346c329dd6" translate="yes" xml:space="preserve">
          <source>When the IF NOT EXISTS clause is used, MariaDB will return a warning instead of an error if the specified view already exists. Cannot be used together with the &lt;code&gt;OR REPLACE&lt;/code&gt; clause.</source>
          <target state="translated">IF NOT EXISTS 절을 사용하면 지정된 뷰가 이미 존재하는 경우 MariaDB는 오류 대신 경고를 반환합니다. &lt;code&gt;OR REPLACE&lt;/code&gt; 절 과 함께 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="4d3db030ea30fe7599271b0f11081c07cc27704c" translate="yes" xml:space="preserve">
          <source>When the InnoDB plugin is compiled, the innodb_plugin test suite will test the InnoDB plugin in addition to xtradb:</source>
          <target state="translated">InnoDB 플러그인이 컴파일되면 innodb_plugin 테스트 스위트는 xtradb 외에도 InnoDB 플러그인을 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="dd3ff6da3b57d4ffa3df196e1d7a8ab1f587330c" translate="yes" xml:space="preserve">
          <source>When the MariaDB Server or clients and utilities are dynamically linked to the system's &lt;a href=&quot;https://www.openssl.org/&quot;&gt;OpenSSL&lt;/a&gt; library, it makes it very easy to update the libraries. The information below will show how to update these libraries for each platform.</source>
          <target state="translated">MariaDB 서버 또는 클라이언트 및 유틸리티가 시스템의 &lt;a href=&quot;https://www.openssl.org/&quot;&gt;OpenSSL&lt;/a&gt; 라이브러리에 동적으로 연결 되면 라이브러리를 매우 쉽게 업데이트 할 수 있습니다. 아래 정보는 각 플랫폼에 대해 이러한 라이브러리를 업데이트하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="828849a54061985d15ce7cdb9bb7e59b8b669705" translate="yes" xml:space="preserve">
          <source>When the MariaDB Server process is started with a service manager, you have the ability to tell the service manager to start the server process on boot. The way that this is done would depend on the specific service manager being used.</source>
          <target state="translated">MariaDB 서버 프로세스가 서비스 관리자로 시작되면 서비스 관리자에게 부팅시 서버 프로세스를 시작하도록 지시 할 수 있습니다. 이를 수행하는 방법은 사용중인 특정 서비스 관리자에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="e0589791b5f36058177bacdf8d10bb571c1fce8e" translate="yes" xml:space="preserve">
          <source>When the MariaDB Server starts, it initializes the partition. Don't create or change any data, (any data written to InnoDB at this stage will be lost on restart). Once the server has successful started, stop it then edit the configuration file again, changing the &lt;code&gt;newraw&lt;/code&gt; keyword to &lt;code&gt;raw&lt;/code&gt;.</source>
          <target state="translated">MariaDB 서버가 시작되면 파티션을 초기화합니다. 데이터를 생성하거나 변경하지 마십시오 (이 단계에서 InnoDB에 기록 된 모든 데이터는 재시작시 손실 됨). 서버가 성공적으로 시작되면 서버를 중지 한 다음 구성 파일을 다시 편집하여 &lt;code&gt;newraw&lt;/code&gt; 키워드를 &lt;code&gt;raw&lt;/code&gt; 로 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="d438a5c62d0bf990c313e678532bd6d036b16839" translate="yes" xml:space="preserve">
          <source>When the MaxScale server streams data to MariaDB ColumnStore it retrieves it from the master server using the same process that the slaves use in MariaDB Replication. In effect it operates as a replication slave, only instead of writing data locally, it streams the writes to the ColumnStore User Modules.</source>
          <target state="translated">MaxScale 서버는 MariaDB ColumnStore로 데이터를 스트리밍 할 때 슬레이브가 MariaDB Replication에서 사용하는 것과 동일한 프로세스를 사용하여 마스터 서버에서 데이터를 검색합니다. 실제로 로컬로 데이터를 쓰지 않고 복제 슬레이브로 작동하여 쓰기를 ColumnStore 사용자 모듈로 스트리밍합니다.</target>
        </trans-unit>
        <trans-unit id="2affe6278da58ef68ad6d2ae933fbfcdce693026" translate="yes" xml:space="preserve">
          <source>When the Performance Module runs on a dedicated server, you can dedicate the majority of the available to this data cache. As the Performance Module cache is shared nothing design:</source>
          <target state="translated">성능 모듈이 전용 서버에서 실행될 때이 데이터 캐시에 사용 가능한 대부분을 전용 할 수 있습니다. 성능 모듈 캐시는 아무 것도 공유하지 않으므로</target>
        </trans-unit>
        <trans-unit id="66b264afe2375811871a44df74056e405f148304" translate="yes" xml:space="preserve">
          <source>When the Performance Schema looks for matches in the &lt;code&gt;setup_objects&lt;/code&gt;, there may be more than one row matching, with different &lt;code&gt;ENABLED&lt;/code&gt; and &lt;code&gt;TIMED&lt;/code&gt; values. It looks for the most specific matches first, that is, it will first look for the specific database and table name combination, then the specific database, only then falling back to a wildcard for both.</source>
          <target state="translated">성능 스키마가 &lt;code&gt;setup_objects&lt;/code&gt; 에서 일치 항목을 찾을 때 서로 다른 &lt;code&gt;ENABLED&lt;/code&gt; 및 &lt;code&gt;TIMED&lt;/code&gt; 값으로 일치하는 둘 이상의 행이있을 수 있습니다 . 가장 구체적인 일치 항목을 먼저 찾습니다. 즉, 먼저 특정 데이터베이스와 테이블 이름 조합을 찾은 다음 특정 데이터베이스를 찾은 다음 두 개 모두에 대해 와일드 카드로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="ce25204d45a304d39f2144cd9000ffa8de0434d2" translate="yes" xml:space="preserve">
          <source>When the Thread Pool is Less Efficient</source>
          <target state="translated">스레드 풀의 효율성이 떨어질 때</target>
        </trans-unit>
        <trans-unit id="e6e4014b32ee87175e5da6b6ebb1d2f787839c45" translate="yes" xml:space="preserve">
          <source>When the XPath value is invalid, it generates an Error 1105:</source>
          <target state="translated">XPath 값이 유효하지 않으면 오류 1105가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="30a8c120b507416f3295eaa6e495138efb0a9662" translate="yes" xml:space="preserve">
          <source>When the backup is complete, it executes the following &lt;code&gt;&lt;a href=&quot;../backup-stage/index&quot;&gt;BACKUP STAGE&lt;/a&gt;&lt;/code&gt; command to unlock the database:</source>
          <target state="translated">백업이 완료되면 다음 &lt;code&gt;&lt;a href=&quot;../backup-stage/index&quot;&gt;BACKUP STAGE&lt;/a&gt;&lt;/code&gt; 명령을 실행 하여 데이터베이스를 잠금 해제합니다.</target>
        </trans-unit>
        <trans-unit id="b7eec8d7effa018cfa4bb66248cc8acba79115dd" translate="yes" xml:space="preserve">
          <source>When the connection to the driver is established by the JdbcInterface wrapper class, it uses the options that are provided when creating the CONNECT JDBC tables. Inside the default Java wrapper, the driver&amp;rsquo;s main class is loaded by the DriverManager.getConnection function that takes three arguments:</source>
          <target state="translated">JdbcInterface 랩퍼 클래스가 드라이버에 대한 연결을 설정하면 CONNECT JDBC 테이블을 작성할 때 제공되는 옵션을 사용합니다. 기본 Java 랩퍼 내에서 드라이버의 기본 클래스는 다음 세 가지 인수를 사용하는 DriverManager.getConnection 함수에 의해로드됩니다.</target>
        </trans-unit>
        <trans-unit id="662ab883ed532c6bda3acbf25e99e788d45a992c" translate="yes" xml:space="preserve">
          <source>When the default &lt;code&gt;one-thread-per-connection&lt;/code&gt; mode is enabled, the server uses one thread to handle each client connection.</source>
          <target state="translated">&lt;code&gt;one-thread-per-connection&lt;/code&gt; 기본 모드가 활성화되면 서버는 하나의 스레드를 사용하여 각 클라이언트 연결을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="f26f38d497d0e68bfbf1d757c86151083e47e729" translate="yes" xml:space="preserve">
          <source>When the delete period falls completely within the row period, it splits the row into two rows. The first row runs from the starting row period to the starting delete period. The second runs from the ending delete period to the ending row period.</source>
          <target state="translated">삭제 기간이 행 기간 내에 완전히 들어가면 행이 두 개의 행으로 분할됩니다. 첫 번째 행은 시작 행 기간에서 시작 삭제 기간까지 실행됩니다. 두 번째는 종료 삭제 기간에서 종료 행 기간까지 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="75ff311abfa2afe931d1a31b5fc58d34e57e8909" translate="yes" xml:space="preserve">
          <source>When the desired returned data is directly specified by the SRCDEF option. This is great to let the remote server do most of the job, such as grouping and/or joining tables. This cannot be done with the FEDERATED engine.</source>
          <target state="translated">원하는 리턴 데이터가 SRCDEF 옵션에 의해 직접 지정된 경우. 이는 원격 서버가 그룹화 및 / 또는 테이블 조인과 같은 대부분의 작업을 수행 할 수 있도록하는 데 유용합니다. FEDERATED 엔진으로는 수행 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="46758d4cf6bf21428dea5a2806403f3cd4b8958a" translate="yes" xml:space="preserve">
          <source>When the event was created.</source>
          <target state="translated">이벤트가 작성된 시간</target>
        </trans-unit>
        <trans-unit id="3843fac269922cfdbbebaa4a071bc6194b44eca6" translate="yes" xml:space="preserve">
          <source>When the event was last changed.</source>
          <target state="translated">이벤트가 마지막으로 변경된시기</target>
        </trans-unit>
        <trans-unit id="a9e40ce653d4552d62ab9202bfa855baad5d15cc" translate="yes" xml:space="preserve">
          <source>When the event was last run.</source>
          <target state="translated">이벤트가 마지막으로 실행 된 시간</target>
        </trans-unit>
        <trans-unit id="22d865832c904ec667ef7dd639f1cadf43e27cf2" translate="yes" xml:space="preserve">
          <source>When the execution of a trigger or a stored function begins, it is not possible to use statements which reference a savepoint which was defined from out of that stored program.</source>
          <target state="translated">트리거 또는 저장된 함수의 실행이 시작되면 해당 저장된 프로그램에서 정의 된 저장 점을 참조하는 명령문을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="bf30c2bbdf47448e6dc5d4e072992f3187c625d5" translate="yes" xml:space="preserve">
          <source>When the failed Performance Module is brought back online, ColumnStore auto-adopts it back into the configuration and begins using it for work.</source>
          <target state="translated">실패한 성능 모듈이 다시 온라인 상태가되면 ColumnStore는이를 자동으로 구성에 채택하여 작업에 사용하기 시작합니다.</target>
        </trans-unit>
        <trans-unit id="2f4f9b834932142d60ca1b6a9a740611263f7661" translate="yes" xml:space="preserve">
          <source>When the history is stored together with the current data, it increases the size of the table, so current data queries &amp;mdash; table scans and index searches &amp;mdash; will take more time, because they will need to skip over historical data. If most queries on that table use only current data, it might make sense to store the history separately, to reduce the overhead from versioning.</source>
          <target state="translated">히스토리가 현재 데이터와 함께 저장되면 테이블 크기가 커지므로 현재 데이터 쿼리 (테이블 스캔 및 인덱스 검색)는 히스토리 데이터를 건너 뛰어야하므로 시간이 더 걸립니다. 해당 테이블의 대부분의 쿼리가 현재 데이터 만 사용하는 경우 버전 관리의 오버 헤드를 줄이기 위해 기록을 별도로 저장하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d9a10a2cffb75e793fec6c0c82792197416f5e00" translate="yes" xml:space="preserve">
          <source>When the join is over an expression. The SQL statement:</source>
          <target state="translated">조인이 표현식 위에있을 때. SQL 문 :</target>
        </trans-unit>
        <trans-unit id="a4f3a72a667e004dcd3b0ddac346726631f08b6a" translate="yes" xml:space="preserve">
          <source>When the join memory limit is exceeded, a disk-based join will be used for processing if this option has been enabled.</source>
          <target state="translated">결합 메모리 한계를 초과하면이 옵션이 사용 가능한 경우 디스크 기반 결합이 처리에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="76bfe770c5d50f710db970ba01b2a0466cce4048" translate="yes" xml:space="preserve">
          <source>When the local and cluster UUID's come into sync, the node is again online and functioning as a part of the cluster.</source>
          <target state="translated">로컬 및 클러스터 UUID가 동기화되면 노드가 다시 온라인 상태가되어 클러스터의 일부로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="74096fa9a15a00a04562e8025793dc7b9eb21057" translate="yes" xml:space="preserve">
          <source>When the master is a newer version with checksums enabled in the binlog, but the slave is an old version that does not understand checksums, replication will fail. The master will disconnect the slave with an error, and also log a warning in its own error log. This prevents sending events to the slave that it will be unable to interpret correctly, but means that binlog checksums can not be used with older slaves. (With the recommended upgrade path, where slaves are upgraded before masters, this is not a problem of course).</source>
          <target state="translated">마스터가 binlog에서 체크섬을 사용할 수있는 최신 버전이지만 슬레이브가 체크섬을 이해하지 못하는 이전 버전 인 경우 복제가 실패합니다. 마스터는 오류와 함께 슬레이브 연결을 끊고 자체 오류 로그에 경고를 기록합니다. 이렇게하면 올바르게 해석 할 수없는 슬레이브로 이벤트를 보내지 못하지만 오래된 슬레이브에서는 binlog 체크섬을 사용할 수 없습니다. (마스터 전에 슬레이브를 업그레이드하는 권장 업그레이드 경로를 사용하는 것은 물론 문제가되지 않습니다).</target>
        </trans-unit>
        <trans-unit id="518f697ddd7343e69541bb33a0efdf729dbbba8d" translate="yes" xml:space="preserve">
          <source>When the number of &lt;a href=&quot;../server-status-variables/index#threads_connected&quot;&gt;threads_connected&lt;/a&gt; exceeds the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#max_connections&quot;&gt;max_connections&lt;/a&gt;&lt;/code&gt; server variable, it's time to make a change. Viewing the &lt;a href=&quot;../server-status-variables/index#threads_connected&quot;&gt;threads_connected&lt;/a&gt; status variable shows only the current number of connections, but it's more useful to see what the value has peaked at, and this is shown by the &lt;a href=&quot;../server-status-variables/index#max_used_connections&quot;&gt;max_used_connections&lt;/a&gt; status variable.</source>
          <target state="translated">수 때 &lt;a href=&quot;../server-status-variables/index#threads_connected&quot;&gt;threads_connected가&lt;/a&gt; 초과 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#max_connections&quot;&gt;max_connections&lt;/a&gt;&lt;/code&gt; 서버 변수를, 그것의 시간 변화를 확인합니다. 보기 &lt;a href=&quot;../server-status-variables/index#threads_connected&quot;&gt;threads_connected&lt;/a&gt; 상태 변수 쇼에게 연결의 현재 수를하지만, 값이 정점으로하고 있으며,이은에 의해 표시되는 내용을 참조하는 것이 더 유용 &lt;a href=&quot;../server-status-variables/index#max_used_connections&quot;&gt;max_used_connections의&lt;/a&gt; 상태 변수입니다.</target>
        </trans-unit>
        <trans-unit id="cb90c08e4fe9eecf79306ab603a199aff62eb4f1" translate="yes" xml:space="preserve">
          <source>When the number of lines retrieved for a table is more than this maximum, a warning is issued by CONNECT. This is mainly prone to occur with columns (and also tables) with some data sources having many tables when the table name is not specified.</source>
          <target state="translated">테이블에 대해 검색된 행 수가이 최대 값을 초과하면 CONNECT가 경고를 발행합니다. 이는 주로 테이블 이름이 지정되지 않은 경우 테이블이 많은 일부 데이터 소스에서 열 (및 테이블)에서 발생하기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="889489e08b3c0782f1b902106041cc9fa0c229d7" translate="yes" xml:space="preserve">
          <source>When the original &lt;em&gt;children&lt;/em&gt; field is void, what happens depends on the NULL specification of the &quot;multiple&quot; column. If it is nullable, like here, a void string will generate a NULL value. However, if the column is not nullable, no row will be generated at all.</source>
          <target state="translated">원래 &lt;em&gt;자식&lt;/em&gt; 필드가 비어 있으면 &quot;복수&quot;열의 NULL 사양에 따라 달라집니다. 여기에서와 같이 널 입력 가능하면 void 문자열은 NULL 값을 생성합니다. 그러나 열이 널 입력 가능하지 않으면 행이 전혀 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dd90bfec2184fe19b44b696e9537eb59234dc586" translate="yes" xml:space="preserve">
          <source>When the outermost statement is not a query. The SQL statement:</source>
          <target state="translated">가장 바깥 쪽 명령문이 쿼리가 아닌 경우 SQL 문 :</target>
        </trans-unit>
        <trans-unit id="c95c168184369a0f8439b4a8ebe6ceb9bd14409e" translate="yes" xml:space="preserve">
          <source>When the plugin is installed and enabled, you will see:</source>
          <target state="translated">플러그인이 설치 및 활성화되면 다음이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="886f76503e6da595db8113bbb093e10689928ef2" translate="yes" xml:space="preserve">
          <source>When the precedence of operators is not intuitive, you can use parentheses to make it immediately clear for whoever reads the statement.</source>
          <target state="translated">연산자의 우선 순위가 직관적이지 않은 경우 괄호를 사용하여 명령문을 읽는 사람에게 즉시 명확하게 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48ee313ce573a7370f307a5a3d57a94b4287ba23" translate="yes" xml:space="preserve">
          <source>When the procedure returns, a client program can also obtain the number of rows affected for the final statement executed within the routine: At the SQL level, call the &lt;code&gt;&lt;a href=&quot;../row_count/index&quot;&gt;ROW_COUNT()&lt;/a&gt;&lt;/code&gt; function; from the C API, call the &lt;code&gt;mysql_affected_rows()&lt;/code&gt; function.</source>
          <target state="translated">프로 시저가 리턴되면 클라이언트 프로그램은 루틴 내에서 실행 된 최종 명령문에 영향을받는 행 수를 얻을 수도 있습니다. SQL 레벨에서 &lt;code&gt;&lt;a href=&quot;../row_count/index&quot;&gt;ROW_COUNT()&lt;/a&gt;&lt;/code&gt; 함수를 호출하십시오 . C API에서 &lt;code&gt;mysql_affected_rows()&lt;/code&gt; 함수를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="a88ea5692a89366722945d2f9db6d87b4429ac8a" translate="yes" xml:space="preserve">
          <source>When the query cache is enabled and a new SELECT query is processed, the query cache is examined to see if the query appears in the cache.</source>
          <target state="translated">쿼리 캐시가 활성화되고 새 SELECT 쿼리가 처리되면 쿼리 캐시가 검사되어 쿼리가 캐시에 나타나는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="fdf6ab097302ab4bf58bd9cf7503370305137d69" translate="yes" xml:space="preserve">
          <source>When the routine is invoked, an implicit USE db_name is performed (and undone when the routine terminates). The causes the routine to have the given default database while it executes. USE statements within stored routines are disallowed.</source>
          <target state="translated">루틴이 호출되면 내재 된 USE db_name이 수행되고 루틴이 종료되면 실행 취소됩니다. 루틴이 실행되는 동안 루틴이 지정된 기본 데이터베이스를 갖도록합니다. 저장된 루틴 내의 USE 문은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f6c0f6a98e2821d4bbd674cd46cbe40ee9267f7c" translate="yes" xml:space="preserve">
          <source>When the row period falls completely within the delete period, it removes the row.</source>
          <target state="translated">행 기간이 삭제 기간 내에 완전히 들어가면 행이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="356224e2c7eabbd0e9938b2966d77ff7021d9a5a" translate="yes" xml:space="preserve">
          <source>When the row period overlaps the delete period, it shrinks the row, removing the overlap from the first or second row period value.</source>
          <target state="translated">행 기간이 삭제 기간과 겹치면 행을 축소하여 첫 번째 또는 두 번째 행 기간 값에서 겹침을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="a262f06b7504977d2cc644d3428b0dbb8fd452fd" translate="yes" xml:space="preserve">
          <source>When the scan of the table t2 is finished a new portion of the records of the first operand fills the buffer and matches for these records are looked for in t2.</source>
          <target state="translated">테이블 t2의 스캔이 완료되면 첫 번째 피연산자 레코드의 새 부분이 버퍼를 채우고 t2에서 이러한 레코드에 대한 일치를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="8b3713413d19ce1e9c930e34b7b72391cd1260cf" translate="yes" xml:space="preserve">
          <source>When the server shuts down, it executes the deinitialization function for each plugin that is loaded so that the plugin has a chance to perform any final cleanup.</source>
          <target state="translated">서버가 종료되면 플러그인은 최종 정리를 수행 할 수 있도록로드 된 각 플러그인에 대해 초기화 해제 기능을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="be2973a723901150f695dc058e9fc2b25a669109" translate="yes" xml:space="preserve">
          <source>When the server starts, the buffer pool is empty. As it starts to access data, the buffer pool will slowly be populated. As more data will be accessed, the most frequently accessed data will be put into the buffer pool, and old data may be evicted. This means that a certain period of time is necessary before the buffer pool is really useful. This period of time is called the warmup.</source>
          <target state="translated">서버가 시작되면 버퍼 풀이 비어 있습니다. 데이터에 액세스하기 시작하면 버퍼 풀이 천천히 채워집니다. 더 많은 데이터에 액세스할수록 가장 자주 액세스하는 데이터가 버퍼 풀에 저장되고 오래된 데이터가 제거 될 수 있습니다. 이는 버퍼 풀이 실제로 유용하기 전에 일정 시간이 필요하다는 것을 의미합니다. 이 기간을 예열이라고합니다.</target>
        </trans-unit>
        <trans-unit id="b087d19a3cb63d38bad852f12c6059aabc2ae9ed" translate="yes" xml:space="preserve">
          <source>When the slave is delaying the execution of an event due to &lt;code&gt;MASTER_DELAY&lt;/code&gt;, this is the number of seconds of delay remaining before the event will be applied. Otherwise, the value is &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">슬레이브가 &lt;code&gt;MASTER_DELAY&lt;/code&gt; 로 인해 이벤트 실행을 지연시키는 경우 이벤트가 적용되기까지 남은 지연 시간 (초)입니다. 그렇지 않으면 값은 &lt;code&gt;NULL&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4474e4b9c850b8ae000eee177ad48ad385b2cb67" translate="yes" xml:space="preserve">
          <source>When the space allocated to query cache is exhausted, the oldest results will be dropped from the cache.</source>
          <target state="translated">쿼리 캐시에 할당 된 공간이 소진되면 가장 오래된 결과가 캐시에서 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="156aa72781812832b700eb55b0e966c7072a12dc" translate="yes" xml:space="preserve">
          <source>When the statement opens the file, it attempts to read the contents using the default character-set, as defined by the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#character_set_database&quot;&gt;character_set_database&lt;/a&gt;&lt;/code&gt; system variable.</source>
          <target state="translated">명령문이 파일을 열면 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#character_set_database&quot;&gt;character_set_database&lt;/a&gt;&lt;/code&gt; 시스템 변수에 정의 된대로 기본 문자 세트를 사용하여 컨텐츠를 읽으려고 시도 합니다.</target>
        </trans-unit>
        <trans-unit id="a709e2153087212da91597bca5f75efb345078ac" translate="yes" xml:space="preserve">
          <source>When the status of DMLProc goes to ACTIVE from BUSY_INIT (meaning is performing rollbacks), then check to see if the lock still exist.</source>
          <target state="translated">BUSY_INIT에서 DMLProc의 상태가 ACTIVE로 전환되면 (롤백 수행 중) 잠금이 여전히 존재하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="e39250d73ea5c59754b32d0e91c0589b507191f6" translate="yes" xml:space="preserve">
          <source>When the sub-table is a view or not a CONNECT table, CONNECT internally creates a temporary CONNECT table of &lt;a href=&quot;../connect-table-types-mysql-table-type-accessing-mysqlmariadb-tables/index&quot;&gt;MYSQL&lt;/a&gt; type to access it. This connection uses the same default parameters as for a &lt;code&gt;MYSQL&lt;/code&gt; table. It is also possible to specify them to the &lt;code&gt;PROXY&lt;/code&gt; table using in the &lt;code&gt;PROXY&lt;/code&gt; declaration the same &lt;code&gt;OPTION_LIST&lt;/code&gt; options as for a &lt;code&gt;MYSQL&lt;/code&gt; table. Of course, it is simpler and more natural to use directly the MYSQL type in this case.</source>
          <target state="translated">서브 테이블이 CONNECT 테이블이 아니거나 뷰인 경우, CONNECT는 내부적으로 &lt;a href=&quot;../connect-table-types-mysql-table-type-accessing-mysqlmariadb-tables/index&quot;&gt;MYSQL&lt;/a&gt; 유형 의 임시 CONNECT 테이블을 작성 하여 액세스합니다. 이 연결은 &lt;code&gt;MYSQL&lt;/code&gt; 테이블 과 동일한 기본 매개 변수를 사용 합니다. &lt;code&gt;PROXY&lt;/code&gt; 선언에서 &lt;code&gt;MYSQL&lt;/code&gt; 테이블 과 동일한 &lt;code&gt;OPTION_LIST&lt;/code&gt; 옵션을 사용하여 &lt;code&gt;PROXY&lt;/code&gt; 테이블에 이를 지정할 수도 있습니다 . 물론,이 경우 MYSQL 유형을 직접 사용하는 것이 더 간단하고 더 자연 스럽습니다.</target>
        </trans-unit>
        <trans-unit id="167e1d92adffcdbce784abe7c6acb3f99a1c200f" translate="yes" xml:space="preserve">
          <source>When the sub-tables are located on different servers, it is possible to execute the remote queries simultaneously instead of sequentially. To enable this, set the thread option to yes.</source>
          <target state="translated">서브 테이블이 다른 서버에있는 경우 순차적 대신 원격 쿼리를 동시에 실행할 수 있습니다. 이를 사용하려면 스레드 옵션을 예로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="ceb0b1a320384097569c35574af3cffcf67fa938" translate="yes" xml:space="preserve">
          <source>When the subquery returns no results, the evaluation is still true:</source>
          <target state="translated">부속 조회가 결과를 리턴하지 않더라도 평가는 여전히 참입니다.</target>
        </trans-unit>
        <trans-unit id="e1a4fd4b1784d0c0716fd8ea5707057e18c51074" translate="yes" xml:space="preserve">
          <source>When the syncing is done the page is moved to a pool and an active page becomes &quot;syncing&quot;.</source>
          <target state="translated">동기화가 완료되면 페이지가 풀로 이동되고 활성 페이지가 &quot;동기화&quot;됩니다.</target>
        </trans-unit>
        <trans-unit id="3194e09ddb9c95a8c494beaa4c81ee4ef45413a7" translate="yes" xml:space="preserve">
          <source>When the table file or files are compressed in one or several zip files.</source>
          <target state="translated">테이블 파일이 하나 이상의 zip 파일로 압축 된 경우</target>
        </trans-unit>
        <trans-unit id="00c217e0144f2a8ff0c0021caa24294fed3534db" translate="yes" xml:space="preserve">
          <source>When the table is sufficiently big, each table record read will need to actually go to disk (and be served from buffer pool or OS cache), and query execution will be too slow to be practical. For example, a 10,000 RPM disk drive is able to make 167 seeks per second, so in the worst case, query execution will be capped at reading about 167 records per second.</source>
          <target state="translated">테이블이 충분히 크면 각 테이블 레코드 읽기는 실제로 디스크로 이동해야하고 버퍼 풀 또는 OS 캐시에서 제공되어야하며 쿼리 실행이 너무 느려 실용적이지 않습니다. 예를 들어, 10,000RPM 디스크 드라이브는 초당 167 개의 탐색을 수행 할 수 있으므로 최악의 경우 초당 약 167 개의 레코드를 읽을 때 쿼리 실행이 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="1b0651af4bcd68b940b127b92ea4b9ca97778d76" translate="yes" xml:space="preserve">
          <source>When the table will be used by a &lt;a href=&quot;../connect-table-types-tbl-table-type-table-list/index&quot;&gt;TBL&lt;/a&gt; table. This enables you to specify the connection parameters for each sub-table and is more efficient than using a local FEDERATED sub-table.</source>
          <target state="translated">&lt;a href=&quot;../connect-table-types-tbl-table-type-table-list/index&quot;&gt;TBL&lt;/a&gt; 테이블에서 테이블을 사용하는시기 이를 통해 각 서브 테이블에 대한 연결 매개 변수를 지정할 수 있으며 로컬 FEDERATED 서브 테이블을 사용하는 것보다 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="9da3f76ebd6b26a18773028b3c87bfff9678ba45" translate="yes" xml:space="preserve">
          <source>When the user creates a temporary table using the &lt;code&gt;&lt;a href=&quot;../create-table/index&quot;&gt;CREATE TEMPORARY TABLE&lt;/a&gt;&lt;/code&gt; statement and the engine is set as InnoDB, MariaDB creates a temporary tablespace file. When the table is not compressed, MariaDB writes to a shared temporary tablespace as defined by the &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_temp_data_file_path&quot;&gt;innodb_temp_data_file_path&lt;/a&gt;&lt;/code&gt; system variable. When compressed, the temporary table is written to a dedicated temporary tablespace for that table. MariaDB deletes temporary tablespaces when the server shuts down gracefully and is recreated when it starts again. It cannot be placed on a raw device.</source>
          <target state="translated">사용자가 &lt;code&gt;&lt;a href=&quot;../create-table/index&quot;&gt;CREATE TEMPORARY TABLE&lt;/a&gt;&lt;/code&gt; 문을 사용하여 임시 테이블을 작성하고 엔진이 InnoDB로 설정된 경우 MariaDB는 임시 테이블 스페이스 파일을 작성합니다. 테이블이 압축되지 않으면 MariaDB는 &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_temp_data_file_path&quot;&gt;innodb_temp_data_file_path&lt;/a&gt;&lt;/code&gt; 시스템 변수에 정의 된대로 공유 임시 테이블 스페이스에 씁니다 . 압축되면 임시 테이블이 해당 테이블의 전용 임시 테이블 스페이스에 기록됩니다. MariaDB는 서버가 정상적으로 종료 될 때 임시 테이블 스페이스를 삭제하고 다시 시작할 때 다시 작성됩니다. 원시 장치에 배치 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f25bbc242b90f0452dc7f4f8a40352115857efd2" translate="yes" xml:space="preserve">
          <source>When the user issuing the statement does not have privileges on the routine, attempting to &lt;code&gt;&lt;a href=&quot;../call/index&quot;&gt;CALL&lt;/a&gt;&lt;/code&gt; the procedure raises Error 1370.</source>
          <target state="translated">명령문을 발행 한 사용자에게 루틴에 대한 권한이없는 경우 &lt;code&gt;&lt;a href=&quot;../call/index&quot;&gt;CALL&lt;/a&gt;&lt;/code&gt; 시도 하면 오류 1370이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="82198803da50d84b179c83c714e89ff04d023fcc" translate="yes" xml:space="preserve">
          <source>When the value is set to &lt;code&gt;2&lt;/code&gt;, InnoDB performs an unclean shutdown, so it will need the &lt;a href=&quot;../innodb-redo-log/index&quot;&gt;Redo Log&lt;/a&gt; at the next server startup. Ensure that the variable is set to &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt;, or &lt;code&gt;3&lt;/code&gt;. For performance reasons, &lt;code&gt;1&lt;/code&gt; is usually the best option. It can be changed dynamically with &lt;code&gt;&lt;a href=&quot;../set/index#global-session&quot;&gt;SET GLOBAL&lt;/a&gt;&lt;/code&gt;. For example:</source>
          <target state="translated">값이 &lt;code&gt;2&lt;/code&gt; 로 설정 되면 InnoDB는 비정상 종료를 수행하므로 다음 서버 시작시 &lt;a href=&quot;../innodb-redo-log/index&quot;&gt;다시 실행 로그&lt;/a&gt; 가 필요합니다 . 변수가 &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;1&lt;/code&gt; 또는 &lt;code&gt;3&lt;/code&gt; 으로 설정되어 있는지 확인하십시오 . 성능상의 이유로 일반적으로 &lt;code&gt;1&lt;/code&gt; 이 가장 좋습니다. &lt;code&gt;&lt;a href=&quot;../set/index#global-session&quot;&gt;SET GLOBAL&lt;/a&gt;&lt;/code&gt; 을 사용 하여 동적으로 변경할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="639d84c55831a613b752d8a645b96d6e8e7b3f24" translate="yes" xml:space="preserve">
          <source>When the value of this option is changed, the metadata about the &lt;a href=&quot;../replication-threads/index#slave-sql-thread&quot;&gt;slave's SQL thread's&lt;/a&gt; position in the &lt;a href=&quot;../relay-log/index&quot;&gt;relay logs&lt;/a&gt; will also be changed in the &lt;code&gt;relay-log.info&lt;/code&gt; file or the file that is configured by the &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-system-variables/index#relay_log_info_file&quot;&gt;relay_log_info_file&lt;/a&gt;&lt;/code&gt; system variable.</source>
          <target state="translated">이 옵션의 값이 변경되면 &lt;a href=&quot;../relay-log/index&quot;&gt;릴레이 로그&lt;/a&gt; 에서 &lt;a href=&quot;../replication-threads/index#slave-sql-thread&quot;&gt;슬레이브의 SQL 스레드&lt;/a&gt; 위치에 대한 메타 데이터 도 &lt;code&gt;relay-log.info&lt;/code&gt; 파일 또는 &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-system-variables/index#relay_log_info_file&quot;&gt;relay_log_info_file&lt;/a&gt;&lt;/code&gt; 시스템 변수로 구성된 파일 에서 변경됩니다 .</target>
        </trans-unit>
        <trans-unit id="b7c594c1cdf123a4f28688d9e704f490a2d9c1b7" translate="yes" xml:space="preserve">
          <source>When the variable &lt;code&gt;read_only&lt;/code&gt; is set to 1, no updates are permitted except from users with the SUPER privilege or slave servers updating from a master. Inserting rows to log tables, updates to temporary tables and OPTIMIZE TABLE or ANALYZE TABLE statements are excluded from this limitation.</source>
          <target state="translated">&lt;code&gt;read_only&lt;/code&gt; 변수 가 1로 설정되면 SUPER 권한이있는 사용자 또는 마스터에서 슬레이브 서버 업데이트를 제외하고는 업데이트가 허용되지 않습니다. 로그 테이블에 행 삽입, 임시 테이블 업데이트 및 OPTIMIZE TABLE 또는 ANALYZE TABLE 문은이 제한에서 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="ae120f5ba4fd24908deeef71d3ad392030cc0211" translate="yes" xml:space="preserve">
          <source>When the view query is written to file, MariaDB converts the binary character into a string literal, which causes it to be misinterpreted when you execute the &lt;code&gt;&lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt;&lt;/code&gt; statement. If you encounter this issue, set the character set in the view to force it to the value you want.</source>
          <target state="translated">뷰 쿼리가 파일에 기록 될 때 MariaDB는 이진 문자를 문자열 리터럴로 변환하므로 &lt;code&gt;&lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt;&lt;/code&gt; 문 을 실행할 때이 문자가 잘못 해석됩니다 . 이 문제가 발생하면보기에서 문자 세트를 설정하여 원하는 값으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="2223049e3902e6729b204dbbe6f9b3e1607ada1a" translate="yes" xml:space="preserve">
          <source>When these are filled up (after 32M rows), create 4 more extents in the 4 files created in step 1.</source>
          <target state="translated">32M 행 이후에 채워지면 1 단계에서 작성된 4 개의 파일에서 범위를 4 개 더 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="3244d5fa688d50c6afaa463e8c181d36f57c6ea8" translate="yes" xml:space="preserve">
          <source>When these are filled up (after 64M rows), create a new partition.</source>
          <target state="translated">64M 행 이후에 채워지면 새 파티션을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="44266fdd4283652ccfc93213207d9776243f41d3" translate="yes" xml:space="preserve">
          <source>When this error is encountered, one solution is to explicitly specify a value for the &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-open-files-limit&quot;&gt;open-files-limit&lt;/a&gt;&lt;/code&gt; option either on the command line or in one of the supported &lt;a href=&quot;#server-option-groups&quot;&gt;server option groups&lt;/a&gt; in an &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;option file&lt;/a&gt;. For example:</source>
          <target state="translated">이 오류가 발생하는 경우, 하나 개의 솔루션은 명시 적으로 값을 지정하는 것입니다 &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-open-files-limit&quot;&gt;open-files-limit&lt;/a&gt;&lt;/code&gt; 명령 줄이나 지원 중 하나에 두 가지 옵션을 &lt;a href=&quot;#server-option-groups&quot;&gt;서버 옵션 그룹&lt;/a&gt; 에서 &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;옵션 파일&lt;/a&gt; . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f959dcb6deb6088cc4b1261684b078428b6b43a8" translate="yes" xml:space="preserve">
          <source>When this happen, provide a Java prefix as a hint on where the package was loaded. For instance on Ubuntu I was obliged to enter:</source>
          <target state="translated">이 경우 패키지가로드 된 위치에 대한 힌트로 Java 접 두부를 제공하십시오. 예를 들어 우분투에서는 다음을 입력해야했습니다.</target>
        </trans-unit>
        <trans-unit id="0466ff02c48b3d27e25e199d4f4478fa35d2026c" translate="yes" xml:space="preserve">
          <source>When this issue is occurring on a system running 1.2.2 or earlier, this is a work-around that can be applied.</source>
          <target state="translated">1.2.2 이전 버전을 실행하는 시스템에서이 문제가 발생하면 적용 할 수있는 해결 방법입니다.</target>
        </trans-unit>
        <trans-unit id="22038b35abc6488fae4202f7b8023cd9e9a331f9" translate="yes" xml:space="preserve">
          <source>When this occurs, the &lt;code&gt;&lt;a href=&quot;../semisynchronous-replication-plugin-status-variables/index#rpl_semi_sync_master_status&quot;&gt;Rpl_semi_sync_master_status&lt;/a&gt;&lt;/code&gt; status variable will be switched to &lt;code&gt;OFF&lt;/code&gt;.</source>
          <target state="translated">이 경우 &lt;code&gt;&lt;a href=&quot;../semisynchronous-replication-plugin-status-variables/index#rpl_semi_sync_master_status&quot;&gt;Rpl_semi_sync_master_status&lt;/a&gt;&lt;/code&gt; 상태 변수가 &lt;code&gt;OFF&lt;/code&gt; 로 전환됩니다 .</target>
        </trans-unit>
        <trans-unit id="30a065cdae19a221890750a8ecc694b2117a6455" translate="yes" xml:space="preserve">
          <source>When this occurs, the &lt;code&gt;&lt;a href=&quot;../semisynchronous-replication-plugin-status-variables/index#rpl_semi_sync_master_status&quot;&gt;Rpl_semi_sync_master_status&lt;/a&gt;&lt;/code&gt; status variable will be switched to &lt;code&gt;ON&lt;/code&gt;.</source>
          <target state="translated">이 경우 &lt;code&gt;&lt;a href=&quot;../semisynchronous-replication-plugin-status-variables/index#rpl_semi_sync_master_status&quot;&gt;Rpl_semi_sync_master_status&lt;/a&gt;&lt;/code&gt; 상태 변수가 &lt;code&gt;ON&lt;/code&gt; 으로 전환됩니다 .</target>
        </trans-unit>
        <trans-unit id="eeecc2b1bf27b99314c769b49ab7c522537d0a97" translate="yes" xml:space="preserve">
          <source>When this occurs, you can usually get more information about the cause of the error by following it with a &lt;code&gt;&lt;a href=&quot;../show-warnings/index&quot;&gt;SHOW WARNINGS&lt;/a&gt;&lt;/code&gt; statement.</source>
          <target state="translated">이 경우 일반적으로 &lt;code&gt;&lt;a href=&quot;../show-warnings/index&quot;&gt;SHOW WARNINGS&lt;/a&gt;&lt;/code&gt; 문 을 사용하여 오류의 원인에 대한 자세한 정보를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e1e9777f339fb0f60e907b06a0b174199d922bd6" translate="yes" xml:space="preserve">
          <source>When this operation is performed with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INSTANT&lt;/code&gt;, the tablespace file will have a non-canonical storage format. See &lt;a href=&quot;#non-canonical-storage-format-caused-by-some-operations&quot;&gt;Non-canonical Storage Format Caused by Some Operations&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 을 &lt;code&gt;INSTANT&lt;/code&gt; 로 설정 한 상태 에서이 작업을 수행 하면 테이블 스페이스 파일의 형식이 아닌 스토리지 형식이됩니다. 자세한 정보 &lt;a href=&quot;#non-canonical-storage-format-caused-by-some-operations&quot;&gt;는 일부 조작으로 인한 비정규 스토리지 형식&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f77361f2eca2185cf7e9bb625676c7d4083cb972" translate="yes" xml:space="preserve">
          <source>When this option is specified as true (by YES or 1) the Colist option contains a MongoDB pipeline applying to the table collation. This is a powerful mean for doing things such as expanding arrays like we do with JSON tables. For instance:</source>
          <target state="translated">이 옵션이 true로 지정되면 (YES 또는 1로) Colist 옵션에는 테이블 데이터 정렬에 적용되는 MongoDB 파이프 라인이 포함됩니다. 이것은 JSON 테이블에서와 같이 배열 확장과 같은 작업을 수행하는 강력한 수단입니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="46324f4ebececa82b00f0562eaae42fdc389e370" translate="yes" xml:space="preserve">
          <source>When this option is used with &lt;code&gt;--backup&lt;/code&gt;, if Mariabackup encounters a page that has a non-zero &lt;code&gt;key_version&lt;/code&gt; value, then Mariabackup assumes that the page is encrypted.</source>
          <target state="translated">이 옵션을 &lt;code&gt;--backup&lt;/code&gt; 과 함께 사용 하면 Mariabackup에서 0이 아닌 &lt;code&gt;key_version&lt;/code&gt; 값 을 가진 페이지가 발견되면 Mariabackup은 해당 페이지가 암호화 된 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="bb500ba0dd61deae4e1d1149ca52f7e6fb4a1414" translate="yes" xml:space="preserve">
          <source>When this option is used, Mariabackup creates an additional file called &lt;code&gt;&lt;a href=&quot;../files-created-by-mariabackup/index#xtrabackup_galera_info&quot;&gt;xtrabackup_galera_info&lt;/a&gt;&lt;/code&gt;, which records information about a &lt;a href=&quot;../galera/index&quot;&gt;Galera Cluster&lt;/a&gt; node's state. It records the values of the &lt;code&gt;&lt;a href=&quot;../galera-cluster-status-variables/index#wsrep_local_state_uuid&quot;&gt;wsrep_local_state_uuid&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../galera-cluster-status-variables/index#wsrep_last_committed&quot;&gt;wsrep_last_committed&lt;/a&gt;&lt;/code&gt; status variables.</source>
          <target state="translated">이 옵션을 사용하면, Mariabackup라는 추가 파일 생성 &lt;code&gt;&lt;a href=&quot;../files-created-by-mariabackup/index#xtrabackup_galera_info&quot;&gt;xtrabackup_galera_info&lt;/a&gt;&lt;/code&gt; 약 정보를 기록, &lt;a href=&quot;../galera/index&quot;&gt;갈레 클러스터&lt;/a&gt; 노드의 상태를. &lt;code&gt;&lt;a href=&quot;../galera-cluster-status-variables/index#wsrep_local_state_uuid&quot;&gt;wsrep_local_state_uuid&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../galera-cluster-status-variables/index#wsrep_last_committed&quot;&gt;wsrep_last_committed&lt;/a&gt;&lt;/code&gt; 상태 변수 의 값을 기록합니다 .</target>
        </trans-unit>
        <trans-unit id="72d112bd4e0ed671d6a79c0cac116d2f7b198aa3" translate="yes" xml:space="preserve">
          <source>When this process is complete for all partitions, the target table will contain the imported data:</source>
          <target state="translated">모든 파티션에 대해이 프로세스가 완료되면 대상 테이블에 가져온 데이터가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="6e3d43442a639ac030df0aad6843be69fe4174df" translate="yes" xml:space="preserve">
          <source>When this process is done for one node, move onto the next node.</source>
          <target state="translated">한 노드에 대해이 프로세스가 완료되면 다음 노드로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="138a428bc24d3e320f64460db96cb8675d4c73e6" translate="yes" xml:space="preserve">
          <source>When this query is executed, disk IO access pattern will follow the red line in this figure:</source>
          <target state="translated">이 쿼리가 실행될 때 디스크 IO 액세스 패턴은이 그림의 빨간색 선을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="b5279e74a14a54f912ce9101de166f4aa00f53c5" translate="yes" xml:space="preserve">
          <source>When this system variable is changed, the InnoDB page compression algorithm does not change for existing pages that were already compressed with a different InnoDB page compression algorithm. InnoDB is able to handle this situation without issues, because every page in an InnoDB tablespace contains metadata about the InnoDB page compression algorithm in the page header. This means that InnoDB supports having uncompressed pages and pages compressed with different InnoDB page compression algorithms in the same InnoDB tablespace at the same time.</source>
          <target state="translated">이 시스템 변수가 변경되면 다른 InnoDB 페이지 압축 알고리즘으로 이미 압축 된 기존 페이지에 대해 InnoDB 페이지 압축 알고리즘이 변경되지 않습니다. InnoDB 테이블 스페이스의 모든 페이지에는 페이지 헤더의 InnoDB 페이지 압축 알고리즘에 대한 메타 데이터가 포함되어 있으므로 InnoDB는 이러한 상황을 문제없이 처리 할 수 ​​있습니다. 이는 InnoDB가 동일한 InnoDB 테이블 스페이스에서 다른 InnoDB 페이지 압축 알고리즘으로 압축되지 않은 페이지와 페이지를 동시에 압축하는 것을 지원한다는 의미입니다.</target>
        </trans-unit>
        <trans-unit id="48229ef171ccf15ada7d3e32dfc69a20148a1564" translate="yes" xml:space="preserve">
          <source>When this variable is set to &lt;code&gt;AFTER_COMMIT&lt;/code&gt;, the master performs the following steps:</source>
          <target state="translated">이 변수가 &lt;code&gt;AFTER_COMMIT&lt;/code&gt; 로 설정 되면 마스터는 다음 단계를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="c36cbdd0e9c6c04c3371f843828605716d1719fa" translate="yes" xml:space="preserve">
          <source>When this variable is set to &lt;code&gt;AFTER_SYNC&lt;/code&gt;, the master performs the following steps:</source>
          <target state="translated">이 변수가 &lt;code&gt;AFTER_SYNC&lt;/code&gt; 로 설정 되면 마스터는 다음 단계를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="2364172a5d7e1c0ecb7382c36eee19b89ef46744" translate="yes" xml:space="preserve">
          <source>When to Remove an Index</source>
          <target state="translated">색인을 제거하는시기</target>
        </trans-unit>
        <trans-unit id="365885d11f8e1295db50c1f8f78822733328866b" translate="yes" xml:space="preserve">
          <source>When to Use the Thread Pool</source>
          <target state="translated">스레드 풀을 사용하는시기</target>
        </trans-unit>
        <trans-unit id="8084160b51dfbd672c5e2d505de15df091f22afb" translate="yes" xml:space="preserve">
          <source>When to augment the summary table(s)?</source>
          <target state="translated">요약 테이블을 언제 보강해야합니까?</target>
        </trans-unit>
        <trans-unit id="379d4a11a5f66cb48997f125ef4c93a42b0db016" translate="yes" xml:space="preserve">
          <source>When to do the ALTERs?</source>
          <target state="translated">ALTER를 언제해야합니까?</target>
        </trans-unit>
        <trans-unit id="4cb6af1ae576c542ddecdff3ea4125d59a9ee8e7" translate="yes" xml:space="preserve">
          <source>When to use</source>
          <target state="translated">사용시기</target>
        </trans-unit>
        <trans-unit id="6edd090805e98289c27ac216c56f1423ef527f6a" translate="yes" xml:space="preserve">
          <source>When to use encryption for MariaDB data.</source>
          <target state="translated">MariaDB 데이터에 암호화를 사용하는 경우</target>
        </trans-unit>
        <trans-unit id="080b10fa2960dd6c77232dd9b2e74556071ec702" translate="yes" xml:space="preserve">
          <source>When to use slave_run_triggers_for_rbr</source>
          <target state="translated">slave_run_triggers_for_rbr를 사용하는 경우</target>
        </trans-unit>
        <trans-unit id="a46cb008c0e76380a67c243bfba38c3f2d392da8" translate="yes" xml:space="preserve">
          <source>When to use the Tool:</source>
          <target state="translated">도구 사용시기 :</target>
        </trans-unit>
        <trans-unit id="fbc8257a5e4c0ca8c8453d82eadc5cd276d786e3" translate="yes" xml:space="preserve">
          <source>When too many table locks have been set by write statements, some pending SELECTs are executed. The maximum number of write locks that can be acquired before this happens is determined by the &lt;a href=&quot;../server-system-variables/index#max_write_lock_count&quot;&gt;max_write_lock_count&lt;/a&gt; server system variable, which is dynamic.</source>
          <target state="translated">쓰기 명령문으로 너무 많은 테이블 잠금이 설정되면 보류중인 일부 SELECT가 실행됩니다. 이러한 상황이 발생하기 전에 확보 할 수있는 최대 쓰기 잠금 수 는 동적 인 &lt;a href=&quot;../server-system-variables/index#max_write_lock_count&quot;&gt;max_write_lock_count&lt;/a&gt; 서버 시스템 변수에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="9b7bd3ae898be78d2f8669d355b2d509b507724e" translate="yes" xml:space="preserve">
          <source>When true, indexes are saved in separate files.</source>
          <target state="translated">true 인 경우 인덱스는 별도의 파일로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="a72d5f2cc2ef25cb262df064f415b0982464ee5d" translate="yes" xml:space="preserve">
          <source>When trying to execute an operation which is not allowed for the transaction's current state, an error is produced:</source>
          <target state="translated">트랜잭션의 현재 상태에 허용되지 않는 작업을 실행하려고하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3a5f97481164aa12a105b7e300745ebab24bab3c" translate="yes" xml:space="preserve">
          <source>When two arguments are given, COALESCE() is the same as &lt;a href=&quot;../ifnull/index&quot;&gt;IFNULL()&lt;/a&gt;:</source>
          <target state="translated">두 개의 인수가 제공되면 COALESCE ()는 &lt;a href=&quot;../ifnull/index&quot;&gt;IFNULL ()과&lt;/a&gt; 같습니다.</target>
        </trans-unit>
        <trans-unit id="744fe9d07f400bfe8733e0b5cf14661bb746fa4a" translate="yes" xml:space="preserve">
          <source>When two processes execute the same query, only the last process stores the query result. All other processes increase the &lt;a href=&quot;../server-status-variables/index#qcache_not_cached&quot;&gt;Qcache_not_cached&lt;/a&gt; status variable.</source>
          <target state="translated">두 프로세스가 동일한 쿼리를 실행하면 마지막 프로세스 만 쿼리 결과를 저장합니다. 다른 모든 프로세스는 &lt;a href=&quot;../server-status-variables/index#qcache_not_cached&quot;&gt;Qcache_not_cached&lt;/a&gt; 상태 변수를 증가시킵니다 .</target>
        </trans-unit>
        <trans-unit id="173fcdc3da7c2a54c40a009c4d0158c503d6f620" translate="yes" xml:space="preserve">
          <source>When upgrading between different major versions of MariaDB or MySQL you need to run the &lt;a href=&quot;../mysql_upgrade/index&quot;&gt;mysql_upgrade&lt;/a&gt; program to convert data that are incompatible between versions. This will also update your privilege tables in the mysql database to the latest format.</source>
          <target state="translated">다른 주요 버전의 MariaDB 또는 MySQL간에 업그레이드 할 때 버전 간에 호환되지 않는 데이터를 변환 하려면 &lt;a href=&quot;../mysql_upgrade/index&quot;&gt;mysql_upgrade&lt;/a&gt; 프로그램을 실행해야합니다 . 또한 mysql 데이터베이스의 권한 테이블을 최신 형식으로 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="09e7ef5a6024cafd8ab38bd040f1a979ac894a25" translate="yes" xml:space="preserve">
          <source>When used in a query, the table returns the same file information listing than the system &quot;DIR &lt;code&gt;*.cc&lt;/code&gt;&quot; statement would return if executed in the same current directory (here supposedly ..\)</source>
          <target state="translated">쿼리에서 사용될 때, 테이블 은 동일한 현재 디렉토리 (여기서는 .. \)에서 실행될 경우 시스템 &quot;DIR &lt;code&gt;*.cc&lt;/code&gt; &quot;문이 리턴하는 것과 동일한 파일 정보 목록 을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="ccd6f1275707c587db0fec5487a8578e9158b37d" translate="yes" xml:space="preserve">
          <source>When used in row comparisons these two queries are synonymous and return the same results:</source>
          <target state="translated">행 비교에서 사용될 때이 두 쿼리는 동의어이며 동일한 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="040f0a038f99d8e01680e14d1a3075e8f4392d89" translate="yes" xml:space="preserve">
          <source>When used in row comparisons these two queries return the same results:</source>
          <target state="translated">행 비교에서 사용될 때이 두 쿼리는 동일한 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5e55384439a5f89adb4e88c04521dd045da1ce68" translate="yes" xml:space="preserve">
          <source>When used with partitioned tables, &lt;code&gt;TRUNCATE TABLE&lt;/code&gt; preserves the partitioning; that is, the data and index files are dropped and re-created, while the partition definitions (.par) file is unaffected.</source>
          <target state="translated">분할 된 테이블과 함께 사용될 때 &lt;code&gt;TRUNCATE TABLE&lt;/code&gt; 은 분할을 유지합니다. 즉, 파티션 정의 (.par) 파일은 영향을받지 않지만 데이터 및 인덱스 파일은 삭제되고 다시 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="927a2bd336a093a360657117b33752b1aeda41b8" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt; to change a column's character set, you need to ensure the character sets are compatible with your data. MariaDB will map the data as best it can, but it's possible to lose data if care is not taken.</source>
          <target state="translated">사용하는 경우 &lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE을&lt;/a&gt; 열의 문자 집합을 변경하려면 문자 집합 데이터와 호환 확인해야합니다. MariaDB는 최선을 다해 데이터를 매핑하지만주의를 기울이지 않으면 데이터가 손실 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b10cda75538881285c0075af1cf1aa9e97efb6a" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;../binary-log-formats/index#row-based&quot;&gt;row-based replication&lt;/a&gt;, the value of the &lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#slave_type_conversions&quot;&gt;slave_type_conversions&lt;/a&gt; variable is important. The default value of this variable is empty, in which case MariaDB will not perform attribute promotion or demotion. If the column definitions do not match, replication will stop. If set to &lt;code&gt;ALL_NON_LOSSY&lt;/code&gt;, safe replication is permitted. If set to &lt;code&gt;ALL_LOSSY&lt;/code&gt; as well, replication will be permitted even if data loss takes place.</source>
          <target state="translated">사용하는 경우 &lt;a href=&quot;../binary-log-formats/index#row-based&quot;&gt;행 기반 복제를&lt;/a&gt; ,의 값 &lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#slave_type_conversions&quot;&gt;slave_type_conversions의&lt;/a&gt; 변수는 중요하다. 이 변수의 기본값은 비어 있습니다.이 경우 MariaDB는 속성 승격 또는 수준 내리기를 수행하지 않습니다. 열 정의가 일치하지 않으면 복제가 중지됩니다. &lt;code&gt;ALL_NON_LOSSY&lt;/code&gt; 로 설정하면 안전한 복제가 허용됩니다. &lt;code&gt;ALL_LOSSY&lt;/code&gt; 로 설정 하면 데이터 손실이 발생하더라도 복제가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="0f715e4863a40dbbbd93bad1cb48ef4b08dec876" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;../binary-log-formats/index#statement-based&quot;&gt;statement-based replication&lt;/a&gt;, generally, if a statement can run successfully on the slave, it will be replicated. If a column definition is the same or a larger type on the slave than on the master, it can replicate successfully. For example a column defined as &lt;code&gt;&lt;a href=&quot;../varchar/index&quot;&gt;VARCHAR(10)&lt;/a&gt;&lt;/code&gt; will successfully be replicated on a slave with a definition of &lt;code&gt;VARCHAR(12)&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../binary-log-formats/index#statement-based&quot;&gt;명령문 기반 복제를&lt;/a&gt; 사용할 때 일반적으로 명령문이 슬레이브에서 성공적으로 실행될 수 있으면 복제됩니다. 열 정의가 마스터에서보다 슬레이브에서 동일하거나 큰 유형이면 성공적으로 복제 할 수 있습니다. 예를 들어 &lt;code&gt;&lt;a href=&quot;../varchar/index&quot;&gt;VARCHAR(10)&lt;/a&gt;&lt;/code&gt; 으로 정의 된 컬럼 은 &lt;code&gt;VARCHAR(12)&lt;/code&gt; 정의로 슬레이브에 성공적으로 복제됩니다 .</target>
        </trans-unit>
        <trans-unit id="dfc0dc58782988c19e77802bc7c90a2b84536317" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;../explain/index&quot;&gt;EXPLAIN&lt;/a&gt;, if &lt;code&gt;index_merge&lt;/code&gt; is the plan chosen by the optimizer, it will show up in the &quot;type&quot; column. For example:</source>
          <target state="translated">&lt;a href=&quot;../explain/index&quot;&gt;EXPLAIN을&lt;/a&gt; 사용할 때 &lt;code&gt;index_merge&lt;/code&gt; 가 옵티마이 저가 선택한 계획 인 경우 &quot;type&quot;열에 표시됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8491b62cc285fba3c3a9bdc9cad8adf24127832a" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;../galera/index&quot;&gt;Galera Cluster&lt;/a&gt; with sysVinit, the first node in a cluster has to be started with &lt;code&gt;service mysql bootstrap&lt;/code&gt;. See &lt;a href=&quot;../getting-started-with-mariadb-galera-cluster/index#bootstrapping-a-new-cluster&quot;&gt;Getting Started with MariaDB Galera Cluster: Bootstrapping a New Cluster&lt;/a&gt; for more information.</source>
          <target state="translated">sysVinit와 함께 &lt;a href=&quot;../galera/index&quot;&gt;Galera Cluster&lt;/a&gt; 를 사용 하는 경우 클러스터의 첫 번째 노드는 &lt;code&gt;service mysql bootstrap&lt;/code&gt; 으로 시작해야 합니다 . 자세한 내용 &lt;a href=&quot;../getting-started-with-mariadb-galera-cluster/index#bootstrapping-a-new-cluster&quot;&gt;은 MariaDB Galera 클러스터 시작 : 새 클러스터 부트 스트랩&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="32453f13dfd75767c79f6010c9c668f3fefaeddf" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;../galera/index&quot;&gt;Galera Cluster&lt;/a&gt; with systemd, a node's position in the cluster can be recovered with &lt;code&gt;galera_recovery&lt;/code&gt;. See &lt;a href=&quot;../getting-started-with-mariadb-galera-cluster/index#determining-the-most-advanced-node&quot;&gt;Getting Started with MariaDB Galera Cluster: Determining the Most Advanced Node&lt;/a&gt; for more information.</source>
          <target state="translated">systemd와 함께 &lt;a href=&quot;../galera/index&quot;&gt;Galera Cluster&lt;/a&gt; 를 사용 하는 경우 &lt;code&gt;galera_recovery&lt;/code&gt; 를 사용하여 클러스터의 노드 위치를 복구 할 수 있습니다 . 자세한 내용 &lt;a href=&quot;../getting-started-with-mariadb-galera-cluster/index#determining-the-most-advanced-node&quot;&gt;은 MariaDB Galera 클러스터 시작 : 가장 고급 노드 결정&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b2a3fb517ef244a2113b9e620ce2b19f2a925232" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;../galera/index&quot;&gt;Galera Cluster&lt;/a&gt; with systemd, the first node in a cluster has to be started with &lt;code&gt;galera_new_cluster&lt;/code&gt;. See &lt;a href=&quot;../getting-started-with-mariadb-galera-cluster/index#bootstrapping-a-new-cluster&quot;&gt;Getting Started with MariaDB Galera Cluster: Bootstrapping a New Cluster&lt;/a&gt; for more information.</source>
          <target state="translated">systemd와 함께 &lt;a href=&quot;../galera/index&quot;&gt;Galera Cluster&lt;/a&gt; 를 사용 하는 경우 클러스터의 첫 번째 노드는 &lt;code&gt;galera_new_cluster&lt;/code&gt; 로 시작해야 합니다 . 자세한 내용 &lt;a href=&quot;../getting-started-with-mariadb-galera-cluster/index#bootstrapping-a-new-cluster&quot;&gt;은 MariaDB Galera 클러스터 시작 : 새 클러스터 부트 스트랩&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6769343d3e4d4b264cc04c3d19d9a3a1feb8cec6" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;../multi-source-replication/index&quot;&gt;multi-source replication&lt;/a&gt;, the same GTID position is shared by all slave connections. In this case, different masters should use different replication domains by configuring different &lt;code&gt;&lt;a href=&quot;#gtid_domain_id&quot;&gt;gtid_domain_id&lt;/a&gt;&lt;/code&gt; values. If one master were using a &lt;code&gt;&lt;a href=&quot;#gtid_domain_id&quot;&gt;gtid_domain_id&lt;/a&gt;&lt;/code&gt; value of &lt;code&gt;1&lt;/code&gt;, and if another master were using a &lt;code&gt;&lt;a href=&quot;#gtid_domain_id&quot;&gt;gtid_domain_id&lt;/a&gt;&lt;/code&gt; value of &lt;code&gt;2&lt;/code&gt;, then any slaves replicating from both masters would have GTIDs with both &lt;code&gt;&lt;a href=&quot;#gtid_domain_id&quot;&gt;gtid_domain_id&lt;/a&gt;&lt;/code&gt; values in &lt;code&gt;gtid_slave_pos&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../multi-source-replication/index&quot;&gt;다중 소스 복제를&lt;/a&gt; 사용 하는 경우 모든 슬레이브 연결에서 동일한 GTID 위치를 공유합니다. 이 경우 다른 마스터는 다른 &lt;code&gt;&lt;a href=&quot;#gtid_domain_id&quot;&gt;gtid_domain_id&lt;/a&gt;&lt;/code&gt; 값 을 구성하여 다른 복제 도메인을 사용해야 합니다. 한 마스터가 &lt;code&gt;&lt;a href=&quot;#gtid_domain_id&quot;&gt;gtid_domain_id&lt;/a&gt;&lt;/code&gt; 값 &lt;code&gt;1&lt;/code&gt; 을 사용하고 다른 마스터가 &lt;code&gt;&lt;a href=&quot;#gtid_domain_id&quot;&gt;gtid_domain_id&lt;/a&gt;&lt;/code&gt; 값 &lt;code&gt;2&lt;/code&gt; 를 사용하는 경우 두 마스터에서 복제하는 모든 슬레이브는 gtid_slave_pos의 &lt;code&gt;&lt;a href=&quot;#gtid_domain_id&quot;&gt;gtid_domain_id&lt;/a&gt;&lt;/code&gt; 값 이 모두있는 GTID 를 &lt;code&gt;gtid_slave_pos&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e8388432ca387847355d4715a19311c77234c915" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;--verbose&lt;/code&gt;, &lt;code&gt;aria_s3_copy&lt;/code&gt; will write a dot for each #/79 part of the file copied.</source>
          <target state="translated">사용하는 경우 &lt;code&gt;--verbose&lt;/code&gt; , &lt;code&gt;aria_s3_copy&lt;/code&gt; 는 복사 한 파일의 각 # / 79 부분에 대한 점을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="bb514b94a1ff39db51582ef324128ee702581187" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;DEFAULT&lt;/code&gt; as a value to set in an &lt;code&gt;&lt;a href=&quot;../insert/index&quot;&gt;INSERT&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt;&lt;/code&gt; statement, you can use the bare keyword &lt;code&gt;DEFAULT&lt;/code&gt; without the parentheses and argument to refer to the column in context. You can only use &lt;code&gt;DEFAULT&lt;/code&gt; as a bare keyword if you are using it alone without a surrounding expression or function.</source>
          <target state="translated">사용하는 경우 &lt;code&gt;DEFAULT&lt;/code&gt; 를 에 세트 값으로 &lt;code&gt;&lt;a href=&quot;../insert/index&quot;&gt;INSERT&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt;&lt;/code&gt; 문, 당신은 베어 키워드를 사용할 수있는 &lt;code&gt;DEFAULT&lt;/code&gt; 맥락에서 열을 참조하는 괄호와 인수없이. 주변 표현식이나 함수없이 단독으로 사용하는 경우 &lt;code&gt;DEFAULT&lt;/code&gt; 를 베어 키워드 로만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9fc3ec2f879963b595fc836f211440f24a309f8d" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;NEXT VALUE&lt;/code&gt; the value will be reserved at once and will not be reused, except if the &lt;code&gt;SEQUENCE&lt;/code&gt; was created with &lt;code&gt;CYCLE&lt;/code&gt;. This means that when you are using &lt;code&gt;SEQUENCE&lt;/code&gt;s you have to expect gaps in the generated sequence numbers.</source>
          <target state="translated">사용하는 경우 &lt;code&gt;NEXT VALUE&lt;/code&gt; 를 값을 한 번에 예약되고있는 경우를 제외하고, 재사용 할 수 없습니다 &lt;code&gt;SEQUENCE&lt;/code&gt; 가 만들어졌습니다 &lt;code&gt;CYCLE&lt;/code&gt; . 이는 &lt;code&gt;SEQUENCE&lt;/code&gt; 를 사용할 때 생성 된 시퀀스 번호에 차이가 있어야 함을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="ed6caf9b44595c172e73a15c74f32ff789fb985b" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;PAGE&lt;/code&gt; format (default) row data is cached by page cache.</source>
          <target state="translated">사용하는 경우 &lt;code&gt;PAGE&lt;/code&gt; 형식 (기본값) 행 데이터는 페이지 캐시에 의해 캐시됩니다.</target>
        </trans-unit>
        <trans-unit id="bed4cf0eb8ca946f6b9527ef79737a162f4d3c45" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;START SLAVE UNTIL master_gtid_pos = XXX&lt;/code&gt;, if the UNTIL position is present in the master's binlog then it is permissible for the start position to be missing on the master. In this case, replication for the associated domains stop immediately.</source>
          <target state="translated">사용시 &lt;code&gt;START SLAVE UNTIL master_gtid_pos = XXX&lt;/code&gt; (가) 위치까지 마스터의 바이너리 로그에 존재한다면, 그것은 시작 위치는 마스터에서 누락되기 위해서는 허용 가능하다. 이 경우 연결된 도메인의 복제가 즉시 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="aac6ac9fe9e2d6fc8859b1c594cec70220e6110b" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;master_use_gtid=current_pos&lt;/code&gt; there is no need to consider whether a server was a master or a slave prior to using &lt;a href=&quot;../change-master-to/index&quot;&gt;CHANGE MASTER&lt;/a&gt;. But care must be taken not to inject extra transactions into the binlog on the slave server that are not intended to be replicated to other servers. If such an extra transaction is the most recent when the slave starts, it will be used as the starting point of replication. This will probably fail because that transaction is not present on the master. To avoid local changes on a slave server to go into the binlog, set &lt;a href=&quot;../replication-and-binary-log-system-variables/index#sql_log_bin&quot;&gt;sql_log_bin&lt;/a&gt; to 0.</source>
          <target state="translated">사용하는 경우 &lt;code&gt;master_use_gtid=current_pos&lt;/code&gt; 서버가 마스터 또는 슬레이브 전에 사용하는 여부를 고려할 필요가 없다 &lt;a href=&quot;../change-master-to/index&quot;&gt;변경 MASTER는&lt;/a&gt; . 그러나 다른 서버로 복제되지 않는 추가 트랜잭션을 슬레이브 서버의 binlog에 주입하지 않도록주의해야합니다. 이러한 추가 트랜잭션이 슬레이브가 시작될 때 가장 최근의 트랜잭션 인 경우 복제 시작점으로 사용됩니다. 해당 트랜잭션이 마스터에 없기 때문에 실패 할 수 있습니다. 슬레이브 서버에서 로컬 변경 사항이 binlog로 들어 가지 않게하려면 &lt;a href=&quot;../replication-and-binary-log-system-variables/index#sql_log_bin&quot;&gt;sql_log_bin&lt;/a&gt; 을 0으로 설정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="52082a3f85cd4c1ee075cddb87d35af4d7830578" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;mysqld_safe&lt;/code&gt;, if you would like to &lt;a href=&quot;../enabling-core-dumps/index&quot;&gt;enable core dumps&lt;/a&gt;, the system's core file size limit can be changed by providing the &lt;code&gt;--core-file-size&lt;/code&gt; option either on the command-line or in an option file. For example:</source>
          <target state="translated">사용하는 경우 &lt;code&gt;mysqld_safe&lt;/code&gt; 당신이 좋아하면, &lt;a href=&quot;../enabling-core-dumps/index&quot;&gt;코어 덤프를 사용&lt;/a&gt; , 시스템의 코어 파일 크기 제한은 제공에 의해 변경 될 수 &lt;code&gt;--core-file-size&lt;/code&gt; 명령 행 또는 옵션 파일에서 옵션 중 하나를. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f62a6d361867e01c91982a53b4cd2ea6c7c93b04" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;mysqld_safe&lt;/code&gt;, if you would like to redirect the error log to the &lt;a href=&quot;https://linux.die.net/man/8/rsyslogd&quot;&gt;syslog&lt;/a&gt;, then that can easily be done by using the &lt;code&gt;--syslog&lt;/code&gt; option. &lt;code&gt;mysqld_safe&lt;/code&gt; redirects two types of log messages to the syslog--its own log messages, and log messages for &lt;code&gt;mysqld&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mysqld_safe&lt;/code&gt; 를 사용할 때 오류 로그를 &lt;a href=&quot;https://linux.die.net/man/8/rsyslogd&quot;&gt;syslog&lt;/a&gt; 로 리디렉션 하려면 &lt;code&gt;--syslog&lt;/code&gt; 옵션 을 사용하여 쉽게 수행 할 수 있습니다 . &lt;code&gt;mysqld_safe&lt;/code&gt; 는 두 가지 유형의 로그 메시지를 자체 로그 메시지와 &lt;code&gt;mysqld&lt;/code&gt; 에 대한 로그 메시지로 syslog로 리디렉션 합니다.</target>
        </trans-unit>
        <trans-unit id="b03bd653e47850b6c66d3f7f91a807bdd8e07f25" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;mysqld_safe&lt;/code&gt;, the system's open files limit can be changed by providing the &lt;code&gt;--open-files-limit&lt;/code&gt; option either on the command-line or in an option file. For example:</source>
          <target state="translated">&lt;code&gt;mysqld_safe&lt;/code&gt; 를 사용할 때 명령 행 또는 옵션 파일에서 &lt;code&gt;--open-files-limit&lt;/code&gt; 옵션 을 제공하여 시스템의 열린 파일 제한을 변경할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c9b54ed483673f4639b06697f58bc27c2dd2c9ce" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;query_cache_type=DEMAND&lt;/code&gt; (after &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-6631&quot;&gt;MDEV-6631&lt;/a&gt; feature request) and the query specifies &lt;code&gt;SQL_CACHE&lt;/code&gt;, the server will cache the query.</source>
          <target state="translated">사용하는 경우 &lt;code&gt;query_cache_type=DEMAND&lt;/code&gt; (이후 &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-6631&quot;&gt;인 mdev-6631&lt;/a&gt; 기능 요청) 쿼리 지정 &lt;code&gt;SQL_CACHE&lt;/code&gt; 를 , 서버는 쿼리를 캐시합니다.</target>
        </trans-unit>
        <trans-unit id="c6ac63aa02d309da84593c01eace0331a32d9adf" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;query_cache_type=ON&lt;/code&gt;, and the query specifies &lt;code&gt;SQL_NO_CACHE&lt;/code&gt; (case-insensitive), the server will not cache the query and will not fetch results from the query cache.</source>
          <target state="translated">&lt;code&gt;query_cache_type=ON&lt;/code&gt; 을 사용 하고 쿼리가 &lt;code&gt;SQL_NO_CACHE&lt;/code&gt; (대소 문자 구분)를 지정하면 서버는 쿼리를 캐시하지 않으며 쿼리 캐시에서 결과를 가져 오지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fa64137bf8ff9bebecaf015838d45c566c89ba08" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;row_format=PAGE&lt;/code&gt;, (the default), Aria first writes the row, then the keys, at which point the check for duplicate keys happens. This makes &lt;code&gt;PAGE&lt;/code&gt; format slower than &lt;code&gt;DYNAMIC&lt;/code&gt; (or MyISAM) if there is a lot of duplicated keys because of the overhead of writing and removing the row. If this is a problem, you can use &lt;code&gt;row_format=DYNAMIC&lt;/code&gt; to get same behavior as MyISAM.</source>
          <target state="translated">사용하는 경우 &lt;code&gt;row_format=PAGE&lt;/code&gt; (기본값), 아리아는 먼저 행, 중복 키에 대한 검사가 어떻게 그 시점에서 다음 키를 씁니다. 이렇게하면 행을 쓰고 제거하는 오버 헤드로 인해 중복 키가 많은 경우 &lt;code&gt;PAGE&lt;/code&gt; 형식이 &lt;code&gt;DYNAMIC&lt;/code&gt; (또는 MyISAM) 보다 느려집니다 . 이것이 문제이면 &lt;code&gt;row_format=DYNAMIC&lt;/code&gt; 을 사용 하여 MyISAM과 동일한 동작을 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="00290c60a0a50ee55881e7bdeebee4591429cf77" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;sql_mode=ORACLE&lt;/code&gt;, &lt;code&gt;table%ROWTYPE&lt;/code&gt; and &lt;code&gt;cursor%ROWTYPE&lt;/code&gt; variables can be used as &lt;code&gt;SELECT...INTO&lt;/code&gt; targets.</source>
          <target state="translated">사용시 &lt;code&gt;sql_mode=ORACLE&lt;/code&gt; , &lt;code&gt;table%ROWTYPE&lt;/code&gt; 및 &lt;code&gt;cursor%ROWTYPE&lt;/code&gt; 변수로서 사용될 수있다 &lt;code&gt;SELECT...INTO&lt;/code&gt; 타겟.</target>
        </trans-unit>
        <trans-unit id="2e4c6ce3ad88cefe92648c239f75d0afb5d9c66c" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;systemd&lt;/code&gt;, if you would like to &lt;a href=&quot;../enabling-core-dumps/index&quot;&gt;enable core dumps&lt;/a&gt;, rather than setting the core file size by setting the &lt;code&gt;&lt;a href=&quot;../mysqld_safe/index#mysqld_safe-options&quot;&gt;core-file-size&lt;/a&gt;&lt;/code&gt; option for &lt;code&gt;mysqld_safe&lt;/code&gt;, the limit can be changed by configuring the &lt;code&gt;&lt;a href=&quot;https://www.freedesktop.org/software/systemd/man/systemd.exec.html#LimitCPU=&quot;&gt;LimitCORE&lt;/a&gt;&lt;/code&gt; option for the MariaDB &lt;code&gt;systemd&lt;/code&gt; service. For example, you can reconfigure the MariaDB &lt;code&gt;systemd&lt;/code&gt; service to have an infinite size for core files by executing the following commands:</source>
          <target state="translated">&lt;code&gt;systemd&lt;/code&gt; 를 사용할 때 &lt;code&gt;mysqld_safe&lt;/code&gt; 에 대해 &lt;code&gt;&lt;a href=&quot;../mysqld_safe/index#mysqld_safe-options&quot;&gt;core-file-size&lt;/a&gt;&lt;/code&gt; 옵션을 설정하여 코어 파일 크기를 설정하는 대신 &lt;a href=&quot;../enabling-core-dumps/index&quot;&gt;코어 덤프&lt;/a&gt; 를 활성화 하려면 MariaDB &lt;code&gt;systemd&lt;/code&gt; 서비스에 대해 &lt;code&gt;&lt;a href=&quot;https://www.freedesktop.org/software/systemd/man/systemd.exec.html#LimitCPU=&quot;&gt;LimitCORE&lt;/a&gt;&lt;/code&gt; 옵션을 구성하여 제한을 변경할 수 있습니다 . 예를 들어 다음 명령을 실행하여 MariaDB &lt;code&gt;systemd&lt;/code&gt; 서비스를 코어 파일에 대해 무한 크기로 재구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ce533eba78533a5158de2b87f75149ac3db7d901" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;systemd&lt;/code&gt;, if you would like to redirect the &lt;a href=&quot;../error-log/index&quot;&gt;error log&lt;/a&gt; to the &lt;a href=&quot;https://linux.die.net/man/8/rsyslogd&quot;&gt;syslog&lt;/a&gt;, then that can easily be done by doing the following:</source>
          <target state="translated">&lt;code&gt;systemd&lt;/code&gt; 를 사용할 때 &lt;a href=&quot;../error-log/index&quot;&gt;오류 로그&lt;/a&gt; 를 &lt;a href=&quot;https://linux.die.net/man/8/rsyslogd&quot;&gt;syslog&lt;/a&gt; 로 리디렉션하려면 다음을 수행하여 쉽게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="605eb8857c6fa6be0f3fc9497ff0cfdb6468eba8" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;systemd&lt;/code&gt;, rather than setting the open files limit by setting the &lt;code&gt;&lt;a href=&quot;../mysqld_safe/index#mysqld_safe-options&quot;&gt;open-files-limit&lt;/a&gt;&lt;/code&gt; option for &lt;code&gt;mysqld_safe&lt;/code&gt; or the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#open_files_limit&quot;&gt;open_files_limit&lt;/a&gt;&lt;/code&gt; system variable, the limit can be changed by configuring the &lt;code&gt;&lt;a href=&quot;https://www.freedesktop.org/software/systemd/man/systemd.exec.html#LimitCPU=&quot;&gt;LimitNOFILE&lt;/a&gt;&lt;/code&gt; option for the MariaDB &lt;code&gt;systemd&lt;/code&gt; service.</source>
          <target state="translated">&lt;code&gt;mysqld_safe&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#open_files_limit&quot;&gt;open_files_limit&lt;/a&gt;&lt;/code&gt; 시스템 변수에 &lt;code&gt;&lt;a href=&quot;../mysqld_safe/index#mysqld_safe-options&quot;&gt;open-files-limit&lt;/a&gt;&lt;/code&gt; 옵션을 설정하여 열린 파일 제한을 설정하는 대신 &lt;code&gt;systemd&lt;/code&gt; 를 사용 하는 경우 MariaDB &lt;code&gt;systemd&lt;/code&gt; 서비스에 대해 &lt;code&gt;&lt;a href=&quot;https://www.freedesktop.org/software/systemd/man/systemd.exec.html#LimitCPU=&quot;&gt;LimitNOFILE&lt;/a&gt;&lt;/code&gt; 옵션을 구성하여 제한을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c7f54a8b4026d3d0cb1ebe61b33f837c17c8556e" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;systemd&lt;/code&gt;, the umask of &lt;code&gt;mysqld&lt;/code&gt; can be set by setting the &lt;code&gt;UMASK&lt;/code&gt; and &lt;code&gt;UMASK_DIR&lt;/code&gt; environment variables for the &lt;code&gt;systemd&lt;/code&gt; service. For example, you can configure the MariaDB &lt;code&gt;systemd&lt;/code&gt; service's umask by executing the following commands:</source>
          <target state="translated">&lt;code&gt;systemd&lt;/code&gt; 를 사용 하는 경우 &lt;code&gt;systemd&lt;/code&gt; 서비스에 대한 &lt;code&gt;UMASK&lt;/code&gt; 및 &lt;code&gt;UMASK_DIR&lt;/code&gt; 환경 변수를 설정하여 &lt;code&gt;mysqld&lt;/code&gt; 의 umask를 설정할 수 있습니다 . 예를 들어 다음 명령을 실행하여 MariaDB &lt;code&gt;systemd&lt;/code&gt; 서비스의 umask를 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="93c52c85af2ba47b6cc604427caba7b8af3e0fab" translate="yes" xml:space="preserve">
          <source>When using A as the left table we ensure that the query will return at least as many rows as there are in that table. For rows where the join condition (B.id = A.id) is not met the selected column (A.colA) will still contain its original value. The not seen B.* row would contain all NULL:s.</source>
          <target state="translated">왼쪽 테이블로 A를 사용하는 경우 쿼리는 최소한 해당 테이블에있는 수만큼 행을 반환합니다. 결합 조건 (B.id = A.id)이 충족되지 않은 행의 경우 선택한 열 (A.colA)에는 여전히 원래 값이 포함됩니다. 보이지 않는 B. * 행에는 모든 NULL이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="272a6edb84cec4e708c9c24939f76d2a2ac45e1e" translate="yes" xml:space="preserve">
          <source>When using ANALYZE TABLE (&lt;code&gt;--analyze&lt;/code&gt;), uses the PERSISTENT FOR ALL option, which forces &lt;a href=&quot;../engine-independent-table-statistics/index&quot;&gt;Engine-independent Statistics&lt;/a&gt; for this table to be updated. Added in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10110-release-notes/&quot;&gt;MariaDB 10.1.10&lt;/a&gt;</source>
          <target state="translated">ANALYZE TABLE ( &lt;code&gt;--analyze&lt;/code&gt; )을 사용할 때 PERSISTENT FOR ALL 옵션을 사용하면 이 테이블에 대한 &lt;a href=&quot;../engine-independent-table-statistics/index&quot;&gt;엔진 독립적 통계&lt;/a&gt; 가 강제 로 업데이트됩니다. &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10110-release-notes/&quot;&gt;MariaDB 10.1.10&lt;/a&gt; 에서 추가됨</target>
        </trans-unit>
        <trans-unit id="96f7ea70f6d0d24b07e60b87577ac2cbc42f832c" translate="yes" xml:space="preserve">
          <source>When using ColumnStore, MariaDB Server creates a series of system databases used for operational purposes.</source>
          <target state="translated">ColumnStore를 사용할 때 MariaDB 서버는 운영 목적으로 사용되는 일련의 시스템 데이터베이스를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="39a8bd258e43f2c3a5b1c80c0d57dd17cc19b062" translate="yes" xml:space="preserve">
          <source>When using ColumnStore, MariaDB Server creates a series of system databases...</source>
          <target state="translated">ColumnStore를 사용할 때 MariaDB 서버는 일련의 시스템 데이터베이스를 생성합니다 ...</target>
        </trans-unit>
        <trans-unit id="332fc23e2c19d0a39aa41f5f1dbe3c6eed8e66c6" translate="yes" xml:space="preserve">
          <source>When using GTID, @@sql_slave_skip_counter can not be used. Instead, setting @@gtid_slave_pos explicitly can be used to skip to after a given GTID position.</source>
          <target state="translated">GTID를 사용할 때는 @@ sql_slave_skip_counter를 사용할 수 없습니다. 대신 @@ gtid_slave_pos를 명시 적으로 설정하면 지정된 GTID 위치 다음으로 건너 뛸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c471ac89c806e3a0e21a616ebd5f6a544c1a3849" translate="yes" xml:space="preserve">
          <source>When using Galera cluster, replication filters should be used with caution. See &lt;a href=&quot;../configuring-mariadb-galera-cluster/index#replication-filters&quot;&gt;Configuring MariaDB Galera Cluster: Replication Filters&lt;/a&gt; for more details.</source>
          <target state="translated">Galera 클러스터를 사용할 때는 복제 필터를주의해서 사용해야합니다. 자세한 내용은 &lt;a href=&quot;../configuring-mariadb-galera-cluster/index#replication-filters&quot;&gt;MariaDB Galera 클러스터 : 복제 필터 구성&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6bd244c54475a5020c907ba0b70d6945272cd3a1" translate="yes" xml:space="preserve">
          <source>When using InnoDB FULLTEXT index one should not use innodb_defragment</source>
          <target state="translated">InnoDB FULLTEXT 인덱스를 사용할 때 innodb_defragment를 사용해서는 안됩니다</target>
        </trans-unit>
        <trans-unit id="9a21dd677d15afbd7c2507b5991d7a4a8b169cf7" translate="yes" xml:space="preserve">
          <source>When using LOAD DATA LOCAL INFILE with the &lt;em&gt;mcsmysql&lt;/em&gt; utility , use the &lt;a href=&quot;../server-system-variables/index#local_infile&quot;&gt;--local-infile&lt;/a&gt; command-line option.</source>
          <target state="translated">&lt;em&gt;mcsmysql&lt;/em&gt; 유틸리티 와 함께 LOAD DATA LOCAL INFILE을 사용하는 경우 &lt;a href=&quot;../server-system-variables/index#local_infile&quot;&gt;--local-infile&lt;/a&gt; 명령 행 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9930d59f7dcf8aece5dd7eebeac821fa2ecdd987" translate="yes" xml:space="preserve">
          <source>When using MRR and BKA (and you do so with network storage), when Spider needs to create temporary tables on the backends, use the CREATE TEMPORARY TABLES privilege. Spider can still switch to a lower performance solution using &lt;a href=&quot;../spider-server-system-variables/index#spider_bka_mode&quot;&gt;spider_bka_mode=2&lt;/a&gt;, or Query push down or range predicate using &lt;a href=&quot;../spider-server-system-variables/index#spider_bka_mode&quot;&gt;spider_bka_mode=0&lt;/a&gt;</source>
          <target state="translated">Spider가 백엔드에서 임시 테이블을 작성해야하는 경우 MRR 및 BKA를 사용하고 네트워크 스토리지를 사용하는 경우 CREATE TEMPORARY TABLES 권한을 사용하십시오. Spider는 여전히 &lt;a href=&quot;../spider-server-system-variables/index#spider_bka_mode&quot;&gt;spider_bka_mode = 2를&lt;/a&gt; 사용하여 성능이 낮은 솔루션으로 전환 하거나 &lt;a href=&quot;../spider-server-system-variables/index#spider_bka_mode&quot;&gt;spider_bka_mode = 0을&lt;/a&gt; 사용하여 쿼리 푸시 다운 또는 범위 조건 자를 계속 전환 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="aab13af4b9233ae1d8c76ae59bc283578c8ee852" translate="yes" xml:space="preserve">
          <source>When using Mariabackup from versions prior to &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10210-release-notes/&quot;&gt;MariaDB 10.2.10&lt;/a&gt;, you would also have to remove any pre-existing &lt;a href=&quot;../xtradbinnodb-redo-log/index&quot;&gt;InnoDB redo log&lt;/a&gt; files. For example:</source>
          <target state="translated">&lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10210-release-notes/&quot;&gt;MariaDB 10.2.10&lt;/a&gt; 이전 버전에서 Mariabackup을 사용 하는 경우 기존 &lt;a href=&quot;../xtradbinnodb-redo-log/index&quot;&gt;InnoDB 리두 로그&lt;/a&gt; 파일 도 제거해야 합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="073f9c99f172c6374ed1789b886d107d6587fa7f" translate="yes" xml:space="preserve">
          <source>When using Mariabackup to perform an incremental backup, this option forces it to also perform a full scan of the data pages being backed up, even when there's bitmap data on the changes. &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt; and later does not support changed page bitmaps, so this option is useless in those versions. See &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-18985&quot;&gt;MDEV-18985&lt;/a&gt; for more information.</source>
          <target state="translated">Mariabackup을 사용하여 증분 백업을 수행하는 경우이 옵션은 변경 사항에 비트 맵 데이터가있는 경우에도 백업중인 데이터 페이지의 전체 스캔을 수행하도록합니다. &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt; 이상은 변경된 페이지 비트 맵을 지원하지 않으므로이 버전에서는이 옵션을 사용할 수 없습니다. 자세한 내용은 &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-18985&quot;&gt;MDEV-18985&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="aa1acbc12c817eb5dde2d2f536588fb28c8fdc20" translate="yes" xml:space="preserve">
          <source>When using Mariabackup with the &lt;code&gt;&lt;a href=&quot;#-copy-back&quot;&gt;--copy-back&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#-move-back&quot;&gt;--move-back&lt;/a&gt;&lt;/code&gt; command options, they normally require a non-empty target directory to avoid conflicts. Using this option with either of command allows Mariabackup to use a non-empty directory.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#-copy-back&quot;&gt;--copy-back&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#-move-back&quot;&gt;--move-back&lt;/a&gt;&lt;/code&gt; 명령 옵션 과 함께 Mariabackup을 사용하는 경우 충돌을 피하기 위해 일반적으로 비어 있지 않은 대상 디렉토리가 필요합니다. 명령 중 하나와 함께이 옵션을 사용하면 Mariabackup이 비어 있지 않은 디렉토리를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d041ab748cc9bb894085b85fd36f506c2ecb6aed" translate="yes" xml:space="preserve">
          <source>When using Mariabackup, you don't necessarily need to restore every table and/or partition that was backed up. Even if you're starting from a &lt;a href=&quot;../full-backup-and-restore-with-mariabackup/index&quot;&gt;full backup&lt;/a&gt;, it is certainly possible to restore only certain tables and/or partitions from the backup, as long as the table or partition involved is in an &lt;a href=&quot;../innodb-file-per-table-tablespaces/index&quot;&gt;InnoDB file-per-table tablespace&lt;/a&gt;. This page documents how to restore individual tables and partitions.</source>
          <target state="translated">Mariabackup을 사용하는 경우 백업 된 모든 테이블 및 / 또는 파티션을 반드시 복원 할 필요는 없습니다. &lt;a href=&quot;../full-backup-and-restore-with-mariabackup/index&quot;&gt;전체 백업&lt;/a&gt; 에서 시작하더라도 관련된 테이블 또는 파티션이 &lt;a href=&quot;../innodb-file-per-table-tablespaces/index&quot;&gt;InnoDB 테이블 당 테이블 스페이스에&lt;/a&gt; 있는 한 백업에서 특정 테이블 및 / 또는 파티션 만 복원 할 수 있습니다 . 이 페이지는 개별 테이블과 파티션을 복원하는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="b47503b40a90f7b961094a505473e4f932d69e62" translate="yes" xml:space="preserve">
          <source>When using Mariabackup, you have the option of performing a full or an incremental backup. Full backups create a complete backup of the database server in an empty directory while incremental backups update a previous backup with whatever changes to the data have occurred since the backup. This page documents how to perform full backups.</source>
          <target state="translated">Mariabackup을 사용하는 경우 전체 또는 증분 백업을 수행 할 수 있습니다. 전체 백업은 빈 디렉토리에 데이터베이스 서버의 전체 백업을 생성하는 반면 증분 백업은 백업 이후 발생한 데이터 변경 사항으로 이전 백업을 업데이트합니다. 이 페이지는 전체 백업을 수행하는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="9799c51d7d7be8c4d4f752b8a67b4d31087f915f" translate="yes" xml:space="preserve">
          <source>When using Mariabackup, you have the option of performing a full or incremental backup. Full backups create a complete copy in an empty directory while incremental backups update a previous backup with new data. This page documents incremental backups.</source>
          <target state="translated">Mariabackup을 사용하는 경우 전체 또는 증분 백업을 수행 할 수 있습니다. 전체 백업은 빈 디렉토리에 완전한 사본을 작성하지만 증분 백업은 새 데이터로 이전 백업을 업데이트합니다. 이 페이지는 증분 백업에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="6bb152f3d25256a33ee4cbbd2f4677f05228c190" translate="yes" xml:space="preserve">
          <source>When using Mariabackup, you have the option of performing partial backups. Partial backups allow you to choose which databases or tables to backup, as long as the table or partition involved is in an &lt;a href=&quot;../innodb-file-per-table-tablespaces/index&quot;&gt;InnoDB file-per-table tablespace&lt;/a&gt;.This page documents how to perform partial backups.</source>
          <target state="translated">Mariabackup을 사용하는 경우 부분 백업을 수행 할 수 있습니다. 부분 백업을 사용하면 관련된 테이블 또는 파티션이 &lt;a href=&quot;../innodb-file-per-table-tablespaces/index&quot;&gt;InnoDB 테이블 당 테이블 스페이스&lt;/a&gt; 에있는 한 백업 할 데이터베이스 또는 테이블을 선택할 수 있습니다. 이 페이지에는 부분 백업을 수행하는 방법이 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c5fa2642bff1c66da809195f11fddf3e538be01" translate="yes" xml:space="preserve">
          <source>When using SQL_NO_CACHE, it should be after the first SELECT hint, for example :</source>
          <target state="translated">SQL_NO_CACHE를 사용하는 경우 첫 번째 SELECT 힌트 뒤에 있어야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="19b94f1cd0ed1d315d231f2306198165f35d3462" translate="yes" xml:space="preserve">
          <source>When using a &lt;a href=&quot;../user-defined-functions/index&quot;&gt;user-defined function&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../user-defined-functions/index&quot;&gt;사용자 정의 함수를&lt;/a&gt; 사용하는 경우 .</target>
        </trans-unit>
        <trans-unit id="0c5a719f5fa4e2988e769cff6d51cc60c1a086e3" translate="yes" xml:space="preserve">
          <source>When using a Page Size of 4KB or 8KB, the maximum index key length is lowered proportionately.</source>
          <target state="translated">4KB 또는 8KB의 페이지 크기를 사용하는 경우 최대 색인 키 길이가 비례 적으로 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="e86906399df54ae247c517748ba0d75d38f8761b" translate="yes" xml:space="preserve">
          <source>When using an SST method that blocks the donor, there is yet another reason to require a minimum of 3 nodes. In a 3-node cluster, if one node is acting as an SST joiner and one other node is acting as an SST donor, then there is still one more node to continue executing queries.</source>
          <target state="translated">공여자를 차단하는 SST 방법을 사용하는 경우 최소 3 개의 노드가 필요한 또 다른 이유가 있습니다. 3 노드 클러스터에서 한 노드가 SST 결합 자로 작동하고 다른 한 노드가 SST 공여자로 작동하는 경우 계속 쿼리를 계속 수행 할 노드가 하나 더 있습니다.</target>
        </trans-unit>
        <trans-unit id="5888fb3f9321eac1ec12495d776f5c11319eb394" translate="yes" xml:space="preserve">
          <source>When using cascading &lt;a href=&quot;../foreign-keys/index&quot;&gt;foreign keys&lt;/a&gt;, operations in the cascade don't activate triggers.</source>
          <target state="translated">계단식 &lt;a href=&quot;../foreign-keys/index&quot;&gt;외래 키를&lt;/a&gt; 사용하는 경우 계단식 작업은 트리거를 활성화하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="768e30f078d797ee1120d299d524fda2f92940db" translate="yes" xml:space="preserve">
          <source>When using data type JSON , one should convert type to TEXT, virtual generated column works the same after.</source>
          <target state="translated">JSON 데이터 유형을 사용할 때 유형을 TEXT로 변환해야하며 가상 생성 열은 이후 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="d431fe5575b90eb117f1b79591cc8bf28ddda729" translate="yes" xml:space="preserve">
          <source>When using data-at-rest encryption with the InnoDB or XtraDB storage engines, it is not necessary that you encrypt every table in your database. You can check which tables are encrypted and which are not by querying the &lt;code&gt;&lt;a href=&quot;../information-schema-innodb_tablespaces_encryption-table/index&quot;&gt;INNODB_TABLESPACES_ENCRYPTION&lt;/a&gt;&lt;/code&gt; table in the &lt;a href=&quot;../information-schema/index&quot;&gt;Information Schema&lt;/a&gt;. This table provides information on which tablespaces are encrypted, which encryption key each tablespace is encrypted with, and whether the background encryption threads are currently working on the tablespace. Since the &lt;a href=&quot;../innodb-system-tablespaces/index&quot;&gt;system tablespace&lt;/a&gt; can also contain tables, it can be helpful to join the &lt;code&gt;&lt;a href=&quot;../information-schema-innodb_tablespaces_encryption-table/index&quot;&gt;INNODB_TABLESPACES_ENCRYPTION&lt;/a&gt;&lt;/code&gt; table with the &lt;code&gt;&lt;a href=&quot;../information-schema-innodb_sys_tables-table/index&quot;&gt;INNODB_SYS_TABLES&lt;/a&gt;&lt;/code&gt; table to find out the encryption status of each specific table, rather than each tablespace. For example:</source>
          <target state="translated">InnoDB 또는 XtraDB 스토리지 엔진에서 미사용 데이터 암호화를 사용하는 경우 데이터베이스의 모든 테이블을 암호화 할 필요는 없습니다. &lt;a href=&quot;../information-schema/index&quot;&gt;정보 스키마&lt;/a&gt; 에서 &lt;code&gt;&lt;a href=&quot;../information-schema-innodb_tablespaces_encryption-table/index&quot;&gt;INNODB_TABLESPACES_ENCRYPTION&lt;/a&gt;&lt;/code&gt; 테이블 을 쿼리하여 암호화 된 테이블과 그렇지 않은 테이블을 확인할 수 있습니다 . 이 테이블은 암호화 된 테이블 스페이스, 각 테이블 스페이스가 암호화 된 암호화 키 및 백그라운드 암호화 스레드가 현재 테이블 스페이스에서 작업 중인지 여부에 대한 정보를 제공합니다. 때문에 &lt;a href=&quot;../innodb-system-tablespaces/index&quot;&gt;시스템 테이블은&lt;/a&gt; 또한 테이블을 포함 할 수 있습니다, 가입하는 것이 도움이 될 수 &lt;code&gt;&lt;a href=&quot;../information-schema-innodb_tablespaces_encryption-table/index&quot;&gt;INNODB_TABLESPACES_ENCRYPTION&lt;/a&gt;&lt;/code&gt; 의 와 테이블을 &lt;code&gt;&lt;a href=&quot;../information-schema-innodb_sys_tables-table/index&quot;&gt;INNODB_SYS_TABLES&lt;/a&gt;&lt;/code&gt; 각 테이블 스페이스가 아닌 각 특정 테이블의 암호화 상태를 확인하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0ff9368386c41155359a7f3d1ea64e4e8c53a11a" translate="yes" xml:space="preserve">
          <source>When using encrypted binary logs with &lt;a href=&quot;../replication/index&quot;&gt;replication&lt;/a&gt;, it is completely supported to have different encryption keys on the master and slave. The master decrypts encrypted binary log events as it reads them from disk, and before its &lt;a href=&quot;../replication-threads/index#binary-log-dump-thread&quot;&gt;binary log dump thread&lt;/a&gt; sends them to the slave, so the slave actually receives the unencrypted binary log events.</source>
          <target state="translated">&lt;a href=&quot;../replication/index&quot;&gt;복제&lt;/a&gt; 와 함께 암호화 된 이진 로그를 사용하는 경우 마스터 및 슬레이브에서 다른 암호화 키를 갖도록 완전히 지원됩니다. 마스터는 암호화 된 이진 로그 이벤트를 디스크에서 읽을 때 해독하고 &lt;a href=&quot;../replication-threads/index#binary-log-dump-thread&quot;&gt;이진 로그 덤프 스레드가&lt;/a&gt; 이를 슬레이브로 보내기 전에 슬레이브가 실제로 암호화되지 않은 이진 로그 이벤트를 수신합니다.</target>
        </trans-unit>
        <trans-unit id="8eadfbfacff5d8cfd7b69d3c1ea1fc4fb3799f25" translate="yes" xml:space="preserve">
          <source>When using field COMPRESSED attribute, 1 byte is reserved to metadata, for example VARCHAR(255) will use +2bytes instead of +1</source>
          <target state="translated">필드 COMPRESSED 속성을 사용하는 경우 1 바이트는 메타 데이터에 예약됩니다. 예를 들어 VARCHAR (255)는 +1 대신 +2 바이트를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9777b428deec0f7eb1d72e5a1bfdd8206cbc8454" translate="yes" xml:space="preserve">
          <source>When using global locks, even with a high value on the &lt;code&gt;&lt;a href=&quot;../thread-pool-system-status-variables/index#thread_pool_max_threads&quot;&gt;thread_pool_max_threads&lt;/a&gt;&lt;/code&gt; system variable, it is still possible to block the entire pool.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../thread-pool-system-status-variables/index#thread_pool_max_threads&quot;&gt;thread_pool_max_threads&lt;/a&gt;&lt;/code&gt; 시스템 변수에서 값이 높은 글로벌 잠금을 사용할 때 여전히 전체 풀을 차단할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6503b228399ba7c6ee2ddbaf7aa84eb621285c5d" translate="yes" xml:space="preserve">
          <source>When using index hints (USE, FORCE or &lt;a href=&quot;../ignore-index/index&quot;&gt;IGNORE INDEX&lt;/a&gt;), the index name value can also be an unambiguous prefix of an index name.</source>
          <target state="translated">인덱스 힌트 (USE, FORCE 또는 &lt;a href=&quot;../ignore-index/index&quot;&gt;IGNORE INDEX&lt;/a&gt; )를 사용할 때 인덱스 이름 값은 인덱스 이름의 명확한 접두사 일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c94c8a2b49a1115817397ba00e08df11c20dfb6e" translate="yes" xml:space="preserve">
          <source>When using index hints (USE, FORCE or IGNORE INDEX), the index name value can also be an unambiguous prefix of an index name.</source>
          <target state="translated">인덱스 힌트 (USE, FORCE 또는 IGNORE INDEX)를 사용할 때 인덱스 이름 값은 인덱스 이름의 명확한 접두사 일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b14bb6f5ca53e1f025e640d6458f681d3a4fa5b" translate="yes" xml:space="preserve">
          <source>When using join_cache_level = 6 to get faster joins on the network it is recommended to use :</source>
          <target state="translated">join_cache_level = 6을 사용하여 네트워크에서 더 빠른 조인을 얻으려면 다음을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b50509e70c847bab9e0007d25d34df397ea40448" translate="yes" xml:space="preserve">
          <source>When using mixed character sets, use the &lt;code&gt;CHARACTER SET&lt;/code&gt; clause in both &lt;code&gt;&lt;a href=&quot;../select-into-outfile/index&quot;&gt;SELECT INTO OUTFILE&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;LOAD DATA INFILE&lt;/code&gt; to ensure that MariaDB correctly interprets the escape sequences.</source>
          <target state="translated">혼합 문자 세트를 사용하는 경우 &lt;code&gt;&lt;a href=&quot;../select-into-outfile/index&quot;&gt;SELECT INTO OUTFILE&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;LOAD DATA INFILE&lt;/code&gt; 모두에서 &lt;code&gt;CHARACTER SET&lt;/code&gt; 절을 사용하여 MariaDB가 이스케이프 시퀀스를 올바르게 해석하도록하십시오.</target>
        </trans-unit>
        <trans-unit id="5885ba5af84b8e321a7daa71440c632bda8a934f" translate="yes" xml:space="preserve">
          <source>When using multi-source replication, where a single slave connects to multiple masters at the same time, each such master should be configured with its own distinct domain ID.</source>
          <target state="translated">단일 슬레이브가 동시에 여러 마스터에 연결되는 다중 소스 복제를 사용하는 경우 각 마스터는 고유 한 도메인 ID로 구성해야합니다.</target>
        </trans-unit>
        <trans-unit id="00b1f1ed3629f636c5c11b04efbcb7c776aefecf" translate="yes" xml:space="preserve">
          <source>When using multiple instances, each instance will of course also need their own &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#datadir&quot;&gt;datadir&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;../mysql_install_db/index&quot;&gt;mysql_install_db&lt;/a&gt; for information on how to initialize the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#datadir&quot;&gt;datadir&lt;/a&gt;&lt;/code&gt; for additional MariaDB instances.</source>
          <target state="translated">여러 인스턴스를 사용할 때 각 인스턴스에는 물론 자체 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#datadir&quot;&gt;datadir&lt;/a&gt;&lt;/code&gt; 이 필요합니다 . 추가 MariaDB 인스턴스 의 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#datadir&quot;&gt;datadir&lt;/a&gt;&lt;/code&gt; 을 초기화하는 방법에 대한 정보는 &lt;a href=&quot;../mysql_install_db/index&quot;&gt;mysql_install_db&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="100cfc8cddf221d19b9edcffe8cbb94db5c07a59" translate="yes" xml:space="preserve">
          <source>When using old MariaDB versions, an alternative is to use java command or CmakeCMake to produce a *.jar result instead of just *.class files. The advantage is that you can have all the wrapper files built into only one jar file. Here is an example of CMakeLists.txt file that I use to compile all java files into one JdbcInterface.jar file:</source>
          <target state="translated">이전 MariaDB 버전을 사용하는 경우 대안은 java 명령 또는 CmakeCMake를 사용하여 * .class 파일 대신 * .jar 결과를 생성하는 것입니다. 장점은 모든 랩퍼 파일을 하나의 jar 파일에만 빌드 할 수 있다는 것입니다. 다음은 모든 Java 파일을 하나의 JdbcInterface.jar 파일로 컴파일하는 데 사용하는 CMakeLists.txt 파일의 예입니다.</target>
        </trans-unit>
        <trans-unit id="2981c643487ff10ba51a0cca8a9c21c10770832c" translate="yes" xml:space="preserve">
          <source>When using out-of-order parallel replication, the current slave position in the master's binlog becomes multi-dimensional - each replication domain can have reached a different point in the master binlog at any one time. The current position can be seen from the variable &lt;code&gt;gtid_slave_pos&lt;/code&gt;. When the slave is stopped, restarted, or switched to replicate from a different master using CHANGE MASTER, MariaDB automatically handles restarting each replication domain at the appropriate point in the binlog.</source>
          <target state="translated">비 순차 병렬 복제를 사용하는 경우 마스터 binlog의 현재 슬레이브 위치는 다차원이됩니다. 각 복제 도메인은 언제든지 마스터 binlog의 다른 지점에 도달 할 수 있습니다. 현재 위치는 변수 &lt;code&gt;gtid_slave_pos&lt;/code&gt; 에서 볼 수 있습니다 . 슬레이브 마스터가 CHANGE MASTER를 사용하여 다른 마스터에서 복제하도록 중지, 재시작 또는 전환되면 MariaDB는 binlog의 해당 지점에서 각 복제 도메인 재시작을 자동으로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="5d0f329a0ce21eed155d1392e59449d02938dbe0" translate="yes" xml:space="preserve">
          <source>When using row-based replication, the binary log does not contain SQL statements, only discrete single-row insert/update/delete &lt;em&gt;events&lt;/em&gt;. This can make it harder to read mysqlbinlog output and understand where in an application a given event may have originated, complicating analysis and debugging.</source>
          <target state="translated">행 기반 복제를 사용할 때 이진 로그에는 SQL 문이 포함되지 않으며 이산 단일 행 삽입 / 업데이트 / 삭제 &lt;em&gt;이벤트 만&lt;/em&gt; 있습니다. 이로 인해 mysqlbinlog 출력을 읽기가 어려워지고 응용 프로그램에서 주어진 이벤트가 어디서 발생했는지 이해하고 분석 및 디버깅이 복잡해질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5e05369930b9b7d2a64456a0ee484dc7d02b3a6" translate="yes" xml:space="preserve">
          <source>When using second table just to check for existence:</source>
          <target state="translated">존재 여부를 확인하기 위해 두 번째 테이블을 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="9e8601da194bdb812e8673a7b0e09fa66d8c881f" translate="yes" xml:space="preserve">
          <source>When using the --retry option to retry failed tests, stop when N failures have occured (default 2). Setting it to 0 or 1 effectively turns off retries.</source>
          <target state="translated">--retry 옵션을 사용하여 실패한 테스트를 재 시도 할 때 N 오류가 발생하면 중지합니다 (기본값 2). 0 또는 1로 설정하면 재 시도가 효과적으로 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="d75756286bcff5ee611fe4ee2b8338aaf6ef6581" translate="yes" xml:space="preserve">
          <source>When using the &lt;a href=&quot;../general-query-log/index&quot;&gt;General Query Log&lt;/a&gt;, non-root users may encounter issues when querying Spider tables. Explicitly setting the &lt;code&gt;&lt;a href=&quot;../spider-server-system-variables/index#spider_internal_sql_log_off&quot;&gt;spider_internal_sql_log_off&lt;/a&gt;&lt;/code&gt; system variable causes the Spider node to execute &lt;code&gt;SET sql_log_off&lt;/code&gt; statements on the data nodes to enable or disable the General Query Log. When this is done, queries issued by users without the &lt;code&gt;SUPER&lt;/code&gt; privilege raise an error.</source>
          <target state="translated">&lt;a href=&quot;../general-query-log/index&quot;&gt;일반 쿼리 로그를&lt;/a&gt; 사용하면 루트가 아닌 사용자가 Spider 테이블을 쿼리 할 때 문제가 발생할 수 있습니다. &lt;code&gt;&lt;a href=&quot;../spider-server-system-variables/index#spider_internal_sql_log_off&quot;&gt;spider_internal_sql_log_off&lt;/a&gt;&lt;/code&gt; 시스템 변수를 명시 적으로 설정하면 Spider 노드가 일반 쿼리 로그를 활성화 또는 비활성화하기 위해 데이터 노드에서 &lt;code&gt;SET sql_log_off&lt;/code&gt; 문 을 실행 합니다. 이 작업을 수행하면 &lt;code&gt;SUPER&lt;/code&gt; 권한이 없는 사용자가 실행 한 쿼리 에서 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="248ebd343dc2fd3feaf2528565cead8e1650ea0e" translate="yes" xml:space="preserve">
          <source>When using the &lt;a href=&quot;../installing-mariadb-msi-packages-on-windows/index&quot;&gt;Windows MSI installer&lt;/a&gt;, &lt;code&gt;mariabackup&lt;/code&gt; can be installed by selecting &lt;em&gt;Backup utilities&lt;/em&gt;:</source>
          <target state="translated">사용하는 경우 &lt;a href=&quot;../installing-mariadb-msi-packages-on-windows/index&quot;&gt;윈도우 MSI 설치를&lt;/a&gt; , &lt;code&gt;mariabackup&lt;/code&gt; 를 선택하여 설치할 수있는 &lt;em&gt;백업 유틸리티를&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="b65e33ff588de54f51a794d4214538c5f7ea0e1f" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;&lt;a href=&quot;#-backup&quot;&gt;--backup&lt;/a&gt;&lt;/code&gt; command option, Mariabackup produces a number of backup files in the target directory. Using this option, you can have Mariabackup produce additional copies of the &lt;code&gt;&lt;a href=&quot;../files-created-by-mariabackup/index#xtrabackup_checkpoints&quot;&gt;xtrabackup_checkpoints&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../files-created-by-mariabackup/index#xtrabackup_info&quot;&gt;xtrabackup_info&lt;/a&gt;# files in the given directory.&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#-backup&quot;&gt;--backup&lt;/a&gt;&lt;/code&gt; 명령 옵션을 사용하면 Mariabackup은 대상 디렉토리에 많은 백업 파일을 생성합니다. 이 옵션을 사용하면 &lt;code&gt;&lt;a href=&quot;../files-created-by-mariabackup/index#xtrabackup_checkpoints&quot;&gt;xtrabackup_checkpoints&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../files-created-by-mariabackup/index#xtrabackup_info&quot;&gt;xtrabackup_info&lt;/a&gt;# files in the given directory.&lt;/code&gt; xtrabackup_checkpoints 및 &lt;a href=&quot;../files-created-by-mariabackup/index#xtrabackup_info&quot;&gt;xtrabackup_info&lt;/a&gt; # 파일 의 추가 사본을 생성하도록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6f8eb624ac2b174e4545f0363606a3cf9c599a5c" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;&lt;a href=&quot;../mysqlbinlog/index&quot;&gt;mysqlbinlog&lt;/a&gt;&lt;/code&gt; client program, there are similar issues.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../mysqlbinlog/index&quot;&gt;mysqlbinlog&lt;/a&gt;&lt;/code&gt; 클라이언트 프로그램을 사용할 때 비슷한 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="38b7eb41106453296e6c23a5893f5aed6837d7dc" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;COMPRESSED&lt;/code&gt; attribute, note that FIELD LENGTH is reduced by 1; for example, a BLOB has a length of 65535, while BLOB COMPRESSED has 65535-1. See &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-15592&quot;&gt;MDEV-15592&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;COMPRESSED&lt;/code&gt; 속성을 사용할 때 FIELD LENGTH는 1 씩 줄어 듭니다. 예를 들어, BLOB의 길이는 65535이고 BLOB COMPRESSED의 길이는 65535-1입니다. &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-15592&quot;&gt;MDEV-15592를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="183ae2f834372d7a071b1d771d2d18a4710e6afa" translate="yes" xml:space="preserve">
          <source>When using the cpimport utility, the input file must be converted to UTF-8 data. The Linux program iconv is one utility to convert it.</source>
          <target state="translated">cpimport 유틸리티를 사용하는 경우 입력 파일을 UTF-8 데이터로 변환해야합니다. Linux 프로그램 iconv는이를 변환하는 유틸리티 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="534a309688ba9868629e9540c1a210026b024f44" translate="yes" xml:space="preserve">
          <source>When using the standard &lt;a href=&quot;../selinux/index&quot;&gt;SELinux&lt;/a&gt; policy with the &lt;a href=&quot;../selinux/index#changing-selinuxs-mode&quot;&gt;mode&lt;/a&gt; set to &lt;code&gt;enforcing&lt;/code&gt;, &lt;code&gt;mysqld&lt;/code&gt; does not have access to &lt;code&gt;/usr/share/cracklib&lt;/code&gt;, and you may see the following error when attempting to use the &lt;code&gt;cracklib_password_check&lt;/code&gt; plugin:</source>
          <target state="translated">&lt;a href=&quot;../selinux/index#changing-selinuxs-mode&quot;&gt;모드&lt;/a&gt; 가 &lt;code&gt;enforcing&lt;/code&gt; 으로 설정된 표준 &lt;a href=&quot;../selinux/index&quot;&gt;SELinux&lt;/a&gt; 정책을 사용하는 경우 &lt;code&gt;mysqld&lt;/code&gt; 는 &lt;code&gt;/usr/share/cracklib&lt;/code&gt; 에 액세스 할 수 없으며 &lt;code&gt;cracklib_password_check&lt;/code&gt; 플러그인 을 사용하려고하면 다음 오류가 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a13b09c0f25303a30628a49205a0dfa8043f591d" translate="yes" xml:space="preserve">
          <source>When using this format, the table is processed by CONNECT like a DOS, CSV or FMT table. Rows are retrieved and parsed by records and the table can be very large. Another advantage is that such a table can be indexed, which can be of great value for very large tables. The &amp;ldquo;distrib&amp;rdquo; option of the &amp;ldquo;state&amp;rdquo; column tells CONNECT to use block indexing when possible.</source>
          <target state="translated">이 형식을 사용할 때 테이블은 DOS, CSV 또는 FMT 테이블과 같이 CONNECT에 의해 처리됩니다. 레코드가 행을 검색하고 구문 분석하며 테이블이 매우 클 수 있습니다. 또 다른 장점은 이러한 테이블을 인덱싱 할 수 있다는 것인데, 이는 매우 큰 테이블에 큰 가치가있을 수 있습니다. &amp;ldquo;state&amp;rdquo;열의&amp;ldquo;distrib&amp;rdquo;옵션은 가능한 경우 CONNECT가 블록 인덱싱을 사용하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="0b5a31ed3e04eb68baab74f83667d424647a850e" translate="yes" xml:space="preserve">
          <source>When using this option, Mariabackup records its operation in a table on the MariaDB Server. Passing a name to this option allows you group backups under arbitrary terms for later processing and analysis.</source>
          <target state="translated">이 옵션을 사용하면 Mariabackup은 MariaDB 서버의 테이블에 작업을 기록합니다. 이 옵션에 이름을 전달하면 나중에 처리 및 분석 할 수 있도록 임의의 용어로 백업을 그룹화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b16e7963b2c2495bffacb7c4ae345112bc0c3b4" translate="yes" xml:space="preserve">
          <source>When using this option, you should keep in mind that only InnoDB tables are dumped in a consistent state. The single-transaction feature depends not only on the engine being transactional and capable of REPEATABLE-READ, but also on START TRANSACTION WITH CONSISTENT SNAPSHOT. The dump is &lt;strong&gt;not&lt;/strong&gt; guaranteed to be consistent for other storage engines. For example, any &lt;a href=&quot;../tokudb/index&quot;&gt;TokuDB&lt;/a&gt;, &lt;a href=&quot;../myisam/index&quot;&gt;MyISAM&lt;/a&gt; or &lt;a href=&quot;../memory-storage-engine/index&quot;&gt;MEMORY&lt;/a&gt; tables dumped while using this option may still change state.</source>
          <target state="translated">이 옵션을 사용할 때 InnoDB 테이블 만 일관성있는 상태로 덤프됩니다. 단일 트랜잭션 기능은 트랜잭션 및 반복 읽기가 가능한 엔진뿐만 아니라 일관성있는 스냅 샷으로 트랜잭션 시작에 달려 있습니다. 덤프는 다른 스토리지 엔진에 대해 일관성이 보장 &lt;strong&gt;되지 않습니다&lt;/strong&gt; . 예를 &lt;a href=&quot;../tokudb/index&quot;&gt;들어이&lt;/a&gt; 옵션을 사용하는 동안 덤프 된 TokuDB , &lt;a href=&quot;../myisam/index&quot;&gt;MyISAM&lt;/a&gt; 또는 &lt;a href=&quot;../memory-storage-engine/index&quot;&gt;MEMORY&lt;/a&gt; 테이블은 여전히 ​​상태를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="71fbbf1c591c8c3d4344bfe42c3ee14fbe5c6cbc" translate="yes" xml:space="preserve">
          <source>When values from different columns are compared, the comparison runs more quickly when the columns are of the same character set and collation. If they are different, the strings need to be converted while the query runs. So, where possible, declare string columns using the same character set and collation when you may need to compare them.</source>
          <target state="translated">다른 열의 값을 비교할 때 열의 문자 집합 및 데이터 정렬이 동일한 경우 비교가 더 빨리 실행됩니다. 서로 다른 경우 쿼리가 실행되는 동안 문자열을 변환해야합니다. 따라서 가능하면 문자열 열을 비교해야 할 때 동일한 문자 집합과 데이터 정렬을 사용하여 선언하십시오.</target>
        </trans-unit>
        <trans-unit id="82840efc6857767655e62a00dab571fe5bb26484" translate="yes" xml:space="preserve">
          <source>When working with a segmented key cache any key cache interface function that needs only one page has to acquire the key cache lock only for the segment the page is assigned to. This makes the chances for threads not having to compete for the same key cache lock better.</source>
          <target state="translated">세그먼트 키 캐시로 작업 할 때 한 페이지 만 필요한 키 캐시 인터페이스 기능은 페이지가 지정된 세그먼트에 대해서만 키 캐시 잠금을 획득해야합니다. 따라서 스레드가 동일한 키 캐시 잠금을 위해 경쟁하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="690d0f74dd4f695a1dc1052d25b244e132333a8f" translate="yes" xml:space="preserve">
          <source>When working with internal temporary tables written to disk, Aria encrypts them to disk using the ID 2 key, unless there is no ID 2 key, then it falls back on the ID 1 key.</source>
          <target state="translated">디스크에 기록 된 내부 임시 테이블로 작업 할 때 Aria는 ID 2 키가없는 경우 ID 2 키를 사용하여 디스크로 디스크에 암호화합니다. 그러면 ID 1 키로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="61e8374e64a6c2a02f1133d3997c4604a1ef79e4" translate="yes" xml:space="preserve">
          <source>When working with user-created tables, Aria encrypts them to disk using the ID 1 key.</source>
          <target state="translated">사용자가 만든 테이블로 작업 할 때 Aria는 ID 1 키를 사용하여 테이블을 디스크에 암호화합니다.</target>
        </trans-unit>
        <trans-unit id="af96bedf1ab43ac1f0fc62e1a277846a1b35e4a5" translate="yes" xml:space="preserve">
          <source>When would `meta_key` or `meta_value` ever be NULL?</source>
          <target state="translated">'meta_key'또는 'meta_value'는 언제 NULL이됩니까?</target>
        </trans-unit>
        <trans-unit id="5f3edb03f97105d6a74a9c9cce8c85433643550b" translate="yes" xml:space="preserve">
          <source>When you add a constraint to a table, whether through a &lt;code&gt;&lt;a href=&quot;../create-table/index#constraint-expressions&quot;&gt;CREATE TABLE&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#add-constraint&quot;&gt;ALTER TABLE...ADD CONSTRAINT&lt;/a&gt;&lt;/code&gt; statement, you can either set a &lt;code&gt;constraint_name&lt;/code&gt; yourself, or allow MariaDB to auto-generate one for you. To view constraints on a table, query &lt;code&gt;&lt;a href=&quot;../information-schema-table_constraints-table/index&quot;&gt;information_schema.TABLE_CONSTRAINTS&lt;/a&gt;&lt;/code&gt;. For instance,</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../create-table/index#constraint-expressions&quot;&gt;CREATE TABLE&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#add-constraint&quot;&gt;ALTER TABLE...ADD CONSTRAINT&lt;/a&gt;&lt;/code&gt; 문을 통해 테이블에 제약 조건을 추가 할 때 &lt;code&gt;constraint_name&lt;/code&gt; 을 직접 설정 하거나 MariaDB가 자동으로 생성하도록 할 수 있습니다. 테이블에서 제한 조건을 보려면 &lt;code&gt;&lt;a href=&quot;../information-schema-table_constraints-table/index&quot;&gt;information_schema.TABLE_CONSTRAINTS&lt;/a&gt;&lt;/code&gt; 를 쿼리 하십시오 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="e0311bdc307ac0b0477e7acd488b4e8244af5173" translate="yes" xml:space="preserve">
          <source>When you are installing a plugin, you also have to ensure that:</source>
          <target state="translated">플러그인을 설치할 때 다음을 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="f77fb8d3f81d3840e870dafaadcb6b45931c9626" translate="yes" xml:space="preserve">
          <source>When you are troubleshooting issues that you think SELinux might be causing, it can help to temporarily put &lt;code&gt;mysqld_t&lt;/code&gt; into permissive mode. This can be done by executing the &lt;code&gt;&lt;a href=&quot;https://linux.die.net/man/8/semanage&quot;&gt;semanage&lt;/a&gt;&lt;/code&gt; command. For example:</source>
          <target state="translated">SELinux로 인해 발생할 수 있다고 생각되는 문제를 해결할 때 일시적으로 &lt;code&gt;mysqld_t&lt;/code&gt; 를 허용 모드로 전환하는 데 도움이 될 수 있습니다 . &lt;code&gt;&lt;a href=&quot;https://linux.die.net/man/8/semanage&quot;&gt;semanage&lt;/a&gt;&lt;/code&gt; 명령 을 실행하여 수행 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="982c2243c2f2dcccf2ab07530e2173690d7fc364" translate="yes" xml:space="preserve">
          <source>When you are using multi source, the following new files are created:</source>
          <target state="translated">다중 소스를 사용하는 경우 다음과 같은 새 파일이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="ffa44fba13cc48d1fb8ef7da356cca6f78f31039" translate="yes" xml:space="preserve">
          <source>When you commit or roll back a transaction, any locks set in the transaction are released. You don't need to issue &lt;a href=&quot;../lock-tables/index&quot;&gt;LOCK TABLES&lt;/a&gt; statements when the &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#autocommit&quot;&gt;autocommit&lt;/a&gt; is enabled, as InnoDB would immediately release the table locks.</source>
          <target state="translated">트랜잭션을 커밋하거나 롤백하면 트랜잭션에 설정된 모든 잠금이 해제됩니다. &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#autocommit&quot;&gt;자동 커밋&lt;/a&gt; 이 활성화 된 경우 InnoDB가 즉시 테이블 잠금을 해제하므로 &lt;a href=&quot;../lock-tables/index&quot;&gt;LOCK TABLES&lt;/a&gt; 문 을 실행할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="5d99edd133548c0e70249e4e1add78036162959c" translate="yes" xml:space="preserve">
          <source>When you create a table on MariaDB ColumnStore, the system creates at least one file per column in the table. So, for instance, a table created with three columns would have a minimum of three, separately addressable logical objects created on a SAN or on the local disk of a Performance Module.</source>
          <target state="translated">MariaDB ColumnStore에서 테이블을 작성할 때 시스템은 테이블의 열당 하나 이상의 파일을 작성합니다. 예를 들어, 3 개의 열로 작성된 테이블은 SAN 또는 성능 모듈의 로컬 디스크에서 작성된 주소 지정이 가능한 최소 3 개의 논리적 객체를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="c1cf29a8cad63a8e8841ba64f670d25f334ca958" translate="yes" xml:space="preserve">
          <source>When you create a table using the &lt;a href=&quot;../xtradb-and-innodb/index&quot;&gt;InnoDB storage engine&lt;/a&gt;, data written to that table is stored on the file system in a data file called a tablespace. Tablespace files contain both the data and indexes.</source>
          <target state="translated">&lt;a href=&quot;../xtradb-and-innodb/index&quot;&gt;InnoDB 스토리지 엔진을&lt;/a&gt; 사용하여 테이블을 생성하면 해당 테이블에 기록 된 데이터는 파일 시스템의 테이블 공간이라는 데이터 파일에 저장됩니다. 테이블 스페이스 파일에는 데이터와 인덱스가 모두 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="39de9176e9dcc7930d158c84cfa5fa9fa1d6a4ee" translate="yes" xml:space="preserve">
          <source>When you create a table using the CSV storage engine, three files are created:</source>
          <target state="translated">CSV 스토리지 엔진을 사용하여 테이블을 작성하면 세 개의 파일이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="c9cb8f195a9ed025f8ee530aff2ada2cdad4afae" translate="yes" xml:space="preserve">
          <source>When you create a table with FederatedX, the connection will be tested. The &lt;code&gt;CREATE&lt;/code&gt; will fail if MariaDB can't connect to the remote host or if the remote table doesn't exist.</source>
          <target state="translated">FederatedX를 사용하여 테이블을 작성하면 연결이 테스트됩니다. 는 &lt;code&gt;CREATE&lt;/code&gt; 원격 테이블이 존재하지 않는 경우 MariaDB가 원격 호스트에 연결하거나 수없는 경우 실패합니다.</target>
        </trans-unit>
        <trans-unit id="297825733fae463fe6bb20cdc63611790091a19b" translate="yes" xml:space="preserve">
          <source>When you discover any needed SELinux permissions, please report the needed permissions to your operating system bug tracking so all users can benefit from your work (e.g. Red Hat Bugzilla &lt;a href=&quot;https://bugzilla.redhat.com/&quot;&gt;https://bugzilla.redhat.com/&lt;/a&gt;).</source>
          <target state="translated">필요한 SELinux 권한을 발견하면 운영 체제 버그 추적에 필요한 권한을보고하여 모든 사용자가 작업의 혜택을 누릴 수 있도록하십시오 (예 : Red Hat Bugzilla &lt;a href=&quot;https://bugzilla.redhat.com/&quot;&gt;https://bugzilla.redhat.com/&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="e2cfc1915e8372044d07e4dd8b05c41ebc622b92" translate="yes" xml:space="preserve">
          <source>When you execute the &lt;code&gt;LOAD DATA INFILE&lt;/code&gt; statement, MariaDB Server attempts to read the input file from its own file system. In contrast, when you execute the &lt;code&gt;LOAD DATA LOCAL INFILE&lt;/code&gt; statement, the client attempts to read the input file from its file system, and it sends the contents of the input file to the MariaDB Server. This allows you to load files from the client's local file system into the database.</source>
          <target state="translated">&lt;code&gt;LOAD DATA INFILE&lt;/code&gt; 문 을 실행할 때 MariaDB 서버는 자체 파일 시스템에서 입력 파일을 읽으려고 시도합니다. 반대로 &lt;code&gt;LOAD DATA LOCAL INFILE&lt;/code&gt; 문 을 실행하면 클라이언트는 파일 시스템에서 입력 파일을 읽으려고 시도하고 입력 파일의 내용을 MariaDB 서버로 보냅니다. 이를 통해 클라이언트의 로컬 파일 시스템에서 데이터베이스로 파일을로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c54519ca4ba674aa97355aa874f6ab096ca02f78" translate="yes" xml:space="preserve">
          <source>When you got the connection to work, you should add the options to your global my.cnf file. Now you can start testing S3 from your &lt;a href=&quot;../mysql-command-line-client/index&quot;&gt;mysql command client&lt;/a&gt; by converting some existing table to S3 with &lt;a href=&quot;../using-the-s3-storage-engine/index&quot;&gt;ALTER TABLE ... ENGINE=S3&lt;/a&gt;.</source>
          <target state="translated">연결이 작동하면 전역 my.cnf 파일에 옵션을 추가해야합니다. 이제 &lt;a href=&quot;../using-the-s3-storage-engine/index&quot;&gt;ALTER TABLE ... ENGINE = S3&lt;/a&gt; 을 사용하여 일부 기존 테이블을 S3으로 변환 하여 &lt;a href=&quot;../mysql-command-line-client/index&quot;&gt;mysql 명령 클라이언트&lt;/a&gt; 에서 S3 테스트를 시작할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e51846c102308cdc5dbcbf392f0e036ec72bbef3" translate="yes" xml:space="preserve">
          <source>When you have a JOIN and a GROUP BY, you may have the situation where the JOIN exploded more rows than the original query (due to many:many), but you wanted only one row from the original table, so you added the GROUP BY to implode back to the desired set of rows.</source>
          <target state="translated">JOIN과 GROUP BY가있는 경우 JOIN이 원래 쿼리보다 많은 행을 폭발 한 상황이 발생할 수 있지만 (많은 수 : 많음) 원래 테이블에서 하나의 행만 원했기 때문에 GROUP BY를 추가했습니다. 원하는 행 집합으로 다시 시작합니다.</target>
        </trans-unit>
        <trans-unit id="fdfaa9bc00f4ca207a4c5528c71a618957af9a36" translate="yes" xml:space="preserve">
          <source>When you have millions or billions of rows, it takes a long time to summarize the data to present counts, totals, averages, etc, in a size that is readily digestible by humans. By computing and saving subtotals as the data comes in, one can make &quot;reports&quot; run much faster. (I have seen 10x to 1000x speedups.) The subtotals go into a &quot;summary table&quot;. This document guides you on efficiency in both creating and using such tables.</source>
          <target state="translated">수백만 또는 수십억 개의 행이있는 경우 데이터를 요약하여 사람이 쉽게 소화 할 수있는 크기로 수, 총계, 평균 등을 나타내는 데 시간이 오래 걸립니다. 데이터가 들어 오면 부분 합계를 계산하고 저장함으로써 &quot;보고서&quot;를 훨씬 빠르게 실행할 수 있습니다. (10 배에서 1000 배의 속도 향상을 보았습니다.) 소계는 &quot;요약 테이블&quot;에 들어갑니다. 이 문서는 이러한 테이블 작성 및 사용의 효율성에 대해 안내합니다.</target>
        </trans-unit>
        <trans-unit id="2cbd56d14fabddaf4dc84eb40b32027cdc8f18e6" translate="yes" xml:space="preserve">
          <source>When you issue a &lt;a href=&quot;../delete/index&quot;&gt;DELETE&lt;/a&gt; statement, InnoDB doesn't regenerate the table, rather it deletes each row from the table one by one.</source>
          <target state="translated">당신이 실행하면 &lt;a href=&quot;../delete/index&quot;&gt;DELETE&lt;/a&gt; 문을 InnoDB는 오히려 하나 테이블 하나에서 각 행을 삭제 테이블을 다시 생성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="666fca067a7681b6b2ddc9c01796819cdbfd62f2" translate="yes" xml:space="preserve">
          <source>When you mark an article for deletion; you &lt;em&gt;must&lt;/em&gt; remove it from Lists:</source>
          <target state="translated">기사를 삭제 표시 한 경우 당신은 &lt;em&gt;있어야합니다&lt;/em&gt; 목록에서 제거 :</target>
        </trans-unit>
        <trans-unit id="98a23ee52cdb30c0e92aa334b12850fe7276ff76" translate="yes" xml:space="preserve">
          <source>When you order by a field that may contain NULL values, any NULLs are considered to have the lowest value. So ordering in DESC order will see the NULLs appearing last. To force NULLs to be regarded as highest values, one can add another column which has a higher value when the main field is NULL. Example:</source>
          <target state="translated">NULL 값을 포함 할 수있는 필드를 기준으로 정렬하면 모든 NULL 값이 가장 낮은 것으로 간주됩니다. 따라서 DESC 순서로 주문하면 NULL이 마지막에 나타납니다. NULL을 최고 값으로 간주하기 위해 기본 필드가 NULL 일 때 더 높은 값을 갖는 다른 열을 추가 할 수 있습니다. 예:</target>
        </trans-unit>
        <trans-unit id="4f6eacfeda1dc5a01a84ae3dae4961bfaee3a75b" translate="yes" xml:space="preserve">
          <source>When you perform a shutdown, all MariaDB ColumnStore processes are stopped. This command would be used mainly when performing software upgrades.</source>
          <target state="translated">종료를 수행하면 모든 MariaDB ColumnStore 프로세스가 중지됩니다. 이 명령은 주로 소프트웨어 업그레이드를 수행 할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4bcd58836fcfc9936137341378e7d88263bd3930" translate="yes" xml:space="preserve">
          <source>When you precede a &lt;code&gt;SELECT&lt;/code&gt; statement (or, since &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1005-release-notes/&quot;&gt;MariaDB 10.0.5&lt;/a&gt;, an &lt;code&gt;UPDATE&lt;/code&gt; or a &lt;code&gt;DELETE&lt;/code&gt; as well) with the keyword &lt;code&gt;EXPLAIN&lt;/code&gt;, MariaDB displays information from the optimizer about the query execution plan. That is, MariaDB explains how it would process the &lt;code&gt;SELECT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;DELETE&lt;/code&gt;, including information about how tables are joined and in which order. &lt;code&gt;EXPLAIN EXTENDED&lt;/code&gt; can be used to provide additional information.</source>
          <target state="translated">키워드 &lt;code&gt;EXPLAIN&lt;/code&gt; 을 사용 하여 &lt;code&gt;SELECT&lt;/code&gt; 문 앞에 (또는 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1005-release-notes/&quot;&gt;MariaDB 10.0.5&lt;/a&gt; , &lt;code&gt;UPDATE&lt;/code&gt; 또는 &lt;code&gt;DELETE&lt;/code&gt; 이후) 선행하면 MariaDB는 쿼리 실행 계획에 대한 정보를 옵티 마이저로부터 표시합니다. 즉, MariaDB는 테이블이 조인되는 방법 및 순서에 대한 정보를 포함 하여 &lt;code&gt;SELECT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; 또는 &lt;code&gt;DELETE&lt;/code&gt; 를 처리하는 방법을 설명합니다 . &lt;code&gt;EXPLAIN EXTENDED&lt;/code&gt; 를 사용하여 추가 정보를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb962864ec1f6a412e236037752a41b9d0fde7ff" translate="yes" xml:space="preserve">
          <source>When you provide an offset &lt;em&gt;m&lt;/em&gt; with a limit &lt;em&gt;n&lt;/em&gt;, the first &lt;em&gt;m&lt;/em&gt; rows will be ignored, and the following &lt;em&gt;n&lt;/em&gt; rows will be returned.</source>
          <target state="translated">한계 &lt;em&gt;n을&lt;/em&gt; 가진 오프셋 &lt;em&gt;m&lt;/em&gt; 을 제공하면 첫 번째 &lt;em&gt;m&lt;/em&gt; 행이 무시되고 다음 &lt;em&gt;n&lt;/em&gt; 행이 반환됩니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="eb7c59c316f6128aba68a81dfc4f58b0ab0f5e24" translate="yes" xml:space="preserve">
          <source>When you run Mariabackup with the &lt;code&gt;&lt;a href=&quot;#-compress&quot;&gt;--compress&lt;/a&gt;&lt;/code&gt; option, it compresses the subsequent backup files, using the QuickLZ algorithm by default, (which is currently the only available compression algorithm). Using this option, Mariabackup decompresses the compressed files from a previous backup.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#-compress&quot;&gt;--compress&lt;/a&gt;&lt;/code&gt; 옵션을 사용하여 Mariabackup을 실행하면 기본적으로 QuickLZ 알고리즘 (현재 사용 가능한 압축 알고리즘)을 사용하여 후속 백업 파일을 압축합니다. Mariabackup은이 옵션을 사용하여 이전 백업에서 압축 된 파일을 압축 해제합니다.</target>
        </trans-unit>
        <trans-unit id="3b0c7cd3d109515240b4e52beb7995055af1f16e" translate="yes" xml:space="preserve">
          <source>When you run Mariabackup, it connects to MariaDB Server in order to access and back up the databases and tables. Using this option, you can set the password Mariabackup uses to access the server. To set the user, use the &lt;code&gt;&lt;a href=&quot;#-u-user&quot;&gt;--user&lt;/a&gt;&lt;/code&gt; option.</source>
          <target state="translated">Mariabackup을 실행하면 데이터베이스와 테이블에 액세스하고 백업하기 위해 MariaDB 서버에 연결됩니다. 이 옵션을 사용하면 Mariabackup이 서버에 액세스하는 데 사용하는 비밀번호를 설정할 수 있습니다. 사용자를 설정하려면 &lt;code&gt;&lt;a href=&quot;#-u-user&quot;&gt;--user&lt;/a&gt;&lt;/code&gt; 옵션을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="1b4e3945c989a0749e6c28b0462e9585452cab54" translate="yes" xml:space="preserve">
          <source>When you run Mariabackup, it connects to MariaDB Server in order to access and back up your databases and tables. Using this option, you can set the port the utility uses to access the server over TCP/IP. To set the host, see the &lt;code&gt;&lt;a href=&quot;#-h-host&quot;&gt;--host&lt;/a&gt;&lt;/code&gt; option. Use &lt;code&gt;mysql --help&lt;/code&gt; for more details.</source>
          <target state="translated">Mariabackup을 실행하면 데이터베이스와 테이블에 액세스하고 백업하기 위해 MariaDB 서버에 연결됩니다. 이 옵션을 사용하면 유틸리티가 TCP / IP를 통해 서버에 액세스하는 데 사용하는 포트를 설정할 수 있습니다. 호스트를 설정하려면 &lt;code&gt;&lt;a href=&quot;#-h-host&quot;&gt;--host&lt;/a&gt;&lt;/code&gt; 옵션을 참조하십시오 . 자세한 내용은 &lt;code&gt;mysql --help&lt;/code&gt; 를 사용 하십시오.</target>
        </trans-unit>
        <trans-unit id="fb6748d338877ee50010ea7ffc652297cf0dcbb4" translate="yes" xml:space="preserve">
          <source>When you run the &lt;code&gt;mxs_adapter&lt;/code&gt; utility, it streams logging messages about the operations it's performing to stdout. You can monitor this information to see the binary events its streaming from the MariaDB Servers to MariaDB ColumnStore.</source>
          <target state="translated">&lt;code&gt;mxs_adapter&lt;/code&gt; 유틸리티 를 실행하면 수행중인 작업에 대한 로깅 메시지가 stdout에 스트리밍됩니다. 이 정보를 모니터링하여 바이너리 이벤트가 MariaDB 서버에서 MariaDB ColumnStore로 스트리밍되는 것을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfa39b4ef16be4321695e5af2bc534f5bf5c616a" translate="yes" xml:space="preserve">
          <source>When you selectively enable or disable the effect of a group option, order is important because options are processed first to last. For example, &lt;code&gt;--disable-keys&lt;/code&gt;&lt;code&gt;--lock-tables&lt;/code&gt;&lt;code&gt;--skip-opt&lt;/code&gt; would not have the intended effect; it is the same as &lt;code&gt;--skip-opt&lt;/code&gt; by itself.</source>
          <target state="translated">그룹 옵션의 효과를 선택적으로 활성화하거나 비활성화하면 옵션이 처음부터 끝까지 처리되므로 순서가 중요합니다. 예를 들어 &lt;code&gt;--disable-keys&lt;/code&gt; &lt;code&gt;--lock-tables&lt;/code&gt; &lt;code&gt;--skip-opt&lt;/code&gt; 는 의도 한 효과가 없습니다. 자체적 으로 &lt;code&gt;--skip-opt&lt;/code&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="78a7e55a33902bfdbdbd95e1d1a58d42bc0d94fb" translate="yes" xml:space="preserve">
          <source>When you start MariaDB again, it'll read and write InnoDB data to the given disk partition instead of the file system.</source>
          <target state="translated">MariaDB를 다시 시작하면 InnoDB 데이터를 읽고 파일 시스템 대신 지정된 디스크 파티션에 씁니다.</target>
        </trans-unit>
        <trans-unit id="f7c8e119fb46ac37c834128d66452cf147d0ddaf" translate="yes" xml:space="preserve">
          <source>When you start MariaDB, the AWS KMS plugin will connect to the AWS Key Management Service and ask it to generate a new key. MariaDB will store that key on-disk in an encrypted form. The key stored on-disk cannot be used to decrypt the data; rather, on each startup, MariaDB must connect to AWS KMS and have the service decrypt the locally-stored key. The decrypted version is stored in-memory as long as the MariaDB server process is running, and that in-memory decrypted key is used to encrypt the local data.</source>
          <target state="translated">MariaDB를 시작하면 AWS KMS 플러그인이 AWS Key Management Service에 연결하여 새 키를 생성하도록 요청합니다. MariaDB는 해당 키를 디스크에 암호화 된 형태로 저장합니다. 디스크에 저장된 키는 데이터를 해독하는 데 사용할 수 없습니다. 대신, 시작할 때마다 MariaDB는 AWS KMS에 연결하고 서비스가 로컬에 저장된 키를 해독해야합니다. 암호 해독 된 버전은 MariaDB 서버 프로세스가 실행되는 한 메모리에 저장되며 메모리 내 암호 해독 키는 로컬 데이터를 암호화하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="daa8003330c3ca52cef26b6a950b55736a309ac6" translate="yes" xml:space="preserve">
          <source>When you start streaming data, the &lt;code&gt;mxs_adapter&lt;/code&gt; utility begins printing logging messages to stdout. As you add data to the MariaDB Servers, you can check this output to see binary events streaming over to ColumnStore.</source>
          <target state="translated">데이터 스트리밍을 시작하면 &lt;code&gt;mxs_adapter&lt;/code&gt; 유틸리티가 로깅 메시지를 stdout에 인쇄하기 시작합니다. MariaDB 서버에 데이터를 추가 할 때이 출력을 확인하여 이진 이벤트가 ColumnStore로 스트리밍되는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15d8532edd613488a4f8958d50e70a936252f965" translate="yes" xml:space="preserve">
          <source>When you start the MariaDB service now, the wrapper will temporarily create a socket file at the location given by the &lt;code&gt;kms_mfa_socket&lt;/code&gt; option. The wrapper will read the MFA code from the socket and will use it to authenticate to KMS. To give the MFA code, simply write the digits to the socket file using &lt;code&gt;echo&lt;/code&gt;: &lt;code&gt;echo 111676 &amp;gt; /tmp/kms_mfa_socket&lt;/code&gt;.</source>
          <target state="translated">이제 MariaDB 서비스를 시작하면 래퍼가 &lt;code&gt;kms_mfa_socket&lt;/code&gt; 옵션으로 지정된 위치에 임시로 소켓 파일을 만듭니다 . 랩퍼는 소켓에서 MFA 코드를 읽고이를 사용하여 KMS에 인증합니다. MFA 코드를 제공하려면 &lt;code&gt;echo&lt;/code&gt; : &lt;code&gt;echo 111676 &amp;gt; /tmp/kms_mfa_socket&lt;/code&gt; 사용하여 소켓 파일에 숫자를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="1edb00db629fd214f079efd7e61f12ef3ff4a763" translate="yes" xml:space="preserve">
          <source>When you use &lt;code&gt;mysqld_safe&lt;/code&gt; to start &lt;code&gt;mysqld&lt;/code&gt;, &lt;code&gt;mysqld_safe&lt;/code&gt; logs to the same destination as &lt;code&gt;mysqld&lt;/code&gt;.</source>
          <target state="translated">당신이 사용하는 경우 &lt;code&gt;mysqld_safe&lt;/code&gt; 시작 &lt;code&gt;mysqld&lt;/code&gt; 를 , &lt;code&gt;mysqld_safe&lt;/code&gt; 에의 같은 대상에 로그를 &lt;code&gt;mysqld&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="6e1fa92a6fb817efbc1accbeb0935f5c41e28059" translate="yes" xml:space="preserve">
          <source>When you use the &lt;code&gt;--safe-updates&lt;/code&gt; option, mysql issues the following statement when it connects to the MariaDB server:</source>
          <target state="translated">&lt;code&gt;--safe-updates&lt;/code&gt; 옵션 을 사용하면 mysql이 MariaDB 서버에 연결할 때 다음 명령문을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="0768497eaaae3b23b349a3c208f991ac6dbba012" translate="yes" xml:space="preserve">
          <source>When you want duplicates, but not false duplicates. Suppose &lt;code&gt;Table_1&lt;/code&gt; has three rows &amp;mdash; {&lt;code&gt;1&lt;/code&gt;,&lt;code&gt;1&lt;/code&gt;,&lt;code&gt;2&lt;/code&gt;} &amp;mdash; and &lt;code&gt;Table_2&lt;/code&gt; has two rows &amp;mdash; {&lt;code&gt;1&lt;/code&gt;,&lt;code&gt;2&lt;/code&gt;,&lt;code&gt;2&lt;/code&gt;}. If you need to list the rows in &lt;code&gt;Table_1&lt;/code&gt; which are also in &lt;code&gt;Table_2&lt;/code&gt;, only this subquery-based &lt;code&gt;SELECT&lt;/code&gt; statement will give the right answer (&lt;code&gt;1&lt;/code&gt;,&lt;code&gt;1&lt;/code&gt;,&lt;code&gt;2&lt;/code&gt;):</source>
          <target state="translated">중복을 원하지만 거짓 복제는 원하지 않습니다. &lt;code&gt;Table_1&lt;/code&gt; 에 { &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; }의 세 행이 있고 &lt;code&gt;Table_2&lt;/code&gt; 에 { &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; }의 두 행 이 있다고 가정 합니다. 당신이 행 나열해야하는 경우 &lt;code&gt;Table_1&lt;/code&gt; 에서 또한 &lt;code&gt;Table_2&lt;/code&gt; 을 만이 하위 쿼리 기반의 &lt;code&gt;SELECT&lt;/code&gt; 문은 정답 (줄 것이다 &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="dd41d145ce6c3125a8a6fdc571e4d31032565a31" translate="yes" xml:space="preserve">
          <source>When you want to change the &lt;a href=&quot;../relay-log/index&quot;&gt;relay log&lt;/a&gt; position, you only need to stop the &lt;a href=&quot;../replication-threads/index#slave-sql-thread&quot;&gt;slave's SQL thread&lt;/a&gt;. The &lt;a href=&quot;../replication-threads/index#slave-io-thread&quot;&gt;slave's I/O thread&lt;/a&gt; can continue running. The &lt;code&gt;&lt;a href=&quot;../stop-slave/index&quot;&gt;STOP SLAVE&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../start-slave/index&quot;&gt;START SLAVE&lt;/a&gt;&lt;/code&gt; statements support the &lt;code&gt;SQL_THREAD&lt;/code&gt; option for this scenario. For example:</source>
          <target state="translated">&lt;a href=&quot;../relay-log/index&quot;&gt;릴레이 로그&lt;/a&gt; 위치 를 변경 하려면 &lt;a href=&quot;../replication-threads/index#slave-sql-thread&quot;&gt;슬레이브의 SQL 스레드&lt;/a&gt; 만 중지하면됩니다 . &lt;a href=&quot;../replication-threads/index#slave-io-thread&quot;&gt;슬레이브의 I / O 스레드&lt;/a&gt; 실행을 계속할 수 있습니다. &lt;code&gt;&lt;a href=&quot;../stop-slave/index&quot;&gt;STOP SLAVE&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../start-slave/index&quot;&gt;START SLAVE&lt;/a&gt;&lt;/code&gt; 문은 지원 &lt;code&gt;SQL_THREAD&lt;/code&gt; 의 이 시나리오에 대한 옵션을 선택합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6927d982c37f64447f69f42a7d81d615c7297fe9" translate="yes" xml:space="preserve">
          <source>When you want to see the exception. For example, suppose the question is: what books are longer than Das Kapital? These two queries are effectively almost the same:</source>
          <target state="translated">예외를보고 싶을 때 예를 들어 Das Kapital보다 어떤 책이 더 긴가? 이 두 쿼리는 사실상 거의 동일합니다.</target>
        </trans-unit>
        <trans-unit id="fdabaf3dc8245e1f8be26a2eda37c09cb8c72936" translate="yes" xml:space="preserve">
          <source>When you want to split your database load on several servers or optimize for scaling. We also suggest looking at &lt;a href=&quot;../galera/index&quot;&gt;Galera&lt;/a&gt;, a synchronous multi-master cluster.</source>
          <target state="translated">여러 서버에서 데이터베이스로드를 분할하거나 스케일링을 최적화하려는 경우. 또한 동기식 다중 마스터 클러스터 인 &lt;a href=&quot;../galera/index&quot;&gt;Galera&lt;/a&gt; 를 살펴볼 것을 제안 합니다.</target>
        </trans-unit>
        <trans-unit id="4bcc197dc728698b5bccff50345edc8ebd6249d1" translate="yes" xml:space="preserve">
          <source>When you want to stop and immediately start application processes, you can perform a restart. You restart the system or modules application processes with the following commands:</source>
          <target state="translated">응용 프로그램 프로세스를 중지하고 즉시 시작하려는 경우 재시작을 수행 할 수 있습니다. 다음 명령을 사용하여 시스템 또는 모듈 응용 프로그램 프로세스를 다시 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="8e9d8d33bbe1177c09652d69e0a512542882af2b" translate="yes" xml:space="preserve">
          <source>When you want to use data not stored in a MariaDB database.</source>
          <target state="translated">MariaDB 데이터베이스에 저장되지 않은 데이터를 사용하려는 경우</target>
        </trans-unit>
        <trans-unit id="9b63ea90124be5c0e540642c66e3c6963cd676c4" translate="yes" xml:space="preserve">
          <source>When you're ready to install MariaDB Platform X3, go to &lt;a href=&quot;https://mariadb.com/downloads&quot;&gt;Downloads&lt;/a&gt; and select Platform X3. If you use an RPM or APT based distribution of Linux, you can configure your server repositories to install it through the package manager.</source>
          <target state="translated">MariaDB 플랫폼 X3을 설치할 준비가되면 &lt;a href=&quot;https://mariadb.com/downloads&quot;&gt;다운로드&lt;/a&gt; 로 이동하여 플랫폼 X3을 선택하십시오. Linux의 RPM 또는 APT 기반 배포를 사용하는 경우 패키지 관리자를 통해 서버 저장소를 설치하도록 서버 저장소를 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf9d22a7c16bc39c7adad2eb53be651582ee0715" translate="yes" xml:space="preserve">
          <source>When your application issues queries to Platform X3 for HTAP operations, it doesn't connect to either the MariaDB Servers or to the MariaDB ColumnStore User Modules directly. Instead, it connects to a MaxScale server configured to selectively routes queries, ensuring that OLTP operations execute on MariaDB Servers and OLAP operations execute on ColumnStore.</source>
          <target state="translated">응용 프로그램이 HTAP 작업을 위해 Platform X3에 쿼리를 발행하면 MariaDB 서버 또는 MariaDB ColumnStore 사용자 모듈에 직접 연결되지 않습니다. 대신 쿼리를 선택적으로 라우팅하도록 구성된 MaxScale 서버에 연결하여 OLTP 작업이 MariaDB 서버에서 실행되고 OLAP 작업이 ColumnStore에서 실행되도록합니다.</target>
        </trans-unit>
        <trans-unit id="596a206f79d416afa8ded5e04beca909c953fdec" translate="yes" xml:space="preserve">
          <source>Whenever InnoDB flushes a page to disk, it is first written to the double write buffer. Only when the buffer is safely flushed to disk will InnoDB write the page to the final destination. When recovering, InnoDB scans the double write buffer and for each valid page in the buffer checks if the page in the data file is valid too.</source>
          <target state="translated">InnoDB가 페이지를 디스크로 플러시 할 때마다 먼저 이중 쓰기 버퍼에 기록됩니다. 버퍼가 디스크로 안전하게 플러시 될 때만 InnoDB가 페이지를 최종 대상에 씁니다. 복구시 InnoDB는 이중 쓰기 버퍼를 스캔하고 버퍼의 각 유효한 페이지에 대해 데이터 파일의 페이지도 유효한지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="ade9fd3b19e13cf24d601e390012985cf47afb3e" translate="yes" xml:space="preserve">
          <source>Whenever an Innodb datafile is opened, a special &lt;code&gt;ioctl()&lt;/code&gt; is issued to switch on atomic writes. If the call fails, an error is logged and returned to the caller. This means that if the system tablespace is not located on an atomic write capable device or filesystem, InnoDB/XtraDB will refuse to start.</source>
          <target state="translated">Innodb 데이터 파일이 열릴 때마다 특별한 &lt;code&gt;ioctl()&lt;/code&gt; 이 발행되어 원자 쓰기를 켭니다. 호출이 실패하면 오류가 기록되고 호출자에게 반환됩니다. 즉, 시스템 테이블 스페이스가 자동 쓰기 가능 장치 또는 파일 시스템에 없으면 InnoDB / XtraDB는 시작을 거부합니다.</target>
        </trans-unit>
        <trans-unit id="3514a898dae0434314d279aeeb79c16a3d39ee65" translate="yes" xml:space="preserve">
          <source>Whenever possible, the fixed format should be preferred to the varying one because it is much faster to deal with fixed tables than with variable tables. Sure enough, instead of being read or written record by record, FIX tables are processed by blocks of &lt;code&gt;BLOCK_SIZE&lt;/code&gt; records, resulting in far less input/output operations to execute. The block size defaults to 100 if not specified in the Create Table statement.</source>
          <target state="translated">가능할 때마다 가변 형식보다 고정 테이블을 처리하는 것이 훨씬 빠르기 때문에 고정 형식이 가변 형식보다 선호되어야합니다. 레코드별로 레코드를 읽거나 쓰는 대신 FIX 테이블은 &lt;code&gt;BLOCK_SIZE&lt;/code&gt; 레코드 블록으로 처리 되므로 입력 / 출력 작업을 훨씬 적게 수행 할 수 있습니다. 테이블 작성 명령문에 지정되지 않은 경우 블록 크기는 기본적으로 100입니다.</target>
        </trans-unit>
        <trans-unit id="4fe69a0d53fb8189cb4e2ff6146dae5dcefb6637" translate="yes" xml:space="preserve">
          <source>Whenever the above PAM service is used, the output of the script will be written to &lt;code&gt;/tmp/pam_output.txt&lt;/code&gt;. It may look similar to this:</source>
          <target state="translated">위의 PAM 서비스를 사용할 때마다 스크립트 출력이 &lt;code&gt;/tmp/pam_output.txt&lt;/code&gt; 에 기록됩니다 . 다음과 유사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="abf0557554a808291e41f23e62ee0328aad3fb71" translate="yes" xml:space="preserve">
          <source>Whenever you change the value on the &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encrypt_tables&quot;&gt;innodb_encrypt_tables&lt;/a&gt;&lt;/code&gt; system variable, InnoDB's background encryption threads perform the necessary encryption or decryption operations. Because of this, you must have a non-zero value set for the &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encryption_threads&quot;&gt;innodb_encryption_threads&lt;/a&gt;&lt;/code&gt; system variable. InnoDB also considers these operations to be key rotations internally. Because of this, you must have a non-zero value set for the &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encryption_rotate_key_age&quot;&gt;innodb_encryption_rotate_key_age&lt;/a&gt;&lt;/code&gt; system variable. For more information, see &lt;a href=&quot;#disabling-background-key-rotation-operations&quot;&gt;disabling key rotations&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encrypt_tables&quot;&gt;innodb_encrypt_tables&lt;/a&gt;&lt;/code&gt; 시스템 변수 의 값을 변경할 때마다 InnoDB의 백그라운드 암호화 스레드는 필요한 암호화 또는 암호 해독 작업을 수행합니다. 이 때문에 &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encryption_threads&quot;&gt;innodb_encryption_threads&lt;/a&gt;&lt;/code&gt; 시스템 변수에 0이 아닌 값이 설정되어 있어야 합니다. InnoDB는 또한 이러한 작업을 내부적으로 키 회전으로 간주합니다. 이 때문에 &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encryption_rotate_key_age&quot;&gt;innodb_encryption_rotate_key_age&lt;/a&gt;&lt;/code&gt; 시스템 변수에 0이 아닌 값을 설정해야합니다 . 자세한 내용은 &lt;a href=&quot;#disabling-background-key-rotation-operations&quot;&gt;키 회전 비활성화를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="579e627eecc2efa0f961a25b4668817fe7602a38" translate="yes" xml:space="preserve">
          <source>Where &quot;n&quot; is the number of incremental backups to store. (Default: 3)</source>
          <target state="translated">여기서 &quot;n&quot;은 저장할 증분 백업의 수입니다. (기본값 : 3)</target>
        </trans-unit>
        <trans-unit id="f82460e253c7e9173f9ec63bfe07f52e706deb38" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;$BASEDIR&lt;/code&gt; is set by the &lt;code&gt;--basedir&lt;/code&gt; option, &lt;code&gt;$PWD&lt;/code&gt; is the current working directory where &lt;code&gt;mysqld_safe&lt;/code&gt; was invoked, and &lt;code&gt;@libexecdir@&lt;/code&gt; is set at compile-time by the &lt;code&gt;INSTALL_BINDIR&lt;/code&gt; option for &lt;code&gt;&lt;a href=&quot;../generic-build-instructions/index#using-cmake&quot;&gt;cmake&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">어디 &lt;code&gt;$BASEDIR&lt;/code&gt; 에 의해 설정되어 &lt;code&gt;--basedir&lt;/code&gt; 옵션, &lt;code&gt;$PWD&lt;/code&gt; 현재 작업 디렉토리입니다 &lt;code&gt;mysqld_safe&lt;/code&gt; 에가 와, 호출 &lt;code&gt;@libexecdir@&lt;/code&gt; 에 의해 컴파일시에 설정되어 &lt;code&gt;INSTALL_BINDIR&lt;/code&gt; 에 대한 옵션 &lt;code&gt;&lt;a href=&quot;../generic-build-instructions/index#using-cmake&quot;&gt;cmake&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0b5d890e94cedf9a897b91cfc7d273260195c577" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;$BASEDIR&lt;/code&gt; is set by the &lt;code&gt;--basedir&lt;/code&gt; option, and &lt;code&gt;@localstatedir@&lt;/code&gt; is set at compile-time by the &lt;code&gt;INSTALL_MYSQLDATADIR&lt;/code&gt; option for &lt;code&gt;&lt;a href=&quot;../generic-build-instructions/index#using-cmake&quot;&gt;cmake&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;$BASEDIR&lt;/code&gt; 은 &lt;code&gt;--basedir&lt;/code&gt; 옵션으로 설정되고 &lt;code&gt;@localstatedir@&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;../generic-build-instructions/index#using-cmake&quot;&gt;cmake&lt;/a&gt;&lt;/code&gt; 의 &lt;code&gt;INSTALL_MYSQLDATADIR&lt;/code&gt; 옵션으로 컴파일 타임에 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="6ba66659e8c2d826d0d008da60ee3f47d52acb11" translate="yes" xml:space="preserve">
          <source>Where can I find documentation and help about Aria?</source>
          <target state="translated">Aria에 대한 문서와 도움을 어디서 찾을 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="e31ffa0f7d42d2d36e512774bdf31f5bcbd805aa" translate="yes" xml:space="preserve">
          <source>Where can I get FederatedX</source>
          <target state="translated">FederatedX는 어디서 구할 수 있습니까</target>
        </trans-unit>
        <trans-unit id="5a5665796bbca1c947bba16f09ae1e2bf3fad457" translate="yes" xml:space="preserve">
          <source>Where character-string has zero or more characters; identifier has one or more characters; attribute- keyword is not case-sensitive; attribute-value may be case-sensitive; and the value of the DSN keyword does not consist solely of blanks. Due to the connection string grammar, keywords and attribute values that contain the characters &lt;code&gt;[]{}(),;?*=!@&lt;/code&gt; should be avoided. The value of the DSN keyword cannot consist only of blanks, and should not contain leading blanks. Because of the grammar of the system information, keywords and data source names cannot contain the backslash (\) character. Applications do not have to add braces around the attribute value after the DRIVER keyword unless the attribute contains a semicolon (;), in which case the braces are required. If the attribute value that the driver receives includes the braces, the driver should not remove them, but they should be part of the returned connection string.</source>
          <target state="translated">character-string에 0 개 이상의 문자가있는 경우 식별자에는 하나 이상의 문자가 있습니다. attribute- 키워드는 대소 문자를 구분하지 않습니다. 속성 값은 대소 문자를 구분할 수 있습니다. DSN 키워드의 값은 공백으로 만 구성되지 않습니다. 연결 문자열 문법으로 인해 &lt;code&gt;[]{}(),;?*=!@&lt;/code&gt; 문자를 포함하는 키워드 및 속성 값피해야합니다. DSN 키워드의 값은 공백으로 만 구성 할 수 없으며 선행 공백을 포함해서는 안됩니다. 시스템 정보의 문법으로 인해 키워드 및 데이터 소스 이름에는 백 슬래시 (\) 문자를 사용할 수 없습니다. 속성에 세미콜론 (;)이 포함되지 않은 경우 (중괄호가 필요한 경우) 애플리케이션은 DRIVER 키워드 다음에 속성 값 주위에 중괄호를 추가 할 필요가 없습니다. 드라이버가받는 속성 값에 중괄호가 포함되어 있으면 드라이버는이를 제거하지 말고 반환 된 연결 문자열의 일부 여야합니다.</target>
        </trans-unit>
        <trans-unit id="0da1060ba88ba47de7c917a0cceac86b432abe42" translate="yes" xml:space="preserve">
          <source>Where it is an option, it is recommended to use bare metal servers for additional performance since ColumnStore will fully consume CPU cores and memory.</source>
          <target state="translated">옵션 인 경우 ColumnStore는 CPU 코어와 메모리를 완전히 소비하므로 추가 성능을 위해 베어 메탈 서버를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8fbfe83e1592fbf8d0fbcecfc332e3cba3a39dcc" translate="yes" xml:space="preserve">
          <source>Where sum_foo2 is SUM(foo * foo) from the summary table. sum_foo and sum_foo2 should be FLOAT. FLOAT gives you about 7 significant digits, which is more than enough for things like average and standard deviation. FLOAT occupies 4 bytes. DOUBLE would give you more precision, but occupies 8 bytes. INT and BIGINT are not practical because they may lead to complaints about overflow.</source>
          <target state="translated">여기서 sum_foo2는 요약 테이블의 SUM (foo * foo)입니다. sum_foo 및 sum_foo2는 FLOAT 여야합니다. FLOAT는 약 7 자리의 유효 숫자를 제공하며 이는 평균 및 표준 편차와 같은 것들에 충분합니다. FLOAT는 4 바이트를 차지합니다. DOUBLE은 더 정밀하지만 8 바이트를 차지합니다. INT 및 BIGINT는 오버플로에 대한 불만을 야기 할 수 있으므로 실용적이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="51a806291a09c9b7e246ccbf18333a74b8d3d28c" translate="yes" xml:space="preserve">
          <source>Where t1 is an ODBC table, t2 is a locally defined table that must exist on the local server. Besides, it is a good way to create a distant ODBC table from local data.</source>
          <target state="translated">t1이 ODBC 테이블 인 경우 t2는 로컬 서버에 존재해야하는 로컬로 정의 된 테이블입니다. 또한 로컬 데이터에서 먼 ODBC 테이블을 만드는 좋은 방법입니다.</target>
        </trans-unit>
        <trans-unit id="16fab3fd91764772031186dffa1762669aee0aa8" translate="yes" xml:space="preserve">
          <source>Where the index part starts in the row.</source>
          <target state="translated">인덱스 부분이 행에서 시작되는 위치</target>
        </trans-unit>
        <trans-unit id="e95397db0d4d95d7982aa25390b4730f02a291a5" translate="yes" xml:space="preserve">
          <source>Where the test case can be specified as: &lt;code&gt;testcase[.test]&lt;/code&gt; Runs the test case named 'testcase' from all suits</source>
          <target state="translated">테스트 케이스를 &lt;code&gt;testcase[.test]&lt;/code&gt; 지정할 수있는 위치 : testcase [.test] 모든 슈트에서 'testcase'라는 테스트 케이스를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="837a2a5ee71c844d90f446fa084ad1bef900ccbe" translate="yes" xml:space="preserve">
          <source>Where things become more difficult is when trying to delete or insert an author of a book. Indeed, a delete command will delete the whole book and an insert command will add a new complete row instead of adding a new author in the same array. Here we are penalized by the SQL language that cannot give us a way to specify this. Something like:</source>
          <target state="translated">더 어려운 곳은 책의 저자를 삭제하거나 삽입하려고 할 때입니다. 실제로, 삭제 명령은 전체 책을 삭제하고 삽입 명령은 동일한 배열에 새 저자를 추가하는 대신 완전한 완전한 행을 추가합니다. 여기서는이를 지정할 수없는 SQL 언어에 의해 처벌을받습니다. 다음과 같은 것 :</target>
        </trans-unit>
        <trans-unit id="737a8108a744f1cc6a4622c529912e3906fa782b" translate="yes" xml:space="preserve">
          <source>Where to Download MariaDB</source>
          <target state="translated">MariaDB를 다운로드 할 수있는 곳</target>
        </trans-unit>
        <trans-unit id="9a0ba7bcafa70f4d409393a9ed1fb82fa889c91e" translate="yes" xml:space="preserve">
          <source>Where to Install</source>
          <target state="translated">설치 장소</target>
        </trans-unit>
        <trans-unit id="e5a2bb5a70d269b4b046c04e2c8fa15c72835d60" translate="yes" xml:space="preserve">
          <source>Where to get it</source>
          <target state="translated">어디서 구할 수 있습니까</target>
        </trans-unit>
        <trans-unit id="f19d03c2931bae3476a2ace072a14cd7c8bb432c" translate="yes" xml:space="preserve">
          <source>Where to include the additional information.</source>
          <target state="translated">추가 정보를 포함 할 위치</target>
        </trans-unit>
        <trans-unit id="306c1746a2296a18da8dad1dced4f1250323f9ae" translate="yes" xml:space="preserve">
          <source>Where two rows match the unique keys match, only the first is updated. This can be unsafe and is not recommended unless you are certain what you are doing. Note that the warning shown below appears in &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt; and before, but has been removed in &lt;a href=&quot;../what-is-mariadb-100/index&quot;&gt;MariaDB 10.0&lt;/a&gt;, as MariaDB now assumes that the keys are checked in order, as shown in &lt;a href=&quot;../show-create-table/index&quot;&gt;SHOW CREATE TABLE&lt;/a&gt;.</source>
          <target state="translated">두 개의 행이 고유 키와 일치하면 첫 번째 행만 업데이트됩니다. 이것은 안전하지 않을 수 있으며 수행중인 작업이 확실하지 않으면 권장되지 않습니다. 아래 표시된 경고는 &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt; 및 그 이전 버전에 나타나지만 MariaDB는 이제 &lt;a href=&quot;../show-create-table/index&quot;&gt;SHOW CREATE TABLE에&lt;/a&gt; 표시된대로 키가 순서대로 확인 된 것으로 가정하므로 MariaDB &lt;a href=&quot;../what-is-mariadb-100/index&quot;&gt;10.0&lt;/a&gt; 에서는 제거되었습니다 .</target>
        </trans-unit>
        <trans-unit id="70e38ade0cf9422f7a8959865bff69c18dbe73c9" translate="yes" xml:space="preserve">
          <source>Where's the problem? Performance. Your web page is doing &quot;SELECT ... OFFSET 49990 LIMIT 10&quot; (or the equivalent &quot;LIMIT 49990,10&quot;). MariaDB has to find all 50,000 rows, step over the first 49,990, then deliver the 10 for that distant page.</source>
          <target state="translated">문제는 어디에 있습니까? 공연. 웹 페이지에서 &quot;SELECT ... OFFSET 49990 LIMIT 10&quot;(또는 동등한 &quot;LIMIT 49990,10&quot;)을 수행하고 있습니다. MariaDB는 50,000 개의 행을 모두 찾아서 처음 49,990 개를 넘어서서 먼 페이지에 10 개를 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="8a5616146f3093aba71b2b6789e4d79a81ddd74e" translate="yes" xml:space="preserve">
          <source>Whether &lt;a href=&quot;../stored-procedures/index&quot;&gt;stored procedure&lt;/a&gt;, &lt;a href=&quot;../stored-functions/index&quot;&gt;stored function&lt;/a&gt; or, from &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1035-release-notes/&quot;&gt;MariaDB 10.3.5&lt;/a&gt;, a &lt;a href=&quot;../create-package/index&quot;&gt;package&lt;/a&gt; or &lt;a href=&quot;../create-package-body/index&quot;&gt;package body&lt;/a&gt;.</source>
          <target state="translated">여부 &lt;a href=&quot;../stored-procedures/index&quot;&gt;저장 프로 시저&lt;/a&gt; , &lt;a href=&quot;../stored-functions/index&quot;&gt;기능을 저장&lt;/a&gt; 에서, 또는 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1035-release-notes/&quot;&gt;MariaDB 10.3.5&lt;/a&gt; 하는 &lt;a href=&quot;../create-package/index&quot;&gt;패키지&lt;/a&gt; 또는 &lt;a href=&quot;../create-package-body/index&quot;&gt;패키지의 몸&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4a0fa0b8f45dc051866dac36dad336c460d71d35" translate="yes" xml:space="preserve">
          <source>Whether InnoDB supports the &lt;code&gt;&lt;a href=&quot;http://google.github.io/snappy/&quot;&gt;snappy&lt;/a&gt;&lt;/code&gt; compression algorithm.</source>
          <target state="translated">InnoDB가 &lt;code&gt;&lt;a href=&quot;http://google.github.io/snappy/&quot;&gt;snappy&lt;/a&gt;&lt;/code&gt; 압축 알고리즘을 지원하는지 여부</target>
        </trans-unit>
        <trans-unit id="41cade3334fe11473ca217eb77ab1e75ddfd2db3" translate="yes" xml:space="preserve">
          <source>Whether InnoDB supports the &lt;code&gt;&lt;a href=&quot;http://tukaani.org/xz/&quot;&gt;lzma&lt;/a&gt;&lt;/code&gt; compression algorithm.</source>
          <target state="translated">InnoDB가 &lt;code&gt;&lt;a href=&quot;http://tukaani.org/xz/&quot;&gt;lzma&lt;/a&gt;&lt;/code&gt; 압축 알고리즘을 지원하는지 여부</target>
        </trans-unit>
        <trans-unit id="32d63fb8cf0bdce06aadcbc9d261f4b27754f79a" translate="yes" xml:space="preserve">
          <source>Whether InnoDB supports the &lt;code&gt;&lt;a href=&quot;http://www.bzip.org/&quot;&gt;bzip2&lt;/a&gt;&lt;/code&gt; compression algorithm.</source>
          <target state="translated">InnoDB가 &lt;code&gt;&lt;a href=&quot;http://www.bzip.org/&quot;&gt;bzip2&lt;/a&gt;&lt;/code&gt; 압축 알고리즘을 지원하는지 여부</target>
        </trans-unit>
        <trans-unit id="cd46b55e068d5e8ff4d4132ffc209abbfc2ff661" translate="yes" xml:space="preserve">
          <source>Whether InnoDB supports the &lt;code&gt;&lt;a href=&quot;http://www.oberhumer.com/opensource/lzo/&quot;&gt;lzo&lt;/a&gt;&lt;/code&gt; compression algorithm.</source>
          <target state="translated">InnoDB가 &lt;code&gt;&lt;a href=&quot;http://www.oberhumer.com/opensource/lzo/&quot;&gt;lzo&lt;/a&gt;&lt;/code&gt; 압축 알고리즘을 지원하는지 여부</target>
        </trans-unit>
        <trans-unit id="9a4caa7befca489dc517423a9ea0953fbf105008" translate="yes" xml:space="preserve">
          <source>Whether InnoDB supports the &lt;code&gt;&lt;a href=&quot;https://code.google.com/p/lz4/&quot;&gt;lz4&lt;/a&gt;&lt;/code&gt; compression algorithm.</source>
          <target state="translated">InnoDB가 &lt;code&gt;&lt;a href=&quot;https://code.google.com/p/lz4/&quot;&gt;lz4&lt;/a&gt;&lt;/code&gt; 압축 알고리즘을 지원하는지 여부</target>
        </trans-unit>
        <trans-unit id="b38a60cefb5d5847ceaa86cbc8f3e2727a26f387" translate="yes" xml:space="preserve">
          <source>Whether a lock is granted or not can be summarised as follows:</source>
          <target state="translated">잠금 부여 여부는 다음과 같이 요약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e57e56c60f33f2a16075489940e032f5f680b766" translate="yes" xml:space="preserve">
          <source>Whether a value is a valid JSON document or not</source>
          <target state="translated">값이 유효한 JSON 문서인지 여부</target>
        </trans-unit>
        <trans-unit id="9a15aa45efa3117e4ab5891ad10702f8fdad0fa8" translate="yes" xml:space="preserve">
          <source>Whether a value is a valid JSON document or not.</source>
          <target state="translated">값이 유효한 JSON 문서인지 여부</target>
        </trans-unit>
        <trans-unit id="03991e9cba3a822eabfafc8a74f36eb245c95171" translate="yes" xml:space="preserve">
          <source>Whether a value is found in a given JSON document or at a specified path within the document</source>
          <target state="translated">주어진 JSON 문서 또는 문서 내의 지정된 경로에 값이 ​​있는지 여부</target>
        </trans-unit>
        <trans-unit id="f71b9b2f1187c43b97649676be1ffee4dbb9cb44" translate="yes" xml:space="preserve">
          <source>Whether a value is found in a given JSON document or at a specified path within the document.</source>
          <target state="translated">지정된 JSON 문서 또는 문서 내의 지정된 경로에서 값을 찾을 수 있는지 여부</target>
        </trans-unit>
        <trans-unit id="60ebd645d3a4068e2bf1488f60d84fa61032272f" translate="yes" xml:space="preserve">
          <source>Whether a variable can be set with the SQL statement. Note that many &quot;read only&quot; variables can still be set on the command line.</source>
          <target state="translated">SQL 문으로 변수를 설정할 수 있는지 여부 명령 행에서 많은 &quot;읽기 전용&quot;변수를 계속 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffa0f3566b23ce536185b624a10942b406210e7b" translate="yes" xml:space="preserve">
          <source>Whether an IPv6 address is a valid IPv4-mapped address</source>
          <target state="translated">IPv6 주소가 유효한 IPv4 매핑 주소인지 여부</target>
        </trans-unit>
        <trans-unit id="bfe08c8866d862f8de3eb8dd05a1d9b864ed8083" translate="yes" xml:space="preserve">
          <source>Whether an IPv6 address is a valid IPv4-mapped address.</source>
          <target state="translated">IPv6 주소가 유효한 IPv4 매핑 주소인지 여부</target>
        </trans-unit>
        <trans-unit id="0faf9904cf10bf5b042f3ed356370fb463e65f0c" translate="yes" xml:space="preserve">
          <source>Whether an SSL connection is permitted (&lt;code&gt;Yes&lt;/code&gt;), not permitted (&lt;code&gt;No&lt;/code&gt;) or permitted but without the slave having SSL support enabled (&lt;code&gt;Ignored&lt;/code&gt;)</source>
          <target state="translated">SSL 연결이 허용되는지 ( &lt;code&gt;Yes&lt;/code&gt; ), 허용되지 않는지 ( &lt;code&gt;No&lt;/code&gt; ) 또는 허용되지만 슬레이브가 SSL을 지원하지 않는지 ( &lt;code&gt;Ignored&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="cedfadbdebf1413e9a3ba044588b6b4ff2aab0f3" translate="yes" xml:space="preserve">
          <source>Whether an argument is required when setting the variable on the command line. &lt;code&gt;NULL&lt;/code&gt; when a variable can not be set on the command line.</source>
          <target state="translated">명령 행에서 변수를 설정할 때 인수가 필요한지 여부 명령 행에서 변수를 설정할 수없는 경우 &lt;code&gt;NULL&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a521cf242f6ef60a8554561230a839db200734c2" translate="yes" xml:space="preserve">
          <source>Whether an index value is unique or not. Either &lt;em&gt;multip.&lt;/em&gt; or &lt;em&gt;unique&lt;/em&gt;.</source>
          <target state="translated">인덱스 값이 고유한지 여부 어느 &lt;em&gt;multip. &lt;/em&gt;또는 &lt;em&gt;고유&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="79f13d7a7b3425b9940214e9cd7b9663dcf3a824" translate="yes" xml:space="preserve">
          <source>Whether concurrent inserts can be used or not depends on the value of the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#concurrent_insert&quot;&gt;concurrent_insert&lt;/a&gt;&lt;/code&gt; server system variable:</source>
          <target state="translated">동시 삽입을 사용할 수 있는지 여부를하면의 값에 따라 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#concurrent_insert&quot;&gt;concurrent_insert&lt;/a&gt;&lt;/code&gt; 의 서버 시스템 변수 :</target>
        </trans-unit>
        <trans-unit id="23e7e29487c17f589a9e7a3dd3d69a86fc3dc3b1" translate="yes" xml:space="preserve">
          <source>Whether expression matches a pattern</source>
          <target state="translated">표현식이 패턴과 일치하는지 여부</target>
        </trans-unit>
        <trans-unit id="852592a3d55f3005fce100f995121dc164517715" translate="yes" xml:space="preserve">
          <source>Whether expression matches a pattern.</source>
          <target state="translated">표현식이 패턴과 일치하는지 여부</target>
        </trans-unit>
        <trans-unit id="68b66e348145b63b46c2c97d1ea1c9e603efe048" translate="yes" xml:space="preserve">
          <source>Whether foreign key checks are &lt;code&gt;on&lt;/code&gt; or &lt;code&gt;off&lt;/code&gt; for the current transaction. Bulk data are a case where foreign keys checks would be off.</source>
          <target state="translated">외래 키 검사 여부 &lt;code&gt;on&lt;/code&gt; 또는 &lt;code&gt;off&lt;/code&gt; 현재의 트랜잭션 (transaction)에 대한. 벌크 데이터는 외래 키 검사가 해제 된 경우입니다.</target>
        </trans-unit>
        <trans-unit id="527d2b3f32d7ec54cd49afafa111510776923d81" translate="yes" xml:space="preserve">
          <source>Whether objects are case-sensitive or not is partly determined by the under...</source>
          <target state="translated">객체가 대소 문자를 구분하는지 여부는 부분적으로 아래에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="0e6d3a065e7a9d18a89ecb5e82a0d63aff7cc33d" translate="yes" xml:space="preserve">
          <source>Whether objects are case-sensitive or not is partly determined by the underlying operating system. Unix-based systems are case-sensitive, Windows is not, while Mac OS X is usually not, but can be if UFS volumes are used.</source>
          <target state="translated">개체가 대 / 소문자를 구분하는지 여부는 기본 운영 체제에 의해 부분적으로 결정됩니다. 유닉스 기반 시스템은 대소 문자를 구분하며 Windows는 그렇지 않지만 Mac OS X는 일반적으로 그렇지 않지만 UFS 볼륨이 사용되는 경우도 있습니다.</target>
        </trans-unit>
        <trans-unit id="51186837dec567f0a6e2e62e49b98e568ecac71c" translate="yes" xml:space="preserve">
          <source>Whether one geometry contains another</source>
          <target state="translated">한 형상에 다른 형상이 포함되어 있는지 여부</target>
        </trans-unit>
        <trans-unit id="c3110edc2b44728f2b7a8343c77ee9cad3601669" translate="yes" xml:space="preserve">
          <source>Whether one geometry contains another.</source>
          <target state="translated">한 형상에 다른 형상이 포함되어 있는지 여부</target>
        </trans-unit>
        <trans-unit id="b9e624adbbffed537d32fcae849e16c78c18594c" translate="yes" xml:space="preserve">
          <source>Whether one geometry g1 spatially touches another</source>
          <target state="translated">한 형상 g1이 다른 형상과 공간적으로 접촉하는지 여부</target>
        </trans-unit>
        <trans-unit id="1c9c2f2a9e87ca5b2b0beaeadddf2cdd629217d0" translate="yes" xml:space="preserve">
          <source>Whether one geometry g1 spatially touches another.</source>
          <target state="translated">한 형상 g1이 다른 형상과 공간적으로 접촉하는지 여부</target>
        </trans-unit>
        <trans-unit id="945a8eb7794cf060e2077b09a696f910434a6660" translate="yes" xml:space="preserve">
          <source>Whether one geometry is contained by another</source>
          <target state="translated">한 형상이 다른 형상에 포함되는지 여부</target>
        </trans-unit>
        <trans-unit id="374cdcfb4930546e3555ad15a54d9b5156fab6ea" translate="yes" xml:space="preserve">
          <source>Whether one geometry is contained by another.</source>
          <target state="translated">한 형상이 다른 형상에 포함되는지 여부</target>
        </trans-unit>
        <trans-unit id="a7cfd9ed14bc3a3a5627c36aef6e96c2439aaa35" translate="yes" xml:space="preserve">
          <source>Whether one geometry is spatially disjoint from another</source>
          <target state="translated">한 형상이 다른 형상과 공간적으로 분리되어 있는지 여부</target>
        </trans-unit>
        <trans-unit id="7dcec598a9ab2cde48a0c0dd8a4beda16a47cc1c" translate="yes" xml:space="preserve">
          <source>Whether one geometry is spatially disjoint from another.</source>
          <target state="translated">한 형상이 다른 형상과 공간적으로 분리되어 있는지 여부</target>
        </trans-unit>
        <trans-unit id="e571dd0f790954cdd8b749caed7f6fa1fc3f6280" translate="yes" xml:space="preserve">
          <source>Whether one geometry is within another</source>
          <target state="translated">한 형상이 다른 형상 내에 있는지 여부</target>
        </trans-unit>
        <trans-unit id="c2a887822890557adcc6140e9f47779106a557c6" translate="yes" xml:space="preserve">
          <source>Whether one geometry is within another.</source>
          <target state="translated">한 형상이 다른 형상 내에 있는지 여부</target>
        </trans-unit>
        <trans-unit id="1cc69fcd1bb47bd590c8d765ecb5f625038bdc67" translate="yes" xml:space="preserve">
          <source>Whether or not &lt;a href=&quot;../global-transaction-id/index&quot;&gt;global transaction ID's&lt;/a&gt; are being used for replication (can be &lt;code&gt;No&lt;/code&gt;, &lt;code&gt;Slave_Pos&lt;/code&gt;, or &lt;code&gt;Current_Pos&lt;/code&gt;).</source>
          <target state="translated">&lt;a href=&quot;../global-transaction-id/index&quot;&gt;글로벌 트랜잭션 ID가&lt;/a&gt; 복제에 사용 되는지 여부 ( &lt;code&gt;No&lt;/code&gt; , &lt;code&gt;Slave_Pos&lt;/code&gt; 또는 &lt;code&gt;Current_Pos&lt;/code&gt; 일 수 있음 )</target>
        </trans-unit>
        <trans-unit id="0e174905c662188b7b4c967114a788bd337cadc9" translate="yes" xml:space="preserve">
          <source>Whether or not &lt;a href=&quot;../savepoint/index&quot;&gt;savepoints&lt;/a&gt; are supported.</source>
          <target state="translated">&lt;a href=&quot;../savepoint/index&quot;&gt;저장&lt;/a&gt; 점이 지원 되는지 여부</target>
        </trans-unit>
        <trans-unit id="ed9bcedf67a9eb4550fe9af0a2db9590687da930" translate="yes" xml:space="preserve">
          <source>Whether or not a hash index has been built on this page.</source>
          <target state="translated">이 페이지에서 해시 인덱스가 작성되었는지 여부</target>
        </trans-unit>
        <trans-unit id="a53fd1234105fbd1b35961205be0ec7c649024c9" translate="yes" xml:space="preserve">
          <source>Whether or not an IPv6 address is IPv4-compatible</source>
          <target state="translated">IPv6 주소가 IPv4와 호환되는지 여부</target>
        </trans-unit>
        <trans-unit id="327dcc6cb3397da08b68497bebe80104ae7b7967" translate="yes" xml:space="preserve">
          <source>Whether or not an IPv6 address is IPv4-compatible.</source>
          <target state="translated">IPv6 주소가 IPv4와 호환되는지 여부</target>
        </trans-unit>
        <trans-unit id="aca6a88fd5cab7dcd5c05a6f16cc36d90cfd0a37" translate="yes" xml:space="preserve">
          <source>Whether or not an expression is a valid IPv4 address</source>
          <target state="translated">식이 유효한 IPv4 주소인지 여부</target>
        </trans-unit>
        <trans-unit id="90b3dc0d77e47acf1ce510534735ac1d13692284" translate="yes" xml:space="preserve">
          <source>Whether or not an expression is a valid IPv4 address.</source>
          <target state="translated">식이 유효한 IPv4 주소인지 여부</target>
        </trans-unit>
        <trans-unit id="59d3b6ecf597b149197dfb314221906fa93c5f24" translate="yes" xml:space="preserve">
          <source>Whether or not an expression is a valid IPv6 address</source>
          <target state="translated">식이 유효한 IPv6 주소인지 여부</target>
        </trans-unit>
        <trans-unit id="03f2496f7b7f5871870087d018c07e0b47e16619" translate="yes" xml:space="preserve">
          <source>Whether or not an expression is a valid IPv6 address.</source>
          <target state="translated">식이 유효한 IPv6 주소인지 여부</target>
        </trans-unit>
        <trans-unit id="29311973e288bd65e2347256dd27985e5b2c8bdc" translate="yes" xml:space="preserve">
          <source>Whether or not leap seconds are used.</source>
          <target state="translated">윤초 사용 여부입니다.</target>
        </trans-unit>
        <trans-unit id="9aec12202065692f1658789ac87744edbd215438" translate="yes" xml:space="preserve">
          <source>Whether or not the SQL thread is running.</source>
          <target state="translated">SQL 스레드가 실행 중인지 여부</target>
        </trans-unit>
        <trans-unit id="c85cc7ac30bf67ab8af2032f154bbf998f3cecc7" translate="yes" xml:space="preserve">
          <source>Whether or not the column can be set to NULL</source>
          <target state="translated">열을 NULL로 설정할 수 있는지 여부</target>
        </trans-unit>
        <trans-unit id="76d239a119f943d6958803b84974b3c8b6db2bf3" translate="yes" xml:space="preserve">
          <source>Whether or not the engine supports &lt;a href=&quot;../transactions/index&quot;&gt;transactions&lt;/a&gt;.</source>
          <target state="translated">엔진이 &lt;a href=&quot;../transactions/index&quot;&gt;트랜잭션을&lt;/a&gt; 지원하는지 여부 .</target>
        </trans-unit>
        <trans-unit id="8bd4370a9dc5f51c0c59557c6d0ec6dbf3f35647" translate="yes" xml:space="preserve">
          <source>Whether or not the engine supports &lt;a href=&quot;../xa-transactions/index&quot;&gt;XA transactions&lt;/a&gt;.</source>
          <target state="translated">여부 엔진이 지원하는 &lt;a href=&quot;../xa-transactions/index&quot;&gt;XA 트랜잭션을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7de5075f3921937c151a1eee0b9354989f49e3ef" translate="yes" xml:space="preserve">
          <source>Whether or not the instrument is enabled. It can be disabled, and the instrument will produce no events.</source>
          <target state="translated">계측기 활성화 여부입니다. 비활성화 할 수 있으며 계측기는 이벤트를 생성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0115473248445b81a0ced24f682489ef78acdfd2" translate="yes" xml:space="preserve">
          <source>Whether or not the instrument is timed. It can be set, but if disabled, events produced by the instrument will have &lt;code&gt;NULL&lt;/code&gt; values for the corresponding &lt;code&gt;TIMER_START&lt;/code&gt;, &lt;code&gt;TIMER_END&lt;/code&gt;, and &lt;code&gt;TIMER_WAIT&lt;/code&gt; values.</source>
          <target state="translated">계측기의 시간 지정 여부입니다. 설정할 수 있지만 비활성화하면 계측기에서 생성 된 이벤트 는 해당 &lt;code&gt;TIMER_START&lt;/code&gt; , &lt;code&gt;TIMER_END&lt;/code&gt; 및 &lt;code&gt;TIMER_WAIT&lt;/code&gt; 에 대해 &lt;code&gt;NULL&lt;/code&gt; 값을 갖습니다. 값에 갖습니다.</target>
        </trans-unit>
        <trans-unit id="93704047d2797e82a09cb17e98c6b75b2dea2b66" translate="yes" xml:space="preserve">
          <source>Whether server certificate verification with &lt;strong&gt;subjectAltName&lt;/strong&gt; fields is supported depends on the underlying TLS library used by the &lt;a href=&quot;../clients-utilities/index&quot;&gt;client or utility&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;subjectAltName&lt;/strong&gt; 필드를 사용한 서버 인증서 확인 지원 여부는 &lt;a href=&quot;../clients-utilities/index&quot;&gt;클라이언트 또는 유틸리티에서&lt;/a&gt; 사용하는 기본 TLS 라이브러리에 따라 다릅니다. .</target>
        </trans-unit>
        <trans-unit id="19914311ca2fe358064cbb3c148a36ea0bb5db4d" translate="yes" xml:space="preserve">
          <source>Whether the Minimum Bounding Rectangles of two geometries are the same.</source>
          <target state="translated">두 도형의 최소 경계 사각형이 같은지 여부</target>
        </trans-unit>
        <trans-unit id="0a21a2f37e45ced849392562b6c862c0584e106f" translate="yes" xml:space="preserve">
          <source>Whether the Minimum Bounding Rectangles of two geometries overlap.</source>
          <target state="translated">두 도형의 최소 경계 사각형이 겹치는 지 여부</target>
        </trans-unit>
        <trans-unit id="620b64d7d83dd8ce09caf9400755738784e1a462" translate="yes" xml:space="preserve">
          <source>Whether the Minimum Bounding Rectangles of two geometries touch.</source>
          <target state="translated">두 도형의 최소 경계 사각형이 닿는 지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="2bd54afcbfc9eed55a0197a730cbab1a7b76c4d8" translate="yes" xml:space="preserve">
          <source>Whether the WHERE clause prevented the efficient use of the ORDER BY</source>
          <target state="translated">WHERE 절이 ORDER BY의 효율적인 사용을 방해했는지 여부</target>
        </trans-unit>
        <trans-unit id="27d0b51e29987a72ad543e61ad0fc9b3c9b883ec" translate="yes" xml:space="preserve">
          <source>Whether the adaptive hash index is locked by the current transaction or not. One transaction at a time can change the adaptive hash index.</source>
          <target state="translated">적응 트랜잭션 해시 인덱스가 현재 트랜잭션에 의해 잠겨 있는지 여부 한 번에 하나의 트랜잭션으로 적응 형 해시 인덱스를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59ba978b3ceeb404ffd15c15fece239610e7dafb" translate="yes" xml:space="preserve">
          <source>Whether the adaptive hash index search latch shoild be relinquished immediately or reserved across all MariaDB calls. &lt;code&gt;0&lt;/code&gt; if there is no contention on the adaptive hash index, in which case the latch is reserved until completion, otherwise counts down to zero and the latch is released after each row lookup.</source>
          <target state="translated">적응 형 해시 인덱스 검색 래치가 즉시 포기되는지 또는 모든 MariaDB 호출에서 예약되었는지 여부. 적응 형 해시 인덱스에 경합이 없으면 &lt;code&gt;0&lt;/code&gt; 은 완료 될 때까지 래치가 예약되고, 그렇지 않으면 0으로 카운트 다운되고 각 행 조회 후에 래치가 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="349279617af476780f00bbd397d593f18c89f882" translate="yes" xml:space="preserve">
          <source>Whether the bloom filter is for the entire key or for the prefix. In case of a prefix, you need to look at the index definition and compute the desired prefix length.</source>
          <target state="translated">블룸 필터가 전체 키 또는 접두사에 대한 것인지 여부 접두사의 경우 인덱스 정의를보고 원하는 접두사 길이를 계산해야합니다.</target>
        </trans-unit>
        <trans-unit id="c87f1b96303a19c3ae4db887bcbb433f5205f64d" translate="yes" xml:space="preserve">
          <source>Whether the collation is compiled into the server.</source>
          <target state="translated">데이터 정렬이 서버로 컴파일되는지 여부</target>
        </trans-unit>
        <trans-unit id="c0adbbf388961848a23abd28e6358db3bb6bab43" translate="yes" xml:space="preserve">
          <source>Whether the collation is the character set's default.</source>
          <target state="translated">데이터 정렬이 문자 집합의 기본값인지 여부</target>
        </trans-unit>
        <trans-unit id="d525981c0c62960eb19338c61095aafb4c00ed6f" translate="yes" xml:space="preserve">
          <source>Whether the column can contain &lt;code&gt;NULL&lt;/code&gt;s.</source>
          <target state="translated">열이 포함 할 수 있는지 여부를 &lt;code&gt;NULL&lt;/code&gt; 의 들.</target>
        </trans-unit>
        <trans-unit id="8f8d08829dde6e615833211ac3dfd5d501e1746a" translate="yes" xml:space="preserve">
          <source>Whether the counter is currently enabled to disabled.</source>
          <target state="translated">카운터가 현재 비활성화되어 있는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="7afbfc3d804ee8748fdc97c84a260f44bb7e3ec1" translate="yes" xml:space="preserve">
          <source>Whether the data is bigger than the cache. This last one kicks in when building one page requires reading more data from disk can be cached. At that point, the problem goes from being CPU-bound to being I/O-bound. This is likely to suddenly slow down the loading of a pages by a factor of 10.</source>
          <target state="translated">데이터가 캐시보다 큰지 여부 한 페이지를 만들 때 디스크에서 더 많은 데이터를 읽어야 할 때이 마지막 페이지가 캐시 될 수 있습니다. 이 시점에서 문제는 CPU 바운드에서 I / O 바운드로 바뀝니다. 이로 인해 페이지로드가 갑자기 10 배 느려질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f878b13a9564433dc5eb370dbc60d96bfc6dda9a" translate="yes" xml:space="preserve">
          <source>Whether the data is stored in reverse order</source>
          <target state="translated">데이터가 역순으로 저장되는지 여부</target>
        </trans-unit>
        <trans-unit id="1e4a1038f0a1316cfd96baff77387355f2c663f3" translate="yes" xml:space="preserve">
          <source>Whether the engine is the default, or is supported or not.</source>
          <target state="translated">엔진이 기본값인지 또는 지원되는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="3662f00df5d64fff5cfc9bfb179c8dbd74518bce" translate="yes" xml:space="preserve">
          <source>Whether the lock is &lt;code&gt;RECORD&lt;/code&gt; (row level) or &lt;code&gt;TABLE&lt;/code&gt; level.</source>
          <target state="translated">잠금이 &lt;code&gt;RECORD&lt;/code&gt; (행 레벨) 또는 &lt;code&gt;TABLE&lt;/code&gt; 레벨 인지 여부</target>
        </trans-unit>
        <trans-unit id="044d87efcba050f5cad344cb68e21c9ffce3711a" translate="yes" xml:space="preserve">
          <source>Whether the object's events are instrumented or not. Can be disabled, in which case monitoring is not enabled for those objects.</source>
          <target state="translated">객체의 이벤트가 계측되는지 여부입니다. 비활성화 할 수 있으며이 경우 해당 개체에 대한 모니터링이 활성화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2610c4f79903cf60dd4e1bba977a57e3f96db624" translate="yes" xml:space="preserve">
          <source>Whether the object's events are timed or not. Can be modified.</source>
          <target state="translated">개체의 이벤트 시간이 초과되었는지 여부 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13f5bc18cb20e1f59403065194de47414e9476bc" translate="yes" xml:space="preserve">
          <source>Whether the page is old or not.</source>
          <target state="translated">페이지가 오래된 지 아닌지.</target>
        </trans-unit>
        <trans-unit id="79bb301e124aa2f54e894b749da6da01ac52d796" translate="yes" xml:space="preserve">
          <source>Whether the privilege can be granted.</source>
          <target state="translated">권한을 부여 할 수 있는지 여부</target>
        </trans-unit>
        <trans-unit id="710040bb9b83a250ad517b2afab6936ac925e3e8" translate="yes" xml:space="preserve">
          <source>Whether the role can be granted (see the &lt;a href=&quot;../create-role/index&quot;&gt;CREATE ROLE&lt;/a&gt;&lt;code&gt;WITH ADMIN&lt;/code&gt; clause).</source>
          <target state="translated">역할을 부여 할 수 있는지 여부 ( &lt;a href=&quot;../create-role/index&quot;&gt;CREATE ROLE &lt;/a&gt; &lt;code&gt;WITH ADMIN&lt;/code&gt; 절 참조).</target>
        </trans-unit>
        <trans-unit id="0da0e383080bb91f968b021c0ccdf90bef0537fb" translate="yes" xml:space="preserve">
          <source>Whether the role can be granted or not.</source>
          <target state="translated">역할을 부여 할 수 있는지 여부</target>
        </trans-unit>
        <trans-unit id="467fd2353ac096873e7897b663785cf266fb8fa0" translate="yes" xml:space="preserve">
          <source>Whether the role is the user's default role or not</source>
          <target state="translated">역할이 사용자의 기본 역할인지 여부</target>
        </trans-unit>
        <trans-unit id="6c38cec45252b8950f688debcf78302b6b8c727b" translate="yes" xml:space="preserve">
          <source>Whether the routine is a &lt;a href=&quot;../stored-procedures/index&quot;&gt;stored procedure&lt;/a&gt;, &lt;a href=&quot;../stored-functions/index&quot;&gt;stored function&lt;/a&gt;, or, from &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1035-release-notes/&quot;&gt;MariaDB 10.3.5&lt;/a&gt;, a &lt;a href=&quot;../create-package/index&quot;&gt;package&lt;/a&gt; or &lt;a href=&quot;../create-package-body/index&quot;&gt;package body&lt;/a&gt;.</source>
          <target state="translated">루틴이 &lt;a href=&quot;../stored-procedures/index&quot;&gt;저장 프로 시저&lt;/a&gt; , &lt;a href=&quot;../stored-functions/index&quot;&gt;저장 함수&lt;/a&gt; 또는 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1035-release-notes/&quot;&gt;MariaDB 10.3.5&lt;/a&gt; 의 &lt;a href=&quot;../create-package/index&quot;&gt;패키지&lt;/a&gt; 또는 &lt;a href=&quot;../create-package-body/index&quot;&gt;패키지 본문인지 여부&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ebb9d6e94e3dadae8da7538659f97b0972605113" translate="yes" xml:space="preserve">
          <source>Whether the routine is a &lt;code&gt;PROCEDURE&lt;/code&gt; or a &lt;code&gt;FUNCTION&lt;/code&gt;.</source>
          <target state="translated">루틴이 &lt;code&gt;PROCEDURE&lt;/code&gt; 또는 &lt;code&gt;FUNCTION&lt;/code&gt; 인지 여부 .</target>
        </trans-unit>
        <trans-unit id="f397e38fb10a3654408b82b4c074aafa62249d05" translate="yes" xml:space="preserve">
          <source>Whether the routine is deterministic (can produce only one result for a given list of parameters) or not.</source>
          <target state="translated">루틴이 결정적인지 (주어진 매개 변수 목록에 대해 하나의 결과 만 생성 할 수 있는지) 여부</target>
        </trans-unit>
        <trans-unit id="34f2d551c054237704dec602a2ba2b32f8f24ea2" translate="yes" xml:space="preserve">
          <source>Whether the slave I/O thread is running and connected (&lt;code&gt;Yes&lt;/code&gt;), running but not connected to a master (&lt;code&gt;Connecting&lt;/code&gt;) or not running (&lt;code&gt;No&lt;/code&gt;).</source>
          <target state="translated">슬레이브 I / O 스레드가 실행 중이고 연결되어 있는지 ( &lt;code&gt;Yes&lt;/code&gt; ), 실행 중이지만 마스터에 &lt;code&gt;Connecting&lt;/code&gt; 되지 않았는지 ( Connecting ) 또는 실행 중이 아닌지 ( &lt;code&gt;No&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="4f412c34f191b71ea34b5fd3117949ac856f879c" translate="yes" xml:space="preserve">
          <source>Whether the trigger acts &lt;code&gt;BEFORE&lt;/code&gt; or &lt;code&gt;AFTER&lt;/code&gt; the event that triggers it.</source>
          <target state="translated">트리거가 작동 여부 &lt;code&gt;BEFORE&lt;/code&gt; 또는 &lt;code&gt;AFTER&lt;/code&gt; 경우 트리거 그것은 그.</target>
        </trans-unit>
        <trans-unit id="941c1e892157534ffbaf30f39f6de2739601d363" translate="yes" xml:space="preserve">
          <source>Whether the two elements do not intersect</source>
          <target state="translated">두 요소가 교차하지 않는지 여부</target>
        </trans-unit>
        <trans-unit id="2c7d047ed8db23a73edc5ae5e428150c17bbe11b" translate="yes" xml:space="preserve">
          <source>Whether the two elements do not intersect.</source>
          <target state="translated">두 요소가 교차하지 않는지 여부</target>
        </trans-unit>
        <trans-unit id="6178f6ceda8caf032050c4b7b3d940d4d5e3c10b" translate="yes" xml:space="preserve">
          <source>Whether the user has the &lt;code&gt;&lt;a href=&quot;../grant/index#the-grant-option-privilege&quot;&gt;GRANT OPTION&lt;/a&gt;&lt;/code&gt; for this privilege.</source>
          <target state="translated">사용자 에게이 권한에 대한 &lt;code&gt;&lt;a href=&quot;../grant/index#the-grant-option-privilege&quot;&gt;GRANT OPTION&lt;/a&gt;&lt;/code&gt; 이 있는지 여부</target>
        </trans-unit>
        <trans-unit id="ca226e7011773e703acc1f4deef85e94ef493506" translate="yes" xml:space="preserve">
          <source>Whether the user is a &lt;a href=&quot;../roles/index&quot;&gt;role&lt;/a&gt;.</source>
          <target state="translated">사용자 여부입니다 &lt;a href=&quot;../roles/index&quot;&gt;역할&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2e28b7b982bb1f6bfc8d3f988a3cc688080bbbb9" translate="yes" xml:space="preserve">
          <source>Whether the view is updatable or not.</source>
          <target state="translated">보기를 업데이트 할 수 있는지 여부</target>
        </trans-unit>
        <trans-unit id="11fd62ca219a598076b4f33a9c69f748458e0ddc" translate="yes" xml:space="preserve">
          <source>Whether there is I/O pending for the page; one of &lt;code&gt;IO_NONE&lt;/code&gt; (no pending I/O), &lt;code&gt;IO_READ&lt;/code&gt; (read pending), &lt;code&gt;IO_WRITE&lt;/code&gt; (write pending).</source>
          <target state="translated">페이지에 보류중인 I / O가 있는지 여부 하나 &lt;code&gt;IO_NONE&lt;/code&gt; , (어떤 I / O 대기 없음) &lt;code&gt;IO_READ&lt;/code&gt; (출원 읽기), &lt;code&gt;IO_WRITE&lt;/code&gt; (쓰기 보류).</target>
        </trans-unit>
        <trans-unit id="53ac9cb307eed6ec5ae7b47338f3e2a3010892b6" translate="yes" xml:space="preserve">
          <source>Whether this is a &quot;Column&quot; or &quot;Dictionary&quot; extent</source>
          <target state="translated">이것이 &quot;열&quot;또는 &quot;사전&quot;범위인지 여부</target>
        </trans-unit>
        <trans-unit id="dd11b356c3a076ebd4d4ea40c7279062e4db62aa" translate="yes" xml:space="preserve">
          <source>Whether to enable TCP/IP (recommended) and which port MariaDB should listen to. If security is a concern, you can change the &lt;a href=&quot;../server-system-variables/index#bind_address&quot;&gt;bind-address&lt;/a&gt; parameter post-installation to bind to only local addresses. If the &quot;Enable networking&quot; checkbox is deselected, the database will use named pipes for communication.</source>
          <target state="translated">TCP / IP 활성화 여부 (권장) 및 MariaDB가 수신해야하는 포트. 보안이 중요한 경우 로컬 주소에만 바인드되도록 설치 후 &lt;a href=&quot;../server-system-variables/index#bind_address&quot;&gt;bind-address&lt;/a&gt; 매개 변수를 변경할 수 있습니다 . &quot;네트워킹 사용&quot;체크 상자를 선택 해제하면 데이터베이스는 통신을 위해 명명 된 파이프를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8fa149251ecb8709151b9610c3a5ca63b64f9b03" translate="yes" xml:space="preserve">
          <source>Whether two geometries are spatoially equal</source>
          <target state="translated">두 기하학이 spatoially 동일 여부</target>
        </trans-unit>
        <trans-unit id="a8790c6d9043edb6854118679a2f4719cf2e588b" translate="yes" xml:space="preserve">
          <source>Whether two geometries are spatoially equal.</source>
          <target state="translated">두 기하학이 spatoially 동일 여부입니다.</target>
        </trans-unit>
        <trans-unit id="020e96a02969c7ccf30a00e84cae825bd2094662" translate="yes" xml:space="preserve">
          <source>Whether two geometries overlap</source>
          <target state="translated">두 도형이 겹치는 지 여부</target>
        </trans-unit>
        <trans-unit id="63593e0063109ae9b2299f39e1a626ecd7456f52" translate="yes" xml:space="preserve">
          <source>Whether two geometries overlap.</source>
          <target state="translated">두 도형이 겹치는 지 여부</target>
        </trans-unit>
        <trans-unit id="7ad37299cb24651acc83246a2f03727629662718" translate="yes" xml:space="preserve">
          <source>Whether two geometries spatially cross</source>
          <target state="translated">두 도형이 공간적으로 교차하는지 여부</target>
        </trans-unit>
        <trans-unit id="ef6cc2eb60f88d947391b79b30de583351ffe653" translate="yes" xml:space="preserve">
          <source>Whether two geometries spatially cross.</source>
          <target state="translated">두 도형이 공간적으로 교차하는지 여부</target>
        </trans-unit>
        <trans-unit id="90a26eb1a2ed0655b45e0fc7f18c971247674c81" translate="yes" xml:space="preserve">
          <source>Whether two geometries spatially intersect</source>
          <target state="translated">두 도형이 공간적으로 교차하는지 여부</target>
        </trans-unit>
        <trans-unit id="bbac7e30272c0ac7d9ca492f1ec88755a435aa43" translate="yes" xml:space="preserve">
          <source>Whether two geometries spatially intersect.</source>
          <target state="translated">두 도형이 공간적으로 교차하는지 여부</target>
        </trans-unit>
        <trans-unit id="dce8e0ea1c8f5a11428090b50b2b38e090e37b93" translate="yes" xml:space="preserve">
          <source>Whether two geometries spatially touch</source>
          <target state="translated">두 도형이 공간적으로 접촉하는지 여부</target>
        </trans-unit>
        <trans-unit id="c9f9e2dfcf4e9931fbc04f01bc94ec67b5059e28" translate="yes" xml:space="preserve">
          <source>Whether two geometries spatially touch.</source>
          <target state="translated">두 도형이 공간적으로 접촉하는지 여부</target>
        </trans-unit>
        <trans-unit id="c665b28eb50c92c9f2b98ab6ecc982b7b2934efe" translate="yes" xml:space="preserve">
          <source>Whether unique checks are &lt;code&gt;on&lt;/code&gt; or &lt;code&gt;off&lt;/code&gt; for the current transaction. Bulk data are a case where unique checks would be off.</source>
          <target state="translated">고유의 검사 여부 &lt;code&gt;on&lt;/code&gt; 또는 &lt;code&gt;off&lt;/code&gt; 현재의 트랜잭션 (transaction)에 대한. 대량 데이터는 고유 검사가 해제 된 경우입니다.</target>
        </trans-unit>
        <trans-unit id="67e6b777d5fb25cc5682ac80de7b35492ccc2067" translate="yes" xml:space="preserve">
          <source>Which Storage Engines Does MariaDB Encryption Support?</source>
          <target state="translated">MariaDB 암호화는 어떤 스토리지 엔진을 지원합니까?</target>
        </trans-unit>
        <trans-unit id="729c58a2978a6e9718d18641057d972ba3120c23" translate="yes" xml:space="preserve">
          <source>Which and how options must be specified and the way columns must be defined may vary depending on the OEM type used and should be documented by the OEM type implementer(s).</source>
          <target state="translated">옵션을 지정해야하는 방법과 열을 정의하는 방법은 사용 된 OEM 유형에 따라 다를 수 있으며 OEM 유형 구현자가 문서화해야합니다.</target>
        </trans-unit>
        <trans-unit id="72feebac95dc3adec66dd0753d33f232b9a968b4" translate="yes" xml:space="preserve">
          <source>Which configuration files and groups mysqld reads.</source>
          <target state="translated">mysqld가 읽는 구성 파일 및 그룹</target>
        </trans-unit>
        <trans-unit id="0d5ecaa0882ffa00f209e641a7f2845774f8f641" translate="yes" xml:space="preserve">
          <source>Which datatypes are supported by MariaDB</source>
          <target state="translated">MariaDB가 지원하는 데이터 유형</target>
        </trans-unit>
        <trans-unit id="f3ab29651276db8d48c040074a193a2f3896262c" translate="yes" xml:space="preserve">
          <source>Which filesystem is best?</source>
          <target state="translated">어떤 파일 시스템이 가장 좋습니까?</target>
        </trans-unit>
        <trans-unit id="a5d041eb5da514e821a1c5a494b54ba5c816ff5f" translate="yes" xml:space="preserve">
          <source>Which filesystem is best? The filesystem is not the most important aspect ...</source>
          <target state="translated">어떤 파일 시스템이 가장 좋습니까? 파일 시스템은 가장 중요한 측면이 아닙니다 ...</target>
        </trans-unit>
        <trans-unit id="e4dfad47a2fb958e45cd53c5171f4a5539d2c2b0" translate="yes" xml:space="preserve">
          <source>Which objects are monitored</source>
          <target state="translated">모니터링 할 개체</target>
        </trans-unit>
        <trans-unit id="5e8ccdc497278cfb4112391fd1e9cc84130235d0" translate="yes" xml:space="preserve">
          <source>Which plan to pick? It depends on many things, so benchmark.</source>
          <target state="translated">어떤 계획을 선택합니까? 그것은 많은 것들에 달려 있으므로 벤치 마크하십시오.</target>
        </trans-unit>
        <trans-unit id="1cda25f5b305b34d345a32f8d036d9f55afaa43f" translate="yes" xml:space="preserve">
          <source>Which privileges you have for the column. A MySQL and MariaDB extension.</source>
          <target state="translated">열에 대한 권한 MySQL 및 MariaDB 확장.</target>
        </trans-unit>
        <trans-unit id="010d4761186c34a1194896595087dd7bee3e099a" translate="yes" xml:space="preserve">
          <source>Which the setup to distribute from the Master User Module, any DDL and non-columnstore table creation and population must be done from the Master User Module. This will keep all of the User Module Databases in-sync.</source>
          <target state="translated">마스터 사용자 모듈에서 분배 할 설정, DDL 및 비열 저장소 테이블 작성 및 채우기는 마스터 사용자 모듈에서 수행해야합니다. 이렇게하면 모든 사용자 모듈 데이터베이스가 동기화 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="fd3b68d40e123572452379fbd5371de9c151566f" translate="yes" xml:space="preserve">
          <source>While &lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#binlog_format&quot;&gt;binlog_format&lt;/a&gt; is checked on startup and can only be ROW (see &lt;a href=&quot;../binary-log-formats/index&quot;&gt;Binary Log Formats&lt;/a&gt;), it can be changed at runtime. Do NOT change binlog_format at runtime, it is likely not only cause replication failure, but make all other nodes crash.</source>
          <target state="translated">하지만 &lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#binlog_format&quot;&gt;binlog_format은&lt;/a&gt; 시작에 체크 만 ROW 할 수 있습니다 ( &lt;a href=&quot;../binary-log-formats/index&quot;&gt;바이너리 로그 형식&lt;/a&gt; 은 런타임에 변경 될 수 있습니다). 런타임에 binlog_format을 변경하지 마십시오. 이는 복제 실패의 원인 일뿐만 아니라 다른 모든 노드의 충돌을 유발합니다.</target>
        </trans-unit>
        <trans-unit id="d8bd4743ae1cacab5c48d0039e08e3f2256a4bd8" translate="yes" xml:space="preserve">
          <source>While I was at it, I gave an alias to change &quot;MONTH(ts)&quot; to just &quot;Month&quot;.</source>
          <target state="translated">내가 그 동안 &quot;MONTH (ts)&quot;를 &quot;Month&quot;로 변경하기 위해 별명을주었습니다.</target>
        </trans-unit>
        <trans-unit id="972d68f8a1c7c3cbcf46cdcbcd1071d258db246e" translate="yes" xml:space="preserve">
          <source>While MariaDB ColumnStore supports multiple ways to get data into the database (individual insert, batch insert, load data infile and import), the most efficient manner to load significant amounts of data into MariaDB ColumnStore is through the import utility.</source>
          <target state="translated">MariaDB ColumnStore는 데이터베이스에 데이터를 가져 오는 여러 가지 방법 (개별 삽입, 배치 삽입, 데이터로드 및 가져 오기)을 지원하지만 대량의 데이터를 MariaDB ColumnStore에로드하는 가장 효율적인 방법은 가져 오기 유틸리티를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d994e05beba24de904d783b413252fecd71e290a" translate="yes" xml:space="preserve">
          <source>While MySQL definition might not say anything about Los Angeles being bigger than Adelanto, it is perfectly clear about the type of queries that you use, and says explicitly that behavior here is undefined:</source>
          <target state="translated">MySQL 정의는 Los Angeles가 Adelanto보다 더 크다는 것을 말하지는 않지만, 사용하는 쿼리 유형에 대해 완벽하게 명확하며 여기에서 동작이 정의되지 않았다고 명시 적으로 말합니다.</target>
        </trans-unit>
        <trans-unit id="a91b010760573dc3a637ca565e77a1ca245d1d11" translate="yes" xml:space="preserve">
          <source>While a &lt;code&gt;--single-transaction&lt;/code&gt; dump is in process, to ensure a valid dump file (correct table contents and binary log coordinates), no other connection should use the following statements: &lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt;, &lt;a href=&quot;../create-table/index&quot;&gt;CREATE TABLE&lt;/a&gt;, &lt;a href=&quot;../drop-table/index&quot;&gt;DROP TABLE&lt;/a&gt;, &lt;a href=&quot;../rename-table/index&quot;&gt;RENAME TABLE&lt;/a&gt;, or &lt;a href=&quot;../truncate-table/index&quot;&gt;TRUNCATE TABLE&lt;/a&gt;. A consistent read is not isolated from those statements, so use of them on a table to be dumped can cause the &lt;code&gt;SELECT&lt;/code&gt; (performed by &lt;em&gt;mysqldump&lt;/em&gt; to retrieve the table contents) to obtain incorrect contents or fail.</source>
          <target state="translated">&lt;code&gt;--single-transaction&lt;/code&gt; 덤프가 처리 되는 동안 유효한 덤프 파일 (올바른 테이블 내용 및 이진 로그 좌표)을 보장하기 위해 다른 연결에서는 &lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt; , &lt;a href=&quot;../create-table/index&quot;&gt;CREATE TABLE&lt;/a&gt; , &lt;a href=&quot;../drop-table/index&quot;&gt;DROP TABLE&lt;/a&gt; , &lt;a href=&quot;../rename-table/index&quot;&gt;RENAME TABLE&lt;/a&gt; 또는 &lt;a href=&quot;../truncate-table/index&quot;&gt;절단 테이블&lt;/a&gt; . 일관성있는 읽기는 해당 명령문과 분리되지 않으므로 덤프 할 테이블에서 명령문을 사용하면 &lt;code&gt;SELECT&lt;/code&gt; ( &lt;em&gt;mysqldump&lt;/em&gt; 가 테이블 컨텐츠를 검색하여 수행 )가 올바르지 않은 컨텐츠를 얻거나 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="749b86bde4746036e6dd2c886ccc6f84ea1d93f4" translate="yes" xml:space="preserve">
          <source>While a SEQUENCE table cannot be dropped, it is possible to drop the converted table. The SEQUENCE table with the same name will still exist:</source>
          <target state="translated">SEQUENCE 테이블을 삭제할 수 없지만 변환 된 테이블을 삭제할 수 있습니다. 동일한 이름의 SEQUENCE 테이블은 여전히 ​​존재합니다.</target>
        </trans-unit>
        <trans-unit id="059ffc1db4cbfb9699ecce336d545a1649a8869c" translate="yes" xml:space="preserve">
          <source>While a connection holds an explicit lock on a table, it cannot access a non-locked table. If you try, the following error will be produced:</source>
          <target state="translated">연결은 테이블에 대한 명시 적 잠금을 보유하지만 잠금이 아닌 테이블에는 액세스 할 수 없습니다. 시도하면 다음 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="284d26733639b5a9be991158a005dcb07430994f" translate="yes" xml:space="preserve">
          <source>While a connection holds an explicit lock on a table, it cannot issue the following: INSERT DELAYED, CREATE TABLE, CREATE TABLE ... LIKE, and DDL statements involving stored programs and views (except for triggers). If you try, the following error will be produced:</source>
          <target state="translated">연결이 테이블에 대한 명시 적 잠금을 보유하는 동안, INSERT DELAYED, CREATE TABLE, CREATE TABLE ... LIKE 및 저장된 프로그램 및 뷰를 포함하는 DDL 문 (트리거 제외)을 발행 할 수 없습니다. 시도하면 다음 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8d2f91a5b10667c6562dfacdf25fb14a82cd631c" translate="yes" xml:space="preserve">
          <source>While a connection holds an explicit read lock on a table, it cannot modify it. If you try, the following error will be produced:</source>
          <target state="translated">연결은 테이블에 대한 명시 적 읽기 잠금을 보유하지만 수정할 수는 없습니다. 시도하면 다음 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a0228987631bc9457ebd795380d98dfcd8f4b484" translate="yes" xml:space="preserve">
          <source>While constructing the index, CONNECT also stores in memory the values of other used columns.</source>
          <target state="translated">인덱스를 구성하는 동안 CONNECT는 사용 된 다른 열의 값을 메모리에 저장합니다.</target>
        </trans-unit>
        <trans-unit id="6bc1e7b71ab1bfe96f9be4669e23068cca7ac51a" translate="yes" xml:space="preserve">
          <source>While each HANDLER READ command is atomic, if you do a scan in many steps, then some engines may give you error 1020 if the table changed between the commands. Please refer to the &lt;a href=&quot;../handler-handler/index&quot;&gt;specific engine handler page&lt;/a&gt; if this happens.</source>
          <target state="translated">각 HANDLER READ 명령이 원 자성이지만 여러 단계로 스캔을 수행하는 경우 명령간에 테이블이 변경되면 일부 엔진에서 오류 1020이 발생할 수 있습니다. 를 참조하십시오 &lt;a href=&quot;../handler-handler/index&quot;&gt;특정 엔진 핸들러 페이지&lt;/a&gt; 이런 일이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9bb46a00fe3438e2fd4979a1eac551c6c8d2727e" translate="yes" xml:space="preserve">
          <source>While in the mysql client, run:</source>
          <target state="translated">mysql 클라이언트에서 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="8b3bbb5ea3685573d5a847a1001154caebb994b2" translate="yes" xml:space="preserve">
          <source>While installing MariaDB-10.1.21-centos7-x86_64-common.rpm there might be a conflict with older MariaDB packages. we need to remove them and install the original rpm again.</source>
          <target state="translated">MariaDB-10.1.21-centos7-x86_64-common.rpm을 설치하는 동안 이전 MariaDB 패키지와 충돌이있을 수 있습니다. 이를 제거하고 원래 rpm을 다시 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="7788c9d1ca1d9796225dd85d57d9193bfb6ecfb7" translate="yes" xml:space="preserve">
          <source>While installing the Galera package there might be a conflict in installation for a dependency package. Here is the error message:</source>
          <target state="translated">Galera 패키지를 설치하는 동안 종속성 패키지 설치가 충돌 할 수 있습니다. 오류 메시지는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e2f7a93aa3244b7615b2958495d33149cb040ac6" translate="yes" xml:space="preserve">
          <source>While it is not recommended, it is possible to download and install the &lt;code&gt;.deb&lt;/code&gt; packages manually. However, it is generally recommended to use a package manager like &lt;code&gt;apt-get&lt;/code&gt;.</source>
          <target state="translated">권장되지는 않지만 &lt;code&gt;.deb&lt;/code&gt; 패키지를 수동으로 다운로드하여 설치할 수 있습니다. 그러나 일반적으로 &lt;code&gt;apt-get&lt;/code&gt; 과 같은 패키지 관리자를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="6a155000c5d30f92297060d41b242e83ab19403e" translate="yes" xml:space="preserve">
          <source>While replication is usually meant to take place between masters and slaves with the same table definitions and this is recommended, in certain cases replication can still take place even if the definitions are identical.</source>
          <target state="translated">일반적으로 동일한 테이블 정의를 사용하여 마스터와 슬레이브간에 복제를 수행하는 것이 권장되지만, 정의가 동일한 경우에도 복제가 여전히 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7311af3e42bf8fe0c937ae3c840763ab29bdcc9f" translate="yes" xml:space="preserve">
          <source>While some disable swap altogether, and you certainly want to avoid any database processes from using it, it can be prudent to leave some swap space to at least allow the kernel to fall over gracefully should a spike occur. Having emergency swap available at least allows you some scope to kill any runaway processes.</source>
          <target state="translated">일부는 스왑을 모두 비활성화하고 데이터베이스 프로세스에서이를 사용하지 않으려는 경우에도 스왑 공간을 남겨 두어 최소한 스파이크가 발생할 경우 커널이 정상적으로 넘어 질 수 있도록 스왑 공간을 남겨 두는 것이 좋습니다. 비상 스왑을 사용할 수 있으면 최소한 어떤 범위에서 런 어웨이 프로세스를 종료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61b0aad0d3eb391fc0c8bbfd0bfbd1534a696582" translate="yes" xml:space="preserve">
          <source>While still inside the container, send the shutdown command to MariaDB. This will shut down the server and also exit back out to the host:</source>
          <target state="translated">컨테이너 내부에있는 동안 종료 명령을 MariaDB로 보냅니다. 그러면 서버가 종료되고 호스트로 다시 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="da077b33bca55c85d3ead15330f7a9d57db6cb56" translate="yes" xml:space="preserve">
          <source>While the MariaDB ColumnStore's autoincrement column attribute behavior it is not identical to MariaDB's implementation. In order to get the correct results from this attribute please read and understand this section.</source>
          <target state="translated">MariaDB ColumnStore의 자동 증분 열 속성 동작은 MariaDB의 구현과 동일하지 않습니다. 이 속성에서 올바른 결과를 얻으려면이 섹션을 읽고 이해하십시오.</target>
        </trans-unit>
        <trans-unit id="682c0433ff29b3738f198af27f826375a89db7a4" translate="yes" xml:space="preserve">
          <source>While the MariaDB Server's &lt;a href=&quot;../explain/index&quot;&gt;EXPLAIN&lt;/a&gt; utility can be used to look at the query plan, it is somewhat less helpful for ColumnStore tables as ColumnStore does not use indexes or make use of MariaDB I/O functionality. The execution plan for a query on a ColumnStore table is made up of multiple steps. Each step in the query plan performs a set of operations that are issued from the &lt;a href=&quot;../columnstore-user-module/index&quot;&gt;User Module&lt;/a&gt; to the set of &lt;a href=&quot;../columnstore-performance-module/index&quot;&gt;Performance Modules&lt;/a&gt; in support of a given step in a query.</source>
          <target state="translated">MariaDB 서버의 &lt;a href=&quot;../explain/index&quot;&gt;EXPLAIN&lt;/a&gt; 유틸리티를 사용하여 쿼리 계획을 볼 수 있지만 ColumnStore는 인덱스를 사용하지 않거나 MariaDB I / O 기능을 사용하지 않으므로 ColumnStore 테이블에는 다소 도움이되지 않습니다. ColumnStore 테이블에서 쿼리에 대한 실행 계획은 여러 단계로 구성됩니다. 쿼리 계획의 각 단계는 쿼리 에서 지정된 단계를 지원 하기 위해 &lt;a href=&quot;../columnstore-user-module/index&quot;&gt;사용자 모듈&lt;/a&gt; 에서 &lt;a href=&quot;../columnstore-performance-module/index&quot;&gt;성능 모듈&lt;/a&gt; 세트로 발행되는 일련의 작업을 수행 합니다.</target>
        </trans-unit>
        <trans-unit id="e1e7ac007671b5fc6a2db73b7103674f88eb9ee3" translate="yes" xml:space="preserve">
          <source>While the character set is defined in a way that satisfies MariaDB, it has not been defined for Oracle, (that is, setting the NLS_LANG environment variable). As a result, Oracle is not providing the characters you want to MariaDB and Connect. The specific method of setting the NLS_LANG variable can vary depending on your operating system or distribution. If you're experiencing this issue, check your OS documentation for more details on how to properly set environment variables.</source>
          <target state="translated">문자 집합은 MariaDB를 만족시키는 방식으로 정의되었지만 Oracle에 대해 정의되지 않았습니다 (즉, NLS_LANG 환경 변수 설정). 결과적으로 Oracle은 MariaDB 및 Connect에 원하는 문자를 제공하지 않습니다. NLS_LANG 변수를 설정하는 구체적인 방법은 운영 체제 또는 배포판에 따라 달라질 수 있습니다. 이 문제가 발생하면 환경 변수를 올바르게 설정하는 방법에 대한 자세한 내용은 OS 설명서를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="2ec641749bfcf92d2b29733ed63a4b9bb47bc026" translate="yes" xml:space="preserve">
          <source>While the connection information can also be specified inline in the comment, it is cleaner to define a server object representing each remote backend server connection:</source>
          <target state="translated">주석에 연결 정보를 인라인으로 지정할 수도 있지만 각 원격 백엔드 서버 연결을 나타내는 서버 오브젝트를 정의하는 것이 더 깨끗합니다.</target>
        </trans-unit>
        <trans-unit id="e9dd65be9b67ecaae0c98b78e8e9841b53d0148f" translate="yes" xml:space="preserve">
          <source>While the query:</source>
          <target state="translated">쿼리하는 동안 :</target>
        </trans-unit>
        <trans-unit id="39645e32f84357cfc65630ec9d1d23e708493559" translate="yes" xml:space="preserve">
          <source>While the system is working, &quot;redistributeData status&quot; can be called to see what's happening. a -r &amp;lt;count&amp;gt; option can be used on the status command line to repeat the call and act as a monitor.</source>
          <target state="translated">시스템이 작동하는 동안 &quot;redistributeData status&quot;를 호출하여 현재 상황을 확인할 수 있습니다. 상태 명령 행에서 -r &amp;lt;count&amp;gt; 옵션을 사용하여 호출을 반복하고 모니터로 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3db5d8a759975674540457d7578fdf3270d85c92" translate="yes" xml:space="preserve">
          <source>While this statement takes effect immediately, threads which are executing a procedure can continue execution.</source>
          <target state="translated">이 명령문은 즉시 적용되지만 프로 시저를 실행중인 스레드는 계속 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="47b13cdb0607925057b8e9d36b0386d1a11eb54c" translate="yes" xml:space="preserve">
          <source>Whitespace</source>
          <target state="translated">Whitespace</target>
        </trans-unit>
        <trans-unit id="7d531617dd394cef59d3cf58fc32b3bc458f6744" translate="yes" xml:space="preserve">
          <source>Who</source>
          <target state="translated">Who</target>
        </trans-unit>
        <trans-unit id="4f7ed3276c176724fb400af0c670b8c7f6c0a459" translate="yes" xml:space="preserve">
          <source>Who are you? The history of MySQL and MariaDB authentication protocols from 1997 to 2017</source>
          <target state="translated">누구세요? 1997 년부터 2017 년까지 MySQL 및 MariaDB 인증 프로토콜의 역사</target>
        </trans-unit>
        <trans-unit id="2562ffcfb633e83d466c22c97d25411f0cd748b9" translate="yes" xml:space="preserve">
          <source>Who develops Aria?</source>
          <target state="translated">아리아는 누가 발달합니까?</target>
        </trans-unit>
        <trans-unit id="f487844a78fd0be738c81b6db7d5675f960c6c5d" translate="yes" xml:space="preserve">
          <source>Whole database on ioDrive.</source>
          <target state="translated">ioDrive의 전체 데이터베이스</target>
        </trans-unit>
        <trans-unit id="0404a9ecfb76de14e52536f7d999cac2b3f689df" translate="yes" xml:space="preserve">
          <source>Why Encrypt MariaDB Data?</source>
          <target state="translated">MariaDB 데이터를 암호화해야하는 이유</target>
        </trans-unit>
        <trans-unit id="5755149c67a112f20c33d4244dd2de585ccd4ba2" translate="yes" xml:space="preserve">
          <source>Why MariaDB uses InnoDB instead of XtraDB from MariaDB 10.2</source>
          <target state="translated">MariaDB가 MariaDB 10.2의 XtraDB 대신 InnoDB를 사용하는 이유</target>
        </trans-unit>
        <trans-unit id="012d55ceafc02ec007faf621e62d6a9f484e869d" translate="yes" xml:space="preserve">
          <source>Why NOT Partition</source>
          <target state="translated">파티션하지 않는 이유</target>
        </trans-unit>
        <trans-unit id="8371318243ee68870cfe16cea004e04f32794402" translate="yes" xml:space="preserve">
          <source>Why Source RPMs (SRPMs) Aren&amp;#x27;t Packaged For Some Platforms</source>
          <target state="translated">일부 플랫폼에서 소스 RPM (SRPM)이 패키지되지 않는 이유</target>
        </trans-unit>
        <trans-unit id="5ba0d52c7983ea69ac4ea2612f20100efd67800d" translate="yes" xml:space="preserve">
          <source>Why Source RPMs (SRPMs) Aren't Packaged For Some Platforms</source>
          <target state="translated">일부 플랫폼에서 소스 RPM (SRPM)이 패키지되지 않는 이유</target>
        </trans-unit>
        <trans-unit id="27a3b92f44642df066621fc5e519d213ab390c09" translate="yes" xml:space="preserve">
          <source>Why do you use the &lt;code&gt;TRANSACTIONAL&lt;/code&gt; keyword now when Aria is not yet transactional?</source>
          <target state="translated">Aria가 아직 거래되지 않았는데 왜 &lt;code&gt;TRANSACTIONAL&lt;/code&gt; 키워드 를 사용 합니까?</target>
        </trans-unit>
        <trans-unit id="91dbe9cce8f7657d959b35a919f7d2c1f803db4e" translate="yes" xml:space="preserve">
          <source>Why is ORDER BY in a FROM subquery ignored?</source>
          <target state="translated">FROM 서브 쿼리에서 ORDER BY가 무시되는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="8298b412b9b0bf180e1ccd287bcacd202c4dcbe3" translate="yes" xml:space="preserve">
          <source>Why is the Software Called MariaDB?</source>
          <target state="translated">소프트웨어가 MariaDB라고 불리는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="264d3352f14e04fdf42c4250f94dab04c82ef2b0" translate="yes" xml:space="preserve">
          <source>Why is the engine called Aria?</source>
          <target state="translated">엔진이 왜 Aria라고 불리는가?</target>
        </trans-unit>
        <trans-unit id="0a8f014dfe41e9e2f6e4dede94ee6e4b8ab0232b" translate="yes" xml:space="preserve">
          <source>Why it Works</source>
          <target state="translated">작동하는 이유</target>
        </trans-unit>
        <trans-unit id="baf89f6130f6f0bf2da25c0217ad83bb42963158" translate="yes" xml:space="preserve">
          <source>Why it is a problem</source>
          <target state="translated">왜 문제인가</target>
        </trans-unit>
        <trans-unit id="2e4580536b0f2359910adb76e50ba348f206ca0a" translate="yes" xml:space="preserve">
          <source>Why it works</source>
          <target state="translated">작동하는 이유</target>
        </trans-unit>
        <trans-unit id="1f710a7d2934e0597da83c0041aee1e4cc94bc8f" translate="yes" xml:space="preserve">
          <source>Why keep the Fact table?</source>
          <target state="translated">팩트 테이블을 유지하는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="57ae15b9e21c312b9470aee02e495bbfbd093937" translate="yes" xml:space="preserve">
          <source>Why the bogus &quot;start&quot; partition? If an invalid datetime (Feb 31) were to be used, the datetime would turn into NULL. NULLs are put into the first partition. Since any SELECT could have an invalid date (yeah, this stretching things), the partition pruner always includes the first partition in the resulting set of partitions to search. So, if the SELECT must scan the first partition, it would be slightly more efficient if that partition were empty. Hence the bogus &quot;start&quot; partition. Longer discussion, by The Data Charmer 5.5 eliminates the bogus check, but only if you switch to a new syntax:</source>
          <target state="translated">왜 가짜 &quot;시작&quot;파티션입니까? 유효하지 않은 날짜 시간 (2 월 31 일)을 사용하면 날짜 시간이 NULL로 바뀝니다. 첫 번째 파티션에는 NULL이 있습니다. 모든 SELECT는 유효하지 않은 날짜를 가질 수 있기 때문에 (예,이 확장) 파티션 정리기는 항상 검색 할 파티션 세트의 첫 번째 파티션을 포함합니다. 따라서 SELECT가 첫 번째 파티션을 스캔해야하는 경우 해당 파티션이 비어 있으면 약간 더 효율적입니다. 따라서 가짜 &quot;시작&quot;파티션. Data Charmer 5.5의 자세한 논의는 가짜 확인을 제거하지만 새로운 구문으로 전환하는 경우에만 가능합니다.</target>
        </trans-unit>
        <trans-unit id="4c650700b5392efda9c668a4dd26448b159d3b5e" translate="yes" xml:space="preserve">
          <source>Why to Avoid Swapping</source>
          <target state="translated">교환을 피하는 이유</target>
        </trans-unit>
        <trans-unit id="0d129eaf3976a8de7fc24723cafc3dd847e67916" translate="yes" xml:space="preserve">
          <source>Why to turn off the QC</source>
          <target state="translated">QC를 끄는 이유</target>
        </trans-unit>
        <trans-unit id="87a028a9e0af78e8d530fa260c816382b7c6b28f" translate="yes" xml:space="preserve">
          <source>Why use Stored Procedures?</source>
          <target state="translated">저장 프로 시저를 사용해야하는 이유</target>
        </trans-unit>
        <trans-unit id="bc677156705ba3019db45a6ee08fe6015ce55d2f" translate="yes" xml:space="preserve">
          <source>Why using Multi Range Read can cause higher values in status variables</source>
          <target state="translated">다중 범위 읽기를 사용하면 상태 변수에서 더 높은 값이 발생할 수있는 이유</target>
        </trans-unit>
        <trans-unit id="d77989c1e3c0e0ace735631597dc367ffdfa6f32" translate="yes" xml:space="preserve">
          <source>Why?</source>
          <target state="translated">Why?</target>
        </trans-unit>
        <trans-unit id="782ece90f2828a2c9b1d518b69ff9ed07a04715a" translate="yes" xml:space="preserve">
          <source>Wide variety of UI skins</source>
          <target state="translated">다양한 UI 스킨</target>
        </trans-unit>
        <trans-unit id="5e1f3cf723d413fbb0357192c5fb834de2445f09" translate="yes" xml:space="preserve">
          <source>Widely-used physical backup method, using a Perl script as a wrapper. See &lt;a href=&quot;http://www.lenzg.net/mylvmbackup/&quot;&gt;http://www.lenzg.net/mylvmbackup/&lt;/a&gt;.</source>
          <target state="translated">Perl 스크립트를 랩퍼로 사용하는 널리 사용되는 실제 백업 방법. &lt;a href=&quot;http://www.lenzg.net/mylvmbackup/&quot;&gt;http://www.lenzg.net/mylvmbackup/을&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="a4647072734b9cbab285b32ec7ae1fbbad22160b" translate="yes" xml:space="preserve">
          <source>Wildcard characters can be used in any position within the pattern to be matched. Strictly speaking, because &quot;&lt;code&gt;_&lt;/code&gt;&quot; is a wildcard that matches any single character, you should escape it as &quot;&lt;code&gt;\_&lt;/code&gt;&quot; to match it literally. In practice, this is rarely necessary.</source>
          <target state="translated">와일드 카드 문자는 패턴 내에서 일치시킬 위치에 사용할 수 있습니다. 엄밀히 말하면 &quot; &lt;code&gt;_&lt;/code&gt; &quot;는 단일 문자와 일치하는 와일드 카드 이므로 문자 그대로 일치 시키려면 &quot; &lt;code&gt;\_&lt;/code&gt; &quot; 로 이스케이프해야합니다 . 실제로 이것은 거의 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cb060aabca1081f0ea1121a26b77b439ee654c31" translate="yes" xml:space="preserve">
          <source>Will be used to set the statement fetch size.</source>
          <target state="translated">명령문 페치 크기를 설정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9bd953bd4e98024d8aa10c66880201bc026e0f03" translate="yes" xml:space="preserve">
          <source>Will display the following result:</source>
          <target state="translated">다음과 같은 결과가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="04617c7de73b21c958726d12f355ff0318fd5722" translate="yes" xml:space="preserve">
          <source>Will display the result:</source>
          <target state="translated">결과를 표시합니다 :</target>
        </trans-unit>
        <trans-unit id="e170300d4382bf3fdd98b4030fec8a2e68bad177" translate="yes" xml:space="preserve">
          <source>Will display the resulting table:</source>
          <target state="translated">결과 테이블을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="a4dc49346b57c5dd7fbd920b5afbff86c2f30953" translate="yes" xml:space="preserve">
          <source>Will return a result such as:</source>
          <target state="translated">다음과 같은 결과를 반환합니다 :</target>
        </trans-unit>
        <trans-unit id="69bda036e1e2725373519a10c1136eb31ebd83b7" translate="yes" xml:space="preserve">
          <source>Will storage engines created for MariaDB work in MySQL?</source>
          <target state="translated">MariaDB 용으로 생성 된 스토리지 엔진이 MySQL에서 작동합니까?</target>
        </trans-unit>
        <trans-unit id="a17c27b0dd82e4a64b5f07594f51aec908488130" translate="yes" xml:space="preserve">
          <source>William J.</source>
          <target state="translated">윌리엄 J.</target>
        </trans-unit>
        <trans-unit id="e9de403ba001575157ba97f921d9ffc712f52ec0" translate="yes" xml:space="preserve">
          <source>William J. Pardi</source>
          <target state="translated">윌리엄 제이 패디</target>
        </trans-unit>
        <trans-unit id="031dd558fb2880afb7b91b47317aafa475a2eb9f" translate="yes" xml:space="preserve">
          <source>Window Frames</source>
          <target state="translated">창틀</target>
        </trans-unit>
        <trans-unit id="68fe8f958724479a101c0326f7607d389d321758" translate="yes" xml:space="preserve">
          <source>Window Functions</source>
          <target state="translated">창 기능</target>
        </trans-unit>
        <trans-unit id="d4fe138cdc734658706e09ae6d3ee6ffb4a6b66c" translate="yes" xml:space="preserve">
          <source>Window Functions Overview</source>
          <target state="translated">창 기능 개요</target>
        </trans-unit>
        <trans-unit id="c4b35ad46c978675cdd5399803966696cd19c982" translate="yes" xml:space="preserve">
          <source>Window frames are determined by the &lt;em&gt;frame_clause&lt;/em&gt; in the window function request.</source>
          <target state="translated">윈도우 프레임은 윈도우 함수 요청에서 &lt;em&gt;frame_clause&lt;/em&gt; 에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="e965ae35bc2e1abda65836f9b050d225efb29207" translate="yes" xml:space="preserve">
          <source>Window function queries are characterised by the OVER keyword, following which the set of rows used for the calculation is specified. By default, the set of rows used for the calculation (the &quot;window) is the entire dataset, which can be ordered with the ORDER BY clause. The PARTITION BY clause is used to reduce the window to a particular group within the dataset.</source>
          <target state="translated">창 함수 쿼리는 OVER 키워드로 특징 지어지며, 그 뒤에 계산에 사용 된 행 세트가 지정됩니다. 기본적으로 계산에 사용되는 행 집합 ( &quot;창&quot;)은 ORDER BY 절과 함께 주문할 수있는 전체 데이터 집합입니다. PARTITION BY 절은 데이터 집합 내의 특정 그룹으로 창을 줄이는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9982524c0326a6daaf5240011f68cff3135ee021" translate="yes" xml:space="preserve">
          <source>Window function that returns the cumulative distribution of a given row</source>
          <target state="translated">주어진 행의 누적 분포를 반환하는 윈도우 함수</target>
        </trans-unit>
        <trans-unit id="b1c65b1ce3572b262b08ef7ecddb8a7f7e25dd63" translate="yes" xml:space="preserve">
          <source>Window function that returns the cumulative distribution of a given row.</source>
          <target state="translated">주어진 행의 누적 분포를 반환하는 윈도우 함수.</target>
        </trans-unit>
        <trans-unit id="331e2cee9453e6c673844790b6387e7f6a75b079" translate="yes" xml:space="preserve">
          <source>Window function that returns the median value of a range of values</source>
          <target state="translated">값 범위의 중앙값을 반환하는 윈도우 함수</target>
        </trans-unit>
        <trans-unit id="298cec3a9d4e7fc456452a8fb8fc35daded10f77" translate="yes" xml:space="preserve">
          <source>Window function that returns the median value of a range of values.</source>
          <target state="translated">값 범위의 중앙값을 반환하는 윈도우 함수.</target>
        </trans-unit>
        <trans-unit id="2c86f2c1fdd58e6f490b6875ed06c6f1ad2b1f1a" translate="yes" xml:space="preserve">
          <source>Window function that returns the relative percent rank of a given row</source>
          <target state="translated">주어진 행의 상대적 백분율 순위를 반환하는 창 함수</target>
        </trans-unit>
        <trans-unit id="36393b39477513b8bd4f1a65fb62d41c0157eb43" translate="yes" xml:space="preserve">
          <source>Window function that returns the relative percent rank of a given row.</source>
          <target state="translated">주어진 행의 상대적 백분율 순위를 반환하는 창 함수.</target>
        </trans-unit>
        <trans-unit id="01d9ba4ea4d75e470dff24644ec39e3d185bfa48" translate="yes" xml:space="preserve">
          <source>Window functions allow calculations to be performed across a set of rows related to the current row.</source>
          <target state="translated">창 기능을 사용하면 현재 행과 관련된 행 집합에서 계산을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef7d24f033558402e2adca433aa5e88f330d4aed" translate="yes" xml:space="preserve">
          <source>Window functions are applied after joins, group by, and having clauses are calculated.</source>
          <target state="translated">창 함수는 결합, 그룹화 및 절이 계산 된 후에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="2c6a3e9d0949739fc830c58aacc5c7a2f17ba8c9" translate="yes" xml:space="preserve">
          <source>Window functions are executed at the UM level due to the need for ordering of the window results. The ColumnStore window function engines uses a dedicated faster sort process.</source>
          <target state="translated">윈도우 함수는 윈도우 결과의 순서가 필요하기 때문에 UM 레벨에서 실행됩니다. ColumnStore 창 함수 엔진은 전용 빠른 정렬 프로세스를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a70a169267904a55d14c5eef7b3720f8b6426455" translate="yes" xml:space="preserve">
          <source>Window functions can be used to achieve cumulative / running calculations on a detail report. In this case a won opportunity report for a 7 day period adds columns to show the accumulated won amount as well as the current highest opportunity amount in preceding rows.</source>
          <target state="translated">창 기능을 사용하여 상세 보고서에서 누적 / 실행 계산을 수행 할 수 있습니다. 이 경우 7 일 동안의 원 기회 보고서는 누적 된 원 금액과 이전 행에서 현재 가장 높은 기회 금액을 표시하기 위해 열을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="41d1e42c043f56b3b8eda656c412dbda26726c89" translate="yes" xml:space="preserve">
          <source>Window functions for performing calculations on a set of rows related to the current row.</source>
          <target state="translated">현재 행과 관련된 행 집합에서 계산을 수행하기위한 창 기능.</target>
        </trans-unit>
        <trans-unit id="5c723a8cb45de7192a2efaa229b633fc7e8da682" translate="yes" xml:space="preserve">
          <source>Window functions perform calculations across a set of rows related to the current row</source>
          <target state="translated">창 함수는 현재 행과 관련된 행 집합에서 계산을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="e39472108e59d0e2bce692234b234386fbea0760" translate="yes" xml:space="preserve">
          <source>Window functions perform calculations across a set of rows related to the current row.</source>
          <target state="translated">창 함수는 현재 행과 관련된 행 집합에서 계산을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="62fb9ef352f78c0c048f11a731b5b820833c6c90" translate="yes" xml:space="preserve">
          <source>Window functions that can be streamed once the number of rows in partition is known: &lt;a href=&quot;../percent_rank/index&quot;&gt;PERCENT_RANK&lt;/a&gt;, &lt;a href=&quot;../cume_dist/index&quot;&gt;CUME_DIST&lt;/a&gt;, &lt;a href=&quot;../ntile/index&quot;&gt;NTILE&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../percent_rank/index&quot;&gt;PERCENT_RANK&lt;/a&gt; , &lt;a href=&quot;../cume_dist/index&quot;&gt;CUME_DIST&lt;/a&gt; , &lt;a href=&quot;../ntile/index&quot;&gt;NTILE&lt;/a&gt; 파티션의 행 수를 알면 스트리밍 할 수있는 창 함수</target>
        </trans-unit>
        <trans-unit id="c9b170bb274f4244968e9310efece02ed0024831" translate="yes" xml:space="preserve">
          <source>Window functions were first introduced in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1020-release-notes/&quot;&gt;MariaDB 10.2.0&lt;/a&gt;.</source>
          <target state="translated">윈도우 함수는 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1020-release-notes/&quot;&gt;MariaDB 10.2.0&lt;/a&gt; 에서 처음 소개되었습니다 .</target>
        </trans-unit>
        <trans-unit id="edc36a72b4a8298db088dcdf2befa7d8c9873f64" translate="yes" xml:space="preserve">
          <source>Window functions were introduced in &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt;.</source>
          <target state="translated">윈도우 함수는 &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt; 에서 도입되었습니다 .</target>
        </trans-unit>
        <trans-unit id="4b505ca5730091db8b9b22eed075616bbd0d2e8a" translate="yes" xml:space="preserve">
          <source>Window functions were introduced in SQL:2003, and their definition was expanded in subsequent versions of the standard. The last expansion was in the latest version of the standard, SQL:2011.</source>
          <target state="translated">윈도우 함수는 SQL : 2003에 도입되었으며 그 정의는 이후 버전의 표준에서 확장되었습니다. 마지막 확장은 최신 버전의 표준 SQL : 2011에있었습니다.</target>
        </trans-unit>
        <trans-unit id="2059fa57b599fba9ff4c3dc650e698e20c59171d" translate="yes" xml:space="preserve">
          <source>Windowing functions</source>
          <target state="translated">윈도우 기능</target>
        </trans-unit>
        <trans-unit id="26d9c28d789c254f71ea99a3463b99a7ccc2f4fa" translate="yes" xml:space="preserve">
          <source>Windows</source>
          <target state="translated">Windows</target>
        </trans-unit>
        <trans-unit id="e2e70e6b2062b417683be7f4fdb5139f4336bf24" translate="yes" xml:space="preserve">
          <source>Windows &amp;gt;= &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1043-release-notes/&quot;&gt;MariaDB 10.4.3&lt;/a&gt;: &lt;code&gt;ON&lt;/code&gt;</source>
          <target state="translated">Windows&amp;gt; = &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1043-release-notes/&quot;&gt;MariaDB 10.4.3&lt;/a&gt; : &lt;code&gt;ON&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="606d107f6142e7530c6b1e55ac71ddbbb55aadc2" translate="yes" xml:space="preserve">
          <source>Windows (32-bit)</source>
          <target state="translated">Windows (32 비트)</target>
        </trans-unit>
        <trans-unit id="1cb7956bf146a8ba0806fced6a0163472a25a83e" translate="yes" xml:space="preserve">
          <source>Windows 10</source>
          <target state="translated">윈도우 10</target>
        </trans-unit>
        <trans-unit id="2cbef5cc0a29769156df9578f94931558cb402a2" translate="yes" xml:space="preserve">
          <source>Windows 10 Package</source>
          <target state="translated">Windows 10 패키지</target>
        </trans-unit>
        <trans-unit id="c15f5812f056a1f2af6de147cae47b4d5b92188c" translate="yes" xml:space="preserve">
          <source>Windows 10 dependencies</source>
          <target state="translated">Windows 10 종속성</target>
        </trans-unit>
        <trans-unit id="9f0b50fedb06b67fac522d29874e99633d2837fb" translate="yes" xml:space="preserve">
          <source>Windows 64 (zip and MSI)</source>
          <target state="translated">Windows 64 (zip 및 MSI)</target>
        </trans-unit>
        <trans-unit id="1f7dfb8547d9e8e0d5d990ae6da536c2489ab062" translate="yes" xml:space="preserve">
          <source>Windows Arabic</source>
          <target state="translated">윈도우 아랍어</target>
        </trans-unit>
        <trans-unit id="8dfcffef649115f1ea11d21fadd4fc4f12f80158" translate="yes" xml:space="preserve">
          <source>Windows Baltic</source>
          <target state="translated">윈도우 발틱</target>
        </trans-unit>
        <trans-unit id="77b768aba882582a87119c2b9d36b9e81ed7e5e7" translate="yes" xml:space="preserve">
          <source>Windows Central European</source>
          <target state="translated">Windows 중앙 유럽</target>
        </trans-unit>
        <trans-unit id="67b932abbaff311fee395428c759a2f124176eb6" translate="yes" xml:space="preserve">
          <source>Windows Cyrillic</source>
          <target state="translated">윈도우 키릴</target>
        </trans-unit>
        <trans-unit id="c2d2af309d034e8d8ab8215f3df76471288dce35" translate="yes" xml:space="preserve">
          <source>Windows GUI client for MariaDB and MySQL.</source>
          <target state="translated">MariaDB 및 MySQL 용 Windows GUI 클라이언트.</target>
        </trans-unit>
        <trans-unit id="dffdc05fe93692520ea1ea10629e5695979725d5" translate="yes" xml:space="preserve">
          <source>Windows GUI for MySQL. Compatible with MariaDB. Freeware. SQL syntax check.</source>
          <target state="translated">MySQL 용 Windows GUI. MariaDB와 호환됩니다. 프리웨어. SQL 구문 검사</target>
        </trans-unit>
        <trans-unit id="4b110f26509a3a6f47679dd7d20021d2d185ecf2" translate="yes" xml:space="preserve">
          <source>Windows GUI for MySQL. SQL Syntax Check. Freeware (Basic Features) &amp;amp; Payware (Extended Features).</source>
          <target state="translated">MySQL 용 Windows GUI. SQL 구문 검사. 프리웨어 (기본 기능) 및 페이웨어 (확장 기능).</target>
        </trans-unit>
        <trans-unit id="a21ed4b27052bc9e381e5ff118ec8431902413cc" translate="yes" xml:space="preserve">
          <source>Windows Linux Subsystem</source>
          <target state="translated">Windows Linux 서브 시스템</target>
        </trans-unit>
        <trans-unit id="31edcde9f4855232b4dd9cb7c97d6798aeb84979" translate="yes" xml:space="preserve">
          <source>Windows Management Instrumentation Table Type &amp;ldquo;WMI&amp;rdquo;</source>
          <target state="translated">Windows Management Instrumentation 테이블 유형&amp;ldquo;WMI&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="963abfbee403df14b5cc4ec7ff6c9739f4d09a2d" translate="yes" xml:space="preserve">
          <source>Windows Management Instrumentation table displaying information coming from a WMI provider. This type enables to get in tabular format all sorts of information about the machine hardware and operating system (Windows only).</source>
          <target state="translated">WMI 공급자가 제공하는 정보를 표시하는 Windows Management Instrumentation 테이블. 이 유형을 사용하면 기계 하드웨어 및 운영 체제에 대한 모든 종류의 정보를 표 형식으로 얻을 수 있습니다 (Windows 만 해당).</target>
        </trans-unit>
        <trans-unit id="676dc0d3370a0cd57170206b449f370366f8bcdc" translate="yes" xml:space="preserve">
          <source>Windows Options</source>
          <target state="translated">Windows 옵션</target>
        </trans-unit>
        <trans-unit id="2b56bcbc442499d96040cf9dc0dfed23dc2faa7b" translate="yes" xml:space="preserve">
          <source>Windows Options and System Variables</source>
          <target state="translated">Windows 옵션 및 시스템 변수</target>
        </trans-unit>
        <trans-unit id="a003aab39ef03e8769d16a9abb4d08a1473c439c" translate="yes" xml:space="preserve">
          <source>Windows connection coloring</source>
          <target state="translated">윈도우 연결 색칠</target>
        </trans-unit>
        <trans-unit id="4a269a465cac548291556aa1c7878cc4f5d8b4b0" translate="yes" xml:space="preserve">
          <source>Windows equivalent of mysql_install_db for creating the system tables etc.</source>
          <target state="translated">시스템 테이블 작성을위한 mysql_install_db와 동등한 Windows</target>
        </trans-unit>
        <trans-unit id="74af82eb12d26d4c13206527666f8d8471bd5a49" translate="yes" xml:space="preserve">
          <source>Windows is not supported.</source>
          <target state="translated">Windows는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e2b0564f9a15b1633334f41faa84e62793ed2785" translate="yes" xml:space="preserve">
          <source>Windows: &lt;code&gt;unbuffered&lt;/code&gt;, &lt;code&gt;async_unbuffered&lt;/code&gt;, &lt;code&gt;normal&lt;/code&gt;</source>
          <target state="translated">Windows : &lt;code&gt;unbuffered&lt;/code&gt; , &lt;code&gt;async_unbuffered&lt;/code&gt; , &lt;code&gt;normal&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="270a3a66c8124a936b5ea40e9baed8d866958487" translate="yes" xml:space="preserve">
          <source>Windows: mysql-test-run --log-error fixed to not add --console.</source>
          <target state="translated">Windows : mysql-test-run --log-error가 --console을 추가하지 않도록 수정했습니다.</target>
        </trans-unit>
        <trans-unit id="a03b7eae23fd8697a4f2489ab04876dd0f8c22c5" translate="yes" xml:space="preserve">
          <source>With 'traditional' replication, especially if using &quot;Statement Based Replication&quot;, all writes to the Master are applied to all Slaves, and they are replayed serially. Even with a multi-master setup, all writes are applied to all Masters. Hence, there is no way to get &quot;write scaling&quot;; that is, no way to increase the number of writes beyond what a single Master can handle.</source>
          <target state="translated">특히 &quot;문 기반 복제&quot;를 사용하는 경우 '전통적인'복제를 사용하면 마스터에 대한 모든 쓰기가 모든 슬레이브에 적용되고 연속적으로 재생됩니다. 다중 마스터 설정을 사용하더라도 모든 쓰기는 모든 마스터에 적용됩니다. 따라서 &quot;쓰기 스케일링&quot;을 얻을 수있는 방법이 없습니다. 즉, 단일 마스터가 처리 할 수있는 것 이상으로 쓰기 수를 늘릴 수있는 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="fd4e2156f7f60353e9a5437980808e487c851c03" translate="yes" xml:space="preserve">
          <source>With 5.6 and especially 5.7 having a lot of ALTER ALGORITHM=INPLACE cases, check which ALTERs should be done which way.</source>
          <target state="translated">ALTER ALGORITHM = INPLACE 사례가 많은 5.6, 특히 5.7에서는 어떤 ALTER를 어떤 방식으로 수행해야하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="d933ce4855854b77ff32a60b1ae9b7d90e97001d" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;../innodb/index&quot;&gt;XtraDB/InnoDB&lt;/a&gt;, &lt;code&gt;TRUNCATE TABLE&lt;/code&gt; is slower if &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_file_per_table&quot;&gt;innodb_file_per_table=ON&lt;/a&gt; is set (the default since &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt;). This is because &lt;code&gt;TRUNCATE TABLE&lt;/code&gt; unlinks the underlying tablespace file, which can be an expensive operation. See &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-8069&quot;&gt;MDEV-8069&lt;/a&gt; for more details.</source>
          <target state="translated">함께 &lt;a href=&quot;../innodb/index&quot;&gt;XtraDB / 이노&lt;/a&gt; , &lt;code&gt;TRUNCATE TABLE&lt;/code&gt; 경우 느린 &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_file_per_table&quot;&gt;innodb_file_per_table = ON은&lt;/a&gt; (이후 기본 설정 &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt; ). &lt;code&gt;TRUNCATE TABLE&lt;/code&gt; 은 기본 테이블 스페이스 파일의 링크를 해제 하므로 비용이 많이 드는 작업 일 수 있습니다. &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-8069&quot;&gt;MDEV-8069&lt;/a&gt; 참조 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="04ee2669aadbb4c27f4fa9f6031172e43f2491ef" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;../mysql_plugin/index&quot;&gt;mysql_plugin&lt;/a&gt; while the server is offline.</source>
          <target state="translated">서버가 오프라인 일 때 &lt;a href=&quot;../mysql_plugin/index&quot;&gt;mysql_plugin&lt;/a&gt; 사용</target>
        </trans-unit>
        <trans-unit id="2e7e3e4f3dd0b9219c2ad274847f9fd00b3eed6b" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;../what-is-mariadb-100/index&quot;&gt;MariaDB 10.0&lt;/a&gt; and newer you can use the &lt;a href=&quot;../shutdown/index&quot;&gt;SHUTDOWN&lt;/a&gt; command from any client.</source>
          <target state="translated">로 &lt;a href=&quot;../what-is-mariadb-100/index&quot;&gt;MariaDB 10.0&lt;/a&gt; 및 최신 당신은 사용할 수 있습니다 &lt;a href=&quot;../shutdown/index&quot;&gt;종료&lt;/a&gt; 모든 클라이언트에서 명령을.</target>
        </trans-unit>
        <trans-unit id="ee48d0359088505c24d4594571f92956fc9d7bca" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt; the following partition clause can be used to specify a default partition for all other values, however this must be a distinct partition / shard:</source>
          <target state="translated">로 &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt; 다음 파티션 절은 모든 다른 값에 대한 기본 파티션을 지정하는 데 사용할 수 있습니다, 그러나 이것은 별개의 파티션 / 파편해야합니다 :</target>
        </trans-unit>
        <trans-unit id="724f245e0be21acd7b99335c5a0fed915bcc6736" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#sql_quote_show_create&quot;&gt;sql_quote_show_create&lt;/a&gt;&lt;/code&gt; off:</source>
          <target state="translated">와 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#sql_quote_show_create&quot;&gt;sql_quote_show_create&lt;/a&gt;&lt;/code&gt; 오프 :</target>
        </trans-unit>
        <trans-unit id="00fc42a9b81846d0e9cc098c3649199d35c586c1" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;EXTENDED&lt;/code&gt;, the entire table is read row by row and the checksum is calculated. This can be very slow for large tables.</source>
          <target state="translated">함께 &lt;code&gt;EXTENDED&lt;/code&gt; 전체 테이블 행에 의해 판독 행이고, 체크섬이 계산된다. 큰 테이블의 경우 속도가 매우 느릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6427c471ba58824be277599e4cc723650d0f6bd" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;INSERT ... SELECT&lt;/code&gt;, you can quickly insert many rows into a table from one or more other tables. For example:</source>
          <target state="translated">함께 &lt;code&gt;INSERT ... SELECT&lt;/code&gt; , 신속 하나 개 이상의 다른 테이블에서 테이블에 많은 행을 삽입 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="423ec3118d4e55dcd835073268ce7e12098dadd7" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;QUICK&lt;/code&gt;, the live table checksum is reported if it is available, or &lt;code&gt;NULL&lt;/code&gt; otherwise. This is very fast. A live checksum is enabled by specifying the &lt;code&gt;CHECKSUM=1&lt;/code&gt; table option when you &lt;a href=&quot;../create-table/index&quot;&gt;create the table&lt;/a&gt;; currently, this is supported only for &lt;a href=&quot;../aria/index&quot;&gt;Aria&lt;/a&gt; and &lt;a href=&quot;../myisam/index&quot;&gt;MyISAM&lt;/a&gt; tables.</source>
          <target state="translated">함께 &lt;code&gt;QUICK&lt;/code&gt; , 라이브 테이블 검사가 가능한 경우, 또는보고 &lt;code&gt;NULL&lt;/code&gt; 이 없습니다. 이것은 매우 빠릅니다. 라이브 체크섬은 테이블을 &lt;a href=&quot;../create-table/index&quot;&gt;작성할&lt;/a&gt; 때 &lt;code&gt;CHECKSUM=1&lt;/code&gt; 테이블 옵션 을 지정하여 사용 가능 합니다 . 현재 이것은 &lt;a href=&quot;../aria/index&quot;&gt;Aria&lt;/a&gt; 및 &lt;a href=&quot;../myisam/index&quot;&gt;MyISAM&lt;/a&gt; 테이블 에서만 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="7c386df6d597cd18880fb206af5119da495f0093" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;SpiderForMySQL&lt;/code&gt;, the &lt;a href=&quot;../create-table/index&quot;&gt;CREATE TABLE&lt;/a&gt; statement uses &lt;code&gt;CONNECTION&lt;/code&gt; to define spider table variables whereas MariaDB uses &lt;code&gt;COMMENT&lt;/code&gt;.</source>
          <target state="translated">로 &lt;code&gt;SpiderForMySQL&lt;/code&gt; 의는 &lt;a href=&quot;../create-table/index&quot;&gt;TABLE CREATE&lt;/a&gt; 문 사용의 &lt;code&gt;CONNECTION&lt;/code&gt; MariaDB가 사용하는 반면 거미 테이블 변수를 정의하는 &lt;code&gt;COMMENT&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="a2c78bab12047489c0481917cc2c69aac4ed423d" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;docker stop&lt;/code&gt;, the container will be gracefully terminated: a &lt;code&gt;SIGTERM&lt;/code&gt; signal will be sent to the &lt;code&gt;mysqld&lt;/code&gt; process, and Docker will wait for the process to shutdown before returning the control to the shell. However, it is also possible to set a timeout, after which the process will be immediately killed with a &lt;code&gt;SIGKILL&lt;/code&gt;. Or it is possible to immediately kill the process, with no timeout.</source>
          <target state="translated">으로 &lt;code&gt;docker stop&lt;/code&gt; A : 컨테이너가 정상적으로 종료됩니다 &lt;code&gt;SIGTERM&lt;/code&gt; 의 신호가 전송됩니다 &lt;code&gt;mysqld&lt;/code&gt; 프로세스 및 고정 표시기 쉘에 컨트롤을 반환하기 전에 종료에 과정을 기다립니다. 그러나 시간 초과를 설정하면 &lt;code&gt;SIGKILL&lt;/code&gt; 을 사용하여 프로세스가 즉시 종료 됩니다. 또는 시간 초과없이 프로세스를 즉시 종료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b3e1a18b6bc2ec97df1dd37c2d30bfc53a8656c" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;innodb-encrypt-tables=ON&lt;/code&gt;, new InnoDB tables will be encrypted by default, using the key ID set in &lt;code&gt;innodb_default_encryption_key_id&lt;/code&gt; (default 1). With &lt;code&gt;innodb-encrypt-tables=FORCE&lt;/code&gt; enabled, it is not possible to manually bypass encryption when creating a table.</source>
          <target state="translated">함께 &lt;code&gt;innodb-encrypt-tables=ON&lt;/code&gt; , 새로운 이노 테이블 내의 키 ID 설정하여, 기본적으로 암호화한다 &lt;code&gt;innodb_default_encryption_key_id&lt;/code&gt; (기본 1). 함께 &lt;code&gt;innodb-encrypt-tables=FORCE&lt;/code&gt; 테이블을 생성 할 때 활성화 수동 암호화를 바이 패스 할 수 없다.</target>
        </trans-unit>
        <trans-unit id="0c34faf40004d8223673aa215ef9adc58dd8941a" translate="yes" xml:space="preserve">
          <source>With CONNECT version 1.04 (from &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1016-release-notes/&quot;&gt;MariaDB 10.1.6&lt;/a&gt;), another way to provide random access is to specify some columns to be indexed. This should be done only when the corresponding column of the source table is also indexed. This should be used for tables too large to be stored in memory and is similar to the remote indexing used by the &lt;a href=&quot;../connect-table-types-mysql-table-type-accessing-mysqlmariadb-tables/index&quot;&gt;MYSQL table type&lt;/a&gt; and by the &lt;a href=&quot;../federatedx-storage-engine/index&quot;&gt;FEDERATED engine&lt;/a&gt;.</source>
          <target state="translated">CONNECT 버전 1.04 ( &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1016-release-notes/&quot;&gt;MariaDB 10.1.6&lt;/a&gt; )에서 무작위 액세스를 제공하는 다른 방법은 색인화 할 일부 열을 지정하는 것입니다. 소스 테이블의 해당 열도 색인화되는 경우에만 수행해야합니다. 메모리에 저장하기에는 너무 큰 테이블에 사용해야하며 &lt;a href=&quot;../connect-table-types-mysql-table-type-accessing-mysqlmariadb-tables/index&quot;&gt;MYSQL 테이블 유형&lt;/a&gt; 및 &lt;a href=&quot;../federatedx-storage-engine/index&quot;&gt;FEDERATED 엔진에서&lt;/a&gt; 사용하는 원격 인덱싱과 유사합니다. .</target>
        </trans-unit>
        <trans-unit id="87ce7324ee7805ad8e3d82b1703e3ce4172ba19b" translate="yes" xml:space="preserve">
          <source>With CONNECT, MariaDB has one of the most advanced implementations of MED and NoSQL, without the need for complex additions to the SQL syntax (foreign tables are &quot;normal&quot; tables using the CONNECT engine).</source>
          <target state="translated">CONNECT를 통해 MariaDB는 SQL 구문에 복잡한 추가 없이도 MED 및 NoSQL의 가장 고급 구현 중 하나를 갖습니다 (외부 테이블은 CONNECT 엔진을 사용하는 &quot;일반&quot;테이블).</target>
        </trans-unit>
        <trans-unit id="84b6c9cc8a75af7971210862caad6eddc2e46d0c" translate="yes" xml:space="preserve">
          <source>With Database Workbench you can:</source>
          <target state="translated">Database Workbench를 사용하면 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b16eb59ae6efbd3ee6353b38abebbcdb19cefda" translate="yes" xml:space="preserve">
          <source>With Galera, there is a moderate degree of write scaling.</source>
          <target state="translated">Galera를 사용하면 적당한 수준의 쓰기 스케일링이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9f9d1a6a60d8cab62a9dc5dbdda5b29ece74c2d" translate="yes" xml:space="preserve">
          <source>With INDEX(id), this suddenly becomes very efficient.</source>
          <target state="translated">INDEX (id)를 사용하면 갑자기 매우 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="dc17a3569e09c48a79eb11855e7803cc6d268b70" translate="yes" xml:space="preserve">
          <source>With INSERT ... SELECT, you can quickly insert many rows into a table from one or more other tables.</source>
          <target state="translated">INSERT ... SELECT를 사용하면 하나 이상의 다른 테이블에서 많은 행을 테이블에 빠르게 삽입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9172d6bebdb5998687c5b7e01fd3ac68df7e85ed" translate="yes" xml:space="preserve">
          <source>With InnoDB page compression, a page is only compressed when it is flushed to disk. This means that if you are monitoring InnoDB page compression via these status variables, then the status variables values will only get incremented when the dirty pages are flushed to disk, which does not necessarily happen immediately. For example:</source>
          <target state="translated">InnoDB 페이지 압축을 사용하면 디스크로 플러시 될 때만 페이지가 압축됩니다. 즉, 이러한 상태 변수를 통해 InnoDB 페이지 압축을 모니터링하는 경우 더티 페이지가 디스크로 플러시 될 때만 상태 변수 값이 증가하므로 반드시 즉시 발생하지는 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4fcebf01b6d6da244dcd33a1ab0e7a2db832691e" translate="yes" xml:space="preserve">
          <source>With InnoDB page compression, compressed pages are immediately decompressed after being read from the tablespace file, and only uncompressed pages are stored in the buffer pool. In contrast, with InnoDB's &lt;code&gt;&lt;a href=&quot;../innodb-compressed-row-format/index&quot;&gt;COMPRESSED&lt;/a&gt;&lt;/code&gt; row format, compressed pages are decompressed immediately after they are read from the tablespace file, and both the uncompressed and compressed pages are stored in the buffer pool. This means that the &lt;code&gt;&lt;a href=&quot;../innodb-compressed-row-format/index&quot;&gt;COMPRESSED&lt;/a&gt;&lt;/code&gt; row format uses more space in the buffer pool than InnoDB page compression does.</source>
          <target state="translated">InnoDB 페이지 압축을 사용하면 테이블 스페이스 파일에서 읽은 후 압축 된 페이지가 즉시 압축 해제되고 압축되지 않은 페이지 만 버퍼 풀에 저장됩니다. 반대로 InnoDB의 &lt;code&gt;&lt;a href=&quot;../innodb-compressed-row-format/index&quot;&gt;COMPRESSED&lt;/a&gt;&lt;/code&gt; 행 형식을 사용하면 테이블 스페이스 파일에서 압축 된 페이지를 읽은 직후 압축 된 페이지가 압축 해제되고 압축되지 않은 페이지와 압축 된 페이지가 모두 버퍼 풀에 저장됩니다. 이는 &lt;code&gt;&lt;a href=&quot;../innodb-compressed-row-format/index&quot;&gt;COMPRESSED&lt;/a&gt;&lt;/code&gt; 행 형식이 InnoDB 페이지 압축보다 버퍼 풀에서 더 많은 공간을 사용함을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="b84c1f4780f2ed25b40cde0e19abae67bf903a4d" translate="yes" xml:space="preserve">
          <source>With InnoDB page compression, multiple compression algorithms are supported. In contrast, with InnoDB's &lt;code&gt;&lt;a href=&quot;../innodb-compressed-row-format/index&quot;&gt;COMPRESSED&lt;/a&gt;&lt;/code&gt; row format, &lt;code&gt;&lt;a href=&quot;https://www.zlib.net/&quot;&gt;zlib&lt;/a&gt;&lt;/code&gt; is the only supported compression algorithm. This means that the &lt;code&gt;&lt;a href=&quot;../innodb-compressed-row-format/index&quot;&gt;COMPRESSED&lt;/a&gt;&lt;/code&gt; row format has less compression options than InnoDB page compression does.</source>
          <target state="translated">InnoDB 페이지 압축을 사용하면 여러 압축 알고리즘이 지원됩니다. 반면 InnoDB의 &lt;code&gt;&lt;a href=&quot;../innodb-compressed-row-format/index&quot;&gt;COMPRESSED&lt;/a&gt;&lt;/code&gt; 행 형식에서는 &lt;code&gt;&lt;a href=&quot;https://www.zlib.net/&quot;&gt;zlib&lt;/a&gt;&lt;/code&gt; 만이 유일하게 지원되는 압축 알고리즘입니다. 이것은 &lt;code&gt;&lt;a href=&quot;../innodb-compressed-row-format/index&quot;&gt;COMPRESSED&lt;/a&gt;&lt;/code&gt; 행 형식이 InnoDB 페이지 압축보다 압축 옵션이 적음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="8356c4903d0f2ea8408ad0014b556953a387bedb" translate="yes" xml:space="preserve">
          <source>With InnoDB page compression, pages are compressed just before being written to the tablespace file. In contrast, with InnoDB's &lt;code&gt;&lt;a href=&quot;../innodb-compressed-row-format/index&quot;&gt;COMPRESSED&lt;/a&gt;&lt;/code&gt; row format, pages are re-compressed immediately after any changes, and the compressed pages are stored in the buffer pool alongside the uncompressed pages. These changes are then occasionally flushed to disk. This means that the &lt;code&gt;&lt;a href=&quot;../innodb-compressed-row-format/index&quot;&gt;COMPRESSED&lt;/a&gt;&lt;/code&gt; row format re-compresses data more frequently than InnoDB page compression does.</source>
          <target state="translated">InnoDB 페이지 압축을 사용하면 테이블 스페이스 파일에 기록되기 직전에 페이지가 압축됩니다. 반대로 InnoDB의 &lt;code&gt;&lt;a href=&quot;../innodb-compressed-row-format/index&quot;&gt;COMPRESSED&lt;/a&gt;&lt;/code&gt; 행 형식을 사용하면 변경 후 즉시 페이지가 다시 압축되고 압축 된 페이지는 압축되지 않은 페이지와 함께 버퍼 풀에 저장됩니다. 이러한 변경 사항은 때때로 디스크로 플러시됩니다. 이는 &lt;code&gt;&lt;a href=&quot;../innodb-compressed-row-format/index&quot;&gt;COMPRESSED&lt;/a&gt;&lt;/code&gt; 행 형식이 InnoDB 페이지 압축보다 데이터를 더 자주 압축 한다는 것을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="852b6d2548dd2bd71099a28f5ee1f38311cdb66b" translate="yes" xml:space="preserve">
          <source>With InnoDB page compression, pages are compressed when they are flushed to disk. Therefore, it can be helpful to optimize the configuration of InnoDB's page flushing. See &lt;a href=&quot;../innodb-page-flushing/index&quot;&gt;InnoDB Page Flushing&lt;/a&gt; for more information.</source>
          <target state="translated">InnoDB 페이지 압축을 사용하면 디스크로 플러시 될 때 페이지가 압축됩니다. 따라서 InnoDB의 페이지 플러시 구성을 최적화하는 것이 도움이 될 수 있습니다. 자세한 내용은 &lt;a href=&quot;../innodb-page-flushing/index&quot;&gt;InnoDB 페이지 플러싱&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b1efe7b3c6a866b3aba4ee38cca1971217a5afac" translate="yes" xml:space="preserve">
          <source>With InnoDB tables using encryption, there are several cases where a &lt;code&gt;&lt;a href=&quot;../create-table/index&quot;&gt;CREATE TABLE&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt;&lt;/code&gt; statement can throw Error 1005, due to the InnoDB error 140, &lt;code&gt;Wrong create options&lt;/code&gt;. For instance,</source>
          <target state="translated">암호화를 사용하는 InnoDB 테이블의 경우 InnoDB 오류 140, &lt;code&gt;Wrong create options&lt;/code&gt; 으로 인해 &lt;code&gt;&lt;a href=&quot;../create-table/index&quot;&gt;CREATE TABLE&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt;&lt;/code&gt; 문이 오류 1005를 발생시킬 수 있는 몇 가지 경우가 있습니다 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="5b93405116643e95f2623544162e93864db23a55" translate="yes" xml:space="preserve">
          <source>With InnoDB, the table rebuild will only reclaim unused space (i.e. the space previously used for deleted rows) if the &lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_file_per_table&quot;&gt;innodb_file_per_table&lt;/a&gt;&lt;/code&gt; system variable is set to &lt;code&gt;ON&lt;/code&gt;. If the system variable is &lt;code&gt;OFF&lt;/code&gt;, then the space will not be reclaimed, but it will be-re-used for new data that's later added.</source>
          <target state="translated">InnoDB를 사용 &lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_file_per_table&quot;&gt;innodb_file_per_table&lt;/a&gt;&lt;/code&gt; 시스템 변수가 &lt;code&gt;ON&lt;/code&gt; 으로 설정된 경우 테이블 재 구축은 사용되지 않은 공간 (즉, 삭제 된 행에 이전에 사용 된 공간) 만 회수 합니다. 시스템 변수가 &lt;code&gt;OFF&lt;/code&gt; 인 경우 공간은 회수되지 않지만 나중에 추가 된 새 데이터에 재사용됩니다.</target>
        </trans-unit>
        <trans-unit id="10d50c5a6663895191851582f4c83c6970cdaa77" translate="yes" xml:space="preserve">
          <source>With InnoDB, users can see the following message as an error or warning:</source>
          <target state="translated">InnoDB를 사용하면 다음 메시지를 오류 또는 경고로 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7db7c20d47f1ee73ad0e21b8bf167ea2c38bd91f" translate="yes" xml:space="preserve">
          <source>With LIST COLUMNS, a row matches a partition if all row values are identical to the specified values. At most one partition can match the row.</source>
          <target state="translated">LIST COLUMNS를 사용하면 모든 행 값이 지정된 값과 동일한 경우 행이 파티션과 일치합니다. 최대 하나의 파티션이 행과 일치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e23a1d10cdd02b6159ae783e6d3b37995568e37" translate="yes" xml:space="preserve">
          <source>With Linux distributions that use &lt;a href=&quot;../systemd/index&quot;&gt;systemd&lt;/a&gt;, you need to set the environment variable in the service file, (systemd doesn't read from the /etc/environment file).</source>
          <target state="translated">&lt;a href=&quot;../systemd/index&quot;&gt;systemd&lt;/a&gt; 를 사용하는 Linux 배포판의 경우 서비스 파일에서 환경 변수를 설정해야합니다 (systemd는 / etc / environment 파일에서 읽지 않습니다).</target>
        </trans-unit>
        <trans-unit id="f457ea447237d9de81dd42fc5f43eac37a979d1e" translate="yes" xml:space="preserve">
          <source>With MERGE, the view definition and the related portion of the statement referring to the view are merged. If TEMPTABLE is selected, the view results are stored in a temporary table.</source>
          <target state="translated">MERGE를 사용하면 뷰 정의와 뷰를 참조하는 명령문의 관련 부분이 병합됩니다. TEMPTABLE을 선택하면 뷰 결과가 임시 테이블에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="fb1991b7888a6dcc51a57e4f1017194969308685" translate="yes" xml:space="preserve">
          <source>With MariaDB it's very easy to copy tables between different MariaDB databases and different MariaDB servers. This works for tables created with the &lt;a href=&quot;../archive/index&quot;&gt;Archive&lt;/a&gt;, &lt;a href=&quot;../aria/index&quot;&gt;Aria&lt;/a&gt;, &lt;a href=&quot;../csv/index&quot;&gt;CSV&lt;/a&gt;, &lt;a href=&quot;../innodb/index&quot;&gt;InnoDB&lt;/a&gt;, &lt;a href=&quot;../myisam/index&quot;&gt;MyISAM&lt;/a&gt;, &lt;a href=&quot;../merge/index&quot;&gt;MERGE&lt;/a&gt;, and &lt;a href=&quot;../innodb/index&quot;&gt;XtraDB&lt;/a&gt; engines.</source>
          <target state="translated">MariaDB를 사용하면 다른 MariaDB 데이터베이스와 다른 MariaDB 서버간에 테이블을 복사하는 것이 매우 쉽습니다. 이것은 &lt;a href=&quot;../archive/index&quot;&gt;Archive&lt;/a&gt; , &lt;a href=&quot;../aria/index&quot;&gt;Aria&lt;/a&gt; , &lt;a href=&quot;../csv/index&quot;&gt;CSV&lt;/a&gt; , &lt;a href=&quot;../innodb/index&quot;&gt;InnoDB&lt;/a&gt; , &lt;a href=&quot;../myisam/index&quot;&gt;MyISAM&lt;/a&gt; , &lt;a href=&quot;../merge/index&quot;&gt;MERGE&lt;/a&gt; 및 &lt;a href=&quot;../innodb/index&quot;&gt;XtraDB&lt;/a&gt; 엔진으로 생성 된 테이블에서 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="5ced70b0909797c3c34c942d36747b6d6a6e3bb8" translate="yes" xml:space="preserve">
          <source>With MariaDB, it is possible to upgrade from the MySQL 5.0 format without having to dump the tables.</source>
          <target state="translated">MariaDB를 사용하면 테이블을 덤프하지 않고도 MySQL 5.0 형식에서 업그레이드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82682ae8453c06d70311b21359852219eb56a101" translate="yes" xml:space="preserve">
          <source>With Mroonga, you can have a CJK-ready full text search feature, and it is faster than the &lt;a href=&quot;../myisam/index&quot;&gt;MyISAM&lt;/a&gt; and &lt;a href=&quot;../innodb/index&quot;&gt;InnoDB&lt;/a&gt;&lt;a href=&quot;../full-text-indexes/index&quot;&gt;full text search&lt;/a&gt; for both updating and searching.</source>
          <target state="translated">Mroonga를 사용하면 CJK 지원 전체 텍스트 검색 기능을 사용할 수 있으며 &lt;a href=&quot;../myisam/index&quot;&gt;MyISAM&lt;/a&gt; 및 &lt;a href=&quot;../innodb/index&quot;&gt;InnoDB &lt;/a&gt;&lt;a href=&quot;../full-text-indexes/index&quot;&gt;전체 텍스트 검색&lt;/a&gt; 보다 업데이트 및 검색 이 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="d7be3142d27609e91b96534704b6932d4da79fa4" translate="yes" xml:space="preserve">
          <source>With RANGE COLUMNS, a row matches a partition if all row values are less than specified values. The first partition that matches row values will be used.</source>
          <target state="translated">RANGE COLUMNS를 사용하면 모든 행 값이 지정된 값보다 작은 경우 행이 파티션과 일치합니다. 행 값과 일치하는 첫 번째 파티션이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fa9edf3dc1b119dc9d8ffd2403b01e3fa6c0091b" translate="yes" xml:space="preserve">
          <source>With Visual Studio 2017, use corresponding 32bit generator</source>
          <target state="translated">Visual Studio 2017에서는 해당 32 비트 생성기를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="20d3b3ab64d1d632ef1e8eb0205fe29f02ef6449" translate="yes" xml:space="preserve">
          <source>With Visual Studio 2019, pass -A Win32 parameter for CMake, like this</source>
          <target state="translated">Visual Studio 2019에서 CMake에 -A Win32 매개 변수를 다음과 같이 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="3006b1f05726f9f36feb282e71f4c90c40ab6713" translate="yes" xml:space="preserve">
          <source>With WAN replication topology, cluster nodes can be located close to clients. Therefore all read &amp;amp; write operations will be super fast with the local node connection. The RTT related delay will be experienced only at commit time, and even then it can be generally accepted by end user, usually the kill-joy for end user experiences is the slow browsing response time, and read operations are as fast as they possibly can be.</source>
          <target state="translated">WAN 복제 토폴로지를 사용하면 클러스터 노드를 클라이언트 가까이에 위치시킬 수 있습니다. 따라서 모든 읽기 및 쓰기 작업은 로컬 노드 연결로 매우 빠릅니다. RTT 관련 지연은 커밋 시간에만 발생하며 최종 사용자가 일반적으로 받아 들일 수 있습니다. 일반적으로 최종 사용자 경험에 대한 킬-조이는 브라우징 응답 시간이 느리고 읽기 작업이 가능한 한 빨리 수행됩니다. 있다.</target>
        </trans-unit>
        <trans-unit id="4c0716491d62d746c18ae551433d2439338e54f8" translate="yes" xml:space="preserve">
          <source>With a &lt;a href=&quot;../compiling-mariadb-for-debugging/index&quot;&gt;MariaDB for debug build&lt;/a&gt;, it can be enabled by a mysqld command line option:</source>
          <target state="translated">A를 &lt;a href=&quot;../compiling-mariadb-for-debugging/index&quot;&gt;디버그 빌드에 대한 MariaDB&lt;/a&gt; , 그것은 mysqld를 명령 줄 옵션으로 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="240ef91a16272d8606b9bccec8f538c50bb30d92" translate="yes" xml:space="preserve">
          <source>With a &lt;code&gt;FOR&lt;/code&gt; clause, this statement sets the password for a specific account on the current server host. Only clients that have the &lt;code&gt;UPDATE&lt;/code&gt; privilege for the &lt;code&gt;mysql&lt;/code&gt; database can do this. The user value should be given in &lt;code&gt;user_name@host_name&lt;/code&gt; format, where &lt;code&gt;user_name&lt;/code&gt; and &lt;code&gt;host_name&lt;/code&gt; are exactly as they are listed in the User and Host columns of the &lt;code&gt;&lt;a href=&quot;../mysqluser-table/index&quot;&gt;mysql.user&lt;/a&gt;&lt;/code&gt; table entry.</source>
          <target state="translated">&lt;code&gt;FOR&lt;/code&gt; 절을 사용하면 이 명령문은 현재 서버 호스트에서 특정 계정의 비밀번호를 설정합니다. &lt;code&gt;mysql&lt;/code&gt; 데이터베이스에 대한 &lt;code&gt;UPDATE&lt;/code&gt; 권한 이있는 클라이언트 만이 를 수행 할 수 있습니다. 사용자 값은 &lt;code&gt;user_name@host_name&lt;/code&gt; 형식 으로 제공해야 합니다. 여기서 &lt;code&gt;user_name&lt;/code&gt; 및 &lt;code&gt;host_name&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;../mysqluser-table/index&quot;&gt;mysql.user&lt;/a&gt;&lt;/code&gt; 테이블 항목 의 User 및 Host 열에 나열된 것과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="5fed98769253ee397b27d20e3d87eb22f3e114f7" translate="yes" xml:space="preserve">
          <source>With a high value for swappiness, you lose some RAM because the OS is trying to keep a lot of space free for future allocations (that MySQL is not likely to need).</source>
          <target state="translated">스왑 파이 (swappiness)에 대한 가치가 높으면, OS가 향후 할당을 위해 많은 공간을 확보하려고 노력하므로 (RAM이 필요하지 않음) RAM이 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="99a95949067382e07bddc39f7b5531a47cb02e28" translate="yes" xml:space="preserve">
          <source>With a single argument, this function returns the date or datetime expression &lt;code&gt;expr&lt;/code&gt; as a datetime value. With two arguments, it adds the time expression &lt;code&gt;expr2&lt;/code&gt; to the date or datetime expression &lt;code&gt;expr1&lt;/code&gt; and returns the result as a datetime value.</source>
          <target state="translated">단일 인수를 사용하면이 함수는 날짜 또는 날짜 / 시간 표현식 &lt;code&gt;expr&lt;/code&gt; 을 날짜 / 시간 값으로 반환합니다 . 두 개의 인수를 사용하면 시간 표현식 &lt;code&gt;expr2&lt;/code&gt; 를 날짜 또는 날짜 시간 표현식 &lt;code&gt;expr1&lt;/code&gt; 에 추가 하고 결과를 날짜 시간 값으로 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="6f52f377e1942482ce4b197ad1e7899872a47f91" translate="yes" xml:space="preserve">
          <source>With a table &quot;mytable&quot; in database &quot;test&quot;, you can compare the output with &lt;code&gt;--flashback&lt;/code&gt; and without.</source>
          <target state="translated">데이터베이스 &quot;test&quot;의 &quot;mytable&quot;테이블을 사용하면 출력을 &lt;code&gt;--flashback&lt;/code&gt; 과 함께 또는없이 비교할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cb1b5c7e746c8ba379508ec6d3be7e4e01e3d81d" translate="yes" xml:space="preserve">
          <source>With each slave MariaDB Server in your deployment, configure it to replicate data from the master server and start the replication process. Perform the following operations on each slave server, (that is, &lt;code&gt;Server-2&lt;/code&gt; through &lt;code&gt;Server-4&lt;/code&gt;).</source>
          <target state="translated">배포시 각 슬레이브 MariaDB 서버와 함께 마스터 서버에서 데이터를 복제하고 복제 프로세스를 시작하도록 구성하십시오. 각 슬레이브 서버 (즉, &lt;code&gt;Server-2&lt;/code&gt; ~ &lt;code&gt;Server-4&lt;/code&gt; ) 에서 다음 작업을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="d31099289091c0da502e88c54bf89fdcf00551a9" translate="yes" xml:space="preserve">
          <source>With earlier versions of the Mongo C Driver, the additional include directories and libraries will have to be specified manually when compiling.</source>
          <target state="translated">이전 버전의 Mongo C 드라이버에서는 컴파일 할 때 추가 포함 디렉토리 및 라이브러리를 수동으로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="be1b6530475bbc1fcf75d4c8f05163b2561798aa" translate="yes" xml:space="preserve">
          <source>With encryption you protect Data At Rest (see the &lt;a href=&quot;http://en.wikipedia.org/wiki/Data_at_Rest&quot;&gt;Wikipedia article&lt;/a&gt;). That way, the database files are protected against unauthorized access.</source>
          <target state="translated">암호화로 Data At Rest를 보호합니다 ( &lt;a href=&quot;http://en.wikipedia.org/wiki/Data_at_Rest&quot;&gt;Wikipedia 기사 참조&lt;/a&gt; ). 이렇게하면 데이터베이스 파일이 무단 액세스로부터 보호됩니다.</target>
        </trans-unit>
        <trans-unit id="edb44b1e52d3da65d39472542c81e74f110b2377" translate="yes" xml:space="preserve">
          <source>With example results:</source>
          <target state="translated">결과 예 :</target>
        </trans-unit>
        <trans-unit id="87790a65e6b3bb90cfd4d47e34491f767acdec76" translate="yes" xml:space="preserve">
          <source>With exponents:</source>
          <target state="translated">지수와 함께 :</target>
        </trans-unit>
        <trans-unit id="9ca3f10c18f112713abc59e9f63cdaeb5c930c13" translate="yes" xml:space="preserve">
          <source>With filtering, the query plan would be:</source>
          <target state="translated">필터링을 사용하면 쿼리 계획은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="900bf3670932297871c57dbdc40d1d9470c85444" translate="yes" xml:space="preserve">
          <source>With histograms available, the optimizer can choose the following, more efficient plan:</source>
          <target state="translated">히스토그램을 사용할 수 있으면 옵티마이 저는 다음보다 효율적인 계획을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b65d9d7731945ba43f6d284ac3e9cdd3c209460" translate="yes" xml:space="preserve">
          <source>With instant &lt;code&gt;&lt;a href=&quot;../alter-table/index#add-column&quot;&gt;ALTER TABLE ... ADD COLUMN&lt;/a&gt;&lt;/code&gt;, you can enjoy all the benefits of structured storage without the drawback of having to rebuild the table.</source>
          <target state="translated">인스턴트 &lt;code&gt;&lt;a href=&quot;../alter-table/index#add-column&quot;&gt;ALTER TABLE ... ADD COLUMN&lt;/a&gt;&lt;/code&gt; 을 사용하면 테이블을 재구성하지 않고도 구조적 스토리지의 모든 이점을 누릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43a1f17996cf48a9a42bdec4024aaca9584a088a" translate="yes" xml:space="preserve">
          <source>With just its default column, a VIR table is almost equivalent to a &lt;a href=&quot;../sequence/index&quot;&gt;SEQUENCE&lt;/a&gt; table. The syntax used is the main difference, for instance:</source>
          <target state="translated">기본 열만 사용하면 VIR 테이블은 &lt;a href=&quot;../sequence/index&quot;&gt;SEQUENCE&lt;/a&gt; 와 거의 같습니다. 테이블 . 사용 된 구문은 다음과 같은 주요 차이점입니다.</target>
        </trans-unit>
        <trans-unit id="2b84c9c9e2f705d03261745bb1dd1e20a8ce5c77" translate="yes" xml:space="preserve">
          <source>With more experience, additional UDFs can be easily written to support new needs.</source>
          <target state="translated">경험이 많을수록 새로운 요구를 지원하기 위해 추가 UDF를 쉽게 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c1e129a77eab15ce79c30d1e5eae3b9daedea34" translate="yes" xml:space="preserve">
          <source>With multiple domains in the UNTIL condition, each domain runs only up to and including the specified position, so it is possible for different domains to stop at different places in the binlog (each domain will resume from the stopped position when the slave is started the next time).</source>
          <target state="translated">UNTIL 조건에 여러 도메인이있는 경우 각 도메인은 지정된 위치까지만 실행되므로 binlog의 다른 위치에서 다른 도메인이 중지 될 수 있습니다 (슬레이브가 시작될 때 각 도메인은 중지 된 위치에서 다시 시작됩니다) 다음에).</target>
        </trans-unit>
        <trans-unit id="4d35210202a52cb15458ac4d3172cf949731baba" translate="yes" xml:space="preserve">
          <source>With neither the extra index, nor 5.6, this 'solution' would belong in 'The Duds' because it would run in O(N*N) time.</source>
          <target state="translated">추가 색인이나 5.6이 없으면이 '솔루션'은 O (N * N) 시간에 실행되므로 'The Duds'에 속합니다.</target>
        </trans-unit>
        <trans-unit id="bc8e0719af116ce01f6392f193b8e180a0f94477" translate="yes" xml:space="preserve">
          <source>With no &lt;code&gt;FOR&lt;/code&gt; clause, this statement sets the password for the current user. Any client that has connected to the server using a non-anonymous account can change the password for that account.</source>
          <target state="translated">&lt;code&gt;FOR&lt;/code&gt; 절이 없으면 이 명령문은 현재 사용자의 비밀번호를 설정합니다. 익명이 아닌 계정을 사용하여 서버에 연결된 모든 클라이언트는 해당 계정의 비밀번호를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="206b239aaf795ac5175b281e489a653090c41ad0" translate="yes" xml:space="preserve">
          <source>With no options, myisamchk simply checks your table as the default operation.</source>
          <target state="translated">옵션이 없으면 myisamchk는 단순히 테이블을 기본 작업으로 확인합니다.</target>
        </trans-unit>
        <trans-unit id="f0a3d72c358abddde6a94e164fd4a42a5976f9f6" translate="yes" xml:space="preserve">
          <source>With non-transactional storage engines, if a BEFORE statement produces an error, the statement will not be executed. Statements that affect multiple rows will fail before inserting the current row.</source>
          <target state="translated">비 트랜잭션 스토리지 엔진의 경우 BEFORE 문에서 오류가 발생하면 명령문이 실행되지 않습니다. 현재 행을 삽입하기 전에 여러 행에 영향을주는 명령문이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="0b165a80289bc5b64dfe37e779cf7f547a40e6af" translate="yes" xml:space="preserve">
          <source>With one non-InnoDB Staging table per Inserter, using an explicit LOCK TABLE avoids repeated implicit locks on each INSERT.</source>
          <target state="translated">Inserter 당 하나의 InnoDB Staging 테이블이 아닌 경우 명시 적 LOCK TABLE을 사용하면 각 INSERT에서 암시 적 잠금이 반복되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="beb991b309d0585e62f8dcf915f7792d606e6abb" translate="yes" xml:space="preserve">
          <source>With openSUSE and SUSE, you can use the source-install command.</source>
          <target state="translated">openSUSE 및 SUSE를 사용하면 source-install 명령을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9230d5c62f521df1d9ed0db178265e0b5b8e5c60" translate="yes" xml:space="preserve">
          <source>With partition engine this will display partition name like P#p0</source>
          <target state="translated">파티션 엔진을 사용하면 P # p0과 같은 파티션 이름이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="63a24eb3903e7932cf097f1309a1ba1e99f50b2a" translate="yes" xml:space="preserve">
          <source>With precision:</source>
          <target state="translated">정밀하게 :</target>
        </trans-unit>
        <trans-unit id="a14e8b2c0bd6ca1ccd151098a135cd3d248a2377" translate="yes" xml:space="preserve">
          <source>With respect to the allowed operations, the &lt;code&gt;INPLACE&lt;/code&gt; algorithm supports a subset of the operations supported by the &lt;code&gt;COPY&lt;/code&gt; algorithm, and it supports a superset of the operations supported by the &lt;code&gt;NOCOPY&lt;/code&gt; algorithm.</source>
          <target state="translated">허용 된 연산과 관련하여 &lt;code&gt;INPLACE&lt;/code&gt; 알고리즘은 &lt;code&gt;COPY&lt;/code&gt; 알고리즘이 지원하는 연산의 하위 집합을 지원하고 &lt;code&gt;NOCOPY&lt;/code&gt; 알고리즘이 지원하는 연산의 슈퍼 세트를 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="8c76cb1dbe79a8725391466acb199f2c2ad9dab2" translate="yes" xml:space="preserve">
          <source>With respect to the allowed operations, the &lt;code&gt;INSTANT&lt;/code&gt; algorithm supports a subset of the operations supported by the &lt;code&gt;NOCOPY&lt;/code&gt; algorithm.</source>
          <target state="translated">허용 된 작업과 관련하여 &lt;code&gt;INSTANT&lt;/code&gt; 알고리즘은 &lt;code&gt;NOCOPY&lt;/code&gt; 가 지원하는 작업의 하위 집합을 지원합니다 알고리즘이 합니다.</target>
        </trans-unit>
        <trans-unit id="f3b6988050b482da973b1891156f92b01631eb1e" translate="yes" xml:space="preserve">
          <source>With respect to the allowed operations, the &lt;code&gt;NOCOPY&lt;/code&gt; algorithm supports a subset of the operations supported by the &lt;code&gt;INPLACE&lt;/code&gt; algorithm, and it supports a superset of the operations supported by the &lt;code&gt;INSTANT&lt;/code&gt; algorithm.</source>
          <target state="translated">허용 된 연산과 관련하여 &lt;code&gt;NOCOPY&lt;/code&gt; 알고리즘은 &lt;code&gt;INPLACE&lt;/code&gt; 알고리즘이 지원하는 연산의 하위 집합을 지원하고 &lt;code&gt;INSTANT&lt;/code&gt; 알고리즘이 지원하는 연산의 슈퍼 세트를 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="f11aa996869c9833d4517300f2dd498f3826b133" translate="yes" xml:space="preserve">
          <source>With roles, managing this is easy. For example, there could be a number of users assigned to a journalist role, with identical privileges. Changing the privileges for all the journalists is a matter of simply changing the role's privileges, while the individual user is still linked with any changes that take place.</source>
          <target state="translated">역할을 사용하면이를 쉽게 관리 할 수 ​​있습니다. 예를 들어, 동일한 권한으로 저널리스트 역할에 여러 사용자가 할당 될 수 있습니다. 모든 기자의 권한을 변경하는 것은 단순히 역할의 권한을 변경하는 문제이며 개별 사용자는 여전히 변경 사항과 연결되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="64bb00fe7658186cc023cc331de8cd9a34661049" translate="yes" xml:space="preserve">
          <source>With some partitioning types, a partitioning expression is also required. A partitioning function is an SQL expression returning an integer or temporal value, used to determine which row will contain a given row. The partitioning expression is used for all reads and writes on involving the partitioned table, thus it should be fast.</source>
          <target state="translated">일부 파티셔닝 유형의 경우 파티셔닝 표현식도 필요합니다. 파티션 함수는 주어진 행을 포함 할 행을 판별하는 데 사용되는 정수 또는 시간 값을 리턴하는 SQL 표현식입니다. 파티셔닝 표현식은 파티셔닝 된 테이블과 관련된 모든 읽기 및 쓰기에 사용되므로 속도가 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="67604812a5097192b4ed0bd51cd2eeaaff518848" translate="yes" xml:space="preserve">
          <source>With strict mode not set (default in version &amp;lt;= &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1023-release-notes/&quot;&gt;MariaDB 10.2.3&lt;/a&gt;), MariaDB will automatically adjust invalid values, for example, truncating strings that are too long, or adjusting numeric values that are out of range, and produce a warning.</source>
          <target state="translated">엄격 모드가 설정되어 있지 않으면 (버전 &amp;lt;= &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1023-release-notes/&quot;&gt;MariaDB 10.2.3의&lt;/a&gt; 기본값 ) MariaDB는 유효하지 않은 값을 자동으로 조정합니다 (예 : 너무 긴 문자열 자르기 또는 범위를 벗어난 숫자 값 조정 및 경고 발생).</target>
        </trans-unit>
        <trans-unit id="ddb5338e431769b10d3e86246cf00be9ebdb3f6c" translate="yes" xml:space="preserve">
          <source>With strict mode set (default from &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1024-release-notes/&quot;&gt;MariaDB 10.2.4&lt;/a&gt;), statements that modify tables (either transactional for &lt;code&gt;STRICT_TRANS_TABLES&lt;/code&gt; or all for &lt;code&gt;STRICT_ALL_TABLES&lt;/code&gt;) will fail, and an error will be returned instead. The IGNORE keyword can be used when strict mode is set to convert the error to a warning.</source>
          <target state="translated">엄격 모드가 설정되면 (기본값은 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1024-release-notes/&quot;&gt;MariaDB 10.2.4&lt;/a&gt; ), 테이블을 수정하는 명령문 ( &lt;code&gt;STRICT_TRANS_TABLES&lt;/code&gt; 의 트랜잭션 또는 &lt;code&gt;STRICT_ALL_TABLES&lt;/code&gt; 의 모든 트랜잭션) )이 실패하고 대신 오류가 리턴됩니다. 엄격 모드가 오류를 경고로 변환하도록 설정된 경우 IGNORE 키워드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd611347ae61ea310465521d61d7132931b38e3d" translate="yes" xml:space="preserve">
          <source>With strict_mode set:</source>
          <target state="translated">strict_mode가 설정된 경우 :</target>
        </trans-unit>
        <trans-unit id="68cbc674b7c81b7daffc5f566225691c990e2b5e" translate="yes" xml:space="preserve">
          <source>With strict_mode unset:</source>
          <target state="translated">strict_mode를 설정하지 않은 상태 :</target>
        </trans-unit>
        <trans-unit id="b8daa7a7faef8373b9cbad7f86a9eefa1d099c2d" translate="yes" xml:space="preserve">
          <source>With swappiness = 0, the OS will probably crash rather than swap. I would rather have MariaDB limping than die. The latest recommendation is swappiness = 1. (2015)</source>
          <target state="translated">swappiness = 0이면 OS가 스왑이 아닌 충돌 할 수 있습니다. 차라리 MariaDB가 죽는 것보다 절뚝 거리고 싶습니다. 최신 권장 사항은 swappiness = 1입니다. (2015)</target>
        </trans-unit>
        <trans-unit id="ecce63488a2db9cdf803cd86e2bd2927a16659e9" translate="yes" xml:space="preserve">
          <source>With table partitioning, each partition is physically represented by a sub-table. Compared to standard partitioning, this brings the following features:</source>
          <target state="translated">테이블 파티셔닝에서 각 파티션은 물리적으로 서브 테이블로 표시됩니다. 표준 파티셔닝에 비해 다음과 같은 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="08e7effba8087d1650dfa433c2c6a64b87991708" translate="yes" xml:space="preserve">
          <source>With tables that the user creates, you can disable encryption by setting the &lt;code&gt;&lt;a href=&quot;../aria-system-variables/index#aria_encrypt_tables&quot;&gt;aria_encrypt_tables&lt;/a&gt;&lt;/code&gt; system variable to &lt;code&gt;OFF&lt;/code&gt;. Once this is set, MariaDB no longer encrypts new tables created with the Aria storage engine.</source>
          <target state="translated">사용자가 작성하는 테이블을 사용하면 &lt;code&gt;&lt;a href=&quot;../aria-system-variables/index#aria_encrypt_tables&quot;&gt;aria_encrypt_tables&lt;/a&gt;&lt;/code&gt; 시스템 변수를 &lt;code&gt;OFF&lt;/code&gt; 로 설정하여 암호화를 비활성화 할 수 있습니다 . 이것이 설정되면 MariaDB는 더 이상 Aria 스토리지 엔진으로 생성 된 새 테이블을 암호화하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2e74bc9a8562d4d0a020b912e3e8fafeb4b531bd" translate="yes" xml:space="preserve">
          <source>With tables that the user creates, you can enable encryption by setting the &lt;code&gt;&lt;a href=&quot;../aria-system-variables/index#aria_encrypt_tables&quot;&gt;aria_encrypt_tables&lt;/a&gt;&lt;/code&gt; system variable to &lt;code&gt;ON&lt;/code&gt;, then restart the Server. Once this is set, Aria automatically enables encryption on all tables you create after with the &lt;code&gt;&lt;a href=&quot;../create-table/index#row_format&quot;&gt;ROW_FORMAT&lt;/a&gt;&lt;/code&gt; table option set to &lt;code&gt;PAGE&lt;/code&gt;.</source>
          <target state="translated">사용자가 작성하는 테이블을 사용하면 &lt;code&gt;&lt;a href=&quot;../aria-system-variables/index#aria_encrypt_tables&quot;&gt;aria_encrypt_tables&lt;/a&gt;&lt;/code&gt; 시스템 변수를 &lt;code&gt;ON&lt;/code&gt; 으로 설정 한 후 서버를 다시 시작하여 암호화를 사용할 수 있습니다 . 이것이 설정되면 Aria는 &lt;code&gt;&lt;a href=&quot;../create-table/index#row_format&quot;&gt;ROW_FORMAT&lt;/a&gt;&lt;/code&gt; 테이블 옵션을 &lt;code&gt;PAGE&lt;/code&gt; 로 설정 한 후 생성 한 모든 테이블에서 자동으로 암호화를 활성화 합니다 .</target>
        </trans-unit>
        <trans-unit id="3713b8de00ff0af23cfc816a1f9f808f6dcd3133" translate="yes" xml:space="preserve">
          <source>With tables that use &lt;a href=&quot;../innodb-enabling-encryption/index#enabling-encryption-for-automatically-encrypted-tablespaces&quot;&gt;automatically&lt;/a&gt; enabled encryption, one way to set the specific encryption key for the table is to use the &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_default_encryption_key_id&quot;&gt;innodb_default_encryption_key_id&lt;/a&gt;&lt;/code&gt; system variable. For example:</source>
          <target state="translated">사용하는 테이블과 함께 &lt;a href=&quot;../innodb-enabling-encryption/index#enabling-encryption-for-automatically-encrypted-tablespaces&quot;&gt;자동으로&lt;/a&gt; 암호화를 사용 가능, 테이블의 특정 암호화 키를 설정하는 한 가지 방법은 사용하는 것입니다 &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_default_encryption_key_id&quot;&gt;innodb_default_encryption_key_id&lt;/a&gt;&lt;/code&gt; 시스템 변수를. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cad07c59f0e8b6db7be122092d3fce11151989ed" translate="yes" xml:space="preserve">
          <source>With tables that use &lt;a href=&quot;../innodb-enabling-encryption/index#enabling-encryption-for-manually-encrypted-tablespaces&quot;&gt;manually&lt;/a&gt; enabled encryption, one way to set the specific encryption key for the table is to use the &lt;code&gt;&lt;a href=&quot;../create-table/index#encryption_key_id&quot;&gt;ENCRYPTION_KEY_ID&lt;/a&gt;&lt;/code&gt; table option. For example:</source>
          <target state="translated">사용하는 테이블을 통해 &lt;a href=&quot;../innodb-enabling-encryption/index#enabling-encryption-for-manually-encrypted-tablespaces&quot;&gt;수동으로&lt;/a&gt; 암호화를 사용 가능, 테이블의 특정 암호화 키를 설정하는 한 가지 방법은 사용하는 것입니다 &lt;code&gt;&lt;a href=&quot;../create-table/index#encryption_key_id&quot;&gt;ENCRYPTION_KEY_ID&lt;/a&gt;&lt;/code&gt; 의 테이블 옵션을 선택합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e77a18df3fee43ac1ee581c71efcb777075a8cd9" translate="yes" xml:space="preserve">
          <source>With tablespaces, the minimum size is 10MB, the maximum varies depending on the InnoDB Page Size.</source>
          <target state="translated">테이블 스페이스에서 최소 크기는 10MB이며 최대 크기는 InnoDB 페이지 크기에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="8ce4b8f29f19c44102d28010a8544e4f4bf98431" translate="yes" xml:space="preserve">
          <source>With the 1.1.X version of MariaDB ColumnStore, there should be no versions of MariaDB Server or MySQL pre-installed on the OS before a MariaDB ColumnStore binary or RPM is installed on the system. If you have an installation of MariaDB server, uninstall it before proceeding.</source>
          <target state="translated">MariaDB ColumnStore 1.1.X 버전에서는 MariaDB ColumnStore 바이너리 또는 RPM이 시스템에 설치되기 전에 OS에 MariaDB 서버 또는 MySQL 버전이 사전 설치되어 있지 않아야합니다. MariaDB 서버를 설치 한 경우 계속하기 전에 서버를 설치 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="fd9f056eab2ac97e8d5951334e3bf865c55c840a" translate="yes" xml:space="preserve">
          <source>With the 1.2.0 version of MariaDB ColumnStore, there should be no versions of MariaDB Server or MySQL pre-installed on the OS before a MariaDB ColumnStore binary or RPM is installed on the system. If you have an installation of MariaDB server, uninstall it before proceeding.</source>
          <target state="translated">1.2.0 버전의 MariaDB ColumnStore를 사용하는 경우 시스템에 MariaDB ColumnStore 바이너리 또는 RPM을 설치하기 전에 OS에 MariaDB 서버 또는 MySQL 버전이 사전 설치되어 있지 않아야합니다. MariaDB 서버를 설치 한 경우 계속하기 전에 서버를 설치 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="3ced67bc1a9485d85b03884df7eff1c7713de406" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;../innodb/index&quot;&gt;InnoDB&lt;/a&gt; storage engine, if you specify a non-zero value for the &lt;code&gt;KEY_BLOCK_SIZE&lt;/code&gt; table option for the whole table, then the table will implicitly be created with the &lt;code&gt;&lt;a href=&quot;#row_format&quot;&gt;ROW_FORMAT&lt;/a&gt;&lt;/code&gt; table option set to &lt;code&gt;COMPRESSED&lt;/code&gt;.</source>
          <target state="translated">으로 &lt;a href=&quot;../innodb/index&quot;&gt;이노&lt;/a&gt; 당신이 0이 아닌 값을 지정하면 스토리지 엔진, &lt;code&gt;KEY_BLOCK_SIZE&lt;/code&gt; 의 전체 테이블에 대한 테이블 옵션 다음 테이블은 암시 적으로 생성됩니다 &lt;code&gt;&lt;a href=&quot;#row_format&quot;&gt;ROW_FORMAT&lt;/a&gt;&lt;/code&gt; 의 에 테이블 옵션을 설정 &lt;code&gt;COMPRESSED&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f98c91c44efbebce935caeb97469a8c51cb9b61" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;../innodb/index&quot;&gt;InnoDB&lt;/a&gt; storage engine, if you specify a non-zero value for the &lt;code&gt;KEY_BLOCK_SIZE&lt;/code&gt; table option for the whole table, then the table will implicitly be created with the &lt;code&gt;&lt;a href=&quot;#row_format&quot;&gt;ROW_FORMAT&lt;/a&gt;&lt;/code&gt; table option set to &lt;code&gt;COMPRESSED&lt;/code&gt;. However, this does not happen if you just set the &lt;code&gt;KEY_BLOCK_SIZE&lt;/code&gt; index option for one or more indexes in the table. The &lt;a href=&quot;../innodb/index&quot;&gt;InnoDB&lt;/a&gt; storage engine ignores the &lt;code&gt;KEY_BLOCK_SIZE&lt;/code&gt; index option. However, the &lt;code&gt;&lt;a href=&quot;../show-create-table/index&quot;&gt;SHOW CREATE TABLE&lt;/a&gt;&lt;/code&gt; statement may still report it for the index.</source>
          <target state="translated">으로 &lt;a href=&quot;../innodb/index&quot;&gt;이노&lt;/a&gt; 당신이 0이 아닌 값을 지정하면 스토리지 엔진, &lt;code&gt;KEY_BLOCK_SIZE&lt;/code&gt; 의 전체 테이블에 대한 테이블 옵션 다음 테이블은 암시 적으로 생성됩니다 &lt;code&gt;&lt;a href=&quot;#row_format&quot;&gt;ROW_FORMAT&lt;/a&gt;&lt;/code&gt; 의 에 테이블 옵션을 설정 &lt;code&gt;COMPRESSED&lt;/code&gt; . 그러나 테이블에서 하나 이상의 인덱스에 대해 &lt;code&gt;KEY_BLOCK_SIZE&lt;/code&gt; 인덱스 옵션을 설정 한 경우에는이 문제가 발생하지 않습니다 . &lt;a href=&quot;../innodb/index&quot;&gt;이노&lt;/a&gt; 스토리지 엔진은 무시 &lt;code&gt;KEY_BLOCK_SIZE&lt;/code&gt; 의 인덱스 옵션을 선택합니다. 그러나 &lt;code&gt;&lt;a href=&quot;../show-create-table/index&quot;&gt;SHOW CREATE TABLE&lt;/a&gt;&lt;/code&gt; 문은 여전히 ​​색인에 대해이를보고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ce35be2e281f90c4e0d39bfba6fb71705c131d2" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;../mariadb/configuring-columnstore-local-pm-query-mode/index&quot;&gt;infinidb_local_query&lt;/a&gt; variable set to 0 (default with &lt;a href=&quot;../mariadb/configuring-columnstore-local-pm-query-mode/index&quot;&gt;local PM Query&lt;/a&gt; ):</source>
          <target state="translated">와 &lt;a href=&quot;../mariadb/configuring-columnstore-local-pm-query-mode/index&quot;&gt;infinidb_local_query의&lt;/a&gt; (과 기본 0으로 설정 변수 &lt;a href=&quot;../mariadb/configuring-columnstore-local-pm-query-mode/index&quot;&gt;현지 PM 쿼리&lt;/a&gt; ) :</target>
        </trans-unit>
        <trans-unit id="39fd7beac22853ed8349fa10846820143b821f5c" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;../mysqld_safe/index&quot;&gt;mysqld_safe&lt;/a&gt;&lt;code&gt;--syslog&lt;/code&gt; option one can duplicate the messages to the system's syslog.</source>
          <target state="translated">&lt;a href=&quot;../mysqld_safe/index&quot;&gt;mysqld_safe &lt;/a&gt; &lt;code&gt;--syslog&lt;/code&gt; 옵션을 사용하면 메시지를 시스템의 syslog에 복제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="278315f252f1430bd3285bc9ac2e1de144e519f7" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;GLOBAL&lt;/code&gt; keyword, the statement sets the default transaction level globally for all subsequent sessions. Existing sessions are unaffected.</source>
          <target state="translated">으로 &lt;code&gt;GLOBAL&lt;/code&gt; 키워드, 문장 이후의 모든 세션에 대해 전 세계적으로 기본 트랜잭션 레벨을 설정합니다. 기존 세션은 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4b5e22ce609c63f9688ecf31f0d532c7ad95ecf3" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;GLOBAL&lt;/code&gt; modifier, &lt;code&gt;SHOW STATUS&lt;/code&gt; displays the status values for all connections to MariaDB. With &lt;code&gt;SESSION&lt;/code&gt;, it displays the status values for the current connection. If no modifier is present, the default is &lt;code&gt;SESSION&lt;/code&gt;. &lt;code&gt;LOCAL&lt;/code&gt; is a synonym for &lt;code&gt;SESSION&lt;/code&gt;. If you see a lot of 0 values, the reason is probably that you have used &lt;code&gt;SHOW STATUS&lt;/code&gt; with a new connection instead of &lt;code&gt;SHOW GLOBAL STATUS&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;GLOBAL&lt;/code&gt; 수정 자 와 함께 &lt;code&gt;SHOW STATUS&lt;/code&gt; 는 MariaDB에 대한 모든 연결의 상태 값을 표시합니다. 함께 &lt;code&gt;SESSION&lt;/code&gt; , 현재 연결에 대한 상태 값을 표시합니다. 수정자가 없으면 기본값은 &lt;code&gt;SESSION&lt;/code&gt; 입니다. &lt;code&gt;LOCAL&lt;/code&gt; 은 &lt;code&gt;SESSION&lt;/code&gt; 과 동의어입니다 . 0 값이 많이 표시되면 &lt;code&gt;SHOW GLOBAL STATUS&lt;/code&gt; 대신 새 연결로 &lt;code&gt;SHOW STATUS&lt;/code&gt; 를 사용했기 때문일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bd4be8887f40f12530c6ba7564baee82680d5d82" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;GLOBAL&lt;/code&gt; modifier, &lt;code&gt;SHOW VARIABLES&lt;/code&gt; displays the values that are used for new connections to MariaDB. With &lt;code&gt;SESSION&lt;/code&gt;, it displays the values that are in effect for the current connection. If no modifier is present, the default is &lt;code&gt;SESSION&lt;/code&gt;. &lt;code&gt;LOCAL&lt;/code&gt; is a synonym for &lt;code&gt;SESSION&lt;/code&gt;. With a &lt;code&gt;LIKE&lt;/code&gt; clause, the statement displays only rows for those variables with names that match the pattern. To obtain the row for a specific variable, use a &lt;code&gt;LIKE&lt;/code&gt; clause as shown:</source>
          <target state="translated">&lt;code&gt;GLOBAL&lt;/code&gt; 수정 자 와 함께 &lt;code&gt;SHOW VARIABLES&lt;/code&gt; 는 MariaDB에 대한 새로운 연결에 사용되는 값을 표시합니다. 함께 &lt;code&gt;SESSION&lt;/code&gt; , 현재의 연결에 적용되는 값을 표시한다. 수정자가 없으면 기본값은 &lt;code&gt;SESSION&lt;/code&gt; 입니다. &lt;code&gt;LOCAL&lt;/code&gt; 은 &lt;code&gt;SESSION&lt;/code&gt; 과 동의어입니다 . A를 &lt;code&gt;LIKE&lt;/code&gt; 의 절, 문장의 표시 패턴과 일치하는 이름을 가진이 변수 만 행. 특정 변수에 대한 행을 얻으려면 다음 과 같이 &lt;code&gt;LIKE&lt;/code&gt; 절을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="fd2751593a0e4714e9c0d463f45680f0a316e43f" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;IGNORE_BAD_TABLE_OPTIONS
&lt;/code&gt;&lt;a href=&quot;../sql_mode/index&quot;&gt;sql mode&lt;/a&gt; this behavior changes. Unknown attributes do not cause an error, they only result in a warning. And &lt;a href=&quot;../show-create-table/index&quot;&gt;SHOW CREATE TABLE&lt;/a&gt; will not comment them out. This mode is implicitly enabled in the replication slave thread.</source>
          <target state="translated">으로 &lt;code&gt;IGNORE_BAD_TABLE_OPTIONS &lt;/code&gt; &lt;a href=&quot;../sql_mode/index&quot;&gt;SQL 모드&lt;/a&gt; 이 동작을 변경합니다. 알 수없는 속성은 오류를 발생시키지 않으며 경고 만 발생합니다. 그리고 &lt;a href=&quot;../show-create-table/index&quot;&gt;테이블 만들기 SHOW&lt;/a&gt; 그들을 언급하지 않습니다. 이 모드는 복제 슬레이브 스레드에서 암시 적으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="1fb8d35ecf3519e4e74df729380e47ccb03d7fd1" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;SESSION&lt;/code&gt; keyword, the statement sets the default transaction level for all subsequent transactions performed within the current session.</source>
          <target state="translated">으로 &lt;code&gt;SESSION&lt;/code&gt; 키워드, 문장은 현재 세션 내에서 수행 된 모든 후속 트랜잭션에 대한 기본 트랜잭션 레벨을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="bf7aa3dc3fc392d9f9ef9680d258c11deb664d82" translate="yes" xml:space="preserve">
          <source>With the CDC Data Adapter installed you can configure it to stream data to MariaDB ColumnStore. This is done by copying the &lt;code&gt;Columnstore.xml&lt;/code&gt; configuration file from one of the ColumnStore nodes to the &lt;code&gt;MaxScale-1&lt;/code&gt; server, where the CDC Data Adapter can use it.</source>
          <target state="translated">CDC 데이터 어댑터를 설치하면 MariaDB ColumnStore에 데이터를 스트리밍하도록 구성 할 수 있습니다. 이것은 ColumnStore 노드 중 하나에서 &lt;code&gt;Columnstore.xml&lt;/code&gt; 데이터 어댑터가 사용할 수 있는 &lt;code&gt;MaxScale-1&lt;/code&gt; 서버로 Columnstore.xml 구성 파일을 복사하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="8f9d3719b263b1d6e59124c8d7875b1aad6798de" translate="yes" xml:space="preserve">
          <source>With the Distributed option, MariaDB ColumnStore will distribute and install the packages automatically on each node. The user installs ColumnStore on Performance Module 1, then during the postConfigure step, ColumnStore will handle the rest.</source>
          <target state="translated">분산 옵션을 사용하면 MariaDB ColumnStore는 각 노드에 패키지를 자동으로 분배 및 설치합니다. 사용자는 Performance Module 1에 ColumnStore를 설치 한 후 postConfigure 단계에서 ColumnStore가 나머지를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="74bf10514ff0d2cb72dd50da43d6fe1a87eb446f" translate="yes" xml:space="preserve">
          <source>With the Distributed option, MariaDB ColumnStore would distribute the packages across to the other nodes in the system and will install them automatically. MariaDB ColumnStore also supports a Distributed option for Multi-Node installs. With this option, the user can install the MariaDB ColumnStore on Performance Module #1 (pm1) and the postConfigure install script will distribute it to all the nodes in the system.</source>
          <target state="translated">분산 옵션을 사용하면 MariaDB ColumnStore는 패키지를 시스템의 다른 노드로 분산하여 자동으로 설치합니다. MariaDB ColumnStore는 다중 노드 설치를위한 분산 옵션도 지원합니다. 이 옵션을 사용하면 사용자는 성능 모듈 # 1 (pm1)에 MariaDB ColumnStore를 설치할 수 있으며 postConfigure 설치 스크립트는이를 시스템의 모든 노드에 배포합니다.</target>
        </trans-unit>
        <trans-unit id="cc82158de113b654544bd5514d2342a516bb4d60" translate="yes" xml:space="preserve">
          <source>With the FederatedX storage engine, there will be no local files for each table's data (such as .MYD). A foreign database will store the data that would normally be in this file. This will necessitate the use of MySQL client API to read, delete, update, insert this data. The data will have to be retrieve via an SQL call &quot;&lt;code&gt;SELECT * FROM users
&lt;/code&gt;&quot;. Then, to read this data, it will have to be retrieved via &lt;code&gt;mysql_fetch_row
&lt;/code&gt; one row at a time, then converted from the column in this select into the format that the handler expects.</source>
          <target state="translated">FederatedX 스토리지 엔진을 사용하면 각 테이블 데이터 (예 : .MYD)에 대한 로컬 파일이 없습니다. 외부 데이터베이스는 일반적으로이 파일에있는 데이터를 저장합니다. 이를 위해서는 MySQL 클라이언트 API를 사용하여이 데이터를 읽고 삭제하고 업데이트하고 삽입해야합니다. SQL 호출 &quot; &lt;code&gt;SELECT * FROM users &lt;/code&gt; &quot; 를 통해 데이터를 검색해야합니다 . 그런 다음이 데이터를 읽으려면 &lt;code&gt;mysql_fetch_row &lt;/code&gt; 를 통해 한 번에 한 행씩 검색 한 다음이 선택의 열에서 핸들러가 예상하는 형식으로 변환해야합니다.</target>
        </trans-unit>
        <trans-unit id="b08c91de91f566d3ac5780281fd625f93d7901a1" translate="yes" xml:space="preserve">
          <source>With the GA version of MariaDB ColumnStore, there should be no versions of MariaDB Server or MySQL pre-installed on the OS before a MariaDB ColumnStore binary or RPM is installed on the system. If you have an installation of MariaDB server, uninstall it before proceeding.</source>
          <target state="translated">GA 버전의 MariaDB ColumnStore를 사용하는 경우 시스템에 MariaDB ColumnStore 바이너리 또는 RPM을 설치하기 전에 OS에 MariaDB 서버 또는 MySQL 버전이 사전 설치되어 있지 않아야합니다. MariaDB 서버를 설치 한 경우 계속하기 전에 서버를 설치 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="1f5e8373b3f8bb4d53822a2010e697c85606ebc3" translate="yes" xml:space="preserve">
          <source>With the MariaDB Servers, ColumnStore and MaxScale servers configured and deployed, you can begin testing the sample HTAP deployment. The application connects to the second MaxScale server, &lt;code&gt;MaxScale-2&lt;/code&gt;, on port 4011, where it performs selective query routing:</source>
          <target state="translated">MariaDB 서버, ColumnStore 및 MaxScale 서버를 구성하고 배치하면 샘플 HTAP 배치 테스트를 시작할 수 있습니다. 애플리케이션은 포트 4011 에서 두 번째 MaxScale 서버 인 &lt;code&gt;MaxScale-2&lt;/code&gt; 에 연결하여 선택적 쿼리 라우팅을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="e9f25f7fb3f18842657eea7b1bd3f7992a8c477e" translate="yes" xml:space="preserve">
          <source>With the MariaDB server you can use &lt;a href=&quot;../sql-commands-check-table/index&quot;&gt;CHECK TABLE&lt;/a&gt;, &lt;a href=&quot;../repair-table/index&quot;&gt;REPAIR TABLE&lt;/a&gt; and &lt;a href=&quot;../optimize-table/index&quot;&gt;OPTIMIZE TABLE&lt;/a&gt; to do similar things.</source>
          <target state="translated">MariaDB 서버에서는 &lt;a href=&quot;../sql-commands-check-table/index&quot;&gt;CHECK TABLE&lt;/a&gt; , &lt;a href=&quot;../repair-table/index&quot;&gt;REPAIR TABLE&lt;/a&gt; 및 &lt;a href=&quot;../optimize-table/index&quot;&gt;OPTIMIZE TABLE&lt;/a&gt; 을 사용하여 유사한 작업을 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9bd2d2703ea4e3ad46e6fd1580f85b07d8cd99df" translate="yes" xml:space="preserve">
          <source>With the above file in place, go to your MariaDB source directory and execute:</source>
          <target state="translated">위의 파일이 있으면 MariaDB 소스 디렉토리로 이동하여 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="a6d107210f06fd9b6a33975be8e2f202b310d43c" translate="yes" xml:space="preserve">
          <source>With the command-line functionality, you can save time by scheduling routine data generation tasks.</source>
          <target state="translated">명령 줄 기능을 사용하면 일상적인 데이터 생성 작업을 예약하여 시간을 절약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a8e692ce666cdbe3afa2672d823feb530de9fcd" translate="yes" xml:space="preserve">
          <source>With the configuration so far, our sample deployment will streams these new tables from the MariaDB Serves to ColumnStore through the CDC Data Adapter running on &lt;code&gt;MaxScale-1&lt;/code&gt;. We'll then configure the second MaxScale server to selectively route your application traffic for HTAP operations.</source>
          <target state="translated">지금까지의 구성으로 샘플 배포는 &lt;code&gt;MaxScale-1&lt;/code&gt; 에서 실행되는 CDC 데이터 어댑터를 통해 MariaDB Serves에서 ColumnStore로 이러한 새 테이블을 스트리밍합니다 . 그런 다음 HTAP 작업을 위해 애플리케이션 트래픽을 선택적으로 라우팅하도록 두 번째 MaxScale 서버를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="029ee5ae25bbf3a718de96c3a2bcf794379b45bb" translate="yes" xml:space="preserve">
          <source>With the data node or data nodes configured, you can set up the Spider node to use them. The Spider node is the MariaDB server that receives queries for the table, (in this case &lt;code&gt;test.spider_example&lt;/code&gt;). It then uses the Spider storage engine to connect to the tables on the data nodes to retrieve data and return the result-set.</source>
          <target state="translated">데이터 노드 또는 데이터 노드가 구성된 상태에서 스파이더 노드를 사용하도록 설정할 수 있습니다. Spider 노드는 테이블에 대한 쿼리를받는 MariaDB 서버입니다 (이 경우 &lt;code&gt;test.spider_example&lt;/code&gt; ). 그런 다음 Spider 스토리지 엔진을 사용하여 데이터 노드의 테이블에 연결하여 데이터를 검색하고 결과 세트를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="e94cdda42a68eeb7e452e38d4513729ea85b4fe4" translate="yes" xml:space="preserve">
          <source>With the data nodes set up and the Spider node configured for use, you can create the Spider table. The Spider table must have the same column definitions as the InnoDB tables on the data nodes. Spider is configured through table system variables passed to the &lt;code&gt;COMMENT&lt;/code&gt; option.</source>
          <target state="translated">데이터 노드를 설정하고 Spider 노드를 사용하도록 구성하면 Spider 테이블을 만들 수 있습니다. Spider 테이블은 데이터 노드의 InnoDB 테이블과 동일한 열 정의를 가져야합니다. 스파이더는 &lt;code&gt;COMMENT&lt;/code&gt; 옵션에 전달 된 테이블 시스템 변수를 통해 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="e295bf25852db41e7501e1fe1ba2e2118187cc07" translate="yes" xml:space="preserve">
          <source>With the data values removed, both of these statements normalize to:</source>
          <target state="translated">데이터 값이 제거되면이 두 명령문은 다음과 같이 정규화됩니다.</target>
        </trans-unit>
        <trans-unit id="aacf3bde1204168290a741a6d4734b4346d6fa1f" translate="yes" xml:space="preserve">
          <source>With the default &lt;a href=&quot;../sql-mode/index&quot;&gt;SQL Mode&lt;/a&gt;:</source>
          <target state="translated">기본 &lt;a href=&quot;../sql-mode/index&quot;&gt;SQL 모드에서&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="0845a52deadbc439ebf893fe0e9d59950f2c4b41" translate="yes" xml:space="preserve">
          <source>With the default collations, &lt;code&gt;LIKE&lt;/code&gt; is case-insensitive:</source>
          <target state="translated">기본 데이터 정렬을 사용하면 &lt;code&gt;LIKE&lt;/code&gt; 는 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6a02807f5fc07567bbfdcf30c240e30c114eecf5" translate="yes" xml:space="preserve">
          <source>With the default setting of &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_locks_unsafe_for_binlog&quot;&gt;innodb_locks_unsafe_for_binlog&lt;/a&gt; and the default &lt;a href=&quot;../set-transaction-isolation-level/index#isolation-level&quot;&gt;isolation level&lt;/a&gt;, &lt;code&gt;REPEATABLE READ&lt;/code&gt;, a method called gap locking is used. When InnoDB sets a shared or exclusive lock on a record, it's actually on the index record. Records will have an internal InnoDB index even if they don't have a unique index defined. At the same time, a lock is held on the gap before the index record, so that another transaction cannot insert a new index record in the gap between the record and the preceding record.</source>
          <target state="translated">&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_locks_unsafe_for_binlog&quot;&gt;innodb_locks_unsafe_for_binlog&lt;/a&gt; 의 기본 설정 과 기본 &lt;a href=&quot;../set-transaction-isolation-level/index#isolation-level&quot;&gt;격리 수준&lt;/a&gt; 인 &lt;code&gt;REPEATABLE READ&lt;/code&gt; 와 함께 간격 잠금이라는 방법이 사용됩니다. InnoDB가 레코드에 공유 또는 독점 잠금을 설정하면 실제로는 인덱스 레코드에 있습니다. 레코드에는 고유 인덱스가 정의되지 않은 경우에도 내부 InnoDB 인덱스가 있습니다. 동시에 인덱스 레코드 이전의 간격에 잠금이 유지되므로 다른 트랜잭션이 레코드와 이전 레코드 사이의 간격에 새 인덱스 레코드를 삽입 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9a7867d744225c13159459ba81b30302bf5be2e5" translate="yes" xml:space="preserve">
          <source>With the directories in place, create a sym-link named &lt;code&gt;mariadb&lt;/code&gt; which points at the &lt;code&gt;mariadb-XXX&lt;/code&gt; directory you are currently testing. When you want to switch to testing a different version, just update the sym-link.</source>
          <target state="translated">디렉토리가 제 위치에 있으면, 현재 테스트중인 &lt;code&gt;mariadb-XXX&lt;/code&gt; 디렉토리를 가리키는 &lt;code&gt;mariadb&lt;/code&gt; 라는 sym-link를 작성하십시오 . 다른 버전의 테스트로 전환하려면 sym-link를 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="5c3761ff551b8eeb5e85e3715a1dab87f0035d4c" translate="yes" xml:space="preserve">
          <source>With the exception of adding an &lt;a href=&quot;../auto_increment/index&quot;&gt;auto-increment&lt;/a&gt; column, this operation supports the non-locking strategy. This strategy can be explicitly chosen by setting the &lt;code&gt;&lt;a href=&quot;../alter-table/index#lock&quot;&gt;LOCK&lt;/a&gt;&lt;/code&gt; clause to &lt;code&gt;NONE&lt;/code&gt;. When this strategy is used, all concurrent DML is permitted.</source>
          <target state="translated">&lt;a href=&quot;../auto_increment/index&quot;&gt;자동 증분&lt;/a&gt; 열 을 추가하는 것을 제외 하고이 작업은 비 잠금 전략을 지원합니다. 이 전략은 &lt;code&gt;&lt;a href=&quot;../alter-table/index#lock&quot;&gt;LOCK&lt;/a&gt;&lt;/code&gt; 절을 &lt;code&gt;NONE&lt;/code&gt; 으로 설정하여 명시 적으로 선택할 수 있습니다 . 이 전략을 사용하면 모든 동시 DML이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="89a48a8c84b0c193a459b00ec563a58d8573c93a" translate="yes" xml:space="preserve">
          <source>With the exception of variable-length columns (that is, &lt;a href=&quot;../varbinary/index&quot;&gt;VARBINARY&lt;/a&gt;, &lt;a href=&quot;../varchar/index&quot;&gt;VARCHAR&lt;/a&gt;, &lt;a href=&quot;../blob/index&quot;&gt;BLOB&lt;/a&gt; and &lt;a href=&quot;../text/index&quot;&gt;TEXT&lt;/a&gt;), rows in InnoDB have a maximum length of roughly half the page size for 4KB, 8KB, 16KB and 32KB page sizes.</source>
          <target state="translated">가변 길이 열 (즉, &lt;a href=&quot;../varbinary/index&quot;&gt;VARBINARY&lt;/a&gt; , &lt;a href=&quot;../varchar/index&quot;&gt;VARCHAR&lt;/a&gt; , &lt;a href=&quot;../blob/index&quot;&gt;BLOB&lt;/a&gt; 및 &lt;a href=&quot;../text/index&quot;&gt;TEXT&lt;/a&gt; )을 제외하고 InnoDB의 행은 최대 페이지 크기의 4KB, 8KB, 16KB 및 32KB 페이지 크기의 절반입니다.</target>
        </trans-unit>
        <trans-unit id="03aabdc2b8fb97a307e7a142630f139278152b1a" translate="yes" xml:space="preserve">
          <source>With the help of both the hardware and the OS, it is possible to have some of RAM in huge pages, of say 4MB (instead of 4KB). This leads to far fewer TLB entries, but it means the unit of paging is 4MB for such parts of RAM. Hence, huge pages tend to be non-pagable.</source>
          <target state="translated">하드웨어와 OS의 도움으로 RAM의 일부를 4KB 대신 4MB와 같은 거대한 페이지로 만들 수 있습니다. 이로 인해 TLB 항목이 훨씬 줄어들지 만 RAM의 해당 부분에 대해 페이징 단위가 4MB임을 의미합니다. 따라서 큰 페이지는 페이지를 넘길 수없는 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="92a1934897a64f7cdc9f12ccb1c9b9b35caa869d" translate="yes" xml:space="preserve">
          <source>With the infinidb_local_query variable set to 0 (default with local PM Query):</source>
          <target state="translated">infinidb_local_query 변수가 0으로 설정된 경우 (로컬 PM 조회의 기본값) :</target>
        </trans-unit>
        <trans-unit id="bcba49c9dd5e21866c1ed8e5f93196667074d372" translate="yes" xml:space="preserve">
          <source>With the infinidb_local_query variable set to 1 (default with local PM Query):</source>
          <target state="translated">infinidb_local_query 변수가 1로 설정된 경우 (로컬 PM 조회의 기본값) :</target>
        </trans-unit>
        <trans-unit id="38187e208a4d7ca5c84c7ce5bc841918b64e51e9" translate="yes" xml:space="preserve">
          <source>With the introduction of &lt;a href=&quot;../group-commit-for-the-binary-log/index&quot;&gt;group commit&lt;/a&gt;, MariaDB also introduced an enhanced storage engine API for COMMIT that allows engines to coordinate commit ordering and visibility with each other and with the &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../group-commit-for-the-binary-log/index&quot;&gt;그룹 커밋&lt;/a&gt; 이 도입되면서 MariaDB는 엔진이 커밋 순서와 가시성을 서로 및 &lt;a href=&quot;../binary-log/index&quot;&gt;이진 로그&lt;/a&gt; 로 조정할 수있는 COMMIT 용 고급 스토리지 엔진 API도 도입했습니다 .</target>
        </trans-unit>
        <trans-unit id="f4c5e3097e95e0d0e2fcdfe998566e24394d157d" translate="yes" xml:space="preserve">
          <source>With the large number of special characters, care needs to be taken to properly escape characters. Two backslash characters,  (one for the MariaDB parser, one for the regex library), are required to properly escape a character. For example:</source>
          <target state="translated">특수 문자가 많으면 문자를 올바르게 이스케이프 처리해야합니다. 문자를 올바르게 이스케이프하려면 두 개의 백 슬래시 문자 (하나는 MariaDB 파서, 하나는 정규식 라이브러리)가 필요합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="02ded6e5528959eb231529d952b56793b25c343b" translate="yes" xml:space="preserve">
          <source>With the non-sharding techniques described here, terabyte(s) of data can be handled by a single machine. Tens of terabytes probably requires sharding.</source>
          <target state="translated">여기에 설명 된 비 샤딩 기술을 사용하면 단일 시스템에서 테라 바이트 규모의 데이터를 처리 할 수 ​​있습니다. 수십 테라 바이트는 아마도 샤딩이 필요할 것입니다.</target>
        </trans-unit>
        <trans-unit id="62567af49b3cfaa3218e98c83c7b238004fd65d1" translate="yes" xml:space="preserve">
          <source>With the repo file in place you can now install MariaDB ColumnStore API like so:</source>
          <target state="translated">repo 파일이 있으면 이제 MariaDB ColumnStore API를 다음과 같이 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5593b86ed096e026a2a21d76f809e31cfe850805" translate="yes" xml:space="preserve">
          <source>With the repo file in place you can now install MariaDB ColumnStore Kafka Data Adapters like so:</source>
          <target state="translated">repo 파일이 있으면 이제 MariaDB ColumnStore Kafka Data Adapter를 다음과 같이 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="051c9a597cf28f48ac2abc1f8aa47443b9da4230" translate="yes" xml:space="preserve">
          <source>With the repo file in place you can now install MariaDB ColumnStore Maxscale CDC Data Adapters like so:</source>
          <target state="translated">repo 파일이 있으면 이제 MariaDB ColumnStore Maxscale CDC 데이터 어댑터를 다음과 같이 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8fd6e8a2bc0b74243b0bee3ac0e680214b4e32a7" translate="yes" xml:space="preserve">
          <source>With the repo file in place you can now install MariaDB ColumnStore Tools like so:</source>
          <target state="translated">repo 파일이 있으면 이제 MariaDB ColumnStore 도구를 다음과 같이 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ceee3d224ae39a174c69bc799308f0a4440c0ac3" translate="yes" xml:space="preserve">
          <source>With the repo file in place you can now install MariaDB ColumnStore like so:</source>
          <target state="translated">repo 파일이 있으면 이제 MariaDB ColumnStore를 다음과 같이 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9c2b021882923422999551ba5f5a5fc54d66561" translate="yes" xml:space="preserve">
          <source>With the repo file in place you can now install MariaDB ColumnStores Kafka Data Adapters like so:</source>
          <target state="translated">repo 파일이 있으면 이제 MariaDB ColumnStores Kafka Data Adapter를 다음과 같이 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20fa050f1bb851671590a0761ece3735757f0b44" translate="yes" xml:space="preserve">
          <source>With the repo file in place you can now install MariaDB ColumnStores Maxscale CDC Data Adapters like so:</source>
          <target state="translated">repo 파일이 있으면 이제 MariaDB ColumnStores Maxscale CDC 데이터 어댑터를 다음과 같이 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0e4a21c10a2cf4263203c8cab6770e4e68c7c04" translate="yes" xml:space="preserve">
          <source>With the repo file in place you can now install MariaDB MaxScale like so:</source>
          <target state="translated">repo 파일이 있으면 이제 MariaDB MaxScale을 다음과 같이 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73eb23dae58b5256a3bec05648364c034c551c4a" translate="yes" xml:space="preserve">
          <source>With the sample tables above, you can do update statements such as:</source>
          <target state="translated">위의 샘플 테이블을 사용하여 다음과 같은 업데이트 명령문을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="480d082879562d5fe475ffad3332191858843869" translate="yes" xml:space="preserve">
          <source>With the source repository cloned onto your system, you can start building MariaDB. Change into the new &lt;code&gt;mariadb-server/&lt;/code&gt; directory and run CMake to prepare the build.</source>
          <target state="translated">소스 리포지토리를 시스템에 복제하면 MariaDB 구축을 시작할 수 있습니다. 새 &lt;code&gt;mariadb-server/&lt;/code&gt; 디렉토리 로 변경하고 CMake를 실행하여 빌드를 준비하십시오.</target>
        </trans-unit>
        <trans-unit id="d44c72fcf2efd277d7247087b8b1a6c953847e4a" translate="yes" xml:space="preserve">
          <source>With the source repository cloned onto your system, you can start building MariaDB. Run CMake to read MariaDB for the build,</source>
          <target state="translated">소스 리포지토리를 시스템에 복제하면 MariaDB 구축을 시작할 수 있습니다. CMake를 실행하여 빌드의 MariaDB를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="2b9fccab30edec4d871ddba8cb4b0c63f602fd15" translate="yes" xml:space="preserve">
          <source>With the techniques described here, you may be able to achieve the following performance numbers. I say &quot;may&quot; because every data warehouse situation is different, and you may require performance-hurting deviations from what I describe here. I give multiple options for some aspects; these may cover some of your deviations.</source>
          <target state="translated">여기에 설명 된 기술을 사용하면 다음과 같은 성능 수치를 달성 할 수 있습니다. 모든 데이터웨어 하우스 상황이 다르기 때문에 &quot;may&quot;라고 말하며 여기에 설명 된 것과 다른 성능 저하가 필요할 수 있습니다. 몇 가지 측면에 대해 여러 가지 옵션을 제공합니다. 여기에는 일부 편차가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd5ea0e071a24dc0c214de5f51c7cc56f4c28cf2" translate="yes" xml:space="preserve">
          <source>With the variables binlog_snapshot_file and binlog_snapshot_position, such provisioning can be done fully non-blocking on the master. Without them, it is necessary to get the binlog position under &lt;code&gt;FLUSH TABLES WITH READ LOCK&lt;/code&gt;; this can potentially stall the server for a long time, as it blocks new queries until all updates that have already started have finished.</source>
          <target state="translated">binlog_snapshot_file 및 binlog_snapshot_position 변수를 사용하면 이러한 프로비저닝을 마스터에서 완전히 비 차단할 수 있습니다. 그것들이 없으면, &lt;code&gt;FLUSH TABLES WITH READ LOCK&lt;/code&gt; 아래에서 binlog 위치를 가져와야합니다 . 이미 시작한 모든 업데이트가 완료 될 때까지 새 쿼리를 차단하므로 서버가 오랫동안 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a78c22b972f18c7d5ec3a4fd17a166ef96babf48" translate="yes" xml:space="preserve">
          <source>With these changes done, you can restart MariaDB to activate TokuDB.</source>
          <target state="translated">이러한 변경이 완료되면 MariaDB를 다시 시작하여 TokuDB를 활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b4f9940132744d422740be176a6a6309461d7bd" translate="yes" xml:space="preserve">
          <source>With these improvements, the &lt;code&gt;START TRANSACTION WITH CONSISTENT SNAPSHOT&lt;/code&gt; statement was enhanced to ensure consistency between storage engines that support the new API. At the time of writing, the supporting engines are &lt;a href=&quot;../xtradb-and-innodb/index&quot;&gt;XtraDB&lt;/a&gt; and &lt;a href=&quot;../pbxt-storage-engine/index&quot;&gt;PBXT&lt;/a&gt;. In addition, the binary log, while not a storage engine as such, also supports the new API and can provide a binlog position consistent with storage engine transaction snapshots.</source>
          <target state="translated">이러한 개선으로 &lt;code&gt;START TRANSACTION WITH CONSISTENT SNAPSHOT&lt;/code&gt; 문이 향상되어 새로운 API를 지원하는 스토리지 엔진 간의 일관성이 보장됩니다. 작성 당시 지원 엔진은 &lt;a href=&quot;../xtradb-and-innodb/index&quot;&gt;XtraDB&lt;/a&gt; 및 &lt;a href=&quot;../pbxt-storage-engine/index&quot;&gt;PBXT&lt;/a&gt; 입니다. 또한 이진 로그는 스토리지 엔진은 아니지만 새로운 API도 지원하며 스토리지 엔진 트랜잭션 스냅 샷과 일치하는 바이너리 로그 위치를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1097a5c6607382218d462f10e4470e20744e2c67" translate="yes" xml:space="preserve">
          <source>With this approach it becomes easy to add/change/remove attributes, but this comes at a cost of added complexity in querying the data: in order to answer the simplest, select-star question of displaying actors and their current ratings one has to write outer joins:</source>
          <target state="translated">이 접근 방식을 사용하면 속성을 추가 / 변경 / 제거하기가 쉬워 지지만 데이터 쿼리시 복잡성이 추가로 발생합니다. 액터와 현재 등급을 표시하는 가장 단순하고 선택적인 질문에 답하기 위해서는 작성해야합니다. 외부 조인 :</target>
        </trans-unit>
        <trans-unit id="8b80fb4c5499022de93a0f153eaf2e4dc08e7ac8" translate="yes" xml:space="preserve">
          <source>With this information, CONNECT will be able to make the query sent to the remote data source:</source>
          <target state="translated">이 정보를 통해 CONNECT는 쿼리를 원격 데이터 소스로 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3c454eef8778907e70ce3232251f51f3aaff48b" translate="yes" xml:space="preserve">
          <source>With this information, FederatedX constructs an SQL statement</source>
          <target state="translated">이 정보를 사용하여 FederatedX는 SQL 문을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="40529c9ef470f76766a0e90a2af5f50c8c3cb233" translate="yes" xml:space="preserve">
          <source>With this installation type, you have the option of install using rpm, deb or binary packages, which you can install with the standard tools yum, apt, zypper.</source>
          <target state="translated">이 설치 유형을 사용하면 rpm, deb 또는 이진 패키지를 사용하여 설치할 수 있으며 표준 도구 yum, apt, zypper를 사용하여 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61e56094225bbb1dffe8900db2c99e17641a2fba" translate="yes" xml:space="preserve">
          <source>With this mode unset, MariaDB truncates fractional seconds when changing precision to smaller. When set, MariaDB will round when converting to TIME, DATETIME and TIMESTAMP, and truncate when converting to DATE. Since &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1041-release-notes/&quot;&gt;MariaDB 10.4.1&lt;/a&gt;</source>
          <target state="translated">이 모드를 설정하지 않으면 MariaDB는 정밀도를 더 작게 변경할 때 분수 초를 자릅니다. 설정하면 MariaDB는 TIME, DATETIME 및 TIMESTAMP로 변환 할 때 반올림하고 DATE로 변환 할 때 잘립니다. &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1041-release-notes/&quot;&gt;MariaDB 10.4.1&lt;/a&gt; 부터</target>
        </trans-unit>
        <trans-unit id="58f4030d6dba6e6a02f43034bbe02312eac49152" translate="yes" xml:space="preserve">
          <source>With this option an optional error log file is written which states truncated, saturated, and invalid values during the injection. If the command line parameter &lt;em&gt;-ignore_malformed_csv&lt;/em&gt; is chosen, it also states which lines were ignored.</source>
          <target state="translated">이 옵션을 사용하면 주입 중에 잘 리거나 포화 된 값과 유효하지 않은 값을 나타내는 선택적 오류 로그 파일이 작성됩니다. 명령 행 매개 변수 &lt;em&gt;-ignore_malformed_csv&lt;/em&gt; 를 선택하면 무시 된 &lt;em&gt;행도 표시&lt;/em&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="6a4c00e4b0cd2b7cc080af32d8be86ad46f38d6e" translate="yes" xml:space="preserve">
          <source>With this option set, the replication I/O thread will limit the rate of download. Since the I/O thread is often much faster to download events than the SQL thread is at applying them, an appropriate value for &lt;strong&gt;read_binlog_speed_limit&lt;/strong&gt; may reduce load spikes on the master without much limit in the speed of the replication slave.</source>
          <target state="translated">이 옵션을 설정하면 복제 I / O 스레드가 다운로드 속도를 제한합니다. I / O 스레드는 종종 SQL 스레드가 이벤트를 적용하는 것보다 이벤트를 다운로드하는 것이 훨씬 빠르기 때문에 &lt;strong&gt;read_binlog_speed_limit&lt;/strong&gt; 의 적절한 값 은 복제 슬레이브 속도의 제한없이 마스터에서로드 스파이크를 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b8c82b3ebacd6f51c786d71ca9d0b059bbe61b2" translate="yes" xml:space="preserve">
          <source>With transactional engines, triggers are executed in the same transaction as the statement that invoked them.</source>
          <target state="translated">트랜잭션 엔진을 사용하면 트리거가 호출 된 명령문과 동일한 트랜잭션에서 트리거가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="33d1fa0684b9557739add3979bb157f95b50121a" translate="yes" xml:space="preserve">
          <source>With two or more arguments, returns the largest (maximum-valued) argument. The arguments are compared using the same rules as for &lt;a href=&quot;../least/index&quot;&gt;LEAST()&lt;/a&gt;.</source>
          <target state="translated">둘 이상의 인수를 사용하면 가장 큰 (최대 값) 인수를 반환합니다. 인수는 &lt;a href=&quot;../least/index&quot;&gt;LEAST ()&lt;/a&gt; 와 동일한 규칙을 사용하여 비교됩니다 .</target>
        </trans-unit>
        <trans-unit id="5945b7024b384205465c0b27340bd5f6cf45d979" translate="yes" xml:space="preserve">
          <source>With two or more arguments, returns the smallest (minimum-valued) argument. The arguments are compared using the following rules:</source>
          <target state="translated">둘 이상의 인수를 사용하면 가장 작은 (최소값) 인수를 반환합니다. 인수는 다음 규칙을 사용하여 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="bddd01b1d0e57ef6103980d7beba54e369950ac0" translate="yes" xml:space="preserve">
          <source>With user and group mapping, any PAM user or any PAM user in a given PAM group can be mapped to a specific MariaDB user account. However, due to the way PAM works, a PAM user with the same name as the mapped MariaDB user account must exist.</source>
          <target state="translated">사용자 및 그룹 매핑을 사용하면 지정된 PAM 그룹의 모든 PAM 사용자 또는 PAM 사용자를 특정 MariaDB 사용자 계정에 매핑 할 수 있습니다. 그러나 PAM의 작동 방식으로 인해 매핑 된 MariaDB 사용자 계정과 이름이 같은 PAM 사용자가 존재해야합니다.</target>
        </trans-unit>
        <trans-unit id="4e9e8e443b9dbdb54a0e450dd86768477668554c" translate="yes" xml:space="preserve">
          <source>With user and group mapping, configuring PAM is done similar to how it is &lt;a href=&quot;../authentication-plugin-pam/index#configuring-pam&quot;&gt;normally done with the &lt;code&gt;pam&lt;/code&gt; authentication plugin&lt;/a&gt;. However, when configuring the PAM service, you will have to add an &lt;code&gt;auth&lt;/code&gt; line for the &lt;code&gt;pam_user_map&lt;/code&gt; PAM module to the service's PAM configuration file. For example:</source>
          <target state="translated">사용자 및 그룹 매핑을 통해 PAM 구성은 &lt;a href=&quot;../authentication-plugin-pam/index#configuring-pam&quot;&gt;일반적으로 &lt;code&gt;pam&lt;/code&gt; 인증 플러그인을 사용하여 수행&lt;/a&gt; 하는 방식과 유사합니다 . 그러나 PAM 서비스를 구성 할 때 &lt;code&gt;pam_user_map&lt;/code&gt; PAM 모듈 의 &lt;code&gt;auth&lt;/code&gt; 라인을 서비스의 PAM 구성 파일에 추가해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d8ed423e68b39fef4968335e02a582f123fa63a2" translate="yes" xml:space="preserve">
          <source>With user and group mapping, creating users is done similar to how it is &lt;a href=&quot;../authentication-plugin-pam/index#creating-users&quot;&gt;normally done with the &lt;code&gt;pam&lt;/code&gt; authentication plugin&lt;/a&gt;. However, one major difference is that you will need to &lt;code&gt;&lt;a href=&quot;../grant/index&quot;&gt;GRANT&lt;/a&gt;&lt;/code&gt; the &lt;code&gt;&lt;a href=&quot;../grant/index#proxy-privileges&quot;&gt;PROXY&lt;/a&gt;&lt;/code&gt; privilege on the mapped user to the original user.</source>
          <target state="translated">사용자 및 그룹 맵핑을 사용하면 사용자 작성은 &lt;a href=&quot;../authentication-plugin-pam/index#creating-users&quot;&gt;일반적으로 &lt;code&gt;pam&lt;/code&gt; 인증 플러그인&lt;/a&gt; 을 사용하는 방식과 유사합니다 . 그러나 한 가지 큰 차이점은해야 할 것입니다 &lt;code&gt;&lt;a href=&quot;../grant/index&quot;&gt;GRANT&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../grant/index#proxy-privileges&quot;&gt;PROXY&lt;/a&gt;&lt;/code&gt; 의 원래 사용자에 매핑 된 사용자에 대한 권한을.</target>
        </trans-unit>
        <trans-unit id="12526cc287164e301cac13bcd7a69e9aea28e2fd" translate="yes" xml:space="preserve">
          <source>With validation:</source>
          <target state="translated">유효성 검사와 함께 :</target>
        </trans-unit>
        <trans-unit id="aef869ce5ea3525a27bc83cca8d5ce20971e8dc7" translate="yes" xml:space="preserve">
          <source>With version 1.2.1 of MariaDB ColumnStore, there should be no version of MariaDB Server or MySQL installed on the OS before a MariaDB ColumnStore is installed on the system. If you have an installation of MariaDB Server or MySQL, uninstall it before proceeding.</source>
          <target state="translated">MariaDB ColumnStore 버전 1.2.1에서는 MariaDB ColumnStore를 시스템에 설치하기 전에 OS에 MariaDB 서버 또는 MySQL 버전이 설치되어 있지 않아야합니다. MariaDB 서버 또는 MySQL을 설치 한 경우 계속하기 전에 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="1d362745a41815fae76f2c3f71d093252e7cfaa4" translate="yes" xml:space="preserve">
          <source>With version 1.2.2 of MariaDB ColumnStore, there should be no version of MariaDB Server or MySQL installed on the OS before a MariaDB ColumnStore is installed on the system. If you have an installation of MariaDB Server or MySQL, uninstall it before proceeding.</source>
          <target state="translated">MariaDB ColumnStore 버전 1.2.2에서는 MariaDB ColumnStore를 시스템에 설치하기 전에 OS에 MariaDB 서버 또는 MySQL 버전이 설치되어 있지 않아야합니다. MariaDB 서버 또는 MySQL을 설치 한 경우 계속하기 전에 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="f539c43d478acd73d36664696c8c15de41745c11" translate="yes" xml:space="preserve">
          <source>With version 1.2.2 onwards these can be set to static numeric limits instead of percentages by entering a number with 'M' or 'G' at the end to signify MiB or GiB.</source>
          <target state="translated">버전 1.2.2 이상에서는 MiB 또는 GiB를 나타 내기 위해 끝에 'M'또는 'G'로 숫자를 입력하여 백분율 대신 정적 숫자 제한으로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c19e85d76acbcf2a8e11206675d67db5fd1649e4" translate="yes" xml:space="preserve">
          <source>With version 1.2.5 of MariaDB ColumnStore, there should be no version of MariaDB Server or MySQL installed on the OS before a MariaDB ColumnStore is installed on the system. If you have an installation of MariaDB Server or MySQL, uninstall it before proceeding.</source>
          <target state="translated">MariaDB ColumnStore 버전 1.2.5에서는 MariaDB ColumnStore를 시스템에 설치하기 전에 OS에 MariaDB 서버 또는 MySQL 버전이 설치되어 있지 않아야합니다. MariaDB 서버 또는 MySQL을 설치 한 경우 계속하기 전에 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="c6205072bdbddad8d3ef5cfb3e195b5d2c6f3556" translate="yes" xml:space="preserve">
          <source>Within</source>
          <target state="translated">Within</target>
        </trans-unit>
        <trans-unit id="173093d79dfcd89328f615c6b58805563981d95e" translate="yes" xml:space="preserve">
          <source>Within a PARTITION (which is effectively a table), use lon do a 'clustered' range scan; then</source>
          <target state="translated">PARTITION (실제로 테이블 임) 내에서 lon을 사용하여 '클러스터 된'범위 스캔을 수행하십시오. 그때</target>
        </trans-unit>
        <trans-unit id="6c9fb380bdd4704d182f52a2250a9b0bc17b59c2" translate="yes" xml:space="preserve">
          <source>Within a stored program, the definition cannot refer to program parameters or local variables.</source>
          <target state="translated">저장된 프로그램 내에서 정의는 프로그램 매개 변수 또는 로컬 변수를 참조 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2c995fb8d2d90b84be97a1b6afe3ce19dfd2eddb" translate="yes" xml:space="preserve">
          <source>Within a stored routine that is defined with the SQL SECURITY DEFINER characteristic, CURRENT_USER returns the routine's DEFINER value. This also affects a view defined within such a program, if the view definition contains a DEFINER value of CURRENT_USER.</source>
          <target state="translated">SQL SECURITY DEFINER 특성으로 정의 된 저장 루틴 내에서 CURRENT_USER는 루틴의 DEFINER 값을 리턴합니다. 뷰 정의에 CURRENT_USER의 DEFINER 값이 포함 된 경우 이러한 프로그램 내에 정의 된 뷰에도 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="4d718cf417abbf35c0266e9652fa09897176d1a1" translate="yes" xml:space="preserve">
          <source>Within a view definition, CURRENT_USER returns the view's DEFINER value by default. Before MySQL 5.1.12, and for views defined with the SQL SECURITY INVOKER characteristic, CURRENT_USER returns the account for the view's invoker. For information about user auditing within views, see &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/en/account-activity-auditing.html&quot;&gt;http://dev.mysql.com/doc/refman/5.1/en/account-activity-auditing.html&lt;/a&gt;.</source>
          <target state="translated">뷰 정의 내에서 CURRENT_USER는 기본적으로 뷰의 DEFINER 값을 반환합니다. MySQL 5.1.12 이전과 SQL SECURITY INVOKER 특성으로 정의 된 뷰의 경우 CURRENT_USER는 뷰 호출자의 계정을 리턴합니다. 뷰 내의 사용자 감사에 대한 자세한 내용은 &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/en/account-activity-auditing.html&quot;&gt;http://dev.mysql.com/doc/refman/5.1/en/account-activity-auditing.html을&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="0e6aab631747ef626a23c0e7af985d19a63e8e6b" translate="yes" xml:space="preserve">
          <source>Within the body of a stored routine (procedure or function) or a trigger, the value of LAST_INSERT_ID() changes the same way as for statements executed outside the body of these kinds of objects. The effect of a stored routine or trigger upon the value of LAST_INSERT_ID() that is seen by following statements depends on the kind of routine:</source>
          <target state="translated">저장 루틴 (프로 시저 또는 함수) 또는 트리거의 본문 내에서 LAST_INSERT_ID ()의 값은 이러한 종류의 오브젝트 본문 외부에서 실행 된 명령문의 경우와 동일한 방식으로 변경됩니다. 다음 명령문에서 볼 수있는 LAST_INSERT_ID () 값에 대한 스토어드 루틴 또는 트리거의 영향은 루틴의 종류에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="7eb1478fe818d06d043a86125a550ecf78610d56" translate="yes" xml:space="preserve">
          <source>Within the same base version (for example MySQL 5.5 -&amp;gt; &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt;, MySQL 5.6 -&amp;gt; &lt;a href=&quot;../what-is-mariadb-100/index&quot;&gt;MariaDB 10.0&lt;/a&gt; and MySQL 5.7 -&amp;gt; &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt;) you can in most cases just uninstall MySQL and install MariaDB and you are good to go. There is no need to dump and restore databases. As with any upgrade, we recommend making a backup of your data beforehand.</source>
          <target state="translated">동일한 기본 버전 (예 : MySQL &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;5.5-&lt;/a&gt; &amp;gt; MariaDB 5.5 , MySQL &lt;a href=&quot;../what-is-mariadb-100/index&quot;&gt;5.6-&lt;/a&gt; &amp;gt; MariaDB 10.0 및 MySQL &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;5.7-&lt;/a&gt; &amp;gt; MariaDB 10.2 ) 내에서 대부분의 경우 MySQL을 제거하고 MariaDB를 설치하면됩니다. 데이터베이스를 덤프하고 복원 할 필요가 없습니다. 업그레이드와 마찬가지로 데이터를 미리 백업하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="aa622205f268486b93aef6314235620f280c7e60" translate="yes" xml:space="preserve">
          <source>Without &lt;code&gt;SQL_BUFFER_RESULT&lt;/code&gt;, the above query would not use a temporary table for the result set.</source>
          <target state="translated">&lt;code&gt;SQL_BUFFER_RESULT&lt;/code&gt; 가 없으면 위의 쿼리는 결과 세트에 임시 테이블을 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0b623147bb53d8551fb2005685b8d893c9dfbbbc" translate="yes" xml:space="preserve">
          <source>Without and with strict mode:</source>
          <target state="translated">엄격 모드 유무</target>
        </trans-unit>
        <trans-unit id="e96d5568eb8f9c088ef95b52de2e79b726cad775" translate="yes" xml:space="preserve">
          <source>Without any &lt;code&gt;SESSION&lt;/code&gt; or &lt;code&gt;GLOBAL&lt;/code&gt; keyword, the statement sets the isolation level for the next (not started) transaction performed within the current session.</source>
          <target state="translated">&lt;code&gt;SESSION&lt;/code&gt; 또는 &lt;code&gt;GLOBAL&lt;/code&gt; 키워드가 없으면 , 명령문은 현재 세션 내에서 수행 된 다음 (시작되지 않은) 트랜잭션의 분리 레벨을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="8f5e1892dfd8723c603b7a6c4febaa2c8b906f77" translate="yes" xml:space="preserve">
          <source>Without any special characters, a regular expression match is true if the characters match. The match is case-insensitive, except in the case of BINARY strings.</source>
          <target state="translated">특수 문자가 없으면 문자가 일치하면 정규식 일치가 참입니다. BINARY 문자열의 경우를 제외하고는 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3e33f667c462bf1b4f87568d34ed07c981e40853" translate="yes" xml:space="preserve">
          <source>Without connection pool or MariaDB thread pool, HaProxy and Spider have been protecting the tcp socket overflow without specific TCP tuning. In reality with a well tuned TCP stack or thread pool the curve should not decrease so abruptly to 0. Refer to the &lt;a href=&quot;../threadpool-in-55/index&quot;&gt;MariaDB Thread Pool&lt;/a&gt; to explore this feature.</source>
          <target state="translated">연결 풀이나 MariaDB 스레드 풀이 없으면 HaProxy와 Spider는 특정 TCP 조정없이 tcp 소켓 오버 플로우를 보호하고 있습니다. 실제로 잘 조정 된 TCP 스택 또는 스레드 풀의 경우 곡선이 갑자기 0으로 줄어들지 않아야 합니다.이 기능을 탐색 하려면 &lt;a href=&quot;../threadpool-in-55/index&quot;&gt;MariaDB 스레드 풀&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ec409a2ee4fae7fbaf7d45672888231ee9ddabb0" translate="yes" xml:space="preserve">
          <source>Without detection or prevention of partial writes, the integrity of the database can be compromised after recovery.</source>
          <target state="translated">부분 쓰기를 감지하거나 방지하지 않으면 복구 후 데이터베이스의 무결성이 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="491fb7eaf6009970effc785af80c8b5c5ea694ed" translate="yes" xml:space="preserve">
          <source>Without that extra index, you would need 5.6, which has the ability to create indexes for subqueries. This is indicated by &amp;lt;auto_key0&amp;gt; in the EXPLAIN. Even so, the performance is worse with the auto-generated index than with the manually generated one.</source>
          <target state="translated">추가 인덱스가 없으면 하위 쿼리에 대한 인덱스를 생성 할 수있는 5.6이 필요합니다. 이것은 EXPLAIN에서 &amp;lt;auto_key0&amp;gt;으로 표시됩니다. 그럼에도 불구하고 수동으로 생성 된 인덱스보다 자동 생성 된 인덱스의 성능이 떨어집니다.</target>
        </trans-unit>
        <trans-unit id="678e97cf12e2f57e796a9fcdfd98aa1fbeeffeef" translate="yes" xml:space="preserve">
          <source>Without that, log entries will go to the main system log file, and low-severity logs may not be recorded at all.</source>
          <target state="translated">그렇지 않으면 로그 항목이 기본 시스템 로그 파일로 이동하고 심각도가 낮은 로그는 전혀 기록되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38b2c685b7e19faac9eb7d34c2e7278205d9865a" translate="yes" xml:space="preserve">
          <source>Without the &lt;a href=&quot;../force-index/index&quot;&gt;FORCE INDEX&lt;/a&gt; option we would have '&lt;code&gt;Using where; Using temporary; Using filesort&lt;/code&gt;' in the 'Extra' column, which means that the optimizer would created a temporary table and sort it.</source>
          <target state="translated">&lt;a href=&quot;../force-index/index&quot;&gt;FORCE INDEX&lt;/a&gt; 옵션이 없으면 ' &lt;code&gt;Using where; Using temporary; Using filesort&lt;/code&gt; '추가'열에서 filesort '를 사용 하면 최적화 프로그램이 임시 테이블을 작성하여 정렬 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="50983bc5907ff2ea0ecb08be6ab857722405709e" translate="yes" xml:space="preserve">
          <source>Wizard for batch SQL formatting of files on the disk</source>
          <target state="translated">디스크에서 파일의 배치 SQL 형식화 마법사</target>
        </trans-unit>
        <trans-unit id="37ab0984be2bb222e3c40769d11e6a3336151d7a" translate="yes" xml:space="preserve">
          <source>Wonderful hop, light alcohol</source>
          <target state="translated">멋진 홉, 가벼운 알코올</target>
        </trans-unit>
        <trans-unit id="4bdafb024b64645ce043e444b45f31fd43a16cad" translate="yes" xml:space="preserve">
          <source>Word Connect-1.6.7: &lt;a alt=&quot;DOCX_Connect_1_6_7&quot; href=&quot;https://mariadb.com/kb/en/using-connect-documentation/+attachment/DOCX_Connect_1_6_7&quot;&gt;DOCX_Connect_1_6_7&lt;/a&gt;.</source>
          <target state="translated">Word Connect-1.6.7 : &lt;a alt=&quot;DOCX_Connect_1_6_7&quot; href=&quot;https://mariadb.com/kb/en/using-connect-documentation/+attachment/DOCX_Connect_1_6_7&quot;&gt;DOCX_Connect_1_6_7&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1ce304d4957c160c4bf05d1896f7537bd5cc9dfd" translate="yes" xml:space="preserve">
          <source>Word boundaries</source>
          <target state="translated">단어 경계</target>
        </trans-unit>
        <trans-unit id="07448a65362c653403e6e5f38686952216bd192a" translate="yes" xml:space="preserve">
          <source>Word from the text of a column with a fulltext index. Words can appear multiple times in the table, once per &lt;code&gt;DOC_ID&lt;/code&gt; and &lt;code&gt;POSITION&lt;/code&gt; combination.</source>
          <target state="translated">전체 텍스트 인덱스가있는 열 텍스트의 단어. 단어는 &lt;code&gt;DOC_ID&lt;/code&gt; 및 &lt;code&gt;POSITION&lt;/code&gt; 조합 마다 한 번씩 표에 여러 번 나타날 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="08503bc94e10947cfb8d3d65399e8ca4ef4a902c" translate="yes" xml:space="preserve">
          <source>Word from the text of a newly added row. Words can appear multiple times in the table, once per &lt;code&gt;DOC_ID&lt;/code&gt; and &lt;code&gt;POSITION&lt;/code&gt; combination.</source>
          <target state="translated">새로 추가 된 행의 텍스트에서 단어. 단어는 &lt;code&gt;DOC_ID&lt;/code&gt; 및 &lt;code&gt;POSITION&lt;/code&gt; 조합 마다 한 번씩 표에 여러 번 나타날 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f0ae31ec16e6cc88e19bfd313918a7432c407f2d" translate="yes" xml:space="preserve">
          <source>Words less than 4 characters in length (3 or less) will not be stored in the fulltext index. This value can be adjusted by changing the &lt;a href=&quot;../server-system-variables/index#ft_min_word_len&quot;&gt;ft_min_word_length&lt;/a&gt; system variable (or, for &lt;a href=&quot;../innodb/index&quot;&gt;InnoDB&lt;/a&gt;, &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_ft_min_token_size&quot;&gt;innodb_ft_min_token_size&lt;/a&gt;).</source>
          <target state="translated">길이가 4 자 미만 (3 이하) 인 단어는 전체 텍스트 색인에 저장되지 않습니다. 이 값은 &lt;a href=&quot;../server-system-variables/index#ft_min_word_len&quot;&gt;ft_min_word_length&lt;/a&gt; 시스템 변수 (또는 &lt;a href=&quot;../innodb/index&quot;&gt;InnoDB의&lt;/a&gt; 경우 &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_ft_min_token_size&quot;&gt;innodb_ft_min_token_size&lt;/a&gt; ) 를 변경하여 조정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="aee32ea03abe21a74a47e9e4593ed0dc624a1f84" translate="yes" xml:space="preserve">
          <source>Words longer than 84 characters in length will also not be stored in the fulltext index. This values can be adjusted by changing the &lt;a href=&quot;../server-system-variables/index#ft_max_word_len&quot;&gt;ft_max_word_length&lt;/a&gt; system variable (or, for &lt;a href=&quot;../innodb/index&quot;&gt;InnoDB&lt;/a&gt;, &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_ft_max_token_size&quot;&gt;innodb_ft_max_token_size&lt;/a&gt;).</source>
          <target state="translated">길이가 84 자보다 긴 단어는 전체 텍스트 색인에 저장되지 않습니다. 이 값은 &lt;a href=&quot;../server-system-variables/index#ft_max_word_len&quot;&gt;ft_max_word_length&lt;/a&gt; 시스템 변수 (또는 &lt;a href=&quot;../innodb/index&quot;&gt;InnoDB의&lt;/a&gt; 경우 &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_ft_max_token_size&quot;&gt;innodb_ft_max_token_size&lt;/a&gt; ) 를 변경하여 조정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ad0482a53f54c1c38493b2119e47942241ff0de1" translate="yes" xml:space="preserve">
          <source>Work began in earnest on the Maria storage engine but the plans quickly expanded and morphed and soon the developers were not just working on a storage engine, but on a complete branch of the MySQL database. Since the project was already called Maria, it made sense to call the whole database server MariaDB.</source>
          <target state="translated">Maria 스토리지 엔진에 대한 작업이 본격적으로 시작되었지만 계획이 빠르게 확장되고 변형되었으며 곧 개발자가 스토리지 엔진을 작업하는 것이 아니라 MySQL 데이터베이스의 전체 브랜치에서 작업했습니다. 프로젝트는 이미 Maria라고했기 때문에 전체 데이터베이스 서버 MariaDB를 호출하는 것이 합리적이었습니다.</target>
        </trans-unit>
        <trans-unit id="8d7e2003ffe4f2be75b411357a0cc248ec1e8c80" translate="yes" xml:space="preserve">
          <source>Work-around Process:</source>
          <target state="translated">해결 과정 :</target>
        </trans-unit>
        <trans-unit id="1ca0ef1afcc26af646433f6e3fab66cf9885f5ad" translate="yes" xml:space="preserve">
          <source>Workarounds for some repository issues with the 5.5.33 release.</source>
          <target state="translated">5.5.33 릴리스의 일부 리포지토리 문제에 대한 해결 방법</target>
        </trans-unit>
        <trans-unit id="3dfe8ddd3bc2f6165879473a86c0530d10f190dc" translate="yes" xml:space="preserve">
          <source>Workarounds:</source>
          <target state="translated">Workarounds:</target>
        </trans-unit>
        <trans-unit id="8513610fa9d20ff09efea964f764e075cd6872d5" translate="yes" xml:space="preserve">
          <source>Worker Thread Creation by Listener Thread</source>
          <target state="translated">리스너 스레드에 의한 작업자 스레드 생성</target>
        </trans-unit>
        <trans-unit id="9ff64748f5ad6d0c267fbcfc64fbf7d8e54f0381" translate="yes" xml:space="preserve">
          <source>Worker Thread Creation by Timer Thread during Stalls</source>
          <target state="translated">중단시 타이머 스레드에 의한 작업자 스레드 생성</target>
        </trans-unit>
        <trans-unit id="bb3ad4c86040df77ac9065a618741afc7e6fe24d" translate="yes" xml:space="preserve">
          <source>Worker Threads</source>
          <target state="translated">작업자 스레드</target>
        </trans-unit>
        <trans-unit id="a0fabf6968f597ceec802a0bdb61d985dabd457b" translate="yes" xml:space="preserve">
          <source>Working Around the Problem</source>
          <target state="translated">문제 해결</target>
        </trans-unit>
        <trans-unit id="f5c3c0f3a08114e5b68236529ce6ab91e5bf0457" translate="yes" xml:space="preserve">
          <source>Working while your computer is busy running mysql-test-run.pl.</source>
          <target state="translated">컴퓨터가 mysql-test-run.pl을 실행하는 동안 작업 중입니다.</target>
        </trans-unit>
        <trans-unit id="aa4462e67aab3a52217aff1c45a148a57aaa074a" translate="yes" xml:space="preserve">
          <source>Working with the Employee Database</source>
          <target state="translated">직원 데이터베이스 작업</target>
        </trans-unit>
        <trans-unit id="54b730a8df6f0e071275a655ff076b3065e813e5" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;MODIFY COLUMN&lt;/code&gt; except that you can also change the name of the column. The column will be at the same place as the original column and all index on the column will be kept.</source>
          <target state="translated">열 이름을 변경할 수도 있다는 점을 제외하고 &lt;code&gt;MODIFY COLUMN&lt;/code&gt; 과 같이 작동 합니다. 열은 원래 열과 같은 위치에 있으며 열의 모든 인덱스가 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="59914e72dee2a6fe777d0798eb7f0ab694420dab" translate="yes" xml:space="preserve">
          <source>Works like in &lt;code&gt;non group commit'&lt;/code&gt; but the thread doesn't do any real sync(). If aria_group_commit_interval is not zero, the sync() will be performed by a service thread with the given rate when needed (new LSN appears). If aria_group_commit_interval is zero, there will be no sync() calls.</source>
          <target state="translated">&lt;code&gt;non group commit'&lt;/code&gt; 과 같은 방식으로 작동 하지만 스레드는 실제 sync ()를 수행하지 않습니다. aria_group_commit_interval이 0이 아닌 경우 sync ()는 필요할 때 지정된 속도로 서비스 스레드에 의해 수행됩니다 (새 LSN이 나타남). aria_group_commit_interval이 0이면 sync () 호출이 없습니다.</target>
        </trans-unit>
        <trans-unit id="f5a6ddedf97473b20224b747067667756fb3fb81" translate="yes" xml:space="preserve">
          <source>Works with &lt;code&gt;--stop-file&lt;/code&gt;, print messages every &lt;em&gt;sec&lt;/em&gt; seconds when mysqltest is waiting to remove the file (for buildbot) (also MTR_STOP_KEEP_ALIVE environment variable).</source>
          <target state="translated">&lt;code&gt;--stop-file&lt;/code&gt; 과 함께 작동하며 , mysqltest가 파일을 제거하기 위해 대기중인 경우 (빌드 봇의 경우) MTR_STOP_KEEP_ALIVE 환경 변수) 매 &lt;em&gt;초&lt;/em&gt; 마다 메시지를 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="1db7ec5398f4ff0f7ca78559f36168133231db08" translate="yes" xml:space="preserve">
          <source>Works with files stored in CSV (comma-separated-values) format.</source>
          <target state="translated">CSV (쉼표로 구분 된 값) 형식으로 저장된 파일과 함께 작동합니다.</target>
        </trans-unit>
        <trans-unit id="76c0c0ec5919d64b63789973ecdfedeb4bc3e7d8" translate="yes" xml:space="preserve">
          <source>Workspace saving</source>
          <target state="translated">작업 공간 절약</target>
        </trans-unit>
        <trans-unit id="d2e3f553055320475b006b720b6b3c74ec5366a0" translate="yes" xml:space="preserve">
          <source>Would have passwordless ssh access between PMs?</source>
          <target state="translated">PM간에 비밀번호없는 ssh 액세스 권한이 있습니까?</target>
        </trans-unit>
        <trans-unit id="89602f17b4f620af431771681e16d27687213f9e" translate="yes" xml:space="preserve">
          <source>Would one ever PARTITION a Summary Table? Yes, in extreme situations, such as the table being large, and</source>
          <target state="translated">어떤 사람이 요약표를 작성합니까? 예, 테이블이 큰 등의 극한 상황에서는</target>
        </trans-unit>
        <trans-unit id="4d084a64e0ad1f853b7ee3f25379584295a35bc4" translate="yes" xml:space="preserve">
          <source>Would you have passwordless ssh access between PMs?</source>
          <target state="translated">PM간에 비밀번호없는 ssh 액세스 권한이 있습니까?</target>
        </trans-unit>
        <trans-unit id="a9ebad9ce612c251b607a54c6d2d4842c89b63b2" translate="yes" xml:space="preserve">
          <source>Wrapper</source>
          <target state="translated">Wrapper</target>
        </trans-unit>
        <trans-unit id="98218f5c5418bbbc2dd06dac215be1cafab0234c" translate="yes" xml:space="preserve">
          <source>Wrapper program example</source>
          <target state="translated">랩퍼 프로그램 예</target>
        </trans-unit>
        <trans-unit id="f2d3a30f12e00e57ea3fb2ffc49c9eea86bf96a3" translate="yes" xml:space="preserve">
          <source>Wrapup</source>
          <target state="translated">Wrapup</target>
        </trans-unit>
        <trans-unit id="652a58841c7f2f9762bffc61c640d2a40ac1ef3a" translate="yes" xml:space="preserve">
          <source>Write ANALYZE, OPTIMIZE and REPAIR TABLE commands to the &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt;. Enabled by default; use &lt;code&gt;--skip-write-binlog&lt;/code&gt; when commands should not be sent to replication slaves.</source>
          <target state="translated">ANALYZE, OPTIMIZE 및 REPAIR TABLE 명령을 &lt;a href=&quot;../binary-log/index&quot;&gt;이진 로그에&lt;/a&gt; 씁니다 . 기본적으로 활성화되어 있습니다. 사용 &lt;code&gt;--skip-write-binlog&lt;/code&gt; 명령은 복제 노예로 전송되지해야 할 때.</target>
        </trans-unit>
        <trans-unit id="5a0bccf16429998445011defea666a26afc70934" translate="yes" xml:space="preserve">
          <source>Write STR to the output within lines filled with #, as a form of banner.</source>
          <target state="translated">배너 형식으로 #으로 채워진 행 내의 출력에 STR을 씁니다.</target>
        </trans-unit>
        <trans-unit id="629935bf77fdd8a949d430c6b4baaca27b04020a" translate="yes" xml:space="preserve">
          <source>Write Scalability</source>
          <target state="translated">쓰기 확장 성</target>
        </trans-unit>
        <trans-unit id="e9bc25aebb827bad238988517f2293042c7b9f58" translate="yes" xml:space="preserve">
          <source>Write Statements</source>
          <target state="translated">문장 쓰기</target>
        </trans-unit>
        <trans-unit id="b39cfd108869fef8506ea77e7025635af7700f2b" translate="yes" xml:space="preserve">
          <source>Write a binary string into file</source>
          <target state="translated">이진 문자열을 파일로 작성</target>
        </trans-unit>
        <trans-unit id="e63eea5aca10d91a0df20af2611520490c926008" translate="yes" xml:space="preserve">
          <source>Write a debugging log. A typical debug_options string is &amp;acute;d:t:o,file_name&amp;acute;. The default is &amp;acute;d:t:o,/tmp/myisamchk.trace&amp;acute;. (Available in debug builds only)</source>
          <target state="translated">디버깅 로그를 작성하십시오. 일반적인 debug_options 문자열은&amp;ldquo;d : t : o, file_name&amp;rdquo;입니다. 디폴트는&amp;ldquo;d : t : o, / tmp / myisamchk.trace&amp;rdquo;입니다. (디버그 빌드에서만 사용 가능)</target>
        </trans-unit>
        <trans-unit id="5eac6f37e66f2dac0ecf265893b67fd6071b2b97" translate="yes" xml:space="preserve">
          <source>Write a debugging log. A typical debug_options string is &lt;code&gt;d:t:o,file_name&lt;/code&gt;. The default is &lt;code&gt;d:t:o,/tmp/mysqladmin.trace&lt;/code&gt;.</source>
          <target state="translated">디버깅 로그를 작성하십시오. 일반적인 debug_options 문자열은 &lt;code&gt;d:t:o,file_name&lt;/code&gt; 입니다. 기본값은 &lt;code&gt;d:t:o,/tmp/mysqladmin.trace&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a3e7a8dfddaa5646bdf7d79fe5c2433e58075854" translate="yes" xml:space="preserve">
          <source>Write additional information in the dump file such as program version, server version, and host. Disable with &lt;code&gt;--skip-comments&lt;/code&gt;.</source>
          <target state="translated">프로그램 버전, 서버 버전 및 호스트와 같은 추가 정보를 덤프 파일에 작성하십시오. &lt;code&gt;--skip-comments&lt;/code&gt; 로 비활성화하십시오 .</target>
        </trans-unit>
        <trans-unit id="0a6b7140cc92747039353c34ec2cd526ed06369a" translate="yes" xml:space="preserve">
          <source>Write buffer size for sequential writes during repair of fixed size or dynamic size rows</source>
          <target state="translated">고정 크기 또는 동적 크기 행을 복구하는 동안 순차적 쓰기를위한 쓰기 버퍼 크기</target>
        </trans-unit>
        <trans-unit id="f476227e5d94ac9699d315e66703a154d6a9f5af" translate="yes" xml:space="preserve">
          <source>Write column names in results. (Defaults to on; use &lt;code&gt;--skip-column-names&lt;/code&gt; to disable.)</source>
          <target state="translated">결과에 열 이름을 씁니다. (기본값은 on; &lt;code&gt;--skip-column-names&lt;/code&gt; 하려면 --skip-column-names 를 사용하십시오.)</target>
        </trans-unit>
        <trans-unit id="689bbdd96a6cdc3116d160ede7b1f9f107f28cba" translate="yes" xml:space="preserve">
          <source>Write complex SQL code comfortably in Worksheet.</source>
          <target state="translated">워크 시트에서 복잡한 SQL 코드를 편안하게 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="9d67614bb7dbe8a7e10748e037599baeb45e5578" translate="yes" xml:space="preserve">
          <source>Write data/index partially sorted records to disk before finding out exactly where it belongs.</source>
          <target state="translated">데이터 / 인덱스 부분적으로 정렬 된 레코드를 디스크에 정확히 기록하기 전에 디스크에 기록하십시오.</target>
        </trans-unit>
        <trans-unit id="eb3a6240bdf6750a4f0b5c0c08ba85cb515dce15" translate="yes" xml:space="preserve">
          <source>Write info about progress and packing result. Use many -v for more verbosity!</source>
          <target state="translated">진행 상황 및 포장 결과에 대한 정보를 작성하십시오. 더 자세한 정보를 얻으려면 많은 -v를 사용하십시오!</target>
        </trans-unit>
        <trans-unit id="4c7474521420e10c146a3c6c5f444e1d925c5024" translate="yes" xml:space="preserve">
          <source>Write info about progress and packing result. Use multiple &lt;code&gt;-v&lt;/code&gt; flags for more verbosity.</source>
          <target state="translated">진행 상황 및 포장 결과에 대한 정보를 작성하십시오. 더 자세한 정보를 얻으려면 여러 개의 &lt;code&gt;-v&lt;/code&gt; 플래그를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="fe450a99b3ff6a628c0e6fced632e7bfd24c7f9f" translate="yes" xml:space="preserve">
          <source>Write line numbers for errors. (Defaults to on; use &lt;code&gt;--skip-line-numbers&lt;/code&gt; to disable.)</source>
          <target state="translated">오류의 줄 번호를 쓰십시오. (기본값은 on이며 &lt;code&gt;--skip-line-numbers&lt;/code&gt; 하려면 --skip-line-numbers 를 사용하십시오.)</target>
        </trans-unit>
        <trans-unit id="a48027a6d2dc14a695ba417ff0a73998a5811405" translate="yes" xml:space="preserve">
          <source>Write more information</source>
          <target state="translated">더 많은 정보 쓰기</target>
        </trans-unit>
        <trans-unit id="737b2efa802a9819cb30cf62925f673ee200df83" translate="yes" xml:space="preserve">
          <source>Write more information.</source>
          <target state="translated">더 많은 정보를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="797733ffbc6c04943324915cb41378d749c84585" translate="yes" xml:space="preserve">
          <source>Write more. (-v -v -v gives the table output format).</source>
          <target state="translated">더 쓰세요. (-v -v -v는 테이블 출력 형식을 제공합니다).</target>
        </trans-unit>
        <trans-unit id="590ad58b956c05515f48accf1d45168825c463d7" translate="yes" xml:space="preserve">
          <source>Write output to stdout instead of to the OS's repository configuration file. This will also skip importing GPG public keys and updating the package cache on platforms where that behavior exists.</source>
          <target state="translated">OS의 저장소 구성 파일 대신 stdout에 출력을 씁니다. 또한 GPG 공개 키 가져 오기와 해당 동작이 존재하는 플랫폼에서 패키지 캐시 업데이트를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="615d79ae92af47edc7de22f57cf5565ac5c88fe8" translate="yes" xml:space="preserve">
          <source>Write queries with customizable syntax-highlighting and code-completion</source>
          <target state="translated">사용자 정의 가능한 구문 강조 표시 및 코드 완성으로 쿼리 작성</target>
        </trans-unit>
        <trans-unit id="b534ce95bd4cb9d3a787e38f89fd7b030ff88d26" translate="yes" xml:space="preserve">
          <source>Write scaling</source>
          <target state="translated">쓰기 스케일링</target>
        </trans-unit>
        <trans-unit id="75854107a6aad1cf9246026854058d027ada136c" translate="yes" xml:space="preserve">
          <source>Write some metadata info (binlog position)</source>
          <target state="translated">메타 데이터 정보 작성 (이진 위치)</target>
        </trans-unit>
        <trans-unit id="9544dca4059cff2c2dd3e5b6cbd9c4f883eebf15" translate="yes" xml:space="preserve">
          <source>Write statements and transactions affecting any other databases into the &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt;.</source>
          <target state="translated">다른 데이터베이스에 영향을주는 명령문 및 트랜잭션을 &lt;a href=&quot;../binary-log/index&quot;&gt;이진 로그에 작성&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="597dfdcdb675ab126c9f70952af1930d0144e78d" translate="yes" xml:space="preserve">
          <source>Write statements and transactions affecting the database named &lt;em&gt;db1&lt;/em&gt; into the &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt;.</source>
          <target state="translated">라는 이름의 데이터베이스에 영향을 미치는 쓰기 제표 및 거래 &lt;em&gt;DB1&lt;/em&gt; 에 &lt;a href=&quot;../binary-log/index&quot;&gt;바이너리 로그를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="23272abc9cb9a507f0aa1028ef351e422dacfb6a" translate="yes" xml:space="preserve">
          <source>Write statements and transactions affecting the database named &lt;em&gt;db2&lt;/em&gt; into the &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt;.</source>
          <target state="translated">라는 이름의 데이터베이스에 영향을 미치는 쓰기 제표 및 거래 &lt;em&gt;DB2&lt;/em&gt; 에 &lt;a href=&quot;../binary-log/index&quot;&gt;바이너리 로그를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3774de2a1633c380e74c23a4bd17e047d4f7b942" translate="yes" xml:space="preserve">
          <source>Write the error log to the given file.</source>
          <target state="translated">주어진 파일에 오류 로그를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="218ddd10ccf779ca2f1088f1dc053f6331c8fe2f" translate="yes" xml:space="preserve">
          <source>Write the resultset to a formatted file</source>
          <target state="translated">결과 집합을 형식이 지정된 파일에 기록</target>
        </trans-unit>
        <trans-unit id="9dee29bf8f48bf9a96928d0705b83c007e1af5fe" translate="yes" xml:space="preserve">
          <source>Write to exceptions table failed. Message: %s&quot;</source>
          <target state="translated">예외 테이블에 쓰지 못했습니다. 메시지 : % s &quot;</target>
        </trans-unit>
        <trans-unit id="c27954ee71e2f65bc1bf0c42cb880cb0a852ad42" translate="yes" xml:space="preserve">
          <source>Write when and why servers are restarted between test cases.</source>
          <target state="translated">테스트 사례 사이에 서버가 언제 언제 다시 시작되는지 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="78a823589726ccb68a0ef9c8638708f8b76c37d8" translate="yes" xml:space="preserve">
          <source>WriteEngineServer coordinates DML, DDL and imports on each Performance Module. DDL changes are made persistent within the System Catalog, which keeps track of all ColumnStore metadata.</source>
          <target state="translated">WriteEngineServer는 각 성능 모듈에서 DML, DDL 및 가져 오기를 조정합니다. DDL 변경은 시스템 카탈로그 내에서 영구적으로 이루어 지므로 모든 ColumnStore 메타 데이터를 추적합니다.</target>
        </trans-unit>
        <trans-unit id="9c7679798c91d057b7f794e98bfc37f8e8362323" translate="yes" xml:space="preserve">
          <source>Write_row_event runs an INSERT trigger. Additionally it runs a DELETE trigger if there was a conflicting row that had to be deleted.</source>
          <target state="translated">Write_row_event는 INSERT 트리거를 실행합니다. 또한 충돌해야하는 행이 삭제 된 경우 DELETE 트리거를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="f0c3b1beb1d8a43117c21f9ffb456d50d8f7e0e5" translate="yes" xml:space="preserve">
          <source>Writes are applied in parallel on the 'slaves', up to the setting wsrep_slave_threads. This is safe because of the way COMMITs work.</source>
          <target state="translated">쓰기는 wsrep_slave_threads 설정까지 '슬레이브'에 병렬로 적용됩니다. COMMIT가 작동하는 방식 때문에 안전합니다.</target>
        </trans-unit>
        <trans-unit id="a0cab26e4b6c1d9638c1807a47b8d71041bc5c8b" translate="yes" xml:space="preserve">
          <source>Writes are replicated via &quot;Row Based Replication&quot;, which is decidely faster for single-row operations.</source>
          <target state="translated">쓰기는 &quot;행 기반 복제&quot;를 통해 복제되며, 이는 단일 행 작업에 훨씬 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="08520be7e7ee562ad911cdf0c64be805e365e9c6" translate="yes" xml:space="preserve">
          <source>Writes to `Staging` are not replicated.</source>
          <target state="translated">스테이징에 대한 쓰기는 복제되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3223392316c246c8fc8fa92f0cb0f1c8bec2e212" translate="yes" xml:space="preserve">
          <source>Writing Logs Into Tables</source>
          <target state="translated">테이블에 로그 쓰기</target>
        </trans-unit>
        <trans-unit id="d557b72b66f5a0834b5f222c69bf2f8054c95365" translate="yes" xml:space="preserve">
          <source>Writing Plugins for MariaDB</source>
          <target state="translated">MariaDB 용 플러그인 작성</target>
        </trans-unit>
        <trans-unit id="8b2a53a44be9823f446abe1cf4ff603d68a4862a" translate="yes" xml:space="preserve">
          <source>Writing Replicated Write Sets to the Binary Log</source>
          <target state="translated">이진 로그에 복제 된 쓰기 세트 쓰기</target>
        </trans-unit>
        <trans-unit id="7853a396c3a7bb58623b5724a4f4bc7b95efc961" translate="yes" xml:space="preserve">
          <source>Writing a MariaDB PAM Authentication Plugin</source>
          <target state="translated">MariaDB PAM 인증 플러그인 작성</target>
        </trans-unit>
        <trans-unit id="fb399ec9f79ea3f5e36812c22b9ce60c94fbd160" translate="yes" xml:space="preserve">
          <source>Writing a packet to the network.</source>
          <target state="translated">네트워크에 패킷 쓰기</target>
        </trans-unit>
        <trans-unit id="d66d9a5fecc5245dbcb4597aed8ea24dd95c5161" translate="yes" xml:space="preserve">
          <source>Writing one row to the row-based binary log failed</source>
          <target state="translated">행 기반 이진 로그에 한 행을 쓰지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="189f3f280e4ff8f036ad78aff8533e2f5d303e7e" translate="yes" xml:space="preserve">
          <source>Writing plugins for MariaDB.</source>
          <target state="translated">MariaDB 용 플러그인 작성</target>
        </trans-unit>
        <trans-unit id="2d4e849a848a3b52d2c95d882608b44bba7aa25d" translate="yes" xml:space="preserve">
          <source>Writing statement to the &lt;a href=&quot;../slow-query-log/index&quot;&gt;slow query log&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../slow-query-log/index&quot;&gt;느린 쿼리 로그에&lt;/a&gt; 문을 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="ed004bb49befd590dc4c5a8378f32469b776d83f" translate="yes" xml:space="preserve">
          <source>Writing the Error Log to Console on Windows</source>
          <target state="translated">Windows에서 콘솔에 오류 로그 작성</target>
        </trans-unit>
        <trans-unit id="8ebd157786ffcc26e6b04508d7d9d982b6a09381" translate="yes" xml:space="preserve">
          <source>Writing the Error Log to Stderr on Unix</source>
          <target state="translated">유닉스에서 Stderr에 오류 로그 쓰기</target>
        </trans-unit>
        <trans-unit id="7116b83cef12cc9dc68d7d31ca9d65368aada679" translate="yes" xml:space="preserve">
          <source>Writing the Error Log to Syslog on Unix</source>
          <target state="translated">Unix의 Syslog에 오류 로그 작성</target>
        </trans-unit>
        <trans-unit id="873ee198a527a198e07b6adc6027c52721183c6c" translate="yes" xml:space="preserve">
          <source>Writing the Error Log to a File</source>
          <target state="translated">파일에 오류 로그 쓰기</target>
        </trans-unit>
        <trans-unit id="5951912a9db4effd34f517e9841c9d9e0ae565ab" translate="yes" xml:space="preserve">
          <source>Writing the Error Log to the Windows Event Viewer</source>
          <target state="translated">Windows 이벤트 뷰어에 오류 로그 작성</target>
        </trans-unit>
        <trans-unit id="de04d3f1d8412883aa72d41aa04980b335230412" translate="yes" xml:space="preserve">
          <source>Writing the General Query Log to a File</source>
          <target state="translated">일반 쿼리 로그를 파일에 쓰기</target>
        </trans-unit>
        <trans-unit id="0dc8c1c9887f3a057106d3d36cacbc5b883de7f2" translate="yes" xml:space="preserve">
          <source>Writing the General Query Log to a Table</source>
          <target state="translated">일반 쿼리 로그를 테이블에 쓰기</target>
        </trans-unit>
        <trans-unit id="7cc4f2e7257253a52da4349054c65b14ce3b0e99" translate="yes" xml:space="preserve">
          <source>Writing the Slow Query Log to a File</source>
          <target state="translated">느린 쿼리 로그를 파일에 쓰기</target>
        </trans-unit>
        <trans-unit id="278f7e4bce51682508f56f788ad92baa8a47262c" translate="yes" xml:space="preserve">
          <source>Writing the Slow Query Log to a Table</source>
          <target state="translated">느린 쿼리 로그를 테이블에 쓰기</target>
        </trans-unit>
        <trans-unit id="71ecde5014e49fa123f0a63302e7dcd499ef5330" translate="yes" xml:space="preserve">
          <source>Writing to net</source>
          <target state="translated">그물에 쓰기</target>
        </trans-unit>
        <trans-unit id="48ca1ea052f66fcc7db03483acd648d365a58c30" translate="yes" xml:space="preserve">
          <source>Written Oct, 2012. Added TokuDB, Jan, 2015.</source>
          <target state="translated">2012 년 10 월 작성. 2015 년 1 월 TokuDB 추가.</target>
        </trans-unit>
        <trans-unit id="5ae46dde1ea211fa30996377965a9ee184024535" translate="yes" xml:space="preserve">
          <source>Wrong Create Options</source>
          <target state="translated">잘못된 작성 옵션</target>
        </trans-unit>
        <trans-unit id="2d6402b699f1d22b33d45ba77a2e55097e98527e" translate="yes" xml:space="preserve">
          <source>Wrong format of the encoded string</source>
          <target state="translated">인코딩 된 문자열의 형식이 잘못되었습니다</target>
        </trans-unit>
        <trans-unit id="d18bed97c20680c8c3d4e36b7567a34e9c998efc" translate="yes" xml:space="preserve">
          <source>Wrong magic in %s</source>
          <target state="translated">% s의 잘못된 마법</target>
        </trans-unit>
        <trans-unit id="4a58890aca023c226696d8c45e70eef11c2cd324" translate="yes" xml:space="preserve">
          <source>Wrong number of partitions defined, mismatch with previous setting</source>
          <target state="translated">잘못 정의 된 파티션 수, 이전 설정과 일치하지 않습니다</target>
        </trans-unit>
        <trans-unit id="0a57973f85759acbc231a849947a37f259251d4c" translate="yes" xml:space="preserve">
          <source>Wrong number of subpartitions defined, mismatch with previous setting</source>
          <target state="translated">하위 파티션 수가 잘못 정의되어 이전 설정과 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="24abb563c05d0845028537b1c15851459a1aea17" translate="yes" xml:space="preserve">
          <source>Wrong usage of &lt;code&gt;--user&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;--user&lt;/code&gt; 의 잘못된 사용법</target>
        </trans-unit>
        <trans-unit id="21500761b9caa52f6e08f7fcc71dd2a377577be5" translate="yes" xml:space="preserve">
          <source>Wrong values for command line options</source>
          <target state="translated">명령 행 옵션에 대한 값이 잘못되었습니다</target>
        </trans-unit>
        <trans-unit id="cff4cf385640c3cc164952d1493f5e21bee6ccf5" translate="yes" xml:space="preserve">
          <source>Wrong values of lower_case_table_names and stack_size</source>
          <target state="translated">lower_case_table_names 및 stack_size의 잘못된 값</target>
        </trans-unit>
        <trans-unit id="8b9699354ec0042f4b05528514e4f7d7158b1417" translate="yes" xml:space="preserve">
          <source>Wsrep GTID Mode</source>
          <target state="translated">Wsrep GTID 모드</target>
        </trans-unit>
        <trans-unit id="977f702f55e6149a075d5975263818a7394b40e6" translate="yes" xml:space="preserve">
          <source>Wsrep GTID mode is not a perfect fix that allows MariaDB's &lt;a href=&quot;../gtid/index&quot;&gt;GTIDs&lt;/a&gt; to work perfectly with &lt;a href=&quot;../galera-cluster/index&quot;&gt;MariaDB Galera Cluster&lt;/a&gt;. There are definitely cases where &lt;a href=&quot;../gtid/index&quot;&gt;GTIDs&lt;/a&gt; can become inconsistent across the cluster nodes.</source>
          <target state="translated">Wsrep GTID 모드는 MariaDB의 &lt;a href=&quot;../gtid/index&quot;&gt;GTID&lt;/a&gt; 가 &lt;a href=&quot;../galera-cluster/index&quot;&gt;MariaDB Galera Cluster&lt;/a&gt; 와 완벽하게 작동하도록 하는 완벽한 수정이 아닙니다 . 클러스터 노드 에서 &lt;a href=&quot;../gtid/index&quot;&gt;GTID&lt;/a&gt; 가 일치하지 않는 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c032adc1ff629c9b66f22749ad667e6beadf144b" translate="yes" xml:space="preserve">
          <source>X</source>
          <target state="translated">X</target>
        </trans-unit>
        <trans-unit id="fecff951f9f4d3f36eb43c0d6525ad6438900871" translate="yes" xml:space="preserve">
          <source>X'&lt;code&gt;value&lt;/code&gt;' (SQL standard)</source>
          <target state="translated">X ' &lt;code&gt;value&lt;/code&gt; '(SQL 표준)</target>
        </trans-unit>
        <trans-unit id="539592324a169dbb7d7202ef2d1100d834a78525" translate="yes" xml:space="preserve">
          <source>X-coordinate value for a point</source>
          <target state="translated">점의 X 좌표 값</target>
        </trans-unit>
        <trans-unit id="9028dbda872b776aca1d41a48711fb2b3679c855" translate="yes" xml:space="preserve">
          <source>X-coordinate value for a point.</source>
          <target state="translated">점의 X 좌표 값입니다.</target>
        </trans-unit>
        <trans-unit id="74c817b8f95f998c8b94e96ea76ae7e1f997984b" translate="yes" xml:space="preserve">
          <source>X509 cipher - see &lt;a href=&quot;../grant/index#per-account-tls-options&quot;&gt;TLS options&lt;/a&gt;.</source>
          <target state="translated">X509 암호-TLS &lt;a href=&quot;../grant/index#per-account-tls-options&quot;&gt;옵션을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="02026c9ea4d3cab56489c1eae0ebf3153856a0e0" translate="yes" xml:space="preserve">
          <source>XA Transactions</source>
          <target state="translated">XA 거래</target>
        </trans-unit>
        <trans-unit id="0d82638bd09812cc5bcd47dd2f6bbfcdc691cf27" translate="yes" xml:space="preserve">
          <source>XA transactions are always supported.</source>
          <target state="translated">XA 트랜잭션은 항상 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="ceade77fd044df16b24a45e4bd080228036cd7c9" translate="yes" xml:space="preserve">
          <source>XA transactions are an overloaded term in MariaDB. If a &lt;a href=&quot;../storage-engines/index&quot;&gt;storage engine&lt;/a&gt; is XA-capable, it can mean one or both of these:</source>
          <target state="translated">XA 트랜잭션은 MariaDB에서 오버로드 된 용어입니다. 경우 &lt;a href=&quot;../storage-engines/index&quot;&gt;스토리지 엔진은&lt;/a&gt; XA 지원, 그것은 하나 또는이 두 가지를 의미 할 수있다 :</target>
        </trans-unit>
        <trans-unit id="9c0bdb7d967427ee706c3ae59e7cf289f00245d4" translate="yes" xml:space="preserve">
          <source>XA transactions are designed to allow distributed transactions, where a transaction manager (the application) controls a transaction which involves multiple resources. Such resources are usually DBMSs, but could be resources of any type. The whole set of required transactional operations is called a global transaction. Each subset of operations which involve a single resource is called a local transaction. XA used a 2-phases commit (2PC). With the first commit, the transaction manager tells each resource to prepare an effective commit, and waits for a confirm message. The changes are not still made effective at this point. If any of the resources encountered an error, the transaction manager will rollback the global transaction. If all resources communicate that the first commit is successful, the transaction manager can require a second commit, which makes the changes effective.</source>
          <target state="translated">XA 트랜잭션은 트랜잭션 관리자 (응용 프로그램)가 여러 자원을 포함하는 트랜잭션을 제어하는 ​​분산 트랜잭션을 허용하도록 설계되었습니다. 이러한 리소스는 일반적으로 DBMS이지만 모든 유형의 리소스 일 수 있습니다. 필요한 트랜잭션 작업의 전체 집합을 전역 트랜잭션이라고합니다. 단일 리소스를 포함하는 각 작업 하위 집합을 로컬 트랜잭션이라고합니다. XA는 2 단계 커밋 (2PC)을 사용했습니다. 첫 번째 커밋을 통해 트랜잭션 관리자는 각 리소스에 효과적인 커밋을 준비하도록 지시하고 확인 메시지를 기다립니다. 이 시점에서 변경 사항이 여전히 적용되지 않습니다. 자원에 오류가 발생한 경우, 트랜잭션 관리자는 글로벌 트랜잭션을 롤백합니다. 모든 자원이 첫 번째 확약이 성공했다고 통신하면, 트랜잭션 관리자는 두 번째 확약을 요구할 수 있습니다.변경 사항이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="ce04ad0ea550dd157418bad0b5d3b973fec14810" translate="yes" xml:space="preserve">
          <source>XA transactions cannot be supported. (Galera is already doing a form of XA in order to do its thing.)</source>
          <target state="translated">XA 트랜잭션은 지원할 수 없습니다. (Galera는 이미 XA 형태로 작업하고 있습니다.)</target>
        </trans-unit>
        <trans-unit id="1c1507016a6da99763e3976be5ca813e68aa9e14" translate="yes" xml:space="preserve">
          <source>XA transactions require &lt;a href=&quot;../set-transaction/index#repeatable-read&quot;&gt;REPEATABLE READ&lt;/a&gt; as a minimum isolation level. However, distributed transactions should always use &lt;a href=&quot;../set-transaction/index#serializable&quot;&gt;SERIALIZABLE&lt;/a&gt;.</source>
          <target state="translated">XA 트랜잭션에는 최소 분리 레벨 로 &lt;a href=&quot;../set-transaction/index#repeatable-read&quot;&gt;반복 읽기가&lt;/a&gt; 필요 합니다. 그러나 분산 트랜잭션은 항상 &lt;a href=&quot;../set-transaction/index#serializable&quot;&gt;SERIALIZABLE을&lt;/a&gt; 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="cc741719e6065b0a0e257db85779c81ef731d9de" translate="yes" xml:space="preserve">
          <source>XA100</source>
          <target state="translated">XA100</target>
        </trans-unit>
        <trans-unit id="3ec438dccfa822d89b0cb9d63a4a06d0c0a3f65e" translate="yes" xml:space="preserve">
          <source>XA102</source>
          <target state="translated">XA102</target>
        </trans-unit>
        <trans-unit id="57fbbbdfea8c6cb901529a4b02383784f12349e3" translate="yes" xml:space="preserve">
          <source>XA106</source>
          <target state="translated">XA106</target>
        </trans-unit>
        <trans-unit id="06c81caf7facc6ff84b792fd172e5d096599b72b" translate="yes" xml:space="preserve">
          <source>XAE03</source>
          <target state="translated">XAE03</target>
        </trans-unit>
        <trans-unit id="f7e46957c686d147f5c773d07c1ade15e94b1b86" translate="yes" xml:space="preserve">
          <source>XAE04</source>
          <target state="translated">XAE04</target>
        </trans-unit>
        <trans-unit id="f1c7fb0d19bc18425190ca4e16ba4c4f7f7e6fbf" translate="yes" xml:space="preserve">
          <source>XAE05</source>
          <target state="translated">XAE05</target>
        </trans-unit>
        <trans-unit id="f44eaf8b7aec80356567bd038dabc04922f7148b" translate="yes" xml:space="preserve">
          <source>XAE07</source>
          <target state="translated">XAE07</target>
        </trans-unit>
        <trans-unit id="f01f25f1a4c7316fae059158c72c42d0b837b0ec" translate="yes" xml:space="preserve">
          <source>XAE08</source>
          <target state="translated">XAE08</target>
        </trans-unit>
        <trans-unit id="c723563a42261f48684b950108e72fd43c3fde7c" translate="yes" xml:space="preserve">
          <source>XAE09</source>
          <target state="translated">XAE09</target>
        </trans-unit>
        <trans-unit id="b2ef287b88b32dcd56e64dfa143b8131f5b6eb41" translate="yes" xml:space="preserve">
          <source>XAER_DUPID: The XID already exists</source>
          <target state="translated">XAER_DUPID : XID가 이미 존재합니다</target>
        </trans-unit>
        <trans-unit id="e062c1d596f2b315e6b6559312c0df3618fb36bb" translate="yes" xml:space="preserve">
          <source>XAER_INVAL: Invalid arguments (or unsupported command)</source>
          <target state="translated">XAER_INVAL : 유효하지 않은 인수 (또는 지원되지 않는 명령)</target>
        </trans-unit>
        <trans-unit id="42901e42087684af2e4d02d0e444d6fc3001d6a6" translate="yes" xml:space="preserve">
          <source>XAER_NOTA: Unknown XID</source>
          <target state="translated">XAER_NOTA : 알 수없는 XID</target>
        </trans-unit>
        <trans-unit id="d07e4009326e8d657c668b9a228a0277bcc9691e" translate="yes" xml:space="preserve">
          <source>XAER_OUTSIDE: Some work is done outside global transaction</source>
          <target state="translated">XAER_OUTSIDE : 일부 작업은 글로벌 트랜잭션 외부에서 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="48a957893b7fbd2b8c119f060f14dc68b45f91c8" translate="yes" xml:space="preserve">
          <source>XAER_RMERR: Fatal error occurred in the transaction branch - check your data for consistency</source>
          <target state="translated">XAER_RMERR : 트랜잭션 분기에서 치명적인 오류가 발생했습니다. 일관성을 위해 데이터를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="9f55450e95008edb0bc353118fed0f65d45873df" translate="yes" xml:space="preserve">
          <source>XAER_RMFAIL: The command cannot be executed when global transaction is in the %s state</source>
          <target state="translated">XAER_RMFAIL : 글로벌 트랜잭션이 % s 상태 인 경우 명령을 실행할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="5ebaa7701fd1243eae44b2e9a9230a44078522a0" translate="yes" xml:space="preserve">
          <source>XA_RBDEADLOCK: Transaction branch was rolled back: deadlock was detected</source>
          <target state="translated">XA_RBDEADLOCK : 트랜잭션 분기가 롤백되었습니다 : 교착 상태가 감지되었습니다</target>
        </trans-unit>
        <trans-unit id="6e9cef98fadb9000b54d83f418af585753a632f1" translate="yes" xml:space="preserve">
          <source>XA_RBROLLBACK: Transaction branch was rolled back</source>
          <target state="translated">XA_RBROLLBACK : 트랜잭션 분기가 롤백되었습니다.</target>
        </trans-unit>
        <trans-unit id="acddc3fa7ba60af43c15b50ee7d5530275090fd0" translate="yes" xml:space="preserve">
          <source>XA_RBTIMEOUT: Transaction branch was rolled back: took too long</source>
          <target state="translated">XA_RBTIMEOUT : 트랜잭션 분기가 롤백되었습니다. 시간이 너무 오래 걸림</target>
        </trans-unit>
        <trans-unit id="9f391dce6147930648b332c237b1742b6e12230d" translate="yes" xml:space="preserve">
          <source>XCOL tables based on specified views</source>
          <target state="translated">지정된 뷰를 기반으로하는 XCOL 테이블</target>
        </trans-unit>
        <trans-unit id="b35e5f7ba4a7c37d8a2ae3d634058efc3b3a617a" translate="yes" xml:space="preserve">
          <source>XCode</source>
          <target state="translated">XCode</target>
        </trans-unit>
        <trans-unit id="93fe4d4942e5cabdae883711c1439e0412f7853a" translate="yes" xml:space="preserve">
          <source>XFS</source>
          <target state="translated">XFS</target>
        </trans-unit>
        <trans-unit id="fe58918a10c27ed384a8ade9b708fb6ad99e8c98" translate="yes" xml:space="preserve">
          <source>XML Representation</source>
          <target state="translated">XML 표현</target>
        </trans-unit>
        <trans-unit id="e3c87b46d42da2878c9a18c1cbbae512249900e6" translate="yes" xml:space="preserve">
          <source>XML Table Type</source>
          <target state="translated">XML 테이블 유형</target>
        </trans-unit>
        <trans-unit id="3d536793a6ed8197771206640b56e49ea29ee7af" translate="yes" xml:space="preserve">
          <source>XML en Action</source>
          <target state="translated">XML과 액션</target>
        </trans-unit>
        <trans-unit id="75ec7b95b48079984e9a418622bafcdc6fba91a9" translate="yes" xml:space="preserve">
          <source>XML output from mysqldump includes the XML namespace, as shown here :</source>
          <target state="translated">mysqldump의 XML 출력에는 다음과 같이 XML 네임 스페이스가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="008dfa914b2a1e8af723d7d4d7c8c4b698dfd344" translate="yes" xml:space="preserve">
          <source>XML, Langage et Applications</source>
          <target state="translated">XML, Langage et Applications</target>
        </trans-unit>
        <trans-unit id="9e580c049acbffa737fcf16ab3d4d04fdfff5739" translate="yes" xml:space="preserve">
          <source>XML/JSON</source>
          <target state="translated">XML/JSON</target>
        </trans-unit>
        <trans-unit id="04e41391d608ebb7cc129b9f95ede0ddc5173b69" translate="yes" xml:space="preserve">
          <source>XOR</source>
          <target state="translated">XOR</target>
        </trans-unit>
        <trans-unit id="f05aa9750af20b837be622b29c8b06906231b9ba" translate="yes" xml:space="preserve">
          <source>XOR stands for eXclusive OR. Returns NULL if either operand is NULL. For non-NULL operands, evaluates to 1 if an odd number of operands is non-zero, otherwise 0 is returned.</source>
          <target state="translated">XOR은 eXclusive OR의 약자입니다. 피연산자 중 하나가 NULL이면 NULL을 반환합니다. NULL이 아닌 피연산자의 경우 홀수 피연산자가 0이 아닌 경우 1로 평가되고 그렇지 않으면 0이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="68491e7e60849f2822a37b4c5292cf78ea171b56" translate="yes" xml:space="preserve">
          <source>XOR()</source>
          <target state="translated">XOR()</target>
        </trans-unit>
        <trans-unit id="83e8f2ae22f9b8661bbd131541118576a8dd93da" translate="yes" xml:space="preserve">
          <source>XTRABACKUP PARAMETERS</source>
          <target state="translated">XTRABACKUP 매개 변수</target>
        </trans-unit>
        <trans-unit id="198987235c75326d666ec1624b791d0c6ad2df03" translate="yes" xml:space="preserve">
          <source>Xact Log Bytes In</source>
          <target state="translated">Xact 로그 바이트</target>
        </trans-unit>
        <trans-unit id="e08277a160de420a803a7b972d5efceb84c17894" translate="yes" xml:space="preserve">
          <source>Xact Log Bytes Out</source>
          <target state="translated">Xact 로그 바이트 아웃</target>
        </trans-unit>
        <trans-unit id="1aa352a456d734d5226a929f17adb51494e1c643" translate="yes" xml:space="preserve">
          <source>Xact Log Cache Hits</source>
          <target state="translated">Xact 로그 캐시 적중</target>
        </trans-unit>
        <trans-unit id="cbad439d5c9fb8261fb0ae9e7ce47ea8ccf8c80f" translate="yes" xml:space="preserve">
          <source>Xact Log Cache Misses</source>
          <target state="translated">Xact 로그 캐시 누락</target>
        </trans-unit>
        <trans-unit id="740ac16ed78a0a454eabfe1883cd48746cc4321a" translate="yes" xml:space="preserve">
          <source>Xact Log Cache Usage</source>
          <target state="translated">Xact 로그 캐시 사용법</target>
        </trans-unit>
        <trans-unit id="92308aff352032b344c97f38dd4b4cead3306099" translate="yes" xml:space="preserve">
          <source>Xact Log File Syncs</source>
          <target state="translated">Xact 로그 파일 동기화</target>
        </trans-unit>
        <trans-unit id="fefef567661108ccfdbea51c0edd0e28d6ff61bd" translate="yes" xml:space="preserve">
          <source>Xact Log Sync Time</source>
          <target state="translated">Xact 로그 동기화 시간</target>
        </trans-unit>
        <trans-unit id="a591d7331aaded541f100208cd6cf0a9e9a98928" translate="yes" xml:space="preserve">
          <source>Xan</source>
          <target state="translated">Xan</target>
        </trans-unit>
        <trans-unit id="26a7c257f7e3f6cebc0cba00291078bccd2c0ff5" translate="yes" xml:space="preserve">
          <source>Xeon E31270 / Asus P8BWS desktop (16GB ECC RAM)</source>
          <target state="translated">Xeon E31270 / Asus P8BWS 데스크톱 (16GB ECC RAM)</target>
        </trans-unit>
        <trans-unit id="2b018cbb6697d8c431483a98997a50096e99b84e" translate="yes" xml:space="preserve">
          <source>Xpath is used by XML to locate and retrieve nodes. The table's main node Xpath is specified by the &lt;code&gt;tabname&lt;/code&gt; option. If just the node name is given, CONNECT constructs an Xpath such as &lt;code&gt;&amp;lsquo;&lt;em&gt;BIBLIO&amp;rsquo;&lt;/em&gt;&lt;/code&gt; in the example above that should retrieve the &lt;code&gt;BIBLIO&lt;/code&gt; node wherever it is within the XML file.</source>
          <target state="translated">Xpath는 XML에서 노드를 찾고 검색하는 데 사용됩니다. 테이블의 기본 노드 Xpath는 &lt;code&gt;tabname&lt;/code&gt; 옵션으로 지정됩니다 . 노드 이름 만 지정하면 CONNECT는 위의 예에서 &lt;code&gt;&amp;lsquo;&lt;em&gt;BIBLIO&amp;rsquo;&lt;/em&gt;&lt;/code&gt; 와 같은 Xpath를 구성 하여 XML 파일 내에서 &lt;code&gt;BIBLIO&lt;/code&gt; 노드를 검색해야 합니다.</target>
        </trans-unit>
        <trans-unit id="6ace67cee91c76907616cf06509f69d33dc8648e" translate="yes" xml:space="preserve">
          <source>Xpath/Jpath</source>
          <target state="translated">Xpath/Jpath</target>
        </trans-unit>
        <trans-unit id="8c1ac8b7a032081767702e5d663d6ed2338a3ed7" translate="yes" xml:space="preserve">
          <source>Xps</source>
          <target state="translated">Xps</target>
        </trans-unit>
        <trans-unit id="ae95b1b7067256704c0800dbb3b5dfed3be03f71" translate="yes" xml:space="preserve">
          <source>Xsp</source>
          <target state="translated">Xsp</target>
        </trans-unit>
        <trans-unit id="9e61cb0cb3690538ad42ec7a04a64e8c17c748bf" translate="yes" xml:space="preserve">
          <source>XtraDB Versions</source>
          <target state="translated">XtraDB 버전</target>
        </trans-unit>
        <trans-unit id="a7727256281e3e131e915dfc2468376e0444375a" translate="yes" xml:space="preserve">
          <source>XtraDB buffer pool blob pages.</source>
          <target state="translated">XtraDB 버퍼 풀 BLOB 페이지.</target>
        </trans-unit>
        <trans-unit id="01434843f60225423c9ac875c1331817a8e30a33" translate="yes" xml:space="preserve">
          <source>XtraDB buffer pool index pages.</source>
          <target state="translated">XtraDB 버퍼 풀 색인 페이지.</target>
        </trans-unit>
        <trans-unit id="7047efba3e4ee590a008e32ca7a0f087c7a3b4db" translate="yes" xml:space="preserve">
          <source>XtraDB buffer pool page information.</source>
          <target state="translated">XtraDB 버퍼 풀 페이지 정보.</target>
        </trans-unit>
        <trans-unit id="fd7de106bd98457f39efecf7e28f6257c618f74b" translate="yes" xml:space="preserve">
          <source>XtraDB from &lt;a href=&quot;http://www.percona.com/doc/percona-server/5.5/release-notes/Percona-Server-5.5.32-31.0.html&quot;&gt;Percona Server-5.5.32-31.0&lt;/a&gt; in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5532-release-notes/&quot;&gt;MariaDB 5.5.32&lt;/a&gt;</source>
          <target state="translated">XtraDB에서 &lt;a href=&quot;http://www.percona.com/doc/percona-server/5.5/release-notes/Percona-Server-5.5.32-31.0.html&quot;&gt;Percona 서버 5.5.32-31.0&lt;/a&gt; 에서 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5532-release-notes/&quot;&gt;MariaDB 5.5.32&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="da8cea32e94eec7e437161899a970d685afd776b" translate="yes" xml:space="preserve">
          <source>XtraDB from &lt;a href=&quot;http://www.percona.com/doc/percona-server/5.5/release-notes/Percona-Server-5.5.33-31.1.html&quot;&gt;Percona Server 5.5.33-31.1&lt;/a&gt; in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5533-release-notes/&quot;&gt;MariaDB 5.5.33&lt;/a&gt;</source>
          <target state="translated">에서 XtraDB &lt;a href=&quot;http://www.percona.com/doc/percona-server/5.5/release-notes/Percona-Server-5.5.33-31.1.html&quot;&gt;Percona 서버 5.5.33-31.1&lt;/a&gt; 에서 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5533-release-notes/&quot;&gt;MariaDB 5.5.33&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5e21ec2cb5673829bc980c433796c061068a4350" translate="yes" xml:space="preserve">
          <source>XtraDB from &lt;a href=&quot;http://www.percona.com/doc/percona-server/5.5/release-notes/Percona-Server-5.5.34-32.0.html&quot;&gt;Percona Server 5.5.34-32.0&lt;/a&gt; in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5534-release-notes/&quot;&gt;MariaDB 5.5.34&lt;/a&gt;</source>
          <target state="translated">에서 XtraDB &lt;a href=&quot;http://www.percona.com/doc/percona-server/5.5/release-notes/Percona-Server-5.5.34-32.0.html&quot;&gt;Percona 서버 5.5.34-32.0&lt;/a&gt; 에서 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5534-release-notes/&quot;&gt;MariaDB 5.5.34&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7b0c0341614f0c9af5601a0e2a3524fcea1306a0" translate="yes" xml:space="preserve">
          <source>XtraDB from &lt;a href=&quot;http://www.percona.com/doc/percona-server/5.5/release-notes/Percona-Server-5.5.35-33.0.html&quot;&gt;Percona Server 5.5.35-33.0&lt;/a&gt; in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5535-release-notes/&quot;&gt;MariaDB 5.5.35&lt;/a&gt;</source>
          <target state="translated">에서 XtraDB &lt;a href=&quot;http://www.percona.com/doc/percona-server/5.5/release-notes/Percona-Server-5.5.35-33.0.html&quot;&gt;Percona 서버 5.5.35-33.0&lt;/a&gt; 에서 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5535-release-notes/&quot;&gt;MariaDB 5.5.35&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3d8384fdef8da6ead1ec37bfe31664096adc17cf" translate="yes" xml:space="preserve">
          <source>XtraDB from &lt;a href=&quot;http://www.percona.com/doc/percona-server/5.5/release-notes/Percona-Server-5.5.36-34.0.html&quot;&gt;Percona Server 5.5.36-34.0&lt;/a&gt; in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5537-release-notes/&quot;&gt;MariaDB 5.5.37&lt;/a&gt;</source>
          <target state="translated">에서 XtraDB &lt;a href=&quot;http://www.percona.com/doc/percona-server/5.5/release-notes/Percona-Server-5.5.36-34.0.html&quot;&gt;Percona 서버 5.5.36-34.0&lt;/a&gt; 에서 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5537-release-notes/&quot;&gt;MariaDB 5.5.37&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3b9f5e07b975ca75fbd1cb3e447a49c69fba09a6" translate="yes" xml:space="preserve">
          <source>XtraDB from &lt;a href=&quot;http://www.percona.com/doc/percona-server/5.5/release-notes/Percona-Server-5.5.37-35.0.html&quot;&gt;Percona Server 5.5.37-35.0&lt;/a&gt; in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5538-release-notes/&quot;&gt;MariaDB 5.5.38&lt;/a&gt;</source>
          <target state="translated">에서 XtraDB &lt;a href=&quot;http://www.percona.com/doc/percona-server/5.5/release-notes/Percona-Server-5.5.37-35.0.html&quot;&gt;Percona 서버 5.5.37-35.0&lt;/a&gt; 에서 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5538-release-notes/&quot;&gt;MariaDB 5.5.38&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4be49419cb50e5249f442ec3abd262909171be8b" translate="yes" xml:space="preserve">
          <source>XtraDB from &lt;a href=&quot;http://www.percona.com/doc/percona-server/5.5/release-notes/Percona-Server-5.5.38-35.2.html&quot;&gt;Percona Server 5.5.38-35.2&lt;/a&gt; in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5539-release-notes/&quot;&gt;MariaDB 5.5.39&lt;/a&gt;</source>
          <target state="translated">에서 XtraDB &lt;a href=&quot;http://www.percona.com/doc/percona-server/5.5/release-notes/Percona-Server-5.5.38-35.2.html&quot;&gt;Percona 서버 5.5.38-35.2&lt;/a&gt; 에서 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5539-release-notes/&quot;&gt;MariaDB 5.5.39&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6edaf941ad1b70e62eac51c747113b8edecd085c" translate="yes" xml:space="preserve">
          <source>XtraDB from &lt;a href=&quot;http://www.percona.com/doc/percona-server/5.5/release-notes/Percona-Server-5.5.40-36.1.html&quot;&gt;Percona Server 5.5.40-36.1&lt;/a&gt; in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5540-release-notes/&quot;&gt;MariaDB 5.5.40&lt;/a&gt;</source>
          <target state="translated">에서 XtraDB &lt;a href=&quot;http://www.percona.com/doc/percona-server/5.5/release-notes/Percona-Server-5.5.40-36.1.html&quot;&gt;Percona 서버 5.5.40-36.1&lt;/a&gt; 에서 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5540-release-notes/&quot;&gt;MariaDB 5.5.40&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dba1b14784db5274c4a8462b59a2bb1ec49f4326" translate="yes" xml:space="preserve">
          <source>XtraDB from &lt;a href=&quot;http://www.percona.com/doc/percona-server/5.5/release-notes/Percona-Server-5.5.42-37.1.html&quot;&gt;Percona Server 5.5.42-37.1&lt;/a&gt; in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5543-release-notes/&quot;&gt;MariaDB 5.5.43&lt;/a&gt;</source>
          <target state="translated">에서 XtraDB &lt;a href=&quot;http://www.percona.com/doc/percona-server/5.5/release-notes/Percona-Server-5.5.42-37.1.html&quot;&gt;Percona 서버 5.5.42-37.1&lt;/a&gt; 에서 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5543-release-notes/&quot;&gt;MariaDB 5.5.43&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f71b7905d9f61b18473f23ca53fcd7deddedf628" translate="yes" xml:space="preserve">
          <source>XtraDB from &lt;a href=&quot;http://www.percona.com/doc/percona-server/5.5/release-notes/Percona-Server-5.5.42-37.2.html&quot;&gt;Percona Server 5.5.42-37.2&lt;/a&gt; in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5544-release-notes/&quot;&gt;MariaDB 5.5.44&lt;/a&gt;</source>
          <target state="translated">에서 XtraDB &lt;a href=&quot;http://www.percona.com/doc/percona-server/5.5/release-notes/Percona-Server-5.5.42-37.2.html&quot;&gt;Percona 서버 5.5.42-37.2&lt;/a&gt; 에서 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5544-release-notes/&quot;&gt;MariaDB 5.5.44&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="09ac43bc100d13d23f9d1af8d6bbb028691770c2" translate="yes" xml:space="preserve">
          <source>XtraDB from &lt;a href=&quot;http://www.percona.com/doc/percona-server/5.5/release-notes/Percona-Server-5.5.44-37.3.html&quot;&gt;Percona Server 5.5.44-37.3&lt;/a&gt; in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5545-release-notes/&quot;&gt;MariaDB 5.5.45&lt;/a&gt;</source>
          <target state="translated">에서 XtraDB &lt;a href=&quot;http://www.percona.com/doc/percona-server/5.5/release-notes/Percona-Server-5.5.44-37.3.html&quot;&gt;Percona 서버 5.5.44-37.3&lt;/a&gt; 에서 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5545-release-notes/&quot;&gt;MariaDB 5.5.45&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1141c0e2d948297fd53b316201872dd648d44389" translate="yes" xml:space="preserve">
          <source>XtraDB from &lt;a href=&quot;http://www.percona.com/doc/percona-server/5.5/release-notes/Percona-Server-5.5.45-37.4.html&quot;&gt;Percona Server 5.5.45-37.4&lt;/a&gt; in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5546-release-notes/&quot;&gt;MariaDB 5.5.46&lt;/a&gt;</source>
          <target state="translated">에서 XtraDB &lt;a href=&quot;http://www.percona.com/doc/percona-server/5.5/release-notes/Percona-Server-5.5.45-37.4.html&quot;&gt;Percona 서버 5.5.45-37.4&lt;/a&gt; 에서 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5546-release-notes/&quot;&gt;MariaDB 5.5.46&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e0ceecf2e05d617fddb58270687225e115eeca81" translate="yes" xml:space="preserve">
          <source>XtraDB from &lt;a href=&quot;http://www.percona.com/doc/percona-server/5.5/release-notes/Percona-Server-5.5.46-37.6.html&quot;&gt;Percona Server 5.5.46-37.6&lt;/a&gt; in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5547-release-notes/&quot;&gt;MariaDB 5.5.47&lt;/a&gt;</source>
          <target state="translated">에서 XtraDB &lt;a href=&quot;http://www.percona.com/doc/percona-server/5.5/release-notes/Percona-Server-5.5.46-37.6.html&quot;&gt;Percona 서버 5.5.46-37.6&lt;/a&gt; 에서 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5547-release-notes/&quot;&gt;MariaDB 5.5.47&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="01e1c6bede6551edded904f3e11ab85db0f54190" translate="yes" xml:space="preserve">
          <source>XtraDB from &lt;a href=&quot;http://www.percona.com/doc/percona-server/5.5/release-notes/Percona-Server-5.5.46-37.7.html&quot;&gt;Percona Server 5.5.46-37.7&lt;/a&gt; in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5548-release-notes/&quot;&gt;MariaDB 5.5.48&lt;/a&gt;</source>
          <target state="translated">에서 XtraDB &lt;a href=&quot;http://www.percona.com/doc/percona-server/5.5/release-notes/Percona-Server-5.5.46-37.7.html&quot;&gt;Percona 서버 5.5.46-37.7&lt;/a&gt; 에서 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5548-release-notes/&quot;&gt;MariaDB 5.5.48&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c334af8d7529d84db7c6c40c3e56c834c1b3d754" translate="yes" xml:space="preserve">
          <source>XtraDB from &lt;a href=&quot;http://www.percona.com/doc/percona-server/5.5/release-notes/Percona-Server-5.5.48-37.8.html&quot;&gt;Percona Server 5.5.48-37.8&lt;/a&gt; in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5549-release-notes/&quot;&gt;MariaDB 5.5.49&lt;/a&gt;</source>
          <target state="translated">에서 XtraDB &lt;a href=&quot;http://www.percona.com/doc/percona-server/5.5/release-notes/Percona-Server-5.5.48-37.8.html&quot;&gt;Percona 서버 5.5.48-37.8&lt;/a&gt; 에서 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5549-release-notes/&quot;&gt;MariaDB 5.5.49&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d8b3933545550b57d66efd644d0024b2e8193ba8" translate="yes" xml:space="preserve">
          <source>XtraDB from &lt;a href=&quot;http://www.percona.com/doc/percona-server/5.5/release-notes/Percona-Server-5.5.49-37.9.html&quot;&gt;Percona Server 5.5.49-37.9&lt;/a&gt; in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5550-release-notes/&quot;&gt;MariaDB 5.5.50&lt;/a&gt;</source>
          <target state="translated">에서 XtraDB &lt;a href=&quot;http://www.percona.com/doc/percona-server/5.5/release-notes/Percona-Server-5.5.49-37.9.html&quot;&gt;Percona 서버 5.5.49-37.9&lt;/a&gt; 에서 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5550-release-notes/&quot;&gt;MariaDB 5.5.50&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7462a5e0a1456bcb4a7c0f10db8c80d66d50f7cc" translate="yes" xml:space="preserve">
          <source>XtraDB from &lt;a href=&quot;http://www.percona.com/doc/percona-server/5.5/release-notes/Percona-Server-5.5.50-38.0.html&quot;&gt;Percona Server 5.5.50-38.0&lt;/a&gt; in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5551-release-notes/&quot;&gt;MariaDB 5.5.51&lt;/a&gt;</source>
          <target state="translated">에서 XtraDB &lt;a href=&quot;http://www.percona.com/doc/percona-server/5.5/release-notes/Percona-Server-5.5.50-38.0.html&quot;&gt;Percona 서버 5.5.50-38.0&lt;/a&gt; 에서 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5551-release-notes/&quot;&gt;MariaDB 5.5.51&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="74a005a592de89111a5be3376389c6b5d0330586" translate="yes" xml:space="preserve">
          <source>XtraDB from &lt;a href=&quot;http://www.percona.com/doc/percona-server/5.5/release-notes/Percona-Server-5.5.52-38.3.html&quot;&gt;Percona Server 5.5.52-38.3&lt;/a&gt; in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5553-release-notes/&quot;&gt;MariaDB 5.5.53&lt;/a&gt;</source>
          <target state="translated">에서 XtraDB &lt;a href=&quot;http://www.percona.com/doc/percona-server/5.5/release-notes/Percona-Server-5.5.52-38.3.html&quot;&gt;Percona 서버 5.5.52-38.3&lt;/a&gt; 에서 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5553-release-notes/&quot;&gt;MariaDB 5.5.53&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="466c53d8d8e6283f3d8a1d730873b4d81256d0d8" translate="yes" xml:space="preserve">
          <source>XtraDB from &lt;a href=&quot;http://www.percona.com/doc/percona-server/5.5/release-notes/Percona-Server-5.5.55-38.8.html&quot;&gt;Percona Server 5.5.55-38.8&lt;/a&gt; in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5557-release-notes/&quot;&gt;MariaDB 5.5.57&lt;/a&gt;</source>
          <target state="translated">에서 XtraDB &lt;a href=&quot;http://www.percona.com/doc/percona-server/5.5/release-notes/Percona-Server-5.5.55-38.8.html&quot;&gt;Percona 서버 5.5.55-38.8&lt;/a&gt; 에서 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5557-release-notes/&quot;&gt;MariaDB 5.5.57&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="713baad668a0fe3971c17d0bcfced4010a530953" translate="yes" xml:space="preserve">
          <source>XtraDB from &lt;a href=&quot;http://www.percona.com/doc/percona-server/5.5/release-notes/Percona-Server-5.5.55-38.9.html&quot;&gt;Percona Server 5.5.55-38.9&lt;/a&gt; in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5558-release-notes/&quot;&gt;MariaDB 5.5.58&lt;/a&gt;</source>
          <target state="translated">에서 XtraDB &lt;a href=&quot;http://www.percona.com/doc/percona-server/5.5/release-notes/Percona-Server-5.5.55-38.9.html&quot;&gt;Percona 서버 5.5.55-38.9&lt;/a&gt; 에서 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5558-release-notes/&quot;&gt;MariaDB 5.5.58&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b5fe305eee280622a65e57eb5e68b0101f1a59bd" translate="yes" xml:space="preserve">
          <source>XtraDB from &lt;a href=&quot;http://www.percona.com/doc/percona-server/5.5/release-notes/Percona-Server-5.5.58-38.10.html&quot;&gt;Percona Server 5.5.58-38.10&lt;/a&gt; in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5559-release-notes/&quot;&gt;MariaDB 5.5.59&lt;/a&gt;</source>
          <target state="translated">에서 XtraDB &lt;a href=&quot;http://www.percona.com/doc/percona-server/5.5/release-notes/Percona-Server-5.5.58-38.10.html&quot;&gt;Percona 서버 5.5.58-38.10&lt;/a&gt; 에서 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5559-release-notes/&quot;&gt;MariaDB 5.5.59&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="edbb250553086d76559d855922d38e5c103d4beb" translate="yes" xml:space="preserve">
          <source>XtraDB from &lt;a href=&quot;http://www.percona.com/doc/percona-server/5.5/release-notes/Percona-Server-5.5.59-38.11.html&quot;&gt;Percona Server 5.5.59-38.11&lt;/a&gt; in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5560-release-notes/&quot;&gt;MariaDB 5.5.60&lt;/a&gt;</source>
          <target state="translated">에서 XtraDB &lt;a href=&quot;http://www.percona.com/doc/percona-server/5.5/release-notes/Percona-Server-5.5.59-38.11.html&quot;&gt;Percona 서버 5.5.59-38.11&lt;/a&gt; 에서 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5560-release-notes/&quot;&gt;MariaDB 5.5.60&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cd7d0653d7eb0087143c503ced36a4bb890533ed" translate="yes" xml:space="preserve">
          <source>XtraDB from &lt;a href=&quot;http://www.percona.com/doc/percona-server/5.5/release-notes/Percona-Server-5.5.61-38.13.html&quot;&gt;Percona Server 5.5.61-38.13&lt;/a&gt; in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5562-release-notes/&quot;&gt;MariaDB 5.5.62&lt;/a&gt;</source>
          <target state="translated">에서 XtraDB &lt;a href=&quot;http://www.percona.com/doc/percona-server/5.5/release-notes/Percona-Server-5.5.61-38.13.html&quot;&gt;Percona 서버 5.5.61-38.13&lt;/a&gt; 에서 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5562-release-notes/&quot;&gt;MariaDB 5.5.62&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="748dda1e0b75ec1881dfff372cd807280a0c2a67" translate="yes" xml:space="preserve">
          <source>XtraDB from &lt;a href=&quot;http://www.percona.com/doc/percona-server/5.6/release-notes/Percona-Server-5.6.14-62.0.html&quot;&gt;Percona Server 5.6.14-rel62.0&lt;/a&gt; in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1007-release-notes/&quot;&gt;MariaDB 10.0.7&lt;/a&gt;</source>
          <target state="translated">에서 XtraDB &lt;a href=&quot;http://www.percona.com/doc/percona-server/5.6/release-notes/Percona-Server-5.6.14-62.0.html&quot;&gt;Percona 서버는 5.6.14-rel62.0&lt;/a&gt; 에서 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1007-release-notes/&quot;&gt;MariaDB 10.0.7&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="15432e6f0fa9af3023dec2b0193e26b088c5004e" translate="yes" xml:space="preserve">
          <source>XtraDB from &lt;a href=&quot;http://www.percona.com/doc/percona-server/5.6/release-notes/Percona-Server-5.6.17-65.0.html&quot;&gt;Percona Server 5.6.17-65.0&lt;/a&gt; in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10011-release-notes/&quot;&gt;MariaDB 10.0.11&lt;/a&gt;</source>
          <target state="translated">XtraDB에서 &lt;a href=&quot;http://www.percona.com/doc/percona-server/5.6/release-notes/Percona-Server-5.6.17-65.0.html&quot;&gt;Percona 서버 5.6.17-65.0&lt;/a&gt; 에서 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10011-release-notes/&quot;&gt;MariaDB 10.0.11&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="caac80d0a78516c2abfd7b24a41584db0e83bb2f" translate="yes" xml:space="preserve">
          <source>XtraDB from &lt;a href=&quot;http://www.percona.com/doc/percona-server/5.6/release-notes/Percona-Server-5.6.17-65.0.html&quot;&gt;Percona Server 5.6.17-65.0&lt;/a&gt; in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1011-release-notes/&quot;&gt;MariaDB 10.1.1&lt;/a&gt;</source>
          <target state="translated">XtraDB에서 &lt;a href=&quot;http://www.percona.com/doc/percona-server/5.6/release-notes/Percona-Server-5.6.17-65.0.html&quot;&gt;Percona 서버 5.6.17-65.0&lt;/a&gt; 에서 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1011-release-notes/&quot;&gt;MariaDB 10.1.1&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="12e65c86b85f04f3d9e05b23ed3ec9b5cd276264" translate="yes" xml:space="preserve">
          <source>XtraDB from &lt;a href=&quot;http://www.percona.com/doc/percona-server/5.6/release-notes/Percona-Server-5.6.19-67.0.html&quot;&gt;Percona Server 5.6.19-67.0&lt;/a&gt; in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10013-release-notes/&quot;&gt;MariaDB 10.0.13&lt;/a&gt;</source>
          <target state="translated">XtraDB에서 &lt;a href=&quot;http://www.percona.com/doc/percona-server/5.6/release-notes/Percona-Server-5.6.19-67.0.html&quot;&gt;Percona 서버 5.6.19-67.0&lt;/a&gt; 에서 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10013-release-notes/&quot;&gt;MariaDB 10.0.13&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="adf2025d32d25fc43dd22fcc07190ca35ad9a981" translate="yes" xml:space="preserve">
          <source>XtraDB from &lt;a href=&quot;http://www.percona.com/doc/percona-server/5.6/release-notes/Percona-Server-5.6.20-68.0.html&quot;&gt;Percona Server 5.6.20-68.0&lt;/a&gt; in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10014-release-notes/&quot;&gt;MariaDB 10.0.14&lt;/a&gt;</source>
          <target state="translated">XtraDB에서 &lt;a href=&quot;http://www.percona.com/doc/percona-server/5.6/release-notes/Percona-Server-5.6.20-68.0.html&quot;&gt;Percona 서버 5.6.20-68.0&lt;/a&gt; 에서 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10014-release-notes/&quot;&gt;MariaDB 10.0.14&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="65414d910409f40b516b3e269477b97151fd7312" translate="yes" xml:space="preserve">
          <source>XtraDB from &lt;a href=&quot;http://www.percona.com/doc/percona-server/5.6/release-notes/Percona-Server-5.6.21-70.0.html&quot;&gt;Percona Server 5.6.21-70.0&lt;/a&gt; in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10015-release-notes/&quot;&gt;MariaDB 10.0.15&lt;/a&gt;</source>
          <target state="translated">XtraDB에서 &lt;a href=&quot;http://www.percona.com/doc/percona-server/5.6/release-notes/Percona-Server-5.6.21-70.0.html&quot;&gt;Percona 서버 5.6.21-70.0&lt;/a&gt; 에서 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10015-release-notes/&quot;&gt;MariaDB 10.0.15&lt;/a&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
