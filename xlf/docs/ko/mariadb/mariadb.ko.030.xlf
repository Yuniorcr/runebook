<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="mariadb">
    <body>
      <group id="mariadb">
        <trans-unit id="bfa60cfd7d8de9fc07227fcef5e390868fa8f82a" translate="yes" xml:space="preserve">
          <source>New &lt;a href=&quot;../reserved-words/index&quot;&gt;reserved words&lt;/a&gt;: OVER, RECURSIVE and ROWS. These can no longer be used as &lt;a href=&quot;../identifier-names/index&quot;&gt;identifiers&lt;/a&gt; without being quoted.</source>
          <target state="translated">새로운 &lt;a href=&quot;../reserved-words/index&quot;&gt;예약어&lt;/a&gt; : OVER, RECURSIVE 및 ROWS. 더 이상 인용 부호없이 &lt;a href=&quot;../identifier-names/index&quot;&gt;식별자&lt;/a&gt; 로 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="3b86ad07fd4c8224f2de9cb42ec2a2e8f7253eeb" translate="yes" xml:space="preserve">
          <source>New Entries in Start Menu</source>
          <target state="translated">시작 메뉴의 새로운 항목</target>
        </trans-unit>
        <trans-unit id="dd4e81ef0bbcc2f076489d01d464eb42c935bcec" translate="yes" xml:space="preserve">
          <source>New Features for mysqltest in MariaDB</source>
          <target state="translated">MariaDB의 mysqltest에 대한 새로운 기능</target>
        </trans-unit>
        <trans-unit id="3fcab399087dc74f0c0f301867fec145252d56d2" translate="yes" xml:space="preserve">
          <source>New Features in the &lt;a href=&quot;../what-is-mariadb-52/index&quot;&gt;MariaDB 5.2&lt;/a&gt; replication feature preview</source>
          <target state="translated">&lt;a href=&quot;../what-is-mariadb-52/index&quot;&gt;MariaDB 5.2&lt;/a&gt; 복제 기능 미리보기 의 새로운 기능</target>
        </trans-unit>
        <trans-unit id="1ae41f6e51827f5ca223627dc43e463a1ac15591" translate="yes" xml:space="preserve">
          <source>New Federated SERVER added to the parser. This was something Cisco needed that made it possible to change the connection parameters for numerous Federated tables at once without having to alter or re-create the Federated tables.</source>
          <target state="translated">새로운 페더 레이 티드 서버가 파서에 추가되었습니다. 이는 연합 테이블을 변경하거나 재 작성할 필요없이 수많은 연합 테이블의 연결 매개 변수를 한 번에 변경할 수있게 해주는 Cisco의 요구였습니다.</target>
        </trans-unit>
        <trans-unit id="9d9bd7970e919aed148031d60868fddee5971058" translate="yes" xml:space="preserve">
          <source>New Files</source>
          <target state="translated">새로운 파일</target>
        </trans-unit>
        <trans-unit id="3508b9d730c0e6c09c0f228a8d134bc3e3fd6e0b" translate="yes" xml:space="preserve">
          <source>New InnoDB tables do not use InnoDB page compression. This is the default value.</source>
          <target state="translated">새로운 InnoDB 테이블은 InnoDB 페이지 압축을 사용하지 않습니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="b4d5e43ecc99f420e4224b17e9512cda31cbee4f" translate="yes" xml:space="preserve">
          <source>New InnoDB tables use InnoDB page compression.</source>
          <target state="translated">새로운 InnoDB 테이블은 InnoDB 페이지 압축을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a9ae505cf75dc5d35122b2a7eb71f01300241c10" translate="yes" xml:space="preserve">
          <source>New Installation and upgrades</source>
          <target state="translated">새로운 설치 및 업그레이드</target>
        </trans-unit>
        <trans-unit id="d22480c433d0f897d3f190f8aae76770e246ac08" translate="yes" xml:space="preserve">
          <source>New Major Features To Consider</source>
          <target state="translated">고려해야 할 새로운 주요 기능</target>
        </trans-unit>
        <trans-unit id="c6f7ae5b2bc1f70be2f3fa04af78d56eba7fb362" translate="yes" xml:space="preserve">
          <source>New Options for CREATE TABLE</source>
          <target state="translated">CREATE TABLE의 새로운 옵션</target>
        </trans-unit>
        <trans-unit id="3268641a7bb7928046f0b40a4f340b953ba95984" translate="yes" xml:space="preserve">
          <source>New Regular Expression Functions</source>
          <target state="translated">새로운 정규식 함수</target>
        </trans-unit>
        <trans-unit id="6dad2daa60e2a59f6d3a1259f9fb11ee581bd33c" translate="yes" xml:space="preserve">
          <source>New SQL document view layout to show query text and retrieved data at the same time</source>
          <target state="translated">쿼리 텍스트와 검색된 데이터를 동시에 표시하는 새로운 SQL 문서보기 레이아웃</target>
        </trans-unit>
        <trans-unit id="d35df19971ca800d3483a2aa3327ac42c97d1796" translate="yes" xml:space="preserve">
          <source>New Session Variables</source>
          <target state="translated">새로운 세션 변수</target>
        </trans-unit>
        <trans-unit id="02a187238899fbb2d018fa7782108cb86ccef602" translate="yes" xml:space="preserve">
          <source>New Status Variables</source>
          <target state="translated">새로운 상태 변수</target>
        </trans-unit>
        <trans-unit id="41fa61a3452cc1957849834a13724c83849e2c1b" translate="yes" xml:space="preserve">
          <source>New Syntax</source>
          <target state="translated">새로운 구문</target>
        </trans-unit>
        <trans-unit id="f1e16c0a4aebdb9929360b9a79a03ccb8a928ae5" translate="yes" xml:space="preserve">
          <source>New Syntax For Global Transaction ID</source>
          <target state="translated">글로벌 트랜잭션 ID의 새로운 구문</target>
        </trans-unit>
        <trans-unit id="d8423b4c47c4aeb98faf2d6e4ac1fdb499f711ec" translate="yes" xml:space="preserve">
          <source>New System Variables</source>
          <target state="translated">새로운 시스템 변수</target>
        </trans-unit>
        <trans-unit id="a2238e91907fa2436a6a50e0fd8cf97ab60ec508" translate="yes" xml:space="preserve">
          <source>New Zealand</source>
          <target state="translated">뉴질랜드</target>
        </trans-unit>
        <trans-unit id="2e6546018d68f2f5a2dff975ccfa667687ad02ff" translate="yes" xml:space="preserve">
          <source>New arguments</source>
          <target state="translated">새로운 논쟁</target>
        </trans-unit>
        <trans-unit id="08d3937e90300993376858a744fb10933d94dd18" translate="yes" xml:space="preserve">
          <source>New class structure which allows developers to write connection classes for other RDBMSs without having to modify base classes for FederatedX</source>
          <target state="translated">개발자가 FederatedX의 기본 클래스를 수정하지 않고도 다른 RDBMS에 대한 연결 클래스를 작성할 수있는 새로운 클래스 구조</target>
        </trans-unit>
        <trans-unit id="5e5783f1a245b19a4898c557bb29e7d00d8a1043" translate="yes" xml:space="preserve">
          <source>New default value</source>
          <target state="translated">새로운 기본값</target>
        </trans-unit>
        <trans-unit id="56d13ddfe1dfd0a76b4635f866b39905790c95f5" translate="yes" xml:space="preserve">
          <source>New error codes are being continually being added as new features are added. For a definitive list, see the file sql/share/errmsg-utf8.txt. Also, the &lt;a href=&quot;../perror/index&quot;&gt;perror&lt;/a&gt; tool can be used to get the error message which is associated with a given error code.</source>
          <target state="translated">새로운 기능이 추가됨에 따라 새로운 오류 코드가 지속적으로 추가되고 있습니다. 결정적인 목록은 sql / share / errmsg-utf8.txt 파일을 참조하십시오. 또한 &lt;a href=&quot;../perror/index&quot;&gt;perror&lt;/a&gt; 도구를 사용하여 주어진 오류 코드와 관련된 오류 메시지를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e6618ac75280e3b070874665792a0c725642b5e" translate="yes" xml:space="preserve">
          <source>New features in FederatedX</source>
          <target state="translated">FederatedX의 새로운 기능</target>
        </trans-unit>
        <trans-unit id="092d4c3ab8a00ba35dbda9490c14c8822ec4d4b5" translate="yes" xml:space="preserve">
          <source>New features in MariaDB you should considering using</source>
          <target state="translated">사용을 고려해야하는 MariaDB의 새로운 기능</target>
        </trans-unit>
        <trans-unit id="f19acb4eb6a242b18fdd60149a45e170ddf2be4a" translate="yes" xml:space="preserve">
          <source>New file setting</source>
          <target state="translated">새로운 파일 설정</target>
        </trans-unit>
        <trans-unit id="396a92ae054a86ac696f09e8b08d91b668d69e45" translate="yes" xml:space="preserve">
          <source>New function added to API (except that two which are representing SQL level functions):</source>
          <target state="translated">새로운 기능이 API에 추가되었습니다 (SQL 레벨 기능을 나타내는 2 개는 제외).</target>
        </trans-unit>
        <trans-unit id="36c26c5df57351c4d8d4b65eecfea922ecbd1c45" translate="yes" xml:space="preserve">
          <source>New functions</source>
          <target state="translated">새로운 기능</target>
        </trans-unit>
        <trans-unit id="97c1c05269675e6566718b1991b6af1289992cf6" translate="yes" xml:space="preserve">
          <source>New global variable: &lt;a href=&quot;../myisam-system-variables/index#key_cache_segments&quot;&gt;key_cache_segments&lt;/a&gt;. This variable sets the number of segments in a key cache. Valid values for this variable are whole numbers between &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;64&lt;/code&gt;. If the number of segments is set to a number greater than &lt;code&gt;64&lt;/code&gt; the number of segments will be truncated to 64 and a warning will be issued.</source>
          <target state="translated">새로운 글로벌 변수 : &lt;a href=&quot;../myisam-system-variables/index#key_cache_segments&quot;&gt;key_cache_segments&lt;/a&gt; . 이 변수는 키 캐시의 세그먼트 수를 설정합니다. 이 변수의 유효한 값은 &lt;code&gt;0&lt;/code&gt; 과 &lt;code&gt;64&lt;/code&gt; 사이의 정수입니다 . 세그먼트 수가 &lt;code&gt;64&lt;/code&gt; 보다 큰 숫자로 설정되면 세그먼트 수가 64 로 잘리고 경고가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="26445874a106cfefa3c07ad7bc5c677499886874" translate="yes" xml:space="preserve">
          <source>New key</source>
          <target state="translated">새로운 열쇠</target>
        </trans-unit>
        <trans-unit id="5d593ae12e67461bca4ee6e0e22e3f696ef5a99b" translate="yes" xml:space="preserve">
          <source>New key management and encryption plugins can be developed using the &lt;a href=&quot;../encryption-plugin-api/index&quot;&gt;encryption plugin API&lt;/a&gt;.</source>
          <target state="translated">새로운 키 관리 및 암호화 플러그인은 &lt;a href=&quot;../encryption-plugin-api/index&quot;&gt;암호화 플러그인 API를&lt;/a&gt; 사용하여 개발할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="10bab2713eef60d9fb4468e28ca1b0486a7fa944" translate="yes" xml:space="preserve">
          <source>New problems are raised when trying to modify the values of an array. Only updates can be done on the original table. First of all, for the values of the array to be distinct values, all update operations concerning array values must be done using a table expanding this array.</source>
          <target state="translated">배열의 값을 수정하려고 할 때 새로운 문제가 발생합니다. 원래 테이블에서는 업데이트 만 수행 할 수 있습니다. 우선, 배열 값이 고유 한 값이 되려면 배열 값과 관련된 모든 업데이트 작업이이 배열을 확장하는 테이블을 사용하여 수행되어야합니다.</target>
        </trans-unit>
        <trans-unit id="b8f6b08365e0d801c06d559ecf56f4e61443ad33" translate="yes" xml:space="preserve">
          <source>New project wizard with import from an existing database</source>
          <target state="translated">기존 데이터베이스에서 가져 오는 새 프로젝트 마법사</target>
        </trans-unit>
        <trans-unit id="77bffa8adffc603d3df6e130689a994853f5da50" translate="yes" xml:space="preserve">
          <source>New relay log files are created by the slave at the following times:</source>
          <target state="translated">다음 시간에 슬레이브가 새 릴레이 로그 파일을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="547fc29180ce0cb6aa665d6405112f0c6ed778f3" translate="yes" xml:space="preserve">
          <source>New reserved word: RETURNING. This can no longer be used as an identifier without being quoted.</source>
          <target state="translated">새로운 예약어 : RETURNING. 더 이상 인용 부호없이 식별자로 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="863185a78de9701ca9cceb7851d7713199f2dd9b" translate="yes" xml:space="preserve">
          <source>New rows are inserted into a compression buffer and are flushed to disk when needed. SELECTs cause a flush. Sometimes, rows created by multi-row inserts are not visible until the statement is complete.</source>
          <target state="translated">새 행이 압축 버퍼에 삽입되고 필요할 때 디스크로 플러시됩니다. SELECT는 플러시를 유발합니다. 다중 행 삽입으로 작성된 행은 명령문이 완료 될 때까지 표시되지 않는 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="65fde6ee7c166eccd5df1414495f8cd94f3bf9a2" translate="yes" xml:space="preserve">
          <source>New status variables:</source>
          <target state="translated">새로운 상태 변수 :</target>
        </trans-unit>
        <trans-unit id="078f57f25e57c200c9251b71200340c1823ae233" translate="yes" xml:space="preserve">
          <source>New table state is being saved. For example, after, analyzing a &lt;a href=&quot;../myisam/index&quot;&gt;MyISAM&lt;/a&gt; table, the key distributions, rowcount etc. are saved to the .MYI file.</source>
          <target state="translated">새로운 테이블 상태가 저장되고 있습니다. 예를 들어, &lt;a href=&quot;../myisam/index&quot;&gt;MyISAM&lt;/a&gt; 테이블을 분석 한 후 키 분배, 행 개수 등이 .MYI 파일에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="30f10178a8575ef8206a81b66314e220c9e26ca4" translate="yes" xml:space="preserve">
          <source>New type of &quot;dynamic column&quot; row added on the API level (in SQL level output it is a string but if you use dynamic column functions to construct object it will be added as dynamic column value) which allow to add dynamic columns inside dynamic columns. JSON function represent such recursive constructions correctly but limit depth of representation as current implementation limit (internally depth of dynamic columns embedding is not limited).</source>
          <target state="translated">API 레벨에 추가 된 새로운 유형의 &quot;동적 컬럼&quot;행 (SQL 레벨 출력에서는 문자열이지만 동적 컬럼 함수를 사용하여 오브젝트를 구성하는 경우 동적 컬럼 값으로 추가됨)을 통해 동적 컬럼 내부에 동적 컬럼을 추가 할 수 있음 . JSON 함수는 이러한 재귀 적 구성을 올바르게 표현하지만 표현 깊이를 현재 구현 제한으로 제한합니다 (내부 동적 열 깊이 포함은 제한되지 않음).</target>
        </trans-unit>
        <trans-unit id="520d572d79925b3c142bc37274e943736c2b6902" translate="yes" xml:space="preserve">
          <source>New value</source>
          <target state="translated">새로운 가치</target>
        </trans-unit>
        <trans-unit id="07ae619fc25a209a602651a4c1849574e42aea65" translate="yes" xml:space="preserve">
          <source>Newer MariaDB servers include Galera by default. To build the database server, &lt;em&gt;cd&lt;/em&gt; into the &lt;em&gt;server/ &lt;/em&gt; directory and run the following commands:</source>
          <target state="translated">최신 MariaDB 서버에는 기본적으로 Galera가 포함되어 있습니다. 데이터베이스 서버를 빌드하려면 &lt;em&gt;server /&lt;/em&gt; 디렉토리 로 &lt;em&gt;cd&lt;/em&gt; 하고 다음 명령을 실행하십시오.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="11934b7a4b563e831d0847c9bcee5616c5d4d7d6" translate="yes" xml:space="preserve">
          <source>Newer versions of PAM do not have this limitation, so you may want to try upgrading your version of PAM to see if that fixes the issue.</source>
          <target state="translated">최신 버전의 PAM에는이 제한이 없으므로 PAM 버전을 업그레이드하여 문제가 해결되는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c74a3327a316567254d65964c13353afc3f547d" translate="yes" xml:space="preserve">
          <source>Newline (linefeed)</source>
          <target state="translated">줄 바꿈 (줄 바꿈)</target>
        </trans-unit>
        <trans-unit id="dba756b5f947439adb330302ac31ae7a6213869f" translate="yes" xml:space="preserve">
          <source>Newline Conventions</source>
          <target state="translated">개행 규칙</target>
        </trans-unit>
        <trans-unit id="f1a85b536d7bdffdb40ccc9bb8f9cced772ec9f9" translate="yes" xml:space="preserve">
          <source>Newline Sequences</source>
          <target state="translated">줄 바꿈 시퀀스</target>
        </trans-unit>
        <trans-unit id="34083630b366c431bb605ad47febbb6e45b56fdc" translate="yes" xml:space="preserve">
          <source>Newline, or linefeed,.</source>
          <target state="translated">줄 바꿈 또는 줄 바꿈.</target>
        </trans-unit>
        <trans-unit id="2f0ae5aa026b96521e203553befccaba0be60fbd" translate="yes" xml:space="preserve">
          <source>Newly added fulltext row information.</source>
          <target state="translated">전체 텍스트 행 정보가 새로 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="76647ae3bed0f244f45be899e4edfddb731c2149" translate="yes" xml:space="preserve">
          <source>Next &lt;a href=&quot;../auto_increment/index&quot;&gt;AUTO_INCREMENT&lt;/a&gt; value.</source>
          <target state="translated">다음 &lt;a href=&quot;../auto_increment/index&quot;&gt;AUTO_INCREMENT&lt;/a&gt; 값.</target>
        </trans-unit>
        <trans-unit id="4b9e595ff157546139368ecb61043c5ae88a247a" translate="yes" xml:space="preserve">
          <source>Next &lt;code&gt;&lt;a href=&quot;../auto_increment/index&quot;&gt;AUTO_INCREMENT&lt;/a&gt;&lt;/code&gt; value.</source>
          <target state="translated">다음 &lt;code&gt;&lt;a href=&quot;../auto_increment/index&quot;&gt;AUTO_INCREMENT&lt;/a&gt;&lt;/code&gt; 값.</target>
        </trans-unit>
        <trans-unit id="26a0dc7a422d6b69e751b92ab828246f1cbb94fb" translate="yes" xml:space="preserve">
          <source>Next create a file MCSAPITest.java with the following contents:</source>
          <target state="translated">다음 내용으로 MCSAPITest.java 파일을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="8f94a472105b07db818ccf9abe0ebcb375879cee" translate="yes" xml:space="preserve">
          <source>Next month a recurring event will be triggered hourly for a week:</source>
          <target state="translated">다음 달 반복 이벤트가 일주일 동안 매시간 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="7d26f16f6facb401f085acf3c326bc31f2555bbd" translate="yes" xml:space="preserve">
          <source>Next page number.</source>
          <target state="translated">다음 페이지 번호.</target>
        </trans-unit>
        <trans-unit id="11fc14203dd0f4441645a9c34d5dd022905f56e4" translate="yes" xml:space="preserve">
          <source>Next steps</source>
          <target state="translated">다음 단계</target>
        </trans-unit>
        <trans-unit id="33988ac26841ba15d4c60e7197729d2318c07e47" translate="yes" xml:space="preserve">
          <source>Next the user mapping must be configured, this will map members of the ldap group 'mysql-admins' to the local 'dba' account (the @ character indicates that mysql-admins is a group):</source>
          <target state="translated">다음으로 사용자 매핑을 구성해야합니다. 이렇게하면 ldap 그룹 'mysql-admins'의 구성원이 로컬 'dba'계정에 매핑됩니다 (@ 문자는 mysql-admins가 그룹임을 나타냅니다).</target>
        </trans-unit>
        <trans-unit id="b0d0bef5d2e71c09fb77dccbc61d1722819e1672" translate="yes" xml:space="preserve">
          <source>Next you need to let pgp know about the key like so:</source>
          <target state="translated">다음으로 pgp에게 키에 대해 알려 주어야합니다.</target>
        </trans-unit>
        <trans-unit id="5b072cc83cad85a94613cc6d7af4f4e328fed994" translate="yes" xml:space="preserve">
          <source>Next, &lt;a href=&quot;../build-environment-setup-for-linux/index&quot;&gt;prepare your system to be able to compile the source&lt;/a&gt;.</source>
          <target state="translated">다음으로 &lt;a href=&quot;../build-environment-setup-for-linux/index&quot;&gt;소스를 컴파일 할 수 있도록 시스템을 준비하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a847e10f566c7817104a0f14d1d6b651cc35dfb1" translate="yes" xml:space="preserve">
          <source>Next, I open several windows for each:</source>
          <target state="translated">다음으로 각각에 대해 여러 개의 창을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="29b47404bc6e73895f7229a64dcd5c07ce3417e5" translate="yes" xml:space="preserve">
          <source>Next, a really bad plan, yet one sometimes chosen:</source>
          <target state="translated">다음으로, 정말 나쁜 계획이지만 때로는 하나를 선택했습니다.</target>
        </trans-unit>
        <trans-unit id="12ecbd087ae43e8a7696e8808fce9ebbd9a233d1" translate="yes" xml:space="preserve">
          <source>Next, click on the &lt;strong&gt;Get Started Now&lt;/strong&gt; button. Alternatively, you can click on the &lt;strong&gt;Launch DB Instance&lt;/strong&gt; button from the &lt;a href=&quot;https://console.aws.amazon.com/rds/home#dbinstances:&quot;&gt;Instances section of the RDS Dashboard&lt;/a&gt;.</source>
          <target state="translated">그런 다음 &lt;strong&gt;지금 시작&lt;/strong&gt; 버튼을 클릭하십시오. 또는 &lt;a href=&quot;https://console.aws.amazon.com/rds/home#dbinstances:&quot;&gt;RDS 대시 보드&lt;/a&gt; 의 인스턴스 섹션 에서 &lt;strong&gt;Launch DB Instance (DB 인스턴스 시작)&lt;/strong&gt; 버튼을 클릭 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="86c41855746e258cdac08784edf42604334b610d" translate="yes" xml:space="preserve">
          <source>Next, configure the router for the Avro service.</source>
          <target state="translated">그런 다음 Avro 서비스에 대한 라우터를 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="4431679944e13bc552ec3d321ca10b9b30b3ee63" translate="yes" xml:space="preserve">
          <source>Next, create a user for the Spider node and set a password for that user. For the sake of the example, assume the Spider node is at the IP address 192.168.1.1:</source>
          <target state="translated">다음으로 Spider 노드의 사용자를 생성하고 해당 사용자의 비밀번호를 설정하십시오. 예를 들어, Spider 노드가 IP 주소 192.168.1.1에 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="29264b8021ec500a6b63aa35dbdb8a9071a5e703" translate="yes" xml:space="preserve">
          <source>Next, execute the recursive part of the query:</source>
          <target state="translated">다음으로 쿼리의 재귀 부분을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="aa95b9397d4f3ebb999d3a99690be72a4829cee4" translate="yes" xml:space="preserve">
          <source>Next, it batch-processes requests where possible, which further reduces CPU usage and lowers disk usage.</source>
          <target state="translated">그런 다음 가능한 경우 요청을 일괄 처리하여 CPU 사용량을 더욱 줄이고 디스크 사용량을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="381a256f19d94d15a9458d27595fa56d8d46c83a" translate="yes" xml:space="preserve">
          <source>Next, let&amp;rsquo;s create a directory manager user. We can do this by using OpenLDAP's &lt;a href=&quot;https://www.openldap.org/doc/admin24/slapdconf2.html&quot;&gt;olc&lt;/a&gt; configuration system to change the &lt;code&gt;&lt;a href=&quot;https://www.openldap.org/doc/admin24/slapdconf2.html#olcRootDN:%20%3CDN%3E&quot;&gt;olcRootDN&lt;/a&gt;&lt;/code&gt; directive to the DN of the directory manager user, which means that the user will be a privileged LDAP user that is not subject to access controls. We will also set the root password for the user by changing the &lt;code&gt;&lt;a href=&quot;https://www.openldap.org/doc/admin24/slapdconf2.html#olcRootPW:%20%3Cpassword%3E&quot;&gt;olcRootPW&lt;/a&gt;&lt;/code&gt; directive.</source>
          <target state="translated">다음으로 디렉토리 관리자 사용자를 만들어 봅시다. OpenLDAP의 &lt;a href=&quot;https://www.openldap.org/doc/admin24/slapdconf2.html&quot;&gt;olc&lt;/a&gt; 구성 시스템을 사용하여 &lt;code&gt;&lt;a href=&quot;https://www.openldap.org/doc/admin24/slapdconf2.html#olcRootDN:%20%3CDN%3E&quot;&gt;olcRootDN&lt;/a&gt;&lt;/code&gt; 지시문을 디렉토리 관리자 사용자의 DN 으로 변경하여 이를 수행 할 수 있습니다. 즉, 사용자는 액세스 제어를받지 않는 권한있는 LDAP 사용자가됩니다. 또한 &lt;code&gt;&lt;a href=&quot;https://www.openldap.org/doc/admin24/slapdconf2.html#olcRootPW:%20%3Cpassword%3E&quot;&gt;olcRootPW&lt;/a&gt;&lt;/code&gt; 지시문 을 변경하여 사용자의 루트 비밀번호를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="9418e0299d2744287a1c7007700052d135d42044" translate="yes" xml:space="preserve">
          <source>Next, let's &lt;a href=&quot;../authentication-plugin-pam/index#configuring-the-pam-service&quot;&gt;configure the PAM service&lt;/a&gt;. We will call our service &lt;code&gt;mariadb&lt;/code&gt;, so our PAM service configuration file will be located at &lt;code&gt;/etc/pam.d/mariadb&lt;/code&gt; on most systems.</source>
          <target state="translated">다음으로 &lt;a href=&quot;../authentication-plugin-pam/index#configuring-the-pam-service&quot;&gt;PAM 서비스를 구성 해&lt;/a&gt; 봅시다 . 우리는 우리의 서비스 &lt;code&gt;mariadb&lt;/code&gt; 를 호출 할 것이므로 , PAM 서비스 구성 파일은 대부분의 시스템 에서 &lt;code&gt;/etc/pam.d/mariadb&lt;/code&gt; 에 있습니다.</target>
        </trans-unit>
        <trans-unit id="2fbe5a9988ec8c22301e55cee4db237816f07a70" translate="yes" xml:space="preserve">
          <source>Next, let's &lt;a href=&quot;../authentication-plugin-pam/index#creating-users&quot;&gt;create the MariaDB users&lt;/a&gt;. Remember that our PAM service is called &lt;code&gt;mariadb&lt;/code&gt;.</source>
          <target state="translated">다음으로 &lt;a href=&quot;../authentication-plugin-pam/index#creating-users&quot;&gt;MariaDB 사용자를 만들어&lt;/a&gt; 봅시다 . PAM 서비스는 &lt;code&gt;mariadb&lt;/code&gt; 라고 합니다 .</target>
        </trans-unit>
        <trans-unit id="0c71878da64381907e4a37f842d1641677eed8d2" translate="yes" xml:space="preserve">
          <source>Next, let's &lt;a href=&quot;../authentication-plugin-pam/index#installing-the-plugin&quot;&gt;install the &lt;code&gt;pam&lt;/code&gt; authentication plugin&lt;/a&gt;.</source>
          <target state="translated">다음으로 &lt;a href=&quot;../authentication-plugin-pam/index#installing-the-plugin&quot;&gt; &lt;code&gt;pam&lt;/code&gt; &lt;/a&gt; 인증 플러그인을 설치 하겠습니다 .</target>
        </trans-unit>
        <trans-unit id="8e41ed0d57d591ca1d3f3f533f39ab772fc24751" translate="yes" xml:space="preserve">
          <source>Next, let's &lt;a href=&quot;../user-and-group-mapping-with-pam/index#configuring-the-pam_user_map-pam-module&quot;&gt;configure the pam_user_map PAM module&lt;/a&gt; based on our hypothetical requirements.</source>
          <target state="translated">다음은 가상 요구 사항에 &lt;a href=&quot;../user-and-group-mapping-with-pam/index#configuring-the-pam_user_map-pam-module&quot;&gt;따라 pam_user_map PAM 모듈을 구성 해&lt;/a&gt; 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="c813459b225dca57b0d7665d51e32856ea7f610f" translate="yes" xml:space="preserve">
          <source>Next, let's &lt;a href=&quot;../user-and-group-mapping-with-pam/index#installing-the-pam_user_map-pam-module&quot;&gt;install the pam_user_map PAM module&lt;/a&gt;.</source>
          <target state="translated">다음으로 &lt;a href=&quot;../user-and-group-mapping-with-pam/index#installing-the-pam_user_map-pam-module&quot;&gt;pam_user_map PAM 모듈을 설치&lt;/a&gt; 하겠습니다 .</target>
        </trans-unit>
        <trans-unit id="a1dac4c586eed5c4edeadd57de6e4bff53fc9669" translate="yes" xml:space="preserve">
          <source>Next, let's configure LDAP on the system. We can use &lt;code&gt;&lt;a href=&quot;https://linux.die.net/man/8/authconfig&quot;&gt;authconfig&lt;/a&gt;&lt;/code&gt; for this:</source>
          <target state="translated">다음으로 시스템에서 LDAP를 구성 해 봅시다. 이를 위해 &lt;code&gt;&lt;a href=&quot;https://linux.die.net/man/8/authconfig&quot;&gt;authconfig&lt;/a&gt;&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3a116d73f9deadf7694d0bd84edcf9b9e16b115c" translate="yes" xml:space="preserve">
          <source>Next, let's create the structure of the directory by creating parts of our tree.</source>
          <target state="translated">다음으로 트리의 일부를 만들어 디렉토리의 구조를 만들어 봅시다.</target>
        </trans-unit>
        <trans-unit id="bb537c62aabe7d6a3eeff4b93ab503979a27eb6b" translate="yes" xml:space="preserve">
          <source>Next, let's start the OpenLDAP Server and configure it to start on reboot. On &lt;code&gt;&lt;a href=&quot;../systemd/index&quot;&gt;systemd&lt;/a&gt;&lt;/code&gt; systems, that would go like this:</source>
          <target state="translated">다음으로 OpenLDAP 서버를 시작하고 재부팅시 시작되도록 구성 해 봅시다. 에 &lt;code&gt;&lt;a href=&quot;../systemd/index&quot;&gt;systemd&lt;/a&gt;&lt;/code&gt; 시스템, 즉,이 같이 갈 것입니다 :</target>
        </trans-unit>
        <trans-unit id="0050ddbdc47732d32c899265144383ae66dd6679" translate="yes" xml:space="preserve">
          <source>Next, let's test out our configuration by &lt;a href=&quot;../user-and-group-mapping-with-pam/index#verifying-that-mapping-is-occurring&quot;&gt;verifying that mapping is occurring&lt;/a&gt;. We can verify this by logging in as each of our users and comparing the return value of &lt;code&gt;&lt;a href=&quot;../user/index&quot;&gt;USER()&lt;/a&gt;&lt;/code&gt;, which is the original user name and the return value of &lt;code&gt;&lt;a href=&quot;../current_user/index&quot;&gt;CURRENT_USER()&lt;/a&gt;&lt;/code&gt;, which is the authenticated user name.</source>
          <target state="translated">다음으로 &lt;a href=&quot;../user-and-group-mapping-with-pam/index#verifying-that-mapping-is-occurring&quot;&gt;매핑이 발생하는지 확인하여&lt;/a&gt; 구성을 테스트 해 보겠습니다 . 각 사용자로 로그인 하고 원래 사용자 이름 인 &lt;code&gt;&lt;a href=&quot;../user/index&quot;&gt;USER()&lt;/a&gt;&lt;/code&gt; 의 반환 값과 인증 된 사용자 이름 인 &lt;code&gt;&lt;a href=&quot;../current_user/index&quot;&gt;CURRENT_USER()&lt;/a&gt;&lt;/code&gt; 의 반환 값을 비교하여이를 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="90b766d35327579dcc149a26c356d764a8f7acde" translate="yes" xml:space="preserve">
          <source>Next, let's to configure the OpenLDAP Server. The easiest way to do that is to copy the template configuration file that is included with the installation. In many installations, that will be at &lt;code&gt;/usr/share/openldap-servers/DB_CONFIG.example&lt;/code&gt;. For example:</source>
          <target state="translated">다음으로 OpenLDAP 서버를 설정해 봅시다. 가장 쉬운 방법은 설치에 포함 된 템플릿 구성 파일을 복사하는 것입니다. 많은 설치에서 &lt;code&gt;/usr/share/openldap-servers/DB_CONFIG.example&lt;/code&gt; 에 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6b6a2a7ebf58f47c3a72fa3fb4ca7707cac3d84e" translate="yes" xml:space="preserve">
          <source>Next, make sure that the Galera version numbers are compatible.</source>
          <target state="translated">다음으로 Galera 버전 번호가 호환되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="cad0c367489115595bba39e9de2321306f9ac5ce" translate="yes" xml:space="preserve">
          <source>Next, modify our sources.list to remove the 5.5.32 repo and switch back to the normal 5.5 repo</source>
          <target state="translated">다음으로 sources.list를 수정하여 5.5.32 저장소를 제거하고 일반 5.5 저장소로 다시 전환하십시오.</target>
        </trans-unit>
        <trans-unit id="56961ed9e4f7aa13ef6f646ec17822d674254ef9" translate="yes" xml:space="preserve">
          <source>Next, point the slave to the master with &lt;a href=&quot;../change-master-to/index&quot;&gt;CHANGE MASTER&lt;/a&gt;. Specify master_host etc. as usual. But instead of specifying master_log_file and master_log_pos manually, use &lt;code&gt;master_use_gtid=current_pos&lt;/code&gt; (or &lt;code&gt;slave_pos&lt;/code&gt; to have GTID do it automatically:</source>
          <target state="translated">그런 다음 &lt;a href=&quot;../change-master-to/index&quot;&gt;CHANGE MASTER&lt;/a&gt; 를 사용하여 슬레이브를 마스터로 지정하십시오 . 평소와 같이 master_host 등을 지정하십시오. 그러나 master_log_file 및 master_log_pos를 수동으로 지정하는 대신 &lt;code&gt;master_use_gtid=current_pos&lt;/code&gt; (또는 &lt;code&gt;slave_pos&lt;/code&gt; 를 사용하여 GTID가 자동으로 수행하도록하십시오.</target>
        </trans-unit>
        <trans-unit id="40b4f6f815b48a70878c08a096ddb7a004f70203" translate="yes" xml:space="preserve">
          <source>Next, set the &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encryption_threads&quot;&gt;innodb_encryption_threads&lt;/a&gt;&lt;/code&gt; system variable to a non-zero value:</source>
          <target state="translated">다음으로 &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encryption_threads&quot;&gt;innodb_encryption_threads&lt;/a&gt;&lt;/code&gt; 시스템 변수를 0이 아닌 값으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="8bc9ecd86ab1a9a0030049ce64fa367e36ccce36" translate="yes" xml:space="preserve">
          <source>Next, test out other write operations using either an &lt;code&gt;&lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../delete/index&quot;&gt;DELETE&lt;/a&gt;&lt;/code&gt; statement on &lt;code&gt;Server-1&lt;/code&gt;:</source>
          <target state="translated">그런 다음 &lt;code&gt;Server-1&lt;/code&gt; 에서 &lt;code&gt;&lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../delete/index&quot;&gt;DELETE&lt;/a&gt;&lt;/code&gt; 문을 사용하여 다른 쓰기 작업을 테스트하십시오 .</target>
        </trans-unit>
        <trans-unit id="45abbc42d57fece299aa33f1343bbc24b6ff83be" translate="yes" xml:space="preserve">
          <source>Next, the function body is placed between &lt;a href=&quot;../begin-end/index&quot;&gt;BEGIN and END&lt;/a&gt; statements. It declares a tinyint, &lt;code&gt;X&lt;/code&gt;, which is simply set to 42, and this is the result returned.</source>
          <target state="translated">다음으로 함수 본문은 &lt;a href=&quot;../begin-end/index&quot;&gt;BEGIN과 END&lt;/a&gt; 문 사이에 배치 됩니다. tinyint &lt;code&gt;X&lt;/code&gt; 를 선언합니다. 이것은 단순히 42로 설정되며 이것이 반환되는 결과입니다.</target>
        </trans-unit>
        <trans-unit id="197106a8f658ede794187e737420115487c97544" translate="yes" xml:space="preserve">
          <source>Next, the pam plugin and mariadb accounts can be configured:</source>
          <target state="translated">다음으로 pam 플러그인과 mariadb 계정을 구성 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="63c2ad2fb5b662aafbb928e3f5bd14005bf5c03e" translate="yes" xml:space="preserve">
          <source>Next, the recursive part:</source>
          <target state="translated">다음으로 재귀 부분 :</target>
        </trans-unit>
        <trans-unit id="1a9b8ef4cee06c76a7ac1fac5617331ccd9f9535" translate="yes" xml:space="preserve">
          <source>Next, we add a few employees to the table:</source>
          <target state="translated">다음으로 몇 명의 직원을 테이블에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="a91ec418226c3eff04dc209087719564eaed2c97" translate="yes" xml:space="preserve">
          <source>Next, we will start streaming data via the &lt;code&gt;mxs_adapter&lt;/code&gt; utility, so that the data we've loaded on the MariaDB Servers can stream to MariaDB ColumnStore. On &lt;code&gt;MaxScale-1&lt;/code&gt;, create a TSV (tab-separated) file named bank.lst with the bank database tables we want to stream:</source>
          <target state="translated">다음으로 &lt;code&gt;mxs_adapter&lt;/code&gt; 유틸리티 를 통해 데이터 스트리밍을 시작 하여 MariaDB 서버에로드 한 데이터가 MariaDB ColumnStore로 스트리밍 할 수 있습니다. 에 &lt;code&gt;MaxScale-1&lt;/code&gt; , 우리는 스트리밍하려는 은행 데이터베이스 테이블 bank.lst라는 TSV (탭으로 구분) 파일을 생성 :</target>
        </trans-unit>
        <trans-unit id="4812648c8a890c1818305642f6a01fa134b34401" translate="yes" xml:space="preserve">
          <source>Nicaragua</source>
          <target state="translated">Nicaragua</target>
        </trans-unit>
        <trans-unit id="4dd2d83410062286116bfd3474723788ce66b385" translate="yes" xml:space="preserve">
          <source>Nl</source>
          <target state="translated">Nl</target>
        </trans-unit>
        <trans-unit id="816c52fd2bdd94a63cd0944823a6c0aa9384c103" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="translated">No</target>
        </trans-unit>
        <trans-unit id="2225a2e57875c7d2bcb4ea80c08167950134f6b7" translate="yes" xml:space="preserve">
          <source>No &quot;compound&quot; (aka &quot;composite&quot;) indexes</source>
          <target state="translated">&quot;복합&quot;(일명 &quot;복합&quot;) 인덱스 없음</target>
        </trans-unit>
        <trans-unit id="f53cfdd4e837935ba9a5dec792a96c5bf2e9b006" translate="yes" xml:space="preserve">
          <source>No &lt;a href=&quot;../transactions/index&quot;&gt;transactions&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../transactions/index&quot;&gt;거래가&lt;/a&gt; 없습니다 .</target>
        </trans-unit>
        <trans-unit id="ccf780ac548904111029978fb25335bb0bcd71c2" translate="yes" xml:space="preserve">
          <source>No &lt;code&gt;INSERT NOAR&lt;/code&gt; or &lt;code&gt;UPDATE NOAR&lt;/code&gt; commands.</source>
          <target state="translated">아니 &lt;code&gt;INSERT NOAR&lt;/code&gt; 또는 &lt;code&gt;UPDATE NOAR&lt;/code&gt; 명령.</target>
        </trans-unit>
        <trans-unit id="dbedeed558ca23cb55764de8336655c6686d38a4" translate="yes" xml:space="preserve">
          <source>No ALTER TABLE, DROP TABLE or any other Data Definition Language calls.</source>
          <target state="translated">ALTER TABLE, DROP TABLE 또는 기타 데이터 정의 언어 호출이 없습니다.</target>
        </trans-unit>
        <trans-unit id="28236384d63efd224b56a386490d2933a83b68cf" translate="yes" xml:space="preserve">
          <source>No BETWEEN and IN predicates.</source>
          <target state="translated">BETWEEN 및 IN 술어가 없습니다.</target>
        </trans-unit>
        <trans-unit id="bfb4430e4dc427099390edb6801587501b590417" translate="yes" xml:space="preserve">
          <source>No Default Datadir</source>
          <target state="translated">기본 데이터 없음</target>
        </trans-unit>
        <trans-unit id="3882321b63dd39b6aba1565a792871d148c1abb1" translate="yes" xml:space="preserve">
          <source>No ID</source>
          <target state="translated">아이디 없음</target>
        </trans-unit>
        <trans-unit id="68caa9a04354929ee1f7093389d1bfc745756762" translate="yes" xml:space="preserve">
          <source>No INDEX on ts is needed. (This helps INSERTs a little.)</source>
          <target state="translated">ts의 INDEX가 필요하지 않습니다. (이것은 INSERT를 조금 도와줍니다.)</target>
        </trans-unit>
        <trans-unit id="088e1bb9cb64b95d87ba023b488d53231e4f4340" translate="yes" xml:space="preserve">
          <source>No PRIMARY KEY</source>
          <target state="translated">기본 키 없음</target>
        </trans-unit>
        <trans-unit id="f7275e645ff116cca3595017be49d87be8d40b0a" translate="yes" xml:space="preserve">
          <source>No RETURN found in FUNCTION %s</source>
          <target state="translated">FUNCTION % s에서 RETURN을 찾을 수 없습니다</target>
        </trans-unit>
        <trans-unit id="089b23d9fcb7a8d6f8824366042a013a3e1a7087" translate="yes" xml:space="preserve">
          <source>No Total for each row -- Remove the SUM...AS Total line from the SELECT.</source>
          <target state="translated">각 행에 대해 총계 없음-SELECT에서 SUM ... AS Total 행을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="0141ed5104e51973f489b8c7064a4f9c6fda1dbe" translate="yes" xml:space="preserve">
          <source>No Totals at the bottom -- Remove the WITH ROLLUP line from the SELECT.</source>
          <target state="translated">맨 아래에 총계 없음-SELECT에서 WITH ROLLUP 행을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="5a105b3e0c7e6dd727e3b4324e2a4c8f8e02b519" translate="yes" xml:space="preserve">
          <source>No automatic rehashing. One has to use 'rehash' to get table and field completion. This gives a quicker start of mysql and disables rehashing on reconnect.</source>
          <target state="translated">자동 리 해싱이 없습니다. 테이블과 필드 완성을 얻으려면 'rehash'를 사용해야합니다. 이것은 mysql의 빠른 시작을 제공하고 재 연결시 재해 싱을 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="6d3c2b8ce96417b8fed4423ab7996e408e018523" translate="yes" xml:space="preserve">
          <source>No change has been made to cluster, so let's create a divergence:</source>
          <target state="translated">클러스터는 변경되지 않았으므로 분기를 생성 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="ea70da0c461f1e3f0899b46fef3bff831433d11b" translate="yes" xml:space="preserve">
          <source>No client connection requests have been allowed to be dequeued to run since the last stall check by the &lt;strong&gt;timer thread&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;타이머 스레드에&lt;/strong&gt; 의한 마지막 스톨 확인 이후 클라이언트 연결 요청이 큐에서 대기되도록 허용되지 않았습니다 .</target>
        </trans-unit>
        <trans-unit id="0b8d971737db5de52f1c619d495403f96df689ca" translate="yes" xml:space="preserve">
          <source>No collation</source>
          <target state="translated">콜 레이션 없음</target>
        </trans-unit>
        <trans-unit id="94abf603c25c35599a2597002873c2007782f9e2" translate="yes" xml:space="preserve">
          <source>No comparison between two columns.</source>
          <target state="translated">두 열 사이에 비교가 없습니다.</target>
        </trans-unit>
        <trans-unit id="875f36d820e0a2159e97b0423a5193cfb08ce7dc" translate="yes" xml:space="preserve">
          <source>No conversion will take place if the value falls outside of the supported TIMESTAMP range ('1970-01-01 00:00:01' to '2038-01-19 05:14:07' UTC) when converted from &lt;em&gt;from_tz&lt;/em&gt; to UTC.</source>
          <target state="translated">&lt;em&gt;from_tz&lt;/em&gt; 에서 UTC 로 변환 할 때 값이 지원되는 TIMESTAMP 범위 ( '1970-01-01 00:00:01'에서 '2038-01-19 05:14:07'UTC)를 &lt;em&gt;벗어나면&lt;/em&gt; 변환이 수행되지 &lt;em&gt;않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="cd8c77c50f5ea92217528c0a4e3b1a60002ba1bc" translate="yes" xml:space="preserve">
          <source>No copy of the original data was done. Both tables use the same source data.</source>
          <target state="translated">원래 데이터의 사본이 수행되지 않았습니다. 두 테이블 모두 동일한 소스 데이터를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="47abc3190d5f1eaec2b5979370f67e88db917639" translate="yes" xml:space="preserve">
          <source>No data - zero rows fetched, selected, or processed</source>
          <target state="translated">데이터 없음-가져 오기, 선택 또는 처리 된 행이 없습니다.</target>
        </trans-unit>
        <trans-unit id="5d073c71341c9acc845bfd63df6a3ddcdbefb997" translate="yes" xml:space="preserve">
          <source>No database selected</source>
          <target state="translated">선택된 데이타베이스가 없습니다</target>
        </trans-unit>
        <trans-unit id="8686690ae125fe5083548f90ee12e0733887e582" translate="yes" xml:space="preserve">
          <source>No datetime expression provided</source>
          <target state="translated">날짜 / 시간 표현이 제공되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="b85898cf67a0373482044d828b39b5a76f0c2b36" translate="yes" xml:space="preserve">
          <source>No decimal point exist in the file</source>
          <target state="translated">파일에 소수점이 없습니다</target>
        </trans-unit>
        <trans-unit id="2983e217997e82ed8ae6f1903692d0dfb61047a4" translate="yes" xml:space="preserve">
          <source>No definer attribute for trigger '%s'.'%s'. The trigger will be activated under the authorization of the invoker, which may have insufficient privileges. Please recreate the trigger.</source>
          <target state="translated">트리거 '% s'. '% s'에 대한 정의 자 속성이 없습니다. 트리거는 권한이 충분하지 않은 호출자의 권한에 따라 활성화됩니다. 트리거를 다시 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="822fdef887227bb9b7e0fc38a66f42b92c41cfd0" translate="yes" xml:space="preserve">
          <source>No disk space is recovered after a DELETE. TRUNCATE and DROP PARTITION can be used to recover space, or alternatively CREATE TABLE, loading only the remaining rows, then using DROP TABLE on the original table and RENAME TABLE).</source>
          <target state="translated">삭제 후 디스크 공간이 복구되지 않습니다. TRUNCATE 및 DROP PARTITION을 사용하여 공간을 복구하거나 다른 방법으로 CREATE TABLE을 수행하여 나머지 행만로드 한 다음 원래 테이블의 DROP TABLE 및 RENAME TABLE을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7158647b72b8b9015e224d319e69c3aab3fbee44" translate="yes" xml:space="preserve">
          <source>No endspace is stored, and endspace compression is not always performed for all values.</source>
          <target state="translated">끝 공간이 저장되지 않으며 끝 공간 압축이 모든 값에 대해 항상 수행되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="5acbca5940fb88ae5f84f58ec4530d749ce9f977" translate="yes" xml:space="preserve">
          <source>No endspace is stored, no empty values are stored.</source>
          <target state="translated">끝 공간이 저장되지 않고 빈 값이 저장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1704244f4a8b33226a48fd25ceacdb49e566c899" translate="yes" xml:space="preserve">
          <source>No endspace is stored.</source>
          <target state="translated">끝 공간이 저장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="28ee82526f28d642ef99ee5926a8839f8a24e7f1" translate="yes" xml:space="preserve">
          <source>No error will be raised and the non-matching values will be ignored. This table will be displayed as:</source>
          <target state="translated">오류가 발생하지 않으며 일치하지 않는 값은 무시됩니다. 이 테이블은 다음과 같이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="1ce8f10e4eb5565ef7c2bcb83d535218a811be77" translate="yes" xml:space="preserve">
          <source>No expression (currently a CONNECT restriction)</source>
          <target state="translated">표현 없음 (현재 CONNECT 제한)</target>
        </trans-unit>
        <trans-unit id="44bb9f27fa7256dfa2829647d5805402baa0579e" translate="yes" xml:space="preserve">
          <source>No external locking (MyISAM has external locking, but this is a rarely used feature).</source>
          <target state="translated">외부 잠금이 없습니다 (MyISAM에는 외부 잠금이 있지만이 기능은 거의 사용되지 않습니다).</target>
        </trans-unit>
        <trans-unit id="63263f6e74a507e4c01aec141009b65c8cd64357" translate="yes" xml:space="preserve">
          <source>No format, the value was entered as is.</source>
          <target state="translated">형식이 없습니다. 값을 그대로 입력했습니다.</target>
        </trans-unit>
        <trans-unit id="0b7df2ae66f3cd6f6b25b79873e389d2105818de" translate="yes" xml:space="preserve">
          <source>No function.</source>
          <target state="translated">기능이 없습니다.</target>
        </trans-unit>
        <trans-unit id="5e9446536938186fc24e882b0babf956c6835a76" translate="yes" xml:space="preserve">
          <source>No gdb stack trace on sigsegv</source>
          <target state="translated">sigsegv에 gdb 스택 추적이 없습니다.</target>
        </trans-unit>
        <trans-unit id="37ee68ca44599638479270885255272a80cadc61" translate="yes" xml:space="preserve">
          <source>No indexes</source>
          <target state="translated">색인 없음</target>
        </trans-unit>
        <trans-unit id="7f5c1e4f7839ed869275c1e7f946d730a78304a7" translate="yes" xml:space="preserve">
          <source>No indexing of ODBC tables (do not specify any columns as key) However, because CONNECT can often add a where clause to the query sent to the data source, indexing will be used by the data source if it supports it. (Remote indexing is available with version 1.04, released with &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1016-release-notes/&quot;&gt;MariaDB 10.1.6&lt;/a&gt;)</source>
          <target state="translated">ODBC 테이블의 인덱싱 없음 (열을 키로 지정하지 않음) 그러나 CONNECT는 데이터 소스로 전송 된 쿼리에 where 절을 추가 할 수 있기 때문에 데이터 소스가 지원하는 경우 인덱싱이 사용됩니다. (원격 인덱싱은 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1016-release-notes/&quot;&gt;MariaDB 10.1.6&lt;/a&gt; 과 함께 릴리스 된 버전 1.04에서 사용 가능 )</target>
        </trans-unit>
        <trans-unit id="4b75441ce105e0d9345edcb25bec4d381d7c6edb" translate="yes" xml:space="preserve">
          <source>No join buffer space is used for null field values.</source>
          <target state="translated">널 필드 값에는 결합 버퍼 공간이 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b3a7ecf1c8c2971dbd3327ea33c84e8e3e073c12" translate="yes" xml:space="preserve">
          <source>No keys on database server hard disk</source>
          <target state="translated">데이터베이스 서버 하드 디스크에 키가 없습니다</target>
        </trans-unit>
        <trans-unit id="67d3038a26dd3b72a108c3fbec277134abe1cc57" translate="yes" xml:space="preserve">
          <source>No longer affects replication of events in a Galera cluster.</source>
          <target state="translated">Galera 클러스터의 이벤트 복제에 더 이상 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0e19cbcd9701989a068db5f50c0e106f31f036f0" translate="yes" xml:space="preserve">
          <source>No longer necessary as the Antelope &lt;a href=&quot;../xtradbinnodb-file-format/index&quot;&gt;InnoDB file format&lt;/a&gt; is no longer supported.</source>
          <target state="translated">Antelope &lt;a href=&quot;../xtradbinnodb-file-format/index&quot;&gt;InnoDB 파일 형식&lt;/a&gt; 이 더 이상 지원되지 않으므로 더 이상 필요 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5344dd7709c68b2cb4d0e77f60d76b739bd2c5c3" translate="yes" xml:space="preserve">
          <source>No longer reported</source>
          <target state="translated">더 이상보고되지 않음</target>
        </trans-unit>
        <trans-unit id="902c9ad0c40a68bcfbd8e1acf96c852c67318016" translate="yes" xml:space="preserve">
          <source>No lost transactions</source>
          <target state="translated">손실 된 거래 없음</target>
        </trans-unit>
        <trans-unit id="b279c3388c450f0c538c684fe9821f7bd2abc7d7" translate="yes" xml:space="preserve">
          <source>No memory copying or extra memory used for blobs on insert/update.</source>
          <target state="translated">삽입 / 업데이트시 Blob에 사용되는 메모리 복사 또는 추가 메모리가 없습니다.</target>
        </trans-unit>
        <trans-unit id="238327aa69e411d4c797a6e2b930fac8bdf376cb" translate="yes" xml:space="preserve">
          <source>No more than 50 PARTITIONs on a table (open, show table status, etc, are impacted) (fixed in MySQL 5.6.6?; a better fix coming eventually in 5.7)</source>
          <target state="translated">테이블에서 50 개 이하의 파티션 (개방, 테이블 상태 표시 등)이 영향을 받음 (MySQL 5.6.6에서 수정 되었습니까? 더 나은 수정은 결국 5.7에서 제공됨)</target>
        </trans-unit>
        <trans-unit id="e65dc3743310276aa64f3e726e810d227b24228b" translate="yes" xml:space="preserve">
          <source>No need for additional SQL language extensions.</source>
          <target state="translated">추가 SQL 언어 확장이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9c9b640339a3c234011d6c3183cc26345173e12a" translate="yes" xml:space="preserve">
          <source>No need to check for errors after COMMIT.</source>
          <target state="translated">COMMIT 후 오류를 확인할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3af06ba28ca0178be7acf674fe9eda442417c3ad" translate="yes" xml:space="preserve">
          <source>No new tables are created and there is no need to copy data from old tables to new tables. Instead, this feature loads &lt;code&gt;n&lt;/code&gt; pages (determined by &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_defragment_n_pages&quot;&gt;innodb-defragment-n-pages&lt;/a&gt;) and tries to move records so that pages would be full of records and then frees pages that are fully empty after the operation.</source>
          <target state="translated">새 테이블이 작성되지 않으며 이전 테이블에서 새 테이블로 데이터를 복사 할 필요가 없습니다. 대신이 기능은 &lt;code&gt;n&lt;/code&gt; 페이지 ( &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_defragment_n_pages&quot;&gt;innodb-defragment-n-pages에&lt;/a&gt; 의해 결정됨)를 로드 하고 페이지가 레코드로 가득 차게하여 레코드를 이동 한 다음 조작 후 완전히 비어있는 페이지를 해제합니다.</target>
        </trans-unit>
        <trans-unit id="cb5eefcd89a077c96fa31a32d390cab2b6b23264" translate="yes" xml:space="preserve">
          <source>No online &lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt;.</source>
          <target state="translated">온라인 &lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE이&lt;/a&gt; 없습니다 .</target>
        </trans-unit>
        <trans-unit id="47c69a80593a64229cd878a3348876cd6d0c8d90" translate="yes" xml:space="preserve">
          <source>No online &lt;a href=&quot;../optimize-table/index&quot;&gt;OPTIMIZE TABLE&lt;/a&gt; before &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10011-release-notes/&quot;&gt;10.0.11&lt;/a&gt; (&lt;a href=&quot;http://bazaar.launchpad.net/~maria-captains/maria/10.0/revision/4199&quot;&gt;r4199&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10011-release-notes/&quot;&gt;10.0.11&lt;/a&gt; ( &lt;a href=&quot;http://bazaar.launchpad.net/~maria-captains/maria/10.0/revision/4199&quot;&gt;r4199&lt;/a&gt; ) 이전에 온라인 &lt;a href=&quot;../optimize-table/index&quot;&gt;OPTIMIZE TABLE이&lt;/a&gt; 없습니다.</target>
        </trans-unit>
        <trans-unit id="87dc5a7cf13410fe90f8d36afe302b8fe22929fd" translate="yes" xml:space="preserve">
          <source>No online &lt;a href=&quot;../optimize-table/index&quot;&gt;OPTIMIZE TABLE&lt;/a&gt; before &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10011-release-notes/&quot;&gt;10.0.11&lt;/a&gt; (&lt;a href=&quot;https://bazaar.launchpad.net/~maria-captains/maria/10.0/revision/4199&quot;&gt;r4199&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6500386b3c4f1fdbed59654499b850d68a93eea" translate="yes" xml:space="preserve">
          <source>No online &lt;a href=&quot;../optimize-table/index&quot;&gt;OPTIMIZE TABLE&lt;/a&gt;.</source>
          <target state="translated">온라인 &lt;a href=&quot;../optimize-table/index&quot;&gt;최적화 테이블이&lt;/a&gt; 없습니다 .</target>
        </trans-unit>
        <trans-unit id="1851836868be57a15ca3684a090210f53c7a98f8" translate="yes" xml:space="preserve">
          <source>No password</source>
          <target state="translated">비밀번호가 없습니다</target>
        </trans-unit>
        <trans-unit id="05cec41a68b34bac7e3b3cbd602e7abeed967682" translate="yes" xml:space="preserve">
          <source>No paths allowed for shared library</source>
          <target state="translated">공유 라이브러리에 경로가 허용되지 않습니다</target>
        </trans-unit>
        <trans-unit id="484dc38082130bc853c7d9c9c8c1fcf4be17b654" translate="yes" xml:space="preserve">
          <source>No programs are bug free, especially new ones. Please &lt;a href=&quot;../reporting-bugs/index&quot;&gt;report all bugs&lt;/a&gt; or documentation errors using the means provided by MariaDB.</source>
          <target state="translated">버그가없는 프로그램, 특히 새로운 프로그램은 없습니다. MariaDB가 제공 한 수단을 사용하여 &lt;a href=&quot;../reporting-bugs/index&quot;&gt;모든 버그&lt;/a&gt; 또는 문서 오류를 보고 하십시오 .</target>
        </trans-unit>
        <trans-unit id="52d9985832ccbc9f1e1c0f59e71c5353c9e015d5" translate="yes" xml:space="preserve">
          <source>No random reads for updating secondary keys, except for unique indexes. The Read-Free Replication option does away with random reads when updating primary keys, regardless of uniqueness, with a row-based binary logging format.</source>
          <target state="translated">고유 인덱스를 제외하고 보조 키 업데이트를위한 임의 읽기가 없습니다. Read-Free Replication 옵션은 고유성에 관계없이 기본 키를 행 기반 이진 로깅 형식으로 업데이트 할 때 무작위 읽기를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="4c494551251852be9135fa745828333daef886da" translate="yes" xml:space="preserve">
          <source>No rows in the subquery, so the scalar is NULL:</source>
          <target state="translated">하위 쿼리에 행이 없으므로 스칼라는 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="6340751f85be68d2f6d212352920023ae6d8e232" translate="yes" xml:space="preserve">
          <source>No slave lag</source>
          <target state="translated">노예 지연 없음</target>
        </trans-unit>
        <trans-unit id="16bf34d7c70c1617980f6ae3b61ad63e1393a36c" translate="yes" xml:space="preserve">
          <source>No storage limit.</source>
          <target state="translated">저장 용량 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="3996752d671360422fa12ef1da47f2290acfac67" translate="yes" xml:space="preserve">
          <source>No tables used</source>
          <target state="translated">사용 된 테이블이 없습니다</target>
        </trans-unit>
        <trans-unit id="f01f12fe5ca492aacb357428426e78ebd31e22fd" translate="yes" xml:space="preserve">
          <source>No tokenizing is performed.</source>
          <target state="translated">토큰 화가 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2af2705cb6f8867afec5003cd80298ceac698bfa" translate="yes" xml:space="preserve">
          <source>No trace.</source>
          <target state="translated">흔적이 없습니다.</target>
        </trans-unit>
        <trans-unit id="54475f97ae86a03302aac3320d96dbfe736fbb5c" translate="yes" xml:space="preserve">
          <source>No trailing zone ID's or traling network masks are permitted. For IPv4 addresses, or IPv6 addresses with IPv4 address parts, no classful addresses or trailing port numbers are permitted and octal numbers are not supported.</source>
          <target state="translated">후행 영역 ID 또는 추적 네트워크 마스크는 허용되지 않습니다. IPv4 주소 또는 IPv4 주소 부분이있는 IPv6 주소의 경우 클래스 주소 나 후행 포트 번호는 허용되지 않으며 8 진수는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1d402441c3b972c1257d41a23a0cf7d56800bfb6" translate="yes" xml:space="preserve">
          <source>No value</source>
          <target state="translated">가치 없음</target>
        </trans-unit>
        <trans-unit id="dc335ef4dd07cf13811ac43bb3464d36ba3ccbd3" translate="yes" xml:space="preserve">
          <source>No way to get E(#rows in column family)</source>
          <target state="translated">E를 얻을 수있는 방법이 없습니다 (열 계열의 행 수)</target>
        </trans-unit>
        <trans-unit id="902cbc89e1c3598e077a2884738aba0c1b224ed5" translate="yes" xml:space="preserve">
          <source>No web server is required. However, Apache 2 has been tested and a configuration file is included in the project.</source>
          <target state="translated">웹 서버가 필요하지 않습니다. 그러나 Apache 2가 테스트되었으며 구성 파일이 프로젝트에 포함되었습니다.</target>
        </trans-unit>
        <trans-unit id="d32db296ae40b368ae00e2c18a4d0c7aaecd9c3d" translate="yes" xml:space="preserve">
          <source>No, it only has to be indexed. It doesn't even have to be unique.</source>
          <target state="translated">아니요, 색인 만 작성하면됩니다. 고유하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="3395ab1c6b216a9b5774208a64c835aeb4b7e00e" translate="yes" xml:space="preserve">
          <source>No. Cassandra SE is not suitable for running analytics-type queries that sift through huge amounts of data in a Cassandra cluster. That task is better handled by Hadoop-based tools like Apache Pig or Apache Hive. Cassandra SE is rather a &quot;window&quot; from an SQL environment into NoSQL.</source>
          <target state="translated">Cassandra SE는 Cassandra 클러스터에서 대량의 데이터를 선별하는 분석 유형 쿼리를 실행하는 데 적합하지 않습니다. 이 작업은 Apache Pig 또는 Apache Hive와 같은 Hadoop 기반 도구로 더 잘 처리됩니다. Cassandra SE는 오히려 SQL 환경에서 NoSQL 로의 &quot;창&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="02225ed0a1732c809d2ddd6d390df08a52bbc0f4" translate="yes" xml:space="preserve">
          <source>NoSQL</source>
          <target state="translated">NoSQL</target>
        </trans-unit>
        <trans-unit id="4c17fb7e44e47e1a6a86f326e6de0a2e62b6d69f" translate="yes" xml:space="preserve">
          <source>NoSQL data obtained from REST queries (requires compiling from source).</source>
          <target state="translated">REST 쿼리에서 얻은 NoSQL 데이터 (소스에서 컴파일해야 함)</target>
        </trans-unit>
        <trans-unit id="150a1e7e4bff5edac5f6c1545921993905c15df3" translate="yes" xml:space="preserve">
          <source>NoSQL new data type &lt;a href=&quot;../connect-mongo-table-type/index&quot;&gt;MONGO&lt;/a&gt; accessing MongoDB collections as relational tables.</source>
          <target state="translated">관계형 테이블로 MongoDB 콜렉션에 액세스하는 NoSQL 새 데이터 유형 &lt;a href=&quot;../connect-mongo-table-type/index&quot;&gt;MONGO&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d51f521264a75ed54739eaa9512995f83d808ab2" translate="yes" xml:space="preserve">
          <source>NoSQL query facilities for &lt;a href=&quot;../connect-json-table-type/index&quot;&gt;JSON&lt;/a&gt;, &lt;a href=&quot;../connect-xml-table-type/index&quot;&gt;XML&lt;/a&gt;, HTML files and using JSON UDFs.</source>
          <target state="translated">&lt;a href=&quot;../connect-json-table-type/index&quot;&gt;JSON&lt;/a&gt; , &lt;a href=&quot;../connect-xml-table-type/index&quot;&gt;XML&lt;/a&gt; , HTML 파일 및 JSON UDF 사용을 위한 NoSQL 쿼리 기능 .</target>
        </trans-unit>
        <trans-unit id="a83ae96ad27d41aac7a1d2eef4e577f23b6ad3e1" translate="yes" xml:space="preserve">
          <source>NoSQL table types</source>
          <target state="translated">NoSQL 테이블 유형</target>
        </trans-unit>
        <trans-unit id="89f4c779102ef4fb92872776c56a977889056be6" translate="yes" xml:space="preserve">
          <source>NoSQL-related commands and interfaces</source>
          <target state="translated">NoSQL 관련 명령 및 인터페이스</target>
        </trans-unit>
        <trans-unit id="e49665bce8dea5efc4d9c6e5ed7ba61cb392244f" translate="yes" xml:space="preserve">
          <source>Node Configuration</source>
          <target state="translated">노드 구성</target>
        </trans-unit>
        <trans-unit id="47ec8f6a1c13895a0c04af48889f4bad9297fefd" translate="yes" xml:space="preserve">
          <source>Node Ping test - ping test to remote nodes</source>
          <target state="translated">노드 핑 테스트-원격 노드에 대한 핑 테스트</target>
        </trans-unit>
        <trans-unit id="fd85bf8986f485f88de97a2e485e6d8aec1337a8" translate="yes" xml:space="preserve">
          <source>Node SSH test -- SSH login test to remote nodes</source>
          <target state="translated">노드 SSH 테스트-원격 노드에 대한 SSH 로그인 테스트</target>
        </trans-unit>
        <trans-unit id="2351921fbcea7ccb869f6fb3ffaabdfbb045411b" translate="yes" xml:space="preserve">
          <source>Node group, only used for MySQL Cluster, defaults to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">MySQL 클러스터에만 사용되는 노드 그룹의 기본값은 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="78192847842ebce74f26fb65a02aa408ecf57b4c" translate="yes" xml:space="preserve">
          <source>Node type</source>
          <target state="translated">노드 유형</target>
        </trans-unit>
        <trans-unit id="b202982c645c60426147504b245e7fd3370a9bcc" translate="yes" xml:space="preserve">
          <source>Nodes may have different table definitions, especially temporarily during &lt;a href=&quot;../galera-cluster-system-variables/index#wsrep_osu_method&quot;&gt;rolling schema upgrade&lt;/a&gt; operations, but the same &lt;a href=&quot;../replication-when-the-master-and-slave-have-different-table-definitions/index&quot;&gt;schema compatibility restrictions&lt;/a&gt; apply as they do for ROW based replication</source>
          <target state="translated">노드는 특히 &lt;a href=&quot;../galera-cluster-system-variables/index#wsrep_osu_method&quot;&gt;롤링 스키마 업그레이드&lt;/a&gt; 작업 중에 일시적으로 다른 테이블 정의를 가질 수 있지만 ROW 기반 복제 와 동일한 &lt;a href=&quot;../replication-when-the-master-and-slave-have-different-table-definitions/index&quot;&gt;스키마 호환성 제한이&lt;/a&gt; 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="7ff20370c8e04428109a1801a67963668dd6d1d0" translate="yes" xml:space="preserve">
          <source>Nom</source>
          <target state="translated">Nom</target>
        </trans-unit>
        <trans-unit id="bdc7ab16126589f949098e57c1b5539a8ac176ed" translate="yes" xml:space="preserve">
          <source>Nomenclature</source>
          <target state="translated">Nomenclature</target>
        </trans-unit>
        <trans-unit id="e6ede58b071116be0fde64f3eefb5295b7f5b815" translate="yes" xml:space="preserve">
          <source>Non Group commit logic (aria_group_commit=&quot;none&quot;)</source>
          <target state="translated">비 그룹 커밋 로직 (aria_group_commit = &quot;none&quot;)</target>
        </trans-unit>
        <trans-unit id="b93e6bf72025beaeaf9acb52f0c45d87e69fe60b" translate="yes" xml:space="preserve">
          <source>Non distributed install, i.e. ColumnStore software must be pre-installed on the other nodes.</source>
          <target state="translated">비 분산 설치, 즉 ColumnStore 소프트웨어는 다른 노드에 사전 설치되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="33a2f04bc5a50c6d8b5496a7d7fec9a72e9e1afb" translate="yes" xml:space="preserve">
          <source>Non matching attribute '%s' between partition and table</source>
          <target state="translated">파티션과 테이블간에 일치하지 않는 속성 '% s'</target>
        </trans-unit>
        <trans-unit id="1f333436bd15fc885ce3b5f02dd6c261a60e6b2f" translate="yes" xml:space="preserve">
          <source>Non-ASCII Character Sets with Oracle</source>
          <target state="translated">Oracle을 사용하는 비 ASCII 문자 세트</target>
        </trans-unit>
        <trans-unit id="4b3131f465d45f6b6bbead4ddc2569246ce57d7e" translate="yes" xml:space="preserve">
          <source>Non-ASCII separator arguments are not fully supported</source>
          <target state="translated">비 ASCII 구분자 인수는 완전히 지원되지 않습니다</target>
        </trans-unit>
        <trans-unit id="0ff4cfd47c5d022b62f534d44abe3a7be6e16fdd" translate="yes" xml:space="preserve">
          <source>Non-Capturing Groups</source>
          <target state="translated">캡처하지 않은 그룹</target>
        </trans-unit>
        <trans-unit id="443a8bf07464a49b57680d412d91c5d879aea608" translate="yes" xml:space="preserve">
          <source>Non-Distributed Install</source>
          <target state="translated">비 분산 설치</target>
        </trans-unit>
        <trans-unit id="4c35d2d736d44979fa19e1b34e9a5aa5fdb01d30" translate="yes" xml:space="preserve">
          <source>Non-Distributed Install by postConfigure will not have any interaction excluding a ping test during the configuration section to validate the IP address provided. With this option, it is up to the user to install the MariaDB ColumnStore packages on the non-pm1 nodes and startup the ColumnStore service before running postConfigure.</source>
          <target state="translated">postConfigure에 의한 비 분산 설치는 제공된 IP 주소의 유효성을 검사하기 위해 구성 섹션에서 핑 테스트를 제외한 상호 작용이 없습니다. 이 옵션을 사용하면 postConfigure를 실행하기 전에 비 PM1 노드에 MariaDB ColumnStore 패키지를 설치하고 ColumnStore 서비스를 시작하는 것은 사용자의 몫입니다.</target>
        </trans-unit>
        <trans-unit id="e3be81780408064ebdd35695b491c2820a3c7646" translate="yes" xml:space="preserve">
          <source>Non-Distributed Install does require an additional command line argument to be provided. The &quot;-n&quot; is the required argument as sown in this example:</source>
          <target state="translated">비 분산 설치에는 추가 명령 행 인수를 제공해야합니다. &quot;-n&quot;은이 예제에서 뿌린 필수 인수입니다.</target>
        </trans-unit>
        <trans-unit id="1dfd81deda4e182282dfde5b8a69241f6c50dd31" translate="yes" xml:space="preserve">
          <source>Non-Distributed Install example</source>
          <target state="translated">비 분산 설치 예</target>
        </trans-unit>
        <trans-unit id="75fdd1f8a5ade73653658f685f6dde68a6edca25" translate="yes" xml:space="preserve">
          <source>Non-Distributed Install is the default setting, so no additional command line arguments needs to be provided.</source>
          <target state="translated">비 분산 설치가 기본 설정이므로 추가 명령 줄 인수를 제공 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="9e3f02643d214027d06946d9f2aee5a6da1a9989" translate="yes" xml:space="preserve">
          <source>Non-Distributed Installation</source>
          <target state="translated">비 분산 설치</target>
        </trans-unit>
        <trans-unit id="c44e3fa25053c662938b929c70004195cbbc618a" translate="yes" xml:space="preserve">
          <source>Non-Distributed Installer when --dist-install when not specified</source>
          <target state="translated">지정되지 않은 경우 --dist-install시 비 분산 설치 프로그램</target>
        </trans-unit>
        <trans-unit id="12d60b01cd02785183866f650f427096eec9a93f" translate="yes" xml:space="preserve">
          <source>Non-Durable Binary Logs</source>
          <target state="translated">내구성이없는 이진 로그</target>
        </trans-unit>
        <trans-unit id="4b7b6ef31212256ed099b9d126cb23dcceff1dde" translate="yes" xml:space="preserve">
          <source>Non-Durable InnoDB Data</source>
          <target state="translated">내구성없는 InnoDB 데이터</target>
        </trans-unit>
        <trans-unit id="572c9bd88f1b8d1c4d473ee3a8ccc142ac8a64d5" translate="yes" xml:space="preserve">
          <source>Non-Durable InnoDB Data and Binary Logs</source>
          <target state="translated">내구성이없는 InnoDB 데이터 및 이진 로그</target>
        </trans-unit>
        <trans-unit id="e89add474dcb4e3cb01e40155e9138bd1b90886a" translate="yes" xml:space="preserve">
          <source>Non-Greedy Quantifiers</source>
          <target state="translated">칙칙하지 않은 정량 자</target>
        </trans-unit>
        <trans-unit id="e3872750c6983fa65722d01193f4c546b4a5e2a9" translate="yes" xml:space="preserve">
          <source>Non-INDEX Issues</source>
          <target state="translated">비 인덱스 문제</target>
        </trans-unit>
        <trans-unit id="6ee34b148259ed263ea71173232e3712e590bbaf" translate="yes" xml:space="preserve">
          <source>Non-Recursive</source>
          <target state="translated">Non-Recursive</target>
        </trans-unit>
        <trans-unit id="97f1735e3f917b019d6c26046d90208b1a91b82b" translate="yes" xml:space="preserve">
          <source>Non-Recursive CTEs</source>
          <target state="translated">비 재귀 CTE</target>
        </trans-unit>
        <trans-unit id="e09305da3933919b832c6787ba0a6ff90b6d4b77" translate="yes" xml:space="preserve">
          <source>Non-Recursive Common Table Expressions Overview</source>
          <target state="translated">비 재귀 공통 테이블 식 개요</target>
        </trans-unit>
        <trans-unit id="6db3e24a53c97951e1a6cdca45535cfcc07eafc0" translate="yes" xml:space="preserve">
          <source>Non-Root System, PrimProc Process fails to startup</source>
          <target state="translated">비 루트 시스템, PrimProc 프로세스가 시작되지 않음</target>
        </trans-unit>
        <trans-unit id="61a480109c05c2532fd0a6d69d3abf06248ea40d" translate="yes" xml:space="preserve">
          <source>Non-Root User Installs</source>
          <target state="translated">비 루트 사용자 설치</target>
        </trans-unit>
        <trans-unit id="9bc884247c8d9ad1c06490187128f91a4e4bd315" translate="yes" xml:space="preserve">
          <source>Non-aggregate window functions include</source>
          <target state="translated">집계되지 않은 창 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="01ffd2d8fa1d750c24fb3a7138f61d9c6900d11b" translate="yes" xml:space="preserve">
          <source>Non-ascii Symbols</source>
          <target state="translated">비 ASCII 기호</target>
        </trans-unit>
        <trans-unit id="a1d8ee3702770f875f9f6490cbf1ebee96fd7ece" translate="yes" xml:space="preserve">
          <source>Non-background Operations</source>
          <target state="translated">백그라운드가 아닌 작업</target>
        </trans-unit>
        <trans-unit id="dd48371c2aab8cf5ebc25cdfa4257bdd5217ca86" translate="yes" xml:space="preserve">
          <source>Non-canonical Storage Format Caused by Some Operations</source>
          <target state="translated">일부 작업으로 인한 비정규 스토리지 형식</target>
        </trans-unit>
        <trans-unit id="1d855d70d9c84bc22fb8e00993e3ee149ae402c2" translate="yes" xml:space="preserve">
          <source>Non-deterministic &lt;a href=&quot;../built-in-functions/index&quot;&gt;built-in functions&lt;/a&gt; are &lt;strong&gt;not&lt;/strong&gt; supported in expressions for &lt;code&gt;VIRTUAL&lt;/code&gt; generated columns.</source>
          <target state="translated">비 결정적 &lt;a href=&quot;../built-in-functions/index&quot;&gt;내장 함수&lt;/a&gt; 는 &lt;code&gt;VIRTUAL&lt;/code&gt; 생성 컬럼의 표현식에서 지원 &lt;strong&gt;되지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="a884f47327cfab01ccde4a636e8eb4b6cf035e0b" translate="yes" xml:space="preserve">
          <source>Non-deterministic &lt;a href=&quot;../built-in-functions/index&quot;&gt;built-in functions&lt;/a&gt; are &lt;strong&gt;not&lt;/strong&gt; supported in expressions for generated columns.</source>
          <target state="translated">비 결정적 &lt;a href=&quot;../built-in-functions/index&quot;&gt;내장 함수&lt;/a&gt; 는 생성 된 컬럼의 표현식에서 지원 &lt;strong&gt;되지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c157e26542594db442e63aa0697c0d5b4fa7c2d0" translate="yes" xml:space="preserve">
          <source>Non-deterministic &lt;a href=&quot;../built-in-functions/index&quot;&gt;built-in functions&lt;/a&gt; are supported in expressions for &lt;code&gt;PERSISTENT&lt;/code&gt; generated columns.</source>
          <target state="translated">비 결정적 &lt;a href=&quot;../built-in-functions/index&quot;&gt;내장 함수&lt;/a&gt; 는 &lt;code&gt;PERSISTENT&lt;/code&gt; 생성 열에 대한 표현식에서 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="9a4603b861513d715e05ea0b8731230da431e81b" translate="yes" xml:space="preserve">
          <source>Non-deterministic replication</source>
          <target state="translated">비 결정적 복제</target>
        </trans-unit>
        <trans-unit id="23f4578870d75bbe8387cafa5e685816f4970247" translate="yes" xml:space="preserve">
          <source>Non-distributed is the default distribution mode in postConfigure</source>
          <target state="translated">비 분배는 postConfigure의 기본 배포 모드입니다.</target>
        </trans-unit>
        <trans-unit id="ead33df30bf0648f3e225e33d0660d5a90075831" translate="yes" xml:space="preserve">
          <source>Non-durable Binary Log Settings</source>
          <target state="translated">내구성이없는 이진 로그 설정</target>
        </trans-unit>
        <trans-unit id="fb4a7bb7e2f07722cfa43623378e52503c7608b0" translate="yes" xml:space="preserve">
          <source>Non-grouping field '%s' is used in %s clause</source>
          <target state="translated">비 그룹화 필드 '% s'은 (는) % s 절에서 사용됩니다</target>
        </trans-unit>
        <trans-unit id="dd1a9d56cd0f4954447088b7848e282ea814628f" translate="yes" xml:space="preserve">
          <source>Non-overlapping 'polygon':</source>
          <target state="translated">겹치지 않는 '다각형':</target>
        </trans-unit>
        <trans-unit id="70f9864d61b2c837fa6d17db6fb19ff3defc2e1b" translate="yes" xml:space="preserve">
          <source>Non-recursive</source>
          <target state="translated">Non-recursive</target>
        </trans-unit>
        <trans-unit id="974a8b391828c3a7b1b2fa9579c3d03e2893d002" translate="yes" xml:space="preserve">
          <source>Non-root install, run as root user. The below example is assuming 'mysql' as the non-root user.</source>
          <target state="translated">비 루트 설치, 루트 사용자로 실행하십시오. 아래 예제는 루트가 아닌 사용자로 'mysql'을 가정 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="e854be5c7ffb1907adcd596c2833d28c184d730c" translate="yes" xml:space="preserve">
          <source>Non-root user &quot;guest&quot; is used in this example</source>
          <target state="translated">이 예에서는 루트가 아닌 사용자 &quot;guest&quot;가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bf8b02185915c1b6d7f24988780f069c750f3861" translate="yes" xml:space="preserve">
          <source>Non-root user &quot;mysql&quot; is used in this example</source>
          <target state="translated">이 예에서는 루트가 아닌 사용자 &quot;mysql&quot;이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5a4186b8777eced18e4470ae82fb22c36d56518a" translate="yes" xml:space="preserve">
          <source>Non-root user MariaDB ColumnStore Admin console</source>
          <target state="translated">비 루트 사용자 MariaDB ColumnStore 관리 콘솔</target>
        </trans-unit>
        <trans-unit id="662e636f8306949f187519a4243cb38497842820" translate="yes" xml:space="preserve">
          <source>Non-root user installs</source>
          <target state="translated">비 루트 사용자 설치</target>
        </trans-unit>
        <trans-unit id="cba0ec64af8bfd1592c779910643ea96b12f9fe7" translate="yes" xml:space="preserve">
          <source>Non-root user sudo setup</source>
          <target state="translated">비 루트 사용자 sudo 설정</target>
        </trans-unit>
        <trans-unit id="b6d4e12f5dc0633cef4ce4e66fb4ffd27ce08350" translate="yes" xml:space="preserve">
          <source>Non-root user, since the MariaDB Server runs under the user mysql, you can also install the MariaDB ColumnStore package and run as the mysql user.</source>
          <target state="translated">루트가 아닌 사용자 MariaDB 서버는 사용자 mysql에서 실행되므로 MariaDB ColumnStore 패키지를 설치하고 mysql 사용자로 실행할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5724355862117d3abe20ae2afbc35c697db9a7b1" translate="yes" xml:space="preserve">
          <source>Non-root user, since the MariaDB Server runs under the user mysql, you can also install the MariaDB ColumnStore package and run as the mysql user. So below where it shows 'guest' as the user, you can substitute 'mysql'.</source>
          <target state="translated">루트가 아닌 사용자 MariaDB 서버는 사용자 mysql에서 실행되므로 MariaDB ColumnStore 패키지를 설치하고 mysql 사용자로 실행할 수도 있습니다. 따라서 사용자로 'guest'가 표시되는 곳에서 'mysql'을 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="747997161b3a86f0138eaea8a4e51ed8cddc8751" translate="yes" xml:space="preserve">
          <source>Non-scrollable means that the rows can only be fetched in the order specified by the SELECT statement. Rows cannot be skipped, you cannot jump to a specific row, and you cannot fetch rows in reverse order.</source>
          <target state="translated">스크롤 불가능은 행을 SELECT 문으로 지정된 순서로만 페치 할 수 있음을 의미합니다. 행을 건너 뛸 수 없으며 특정 행으로 이동할 수 없으며 행을 역순으로 가져올 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e78eb5df195583a03cf49c5fa56ff5d0743a2794" translate="yes" xml:space="preserve">
          <source>Non-semi-join &lt;a href=&quot;../non-semi-join-subquery-optimizations/index#materialization-for-non-correlated-in-subqueries&quot;&gt;Materialization&lt;/a&gt; (including NULL-aware and partial matching)</source>
          <target state="translated">세미-세인 &lt;a href=&quot;../non-semi-join-subquery-optimizations/index#materialization-for-non-correlated-in-subqueries&quot;&gt;구체화&lt;/a&gt; (NULL 인식 및 부분 일치 포함)</target>
        </trans-unit>
        <trans-unit id="651aa8953f261a48569457a5968a54bee4b07a95" translate="yes" xml:space="preserve">
          <source>Non-semi-join Subquery Optimizations</source>
          <target state="translated">비 세미 조인 하위 쿼리 최적화</target>
        </trans-unit>
        <trans-unit id="234a623f6ba9a7ff287ed003837119c0295841fe" translate="yes" xml:space="preserve">
          <source>Non-spacing mark</source>
          <target state="translated">비 간격 마크</target>
        </trans-unit>
        <trans-unit id="1d2aed35161eb3f8362ad9d209195e6db38df935" translate="yes" xml:space="preserve">
          <source>Non-transactional DML and DDL is not safe to optimistically apply in parallel, as it cannot be rolled back in case of conflicts. Thus, in optimistic mode, non-transactional (such as MyISAM) updates are not applied in parallel with earlier events (it is however possible to apply a MyISAM update in parallel with a later InnoDB update). DDL statements are not applied in parallel with any other transactions, earlier or later.</source>
          <target state="translated">비 트랜잭션 DML과 DDL은 충돌시 롤백 할 수 없으므로 낙관적으로 병렬로 적용하는 것이 안전하지 않습니다. 따라서 낙관적 모드에서 비 트랜잭션 (예 : MyISAM) 업데이트는 이전 이벤트와 병렬로 적용되지 않습니다 (단, 이후 InnoDB 업데이트와 동시에 MyISAM 업데이트를 적용 할 수 있음). DDL 문은 다른 트랜잭션과 동시에 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="205ceec02b96824380ef7796616dd210694fec63" translate="yes" xml:space="preserve">
          <source>Non-transactional INSERT ... SELECT is directed to ColumnStores cpimport tool by default, which significantly increases performance.</source>
          <target state="translated">비 트랜잭션 INSERT ... SELECT는 기본적으로 ColumnStores cpimport 도구로 보내 지므로 성능이 크게 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="10c3435d9a387dd0f74e714a127e58d5dbfbe258" translate="yes" xml:space="preserve">
          <source>Non-transactional LOAD DATA INFILE is directed to ColumnStores cpimport tool by default, which significantly increases performance.</source>
          <target state="translated">비 트랜잭션 LOAD DATA INFILE은 기본적으로 ColumnStores cpimport 도구로 보내 지므로 성능이 크게 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="651d9879329f607bc9c33cb09ab2f26bc41ef893" translate="yes" xml:space="preserve">
          <source>Non-transactional reads or writes that execute after transactional reads within a transaction.</source>
          <target state="translated">트랜잭션 내에서 트랜잭션을 읽은 후에 실행되는 비 트랜잭션 읽기 또는 쓰기</target>
        </trans-unit>
        <trans-unit id="ba3cfd327623528bd186466dfea1f732e0d75725" translate="yes" xml:space="preserve">
          <source>Non-transactional storage engine with good performance and small data footprint.</source>
          <target state="translated">성능이 우수하고 데이터 공간이 작은 비 트랜잭션 스토리지 엔진</target>
        </trans-unit>
        <trans-unit id="31ef69f9d72a2a32146baa584bfe56a1ecf73c35" translate="yes" xml:space="preserve">
          <source>Non-zero values of &lt;code&gt;Handler_mrr_key_refills&lt;/code&gt; and/or &lt;code&gt;Handler_mrr_rowid_refills&lt;/code&gt; mean that Multi Range Read scan did not have enough memory and had to do multiple key/rowid sort-and-sweep passes. The greatest speedup is achieved when Multi Range Read runs everything in one pass, if you see lots of refills it may be beneficial to increase sizes of relevant buffers &lt;a href=&quot;../server-system-variables/index#mrr_buffer_size&quot;&gt;mrr_buffer_size&lt;/a&gt;&lt;a href=&quot;../server-system-variables/index#join_buffer_size&quot;&gt;join_buffer_size&lt;/a&gt; and &lt;a href=&quot;../server-system-variables/index#join_buffer_space_limit&quot;&gt;join_buffer_space_limit&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;Handler_mrr_key_refills&lt;/code&gt; 및 / 또는 &lt;code&gt;Handler_mrr_rowid_refills&lt;/code&gt; 의 0이 아닌 값은 다중 범위 읽기 스캔에 충분한 메모리가없고 여러 키 / 행 정렬 및 스윕 패스를 수행해야 함을 의미합니다. 다중 범위 읽기가 한 번에 모든 것을 실행할 때 가장 빠른 속도를 달성 할 수 있습니다. 많은 리필이 표시되면 관련 버퍼의 크기를 늘리는 것이 유리할 수 있습니다. &lt;a href=&quot;../server-system-variables/index#mrr_buffer_size&quot;&gt;mrr_buffer_size &lt;/a&gt;&lt;a href=&quot;../server-system-variables/index#join_buffer_size&quot;&gt;join_buffer_size&lt;/a&gt; 및 &lt;a href=&quot;../server-system-variables/index#join_buffer_space_limit&quot;&gt;join_buffer_space_limit&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e1a268c3266dcf6f02611fd03d43b40d0a379e09" translate="yes" xml:space="preserve">
          <source>None of the provided routines JOIN to the other table; you may wish to develop custom queries based on the given reference Stored Procedures.</source>
          <target state="translated">제공된 루틴 중 어느 것도 다른 테이블에 참여하지 않습니다. 주어진 참조 저장 프로 시저를 기반으로 사용자 지정 쿼리를 개발할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f66ad6b146b8d43057663e9964ad9320d75d7809" translate="yes" xml:space="preserve">
          <source>None of the queries presented here need a full table (or index) scan. Each has a time proportional to the number of rows returned.</source>
          <target state="translated">여기에 제시된 쿼리는 전체 테이블 (또는 인덱스) 스캔이 필요하지 않습니다. 각각은 리턴 된 행 수에 비례 한 시간을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="fdd711ea709f740d7d96f7c9cd5ba64db57ab80d" translate="yes" xml:space="preserve">
          <source>Normal database files are local and as such: You create a table called 'users', a file such as 'users.MYD' is created. A handler reads, inserts, deletes, updates data in this file. The data is stored in particular format, so to read, that data has to be parsed into fields, to write, fields have to be stored in this format to write to this data file.</source>
          <target state="translated">일반 데이터베이스 파일은 로컬이며 다음과 같습니다. 'users'라는 테이블을 만들고 'users.MYD'와 같은 파일을 만듭니다. 핸들러는이 파일의 데이터를 읽고, 삽입하고, 삭제하고, 업데이트합니다. 데이터는 특정 형식으로 저장되므로 읽 기 위해서는 데이터를 필드로 구문 분석하고 기록하기 위해 필드를이 형식으로 저장하여이 데이터 파일에 기록해야합니다.</target>
        </trans-unit>
        <trans-unit id="bcad6f3bac2acce792e27c52148f493e1afafb2e" translate="yes" xml:space="preserve">
          <source>Normal files created by the storage engine use this pattern for names. The extension depends on the storage engine.</source>
          <target state="translated">스토리지 엔진으로 작성된 일반 파일은 이름에이 패턴을 사용합니다. 확장은 스토리지 엔진에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="b497e41862f9698e00a54bee658bead48ffe4415" translate="yes" xml:space="preserve">
          <source>Normal-size (double-precision) floating-point number</source>
          <target state="translated">보통 크기 (배정 밀도) 부동 소수점 숫자</target>
        </trans-unit>
        <trans-unit id="b8c54e5e1e867a54e9d75697c450f4be835f910e" translate="yes" xml:space="preserve">
          <source>Normalization</source>
          <target state="translated">Normalization</target>
        </trans-unit>
        <trans-unit id="a68a85e38c270403d6016dac651716eb62463798" translate="yes" xml:space="preserve">
          <source>Normalization (Dimension) table</source>
          <target state="translated">정규화 (차원) 테이블</target>
        </trans-unit>
        <trans-unit id="0e8dd9d861f53e082a485936ed7131650f945995" translate="yes" xml:space="preserve">
          <source>Normalization -- The process of building the mapping ('New York City' &amp;lt;-&amp;gt; 123)</source>
          <target state="translated">정규화-매핑 작성 프로세스 ( 'New York City'&amp;lt;-&amp;gt; 123)</target>
        </trans-unit>
        <trans-unit id="516853315ff084467713f89094e2d032d2dbb226" translate="yes" xml:space="preserve">
          <source>Normalization and Summarization reads Staging, not Fact.</source>
          <target state="translated">정규화 및 요약은 사실이 아니라 스테이징을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="103e42ec4046f2f55bc1f0fd5d545c72474b61f6" translate="yes" xml:space="preserve">
          <source>Normalization can be done in bulk, hence efficiently</source>
          <target state="translated">정규화를 대량으로 수행 할 수 있으므로 효율적으로</target>
        </trans-unit>
        <trans-unit id="f500aba69f99b6dbba0616fe05c26263becda122" translate="yes" xml:space="preserve">
          <source>Normalization is important in Data Warehouse applications because it significantly cuts down on the disk footprint and improves performance. There are other reasons for normalizing, but space is the important one for DW.</source>
          <target state="translated">정규화는 디스크 풋 프린트를 크게 줄이고 성능을 향상 시키므로 Data Warehouse 애플리케이션에서 중요합니다. 정규화에는 다른 이유가 있지만 공간은 DW의 중요한 이유입니다.</target>
        </trans-unit>
        <trans-unit id="d195ab87b60290eab729848a60ca9ddd922dc00a" translate="yes" xml:space="preserve">
          <source>Normalization sends only the few updates to the normalization tables.</source>
          <target state="translated">정규화는 몇 가지 업데이트 만 정규화 테이블로 보냅니다.</target>
        </trans-unit>
        <trans-unit id="a72f2e3d2de5ef27f091d7b002c57e1612e3ea72" translate="yes" xml:space="preserve">
          <source>Normalization table (dimension table) -- mapping between strings an ids; used for space and speed.</source>
          <target state="translated">정규화 테이블 (차원 테이블)-문자열과 ID 간의 매핑; 공간과 속도에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fd7dfefd1069d785bd343523363a4fb73a95ba2c" translate="yes" xml:space="preserve">
          <source>Normalization tables -- InnoDB, primarily because it can be done efficiently with 2 indexes, whereas, MyISAM would need 4 to achieve the same efficiency.</source>
          <target state="translated">정규화 테이블-InnoDB는 주로 2 개의 인덱스로 효율적으로 수행 할 수 있기 때문에 MyISAM은 동일한 효율성을 달성하기 위해 4가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="92cfa2b98d55673d7a7c8ab39339f0febe14fe49" translate="yes" xml:space="preserve">
          <source>Normalize from `Staging` -- use code in Case 3.</source>
          <target state="translated">스테이징에서 정규화-사례 3의 코드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1020b34023d593ea30484e4a738ed5090b68de17" translate="yes" xml:space="preserve">
          <source>Normalized statements with data values removed</source>
          <target state="translated">데이터 값이 제거 된 정규화 된 명령문</target>
        </trans-unit>
        <trans-unit id="2dad10305ce34102358d2dce83ff70ff3965949e" translate="yes" xml:space="preserve">
          <source>Normally &lt;a href=&quot;../insert/index&quot;&gt;INSERT&lt;/a&gt; stops and rolls back when it encounters an error.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;../insert/index&quot;&gt;INSERT&lt;/a&gt; 는 오류가 발생하면 중지되고 롤백됩니다.</target>
        </trans-unit>
        <trans-unit id="69a922f58630cf7e815ad15469f6b19d7cc07b14" translate="yes" xml:space="preserve">
          <source>Normally &lt;a href=&quot;../rollback/index&quot;&gt;ROLLBACK&lt;/a&gt; undoes the changes performed by the whole transaction. When used with the TO clause, it undoes the changes performed after the specified savepoint, and erases all subsequent savepoints. However, all locks that have been acquired after the save point will survive. RELEASE SAVEPOINT does not rollback or commit any changes, but removes the specified savepoint.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;../rollback/index&quot;&gt;ROLLBACK&lt;/a&gt; 은 전체 트랜잭션에 의해 수행 된 변경 사항을 취소합니다. TO 절과 함께 사용하면 지정된 저장 점 이후에 수행 된 변경 사항을 취소하고 이후의 모든 저장 점을 지 웁니다. 그러나 저장 점 이후에 획득 한 모든 잠금은 유지됩니다. RELEASE SAVEPOINT는 롤백하거나 변경 사항을 커밋하지 않지만 지정된 세이브 포인트를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="da9788c4f42f6adabc009e5bc770fc6626098a9a" translate="yes" xml:space="preserve">
          <source>Normally &lt;code&gt;00&lt;/code&gt;, but &lt;code&gt;11&lt;/code&gt; for &quot;no-rollback tables&quot; (&lt;a href=&quot;../what-is-mariadb-103/index&quot;&gt;MariaDB 10.3&lt;/a&gt; CREATE SEQUENCE). In &lt;a href=&quot;../what-is-mariadb-101/index&quot;&gt;MariaDB 10.1&lt;/a&gt;, these bits could be &lt;code&gt;01&lt;/code&gt; or &lt;code&gt;10&lt;/code&gt; for ATOMIC_WRITES=ON or ATOMIC_WRITES=OFF.</source>
          <target state="translated">일반적으로 &lt;code&gt;00&lt;/code&gt; 이지만 &quot;롤백 없음 테이블&quot;의 경우 &lt;code&gt;11&lt;/code&gt; 입니다 ( &lt;a href=&quot;../what-is-mariadb-103/index&quot;&gt;MariaDB 10.3&lt;/a&gt; CREATE SEQUENCE). 에서는 &lt;a href=&quot;../what-is-mariadb-101/index&quot;&gt;MariaDB 10.1&lt;/a&gt; , 이러한 비트 수 있었다 &lt;code&gt;01&lt;/code&gt; 또는 &lt;code&gt;10&lt;/code&gt; ATOMIC_WRITES = ON 또는 OFF ATOMIC_WRITES = 대한.</target>
        </trans-unit>
        <trans-unit id="79420ddfeeea54931f931f3ba3540e4af970c451" translate="yes" xml:space="preserve">
          <source>Normally &lt;code&gt;OLD_MODE&lt;/code&gt; should be empty. It's mainly used to get old behavior when switching to MariaDB or to a new major version of MariaDB, until you have time to fix your application.</source>
          <target state="translated">일반적으로 &lt;code&gt;OLD_MODE&lt;/code&gt; 는 비어 있어야합니다. 주로 응용 프로그램을 수정할 때까지 MariaDB 또는 새로운 주요 MariaDB 버전으로 전환 할 때 이전 동작을 수행하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="78f723eea3977312eb42589e52d1c9f11a09e613" translate="yes" xml:space="preserve">
          <source>Normally CACHE INDEX should not take a long time to execute. Internally it's implemented the following way:</source>
          <target state="translated">일반적으로 CACHE INDEX를 실행하는 데 시간이 오래 걸리지 않아야합니다. 내부적으로 다음과 같이 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="d72e2f8df7f4c4d18cdeedbf4af34110652d97fb" translate="yes" xml:space="preserve">
          <source>Normally the activation of a sync point is cleared when it has been executed. Sometimes it is necessary to keep the sync point active for another execution. You can add an execute count to the action:</source>
          <target state="translated">일반적으로 동기 점의 활성화는 실행되면 지워집니다. 다른 실행을 위해 동기 점을 활성 상태로 유지해야하는 경우가 있습니다. 조치에 실행 횟수를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb6c9d2a003117d49215f9363021d7de17babe03" translate="yes" xml:space="preserve">
          <source>Normally this internal state is not needed by users, as @@gtid_binlog_pos is more useful in most cases. The main usage of @@gtid_binlog_state is to restore the state of the binlog after RESET MASTER (or equivalently if the binlog files are lost). If the value of @@gtid_binlog_state is saved before RESET MASTER and restored afterwards, the master will retain information about past history, same as if PURGE BINARY LOGS had been used (of course the actual events in the binary logs are still deleted).</source>
          <target state="translated">@@ gtid_binlog_pos가 대부분의 경우에 더 유용하므로 일반적으로이 내부 상태는 사용자에게 필요하지 않습니다. @@ gtid_binlog_state의 주요 사용법은 RESET MASTER 후 binlog의 상태를 복원하는 것입니다 (또는 binlog 파일이 손실 된 경우와 동일). @@ gtid_binlog_state의 값이 RESET MASTER 전에 저장되고 나중에 복원되면 마스터는 PURGE BINARY LOGS가 사용 된 것처럼 (이진 로그의 실제 이벤트는 여전히 삭제됨) 과거 기록에 대한 정보를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="e145797377f1326c39a4fa385f191c866a7e923c" translate="yes" xml:space="preserve">
          <source>Normally, MySQL's replication system can replicate trigger actions automatically.</source>
          <target state="translated">일반적으로 MySQL의 복제 시스템은 트리거 동작을 자동으로 복제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5278a301741ff5c623254bea0e339d815ef43ed0" translate="yes" xml:space="preserve">
          <source>Normally, RAM is 'paged' in 4KB pieces; the TLB actually maps the top (64-12) bits into a specific page. Then the bottom 12 bits of the virtual address are carried over intact.</source>
          <target state="translated">일반적으로 RAM은 4KB 단위로 '페이징'됩니다. TLB는 실제로 최상위 (64-12) 비트를 특정 페이지에 매핑합니다. 그런 다음 가상 주소의 맨 아래 12 비트가 그대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="547a1bf60c7948bb3dcb74818af34546161d5b9a" translate="yes" xml:space="preserve">
          <source>Normally, a long-running ALTER TABLE or other query will stall all following transactions, causing the slave to become behind the master as least as long time as it takes to run the long-running query. By using out-of-order parallel replication by setting the replication domain id, this can be avoided. The DBA/application must ensure that no conflicting transactions will be replicated while the ALTER TABLE runs.</source>
          <target state="translated">일반적으로 장기 실행 ALTER TABLE 또는 기타 쿼리는 다음과 같은 모든 트랜잭션을 중단하여 슬레이브가 장기 실행 쿼리를 실행하는 데 걸리는 시간만큼 마스터 뒤에있게됩니다. 복제 도메인 ID를 설정하여 비 순차 병렬 복제를 사용하면이를 피할 수 있습니다. DBA / 응용 프로그램은 ALTER TABLE이 실행되는 동안 충돌하는 트랜잭션이 복제되지 않도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="db413ce16f815359a66a501c5bc3df79e15d285b" translate="yes" xml:space="preserve">
          <source>Normally, a slave server should not receive direct updates (as this creates binlog differences compared to the master). Thus it does not matter what value of gtid_domain_id is set on a slave, though it may make sense to make it the same as the master (if not using multi-master) to make it easy to promote the slave as a new master. Of course, if a slave is itself an active master, as in a multi-master ring topology, the domain ID should be set according to the server's role as active master.</source>
          <target state="translated">일반적으로 슬레이브 서버는 직접 업데이트를받지 않아야합니다 (마스터와 비교하여 binlog 차이가 발생 함). 따라서 슬레이브에 gtid_domain_id 값을 설정하는 것은 중요하지 않지만 슬레이브를 새 마스터로 쉽게 승격시킬 수 있도록 마스터와 동일하게 만드는 것이 좋습니다 (멀티 마스터를 사용하지 않는 경우). 물론 다중 마스터 링 토폴로지에서와 같이 슬레이브 자체가 활성 마스터 인 경우 도메인 ID는 서버의 활성 마스터 역할에 따라 설정되어야합니다.</target>
        </trans-unit>
        <trans-unit id="e4c241a31a671010da75570d4e9db4726c65bd44" translate="yes" xml:space="preserve">
          <source>Normally, adding a column to a table requires the full table to be rebuilt. The complexity of the operation is proportional to the size of the table, or O(n&amp;middot;m) where n is the number of rows in the table and m is the number of indexes.</source>
          <target state="translated">일반적으로 테이블에 열을 추가하려면 전체 테이블을 다시 작성해야합니다. 연산의 복잡성은 테이블의 크기 또는 O (n &amp;middot; m)에 비례합니다. 여기서 n은 테이블의 행 수이고 m은 인덱스 수입니다.</target>
        </trans-unit>
        <trans-unit id="7886d4628791a3284c05198189734d3ff0a7d355" translate="yes" xml:space="preserve">
          <source>Normally, all changes that are logged as events in the &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt; are also replicated to all slaves (though still subject to filtering by &lt;code&gt;--replicate-do-xxx&lt;/code&gt;, &lt;code&gt;--replicate-ignore-xxx&lt;/code&gt;, and similar options). However, sometimes it may be desirable to have certain events be logged into the binlog, but not be replicated to all or a subset of slaves, where the distinction between events that should be replicated or not is under the control of the application making the changes.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;../binary-log/index&quot;&gt;이진 로그에&lt;/a&gt; 이벤트로 기록 된 모든 변경 사항은 모든 슬레이브에도 복제됩니다 (여전히 &lt;code&gt;--replicate-do-xxx&lt;/code&gt; , &lt;code&gt;--replicate-ignore-xxx&lt;/code&gt; 및 이와 유사한 옵션 으로 필터링 ). 그러나 때때로 특정 이벤트를 binlog에 기록하는 것이 바람직하지만 슬레이브의 전체 또는 서브 세트에 복제하지 않는 것이 좋을 수 있습니다. 여기서 복제 여부와 상관없이 이벤트를 구별하는 것은 응용 프로그램이 제어하는 ​​변경 사항입니다 .</target>
        </trans-unit>
        <trans-unit id="b5d08701cf54f55cf506b1cbdcf1feb5aff95410" translate="yes" xml:space="preserve">
          <source>Normally, hexadecimal literals are interpreted as binary string, where each pair of digits represents a character. When used in a numeric context, they are interpreted as integers. (See the example below). In no case can a hexadecimal literal be a decimal number.</source>
          <target state="translated">일반적으로 16 진 리터럴은 이진수 문자열로 해석되며 각 숫자 쌍은 문자를 나타냅니다. 숫자 컨텍스트에서 사용되는 경우 정수로 해석됩니다. (아래 예 참조). 어떠한 경우에도 16 진 리터럴은 10 진수 일 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="09fd2bcfa15b8db8cb9c16b58e7ac18d28b5981a" translate="yes" xml:space="preserve">
          <source>Normally, mysql-test-run.pl exits if a test case fails. &lt;code&gt;--force&lt;/code&gt; causes execution to continue regardless of test case failure.</source>
          <target state="translated">테스트 케이스가 실패하면 일반적으로 mysql-test-run.pl이 종료됩니다. &lt;code&gt;--force&lt;/code&gt; 는 테스트 사례 실패에 관계없이 실행이 계속되도록합니다.</target>
        </trans-unit>
        <trans-unit id="0c75824c8b1e8e0eb6192740f7aed4a64f194f3d" translate="yes" xml:space="preserve">
          <source>Normally, the default parameters should enable the &lt;code&gt;PROXY&lt;/code&gt; table to reconnect the server. However, an issue is when the current user was logged using a password. The security protocol prevents CONNECT to retrieve this password and requires it to be given in the &lt;code&gt;PROXY&lt;/code&gt; table create statement. For instance adding to it:</source>
          <target state="translated">일반적으로 기본 매개 변수는 &lt;code&gt;PROXY&lt;/code&gt; 테이블이 서버를 다시 연결하도록합니다. 그러나 현재 사용자가 비밀번호를 사용하여 로그인 한 경우 문제가 발생합니다. 보안 프로토콜은 CONNECT가이 비밀번호를 검색하지 못하도록하고 &lt;code&gt;PROXY&lt;/code&gt; 테이블 작성 명령문에 제공해야합니다. 예를 들어 추가 :</target>
        </trans-unit>
        <trans-unit id="ef891b320d8396bce4c8a72dbce55076ec157d78" translate="yes" xml:space="preserve">
          <source>Normally, when running with the prepared statement protocol with warnings enabled and executing a statement that returns a result set (like SELECT), warnings that occur during the execute phase are shown, but warnings that occur during the prepare phase are ''not'' shown. The reason for this is that some warnings are returned both during prepare and execute; if both copies of warnings were shown, then test cases would show different number of warnings between prepared statement execution and normal execution (where there is no prepare phase).</source>
          <target state="translated">일반적으로 경고가 활성화 된 준비된 명령문 프로토콜로 실행하고 SELECT와 같은 결과 세트를 리턴하는 명령문을 실행할 때 실행 단계 중에 발생하는 경고가 표시되지만 준비 단계 중에 발생하는 경고는 ''아닙니다 '' 표시. 그 이유는 준비 및 실행 중에 일부 경고가 반환되기 때문입니다. 두 경고 사본이 모두 표시되면 테스트 케이스는 준비된 명령문 실행과 정상 실행 (준비 단계가없는 경우)간에 서로 다른 수의 경고를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="9010378cbfe4cf3613887e501c94eac9a7c20b33" translate="yes" xml:space="preserve">
          <source>Normally, you should use &lt;a href=&quot;../dynamic-columns/index#dynamic-columns-functions&quot;&gt;Dynamic column functions&lt;/a&gt; which are run inside the MariaDB server and allow one to access Dynamic Columns content without any client-side libraries.</source>
          <target state="translated">일반적으로 MariaDB 서버 내에서 실행되는 &lt;a href=&quot;../dynamic-columns/index#dynamic-columns-functions&quot;&gt;동적 열 함수&lt;/a&gt; 를 사용해야 하며 클라이언트 측 라이브러리없이 동적 열 내용에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="988455e67df7cd81d090ea4bacdc05f39fb7caa5" translate="yes" xml:space="preserve">
          <source>Norway</source>
          <target state="translated">Norway</target>
        </trans-unit>
        <trans-unit id="79b723002f87708ebc11fd4f3b902a03f7c9a5c1" translate="yes" xml:space="preserve">
          <source>Norwegian</source>
          <target state="translated">Norwegian</target>
        </trans-unit>
        <trans-unit id="a825ce53f56742406a61c2e74ce307879ea0851f" translate="yes" xml:space="preserve">
          <source>Norwegian(Bokm&amp;aring;l)</source>
          <target state="translated">Norwegian(Bokm&amp;aring;l)</target>
        </trans-unit>
        <trans-unit id="3adf6135aa313ae8195601fb7dfd60aa1d1aaa41" translate="yes" xml:space="preserve">
          <source>Norwegian-ny (Nynorsk)</source>
          <target state="translated">노르웨이어-니 (니 노르 스크)</target>
        </trans-unit>
        <trans-unit id="84419e92f882ce8b634fd2e68ebba148c3019195" translate="yes" xml:space="preserve">
          <source>Not Equal Operator: !=</source>
          <target state="translated">같지 않은 연산자 :! =</target>
        </trans-unit>
        <trans-unit id="0903b4417f7c8800893c3b1c14c1f76950dc61fe" translate="yes" xml:space="preserve">
          <source>Not a multiple table (the default). This can be used in an alter table statement.</source>
          <target state="translated">다중 테이블이 아닙니다 (기본값). 이것은 alter table 문에서 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="041d65af2db05ed04b994f8d33da4b94dd52bafe" translate="yes" xml:space="preserve">
          <source>Not all characters that are allowed in table names can be used in file names. Every filesystem has its own rules of what characters can be used in file names. To let the user create tables using all characters allowed in the SQL Standard and to not depend on whatever particular filesystem a particular database resides, MariaDB encodes &quot;potentially unsafe&quot; characters in the table name to derive the corresponding file name.</source>
          <target state="translated">테이블 이름에 허용되는 모든 문자를 파일 이름에 사용할 수있는 것은 아닙니다. 모든 파일 시스템에는 파일 이름에 사용할 수있는 문자 규칙이 있습니다. 사용자가 SQL 표준에 허용 된 모든 문자를 사용하여 테이블을 작성하고 특정 데이터베이스가있는 특정 파일 시스템에 의존하지 않도록하기 위해 MariaDB는 테이블 이름에 &quot;안전하지 않은&quot;문자를 인코딩하여 해당 파일 이름을 파생시킵니다.</target>
        </trans-unit>
        <trans-unit id="5d182e80000fd013614df895ec6e44e5cad160af" translate="yes" xml:space="preserve">
          <source>Not all floating-point numbers can be stored with exact precision</source>
          <target state="translated">모든 부동 소수점 숫자를 정확한 정밀도로 저장할 수있는 것은 아닙니다</target>
        </trans-unit>
        <trans-unit id="13111547fd815e10a29684d2d92636390fa084ab" translate="yes" xml:space="preserve">
          <source>Not all global status variables support being reset by &lt;code&gt;FLUSH STATUS&lt;/code&gt;. Currently, the following status variables are reset by &lt;code&gt;FLUSH STATUS&lt;/code&gt;:</source>
          <target state="translated">모든 전역 상태 변수가 &lt;code&gt;FLUSH STATUS&lt;/code&gt; 에 의해 재설정되는 것을 지원하지는 않습니다 . 현재 다음 상태 변수는 &lt;code&gt;FLUSH STATUS&lt;/code&gt; 에 의해 재설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="62dfd0f2d6c39a87e8b8bbda8f79bc107a7ca25a" translate="yes" xml:space="preserve">
          <source>Not all server-side authentication plugins are installed by default. If a specific server-side authentication plugin is not installed by default, then you can find the installation procedure on the documentation page for the specific authentication plugin.</source>
          <target state="translated">모든 서버 측 인증 플러그인이 기본적으로 설치되는 것은 아닙니다. 특정 서버 측 인증 플러그인이 기본적으로 설치되어 있지 않은 경우 특정 인증 플러그인의 설명서 페이지에서 설치 절차를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6cf356d55e41638ca8bbe9698be37179869840ab" translate="yes" xml:space="preserve">
          <source>Not all statements can be prepared. Only the following SQL commands are permitted:</source>
          <target state="translated">모든 진술을 준비 할 수있는 것은 아닙니다. 다음 SQL 명령 만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="19a944035220e475c7d31f3d35e0af277fa1cd75" translate="yes" xml:space="preserve">
          <source>Not all tests will necessarily run for all combinations. A particular test may require to be run only in one specific combination. For example, in replication, if a test can only be run with the row binlog format, it will have &lt;code&gt;--binlog-format=row&lt;/code&gt; in one of the &lt;code&gt;.opt&lt;/code&gt; files. In this case, mtr will notice that server command line already has an option that matches one of the combinations, and will skip all other combinations for this particular test.</source>
          <target state="translated">모든 테스트가 모든 조합에 대해 반드시 실행되는 것은 아닙니다. 특정 테스트는 하나의 특정 조합으로 만 실행해야 할 수도 있습니다. 예를 들어, 복제에서 테스트가 행 binlog 형식으로 만 실행될 수 있는 경우 &lt;code&gt;.opt&lt;/code&gt; 파일 중 하나에 &lt;code&gt;--binlog-format=row&lt;/code&gt; 가 있습니다. 이 경우 mtr은 서버 명령 행에 이미 조합 중 하나와 일치하는 옵션이 있으며이 특정 테스트에 대한 다른 모든 조합을 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="4e7d03ae1f8c88672c5affeeaa543426480297e2" translate="yes" xml:space="preserve">
          <source>Not allowed to return a result set from a %s</source>
          <target state="translated">% s에서 결과 세트를 리턴 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b54474e74555a65eee8ac9ca4e52b87782f480b7" translate="yes" xml:space="preserve">
          <source>Not allowed to set autocommit from a stored function or trigger</source>
          <target state="translated">저장된 기능 또는 트리거에서 자동 커밋을 설정할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="e67fb1ae8839b21d1c033043d2eadde43279bec6" translate="yes" xml:space="preserve">
          <source>Not allowed to use NULL value in VALUES LESS THAN</source>
          <target state="translated">VALUES LESS THAN에서 NULL 값을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c500b16277c666da560b9b821e99d42117dbcff9" translate="yes" xml:space="preserve">
          <source>Not complete yet - still being updated</source>
          <target state="translated">아직 완료되지 않았습니다-여전히 업데이트 중</target>
        </trans-unit>
        <trans-unit id="51155745af8063958ec76934f809009e58a38237" translate="yes" xml:space="preserve">
          <source>Not compressed</source>
          <target state="translated">압축되지 않음</target>
        </trans-unit>
        <trans-unit id="34e5c8d4921d70a5fd42a7796af4e4cbaaabd2e7" translate="yes" xml:space="preserve">
          <source>Not equal operator.</source>
          <target state="translated">같지 않은 연산자</target>
        </trans-unit>
        <trans-unit id="e5cfceca70840e7a8293d5d05471c6a35f7ca7ce" translate="yes" xml:space="preserve">
          <source>Not equal operator. Evaluates both SQL expressions and returns 1 if they are not equal and 0 if they are equal, or &lt;code&gt;NULL&lt;/code&gt; if either expression is NULL. If the expressions return different data types, (for instance, a number and a string), performs type conversion.</source>
          <target state="translated">같지 않은 연산자 두 SQL 표현식을 모두 평가하고 같지 않으면 1을 리턴하고, 같지 않으면 0을 &lt;code&gt;NULL&lt;/code&gt; 하고 두 표현식이 NULL이면 NULL을 리턴합니다. 식이 다른 데이터 형식 (예 : 숫자 및 문자열)을 반환하면 형식 변환을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="0b4111577c9d69153a097caeb5d59cb7772b3248" translate="yes" xml:space="preserve">
          <source>Not equals</source>
          <target state="translated">같지 않음</target>
        </trans-unit>
        <trans-unit id="3ea80ac34f7672db4739183faddacc5787d7aea8" translate="yes" xml:space="preserve">
          <source>Not having a primary key will generate errors for resynchronizing tables via spider_copy_table().</source>
          <target state="translated">기본 키가 없으면 spider_copy_table ()을 통해 테이블을 다시 동기화 할 때 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e13a5c050aa55c398a1c8eb8944533c8d064a70b" translate="yes" xml:space="preserve">
          <source>Not knowing the limit clause, CONNECT sends to the remote DBMS the query:</source>
          <target state="translated">limit 절을 모르면 CONNECT는 원격 DBMS에 쿼리를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="4872c6bb249a80c660ce7b85b8cd5cf36bc03ffe" translate="yes" xml:space="preserve">
          <source>Not only is &lt;code&gt;table1&lt;/code&gt; write locked, &lt;code&gt;table2&lt;/code&gt; and &lt;code&gt;table3&lt;/code&gt; are also write locked, due to the possible &lt;code&gt;&lt;a href=&quot;../insert/index&quot;&gt;INSERT&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt;&lt;/code&gt;, while &lt;code&gt;table4&lt;/code&gt; is read locked due to the &lt;code&gt;&lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">입니다뿐만 아니라 &lt;code&gt;table1&lt;/code&gt; 쓰기가 잠겨, &lt;code&gt;table2&lt;/code&gt; 와 &lt;code&gt;table3&lt;/code&gt; 인해 가능성에 잠겨 쓰기되는 &lt;code&gt;&lt;a href=&quot;../insert/index&quot;&gt;INSERT&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt;&lt;/code&gt; 동안, &lt;code&gt;table4&lt;/code&gt; 받는 잠긴 읽기된다 &lt;code&gt;&lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="93daf7f6ab044b80ce9101933d2eef7a7436355a" translate="yes" xml:space="preserve">
          <source>Not set (&amp;lt;= &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1036-release-notes/&quot;&gt;MariaDB 10.3.6&lt;/a&gt;)</source>
          <target state="translated">설정되지 않음 (&amp;lt;= &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1036-release-notes/&quot;&gt;MariaDB 10.3.6&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="d23524c99a0c506cb6a802754299010056bd5746" translate="yes" xml:space="preserve">
          <source>Not so fast?</source>
          <target state="translated">그렇게 빠르지 않습니까?</target>
        </trans-unit>
        <trans-unit id="0bd44553a56cce210ba53f7e653211917da399ee" translate="yes" xml:space="preserve">
          <source>Not specifying a replication domain at all in the UNTIL condition means that the domain is stopped immediately, nothing is replicated from that domain. In particular, specifying the empty string will stop the slave immediately.</source>
          <target state="translated">UNTIL 조건에서 복제 도메인을 전혀 지정하지 않으면 도메인이 즉시 중지되고 해당 도메인에서 아무것도 복제되지 않습니다. 특히 빈 문자열을 지정하면 슬레이브가 즉시 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="8e635455c1c04acc72cc3cb8b3930fa2002922c7" translate="yes" xml:space="preserve">
          <source>Not supported</source>
          <target state="translated">미지원</target>
        </trans-unit>
        <trans-unit id="8611c6936dca3722c56571b8513694531c55d3b0" translate="yes" xml:space="preserve">
          <source>Not supported, no conversion provided.</source>
          <target state="translated">지원되지 않으며 변환이 제공되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="5189a243609288d97445e98305f0804e3602409c" translate="yes" xml:space="preserve">
          <source>Not supported, will return an empty result</source>
          <target state="translated">지원되지 않으며 빈 결과를 반환합니다</target>
        </trans-unit>
        <trans-unit id="4329a7c2771cca431ea2f11d787607a3244b8736" translate="yes" xml:space="preserve">
          <source>Not supported.</source>
          <target state="translated">지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="46c1bbd14a70ff50f3617be209a3b09c2dccca74" translate="yes" xml:space="preserve">
          <source>Not unique table/alias: '%s'</source>
          <target state="translated">고유하지 않은 테이블 / 별칭 : '% s'</target>
        </trans-unit>
        <trans-unit id="0dd378e1836af98ac1c78f930410e69ab76df59a" translate="yes" xml:space="preserve">
          <source>Not used.</source>
          <target state="translated">사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="11f3cd250cd2c9297b54baf3a33f27945247313c" translate="yes" xml:space="preserve">
          <source>Not_flushed_delayed_rows</source>
          <target state="translated">Not_flushed_delayed_rows</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="469ae2314458aff14962ab1b27353ca0e84374c6" translate="yes" xml:space="preserve">
          <source>Note 1: The comment is not mandatory here but useful to see that the index is dynamic if you use the &lt;a href=&quot;../show-index/index&quot;&gt;SHOW INDEX&lt;/a&gt; command.</source>
          <target state="translated">참고 1 : 주석은 필수 사항은 아니지만 &lt;a href=&quot;../show-index/index&quot;&gt;SHOW INDEX&lt;/a&gt; 명령 을 사용하는 경우 색인이 동적임을 알 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8fac7a7c74268a4813f88fe66f77f2b3bee3bcb8" translate="yes" xml:space="preserve">
          <source>Note 1: When the LIMIT restriction is applicable, only the first &lt;em&gt;m&lt;/em&gt; array items are used, &lt;em&gt;m&lt;/em&gt; being the value of the LIMIT option (to be specified in option_list). The LIMIT default value is 10.</source>
          <target state="translated">주 1 : LIMIT 제한을 적용하는 경우에만 상기 제 &lt;em&gt;m의&lt;/em&gt; 배열 항목이 사용된다 &lt;em&gt;m은&lt;/em&gt; (는 option_list에서 규정 함) 제한 옵션의 가치. LIMIT 기본값은 10입니다.</target>
        </trans-unit>
        <trans-unit id="b2f26bdadf32c4bd159265892c7732aa06115e0c" translate="yes" xml:space="preserve">
          <source>Note 1: we had to do it in two steps because of the column CONNECT options.</source>
          <target state="translated">참고 1 : CONNECT 옵션 열로 인해 두 단계로 수행해야했습니다.</target>
        </trans-unit>
        <trans-unit id="b1523fb2e741b5e2f3803681a9245abdc64f82a0" translate="yes" xml:space="preserve">
          <source>Note 2: An alternative way to indicate what is to be expanded is to use the expand option in the option list, for instance:</source>
          <target state="translated">참고 2 : 확장 대상을 나타내는 다른 방법은 옵션 목록에서 확장 옵션을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="40c672c6f2445240163a246081a72c399a5a4943" translate="yes" xml:space="preserve">
          <source>Note 2: There is currently no way to just change the DYNAM option without dropping and adding the index. This is unfortunate because it takes time.</source>
          <target state="translated">참고 2 : 현재 인덱스를 삭제하거나 추가하지 않고 DYNAM 옵션을 변경하는 방법은 없습니다. 시간이 걸리기 때문에 불행합니다.</target>
        </trans-unit>
        <trans-unit id="e6091e578fab85729faf8fadf16cee21a65dca8b" translate="yes" xml:space="preserve">
          <source>Note 2: the special column PARTID returns the name of the partition in which the row is located.</source>
          <target state="translated">참고 2 : 특수 열 PARTID는 행이 위치한 파티션의 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cca48fa48c9777438824c86eff6c4e716875b1a0" translate="yes" xml:space="preserve">
          <source>Note 3: here we could have used the FNAME special column instead because the file name is specified as being the partition name.</source>
          <target state="translated">참고 3 : 여기서는 파일 이름이 파티션 이름으로 지정되었으므로 FNAME 특수 열을 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3bad4fb8cbb53daf2356de471b9bc68d8c2ac5e2" translate="yes" xml:space="preserve">
          <source>Note : Starting with &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1043-release-notes/&quot;&gt;MariaDB 10.4.3&lt;/a&gt;, a pre-built data directory is no longer provided, and users need to run &lt;a href=&quot;../mysql_install_dbexe/index&quot;&gt;mysql_install_db.exe&lt;/a&gt; to create a data directory.</source>
          <target state="translated">참고 : &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1043-release-notes/&quot;&gt;MariaDB 10.4.3&lt;/a&gt; 부터는 사전 빌드 된 데이터 디렉토리가 더 이상 제공되지 않으므로 사용자는 &lt;a href=&quot;../mysql_install_dbexe/index&quot;&gt;mysql_install_db.exe&lt;/a&gt; 를 실행 하여 데이터 디렉토리를 작성 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c2832d3b427c9902bab0f7be8c141d71a73c300c" translate="yes" xml:space="preserve">
          <source>Note When one loads data with &lt;a href=&quot;../myrocks-system-variables/index#rocksdb_bulk_load&quot;&gt;rocksdb_bulk_load=1&lt;/a&gt; and the data conflicts with the data already in the database, one may get non-trivial errors, for example:</source>
          <target state="translated">참고 &lt;a href=&quot;../myrocks-system-variables/index#rocksdb_bulk_load&quot;&gt;rockdb_bulk_load = 1로&lt;/a&gt; 데이터를로드 하고 데이터가 이미 데이터베이스에있는 데이터와 충돌하면 다음과 같은 사소한 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a64c7a3291796614cba990a8dad7747eb67d6d8" translate="yes" xml:space="preserve">
          <source>Note also that XtraDB by default will crash the server when it detects corrupted data in a single-table tablespace. This behaviour can be changed - see the &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_corrupt_table_action&quot;&gt;innodb_corrupt_table_action&lt;/a&gt; system variable.</source>
          <target state="translated">또한 기본적으로 XtraDB는 단일 테이블 테이블 스페이스에서 손상된 데이터를 발견하면 서버를 중단시킵니다. 이 동작은 변경 될 수 있습니다 . &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_corrupt_table_action&quot;&gt;innodb_corrupt_table_action&lt;/a&gt; 시스템 변수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5bcb89019afb43a2b0517fc957cda45e2183accc" translate="yes" xml:space="preserve">
          <source>Note for live databases: You just need to make a local copy of the data, you don't need to keep the master locked until the slave has imported the data.</source>
          <target state="translated">라이브 데이터베이스에 대한 참고 사항 : 로컬 데이터 복사본 만 만들면 슬레이브가 데이터를 가져올 때까지 마스터를 잠그지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="4031a55299e185ffad44aeb98d6f5b919892bc8c" translate="yes" xml:space="preserve">
          <source>Note how all the '=' parts of the WHERE come first; then comes both the '&amp;gt;=' and 'ORDER BY', both on id. This means that the INDEX can be used for all the WHERE, plus the ORDER BY.</source>
          <target state="translated">WHERE의 모든 '='부분이 먼저 나오는 방법에 주목하십시오. 그런 다음 id에 '&amp;gt; ='및 'ORDER BY'가 모두 있습니다. 이것은 INDEX가 모든 WHERE와 ORDER BY에 사용될 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0f5ccb1471458269587164b0661feb916af32adb" translate="yes" xml:space="preserve">
          <source>Note however that the short-circuit evaluation does &lt;em&gt;not&lt;/em&gt; apply to &lt;code&gt;NULL AND x()&lt;/code&gt;. Also, &lt;code&gt;BETWEEN&lt;/code&gt;'s right operands are not evaluated if the left operand is &lt;code&gt;NULL&lt;/code&gt;, but in all other cases all the operands are evaluated.</source>
          <target state="translated">그러나 단락 평가는 &lt;code&gt;NULL AND x()&lt;/code&gt; &lt;em&gt;에는&lt;/em&gt; 적용 되지 &lt;em&gt;않습니다&lt;/em&gt; . 또한 왼쪽 피연산자가 &lt;code&gt;NULL&lt;/code&gt; 이면 &lt;code&gt;BETWEEN&lt;/code&gt; 의 오른쪽 피연산자가 평가되지 않지만 다른 모든 경우에는 모든 피연산자가 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="6e2bf5b8e3574b1f960c76310208ecb8df2b133c" translate="yes" xml:space="preserve">
          <source>Note subtle things like</source>
          <target state="translated">미묘한 것들에 주목</target>
        </trans-unit>
        <trans-unit id="aa966a6dcd0067f3d8a0aba1e3b807cd32a65009" translate="yes" xml:space="preserve">
          <source>Note that 10 rows/sec (300M/year) implies maybe 30GB for data + indexes + normalization tables + summary tables for 1 year. I would call this &quot;not so big&quot;.</source>
          <target state="translated">초당 10 행 (300M / 년)은 데이터 + 인덱스 + 정규화 테이블 + 1 년 동안의 요약 테이블에 대해 30GB를 의미합니다. 나는 이것을 &quot;너무 크지 않다&quot;고 부를 것이다.</target>
        </trans-unit>
        <trans-unit id="b8a0d78fe0448cb36027fe12a76adf775370f28f" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;../explain-in-the-slow-query-log/index&quot;&gt;EXPLAIN output&lt;/a&gt; will only be recorded if the slow query log is written to a file and not to a table.</source>
          <target state="translated">참고 &lt;a href=&quot;../explain-in-the-slow-query-log/index&quot;&gt;EXPLAIN 출력은&lt;/a&gt; 슬로우 쿼리 로그 테이블에 파일에 기록되어 있지 않은 경우에만 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="d977401a453ff483001325cf6397fd8a62c88fe8" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;../set/index&quot;&gt;SET&lt;/a&gt; and &lt;a href=&quot;../enum/index&quot;&gt;ENUM&lt;/a&gt; fields are currently compared by their string value rather than their relative position in the set, so MAX() may produce a different highest result than ORDER BY DESC.</source>
          <target state="translated">참고 &lt;a href=&quot;../set/index&quot;&gt;SET&lt;/a&gt; 및 &lt;a href=&quot;../enum/index&quot;&gt;ENUM&lt;/a&gt; MAX ()는 ORDER BY DESC와 다른 가장 높은 결과를 얻을 수 있도록 필드가 현재 자신의 문자열 값이 아닌 세트에서 자신의 상대적 위치를 기준으로 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="d6801fd5af9fa8416a971566fd519a77202a6e10" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;../set/index&quot;&gt;SET&lt;/a&gt; and &lt;a href=&quot;../enum/index&quot;&gt;ENUM&lt;/a&gt; fields are currently compared by their string value rather than their relative position in the set, so MIN() may produce a different lowest result than ORDER BY ASC.</source>
          <target state="translated">참고 &lt;a href=&quot;../set/index&quot;&gt;SET&lt;/a&gt; 및 &lt;a href=&quot;../enum/index&quot;&gt;ENUM&lt;/a&gt; MIN ()는 ORDER BY ASC의 상이한 낮은 결과를 생성 할 수 있도록, 현재 필드가 그 문자열 값보다는 세트의 상대적인 위치에 의해 비교된다.</target>
        </trans-unit>
        <trans-unit id="411383db9c3c0c8181fcdfd37b5a69383d4e23ae" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;../truncate-table/index&quot;&gt;TRUNCATE TABLE&lt;/a&gt; does not activate any triggers.</source>
          <target state="translated">참고 &lt;a href=&quot;../truncate-table/index&quot;&gt;TRUNCATE 표는&lt;/a&gt; 어떤 트리거를 활성화하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="40dcb98cba2f66ab376a1b443092301ae9ce69a7" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt;&lt;a href=&quot;../why-does-mariadb-102-use-innodb-instead-of-xtradb/index&quot;&gt;makes use of InnoDB, not XtraDB&lt;/a&gt;.</source>
          <target state="translated">참고 &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2 &lt;/a&gt;&lt;a href=&quot;../why-does-mariadb-102-use-innodb-instead-of-xtradb/index&quot;&gt;차종이, 이노의 XtraDB를 사용하지 않음&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="afe558873bff2a85311519ed53639647564ff7e1" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;https://lists.freedesktop.org/archives/systemd-devel/2017-December/039996.html&quot;&gt;systemd 236 added the &lt;code&gt;EXTEND_TIMEOUT_USEC&lt;/code&gt; environment variable&lt;/a&gt; that allows services to extend the startup timeout during long-running processes. Starting with &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10133-release-notes/&quot;&gt;MariaDB 10.1.33&lt;/a&gt;, &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10215-release-notes/&quot;&gt;MariaDB 10.2.15&lt;/a&gt;, and &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1036-release-notes/&quot;&gt;MariaDB 10.3.6&lt;/a&gt;, on systems with systemd versions that support it, MariaDB uses this feature to extend the startup timeout during certain startup processes that can run long. Therefore, if you are using &lt;code&gt;systemd&lt;/code&gt; 236 or later, then you should not need to manually override &lt;code&gt;TimeoutStartSec&lt;/code&gt;, even if your startup tasks, such as crash recovery, run for longer than the configured value. See &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-14705&quot;&gt;MDEV-14705&lt;/a&gt; for more information.</source>
          <target state="translated">노트 &lt;a href=&quot;https://lists.freedesktop.org/archives/systemd-devel/2017-December/039996.html&quot;&gt;(236)는 추가 systemd &lt;code&gt;EXTEND_TIMEOUT_USEC&lt;/code&gt; 의 환경 변수&lt;/a&gt; 서비스 장기 실행 프로세스 중에 시작 시간 제한을 확장 할 수있다. 이를 지원하는 시스템 버전의 시스템 에서 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10133-release-notes/&quot;&gt;MariaDB 10.1.33&lt;/a&gt; , &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10215-release-notes/&quot;&gt;MariaDB 10.2.15&lt;/a&gt; 및 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1036-release-notes/&quot;&gt;MariaDB 10.3.6&lt;/a&gt; 부터 MariaDB는이 기능을 사용하여 오래 실행될 수있는 특정 시작 프로세스 중에 시작 시간 초과를 연장합니다. 따라서 &lt;code&gt;systemd&lt;/code&gt; 236 이상을 사용하는 경우 응급 복구와 같은 시작 태스크가 구성된 값보다 오래 실행 되더라도 &lt;code&gt;TimeoutStartSec&lt;/code&gt; 을 수동으로 대체하지 않아도됩니다 . 자세한 내용은 &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-14705&quot;&gt;MDEV-14705&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7e0885c4f56e0990425fd022ce2adf05dd1f8db5" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;https://lists.freedesktop.org/archives/systemd-devel/2017-December/039996.html&quot;&gt;systemd 236 added the &lt;code&gt;EXTEND_TIMEOUT_USEC&lt;/code&gt; environment variable&lt;/a&gt; that allows services to extend the startup timeout during long-running processes. Starting with &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10135-release-notes/&quot;&gt;MariaDB 10.1.35&lt;/a&gt;, &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10217-release-notes/&quot;&gt;MariaDB 10.2.17&lt;/a&gt;, and &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1038-release-notes/&quot;&gt;MariaDB 10.3.8&lt;/a&gt;, on systems with systemd versions that support it, MariaDB uses this feature to extend the startup timeout during long SSTs. Therefore, if you are using &lt;code&gt;systemd&lt;/code&gt; 236 or later, then you should not need to manually override &lt;code&gt;TimeoutStartSec&lt;/code&gt;, even if your SSTs run for longer than the configured value. See &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-15607&quot;&gt;MDEV-15607&lt;/a&gt; for more information.</source>
          <target state="translated">노트 &lt;a href=&quot;https://lists.freedesktop.org/archives/systemd-devel/2017-December/039996.html&quot;&gt;(236)는 추가 systemd &lt;code&gt;EXTEND_TIMEOUT_USEC&lt;/code&gt; 의 환경 변수&lt;/a&gt; 서비스 장기 실행 프로세스 중에 시작 시간 제한을 확장 할 수있다. 이를 지원하는 시스템 버전의 시스템 에서 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10135-release-notes/&quot;&gt;MariaDB 10.1.35&lt;/a&gt; , &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10217-release-notes/&quot;&gt;MariaDB 10.2.17&lt;/a&gt; 및 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1038-release-notes/&quot;&gt;MariaDB 10.3.8&lt;/a&gt; 부터 MariaDB는이 기능을 사용하여 긴 SST 동안 시작 시간 초과를 연장합니다. 따라서 &lt;code&gt;systemd&lt;/code&gt; 236 이상을 사용하는 경우 SST가 구성된 값보다 오래 실행 되더라도 &lt;code&gt;TimeoutStartSec&lt;/code&gt; 을 수동으로 대체하지 않아도됩니다 . 자세한 내용은 &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-15607&quot;&gt;MDEV-15607&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1b52334dda2a5d6ab0d65c7098b69ba37f4ff3a4" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;https://lists.freedesktop.org/archives/systemd-devel/2017-December/039996.html&quot;&gt;systemd 236 added the EXTEND_TIMEOUT_USEC environment variable&lt;/a&gt; that allows services to extend the startup timeout during long-running processes. On systems with systemd versions that support it, MariaDB uses this feature to extend the startup timeout during certain startup processes that can run long.</source>
          <target state="translated">참고 &lt;a href=&quot;https://lists.freedesktop.org/archives/systemd-devel/2017-December/039996.html&quot;&gt;236 systemd는 EXTEND_TIMEOUT_USEC 환경 변수 추가&lt;/a&gt; 서비스 장기 실행 프로세스 중에 시작 시간 제한을 확장 할 수있다. 시스템 버전을 지원하는 시스템 버전에서 MariaDB는이 기능을 사용하여 오래 실행될 수있는 특정 시작 프로세스 중에 시작 시간 초과를 연장합니다.</target>
        </trans-unit>
        <trans-unit id="639d6ac5f0ba236be638e562a09eb8fc616558b9" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;CONNECT&lt;/code&gt; events are always logged for all users, regardless of these two settings. Logging is also based on username only, not the username and hostname combination that MariaDB uses to determine privileges.</source>
          <target state="translated">참고 &lt;code&gt;CONNECT&lt;/code&gt; 의 이벤트에 관계없이 항상이 두 가지 설정의 모든 사용자에 대해 기록됩니다. 또한 로깅은 MariaDB가 권한을 결정하기 위해 사용하는 사용자 이름과 호스트 이름 조합이 아닌 사용자 이름 만 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="f93d5bcb3c0f9cf11a81f7e4e8fd1b53d77dbcbf" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;DECLARE HANDLER&lt;/code&gt; contains another &lt;code&gt;BEGIN ... END&lt;/code&gt; construct.</source>
          <target state="translated">참고 &lt;code&gt;DECLARE HANDLER&lt;/code&gt; 다른 포함 &lt;code&gt;BEGIN ... END&lt;/code&gt; 구조를.</target>
        </trans-unit>
        <trans-unit id="469446ecd377e5a2f389e6a7f5b1dcbf20d810fa" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;END&lt;/code&gt; will perform a commit. If you are running in &lt;a href=&quot;../server-system-variables/index#autocommit&quot;&gt;autocommit&lt;/a&gt; mode, every statement will be committed separately. If you are not running in &lt;code&gt;autocommit&lt;/code&gt; mode, you must execute a &lt;a href=&quot;../commit/index&quot;&gt;COMMIT&lt;/a&gt; or &lt;a href=&quot;../rollback/index&quot;&gt;ROLLBACK&lt;/a&gt; after &lt;code&gt;END&lt;/code&gt; to get the database up to date.</source>
          <target state="translated">참고 &lt;code&gt;END&lt;/code&gt; 를 커밋 수행합니다. &lt;a href=&quot;../server-system-variables/index#autocommit&quot;&gt;자동&lt;/a&gt; 커미트 모드 에서 실행중인 경우 모든 명령문이 별도로 커미트됩니다. &lt;code&gt;autocommit&lt;/code&gt; &lt;a href=&quot;../commit/index&quot;&gt;커미트&lt;/a&gt; 모드 에서 실행하지 않는 경우 데이터베이스를 최신 상태로 유지하려면 &lt;code&gt;END&lt;/code&gt; 후에 COMMIT 또는 &lt;a href=&quot;../rollback/index&quot;&gt;ROLLBACK&lt;/a&gt; 을 실행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="41f00135efd1bad4e0190ec1a374e0e6dc93011a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Gtid_IO_Pos&lt;/code&gt; on slave can contain many different positions separated with ',' if the slave has been connected to many different masters. What is important is that all the sequences that are on the master is also on the slave.</source>
          <target state="translated">참고 &lt;code&gt;Gtid_IO_Pos&lt;/code&gt; 슬레이브가 많은 다른 마스터에 연결되어있는 경우 슬레이브가 많은 다른 위치를 포함 할 수는 ','로 구분. 중요한 것은 마스터에있는 모든 시퀀스도 슬레이브에 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f49157e9a89a5e819bbfa3a78c233d0bc7b90586" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;INSERT DELAYED&lt;/code&gt; is slower than a normal &lt;code&gt;INSERT&lt;/code&gt; if the table is not otherwise in use. There is also the additional overhead for the server to handle a separate thread for each table for which there are delayed rows. This means that you should use &lt;code&gt;INSERT DELAYED&lt;/code&gt; only when you are really sure that you need it.</source>
          <target state="translated">참고 &lt;code&gt;INSERT DELAYED&lt;/code&gt; 정상보다 느린 &lt;code&gt;INSERT&lt;/code&gt; 테이블이 사용하고 그렇지 않은 경우. 지연된 행이있는 각 테이블에 대해 서버가 별도의 스레드를 처리하기위한 추가 오버 헤드도 있습니다. 즉, 실제로 필요한 경우에만 &lt;code&gt;INSERT DELAYED&lt;/code&gt; 를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="9cca3730f46f558e4703b9501f9631171a1afcaf" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;LOAD DATA FROM MASTER&lt;/code&gt; does not copy any tables from the mysql database. This makes it easy to have different users and privileges on the master and the slave.</source>
          <target state="translated">참고 &lt;code&gt;LOAD DATA FROM MASTER&lt;/code&gt; (을) MySQL 데이터베이스에서 모든 테이블을 복사하지 않습니다. 이를 통해 마스터와 슬레이브에 대해 다른 사용자와 권한을 쉽게 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f4aa9eb1e1c86f35108d5c8e80bf74a6d380f80" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;RESIGNAL&lt;/code&gt; does not empty the diagnostics area: it just appends another error condition.</source>
          <target state="translated">참고 &lt;code&gt;RESIGNAL&lt;/code&gt; 이 진단 영역을 비우하지 않습니다 : 그것은 또 다른 오류 조건을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="2ec8c7159166feed85fb26480c1e0ea9c4a66509" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;SHOW CREATE TABLE&lt;/code&gt; is not meant to provide metadata about a table. It provides information about how the table was declared, but the real table structure could differ a bit. For example, if an index has been declared as &lt;code&gt;HASH&lt;/code&gt;, the &lt;code&gt;CREATE TABLE&lt;/code&gt; statement returned by &lt;code&gt;SHOW CREATE TABLE&lt;/code&gt; will declare that index as &lt;code&gt;HASH&lt;/code&gt;; however, it is possible that the index is in fact a &lt;code&gt;BTREE&lt;/code&gt;, because the storage engine does not support &lt;code&gt;HASH&lt;/code&gt;.</source>
          <target state="translated">참고 &lt;code&gt;SHOW CREATE TABLE&lt;/code&gt; 테이블에 대한 메타 데이터를 제공하는 것은 아닙니다. 테이블이 선언 된 방법에 대한 정보를 제공하지만 실제 테이블 구조는 약간 다를 수 있습니다. 인덱스는 다음과 같이 선언 된 경우 예를 들어, &lt;code&gt;HASH&lt;/code&gt; 는이 &lt;code&gt;CREATE TABLE&lt;/code&gt; 에 의해 반환 문 &lt;code&gt;SHOW CREATE TABLE&lt;/code&gt; 등의 해당 인덱스 선언합니다 &lt;code&gt;HASH&lt;/code&gt; 를 ; 그러나 스토리지 엔진이 &lt;code&gt;HASH&lt;/code&gt; 를 지원하지 않기 때문에 인덱스가 실제로 &lt;code&gt;BTREE&lt;/code&gt; 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a00c6877fc67be583efb6cf023a3f87a4d59d084" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;STOP SLAVE&lt;/code&gt; doesn't delete the connection permanently. Next time you execute &lt;code&gt;&lt;a href=&quot;../start-slave/index&quot;&gt;START SLAVE&lt;/a&gt;&lt;/code&gt; or the MariaDB server restarts, the slave connection is restored with it's &lt;code&gt;&lt;a href=&quot;../change-master-to/index&quot;&gt;original arguments&lt;/a&gt;&lt;/code&gt;. If you want to delete a connection, you should execute &lt;code&gt;&lt;a href=&quot;../reset-slave/index&quot;&gt;RESET SLAVE&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">참고 &lt;code&gt;STOP SLAVE&lt;/code&gt; 가 영구적으로 연결을 삭제하지 않습니다. 다음에 &lt;code&gt;&lt;a href=&quot;../start-slave/index&quot;&gt;START SLAVE&lt;/a&gt;&lt;/code&gt; 를 실행 하거나 MariaDB 서버가 다시 시작되면 슬레이브 연결이 &lt;code&gt;&lt;a href=&quot;../change-master-to/index&quot;&gt;original arguments&lt;/a&gt;&lt;/code&gt; 복원됩니다 . 연결을 삭제하려면 &lt;code&gt;&lt;a href=&quot;../reset-slave/index&quot;&gt;RESET SLAVE&lt;/a&gt;&lt;/code&gt; 를 실행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="82383571279ee0f60376d82d2b1c2194fd310797" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;ac_dob&lt;/code&gt; table is not in the output. Now let's try getting birthdate instead:</source>
          <target state="translated">참고 &lt;code&gt;ac_dob&lt;/code&gt; 의 표는 출력되지 않습니다. 이제 생년월일을 가져와 봅시다.</target>
        </trans-unit>
        <trans-unit id="6b43b7d52a647732c8ffd547fcf44e3a051ccea7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;encrypt=1&lt;/code&gt; refers to a TLS encryption method that has been deprecated and removed.</source>
          <target state="translated">참고 &lt;code&gt;encrypt=1&lt;/code&gt; 되지 않고 제거 된 TLS 암호화 방법을 말한다.</target>
        </trans-unit>
        <trans-unit id="7f20d0b07c57a007fc228ddfa5fb07cedfc68b48" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;encrypt=1&lt;/code&gt; refers to a TLS encryption method that has been deprecated and removed. &lt;code&gt;encrypt=4&lt;/code&gt; refers to a TLS encryption method in &lt;code&gt;xtrabackup-v2&lt;/code&gt; that has not yet been ported to &lt;code&gt;mariabackup&lt;/code&gt;. See &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-18050&quot;&gt;MDEV-18050&lt;/a&gt; about that.</source>
          <target state="translated">참고 &lt;code&gt;encrypt=1&lt;/code&gt; 되지 않고 제거 된 TLS 암호화 방법을 말한다. &lt;code&gt;encrypt=4&lt;/code&gt; 는 &lt;code&gt;xtrabackup-v2&lt;/code&gt; 에서 아직 &lt;code&gt;mariabackup&lt;/code&gt; 으로 포팅되지 않은 TLS 암호화 방법을 나타 냅니다 . 이에 대해서는 &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-18050&quot;&gt;MDEV-18050을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7c04b3d18fea3b5f34fe953bd58fbb597e01d09d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;localhost&lt;/code&gt; is a special value. Using 127.0.0.1 is not the same thing. The latter will connect to the mysqld server through tcpip.</source>
          <target state="translated">참고 &lt;code&gt;localhost&lt;/code&gt; 특별한 값이다. 127.0.0.1 사용은 동일하지 않습니다. 후자는 tcpip를 통해 mysqld 서버에 연결합니다.</target>
        </trans-unit>
        <trans-unit id="769a546a18165a82a73404eb9388d48d6fedd5b0" translate="yes" xml:space="preserve">
          <source>Note that Cassandra is no longer actively being developed.</source>
          <target state="translated">Cassandra는 더 이상 적극적으로 개발되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="35b5f86ca57bfc81b76fae2f5d78d74e4ee8bbea" translate="yes" xml:space="preserve">
          <source>Note that FreeBSD treats the Server and Client as separate packages. The Client is a dependency of the Server, so you only need to build the Server to get both. It also provides a number of different versions. You can search the available ports from &lt;a href=&quot;http://www.freshports.org/databases&quot;&gt;Fresh Ports&lt;/a&gt;. Decide what version of MariaDB you want to install, the change into the relevant directory. Once in the directory, run Make to build MariaDB.</source>
          <target state="translated">FreeBSD는 서버와 클라이언트를 별도의 패키지로 취급합니다. 클라이언트는 서버의 종속성이므로 서버를 구축하기 만하면됩니다. 또한 다양한 버전을 제공합니다. &lt;a href=&quot;http://www.freshports.org/databases&quot;&gt;Fresh Ports&lt;/a&gt; 에서 사용 가능한 포트를 검색 할 수 있습니다 . 설치할 MariaDB 버전을 결정하고 관련 디렉토리로 변경하십시오. 디렉토리에 들어가면 Make를 실행하여 MariaDB를 빌드하십시오.</target>
        </trans-unit>
        <trans-unit id="dea3c954ec364afdc5a67e92fa2a0c35998ee4b4" translate="yes" xml:space="preserve">
          <source>Note that FreeBSD treats the Server and Client as separate packages. The Client is a dependency of the Server, so you only need to build the Server to get both. It also provides a number of different versions. You can search the available ports from &lt;a href=&quot;https://www.freshports.org/databases&quot;&gt;Fresh Ports&lt;/a&gt;. Decide what version of MariaDB you want to install, the change into the relevant directory. Once in the directory, run Make to build MariaDB.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea62256f686189db20a880f59c334be078bd9af7" translate="yes" xml:space="preserve">
          <source>Note that I am using the &lt;code&gt;dc=support,dc=mariadb,dc=com&lt;/code&gt; domain for my directory. You can change this to whatever is relevant to you.</source>
          <target state="translated">내가 사용하고 있습니다 &lt;code&gt;dc=support,dc=mariadb,dc=com&lt;/code&gt; 내 디렉토리 도메인. 당신은 당신과 관련된 무엇이든 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b25e49da1524e2ee760128313a368fabe90809d8" translate="yes" xml:space="preserve">
          <source>Note that Jbin results are recognized as such because they are aliased beginning with &amp;ldquo;Jbin_&amp;rdquo;. This is why in the &lt;em&gt;Json_Object&lt;/em&gt; function the alias is specified as &amp;ldquo;Jbin_foo&amp;rdquo;.</source>
          <target state="translated">Jbin 결과는 &quot;Jbin_&quot;으로 시작하여 별칭이 지정되므로 인식됩니다. 이것이 &lt;em&gt;Json_Object&lt;/em&gt; 함수에서 별명이&amp;ldquo;Jbin_foo&amp;rdquo;로 지정된 이유입니다 .</target>
        </trans-unit>
        <trans-unit id="2b21f1414e5b53a915cee17de4fc3a053990832a" translate="yes" xml:space="preserve">
          <source>Note that KEY_BLOCK_SIZE is currently ignored in CREATE INDEX, although it is included in the output of &lt;a href=&quot;../show-create-table/index&quot;&gt;SHOW CREATE TABLE&lt;/a&gt;.</source>
          <target state="translated">KEY_BLOCK_SIZE는 현재 CREATE INDEX에서 무시되지만 &lt;a href=&quot;../show-create-table/index&quot;&gt;SHOW CREATE TABLE&lt;/a&gt; 의 출력에 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="acd26e26caa5b79fd8df9cc935239b8fbc95010b" translate="yes" xml:space="preserve">
          <source>Note that LEAVE cannot be used to exit a &lt;a href=&quot;../declare-handler/index&quot;&gt;DECLARE HANDLER&lt;/a&gt; block.</source>
          <target state="translated">&lt;a href=&quot;../declare-handler/index&quot;&gt;DEAVEARE HANDLER&lt;/a&gt; 블록 을 종료하는 데 LEAVE를 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="8743f996183ab0ae75f4a67078933bc018ca20f0" translate="yes" xml:space="preserve">
          <source>Note that MASTER_GTID_WAIT() can be used even if the slave is configured not to use GTID for connections (&lt;a href=&quot;../change-master-to/index#master_use_gtid&quot;&gt;CHANGE MASTER TO master_use_gtid=no&lt;/a&gt;). This is because from MariaDB 10, GTIDs are always logged on the master server, and always recorded on the slave servers.</source>
          <target state="translated">슬레이브가 연결에 GTID를 사용하지 않도록 구성된 경우에도 MASTER_GTID_WAIT ()를 사용할 수 있습니다 ( &lt;a href=&quot;../change-master-to/index#master_use_gtid&quot;&gt;CHANGE MASTER TO master_use_gtid = no&lt;/a&gt; ). MariaDB 10부터 GTID는 항상 마스터 서버에 기록되고 항상 슬레이브 서버에 기록되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="d99a172a50e1141c400e6fc7a979051b5be410d1" translate="yes" xml:space="preserve">
          <source>Note that MEDIUMINT columns will require 4 bytes in memory (for example, in InnoDB buffer pool).</source>
          <target state="translated">MEDIUMINT 열에는 메모리에 4 바이트가 필요합니다 (예 : InnoDB 버퍼 풀).</target>
        </trans-unit>
        <trans-unit id="14710d9107d974951c9236e0e34ecfe6471d39b8" translate="yes" xml:space="preserve">
          <source>Note that MariaDB and MySQL have different GTID implementations, and that these are not compatible with each other.</source>
          <target state="translated">MariaDB와 MySQL의 GTID 구현은 서로 다르며 서로 호환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ed16ce4a5dcb43d077241a288f4bb07169f68dc4" translate="yes" xml:space="preserve">
          <source>Note that OQGRAPH v3 requires libjudy, which is not in the official Red Hat/Fedora repositories. This needs to be installed first, for example:</source>
          <target state="translated">OQGRAPH v3에는 공식 Red Hat / Fedora 리포지토리에없는 libjudy가 필요합니다. 예를 들어 다음과 같이 먼저 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="171fbe002c7a0a757f00a81afe77c853d0773b54" translate="yes" xml:space="preserve">
          <source>Note that REPAIR VIEW in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10018-release-notes/&quot;&gt;MariaDB 10.0.18&lt;/a&gt; and &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5543-release-notes/&quot;&gt;MariaDB 5.5.43&lt;/a&gt; could crash the server (see &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-8115&quot;&gt;MDEV-8115&lt;/a&gt;). Upgrade to a later version.</source>
          <target state="translated">&lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10018-release-notes/&quot;&gt;MariaDB 10.0.18&lt;/a&gt; 및 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5543-release-notes/&quot;&gt;MariaDB 5.5.43의&lt;/a&gt; REPAIR VIEW 는 서버 와 충돌 할 수 있습니다 ( &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-8115&quot;&gt;MDEV-8115&lt;/a&gt; 참조 ). 이후 버전으로 업그레이드하십시오.</target>
        </trans-unit>
        <trans-unit id="6bb51a67ddcfeae98467f6e2de0d939d75066ef0" translate="yes" xml:space="preserve">
          <source>Note that SQL enables you to get the same result presented differently by using the &amp;ldquo;group by&amp;rdquo; clause, namely:</source>
          <target state="translated">SQL을 사용하면 &quot;group by&quot;절을 사용하여 동일한 결과를 다르게 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3992fa22c93155893edb4e306650fa6f10e6d5ff" translate="yes" xml:space="preserve">
          <source>Note that Spider UDF functions will not work with such settings.</source>
          <target state="translated">Spider UDF 기능은 이러한 설정에서 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="42faa5503cb358351af0a2f87a407196b868608c" translate="yes" xml:space="preserve">
          <source>Note that a few items are marked with &lt;code&gt;TODO&lt;/code&gt;; these are things we are working on and will be in next version of Mariabackup.</source>
          <target state="translated">일부 항목에는 &lt;code&gt;TODO&lt;/code&gt; 가 표시되어 있습니다 . 이것들은 우리가 연구하고 있으며 다음 버전의 Mariabackup에 있습니다.</target>
        </trans-unit>
        <trans-unit id="f79c68d59392120e43b210bb6704b8c052edea57" translate="yes" xml:space="preserve">
          <source>Note that a page becomes &quot;dirty&quot; and has to be synced only when a new xid is added into it. Removing a xid from a page does not make it dirty - we don't sync xid removals to disk.</source>
          <target state="translated">페이지가 &quot;더러운&quot;상태가되고 새 xid가 추가 된 경우에만 동기화되어야합니다. 페이지에서 xid를 제거해도 더러워지지는 않습니다. xid 제거를 디스크에 동기화하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="67f78988e62af21808651f719c653afb4bfa7efc" translate="yes" xml:space="preserve">
          <source>Note that according the the OpenGIS standard, a &lt;a href=&quot;../polygon/index&quot;&gt;POLYGON&lt;/a&gt; should have exactly one ExteriorRing and all other rings should lie within that ExteriorRing and thus be the InteriorRings. Practically, however, some systems, including MariaDB's, permit polygons to have several 'ExteriorRings'. In the case of there being multiple, non-overlapping exterior rings ST_NumInteriorRings() will return &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">OpenGIS 표준에 따라 &lt;a href=&quot;../polygon/index&quot;&gt;POLYGON&lt;/a&gt; 은 정확히 하나의 ExteriorRing을 가져야하며 다른 모든 링은 해당 ExteriorRing 내에 있어야하므로 InteriorRings 여야합니다. 그러나 실제로 MariaDB를 포함한 일부 시스템에서는 다각형에 여러 개의 'ExteriorRings'가있을 수 있습니다. 겹치지 않는 외부 링 ST_NumInteriorRings ()가 여러 개있는 경우 &lt;code&gt;1&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="be9bead4adbb886c45f6ba5a0de90ab1c6606deb" translate="yes" xml:space="preserve">
          <source>Note that according to the OpenGIS standard, a POLYGON should have exactly one ExteriorRing and all other rings should lie within that ExteriorRing and thus be the InteriorRings. Practically, however, some systems, including MariaDB's, permit polygons to have several 'ExteriorRings'. In the case of there being multiple, non-overlapping exterior rings &lt;a href=&quot;../st_numinteriorrings/index&quot;&gt;ST_NUMINTERIORRINGS()&lt;/a&gt; will return 1.</source>
          <target state="translated">OpenGIS 표준에 따라 POLYGON은 정확히 하나의 ExteriorRing을 가져야하며 다른 모든 링은 해당 ExteriorRing 내에 있어야하므로 InteriorRings 여야합니다. 그러나 실제로 MariaDB를 포함한 일부 시스템에서는 다각형에 여러 개의 'ExteriorRings'가있을 수 있습니다. 겹치지 않는 외부 링 &lt;a href=&quot;../st_numinteriorrings/index&quot;&gt;ST_NUMINTERIORRINGS ()&lt;/a&gt; 가 여러 개있는 경우 1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bec783d7a50cd02dfd9a94df95e79df7fc36fc1c" translate="yes" xml:space="preserve">
          <source>Note that all double words were removed, in the beginning, in the middle and in the end of the subject string.</source>
          <target state="translated">제목 문자열의 중간과 끝에서 모든 이중 단어가 처음부터 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="e3beb7dc8da85973412251b127012e938ac84262" translate="yes" xml:space="preserve">
          <source>Note that almost always, these use cases involve RANGE partitioning, not the other forms.</source>
          <target state="translated">거의 항상 이러한 유스 케이스에는 다른 형식이 아닌 RANGE 파티셔닝이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="c61b30839fef85c3b8e813fc1ca370711dba17b2" translate="yes" xml:space="preserve">
          <source>Note that although the preferred syntax indicates that the attributes are exclusive, more than one attribute can be specified.</source>
          <target state="translated">선호하는 구문은 속성이 배타적임을 나타내지 만 둘 이상의 속성을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f084dab25e54acc3f72919a782094bf00ab4d87" translate="yes" xml:space="preserve">
          <source>Note that as a difference to MySQL, in MariaDB the &lt;code&gt;TIME&lt;/code&gt; column (and also the &lt;code&gt;TIME_MS&lt;/code&gt; column) are not affected by any setting of &lt;a href=&quot;../server-system-variables/index#timestamp&quot;&gt;@TIMESTAMP&lt;/a&gt;. This means that it can be reliably used also for threads that change &lt;code&gt;@TIMESTAMP&lt;/code&gt; (such as the &lt;a href=&quot;../replication/index&quot;&gt;replication&lt;/a&gt; SQL thread). See also &lt;a href=&quot;http://bugs.mysql.com/bug.php?id=22047&quot;&gt;MySQL Bug #22047&lt;/a&gt;.</source>
          <target state="translated">MySQL과의 차이점으로 MariaDB에서 &lt;code&gt;TIME&lt;/code&gt; 열 (및 &lt;code&gt;TIME_MS&lt;/code&gt; 열)은 &lt;a href=&quot;../server-system-variables/index#timestamp&quot;&gt;@TIMESTAMP&lt;/a&gt; 설정에 영향을받지 않습니다 . 이는 &lt;code&gt;@TIMESTAMP&lt;/code&gt; 를 변경하는 스레드 (예 : &lt;a href=&quot;../replication/index&quot;&gt;복제&lt;/a&gt; SQL 스레드) 에도 안정적으로 사용할 수 있음을 의미합니다 . &lt;a href=&quot;http://bugs.mysql.com/bug.php?id=22047&quot;&gt;MySQL Bug # 22047&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9e3a21661d1bec4615a2347019fe24ca1aaec1d5" translate="yes" xml:space="preserve">
          <source>Note that as a difference to MySQL, in MariaDB the &lt;code&gt;TIME&lt;/code&gt; column (and also the &lt;code&gt;TIME_MS&lt;/code&gt; column) are not affected by any setting of &lt;a href=&quot;../server-system-variables/index#timestamp&quot;&gt;@TIMESTAMP&lt;/a&gt;. This means that it can be reliably used also for threads that change &lt;code&gt;@TIMESTAMP&lt;/code&gt; (such as the &lt;a href=&quot;../replication/index&quot;&gt;replication&lt;/a&gt; SQL thread). See also &lt;a href=&quot;https://bugs.mysql.com/bug.php?id=22047&quot;&gt;MySQL Bug #22047&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7d76922321e60e4bb629f7d79e761a76e082a63" translate="yes" xml:space="preserve">
          <source>Note that as a difference to MySQL, in MariaDB the &lt;code&gt;TIME&lt;/code&gt; column (and also the &lt;code&gt;TIME_MS&lt;/code&gt; column) are not affected by any setting of &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#timestamp&quot;&gt;@TIMESTAMP&lt;/a&gt;&lt;/code&gt;. This means that it can be reliably used also for threads that change &lt;code&gt;@TIMESTAMP&lt;/code&gt; (such as the &lt;a href=&quot;../replication/index&quot;&gt;replication&lt;/a&gt; SQL thread). See also &lt;a href=&quot;http://bugs.mysql.com/bug.php?id=22047&quot;&gt;MySQL Bug #22047&lt;/a&gt;.</source>
          <target state="translated">MySQL과의 차이점으로 MariaDB에서 &lt;code&gt;TIME&lt;/code&gt; 열 (및 &lt;code&gt;TIME_MS&lt;/code&gt; 열)은 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#timestamp&quot;&gt;@TIMESTAMP&lt;/a&gt;&lt;/code&gt; 설정에 영향을받지 않습니다 . 이는 &lt;code&gt;@TIMESTAMP&lt;/code&gt; 를 변경하는 스레드 (예 : &lt;a href=&quot;../replication/index&quot;&gt;복제&lt;/a&gt; SQL 스레드) 에도 안정적으로 사용할 수 있음을 의미합니다 . &lt;a href=&quot;http://bugs.mysql.com/bug.php?id=22047&quot;&gt;MySQL Bug # 22047&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="205e07ec88c96b9f9bcd25863f7d60b03d135d87" translate="yes" xml:space="preserve">
          <source>Note that as a difference to MySQL, in MariaDB the &lt;code&gt;TIME&lt;/code&gt; column (and also the &lt;code&gt;TIME_MS&lt;/code&gt; column) are not affected by any setting of &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#timestamp&quot;&gt;@TIMESTAMP&lt;/a&gt;&lt;/code&gt;. This means that it can be reliably used also for threads that change &lt;code&gt;@TIMESTAMP&lt;/code&gt; (such as the &lt;a href=&quot;../replication/index&quot;&gt;replication&lt;/a&gt; SQL thread). See also &lt;a href=&quot;https://bugs.mysql.com/bug.php?id=22047&quot;&gt;MySQL Bug #22047&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="095e4552b1ed84cfa72032852b18c17e005ac213" translate="yes" xml:space="preserve">
          <source>Note that as the amount of space available to root (OS user) may be more that what is available to non-root users, 'available' + 'used' may be less than 'total'.</source>
          <target state="translated">루트 (OS 사용자)가 사용할 수있는 공간이 루트가 아닌 사용자가 사용할 수있는 공간보다 많을 수 있으므로 '사용 가능'+ '사용됨'은 '총계'보다 작을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f1214fc8e14ca7b01469976fc8497aca04fa4e6" translate="yes" xml:space="preserve">
          <source>Note that atomic writes are only supported on &lt;a href=&quot;../fusion-io-introduction/index#atomic-writes&quot;&gt;Fusion-io devices that use the NVMFS file system&lt;/a&gt; in these versions of MariaDB.</source>
          <target state="translated">원자 쓰기는 이러한 버전의 MariaDB에서 &lt;a href=&quot;../fusion-io-introduction/index#atomic-writes&quot;&gt;NVMFS 파일 시스템을 사용하는 Fusion-io 장치&lt;/a&gt; 에서만 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="7494324aa0d1040096913c61c4596564f06aef5a" translate="yes" xml:space="preserve">
          <source>Note that before &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt;, queries returned from the query cache did not increment the &lt;a href=&quot;../server-status-variables/index#com_select&quot;&gt;Com_select&lt;/a&gt; status variable, so to find the total number of valid queries run on the server, add &lt;a href=&quot;../server-status-variables/index#com_select&quot;&gt;Com_select&lt;/a&gt; to &lt;a href=&quot;../server-status-variables/index#qcache_hits&quot;&gt;Qcache_hits&lt;/a&gt;. Starting from &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt;, results returned by the query cache count towards &lt;code&gt;Com_select&lt;/code&gt; (see &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-4981&quot;&gt;MDEV-4981&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt; 이전 에는 조회 캐시에서 리턴 된 조회가 &lt;a href=&quot;../server-status-variables/index#com_select&quot;&gt;Com_select&lt;/a&gt; 상태 변수를 증가 시키지 않았으므로 서버에서 실행되는 총 유효 조회 수를 찾으려면 &lt;a href=&quot;../server-status-variables/index#com_select&quot;&gt;Com_select&lt;/a&gt; 를 &lt;a href=&quot;../server-status-variables/index#qcache_hits&quot;&gt;Qcache_hits에&lt;/a&gt; 추가하십시오 . &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt; 부터 쿼리 캐시에 의해 반환 된 결과는 &lt;code&gt;Com_select&lt;/code&gt; 로 계산됩니다 ( &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-4981&quot;&gt;MDEV-4981&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="595fc04fea2c1e8a0cd8898b1d1d0bfbe7e92793" translate="yes" xml:space="preserve">
          <source>Note that before Galera 3, the &lt;code&gt;repl&lt;/code&gt; tag was named &lt;code&gt;replicator&lt;/code&gt;.</source>
          <target state="translated">Galera 3 이전에는 &lt;code&gt;repl&lt;/code&gt; 태그의 이름이 &lt;code&gt;replicator&lt;/code&gt; 였습니다.</target>
        </trans-unit>
        <trans-unit id="9011a557ff281e0a54ed27c955814b0d99a424f5" translate="yes" xml:space="preserve">
          <source>Note that both MySQL's InnoDB and Percona's XtraDB replacement are labeled as &lt;code&gt;InnoDB&lt;/code&gt;. However, if XtraDB is in use, it will be specified in the &lt;code&gt;COMMENT&lt;/code&gt; field. See &lt;a href=&quot;../xtradb-and-innodb/index&quot;&gt;XtraDB and InnoDB&lt;/a&gt;. The same applies to &lt;a href=&quot;../federatedx/index&quot;&gt;FederatedX&lt;/a&gt;.</source>
          <target state="translated">MySQL의 InnoDB 및 Percona의 XtraDB 교체는 모두 &lt;code&gt;InnoDB&lt;/code&gt; 로 표시되어 있습니다. 그러나 XtraDB를 사용중인 경우 &lt;code&gt;COMMENT&lt;/code&gt; 필드에 지정됩니다 . &lt;a href=&quot;../xtradb-and-innodb/index&quot;&gt;XtraDB 및 InnoDB를&lt;/a&gt; 참조하십시오 . &lt;a href=&quot;../federatedx/index&quot;&gt;FederatedX&lt;/a&gt; 에도 동일하게 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="6b2363a4543837a2c9b859d33b2c7ae929eeb57c" translate="yes" xml:space="preserve">
          <source>Note that building with MariaDB this way will disable tokuDB, till tokuDB becomes fully supported on musl.</source>
          <target state="translated">이 방법으로 MariaDB로 빌드하면 tokuDB가 musl에서 완전히 지원 될 때까지 tokuDB가 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="1e304854fdc300f576b9caaa1fd7a7931a88f035" translate="yes" xml:space="preserve">
          <source>Note that by default MariaDB is configured to work on a desktop system and should because of this not take a lot of resources. To get things to work for a dedicated server, you have to do a few minutes of work.</source>
          <target state="translated">기본적으로 MariaDB는 데스크탑 시스템에서 작동하도록 구성되며 이로 인해 많은 리소스를 소비하지 않아야합니다. 전용 서버에 대한 작업을 수행하려면 몇 분 동안 작업해야합니다.</target>
        </trans-unit>
        <trans-unit id="e8fc15359e3198256ceeca096d3e8f01795ad6eb" translate="yes" xml:space="preserve">
          <source>Note that by default, column values that are objects have been set to the concatenation of all the string values of the object separated by a blank. When a column value is an array, only the first item of the array is retrieved.</source>
          <target state="translated">기본적으로 개체 인 열 값은 공백으로 구분 된 개체의 모든 문자열 값을 연결하도록 설정되어 있습니다. 열 값이 배열이면 배열의 첫 번째 항목 만 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="ea92f0baf8f256f3ecca42e12172f5bd80f8656e" translate="yes" xml:space="preserve">
          <source>Note that current versions of this module are not &lt;a href=&quot;#multi-threaded-issues&quot;&gt;safe for multi-threaded environments&lt;/a&gt;, and the vendor does not officially support the product on MariaDB. See &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-10361&quot;&gt;MDEV-10361&lt;/a&gt; about that. However, the module may work with &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1040-release-notes/&quot;&gt;MariaDB 10.4.0&lt;/a&gt; and above.</source>
          <target state="translated">이 모듈의 현재 버전은 &lt;a href=&quot;#multi-threaded-issues&quot;&gt;다중 스레드 환경에 안전&lt;/a&gt; 하지 않으며 공급 업체는 MariaDB에서 공식적으로 제품을 지원하지 않습니다. 이에 대해서는 &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-10361&quot;&gt;MDEV-10361을&lt;/a&gt; 참조하십시오 . 그러나이 모듈은 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1040-release-notes/&quot;&gt;MariaDB 10.4.0 이상에서&lt;/a&gt; 작동 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b317554d728752af9cb48a22ca1afbd964fa0838" translate="yes" xml:space="preserve">
          <source>Note that data member &quot;x&quot; is an array, and data members &quot;y&quot; and &quot;z&quot; are strings. The following examples demonstrate the differences between the two functions.</source>
          <target state="translated">데이터 멤버 &quot;x&quot;는 배열이고 데이터 멤버 &quot;y&quot;및 &quot;z&quot;는 문자열입니다. 다음 예제는 두 기능의 차이점을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="f8522323db506e9278a8f6ce8034cd16d01881ad" translate="yes" xml:space="preserve">
          <source>Note that domain ID and server ID are distinct concepts. It is possible to use a different domain ID on each server, but this is normally not desirable. It makes the current GTID position (@@global.gtid_slave_pos) more complicated to understand and work with, and loses the concept of a single ordered binlog stream across all servers. It is recommended only to configure as many domain IDs as there are master servers actively being updated by the application at the same time.</source>
          <target state="translated">도메인 ID와 서버 ID는 서로 다른 개념입니다. 각 서버에서 다른 도메인 ID를 사용할 수 있지만 일반적으로 바람직하지 않습니다. 현재 GTID 위치 (@@ global.gtid_slave_pos)를 이해하고 작업하기가 더 복잡해지며 모든 서버에서 단일 순서의 binlog 스트림 개념을 잃게됩니다. 응용 프로그램에서 동시에 업데이트하는 마스터 서버가있는 한 도메인 ID 수만 구성하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="0cd1b9198e2595e6ed64c467b984833e494dad4d" translate="yes" xml:space="preserve">
          <source>Note that during the build few helper tools are compiled and then immediately used to generate more source files for this very build. When cross-compiling these tools naturally should be built for the host architecture, not for the target architecture. Do it like this (assuming you're in the mariadb source tree):</source>
          <target state="translated">빌드하는 동안 몇 가지 도우미 도구가 컴파일 된 다음이 빌드를 위해 더 많은 소스 파일을 생성하는 데 즉시 사용됩니다. 크로스 컴파일 할 때 이러한 도구는 대상 아키텍처가 아닌 호스트 아키텍처를 위해 자연스럽게 구축되어야합니다. 다음과 같이하십시오 (mariadb 소스 트리에 있다고 가정).</target>
        </trans-unit>
        <trans-unit id="3c6ce2800c675c82654cbc41b144b76d66a86716" translate="yes" xml:space="preserve">
          <source>Note that each of these users needs a password, so we can set it for each user with &lt;code&gt;&lt;a href=&quot;http://www.openldap.org/software/man.cgi?query=ldappasswd&amp;amp;apropos=0&amp;amp;sektion=1&amp;amp;manpath=OpenLDAP+2.4-Release&amp;amp;format=html&quot;&gt;ldappasswd&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">이러한 각 사용자는 비밀번호가 필요하므로 &lt;code&gt;&lt;a href=&quot;http://www.openldap.org/software/man.cgi?query=ldappasswd&amp;amp;apropos=0&amp;amp;sektion=1&amp;amp;manpath=OpenLDAP+2.4-Release&amp;amp;format=html&quot;&gt;ldappasswd&lt;/a&gt;&lt;/code&gt; 를 사용하여 각 사용자에 대해 비밀번호를 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="65374fa822c9f5e642b3116282b3eff3ad70508f" translate="yes" xml:space="preserve">
          <source>Note that each of these users needs a password, so we can set it for each user with &lt;code&gt;&lt;a href=&quot;https://www.openldap.org/software/man.cgi?query=ldappasswd&amp;amp;apropos=0&amp;amp;sektion=1&amp;amp;manpath=OpenLDAP+2.4-Release&amp;amp;format=html&quot;&gt;ldappasswd&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="facbe7f6187e8fc1ac7c6bca6d7167127858d6cc" translate="yes" xml:space="preserve">
          <source>Note that even if there is no parallelism available from the master &lt;a href=&quot;../group-commit-for-the-binary-log/index&quot;&gt;group commit&lt;/a&gt;, there is still an opportunity for speedup from in-order parallel replication, since the actual commit steps of different transactions can run in parallel. This can be particularly effective on a slave with binlog enabled (&lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#log_slave_updates&quot;&gt;log_slave_updates=1&lt;/a&gt;), and more so if slave is configured to be crash-safe (&lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#sync_binlog&quot;&gt;sync_binlog=1&lt;/a&gt; and &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_flush_log_at_trx_commit&quot;&gt;innodb_flush_log_at_trx_commit=1&lt;/a&gt;), as this makes &lt;a href=&quot;../group-commit-for-the-binary-log/index&quot;&gt;group commit&lt;/a&gt; possible on the slave.</source>
          <target state="translated">마스터 &lt;a href=&quot;../group-commit-for-the-binary-log/index&quot;&gt;그룹 commit&lt;/a&gt; 에서 사용할 수있는 병렬 처리가없는 경우에도 다른 트랜잭션의 실제 커밋 단계가 병렬로 실행될 수 있기 때문에 순차적 병렬 복제로 속도가 향상 될 수 있습니다. 이는 binlog가 활성화 된 ( &lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#log_slave_updates&quot;&gt;log_slave_updates = 1&lt;/a&gt; ) 슬레이브에서 특히 효과적 일 수 있으며 , 슬레이브가 충돌 안전 ( &lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#sync_binlog&quot;&gt;sync_binlog = 1&lt;/a&gt; 및 &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_flush_log_at_trx_commit&quot;&gt;innodb_flush_log_at_trx_commit = 1&lt;/a&gt; ) 으로 구성된 경우 슬레이브에서 &lt;a href=&quot;../group-commit-for-the-binary-log/index&quot;&gt;그룹 커밋이&lt;/a&gt; 가능해 지므로 더욱 효과적 입니다.</target>
        </trans-unit>
        <trans-unit id="bdac9953e2e16bc9f6b75eabd75e6b9c4e7687d0" translate="yes" xml:space="preserve">
          <source>Note that explicit or implicit casts from MAX(string) to INT, DOUBLE or DECIMAL now produce warnings (&lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-8852&quot;&gt;MDEV-8852&lt;/a&gt;).</source>
          <target state="translated">MAX (string)에서 INT, DOUBLE 또는 DECIMAL 로의 명시 적 또는 암시 적 캐스트는 이제 경고 ( &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-8852&quot;&gt;MDEV-8852&lt;/a&gt; )를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a2d8ae6bb2a9f1306944e72a652d84c7446bcc91" translate="yes" xml:space="preserve">
          <source>Note that for &lt;code&gt;OPTIMIZE TABLE&lt;/code&gt; to process InnoDB fulltext index data, the &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_optimize_fulltext_only&quot;&gt;innodb_optimize_fulltext_only&lt;/a&gt; system variable needs to be set to &lt;code&gt;1&lt;/code&gt;. When this is done, and an &lt;code&gt;OPTIMIZE TABLE&lt;/code&gt; statement run, the &lt;code&gt;INNODB_FT_INDEX_CACHE&lt;/code&gt; table will be emptied, and the &lt;a href=&quot;../information-schema-innodb_ft_index_table-table/index&quot;&gt;INNODB_FT_INDEX_TABLE&lt;/a&gt; table will be updated.</source>
          <target state="translated">위한 유의 &lt;code&gt;OPTIMIZE TABLE&lt;/code&gt; 이노 전체 텍스트 인덱스 데이터를 처리하기 위해, 상기 &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_optimize_fulltext_only&quot;&gt;innodb_optimize_fulltext_only&lt;/a&gt; 시스템 변수 요구가 설정된다 &lt;code&gt;1&lt;/code&gt; . 이 작업이 완료되고 &lt;code&gt;OPTIMIZE TABLE&lt;/code&gt; 문이 실행되면 &lt;code&gt;INNODB_FT_INDEX_CACHE&lt;/code&gt; 테이블이 비워지고 &lt;a href=&quot;../information-schema-innodb_ft_index_table-table/index&quot;&gt;INNODB_FT_INDEX_TABLE&lt;/a&gt; 테이블이 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="e535d1190526eb25937d033acba188944400d5aa" translate="yes" xml:space="preserve">
          <source>Note that for &lt;code&gt;OPTIMIZE TABLE&lt;/code&gt; to process InnoDB fulltext index data, the &lt;a href=&quot;innodb-server-system-variables#innodb_optimize_fulltext_only&quot;&gt;innodb_optimize_fulltext_only&lt;/a&gt; system variable needs to be set to &lt;code&gt;1&lt;/code&gt;. When this is done, and an &lt;code&gt;OPTIMIZE TABLE&lt;/code&gt; statement run, the &lt;a href=&quot;../information-schema-innodb_ft_index_cache-table/index&quot;&gt;INNODB_FT_INDEX_CACHE&lt;/a&gt; table will be emptied, and the &lt;code&gt;INNODB_FT_INDEX_TABLE&lt;/code&gt; table will be updated.</source>
          <target state="translated">위한 유의 &lt;code&gt;OPTIMIZE TABLE&lt;/code&gt; 이노 전체 텍스트 인덱스 데이터를 처리하기 위해, 상기 &lt;a href=&quot;innodb-server-system-variables#innodb_optimize_fulltext_only&quot;&gt;innodb_optimize_fulltext_only&lt;/a&gt; 시스템 변수 요구가 설정된다 &lt;code&gt;1&lt;/code&gt; . 이 작업이 완료되고 &lt;code&gt;OPTIMIZE TABLE&lt;/code&gt; 문이 실행되면 &lt;a href=&quot;../information-schema-innodb_ft_index_cache-table/index&quot;&gt;INNODB_FT_INDEX_CACHE&lt;/a&gt; 테이블이 비워지고 &lt;code&gt;INNODB_FT_INDEX_TABLE&lt;/code&gt; 테이블이 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="a4680d5af9faaa28d45e823a455a590b3a94537d" translate="yes" xml:space="preserve">
          <source>Note that for a partitioned table, &lt;code&gt;DROP TABLE&lt;/code&gt; permanently removes the table definition, all of its partitions, and all of the data which was stored in those partitions. It also removes the partitioning definition (.par) file associated with the dropped table.</source>
          <target state="translated">파티션 된 테이블의 경우 &lt;code&gt;DROP TABLE&lt;/code&gt; 은 테이블 정의, 모든 해당 파티션 및 해당 파티션에 저장된 모든 데이터를 영구적으로 제거합니다. 또한 삭제 된 테이블과 연관된 파티셔닝 정의 (.par) 파일을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="171b8cd9471d626d7874c82790afb5342ad1073f" translate="yes" xml:space="preserve">
          <source>Note that for scalability reasons, the automatic creation of a new &lt;code&gt;mysql.gtid_slave_posXXX&lt;/code&gt; table happens asynchronously when the first transaction with the new storage engine is committed. So the very first few transactions will update the old version of the table, until the new version is created and available.</source>
          <target state="translated">확장 성의 이유로, 새로운 &lt;code&gt;mysql.gtid_slave_posXXX&lt;/code&gt; 테이블 의 자동 생성은 새로운 스토리지 엔진과의 첫 번째 트랜잭션이 커밋 될 때 비동기 적으로 수행됩니다. 따라서 처음 몇 트랜잭션은 새 버전이 작성되어 사용 가능할 때까지 테이블의 이전 버전을 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="e532b131d9526b416e05a3bb9a0fe2077e7287d1" translate="yes" xml:space="preserve">
          <source>Note that ha_tokudb is not included in binaries built with the &quot;old&quot; glibc. Binaries built with glibc 2.14+ do include it.</source>
          <target state="translated">ha_tokudb는 &quot;old&quot;glibc로 빌드 된 바이너리에는 포함되지 않습니다. glibc 2.14+로 빌드 된 바이너리는이를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="7f764322aeb7490aaadf24422792f2f390c79f00" translate="yes" xml:space="preserve">
          <source>Note that if a statement can be run in a stored routine, it will work even if it is called by a prepared statement. For example, &lt;a href=&quot;../signal/index&quot;&gt;SIGNAL&lt;/a&gt; can't be directly prepared. However, it is allowed in &lt;a href=&quot;../stored-routines/index&quot;&gt;stored routines&lt;/a&gt;. If the x() procedure contains SIGNAL, you can still prepare and execute the 'CALL x();' prepared statement.</source>
          <target state="translated">저장 루틴에서 명령문을 실행할 수 있으면 준비된 명령문에 의해 호출 된 경우에도 작동합니다. 예를 들어, &lt;a href=&quot;../signal/index&quot;&gt;SIGNAL&lt;/a&gt; 은 직접 준비 될 수 없습니다. 그러나 &lt;a href=&quot;../stored-routines/index&quot;&gt;스토어드 루틴&lt;/a&gt; 에서는 허용 됩니다 . x () 프로 시저에 SIGNAL이 포함되어 있으면 여전히 'CALL x ();'를 준비하고 실행할 수 있습니다. 준비된 진술.</target>
        </trans-unit>
        <trans-unit id="e9014e514884af0cfad398865431efc249b3544d" translate="yes" xml:space="preserve">
          <source>Note that if a string column is being compared with a numeric value, MariaDB will not use the index on the column, as there are numerous alternatives that may evaluate as equal (see examples below).</source>
          <target state="translated">문자열 열을 숫자 값과 비교하는 경우 MariaDB는 동일한 것으로 평가 될 수있는 여러 가지 대안이 있으므로 열에서 인덱스를 사용하지 않습니다 (아래 예 참조).</target>
        </trans-unit>
        <trans-unit id="10442f6154495c2f350fa4830c35cf654fdbb18b" translate="yes" xml:space="preserve">
          <source>Note that if an error occurs within a &lt;code&gt;CONTINUE HANDLER&lt;/code&gt; block, it can be handled by another &lt;code&gt;HANDLER&lt;/code&gt;. However, a &lt;code&gt;HANDLER&lt;/code&gt; which is already in the stack (that is, it has been called to handle an error and its execution didn't finish yet) cannot handle new errors&amp;mdash;this prevents endless loops. For example, suppose that a stored procedure contains a &lt;code&gt;CONTINUE HANDLER&lt;/code&gt; for &lt;code&gt;SQLWARNING&lt;/code&gt; and another &lt;code&gt;CONTINUE HANDLER&lt;/code&gt; for &lt;code&gt;NOT FOUND&lt;/code&gt;. At some point, a NOT FOUND error occurs, and the execution enters the &lt;code&gt;NOT FOUND HANDLER&lt;/code&gt;. But within that handler, a warning occurs, and the execution enters the &lt;code&gt;SQLWARNING HANDLER&lt;/code&gt;. If another &lt;code&gt;NOT FOUND&lt;/code&gt; error occurs, it cannot be handled again by the &lt;code&gt;NOT FOUND HANDLER&lt;/code&gt;, because its execution is not finished.</source>
          <target state="translated">&lt;code&gt;CONTINUE HANDLER&lt;/code&gt; 블록 내에서 오류가 발생하면 다른 &lt;code&gt;HANDLER&lt;/code&gt; 가 처리 할 수 ​​있습니다 . 그러나 이미 스택에 있는 &lt;code&gt;HANDLER&lt;/code&gt; (즉, 오류를 처리하기 위해 호출되었고 아직 실행이 완료되지 않은)는 새 오류를 처리 할 수 ​​없으므로 무한 루프를 방지합니다. 예를 들어, 스토어드 프로 시저 에 &lt;code&gt;SQLWARNING&lt;/code&gt; 용 &lt;code&gt;CONTINUE HANDLER&lt;/code&gt; 가 있고 &lt;code&gt;NOT FOUND&lt;/code&gt; 용 &lt;code&gt;CONTINUE HANDLER&lt;/code&gt; 가 있다고 가정하십시오 . 어떤 시점에서 NOT FOUND 오류가 발생하고 실행이 &lt;code&gt;NOT FOUND HANDLER&lt;/code&gt; 로 들어갑니다 . 그러나 해당 핸들러 내에서 경고가 발생하고 실행이 &lt;code&gt;SQLWARNING HANDLER&lt;/code&gt; 로 들어갑니다 . 다른 경우 &lt;code&gt;NOT FOUND&lt;/code&gt; 오류가 발생하면 실행이 완료되지 않아 &lt;code&gt;NOT FOUND HANDLER&lt;/code&gt; 가 다시 처리 할 수 ​​없습니다 .</target>
        </trans-unit>
        <trans-unit id="004e740cb43fbd8a4d4fb5ae885b5fdae627b2af" translate="yes" xml:space="preserve">
          <source>Note that if we run &lt;a href=&quot;../mysqladmin/index#mysqladmin-commands&quot;&gt;mysqladmin shutdown&lt;/a&gt; or the &lt;a href=&quot;../shutdown/index&quot;&gt;SHUTDOWN&lt;/a&gt; command to stop the container, the container will be deactivated, and we will automatically exit to our system.</source>
          <target state="translated">우리가 실행하는 경우하는 것으로 &lt;a href=&quot;../mysqladmin/index#mysqladmin-commands&quot;&gt;mysqladmin 데이터의 종료&lt;/a&gt; 또는 &lt;a href=&quot;../shutdown/index&quot;&gt;종료&lt;/a&gt; 컨테이너를 중지 명령을, 용기가 비활성화됩니다, 우리는 자동으로 우리 시스템에 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="ec6b10803c2ab7a03aeafe5d112cd77d3550b27b" translate="yes" xml:space="preserve">
          <source>Note that if you are migrating from the MySQL Enterprise thread pool plugin, then the unit used in their implementation is 10ms, not 1ms.</source>
          <target state="translated">MySQL Enterprise 스레드 풀 플러그인에서 마이그레이션하는 경우 구현에 사용되는 단위는 1ms가 아니라 10ms입니다.</target>
        </trans-unit>
        <trans-unit id="d3440665789a38165b5011e01e644fc8cba208d9" translate="yes" xml:space="preserve">
          <source>Note that if you change an existing repository configuration, then you need to execute the following:</source>
          <target state="translated">기존 리포지토리 구성을 변경하면 다음을 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="d0592128989db5df2c89f84ee20a391b09f30f5f" translate="yes" xml:space="preserve">
          <source>Note that if you change the page size you have to dump all your old tables into text (with &lt;code&gt;&lt;a href=&quot;../mysqldump/index&quot;&gt;mysqldump&lt;/a&gt;&lt;/code&gt;) and remove the old Aria log and files:</source>
          <target state="translated">페이지 크기를 변경하면 모든 이전 테이블을 &lt;code&gt;&lt;a href=&quot;../mysqldump/index&quot;&gt;mysqldump&lt;/a&gt;&lt;/code&gt; 를 사용 하여 텍스트로 덤프 하고 이전 Aria 로그 및 파일을 제거해야합니다.</target>
        </trans-unit>
        <trans-unit id="41ab694f4dab8d7dbac6f5b8b6e12533ef980c09" translate="yes" xml:space="preserve">
          <source>Note that if you had an AUTO_INCREMENT in this table, IODKU would &quot;burn&quot; ids quite rapidly.</source>
          <target state="translated">이 테이블에 AUTO_INCREMENT가 있으면 IODKU가 ID를 매우 빠르게 &quot;굽습니다&quot;.</target>
        </trans-unit>
        <trans-unit id="5489e2bb5a77cca645317662fdd8fb1a417adfc1" translate="yes" xml:space="preserve">
          <source>Note that if you use the &lt;code&gt;mariabackup&lt;/code&gt; SST method, then you also need to have &lt;code&gt;&lt;a href=&quot;#socat-dependency&quot;&gt;socat&lt;/a&gt;&lt;/code&gt; installed on the server. This is needed to stream the backup from the donor node to the joiner node. This is a limitation that was inherited from the &lt;code&gt;&lt;a href=&quot;../xtrabackup-v2-sst-method/index&quot;&gt;xtrabackup-v2&lt;/a&gt;&lt;/code&gt; SST method.</source>
          <target state="translated">&lt;code&gt;mariabackup&lt;/code&gt; SST 방법 을 사용하는 경우 서버에 &lt;code&gt;&lt;a href=&quot;#socat-dependency&quot;&gt;socat&lt;/a&gt;&lt;/code&gt; 이 설치되어 있어야합니다. 이는 기증자 노드에서 결합 자 노드로 백업을 스트리밍하는 데 필요합니다. 이것은 &lt;code&gt;&lt;a href=&quot;../xtrabackup-v2-sst-method/index&quot;&gt;xtrabackup-v2&lt;/a&gt;&lt;/code&gt; SST 메소드 에서 상속 된 제한 사항입니다 .</target>
        </trans-unit>
        <trans-unit id="d7740020bbae96d94eb3886aab313bc534099aec" translate="yes" xml:space="preserve">
          <source>Note that if you use the &lt;code&gt;xtrabackup-v2&lt;/code&gt; SST method, then you also need to have &lt;code&gt;&lt;a href=&quot;#socat-dependency&quot;&gt;socat&lt;/a&gt;&lt;/code&gt; installed on the server. This is needed to stream the backup from the donor node to the joiner node.</source>
          <target state="translated">&lt;code&gt;xtrabackup-v2&lt;/code&gt; SST 방법 을 사용하는 경우 서버에 &lt;code&gt;&lt;a href=&quot;#socat-dependency&quot;&gt;socat&lt;/a&gt;&lt;/code&gt; 이 설치되어 있어야합니다. 이는 기증자 노드에서 결합 자 노드로 백업을 스트리밍하는 데 필요합니다.</target>
        </trans-unit>
        <trans-unit id="971d0b15f4b7a9d94bd22e1f722fd8fe95057d2a" translate="yes" xml:space="preserve">
          <source>Note that if your operating system has scripts that require password-less access to MariaDB, then this may break those scripts. You may be able to fix that by setting a password in the &lt;code&gt;[client]&lt;/code&gt;&lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;option group&lt;/a&gt; in your /root/.my.cnf &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;option file&lt;/a&gt;. For example:</source>
          <target state="translated">운영 체제에 MariaDB에 암호없이 액세스해야하는 스크립트가있는 경우 해당 스크립트가 손상 될 수 있습니다. /root/.my.cnf &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;옵션 파일&lt;/a&gt; 의 &lt;code&gt;[client]&lt;/code&gt; &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;옵션 그룹&lt;/a&gt; 에서 비밀번호를 설정 하여이 문제를 해결할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8fe32502f11379808f4d57deb13c1c88184959b6" translate="yes" xml:space="preserve">
          <source>Note that in MariaDB, &lt;code&gt;INT&lt;/code&gt; and &lt;code&gt;INTEGER&lt;/code&gt; are the same thing.</source>
          <target state="translated">MariaDB에서 &lt;code&gt;INT&lt;/code&gt; 와 &lt;code&gt;INTEGER&lt;/code&gt; 는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="3e74b3ab0842aabdf0cce0fd9db332d160172ddb" translate="yes" xml:space="preserve">
          <source>Note that in any case, only queries that takes longer than &lt;strong&gt;log_slow_time&lt;/strong&gt; or &lt;strong&gt;long_query_time&lt;/strong&gt;' are logged (as before).</source>
          <target state="translated">&lt;strong&gt;어쨌든 log_slow_time&lt;/strong&gt; 또는 &lt;strong&gt;long_query_time&lt;/strong&gt; ' 보다 오래 걸리는 쿼리 만 기록됩니다 (전과 같이).</target>
        </trans-unit>
        <trans-unit id="92d3053902175172349f5129f98fbd3feea59520" translate="yes" xml:space="preserve">
          <source>Note that in both case the test.json file is not modified. This is because the &lt;em&gt;Json_File&lt;/em&gt; function returns a string representing all or part of the file text but no information about the file name. This is all right to check what would be the effect of the modification to the file.</source>
          <target state="translated">두 경우 모두 test.json 파일은 수정되지 않습니다. &lt;em&gt;Json_File&lt;/em&gt; 함수는 파일 이름에 대한 정보는 없지만 파일 텍스트의 일부 또는 전부를 나타내는 문자열을 반환 하기 때문 입니다. 이것은 파일 수정의 영향을 확인하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="5b10bfd387af714694140b15003972e98725ec58" translate="yes" xml:space="preserve">
          <source>Note that in contrast to MySQL, all variables always show the correct active value!</source>
          <target state="translated">MySQL과 달리 모든 변수는 항상 올바른 활성 값을 보여줍니다!</target>
        </trans-unit>
        <trans-unit id="3a5eccc7216377c5bb950f1668cc92cc222f44c7" translate="yes" xml:space="preserve">
          <source>Note that in the case of the MySQL or MariaDB connectors, because they internally read the whole result set in memory, using the MEMORY option would be a waste of memory. It is much better to specify the use of a scrollable cursor when needed.</source>
          <target state="translated">MySQL 또는 MariaDB 커넥터의 경우 내부적으로 메모리에서 전체 결과 세트를 읽으므로 MEMORY 옵션을 사용하면 메모리가 낭비됩니다. 필요할 때 스크롤 가능한 커서 사용을 지정하는 것이 훨씬 좋습니다.</target>
        </trans-unit>
        <trans-unit id="a31d611578353677b5b07466032a9114868c8a0b" translate="yes" xml:space="preserve">
          <source>Note that in the examples below, &lt;code&gt;[connection_name]&lt;/code&gt; is used as the &lt;a href=&quot;../multi-source-replication/index&quot;&gt;name of the connection&lt;/a&gt;. If you are not using named connections you can ignore this.</source>
          <target state="translated">아래 예에서 &lt;code&gt;[connection_name]&lt;/code&gt; 은 연결 &lt;a href=&quot;../multi-source-replication/index&quot;&gt;이름으로&lt;/a&gt; 사용됩니다 . 명명 된 연결을 사용하지 않는 경우이를 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28a57dc351b8489a06550a280c9b822199b5f7a1" translate="yes" xml:space="preserve">
          <source>Note that it implies you are connecting via the unix socket, not tcp. If you happen to have &lt;code&gt;protocol=tcp&lt;/code&gt; in a system-wide &lt;code&gt;/etc/my.cnf&lt;/code&gt; file, use &lt;code&gt;sudo mysql --protocol=socket&lt;/code&gt;.</source>
          <target state="translated">tcp가 아닌 unix 소켓을 통해 연결하고 있음을 의미합니다. 당신이 일어날 경우 &lt;code&gt;protocol=tcp&lt;/code&gt; 시스템 전체에 &lt;code&gt;/etc/my.cnf&lt;/code&gt; 에의 파일, 사용 &lt;code&gt;sudo mysql --protocol=socket&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6fecc4d1b43028233e7beb7cd01dc0621841a35c" translate="yes" xml:space="preserve">
          <source>Note that it is important to repeat the test for thd-&amp;gt;killed after &lt;code&gt;enter_cond()&lt;/code&gt;. Otherwise the killing thread may kill this thread after it tested &lt;code&gt;thd-&amp;gt;killed&lt;/code&gt; in the loop condition and before it registered the condition variable and mutex in &lt;code&gt;enter_cond()&lt;/code&gt;. In this case, the killing thread does not know that this thread is going to wait on a condition variable. It would just set &lt;code&gt;THD::killed&lt;/code&gt;. But if we would not test it again, we would go asleep though we are killed. If the killing thread would kill us when we are after the second test, but still before sleeping, we hold the mutex, which is registered in mysys_var. The killing thread would try to acquire the mutex before signaling the condition variable. Since the mutex is only released implicitly in &lt;code&gt;mysql_cond_wait()&lt;/code&gt;, the signaling happens at the right place. We have a safe synchronization.</source>
          <target state="translated">&lt;code&gt;enter_cond()&lt;/code&gt; 다음에 thd-&amp;gt; killed 테스트를 반복하는 것이 중요합니다 . 그렇지 않으면, killing thread는 루프 조건에서 &lt;code&gt;thd-&amp;gt;killed&lt;/code&gt; 를 테스트 한 후 &lt;code&gt;enter_cond()&lt;/code&gt; 에 조건 변수와 mutex를 등록하기 전에이 스레드를 강제 종료 할 수 있습니다 . 이 경우, 종료 스레드는이 스레드가 조건 변수를 기다릴 것이라는 것을 알지 못합니다. &lt;code&gt;THD::killed&lt;/code&gt; 설정 했을 뿐입니다.. 그러나 우리가 다시 시험하지 않으면, 우리는 죽었지 만 잠들 것입니다. 우리가 두 번째 테스트 후에도 여전히 잠자기 전에 죽이는 스레드가 우리를 죽이는 경우 mysys_var에 등록 된 뮤텍스를 보유합니다. killing thread는 조건 변수를 신호하기 전에 뮤텍스를 획득하려고 시도합니다. 뮤텍스는 &lt;code&gt;mysql_cond_wait()&lt;/code&gt; 에서만 암시 적으로 해제 되므로 시그널링은 올바른 위치에서 발생합니다. 안전한 동기화가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c70c317cf3e3aa74ab252f4701e450d5db05f67" translate="yes" xml:space="preserve">
          <source>Note that it is not entirely accurate to say that the MariaDB version does not support the command. It would be more accurate to say that the MariaDB configuration does not support the command. See &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-20500&quot;&gt;MDEV-20500&lt;/a&gt; for more information.</source>
          <target state="translated">MariaDB 버전이 명령을 지원하지 않는다고 말하는 것이 전적으로 정확하지는 않습니다. MariaDB 구성이 명령을 지원하지 않는다고 말하는 것이 더 정확합니다. 자세한 내용은 &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-20500&quot;&gt;MDEV-20500&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bb4d1a287b1b870e8120b924597eae7e0b171a95" translate="yes" xml:space="preserve">
          <source>Note that it is not necessary to use &lt;code&gt;DROP VIEW&lt;/code&gt; to replace an existing view, because &lt;code&gt;&lt;a href=&quot;../create-view/index&quot;&gt;CREATE VIEW&lt;/a&gt;&lt;/code&gt; has an &lt;code&gt;OR REPLACE&lt;/code&gt; clause.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../create-view/index&quot;&gt;CREATE VIEW&lt;/a&gt;&lt;/code&gt; 에는 &lt;code&gt;OR REPLACE&lt;/code&gt; 절이 있으므로 &lt;code&gt;DROP VIEW&lt;/code&gt; 를 사용 하여 기존 뷰를 바꿀 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="ba9af43412db5ae5491495748480c4a16b5aca8f" translate="yes" xml:space="preserve">
          <source>Note that it makes no sense to try to set a session variable inside a &lt;code&gt;SET STATEMENT&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;SET STATEMENT&lt;/code&gt; 내에 세션 변수를 설정하려고 시도하는 것은 의미가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="f27f827088d2e58e7afbed47e81bf5b7d2bf20ad" translate="yes" xml:space="preserve">
          <source>Note that look-ahead and look-behind assertions can only be of fixed length; you cannot have repetition operators or alternations with different lengths:</source>
          <target state="translated">look-ahead 및 look-behind 어설 션의 길이는 고정 길이 일 수 있습니다. 길이가 다른 반복 연산자 나 대체 연산자를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="419380f944bd4bfe87167c91369d2a93d9c1b524" translate="yes" xml:space="preserve">
          <source>Note that moving a table to another database is not possible if it has some triggers. Trying to do so produces the following error:</source>
          <target state="translated">트리거가 있으면 테이블을 다른 데이터베이스로 이동할 수 없습니다. 이렇게하면 다음 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="91db487b659cd1a75cf5dc3b93d66f07e13342d5" translate="yes" xml:space="preserve">
          <source>Note that nodes are uni-directional, so there is no path from node 6 to node 1:</source>
          <target state="translated">노드는 단방향이므로 노드 6에서 노드 1까지의 경로는 없습니다.</target>
        </trans-unit>
        <trans-unit id="47664f1554d9803f7aced3be942cedd8ef6942d6" translate="yes" xml:space="preserve">
          <source>Note that not all MariaDB-enhancements are listed on this page. See &lt;a href=&quot;../mysqltest-and-mysqltest-embedded/index&quot;&gt;mysqltest and mysqltest-embedded&lt;/a&gt; for a full set of options.</source>
          <target state="translated">모든 MariaDB 향상 기능이이 페이지에 나열되어 있지는 않습니다. 전체 옵션 세트에 대해서는 &lt;a href=&quot;../mysqltest-and-mysqltest-embedded/index&quot;&gt;mysqltest 및 mysqltest 내장&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b22d3b8f85447e791aecf6ffcee74436024c4582" translate="yes" xml:space="preserve">
          <source>Note that options may be put either on one line or on separate lines. It is a good idea to start an option name with the &lt;code&gt;--loose-&lt;/code&gt; prefix if the server may or may not recognize the option depending on the configuration. An unknown option in the &lt;code&gt;.opt&lt;/code&gt; file will stop the server from starting, and the test will be aborted.</source>
          <target state="translated">옵션은 한 줄 또는 개별 줄에 둘 수 있습니다. 서버가 구성에 따라 옵션을 인식하거나 인식하지 못하는 경우 &lt;code&gt;--loose-&lt;/code&gt; 접두어 로 옵션 이름을 시작하는 것이 좋습니다 . &lt;code&gt;.opt&lt;/code&gt; 파일 에 알 수없는 옵션이 있으면 서버 시작이 중지되고 테스트가 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="c8dae4df67156a5332b99deadb80d2fceaae7494" translate="yes" xml:space="preserve">
          <source>Note that passwords can be directly set as a hash, bypassing the password validation, if the &lt;a href=&quot;../server-system-variables/index#strict_password_validation&quot;&gt;strict_password_validation&lt;/a&gt; variable is &lt;code&gt;OFF&lt;/code&gt; (it is &lt;code&gt;ON&lt;/code&gt; by default).</source>
          <target state="translated">&lt;a href=&quot;../server-system-variables/index#strict_password_validation&quot;&gt;strict_password_validation&lt;/a&gt; 변수가 &lt;code&gt;OFF&lt;/code&gt; ( 기본적으로 &lt;code&gt;ON&lt;/code&gt; ) 인 경우 비밀번호 유효성 검사를 무시하고 비밀번호를 직접 해시로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0ecb4c2af8368b95938e713ad7e6f02ee5f7eab3" translate="yes" xml:space="preserve">
          <source>Note that sequences can't generate the maximum/minimum 64 bit number because of the constraint of &lt;code&gt;MINVALUE&lt;/code&gt; and &lt;code&gt;MAXVALUE&lt;/code&gt;.</source>
          <target state="translated">시퀀스는 &lt;code&gt;MINVALUE&lt;/code&gt; 및 &lt;code&gt;MAXVALUE&lt;/code&gt; 제약으로 인해 최대 / 최소 64 비트 숫자를 생성 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="75ad7b851090e5fc0266d3a1eb2600776f2767e3" translate="yes" xml:space="preserve">
          <source>Note that soft group commit should only be used if you can afford to lose a few rows if your machine shuts down hard (as in the case of a power failure).</source>
          <target state="translated">소프트 그룹 커밋은 시스템이 하드 종료 된 경우 (정전시와 같이) 몇 개의 행을 잃을 수있는 경우에만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="e9369798d48f3872aafee25c1263ec2298d016dc" translate="yes" xml:space="preserve">
          <source>Note that statistic counters are never reset, even if a rollback occurs. For example, if an &lt;code&gt;UPDATE
&lt;/code&gt; statement is rolled back, &lt;code&gt;xtstat&lt;/code&gt; will still indicate that one write statement (see stat-write below) was executed.</source>
          <target state="translated">롤백이 발생하더라도 통계 카운터는 재설정되지 않습니다. 예를 들어, &lt;code&gt;UPDATE &lt;/code&gt; 문이 롤백 된 경우 &lt;code&gt;xtstat&lt;/code&gt; 는 여전히 하나의 쓰기 문 (아래 stat-write 참조)이 실행되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ec335cc1197f802a522c920ba4c18fbf0f944ed9" translate="yes" xml:space="preserve">
          <source>Note that statistics for blob and text columns are not collected. If explicitly specified, a warning is returned.</source>
          <target state="translated">Blob 및 텍스트 열에 대한 통계는 수집되지 않습니다. 명시 적으로 지정된 경우 경고가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="75d5098fa47356b01f68202a79fcc01b8da1b736" translate="yes" xml:space="preserve">
          <source>Note that storage engines can have their logs too: for example, InnoDB keeps an &lt;a href=&quot;../undo-log/index&quot;&gt;Undo Log&lt;/a&gt; and a Redo Log which are used for rollback and crash recovery. However, this page only lists MariaDB server logs.</source>
          <target state="translated">스토리지 엔진에도 로그가있을 수 있습니다. 예를 들어 InnoDB 는 롤백 및 응급 복구에 사용되는 실행 &lt;a href=&quot;../undo-log/index&quot;&gt;취소 로그&lt;/a&gt; 및 재실행 로그를 유지합니다 . 그러나이 페이지에는 MariaDB 서버 로그 만 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="d9811b6830a71b17e23be80d65246455e72bb6c8" translate="yes" xml:space="preserve">
          <source>Note that such tables are read only. In addition, the data will be retrieved from the web each time you query the table with a &lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt; statement. This is fine if the result varies each time, such as when you query a weather forecasting site. But if you want to use the retrieved file many times without reloading it, just create another table on the same file without specifying the HTTP option.</source>
          <target state="translated">이러한 테이블은 읽기 전용입니다. 또한 &lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt; 문으로 테이블을 쿼리 할 때마다 웹에서 데이터가 검색됩니다 . 일기 예보 사이트를 쿼리 할 때와 같이 결과가 매번 달라지면 문제가 없습니다. 그러나 검색된 파일을 다시로드하지 않고 여러 번 사용하려면 HTTP 옵션을 지정하지 않고 동일한 파일에 다른 테이블을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="f1b4facc8a590902a67b6849a42a1fe463630fff" translate="yes" xml:space="preserve">
          <source>Note that table &lt;code&gt;orders&lt;/code&gt; has &quot;Using rowid filter&quot;. The &lt;code&gt;type&lt;/code&gt; column has &lt;code&gt;&quot;|filter&quot;&lt;/code&gt;, the &lt;code&gt;key&lt;/code&gt; column shows the index that is used to construct the filter. &lt;code&gt;rows&lt;/code&gt; column shows the expected filter selectivity, it is 5%.</source>
          <target state="translated">테이블 &lt;code&gt;orders&lt;/code&gt; 에는 &quot;Rowid 필터 사용&quot;이 있습니다. &lt;code&gt;type&lt;/code&gt; 컬럼 갖는다 &lt;code&gt;&quot;|filter&quot;&lt;/code&gt; 의 &lt;code&gt;key&lt;/code&gt; 컬럼 표시 필터를 구성하는 데 사용되는 인덱스. &lt;code&gt;rows&lt;/code&gt; 열에는 예상되는 필터 선택성이 표시되며 5 %입니다.</target>
        </trans-unit>
        <trans-unit id="f18cc6c7a77f2b2d0d9d263b39688cca453b5745" translate="yes" xml:space="preserve">
          <source>Note that tablespace files (including ibdata1) will not shrink as the result of defragmentation, but one will get better memory utilization in the InnoDB buffer pool as there are fewer data pages in use.</source>
          <target state="translated">조각 모음으로 인해 테이블 ​​스페이스 파일 (ibdata1 포함)은 축소되지 않지만 사용중인 데이터 페이지 수가 적어 InnoDB 버퍼 풀에서 더 나은 메모리 사용률을 얻게됩니다.</target>
        </trans-unit>
        <trans-unit id="87055dc9fd601c6319310dcf72a5b1106dcac2b3" translate="yes" xml:space="preserve">
          <source>Note that the &quot;consumer&quot; events are not shown on this list. They can only be enabled at &lt;a href=&quot;../mysqld-options/index#performance-schema-options&quot;&gt;startup&lt;/a&gt;.</source>
          <target state="translated">&quot;소비자&quot;이벤트는이 목록에 표시되지 않습니다. &lt;a href=&quot;../mysqld-options/index#performance-schema-options&quot;&gt;시작시&lt;/a&gt; 에만 활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9649c602cdf8cf00105d56d3f75eba89892fd7c4" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;../grant/index#table-privileges&quot;&gt;Delete history&lt;/a&gt; privilege displays as &lt;code&gt;Delete versioning rows&lt;/code&gt; (&lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-20382&quot;&gt;MDEV-20382&lt;/a&gt;).</source>
          <target state="translated">참고 그 &lt;a href=&quot;../grant/index#table-privileges&quot;&gt;삭제 이력&lt;/a&gt; 등의 권한을 표시 &lt;code&gt;Delete versioning rows&lt;/code&gt; ( &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-20382&quot;&gt;인 mdev-20382&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="32bd5ff69f71fb7a759df61f9384454aee40a4f3" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;../mroonga/index&quot;&gt;Mroonga Storage Engine&lt;/a&gt; only supports a limited number of character sets. See &lt;a href=&quot;../about-mroonga/index#available-character-sets&quot;&gt;Mroonga available character sets&lt;/a&gt;.</source>
          <target state="translated">있습니다 &lt;a href=&quot;../mroonga/index&quot;&gt;Mroonga 저장소 엔진은&lt;/a&gt; 단지 문자 세트의 제한된 수를 지원합니다. &lt;a href=&quot;../about-mroonga/index#available-character-sets&quot;&gt;Mroonga 사용 가능한 문자 세트를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5d5f28b8686f13da798675142eda06a1335ffde7" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;../server-system-variables/index#join_buffer_size&quot;&gt;#join_buffer_size&lt;/a&gt; buffer is still needed by the SQL layer, so its value should still be increased if you want to read in big batches.</source>
          <target state="translated">있습니다 &lt;a href=&quot;../server-system-variables/index#join_buffer_size&quot;&gt;#join_buffer_size의&lt;/a&gt; 당신은 큰 일괄 적으로 읽으려면 그 값이 계속 증가해야하므로 버퍼가 여전히 SQL 층으로 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ba6bd248057571ebf1f22d09acb90723ec647c1b" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;''@'%'&lt;/code&gt; account is a special catch-all &lt;a href=&quot;../create-user/index#anonymous-accounts&quot;&gt;anonymous account&lt;/a&gt;. Any login by a user that has no more specific account match in the system will be matched by this anonymous account.</source>
          <target state="translated">있습니다 &lt;code&gt;''@'%'&lt;/code&gt; 계정이 특별한 포괄이다 &lt;a href=&quot;../create-user/index#anonymous-accounts&quot;&gt;익명 계정&lt;/a&gt; . 시스템에서 더 이상 특정 계정과 일치하지 않는 사용자의 로그인은이 익명 계정과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="7e97063640b6ddfa89665acb249ed0c795f86524" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-loose-&quot;&gt;loose&lt;/a&gt;&lt;/code&gt; option prefix is specified. This option prefix is used in case the plugin hasn't been installed yet.</source>
          <target state="translated">있습니다 &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-loose-&quot;&gt;loose&lt;/a&gt;&lt;/code&gt; 옵션 접두사가 지정됩니다. 이 옵션 접두사는 플러그인이 아직 설치되지 않은 경우에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9cf84004a8062ca0e654a771af3b3924b22e82b2" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;DELETE HISTORY&lt;/code&gt; privilege, introduced in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1034-release-notes/&quot;&gt;MariaDB 10.3.4&lt;/a&gt;, is displayed as &lt;code&gt;DELETE VERSIONING ROWS&lt;/code&gt; when running SHOW GRANTS (&lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-17655&quot;&gt;MDEV-17655&lt;/a&gt;).</source>
          <target state="translated">있습니다 &lt;code&gt;DELETE HISTORY&lt;/code&gt; 도입 특권 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1034-release-notes/&quot;&gt;MariaDB 10.3.4는&lt;/a&gt; ,로 표시됩니다 &lt;code&gt;DELETE VERSIONING ROWS&lt;/code&gt; SHOW 보조금 (실행시 &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-17655&quot;&gt;인 mdev-17655을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="32f00bc068e03220ffd0f7f2b16005e6a3fcdd38" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;PROGRESS&lt;/code&gt; field from the information schema, and the &lt;code&gt;PROGRESS&lt;/code&gt; field from &lt;code&gt;SHOW PROCESSLIST&lt;/code&gt; display different results. &lt;code&gt;SHOW PROCESSLIST&lt;/code&gt; shows the total progress, while the information schema shows the progress for the current stage only.</source>
          <target state="translated">참고 것을 &lt;code&gt;PROGRESS&lt;/code&gt; 정보 스키마 필드 및 &lt;code&gt;PROGRESS&lt;/code&gt; 에서 필드 &lt;code&gt;SHOW PROCESSLIST&lt;/code&gt; 는 다른 결과를 표시합니다. &lt;code&gt;SHOW PROCESSLIST&lt;/code&gt; 는 전체 진행률을 표시하고 정보 스키마는 현재 단계의 진행률 만 표시합니다.</target>
        </trans-unit>
        <trans-unit id="6ad04c19190227038f36cfcd068cc4409d06a3ec" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;PROGRESS&lt;/code&gt; field from the information schema, and the &lt;code&gt;PROGRESS&lt;/code&gt; field from &lt;code&gt;SHOW PROCESSLIST&lt;/code&gt; display different results. &lt;code&gt;SHOW PROCESSLIST&lt;/code&gt; shows the total progress, while the information schema shows the progress for the current stage only.. To retrieve a similar &quot;total&quot; Progress value from &lt;code&gt;information_schema.PROCESSLIST&lt;/code&gt; as the one from &lt;code&gt;SHOW PROCESSLIST&lt;/code&gt;, use</source>
          <target state="translated">참고 것을 &lt;code&gt;PROGRESS&lt;/code&gt; 정보 스키마 필드 및 &lt;code&gt;PROGRESS&lt;/code&gt; 에서 필드 &lt;code&gt;SHOW PROCESSLIST&lt;/code&gt; 는 다른 결과를 표시합니다. &lt;code&gt;SHOW PROCESSLIST&lt;/code&gt; 는 전체 진행률을 표시하고 정보 스키마는 현재 단계의 진행률 만 표시합니다. &lt;code&gt;SHOW PROCESSLIST&lt;/code&gt; 의 값과 &lt;code&gt;information_schema.PROCESSLIST&lt;/code&gt; 에서 유사한 &quot;전체&quot;진행 값을 검색하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ca70b838709d018850ae3cfdf9810942cd1fbb86" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;TLSv1.3&lt;/code&gt; ciphers cannot be excluded when using &lt;a href=&quot;https://www.openssl.org/&quot;&gt;OpenSSL&lt;/a&gt;, even by using the &lt;code&gt;&lt;a href=&quot;../ssl-system-variables/index#ssl_cipher&quot;&gt;ssl_cipher&lt;/a&gt;&lt;/code&gt; system variable. See &lt;a href=&quot;../using-tlsv13/index&quot;&gt;Using TLSv1.3&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../ssl-system-variables/index#ssl_cipher&quot;&gt;ssl_cipher&lt;/a&gt;&lt;/code&gt; 시스템 변수를 사용하더라도 &lt;a href=&quot;https://www.openssl.org/&quot;&gt;OpenSSL을&lt;/a&gt; 사용 하는 경우 &lt;code&gt;TLSv1.3&lt;/code&gt; 암호를 제외 할 수 없습니다 . 자세한 내용은 &lt;a href=&quot;../using-tlsv13/index&quot;&gt;TLSv1.3 사용&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e66663b0c628e45725d49962fe6cc05b25f0e815" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;default-character-set&lt;/code&gt; option is a client option, not a server option.</source>
          <target state="translated">참고 것을 &lt;code&gt;default-character-set&lt;/code&gt; 옵션은 클라이언트 옵션이 아닌 서버 옵션입니다.</target>
        </trans-unit>
        <trans-unit id="2901de48375474ae1db5888390e4b2f6cfe2fab0" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;replicate_...&lt;/code&gt; variables were added in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1002-release-notes/&quot;&gt;MariaDB 10.0.2&lt;/a&gt;</source>
          <target state="translated">있습니다 &lt;code&gt;replicate_...&lt;/code&gt; 변수에 추가되었습니다 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1002-release-notes/&quot;&gt;MariaDB 10.0.2&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2b5585dc1f43fa7be6697acee1f4fa555f4faf3f" translate="yes" xml:space="preserve">
          <source>Note that the MariaDB privileges occur at many levels. A user may be granted a privilege at the column level, but may still not have permission on a table level, for example. See &lt;a href=&quot;../grant/index&quot;&gt;privileges&lt;/a&gt; for a more complete view of the MariaDB privilege system.</source>
          <target state="translated">MariaDB 권한은 여러 수준에서 발생합니다. 사용자에게는 열 수준에서 권한이 부여 될 수 있지만 예를 들어 테이블 수준에 대한 권한이 없을 수도 있습니다. MariaDB 권한 시스템에 대한 자세한 내용은 &lt;a href=&quot;../grant/index&quot;&gt;권한&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8f12d483ac10e7625da6f587b2eca0cdc66cc836" translate="yes" xml:space="preserve">
          <source>Note that the MariaDB privileges occur at many levels. A user may be granted a privilege at the table level, but may still not have permission on a database level, for example. See &lt;a href=&quot;../grant/index&quot;&gt;privileges&lt;/a&gt; for a more complete view of the MariaDB privilege system.</source>
          <target state="translated">MariaDB 권한은 여러 수준에서 발생합니다. 사용자에게 테이블 수준에서 권한이 부여 될 수 있지만 예를 들어 데이터베이스 수준에 대한 권한이 없을 수도 있습니다. MariaDB 권한 시스템에 대한 자세한 내용은 &lt;a href=&quot;../grant/index&quot;&gt;권한&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f910ea7e771bacd561191d61576a541eba5a2ac5" translate="yes" xml:space="preserve">
          <source>Note that the MariaDB privileges occur at many levels. A user may not be granted &lt;code&gt;create&lt;/code&gt; privilege at the user level, but may still have &lt;code&gt;create&lt;/code&gt; permission on certain tables or databases, for example. See &lt;a href=&quot;../grant/index&quot;&gt;privileges&lt;/a&gt; for a more complete view of the MariaDB privilege system.</source>
          <target state="translated">MariaDB 권한은 여러 수준에서 발생합니다. 사용자에게 사용자 수준에서 &lt;code&gt;create&lt;/code&gt; 권한 이 부여되지는 않지만 , 예를 들어 특정 테이블이나 데이터베이스에 대한 &lt;code&gt;create&lt;/code&gt; 권한 이 여전히있을 수 있습니다 . MariaDB 권한 시스템에 대한 자세한 내용은 &lt;a href=&quot;../grant/index&quot;&gt;권한&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d056f9729dee90461f3152ea64c06c7e24d4cadf" translate="yes" xml:space="preserve">
          <source>Note that the MariaDB privileges occur at many levels. A user may not be granted a privilege at the database level, but may still have permission on a table level, for example. See &lt;a href=&quot;../grant/index&quot;&gt;privileges&lt;/a&gt; for a more complete view of the MariaDB privilege system.</source>
          <target state="translated">MariaDB 권한은 여러 수준에서 발생합니다. 사용자에게 데이터베이스 수준에서 권한이 부여되지는 않지만 테이블 수준에 대한 권한이 여전히있을 수 있습니다. MariaDB 권한 시스템에 대한 자세한 내용은 &lt;a href=&quot;../grant/index&quot;&gt;권한&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6e40ce32c1b3def661851d3e1fd318b4305ceb19" translate="yes" xml:space="preserve">
          <source>Note that the MySQL InnoDB and Percona XtraDB versions of the tables differ (see &lt;a href=&quot;../xtradb-and-innodb/index&quot;&gt;XtraDB and InnoDB&lt;/a&gt;).</source>
          <target state="translated">테이블의 MySQL InnoDB 및 Percona XtraDB 버전이 다릅니다 ( &lt;a href=&quot;../xtradb-and-innodb/index&quot;&gt;XtraDB 및 InnoDB&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="27c7c13b5b80df8e42f486be8ee7d6cd63a609b0" translate="yes" xml:space="preserve">
          <source>Note that the WAL was synced fewer times than there were binlog commit groups (?)</source>
          <target state="translated">WAL은 binlog 커밋 그룹 (?)보다 적은 횟수로 동기화되었습니다.</target>
        </trans-unit>
        <trans-unit id="6dcb37ccb111e34644c042b7596d7c8cc490cbef" translate="yes" xml:space="preserve">
          <source>Note that the above limitations do no apply to &lt;a href=&quot;../stored-procedures/index&quot;&gt;stored procedures&lt;/a&gt; or to &lt;a href=&quot;../events/index&quot;&gt;events&lt;/a&gt;.</source>
          <target state="translated">위의 제한없이 적용 않음을 참고 &lt;a href=&quot;../stored-procedures/index&quot;&gt;저장 프로 시저&lt;/a&gt; 하거나 &lt;a href=&quot;../events/index&quot;&gt;이벤트&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d20a9bef1e6712aa4312eae5e0136fa5b0116ba5" translate="yes" xml:space="preserve">
          <source>Note that the articles are listed inside the left parentheses using the alternation operator &lt;code&gt;|&lt;/code&gt; but they do not produce a captured subpattern, so the word followed by the article is referenced by &lt;code&gt;'&lt;br/&gt;1'&lt;/code&gt; in the third argument to the function. Using non-capturing groups can be useful to save numbers on the sup-patterns that won't be used in the third argument of &lt;a href=&quot;../regexp_replace/index&quot;&gt;REGEXP_REPLACE()&lt;/a&gt;, as well as for performance purposes.</source>
          <target state="translated">참고 기사가 교대 연산자를 사용하여 왼쪽 괄호 안에 나열되어 있는지 &lt;code&gt;|&lt;/code&gt; 그러나 캡처 된 하위 패턴을 생성하지 않으므로 기사 다음에 나오는 단어 는 함수의 세 번째 인수에서 &lt;code&gt;'&lt;br/&gt;1'&lt;/code&gt; 로 참조됩니다 . 비 캡처 그룹을 사용하면 성능 목적뿐만 아니라 &lt;a href=&quot;../regexp_replace/index&quot;&gt;REGEXP_REPLACE ()&lt;/a&gt; 의 세 번째 인수에 사용되지 않는 sup-patterns에 숫자를 저장하는 데 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="49398c5b5b271b8906001e3967b6cfe223357cea" translate="yes" xml:space="preserve">
          <source>Note that the backup will still be fully consistent with itself and the &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt;. This problem is normally not an issue in practice. A backup usually takes a long time to complete (relative to the 1 second or so that &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-system-variables/index#binlog_commit_wait_usec&quot;&gt;binlog_commit_wait_usec&lt;/a&gt;&lt;/code&gt; is normally set to), and a backup usually includes a lot of transactions that were committed during the backup. With this in mind, it is not generally noticeable if the backup does not include transactions that were committed during the last 1 second or so of the backup process. It is just mentioned here for completeness.</source>
          <target state="translated">백업은 여전히 ​​자체 및 &lt;a href=&quot;../binary-log/index&quot;&gt;이진 로그&lt;/a&gt; 와 완전히 일치합니다 . 이 문제는 일반적으로 실제로 문제가되지 않습니다. 일반적으로 백업을 완료하는 데 시간이 오래 걸리고 (1 초 정도 &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-system-variables/index#binlog_commit_wait_usec&quot;&gt;binlog_commit_wait_usec&lt;/a&gt;&lt;/code&gt; 가 일반적으로 설정 됨) 백업에는 일반적으로 백업 중에 커밋 된 많은 트랜잭션이 포함됩니다. 이를 염두에두고 백업에 백업 프로세스의 마지막 1 초 정도 동안 커밋 된 트랜잭션이 백업에 포함되어 있지 않은 경우 일반적으로 눈에 띄지 않습니다. 완전성을 위해 여기에 언급되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1bdde8d28e9435ad4f2b7d03c3ae38de5804cfd5" translate="yes" xml:space="preserve">
          <source>Note that the benefit of the &quot;hot spot&quot; is only partial:</source>
          <target state="translated">&quot;핫스팟&quot;의 이점은 부분적인 것입니다.</target>
        </trans-unit>
        <trans-unit id="6358b3dbec4708cfa87d9854b43e290f32622762" translate="yes" xml:space="preserve">
          <source>Note that the best way to handle ORDER BY is to set the max_length_for_sort_data variable to a larger value (its default value is 1024 that is pretty small). Indeed, it requires less memory to be used, particularly when a WHERE clause limits the retrieved data set. This is because in the case of an order by query, MariaDB firstly retrieves the sequentially the result set and the position of each records. Often the sort can be done from the result set if it is not too big. But if too big, or if it implies some &amp;ldquo;long&amp;rdquo; columns, only the positions are sorted and MariaDB retrieves the final result from the table read in random order. If setting the max_length_for_sort_data variable is not feasible or does not work, to be able to retrieve table data from memory after the first sequential read, the memory option must be set to 2.</source>
          <target state="translated">ORDER BY를 처리하는 가장 좋은 방법은 max_length_for_sort_data 변수를 더 큰 값으로 설정하는 것입니다 (기본값은 1024이며 매우 작음). 실제로, 특히 WHERE 절이 검색된 데이터 세트를 제한하는 경우 사용되는 메모리가 더 적게 필요합니다. 쿼리 별 주문의 경우 MariaDB는 먼저 결과 세트와 각 레코드의 위치를 ​​순차적으로 검색하기 때문입니다. 너무 크지 않은 경우 결과 집합에서 정렬을 수행 할 수있는 경우가 종종 있습니다. 그러나 너무 크거나 일부 &quot;긴&quot;열을 의미하는 경우 위치 만 정렬되고 MariaDB는 임의 순서로 읽은 테이블에서 최종 결과를 검색합니다. max_length_for_sort_data 변수 설정이 가능하지 않거나 작동하지 않는 경우, 첫 번째 순차 읽기 후 메모리에서 테이블 데이터를 검색 할 수 있으려면 메모리 옵션을 2로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="26a7cec2ae838415375c117caaec648f795c30a3" translate="yes" xml:space="preserve">
          <source>Note that the command above does not destroy the data volume that Docker has created for /var/lib/mysql. If you want to destroy the volume as well, use:</source>
          <target state="translated">위의 명령은 Docker가 / var / lib / mysql에 대해 생성 한 데이터 볼륨을 삭제하지 않습니다. 볼륨을 파괴하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2f591eadf892dc40922d426829ebaef943b3140f" translate="yes" xml:space="preserve">
          <source>Note that the contents of the &lt;code&gt;spcont&lt;/code&gt; is changing during the parsing, at all times reflecting the state of the would-be runtime frame. The &lt;code&gt;m_instr&lt;/code&gt; is an array of instructions:</source>
          <target state="translated">&lt;code&gt;spcont&lt;/code&gt; 의 내용은 구문 분석 중에 항상 런타임 프레임의 상태를 반영하여 변경됩니다. &lt;code&gt;m_instr&lt;/code&gt; 은 명령들의 배열이다 :</target>
        </trans-unit>
        <trans-unit id="52e1b41ab601b7f346cf7b933fc7e8c3276d2a44" translate="yes" xml:space="preserve">
          <source>Note that the default value of &lt;a href=&quot;../tokudb-system-variables/index#tokudb_pk_insert_mode&quot;&gt;tokudb_pk_insert_mode&lt;/a&gt; will prevent row-based replication from working. To use RBR, change the value of this variable.</source>
          <target state="translated">&lt;a href=&quot;../tokudb-system-variables/index#tokudb_pk_insert_mode&quot;&gt;tokudb_pk_insert_mode&lt;/a&gt; 의 기본값 은 행 기반 복제가 작동하지 못하게합니다. RBR을 사용하려면이 변수의 값을 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="3f5a63d4a84a5f984187ca3ddf0da76cfe8cb3ba" translate="yes" xml:space="preserve">
          <source>Note that the expression must be of the form of `column_name` = (constant). These do not apply to this step in the Algorithm: DATE(dt) = '...', LOWER(s) = '...', CAST(s ...) = '...', x='...' COLLATE...</source>
          <target state="translated">표현식은`column_name` = (constant) 형식이어야합니다. 알고리즘에서이 단계에는 적용되지 않습니다 : DATE (dt) = '...', LOWER (s) = '...', CAST (s ...) = '...', x = ' ... '콜라주 ...</target>
        </trans-unit>
        <trans-unit id="dccaf92e6ad93380208aac69d0969609a2c3f671" translate="yes" xml:space="preserve">
          <source>Note that the leftmost dollar sign and the parentheses are used literally, while the rightmost dollar sign is still used to match the end of the string.</source>
          <target state="translated">가장 왼쪽에있는 달러 기호와 괄호는 문자 그대로 사용되며 가장 오른쪽에있는 달러 기호는 여전히 문자열의 끝과 일치하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ec3b6ee6b1e99403d8aeda272c03ae45d82cbfe9" translate="yes" xml:space="preserve">
          <source>Note that the loop merely uses 'squares' of lat/lng ranges. This is crude, but works well with the partitioning and indexing, and avoids calling to GCDist (until the last step). In the sample code, I picked 15 miles as starting value. Adjusting this will have some impact on the Procedure's performance, but the impact will vary with the use cases. A rough way to set the radius is to guess what will find the desired LIMIT about half the time. (This value is hardcoded in the PROCEDURE.)</source>
          <target state="translated">루프는 단지 위도 / 경도 범위의 '제곱'을 사용합니다. 이것은 조잡하지만 분할 및 인덱싱과 잘 작동하며 GCDist 호출을 피합니다 (마지막 단계까지). 샘플 코드에서는 시작 값으로 15 마일을 선택했습니다. 이를 조정하면 프로 시저의 성능에 약간의 영향을 주지만 사용 사례에 따라 영향이 달라집니다. 반경을 설정하는 대략적인 방법은 절반 정도의 시간 동안 원하는 LIMIT를 찾을 수있는 것을 추측하는 것입니다. 이 값은 PROCEDURE에서 하드 코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="0f0174f8e12b0393997296224ccac1e97b0c9224" translate="yes" xml:space="preserve">
          <source>Note that the maximum sizes are not hard limits, and may vary according to circumstance.</source>
          <target state="translated">최대 크기는 하드 제한이 아니며 상황에 따라 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a1526a6b2cd3f38d7c37907ec9bc0b84e819ff5" translate="yes" xml:space="preserve">
          <source>Note that the meaning of the alternative form &lt;code&gt;NOT expr BETWEEN min AND max&lt;/code&gt; is affected by the &lt;code&gt;HIGH_NOT_PRECEDENCE&lt;/code&gt;&lt;a href=&quot;../sql-mode/index&quot;&gt;SQL_MODE&lt;/a&gt; flag.</source>
          <target state="translated">&lt;code&gt;NOT expr BETWEEN min AND max&lt;/code&gt; 의 대체 형식의 의미 는 &lt;code&gt;HIGH_NOT_PRECEDENCE&lt;/code&gt; &lt;a href=&quot;../sql-mode/index&quot;&gt;SQL_MODE&lt;/a&gt; 플래그의 영향을받습니다 .</target>
        </trans-unit>
        <trans-unit id="91ac56ae86e0e471bd8d0a5e402f97f31ac6fc09" translate="yes" xml:space="preserve">
          <source>Note that the option accepts no arguments; specifying &lt;code&gt;--core-file&lt;/code&gt; sets the value to &lt;code&gt;ON&lt;/code&gt;. It cannot be disabled in the case of Windows &amp;gt;= &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1043-release-notes/&quot;&gt;MariaDB 10.4.3&lt;/a&gt;.</source>
          <target state="translated">이 옵션은 인수를 허용하지 않습니다. &lt;code&gt;--core-file&lt;/code&gt; 을 지정 하면 값이 &lt;code&gt;ON&lt;/code&gt; 으로 설정 됩니다. Windows&amp;gt; = &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1043-release-notes/&quot;&gt;MariaDB 10.4.3&lt;/a&gt; 의 경우에는 비활성화 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="b358e0b57cb2a93bce9b6c019e40abd0dee3a690" translate="yes" xml:space="preserve">
          <source>Note that the problem requirement needs a [Next] link on each page so that the user can 'page' through the data. He does not really need &quot;GoTo Page #&quot;. Jump to the [First] or [Last] page may be useful.</source>
          <target state="translated">문제 요구 사항은 사용자가 데이터를 '페이지'할 수 있도록 각 페이지에 [다음] 링크가 필요합니다. 그는 실제로 &quot;GoTo Page #&quot;가 필요하지 않습니다. [First] 또는 [Last] 페이지로 이동하면 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e4e068deb26e226bb6c0236c8ea1bb2e8203b15" translate="yes" xml:space="preserve">
          <source>Note that the query cache cannot be enabled in certain environments. See &lt;a href=&quot;#limitations&quot;&gt;Limitations&lt;/a&gt;.</source>
          <target state="translated">특정 환경에서는 쿼리 캐시를 사용할 수 없습니다. &lt;a href=&quot;#limitations&quot;&gt;제한 사항을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="344d72d048466dc66acb405eed46885bbe46b8a2" translate="yes" xml:space="preserve">
          <source>Note that the row order is not defined for keys with duplicated values and will vary from engine to engine.</source>
          <target state="translated">행 순서는 값이 중복 된 키에 대해 정의되지 않으며 엔진마다 다릅니다.</target>
        </trans-unit>
        <trans-unit id="08d02b7448e26ae2dfb46f3cf877a0f31daaa0c1" translate="yes" xml:space="preserve">
          <source>Note that the rows are not cached in the page cache for &lt;code&gt;FIXED&lt;/code&gt; or &lt;code&gt;DYNAMIC&lt;/code&gt; format. If you want to have the data cached (something MyISAM doesn't support) you should use &lt;code&gt;ROW_FORMAT=PAGE&lt;/code&gt;:</source>
          <target state="translated">행은 &lt;code&gt;FIXED&lt;/code&gt; 또는 &lt;code&gt;DYNAMIC&lt;/code&gt; 형식 의 페이지 캐시에 캐시되지 않습니다 . 데이터를 캐시하려면 (MyISAM에서 지원하지 않는) &lt;code&gt;ROW_FORMAT=PAGE&lt;/code&gt; 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="66a30d932b905ed7cc3f28ba486efc648aeb4e76" translate="yes" xml:space="preserve">
          <source>Note that the short-cutting has to take place after &quot;Using where&quot; has been applied. It would have been wrong to short-cut after we found Trier.</source>
          <target state="translated">&quot;어디에 사용&quot;을 적용한 후에 바로 가기를 수행해야합니다. 트리어를 찾은 후 바로 가기가 잘못되었을 것입니다.</target>
        </trans-unit>
        <trans-unit id="b23bef296f3b987564c60b2fc7779087030ddf2e" translate="yes" xml:space="preserve">
          <source>Note that the size of the table can be made very big as there no physical data. However, the result should be limited in the queries. For instance:</source>
          <target state="translated">실제 데이터가 없으므로 테이블 크기를 매우 크게 만들 수 있습니다. 그러나 결과는 쿼리에서 제한되어야합니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="976b9ace4626080559be9435b69da3f44e205f30" translate="yes" xml:space="preserve">
          <source>Note that the table flags returned here are not the same as tablespace flags (FSP_SPACE_FLAGS).</source>
          <target state="translated">여기에 리턴 된 테이블 플래그는 테이블 스페이스 플래그 (FSP_SPACE_FLAGS)와 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3914242be30f4c1d4a2d7c9d8f2889ab4dc2d467" translate="yes" xml:space="preserve">
          <source>Note that the temporary credentials put into the environment of the MariaDB process will expire after a period of time defined by the request to the AWS Security Token Service (STS). In the example below, they will expire after 900 seconds. After that time, MariaDB may be unable to generate new encrypted data keys, which means that, for example, an attempt to create a table with a previously-unused key ID would fail.</source>
          <target state="translated">MariaDB 프로세스 환경에 배치 된 임시 자격 증명은 AWS Security Token Service (STS)에 대한 요청으로 정의 된 기간이 지나면 만료됩니다. 아래 예에서는 900 초 후에 만료됩니다. 그 후 MariaDB가 암호화 된 새 데이터 키를 생성하지 못할 수 있습니다. 예를 들어, 이전에 사용하지 않은 키 ID로 테이블을 작성하려는 시도가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="c39d7a0be404fc27c5c828a254a17cb539473dcb" translate="yes" xml:space="preserve">
          <source>Note that the types of the inserted values must match the column type, not the field format type.</source>
          <target state="translated">삽입 된 값의 유형은 필드 형식 유형이 아니라 열 유형과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="53f9e3de17b19ca16816bb59781c63bb0c1174ee" translate="yes" xml:space="preserve">
          <source>Note that the underlying crypt() system call may have some limitations, such as ignoring all but the first eight characters.</source>
          <target state="translated">기본 crypt () 시스템 호출에는 처음 8자를 제외한 모든 문자를 무시하는 것과 같은 일부 제한이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bfc608f1aeb5fab15d8f0ee843a92773b23cacd" translate="yes" xml:space="preserve">
          <source>Note that the value of USER() may differ from the value of &lt;a href=&quot;../current_user/index&quot;&gt;CURRENT_USER()&lt;/a&gt;, which is the user used to authenticate the current client. &lt;code&gt;&lt;a href=&quot;../current_role/index&quot;&gt;CURRENT_ROLE()&lt;/a&gt;&lt;/code&gt; returns the current active role.</source>
          <target state="translated">USER () 값은 현재 클라이언트를 인증하는 데 사용되는 &lt;a href=&quot;../current_user/index&quot;&gt;CURRENT_USER ()&lt;/a&gt; 값과 다를 수 있습니다 . &lt;code&gt;&lt;a href=&quot;../current_role/index&quot;&gt;CURRENT_ROLE()&lt;/a&gt;&lt;/code&gt; 은 현재 활성 역할을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="d96bd349b2382056b8515213c261df77509d210e" translate="yes" xml:space="preserve">
          <source>Note that the version returned by this system variable does not always necessarily correspond to the exact version of the &lt;a href=&quot;https://www.openssl.org/&quot;&gt;OpenSSL&lt;/a&gt; package installed on the system. &lt;a href=&quot;https://www.openssl.org/&quot;&gt;OpenSSL&lt;/a&gt; shared libraries tend to contain interfaces for multiple versions at once to allow for backward compatibility. Therefore, if the &lt;a href=&quot;https://www.openssl.org/&quot;&gt;OpenSSL&lt;/a&gt; package installed on the system is newer than the &lt;a href=&quot;https://www.openssl.org/&quot;&gt;OpenSSL&lt;/a&gt; version that the MariaDB Server binary was built with, then the MariaDB Server binary might use one of the interfaces for an older version. See &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-15848&quot;&gt;MDEV-15848&lt;/a&gt; for more information. For example:</source>
          <target state="translated">이 시스템 변수에 의해 리턴 된 버전이 반드시 시스템에 설치된 &lt;a href=&quot;https://www.openssl.org/&quot;&gt;OpenSSL&lt;/a&gt; 패키지 의 정확한 버전과 반드시 ​​일치하는 것은 아닙니다 . &lt;a href=&quot;https://www.openssl.org/&quot;&gt;OpenSSL&lt;/a&gt; 공유 라이브러리는 이전 버전과의 호환성을 위해 여러 버전에 대한 인터페이스를 한 번에 포함하는 경향이 있습니다. 따라서 시스템에 설치된 &lt;a href=&quot;https://www.openssl.org/&quot;&gt;OpenSSL&lt;/a&gt; 패키지 가 MariaDB 서버 바이너리가 작성된 &lt;a href=&quot;https://www.openssl.org/&quot;&gt;OpenSSL&lt;/a&gt; 버전 보다 최신 버전 인 경우 MariaDB 서버 바이너리는 이전 버전의 인터페이스 중 하나를 사용할 수 있습니다. 자세한 내용은 &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-15848&quot;&gt;MDEV-15848&lt;/a&gt; 을 참조하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8aa5b9edb931cf2cb7c54302e83ee78f38e2c836" translate="yes" xml:space="preserve">
          <source>Note that the word being matched must match the whole pattern:</source>
          <target state="translated">일치하는 단어는 전체 패턴과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="c7d838c41b979507346424a0f95d375732c034b1" translate="yes" xml:space="preserve">
          <source>Note that there are no special restrictions on what operations can be replicated in parallel using out-of-order; such operations can be on the same database/schema or even on the same table. The only restriction is that the operations must not conflict, that is they must be able to be applied in any order and still end up with the same result.</source>
          <target state="translated">비 순차적으로 병렬로 복제 할 수있는 작업에는 특별한 제한이 없습니다. 이러한 작업은 동일한 데이터베이스 / 스키마 또는 동일한 테이블에있을 수 있습니다. 유일한 제한 사항은 작업이 충돌하지 않아야한다는 것입니다. 즉, 순서에 관계없이 적용 할 수 있어야하며 결과는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="11510fcd22d0b3f010eae77aab7d504576939185" translate="yes" xml:space="preserve">
          <source>Note that there are two rows reported as affected, but this refers only to the UPDATE.</source>
          <target state="translated">영향을받는 것으로보고 된 행은 두 개이지만 UPDATE 만 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="134f60d390703a9ad76e9ec655fdc0f941d3e3fd" translate="yes" xml:space="preserve">
          <source>Note that there may be more tests in your output as we are constantly adding more tests to S3 when needed.</source>
          <target state="translated">필요한 경우 S3에 지속적으로 더 많은 테스트를 추가하므로 출력에 더 많은 테스트가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2160ec95387228156f8e9a1af27cba762c84c05" translate="yes" xml:space="preserve">
          <source>Note that these commands must be available to non-interactive shells. Once changes have been made, verify by running 'ssh user@host env' to ensure these values are displayed.</source>
          <target state="translated">이 명령은 비 대화식 쉘에서 사용 가능해야합니다. 변경 한 후에는 'ssh user @ host env'를 실행하여 이러한 값이 표시되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="2ae5f5ea4897b985b2c6c483b29eedf5e992ff03" translate="yes" xml:space="preserve">
          <source>Note that they must be spelled (case insensitive) exactly as above, no final &amp;ldquo;s&amp;rdquo;. For instance:</source>
          <target state="translated">위와 같이 철자가 정확하고 대소 문자를 구분하지 않아야하며 마지막 &quot;s&quot;는 없습니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="c6ab3f8cbdf44357ff25bb4169f713e5edf66acb" translate="yes" xml:space="preserve">
          <source>Note that this associated format is used only to describe the way the temporal value is stored internally. This format is used both for output to decode the date in a SELECT statement as well as for input to encode the date in INSERT or UPDATE statements. However, what is kept in this value depends on the data type used in the column definition (all the MariaDB temporal values can be specified). When creating a table, the format is associated to a date column using the DATE_FORMAT option in the column definition, for instance:</source>
          <target state="translated">이 관련 형식은 시간 값이 내부적으로 저장되는 방식을 설명하는 데만 사용됩니다. 이 형식은 SELECT 문에서 날짜를 디코딩하기위한 출력과 INSERT 또는 UPDATE 문에서 날짜를 인코딩하기위한 입력 모두에 사용됩니다. 그러나이 값으로 유지되는 것은 열 정의에 사용 된 데이터 유형에 따라 다릅니다 (모든 MariaDB 시간 값을 지정할 수 있음). 테이블을 만들 때 형식은 열 정의에서 DATE_FORMAT 옵션을 사용하여 날짜 열과 연결됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3eb481d8c3e076bb1f8ca21eac5331be3a90e96e" translate="yes" xml:space="preserve">
          <source>Note that this automatic detection doesn't work if you copy tables within the same MariaDB server!</source>
          <target state="translated">동일한 MariaDB 서버 내에서 테이블을 복사하면이 자동 감지 기능이 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8ae8677222c890b23c8353c5ce04c93100dc003c" translate="yes" xml:space="preserve">
          <source>Note that this does not even call GCDist. That comes in the last pass when the ORDER BY and LIMIT are used.</source>
          <target state="translated">이것은 GCDist를 호출하지도 않습니다. ORDER BY와 LIMIT가 사용될 때 마지막 패스에 온다.</target>
        </trans-unit>
        <trans-unit id="55447af80132727219d958d1ebfd8531d00cefaa" translate="yes" xml:space="preserve">
          <source>Note that this function did not work correctly before &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1028-release-notes/&quot;&gt;MariaDB 10.2.8&lt;/a&gt; - see &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-12180&quot;&gt;MDEV-12180&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1028-release-notes/&quot;&gt;MariaDB 10.2.8&lt;/a&gt; 이전에는이 ​​기능이 제대로 작동하지 않았습니다 . &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-12180&quot;&gt;MDEV-12180을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="75dddb03e977b973796b7fff5fc3284a965ae852" translate="yes" xml:space="preserve">
          <source>Note that this function did not work correctly before &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1028-release-notes/&quot;&gt;MariaDB 10.2.8&lt;/a&gt; - see &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-12181&quot;&gt;MDEV-12181&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1028-release-notes/&quot;&gt;MariaDB 10.2.8&lt;/a&gt; 이전에는이 ​​기능이 제대로 작동하지 않았습니다 . &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-12181&quot;&gt;MDEV-12181을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="aaa58c1286c48c57abe77a1697b1d7dce845316c" translate="yes" xml:space="preserve">
          <source>Note that this implementation only affects the processing done by PrimProc. Depending on the work distribution of a given query, a user may or may not observe overall performance proportional to their priority level.</source>
          <target state="translated">이 구현은 PrimProc에 의해 수행 된 처리에만 영향을 미칩니다. 주어진 쿼리의 작업 분포에 따라 사용자는 우선 순위 수준에 비례하여 전체 성능을 관찰하거나 관찰하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eba63d3d187888acb5c5b5a5b6281a2b9e62c20c" translate="yes" xml:space="preserve">
          <source>Note that this implies that the Lex structure with its sphead must be reentrant, that is, reusable and shareable between different threads and calls. The runtime state for a procedure is kept in the sp_rcontext in THD.</source>
          <target state="translated">이는 sphead가있는 Lex 구조가 다시 입력 가능해야합니다. 즉, 다른 스레드와 호출간에 재사용 가능하고 공유 가능해야합니다. 프로 시저의 런타임 상태는 THD의 sp_rcontext에 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="9eac6add09355e35b39d08bde6fdeed4f17f4eab" translate="yes" xml:space="preserve">
          <source>Note that this is still a &lt;em&gt;best-effort&lt;/em&gt; approach:</source>
          <target state="translated">이것은 여전히 &lt;em&gt;최선의 노력입니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="46133ca17992b176a9aba390c1f390f67902510e" translate="yes" xml:space="preserve">
          <source>Note that this may not be required on Windows because the path to the JVM library can sometimes be found in the registry.</source>
          <target state="translated">JVM 라이브러리에 대한 경로는 때때로 레지스트리에서 찾을 수 있으므로 Windows에서는 필요하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86edcb37e70417015d915dc42d831b35dad6f286" translate="yes" xml:space="preserve">
          <source>Note that this particular setting was rounded down to some multiple that MariaDB liked.</source>
          <target state="translated">이 특정 설정은 MariaDB가 좋아하는 배수로 반올림되었습니다.</target>
        </trans-unit>
        <trans-unit id="9ce045a95015d3de6c0477ffaae6498b7ef0be53" translate="yes" xml:space="preserve">
          <source>Note that this returns all possible destinations along the path, not just immediate links.</source>
          <target state="translated">이렇게하면 즉시 링크뿐만 아니라 경로를 따라 가능한 모든 대상이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="9f6280c186ab6fd25323b70c300803d2c384fd29" translate="yes" xml:space="preserve">
          <source>Note that this script also configures a repository for &lt;a href=&quot;../maxscale/index&quot;&gt;MariaDB MaxScale&lt;/a&gt; and a repository for MariaDB Tools, which currently only contains &lt;a href=&quot;../percona-xtrabackup/index&quot;&gt;Percona XtraBackup&lt;/a&gt; and its dependencies.</source>
          <target state="translated">이 스크립트는 또한 현재 &lt;a href=&quot;../percona-xtrabackup/index&quot;&gt;Percona XtraBackup&lt;/a&gt; 및 해당 종속성 만 포함하는 &lt;a href=&quot;../maxscale/index&quot;&gt;MariaDB MaxScale&lt;/a&gt; 용 저장소와 MariaDB 도구 용 저장소를 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="c5af633e90b96b405d525fd82197f85d9817dcdd" translate="yes" xml:space="preserve">
          <source>Note that this setting may cause issues with multi byte character set data. It is recommended to utilize UTF8 files directly with cpimport.</source>
          <target state="translated">이 설정으로 멀티 바이트 문자 집합 데이터에 문제가 발생할 수 있습니다. cpimport를 사용하여 UTF8 파일을 직접 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="5cb816b6b5ef325d6b561cc617f1bfb7f7a4de20" translate="yes" xml:space="preserve">
          <source>Note that this variable does not affect the algorithm that MariaDB uses to decrypt the key file. This variable only affects the encryption algorithm that MariaDB uses to encrypt and decrypt data. The only algorithm that MariaDB currently supports to encrypt the key file is &lt;a href=&quot;https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#CBC&quot;&gt;Cipher Block Chaining (CBC)&lt;/a&gt; mode of &lt;a href=&quot;https://en.wikipedia.org/wiki/Advanced_Encryption_Standard&quot;&gt;Advanced Encryption Standard (AES)&lt;/a&gt;.</source>
          <target state="translated">이 변수는 MariaDB가 키 파일의 암호를 해독하는 데 사용하는 알고리즘에는 영향을 미치지 않습니다. 이 변수는 MariaDB가 데이터를 암호화하고 해독하는 데 사용하는 암호화 알고리즘에만 영향을줍니다. MariaDB가 현재 키 파일을 암호화하기 위해 지원하는 유일한 알고리즘은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#CBC&quot;&gt;CBC (Cipher Block Chaining)입니다.&lt;/a&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Advanced_Encryption_Standard&quot;&gt; AES (Advanced Encryption Standard&lt;/a&gt; 모드입니다 .</target>
        </trans-unit>
        <trans-unit id="2ee4568d67573f09bee91806a20ad2cc39e0559e" translate="yes" xml:space="preserve">
          <source>Note that those keys are not useful alone. They are encrypted. When MariaDB starts up, the AWS KMS plugin decrypts those keys by interacting with AWS KMS.</source>
          <target state="translated">이러한 키는 단독으로는 유용하지 않습니다. 그것들은 암호화되어 있습니다. MariaDB가 시작되면 AWS KMS 플러그인은 AWS KMS와 상호 작용하여 해당 키를 해독합니다.</target>
        </trans-unit>
        <trans-unit id="ad39b35cf090dae40c91b627140540dc08a765c9" translate="yes" xml:space="preserve">
          <source>Note that to set the value of @@gtid_binlog_state, the binary log must be empty, that is it must not contain any GTID events and the previous value of @@gtid_binlog_state must be the empty string. If not, then RESET MASTER must be used first to erase the binary log first.</source>
          <target state="translated">@@ gtid_binlog_state의 값을 설정하려면 이진 로그가 비어 있어야합니다. 즉, GTID 이벤트를 포함하지 않아야하며 @@ gtid_binlog_state의 이전 값은 빈 문자열이어야합니다. 그렇지 않은 경우 먼저 RESET MASTER를 사용하여 이진 로그를 먼저 지워야합니다.</target>
        </trans-unit>
        <trans-unit id="b5c575644152cf20fb419d5f3d88553ce66cfd06" translate="yes" xml:space="preserve">
          <source>Note that unless the table has a &lt;code&gt;PRIMARY KEY&lt;/code&gt; or &lt;code&gt;UNIQUE&lt;/code&gt; index, using a &lt;code&gt;REPLACE&lt;/code&gt; statement makes no sense. It becomes equivalent to &lt;code&gt;INSERT&lt;/code&gt;, because there is no index to be used to determine whether a new row duplicates another.</source>
          <target state="translated">테이블에 &lt;code&gt;PRIMARY KEY&lt;/code&gt; 또는 &lt;code&gt;UNIQUE&lt;/code&gt; 인덱스 가 없으면 &lt;code&gt;REPLACE&lt;/code&gt; 문을 사용하는 것은 의미가 없습니다. &lt;code&gt;INSERT&lt;/code&gt; 와 동등해진다새 행이 다른 행을 복제하는지 여부를 판별하는 데 사용할 인덱스가 없으므로 .</target>
        </trans-unit>
        <trans-unit id="f3e2d39e3151ddf8d96026c05ea03b14bfd40ed3" translate="yes" xml:space="preserve">
          <source>Note that unlike autotools, cmake tries to configure and build incrementally. You can modify one configuration option and cmake will only rebuild the part of the tree affected by it. For example, when you do &lt;code&gt;cmake -DWITH_EMBEDDED_SERVER=1&lt;/code&gt; in the already-built tree, it will make libmysqld to be built, but no other configuration options will be changed or reset to their default values.</source>
          <target state="translated">자동 도구와 달리 cmake는 점진적으로 구성 및 빌드를 시도합니다. 하나의 구성 옵션을 수정할 수 있으며 cmake는 영향을받는 트리의 일부만 다시 작성합니다. 예를 들어, &lt;code&gt;cmake -DWITH_EMBEDDED_SERVER=1&lt;/code&gt; 을 수행 할 때 이미 구축 된 트리에서 하면 libmysqld가 구축되지만 다른 구성 옵션은 변경되거나 기본값으로 재설정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="55d60d9a81f0f8f42976280cb8185370563aba34" translate="yes" xml:space="preserve">
          <source>Note that updating the &quot;multiple&quot; column is not possible because CONNECT does not know which of the nodes to update.</source>
          <target state="translated">CONNECT가 갱신 할 노드를 모르기 때문에 &quot;복수&quot;열을 갱신 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d11e73ba3cfac2402b243973da4bc8224c968a15" translate="yes" xml:space="preserve">
          <source>Note that we have been lucky. Because unlike SQL, XML is case sensitive and the column names have matched the node names only because the column names were given in upper case. Note also that the order of the columns in the table could have been different from the order in which the nodes appear in the XML file.</source>
          <target state="translated">우리는 운이 좋았습니다. SQL과 달리 XML은 대소 문자를 구분하며 열 이름이 대문자로 제공 되었기 때문에 열 이름이 노드 이름과 일치했습니다. 또한 테이블의 열 순서는 노드가 XML 파일에 나타나는 순서와 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e4a6d749463161445f73dfdcebb8a3f9faeccf2" translate="yes" xml:space="preserve">
          <source>Note that when a transaction starts (not in autocommit mode), all locks acquired with &lt;a href=&quot;../lock-tables-and-unlock-tables/index&quot;&gt;LOCK TABLES&lt;/a&gt; are released. And acquiring such locks always commits the current transaction. To preserve the data integrity between transactional and non-transactional tables, the &lt;a href=&quot;../get_lock/index&quot;&gt;GET_LOCK()&lt;/a&gt; function can be used.</source>
          <target state="translated">트랜잭션이 시작되면 (자동 커밋 모드가 아님) &lt;a href=&quot;../lock-tables-and-unlock-tables/index&quot;&gt;LOCK TABLES&lt;/a&gt; 로 획득 한 모든 잠금 이 해제됩니다. 이러한 잠금을 획득하면 항상 현재 트랜잭션이 커밋됩니다. 트랜잭션 테이블과 비 트랜잭션 테이블 간의 데이터 무결성을 유지하기 위해 &lt;a href=&quot;../get_lock/index&quot;&gt;GET_LOCK ()&lt;/a&gt; 함수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02cfe39acd5b26b90bfb928e25de44b5217bbbea" translate="yes" xml:space="preserve">
          <source>Note that when backing up off a slave server, it is important to ensure that the servers keep the data in sync. See for example &lt;a href=&quot;../replication-and-foreign-keys/index&quot;&gt;Replication and Foreign Keys&lt;/a&gt; for a situation when identical statements can result in different data on a slave and a master.</source>
          <target state="translated">슬레이브 서버를 백업 할 때는 서버가 데이터를 동기화 된 상태로 유지해야합니다. 예를 들어 &lt;a href=&quot;../replication-and-foreign-keys/index&quot;&gt;복제 및 외래 키 참조&lt;/a&gt;동일한 명령문으로 인해 슬레이브 및 마스터에서 다른 데이터가 발생할 수있는 상황에 를 .</target>
        </trans-unit>
        <trans-unit id="fc7f6a088471f90e7fed82bf39b3a86e14dfb755" translate="yes" xml:space="preserve">
          <source>Note that when events are filtered for a slave, the data in the database will be different on the slave and on the master. It is the responsibility of the application to replicate the data outside of the built-in replication or otherwise ensure consistency of operation. If this is not done, it is possible for replication to encounter, for example, &lt;code&gt;&lt;a href=&quot;../constraint_type-unique-constraint/index&quot;&gt;UNIQUE&lt;/a&gt;&lt;/code&gt; contraint violations or other problems which will cause replication to stop and require manual intervention to fix.</source>
          <target state="translated">슬레이브에 대해 이벤트를 필터링하면 데이터베이스의 데이터가 슬레이브와 마스터에서 달라집니다. 기본 제공 복제 외부에서 데이터를 복제하거나 운영 일관성을 유지하는 것은 응용 프로그램의 책임입니다. 이 작업을 수행하지 않으면 &lt;code&gt;&lt;a href=&quot;../constraint_type-unique-constraint/index&quot;&gt;UNIQUE&lt;/a&gt;&lt;/code&gt; 위반 또는 기타 문제로 인해 복제가 중지 될 수 있으며 복제를 중지하고 수정하려면 수동 개입이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="808d57876f0f17474a3e5c5de1355e26523920d9" translate="yes" xml:space="preserve">
          <source>Note that when one casts to &lt;code&gt;&lt;a href=&quot;../char/index&quot;&gt;CHAR&lt;/a&gt;&lt;/code&gt; without specifying the character set, the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#collation_connection&quot;&gt;collation_connection&lt;/a&gt;&lt;/code&gt; character set collation will be used. When used with &lt;code&gt;CHAR CHARACTER SET&lt;/code&gt;, the default collation for that character set will be used.</source>
          <target state="translated">문자 세트를 지정하지 않고 &lt;code&gt;&lt;a href=&quot;../char/index&quot;&gt;CHAR&lt;/a&gt;&lt;/code&gt; 로 캐스트 할 때 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#collation_connection&quot;&gt;collation_connection&lt;/a&gt;&lt;/code&gt; 문자 세트 조합이 사용됩니다. &lt;code&gt;CHAR CHARACTER SET&lt;/code&gt; 과 함께 사용하는 경우 해당 문자 세트의 기본 데이터 정렬이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="142c6fd01b3f7e3669f981a3dac71c742ef78a24" translate="yes" xml:space="preserve">
          <source>Note that when the backup is completed, one should delete all files with the &quot;#sql&quot; prefix, as these are files used by concurrent running &lt;code&gt;ALTER TABLE&lt;/code&gt;. Note that InnoDB will on server restart automatically delete any tables with the &quot;#sql&quot; prefix.</source>
          <target state="translated">백업이 완료되면 &quot;#sql&quot;접두사가 붙은 모든 파일을 삭제해야합니다. 파일은 &lt;code&gt;ALTER TABLE&lt;/code&gt; 과 동시에 실행되는 파일이기 때문 입니다. InnoDB는 서버를 다시 시작할 때 &quot;#sql&quot;접두사가있는 테이블을 자동으로 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="cdfa9a746a704f0a9e36a3bc197e0da568ec0efa" translate="yes" xml:space="preserve">
          <source>Note that when the binlog is empty (such as on a fresh install or after &lt;a href=&quot;../reset-master/index&quot;&gt;RESET MASTER&lt;/a&gt;), there are no event groups written in any replication domain, so in this case the value of &lt;code&gt;gtid_binlog_pos&lt;/code&gt; will be the empty string.</source>
          <target state="translated">binlog가 비어 있으면 (예 : 새로 설치하거나 &lt;a href=&quot;../reset-master/index&quot;&gt;RESET MASTER&lt;/a&gt; 후 ) 복제 도메인에 기록 된 이벤트 그룹이 &lt;code&gt;gtid_binlog_pos&lt;/code&gt; 경우 gtid_binlog_pos 값 빈 문자열이됩니다.</target>
        </trans-unit>
        <trans-unit id="8b12db7f454b235367a78376a72dfc2241b7a16d" translate="yes" xml:space="preserve">
          <source>Note that when upgrading the Galera wsrep provider, sometimes the Galera protocol version can change. The Galera wsrep provider should not start using the new protocol version until all cluster nodes have been upgraded to the new version, so this is not generally an issue during a rolling upgrade. However, this can cause issues if you restart a non-upgraded node in a cluster where the rest of the nodes have been upgraded.</source>
          <target state="translated">Galera wsrep 제공자를 업그레이드 할 때 Galera 프로토콜 버전이 변경 될 수 있습니다. Galera wsrep 제공자는 모든 클러스터 노드가 새 버전으로 업그레이드 될 때까지 새 프로토콜 버전을 사용하지 않아야하므로 롤링 업그레이드 중에는 일반적으로 문제가되지 않습니다. 그러나 나머지 노드가 업그레이드 된 클러스터에서 업그레이드되지 않은 노드를 다시 시작하면 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b91790f305ce40b10913ac92584f1c1ae89d1b2" translate="yes" xml:space="preserve">
          <source>Note that when using &lt;a href=&quot;../using-the-s3-storage-engine/index&quot;&gt;ALTER TABLE table_name ENGINE=S3&lt;/a&gt; this restriction doesn't apply.</source>
          <target state="translated">&lt;a href=&quot;../using-the-s3-storage-engine/index&quot;&gt;ALTER TABLE table_name ENGINE = S3&lt;/a&gt; 을 사용할 때는 이 제한이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="59c86ff29aaf67bb92900e1da479699a9ac1dfa2" translate="yes" xml:space="preserve">
          <source>Note that you &lt;strong&gt;must&lt;/strong&gt; include &lt;code&gt;aws-key-management-region&lt;/code&gt; in your .cnf file if you are not using the us-east-1 region.</source>
          <target state="translated">참고는 &lt;strong&gt;해야한다&lt;/strong&gt; 포함 &lt;code&gt;aws-key-management-region&lt;/code&gt; 은 미국 동부-1 영역을 사용하지 않는 경우 .CNF 파일을.</target>
        </trans-unit>
        <trans-unit id="b4b886e44085708eb1238f8f95af6e0cb03fee78" translate="yes" xml:space="preserve">
          <source>Note that you can't change this without dumping, deleting old tables and deleting all log files and then restoring your Aria tables. (This is the only option that requires a dump and load)</source>
          <target state="translated">덤프, 기존 테이블 삭제 및 모든 로그 파일 삭제 후 Aria 테이블 복원 없이는이를 변경할 수 없습니다. (이것은 덤프 및로드가 필요한 유일한 옵션입니다)</target>
        </trans-unit>
        <trans-unit id="2572c7fdc6711a8c868ee617279917a45795c80b" translate="yes" xml:space="preserve">
          <source>Note that you don't have to uninstall or otherwise remove MySQL!</source>
          <target state="translated">MySQL을 제거하거나 제거 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="1fa6f467d8267b23cfdc98e4395478e4e179047c" translate="yes" xml:space="preserve">
          <source>Note that you should not disconnect this session as otherwise the read lock will disappear and you have to start from the beginning.</source>
          <target state="translated">그렇지 않으면 읽기 잠금이 사라지고 처음부터 시작해야하므로이 세션의 연결을 끊지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="d121a3320bf36ff834f71fce8e6ec4b60fbc0388" translate="yes" xml:space="preserve">
          <source>Note that zipped_file_path can contain wildcards &quot; * &quot; when used with MULTIPLE={1|3}, a file path example would be as follows: C:/SubFolder/Folder/Filename*.zip</source>
          <target state="translated">zipped_file_path는 MULTIPLE = {1 | 3}과 함께 사용될 때 와일드 카드 &quot;*&quot;를 포함 할 수 있습니다. 파일 경로 예제는 다음과 같습니다. C : /SubFolder/Folder/Filename*.zip</target>
        </trans-unit>
        <trans-unit id="9315aa159e676caa856eb686175fba46c696813e" translate="yes" xml:space="preserve">
          <source>Note that, because the statement must be terminated by &lt;code&gt;%m&lt;/code&gt; with no additional characters, skipping the ending quote of field 2 was moved from the end of the second column format to the beginning of the third column format.</source>
          <target state="translated">명령문은 추가 문자없이 &lt;code&gt;%m&lt;/code&gt; 으로 끝나야하므로 필드 2의 끝 인용 부호 건너 뛰기가 두 번째 열 형식의 끝에서 세 번째 열 형식의 시작으로 이동했습니다.</target>
        </trans-unit>
        <trans-unit id="043ebd76f8a470fee4e3efb176ba67ee43cc6ded" translate="yes" xml:space="preserve">
          <source>Note that, if a stored program calls another stored program, the latter will inherit the caller's limitations. So, for example, if a stored procedure is called by a stored function, that stored procedure will not be able to produce a result set, because stored functions can't do this.</source>
          <target state="translated">저장된 프로그램이 다른 저장된 프로그램을 호출하는 경우 저장된 프로그램은 호출자의 제한을 상속합니다. 예를 들어 저장 프로 시저가 저장 함수에 의해 호출되면 저장 함수는이를 수행 할 수 없으므로 저장 프로 시저가 결과 집합을 생성 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f4118bbac0818eec359a31a7ab66068157cf49b3" translate="yes" xml:space="preserve">
          <source>Note that, if the &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_file_per_table&quot;&gt;innodb_file_per_table&lt;/a&gt; server system variable is set to 0 at the time of the table creation, all partitions will be stored in the system tablespace.</source>
          <target state="translated">경우 생성 것을 유의 &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_file_per_table&quot;&gt;innodb_file_per_table&lt;/a&gt; 서버 시스템 변수 테이블 작성시에 0으로 설정되고, 모든 파티션은 시스템 테이블에 저장된다.</target>
        </trans-unit>
        <trans-unit id="f1f0fc551783d9d909bc280f0d69655a7bd76702" translate="yes" xml:space="preserve">
          <source>Note that, if the &lt;code&gt;PIPES_AS_CONCAT&lt;/code&gt;&lt;a href=&quot;../sql-mode/index&quot;&gt;SQL_MODE&lt;/a&gt; is set, &lt;code&gt;||&lt;/code&gt; is used as a string concatenation operator. This means that &lt;code&gt;a || b&lt;/code&gt; is the same as &lt;code&gt;CONCAT(a,b)&lt;/code&gt;. See &lt;code&gt;&lt;a href=&quot;../concat/index&quot;&gt;CONCAT()&lt;/a&gt;&lt;/code&gt; for details.</source>
          <target state="translated">경우, 그 주 &lt;code&gt;PIPES_AS_CONCAT&lt;/code&gt; 의&lt;a href=&quot;../sql-mode/index&quot;&gt;SQL_MODE이&lt;/a&gt; 설정되어 &lt;code&gt;||&lt;/code&gt; 문자열 연결 연산자로 사용됩니다. 이것은 &lt;code&gt;a || b&lt;/code&gt; 는 &lt;code&gt;CONCAT(a,b)&lt;/code&gt; 와 동일 합니다. &lt;code&gt;&lt;a href=&quot;../concat/index&quot;&gt;CONCAT()&lt;/a&gt;&lt;/code&gt; 참조 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8cb683aa90c8afbde27bcdb6b47f0cfb3a3ac093" translate="yes" xml:space="preserve">
          <source>Note that, if the event is a &lt;a href=&quot;../transactions/index&quot;&gt;transaction&lt;/a&gt;, the whole transaction will be skipped. With non-transactional engines, an event is always a single statement.</source>
          <target state="translated">이벤트가 &lt;a href=&quot;../transactions/index&quot;&gt;transaction&lt;/a&gt; 인 경우 전체 트랜잭션을 건너 뜁니다. 비 트랜잭션 엔진의 경우 이벤트는 항상 단일 명령문입니다.</target>
        </trans-unit>
        <trans-unit id="69b9eec5c5f4d1429aa1ee8dcd1e67e3189ff9df" translate="yes" xml:space="preserve">
          <source>Note that, if you specify an account that is currently connected, it will not be deleted until the connection is closed. The connection will not be automatically closed.</source>
          <target state="translated">현재 연결된 계정을 지정하면 연결이 종료 될 때까지 계정이 삭제되지 않습니다. 연결이 자동으로 닫히지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d40c04945d4e3eb8a63610e6bba32992a46e5f90" translate="yes" xml:space="preserve">
          <source>Note that, if your queries contain user's passwords, the slow query log may contain passwords too. Thus, it should be protected.</source>
          <target state="translated">쿼리에 사용자 암호가 포함 된 경우 느린 쿼리 로그에도 암호가 포함될 수 있습니다. 따라서 보호되어야합니다.</target>
        </trans-unit>
        <trans-unit id="f89f577056d3c4c03da6c0aa8ea418200544f266" translate="yes" xml:space="preserve">
          <source>Note that, while &lt;code&gt;system_time&lt;/code&gt; here is also a time period, it cannot be used in &lt;code&gt;DELETE FOR PORTION&lt;/code&gt; or &lt;code&gt;UPDATE FOR PORTION&lt;/code&gt; statements.</source>
          <target state="translated">반면,주의 &lt;code&gt;system_time&lt;/code&gt; 여기에 또한 시간입니다, 그것은 사용할 수 없습니다 &lt;code&gt;DELETE FOR PORTION&lt;/code&gt; 또는 &lt;code&gt;UPDATE FOR PORTION&lt;/code&gt; 문.</target>
        </trans-unit>
        <trans-unit id="ab72e5dbabe1bc0af58ea83b0a19e3728cf3a8cb" translate="yes" xml:space="preserve">
          <source>Note that, while your package repositories could have a package called &lt;code&gt;docker&lt;/code&gt;, it is probably not the Docker we are talking about. The Docker package could be called &lt;code&gt;docker.io&lt;/code&gt; or &lt;code&gt;docker-engine&lt;/code&gt;.</source>
          <target state="translated">패키지 리포지토리에는 &lt;code&gt;docker&lt;/code&gt; 라는 패키지 가있을 수 있지만 아마도 우리가 이야기하는 Docker가 아닐 수도 있습니다. Docker 패키지는 &lt;code&gt;docker.io&lt;/code&gt; 또는 &lt;code&gt;docker-engine&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f6db9f97907c3c20a8c54432eebf664fb2bbec88" translate="yes" xml:space="preserve">
          <source>Note the &quot;Priority_queue: Yes&quot; on the last comment line. (&lt;code&gt;pt-query-digest&lt;/code&gt; is able to parse slow query logs with the Priority_queue field)</source>
          <target state="translated">마지막 주석 행의 &quot;Priority_queue : Yes&quot;에 유의하십시오. ( &lt;code&gt;pt-query-digest&lt;/code&gt; Priority_queue 필드와 슬로우 쿼리 로그를 분석 할 수 있습니다)</target>
        </trans-unit>
        <trans-unit id="211d7cbaddbc7d574c34289132b6a7cc25e93593" translate="yes" xml:space="preserve">
          <source>Note the --no-data option since only the ddl is required for column store tables. The next step will backup the data files. If tables exist using other storage engines then this is likely not appropriate for these.</source>
          <target state="translated">열 저장소 테이블에는 ddl 만 필요하므로 --no-data 옵션에 유의하십시오. 다음 단계는 데이터 파일을 백업합니다. 다른 스토리지 엔진을 사용하는 테이블이 존재하는 경우에는 해당 테이블에 적합하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e06d42f1a9eabbdda60fc09742ee3a8e72714aee" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;rowid_filter&lt;/code&gt; element. It has a &lt;code&gt;range&lt;/code&gt; element inside it. &lt;code&gt;selectivity_pct&lt;/code&gt; is the expected selectivity, accompanied by the &lt;code&gt;r_selectivity_pct&lt;/code&gt; showing the actual observed selectivity.</source>
          <target state="translated">&lt;code&gt;rowid_filter&lt;/code&gt; 요소를 참고하십시오 . 이것은 보유 &lt;code&gt;range&lt;/code&gt; 그 안에 소자. &lt;code&gt;selectivity_pct&lt;/code&gt; 는 예상 된 선택도이며 &lt;code&gt;r_selectivity_pct&lt;/code&gt; 는 실제 관찰 된 선택도를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2ad44e1453c85b45eb1b899286c410371ec3a168" translate="yes" xml:space="preserve">
          <source>Note the alias for the functional column. An alias would be required for the c1 column if its name was different on some machines. The t1 and t2 table names can also be eventually different on the remote machines. The true names must be used in the &lt;code&gt;SRCDEF&lt;/code&gt; parameter. This will create a set of tables with two columns named c1 and sc2&lt;sup id=&quot;_ref-0&quot;&gt;[&lt;a href=&quot;#_note-0&quot;&gt;1&lt;/a&gt;]&lt;/sup&gt;.</source>
          <target state="translated">기능 열의 별명에 유의하십시오. 일부 머신에서 이름이 다른 경우 c1 컬럼에 별명이 필요합니다. t1 및 t2 테이블 이름도 원격 시스템에서 다를 수 있습니다. 실제 이름은 &lt;code&gt;SRCDEF&lt;/code&gt; 매개 변수 에 사용해야합니다 . 그러면 c1 및 sc2 &lt;sup id=&quot;_ref-0&quot;&gt;[ &lt;/sup&gt;&lt;sup id=&quot;_ref-0&quot;&gt;&lt;a href=&quot;#_note-0&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;_ref-0&quot;&gt; ]&lt;/sup&gt; 라는 두 개의 열이있는 테이블 세트가 작성됩니다 &lt;sup id=&quot;_ref-0&quot;&gt;.&lt;/sup&gt;&lt;sup id=&quot;_ref-0&quot;&gt;&lt;/sup&gt; 집니다.</target>
        </trans-unit>
        <trans-unit id="6f4d5522730b5e3f19e423491f09daa6d06c05c2" translate="yes" xml:space="preserve">
          <source>Note the empty string.</source>
          <target state="translated">빈 문자열을 참고하십시오.</target>
        </trans-unit>
        <trans-unit id="6bd2451ac37f43169334334ff727fcbbda1d943e" translate="yes" xml:space="preserve">
          <source>Note the quoted closed parenthesis.</source>
          <target state="translated">따옴표로 묶은 괄호를 주목하십시오.</target>
        </trans-unit>
        <trans-unit id="b65e19c98e5f844ff4dfb7724dfd9f1ed446d24a" translate="yes" xml:space="preserve">
          <source>Note the several lines of output that refer explicitly to the &quot;AWS KMS plugin&quot;. You can see that the plugin generates a &quot;datakey&quot;, loads that data key, and then later generates and loads a second data key. The 2nd data key is used to encrypt temporary files and temporary tables.</source>
          <target state="translated">&quot;AWS KMS 플러그인&quot;을 명시 적으로 참조하는 여러 줄의 출력에 유의하십시오. 플러그인이 &quot;datakey&quot;를 생성하고 해당 데이터 키를로드 한 다음 나중에 두 번째 데이터 키를 생성 및로드하는 것을 볼 수 있습니다. 두 번째 데이터 키는 임시 파일 및 임시 테이블을 암호화하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fb5fc6842133de8d2115673b30fad3bff083a6f8" translate="yes" xml:space="preserve">
          <source>Note the use of [n] (until Connect 1.5) or n (from Connect 1.6) array specifications for the longitude and latitude columns.</source>
          <target state="translated">경도 및 위도 열에 [n] (Connect 1.5까지) 또는 n (Connect 1.6부터) 배열 사양을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="70a37ac5aaf987fb86624d418a00ad10ac4eb04f" translate="yes" xml:space="preserve">
          <source>Note these packages conflict with ColumnStore installations. Don't install them on any of your ColumnStore servers.</source>
          <target state="translated">이 패키지는 ColumnStore 설치와 충돌합니다. ColumnStore 서버에 설치하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="a918afb61a57ef6ad711aa2f7cc4b322bbe28ab1" translate="yes" xml:space="preserve">
          <source>Note*: The TIMESTAMP format that was used prior to MySQL 4.1 is not supported in MySQL 5.5; see MySQL 3.23, 4.0, 4.1 Reference Manual for information regarding the old format.</source>
          <target state="translated">참고 * : MySQL 4.1 이전에 사용 된 TIMESTAMP 형식은 MySQL 5.5에서 지원되지 않습니다. 이전 형식에 대한 정보는 MySQL 3.23, 4.0, 4.1 참조 매뉴얼을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6ace0ca8a9d57f75e5cb2a5bfe0fbd406efb21b6" translate="yes" xml:space="preserve">
          <source>Note, &lt;code&gt;DROP PACKAGE BODY&lt;/code&gt; drops only the package implementation, but does not drop the package specification. Use &lt;a href=&quot;../drop-package/index&quot;&gt;DROP PACKAGE&lt;/a&gt; to drop the package entirely (i.e. both implementation and specification).</source>
          <target state="translated">참고 &lt;code&gt;DROP PACKAGE BODY&lt;/code&gt; 는 패키지 만 구현을 삭제하지만 패키지 사양을 삭제하지 않습니다. &lt;a href=&quot;../drop-package/index&quot;&gt;DROP PACKAGE&lt;/a&gt; 를 사용 하여 패키지를 완전히 삭제하십시오 (즉, 구현 및 사양 모두).</target>
        </trans-unit>
        <trans-unit id="3327dcbfbdd60b43b9719468015c6755d9731cb9" translate="yes" xml:space="preserve">
          <source>Note, EXECUTE IMMEDIATE does not increment the &lt;a href=&quot;../server-status-variables/index#com_execute_sql&quot;&gt;Com_execute_sql&lt;/a&gt; status variable. &lt;em&gt;Com_execute_sql&lt;/em&gt; is used only for &lt;a href=&quot;../prepare-statement/index&quot;&gt;PREPARE&lt;/a&gt;..&lt;a href=&quot;../execute-statement/index&quot;&gt;EXECUTE&lt;/a&gt;.</source>
          <target state="translated">EXECUTE IMMEDIATE는 &lt;a href=&quot;../server-status-variables/index#com_execute_sql&quot;&gt;Com_execute_sql&lt;/a&gt; 상태 변수를 증가시키지 않습니다 . &lt;em&gt;Com_execute_sql&lt;/em&gt; 은 &lt;a href=&quot;../prepare-statement/index&quot;&gt;PREPARE&lt;/a&gt; .. &lt;a href=&quot;../execute-statement/index&quot;&gt;EXECUTE&lt;/a&gt; 에만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="fbe81b8173dae79f51a633f0d8afc731e1f1fa0f" translate="yes" xml:space="preserve">
          <source>Note, currently an attempt to use &lt;code&gt;FETCH&lt;/code&gt; for a &lt;code&gt;ROW&lt;/code&gt; type variable returns this error:</source>
          <target state="translated">참고 사용하는 현재 시도 &lt;code&gt;FETCH&lt;/code&gt; A에 대한 &lt;code&gt;ROW&lt;/code&gt; 의 유형 변수는이 오류를 반환 :</target>
        </trans-unit>
        <trans-unit id="ab1f7ed816a26e77daa2061c149a8192496818a6" translate="yes" xml:space="preserve">
          <source>Note, for diagnostics it is best to capture all statistics. The reason is because you never now where a problem might turn up, so without certain statistics you may not be able to identify the problem.</source>
          <target state="translated">진단의 경우 모든 통계를 캡처하는 것이 가장 좋습니다. 그 이유는 지금 문제가 발생할 수있는 위치가 없기 때문에 특정 통계가 없으면 문제를 식별하지 못할 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="36583783cf034fd816f06d125c44b6063824c65a" translate="yes" xml:space="preserve">
          <source>Note, however, that this technique should never be used on a large table as it will be extremely slow. MariaDB will read all rows in the table, generate a random value for each of them, order them, and finally will apply the LIMIT clause.</source>
          <target state="translated">그러나이 기술은 매우 느릴 수 있으므로 큰 테이블에서 사용해서는 안됩니다. MariaDB는 테이블의 모든 행을 읽고 각 행에 대해 임의의 값을 생성하여 순서를 지정한 다음 LIMIT 절을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="4e8990dafd3dbb9f37c3fda99fb04e8a4eea96f1" translate="yes" xml:space="preserve">
          <source>Note, if we rewrite the query like this:</source>
          <target state="translated">다음과 같이 쿼리를 다시 작성하면</target>
        </trans-unit>
        <trans-unit id="2180660d1e6c032b1feac0bbea2b50fafa37f881" translate="yes" xml:space="preserve">
          <source>Note, if we rewrite the script like this:</source>
          <target state="translated">다음과 같이 스크립트를 다시 작성하면</target>
        </trans-unit>
        <trans-unit id="0581e4528b6683504ccebbdbf64c64a91483cb07" translate="yes" xml:space="preserve">
          <source>Note, in the above example, while the XPath expression matches to the parent &lt;code&gt;&amp;lt;case&amp;gt;&lt;/code&gt; instance, it does not return the contained &lt;code&gt;&amp;lt;email&amp;gt;&lt;/code&gt; tag or its content.</source>
          <target state="translated">위의 예에서 XPath 표현식은 상위 &lt;code&gt;&amp;lt;case&amp;gt;&lt;/code&gt; 인스턴스 와 일치 하지만 포함 된 &lt;code&gt;&amp;lt;email&amp;gt;&lt;/code&gt; 태그 또는 해당 컨텐츠를 리턴하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6c654fffdc0c4d9920074cedfec4cb08ccdb8802" translate="yes" xml:space="preserve">
          <source>Note, installing MaxScale and the CDC Data Adapter as root creates the &lt;code&gt;/var/lib/mxs_adapter/&lt;/code&gt; directory. If you intend to run &lt;code&gt;mxs_adapter&lt;/code&gt; as a non-root user, ensure that the user can read and write from this directory. If not, change the ownership to that of your user. For instance,</source>
          <target state="translated">MaxScale 및 CDC 데이터 어댑터를 루트로 설치하면 &lt;code&gt;/var/lib/mxs_adapter/&lt;/code&gt; 디렉토리가 생성됩니다. 루트가 아닌 사용자로 &lt;code&gt;mxs_adapter&lt;/code&gt; 를 실행하려는 경우 사용자가이 디렉토리에서 읽고 쓸 수 있는지 확인하십시오. 그렇지 않은 경우 소유권을 사용자의 소유권으로 변경하십시오. 예를 들어</target>
        </trans-unit>
        <trans-unit id="4c9784c154cd06b7124d15b84ed48c6c87c9a66f" translate="yes" xml:space="preserve">
          <source>Note, putting spaces into a pattern in combination with the (?x) option can be useful to split different logical parts of a complex pattern, to make it more readable.</source>
          <target state="translated">패턴에 공백을 (? x) 옵션과 함께 사용하면 복잡한 패턴의 여러 논리 부분을 분할하여 더 읽기 쉽게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c932a5cb53eb672c8a5977e00015674a455f9226" translate="yes" xml:space="preserve">
          <source>Note, softlinks may cause a problem during the upgrade if you use the RPM or DEB packages. If you have linked a directory above /usr/local/mariadb/columnstore, the softlinks will be deleted and the upgrade will fail. In that case you will need to upgrade using the binary tarball instead. If you have only linked the data directories (ie /usr/local/MariaDB/columnstore/data*), the RPM/DEB package upgrade will work.</source>
          <target state="translated">RPM 또는 DEB 패키지를 사용하는 경우 업그레이드 중 소프트 링크로 인해 문제가 발생할 수 있습니다. / usr / local / mariadb / columnstore 이상의 디렉토리를 연결 한 경우 소프트 링크가 삭제되고 업그레이드가 실패합니다. 이 경우 바이너리 tarball을 사용하여 업그레이드해야합니다. 데이터 디렉토리 만 링크 한 경우 (예 : / usr / local / MariaDB / columnstore / data *) RPM / DEB 패키지 업그레이드가 작동합니다.</target>
        </trans-unit>
        <trans-unit id="ebc81f5163583a8b31f5d416e338bba2c7481e28" translate="yes" xml:space="preserve">
          <source>Note, that hulda has no &lt;code&gt;SHOW DATABASES&lt;/code&gt; privilege, even though she was granted the journalist role. She needs to &lt;strong&gt;set&lt;/strong&gt; the role first:</source>
          <target state="translated">hulda 에게는 언론인 역할이 부여되었지만 &lt;code&gt;SHOW DATABASES&lt;/code&gt; 권한 이 없습니다 . 그녀는 먼저 역할 을 &lt;strong&gt;설정&lt;/strong&gt; 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="eb6f241704ad3e8790a9e52b5f5c4340d836cabc" translate="yes" xml:space="preserve">
          <source>Note, that one cannot drop a current partition or the only historical partition.</source>
          <target state="translated">현재 파티션이나 유일한 히스토리 파티션을 삭제할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="b0484a9acc51d48404b9c0a681009817a51826c1" translate="yes" xml:space="preserve">
          <source>Note, that using compound statements this way is subject to following limitations:</source>
          <target state="translated">이 방법으로 복합 명령문을 사용하면 다음 제한 사항이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="6bed22210b820fc8087e9303862483cd72a16ddf" translate="yes" xml:space="preserve">
          <source>Note, the &lt;code&gt;0_DIRECT_NO_FSYNC&lt;/code&gt; method is only available with &lt;a href=&quot;../what-is-mariadb-100/index&quot;&gt;MariaDB 10.0&lt;/a&gt; and later. The &lt;code&gt;ALL_O_DIRECT&lt;/code&gt; method available with version 5.5 and later, but only with tables using the XtraDB storage engine.</source>
          <target state="translated">참고는 &lt;code&gt;0_DIRECT_NO_FSYNC&lt;/code&gt; 의 방법으로 만 사용할 수 있습니다 &lt;a href=&quot;../what-is-mariadb-100/index&quot;&gt;MariaDB 10.0&lt;/a&gt; 이상 및. &lt;code&gt;ALL_O_DIRECT&lt;/code&gt; 의 버전 5.5 이상을 사용할 수 있지만, 단지 XtraDB 스토리지 엔진을 사용하여 테이블 방법.</target>
        </trans-unit>
        <trans-unit id="df42efe39a491ba3563194cb149181e95e149a21" translate="yes" xml:space="preserve">
          <source>Note, the above rules mean that when an argument of a temporal data type appears in addition or subtraction, it's treated as a number by default.</source>
          <target state="translated">위의 규칙은 시간 데이터 유형의 인수가 덧셈 또는 뺄셈에 나타날 때 기본적으로 숫자로 취급됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="2ec748db3a770a8b414e273e1a9278b02357ee4d" translate="yes" xml:space="preserve">
          <source>Note, the backslash characters (here, and in all examples in the sections below) must be escaped with another backslash, unless you're using the &lt;a href=&quot;../sql-mode/index&quot;&gt;SQL_MODE&lt;/a&gt;&lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../sql-mode/index&quot;&gt;SQL_MODE &lt;/a&gt; &lt;code&gt;NO_BACKSLASH_ESCAPES&lt;/code&gt; 를 사용하지 않는 한 백 슬래시 문자 (여기서 아래 섹션의 모든 예에서)는 다른 백 슬래시로 이스케이프되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="7c08109b908d1e4d96c3c9a3b8b93a3032b9a1a0" translate="yes" xml:space="preserve">
          <source>Note, the new line convention does not affect the meaning of &lt;code&gt;\R&lt;/code&gt;.</source>
          <target state="translated">줄 바꾸기 규칙은 &lt;code&gt;\R&lt;/code&gt; 의 의미에 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="42a6063710fb054154be9a4749ceb65bc688c779" translate="yes" xml:space="preserve">
          <source>Note, the system user that runs the MariaDB Server process (which is usually &lt;code&gt;mysql&lt;/code&gt;) must have write permissions on the given path.</source>
          <target state="translated">MariaDB 서버 프로세스 (보통 &lt;code&gt;mysql&lt;/code&gt; ) 를 실행하는 시스템 사용자 는 주어진 경로에 대한 쓰기 권한이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="c77debb08afd5f7668f8e0077950ed4788f0f2b0" translate="yes" xml:space="preserve">
          <source>Note, this feature was deprecated in &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt;. It was removed in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1031-release-notes/&quot;&gt;MariaDB 10.3.1&lt;/a&gt;.</source>
          <target state="translated">이 기능은 &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt; 에서 더 이상 사용되지 않습니다 . &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1031-release-notes/&quot;&gt;MariaDB 10.3.1&lt;/a&gt; 에서 제거되었습니다 .</target>
        </trans-unit>
        <trans-unit id="47eed8528a0c557896ca88a7bc6bae8bcef3dd39" translate="yes" xml:space="preserve">
          <source>Note, using &lt;code&gt;--read-from-remote-server&lt;/code&gt; option on versions of the &lt;code&gt;mysqlbinlog&lt;/code&gt; utility that do not have the &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-20574&quot;&gt;MDEV-20574&lt;/a&gt; fix, can corrupt binlog positions when the binary log is encrypted.</source>
          <target state="translated">이용 주, &lt;code&gt;--read-from-remote-server&lt;/code&gt; 의 버전에 옵션 &lt;code&gt;mysqlbinlog&lt;/code&gt; 이없는 유틸리티 &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-20574&quot;&gt;인 mdev-20574&lt;/a&gt; 수정은 손상 바이너리 로그 위치 바이너리 로그가 암호화 할 수있을 때.</target>
        </trans-unit>
        <trans-unit id="83423c198b6099edba08f185f940042d5dba3b79" translate="yes" xml:space="preserve">
          <source>Note:</source>
          <target state="translated">Note:</target>
        </trans-unit>
        <trans-unit id="b0c5f983d3062c0fbcb18ceabf02b693e42528c7" translate="yes" xml:space="preserve">
          <source>Note: 8192 being here the _connect_conv_size_ value.</source>
          <target state="translated">참고 : 8192는 _connect_conv_size_ 값입니다.</target>
        </trans-unit>
        <trans-unit id="69ab0c35aa0839510f9b52bddb71e817803b26c1" translate="yes" xml:space="preserve">
          <source>Note: &lt;a href=&quot;../blob/index&quot;&gt;BLOB&lt;/a&gt; is currently not converted by default until a TYPE_BIN type is added to CONNECT. However, the FORCE option (from Connect 1.06.006) can be specified for blob columns containing text and the SKIP option also applies to ODBC BLOB columns.</source>
          <target state="translated">참고 : TYPE_BIN 유형이 CONNECT에 추가 될 때까지 &lt;a href=&quot;../blob/index&quot;&gt;BLOB&lt;/a&gt; 는 현재 기본적으로 변환되지 않습니다. 그러나 텍스트가 포함 된 Blob 열에는 FORCE 옵션 (Connect 1.06.006)을 지정할 수 있으며 SKIP 옵션은 ODBC BLOB 열에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="995bcdab23dee9f4d6232f3d14e5c0dea6f78cef" translate="yes" xml:space="preserve">
          <source>Note: &lt;a href=&quot;../text/index&quot;&gt;TEXT&lt;/a&gt; is allowed. However, the handling depends on the values given to the &lt;a href=&quot;../connect-system-variables/index#connect_type_conv&quot;&gt;connect_type_conv&lt;/a&gt; and &lt;a href=&quot;../connect-system-variables/index#connect_conv_size&quot;&gt;connect_conv_size&lt;/a&gt; system variables, and by default no conversion of TEXT columns is permitted.</source>
          <target state="translated">참고 : &lt;a href=&quot;../text/index&quot;&gt;TEXT&lt;/a&gt; 가 허용됩니다. 그러나 처리는 &lt;a href=&quot;../connect-system-variables/index#connect_type_conv&quot;&gt;connect_type_conv&lt;/a&gt; 및 &lt;a href=&quot;../connect-system-variables/index#connect_conv_size&quot;&gt;connect_conv_size&lt;/a&gt; 시스템 변수에 제공된 값에 따라 다르며 기본적으로 TEXT 열 변환은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2a22f44991652f910409d56e8d153b5216d2457a" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;COLUMN_ADD()&lt;/code&gt; is a regular function (just like &lt;code&gt;&lt;a href=&quot;../concat/index&quot;&gt;CONCAT()&lt;/a&gt;&lt;/code&gt;), hence, in order to update the value in the table you have to use the &lt;code&gt;UPDATE ... SET dynamic_col=COLUMN_ADD(dynamic_col,
 ....) &lt;/code&gt; pattern.</source>
          <target state="translated">참고 : &lt;code&gt;COLUMN_ADD()&lt;/code&gt; 는 정규 함수 ( &lt;code&gt;&lt;a href=&quot;../concat/index&quot;&gt;CONCAT()&lt;/a&gt;&lt;/code&gt; )이므로 테이블의 값을 업데이트하려면 &lt;code&gt;UPDATE ... SET dynamic_col=COLUMN_ADD(dynamic_col, ....) &lt;/code&gt; 패턴 을 사용해야합니다 . .</target>
        </trans-unit>
        <trans-unit id="31da085c1e7f48a386ed9566ae624e4642f47be7" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;aria_chk&lt;/code&gt; should not be used when MariaDB is running. MariaDB assumes that no one is changing the tables it's using!</source>
          <target state="translated">참고 : MariaDB가 실행 중일 때는 &lt;code&gt;aria_chk&lt;/code&gt; 를 사용 해서는 안됩니다. MariaDB는 아무도 사용중인 테이블을 변경하지 않는다고 가정합니다!</target>
        </trans-unit>
        <trans-unit id="33ad75c441223b6ad03472f42d12bf301d7885d2" translate="yes" xml:space="preserve">
          <source>Note: A &amp;lsquo;literal&amp;rsquo; may be a constant (e.g. 3) or an expression that evaluates to a constant [e.g. 100 - (27 * 3)]. For date columns, you may use the SQL &amp;lsquo;interval&amp;rsquo; syntax to perform date arithmetic, as long as all the components of the expression are constants (e.g. &amp;lsquo;1998-12-01&amp;rsquo; - interval &amp;lsquo;1&amp;rsquo; year)</source>
          <target state="translated">참고 : 'literal'은 상수 (예 : 3) 또는 상수로 평가되는 표현식 (예 : 100-(27 * 3)) 일 수 있습니다. 날짜 열의 경우, 표현식의 모든 구성 요소가 상수 인 한 (예 : '1998-12-01'-간격 '1'년) SQL 'interval'구문을 사용하여 날짜 산술을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c3f3d1776b822845819f5913365fcba935cfcf7" translate="yes" xml:space="preserve">
          <source>Note: All PROXY and PROXY-based table types are not indexable.</source>
          <target state="translated">참고 : 모든 PROXY 및 PROXY 기반 테이블 유형은 색인을 생성 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="fc57da42eab3844b5eb2f4713b0934181a9c8152" translate="yes" xml:space="preserve">
          <source>Note: All XCOL tables are read only.</source>
          <target state="translated">참고 : 모든 XCOL 테이블은 읽기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="08571352767d1e246521a9f76c566678878d2e36" translate="yes" xml:space="preserve">
          <source>Note: All relay log files are deleted, even if they have not been completely executed by the slave SQL thread. (This is a condition likely to exist on a replication slave if you have issued a STOP SLAVE statement or if the slave is highly loaded.)</source>
          <target state="translated">참고 : 모든 릴레이 로그 파일은 슬레이브 SQL 스레드에서 완전히 실행되지 않은 경우에도 삭제됩니다. (STOP SLAVE 문을 발행했거나 슬레이브가 많이로드 된 경우 복제 슬레이브에 존재할 수있는 조건입니다.)</target>
        </trans-unit>
        <trans-unit id="b06f1df697e01944174e4b71b1d348066d3a6f82" translate="yes" xml:space="preserve">
          <source>Note: All this applies only to tables having pretty = 2 (see below).</source>
          <target state="translated">참고 :이 모든 것은 pretty = 2 인 테이블에만 적용됩니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="6d87cf3036d07c643af4ca5b7b960d29cbf0527c" translate="yes" xml:space="preserve">
          <source>Note: Aria is compiled without -DIDENTICAL_PAGES_AFTER_RECOVERY which means that the table files are not byte-to-byte identical to files created during normal execution. This should be ok, except for test scripts that try to compare files before and after recovery.</source>
          <target state="translated">참고 : Aria는 -DIDENTICAL_PAGES_AFTER_RECOVERY없이 컴파일됩니다. 즉, 테이블 파일이 정상 실행 중에 작성된 파일과 바이트 단위가 동일하지 않습니다. 복구 전후 파일을 비교하려는 테스트 스크립트를 제외하고는 정상입니다.</target>
        </trans-unit>
        <trans-unit id="de7c9368e1dc8785944de0f6cbf3e8baee94624b" translate="yes" xml:space="preserve">
          <source>Note: Before &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10010-release-notes/&quot;&gt;MariaDB 10.0.10&lt;/a&gt; the arguments were reversed.</source>
          <target state="translated">참고 : &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10010-release-notes/&quot;&gt;MariaDB 10.0.10 이전&lt;/a&gt; 에는 인수가 취소되었습니다.</target>
        </trans-unit>
        <trans-unit id="789aeece1a0c81bf2855f3716f144f7c20ece648" translate="yes" xml:space="preserve">
          <source>Note: Before &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1021-release-notes/&quot;&gt;MariaDB 10.2.1&lt;/a&gt;, constraint expressions were accepted in syntax, but ignored.</source>
          <target state="translated">참고 : &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1021-release-notes/&quot;&gt;MariaDB 10.2.1&lt;/a&gt; 이전 에는 제약 조건 표현식이 구문으로 허용되었지만 무시되었습니다.</target>
        </trans-unit>
        <trans-unit id="b184d7c583e21e9e907582812eb1fb77ce0ce453" translate="yes" xml:space="preserve">
          <source>Note: Before &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1021-release-notes/&quot;&gt;MariaDB 10.2.1&lt;/a&gt;, constraint expressions were accepted in the syntax but ignored.</source>
          <target state="translated">참고 : &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1021-release-notes/&quot;&gt;MariaDB 10.2.1&lt;/a&gt; 이전 에는 제약 조건 표현식이 구문에서 허용되었지만 무시되었습니다.</target>
        </trans-unit>
        <trans-unit id="6e85b3c6fcb43eec07386ac2a6b04bf834afe92b" translate="yes" xml:space="preserve">
          <source>Note: Calling a column returning JSON a name prefixed by json_ (like json_author here) is good practice and removes the need to give it an alias to prevent escaping when used as an argument.</source>
          <target state="translated">참고 : json_이 앞에 붙은 이름 (예 : json_author here)을 JSON으로 반환하는 열을 호출하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3a843754235f4e11a4387a6f1f6be474387b22d3" translate="yes" xml:space="preserve">
          <source>Note: Calpont.xml and my.cnf modifications you manually made are not automatically carried forward on an upgrade. These modifications will need to be incorporated back into Columnstore.xml and my.cnf once the upgrade has occurred.</source>
          <target state="translated">참고 : 수동으로 작성한 Calpont.xml 및 my.cnf 수정은 업그레이드시 자동으로 전달되지 않습니다. 업그레이드가 발생하면 이러한 수정 사항을 Columnstore.xml 및 my.cnf에 다시 통합해야합니다.</target>
        </trans-unit>
        <trans-unit id="d45420507ee9efc8d946671a45234de36ab07138" translate="yes" xml:space="preserve">
          <source>Note: Calpont.xml modifications you manually made are not automatically carried forward on an upgrade. These modifications will need to be incorporated back into .XML once the upgrade has occurred.</source>
          <target state="translated">참고 : 수동으로 수행 한 Calpont.xml 수정 사항은 업그레이드시 자동으로 전달되지 않습니다. 업그레이드가 이루어지면 이러한 수정 사항을 .XML로 다시 통합해야합니다.</target>
        </trans-unit>
        <trans-unit id="8271a6f104be5de8cc51e30a8007666b14da0bb2" translate="yes" xml:space="preserve">
          <source>Note: Columnstore.xml modifications you manually made are not automatically carried forward on an upgrade. These modifications will need to be incorporated back into .XML once the upgrade has occurred.</source>
          <target state="translated">참고 : 수동으로 만든 Columnstore.xml 수정 사항은 업그레이드시 자동으로 전달되지 않습니다. 업그레이드가 이루어지면 이러한 수정 사항을 .XML로 다시 통합해야합니다.</target>
        </trans-unit>
        <trans-unit id="5fba0c5dc337f48640f37ae83b72d2e884a84913" translate="yes" xml:space="preserve">
          <source>Note: Conforming java naming usage, class names are preceded by the java package name with a slash separator. However, this is not mandatory for CONNECT which adds the package name if it is missing.</source>
          <target state="translated">참고 : Java 이름 지정 사용법에 따라 클래스 이름 앞에 슬래시 구분 기호가있는 Java 패키지 이름이옵니다. 그러나 패키지 이름이없는 경우이를 추가하는 CONNECT에는 필수가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="5fe4289d598b015c973f5ef151ff2e85d2e234ba" translate="yes" xml:space="preserve">
          <source>Note: For columns prone to be targeted by a where clause, keep the column type compatible with the source table column type (numeric or character) to have a correct rephrasing of the where clause.</source>
          <target state="translated">참고 : where 절에서 대상이되기 쉬운 열의 경우 where 절을 올바르게 표현하려면 열 유형을 소스 테이블 열 유형 (숫자 또는 문자)과 호환 가능하게 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="41e6304ca2ac10f600524eed02f2783a75700447" translate="yes" xml:space="preserve">
          <source>Note: For more detail about this, see &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-17501&quot;&gt;MDEV-17501&lt;/a&gt;.</source>
          <target state="translated">참고 : 이에 대한 자세한 내용은 &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-17501&quot;&gt;MDEV-17501을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="548625b5e0774761b1d48bd19b62a81cffe88ab8" translate="yes" xml:space="preserve">
          <source>Note: For the content of these options, refer to the MongoDB documentation.</source>
          <target state="translated">참고 :이 옵션의 내용은 MongoDB 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e3df5a092881038a21d40bc6264528b5890f91b9" translate="yes" xml:space="preserve">
          <source>Note: For this simple example, this is equivalent to using the &lt;em&gt;Json_Array&lt;/em&gt; function.</source>
          <target state="translated">참고 :이 간단한 예에서는 &lt;em&gt;Json_Array&lt;/em&gt; 함수 를 사용하는 &lt;em&gt;것과&lt;/em&gt; 같습니다.</target>
        </trans-unit>
        <trans-unit id="f29e1609a8c5c80dcda7efac5e676652197be730" translate="yes" xml:space="preserve">
          <source>Note: If &lt;code&gt;&lt;a href=&quot;#query_response_time_stats&quot;&gt;query_response_time_stats&lt;/a&gt;&lt;/code&gt; is set to &lt;code&gt;ON&lt;/code&gt;, then the execution times for these two SELECT queries will also be collected.</source>
          <target state="translated">참고 : &lt;code&gt;&lt;a href=&quot;#query_response_time_stats&quot;&gt;query_response_time_stats&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;ON&lt;/code&gt; 으로 설정 되면 이 두 SELECT 쿼리의 실행 시간도 수집됩니다.</target>
        </trans-unit>
        <trans-unit id="150066a8539ea8cfb41c8a20885a0e99020deae3" translate="yes" xml:space="preserve">
          <source>Note: If a table is based on several zipped files each containing several entries, only the first case is possible. Using sub-partitioning to make partitions on each entries is not supported yet.</source>
          <target state="translated">참고 : 테이블이 각각 여러 항목을 포함하는 여러 개의 압축 파일을 기반으로하는 경우 첫 번째 경우 만 가능합니다. 하위 파티션을 사용하여 각 항목에서 파티션을 만드는 것은 아직 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="57e02c2948c52a26793ff04b8e5bde7be0bb3cb8" translate="yes" xml:space="preserve">
          <source>Note: If another version of MariaDB is currently running, this service will need to be stopped before running this command. After the rpm command has been executed, you can restart the service.</source>
          <target state="translated">참고 : 다른 버전의 MariaDB가 현재 실행중인 경우이 명령을 실행하기 전에이 서비스를 중지해야합니다. rpm 명령이 실행 된 후 서비스를 다시 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc1b9e491368727c49076e45c7af852720c8c4bb" translate="yes" xml:space="preserve">
          <source>Note: If sub-partitioning is used, inward table files and index files are named:</source>
          <target state="translated">참고 : 하위 파티션을 사용하는 경우 내부 테이블 파일과 인덱스 파일의 이름은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7aa2a32d03ba4e201f73b43228b403f5566ed134" translate="yes" xml:space="preserve">
          <source>Note: If the collection does not exist yet when creating the table and inserting in it, MongoDB creates it automatically.</source>
          <target state="translated">참고 : 테이블을 생성하고 삽입 할 때 컬렉션이 아직 존재하지 않으면 MongoDB는 자동으로 생성합니다.</target>
        </trans-unit>
        <trans-unit id="1e43ab6dacae81329360e881e10f06f35afd716e" translate="yes" xml:space="preserve">
          <source>Note: If the specified key already exists in the object, its value is replaced by the new one.</source>
          <target state="translated">참고 : 지정된 키가 이미 개체에 존재하면 해당 값이 새 키로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="541d5705041a41988100c116ae1b8f2de32b170b" translate="yes" xml:space="preserve">
          <source>Note: If this table were a big table with many books, it would be difficult to know what the order of a specific book is in the table. This can be found by adding a special ROWID column in the table.</source>
          <target state="translated">참고 :이 테이블이 많은 책이있는 큰 테이블 인 경우 테이블에서 특정 책의 순서가 무엇인지 알기가 어렵습니다. 이는 테이블에 특수 ROWID 열을 추가하여 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c20e24b246f8fd0b3a69b9b170a9b6fd595acbe6" translate="yes" xml:space="preserve">
          <source>Note: If you want to use this feature with a binary distributed version of MariaDB, even a previous version not containing the last CONNECT version, it is also possible to add it as an OEM module as explained in Appendix B.</source>
          <target state="translated">참고 :이 기능을 MariaDB의 이진 분산 버전 (마지막 CONNECT 버전이 포함되지 않은 이전 버전)과 함께 사용하려면 부록 B에 설명 된대로 기능을 OEM 모듈로 추가 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b506c1265a4f65d159ef0ecbd0880fe5b5c8cedd" translate="yes" xml:space="preserve">
          <source>Note: If you're running a source code distribution of MariaDB, (that is, where you compiled it from source), the script is located in the build directory at &lt;code&gt;storage/spider/scripts/install_spider.sql&lt;/code&gt;.</source>
          <target state="translated">참고 : MariaDB의 소스 코드 배포를 실행중인 경우 (즉, 소스에서 컴파일 한 경우) 스크립트는 build &lt;code&gt;storage/spider/scripts/install_spider.sql&lt;/code&gt; 의 빌드 디렉토리에 있습니다.</target>
        </trans-unit>
        <trans-unit id="b95203c25a3c955ccaef9899eccd7e0da47f0ed1" translate="yes" xml:space="preserve">
          <source>Note: In CONNECT version 1.3 (before &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10023-release-notes/&quot;&gt;MariaDB 10.0.23&lt;/a&gt;, &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1019-release-notes/&quot;&gt;MariaDB 10.1.9&lt;/a&gt;), this function behaved like the new &lt;code&gt;Json_Array_Add_Values&lt;/code&gt; function. The following describes this function for CONNECT version 1.4 (from MariaDB &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10023-release-notes/&quot;&gt;MariaDB 10.0.23&lt;/a&gt;, 10.1.9) only. The first argument must be a JSON array. The second argument is added as member of this array. For example:</source>
          <target state="translated">참고 : CONNECT 버전 1.3 ( &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10023-release-notes/&quot;&gt;MariaDB 10.0.23&lt;/a&gt; , &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1019-release-notes/&quot;&gt;MariaDB 10.1.9 이전&lt;/a&gt; )에서이 함수는 새로운 &lt;code&gt;Json_Array_Add_Values&lt;/code&gt; 함수 처럼 작동 합니다. 다음은 CONNECT 버전 1.4 (MariaDB &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10023-release-notes/&quot;&gt;MariaDB 10.0.23&lt;/a&gt; , 10.1.9)에 대해서만 이 기능을 설명 합니다. 첫 번째 인수는 JSON 배열이어야합니다. 두 번째 인수는이 배열의 멤버로 추가됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="52e86ca534cb10b3df40ec7f6aa8dce792f4091b" translate="yes" xml:space="preserve">
          <source>Note: In previous versions of JDBC, to obtain a connection, java first had to initialize the JDBC driver by calling the method Class.forName. In this case, see the documentation of your DBMS driver to obtain the name of the class that implements the interface java.sql.Driver. This name can be specified as an option DRIVER to be put in the option list. However, most modern JDBC drivers since version 4 are self-loading and do not require this option to be specified.</source>
          <target state="translated">참고 : 이전 버전의 JDBC에서 연결을 얻으려면 java는 먼저 Class.forName 메소드를 호출하여 JDBC 드라이버를 초기화해야했습니다. 이 경우, 인터페이스 java.sql.Driver를 구현하는 클래스의 이름을 얻으려면 DBMS 드라이버 문서를 참조하십시오. 이 이름은 옵션 목록에 넣을 옵션 DRIVER로 지정할 수 있습니다. 그러나 버전 4 이후 대부분의 최신 JDBC 드라이버는 자동로드되므로이 옵션을 지정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="dcea2ade98a80a5e96c36ba778a68fd9badc2d7e" translate="yes" xml:space="preserve">
          <source>Note: It can only 1 table (but multiple columns) be updated from the table list in table_references.</source>
          <target state="translated">참고 : table_references의 테이블 목록에서 하나의 테이블 (여러 열) 만 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b33fe16d41b56c7fbdbf3da1b1bbc3fc2b44a796" translate="yes" xml:space="preserve">
          <source>Note: It was an important facility to name the second column of the table beginning by &amp;ldquo;jfile_&amp;rdquo; so the json functions knew it was a file name without obliging to specify an alias in the queries.</source>
          <target state="translated">참고 :&amp;ldquo;jfile_&amp;rdquo;로 시작하는 테이블의 두 번째 열 이름을 지정하는 것이 중요한 기능이므로 json 함수는 쿼리에서 별명을 지정할 필요없이 파일 이름임을 알 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="ff5cbfc2dc8a44c521c964caf0342e825fd09aa2" translate="yes" xml:space="preserve">
          <source>Note: JSON tables using the MongoDB access accept the specific MONGO options &lt;em&gt;colist&lt;/em&gt;, &lt;em&gt;filter&lt;/em&gt; and &lt;em&gt;pipe&lt;/em&gt;. They are described in the MONGO table chapter.</source>
          <target state="translated">참고 : MongoDB 액세스를 사용하는 JSON 테이블은 특정 MONGO 옵션 &lt;em&gt;colist&lt;/em&gt; , &lt;em&gt;filter&lt;/em&gt; 및 &lt;em&gt;pipe를 허용&lt;/em&gt; 합니다. MONGO 표 장에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e1c565b6d3caf275004070c3f059c010d893ad7" translate="yes" xml:space="preserve">
          <source>Note: Json function names are often written on this page with leading upper case letters for clarity. It is possible to do so in SQL queries because function names are case insensitive. However, when creating or dropping them, their names must match the case they are in the library module (lower case from &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10023-release-notes/&quot;&gt;MariaDB 10.0.23&lt;/a&gt;, &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1019-release-notes/&quot;&gt;MariaDB 10.1.9&lt;/a&gt;).</source>
          <target state="translated">참고 : Json 함수 이름은 명확성을 위해이 페이지에서 대문자로 시작되는 경우가 많습니다. 함수 이름은 대소 문자를 구분하지 않기 때문에 SQL 쿼리에서 그렇게 할 수 있습니다. 그러나 작성 또는 제거 할 때 이름은 라이브러리 모듈에있는 경우와 일치해야합니다 ( &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10023-release-notes/&quot;&gt;MariaDB 10.0.23&lt;/a&gt; , &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1019-release-notes/&quot;&gt;MariaDB 10.1.9&lt;/a&gt; 소문자 ).</target>
        </trans-unit>
        <trans-unit id="94dcc3b0dda8c7a05998533eac1307f7d45d8e19" translate="yes" xml:space="preserve">
          <source>Note: Make sure the above entry is added to the rc.local file that gets executed at boot time. Depending on the OS installation, rc.local could be in a different location.</source>
          <target state="translated">참고 : 부팅시 실행되는 rc.local 파일에 위 항목이 추가되었는지 확인하십시오. OS 설치에 따라 rc.local은 다른 위치에있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="452014e3d4632de3e5436886e84f851fa1c86455" translate="yes" xml:space="preserve">
          <source>Note: MariaDB ColumnStore installation will install with a single MariaDB userid of root with no password. You may setup users and permissions for a MariaDB ColumnStore-MySQL account just as you would in MySQL.</source>
          <target state="translated">참고 : MariaDB ColumnStore 설치는 비밀번호없이 root의 단일 MariaDB 사용자 ID로 설치됩니다. MySQL에서와 마찬가지로 MariaDB ColumnStore-MySQL 계정에 대한 사용자 및 권한을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="41a02640bf719eca8d6237921dae85318363fd0f" translate="yes" xml:space="preserve">
          <source>Note: MariaDB ColumnStore installation will install with a single MariaDB userid of root with no password. You may setup users and permissions for a MariaDB ColumnStore-Mysql account just as you would in MySQL.</source>
          <target state="translated">참고 : MariaDB ColumnStore 설치는 비밀번호없이 root의 단일 MariaDB 사용자 ID로 설치됩니다. MySQL에서와 마찬가지로 MariaDB ColumnStore-Mysql 계정에 대한 사용자 및 권한을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bcf8c8bd0d037be3d9e02af6b4787a7c9ceacf03" translate="yes" xml:space="preserve">
          <source>Note: MariaDB ColumnStore will configure a root user with no password in the MariaDB server initially. Afterward, you may setup users and permissions within MariaDB as you normally would.</source>
          <target state="translated">참고 : MariaDB ColumnStore는 처음에 MariaDB 서버에 비밀번호가없는 루트 사용자를 구성합니다. 그 후, 평소와 같이 MariaDB 내에서 사용자와 권한을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da52ece33cbbd4cedc942c3e901c783a3f99a5de" translate="yes" xml:space="preserve">
          <source>Note: Multi-column primary keys are currently not supported. Support may be added in a future version, depending on whether there is a demand for it.</source>
          <target state="translated">참고 : 다중 열 기본 키는 현재 지원되지 않습니다. 수요가 있는지 여부에 따라 향후 버전에서 지원이 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0158924a6821e78f329319349ff5b93efcb5cef7" translate="yes" xml:space="preserve">
          <source>Note: No M or G suffix is allowed here.</source>
          <target state="translated">참고 : 여기에는 M 또는 G 접미사가 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7dab6f9bd3b1dc1eec12329ed05a3873861aee62" translate="yes" xml:space="preserve">
          <source>Note: On Debian-based distributions, you may receive a &lt;em&gt;&quot;You must put some 'source' URIs in your sources.list&quot;&lt;/em&gt; error. To avoid this, ensure that /etc/apt/sources.list contains the source repositories.</source>
          <target state="translated">참고 : 데비안 기반 배포판에서는 &lt;em&gt;&quot;sources.list에 'source'URI를 넣어야합니다&quot;&lt;/em&gt; 오류가 표시 될 수 있습니다. 이를 피하려면 /etc/apt/sources.list에 소스 리포지토리가 포함되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="945fe13b9dfe3cabaa061f2b57158821c5b56e0b" translate="yes" xml:space="preserve">
          <source>Note: On Linux, unixODBC must be installed.</source>
          <target state="translated">참고 : Linux에서는 unixODBC가 설치되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="3fa0b2744f86a662a8b850d140f366c7e410cd0c" translate="yes" xml:space="preserve">
          <source>Note: On Windows, the compiled Debug version generated code must be compatible with the &lt;code&gt;cpprest&lt;/code&gt; dll called by CONNECT when using REST. If not, this will cause a server crash. If this occurs, recompile CONNECT with Visual Studio after setting the Code Generation Runtime Library to the proper value. It could depend on the way &lt;code&gt;cpprestsdk&lt;/code&gt; was installed and most of the time will be /MDd.</source>
          <target state="translated">참고 : Windows에서 컴파일 된 디버그 버전 생성 코드는 REST를 사용할 때 CONNECT가 호출 한 &lt;code&gt;cpprest&lt;/code&gt; dll 과 호환 가능해야합니다 . 그렇지 않으면 서버 충돌이 발생합니다. 이 경우 코드 생성 런타임 라이브러리를 적절한 값으로 설정 한 후 Visual Studio로 CONNECT를 다시 컴파일하십시오. &lt;code&gt;cpprestsdk&lt;/code&gt; 가 설치된 방식에 따라 달라질 수 있으며 대부분의 시간은 / MDd입니다.</target>
        </trans-unit>
        <trans-unit id="9b45e59052d5178ce29d72a6932b9fb2d0c2608c" translate="yes" xml:space="preserve">
          <source>Note: On openSUSE the source package repository may be disabled. The following command will enable it:</source>
          <target state="translated">참고 : openSUSE에서 소스 패키지 저장소가 사용 불가능할 수 있습니다. 다음 명령으로 활성화합니다 :</target>
        </trans-unit>
        <trans-unit id="75ef267f39d48815e12155e7071549e3ec11d30b" translate="yes" xml:space="preserve">
          <source>Note: Oracle, as Postgresql, does not seem to understand the DATABASE setting as the table schema that must be specified in the Create Table statement.</source>
          <target state="translated">참고 : Oracle은 Postgresql과 같이 DATABASE 설정을 Create Table 문에 지정해야하는 테이블 스키마로 이해하지 못하는 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="e4a6173683ae888993c0895bbfb51663c2194ec0" translate="yes" xml:space="preserve">
          <source>Note: PostgreSQL, when a column size is undefined, returns 2147483647, which is not acceptable for MariaDB. CONNECT change it to the value of the connect_conv_size session variable. Also, for TEXT columns the data type returned is 12 (SQL_VARCHAR) instead of -1 the SQL_TEXT value.</source>
          <target state="translated">참고 : PostgreSQL은 열 크기가 정의되지 않은 경우 Maria214에 허용되지 않는 2147483647을 반환합니다. CONNECT는 connect_conv_size 세션 변수의 값으로 변경하십시오. 또한 TEXT 컬럼의 경우 리턴되는 데이터 유형은 SQL_TEXT 값 -1 대신 12 (SQL_VARCHAR)입니다.</target>
        </trans-unit>
        <trans-unit id="790f626c43bcf451176d2aecb38f950132cd3f8e" translate="yes" xml:space="preserve">
          <source>Note: START SLAVE UNTIL first appeared in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1003-release-notes/&quot;&gt;MariaDB 10.0.3&lt;/a&gt;.</source>
          <target state="translated">참고 : START SLAVE UNTIL은 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1003-release-notes/&quot;&gt;MariaDB 10.0.3&lt;/a&gt; 에서 처음 나타났습니다 .</target>
        </trans-unit>
        <trans-unit id="0a7216e3197917de4057481c92e5bb2a74b65118" translate="yes" xml:space="preserve">
          <source>Note: See &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-7540&quot;&gt;MDEV-7540&lt;/a&gt;.</source>
          <target state="translated">참고 : &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-7540&quot;&gt;MDEV-7540을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="72c96c5e1729e3f85a46caff72ffcdddda5ef330" translate="yes" xml:space="preserve">
          <source>Note: Some JDBC drivers fail when the global time_zone variable is ambiguous, which sometimes happens when it is set to SYSTEM. If so, reset it to a not ambiguous value, for instance:</source>
          <target state="translated">참고 : 전역 time_zone 변수가 모호한 경우 일부 JDBC 드라이버가 실패하며, 때로는 SYSTEM으로 설정되어있을 때 발생합니다. 그렇다면 다음과 같이 모호하지 않은 값으로 재설정하십시오.</target>
        </trans-unit>
        <trans-unit id="a3f3fcbedba1a6d5f5832655d0c7e25d3d127f9a" translate="yes" xml:space="preserve">
          <source>Note: Some data sources, including MySQL and MariaDB, accept aliases in the having clause. In that case, the alias option could have been specified as:</source>
          <target state="translated">참고 : MySQL 및 MariaDB를 포함한 일부 데이터 소스는 having 절에서 별칭을 허용합니다. 이 경우 별명 옵션을 다음과 같이 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86ab1c4bde428a20e70f0c7921ed2ab39bfa9819" translate="yes" xml:space="preserve">
          <source>Note: The &lt;a href=&quot;../columnstore-performance-module/index&quot;&gt;Performance Module&lt;/a&gt; that the DBRoot is being unassigned from must to Manually Offline. The system must be in a STOPPED state</source>
          <target state="translated">참고 : DBRoot가 할당 해제 된 &lt;a href=&quot;../columnstore-performance-module/index&quot;&gt;성능 모듈&lt;/a&gt; 은 수동 오프라인으로해야합니다. 시스템은 STOPPED 상태 여야합니다</target>
        </trans-unit>
        <trans-unit id="5da464ef4250dcd4428753058a9bf94403da9166" translate="yes" xml:space="preserve">
          <source>Note: The &lt;a href=&quot;../connect-system-variables/index#connect_type_conv&quot;&gt;connect_type_conv&lt;/a&gt; SKIP option also applies to ODBC and JDBC tables.</source>
          <target state="translated">참고 : &lt;a href=&quot;../connect-system-variables/index#connect_type_conv&quot;&gt;connect_type_conv&lt;/a&gt; SKIP 옵션은 ODBC 및 JDBC 테이블에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="d5ae046fd88b66921ab2dbb407265d7f9746fafc" translate="yes" xml:space="preserve">
          <source>Note: The &lt;strong&gt;&lt;em&gt;Aria&lt;/em&gt;&lt;/strong&gt; storage engine was previously called &lt;em&gt;&lt;strong&gt;Maria&lt;/strong&gt;&lt;/em&gt; (see &lt;a href=&quot;../the-aria-name/index&quot;&gt;The Aria Name&lt;/a&gt; for details on the rename) and in previous versions of &lt;a href=&quot;../mariadb/index&quot;&gt;MariaDB&lt;/a&gt; the engine was still called Maria.</source>
          <target state="translated">참고 : &lt;strong&gt;&lt;em&gt;Aria&lt;/em&gt;&lt;/strong&gt; 스토리지 엔진은 이전에 &lt;em&gt;&lt;strong&gt;Maria&lt;/strong&gt;&lt;/em&gt; 라고하며 ( 이름 변경에 대한 자세한 내용 &lt;a href=&quot;../the-aria-name/index&quot;&gt;은 Aria 이름&lt;/a&gt; 참조 ) 이전 버전의 &lt;a href=&quot;../mariadb/index&quot;&gt;MariaDB&lt;/a&gt; 에서는 엔진을 여전히 Maria라고했습니다.</target>
        </trans-unit>
        <trans-unit id="9f79085188fbfad5eaba73ce5162af2dc2fb8d34" translate="yes" xml:space="preserve">
          <source>Note: The argument list can be void. If so a void array is returned.</source>
          <target state="translated">참고 : 인수 목록은 무효가 될 수 있습니다. 그렇다면 void 배열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b256f0c0db08f2967f10ad301f7f66845d3cb963" translate="yes" xml:space="preserve">
          <source>Note: The array is aliased &amp;ldquo;json_second&amp;rdquo; to indicate it is a json item and avoid escaping it. However, the &amp;ldquo;json_&amp;rdquo; prefix is skipped when making the object and must not be added to the path.</source>
          <target state="translated">참고 : 배열은 json 항목임을 나타 내기 위해&amp;ldquo;json_second&amp;rdquo;로 별칭이 지정되며 이스케이프되지 않습니다. 그러나&amp;ldquo;json_&amp;rdquo;접두사는 객체를 만들 때 건너 뛰므로 경로에 추가해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="5449050d4e4880207245eae025c2072f13d94597" translate="yes" xml:space="preserve">
          <source>Note: The dbname indicated in the URL corresponds for many DBMS to the catalog information. For MySQL and MariaDB it is the schema (often called database) of the connection.</source>
          <target state="translated">참고 : URL에 표시된 dbname은 많은 DBMS에 대해 카탈로그 정보에 해당합니다. MySQL과 MariaDB의 경우 연결의 스키마 (종종 데이터베이스라고 함)입니다.</target>
        </trans-unit>
        <trans-unit id="8587c3470aec3e7275947567ab46e9c6f2dd4c6e" translate="yes" xml:space="preserve">
          <source>Note: The first array is not escaped, its (alias) name beginning with &amp;lsquo;json_&amp;rsquo;.</source>
          <target state="translated">참고 : 첫 번째 배열은 이스케이프되지 않으며 이름은 'json_'로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="10ee5a7a044093b808d9f6e7b21eff14b0f6aa71" translate="yes" xml:space="preserve">
          <source>Note: The packages will be installed at /usr/local. This is required for root user installations.</source>
          <target state="translated">참고 : 패키지는 / usr / local에 설치됩니다. 루트 사용자 설치에 필요합니다.</target>
        </trans-unit>
        <trans-unit id="5ba10d7f5a63f154560ed48d105e384abfb28856" translate="yes" xml:space="preserve">
          <source>Note: The packages will be installed into /usr/local. This is required for root user installs</source>
          <target state="translated">참고 : 패키지는 / usr / local에 설치됩니다. 루트 사용자 설치에 필요합니다</target>
        </trans-unit>
        <trans-unit id="958c48859848df6ee7545afda2ea4a06f0094f04" translate="yes" xml:space="preserve">
          <source>Note: The used driver is by default the C driver if only the MongoDB C Driver is installed and the Java driver if only the MongoDB Java Driver is installed. If both are available, it can be specified by the DRIVER option to be specified in the option list and defaults to C.</source>
          <target state="translated">참고 : 사용 된 드라이버는 MongoDB C 드라이버 만 설치된 경우 기본적으로 C 드라이버이고 MongoDB Java 드라이버 만 설치된 경우 Java 드라이버입니다. 둘 다 사용 가능한 경우 DRIVER 옵션으로 지정하여 옵션 목록에 지정하고 기본값은 C입니다.</target>
        </trans-unit>
        <trans-unit id="075ac9c25fc31092ffd171b1aeb3716d244708dc" translate="yes" xml:space="preserve">
          <source>Note: The way file names are retrieved makes positional access to them impossible. Therefore, DIR tables cannot be indexed or sorted when it is done using positions.</source>
          <target state="translated">참고 : 파일 이름을 검색하는 방법으로 파일에 대한 위치 액세스가 불가능합니다. 따라서 DIR 테이블은 위치를 사용하여 수행 될 때 색인화되거나 정렬 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ff43056ca1d761d9559c82736802959bc199b102" translate="yes" xml:space="preserve">
          <source>Note: This is a fake &lt;code&gt;my_global.h&lt;/code&gt; that just contains what is useful for the &lt;code&gt;jmgoem.cpp&lt;/code&gt;source file.</source>
          <target state="translated">참고 : 이것은 &lt;code&gt;jmgoem.cpp&lt;/code&gt; 소스 파일에 유용한 것만 포함 하는 가짜 &lt;code&gt;my_global.h&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="a4b66a8c9ba4d21f70af0e9599edb0d8c6906c23" translate="yes" xml:space="preserve">
          <source>Note: This last table can be used to make array calculations like with JSON tables using the JSON UDF functions. For instance:</source>
          <target state="translated">참고 :이 마지막 테이블은 JSON UDF 함수를 사용하여 JSON 테이블과 같은 배열 계산을 수행하는 데 사용할 수 있습니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="48f2b63670f451844edfd6d022abe7b902e4158d" translate="yes" xml:space="preserve">
          <source>Note: This mode is not as fast as the append-only mode and might not be suitable for heavy workloads. This is due to the fact that the data transformation is done via various DML statements.</source>
          <target state="translated">참고 :이 모드는 추가 전용 모드만큼 빠르지 않으며 작업량이 많은 경우에는 적합하지 않을 수 있습니다. 이는 데이터 변환이 다양한 DML 문을 통해 수행되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="076da3c3e59cfe5e88301732a8a970ea3ee38bf9" translate="yes" xml:space="preserve">
          <source>Note: This page is obsolete. The information is old, outdated, or otherwise...</source>
          <target state="translated">참고 :이 페이지는 더 이상 사용되지 않습니다. 정보가 오래되었거나 구식이거나 그렇지 않은 경우 ...</target>
        </trans-unit>
        <trans-unit id="3533ed4ce1acbe4b3e024f1c9e7c2db3e1758c8d" translate="yes" xml:space="preserve">
          <source>Note: This raises an error (and is useless anyway) with DOMDOC.</source>
          <target state="translated">참고 : DOMDOC에서 오류가 발생합니다 (어쨌든 쓸모가 없습니다).</target>
        </trans-unit>
        <trans-unit id="ca487b407f79279fa9343ac6cae0ef1a664a01a3" translate="yes" xml:space="preserve">
          <source>Note: This script will also be added to the /root/.bash_profile. The following alias will be created after running the Alias:</source>
          <target state="translated">참고 :이 스크립트는 /root/.bash_profile에도 추가됩니다. 별명을 실행 한 후 다음 별명이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="1ee802522d8fb0059890b1f84a40762bfa97a641" translate="yes" xml:space="preserve">
          <source>Note: VEC being a file format specific to CONNECT, no big endian / little endian conversion is provided. These files are not portable between machines using a different byte order setting.</source>
          <target state="translated">참고 : VEC는 CONNECT 전용 파일 형식이므로 빅 엔디안 / 리틀 엔디안 변환은 제공되지 않습니다. 이 파일들은 다른 바이트 순서 설정을 사용하는 머신간에 이식성이 없습니다.</target>
        </trans-unit>
        <trans-unit id="90e4ffc92ad1864fb7223374b66676e9273122bd" translate="yes" xml:space="preserve">
          <source>Note: When calculating on arrays, null values are ignored.</source>
          <target state="translated">참고 : 배열을 계산할 때는 null 값이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="11bc9fc62cae02597f7b9f351c4d03c514e5e833" translate="yes" xml:space="preserve">
          <source>Note: When installed with a package manager, an option file that contains the &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-plugin-load-add&quot;&gt;--plugin-load-add&lt;/a&gt;&lt;/code&gt; option may also be installed. The RPM package installs it as &lt;code&gt;/etc/my.cnf.d/rocksdb.cnf&lt;/code&gt;, and the DEB package installs it as &lt;code&gt;/etc/mysql/mariadb.conf.d/rocksdb.cnf&lt;/code&gt;</source>
          <target state="translated">참고 : 패키지 관리자와 함께 설치하면 &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-plugin-load-add&quot;&gt;--plugin-load-add&lt;/a&gt;&lt;/code&gt; 옵션이 포함 된 옵션 파일 도 설치 될 수 있습니다. RPM 패키지는이를 &lt;code&gt;/etc/my.cnf.d/rocksdb.cnf&lt;/code&gt; 로 설치 하고 DEB 패키지는이를 &lt;code&gt;/etc/mysql/mariadb.conf.d/rocksdb.cnf&lt;/code&gt; 로 설치합니다</target>
        </trans-unit>
        <trans-unit id="63637d433b2f7e1f63cac4c3c8b78411247ecefb" translate="yes" xml:space="preserve">
          <source>Note: When testing, the tree returned by a &amp;ldquo;Jbin&amp;rdquo; function can be seen using the &lt;em&gt;Json_Serialize&lt;/em&gt; function whose unique parameter must be a &amp;ldquo;Jbin&amp;rdquo; result. For instance:</source>
          <target state="translated">참고 : 테스트시 &quot;Jbin&quot;함수에서 반환 된 트리는 고유 한 매개 변수가 &quot;Jbin&quot;결과 여야 하는 &lt;em&gt;Json_Serialize&lt;/em&gt; 함수를 사용하여 볼 수 있습니다 . 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="2ac48d23e662aff1a31ee9ce2037a2e0ac1a57d5" translate="yes" xml:space="preserve">
          <source>Note: With some ODBC drivers, the DBNAME option or qualified table name is useless because the schema implied by the connection string or the definition of the data source has priority over the specified DBNAME .</source>
          <target state="translated">참고 : 일부 ODBC 드라이버의 경우 연결 문자열 또는 데이터 소스 정의에 의해 암시 된 스키마가 지정된 DBNAME보다 우선하므로 DBNAME 옵션 또는 규정 된 테이블 이름은 쓸모가 없습니다.</target>
        </trans-unit>
        <trans-unit id="bcb6d6d7c5999d12868d1edc1b854a96d9ed185c" translate="yes" xml:space="preserve">
          <source>Note: XtraDB has the experimental feature of an increased InnoDB log block size of 4K. If this is enabled, then both redo log I/O and page I/O in InnoDB will match a sector size of 4K.</source>
          <target state="translated">참고 : XtraDB에는 증가 된 InnoDB 로그 블록 크기 4K의 실험 기능이 있습니다. 이것이 활성화되면 InnoDB의 리두 로그 I / O와 페이지 I / O가 모두 섹터 크기 4K와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="ffa5cddb3413f64b655087219453440dda82dc9a" translate="yes" xml:space="preserve">
          <source>Note: You can download a &lt;a href=&quot;https://mariadb.com/kb/en/mariadb/documentation/storage-engines/connect/connect-table-types/+attachment/connect_1_6_11&quot;&gt;PDF version of the CONNECT documentation&lt;/a&gt;.</source>
          <target state="translated">참고 : &lt;a href=&quot;https://mariadb.com/kb/en/mariadb/documentation/storage-engines/connect/connect-table-types/+attachment/connect_1_6_11&quot;&gt;CONNECT 설명서&lt;/a&gt; 의 PDF 버전을 다운로드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4f7854011f33402904cf8234f3974dd2079c3a4f" translate="yes" xml:space="preserve">
          <source>Note: You can't unassigned DBROOT #1. It always has to be assigned to the Active Parent &lt;a href=&quot;../columnstore-performance-module/index&quot;&gt;Performance Module&lt;/a&gt;.</source>
          <target state="translated">참고 : 할당되지 않은 DBROOT # 1은 할 수 없습니다. 항상 Active Parent &lt;a href=&quot;../columnstore-performance-module/index&quot;&gt;Performance Module에&lt;/a&gt; 할당되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="abfdde7e43fc3637ff50e1982845663084b37ef9" translate="yes" xml:space="preserve">
          <source>Note: an exception to this rule is Mac OS X. On Mac OS X old log files are not recycled because writing pre-allocated file is slower than writing to the end of file.</source>
          <target state="translated">참고 :이 규칙의 예외는 Mac OS X입니다. Mac OS X의 경우 사전 할당 된 파일을 쓰는 것이 파일 끝에 쓰는 것보다 느리기 때문에 오래된 로그 파일은 재활용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a35807ced29e56c74e24116e5fe6a78315b0f63d" translate="yes" xml:space="preserve">
          <source>Note: columnstoreBackup tool is only for ColumnStore data backups. Other engines may not be fully backed up and data could be lost when restoring.</source>
          <target state="translated">참고 : columnstoreBackup 도구는 ColumnStore 데이터 백업 전용입니다. 다른 엔진이 완전히 백업되지 않아 복원시 데이터가 손실 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b27cbb927853520021db7aceaae157ca279097ac" translate="yes" xml:space="preserve">
          <source>Note: for multi-table queries, all counter increments are &quot;billed&quot; to the first table in the query: &lt;a href=&quot;https://github.com/facebook/mysql-5.6/issues/1018&quot;&gt;https://github.com/facebook/mysql-5.6/issues/1018&lt;/a&gt;</source>
          <target state="translated">참고 : 다중 테이블 쿼리의 경우 모든 카운터 증분이 쿼리의 첫 번째 테이블에 청구됩니다 ( &lt;a href=&quot;https://github.com/facebook/mysql-5.6/issues/1018&quot;&gt;https://github.com/facebook/mysql-5.6/issues/1018).&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8b3e97f718f44a753670553bad1bb4677782ab5d" translate="yes" xml:space="preserve">
          <source>Note: the &lt;code&gt;&lt;a href=&quot;http://www.freedesktop.org/software/systemd/man/systemd.service.html&quot;&gt;systemd&lt;/a&gt;&lt;/code&gt; manual contains the official meanings for these options. The manual also lists considerably more options than the ones listed above.</source>
          <target state="translated">참고 : &lt;code&gt;&lt;a href=&quot;http://www.freedesktop.org/software/systemd/man/systemd.service.html&quot;&gt;systemd&lt;/a&gt;&lt;/code&gt; 매뉴얼은 이러한 옵션에 대한 공식적인 의미가 포함되어 있습니다. 매뉴얼에는 위에 나열된 것보다 훨씬 더 많은 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b16c10da8ce6fee418e6d6ca7d4da6aab406e431" translate="yes" xml:space="preserve">
          <source>Note: the &lt;code&gt;&lt;a href=&quot;https://www.freedesktop.org/software/systemd/man/systemd.service.html&quot;&gt;systemd&lt;/a&gt;&lt;/code&gt; manual contains the official meanings for these options. The manual also lists considerably more options than the ones listed above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db689731a2c6f7b5f4e9e49431643b223183ef3b" translate="yes" xml:space="preserve">
          <source>Note: the MEMORY and SCROLLABLE options must be specified in the OPTION _ LIST.</source>
          <target state="translated">참고 : MEMORY 및 SCROLLABLE 옵션은 OPTION _ LIST에서 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="74ecabc20494a99e253b45e43ae082ac144b165e" translate="yes" xml:space="preserve">
          <source>Note: the connection data source name (limited to 32 characters) should not be preceded by &amp;ldquo;DSN=&amp;rdquo;.</source>
          <target state="translated">참고 : 연결 데이터 소스 이름 (32 자로 제한됨) 앞에 &quot;DSN =&quot;이 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="aa1d728692fa173a87a2fc76fac29ad622e6e334" translate="yes" xml:space="preserve">
          <source>Note: the use of integer latch commands is deprecated and may be phased out in a future release. Currently, numeric values in the strings are interpreted as aliases, and use of an integer column can be optionally allowed, for the latch commands column.</source>
          <target state="translated">참고 : 정수 래치 명령 사용은 더 이상 사용되지 않으며 향후 릴리스에서 단계적으로 중단 될 수 있습니다. 현재 문자열의 숫자 값은 별명으로 해석되며 래치 명령 열에 정수 열을 사용할 수 있습니다 (선택 사항).</target>
        </trans-unit>
        <trans-unit id="988285568eddb3e2429971cf08b359220bcc8eb2" translate="yes" xml:space="preserve">
          <source>Note: the versions numbers can be different on your installation.</source>
          <target state="translated">참고 : 설치시 버전 번호가 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be4de77ce091d6248c4ceb924dee6e56aaeff9fe" translate="yes" xml:space="preserve">
          <source>Note: this last example returns an XML file whose format was not recognized by old CONNECT versions. It is here the reason of the option &amp;lsquo;Rownode=weatherdata&amp;rsquo;.</source>
          <target state="translated">참고 :이 마지막 예는 이전 CONNECT 버전에서 형식을 인식하지 못한 XML 파일을 리턴합니다. 이것이 'Rownode = weatherdata'옵션의 이유입니다.</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="e7c3241e619a668f45b6e200284763ee76e478c9" translate="yes" xml:space="preserve">
          <source>Notes (Most of these caveats will be covered later):</source>
          <target state="translated">참고 사항 (이러한 경고는 대부분 나중에 다루게됩니다) :</target>
        </trans-unit>
        <trans-unit id="5d659a8460591108bde4bc8a76877f06189652db" translate="yes" xml:space="preserve">
          <source>Notes about &quot;base_cols&quot;:</source>
          <target state="translated">&quot;base_cols&quot;에 대한 참고 사항 :</target>
        </trans-unit>
        <trans-unit id="cee269065f3c2b55aae930fd76699a3f098f1ec2" translate="yes" xml:space="preserve">
          <source>Notes about the &quot;Totals&quot;:</source>
          <target state="translated">&quot;총계&quot;에 대한 참고 사항 :</target>
        </trans-unit>
        <trans-unit id="70d38e6e55d3e393b04c0c81458b38b409643842" translate="yes" xml:space="preserve">
          <source>Notes for this Release:</source>
          <target state="translated">이 릴리스에 대한 참고 사항 :</target>
        </trans-unit>
        <trans-unit id="9235bcd68848e0c366c92d8f349d3dd80620a88d" translate="yes" xml:space="preserve">
          <source>Notes on the &lt;a href=&quot;http://mysql.rjweb.org/doc.php/ipv4.sql&quot;&gt;Reference implementation for IPv4&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://mysql.rjweb.org/doc.php/ipv4.sql&quot;&gt;IPv4&lt;/a&gt; 의 참조 구현 에 대한 참고 사항 :</target>
        </trans-unit>
        <trans-unit id="bbb118a533084924f085530f210b7d6684bfe2c7" translate="yes" xml:space="preserve">
          <source>Notes on the &lt;a href=&quot;http://mysql.rjweb.org/doc.php/ipv6.sql&quot;&gt;reference implementation for IPv6&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://mysql.rjweb.org/doc.php/ipv6.sql&quot;&gt;IPv6&lt;/a&gt; 의 참조 구현에 대한 참고 사항 :</target>
        </trans-unit>
        <trans-unit id="9743ecac54a315d18c2d3f70d409e768ed3948c9" translate="yes" xml:space="preserve">
          <source>Notes to AUTOINCREMENT:</source>
          <target state="translated">AUTOINCREMENT에 대한 참고 사항 :</target>
        </trans-unit>
        <trans-unit id="80a516438fbec76762b8d950f1eff1d86e85c6db" translate="yes" xml:space="preserve">
          <source>Notes to CHANGE COLUMN:</source>
          <target state="translated">열 변경 사항 :</target>
        </trans-unit>
        <trans-unit id="111b2f45b9f4c46f87b3cdd58e0c4218ccde3568" translate="yes" xml:space="preserve">
          <source>Notes to CREATE VIEW:</source>
          <target state="translated">보기 참고 사항 :</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="8f3643a8448174ba005451d93f4e8bb3e9bea0e2" translate="yes" xml:space="preserve">
          <source>Notes: By entering 'y', EBS Volumnes will automatically be created. If there are EBS Volumnes already created that you want to use, then enter 'n' and you will be prompted for the Volumne ID.</source>
          <target state="translated">참고 : 'y'를 입력하면 EBS Volumnes가 자동으로 생성됩니다. 사용할 EBS Volumnes가 이미 생성 된 경우 'n'을 입력하면 Volumne ID를 입력하라는 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="33b2bb40deed5b0dbd2145a5bbbaf9f9cb1f2463" translate="yes" xml:space="preserve">
          <source>Notes: By entering 'y', Instances will automatically be created. If there are Instances already created that you want to use, then enter 'n' and you will be prompted for the Instance ID.</source>
          <target state="translated">참고 : 'y'를 입력하면 인스턴스가 자동으로 생성됩니다. 사용하려는 인스턴스가 이미 생성 된 경우 'n'을 입력하면 인스턴스 ID를 입력하라는 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="d4cd8bb109d397f4769ef07c53866aaa55bc2281" translate="yes" xml:space="preserve">
          <source>Notes: Choosing internal and using softlinks to point to an externally mounted storage will allow you to use any format (i.e., ext2, ext3, etc.).</source>
          <target state="translated">참고 : 내부 마운트 및 소프트 링크를 사용하여 외부 마운트 스토리지를 선택하면 모든 형식 (예 : ext2, ext3 등)을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5a6e45dba41dc94acc55a956645321881b1e3f1" translate="yes" xml:space="preserve">
          <source>Notes: Enter 2 if you want to create a EBS storage for the MariaDB ColumnStore DBRoot Data to be stored. When using option 2, this will allow this EBS volume to be reattached to other Performance Modules during failover situations</source>
          <target state="translated">참고 : MariaDB ColumnStore DBRoot 데이터를 저장할 EBS 스토리지를 작성하려면 2를 입력하십시오. 옵션 2를 사용하면 장애 조치 상황에서이 EBS 볼륨을 다른 성능 모듈에 다시 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4a18831d241d34d59b11261e0a79411aa876aba" translate="yes" xml:space="preserve">
          <source>Notes: Enter 2 if you want to create a EBS storage for the mysql schema's to be stored.</source>
          <target state="translated">참고 : mysql 스키마를 저장하기 위해 EBS 스토리지를 작성하려면 2를 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="57e7354bf0fdc7719bf7bef4db31b4234c70511f" translate="yes" xml:space="preserve">
          <source>Notes: Hit Enter since ssh-keys are setup</source>
          <target state="translated">ssh 키가 설정되었으므로 Enter 키를 누르십시오</target>
        </trans-unit>
        <trans-unit id="a6ca5106a005bd630d10f350cea7f2ed5dc4ed5d" translate="yes" xml:space="preserve">
          <source>Notes: The default maximum for a single server is 16Gb.</source>
          <target state="translated">참고 : 단일 서버의 기본 최대 값은 16Gb입니다.</target>
        </trans-unit>
        <trans-unit id="c9f36f66e81a18e76b7a095214beaebcdff07216" translate="yes" xml:space="preserve">
          <source>Notes: You should give this system a name that will appear in various Admin utilities, etc. The name can be composed of any number of printable characters and spaces.</source>
          <target state="translated">참고 :이 시스템에는 다양한 관리 유틸리티 등에 표시 될 이름을 지정해야합니다. 이름은 인쇄 가능한 문자 및 공백으로 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8003a41bcf936117b4f1f1d4cbc3cdec4f95568c" translate="yes" xml:space="preserve">
          <source>Notice how Alaska (AK) has populations in high latitudes and Hawaii (HI) in low latitudes.</source>
          <target state="translated">알래스카 (AK)의 인구는 위도에 있고 하와이 (HI)는 위도에 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c492d474d27b3b972cef253da32a0c95a74869a" translate="yes" xml:space="preserve">
          <source>Notice in the cookbook how it says &quot;in any order&quot; in a few places. If, for example, you have both of these (in different SELECTs):</source>
          <target state="translated">요리 책에 몇 군데서 &quot;어느 순서로&quot;어떻게 쓰 였는지 주목하십시오. 예를 들어 다음과 같은 두 가지가 모두 다른 SELECT에있는 경우 :</target>
        </trans-unit>
        <trans-unit id="8d2aeec098b8672cd283711a41b831c73dbb47a5" translate="yes" xml:space="preserve">
          <source>Notice that S3 means the Cloud Object Storage API defined by Amazon AWS. Often the whole of Amazon&amp;rsquo;s Cloud Object Storage is referred to as S3. In the context of the S3 archive storage engine, it refers to the API itself that defines how to store objects in a cloud service, being it Amazon&amp;rsquo;s or someone else&amp;rsquo;s. OpenStack for example provides an S3 API for storing objects.</source>
          <target state="translated">S3은 Amazon AWS에서 정의한 Cloud Object Storage API를 의미합니다. 종종 Amazon의 Cloud Object Storage 전체를 S3라고합니다. S3 아카이브 스토리지 엔진과 관련하여 클라우드 서비스에 객체를 저장하는 방법을 정의하는 API 자체 (아마존 또는 다른 사람)를 말합니다. 예를 들어 OpenStack은 객체 저장을위한 S3 API를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="88f297aa9916f870ea219fd3743e1d77ebb2d437" translate="yes" xml:space="preserve">
          <source>Notice that as of MariaDB versions 5.5.42 and 10.0.10 the Audit Plugin is included with MariaDB and not distributed separately, so separate release notes are no longer kept.</source>
          <target state="translated">MariaDB 버전 5.5.42 및 10.0.10부터 감사 플러그인은 MariaDB에 포함되어 있으며 별도로 배포되지 않으므로 별도의 릴리스 정보가 더 이상 유지되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bfe41ddb8d108277317c80fbd82b9df6138320c2" translate="yes" xml:space="preserve">
          <source>Notice that rows 4 and 5 now contain new values.</source>
          <target state="translated">행 4와 5에는 이제 새로운 값이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="e5d3156d026ab7d559d508415f2988d226e32f44" translate="yes" xml:space="preserve">
          <source>Notice that the last value in the log entry is &lt;code&gt;1142&lt;/code&gt;. That's the error number for the query. To find failed queries, you would look for two elements: the notation indicating that it's a &lt;code&gt;QUERY&lt;/code&gt; entry, and the last value for the entry. If the query is successful, the value will be &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">로그 항목의 마지막 값은 &lt;code&gt;1142&lt;/code&gt; 입니다. 이것이 쿼리의 오류 번호입니다. 실패한 쿼리를 찾으려면 &lt;code&gt;QUERY&lt;/code&gt; 항목 임을 나타내는 표기법 과 항목의 마지막 값 이라는 두 가지 요소를 찾습니다 . 쿼리가 성공하면 값은 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6b3f49f952594fc76a393a0b93300dbd49121c84" translate="yes" xml:space="preserve">
          <source>Notice that the two &lt;code&gt;\b&lt;/code&gt; assertions checked the word boundaries but did not get into the matching pattern.</source>
          <target state="translated">두 개의 &lt;code&gt;\b&lt;/code&gt; 어설 션이 단어 경계를 확인했지만 일치하는 패턴을 얻지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="940c7db8ab579edd9f336f9275c73c13c1ead613" translate="yes" xml:space="preserve">
          <source>Notice the &quot;ENGINE&quot; and &quot;CONNECTION&quot; fields? This is where you respectively set the engine type, &quot;FEDERATED&quot; and foreign host information, this being the database your 'client' database will connect to and use as the &quot;data file&quot;. Obviously, the foreign database is running on port 9306, so you want to start up your other database so that it is indeed on port 9306, and your FederatedX database on a port other than that. In my setup, I use port 5554 for FederatedX, and port 5555 for the foreign database.</source>
          <target state="translated">&quot;ENGINE&quot;및 &quot;CONNECTION&quot;필드를 확인하십시오. 여기에서 엔진 유형, &quot;FEDERATED&quot;및 외부 호스트 정보를 각각 설정하는 위치입니다.이 정보는 '클라이언트'데이터베이스가 연결하고 &quot;데이터 파일&quot;로 사용할 데이터베이스입니다. 분명히 외부 데이터베이스가 포트 9306에서 실행 중이므로 다른 데이터베이스를 실제로 포트 9306에서 시작하고 FederatedX 데이터베이스가 아닌 다른 포트에서 시작하려고합니다. 내 설정에서는 FederatedX에 포트 5554를 사용하고 외부 데이터베이스에 포트 5555를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="cd68904301e62614e411be3274df3a7e84518397" translate="yes" xml:space="preserve">
          <source>Notice the &lt;code&gt;(?m)&lt;/code&gt; option in the beginning of the pattern, which switches to the multiline matching mode.</source>
          <target state="translated">통지 &lt;code&gt;(?m)&lt;/code&gt; 여러 줄 일치하는 모드로 전환하는 패턴의 시작 부분에있는 옵션.</target>
        </trans-unit>
        <trans-unit id="cf98d9442e6a694b54e5d2d264aa931ecc0ee1f3" translate="yes" xml:space="preserve">
          <source>Notify the server that this client is prepared to handle &lt;a href=&quot;../user-password-expiry/index&quot;&gt;expired password sandbox mode&lt;/a&gt; even if &lt;code&gt;--batch&lt;/code&gt; was specified. From &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1043-release-notes/&quot;&gt;MariaDB 10.4.3&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;--batch&lt;/code&gt; 가 지정된 경우 에도이 클라이언트가 &lt;a href=&quot;../user-password-expiry/index&quot;&gt;만료 된 비밀번호 샌드 박스 모드&lt;/a&gt; 를 처리 할 준비가되었음을 서버에 알립니다 . 에서 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1043-release-notes/&quot;&gt;MariaDB 10.4.3&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bd35acd31bbbb82c25342e456204e4d38de20857" translate="yes" xml:space="preserve">
          <source>Novice Alert! The QC is totally unrelated to the key_buffer and buffer_pool.</source>
          <target state="translated">초보자 알림! QC는 key_buffer 및 buffer_pool과 완전히 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="e9b31b1f49e4340b390f2417975896b5aebc55e8" translate="yes" xml:space="preserve">
          <source>Now RAM is broken into pagable and non pagable parts; what parts can reasonably be non pagable? In MariaDB, the &lt;a href=&quot;../xtradbinnodb-buffer-pool/index&quot;&gt;Innodb Buffer Pool&lt;/a&gt; is a perfect candidate. So, by correctly configuring these, InnoDB can run a little faster:</source>
          <target state="translated">이제 RAM은 페이징 가능하고 페이징 불가능한 부분으로 나뉩니다. 어떤 부분이 합리적으로 페이징 가능하지 않을 수 있습니까? MariaDB에서 &lt;a href=&quot;../xtradbinnodb-buffer-pool/index&quot;&gt;Innodb 버퍼 풀&lt;/a&gt; 은 완벽한 후보입니다. 따라서이를 올바르게 구성하면 InnoDB가 약간 더 빠르게 실행될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7979ed70955a02dac272a0f1641acc7fbe30cb08" translate="yes" xml:space="preserve">
          <source>Now actually run cpimport to use the job file generated by the colxml execution</source>
          <target state="translated">이제 실제로 cpimport를 실행하여 colxml 실행으로 생성 된 작업 파일을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a216bf19a76952c0feb98a3bc17876506b7a7fb4" translate="yes" xml:space="preserve">
          <source>Now add the appropriate repository. An easy way is to create a file called &lt;code&gt;mariadb-5.2-rpl.list&lt;/code&gt; in &lt;code&gt;/etc/apt/sources.list.d/&lt;/code&gt; with contents like this for Debian:</source>
          <target state="translated">이제 적절한 저장소를 추가하십시오. 쉬운 방법은 &lt;code&gt;/etc/apt/sources.list.d/&lt;/code&gt; 에 &lt;code&gt;mariadb-5.2-rpl.list&lt;/code&gt; 라는 파일 을 데비안에서 다음과 같은 내용 으로 만드는 것 입니다 .</target>
        </trans-unit>
        <trans-unit id="2d8c104c9017a17cbfe06413d594dbfe072ed3c3" translate="yes" xml:space="preserve">
          <source>Now all that is needed is to create the specially-named symlinks. On both RPM and Debian-based Linux distributions there are tools which do this for you. Consult your distribution's documentation if neither of these work for you and follow their instructions for generating the symlinks or creating them manually.</source>
          <target state="translated">이제 필요한 것은 특별히 명명 된 심볼릭 링크를 만드는 것입니다. RPM 및 Debian 기반 Linux 배포판에는이를위한 도구가 있습니다. 이들 중 어느 것도 작동하지 않으면 배포판 설명서를 참조하고 심볼릭 링크를 생성하거나 수동으로 생성하는 지침을 따르십시오.</target>
        </trans-unit>
        <trans-unit id="4fa1ee9b23c11ce61c2c11b19c9342af572769ca" translate="yes" xml:space="preserve">
          <source>Now attempt to login to verify correct setup, entering the unix password for the account david when prompted:</source>
          <target state="translated">프롬프트가 표시되면 david 계정에 대한 유닉스 비밀번호를 입력하여 올바른 설정을 확인하기 위해 로그인을 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="6a6a609a9ec7ce4aa5aa30e525d686b62f11bdf1" translate="yes" xml:space="preserve">
          <source>Now back in mcsmysql verify the data is written:</source>
          <target state="translated">이제 mcsmysql로 ​​돌아가서 데이터가 작성되었는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="841aca3e34d34533ddf85b8cc0b1f33f087ff5ef" translate="yes" xml:space="preserve">
          <source>Now compile and run the program. For RHEL / CentOS 7 (library installed in /usr/lib64):</source>
          <target state="translated">이제 프로그램을 컴파일하고 실행하십시오. RHEL / CentOS 7 (/ usr / lib64에 설치된 라이브러리) :</target>
        </trans-unit>
        <trans-unit id="0e5278841419f848e78b2dfbff4242ec41c15aee" translate="yes" xml:space="preserve">
          <source>Now connection 1 ends the transaction:</source>
          <target state="translated">이제 연결 1이 트랜잭션을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="4bd257196d91c2f8d243bc7d830e146e50c2db8d" translate="yes" xml:space="preserve">
          <source>Now for the gory details.</source>
          <target state="translated">이제 까다로운 세부 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ab2eea3da43f1ebf47d2d3e6d48e734c541f933" translate="yes" xml:space="preserve">
          <source>Now for the problem.</source>
          <target state="translated">이제 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7568bd5642cd3fdfeb8dbaca3d09e47ed6056926" translate="yes" xml:space="preserve">
          <source>Now if you send the query:</source>
          <target state="translated">이제 쿼리를 보내면 :</target>
        </trans-unit>
        <trans-unit id="cb250be516946cf087391586421b5fc728911937" translate="yes" xml:space="preserve">
          <source>Now imagine getting to your personal address book and finding it has twice the number of entries as the phone book. Your search would be slower. The same process applies to the query optimizer, so having access to up-to-date and accurate statistics is critical.</source>
          <target state="translated">이제 개인 주소록을 찾아 전화 번호부보다 2 배 많은 항목이 있다고 가정 해보십시오. 검색 속도가 느려집니다. 쿼리 최적화 프로그램에도 동일한 프로세스가 적용되므로 최신의 정확한 통계에 액세스하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="289c3ca3a89ab41af391e5e764cb932b3a03f358" translate="yes" xml:space="preserve">
          <source>Now imagine, that both 5.1 and 5.2 are installed on the same machine and we want to upgrade the database instance running on 5.1 to the new version. In this case special tools are requied. Traditionally, &lt;code&gt;&lt;a href=&quot;../mysql_upgrade/index&quot;&gt;mysql_upgrade&lt;/a&gt;&lt;/code&gt; is used to accomplish this. On Windows, the &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.5/en/windows-upgrading.html&quot;&gt;MySQL upgrade&lt;/a&gt; is a complicated multiple-step manual process.</source>
          <target state="translated">이제 5.1과 5.2가 동일한 머신에 설치되어 있고 5.1에서 실행중인 데이터베이스 인스턴스를 새 버전으로 업그레이드하려고합니다. 이 경우 특수 도구가 필요합니다. 전통적으로 &lt;code&gt;&lt;a href=&quot;../mysql_upgrade/index&quot;&gt;mysql_upgrade&lt;/a&gt;&lt;/code&gt; 는이를 위해 사용됩니다. Windows에서 &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.5/en/windows-upgrading.html&quot;&gt;MySQL 업그레이드&lt;/a&gt; 는 복잡한 여러 단계의 수동 프로세스입니다.</target>
        </trans-unit>
        <trans-unit id="e1f33d0f174c2f3cdfe56d6ce666f7c857ee0d6c" translate="yes" xml:space="preserve">
          <source>Now imagine, that both 5.1 and 5.2 are installed on the same machine and we want to upgrade the database instance running on 5.1 to the new version. In this case special tools are requied. Traditionally, &lt;code&gt;&lt;a href=&quot;../mysql_upgrade/index&quot;&gt;mysql_upgrade&lt;/a&gt;&lt;/code&gt; is used to accomplish this. On Windows, the &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.5/en/windows-upgrading.html&quot;&gt;MySQL upgrade&lt;/a&gt; is a complicated multiple-step manual process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8e93b11764b2bd6c73f7fffe89b2e25f65821b3" translate="yes" xml:space="preserve">
          <source>Now it is possible to populate it by:</source>
          <target state="translated">이제 다음을 통해 채울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb3212a5b68f08f1853ebf7a112715ac510bce8f" translate="yes" xml:space="preserve">
          <source>Now let us see what happens with not null columns:</source>
          <target state="translated">이제 null이 아닌 열에 어떤 일이 발생하는지 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="474fbab0c30c49529008bb016bf012bb278715ef" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s run the ldif file with &lt;code&gt;&lt;a href=&quot;http://www.openldap.org/software/man.cgi?query=ldapmodify&amp;amp;sektion=1&amp;amp;apropos=0&amp;amp;manpath=OpenLDAP+2.4-Release&quot;&gt;ldapmodify&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">이제 &lt;code&gt;&lt;a href=&quot;http://www.openldap.org/software/man.cgi?query=ldapmodify&amp;amp;sektion=1&amp;amp;apropos=0&amp;amp;manpath=OpenLDAP+2.4-Release&quot;&gt;ldapmodify&lt;/a&gt;&lt;/code&gt; 로 ldif 파일을 실행 해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="264bf0603356f0a8b1f4883bfda6ae0af63f797a" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s run the ldif file with &lt;code&gt;&lt;a href=&quot;https://www.openldap.org/software/man.cgi?query=ldapmodify&amp;amp;sektion=1&amp;amp;apropos=0&amp;amp;manpath=OpenLDAP+2.4-Release&quot;&gt;ldapmodify&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0304e7a736d92f4ee0bd5c98a12ef74304dd9220" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s use our new directory manager user and run the &lt;code&gt;&lt;a href=&quot;https://www.digitalocean.com/community/tutorials/how-to-use-ldif-files-to-make-changes-to-an-openldap-system&quot;&gt;LDIF&lt;/a&gt;&lt;/code&gt; file with &lt;code&gt;&lt;a href=&quot;http://www.openldap.org/software/man.cgi?query=ldapmodify&amp;amp;sektion=1&amp;amp;apropos=0&amp;amp;manpath=OpenLDAP+2.4-Release&quot;&gt;ldapmodify&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">이제 새로운 디렉토리 관리자 사용자를 사용하고 &lt;code&gt;&lt;a href=&quot;http://www.openldap.org/software/man.cgi?query=ldapmodify&amp;amp;sektion=1&amp;amp;apropos=0&amp;amp;manpath=OpenLDAP+2.4-Release&quot;&gt;ldapmodify&lt;/a&gt;&lt;/code&gt; 로 &lt;code&gt;&lt;a href=&quot;https://www.digitalocean.com/community/tutorials/how-to-use-ldif-files-to-make-changes-to-an-openldap-system&quot;&gt;LDIF&lt;/a&gt;&lt;/code&gt; 파일을 실행 해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="3cad8998edc5d5d88f27dda1f1c4056a26fc123d" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s use our new directory manager user and run the &lt;code&gt;&lt;a href=&quot;https://www.digitalocean.com/community/tutorials/how-to-use-ldif-files-to-make-changes-to-an-openldap-system&quot;&gt;LDIF&lt;/a&gt;&lt;/code&gt; file with &lt;code&gt;&lt;a href=&quot;https://www.openldap.org/software/man.cgi?query=ldapmodify&amp;amp;sektion=1&amp;amp;apropos=0&amp;amp;manpath=OpenLDAP+2.4-Release&quot;&gt;ldapmodify&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bc4cc310d7b0fff70a2be6dff4b5ec628d5096a" translate="yes" xml:space="preserve">
          <source>Now let's look at some edge cases, and argue that the number of blocks is still better (usually) than with traditional indexing techniques.</source>
          <target state="translated">이제 몇 가지 중요한 경우를 살펴보고 기존 인덱싱 기술보다 블록 수가 여전히 더 낫다고 주장합니다.</target>
        </trans-unit>
        <trans-unit id="3d86fd1e3f851afceead35ccd175c901192c7c9e" translate="yes" xml:space="preserve">
          <source>Now place the MariaDB Columnstore binary tar file in your home directory on the host you will be using as PM1. Untar the binary distribution package to the /home/guest directory: tar -xf mariadb-columnstore-release#.x86_64.bin.tar.gz</source>
          <target state="translated">이제 MariaDB Columnstore 바이너리 tar 파일을 PM1으로 사용할 호스트의 홈 디렉토리에 배치하십시오. 바이너리 배포 패키지를 / home / guest 디렉토리에 untar하십시오. tar -xf mariadb-columnstore-release # .x86_64.bin.tar.gz</target>
        </trans-unit>
        <trans-unit id="0e7b57699bc33320d10e5cae329a9bffbb95daa3" translate="yes" xml:space="preserve">
          <source>Now place the MariaDB Columnstore binary tar file in your home directory on the host you will be using as PM1. Untar the binary distribution package to the /home/mysql directory: tar -xf mariadb-columnstore-release#.x86_64.bin.tar.gz</source>
          <target state="translated">이제 MariaDB Columnstore 바이너리 tar 파일을 PM1으로 사용할 호스트의 홈 디렉토리에 배치하십시오. 바이너리 배포 패키지를 / home / mysql 디렉토리에 untar하십시오. tar -xf mariadb-columnstore-release # .x86_64.bin.tar.gz</target>
        </trans-unit>
        <trans-unit id="52c1ebb8a03e469b574c4289d9e66e8fee2dc862" translate="yes" xml:space="preserve">
          <source>Now replace it with,</source>
          <target state="translated">이제 그것을</target>
        </trans-unit>
        <trans-unit id="3b31d35ed4d3a5e540f3f1360b097769a4991e28" translate="yes" xml:space="preserve">
          <source>Now replace the data&amp;lt;N&amp;gt; directories with the backup on each PM as appropriate for each directory:</source>
          <target state="translated">이제 data &amp;lt;N&amp;gt; 디렉토리를 각 디렉토리에 적합한 각 PM의 백업으로 바꾸십시오.</target>
        </trans-unit>
        <trans-unit id="78902c32b9f5a6f8f95a9ab512a5c6c9134f56ee" translate="yes" xml:space="preserve">
          <source>Now replace the data&amp;lt;N&amp;gt; directories with the backup on pm1 as appropriate for each directory:</source>
          <target state="translated">이제 각 디렉토리에 대해 data &amp;lt;N&amp;gt; 디렉토리를 pm1의 백업으로 바꾸십시오.</target>
        </trans-unit>
        <trans-unit id="bf8eda850825f83e55570282862d7944e49ad82a" translate="yes" xml:space="preserve">
          <source>Now restart columnstore since the user group permissions of mysql have changed and need to be picked up by the mysqld process:</source>
          <target state="translated">이제 mysql의 사용자 그룹 권한이 변경되어 mysqld 프로세스에서 선택해야하므로 columnstore를 다시 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="b502363c9d43a3258b18dcc28321bf168995d38c" translate="yes" xml:space="preserve">
          <source>Now run</source>
          <target state="translated">이제 실행</target>
        </trans-unit>
        <trans-unit id="a5b329ac8d15e7b58859e154db55305232725911" translate="yes" xml:space="preserve">
          <source>Now run the commands to get User Module #1 as the Master. This is assuming User Module #2 is the current the Master:</source>
          <target state="translated">이제 명령을 실행하여 사용자 모듈 # 1을 마스터로 가져옵니다. 이것은 사용자 모듈 # 2가 현재 마스터라고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="711436f2f5dac27a149545e0d0eae4889a8e68ef" translate="yes" xml:space="preserve">
          <source>Now saying:</source>
          <target state="translated">이제 말 :</target>
        </trans-unit>
        <trans-unit id="6d854f6dfd384a9cb01df0270b3932ebd0b78226" translate="yes" xml:space="preserve">
          <source>Now some pages have been freed, and some merged:</source>
          <target state="translated">이제 일부 페이지가 비워졌고 일부는 병합되었습니다.</target>
        </trans-unit>
        <trans-unit id="d036fd420dc4d74b80f00dde0e9c11b9e0120997" translate="yes" xml:space="preserve">
          <source>Now start the slave with the &lt;a href=&quot;../start-slave/index&quot;&gt;&lt;code&gt;START SLAVE&lt;/code&gt;&lt;/a&gt; command:</source>
          <target state="translated">이제 &lt;a href=&quot;../start-slave/index&quot;&gt; &lt;code&gt;START SLAVE&lt;/code&gt; &lt;/a&gt; 명령으로 슬레이브를 시작하십시오 :</target>
        </trans-unit>
        <trans-unit id="ac1e236736857ef70fae77a272e6a80f77bb1544" translate="yes" xml:space="preserve">
          <source>Now test the following query :</source>
          <target state="translated">이제 다음 쿼리를 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="df423c4c503723fac13a8c5988494cc3d77f574e" translate="yes" xml:space="preserve">
          <source>Now that the MariaDB Server is up, ensure that it does not start accepting writes yet if you want to set up &lt;a href=&quot;../replication-overview/index#ring-replication&quot;&gt;circular replication&lt;/a&gt; between the cluster and the MariaDB Server.</source>
          <target state="translated">이제 MariaDB 서버가 가동 되었으므로 클러스터와 MariaDB 서버간에 &lt;a href=&quot;../replication-overview/index#ring-replication&quot;&gt;순환 복제&lt;/a&gt; 를 설정하려는 경우 아직 쓰기 수락을 시작하지 않아야합니다 .</target>
        </trans-unit>
        <trans-unit id="ff4eec2c09766e495dd2979a5e104f499670d6d8" translate="yes" xml:space="preserve">
          <source>Now that the backup has been restored to the MariaDB Server slave, you can &lt;a href=&quot;../starting-and-stopping-mariadb-starting-and-stopping-mariadb/index&quot;&gt;start the MariaDB Server process&lt;/a&gt;.</source>
          <target state="translated">이제 백업이 MariaDB 서버 슬레이브로 복원되었으므로 &lt;a href=&quot;../starting-and-stopping-mariadb-starting-and-stopping-mariadb/index&quot;&gt;MariaDB 서버 프로세스를 시작할&lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="811a88b81bb4eefdff4e154f675b27b30f4c1305" translate="yes" xml:space="preserve">
          <source>Now that the backup has been restored to the second cluster's slave, you can start the server by &lt;a href=&quot;../getting-started-with-mariadb-galera-cluster/index#bootstrapping-a-new-cluster&quot;&gt;bootstrapping&lt;/a&gt; the node.</source>
          <target state="translated">백업이 두 번째 클러스터의 슬레이브로 복원되었으므로 노드 를 &lt;a href=&quot;../getting-started-with-mariadb-galera-cluster/index#bootstrapping-a-new-cluster&quot;&gt;부트 스트랩&lt;/a&gt; 하여 서버를 시작할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c24f859968d2695984f214436b77c658fa3544b0" translate="yes" xml:space="preserve">
          <source>Now that the second cluster is up, ensure that it does not start accepting writes yet if you want to set up &lt;a href=&quot;../replication-overview/index#ring-replication&quot;&gt;circular replication&lt;/a&gt; between the two clusters.</source>
          <target state="translated">두 번째 클러스터가 작동되었으므로 두 클러스터간에 &lt;a href=&quot;../replication-overview/index#ring-replication&quot;&gt;순환 복제&lt;/a&gt; 를 설정하려는 경우 아직 쓰기를 수락하지 않아야 합니다.</target>
        </trans-unit>
        <trans-unit id="9f1b76ad92d549de37a9f87a539693f621dc672e" translate="yes" xml:space="preserve">
          <source>Now that we have a cleanly structured database to work with, let us begin this tutorial by stepping up one notch from the last tutorial and filtering our information a little.</source>
          <target state="translated">작업하기 위해 정리 된 데이터베이스를 만들었으므로 이제는 마지막 자습서에서 한 단계를 밟고 정보를 약간 필터링하여이 자습서를 시작하겠습니다.</target>
        </trans-unit>
        <trans-unit id="95cd6a4d57e97d5a59d326b9a8780fc84e582e8d" translate="yes" xml:space="preserve">
          <source>Now the JDBC table can be created by:</source>
          <target state="translated">이제 다음을 통해 JDBC 테이블을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0874e47da980d46cc852421141a51159df45612a" translate="yes" xml:space="preserve">
          <source>Now the added book, in the XML file, will have the required structure:</source>
          <target state="translated">이제 XML 파일에 추가 된 책은 필요한 구조를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="720fef41e6abe3993e646fb8dc969e53be611f61" translate="yes" xml:space="preserve">
          <source>Now the engine can compare the table definition version that the server is using (from any handler method it can be accessed as &lt;code&gt;this-&amp;gt;table-&amp;gt;s-&amp;gt;tabledef_version&lt;/code&gt;) with the version of the actual table definition. If they differ &amp;mdash; it is &lt;code&gt;HA_ERR_TABLE_DEF_CHANGED&lt;/code&gt;.</source>
          <target state="translated">이제 엔진은 서버가 사용하고있는 테이블 정의 버전 (이 핸들러 &lt;code&gt;this-&amp;gt;table-&amp;gt;s-&amp;gt;tabledef_version&lt;/code&gt; 에서 this-&amp;gt; table-&amp;gt; s-&amp;gt; tabledef_version 로 액세스 할 수 있음 )을 실제 테이블 정의 버전과 비교할 수 있습니다 . 서로 다른 경우 &amp;mdash; &lt;code&gt;HA_ERR_TABLE_DEF_CHANGED&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="28b6bcaf72ec6b2b2915d420d1a98d65ae16eb5b" translate="yes" xml:space="preserve">
          <source>Now the helpers are built and you can cross-compile:</source>
          <target state="translated">이제 도우미가 만들어지고 크로스 컴파일 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="793cedc66ad270d274d3e6d98e9bf1002ee44acb" translate="yes" xml:space="preserve">
          <source>Now the query can take good advantage of two different indexes. Note: &quot;Index merge&quot; might kick in on the original query, but it is not necessarily any faster than the UNION. Sister blog on compound indexes, including 'Index Merge'</source>
          <target state="translated">이제 쿼리는 서로 다른 두 인덱스를 활용할 수 있습니다. 참고 : &quot;인덱스 병합&quot;은 원래 쿼리에서 시작될 수 있지만 반드시 UNION보다 빠를 필요는 없습니다. '색인 병합'을 포함한 복합 색인에 대한 자매 블로그</target>
        </trans-unit>
        <trans-unit id="718a7ca1660bb3ffadfe5bd8184af8e999402677" translate="yes" xml:space="preserve">
          <source>Now the query:</source>
          <target state="translated">이제 쿼리 :</target>
        </trans-unit>
        <trans-unit id="977654634c61fb5c07ae60c1eeaa65baf1bfe1a6" translate="yes" xml:space="preserve">
          <source>Now the read-only &lt;a href=&quot;../oqgraph/index&quot;&gt;OQGRAPH&lt;/a&gt; table is created.</source>
          <target state="translated">이제 읽기 전용 &lt;a href=&quot;../oqgraph/index&quot;&gt;OQGRAPH&lt;/a&gt; 테이블이 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="71cb03df3e2523cc6bcf87720ec6fdaa0e26f0e3" translate="yes" xml:space="preserve">
          <source>Now the read-only OQGRAPH table is created. The CREATE statement must match the format below - any difference will result in an error.</source>
          <target state="translated">이제 읽기 전용 OQGRAPH 테이블이 작성되었습니다. CREATE 문은 아래 형식과 일치해야합니다. 차이가 있으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="06676b6db268ed5cfb01f2e40aa0e14d45ecb2c0" translate="yes" xml:space="preserve">
          <source>Now the statement:</source>
          <target state="translated">이제 진술 :</target>
        </trans-unit>
        <trans-unit id="98ecc946bfaf32acad0702cb4991cbc506262319" translate="yes" xml:space="preserve">
          <source>Now to define a table that will give us all the previous information, we must specify the column type for each column. Because in the next statement the column type defaults to Node, the &lt;em&gt;field_format&lt;/em&gt; column parameter was used to indicate which columns are attributes:</source>
          <target state="translated">이전의 모든 정보를 제공 할 테이블을 정의하려면 각 열의 열 유형을 지정해야합니다. 다음 명령문에서 열 유형의 기본값은 Node이므로 &lt;em&gt;field_format&lt;/em&gt; 열 매개 변수는 어떤 열이 속성인지 표시하는 데 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="e7a91bd1a33d821f9b2d3ac2fc556acd56b5f759" translate="yes" xml:space="preserve">
          <source>Now verify that these connections can be used from the spider node (here 172.21.21.3 = backend1 and 172.21.21.4 = backend2):</source>
          <target state="translated">이제 스파이더 노드에서이 연결을 사용할 수 있는지 확인하십시오 (여기서는 172.21.21.3 = backend1 및 172.21.21.4 = backend2).</target>
        </trans-unit>
        <trans-unit id="539a2f901d5d175a17846ae8e997e40f30eeb1a9" translate="yes" xml:space="preserve">
          <source>Now we are ready to &lt;a href=&quot;../getting-installing-and-upgrading-mariadb/index&quot;&gt;install MariaDB&lt;/a&gt; in the way we prefer.</source>
          <target state="translated">이제 원하는 방식으로 &lt;a href=&quot;../getting-installing-and-upgrading-mariadb/index&quot;&gt;MariaDB&lt;/a&gt; 를 설치할 준비가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="2dd9236ff548ff02b7f07ac94b7bfb9a1be3cfa3" translate="yes" xml:space="preserve">
          <source>Now we can create a standard ODBC table on the newly created table:</source>
          <target state="translated">이제 새로 작성된 테이블에 표준 ODBC 테이블을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e082d1196147ae0b3ff86c5b1faa0cb14e82fb7" translate="yes" xml:space="preserve">
          <source>Now we can see how adding an author to the JSAMPLE2 table can alternatively be done:</source>
          <target state="translated">이제 JSAMPLE2 테이블에 작성자를 추가하는 방법을 대안으로 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="438fc381dc49683763518095475618f88b1fa4bb" translate="yes" xml:space="preserve">
          <source>Now we can see how to delete the second author from the JSAMPLE2 table:</source>
          <target state="translated">이제 JSAMPLE2 테이블에서 두 번째 저자를 삭제하는 방법을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdd1f98fba51ed467bce9d8b71e1176bdea2695e" translate="yes" xml:space="preserve">
          <source>Now we can use normal Linux commands like &lt;em&gt;cd&lt;/em&gt;, &lt;em&gt;ls&lt;/em&gt;, etc. We will have root privileges. We can even install our favorite file editor, for example:</source>
          <target state="translated">이제 &lt;em&gt;cd&lt;/em&gt; , &lt;em&gt;ls&lt;/em&gt; 등과 같은 일반적인 Linux 명령을 사용할 수 있습니다 . 루트 권한이 있습니다. 좋아하는 파일 편집기를 설치할 수도 있습니다 :</target>
        </trans-unit>
        <trans-unit id="bbe8be3afaa812144418b220719818d4896466ce" translate="yes" xml:space="preserve">
          <source>Now we connect to it using &quot;mysql.exe&quot;, which uses the DOS character set (cp850 on a West European machine), and want to fetch all records that are equal to '&amp;ouml;' according to the German phonebook rules.</source>
          <target state="translated">이제 DOS 문자 세트 (서유럽 어 시스템의 경우 cp850)를 사용하는 &quot;mysql.exe&quot;를 사용하여 독일 전화 번호부 규칙에 따라 '&amp;ouml;'와 동일한 모든 레코드를 가져 오려고합니다.</target>
        </trans-unit>
        <trans-unit id="dab47b04a8e06ed6c95072b11e9b25e2f2abd66e" translate="yes" xml:space="preserve">
          <source>Now we have a number that increases nicely over time. Multiple sources won't be quite in time order, but they will be close. The &quot;hot&quot; spot for inserting into an INDEX(uuid) will be rather narrow, thereby making it quite cacheable and efficient.</source>
          <target state="translated">이제 시간이 지남에 따라 멋지게 증가하는 숫자가 있습니다. 여러 소스는 시간 순서가 좋지는 않지만 가깝습니다. INDEX (uuid)에 삽입하기위한 &quot;핫&quot;지점은 다소 좁아서 캐시 가능하고 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="cda1de485a7c5dc8cc28708c6a01e2152f9aeefa" translate="yes" xml:space="preserve">
          <source>Now we have started to implement the newer 06-104r4 standard.</source>
          <target state="translated">이제 최신 06-104r4 표준을 구현하기 시작했습니다.</target>
        </trans-unit>
        <trans-unit id="0b0eb46be68e927051e924600fb304d355c5ceee" translate="yes" xml:space="preserve">
          <source>Now we want to create the table to access the CUSTOMERS table. Because CONNECT can retrieve the column description of ODBC tables, it not necessary to specify them in the create table statement:</source>
          <target state="translated">이제 CUSTOMERS 테이블에 액세스 할 테이블을 작성하려고합니다. CONNECT는 ODBC 테이블의 열 설명을 검색 할 수 있으므로 테이블 작성 명령문에서이를 지정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="7493777f988affd3ca6d9f81ef66d2dd705346f5" translate="yes" xml:space="preserve">
          <source>Now whenever you run a backup with the &lt;code&gt;&lt;a href=&quot;#-compress&quot;&gt;--compress&lt;/a&gt;&lt;/code&gt; option, it always performs the compression using 12 threads and 64K chunks.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#-compress&quot;&gt;--compress&lt;/a&gt;&lt;/code&gt; 옵션을 사용하여 백업을 실행할 때마다 항상 12 개의 스레드와 64K 청크를 사용하여 압축을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="2b0f48d6400d7d57dd4e6e5dc700c6a610aac822" translate="yes" xml:space="preserve">
          <source>Now you are ready to use the system.</source>
          <target state="translated">이제 시스템을 사용할 준비가되었습니다.</target>
        </trans-unit>
        <trans-unit id="bd9eeac761151d7426c33d3dc72ea0925fc6ce07" translate="yes" xml:space="preserve">
          <source>Now you can calculate a password hash by executing:</source>
          <target state="translated">이제 다음을 실행하여 비밀번호 해시를 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11b9373a071e3949d36d382ee27a5d2f145b4c0c" translate="yes" xml:space="preserve">
          <source>Now you can change the user account's password using the new password hash.</source>
          <target state="translated">이제 새로운 비밀번호 해시를 사용하여 사용자 계정의 비밀번호를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76cd276eff1e0f3af7bc499976868469e867d913" translate="yes" xml:space="preserve">
          <source>Now you can create an Oracle table with something like this:</source>
          <target state="translated">이제 다음과 같이 Oracle 테이블을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89b2885b6645c404ed4ebd73766bbee7bc59e2c1" translate="yes" xml:space="preserve">
          <source>Now you can create the CUSTOMERS table as:</source>
          <target state="translated">이제 CUSTOMERS 테이블을 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e91048d1dd74da1e8e36a53d9b3660803e1020fe" translate="yes" xml:space="preserve">
          <source>Now you can retrieve the desired result by:</source>
          <target state="translated">이제 다음을 통해 원하는 결과를 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="898f9c10871f22410a4e667168a6d4a51da18a03" translate="yes" xml:space="preserve">
          <source>Now you can run both console commands for a non-root user account: 'mcsmysql' and 'mcsadmin'</source>
          <target state="translated">이제 루트가 아닌 사용자 계정 인 'mcsmysql'및 'mcsadmin'에 대해 두 콘솔 명령을 모두 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0ab983d4d2930d9f3ffac7c2f9d607b70e27022" translate="yes" xml:space="preserve">
          <source>Now you can send commands like this:</source>
          <target state="translated">이제 다음과 같은 명령을 보낼 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="b253f18bfb4744ab577e1e7dceb7c79c1021b206" translate="yes" xml:space="preserve">
          <source>Now you can start MariaDB by</source>
          <target state="translated">이제 다음을 통해 MariaDB를 시작할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="ec5712346e0c6c4b576df9acf2764a1eeb4e9f32" translate="yes" xml:space="preserve">
          <source>Now you can start mysqld in the debugger:</source>
          <target state="translated">이제 디버거에서 mysqld를 시작할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="4b0b8f16038728e720d0eb2d323d86371102e19c" translate="yes" xml:space="preserve">
          <source>Now you can test the configuration:</source>
          <target state="translated">이제 구성을 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b7dfa32f36fbecbdf18e404cdc83c24f39a9b3e" translate="yes" xml:space="preserve">
          <source>Now you can upgrade the new master to a newer version of MariaDB and then follow the same procedure to connect it as a slave.</source>
          <target state="translated">이제 새 마스터를 최신 버전의 MariaDB로 업그레이드 한 다음 동일한 절차에 따라 슬레이브로 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c8dc0f4b1fa267fa611a11c2d45825a7e659e38" translate="yes" xml:space="preserve">
          <source>Now you can use &lt;em&gt;custfix&lt;/em&gt; for fast database operations on the copied &lt;em&gt;customer&lt;/em&gt; table data.</source>
          <target state="translated">이제 &lt;em&gt;custfix&lt;/em&gt; 를 사용할 수 있습니다&lt;em&gt;&lt;/em&gt; 복사 된 &lt;em&gt;고객&lt;/em&gt; 테이블 데이터 에서 빠른 데이터베이스 조작을 를 .</target>
        </trans-unit>
        <trans-unit id="6b538fe2205517823e9bb74ebe254f680f3fc698" translate="yes" xml:space="preserve">
          <source>Now you can use it to create the user account using the new password hash.</source>
          <target state="translated">이제 새 비밀번호 해시를 사용하여 사용자 계정을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8cc266edc9e7ea020e1ad49e2e0d37527b585a8" translate="yes" xml:space="preserve">
          <source>Now you can use the &lt;a href=&quot;../aria_s3_copy/index&quot;&gt;aria_s3_copy&lt;/a&gt; tool to copy this to S3 from your shell/the command line:</source>
          <target state="translated">이제는 &lt;a href=&quot;../aria_s3_copy/index&quot;&gt; aria_s3_copy&lt;/a&gt; 도구를 하여 쉘 / 명령 줄에서 S3으로 복사 .</target>
        </trans-unit>
        <trans-unit id="50b36a3d08c758876e38ed3eb35845d9b8eadb40" translate="yes" xml:space="preserve">
          <source>Now you need prevent any changes to the data while you view the binary log position. You'll use this to tell the slave at exactly which point it should start replicating from.</source>
          <target state="translated">이제 이진 로그 위치를 보는 동안 데이터가 변경되지 않도록해야합니다. 이것을 사용하여 슬레이브가 정확히 어느 지점에서 복제를 시작해야하는지 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="fbab0583f98df90b3ed6d70f974a58e29a88b46d" translate="yes" xml:space="preserve">
          <source>Now, a 'last' SELECT is performed to get the exact distances, sort them (ORDER BY) and LIMIT to the desired number.</source>
          <target state="translated">이제 정확한 거리를 얻기 위해 '마지막'SELECT가 수행되어 거리를 정렬하고 (ORDER BY) 원하는 수로 제한합니다.</target>
        </trans-unit>
        <trans-unit id="7bb4e52b2daf3259ca39d95fad656a1ea2572f17" translate="yes" xml:space="preserve">
          <source>Now, add an MFA device for your user. You'll need to have a hardware MFA device or an application such as Google Authenticator installed on your smartphone.</source>
          <target state="translated">이제 사용자의 MFA 장치를 추가하십시오. 스마트 폰에 하드웨어 MFA 장치 또는 Google OTP와 같은 응용 프로그램이 설치되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="60f72b8ef4ab24260cd374830ad5c4367670bd80" translate="yes" xml:space="preserve">
          <source>Now, configure CloudWatch and create an Event Rule.</source>
          <target state="translated">이제 CloudWatch를 구성하고 이벤트 규칙을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="25f15d2fb8a69b7209c734eebfef632614088386" translate="yes" xml:space="preserve">
          <source>Now, give the new user permission to perform API operations on your key.</source>
          <target state="translated">이제 새 사용자에게 키에서 API 작업을 수행 할 수있는 권한을 부여하십시오.</target>
        </trans-unit>
        <trans-unit id="d623402a0d13fd10738c41ad5385e71faf34da3b" translate="yes" xml:space="preserve">
          <source>Now, having created the &lt;code&gt;oq_graph&lt;/code&gt; table linked to a backing table, it is now possible to query the &lt;code&gt;oq_graph&lt;/code&gt; table directly. The &lt;code&gt;weight&lt;/code&gt; field, since it was not specified in this example, defaults to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">이제 백업 테이블에 링크 된 &lt;code&gt;oq_graph&lt;/code&gt; 테이블 을 작성 &lt;code&gt;oq_graph&lt;/code&gt; 테이블을 직접 조회 할 수 있습니다. &lt;code&gt;weight&lt;/code&gt; 필드가이 예제에 지정되지 이후, 기본값은 &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="560121f5a6ffcd0231a9fa445dee9a32b1adefe7" translate="yes" xml:space="preserve">
          <source>Now, if we insert a record into the &lt;code&gt;animals&lt;/code&gt; table, the trigger will run, incrementing the animal_count table;</source>
          <target state="translated">이제 &lt;code&gt;animals&lt;/code&gt; 테이블에 레코드를 삽입 하면 트리거가 실행되어 animal_count 테이블이 증가합니다.</target>
        </trans-unit>
        <trans-unit id="af859825183275d16426326d38aa175148f24cc2" translate="yes" xml:space="preserve">
          <source>Now, if we run a query on this view, as follows:</source>
          <target state="translated">이제이 뷰에서 쿼리를 실행하면 다음과 같이됩니다.</target>
        </trans-unit>
        <trans-unit id="c0f5f3ab87a58d7fe0ec982a99f4419b4a08c7c9" translate="yes" xml:space="preserve">
          <source>Now, if we try to insert a book with a non-existing author, we will get an error:</source>
          <target state="translated">이제 존재하지 않는 저자가있는 책을 삽입하려고하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="19c7eda5391c142f3f43bf365e4a33c6d8e2e26c" translate="yes" xml:space="preserve">
          <source>Now, let's check if it can be seen in Cassandra:</source>
          <target state="translated">이제 Cassandra에서 볼 수 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="9eefd16f754240362763bb0120cb538c3670eae8" translate="yes" xml:space="preserve">
          <source>Now, let's delete the second author. When we created the foreign key, we specified &lt;code&gt;ON DELETE CASCADE&lt;/code&gt;. This should propagate the deletion, and make the deleted author's books disappear:</source>
          <target state="translated">이제 두 번째 저자를 삭제하겠습니다. 외래 키를 만들 때 &lt;code&gt;ON DELETE CASCADE&lt;/code&gt; 를 지정했습니다 . 이렇게하면 삭제가 전파되고 삭제 된 저자의 책이 사라집니다.</target>
        </trans-unit>
        <trans-unit id="657747812eb341b939de82d93d1f53e375c846e0" translate="yes" xml:space="preserve">
          <source>Now, let's discuss the 'last' SELECT, wherein the square is expanded by SQRT(2) and it uses the Great Circle formula to precisely order the N results. The SQRT(2) is in case that the N items were all at the corners of the 'square'. Growing the square by this much allows us to catch any other sites that were just outside the old square.</source>
          <target state="translated">이제 SQRT (2)에 의해 사각형이 확장되고 Great Circle 수식을 사용하여 N 결과를 정확하게 정렬하는 '마지막'SELECT에 대해 설명하겠습니다. SQRT (2)는 N 항목이 모두 '사각형'모퉁이에있는 경우입니다. 이만큼 광장을 성장 시키면 우리는 오래된 광장 밖에 있던 다른 사이트를 잡을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3787f2d8e72fb0c79fca41664f65c5e835c39ac0" translate="yes" xml:space="preserve">
          <source>Now, let's try to connect an SQL table to it:</source>
          <target state="translated">이제 SQL 테이블을 연결해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="bff5c3a80ff4d1083c0466913199148d18a6aace" translate="yes" xml:space="preserve">
          <source>Now, let's try to properly insert two authors and their books:</source>
          <target state="translated">이제 두 명의 저자와 그 책을 올바르게 삽입 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="77fd172218c27ccafc82a77cd6867ed5712e4906" translate="yes" xml:space="preserve">
          <source>Now, remove files associated with the MariaDB Server package:</source>
          <target state="translated">이제 MariaDB 서버 패키지와 관련된 파일을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="1b9c6173ba5a2496b2af53066ccd0620fb90a638" translate="yes" xml:space="preserve">
          <source>Now, set up an SNS topic to facilitate email notifications.</source>
          <target state="translated">이제 이메일 알림을 용이하게하기 위해 SNS 주제를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="1bb69c9efabe0e75aa4b445020ecbdfdac72cc78" translate="yes" xml:space="preserve">
          <source>Now, set up the wrapper program.</source>
          <target state="translated">이제 랩퍼 프로그램을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="63ebf04783d46377cdaa12f1db6e7f07892dddac" translate="yes" xml:space="preserve">
          <source>Now, start the &lt;code&gt;mxs_adapter&lt;/code&gt; utility designating this file with the &lt;code&gt;-f&lt;/code&gt; option for this file:</source>
          <target state="translated">이제이 파일에 대해 &lt;code&gt;-f&lt;/code&gt; 옵션을 사용하여이 파일을 지정 하는 &lt;code&gt;mxs_adapter&lt;/code&gt; 유틸리티를 시작 하십시오.</target>
        </trans-unit>
        <trans-unit id="b0cbbe318915c2550f38f706f33e09d553d33790" translate="yes" xml:space="preserve">
          <source>Now, suppose you are on an ocean liner somewhere in the Pacific. And there is one Starbucks onboard, but you are looking for the nearest 10. If you again start with 2 miles, it will take several iterations to find 10 sites. But, let's walk through it anyway. The first probe will hit one partition (maybe 2), and find just one hit. The second probe doubles the width of the square; 4 miles will still give you one hit -- the same hit in the same block, which is now cached, so we won't count it as a second disk I/O. Eventually the square will be wide enough to span multiple partitions. Each extra partition will be one new disk hit to discover no sites in the square. Finally, the square will hit Chile or Hawaii or Fiji and find some more sites, perhaps enough to stop the iteration. Since the main criteria in determining the number of disk hits is the number of partitions hit, we do not want to split the world into too many partitions. If there are, say, 40 partitions, then I have just described a case where there might be 20 disk hits.</source>
          <target state="translated">이제 태평양 어딘가에 바다 라이너가 있다고 가정하십시오. 그리고 1 개의 스타 벅스가 내장되어 있지만 가장 가까운 10 개를 찾고 있습니다. 다시 2 마일로 시작하면 10 개의 사이트를 찾기 위해 여러 번 반복해야합니다. 그러나 어쨌든 살펴 보겠습니다. 첫 번째 프로브는 하나의 파티션 (2 개)에 도달하고 하나의 히트 만 찾습니다. 두 번째 프로브는 사각형의 너비를 두 배로 늘립니다. 4 마일은 여전히 ​​하나의 히트를 제공합니다. 동일한 블록에서 동일한 히트가 캐시에 저장되므로 두 번째 디스크 I / O로 계산하지 않습니다. 결국 정사각형은 여러 파티션에 걸쳐있을만큼 넓습니다. 각 추가 파티션은 사각형에 사이트가 없음을 발견하기 위해 하나의 새 디스크 적중입니다. 마지막으로 광장은 칠레, 하와이 또는 피지에 부딪 히고 더 많은 사이트를 찾게 될 것입니다.디스크 적중 횟수를 결정하는 주요 기준은 적중 한 파티션 수이므로 월드를 너무 많은 파티션으로 나누고 싶지는 않습니다. 예를 들어 40 개의 파티션이 있다면 방금 20 개의 디스크 적중이있는 경우를 설명했습니다.</target>
        </trans-unit>
        <trans-unit id="cd725afd2fe0e16e9f36789aed8a6976ead38b24" translate="yes" xml:space="preserve">
          <source>Now, table &lt;code&gt;t&lt;/code&gt; will be encrypted using the encryption key from the key file.</source>
          <target state="translated">이제 테이블 &lt;code&gt;t&lt;/code&gt; 는 키 파일의 암호화 키를 사용하여 암호화됩니다.</target>
        </trans-unit>
        <trans-unit id="5158a45b226613121f3df3f10efe9a26b10f4b07" translate="yes" xml:space="preserve">
          <source>Now, table &lt;code&gt;t&lt;/code&gt; will be encrypted using the encryption key from the key server.</source>
          <target state="translated">이제 테이블 &lt;code&gt;t&lt;/code&gt; 는 키 서버의 암호화 키를 사용하여 암호화됩니다.</target>
        </trans-unit>
        <trans-unit id="b064055664e0c6fe05e9e3243e2419fa8da1a01b" translate="yes" xml:space="preserve">
          <source>Now, table &lt;code&gt;t&lt;/code&gt; will be encrypted using the encryption key generated by AWS.</source>
          <target state="translated">이제 테이블 &lt;code&gt;t&lt;/code&gt; 는 AWS에서 생성 한 암호화 키를 사용하여 암호화됩니다.</target>
        </trans-unit>
        <trans-unit id="d7b8b88bcdcfee80095047af4cf4c2b40eefb0fb" translate="yes" xml:space="preserve">
          <source>Now, taking into account the cost of the dependent subquery:</source>
          <target state="translated">이제 종속 하위 쿼리의 비용을 고려합니다.</target>
        </trans-unit>
        <trans-unit id="3ffbde9d8efe37a229f309d63eaa797467a9e181" translate="yes" xml:space="preserve">
          <source>Now, this is easily possible. Cassandra SE makes Cassandra's column family appear as a table in MariaDB that you can insert to, update, and select from. You can write joins against this table, it is possible to join data that's stored in MariaDB with data that's stored in Cassandra.</source>
          <target state="translated">이제 이것은 쉽게 가능합니다. Cassandra SE는 Cassandra의 컬럼 패밀리를 MariaDB에서 테이블로 표시하여 삽입, 업데이트 및 선택할 수 있도록합니다. 이 테이블에 대해 조인을 작성할 수 있습니다. MariaDB에 저장된 데이터를 Cassandra에 저장된 데이터와 조인 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0398036fd545fe60162dcc7f0bf5df70ce5a0357" translate="yes" xml:space="preserve">
          <source>Now, we create a second table, containing the hours which each employee clocked in and out during the week:</source>
          <target state="translated">이제 우리는 각 직원이 주중에 시계를 출입하는 시간을 포함하는 두 번째 테이블을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="f13284bf73b037c77672ef842dff07217f58c729" translate="yes" xml:space="preserve">
          <source>Now, we know that the problem is in &lt;code&gt;t3&lt;/code&gt;'s definition.</source>
          <target state="translated">이제 우리는 문제가 &lt;code&gt;t3&lt;/code&gt; 정의 에 있음을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="5aafab5f8d654bfcfcca94b262b8a6afe256f41b" translate="yes" xml:space="preserve">
          <source>Now, we need to reduce the results to find only the top 5 per department. Here is a common mistake:</source>
          <target state="translated">이제 부서 당 상위 5 개만 찾으려면 결과를 줄여야합니다. 일반적인 실수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6ca412230ac5b07cd37013b9bfe74c0d36dc2db1" translate="yes" xml:space="preserve">
          <source>Now, we want to return the bus destinations with New York as the origin:</source>
          <target state="translated">이제 뉴욕을 출발지로하여 버스 목적지를 반환하려고합니다.</target>
        </trans-unit>
        <trans-unit id="7a3e8f6a560d5dea52ad03d17f87c717b1c1a636" translate="yes" xml:space="preserve">
          <source>Now, we'll create a master encryption key. This key can &lt;em&gt;never&lt;/em&gt; be retrieved by &lt;em&gt;any&lt;/em&gt; application or user. This key is used remotely to encrypt (and decrypt) the actual encryption keys that will be used by MariaDB. If this key is deleted or you lose access to it, you will be unable to use the contents of your MariaDB data directory.</source>
          <target state="translated">이제 마스터 암호화 키를 만듭니다. 이 키는 수 &lt;em&gt;적이&lt;/em&gt; 에 의해 검색되지 &lt;em&gt;어떤&lt;/em&gt; 응용 프로그램이나 사용자입니다. 이 키는 MariaDB가 사용할 실제 암호화 키를 원격으로 암호화 (및 해독)하는 데 사용됩니다. 이 키가 삭제되거나 액세스 할 수 없으면 MariaDB 데이터 디렉토리의 내용을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7e529983005c7cb146bf37419cea8fca51a1d8ff" translate="yes" xml:space="preserve">
          <source>Now, with the lock still in place, copy the data from the master to the slave. See &lt;a href=&quot;../backup-restore-and-import/index&quot;&gt;Backup, Restore and Import&lt;/a&gt; for details on how to do this.</source>
          <target state="translated">이제 잠금 장치를 그대로두고 마스터에서 슬레이브로 데이터를 복사하십시오. 이를 수행하는 방법에 대한 자세한 내용 은 &lt;a href=&quot;../backup-restore-and-import/index&quot;&gt;백업, 복원 및 가져 오기&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fba6110ccd0b518416a40fc9ddabb2038022d8c1" translate="yes" xml:space="preserve">
          <source>Now, you have told MariaDB to use the AWS KMS plugin and you've put credentials for the plugin in a location where the plugin will find them. The /etc/my.cnf.d/enable_encryption.preset file contains a set of options that enable all available encryption functionality.</source>
          <target state="translated">이제 MariaDB에 AWS KMS 플러그인을 사용하라고 지시했으며 플러그인이있는 위치에 플러그인의 자격 증명을 넣었습니다. /etc/my.cnf.d/enable_encryption.preset 파일에는 사용 가능한 모든 암호화 기능을 활성화하는 옵션 세트가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="109085beaaa80ac89858b283a64f7c75d7e5bb12" translate="yes" xml:space="preserve">
          <source>Null</source>
          <target state="translated">Null</target>
        </trans-unit>
        <trans-unit id="e6548f92994d81fc47f091a632c20725e1a0991a" translate="yes" xml:space="preserve">
          <source>Null-Safe and Regular Comparisons</source>
          <target state="translated">안전하고 규칙적인 비교</target>
        </trans-unit>
        <trans-unit id="1804c90829b7f01abfd49841af3caae85ad51299" translate="yes" xml:space="preserve">
          <source>Nullable</source>
          <target state="translated">Nullable</target>
        </trans-unit>
        <trans-unit id="a293728cf875f9f55a9420b2275fcf698eaf6701" translate="yes" xml:space="preserve">
          <source>Nullbit</source>
          <target state="translated">Nullbit</target>
        </trans-unit>
        <trans-unit id="2b8035e528a8304524ff2c53d1d363ea3a518130" translate="yes" xml:space="preserve">
          <source>Nullpos</source>
          <target state="translated">Nullpos</target>
        </trans-unit>
        <trans-unit id="f8270722db379d93855678ed90849d2bcbe9fa07" translate="yes" xml:space="preserve">
          <source>NumGeometries</source>
          <target state="translated">NumGeometries</target>
        </trans-unit>
        <trans-unit id="03edfc9e704c92b4d95c83ff5b962dd12cb2977e" translate="yes" xml:space="preserve">
          <source>NumInteriorRings</source>
          <target state="translated">NumInteriorRings</target>
        </trans-unit>
        <trans-unit id="6e21c32f5d911cf7cb62654f4b6cd27e7391aec3" translate="yes" xml:space="preserve">
          <source>NumPoints</source>
          <target state="translated">NumPoints</target>
        </trans-unit>
        <trans-unit id="b7baa1d40c4ea29afc9098732bffee2a861a6c44" translate="yes" xml:space="preserve">
          <source>Number</source>
          <target state="translated">Number</target>
        </trans-unit>
        <trans-unit id="dd451df143db1883131677d43c7f1a93144a6224" translate="yes" xml:space="preserve">
          <source>Number Forms</source>
          <target state="translated">숫자 양식</target>
        </trans-unit>
        <trans-unit id="dc89bc888db014a86c72f1ccae20d82a89e1e0e0" translate="yes" xml:space="preserve">
          <source>Number of %s = 0 is not an allowed value</source>
          <target state="translated">% s = 0의 개수는 허용되는 값이 아닙니다</target>
        </trans-unit>
        <trans-unit id="c23683f8312b6b3a97c0398edd9aa2b03c070617" translate="yes" xml:space="preserve">
          <source>Number of (potentially) returned rows</source>
          <target state="translated">(잠재적으로) 리턴 된 행 수</target>
        </trans-unit>
        <trans-unit id="b2b328dc58e9a9004bbe16c6430cdd2d18f29013" translate="yes" xml:space="preserve">
          <source>Number of (potentially) returned rows.</source>
          <target state="translated">(잠재적으로) 리턴 된 행 수</target>
        </trans-unit>
        <trans-unit id="661f5cda6b748f24deb6c7db5c985f8ac362ffbc" translate="yes" xml:space="preserve">
          <source>Number of 1024 sectors trimmed</source>
          <target state="translated">1024 개의 섹터 수</target>
        </trans-unit>
        <trans-unit id="293f8ad2f136bef7844969cd22b5602774c30e27" translate="yes" xml:space="preserve">
          <source>Number of 16384 sectors trimmed</source>
          <target state="translated">16384 개의 섹터 수 트림</target>
        </trans-unit>
        <trans-unit id="52b2f33362b1c6a0fbd7ed447775e731767d3b6b" translate="yes" xml:space="preserve">
          <source>Number of 2048 sectors trimmed</source>
          <target state="translated">트리밍 된 2048 개의 섹터 수</target>
        </trans-unit>
        <trans-unit id="b79c472e34c5bca73b3679382c9b488fd8a54159" translate="yes" xml:space="preserve">
          <source>Number of 32768 sectors trimmed</source>
          <target state="translated">32768 개의 섹터 수</target>
        </trans-unit>
        <trans-unit id="5a8842f8a2944bc32b08fb146aba802e8a223e44" translate="yes" xml:space="preserve">
          <source>Number of 4096 sectors trimmed</source>
          <target state="translated">트리밍 된 4096 개의 섹터 수</target>
        </trans-unit>
        <trans-unit id="3e231453b3df199990b24848edb00b1cd04e5205" translate="yes" xml:space="preserve">
          <source>Number of 512 sectors trimmed</source>
          <target state="translated">512 개의 섹터가 트림되었습니다</target>
        </trans-unit>
        <trans-unit id="9b66e6bfbecef68add0b83623583358e7590c225" translate="yes" xml:space="preserve">
          <source>Number of 8192 sectors trimmed</source>
          <target state="translated">8192 개의 섹터 수 트림</target>
        </trans-unit>
        <trans-unit id="668798291f55b1a0e4b1df6868cc735c3107f482" translate="yes" xml:space="preserve">
          <source>Number of &lt;a href=&quot;../int/index&quot;&gt;INT&lt;/a&gt; columns to create in table if specifying &lt;code&gt;--auto-generate-sql&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--auto-generate-sql&lt;/code&gt; 을 지정하면 테이블에 만들 &lt;a href=&quot;../int/index&quot;&gt;INT&lt;/a&gt; 열 수입니다 .</target>
        </trans-unit>
        <trans-unit id="2bf16c069d8790efd82cd655c316db79bfd328db" translate="yes" xml:space="preserve">
          <source>Number of &lt;a href=&quot;../varchar/index&quot;&gt;VARCHAR&lt;/a&gt; columns to create in table if specifying &lt;code&gt;--auto-generate-sql&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--auto-generate-sql&lt;/code&gt; 을 지정하는 경우 테이블에 작성할 &lt;a href=&quot;../varchar/index&quot;&gt;VARCHAR&lt;/a&gt; 열 수입니다 .</target>
        </trans-unit>
        <trans-unit id="910e960cc992371663aade42c8190f85c924421b" translate="yes" xml:space="preserve">
          <source>Number of InnoDB tables currently being used for processing the current SQL statement.</source>
          <target state="translated">현재 SQL 문 처리에 현재 사용중인 InnoDB 테이블 수</target>
        </trans-unit>
        <trans-unit id="3c2637085c9f6b28b62caafd62604af5b8434b01" translate="yes" xml:space="preserve">
          <source>Number of InnoDB tables that that have row locks held by the current SQL statement.</source>
          <target state="translated">현재 SQL 문이 보유한 행 잠금이있는 InnoDB 테이블 수</target>
        </trans-unit>
        <trans-unit id="169b9be5012c6dc9d3459ca4215736a4cf995cbb" translate="yes" xml:space="preserve">
          <source>Number of NULL rows</source>
          <target state="translated">NULL 행 수</target>
        </trans-unit>
        <trans-unit id="35874b2bf5cbe29a074a6de80120785ebd08e718" translate="yes" xml:space="preserve">
          <source>Number of SELECT statements</source>
          <target state="translated">SELECT 문 수</target>
        </trans-unit>
        <trans-unit id="d40d8306ff86077beaf31d5ccfbdd3ad8c68dbc3" translate="yes" xml:space="preserve">
          <source>Number of Threads in Thread Group</source>
          <target state="translated">스레드 그룹의 스레드 수</target>
        </trans-unit>
        <trans-unit id="f87e1e452684667e59b9c8d9ccfac684b5416e96" translate="yes" xml:space="preserve">
          <source>Number of Timeout exceptions we got from Cassandra</source>
          <target state="translated">Cassandra에서 얻은 시간 초과 예외 수</target>
        </trans-unit>
        <trans-unit id="0e7f5941d48976195154d427c9224a9b81f70a49" translate="yes" xml:space="preserve">
          <source>Number of UPDATE/INSERT/DELETE statements</source>
          <target state="translated">UPDATE / INSERT / DELETE 문 수</target>
        </trans-unit>
        <trans-unit id="3b646a4160fe3363bed6942049e64f0e6c7f3a81" translate="yes" xml:space="preserve">
          <source>Number of Unavailable exceptions we got from Cassandra</source>
          <target state="translated">Cassandra에서 얻은 사용할 수없는 예외 수</target>
        </trans-unit>
        <trans-unit id="b50150c53271526beafbd7de51a8fdec0b69f06a" translate="yes" xml:space="preserve">
          <source>Number of XtraDB/InnoDB compressed pages of different page sizes.</source>
          <target state="translated">페이지 크기가 다른 XtraDB / InnoDB 압축 페이지 수</target>
        </trans-unit>
        <trans-unit id="c95ea65a703d786f34472f7855ea5231a24c1c1a" translate="yes" xml:space="preserve">
          <source>Number of all delete operations.</source>
          <target state="translated">모든 삭제 작업 수</target>
        </trans-unit>
        <trans-unit id="c5451f3c5c5d6b9c8da0f8bd015ecc77259c427d" translate="yes" xml:space="preserve">
          <source>Number of all external read locks.</source>
          <target state="translated">모든 외부 읽기 잠금 수</target>
        </trans-unit>
        <trans-unit id="b94d8babe66f4b85a201b45860e074d4b6cb8da1" translate="yes" xml:space="preserve">
          <source>Number of all external write locks.</source>
          <target state="translated">모든 외부 쓰기 잠금 수</target>
        </trans-unit>
        <trans-unit id="8e68f6070e52db3289203ca8f7bc014475d8d0fe" translate="yes" xml:space="preserve">
          <source>Number of all fetch operations.</source>
          <target state="translated">모든 페치 조작 수</target>
        </trans-unit>
        <trans-unit id="3ff2573da8df712d4d7f28a0ab1c35393f4cafdf" translate="yes" xml:space="preserve">
          <source>Number of all insert operations.</source>
          <target state="translated">모든 삽입 작업 수</target>
        </trans-unit>
        <trans-unit id="82510ae7485269112b293b8fa83a99edd403624e" translate="yes" xml:space="preserve">
          <source>Number of all internal concurrent insert write locks.</source>
          <target state="translated">모든 내부 동시 삽입 쓰기 잠금 수</target>
        </trans-unit>
        <trans-unit id="f4772abf0db1ec37a29f80f8bcfd627ad99a2db0" translate="yes" xml:space="preserve">
          <source>Number of all internal read high priority locks.</source>
          <target state="translated">모든 내부 읽기 우선 순위가 높은 잠금 수</target>
        </trans-unit>
        <trans-unit id="2d642e736b71469a03a1359b7e082267b869e83b" translate="yes" xml:space="preserve">
          <source>Number of all internal read no insert locks.</source>
          <target state="translated">모든 내부 읽기 수 인서트 잠금 수</target>
        </trans-unit>
        <trans-unit id="1f447b21a5587f2e30b9f25915f2ea9fd610fe93" translate="yes" xml:space="preserve">
          <source>Number of all internal read normal locks.</source>
          <target state="translated">모든 내부 읽기 정상 잠금 수</target>
        </trans-unit>
        <trans-unit id="193820df233b21f8f29deb85f85e1cbe13d5badc" translate="yes" xml:space="preserve">
          <source>Number of all internal read with shared locks.</source>
          <target state="translated">공유 잠금이있는 모든 내부 읽기 수</target>
        </trans-unit>
        <trans-unit id="5b17991eb50aad4e44ee9c8f4006a01f9e85301c" translate="yes" xml:space="preserve">
          <source>Number of all internal write delayed locks.</source>
          <target state="translated">모든 내부 쓰기 지연 잠금 수</target>
        </trans-unit>
        <trans-unit id="77ff20a99c4561536763906e5d841e920351fc3b" translate="yes" xml:space="preserve">
          <source>Number of all internal write low priority locks.</source>
          <target state="translated">모든 내부 쓰기 우선 순위가 낮은 잠금 수</target>
        </trans-unit>
        <trans-unit id="1baee1a8f9d948b6bc3e5ac1f3dd7dc871e94317" translate="yes" xml:space="preserve">
          <source>Number of all internal write normal locks.</source>
          <target state="translated">모든 내부 쓰기 정상 잠금 수</target>
        </trans-unit>
        <trans-unit id="c372435bd0e1b0c419825c2af03b534bd24a3667" translate="yes" xml:space="preserve">
          <source>Number of all miscellaneous operations not counted above, including &lt;code&gt;CONNECT&lt;/code&gt;, &lt;code&gt;LISTEN&lt;/code&gt;, &lt;code&gt;ACCEPT&lt;/code&gt;, &lt;code&gt;CLOSE&lt;/code&gt;, and &lt;code&gt;SHUTDOWN&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CONNECT&lt;/code&gt; , &lt;code&gt;LISTEN&lt;/code&gt; , &lt;code&gt;ACCEPT&lt;/code&gt; , &lt;code&gt;CLOSE&lt;/code&gt; 및 &lt;code&gt;SHUTDOWN&lt;/code&gt; 을 포함하여 위에서 계산되지 않은 모든 기타 작업의 수입니다 .</target>
        </trans-unit>
        <trans-unit id="e35e9f1e2d836b7f8688c60354a36886b5980003" translate="yes" xml:space="preserve">
          <source>Number of all miscellaneous operations not counted above, including &lt;code&gt;CONNECT&lt;/code&gt;, &lt;code&gt;LISTENw&lt;/code&gt;, &lt;code&gt;ACCEPT&lt;/code&gt;, &lt;code&gt;CLOSE&lt;/code&gt;, and &lt;code&gt;SHUTDOWN&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CONNECT&lt;/code&gt; , &lt;code&gt;LISTENw&lt;/code&gt; , &lt;code&gt;ACCEPT&lt;/code&gt; , &lt;code&gt;CLOSE&lt;/code&gt; 및 &lt;code&gt;SHUTDOWN&lt;/code&gt; 을 포함하여 위에서 계산되지 않은 모든 기타 작업의 수입니다 .</target>
        </trans-unit>
        <trans-unit id="c09030dd82f8c6a5bc91767fdbd268643e22ef65" translate="yes" xml:space="preserve">
          <source>Number of all miscellaneous operations not counted above, including &lt;code&gt;CREATE&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, &lt;code&gt;OPEN&lt;/code&gt;, &lt;code&gt;CLOSE&lt;/code&gt;, &lt;code&gt;STREAM_OPEN&lt;/code&gt;, &lt;code&gt;STREAM_CLOSE&lt;/code&gt;, &lt;code&gt;SEEK&lt;/code&gt;, &lt;code&gt;TELL&lt;/code&gt;, &lt;code&gt;FLUSH&lt;/code&gt;, &lt;code&gt;STAT&lt;/code&gt;, &lt;code&gt;FSTAT&lt;/code&gt;, &lt;code&gt;CHSIZE&lt;/code&gt;, &lt;code&gt;RENAME&lt;/code&gt;, and &lt;code&gt;SYNC&lt;/code&gt;.</source>
          <target state="translated">모든 기타 작업의 수를 포함하여, 위의 계산되지 &lt;code&gt;CREATE&lt;/code&gt; , &lt;code&gt;DELETE&lt;/code&gt; , &lt;code&gt;OPEN&lt;/code&gt; , &lt;code&gt;CLOSE&lt;/code&gt; , &lt;code&gt;STREAM_OPEN&lt;/code&gt; , &lt;code&gt;STREAM_CLOSE&lt;/code&gt; , &lt;code&gt;SEEK&lt;/code&gt; , &lt;code&gt;TELL&lt;/code&gt; , &lt;code&gt;FLUSH&lt;/code&gt; , &lt;code&gt;STAT&lt;/code&gt; , &lt;code&gt;FSTAT&lt;/code&gt; , &lt;code&gt;CHSIZE&lt;/code&gt; , &lt;code&gt;RENAME&lt;/code&gt; 및 &lt;code&gt;SYNC&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="080598e4fa0be72f878d32879969bb8aa43e9516" translate="yes" xml:space="preserve">
          <source>Number of all read operations, and the sum of the equivalent &lt;code&gt;x_FETCH&lt;/code&gt; columns.</source>
          <target state="translated">모든 읽기 작업 수 및 해당 &lt;code&gt;x_FETCH&lt;/code&gt; 열의 합계</target>
        </trans-unit>
        <trans-unit id="ac9f495d808ff6428ff70e82b1200d29455a0667" translate="yes" xml:space="preserve">
          <source>Number of all read operations, and the sum of the equivalent &lt;code&gt;x_READ_NORMAL&lt;/code&gt;, &lt;code&gt;x_READ_WITH_SHARED_LOCKS&lt;/code&gt;, &lt;code&gt;x_READ_HIGH_PRIORITY&lt;/code&gt; and &lt;code&gt;x_READ_NO_INSERT&lt;/code&gt; columns.</source>
          <target state="translated">모든 읽기 조작 수 및 해당 &lt;code&gt;x_READ_NORMAL&lt;/code&gt; , &lt;code&gt;x_READ_WITH_SHARED_LOCKS&lt;/code&gt; , &lt;code&gt;x_READ_HIGH_PRIORITY&lt;/code&gt; 및 &lt;code&gt;x_READ_NO_INSERT&lt;/code&gt; 열의 합계</target>
        </trans-unit>
        <trans-unit id="9d52e8c4970b5dbec3fe07f40b16e2756cd3c629" translate="yes" xml:space="preserve">
          <source>Number of all read operations, including &lt;code&gt;FGETS&lt;/code&gt;, &lt;code&gt;FGETC&lt;/code&gt;, &lt;code&gt;FREAD&lt;/code&gt;, and &lt;code&gt;READ&lt;/code&gt;.</source>
          <target state="translated">를 포함한 모든 읽기 작업의 수 &lt;code&gt;FGETS&lt;/code&gt; , &lt;code&gt;FGETC&lt;/code&gt; , &lt;code&gt;FREAD&lt;/code&gt; 및 &lt;code&gt;READ&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4fee60144d5e1f037b5de34f61f51467ba1efe62" translate="yes" xml:space="preserve">
          <source>Number of all read operations, including &lt;code&gt;RECV&lt;/code&gt;, &lt;code&gt;RECVFROM&lt;/code&gt;, and &lt;code&gt;RECVMSG&lt;/code&gt;.</source>
          <target state="translated">를 포함한 모든 읽기 작업의 수 &lt;code&gt;RECV&lt;/code&gt; , &lt;code&gt;RECVFROM&lt;/code&gt; 및 &lt;code&gt;RECVMSG&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8928a9e585b89554daf1282249ef9f7c39986ccf" translate="yes" xml:space="preserve">
          <source>Number of all update operations.</source>
          <target state="translated">모든 업데이트 작업 수</target>
        </trans-unit>
        <trans-unit id="e7cc7913543ad898aec39528316debcc962ff03f" translate="yes" xml:space="preserve">
          <source>Number of all write operations, and the sum of the equivalent &lt;code&gt;x_INSERT&lt;/code&gt;, &lt;code&gt;x_UPDATE&lt;/code&gt; and &lt;code&gt;x_DELETE&lt;/code&gt; columns.</source>
          <target state="translated">모든 쓰기 작업 수 및 해당 &lt;code&gt;x_INSERT&lt;/code&gt; , &lt;code&gt;x_UPDATE&lt;/code&gt; 및 &lt;code&gt;x_DELETE&lt;/code&gt; 열의 합계</target>
        </trans-unit>
        <trans-unit id="6e41195ba51025789943e30d6bbbbe04ec850f95" translate="yes" xml:space="preserve">
          <source>Number of all write operations, and the sum of the equivalent &lt;code&gt;x_WRITE_ALLOW_WRITE&lt;/code&gt;, &lt;code&gt;x_WRITE_CONCURRENT_INSERT&lt;/code&gt;, &lt;code&gt;x_WRITE_DELAYED&lt;/code&gt;, &lt;code&gt;x_WRITE_LOW_PRIORITY&lt;/code&gt; and &lt;code&gt;x_WRITE_NORMAL&lt;/code&gt; columns.</source>
          <target state="translated">모든 쓰기 작업 수 및 해당 &lt;code&gt;x_WRITE_ALLOW_WRITE&lt;/code&gt; , &lt;code&gt;x_WRITE_CONCURRENT_INSERT&lt;/code&gt; , &lt;code&gt;x_WRITE_DELAYED&lt;/code&gt; , &lt;code&gt;x_WRITE_LOW_PRIORITY&lt;/code&gt; 및 &lt;code&gt;x_WRITE_NORMAL&lt;/code&gt; 열의 합계</target>
        </trans-unit>
        <trans-unit id="980d3344b59fbad740693c55453938fd4038b0aa" translate="yes" xml:space="preserve">
          <source>Number of all write operations, including &lt;code&gt;FPUTS&lt;/code&gt;, &lt;code&gt;FPUTC&lt;/code&gt;, &lt;code&gt;FPRINTF&lt;/code&gt;, &lt;code&gt;VFPRINTF&lt;/code&gt;, &lt;code&gt;FWRITE&lt;/code&gt;, and &lt;code&gt;PWRITE&lt;/code&gt;.</source>
          <target state="translated">를 포함한 모든 쓰기 작업의 수 &lt;code&gt;FPUTS&lt;/code&gt; , &lt;code&gt;FPUTC&lt;/code&gt; , &lt;code&gt;FPRINTF&lt;/code&gt; , &lt;code&gt;VFPRINTF&lt;/code&gt; , &lt;code&gt;FWRITE&lt;/code&gt; 및 &lt;code&gt;PWRITE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f7a61b1149c67dc31ad7d89fd7e79753b8d9d248" translate="yes" xml:space="preserve">
          <source>Number of all write operations, including &lt;code&gt;SEND&lt;/code&gt;, &lt;code&gt;SENDTO&lt;/code&gt;, and &lt;code&gt;SENDMSG&lt;/code&gt;.</source>
          <target state="translated">를 포함한 모든 쓰기 작업의 수 &lt;code&gt;SEND&lt;/code&gt; , &lt;code&gt;SENDTO&lt;/code&gt; 및 &lt;code&gt;SENDMSG&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="53c2869b9ff6e04239a31feefc0384d551c4f389" translate="yes" xml:space="preserve">
          <source>Number of block input operations.</source>
          <target state="translated">블록 입력 조작의 수</target>
        </trans-unit>
        <trans-unit id="8e14a8556077dced385703df8d7e402c6b98c875" translate="yes" xml:space="preserve">
          <source>Number of block output operations.</source>
          <target state="translated">블록 출력 작업 수</target>
        </trans-unit>
        <trans-unit id="4949da8695ee74a64c9e1462720dce096db6c697" translate="yes" xml:space="preserve">
          <source>Number of blocked connections because &lt;code&gt;SUM_CONNECT_ERRORS&lt;/code&gt; exceeded the &lt;a href=&quot;../server-system-variables/index#max_connect_errors&quot;&gt;max_connect_errors&lt;/a&gt; system variable.</source>
          <target state="translated">&lt;code&gt;SUM_CONNECT_ERRORS&lt;/code&gt; 가 &lt;a href=&quot;../server-system-variables/index#max_connect_errors&quot;&gt;max_connect_errors&lt;/a&gt; 시스템 변수를 초과하여 차단 된 연결 수입니다 .</target>
        </trans-unit>
        <trans-unit id="18e462b6cabb3475f90472b215f551ec782ee45d" translate="yes" xml:space="preserve">
          <source>Number of bytes of unreclaimed deleted data, Use &lt;a href=&quot;../optimize-table/index&quot;&gt;OPTIMIZE TABLE&lt;/a&gt; to reclaim the space.</source>
          <target state="translated">교정되지 않은 삭제 된 데이터의 바이트 수입니다. &lt;a href=&quot;../optimize-table/index&quot;&gt;OPTIMIZE TABLE&lt;/a&gt; 을 사용 하여 공간을 확보하십시오.</target>
        </trans-unit>
        <trans-unit id="e9423b30fa47cab1adf83f5d79ef2d520ac387fc" translate="yes" xml:space="preserve">
          <source>Number of bytes that the operation read or wrote, or &lt;code&gt;NULL&lt;/code&gt; for table I/O waits.</source>
          <target state="translated">조작이 읽거나 쓴 바이트 수 또는 테이블 I / O 대기의 경우 &lt;code&gt;NULL&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="991d80cd450ac13a0d446de74509bd0cabb4fa79" translate="yes" xml:space="preserve">
          <source>Number of clients running queries</source>
          <target state="translated">쿼리를 실행하는 클라이언트 수</target>
        </trans-unit>
        <trans-unit id="6fc0f842962f427f73e9bec4caba4a5745254de7" translate="yes" xml:space="preserve">
          <source>Number of clients to simulate for query to run.</source>
          <target state="translated">쿼리 실행을 위해 시뮬레이트 할 클라이언트 수입니다.</target>
        </trans-unit>
        <trans-unit id="bfbad7d8a5698feed3f14f7427e7900af4bb851b" translate="yes" xml:space="preserve">
          <source>Number of columns</source>
          <target state="translated">열 수</target>
        </trans-unit>
        <trans-unit id="1d6ab714ad2c7e1e8466ecb56a7003316262f89e" translate="yes" xml:space="preserve">
          <source>Number of columns in following arrays</source>
          <target state="translated">다음 배열의 열 수</target>
        </trans-unit>
        <trans-unit id="7264f1b78113cc64e0d8f144f54300a31dce1e98" translate="yes" xml:space="preserve">
          <source>Number of columns in the index. GEN_CLUST_INDEX's have a value of 0 as the index is not based on an actual column in the table.</source>
          <target state="translated">인덱스의 열 수 인덱스가 테이블의 실제 열을 기반으로하지 않기 때문에 GEN_CLUST_INDEX의 값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="8a194fcae31088b4fc7594f120f275ef173980f9" translate="yes" xml:space="preserve">
          <source>Number of columns in the table.</source>
          <target state="translated">테이블의 열 수</target>
        </trans-unit>
        <trans-unit id="1e627446b8d35b4d036303ebe0f2b2debcc7e6f7" translate="yes" xml:space="preserve">
          <source>Number of columns in the temporary table, including three hidden columns that InnoDB creates (&lt;code&gt;DB_ROW_ID&lt;/code&gt;, &lt;code&gt;DB_TRX_ID&lt;/code&gt;, and &lt;code&gt;DB_ROLL_PTR&lt;/code&gt;).</source>
          <target state="translated">InnoDB가 생성하는 3 개의 숨겨진 열 ( &lt;code&gt;DB_ROW_ID&lt;/code&gt; , &lt;code&gt;DB_TRX_ID&lt;/code&gt; 및 &lt;code&gt;DB_ROLL_PTR&lt;/code&gt; )을</target>
        </trans-unit>
        <trans-unit id="e312db1940445b2acc2ff198d744fbea87b9e423" translate="yes" xml:space="preserve">
          <source>Number of communications received.</source>
          <target state="translated">수신 된 통신 수</target>
        </trans-unit>
        <trans-unit id="ec539972ae896f4ac8daa4208002416a078762fd" translate="yes" xml:space="preserve">
          <source>Number of communications sent.</source>
          <target state="translated">전송 된 통신 수</target>
        </trans-unit>
        <trans-unit id="571218ffdd5d8f80d27deeeaffa685b5213e0a50" translate="yes" xml:space="preserve">
          <source>Number of compression errors</source>
          <target state="translated">압축 오류 수</target>
        </trans-unit>
        <trans-unit id="be34f5f4c998bfa55fa3fc1b256c9b173b95a3ea" translate="yes" xml:space="preserve">
          <source>Number of connection errors. Counts only protocol handshake errors for hosts that passed validation. These errors count towards &lt;a href=&quot;../server-system-variables/index#max_connect_errors&quot;&gt;max_connect_errors&lt;/a&gt;.</source>
          <target state="translated">연결 오류 수 유효성 검사를 통과 한 호스트의 프로토콜 핸드 셰이크 오류 만 계산합니다. 이 오류는 &lt;a href=&quot;../server-system-variables/index#max_connect_errors&quot;&gt;max_connect_errors로&lt;/a&gt; 계산됩니다 .</target>
        </trans-unit>
        <trans-unit id="99dd8e0110e07a914bd7e07756b58c281c1feb85" translate="yes" xml:space="preserve">
          <source>Number of connections that the account can start per hour</source>
          <target state="translated">시간당 계정을 시작할 수있는 연결 수</target>
        </trans-unit>
        <trans-unit id="96717cd8bc454b3f1daf1dfcc15da2a43f72a33c" translate="yes" xml:space="preserve">
          <source>Number of connections the account can start per hour. Zero is unlimited. See &lt;a href=&quot;../grant/index#setting-per-account-resources-limits&quot;&gt;per-account resource limits&lt;/a&gt;.</source>
          <target state="translated">시간당 계정을 시작할 수있는 연결 수입니다. 제로는 무제한입니다. &lt;a href=&quot;../grant/index#setting-per-account-resources-limits&quot;&gt;계정 별 리소스 제한을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="505d3b950c9a82a51110abc5e3e46c6bebab917c" translate="yes" xml:space="preserve">
          <source>Number of days since year 0</source>
          <target state="translated">0 년 이후의 일 수</target>
        </trans-unit>
        <trans-unit id="dd9fa08d27952a65028fae9e548c262a28323d0f" translate="yes" xml:space="preserve">
          <source>Number of days since year 0.</source>
          <target state="translated">0 년 이후의 일 수입니다.</target>
        </trans-unit>
        <trans-unit id="886043468d5f121893620193acb71e586ce9e008" translate="yes" xml:space="preserve">
          <source>Number of decimals after the decimal point. The default, if an explicit number of decimals is passed in the arguments to the main function, is the maximum number of decimals, so if &lt;em&gt;9.5&lt;/em&gt;, &lt;em&gt;9.55&lt;/em&gt; and &lt;em&gt;9.555&lt;/em&gt; are passed to the function, the default would be three (based on &lt;em&gt;9.555&lt;/em&gt;, the maximum). If there are no explicit number of decimals, the default is set to 31, or one more than the maximum for the DOUBLE, FLOAT and DECIMAL types. This default can be changed in the function to suit the actual calculation.</source>
          <target state="translated">소수점 뒤의 소수점 이하 자릿수. 기본 함수의 인수에 명시 적 소수 자릿수가 전달되는 경우 기본값은 최대 소수 자릿수이므로 &lt;em&gt;9.5&lt;/em&gt; , &lt;em&gt;9.55&lt;/em&gt; 및 &lt;em&gt;9.555&lt;/em&gt; 가 함수에 전달되면 기본값은 3입니다 ( &lt;em&gt;9.555&lt;/em&gt; 기준 ). 최고). 명시적인 소수 자릿수가 없으면 기본값은 31로 설정되거나 DOUBLE, FLOAT 및 DECIMAL 유형의 최대 값보다 하나 이상으로 설정됩니다. 이 기본값은 실제 계산에 맞게 함수에서 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9112c6823276070961205a5caaa1b4b83ca72a9c" translate="yes" xml:space="preserve">
          <source>Number of deleted blocks</source>
          <target state="translated">삭제 된 블록 수</target>
        </trans-unit>
        <trans-unit id="94ea74c7059f17095b9cf4871bab65f82acb3e47" translate="yes" xml:space="preserve">
          <source>Number of deleted blocks that are still reserving space. Use &lt;a href=&quot;../optimize-table/index&quot;&gt;OPTIMIZE TABLE&lt;/a&gt; to defragment.</source>
          <target state="translated">여전히 공간을 예약하고있는 삭제 된 블록 수 조각 모음을 하려면 &lt;a href=&quot;../optimize-table/index&quot;&gt;OPTIMIZE TABLE&lt;/a&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="648b5b1691e167ae84b873e87f33f537cb3e8180" translate="yes" xml:space="preserve">
          <source>Number of dimensions in the spatial reference system. Always 2 in MariaDB.</source>
          <target state="translated">공간 참조 시스템의 차원 수 MariaDB에서는 항상 2입니다.</target>
        </trans-unit>
        <trans-unit id="ebdf6a26a80a37e4b48af71f9892d23fc1cc9213" translate="yes" xml:space="preserve">
          <source>Number of dirty pages.</source>
          <target state="translated">더티 페이지 수</target>
        </trans-unit>
        <trans-unit id="a16d0a26d79e0b80cad821f1e4bc723b3b50dda5" translate="yes" xml:space="preserve">
          <source>Number of empty rows</source>
          <target state="translated">빈 행 수</target>
        </trans-unit>
        <trans-unit id="e2e004c76658c3ee5506b755fb178341d6f82b78" translate="yes" xml:space="preserve">
          <source>Number of errors detected at the wire protocol level.</source>
          <target state="translated">유선 프로토콜 수준에서 감지 된 오류 수</target>
        </trans-unit>
        <trans-unit id="373a047eb2e381548fa1b55fb16efd9b9a9538fc" translate="yes" xml:space="preserve">
          <source>Number of errors detected when a proxy user is proxied to a user that does not exist.</source>
          <target state="translated">프록시 사용자가 존재하지 않는 사용자에게 프록시 될 때 감지 된 오류 수입니다.</target>
        </trans-unit>
        <trans-unit id="98b70fad3ce367fe4268ca3e40fd2eeb540c51e2" translate="yes" xml:space="preserve">
          <source>Number of errors detected when a proxy user is proxied to a user that exists, but the proxy user doesn't have the PROXY privilege.</source>
          <target state="translated">프록시 사용자가 존재하는 사용자에게 프록시되었지만 프록시 사용자에게 PROXY 권한이없는 경우 감지 된 오류 수입니다.</target>
        </trans-unit>
        <trans-unit id="04d2b4974689cefe1afbeb82b7658193f40ba731" translate="yes" xml:space="preserve">
          <source>Number of errors due to TLS problems.</source>
          <target state="translated">TLS 문제로 인한 오류 수</target>
        </trans-unit>
        <trans-unit id="13c7c473ba4ad555c5d325852876d6db14de83f4" translate="yes" xml:space="preserve">
          <source>Number of errors due to requesting an authentication plugin that was not available. This can be due to the plugin never having been loaded, or the load attempt failing.</source>
          <target state="translated">사용할 수없는 인증 플러그인 요청으로 인한 오류 수 플러그인이로드되지 않았거나로드 시도가 실패했기 때문일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77eb05631026c0ba7b3be5b135f73bbf30103429" translate="yes" xml:space="preserve">
          <source>Number of errors due to statements in the &lt;a href=&quot;../server-system-variables/index#init_connect&quot;&gt;init_connect&lt;/a&gt; system variable.</source>
          <target state="translated">&lt;a href=&quot;../server-system-variables/index#init_connect&quot;&gt;init_connect&lt;/a&gt; 시스템 변수의 명령문으로 인한 오류 수</target>
        </trans-unit>
        <trans-unit id="4416048347cb5c67e007664d2df3568ec84cac75" translate="yes" xml:space="preserve">
          <source>Number of errors due to the per-hour quota being exceeded.</source>
          <target state="translated">시간당 할당량을 초과하여 발생한 오류 수입니다.</target>
        </trans-unit>
        <trans-unit id="e7cb59d2976449d567ad7bae9dfba044bfc85e71" translate="yes" xml:space="preserve">
          <source>Number of errors due to the per-user quota being exceeded.</source>
          <target state="translated">사용자 당 할당량을 초과하여 발생한 오류 수</target>
        </trans-unit>
        <trans-unit id="ad136abdfd19a703deae1ce346309493b274fd26" translate="yes" xml:space="preserve">
          <source>Number of errors due to the user not having permission to access the specified default database, or it not existing.</source>
          <target state="translated">사용자에게 지정된 기본 데이터베이스에 대한 액세스 권한이 없거나 존재하지 않는 오류 수.</target>
        </trans-unit>
        <trans-unit id="1e3ab1037e6af6d8ad5c7f3e313f739555bc03b3" translate="yes" xml:space="preserve">
          <source>Number of errors occurring because no user from the host is permitted to log in. These attempts return &lt;a href=&quot;../mariadb-error-codes/index&quot;&gt;error code&lt;/a&gt;&lt;code&gt;1130 ER_HOST_NOT_PRIVILEGED&lt;/code&gt; and do not proceed to username and password authentication.</source>
          <target state="translated">호스트의 사용자가 로그인 할 수 없어서 발생하는 오류 수. 이러한 시도는 &lt;a href=&quot;../mariadb-error-codes/index&quot;&gt;오류 코드 &lt;/a&gt; &lt;code&gt;1130 ER_HOST_NOT_PRIVILEGED&lt;/code&gt; 를 리턴 하며 사용자 이름 및 비밀번호 인증을 진행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e568506b5316485e24bd087d1377fd45384e7f97" translate="yes" xml:space="preserve">
          <source>Number of errors reported by an authentication plugin. Plugins can increment &lt;code&gt;COUNT_AUTHENTICATION_ERRORS&lt;/code&gt; or &lt;code&gt;COUNT_HANDSHAKE_ERRORS&lt;/code&gt; instead, but, if specified or the error is unknown, this column is incremented.</source>
          <target state="translated">인증 플러그인이보고 한 오류 수 플러그인은 대신 &lt;code&gt;COUNT_AUTHENTICATION_ERRORS&lt;/code&gt; 또는 &lt;code&gt;COUNT_HANDSHAKE_ERRORS&lt;/code&gt; 를 증가 시킬 수 있지만, 지정되거나 오류를 알 수없는 경우이 열이 증가합니다.</target>
        </trans-unit>
        <trans-unit id="7d0c1bdb58cd6ed814a2f1b0bdbd186f40f77fb8" translate="yes" xml:space="preserve">
          <source>Number of errors where authentication failed.</source>
          <target state="translated">인증이 실패한 오류 수</target>
        </trans-unit>
        <trans-unit id="c3c16f175bdb6f330be712187beb5a0ce2ff6581" translate="yes" xml:space="preserve">
          <source>Number of events that a slave skips from the master, as recorded in the &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#sql_slave_skip_counter&quot;&gt;sql_slave_skip_counter&lt;/a&gt;&lt;/code&gt; system variable.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#sql_slave_skip_counter&quot;&gt;sql_slave_skip_counter&lt;/a&gt;&lt;/code&gt; 시스템 변수에 기록 된대로 슬레이브가 마스터에서 건너 뛰는 이벤트 수입니다 .</target>
        </trans-unit>
        <trans-unit id="965754c01660992392eb4f6612cb1edfb55fcc56" translate="yes" xml:space="preserve">
          <source>Number of executed &lt;code&gt;START ALL SLAVES&lt;/code&gt; commands.</source>
          <target state="translated">실행 된 &lt;code&gt;START ALL SLAVES&lt;/code&gt; 명령의 수</target>
        </trans-unit>
        <trans-unit id="7016354f0638847567385d171db54f9c5f6f15f1" translate="yes" xml:space="preserve">
          <source>Number of executed &lt;code&gt;START SLAVE&lt;/code&gt; commands. This replaces &lt;code&gt;Com_slave_start&lt;/code&gt;.</source>
          <target state="translated">실행 된 &lt;code&gt;START SLAVE&lt;/code&gt; 명령의 수 이것은 &lt;code&gt;Com_slave_start&lt;/code&gt; 를 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="9ad13d8cb8f90bd69c8b518694815a27ef8ae8b9" translate="yes" xml:space="preserve">
          <source>Number of executed &lt;code&gt;STOP ALL SLAVES&lt;/code&gt; commands.</source>
          <target state="translated">실행 된 &lt;code&gt;STOP ALL SLAVES&lt;/code&gt; 명령의 수</target>
        </trans-unit>
        <trans-unit id="5fce12048c11f8743876613a0d9a74205836a514" translate="yes" xml:space="preserve">
          <source>Number of executed &lt;code&gt;STOP SLAVE&lt;/code&gt; commands. This replaces &lt;code&gt;Com_slave_stop&lt;/code&gt;.</source>
          <target state="translated">실행 된 &lt;code&gt;STOP SLAVE&lt;/code&gt; 명령 수 이것은 &lt;code&gt;Com_slave_stop&lt;/code&gt; 을 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="f25212e4efd569f4aa4de2b156d11997a30aeffa" translate="yes" xml:space="preserve">
          <source>Number of flushes to data log files</source>
          <target state="translated">데이터 로그 파일 플러시 수</target>
        </trans-unit>
        <trans-unit id="05468115505acd0397f6dc1606bede545bf75a0a" translate="yes" xml:space="preserve">
          <source>Number of flushes to transaction log files</source>
          <target state="translated">트랜잭션 로그 파일의 플러시 수</target>
        </trans-unit>
        <trans-unit id="a9bd6faed2e7cd42c5791e3590783427793f817c" translate="yes" xml:space="preserve">
          <source>Number of foreign key index columns.</source>
          <target state="translated">외래 키 인덱스 열 수</target>
        </trans-unit>
        <trans-unit id="6e9302abdfa2386a0044e0f4865c77b367c86845" translate="yes" xml:space="preserve">
          <source>Number of forward-confirmed reverse DNS errors, which occur when IP-to-host DNS lookup does not match the originating IP address.</source>
          <target state="translated">IP-to-host DNS 조회가 원래 IP 주소와 일치하지 않을 때 발생하는 정방향 역방향 DNS 오류 수입니다.</target>
        </trans-unit>
        <trans-unit id="4ed91837c1ceaa49b45dc71a23a0a167a1e6a7ef" translate="yes" xml:space="preserve">
          <source>Number of free pages in the buffer pool.</source>
          <target state="translated">버퍼 풀에서 사용 가능한 페이지 수</target>
        </trans-unit>
        <trans-unit id="fbb5ed6c728cbdd6e6ee9b78edb22031c90acab4" translate="yes" xml:space="preserve">
          <source>Number of geometries in a GeometryCollection</source>
          <target state="translated">GeometryCollection의 기하학 수</target>
        </trans-unit>
        <trans-unit id="0887a99fe9d16306bf4f80a031f9819da2bb813a" translate="yes" xml:space="preserve">
          <source>Number of geometries in a GeometryCollection.</source>
          <target state="translated">GeometryCollection의 도형 수입니다.</target>
        </trans-unit>
        <trans-unit id="445471559f88375fd812286db021092fd01eb57a" translate="yes" xml:space="preserve">
          <source>Number of host name format errors, for example a numeric host column.</source>
          <target state="translated">호스트 이름 형식 오류 수 (예 : 숫자 호스트 열)</target>
        </trans-unit>
        <trans-unit id="7f2483378ec66bd443371682a228280534330eac" translate="yes" xml:space="preserve">
          <source>Number of inactive threads in the thread pool. Threads become inactive for various reasons, such as by waiting for new work. However, an inactive thread is not necessarily one that has not been assigned work. Threads are also considered inactive if they are being blocked while waiting on disk I/O, or while waiting on a lock, etc. This status variable is only meaningful on &lt;strong&gt;Unix&lt;/strong&gt;.</source>
          <target state="translated">스레드 풀에서 비활성 스레드 수 스레드는 새로운 작업을 기다리는 등 여러 가지 이유로 비활성화됩니다. 그러나 비활성 스레드가 반드시 작업에 할당되지 않은 스레드는 아닙니다. 스레드는 디스크 I / O를 기다리는 동안 또는 잠금을 기다리는 동안 차단되는 경우 비활성으로 간주됩니다.이 상태 변수는 &lt;strong&gt;Unix&lt;/strong&gt; 에서만 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="8cbe7847187229b84530f9f14cedf764f144ef65" translate="yes" xml:space="preserve">
          <source>Number of index scans</source>
          <target state="translated">인덱스 스캔 수</target>
        </trans-unit>
        <trans-unit id="627e71d98d13b9feaa6c47ac85537a42b3dad778" translate="yes" xml:space="preserve">
          <source>Number of input rows.</source>
          <target state="translated">입력 행 수</target>
        </trans-unit>
        <trans-unit id="5a99bc0bb8dc7db6cecbb391992f4de14cfcdcbe" translate="yes" xml:space="preserve">
          <source>Number of insert batches performed</source>
          <target state="translated">수행 된 인서트 배치 수</target>
        </trans-unit>
        <trans-unit id="d6283203d754a1e4f8efe91614482fe0794c2294" translate="yes" xml:space="preserve">
          <source>Number of interior rings in a Polygon</source>
          <target state="translated">다각형의 내부 링 수</target>
        </trans-unit>
        <trans-unit id="614be1ba0e63e22d1501be2b1a2b4f1751faf482" translate="yes" xml:space="preserve">
          <source>Number of interior rings in a Polygon.</source>
          <target state="translated">다각형의 내부 링 수</target>
        </trans-unit>
        <trans-unit id="955f5570b7c98b384b7e2b08add2530406bedd76" translate="yes" xml:space="preserve">
          <source>Number of involuntary context switches.</source>
          <target state="translated">비자발적 컨텍스트 전환 수</target>
        </trans-unit>
        <trans-unit id="066129cb0f38faad20f26396239842b2bd8faa9f" translate="yes" xml:space="preserve">
          <source>Number of iterations to make. This works with &lt;code&gt;-i&lt;/code&gt; (&lt;code&gt;--sleep&lt;/code&gt;) only.</source>
          <target state="translated">반복 횟수입니다. 이것은 &lt;code&gt;-i&lt;/code&gt; ( &lt;code&gt;--sleep&lt;/code&gt; )에서만 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="48d68842331dc08cb9c3e615cc47884c453e8cfc" translate="yes" xml:space="preserve">
          <source>Number of joins performed by the statement which did not use an index.</source>
          <target state="translated">인덱스를 사용하지 않은 명령문에 의해 수행 된 조인 수</target>
        </trans-unit>
        <trans-unit id="66999066d96b8044c36abfbf38bf9f240896ca13" translate="yes" xml:space="preserve">
          <source>Number of joins performed by the statement which used a full scan of the first table.</source>
          <target state="translated">첫 번째 테이블의 전체 스캔을 사용한 명령문이 수행 한 조인 수입니다.</target>
        </trans-unit>
        <trans-unit id="097ab6ee4ae1320536ca138541797947178d5c5b" translate="yes" xml:space="preserve">
          <source>Number of joins performed by the statement which used a range of the first table.</source>
          <target state="translated">첫 번째 테이블의 범위를 사용한 명령문이 수행 한 조인 수입니다.</target>
        </trans-unit>
        <trans-unit id="0eac0bfa2faa7bbdb075d84da421550cb85d00b3" translate="yes" xml:space="preserve">
          <source>Number of joins performed by the statement which used a range search of the first table.</source>
          <target state="translated">첫 번째 테이블의 범위 검색을 사용한 명령문에서 수행 한 조인 수입니다.</target>
        </trans-unit>
        <trans-unit id="31971dbde73003e5181edbc282ae4915a3f06606" translate="yes" xml:space="preserve">
          <source>Number of joins without keys performed by the statement that check for key usage after each row.</source>
          <target state="translated">각 행 이후의 키 사용을 확인하는 명령문으로 키가없는 조인 수입니다.</target>
        </trans-unit>
        <trans-unit id="8b11804b62aadeb2fda9917517af612a3602d481" translate="yes" xml:space="preserve">
          <source>Number of keys we've made lookups for</source>
          <target state="translated">조회 한 키 수</target>
        </trans-unit>
        <trans-unit id="530d3adcfe281a54268fbfbc43abbafbdd890221" translate="yes" xml:space="preserve">
          <source>Number of local server errors, such as out-of-memory errors, unrelated to network, authentication, or authorization.</source>
          <target state="translated">네트워크, 인증 또는 권한과 관련이없는 메모리 부족 오류와 같은 로컬 서버 오류 수</target>
        </trans-unit>
        <trans-unit id="e82abc4ddcf4be20bc0e9d3da08b8ad84ba921dc" translate="yes" xml:space="preserve">
          <source>Number of locks reserved by the transaction.</source>
          <target state="translated">트랜잭션이 예약 한 잠금 수</target>
        </trans-unit>
        <trans-unit id="a5cbb1feed58da537b510ae13c574e52c7777034" translate="yes" xml:space="preserve">
          <source>Number of logical read requests.</source>
          <target state="translated">논리적 읽기 요청 수</target>
        </trans-unit>
        <trans-unit id="fc87ec0ac8e37c7fc068e510b997ef1ee6856686" translate="yes" xml:space="preserve">
          <source>Number of major page faults.</source>
          <target state="translated">주요 페이지 결함 수</target>
        </trans-unit>
        <trans-unit id="6d7608191b2790cc9dc1dc0ae64cb17bcef95b2f" translate="yes" xml:space="preserve">
          <source>Number of merge passes by the sort algorithm performed by the statement. If too high, you may need to increase the &lt;a href=&quot;../server-system-variables/index#sort_buffer_size&quot;&gt;sort_buffer_size&lt;/a&gt;.</source>
          <target state="translated">명령문이 수행 한 정렬 알고리즘에 의한 병합 패스 수 너무 높으면 &lt;a href=&quot;../server-system-variables/index#sort_buffer_size&quot;&gt;sort_buffer_size&lt;/a&gt; 를 늘려야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4e8d18d406763d2331966314d41c713407869622" translate="yes" xml:space="preserve">
          <source>Number of minor page faults.</source>
          <target state="translated">사소한 페이지 결함 수</target>
        </trans-unit>
        <trans-unit id="03f6bda35af8e19520ba38240b4e96e898557bf4" translate="yes" xml:space="preserve">
          <source>Number of months between two periods</source>
          <target state="translated">두 기간 사이의 개월 수</target>
        </trans-unit>
        <trans-unit id="0eba2c605dbe158e9a9222d91600540d5832a91f" translate="yes" xml:space="preserve">
          <source>Number of months between two periods.</source>
          <target state="translated">두 기간 사이의 월 수입니다.</target>
        </trans-unit>
        <trans-unit id="6094c43ea05148ceb5497e8d9a7d7d5005edf6c7" translate="yes" xml:space="preserve">
          <source>Number of not NULL columns in the dynamic columns string</source>
          <target state="translated">동적 열 문자열에서 NULL이 아닌 열 수</target>
        </trans-unit>
        <trans-unit id="9513ed101e596df9a49cc5307035805548f8a7b8" translate="yes" xml:space="preserve">
          <source>Number of on-disk temp tables created by the statement.</source>
          <target state="translated">명령문으로 작성된 온 디스크 임시 테이블 수</target>
        </trans-unit>
        <trans-unit id="15ba8110ab9bb3426210d07b8cc78caa5f027423" translate="yes" xml:space="preserve">
          <source>Number of pages compressed</source>
          <target state="translated">압축 된 페이지 수</target>
        </trans-unit>
        <trans-unit id="3377571ec4f261e3d485e545f4d7d4ac91aa013c" translate="yes" xml:space="preserve">
          <source>Number of pages created since the last printout divided by the time elapsed, giving pages created per second.</source>
          <target state="translated">마지막 인쇄 이후 생성 된 페이지 수를 경과 시간으로 나눈 후 초당 생성 된 페이지 수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e91eced7fba33d0d88c705b9df0c4687ad82596c" translate="yes" xml:space="preserve">
          <source>Number of pages created.</source>
          <target state="translated">작성된 페이지 수</target>
        </trans-unit>
        <trans-unit id="6200cb4f94a2e645a1b760a3b58d19e745474137" translate="yes" xml:space="preserve">
          <source>Number of pages decompressed</source>
          <target state="translated">압축 해제 된 페이지 수</target>
        </trans-unit>
        <trans-unit id="2ad8252dfcfb1282f183ba6e67dabb893ac9c874" translate="yes" xml:space="preserve">
          <source>Number of pages decompressed in the current interval</source>
          <target state="translated">현재 간격에서 압축 해제 된 페이지 수</target>
        </trans-unit>
        <trans-unit id="301414ba6a8afb38593d8e2f66ee8d6c04b88a55" translate="yes" xml:space="preserve">
          <source>Number of pages in the &lt;em&gt;old&lt;/em&gt; sublist.</source>
          <target state="translated">&lt;em&gt;이전&lt;/em&gt; 하위 목록 의 페이지 수</target>
        </trans-unit>
        <trans-unit id="a1ea9e68a2da0c25d0220d5722316999744cce4d" translate="yes" xml:space="preserve">
          <source>Number of pages in the LRU pending flush.</source>
          <target state="translated">LRU 보류 플러시의 페이지 수입니다.</target>
        </trans-unit>
        <trans-unit id="b4991b1e40a54670d66f0cb7fa8fb80088f8ab86" translate="yes" xml:space="preserve">
          <source>Number of pages in the flush list pending flush.</source>
          <target state="translated">플러시 대기중인 플러시 목록의 페이지 수입니다.</target>
        </trans-unit>
        <trans-unit id="de950555749d659f8a83d8668fcafd79a46fb203" translate="yes" xml:space="preserve">
          <source>Number of pages of the size &lt;code&gt;PAGE_SIZE&lt;/code&gt; which are currently free, and thus are available for allocation. This value represents the buffer pool's fragmentation. A totally unfragmented buffer pool has at most 1 free page.</source>
          <target state="translated">현재 사용 가능하고 할당 할 수있는 &lt;code&gt;PAGE_SIZE&lt;/code&gt; 크기의 페이지 수입니다. 이 값은 버퍼 풀의 조각화를 나타냅니다. 완전히 조각화되지 않은 버퍼 풀에는 최대 1 개의 사용 가능한 페이지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="76875744bf57141b730b8d25b30ce01d282f2073" translate="yes" xml:space="preserve">
          <source>Number of pages of the size &lt;code&gt;PAGE_SIZE&lt;/code&gt; which are currently in the buffer pool.</source>
          <target state="translated">현재 버퍼 풀에있는 &lt;code&gt;PAGE_SIZE&lt;/code&gt; 크기의 페이지 수입니다 .</target>
        </trans-unit>
        <trans-unit id="30f98eccd5cfbfd7e54099ab615669f97e06053f" translate="yes" xml:space="preserve">
          <source>Number of pages on disk storing secondary indexes for the table, or &lt;code&gt;NULL&lt;/code&gt; if not statistics yet collected.</source>
          <target state="translated">테이블의 보조 인덱스를 저장하는 디스크의 페이지 수 또는 통계가 아직 수집되지 않은 경우 &lt;code&gt;NULL&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2e2d7444c87dc3b9a2de523aac9a3b2764a9f1dd" translate="yes" xml:space="preserve">
          <source>Number of pages on disk storing the clustered index, holding InnoDB table data in primary key order, or &lt;code&gt;NULL&lt;/code&gt; if not statistics yet collected.</source>
          <target state="translated">InnoDB 테이블 데이터를 기본 키 순서로 유지하고 클러스터 된 인덱스를 저장하는 디스크의 페이지 수 또는 통계가 아직 수집되지 않은 경우 &lt;code&gt;NULL&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="18a559b40ce56bc180c35c3328dfea44af90af0c" translate="yes" xml:space="preserve">
          <source>Number of pages pending decompression.</source>
          <target state="translated">감압 대기중인 페이지 수</target>
        </trans-unit>
        <trans-unit id="a14c7f6e3250f0dbee8a8643af26b6897fddcfea" translate="yes" xml:space="preserve">
          <source>Number of pages read ahead by the read-ahead thread that were later evicted without being accessed by any queries.</source>
          <target state="translated">미리 읽기 스레드가 미리 읽은 페이지 수는 나중에 쿼리에 의해 액세스되지 않고 추방되었습니다.</target>
        </trans-unit>
        <trans-unit id="ce0beae9cbc96101136232fe6a02b498ae095f89" translate="yes" xml:space="preserve">
          <source>Number of pages read ahead.</source>
          <target state="translated">미리 읽은 페이지 수</target>
        </trans-unit>
        <trans-unit id="734e19243f6e4cfef78d0cf382ffa8d8b37aa1b0" translate="yes" xml:space="preserve">
          <source>Number of pages read since the last printout divided by the time elapsed, giving pages read per second.</source>
          <target state="translated">마지막 인쇄 이후 읽은 페이지 수를 경과 시간으로 나눈 후 초당 페이지를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="0bdc318f8726226badf461498e676e0e74b320d2" translate="yes" xml:space="preserve">
          <source>Number of pages read.</source>
          <target state="translated">읽은 페이지 수</target>
        </trans-unit>
        <trans-unit id="915d7fbedad1c0cafa82f3ccb7b62eb5b7c3a852" translate="yes" xml:space="preserve">
          <source>Number of pages sampled for the estimated statistic value.</source>
          <target state="translated">예상 통계 값으로 샘플링 된 페이지 수입니다.</target>
        </trans-unit>
        <trans-unit id="65f6fa4e6774f9a0edad6467b699502ac7679fb6" translate="yes" xml:space="preserve">
          <source>Number of pages written since the last printout divided by the time elapsed, giving pages written per second.</source>
          <target state="translated">마지막 인쇄 이후에 기록 된 페이지 수를 경과 시간으로 나눈 후 초당 기록 된 페이지 수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="30433e890a594823125df879ad86dc92cd4225d2" translate="yes" xml:space="preserve">
          <source>Number of pages written.</source>
          <target state="translated">쓴 페이지 수</target>
        </trans-unit>
        <trans-unit id="a6c6c756cf6af44aedef5ca6b2e93e53a65731fa" translate="yes" xml:space="preserve">
          <source>Number of permanent errors during IP-to-host DNS lookups.</source>
          <target state="translated">IP-to-host DNS 조회 중 영구 오류 수</target>
        </trans-unit>
        <trans-unit id="13f4f3b591ec092f7be4d43950eadf3ebf5e67d2" translate="yes" xml:space="preserve">
          <source>Number of permanent errors during host-to-IP reverse DNS lookups.</source>
          <target state="translated">호스트 -IP 역방향 DNS 조회 중 영구 오류 수</target>
        </trans-unit>
        <trans-unit id="aaa7c8951de81a64a592781e3219b1ebc9745767" translate="yes" xml:space="preserve">
          <source>Number of queries in query cache using this table</source>
          <target state="translated">이 테이블을 사용하는 쿼리 캐시의 쿼리 수</target>
        </trans-unit>
        <trans-unit id="d895e18f4daba9212e704692b5e6084ba15a7c5d" translate="yes" xml:space="preserve">
          <source>Number of queries the user can perform per hour. Zero is unlimited. See &lt;a href=&quot;../grant/index#setting-per-account-resources-limits&quot;&gt;per-account resource limits&lt;/a&gt;.</source>
          <target state="translated">사용자가 시간당 수행 할 수있는 쿼리 수입니다. 제로는 무제한입니다. &lt;a href=&quot;../grant/index#setting-per-account-resources-limits&quot;&gt;계정 별 리소스 제한을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="94a9a1fca7a151709cf0cdbe301707a3a7b0db62" translate="yes" xml:space="preserve">
          <source>Number of read operations</source>
          <target state="translated">읽기 작업 수</target>
        </trans-unit>
        <trans-unit id="7ee94053b305f677a2918508e91f04a953aa0b14" translate="yes" xml:space="preserve">
          <source>Number of record cache pages freed</source>
          <target state="translated">사용 가능한 레코드 캐시 페이지 수</target>
        </trans-unit>
        <trans-unit id="12729676e161b24f9cc02a7b980f5bb4e83c306a" translate="yes" xml:space="preserve">
          <source>Number of records in the table.</source>
          <target state="translated">테이블의 레코드 수</target>
        </trans-unit>
        <trans-unit id="a6087d3576c80c5a46c8fb08bc4bf41aa49d4094" translate="yes" xml:space="preserve">
          <source>Number of records the page contains.</source>
          <target state="translated">페이지에 포함 된 레코드 수</target>
        </trans-unit>
        <trans-unit id="1871377bfa3f02651e85938f750487a7f851ce97" translate="yes" xml:space="preserve">
          <source>Number of replicated transactions that involved changes in multiple (transactional) storage engines, before considering the update of &lt;code&gt;gtid_slave_pos&lt;/code&gt;. These are transactions that were already cross-engine, independent of the GTID position update introduced by replication</source>
          <target state="translated">&lt;code&gt;gtid_slave_pos&lt;/code&gt; 의 업데이트를 고려하기 전에 여러 (트랜잭션) 스토리지 엔진의 변경과 관련된 복제 된 트랜잭션 수입니다 . 이는 복제에 의해 도입 된 GTID 위치 업데이트와 상관없이 이미 교차 엔진 간 트랜잭션입니다.</target>
        </trans-unit>
        <trans-unit id="f14bfd9002fee9b2544c2659d5e5bd5a2361bfb9" translate="yes" xml:space="preserve">
          <source>Number of replicated transactions where the update of the &lt;code&gt;gtid_slave_pos&lt;/code&gt; table had to choose a storage engine that did not otherwise participate in the transaction. This can indicate that setting gtid_pos_auto_engines might be useful.</source>
          <target state="translated">&lt;code&gt;gtid_slave_pos&lt;/code&gt; 테이블 의 업데이트가 다른 방식으로 트랜잭션에 참여하지 않은 스토리지 엔진을 선택 해야하는 복제 된 트랜잭션 수입니다 . 이는 gtid_pos_auto_engines 설정이 유용 할 수 있음을 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b71860b30d809e5d5a8db645987c1e71001205e8" translate="yes" xml:space="preserve">
          <source>Number of result blocks</source>
          <target state="translated">결과 블록 수</target>
        </trans-unit>
        <trans-unit id="92830782f42ce78db36eae420d1bda65df62ad61" translate="yes" xml:space="preserve">
          <source>Number of retried transactions for this connection.</source>
          <target state="translated">이 연결에 대한 재 시도 된 트랜잭션 수입니다.</target>
        </trans-unit>
        <trans-unit id="af1a35f2f04a254ea1b6fe143675c632df5232b3" translate="yes" xml:space="preserve">
          <source>Number of retried transactions for this connection. Returned with &lt;code&gt;SHOW ALL SLAVES STATUS&lt;/code&gt; only.</source>
          <target state="translated">이 연결에 대한 재 시도 된 트랜잭션 수입니다. &lt;code&gt;SHOW ALL SLAVES STATUS&lt;/code&gt; 에서만 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="b3a8c4af9cbb63a02df3474953007f8667b679f4" translate="yes" xml:space="preserve">
          <source>Number of row inserts to perform for each thread. The default is 100.</source>
          <target state="translated">각 스레드에 대해 수행 할 행 삽입 수입니다. 기본값은 100입니다.</target>
        </trans-unit>
        <trans-unit id="97049fd98116699ec789632f4b8f759dbff46c7c" translate="yes" xml:space="preserve">
          <source>Number of rows actually read</source>
          <target state="translated">실제로 읽은 행 수</target>
        </trans-unit>
        <trans-unit id="4ea84253bf9436346c07c9ffbbb688430c3e9ff8" translate="yes" xml:space="preserve">
          <source>Number of rows added or changed in the current transaction.</source>
          <target state="translated">현재 트랜잭션에서 추가 또는 변경된 행 수</target>
        </trans-unit>
        <trans-unit id="607cc9af9762aacd5728fa6442abac2b046cf1de" translate="yes" xml:space="preserve">
          <source>Number of rows affected by an &lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt; or &lt;a href=&quot;../delete/index&quot;&gt;DELETE&lt;/a&gt; (from &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1012-release-notes/&quot;&gt;MariaDB 10.1.2&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt; 또는 &lt;a href=&quot;../delete/index&quot;&gt;DELETE의&lt;/a&gt; 영향을받는 행 수 ( &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1012-release-notes/&quot;&gt;MariaDB 10.1.2&lt;/a&gt; 부터 )</target>
        </trans-unit>
        <trans-unit id="0d0e70575454dbb019117d3cc2a3ed12a7bb0027" translate="yes" xml:space="preserve">
          <source>Number of rows affected by previous statement</source>
          <target state="translated">이전 명령문의 영향을받는 행 수</target>
        </trans-unit>
        <trans-unit id="d3cebf3fd8c2bbb7032d000bf4b6d175d05eec37" translate="yes" xml:space="preserve">
          <source>Number of rows affected by previous statement.</source>
          <target state="translated">이전 명령문의 영향을받는 행 수</target>
        </trans-unit>
        <trans-unit id="2cd4f1c2b0250aa7d804bfa262ebfbb6784e8d84" translate="yes" xml:space="preserve">
          <source>Number of rows affected the statement affected.</source>
          <target state="translated">영향을받는 명령문에 영향을주는 행 수</target>
        </trans-unit>
        <trans-unit id="c93298da58e96e296ec6830d2d3b31ab9571dd05" translate="yes" xml:space="preserve">
          <source>Number of rows containing this word in the index.</source>
          <target state="translated">색인에이 단어를 포함하는 행 수</target>
        </trans-unit>
        <trans-unit id="d2766fede1a28c68b26ca72aae563b9c0e3b81e7" translate="yes" xml:space="preserve">
          <source>Number of rows deleted</source>
          <target state="translated">삭제 된 행 수</target>
        </trans-unit>
        <trans-unit id="39de82355f23273935f46b59d480e2924fb04fa0" translate="yes" xml:space="preserve">
          <source>Number of rows examined.</source>
          <target state="translated">검사 된 행 수</target>
        </trans-unit>
        <trans-unit id="7e565095acd5f5a196699b5f617c668b1687c41f" translate="yes" xml:space="preserve">
          <source>Number of rows in the table (may be an estimate for some storage engines).</source>
          <target state="translated">테이블의 행 수 (일부 스토리지 엔진의 추정치 일 수 있음).</target>
        </trans-unit>
        <trans-unit id="b70607eec9d538fe0e206d2cedcfbc46e6275968" translate="yes" xml:space="preserve">
          <source>Number of rows in the table.</source>
          <target state="translated">테이블의 행 수</target>
        </trans-unit>
        <trans-unit id="e3a8b3f45552fa38ab646ef99b7ce86cb5955e38" translate="yes" xml:space="preserve">
          <source>Number of rows in the table. Some engines, such as &lt;a href=&quot;../innodb/index&quot;&gt;XtraDB and InnoDB&lt;/a&gt; may store an estimate.</source>
          <target state="translated">테이블의 행 수 &lt;a href=&quot;../innodb/index&quot;&gt;XtraDB 및 InnoDB&lt;/a&gt; 와 같은 일부 엔진 은 추정치를 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54424479400053a073483ddc1ec06ed3d594decb" translate="yes" xml:space="preserve">
          <source>Number of rows in the table. Some engines, such as &lt;a href=&quot;../xtradb-and-innodb/index&quot;&gt;XtraDB and InnoDB&lt;/a&gt; may store an estimate.</source>
          <target state="translated">테이블의 행 수 &lt;a href=&quot;../xtradb-and-innodb/index&quot;&gt;XtraDB 및 InnoDB&lt;/a&gt; 와 같은 일부 엔진 은 추정치를 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f45586cda10d5aa205f934dede2f25a7f45e1dde" translate="yes" xml:space="preserve">
          <source>Number of rows inserted</source>
          <target state="translated">삽입 된 행 수</target>
        </trans-unit>
        <trans-unit id="de3932d6f9a7bd36812cd28f409407af629100d7" translate="yes" xml:space="preserve">
          <source>Number of rows modified by statements modifying data.</source>
          <target state="translated">데이터를 수정하는 명령문으로 수정 된 행 수</target>
        </trans-unit>
        <trans-unit id="ac6e74f1e1c05be6d16926c850a6ff0d934b84dd" translate="yes" xml:space="preserve">
          <source>Number of rows read during the statement's execution.</source>
          <target state="translated">명령문 실행 중 읽은 행 수</target>
        </trans-unit>
        <trans-unit id="9fbc85c8750fc5ce4960c990a4cc28c9ea837a8e" translate="yes" xml:space="preserve">
          <source>Number of rows read from all Mroonga tables.</source>
          <target state="translated">모든 Mroonga 테이블에서 읽은 행 수</target>
        </trans-unit>
        <trans-unit id="c108853e464ce381389cd73e89ef79b9e710f10d" translate="yes" xml:space="preserve">
          <source>Number of rows returned.</source>
          <target state="translated">리턴 된 행 수</target>
        </trans-unit>
        <trans-unit id="5eed060073d093dcf336348c6b037f0c5e8fd637" translate="yes" xml:space="preserve">
          <source>Number of rows selected</source>
          <target state="translated">선택된 행 수</target>
        </trans-unit>
        <trans-unit id="38d0e2a900b9853e43e431fb7991a206f43d34ba" translate="yes" xml:space="preserve">
          <source>Number of rows sent.</source>
          <target state="translated">전송 된 행 수</target>
        </trans-unit>
        <trans-unit id="f51d46e57a9bd7e87b05ab70b41b67d9b477ee68" translate="yes" xml:space="preserve">
          <source>Number of rows sorted by the statement.</source>
          <target state="translated">명령문으로 정렬 된 행 수</target>
        </trans-unit>
        <trans-unit id="b71e22a269165d80472a50adf1191cd97dfcda72" translate="yes" xml:space="preserve">
          <source>Number of rows the current transaction has locked. locked by this transaction. An approximation, and may include rows not visible to the current transaction that are delete-marked but physically present.</source>
          <target state="translated">현재 트랜잭션이 잠근 행 수입니다. 이 거래에 의해 잠겨 있습니다. 근사치로, 삭제 표시되어 있지만 실제로 존재하는 현재 트랜잭션에 보이지 않는 행을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3dbd618c62e5509f58ea0ed9df0ba4637abdec45" translate="yes" xml:space="preserve">
          <source>Number of rows updated</source>
          <target state="translated">업데이트 된 행 수</target>
        </trans-unit>
        <trans-unit id="126117236dc947f7533989386020ae4d0f6d117f" translate="yes" xml:space="preserve">
          <source>Number of rows written into Mroonga tables.</source>
          <target state="translated">Mroonga 테이블에 기록 된 행 수</target>
        </trans-unit>
        <trans-unit id="5304e50052b52157ad6065f0bb3172a41911a8cc" translate="yes" xml:space="preserve">
          <source>Number of secondary indexes to add to auto-generated tables. By default, none are added.</source>
          <target state="translated">자동 생성 된 테이블에 추가 할 보조 인덱스 수입니다. 기본적으로 아무것도 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3f9662e96f8401736736a98daf54f4e16007f140" translate="yes" xml:space="preserve">
          <source>Number of seconds before connection timeout. Defaults to zero.</source>
          <target state="translated">연결 시간이 초과되기 전의 시간 (초)입니다. 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="5dc99480c8d228eeb694e6bc2d17a72a0ee9629a" translate="yes" xml:space="preserve">
          <source>Number of seconds since year 0</source>
          <target state="translated">0 년 이후의 초 수</target>
        </trans-unit>
        <trans-unit id="5a066f02db0d71c4fea02707ae61fb7436452279" translate="yes" xml:space="preserve">
          <source>Number of seconds since year 0.</source>
          <target state="translated">0 년 이후의 초 수</target>
        </trans-unit>
        <trans-unit id="8c4b4b2610d70bd20ae3b95f9061bc4e3686727a" translate="yes" xml:space="preserve">
          <source>Number of simultaneous connections that can be accepted from the same account; if it is 0, &lt;code&gt;max_connections&lt;/code&gt; will be used instead; if &lt;code&gt;max_connections&lt;/code&gt; is 0, there is no limit for this account's simultaneous connections.</source>
          <target state="translated">동일한 계정에서 수락 할 수있는 동시 연결 수 0이면 &lt;code&gt;max_connections&lt;/code&gt; 가 대신 사용됩니다. 경우 &lt;code&gt;max_connections&lt;/code&gt; 0이 계정의 동시 접속에 대한 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="4fb583c7d0e3decd270519daf43bcfc2978b4f36" translate="yes" xml:space="preserve">
          <source>Number of simultaneous connections the account can have. Zero is unlimited. See &lt;a href=&quot;../grant/index#setting-per-account-resources-limits&quot;&gt;per-account resource limits&lt;/a&gt;.</source>
          <target state="translated">계정이 가질 수있는 동시 연결 수 제로는 무제한입니다. &lt;a href=&quot;../grant/index#setting-per-account-resources-limits&quot;&gt;계정 별 리소스 제한을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8d3ca7e83140556c21a3aa12628fe7cac62a0d45" translate="yes" xml:space="preserve">
          <source>Number of sorts performed by the statement which used a full table scan.</source>
          <target state="translated">전체 테이블 스캔을 사용한 명령문에 의해 수행 된 정렬 수</target>
        </trans-unit>
        <trans-unit id="375d20625d737de928a0899f8abf5a920d61a82b" translate="yes" xml:space="preserve">
          <source>Number of sorts performed by the statement which used a range.</source>
          <target state="translated">범위를 사용한 명령문에 의해 수행 된 정렬 수</target>
        </trans-unit>
        <trans-unit id="031c5d0aaf7d2a0638862629cc5270da5d41c9cf" translate="yes" xml:space="preserve">
          <source>Number of spin rounds for a mutex, or &lt;code&gt;NULL&lt;/code&gt; if spin rounds are not used, or spinning is not instrumented.</source>
          <target state="translated">뮤텍스의 스핀 라운드 수 또는 &lt;code&gt;NULL&lt;/code&gt; 스핀 라운드가 사용되지 않거나 스피닝이 계측되지 않은 경우 입니다.</target>
        </trans-unit>
        <trans-unit id="f4066206c6fb82952149f9a8a6d0bc0c617a195b" translate="yes" xml:space="preserve">
          <source>Number of statements that the account can issue per hour (including updates)</source>
          <target state="translated">계정이 시간당 발행 할 수있는 진술 수 (업데이트 포함)</target>
        </trans-unit>
        <trans-unit id="2a4677924c8461ac62bce57477962ec6a27edc43" translate="yes" xml:space="preserve">
          <source>Number of statements to execute before committing. The default is 0.</source>
          <target state="translated">커밋하기 전에 실행할 명령문 수 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="f58fe536a38f81dab7a22f9b4e6b0ca8fbb4b675" translate="yes" xml:space="preserve">
          <source>Number of summarized events</source>
          <target state="translated">요약 된 이벤트 수</target>
        </trans-unit>
        <trans-unit id="5cd7b66251879270819d00ad7d2f72cc24cf620d" translate="yes" xml:space="preserve">
          <source>Number of summarized events and the sum of the &lt;code&gt;x_READ&lt;/code&gt; and &lt;code&gt;x_WRITE&lt;/code&gt; columns.</source>
          <target state="translated">요약 된 이벤트 수 및 &lt;code&gt;x_READ&lt;/code&gt; 및 &lt;code&gt;x_WRITE&lt;/code&gt; 열의 합계</target>
        </trans-unit>
        <trans-unit id="3aa0d32978f45eac31ac0e9c5693c5b7214ab29a" translate="yes" xml:space="preserve">
          <source>Number of summarized events, which includes all timed and untimed events.</source>
          <target state="translated">모든 시간 지정 및 시간 지정되지 않은 이벤트를 포함하는 요약 된 이벤트 수입니다.</target>
        </trans-unit>
        <trans-unit id="b3fd116f99cfd774f98fc182623d68320caa82ff" translate="yes" xml:space="preserve">
          <source>Number of swaps.</source>
          <target state="translated">스왑 수</target>
        </trans-unit>
        <trans-unit id="b2c75d979aa32e693696be0c3dae8224a0a78b51" translate="yes" xml:space="preserve">
          <source>Number of table instances being used.</source>
          <target state="translated">사용중인 테이블 인스턴스 수</target>
        </trans-unit>
        <trans-unit id="017699dc753183d1a520bdec5c0948a05ff975bc" translate="yes" xml:space="preserve">
          <source>Number of table scans</source>
          <target state="translated">테이블 스캔 수</target>
        </trans-unit>
        <trans-unit id="c87f0dfca4b4355b867a9df96a4e68dfb9d8d0bf" translate="yes" xml:space="preserve">
          <source>Number of temp tables created by the statement.</source>
          <target state="translated">명령문으로 작성된 임시 테이블 수</target>
        </trans-unit>
        <trans-unit id="fbd59730b7a56c3e0e8fb9f12eb3ae07d9153b9a" translate="yes" xml:space="preserve">
          <source>Number of the current row within its partition, counting from 1</source>
          <target state="translated">파티션 내 현재 행 수 (1부터 계산)</target>
        </trans-unit>
        <trans-unit id="2dd7d0ccf552229fbf1fc94da8e34fa3cc62e557" translate="yes" xml:space="preserve">
          <source>Number of threads currently scrubbing the tablespace.</source>
          <target state="translated">현재 테이블 스페이스를 스크러빙하는 스레드 수</target>
        </trans-unit>
        <trans-unit id="8e9e04c0c2ca95b6756456e7efa5130088f27f99" translate="yes" xml:space="preserve">
          <source>Number of threads in the thread pool. In rare cases, this can be slightly higher than &lt;code&gt;&lt;a href=&quot;../thread-pool-system-status-variables/index#thread_pool_max_threads&quot;&gt;thread_pool_max_threads&lt;/a&gt;&lt;/code&gt;, because each thread group needs at least two threads (i.e. at least one worker thread and at least one listener thread) to prevent deadlocks.</source>
          <target state="translated">스레드 풀의 스레드 수 드문 경우지만 &lt;code&gt;&lt;a href=&quot;../thread-pool-system-status-variables/index#thread_pool_max_threads&quot;&gt;thread_pool_max_threads&lt;/a&gt;&lt;/code&gt; 보다 약간 높을 수 있습니다 각 스레드 그룹이 교착 상태를 방지하기 위해 두 개 이상의 스레드 (즉, 하나 이상의 작업자 스레드와 하나 이상의 리스너 스레드)가 필요하기 때문에 .</target>
        </trans-unit>
        <trans-unit id="feae845368e822352a3080c94142b0b18eb0f059" translate="yes" xml:space="preserve">
          <source>Number of timer units by which timed values increase each time.</source>
          <target state="translated">시간 값이 매번 증가하는 타이머 단위 수입니다.</target>
        </trans-unit>
        <trans-unit id="43084cd331ab20ab9c6f5f0a48d7623874222f20" translate="yes" xml:space="preserve">
          <source>Number of timer units per second. Dependent on the processor speed.</source>
          <target state="translated">초당 타이머 단위 수 프로세서 속도에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="d80dc81a72b2e3ccabbcbd0d6db23d09bc356ab1" translate="yes" xml:space="preserve">
          <source>Number of times InnoDB has had to request a key from the &lt;a href=&quot;../encryption-key-management/index&quot;&gt;encryption key management plugin&lt;/a&gt;. The three most recent keys are cached internally.</source>
          <target state="translated">InnoDB가 &lt;a href=&quot;../encryption-key-management/index&quot;&gt;암호화 키 관리 플러그인&lt;/a&gt; 에서 키를 요청한 횟수 입니다. 가장 최근의 세 키는 내부적으로 캐시됩니다.</target>
        </trans-unit>
        <trans-unit id="dc75e70f3f7ac425b22636546b5aa97a6c5b91ec" translate="yes" xml:space="preserve">
          <source>Number of times key buffer was refilled (not counting the initial fill)</source>
          <target state="translated">키 버퍼가 리필 된 횟수 (초기 채우기를 계산하지 않음)</target>
        </trans-unit>
        <trans-unit id="d4f32bcd2d2e3a96a0ceb4bfbd0d6e5f70cabe5b" translate="yes" xml:space="preserve">
          <source>Number of times pushed index condition was checked.</source>
          <target state="translated">푸시 된 인덱스 조건을 확인한 횟수입니다.</target>
        </trans-unit>
        <trans-unit id="ab27b20db7758281d411ed76abe37a336ed618f1" translate="yes" xml:space="preserve">
          <source>Number of times rowid buffer was refilled (not counting the initial fill)</source>
          <target state="translated">rowid 버퍼가 리필 된 횟수 (초기 채우기를 계산하지 않음)</target>
        </trans-unit>
        <trans-unit id="def0d694a90f0e0869535407f59741b68dad6465" translate="yes" xml:space="preserve">
          <source>Number of times the condition was matched.</source>
          <target state="translated">조건이 일치 한 횟수입니다.</target>
        </trans-unit>
        <trans-unit id="24a82d035218fd0e351ae856ad0195a1323a7e59" translate="yes" xml:space="preserve">
          <source>Number of times to retry on timeout/unavailable failures</source>
          <target state="translated">제한 시간 초과 / 사용할 수없는 장애에 대한 재시도 횟수</target>
        </trans-unit>
        <trans-unit id="7c458354369a033ba7bb5ec46a3eb313dd546153" translate="yes" xml:space="preserve">
          <source>Number of times to run the tests.</source>
          <target state="translated">테스트 실행 횟수</target>
        </trans-unit>
        <trans-unit id="40375152c972e86d5c6ebc497aea9270e9cc258a" translate="yes" xml:space="preserve">
          <source>Number of times waited for another transaction</source>
          <target state="translated">다른 거래를 기다린 횟수</target>
        </trans-unit>
        <trans-unit id="5c9630b257ff2b0827de4c27207a0c9418b36ef0" translate="yes" xml:space="preserve">
          <source>Number of transactions committed</source>
          <target state="translated">커밋 된 트랜잭션 수</target>
        </trans-unit>
        <trans-unit id="e2a3e49d5a6e7c5bcba3b6da894638acffab0839" translate="yes" xml:space="preserve">
          <source>Number of transactions rolled back</source>
          <target state="translated">롤백 된 트랜잭션 수</target>
        </trans-unit>
        <trans-unit id="0d222f0dba2fc506d79fdda54b2d783128db2dc7" translate="yes" xml:space="preserve">
          <source>Number of transactions still to be cleaned up. This also includes all the currently running transactions. Cleanup means that the Sweeper thread must still scan the transcation and collect/mark any &quot;garbage&quot; left by the transaction. Garbage is, for example, versions of rows that are no longer visiable by any transaction.</source>
          <target state="translated">여전히 정리할 트랜잭션 수입니다. 여기에는 현재 실행중인 모든 트랜잭션도 포함됩니다. 정리는 스위퍼 스레드가 여전히 변환을 스캔하고 트랜잭션이 남긴 &quot;쓰레기&quot;를 수집 / 표시해야 함을 의미합니다. 가비지는 예를 들어 트랜잭션에서 더 이상 볼 수없는 행 버전입니다.</target>
        </trans-unit>
        <trans-unit id="94d5f031cd56b94b5a5a80b3e2096a877e458b99" translate="yes" xml:space="preserve">
          <source>Number of transactions that changed data in multiple (transactional) storage engines. If this is significantly larger than Rpl_transactions_multi_engine, it indicates that setting &lt;code&gt;gtid_pos_auto_engines&lt;/code&gt; could reduce the need for cross-engine transactions.</source>
          <target state="translated">여러 (트랜잭션) 스토리지 엔진에서 데이터를 변경 한 트랜잭션 수 이것이 Rpl_transactions_multi_engine보다 상당히 큰 경우, gtid_pos_auto_engines를 설정 &lt;code&gt;gtid_pos_auto_engines&lt;/code&gt; 교차 엔진 트랜잭션의 필요성이 줄어들 수 있음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="15f361aca592b42e8e54f9ab2ae382e5ae87f334" translate="yes" xml:space="preserve">
          <source>Number of transient errors during IP-to-host DNS lookups.</source>
          <target state="translated">IP-to-host DNS 조회 중 일시적 오류 수.</target>
        </trans-unit>
        <trans-unit id="60fd056b4dac4d6e48a1b47602f698e6e394220d" translate="yes" xml:space="preserve">
          <source>Number of transient errors during host-to-IP reverse DNS lookups.</source>
          <target state="translated">호스트 -IP 역방향 DNS 조회 중 일시적 오류 수.</target>
        </trans-unit>
        <trans-unit id="f829ca140d2dbb91f05aeabc609fe32cfca70171" translate="yes" xml:space="preserve">
          <source>Number of trim operations</source>
          <target state="translated">트림 작업 수</target>
        </trans-unit>
        <trans-unit id="bb6fd84f6fa9e757123bc7121fba40d84614af82" translate="yes" xml:space="preserve">
          <source>Number of trim operations saved</source>
          <target state="translated">저장된 트림 작업 수</target>
        </trans-unit>
        <trans-unit id="b4eb374099945e772d7afc1b00389768f8085bdc" translate="yes" xml:space="preserve">
          <source>Number of unique queries to generate for &lt;code&gt;auto-generate-sql-write-number&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;auto-generate-sql-write-number&lt;/code&gt; 에 대해 생성 할 고유 쿼리 수 입니다.</target>
        </trans-unit>
        <trans-unit id="4834d0e584931efb75ea27f9a946bb6c99662dfb" translate="yes" xml:space="preserve">
          <source>Number of unique queries to generate for automatic tests. For example, if you run a key test that performs 1000 selects, you can use this option with a value of 1000 to run 1000 unique queries, or with a value of 50 to perform 50 different selects. The default is 10.</source>
          <target state="translated">자동 테스트를 위해 생성 할 고유 쿼리 수입니다. 예를 들어, 1000 개의 선택을 수행하는 키 테스트를 실행하는 경우이 옵션을 1000의 값으로 사용하여 1000 개의 고유 쿼리를 실행하거나 50의 값으로 50 개의 다른 선택을 수행 할 수 있습니다. 기본값은 10입니다.</target>
        </trans-unit>
        <trans-unit id="20c046098e202bf5fdc4067d455ea6bb04c09957" translate="yes" xml:space="preserve">
          <source>Number of unknown errors that cannot be allocated to another column.</source>
          <target state="translated">다른 열에 할당 할 수없는 알 수없는 오류 수</target>
        </trans-unit>
        <trans-unit id="819b9186850f109da7c5f751d6cbac553db89650" translate="yes" xml:space="preserve">
          <source>Number of updates (not queries) that the account can issue per hour</source>
          <target state="translated">시간당 계정에서 발행 할 수있는 업데이트 수 (쿼리 아님)</target>
        </trans-unit>
        <trans-unit id="fecfcb942748290cdac90d15eff580d1b73edc4e" translate="yes" xml:space="preserve">
          <source>Number of updates the user can perform per hour. Zero is unlimited. See &lt;a href=&quot;../grant/index#setting-per-account-resources-limits&quot;&gt;per-account resource limits&lt;/a&gt;.</source>
          <target state="translated">사용자가 시간당 수행 할 수있는 업데이트 수 제로는 무제한입니다. &lt;a href=&quot;../grant/index#setting-per-account-resources-limits&quot;&gt;계정 별 리소스 제한을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fe3068f3ca514fab1aff9cd9e552bf6c58b4270b" translate="yes" xml:space="preserve">
          <source>Number of used blocks. Will match the number of rows for fixed or optimized tables.</source>
          <target state="translated">사용 된 블록 수 고정 또는 최적화 된 테이블의 행 수와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="94382e8c56b800ea6d18f6fe7bfdf49dd47e75d5" translate="yes" xml:space="preserve">
          <source>Number of user records on the page.</source>
          <target state="translated">페이지의 사용자 레코드 수</target>
        </trans-unit>
        <trans-unit id="a984fe23d32c5d80ef20b6a367bed632274a241e" translate="yes" xml:space="preserve">
          <source>Number of values that should be cached. 0 if no &lt;code&gt;CACHE&lt;/code&gt;. The underlying table will be updated first time a new sequence number is generated and each time the cache runs out.</source>
          <target state="translated">캐시해야하는 값의 수입니다. &lt;code&gt;CACHE&lt;/code&gt; 가 없으면 0 입니다. 기본 테이블은 새 시퀀스 번호가 처음 생성 될 때와 캐시가 소진 될 때마다 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="f65db7d8834a06add869d259b596e90a487c8a56" translate="yes" xml:space="preserve">
          <source>Number of values that should be cached. 0 if no CACHE. The underlying table will be updated first time a new sequence number is generated and each time the cache runs out.</source>
          <target state="translated">캐시해야하는 값의 수입니다. 캐시가 없으면 0입니다. 기본 테이블은 새 시퀀스 번호가 처음 생성 될 때와 캐시가 소진 될 때마다 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="670b1eece5adae94311dde1613b7ab5683969df0" translate="yes" xml:space="preserve">
          <source>Number of voluntary context switches.</source>
          <target state="translated">자발적 컨텍스트 전환 수</target>
        </trans-unit>
        <trans-unit id="35444c92d92faa591d785a3e624828cf3dd7471c" translate="yes" xml:space="preserve">
          <source>Number of warnings from the diagnostics area.</source>
          <target state="translated">진단 영역의 경고 수</target>
        </trans-unit>
        <trans-unit id="34cbef2f7fe0377a4d28aec8e4b8ba21c182c848" translate="yes" xml:space="preserve">
          <source>Number stored as a string, right justified, and padded with blanks to the width of the field.</source>
          <target state="translated">숫자는 문자열로 저장되고 오른쪽 자리 맞추기되며 필드 너비에 공백으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="4d027d9e98c1602e05ee3dd55faafac298204782" translate="yes" xml:space="preserve">
          <source>Numbers stored in &lt;a href=&quot;../varchar/index&quot;&gt;VARCHAR&lt;/a&gt; do not compare 'correctly', especially for range tests.</source>
          <target state="translated">&lt;a href=&quot;../varchar/index&quot;&gt;VARCHAR에&lt;/a&gt; 저장된 숫자 는 특히 범위 테스트에서 '정확하게'비교되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="30a62380404b3b267a5c4e21b5e111455d09031e" translate="yes" xml:space="preserve">
          <source>Numeric</source>
          <target state="translated">Numeric</target>
        </trans-unit>
        <trans-unit id="3ed9ce3f835377d0e306efa39c8034dafd01e7bf" translate="yes" xml:space="preserve">
          <source>Numeric ASCII value of leftmost character</source>
          <target state="translated">가장 왼쪽 문자의 숫자 ASCII 값</target>
        </trans-unit>
        <trans-unit id="9b13e1ee5ee1c7220640039187c34f0f6fce564d" translate="yes" xml:space="preserve">
          <source>Numeric ASCII value of leftmost character.</source>
          <target state="translated">가장 왼쪽 문자의 숫자 ASCII 값.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
