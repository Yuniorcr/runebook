<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="mariadb">
    <body>
      <group id="mariadb">
        <trans-unit id="7f0c4caff6f8d87fa5ff9f443b25145221874b54" translate="yes" xml:space="preserve">
          <source>In mode 1, auto-increment values are never re-issued because PBXT automatically incrementing the table level AUTO_INCREMENT table option. The AUTO_INCREMENT table is incremented in steps of 100. Since this requires the table file to be flushed to disk, this can influence performance.</source>
          <target state="translated">모드 1에서는 PBXT가 테이블 레벨 AUTO_INCREMENT 테이블 옵션을 자동으로 증가시키기 때문에 자동 증가 값이 다시 발행되지 않습니다. AUTO_INCREMENT 테이블은 100 단계로 증가합니다. 테이블 파일을 디스크로 플러시해야하므로 성능에 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7207f47867ef1408e0e181ba065e7c6026750d1d" translate="yes" xml:space="preserve">
          <source>In most cases PCRE is backward compatible with the old POSIX 1003.2 compliant regexp library (see &lt;a href=&quot;../regular-expressions-overview/index&quot;&gt;Regular Expressions Overview&lt;/a&gt;), so you won't need to change your applications that use SQL queries with the REGEXP/RLIKE predicate.</source>
          <target state="translated">대부분의 경우 PCRE는 이전 POSIX 1003.2 호환 regexp 라이브러리 ( &lt;a href=&quot;../regular-expressions-overview/index&quot;&gt;정규 표현식 개요&lt;/a&gt; 참조)와 역 호환 되므로 REGEXP / RLIKE 술어와 함께 SQL 조회를 사용하는 애플리케이션을 변경할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="187d967d792e8095b7abf5acc7bedb42beba2333" translate="yes" xml:space="preserve">
          <source>In most cases the problem is to correctly set the S3 connection variables.</source>
          <target state="translated">대부분의 경우 문제는 S3 연결 변수를 올바르게 설정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7879b451c293222bc34fdf1d900991115fabadf0" translate="yes" xml:space="preserve">
          <source>In most cases this should be a fast operation (depending of course on the number of tables)</source>
          <target state="translated">대부분의 경우 이것은 빠른 작업이어야합니다 (물론 테이블 수에 따라 다름)</target>
        </trans-unit>
        <trans-unit id="034e3b6338bcfab501a7818f8f2c851f1a93693d" translate="yes" xml:space="preserve">
          <source>In most cases this should be a fast operation (depending of course on the number of tables).</source>
          <target state="translated">대부분의 경우 이는 테이블 수에 따라 빠른 작업이어야합니다.</target>
        </trans-unit>
        <trans-unit id="3f68585235f09cce603e681e5700fc4b4f82fca2" translate="yes" xml:space="preserve">
          <source>In most cases, &lt;code&gt;mysql_upgrade&lt;/code&gt; should just take a few seconds. The main work of &lt;code&gt;mysql_upgrade&lt;/code&gt; is to:</source>
          <target state="translated">대부분의 경우 &lt;code&gt;mysql_upgrade&lt;/code&gt; 는 몇 초 밖에 걸리지 않습니다. &lt;code&gt;mysql_upgrade&lt;/code&gt; 의 주요 작업 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3675e5a683e2bd82fbceb2fb3d65ff68f70ff531" translate="yes" xml:space="preserve">
          <source>In most cases, a ColumnStore table works just as any other MariaDB table. There are however a few differences.</source>
          <target state="translated">대부분의 경우 ColumnStore 테이블은 다른 MariaDB 테이블과 동일하게 작동합니다. 그러나 몇 가지 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="12e07689efeb97244cfdb1d11c7343f6dc09c654" translate="yes" xml:space="preserve">
          <source>In most cases, functions will return NULL if any of the parameters are NULL. There are also functions specifically for handling NULLs. These include &lt;a href=&quot;../ifnull/index&quot;&gt;IFNULL()&lt;/a&gt;, &lt;a href=&quot;../nullif/index&quot;&gt;NULLIF()&lt;/a&gt; and &lt;a href=&quot;../coalesce/index&quot;&gt;COALESCE()&lt;/a&gt;.</source>
          <target state="translated">대부분의 경우 매개 변수 중 하나라도 NULL이면 함수는 NULL을 반환합니다. NULL 처리를위한 기능도 있습니다. 여기에는 &lt;a href=&quot;../ifnull/index&quot;&gt;IFNULL ()&lt;/a&gt; , &lt;a href=&quot;../nullif/index&quot;&gt;NULLIF ()&lt;/a&gt; 및 &lt;a href=&quot;../coalesce/index&quot;&gt;COALESCE ()가 포함&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="39544d02fab99a467eb09d0d269a711b2adb66f9" translate="yes" xml:space="preserve">
          <source>In most cases, yes. MariaDB tries to keep API compatibility with MySQL, even across major versions.</source>
          <target state="translated">대부분의 경우 그렇습니다. MariaDB는 주요 버전에서도 MySQL과 API 호환성을 유지하려고합니다.</target>
        </trans-unit>
        <trans-unit id="104b651fa496ec52ed1ab746789381116e162695" translate="yes" xml:space="preserve">
          <source>In normal operations, the only variables you have to consider are:</source>
          <target state="translated">정상적인 작업에서 고려해야 할 유일한 변수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b8e743cb1d3670164601c2e6782c1b56f3e61b86" translate="yes" xml:space="preserve">
          <source>In older versions of MariaDB Cluster there was a 2GB limit on the size of the transaction you could run. The node waits on the transaction commit before performing replication and certification. With large transactions, long running writes, and changes to huge data-sets, there was a greater possibility of a conflict forcing rollback on an expensive operation.</source>
          <target state="translated">이전 버전의 MariaDB 클러스터에서는 실행할 수있는 트랜잭션 크기에 2GB 제한이있었습니다. 노드는 트랜잭션 커밋을 기다렸다가 복제 및 인증을 수행합니다. 대규모 트랜잭션, 장기 실행 쓰기 및 대규모 데이터 세트 변경으로 인해 고가의 작업에서 롤백을 강제로 수행 할 가능성이 커졌습니다.</target>
        </trans-unit>
        <trans-unit id="5cf7437c362de127090660323a4631c0591642db" translate="yes" xml:space="preserve">
          <source>In older versions of MariaDB, if you have recently changed the value of the &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encrypt_tables&quot;&gt;innodb_encrypt_tables&lt;/a&gt;&lt;/code&gt; system variable, then you must ensure that any pending background encryption or decryption operations are complete before disabling key rotation. You can check the status of background encryption operations by querying the &lt;code&gt;&lt;a href=&quot;../information-schema-innodb_tablespaces_encryption-table/index&quot;&gt;INNODB_TABLESPACES_ENCRYPTION&lt;/a&gt;&lt;/code&gt; table in the &lt;code&gt;&lt;a href=&quot;../information-schema/index&quot;&gt;information_schema&lt;/a&gt;&lt;/code&gt; database.</source>
          <target state="translated">이전 버전의 MariaDB에서 최근에 &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encrypt_tables&quot;&gt;innodb_encrypt_tables&lt;/a&gt;&lt;/code&gt; 시스템 변수 의 값을 변경 한 경우 키 순환을 비활성화하기 전에 보류중인 백그라운드 암호화 또는 암호 해독 작업이 완료되었는지 확인해야합니다. &lt;code&gt;&lt;a href=&quot;../information-schema/index&quot;&gt;information_schema&lt;/a&gt;&lt;/code&gt; 데이터베이스 에서 &lt;code&gt;&lt;a href=&quot;../information-schema-innodb_tablespaces_encryption-table/index&quot;&gt;INNODB_TABLESPACES_ENCRYPTION&lt;/a&gt;&lt;/code&gt; 테이블 을 쿼리하여 백그라운드 암호화 작업의 상태를 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c24ddf5af64d9db82247811fd51941a441af860b" translate="yes" xml:space="preserve">
          <source>In older versions of MariaDB, spatial index encryption is unsupported. Tables that contain spatial indexes store them unencrypted.</source>
          <target state="translated">이전 버전의 MariaDB에서는 공간 인덱스 암호화가 지원되지 않습니다. 공간 인덱스가 포함 된 테이블은 암호화되지 않은 상태로 저장합니다.</target>
        </trans-unit>
        <trans-unit id="356b4509308bb953d67797195ba555bda190c3c2" translate="yes" xml:space="preserve">
          <source>In older versions, after installing the plugin, &lt;a href=&quot;../show-processlist/index&quot;&gt;SHOW PROCESSLIST&lt;/a&gt; would show the HandlerSocket worker threads. With the latest versions, you first need to configure some settings. All &lt;a href=&quot;../handlersocket-configuration-options/index&quot;&gt;HandlerSocket configuration options&lt;/a&gt; are placed in the [mysqld] section of your my.cnf file.</source>
          <target state="translated">이전 버전에서는 플러그인을 설치 한 후 &lt;a href=&quot;../show-processlist/index&quot;&gt;SHOW PROCESSLIST&lt;/a&gt; 에 HandlerSocket 작업자 스레드가 표시됩니다. 최신 버전에서는 먼저 일부 설정을 구성해야합니다. 모든 &lt;a href=&quot;../handlersocket-configuration-options/index&quot;&gt;HandlerSocket 구성 옵션&lt;/a&gt; 은 my.cnf 파일의 [mysqld] 섹션에 있습니다.</target>
        </trans-unit>
        <trans-unit id="909526f00c8f8fe81e484e40115ac0506407e958" translate="yes" xml:space="preserve">
          <source>In order for InnoDB to store some variable-length columns on overflow pages, the length of those columns may need to be increased.</source>
          <target state="translated">InnoDB가 오버플로 페이지에 일부 가변 길이 열을 저장하려면 해당 열의 길이를 늘려야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8279964f7699f9d9ad5aa2578e08abca45676461" translate="yes" xml:space="preserve">
          <source>In order for MariaDB Server to use TLS, it needs to be compiled with TLS support. All MariaDB packages distributed by MariaDB Foundation and MariaDB Corporation are compiled with TLS support.</source>
          <target state="translated">MariaDB 서버가 TLS를 사용하려면 TLS 지원으로 컴파일해야합니다. MariaDB Foundation 및 MariaDB Corporation에서 배포 한 모든 MariaDB 패키지는 TLS 지원으로 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="3aa94f0ea7fcb34f2087f3fc96017c3e9d3eca6f" translate="yes" xml:space="preserve">
          <source>In order for MariaDB to start, this new user will have to enable the master key, then the DBA can start MariaDB, and this user can once again disable the master key after the service has started. Note that in this workflow, MariaDB will be unable to create new encryption keys, such as would be done when a user creates a table that refers to a non-existent key ID. The AWS KMS plugin will encounter an error if it tries to generate a new encryption key while the master key is disabled. In that scenario, the key administrator would have to enable the key before the operation could succeed. Here's what you should expect to see in the journal if MariaDB tries to interact with a disabled master key:</source>
          <target state="translated">MariaDB를 시작하려면이 새 사용자가 마스터 키를 활성화 한 다음 DBA가 MariaDB를 시작할 수 있으며이 사용자는 서비스가 시작된 후 다시 마스터 키를 비활성화 할 수 있습니다. 이 워크 플로우에서 MariaDB는 사용자가 존재하지 않는 키 ID를 참조하는 테이블을 작성할 때와 같이 새 암호화 키를 작성할 수 없습니다. 마스터 키가 비활성화 된 상태에서 새 암호화 키를 생성하려고하면 AWS KMS 플러그인에 오류가 발생합니다. 이 시나리오에서 키 관리자는 작업이 성공하기 전에 키를 활성화해야합니다. MariaDB가 비활성화 된 마스터 키와 상호 작용하려는 경우 저널에서 볼 수있는 내용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a7f1d48da9b9a692fcac5ccbf8c5414f0a60725b" translate="yes" xml:space="preserve">
          <source>In order for key rotation to work, both the backend key management service (KMS) and the corresponding &lt;a href=&quot;../encryption-key-management/index&quot;&gt;key management and encryption plugin&lt;/a&gt; have to support key rotation. See &lt;a href=&quot;../encryption-key-management/index#support-for-key-rotation-in-encryption-plugins&quot;&gt;Encryption Key Management: Support for Key Rotation in Encryption Plugins&lt;/a&gt; to determine which plugins currently support key rotation.</source>
          <target state="translated">키 교체가 작동하려면 백엔드 키 관리 서비스 (KMS)와 해당 &lt;a href=&quot;../encryption-key-management/index&quot;&gt;키 관리 및 암호화 플러그인&lt;/a&gt; 이 모두 키 교체를 지원해야합니다. 현재 키 회전을 지원하는 플러그인을 확인하려면 &lt;a href=&quot;../encryption-key-management/index#support-for-key-rotation-in-encryption-plugins&quot;&gt;암호화 키 관리 : 암호화 플러그인의 키 회전 지원을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a6e25b42ec85e89fa23b26c001d74c24064955fc" translate="yes" xml:space="preserve">
          <source>In order for this to work, you need to configure the data nodes to accept queries from the Spider node and you need to configure the Spider node to use the data nodes as remote storage.</source>
          <target state="translated">이 작업을 수행하려면 Spider 노드의 쿼리를 수락하도록 데이터 노드를 구성해야하며 데이터 노드를 원격 저장소로 사용하도록 Spider 노드를 구성해야합니다.</target>
        </trans-unit>
        <trans-unit id="3b42ec48f4d1815a51bef4820e2a682f4d3b095f" translate="yes" xml:space="preserve">
          <source>In order to accomplish this, ProcMgr uses the Process Monitor, or ProcMon on each Performance Module to keep track of MariaDB ColumnStore processes.</source>
          <target state="translated">이를 위해 ProcMgr은 프로세스 모니터 또는 각 성능 모듈에서 ProcMon을 사용하여 MariaDB ColumnStore 프로세스를 추적합니다.</target>
        </trans-unit>
        <trans-unit id="4d94b06d836a1191c2ea7649c117580ef7bc0879" translate="yes" xml:space="preserve">
          <source>In order to avoid a split-brain condition, the minimum recommended number of nodes in a cluster is 3.</source>
          <target state="translated">스플릿 브레인 조건을 피하기 위해 클러스터에서 권장되는 최소 노드 수는 3입니다.</target>
        </trans-unit>
        <trans-unit id="2231d79007d0101d03bb7521b56dadecc3bc1dfa" translate="yes" xml:space="preserve">
          <source>In order to back up the database, you need to run Mariabackup with the &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-backup&quot;&gt;--backup&lt;/a&gt;&lt;/code&gt; option to tell it to perform a backup and with the &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-target-dir&quot;&gt;--target-dir&lt;/a&gt;&lt;/code&gt; option to tell it where to place the backup files. When taking a full backup, the target directory must be empty or it must not exist.</source>
          <target state="translated">데이터베이스를 백업하려면 &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-backup&quot;&gt;--backup&lt;/a&gt;&lt;/code&gt; 옵션을 사용하여 Mariabackup 을 실행하여 백업을 수행하고 &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-target-dir&quot;&gt;--target-dir&lt;/a&gt;&lt;/code&gt; 옵션을 사용하여 백업 파일을 배치 할 위치를 지정해야합니다. 전체 백업을 수행 할 때 대상 디렉토리가 비어 있거나 존재하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="266a523486379e26fe530bd595326324a52eaa71" translate="yes" xml:space="preserve">
          <source>In order to be crash-safe, this table must use a transactional storage engine such as InnoDB. When MariaDB is first installed (or upgraded to 10.0.2+) the table is created using the default storage engine - which itself defaults to InnoDB. If there is a need to change the storage engine for this table (to make it transactional on a system configured with &lt;a href=&quot;../myisam/index&quot;&gt;MyISAM&lt;/a&gt; as the default storage engine, for example), use &lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt;:</source>
          <target state="translated">충돌에 안전하려면이 테이블은 InnoDB와 같은 트랜잭션 스토리지 엔진을 사용해야합니다. MariaDB를 처음 설치 (또는 10.0.2+로 업그레이드)하면 기본 스토리지 엔진을 사용하여 테이블이 생성되며 기본적으로 InnoDB로 설정됩니다. 이 테이블의 스토리지 엔진을 변경해야하는 경우 ( 예 : &lt;a href=&quot;../myisam/index&quot;&gt;MyISAM&lt;/a&gt; 을 기본 스토리지 엔진으로 구성된 시스템에서 트랜잭션으로 만들려면 ) &lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE을&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b24d23deb51ec3e58d87f298445d64626f114738" translate="yes" xml:space="preserve">
          <source>In order to better illustrate how MaxScale distributes queries between the servers, we are going to install a sample banking database and show how to process payments and analyze loan data.</source>
          <target state="translated">MaxScale이 서버간에 쿼리를 분배하는 방법을 더 잘 설명하기 위해 샘플 뱅킹 데이터베이스를 설치하고 지불을 처리하고 대출 데이터를 분석하는 방법을 보여줄 것입니다.</target>
        </trans-unit>
        <trans-unit id="4284c25d9bf355e16fb179318cf64188251d068e" translate="yes" xml:space="preserve">
          <source>In order to connect the Spider node to the data nodes, you need to issue a &lt;code&gt;&lt;a href=&quot;../create-server/index&quot;&gt;CREATE SERVER&lt;/a&gt;&lt;/code&gt; statement for each data node. You can then use the server definition in creating the Spider table.</source>
          <target state="translated">Spider 노드를 데이터 노드에 연결하려면 각 데이터 노드에 대해 &lt;code&gt;&lt;a href=&quot;../create-server/index&quot;&gt;CREATE SERVER&lt;/a&gt;&lt;/code&gt; 문 을 발행해야 합니다. 그런 다음 Spider 테이블 작성시 서버 정의를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f41889a1cda3969306d60ae70204fc4b84d94cf" translate="yes" xml:space="preserve">
          <source>In order to do temporal addition or subtraction instead, use the &lt;a href=&quot;../date_add/index&quot;&gt;DATE_ADD()&lt;/a&gt; or &lt;a href=&quot;../date_sub/index&quot;&gt;DATE_SUB()&lt;/a&gt; functions, or an &lt;a href=&quot;../date-and-time-units/index&quot;&gt;INTERVAL&lt;/a&gt; expression as the second argument:</source>
          <target state="translated">임시 덧셈 또는 뺄셈을 대신하려면 &lt;a href=&quot;../date_add/index&quot;&gt;DATE_ADD ()&lt;/a&gt; 또는 &lt;a href=&quot;../date_sub/index&quot;&gt;DATE_SUB ()&lt;/a&gt; 함수 또는 &lt;a href=&quot;../date-and-time-units/index&quot;&gt;INTERVAL&lt;/a&gt; 표현식을 두 번째 인수로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8a0e09de9756f1da0857a88eeb837a3033bd8b74" translate="yes" xml:space="preserve">
          <source>In order to efficiently compute the result of an IN predicate in the presence of NULLs, MariaDB implements two special algorithms for &lt;a href=&quot;http://askmonty.org/worklog/Server-Sprint/?tid=68&quot;&gt;partial matching, described here in detail&lt;/a&gt;.</source>
          <target state="translated">NULL이있는 경우 IN 술어의 결과를 효율적으로 계산하기 위해 MariaDB &lt;a href=&quot;http://askmonty.org/worklog/Server-Sprint/?tid=68&quot;&gt;는 여기에 자세히 설명 된 부분 일치를&lt;/a&gt; 위한 두 가지 특수 알고리즘을 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="0cc3e1533ecf14b0c3efe027bdc57c1a2820fee8" translate="yes" xml:space="preserve">
          <source>In order to efficiently compute the result of an IN predicate in the presence of NULLs, MariaDB implements two special algorithms for &lt;a href=&quot;https://mariadb.com/about/worklog/Server-Sprint/?tid=68&quot;&gt;partial matching, described here in detail&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c25a31c42fd9ae00892f0183c47a69870bd70b3b" translate="yes" xml:space="preserve">
          <source>In order to enable TLS for Galera Cluster's replication traffic, there are a number of &lt;a href=&quot;../wsrep_provider_options/index&quot;&gt;wsrep_provider_options&lt;/a&gt; that you need to set, such as:</source>
          <target state="translated">Galera Cluster의 복제 트래픽에 대해 TLS를 활성화 하려면 다음과 같이 설정해야하는 여러 &lt;a href=&quot;../wsrep_provider_options/index&quot;&gt;wsrep_provider_options&lt;/a&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="31d286c33859c03ca3e69e3f0b3c6ee05a4804ef" translate="yes" xml:space="preserve">
          <source>In order to enable TLS on a MariaDB server that was compiled with TLS support, there are a number of system variables that you need to set, such as:</source>
          <target state="translated">TLS 지원으로 컴파일 된 MariaDB 서버에서 TLS를 사용하려면 다음과 같이 설정해야하는 여러 시스템 변수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a57ce1415356c64877f2fa0e71081adb709b99c6" translate="yes" xml:space="preserve">
          <source>In order to enable data-at-rest encryption for tables using the &lt;a href=&quot;../aria/index&quot;&gt;Aria&lt;/a&gt; storage engine, you first need to configure the server to use an &lt;a href=&quot;../encryption-key-management/index&quot;&gt;Encryption Key Management&lt;/a&gt; plugin. Once this is done, you can enable encryption by setting the relevant system variables.</source>
          <target state="translated">&lt;a href=&quot;../aria/index&quot;&gt;Aria&lt;/a&gt; 스토리지 엔진을 사용하여 테이블에 대해 미사용 데이터 암호화를 활성화 하려면 먼저 &lt;a href=&quot;../encryption-key-management/index&quot;&gt;암호화 키 관리&lt;/a&gt; 플러그인 을 사용하도록 서버를 구성해야합니다 . 이 작업이 완료되면 관련 시스템 변수를 설정하여 암호화를 활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fff7e76254d98f256272c3a401ecaff786766faf" translate="yes" xml:space="preserve">
          <source>In order to enable data-at-rest encryption for tables using the Aria stora...</source>
          <target state="translated">Aria stora를 사용하여 테이블에 미사용 데이터 암호화를 활성화하려면 ...</target>
        </trans-unit>
        <trans-unit id="8cb4d832ce6fdcf963eeb9074d7a13baaac66555" translate="yes" xml:space="preserve">
          <source>In order to enable data-at-rest encryption for tables using the InnoDB or XtraDB storage engines, you first need to configure the Server to use an &lt;a href=&quot;../encryption-key-management/index&quot;&gt;Encryption Key Management&lt;/a&gt; plugin. Once this is done, you can enable encryption by setting the &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encrypt_tables&quot;&gt;innodb_encrypt_tables&lt;/a&gt;&lt;/code&gt; system variable to encrypt the InnoDB &lt;a href=&quot;../innodb-system-tablespaces/index&quot;&gt;system&lt;/a&gt; and &lt;a href=&quot;../innodb-file-per-table-tablespaces/index&quot;&gt;file&lt;/a&gt; tablespaces and setting the &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encrypt_log&quot;&gt;innodb_encrypt_log&lt;/a&gt;&lt;/code&gt; system variable to encrypt the InnoDB &lt;a href=&quot;../innodb-redo-log/index&quot;&gt;Redo Log&lt;/a&gt;.</source>
          <target state="translated">InnoDB 또는 XtraDB 스토리지 엔진을 사용하는 테이블에 대해 미사용 데이터 암호화를 사용하려면 먼저 &lt;a href=&quot;../encryption-key-management/index&quot;&gt;암호화 키 관리&lt;/a&gt; 플러그인 을 사용하도록 서버를 구성해야합니다 . 이 작업이 완료되면 &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encrypt_tables&quot;&gt;innodb_encrypt_tables&lt;/a&gt;&lt;/code&gt; 시스템 변수를 설정 하여 InnoDB &lt;a href=&quot;../innodb-system-tablespaces/index&quot;&gt;시스템&lt;/a&gt; 및 &lt;a href=&quot;../innodb-file-per-table-tablespaces/index&quot;&gt;파일&lt;/a&gt; 테이블 스페이스 를 암호화하고 &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encrypt_log&quot;&gt;innodb_encrypt_log&lt;/a&gt;&lt;/code&gt; 시스템 변수를 설정 하여 InnoDB &lt;a href=&quot;../innodb-redo-log/index&quot;&gt;Redo Log&lt;/a&gt; 를 암호화하여 암호화를 활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4f314f00a9e67e168c8a39a3faeb3ed21f3ed81c" translate="yes" xml:space="preserve">
          <source>In order to enable encryption for tables using the &lt;a href=&quot;../aria/index&quot;&gt;Aria storage engine&lt;/a&gt;, there are a couple server system variables that you need to set and configure. Most users will want to set &lt;code&gt;&lt;a href=&quot;../aria-system-variables/index#aria_encrypt_tables&quot;&gt;aria_encrypt_tables&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#encrypt_tmp_disk_tables&quot;&gt;encrypt_tmp_disk_tables&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../aria/index&quot;&gt;Aria 스토리지 엔진을&lt;/a&gt; 사용하여 테이블에 대한 암호화를 사용하려면 설정 및 구성해야하는 몇 가지 서버 시스템 변수가 있습니다. 대부분의 사용자는 &lt;code&gt;&lt;a href=&quot;../aria-system-variables/index#aria_encrypt_tables&quot;&gt;aria_encrypt_tables&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#encrypt_tmp_disk_tables&quot;&gt;encrypt_tmp_disk_tables&lt;/a&gt;&lt;/code&gt; 를 설정하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="853ae539e797dd8bbdee931703994cd1c1e6dfdf" translate="yes" xml:space="preserve">
          <source>In order to encrypt your tables with encryption keys using the File Key Management plugin, you first need to create the file that contains the encryption keys. The file needs to contain two pieces of information for each encryption key. First, each encryption key needs to be identified with a 32-bit integer as the key identifier. Second, the encryption key itself needs to be provided in hex-encoded form. These two pieces of information need to be separated by a semicolon. For example, the file is formatted in the following way:</source>
          <target state="translated">File Key Management 플러그인을 사용하여 암호화 키로 테이블을 암호화하려면 먼저 암호화 키가 포함 된 파일을 작성해야합니다. 파일에는 각 암호화 키에 대한 두 가지 정보가 포함되어야합니다. 먼저, 각 암호화 키는 키 식별자로 32 비트 정수로 식별되어야합니다. 둘째, 암호화 키 자체는 16 진 인코딩 형식으로 제공되어야합니다. 이 두 정보는 세미콜론으로 구분해야합니다. 예를 들어, 파일 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7c9615203b7ac56a1e3e4ede30601a9eeff8d7d3" translate="yes" xml:space="preserve">
          <source>In order to ensure that a a valid json document is inserted, the &lt;a href=&quot;../json_valid/index&quot;&gt;JSON_VALID&lt;/a&gt; function can be used as a &lt;a href=&quot;../constraint/index#check-constraint-expressions&quot;&gt;CHECK constraint&lt;/a&gt;. This constraint is automatically included for types using the JSON alias from &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1043-release-notes/&quot;&gt;MariaDB 10.4.3&lt;/a&gt;.</source>
          <target state="translated">유효한 json 문서를 삽입하기 위해 &lt;a href=&quot;../json_valid/index&quot;&gt;JSON_VALID&lt;/a&gt; 함수를 &lt;a href=&quot;../constraint/index#check-constraint-expressions&quot;&gt;CHECK 제약 조건&lt;/a&gt; 으로 사용할 수 있습니다 . 이 제약 조건은 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1043-release-notes/&quot;&gt;MariaDB 10.4.3&lt;/a&gt; 의 JSON 별칭을 사용하는 유형에 자동으로 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="9926e534366c20f83571d33a2e3f6a522b32fc0e" translate="yes" xml:space="preserve">
          <source>In order to execute a query, the function &lt;code&gt;sql_parse.cc:mysql_parse()&lt;/code&gt; is called, which in turn calls the parser (&lt;code&gt;yyparse()&lt;/code&gt;) with an updated Lex structure as the result. &lt;code&gt;mysql_parse()&lt;/code&gt; then calls &lt;code&gt;mysql_execute_command()&lt;/code&gt; which dispatches on the command code (in Lex) to the corresponding code for executing that particular query.</source>
          <target state="translated">쿼리를 실행하기 위해 &lt;code&gt;sql_parse.cc:mysql_parse()&lt;/code&gt; 함수 가 호출되고 결과적 으로 업데이트 된 Lex 구조를 사용하여 구문 분석기 ( &lt;code&gt;yyparse()&lt;/code&gt; )를 호출합니다 . &lt;code&gt;mysql_parse()&lt;/code&gt; 다음 호출 &lt;code&gt;mysql_execute_command()&lt;/code&gt; 특정 질의를 실행하기위한 대응하는 코드 (렉스)에 명령 코드에있는 디스패치.</target>
        </trans-unit>
        <trans-unit id="122212c621216508a8f21fd16e788b676f95d89a" translate="yes" xml:space="preserve">
          <source>In order to make use of the &lt;a href=&quot;../handlersocket/index&quot;&gt;HandlerSocket&lt;/a&gt; plugin in your applications, you will need to use the appropriate client library. The following client libraries are available:</source>
          <target state="translated">의 메이크업에 사용하기 위해 &lt;a href=&quot;../handlersocket/index&quot;&gt;HandlerSocket의&lt;/a&gt; 응용 프로그램에 플러그인 적절한 클라이언트 라이브러리를 사용해야합니다. 사용 가능한 클라이언트 라이브러리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4db7d779b1f0558a8405c3435794559c5b8c4cba" translate="yes" xml:space="preserve">
          <source>In order to perform an incremental backup, you need to run Mariabackup with the &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-backup&quot;&gt;--backup&lt;/a&gt;&lt;/code&gt; option to tell it to perform a backup and with the &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-target-dir&quot;&gt;--target-dir&lt;/a&gt;&lt;/code&gt; option to tell it where to place the incremental changes. The target directory must be empty. You also need to run it with the &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-incremental-basedir&quot;&gt;--incremental-basedir&lt;/a&gt;&lt;/code&gt; option to tell it the path to the full backup taken above. For example:</source>
          <target state="translated">증분 백업을 수행하려면 &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-backup&quot;&gt;--backup&lt;/a&gt;&lt;/code&gt; 옵션을 사용하여 Mariabackup 을 실행하여 백업을 수행하도록 지시하고 &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-target-dir&quot;&gt;--target-dir&lt;/a&gt;&lt;/code&gt; 옵션을 사용하여 증분 변경을 배치 할 위치를 지정해야합니다. 대상 디렉토리는 비어 있어야합니다. &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-incremental-basedir&quot;&gt;--incremental-basedir&lt;/a&gt;&lt;/code&gt; 옵션 과 함께 실행하여 위에서 수행 한 전체 백업의 경로를 알려 주어야 합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="09f4c01fb47f142e6fc957eb54ec63fe3743d909" translate="yes" xml:space="preserve">
          <source>In order to prevent data drift, serial execution of statements on the slave must have the same effect as concurrent execution of these statements on the master. In other words, transaction isolation on the master must be close to &lt;code&gt;SERIALIZABLE&lt;/code&gt; transaction isolation level (This is not a strict mathematical proof but shows the idea).</source>
          <target state="translated">데이터 드리프트를 방지하기 위해 슬레이브에서 명령문의 직렬 실행은 마스터에서 이러한 명령문의 동시 실행과 동일한 효과를 가져야합니다. 다시 말해, 마스터에서의 트랜잭션 격리는 &lt;code&gt;SERIALIZABLE&lt;/code&gt; 트랜잭션 격리 수준에 가까워 야합니다 (엄격한 수학적 증거는 아니지만 아이디어를 보여줍니다).</target>
        </trans-unit>
        <trans-unit id="3791adfb47ec762924dd2cb08ce1f2ea34b3e21d" translate="yes" xml:space="preserve">
          <source>In order to prevent such situations, the optimizer checks whether the UPDATE statement is going to change key values for the keys it is using. In that case, it will use a different algorithm:</source>
          <target state="translated">이러한 상황을 방지하기 위해 옵티마이 저는 UPDATE 문이 사용중인 키의 키 값을 변경하는지 여부를 확인합니다. 이 경우 다른 알고리즘을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9e4f81b5ee983c8fcb44bf8c8028f4f3730b7b89" translate="yes" xml:space="preserve">
          <source>In order to restore from a backup, you first need to run Mariabackup with the &lt;code&gt;&lt;a href=&quot;#-prepare&quot;&gt;--prepare&lt;/a&gt;&lt;/code&gt; command option, to make a full backup point-in-time consistent or to apply incremental backup deltas to base. Then you can run Mariabackup again with either the &lt;code&gt;&lt;a href=&quot;#-copy-back&quot;&gt;--copy-back&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#-move-back&quot;&gt;--move-back&lt;/a&gt;&lt;/code&gt; commands to restore the database.</source>
          <target state="translated">위해, 백업에서 복원하는 당신에게로 Mariabackup를 실행하려면 먼저 필요 &lt;code&gt;&lt;a href=&quot;#-prepare&quot;&gt;--prepare&lt;/a&gt;&lt;/code&gt; , 명령 옵션 확인하기 위해 전체 백업 일관된 시점 시간 또는베이스에 증분 백업 델타를 적용하는. 그런 다음 &lt;code&gt;&lt;a href=&quot;#-copy-back&quot;&gt;--copy-back&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#-move-back&quot;&gt;--move-back&lt;/a&gt;&lt;/code&gt; 명령으로 Mariabackup을 다시 실행 하여 데이터베이스를 복원 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fab299b0f09f7efc4554ff842bc9f91a66438e94" translate="yes" xml:space="preserve">
          <source>In order to safely disable encryption, you first need to decrypt the tablespaces and the Redo Log, then turn off the system variables. The specifics of this process depends on whether you are using automatic or manual encryption of the InnoDB tablespaces.</source>
          <target state="translated">암호화를 안전하게 비활성화하려면 먼저 테이블 스페이스와 재실행 로그를 해독 한 다음 시스템 변수를 꺼야합니다. 이 프로세스의 세부 사항은 InnoDB 테이블 스페이스의 자동 또는 수동 암호화 사용 여부에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="1c10c658fac362678290fd1393138b2a7e48c215" translate="yes" xml:space="preserve">
          <source>In order to secure communications with the MariaDB Server using TLS, you need to create a private key and an X509 certificate for the server. You may also want to create additional private keys and X509 certificates for any clients that need to connect to the server with TLS. This guide covers how to create a private key and a self-signed X509 certificate with OpenSSL.</source>
          <target state="translated">TLS를 사용하여 MariaDB 서버와의 통신을 보호하려면 서버에 대한 개인 키와 X509 인증서를 작성해야합니다. TLS를 사용하여 서버에 연결해야하는 클라이언트에 대해 추가 개인 키와 X509 인증서를 만들 수도 있습니다. 이 안내서는 OpenSSL을 사용하여 개인 키 및 자체 서명 된 X509 인증서를 작성하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="bd72a1a574d39ae3c32eaf4b23fc1b5343b677a9" translate="yes" xml:space="preserve">
          <source>In order to secure connections between the cluster nodes, you need to ensure that all servers were compiled with TLS support. See &lt;a href=&quot;../secure-connections-overview/index&quot;&gt;Secure Connections Overview&lt;/a&gt; to determine how to check whether a server was compiled with TLS support.</source>
          <target state="translated">클러스터 노드 간의 연결을 보호하려면 모든 서버가 TLS 지원으로 컴파일되었는지 확인해야합니다. 서버가 TLS 지원으로 컴파일되었는지 확인하는 방법을 확인하려면 &lt;a href=&quot;../secure-connections-overview/index&quot;&gt;보안 연결 개요&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b7cef82ba00f73b906535350f68cc25b4b7f809d" translate="yes" xml:space="preserve">
          <source>In order to secure connections between the master and slave, you need to ensure that both servers were compiled with TLS support. See &lt;a href=&quot;../secure-connections-overview/index&quot;&gt;Secure Connections Overview&lt;/a&gt; to determine how to check whether a server was compiled with TLS support.</source>
          <target state="translated">마스터와 슬레이브 간의 연결을 보호하려면 두 서버가 모두 TLS 지원으로 컴파일되었는지 확인해야합니다. 서버가 TLS 지원으로 컴파일되었는지 확인하는 방법을 확인하려면 &lt;a href=&quot;../secure-connections-overview/index&quot;&gt;보안 연결 개요&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a2732f24a558909f87671f6810f3c50b4536c957" translate="yes" xml:space="preserve">
          <source>In order to secure connections between the server and client, you need to ensure that your server was compiled with TLS support. See &lt;a href=&quot;../secure-connections-overview/index&quot;&gt;Secure Connections Overview&lt;/a&gt; to determine how to check whether a server was compiled with TLS support.</source>
          <target state="translated">서버와 클라이언트 사이의 연결을 보호하려면 서버가 TLS 지원으로 컴파일되었는지 확인해야합니다. 서버가 TLS 지원으로 컴파일되었는지 확인하는 방법을 확인하려면 &lt;a href=&quot;../secure-connections-overview/index&quot;&gt;보안 연결 개요&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3bcb0361d23b2b6561becace98a7a70b2d6f88a9" translate="yes" xml:space="preserve">
          <source>In order to secure replication traffic, you will need to ensure that TLS is enabled on the master. If you want to use two-way TLS, then you will also need to ensure that TLS is enabled on the slave. See &lt;a href=&quot;../securing-connections-for-client-and-server/index&quot;&gt;Securing Connections for Client and Server&lt;/a&gt; for information on how to do that.</source>
          <target state="translated">복제 트래픽을 보호하려면 마스터에서 TLS가 활성화되어 있는지 확인해야합니다. 양방향 TLS를 사용하려면 슬레이브에서 TLS가 활성화되어 있는지 확인해야합니다. 이를 수행하는 방법에 대한 정보 &lt;a href=&quot;../securing-connections-for-client-and-server/index&quot;&gt;는 클라이언트 및 서버의 연결 보안을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="66b2e596a25ff889219556706d0656edbbe984dd" translate="yes" xml:space="preserve">
          <source>In order to show the benefits of partial matching we extended the &lt;em&gt;customer&lt;/em&gt; table from the DBT3 benchmark with two extra columns:</source>
          <target state="translated">부분 일치의 이점을 보여주기 위해 DBT3 벤치 마크에서 &lt;em&gt;고객&lt;/em&gt; 테이블을 두 개의 추가 열로 확장했습니다.</target>
        </trans-unit>
        <trans-unit id="c8175ce1b154e00ef8c38d621a2af9bd8e2a1413" translate="yes" xml:space="preserve">
          <source>In order to size temporary tablespaces, use the &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_temp_data_file_path&quot;&gt;innodb_temp_data_file_path&lt;/a&gt;&lt;/code&gt; system variable. This system variable can be specified as a command-line argument to &lt;code&gt;&lt;a href=&quot;../mysqld-options/index&quot;&gt;mysqld&lt;/a&gt;&lt;/code&gt; or it can be specified in a relevant server &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;option group&lt;/a&gt; in an &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;option file&lt;/a&gt;. For example:</source>
          <target state="translated">임시 테이블 스페이스의 크기를 조정하려면 &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_temp_data_file_path&quot;&gt;innodb_temp_data_file_path&lt;/a&gt;&lt;/code&gt; 시스템 변수를 사용하십시오 . 이 시스템 변수는 &lt;code&gt;&lt;a href=&quot;../mysqld-options/index&quot;&gt;mysqld&lt;/a&gt;&lt;/code&gt; 에 대한 명령 행 인수로 지정 하거나 &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;옵션 파일&lt;/a&gt; 의 관련 서버 &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;옵션 그룹&lt;/a&gt; 에서 지정할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="abb060dac3972df11faf92e4c04dad7ed03ae021" translate="yes" xml:space="preserve">
          <source>In order to skip transactions in cases like this, you will have to manually change &lt;code&gt;&lt;a href=&quot;../gtid/index#gtid_slave_pos&quot;&gt;gtid_slave_pos&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이런 경우에 트랜잭션을 건너 뛰 &lt;code&gt;&lt;a href=&quot;../gtid/index#gtid_slave_pos&quot;&gt;gtid_slave_pos&lt;/a&gt;&lt;/code&gt; 를 수동으로 변경 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="b3c31d96969f1d715180468784bcdada28547889" translate="yes" xml:space="preserve">
          <source>In order to stream data from the MariaDB Servers to ColumnStore,call the &lt;code&gt;mxs_adapter&lt;/code&gt; utility. From the &lt;code&gt;MaxScale-1&lt;/code&gt; server, run the following command:</source>
          <target state="translated">MariaDB 서버에서 ColumnStore로 데이터를 스트리밍하려면 &lt;code&gt;mxs_adapter&lt;/code&gt; 유틸리티를 호출하십시오 . 로부터 &lt;code&gt;MaxScale-1&lt;/code&gt; 서버, 다음 명령을 실행합니다 :</target>
        </trans-unit>
        <trans-unit id="d6a25f58c8eef8ed2c7b881607d03db66d1b765b" translate="yes" xml:space="preserve">
          <source>In order to take an incremental backup, you first need to take a &lt;a href=&quot;../full-backup-and-restore-with-mariabackup/index&quot;&gt;full backup&lt;/a&gt;. In order to back up the database, you need to run Mariabackup with the &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-backup&quot;&gt;--backup&lt;/a&gt;&lt;/code&gt; option to tell it to perform a backup and with the &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-target-dir&quot;&gt;--target-dir&lt;/a&gt;&lt;/code&gt; option to tell it where to place the backup files. When taking a full backup, the target directory must be empty or it must not exist.</source>
          <target state="translated">증분 백업을 수행하려면 먼저 &lt;a href=&quot;../full-backup-and-restore-with-mariabackup/index&quot;&gt;전체 백업&lt;/a&gt; 을 수행해야합니다 . 데이터베이스를 백업하려면 &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-backup&quot;&gt;--backup&lt;/a&gt;&lt;/code&gt; 옵션을 사용하여 Mariabackup 을 실행하여 백업을 수행하고 &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-target-dir&quot;&gt;--target-dir&lt;/a&gt;&lt;/code&gt; 옵션을 사용하여 백업 파일을 배치 할 위치를 지정해야합니다. 전체 백업을 수행 할 때 대상 디렉토리가 비어 있거나 존재하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="2d2afa5b791ef6ef8c3e14ca5a840c3753b0e011" translate="yes" xml:space="preserve">
          <source>In order to test this feature, you first need to create tables to store the data the CDC Data Adapter transfers. First, connect to the master MariaDB Server, &lt;code&gt;Server-1&lt;/code&gt;, and create an InnoDB table to use in storing test data:</source>
          <target state="translated">이 기능을 테스트하려면 먼저 CDC Data Adapter가 전송하는 데이터를 저장할 테이블을 작성해야합니다. 먼저 마스터 MariaDB 서버 &lt;code&gt;Server-1&lt;/code&gt; 에 연결하고 테스트 데이터 저장에 사용할 InnoDB 테이블을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="338c4653578c15fb14688b04f330ac7063511cb9" translate="yes" xml:space="preserve">
          <source>In order to update table columns from the older format to the newer format, execute an &lt;code&gt;&lt;a href=&quot;../alter-table/index#modify-column&quot;&gt;ALTER TABLE... MODIFY COLUMN&lt;/a&gt;&lt;/code&gt; statement that changes the column to the *same* data type. This change may be needed if you want to export the table's tablespace and import it onto a server that has &lt;code&gt;mysql56_temporal_format=ON&lt;/code&gt; set (see &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-15225&quot;&gt;MDEV-15225&lt;/a&gt;).</source>
          <target state="translated">이전 형식에서 새로운 형식으로 테이블 컬럼을 갱신 하려면 컬럼을 * same * 데이터 유형으로 변경 하는 &lt;code&gt;&lt;a href=&quot;../alter-table/index#modify-column&quot;&gt;ALTER TABLE... MODIFY COLUMN&lt;/a&gt;&lt;/code&gt; 문을 실행 하십시오 . 테이블의 테이블 스페이스를 내보내고 &lt;code&gt;mysql56_temporal_format=ON&lt;/code&gt; 이 설정된 서버로 가져 오려면이 변경이 필요할 수 있습니다 ( &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-15225&quot;&gt;MDEV-15225&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="264a1d00d09acce54ebfce32b4b0e0027f3aaf86" translate="yes" xml:space="preserve">
          <source>In order to use &lt;a href=&quot;../galera/index&quot;&gt;Galera Cluster&lt;/a&gt;, the lock mode needs to be set to &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../galera/index&quot;&gt;Galera Cluster&lt;/a&gt; 를 사용 하려면 잠금 모드를 &lt;code&gt;2&lt;/code&gt; 로 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ae37bbaaaa4fe886271ae6addc3d0e9fbf700c7c" translate="yes" xml:space="preserve">
          <source>In order to use Galera Cluster without problems in &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt;, the &lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_lock_schedule_algorithm&quot;&gt;innodb_lock_schedule_algorithm&lt;/a&gt;&lt;/code&gt; system variable must be set to &lt;code&gt;FCFS&lt;/code&gt;. In &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10212-release-notes/&quot;&gt;MariaDB 10.2.12&lt;/a&gt; and later, this system variable is automatically set to this value when Galera Cluster is enabled. In &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10211-release-notes/&quot;&gt;MariaDB 10.2.11&lt;/a&gt; and before, this system variable must be set to this value manually. See &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-12837&quot;&gt;MDEV-12837&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt; 에서 Galera Cluster를 문제없이 사용 하려면 &lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_lock_schedule_algorithm&quot;&gt;innodb_lock_schedule_algorithm&lt;/a&gt;&lt;/code&gt; 시스템 변수를 &lt;code&gt;FCFS&lt;/code&gt; 로 설정해야합니다 . 에서 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10212-release-notes/&quot;&gt;MariaDB 10.2.12&lt;/a&gt; 갈레 클러스터가 활성화되면 이상이 시스템 변수는 자동으로이 값으로 설정됩니다. &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10211-release-notes/&quot;&gt;MariaDB 10.2.11&lt;/a&gt; 이하에서는 이 시스템 변수를이 값으로 수동 설정해야합니다. 자세한 내용은 &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-12837&quot;&gt;MDEV-12837&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="df47103dfbc6401bf9574e6d233b856ad79d1b85" translate="yes" xml:space="preserve">
          <source>In order to use LDAP for authentication, we also need to install some standard &lt;code&gt;objectClasses&lt;/code&gt;, such as &lt;code&gt;posixAccount&lt;/code&gt; and &lt;code&gt;posixGroup&lt;/code&gt;. In LDAP, things like &lt;code&gt;objectClasses&lt;/code&gt; are defined in &lt;code&gt;&lt;a href=&quot;https://www.digitalocean.com/community/tutorials/how-to-use-ldif-files-to-make-changes-to-an-openldap-system&quot;&gt;LDIF&lt;/a&gt;&lt;/code&gt; files. In many installations, these specific &lt;code&gt;objectClasses&lt;/code&gt; are defined in &lt;code&gt;/etc/openldap/schema/nis.ldif&lt;/code&gt;. &lt;code&gt;nis.ldif&lt;/code&gt; also depends on &lt;code&gt;core.ldif&lt;/code&gt; and &lt;code&gt;cosine.ldif&lt;/code&gt;. However, &lt;code&gt;core.ldif&lt;/code&gt; is usually installed by default.</source>
          <target state="translated">인증에 LDAP를 사용하려면 &lt;code&gt;posixAccount&lt;/code&gt; 및 &lt;code&gt;posixGroup&lt;/code&gt; 과 같은 일부 표준 &lt;code&gt;objectClasses&lt;/code&gt; 도 설치해야합니다 . LDAP에서 &lt;code&gt;objectClasses&lt;/code&gt; 와 같은 것은 &lt;code&gt;&lt;a href=&quot;https://www.digitalocean.com/community/tutorials/how-to-use-ldif-files-to-make-changes-to-an-openldap-system&quot;&gt;LDIF&lt;/a&gt;&lt;/code&gt; 파일에 정의되어 있습니다. 많은 설치에서 이러한 특정 &lt;code&gt;objectClasses&lt;/code&gt; 는 &lt;code&gt;/etc/openldap/schema/nis.ldif&lt;/code&gt; 에 정의되어 있습니다. &lt;code&gt;nis.ldif&lt;/code&gt; 는 &lt;code&gt;core.ldif&lt;/code&gt; 및 &lt;code&gt;cosine.ldif&lt;/code&gt; 에 의존합니다 . 그러나 &lt;code&gt;core.ldif&lt;/code&gt; 는 일반적으로 기본적으로 설치됩니다.</target>
        </trans-unit>
        <trans-unit id="bdbe173997ef5a2a9f2d9517bc55d2e658de1c32" translate="yes" xml:space="preserve">
          <source>In order to use ODBC tables, you will need to have unixODBC installed. Additionally, you will need the ODBC driver for your foreign server's protocol. For example, for MS SQL Server or Sybase, you will need to have FreeTDS installed.</source>
          <target state="translated">ODBC 테이블을 사용하려면 unixODBC가 설치되어 있어야합니다. 또한 외부 서버 프로토콜에 대한 ODBC 드라이버가 필요합니다. 예를 들어, MS SQL Server 또는 Sybase의 경우 FreeTDS가 설치되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="d5ffee4ce0f5e11e3eef5adbcef865010ff1cff2" translate="yes" xml:space="preserve">
          <source>In order to use Poudriere, you need to set up and configure a web server, such as Nginx or Apache to serve the directory that Poudriere built. For instance, in the case of the above example, you would map to the &lt;code&gt;package-builder&lt;/code&gt; jail: &lt;code&gt;/usr/local/poudriere/data/packages/package-builder/&lt;/code&gt;. You may find it useful to map this directory to a sub-domain, for instance &lt;code&gt;https&lt;em&gt;pkg.example.com&lt;/em&gt;&lt;/code&gt; or something similar.</source>
          <target state="translated">Poudriere를 사용하려면 Nginx 또는 Apache와 같은 웹 서버를 설정하고 구성하여 Poudriere가 빌드 한 디렉토리를 제공해야합니다. 예를 들어, 위 예제의 경우 &lt;code&gt;package-builder&lt;/code&gt; jail : &lt;code&gt;/usr/local/poudriere/data/packages/package-builder/&lt;/code&gt; 됩니다. 이 디렉토리를 하위 도메인 (예 : &lt;code&gt;https&lt;em&gt;pkg.example.com&lt;/em&gt;&lt;/code&gt; 또는 이와 유사한 도메인)에 매핑하는 것이 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ce77328432cca8c72cbb544a3e3971ec98da0811" translate="yes" xml:space="preserve">
          <source>In order to use Spider, you need to run the configuration script on the Spider node. You can check whether it has been installed already by querying the Information Schema.</source>
          <target state="translated">Spider를 사용하려면 Spider 노드에서 구성 스크립트를 실행해야합니다. 정보 스키마를 쿼리하여 이미 설치되어 있는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d067253b60e0c1210a223eaae5e0100ea7b95a4" translate="yes" xml:space="preserve">
          <source>In order to use named time zones, such as GMT, MET or Africa/Johannesburg, the time_zone tables must be loaded (see &lt;a href=&quot;../mysql_tzinfo_to_sql/index&quot;&gt;mysql_tzinfo_to_sql&lt;/a&gt;).</source>
          <target state="translated">GMT, MET 또는 Africa / Johannesburg와 같은 명명 된 시간대를 사용하려면 time_zone 테이블을로드해야합니다 ( &lt;a href=&quot;../mysql_tzinfo_to_sql/index&quot;&gt;mysql_tzinfo_to_sql&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="0ed8d07366575ead43fcf825cfcca2a9bee5fa62" translate="yes" xml:space="preserve">
          <source>In order to use the &lt;a href=&quot;../sphinxse/index&quot;&gt;Sphinx Storage Engine&lt;/a&gt;, it is necessary to install the Sphinx daemon.</source>
          <target state="translated">사용하기 위해 &lt;a href=&quot;../sphinxse/index&quot;&gt;스핑크스 스토리지 엔진&lt;/a&gt; , 스핑크스 데몬을 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="d4c18fbc5ec2c09c51ff42d424c8358a3196030e" translate="yes" xml:space="preserve">
          <source>In order to use the &lt;code&gt;&lt;a href=&quot;../authentication-plugin-pam/index#dialog&quot;&gt;dialog&lt;/a&gt;&lt;/code&gt; client authentication plugin to communicate with the user in a customized way, the application will need to implement a function with the following signature:</source>
          <target state="translated">사용하기 위해 &lt;code&gt;&lt;a href=&quot;../authentication-plugin-pam/index#dialog&quot;&gt;dialog&lt;/a&gt;&lt;/code&gt; 사용자 정의 방식으로 사용자와 통신하는 클라이언트 인증 플러그인을, 응용 프로그램은 다음과 같은 서명 기능을 구현해야합니다 :</target>
        </trans-unit>
        <trans-unit id="a28008a7611857a52e1e343769dfb71a302dcc53" translate="yes" xml:space="preserve">
          <source>In other cases (&lt;code&gt;hostname&lt;/code&gt; is given and it's not &lt;code&gt;localhost&lt;/code&gt;) then a tcpip connection through the &lt;code&gt;port&lt;/code&gt; option is used.</source>
          <target state="translated">다른 경우 ( &lt;code&gt;hostname&lt;/code&gt; 이 지정되고 &lt;code&gt;localhost&lt;/code&gt; 가 아님) &lt;code&gt;port&lt;/code&gt; 옵션을 통한 tcpip 연결 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8ed306d46740ec0377ca39c86e5e4ac80000f8fd" translate="yes" xml:space="preserve">
          <source>In other cases then a tcpip connection through the &lt;code&gt;port&lt;/code&gt; option is used.</source>
          <target state="translated">다른 경우에는 &lt;code&gt;port&lt;/code&gt; 옵션을 통한 tcpip 연결 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b8f93c9aff1f1b56fea9d670417aafe5da3ad0d8" translate="yes" xml:space="preserve">
          <source>In other cases you may need more control over the returned matches, and will need to use regular expressions.</source>
          <target state="translated">다른 경우에는 반환 된 일치 항목에 대해 더 많은 제어가 필요할 수 있으며 정규식을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="09f866019e979dbbf6c8e4e0d4807cc5d8c72f92" translate="yes" xml:space="preserve">
          <source>In other cases, arguments are compared as floating point, or real, numbers.</source>
          <target state="translated">다른 경우 인수는 부동 소수점 또는 실수로 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="1e8f759104a057115355e57282996fd86ea8682a" translate="yes" xml:space="preserve">
          <source>In other cases, the depth will be greater than 2.</source>
          <target state="translated">다른 경우에는 깊이가 2보다 큽니다.</target>
        </trans-unit>
        <trans-unit id="19576d550e43e6e95964268f344cc9572a67dfd0" translate="yes" xml:space="preserve">
          <source>In other systems, although the plugin's shared library is distributed with MariaDB by default as &lt;code&gt;auth_socket.so&lt;/code&gt;, the plugin is not actually installed by MariaDB by default. There are two methods that can be used to install the plugin with MariaDB.</source>
          <target state="translated">다른 시스템에서는 플러그인의 공유 라이브러리가 기본적으로 &lt;code&gt;auth_socket.so&lt;/code&gt; 로 MariaDB와 함께 배포 되지만 실제로 플러그인은 MariaDB에 의해 기본적으로 설치되지 않습니다. MariaDB와 함께 플러그인을 설치하는 데 사용할 수있는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="754492e44ae67b9cd90138c80d9f85a03249017d" translate="yes" xml:space="preserve">
          <source>In other words, Cassandra encourages creation/use of materialized VIEWs. Having lots of materialized VIEWs makes updates expensive, but their low cost and non-conflicting nature should offset that.</source>
          <target state="translated">다시 말해 Cassandra는 구체화 된 VIEW를 생성 / 사용하도록 권장합니다. 구체화 된 VIEW가 많으면 업데이트 비용이 많이 들지만 비용이 낮고 충돌하지 않는 특성으로 인해이를 상쇄해야합니다.</target>
        </trans-unit>
        <trans-unit id="5b96febd7650fb01793734aaa1ed7ce209d92513" translate="yes" xml:space="preserve">
          <source>In other words, Mariabackup is able to figure out a lot of encryption-related information on its own, so normally one doesn't need to provide any extra options to backup or restore encrypted tables.</source>
          <target state="translated">즉, Mariabackup은 자체적으로 많은 암호화 관련 정보를 알아낼 수 있으므로 일반적으로 암호화 된 테이블을 백업 또는 복원하기위한 추가 옵션을 제공 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5ef502060f3ed1dbd5b5a5121e2391c9ce1824dd" translate="yes" xml:space="preserve">
          <source>In other words, if you would run the following in a shell:</source>
          <target state="translated">다시 말해, 쉘에서 다음을 실행한다면 :</target>
        </trans-unit>
        <trans-unit id="98d2bc2f5f33d1d2f1030b78b95fa8b26894979c" translate="yes" xml:space="preserve">
          <source>In our tests, this query ran in 3.2 seconds, which is not as good as the case with two equalities, but still much better than 10.8 seconds we were getting without &lt;code&gt;sort_intersect&lt;/code&gt;.</source>
          <target state="translated">테스트에서이 쿼리는 3.2 초 안에 실행되었는데, 이는 두 개의 등가 인 경우에는 좋지 않지만 &lt;code&gt;sort_intersect&lt;/code&gt; 없이는 10.8 초보다 훨씬 낫습니다 .</target>
        </trans-unit>
        <trans-unit id="69c5b926c535c87d71d8031076e464a79d8632e2" translate="yes" xml:space="preserve">
          <source>In parallel replication the worker thread is waiting for conflicting things to end before starting executing.</source>
          <target state="translated">병렬 복제에서 작업자 스레드는 실행을 시작하기 전에 충돌하는 항목이 끝나기를 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="99522fb9bd3c38bd02b7153f73ec329e0a58623b" translate="yes" xml:space="preserve">
          <source>In parallel replication the worker thread is waiting for more things from the SQL thread.</source>
          <target state="translated">병렬 복제에서 작업자 스레드는 SQL 스레드에서 더 많은 것을 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e3b96a05cf23bcda10dac26327ed1487b223c1c" translate="yes" xml:space="preserve">
          <source>In parallel replication when worker threads are waiting for a global read lock to be released.</source>
          <target state="translated">작업자 스레드가 전역 읽기 잠금이 해제되기를 기다리는 경우의 병렬 복제</target>
        </trans-unit>
        <trans-unit id="22384d2bb41c98e1f5f56780c61fd79c1378d5bd" translate="yes" xml:space="preserve">
          <source>In particular this means that if you have run, for example</source>
          <target state="translated">특히 이것은 예를 들어</target>
        </trans-unit>
        <trans-unit id="f8f071ea74d56b287b66ce0ea8f3fe665ee2d3bf" translate="yes" xml:space="preserve">
          <source>In particular, &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt; and 10.3 feature native JSON functions. In some cases, it is possible that these native functions can be used. However, mixing native and UDF JSON functions in the same query often does not work because the way they recognize their arguments is different and might even cause a server crash.</source>
          <target state="translated">특히 &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt; 및 10.3에는 기본 JSON 함수가 있습니다. 경우에 따라 이러한 기본 기능을 사용할 수 있습니다. 그러나 동일한 쿼리에서 기본 및 UDF JSON 함수를 혼합하면 인수를 인식하는 방식이 다르고 서버 충돌이 발생할 수 있으므로 종종 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c2f22bc019e101e17d44523ad11f462ae644845f" translate="yes" xml:space="preserve">
          <source>In particular, on step #5 we'll read the same index page that we've read on step #2, and the page we've read on step #4 will be re-read on step#6. If all pages you're accessing are in the cache (in the buffer pool, if you're using InnoDB, and in the key cache, if you're using MyISAM), this is not a problem. However, if your hit ratio is poor and you're going to hit the disk, it makes sense to sort the lookup keys, like shown in this figure:</source>
          <target state="translated">특히 5 단계에서 2 단계에서 읽은 것과 동일한 색인 페이지를 읽고 4 단계에서 읽은 페이지를 6 단계에서 다시 읽습니다. 액세스하는 모든 페이지가 캐시 (버퍼 풀, InnoDB를 사용하는 경우 및 키 캐시, MyISAM을 사용하는 경우)에 있으면 문제가되지 않습니다. 그러나 적중률이 낮고 디스크에 도달 할 경우 다음 그림과 같이 조회 키를 정렬하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c93eae56c253abcef651c99ce8492de5c3d2df5d" translate="yes" xml:space="preserve">
          <source>In particular, take note of the changes to &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_strict_mode&quot;&gt;innodb_strict_mode&lt;/a&gt;, &lt;a href=&quot;../server-system-variables/index#sql_mode&quot;&gt;sql_mode&lt;/a&gt;, &lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#binlog_format&quot;&gt;binlog_format&lt;/a&gt;, &lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#binlog_checksum&quot;&gt;binlog_checksum&lt;/a&gt; and &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_checksum_algorithm&quot;&gt;innodb_checksum_algorithm&lt;/a&gt;.</source>
          <target state="translated">특히 &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_strict_mode&quot;&gt;innodb_strict_mode&lt;/a&gt; , &lt;a href=&quot;../server-system-variables/index#sql_mode&quot;&gt;sql_mode&lt;/a&gt; , &lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#binlog_format&quot;&gt;binlog_format&lt;/a&gt; , &lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#binlog_checksum&quot;&gt;binlog_checksum&lt;/a&gt; 및 &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_checksum_algorithm&quot;&gt;innodb_checksum_algorithm&lt;/a&gt; 에 대한 변경 사항을 기록하십시오 .</target>
        </trans-unit>
        <trans-unit id="c23cab4bbba2df2dce22900cc3bd85a31002d0e7" translate="yes" xml:space="preserve">
          <source>In particular, when column definition is left to the Discovery feature, if tables with the same name are present in several schemas and the schema name is not specified, several columns with the same name will be generated. This will make the creation fail with a not very explicit error message.</source>
          <target state="translated">특히, 컬럼 정의가 감지 기능에 남겨진 경우, 동일한 이름을 가진 테이블이 여러 스키마에 존재하고 스키마 이름이 지정되지 않은 경우 동일한 이름을 가진 여러 컬럼이 생성됩니다. 이렇게하면 명시 적이 지 않은 오류 메시지와 함께 생성이 실패하게됩니다.</target>
        </trans-unit>
        <trans-unit id="c8cabd96daa6de42c491d8c6315e1b37f37c6fab" translate="yes" xml:space="preserve">
          <source>In particular, you should not specify an index for columns not used for joining and above all DO NOT index a joined column if it is not indexed in the remote table. This would cause multiple scans of the remote table to retrieve the joined rows one by one.</source>
          <target state="translated">특히 조인에 사용되지 않는 열에 대한 인덱스를 지정해서는 안되며 무엇보다도 원격 테이블에서 인덱싱되지 않은 경우 조인 된 열을 인덱싱하지 마십시오. 이로 인해 원격 테이블을 여러 번 스캔하면 조인 된 행이 하나씩 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="9c8f7c1bd4f968218e6e757997097d2d9a2d6407" translate="yes" xml:space="preserve">
          <source>In practice, having both &lt;em&gt;MariaDB&lt;/em&gt; the database server and &lt;em&gt;Maria&lt;/em&gt; the storage engine with such similar names proved confusing. To mitigate this, the decision was made to change the name. A Rename Maria contest was held during the first half of 2010 and names were submitted from around the world. Monty picked the name &lt;strong&gt;&lt;em&gt;Aria&lt;/em&gt;&lt;/strong&gt; from a short list of finalist. Chris Tooley, who suggested it, received the prize of a Linux-powered &lt;a href=&quot;http://www.system76.com/product_info.php?cPath=27&amp;amp;products_id=91&quot;&gt;System 76 Meerkat NetTop&lt;/a&gt; from Monty Program.</source>
          <target state="translated">실제로, 데이터베이스 서버 &lt;em&gt;MariaDB&lt;/em&gt; 와 이와 유사한 이름을 가진 스토리지 엔진 &lt;em&gt;Maria&lt;/em&gt; 를 모두 갖는 것은 혼란 스러웠습니다. 이를 완화하기 위해 이름을 변경하기로 결정했습니다. 2010 년 상반기 동안 Rename Maria 콘테스트가 열렸으며 전 세계에서 이름이 제출되었습니다. Monty는 결선 진출작에서 &lt;strong&gt;&lt;em&gt;Aria&lt;/em&gt;&lt;/strong&gt; 라는 이름을 선택했습니다 . 이를 제안한 Chris Tooley 는 Monty Program으로부터 Linux 기반 &lt;a href=&quot;http://www.system76.com/product_info.php?cPath=27&amp;amp;products_id=91&quot;&gt;System 76 Meerkat NetTop&lt;/a&gt; 상을 수상했습니다 .</target>
        </trans-unit>
        <trans-unit id="19e13fa18601ebe672a95f8a77d3987110c7f39d" translate="yes" xml:space="preserve">
          <source>In practice, having both &lt;em&gt;MariaDB&lt;/em&gt; the database server and &lt;em&gt;Maria&lt;/em&gt; the storage engine with such similar names proved confusing. To mitigate this, the decision was made to change the name. A Rename Maria contest was held during the first half of 2010 and names were submitted from around the world. Monty picked the name &lt;strong&gt;&lt;em&gt;Aria&lt;/em&gt;&lt;/strong&gt; from a short list of finalist. Chris Tooley, who suggested it, received the prize of a Linux-powered &lt;a href=&quot;https://www.system76.com/product_info.php?cPath=27&amp;amp;products_id=91&quot;&gt;System 76 Meerkat NetTop&lt;/a&gt; from Monty Program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a43e4aa34aaed529bfc1c936ba5a6965b77e8f60" translate="yes" xml:space="preserve">
          <source>In practice, the subquery will be converted only if it has inner=outer equality. Both correlated and uncorrelated subqueries are converted.</source>
          <target state="translated">실제로 하위 쿼리는 inner = outer equality 인 경우에만 변환됩니다. 상관 된 하위 쿼리와 상관되지 않은 하위 쿼리 모두 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="ed7ac32304b15901e672daea0ae182e0882e38e4" translate="yes" xml:space="preserve">
          <source>In principle the subquery materialization strategy is universal, however, due to some technical limitations in the MariaDB server, there are few cases when the server cannot apply this optimization.</source>
          <target state="translated">하위 쿼리 구체화 전략은 보편적이지만 MariaDB 서버의 일부 기술적 제한으로 인해 서버가이 최적화를 적용 할 수없는 경우는 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="8027ffdb297271f6cc6b8041f4fba95b5d1f626d" translate="yes" xml:space="preserve">
          <source>In releases after &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt;, &lt;code&gt;LOAD DATA INFILE&lt;/code&gt; is &lt;a href=&quot;../unsafe-statements-for-replication/index&quot;&gt;unsafe&lt;/a&gt; for statement-based replication.</source>
          <target state="translated">&lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt; 이후 릴리스 에서 &lt;code&gt;LOAD DATA INFILE&lt;/code&gt; 은 명령문 기반 복제에 &lt;a href=&quot;../unsafe-statements-for-replication/index&quot;&gt;안전하지&lt;/a&gt; 않습니다.</target>
        </trans-unit>
        <trans-unit id="a319871390566f13a8f0b9230a0570d0a9f1358d" translate="yes" xml:space="preserve">
          <source>In semisynchronous replication, only after the events have been written to the relay log and flushed does the slave acknowledge receipt of a transaction's events. If the slave does not acknowledge the transaction before a certain amount of time has passed, then a timeout occurs and the master switches to asynchronous replication. This will be reflected in the master's &lt;a href=&quot;../error-log/index&quot;&gt;error log&lt;/a&gt; with messages like the following:</source>
          <target state="translated">반 동기식 복제에서는 이벤트가 릴레이 로그에 기록되고 플러시 된 후에 만 ​​슬레이브가 트랜잭션의 이벤트 수신을 승인합니다. 특정 시간이 지나기 전에 슬레이브가 트랜잭션을 승인하지 않으면 시간 초과가 발생하고 마스터가 비동기 복제로 전환됩니다. 이것은 다음과 같은 메시지와 함께 마스터의 &lt;a href=&quot;../error-log/index&quot;&gt;오류 로그에&lt;/a&gt; 반영됩니다 .</target>
        </trans-unit>
        <trans-unit id="2ad6040aaf3e1f2fea199e16233773132d5963bf" translate="yes" xml:space="preserve">
          <source>In semisynchronous replication, there are two potential points at which the master can wait for the slave acknowledge the receipt of a transaction's events. These two wait points have different advantages and disadvantages.</source>
          <target state="translated">반동기 복제에는 마스터가 슬레이브가 트랜잭션 이벤트 수신을 승인 할 때까지 기다릴 수있는 두 가지 잠재적 지점이 있습니다. 이 두 대기 지점은 서로 다른 장단점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9273fe5a2aa52f551dfe2beab83b03182e57eb4" translate="yes" xml:space="preserve">
          <source>In sequential test mode, the number of loops to execute before exiting.</source>
          <target state="translated">순차 테스트 모드에서 종료하기 전에 실행할 루프 수.</target>
        </trans-unit>
        <trans-unit id="3ce5b642e39908a5772cdf157cfcf69a1149fcce" translate="yes" xml:space="preserve">
          <source>In situations where accurate data from &lt;a href=&quot;../analyze-table/index&quot;&gt;ANALYZE TABLE&lt;/a&gt; statements is important, enable the &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_stats_persistent&quot;&gt;innodb_stats_persistent&lt;/a&gt; system variable. Additionally, you can use the &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_stats_transient_sample_pages&quot;&gt;innodb_stats_transient_sample_pages&lt;/a&gt; system variable to change the number of random dives it performs.</source>
          <target state="translated">&lt;a href=&quot;../analyze-table/index&quot;&gt;ANALYZE TABLE&lt;/a&gt; 문의 정확한 데이터 가 중요한 상황에서는 &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_stats_persistent&quot;&gt;innodb_stats_persistent&lt;/a&gt; 시스템 변수를 활성화하십시오 . 또한 &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_stats_transient_sample_pages&quot;&gt;innodb_stats_transient_sample_pages&lt;/a&gt; 시스템 변수를 사용하여 수행하는 임의 다이빙 수를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d17ace648d9f6bf653b41e01b3aa2e676453846" translate="yes" xml:space="preserve">
          <source>In situations where you find yourself using certain Mariabackup options consistently every time you call it, you can set the options in an &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;option file&lt;/a&gt;. The &lt;code&gt;--defaults-group&lt;/code&gt; option defines what option group Mariabackup reads for its options.</source>
          <target state="translated">전화 할 때마다 특정 Mariabackup 옵션을 일관되게 사용하는 경우 &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;옵션 파일&lt;/a&gt; 에서 옵션을 설정할 수 있습니다 . &lt;code&gt;--defaults-group&lt;/code&gt; 옵션을 정의 옵션 그룹 Mariabackup는 옵션에 대해 무엇을 읽고.</target>
        </trans-unit>
        <trans-unit id="c42b50f1dfbe4a89a8f417953cac7c9595aa3808" translate="yes" xml:space="preserve">
          <source>In small bottles</source>
          <target state="translated">작은 병에</target>
        </trans-unit>
        <trans-unit id="21f93cbde20d2a2275421a54c46140b61b0fbaf8" translate="yes" xml:space="preserve">
          <source>In some &lt;a href=&quot;../data-types-character-sets-and-collations/index&quot;&gt;character sets&lt;/a&gt;, not all characters use the same number of bytes. utf8 encodes characters with one to three bytes per character, while utf8mb4 requires one to four bytes per character.</source>
          <target state="translated">일부 &lt;a href=&quot;../data-types-character-sets-and-collations/index&quot;&gt;문자 세트&lt;/a&gt; 에서 모든 문자가 동일한 바이트 수를 사용하는 것은 아닙니다. utf8은 문자 당 1-3 바이트의 문자를 인코딩하는 반면 utf8mb4는 문자 당 1-4 바이트가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="61d493c560dd846ac797eee37206963fa34fc866" translate="yes" xml:space="preserve">
          <source>In some case or some platform, when CONNECT is set up for use with JDBC table types, this causes &lt;a href=&quot;../mysqldump/index&quot;&gt;mysqldump&lt;/a&gt; with the option --all-databases to fail.</source>
          <target state="translated">어떤 경우 또는 일부 플랫폼에서 JDBC 테이블 유형과 함께 사용하기 위해 CONNECT가 설정되면 --all-databases 옵션 이있는 &lt;a href=&quot;../mysqldump/index&quot;&gt;mysqldump&lt;/a&gt; 가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="8f494656a35890e4757768268e9d848dd6a27a9a" translate="yes" xml:space="preserve">
          <source>In some case or some platforms, when CONNECT is set up for use with JDBC table types, this causes &lt;a href=&quot;../mysqldump/index&quot;&gt;mysqldump&lt;/a&gt; with the --all-databases option to fail.</source>
          <target state="translated">일부 또는 일부 플랫폼에서 JDBC 테이블 유형에 사용하기 위해 CONNECT가 설정 되면 --all-databases 옵션 이있는 &lt;a href=&quot;../mysqldump/index&quot;&gt;mysqldump&lt;/a&gt; 가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="c81c5bfb594c78801ab4cb408f2f6344f8c2c9f2" translate="yes" xml:space="preserve">
          <source>In some cases Galera will refuse to bootstrap a node if it detects that it might not be the most advanced node in the cluster. Galera makes this determination if the node was not the last one in the cluster to be shut down or if the node crashed. In those cases, manual intervention is needed.</source>
          <target state="translated">경우에 따라 Galera는 노드가 클러스터에서 가장 고급 노드가 아닌 것으로 감지되면 노드 부트 스트랩을 거부합니다. Galera는 노드가 종료 될 클러스터의 마지막 노드가 아니거나 노드가 충돌 한 경우이 결정을합니다. 이 경우 수동 개입이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="84ddcb240e8c8f5d44deaabf494414466c13419b" translate="yes" xml:space="preserve">
          <source>In some cases it is optimal to do step 1 (all equals) plus step 2c (ORDER BY).</source>
          <target state="translated">어떤 경우에는 1 단계 (모두 동일)에 2 단계 (ORDER BY)를 더하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="dd35b48902822d9daecd5596c3df0abcc6cc075c" translate="yes" xml:space="preserve">
          <source>In some cases the optimizer may choose a non-optimal index or it may choose to not use an index at all, even if some index could theoretically be used.</source>
          <target state="translated">어떤 경우에는 옵티마이 저가 비 최적 인덱스를 선택하거나 이론적으로 일부 인덱스를 사용할 수있는 경우에도 인덱스를 전혀 사용하지 않도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdf2009bc760396ab2ce83cfb8ac46c5f5ef0410" translate="yes" xml:space="preserve">
          <source>In some cases you may want to force the use of a temporary table for the result to free up the table/row locks for the used tables as quickly as possible.</source>
          <target state="translated">경우에 따라 임시 테이블을 사용하여 사용 된 테이블의 테이블 / 행 잠금을 가능한 빨리 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f48a7c5473974fa4cc0c9ec766fa44fabf0717c8" translate="yes" xml:space="preserve">
          <source>In some cases, Fusion-io devices allow for atomic writes, which allows the server to safely disable the &lt;a href=&quot;../xtradbinnodb-doublewrite-buffer/index&quot;&gt;doublewrite buffer&lt;/a&gt;.</source>
          <target state="translated">경우에 따라 Fusion-io 장치는 원자 쓰기를 허용하므로 서버가 &lt;a href=&quot;../xtradbinnodb-doublewrite-buffer/index&quot;&gt;이중 쓰기 버퍼&lt;/a&gt; 를 안전하게 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="64f1df95442a4a07dc3a536a9663831c1066d7cf" translate="yes" xml:space="preserve">
          <source>In some cases, a MariaDB system might need non-standard policies. It is possible to create these policies from the SELinux audit log using the &lt;code&gt;&lt;a href=&quot;https://linux.die.net/man/1/audit2allow&quot;&gt;audit2allow&lt;/a&gt;&lt;/code&gt; utility. The &lt;code&gt;&lt;a href=&quot;https://linux.die.net/man/8/semanage&quot;&gt;semanage&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;https://linux.die.net/man/8/semodule&quot;&gt;semodule&lt;/a&gt;&lt;/code&gt; utilities will also be needed.</source>
          <target state="translated">경우에 따라 MariaDB 시스템에는 비표준 정책이 필요할 수 있습니다. &lt;code&gt;&lt;a href=&quot;https://linux.die.net/man/1/audit2allow&quot;&gt;audit2allow&lt;/a&gt;&lt;/code&gt; 유틸리티를 사용하여 SELinux 감사 로그에서 이러한 정책을 작성할 수 있습니다 . &lt;code&gt;&lt;a href=&quot;https://linux.die.net/man/8/semanage&quot;&gt;semanage&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;https://linux.die.net/man/8/semodule&quot;&gt;semodule&lt;/a&gt;&lt;/code&gt; 유틸리티도 필요합니다.</target>
        </trans-unit>
        <trans-unit id="51b742670c48246b56a9727b48f3ad9847781c66" translate="yes" xml:space="preserve">
          <source>In some cases, a statement could produce multiple errors. If this happens, in some cases multiple handlers could have the highest precedence. In such cases, the choice of the handler is indeterminate.</source>
          <target state="translated">경우에 따라 명령문이 여러 오류를 생성 할 수 있습니다. 이 경우 여러 처리기가 가장 높은 우선 순위를 가질 수 있습니다. 이러한 경우 처리기의 선택이 불확실합니다.</target>
        </trans-unit>
        <trans-unit id="ae3cf6c6ecd5a7422ea1ec04072206b41aa9f430" translate="yes" xml:space="preserve">
          <source>In some cases, adding zeroes at the end of a decimal number can increment the precision of the expression where the number is used. For example, &lt;code&gt;&lt;a href=&quot;../pi/index&quot;&gt;PI()&lt;/a&gt;&lt;/code&gt; by default returns a number with 6 decimal digits. But the &lt;code&gt;PI()+0.0000000000&lt;/code&gt; expression (with 10 zeroes) returns a number with 10 decimal digits.</source>
          <target state="translated">경우에 따라 10 진수 끝에 0을 추가하면 숫자가 사용되는 표현식의 정밀도가 증가 할 수 있습니다. 예를 들어, &lt;code&gt;&lt;a href=&quot;../pi/index&quot;&gt;PI()&lt;/a&gt;&lt;/code&gt; 는 기본적으로 소수점 6 자리의 숫자를 반환합니다. 그러나 &lt;code&gt;PI()+0.0000000000&lt;/code&gt; 식 (0이 0 인)은 10 진수가 10 인 숫자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f187ab870d6af39b8a55a704cc74ee6517e8f90c" translate="yes" xml:space="preserve">
          <source>In some cases, if Galera Cluster's automatic SSTs repeatedly fail, then it can be helpful to perform a &quot;manual SST&quot;. See the following page on how to do that:</source>
          <target state="translated">Galera Cluster의 자동 SST가 반복적으로 실패하면 &quot;수동 SST&quot;를 수행하는 것이 도움이 될 수 있습니다. 이를 수행하는 방법에 대해서는 다음 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="22b76610bbdbd17b2aab94837fcaf3417c55be90" translate="yes" xml:space="preserve">
          <source>In some cases, if Galera Cluster's automatic SSTs repeatedly fail, then it can be helpful to perform a &quot;manual SST&quot;. See the following pages on how to do that:</source>
          <target state="translated">Galera Cluster의 자동 SST가 반복적으로 실패하면 &quot;수동 SST&quot;를 수행하는 것이 도움이 될 수 있습니다. 이를 수행하는 방법에 대해서는 다음 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="28dccb5fb7db5d8175b167c1c596a43792692d35" translate="yes" xml:space="preserve">
          <source>In some cases, it might make sense to only enable specific TLS protocol versions. For example, it would make sense if your organization has to comply with a specific security standard. It would also make sense if a vulnerability is found in a specific TLS protocol version, and you would like to ensure that your server does not use the vulnerable protocol version.</source>
          <target state="translated">경우에 따라 특정 TLS 프로토콜 버전 만 사용하도록 설정하는 것이 좋습니다. 예를 들어 조직이 특정 보안 표준을 준수해야하는 경우에 적합합니다. 특정 TLS 프로토콜 버전에서 취약점이 발견되면 서버가 취약한 프로토콜 버전을 사용하지 않도록하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="80c5a5cda1d68fa57194a66e1c3732052d63b69f" translate="yes" xml:space="preserve">
          <source>In some cases, knowledge of the database allows one to compute statistics manually in a more efficient way than ANALYZE does. One can compute the statistics manually and put it into the database.</source>
          <target state="translated">어떤 경우에는 데이터베이스에 대한 지식으로 ANALYZE보다 효율적인 방식으로 통계를 수동으로 계산할 수 있습니다. 통계를 수동으로 계산하여 데이터베이스에 넣을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fe3bd8bb5da9c9ecf726d59ba1182a06aeded4b" translate="yes" xml:space="preserve">
          <source>In some cases, remember to include a space in the separator string:</source>
          <target state="translated">경우에 따라 구분자 문자열에 공백을 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="e41edbccf7b0530da1fa17c69c689493e1aef9ed" translate="yes" xml:space="preserve">
          <source>In some cases, there may be easier ways to run multiple MariaDB Server instances on the same server, such as::</source>
          <target state="translated">경우에 따라 다음과 같은 동일한 서버에서 여러 MariaDB 서버 인스턴스를보다 쉽게 ​​실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df99afde01c00af5732557ee28c8367bfb1f82f9" translate="yes" xml:space="preserve">
          <source>In some earlier versions, from &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5533-release-notes/&quot;&gt;MariaDB 5.5.33&lt;/a&gt; and &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1005-release-notes/&quot;&gt;MariaDB 10.0.5&lt;/a&gt;, TokuDB is in a separate package called &lt;code&gt;mariadb-tokudb-engine-x.x&lt;/code&gt;, where &lt;code&gt;x.x&lt;/code&gt; is the MariaDB series (&lt;code&gt;5.5&lt;/code&gt; or &lt;code&gt;10.0&lt;/code&gt;). The package is installed, for example on &lt;code&gt;5.5&lt;/code&gt;, as follows:</source>
          <target state="translated">이전 버전의 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5533-release-notes/&quot;&gt;MariaDB 5.5.33&lt;/a&gt; 및 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1005-release-notes/&quot;&gt;MariaDB 10.0.5&lt;/a&gt; 에서 TokuDB는 &lt;code&gt;mariadb-tokudb-engine-x.x&lt;/code&gt; 라는 별도의 패키지 에 있습니다. 여기서 &lt;code&gt;x.x&lt;/code&gt; 는 MariaDB 시리즈 ( &lt;code&gt;5.5&lt;/code&gt; 또는 &lt;code&gt;10.0&lt;/code&gt; )입니다. 패키지는 다음과 같이 예를 들어 &lt;code&gt;5.5&lt;/code&gt; 에 설치 됩니다.</target>
        </trans-unit>
        <trans-unit id="1747ebab48644b97e66499e702f45428eb570ba3" translate="yes" xml:space="preserve">
          <source>In some images, no repository is configured by default, so we may need to add them.</source>
          <target state="translated">일부 이미지에서는 기본적으로 리포지토리가 구성되어 있지 않으므로 추가해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd3dffb6f549424177d784b663822c3adbeaf6aa" translate="yes" xml:space="preserve">
          <source>In some of the scenarios listed above, a thread is only created within a thread group if no new threads have been created for the thread group within the &lt;em&gt;throttling interval&lt;/em&gt;. The throttling interval depends on the number of threads that are already in the thread group.</source>
          <target state="translated">위에 나열된 일부 시나리오에서 &lt;em&gt;제한 간격&lt;/em&gt; 내에 스레드 그룹에 대해 새 스레드가 작성되지 않은 경우 스레드 그룹 내에서만 스레드가 작성됩니다 . 조절 간격은 이미 스레드 그룹에있는 스레드 수에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="84e242155b282f58259e5e0571f17625338a6b78" translate="yes" xml:space="preserve">
          <source>In some rare cases MariaDB needs to know whether a given table exists, but does not particularly care about this table structure (for example, when executing a &lt;code&gt;DROP TABLE&lt;/code&gt; statement). In these cases, the server uses the &lt;strong&gt;discover_table_existence()&lt;/strong&gt; method to find out whether a table with the given name exists in the engine.</source>
          <target state="translated">드문 경우에 MariaDB는 주어진 테이블이 존재하는지 여부를 알아야하지만 특히이 테이블 구조 (예 : &lt;code&gt;DROP TABLE&lt;/code&gt; 문을 실행할 때)를 신경 쓰지 않습니다 . 이 경우, 서버는 &lt;strong&gt;discover_table_existence ()&lt;/strong&gt; 메소드를 사용하여 지정된 이름의 테이블이 엔진에 있는지 여부를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="e204184e5f08af99aa5949ff0f89bb4a55187be9" translate="yes" xml:space="preserve">
          <source>In some versions, this could happen while creating a table with the &lt;code&gt;&lt;a href=&quot;../create-table/index#encrypted&quot;&gt;ENCRYPTED&lt;/a&gt;&lt;/code&gt; table option set to &lt;code&gt;DEFAULT&lt;/code&gt; while the &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encrypt_tables&quot;&gt;innodb_encrypt_tables&lt;/a&gt;&lt;/code&gt; system variable is set to &lt;code&gt;OFF&lt;/code&gt;, and the &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_default_encryption_key_id&quot;&gt;innodb_default_encryption_key_id&lt;/a&gt;&lt;/code&gt; system variable or the &lt;code&gt;&lt;a href=&quot;../create-table/index#encryption_key_id&quot;&gt;ENCRYPTION_KEY_ID&lt;/a&gt;&lt;/code&gt; table option are &lt;strong&gt;not&lt;/strong&gt; set to &lt;code&gt;1&lt;/code&gt;. In this case, &lt;code&gt;&lt;a href=&quot;../show-warnings/index&quot;&gt;SHOW WARNINGS&lt;/a&gt;&lt;/code&gt; would return the following:</source>
          <target state="translated">일부 버전에서는 &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encrypt_tables&quot;&gt;innodb_encrypt_tables&lt;/a&gt;&lt;/code&gt; 시스템 변수가 &lt;code&gt;OFF&lt;/code&gt; 로 설정되어 있고 &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_default_encryption_key_id&quot;&gt;innodb_default_encryption_key_id&lt;/a&gt;&lt;/code&gt; 시스템 변수 또는 &lt;code&gt;&lt;a href=&quot;../create-table/index#encryption_key_id&quot;&gt;ENCRYPTION_KEY_ID&lt;/a&gt;&lt;/code&gt; 테이블 옵션이 &lt;code&gt;1&lt;/code&gt; 로 설정되어 &lt;strong&gt;있지 않은&lt;/strong&gt; 상태 에서 &lt;code&gt;&lt;a href=&quot;../create-table/index#encrypted&quot;&gt;ENCRYPTED&lt;/a&gt;&lt;/code&gt; 테이블 옵션이 &lt;code&gt;DEFAULT&lt;/code&gt; 로 설정된 테이블을 작성하는 중에 이러한 상황이 발생할 수 있습니다. 이 경우 &lt;code&gt;&lt;a href=&quot;../show-warnings/index&quot;&gt;SHOW WARNINGS&lt;/a&gt;&lt;/code&gt; 는 다음을 반환합니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e12e722ec574bf81972ea5a5078db4ba21b10ba3" translate="yes" xml:space="preserve">
          <source>In some very special cases, even if materialization was forced, the optimizer may still revert to the IN-TO-EXISTS strategy if materialization is not applicable. In the cases when materialization requres partial matching (because of the presense of NULL values), there are two subordinate switches that control the two partial matching strategies:</source>
          <target state="translated">매우 특별한 경우에, 구체화가 강제 되더라도 구체화를 적용 할 수없는 경우 옵티마이 저는 여전히 IN-TO-EXISTS 전략으로 되돌아 갈 수 있습니다. 구체화가 NULL 값의 존재로 인해 부분 일치를 요구하는 경우 두 부분 일치 전략을 제어하는 ​​두 개의 하위 스위치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0b01915902cea7f45011105b672239b1e816a60" translate="yes" xml:space="preserve">
          <source>In some ways, window functions are similar to &lt;a href=&quot;../aggregate-functions/index&quot;&gt;aggregate functions&lt;/a&gt; in that they perform calculations across a set of rows. However, unlike aggregate functions, the output is not grouped into a single row.</source>
          <target state="translated">어떤면에서 창 함수는 행 집합에서 계산을 수행한다는 점에서 &lt;a href=&quot;../aggregate-functions/index&quot;&gt;집계 함수&lt;/a&gt; 와 유사합니다 . 그러나 집계 함수와 달리 출력은 단일 행으로 그룹화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="08990a1eaf362e60bd6f4608259b4057c256f3d0" translate="yes" xml:space="preserve">
          <source>In source distributions, the sample option files are usually found in the &lt;code&gt;support-files&lt;/code&gt; directory, and in other distributions, the option files are usually found in the &lt;code&gt;share/mysql&lt;/code&gt; directory that is relative to the MariaDB base installation directory.</source>
          <target state="translated">소스 배포에서 샘플 옵션 파일은 일반적으로 &lt;code&gt;support-files&lt;/code&gt; 디렉토리에 있으며 다른 배포에서는 옵션 파일이 일반적으로 MariaDB 기본 설치 디렉토리 와 관련된 &lt;code&gt;share/mysql&lt;/code&gt; 디렉토리에 있습니다.</target>
        </trans-unit>
        <trans-unit id="33fa7325329ee153c471a9b6bb2953bb3b90a8a7" translate="yes" xml:space="preserve">
          <source>In streaming data from MariaDB Server to ColumnStore for analysis, MaxScale requires that the Servers format the binary log events by each row modified by a statement, rather than by operation. So, when deploying a cluster for HTAP, ensure that the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#binlog_format&quot;&gt;binlog_format&lt;/a&gt;&lt;/code&gt; system variable on the MariaDB Servers is always set to the &lt;code&gt;ROW&lt;/code&gt; value.</source>
          <target state="translated">분석을 위해 MariaDB 서버에서 ColumnStore로 데이터를 스트리밍 할 때 MaxScale에서는 서버가 작업이 아닌 명령문으로 수정 된 각 행별로 이진 로그 이벤트를 형식화해야합니다. 따라서 HTAP 용 클러스터를 배치 할 때 MariaDB 서버 의 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#binlog_format&quot;&gt;binlog_format&lt;/a&gt;&lt;/code&gt; 시스템 변수가 항상 &lt;code&gt;ROW&lt;/code&gt; 값으로 설정되어 있는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="2992ead0fd76a6359a59a4bce65f3145e8fd411b" translate="yes" xml:space="preserve">
          <source>In such setups, each active master must be configured with its own distinct replication domain ID, &lt;a href=&quot;#gtid_domain_id&quot;&gt;gtid_domain_id&lt;/a&gt;. The binlog will then in effect consists of multiple independent streams, one per active master. Within one replication domain, binlog order is always the same on every server. But two different streams can be interleaved differently in different server binlogs.</source>
          <target state="translated">이러한 설정에서 각 활성 마스터는 고유 한 복제 도메인 ID &lt;a href=&quot;#gtid_domain_id&quot;&gt;gtid_domain_id&lt;/a&gt; 로 구성해야합니다 . 그러면 binlog는 실제로 활성 마스터 당 하나씩 여러 개의 독립적 인 스트림으로 구성됩니다. 하나의 복제 도메인 내에서 binlog 순서는 모든 서버에서 항상 동일합니다. 그러나 두 개의 다른 스트림은 다른 서버 binlog에서 다르게 인터리브 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d5e3fbf65590a719f53faf6f88ca284326180b2" translate="yes" xml:space="preserve">
          <source>In supported builds, Galera Cluster functionality can be enabled by setting some configuration options that are mentioned below. Galera Cluster functionality is not enabled in a standard MariaDB Server installation unless explicitly enabled with these configuration options.</source>
          <target state="translated">지원되는 빌드에서 아래에 언급 된 일부 구성 옵션을 설정하여 Galera Cluster 기능을 활성화 할 수 있습니다. Galera Cluster 기능은 이러한 구성 옵션으로 명시 적으로 활성화하지 않으면 표준 MariaDB 서버 설치에서 활성화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1d562c299f4cae1af76edac5bde456c1979bb744" translate="yes" xml:space="preserve">
          <source>In that case, one can set &lt;code&gt;@@rocksdb_unsafe_for_binlog=1&lt;/code&gt; and MyRocks will work with SBR. The user is however responsible for making sure their queries are not causing a data skew.</source>
          <target state="translated">이 경우 &lt;code&gt;@@rocksdb_unsafe_for_binlog=1&lt;/code&gt; 설정할 수 있으며 MyRocks는 SBR과 함께 작동합니다. 그러나 사용자는 쿼리로 인해 데이터가 왜곡되지 않도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="119b053bd02d05267b2286bc224f2ce51ac4a94d" translate="yes" xml:space="preserve">
          <source>In that case, the Condition Pushdown optimization is applicable.</source>
          <target state="translated">이 경우 조건 푸시 다운 최적화가 적용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="82d411853b3d219c70faf3d92ccbd7eb647df205" translate="yes" xml:space="preserve">
          <source>In that case, you will need to add more memory to your server/VM or decrease the value of the &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_buffer_pool_size&quot;&gt;innodb_buffer_pool_size&lt;/a&gt; variables.</source>
          <target state="translated">이 경우 서버 / VM에 메모리를 추가하거나 &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_buffer_pool_size&quot;&gt;innodb_buffer_pool_size&lt;/a&gt; 변수 값을 줄여야합니다 .</target>
        </trans-unit>
        <trans-unit id="60df046d91b0a4e79d7f44f795a020afe2bd8063" translate="yes" xml:space="preserve">
          <source>In the &quot;Adjusting your PATH&quot; dialog, choose &quot;Use Git from Windows command prompt&quot;, otherwise wrong (mingw64) git and perl will be in your PATH</source>
          <target state="translated">&quot;PATH 조정&quot;대화창에서 &quot;Windows 명령 프롬프트에서 Git 사용&quot;을 선택하십시오. 그렇지 않으면 잘못된 (mingw64) git 및 perl이 PATH에 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed3366a7a306bbc4c9e1b6cbc1ac4c952e260747" translate="yes" xml:space="preserve">
          <source>In the &quot;CloudWatch Logs&quot; section, click &quot;Configure&quot;.</source>
          <target state="translated">&quot;CloudWatch Logs&quot;섹션에서 &quot;Configure&quot;를 클릭하십시오.</target>
        </trans-unit>
        <trans-unit id="03b8d2bed98e8680e21f301ba61879fbafb7845e" translate="yes" xml:space="preserve">
          <source>In the &quot;Sign-In Credentials&quot; section, click the &quot;Manage MFA Device&quot; button.</source>
          <target state="translated">&quot;로그인 자격 증명&quot;섹션에서 &quot;MFA 장치 관리&quot;버튼을 클릭하십시오.</target>
        </trans-unit>
        <trans-unit id="80c9a5e5479eded1f45f90b2278ff96cf62d6196" translate="yes" xml:space="preserve">
          <source>In the 1.1 version and later, MariaDB ColumnStore supports a Non-Distributed option for Multi-Node installs. With this option, the user is required to install the MariaDB ColumnStore on all the nodes in the system.</source>
          <target state="translated">1.1 버전 이상에서 MariaDB ColumnStore는 다중 노드 설치에 대해 비 분산 옵션을 지원합니다. 이 옵션을 사용하면 사용자는 시스템의 모든 노드에 MariaDB ColumnStore를 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="2b75dc9a84d057bdfc56b6b6d19a34ed00ed5c0e" translate="yes" xml:space="preserve">
          <source>In the 1.2.2 and earlier releases, MariaDB ColumnStore Process like PrimProc, ExeMgr, or WriteEngineService can automatically restart due to over allocation of memory. PrimProc and WriteEngineService run on the Performance Module. ExeMgr runs on the User Module.</source>
          <target state="translated">1.2.2 이하 릴리스에서는 PrimProc, ExeMgr 또는 WriteEngineService와 같은 MariaDB ColumnStore 프로세스가 메모리 초과 할당으로 인해 자동으로 다시 시작할 수 있습니다. PrimProc 및 WriteEngineService는 성능 모듈에서 실행됩니다. ExeMgr은 사용자 모듈에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="a4873e6e5195f176bc0eb1e0f50757b80f058ccf" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;../mysqlbinlog/index&quot;&gt;binary log&lt;/a&gt;, each &lt;code&gt;Annotate_rows&lt;/code&gt; event precedes the corresponding Table map event or the first of the Table map events, if there are more than one (e.g. in a case of multi-delete or insert delayed).</source>
          <target state="translated">에서 &lt;a href=&quot;../mysqlbinlog/index&quot;&gt;바이너리 로그&lt;/a&gt; , 각 &lt;code&gt;Annotate_rows&lt;/code&gt; 가있는 경우 이벤트가 해당 테이블 맵 이벤트 또는 표 맵 이벤트의 첫 번째 앞에 하나 이상의 (예 : 멀티 삭제 또는 지연 삽입물의 경우에).</target>
        </trans-unit>
        <trans-unit id="1027a55ddbd3f8af870c4a0d03487d3028a66e2f" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;COMPACT&lt;/code&gt; row format variable-length columns, such as columns using the &lt;code&gt;&lt;a href=&quot;../varbinary/index&quot;&gt;VARBINARY&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../varchar/index&quot;&gt;VARCHAR&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../blob/index&quot;&gt;BLOB&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../text/index&quot;&gt;TEXT&lt;/a&gt;&lt;/code&gt; data types, can be partially stored in overflow pages.</source>
          <target state="translated">에서 &lt;code&gt;COMPACT&lt;/code&gt; 같은 사용 열과 행의 형식의 가변 길이 열 &lt;code&gt;&lt;a href=&quot;../varbinary/index&quot;&gt;VARBINARY&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../varchar/index&quot;&gt;VARCHAR&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../blob/index&quot;&gt;BLOB&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;../text/index&quot;&gt;TEXT&lt;/a&gt;&lt;/code&gt; 를 데이터 형식, 부분 오버플 페이지에 저장 될 수있다.</target>
        </trans-unit>
        <trans-unit id="9931b9ebd74a91d7885de3211546f8772dbf835c" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;COMPRESSED&lt;/code&gt; row format variable-length columns, such as columns using the &lt;code&gt;&lt;a href=&quot;../varbinary/index&quot;&gt;VARBINARY&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../varchar/index&quot;&gt;VARCHAR&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../blob/index&quot;&gt;BLOB&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../text/index&quot;&gt;TEXT&lt;/a&gt;&lt;/code&gt; data types, can be completely stored in overflow pages.</source>
          <target state="translated">에서 &lt;code&gt;COMPRESSED&lt;/code&gt; 같은 사용 열과 행의 형식의 가변 길이 열 &lt;code&gt;&lt;a href=&quot;../varbinary/index&quot;&gt;VARBINARY&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../varchar/index&quot;&gt;VARCHAR&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../blob/index&quot;&gt;BLOB&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;../text/index&quot;&gt;TEXT&lt;/a&gt;&lt;/code&gt; 를 데이터 형식 완전히 오버 플로우 페이지에 저장 될 수있다.</target>
        </trans-unit>
        <trans-unit id="3081c40391f0257bfaf8f276ca023c67d8e04d0a" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;DYNAMIC&lt;/code&gt; row format variable-length columns, such as columns using the &lt;code&gt;&lt;a href=&quot;../varbinary/index&quot;&gt;VARBINARY&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../varchar/index&quot;&gt;VARCHAR&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../blob/index&quot;&gt;BLOB&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../text/index&quot;&gt;TEXT&lt;/a&gt;&lt;/code&gt; data types, can be completely stored in overflow pages.</source>
          <target state="translated">에서 &lt;code&gt;DYNAMIC&lt;/code&gt; 같은 사용 열과 행의 형식의 가변 길이 열 &lt;code&gt;&lt;a href=&quot;../varbinary/index&quot;&gt;VARBINARY&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../varchar/index&quot;&gt;VARCHAR&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../blob/index&quot;&gt;BLOB&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;../text/index&quot;&gt;TEXT&lt;/a&gt;&lt;/code&gt; 를 데이터 유형을 완전히 오버 플로우 페이지에 저장 될 수있다.</target>
        </trans-unit>
        <trans-unit id="4480632b7aa6c63829717ccb5ed72973f1f3a299" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;REDUNDANT&lt;/code&gt; row format variable-length columns, such as columns using the &lt;code&gt;&lt;a href=&quot;../varbinary/index&quot;&gt;VARBINARY&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../varchar/index&quot;&gt;VARCHAR&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../blob/index&quot;&gt;BLOB&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../text/index&quot;&gt;TEXT&lt;/a&gt;&lt;/code&gt; data types, can be partially stored in overflow pages.</source>
          <target state="translated">에서 &lt;code&gt;REDUNDANT&lt;/code&gt; 같은 사용 열과 행의 형식의 가변 길이 열 &lt;code&gt;&lt;a href=&quot;../varbinary/index&quot;&gt;VARBINARY&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../varchar/index&quot;&gt;VARCHAR&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../blob/index&quot;&gt;BLOB&lt;/a&gt;&lt;/code&gt; 과 &lt;code&gt;&lt;a href=&quot;../text/index&quot;&gt;TEXT&lt;/a&gt;&lt;/code&gt; 의 데이터 타입을 부분적으로 오버 플로우 페이지에 저장 될 수있다.</target>
        </trans-unit>
        <trans-unit id="e2bb072988a888fa1676208d5cc78ad08e905b01" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;WHERE&lt;/code&gt; clause, you can use any of the functions and operators that MariaDB supports, except for aggregate (summary) functions. See &lt;a href=&quot;../functions-and-operators/index&quot;&gt;Functions and Operators&lt;/a&gt; and &lt;a href=&quot;../functions-and-modifiers-for-use-with-group-by/index&quot;&gt;Functions and Modifiers for use with GROUP BY&lt;/a&gt; (aggregate).</source>
          <target state="translated">에서 &lt;code&gt;WHERE&lt;/code&gt; 절, 당신은 MariaDB가 지원, 집계 (요약) 기능을 제외하는 함수와 연산자 중 하나를 사용할 수 있습니다. &lt;a href=&quot;../functions-and-modifiers-for-use-with-group-by/index&quot;&gt;GROUP BY&lt;/a&gt; (집계) 와 함께 사용하려면 &lt;a href=&quot;../functions-and-operators/index&quot;&gt;함수 및 연산자&lt;/a&gt; 와 함수 및 수정자를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="71ea0b85efe4b261e41a2c86258e6442abe6021c" translate="yes" xml:space="preserve">
          <source>In the Explorer applet &quot;Programs and Features&quot; (or &quot;Add/Remove programs&quot; on older Windows), find the entry for MariaDB, choose Uninstall/Change and click on the &quot;Remove&quot; button in the dialog below.</source>
          <target state="translated">탐색기 애플릿 &quot;프로그램 및 기능&quot;(또는 이전 Windows의 &quot;프로그램 추가 / 제거&quot;)에서 MariaDB에 대한 항목을 찾아 제거 / 변경을 선택한 다음 아래 대화 상자에서 &quot;제거&quot;버튼을 클릭하십시오.</target>
        </trans-unit>
        <trans-unit id="7db46b7d7c7b86e8e8219ba4e60913e5f4416892" translate="yes" xml:space="preserve">
          <source>In the MariaDB ColumnStore 1.2.1 and later, sudo configuration is only required for certain system configurations.</source>
          <target state="translated">MariaDB ColumnStore 1.2.1 이상에서 sudo 구성은 특정 시스템 구성에만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="9c83f55a6fa06250b95606b0261ff192193beefb" translate="yes" xml:space="preserve">
          <source>In the MariaDB binary tarballs, only the ones labeled &quot;glibc_214&quot; have TokuDB.</source>
          <target state="translated">MariaDB 바이너리 타르볼에서 &quot;glibc_214&quot;로 표시된 것만 TokuDB가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d7757ac17878a24e7bdaef0e45aacea9273f271" translate="yes" xml:space="preserve">
          <source>In the Processing steps, USE that database, reach into the main db via syntax like &quot;MainDb.Hosts&quot;. (Otherwise, the binlog-ignore-db does the wrong thing.)</source>
          <target state="translated">처리 단계에서 해당 데이터베이스를 사용하고 &quot;MainDb.Hosts&quot;와 같은 구문을 통해 기본 데이터베이스에 도달하십시오. (그렇지 않으면 binlog-ignore-db는 잘못된 일을합니다.)</target>
        </trans-unit>
        <trans-unit id="46386444e4189ff6b7b8668a9742326c65086726" translate="yes" xml:space="preserve">
          <source>In the above cases, the server reverts to the &lt;a href=&quot;index#the-in-to-exists-transformation&quot;&gt;IN-TO-EXISTS&lt;/a&gt; transformation.</source>
          <target state="translated">위의 경우 서버는 &lt;a href=&quot;index#the-in-to-exists-transformation&quot;&gt;IN-TO-EXISTS&lt;/a&gt; 변환으로 되돌아갑니다 .</target>
        </trans-unit>
        <trans-unit id="3052cabb295bbd8f562c38b4a71d21131d40d183" translate="yes" xml:space="preserve">
          <source>In the above example, the &lt;code&gt;alice&lt;/code&gt; user account does not require TLS when logging in from localhost. However, when the &lt;code&gt;alice&lt;/code&gt; user account logs in from any other host, they must use TLS with the given cipher, and they must provide a valid client certificate with the given subject that must have been signed by the given issuer.</source>
          <target state="translated">위의 예에서 &lt;code&gt;alice&lt;/code&gt; 사용자 계정은 localhost에서 로그인 할 때 TLS가 필요하지 않습니다. 그러나 &lt;code&gt;alice&lt;/code&gt; 사용자 계정이 다른 호스트에서 로그인 할 때, 주어진 암호와 함께 TLS를 사용해야하며, 지정된 발행자가 서명 한 주어진 주제와 함께 유효한 클라이언트 인증서를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="b35521b93c6d181725e1b35b22d8a27d8d8ea161" translate="yes" xml:space="preserve">
          <source>In the above example, the choice produces a better query plan. Without pullout, the query plan with a subquery would read &lt;code&gt;(4079 + 1*4079)=8158&lt;/code&gt; table records. With table pullout, the join plan would read &lt;code&gt;(37 + 37 * 18) = 703&lt;/code&gt; rows. Not all row reads are equal, but generally, reading &lt;code&gt;10&lt;/code&gt; times fewer table records is faster.</source>
          <target state="translated">위의 예에서 선택하면 더 나은 쿼리 계획이 생성됩니다. 풀 아웃이 없으면 하위 쿼리가있는 쿼리 계획은 &lt;code&gt;(4079 + 1*4079)=8158&lt;/code&gt; 테이블 레코드를 읽습니다 . 테이블 풀 아웃의 경우 결합 계획은 &lt;code&gt;(37 + 37 * 18) = 703&lt;/code&gt; 행을 읽습니다 . 모든 행 읽기가 동일한 것은 아니지만 일반적으로 &lt;code&gt;10&lt;/code&gt; 배 적은 테이블 레코드를 읽는 것이 더 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="b82ef612a2521462f9f1e24e38cd336344f34376" translate="yes" xml:space="preserve">
          <source>In the above example, the format for this (1st) field is &lt;code&gt;' %n%s%n'&lt;/code&gt;. Note that the blank character at the beginning of this format &lt;strong&gt;is&lt;/strong&gt; significant. No trailing blank should be specified in the column formats.</source>
          <target state="translated">위의 예에서이 첫 번째 필드의 형식은 &lt;code&gt;' %n%s%n'&lt;/code&gt; 입니다. 이 형식의 시작 부분에있는 공백 문자 &lt;strong&gt;는&lt;/strong&gt; 중요합니다. 열 형식에는 후행 공백을 지정하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="9c587571e6b8ab6c4d97234c7a6b868cb6f0b264" translate="yes" xml:space="preserve">
          <source>In the above log snippet, notice that both the &lt;code&gt;pam_unix&lt;/code&gt; and the &lt;code&gt;pam_sss&lt;/code&gt; PAM modules are complaining that the &lt;code&gt;dba&lt;/code&gt; PAM user does not appear to exist, and that these complaints cause the PAM authentication process to fail, which causes the MariaDB authentication process to fail as well.</source>
          <target state="translated">위의 로그 스 니펫에서 &lt;code&gt;pam_unix&lt;/code&gt; 및 &lt;code&gt;pam_sss&lt;/code&gt; PAM 모듈 모두 &lt;code&gt;dba&lt;/code&gt; PAM 사용자가 존재하지 않는 것으로 나타나고 있으며 이러한 불만으로 인해 PAM 인증 프로세스가 실패하여 MariaDB 인증 프로세스가 실패합니다. 잘.</target>
        </trans-unit>
        <trans-unit id="5c9d948a7740d75d6b1a359bf264a8f4bd2d1121" translate="yes" xml:space="preserve">
          <source>In the above output, the &quot;rows&quot; column shows that the first is almost 10x less efficient and the second is over 15x less efficient than &lt;code&gt;index_merge&lt;/code&gt;.</source>
          <target state="translated">위의 출력에서 ​​&quot;행&quot;열은 첫 번째 열이 거의 10 배 덜 효율적이고 두 번째 열이 &lt;code&gt;index_merge&lt;/code&gt; 보다 15 배 이상 덜 효율적 임을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="d405a0b722882fb72149375dbbaa4f7379ed5b45" translate="yes" xml:space="preserve">
          <source>In the above table, &lt;code&gt;a&lt;/code&gt; is a &lt;a href=&quot;../storage-engine-index-types/index#hash-indexes&quot;&gt;HASH&lt;/a&gt; key that only supports exact matches (=) while &lt;code&gt;b&lt;/code&gt; is a &lt;a href=&quot;../storage-engine-index-types/index#b-tree-indexes&quot;&gt;BTREE&lt;/a&gt; key that you can use to scan the table in key order, starting from start or from a given key value.</source>
          <target state="translated">위의 표에서 &lt;code&gt;a&lt;/code&gt; 는 정확한 일치 만 지원 하는 &lt;a href=&quot;../storage-engine-index-types/index#hash-indexes&quot;&gt;HASH&lt;/a&gt; 키 (=)이고 &lt;code&gt;b&lt;/code&gt; 는 시작 또는 지정된 키 값에서 시작하여 키 순서로 테이블을 스캔하는 데 사용할 수 있는 &lt;a href=&quot;../storage-engine-index-types/index#b-tree-indexes&quot;&gt;BTREE&lt;/a&gt; 키입니다.</target>
        </trans-unit>
        <trans-unit id="e5bbaa9f64051acb42500cc911c6b2a6bc3311b3" translate="yes" xml:space="preserve">
          <source>In the background, combine these partially digested blocks. Repeat as needed.</source>
          <target state="translated">백그라운드에서 부분적으로 소화 된 블록을 결합하십시오. 필요에 따라 반복하십시오.</target>
        </trans-unit>
        <trans-unit id="c77b5bfb1ac170799d01fa8f183d8495f9ae38c2" translate="yes" xml:space="preserve">
          <source>In the bintar tarball it is &lt;code&gt;Snappy,Zlib&lt;/code&gt;.</source>
          <target state="translated">bintar tarball에서는 &lt;code&gt;Snappy,Zlib&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2d359eb320740a2a56b3b15f92331613a7247a3a" translate="yes" xml:space="preserve">
          <source>In the case of &lt;a href=&quot;../text/index&quot;&gt;TEXT&lt;/a&gt; columns, the handling depends on the values given to the &lt;a href=&quot;../connect-system-variables/index#connect_type_conv&quot;&gt;connect_type_conv&lt;/a&gt; and &lt;a href=&quot;../connect-system-variables/index#connect_conv_size&quot;&gt;connect_conv_size&lt;/a&gt; system variables. By default no conversion is permitted.</source>
          <target state="translated">&lt;a href=&quot;../text/index&quot;&gt;TEXT&lt;/a&gt; 컬럼 의 경우 처리는 &lt;a href=&quot;../connect-system-variables/index#connect_type_conv&quot;&gt;connect_type_conv&lt;/a&gt; 및 &lt;a href=&quot;../connect-system-variables/index#connect_conv_size&quot;&gt;connect_conv_size&lt;/a&gt; 시스템 변수에 제공된 값에 따라 다릅니다 . 기본적으로 변환은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eb1f1de0b4e1a3d3b662f0de64ad1c25174c904d" translate="yes" xml:space="preserve">
          <source>In the case of a unique file, inserting new data will be limited but there will be only one open and close to do. However, the size of the table cannot be calculated from the file size because of the eventual unused space in the file. It must be kept in a header containing the maximum number of rows and the current number of valid rows in the table. To achieve this, specify the option Header=&lt;em&gt;n&lt;/em&gt; when creating the table. If &lt;code&gt;n=1&lt;/code&gt; the header will be placed at the beginning of the file, if &lt;code&gt;n=2&lt;/code&gt; it will be a separate file with the type &amp;lsquo;.blk&amp;rsquo;, and if &lt;code&gt;n=3&lt;/code&gt; the header will be place at the end of the file. This last value is provided because batch inserting is sometimes slower when the header is at the beginning of the file. If not specified, the header option will default to 2 for this table type.</source>
          <target state="translated">고유 한 파일의 경우 새 데이터 삽입은 제한적이지만 하나만 열어야 할 작업이 있습니다. 그러나 파일에서 사용되지 않은 공간으로 인해 파일 크기에서 테이블 크기를 계산할 수 없습니다. 테이블의 최대 행 수와 현재 유효한 행 수를 포함하는 헤더에 보관해야합니다. 이를 위해서는 테이블 작성시 옵션 Header = &lt;em&gt;n을&lt;/em&gt; 지정하십시오 . 경우 &lt;code&gt;n=1&lt;/code&gt; 헤더가 있으면, 파일의 시작 부분에 배치 될 &lt;code&gt;n=2&lt;/code&gt; 는 타입 '.blk'와 별개의 파일이 될 것이며, 만약 &lt;code&gt;n=3&lt;/code&gt; 헤더는 파일의 끝에 위치합니다. 이 마지막 값은 헤더가 파일의 시작 부분에있을 때 배치 삽입이 느리기 때문에 제공됩니다. 지정하지 않으면이 테이블 유형에 대해 헤더 옵션의 기본값은 2입니다.</target>
        </trans-unit>
        <trans-unit id="c4dbe455516f629e96125be2d9efd3641555ca1d" translate="yes" xml:space="preserve">
          <source>In the case of an error, you can store the value to which the error argument points (a single-byte variable, not a string string buffer) in the variable.</source>
          <target state="translated">오류의 경우 오류 인수가 가리키는 값 (문자열 문자열 버퍼가 아닌 단일 바이트 변수)을 변수에 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90d2e39a9add7010da8b65e9fc48a714bbf8f7e5" translate="yes" xml:space="preserve">
          <source>In the case of an odd step, the sequence will commence with the &lt;code&gt;FROM&lt;/code&gt;, and end at the final result before &lt;code&gt;TO&lt;/code&gt;.</source>
          <target state="translated">홀수 단계의 경우 시퀀스는 &lt;code&gt;FROM&lt;/code&gt; 으로 시작하여 &lt;code&gt;TO&lt;/code&gt; 이전의 최종 결과에서 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="250a9b98d25ac9a03ad52b0e15080384527e00b0" translate="yes" xml:space="preserve">
          <source>In the case of connecting to Oracle, when using non-ASCI character sets, you need to properly set the NLS_LANG environment variable before starting the MariaDB Server.</source>
          <target state="translated">Oracle에 연결하는 경우 비 ASCI 문자 세트를 사용하는 경우 MariaDB 서버를 시작하기 전에 NLS_LANG 환경 변수를 올바르게 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="c7e6de2c17e38c77fbe615998683963810400f8d" translate="yes" xml:space="preserve">
          <source>In the case of full backups, the files are not point in time consistent, since they were taken at different times. If you try to restore the database without first preparing the data, InnoDB rejects the new data as corrupt. Running Mariabackup with the &lt;code&gt;--prepare&lt;/code&gt; command readies the data so you can restore it to MariaDB Server. When working with incremental backups, you need to use the &lt;code&gt;--prepare&lt;/code&gt; command and the &lt;code&gt;&lt;a href=&quot;#-incremental-dir&quot;&gt;--incremental-dir&lt;/a&gt;&lt;/code&gt; option to update the base backup with the deltas from an incremental backup.</source>
          <target state="translated">전체 백업의 경우 파일은 다른 시간에 수행 되었기 때문에 특정 시점에 일관성이 없습니다. 먼저 데이터를 준비하지 않고 데이터베이스를 복원하려고하면 InnoDB는 새 데이터가 손상된 것으로 거부합니다. --prepare 명령으로 Mariabackup을 실행 하면 데이터를 &lt;code&gt;--prepare&lt;/code&gt; 하여 MariaDB 서버로 복원 할 수 있습니다. 증분 백업 작업을 할 때 사용할 필요가 &lt;code&gt;--prepare&lt;/code&gt; 명령과 &lt;code&gt;&lt;a href=&quot;#-incremental-dir&quot;&gt;--incremental-dir&lt;/a&gt;&lt;/code&gt; 증분 백업에서 델타와 기본 백업을 업데이트하는 옵션을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="2c5a9dcffd3c209e2c3cb2ca566d4c97af5d98b2" translate="yes" xml:space="preserve">
          <source>In the case of manually encrypted InnoDB tablespaces, (that is, those where the &lt;code&gt;&lt;a href=&quot;../create-table/index#encrypted&quot;&gt;ENCRYPTED&lt;/a&gt;&lt;/code&gt; table option is set to &lt;code&gt;YES&lt;/code&gt;), you must issue an &lt;code&gt;&lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt;&lt;/code&gt; statement to decrypt each tablespace before removing the encryption keys. Otherwise, the tablespace remains encrypted and becomes inaccessible without the keys.</source>
          <target state="translated">수동으로 암호화 된 InnoDB 테이블 스페이스 (즉, &lt;code&gt;&lt;a href=&quot;../create-table/index#encrypted&quot;&gt;ENCRYPTED&lt;/a&gt;&lt;/code&gt; 테이블 옵션이 &lt;code&gt;YES&lt;/code&gt; 로 설정된 테이블 스페이스)의 경우 암호화 키를 제거하기 전에 &lt;code&gt;&lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt;&lt;/code&gt; 문을 발행하여 각 테이블 스페이스를 해독 해야 합니다. 그렇지 않으면 테이블 스페이스는 암호화 된 상태로 유지되며 키 없이는 액세스 할 수 없게됩니다.</target>
        </trans-unit>
        <trans-unit id="f781123347afa2381bef4a5387c868f0d8a57641" translate="yes" xml:space="preserve">
          <source>In the case where an entry in the MariaDB ColumnStore's configuration needs to be updated and distributed, this can be done from the command line from Performance Module #1. All changes made to MariaDB ColumnStore's configuration file need to be applied on PM1.</source>
          <target state="translated">MariaDB ColumnStore 구성의 항목을 업데이트하고 배포해야하는 경우 성능 모듈 # 1의 명령 줄에서 수행 할 수 있습니다. MariaDB ColumnStore의 구성 파일에 대한 모든 변경 사항은 PM1에 적용해야합니다.</target>
        </trans-unit>
        <trans-unit id="f2f26a0eee7d37a4b96d61b0550a3cc933bc22bd" translate="yes" xml:space="preserve">
          <source>In the case where an entry in the MariaDB ColumnStore's configuration needs...</source>
          <target state="translated">MariaDB ColumnStore 구성의 항목이 필요한 경우 ...</target>
        </trans-unit>
        <trans-unit id="29b8810fcad8c266231437a429e788672ecddc19" translate="yes" xml:space="preserve">
          <source>In the case where the system fails to startup or the MariaDB ColumnStore server (mysqld) fails to startup and its reporting an replication error on Drop Table or View, this could mean that the Binary Logs on the Module, usually a Slave User Module are out of sync with the Database. An example would be when mysqld startups on User Module #2, a slave module, it will go through the Replication bin-logs and run commands to capture up with the Master DB. If it tried to Drop a Table or View that doesn't exist in the Slave Database, it will reported an error and shutdown. This is an indication that the Replication and maybe the Data itself is out-of-sync between the Master and the slave Modules, usually UM1 and UM2. It resolve the issue to where the UM2 slave mysqld will run, the following procedure needs to be execute to get the UMs back in-sync.</source>
          <target state="translated">시스템이 시작되지 않거나 MariaDB ColumnStore 서버 (mysqld)가 시작되지 않고 Drop Table 또는 View에서 복제 오류를보고하는 경우 이는 일반적으로 슬레이브 사용자 모듈 인 모듈의 이진 로그가 없음을 의미 할 수 있습니다 데이터베이스와 동기화합니다. 예를 들어, 슬레이브 모듈 인 사용자 모듈 # 2에서 mysqld를 시작하면 Replication bin-logs를 통해 명령을 실행하여 Master DB로 캡처합니다. 슬레이브 데이터베이스에 존재하지 않는 테이블 또는 뷰를 삭제하려고하면 오류 및 종료가보고됩니다. 이는 복제 및 데이터 자체가 마스터 모듈과 슬레이브 모듈 (일반적으로 UM1 및 UM2)간에 동기화되지 않았 음을 나타냅니다. UM2 슬레이브 mysqld가 실행되는 문제를 해결하고 UM을 다시 동기화하려면 다음 절차를 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="5b92eab3d3e16c03870a4479f39759b3e3bbe1c5" translate="yes" xml:space="preserve">
          <source>In the cases where the MariaDB ColumnStore's configuration files gets out of sync with the PM1 copy, run the following to get MariaDB ColumnStore's configuration file redistribute to the other nodes.</source>
          <target state="translated">MariaDB ColumnStore의 구성 파일이 PM1 사본과 동기화되지 않은 경우 다음을 실행하여 MariaDB ColumnStore의 구성 파일을 다른 노드에 재분배하십시오.</target>
        </trans-unit>
        <trans-unit id="04ce35d092d56eaa965307b72e499ecf03a29fec" translate="yes" xml:space="preserve">
          <source>In the cases where the file was written using a character-set other than the default, you can specify the character-set to use with the &lt;code&gt;CHARACTER SET&lt;/code&gt; clause in the statement. It ignores character-sets specified by the &lt;code&gt;&lt;a href=&quot;../set-names/index&quot;&gt;SET NAMES&lt;/a&gt;&lt;/code&gt; statement and by the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#character_set_client&quot;&gt;character_set_client&lt;/a&gt;&lt;/code&gt; system variable. Setting the &lt;code&gt;CHARACTER SET&lt;/code&gt; clause to a value of &lt;code&gt;binary&lt;/code&gt; indicates &quot;no conversion.&quot;</source>
          <target state="translated">디폴트가 아닌 문자 세트를 사용하여 파일을 작성한 경우 , 명령문에서 &lt;code&gt;CHARACTER SET&lt;/code&gt; 절 과 함께 사용할 문자 세트를 지정할 수 있습니다 . &lt;code&gt;&lt;a href=&quot;../set-names/index&quot;&gt;SET NAMES&lt;/a&gt;&lt;/code&gt; 문 및 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#character_set_client&quot;&gt;character_set_client&lt;/a&gt;&lt;/code&gt; 시스템 변수로 지정된 문자 세트를 무시 합니다. &lt;code&gt;CHARACTER SET&lt;/code&gt; 절을 &lt;code&gt;binary&lt;/code&gt; 값으로 설정하면 &quot;변환 없음&quot;을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b29a170383ca6763007417d760642e57dff0c861" translate="yes" xml:space="preserve">
          <source>In the context of such statements that occur as part of events executed by the Event Scheduler, diagnostics messages (not only errors, but also warnings) are written to the error log, and, on Windows, to the application event log.</source>
          <target state="translated">이벤트 스케줄러에 의해 실행 된 이벤트의 일부로 발생하는 이러한 명령문의 컨텍스트에서, 진단 메시지 (오류뿐만 아니라 경고도)는 오류 로그 및 Windows의 경우 응용 프로그램 이벤트 로그에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="d87a263e3b4f875618838a393932d6447baf6118" translate="yes" xml:space="preserve">
          <source>In the current development phase Aria tables created with &lt;code&gt;TRANSACTIONAL=1&lt;/code&gt; are crash safe and atomic but not transactional because changes in Aria tables can't be rolled back with the &lt;code&gt;ROLLBACK&lt;/code&gt; command. As we planned to make Aria tables fully transactional, we decided it was better to use the &lt;code&gt;TRANSACTIONAL&lt;/code&gt; keyword from the start so so that applications don't need to be changed later.</source>
          <target state="translated">현재 개발 단계에서 &lt;code&gt;TRANSACTIONAL=1&lt;/code&gt; 로 작성된 Aria 테이블 은 충돌 안전 및 원자 적이지만 &lt;code&gt;ROLLBACK&lt;/code&gt; 명령 으로 Aria 테이블의 변경 사항을 롤백 할 수 없으므로 트랜잭션이 아닙니다 . Aria 테이블을 완전히 트랜잭션 처리 할 계획 이었으므로 애플리케이션을 나중에 변경할 필요가 없도록 처음부터 &lt;code&gt;TRANSACTIONAL&lt;/code&gt; 키워드 를 사용하는 것이 더 낫 습니다.</target>
        </trans-unit>
        <trans-unit id="9823ba7cd1b256485de42b2a083ed8d26f4435e4" translate="yes" xml:space="preserve">
          <source>In the default high availability setup #Spider Nodes# produce SQL errors when a backend server is not responding. Per table monitoring can be setup to enable availability in case of unresponsive backends &lt;code&gt;monotoring_bg_kind=1&lt;/code&gt; or &lt;code&gt;monotoring_bg_kind=2&lt;/code&gt;. The Monitoring Spider Nodes will be inter-connected with usage of the system table &lt;code&gt;mysql.link_mon_servers&lt;/code&gt; to manage network partitioning. Better known as split brain, an even number of &lt;code&gt;Spider Monitor Nodes&lt;/code&gt; should be setup to allow a consensus based on the majority. Rather a single separated shared &lt;code&gt;Monitoring Node&lt;/code&gt; instance or a minimum set of 3 &lt;code&gt;Spider Nodes&lt;/code&gt;. More information can be found &lt;a href=&quot;http://fr.slideshare.net/Kentoku/spider-ha-20100922dtt7&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">기본 고 가용성 설정에서 #Spider Nodes #는 백엔드 서버가 응답하지 않을 때 SQL 오류를 생성합니다. 응답하지 않는 백엔드 &lt;code&gt;monotoring_bg_kind=1&lt;/code&gt; 또는 &lt;code&gt;monotoring_bg_kind=2&lt;/code&gt; 인 경우 가용성을 사용하도록 테이블 당 모니터링을 설정할 수 있습니다 . 모니터링 스파이더 노드는 시스템 테이블 &lt;code&gt;mysql.link_mon_servers&lt;/code&gt; 의 사용과 상호 연결되어 네트워크 파티셔닝을 관리합니다. 스플릿 브레인 (Split Brain)으로 더 잘 알려진 다수의 &lt;code&gt;Spider Monitor Nodes&lt;/code&gt; 를 설정하여 대다수에 기반한 합의를 허용해야합니다. 단일의 분리 된 공유 &lt;code&gt;Monitoring Node&lt;/code&gt; 인스턴스 또는 최소 3 개의 &lt;code&gt;Spider Nodes&lt;/code&gt; 세트 . 자세한 내용은 &lt;a href=&quot;http://fr.slideshare.net/Kentoku/spider-ha-20100922dtt7&quot;&gt;여기를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b49f8be3537d683448ee0dfaacd45eeca470d908" translate="yes" xml:space="preserve">
          <source>In the descriptions below, &lt;code&gt;M&lt;/code&gt; is the declared column length (in characters or in bytes), while &lt;code&gt;len&lt;/code&gt; is the actual length in bytes of the value.</source>
          <target state="translated">아래 설명에서 &lt;code&gt;M&lt;/code&gt; 은 선언 된 열 길이 (문자 또는 바이트)이며 &lt;code&gt;len&lt;/code&gt; 은 값의 실제 길이 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="20b764403b8aad015a3c52cec0c0eb1a681c2d70" translate="yes" xml:space="preserve">
          <source>In the event that there are still build dependencies that are not satisfied, use &lt;code&gt;mk-build-deps&lt;/code&gt; to generate a build dependency &lt;code&gt;deb&lt;/code&gt; to use in installing the remaining packages.</source>
          <target state="translated">여전히 만족스럽지 않은 빌드 종속성이있는 경우 &lt;code&gt;mk-build-deps&lt;/code&gt; 를 사용하여 나머지 패키지 설치에 사용할 빌드 종속성 &lt;code&gt;deb&lt;/code&gt; 를 생성 하십시오.</target>
        </trans-unit>
        <trans-unit id="06df5fbacfd4bdc1c684e852ab7f7d115d14999b" translate="yes" xml:space="preserve">
          <source>In the event that you are using the Linux-based operating system CentOS or any of its derivatives, you can optionally compile MariaDB from source code. This is useful in cases where you want use a more advanced release than the one that's available in the official repositories, or when you want to enable certain feature that are not otherwise accessible.</source>
          <target state="translated">Linux 기반 운영 체제 CentOS 또는 그 파생물을 사용하는 경우 선택적으로 소스 코드에서 MariaDB를 컴파일 할 수 있습니다. 이 기능은 공식 리포지토리에서 제공되는 것보다 고급 릴리스를 사용하려는 경우 또는 액세스 할 수없는 특정 기능을 활성화하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="f5387b4f7088edda6bac20dd40dc61b031a31d1f" translate="yes" xml:space="preserve">
          <source>In the event that you are using the Linux-based operating system Debian or any of its direct derivatives and would like to compile MariaDB from source code, you can do so using the MariaDB source repository for the release that interests you. For Ubuntu and its derivatives, see &lt;a href=&quot;../building-mariadb-on-ubuntu/index&quot;&gt;Building on Ubuntu&lt;/a&gt;.</source>
          <target state="translated">Linux 기반 운영 체제 데비안 또는 해당 파생 제품을 사용 중이고 소스 코드에서 MariaDB를 컴파일하려는 경우 관심있는 릴리스의 MariaDB 소스 저장소를 사용하면됩니다. 우분투 및 그 파생어에 대해서는 &lt;a href=&quot;../building-mariadb-on-ubuntu/index&quot;&gt;우분투 구축을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="10230a836f808c2be96e96bdf9b0bd01b909232b" translate="yes" xml:space="preserve">
          <source>In the event that you are using the Linux-based operating system Fedora or any of its derivatives and would like to compile MariaDB from source code, you can do so using the MariaDB build in the official repositories.</source>
          <target state="translated">Linux 기반 운영 체제 Fedora 또는 그 파생물을 사용하고 소스 코드에서 MariaDB를 컴파일하려는 경우 공식 저장소의 MariaDB 빌드를 사용하면됩니다.</target>
        </trans-unit>
        <trans-unit id="6f9ac30dbaf6e2e687db5686a480ab81ee1c5d1f" translate="yes" xml:space="preserve">
          <source>In the event that you are using the Linux-based operating system Ubuntu or any of its derivatives and would like to compile MariaDB from source code, you can do so using the MariaDB source repository for the release that interests you.</source>
          <target state="translated">Linux 기반 운영 체제 Ubuntu 또는 그 파생 제품을 사용하고 소스 코드에서 MariaDB를 컴파일하려는 경우 관심있는 릴리스의 MariaDB 소스 저장소를 사용하면됩니다.</target>
        </trans-unit>
        <trans-unit id="e45b1a6357d838828c42675cad9ac87e4836b8a0" translate="yes" xml:space="preserve">
          <source>In the event that you don't want to permit this operation (such as for security reasons), you can disable the &lt;code&gt;LOAD DATA LOCAL INFILE&lt;/code&gt; statement on either the server or the client.</source>
          <target state="translated">보안상의 이유로이 작업을 허용하지 않으려 는 경우 서버 또는 클라이언트 에서 &lt;code&gt;LOAD DATA LOCAL INFILE&lt;/code&gt; 문을 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8355bbeef47cb86e090fb54b086331233ea0ead9" translate="yes" xml:space="preserve">
          <source>In the event that you encounter issues with background key encryption, you can disable it by setting the &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encryption_rotate_key_age&quot;&gt;innodb_encryption_rotate_key_age&lt;/a&gt;&lt;/code&gt; system variable to &lt;code&gt;0&lt;/code&gt;. You may find this useful when the constant key version checks lead to excessive CPU usage. It's also useful in cases where your encryption key management plugin does not support key rotation, (such as with the &lt;code&gt;&lt;a href=&quot;../encryption-key-management/index#file-key-management-encryption-plugin&quot;&gt;file_key_management&lt;/a&gt;&lt;/code&gt; plugin). For more information, see &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-14180&quot;&gt;MDEV-14180&lt;/a&gt;.</source>
          <target state="translated">백그라운드 키 암호화에 문제가 발생하면 &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encryption_rotate_key_age&quot;&gt;innodb_encryption_rotate_key_age&lt;/a&gt;&lt;/code&gt; 시스템 변수를 &lt;code&gt;0&lt;/code&gt; 으로 설정하여 비활성화 할 수 있습니다 . 상수 키 버전 확인으로 과도한 CPU 사용량이 발생할 때이 기능이 유용 할 수 있습니다. 암호화 키 관리 플러그인이 키 순환을 지원하지 않는 경우 (예 : &lt;code&gt;&lt;a href=&quot;../encryption-key-management/index#file-key-management-encryption-plugin&quot;&gt;file_key_management&lt;/a&gt;&lt;/code&gt; 플러그인) 에도 유용합니다 . 자세한 내용은 &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-14180&quot;&gt;MDEV-14180을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7202ebd5920a5e7a9a407f9118bd495e112ca09d" translate="yes" xml:space="preserve">
          <source>In the event that you have a specific tablespace that you need stored in a dedicated path, you can set the location using the &lt;code&gt;&lt;a href=&quot;../create-table/index#data-directoryindex-directory&quot;&gt;DATA DIRECTORY&lt;/a&gt;&lt;/code&gt; table option when you create the table.</source>
          <target state="translated">전용 경로에 저장해야하는 특정 테이블 스페이스가있는 경우 테이블을 작성할 때 &lt;code&gt;&lt;a href=&quot;../create-table/index#data-directoryindex-directory&quot;&gt;DATA DIRECTORY&lt;/a&gt;&lt;/code&gt; 테이블 옵션을 사용하여 위치를 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b506d6b2ebd51025701b29cd1e0710de3f3012df" translate="yes" xml:space="preserve">
          <source>In the event that you have an existing table and you want to manually enable encryption for that table, then you can do the same with an &lt;code&gt;&lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt;&lt;/code&gt; statement. For example:</source>
          <target state="translated">기존 테이블이 있고 해당 테이블에 대해 수동으로 암호화를 사용하려는 경우 &lt;code&gt;&lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt;&lt;/code&gt; 문으로 동일한 작업을 수행 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c9cedea4523a27f3c55cdf6c52ce6af3665b6dd7" translate="yes" xml:space="preserve">
          <source>In the event that you have not used Ports before on your system, you need to first fetch and extract the Ports tree. This downloads the Ports tree from FreeBSD and extracts it onto your system, placing the various Makefiles, patches and so on in the &lt;code&gt;/usr/ports/&lt;/code&gt; directory.</source>
          <target state="translated">시스템에서 포트를 사용하지 않은 경우 먼저 포트 트리를 가져와 추출해야합니다. FreeBSD에서 포트 트리를 다운로드하여 시스템에 추출하여 다양한 Makefile, 패치 등을 &lt;code&gt;/usr/ports/&lt;/code&gt; 디렉토리에 배치합니다.</target>
        </trans-unit>
        <trans-unit id="d494929d0ef8c95ce57affc656145d67786bb740" translate="yes" xml:space="preserve">
          <source>In the event that you have several tables and columns using temporal data types that you want to switch over to the new format, make sure the system variable is enabled, then perform a dump and restore using &lt;code&gt;mysqldump&lt;/code&gt;. The columns using relevant temporal data types are restored using the new temporal format.</source>
          <target state="translated">새 형식으로 전환하려는 임시 데이터 유형을 사용하는 여러 테이블 및 열이있는 경우 시스템 변수가 사용 가능한지 확인한 다음 &lt;code&gt;mysqldump&lt;/code&gt; 를 사용하여 덤프 및 복원을 수행하십시오 . 관련 시간 데이터 유형을 사용하는 열은 새로운 시간 형식을 사용하여 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="e505b042414b0694b4921cbaa3ea3e1d797c393a" translate="yes" xml:space="preserve">
          <source>In the event that you have used Ports before on this system, run Portsnap again to download and install any updates to the Ports tree.</source>
          <target state="translated">이 시스템에서 이전에 포트를 사용한 경우 포트 스냅을 다시 실행하여 포트 트리에 대한 업데이트를 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="899dc6b228d3fc8f7ad4bef3de80c23db9d1a1da" translate="yes" xml:space="preserve">
          <source>In the event that you miss a package while installing build dependencies, CMake may continue to fail after you install the necessary packages. If this happens to you, delete the CMake cache then run the above the command again:</source>
          <target state="translated">빌드 종속성을 설치하는 동안 패키지가 누락 된 경우 필요한 패키지를 설치 한 후 CMake가 계속 실패 할 수 있습니다. 이 문제가 발생하면 CMake 캐시를 삭제 한 다음 위 명령을 다시 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="0145e4370be0489d526ea23255833470dc9bac20" translate="yes" xml:space="preserve">
          <source>In the event that you need to modify or replace this server after setting up the Spider table, remember to issue a &lt;code&gt;&lt;a href=&quot;../flush/index&quot;&gt;FLUSH&lt;/a&gt;&lt;/code&gt; statement to update the server definition.</source>
          <target state="translated">Spider 테이블을 설정 한 후이 서버를 수정하거나 교체해야하는 경우 &lt;code&gt;&lt;a href=&quot;../flush/index&quot;&gt;FLUSH&lt;/a&gt;&lt;/code&gt; 문을 발행 하여 서버 정의를 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="94690b4467f9baa2132a6eec89f27f45761d5d68" translate="yes" xml:space="preserve">
          <source>In the example above the presence of &lt;code&gt;&quot;&amp;lt;expr_cache&amp;gt;&amp;lt;`test`.`t1`.`a`&amp;gt;(...)&quot;&lt;/code&gt; is how you know you are using the subquery cache.</source>
          <target state="translated">위의 예에서 &lt;code&gt;&quot;&amp;lt;expr_cache&amp;gt;&amp;lt;`test`.`t1`.`a`&amp;gt;(...)&quot;&lt;/code&gt; 의 존재는 서브 쿼리 캐시를 사용하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="da3429ceebd31aaed63de2b280b575eb987bce9d" translate="yes" xml:space="preserve">
          <source>In the example above, that would be:</source>
          <target state="translated">위의 예에서 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4c03d4227c868f022eaf9e7d9ffcecc95a707a32" translate="yes" xml:space="preserve">
          <source>In the example above, the wait condition is repeated before the sync point. This is done to skip the sync point, if no wait takes place. The sync point is before the loop (not inside the loop) to have it hit once only. It is possible that the condition variable is signaled multiple times without the wait condition to be true.</source>
          <target state="translated">위의 예에서 대기 조건은 동기 점 이전에 반복됩니다. 대기 시간이없는 경우 동기 점을 건너 뛰기 위해 수행됩니다. 동기 점은 루프 앞 (루프 내부가 아님) 앞에있어 한 번만 히트합니다. 대기 조건이 참이 아닌 조건 변수에 여러 번 신호를 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96921d767a2e92b4bbe0ce45530d2ee5d163982a" translate="yes" xml:space="preserve">
          <source>In the example above, there is no problem if the table is initially void, but if it is not, serious problems can be met if the initial distribution does not match the table distribution. Supposing a row in which &amp;ldquo;id&amp;rdquo; as the value 12 was initially contained in the part1.txt file, it will be seen when selecting the whole table but if you ask:</source>
          <target state="translated">위의 예에서, 테이블이 처음에 공백 인 경우에는 문제가 없지만, 그렇지 않은 경우 초기 분포가 테이블 분포와 일치하지 않으면 심각한 문제가 발생할 수 있습니다. 값 12 인 &quot;id&quot;가 part1.txt 파일에 처음 포함 된 행을 가정하면 전체 테이블을 선택할 때 표시되지만 다음과 같은 경우에는</target>
        </trans-unit>
        <trans-unit id="888d6b6b2734219f59dbe466b82a7d09e7d692a5" translate="yes" xml:space="preserve">
          <source>In the example below we install MariaDB in the &lt;code&gt;/usr/local/mysql&lt;/code&gt; directory (this is the default location for MariaDB for many platforms). However any other directory should work too.</source>
          <target state="translated">아래 예에서는 &lt;code&gt;/usr/local/mysql&lt;/code&gt; 디렉토리에 MariaDB를 설치합니다 (여러 플랫폼에서 MariaDB의 기본 위치 임). 그러나 다른 디렉토리도 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="a2cd1355e914b6375da26e747c934f44be5b2f1c" translate="yes" xml:space="preserve">
          <source>In the examples below we will follow the historical convention of renaming the &lt;code&gt;mysql.server&lt;/code&gt; script to '&lt;code&gt;mysql&lt;/code&gt;' when we copy it to &lt;code&gt;/etc/init.d/&lt;/code&gt;.</source>
          <target state="translated">아래 예에서는 &lt;code&gt;/etc/init.d/&lt;/code&gt; 로 복사 할 때 &lt;code&gt;mysql.server&lt;/code&gt; 스크립트 의 이름 을 ' &lt;code&gt;mysql&lt;/code&gt; ' 로 바꾸는 역사적 규칙을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="f7d4ac5343fca7f7dbcaee3833fcf5736b5a5950" translate="yes" xml:space="preserve">
          <source>In the extreme (data/index much larger than buffer_pool), InnoDB must read-modify-write one 16KB disk block for each UUID entry.</source>
          <target state="translated">극단적으로 (buffer_pool보다 훨씬 큰 데이터 / 인덱스) InnoDB는 각 UUID 항목마다 하나의 16KB 디스크 블록을 읽고 수정하고 기록해야합니다.</target>
        </trans-unit>
        <trans-unit id="6405249d3065666ac1f889b517c7c20a85293ff4" translate="yes" xml:space="preserve">
          <source>In the first case, &lt;code&gt;NOT&lt;/code&gt; applies to &lt;code&gt;a&lt;/code&gt;, so if &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;FALSE&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;TRUE&lt;/code&gt;, the expression returns &lt;code&gt;TRUE&lt;/code&gt;. In the second case, &lt;code&gt;NOT&lt;/code&gt; applies to the result of &lt;code&gt;a OR b&lt;/code&gt;, so if at least one of &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; is &lt;code&gt;TRUE&lt;/code&gt;, the expression is &lt;code&gt;TRUE&lt;/code&gt;.</source>
          <target state="translated">첫 번째 경우 &lt;code&gt;NOT&lt;/code&gt; 은 &lt;code&gt;a&lt;/code&gt; 에 적용 되므로 &lt;code&gt;a&lt;/code&gt; 가 &lt;code&gt;FALSE&lt;/code&gt; 이거나 &lt;code&gt;b&lt;/code&gt; 가 &lt;code&gt;TRUE&lt;/code&gt; 이면 표현식은 &lt;code&gt;TRUE&lt;/code&gt; 를 반환 합니다 . 두 번째 경우, &lt;code&gt;NOT&lt;/code&gt; &lt;code&gt;a OR b&lt;/code&gt; 결과에 적용 되므로 &lt;code&gt;a&lt;/code&gt; 또는 &lt;code&gt;b&lt;/code&gt; 중 하나 이상 이 &lt;code&gt;TRUE&lt;/code&gt; 인 경우 표현식은 &lt;code&gt;TRUE&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0b78ebe9daa6a61ba854e42f0fe6d57684252623" translate="yes" xml:space="preserve">
          <source>In the first query &lt;em&gt;Jbin_Object_Add&lt;/em&gt; does not serialize the document (no &amp;ldquo;Jbin&amp;rdquo; functions do) and &lt;em&gt;Json_Object&lt;/em&gt; just returns a serialized modified tree. Consequently, the file bt2.json is not modified. This query is all right to copy a modified version of the json file without modifying it.</source>
          <target state="translated">첫 번째 쿼리에서 &lt;em&gt;Jbin_Object_Add&lt;/em&gt; 는 문서를 직렬화하지 않으며 ( &quot;Jbin&quot;함수는 수행하지 않음) &lt;em&gt;Json_Object&lt;/em&gt; 는 직렬화 된 수정 된 트리 만 반환합니다. 결과적으로 bt2.json 파일은 수정되지 않습니다. 이 쿼리는 수정하지 않은 json 파일의 수정 된 버전을 수정하지 않고 복사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2879fa98bd8c28d4e0f293ea6349a17a9d5ffe08" translate="yes" xml:space="preserve">
          <source>In the first two cases, the specified table must exist at the time the system variable is set and the full-text index created. It must be an InnoDB table with a single column, a &lt;a href=&quot;../varchar/index&quot;&gt;VARCHAR&lt;/a&gt; named VALUE.</source>
          <target state="translated">처음 두 경우에는 시스템 변수가 설정되고 전체 텍스트 색인이 작성 될 때 지정된 테이블이 존재해야합니다. &lt;a href=&quot;../varchar/index&quot;&gt;VARCHAR&lt;/a&gt; VALUE라는 단일 열이있는 InnoDB 테이블이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="17d27be908ec316cbe6249522be5cd4cdb503e9f" translate="yes" xml:space="preserve">
          <source>In the following example, a statement generates two warnings, and GET DIAGNOSTICS is used to get the number of warnings:</source>
          <target state="translated">다음 예에서 명령문은 두 개의 경고를 생성하며 GET DIAGNOSTICS는 경고 수를 얻는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="dfd1dc7d1300ad5d8240fae60650272eb6536fa7" translate="yes" xml:space="preserve">
          <source>In the following example, data is truncated because the results are not specifically cast to a wide enough type:</source>
          <target state="translated">다음 예에서는 결과가 충분히 넓은 유형으로 캐스트되지 않기 때문에 데이터가 잘립니다.</target>
        </trans-unit>
        <trans-unit id="0c037076e3f78e5b8bf6d8f8b5b528a13b4a3493" translate="yes" xml:space="preserve">
          <source>In the following example, each time the genre, the year or the country change, another super-aggregate row is added:</source>
          <target state="translated">다음 예에서는 장르, 연도 또는 국가가 변경 될 때마다 다른 상위 집계 행이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="d4847e1b97218dfe3b66c89ef693c20d68c1e559" translate="yes" xml:space="preserve">
          <source>In the following example, next month a recurring event will be triggered hourly for a week:</source>
          <target state="translated">다음 예에서 다음 달에 반복 이벤트가 일주일 동안 매시간 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="1ac20d49006236d2490e992ee9913bbe959b35de" translate="yes" xml:space="preserve">
          <source>In the following example, no column-level privilege has been explicitly assigned:</source>
          <target state="translated">다음 예에서는 열 수준 권한이 명시 적으로 할당되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="5e469fd6ef2e9aa08f850c9fd36d60b27841c2ec" translate="yes" xml:space="preserve">
          <source>In the following example, the right &lt;code&gt;1 XOR 1&lt;/code&gt; is evaluated first, and returns &lt;code&gt;0&lt;/code&gt;. Then, &lt;code&gt;1 XOR 0&lt;/code&gt; is evaluated, and &lt;code&gt;1&lt;/code&gt; is returned.</source>
          <target state="translated">다음 예제에서 오른쪽 &lt;code&gt;1 XOR 1&lt;/code&gt; 이 먼저 평가되고 &lt;code&gt;0&lt;/code&gt; 을 리턴합니다 . 그런 다음 &lt;code&gt;1 XOR 0&lt;/code&gt; 이 평가되고 &lt;code&gt;1&lt;/code&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="4a51f265d0757c499ba19daf2c315682f6f08582" translate="yes" xml:space="preserve">
          <source>In the following example, we will filter out all of the times which Helmholtz clocked in that were before 7:01:00 and during the work week that lasted from the 8th to the 12th of August:</source>
          <target state="translated">다음 예에서, 우리는 Helmholtz가 7시 0 분 이전의 시간과 8 월 8 일에서 12 일까지 지속 된 주중 시간을 모두 걸러냅니다.</target>
        </trans-unit>
        <trans-unit id="3c726f46d38ee4f56dbfafb7a98c4e580ed65f87" translate="yes" xml:space="preserve">
          <source>In the following example, we will partition a log table by year.</source>
          <target state="translated">다음 예에서는 연도별로 로그 테이블을 분할합니다.</target>
        </trans-unit>
        <trans-unit id="cb0a54ad8186fc1528b0383cd82b9aa2eebb5916" translate="yes" xml:space="preserve">
          <source>In the following example, we'll create three MyISAM tables, and then a MERGE table on them. However, one of them uses a different data type for the column b, so a SELECT will produce an error:</source>
          <target state="translated">다음 예에서는 3 개의 MyISAM 테이블을 만든 다음 테이블에 MERGE 테이블을 만듭니다. 그러나 그들 중 하나는 열 b에 대해 다른 데이터 유형을 사용하므로 SELECT는 오류를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="dd3e53bdbb88831edcc1d1652ae780d5f39a200c" translate="yes" xml:space="preserve">
          <source>In the following steps, be sure to replace &lt;code&gt;${HOST}&lt;/code&gt; with the fully qualified DNS name for the MariaDB server host.</source>
          <target state="translated">다음 단계에서 &lt;code&gt;${HOST}&lt;/code&gt; 를 MariaDB 서버 호스트의 완전한 DNS 이름 으로 바꾸십시오 .</target>
        </trans-unit>
        <trans-unit id="7a5323960d7f7f8cfee7ce9cb55176adb7d97ad9" translate="yes" xml:space="preserve">
          <source>In the following text, a transactional table means InnoDB or &quot;InnoDB-like engine with redo log that can lock redo purges and can be copied without locks by an outside process&quot;.</source>
          <target state="translated">다음 텍스트에서 트랜잭션 테이블은 InnoDB 또는 &quot;다시 실행 제거를 잠글 수 있고 외부 프로세스에서 잠금없이 복사 할 수있는 다시 실행 로그가있는 InnoDB와 유사한 엔진&quot;을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="e530d96f312dce723f8518d5f5c04fe8c7df23e1" translate="yes" xml:space="preserve">
          <source>In the format &lt;code&gt;user_name@host_name&lt;/code&gt;.</source>
          <target state="translated">형식에서 &lt;code&gt;user_name@host_name&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="adc1342d1f0e796219a5c280891c4e4f04246134" translate="yes" xml:space="preserve">
          <source>In the former example, &lt;code&gt;DISTINCT&lt;/code&gt; is used because the same user may occur more than once. The new line (&lt;code&gt;\n&lt;/code&gt;) used as a &lt;code&gt;SEPARATOR&lt;/code&gt; makes the results easier to read.</source>
          <target state="translated">&lt;code&gt;DISTINCT&lt;/code&gt; 예에서는 동일한 사용자가 두 번 이상 발생할 수 있으므로 DISTINCT 가 사용됩니다. &lt;code&gt;SEPARATOR&lt;/code&gt; 로 사용 된 줄 바꾸기 ( &lt;code&gt;\n&lt;/code&gt; ) 는 결과를보다 쉽게 ​​읽을 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="5eea0690db6c3311d8396fc791c72656c8826a0e" translate="yes" xml:space="preserve">
          <source>In the latter case no extra columns will be created and they won't clutter the output of, say, &lt;code&gt;SELECT * FROM t&lt;/code&gt;. The versioning information will still be stored, and it can be accessed via the pseudo-columns &lt;code&gt;ROW_START&lt;/code&gt; and &lt;code&gt;ROW_END&lt;/code&gt;:</source>
          <target state="translated">후자의 경우 추가 열이 생성되지 않으며 &lt;code&gt;SELECT * FROM t&lt;/code&gt; 의 출력을 어지럽히 지 않습니다 . 버전 정보는 여전히 저장되며 의사 열 &lt;code&gt;ROW_START&lt;/code&gt; 및 &lt;code&gt;ROW_END&lt;/code&gt; 를 통해 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c1daca979164afda0faa605f94601ed1bfa485b4" translate="yes" xml:space="preserve">
          <source>In the latter, user-assisted, discovery the engine does not have enough information to discover the table all on its own. But it can discover the table structure if the user provides certain additional information. In this case, an explicit &lt;code&gt;CREATE TABLE&lt;/code&gt; statement is still necessary, but it should contain no table structure &amp;mdash; only the table name and the table attributes. In MariaDB, the &lt;a href=&quot;../federatedx-storage-engine/index&quot;&gt;FederatedX&lt;/a&gt; storage engine supports this. When creating a table, one only needs to specify the &lt;code&gt;CONNECTION&lt;/code&gt; attribute and the table structure &amp;mdash; fields and indexes &amp;mdash; will be provided automatically by the engine.</source>
          <target state="translated">후자의 사용자 지원 검색 엔진은 테이블 자체를 모두 검색하기에 충분한 정보가 없습니다. 그러나 사용자가 특정 추가 정보를 제공하면 테이블 구조를 발견 할 수 있습니다. 이 경우 명시 적 &lt;code&gt;CREATE TABLE&lt;/code&gt; 문이 여전히 필요하지만 테이블 구조와 테이블 이름 및 테이블 속성 만 포함해야합니다. MariaDB에서는 &lt;a href=&quot;../federatedx-storage-engine/index&quot;&gt;FederatedX&lt;/a&gt; 스토리지 엔진이이를 지원합니다. 테이블을 생성 할 때 &lt;code&gt;CONNECTION&lt;/code&gt; 속성 만 지정 하면 테이블 구조 (필드 및 인덱스)가 엔진에 의해 자동으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="46c374be751d5518eb6e5d54e249a601db25679a" translate="yes" xml:space="preserve">
          <source>In the log directory, there will be the following 2 files. So all the STDOUT/STDERR from the process will be logged here</source>
          <target state="translated">로그 디렉토리에는 다음 2 개의 파일이 있습니다. 프로세스의 모든 STDOUT / STDERR이 여기에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="31745928b4362e7856a0118aaeaf42886707400c" translate="yes" xml:space="preserve">
          <source>In the mysql client, run &lt;code&gt;EXPLAIN&lt;/code&gt; on a query and copy the output. For example:</source>
          <target state="translated">mysql 클라이언트 의 쿼리 에서 &lt;code&gt;EXPLAIN&lt;/code&gt; 을 실행 하고 출력을 복사하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f0db5b20392274db2146c92453533d2334729c51" translate="yes" xml:space="preserve">
          <source>In the non-prepared backup, &lt;code&gt;ib_logfile0&lt;/code&gt; contains all of the &lt;a href=&quot;../xtradbinnodb-redo-log/index&quot;&gt;InnoDB redo log&lt;/a&gt; copied during the backup. Previous versions of Mariabackup would use a file called &lt;code&gt;&lt;a href=&quot;#xtrabackup_logfile&quot;&gt;xtrabackup_logfile&lt;/a&gt;&lt;/code&gt; for this.</source>
          <target state="translated">준비되지 않은 백업에서 &lt;code&gt;ib_logfile0&lt;/code&gt; 에는 백업 중에 복사 된 모든 &lt;a href=&quot;../xtradbinnodb-redo-log/index&quot;&gt;InnoDB 리두 로그&lt;/a&gt; 가 포함됩니다 . 이전 버전의 Mariabackup &lt;code&gt;&lt;a href=&quot;#xtrabackup_logfile&quot;&gt;xtrabackup_logfile&lt;/a&gt;&lt;/code&gt; 위해 xtrabackup_logfile 이라는 파일을 사용했습니다 .</target>
        </trans-unit>
        <trans-unit id="05094619d045884af4d4220f1c00d8d9f208db0a" translate="yes" xml:space="preserve">
          <source>In the output you will see the available versions.</source>
          <target state="translated">출력에 사용 가능한 버전이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="26593d52d79d5ad80de6d062b36124b7a96f2df7" translate="yes" xml:space="preserve">
          <source>In the output you will see the available versions. For example:</source>
          <target state="translated">출력에 사용 가능한 버전이 표시됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9d708a2ee5b6ce48a6b74c860a41950cb45e784f" translate="yes" xml:space="preserve">
          <source>In the past, some developers may have implemented a kind of &quot;instant add column&quot; in the application by encoding multiple columns in a single &lt;code&gt;&lt;a href=&quot;../text/index&quot;&gt;TEXT&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../blob/index&quot;&gt;BLOB&lt;/a&gt;&lt;/code&gt; column. MariaDB &lt;a href=&quot;../dynamic-columns/index&quot;&gt;Dynamic Columns&lt;/a&gt; was an early example of that. A more recent example is &lt;code&gt;&lt;a href=&quot;../json-functions/index&quot;&gt;JSON&lt;/a&gt;&lt;/code&gt; and related string manipulation functions.</source>
          <target state="translated">과거에는 일부 개발자가 단일 &lt;code&gt;&lt;a href=&quot;../text/index&quot;&gt;TEXT&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../blob/index&quot;&gt;BLOB&lt;/a&gt;&lt;/code&gt; 열에 여러 열을 인코딩하여 응용 프로그램에서 일종의 &quot;인스턴트 추가 열&quot;을 구현했을 수 있습니다 . MariaDB &lt;a href=&quot;../dynamic-columns/index&quot;&gt;동적 열&lt;/a&gt; 는 그 초기 사례입니다. 보다 최근의 예는 &lt;code&gt;&lt;a href=&quot;../json-functions/index&quot;&gt;JSON&lt;/a&gt;&lt;/code&gt; 및 관련 문자열 조작 함수입니다.</target>
        </trans-unit>
        <trans-unit id="e41d6196a7b29bfb23884097482169941c8ebc92" translate="yes" xml:space="preserve">
          <source>In the process of terminating the thread.</source>
          <target state="translated">스레드를 종료하는 과정에서.</target>
        </trans-unit>
        <trans-unit id="a29c1caf36d3d7d0f6a5bfa122e3c59c1466652f" translate="yes" xml:space="preserve">
          <source>In the results above, the two single quotes in &lt;code&gt;concat(''A'',''B'')&lt;/code&gt; indicate an escaped single quote - see &lt;a href=&quot;../string-literals/index&quot;&gt;string-literals&lt;/a&gt;. Note that while &lt;a href=&quot;../mysql-command-line-client/index&quot;&gt;mysql-command-line-client&lt;/a&gt; appears to show the same default value for columns &lt;code&gt;s5&lt;/code&gt; and &lt;code&gt;s6&lt;/code&gt;, the first is a 4-character string &quot;NULL&quot;, while the second is the SQL NULL value.</source>
          <target state="translated">위의 결과에서 &lt;code&gt;concat(''A'',''B'')&lt;/code&gt; 의 두 개의 작은 따옴표 는 이스케이프 된 작은 따옴표를 나타냅니다 ( &lt;a href=&quot;../string-literals/index&quot;&gt;string-literals&lt;/a&gt; 참조) . 주 동안 그 &lt;a href=&quot;../mysql-command-line-client/index&quot;&gt;MySQL을 명령 줄 클라이언트&lt;/a&gt; 가 나타납니다 컬럼에 대해 동일한 기본값 쇼에 &lt;code&gt;s5&lt;/code&gt; 하고 &lt;code&gt;s6&lt;/code&gt; 번째는 SQL의 NULL 값이있는 동안, 첫 번째 4 문자열 &quot;NULL&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="276a3161884d63f66a566546b7ebd68926f92df8" translate="yes" xml:space="preserve">
          <source>In the second window (the one that's on terrier, but not in VM), run:</source>
          <target state="translated">두 번째 창 (테리어에는 있지만 VM에는없는 창)에서 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="de1b973a8f13a32b1aa5e9f0373008ce075d53a4" translate="yes" xml:space="preserve">
          <source>In the secondary index, saying justINDEX(y_id) would work because it would implicit include x_id. But I would rather make it more obvious that I am hoping for a 'covering' index.</source>
          <target state="translated">보조 인덱스에서 justINDEX (y_id)는 x_id를 암시 적으로 포함하기 때문에 작동합니다. 그러나 나는 '커버링'지수를 기대하고 있음을 더 분명히하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="54ff5f79d37ea20bbd6beb948ad178607a8eff6c" translate="yes" xml:space="preserve">
          <source>In the source server, &lt;code&gt;ib_logfile0&lt;/code&gt; is the first (and possibly the only) &lt;a href=&quot;../xtradbinnodb-redo-log/index&quot;&gt;InnoDB redo log&lt;/a&gt; file.</source>
          <target state="translated">소스 서버에서 &lt;code&gt;ib_logfile0&lt;/code&gt; 은 첫 번째 (그리고 아마도 유일한) &lt;a href=&quot;../xtradbinnodb-redo-log/index&quot;&gt;InnoDB 리두 로그&lt;/a&gt; 파일입니다.</target>
        </trans-unit>
        <trans-unit id="c0568cb4fcf1e1538251c231ea6c1ab0cedf8deb" translate="yes" xml:space="preserve">
          <source>In the standard 'MySQL' mode it is possible that an auto-increment value is re-issued. This occurs when the maximum auto-increment value is deleted, and then MariaDB is restarted. This occurs because the next auto-increment value to be issued is determined at startup by retrieving the current maximum auto-increment value from the table.</source>
          <target state="translated">표준 'MySQL'모드에서는 자동 증분 값이 다시 발행 될 수 있습니다. 최대 자동 증분 값이 삭제 된 다음 MariaDB가 다시 시작될 때 발생합니다. 테이블에서 현재 최대 자동 증분 값을 검색하여 시작시 다음 자동 증분 값이 결정되기 때문에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ec787dc9f45cd5258530d1c2324289f5e8e37ed7" translate="yes" xml:space="preserve">
          <source>In the text file my.cnf (my.ini on Windows), add or modify a line to say something like</source>
          <target state="translated">텍스트 파일 my.cnf (Windows의 경우 my.ini)에서 다음과 같이 말할 줄을 추가하거나 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="e55eefe99291f07416a9deca755fec63a9c70379" translate="yes" xml:space="preserve">
          <source>In the versions of MariaDB/MySQL before 5.3 only one block-based join algorithm was implemented : the Block Nested Loops (BNL) join algorithm which could only be used for inner joins.</source>
          <target state="translated">5.3 이전의 MariaDB / MySQL 버전에서는 내부 결합에만 사용할 수있는 블록 중첩 루프 (BNL) 결합 알고리즘이 하나의 블록 기반 결합 알고리즘 만 구현되었습니다.</target>
        </trans-unit>
        <trans-unit id="225c4cb906cc8804a420ee00a1ad1e045e921728" translate="yes" xml:space="preserve">
          <source>In the worst case, with no strings being space-compressed, the total index storage space will be (index_length+4)/0.67 per index.</source>
          <target state="translated">최악의 경우 공간 압축 된 문자열이 없으면 총 인덱스 스토리지 공간은 인덱스 당 (index_length + 4) /0.67이됩니다.</target>
        </trans-unit>
        <trans-unit id="5d31a34b8dba033bf76bd006309f61f3fd5975d6" translate="yes" xml:space="preserve">
          <source>In theory, it makes sense to convert all kinds of EXISTS subqueries: convert both correlated and uncorrelated ones, convert irrespectively of whether the subquery has inner=outer equality.</source>
          <target state="translated">이론적으로 모든 종류의 EXISTS 하위 쿼리를 변환하는 것이 좋습니다. 상관 된 쿼리와 상관되지 않은 쿼리를 모두 변환하고 하위 쿼리에 inner = outer equality가 있는지 여부에 관계없이 변환합니다.</target>
        </trans-unit>
        <trans-unit id="f310f8d506d5bb71e3c50ba9990d9d2fff9ece87" translate="yes" xml:space="preserve">
          <source>In these MariaDB versions, this problem could be avoided by not restoring the backup by manually copying the files and instead restoring the backup by using Mariabackup and providing the &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-copy-back&quot;&gt;--copy-back&lt;/a&gt;&lt;/code&gt; option, since Mariabackup deletes pre-existing &lt;a href=&quot;../xtradbinnodb-redo-log/index&quot;&gt;InnoDB redo log&lt;/a&gt; files from the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#datadir&quot;&gt;datadir&lt;/a&gt;&lt;/code&gt; during the restore process.</source>
          <target state="translated">이 MariaDB 버전에서이 문제를 수동으로 파일을 복사하는 대신 Mariabackup를 사용하여 백업을 복원하고 제공하여 백업을 복원하지 않음으로써 피할 수 &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-copy-back&quot;&gt;--copy-back&lt;/a&gt;&lt;/code&gt; Mariabackup는 기존에 삭제하기 때문에, 옵션을 &lt;a href=&quot;../xtradbinnodb-redo-log/index&quot;&gt;InnoDB의 리두 로그&lt;/a&gt; 로부터 파일을 복원 프로세스 중 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#datadir&quot;&gt;datadir&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="90db278c8675ea2d5ea391628848718c163cedb2" translate="yes" xml:space="preserve">
          <source>In these cases you have the option to either tell the optimizer to only use a limited set of indexes, ignore one or more indexes, or force the usage of some particular index.</source>
          <target state="translated">이 경우 옵티 마이저에게 제한된 인덱스 세트 만 사용하거나 하나 이상의 인덱스를 무시하거나 특정 인덱스를 강제로 사용하도록 지시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae3e40af0538d7afcf229d960ac672422bdd34da" translate="yes" xml:space="preserve">
          <source>In these cases, InnoDB performs the encryption or decryption operation using the server thread for the client connection that executes the statement. This means that you can update encryption on &lt;a href=&quot;../innodb-file-per-table-tablespaces/index&quot;&gt;file-per-table&lt;/a&gt; tablespaces with an &lt;code&gt;&lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt;&lt;/code&gt; statement, even when the &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encryption_threads&quot;&gt;innodb_encryption_threads&lt;/a&gt;&lt;/code&gt; and/or the &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encryption_rotate_key_age&quot;&gt;innodb_rotate_key_age&lt;/a&gt;&lt;/code&gt; system variables are set to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">이 경우 InnoDB는 명령문을 실행하는 클라이언트 연결에 서버 스레드를 사용하여 암호화 또는 암호 해독 작업을 수행합니다. 이는 &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encryption_threads&quot;&gt;innodb_encryption_threads&lt;/a&gt;&lt;/code&gt; 및 / 또는 &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encryption_rotate_key_age&quot;&gt;innodb_rotate_key_age&lt;/a&gt;&lt;/code&gt; 시스템 변수가 &lt;code&gt;0&lt;/code&gt; 으로 설정되어 있어도 &lt;code&gt;&lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt;&lt;/code&gt; 문 &lt;a href=&quot;../innodb-file-per-table-tablespaces/index&quot;&gt;으로 테이블 당 파일&lt;/a&gt; 공간의 암호화를 업데이트 할 수 있음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="53ea2c859b4930c7a5976a2e2b167fc6124eefa7" translate="yes" xml:space="preserve">
          <source>In these true vertical formats, the VEC files are made of all the data of the first column, followed by all the data of the second column etc. All this can be in one physical file or each column data can be in a separate file. In the first case, the option max_rows=m, where m is the estimate of the maximum size (number of rows) of the table, must be specified to be able to insert some new records. This leaves an empty space after each column area in which new data can be inserted. In the second case, the &amp;ldquo;Split&amp;rdquo; option can be specified&lt;sup id=&quot;_ref-1&quot;&gt;[&lt;a href=&quot;#_note-1&quot;&gt;2&lt;/a&gt;]&lt;/sup&gt; at table creation and each column will be stored in a file named sequentially from the table file name followed by the rank of the column. Inserting new lines can freely augment such a table.</source>
          <target state="translated">이러한 실제 세로 형식에서 VEC 파일은 첫 번째 열의 모든 데이터와 두 번째 열의 모든 데이터 등으로 구성됩니다.이 파일은 모두 하나의 실제 파일에 있거나 각 열 데이터는 별도의 파일에있을 수 있습니다. 첫 번째 경우, max_rows = m 옵션 (여기서 m은 테이블의 최대 크기 (행 수)의 추정치 임)은 일부 새 레코드를 삽입 할 수 있도록 지정해야합니다. 새 데이터를 삽입 할 수있는 각 열 영역 뒤에 빈 공간이 남습니다. 두 번째 경우에는 &quot;분할&quot;옵션을 지정할 수 있습니다. &lt;sup id=&quot;_ref-1&quot;&gt;[ &lt;a href=&quot;#_note-1&quot;&gt;2&lt;/a&gt; ]&lt;/sup&gt; 테이블을 생성하고 각 열은 열 랭크 다음 표 파일명으로부터 순차적라는 파일에 저장된다. 줄 바꿈을 삽입하면 이러한 테이블을 자유롭게 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="227bc4850c1f015335ce44ec3f1b3ad865fee3e6" translate="yes" xml:space="preserve">
          <source>In these versions, InnoDB also supports changing a table's &lt;code&gt;&lt;a href=&quot;../create-table/index#page_compression_level&quot;&gt;PAGE_COMPRESSION_LEVEL&lt;/a&gt;&lt;/code&gt; value with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INPLACE&lt;/code&gt;.</source>
          <target state="translated">이 버전에서 InnoDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;INPLACE&lt;/code&gt; 로 설정된 테이블의 &lt;code&gt;&lt;a href=&quot;../create-table/index#page_compression_level&quot;&gt;PAGE_COMPRESSION_LEVEL&lt;/a&gt;&lt;/code&gt; 값 변경을 지원합니다. .</target>
        </trans-unit>
        <trans-unit id="c50a591f1dc5b7753bc174fbeb17c00e60af36e3" translate="yes" xml:space="preserve">
          <source>In these versions, InnoDB also supports changing a table's &lt;code&gt;&lt;a href=&quot;../create-table/index#page_compression_level&quot;&gt;PAGE_COMPRESSION_LEVEL&lt;/a&gt;&lt;/code&gt; value with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INSTANT&lt;/code&gt;.</source>
          <target state="translated">이 버전에서 InnoDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;INSTANT&lt;/code&gt; 로 설정된 테이블의 &lt;code&gt;&lt;a href=&quot;../create-table/index#page_compression_level&quot;&gt;PAGE_COMPRESSION_LEVEL&lt;/a&gt;&lt;/code&gt; 값 변경도 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="d416556a77c7867b23ee0ea0eae0c63ea51a7c63" translate="yes" xml:space="preserve">
          <source>In these versions, InnoDB also supports changing a table's &lt;code&gt;&lt;a href=&quot;../create-table/index#page_compression_level&quot;&gt;PAGE_COMPRESSION_LEVEL&lt;/a&gt;&lt;/code&gt; value with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;NOCOPY&lt;/code&gt; in the cases where the operation supports having the &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; clause is set to &lt;code&gt;INSTANT&lt;/code&gt;.</source>
          <target state="translated">이 버전에서 InnoDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 절이 &lt;code&gt;INSTANT&lt;/code&gt; 로 설정된 조작이 지원되는 경우 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;NOCOPY&lt;/code&gt; 로 설정된 테이블의 &lt;code&gt;&lt;a href=&quot;../create-table/index#page_compression_level&quot;&gt;PAGE_COMPRESSION_LEVEL&lt;/a&gt;&lt;/code&gt; 값 변경을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="5cce163457a9976ba6825bf3e3d86e563c43d90f" translate="yes" xml:space="preserve">
          <source>In this article, we will walk through the configuration of PAM authentication using the &lt;code&gt;&lt;a href=&quot;../authentication-plugin-pam/index&quot;&gt;pam&lt;/a&gt;&lt;/code&gt; authentication plugin and user and group mapping with the &lt;code&gt;&lt;a href=&quot;../user-and-group-mapping-with-pam/index&quot;&gt;pam_user_map&lt;/a&gt;&lt;/code&gt; PAM module. The primary authentication will be handled by the &lt;code&gt;&lt;a href=&quot;https://linux.die.net/man/5/pam_ldap&quot;&gt;pam_ldap&lt;/a&gt;&lt;/code&gt; PAM module, which performs LDAP authentication. We will also set up an OpenLDAP server.</source>
          <target state="translated">이 기사에서는 &lt;code&gt;&lt;a href=&quot;../authentication-plugin-pam/index&quot;&gt;pam&lt;/a&gt;&lt;/code&gt; 인증 플러그인을 사용한 PAM 인증 구성 과 &lt;code&gt;&lt;a href=&quot;../user-and-group-mapping-with-pam/index&quot;&gt;pam_user_map&lt;/a&gt;&lt;/code&gt; PAM 모듈을 사용한 사용자 및 그룹 매핑에 대해 설명 합니다. 기본 인증은 &lt;code&gt;&lt;a href=&quot;https://linux.die.net/man/5/pam_ldap&quot;&gt;pam_ldap&lt;/a&gt;&lt;/code&gt; 에 의해 처리됩니다. LDAP 인증을 수행 PAM 모듈에 . OpenLDAP 서버도 설정합니다.</target>
        </trans-unit>
        <trans-unit id="5df4fb48f9b4fbb65a3f8c25f863eb24e8f6a9e6" translate="yes" xml:space="preserve">
          <source>In this article, we will walk through the configuration of PAM authentication using the &lt;code&gt;&lt;a href=&quot;../authentication-plugin-pam/index&quot;&gt;pam&lt;/a&gt;&lt;/code&gt; authentication plugin and user and group mapping with the &lt;code&gt;&lt;a href=&quot;../user-and-group-mapping-with-pam/index&quot;&gt;pam_user_map&lt;/a&gt;&lt;/code&gt; PAM module. The primary authentication will be handled by the &lt;code&gt;&lt;a href=&quot;https://linux.die.net/man/8/pam_unix&quot;&gt;pam_unix&lt;/a&gt;&lt;/code&gt; PAM module, which performs standard Unix password authentication.</source>
          <target state="translated">이 기사에서는 &lt;code&gt;&lt;a href=&quot;../authentication-plugin-pam/index&quot;&gt;pam&lt;/a&gt;&lt;/code&gt; 인증 플러그인을 사용한 PAM 인증 구성 과 &lt;code&gt;&lt;a href=&quot;../user-and-group-mapping-with-pam/index&quot;&gt;pam_user_map&lt;/a&gt;&lt;/code&gt; PAM 모듈을 사용한 사용자 및 그룹 매핑에 대해 설명 합니다. 기본 인증은 표준 Unix 비밀번호 인증을 수행 하는 &lt;code&gt;&lt;a href=&quot;https://linux.die.net/man/8/pam_unix&quot;&gt;pam_unix&lt;/a&gt;&lt;/code&gt; PAM 모듈에 의해 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="24fae0bfa40ad7acaf967960ad5c45f88a40e8a4" translate="yes" xml:space="preserve">
          <source>In this case a spider table is created to distribute data across backend1 and backend2 based on specific values in the owner field. Bill, Bob, and Chris will be stored in backend1 and Maria and Olivier stored in backend2. Note that the owner column must be added to the primary key which is a requirement of MariaDB partitioning:</source>
          <target state="translated">이 경우 소유자 필드의 특정 값을 기반으로 백엔드 1과 백엔드 2에 데이터를 분산시키기 위해 스파이더 테이블이 생성됩니다. Bill, Bob 및 Chris는 백엔드 1에 저장되고 Maria 및 Olivier는 백엔드 2에 저장됩니다. 소유자 열은 MariaDB 분할의 요구 사항 인 기본 키에 추가되어야합니다.</target>
        </trans-unit>
        <trans-unit id="619f1828f8309290a67ea3bdeaabcd04c7611409" translate="yes" xml:space="preserve">
          <source>In this case a spider table is created to distribute data across backend1 and backend2 based on the first letter of the accountName field. All accountNames that start with the letter L and prior will be stored in backend1 and all other values stored in backend2. Note that the accountName column must be added to the primary key which is a requirement of MariaDB partitioning:</source>
          <target state="translated">이 경우 accountName 필드의 첫 글자를 기준으로 백엔드 1과 백엔드 2에 데이터를 분산시키기 위해 스파이더 테이블이 생성됩니다. 문자 L로 시작하는 이전의 모든 계정 이름은 backend1에 저장되고 다른 모든 값은 backend2에 저장됩니다. accountName 열은 MariaDB 분할의 요구 사항 인 기본 키에 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="683924b51be347fc8cd91bd41c9d79011ef80604" translate="yes" xml:space="preserve">
          <source>In this case a spider table is created to distribute data across backend1 and backend2 by hashing the id column. Since the id column is an incrementing numeric value the hashing will ensure even distribution across the 2 nodes.</source>
          <target state="translated">이 경우 id 열을 해싱하여 backend1 및 backend2에 데이터를 분산시키기 위해 스파이더 테이블이 생성됩니다. id 열은 증가하는 숫자 값이므로 해싱은 두 노드에 고른 분포를 보장합니다.</target>
        </trans-unit>
        <trans-unit id="901f018196cb25cf0aec14d278234f8b9e1bb93b" translate="yes" xml:space="preserve">
          <source>In this case it will eliminate both the &lt;code&gt;ac_dob&lt;/code&gt; and &lt;code&gt;ac_rating&lt;/code&gt; tables.</source>
          <target state="translated">이 경우 &lt;code&gt;ac_dob&lt;/code&gt; 및 &lt;code&gt;ac_rating&lt;/code&gt; 테이블이 모두 제거됩니다 .</target>
        </trans-unit>
        <trans-unit id="82d7aee55994331c1c32f0bf97c60c7a17bca871" translate="yes" xml:space="preserve">
          <source>In this case run the colxml utility (the -t argument can be useful for producing a job file for one table if preferred) to produce the job xml file and then use this a template for editing and then subsequently use that job file for running cpimport.</source>
          <target state="translated">이 경우 colxml 유틸리티 (-t 인수는 원하는 경우 하나의 테이블에 대한 작업 파일을 생성하는 데 유용 할 수 있음)를 실행하여 작업 xml 파일을 생성 한 후이 템플리트를 사용하여 편집 한 다음 해당 작업 파일을 사용하여 cpimport를 실행하십시오. .</target>
        </trans-unit>
        <trans-unit id="4f60af5493d6fd6ca892405d37f7198b58d293c2" translate="yes" xml:space="preserve">
          <source>In this case the command:</source>
          <target state="translated">이 경우 명령은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b2d040ddb90deb652adfc1e10676bf0550d8e700" translate="yes" xml:space="preserve">
          <source>In this case the table structure must match exactly the table on the foreign server.</source>
          <target state="translated">이 경우 테이블 구조는 외부 서버의 테이블과 정확히 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="97eeb17b0955b33afbd53b7ec7306a96aed37d0e" translate="yes" xml:space="preserve">
          <source>In this case you are probably best off creating a specific section for MariaDB in your &lt;code&gt;~/.my.cnf&lt;/code&gt; file.</source>
          <target state="translated">이 경우 &lt;code&gt;~/.my.cnf&lt;/code&gt; 파일 에서 MariaDB에 대한 특정 섹션을 만드는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="b5efb7bb381bddd7a2721ad4f4834aa0b51ec9c3" translate="yes" xml:space="preserve">
          <source>In this case, a spider table is created to allow remote access to the opportunities table hosted on backend1. This then allows for queries and remote dml into the backend1 server from the spider server:</source>
          <target state="translated">이 경우 backend1에서 호스팅되는 기회 테이블에 원격으로 액세스 할 수 있도록 스파이더 테이블이 생성됩니다. 그러면 스파이더 서버에서 백엔드 1 서버로 쿼리 및 원격 dml이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="bc6d1f947e089d1454d345edb7336b5bbfb96745" translate="yes" xml:space="preserve">
          <source>In this case, it is advantageous to:</source>
          <target state="translated">이 경우 다음과 같은 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9130de3f44592afb711c4cb5cb187773f72b1d8" translate="yes" xml:space="preserve">
          <source>In this case, raising an error is preferable, if the alternative is for the operation to make a copy of the table, and perform unexpectedly slowly.</source>
          <target state="translated">이 경우, 조작이 테이블의 사본을 작성하고 예기치 않게 느리게 수행하는 경우 오류를 발생시키는 것이 바람직합니다.</target>
        </trans-unit>
        <trans-unit id="7f944d3411719e07d33c5134e5738cc81dc090af" translate="yes" xml:space="preserve">
          <source>In this case, raising an error is preferable, if the alternative is for the operation to modify data files, and perform unexpectedly slowly.</source>
          <target state="translated">이 경우 대체 작업이 데이터 파일을 수정하고 예기치 않게 느리게 수행하는 경우 오류를 발생시키는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="53d4c9fca10723fc2ffd9bb1d3d4743c2579bc17" translate="yes" xml:space="preserve">
          <source>In this case, raising an error is preferable, if the alternative is for the operation to rebuild the clustered index, and perform unexpectedly slowly.</source>
          <target state="translated">이 경우 대체 작업이 클러스터형 인덱스를 다시 작성하고 예기치 않게 느리게 수행하는 경우 오류를 발생시키는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="62b1d8e78b5d19e4306f174c1727bdca1b21d25f" translate="yes" xml:space="preserve">
          <source>In this case, shortening the index may may be beneficial:</source>
          <target state="translated">이 경우 인덱스를 줄이는 것이 유리할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4b930387f28e6de4145cef10a2924e32d68e650" translate="yes" xml:space="preserve">
          <source>In this case, the value fits in the master definition, but is too long for the slave field, and so replication will fail.</source>
          <target state="translated">이 경우 값이 마스터 정의에 맞지만 슬레이브 필드에 비해 너무 길어 복제가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="2aa419580614ee122f37a1c21d13b088e22f327c" translate="yes" xml:space="preserve">
          <source>In this case, this is as if the table had four rows. However if we enter the query:</source>
          <target state="translated">이 경우 이것은 테이블에 네 개의 행이있는 것처럼 보입니다. 그러나 쿼리를 입력하면 :</target>
        </trans-unit>
        <trans-unit id="439c79c25888acaeb458b77f3231c2d01569a570" translate="yes" xml:space="preserve">
          <source>In this collection, the address column is a JSON object and the column grades is a JSON array. Unlike the JSON table, just specifying the column name with no Jpath result in displaying the JSON representation of them. For instance:</source>
          <target state="translated">이 컬렉션에서 주소 열은 JSON 객체이고 열 등급은 JSON 배열입니다. JSON 테이블과 달리 Jpath없이 열 이름을 지정하면 JSON 표시가 표시됩니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="8b438bd5424df9fad2d586f408f75293e4899e5f" translate="yes" xml:space="preserve">
          <source>In this example &lt;code&gt;\g{-1}&lt;/code&gt; is equivalent to &lt;code&gt;\2&lt;/code&gt;:</source>
          <target state="translated">이 예에서 &lt;code&gt;\g{-1}&lt;/code&gt; 은 &lt;code&gt;\2&lt;/code&gt; 같습니다.</target>
        </trans-unit>
        <trans-unit id="235029a6907099ef71df0e85805461aed8cc990f" translate="yes" xml:space="preserve">
          <source>In this example all history will be stored in the partition &lt;code&gt;p_hist&lt;/code&gt; while all current data will be in the partition &lt;code&gt;p_cur&lt;/code&gt;. The table must have exactly one current partition and at least one historical partition.</source>
          <target state="translated">이 예제에서 모든 히스토리는 &lt;code&gt;p_hist&lt;/code&gt; 파티션에 저장되고 모든 현재 데이터는 &lt;code&gt;p_cur&lt;/code&gt; 파티션에 저장 됩니다. 테이블에는 정확히 하나의 현재 파티션과 하나 이상의 히스토리 파티션이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="2e926d45e263da187e5820c4703ee2cb18faa236" translate="yes" xml:space="preserve">
          <source>In this example the pattern &lt;code&gt;(?i)m((?-i)aria)db&lt;/code&gt; matches the words &lt;code&gt;MariaDB&lt;/code&gt;, &lt;code&gt;Mariadb&lt;/code&gt;, &lt;code&gt;mariadb&lt;/code&gt;, but not &lt;code&gt;MARIADB&lt;/code&gt;:</source>
          <target state="translated">이 예에서, 패턴 &lt;code&gt;(?i)m((?-i)aria)db&lt;/code&gt; 단어 일치 &lt;code&gt;MariaDB&lt;/code&gt; , &lt;code&gt;Mariadb&lt;/code&gt; , &lt;code&gt;mariadb&lt;/code&gt; 아니지만 &lt;code&gt;MARIADB&lt;/code&gt; 을 :</target>
        </trans-unit>
        <trans-unit id="86505a275b7e7602647d99bce75053a23aa87eb7" translate="yes" xml:space="preserve">
          <source>In this example we have added another join condition, which ensures that we only pick the matching row from tableB having the latest fromDate. In this case tableB will contain duplicates of the column B.id, so in order to ensure uniqueness the primary key has to contain the fromDate column as well. In other words the primary key of tableB is (B.id, B.fromDate).</source>
          <target state="translated">이 예에서는 다른 조인 조건을 추가하여 최신 fromDate가있는 tableB에서 일치하는 행만 선택하도록합니다. 이 경우 tableB는 B.id 열의 복제본을 포함하므로 고유성을 보장하기 위해 기본 키에는 fromDate 열도 포함되어야합니다. 즉, tableB의 기본 키는 (B.id, B.fromDate)입니다.</target>
        </trans-unit>
        <trans-unit id="d654866c079100af8314dc52100dfbf30f654fb6" translate="yes" xml:space="preserve">
          <source>In this example, a &lt;a href=&quot;../tinyint/index&quot;&gt;TINYINT&lt;/a&gt; variable, &lt;code&gt;x&lt;/code&gt; is declared in the outter block. But in the inner block &lt;code&gt;x&lt;/code&gt; is re-declared as a &lt;a href=&quot;../char/index&quot;&gt;CHAR&lt;/a&gt; and an &lt;code&gt;y&lt;/code&gt; variable is declared. The inner &lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt; shows the &quot;new&quot; value of &lt;code&gt;x&lt;/code&gt;, and the value of &lt;code&gt;y&lt;/code&gt;. But when x is selected in the outer block, the &quot;old&quot; value is returned. The final &lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt; doesn't try to read &lt;code&gt;y&lt;/code&gt;, because it doesn't exist in that context.</source>
          <target state="translated">이 예에서 &lt;a href=&quot;../tinyint/index&quot;&gt;TINYINT&lt;/a&gt; 변수 &lt;code&gt;x&lt;/code&gt; 는 외부 블록에 선언됩니다. 그러나 내부 블록 &lt;code&gt;x&lt;/code&gt; A와 재 선언이다 &lt;a href=&quot;../char/index&quot;&gt;CHAR&lt;/a&gt; 및 &lt;code&gt;y&lt;/code&gt; 변수 선언된다. 내부 &lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt; 는 &quot;새로운&quot; &lt;code&gt;x&lt;/code&gt; 값과 &lt;code&gt;y&lt;/code&gt; 값을 보여줍니다 . 그러나 외부 블록에서 x를 선택하면 &quot;이전&quot;값이 반환됩니다. 최종 &lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt; 는 해당 컨텍스트에 없으므로 &lt;code&gt;y&lt;/code&gt; 를 읽으려고 시도 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a177bce2da4ab85ee7e53e405119275eabbe9296" translate="yes" xml:space="preserve">
          <source>In this example, a user &lt;code&gt;serg&lt;/code&gt; is already logged into the operating system and has full shell access. He has already authenticated with the operating system and his MariaDB account is configured to use the &lt;code&gt;&lt;a href=&quot;../authentication-plugin-unix-socket/index&quot;&gt;unix_socket&lt;/a&gt;&lt;/code&gt; authentication plugin, so he does not need to authenticate again for the database. MariaDB accepts his operating system credentials and allows him to connect. However, any attempt to connect to the database as another operating system user will be denied.</source>
          <target state="translated">이 예에서 사용자 &lt;code&gt;serg&lt;/code&gt; 는 이미 운영 체제에 로그인되어 있으며 전체 셸 액세스 권한이 있습니다. 그는 이미 운영 체제로 인증했으며 MariaDB 계정은 &lt;code&gt;&lt;a href=&quot;../authentication-plugin-unix-socket/index&quot;&gt;unix_socket&lt;/a&gt;&lt;/code&gt; 인증 플러그인 을 사용하도록 구성 되었으므로 데이터베이스에 대해 다시 인증 할 필요가 없습니다. MariaDB는 운영 체제 자격 증명을 수락하고 연결할 수 있습니다. 그러나 다른 운영 체제 사용자로 데이터베이스에 연결하려는 시도는 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="9dd540743efc5a0cd6709cf4e503d56d067f3b09" translate="yes" xml:space="preserve">
          <source>In this example, a user &lt;code&gt;serg&lt;/code&gt; is already logged into the operating system and has full shell access. He has already authenticated with the operating system and his MariaDB account is configured to use the &lt;code&gt;unix_socket&lt;/code&gt; authentication plugin, so he does not need to authenticate again for the database. MariaDB accepts his operating system credentials and allows him to connect. However, any attempt to connect to the database as another operating system user will be denied.</source>
          <target state="translated">이 예에서 사용자 &lt;code&gt;serg&lt;/code&gt; 는 이미 운영 체제에 로그인되어 있으며 전체 셸 액세스 권한이 있습니다. 그는 이미 운영 체제로 인증했으며 MariaDB 계정은 &lt;code&gt;unix_socket&lt;/code&gt; 인증 플러그인 을 사용하도록 구성 되었으므로 데이터베이스에 대해 다시 인증 할 필요가 없습니다. MariaDB는 운영 체제 자격 증명을 수락하고 연결할 수 있습니다. 그러나 다른 운영 체제 사용자로 데이터베이스에 연결하려는 시도는 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="ef2165ccf6a509c9643d390c423d1a0ace127a79" translate="yes" xml:space="preserve">
          <source>In this example, a user &lt;code&gt;wlad&lt;/code&gt; is already logged into the system. Because he has identified himself to the operating system, he does not need to do it again for the database &amp;mdash; MariaDB trusts the operating system credentials. However, he cannot connect to the database as another user.</source>
          <target state="translated">이 예제에서 사용자 &lt;code&gt;wlad&lt;/code&gt; 는 이미 시스템에 로그인되어 있습니다. 자신이 운영 체제를 식별 했으므로 데이터베이스에 대해 다시 수행 할 필요가 없습니다. MariaDB는 운영 체제 자격 증명을 신뢰합니다. 그러나 다른 사용자로 데이터베이스에 연결할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="da14afe35a6f41a6064f5cce7bcfcfe245cc5789" translate="yes" xml:space="preserve">
          <source>In this example, column order_no will be changed to a autoincrement column with a startvalue of 10</source>
          <target state="translated">이 예에서 열 order_no는 시작 값이 10 인 자동 증분 열로 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="f0e96095dc33b228b4b6722b257d43d2c8b7ce1d" translate="yes" xml:space="preserve">
          <source>In this example, we added another cursor option, the limit option that works like the limit SQL clause.</source>
          <target state="translated">이 예에서는 limit SQL 절처럼 작동하는 limit 옵션이라는 다른 커서 옵션을 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="0a241acdf9441229a7703de7d996a680b0a2d935" translate="yes" xml:space="preserve">
          <source>In this example, we'll define a &lt;a href=&quot;../handler/index&quot;&gt;HANDLER&lt;/a&gt; for an error code. When the error occurs, we &lt;a href=&quot;index&quot;&gt;SIGNAL&lt;/a&gt; a more informative error which makes sense for our procedure:</source>
          <target state="translated">이 예에서는 오류 코드에 대한 &lt;a href=&quot;../handler/index&quot;&gt;HANDLER&lt;/a&gt; 를 정의합니다 . 오류가 발생하면 절차에 적합한보다 유익한 오류에 &lt;a href=&quot;index&quot;&gt;신호를 보냅니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4ea2d11428a654aec637382536de8806661655eb" translate="yes" xml:space="preserve">
          <source>In this first scenario, both client and server were partially upgraded to 5.5.33 before the process aborted. The problem looks like this:</source>
          <target state="translated">이 첫 번째 시나리오에서는 프로세스가 중단되기 전에 클라이언트와 서버가 5.5.33으로 부분적으로 업그레이드되었습니다. 문제는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8e99a3c3f449a963216d9b3973bcdb101d1eed31" translate="yes" xml:space="preserve">
          <source>In this mode, &lt;a href=&quot;../innodb/index&quot;&gt;InnoDB&lt;/a&gt; does not hold any table-level locks at all. This is the fastest and most scalable mode, but is not safe for &lt;a href=&quot;../binary-log-formats/index#statement-based&quot;&gt;statement-based&lt;/a&gt; replication.</source>
          <target state="translated">이 모드에서 &lt;a href=&quot;../innodb/index&quot;&gt;InnoDB&lt;/a&gt; 는 테이블 수준 잠금을 전혀 보유하지 않습니다. 가장 빠르고 확장 가능한 모드이지만 &lt;a href=&quot;../binary-log-formats/index#statement-based&quot;&gt;명령문 기반&lt;/a&gt; 복제 에는 안전하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c277e7930f014092491c39189d4b178a64311812" translate="yes" xml:space="preserve">
          <source>In this mode, &lt;a href=&quot;../innodb/index&quot;&gt;InnoDB&lt;/a&gt; holds a table-level lock for all &lt;code&gt;&lt;a href=&quot;../insert/index&quot;&gt;INSERT&lt;/a&gt;&lt;/code&gt; statements until the statement completes.</source>
          <target state="translated">이 모드에서 &lt;a href=&quot;../innodb/index&quot;&gt;InnoDB&lt;/a&gt; 는 명령문이 완료 될 때까지 모든 &lt;code&gt;&lt;a href=&quot;../insert/index&quot;&gt;INSERT&lt;/a&gt;&lt;/code&gt; 문에 대한 테이블 레벨 잠금을 보유합니다 .</target>
        </trans-unit>
        <trans-unit id="04cd9e022c46647a64cb7771601a6623cb8ec045" translate="yes" xml:space="preserve">
          <source>In this mode, &lt;a href=&quot;../innodb/index&quot;&gt;InnoDB&lt;/a&gt; holds a table-level lock for all bulk &lt;a href=&quot;../insert/index&quot;&gt;INSERT&lt;/a&gt; statements (such as &lt;a href=&quot;../load-data-infile/index&quot;&gt;LOAD DATA&lt;/a&gt; or &lt;a href=&quot;../insert-select/index&quot;&gt;INSERT ... SELECT&lt;/a&gt;) until the end of the statement. For simple &lt;a href=&quot;../insert/index&quot;&gt;INSERT&lt;/a&gt; statements, no table-level lock is held. Instead, a lightweight mutex is used which scales significantly better. This is the default setting.</source>
          <target state="translated">이 모드에서 &lt;a href=&quot;../innodb/index&quot;&gt;InnoDB&lt;/a&gt; 는 명령문 이 끝날 때까지 모든 대량 &lt;a href=&quot;../insert/index&quot;&gt;INSERT&lt;/a&gt; 문 (예 : &lt;a href=&quot;../load-data-infile/index&quot;&gt;LOAD DATA&lt;/a&gt; 또는 &lt;a href=&quot;../insert-select/index&quot;&gt;INSERT ... SELECT&lt;/a&gt; )에 대한 테이블 레벨 잠금을 보유합니다 . 간단한 &lt;a href=&quot;../insert/index&quot;&gt;INSERT&lt;/a&gt; 문의 경우 테이블 레벨 잠금이 유지되지 않습니다. 대신, 훨씬 더 잘 확장되는 가벼운 뮤텍스가 사용됩니다. 이것이 기본 설정입니다.</target>
        </trans-unit>
        <trans-unit id="e475aabaca6596265250cf88d42222a45f4007c8" translate="yes" xml:space="preserve">
          <source>In this mode, you run cpimport from the individual PM nodes independently, which will import the source file that exists on that PM. Concurrent imports can be executed on every PM for the same table.</source>
          <target state="translated">이 모드에서는 개별 PM 노드에서 독립적으로 cpimport를 실행하여 해당 PM에 존재하는 소스 파일을 가져옵니다. 동일한 테이블에 대해 모든 PM에서 동시 가져 오기를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd718861cef2c37a911c1934d025f1fd1665d455" translate="yes" xml:space="preserve">
          <source>In this mode, you run the cpimport from a central location(either &lt;a href=&quot;../columnstore-user-module/index&quot;&gt;UM&lt;/a&gt; or &lt;a href=&quot;../columnstore-performance-module/index&quot;&gt;PM&lt;/a&gt;). The source data is in already partitioned data files residing on the PMs. Each PM should have the source data file of the same name but containing the partitioned data for the PM</source>
          <target state="translated">이 모드에서는 중앙 위치 ( &lt;a href=&quot;../columnstore-user-module/index&quot;&gt;UM&lt;/a&gt; 또는 &lt;a href=&quot;../columnstore-performance-module/index&quot;&gt;PM&lt;/a&gt; ) 에서 cpimport를 실행합니다 . 소스 데이터는 PM에 상주하는 이미 파티션 된 데이터 파일에 있습니다. 각 PM에는 동일한 이름의 소스 데이터 파일이 있어야하지만 PM에 대한 파티션 된 데이터가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="044d75edf95e3a05e6a8aba0b2c457d7a8c24be3" translate="yes" xml:space="preserve">
          <source>In this mode, you run the cpimport from a central location(either &lt;a href=&quot;../columnstore-user-module/index&quot;&gt;UM&lt;/a&gt; or &lt;a href=&quot;../columnstore-performance-module/index&quot;&gt;PM&lt;/a&gt;). The source file is located at this central location and the data from cpimport is distributed across all the &lt;a href=&quot;../columnstore-performance-module/index&quot;&gt;PM&lt;/a&gt; nodes. If no mode is specified, then this is the default for cpimport mode. The central location where cpimport is being run from could be UM or any one of the PM.</source>
          <target state="translated">이 모드에서는 중앙 위치 ( &lt;a href=&quot;../columnstore-user-module/index&quot;&gt;UM&lt;/a&gt; 또는 &lt;a href=&quot;../columnstore-performance-module/index&quot;&gt;PM&lt;/a&gt; ) 에서 cpimport를 실행합니다 . 소스 파일은이 중앙 위치에 있으며 cpimport의 데이터는 모든 &lt;a href=&quot;../columnstore-performance-module/index&quot;&gt;PM&lt;/a&gt; 노드에 분산 됩니다. 모드를 지정하지 않으면 cpimport 모드의 기본값입니다. cpimport가 실행되는 중앙 위치는 UM 또는 PM 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="096115b48c416da38ce2f6237d92c6ac4cfda7b3" translate="yes" xml:space="preserve">
          <source>In this page &lt;code&gt;CASE&lt;/code&gt; refers to the &lt;a href=&quot;../case-operator/index&quot;&gt;CASE operator&lt;/a&gt;, not to the &lt;a href=&quot;../case-statement/index&quot;&gt;CASE statement&lt;/a&gt;&lt;code&gt;.&lt;/code&gt;</source>
          <target state="translated">이 페이지에서 &lt;code&gt;CASE&lt;/code&gt; 는 &lt;a href=&quot;../case-statement/index&quot;&gt;CASE 문이&lt;/a&gt; 아니라 &lt;a href=&quot;../case-operator/index&quot;&gt;CASE 연산자를&lt;/a&gt; 나타냅니다 &lt;code&gt;.&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="997f227cf6cb4f630dda037c17e935d88a29505a" translate="yes" xml:space="preserve">
          <source>In this pipeline &amp;ldquo;$match&amp;rdquo; is an early filter, &amp;ldquo;$unwind&amp;rdquo; means that the grades array will be expanded (one Document for each array values) and &amp;ldquo;$project&amp;rdquo; eliminates the _id and cuisine columns and gives the Jpath for the date, grade and score columns.</source>
          <target state="translated">이 파이프 라인에서 &quot;$ match&quot;는 초기 필터이며 &quot;$ unwind&quot;는 성적 배열이 확장되고 (각 배열 값에 대해 하나의 문서) &quot;$ project&quot;는 _id 및 요리 열을 제거하고 날짜에 대한 Jpath를 제공함을 의미합니다. , 성적 및 점수 열.</target>
        </trans-unit>
        <trans-unit id="bb87748eaff3e759f488db3f9a83b6fce777562d" translate="yes" xml:space="preserve">
          <source>In this query big can be a huge table having million rows. Having correctly specified the block size as 1 when creating the table, the wrapper just reads the 10 first rows and stops. However, when closing the statement, these MySQL/MariaDB drivers must still retrieve all the rows returned by the query. This is why, the wrapper class when closing the statement also cancels the query to stop that extra reading.</source>
          <target state="translated">이 쿼리에서 big은 백만 개의 행이있는 거대한 테이블 일 수 있습니다. 테이블을 작성할 때 블록 크기를 1로 올바르게 지정하면 랩퍼는 단지 10 개의 첫 행을 읽고 중지합니다. 그러나 문을 닫을 때 이러한 MySQL / MariaDB 드라이버는 여전히 쿼리에서 반환 된 모든 행을 검색해야합니다. 이것이 명령문을 닫을 때 랩퍼 클래스가 추가 읽기를 중지하기 위해 쿼리를 취소하는 이유입니다.</target>
        </trans-unit>
        <trans-unit id="b4dde17217dbe5a541018d39fce44bda3e54f0c4" translate="yes" xml:space="preserve">
          <source>In this scenario, only the library upgraded. The problem looks like this:</source>
          <target state="translated">이 시나리오에서는 라이브러리 만 업그레이드되었습니다. 문제는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c05ee0fd9dcfc76193bdfcd314138c9721efbfc3" translate="yes" xml:space="preserve">
          <source>In this scenario, queries listing account information and general transaction activities are OLTP operations. Reports analyzing transaction activities run by the customer for individual accounts or by the bank on all customers are OLAP operations.</source>
          <target state="translated">이 시나리오에서 계정 정보를 나열하는 쿼리 및 일반 트랜잭션 활동은 OLTP 작업입니다. 고객이 개별 계정을 위해 또는 은행이 모든 고객에 대해 실행 한 거래 활동을 분석하는 보고서는 OLAP 작업입니다.</target>
        </trans-unit>
        <trans-unit id="9174c7a195819895812184e06e27984ee32c64ff" translate="yes" xml:space="preserve">
          <source>In this scenario, the client upgraded, but Galera-server did not. The problem looks like this:</source>
          <target state="translated">이 시나리오에서는 클라이언트가 업그레이드되었지만 Galera 서버는 업그레이드되지 않았습니다. 문제는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9c676f52a01b0ab94460f69fb4aaa04dcaa4ce02" translate="yes" xml:space="preserve">
          <source>In this section, we will refer to the directory ColumnStore is installed in as &amp;lt;CSROOT&amp;gt;. If you installed the RPM or DEB package, then your &amp;lt;CSROOT&amp;gt; will be /usr/local. If you installed it from the tarball, &amp;lt;CSROOT&amp;gt; will be where you unpacked it.</source>
          <target state="translated">이 섹션에서는 ColumnStore가 &amp;lt;CSROOT&amp;gt;로 설치된 디렉토리를 참조합니다. RPM 또는 DEB 패키지를 설치 한 경우 &amp;lt;CSROOT&amp;gt;는 / usr / local입니다. tarball에서 설치 한 경우 &amp;lt;CSROOT&amp;gt;에서 압축을 풉니 다.</target>
        </trans-unit>
        <trans-unit id="ef0ed4672b9e25b2a209bdfdd9022e866fe3b201" translate="yes" xml:space="preserve">
          <source>In this specific scenario, &lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_flush_log_at_trx_commit&quot;&gt;innodb_flush_log_at_trx_commit=3&lt;/a&gt;&lt;/code&gt; can be set to ensure that transactions will be durable in InnoDB, even if they are not necessarily durable from the perspective of the binary log.</source>
          <target state="translated">이 특정 시나리오에서는 트랜잭션이 이진 로그의 관점에서 내구성이 없어도 InnoDB에서 트랜잭션이 내구성을 갖도록 &lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_flush_log_at_trx_commit&quot;&gt;innodb_flush_log_at_trx_commit=3&lt;/a&gt;&lt;/code&gt; 을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65669cdb02b7487c1dd18e9bb9dfb702e42bc2e8" translate="yes" xml:space="preserve">
          <source>In this statement, the &quot;Layout&quot; option sets the display format, Column by default or anything else not beginning by 'C' for row layout display. The names of the three columns can be freely chosen. The Flag option gives the meaning of the column. Specify &lt;code&gt;flag=1&lt;/code&gt; for the section name and &lt;code&gt;flag=2&lt;/code&gt; for the key name. Otherwise, the column will contain the key value.</source>
          <target state="translated">이 명령문에서 &quot;레이아웃&quot;옵션은 표시 형식, 기본적으로 열 또는 행 레이아웃 표시에 대해 'C'로 시작하지 않는 표시 형식을 설정합니다. 세 열의 이름은 자유롭게 선택할 수 있습니다. 플래그 옵션은 열의 의미를 제공합니다. 섹션 이름으로 &lt;code&gt;flag=1&lt;/code&gt; 을 지정 하고 키 이름으로 &lt;code&gt;flag=2&lt;/code&gt; 를 지정하십시오. 그렇지 않으면 열에 키 값이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="8696e0d82fc27f6a027683de7f9f7f577c78d38a" translate="yes" xml:space="preserve">
          <source>In this statement, the &lt;em&gt;file_name&lt;/em&gt; option was replaced by the &lt;em&gt;connection&lt;/em&gt; option. It is the URI enabling to retrieve data from a local or remote MongoDB server. The &lt;em&gt;tabname&lt;/em&gt; option is the name of the MongoDB collection that will be used and the &lt;em&gt;dbname&lt;/em&gt; option could have been used to indicate the database containing the collection (it defaults to the current database).</source>
          <target state="translated">이 명령문에서 &lt;em&gt;file_name&lt;/em&gt; 옵션은 &lt;em&gt;연결&lt;/em&gt; 옵션 으로 대체되었습니다 . 로컬 또는 원격 MongoDB 서버에서 데이터를 검색 할 수있는 URI입니다. &lt;em&gt;TABNAME의&lt;/em&gt; 옵션이 사용되며하여 MongoDB를 수집의 이름입니다 &lt;em&gt;DBNAME의&lt;/em&gt; 옵션이 컬렉션 (현재 데이터베이스에 기본값)를 포함하는 데이터베이스를 표시하는 데 사용되었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="12a7abe9bb0dcdd7167358cd7ca7acbb5a809a72" translate="yes" xml:space="preserve">
          <source>In this statement, the Limit option specifies the maximum number of values that will be expanded. If not specified, it defaults to &lt;code&gt;10&lt;/code&gt;. Any values above the limit will be ignored and a warning message issued&lt;sup id=&quot;_ref-2&quot;&gt;[&lt;a href=&quot;#_note-2&quot;&gt;3&lt;/a&gt;]&lt;/sup&gt;. Now you can enter a query such as:</source>
          <target state="translated">이 명령문에서 한계 옵션은 확장 될 최대 값 수를 지정합니다. 지정하지 않으면 기본값은 &lt;code&gt;10&lt;/code&gt; 입니다. 제한을 초과하는 값은 무시되고 경고 메시지가 표시됩니다 &lt;sup id=&quot;_ref-2&quot;&gt;[ &lt;a href=&quot;#_note-2&quot;&gt;3&lt;/a&gt; ]&lt;/sup&gt; . 이제 다음과 같은 쿼리를 입력 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98b57ae4260636c0e0332149778fc5d3210b79f4" translate="yes" xml:space="preserve">
          <source>In this table, the &lt;em&gt;jfile_cols&lt;/em&gt; column just contains a file name. If we update it by:</source>
          <target state="translated">이 테이블에서 &lt;em&gt;jfile_cols&lt;/em&gt; 열은 파일 이름 만 포함합니다. 우리가 업데이트하면 :</target>
        </trans-unit>
        <trans-unit id="bc0ba5cada0d27569120df19448c15985228b84c" translate="yes" xml:space="preserve">
          <source>In this walkthrough, we are going to assume the following hypothetical requirements:</source>
          <target state="translated">이 연습에서는 다음과 같은 가상 요구 사항을 가정합니다.</target>
        </trans-unit>
        <trans-unit id="3bad5ff8472271ed1e62ce8df2f0e2f8259bfdcd" translate="yes" xml:space="preserve">
          <source>In total the algorithm scans the second operand as many times as many refills of the join buffer occur.</source>
          <target state="translated">전체적으로 알고리즘은 조인 버퍼의 많은 리필이 발생하는 횟수만큼 두 번째 피연산자를 스캔합니다.</target>
        </trans-unit>
        <trans-unit id="2f3b6741103129ea57f0241f74ef50fcac31c4b8" translate="yes" xml:space="preserve">
          <source>In transactional mode DML inserts are performed which will be significantly slower plus it will consume both binlog transaction files and ColumnStore VersionBuffer files.</source>
          <target state="translated">트랜잭션 모드에서 DML 삽입이 수행되어 속도가 크게 느려지고 binlog 트랜잭션 파일과 ColumnStore VersionBuffer 파일이 모두 소비됩니다.</target>
        </trans-unit>
        <trans-unit id="697cf6e6aab459bb8347e0071be417bcae04a88f" translate="yes" xml:space="preserve">
          <source>In you specify &lt;code&gt;ON COMPLETION NOT PRESERVE&lt;/code&gt;, and you specify a timestamp in the past for &lt;code&gt;AT&lt;/code&gt; or &lt;code&gt;ENDS&lt;/code&gt; clause, the event will be immediatly dropped. In such cases, you will get a Note 1558: &quot;Event execution time is in the past and ON COMPLETION NOT PRESERVE is set. The event was dropped immediately after creation&quot;.</source>
          <target state="translated">사용자가 지정한에서 &lt;code&gt;ON COMPLETION NOT PRESERVE&lt;/code&gt; , 그리고 당신이 과거에 타임 스탬프를 지정 &lt;code&gt;AT&lt;/code&gt; 또는 &lt;code&gt;ENDS&lt;/code&gt; 절을, 이벤트가 immediatly 삭제됩니다. 이러한 경우 &quot;이벤트 실행 시간이 과거이고 ON COMPLETION NOT PRESERVE가 설정되었습니다. 이벤트가 생성 된 직후 삭제되었습니다.&quot;라는 메모 1558이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="bee4200168d22fae0f17817848e512544b146532" translate="yes" xml:space="preserve">
          <source>In-Order Parallel Replication</source>
          <target state="translated">주문형 병렬 복제</target>
        </trans-unit>
        <trans-unit id="ee9ea4f813c22247985af1144419e9ceb042ea9c" translate="yes" xml:space="preserve">
          <source>In-depth material:</source>
          <target state="translated">심층 자료 :</target>
        </trans-unit>
        <trans-unit id="2b2d64c0df3ab3d11a079d364da5c9248e942816" translate="yes" xml:space="preserve">
          <source>In-order executes transactions in parallel, but orders the commit step of the transactions to happen in the exact same order as on the master. Transactions are only executed in parallel to the extent that this can be automatically verified to be possible without any conflicts. This means that the use of parallelism is completely transparent to the application.</source>
          <target state="translated">순서대로 트랜잭션을 병렬로 실행하지만 트랜잭션의 커밋 단계가 마스터에서와 동일한 순서로 발생하도록 명령합니다. 트랜잭션은 충돌없이 가능한 것으로 자동 확인 될 수있는 정도로만 병렬로 실행됩니다. 이것은 병렬 처리의 사용이 응용 프로그램에 완전히 투명하다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="cdd6a85070c74a08f344029a16ecd7f41093395b" translate="yes" xml:space="preserve">
          <source>In_use</source>
          <target state="translated">In_use</target>
        </trans-unit>
        <trans-unit id="ebf6dfea313a8f94e1be1fc48e3ee6d8da4f32a9" translate="yes" xml:space="preserve">
          <source>Include &lt;a href=&quot;../stored-programs-and-views-events/index&quot;&gt;Event Scheduler events&lt;/a&gt; for the dumped databases in the output.</source>
          <target state="translated">포함 &lt;a href=&quot;../stored-programs-and-views-events/index&quot;&gt;이벤트 스케줄러 이벤트&lt;/a&gt; 출력에 덤프 된 데이터베이스를.</target>
        </trans-unit>
        <trans-unit id="2757a3dc13c84d4a8f49d73885fd41b12747bdfe" translate="yes" xml:space="preserve">
          <source>Include &lt;a href=&quot;../triggers/index&quot;&gt;triggers&lt;/a&gt; for each dumped table in the output. This option is enabled by default; disable it with &lt;code&gt;--skip-triggers&lt;/code&gt;.</source>
          <target state="translated">포함 &lt;a href=&quot;../triggers/index&quot;&gt;트리거&lt;/a&gt; 출력의 각 덤프 테이블을. 이 옵션은 기본적으로 활성화되어 있습니다. &lt;code&gt;--skip-triggers&lt;/code&gt; 로 비활성화하십시오 .</target>
        </trans-unit>
        <trans-unit id="068323f831dbbabe886ba3be9448c8e97e022268" translate="yes" xml:space="preserve">
          <source>Include all MariaDB and/or MySQL specific create options in &lt;code&gt;CREATE TABLE&lt;/code&gt; statements. Use &lt;code&gt;--skip-create-options&lt;/code&gt; to disable.</source>
          <target state="translated">&lt;code&gt;CREATE TABLE&lt;/code&gt; 문에 모든 MariaDB 및 / 또는 MySQL 특정 작성 옵션을 포함하십시오 . &lt;code&gt;--skip-create-options&lt;/code&gt; 하려면 --skip-create-options 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="232263f46bb4a20a712858d3cb339d36d1da38bb" translate="yes" xml:space="preserve">
          <source>Include stored routines (&lt;a href=&quot;../stored-procedures/index&quot;&gt;procedures&lt;/a&gt; and &lt;a href=&quot;../stored-functions/index&quot;&gt;functions&lt;/a&gt;) for the dumped databases in the output. Use of this option requires the &lt;code&gt;SELECT&lt;/code&gt; privilege for the &lt;a href=&quot;../mysqlproc-table/index&quot;&gt;mysql.proc&lt;/a&gt; table. The output generated using &lt;code&gt;--routines&lt;/code&gt; contains &lt;a href=&quot;../create-procedure/index&quot;&gt;CREATE PROCEDURE&lt;/a&gt; and &lt;a href=&quot;../create-function/index&quot;&gt;CREATE FUNCTION&lt;/a&gt; statements to re-create the routines. However, these statements do not include attributes such as the routine creation and modification timestamps. This means that when the routines are reloaded, they will be created with the timestamps equal to the reload time.</source>
          <target state="translated">덤프 된 데이터베이스에 대한 저장 루틴 ( &lt;a href=&quot;../stored-procedures/index&quot;&gt;프로 시저&lt;/a&gt; 및 &lt;a href=&quot;../stored-functions/index&quot;&gt;함수&lt;/a&gt; )을 출력에 포함하십시오. 이 옵션을 사용하려면 &lt;a href=&quot;../mysqlproc-table/index&quot;&gt;mysql.proc&lt;/a&gt; 테이블에 대한 &lt;code&gt;SELECT&lt;/code&gt; 권한 이 필요 합니다. &lt;code&gt;--routines&lt;/code&gt; 를 사용하여 생성 된 출력 에는 루틴을 다시 작성하기위한 &lt;a href=&quot;../create-procedure/index&quot;&gt;CREATE PROCEDURE&lt;/a&gt; 및 &lt;a href=&quot;../create-function/index&quot;&gt;CREATE FUNCTION&lt;/a&gt; 문이 포함됩니다. 그러나 이러한 명령문에는 루틴 작성 및 수정 시간 소인과 같은 속성이 포함되지 않습니다. 이는 루틴이 재로드 될 때 재로드 시간과 동일한 시간 소인으로 작성됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="20a857b6c8a9c88f56b3fe3e91b91e9a01c88929" translate="yes" xml:space="preserve">
          <source>Including HeidiSQL in the MSI Installer</source>
          <target state="translated">MSI 설치 프로그램에 HeidiSQL 포함</target>
        </trans-unit>
        <trans-unit id="38dde39189785cbd61de68da854b9540479993ed" translate="yes" xml:space="preserve">
          <source>Including Option File Directories</source>
          <target state="translated">옵션 파일 디렉토리 포함</target>
        </trans-unit>
        <trans-unit id="daeb3231e3ca0249f6a60f9ed6491b72e189f3e5" translate="yes" xml:space="preserve">
          <source>Including Option Files</source>
          <target state="translated">옵션 파일 포함</target>
        </trans-unit>
        <trans-unit id="56acf1dc899e80446b412ec6aa810c9be9075b5f" translate="yes" xml:space="preserve">
          <source>Including a checksum in binlog events</source>
          <target state="translated">binlog 이벤트에 체크섬 포함</target>
        </trans-unit>
        <trans-unit id="83b6f9e6f58e4b6c1cb61243191345b2c51ffe90" translate="yes" xml:space="preserve">
          <source>Including of actual data into report</source>
          <target state="translated">실제 데이터를 보고서에 포함</target>
        </trans-unit>
        <trans-unit id="412d170006ffe3723f1141b1dc98c7a94a7bec1f" translate="yes" xml:space="preserve">
          <source>Incomparable fields</source>
          <target state="translated">비교할 수없는 필드</target>
        </trans-unit>
        <trans-unit id="13c99e839ca51dc6171c2d2a15c5a7afccf79787" translate="yes" xml:space="preserve">
          <source>Incompatibilities</source>
          <target state="translated">Incompatibilities</target>
        </trans-unit>
        <trans-unit id="3745b0d31628a8c316c384896391edd4a2f3b9b5" translate="yes" xml:space="preserve">
          <source>Incompatibilities with MariaDB/MySQL 5.5</source>
          <target state="translated">MariaDB / MySQL 5.5와의 비 호환성</target>
        </trans-unit>
        <trans-unit id="37e21e1a43cee7f2d6b53a012b5f3a6cc9529dbc" translate="yes" xml:space="preserve">
          <source>Incompatible Changes Between 10.0 and 10.1</source>
          <target state="translated">10.0과 10.1 사이의 호환되지 않는 변경</target>
        </trans-unit>
        <trans-unit id="368f534febe9bbf9075b0425e50151df46bd2da1" translate="yes" xml:space="preserve">
          <source>Incompatible Changes Between 10.1 and 10.2</source>
          <target state="translated">10.1과 10.2 사이의 호환되지 않는 변경</target>
        </trans-unit>
        <trans-unit id="64994cb98ffcae14492ce7fbc1ee3bc8c9d244f1" translate="yes" xml:space="preserve">
          <source>Incompatible Changes Between 10.2 and 10.3</source>
          <target state="translated">10.2와 10.3 사이의 호환되지 않는 변경</target>
        </trans-unit>
        <trans-unit id="639f1877c2ddaebf8798185a8f6561920a0f5868" translate="yes" xml:space="preserve">
          <source>Incompatible Changes Between 10.3 and 10.4</source>
          <target state="translated">10.3과 10.4 사이의 호환되지 않는 변경</target>
        </trans-unit>
        <trans-unit id="ded6592a1baa429eaee31ca3dc0f0396c48b155f" translate="yes" xml:space="preserve">
          <source>Incompatible Changes Between 10.4 and 10.5</source>
          <target state="translated">10.4와 10.5 사이의 호환되지 않는 변경</target>
        </trans-unit>
        <trans-unit id="cb60ce2e9d3533e87e7aea0506a9ff4ee13ea90a" translate="yes" xml:space="preserve">
          <source>Incompatible Changes Between 5.5 and 10.0</source>
          <target state="translated">5.5와 10.0 사이의 호환되지 않는 변경</target>
        </trans-unit>
        <trans-unit id="2f167cb788a1b18892516e62af6adfb47dea77da" translate="yes" xml:space="preserve">
          <source>Incompatible changes between 5.3 and 5.5</source>
          <target state="translated">5.3과 5.5 사이의 호환되지 않는 변경</target>
        </trans-unit>
        <trans-unit id="fea40042ba8727051ba48a446173107d5163b83b" translate="yes" xml:space="preserve">
          <source>Incomplete list of graphical clients</source>
          <target state="translated">불완전한 그래픽 클라이언트 목록</target>
        </trans-unit>
        <trans-unit id="2e887a8eda84c5b3c73696e362a713c70bd3309b" translate="yes" xml:space="preserve">
          <source>Inconsistency in usage of column lists for partitioning</source>
          <target state="translated">파티셔닝을위한 컬럼 목록 사용 불일치</target>
        </trans-unit>
        <trans-unit id="d283f406cf0041dfc9da521d73cc9613de47b492" translate="yes" xml:space="preserve">
          <source>Incorrect %s value: '%s'</source>
          <target state="translated">잘못된 % s 값 : '% s'</target>
        </trans-unit>
        <trans-unit id="e70cdb0b0f5a4cb84639eee5555c31ddeedea8e9" translate="yes" xml:space="preserve">
          <source>Incorrect %s value: '%s' for column '%s' at row %ld</source>
          <target state="translated">잘못된 % s 값 : 행 % ld의 열 '% s'에 대한 '% s'</target>
        </trans-unit>
        <trans-unit id="7dc78294d37b986b06eadfa707c7423c5f553fd7" translate="yes" xml:space="preserve">
          <source>Incorrect %s value: '%s' for function %s</source>
          <target state="translated">잘못된 % s 값 : 함수 % s의 '% s'</target>
        </trans-unit>
        <trans-unit id="31594e6a53b11486f370d44e6cf38aef46c2e350" translate="yes" xml:space="preserve">
          <source>Incorrect argument type to variable '%s'</source>
          <target state="translated">변수 '% s'에 잘못된 인수 유형</target>
        </trans-unit>
        <trans-unit id="11454bad0d13a1797494ea97b5b145617b4bc80c" translate="yes" xml:space="preserve">
          <source>Incorrect arguments to %s</source>
          <target state="translated">% s에 대한 잘못된 인수</target>
        </trans-unit>
        <trans-unit id="451ddaf673b24ce902cbe1fcd8e5a78231155915" translate="yes" xml:space="preserve">
          <source>Incorrect catalog name '%s'</source>
          <target state="translated">카탈로그 이름 '% s'이 (가) 잘못되었습니다</target>
        </trans-unit>
        <trans-unit id="0d142b38c2b3608dc57ce3cdc83e9b9cc12384f7" translate="yes" xml:space="preserve">
          <source>Incorrect column name '%s'</source>
          <target state="translated">열 이름 '% s'이 (가) 잘못되었습니다</target>
        </trans-unit>
        <trans-unit id="c6705a3e3ab982a21f54b9e9c0e2eefc7d229bf9" translate="yes" xml:space="preserve">
          <source>Incorrect column specifier for column '%s'</source>
          <target state="translated">열 '% s'에 대한 잘못된 열 지정자</target>
        </trans-unit>
        <trans-unit id="f65d1641366c97f25289911f11a5eeb7a9b9cda0" translate="yes" xml:space="preserve">
          <source>Incorrect database name '%s'</source>
          <target state="translated">데이터베이스 이름 '% s'이 (가) 잘못되었습니다</target>
        </trans-unit>
        <trans-unit id="8c02207361ab2a80e575091f21de0c523ad1afea" translate="yes" xml:space="preserve">
          <source>Incorrect default value '%-.128s' for column '%.192s'</source>
          <target state="translated">열 '% .192s'에 대해 잘못된 기본값 '%-. 128s'</target>
        </trans-unit>
        <trans-unit id="27a9775c0dca050eb0242484672eb3ad58adf488" translate="yes" xml:space="preserve">
          <source>Incorrect foreign key definition for '%s': %s</source>
          <target state="translated">'% s'에 대한 외래 키 정의가 잘못되었습니다 : % s</target>
        </trans-unit>
        <trans-unit id="fbd709ef9a6343bc781c11be43e2149866b878a5" translate="yes" xml:space="preserve">
          <source>Incorrect index name '%s'</source>
          <target state="translated">인덱스 이름 '% s'이 (가) 잘못되었습니다</target>
        </trans-unit>
        <trans-unit id="5055e42abe4ef76265084f1819f1a6fb5e3ea204" translate="yes" xml:space="preserve">
          <source>Incorrect information in file: '%s'</source>
          <target state="translated">파일의 정보가 잘못되었습니다 : '% s'</target>
        </trans-unit>
        <trans-unit id="d5620256b7758e19cf641ba5f1a968931e91c76f" translate="yes" xml:space="preserve">
          <source>Incorrect input data</source>
          <target state="translated">잘못된 입력 데이터</target>
        </trans-unit>
        <trans-unit id="d6e443013cabd10deca3a988097876b6565eb2d1" translate="yes" xml:space="preserve">
          <source>Incorrect integer value</source>
          <target state="translated">잘못된 정수 값</target>
        </trans-unit>
        <trans-unit id="c25ee50acc16842260aae535b59d3e8343aa61c0" translate="yes" xml:space="preserve">
          <source>Incorrect key file for table '%s'; try to repair it</source>
          <target state="translated">테이블 '% s'의 키 파일이 잘못되었습니다. 그것을 수리하려고</target>
        </trans-unit>
        <trans-unit id="3b249742fcb6d4fd339e2a34f5afc2d1edae2366" translate="yes" xml:space="preserve">
          <source>Incorrect number of FETCH variables</source>
          <target state="translated">잘못된 수의 FETCH 변수</target>
        </trans-unit>
        <trans-unit id="60c0ba6e0cbbb058a4c3cb99d66a411586d24d4d" translate="yes" xml:space="preserve">
          <source>Incorrect number of arguments for %s %s; expected %u, got %u</source>
          <target state="translated">% s % s에 대해 잘못된 인수 수가 있습니다. % u 예상 % u</target>
        </trans-unit>
        <trans-unit id="2b5c2bb88554b97c3a0d0819954f65fdb8fe229c" translate="yes" xml:space="preserve">
          <source>Incorrect order, so no match:</source>
          <target state="translated">잘못된 순서이므로 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8dbb48222fd87f5f319191e7755963e4f7427a58" translate="yes" xml:space="preserve">
          <source>Incorrect parameter count in the call to native function '%s'</source>
          <target state="translated">기본 함수 '% s'에 대한 호출에서 잘못된 매개 변수 수</target>
        </trans-unit>
        <trans-unit id="0cca67bb711f11cbdd1dfb6801077351c44df354" translate="yes" xml:space="preserve">
          <source>Incorrect parameter count to procedure '%s'</source>
          <target state="translated">프로 시저 '% s'에 대한 잘못된 매개 변수 수</target>
        </trans-unit>
        <trans-unit id="376514841289f2b47945dc5f9b71db83555c8dec" translate="yes" xml:space="preserve">
          <source>Incorrect parameter or combination of parameters for START SLAVE UNTIL</source>
          <target state="translated">START SLAVE UNTIL에 대한 잘못된 매개 변수 또는 매개 변수 조합</target>
        </trans-unit>
        <trans-unit id="c823c60860c897e25d2846924faf4fe6fc0edad6" translate="yes" xml:space="preserve">
          <source>Incorrect parameters in the call to native function '%s'</source>
          <target state="translated">기본 함수 '% s'에 대한 호출에서 잘못된 매개 변수</target>
        </trans-unit>
        <trans-unit id="dc4c5c449d646a20d68fbee608524db943500f4a" translate="yes" xml:space="preserve">
          <source>Incorrect parameters in the call to stored function '%s'</source>
          <target state="translated">저장된 함수 '% s'에 대한 호출에서 잘못된 매개 변수</target>
        </trans-unit>
        <trans-unit id="d3165f34fcd731b2a9bc8ce875610ac10ca1d196" translate="yes" xml:space="preserve">
          <source>Incorrect parameters to procedure '%s'</source>
          <target state="translated">'% s'프로 시저에 잘못된 매개 변수</target>
        </trans-unit>
        <trans-unit id="3514df11cdfccf236153bd66b904b6e1bf3371b4" translate="yes" xml:space="preserve">
          <source>Incorrect partition name</source>
          <target state="translated">잘못된 파티션 이름</target>
        </trans-unit>
        <trans-unit id="04e93cc0601bacdd3e8b0cabfece7cc523b7a5d1" translate="yes" xml:space="preserve">
          <source>Incorrect prefix key; the used key part isn't a string, the used length is longer than the key part, or the storage engine doesn't support unique prefix keys</source>
          <target state="translated">잘못된 접두사 키; 사용 된 키 부분이 문자열이 아니거나 사용 된 길이가 키 부분보다 길거나 스토리지 엔진이 고유 한 접두사 키를 지원하지 않습니다</target>
        </trans-unit>
        <trans-unit id="320e7ab95f0aa600952e00ccfb28848842e2ba1c" translate="yes" xml:space="preserve">
          <source>Incorrect routine name '%s'</source>
          <target state="translated">루틴 이름 '% s'이 (가) 잘못되었습니다</target>
        </trans-unit>
        <trans-unit id="fbed000d548e667dcc54e27a681cc0d356e730a2" translate="yes" xml:space="preserve">
          <source>Incorrect table definition; all MERGE tables must be in the same database</source>
          <target state="translated">잘못된 테이블 정의; 모든 MERGE 테이블은 동일한 데이터베이스에 있어야합니다</target>
        </trans-unit>
        <trans-unit id="fe93a5deba0bded7b1cddca133d7b9b5d0b44571" translate="yes" xml:space="preserve">
          <source>Incorrect table definition; there can be only one TIMESTAMP column with CURRENT_TIMESTAMP in DEFAULT or ON UPDATE clause</source>
          <target state="translated">잘못된 테이블 정의; DEFAULT 또는 ON UPDATE 절에 CURRENT_TIMESTAMP가있는 TIMESTAMP 컬럼은 하나만있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b96d61b7e729a3465c7fb08c8b11209ce88366e" translate="yes" xml:space="preserve">
          <source>Incorrect table definition; there can be only one auto column and it must be defined as a key</source>
          <target state="translated">잘못된 테이블 정의; 하나의 자동 열만있을 수 있으며 키로 정의되어야합니다.</target>
        </trans-unit>
        <trans-unit id="0baa1daa7ef5b4dbcecb26f6e1fdecb44464a2ec" translate="yes" xml:space="preserve">
          <source>Incorrect table name '%s'</source>
          <target state="translated">테이블 이름 '% s'이 (가) 잘못되었습니다</target>
        </trans-unit>
        <trans-unit id="e30573a206f77672e607bd8bc46940d3b8915819" translate="yes" xml:space="preserve">
          <source>Incorrect usage of %s and %s</source>
          <target state="translated">% s 및 % s의 잘못된 사용법</target>
        </trans-unit>
        <trans-unit id="080c67ee29ca1a2fedc517b4af9269fb2cde9e00" translate="yes" xml:space="preserve">
          <source>Incorrect usage/placement of '%s'</source>
          <target state="translated">'% s'의 잘못된 사용법 / 배치</target>
        </trans-unit>
        <trans-unit id="06184d01a491ee930474505a97d52f1380a6d111" translate="yes" xml:space="preserve">
          <source>Incorrect value '%-.64s' for option '%-.64s'</source>
          <target state="translated">옵션 '%-. 64s'에 대해 잘못된 값 '%-. 64s'</target>
        </trans-unit>
        <trans-unit id="29d52df1b209d35ac05cc16bac9caad778df933c" translate="yes" xml:space="preserve">
          <source>Increase the output level.</source>
          <target state="translated">출력 레벨을 높이십시오.</target>
        </trans-unit>
        <trans-unit id="5a3cc602ce0582d2745cfcf06449f6040776513a" translate="yes" xml:space="preserve">
          <source>Increase this if you have many indexes in InnoDB/XtraDB tables</source>
          <target state="translated">InnoDB / XtraDB 테이블에 인덱스가 많은 경우이를 늘리십시오</target>
        </trans-unit>
        <trans-unit id="f0e39de91d3fcc956e6c9c119449852c1547ed0e" translate="yes" xml:space="preserve">
          <source>Increase this if you have many indexes in MyISAM tables</source>
          <target state="translated">MyISAM 테이블에 많은 인덱스가있는 경우이 값을 늘리십시오</target>
        </trans-unit>
        <trans-unit id="27fe78e6f9675f2eb397018b9f431ddb6ee2810a" translate="yes" xml:space="preserve">
          <source>Increase this to allow bigger multi-insert statements</source>
          <target state="translated">더 큰 다중 삽입 문을 허용하려면 이것을 늘리십시오.</target>
        </trans-unit>
        <trans-unit id="51bd0c96797c51bd663fc048529ab977b9ac0ab9" translate="yes" xml:space="preserve">
          <source>Increases the size of &lt;code&gt;ibdata1&lt;/code&gt; because the contiguous data and index pages are appended to &lt;code&gt;ibdata1&lt;/code&gt;.</source>
          <target state="translated">연속 데이터 및 색인 페이지가 &lt;code&gt;ibdata1&lt;/code&gt; 에 추가되므로 &lt;code&gt;ibdata1&lt;/code&gt; 의 크기가 증가합니다 .</target>
        </trans-unit>
        <trans-unit id="ec7ceb6dde1f90f18895b3deb9a835b57960dd74" translate="yes" xml:space="preserve">
          <source>Increasing Version Number or Tagging a Version</source>
          <target state="translated">버전 번호 증가 또는 버전 태깅</target>
        </trans-unit>
        <trans-unit id="923827eb194c9aa08f2d8692b0db0b19ef6238bb" translate="yes" xml:space="preserve">
          <source>Increasing the Length of &lt;code&gt;VARBINARY&lt;/code&gt; Columns</source>
          <target state="translated">&lt;code&gt;VARBINARY&lt;/code&gt; 열 길이 늘리기</target>
        </trans-unit>
        <trans-unit id="2db8cf05ba22ca6990b8353ac18d3627dacebee6" translate="yes" xml:space="preserve">
          <source>Increasing the Length of &lt;code&gt;VARCHAR&lt;/code&gt; Columns</source>
          <target state="translated">&lt;code&gt;VARCHAR&lt;/code&gt; 열 길이 늘리기</target>
        </trans-unit>
        <trans-unit id="ca9032ef4d9fa85973743391810656ee52c5c1bf" translate="yes" xml:space="preserve">
          <source>Increasing the Size</source>
          <target state="translated">크기 늘리기</target>
        </trans-unit>
        <trans-unit id="f769ea21cbfbe9759bcbcf4cb3f789bdc5acb7c0" translate="yes" xml:space="preserve">
          <source>Increasing the amount of I/O capacity available to InnoDB can also help increase the performance of page flushing.</source>
          <target state="translated">InnoDB에 사용 가능한 I / O 용량을 늘리면 페이지 플러시 성능을 향상시키는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a26599120bf90218e33ca079ea407f90e80b1fb8" translate="yes" xml:space="preserve">
          <source>Increasing the round from zero to 1 will allow &lt;code&gt;next_value&lt;/code&gt; to be returned.</source>
          <target state="translated">반올림을 0에서 1로 늘리면 &lt;code&gt;next_value&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="e374606c48cedadb0a7dcf3a30f860b1dcf4a855" translate="yes" xml:space="preserve">
          <source>Increasing the size of the s3 page cache: &lt;a href=&quot;../s3-storage-engine-system-variables/index#s3_pagecache_buffer_size&quot;&gt;s3_pagecache_buffer_size&lt;/a&gt;</source>
          <target state="translated">s3 페이지 캐시 크기 늘리기 : &lt;a href=&quot;../s3-storage-engine-system-variables/index#s3_pagecache_buffer_size&quot;&gt;s3_pagecache_buffer_size&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d7780027ae65a2aed1f01022082b3159d562c740" translate="yes" xml:space="preserve">
          <source>Increment to use for values. May be negative.</source>
          <target state="translated">값에 사용할 증분. 부정적 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40f90a9ffb9ef7f576f325473b4f962860bddf1d" translate="yes" xml:space="preserve">
          <source>Increment to use for values. May be negative. Setting an increment of 0 causes the sequence to use the value of the &lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#auto_increment_increment&quot;&gt;auto_increment_increment&lt;/a&gt; system variable at the time of creation, which is always a positive number. (see &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-16035&quot;&gt;MDEV-16035&lt;/a&gt;).</source>
          <target state="translated">값에 사용할 증분. 부정적 일 수 있습니다. 증분을 0으로 설정하면 시퀀스 는 생성시 &lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#auto_increment_increment&quot;&gt;auto_increment_increment&lt;/a&gt; 시스템 변수 의 값을 사용하며 , 항상 양수입니다. ( &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-16035&quot;&gt;MDEV-16035&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="8d8cd9999b903c18be1be576627b5d45c7c2e3a4" translate="yes" xml:space="preserve">
          <source>Incremental Backup and Restore with Mariabackup</source>
          <target state="translated">Mariabackup으로 증분 백업 및 복원</target>
        </trans-unit>
        <trans-unit id="9a42fd36f413621f870cdb0540428ab37f524059" translate="yes" xml:space="preserve">
          <source>Incremental Join Buffers</source>
          <target state="translated">증분 조인 버퍼</target>
        </trans-unit>
        <trans-unit id="cce204c4d59d1b85b93314b8f4fc66ccfd70ddb0" translate="yes" xml:space="preserve">
          <source>Incremental State Transfers (ISTs)</source>
          <target state="translated">증분 상태 이전 (IST)</target>
        </trans-unit>
        <trans-unit id="7ca65b353947e9df3b6a4d3f803cec6657ae0e67" translate="yes" xml:space="preserve">
          <source>Indeed, because the entire table result is memorized before the query is executed; the returned value would be limited even on a query such as:</source>
          <target state="translated">실제로, 쿼리가 실행되기 전에 전체 테이블 결과가 기억되기 때문에; 반환 된 값은 다음과 같은 쿼리에서도 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="a3cf6ede08519b4a86a40acecc25b383d5da3ed4" translate="yes" xml:space="preserve">
          <source>Indeed, if one runs EXPLAIN EXTENDED; SHOW WARNINGS, they will see that the subquery is gone and it was replaced with a join:</source>
          <target state="translated">실제로, EXPLAIN EXTENDED를 실행하면; 경고를 표시하면 하위 쿼리가 없어지고 조인으로 대체되었음을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53e3790701f23001062172c9aef31bd6196c91e1" translate="yes" xml:space="preserve">
          <source>Indeed, in SQL two last rows, even if identical, are not equal to each other:</source>
          <target state="translated">실제로 SQL에서 두 개의 마지막 행은 동일하더라도 서로 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5a21e258d3b5c776af82609cc99dae762e6b81a6" translate="yes" xml:space="preserve">
          <source>Indeed, the JVM library module is not statically linked to the CONNECT plugin. This is to make it possible to use a CONNECT plugin that has been compiled with the JDBC table type on a machine where the Java SDK is not installed. Otherwise, users not interested in the JDBC table type would be obliged to install the Java SDK on their machine to be able to load the CONNECT storage engine.</source>
          <target state="translated">실제로 JVM 라이브러리 모듈은 CONNECT 플러그인에 정적으로 링크되어 있지 않습니다. 이는 Java SDK가 설치되지 않은 시스템에서 JDBC 테이블 유형으로 컴파일 된 CONNECT 플러그인을 사용할 수있게하기위한 것입니다. 그렇지 않으면 JDBC 테이블 유형에 관심이없는 사용자는 CONNECT 스토리지 엔진을로드 할 수 있도록 시스템에 Java SDK를 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="c2df9b932637fe9d32a0f16da1c11873398f873d" translate="yes" xml:space="preserve">
          <source>Index</source>
          <target state="translated">Index</target>
        </trans-unit>
        <trans-unit id="8d072a5dda2f42149e1e38ae2b6106403c162bf9" translate="yes" xml:space="preserve">
          <source>Index %s is corrupted</source>
          <target state="translated">인덱스 % s이 (가) 손상되었습니다</target>
        </trans-unit>
        <trans-unit id="2dda08180acdb58d02727d68599e08e9ecff5be3" translate="yes" xml:space="preserve">
          <source>Index '%s' is of wrong type for an InnoDB FULLTEXT index</source>
          <target state="translated">InnoDB FULLTEXT 인덱스에 대해 인덱스 '% s'이 (가) 잘못된 유형입니다.</target>
        </trans-unit>
        <trans-unit id="cc120771b0b13368c560bf6ab343b4d1eb9d252d" translate="yes" xml:space="preserve">
          <source>Index B-tree's root page number. &lt;code&gt;-1&lt;/code&gt; (unused) for full-text indexes, as they are laid out over several auxiliary tables.</source>
          <target state="translated">인덱스 B- 트리의 루트 페이지 번호. 여러 개의 보조 테이블 위에 배치되므로 전체 텍스트 인덱스의 경우 &lt;code&gt;-1&lt;/code&gt; (사용되지 않음)입니다.</target>
        </trans-unit>
        <trans-unit id="510147dafe7f5e65cae9e90b5a0adc0ae45ca81b" translate="yes" xml:space="preserve">
          <source>Index Bytes Read</source>
          <target state="translated">인덱스 바이트 읽기</target>
        </trans-unit>
        <trans-unit id="70fbd96effb93092cfa08b12b9b28b45a7bac7c4" translate="yes" xml:space="preserve">
          <source>Index Cache Hits</source>
          <target state="translated">인덱스 캐시 적중</target>
        </trans-unit>
        <trans-unit id="641fc3059ff0e852ca3fe0c7d033a3d4fdd3ac79" translate="yes" xml:space="preserve">
          <source>Index Cache Misses</source>
          <target state="translated">인덱스 캐시 미스</target>
        </trans-unit>
        <trans-unit id="81e0313562518f07a7dba0ebecf14b8e57b5a50c" translate="yes" xml:space="preserve">
          <source>Index Cache Usage</source>
          <target state="translated">인덱스 캐시 사용법</target>
        </trans-unit>
        <trans-unit id="d58122de675b70946db52d40c41827a803aa0c85" translate="yes" xml:space="preserve">
          <source>Index Categories</source>
          <target state="translated">인덱스 카테고리</target>
        </trans-unit>
        <trans-unit id="cd5c84baaf50fd0abc29df2f3142fdf71a28df13" translate="yes" xml:space="preserve">
          <source>Index Condition Pushdown</source>
          <target state="translated">인덱스 조건 푸시 다운</target>
        </trans-unit>
        <trans-unit id="2a27e6a91afd469e148fa4a72f991aee120239e6" translate="yes" xml:space="preserve">
          <source>Index Condition Pushdown is an optimization that is applied for access methods that access table data through indexes: &lt;code&gt;range&lt;/code&gt;, &lt;code&gt;ref&lt;/code&gt;, &lt;code&gt;eq_ref&lt;/code&gt;, &lt;code&gt;ref_or_null&lt;/code&gt;, and &lt;a href=&quot;../block-based-join-algorithms/index#batch-key-access-join&quot;&gt;Batched Key Access&lt;/a&gt;.</source>
          <target state="translated">인덱스 조건 푸시 다운은 &lt;code&gt;range&lt;/code&gt; , &lt;code&gt;ref&lt;/code&gt; , &lt;code&gt;eq_ref&lt;/code&gt; , &lt;code&gt;ref_or_null&lt;/code&gt; 및 &lt;a href=&quot;../block-based-join-algorithms/index#batch-key-access-join&quot;&gt;Batched Key Access&lt;/a&gt; 와 같은 인덱스를 통해 테이블 ​​데이터에 액세스하는 액세스 방법에 적용되는 최적화입니다 .</target>
        </trans-unit>
        <trans-unit id="97a986f06671d40060d499ed98df98fabda02861" translate="yes" xml:space="preserve">
          <source>Index Condition Pushdown optimization</source>
          <target state="translated">인덱스 조건 푸시 다운 최적화</target>
        </trans-unit>
        <trans-unit id="55f2f2db03496091f9cc31d8748114f8dd499c0d" translate="yes" xml:space="preserve">
          <source>Index Condition Pushdown optimization tries to cut down the number of full record reads by checking whether index records satisfy part of the WHERE condition that can be checked for them:</source>
          <target state="translated">인덱스 조건 푸시 다운 최적화는 인덱스 레코드가 확인할 수있는 WHERE 조건의 일부를 만족하는지 확인하여 전체 레코드 읽기 수를 줄입니다.</target>
        </trans-unit>
        <trans-unit id="b51ef873dbcae569a7535cd7747459f6a169fe3e" translate="yes" xml:space="preserve">
          <source>Index Definitions</source>
          <target state="translated">인덱스 정의</target>
        </trans-unit>
        <trans-unit id="33aca4ee06423b496847aa6808c64bb32b059b5c" translate="yes" xml:space="preserve">
          <source>Index File Flushes</source>
          <target state="translated">인덱스 파일 플러시</target>
        </trans-unit>
        <trans-unit id="04e48fc7b8e700c534974052eead44baa2051e0e" translate="yes" xml:space="preserve">
          <source>Index Hint per table imposed on remote backend</source>
          <target state="translated">원격 백엔드에 부과 된 테이블 당 인덱스 힌트</target>
        </trans-unit>
        <trans-unit id="1eaa581cddc01c3726c58d7b90d70d600c40679a" translate="yes" xml:space="preserve">
          <source>Index Hints: How to Force Query Plans</source>
          <target state="translated">인덱스 힌트 : 쿼리 계획을 강제하는 방법</target>
        </trans-unit>
        <trans-unit id="539d4e0023fd87eb67d442e8c1454da4e671cfb8" translate="yes" xml:space="preserve">
          <source>Index Key Length</source>
          <target state="translated">인덱스 키 길이</target>
        </trans-unit>
        <trans-unit id="b48a835ff333dfb3ec947b86ed76b40bfce7ad77" translate="yes" xml:space="preserve">
          <source>Index Log Bytes In</source>
          <target state="translated">인덱스 로그 바이트</target>
        </trans-unit>
        <trans-unit id="896485faaea2e5e502eafdab30661377024b9167" translate="yes" xml:space="preserve">
          <source>Index Log Bytes Out</source>
          <target state="translated">인덱스 로그 바이트 아웃</target>
        </trans-unit>
        <trans-unit id="916c1bc807f73bc45af1c9c1a1011baff8dab8b2" translate="yes" xml:space="preserve">
          <source>Index Log File Syncs</source>
          <target state="translated">인덱스 로그 파일 동기화</target>
        </trans-unit>
        <trans-unit id="5140100a2a60d0bd93c3be3115e54e514b6801aa" translate="yes" xml:space="preserve">
          <source>Index Operations</source>
          <target state="translated">인덱스 작업</target>
        </trans-unit>
        <trans-unit id="fbe410e3278a057b9ae283270b4b686db0fd81d2" translate="yes" xml:space="preserve">
          <source>Index Option</source>
          <target state="translated">인덱스 옵션</target>
        </trans-unit>
        <trans-unit id="c2b4f20ce22b146e150624d9b5632871a4fb7191" translate="yes" xml:space="preserve">
          <source>Index Options</source>
          <target state="translated">인덱스 옵션</target>
        </trans-unit>
        <trans-unit id="91b13df5af3f4154cdd0632303bde2c7fc7045c1" translate="yes" xml:space="preserve">
          <source>Index Prefixes</source>
          <target state="translated">색인 접두사</target>
        </trans-unit>
        <trans-unit id="81984a6d2938b8fa3b6e7ba630c36c2c442b3499" translate="yes" xml:space="preserve">
          <source>Index Prefixes with the &lt;code&gt;COMPACT&lt;/code&gt; Row Format</source>
          <target state="translated">&lt;code&gt;COMPACT&lt;/code&gt; 행 형식 의 색인 접 두부</target>
        </trans-unit>
        <trans-unit id="b85a1da771cfe314c887bb79f13cbbb1ea9fd61f" translate="yes" xml:space="preserve">
          <source>Index Prefixes with the &lt;code&gt;COMPRESSED&lt;/code&gt; Row Format</source>
          <target state="translated">&lt;code&gt;COMPRESSED&lt;/code&gt; 행 형식 의 색인 접 두부</target>
        </trans-unit>
        <trans-unit id="389ba32b014f9c818acf790ec79c92da60decaa7" translate="yes" xml:space="preserve">
          <source>Index Prefixes with the &lt;code&gt;DYNAMIC&lt;/code&gt; Row Format</source>
          <target state="translated">&lt;code&gt;DYNAMIC&lt;/code&gt; 행 형식 의 색인 접 두부</target>
        </trans-unit>
        <trans-unit id="a7ff7f528df413a4cb0d229c01209a1d45f51073" translate="yes" xml:space="preserve">
          <source>Index Prefixes with the &lt;code&gt;REDUNDANT&lt;/code&gt; Row Format</source>
          <target state="translated">&lt;code&gt;REDUNDANT&lt;/code&gt; 행 형식 의 색인 접두사</target>
        </trans-unit>
        <trans-unit id="9ffb8982736fa020724d84af0933932b2f24f6ba" translate="yes" xml:space="preserve">
          <source>Index Scan Count</source>
          <target state="translated">인덱스 스캔 카운트</target>
        </trans-unit>
        <trans-unit id="7ebfaf4e50dd0d3b105a9fff28bb4aa1b58bb39e" translate="yes" xml:space="preserve">
          <source>Index Statistics</source>
          <target state="translated">인덱스 통계</target>
        </trans-unit>
        <trans-unit id="e6b4f06e4c0fbcdf1b9106b25aaf274d6876327c" translate="yes" xml:space="preserve">
          <source>Index Support</source>
          <target state="translated">인덱스 지원</target>
        </trans-unit>
        <trans-unit id="4e09dcdaddb1a9558501d09366dc72f53b93938b" translate="yes" xml:space="preserve">
          <source>Index Types</source>
          <target state="translated">색인 유형</target>
        </trans-unit>
        <trans-unit id="e1237e6a85dd3ed003c41f693f41b1e4c3fccefc" translate="yes" xml:space="preserve">
          <source>Index block size, in bytes.</source>
          <target state="translated">인덱스 블록 크기 (바이트)</target>
        </trans-unit>
        <trans-unit id="026ad27a783f0aac5d5692d28e8ce0dad8c0ff48" translate="yes" xml:space="preserve">
          <source>Index blocks (1KB each, BTree structured, from .MYI file) live in the &quot;key buffer&quot;.</source>
          <target state="translated">인덱스 블록 (각각 1KB, .MYI 파일로 구성된 BTree)은 &quot;키 버퍼&quot;에 있습니다.</target>
        </trans-unit>
        <trans-unit id="aec3dd813a4c08ff3b914b2fd426419525d09c29" translate="yes" xml:space="preserve">
          <source>Index cardinality (how distinct values are in the index)</source>
          <target state="translated">인덱스 카디널리티 (인덱스에 고유 한 값이있는 방법)</target>
        </trans-unit>
        <trans-unit id="8f28515bfd42cf8ac659fccc1124ea724c28e40d" translate="yes" xml:space="preserve">
          <source>Index column size too large. The maximum column size is %lu bytes.</source>
          <target state="translated">인덱스 열 크기가 너무 큽니다. 최대 열 크기는 % lu 바이트입니다.</target>
        </trans-unit>
        <trans-unit id="287602497533a553f59d972b695b2227db7f1ec4" translate="yes" xml:space="preserve">
          <source>Index columns names are listed between parenthesis. After each column, a prefix length can be specified. If no length is specified, the whole column will be indexed. &lt;code&gt;ASC&lt;/code&gt; and &lt;code&gt;DESC&lt;/code&gt; can be specified for compatibility with are DBMS's, but have no meaning in MariaDB.</source>
          <target state="translated">색인 열 이름은 괄호 안에 표시됩니다. 각 열 뒤에 접두사 길이를 지정할 수 있습니다. 길이를 지정하지 않으면 전체 열이 색인됩니다. &lt;code&gt;ASC&lt;/code&gt; 및 &lt;code&gt;DESC&lt;/code&gt; 는 DBMS와의 호환성을 위해 지정할 수 있지만 MariaDB에서는 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="408526b5c38d7acf5b6fa9787818a33a410b2404" translate="yes" xml:space="preserve">
          <source>Index comments from the &lt;code&gt;&lt;a href=&quot;../create-index/index&quot;&gt;CREATE INDEX&lt;/a&gt;&lt;/code&gt; statement.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../create-index/index&quot;&gt;CREATE INDEX&lt;/a&gt;&lt;/code&gt; 문의 색인 주석 .</target>
        </trans-unit>
        <trans-unit id="b930a2d67ebb45228a56874eb7eb0fa6206e4b96" translate="yes" xml:space="preserve">
          <source>Index corrupt: %s</source>
          <target state="translated">인덱스 손상 : % s</target>
        </trans-unit>
        <trans-unit id="6f7a368fa9fa1b35444aa51ec6717735e06b0556" translate="yes" xml:space="preserve">
          <source>Index file mapping</source>
          <target state="translated">인덱스 파일 매핑</target>
        </trans-unit>
        <trans-unit id="0b64440e38d840b89a4270f5c185a49ca4b40f99" translate="yes" xml:space="preserve">
          <source>Index hints can be specified to affect how the MariaDB optimizer makes use of indexes. For more information, see &lt;a href=&quot;../how-to-force-query-plans/index&quot;&gt;How to force query plans&lt;/a&gt;.</source>
          <target state="translated">MariaDB 옵티마이 저가 인덱스를 사용하는 방법에 영향을주기 위해 인덱스 힌트를 지정할 수 있습니다. 자세한 내용은 &lt;a href=&quot;../how-to-force-query-plans/index&quot;&gt;쿼리 계획을 적용하는 방법을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ca14da85da42db063ac833b2c7574ca4d0232ad3" translate="yes" xml:space="preserve">
          <source>Index identifier, matching the value from &lt;a href=&quot;../information-schema-innodb_sys_indexes-table/index&quot;&gt;INNODB_SYS_INDEXES.INDEX_ID&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../information-schema-innodb_sys_indexes-table/index&quot;&gt;INNODB_SYS_INDEXES.INDEX_ID&lt;/a&gt; 의 값과 일치하는 색인 ​​ID .</target>
        </trans-unit>
        <trans-unit id="27bf949a8c6bbf392cd9bbfb0a23ac87298c9ae6" translate="yes" xml:space="preserve">
          <source>Index name</source>
          <target state="translated">색인 이름</target>
        </trans-unit>
        <trans-unit id="d2d98b2bbe02189fd972518040e9baed099a4df6" translate="yes" xml:space="preserve">
          <source>Index name if a &lt;code&gt;RECORD&lt;/code&gt;&lt;code&gt;LOCK_TYPE&lt;/code&gt;, or &lt;code&gt;NULL&lt;/code&gt; if not.</source>
          <target state="translated">&lt;code&gt;RECORD&lt;/code&gt; &lt;code&gt;LOCK_TYPE&lt;/code&gt; 이면 인덱스 이름 , 그렇지 않으면 &lt;code&gt;NULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="77fd733ce2381e92b843dacdeb042bc236a8e219" translate="yes" xml:space="preserve">
          <source>Index name, lowercase for all user-created indexes, or uppercase for implicitly-created indexes; &lt;code&gt;PRIMARY&lt;/code&gt; (primary key), &lt;code&gt;GEN_CLUST_INDEX&lt;/code&gt; (index representing primary key where there isn't one), &lt;code&gt;ID_IND&lt;/code&gt;, &lt;code&gt;FOR_IND&lt;/code&gt; (validating foreign key constraint) , &lt;code&gt;REF_IND&lt;/code&gt;.</source>
          <target state="translated">색인 이름, 모든 사용자 작성 색인의 경우 소문자 또는 내재적으로 작성된 색인의 경우 대문자; &lt;code&gt;PRIMARY&lt;/code&gt; (기본 키), &lt;code&gt;GEN_CLUST_INDEX&lt;/code&gt; (하나가없는 경우 기본 키를 나타내는 지수), &lt;code&gt;ID_IND&lt;/code&gt; , &lt;code&gt;FOR_IND&lt;/code&gt; 는 , (외래 키 제약 조건의 유효성을 검사) &lt;code&gt;REF_IND&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="650440cacf90124dc3cdc68a7fa6666828abec73" translate="yes" xml:space="preserve">
          <source>Index name, or &lt;code&gt;PRIMARY&lt;/code&gt; for the primary index, &lt;code&gt;NULL&lt;/code&gt; for no index (inserts are counted in this case).</source>
          <target state="translated">인덱스 이름 또는 1 차 인덱스의 경우 &lt;code&gt;PRIMARY&lt;/code&gt; , 인덱스 가없는 경우 &lt;code&gt;NULL&lt;/code&gt; (이 경우 삽입이 계산 됨).</target>
        </trans-unit>
        <trans-unit id="6e92b7a2785e378d347a5dbba4568f754e0b3cfb" translate="yes" xml:space="preserve">
          <source>Index name.</source>
          <target state="translated">색인 이름.</target>
        </trans-unit>
        <trans-unit id="d32a18bf86c35e3d151f5ee6abc3cccc5fb56664" translate="yes" xml:space="preserve">
          <source>Index name. The primary key is always named &lt;code&gt;PRIMARY&lt;/code&gt;.</source>
          <target state="translated">색인 이름. 기본 키의 이름은 항상 &lt;code&gt;PRIMARY&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="209467d3f0ffa78aa82a14c5d7cb2c091ac88b7c" translate="yes" xml:space="preserve">
          <source>Index names are optional, if not specified an automatic name will be assigned. Index name are needed to drop indexes and appear in error messages when a constraint is violated.</source>
          <target state="translated">인덱스 이름은 선택 사항이며, 지정하지 않으면 자동 이름이 할당됩니다. 인덱스 이름은 인덱스를 삭제하는 데 필요하며 제약 조건을 위반할 때 오류 메시지에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="c2830669e39ef3f42dc816cb383e5f19ca0be374" translate="yes" xml:space="preserve">
          <source>Index number of the table's &lt;a href=&quot;auto-increment&quot;&gt;auto-increment&lt;/a&gt; column. Not shown if no auto-increment column exists.</source>
          <target state="translated">테이블의 &lt;a href=&quot;auto-increment&quot;&gt;자동 증가&lt;/a&gt; 열의 인덱스 번호입니다 . 자동 증분 열이 없으면 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="371f2fe5ab0205b0f1f63c2bdcb3a6fba2d1b303" translate="yes" xml:space="preserve">
          <source>Index number, starting with one.</source>
          <target state="translated">1부터 시작하는 색인 ​​번호.</target>
        </trans-unit>
        <trans-unit id="cd301869f443834d089f90ef115c91ccaf2e5bbc" translate="yes" xml:space="preserve">
          <source>Index number, starting with one. If not shown, the index is part of a multiple-column index.</source>
          <target state="translated">1부터 시작하는 색인 ​​번호. 표시되지 않은 경우 인덱스는 다중 열 인덱스의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="00d59527a8bd5f3fdebc8bde5a9eece672b8da36" translate="yes" xml:space="preserve">
          <source>Index of the argument that is less than the first argument</source>
          <target state="translated">첫 번째 인수보다 작은 인수의 색인</target>
        </trans-unit>
        <trans-unit id="80464b57c91edcaf54ae882823513d332acafa66" translate="yes" xml:space="preserve">
          <source>Index prefix length. 1 for the first keypart, 2 for the first two, and so on. InnoDB's extended keys are supported.</source>
          <target state="translated">인덱스 접두사 길이 첫 번째 키 파트의 경우 1, 첫 번째 키 파트의 경우 2 등. InnoDB의 확장 키가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="dbca4cf72f987b6b6bf385ec379f66e23f919805" translate="yes" xml:space="preserve">
          <source>Index size: 1024 bytes</source>
          <target state="translated">인덱스 크기 : 1024 바이트</target>
        </trans-unit>
        <trans-unit id="ee2bb56b43b8ee866cb5d1b774029aab3ca9866d" translate="yes" xml:space="preserve">
          <source>Index statistics and the query optimizer.</source>
          <target state="translated">인덱스 통계 및 쿼리 최적화 프로그램</target>
        </trans-unit>
        <trans-unit id="17b09701650f2e187a60200518da54ed9bd5c99d" translate="yes" xml:space="preserve">
          <source>Index stats for engine-independent statistics</source>
          <target state="translated">엔진 독립적 인 통계에 대한 인덱스 통계</target>
        </trans-unit>
        <trans-unit id="79850fc5992933084261d0fe65f88ab6936b706f" translate="yes" xml:space="preserve">
          <source>Index that the page belongs to, either a clustered index or a secondary index.</source>
          <target state="translated">페이지가 속한 인덱스 (클러스터형 인덱스 또는 보조 인덱스)</target>
        </trans-unit>
        <trans-unit id="60589670b1334081a0cb7a4e06660afb4414ae02" translate="yes" xml:space="preserve">
          <source>Index type</source>
          <target state="translated">인덱스 타입</target>
        </trans-unit>
        <trans-unit id="d742d73fed9fd6064346fbf84e3c191f21a777eb" translate="yes" xml:space="preserve">
          <source>Index type, one of &lt;code&gt;BTREE&lt;/code&gt;, &lt;code&gt;RTREE&lt;/code&gt;, &lt;code&gt;HASH&lt;/code&gt; or &lt;code&gt;FULLTEXT&lt;/code&gt;. See &lt;a href=&quot;../storage-engine-index-types/index&quot;&gt;Storage Engine Index Types&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;BTREE&lt;/code&gt; , &lt;code&gt;RTREE&lt;/code&gt; , &lt;code&gt;HASH&lt;/code&gt; 또는 &lt;code&gt;FULLTEXT&lt;/code&gt; 중 하나의 색인 유형 . &lt;a href=&quot;../storage-engine-index-types/index&quot;&gt;스토리지 엔진 인덱스 유형을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="37645c17d5fa7a7ddcec05e3d9b5d042b150ae13" translate="yes" xml:space="preserve">
          <source>Index type. &lt;code&gt;PRI&lt;/code&gt; for primary key, &lt;code&gt;UNI&lt;/code&gt; for unique index, &lt;code&gt;MUL&lt;/code&gt; for multiple index. A MySQL and MariaDB extension.</source>
          <target state="translated">인덱스 타입. 기본 키의 경우 &lt;code&gt;PRI&lt;/code&gt; , 고유 인덱스의 경우 &lt;code&gt;UNI&lt;/code&gt; , 여러 인덱스의 경우 &lt;code&gt;MUL&lt;/code&gt; MySQL 및 MariaDB 확장.</target>
        </trans-unit>
        <trans-unit id="ddb3cb35cb62f4eaf2401fedc1e4633fe0354362" translate="yes" xml:space="preserve">
          <source>Index usage statistics</source>
          <target state="translated">인덱스 사용 통계</target>
        </trans-unit>
        <trans-unit id="38201ff51ead5fe60e5c5810cbc1aa65192c0bf7" translate="yes" xml:space="preserve">
          <source>Index-Only Support for Various Collations</source>
          <target state="translated">다양한 데이터 정렬을위한 인덱스 전용 지원</target>
        </trans-unit>
        <trans-unit id="19e3c84a410ccfb9840c47d0c1568d43fbe4ad37" translate="yes" xml:space="preserve">
          <source>Index-Only Support for Various Datatypes</source>
          <target state="translated">다양한 데이터 유형에 대한 인덱스 전용 지원</target>
        </trans-unit>
        <trans-unit id="d04afe33a922ae69353676ab701a10dcc90f2f51" translate="yes" xml:space="preserve">
          <source>Index-only scans are currently not supported for less frequently used datatypes, like</source>
          <target state="translated">색인 전용 스캔은 현재 덜 자주 사용되는 데이터 유형에 대해 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d8030b61ab677c2316ad3dc872288ef7ea19abac" translate="yes" xml:space="preserve">
          <source>Index-only scans are supported for numeric and date/time datatypes. For CHAR and VAR[CHAR], it depends on which collation is used, see below for details.</source>
          <target state="translated">숫자 및 날짜 / 시간 데이터 유형에 대해서는 인덱스 전용 스캔이 지원됩니다. CHAR 및 VAR [CHAR]의 경우 사용되는 데이터 정렬에 따라 다릅니다. 자세한 내용은 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f18a078107189cc40ec70fd02367e0a72485bc73" translate="yes" xml:space="preserve">
          <source>Index-only scans are supported for these collations.</source>
          <target state="translated">이러한 데이터 정렬에는 인덱스 전용 스캔이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="0fb239031c3b1440dac3239e5bfeed59b1154312" translate="yes" xml:space="preserve">
          <source>IndexBytesWritten</source>
          <target state="translated">IndexBytesWritten</target>
        </trans-unit>
        <trans-unit id="2d891a34e0f716e03cdf3e9cbf6df55cb662925e" translate="yes" xml:space="preserve">
          <source>Index_length</source>
          <target state="translated">Index_length</target>
        </trans-unit>
        <trans-unit id="b5937096e49ebf8932bdb89bd0392ee4f0775814" translate="yes" xml:space="preserve">
          <source>Indexes are automatically reconstructed when the table is created, modified by INSERT, UPDATE or DELETE commands, or when the SEPINDEX option is changed. If you have a lot of changes to do on a table at one moment, you can use table locking to prevent indexes to be reconstructed after each statement. The indexes will be reconstructed when unlocking the table. For instance:</source>
          <target state="translated">INSERT, UPDATE 또는 DELETE 명령으로 테이블을 작성하거나 수정하거나 SEPINDEX 옵션을 변경하면 색인이 자동으로 재구성됩니다. 한 번에 테이블에 대해 많은 변경 사항이있는 경우 테이블 잠금을 사용하여 각 명령문 이후에 인덱스가 재구성되지 않도록 할 수 있습니다. 테이블 잠금을 해제 할 때 인덱스가 재구성됩니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="33c761766bc1b99020c7456ac60f0cbe214c1f0d" translate="yes" xml:space="preserve">
          <source>Indexes are being created through the key cache, one-by-one. Much slower than the related &lt;code&gt;Repair by sorting&lt;/code&gt;.</source>
          <target state="translated">키 캐시를 통해 하나씩 인덱스가 생성됩니다. &lt;code&gt;Repair by sorting&lt;/code&gt; 하여 관련 복구 보다 훨씬 느립니다 .</target>
        </trans-unit>
        <trans-unit id="8acae8f59fadd51d3e488bd10fdee7c95a3dbbbb" translate="yes" xml:space="preserve">
          <source>Indexes are being created with the use of a sort. Much faster than the related &lt;code&gt;Repair with keycache&lt;/code&gt;.</source>
          <target state="translated">정렬을 사용하여 색인을 작성 중입니다. &lt;code&gt;Repair with keycache&lt;/code&gt; 관련 복구 보다 훨씬 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="f49fcaf6e4690eea12931dc043bd877624f769e4" translate="yes" xml:space="preserve">
          <source>Indexes are rarely useful with MYSQL tables. This is because CONNECT tries to access only the requested rows. For instance if you ask:</source>
          <target state="translated">인덱스는 MYSQL 테이블에서 거의 유용하지 않습니다. 이는 CONNECT가 요청 된 행에만 액세스하려고하기 때문입니다. 예를 들어 다음과 같은 경우</target>
        </trans-unit>
        <trans-unit id="d4dc203411c39cad0202fd3fb06f938c9ee41ae6" translate="yes" xml:space="preserve">
          <source>Indexes can be built natively</source>
          <target state="translated">인덱스는 기본적으로 구축 가능</target>
        </trans-unit>
        <trans-unit id="ae07716f141b6c4b9c3980f368ffd78c2f0da13e" translate="yes" xml:space="preserve">
          <source>Indexes can contain more than one column. MariaDB is able to use one or more columns on the leftmost part of the index, if it cannot use the whole index.</source>
          <target state="translated">인덱스는 둘 이상의 열을 포함 할 수 있습니다. MariaDB는 전체 색인을 사용할 수없는 경우 색인의 가장 왼쪽에있는 하나 이상의 열을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d80032aef28301d3837a272e288edc057c5915f" translate="yes" xml:space="preserve">
          <source>Indexes do not necessarily need to be unique. For example:</source>
          <target state="translated">인덱스가 반드시 고유 할 필요는 없습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="18df9bebbf524039037b1f60c2be009f249b562e" translate="yes" xml:space="preserve">
          <source>Indexes per table: 31</source>
          <target state="translated">테이블 당 인덱스 : 31</target>
        </trans-unit>
        <trans-unit id="9951861c21df18489a5872209655d6f9039b5e2a" translate="yes" xml:space="preserve">
          <source>Indexing</source>
          <target state="translated">Indexing</target>
        </trans-unit>
        <trans-unit id="b5f77cdefc490a1b888e35d0768a0b60c2ee9e5d" translate="yes" xml:space="preserve">
          <source>Indexing of MYSQL tables</source>
          <target state="translated">MYSQL 테이블 인덱싱</target>
        </trans-unit>
        <trans-unit id="d585d436f5cc9a35bc94a138c034110e043fb8ac" translate="yes" xml:space="preserve">
          <source>Indexing time is a little faster if the index is smaller.</source>
          <target state="translated">색인이 작을 경우 색인 시간이 조금 더 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="80f0e0c5bd178ef42db1173b98aaabcc83c45375" translate="yes" xml:space="preserve">
          <source>Indexing with Table Partitioning</source>
          <target state="translated">테이블 파티셔닝으로 인덱싱</target>
        </trans-unit>
        <trans-unit id="caf0c9f50c5be36dbe3e095426bc2263549e07f9" translate="yes" xml:space="preserve">
          <source>Indexing with the CONNECT handler</source>
          <target state="translated">CONNECT 핸들러를 사용한 인덱싱</target>
        </trans-unit>
        <trans-unit id="967ce367d89dccc133d71049f1197d29561b3726" translate="yes" xml:space="preserve">
          <source>India</source>
          <target state="translated">India</target>
        </trans-unit>
        <trans-unit id="74ba8eb95805a9ff8cfa346367b71aaec35f6d4c" translate="yes" xml:space="preserve">
          <source>Indicate whether a geographic element is spacially within another</source>
          <target state="translated">지리적 요소가 다른 요소와 간격을두고 있는지 표시</target>
        </trans-unit>
        <trans-unit id="b142a50361a6e71ba9d207ecd955e889d8f32057" translate="yes" xml:space="preserve">
          <source>Indicate whether a geographic element is spacially within another.</source>
          <target state="translated">지리적 요소가 다른 영역 내에 있는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="685a84eb9d5780ea5810a6d8b60413c743c25686" translate="yes" xml:space="preserve">
          <source>Indicated validity of geometry value</source>
          <target state="translated">표시된 지오메트리 값의 유효성</target>
        </trans-unit>
        <trans-unit id="267b37aaf9dac14ad0a9423cb1e1b5c6dadbe688" translate="yes" xml:space="preserve">
          <source>Indicated validity of geometry value.</source>
          <target state="translated">지오메트리 값의 유효성을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="57dbf6b61cff8f6e91044ebb9a13b67eda49c0bc" translate="yes" xml:space="preserve">
          <source>Indicates how much work the current transaction can do before being swapped out, see the &lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_concurrency_tickets&quot;&gt;innodb_concurrency_tickets&lt;/a&gt;&lt;/code&gt; system variable.</source>
          <target state="translated">현재 트랜잭션이 스왑 아웃되기 전에 수행 할 수있는 작업량을 나타냅니다 . &lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_concurrency_tickets&quot;&gt;innodb_concurrency_tickets&lt;/a&gt;&lt;/code&gt; 시스템 변수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6e66561c54b558b83fd3302ff03fca1cc7132a6b" translate="yes" xml:space="preserve">
          <source>Indicates one Minimum Bounding Rectangle contains another</source>
          <target state="translated">하나의 최소 경계 사각형에 다른 최소 경계 사각형이 있음을 나타냅니다</target>
        </trans-unit>
        <trans-unit id="0bab1dfc32b95fbae58876218204c8a6cc5be680" translate="yes" xml:space="preserve">
          <source>Indicates one Minimum Bounding Rectangle contains another.</source>
          <target state="translated">하나의 최소 경계 사각형에 다른 최소 경계 사각형이 포함되어 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="16b77c5c2366513fb564131d2fcd771a079eb0cc" translate="yes" xml:space="preserve">
          <source>Indicates the max number of multiple items. It is used to internally calculate the max size of the table and defaults to 10. (To be specified in &lt;code&gt;OPTION_LIST&lt;/code&gt;).</source>
          <target state="translated">여러 항목의 최대 수를 나타냅니다. 내부적으로 테이블의 최대 크기를 계산하는 데 사용되며 기본값은 10입니다 ( &lt;code&gt;OPTION_LIST&lt;/code&gt; 에 지정 ).</target>
        </trans-unit>
        <trans-unit id="d0f1677d380b001ef0dd695635043222a295521b" translate="yes" xml:space="preserve">
          <source>Indicates the operation type, for example &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;UPDATE&lt;/code&gt;.</source>
          <target state="translated">조작 유형을 나타냅니다 (예 : &lt;code&gt;INSERT&lt;/code&gt; 또는 &lt;code&gt;UPDATE&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="40becd1a44c6abc66f9ccf81ce4c4dc54b8713bb" translate="yes" xml:space="preserve">
          <source>Indicates the order that the action will be performed in (of the list of a table's triggers with identical &lt;code&gt;EVENT_MANIPULATION&lt;/code&gt; and &lt;code&gt;ACTION_TIMING&lt;/code&gt; values). Before &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1023-release-notes/&quot;&gt;MariaDB 10.2.3&lt;/a&gt; introduced the &lt;a href=&quot;../create-trigger/index#followsprecedes-other_trigger_name&quot;&gt;FOLLOWS and PRECEDES clauses&lt;/a&gt;, always &lt;code&gt;0&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;EVENT_MANIPULATION&lt;/code&gt; 및 &lt;code&gt;ACTION_TIMING&lt;/code&gt; 값 이 동일한 테이블 트리거 목록에서 작업이 수행되는 순서를 나타냅니다 . &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1023-release-notes/&quot;&gt;MariaDB 10.2.3&lt;/a&gt; 이 &lt;a href=&quot;../create-trigger/index#followsprecedes-other_trigger_name&quot;&gt;FOLLOWS 및 PRECEDES 절을&lt;/a&gt; 도입 하기 전에 항상 &lt;code&gt;0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8a0a945688dfd6bfbddbb6ec426525f89e4dd356" translate="yes" xml:space="preserve">
          <source>Indicates whether one Minimum Bounding Rectangle is within another</source>
          <target state="translated">하나의 최소 경계 사각형이 다른 경계 안에 있는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2fe5f5b142f9b04e602feb40d7502cae65a965fe" translate="yes" xml:space="preserve">
          <source>Indicates whether the Minimum Bounding Rectangles of the two geometries intersect</source>
          <target state="translated">두 도형의 최소 경계 사각형이 교차하는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="430a2f8c54cd44600d5c5a183f6a7ab5aa7207f4" translate="yes" xml:space="preserve">
          <source>Indicates whether the Minimum Bounding Rectangles of the two geometries intersect.</source>
          <target state="translated">두 도형의 최소 경계 사각형이 교차하는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="13b5a1db96e0706cec6a8528eef504e685db1fdf" translate="yes" xml:space="preserve">
          <source>Indicates whether the Minimum Bounding Rectangles of two geometries are disjoint</source>
          <target state="translated">두 도형의 최소 경계 사각형이 분리되어 있는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="530297ad9c00f73f5dc2b10473c752034e669d07" translate="yes" xml:space="preserve">
          <source>Indicates whether the Minimum Bounding Rectangles of two geometries are disjoint.</source>
          <target state="translated">두 도형의 최소 경계 사각형이 분리되어 있는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f501b511892aad352dd12ead8473a0ee97408d7a" translate="yes" xml:space="preserve">
          <source>Indicates whether the column value is &lt;a href=&quot;../virtual-computed-columns/index&quot;&gt;generated (virtual, or computed)&lt;/a&gt;. Can be &lt;code&gt;ALWAYS&lt;/code&gt; or &lt;code&gt;NEVER&lt;/code&gt;.</source>
          <target state="translated">열 값의 &lt;a href=&quot;../virtual-computed-columns/index&quot;&gt;생성&lt;/a&gt; 여부 (가상 또는 계산)를 나타냅니다 . &lt;code&gt;ALWAYS&lt;/code&gt; 또는 &lt;code&gt;NEVER&lt;/code&gt; 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fc75f8e4e1fcd4c0680058786c9103dfaa03a108" translate="yes" xml:space="preserve">
          <source>Indicates whether the given JSON document contains data at the specified path or paths</source>
          <target state="translated">지정된 JSON 문서에 지정된 경로의 데이터가 있는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="40b6b3a61aa43482ca64d555c77d56f68b09e182" translate="yes" xml:space="preserve">
          <source>Indicates whether the given JSON document contains data at the specified path or paths.</source>
          <target state="translated">지정된 JSON 문서에 지정된 경로의 데이터가 있는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5f018152f43724cd7de64cd20597ddf5598b0de5" translate="yes" xml:space="preserve">
          <source>Indicates whether the given JSON document contains data at the specified path or paths. Returns &lt;code&gt;1&lt;/code&gt; if it does, &lt;code&gt;0&lt;/code&gt; if not and NULL if any of the arguments are null.</source>
          <target state="translated">지정된 JSON 문서에 지정된 경로의 데이터가 있는지 여부를 나타냅니다. 존재하면 &lt;code&gt;1&lt;/code&gt; 을 리턴 하고, 그렇지 않으면 &lt;code&gt;0&lt;/code&gt; 을 리턴 하고 인수가 널 (NULL)이면 NULL을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="ddc85d598debc68e78956417b0d5607c54aa80dd" translate="yes" xml:space="preserve">
          <source>Indicates whether the given value is a valid JSON document or not. Returns &lt;code&gt;1&lt;/code&gt; if valid, &lt;code&gt;0&lt;/code&gt; if not, and NULL if the argument is NULL.</source>
          <target state="translated">주어진 값이 유효한 JSON 문서인지 여부를 나타냅니다. 반환 &lt;code&gt;1&lt;/code&gt; 경우, 유효한 &lt;code&gt;0&lt;/code&gt; 인수가 NULL의 경우 그렇지 않은 경우와 NULL.</target>
        </trans-unit>
        <trans-unit id="6c073379746ed18e350a2be0df4597342ca1162b" translate="yes" xml:space="preserve">
          <source>Indicates whether two elements spatially overlap</source>
          <target state="translated">두 요소가 공간적으로 겹치는 지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="528ff77ef1fe8942db21caa59bf226c4f741325b" translate="yes" xml:space="preserve">
          <source>Indicates whether two elements spatially overlap.</source>
          <target state="translated">두 요소가 공간적으로 겹치는 지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5da3264f2b61c25c5b53eeaf9888603e31d9e26e" translate="yes" xml:space="preserve">
          <source>Indicates whether two geometries are spatially equal</source>
          <target state="translated">두 도형이 공간적으로 동일한 지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e669fbd393003bd11c6bed782a41c44d74cc580e" translate="yes" xml:space="preserve">
          <source>Indicates whether two geometries are spatially equal.</source>
          <target state="translated">두 도형이 공간적으로 동일한 지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="68f0803fafa73c679205ee209f42444c25eb5fb7" translate="yes" xml:space="preserve">
          <source>Indicates whether two geometries spatially intersect</source>
          <target state="translated">두 도형이 공간적으로 교차하는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="36210a208ffefb73d51e7643dbec08adb2a5a82f" translate="yes" xml:space="preserve">
          <source>Indicates whether two geometries spatially intersect.</source>
          <target state="translated">두 도형이 공간적으로 교차하는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a252513d851f0174c6667dad10bcd8e8fcc5b474" translate="yes" xml:space="preserve">
          <source>Individual SELECTs can contain their own &lt;a href=&quot;../order-by/index&quot;&gt;ORDER BY&lt;/a&gt; and &lt;a href=&quot;../limit/index&quot;&gt;LIMIT&lt;/a&gt; clauses. In this case, the individual queries need to be wrapped between parentheses. However, this does not affect the order of the UNION, so they only are useful to limit the record read by one SELECT.</source>
          <target state="translated">개별 SELECT는 고유 한 &lt;a href=&quot;../order-by/index&quot;&gt;ORDER BY&lt;/a&gt; 및 &lt;a href=&quot;../limit/index&quot;&gt;LIMIT&lt;/a&gt; 절을 포함 할 수 있습니다 . 이 경우 개별 쿼리를 괄호로 묶어야합니다. 그러나 이것은 UNION의 순서에 영향을 미치지 않으므로 하나의 SELECT로 읽는 레코드를 제한하는 데만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="8c72cb3f02bb2ff49a3b676c8e9ac27d7de29ce5" translate="yes" xml:space="preserve">
          <source>Individual SELECTs cannot be written &lt;a href=&quot;../select-into-dumpfile/index&quot;&gt;INTO DUMPFILE&lt;/a&gt; or &lt;a href=&quot;../select-into-outfile/index&quot;&gt;INTO OUTFILE&lt;/a&gt;. If the last SELECT statement specifies INTO DUMPFILE or INTO OUTFILE, the entire result of the UNION will be written. Placing the clause after any other SELECT will result in a syntax error.</source>
          <target state="translated">개별 SELECT는 &lt;a href=&quot;../select-into-dumpfile/index&quot;&gt;INTO DUMPFILE&lt;/a&gt; 또는 &lt;a href=&quot;../select-into-outfile/index&quot;&gt;INTO OUTFILE에&lt;/a&gt; 쓸 수 없습니다 . 마지막 SELECT 문이 INTO DUMPFILE 또는 INTO OUTFILE을 지정하면 UNION의 전체 결과가 기록됩니다. 다른 SELECT 뒤에 절을 배치하면 구문 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="35536a41b209715d9e3ad440431fef2672f20bbe" translate="yes" xml:space="preserve">
          <source>Indonesia</source>
          <target state="translated">Indonesia</target>
        </trans-unit>
        <trans-unit id="2339b8ad3625abec50c5fec9ccfe1b4c0adb5b6e" translate="yes" xml:space="preserve">
          <source>Indonesian</source>
          <target state="translated">Indonesian</target>
        </trans-unit>
        <trans-unit id="53126f434ce50141e74d8147b60efe4052d304ed" translate="yes" xml:space="preserve">
          <source>InfiniDB Migration to ColumnStore</source>
          <target state="translated">InfiniDB를 ColumnStore로 마이그레이션</target>
        </trans-unit>
        <trans-unit id="2b0e9d705c8fce6b415ff02752c28d8172f7f0ef" translate="yes" xml:space="preserve">
          <source>Inflating the BIT_COUNT</source>
          <target state="translated">BIT_COUNT 팽창</target>
        </trans-unit>
        <trans-unit id="4b631f69842530d659306c8f06dbad594a6b1807" translate="yes" xml:space="preserve">
          <source>Info</source>
          <target state="translated">Info</target>
        </trans-unit>
        <trans-unit id="3fc5f170cd53e006d9c37d2e2667dd8d716661b2" translate="yes" xml:space="preserve">
          <source>Info Type</source>
          <target state="translated">정보 유형</target>
        </trans-unit>
        <trans-unit id="729995d8da68c2d294f2736a45b4a130227d8efa" translate="yes" xml:space="preserve">
          <source>Info will have logs showing high level actions that are going on in the system. During a stop/startsystem, it will show the high level commands of the process/modules being stopped and started. The bulk-load (cpimport) tool logs is high level actions there also.</source>
          <target state="translated">정보에는 시스템에서 진행중인 높은 수준의 작업을 보여주는 로그가 있습니다. 중지 / 시작 시스템 중에는 중지 / 시작된 프로세스 / 모듈의 고급 명령이 표시됩니다. 벌크로드 (cpimport) 도구 로그도 여기에서 높은 수준의 작업입니다.</target>
        </trans-unit>
        <trans-unit id="0eb5ed506e4923c28d7f4a8aa69efe99b3ad75d1" translate="yes" xml:space="preserve">
          <source>Information</source>
          <target state="translated">Information</target>
        </trans-unit>
        <trans-unit id="c2a7d9412999e1bd050d1ef02e4289c7fc87a52c" translate="yes" xml:space="preserve">
          <source>Information Functions</source>
          <target state="translated">정보 기능</target>
        </trans-unit>
        <trans-unit id="c16c4802416ae69a705e704fe1fecbfd80949808" translate="yes" xml:space="preserve">
          <source>Information Schema</source>
          <target state="translated">정보 스키마</target>
        </trans-unit>
        <trans-unit id="c1dbec3e6ae32609b8cdb34052dd1c3ff7d1e8de" translate="yes" xml:space="preserve">
          <source>Information Schema ALL_PLUGINS Table</source>
          <target state="translated">정보 스키마 ALL_PLUGINS 테이블</target>
        </trans-unit>
        <trans-unit id="33d33286513fabff7fee189c1910ec43ee87ae12" translate="yes" xml:space="preserve">
          <source>Information Schema APPLICABLE_ROLES Table</source>
          <target state="translated">정보 스키마 APPLICABLE_ROLES 테이블</target>
        </trans-unit>
        <trans-unit id="4dee3bee30ed2a32da1e606327cd9896a00df3a8" translate="yes" xml:space="preserve">
          <source>Information Schema CHANGED_PAGE_BITMAPS Table</source>
          <target state="translated">정보 스키마 CHANGED_PAGE_BITMAPS 테이블</target>
        </trans-unit>
        <trans-unit id="c7cac9990a7985860f05013751b2dc7bbeb89347" translate="yes" xml:space="preserve">
          <source>Information Schema CHARACTER_SETS Table</source>
          <target state="translated">정보 스키마 CHARACTER_SETS 테이블</target>
        </trans-unit>
        <trans-unit id="7bfff5db194cd112d75350fa934cd97cb7671ed0" translate="yes" xml:space="preserve">
          <source>Information Schema CHECK_CONSTRAINTS Table</source>
          <target state="translated">정보 스키마 CHECK_CONSTRAINTS 테이블</target>
        </trans-unit>
        <trans-unit id="0bc64f4b9e14c88aa52e3cccc05aa39ae603701a" translate="yes" xml:space="preserve">
          <source>Information Schema CLIENT_STATISTICS Table</source>
          <target state="translated">정보 스키마 CLIENT_STATISTICS 테이블</target>
        </trans-unit>
        <trans-unit id="489684d62e529987ea3c228bd72a8902e756b022" translate="yes" xml:space="preserve">
          <source>Information Schema COLLATIONS Table</source>
          <target state="translated">정보 스키마 컬렉션 테이블</target>
        </trans-unit>
        <trans-unit id="b5d4e168c0943b35e1f653b86937bc61e9202de2" translate="yes" xml:space="preserve">
          <source>Information Schema COLLATION_CHARACTER_SET_APPLICABILITY Table</source>
          <target state="translated">정보 스키마 COLLATION_CHARACTER_SET_APPLICABILITY 테이블</target>
        </trans-unit>
        <trans-unit id="1afede79a10697978918d447b1e8b60f5bdeb0e1" translate="yes" xml:space="preserve">
          <source>Information Schema COLUMNS Table</source>
          <target state="translated">정보 스키마 COLUMNS 테이블</target>
        </trans-unit>
        <trans-unit id="bd0144e73394d3924908d33eafc87ee40c9ae672" translate="yes" xml:space="preserve">
          <source>Information Schema COLUMN_PRIVILEGES Table</source>
          <target state="translated">정보 스키마 COLUMN_PRIVILEGES 테이블</target>
        </trans-unit>
        <trans-unit id="e7a0790188afb0e4d8c213984b74726fa3bc263a" translate="yes" xml:space="preserve">
          <source>Information Schema DISKS Table</source>
          <target state="translated">정보 스키마 DISKS 테이블</target>
        </trans-unit>
        <trans-unit id="7c39e22d41b7349065522a2469f1c6b37d41249d" translate="yes" xml:space="preserve">
          <source>Information Schema ENABLED_ROLES Table</source>
          <target state="translated">정보 스키마 ENABLED_ROLES 테이블</target>
        </trans-unit>
        <trans-unit id="cffe76b1d1fef96bd93ca2e425a40b58fed74803" translate="yes" xml:space="preserve">
          <source>Information Schema ENGINES Table</source>
          <target state="translated">정보 스키마 엔진 테이블</target>
        </trans-unit>
        <trans-unit id="21ca4b1f54a51fb1cd13a5a19c4168d7b4cdd0b0" translate="yes" xml:space="preserve">
          <source>Information Schema EVENTS Table</source>
          <target state="translated">정보 스키마 이벤트 테이블</target>
        </trans-unit>
        <trans-unit id="0a6c56159e45f01a0592b83ea694428278ee5cc0" translate="yes" xml:space="preserve">
          <source>Information Schema FEEDBACK Table</source>
          <target state="translated">정보 스키마 FEEDBACK 테이블</target>
        </trans-unit>
        <trans-unit id="eef6e73993e5c488e8dadeefcbe8ebf8d40a34b4" translate="yes" xml:space="preserve">
          <source>Information Schema FILES Table</source>
          <target state="translated">정보 스키마 FILES 테이블</target>
        </trans-unit>
        <trans-unit id="e41916f863f767095cee56b06eff6e42ac437467" translate="yes" xml:space="preserve">
          <source>Information Schema GEOMETRY_COLUMNS Table</source>
          <target state="translated">정보 스키마 GEOMETRY_COLUMNS 테이블</target>
        </trans-unit>
        <trans-unit id="c741a9f4f1f6891ce0deab19221eb600eccec025" translate="yes" xml:space="preserve">
          <source>Information Schema GLOBAL_STATUS and SESSION_STATUS Tables</source>
          <target state="translated">정보 스키마 GLOBAL_STATUS 및 SESSION_STATUS 테이블</target>
        </trans-unit>
        <trans-unit id="9e257c7bf8168cf59b896fed798f28f3329cd6d5" translate="yes" xml:space="preserve">
          <source>Information Schema GLOBAL_VARIABLES and SESSION_VARIABLES Tables</source>
          <target state="translated">정보 스키마 GLOBAL_VARIABLES 및 SESSION_VARIABLES 테이블</target>
        </trans-unit>
        <trans-unit id="c98ec5c7fd5fe54ee8a5c993f12efd24a835d5a5" translate="yes" xml:space="preserve">
          <source>Information Schema INDEX_STATISTICS Table</source>
          <target state="translated">정보 스키마 INDEX_STATISTICS 테이블</target>
        </trans-unit>
        <trans-unit id="934aa4abe308910a05ffb1daddd1d8a63745a217" translate="yes" xml:space="preserve">
          <source>Information Schema INNODB_BUFFER_PAGE Table</source>
          <target state="translated">정보 스키마 INNODB_BUFFER_PAGE 테이블</target>
        </trans-unit>
        <trans-unit id="bd5b1c57de2b5c05a1a160f692b96b4e094331d2" translate="yes" xml:space="preserve">
          <source>Information Schema INNODB_BUFFER_PAGE_LRU Table</source>
          <target state="translated">정보 스키마 INNODB_BUFFER_PAGE_LRU 테이블</target>
        </trans-unit>
        <trans-unit id="83aede4dcff89864379e84babfbfae0b364507b1" translate="yes" xml:space="preserve">
          <source>Information Schema INNODB_BUFFER_POOL_PAGES Table</source>
          <target state="translated">정보 스키마 INNODB_BUFFER_POOL_PAGES 테이블</target>
        </trans-unit>
        <trans-unit id="395dc6c0384be928f77478d2bbd4dc0bb8902cba" translate="yes" xml:space="preserve">
          <source>Information Schema INNODB_BUFFER_POOL_PAGES_BLOB Table</source>
          <target state="translated">정보 스키마 INNODB_BUFFER_POOL_PAGES_BLOB 테이블</target>
        </trans-unit>
        <trans-unit id="179a40730a4fee2eddab2dc018f1e276b2e7a25c" translate="yes" xml:space="preserve">
          <source>Information Schema INNODB_BUFFER_POOL_PAGES_INDEX Table</source>
          <target state="translated">정보 스키마 INNODB_BUFFER_POOL_PAGES_INDEX 테이블</target>
        </trans-unit>
        <trans-unit id="cfc78d930a083f181fa2aa5860e4762827a2f922" translate="yes" xml:space="preserve">
          <source>Information Schema INNODB_BUFFER_POOL_STATS Table</source>
          <target state="translated">정보 스키마 INNODB_BUFFER_POOL_STATS 테이블</target>
        </trans-unit>
        <trans-unit id="e52df159a23ddde054d7855c781ac339bf7718c3" translate="yes" xml:space="preserve">
          <source>Information Schema INNODB_CHANGED_PAGES Table</source>
          <target state="translated">정보 스키마 INNODB_CHANGED_PAGES 테이블</target>
        </trans-unit>
        <trans-unit id="ab5c475dbf9752a93ffc0bc00640b757a241eb2d" translate="yes" xml:space="preserve">
          <source>Information Schema INNODB_CMP and INNODB_CMP_RESET Tables</source>
          <target state="translated">정보 스키마 INNODB_CMP 및 INNODB_CMP_RESET 테이블</target>
        </trans-unit>
        <trans-unit id="b36a4b261287e6c2eef52188fe9c7c9899266e3c" translate="yes" xml:space="preserve">
          <source>Information Schema INNODB_CMPMEM and INNODB_CMPMEM_RESET Tables</source>
          <target state="translated">정보 스키마 INNODB_CMPMEM 및 INNODB_CMPMEM_RESET 테이블</target>
        </trans-unit>
        <trans-unit id="014a9de0f926974330f134998c5d796e6ffff71f" translate="yes" xml:space="preserve">
          <source>Information Schema INNODB_CMP_PER_INDEX and INNODB_CMP_PER_INDEX_RESET Tables</source>
          <target state="translated">정보 스키마 INNODB_CMP_PER_INDEX 및 INNODB_CMP_PER_INDEX_RESET 테이블</target>
        </trans-unit>
        <trans-unit id="b80a83f410bd388a5617bc3339ea8d8a8bde9660" translate="yes" xml:space="preserve">
          <source>Information Schema INNODB_FT_BEING_DELETED Table</source>
          <target state="translated">정보 스키마 INNODB_FT_BEING_DELETED 테이블</target>
        </trans-unit>
        <trans-unit id="5fbfca9124105230bb64f4615de86ec7d6009f86" translate="yes" xml:space="preserve">
          <source>Information Schema INNODB_FT_CONFIG Table</source>
          <target state="translated">정보 스키마 INNODB_FT_CONFIG 테이블</target>
        </trans-unit>
        <trans-unit id="c82e370839c78eb8115bfee2d098572956f1bbd6" translate="yes" xml:space="preserve">
          <source>Information Schema INNODB_FT_DEFAULT_STOPWORD Table</source>
          <target state="translated">정보 스키마 INNODB_FT_DEFAULT_STOPWORD 테이블</target>
        </trans-unit>
        <trans-unit id="c3a5e45e4d817d2a71dcdf0b8e7fd524a6131f0f" translate="yes" xml:space="preserve">
          <source>Information Schema INNODB_FT_DELETED Table</source>
          <target state="translated">정보 스키마 INNODB_FT_DELETED 테이블</target>
        </trans-unit>
        <trans-unit id="031f7de99dff2829033ab29206a257a41207295e" translate="yes" xml:space="preserve">
          <source>Information Schema INNODB_FT_INDEX_CACHE Table</source>
          <target state="translated">정보 스키마 INNODB_FT_INDEX_CACHE 테이블</target>
        </trans-unit>
        <trans-unit id="d96eccd57023655a651ac967c177a020c9e8067c" translate="yes" xml:space="preserve">
          <source>Information Schema INNODB_FT_INDEX_TABLE Table</source>
          <target state="translated">정보 스키마 INNODB_FT_INDEX_TABLE 테이블</target>
        </trans-unit>
        <trans-unit id="dc68c132832da3aa9572d344e7a790e6f5dd7429" translate="yes" xml:space="preserve">
          <source>Information Schema INNODB_LOCKS Table</source>
          <target state="translated">정보 스키마 INNODB_LOCKS 테이블</target>
        </trans-unit>
        <trans-unit id="6377aa637554eb1f0a8cb375d570686bec9dbc03" translate="yes" xml:space="preserve">
          <source>Information Schema INNODB_LOCK_WAITS Table</source>
          <target state="translated">정보 스키마 INNODB_LOCK_WAITS 테이블</target>
        </trans-unit>
        <trans-unit id="8ca3f6777de100695d886f233586f75c777918bb" translate="yes" xml:space="preserve">
          <source>Information Schema INNODB_METRICS Table</source>
          <target state="translated">정보 스키마 INNODB_METRICS 테이블</target>
        </trans-unit>
        <trans-unit id="fe0470e6cc0bd385ffe4e225c70f4157a0e3e6e5" translate="yes" xml:space="preserve">
          <source>Information Schema INNODB_MUTEXES Table</source>
          <target state="translated">정보 스키마 INNODB_MUTEXES 테이블</target>
        </trans-unit>
        <trans-unit id="c0b5195583baae29883afc11c4670aec32f515d8" translate="yes" xml:space="preserve">
          <source>Information Schema INNODB_SYS_COLUMNS Table</source>
          <target state="translated">정보 스키마 INNODB_SYS_COLUMNS 테이블</target>
        </trans-unit>
        <trans-unit id="32f4c1f9273eb5a5dc04f8c9d0e0c409655c8652" translate="yes" xml:space="preserve">
          <source>Information Schema INNODB_SYS_DATAFILES Table</source>
          <target state="translated">정보 스키마 INNODB_SYS_DATAFILES 테이블</target>
        </trans-unit>
        <trans-unit id="7fafa7d5836830314eb14f50f7bf3a004f1fb2b8" translate="yes" xml:space="preserve">
          <source>Information Schema INNODB_SYS_FIELDS Table</source>
          <target state="translated">정보 스키마 INNODB_SYS_FIELDS 테이블</target>
        </trans-unit>
        <trans-unit id="fa6b47e55c9b64da4e47fe2c2b4868f761897848" translate="yes" xml:space="preserve">
          <source>Information Schema INNODB_SYS_FOREIGN Table</source>
          <target state="translated">정보 스키마 INNODB_SYS_FOREIGN 테이블</target>
        </trans-unit>
        <trans-unit id="b2010cc9200bc81d2de3f4456390943018e8804a" translate="yes" xml:space="preserve">
          <source>Information Schema INNODB_SYS_FOREIGN_COLS Table</source>
          <target state="translated">정보 스키마 INNODB_SYS_FOREIGN_COLS 테이블</target>
        </trans-unit>
        <trans-unit id="12c3238e5716a2adc6738ea40fb0766e667ebd89" translate="yes" xml:space="preserve">
          <source>Information Schema INNODB_SYS_INDEXES Table</source>
          <target state="translated">정보 스키마 INNODB_SYS_INDEXES 테이블</target>
        </trans-unit>
        <trans-unit id="f5aa77e4448b0ae57b601a289d682cb1bdd4fbf8" translate="yes" xml:space="preserve">
          <source>Information Schema INNODB_SYS_SEMAPHORE_WAITS Table</source>
          <target state="translated">정보 스키마 INNODB_SYS_SEMAPHORE_WAITS 테이블</target>
        </trans-unit>
        <trans-unit id="073b2c1ed50015eaa426d97fdc47a2f7112fa5d6" translate="yes" xml:space="preserve">
          <source>Information Schema INNODB_SYS_TABLES Table</source>
          <target state="translated">정보 스키마 INNODB_SYS_TABLES 테이블</target>
        </trans-unit>
        <trans-unit id="c920327c5483ae07f668e50744312248be603fdc" translate="yes" xml:space="preserve">
          <source>Information Schema INNODB_SYS_TABLESPACES Table</source>
          <target state="translated">정보 스키마 INNODB_SYS_TABLESPACES 테이블</target>
        </trans-unit>
        <trans-unit id="23b701bd990e29f59917601a9c67f62a42b4e6f0" translate="yes" xml:space="preserve">
          <source>Information Schema INNODB_SYS_TABLESTATS Table</source>
          <target state="translated">정보 스키마 INNODB_SYS_TABLESTATS 테이블</target>
        </trans-unit>
        <trans-unit id="7f87056443034664f93eb55d9aeea01082383c29" translate="yes" xml:space="preserve">
          <source>Information Schema INNODB_TABLESPACES_ENCRYPTION Table</source>
          <target state="translated">정보 스키마 INNODB_TABLESPACES_ENCRYPTION 테이블</target>
        </trans-unit>
        <trans-unit id="9771187ff5772a0d4a11a8dd6f1ebd87a6b6d120" translate="yes" xml:space="preserve">
          <source>Information Schema INNODB_TABLESPACES_ENCRYPTION table</source>
          <target state="translated">정보 스키마 INNODB_TABLESPACES_ENCRYPTION 테이블</target>
        </trans-unit>
        <trans-unit id="f40d1109ba1dc79215422f0b1b38444d5b1199f8" translate="yes" xml:space="preserve">
          <source>Information Schema INNODB_TABLESPACES_SCRUBBING Table</source>
          <target state="translated">정보 스키마 INNODB_TABLESPACES_SCRUBBING 테이블</target>
        </trans-unit>
        <trans-unit id="bd23c12b37578782e3e0be2b6f059e420a2cba91" translate="yes" xml:space="preserve">
          <source>Information Schema INNODB_TRX Table</source>
          <target state="translated">정보 스키마 INNODB_TRX 테이블</target>
        </trans-unit>
        <trans-unit id="6292d7d290407f6751c4ee2dff4b4346cbb97b3d" translate="yes" xml:space="preserve">
          <source>Information Schema INNODB_UNDO_LOGS Table</source>
          <target state="translated">정보 스키마 INNODB_UNDO_LOGS 테이블</target>
        </trans-unit>
        <trans-unit id="22ed6e52e1ac155c780f4ca81274d973b657a5e6" translate="yes" xml:space="preserve">
          <source>Information Schema InnoDB Tables</source>
          <target state="translated">정보 스키마 InnoDB 테이블</target>
        </trans-unit>
        <trans-unit id="4a75dd891f16b658990a3657bb3fd5434e808122" translate="yes" xml:space="preserve">
          <source>Information Schema KEY_CACHES Table</source>
          <target state="translated">정보 스키마 KEY_CACHES 테이블</target>
        </trans-unit>
        <trans-unit id="b4f810ce90e1359c7b765c21434710e2a18b489e" translate="yes" xml:space="preserve">
          <source>Information Schema KEY_COLUMN_USAGE Table</source>
          <target state="translated">정보 스키마 KEY_COLUMN_USAGE 테이블</target>
        </trans-unit>
        <trans-unit id="62ec2e42554b74738d6ab68cd73a6fc1809ce0d9" translate="yes" xml:space="preserve">
          <source>Information Schema LOCALES Table</source>
          <target state="translated">정보 스키마 LOCALES 테이블</target>
        </trans-unit>
        <trans-unit id="97eaa0a3979dbe71537b4534d9b35f0db4d60fa4" translate="yes" xml:space="preserve">
          <source>Information Schema METADATA_LOCK_INFO Table</source>
          <target state="translated">정보 스키마 METADATA_LOCK_INFO 테이블</target>
        </trans-unit>
        <trans-unit id="394a2f0c33e1d04dd495b8fe57f1ceff82bfbab0" translate="yes" xml:space="preserve">
          <source>Information Schema MROONGA_STATS Table</source>
          <target state="translated">정보 스키마 MROONGA_STATS 테이블</target>
        </trans-unit>
        <trans-unit id="7d53e3b140ae68033f5aa37703f58a1c4801f720" translate="yes" xml:space="preserve">
          <source>Information Schema MyRocks Tables</source>
          <target state="translated">정보 스키마 MyRocks 테이블</target>
        </trans-unit>
        <trans-unit id="c96fae9eb607f70d4a248f6ade75415a2eaad13c" translate="yes" xml:space="preserve">
          <source>Information Schema OPTIMIZER_TRACE Table</source>
          <target state="translated">정보 스키마 OPTIMIZER_TRACE 테이블</target>
        </trans-unit>
        <trans-unit id="54394ef4387d3dfbc639a10ec603f2692ae6560a" translate="yes" xml:space="preserve">
          <source>Information Schema PARAMETERS Table</source>
          <target state="translated">정보 스키마 매개 변수 표</target>
        </trans-unit>
        <trans-unit id="80cb61c360f5e3bdae6ca55cf41df9b225ade12e" translate="yes" xml:space="preserve">
          <source>Information Schema PARTITIONS Table</source>
          <target state="translated">정보 스키마 PARTITIONS 테이블</target>
        </trans-unit>
        <trans-unit id="d3238b8ee6d2722efaa385dcdb046c88dccd1ea1" translate="yes" xml:space="preserve">
          <source>Information Schema PROCESSLIST Table</source>
          <target state="translated">정보 스키마 PROCESSLIST 테이블</target>
        </trans-unit>
        <trans-unit id="cb78ecca470264734b0f768ae890b263ca07bbfc" translate="yes" xml:space="preserve">
          <source>Information Schema PROFILING Table</source>
          <target state="translated">정보 스키마 프로파일 링 테이블</target>
        </trans-unit>
        <trans-unit id="b23c0a64bf93fa3881dd5e3bdf3f987290131ad4" translate="yes" xml:space="preserve">
          <source>Information Schema Plugin - &lt;code&gt;DISKS&lt;/code&gt;</source>
          <target state="translated">정보 스키마 플러그인 &lt;code&gt;DISKS&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8660cfb3653f0f8f6c4cc63c3fdf24a985b1dec7" translate="yes" xml:space="preserve">
          <source>Information Schema Plugin - &lt;code&gt;LOCALES&lt;/code&gt;</source>
          <target state="translated">정보 스키마 플러그인 &lt;code&gt;LOCALES&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fa3b11125ef0e18af64565d9b2c9b1e66a2520bf" translate="yes" xml:space="preserve">
          <source>Information Schema Plugin - &lt;code&gt;METADATA_LOCK_INFO&lt;/code&gt;</source>
          <target state="translated">정보 스키마 플러그인 &lt;code&gt;METADATA_LOCK_INFO&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a98f25229329aba399f0b827f160d5a330b040b4" translate="yes" xml:space="preserve">
          <source>Information Schema Plugin - &lt;code&gt;QUERY_CACHE_INFO&lt;/code&gt;</source>
          <target state="translated">정보 스키마 플러그인 &lt;code&gt;QUERY_CACHE_INFO&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d5019ffe5ed19184fd373821034914f3fb2cdabe" translate="yes" xml:space="preserve">
          <source>Information Schema Plugin - &lt;code&gt;QUERY_RESPONSE_TIME&lt;/code&gt;</source>
          <target state="translated">정보 스키마 플러그인 &lt;code&gt;QUERY_RESPONSE_TIME&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a18ff1cd9930b85a1ee9dad08953c2d5b2a17335" translate="yes" xml:space="preserve">
          <source>Information Schema Plugin - &lt;code&gt;WSREP_MEMBERSHIP&lt;/code&gt;</source>
          <target state="translated">정보 스키마 플러그인 &lt;code&gt;WSREP_MEMBERSHIP&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5f24cb2a78df59981c808ebe398169ba2be2fff9" translate="yes" xml:space="preserve">
          <source>Information Schema Plugin - &lt;code&gt;WSREP_STATUS&lt;/code&gt;</source>
          <target state="translated">정보 스키마 플러그인 &lt;code&gt;WSREP_STATUS&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="af8e0885b4ec6ef8c0fc3c175e1f1b8e905c018e" translate="yes" xml:space="preserve">
          <source>Information Schema Plugin - &lt;code&gt;feedback&lt;/code&gt;</source>
          <target state="translated">정보 스키마 플러그인- &lt;code&gt;feedback&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e91c5facf8c5bbe1e8035a6053106aefa800fc54" translate="yes" xml:space="preserve">
          <source>Information Schema Plugin - &lt;code&gt;user_variables&lt;/code&gt;</source>
          <target state="translated">정보 스키마 플러그인 &lt;code&gt;user_variables&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9de3108c24ac94c240faffa2e29a7e8d9ae2ca11" translate="yes" xml:space="preserve">
          <source>Information Schema Plugins - Options and System Variables</source>
          <target state="translated">정보 스키마 플러그인-옵션 및 시스템 변수</target>
        </trans-unit>
        <trans-unit id="a4344ac0876463bb14aee7d630f4676cc71dd838" translate="yes" xml:space="preserve">
          <source>Information Schema Plugins Table</source>
          <target state="translated">정보 스키마 플러그인 테이블</target>
        </trans-unit>
        <trans-unit id="944f67c48524eb6996b657292ad9b9622d571288" translate="yes" xml:space="preserve">
          <source>Information Schema QUERY_CACHE_INFO Table</source>
          <target state="translated">정보 스키마 QUERY_CACHE_INFO 테이블</target>
        </trans-unit>
        <trans-unit id="bc8dbb4f415cb976430daa838377e0862c0dc462" translate="yes" xml:space="preserve">
          <source>Information Schema QUERY_CACHE_QUERIES Table</source>
          <target state="translated">정보 스키마 QUERY_CACHE_QUERIES 테이블</target>
        </trans-unit>
        <trans-unit id="f3cffc07cd2b5bcebdd073460abeaeec7cf1068a" translate="yes" xml:space="preserve">
          <source>Information Schema QUERY_CACHE_QUERIES_TABLES Table</source>
          <target state="translated">정보 스키마 QUERY_CACHE_QUERIES_TABLES 테이블</target>
        </trans-unit>
        <trans-unit id="f77b642f6b9b4b212bf582b3de1fbd3365e2b70c" translate="yes" xml:space="preserve">
          <source>Information Schema QUERY_CACHE_TABLES Table</source>
          <target state="translated">정보 스키마 QUERY_CACHE_TABLES 테이블</target>
        </trans-unit>
        <trans-unit id="a5d95729721ba97267a0b0daca89a834906b7919" translate="yes" xml:space="preserve">
          <source>Information Schema QUERY_RESPONSE_TIME Table</source>
          <target state="translated">정보 스키마 QUERY_RESPONSE_TIME 테이블</target>
        </trans-unit>
        <trans-unit id="a619057626543e93aac2b36257c203d85e1e1fc9" translate="yes" xml:space="preserve">
          <source>Information Schema REFERENTIAL_CONSTRAINTS Table</source>
          <target state="translated">정보 스키마 REFERENTIAL_CONSTRAINTS 테이블</target>
        </trans-unit>
        <trans-unit id="b1b3c5c58fb6d31f2ce0a5d1937b205cfd0c4c90" translate="yes" xml:space="preserve">
          <source>Information Schema ROCKSDB_CFSTATS Table</source>
          <target state="translated">정보 스키마 ROCKSDB_CFSTATS 테이블</target>
        </trans-unit>
        <trans-unit id="3a9ca9142393b8907f0dad15b9a4ffb4ff4e2ca2" translate="yes" xml:space="preserve">
          <source>Information Schema ROCKSDB_CF_OPTIONS Table</source>
          <target state="translated">정보 스키마 ROCKSDB_CF_OPTIONS 테이블</target>
        </trans-unit>
        <trans-unit id="5e0b6452301e9c138a84176ed6c6fb8dfdb1ee58" translate="yes" xml:space="preserve">
          <source>Information Schema ROCKSDB_COMPACTION_STATS Table</source>
          <target state="translated">정보 스키마 ROCKSDB_COMPACTION_STATS 테이블</target>
        </trans-unit>
        <trans-unit id="d0283e100133d9fefad57fed4bc953f7cab34091" translate="yes" xml:space="preserve">
          <source>Information Schema ROCKSDB_DBSTATS Table</source>
          <target state="translated">정보 스키마 ROCKSDB_DBSTATS 테이블</target>
        </trans-unit>
        <trans-unit id="68fce87bca1a982c51f95fdbdd095b6df481da03" translate="yes" xml:space="preserve">
          <source>Information Schema ROCKSDB_DDL Table</source>
          <target state="translated">정보 스키마 ROCKSDB_DDL 테이블</target>
        </trans-unit>
        <trans-unit id="3e29b05baa9bb7fa5e8ad66e798de3100482f05f" translate="yes" xml:space="preserve">
          <source>Information Schema ROCKSDB_DEADLOCK Table</source>
          <target state="translated">정보 스키마 ROCKSDB_DEADLOCK 테이블</target>
        </trans-unit>
        <trans-unit id="c610531ce2d25c1a017e012169311275a8ad8b85" translate="yes" xml:space="preserve">
          <source>Information Schema ROCKSDB_GLOBAL_INFO Table</source>
          <target state="translated">정보 스키마 ROCKSDB_GLOBAL_INFO 테이블</target>
        </trans-unit>
        <trans-unit id="2cea4ad884363eaba7c47181204f02a8990c05ef" translate="yes" xml:space="preserve">
          <source>Information Schema ROCKSDB_INDEX_FILE_MAP Table</source>
          <target state="translated">정보 스키마 ROCKSDB_INDEX_FILE_MAP 테이블</target>
        </trans-unit>
        <trans-unit id="06bef2a52580d3d7e9c014df33a2199e3e872283" translate="yes" xml:space="preserve">
          <source>Information Schema ROCKSDB_LOCKS Table</source>
          <target state="translated">정보 스키마 ROCKSDB_LOCKS 테이블</target>
        </trans-unit>
        <trans-unit id="da5430fe0325e1db7aa534679d341e1397c4ec8d" translate="yes" xml:space="preserve">
          <source>Information Schema ROCKSDB_PERF_CONTEXT Table</source>
          <target state="translated">정보 스키마 ROCKSDB_PERF_CONTEXT 테이블</target>
        </trans-unit>
        <trans-unit id="8726f76da891e48641a97e6967ab778c4bf0f046" translate="yes" xml:space="preserve">
          <source>Information Schema ROCKSDB_PERF_CONTEXT_GLOBAL Table</source>
          <target state="translated">정보 스키마 ROCKSDB_PERF_CONTEXT_GLOBAL 테이블</target>
        </trans-unit>
        <trans-unit id="eef3072ca3f5eabe97655672e45ce5574f59f582" translate="yes" xml:space="preserve">
          <source>Information Schema ROCKSDB_SST_PROPS Table</source>
          <target state="translated">정보 스키마 ROCKSDB_SST_PROPS 테이블</target>
        </trans-unit>
        <trans-unit id="e837b85c1f61d84d013556b8d42b58269de0b2a1" translate="yes" xml:space="preserve">
          <source>Information Schema ROCKSDB_TRX Table</source>
          <target state="translated">정보 스키마 ROCKSDB_TRX 테이블</target>
        </trans-unit>
        <trans-unit id="9ecacde82b5f0f22c58cc6c0d38591a97c84bdff" translate="yes" xml:space="preserve">
          <source>Information Schema ROUTINES Table</source>
          <target state="translated">정보 스키마 ROUTINES 테이블</target>
        </trans-unit>
        <trans-unit id="0ff5181a65313cd328e14520807328482fcec2f9" translate="yes" xml:space="preserve">
          <source>Information Schema SCHEMATA Table</source>
          <target state="translated">정보 스키마 SCHEMATA 테이블</target>
        </trans-unit>
        <trans-unit id="53b0a0ea5b6005d5df2f14d4e54dbd29e35f67ac" translate="yes" xml:space="preserve">
          <source>Information Schema SCHEMA_PRIVILEGES Table</source>
          <target state="translated">정보 스키마 SCHEMA_PRIVILEGES 테이블</target>
        </trans-unit>
        <trans-unit id="8639a75b51674c260f2db3bffbbfa5aef5ee6656" translate="yes" xml:space="preserve">
          <source>Information Schema SPATIAL_REF_SYS Table</source>
          <target state="translated">정보 스키마 SPATIAL_REF_SYS 테이블</target>
        </trans-unit>
        <trans-unit id="fa905dfb22aa5e17db15c6484f6b879ae16312b6" translate="yes" xml:space="preserve">
          <source>Information Schema SPIDER_ALLOC_MEM Table</source>
          <target state="translated">정보 스키마 SPIDER_ALLOC_MEM 테이블</target>
        </trans-unit>
        <trans-unit id="940fd9b2946a55748d1c3464ccd298c7b7e38766" translate="yes" xml:space="preserve">
          <source>Information Schema STATISTICS Table</source>
          <target state="translated">정보 스키마 통계 테이블</target>
        </trans-unit>
        <trans-unit id="63662c1763f2a0225e5d01f7e0c0d77647ea977d" translate="yes" xml:space="preserve">
          <source>Information Schema SYSTEM_VARIABLES Table</source>
          <target state="translated">정보 스키마 SYSTEM_VARIABLES 테이블</target>
        </trans-unit>
        <trans-unit id="36ecff0820e0c083c80583598d96ae9b95b35de2" translate="yes" xml:space="preserve">
          <source>Information Schema TABLES Table</source>
          <target state="translated">정보 스키마 테이블 테이블</target>
        </trans-unit>
        <trans-unit id="b27a1486747aa63c43514155af349a758e014773" translate="yes" xml:space="preserve">
          <source>Information Schema TABLESPACES Table</source>
          <target state="translated">정보 스키마 TABLESPACES 테이블</target>
        </trans-unit>
        <trans-unit id="82b800d3faff7d5ae00b3e6ad2e15daf1df44156" translate="yes" xml:space="preserve">
          <source>Information Schema TABLE_CONSTRAINTS Table</source>
          <target state="translated">정보 스키마 TABLE_CONSTRAINTS 테이블</target>
        </trans-unit>
        <trans-unit id="da74839d23d035facf97a2d33a68815943ecebe1" translate="yes" xml:space="preserve">
          <source>Information Schema TABLE_PRIVILEGES Table</source>
          <target state="translated">정보 스키마 TABLE_PRIVILEGES 테이블</target>
        </trans-unit>
        <trans-unit id="9a48d111f9bb6fa0d2bc5984a6899b4e4087bbca" translate="yes" xml:space="preserve">
          <source>Information Schema TABLE_STATISTICS Table</source>
          <target state="translated">정보 스키마 TABLE_STATISTICS 테이블</target>
        </trans-unit>
        <trans-unit id="842f65a3c891b04bdc268c750711a0e3f4946170" translate="yes" xml:space="preserve">
          <source>Information Schema TEMP_TABLES_INFO Table</source>
          <target state="translated">정보 스키마 TEMP_TABLES_INFO 테이블</target>
        </trans-unit>
        <trans-unit id="dd66e818d637befc4cd7cf44b349dd8e119d650d" translate="yes" xml:space="preserve">
          <source>Information Schema THREADPOOL_GROUPS Table</source>
          <target state="translated">정보 스키마 THREADPOOL_GROUPS 테이블</target>
        </trans-unit>
        <trans-unit id="7a5c3f2ecd294f490deb69ba40cf417d80c3feae" translate="yes" xml:space="preserve">
          <source>Information Schema THREADPOOL_GROUPS Table.</source>
          <target state="translated">정보 스키마 THREADPOOL_GROUPS 테이블.</target>
        </trans-unit>
        <trans-unit id="cc55bca67a25f86c654ebce9d1eb5cb82a9afc57" translate="yes" xml:space="preserve">
          <source>Information Schema THREADPOOL_QUEUES Table</source>
          <target state="translated">정보 스키마 THREADPOOL_QUEUES 테이블</target>
        </trans-unit>
        <trans-unit id="2fcdbbb9c890f848096be7e052cf5cb71c6d4180" translate="yes" xml:space="preserve">
          <source>Information Schema THREADPOOL_QUEUES Table.</source>
          <target state="translated">정보 스키마 THREADPOOL_QUEUES 테이블.</target>
        </trans-unit>
        <trans-unit id="b2754b2d41332fa0bb38586917968b4b389b8836" translate="yes" xml:space="preserve">
          <source>Information Schema THREADPOOL_STATS Table</source>
          <target state="translated">정보 스키마 THREADPOOL_STATS 테이블</target>
        </trans-unit>
        <trans-unit id="c6d8fcd7cdcad51c6741145eff2f1cbd47f27007" translate="yes" xml:space="preserve">
          <source>Information Schema THREADPOOL_STATS Table.</source>
          <target state="translated">정보 스키마 THREADPOOL_STATS 테이블.</target>
        </trans-unit>
        <trans-unit id="173174c5e1430aec739cddc7f721d331cdfc3405" translate="yes" xml:space="preserve">
          <source>Information Schema TRIGGERS Table</source>
          <target state="translated">정보 스키마 TRIGGERS 테이블</target>
        </trans-unit>
        <trans-unit id="57d1095816b05bb3d6155dba13961223a69b7430" translate="yes" xml:space="preserve">
          <source>Information Schema Tables</source>
          <target state="translated">정보 스키마 테이블</target>
        </trans-unit>
        <trans-unit id="15e2c2478c1d453c16f7cfa7e26f01c8f6c85023" translate="yes" xml:space="preserve">
          <source>Information Schema USER_PRIVILEGES Table</source>
          <target state="translated">정보 스키마 USER_PRIVILEGES 테이블</target>
        </trans-unit>
        <trans-unit id="aaabae9b2e6d5bd6b7519694b45051ff8e381ab1" translate="yes" xml:space="preserve">
          <source>Information Schema USER_STATISTICS Table</source>
          <target state="translated">정보 스키마 USER_STATISTICS 테이블</target>
        </trans-unit>
        <trans-unit id="f8eb4238fd703e33f43f16178b12750c415b0371" translate="yes" xml:space="preserve">
          <source>Information Schema USER_VARIABLES Table</source>
          <target state="translated">정보 스키마 USER_VARIABLES 테이블</target>
        </trans-unit>
        <trans-unit id="1cb79b89b0d273db37721782870b7e4f638b256f" translate="yes" xml:space="preserve">
          <source>Information Schema VIEWS Table</source>
          <target state="translated">정보 스키마 VIEWS 테이블</target>
        </trans-unit>
        <trans-unit id="f1493b49ae50c66667a14e971e2ade55f9f2f25d" translate="yes" xml:space="preserve">
          <source>Information Schema WSREP_MEMBERSHIP Table</source>
          <target state="translated">정보 스키마 WSREP_MEMBERSHIP 테이블</target>
        </trans-unit>
        <trans-unit id="697598c167e5a627d11ed1673129d80a3ad9e0e6" translate="yes" xml:space="preserve">
          <source>Information Schema WSREP_STATUS Table</source>
          <target state="translated">정보 스키마 WSREP_STATUS 테이블</target>
        </trans-unit>
        <trans-unit id="6382db721362d0fd6eba5ad5ddab029d9bc636cb" translate="yes" xml:space="preserve">
          <source>Information Schema XTRADB_INTERNAL_HASH_TABLES Table</source>
          <target state="translated">정보 스키마 XTRADB_INTERNAL_HASH_TABLES 테이블</target>
        </trans-unit>
        <trans-unit id="114b66cbc45eb086ad6e3cd039f039db8b812943" translate="yes" xml:space="preserve">
          <source>Information Schema XTRADB_READ_VIEW Table</source>
          <target state="translated">정보 스키마 XTRADB_READ_VIEW 테이블</target>
        </trans-unit>
        <trans-unit id="72747241fcd468f0ded0d58db4d033d2311b23d6" translate="yes" xml:space="preserve">
          <source>Information Schema XTRADB_RSEG Table</source>
          <target state="translated">정보 스키마 XTRADB_RSEG 테이블</target>
        </trans-unit>
        <trans-unit id="45a1fedaaec490b72dbf42242ebf98e14fb62def" translate="yes" xml:space="preserve">
          <source>Information Schema XtraDB Tables</source>
          <target state="translated">정보 스키마 XtraDB 테이블</target>
        </trans-unit>
        <trans-unit id="277de15014a0e749bf79260d116f82f52dbb2c67" translate="yes" xml:space="preserve">
          <source>Information Schema table containing information on plugins installed on a server.</source>
          <target state="translated">서버에 설치된 플러그인에 대한 정보가 포함 된 정보 스키마 테이블.</target>
        </trans-unit>
        <trans-unit id="33d647c6056fb1cf22b782c1e9e3b26d58a4628a" translate="yes" xml:space="preserve">
          <source>Information about &lt;a href=&quot;https://mariadb.org/monitoring-progress-and-temporal-memory-usage-of-online-ddl-in-innodb/&quot;&gt;progress of InnoDB online DDL&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://mariadb.org/monitoring-progress-and-temporal-memory-usage-of-online-ddl-in-innodb/&quot;&gt;InnoDB 온라인 DDL의 진행에&lt;/a&gt; 관한 정보 .</target>
        </trans-unit>
        <trans-unit id="667db567d0a16c198ddf6ae66a0227d742a83f68" translate="yes" xml:space="preserve">
          <source>Information about MariaDB events</source>
          <target state="translated">MariaDB 이벤트에 대한 정보</target>
        </trans-unit>
        <trans-unit id="1f45d9df7e670f34685f242e038d316c930c73c4" translate="yes" xml:space="preserve">
          <source>Information about MyRocks Column Families.</source>
          <target state="translated">MyRocks 컬럼 패밀리에 대한 정보.</target>
        </trans-unit>
        <trans-unit id="280be869bfcf3ecbbf89e1246b90dc6fd0da77d3" translate="yes" xml:space="preserve">
          <source>Information about Spider's memory usage.</source>
          <target state="translated">스파이더의 메모리 사용량에 대한 정보.</target>
        </trans-unit>
        <trans-unit id="a91cc12cf5e6638f5c124b10092349a14df26f8a" translate="yes" xml:space="preserve">
          <source>Information about a master's &lt;a href=&quot;../replication-threads/index#binary-log-dump-thread&quot;&gt;binary log dump thread&lt;/a&gt;.</source>
          <target state="translated">석사에 대한 정보 &lt;a href=&quot;../replication-threads/index#binary-log-dump-thread&quot;&gt;바이너리 로그 덤프 스레드&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1a9b0a0de776eaa6bc489aae1c09a72cab174c1b" translate="yes" xml:space="preserve">
          <source>Information about a range of parititions for a given column can be retrieved using the &lt;em&gt;calShowPartitionsByValue&lt;/em&gt; stored procedure. This procedure takes either four or five mandatory parameters: [&lt;em&gt;database_name&lt;/em&gt;], &lt;em&gt;table_name&lt;/em&gt;, &lt;em&gt;column_name&lt;/em&gt;, &lt;em&gt;start_value&lt;/em&gt;, and &lt;em&gt;end_value&lt;/em&gt;. If four parameters are provided the current database is assumed. Only casual partition column types (&lt;a href=&quot;../int/index&quot;&gt;INTEGER&lt;/a&gt;, &lt;a href=&quot;../decimal/index&quot;&gt;DECIMAL&lt;/a&gt;, &lt;a href=&quot;../date/index&quot;&gt;DATE&lt;/a&gt;, &lt;a href=&quot;../datetime/index&quot;&gt;DATETIME&lt;/a&gt;, &lt;a href=&quot;../char/index&quot;&gt;CHAR&lt;/a&gt; up to 8 bytes and &lt;a href=&quot;../varchar/index&quot;&gt;VARCHAR&lt;/a&gt; up to 7 bytes) are supported for this function.</source>
          <target state="translated">&lt;em&gt;calShowPartitionsByValue&lt;/em&gt; 저장 프로 시저를 사용하여 지정된 열에 대한 여러 가지 범위에 대한 정보를 검색 할 수 있습니다 . 이 프로시 저는 네 개 또는 다섯 개의 필수 매개 변수 ([ &lt;em&gt;database_name&lt;/em&gt; ], &lt;em&gt;table_name&lt;/em&gt; , &lt;em&gt;column_name&lt;/em&gt; , &lt;em&gt;start_value&lt;/em&gt; 및 &lt;em&gt;end_value)를 사용&lt;/em&gt; 합니다. 네 개의 매개 변수가 제공되면 현재 데이터베이스가 가정됩니다. 이 함수에는 일반 파티션 열 유형 ( &lt;a href=&quot;../int/index&quot;&gt;INTEGER&lt;/a&gt; , &lt;a href=&quot;../decimal/index&quot;&gt;DECIMAL&lt;/a&gt; , &lt;a href=&quot;../date/index&quot;&gt;DATE&lt;/a&gt; , &lt;a href=&quot;../datetime/index&quot;&gt;DATETIME&lt;/a&gt; , &lt;a href=&quot;../char/index&quot;&gt;CHAR&lt;/a&gt; 최대 8 바이트 및 &lt;a href=&quot;../varchar/index&quot;&gt;VARCHAR&lt;/a&gt; 최대 7 바이트) 만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="23e618e56b11b443761f6932931ce0b3635fcbdd" translate="yes" xml:space="preserve">
          <source>Information about active InnoDB temporary tables.</source>
          <target state="translated">활성 InnoDB 임시 테이블에 대한 정보.</target>
        </trans-unit>
        <trans-unit id="cabe16cd15c6bb881ecf0660b71bddf299afdbf3" translate="yes" xml:space="preserve">
          <source>Information about active tablespaces</source>
          <target state="translated">활성 테이블 스페이스에 대한 정보</target>
        </trans-unit>
        <trans-unit id="2899d8329306dbc610892b8b1e5878ef936ce563" translate="yes" xml:space="preserve">
          <source>Information about all available plugins, installed or not</source>
          <target state="translated">사용 가능한 모든 플러그인에 대한 정보 (설치 여부)</target>
        </trans-unit>
        <trans-unit id="c18a04c318864eaf9500396ee2deef895de7b3db" translate="yes" xml:space="preserve">
          <source>Information about all partitions for a given column can be retrieved using the &lt;em&gt;calShowPartitions&lt;/em&gt; stored procedure which takes either two or three mandatory parameters: [&lt;em&gt;database_name&lt;/em&gt;], &lt;em&gt;table_name&lt;/em&gt;, and &lt;em&gt;column_name&lt;/em&gt;. If two parameters are provided the current database is assumed. For example:</source>
          <target state="translated">주어진 열에 대한 모든 파티션에 대한 정보는 &lt;em&gt;calShowPartitions&lt;/em&gt; 저장 프로 시저를 사용하여 검색 할 수 있습니다.이 프로시 저는 [ &lt;em&gt;database_name&lt;/em&gt; ], &lt;em&gt;table_name&lt;/em&gt; 및 &lt;em&gt;column_name의&lt;/em&gt; 필수 매개 변수 인 2 개 또는 3 개의 필수 매개 변수를 사용 합니다. 두 개의 매개 변수가 제공되면 현재 데이터베이스가 가정됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="07abe3b663d59a5fe8a2197992ee3c1409515c84" translate="yes" xml:space="preserve">
          <source>Information about columns in a table.</source>
          <target state="translated">테이블의 열에 대한 정보.</target>
        </trans-unit>
        <trans-unit id="2f142f6fa97dab761e056ef3e7776d237bee9407" translate="yes" xml:space="preserve">
          <source>Information about current semaphore waits.</source>
          <target state="translated">현재 세마포어에 대한 정보가 대기합니다.</target>
        </trans-unit>
        <trans-unit id="7e7a2d36d19c8fe5a2cb40926aebbed89e3fbbca" translate="yes" xml:space="preserve">
          <source>Information about databases</source>
          <target state="translated">데이터베이스에 대한 정보</target>
        </trans-unit>
        <trans-unit id="29cdc89e6fea91177f159621626628e68add511d" translate="yes" xml:space="preserve">
          <source>Information about initializing plugins.</source>
          <target state="translated">플러그인 초기화에 대한 정보.</target>
        </trans-unit>
        <trans-unit id="32336eb8776a177ab36756a6c4200fe293af1e36" translate="yes" xml:space="preserve">
          <source>Information about old-style language options.</source>
          <target state="translated">구식 언어 옵션에 대한 정보.</target>
        </trans-unit>
        <trans-unit id="66136bf8da26e74f88220b5554914c056dab5f15" translate="yes" xml:space="preserve">
          <source>Information about roles and who they've been granted to can be found in the &lt;a href=&quot;../information-schema-applicable_roles-table/index&quot;&gt;Information Schema APPLICABLE_ROLES table&lt;/a&gt; as well as the &lt;a href=&quot;../mysqlroles_mapping-table/index&quot;&gt;mysql.ROLES_MAPPING table&lt;/a&gt;.</source>
          <target state="translated">역할 및 부여 된 역할에 대한 &lt;a href=&quot;../information-schema-applicable_roles-table/index&quot;&gt;정보&lt;/a&gt; 는 &lt;a href=&quot;../mysqlroles_mapping-table/index&quot;&gt;mysql.ROLES_MAPPING 테이블&lt;/a&gt; 뿐만 아니라 Information Schema APPLICABLE_ROLES 테이블 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="928631531b6d2082f1a9d9f2126944c453cbecca" translate="yes" xml:space="preserve">
          <source>Information about server plugins, whether installed or not.</source>
          <target state="translated">설치 여부에 관계없이 서버 플러그인에 대한 정보.</target>
        </trans-unit>
        <trans-unit id="5d744a4c4815a0c65d44e1c2c9dc335505893fc5" translate="yes" xml:space="preserve">
          <source>Information about stored procedures and stored functions parameters</source>
          <target state="translated">저장 프로 시저 및 저장 함수 매개 변수에 대한 정보</target>
        </trans-unit>
        <trans-unit id="c6ed7ae8425a5d426dae56f82a915d84494c1ce0" translate="yes" xml:space="preserve">
          <source>Information about stored routines.</source>
          <target state="translated">저장 루틴에 대한 정보.</target>
        </trans-unit>
        <trans-unit id="54be910566b764fa251dc853575187e164c3757d" translate="yes" xml:space="preserve">
          <source>Information about table fields.</source>
          <target state="translated">테이블 필드에 대한 정보</target>
        </trans-unit>
        <trans-unit id="0a3fcfb94aa1b2ddfe7831e23ff587e56e99f028" translate="yes" xml:space="preserve">
          <source>Information about table indexes</source>
          <target state="translated">테이블 인덱스에 대한 정보</target>
        </trans-unit>
        <trans-unit id="0b730998c4fe49ec596886fe7ec9773c9766c1cf" translate="yes" xml:space="preserve">
          <source>Information about the Aria storage engine. From &lt;a href=&quot;../what-is-mariadb-104/index&quot;&gt;MariaDB 10.4&lt;/a&gt;, &lt;a href=&quot;../system-tables/index&quot;&gt;system tables&lt;/a&gt; use the Aria storage engine.</source>
          <target state="translated">Aria 스토리지 엔진에 대한 정보 에서 &lt;a href=&quot;../what-is-mariadb-104/index&quot;&gt;MariaDB 10.4&lt;/a&gt; , &lt;a href=&quot;../system-tables/index&quot;&gt;시스템 테이블은&lt;/a&gt; 아리아 스토리지 엔진을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ac43dbb88d3d34611e5bc81ce06c552b8bb29f23" translate="yes" xml:space="preserve">
          <source>Information about the FederatedX Storage Engine</source>
          <target state="translated">FederatedX 스토리지 엔진에 대한 정보</target>
        </trans-unit>
        <trans-unit id="a64b68d78e92fe64153707bc9ce5b1f88a5ba6ba" translate="yes" xml:space="preserve">
          <source>Information about the oldest active transaction in the system.</source>
          <target state="translated">시스템에서 가장 오래된 활성 트랜잭션에 대한 정보.</target>
        </trans-unit>
        <trans-unit id="bd9eafb874d0d9cadd25ceedc4d1b833492379a9" translate="yes" xml:space="preserve">
          <source>Information about the people who work on MariaDB.</source>
          <target state="translated">MariaDB에서 일하는 사람들에 대한 정보.</target>
        </trans-unit>
        <trans-unit id="9dc6d666585605922723e180f372692659e90bca" translate="yes" xml:space="preserve">
          <source>Information about this key:</source>
          <target state="translated">이 키에 대한 정보 :</target>
        </trans-unit>
        <trans-unit id="2e58246bfce37299926241efc2057b35d42414cc" translate="yes" xml:space="preserve">
          <source>Information about triggers</source>
          <target state="translated">트리거에 대한 정보</target>
        </trans-unit>
        <trans-unit id="1ec970b80d1d29b66737a2e7b354510aff6cbd4a" translate="yes" xml:space="preserve">
          <source>Information about views</source>
          <target state="translated">조회수에 대한 정보</target>
        </trans-unit>
        <trans-unit id="f735b9598c01120ff4bb58349c3475f77654379e" translate="yes" xml:space="preserve">
          <source>Information and instructions on using the RPM packages and the related repositories.</source>
          <target state="translated">RPM 패키지 및 관련 리포지토리 사용에 대한 정보 및 지침</target>
        </trans-unit>
        <trans-unit id="cd63fa23a9993594c123c0846168a556836caed3" translate="yes" xml:space="preserve">
          <source>Information from this statement can be used to diagnose system problems. For example, large values of spin_waits and spin_rounds may indicate scalability problems.</source>
          <target state="translated">이 설명의 정보는 시스템 문제를 진단하는 데 사용될 수 있습니다. 예를 들어, spin_waits 및 spin_rounds 값이 크면 확장 성 문제가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6533e5dc7d560a44753f878d69e0a56e8e33f9e" translate="yes" xml:space="preserve">
          <source>Information from this table is similar to that found in the &lt;code&gt;param_list&lt;/code&gt; column in the &lt;a href=&quot;../mysqlproc-table/index&quot;&gt;mysql.proc&lt;/a&gt; table, and the output of the &lt;code&gt;&lt;a href=&quot;../show-create-procedure/index&quot;&gt;SHOW CREATE PROCEDURE&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../show-create-function/index&quot;&gt;SHOW CREATE FUNCTION&lt;/a&gt;&lt;/code&gt; statements.</source>
          <target state="translated">이 테이블의 정보 는 &lt;a href=&quot;../mysqlproc-table/index&quot;&gt;mysql.proc&lt;/a&gt; 테이블 의 &lt;code&gt;param_list&lt;/code&gt; 열에있는 정보 와 &lt;code&gt;&lt;a href=&quot;../show-create-procedure/index&quot;&gt;SHOW CREATE PROCEDURE&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../show-create-function/index&quot;&gt;SHOW CREATE FUNCTION&lt;/a&gt;&lt;/code&gt; 문의 출력과 유사 합니다.</target>
        </trans-unit>
        <trans-unit id="903f3637e6441138591fc993961ac08e72454a4a" translate="yes" xml:space="preserve">
          <source>Information on MariaDB's Software Deprecation Policy and Schedule.</source>
          <target state="translated">MariaDB의 소프트웨어 사용 중단 정책 및 일정에 대한 정보.</target>
        </trans-unit>
        <trans-unit id="89675560ce90af86f28cb14cd86cf2cdba1d3852" translate="yes" xml:space="preserve">
          <source>Information on Plugins</source>
          <target state="translated">플러그인 정보</target>
        </trans-unit>
        <trans-unit id="e30846753eaf0f002b95530aa4ea3edd6e2e8bf2" translate="yes" xml:space="preserve">
          <source>Information on configuring replication between MariaDB Galera Cluster and MariaDB Server.</source>
          <target state="translated">MariaDB Galera Cluster와 MariaDB Server 간의 복제 구성에 대한 정보입니다.</target>
        </trans-unit>
        <trans-unit id="89316a25055a61ea8a4cfb8584ec24094ad2d75f" translate="yes" xml:space="preserve">
          <source>Information on configuring replication between two MariaDB Galera Clusters.</source>
          <target state="translated">두 MariaDB Galera 클러스터 간의 복제 구성에 대한 정보.</target>
        </trans-unit>
        <trans-unit id="c2cb254f34866f01d79776b45d7adc5db039d07e" translate="yes" xml:space="preserve">
          <source>Information on each spatial reference system used in the database</source>
          <target state="translated">데이터베이스에서 사용되는 각 공간 참조 시스템에 대한 정보</target>
        </trans-unit>
        <trans-unit id="23e599802db2728ffd84a08b9f2f8a41eb901fc5" translate="yes" xml:space="preserve">
          <source>Information on how to prepare the &lt;em&gt;Columnstore.xml&lt;/em&gt; configuration file can be found &lt;a href=&quot;../library/columnstore-bulk-write-sdk/index#environment-configuration&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;Columnstore.xml&lt;/em&gt; 구성 파일 을 준비하는 방법에 대한 정보는 &lt;a href=&quot;../library/columnstore-bulk-write-sdk/index#environment-configuration&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="528572a3b46ea1c0b9264f52de07cc0dabcb46ea" translate="yes" xml:space="preserve">
          <source>Information on installed and disabled plugins on a MariaDB Server.</source>
          <target state="translated">MariaDB 서버에 설치 및 비활성화 된 플러그인에 대한 정보.</target>
        </trans-unit>
        <trans-unit id="f205635118a08a4f17d4347bb9cb1b31a6bee199" translate="yes" xml:space="preserve">
          <source>Information on installing and using other plugins.</source>
          <target state="translated">다른 플러그인 설치 및 사용에 대한 정보.</target>
        </trans-unit>
        <trans-unit id="74a06909d66df178dba9799d7c2c98b6d4402482" translate="yes" xml:space="preserve">
          <source>Information on migrating from PostgreSQL to MariaDB.</source>
          <target state="translated">PostgreSQL에서 MariaDB로 마이그레이션하는 방법에 대한 정보.</target>
        </trans-unit>
        <trans-unit id="036aa4c305368ee9cfbf3b67e726f3111a24f462" translate="yes" xml:space="preserve">
          <source>Information on migrating to MariaDB from other databases.</source>
          <target state="translated">다른 데이터베이스에서 MariaDB로 마이그레이션하는 방법에 대한 정보.</target>
        </trans-unit>
        <trans-unit id="79f655b99467b67ffcadf61b78844c1bb7b0f5df" translate="yes" xml:space="preserve">
          <source>Information on new R packages is regularly published in the following websites:</source>
          <target state="translated">새로운 R 패키지에 대한 정보는 다음 웹 사이트에 정기적으로 게시됩니다.</target>
        </trans-unit>
        <trans-unit id="b353689ee292f00aa51f52682a72bc7ef0b7cfac" translate="yes" xml:space="preserve">
          <source>Information on replication, clustering, and multi-master solutions for MariaDB, as well as performance tuning.</source>
          <target state="translated">MariaDB 용 복제, 클러스터링 및 다중 마스터 솔루션 및 성능 조정에 대한 정보입니다.</target>
        </trans-unit>
        <trans-unit id="5531abeda09ca9820887399e6a48c7c2747525df" translate="yes" xml:space="preserve">
          <source>Information on setting server variables can be found on the &lt;a href=&quot;../server-system-variables/index&quot;&gt;Server System Variables&lt;/a&gt; page.</source>
          <target state="translated">서버 변수 설정에 대한 정보는 &lt;a href=&quot;../server-system-variables/index&quot;&gt;서버 시스템 변수&lt;/a&gt; 페이지 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b5e21258705626e56fa58246a906d390291a7b83" translate="yes" xml:space="preserve">
          <source>Information on storage engines available for MariaDB.</source>
          <target state="translated">MariaDB에 사용할 수있는 스토리지 엔진에 대한 정보입니다.</target>
        </trans-unit>
        <trans-unit id="4a69bbd551b5398395c392f9905ab9f8b894d486" translate="yes" xml:space="preserve">
          <source>Information on tablespaces for user-created temporary tables.</source>
          <target state="translated">사용자가 생성 한 임시 테이블의 테이블 스페이스에 대한 정보입니다.</target>
        </trans-unit>
        <trans-unit id="7cffffcb50994f5eedbdeb18b2294e3e425f5cae" translate="yes" xml:space="preserve">
          <source>Information on tablespaces in InnoDB, including an overview, system tablesp...</source>
          <target state="translated">개요, 시스템 테이블을 포함한 InnoDB의 테이블 스페이스에 대한 정보 ...</target>
        </trans-unit>
        <trans-unit id="67632ce9909db45f9c77a87ceaa158f91d964c02" translate="yes" xml:space="preserve">
          <source>Information on using MariaDB replication with MariaDB Galera Cluster.</source>
          <target state="translated">MariaDB Galera Cluster에서 MariaDB 복제 사용에 대한 정보.</target>
        </trans-unit>
        <trans-unit id="6c015d434930d7007a574a3b166117d4d023ca69" translate="yes" xml:space="preserve">
          <source>Information on using MariaDB's GTIDs with MariaDB Galera Cluster.</source>
          <target state="translated">MariaDB Galera Cluster에서 MariaDB의 GTID를 사용하는 방법에 대한 정보.</target>
        </trans-unit>
        <trans-unit id="8af669ae4d9bb32d7dff5f558d55511bc87e2429" translate="yes" xml:space="preserve">
          <source>Information relating to configuring and analyzing the ColumnStore system for optimal performance.</source>
          <target state="translated">최적의 성능을위한 ColumnStore 시스템 구성 및 분석과 관련된 정보입니다.</target>
        </trans-unit>
        <trans-unit id="a4e8a829f493f2271814391d53fc88ae69841fd7" translate="yes" xml:space="preserve">
          <source>Information your system administrator must provide before installing MariaDB ColumnStore:</source>
          <target state="translated">시스템 관리자가 MariaDB ColumnStore를 설치하기 전에 제공해야하는 정보 :</target>
        </trans-unit>
        <trans-unit id="c2da747e084afc73850cdd9641ca2141d08af25e" translate="yes" xml:space="preserve">
          <source>Information your system administrator must provide you before you start installing MariaDB ColumnStore:</source>
          <target state="translated">MariaDB ColumnStore 설치를 시작하기 전에 시스템 관리자가 제공해야하는 정보 :</target>
        </trans-unit>
        <trans-unit id="3e4c5f526adaee6ebcc67a3a95217c00d8018993" translate="yes" xml:space="preserve">
          <source>Ingesting lots of data and performance is bottlenecked in the INSERT area. What to do?</source>
          <target state="translated">INSERT 영역에서 많은 데이터와 성능을 수집하는 데 병목 현상이 발생합니다. 무엇을해야합니까?</target>
        </trans-unit>
        <trans-unit id="64f151d6ace3dfeee5467356c19cf020980c5ef6" translate="yes" xml:space="preserve">
          <source>Inherent dimension of a geometry value</source>
          <target state="translated">기하학 값의 고유 치수</target>
        </trans-unit>
        <trans-unit id="3927b44f685cd94cb167d9a43b8bf383fa7a9cbe" translate="yes" xml:space="preserve">
          <source>Inherent dimension of a geometry value.</source>
          <target state="translated">기하학 값의 고유 치수입니다.</target>
        </trans-unit>
        <trans-unit id="a66fce5e1da2bf944f42eb3efca3f248d1832205" translate="yes" xml:space="preserve">
          <source>Init DB</source>
          <target state="translated">초기화 DB</target>
        </trans-unit>
        <trans-unit id="f145cc6f22ecb82623ea2627d4974ffa985fa96c" translate="yes" xml:space="preserve">
          <source>Initial</source>
          <target state="translated">Initial</target>
        </trans-unit>
        <trans-unit id="058d19dda650f84e4d1f2d9a400605bbe773e450" translate="yes" xml:space="preserve">
          <source>Initial download &amp;amp; installation of MariaDB ColumnStore DEB package</source>
          <target state="translated">MariaDB ColumnStore DEB 패키지의 초기 다운로드 및 설치</target>
        </trans-unit>
        <trans-unit id="f2af6d4a7e7d9d7d264e2e959ee2765910f9b567" translate="yes" xml:space="preserve">
          <source>Initial download &amp;amp; installation of MariaDB ColumnStore RPMs</source>
          <target state="translated">MariaDB ColumnStore RPM의 초기 다운로드 및 설치</target>
        </trans-unit>
        <trans-unit id="4f5cb6dc4123de359e92b6359e61740bd1f88ddf" translate="yes" xml:space="preserve">
          <source>Initial download &amp;amp; installation of MariaDB ColumnStore binary package</source>
          <target state="translated">MariaDB ColumnStore 바이너리 패키지의 초기 다운로드 및 설치</target>
        </trans-unit>
        <trans-unit id="6dda592d3ec920ed808293f48bf69670c7722815" translate="yes" xml:space="preserve">
          <source>Initial download/install of MariaDB ColumnStore DEB package</source>
          <target state="translated">MariaDB ColumnStore DEB 패키지의 초기 다운로드 / 설치</target>
        </trans-unit>
        <trans-unit id="07f5b694e4eade0d86779797d674a48eb9149456" translate="yes" xml:space="preserve">
          <source>Initial download/install of MariaDB ColumnStore Package Repositories</source>
          <target state="translated">MariaDB ColumnStore 패키지 저장소의 초기 다운로드 / 설치</target>
        </trans-unit>
        <trans-unit id="a0a81687a15514554a11ddb007a5451722d5fadd" translate="yes" xml:space="preserve">
          <source>Initial download/install of MariaDB ColumnStore Package with the AX package</source>
          <target state="translated">AX 패키지와 함께 MariaDB ColumnStore 패키지의 초기 다운로드 / 설치</target>
        </trans-unit>
        <trans-unit id="a72e0602dc81b218f733b0766ac6e0fd61d24540" translate="yes" xml:space="preserve">
          <source>Initial download/install of MariaDB ColumnStore Packages</source>
          <target state="translated">MariaDB ColumnStore 패키지의 초기 다운로드 / 설치</target>
        </trans-unit>
        <trans-unit id="b94d1e86959fa3e31dc5838f112358889fbd2af6" translate="yes" xml:space="preserve">
          <source>Initial download/install of MariaDB ColumnStore RPMs</source>
          <target state="translated">MariaDB ColumnStore RPM의 초기 다운로드 / 설치</target>
        </trans-unit>
        <trans-unit id="72c2a0f4413e3964d98259646f2acd77db9899df" translate="yes" xml:space="preserve">
          <source>Initial download/install of MariaDB ColumnStore binary package</source>
          <target state="translated">MariaDB ColumnStore 바이너리 패키지의 초기 다운로드 / 설치</target>
        </trans-unit>
        <trans-unit id="79994a85d4a1e19527a0572a5ea37568f41c1a10" translate="yes" xml:space="preserve">
          <source>Initial posting: March, 2015; Refreshed Feb, 2016; Add DATE June, 2016; Add WP example May, 2017.</source>
          <target state="translated">최초 게시 : 2015 년 3 월 2016 년 2 월 새로 고침 2016 년 6 월 DATE 추가; 2017 년 5 월 WP 예제 추가.</target>
        </trans-unit>
        <trans-unit id="fd67134d209d3929a18fd22b2bf93061d0a6fcc9" translate="yes" xml:space="preserve">
          <source>Initial punctuation</source>
          <target state="translated">구두점</target>
        </trans-unit>
        <trans-unit id="d5f06d0de5953224d23adc916e87d19fc7847e1b" translate="yes" xml:space="preserve">
          <source>Initial state after a system reboot or install and before any action is taken.</source>
          <target state="translated">시스템 재부팅 또는 설치 후 작업을 수행하기 전의 초기 상태입니다.</target>
        </trans-unit>
        <trans-unit id="5bdbd8565b88c6e7e979abd5b98c8e249e178e5e" translate="yes" xml:space="preserve">
          <source>Initial support was based on version 05-134 of the standard. MariaDB implements a subset of the 'SQL with Geometry Types' environment proposed by the OGC. And the SQL environment was extended with a set of geometry types.</source>
          <target state="translated">초기 지원은 표준 버전 05-134를 기반으로합니다. MariaDB는 OGC에서 제안한 '기하 유형이있는 SQL'환경의 하위 집합을 구현합니다. 그리고 SQL 환경은 일련의 지오메트리 유형으로 확장되었습니다.</target>
        </trans-unit>
        <trans-unit id="18b2d7c364f038b5c943c5df7f817e5b15200373" translate="yes" xml:space="preserve">
          <source>Initialization Phase</source>
          <target state="translated">초기화 단계</target>
        </trans-unit>
        <trans-unit id="b5345d0b2b5e4c601690567f8c3586e57f181917" translate="yes" xml:space="preserve">
          <source>Initialization function for x(). Can be used for the following:</source>
          <target state="translated">x ()에 대한 초기화 함수. 다음 용도로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="efd862d60f2848797f3e38eef05ac4c2fb7fbc77" translate="yes" xml:space="preserve">
          <source>Initialize &lt;code&gt;DYNAMIC_COLUMN_VALUE&lt;/code&gt; before value of &lt;code&gt;value.x.decimal.value&lt;/code&gt; can be set</source>
          <target state="translated">&lt;code&gt;value.x.decimal.value&lt;/code&gt; 의 값을 설정 하기 전에 &lt;code&gt;DYNAMIC_COLUMN_VALUE&lt;/code&gt; 를 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="b7f2df998fcd800f1a2a462b2c863205a00d5a95" translate="yes" xml:space="preserve">
          <source>Initialize a &lt;code&gt;DYNAMIC_COLUMN_VALUE&lt;/code&gt; structure to a safe default.</source>
          <target state="translated">&lt;code&gt;DYNAMIC_COLUMN_VALUE&lt;/code&gt; 구조를 안전한 기본값으로 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="26ac5e37d496de00bf60e19d042275381e3527b3" translate="yes" xml:space="preserve">
          <source>Initialized</source>
          <target state="translated">Initialized</target>
        </trans-unit>
        <trans-unit id="1a7cac91a0bfc952f8d2a1623c8520beaf05a232" translate="yes" xml:space="preserve">
          <source>Initializing (trying to find the delayed-insert handler thread).</source>
          <target state="translated">초기화 중 (지연된 삽입 처리기 스레드를 찾으려고 시도 중)</target>
        </trans-unit>
        <trans-unit id="c55a4dda5ea20bb05d5ac82e972136b8a9ae3f64" translate="yes" xml:space="preserve">
          <source>Initially, any user and host is matched:</source>
          <target state="translated">처음에는 모든 사용자와 호스트가 일치합니다.</target>
        </trans-unit>
        <trans-unit id="97f81aea726bd840959c9cdbb824d0d2255dfa61" translate="yes" xml:space="preserve">
          <source>Initially, the MySQL C API was developed to be very similar to that of the mSQL database system.</source>
          <target state="translated">처음에 MySQL C API는 mSQL 데이터베이스 시스템과 매우 유사하게 개발되었습니다.</target>
        </trans-unit>
        <trans-unit id="5bdd45006b855003ab773ffbec00c6dab96a2186" translate="yes" xml:space="preserve">
          <source>Injection speed</source>
          <target state="translated">주입 속도</target>
        </trans-unit>
        <trans-unit id="c6f2016bd5e3d993457b8bf62c39fe291a9e4e4b" translate="yes" xml:space="preserve">
          <source>InnoD strict mode makes InnoDB more reliable.</source>
          <target state="translated">InnoD 엄격 모드는 InnoDB를 더 안정적으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="244543a61038c397a5da15c129a7d9860c1313df" translate="yes" xml:space="preserve">
          <source>InnoDB</source>
          <target state="translated">InnoDB</target>
        </trans-unit>
        <trans-unit id="9964c76dc61a02364dfc8153293163ec42c40b5c" translate="yes" xml:space="preserve">
          <source>InnoDB &quot;clusters&quot; the PRIMARY KEY with the data. Hence, given the value of the PK (&quot;PRIMARY KEY&quot;), after drilling down the BTree to find the index entry, you have all the columns of the row when you get there. A &quot;secondary key&quot; (any UNIQUE or INDEX other than the PK) in InnoDB first drills down the BTree for the secondary index, where it finds a copy of the PK. Then it drills down the PK to find the row.</source>
          <target state="translated">InnoDB는 데이터와 함께 PRIMARY KEY를 &quot;클러스터링&quot;합니다. 따라서 PK ( &quot;PRIMARY KEY&quot;)의 값이 주어지면 BTree를 드릴 다운하여 인덱스 항목을 찾은 후 해당 행에 도달하면 행의 모든 ​​열을 갖게됩니다. InnoDB의 &quot;보조 키&quot;(PK 이외의 UNIQUE 또는 INDEX)는 먼저 보조 인덱스에 대한 BTree를 드릴 다운하여 PK의 복사본을 찾습니다. 그런 다음 PK를 드릴 다운하여 행을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="80708c2e8c5918f2d6dd8a5463cd0f8fd6b8cf89" translate="yes" xml:space="preserve">
          <source>InnoDB / XtraDB Background Encryption Threads</source>
          <target state="translated">InnoDB / XtraDB 백그라운드 암호화 스레드</target>
        </trans-unit>
        <trans-unit id="19da305cad895ec352d2c9c7f3d75d8821076bd6" translate="yes" xml:space="preserve">
          <source>InnoDB / XtraDB Disabling Encryption</source>
          <target state="translated">InnoDB / XtraDB 비활성화 암호화</target>
        </trans-unit>
        <trans-unit id="1d0371f8bed36b11ca75da96b60b674ce864f5ea" translate="yes" xml:space="preserve">
          <source>InnoDB / XtraDB Enabling Encryption</source>
          <target state="translated">InnoDB / XtraDB 활성화 암호화</target>
        </trans-unit>
        <trans-unit id="d8b12c37fd7f747c64fcb03a4bb1cf71c5d5eacd" translate="yes" xml:space="preserve">
          <source>InnoDB / XtraDB Encryption</source>
          <target state="translated">InnoDB / XtraDB 암호화</target>
        </trans-unit>
        <trans-unit id="5412c58401e415f333d1c9c511ee150242e9d9b9" translate="yes" xml:space="preserve">
          <source>InnoDB / XtraDB Encryption Keys</source>
          <target state="translated">InnoDB / XtraDB 암호화 키</target>
        </trans-unit>
        <trans-unit id="dadec9bf7268cda3f790374f988100c51284498a" translate="yes" xml:space="preserve">
          <source>InnoDB / XtraDb Encryption Troubleshooting</source>
          <target state="translated">InnoDB / XtraDb 암호화 문제 해결</target>
        </trans-unit>
        <trans-unit id="b23f657c094d515ad8cad7aa5108e709b1de5f27" translate="yes" xml:space="preserve">
          <source>InnoDB 5.6.14</source>
          <target state="translated">InnoDB 5.6.14</target>
        </trans-unit>
        <trans-unit id="528e4227aaa8fbaba3d2d36f7a358dc69f34e509" translate="yes" xml:space="preserve">
          <source>InnoDB 5.6.15</source>
          <target state="translated">InnoDB 5.6.15</target>
        </trans-unit>
        <trans-unit id="1d2c5fc3abf4d878aa7368c7fea0aaaeacc9d776" translate="yes" xml:space="preserve">
          <source>InnoDB 5.6.17</source>
          <target state="translated">InnoDB 5.6.17</target>
        </trans-unit>
        <trans-unit id="01e2f70d98cd2ecc7f1c13f16ca34ecd0a4d3f04" translate="yes" xml:space="preserve">
          <source>InnoDB 5.6.19</source>
          <target state="translated">InnoDB 5.6.19</target>
        </trans-unit>
        <trans-unit id="ab1b3ff8f2e6042c4ffb5a15f488d5a904b7f06f" translate="yes" xml:space="preserve">
          <source>InnoDB 5.6.20</source>
          <target state="translated">InnoDB 5.6.20</target>
        </trans-unit>
        <trans-unit id="b3299aeb1b3e41e120b99665892a97068097d9de" translate="yes" xml:space="preserve">
          <source>InnoDB 5.6.21</source>
          <target state="translated">InnoDB 5.6.21</target>
        </trans-unit>
        <trans-unit id="5d7c5cb2330a68a0fef08b914710ff20d8e8b646" translate="yes" xml:space="preserve">
          <source>InnoDB 5.6.22</source>
          <target state="translated">InnoDB 5.6.22</target>
        </trans-unit>
        <trans-unit id="f819fbe3c657f59c591b10e3030ce195b02a472e" translate="yes" xml:space="preserve">
          <source>InnoDB 5.6.23</source>
          <target state="translated">InnoDB 5.6.23</target>
        </trans-unit>
        <trans-unit id="ca7ce875cbef3ced302534f7f6c98517f70fd12a" translate="yes" xml:space="preserve">
          <source>InnoDB 5.6.24</source>
          <target state="translated">InnoDB 5.6.24</target>
        </trans-unit>
        <trans-unit id="723deb1d6cd9962825803dfbd68d6e072f5f3a59" translate="yes" xml:space="preserve">
          <source>InnoDB 5.6.25</source>
          <target state="translated">InnoDB 5.6.25</target>
        </trans-unit>
        <trans-unit id="51146ecdea0b06ae23a4a85a06a123fee9fbd9d1" translate="yes" xml:space="preserve">
          <source>InnoDB 5.6.26</source>
          <target state="translated">InnoDB 5.6.26</target>
        </trans-unit>
        <trans-unit id="f21febaca2d27d2746b11e2d9d03b217b8340efa" translate="yes" xml:space="preserve">
          <source>InnoDB 5.6.27</source>
          <target state="translated">InnoDB 5.6.27</target>
        </trans-unit>
        <trans-unit id="a6781e4a45b9d0e4db0d996f11ed21f7a3197ef8" translate="yes" xml:space="preserve">
          <source>InnoDB 5.6.28</source>
          <target state="translated">InnoDB 5.6.28</target>
        </trans-unit>
        <trans-unit id="0a4cccccbe8d5e80794244e7cdaf0760398b2bc9" translate="yes" xml:space="preserve">
          <source>InnoDB 5.6.29</source>
          <target state="translated">InnoDB 5.6.29</target>
        </trans-unit>
        <trans-unit id="83369e0e10d534acac37ee80b72cede72d6647c0" translate="yes" xml:space="preserve">
          <source>InnoDB 5.6.30</source>
          <target state="translated">InnoDB 5.6.30</target>
        </trans-unit>
        <trans-unit id="e04a35b5c68e9956632e31dfd509450a17b4c20e" translate="yes" xml:space="preserve">
          <source>InnoDB 5.6.31</source>
          <target state="translated">InnoDB 5.6.31</target>
        </trans-unit>
        <trans-unit id="a0c1b7faa219119418dfa92e4bfc9b5753b74ad6" translate="yes" xml:space="preserve">
          <source>InnoDB 5.6.32</source>
          <target state="translated">InnoDB 5.6.32</target>
        </trans-unit>
        <trans-unit id="2de5ff4d45108c371abeca08f99a013280961d0f" translate="yes" xml:space="preserve">
          <source>InnoDB 5.6.33</source>
          <target state="translated">InnoDB 5.6.33</target>
        </trans-unit>
        <trans-unit id="9d61d37b6a36d805dafe2cb7b56df9eac2185430" translate="yes" xml:space="preserve">
          <source>InnoDB 5.6.35</source>
          <target state="translated">InnoDB 5.6.35</target>
        </trans-unit>
        <trans-unit id="5889e1f8fe8b28ba07434dfb59458c0fbc572ec0" translate="yes" xml:space="preserve">
          <source>InnoDB 5.6.36</source>
          <target state="translated">InnoDB 5.6.36</target>
        </trans-unit>
        <trans-unit id="53809c5b9504e285df4e2d5df2ce4f08c9709dc2" translate="yes" xml:space="preserve">
          <source>InnoDB 5.6.37</source>
          <target state="translated">InnoDB 5.6.37</target>
        </trans-unit>
        <trans-unit id="2deaeb7bb237eebb84fd36897482cf11393fe274" translate="yes" xml:space="preserve">
          <source>InnoDB 5.6.38</source>
          <target state="translated">InnoDB 5.6.38</target>
        </trans-unit>
        <trans-unit id="3dd2061d9112a417d938860e44d218f4138fd16b" translate="yes" xml:space="preserve">
          <source>InnoDB 5.6.39</source>
          <target state="translated">InnoDB 5.6.39</target>
        </trans-unit>
        <trans-unit id="40ee64a27f466ad75ffe526513ffe6b4c7aca8cc" translate="yes" xml:space="preserve">
          <source>InnoDB 5.6.40</source>
          <target state="translated">InnoDB 5.6.40</target>
        </trans-unit>
        <trans-unit id="3726d9f40824489851c45b98c9f2166b1a04341d" translate="yes" xml:space="preserve">
          <source>InnoDB 5.6.42</source>
          <target state="translated">InnoDB 5.6.42</target>
        </trans-unit>
        <trans-unit id="52c9f350b6a8a7dcf757a3ebc886bbe8f86d9b41" translate="yes" xml:space="preserve">
          <source>InnoDB 5.6.43</source>
          <target state="translated">InnoDB 5.6.43</target>
        </trans-unit>
        <trans-unit id="25fe9825aa01441e24fc0ecda81bcfc6384a01ac" translate="yes" xml:space="preserve">
          <source>InnoDB 5.6.44</source>
          <target state="translated">InnoDB 5.6.44</target>
        </trans-unit>
        <trans-unit id="3f0b239a922d5cfae89a0e696899612f33b74f83" translate="yes" xml:space="preserve">
          <source>InnoDB 5.7.14</source>
          <target state="translated">InnoDB 5.7.14</target>
        </trans-unit>
        <trans-unit id="2d251c9b7199f2ef1202f2ab980c4dc35570e158" translate="yes" xml:space="preserve">
          <source>InnoDB 5.7.18</source>
          <target state="translated">InnoDB 5.7.18</target>
        </trans-unit>
        <trans-unit id="24e058dab8bbbf8fde4aea0209cacca9b2b9267d" translate="yes" xml:space="preserve">
          <source>InnoDB 5.7.19</source>
          <target state="translated">InnoDB 5.7.19</target>
        </trans-unit>
        <trans-unit id="3ac916f2c017ebe5b35f1ed261b5176fb31adee6" translate="yes" xml:space="preserve">
          <source>InnoDB 5.7.20</source>
          <target state="translated">InnoDB 5.7.20</target>
        </trans-unit>
        <trans-unit id="a775a855aaecd34c602fae5d9dc3034d6f72bf1d" translate="yes" xml:space="preserve">
          <source>InnoDB 5.7.21</source>
          <target state="translated">InnoDB 5.7.21</target>
        </trans-unit>
        <trans-unit id="b239dfabcfd6d65cb0923b241bd3c52eacea7bbf" translate="yes" xml:space="preserve">
          <source>InnoDB 5.7.22</source>
          <target state="translated">InnoDB 5.7.22</target>
        </trans-unit>
        <trans-unit id="eee04bc9cd80ee543a3e3cb9f4ab9770d1b0ee77" translate="yes" xml:space="preserve">
          <source>InnoDB 5.7.23</source>
          <target state="translated">InnoDB 5.7.23</target>
        </trans-unit>
        <trans-unit id="32fd3c602ff72d9c9dad6c7081fcbc73ecd9f581" translate="yes" xml:space="preserve">
          <source>InnoDB Buffer Pool</source>
          <target state="translated">InnoDB 버퍼 풀</target>
        </trans-unit>
        <trans-unit id="d47e6566f8253ac5907d6ece130b6d87283b06a3" translate="yes" xml:space="preserve">
          <source>InnoDB COMPACT Row Format</source>
          <target state="translated">InnoDB COMPACT 행 형식</target>
        </trans-unit>
        <trans-unit id="116f90e3c9828c655e37be3da7f9898388e526eb" translate="yes" xml:space="preserve">
          <source>InnoDB COMPACT Row Format: Overflow Pages with the COMPACT Row Format</source>
          <target state="translated">InnoDB COMPACT 행 형식 : COMPACT 행 형식을 사용하는 오버플로 페이지</target>
        </trans-unit>
        <trans-unit id="4e12d2d92185181abffc90380fe59ab28152317c" translate="yes" xml:space="preserve">
          <source>InnoDB COMPRESSED Row Format</source>
          <target state="translated">InnoDB COMPRESSED 행 형식</target>
        </trans-unit>
        <trans-unit id="55b25794ff9ca7d5a0fe9aea8a3814f879a52dee" translate="yes" xml:space="preserve">
          <source>InnoDB COMPRESSED Row Format: Overflow Pages with the COMPRESSED Row Format</source>
          <target state="translated">InnoDB COMPRESSED 행 형식 : COMPRESSED 행 형식을 사용하는 오버플로 페이지</target>
        </trans-unit>
        <trans-unit id="adedf618f8b0687e020835f53920a41c05bc3207" translate="yes" xml:space="preserve">
          <source>InnoDB Change Buffering</source>
          <target state="translated">InnoDB 변경 버퍼링</target>
        </trans-unit>
        <trans-unit id="922eb208d3364e1933fd7d4d504d0ff7db8b75cf" translate="yes" xml:space="preserve">
          <source>InnoDB DYNAMIC Row Format</source>
          <target state="translated">InnoDB DYNAMIC 행 형식</target>
        </trans-unit>
        <trans-unit id="514f2bb10d397aaedb3350eb661834fea93bc15e" translate="yes" xml:space="preserve">
          <source>InnoDB DYNAMIC Row Format: Overflow Pages with the DYNAMIC Row Format</source>
          <target state="translated">InnoDB DYNAMIC 행 형식 : DYNAMIC 행 형식을 사용하는 오버플로 페이지</target>
        </trans-unit>
        <trans-unit id="ac9e48f56d812c35c30a1041abdfc3a81a10bd72" translate="yes" xml:space="preserve">
          <source>InnoDB Data Dictionary Troubleshooting</source>
          <target state="translated">InnoDB 데이터 사전 문제 해결</target>
        </trans-unit>
        <trans-unit id="0b8acde0e7acf2af00be4e464b243f174bdc89bd" translate="yes" xml:space="preserve">
          <source>InnoDB Data Files</source>
          <target state="translated">InnoDB 데이터 파일</target>
        </trans-unit>
        <trans-unit id="76bfe54556b8c7d985245bc29d527b1fd080e20f" translate="yes" xml:space="preserve">
          <source>InnoDB Data Scrubbing</source>
          <target state="translated">InnoDB 데이터 스크러빙</target>
        </trans-unit>
        <trans-unit id="77c8fb1df0cd7868d1088495c503af7bb2ba8f2f" translate="yes" xml:space="preserve">
          <source>InnoDB Defragmentation from 10.1.1</source>
          <target state="translated">10.1.1에서 InnoDB 조각 모음</target>
        </trans-unit>
        <trans-unit id="b48a2ca6ab263bf04e4d143ac578c1634cbe46f8" translate="yes" xml:space="preserve">
          <source>InnoDB Doublewrite Buffer</source>
          <target state="translated">InnoDB 이중 쓰기 버퍼</target>
        </trans-unit>
        <trans-unit id="c6da2698758ffdaef9f8d9d1fb0cb6db2bb1b69b" translate="yes" xml:space="preserve">
          <source>InnoDB Encryption Overview</source>
          <target state="translated">InnoDB 암호화 개요</target>
        </trans-unit>
        <trans-unit id="ca3a6d715aab62930af2d623982bbc55d6c8906e" translate="yes" xml:space="preserve">
          <source>InnoDB File Format</source>
          <target state="translated">InnoDB 파일 형식</target>
        </trans-unit>
        <trans-unit id="7df68fa6b9b332912b7e3ed9c3c07aa9f591c7f1" translate="yes" xml:space="preserve">
          <source>InnoDB File-Per-Table Tablespaces</source>
          <target state="translated">InnoDB 테이블 당 테이블 스페이스</target>
        </trans-unit>
        <trans-unit id="023c13e5228bc1eeea828353aea71a3b221d76a7" translate="yes" xml:space="preserve">
          <source>InnoDB Instead of XtraDB</source>
          <target state="translated">XtraDB 대신 InnoDB</target>
        </trans-unit>
        <trans-unit id="dca135edb0200e1f23b6811247f4bb5be2ee0606" translate="yes" xml:space="preserve">
          <source>InnoDB Limitations</source>
          <target state="translated">InnoDB 제한</target>
        </trans-unit>
        <trans-unit id="6e66622a24a0b7e11e56771da0f5315dd279561b" translate="yes" xml:space="preserve">
          <source>InnoDB Lock Modes</source>
          <target state="translated">InnoDB 잠금 모드</target>
        </trans-unit>
        <trans-unit id="3734e3ce44682915d9174f88dd3825e9e458a2a2" translate="yes" xml:space="preserve">
          <source>InnoDB Lock Monitor</source>
          <target state="translated">InnoDB 잠금 모니터</target>
        </trans-unit>
        <trans-unit id="451ad1f126f987f3f995266ab745d6ac82da1498" translate="yes" xml:space="preserve">
          <source>InnoDB Logical Backups</source>
          <target state="translated">InnoDB 논리 백업</target>
        </trans-unit>
        <trans-unit id="f2b9ae2b7d3503557faae8723ce1c97e098fe278" translate="yes" xml:space="preserve">
          <source>InnoDB Monitors</source>
          <target state="translated">InnoDB 모니터</target>
        </trans-unit>
        <trans-unit id="c9d3c7a1bd5f3fe4224c932c3bb7af4e89306f30" translate="yes" xml:space="preserve">
          <source>InnoDB Online DDL</source>
          <target state="translated">InnoDB 온라인 DDL</target>
        </trans-unit>
        <trans-unit id="09e6a0aa600938af7ee822bd6cc126a134c0ab7e" translate="yes" xml:space="preserve">
          <source>InnoDB Online DDL Operations with ALGORITHM=INPLACE</source>
          <target state="translated">ALGORITHM = INPLACE를 사용한 InnoDB 온라인 DDL 작업</target>
        </trans-unit>
        <trans-unit id="e8adc8b01a23c36e3da2418b31387d3bf82cd70d" translate="yes" xml:space="preserve">
          <source>InnoDB Online DDL Operations with ALGORITHM=INSTANT</source>
          <target state="translated">ALGORITHM = INSTANT를 사용한 InnoDB 온라인 DDL 작업</target>
        </trans-unit>
        <trans-unit id="31a38435764d7082bb697c6837f4c3d2cda0b5a2" translate="yes" xml:space="preserve">
          <source>InnoDB Online DDL Operations with ALGORITHM=NOCOPY</source>
          <target state="translated">ALGORITHM = NOCOPY를 사용한 InnoDB 온라인 DDL 작업</target>
        </trans-unit>
        <trans-unit id="d60deabe1a42fbd245bbd71cd3be4002eb09cf9d" translate="yes" xml:space="preserve">
          <source>InnoDB Online DDL Operations with the INPLACE Alter Algorithm</source>
          <target state="translated">INPLACE 변경 알고리즘을 사용한 InnoDB 온라인 DDL 작업</target>
        </trans-unit>
        <trans-unit id="e7f6abb8abaa72bc05c151b98362280d4bd25be2" translate="yes" xml:space="preserve">
          <source>InnoDB Online DDL Operations with the INSTANT Alter Algorithm</source>
          <target state="translated">인스턴스 변경 알고리즘을 사용한 InnoDB 온라인 DDL 작업</target>
        </trans-unit>
        <trans-unit id="9a464f5f926c3d3f619ea4faceb0e3d925cf86d0" translate="yes" xml:space="preserve">
          <source>InnoDB Online DDL Operations with the NOCOPY Alter Algorithm</source>
          <target state="translated">NOCOPY 변경 알고리즘을 사용한 InnoDB 온라인 DDL 작업</target>
        </trans-unit>
        <trans-unit id="743047484570b2c4943d66c7e8e548440f3a2b97" translate="yes" xml:space="preserve">
          <source>InnoDB Online DDL Overview</source>
          <target state="translated">InnoDB 온라인 DDL 개요</target>
        </trans-unit>
        <trans-unit id="ec19094193415ba96e4de6ff6ff6c0ffa1a88327" translate="yes" xml:space="preserve">
          <source>InnoDB Page Compression</source>
          <target state="translated">InnoDB 페이지 압축</target>
        </trans-unit>
        <trans-unit id="564be8da49210f746c23f5b557208764a7b39cc3" translate="yes" xml:space="preserve">
          <source>InnoDB Page Flushing</source>
          <target state="translated">InnoDB 페이지 플러싱</target>
        </trans-unit>
        <trans-unit id="7ad1d4a56d01cb9a339b7b1b408fa7aef62517c5" translate="yes" xml:space="preserve">
          <source>InnoDB Page Size</source>
          <target state="translated">InnoDB 페이지 크기</target>
        </trans-unit>
        <trans-unit id="464ab305129af18a9108f8b78200166c4fbfc98a" translate="yes" xml:space="preserve">
          <source>InnoDB Persistent Statistics</source>
          <target state="translated">InnoDB 영구 통계</target>
        </trans-unit>
        <trans-unit id="8aa56f1fea0f3791cd45d8d9701ba8b45d1cf057" translate="yes" xml:space="preserve">
          <source>InnoDB Purge</source>
          <target state="translated">InnoDB 퍼지</target>
        </trans-unit>
        <trans-unit id="ca3bc2035b6e6622e8d95cca154bca2a36c51691" translate="yes" xml:space="preserve">
          <source>InnoDB REDUNDANT Row Format</source>
          <target state="translated">InnoDB 중복 행 형식</target>
        </trans-unit>
        <trans-unit id="ee3b02b922b79fd521901ee0f654a4c53ed6e3dd" translate="yes" xml:space="preserve">
          <source>InnoDB REDUNDANT Row Format: Overflow Pages with the REDUNDANT Row Format</source>
          <target state="translated">InnoDB REDUNDANT 행 형식 : REDUNDANT 행 형식의 오버 플로우 페이지</target>
        </trans-unit>
        <trans-unit id="c6420fcf5a42bbf24ad8cb87264ab30040bff5f1" translate="yes" xml:space="preserve">
          <source>InnoDB Redo Log</source>
          <target state="translated">InnoDB 리두 로그</target>
        </trans-unit>
        <trans-unit id="5c5dbf18190bebeb4878ad7fb9bda122a45af4d3" translate="yes" xml:space="preserve">
          <source>InnoDB Row Formats</source>
          <target state="translated">InnoDB 행 형식</target>
        </trans-unit>
        <trans-unit id="a720e710f1833f0600f9575ab208918854d0f726" translate="yes" xml:space="preserve">
          <source>InnoDB Row Formats Overview</source>
          <target state="translated">InnoDB 행 형식 개요</target>
        </trans-unit>
        <trans-unit id="faac0e997b98b79a24315a0aebab23269b36b522" translate="yes" xml:space="preserve">
          <source>InnoDB Server Status Variables</source>
          <target state="translated">InnoDB 서버 상태 변수</target>
        </trans-unit>
        <trans-unit id="db7160080c3db48854b1447c97e370882c1e8524" translate="yes" xml:space="preserve">
          <source>InnoDB Spatial Indexes</source>
          <target state="translated">InnoDB 공간 인덱스</target>
        </trans-unit>
        <trans-unit id="1720d1bbe9c2757569f8ca7bee15efa716c0bb76" translate="yes" xml:space="preserve">
          <source>InnoDB Stopwords</source>
          <target state="translated">InnoDB 중지 어</target>
        </trans-unit>
        <trans-unit id="f9f87b4a5e24536c2f019cd661d781a1425ec90e" translate="yes" xml:space="preserve">
          <source>InnoDB Storage Engine Options</source>
          <target state="translated">InnoDB 스토리지 엔진 옵션</target>
        </trans-unit>
        <trans-unit id="917eff65a32c4c6cb8b5fed298249c2354df2cc0" translate="yes" xml:space="preserve">
          <source>InnoDB Storage Engine Options and System Variables</source>
          <target state="translated">InnoDB 스토리지 엔진 옵션 및 시스템 변수</target>
        </trans-unit>
        <trans-unit id="e7fed191484d548a1deb538310a5e25bf90d1d08" translate="yes" xml:space="preserve">
          <source>InnoDB Storage Formats</source>
          <target state="translated">InnoDB 스토리지 포맷</target>
        </trans-unit>
        <trans-unit id="5a2a5f18b1e21b59c9cda99e798c393f9fddfdda" translate="yes" xml:space="preserve">
          <source>InnoDB Strict Mode</source>
          <target state="translated">InnoDB 엄격한 모드</target>
        </trans-unit>
        <trans-unit id="d79ffa4ac90232db7d39c3077e14235fc7ff84ce" translate="yes" xml:space="preserve">
          <source>InnoDB Strict Mode Errors</source>
          <target state="translated">InnoDB 엄격한 모드 오류</target>
        </trans-unit>
        <trans-unit id="d6099acdfa59e6b41631dbb683bae499108e8409" translate="yes" xml:space="preserve">
          <source>InnoDB System Tablespaces</source>
          <target state="translated">InnoDB 시스템 테이블 스페이스</target>
        </trans-unit>
        <trans-unit id="b069f1a6961bed9788d454135a25e518eff8286a" translate="yes" xml:space="preserve">
          <source>InnoDB System Variables</source>
          <target state="translated">InnoDB 시스템 변수</target>
        </trans-unit>
        <trans-unit id="2ff871c036090a3ab126fd7fbe3d0c1a303670dd" translate="yes" xml:space="preserve">
          <source>InnoDB Table Corruption</source>
          <target state="translated">InnoDB 테이블 손상</target>
        </trans-unit>
        <trans-unit id="c701adf58455148775c741deecbb6ea0e05497a0" translate="yes" xml:space="preserve">
          <source>InnoDB Table Monitor</source>
          <target state="translated">InnoDB 테이블 모니터</target>
        </trans-unit>
        <trans-unit id="1b89656523e5010e65153d7c7dad724518c7a38a" translate="yes" xml:space="preserve">
          <source>InnoDB Tablespace Monitor</source>
          <target state="translated">InnoDB 테이블 스페이스 모니터</target>
        </trans-unit>
        <trans-unit id="ee1433a1047fb7a66b6e693c2de863d3cf933466" translate="yes" xml:space="preserve">
          <source>InnoDB Tablespaces</source>
          <target state="translated">InnoDB 테이블 스페이스</target>
        </trans-unit>
        <trans-unit id="4dedda2b5c27f817b4fdc75ed30fa6ff7535e350" translate="yes" xml:space="preserve">
          <source>InnoDB Temporary Tablespaces</source>
          <target state="translated">InnoDB 임시 테이블 스페이스</target>
        </trans-unit>
        <trans-unit id="65b1efddbc92904076db5d3e34748d9bbf681920" translate="yes" xml:space="preserve">
          <source>InnoDB Troubleshooting</source>
          <target state="translated">InnoDB 문제 해결</target>
        </trans-unit>
        <trans-unit id="e1597487c3611354878b2fff1089c09295144417" translate="yes" xml:space="preserve">
          <source>InnoDB Troubleshooting Overview</source>
          <target state="translated">InnoDB 문제 해결 개요</target>
        </trans-unit>
        <trans-unit id="829182a07aff5bcde879221cbe2ebf7e832ee8dd" translate="yes" xml:space="preserve">
          <source>InnoDB Undo Log</source>
          <target state="translated">InnoDB 실행 취소 로그</target>
        </trans-unit>
        <trans-unit id="2ecc8fad8f12d005029eb20339d82ffe5c0a6693" translate="yes" xml:space="preserve">
          <source>InnoDB Undo log.</source>
          <target state="translated">InnoDB 실행 취소 로그.</target>
        </trans-unit>
        <trans-unit id="220b2ece2327001590ab0383971db60659b1dfba" translate="yes" xml:space="preserve">
          <source>InnoDB Version</source>
          <target state="translated">InnoDB 버전</target>
        </trans-unit>
        <trans-unit id="ecfd5fe158278af3d9bdd1d37d102c427b9896b5" translate="yes" xml:space="preserve">
          <source>InnoDB Versions</source>
          <target state="translated">InnoDB 버전</target>
        </trans-unit>
        <trans-unit id="b0674cfc4b04946b6ae84073791d4550aeb85425" translate="yes" xml:space="preserve">
          <source>InnoDB Versions Included in MariaDB Releases</source>
          <target state="translated">MariaDB 릴리스에 포함 된 InnoDB 버전</target>
        </trans-unit>
        <trans-unit id="7fa8edb13b1fedb19ed4c9c343c8b5a1b38f40bb" translate="yes" xml:space="preserve">
          <source>InnoDB achieves this by (almost) supporting &lt;code&gt;SERIALIZABLE&lt;/code&gt; transactional isolation level. It does so by supporting &quot;Gap Locks&quot;. MyRocks doesn't support &lt;code&gt;SERIALIZABLE&lt;/code&gt; isolation, and it doesn't support gap locks.</source>
          <target state="translated">InnoDB는 &lt;code&gt;SERIALIZABLE&lt;/code&gt; 트랜잭션 격리 수준 을 (거의) 지원함으로써이를 달성 합니다. &quot;갭 잠금&quot;을 지원하여 그렇게합니다. MyRocks는 &lt;code&gt;SERIALIZABLE&lt;/code&gt; 격리를 지원하지 않으며 간격 잠금을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="46502b86be25dbf13be3689335d4ebd83957d4a6" translate="yes" xml:space="preserve">
          <source>InnoDB also permits table locking, and to allow locking at both table and row level to co-exist gracefully, a series of locks called &lt;em&gt;intention locks&lt;/em&gt; exist.</source>
          <target state="translated">InnoDB는 또한 테이블 잠금을 허용하고 테이블과 행 수준에서의 잠금이 정상적으로 공존 할 수 있도록 &lt;em&gt;의도 잠금&lt;/em&gt; 이라고하는 일련의 &lt;em&gt;잠금&lt;/em&gt; 이 존재합니다.</target>
        </trans-unit>
        <trans-unit id="9b5fb0fdc04aabbac3f094a72954b9d80fa8b1c7" translate="yes" xml:space="preserve">
          <source>InnoDB and AUTO_INCREMENT</source>
          <target state="translated">InnoDB와 AUTO_INCREMENT</target>
        </trans-unit>
        <trans-unit id="859df3c1005987ef6124efc45c4ed7332bab6e83" translate="yes" xml:space="preserve">
          <source>InnoDB and XtraDB</source>
          <target state="translated">InnoDB와 XtraDB</target>
        </trans-unit>
        <trans-unit id="5e8847d648a9e875369966a5a631de54e8c020df" translate="yes" xml:space="preserve">
          <source>InnoDB and XtraDB data scrubbing was introduced in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1013-release-notes/&quot;&gt;MariaDB 10.1.3&lt;/a&gt;.</source>
          <target state="translated">InnoDB 및 XtraDB 데이터 스크러빙은 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1013-release-notes/&quot;&gt;MariaDB 10.1.3&lt;/a&gt; 에서 도입되었습니다 .</target>
        </trans-unit>
        <trans-unit id="f4edb08e2f01e340a93af6e58f80b987fa9f289d" translate="yes" xml:space="preserve">
          <source>InnoDB and XtraDB do not permit manual encryption changes to tables in the &lt;a href=&quot;../innodb-system-tablespaces/index&quot;&gt;system&lt;/a&gt; tablespace using &lt;code&gt;&lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt;&lt;/code&gt;. Encryption of the &lt;a href=&quot;../innodb-system-tablespaces/index&quot;&gt;system&lt;/a&gt; tablespace can only be configured by setting the value of the &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encrypt_tables&quot;&gt;innodb_encrypt_tables&lt;/a&gt;&lt;/code&gt; system variable. This means that when you want to encrypt or decrypt the &lt;a href=&quot;../innodb-system-tablespaces/index&quot;&gt;system&lt;/a&gt; tablespace, you must also set a non-zero value for the &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encryption_threads&quot;&gt;innodb_encryption_threads&lt;/a&gt;&lt;/code&gt; system variable, and you must also set the &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encryption_rotate_key_age&quot;&gt;innodb_system_rotate_key_age&lt;/a&gt;&lt;/code&gt; system variable to &lt;code&gt;1&lt;/code&gt; to ensure that the system tablespace is properly encrypted or decrypted by the background threads. See &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-14398&quot;&gt;MDEV-14398&lt;/a&gt; for more information.</source>
          <target state="translated">InnoDB 및 XtraDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt;&lt;/code&gt; 을 사용하여 &lt;a href=&quot;../innodb-system-tablespaces/index&quot;&gt;시스템&lt;/a&gt; 테이블 스페이스의 테이블에 대한 수동 암호화 변경을 허용하지 않습니다 . &lt;a href=&quot;../innodb-system-tablespaces/index&quot;&gt;시스템&lt;/a&gt; 테이블 스페이스의 암호화는 &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encrypt_tables&quot;&gt;innodb_encrypt_tables&lt;/a&gt;&lt;/code&gt; 시스템 변수 의 값을 설정하여 구성 할 수 있습니다 . 이는 &lt;a href=&quot;../innodb-system-tablespaces/index&quot;&gt;시스템&lt;/a&gt; 테이블 스페이스 를 암호화 또는 암호 해독 할 때 &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encryption_threads&quot;&gt;innodb_encryption_threads&lt;/a&gt;&lt;/code&gt; 시스템 변수에 0이 아닌 값을 설정해야 하며 시스템 테이블 스페이스가 올바르게 암호화되도록 하려면 &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encryption_rotate_key_age&quot;&gt;innodb_system_rotate_key_age&lt;/a&gt;&lt;/code&gt; 시스템 변수를 &lt;code&gt;1&lt;/code&gt; 로 설정해야합니다. 백그라운드 스레드에 의해 해독됩니다. 자세한 내용은 &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-14398&quot;&gt;MDEV-14398&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="01e1d29b71bb5bf02e7e4578fe48a4cf9ee1b92d" translate="yes" xml:space="preserve">
          <source>InnoDB and XtraDB perform some encryption and decryption operations with ba...</source>
          <target state="translated">InnoDB와 XtraDB는 일부 암호화 및 암호 해독 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="e81713dced293efeec4cac930157b620dd2fe7b6" translate="yes" xml:space="preserve">
          <source>InnoDB and XtraDB perform some encryption and decryption operations with background encryption threads. The &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encryption_threads&quot;&gt;innodb_encryption_threads&lt;/a&gt;&lt;/code&gt; system variable controls the number of threads that the storage engine uses for encryption-related background operations, including encrypting and decrypting pages after key rotations or configuration changes, and &lt;a href=&quot;../innodb-data-scrubbing/index&quot;&gt;scrubbing&lt;/a&gt; data to permanently delete it.</source>
          <target state="translated">InnoDB 및 XtraDB는 백그라운드 암호화 스레드를 사용하여 일부 암호화 및 암호 해독 작업을 수행합니다. &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encryption_threads&quot;&gt;innodb_encryption_threads&lt;/a&gt;&lt;/code&gt; 의 시스템 변수를 제어 스레드의 수를 그 암호화 및 키 순환 또는 구성 변경 후 페이지를 암호 해독 등을 포함한 암호화 관련 배경 작업을위한 스토리지 엔진을 사용하는 &lt;a href=&quot;../innodb-data-scrubbing/index&quot;&gt;스크럽&lt;/a&gt; 영구적으로 삭제 된 데이터를.</target>
        </trans-unit>
        <trans-unit id="62cd644f1c5fb3d51dd3e84c490c54dc8d19bd83" translate="yes" xml:space="preserve">
          <source>InnoDB and XtraDB perform the following encryption and decryption operations &lt;strong&gt;without&lt;/strong&gt; using background encryption threads:</source>
          <target state="translated">InnoDB 및 XtraDB는 백그라운드 암호화 스레드 &lt;strong&gt;를&lt;/strong&gt; 사용 &lt;strong&gt;하지 않고&lt;/strong&gt; 다음과 같은 암호화 및 암호 해독 작업 &lt;strong&gt;을&lt;/strong&gt; 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="16689fb54bba36a1a2c46c475c45a6832fb31e0d" translate="yes" xml:space="preserve">
          <source>InnoDB and XtraDB perform the following encryption and decryption operations using background encryption threads:</source>
          <target state="translated">InnoDB 및 XtraDB는 백그라운드 암호화 스레드를 사용하여 다음과 같은 암호화 및 암호 해독 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="ebedad48c50435939437180f68542ca8b77ea768" translate="yes" xml:space="preserve">
          <source>InnoDB and undo</source>
          <target state="translated">InnoDB 및 실행 취소</target>
        </trans-unit>
        <trans-unit id="e7b808bbcc6e2b8c918ee6e8b7cfaeeab65119ea" translate="yes" xml:space="preserve">
          <source>InnoDB automatically uses the &lt;code&gt;COMPRESSED&lt;/code&gt; row format for a table if the &lt;code&gt;&lt;a href=&quot;../library/create-table/index#key_block_size&quot;&gt;KEY_BLOCK_SIZE&lt;/a&gt;&lt;/code&gt; table option is set to some value in a &lt;code&gt;&lt;a href=&quot;../create-table/index&quot;&gt;CREATE TABLE&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt;&lt;/code&gt; statement. For example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../library/create-table/index#key_block_size&quot;&gt;KEY_BLOCK_SIZE&lt;/a&gt;&lt;/code&gt; 테이블 옵션이 &lt;code&gt;&lt;a href=&quot;../create-table/index&quot;&gt;CREATE TABLE&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt;&lt;/code&gt; 문 에서 일부 값으로 설정된 경우 InnoDB는 자동으로 테이블에 &lt;code&gt;COMPRESSED&lt;/code&gt; 행 형식을 사용합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="24d7a4ed745bb393c957e7bdc297b196e9fdd614" translate="yes" xml:space="preserve">
          <source>InnoDB buffer pool information.</source>
          <target state="translated">InnoDB 버퍼 풀 정보.</target>
        </trans-unit>
        <trans-unit id="a152e7ac45f1ce1bf22678c328d9f023111e2157" translate="yes" xml:space="preserve">
          <source>InnoDB chunking recommendation</source>
          <target state="translated">InnoDB 청킹 추천</target>
        </trans-unit>
        <trans-unit id="6e5c179f53750b499dbebac584049660de56d4a0" translate="yes" xml:space="preserve">
          <source>InnoDB column information.</source>
          <target state="translated">InnoDB 열 정보.</target>
        </trans-unit>
        <trans-unit id="68d54dad2132224fb6ec9bb8da221d90f00d082e" translate="yes" xml:space="preserve">
          <source>InnoDB creates some system tables within the InnoDB System Tablespace:</source>
          <target state="translated">InnoDB는 InnoDB 시스템 테이블 스페이스 내에 일부 시스템 테이블을 생성합니다 :</target>
        </trans-unit>
        <trans-unit id="31720488b64a7b5cc3e1470d29a690a5c40b80ea" translate="yes" xml:space="preserve">
          <source>InnoDB data files after instant &lt;code&gt;&lt;a href=&quot;../alter-table/index#add-column&quot;&gt;ALTER TABLE ... ADD COLUMN&lt;/a&gt;&lt;/code&gt; cannot be imported to older versions of MariaDB or MySQL without first being rebuilt.</source>
          <target state="translated">인스턴트 &lt;code&gt;&lt;a href=&quot;../alter-table/index#add-column&quot;&gt;ALTER TABLE ... ADD COLUMN&lt;/a&gt;&lt;/code&gt; 후 InnoDB 데이터 파일 은 먼저 다시 빌드하지 않고는 이전 버전의 MariaDB 또는 MySQL로 가져올 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="05bf6b5e8e8b1483baeb7e7f06ac5bebcd3530eb" translate="yes" xml:space="preserve">
          <source>InnoDB defaults to allocating 12M to the &lt;code&gt;ibdata1&lt;/code&gt; file for the system tablespace. While this is sufficient for most use cases, it may not be for all. You may find after using MariaDB for a while that the allocation is too small for the system tablespace or it grows too large for your disk. Fortunately, you can adjust this size as need later.</source>
          <target state="translated">InnoDB는 기본적으로 시스템 테이블 스페이스 의 &lt;code&gt;ibdata1&lt;/code&gt; 파일에 12M을 할당 합니다. 이것이 대부분의 유스 케이스에 충분하지만 전부는 아닙니다. MariaDB를 잠시 사용한 후 시스템 테이블 공간에 대한 할당이 너무 작거나 디스크에 비해 너무 커질 수 있습니다. 다행히 나중에이 크기를 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b131b98889dfde5d0b4e73f0d00a4c6769c0798" translate="yes" xml:space="preserve">
          <source>InnoDB does &lt;strong&gt;not&lt;/strong&gt; support adding a &lt;code&gt;&lt;a href=&quot;../full-text-indexes/index&quot;&gt;FULLTEXT&lt;/a&gt;&lt;/code&gt; index to a table with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INSTANT&lt;/code&gt;.</source>
          <target state="translated">InnoDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;INSTANT&lt;/code&gt; 로 설정된 테이블에 &lt;code&gt;&lt;a href=&quot;../full-text-indexes/index&quot;&gt;FULLTEXT&lt;/a&gt;&lt;/code&gt; 인덱스 추가를 지원 하지 &lt;strong&gt;않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="41ff6d396c57a9a968c0f9d3621c30944afd1300" translate="yes" xml:space="preserve">
          <source>InnoDB does &lt;strong&gt;not&lt;/strong&gt; support adding a &lt;code&gt;&lt;a href=&quot;../spatial-index/index&quot;&gt;SPATIAL&lt;/a&gt;&lt;/code&gt; index to a table with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INSTANT&lt;/code&gt;.</source>
          <target state="translated">InnoDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;INSTANT&lt;/code&gt; 로 설정된 테이블에 &lt;code&gt;&lt;a href=&quot;../spatial-index/index&quot;&gt;SPATIAL&lt;/a&gt;&lt;/code&gt; 인덱스 추가를 지원 하지 &lt;strong&gt;않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="f3c9ffd17dfe72de73a3040126b990a37c7fee3e" translate="yes" xml:space="preserve">
          <source>InnoDB does &lt;strong&gt;not&lt;/strong&gt; support adding a plain index to a table with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INSTANT&lt;/code&gt;.</source>
          <target state="translated">InnoDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;INSTANT&lt;/code&gt; 로 설정된 테이블에 일반 인덱스 추가를 지원 하지 &lt;strong&gt;않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c4ff461bd086044a16c9a0571a12cc4c20726a4d" translate="yes" xml:space="preserve">
          <source>InnoDB does &lt;strong&gt;not&lt;/strong&gt; support adding a primary key to a table with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INSTANT&lt;/code&gt;.</source>
          <target state="translated">InnoDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;INSTANT&lt;/code&gt; 로 설정된 테이블에 기본 키 추가를 지원 하지 &lt;strong&gt;않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="ca85bb04db7454ac8b3191bc03a800ac480462d2" translate="yes" xml:space="preserve">
          <source>InnoDB does &lt;strong&gt;not&lt;/strong&gt; support adding a primary key to a table with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;NOCOPY&lt;/code&gt;.</source>
          <target state="translated">InnoDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;NOCOPY&lt;/code&gt; 로 설정된 테이블에 기본 키 추가를 지원 하지 &lt;strong&gt;않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="b47f302be7049ca4dee0221657d2a8cbd4dfb7c6" translate="yes" xml:space="preserve">
          <source>InnoDB does &lt;strong&gt;not&lt;/strong&gt; support adding foreign key constraints to a table with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INSTANT&lt;/code&gt;.</source>
          <target state="translated">InnoDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;INSTANT&lt;/code&gt; 로 설정된 테이블에 외래 키 제약 조건 추가를 지원 하지 &lt;strong&gt;않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="ce3bb79ff13684d53f2d32717a0622beb8caf5f7" translate="yes" xml:space="preserve">
          <source>InnoDB does &lt;strong&gt;not&lt;/strong&gt; support changing a table's &lt;a href=&quot;../innodb-storage-formats/index&quot;&gt;row format&lt;/a&gt; with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INSTANT&lt;/code&gt;.</source>
          <target state="translated">InnoDB는 않습니다 &lt;strong&gt;하지&lt;/strong&gt; 테이블의 변경을 지원 &lt;a href=&quot;../innodb-storage-formats/index&quot;&gt;행 형식을&lt;/a&gt; 가진 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 으로 설정 &lt;code&gt;INSTANT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="19b5a6067782139983e049516c55326366f7ce0f" translate="yes" xml:space="preserve">
          <source>InnoDB does &lt;strong&gt;not&lt;/strong&gt; support changing a table's &lt;a href=&quot;../innodb-storage-formats/index&quot;&gt;row format&lt;/a&gt; with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;NOCOPY&lt;/code&gt;.</source>
          <target state="translated">InnoDB는 않습니다 &lt;strong&gt;하지&lt;/strong&gt; 테이블의 변경을 지원 &lt;a href=&quot;../innodb-storage-formats/index&quot;&gt;행 형식&lt;/a&gt; 으로 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 로 설정 &lt;code&gt;NOCOPY&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f259ac00eee32972a655182439b23da7aeeadd6f" translate="yes" xml:space="preserve">
          <source>InnoDB does &lt;strong&gt;not&lt;/strong&gt; support changing a table's &lt;code&gt;&lt;a href=&quot;../create-table/index#page_compressed&quot;&gt;PAGE_COMPRESSED&lt;/a&gt;&lt;/code&gt; value from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;0&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;NOCOPY&lt;/code&gt;.</source>
          <target state="translated">InnoDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;NOCOPY&lt;/code&gt; 로 설정된 테이블의 &lt;code&gt;&lt;a href=&quot;../create-table/index#page_compressed&quot;&gt;PAGE_COMPRESSED&lt;/a&gt;&lt;/code&gt; 값을 &lt;code&gt;1&lt;/code&gt; 에서 &lt;code&gt;0&lt;/code&gt; 으로 변경하는 &lt;strong&gt;것을&lt;/strong&gt; 지원 하지 &lt;strong&gt;않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="fdc3303a44ccfa410be3d4d8867a83743ee9a28a" translate="yes" xml:space="preserve">
          <source>InnoDB does &lt;strong&gt;not&lt;/strong&gt; support changing a table's &lt;code&gt;&lt;a href=&quot;../innodb-storage-formats/index#using-the-compressed-row-format&quot;&gt;KEY_BLOCK_SIZE&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INSTANT&lt;/code&gt;.</source>
          <target state="translated">InnoDB는 않습니다 &lt;strong&gt;하지&lt;/strong&gt; 테이블의 변경을 지원 &lt;code&gt;&lt;a href=&quot;../innodb-storage-formats/index#using-the-compressed-row-format&quot;&gt;KEY_BLOCK_SIZE&lt;/a&gt;&lt;/code&gt; 을 함께 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 으로 설정 &lt;code&gt;INSTANT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc8eeaeaf33645603222bc9e366338be29ee9fb7" translate="yes" xml:space="preserve">
          <source>InnoDB does &lt;strong&gt;not&lt;/strong&gt; support changing a table's &lt;code&gt;&lt;a href=&quot;../innodb-storage-formats/index#using-the-compressed-row-format&quot;&gt;KEY_BLOCK_SIZE&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;NOCOPY&lt;/code&gt;.</source>
          <target state="translated">InnoDB는 않습니다 &lt;strong&gt;하지&lt;/strong&gt; 테이블의 변경을 지원 &lt;code&gt;&lt;a href=&quot;../innodb-storage-formats/index#using-the-compressed-row-format&quot;&gt;KEY_BLOCK_SIZE&lt;/a&gt;&lt;/code&gt; 을 함께 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 로 설정 &lt;code&gt;NOCOPY&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ae7ad40ad7147a9bfd17865938f6f12447aea0e2" translate="yes" xml:space="preserve">
          <source>InnoDB does &lt;strong&gt;not&lt;/strong&gt; support dropping &lt;a href=&quot;../system-versioned-tables/index&quot;&gt;system versioning&lt;/a&gt; from a table with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INSTANT&lt;/code&gt;.</source>
          <target state="translated">InnoDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;INSTANT&lt;/code&gt; 로 설정된 테이블에서 &lt;a href=&quot;../system-versioned-tables/index&quot;&gt;시스템 버저 닝&lt;/a&gt; 삭제를 지원 하지 &lt;strong&gt;않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="6ec7e17671cec5717e5c2d126a4881807edbc4da" translate="yes" xml:space="preserve">
          <source>InnoDB does &lt;strong&gt;not&lt;/strong&gt; support dropping &lt;a href=&quot;../system-versioned-tables/index&quot;&gt;system versioning&lt;/a&gt; from a table with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;NOCOPY&lt;/code&gt;.</source>
          <target state="translated">InnoDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;NOCOPY&lt;/code&gt; 로 설정된 테이블에서 &lt;a href=&quot;../system-versioned-tables/index&quot;&gt;시스템 버전&lt;/a&gt; 제거를 지원 하지 &lt;strong&gt;않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="b5908e23a8067d5692614b2dfb1c3ff06d76db26" translate="yes" xml:space="preserve">
          <source>InnoDB does &lt;strong&gt;not&lt;/strong&gt; support dropping a primary key with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INPLACE&lt;/code&gt; in most cases.</source>
          <target state="translated">InnoDB는 대부분의 경우 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;INPLACE&lt;/code&gt; 로 설정된 기본 키 삭제를 지원 하지 &lt;strong&gt;않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="f1dac6f43356b2d380c31b171103948f2f2a178f" translate="yes" xml:space="preserve">
          <source>InnoDB does &lt;strong&gt;not&lt;/strong&gt; support dropping a primary key with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INSTANT&lt;/code&gt;.</source>
          <target state="translated">InnoDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;INSTANT&lt;/code&gt; 로 설정된 기본 키 삭제를 지원 하지 &lt;strong&gt;않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="41bf774edea0cc395887b6ff227b44617fc61f41" translate="yes" xml:space="preserve">
          <source>InnoDB does &lt;strong&gt;not&lt;/strong&gt; support dropping a primary key with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;NOCOPY&lt;/code&gt;.</source>
          <target state="translated">InnoDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;NOCOPY&lt;/code&gt; 로 설정된 기본 키 삭제를 지원 하지 &lt;strong&gt;않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="35f0b9c0d2cedfe812a292b8944e05fe2f9e80af" translate="yes" xml:space="preserve">
          <source>InnoDB does &lt;strong&gt;not&lt;/strong&gt; support forcing a table rebuild with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INSTANT&lt;/code&gt;.</source>
          <target state="translated">InnoDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;INSTANT&lt;/code&gt; 로 설정된 테이블 재구성을 지원 하지 &lt;strong&gt;않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c4a35167416ab6ce5c5af7b119244789dfb2db63" translate="yes" xml:space="preserve">
          <source>InnoDB does &lt;strong&gt;not&lt;/strong&gt; support forcing a table rebuild with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;NOCOPY&lt;/code&gt;.</source>
          <target state="translated">InnoDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;NOCOPY&lt;/code&gt; 로 설정된 테이블 재구성을 지원 하지 &lt;strong&gt;않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="4be87fd1d3133e2e4346b242f8a0e159cf62f969" translate="yes" xml:space="preserve">
          <source>InnoDB does &lt;strong&gt;not&lt;/strong&gt; support modifying a column to &lt;strong&gt;not&lt;/strong&gt; allow &lt;code&gt;&lt;a href=&quot;../create-table/index#null-and-not-null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; values with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INSTANT&lt;/code&gt;.</source>
          <target state="translated">InnoDB는 않습니다 &lt;strong&gt;하지&lt;/strong&gt; 에 열을 수정 지원 &lt;strong&gt;하지&lt;/strong&gt; 수 &lt;code&gt;&lt;a href=&quot;../create-table/index#null-and-not-null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; 의 와 값 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 로 설정 &lt;code&gt;INSTANT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a36782c69cbfcb9dee24ff6a45a0375f4de9c9e2" translate="yes" xml:space="preserve">
          <source>InnoDB does &lt;strong&gt;not&lt;/strong&gt; support modifying a column to &lt;strong&gt;not&lt;/strong&gt; allow &lt;code&gt;&lt;a href=&quot;../create-table/index#null-and-not-null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; values with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;NOCOPY&lt;/code&gt;.</source>
          <target state="translated">InnoDB는 않습니다 &lt;strong&gt;하지&lt;/strong&gt; 에 열을 수정 지원 &lt;strong&gt;하지&lt;/strong&gt; 수 &lt;code&gt;&lt;a href=&quot;../create-table/index#null-and-not-null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; 의 와 값 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 로 설정 &lt;code&gt;NOCOPY&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="67f2470cd0c2d8d435e61628e3ae9fbeb9c0cb46" translate="yes" xml:space="preserve">
          <source>InnoDB does &lt;strong&gt;not&lt;/strong&gt; support modifying a column's data type with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INPLACE&lt;/code&gt; in most cases. There are some exceptions:</source>
          <target state="translated">InnoDB는 수행 &lt;strong&gt;하지&lt;/strong&gt; 대부분의 경우 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;INPLACE&lt;/code&gt; 로 설정된 열의 데이터 유형 수정을 지원 . 몇 가지 예외가 있습니다 :</target>
        </trans-unit>
        <trans-unit id="8c1ba00bd708c8f158d773d76d37ea171425ece4" translate="yes" xml:space="preserve">
          <source>InnoDB does &lt;strong&gt;not&lt;/strong&gt; support modifying a column's data type with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INSTANT&lt;/code&gt; in most cases. There are some exceptions:</source>
          <target state="translated">InnoDB는 다음을 사용 하여 열의 데이터 유형 수정을 지원 하지 &lt;strong&gt;않습니다.&lt;/strong&gt; &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 대부분의 경우 ALGORITHM 이 &lt;code&gt;INSTANT&lt;/code&gt; 로설정된. 몇 가지 예외가 있습니다 :</target>
        </trans-unit>
        <trans-unit id="01f6cf3bfd77f8b546198bd39d394703c5652e93" translate="yes" xml:space="preserve">
          <source>InnoDB does &lt;strong&gt;not&lt;/strong&gt; support modifying a column's data type with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;NOCOPY&lt;/code&gt; in most cases. There are a few exceptions in the cases where the operation supports having the &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; clause set to &lt;code&gt;INSTANT&lt;/code&gt;.</source>
          <target state="translated">InnoDB는 대부분의 경우 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;NOCOPY&lt;/code&gt; 로 설정된 열의 데이터 유형 수정을 지원 하지 &lt;strong&gt;않습니다&lt;/strong&gt; . 작업이 다음을 지원하는 경우 몇 가지 예외가 있습니다. &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 절을 &lt;code&gt;INSTANT&lt;/code&gt; 로 설정하도록.</target>
        </trans-unit>
        <trans-unit id="c6052d8e94b00eb7d5c72a433dec2bd0838d1c40" translate="yes" xml:space="preserve">
          <source>InnoDB does &lt;strong&gt;not&lt;/strong&gt; support optimizing a table with with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INSTANT&lt;/code&gt;.</source>
          <target state="translated">InnoDB는 로 테이블 최적화를 지원 하지 &lt;strong&gt;않습니다&lt;/strong&gt; &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;INSTANT&lt;/code&gt; 로 설정된.</target>
        </trans-unit>
        <trans-unit id="5f03c995d383e363be14e0f4b54598948f5610b2" translate="yes" xml:space="preserve">
          <source>InnoDB does &lt;strong&gt;not&lt;/strong&gt; support optimizing a table with with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;NOCOPY&lt;/code&gt;.</source>
          <target state="translated">InnoDB는 로 테이블 최적화를 지원 하지 &lt;strong&gt;않습니다&lt;/strong&gt; &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;NOCOPY&lt;/code&gt; 로 설정된.</target>
        </trans-unit>
        <trans-unit id="30d4dbe99d0834790e3274101bad0cbd6c454636" translate="yes" xml:space="preserve">
          <source>InnoDB does all its caching in a the &lt;a href=&quot;../xtradbinnodb-buffer-pool/index&quot;&gt;buffer pool&lt;/a&gt;, whose size is controlled by &lt;a href=&quot;../innodb-system-variables/index#innodb_buffer_pool_size&quot;&gt;innodb_buffer_pool_size&lt;/a&gt;. By default it contains 16KB data and index blocks from the open tables (see &lt;a href=&quot;../innodb-system-variables/index#innodb_page_size&quot;&gt;innodb_page_size&lt;/a&gt;), plus some maintenance overhead.</source>
          <target state="translated">이노는 상기의 모든 캐시 않는 &lt;a href=&quot;../xtradbinnodb-buffer-pool/index&quot;&gt;버퍼 풀&lt;/a&gt; 크기가 제어되어,&lt;a href=&quot;../innodb-system-variables/index#innodb_buffer_pool_size&quot;&gt; innodb_buffer_pool_size에&lt;/a&gt; . 기본적으로 열린 테이블 ( &lt;a href=&quot;../innodb-system-variables/index#innodb_page_size&quot;&gt;innodb_page_size&lt;/a&gt; 참조 )의 16KB 데이터 및 인덱스 블록 과 유지 보수 오버 헤드가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="9b128606e5b58d0588113917fb29cf846057f68f" translate="yes" xml:space="preserve">
          <source>InnoDB does not currently have an easy way to check all existing tables to determine which tables have this problem. See &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-20400&quot;&gt;MDEV-20400&lt;/a&gt; for more information.</source>
          <target state="translated">InnoDB는 현재 기존의 모든 테이블을 확인하여이 문제가있는 테이블을 쉽게 확인할 수있는 방법이 없습니다. 자세한 내용은 &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-20400&quot;&gt;MDEV-20400&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e5fa42ad3f7b40ffe4d86e858943b19f27555fdd" translate="yes" xml:space="preserve">
          <source>InnoDB does not currently have an easy way to check which existing tables have this problem. See &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-20400&quot;&gt;MDEV-20400&lt;/a&gt; for more information.</source>
          <target state="translated">InnoDB는 현재이 문제가있는 기존 테이블을 쉽게 확인할 수있는 방법이 없습니다. 보다&lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-20400&quot;&gt; MDEV-20400&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d7d87b1b77fcda19d22d81ee3e5d2a6be8e3d189" translate="yes" xml:space="preserve">
          <source>InnoDB does not use a sort buffer.</source>
          <target state="translated">InnoDB는 정렬 버퍼를 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d5473d59285de615687c5fbafac4e2dffa5dd1b7" translate="yes" xml:space="preserve">
          <source>InnoDB does supports adding foreign key constraints to a table with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;NOCOPY&lt;/code&gt;. In order to add a new foreign key constraint to a table with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;NOCOPY&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#foreign_key_checks&quot;&gt;foreign_key_checks&lt;/a&gt;&lt;/code&gt; system variable needs to be set to &lt;code&gt;OFF&lt;/code&gt;. If it is set to &lt;code&gt;ON&lt;/code&gt;, then &lt;code&gt;ALGORITHM=COPY&lt;/code&gt; is required.</source>
          <target state="translated">InnoDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;NOCOPY&lt;/code&gt; 로 설정된 테이블에 외래 키 제약 조건 추가를 지원합니다 . &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;NOCOPY&lt;/code&gt; 로 설정된 테이블에 새 외래 키 제약 조건을 추가 하려면 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#foreign_key_checks&quot;&gt;foreign_key_checks&lt;/a&gt;&lt;/code&gt; 시스템 변수를 &lt;code&gt;OFF&lt;/code&gt; 로 설정해야합니다 . &lt;code&gt;ON&lt;/code&gt; 으로 설정 되면 &lt;code&gt;ALGORITHM=COPY&lt;/code&gt; 가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="17a8e1b5f95a6ae98d546301ab9d9915db5fc1c6" translate="yes" xml:space="preserve">
          <source>InnoDB encrypts the &lt;a href=&quot;../innodb-redo-log/index&quot;&gt;Redo Log&lt;/a&gt; using the encryption key with the ID &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">InnoDB 는 ID가 &lt;code&gt;1&lt;/code&gt; 인 암호화 키를 사용하여 &lt;a href=&quot;../innodb-redo-log/index&quot;&gt;Redo Log&lt;/a&gt; 를 암호화합니다 .</target>
        </trans-unit>
        <trans-unit id="702ecf87452d87a1c7339ccc4b92c20353d6043a" translate="yes" xml:space="preserve">
          <source>InnoDB encrypts the &lt;a href=&quot;../innodb-temporary-tablespaces/index&quot;&gt;temporary tablespace&lt;/a&gt; using the encryption key with the ID &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">InnoDB 는 ID가 &lt;code&gt;1&lt;/code&gt; 인 암호화 키를 사용하여 &lt;a href=&quot;../innodb-temporary-tablespaces/index&quot;&gt;임시 테이블 스페이스&lt;/a&gt; 를 암호화합니다 .</target>
        </trans-unit>
        <trans-unit id="2dbd8fc19d752a091d0822bff1bd998ce9d02220" translate="yes" xml:space="preserve">
          <source>InnoDB file-per-table tablespaces</source>
          <target state="translated">InnoDB 테이블 당 테이블 스페이스</target>
        </trans-unit>
        <trans-unit id="320bb6014a6473fefd189b423769b5ad2be76295" translate="yes" xml:space="preserve">
          <source>InnoDB file-per-table tablespaces can use different &lt;a href=&quot;../xtradbinnodb-storage-formats/index&quot;&gt;row formats&lt;/a&gt;. A specific row format can be specified when creating a table either by setting the &lt;code&gt;&lt;a href=&quot;../create-table/index#row_format&quot;&gt;ROW_FORMAT&lt;/a&gt;&lt;/code&gt; table option or by the setting the &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_default_row_format&quot;&gt;innodb_default_row_format&lt;/a&gt;&lt;/code&gt; system variable. See &lt;a href=&quot;../innodb-storage-formats/index#setting-a-tables-row-format&quot;&gt;Setting a Table's Row Format&lt;/a&gt; for more information on how to set an InnoDB table's row format.</source>
          <target state="translated">InnoDB 테이블 당 테이블 스페이스는 다른 &lt;a href=&quot;../xtradbinnodb-storage-formats/index&quot;&gt;행 형식을&lt;/a&gt; 사용할 수 있습니다 . &lt;code&gt;&lt;a href=&quot;../create-table/index#row_format&quot;&gt;ROW_FORMAT&lt;/a&gt;&lt;/code&gt; 테이블 옵션을 설정하거나 &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_default_row_format&quot;&gt;innodb_default_row_format&lt;/a&gt;&lt;/code&gt; 시스템 변수 를 설정하여 테이블을 작성할 때 특정 행 형식을 지정할 수 있습니다 . InnoDB 테이블의 행 형식을 설정하는 방법에 대한 자세한 내용 &lt;a href=&quot;../innodb-storage-formats/index#setting-a-tables-row-format&quot;&gt;은 테이블의 행 형식 설정을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5fb12a78c8ae7b7f3900d9fdd047cb67ac0ba4f1" translate="yes" xml:space="preserve">
          <source>InnoDB file-per-table tablespaces: what they are, where they're located, ho...</source>
          <target state="translated">InnoDB 테이블 당 테이블 스페이스 : 현재 위치, 위치, 위치</target>
        </trans-unit>
        <trans-unit id="0e82655a57f914e1e60a3e46af004955f313b583" translate="yes" xml:space="preserve">
          <source>InnoDB foreign key information.</source>
          <target state="translated">InnoDB 외래 키 정보</target>
        </trans-unit>
        <trans-unit id="0e7eb1f358b76d3d7639ca684f7cc1a64b91f4e4" translate="yes" xml:space="preserve">
          <source>InnoDB fulltext information.</source>
          <target state="translated">InnoDB 전문 정보.</target>
        </trans-unit>
        <trans-unit id="a943f607d971b58843d83970e5ae4e77bde27aba" translate="yes" xml:space="preserve">
          <source>InnoDB fulltext metadata.</source>
          <target state="translated">InnoDB 전체 텍스트 메타 데이터.</target>
        </trans-unit>
        <trans-unit id="9669cd98738238e69e82331826e0b94b43032086" translate="yes" xml:space="preserve">
          <source>InnoDB has essentially no need for CHECK, OPTIMIZE, or ANALYZE. Remove them from your maintenance scripts. (No real harm if you keep them.)</source>
          <target state="translated">InnoDB는 본질적으로 CHECK, OPTIMIZE 또는 ANALYZE가 필요하지 않습니다. 유지 보수 스크립트에서 제거하십시오. (만두면 아무런 해가 없습니다.)</target>
        </trans-unit>
        <trans-unit id="62048fbf0bb4fb9a90e74c6056677e04436ec93b" translate="yes" xml:space="preserve">
          <source>InnoDB has the following table-specific limitations.</source>
          <target state="translated">InnoDB에는 다음과 같은 테이블 별 제한 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="bde26f3019b8767803d145217b0efcfd8af73794" translate="yes" xml:space="preserve">
          <source>InnoDB has to write the undo information to its transaction logs; this significantly increases the I/O required.</source>
          <target state="translated">InnoDB는 실행 취소 정보를 트랜잭션 로그에 기록해야합니다. 이것은 필요한 I / O를 크게 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="24114f25a4bf344526be050c29380ea194aaa65d" translate="yes" xml:space="preserve">
          <source>InnoDB holepunch compression vs the filesystem in MariaDB 10.1</source>
          <target state="translated">MariaDB 10.1의 파일 시스템과 InnoDB 홀 펀치 압축</target>
        </trans-unit>
        <trans-unit id="76ea5fc3329042519679d75f27d4fe9e80e89a59" translate="yes" xml:space="preserve">
          <source>InnoDB index information.</source>
          <target state="translated">InnoDB 인덱스 정보.</target>
        </trans-unit>
        <trans-unit id="ca55a6af51c2eefb51b8b262e7fb47b176d61a42" translate="yes" xml:space="preserve">
          <source>InnoDB is better than MyISAM because of way the two keys are structured.</source>
          <target state="translated">InnoDB는 두 키가 구조화되어 있기 때문에 MyISAM보다 낫습니다.</target>
        </trans-unit>
        <trans-unit id="56a7b24d52bfaea90685b3bc3671fb8c629e99b7" translate="yes" xml:space="preserve">
          <source>InnoDB is block-structured, organized in a BTree on the PRIMARY KEY. An isolated deleted row leaves a block less full. A lot of deleted rows can lead to coalescing of adjacent blocks. (Blocks are normally 16KB - see &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_page_size&quot;&gt;innodb_page_size&lt;/a&gt;.)</source>
          <target state="translated">InnoDB는 기본 키의 BTree로 구성된 블록 구조입니다. 격리 된 삭제 된 행은 블록을 덜 가득 채 웁니다. 삭제 된 행이 많으면 인접한 블록이 병합 될 수 있습니다. (블록은 일반적으로 16KB입니다 &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_page_size&quot;&gt;-innodb_page_size&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="7b44f6dff7f130fa103d171ed661aabcd7344f0d" translate="yes" xml:space="preserve">
          <source>InnoDB is in read only mode.</source>
          <target state="translated">InnoDB가 읽기 전용 모드입니다.</target>
        </trans-unit>
        <trans-unit id="aa87c217fa3d353456b8e01c383e0fb563954b41" translate="yes" xml:space="preserve">
          <source>InnoDB lock information.</source>
          <target state="translated">InnoDB 잠금 정보.</target>
        </trans-unit>
        <trans-unit id="716f2040094835b09a4e95a1588730d5ec8a67d7" translate="yes" xml:space="preserve">
          <source>InnoDB might use new file formats in the future. Each format will have an identifier from 0 to 25, and a name. The names have already been decided, and are animal names listed in an alphabetical order: Antelope, Barracuda, Cheetah, Dragon, Elk, Fox, Gazelle, Hornet, Impala, Jaguar, Kangaroo, Leopard, Moose, Nautilus, Ocelot, Porpoise, Quail, Rabbit, Shark, Tiger, Urchin, Viper, Whale, Xenops, Yak and Zebra.</source>
          <target state="translated">InnoDB는 향후 새로운 파일 형식을 사용할 수 있습니다. 각 형식에는 0에서 25까지의 식별자와 이름이 있습니다. 이름은 이미 정해져 있으며 영양, 바라쿠다, 치타, 용, 엘크, 여우, 가젤, 호넷, 임팔라, 재규어, 캥거루, 표범, 무스, 노틸러스, 오셀롯, Porpoise, 메추라기 등 알파벳 순서로 나열된 동물 이름입니다. , 토끼, 상어, 호랑이, 성게, 독사, 고래, 제 노프, 야크 및 얼룩말.</target>
        </trans-unit>
        <trans-unit id="31e24db333c90310a6a3cb4a89dac81a645b4304" translate="yes" xml:space="preserve">
          <source>InnoDB only</source>
          <target state="translated">InnoDB 만</target>
        </trans-unit>
        <trans-unit id="1fdcd59ce6b02fc828ac0988af33327059e123cd" translate="yes" xml:space="preserve">
          <source>InnoDB only considers using overflow pages if the table's row size is greater than half of &lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_page_size&quot;&gt;innodb_page_size&lt;/a&gt;&lt;/code&gt;. If the row size is greater than this, then InnoDB chooses variable-length columns to be stored on overflow pages until the row size is less than half of &lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_page_size&quot;&gt;innodb_page_size&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">InnoDB는 테이블의 행 크기가 &lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_page_size&quot;&gt;innodb_page_size&lt;/a&gt;&lt;/code&gt; 의 절반보다 큰 경우 오버플로 페이지 사용 만 고려 합니다. 행 크기가 이보다 큰 경우 InnoDB는 행 크기가 &lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_page_size&quot;&gt;innodb_page_size&lt;/a&gt;&lt;/code&gt; 의 절반보다 작을 때까지 오버플로 페이지에 저장할 가변 길이 열을 선택합니다 .</target>
        </trans-unit>
        <trans-unit id="940a21086da7d7bf368278dddcdfefb9e50f4247" translate="yes" xml:space="preserve">
          <source>InnoDB only, always have PK.</source>
          <target state="translated">InnoDB에만 해당되며 항상 PK가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a76ced1684c4fe684eccf3ea419980dc3d5f3461" translate="yes" xml:space="preserve">
          <source>InnoDB only: &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_buffer_pool_size&quot;&gt;innodb_buffer_pool_size=0&lt;/a&gt; = 70% of RAM. If you have lots of RAM and are using 5.5 (or later), then consider having multiple pools. Recommend 1-16 &lt;a href=&quot;../innodb-system-variables/index#innodb_buffer_pool_instances&quot;&gt;innodb_buffer_pool_instances&lt;/a&gt;, such that each one is no smaller than 1GB. (Sorry, no metric on how much this will help; probably not a lot.)</source>
          <target state="translated">InnoDB 만 해당 : &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_buffer_pool_size&quot;&gt;innodb_buffer_pool_size = 0&lt;/a&gt; = RAM의 70 % RAM이 많고 5.5 이상을 사용하는 경우 여러 풀을 사용하는 것이 좋습니다. 1-16 &lt;a href=&quot;../innodb-system-variables/index#innodb_buffer_pool_instances&quot;&gt;innodb_buffer_pool_instances를&lt;/a&gt; 권장 하여 각각 1GB보다 작지 않도록하십시오. (죄송합니다, 이것이 얼마나 도움이 될지에 대한 통계는 없습니다. 아마 많이는 아닙니다.)</target>
        </trans-unit>
        <trans-unit id="44f9e8da8d64652b31301bc4081aa2cfd36a8470" translate="yes" xml:space="preserve">
          <source>InnoDB or XtraDB is normally the default storage engine with MariaDB.</source>
          <target state="translated">InnoDB 또는 XtraDB는 일반적으로 MariaDB의 기본 스토리지 엔진입니다.</target>
        </trans-unit>
        <trans-unit id="9e33794aebeb134e58def90ba272d27a35a5b698" translate="yes" xml:space="preserve">
          <source>InnoDB page cleaner threads flush dirty pages from the &lt;a href=&quot;../innodb-buffer-pool/index&quot;&gt;InnoDB buffer pool&lt;/a&gt;. These dirty pages are flushed using a least-recently used (LRU) algorithm.</source>
          <target state="translated">InnoDB 페이지 클리너 스레드는 &lt;a href=&quot;../innodb-buffer-pool/index&quot;&gt;InnoDB 버퍼 풀&lt;/a&gt; 에서 더티 페이지를 플러시 합니다 . 이러한 더티 페이지는 LRU (Least-Recently Used) 알고리즘을 사용하여 플러시됩니다.</target>
        </trans-unit>
        <trans-unit id="91a74cb8f1e24a78fc827d907663c00812898814" translate="yes" xml:space="preserve">
          <source>InnoDB page compression can be enabled for individual tables by setting the &lt;code&gt;&lt;a href=&quot;../create-table/index#page_compressed&quot;&gt;PAGE_COMPRESSED&lt;/a&gt;&lt;/code&gt; table option to &lt;code&gt;1&lt;/code&gt;. For example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../create-table/index#page_compressed&quot;&gt;PAGE_COMPRESSED&lt;/a&gt;&lt;/code&gt; 테이블 옵션을 &lt;code&gt;1&lt;/code&gt; 로 설정하여 개별 테이블에 대해 InnoDB 페이지 압축을 사용할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6414933b7e2c9065561191b5f3f7f4b10ce2fa96" translate="yes" xml:space="preserve">
          <source>InnoDB page compression can be monitored by querying the following status variables with &lt;code&gt;&lt;a href=&quot;../show-status/index&quot;&gt;SHOW GLOBAL STATUS&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../show-status/index&quot;&gt;SHOW GLOBAL STATUS&lt;/a&gt;&lt;/code&gt; 로 다음 상태 변수를 쿼리하여 InnoDB 페이지 압축을 모니터링 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a5821d834bc625f3e333c1ac1e30ead3440d7629" translate="yes" xml:space="preserve">
          <source>InnoDB page compression can be used on any storage device and any file system.</source>
          <target state="translated">InnoDB 페이지 압축은 모든 저장 장치 및 파일 시스템에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f776f43a64e8fdc72ae0af753480f72c24ce9fe" translate="yes" xml:space="preserve">
          <source>InnoDB page compression can encounter compression failures.</source>
          <target state="translated">InnoDB 페이지 압축시 압축 실패가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca490378f7877bfc67499537d30634814b2f37b0" translate="yes" xml:space="preserve">
          <source>InnoDB page compression is a modern way to compress your InnoDB tables. It is similar to InnoDB's &lt;code&gt;&lt;a href=&quot;../innodb-compressed-row-format/index&quot;&gt;COMPRESSED&lt;/a&gt;&lt;/code&gt; row format, but it has many advantages. Some of the differences are:</source>
          <target state="translated">InnoDB 페이지 압축은 InnoDB 테이블을 압축하는 현대적인 방법입니다. InnoDB의 &lt;code&gt;&lt;a href=&quot;../innodb-compressed-row-format/index&quot;&gt;COMPRESSED&lt;/a&gt;&lt;/code&gt; 행 형식 과 비슷 하지만 많은 장점이 있습니다. 차이점 중 일부는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="192f4301132ca7dad5c2332f7861d8cd7e9e2c1e" translate="yes" xml:space="preserve">
          <source>InnoDB page compression is also only supported if the InnoDB table is in a &lt;a href=&quot;../innodb-file-per-table-tablespaces/index&quot;&gt;file per-table&lt;/a&gt; tablespace. Therefore, the &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_file_per_table&quot;&gt;innodb_file_per_table&lt;/a&gt;&lt;/code&gt; system variable must be set to &lt;code&gt;ON&lt;/code&gt; to use InnoDB page compression.</source>
          <target state="translated">InnoDB 페이지 압축은 InnoDB 테이블이 &lt;a href=&quot;../innodb-file-per-table-tablespaces/index&quot;&gt;파일 별 테이블&lt;/a&gt; 스페이스 에있는 경우에만 지원됩니다 . 따라서 InnoDB 페이지 압축을 사용 하려면 &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_file_per_table&quot;&gt;innodb_file_per_table&lt;/a&gt;&lt;/code&gt; 시스템 변수를 &lt;code&gt;ON&lt;/code&gt; 으로 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="989d2ed3d603c3fb9e84032e017b2d4a23912cf6" translate="yes" xml:space="preserve">
          <source>InnoDB page compression is also only supported if the InnoDB table's &lt;a href=&quot;../innodb-row-formats-overview/index&quot;&gt;row format&lt;/a&gt; is &lt;code&gt;&lt;a href=&quot;../innodb-compact-row-format/index&quot;&gt;COMPACT&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../innodb-dynamic-row-format/index&quot;&gt;DYNAMIC&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">InnoDB 페이지 압축은 InnoDB 테이블의 &lt;a href=&quot;../innodb-row-formats-overview/index&quot;&gt;행 형식&lt;/a&gt; 이 &lt;code&gt;&lt;a href=&quot;../innodb-compact-row-format/index&quot;&gt;COMPACT&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../innodb-dynamic-row-format/index&quot;&gt;DYNAMIC&lt;/a&gt;&lt;/code&gt; 인 경우에만 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="811c5ecde38f8957b5366745f564047522a84480" translate="yes" xml:space="preserve">
          <source>InnoDB page compression is most beneficial on solid state drives (SSDs) and other flash storage. See &lt;a href=&quot;#optimized-for-flash-storage&quot;&gt;Optimized for Flash Storage&lt;/a&gt; for more information.</source>
          <target state="translated">InnoDB 페이지 압축은 SSD (Solid State Drive) 및 기타 플래시 스토리지에서 가장 유리합니다. 자세한 내용 &lt;a href=&quot;#optimized-for-flash-storage&quot;&gt;은 플래시 스토리지&lt;/a&gt; 에 최적화를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0670323586aa76ed2a849b2492f5af396f07f326" translate="yes" xml:space="preserve">
          <source>InnoDB page compression is most efficient on file systems that support sparse files. See &lt;a href=&quot;#saving-storage-space-with-sparse-files&quot;&gt;Saving Storage Space with Sparse Files&lt;/a&gt; for more information.</source>
          <target state="translated">InnoDB 페이지 압축은 스파 스 파일을 지원하는 파일 시스템에서 가장 효율적입니다. 자세한 내용 &lt;a href=&quot;#saving-storage-space-with-sparse-files&quot;&gt;은 스파 스 파일&lt;/a&gt; 로 저장 공간 저장 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="857563e9774699b98a85725b217e0b75cba9894a" translate="yes" xml:space="preserve">
          <source>InnoDB page compression is not enabled by default. However, InnoDB page compression can be enabled for just individual InnoDB tables or it can be enabled for all new InnoDB tables by default.</source>
          <target state="translated">InnoDB 페이지 압축은 기본적으로 활성화되어 있지 않습니다. 그러나 InnoDB 페이지 압축은 개별 InnoDB 테이블에 대해서만 활성화하거나 기본적으로 모든 새로운 InnoDB 테이블에 대해 활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b449336a467033cc6783717004ec6a932642964d" translate="yes" xml:space="preserve">
          <source>InnoDB page compression is only supported if the InnoDB table uses the &lt;code&gt;Barracuda&lt;/code&gt;&lt;a href=&quot;../xtradbinnodb-file-format/index&quot;&gt;file format&lt;/a&gt;.Therefore, in &lt;a href=&quot;../what-is-mariadb-101/index&quot;&gt;MariaDB 10.1&lt;/a&gt; and before, the &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_file_format&quot;&gt;innodb_file_format&lt;/a&gt;&lt;/code&gt; system variable must be set to &lt;code&gt;Barracuda&lt;/code&gt; to use InnoDB page compression.</source>
          <target state="translated">InnoDB의 테이블이 사용하는 경우 InnoDB의 페이지 압축에만 지원됩니다 &lt;code&gt;Barracuda&lt;/code&gt; &lt;a href=&quot;../xtradbinnodb-file-format/index&quot;&gt;파일 형식&lt;/a&gt; 으로, .Therefore을 &lt;a href=&quot;../what-is-mariadb-101/index&quot;&gt;MariaDB 10.1&lt;/a&gt; 및 이전과 &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_file_format&quot;&gt;innodb_file_format&lt;/a&gt;&lt;/code&gt; 의 시스템 변수로 설정해야합니다 &lt;code&gt;Barracuda&lt;/code&gt; 이노 페이지 압축을 사용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55cf6e5ab2d64648846e6f329fe72e4fad4eebb0" translate="yes" xml:space="preserve">
          <source>InnoDB page compression performs best when your storage device and file system support atomic writes, since that allows the &lt;a href=&quot;../xtradbinnodb-doublewrite-buffer/index&quot;&gt;InnoDB doublewrite buffer&lt;/a&gt; to be disabled. See &lt;a href=&quot;../atomic-write-support/index&quot;&gt;Atomic Write Support&lt;/a&gt; for more information.</source>
          <target state="translated">InnoDB 페이지 압축은 스토리지 장치 및 파일 시스템이 원자 쓰기를 지원할 때 가장 잘 수행됩니다. &lt;a href=&quot;../xtradbinnodb-doublewrite-buffer/index&quot;&gt;InnoDB 이중 쓰기 버퍼&lt;/a&gt; 를 비활성화 할 수 있기 때문입니다 . 자세한 내용은 &lt;a href=&quot;../atomic-write-support/index&quot;&gt;원자 쓰기 지원&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3933d4f927add088e4e37a46924dfccf3fa8c468" translate="yes" xml:space="preserve">
          <source>InnoDB page compression provides a way to compress InnoDB tables.</source>
          <target state="translated">InnoDB 페이지 압축은 InnoDB 테이블을 압축하는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4a06696af1fdf54888e680c225e972f86835082f" translate="yes" xml:space="preserve">
          <source>InnoDB page compression was designed to be optimized on solid state drives (SSDs) and other flash storage.</source>
          <target state="translated">InnoDB 페이지 압축은 SSD (Solid State Drive) 및 기타 플래시 스토리지에서 최적화되도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="5f7967313b0a263ec4cf818bef04466cfe74e76e" translate="yes" xml:space="preserve">
          <source>InnoDB page compression was developed by collaborating with &lt;a href=&quot;http://fusionio.com&quot;&gt;Fusion-io&lt;/a&gt;. Special thanks especially to Dhananjoy Das and Torben Mathiasen.</source>
          <target state="translated">InnoDB 페이지 압축은 &lt;a href=&quot;http://fusionio.com&quot;&gt;Fusion-io&lt;/a&gt; 와 협력하여 개발되었습니다 . 특히 Dhananjoy Das와 Torben Mathiasen에게 감사드립니다.</target>
        </trans-unit>
        <trans-unit id="8cd74356adf1061dfc2df7be613de559028cb205" translate="yes" xml:space="preserve">
          <source>InnoDB page compression was originally developed by collaborating with &lt;a href=&quot;http://fusionio.com&quot;&gt;Fusion-io&lt;/a&gt;. As a consequence, it was originally designed to work best on &lt;a href=&quot;../fusion-io-introduction/index&quot;&gt;FusionIO devices&lt;/a&gt; using &lt;a href=&quot;https://ieeexplore.ieee.org/document/6558434&quot;&gt;NVMFS&lt;/a&gt;. &lt;a href=&quot;http://fusionio.com&quot;&gt;Fusion-io&lt;/a&gt; has since been acquired by &lt;a href=&quot;https://www.westerndigital.com/&quot;&gt;Western Digital&lt;/a&gt;, and they have decided not to continue supporting &lt;a href=&quot;https://ieeexplore.ieee.org/document/6558434&quot;&gt;NVMFS&lt;/a&gt;.</source>
          <target state="translated">InnoDB 페이지 압축은 원래 &lt;a href=&quot;http://fusionio.com&quot;&gt;Fusion-io&lt;/a&gt; 와 협력하여 개발되었습니다 . 결과적으로 원래 &lt;a href=&quot;https://ieeexplore.ieee.org/document/6558434&quot;&gt;NVMFS를&lt;/a&gt; 사용 하는 &lt;a href=&quot;../fusion-io-introduction/index&quot;&gt;FusionIO 장치에서&lt;/a&gt; 가장 잘 작동하도록 설계되었습니다 . 이후 &lt;a href=&quot;http://fusionio.com&quot;&gt;Fusion-io&lt;/a&gt; 는 &lt;a href=&quot;https://www.westerndigital.com/&quot;&gt;Western Digital&lt;/a&gt; 에 인수되었으며 &lt;a href=&quot;https://ieeexplore.ieee.org/document/6558434&quot;&gt;NVMFS&lt;/a&gt; 를 계속 지원하지 않기로 결정했습니다 .</target>
        </trans-unit>
        <trans-unit id="cf0e27710a59667a4364557a6963d95e9b6cdfad" translate="yes" xml:space="preserve">
          <source>InnoDB page compression works without any issues on hard disk drives (HDDs). However, since its compression relies on the use of sparse files, the data may be somewhat fragmented on disk. This fragmentation may hurt performance on HDDs, since they handle random reads and writes much more slowly than flash storage.</source>
          <target state="translated">InnoDB 페이지 압축은 하드 디스크 드라이브 (HDD)에 아무런 문제없이 작동합니다. 그러나 압축은 스파 스 파일의 사용에 의존하기 때문에 데이터가 디스크에서 다소 조각화 될 수 있습니다. 이 단편화는 플래시 저장 장치보다 임의 읽기 및 쓰기 속도가 훨씬 느리기 때문에 HDD 성능을 저하시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="617ee0c6c4d0511c6b462ca206fe77b9d5e2e04a" translate="yes" xml:space="preserve">
          <source>InnoDB page compression's failure threshold can be configured. If InnoDB encounters more compression failures than the failure threshold, then it pads pages with zeroed out bytes before attempting to compress them as a way to reduce failures. If the failure rate stays above the failure threshold, then InnoDB pads pages with more zeroed out bytes in 128 byte increments.</source>
          <target state="translated">InnoDB 페이지 압축의 실패 임계 값을 구성 할 수 있습니다. InnoDB가 실패 임계 값보다 더 많은 압축 실패를 겪으면 실패를 줄이기위한 방법으로 페이지를 압축하기 전에 0 바이트로 페이지를 채 웁니다. 실패율이 실패 임계 값을 초과하면 InnoDB는 128 바이트 단위로 더 많은 제로 아웃 된 바이트로 페이지를 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="6a80afb9e6ebeca3819ee4555007ff0db5f1cf38" translate="yes" xml:space="preserve">
          <source>InnoDB page compression's maximum padding can also be configured.</source>
          <target state="translated">InnoDB 페이지 압축의 최대 패딩도 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15a00bfc9150ef060018a70f609512e024a8e74f" translate="yes" xml:space="preserve">
          <source>InnoDB page compression, which is more sophisticated than the COMPRESSED row format.</source>
          <target state="translated">COMPRESSED 행 형식보다 정교한 InnoDB 페이지 압축</target>
        </trans-unit>
        <trans-unit id="e6381c5bb6da3b83b973a19a41ba9411c441fc0d" translate="yes" xml:space="preserve">
          <source>InnoDB pages contain log sequence numbers, or LSN's. Whenever you modify a row on any InnoDB table on the database, the storage engine increments this number. When performing an incremental backup, Mariabackup checks the most recent LSN for the backup against the LSN's contained in the database. It then updates any of the backup files that have fallen behind.</source>
          <target state="translated">InnoDB 페이지에는 로그 시퀀스 번호 또는 LSN이 포함됩니다. 데이터베이스의 InnoDB 테이블에서 행을 수정할 때마다 스토리지 엔진이이 숫자를 증가시킵니다. 증분 백업을 수행 할 때 Mariabackup은 데이터베이스에 포함 된 LSN과 비교하여 가장 최근의 LSN에서 백업을 확인합니다. 그런 다음 뒤에 있던 백업 파일을 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="1b989d440db4a6629b27efc4b0728f5fb5b07590" translate="yes" xml:space="preserve">
          <source>InnoDB performance metrics.</source>
          <target state="translated">InnoDB 성능 지표.</target>
        </trans-unit>
        <trans-unit id="3410c5ad8af06facfd195b40cecd657faa13a7c3" translate="yes" xml:space="preserve">
          <source>InnoDB persistent statistics are stored on disk, leading to more consistent query plans.</source>
          <target state="translated">InnoDB 영구 통계는 디스크에 저장되어보다 일관된 쿼리 계획을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="baf9f35304492f971df74afb8b864ace408402c9" translate="yes" xml:space="preserve">
          <source>InnoDB presently supports one FULLTEXT index creation at a time</source>
          <target state="translated">InnoDB는 현재 한 번에 하나의 FULLTEXT 인덱스 생성을 지원합니다</target>
        </trans-unit>
        <trans-unit id="1437491e6d9a24c1d7097d1735ed32ca2700853d" translate="yes" xml:space="preserve">
          <source>InnoDB records the status of background encryption operations in the &lt;code&gt;&lt;a href=&quot;information-schema-innodb_tablespaces_encryption&quot;&gt;INNODB_TABLESPACES_ENCRYPTION&lt;/a&gt;&lt;/code&gt; table in the &lt;code&gt;&lt;a href=&quot;../information-schema/index&quot;&gt;information_schema&lt;/a&gt;&lt;/code&gt; database.</source>
          <target state="translated">InnoDB 는 &lt;code&gt;&lt;a href=&quot;../information-schema/index&quot;&gt;information_schema&lt;/a&gt;&lt;/code&gt; 암호화 &lt;code&gt;&lt;a href=&quot;information-schema-innodb_tablespaces_encryption&quot;&gt;INNODB_TABLESPACES_ENCRYPTION&lt;/a&gt;&lt;/code&gt; 의 INNODB_TABLESPACES_ENCRYPTION 테이블에 백그라운드 암호화 작업의 상태를 기록 합니다.</target>
        </trans-unit>
        <trans-unit id="af87395c63f88d9a7961d12f99d6960568881963" translate="yes" xml:space="preserve">
          <source>InnoDB status for high-level performance monitoring.</source>
          <target state="translated">고급 성능 모니터링을위한 InnoDB 상태.</target>
        </trans-unit>
        <trans-unit id="64ee504e0995421f61d2760fde8132cbede50ef6" translate="yes" xml:space="preserve">
          <source>InnoDB storage engine and XtraDB, its performance-enhanced fork made by Percona.</source>
          <target state="translated">퍼 노나가 만든 성능 향상 포크 인 InnoDB 스토리지 엔진과 XtraDB.</target>
        </trans-unit>
        <trans-unit id="ccb4035d61542f0678e19ae6c79efe49bca6844e" translate="yes" xml:space="preserve">
          <source>InnoDB strict mode can be enabled or disabled by configuring the &lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_strict_mode&quot;&gt;innodb_strict_mode&lt;/a&gt;&lt;/code&gt; server system variable.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_strict_mode&quot;&gt;innodb_strict_mode&lt;/a&gt;&lt;/code&gt; 서버 시스템 변수를 구성하여 InnoDB 엄격 모드를 활성화 또는 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="23bac77edd32ee0e066aa72f9b4a909126db225d" translate="yes" xml:space="preserve">
          <source>InnoDB subsystem. See below for the matching module to use to enable/disable monitoring this subsytem with the &lt;a href=&quot;../innodb-system-variables/index#innodb_monitor_enable&quot;&gt;innodb_monitor_enable&lt;/a&gt; and &lt;a href=&quot;../innodb-system-variables/index#innodb_monitor_disable&quot;&gt;innodb_monitor_disable&lt;/a&gt; system variables.</source>
          <target state="translated">InnoDB 서브 시스템. &lt;a href=&quot;../innodb-system-variables/index#innodb_monitor_enable&quot;&gt;innodb_monitor_enable&lt;/a&gt; 및 &lt;a href=&quot;../innodb-system-variables/index#innodb_monitor_disable&quot;&gt;innodb_monitor_disable&lt;/a&gt; 시스템 변수를 사용 하여이 하위 시스템 의 모니터링을 활성화 / 비활성화하는 데 사용할 일치 모듈에 대해서는 아래를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e5a3242ac86408df74c9a1e127b1bc0450a8d4d3" translate="yes" xml:space="preserve">
          <source>InnoDB supports a number of lock modes to ensure that concurrent write operations never collide.</source>
          <target state="translated">InnoDB는 동시 쓰기 작업이 충돌하지 않도록 여러 잠금 모드를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="36f6dc1135cc2ed77a8382b16e95f6d8b75898bc" translate="yes" xml:space="preserve">
          <source>InnoDB supports adding a &lt;code&gt;&lt;a href=&quot;../full-text-indexes/index&quot;&gt;FULLTEXT&lt;/a&gt;&lt;/code&gt; index to a table with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INPLACE&lt;/code&gt;. The table is not rebuilt in some cases.</source>
          <target state="translated">InnoDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;INPLACE&lt;/code&gt; 로 설정된 테이블에 &lt;code&gt;&lt;a href=&quot;../full-text-indexes/index&quot;&gt;FULLTEXT&lt;/a&gt;&lt;/code&gt; 인덱스 추가를 지원합니다 . 경우에 따라 테이블이 다시 작성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0354f38302c2129bd284f36d42df57486f16db1b" translate="yes" xml:space="preserve">
          <source>InnoDB supports adding a &lt;code&gt;&lt;a href=&quot;../full-text-indexes/index&quot;&gt;FULLTEXT&lt;/a&gt;&lt;/code&gt; index to a table with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;NOCOPY&lt;/code&gt;.</source>
          <target state="translated">InnoDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;NOCOPY&lt;/code&gt; 로 설정된 테이블에 &lt;code&gt;&lt;a href=&quot;../full-text-indexes/index&quot;&gt;FULLTEXT&lt;/a&gt;&lt;/code&gt; 인덱스 추가를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="bf2d6695e1c7f5409f4b91ea4e54f1d5a8b8a643" translate="yes" xml:space="preserve">
          <source>InnoDB supports adding a &lt;code&gt;&lt;a href=&quot;../spatial-index/index&quot;&gt;SPATIAL&lt;/a&gt;&lt;/code&gt; index to a table with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INPLACE&lt;/code&gt;.</source>
          <target state="translated">InnoDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;INPLACE&lt;/code&gt; 로 설정된 테이블에 &lt;code&gt;&lt;a href=&quot;../spatial-index/index&quot;&gt;SPATIAL&lt;/a&gt;&lt;/code&gt; 인덱스 추가를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="2d14661b4010213fabe5b1b90703595237045a4b" translate="yes" xml:space="preserve">
          <source>InnoDB supports adding a &lt;code&gt;&lt;a href=&quot;../spatial-index/index&quot;&gt;SPATIAL&lt;/a&gt;&lt;/code&gt; index to a table with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;NOCOPY&lt;/code&gt;.</source>
          <target state="translated">InnoDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;NOCOPY&lt;/code&gt; 로 설정된 테이블에 &lt;code&gt;&lt;a href=&quot;../spatial-index/index&quot;&gt;SPATIAL&lt;/a&gt;&lt;/code&gt; 인덱스 추가를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="72e151d7952b8ec5eba8cce14b836a01ccb8a0fc" translate="yes" xml:space="preserve">
          <source>InnoDB supports adding a new &lt;code&gt;&lt;a href=&quot;../enum/index&quot;&gt;ENUM&lt;/a&gt;&lt;/code&gt; option to a column with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INPLACE&lt;/code&gt;. In order to add a new &lt;code&gt;&lt;a href=&quot;../enum/index&quot;&gt;ENUM&lt;/a&gt;&lt;/code&gt; option with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INPLACE&lt;/code&gt;, the following requirements must be met:</source>
          <target state="translated">InnoDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;INPLACE&lt;/code&gt; 로 설정된 열에 새로운 &lt;code&gt;&lt;a href=&quot;../enum/index&quot;&gt;ENUM&lt;/a&gt;&lt;/code&gt; 옵션 추가를 지원합니다 . &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;INPLACE&lt;/code&gt; 로 설정된 새 &lt;code&gt;&lt;a href=&quot;../enum/index&quot;&gt;ENUM&lt;/a&gt;&lt;/code&gt; 옵션 을 추가 하려면 다음 요구 사항을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="51411289bf9303917b01a815c22c0cbfc68a0d9d" translate="yes" xml:space="preserve">
          <source>InnoDB supports adding a new &lt;code&gt;&lt;a href=&quot;../enum/index&quot;&gt;ENUM&lt;/a&gt;&lt;/code&gt; option to a column with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INSTANT&lt;/code&gt;. In order to add a new &lt;code&gt;&lt;a href=&quot;../enum/index&quot;&gt;ENUM&lt;/a&gt;&lt;/code&gt; option with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INSTANT&lt;/code&gt;, the following requirements must be met:</source>
          <target state="translated">InnoDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;INSTANT&lt;/code&gt; 로 설정된 열에 새로운 &lt;code&gt;&lt;a href=&quot;../enum/index&quot;&gt;ENUM&lt;/a&gt;&lt;/code&gt; 옵션 추가를 지원합니다 . &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;INSTANT&lt;/code&gt; 로 설정된 새 &lt;code&gt;&lt;a href=&quot;../enum/index&quot;&gt;ENUM&lt;/a&gt;&lt;/code&gt; 옵션 을 추가 하려면 다음 요구 사항을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="79899c8bf7ce36c73c60b3ce601a255a6bf7286a" translate="yes" xml:space="preserve">
          <source>InnoDB supports adding a new &lt;code&gt;&lt;a href=&quot;../enum/index&quot;&gt;ENUM&lt;/a&gt;&lt;/code&gt; option to a column with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;NOCOPY&lt;/code&gt; in the cases where the operation supports having the &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; clause set to &lt;code&gt;INSTANT&lt;/code&gt;.</source>
          <target state="translated">InnoDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 절이 &lt;code&gt;INSTANT&lt;/code&gt; 로 설정된 조작을 지원하는 경우 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;NOCOPY&lt;/code&gt; 로 설정된 열에 새 &lt;code&gt;&lt;a href=&quot;../enum/index&quot;&gt;ENUM&lt;/a&gt;&lt;/code&gt; 옵션 추가를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="fe069d748be9e1c1ba197d6a6b54763d00fbdbb5" translate="yes" xml:space="preserve">
          <source>InnoDB supports adding a new &lt;code&gt;&lt;a href=&quot;../set-data-type/index&quot;&gt;SET&lt;/a&gt;&lt;/code&gt; option to a column with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INPLACE&lt;/code&gt;. In order to add a new &lt;code&gt;&lt;a href=&quot;../set-data-type/index&quot;&gt;SET&lt;/a&gt;&lt;/code&gt; option with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INPLACE&lt;/code&gt;, the following requirements must be met:</source>
          <target state="translated">InnoDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;INPLACE&lt;/code&gt; 로 설정된 열에 새로운 &lt;code&gt;&lt;a href=&quot;../set-data-type/index&quot;&gt;SET&lt;/a&gt;&lt;/code&gt; 옵션 추가를 지원합니다 . &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;INPLACE&lt;/code&gt; 로 설정된 새 &lt;code&gt;&lt;a href=&quot;../set-data-type/index&quot;&gt;SET&lt;/a&gt;&lt;/code&gt; 옵션 을 추가 하려면 다음 요구 사항을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="d1a2e11e00a324aa9b3b8265790f702ffad6568e" translate="yes" xml:space="preserve">
          <source>InnoDB supports adding a new &lt;code&gt;&lt;a href=&quot;../set-data-type/index&quot;&gt;SET&lt;/a&gt;&lt;/code&gt; option to a column with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INSTANT&lt;/code&gt;. In order to add a new &lt;code&gt;&lt;a href=&quot;../set-data-type/index&quot;&gt;SET&lt;/a&gt;&lt;/code&gt; option with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INSTANT&lt;/code&gt;, the following requirements must be met:</source>
          <target state="translated">InnoDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;INSTANT&lt;/code&gt; 로 설정된 열에 새로운 &lt;code&gt;&lt;a href=&quot;../set-data-type/index&quot;&gt;SET&lt;/a&gt;&lt;/code&gt; 옵션 추가를 지원합니다 . &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 을 &lt;code&gt;INSTANT&lt;/code&gt; 로 설정하여 새 &lt;code&gt;&lt;a href=&quot;../set-data-type/index&quot;&gt;SET&lt;/a&gt;&lt;/code&gt; 옵션 을 추가 하려면 다음 요구 사항을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="dc941437a460f866bcceb9d680042e5549794ad8" translate="yes" xml:space="preserve">
          <source>InnoDB supports adding a new &lt;code&gt;&lt;a href=&quot;../set-data-type/index&quot;&gt;SET&lt;/a&gt;&lt;/code&gt; option to a column with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;NOCOPY&lt;/code&gt; in the cases where the operation supports having the &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; clause set to &lt;code&gt;INSTANT&lt;/code&gt;.</source>
          <target state="translated">InnoDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 절이 &lt;code&gt;INSTANT&lt;/code&gt; 로 설정된 작업을 지원하는 경우 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;NOCOPY&lt;/code&gt; 로 설정된 열에 새 &lt;code&gt;&lt;a href=&quot;../set-data-type/index&quot;&gt;SET&lt;/a&gt;&lt;/code&gt; 옵션 추가를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="a4f662a349b8c3e2b6d5a085d91ed9705b8fffb5" translate="yes" xml:space="preserve">
          <source>InnoDB supports adding a plain index to a table with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INPLACE&lt;/code&gt;. The table is not rebuilt.</source>
          <target state="translated">InnoDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;INPLACE&lt;/code&gt; 로 설정된 테이블에 일반 인덱스 추가를 지원합니다 . 테이블이 재 구축되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="8d732393ca1ba453ee684ca5fbb968920b969f86" translate="yes" xml:space="preserve">
          <source>InnoDB supports adding a plain index to a table with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;NOCOPY&lt;/code&gt;.</source>
          <target state="translated">InnoDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;NOCOPY&lt;/code&gt; 로 설정된 테이블에 일반 인덱스 추가를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="6df76cb3e6b7a876f82e3dae93d7141cc33de753" translate="yes" xml:space="preserve">
          <source>InnoDB supports adding a primary key to a table with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INPLACE&lt;/code&gt;.</source>
          <target state="translated">InnoDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;INPLACE&lt;/code&gt; 로 설정된 테이블에 기본 키 추가를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="c5696521410aade245f5e533b3f4ac582a3b1cc9" translate="yes" xml:space="preserve">
          <source>InnoDB supports adding columns to a table with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INPLACE&lt;/code&gt;.</source>
          <target state="translated">InnoDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;INPLACE&lt;/code&gt; 로 설정된 테이블에 열 추가를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="dfb9884df56306a69f72d151a7bdd7c4ef7b6c0a" translate="yes" xml:space="preserve">
          <source>InnoDB supports adding foreign key constraints to a table with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INPLACE&lt;/code&gt;. In order to add a new foreign key constraint to a table with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INPLACE&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#foreign_key_checks&quot;&gt;foreign_key_checks&lt;/a&gt;&lt;/code&gt; system variable needs to be set to &lt;code&gt;OFF&lt;/code&gt;. If it is set to &lt;code&gt;ON&lt;/code&gt;, then &lt;code&gt;ALGORITHM=COPY&lt;/code&gt; is required.</source>
          <target state="translated">InnoDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;INPLACE&lt;/code&gt; 로 설정된 테이블에 외래 키 제약 조건 추가를 지원합니다 . &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;INPLACE&lt;/code&gt; 로 설정된 테이블에 새 외래 키 제약 조건을 추가 하려면 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#foreign_key_checks&quot;&gt;foreign_key_checks&lt;/a&gt;&lt;/code&gt; 시스템 변수를 &lt;code&gt;OFF&lt;/code&gt; 로 설정해야합니다 . &lt;code&gt;ON&lt;/code&gt; 으로 설정 되면 &lt;code&gt;ALGORITHM=COPY&lt;/code&gt; 가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="de3e7971980f7d830aec608bdaa4f570f4e518cd" translate="yes" xml:space="preserve">
          <source>InnoDB supports changing a table's &lt;a href=&quot;../innodb-storage-formats/index&quot;&gt;row format&lt;/a&gt; with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INPLACE&lt;/code&gt;.</source>
          <target state="translated">InnoDB는 테이블의 변경을 지원 &lt;a href=&quot;../innodb-storage-formats/index&quot;&gt;행 형식&lt;/a&gt; 으로 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 로 설정 &lt;code&gt;INPLACE&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="7ebb5d5ff70b1435cd9765390c9b131ad4ac437a" translate="yes" xml:space="preserve">
          <source>InnoDB supports changing a table's &lt;code&gt;&lt;a href=&quot;../auto_increment/index&quot;&gt;AUTO_INCREMENT&lt;/a&gt;&lt;/code&gt; value with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INPLACE&lt;/code&gt;. This operation should finish instantly. The table is not rebuilt.</source>
          <target state="translated">InnoDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;INPLACE&lt;/code&gt; 로 설정된 테이블의 &lt;code&gt;&lt;a href=&quot;../auto_increment/index&quot;&gt;AUTO_INCREMENT&lt;/a&gt;&lt;/code&gt; 값 변경을 지원합니다 . 이 작업은 즉시 완료되어야합니다. 테이블이 재 구축되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="1a71704e906e22205b6804786b107fe98502bb3d" translate="yes" xml:space="preserve">
          <source>InnoDB supports changing a table's &lt;code&gt;&lt;a href=&quot;../auto_increment/index&quot;&gt;AUTO_INCREMENT&lt;/a&gt;&lt;/code&gt; value with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INSTANT&lt;/code&gt;.</source>
          <target state="translated">InnoDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;INSTANT&lt;/code&gt; 로 설정된 테이블의 &lt;code&gt;&lt;a href=&quot;../auto_increment/index&quot;&gt;AUTO_INCREMENT&lt;/a&gt;&lt;/code&gt; 값 변경을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="7848cf6c2df4098dfafb75a6b5c995e59e74d97e" translate="yes" xml:space="preserve">
          <source>InnoDB supports changing a table's &lt;code&gt;&lt;a href=&quot;../auto_increment/index&quot;&gt;AUTO_INCREMENT&lt;/a&gt;&lt;/code&gt; value with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;NOCOPY&lt;/code&gt; in the cases where the operation supports having the &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; clause set to &lt;code&gt;INSTANT&lt;/code&gt;.</source>
          <target state="translated">InnoDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 절이 &lt;code&gt;INSTANT&lt;/code&gt; 로 설정된 조작을 지원하는 경우 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 을 &lt;code&gt;NOCOPY&lt;/code&gt; 로 설정하여 테이블의 &lt;code&gt;&lt;a href=&quot;../auto_increment/index&quot;&gt;AUTO_INCREMENT&lt;/a&gt;&lt;/code&gt; 값 변경을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="563daaa0d40c41b87628621006de75ec00c0455a" translate="yes" xml:space="preserve">
          <source>InnoDB supports changing a table's &lt;code&gt;&lt;a href=&quot;../innodb-storage-formats/index#using-the-compressed-row-format&quot;&gt;KEY_BLOCK_SIZE&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INPLACE&lt;/code&gt;.</source>
          <target state="translated">테이블의 변경 이노 지원 &lt;code&gt;&lt;a href=&quot;../innodb-storage-formats/index#using-the-compressed-row-format&quot;&gt;KEY_BLOCK_SIZE&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 로 설정 &lt;code&gt;INPLACE&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="a2319a91a69447dfc1705a9ae03148aa8b73ae57" translate="yes" xml:space="preserve">
          <source>InnoDB supports dropping &lt;a href=&quot;../system-versioned-tables/index&quot;&gt;system versioning&lt;/a&gt; from a table with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INPLACE&lt;/code&gt;.</source>
          <target state="translated">InnoDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;INPLACE&lt;/code&gt; 로 설정된 테이블에서 &lt;a href=&quot;../system-versioned-tables/index&quot;&gt;시스템 버전&lt;/a&gt; 제거를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="82c59767706e56eea9d2f428e0da13d67f4c1fa9" translate="yes" xml:space="preserve">
          <source>InnoDB supports dropping columns from a table with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INPLACE&lt;/code&gt;.</source>
          <target state="translated">InnoDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;INPLACE&lt;/code&gt; 로 설정된 테이블에서 열 삭제를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="e243848748a569c3e9b7a92be60af1154929687f" translate="yes" xml:space="preserve">
          <source>InnoDB supports dropping foreign key constraints from a table with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INPLACE&lt;/code&gt;.</source>
          <target state="translated">InnoDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;INPLACE&lt;/code&gt; 로 설정된 테이블에서 외래 키 제약 조건 제거를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="af379b3158cf7716cb4393cbe14de50458be8c85" translate="yes" xml:space="preserve">
          <source>InnoDB supports dropping foreign key constraints from a table with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INSTANT&lt;/code&gt;.</source>
          <target state="translated">InnoDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;INSTANT&lt;/code&gt; 로 설정된 테이블에서 외래 키 제약 조건 제거를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="85770b0d9b6d87bd933bf246f0776a334c54fd7b" translate="yes" xml:space="preserve">
          <source>InnoDB supports dropping foreign key constraints from a table with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;NOCOPY&lt;/code&gt; in the cases where the operation supports having the &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; clause set to &lt;code&gt;INSTANT&lt;/code&gt;.</source>
          <target state="translated">InnoDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 절이 &lt;code&gt;INSTANT&lt;/code&gt; 로 설정된 작업을 지원하는 경우 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;NOCOPY&lt;/code&gt; 로 설정된 테이블에서 외래 키 제약 조건 제거를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="36e2c5dd4d7000f9d2ef0687b05a522ef9398f1f" translate="yes" xml:space="preserve">
          <source>InnoDB supports dropping indexes from a table with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INPLACE&lt;/code&gt;.</source>
          <target state="translated">InnoDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;INPLACE&lt;/code&gt; 로 설정된 테이블에서 인덱스 삭제를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="a669253dc888f17d197adb3d492f467fc509a7d5" translate="yes" xml:space="preserve">
          <source>InnoDB supports dropping indexes from a table with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INSTANT&lt;/code&gt;.</source>
          <target state="translated">InnoDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;INSTANT&lt;/code&gt; 로 설정된 테이블에서 인덱스 삭제를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="3de2fb9879ff29650ff56d518afa59652597fe98" translate="yes" xml:space="preserve">
          <source>InnoDB supports dropping indexes from a table with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;NOCOPY&lt;/code&gt; in the cases where the operation supports having the &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; clause set to &lt;code&gt;INSTANT&lt;/code&gt;.</source>
          <target state="translated">InnoDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 절이 &lt;code&gt;INSTANT&lt;/code&gt; 로 설정된 조작을 지원하는 경우 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;NOCOPY&lt;/code&gt; 로 설정된 테이블에서 인덱스 삭제를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="fac248b7bd394b5cd597f4883e72f0ad9f27745b" translate="yes" xml:space="preserve">
          <source>InnoDB supports each of the translation isolation levels described here using different locking strategies. The default level is &lt;code&gt;REPEATABLE READ&lt;/code&gt;. For additional information about InnoDB record-level locks and how it uses them to execute various types of statements, see &lt;a href=&quot;../xtradbinnodb-lock-modes/index&quot;&gt;XtraDB/InnoDB Lock Modes&lt;/a&gt;, and &lt;a href=&quot;http://dev.mysql.com/doc/refman/en/innodb-locks-set.html&quot;&gt;http://dev.mysql.com/doc/refman/en/innodb-locks-set.html&lt;/a&gt;.</source>
          <target state="translated">InnoDB는 다른 잠금 전략을 사용하여 여기에 설명 된 각 변환 격리 수준을 지원합니다. 기본 레벨은 &lt;code&gt;REPEATABLE READ&lt;/code&gt; 입니다. InnoDB 레코드 레벨 잠금 및 잠금을 사용하여 다양한 유형의 명령문을 실행하는 방법에 대한 자세한 정보는 &lt;a href=&quot;../xtradbinnodb-lock-modes/index&quot;&gt;XtraDB / InnoDB 잠금 모드&lt;/a&gt; 및 &lt;a href=&quot;http://dev.mysql.com/doc/refman/en/innodb-locks-set.html&quot;&gt;http://dev.mysql.com/doc/refman/en/innodb-locks-set를 참조하십시오. .html&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="896198552cb834de01b3c490dc9b1f74825d380b" translate="yes" xml:space="preserve">
          <source>InnoDB supports each of the translation isolation levels described here using different locking strategies. The default level is &lt;code&gt;REPEATABLE READ&lt;/code&gt;. For additional information about InnoDB record-level locks and how it uses them to execute various types of statements, see &lt;a href=&quot;../xtradbinnodb-lock-modes/index&quot;&gt;XtraDB/InnoDB Lock Modes&lt;/a&gt;, and &lt;a href=&quot;https://dev.mysql.com/doc/refman/en/innodb-locks-set.html&quot;&gt;http://dev.mysql.com/doc/refman/en/innodb-locks-set.html&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd56ce6ee85774b2fe3398c3f8d1e0a312149ec9" translate="yes" xml:space="preserve">
          <source>InnoDB supports forcing a table rebuild with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INPLACE&lt;/code&gt;.</source>
          <target state="translated">InnoDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 을 &lt;code&gt;INPLACE&lt;/code&gt; 로 설정하여 테이블을 강제로 다시 작성하도록 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="f2471e9d3d4da1c34666f93e473aeed74531680f" translate="yes" xml:space="preserve">
          <source>InnoDB supports increasing the length of &lt;code&gt;VARCHAR&lt;/code&gt; columns with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INSTANT&lt;/code&gt;, unless it would require changing the number of bytes requires to represent the column's length. A &lt;code&gt;VARCHAR&lt;/code&gt; column that is between 0 and 255 bytes in size requires 1 byte to represent its length, while a &lt;code&gt;VARCHAR&lt;/code&gt; column that is 256 bytes or longer requires 2 bytes to represent its length. This means that the length of a column cannot be increased with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INSTANT&lt;/code&gt; if the original length was less than 256 bytes, and the new length is 256 bytes or more.</source>
          <target state="translated">InnoDB는 열 길이 를 나타 내기 위해 바이트 수를 변경해야하는 경우가 아니면 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;INSTANT&lt;/code&gt; 로 설정된 &lt;code&gt;VARCHAR&lt;/code&gt; 열의 길이 증가를 지원합니다 . &lt;code&gt;VARCHAR&lt;/code&gt; 의 동안 크기 0과 255 사이의 바이트 열에는, 그 길이를 나타 내기 위해 1 바이트를 필요 &lt;code&gt;VARCHAR&lt;/code&gt; 의 이상 256 바이트 또는 컬럼의 길이를 나타 내기 위해 2 바이트를 필요로한다. 이는 원래 길이가 256 바이트 미만이고 새 길이가 256 바이트 이상인 경우 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 을 &lt;code&gt;INSTANT&lt;/code&gt; 로 설정 하면 열의 길이를 늘릴 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="bffad27d223c8de75d718adc8fa895651b5da5c0" translate="yes" xml:space="preserve">
          <source>InnoDB supports modifying a column to &lt;strong&gt;not&lt;/strong&gt; allow &lt;code&gt;&lt;a href=&quot;../create-table/index#null-and-not-null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; values with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INPLACE&lt;/code&gt;. It is required for &lt;a href=&quot;../sql-mode/index#strict-mode&quot;&gt;strict mode&lt;/a&gt; to be enabled in &lt;code&gt;&lt;a href=&quot;../sql-mode/index&quot;&gt;SQL_MODE&lt;/a&gt;&lt;/code&gt;. The operation will fail if the column contains any &lt;code&gt;NULL&lt;/code&gt; values. Changes that would interfere with referential integrity are also not permitted.</source>
          <target state="translated">InnoDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;INPLACE&lt;/code&gt; 로 설정된 &lt;code&gt;&lt;a href=&quot;../create-table/index#null-and-not-null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; 값을 허용 &lt;strong&gt;하지 않도록&lt;/strong&gt; 열 수정을 지원합니다 . 것이이 필요 &lt;a href=&quot;../sql-mode/index#strict-mode&quot;&gt;엄격 모드&lt;/a&gt; 에서 활성화 될 &lt;code&gt;&lt;a href=&quot;../sql-mode/index&quot;&gt;SQL_MODE&lt;/a&gt;&lt;/code&gt; . 열에 &lt;code&gt;NULL&lt;/code&gt; 값이 포함되어 있으면 작업이 실패 합니다. 참조 무결성을 방해하는 변경도 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0cb8021890574679c27a5f40fc3ef27c565c29da" translate="yes" xml:space="preserve">
          <source>InnoDB supports modifying a column to allow &lt;code&gt;&lt;a href=&quot;../create-table/index#null-and-not-null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; values with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INPLACE&lt;/code&gt;.</source>
          <target state="translated">InnoDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;INPLACE&lt;/code&gt; 로 설정된 &lt;code&gt;&lt;a href=&quot;../create-table/index#null-and-not-null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; 값 을 허용하도록 열 수정을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="081b9f597f83f8f392803d951fdf9d5ef1ede59b" translate="yes" xml:space="preserve">
          <source>InnoDB supports modifying a column's &lt;code&gt;&lt;a href=&quot;../create-table/index#default-column-option&quot;&gt;DEFAULT&lt;/a&gt;&lt;/code&gt; value with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INPLACE&lt;/code&gt;.</source>
          <target state="translated">InnoDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;INPLACE&lt;/code&gt; 로 설정된 열의 &lt;code&gt;&lt;a href=&quot;../create-table/index#default-column-option&quot;&gt;DEFAULT&lt;/a&gt;&lt;/code&gt; 값 수정을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="aa28426a668223659e20d9317b6f71544c8eb328" translate="yes" xml:space="preserve">
          <source>InnoDB supports modifying a column's &lt;code&gt;&lt;a href=&quot;../create-table/index#default-column-option&quot;&gt;DEFAULT&lt;/a&gt;&lt;/code&gt; value with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INSTANT&lt;/code&gt;.</source>
          <target state="translated">InnoDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;INSTANT&lt;/code&gt; 로 설정된 열의 &lt;code&gt;&lt;a href=&quot;../create-table/index#default-column-option&quot;&gt;DEFAULT&lt;/a&gt;&lt;/code&gt; 값 수정을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="184fa807048b5e54e30d016650ac76c4eb38c838" translate="yes" xml:space="preserve">
          <source>InnoDB supports modifying a column's &lt;code&gt;&lt;a href=&quot;../create-table/index#default-column-option&quot;&gt;DEFAULT&lt;/a&gt;&lt;/code&gt; value with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;NOCOPY&lt;/code&gt; in the cases where the operation supports having the &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; clause set to &lt;code&gt;INSTANT&lt;/code&gt;.</source>
          <target state="translated">InnoDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 절이 &lt;code&gt;INSTANT&lt;/code&gt; 로 설정된 조작을 지원하는 경우 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 을 &lt;code&gt;NOCOPY&lt;/code&gt; 로 설정하여 열의 &lt;code&gt;&lt;a href=&quot;../create-table/index#default-column-option&quot;&gt;DEFAULT&lt;/a&gt;&lt;/code&gt; 값 수정을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="f7b54e35573be633f4c317b46b853debe53de1f0" translate="yes" xml:space="preserve">
          <source>InnoDB supports optimizing a table with with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INPLACE&lt;/code&gt;.</source>
          <target state="translated">InnoDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;INPLACE&lt;/code&gt; 로 설정된 테이블 최적화를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="2f2c75e47ab0532d2c3e7b00420298930c0917ee" translate="yes" xml:space="preserve">
          <source>InnoDB supports removing a column's &lt;code&gt;&lt;a href=&quot;../create-table/index#default-column-option&quot;&gt;DEFAULT&lt;/a&gt;&lt;/code&gt; value with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INPLACE&lt;/code&gt;.</source>
          <target state="translated">InnoDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;INPLACE&lt;/code&gt; 로 설정된 열의 &lt;code&gt;&lt;a href=&quot;../create-table/index#default-column-option&quot;&gt;DEFAULT&lt;/a&gt;&lt;/code&gt; 값 제거를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="05a2cfe15dcdbe2ccf3cbb55b0a936078bd8f9c5" translate="yes" xml:space="preserve">
          <source>InnoDB supports removing a column's &lt;code&gt;&lt;a href=&quot;../create-table/index#default-column-option&quot;&gt;DEFAULT&lt;/a&gt;&lt;/code&gt; value with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INSTANT&lt;/code&gt;.</source>
          <target state="translated">InnoDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;INSTANT&lt;/code&gt; 로 설정된 열의 &lt;code&gt;&lt;a href=&quot;../create-table/index#default-column-option&quot;&gt;DEFAULT&lt;/a&gt;&lt;/code&gt; 값 제거를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="65af44b4366c8ee6b5de1f82cca3c4ae8a11ed28" translate="yes" xml:space="preserve">
          <source>InnoDB supports removing a column's &lt;code&gt;&lt;a href=&quot;../create-table/index#default-column-option&quot;&gt;DEFAULT&lt;/a&gt;&lt;/code&gt; value with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;NOCOPY&lt;/code&gt; in the cases where the operation supports having the &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; clause set to &lt;code&gt;INSTANT&lt;/code&gt;.</source>
          <target state="translated">InnoDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 절이 &lt;code&gt;INSTANT&lt;/code&gt; 로 설정된 조작을 지원하는 경우 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;NOCOPY&lt;/code&gt; 로 설정된 열의 &lt;code&gt;&lt;a href=&quot;../create-table/index#default-column-option&quot;&gt;DEFAULT&lt;/a&gt;&lt;/code&gt; 값 제거를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="79f546ad7650dfb20ba379e1fdf6fa6f618eaed8" translate="yes" xml:space="preserve">
          <source>InnoDB supports renaming a column with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INPLACE&lt;/code&gt;, unless the column's data type or attributes changed in addition to the name.</source>
          <target state="translated">InnoDB는 이름과 함께 열의 데이터 유형 또는 속성이 변경되지 않는 한 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;INPLACE&lt;/code&gt; 로 설정된 열 이름 바꾸기를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="9168cbf063f669f878572500f56fd4e7ee30c3f7" translate="yes" xml:space="preserve">
          <source>InnoDB supports renaming a column with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INSTANT&lt;/code&gt;, unless the column's data type or attributes changed in addition to the name.</source>
          <target state="translated">InnoDB는 이름 외에 열의 데이터 유형이나 속성이 변경되지 않는 한 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;INSTANT&lt;/code&gt; 로 설정된 열 이름 바꾸기를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="a869380cc8ecfd9c9286369de063fd2bb5ecf34c" translate="yes" xml:space="preserve">
          <source>InnoDB supports renaming a column with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;NOCOPY&lt;/code&gt; in the cases where the operation supports having the &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; clause set to &lt;code&gt;INSTANT&lt;/code&gt;.</source>
          <target state="translated">InnoDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 절이 &lt;code&gt;INSTANT&lt;/code&gt; 로 설정된 조작을 지원하는 경우 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;NOCOPY&lt;/code&gt; 로 설정된 열 이름 바꾸기를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="ebbacf0562e1da36037f5ecebb94ca4afe806687" translate="yes" xml:space="preserve">
          <source>InnoDB supports renaming a table with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INPLACE&lt;/code&gt;.</source>
          <target state="translated">InnoDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;INPLACE&lt;/code&gt; 로 설정된 테이블 이름 바꾸기를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="6e489636f89683939a1018ef0748720345b8f697" translate="yes" xml:space="preserve">
          <source>InnoDB supports renaming a table with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INSTANT&lt;/code&gt;.</source>
          <target state="translated">InnoDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;INSTANT&lt;/code&gt; 로 설정된 테이블 이름 바꾸기를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="09a799137ba4620d8cd0b9d3e2527248d5696fb1" translate="yes" xml:space="preserve">
          <source>InnoDB supports renaming a table with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;NOCOPY&lt;/code&gt; in the cases where the operation supports having the &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; clause set to &lt;code&gt;INSTANT&lt;/code&gt;.</source>
          <target state="translated">InnoDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 절이 &lt;code&gt;INSTANT&lt;/code&gt; 로 설정된 조작을 지원하는 경우 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;NOCOPY&lt;/code&gt; 로 설정된 테이블 이름 바꾸기를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="63faa34d6799aa56774f4cda21cc58a643923f4b" translate="yes" xml:space="preserve">
          <source>InnoDB supports reordering columns within a table with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INPLACE&lt;/code&gt;.</source>
          <target state="translated">InnoDB는 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;INPLACE&lt;/code&gt; 로 설정된 테이블 내에서 열 순서 변경을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="f7bcbf18e65027ca3676caec85b83d3bc8ea7ce0" translate="yes" xml:space="preserve">
          <source>InnoDB supports the SQL statements &lt;code&gt;SAVEPOINT&lt;/code&gt;, &lt;code&gt;ROLLBACK TO SAVEPOINT&lt;/code&gt;, &lt;code&gt;RELEASE SAVEPOINT&lt;/code&gt; and the optional &lt;code&gt;WORK&lt;/code&gt; keyword for &lt;code&gt;ROLLBACK&lt;/code&gt;.</source>
          <target state="translated">InnoDB는 SQL 문 지원 &lt;code&gt;SAVEPOINT&lt;/code&gt; , &lt;code&gt;ROLLBACK TO SAVEPOINT&lt;/code&gt; , &lt;code&gt;RELEASE SAVEPOINT&lt;/code&gt; 와 옵션 &lt;code&gt;WORK&lt;/code&gt; 에 대한 키워드 &lt;code&gt;ROLLBACK&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="7bf8dcba823b47dd215d74bb8e18511d02f0a7a6" translate="yes" xml:space="preserve">
          <source>InnoDB system tablespace</source>
          <target state="translated">InnoDB 시스템 테이블 스페이스</target>
        </trans-unit>
        <trans-unit id="215fa97c731a9f7e76c552512bfaf3cc9d67de51" translate="yes" xml:space="preserve">
          <source>InnoDB table information.</source>
          <target state="translated">InnoDB 테이블 정보.</target>
        </trans-unit>
        <trans-unit id="c04f92ede0aa4ca2c71691c1ad6fddb763b36f9e" translate="yes" xml:space="preserve">
          <source>InnoDB table space id number.</source>
          <target state="translated">InnoDB 테이블 스페이스 ID 번호</target>
        </trans-unit>
        <trans-unit id="9942297e05d0b41bf81d112da17b081abf23f526" translate="yes" xml:space="preserve">
          <source>InnoDB tables can have a maximum of 1,017 columns. This includes &lt;a href=&quot;../generated-columns/index&quot;&gt;virtual generated columns&lt;/a&gt;.</source>
          <target state="translated">InnoDB 테이블은 최대 1,017 개의 열을 가질 수 있습니다. 여기에는 &lt;a href=&quot;../generated-columns/index&quot;&gt;가상 생성 열&lt;/a&gt; 이 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="22376d8fea83173837efbbefdf44d5d2a877c9dd" translate="yes" xml:space="preserve">
          <source>InnoDB tables can have a maximum of 64 secondary indexes.</source>
          <target state="translated">InnoDB 테이블은 최대 64 개의 보조 인덱스를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51d3868d3f34467fa93d6e66d77a1ad5a7eb4958" translate="yes" xml:space="preserve">
          <source>InnoDB tables support online DDL in certain circumstances.</source>
          <target state="translated">InnoDB 테이블은 특정 상황에서 온라인 DDL을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="60323cfd482f24f42d7b16d5ae360316b21bc66c" translate="yes" xml:space="preserve">
          <source>InnoDB tables support online DDL, which permits concurrent DML and uses optimizations to avoid unnecessary table copying.</source>
          <target state="translated">InnoDB 테이블은 온라인 DDL을 지원하여 동시 DML을 허용하고 불필요한 테이블 복사를 피하기 위해 최적화를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ede663a6ef13ec385af7a6fed7706fc2b44ff522" translate="yes" xml:space="preserve">
          <source>InnoDB tables that are part of the &lt;a href=&quot;../innodb-system-tablespaces/index&quot;&gt;system&lt;/a&gt; tablespace can only be encrypted using the encryption key set by the &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_default_encryption_key_id&quot;&gt;innodb_default_encryption_key_id&lt;/a&gt;&lt;/code&gt; system variable.</source>
          <target state="translated">&lt;a href=&quot;../innodb-system-tablespaces/index&quot;&gt;시스템&lt;/a&gt; 테이블 스페이스의 일부인 InnoDB 테이블 은 &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_default_encryption_key_id&quot;&gt;innodb_default_encryption_key_id&lt;/a&gt;&lt;/code&gt; 시스템 변수로 설정된 암호화 키를 사용해야 만 암호화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3260a7a04e1c27b0aafab08e7da534f06665f2a1" translate="yes" xml:space="preserve">
          <source>InnoDB tablespace ID.</source>
          <target state="translated">InnoDB 테이블 스페이스 ID.</target>
        </trans-unit>
        <trans-unit id="73d067fd73665f1f859f6ec95b52eb1b9d06235a" translate="yes" xml:space="preserve">
          <source>InnoDB tablespace information.</source>
          <target state="translated">InnoDB 테이블 스페이스 정보.</target>
        </trans-unit>
        <trans-unit id="ff5e7b4456062e93f10d954cbd45bcaa216be241" translate="yes" xml:space="preserve">
          <source>InnoDB tablespace paths.</source>
          <target state="translated">InnoDB 테이블 스페이스 경로.</target>
        </trans-unit>
        <trans-unit id="390d274994d5d585afb42708bce2590baf4b74aa" translate="yes" xml:space="preserve">
          <source>InnoDB used the wrong calculations to determine row sizes for quite a long time, so a lot of users may unknowingly have &lt;em&gt;unsafe&lt;/em&gt; tables that the InnoDB row format can't actually store.</source>
          <target state="translated">InnoDB는 잘못된 계산을 사용하여 오랫동안 행 크기를 결정했기 때문에 많은 사용자가 InnoDB 행 형식으로 실제로 저장할 수없는 &lt;em&gt;안전하지 않은&lt;/em&gt; 테이블을 모르게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb9a814598672a4ce49d2b538942377343c133c2" translate="yes" xml:space="preserve">
          <source>InnoDB uses &lt;a href=&quot;../encryption-key-management/index&quot;&gt;encryption key management&lt;/a&gt; plugins to support the use of multiple &lt;a href=&quot;../encryption-key-management/index#using-multiple-encryption-keys&quot;&gt;encryption keys&lt;/a&gt;.</source>
          <target state="translated">InnoDB는 &lt;a href=&quot;../encryption-key-management/index&quot;&gt;암호화 키 관리&lt;/a&gt; 플러그인을 사용하여 여러 &lt;a href=&quot;../encryption-key-management/index#using-multiple-encryption-keys&quot;&gt;암호화 키&lt;/a&gt; 사용을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="8dbe33857ea8328c84782e1a8d673cd62bbec4e2" translate="yes" xml:space="preserve">
          <source>InnoDB uses encryption key management plugins to support the use of multiple encryption keys.</source>
          <target state="translated">InnoDB는 암호화 키 관리 플러그인을 사용하여 여러 암호화 키 사용을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="3152a4b0e69ba5091aa6bd8ebb38d798c64c43c1" translate="yes" xml:space="preserve">
          <source>InnoDB uses the &lt;a href=&quot;../innodb-redo-log/index&quot;&gt;Redo Log&lt;/a&gt; in crash recovery. By default, these events are written to file in an unencrypted state. In configuring MariaDB for data-at-rest encryption, ensure that you also enable encryption for the Redo Log.</source>
          <target state="translated">InnoDB는 응급 복구에서 &lt;a href=&quot;../innodb-redo-log/index&quot;&gt;Redo Log&lt;/a&gt; 를 사용합니다 . 기본적으로 이러한 이벤트는 암호화되지 않은 상태로 파일에 기록됩니다. 미사용 데이터 암호화를 위해 MariaDB를 구성 할 때 리두 로그에 대한 암호화도 활성화해야합니다.</target>
        </trans-unit>
        <trans-unit id="5a6b4c2d4399c3e1c7ddf2336538219a995f952e" translate="yes" xml:space="preserve">
          <source>InnoDB uses the &lt;a href=&quot;../innodb-redo-log/index&quot;&gt;Redo Log&lt;/a&gt; in crash recovery. By default, these events are written to file in an unencrypted state. In removing data-at-rest encryption for InnoDB, be sure to also disable encryption for the Redo Log before removing encryption key settings. Otherwise the Redo Log can become inaccessible without the encryption keys.</source>
          <target state="translated">InnoDB는 응급 복구에서 &lt;a href=&quot;../innodb-redo-log/index&quot;&gt;Redo Log&lt;/a&gt; 를 사용합니다 . 기본적으로 이러한 이벤트는 암호화되지 않은 상태로 파일에 기록됩니다. InnoDB의 유휴 데이터 암호화를 제거 할 때 암호화 키 설정을 제거하기 전에 다시 실행 로그에 대한 암호화도 비활성화해야합니다. 그렇지 않으면 암호화 키가 없으면 재실행 로그에 액세스 할 수 없게됩니다.</target>
        </trans-unit>
        <trans-unit id="e4faf4bbb17c810b65b7f7e53dfef6b2dc2e6f7e" translate="yes" xml:space="preserve">
          <source>InnoDB uses the &lt;a href=&quot;../xtradbinnodb-buffer-pool/index&quot;&gt;buffer pool&lt;/a&gt;, which stores data and indexes from its tables in memory. This buffer is very important for performance. If InnoDB data doesn't fit the memory, it is important that the buffer contains the most frequently accessed data. However, last accessed data is candidate for insertion into the buffer pool. If not properly configured, when a table scan happens, InnoDB may copy the whole contents of a table into the buffer pool. The problem with logical backups is that they always imply full table scans.</source>
          <target state="translated">InnoDB는 테이블의 데이터와 인덱스를 메모리에 저장 하는 &lt;a href=&quot;../xtradbinnodb-buffer-pool/index&quot;&gt;버퍼 풀을&lt;/a&gt; 사용합니다 . 이 버퍼는 성능에 매우 중요합니다. InnoDB 데이터가 메모리에 맞지 않으면 버퍼에 가장 자주 액세스하는 데이터가 포함되어 있어야합니다. 그러나 마지막으로 액세스 한 데이터는 버퍼 풀에 삽입 할 수 있습니다. 제대로 구성되지 않은 경우, 테이블 스캔이 발생하면 InnoDB는 테이블의 전체 내용을 버퍼 풀에 복사 할 수 있습니다. 논리적 백업의 문제점은 항상 전체 테이블 스캔을 암시한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="59f169ca0f8ff7cca9180638bff72be75a9326dc" translate="yes" xml:space="preserve">
          <source>InnoDB versions in MySQL 5.7 and above also support an additional type of tablespace called &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/general-tablespaces.html&quot;&gt;general tablespaces&lt;/a&gt; that are created with &lt;code&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/create-tablespace.html&quot;&gt;CREATE TABLESPACE&lt;/a&gt;&lt;/code&gt;. However, InnoDB versions in MariaDB Server do not currently support general tablespaces or &lt;code&gt;&lt;a href=&quot;../create-tablespace/index&quot;&gt;CREATE TABLESPACE&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">MySQL 5.7 이상의 InnoDB 버전은 &lt;code&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/create-tablespace.html&quot;&gt;CREATE TABLESPACE&lt;/a&gt;&lt;/code&gt; 로 생성 된 &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/general-tablespaces.html&quot;&gt;일반 테이블&lt;/a&gt; 스페이스라는 추가 테이블 스페이스 유형도 지원합니다 . 그러나 MariaDB 서버의 InnoDB 버전은 현재 일반 테이블 스페이스 또는 &lt;code&gt;&lt;a href=&quot;../create-tablespace/index&quot;&gt;CREATE TABLESPACE&lt;/a&gt;&lt;/code&gt; 를 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a2912e1d1e15e38c18d83448340b49b75ed2f4f5" translate="yes" xml:space="preserve">
          <source>InnoDB's buffer_pool With multi-core boxes, the mutex problem is causing performance problems. In general, past 4-8 cores, MySQL gets slower, not faster. MySQL 5.5 and Percona's XtraDB made that somewhat better in InnoDB; the practical limit for cores is more like 32, and performance tends plateaus after that rather than declining. 5.6 claims to scale up to about 48 cores.</source>
          <target state="translated">InnoDB의 buffer_pool 멀티 코어 박스에서 뮤텍스 문제는 성능 문제를 일으 킵니다. 일반적으로 지난 4-8 코어에서 MySQL은 느리게 진행됩니다. MySQL 5.5와 Percona의 XtraDB는 InnoDB에서 다소 개선되었습니다. 코어의 실제 한계는 32와 비슷하며 성능은 감소하기보다는 정점에 이릅니다. 5.6은 최대 약 48 코어까지 확장 할 수 있다고 주장합니다.</target>
        </trans-unit>
        <trans-unit id="012929cacd37f1d137b5c87719790cf4854b192b" translate="yes" xml:space="preserve">
          <source>InnoDB's file-per-table tablespaces are transportable, which means that you can copy a file-per-table tablespace from one MariaDB Server to another server. See &lt;a href=&quot;../innodb-file-per-table-tablespaces/index#copying-transportable-tablespaces&quot;&gt;Copying Transportable Tablespaces&lt;/a&gt; for more information.</source>
          <target state="translated">InnoDB의 테이블 당 테이블 스페이스는 이동 가능하므로 테이블 당 파일 스페이스를 하나의 MariaDB 서버에서 다른 서버로 복사 할 수 있습니다. 자세한 정보는 &lt;a href=&quot;../innodb-file-per-table-tablespaces/index#copying-transportable-tablespaces&quot;&gt;전송 가능한 테이블 스페이스 복사&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3c9037ca890bf357f628a869acd7c2bf22484754" translate="yes" xml:space="preserve">
          <source>InnoDB's file-per-table tablespaces are transportable, which means that you can copy a file-per-table tablespace from one MariaDB Server to another server. You may find this useful in cases where you need to transport full tables between servers and don't want to use backup tools like &lt;code&gt;&lt;a href=&quot;../mariabackup/index&quot;&gt;mariabackup&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../mysqldump/index&quot;&gt;mysqldump&lt;/a&gt;&lt;/code&gt;. In fact, this process can even be used with &lt;code&gt;&lt;a href=&quot;../mariabackup/index&quot;&gt;mariabackup&lt;/a&gt;&lt;/code&gt; in some cases, such as when &lt;a href=&quot;../partial-backup-and-restore-with-mariabackup/index&quot;&gt;restoring partial backups&lt;/a&gt; or when &lt;a href=&quot;../restoring-individual-tables-and-partitions-with-mariabackup/index&quot;&gt;restoring individual tables or partitions from a backup&lt;/a&gt;.</source>
          <target state="translated">InnoDB의 테이블 당 테이블 스페이스는 이동 가능하므로 테이블 당 파일 스페이스를 하나의 MariaDB 서버에서 다른 서버로 복사 할 수 있습니다. 서버간에 전체 테이블을 전송해야하고 &lt;code&gt;&lt;a href=&quot;../mariabackup/index&quot;&gt;mariabackup&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../mysqldump/index&quot;&gt;mysqldump&lt;/a&gt;&lt;/code&gt; 와 같은 백업 도구를 사용하지 않으려는 경우에 유용 할 수 있습니다 . 실제로이 프로세스는 &lt;a href=&quot;../partial-backup-and-restore-with-mariabackup/index&quot;&gt;부분 백업&lt;/a&gt; 을 &lt;a href=&quot;../restoring-individual-tables-and-partitions-with-mariabackup/index&quot;&gt;복원하거나 백업에서 개별 테이블 또는 파티션을 복원&lt;/a&gt; 할 때와 같이 경우에 따라 &lt;code&gt;&lt;a href=&quot;../mariabackup/index&quot;&gt;mariabackup&lt;/a&gt;&lt;/code&gt; 과 함께 사용될 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ea661bff50ba02d14aadf0a02b4d551f77c4d34d" translate="yes" xml:space="preserve">
          <source>InnoDB's multi-thread flush feature can be enabled by setting the &lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_use_mtflush&quot;&gt;innodb_use_mtflush&lt;/a&gt;&lt;/code&gt; system variable. The number of threads cane be configured by setting the &lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_mtflush_threads&quot;&gt;innodb_mtflush_threads&lt;/a&gt;&lt;/code&gt; system variable. This system variable can be set in a server &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;option group&lt;/a&gt; in an &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;option file&lt;/a&gt; prior to starting up the server. For example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_use_mtflush&quot;&gt;innodb_use_mtflush&lt;/a&gt;&lt;/code&gt; 시스템 변수를 설정하여 InnoDB의 멀티 스레드 플러시 기능을 활성화 할 수 있습니다 . &lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_mtflush_threads&quot;&gt;innodb_mtflush_threads&lt;/a&gt;&lt;/code&gt; 시스템 변수를 설정하여 스레드 수를 구성 할 수 있습니다 . 이 시스템 변수는 서버 를 시작하기 전에 &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;옵션 파일&lt;/a&gt; 의 서버 &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;옵션 그룹&lt;/a&gt; 에서 설정할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="693f8ae125a53e0b0f07175bc350b9f1cdf80b09" translate="yes" xml:space="preserve">
          <source>InnoDB's multi-thread flush feature was deprecated in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1029-release-notes/&quot;&gt;MariaDB 10.2.9&lt;/a&gt; and removed from &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1032-release-notes/&quot;&gt;MariaDB 10.3.2&lt;/a&gt;. In later versions of MariaDB, use &lt;code&gt;&lt;a href=&quot;#innodb_page_cleaners&quot;&gt;innodb_page_cleaners&lt;/a&gt;&lt;/code&gt; system variable instead.</source>
          <target state="translated">InnoDB의 다중 스레드 플러시 기능은 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1029-release-notes/&quot;&gt;MariaDB 10.2.9&lt;/a&gt; 에서 더 이상 사용되지 않으며 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1032-release-notes/&quot;&gt;MariaDB 10.3.2&lt;/a&gt; 에서 제거되었습니다 . 이후 버전의 MariaDB에서는 대신 &lt;code&gt;&lt;a href=&quot;#innodb_page_cleaners&quot;&gt;innodb_page_cleaners&lt;/a&gt;&lt;/code&gt; 시스템 변수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0de4730cd900bd33ac2d9b71badb2923284f00e0" translate="yes" xml:space="preserve">
          <source>InnoDB's multi-thread flush feature was deprecated in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1029-release-notes/&quot;&gt;MariaDB 10.2.9&lt;/a&gt; and removed from &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1032-release-notes/&quot;&gt;MariaDB 10.3.2&lt;/a&gt;. In later versions of MariaDB, use multiple InnoDB page cleaner threads instead.</source>
          <target state="translated">InnoDB의 다중 스레드 플러시 기능은 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1029-release-notes/&quot;&gt;MariaDB 10.2.9&lt;/a&gt; 에서 더 이상 사용되지 않으며 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1032-release-notes/&quot;&gt;MariaDB 10.3.2&lt;/a&gt; 에서 제거되었습니다 . 이후 버전의 MariaDB에서는 여러 InnoDB 페이지 클리너 스레드를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6815831288a982d104635a7426ee884409fd40e8" translate="yes" xml:space="preserve">
          <source>InnoDB's multi-thread flush feature was first added in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1010-release-notes/&quot;&gt;MariaDB 10.1.0&lt;/a&gt;. It was deprecated in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1029-release-notes/&quot;&gt;MariaDB 10.2.9&lt;/a&gt; and removed in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1032-release-notes/&quot;&gt;MariaDB 10.3.2&lt;/a&gt;.</source>
          <target state="translated">InnoDB의 멀티 스레드 플러시 기능은 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1010-release-notes/&quot;&gt;MariaDB 10.1.0&lt;/a&gt; 에서 처음 추가되었습니다 . &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1029-release-notes/&quot;&gt;MariaDB 10.2.9&lt;/a&gt; 에서는 더 이상 사용되지 않으며 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1032-release-notes/&quot;&gt;MariaDB 10.3.2&lt;/a&gt; 에서는 제거되었습니다 .</target>
        </trans-unit>
        <trans-unit id="0b8f6966f8422748634070a69980e3e85ca02065" translate="yes" xml:space="preserve">
          <source>InnoDB's row formats are REDUNDANT, COMPACT, DYNAMIC, and COMPRESSED.</source>
          <target state="translated">InnoDB의 행 형식은 REDUNDANT, COMPACT, DYNAMIC 및 COMPRESSED입니다.</target>
        </trans-unit>
        <trans-unit id="e2603fd932a295634cfe55d3373083ac86f3bacb" translate="yes" xml:space="preserve">
          <source>InnoDB's row formats work around this limit by storing certain kinds of variable-length columns on overflow pages. However, different row formats can store different types of data on overflow pages. Some row formats can store more data in overflow pages than others. For example, the &lt;code&gt;&lt;a href=&quot;../innodb-dynamic-row-format/index&quot;&gt;DYNAMIC&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../innodb-compressed-row-format/index&quot;&gt;COMPRESSED&lt;/a&gt;&lt;/code&gt; row formats can store the most data in overflow pages. To learn how the various InnoDB row formats use overflow pages, see the following pages:</source>
          <target state="translated">InnoDB의 행 형식은 특정 종류의 가변 길이 열을 오버플로 페이지에 저장하여이 한계를 해결합니다. 그러나 다른 행 형식은 오버플로 페이지에 다른 유형의 데이터를 저장할 수 있습니다. 일부 행 형식은 다른 행 형식보다 더 많은 데이터를 오버플로 페이지에 저장할 수 있습니다. 예를 들어, &lt;code&gt;&lt;a href=&quot;../innodb-dynamic-row-format/index&quot;&gt;DYNAMIC&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../innodb-compressed-row-format/index&quot;&gt;COMPRESSED&lt;/a&gt;&lt;/code&gt; 행 형식은 대부분의 데이터를 오버 플로우 페이지에 저장할 수 있습니다. 다양한 InnoDB 행 형식이 오버플로 페이지를 사용하는 방법을 알아 보려면 다음 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3b6fbb259f519c10978eb86512ebbd45da6e6a2e" translate="yes" xml:space="preserve">
          <source>InnoDB, even with innodb_file_per_table = 1, won't give space back to the OS, but at least it is only one table to rebuild with. In this case, something like this should work:</source>
          <target state="translated">innodb_file_per_table = 1 인 경우에도 InnoDB는 OS에 공간을 다시 제공하지 않지만 최소한 다시 빌드 할 테이블은 하나뿐입니다. 이 경우 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="30ad4afd6c24a6c31f56a998c4ee5ddefcb2610c" translate="yes" xml:space="preserve">
          <source>InnoDB/XtraDB</source>
          <target state="translated">InnoDB/XtraDB</target>
        </trans-unit>
        <trans-unit id="49db08bf445cee6ce1451ef8d24521310c8b35b7" translate="yes" xml:space="preserve">
          <source>InnoDB/XtraDB Page Compression</source>
          <target state="translated">InnoDB / XtraDB 페이지 압축</target>
        </trans-unit>
        <trans-unit id="39ddc885a5026763cf8d11b606f34389d0f376d2" translate="yes" xml:space="preserve">
          <source>InnoDB/XtraDB hash table memory usage information.</source>
          <target state="translated">InnoDB / XtraDB 해시 테이블 메모리 사용 정보.</target>
        </trans-unit>
        <trans-unit id="4fce84d69eadef8286b32a873c0ba669dcc9f135" translate="yes" xml:space="preserve">
          <source>InnoDB/XtraDB supports row-level locking. selected rows can be locked using &lt;code&gt;LOCK IN SHARE MODE&lt;/code&gt; or &lt;code&gt;FOR UPDATE&lt;/code&gt;. In both cases, a lock is acquired on the rows read by the query, and it will be released when the current transaction is committed.</source>
          <target state="translated">InnoDB / XtraDB는 행 수준 잠금을 지원합니다. 선택된 행은 &lt;code&gt;LOCK IN SHARE MODE&lt;/code&gt; 또는 &lt;code&gt;FOR UPDATE&lt;/code&gt; 를 사용하여 잠글 수 있습니다 . 두 경우 모두, 쿼리가 읽은 행에서 잠금이 획득되고 현재 트랜잭션이 커밋 될 때 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="6fabc57fe735cd7ecec3ae0fe3a880506f5db352" translate="yes" xml:space="preserve">
          <source>Innodb page size, since &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1025-release-notes/&quot;&gt;MariaDB 10.2.5&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1025-release-notes/&quot;&gt;MariaDB 10.2.5&lt;/a&gt; 부터 Innodb 페이지 크기</target>
        </trans-unit>
        <trans-unit id="5d8dd2b5d8fad22fabded81ce70b26f2ad623ff1" translate="yes" xml:space="preserve">
          <source>Innodb_adaptive_hash_cells</source>
          <target state="translated">Innodb_adaptive_hash_cells</target>
        </trans-unit>
        <trans-unit id="d6fa166f2598a217ae198ffd96f70ba4ccf2fa7f" translate="yes" xml:space="preserve">
          <source>Innodb_adaptive_hash_hash_searches</source>
          <target state="translated">Innodb_adaptive_hash_hash_searches</target>
        </trans-unit>
        <trans-unit id="ee39254d16d4ccd3f376ab9aec3555d592c58613" translate="yes" xml:space="preserve">
          <source>Innodb_adaptive_hash_heap_buffers</source>
          <target state="translated">Innodb_adaptive_hash_heap_buffers</target>
        </trans-unit>
        <trans-unit id="d3b22a58c50f6e8eb1080c241a33e61a106f2913" translate="yes" xml:space="preserve">
          <source>Innodb_adaptive_hash_non_hash_searches</source>
          <target state="translated">Innodb_adaptive_hash_non_hash_searches</target>
        </trans-unit>
        <trans-unit id="a12f83b7d3df42824cc3bb34c99a03b50ae47f4a" translate="yes" xml:space="preserve">
          <source>Innodb_available_undo_logs</source>
          <target state="translated">Innodb_available_undo_logs</target>
        </trans-unit>
        <trans-unit id="bc6eb225564dc638bf3764e26f857863d4b31781" translate="yes" xml:space="preserve">
          <source>Innodb_background_log_sync</source>
          <target state="translated">Innodb_background_log_sync</target>
        </trans-unit>
        <trans-unit id="4b6a6b045ffac67c00e62ef8b629e3e72bdde732" translate="yes" xml:space="preserve">
          <source>Innodb_buffer_pool_bytes_data</source>
          <target state="translated">Innodb_buffer_pool_bytes_data</target>
        </trans-unit>
        <trans-unit id="6427309221c25a992c0431870ddae600b9a8d562" translate="yes" xml:space="preserve">
          <source>Innodb_buffer_pool_bytes_dirty</source>
          <target state="translated">Innodb_buffer_pool_bytes_dirty</target>
        </trans-unit>
        <trans-unit id="938b7ad3b1ed3f2fba0e94bbf26cf1597d4f4837" translate="yes" xml:space="preserve">
          <source>Innodb_buffer_pool_dump_status</source>
          <target state="translated">Innodb_buffer_pool_dump_status</target>
        </trans-unit>
        <trans-unit id="0b6d5e98fee9100929dce85c758ce172e6ea9215" translate="yes" xml:space="preserve">
          <source>Innodb_buffer_pool_load_incomplete</source>
          <target state="translated">Innodb_buffer_pool_load_incomplete</target>
        </trans-unit>
        <trans-unit id="7367d3dbee023d1ff4994cfc7b75d930b877551c" translate="yes" xml:space="preserve">
          <source>Innodb_buffer_pool_load_status</source>
          <target state="translated">Innodb_buffer_pool_load_status</target>
        </trans-unit>
        <trans-unit id="7ec8d031a8b631d30417c6bc1fe428267ab2ca56" translate="yes" xml:space="preserve">
          <source>Innodb_buffer_pool_pages_LRU_flushed</source>
          <target state="translated">Innodb_buffer_pool_pages_LRU_flushed</target>
        </trans-unit>
        <trans-unit id="e34a729c316259af30c8c7ad1b0775d437e81102" translate="yes" xml:space="preserve">
          <source>Innodb_buffer_pool_pages_data</source>
          <target state="translated">Innodb_buffer_pool_pages_data</target>
        </trans-unit>
        <trans-unit id="814bed816d8a2bde054f73270fb9d5129fe3914d" translate="yes" xml:space="preserve">
          <source>Innodb_buffer_pool_pages_dirty</source>
          <target state="translated">Innodb_buffer_pool_pages_dirty</target>
        </trans-unit>
        <trans-unit id="5e2fb3f551e448f0f9fcd0c5ab71077e0cce49cc" translate="yes" xml:space="preserve">
          <source>Innodb_buffer_pool_pages_flushed</source>
          <target state="translated">Innodb_buffer_pool_pages_flushed</target>
        </trans-unit>
        <trans-unit id="b43d2c75161f261348ff12f9af7805ab2c5b5362" translate="yes" xml:space="preserve">
          <source>Innodb_buffer_pool_pages_free</source>
          <target state="translated">Innodb_buffer_pool_pages_free</target>
        </trans-unit>
        <trans-unit id="7e77a6d943703e1ba56eae86d213e93a84da36a7" translate="yes" xml:space="preserve">
          <source>Innodb_buffer_pool_pages_made_not_young</source>
          <target state="translated">Innodb_buffer_pool_pages_made_not_young</target>
        </trans-unit>
        <trans-unit id="892218ff9b513f59f58f46ae4327813a9a86d949" translate="yes" xml:space="preserve">
          <source>Innodb_buffer_pool_pages_made_young</source>
          <target state="translated">Innodb_buffer_pool_pages_made_young</target>
        </trans-unit>
        <trans-unit id="8309907c2b2201de120151203851bd1d99dd2421" translate="yes" xml:space="preserve">
          <source>Innodb_buffer_pool_pages_misc</source>
          <target state="translated">Innodb_buffer_pool_pages_misc</target>
        </trans-unit>
        <trans-unit id="4d6857a8974ff7a9a76fdf4149169633c449a9d8" translate="yes" xml:space="preserve">
          <source>Innodb_buffer_pool_pages_old</source>
          <target state="translated">Innodb_buffer_pool_pages_old</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
