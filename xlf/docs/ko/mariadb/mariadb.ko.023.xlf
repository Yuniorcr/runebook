<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="mariadb">
    <body>
      <group id="mariadb">
        <trans-unit id="50b42da14599921af0cb6726f44a9db88af1dff2" translate="yes" xml:space="preserve">
          <source>INET6_NTOA() has been available from &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10012-release-notes/&quot;&gt;MariaDB 10.0.12&lt;/a&gt;.</source>
          <target state="translated">INET6_NTOA ()는 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10012-release-notes/&quot;&gt;MariaDB 10.0.12&lt;/a&gt; 에서 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="fd0d5a1c5d42917eb5f4b4d9a3a680975141cd3d" translate="yes" xml:space="preserve">
          <source>INET_ATON</source>
          <target state="translated">INET_ATON</target>
        </trans-unit>
        <trans-unit id="d022f4767e940ec54c3653b08e342a66e6f13ffb" translate="yes" xml:space="preserve">
          <source>INET_ATON()</source>
          <target state="translated">INET_ATON()</target>
        </trans-unit>
        <trans-unit id="980345785d00a49f1d0d4d718ab3ca3e690536e0" translate="yes" xml:space="preserve">
          <source>INET_NTOA</source>
          <target state="translated">INET_NTOA</target>
        </trans-unit>
        <trans-unit id="f5040f7bb520255d015eabf1dab0c638a1198569" translate="yes" xml:space="preserve">
          <source>INET_NTOA()</source>
          <target state="translated">INET_NTOA()</target>
        </trans-unit>
        <trans-unit id="d05e97a01bfb8208657572ec3e5d894c7ca6d8e9" translate="yes" xml:space="preserve">
          <source>INFILE</source>
          <target state="translated">INFILE</target>
        </trans-unit>
        <trans-unit id="cb74181384115f8a1cb63ac64149672a5f8180a1" translate="yes" xml:space="preserve">
          <source>INFLOW '14: NVM Compression&amp;mdash;Hybrid Flash-Aware Application Level Compression</source>
          <target state="translated">INFLOW '14 : NVM 압축 &amp;mdash; 하이브리드 플래시 인식 응용 프로그램 수준 압축</target>
        </trans-unit>
        <trans-unit id="caa43f1c3f72ad668d50e33fe9dbd4537b54ed34" translate="yes" xml:space="preserve">
          <source>INFORMATION SCHEMA VIEWS Table</source>
          <target state="translated">정보 스키마 뷰 테이블</target>
        </trans-unit>
        <trans-unit id="4ce8800787a56cddc1663d422c3fda9b36123dde" translate="yes" xml:space="preserve">
          <source>INFORMATION_SCHEMA ROUTINES Table</source>
          <target state="translated">INFORMATION_SCHEMA ROUTINES 테이블</target>
        </trans-unit>
        <trans-unit id="d1499ca62d36134bc5693713394786f8b941fb6f" translate="yes" xml:space="preserve">
          <source>INFORMATION_SCHEMA.COLUMNS Table</source>
          <target state="translated">INFORMATION_SCHEMA.COLUMNS 테이블</target>
        </trans-unit>
        <trans-unit id="4bf7b5d7bb6ffb009b717ad4751ce332fdd66afc" translate="yes" xml:space="preserve">
          <source>INFORMATION_SCHEMA.PLUGINS Table</source>
          <target state="translated">INFORMATION_SCHEMA.PLUGINS 테이블</target>
        </trans-unit>
        <trans-unit id="f2819c72b7dd2d1c07dc59ab9c2ea5a6591d270a" translate="yes" xml:space="preserve">
          <source>INGENIEUR</source>
          <target state="translated">INGENIEUR</target>
        </trans-unit>
        <trans-unit id="e7eb1f3fa97480d0a00295acb4acc566a473a87d" translate="yes" xml:space="preserve">
          <source>INI</source>
          <target state="translated">INI</target>
        </trans-unit>
        <trans-unit id="7d648a728a4737779ef7f4150b74bea727e228d6" translate="yes" xml:space="preserve">
          <source>INI Table Type</source>
          <target state="translated">INI 테이블 타입</target>
        </trans-unit>
        <trans-unit id="fd4d2f0d5aa850e30c0830c19e27d0fa4c65c7a7" translate="yes" xml:space="preserve">
          <source>INITIALLY</source>
          <target state="translated">INITIALLY</target>
        </trans-unit>
        <trans-unit id="88d86d54436967d4b4599d22d53c2a3db38390e6" translate="yes" xml:space="preserve">
          <source>INNER</source>
          <target state="translated">INNER</target>
        </trans-unit>
        <trans-unit id="17405a4822dd2e9bd239b579b9034a52cace3085" translate="yes" xml:space="preserve">
          <source>INNODB_CMP and INNODB_CMP_RESET</source>
          <target state="translated">INNODB_CMP 및 INNODB_CMP_RESET</target>
        </trans-unit>
        <trans-unit id="bf22d2b767d5719359b73693d1610cf97e773d60" translate="yes" xml:space="preserve">
          <source>INNODB_CMPMEM and INNODB_CMPMEM_RESET</source>
          <target state="translated">INNODB_CMPMEM 및 INNODB_CMPMEM_RESET</target>
        </trans-unit>
        <trans-unit id="a5839ab4bba88aabcc89c6eefe7171eeeb279d63" translate="yes" xml:space="preserve">
          <source>INNODB_CMP_PER_INDEX and INNODB_CMP_PER_INDEX_RESET</source>
          <target state="translated">INNODB_CMP_PER_INDEX 및 INNODB_CMP_PER_INDEX_RESET</target>
        </trans-unit>
        <trans-unit id="1c4cdb7355976e7613bf170c150d4d0061114b3d" translate="yes" xml:space="preserve">
          <source>INOUT</source>
          <target state="translated">INOUT</target>
        </trans-unit>
        <trans-unit id="397fff4a0e90aa11cdba9f0130429d20a47a5607" translate="yes" xml:space="preserve">
          <source>INSENSITIVE</source>
          <target state="translated">INSENSITIVE</target>
        </trans-unit>
        <trans-unit id="c20ea07e32d25c072a65368c234d6f5a88f4521a" translate="yes" xml:space="preserve">
          <source>INSERT</source>
          <target state="translated">INSERT</target>
        </trans-unit>
        <trans-unit id="38c1468afdea6a18230b8f7459ea2284e363ff50" translate="yes" xml:space="preserve">
          <source>INSERT - Default &amp;amp; Duplicate Values</source>
          <target state="translated">삽입-기본값 및 중복 값</target>
        </trans-unit>
        <trans-unit id="dece2b708ab1c86d202d1cc49ebff8921ddeb630" translate="yes" xml:space="preserve">
          <source>INSERT .. SELECT to move the data from `Staging` into the Fact table</source>
          <target state="translated">INSERT ..`Staging`에서 Fact 테이블로 데이터를 이동 시키려면 SELECT</target>
        </trans-unit>
        <trans-unit id="7e2a8c5b69b1e4e7c1c44ff32f1418469af24296" translate="yes" xml:space="preserve">
          <source>INSERT ... ON DUPLICATE KEY UPDATE</source>
          <target state="translated">INSERT ... 중복 키 업데이트시</target>
        </trans-unit>
        <trans-unit id="68e8b6e77a3c6ab22f6cebd56902806cf5eba3ad" translate="yes" xml:space="preserve">
          <source>INSERT ... ON DUPLICATE KEY UPDATE is a MariaDB/MySQL extension to the &lt;a href=&quot;../insert/index&quot;&gt;INSERT&lt;/a&gt; statement that, if it finds a duplicate unique or primary key, will instead perform an &lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt;.</source>
          <target state="translated">INSERT ... ON DUPLICATE KEY UPDATE는 &lt;a href=&quot;../insert/index&quot;&gt;INSERT&lt;/a&gt; 문에 대한 MariaDB / MySQL 확장 으로서 중복 된 고유 키 또는 기본 키를 발견하면 대신 &lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt; 를 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="6cf006b32601c4612de63d359fc9a250351fdfa8" translate="yes" xml:space="preserve">
          <source>INSERT ... RETURNING</source>
          <target state="translated">INSERT ... 반환</target>
        </trans-unit>
        <trans-unit id="10d54df9c2893dd569999f279642caf49c896c15" translate="yes" xml:space="preserve">
          <source>INSERT ... RETURNING will be available in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1051-release-notes/&quot;&gt;MariaDB 10.5.1&lt;/a&gt;.</source>
          <target state="translated">INSERT ... RETURNING은 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1051-release-notes/&quot;&gt;MariaDB 10.5.1&lt;/a&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="080740cf1b35e55dbf908da3ca0ef5a011adaafb" translate="yes" xml:space="preserve">
          <source>INSERT ... SELECT</source>
          <target state="translated">삽입 ... 선택</target>
        </trans-unit>
        <trans-unit id="c7211f40bb3b65ff1de7000933903b91b0538efb" translate="yes" xml:space="preserve">
          <source>INSERT Command</source>
          <target state="translated">INSERT 명령</target>
        </trans-unit>
        <trans-unit id="67f62edcf287a3b8cd8b604753788b31358bd6f9" translate="yes" xml:space="preserve">
          <source>INSERT DELAYED</source>
          <target state="translated">삽입 지연</target>
        </trans-unit>
        <trans-unit id="dd41181a6e11a7f83ef914618d083316c69f601b" translate="yes" xml:space="preserve">
          <source>INSERT DELAYED can't be used with table '%s' because it is locked with LOCK TABLES</source>
          <target state="translated">INSERT DELAYED는 LOCK TABLES로 잠겨 있기 때문에 '% s'테이블과 함께 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="08b4369556b85bfce4ce0c4996d8f15b48c9a49c" translate="yes" xml:space="preserve">
          <source>INSERT Function</source>
          <target state="translated">삽입 기능</target>
        </trans-unit>
        <trans-unit id="0a43817f1a13899635aeefbe745c61fcdc603597" translate="yes" xml:space="preserve">
          <source>INSERT IGNORE</source>
          <target state="translated">INSERT IGNORE</target>
        </trans-unit>
        <trans-unit id="838d1a13079816f9d8b1d4d1057c1d8def37fbb0" translate="yes" xml:space="preserve">
          <source>INSERT IGNORE... SELECT is unsafe because the order in which rows are retrieved by the SELECT determines which (if any) rows are ignored. This order cannot be predicted and may differ on master and the slave.</source>
          <target state="translated">INSERT IGNORE ... SELECT는 행이 검색되는 순서에 따라 무시되는 행이 결정되므로 안전하지 않습니다. 이 순서는 예측할 수 없으며 마스터와 슬레이브에서 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39def9e477e9e43c866d2b48576b99bdfb662885" translate="yes" xml:space="preserve">
          <source>INSERT INTO Fact (.,.,.) VALUES (.,.,.), (.,.,.), ...; -- &quot;Batch insert&quot;</source>
          <target state="translated">팩트에 삽입 (.,.,.) 값 (.,.,.), (.,.,.), ...; - &quot;배치 인서트&quot;</target>
        </trans-unit>
        <trans-unit id="f3676ceb84f3f9001e22f4dc181475fba2792635" translate="yes" xml:space="preserve">
          <source>INSERT INTO Fact SELECT * FROM Staging; This INSERT..SELECT allows you to do other things, such as normalization. More later.</source>
          <target state="translated">팩트 선택에 삽입 * 스테이징; 이 INSERT..SELECT를 사용하면 정규화와 같은 다른 작업을 수행 할 수 있습니다. 더 늦게.</target>
        </trans-unit>
        <trans-unit id="c37ca177e55f25188cd6f24aa0630d437b63747d" translate="yes" xml:space="preserve">
          <source>INSERT ON DUPLICATE KEY UPDATE</source>
          <target state="translated">중복 키 업데이트에 대한 삽입</target>
        </trans-unit>
        <trans-unit id="e72502a4fb06d289d691a9af032a5549608dce20" translate="yes" xml:space="preserve">
          <source>INSERT SELECT</source>
          <target state="translated">삽입 선택</target>
        </trans-unit>
        <trans-unit id="e0b1035081b6b5d52e7db96f679e0c9faaddcf3b" translate="yes" xml:space="preserve">
          <source>INSERT and loading</source>
          <target state="translated">삽입 및 로딩</target>
        </trans-unit>
        <trans-unit id="2d331d2fd690f8ab95ecd42d9b2322936de5b2fc" translate="yes" xml:space="preserve">
          <source>INSERT batch size</source>
          <target state="translated">삽입 배치 크기</target>
        </trans-unit>
        <trans-unit id="508eecaec1ac99b7d53e6ce15dc1632045692e90" translate="yes" xml:space="preserve">
          <source>INSERT if no duplicate key is found, otherwise UPDATE</source>
          <target state="translated">중복 키가 없으면 INSERT, 그렇지 않으면 UPDATE</target>
        </trans-unit>
        <trans-unit id="b1a771698b31b06ad0f33444ef624e1225e4818c" translate="yes" xml:space="preserve">
          <source>INSERT into autoincrement field which is not the first part in the composed primary key is unsafe.</source>
          <target state="translated">구성된 기본 키의 첫 번째 부분이 아닌 자동 증분 필드에 삽입하는 것은 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dc1c444a0a674f26aa69d22aea80532283b7688d" translate="yes" xml:space="preserve">
          <source>INSERT()</source>
          <target state="translated">INSERT()</target>
        </trans-unit>
        <trans-unit id="a6895ffa842c94a50a72686e0e27d886e22db783" translate="yes" xml:space="preserve">
          <source>INSERT, UPDATE and DELETE statements can be particularly heavy operations to perform, as all indexes need to be updated after each change. For this reason these changes are often buffered.</source>
          <target state="translated">INSERT, UPDATE 및 DELETE 문은 각 인덱스 변경 후에 모든 인덱스를 업데이트해야하므로 특히 수행해야하는 작업이 많을 수 있습니다. 이러한 이유로 이러한 변경 사항은 종종 버퍼링됩니다.</target>
        </trans-unit>
        <trans-unit id="44519d27508dc70f7a139b87f074cc019d2a47a3" translate="yes" xml:space="preserve">
          <source>INSERT... ON DUPLICATE KEY UPDATE on a table with more than one UNIQUE KEY is unsafe</source>
          <target state="translated">삽입 ... 둘 이상의 고유 키가있는 테이블에서 중복 키 업데이트시 안전하지 않음</target>
        </trans-unit>
        <trans-unit id="ab0d891e1242aaea4c9f12f0ca0d99cd5e2196f2" translate="yes" xml:space="preserve">
          <source>INSERT... SELECT... ON DUPLICATE KEY UPDATE is unsafe because the order in which rows are retrieved by the SELECT determines which (if any) rows are updated. This order cannot be predicted and may differ on master and the slave.</source>
          <target state="translated">INSERT ... SELECT ... ON DUPLICATE KEY UPDATE는 SELECT에 의해 행을 검색하는 순서에 따라 업데이트 될 행이 결정되므로 안전하지 않습니다. 이 순서는 예측할 수 없으며 마스터와 슬레이브에서 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04815baf1494bd34ef3f7d495f3e93886f4b2b24" translate="yes" xml:space="preserve">
          <source>INSERT...RETURNING</source>
          <target state="translated">INSERT...RETURNING</target>
        </trans-unit>
        <trans-unit id="b66af6add5248f6cc3d7ed7bd0f91811d8f20373" translate="yes" xml:space="preserve">
          <source>INSTALL PLUGIN</source>
          <target state="translated">플러그인 설치</target>
        </trans-unit>
        <trans-unit id="729ff8b60048c0b3c786bf33af9215cfec45e69b" translate="yes" xml:space="preserve">
          <source>INSTALL SONAME</source>
          <target state="translated">SONAME 설치</target>
        </trans-unit>
        <trans-unit id="4fc1395df84dfdf2f80f047198c1f3b574bb81e0" translate="yes" xml:space="preserve">
          <source>INSTALL SONAME has been supported since &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5521-release-notes/&quot;&gt;MariaDB 5.5.21&lt;/a&gt;.</source>
          <target state="translated">INSTALL SONAME은 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5521-release-notes/&quot;&gt;MariaDB 5.5.21&lt;/a&gt; 부터 지원되었습니다 .</target>
        </trans-unit>
        <trans-unit id="77a997d245adbecfd4396dc5c027f2f010f50830" translate="yes" xml:space="preserve">
          <source>INSTALL {&lt;a href=&quot;../install-plugin/index&quot;&gt;PLUGIN&lt;/a&gt; | &lt;a href=&quot;../install-soname/index&quot;&gt;SONAME&lt;/a&gt;}</source>
          <target state="translated">설치 { &lt;a href=&quot;../install-plugin/index&quot;&gt;PLUGIN&lt;/a&gt; | &lt;a href=&quot;../install-soname/index&quot;&gt;SONAME&lt;/a&gt; }</target>
        </trans-unit>
        <trans-unit id="13a4119956adaaa86ae9cb982935d1c8ec924ed8" translate="yes" xml:space="preserve">
          <source>INSTALLDIR</source>
          <target state="translated">INSTALLDIR</target>
        </trans-unit>
        <trans-unit id="78c28743ff190a4db411b49fb89eb31bee325c93" translate="yes" xml:space="preserve">
          <source>INSTALLDIR\data</source>
          <target state="translated">INSTALLDIR\data</target>
        </trans-unit>
        <trans-unit id="11692ffcea3667492741cd536a6476281d35f3ea" translate="yes" xml:space="preserve">
          <source>INSTR</source>
          <target state="translated">INSTR</target>
        </trans-unit>
        <trans-unit id="1978e07eae288a50d2b53a0c90f951950a6ae0c2" translate="yes" xml:space="preserve">
          <source>INSTR()</source>
          <target state="translated">INSTR()</target>
        </trans-unit>
        <trans-unit id="793985cddb68d46ef51b688aecf85864c9e06813" translate="yes" xml:space="preserve">
          <source>INT</source>
          <target state="translated">INT</target>
        </trans-unit>
        <trans-unit id="fb26155faf1e6f97466da87a640b75b983fe6d3d" translate="yes" xml:space="preserve">
          <source>INT UNSIGNED with constants computed as unix timestamps.</source>
          <target state="translated">유닉스 타임 스탬프로 계산 된 상수를 가진 INT UNSIGNED.</target>
        </trans-unit>
        <trans-unit id="60e4eddac93ad49f5da9e6f5183ee8ab0ad147bd" translate="yes" xml:space="preserve">
          <source>INT UNSIGNED with constants for some non-time-based series.</source>
          <target state="translated">비 시간 계열 계열에 대한 상수로 INT UNSIGNED.</target>
        </trans-unit>
        <trans-unit id="6ef928726da8fe58f4e66fc244140c2bf0e00cef" translate="yes" xml:space="preserve">
          <source>INT/TINYINT/SMALLINT/BIGINT</source>
          <target state="translated">INT/TINYINT/SMALLINT/BIGINT</target>
        </trans-unit>
        <trans-unit id="d4310d7a6b5906db2b2a34d24641be6b8da8da66" translate="yes" xml:space="preserve">
          <source>INT1</source>
          <target state="translated">INT1</target>
        </trans-unit>
        <trans-unit id="a3a0ec55e3e26ee54417c786dfad5d709ecb7c40" translate="yes" xml:space="preserve">
          <source>INT2</source>
          <target state="translated">INT2</target>
        </trans-unit>
        <trans-unit id="f3faa3cdcd9796c108513fab2eaf59c1cd196d1e" translate="yes" xml:space="preserve">
          <source>INT3</source>
          <target state="translated">INT3</target>
        </trans-unit>
        <trans-unit id="be9d5856c1bd71388ff9c8026a9e0421d50eb06e" translate="yes" xml:space="preserve">
          <source>INT4</source>
          <target state="translated">INT4</target>
        </trans-unit>
        <trans-unit id="021a30ffe1ce8750cb57ce941d7fb3d04090b37c" translate="yes" xml:space="preserve">
          <source>INT8</source>
          <target state="translated">INT8</target>
        </trans-unit>
        <trans-unit id="0fe37e40e5dab3ac411c2ddca6d21991e811acfa" translate="yes" xml:space="preserve">
          <source>INTEGER</source>
          <target state="translated">INTEGER</target>
        </trans-unit>
        <trans-unit id="8c5f25317b17dedece743e2eb3d408dbbc280c11" translate="yes" xml:space="preserve">
          <source>INTEGER, DECIMAL, NUMERIC, FLOAT</source>
          <target state="translated">정수, 십진법, 숫자, 실수</target>
        </trans-unit>
        <trans-unit id="c765a2e299a6cf5d8f67d4988b7e5cb0db89e33b" translate="yes" xml:space="preserve">
          <source>INTEGER/INT</source>
          <target state="translated">INTEGER/INT</target>
        </trans-unit>
        <trans-unit id="3230de938114213aa9c2d1e95f291cad51ede171" translate="yes" xml:space="preserve">
          <source>INTERSECT</source>
          <target state="translated">INTERSECT</target>
        </trans-unit>
        <trans-unit id="3db392e390c5765bced57aa969f421e28c3ff5fb" translate="yes" xml:space="preserve">
          <source>INTERSECT was introduced in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1030-release-notes/&quot;&gt;MariaDB 10.3.0&lt;/a&gt;.</source>
          <target state="translated">INTERSECT는 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1030-release-notes/&quot;&gt;MariaDB 10.3.0&lt;/a&gt; 에서 도입되었습니다 .</target>
        </trans-unit>
        <trans-unit id="d91d9f71e2e2bbca1f77b0c371cf47adb7c1fa6f" translate="yes" xml:space="preserve">
          <source>INTERSECTS</source>
          <target state="translated">INTERSECTS</target>
        </trans-unit>
        <trans-unit id="0289c89cd5b573281a85d3ae623ecf9f43c52ab9" translate="yes" xml:space="preserve">
          <source>INTERSECTS() is based on the original MySQL implementation and uses object bounding rectangles, while &lt;a href=&quot;../st_intersects/index&quot;&gt;ST_INTERSECTS()&lt;/a&gt; uses object shapes.</source>
          <target state="translated">INTERSECTS ()는 원래 MySQL 구현을 기반으로하며 객체 경계 사각형을 사용하고 &lt;a href=&quot;../st_intersects/index&quot;&gt;ST_INTERSECTS ()&lt;/a&gt; 는 객체 모양을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c1cfa9e8cce52355e3bd6bfd4799c3d01d5e70fa" translate="yes" xml:space="preserve">
          <source>INTERSECTS() tests the opposite relationship to &lt;a href=&quot;../disjoint/index&quot;&gt;DISJOINT()&lt;/a&gt;.</source>
          <target state="translated">INTERSECTS ()는 &lt;a href=&quot;../disjoint/index&quot;&gt;DISJOINT ()&lt;/a&gt; 와 반대 관계를 테스트합니다 .</target>
        </trans-unit>
        <trans-unit id="c37a2373e34e9bdcd71d22081153b4ebedc9c58a" translate="yes" xml:space="preserve">
          <source>INTERVAL</source>
          <target state="translated">INTERVAL</target>
        </trans-unit>
        <trans-unit id="a9337645bdb2e4ae1023d6596e40621a2b4eb384" translate="yes" xml:space="preserve">
          <source>INTERVAL is either not positive or too big</source>
          <target state="translated">간격이 양수가 아니거나 너무 큽니다</target>
        </trans-unit>
        <trans-unit id="ce45b16212fe00c28d1a00de9cdfe954aa5bdc83" translate="yes" xml:space="preserve">
          <source>INTO</source>
          <target state="translated">INTO</target>
        </trans-unit>
        <trans-unit id="a9295d42409ebe2d3c54569dcb1fb2181f2c102d" translate="yes" xml:space="preserve">
          <source>INTO DUMPFILE 'file_name'</source>
          <target state="translated">덤프 파일 'file_name'으로</target>
        </trans-unit>
        <trans-unit id="9c362bda6612a02863bb89afbd7b7b6b290482ec" translate="yes" xml:space="preserve">
          <source>INTO var_name [, var_name] ]</source>
          <target state="translated">var_name [, var_name]]으로</target>
        </trans-unit>
        <trans-unit id="0a42d367a4b3a2f1783237c312372bbeddacc860" translate="yes" xml:space="preserve">
          <source>IO Read error: (%lu, %s) %s</source>
          <target state="translated">IO 읽기 오류 : (% lu, % s) % s</target>
        </trans-unit>
        <trans-unit id="b86adf75aa4c93e11db663fea617f5d80dbfd88d" translate="yes" xml:space="preserve">
          <source>IO Write error: (%lu, %s) %s</source>
          <target state="translated">IO 쓰기 오류 : (% lu, % s) % s</target>
        </trans-unit>
        <trans-unit id="aa59749f6a66f891a46de61e97421a1306054981" translate="yes" xml:space="preserve">
          <source>IO scheduler</source>
          <target state="translated">IO 스케줄러</target>
        </trans-unit>
        <trans-unit id="18b1ac57cb6ca1c255dd884c6e66f67cf52f26d9" translate="yes" xml:space="preserve">
          <source>IODKU (Insert On Duplicate Key Update) will update an existing row or create a new row. It knows which to do based on the Summary table's PRIMARY KEY.</source>
          <target state="translated">IODKU (중복 키 업데이트 삽입)는 기존 행을 업데이트하거나 새 행을 만듭니다. 요약 테이블의 기본 키를 기반으로 수행 할 작업을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="e828f582f4e653ac3448c38fb599c8af2fa3a3ad" translate="yes" xml:space="preserve">
          <source>ION - transforms ioDrive into a shareable storage</source>
          <target state="translated">ION-ioDrive를 공유 가능한 스토리지로 변환</target>
        </trans-unit>
        <trans-unit id="ea424d38af72dd1366a08aad1f47eca3e7ec3d24" translate="yes" xml:space="preserve">
          <source>IP</source>
          <target state="translated">IP</target>
        </trans-unit>
        <trans-unit id="bc0fa4ce6f14c834557971d4b50034d1c80468f7" translate="yes" xml:space="preserve">
          <source>IP Range Table Performance</source>
          <target state="translated">IP 범위 테이블 성능</target>
        </trans-unit>
        <trans-unit id="2d4ed8865f0ed43f38a32795824d4f3549c26b9c" translate="yes" xml:space="preserve">
          <source>IP Range Table Performance Improvements</source>
          <target state="translated">IP 범위 테이블 성능 개선</target>
        </trans-unit>
        <trans-unit id="99a1caa5a191378660330a2316dc747ce9d779fb" translate="yes" xml:space="preserve">
          <source>IP address</source>
          <target state="translated">IP 주소</target>
        </trans-unit>
        <trans-unit id="34e9c8f1c3e908d3541b9298aa01322122b98d37" translate="yes" xml:space="preserve">
          <source>IP's resolved DNS host name, or &lt;code&gt;NULL&lt;/code&gt; if unknown.</source>
          <target state="translated">IP가 확인 된 DNS 호스트 이름이거나 알 수없는 경우 &lt;code&gt;NULL&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a68fa8efe4a09d8c0c63ae60426d9366434bccb2" translate="yes" xml:space="preserve">
          <source>IRC</source>
          <target state="translated">IRC</target>
        </trans-unit>
        <trans-unit id="ec4a2a5056d72d8e03345caaebf4607d163e6dd7" translate="yes" xml:space="preserve">
          <source>IS</source>
          <target state="translated">IS</target>
        </trans-unit>
        <trans-unit id="819809f7649d3da66fd65a40dff83509ed2b98d0" translate="yes" xml:space="preserve">
          <source>IS NOT</source>
          <target state="translated">아니다</target>
        </trans-unit>
        <trans-unit id="a6df0f993385336b711715120aa8ff7fe24eaec6" translate="yes" xml:space="preserve">
          <source>IS NOT NULL</source>
          <target state="translated">NULL이 아님</target>
        </trans-unit>
        <trans-unit id="9de38ddc0e52c0319211a61e94b4bc11ab39629c" translate="yes" xml:space="preserve">
          <source>IS NOT NULL operator</source>
          <target state="translated">IS NOT NULL 연산자</target>
        </trans-unit>
        <trans-unit id="20d3394ad7ad074fe7a2f2f68a77c18aabcd0711" translate="yes" xml:space="preserve">
          <source>IS NULL</source>
          <target state="translated">NULL</target>
        </trans-unit>
        <trans-unit id="d85ac9467e5f682ce2170526a955b877a08195cb" translate="yes" xml:space="preserve">
          <source>IS NULL operator</source>
          <target state="translated">IS NULL 연산자</target>
        </trans-unit>
        <trans-unit id="75a498e65eb0be862538d3aa6bc13bfd88414272" translate="yes" xml:space="preserve">
          <source>IS1</source>
          <target state="translated">IS1</target>
        </trans-unit>
        <trans-unit id="cd81fbe05b5c4fc2ca9033a460877910bdcfe73e" translate="yes" xml:space="preserve">
          <source>IS2</source>
          <target state="translated">IS2</target>
        </trans-unit>
        <trans-unit id="55ae3706ba34465cdd3bef5883f7d940c1b15555" translate="yes" xml:space="preserve">
          <source>IS3</source>
          <target state="translated">IS3</target>
        </trans-unit>
        <trans-unit id="be9f864499d2dc6b48446a2a4ab19ed7a4f25b97" translate="yes" xml:space="preserve">
          <source>IS4</source>
          <target state="translated">IS4</target>
        </trans-unit>
        <trans-unit id="804525c8009e09a9b3f128e566dab3e3b40f20f8" translate="yes" xml:space="preserve">
          <source>ISBN</source>
          <target state="translated">ISBN</target>
        </trans-unit>
        <trans-unit id="4e93120a53b25e7642cc15924ececcc7c79ac693" translate="yes" xml:space="preserve">
          <source>ISNULL</source>
          <target state="translated">ISNULL</target>
        </trans-unit>
        <trans-unit id="18d40741b02fd0579c50bd8af5992cfe7ba68244" translate="yes" xml:space="preserve">
          <source>ISNULL function</source>
          <target state="translated">ISNULL 함수</target>
        </trans-unit>
        <trans-unit id="ab8576210aa9dc381f2cd242ce3ad381459d46f7" translate="yes" xml:space="preserve">
          <source>ISNULL()</source>
          <target state="translated">ISNULL()</target>
        </trans-unit>
        <trans-unit id="b2e93ebb3a976038add0f648b7f174d09bc3fbaf" translate="yes" xml:space="preserve">
          <source>ISO 8859-13 Baltic</source>
          <target state="translated">ISO 8859-13 발트 어</target>
        </trans-unit>
        <trans-unit id="223e24a89dd0a26b59604b2b31cc673c3095ccc4" translate="yes" xml:space="preserve">
          <source>ISO 8859-2 Central European</source>
          <target state="translated">ISO 8859-2 중앙 유럽</target>
        </trans-unit>
        <trans-unit id="25885b4bdebe367dd767876b0b31e390af4a5f05" translate="yes" xml:space="preserve">
          <source>ISO 8859-7 Greek</source>
          <target state="translated">ISO 8859-7 그리스어</target>
        </trans-unit>
        <trans-unit id="494ed07ee800943512929f48dc12ffe50d7f5068" translate="yes" xml:space="preserve">
          <source>ISO 8859-8 Hebrew</source>
          <target state="translated">ISO 8859-8 히브리어</target>
        </trans-unit>
        <trans-unit id="f6df4b3d467d2d1f9d9210e3e5234034c8d9d4a0" translate="yes" xml:space="preserve">
          <source>ISO 8859-9 Turkish</source>
          <target state="translated">ISO 8859-9 터키어</target>
        </trans-unit>
        <trans-unit id="4eb8010f74dc00bb39d40cc854c7f5f260d0f67a" translate="yes" xml:space="preserve">
          <source>IS_AUTOINCREMENT</source>
          <target state="translated">IS_AUTOINCREMENT</target>
        </trans-unit>
        <trans-unit id="6d47ce239db3557bdffb70cdbaaca7e8b841d77b" translate="yes" xml:space="preserve">
          <source>IS_FREE_LOCK</source>
          <target state="translated">IS_FREE_LOCK</target>
        </trans-unit>
        <trans-unit id="9f6c43532eb5e91ccf7d33e50666b4fb6a171d22" translate="yes" xml:space="preserve">
          <source>IS_FREE_LOCK()</source>
          <target state="translated">IS_FREE_LOCK()</target>
        </trans-unit>
        <trans-unit id="f9f908d95e91cfb22d64e573cae47a4eda4728d1" translate="yes" xml:space="preserve">
          <source>IS_IPV4</source>
          <target state="translated">IS_IPV4</target>
        </trans-unit>
        <trans-unit id="d1bb88962644f674c13c3abfb08651c5b0e439f2" translate="yes" xml:space="preserve">
          <source>IS_IPV4() has been available since &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10012-release-notes/&quot;&gt;MariaDB 10.0.12&lt;/a&gt;.</source>
          <target state="translated">IS_IPV4 ()는 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10012-release-notes/&quot;&gt;MariaDB 10.0.12&lt;/a&gt; 부터 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="08d0f78183f50708a405d47a893c7d3a32f8e443" translate="yes" xml:space="preserve">
          <source>IS_IPV4() is stricter than &lt;a href=&quot;../inet_aton/index&quot;&gt;INET_ATON()&lt;/a&gt;, but as strict as &lt;a href=&quot;../inet6_aton/index&quot;&gt;INET6_ATON()&lt;/a&gt;, in determining the validity of an IPv4 address. This implies that if IS_IPV4 returns 1, the same expression will always return a non-NULL result when passed to INET_ATON(), but that the reverse may not apply.</source>
          <target state="translated">IS_IPV4 ()는 IPv4 주소의 유효성을 판별하는 데 &lt;a href=&quot;../inet_aton/index&quot;&gt;INET_ATON ()&lt;/a&gt; 보다 엄격 하지만 &lt;a href=&quot;../inet6_aton/index&quot;&gt;INET6_ATON ()&lt;/a&gt; 만큼 엄격 합니다. 이는 IS_IPV4가 1을 반환하면 동일한식이 INET_ATON ()에 전달 될 때 항상 NULL이 아닌 결과를 반환하지만 그 반대의 경우는 적용되지 않을 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="54eaa74dbf14bb50118770e0d81026ced6cdc3df" translate="yes" xml:space="preserve">
          <source>IS_IPV4_COMPAT</source>
          <target state="translated">IS_IPV4_COMPAT</target>
        </trans-unit>
        <trans-unit id="b6911b8d93b2900400f821e864b9347a76d43178" translate="yes" xml:space="preserve">
          <source>IS_IPV4_COMPAT() has been available since &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10012-release-notes/&quot;&gt;MariaDB 10.0.12&lt;/a&gt;.</source>
          <target state="translated">IS_IPV4_COMPAT ()는 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10012-release-notes/&quot;&gt;MariaDB 10.0.12&lt;/a&gt; 부터 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="d4e87a7ed29b4b7b7ceb95dec4f4f22783ccd854" translate="yes" xml:space="preserve">
          <source>IS_IPV4_MAPPED</source>
          <target state="translated">IS_IPV4_MAPPED</target>
        </trans-unit>
        <trans-unit id="82afbf8e5bcf810a9f4d8353aa45a350cbda5540" translate="yes" xml:space="preserve">
          <source>IS_IPV4_MAPPED() has been available since &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10012-release-notes/&quot;&gt;MariaDB 10.0.12&lt;/a&gt;.</source>
          <target state="translated">IS_IPV4_MAPPED ()는 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10012-release-notes/&quot;&gt;MariaDB 10.0.12&lt;/a&gt; 부터 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="16a7c0cb8dfc28d8f03c599da47363b006e90658" translate="yes" xml:space="preserve">
          <source>IS_IPV6</source>
          <target state="translated">IS_IPV6</target>
        </trans-unit>
        <trans-unit id="3fe3a1cee9c3e8e5e8b89f81e24c0e05c3556366" translate="yes" xml:space="preserve">
          <source>IS_IPV6() has been available since &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10012-release-notes/&quot;&gt;MariaDB 10.0.12&lt;/a&gt;.</source>
          <target state="translated">IS_IPV6 ()은 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10012-release-notes/&quot;&gt;MariaDB 10.0.12&lt;/a&gt; 부터 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="c77bd75e20ecbd52166f2ddbc6668b84ec44e49b" translate="yes" xml:space="preserve">
          <source>IS_NULLABLE</source>
          <target state="translated">IS_NULLABLE</target>
        </trans-unit>
        <trans-unit id="b69a5d44307e70ade032136442debf2e14779b73" translate="yes" xml:space="preserve">
          <source>IS_USED_LOCK</source>
          <target state="translated">IS_USED_LOCK</target>
        </trans-unit>
        <trans-unit id="d391da92e5551a22908f9b78045bab0ade9f1273" translate="yes" xml:space="preserve">
          <source>IS_USED_LOCK()</source>
          <target state="translated">IS_USED_LOCK()</target>
        </trans-unit>
        <trans-unit id="88305133ac573e65d839712ea0345ca6d26f514a" translate="yes" xml:space="preserve">
          <source>ITERATE</source>
          <target state="translated">ITERATE</target>
        </trans-unit>
        <trans-unit id="b3c92eecf0aa1905086059d9f6d3261d8fb19657" translate="yes" xml:space="preserve">
          <source>Iceland</source>
          <target state="translated">Iceland</target>
        </trans-unit>
        <trans-unit id="4908b12c142b7bd671d43e5185556c158bb0999c" translate="yes" xml:space="preserve">
          <source>Icelandic</source>
          <target state="translated">Icelandic</target>
        </trans-unit>
        <trans-unit id="316319865ed9e1fbafc9594d09703c1b74f45f41" translate="yes" xml:space="preserve">
          <source>Ideally, you want to have a large enough gcache to avoid a &lt;a href=&quot;../introduction-to-state-snapshot-transfers-ssts/index&quot;&gt;State Snapshot Transfer (SST)&lt;/a&gt; during the rolling upgrade. The gcache size can be configured by setting &lt;code&gt;&lt;a href=&quot;../wsrep_provider_options/index#gcachesize&quot;&gt;gcache.size&lt;/a&gt;&lt;/code&gt; For example:</source>
          <target state="translated">롤링 업그레이드 중에 &lt;a href=&quot;../introduction-to-state-snapshot-transfers-ssts/index&quot;&gt;SST (State Snapshot Transfer)&lt;/a&gt; 를 피하기에 충분한 gcache를 보유하는 것이 이상적 입니다. &lt;code&gt;&lt;a href=&quot;../wsrep_provider_options/index#gcachesize&quot;&gt;gcache.size&lt;/a&gt;&lt;/code&gt; 를 설정하여 gcache 크기를 구성 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="558c60f9417387233cc3886d2fe3d68bccc3da01" translate="yes" xml:space="preserve">
          <source>Identifier Case-sensitivity</source>
          <target state="translated">식별자 대소 문자 구분</target>
        </trans-unit>
        <trans-unit id="5ef6050e24ee4211dcc29ec98c1bf91db5d9062f" translate="yes" xml:space="preserve">
          <source>Identifier Names</source>
          <target state="translated">식별자 이름</target>
        </trans-unit>
        <trans-unit id="8558babff0d7c7242708b18f719cce3748dae5f1" translate="yes" xml:space="preserve">
          <source>Identifier Qualifiers</source>
          <target state="translated">식별자 한정자</target>
        </trans-unit>
        <trans-unit id="5fcc3a78fe2ee6dffdd6460b0d43292125f122ac" translate="yes" xml:space="preserve">
          <source>Identifier name '%s' is too long</source>
          <target state="translated">식별자 이름 '% s'이 (가) 너무 깁니다</target>
        </trans-unit>
        <trans-unit id="1a1e08c12602f91e523a79c111a23d318d6bb0c5" translate="yes" xml:space="preserve">
          <source>Identifier names may begin with a numeral, but can't only contain numerals unless quoted.</source>
          <target state="translated">식별자 이름은 숫자로 시작할 수 있지만 인용되지 않은 숫자 만 포함 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="e6ee891747e0c30645a94f179fdaa3747200547e" translate="yes" xml:space="preserve">
          <source>Identifier quotes can themselves be used as part of an identifier, as long as they are quoted.</source>
          <target state="translated">식별자 인용 부호는 인용 부호가있는 한 식별자의 일부로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae6d5e8096fcb2b5d36c4f7ce986cb131c13ea82" translate="yes" xml:space="preserve">
          <source>Identifier to File Name Mapping</source>
          <target state="translated">식별자 대 파일 이름 매핑</target>
        </trans-unit>
        <trans-unit id="0d13120fe1a5e61fc3e5c20108329e9d34310ba2" translate="yes" xml:space="preserve">
          <source>Identifiers are not permitted to contain the ASCII NUL character (U+0000) and supplementary characters (U+10000 and higher).</source>
          <target state="translated">식별자는 ASCII NUL 문자 (U + 0000) 및 보충 문자 (U + 10000 이상)를 포함 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6ac79fa5c723931ba27b3654cb189cdc973a2637" translate="yes" xml:space="preserve">
          <source>Identifiers are stored as Unicode (UTF-8)</source>
          <target state="translated">식별자는 유니 코드 (UTF-8)로 저장됩니다</target>
        </trans-unit>
        <trans-unit id="c73bbe7cff7546131280d3e66b3545e8e68c30a7" translate="yes" xml:space="preserve">
          <source>Identifiers may be quoted using the backtick character - &lt;code&gt;`&lt;/code&gt;. Quoting is optional for identifiers that don't contain special characters, or for identifiers that are not &lt;a href=&quot;../reserved-words/index&quot;&gt;reserved words&lt;/a&gt;. If the &lt;code&gt;ANSI_QUOTES&lt;/code&gt;&lt;a href=&quot;../sql-mode/index&quot;&gt;SQL_MODE&lt;/a&gt; flag is set, double quotes (&lt;code&gt;&quot;&lt;/code&gt;) can also be used to quote identifiers.</source>
          <target state="translated">식별자는 백틱 문자를 사용하여 인용 할 수있다 - &lt;code&gt;`&lt;/code&gt; . 인용은 특수 문자가 포함되지 않은 식별자 또는 &lt;a href=&quot;../reserved-words/index&quot;&gt;예약어&lt;/a&gt; 가 아닌 식별자의 경우 선택 사항입니다 . 는 IF &lt;code&gt;ANSI_QUOTES&lt;/code&gt; &lt;a href=&quot;../sql-mode/index&quot;&gt;SQL_MODE의&lt;/a&gt; 플래그가 설정되어, 큰 따옴표 ( &lt;code&gt;&quot;&lt;/code&gt; )도 식별자를 인용하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="45b2928135016e375247fd90b2a788a85fc3342b" translate="yes" xml:space="preserve">
          <source>Identifiers may or may not be case-sensitive. See &lt;a href=&quot;../identifier-case-sensitivity/index&quot;&gt;Indentifier Case-sensitivity&lt;/a&gt;.</source>
          <target state="translated">식별자는 대소 문자를 구분하거나 구분하지 않을 수 있습니다. &lt;a href=&quot;../identifier-case-sensitivity/index&quot;&gt;식별자 대소 문자 구분을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bcbd29906292f594f4e80bfd78b0eeca3b07f8ce" translate="yes" xml:space="preserve">
          <source>Identifiers used to identify a BEGIN ... END construct.</source>
          <target state="translated">BEGIN ... END 구문을 식별하는 데 사용되는 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="46fd858915757864deda003fc79f765db0fb9912" translate="yes" xml:space="preserve">
          <source>Identify Aria tables that have the &lt;code&gt;&lt;a href=&quot;../create-table/index#row_format&quot;&gt;ROW_FORMAT&lt;/a&gt;&lt;/code&gt; table option set to &lt;code&gt;PAGE&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../create-table/index#row_format&quot;&gt;ROW_FORMAT&lt;/a&gt;&lt;/code&gt; 테이블 옵션이 &lt;code&gt;PAGE&lt;/code&gt; 로 설정된 Aria 테이블을 식별하십시오 .</target>
        </trans-unit>
        <trans-unit id="a52535a34b8a368f916d626b4809141477346c23" translate="yes" xml:space="preserve">
          <source>IdentifyingNumber</source>
          <target state="translated">IdentifyingNumber</target>
        </trans-unit>
        <trans-unit id="cf4eb8f80020747d140bd9e400aff23ff935b6e6" translate="yes" xml:space="preserve">
          <source>If &quot;base_cols&quot; is more than one column, WITH ROLLUP will be subtotals as well as a grand total.</source>
          <target state="translated">&quot;base_cols&quot;가 둘 이상의 열인 경우 WITH ROLLUP은 소계 및 총계입니다.</target>
        </trans-unit>
        <trans-unit id="799d946c2210adcfa671d38a49bd248d45c25c92" translate="yes" xml:space="preserve">
          <source>If &quot;redistributeData stop&quot; is called, all processing stops where it's at, but in a usable state. &quot;redistributeData status&quot; can be used to see how much has been done. A further &quot;redistributeData start&quot; will start over using the new state of the system. This may lead to a less optimal distribution, so stop-start sequences aren't recommended.</source>
          <target state="translated">&quot;redistributeData stop&quot;이 호출되면 모든 처리가 현재 위치에서 사용 가능 상태로 중지됩니다. &quot;redistributeData status&quot;를 사용하여 수행 된 작업량을 확인할 수 있습니다. 추가 &quot;redistributeData start&quot;는 시스템의 새로운 상태를 사용하여 다시 시작됩니다. 이로 인해 최적의 배포가 줄어들 수 있으므로 중지 시작 시퀀스는 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8f079ae496bafc6cdbefa4d186b4b7be83aa9088" translate="yes" xml:space="preserve">
          <source>If (CRN = FRN = RN) then the result is (value of expression from row at RN)</source>
          <target state="translated">(CRN = FRN = RN)이면 결과는 (RN에서 행의 표현식 값)입니다.</target>
        </trans-unit>
        <trans-unit id="f72ed6b741c701d92ded7087bb11fd325e41aa81" translate="yes" xml:space="preserve">
          <source>If --lock-ddl-per-table is used:</source>
          <target state="translated">--lock-ddl-per-table을 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="f55409632983989a4400bc6fef60bd4f340be976" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../flush/index&quot;&gt;FLUSH TABLE WITH READ LOCK&lt;/a&gt; is not used, then only InnoDB tables will be consistent (not the privilege tables in the mysql database or the binary log). The backup point depends on the content of the redo log within the backup itself.</source>
          <target state="translated">경우 &lt;a href=&quot;../flush/index&quot;&gt;READ LOCK과 같은 높이 테이블이&lt;/a&gt; 사용되지 만 InnoDB 테이블 일관성 (MySQL 데이터베이스 또는 바이너리 로그에없는 특권 테이블)입니다. 백업 지점은 백업 자체의 리두 로그 내용에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="394d6e0edb550bd0f5635d676e0e10843705d2e1" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../flush/index&quot;&gt;FLUSH TABLE WITH READ LOCK&lt;/a&gt; was done:</source>
          <target state="translated">만약 &lt;a href=&quot;../flush/index&quot;&gt;READ LOCK과 같은 높이의 표가&lt;/a&gt; 이루어졌다 :</target>
        </trans-unit>
        <trans-unit id="b7146338210e1def35bba0d8438d1d2ddadde8f8" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../innodb-persistent-statistics/index&quot;&gt;persistent statistics&lt;/a&gt; are enabled, then the &lt;code&gt;&lt;a href=&quot;#innodb_stats_persistent_sample_pages&quot;&gt;innodb_stats_persistent_sample_pages&lt;/a&gt;&lt;/code&gt; system variable applies instead. &lt;a href=&quot;../innodb-persistent-statistics/index&quot;&gt;persistent statistics&lt;/a&gt; are enabled with the &lt;code&gt;&lt;a href=&quot;#innodb_stats_persistent&quot;&gt;innodb_stats_persistent&lt;/a&gt;&lt;/code&gt; system variable.</source>
          <target state="translated">경우 &lt;a href=&quot;../innodb-persistent-statistics/index&quot;&gt;지속적인 통계가&lt;/a&gt; 활성화되어, 다음 &lt;code&gt;&lt;a href=&quot;#innodb_stats_persistent_sample_pages&quot;&gt;innodb_stats_persistent_sample_pages&lt;/a&gt;&lt;/code&gt; 의 시스템 변수 대신 적용됩니다. &lt;a href=&quot;../innodb-persistent-statistics/index&quot;&gt;지속적 통계&lt;/a&gt; 는 &lt;code&gt;&lt;a href=&quot;#innodb_stats_persistent&quot;&gt;innodb_stats_persistent&lt;/a&gt;&lt;/code&gt; 시스템 변수 로 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="41bf031c9af7575a367bd6a1f11a28595425b07b" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../innodb-strict-mode/index&quot;&gt;InnoDB strict mode&lt;/a&gt; is &lt;strong&gt;disabled&lt;/strong&gt; and if a &lt;a href=&quot;../data-definition/index&quot;&gt;DDL&lt;/a&gt; statement is executed that touches the table, such as &lt;code&gt;&lt;a href=&quot;../create-table/index&quot;&gt;CREATE TABLE&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt;&lt;/code&gt;, then InnoDB will raise a &lt;strong&gt;warning&lt;/strong&gt; with this message.</source>
          <target state="translated">경우 &lt;a href=&quot;../innodb-strict-mode/index&quot;&gt;InnoDB의 엄격한 모드&lt;/a&gt; 입니다 &lt;strong&gt;장애인&lt;/strong&gt; 과 경우 &lt;a href=&quot;../data-definition/index&quot;&gt;의 DDL&lt;/a&gt; 문이 터치 테이블 같은 것을 실행 &lt;code&gt;&lt;a href=&quot;../create-table/index&quot;&gt;CREATE TABLE&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt;&lt;/code&gt; 을 다음 InnoDB는 인상됩니다 &lt;strong&gt;경고&lt;/strong&gt; 메시지와 함께합니다.</target>
        </trans-unit>
        <trans-unit id="b2ae5c38d6447fca63319d4ee9cbd4ca4455a32d" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../innodb-strict-mode/index&quot;&gt;InnoDB strict mode&lt;/a&gt; is &lt;strong&gt;enabled&lt;/strong&gt; and if a &lt;a href=&quot;../data-definition/index&quot;&gt;DDL&lt;/a&gt; statement is executed that touches the table, such as &lt;code&gt;&lt;a href=&quot;../create-table/index&quot;&gt;CREATE TABLE&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt;&lt;/code&gt;, then InnoDB will raise an &lt;strong&gt;error&lt;/strong&gt; with this message</source>
          <target state="translated">경우 &lt;a href=&quot;../innodb-strict-mode/index&quot;&gt;InnoDB에 엄격 모드가&lt;/a&gt; 되어 &lt;strong&gt;사용할 수&lt;/strong&gt; 경우 &lt;a href=&quot;../data-definition/index&quot;&gt;DDL의&lt;/a&gt; 문은 터치 테이블 등이 같은 것을 실행 &lt;code&gt;&lt;a href=&quot;../create-table/index&quot;&gt;CREATE TABLE&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt;&lt;/code&gt; 을 다음 이노은 올릴 &lt;strong&gt;오류&lt;/strong&gt; 메시지와 함께</target>
        </trans-unit>
        <trans-unit id="b6df426b047f5c530285e08d8e87b35b48ec1d0c" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../innodb-strict-mode/index&quot;&gt;InnoDB strict mode&lt;/a&gt; is disabled, and if DDL is performed on a table that triggers a &lt;a href=&quot;../troubleshooting-row-size-too-large-errors-with-innodb/index&quot;&gt;&quot;Row size too large&quot; error&lt;/a&gt;, then InnoDB will log a warning:</source>
          <target state="translated">경우 &lt;a href=&quot;../innodb-strict-mode/index&quot;&gt;InnoDB에 엄격 모드가&lt;/a&gt; 비활성화되고 DDL은 트리거가있는 테이블에서 수행되는 경우 &lt;a href=&quot;../troubleshooting-row-size-too-large-errors-with-innodb/index&quot;&gt;&quot;행 크기가 너무 큰&quot;오류가&lt;/a&gt; , InnoDB에 경고를 기록합니다 :</target>
        </trans-unit>
        <trans-unit id="6c68387bb6acb189578be0ee994b34c1caf1ae04" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../innodb-system-variables/index#innodb_fast_shutdown&quot;&gt;innodb_fast_shutdown&lt;/a&gt; is set to &lt;code&gt;2&lt;/code&gt;, then set it to &lt;code&gt;1&lt;/code&gt;:</source>
          <target state="translated">경우 &lt;a href=&quot;../innodb-system-variables/index#innodb_fast_shutdown&quot;&gt;innodb_fast_shutdown가&lt;/a&gt; 설정되어 &lt;code&gt;2&lt;/code&gt; , 다음으로 설정 &lt;code&gt;1&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="aacbfc4106328710eb7766f47f14d817e4d023cc" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../parallel-replication/index&quot;&gt;parallel replication&lt;/a&gt; is in use, then events that were logged with GTIDs with different &lt;code&gt;&lt;a href=&quot;index#gtid_domain_id&quot;&gt;gtid_domain_id&lt;/a&gt;&lt;/code&gt; values can be applied in parallel in an &lt;a href=&quot;../parallel-replication/index#out-of-order-parallel-replication&quot;&gt;out-of-order&lt;/a&gt; manner.</source>
          <target state="translated">경우 &lt;a href=&quot;../parallel-replication/index&quot;&gt;병렬 복제가&lt;/a&gt; 사용되고, 다른 GTIDs와 함께 기록 된 후 일정 &lt;code&gt;&lt;a href=&quot;index#gtid_domain_id&quot;&gt;gtid_domain_id&lt;/a&gt;&lt;/code&gt; 의 값은 병렬로 적용 할 수있는 &lt;a href=&quot;../parallel-replication/index#out-of-order-parallel-replication&quot;&gt;비 순차적&lt;/a&gt; 방식.</target>
        </trans-unit>
        <trans-unit id="43d469866fc588d4431e8e6d52c991be027df2a3" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../semisynchronous-replication/index&quot;&gt;semisynchronous replication&lt;/a&gt; is enabled, then the master also has an ACK receiver thread.</source>
          <target state="translated">반 &lt;a href=&quot;../semisynchronous-replication/index&quot;&gt;동기식 복제&lt;/a&gt; 가 활성화 된 경우 마스터에도 ACK 수신기 스레드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="437ae2438ad7c46ead2b6bf7f7ca8d8b741458c0" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../sql-mode/index#strict-mode&quot;&gt;strict_mode&lt;/a&gt; has been set (the default from &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1024-release-notes/&quot;&gt;MariaDB 10.2.4&lt;/a&gt;), MariaDB will return an error.</source>
          <target state="translated">경우 &lt;a href=&quot;../sql-mode/index#strict-mode&quot;&gt;strict_mode이&lt;/a&gt; (에서 기본 설정되어 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1024-release-notes/&quot;&gt;MariaDB 10.2.4&lt;/a&gt; ), MariaDB는 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a232980e1f4225ded0ca291938871385c4789bda" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../sql-mode/index#strict-mode&quot;&gt;strict_mode&lt;/a&gt; has not been set (the default until &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1023-release-notes/&quot;&gt;MariaDB 10.2.3&lt;/a&gt;), MariaDB will adjust the number to fit in the field, returning a warning.</source>
          <target state="translated">경우 &lt;a href=&quot;../sql-mode/index#strict-mode&quot;&gt;strict_mode이&lt;/a&gt; 세트 (때까지 디폴트되지 않았습니다 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1023-release-notes/&quot;&gt;MariaDB 10.2.3&lt;/a&gt; ), MariaDB는 경고를 반환 필드에 맞게 수를 조정합니다.</target>
        </trans-unit>
        <trans-unit id="46238527ce123b8a807e8b2b9bf64edd47ea252b" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../thread-pool-system-and-status-variables/index#extra_port&quot;&gt;extra-port&lt;/a&gt; is &amp;lt;&amp;gt; 0 then you can connect max_connections number of normal threads + 1 extra SUPER user through the 'extra-port' TCP/IP port. These connections use the old one-thread-per-connection method.</source>
          <target state="translated">경우 &lt;a href=&quot;../thread-pool-system-and-status-variables/index#extra_port&quot;&gt;추가 포트는&lt;/a&gt; &amp;lt;&amp;gt; 0 다음은 '추가 포트'를 통해 일반 스레드 + 1 추가 SUPER 사용자의 MAX_CONNECTIONS 번호를 연결할 수있는 TCP / IP 포트입니다. 이러한 연결은 기존의 연결 당 하나의 스레드 당 방법을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="516836c1d5afe60fafcf357c601052be2e8aa360" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../user-statistics/index&quot;&gt;user statistics&lt;/a&gt; are enabled, the &lt;a href=&quot;../information-schema/index&quot;&gt;Information Schema&lt;/a&gt;&lt;a href=&quot;../information-schema-index_statistics-table/index&quot;&gt;INDEX_STATISTICS&lt;/a&gt; table stores the index usage.</source>
          <target state="translated">경우 &lt;a href=&quot;../user-statistics/index&quot;&gt;사용자 통계&lt;/a&gt; 활성화의 &lt;a href=&quot;../information-schema/index&quot;&gt;정보 스키마 &lt;/a&gt;&lt;a href=&quot;../information-schema-index_statistics-table/index&quot;&gt;INDEX_STATISTICS의&lt;/a&gt; 테이블은 인덱스 사용을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="6c00e38e8b7fbe94b1e55e456278199412b1102e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--debug-sync-timeout=0&lt;/code&gt; the value of the variable reads as &lt;code&gt;&quot;OFF&quot;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;--debug-sync-timeout=0&lt;/code&gt; , 변수의 값으로서 판독하고 &lt;code&gt;&quot;OFF&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f6b2eafe0b0074e28aa10747c666e570b3e65647" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--lock-ddl-per-table&lt;/code&gt; is used and there is a user query waiting for MDL, the user query will be killed to resolve a deadlock. Note that these are only queries of type ALTER, DROP, TRUNCATE or RENAME TABLE. (&lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-15636&quot;&gt;MDEV-15636&lt;/a&gt;)</source>
          <target state="translated">경우 &lt;code&gt;--lock-ddl-per-table&lt;/code&gt; 사용하고 MDL을 기다리는 사용자 쿼리가, 사용자 쿼리는 교착 상태를 해결하기 위해 살해됩니다. 이들은 ALTER, DROP, TRUNCATE 또는 RENAME TABLE 유형의 쿼리 일뿐입니다. ( &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-15636&quot;&gt;MDEV-15636&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="3f1238ef918857368023df443728fb9d8a159636" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--lock-ddl-per-table&lt;/code&gt; was done:</source>
          <target state="translated">만약 &lt;code&gt;--lock-ddl-per-table&lt;/code&gt; 이루어졌다 :</target>
        </trans-unit>
        <trans-unit id="e52ccdd71972757dd60b47f51b917fbe85dc3b97" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--start&lt;/code&gt; or &lt;code&gt;--start-dirty&lt;/code&gt; option is used, wait for all servers to exit before finishing the process. Otherwise, it will terminate if one (of several) servers is restarted.</source>
          <target state="translated">경우 &lt;code&gt;--start&lt;/code&gt; 또는 &lt;code&gt;--start-dirty&lt;/code&gt; 옵션을 사용하여 프로세스를 완료하기 전에 종료 모든 서버에 대한 대기. 그렇지 않으면 하나의 서버가 다시 시작되면 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="dc31e17b56b343eeb8d8016e383207070b92755a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--syslog&lt;/code&gt; and &lt;code&gt;--log-error&lt;/code&gt; are both provided, then a warning is issued and &lt;code&gt;--log-error&lt;/code&gt; takes precedence.</source>
          <target state="translated">경우 &lt;code&gt;--syslog&lt;/code&gt; 및 &lt;code&gt;--log-error&lt;/code&gt; 모두 제공되며, 다음 경고가 발행되고 &lt;code&gt;--log-error&lt;/code&gt; 우선합니다.</target>
        </trans-unit>
        <trans-unit id="5c88292a1eec8649745aa6bb4e3149c3c29047fe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#innodb_stats_traditional&quot;&gt;innodb_stats_traditional&lt;/a&gt;&lt;/code&gt; is disabled, then the number of pages to sample for statistics is calculated using a logarithmic algorithm, so the exact number can change depending on the size of the table. This means that more samples may be used for larger tables.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#innodb_stats_traditional&quot;&gt;innodb_stats_traditional&lt;/a&gt;&lt;/code&gt; 이 비활성화 된 경우 통계를 위해 샘플링 할 페이지 수는 로그 알고리즘을 사용하여 계산되므로 정확한 수는 테이블 크기에 따라 변경 될 수 있습니다. 이는 더 큰 테이블에 더 많은 샘플이 사용될 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="74acb485db138d8f913437c2bbeb200b3c48b407" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#innodb_stats_traditional&quot;&gt;innodb_stats_traditional&lt;/a&gt;&lt;/code&gt; is enabled, then the exact number of pages configured by the system variable will be sampled for statistics.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#innodb_stats_traditional&quot;&gt;innodb_stats_traditional&lt;/a&gt;&lt;/code&gt; 이 사용 가능한 경우 시스템 변수에 의해 구성된 정확한 페이지 수가 통계를 위해 샘플링됩니다.</target>
        </trans-unit>
        <trans-unit id="32826bb4895da88e818caea43b8d2cd2bfb4234c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#innodb_stats_traditional&quot;&gt;innodb_stats_traditional&lt;/a&gt;&lt;/code&gt; is enabled, then the exact number of pages configured by this system variable will be sampled for statistics.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;#innodb_stats_traditional&quot;&gt;innodb_stats_traditional&lt;/a&gt;&lt;/code&gt; 가 활성화되어,이 시스템 변수에 의해 구성 페이지의 정확한 수는 통계 샘플링됩니다.</target>
        </trans-unit>
        <trans-unit id="b0843377599c29318c918cfbade2f060db876784" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-lock-ddl-per-table&quot;&gt;--lock-ddl-per-table&lt;/a&gt;&lt;/code&gt; is used and if a table is concurrently being dropped or renamed, then Mariabackup can fail to acquire the MDL lock.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-lock-ddl-per-table&quot;&gt;--lock-ddl-per-table&lt;/a&gt;&lt;/code&gt; 테이블이 동시에 삭제되거나 이름이 변경되는 경우 사용되며, 다음 Mariabackup은 MDL 잠금을 획득하는 데 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb935aeacdb49cc691f5f73cf8be0cd99b389b91" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-tc-heuristic-recover&quot;&gt;--tc-heuristic-recover&lt;/a&gt;&lt;/code&gt; is set to some value other than &lt;code&gt;OFF&lt;/code&gt; and if the &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt; is &lt;strong&gt;not&lt;/strong&gt; enabled, then MariaDB will ignore information about transactions in the the memory-mapped file defined by the &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-log-tc&quot;&gt;--log-tc&lt;/a&gt;&lt;/code&gt; option during the recovery process. Prepared transactions that are encountered during the recovery process will either be rolled back or committed, depending on the value of &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-tc-heuristic-recover&quot;&gt;--tc-heuristic-recover&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-tc-heuristic-recover&quot;&gt;--tc-heuristic-recover&lt;/a&gt;&lt;/code&gt; 이외의 값으로 설정 &lt;code&gt;OFF&lt;/code&gt; 하고있는 경우 &lt;a href=&quot;../binary-log/index&quot;&gt;바이너리 로그가&lt;/a&gt; 되어 &lt;strong&gt;있지&lt;/strong&gt; 활성화, 다음 MariaDB는에 의해 정의 된 메모리 매핑 파일에 트랜잭션에 대한 정보 무시합니다 &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-log-tc&quot;&gt;--log-tc&lt;/a&gt;&lt;/code&gt; 동안 옵션을 복구 과정. 복구 프로세스 중 발생하는 준비된 트랜잭션은 &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-tc-heuristic-recover&quot;&gt;--tc-heuristic-recover&lt;/a&gt;&lt;/code&gt; 값에 따라 롤백되거나 커밋 됩니다.</target>
        </trans-unit>
        <trans-unit id="005062a229caa1abba5bf724920e75260adec5c7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-tc-heuristic-recover&quot;&gt;--tc-heuristic-recover&lt;/a&gt;&lt;/code&gt; is set to some value other than &lt;code&gt;OFF&lt;/code&gt; and if the &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt; is enabled, then MariaDB will ignore information about transactions in the &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt; during the recovery process. Prepared transactions that are encountered during the recovery process will either be rolled back or committed, depending on the value of &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-tc-heuristic-recover&quot;&gt;--tc-heuristic-recover&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-tc-heuristic-recover&quot;&gt;--tc-heuristic-recover&lt;/a&gt;&lt;/code&gt; 이외의 값으로 설정 &lt;code&gt;OFF&lt;/code&gt; 하고있는 경우 &lt;a href=&quot;../binary-log/index&quot;&gt;바이너리 로그가&lt;/a&gt; 활성화되어, 다음 MariaDB는의 트랜잭션에 대한 정보 무시 &lt;a href=&quot;../binary-log/index&quot;&gt;바이너리 로그&lt;/a&gt; 복구 과정을. 복구 프로세스 중 발생하는 준비된 트랜잭션은 &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-tc-heuristic-recover&quot;&gt;--tc-heuristic-recover&lt;/a&gt;&lt;/code&gt; 값에 따라 롤백되거나 커밋 됩니다.</target>
        </trans-unit>
        <trans-unit id="b1151ec02d5ad91a2fbb9a110537b84729d818fc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#sync_binlog&quot;&gt;sync_binlog=1&lt;/a&gt;&lt;/code&gt; is set, but &lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_flush_log_at_trx_commit&quot;&gt;innodb_flush_log_at_trx_commit&lt;/a&gt;&lt;/code&gt; is not set to &lt;code&gt;1&lt;/code&gt; or &lt;code&gt;3&lt;/code&gt;, then it is possible after a crash to end up in a state where a transaction present in a server's &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt; is missing from the server's &lt;a href=&quot;../xtradbinnodb-redo-log/index&quot;&gt;InnoDB redo log&lt;/a&gt;. If the server is a &lt;a href=&quot;../high-availability-performance-tuning-mariadb-replication/index&quot;&gt;replication master&lt;/a&gt;, then that means that the server can become inconsistent with its slaves, since the slaves may have replicated transactions from the master's &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt; that are no longer present in the master's local &lt;a href=&quot;../innodb/index&quot;&gt;InnoDB&lt;/a&gt; data.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#sync_binlog&quot;&gt;sync_binlog=1&lt;/a&gt;&lt;/code&gt; 설정되어 있지만 &lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_flush_log_at_trx_commit&quot;&gt;innodb_flush_log_at_trx_commit&lt;/a&gt;&lt;/code&gt; 설정되어 있지 않습니다 &lt;code&gt;1&lt;/code&gt; 또는 &lt;code&gt;3&lt;/code&gt; 충돌이 서버의에서 트랜잭션 존재하는 상태에서 종료 한 후, 다음이 가능합니다 &lt;a href=&quot;../binary-log/index&quot;&gt;바이너리 로그는&lt;/a&gt; 서버의 누락 된 &lt;a href=&quot;../xtradbinnodb-redo-log/index&quot;&gt;이노 리두 로그&lt;/a&gt; . 서버가 &lt;a href=&quot;../high-availability-performance-tuning-mariadb-replication/index&quot;&gt;복제 마스터&lt;/a&gt; 인 경우 슬레이브가 마스터의 로컬 &lt;a href=&quot;../innodb/index&quot;&gt;InnoDB&lt;/a&gt; 데이터 에 더 이상 존재하지 않는 마스터의 &lt;a href=&quot;../binary-log/index&quot;&gt;이진 로그&lt;/a&gt; 에서 트랜잭션을 복제했을 수 있기 때문에 서버가 슬레이브와 일치하지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6d409b95c85b3d7e701aabed7fcd861c82eaeae1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#log_warnings&quot;&gt;log_warnings&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;, then many optional warnings will not be logged. However, this does not prevent all warnings from being logged, because there are certain core warnings that will always be written to the error log. For example:</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#log_warnings&quot;&gt;log_warnings&lt;/a&gt;&lt;/code&gt; 가 있다 &lt;code&gt;0&lt;/code&gt; , 다음 많은 옵션 경고가 기록되지 않습니다. 그러나 항상 오류 로그에 기록되는 특정 핵심 경고가 있기 때문에 모든 경고가 기록되는 것을 막지는 못합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a74f295f9e00f0986ce81e8db7b39d6fb8944af8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#log_warnings&quot;&gt;log_warnings&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt;, then many types of warnings are logged. Some useful warnings are:</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#log_warnings&quot;&gt;log_warnings&lt;/a&gt;&lt;/code&gt; 가 있다 &lt;code&gt;1&lt;/code&gt; , 다음 경고의 많은 종류가 기록됩니다. 유용한 경고는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="567e81dd70848630745ba70356acd881ef322432" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#log_warnings&quot;&gt;log_warnings&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;2&lt;/code&gt;, then a couple other different kinds of warnings are printed. For example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../server-system-variables/index#log_warnings&quot;&gt;log_warnings&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;2&lt;/code&gt; 인 경우 몇 가지 다른 종류의 경고가 인쇄됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="795a4b3e651050733b485cf2ad194df325f822a5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#log_warnings&quot;&gt;log_warnings&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;3&lt;/code&gt;, then a couple other different kinds of warnings are printed. For example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../server-system-variables/index#log_warnings&quot;&gt;log_warnings&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;3&lt;/code&gt; 인 경우 몇 가지 다른 종류의 경고가 인쇄됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="11170dbc60f721a2e4b7e9c8d89757b67c008039" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#log_warnings&quot;&gt;log_warnings&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;4&lt;/code&gt;, then a couple other different kinds of warnings are printed. For example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../server-system-variables/index#log_warnings&quot;&gt;log_warnings&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;4&lt;/code&gt; 인 경우 몇 가지 다른 종류의 경고가 인쇄됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4a2791fd43bcf4ace5d7826e9b66efc8b505d5e9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#log_warnings&quot;&gt;log_warnings&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;9&lt;/code&gt;, then some &lt;strong&gt;very&lt;/strong&gt; verbose warnings are printed. For example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../server-system-variables/index#log_warnings&quot;&gt;log_warnings&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;9&lt;/code&gt; 인 경우 &lt;strong&gt;매우&lt;/strong&gt; 자세한 경고가 인쇄됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c4524721595f060427cda3d66c0f79065ba54854" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#secure_file_priv&quot;&gt;secure_file_priv&lt;/a&gt;&lt;/code&gt; is set to the path of some directory, then CSV tables can only be created with files in that directory.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../server-system-variables/index#secure_file_priv&quot;&gt;secure_file_priv&lt;/a&gt;&lt;/code&gt; 가 일부 디렉토리의 경로로 설정된 경우 해당 디렉토리의 파일로만 CSV 테이블을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0da2956d8f5807ce80ad46591f50ec20fc5ce9c5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../sql-mode/index&quot;&gt;SQL_MODE&lt;/a&gt;&lt;/code&gt; does not have &lt;code&gt;NO_AUTO_CREATE_USER&lt;/code&gt; set, then you can also create the user account via &lt;code&gt;&lt;a href=&quot;../grant/index&quot;&gt;GRANT&lt;/a&gt;&lt;/code&gt;. For example:</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;../sql-mode/index&quot;&gt;SQL_MODE&lt;/a&gt;&lt;/code&gt; 이 없는 &lt;code&gt;NO_AUTO_CREATE_USER&lt;/code&gt; 의 세트를, 당신은 또한을 통해 사용자 계정을 만들 수 있습니다 &lt;code&gt;&lt;a href=&quot;../grant/index&quot;&gt;GRANT&lt;/a&gt;&lt;/code&gt; 를 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6d68e45e65e21cb2b67b2f263b40bbe6fd7d6d15" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../sql-mode/index&quot;&gt;SQL_MODE&lt;/a&gt;&lt;/code&gt; does not have &lt;code&gt;NO_AUTO_CREATE_USER&lt;/code&gt; set, then you can also create the user this way with &lt;code&gt;&lt;a href=&quot;../grant/index&quot;&gt;GRANT&lt;/a&gt;&lt;/code&gt;. For example:</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;../sql-mode/index&quot;&gt;SQL_MODE&lt;/a&gt;&lt;/code&gt; 이 없는 &lt;code&gt;NO_AUTO_CREATE_USER&lt;/code&gt; 의 세트를, 당신은 또한 사용자에게이 방법으로 만들 수 있습니다 &lt;code&gt;&lt;a href=&quot;../grant/index&quot;&gt;GRANT&lt;/a&gt;&lt;/code&gt; 를 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="01c21716ef5ac8a0ebed26b3acfbc25844b9b9f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../sql-mode/index&quot;&gt;SQL_MODE&lt;/a&gt;&lt;/code&gt; does not have &lt;code&gt;NO_AUTO_CREATE_USER&lt;/code&gt; set, then you can also create the user via &lt;code&gt;&lt;a href=&quot;../grant/index&quot;&gt;GRANT&lt;/a&gt;&lt;/code&gt;. For example:</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;../sql-mode/index&quot;&gt;SQL_MODE&lt;/a&gt;&lt;/code&gt; 이 없는 &lt;code&gt;NO_AUTO_CREATE_USER&lt;/code&gt; 의 세트를, 당신은 또한을 통해 사용자 생성 할 수 있습니다 &lt;code&gt;&lt;a href=&quot;../grant/index&quot;&gt;GRANT&lt;/a&gt;&lt;/code&gt; 를 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4d2866a1d048b9d73edb1dea6040e6207fb3cbc3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_flush_log_at_trx_commit&quot;&gt;innodb_flush_log_at_trx_commit&lt;/a&gt;&lt;/code&gt; is set to &lt;code&gt;1&lt;/code&gt; or &lt;code&gt;3&lt;/code&gt;, but &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#sync_binlog&quot;&gt;sync_binlog=1&lt;/a&gt;&lt;/code&gt; is not set, then it is possible after a crash to end up in a state where a transaction present in a server's &lt;a href=&quot;../xtradbinnodb-redo-log/index&quot;&gt;InnoDB redo log&lt;/a&gt; is missing from the server's &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt;. If the server is a &lt;a href=&quot;../high-availability-performance-tuning-mariadb-replication/index&quot;&gt;replication master&lt;/a&gt;, then that also means that the server can become inconsistent with its slaves, since the server's slaves would not be able to replicate the missing transactions from the server's &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_flush_log_at_trx_commit&quot;&gt;innodb_flush_log_at_trx_commit&lt;/a&gt;&lt;/code&gt; 설정되어 &lt;code&gt;1&lt;/code&gt; 또는 &lt;code&gt;3&lt;/code&gt; 만 &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#sync_binlog&quot;&gt;sync_binlog=1&lt;/a&gt;&lt;/code&gt; 충돌이 서버의에서 트랜잭션 존재하는 상태에서 종료 후에 가능하며, 설정되지 않은 &lt;a href=&quot;../xtradbinnodb-redo-log/index&quot;&gt;이노 리두 로그는&lt;/a&gt; 서버의 누락 된 &lt;a href=&quot;../binary-log/index&quot;&gt;바이너리 로그&lt;/a&gt; . 서버가 &lt;a href=&quot;../high-availability-performance-tuning-mariadb-replication/index&quot;&gt;복제 마스터&lt;/a&gt; 인 경우 서버의 슬레이브가 서버의 &lt;a href=&quot;../binary-log/index&quot;&gt;이진 로그&lt;/a&gt; 에서 누락 된 트랜잭션을 복제 할 수 없으므로 서버가 슬레이브와 일치하지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9d7939af20a377548f376ca6e7c7776423090ca2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_flush_log_at_trx_commit&quot;&gt;innodb_flush_log_at_trx_commit=1&lt;/a&gt;&lt;/code&gt; is set and the &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt; is enabled, but &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#sync_binlog&quot;&gt;sync_binlog=0&lt;/a&gt;&lt;/code&gt; is set, then commits are not guaranteed durable inside InnoDB after commit. This is because if &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#sync_binlog&quot;&gt;sync_binlog=0&lt;/a&gt;&lt;/code&gt; is set and if the server crashes, then transactions that were not flushed to the binary log prior to the crash will be missing from the binary log.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_flush_log_at_trx_commit&quot;&gt;innodb_flush_log_at_trx_commit=1&lt;/a&gt;&lt;/code&gt; 설정되고 &lt;a href=&quot;../binary-log/index&quot;&gt;바이너리 로그가&lt;/a&gt; 활성화되어 있지만, &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#sync_binlog&quot;&gt;sync_binlog=0&lt;/a&gt;&lt;/code&gt; 다음, 설정 커밋은 후 커밋 InnoDB의 내부 내구성이 보장되지 않습니다. 경우 때문이다 &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#sync_binlog&quot;&gt;sync_binlog=0&lt;/a&gt;&lt;/code&gt; 설정하고 서버가 충돌하는 경우, 다음, 이전 사고에 바이너리 로그에 플러시되지 않은 트랜잭션이 바이너리 로그에서 누락됩니다.</target>
        </trans-unit>
        <trans-unit id="12f267b0dec9eb835e4a3cf4e1624efc033f1b66" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;@@default_master_connection&lt;/code&gt; contains a non existing name, you will get a warning.</source>
          <target state="translated">경우 &lt;code&gt;@@default_master_connection&lt;/code&gt; 아닌 기존 이름을 포함, 당신은 경고를 받게됩니다.</target>
        </trans-unit>
        <trans-unit id="63d7c38aa663b8e98d6ab4fec7928ae4a03b6de5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;AES_DECRYPT()&lt;/code&gt; detects invalid data or incorrect padding, it returns &lt;code&gt;NULL&lt;/code&gt;. However, it is possible for &lt;code&gt;AES_DECRYPT()&lt;/code&gt; to return a non-&lt;code&gt;NULL&lt;/code&gt; value (possibly garbage) if the input data or the key is invalid.</source>
          <target state="translated">경우 &lt;code&gt;AES_DECRYPT()&lt;/code&gt; 유효하지 않은 데이터 또는 잘못된 패딩을 감지, 그것은 반환 &lt;code&gt;NULL&lt;/code&gt; 을 . 그러나 입력 데이터 또는 키가 유효하지 않은 경우 &lt;code&gt;AES_DECRYPT()&lt;/code&gt; 가 &lt;code&gt;NULL&lt;/code&gt; 이 아닌 값 (가비지) 을 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17f6716ac4c5cf36759c3792aa0dd28e562a0c9f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ALGORITHM=COPY&lt;/code&gt; is specified, then the copy algorithm will be used even if it is not necessary. This can result in a lengthy table copy. If multiple &lt;code&gt;&lt;a href=&quot;index&quot;&gt;ALTER TABLE&lt;/a&gt;&lt;/code&gt; operations are required that each require the table to be rebuilt, then it is best to specify all operations in a single &lt;code&gt;&lt;a href=&quot;index&quot;&gt;ALTER TABLE&lt;/a&gt;&lt;/code&gt; statement, so that the table is only rebuilt once.</source>
          <target state="translated">경우 &lt;code&gt;ALGORITHM=COPY&lt;/code&gt; 를 지정하면 복사 알고리즘은 필요없는 경우에도 사용됩니다. 테이블 길이가 길어질 수 있습니다. 각각의 테이블을 재 빌드해야하는 복수의 &lt;code&gt;&lt;a href=&quot;index&quot;&gt;ALTER TABLE&lt;/a&gt;&lt;/code&gt; 조작이 필요한 경우, 테이블을 한 번만 재 빌드 할 수 있도록 단일 &lt;code&gt;&lt;a href=&quot;index&quot;&gt;ALTER TABLE&lt;/a&gt;&lt;/code&gt; 문 에서 모든 조작을 지정하는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="2c5bd7154ce455897e3b767cef8f02ce9af48032" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ALGORITHM=INSTANT&lt;/code&gt; is specified for an &lt;code&gt;ALTER TABLE&lt;/code&gt; operation that does not support &lt;code&gt;ALGORITHM=INSTANT&lt;/code&gt;, then an error will be raised. In this case, raising an error is preferable, if the alternative is for the operation to modify data files, and perform unexpectedly slowly.</source>
          <target state="translated">경우 &lt;code&gt;ALGORITHM=INSTANT&lt;/code&gt; 이 에 지정된 &lt;code&gt;ALTER TABLE&lt;/code&gt; 지원하지 않는 운영 &lt;code&gt;ALGORITHM=INSTANT&lt;/code&gt; 를 , 다음 오류가 발생합니다. 이 경우 대체 작업이 데이터 파일을 수정하고 예기치 않게 느리게 수행하는 경우 오류를 발생시키는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c66b1195abffc52e2ba231d2fa751a820f5d36c6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ALGORITHM=NOCOPY&lt;/code&gt; is specified for an &lt;code&gt;ALTER TABLE&lt;/code&gt; operation that does not support &lt;code&gt;ALGORITHM=NOCOPY&lt;/code&gt;, then an error will be raised. In this case, raising an error is preferable, if the alternative is for the operation to rebuild the clustered index, and perform unexpectedly slowly.</source>
          <target state="translated">경우 &lt;code&gt;ALGORITHM=NOCOPY&lt;/code&gt; 가 에 지정된 &lt;code&gt;ALTER TABLE&lt;/code&gt; 지원하지 않는 운영 &lt;code&gt;ALGORITHM=NOCOPY&lt;/code&gt; 를 , 다음 오류가 발생합니다. 이 경우 작업이 클러스터형 인덱스를 다시 작성하고 예기치 않게 느리게 수행하는 경우 오류를 발생시키는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="bf3289c6cec0dab5a87c48b8528de3e83e607a0f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;CHECK TABLE&lt;/code&gt; finds an error in an InnoDB table, MariaDB might shutdown to prevent the error propagation. In this case, the problem will be reported in the error log. Otherwise, since &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt;, the table or an index might be marked as corrupted, to prevent use. This does not happen with some minor problems, like a wrong number of entries in a secondary index. Those problems are reported in the output of &lt;code&gt;CHECK TABLE&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;CHECK TABLE&lt;/code&gt; InnoDB의 테이블에서 오류를 발견, MariaDB의 힘 종료 오류 전파를 방지합니다. 이 경우 문제가 오류 로그에보고됩니다. 그렇지 않으면 &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt; 부터 테이블 또는 인덱스가 손상된 것으로 표시되어 사용되지 않을 수 있습니다. 보조 인덱스의 잘못된 수의 항목과 같은 사소한 문제에서는 발생하지 않습니다. 이러한 문제점은 &lt;code&gt;CHECK TABLE&lt;/code&gt; 출력에보고됩니다 .</target>
        </trans-unit>
        <trans-unit id="82540f2e001eb115b02779c851ffbf10b2edd1b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;CYCLE&lt;/code&gt; is used then the sequence should start again from &lt;code&gt;MINVALUE&lt;/code&gt; after it has run out of values. Default value is &lt;code&gt;NOCYCLE&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CYCLE&lt;/code&gt; 이 사용 되면 값이 부족한 후 &lt;code&gt;MINVALUE&lt;/code&gt; 부터 시퀀스가 ​​다시 시작되어야 합니다. 기본값은 &lt;code&gt;NOCYCLE&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="89d03fd3cefdc64571e2f73c9cf2de2a1189b13f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;CYCLE&lt;/code&gt; is used, first &lt;code&gt;round&lt;/code&gt; and then &lt;code&gt;next_value&lt;/code&gt; are compared to see if the value is bigger than the current value.</source>
          <target state="translated">경우 &lt;code&gt;CYCLE&lt;/code&gt; 가 사용되고, 첫 번째 &lt;code&gt;round&lt;/code&gt; 다음과 &lt;code&gt;next_value&lt;/code&gt; 값을 현재 값보다 더 있는지 비교한다.</target>
        </trans-unit>
        <trans-unit id="b2b574d490f4e9874bef219397ef7e2d762accb6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;EXISTS&lt;/code&gt; subquery is an AND-part of the &lt;code&gt;WHERE&lt;/code&gt; clause:</source>
          <target state="translated">경우 &lt;code&gt;EXISTS&lt;/code&gt; 서브 쿼리의 AND-부분이다 &lt;code&gt;WHERE&lt;/code&gt; 절 :</target>
        </trans-unit>
        <trans-unit id="7d0b10f994df9a2380ee81b4bbf058140ddcce55" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FLUSH TABLES ... FOR EXPORT&lt;/code&gt; is in effect in the session, the following statements will produce an error if attempted:</source>
          <target state="translated">경우 &lt;code&gt;FLUSH TABLES ... FOR EXPORT&lt;/code&gt; 세션에 적용되는 시도하는 경우, 다음 문은 오류가 발생합니다 :</target>
        </trans-unit>
        <trans-unit id="7d3b46cc4cdc9e6216c60e8b91426c0cf47919d5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MyRocks&lt;/code&gt; is used, create rocksdb checkpoint via &quot;set rocksdb_create_checkpoint=$rocksdb_data_dir/mariabackup_rocksdb_checkpoint &quot; command. The result of it is a directory with hardlinks to MyRocks files. Copy the checkpoint directory to the backup (or create hardlinks in backup directory is on the same partition as data directory). Remove the checkpoint directory.</source>
          <target state="translated">&lt;code&gt;MyRocks&lt;/code&gt; 를 사용하는 경우 &quot;set rocksdb_create_checkpoint = $ rocksdb_data_dir / mariabackup_rocksdb_checkpoint&quot;명령을 통해 rocksdb 검사 점을 작성하십시오. 그 결과 MyRocks 파일에 대한 하드 링크가있는 디렉토리가됩니다. 체크 포인트 디렉토리를 백업에 복사하십시오 (또는 백업 디렉토리에 데이터 링크와 동일한 파티션에있는 하드 링크 작성). 검사 점 디렉토리를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="db7758434a2f7a72062c7a7d7fef6118d32de200" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;N_or_S&lt;/code&gt; is a number, returns a string representation of the hexadecimal value of &lt;code&gt;N&lt;/code&gt;, where &lt;code&gt;N&lt;/code&gt; is a &lt;code&gt;longlong&lt;/code&gt; (&lt;code&gt;&lt;a href=&quot;../bigint/index&quot;&gt;BIGINT&lt;/a&gt;&lt;/code&gt;) number. This is equivalent to &lt;code&gt;&lt;a href=&quot;../conv/index&quot;&gt;CONV&lt;/a&gt;(N,10,16)&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;N_or_S&lt;/code&gt; 이 숫자는, 16 진수 값의 스트링 표현 반환 &lt;code&gt;N&lt;/code&gt; , &lt;code&gt;N&lt;/code&gt; 은 A는 &lt;code&gt;longlong&lt;/code&gt; ( &lt;code&gt;&lt;a href=&quot;../bigint/index&quot;&gt;BIGINT&lt;/a&gt;&lt;/code&gt; ) 참조. 이것은 &lt;code&gt;&lt;a href=&quot;../conv/index&quot;&gt;CONV&lt;/a&gt;(N,10,16)&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="f2ba38b5176baaa6cc861e770c221b61e8d5852f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;N_or_S&lt;/code&gt; is a string, returns a hexadecimal string representation of &lt;code&gt;N_or_S&lt;/code&gt; where each byte of each character in &lt;code&gt;N_or_S&lt;/code&gt; is converted to two hexadecimal digits. If &lt;code&gt;N_or_S&lt;/code&gt; is NULL, returns NULL. The inverse of this operation is performed by the &lt;a href=&quot;../unhex/index&quot;&gt;UNHEX&lt;/a&gt;() function.</source>
          <target state="translated">경우 &lt;code&gt;N_or_S&lt;/code&gt; 이 문자열 인의 16 진수 문자열 표현을 반환 &lt;code&gt;N_or_S&lt;/code&gt; 의 각 문자의 각 바이트 &lt;code&gt;N_or_S&lt;/code&gt; 는 두 개의 16 진수로 변환됩니다. 경우 &lt;code&gt;N_or_S&lt;/code&gt; 는 NULL, 반환 NULL입니다. 이 작업의 역은 &lt;a href=&quot;../unhex/index&quot;&gt;UNHEX&lt;/a&gt; () 함수에 의해 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="7c423accf5db70a2845a66577bd36974d4b97a5d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;QUERY&lt;/code&gt; event logging is enabled, queries that are executed will be logged for defined users. The queries will be logged exactly as they are executed, in plain text. This is a security vulnerability: anyone who has access to the log files will be able to read the queries. So make sure that only trusted users have access to the log files and that the files are in a protected location. An alternative is not to use &lt;code&gt;QUERY&lt;/code&gt; event logging, but to use only &lt;code&gt;TABLE&lt;/code&gt; event logging.</source>
          <target state="translated">&lt;code&gt;QUERY&lt;/code&gt; 이벤트 로깅이 사용 가능한 경우 실행 된 쿼리가 정의 된 사용자에 대해 로깅됩니다. 쿼리는 실행되는 그대로 일반 텍스트로 기록됩니다. 이것은 보안 취약점입니다. 로그 파일에 액세스 할 수있는 사람은 누구나 쿼리를 읽을 수 있습니다. 따라서 신뢰할 수있는 사용자 만 로그 파일에 액세스 할 수 있고 파일이 보호 된 위치에 있는지 확인하십시오. 대안은 &lt;code&gt;QUERY&lt;/code&gt; 이벤트 로깅 을 사용하지 않고 &lt;code&gt;TABLE&lt;/code&gt; 이벤트 로깅 만 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="8a2ff1981b4769a0256e201ed0691b8090c2f936" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;RESTART&lt;/code&gt; option is used, &lt;code&gt;NEXT VALUE&lt;/code&gt; will return the restart value.</source>
          <target state="translated">경우 &lt;code&gt;RESTART&lt;/code&gt; 의 옵션을 사용, &lt;code&gt;NEXT VALUE&lt;/code&gt; 는 다시 시작 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cbaf4068d15009e7d4b1ccf0bf9df0e0900c6e3b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SHOW GRANTS FOR CURRENT_USER&lt;/code&gt; (or any of the equivalent syntaxes) is used in &lt;code&gt;DEFINER&lt;/code&gt; context (such as within a stored procedure that is defined with &lt;code&gt;SQL SECURITY DEFINER&lt;/code&gt;), the grants displayed are those of the definer and not the invoker.</source>
          <target state="translated">경우 &lt;code&gt;SHOW GRANTS FOR CURRENT_USER&lt;/code&gt; (또는 등가의 구문 중)에서 사용된다 &lt;code&gt;DEFINER&lt;/code&gt; 의 (예로 정의되는 프로 시저 내에 같은 맥락 &lt;code&gt;SQL SECURITY DEFINER&lt;/code&gt; ), 표시 허가는 디파 아닌 호출자의 것들이다.</target>
        </trans-unit>
        <trans-unit id="aa25c397c3e720ac82dd55f65b65f4161f4fd403" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SIGNED&lt;/code&gt;, or no attribute, is specified, a portion of the numeric type will be reserved for the sign (plus or minus). For example, a TINYINT SIGNED can range from -128 to 127.</source>
          <target state="translated">&lt;code&gt;SIGNED&lt;/code&gt; 또는 속성이 지정되지 않은 경우 숫자 유형의 일부가 부호 (플러스 또는 마이너스)로 예약됩니다. 예를 들어 TINYINT SIGNED의 범위는 -128에서 127 사이입니다.</target>
        </trans-unit>
        <trans-unit id="d27c5097a9de37a84c09fc2327dc5446903b9295" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;START SLAVE&lt;/code&gt; succeeds in starting the slave threads, it returns without any error. However, even in that case, it might be that the slave threads start and then later stop (for example, because they do not manage to connect to the master or read its &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt;, or some other problem). &lt;code&gt;START SLAVE&lt;/code&gt; does not warn you about this. You must check the slave's error log for error messages generated by the slave threads, or check that they are running satisfactorily with &lt;code&gt;SHOW SLAVE
STATUS&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;START SLAVE&lt;/code&gt; 가 슬레이브 쓰레드를 시작하기에 성공, 어떤 오류없이 반환합니다. 그러나이 경우에도 슬레이브 스레드가 시작된 후 나중에 중지 될 수 있습니다 (예를 들어, 마스터에 연결하거나 &lt;a href=&quot;../binary-log/index&quot;&gt;이진 로그를&lt;/a&gt; 읽 거나 다른 문제를 읽을 수 없기 때문에 ). &lt;code&gt;START SLAVE&lt;/code&gt; 는 이에 대해 경고하지 않습니다. 슬레이브 스레드에서 생성 한 오류 메시지에 대해 슬레이브의 오류 로그를 확인하거나 &lt;code&gt;SHOW SLAVE STATUS&lt;/code&gt; 만족스럽게 실행되고 있는지 확인해야 합니다.</target>
        </trans-unit>
        <trans-unit id="ccdfd05e22aae125a4003377e884ddba6b618371" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;TO #&lt;/code&gt; is given, then the first new binary log file will start from number #.</source>
          <target state="translated">경우 &lt;code&gt;TO #&lt;/code&gt; 부여 후 처음으로 새로운 바이너리 로그 파일 번호 #에서 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="1b9ad62d9e7979044d96471bef151b02b7b917df" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;TRANSACTIONAL&lt;/code&gt; was not specified at all, the row format will be whatever the user has specified (or PAGE, by default), and the table will be transactional if the row format will end up being PAGE and non-transactional otherwise.</source>
          <target state="translated">경우 &lt;code&gt;TRANSACTIONAL&lt;/code&gt; 이 전혀 지정되지 않은, 행 형식은 사용자가 (기본적으로, 또는 PAGE) 지정한 무엇이든 될 것이며, 행 형식이 다른 것을 PAGE 및 비 트랜잭션을 종료 할 경우 테이블은 트랜잭션이 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="162f8a52a84944a7183bf497b1977178ce1ab5b6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;TRANSACTIONAL=0&lt;/code&gt; was specified, the table will be not transactional and the row format will be whatever the user has specified (or PAGE, by default).</source>
          <target state="translated">경우 &lt;code&gt;TRANSACTIONAL=0&lt;/code&gt; 이 지정된 테이블이없는 트랜잭션되며 행 형식은 사용자 (기본적으로, 또는 PAGE) 지정한됩니다 뭐든간에.</target>
        </trans-unit>
        <trans-unit id="08dd1f402ee863e32d438938e55c809b90db2c74" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;TRANSACTIONAL=1&lt;/code&gt; was specified, the row format will be PAGE. If a user has specified some other row format, Aria issues a warning, but still forces the row format to be PAGE.</source>
          <target state="translated">경우 &lt;code&gt;TRANSACTIONAL=1&lt;/code&gt; 지정, 행 형식은 페이지가됩니다. 사용자가 다른 행 형식을 지정한 경우 Aria는 경고를 발행하지만 여전히 행 형식을 PAGE로 강제합니다.</target>
        </trans-unit>
        <trans-unit id="78071d6dc1f65a05f29151739369ce60db6ddc8a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;TRUE&lt;/code&gt;, the temporary table resides in a separate per-table tablespace. If &lt;code&gt;FALSE&lt;/code&gt;, it resides in the shared temporary tablespace.</source>
          <target state="translated">만약 &lt;code&gt;TRUE&lt;/code&gt; , 별도의 테이블 당 테이블 스페이스의 임시 테이블이 상주. &lt;code&gt;FALSE&lt;/code&gt; 인 경우 공유 임시 테이블 스페이스에 상주합니다.</target>
        </trans-unit>
        <trans-unit id="cf8653d24287cc321f7ac03d4b59fe5f0c7b7679" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;TRX_STATE&lt;/code&gt; is &lt;code&gt;LOCK_WAIT&lt;/code&gt;, the &lt;code&gt;&lt;a href=&quot;../information-schema-innodb_locks-table/index&quot;&gt;INNODB_LOCKS.LOCK_ID&lt;/a&gt;&lt;/code&gt; value of the lock being waited on. &lt;code&gt;NULL&lt;/code&gt; if any other state.</source>
          <target state="translated">&lt;code&gt;TRX_STATE&lt;/code&gt; 가 &lt;code&gt;LOCK_WAIT&lt;/code&gt; 인 경우 대기중인 잠금 의 &lt;code&gt;&lt;a href=&quot;../information-schema-innodb_locks-table/index&quot;&gt;INNODB_LOCKS.LOCK_ID&lt;/a&gt;&lt;/code&gt; 값입니다. 다른 상태이면 &lt;code&gt;NULL&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0b5b7da5d0ce649de080b64a28fc02d11f1683e6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;TRX_STATE&lt;/code&gt; is &lt;code&gt;LOCK_WAIT&lt;/code&gt;, the time the transaction started waiting for the lock, otherwise &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;TRX_STATE&lt;/code&gt; 가 있다 &lt;code&gt;LOCK_WAIT&lt;/code&gt; , 트랜잭션이 락을 대기 시작 시간, 그렇지 않으면 &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="89d1059264f7712ad76a61ce1189e949e4533a25" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;UNSIGNED&lt;/code&gt; is specified, no portion of the numeric type is reserved for the sign, so for integer types range can be larger. For example, a TINYINT UNSIGNED can range from 0 to 255. Floating point and fixed-point types also can be &lt;code&gt;UNSIGNED&lt;/code&gt;, but this only prevents negative values from being stored and doesn't alter the range.</source>
          <target state="translated">경우 &lt;code&gt;UNSIGNED&lt;/code&gt; 가 지정되면, 숫자 형태의 어떤 부분이 정수 타입 클 수 범위 정도, 부호 예약되지 않는다. 예를 들어 TINYINT UNSIGNED의 범위는 0-255입니다. 부동 소수점 및 고정 소수점 유형도 &lt;code&gt;UNSIGNED&lt;/code&gt; 일 수 있지만 음수 값만 저장되지 않고 범위를 변경하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="12beee1671cd8098ccaec5502ad6ff3a73319605" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;USING&lt;/code&gt; is given and the result string is illegal for the given character set, a warning is issued. Also, if strict &lt;a href=&quot;../sql_mode/index&quot;&gt;SQL mode&lt;/a&gt; is enabled, the result from &lt;code&gt;CHAR()&lt;/code&gt; becomes &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;USING&lt;/code&gt; 주어지고 결과 문자열은 지정된 문자 세트에 대한 불법입니다 경고가 발생합니다. 또한 엄격한 &lt;a href=&quot;../sql_mode/index&quot;&gt;SQL 모드&lt;/a&gt; 가 사용 가능한 경우 &lt;code&gt;CHAR()&lt;/code&gt; 의 결과 는 &lt;code&gt;NULL&lt;/code&gt; 이 됩니다 .</target>
        </trans-unit>
        <trans-unit id="56961e160a546d0f26ba963d877a5ed93d920529" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;X&lt;/code&gt; is &lt;code&gt;NULL&lt;/code&gt;, this function returns &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;X&lt;/code&gt; 가 있다 &lt;code&gt;NULL&lt;/code&gt; 이 ,이 함수는 반환 &lt;code&gt;NULL&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="34f504ad70cb400b4915145c3b0b3c089b411d66" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ZEROFILL&lt;/code&gt; is specified, the column will be set to UNSIGNED and the spaces used by default to pad the field are replaced with zeros. &lt;code&gt;ZEROFILL&lt;/code&gt; is ignored in expressions or as part of a &lt;a href=&quot;../union/index&quot;&gt;UNION&lt;/a&gt;. &lt;code&gt;ZEROFILL&lt;/code&gt; is a non-standard MySQL and MariaDB enhancement.</source>
          <target state="translated">경우 &lt;code&gt;ZEROFILL&lt;/code&gt; 가 지정되는 칼럼 UNSIGNED로 설정되고 패드 기본 필드에서 사용하는 공간은 제로로 대체된다. &lt;code&gt;ZEROFILL&lt;/code&gt; 은 표현식에서 또는 &lt;a href=&quot;../union/index&quot;&gt;UNION의&lt;/a&gt; 일부로 무시됩니다 . &lt;code&gt;ZEROFILL&lt;/code&gt; 은 비표준 MySQL 및 MariaDB 향상입니다.</target>
        </trans-unit>
        <trans-unit id="1f14ac446e04b477ee0cfaf4e78032656b7d3c0f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;autocommit&lt;/code&gt; is set to 1, the &lt;a href=&quot;../lock-in-share-mode/index&quot;&gt;LOCK IN SHARE MODE&lt;/a&gt; and &lt;code&gt;FOR UPDATE&lt;/code&gt; clauses have no effect.</source>
          <target state="translated">&lt;code&gt;autocommit&lt;/code&gt; 이 1로 설정되어 있으면 &lt;a href=&quot;../lock-in-share-mode/index&quot;&gt;LOCK IN SHARE MODE&lt;/a&gt; 및 &lt;code&gt;FOR UPDATE&lt;/code&gt; 절이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2c1cc29182987394650409d106f53811467a28d4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;autocommit&lt;/code&gt; is set to 1, the LOCK IN SHARE MODE and &lt;a href=&quot;../for-update/index&quot;&gt;FOR UPDATE&lt;/a&gt; clauses have no effect.</source>
          <target state="translated">&lt;code&gt;autocommit&lt;/code&gt; 이 1로 설정되어 있으면 LOCK IN SHARE MODE 및 &lt;a href=&quot;../for-update/index&quot;&gt;FOR UPDATE&lt;/a&gt; 절이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8e915a497658108dfe9a643aacc98cb511128a44" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;backup_type&lt;/code&gt; is &lt;code&gt;full-backuped&lt;/code&gt;, then &lt;code&gt;from_lsn&lt;/code&gt; has the value of &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;backup_type&lt;/code&gt; 이 있다 &lt;code&gt;full-backuped&lt;/code&gt; 후 &lt;code&gt;from_lsn&lt;/code&gt; 의 값이 &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe391a03afbfb87cf88831cf3adba425cab485fd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;backup_type&lt;/code&gt; is &lt;code&gt;incremental&lt;/code&gt;, then &lt;code&gt;from_lsn&lt;/code&gt; has the value of the &lt;a href=&quot;../innodb-redo-log/index#log-sequence-number-lsn&quot;&gt;log sequence number (LSN)&lt;/a&gt; at which the backup started reading from the &lt;a href=&quot;../innodb-redo-log/index&quot;&gt;InnoDB redo log&lt;/a&gt;. This is internally used by Mariabackup when preparing incremental backups.</source>
          <target state="translated">&lt;code&gt;backup_type&lt;/code&gt; 이 &lt;code&gt;incremental&lt;/code&gt; 인 경우 , &lt;code&gt;from_lsn&lt;/code&gt; 은 백업이 &lt;a href=&quot;../innodb-redo-log/index&quot;&gt;InnoDB 리두 로그&lt;/a&gt; 에서 읽기 시작한 &lt;a href=&quot;../innodb-redo-log/index#log-sequence-number-lsn&quot;&gt;LSN (로그 시퀀스 번호)&lt;/a&gt; 값을 갖습니다 . 이는 증분 백업을 준비 할 때 Mariabackup에서 내부적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="09601bab020e80bd49d31f4912b595cdd9b79431" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;expr1&lt;/code&gt; is &lt;code&gt;TRUE&lt;/code&gt; (&lt;code&gt;expr1 &amp;lt;&amp;gt; 0&lt;/code&gt; and &lt;code&gt;expr1 &amp;lt;&amp;gt; NULL&lt;/code&gt;) then &lt;code&gt;IF()&lt;/code&gt; returns &lt;code&gt;expr2&lt;/code&gt;; otherwise it returns &lt;code&gt;expr3&lt;/code&gt;. &lt;code&gt;IF()&lt;/code&gt; returns a numeric or string value, depending on the context in which it is used.</source>
          <target state="translated">&lt;code&gt;expr1&lt;/code&gt; 이 &lt;code&gt;TRUE&lt;/code&gt; 이면 ( &lt;code&gt;expr1 &amp;lt;&amp;gt; 0&lt;/code&gt; 및 &lt;code&gt;expr1 &amp;lt;&amp;gt; NULL&lt;/code&gt; ) &lt;code&gt;IF()&lt;/code&gt; 는 &lt;code&gt;expr2&lt;/code&gt; 를 반환합니다 . 그렇지 않으면 &lt;code&gt;expr3&lt;/code&gt; 을 반환합니다 . &lt;code&gt;IF()&lt;/code&gt; 는 사용되는 컨텍스트에 따라 숫자 또는 문자열 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="94e44e3a9bc243c264dd43797107dde5cf0fe7d9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;hostname&lt;/code&gt; is not specified or &lt;code&gt;hostname&lt;/code&gt; is &lt;code&gt;localhost&lt;/code&gt;, then Unix sockets are used. Unused connection parameters (such as &lt;code&gt;port&lt;/code&gt;) will be ignored.</source>
          <target state="translated">경우 &lt;code&gt;hostname&lt;/code&gt; 지정되지 않았거나 &lt;code&gt;hostname&lt;/code&gt; 인 &lt;code&gt;localhost&lt;/code&gt; 를 , 다음 유닉스 소켓이 사용됩니다. 사용하지 않는 연결 매개 변수 (예 : &lt;code&gt;port&lt;/code&gt; )는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="70f0b82adef759e302dfb68d4919e8151412ff64" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;innodb_ft_user_stopword_table&lt;/code&gt; is not set, the table set by &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_ft_server_stopword_table&quot;&gt;innodb_ft_server_stopword_table&lt;/a&gt; is used.</source>
          <target state="translated">경우 &lt;code&gt;innodb_ft_user_stopword_table&lt;/code&gt; 가 설정되지 않은 의한 테이블 세트 &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_ft_server_stopword_table&quot;&gt;innodb_ft_server_stopword_table이&lt;/a&gt; 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a716ca47dcdc4a892b8afa5e84fdedcb7c37fc33" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;join_cache_bka&lt;/code&gt; is off then BKA and BKAH join algorithms are not allowed. If &lt;code&gt;join_cache_hashed&lt;/code&gt; is off then BNLH and BKAH join algorithms are not allowed. If &lt;code&gt;join_cache_incremental&lt;/code&gt; is off then no incremental variants of the block-based join algorithms are allowed.</source>
          <target state="translated">경우 &lt;code&gt;join_cache_bka&lt;/code&gt; 은 다음 꺼져 BKA 및 BKAH 알고리즘이 허용되지 않습니다 가입 할 수 있습니다. 경우 &lt;code&gt;join_cache_hashed&lt;/code&gt; 은 다음 꺼져 BNLH 및 BKAH 알고리즘이 허용되지 않습니다 가입 할 수 있습니다. &lt;code&gt;join_cache_incremental&lt;/code&gt; 이 해제되어 있으면 블록 기반 결합 알고리즘의 증분 변형이 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bd3b7806ba07cbe19fb2b0c4b77f63f79f15d10e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;minute&lt;/code&gt; or &lt;code&gt;second&lt;/code&gt; are out of the range 0 to 60, NULL is returned. The &lt;code&gt;hour&lt;/code&gt; can be in the range -838 to 838, outside of which the value is truncated with a warning.</source>
          <target state="translated">경우 &lt;code&gt;minute&lt;/code&gt; 또는 &lt;code&gt;second&lt;/code&gt; 0 내지 60의 범위를 벗어나, NULL이 반환된다. &lt;code&gt;hour&lt;/code&gt; 범위 내에있을 수 -838 값 경고가 절단되어있는 외부 838한다.</target>
        </trans-unit>
        <trans-unit id="807c7617fa4d51e8e3373191ae7dc25f5384aeb2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;mysql_install_db&lt;/code&gt; fails, you should examine the &lt;a href=&quot;../error-log/index&quot;&gt;error log&lt;/a&gt; in the data directory, which is the directory specified with &lt;code&gt;--datadir&lt;/code&gt; option. This should provide a clue about what went wrong.</source>
          <target state="translated">경우 &lt;code&gt;mysql_install_db&lt;/code&gt; 가이 실패, 당신은 조사해야 &lt;a href=&quot;../error-log/index&quot;&gt;오류 로그&lt;/a&gt; 로 지정된 디렉토리 데이터 디렉토리에 &lt;code&gt;--datadir&lt;/code&gt; 옵션을 선택합니다. 이것은 무엇이 잘못되었는지에 대한 힌트를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="0bf7bc902a774aba8bc9b56194cb68253c50faf8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;protocol&lt;/code&gt; is not specified, then the following happens:</source>
          <target state="translated">경우 &lt;code&gt;protocol&lt;/code&gt; 지정되어 있지 않은 경우, 다음과 같은 상황이 발생합니다</target>
        </trans-unit>
        <trans-unit id="e59a4c134a588949679c44f7f4c6fbf912472d0f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;round&lt;/code&gt; is used then it will set the &lt;code&gt;round&lt;/code&gt; value (or the internal cycle count, starting at zero) for the sequence. If &lt;code&gt;round&lt;/code&gt; is not used, it's assumed to be 0.</source>
          <target state="translated">경우 &lt;code&gt;round&lt;/code&gt; 사용 후는 설정할 것이다 &lt;code&gt;round&lt;/code&gt; 값 (또는 내부 사이클 카운트, 제로에서 시작)를위한 시퀀스. 경우 &lt;code&gt;round&lt;/code&gt; 사용되지 않습니다, 0으로 가정한다.</target>
        </trans-unit>
        <trans-unit id="a20b908276c8337436dcf766c905d68c13ecf06d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;shared-memory-base-name&lt;/code&gt; is not specified and &lt;code&gt;hostname&lt;/code&gt; is not specified or &lt;code&gt;hostname&lt;/code&gt; is &lt;code&gt;localhost&lt;/code&gt;, then the connection will happen through windows named pipes.</source>
          <target state="translated">경우 &lt;code&gt;shared-memory-base-name&lt;/code&gt; 지정되지 않고 &lt;code&gt;hostname&lt;/code&gt; 지정되지 않았거나 &lt;code&gt;hostname&lt;/code&gt; 인 &lt;code&gt;localhost&lt;/code&gt; 를 , 다음 연결 파이프라는 이름의 창을 통해 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b9367a27a875fb1bb78a33829b72a7e787c6be05" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;shared-memory-base-name&lt;/code&gt; is specified and &lt;code&gt;hostname&lt;/code&gt; is not specified or &lt;code&gt;hostname&lt;/code&gt; is &lt;code&gt;localhost&lt;/code&gt;, then the connection will happen through shared memory. Unused connection parameters (such as &lt;code&gt;port&lt;/code&gt;) will be ignored.</source>
          <target state="translated">경우 &lt;code&gt;shared-memory-base-name&lt;/code&gt; 지정되고 &lt;code&gt;hostname&lt;/code&gt; 지정되지 않았거나 &lt;code&gt;hostname&lt;/code&gt; 인 &lt;code&gt;localhost&lt;/code&gt; 를 , 다음 연결은 공유 메모리를 통해 발생합니다. 사용하지 않는 연결 매개 변수 (예 : &lt;code&gt;port&lt;/code&gt; )는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="e5d5ec09992b7de174eeb95e2b9266e6024da7af" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sql_error_log_rate&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt; the logging is disabled.</source>
          <target state="translated">경우 &lt;code&gt;sql_error_log_rate&lt;/code&gt; 가 있다 &lt;code&gt;0&lt;/code&gt; 로깅을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c77467ff82cd0dbc1368f7c890d931cfc1056c75" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str&lt;/code&gt; is &lt;code&gt;NULL&lt;/code&gt;, &lt;code&gt;UNHEX()&lt;/code&gt; returns &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;str&lt;/code&gt; 입니다 &lt;code&gt;NULL&lt;/code&gt; , &lt;code&gt;UNHEX()&lt;/code&gt; 반환 &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4b4261e160a9935623a6aa93a6257071cf06b523" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str&lt;/code&gt; is a non-binary string (&lt;a href=&quot;../char/index&quot;&gt;CHAR&lt;/a&gt;, &lt;a href=&quot;../varchar/index&quot;&gt;VARCHAR&lt;/a&gt; or &lt;a href=&quot;../text/index&quot;&gt;TEXT&lt;/a&gt;), WEIGHT_STRING returns the string's collation weight. If &lt;code&gt;str&lt;/code&gt; is a binary string (&lt;a href=&quot;../binary/index&quot;&gt;BINARY&lt;/a&gt;, &lt;a href=&quot;../varbinary/index&quot;&gt;VARBINARY&lt;/a&gt; or &lt;a href=&quot;../blob/index&quot;&gt;BLOB&lt;/a&gt;), the return value is simply the input value, since the weight for each byte in a binary string is the byte value.</source>
          <target state="translated">경우 &lt;code&gt;str&lt;/code&gt; 아닌 바이너리 문자열입니다 ( &lt;a href=&quot;../char/index&quot;&gt;CHAR&lt;/a&gt; , &lt;a href=&quot;../varchar/index&quot;&gt;VARCHAR&lt;/a&gt; 또는 &lt;a href=&quot;../text/index&quot;&gt;TEXT&lt;/a&gt; ), WEIGHT_STRING 반환 문자열의 조합 무게. 경우 &lt;code&gt;str&lt;/code&gt; 이진 스트링 (인 &lt;a href=&quot;../binary/index&quot;&gt;BINARY&lt;/a&gt; , &lt;a href=&quot;../varbinary/index&quot;&gt;VARBINARY&lt;/a&gt; 또는 &lt;a href=&quot;../blob/index&quot;&gt;BLOB가&lt;/a&gt; ) 이진 스트링의 각 바이트에 대한 가중치가 바이트 값이기 때문에, 반환 값은 단순히 입력 값이다.</target>
        </trans-unit>
        <trans-unit id="d4897bbea856514cf49ddb5c881a8294e0caebbc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str&lt;/code&gt; is not a string value, it is converted into a string. If &lt;code&gt;str&lt;/code&gt; is &lt;code&gt;NULL&lt;/code&gt;, the function returns &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;str&lt;/code&gt; 문자열 값이 아닙니다, 그것은 문자열로 변환됩니다. 경우 &lt;code&gt;str&lt;/code&gt; 입니다 &lt;code&gt;NULL&lt;/code&gt; 이 함수는 반환 &lt;code&gt;NULL&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="3a3ab822a448fb386bb98f61abe502bf469ea3fe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;table_name&lt;/code&gt; was locked with &lt;a href=&quot;../lock-tables-and-unlock-tables/index&quot;&gt;LOCK TABLES&lt;/a&gt; it will continue to be locked after the statement.</source>
          <target state="translated">경우 &lt;code&gt;table_name&lt;/code&gt; 잠겨 된 &lt;a href=&quot;../lock-tables-and-unlock-tables/index&quot;&gt;잠금 테이블&lt;/a&gt; 은 성명 이후 계속 잠글 것입니다.</target>
        </trans-unit>
        <trans-unit id="0b153f22c21fd5422dec4703c64daaed15bab3bd" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;&lt;code&gt;expr1&lt;/code&gt;&lt;/em&gt; is not NULL, IFNULL() returns &lt;em&gt;&lt;code&gt;expr1&lt;/code&gt;&lt;/em&gt;; otherwise it returns &lt;em&gt;&lt;code&gt;expr2&lt;/code&gt;&lt;/em&gt;. IFNULL() returns a numeric or string value, depending on the context in which it is used.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;expr1&lt;/code&gt; &lt;/em&gt; 이 NULL이 아닌 경우 IFNULL ()은 &lt;em&gt; &lt;code&gt;expr1&lt;/code&gt; 을&lt;/em&gt; 리턴합니다 . 그렇지 않으면 &lt;em&gt; &lt;code&gt;expr2&lt;/code&gt; 를&lt;/em&gt; 반환합니다 . IFNULL ()은 사용되는 컨텍스트에 따라 숫자 또는 문자열 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="be95d65f6f2654633df01ac639806ea3d0b6f07e" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;&lt;code&gt;expr&lt;/code&gt;&lt;/em&gt; is NULL, IN always returns NULL. If at least one of the values in the list is NULL, and one of the comparisons is true, the result is 1. If at least one of the values in the list is NULL and none of the comparisons is true, the result is NULL.</source>
          <target state="translated">경우 &lt;em&gt; &lt;code&gt;expr&lt;/code&gt; 이&lt;/em&gt; NULL이고, IN은 항상 NULL을 반환합니다. 목록의 값 중 하나 이상이 NULL이고 비교 중 하나가 참이면 결과는 1입니다. 목록의 값 중 하나 이상이 NULL이고 비교 중 어느 것도 참이 아닌 경우 결과는 NULL입니다 .</target>
        </trans-unit>
        <trans-unit id="c6d87faa9fcd1ecbbffec303e06251ca47dcf43d" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;&lt;code&gt;expr&lt;/code&gt;&lt;/em&gt; is NULL, ISNULL() returns 1, otherwise it returns 0.</source>
          <target state="translated">경우 &lt;em&gt; &lt;code&gt;expr&lt;/code&gt; 이&lt;/em&gt; NULL이며, ISNULL () 그렇지 않으면 0을 반환 1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="86ba07207c618b6f6bb96c298bf778590021994f" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;expr&lt;/em&gt; is a time with no microseconds, zero is returned, while if &lt;em&gt;expr&lt;/em&gt; is a date with no time, zero with a warning is returned.</source>
          <target state="translated">경우 &lt;em&gt;expr이&lt;/em&gt; 없는 마이크로와 시간이면 반면, 제로, 반환 &lt;em&gt;expr이&lt;/em&gt; 없는 시간과 날짜는 경고와 0을 반환한다.</target>
        </trans-unit>
        <trans-unit id="ff06e06f5e7fa1f00bf50e889376ee72719d530a" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;mysqlbinlog&lt;/em&gt; reads a binary log event that it does not recognize, it prints a warning, ignores the event, and continues. Without this option, mysqlbinlog stops if it reads such an event.</source>
          <target state="translated">경우 &lt;em&gt;에서 mysqlbinlog가&lt;/em&gt; 인식하지 못하는 바이너리 로그 이벤트를 읽고는 경고를 출력 이벤트를 무시하고 계속 진행한다. 이 옵션이 없으면 mysqlbinlog는 이러한 이벤트를 읽으면 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="009dcfb155687be923832a264ae56698c24164ae" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;x_remove()&lt;/em&gt; supported (defined) detected automatically.</source>
          <target state="translated">만약 &lt;em&gt;x_remove ()&lt;/em&gt; 지원 (정의)를 자동으로 검출.</target>
        </trans-unit>
        <trans-unit id="8b307256c43bf5a94da90a15848fab27d0403981" translate="yes" xml:space="preserve">
          <source>If &lt;strong&gt;Key&lt;/strong&gt; is &lt;em&gt;&lt;strong&gt;MUL&lt;/strong&gt;&lt;/em&gt;, multiple occurrences of a given value are allowed within the column. The column is the first column of a non-unique index or a unique-valued index that can contain &lt;code&gt;NULL&lt;/code&gt; values.</source>
          <target state="translated">&lt;strong&gt;Key&lt;/strong&gt; 가 &lt;em&gt;&lt;strong&gt;MUL&lt;/strong&gt;&lt;/em&gt; 인 경우 주어진 값이 여러 번 발생할 수 있습니다. 열은 고유하지 않은 인덱스 또는 &lt;code&gt;NULL&lt;/code&gt; 값을 포함 할 수있는 고유 값 인덱스의 첫 번째 열입니다 .</target>
        </trans-unit>
        <trans-unit id="721c72445e231f9a41a3fae09bda7768145661f1" translate="yes" xml:space="preserve">
          <source>If &lt;strong&gt;Key&lt;/strong&gt; is &lt;em&gt;&lt;strong&gt;PRI&lt;/strong&gt;&lt;/em&gt;, the column is a &lt;code&gt;PRIMARY KEY&lt;/code&gt; or is one of the columns in a multiple-column &lt;code&gt;PRIMARY KEY&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;strong&gt;키&lt;/strong&gt; 입니다 &lt;em&gt;&lt;strong&gt;PRI&lt;/strong&gt;&lt;/em&gt; , 열은입니다 &lt;code&gt;PRIMARY KEY&lt;/code&gt; 또는 여러 열에서 열 중 하나입니다 &lt;code&gt;PRIMARY KEY&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e3b3c9325d441c894a24bd158309e0a15c0a62af" translate="yes" xml:space="preserve">
          <source>If &lt;strong&gt;Key&lt;/strong&gt; is &lt;em&gt;&lt;strong&gt;UNI&lt;/strong&gt;&lt;/em&gt;, the column is the first column of a unique-valued index that cannot contain &lt;code&gt;NULL&lt;/code&gt; values.</source>
          <target state="translated">경우 &lt;strong&gt;키&lt;/strong&gt; 입니다 &lt;em&gt;&lt;strong&gt;UNI&lt;/strong&gt;&lt;/em&gt; , 열은 포함 할 수 없습니다 고유 값 인덱스의 첫 번째 열입니다 &lt;code&gt;NULL&lt;/code&gt; 의 값을.</target>
        </trans-unit>
        <trans-unit id="30446c9e71bb66ac0d0001f503cd2cc877b70211" translate="yes" xml:space="preserve">
          <source>If &lt;strong&gt;Key&lt;/strong&gt; is empty, the column either is not indexed or is indexed only as a secondary column in a multiple-column, non-unique index.</source>
          <target state="translated">&lt;strong&gt;키&lt;/strong&gt; 가 비어 있으면 열이 색인화되지 않거나 다중 열의 고유하지 않은 색인에서 2 차 열로만 색인화됩니다.</target>
        </trans-unit>
        <trans-unit id="efb97e9de7bd70781b7dae5abb9012c4192bc120" translate="yes" xml:space="preserve">
          <source>If Aria doesn't start or you have an unrecoverable table (shouldn't happen):</source>
          <target state="translated">Aria가 시작되지 않거나 복구 할 수없는 테이블이있는 경우 (발생하지 않아야 함) :</target>
        </trans-unit>
        <trans-unit id="1e39b438fffc00ffd0cb487e4b0307b4b0dcc80f" translate="yes" xml:space="preserve">
          <source>If Aria is ever unable to obtain a lock, we might have a deadlock. There are two primary ways for detecting if a deadlock has actually occurred. First is to search a wait-for graph (see the &lt;a href=&quot;http://en.wikipedia.org/wiki/Wait-for_graph&quot;&gt;wait-for graph on Wikipedia&lt;/a&gt;) and the second is to just wait and let the deadlock exhibit itself. Aria Two-step Deadlock Detection does a combination of both.</source>
          <target state="translated">Aria가 잠금을 획득 할 수없는 경우 교착 상태가 발생했을 수 있습니다. 교착 상태가 실제로 발생했는지 감지하는 두 가지 기본 방법이 있습니다. 첫 번째는 대기 그래프를 검색하는 것이며 ( &lt;a href=&quot;http://en.wikipedia.org/wiki/Wait-for_graph&quot;&gt;Wikipedia&lt;/a&gt; 의 대기 그래프 참조 ) 두 번째는 대기하고 교착 상태를 표시하는 것입니다. Aria 2 단계 교착 상태 탐지는이 두 가지를 모두 수행합니다.</target>
        </trans-unit>
        <trans-unit id="26931a443926b98509a90055c1a4804e153a780f" translate="yes" xml:space="preserve">
          <source>If Aria is ever unable to obtain a lock, we might have a deadlock. There are two primary ways for detecting if a deadlock has actually occurred. First is to search a wait-for graph (see the &lt;a href=&quot;https://en.wikipedia.org/wiki/Wait-for_graph&quot;&gt;wait-for graph on Wikipedia&lt;/a&gt;) and the second is to just wait and let the deadlock exhibit itself. Aria Two-step Deadlock Detection does a combination of both.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8117e7b0a9e798bd1e7a721caed032c8b871ed7b" translate="yes" xml:space="preserve">
          <source>If COMMIT or ROLLBACK is issued and no transaction was started, no error is reported.</source>
          <target state="translated">COMMIT 또는 ROLLBACK이 발행되고 트랜잭션이 시작되지 않은 경우 오류가보고되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1b27a2d59fdf94c44391dab416ba02b3afa8582b" translate="yes" xml:space="preserve">
          <source>If Cassandra's &lt;code&gt;rowkey&lt;/code&gt; has an alias (or name), then MariaDB's column must have the same name.</source>
          <target state="translated">Cassandra의 &lt;code&gt;rowkey&lt;/code&gt; 에 별명 (또는 이름)이 있으면 MariaDB의 열 이름이 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="48471704e165c6d5815f33900e8862f1e7d8c1b6" translate="yes" xml:space="preserve">
          <source>If GET DIAGNOSTICS produces an error condition (because the command is properly parsed but not correctly used), the diagnostics area is not emptied, and the new condition is added.</source>
          <target state="translated">GET DIAGNOSTICS가 오류 조건을 생성하면 (명령이 올바르게 구문 분석되었지만 올바르게 사용되지 않기 때문에) 진단 영역이 비워지지 않고 새 조건이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="62cb36839e149d893a9506fdde374a13d377c50c" translate="yes" xml:space="preserve">
          <source>If HTTP traffic requires a proxy in your environment, then you can specify the proxy by setting the &lt;code&gt;&lt;a href=&quot;#feedback_http_proxy&quot;&gt;feedback_http_proxy&lt;/a&gt;&lt;/code&gt; system variable.</source>
          <target state="translated">HTTP 트래픽에 사용자 환경의 프록시가 필요한 경우 &lt;code&gt;&lt;a href=&quot;#feedback_http_proxy&quot;&gt;feedback_http_proxy&lt;/a&gt;&lt;/code&gt; 시스템 변수를 설정하여 프록시를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="129f4755fe82fac51888c19494daeb7e6a5f0de0" translate="yes" xml:space="preserve">
          <source>If I look at the MySQL-site &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/de/datetime.html&quot;&gt;http://dev.mysql.com/doc/refman/5.1/de/datetime.html&lt;/a&gt;</source>
          <target state="translated">MySQL 사이트 &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/de/datetime.html&quot;&gt;http://dev.mysql.com/doc/refman/5.1/de/datetime.html을&lt;/a&gt; 보면</target>
        </trans-unit>
        <trans-unit id="658d3f05c3742a89600df3961ca06bb80269572e" translate="yes" xml:space="preserve">
          <source>If I look at the MySQL-site &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.1/de/datetime.html&quot;&gt;http://dev.mysql.com/doc/refman/5.1/de/datetime.html&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a057c523dd1e7025317801efd0f1e6144eec220" translate="yes" xml:space="preserve">
          <source>If InnoDB crashes the server after detecting data corruption, it writes a detailed message in the error log. The first lines are similar to the following:</source>
          <target state="translated">데이터 손상을 감지 한 후 InnoDB가 서버와 충돌하면 오류 로그에 자세한 메시지가 기록됩니다. 첫 번째 줄은 다음과 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="69286800b6c4616ee780c018cbcf1f3066fff6fc" translate="yes" xml:space="preserve">
          <source>If InnoDB needs to restore an old version, it will simply replace the newer version with the older one. When a transaction inserts a new row, there is no older version. However, in that case, the restore can be done by deleting the inserted rows.</source>
          <target state="translated">InnoDB가 이전 버전을 복원해야하는 경우 새 버전을 이전 버전으로 대체하기 만하면됩니다. 트랜잭션이 새 행을 삽입하면 이전 버전이 없습니다. 그러나이 경우 삽입 된 행을 삭제하여 복원을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc174602ed4cb7a60de7d1f3af8d9d2c3d497f13" translate="yes" xml:space="preserve">
          <source>If InnoDB returns something like the following error:</source>
          <target state="translated">InnoDB가 다음과 같은 오류를 반환하는 경우 :</target>
        </trans-unit>
        <trans-unit id="1b9b733f28677e0f788024b47e3d19d54ad7d42b" translate="yes" xml:space="preserve">
          <source>If InnoDB strict mode is enabled, and if a DDL statement is executed and invalid or conflicting &lt;a href=&quot;../create-table/index#table-options&quot;&gt;table options&lt;/a&gt; are specified, then an error is raised. The error will only be a generic error that says the following:</source>
          <target state="translated">InnoDB 엄격 모드가 사용 가능하고 DDL 문이 실행되고 유효하지 않거나 충돌하는 &lt;a href=&quot;../create-table/index#table-options&quot;&gt;테이블 옵션&lt;/a&gt; 이 지정되면 오류가 발생합니다. 오류는 다음과 같은 일반적인 오류 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="7b26e1e0530cb9812fdf9d4a1ac764f84911418a" translate="yes" xml:space="preserve">
          <source>If InnoDB strict mode is enabled, and if a table exceeds its row format's &lt;a href=&quot;../innodb-row-formats-overview/index#maximum-row-size&quot;&gt;maximum row size&lt;/a&gt;, then InnoDB will return an error.</source>
          <target state="translated">InnoDB 엄격 모드가 활성화되어 있고 테이블이 행 형식의 &lt;a href=&quot;../innodb-row-formats-overview/index#maximum-row-size&quot;&gt;최대 행 크기를&lt;/a&gt; 초과하면 InnoDB는 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6f3fec6040d1b584501669ec16e2daf8cf237b80" translate="yes" xml:space="preserve">
          <source>If InnoDB strict mode is enabled, and if a table uses the &lt;code&gt;&lt;a href=&quot;../innodb-compressed-row-format/index&quot;&gt;COMPRESSED&lt;/a&gt;&lt;/code&gt; row format, and if the table's &lt;code&gt;&lt;a href=&quot;../create-table/index#key_block_size&quot;&gt;KEY_BLOCK_SIZE&lt;/a&gt;&lt;/code&gt; is too small to contain a row, then an error is returned by the statement.</source>
          <target state="translated">InnoDB 엄격 모드가 사용 가능하고 테이블이 &lt;code&gt;&lt;a href=&quot;../innodb-compressed-row-format/index&quot;&gt;COMPRESSED&lt;/a&gt;&lt;/code&gt; 행 형식을 사용하고 테이블의 &lt;code&gt;&lt;a href=&quot;../create-table/index#key_block_size&quot;&gt;KEY_BLOCK_SIZE&lt;/a&gt;&lt;/code&gt; 가 너무 작아 행을 포함 할 수없는 경우 명령문이 오류를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="84684ed9cf0b2e4229921958bfc929ba10f19e0f" translate="yes" xml:space="preserve">
          <source>If MYSQL_ERRNO is out of range, you will get an error like this:</source>
          <target state="translated">MYSQL_ERRNO가 범위를 벗어나면 다음과 같은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7a4d7910639fd436ac318942067f69eadaad2e5a" translate="yes" xml:space="preserve">
          <source>If MariaDB Columnstore has ever before been installed on any of the planned hosts as a root user install, you must have the system administrator verify that no remnants of that installation exist. The non-root installation will not be successful if there are MariaDB Columnstore files owned by root on any of the hosts.</source>
          <target state="translated">계획된 호스트에 MariaDB Columnstore를 루트 사용자 설치로 설치 한 적이있는 경우 시스템 관리자에게 해당 설치의 나머지가 존재하지 않는지 확인해야합니다. 호스트 중 하나에 root가 소유 한 MariaDB Columnstore 파일이 있으면 비 루트 설치에 실패합니다.</target>
        </trans-unit>
        <trans-unit id="d49b6023716413de4b2e3b03571005ff08e81abc" translate="yes" xml:space="preserve">
          <source>If MariaDB Columnstore has ever before been installed on any of the planned hosts as a root user install, you must have the system administrator verify that no remnants of that installation exist. The unprivileged installation will not be successful if there are MariaDB Columnstore files owned by root on any of the hosts.</source>
          <target state="translated">계획된 호스트에 MariaDB Columnstore를 루트 사용자 설치로 설치 한 적이있는 경우 시스템 관리자에게 해당 설치의 나머지가 존재하지 않는지 확인해야합니다. 호스트가 루트로 소유 한 MariaDB Columnstore 파일이 있으면 권한이없는 설치는 성공하지 못합니다.</target>
        </trans-unit>
        <trans-unit id="c89e7cbb3098221bd3da782024b57896dde3bdbe" translate="yes" xml:space="preserve">
          <source>If MariaDB encounters a full disk error while trying to write to a binary log file, then it will keep retrying the write every 60 seconds. Log messages will get written to the error log every 600 seconds. For example:</source>
          <target state="translated">이진 로그 파일에 쓰려고 시도하는 동안 MariaDB에 전체 디스크 오류가 발생하면 60 초마다 계속해서 다시 쓰기를 시도합니다. 600 초마다 로그 메시지가 오류 로그에 기록됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1bc3462a2a84c8b8e9a701e6a8299ef5a3481032" translate="yes" xml:space="preserve">
          <source>If MariaDB is compiled for debugging, you can both use it in a debugger, an...</source>
          <target state="translated">MariaDB가 디버깅을 위해 컴파일되면 디버거에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fbd5217c13998117aa62f790d1659c28f3a2ecc8" translate="yes" xml:space="preserve">
          <source>If MariaDB is configured to access files under &lt;code&gt;/home&lt;/code&gt;, &lt;code&gt;/root&lt;/code&gt;, or &lt;code&gt;/run/user&lt;/code&gt;, then the default systemd unit file will prevent access to these directories with a &lt;code&gt;Permission Denied&lt;/code&gt; error. This happens because the unit file set &lt;code&gt;&lt;a href=&quot;https://www.freedesktop.org/software/systemd/man/systemd.exec.html#ProtectHome=&quot;&gt;ProtectHome=true&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;../systemd/index#configuring-access-to-home-directories&quot;&gt;Systemd: Configuring Access to Home Directories&lt;/a&gt; for information on how to work around this.</source>
          <target state="translated">MariaDB가 &lt;code&gt;/home&lt;/code&gt; , &lt;code&gt;/root&lt;/code&gt; 또는 &lt;code&gt;/run/user&lt;/code&gt; 에있는 파일에 액세스하도록 구성된 경우 기본 시스템 단위 파일은 &lt;code&gt;Permission Denied&lt;/code&gt; 오류 로 이러한 디렉토리에 액세스 할 수 없습니다. 이것은 단위 파일이 &lt;code&gt;&lt;a href=&quot;https://www.freedesktop.org/software/systemd/man/systemd.exec.html#ProtectHome=&quot;&gt;ProtectHome=true&lt;/a&gt;&lt;/code&gt; 로 설정 되었기 때문에 발생 합니다 . 이 문제를 해결하는 방법에 대한 정보는 시스템 &lt;a href=&quot;../systemd/index#configuring-access-to-home-directories&quot;&gt;: 홈 디렉토리에&lt;/a&gt; 대한 액세스 구성을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="09263619c6e92b2718b503c13c5b794baf79fdcb" translate="yes" xml:space="preserve">
          <source>If MariaDB needs to perform automatic crash recovery and if the &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt; is &lt;strong&gt;not&lt;/strong&gt; enabled, then the &lt;a href=&quot;../error-log/index&quot;&gt;error log&lt;/a&gt; will contain messages like this:</source>
          <target state="translated">MariaDB가 자동 응급 복구를 수행해야하고 &lt;a href=&quot;../binary-log/index&quot;&gt;이진 로그&lt;/a&gt; 가 활성화 되어 &lt;strong&gt;있지 않으면 &lt;/strong&gt;&lt;a href=&quot;../error-log/index&quot;&gt;오류 로그에&lt;/a&gt; 다음 과 같은 메시지가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="b6c3ded288faf835347ae195bffe71f127c44631" translate="yes" xml:space="preserve">
          <source>If MariaDB needs to perform automatic crash recovery and if the &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt; is enabled, then the &lt;a href=&quot;../error-log/index&quot;&gt;error log&lt;/a&gt; will contain messages like this:</source>
          <target state="translated">MariaDB가 자동 응급 복구를 수행해야하고 &lt;a href=&quot;../binary-log/index&quot;&gt;이진 로그&lt;/a&gt; 가 활성화 된 경우 &lt;a href=&quot;../error-log/index&quot;&gt;오류 로그&lt;/a&gt; 에는 다음 과 같은 메시지가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="e678b08a1bf487f0e7bb9f2d63c0472abec4c380" translate="yes" xml:space="preserve">
          <source>If MariaDB shuts down or crashes, &lt;code&gt;xtstat&lt;/code&gt; will attempt to reconnect. &lt;code&gt;xtstat&lt;/code&gt; can be terminated any time using the &lt;code&gt;CTRL-C&lt;/code&gt; key cimbination.</source>
          <target state="translated">MariaDB가 종료되거나 충돌하면 &lt;code&gt;xtstat&lt;/code&gt; 는 다시 연결을 시도합니다. &lt;code&gt;xtstat&lt;/code&gt; 는 &lt;code&gt;CTRL-C&lt;/code&gt; 키 암호화를 사용하여 언제든지 종료 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="11478d67d81d585bfd1e301cbe45012b6c860abf" translate="yes" xml:space="preserve">
          <source>If MariaDB takes longer than 90 seconds to start, then the default systemd unit file will cause it to fail with an error. This happens because the default value for the &lt;code&gt;&lt;a href=&quot;https://www.freedesktop.org/software/systemd/man/systemd.service.html#TimeoutStartSec=&quot;&gt;TimeoutStartSec&lt;/a&gt;&lt;/code&gt; option is 90 seconds. See &lt;a href=&quot;../systemd/index#configuring-the-systemd-service-timeout&quot;&gt;Systemd: Configuring the Systemd Service Timeout&lt;/a&gt; for information on how to work around this.</source>
          <target state="translated">MariaDB를 시작하는 데 90 초 이상이 걸리면 기본 시스템 단위 파일이 오류와 함께 실패합니다. &lt;code&gt;&lt;a href=&quot;https://www.freedesktop.org/software/systemd/man/systemd.service.html#TimeoutStartSec=&quot;&gt;TimeoutStartSec&lt;/a&gt;&lt;/code&gt; 옵션 의 기본값 이 90 초 이기 때문에 발생합니다 . 이 문제를 해결하는 방법에 대한 정보 &lt;a href=&quot;../systemd/index#configuring-the-systemd-service-timeout&quot;&gt;는 Systemd : Systemd Service Timeout 구성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="43ef49ad7c092e6870bb262a1fd25c88e0ec3402" translate="yes" xml:space="preserve">
          <source>If Mariabackup uses more file descriptors than the system is configured to allow, then users can see errors like the following:</source>
          <target state="translated">Mariabackup이 시스템이 허용하도록 구성된 것보다 많은 파일 설명자를 사용하는 경우 사용자는 다음과 같은 오류를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46bae166da2e42853cde1e5f7df27a4669fc9445" translate="yes" xml:space="preserve">
          <source>If MySQL/MariaDB is already installed and running, you have two options:</source>
          <target state="translated">MySQL / MariaDB가 이미 설치되어 실행중인 경우 다음 두 가지 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="78debdbd134633a7fda77624cb9f4b48d50598b5" translate="yes" xml:space="preserve">
          <source>If OQGRAPH gets compiled properly, there should be a file like:</source>
          <target state="translated">OQGRAPH가 올바르게 컴파일되면 다음과 같은 파일이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="47160270ac6e088412d69a2badee60904e35ffc7" translate="yes" xml:space="preserve">
          <source>If P1 or P2 contains a two-digit year, values from 00 to 69 are converted to from 2000 to 2069, while values from 70 are converted to 1970 upwards.</source>
          <target state="translated">P1 또는 P2에 두 자리 연도가 포함 된 경우 00에서 69 사이의 값은 2000에서 2069로 변환되고 70에서 값은 1970 이상으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="9e8a9da717722b0659d367f45053df53b9e374ce" translate="yes" xml:space="preserve">
          <source>If R &amp;gt; 1000 -- Batching may not work. Decide how long (S seconds) you can stall loading the data in order to collect a batch of rows.</source>
          <target state="translated">R&amp;gt; 1000 인 경우-배치가 작동하지 않을 수 있습니다. 일련의 행을 수집하기 위해 데이터로드를 중단 할 수있는 시간 (S 초)을 결정하십시오.</target>
        </trans-unit>
        <trans-unit id="23145af9ce4e309b9230b6d8d144dae8d0c7e7df" translate="yes" xml:space="preserve">
          <source>If R &amp;lt; 10 (= 1M/day = 300M/year) -- single-row INSERTs would probably work fine (that is, batching is optional)</source>
          <target state="translated">R &amp;lt;10 인 경우 (= 1M / 일 = 300M / 년)-단일 행 INSERT가 제대로 작동 할 수 있습니다 (즉, 일괄 처리는 선택 사항 임)</target>
        </trans-unit>
        <trans-unit id="a68f0f752dc7a6d2b564ad01d35ccf679dd681ba" translate="yes" xml:space="preserve">
          <source>If R &amp;lt; 100 (3B records per year) -- secondary indexes on Fact table may be ok</source>
          <target state="translated">R &amp;lt;100 (연간 3B 레코드)-팩트 테이블의 보조 인덱스가 정상일 수 있음</target>
        </trans-unit>
        <trans-unit id="fa259916e10d0d30b90d475e57968eab263137cd" translate="yes" xml:space="preserve">
          <source>If R &amp;lt; 1000 (100M records/day) -- avoid secondary indexes on Fact table.</source>
          <target state="translated">R &amp;lt;1000 (100M 레코드 / 일) 인 경우 팩트 테이블에서 보조 인덱스를 피하십시오.</target>
        </trans-unit>
        <trans-unit id="e3b29822cdc3ab8efb87db6842f214a1998f3d20" translate="yes" xml:space="preserve">
          <source>If REVERSE is specified, the counter is decremented, and the upper bound value needs to be less than or equal for the loop to continue.</source>
          <target state="translated">REVERSE가 지정되면 카운터가 감소하고 루프가 계속 되려면 상한값이 작거나 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="e6f1dc76eddde41882e5f21ee7e7a668f2cb9c00" translate="yes" xml:space="preserve">
          <source>If S &amp;lt; 0.1s -- May not be able to keep up</source>
          <target state="translated">S &amp;lt;0.1s 인 경우-유지하지 못할 수 있음</target>
        </trans-unit>
        <trans-unit id="65b63a017a6214cea7abcf6e8ebc2fb4738f20df" translate="yes" xml:space="preserve">
          <source>If SAVEPOINT is issued and no transaction was started, no error is reported but no savepoint is created. When ROLLBACK TO SAVEPOINT or RELEASE SAVEPOINT is called for a savepoint that does not exist, an error like this is issued:</source>
          <target state="translated">SAVEPOINT가 발행되고 트랜잭션이 시작되지 않은 경우 오류는보고되지 않지만 저장 점이 작성되지 않습니다. 존재하지 않는 저장 점에 대해 ROLLBACK TO SAVEPOINT 또는 RELEASE SAVEPOINT를 호출하면 다음과 같은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="65700de607cb27ed236d931db5ffaa75a1a5b3b7" translate="yes" xml:space="preserve">
          <source>If Spider does not appear in this list, you need to run the configuration script. This is installed with the MariaDB server in CentOS. Debian distributions need to install the &lt;code&gt;mariadb-plugin-spider&lt;/code&gt; package first. The package is usually found in &lt;code&gt;/usr/share/mysql&lt;/code&gt;.</source>
          <target state="translated">Spider가이 목록에 없으면 구성 스크립트를 실행해야합니다. 이것은 CentOS의 MariaDB 서버와 함께 설치됩니다. 데비안 배포판은 &lt;code&gt;mariadb-plugin-spider&lt;/code&gt; 패키지 를 설치해야합니다 . 패키지는 보통 &lt;code&gt;/usr/share/mysql&lt;/code&gt; 에 있습니다.</target>
        </trans-unit>
        <trans-unit id="f88ef497d00679a30cf0bdc90b0fe3e7c2a4245a" translate="yes" xml:space="preserve">
          <source>If Staging is 'big', an iteration will take longer, but run more efficiently. Hence, it is self-regulating.</source>
          <target state="translated">스테이징이 '큰'인 경우 반복이 오래 걸리지 만 더 효율적으로 실행됩니다. 그러므로 그것은 스스로 규제하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="e61ae682cd4143a7cb6ce9b841aa205f7111d595" translate="yes" xml:space="preserve">
          <source>If TRUE then the &lt;code&gt;str&lt;/code&gt; will be reinitialized (not freed) before usage</source>
          <target state="translated">TRUE이면 사용 전에 &lt;code&gt;str&lt;/code&gt; 이 다시 초기화됩니다 (해제되지 않음).</target>
        </trans-unit>
        <trans-unit id="dd4df347531f608d9bd7195b3439e68362b7f001" translate="yes" xml:space="preserve">
          <source>If True, Colist is a pipeline.</source>
          <target state="translated">True 인 경우 Colist는 파이프 라인입니다.</target>
        </trans-unit>
        <trans-unit id="82e7ed429ae848d6e5272eab8fef1fc7f4e6b812" translate="yes" xml:space="preserve">
          <source>If User Module #1 is disabled, run to enable it:</source>
          <target state="translated">사용자 모듈 # 1이 비활성화 된 경우 다음을 실행하여 활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="c74ee5c45c43c54b9ae6c23b17888d31c5fa6bc1" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt; event is encountered in which the default database was &lt;em&gt;db1&lt;/em&gt;, then apply the event in &lt;em&gt;db3&lt;/em&gt; instead.</source>
          <target state="translated">경우 &lt;a href=&quot;../binary-log/index&quot;&gt;바이너리 로그&lt;/a&gt; 이벤트가있는 발생 기본 데이터베이스이었다 &lt;em&gt;DB1은&lt;/em&gt; , 다음에 이벤트를 적용 &lt;em&gt;DB3&lt;/em&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="e7dbf005ea2f5ffe79439b5449f076f16b2083cb" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt; event is encountered in which the default database was &lt;em&gt;db2&lt;/em&gt;, then apply the event in &lt;em&gt;db4&lt;/em&gt; instead.</source>
          <target state="translated">경우 &lt;a href=&quot;../binary-log/index&quot;&gt;바이너리 로그&lt;/a&gt; 이벤트가있는 발생 기본 데이터베이스이었다 &lt;em&gt;DB2는&lt;/em&gt; 다음에 이벤트를 적용 &lt;em&gt;DB4&lt;/em&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="fae62e05e1eeb268c0ff518c88eedd59a9752e8e" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;../foreign-keys/index&quot;&gt;foreign key&lt;/a&gt; references this table, the table cannot be dropped. In this case, it is necessary to drop the foreign key first.</source>
          <target state="translated">경우 &lt;a href=&quot;../foreign-keys/index&quot;&gt;외래 키는&lt;/a&gt; 이 테이블을 참조하는 테이블은 삭제할 수 없습니다. 이 경우 외래 키를 먼저 삭제해야합니다.</target>
        </trans-unit>
        <trans-unit id="4582eed28aedd8f4aa374f64d77abcaf893c74b8" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;../myisam/index&quot;&gt;MyISAM&lt;/a&gt; table is fragmented, &lt;a href=&quot;../concurrent-inserts/index&quot;&gt;concurrent inserts&lt;/a&gt; will not be performed until an &lt;code&gt;OPTIMIZE TABLE&lt;/code&gt; statement is executed on that table, unless the &lt;a href=&quot;../server-system-variables/index#concurrent_insert&quot;&gt;concurrent_insert&lt;/a&gt; server system variable is set to &lt;code&gt;ALWAYS&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;../myisam/index&quot;&gt;의 MyISAM&lt;/a&gt; 테이블이 조각화되어, &lt;a href=&quot;../concurrent-inserts/index&quot;&gt;동시 삽입은&lt;/a&gt; 때까지 수행되지 않습니다 &lt;code&gt;OPTIMIZE TABLE&lt;/code&gt; 하지 않는 문이 해당 테이블에서 실행되는 &lt;a href=&quot;../server-system-variables/index#concurrent_insert&quot;&gt;concurrent_insert의&lt;/a&gt; 서버 시스템 변수로 설정되어 &lt;code&gt;ALWAYS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43b197fe09bca554134bbf7b4cac7473c43cfeb9" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;../stored-procedures/index&quot;&gt;stored procedure&lt;/a&gt; executes statements that change the value of LAST_INSERT_ID(), the new value will be seen by statements that follow the procedure call.</source>
          <target state="translated">경우 &lt;a href=&quot;../stored-procedures/index&quot;&gt;저장 프로 시저가&lt;/a&gt; LAST_INSERT_ID ()의 값을 변경 명령문을 실행, 새로운 값은 프로 시저 호출에 따라 문을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b34da18af2b8176c2c8cec2a169842b5843a0635" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;DEFAULT&lt;/code&gt; clause is missing, the default value will be:</source>
          <target state="translated">경우 &lt;code&gt;DEFAULT&lt;/code&gt; 의 조항이 누락 된 기본값은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="5003ae7a2e70bbfa8ce9ee393ac7d5148dfe0446" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;NOT NULL&lt;/code&gt; column having a &lt;code&gt;DEFAULT&lt;/code&gt; value is not referenced, &lt;code&gt;NULL&lt;/code&gt; will be inserted.</source>
          <target state="translated">경우 &lt;code&gt;NOT NULL&lt;/code&gt; 의 가진 열 &lt;code&gt;DEFAULT&lt;/code&gt; 의 값이 참조되지, &lt;code&gt;NULL&lt;/code&gt; 이 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="e679360e77758887ace20059a520aa31a47965c2" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;NULL&lt;/code&gt; column having a &lt;code&gt;DEFAULT&lt;/code&gt; value is not referenced, its default value will be inserted. It is also possible to explicitly assign the default value using the &lt;code&gt;DEFAULT&lt;/code&gt; keyword or the &lt;code&gt;&lt;a href=&quot;../default/index&quot;&gt;DEFAULT()&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">경우 &lt;code&gt;NULL&lt;/code&gt; 의 가진 열 &lt;code&gt;DEFAULT&lt;/code&gt; 의 값이 참조되지, 기본 값이 삽입됩니다. &lt;code&gt;DEFAULT&lt;/code&gt; 키워드 또는 &lt;code&gt;&lt;a href=&quot;../default/index&quot;&gt;DEFAULT()&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 기본값을 명시 적으로 지정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4a104dfee6269a37e4803ab61b93fdc63dede8b7" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;NULL&lt;/code&gt; is assigned to a &lt;code&gt;VIRTUAL&lt;/code&gt; or &lt;code&gt;PERSISTENT&lt;/code&gt; column, the default value is assigned instead.</source>
          <target state="translated">&lt;code&gt;VIRTUAL&lt;/code&gt; 또는 &lt;code&gt;PERSISTENT&lt;/code&gt; 컬럼에 &lt;code&gt;NULL&lt;/code&gt; 이 지정 되면 대신 기본값이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="1b1389ff3831119f9d707106ab697a1e55854695" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;RENAME TABLE&lt;/code&gt; renames more than one table and one renaming fails, all renames executed by the same statement are rolled back.</source>
          <target state="translated">경우 &lt;code&gt;RENAME TABLE&lt;/code&gt; 더 하나 개의 테이블보다 이름을 변경 한 이름 바꾸기가 실패, 같은 문에 의해 실행되는 모든 이름 변경은 롤백됩니다.</target>
        </trans-unit>
        <trans-unit id="08475b2037e15727586f1e559d56e923cde2d8cf" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;SEQUENCE&lt;/code&gt; has been dropped and re-created then it's treated as a new &lt;code&gt;SEQUENCE&lt;/code&gt; and &lt;code&gt;PREVIOUS VALUE FOR&lt;/code&gt; will return &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;SEQUENCE&lt;/code&gt; 삭제되었습니다 다시 만든 다음이를 새로 처리됩니다 &lt;code&gt;SEQUENCE&lt;/code&gt; 및 &lt;code&gt;PREVIOUS VALUE FOR&lt;/code&gt; 반환 &lt;code&gt;NULL&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="929d59ca8cb3f879c7123f195e8e3525ef37bf72" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;SIGNED&lt;/code&gt; generated column is based on the subtraction of an &lt;code&gt;UNSIGNED&lt;/code&gt; value, the resulting value can vary depending on how large the value is and the NO_UNSIGNED_SUBTRACTION &lt;code&gt;&lt;a href=&quot;../sql-mode/index&quot;&gt;sql_mode&lt;/a&gt;&lt;/code&gt; flag. To make the value consistent, use &lt;code&gt;&lt;a href=&quot;../cast/index&quot;&gt;CAST()&lt;/a&gt;&lt;/code&gt; to ensure that each &lt;code&gt;UNSIGNED&lt;/code&gt; operand is &lt;code&gt;SIGNED&lt;/code&gt; before the subtraction.</source>
          <target state="translated">경우 &lt;code&gt;SIGNED&lt;/code&gt; 생성가 컬럼의 감산에 기초 &lt;code&gt;UNSIGNED&lt;/code&gt; 값의 결과 값은 값이 상기의 방법에 큰 NO_UNSIGNED_SUBTRACTION에 따라 달라질 수 &lt;code&gt;&lt;a href=&quot;../sql-mode/index&quot;&gt;sql_mode&lt;/a&gt;&lt;/code&gt; 의 플래그. 값의 일관성을 유지하려면 &lt;code&gt;&lt;a href=&quot;../cast/index&quot;&gt;CAST()&lt;/a&gt;&lt;/code&gt; 를 사용 하여 빼기 전에 각 &lt;code&gt;UNSIGNED&lt;/code&gt; 피연산자가 &lt;code&gt;SIGNED&lt;/code&gt; 되도록 하십시오.</target>
        </trans-unit>
        <trans-unit id="aca1ca47c76e29370c5daf5a2dbb3fa006575bbd" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;timeout&lt;/code&gt; value is specified, &lt;code&gt;MASTER_POS_WAIT()&lt;/code&gt; stops waiting when &lt;code&gt;timeout&lt;/code&gt; seconds have elapsed. &lt;code&gt;timeout&lt;/code&gt; must be greater than 0; a zero or negative &lt;code&gt;timeout&lt;/code&gt; means no &lt;code&gt;timeout&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;timeout&lt;/code&gt; 값이 지정되고, &lt;code&gt;MASTER_POS_WAIT()&lt;/code&gt; 때 대기 정지 &lt;code&gt;timeout&lt;/code&gt; (초)이 경과했다. &lt;code&gt;timeout&lt;/code&gt; 은 0보다 커야합니다. 0 또는 음의 &lt;code&gt;timeout&lt;/code&gt; 는 &lt;code&gt;timeout&lt;/code&gt; 없음을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="4bb5cc5f899a6c1065ffa9eb3004c32cc4bdb153" translate="yes" xml:space="preserve">
          <source>If a DYNAMIC table has some frequently-accessed fixed-length columns, it could be a good idea to move them into a separate FIXED table to avoid fragmentation.</source>
          <target state="translated">DYNAMIC 테이블에 자주 액세스하는 고정 길이 컬럼이있는 경우 단편화를 피하기 위해 별도의 FIXED 테이블로 이동하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="1a7144fbabe73753d94495f2e40b11629ebdb829" translate="yes" xml:space="preserve">
          <source>If a Galera Cluster node is also a &lt;a href=&quot;../../replication-overview/index&quot;&gt;replication master&lt;/a&gt;, then some additional configuration may be needed.</source>
          <target state="translated">Galera Cluster 노드도 &lt;a href=&quot;../../replication-overview/index&quot;&gt;복제 마스터&lt;/a&gt; 인 경우 일부 추가 구성이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9c87b99f5fa7ac5c6c99c1934b24baed0327f20" translate="yes" xml:space="preserve">
          <source>If a Galera Cluster node is also a &lt;a href=&quot;../../replication-overview/index&quot;&gt;replication slave&lt;/a&gt;, then some additional configuration may be needed.</source>
          <target state="translated">Galera Cluster 노드가 &lt;a href=&quot;../../replication-overview/index&quot;&gt;복제 슬레이브&lt;/a&gt; 인 경우 추가 구성이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed5f44ee37e4cf676251c7f67610e5c9157f1097" translate="yes" xml:space="preserve">
          <source>If a Galera Cluster node is also a &lt;a href=&quot;../replication-overview/index&quot;&gt;replication slave&lt;/a&gt;, then that node's &lt;a href=&quot;../replication-threads/index#slave-sql-thread&quot;&gt;slave SQL thread&lt;/a&gt; will be applying transactions that it replicates from its replication master. If the node has &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-system-variables/index#log_slave_updates&quot;&gt;log_slave_updates=ON&lt;/a&gt;&lt;/code&gt; set, then each transaction that the &lt;a href=&quot;../replication-threads/index#slave-sql-thread&quot;&gt;slave SQL thread&lt;/a&gt; applies will also generate a Galera Cluster write set that is replicated to the rest of the nodes in the cluster.</source>
          <target state="translated">Galera Cluster 노드가 &lt;a href=&quot;../replication-overview/index&quot;&gt;복제 슬레이브&lt;/a&gt; 인 경우 해당 노드의 &lt;a href=&quot;../replication-threads/index#slave-sql-thread&quot;&gt;슬레이브 SQL 스레드&lt;/a&gt; 는 복제 마스터에서 복제 한 트랜잭션을 적용합니다. 노드에 &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-system-variables/index#log_slave_updates&quot;&gt;log_slave_updates=ON&lt;/a&gt;&lt;/code&gt; 이 설정 되어 있으면 &lt;a href=&quot;../replication-threads/index#slave-sql-thread&quot;&gt;슬레이브 SQL 스레드가&lt;/a&gt; 적용되는 각 트랜잭션은 클러스터의 나머지 노드로 복제되는 Galera Cluster 쓰기 세트도 생성합니다.</target>
        </trans-unit>
        <trans-unit id="76d43cea0297803df1e973fbadf9f2229e2f9f4b" translate="yes" xml:space="preserve">
          <source>If a NULL value is single-row inserted into a column declared as NOT NULL, an error will be returned. However, if the &lt;a href=&quot;../sql_mode/index&quot;&gt;SQL mode&lt;/a&gt; is not &lt;a href=&quot;../sql-mode/index#strict-mode&quot;&gt;strict&lt;/a&gt; (default until &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1023-release-notes/&quot;&gt;MariaDB 10.2.3&lt;/a&gt;), if a NULL value is multi-row inserted into a column declared as NOT NULL, the implicit default for the column type will be inserted (and NOT the default value in the table definition). The implicit defaults are an empty string for string types, and the zero value for numeric, date and time types.</source>
          <target state="translated">NOT NULL로 선언 된 열에 NULL 값이 단일 행으로 삽입되면 오류가 리턴됩니다. 그러나 &lt;a href=&quot;../sql_mode/index&quot;&gt;SQL 모드&lt;/a&gt; 가 &lt;a href=&quot;../sql-mode/index#strict-mode&quot;&gt;엄격&lt;/a&gt; 하지 않은 경우 ( &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1023-release-notes/&quot;&gt;MariaDB 10.2.3&lt;/a&gt; 까지의 기본값 ) NULL 값이 NOT NULL로 선언 된 열에 다중 행 삽입되면 열 유형에 대한 내재 된 기본값이 삽입됩니다 (기본값이 아님) 테이블 정의의 값). 암시 적 기본값은 문자열 유형의 경우 빈 문자열이고 숫자, 날짜 및 시간 유형의 경우 0입니다.</target>
        </trans-unit>
        <trans-unit id="b9a4502ec4d58d1d00da8b6116d6be2f11c3612a" translate="yes" xml:space="preserve">
          <source>If a UNION was interrupted during execution of one of its queries, the last step of the UNION is still executed in order to produce a partial result.</source>
          <target state="translated">쿼리 중 하나를 실행하는 동안 UNION이 중단 된 경우 부분 결과를 생성하기 위해 UNION의 마지막 단계가 계속 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="46ca975cdcd3dec1de7a23e6ae7ddb03a989f979" translate="yes" xml:space="preserve">
          <source>If a USING clause specifies an index that's not permitted by the storage engine, the engine will instead use another available index type that can be applied without affecting results.</source>
          <target state="translated">USING 절이 스토리지 엔진에서 허용하지 않는 인덱스를 지정하는 경우 엔진은 결과에 영향을주지 않고 적용 할 수있는 다른 사용 가능한 인덱스 유형을 대신 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0ec697626bb177efea0ab985b1b1c3d9743762d1" translate="yes" xml:space="preserve">
          <source>If a UUID was provided by the &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-incremental-history-uuid&quot;&gt;--incremental-history-uuid&lt;/a&gt;&lt;/code&gt; option, then it will be saved here. Otherwise, this will be the empty string.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-incremental-history-uuid&quot;&gt;--incremental-history-uuid&lt;/a&gt;&lt;/code&gt; 옵션 으로 UUID를 제공 한 경우 여기에 저장됩니다. 그렇지 않으면 빈 문자열이됩니다.</target>
        </trans-unit>
        <trans-unit id="d1c519a8435006549176d28a9fddef6bf7a30ac8" translate="yes" xml:space="preserve">
          <source>If a backup is a &lt;a href=&quot;../incremental-backup-and-restore-with-mariabackup/index&quot;&gt;incremental backup&lt;/a&gt;, then Mariabackup will record that detail in the &lt;code&gt;&lt;a href=&quot;../files-created-by-mariabackup/index#xtrabackup_info&quot;&gt;xtrabackup_info&lt;/a&gt;&lt;/code&gt; file.</source>
          <target state="translated">백업이 &lt;a href=&quot;../incremental-backup-and-restore-with-mariabackup/index&quot;&gt;증분 백업&lt;/a&gt; 인 경우 Mariabackup은 &lt;code&gt;&lt;a href=&quot;../files-created-by-mariabackup/index#xtrabackup_info&quot;&gt;xtrabackup_info&lt;/a&gt;&lt;/code&gt; 파일 에 해당 세부 정보를 기록 합니다.</target>
        </trans-unit>
        <trans-unit id="7c264eaa7dd9f6c0dd56fe75827895c6f0e56e9c" translate="yes" xml:space="preserve">
          <source>If a backup is a &lt;a href=&quot;../partial-backup-and-restore-with-mariabackup/index&quot;&gt;partial backup&lt;/a&gt;, then Mariabackup will record that detail in the &lt;code&gt;&lt;a href=&quot;../files-created-by-mariabackup/index#xtrabackup_info&quot;&gt;xtrabackup_info&lt;/a&gt;&lt;/code&gt; file.</source>
          <target state="translated">백업이 &lt;a href=&quot;../partial-backup-and-restore-with-mariabackup/index&quot;&gt;부분 백업&lt;/a&gt; 인 경우 Mariabackup은 &lt;code&gt;&lt;a href=&quot;../files-created-by-mariabackup/index#xtrabackup_info&quot;&gt;xtrabackup_info&lt;/a&gt;&lt;/code&gt; 파일 에 해당 세부 정보를 기록 합니다.</target>
        </trans-unit>
        <trans-unit id="a23935c0b7200bb3e2b392c475207ded2a1a5aca" translate="yes" xml:space="preserve">
          <source>If a backup is compressed, then Mariabackup will record that detail in the &lt;code&gt;&lt;a href=&quot;../files-created-by-mariabackup/index#xtrabackup_info&quot;&gt;xtrabackup_info&lt;/a&gt;&lt;/code&gt; file.</source>
          <target state="translated">백업이 압축되면 Mariabackup은 &lt;code&gt;&lt;a href=&quot;../files-created-by-mariabackup/index#xtrabackup_info&quot;&gt;xtrabackup_info&lt;/a&gt;&lt;/code&gt; 파일에 세부 정보를 기록 합니다.</target>
        </trans-unit>
        <trans-unit id="4742cbceecb3f9340af5268a17aeae0a8d7da0e9" translate="yes" xml:space="preserve">
          <source>If a backup is streamed, then Mariabackup will record the format in the &lt;code&gt;&lt;a href=&quot;../files-created-by-mariabackup/index#xtrabackup_info&quot;&gt;xtrabackup_info&lt;/a&gt;&lt;/code&gt; file.</source>
          <target state="translated">백업이 스트리밍되면 Mariabackup은 &lt;code&gt;&lt;a href=&quot;../files-created-by-mariabackup/index#xtrabackup_info&quot;&gt;xtrabackup_info&lt;/a&gt;&lt;/code&gt; 파일에 형식을 기록 합니다.</target>
        </trans-unit>
        <trans-unit id="886ffec7f4b3d46ba08fe82a890249fd3c596dd2" translate="yes" xml:space="preserve">
          <source>If a checked table is corrupted, automatically fix it. Repairing will be done after all tables have been checked.</source>
          <target state="translated">확인 된 테이블이 손상된 경우 자동으로 수정하십시오. 모든 테이블을 확인한 후 복구가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="fbfb61f35c85dca8c8516c70e8ec44b126d5a089" translate="yes" xml:space="preserve">
          <source>If a client doesn't explicitly set the default client-side authentication plugin, then the client will determine which authentication plugin to use by checking the length of the scramble in the server's handshake packet.</source>
          <target state="translated">클라이언트가 기본 클라이언트 측 인증 플러그인을 명시 적으로 설정하지 않은 경우, 클라이언트는 서버의 핸드 셰이크 패킷에서 스크램블의 길이를 확인하여 사용할 인증 플러그인을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="4002c287b974496cd46b5e42470fa07417d67019" translate="yes" xml:space="preserve">
          <source>If a column has been set to ZEROFILL, all values will be prepended by zeros so that the BIGINT value contains a number of M digits.</source>
          <target state="translated">열이 ZEROFILL로 설정된 경우 BIGINT 값에 M 개의 숫자가 포함되도록 모든 값 앞에 0이 붙습니다.</target>
        </trans-unit>
        <trans-unit id="f715795436476cd84e1c502d40b074aeea6ce569" translate="yes" xml:space="preserve">
          <source>If a column has been set to ZEROFILL, all values will be prepended by zeros so that the SMALLINT value contains a number of M digits.</source>
          <target state="translated">열이 ZEROFILL로 설정된 경우 SMALLINT 값에 M 개의 숫자가 포함되도록 모든 값 앞에 0이 붙습니다.</target>
        </trans-unit>
        <trans-unit id="eb0c3fd124b73aacec33dbfbf903430cecc49d31" translate="yes" xml:space="preserve">
          <source>If a column is chosen to be stored on overflow pages, then the entire value of the column is stored on overflow pages, and only a 20-byte pointer to the column's first overflow page is stored on the main page. Each overflow page is the size of &lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_page_size&quot;&gt;innodb_page_size&lt;/a&gt;&lt;/code&gt;. If a column is too large to be stored on a single overflow page, then it is stored on multiple overflow pages. Each overflow page contains part of the data and a 20-byte pointer to the next overflow page, if a next page exists.</source>
          <target state="translated">열이 오버 플로우 페이지에 저장되도록 선택되면 열의 전체 값이 오버 플로우 페이지에 저장되고 열의 첫 번째 오버 플로우 페이지에 대한 20 바이트 포인터 만 기본 페이지에 저장됩니다. 각 오버 플로우 페이지는 &lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_page_size&quot;&gt;innodb_page_size&lt;/a&gt;&lt;/code&gt; 의 크기입니다 . 열이 너무 커서 단일 오버플로 페이지에 저장되지 않으면 여러 오버플로 페이지에 저장됩니다. 각 오버 플로우 페이지에는 다음 페이지가있는 경우 데이터의 일부와 다음 오버 플로우 페이지에 대한 20 바이트 포인터가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="c27f5ca23951881032d9f386a591fe6b1ed1341e" translate="yes" xml:space="preserve">
          <source>If a column is chosen to be stored on overflow pages, then the first 767 bytes of the column's value and a 20-byte pointer to the column's first overflow page are stored on the main page. Each overflow page is the size of &lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_page_size&quot;&gt;innodb_page_size&lt;/a&gt;&lt;/code&gt;. If a column is too large to be stored on a single overflow page, then it is stored on multiple overflow pages. Each overflow page contains part of the data and a 20-byte pointer to the next overflow page, if a next page exists.</source>
          <target state="translated">열이 오버 플로우 페이지에 저장되도록 선택되면 열 값의 첫 번째 767 바이트와 열의 첫 번째 오버 플로우 페이지에 대한 20 바이트 포인터가 기본 페이지에 저장됩니다. 각 오버 플로우 페이지는 &lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_page_size&quot;&gt;innodb_page_size&lt;/a&gt;&lt;/code&gt; 의 크기입니다 . 열이 너무 커서 단일 오버플로 페이지에 저장되지 않으면 여러 오버플로 페이지에 저장됩니다. 각 오버 플로우 페이지에는 다음 페이지가있는 경우 데이터의 일부와 다음 오버 플로우 페이지에 대한 20 바이트 포인터가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="fee03d833b28df1b010f2e5f9f1c47eef1dba8cf" translate="yes" xml:space="preserve">
          <source>If a column is dropped, old records will contain garbage in that column's former position, and new records will be written with &lt;code&gt;&lt;a href=&quot;../null-values/index&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; values, empty strings, or dummy values.</source>
          <target state="translated">열을 삭제하면 이전 레코드에 해당 열의 이전 위치에 가비지가 포함되고 새 레코드는 &lt;code&gt;&lt;a href=&quot;../null-values/index&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; 값, 빈 문자열 또는 더미 값으로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="6adc1cae054e50064961fe39f1f8f22d66ff8053" translate="yes" xml:space="preserve">
          <source>If a column uses the &lt;code&gt;DATETIME&lt;/code&gt; data type, then any inserted values are stored as-is, so no automatic time zone conversions are performed.</source>
          <target state="translated">열이 &lt;code&gt;DATETIME&lt;/code&gt; 데이터 유형을 사용하는 경우 삽입 된 값은 그대로 저장되므로 자동 시간대 변환이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5936e95e513a9d16b6335a2ba37fcf8e8b0ffbd7" translate="yes" xml:space="preserve">
          <source>If a column uses the &lt;code&gt;TIMESTAMP&lt;/code&gt; data type, then any inserted values are converted from the session's time zone to &lt;a href=&quot;../coordinated-universal-time/index&quot;&gt;Coordinated Universal Time (UTC)&lt;/a&gt; when stored, and converted back to the session's time zone when retrieved.</source>
          <target state="translated">열이 &lt;code&gt;TIMESTAMP&lt;/code&gt; 데이터 유형을 사용하는 경우, 삽입 될 때 삽입 된 값은 세션 시간대에서 &lt;a href=&quot;../coordinated-universal-time/index&quot;&gt;UTC (협정 세계시)&lt;/a&gt; 로 변환되고 검색 될 때 세션 시간대로 다시 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="8de95861e08be3fe934fd12ae70025dcf14bf2a6" translate="yes" xml:space="preserve">
          <source>If a composite query (such as &lt;code&gt;UNION&lt;/code&gt;, or query with derived tables or with subqueries) contains more than one &lt;code&gt;LIMIT ROWS EXAMINED&lt;/code&gt;, the last one parsed is taken into account. In this manner either the last or the outermost one is taken into account. For instance, in the query:</source>
          <target state="translated">복합 쿼리 (예 : &lt;code&gt;UNION&lt;/code&gt; 또는 파생 테이블 또는 하위 쿼리가있는 쿼리)에 둘 이상의 &lt;code&gt;LIMIT ROWS EXAMINED&lt;/code&gt; 가 포함 된 경우 구문 분석 된 마지막 쿼리 가 고려됩니다. 이러한 방식으로 마지막 또는 가장 바깥 쪽이 고려됩니다. 예를 들어, 쿼리에서 :</target>
        </trans-unit>
        <trans-unit id="d1655651355ca3203a953a12aff662e10a949227" translate="yes" xml:space="preserve">
          <source>If a condition consists of a number, it makes a condition with a subpattern reference. Such a condition is true if a capturing subpattern corresponding to the number has previously matched.</source>
          <target state="translated">조건이 숫자로 구성된 경우 하위 패턴 참조를 사용하여 조건을 만듭니다. 이러한 조건은 숫자에 해당하는 캡처 하위 패턴이 이전에 일치 한 경우에 해당됩니다.</target>
        </trans-unit>
        <trans-unit id="9ead350a2ee55992cb1c7adc883624d3f690931c" translate="yes" xml:space="preserve">
          <source>If a condition occurs for which no handler has been declared, the default action is &lt;code&gt;EXIT&lt;/code&gt;.</source>
          <target state="translated">핸들러가 선언되지 않은 조건이 발생하면 기본 조치는 &lt;code&gt;EXIT&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4515bc455c98cc6608f83d4b89bbbe70b5767125" translate="yes" xml:space="preserve">
          <source>If a connection is terminated that has an active transaction, the transaction will be rolled back. If only a query is killed, the current transaction will stay active. See also &lt;a href=&quot;../server-system-variables/index#idle_transaction_timeout&quot;&gt;idle_transaction_timeout&lt;/a&gt;.</source>
          <target state="translated">활성 트랜잭션이있는 연결이 종료되면 트랜잭션이 롤백됩니다. 쿼리 만 종료되면 현재 트랜잭션은 활성 상태를 유지합니다. &lt;a href=&quot;../server-system-variables/index#idle_transaction_timeout&quot;&gt;idle_transaction_timeout&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bcb4bd3a8a1929bbf0fe1cd2216ac0f5581e36a2" translate="yes" xml:space="preserve">
          <source>If a constant is compared to a TIMESTAMP or DATETIME, the constant is converted to a timestamp, unless used as an argument to the &lt;a href=&quot;../in/index&quot;&gt;IN&lt;/a&gt; function.</source>
          <target state="translated">상수가 TIMESTAMP 또는 DATETIME과 비교되면 &lt;a href=&quot;../in/index&quot;&gt;IN&lt;/a&gt; 함수 의 인수로 사용되지 않는 한 상수는 시간 소인으로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="f8687755fa85cf837f4695ae49b8a1a77e8cc391" translate="yes" xml:space="preserve">
          <source>If a derived table cannot be merged into its parent SELECT, it will be materialized in a temporary table, and then parent select will treat it as a regular base table.</source>
          <target state="translated">파생 테이블을 상위 SELECT에 병합 할 수없는 경우 임시 테이블에 구체화되고 상위 선택은 일반 기본 테이블로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="f65f076f2e8a5e56ff9fa5d3c39055d0622863ae" translate="yes" xml:space="preserve">
          <source>If a different result is desired, Create Table options are available to change the defaults used by Pivot. For instance if we want to display the average expense for each person and product, spread in columns for each week, use the following statement:</source>
          <target state="translated">다른 결과를 원하는 경우 테이블 만들기 옵션을 사용하여 피벗에서 사용하는 기본값을 변경할 수 있습니다. 예를 들어, 각 개인과 제품의 평균 비용을 매주 열 단위로 표시하려면 다음 설명을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="193df426e0bc1fafc24a69bd4fd2d2653b62b2c0" translate="yes" xml:space="preserve">
          <source>If a file-per-tablespace file contains columns that use one or more of these temporal data types and if the tablespace file's original table was created with a certain storage format for these columns, then the tablespace file can only be imported into tables that were also created with the same storage format for these columns as the original table. Otherwise, you will see errors like the following:</source>
          <target state="translated">테이블 당 파일 공간 파일에 이러한 임시 데이터 유형 중 하나 이상을 사용하는 열이 포함되어 있고 테이블 공간 파일의 원래 테이블이 이러한 열에 대한 특정 스토리지 형식으로 작성된 경우 테이블 공간 파일은 다음과 같은 테이블로만 가져올 수 있습니다. 이 열에 대해 원래 테이블과 동일한 스토리지 형식으로 작성되었습니다. 그렇지 않으면 다음과 같은 오류가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="d9e4067d61dcee5b716636cb17db50a3d986f477" translate="yes" xml:space="preserve">
          <source>If a file-per-tablespace file was created with a certain row format, then the tablespace file can only be imported into tables that were created with the same row format as the original table. Otherwise, you will see errors like the following:</source>
          <target state="translated">테이블 당 파일 공간 파일이 특정 행 형식으로 작성된 경우, 테이블 공간 파일은 원래 테이블과 동일한 행 형식으로 작성된 테이블로만 가져올 수 있습니다. 그렇지 않으면 다음과 같은 오류가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="3c09b58761a8f89611699523a33c62799de7c61a" translate="yes" xml:space="preserve">
          <source>If a foreign keys exists, each row in the child table must match a row in the parent table. Multiple child rows can match the same parent row. A child row &lt;em&gt;matches&lt;/em&gt; a parent row if all its foreign key values are identical to a parent row's values in the parent table. However, if at least one of the foreign key values is &lt;code&gt;NULL&lt;/code&gt;, the row has no parents, but it is still allowed.</source>
          <target state="translated">외래 키가 존재하면 자식 테이블의 각 행이 부모 테이블의 행과 일치해야합니다. 여러 자식 행이 동일한 부모 행과 일치 할 수 있습니다. 외래 키 값이 모두 부모 테이블의 부모 행 값과 동일하면 자식 행 이 부모 행 &lt;em&gt;과 일치&lt;/em&gt; 합니다. 그러나 외래 키 값 중 하나 이상이 &lt;code&gt;NULL&lt;/code&gt; 이면 행에 부모가 없지만 여전히 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="de280be6f98a0d152efd8a6e9a75668ddfbd07d4" translate="yes" xml:space="preserve">
          <source>If a hexadecimal argument is not compared to a number, it is treated as a binary string.</source>
          <target state="translated">16 진 인수를 숫자와 비교하지 않으면 2 진 문자열로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="8d3df5604675897662d74a6d787236fe3bd44616" translate="yes" xml:space="preserve">
          <source>If a join buffer is used for a simple left outer join of tables t1 and t1 t1 LEFT JOIN t2 ON P(t1,t2) then each record r1 stored in the buffer is provided with a match flag. Initially this flag is set off. As soon as the first match for r1 is found this flag is set on. When all matching candidates from t2 have been check, the record the join buffer are scanned and for those of them that still have there match flags off null-complemented rows are generated. The same match flag is used for any record in the join buffer is a semi-join operation t1 SEMI JOIN t2 ON P(t1,t2) is performed with a block based join algorithm. When this match flag is set to on for a record r1 in the buffer no matches from table t2 for record r1 are looked for anymore.</source>
          <target state="translated">조인 버퍼가 테이블 t1 및 t1의 간단한 왼쪽 외부 조인에 사용되는 경우 t1 t1 LEFT JOIN t2 ON P (t1, t2) 버퍼에 저장된 각 레코드 r1에 일치 플래그가 제공됩니다. 처음에는이 플래그가 설정되어 있습니다. r1에 대한 첫 번째 일치가 발견되면이 플래그가 설정됩니다. t2의 모든 일치하는 후보가 검사되면 결합 버퍼를 스캔하고 널로 보완 된 행과 일치하는 플래그가있는 후보의 레코드가 생성됩니다. 결합 버퍼의 모든 레코드에 동일한 일치 플래그가 사용됩니다. semi-join 연산 t1 SEMI JOIN t2 ON P (t1, t2)는 블록 기반 결합 알고리즘으로 수행됩니다. 이 일치 플래그가 버퍼의 레코드 r1에 대해 설정되면, 레코드 r1에 대한 테이블 t2에서 더 이상 일치하는 것이 없습니다.</target>
        </trans-unit>
        <trans-unit id="e87a5d69dacc95452dd031699d3c146bc99342e8" translate="yes" xml:space="preserve">
          <source>If a listed table is a view, an error like the following will be produced:</source>
          <target state="translated">나열된 테이블이 뷰인 경우 다음과 같은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7b0c1818c3588b2babde464671905e604053f1d6" translate="yes" xml:space="preserve">
          <source>If a more complex definition is desired, you can ask CONNECT to analyse the XPATH up to a given level using the level option in the option list. The level value is the number of nodes that are taken in the XPATH. For instance:</source>
          <target state="translated">보다 복잡한 정의가 필요한 경우 옵션 목록의 레벨 옵션을 사용하여 CONNECT에 지정된 레벨까지 XPATH를 분석하도록 요청할 수 있습니다. 레벨 값은 XPATH에서 가져온 노드 수입니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="074fc5f84e86a18de5307364fe3017fe6a234e39" translate="yes" xml:space="preserve">
          <source>If a more complex definition is desired, you can ask CONNECT to analyze the JPATH up to a given level using the level option in the option list. The level value is the number of sub-objects that are taken in the JPATH. For instance:</source>
          <target state="translated">보다 복잡한 정의가 필요한 경우 옵션 목록의 레벨 옵션을 사용하여 CONNECT에 지정된 레벨까지 JPATH를 분석하도록 요청할 수 있습니다. 레벨 값은 JPATH에서 가져온 하위 오브젝트의 수입니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="67423baf8c7aff8900d14368533dce51f059b10c" translate="yes" xml:space="preserve">
          <source>If a name was provided by the &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-history&quot;&gt;--history&lt;/a&gt;&lt;/code&gt; or the &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-incremental-history-name&quot;&gt;---incremental-history-name&lt;/a&gt;&lt;/code&gt; options, then it will be saved here. Otherwise, this will be the empty string.</source>
          <target state="translated">이름이 제공된 경우 &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-history&quot;&gt;--history&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-incremental-history-name&quot;&gt;---incremental-history-name&lt;/a&gt;&lt;/code&gt; 옵션, 다음 여기에 저장됩니다. 그렇지 않으면 빈 문자열이됩니다.</target>
        </trans-unit>
        <trans-unit id="534ac3d8c4fdbd99f4e595887a09824deeceefbf" translate="yes" xml:space="preserve">
          <source>If a new module has been added or if a module was previously disable, use this command to enable the module. The command alterSystem-EnableModule will restart the system as part of its functionality to bring the new module into use. So there will be some down time during this process.</source>
          <target state="translated">새 모듈이 추가되었거나 모듈이 이전에 비활성화 된 경우이 명령을 사용하여 모듈을 활성화하십시오. alterSystem-EnableModule 명령은 새 모듈을 사용하기 위해 기능의 일부로 시스템을 다시 시작합니다. 따라서이 프로세스 중에 가동 중지 시간이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f382017b908e2343d48c3a8007eaaa4e63c4fa9d" translate="yes" xml:space="preserve">
          <source>If a node has only been out of a cluster for a little while, then an IST is generally faster than an SST.</source>
          <target state="translated">노드가 잠시 동안 클러스터에서 벗어난 경우 IST는 일반적으로 SST보다 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="6091e0d25af56650e9cd78e5b90ad685d217d7c5" translate="yes" xml:space="preserve">
          <source>If a non-deterministic function is used for a &lt;code&gt;PERSISTENT&lt;/code&gt; generated column, then any changes made to this table should be logged to the &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt; in the &lt;a href=&quot;../binary-log-formats/index#row-based-logging&quot;&gt;row-based logging format&lt;/a&gt; when the &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-system-variables/index#binlog_format&quot;&gt;binlog_format&lt;/a&gt;&lt;/code&gt; system variable is set to &lt;code&gt;MIXED&lt;/code&gt;. However, this does not always happen. Therefore, it is recommended to set the &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-system-variables/index#binlog_format&quot;&gt;binlog_format&lt;/a&gt;&lt;/code&gt; system variable to &lt;code&gt;ROW&lt;/code&gt;. See &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-10436&quot;&gt;MDEV-10436&lt;/a&gt; for more information.</source>
          <target state="translated">결정적이지 않은 함수가 &lt;code&gt;PERSISTENT&lt;/code&gt; 생성 열에 사용되는 경우 &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-system-variables/index#binlog_format&quot;&gt;binlog_format&lt;/a&gt;&lt;/code&gt; 시스템 변수가 &lt;code&gt;MIXED&lt;/code&gt; 로 설정 되면 이 테이블에 대한 모든 변경 사항이 &lt;a href=&quot;../binary-log-formats/index#row-based-logging&quot;&gt;행 기반 로깅 형식으로 &lt;/a&gt;&lt;a href=&quot;../binary-log/index&quot;&gt;2 진 로그&lt;/a&gt; 에 로그 되어야합니다 . 그러나 항상 그런 것은 아닙니다. 따라서 &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-system-variables/index#binlog_format&quot;&gt;binlog_format&lt;/a&gt;&lt;/code&gt; 시스템 변수를 &lt;code&gt;ROW&lt;/code&gt; 로 설정하는 것이 좋습니다 . 자세한 내용은 &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-10436&quot;&gt;MDEV-10436&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3ab6c7c6d6061102fdb5a597c0c7d4a1dc124b1c" translate="yes" xml:space="preserve">
          <source>If a plugin is installed with one of these options, then a record will &lt;strong&gt;not&lt;/strong&gt; be added to the &lt;code&gt;&lt;a href=&quot;../mysqlplugin-table/index&quot;&gt;mysql.plugins&lt;/a&gt;&lt;/code&gt; table for the plugin. This means that if the server is restarted without the same option set, then the plugin will &lt;strong&gt;not&lt;/strong&gt; automatically be loaded.</source>
          <target state="translated">이러한 옵션 중 하나를 사용하여 플러그인을 설치하면 플러그인 의 &lt;code&gt;&lt;a href=&quot;../mysqlplugin-table/index&quot;&gt;mysql.plugins&lt;/a&gt;&lt;/code&gt; 테이블에 레코드가 추가 &lt;strong&gt;되지 않습니다&lt;/strong&gt; . 즉, 동일한 옵션을 설정하지 않고 서버를 다시 시작하면 플러그인이 자동으로로드 &lt;strong&gt;되지 않습니다&lt;/strong&gt; .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2a4a5bc75dbe9897c12ee3712af0ec4a29d75173" translate="yes" xml:space="preserve">
          <source>If a plugin is installed with one of these statements, then a record will be added to the &lt;code&gt;&lt;a href=&quot;../mysqlplugin-table/index&quot;&gt;mysql.plugins&lt;/a&gt;&lt;/code&gt; table for the plugin. This means that the plugin will automatically be loaded every time the server restarts, unless specifically uninstalled or deactivated.</source>
          <target state="translated">이러한 명령문 중 하나를 사용하여 플러그인을 설치하면 플러그인의 &lt;code&gt;&lt;a href=&quot;../mysqlplugin-table/index&quot;&gt;mysql.plugins&lt;/a&gt;&lt;/code&gt; 테이블에 레코드가 추가됩니다 . 이는 특별히 제거하거나 비활성화하지 않는 한 서버를 다시 시작할 때마다 플러그인이 자동으로로드됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="9d6bd8d0249e54508995bd11e73d7fe587216edc" translate="yes" xml:space="preserve">
          <source>If a plugin is installed with this utility, then a record will be added to the &lt;code&gt;&lt;a href=&quot;../mysqlplugin-table/index&quot;&gt;mysql.plugins&lt;/a&gt;&lt;/code&gt; table for the plugin. This means that the plugin will automatically be loaded every time the server restarts, unless specifically uninstalled or deactivated.</source>
          <target state="translated">이 유틸리티를 사용하여 플러그인을 설치하면 플러그인의 &lt;code&gt;&lt;a href=&quot;../mysqlplugin-table/index&quot;&gt;mysql.plugins&lt;/a&gt;&lt;/code&gt; 테이블에 레코드가 추가됩니다 . 이는 특별히 제거하거나 비활성화하지 않는 한 서버를 다시 시작할 때마다 플러그인이 자동으로로드됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="715074959abbe5372cea35b3c71f91862b3d7ac6" translate="yes" xml:space="preserve">
          <source>If a plugin's &lt;code&gt;Library&lt;/code&gt; column has the &lt;code&gt;NULL&lt;/code&gt; value, then the plugin is built-in, and it cannot be uninstalled.</source>
          <target state="translated">플러그인의 &lt;code&gt;Library&lt;/code&gt; 열에 &lt;code&gt;NULL&lt;/code&gt; 값 이 있으면 플러그인이 내장되어 있으며 제거 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1020beb86d948c5c1ebf542c91bd5e8b4c8bead4" translate="yes" xml:space="preserve">
          <source>If a plugin's &lt;code&gt;PLUGIN_LIBRARY&lt;/code&gt; column has the &lt;code&gt;NULL&lt;/code&gt; value, then the plugin is built-in, and it cannot be uninstalled.</source>
          <target state="translated">플러그인의 &lt;code&gt;PLUGIN_LIBRARY&lt;/code&gt; 열에 &lt;code&gt;NULL&lt;/code&gt; 값 이 있으면 플러그인이 내장되어 있으며 제거 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6cf24ebadd38f26d295f2a33308dae6fd531696b" translate="yes" xml:space="preserve">
          <source>If a prepared statement with the given name already exists, it is deallocated implicitly before the new statement is prepared. This means that if the new statement contains an error and cannot be prepared, an error is returned and no statement with the given name exists.</source>
          <target state="translated">주어진 이름의 준비된 명령문이 이미 존재하면 새 명령문이 준비되기 전에 암시 적으로 할당이 해제됩니다. 이는 새 명령문에 오류가 있고 준비 할 수없는 경우 오류가 리턴되고 지정된 이름의 명령문이 존재하지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="ed9dc4402418885a0c73c21a269efcd5077183a1" translate="yes" xml:space="preserve">
          <source>If a property is specified more than once, an error like this will be produced:</source>
          <target state="translated">속성이 두 번 이상 지정되면 다음과 같은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c4dd03175c4b51943d68f68eb134215f89518329" translate="yes" xml:space="preserve">
          <source>If a qualifier is composed by more than one identifier, a dot (.) must be used as a separator. All identifiers can be quoted individually. Extra spacing (including new lines and tabs) is allowed.</source>
          <target state="translated">한정자가 둘 이상의 식별자로 구성된 경우 점 (.)을 구분 기호로 사용해야합니다. 모든 식별자는 개별적으로 인용 할 수 있습니다. 추가 간격 (줄 바꾸기 및 탭 포함)이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="ba0775a6d5808f20da7de3a7c7ae36cd047223a5" translate="yes" xml:space="preserve">
          <source>If a query does not involve the &quot;multiple&quot; column, no row multiplication will be done. For instance:</source>
          <target state="translated">쿼리에 &quot;다중&quot;열이 포함되어 있지 않으면 행 곱셈이 수행되지 않습니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="f7d9d2732823ea06c2733fbbff8f95e7457aa149" translate="yes" xml:space="preserve">
          <source>If a query is &lt;code&gt;&lt;a href=&quot;../explain/index&quot;&gt;EXPLAIN&lt;/a&gt;&lt;/code&gt;-ed.</source>
          <target state="translated">쿼리가 &lt;code&gt;&lt;a href=&quot;../explain/index&quot;&gt;EXPLAIN&lt;/a&gt;&lt;/code&gt; -ed 인 경우</target>
        </trans-unit>
        <trans-unit id="3f0df7bb69b67a9b8dd392d42512cc4a19e29503" translate="yes" xml:space="preserve">
          <source>If a query uses a derived table (or a view), the first action that the que...</source>
          <target state="translated">쿼리가 파생 테이블 (또는 뷰)을 사용하는 경우 쿼리가 수행 한 첫 번째 작업은</target>
        </trans-unit>
        <trans-unit id="d8c9caf8c792d1eb2edf3747b0b19f807b598ccb" translate="yes" xml:space="preserve">
          <source>If a query uses a derived table (or a view), the first action that the query optimizer will attempt is to apply the &lt;a href=&quot;../derived-table-merge-optimization/index&quot;&gt;derived-table-merge-optimization&lt;/a&gt; and merge the derived table into its parent select. However, that optimization is only applicable when the select inside the derived table has a join as the top-level operation. If it has a &lt;a href=&quot;../group-by/index&quot;&gt;GROUP-BY&lt;/a&gt;, &lt;a href=&quot;../select/index#distinct&quot;&gt;DISTINCT&lt;/a&gt;, or uses &lt;a href=&quot;../window-functions/index&quot;&gt;window functions&lt;/a&gt;, then &lt;a href=&quot;../derived-table-merge-optimization/index&quot;&gt;derived-table-merge-optimization&lt;/a&gt; is not applicable.</source>
          <target state="translated">쿼리에서 파생 테이블 (또는 뷰)을 사용하는 경우 쿼리 최적화 프로그램에서 가장 먼저 시도 할 작업은 파생 테이블 병합 &lt;a href=&quot;../derived-table-merge-optimization/index&quot;&gt;최적화&lt;/a&gt; 를 적용 하고 파생 테이블을 부모 선택에 병합하는 것입니다. 그러나이 최적화는 파생 테이블 내부의 선택에 최상위 작업으로 조인이있는 경우에만 적용 할 수 있습니다. 그것은이있는 경우 &lt;a href=&quot;../group-by/index&quot;&gt;GROUP-BY를&lt;/a&gt; , &lt;a href=&quot;../select/index#distinct&quot;&gt;DISTINCT&lt;/a&gt; , 또는 용도의 &lt;a href=&quot;../window-functions/index&quot;&gt;윈도우 함수는&lt;/a&gt; 다음 &lt;a href=&quot;../derived-table-merge-optimization/index&quot;&gt;파생 테이블 병합 최적화가&lt;/a&gt; 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8356a188f87dc3975e3d660a3fd4fb79a8843ccf" translate="yes" xml:space="preserve">
          <source>If a role that doesn't exist, or to which the user has not been assigned, is specified, an &lt;code&gt;ERROR 1959 (OP000): Invalid role specification&lt;/code&gt; error occurs.</source>
          <target state="translated">존재하지 않거나 사용자에게 할당되지 않은 역할이 지정되면 &lt;code&gt;ERROR 1959 (OP000): Invalid role specification&lt;/code&gt; 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="91251e6fb9d97e2133c16d0fb096a58592843882" translate="yes" xml:space="preserve">
          <source>If a row in the table matches a new foreground thread's client and host, the matching &lt;code&gt;INSTRUMENTED&lt;/code&gt; column in the &lt;a href=&quot;../performance-schema-threads-table/index&quot;&gt;threads&lt;/a&gt; table is set to either &lt;code&gt;YES&lt;/code&gt; or &lt;code&gt;NO&lt;/code&gt;, which allows selective application of instrumenting by host, by user, or combination thereof.</source>
          <target state="translated">테이블의 행이 새로운 포 그라운드 스레드의 클라이언트 및 호스트와 일치하는 경우, &lt;a href=&quot;../performance-schema-threads-table/index&quot;&gt;스레드&lt;/a&gt; 테이블 의 일치하는 &lt;code&gt;INSTRUMENTED&lt;/code&gt; 컬럼은 &lt;code&gt;YES&lt;/code&gt; 또는 &lt;code&gt;NO&lt;/code&gt; 로 설정 되어 호스트, 사용자 또는 이들의 조합에 의해 계측을 선택적으로 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3822a662d8a3518834f5cdc2f1916f407cf13f65" translate="yes" xml:space="preserve">
          <source>If a row is rejected because of the CHECK OPTION, an error similar to the following is produced:</source>
          <target state="translated">CHECK OPTION으로 인해 행이 거부되면 다음과 유사한 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0191d410233505c425780c297c4f32ea73b683ed" translate="yes" xml:space="preserve">
          <source>If a row with the &lt;a href=&quot;../group-by/index&quot;&gt;GROUP BY&lt;/a&gt; key exists in the temporary table, add the new result row to it. If not, create a new row.</source>
          <target state="translated">있는 행하면 &lt;a href=&quot;../group-by/index&quot;&gt;BY GROUP&lt;/a&gt; 키가 임시 테이블에 존재하는, 그것에 새로운 결과 행을 추가합니다. 그렇지 않은 경우 새 행을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="a9ab713707cdc7bed6531bd17820b63545ccfc11" translate="yes" xml:space="preserve">
          <source>If a row's last &lt;a href=&quot;../innodb-undo-log/index&quot;&gt;InnoDB undo log&lt;/a&gt; record is purged, this can obviously effect the value of the row's &lt;code&gt;DB_ROLL_PTR&lt;/code&gt; column, because there would no longer be any &lt;a href=&quot;../innodb-undo-log/index&quot;&gt;InnoDB undo log&lt;/a&gt; record for the pointer to reference.</source>
          <target state="translated">행의 마지막 &lt;a href=&quot;../innodb-undo-log/index&quot;&gt;InnoDB 실행 취소 로그&lt;/a&gt; 레코드가 제거되면 더 이상 참조 포인터에 대한 &lt;a href=&quot;../innodb-undo-log/index&quot;&gt;InnoDB 실행 취소 로그&lt;/a&gt; 레코드 가 없으므로 행의 &lt;code&gt;DB_ROLL_PTR&lt;/code&gt; 열 값에 영향을 줄 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="057442ee770b428704690e62c650ec07c2bc01e2" translate="yes" xml:space="preserve">
          <source>If a search string matches multiple items, MariaDB shows a list of matching topics:</source>
          <target state="translated">검색 문자열이 여러 항목과 일치하면 MariaDB는 일치하는 주제 목록을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="f5243c9ced06d2abd3bf048edb5d29da34d82e1f" translate="yes" xml:space="preserve">
          <source>If a secondary index is bigger than can be cached in RAM, and if the column(s) being indexed is random, then each row inserted may cause a disk hit to update the index. This limits insert speed to something like 100 rows per second (on ordinary disks). Multiple random indexes slow down insertion further. RAID striping and/or SSDs speed up insertion. Write caching helps, but only for bursts.</source>
          <target state="translated">보조 인덱스가 RAM에 캐시 될 수있는 것보다 큰 경우, 인덱스되는 열이 무작위 인 경우 삽입 된 각 행으로 인해 디스크 적중으로 인해 인덱스가 업데이트 될 수 있습니다. 이렇게하면 삽입 속도가 초당 100 행 (일반 디스크)으로 제한됩니다. 여러 개의 임의 인덱스는 삽입 속도를 늦 춥니 다. RAID 스트라이핑 및 / 또는 SSD는 삽입 속도를 높입니다. 쓰기 캐싱은 버스트에만 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="4631a02ae8cd0c06ce02f75ebd554cbde8687d35" translate="yes" xml:space="preserve">
          <source>If a sent command causes warnings to be issued, it is useless to resend a &amp;ldquo;show warnings&amp;rdquo; command because the MariaDB server is opened and closed when sending commands. Therefore, getting warnings requires a specific (and tricky) way.</source>
          <target state="translated">전송 된 명령으로 경고가 발행되는 경우 명령을 보낼 때 MariaDB 서버가 열리고 닫히므로 &quot;show warnings&quot;명령을 다시 보내는 것은 쓸모가 없습니다. 따라서 경고를 받으려면 구체적이고 까다로운 방법이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ac9e4b398a650b0b09eb0bb08fc47416a098493c" translate="yes" xml:space="preserve">
          <source>If a server has the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#lc_messages&quot;&gt;lc_messages&lt;/a&gt;&lt;/code&gt; system variable set to the &lt;code&gt;fr_CA&lt;/code&gt; locale like the above example, then error messages would be in French. For example:</source>
          <target state="translated">서버에 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#lc_messages&quot;&gt;lc_messages&lt;/a&gt;&lt;/code&gt; 시스템 변수 가 위의 예와 같이 &lt;code&gt;fr_CA&lt;/code&gt; 로케일로 설정되어 있으면 오류 메시지가 프랑스어로 표시됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ddea9bf9809addb457c3c6797043a966994aaa3d" translate="yes" xml:space="preserve">
          <source>If a server needs to be able to switch between acting as a master and a slave, then you can enable both the master and slave system variables on the server. For example, you might need to do this if &lt;a href=&quot;../maxscale/index&quot;&gt;MariaDB MaxScale&lt;/a&gt; is being used to enable &lt;a href=&quot;../mariadb-maxscale-23-mariadb-monitor/index#cluster-manipulation-operations&quot;&gt;auto-failover or switchover&lt;/a&gt; with &lt;a href=&quot;../mariadb-maxscale-23-mariadb-monitor/index&quot;&gt;MariaDB Monitor&lt;/a&gt;.</source>
          <target state="translated">서버가 마스터와 슬레이브로 작동하는 사이를 전환 할 수 있어야하는 경우 서버에서 마스터 및 슬레이브 시스템 변수를 모두 사용할 수 있습니다. 예를 들어 &lt;a href=&quot;../maxscale/index&quot;&gt;MariaDB MaxScale&lt;/a&gt; 을 사용 하여 &lt;a href=&quot;../mariadb-maxscale-23-mariadb-monitor/index&quot;&gt;MariaDB Monitor로 &lt;/a&gt;&lt;a href=&quot;../mariadb-maxscale-23-mariadb-monitor/index#cluster-manipulation-operations&quot;&gt;자동 장애 조치 또는 전환&lt;/a&gt; 을 활성화하는 경우이 작업을 수행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1aba5bcb2552468fff32d6509a31f8646cfdb52a" translate="yes" xml:space="preserve">
          <source>If a service principal name is not provided, then the plugin will try to use &lt;code&gt;mariadb/host.domain.com@REALM&lt;/code&gt; by default.</source>
          <target state="translated">서비스 사용자 이름이 제공되지 않으면 플러그인은 기본적으로 &lt;code&gt;mariadb/host.domain.com@REALM&lt;/code&gt; 을 사용하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="eaa3f1477c73c800324aa8df9f8167647e3b3fca" translate="yes" xml:space="preserve">
          <source>If a situation as described above exists when you try to install MariaDB you will get an error like this:</source>
          <target state="translated">MariaDB를 설치하려고 할 때 위에서 설명한 상황이 존재하면 다음과 같은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="85e75638098dbf842d76d4854cce4f2ac6694b1c" translate="yes" xml:space="preserve">
          <source>If a slave is active but has yet to read from a binary log file you attempt to delete, the statement will fail with an error. However, if the slave is not connected and has yet to read from a log file you delete, the file will be deleted, but the slave will be unable to continue replicating once it connects again.</source>
          <target state="translated">슬레이브가 활성 상태이지만 아직 이진 로그 파일에서 읽지 않은 경우 삭제하려고하면 명령문이 실패합니다. 그러나 슬레이브가 연결되어 있지 않고 삭제 한 로그 파일에서 아직 읽지 않으면 파일이 삭제되지만 다시 연결되면 슬레이브는 계속 복제 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4ba16c04348c74a26a4dd4aab784aabd5dde67b9" translate="yes" xml:space="preserve">
          <source>If a slave is configured with the binlog disabled, &lt;code&gt;current_pos&lt;/code&gt; and &lt;code&gt;slave_pos&lt;/code&gt; are equivalent.</source>
          <target state="translated">binlog를 비활성화 한 상태에서 슬레이브를 구성하면 &lt;code&gt;current_pos&lt;/code&gt; 와 &lt;code&gt;slave_pos&lt;/code&gt; 가 같습니다.</target>
        </trans-unit>
        <trans-unit id="a0d03216a1fb2deefaf34293632c4a9a41708c50" translate="yes" xml:space="preserve">
          <source>If a slave server tries to replicate a GTID with a sequence number lower than what is already in the binlog for that replication domain, the SQL thread stops with an error (this indicates an extra transaction in the slave binlog not present on the master).</source>
          <target state="translated">슬레이브 서버가 해당 복제 도메인의 binlog에 이미있는 것보다 시퀀스 번호가 낮은 GTID를 복제하려고하면 SQL 스레드가 오류와 함께 중지됩니다 (이는 슬레이브 binlog에 마스터에없는 추가 트랜잭션을 나타냄).</target>
        </trans-unit>
        <trans-unit id="c7692d97908b31a7c830ea641300be8374fae17c" translate="yes" xml:space="preserve">
          <source>If a statement may potentially have an effect, but doesn't, such as an UPDATE or DELETE that returns no rows, it will still be logged (this applies to the default statement-based logging, not to row-based logging - see &lt;a href=&quot;../binary-log-formats/index&quot;&gt;Binary Log Formats&lt;/a&gt;).</source>
          <target state="translated">명령문이 잠재적으로 영향을 줄 수 있지만 행을 리턴하지 않는 UPDATE 또는 DELETE와 같이 영향을 미치지 않는 경우 여전히 로그됩니다 (이것은 행 기반 로깅이 아닌 기본 명령문 기반 로깅에 적용됨- &lt;a href=&quot;../binary-log-formats/index&quot;&gt;이진&lt;/a&gt; 참조). 로그 형식 ).</target>
        </trans-unit>
        <trans-unit id="13d9072aad0c6e04d73edc3a993bd357e32c8104" translate="yes" xml:space="preserve">
          <source>If a statement uses all the columns of a unique index to search for unique row, gap locking is not used.</source>
          <target state="translated">명령문이 고유 인덱스의 모든 컬럼을 사용하여 고유 행을 검색하는 경우 간격 잠금이 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b96982d5bba50bb7635998ea2e70e67a8aeee5f2" translate="yes" xml:space="preserve">
          <source>If a storage engine does not support &lt;code&gt;FLUSH TABLES FOR EXPORT&lt;/code&gt;, a 1031 error (&lt;a href=&quot;../sqlstate/index&quot;&gt;SQLSTATE&lt;/a&gt; 'HY000') is produced.</source>
          <target state="translated">스토리지 엔진이 &lt;code&gt;FLUSH TABLES FOR EXPORT&lt;/code&gt; 를 지원하지 않으면 1031 오류 ( &lt;a href=&quot;../sqlstate/index&quot;&gt;SQLSTATE&lt;/a&gt; 'HY000')가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="aa9a059701f32344f287565e4c4ba5d9a5a36fe6" translate="yes" xml:space="preserve">
          <source>If a string argument is added, it specifies the Json path to the array to be modified. For instance:</source>
          <target state="translated">문자열 인수가 추가되면 수정할 배열의 Json 경로를 지정합니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="492fac47021201a25b1c4aca39dc115c63df144a" translate="yes" xml:space="preserve">
          <source>If a subquery is used in this way, you must also use an AS clause to name the result of the subquery.</source>
          <target state="translated">서브 쿼리가 이런 식으로 사용되면 AS 절을 사용하여 서브 쿼리 결과의 이름을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="b1aba4ca6793610411b3cb5b6cb782b4ffb74700" translate="yes" xml:space="preserve">
          <source>If a table does not exist, an error like the following will be produced:</source>
          <target state="translated">테이블이 존재하지 않으면 다음과 같은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="856417f6c789a2fb957701919f474303cda3646b" translate="yes" xml:space="preserve">
          <source>If a table exists when the backup starts, but it is dropped before the backup copies it, then the tablespace file can't be copied, so the backup would fail.</source>
          <target state="translated">백업이 시작될 때 테이블이 존재하지만 백업이 복사하기 전에 테이블이 삭제되면 테이블 스페이스 파일을 복사 할 수 없으므로 백업이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="307df633401f91806b70682c1066e9e4564f3cec" translate="yes" xml:space="preserve">
          <source>If a table has a &lt;code&gt;&lt;a href=&quot;../full-text-indexes/index&quot;&gt;FULLTEXT&lt;/a&gt;&lt;/code&gt; index, then it cannot be rebuilt by any &lt;code&gt;&lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt;&lt;/code&gt; operations when the &lt;code&gt;&lt;a href=&quot;../alter-table/index#lock&quot;&gt;LOCK&lt;/a&gt;&lt;/code&gt; clause is set to &lt;code&gt;NONE&lt;/code&gt;.</source>
          <target state="translated">테이블에 &lt;code&gt;&lt;a href=&quot;../full-text-indexes/index&quot;&gt;FULLTEXT&lt;/a&gt;&lt;/code&gt; 인덱스 가있는 경우 &lt;code&gt;&lt;a href=&quot;../alter-table/index#lock&quot;&gt;LOCK&lt;/a&gt;&lt;/code&gt; 절이 &lt;code&gt;NONE&lt;/code&gt; 으로 설정 되면 &lt;code&gt;&lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt;&lt;/code&gt; 조작으로 테이블을 재 빌드 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c07b0123cbc0683350e294c2d1e13932fa2aaaa0" translate="yes" xml:space="preserve">
          <source>If a table has a &lt;code&gt;&lt;a href=&quot;../spatial-index/index&quot;&gt;SPATIAL&lt;/a&gt;&lt;/code&gt; index, then it cannot be rebuilt by any &lt;code&gt;&lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt;&lt;/code&gt; operations when the &lt;code&gt;&lt;a href=&quot;../alter-table/index#lock&quot;&gt;LOCK&lt;/a&gt;&lt;/code&gt; clause is set to &lt;code&gt;NONE&lt;/code&gt;.</source>
          <target state="translated">테이블에 &lt;code&gt;&lt;a href=&quot;../spatial-index/index&quot;&gt;SPATIAL&lt;/a&gt;&lt;/code&gt; 인덱스가 있으면 &lt;code&gt;&lt;a href=&quot;../alter-table/index#lock&quot;&gt;LOCK&lt;/a&gt;&lt;/code&gt; 절이 &lt;code&gt;NONE&lt;/code&gt; 으로 설정된 경우 &lt;code&gt;&lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt;&lt;/code&gt; 조작으로 테이블을 재 빌드 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="5196f7871c68d6cc68abb32468bf29ac236191d9" translate="yes" xml:space="preserve">
          <source>If a table has more than one &lt;code&gt;&lt;a href=&quot;../full-text-indexes/index&quot;&gt;FULLTEXT&lt;/a&gt;&lt;/code&gt; index, then it cannot be rebuilt by any &lt;code&gt;&lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt;&lt;/code&gt; operations when &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; is set to &lt;code&gt;INPLACE&lt;/code&gt;.</source>
          <target state="translated">테이블에 둘 이상의 &lt;code&gt;&lt;a href=&quot;../full-text-indexes/index&quot;&gt;FULLTEXT&lt;/a&gt;&lt;/code&gt; 인덱스 가 있으면 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 이 &lt;code&gt;INPLACE&lt;/code&gt; 로 설정된 경우 &lt;code&gt;&lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt;&lt;/code&gt; 조작으로 테이블을 재 빌드 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="36c3a740ccc51e36730233ecee821c9b8af2daba" translate="yes" xml:space="preserve">
          <source>If a table identifier is prefixed with a dot (.), the default database is assumed. This syntax is supported for ODBC compliance, but has no practical effect on MariaDB. These qualifiers are equivalent:</source>
          <target state="translated">테이블 식별자 앞에 점 (.)이 있으면 기본 데이터베이스가 사용됩니다. 이 구문은 ODBC 호환을 위해 지원되지만 MariaDB에는 실질적인 영향을 미치지 않습니다. 이 한정자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="47c9f1215ae3a21edc9931265818b756781ac491" translate="yes" xml:space="preserve">
          <source>If a table is a view, an error like the following will be produced:</source>
          <target state="translated">테이블이 뷰인 경우 다음과 같은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4ddd8b4ba9127aa8c85ad73cc4199f75e3022c55" translate="yes" xml:space="preserve">
          <source>If a table is based on only one zip file containing several entries, this will be indicated by placing the &amp;lsquo;%s&amp;rsquo; part in the entry option value.</source>
          <target state="translated">테이블이 여러 항목을 포함하는 하나의 zip 파일만을 기반으로하는 경우 항목 옵션 값에 '% s'부분을 배치하여 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="a0df61e53e188b8ca7ba1952116bf19a49313232" translate="yes" xml:space="preserve">
          <source>If a table is based on several zipped files, portioning is done the standard way as above. This is the &lt;em&gt;file_name&lt;/em&gt; option specifying the name of the zip files that shall contain the &amp;lsquo;%s&amp;rsquo; part used to generate the file names.</source>
          <target state="translated">테이블이 여러 압축 파일을 기반으로하는 경우 분할은 위와 같은 표준 방식으로 수행됩니다. 파일 이름을 생성하는 데 사용되는 '% s'부분을 포함 할 zip 파일의 이름을 지정 하는 &lt;em&gt;file_name&lt;/em&gt; 옵션입니다.</target>
        </trans-unit>
        <trans-unit id="02b78f56ce3d433649172a5ee96f2c44bdab57f0" translate="yes" xml:space="preserve">
          <source>If a table is created during the backup, then it might not exist in the backup after prepare.</source>
          <target state="translated">백업 중에 테이블이 작성되면 준비 후 백업에 존재하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ea6c3d8ba174df9803f603ac497511abb75a9a9" translate="yes" xml:space="preserve">
          <source>If a table is dropped and created under the same name during the backup after the tablespace file was copied, then the table will have the wrong tablespace ID when the backup is prepared.</source>
          <target state="translated">테이블 스페이스 파일을 복사 한 후 백업 중에 동일한 이름으로 테이블을 삭제하고 작성하면 백업 준비시 테이블에 잘못된 테이블 스페이스 ID가 있습니다.</target>
        </trans-unit>
        <trans-unit id="48b848455f1284e65bd9941b397e2830fe4b0d99" translate="yes" xml:space="preserve">
          <source>If a table is dropped during the backup, then it might still exists after the backup is prepared.</source>
          <target state="translated">백업 중에 테이블이 삭제되면 백업 준비 후에도 테이블이 여전히 존재할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9994655db01b406ece9c67be5ad2ab0bc0cd8918" translate="yes" xml:space="preserve">
          <source>If a table is renamed during the backup after the tablespace file was copied, then the table may not exist after the backup is prepared.</source>
          <target state="translated">테이블 스페이스 파일이 복사 된 후 백업 중에 테이블 이름이 바뀌면 백업 준비 후 테이블이 존재하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e196e7793b58907c4c79b3d128490276e3b6aeb" translate="yes" xml:space="preserve">
          <source>If a table was modified by an external application that does not handle indexing, the indexes must be reconstructed to prevent returning false or incomplete results. To do this, use the &lt;a href=&quot;../optimize-table/index&quot;&gt;OPTIMIZE TABLE&lt;/a&gt; command.</source>
          <target state="translated">인덱싱을 처리하지 않는 외부 응용 프로그램에서 테이블을 수정 한 경우 거짓 또는 불완전한 결과가 반환되지 않도록 인덱스를 재구성해야합니다. 이를 수행하려면 &lt;a href=&quot;../optimize-table/index&quot;&gt;OPTIMIZE TABLE&lt;/a&gt; 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="eaee2d05db572fa09a4407b55e7e7a7ade1eeb73" translate="yes" xml:space="preserve">
          <source>If a table with the same name exists, error 1050 results. Use &lt;code&gt;IF NOT EXISTS&lt;/code&gt; to suppress this error and issue a note instead. Use &lt;code&gt;&lt;a href=&quot;../show-warnings/index&quot;&gt;SHOW WARNINGS&lt;/a&gt;&lt;/code&gt; to see notes.</source>
          <target state="translated">이름이 같은 테이블이 있으면 오류 1050이 발생합니다. &lt;code&gt;IF NOT EXISTS&lt;/code&gt; 를 사용 하여이 오류를 억제하고 대신 메모를 발행하십시오. &lt;code&gt;&lt;a href=&quot;../show-warnings/index&quot;&gt;SHOW WARNINGS&lt;/a&gt;&lt;/code&gt; 를 사용 하여 메모를보십시오.</target>
        </trans-unit>
        <trans-unit id="0fadb561ef5b894f54b400313ac2411acb4c44a9" translate="yes" xml:space="preserve">
          <source>If a table's definition can allow rows that the table's InnoDB row format can't actually store, then InnoDB will raise errors or warnings in certain scenarios.</source>
          <target state="translated">테이블의 정의가 테이블의 InnoDB 행 형식으로 실제로 저장할 수없는 행을 허용 할 경우 InnoDB는 특정 시나리오에서 오류나 경고를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="a5f8fdf831dc004387a1dc64a19647f30187fc6c" translate="yes" xml:space="preserve">
          <source>If a table's index structure is changed, index statistics recorded in this table may also be reset.</source>
          <target state="translated">테이블의 인덱스 구조가 변경되면이 테이블에 기록 된 인덱스 통계도 재설정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1cb800a437c1140d63708d4e0b51048c1e73fb9f" translate="yes" xml:space="preserve">
          <source>If a test fails, it is retried up to a maximum of N runs (default 1). Retries are also limited by the maximum number of failures before stopping, set with the &lt;code&gt;--retry-failure&lt;/code&gt; option. This option has no effect unless &lt;code&gt;--force&lt;/code&gt; is also used; without it, test execution will terminate after the first failure. The &lt;code&gt;--retry&lt;/code&gt; and &lt;code&gt;--retry-failure&lt;/code&gt; options do not affect how many times a test repeated with &lt;code&gt;--repeat&lt;/code&gt; may fail in total, as each repetition is considered a new test case, which may in turn be retried if it fails.</source>
          <target state="translated">테스트가 실패하면 최대 N 회 실행 (기본값 1)으로 재 시도됩니다. 재 시도는 &lt;code&gt;--retry-failure&lt;/code&gt; 옵션으로 설정하여 중지하기 전 최대 실패 횟수에 의해 제한됩니다 . &lt;code&gt;--force&lt;/code&gt; 를 사용 하지 않으면이 옵션이 적용되지 않습니다 . 그렇지 않으면 첫 번째 실패 후 테스트 실행이 종료됩니다. &lt;code&gt;--retry&lt;/code&gt; 및 &lt;code&gt;--retry-failure&lt;/code&gt; 옵션은 반복 시험 횟수에 영향을주지 않는 &lt;code&gt;--repeat&lt;/code&gt; 는 각각의 반복이 실패하면 다시 시도 할 수있는 새로운 테스트 케이스를 고려로, 총에 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a299cab05a36b6abc600e43115d9fcd3c156f7f" translate="yes" xml:space="preserve">
          <source>If a transaction log has been read (i.e. the log is offline), it will be recycled for writing again, unless it must be deleted because the number of logs on disk exceeds this threshold. Recycling logs is an optimization because the writing a pre-allocated file is faster then writing to the end of a file.</source>
          <target state="translated">트랜잭션 로그를 읽은 경우 (즉, 로그가 오프라인 인 경우) 디스크의 로그 수가이 임계 값을 초과하여 삭제해야하는 경우가 아니라면 다시 쓰기 위해 재활용됩니다. 미리 할당 된 파일을 쓰는 것이 파일의 끝에 쓰는 것보다 빠르기 때문에 재활용 로그가 최적화됩니다.</target>
        </trans-unit>
        <trans-unit id="508041a345243dd9c8a3d388cacb56546b3cea15" translate="yes" xml:space="preserve">
          <source>If a trigger contains an error and the engine is transactional, or it is a BEFORE trigger, the trigger will not run, and will prevent the original statement from running as well. If the engine is non-transactional, and it is an AFTER trigger, the trigger will not run, but the original statement will.</source>
          <target state="translated">트리거에 오류가 있고 엔진이 트랜잭션이거나 BEFORE 트리거 인 경우 트리거가 실행되지 않고 원래 명령문도 실행되지 않습니다. 엔진이 비 트랜잭션이고 AFTER 트리거 인 경우 트리거가 실행되지 않지만 원래 명령문은 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="2d54384ebb5d8a9900860a8eccafb82f95aac019" translate="yes" xml:space="preserve">
          <source>If a trigger is loaded into cache, it is not automatically reloaded when the table metadata changes. In this case a trigger can operate using the outdated metadata.</source>
          <target state="translated">트리거가 캐시에로드되면 테이블 메타 데이터가 변경 될 때 자동으로 다시로드되지 않습니다. 이 경우 오래된 메타 데이터를 사용하여 트리거를 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee7bbc773926bd7821bb488dcd62f614625f9203" translate="yes" xml:space="preserve">
          <source>If a unique index consists of a column where trailing pad characters are stripped or ignored, inserts into that column where values differ only by the number of trailing pad characters will result in a duplicate-key error.</source>
          <target state="translated">고유 색인이 후행 패드 문자가 제거되거나 무시되는 열로 구성된 경우 후행 패드 문자 수에 따라 값이 다른 열에 삽입하면 중복 키 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="36704a03981b7687fcbdb3fd9cf6095edaceb688" translate="yes" xml:space="preserve">
          <source>If a user has been granted a role, they do not automatically obtain all permissions associated with that role. These permissions are only in use when the user activates the role with the &lt;a href=&quot;../set-role/index&quot;&gt;SET ROLE&lt;/a&gt; statement.</source>
          <target state="translated">사용자에게 역할이 부여 된 경우 해당 역할과 관련된 모든 권한을 자동으로 얻지는 않습니다. 이 권한은 사용자가 &lt;a href=&quot;../set-role/index&quot;&gt;SET ROLE&lt;/a&gt; 문으로 역할을 활성화 할 때만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="4b0ac3bed68bdc286095c3cb1edb7b00ef013642" translate="yes" xml:space="preserve">
          <source>If a user has the &lt;a href=&quot;../grant/index&quot;&gt;SUPER privilege&lt;/a&gt; but not the &lt;code&gt;DELETE HISTORY&lt;/code&gt; privilege, running &lt;a href=&quot;../mysql_upgrade/index&quot;&gt;mysql_upgrade&lt;/a&gt; will grant &lt;code&gt;DELETE HISTORY&lt;/code&gt; as well.</source>
          <target state="translated">사용자에게 &lt;a href=&quot;../grant/index&quot;&gt;SUPER 권한이&lt;/a&gt; 있지만 &lt;code&gt;DELETE HISTORY&lt;/code&gt; 권한이 없는 경우 &lt;a href=&quot;../mysql_upgrade/index&quot;&gt;mysql_upgrade&lt;/a&gt; 를 실행 하면 &lt;code&gt;DELETE HISTORY&lt;/code&gt; 도 부여 됩니다.</target>
        </trans-unit>
        <trans-unit id="c17c47214ec2fcd92c53bc95e57bd6b627126dd9" translate="yes" xml:space="preserve">
          <source>If a user sets the value of the &lt;code&gt;gtid_slave_pos&lt;/code&gt; system variable, and &lt;code&gt;&lt;a href=&quot;#gtid_binlog_pos&quot;&gt;gtid_binlog_pos&lt;/a&gt;&lt;/code&gt; contains later GTIDs for certain replication domains, then &lt;code&gt;&lt;a href=&quot;#gtid_current_pos&quot;&gt;gtid_current_pos&lt;/a&gt;&lt;/code&gt; will contain the GTIDs from &lt;code&gt;&lt;a href=&quot;#gtid_binlog_pos&quot;&gt;gtid_binlog_pos&lt;/a&gt;&lt;/code&gt; for those replication domains. To protect users in this scenario, if a user sets tthe &lt;code&gt;gtid_slave_pos&lt;/code&gt; system variable to a GTID position that is behind the GTID position in &lt;code&gt;&lt;a href=&quot;#gtid_binlog_pos&quot;&gt;gtid_binlog_pos&lt;/a&gt;&lt;/code&gt;, then the server will give the user a warning.</source>
          <target state="translated">사용자가 값 설정하는 경우 &lt;code&gt;gtid_slave_pos&lt;/code&gt; 의 시스템 변수를, 그리고 &lt;code&gt;&lt;a href=&quot;#gtid_binlog_pos&quot;&gt;gtid_binlog_pos&lt;/a&gt;&lt;/code&gt; 은 특정 복제 도메인에 대해 나중에 GTIDs을 포함, 다음 &lt;code&gt;&lt;a href=&quot;#gtid_current_pos&quot;&gt;gtid_current_pos&lt;/a&gt;&lt;/code&gt; 는 에서 GTIDs 포함 &lt;code&gt;&lt;a href=&quot;#gtid_binlog_pos&quot;&gt;gtid_binlog_pos&lt;/a&gt;&lt;/code&gt; 을 그 복제 도메인에 대해. 이 시나리오에서 사용자를 보호하기 위해 사용자가 &lt;code&gt;gtid_slave_pos&lt;/code&gt; 시스템 변수를 gtid_binlog_pos의 GTID 위치 뒤에있는 GTID 위치로 &lt;code&gt;&lt;a href=&quot;#gtid_binlog_pos&quot;&gt;gtid_binlog_pos&lt;/a&gt;&lt;/code&gt; 하면 서버는 사용자에게 경고를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="68e5f4e8eab6781a2986136c6a1934debe6996e8" translate="yes" xml:space="preserve">
          <source>If a user value is given for the DEFINER clause, it should be a MariaDB account in 'user_name'@'host_name' format (the same format used in the GRANT statement). The user_name and host_name values both are required. The definer can also be given as CURRENT_USER or CURRENT_USER(). The default DEFINER value is the user who executes the CREATE VIEW statement. This is the same as specifying DEFINER = CURRENT_USER explicitly.</source>
          <target state="translated">DEFINER 절에 사용자 값이 제공되면 'user_name'@ 'host_name'형식 (GRANT 문에서 사용 된 형식과 동일)의 MariaDB 계정이어야합니다. user_name 및 host_name 값이 모두 필요합니다. 정의자는 CURRENT_USER 또는 CURRENT_USER ()로 제공 될 수도 있습니다. 기본 DEFINER 값은 CREATE VIEW 문을 실행하는 사용자입니다. 이는 DEFINER = CURRENT_USER를 명시 적으로 지정하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f6a76061b0df54d6cf61f22b926b9cd13b4b1b78" translate="yes" xml:space="preserve">
          <source>If a variable has not been used yet, its value is NULL:</source>
          <target state="translated">변수가 아직 사용되지 않은 경우 해당 값은 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="d3b0a35fa1a5c913a1b8134b297d92176fd325d4" translate="yes" xml:space="preserve">
          <source>If a view references another view, it will be possible to drop the referenced view. However, the other view will reference a view which does not exist any more. Thus, querying it will produce an error similar to the following:</source>
          <target state="translated">뷰가 다른 뷰를 참조하는 경우 참조 된 뷰를 삭제할 수 있습니다. 그러나 다른보기는 더 이상 존재하지 않는보기를 참조합니다. 따라서 쿼리하면 다음과 유사한 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d77e8e7047338ea1488452b2acc683cf76878c69" translate="yes" xml:space="preserve">
          <source>If a warning is issued with the SIGNAL or RESIGNAL statement (that is, an error with an SQLSTATE starting with '01'), it will be treated like an error.</source>
          <target state="translated">SIGNAL 또는 RESIGNAL 문으로 경고가 발행되면 (즉, '01'로 시작하는 SQLSTATE의 오류) 오류처럼 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="5032446f1ca6fb528794af915068b5675acbe177" translate="yes" xml:space="preserve">
          <source>If all goes well, it will run in O(M) where M is the number of output rows.</source>
          <target state="translated">모두 잘 진행되면 O (M)에서 실행됩니다. 여기서 M은 출력 행 수입니다.</target>
        </trans-unit>
        <trans-unit id="37ed845989f60389f6abc6cac67def1f558e90e9" translate="yes" xml:space="preserve">
          <source>If all the servers are in the same 'vulnerability zone' -- eg, rack or data center -- Have an odd number (at least 3) of nodes.</source>
          <target state="translated">모든 서버가 동일한 '취약성 영역'에있는 경우 (예 : 랙 또는 데이터 센터) 홀수 (최소 3)의 노드를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="157d7696dab42205f50912e57d2aa462e571cb67" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;&lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt;&lt;/code&gt; operation supports the &lt;code&gt;INPLACE&lt;/code&gt; algorithm, then it can be performed using optimizations by the underlying storage engine, but it may rebuilt.</source>
          <target state="translated">는 IF &lt;code&gt;&lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt;&lt;/code&gt; 조작이 지원 &lt;code&gt;INPLACE&lt;/code&gt; 의 알고리즘을 다음이를 기본 스토리지 엔진 최적화를 사용하여 수행 될 수 있지만, 재건 할 수있다.</target>
        </trans-unit>
        <trans-unit id="65ae1052ef59c70ca98d25b93cddafc4b6beed77" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;&lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt;&lt;/code&gt; operation supports the &lt;code&gt;INSTANT&lt;/code&gt; algorithm, then it can be performed without modifying any data files.</source>
          <target state="translated">는 IF &lt;code&gt;&lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt;&lt;/code&gt; 조작이 지원 &lt;code&gt;INSTANT&lt;/code&gt; 의 알고리즘을 다음 모든 데이터 파일을 수정하지 않고도 행할 수있다.</target>
        </trans-unit>
        <trans-unit id="b2a52ddac4023979a75ea243b5c96cc1f002501c" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;&lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt;&lt;/code&gt; operation supports the &lt;code&gt;NOCOPY&lt;/code&gt; algorithm, then it can be performed without rebuilding the clustered index.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt;&lt;/code&gt; 의 동작이 지원 &lt;code&gt;NOCOPY&lt;/code&gt; 의 알고리즘을, 다음은 클러스터 된 인덱스를 다시 작성하지 않고 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f67cfba0f68f88b1ec3187b757b4c7f08fd05421" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;&lt;a href=&quot;index&quot;&gt;ALTER TABLE&lt;/a&gt;&lt;/code&gt; operation supports &lt;code&gt;ALGORITHM=INPLACE&lt;/code&gt;, then it can be performed using optimizations by the underlying storage engine, but it may rebuilt.</source>
          <target state="translated">는 IF &lt;code&gt;&lt;a href=&quot;index&quot;&gt;ALTER TABLE&lt;/a&gt;&lt;/code&gt; 동작 지원 &lt;code&gt;ALGORITHM=INPLACE&lt;/code&gt; 를 다음이를 기본 스토리지 엔진 최적화를 사용하여 수행 될 수 있지만, 재건 할 수있다.</target>
        </trans-unit>
        <trans-unit id="65f0943a1d79f04e5d16dc915b441ec94017adda" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;ALTER TABLE&lt;/code&gt; operation is being performed and the connection is killed, the changes will be rolled back in a controlled manner. The rollback can be a slow operation as the time it takes is relative to how far the operation has progressed.</source>
          <target state="translated">는 IF &lt;code&gt;ALTER TABLE&lt;/code&gt; 동작이 수행되는 상기 연결 살해의 변화는 제어 된 방식으로 롤백한다. 롤백에 걸리는 시간은 작업 진행 정도에 따라 롤백이 느려질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22e15ba28dc73e12ded6c35b134df9b4a4d5ce30" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;ALTER TABLE&lt;/code&gt; operation supports &lt;code&gt;ALGORITHM=INSTANT&lt;/code&gt;, then it can be performed without modifying any data files.</source>
          <target state="translated">&lt;code&gt;ALTER TABLE&lt;/code&gt; 조작이 &lt;code&gt;ALGORITHM=INSTANT&lt;/code&gt; 를 지원 하는 경우 데이터 파일을 수정하지 않고 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8776b96f9d448769e659021b77097a455b482361" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;ALTER TABLE&lt;/code&gt; operation supports &lt;code&gt;ALGORITHM=NOCOPY&lt;/code&gt;, then it can be performed without rebuilding the clustered index.</source>
          <target state="translated">경우 &lt;code&gt;ALTER TABLE&lt;/code&gt; 의 동작이 지원 &lt;code&gt;ALGORITHM=NOCOPY&lt;/code&gt; 를 , 다음은 클러스터 된 인덱스를 다시 작성하지 않고 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="682344c71995e73807a924c54b8576cc5410b173" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;INSERT&lt;/code&gt; statement contain the &lt;code&gt;&lt;a href=&quot;../high_priority-and-low_priority-clauses/index&quot;&gt;HIGH_PRIORITY&lt;/a&gt;&lt;/code&gt; clause, concurrent inserts cannot be used. &lt;code&gt;&lt;a href=&quot;../insert-delayed/index&quot;&gt;INSERT ... DELAYED&lt;/a&gt;&lt;/code&gt; is usually unneeded if concurrent inserts are enabled.</source>
          <target state="translated">&lt;code&gt;INSERT&lt;/code&gt; 문에 &lt;code&gt;&lt;a href=&quot;../high_priority-and-low_priority-clauses/index&quot;&gt;HIGH_PRIORITY&lt;/a&gt;&lt;/code&gt; 절이 포함 된 경우 동시 삽입을 사용할 수 없습니다. &lt;code&gt;&lt;a href=&quot;../insert-delayed/index&quot;&gt;INSERT ... DELAYED&lt;/a&gt;&lt;/code&gt; 는 일반적으로 동시 삽입이 활성화 된 경우 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4703a83c8f0a5a103f34d0eaa1157139bcd93d64" translate="yes" xml:space="preserve">
          <source>If an InnoDB page compression algorithm does not support compression levels, then it ignores any provided compression level value.</source>
          <target state="translated">InnoDB 페이지 압축 알고리즘이 압축 수준을 지원하지 않으면 제공된 압축 수준 값을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="08c46f76818e766dc5d2e07fe5573504d9c15902" translate="yes" xml:space="preserve">
          <source>If an array, expand it if under an expanded object or take the first value of it.</source>
          <target state="translated">배열 인 경우 확장 된 오브젝트 아래에서 배열을 확장하거나 첫 번째 값을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3e8b946c1dce4cafb1c88534f9eda69809e33f46" translate="yes" xml:space="preserve">
          <source>If an array, the number of elements in the array.</source>
          <target state="translated">배열 인 경우 배열의 요소 수입니다.</target>
        </trans-unit>
        <trans-unit id="639ee5b6aa397be3caf19c633f893043bf7361e2" translate="yes" xml:space="preserve">
          <source>If an error in processing dependencies is encountered, a user can fix it manually</source>
          <target state="translated">종속성 처리 오류가 발생하면 사용자가 수동으로 수정할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="19757a2ea8aeb937bb155e2c5552dad1054a60a8" translate="yes" xml:space="preserve">
          <source>If an error occurs during the query, the table will not be created at all.</source>
          <target state="translated">쿼리 중에 오류가 발생하면 테이블이 전혀 만들어지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="49ba0b6d08514fb62d79ef483b4c53857ca03436" translate="yes" xml:space="preserve">
          <source>If an event is currently being executed, it can be seen by querying the &lt;a href=&quot;../information-schema-processlist-table/index&quot;&gt;Information Schema PROCESSLIST table&lt;/a&gt;, or with the &lt;a href=&quot;../show-processlist/index&quot;&gt;SHOW PROCESSLIST&lt;/a&gt; statement.</source>
          <target state="translated">이벤트가 현재 실행중인 경우 &lt;a href=&quot;../information-schema-processlist-table/index&quot;&gt;Information Schema PROCESSLIST 테이블&lt;/a&gt; 을 조회 하거나 &lt;a href=&quot;../show-processlist/index&quot;&gt;SHOW PROCESSLIST&lt;/a&gt; 문을 사용하여 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b0760490bce28021f43d4349af4df1e12adf992d" translate="yes" xml:space="preserve">
          <source>If an event is recurring, you can specify when the first execution must happen via the &lt;code&gt;STARTS&lt;/code&gt; clause and a maximum time for the last execution via the &lt;code&gt;ENDS&lt;/code&gt; clause. &lt;code&gt;STARTS&lt;/code&gt; and &lt;code&gt;ENDS&lt;/code&gt; clauses are followed by a timestamp and, optionally, one or more intervals. The &lt;code&gt;ENDS&lt;/code&gt; clause can specify a timestamp in the past, so that the event is stored but not executed until you modify it via &lt;a href=&quot;../alter-event/index&quot;&gt;ALTER EVENT&lt;/a&gt;.</source>
          <target state="translated">이벤트가 반복되는 경우 &lt;code&gt;STARTS&lt;/code&gt; 절을 통해 첫 번째 실행이 발생해야하는 시기와 &lt;code&gt;ENDS&lt;/code&gt; 절을 통한 마지막 실행의 최대 시간을 지정할 수 있습니다 . &lt;code&gt;STARTS&lt;/code&gt; 및 &lt;code&gt;ENDS&lt;/code&gt; 절 뒤에는 타임 스탬프 및 선택적으로 하나 이상의 간격이옵니다. &lt;code&gt;ENDS&lt;/code&gt; 절은 이벤트가 저장되지만를 통해 수정 될 때까지 실행되지 않습니다 그래서, 과거에 타임 스탬프를 지정할 수 있습니다 &lt;a href=&quot;../alter-event/index&quot;&gt;ALTER EVENT&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3015ff9dad587a50042ce1493bd8ef30e63985d8" translate="yes" xml:space="preserve">
          <source>If an index is defined on a generated column, then the optimizer considers using it in the same way as indexes based on &quot;real&quot; columns.</source>
          <target state="translated">인덱스가 생성 된 컬럼에 정의 된 경우 옵티마이 저는 &quot;실제&quot;컬럼을 기반으로하는 인덱스와 동일한 방식으로 인덱스를 사용하는 것을 고려합니다.</target>
        </trans-unit>
        <trans-unit id="13ed38364174e622d9997e2c3276d9b15a23c68a" translate="yes" xml:space="preserve">
          <source>If an index is rarely used (or not used at all) then remove it to increase INSERT, and UPDATE performance.</source>
          <target state="translated">인덱스를 거의 사용하지 않거나 전혀 사용하지 않으면 인덱스를 제거하여 INSERT 및 UPDATE 성능을 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="5e62cbb0577681c35feb6b99f109df3d5fce044d" translate="yes" xml:space="preserve">
          <source>If an instrument creates multiple instances, each instance has a unique &lt;code&gt;OBJECT_INSTANCE_BEGIN&lt;/code&gt; value to allow for grouping by instance.</source>
          <target state="translated">인스트루먼트가 여러 인스턴스를 생성하는 경우 각 인스턴스는 인스턴스별로 그룹화 할 수 있도록 고유 한 &lt;code&gt;OBJECT_INSTANCE_BEGIN&lt;/code&gt; 값을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="83e15393de9ec880ba079bbf319751f4368bafba" translate="yes" xml:space="preserve">
          <source>If an item is inserted or deleted between the time you look at one page and the next, you could miss an item, or see an item duplicated.</source>
          <target state="translated">한 페이지와 다음 페이지를 볼 때 사이에 항목을 삽입하거나 삭제하면 항목을 놓치거나 항목이 복제 된 것을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a554f32db33dc7fbfece6eaf3bc8b4600712d05f" translate="yes" xml:space="preserve">
          <source>If an object, the number of members in the object.</source>
          <target state="translated">개체 인 경우 개체의 멤버 수입니다.</target>
        </trans-unit>
        <trans-unit id="e59e68ce62176b794d5033359e39e26fef4d8d4a" translate="yes" xml:space="preserve">
          <source>If an option is not explicitly set, then the server or client will simply use the default value for that option.</source>
          <target state="translated">옵션이 명시 적으로 설정되지 않은 경우 서버 또는 클라이언트는 해당 옵션의 기본값을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="bd8409e1786620a6be2c8805302389cbebdd6957" translate="yes" xml:space="preserve">
          <source>If an option is set outside of subpattern parentheses, the option applies to the remainder of the pattern that follows the option. If an option is set inside a subpattern, it applies to the part of this subpattern that follows the option.</source>
          <target state="translated">옵션이 하위 패턴 괄호 밖에 설정되어 있으면 옵션은 옵션 다음에 나오는 나머지 패턴에 적용됩니다. 하위 패턴 내부에 옵션이 설정되어 있으면 옵션을 따르는이 하위 패턴의 일부에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="70842326e588d5a6a518b65385abe76696eab7e7" translate="yes" xml:space="preserve">
          <source>If an option or system variable is not explicitly set, then it will be set to its default value. See &lt;a href=&quot;../server-system-variables/index&quot;&gt;Server System Variables&lt;/a&gt; for a full list of all server system variables and their default values.</source>
          <target state="translated">옵션 또는 시스템 변수가 명시 적으로 설정되어 있지 않으면 기본값으로 설정됩니다. 모든 서버 시스템 변수 및 해당 기본값의 전체 목록은 &lt;a href=&quot;../server-system-variables/index&quot;&gt;서버 시스템 변수&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c71f6f2826c414da5647cf92324c1afd5367313c" translate="yes" xml:space="preserve">
          <source>If an unknown option is provided to &lt;code&gt;mysqld_safe&lt;/code&gt; on the command-line, then it is passed to &lt;code&gt;mysqld_safe&lt;/code&gt;.</source>
          <target state="translated">알 수없는 옵션이 제공 될 경우 &lt;code&gt;mysqld_safe&lt;/code&gt; 는 명령 줄에 다음이 전달됩니다 &lt;code&gt;mysqld_safe&lt;/code&gt; 에 .</target>
        </trans-unit>
        <trans-unit id="3b12ab5874f8ace61b004f009cbba9c7965c2a57" translate="yes" xml:space="preserve">
          <source>If another connection is using the sequence, a metadata lock is active, and this statement will wait until the lock is released. This is also true for non-transactional tables.</source>
          <target state="translated">다른 연결에서 시퀀스를 사용중인 경우 메타 데이터 잠금이 활성화되고이 명령문은 잠금이 해제 될 때까지 기다립니다. 비 트랜잭션 테이블에서도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="abb51e2191afdac5c25fb56c4874f57c56ec6ebd" translate="yes" xml:space="preserve">
          <source>If another connection is using the table, a &lt;a href=&quot;../metadata-locking/index&quot;&gt;metadata lock&lt;/a&gt; is active, and this statement will wait until the lock is released. This is also true for non-transactional tables.</source>
          <target state="translated">다른 연결이 테이블을 사용하는 경우 &lt;a href=&quot;../metadata-locking/index&quot;&gt;메타 데이터 잠금&lt;/a&gt; 이 활성화되고이 명령문은 잠금이 해제 될 때까지 기다립니다. 비 트랜잭션 테이블에서도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="debd77996be42c15d8d8afe74507e3bb2fcb6bb1" translate="yes" xml:space="preserve">
          <source>If any MariaDB files are in /home/</source>
          <target state="translated">MariaDB 파일이 / home /에있는 경우</target>
        </trans-unit>
        <trans-unit id="91122490fcb853b12b3f2acdf0d9d98d67bc82eb" translate="yes" xml:space="preserve">
          <source>If any MariaDB storage references raw block devices</source>
          <target state="translated">MariaDB 저장소가 원시 블록 장치를 참조하는 경우</target>
        </trans-unit>
        <trans-unit id="faff85734b685735be5def9dabf90c25ec6abbe0" translate="yes" xml:space="preserve">
          <source>If any MariaDB write any files to anywhere under /boot, /usr or /etc</source>
          <target state="translated">MariaDB가 / boot, / usr 또는 / etc 아래에 파일을 쓰는 경우</target>
        </trans-unit>
        <trans-unit id="203f9b2c49ee540f09082f4418ac27b314684dc4" translate="yes" xml:space="preserve">
          <source>If any argument is &lt;code&gt;NULL&lt;/code&gt;, returns &lt;code&gt;NULL.&lt;/code&gt;</source>
          <target state="translated">인수가 &lt;code&gt;NULL&lt;/code&gt; 이면 NULL 을 반환 &lt;code&gt;NULL.&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7139f3c92667f83119f7baa247d024ab27dfae9d" translate="yes" xml:space="preserve">
          <source>If any argument is &lt;code&gt;NULL&lt;/code&gt;, returns &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">인수가 &lt;code&gt;NULL&lt;/code&gt; 이면 NULL 을 반환 &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0dfe4d802f1dc4f11494adab15b8cdf98838514" translate="yes" xml:space="preserve">
          <source>If any argument is &lt;code&gt;NULL&lt;/code&gt;, the function returns &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">인수가 &lt;code&gt;NULL&lt;/code&gt; 이면 함수는 &lt;code&gt;NULL&lt;/code&gt; 을 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="175c5e0f348fd3fc5f32fd34f8727fee933cc9d5" translate="yes" xml:space="preserve">
          <source>If any argument is a case-sensitive string, the arguments are compared as case-sensitive strings.</source>
          <target state="translated">인수가 대소 문자를 구분하는 문자열 인 경우 인수는 대소 문자를 구분하는 문자열로 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="d44143a970049b1df2c46e83f0401036669fd07c" translate="yes" xml:space="preserve">
          <source>If any of the arguments are set as &lt;code&gt;NULL&lt;/code&gt;, the function returns &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">인수가 &lt;code&gt;NULL&lt;/code&gt; 로 설정 되면 함수는 &lt;code&gt;NULL&lt;/code&gt; 을 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="1d3bbf90ac88e55c9b9539179753fe1eed9562cc" translate="yes" xml:space="preserve">
          <source>If any of the following functions are present in a query, it will not be cached. Queries with these functions are sometimes called 'non-deterministic' - don't get confused with the use of this term in other contexts.</source>
          <target state="translated">다음 함수 중 하나라도 쿼리에 있으면 캐시되지 않습니다. 이러한 기능을 가진 쿼리는 때때로 '비결정론 적 (non-deterministic)'이라고 불립니다. 다른 문맥에서이 용어를 사용하는 것과 혼동하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="35252ff2427d0f3398a8d6daf12db0b608070869" translate="yes" xml:space="preserve">
          <source>If any of the following statements is in effect in the session, attempting &lt;code&gt; FLUSH TABLES ... FOR EXPORT&lt;/code&gt; will produce an error.</source>
          <target state="translated">세션에서 다음 명령문 중 하나라도 적용되는 경우 &lt;code&gt; FLUSH TABLES ... FOR EXPORT&lt;/code&gt; 시도 하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5f818cef9181ecb4ceb2f3c81e5c820f42c5b8ae" translate="yes" xml:space="preserve">
          <source>If any of the old user accounts do not exist or any of the new user accounts already exist, &lt;code&gt;ERROR 1396 (HY000)&lt;/code&gt; results. If an error occurs, &lt;code&gt;RENAME USER&lt;/code&gt; will still rename the accounts that do not result in an error.</source>
          <target state="translated">기존 사용자 계정이 없거나 새 사용자 계정이 이미 있으면 &lt;code&gt;ERROR 1396 (HY000)&lt;/code&gt; 이 발생합니다. 오류가 발생해도 &lt;code&gt;RENAME USER&lt;/code&gt; 는 여전히 오류가 발생 하지 않는 계정의 이름을 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="186917fe2efa7c1de33229effb44d51f56b8b043" translate="yes" xml:space="preserve">
          <source>If any of the specified accounts, or any permissions for the specified accounts, already exist, then the server returns &lt;code&gt;ERROR 1396 (HY000)&lt;/code&gt;. If an error occurs, &lt;code&gt;CREATE USER&lt;/code&gt; will still create the accounts that do not result in an error. Only one error is produced for all users which have not been created:</source>
          <target state="translated">지정된 계정 또는 지정된 계정에 대한 권한이 이미 존재하면 서버는 &lt;code&gt;ERROR 1396 (HY000)&lt;/code&gt; 을 리턴합니다 . 오류가 발생해도 &lt;code&gt;CREATE USER&lt;/code&gt; 는 여전히 오류가 발생 하지 않는 계정을 만듭니다. 작성되지 않은 모든 사용자에 대해 하나의 오류 만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="11dcfe6908c799ae309913a171e22bdf9f3de8d2" translate="yes" xml:space="preserve">
          <source>If any of the specified roles already exist, &lt;code&gt;ERROR 1396 (HY000)&lt;/code&gt; results. If an error occurs, &lt;code&gt;CREATE ROLE&lt;/code&gt; will still create the roles that do not result in an error. The maximum length for a role is 128 characters. Role names can be quoted, as explained in the &lt;a href=&quot;../identifier-names/index&quot;&gt;Identifier names&lt;/a&gt; page. Only one error is produced for all roles which have not been created:</source>
          <target state="translated">지정된 역할 중 하나라도 이미 존재하면 &lt;code&gt;ERROR 1396 (HY000)&lt;/code&gt; 이 발생합니다. 오류가 발생해도 &lt;code&gt;CREATE ROLE&lt;/code&gt; 은 여전히 오류를 발생 시키지 않는 역할을 만듭니다. 역할의 최대 길이는 128 자입니다. &lt;a href=&quot;../identifier-names/index&quot;&gt;식별자 이름&lt;/a&gt; 페이지에 설명 된대로 역할 이름을 인용 할 수 있습니다 . 작성되지 않은 모든 역할에 대해 하나의 오류 만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6f9e76669d2ebab6f55e71a3c957801a286e43e7" translate="yes" xml:space="preserve">
          <source>If any of the specified user accounts do not exist, &lt;code&gt;ERROR 1396 (HY000)&lt;/code&gt; results. If an error occurs, &lt;code&gt;DROP ROLE&lt;/code&gt; will still drop the roles that do not result in an error. Only one error is produced for all roles which have not been dropped:</source>
          <target state="translated">지정된 사용자 계정이 존재하지 않으면 &lt;code&gt;ERROR 1396 (HY000)&lt;/code&gt; 이 발생합니다. 오류가 발생해도 &lt;code&gt;DROP ROLE&lt;/code&gt; 은 여전히 오류를 발생 시키지 않는 역할을 삭제합니다. 삭제되지 않은 모든 역할에 대해 하나의 오류 만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="039d7eade7d99f6b9ac7cacfae5bba955d8e87cb" translate="yes" xml:space="preserve">
          <source>If any of the specified user accounts do not exist, &lt;code&gt;ERROR 1396 (HY000)&lt;/code&gt; results. If an error occurs, &lt;code&gt;DROP USER&lt;/code&gt; will still drop the accounts that do not result in an error. Only one error is produced for all users which have not been dropped:</source>
          <target state="translated">지정된 사용자 계정이 존재하지 않으면 &lt;code&gt;ERROR 1396 (HY000)&lt;/code&gt; 이 발생합니다. 오류가 발생해도 &lt;code&gt;DROP USER&lt;/code&gt; 는 여전히 오류를 일으키지 않는 계정을 삭제합니다. 삭제되지 않은 모든 사용자에 대해 하나의 오류 만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bb4799ead9b53277c11236589f6f3802dad2b90e" translate="yes" xml:space="preserve">
          <source>If any of the specified user accounts do not yet exist, an error results. If an error occurs, &lt;code&gt;ALTER USER&lt;/code&gt; will still modify the accounts that do not result in an error. Only one error is produced for all users which have not been modified.</source>
          <target state="translated">지정된 사용자 계정이 아직 없으면 오류가 발생합니다. 오류가 발생하면 &lt;code&gt;ALTER USER&lt;/code&gt; 는 여전히 오류가 발생 하지 않는 계정을 수정합니다. 수정되지 않은 모든 사용자에 대해 하나의 오류 만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="19aac64f67dbb15d3db08c843a5c9c961f08e8b8" translate="yes" xml:space="preserve">
          <source>If any of these limits are set to &lt;code&gt;0&lt;/code&gt;, then there is no limit for that resource for that user.</source>
          <target state="translated">이러한 제한 중 하나가 &lt;code&gt;0&lt;/code&gt; 으로 설정되면 해당 사용자의 해당 자원에 대한 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="b933f251235f20c7f656629c405d2ebd181a13b8" translate="yes" xml:space="preserve">
          <source>If any of these options are set for a specific user account, then any client who tries to connect with that user account will have to be configured to connect with TLS.</source>
          <target state="translated">이러한 옵션 중 하나가 특정 사용자 계정에 대해 설정된 경우 해당 사용자 계정으로 연결을 시도하는 모든 클라이언트는 TLS와 연결되도록 구성해야합니다.</target>
        </trans-unit>
        <trans-unit id="739178c2f05fa598f7f3bde2455b8426575d4ff3" translate="yes" xml:space="preserve">
          <source>If any user logs in for a query while User 1 and User 2 are running queries, these new users (i.e., User 3,4 and 5) get only the remaining 30% of the CPU Resources.&quot;</source>
          <target state="translated">사용자 1과 사용자 2가 쿼리를 실행하는 동안 사용자가 쿼리에 로그인하면 새 사용자 (예 : 사용자 3, 4 및 5)는 CPU 리소스의 나머지 30 % 만 얻습니다. &quot;</target>
        </trans-unit>
        <trans-unit id="db81ea72b976ba449f7a66b37fbdddb64594b412" translate="yes" xml:space="preserve">
          <source>If batching seems viable, then design the batching layer to gather for S seconds or 100-1000 rows, whichever comes first.</source>
          <target state="translated">배치가 실행 가능해 보이는 경우 배치 계층을 설계하여 S 초 또는 100-1000 행 중 더 빠른 행을 수집하십시오.</target>
        </trans-unit>
        <trans-unit id="ecfa962b236dbe72098e257d07790d307ab12d44" translate="yes" xml:space="preserve">
          <source>If binary logging is enabled, when a &lt;a href=&quot;../stored-functions/index&quot;&gt;stored function&lt;/a&gt; is created, it must be declared as either &lt;code&gt;DETERMINISTIC&lt;/code&gt;, &lt;code&gt;NO SQL&lt;/code&gt; or &lt;code&gt;READS SQL DATA&lt;/code&gt;, or else an error will occur.</source>
          <target state="translated">이진 로깅이 사용 가능한 경우, &lt;a href=&quot;../stored-functions/index&quot;&gt;저장된 함수&lt;/a&gt; 가 작성 될 때 &lt;code&gt;DETERMINISTIC&lt;/code&gt; , &lt;code&gt;NO SQL&lt;/code&gt; 또는 &lt;code&gt;READS SQL DATA&lt;/code&gt; 로 선언되어야 합니다. 그렇지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1e12d188418944da6db84fd05f65b1bad9331d4a" translate="yes" xml:space="preserve">
          <source>If both arguments are integer numbers (tinyint, smallint, mediumint, bigint), the result may vary between int, int unsigned, bigint or bigint unsigned, depending of the exact data types and their signs.</source>
          <target state="translated">두 인수가 모두 정수 (tinyint, smallint, mediumint, bigint) 인 경우 결과는 정확한 데이터 유형 및 부호에 따라 int, int unsigned, bigint 또는 bigint unsigned 사이에서 달라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37d299f6fa98f7cc687c9bb8eabe6f75428cac26" translate="yes" xml:space="preserve">
          <source>If both arguments are integers, they are compared as integers.</source>
          <target state="translated">두 인수가 모두 정수인 경우 정수로 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="61b9048613457b0b7aac6dea6c03c356211dfa01" translate="yes" xml:space="preserve">
          <source>If both arguments are strings, they are compared as strings.</source>
          <target state="translated">두 인수가 모두 문자열 인 경우 문자열로 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="c95fa97938d216dfa278bffc2c1d0e0ff3a6eab0" translate="yes" xml:space="preserve">
          <source>If both operands are integers, the result is calculated with &lt;a href=&quot;../bigint/index&quot;&gt;BIGINT&lt;/a&gt; precision. If either integer is unsigned, the result is also an unsigned integer, unless the NO_UNSIGNED_SUBTRACTION &lt;a href=&quot;../sql-mode/index&quot;&gt;SQL_MODE&lt;/a&gt; is enabled, in which case the result is always signed.</source>
          <target state="translated">두 피연산자가 모두 정수이면 결과는 &lt;a href=&quot;../bigint/index&quot;&gt;BIGINT&lt;/a&gt; 정밀도 로 계산됩니다 . 정수 중 하나가 부호없는 경우 &lt;a href=&quot;../sql-mode/index&quot;&gt;NO_UNSIGNED_SUBTRACTION SQL_MODE&lt;/a&gt; 가 사용 가능 하지 않은 경우 결과도 부호없는 정수 입니다.이 경우 결과는 항상 부호가 있습니다.</target>
        </trans-unit>
        <trans-unit id="066515fb1f3edde4181cf75316fb276db47ae258" translate="yes" xml:space="preserve">
          <source>If both operands are integers, the result is calculated with &lt;a href=&quot;../bigint/index&quot;&gt;BIGINT&lt;/a&gt; precision. If either integer is unsigned, the result is also an unsigned integer.</source>
          <target state="translated">두 피연산자가 모두 정수이면 결과는 &lt;a href=&quot;../bigint/index&quot;&gt;BIGINT&lt;/a&gt; 정밀도 로 계산됩니다 . 정수 중 하나가 부호없는 경우 결과도 부호없는 정수입니다.</target>
        </trans-unit>
        <trans-unit id="617ba4ea76d184e900565077fddf10d71bbf2c03" translate="yes" xml:space="preserve">
          <source>If called with no argument, returns a Unix timestamp (seconds since '1970-01-01 00:00:00' &lt;a href=&quot;../coordinated-universal-time/index&quot;&gt;UTC&lt;/a&gt;) as an unsigned integer. If &lt;code&gt;UNIX_TIMESTAMP()&lt;/code&gt; is called with a date argument, it returns the value of the argument as seconds since '1970-01-01 00:00:00' UTC. date may be a &lt;code&gt;&lt;a href=&quot;../date/index&quot;&gt;DATE&lt;/a&gt;&lt;/code&gt; string, a &lt;code&gt;&lt;a href=&quot;../datetime/index&quot;&gt;DATETIME&lt;/a&gt;&lt;/code&gt; string, a &lt;code&gt;&lt;a href=&quot;../timestamp/index&quot;&gt;TIMESTAMP&lt;/a&gt;&lt;/code&gt;, or a number in the format YYMMDD or YYYYMMDD. The server interprets date as a value in the current &lt;a href=&quot;../time-zones/index&quot;&gt;time zone&lt;/a&gt; and converts it to an internal value in &lt;a href=&quot;../coordinated-universal-time/index&quot;&gt;UTC&lt;/a&gt;. Clients can set their time zone as described in &lt;a href=&quot;../time-zones/index&quot;&gt;time zones&lt;/a&gt;.</source>
          <target state="translated">인수없이 호출하면 ( '1970-01-01 0시 0분 0초'이후의 초 유닉스 타임 스탬프를 반환 &lt;a href=&quot;../coordinated-universal-time/index&quot;&gt;UTC&lt;/a&gt; 부호없는 정수로)을. 날짜 인수와 함께 &lt;code&gt;UNIX_TIMESTAMP()&lt;/code&gt; 를 호출하면 '1970-01-01 00:00 : 00'UTC 이후의 인수 값을 초 단위로 반환합니다. 날짜는 &lt;code&gt;&lt;a href=&quot;../date/index&quot;&gt;DATE&lt;/a&gt;&lt;/code&gt; 문자열, &lt;code&gt;&lt;a href=&quot;../datetime/index&quot;&gt;DATETIME&lt;/a&gt;&lt;/code&gt; 문자열, &lt;code&gt;&lt;a href=&quot;../timestamp/index&quot;&gt;TIMESTAMP&lt;/a&gt;&lt;/code&gt; 또는 YYMMDD 또는 YYYYMMDD 형식의 숫자 일 수 있습니다 . 서버는 날짜를 현재 &lt;a href=&quot;../time-zones/index&quot;&gt;시간대&lt;/a&gt; 의 값으로 해석 하여 &lt;a href=&quot;../coordinated-universal-time/index&quot;&gt;UTC&lt;/a&gt; 의 내부 값으로 변환합니다 . 클라이언트는 시간대에 설명 된대로 시간대를 설정할 수 &lt;a href=&quot;../time-zones/index&quot;&gt;있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c25af9c124545cb87e7bcac79d4b82fd65f28f1a" translate="yes" xml:space="preserve">
          <source>If called with one parameter, this function returns the natural logarithm of X. If X is less than or equal to 0, then NULL is returned.</source>
          <target state="translated">하나의 매개 변수로 호출하면이 함수는 X의 자연 로그를 반환합니다. X가 0보다 작거나 같은 경우 NULL이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a5f07c83af338afe1b2bcef4e8b8bd5c500bcecb" translate="yes" xml:space="preserve">
          <source>If called with two parameters, it returns the logarithm of X to the base B. If B is &amp;lt;= 1 or X &amp;lt;= 0, the function returns NULL.</source>
          <target state="translated">두 개의 매개 변수를 사용하여 호출하면 X의 로그를 기본 B에 반환합니다. B가 &amp;lt;= 1 또는 X &amp;lt;= 0이면 함수는 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f120c008357fcb9450ad7911cc98e2d818643edc" translate="yes" xml:space="preserve">
          <source>If compression (&lt;code&gt;COMPRESSION_ALGORITHM=zlib&lt;/code&gt;) is used, then all index blocks and data blocks are compressed. The &lt;code&gt;.frm&lt;/code&gt; file and Aria definition header (first page/pages in the index file) are not compressed as these are used by discovery/open.</source>
          <target state="translated">압축 ( &lt;code&gt;COMPRESSION_ALGORITHM=zlib&lt;/code&gt; )이 사용되면 모든 인덱스 블록 및 데이터 블록이 압축됩니다. &lt;code&gt;.frm&lt;/code&gt; 파일과 아리아 정의 헤더는 (첫 페이지 / 색인 파일의 페이지)를 발견 / 개방에서 사용하는 이들로 압축되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f6aa764483ac1b67842a64eb8b448b1067542ad3" translate="yes" xml:space="preserve">
          <source>If compression is used, then the local block size is &lt;code&gt;S3_BLOCK_SIZE&lt;/code&gt;, but the block stored in S3 will be the size of the compressed block.</source>
          <target state="translated">압축이 사용되면 로컬 블록 크기는 &lt;code&gt;S3_BLOCK_SIZE&lt;/code&gt; 이지만 S3에 저장된 블록은 압축 된 블록의 크기가됩니다.</target>
        </trans-unit>
        <trans-unit id="75b9364ad2214c9d0bb8f41ad6b5668f34925d3c" translate="yes" xml:space="preserve">
          <source>If distinct optimization (remove duplicates) was used. This is marked only for the last table in the &lt;code&gt;SELECT&lt;/code&gt;.</source>
          <target state="translated">별개의 최적화 (중복 제거)가 사용 된 경우. 이것은 &lt;code&gt;SELECT&lt;/code&gt; 의 마지막 테이블에 대해서만 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="52e9bf50328ff591b0e97cbac7129fc811c8494c" translate="yes" xml:space="preserve">
          <source>If duplicate unique key was found, keep old row.</source>
          <target state="translated">중복 된 고유 키가 발견되면 이전 행을 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="584b6e852460a38727c99e7ca5d3ad627d1c24bd" translate="yes" xml:space="preserve">
          <source>If duplicate unique key was found, replace old row.</source>
          <target state="translated">중복 고유 키가 발견되면 이전 행을 바꾸십시오.</target>
        </trans-unit>
        <trans-unit id="82796028ab933cd01fa3a9ed344554171a5a0244" translate="yes" xml:space="preserve">
          <source>If either argument is NULL, the result of the comparison is NULL unless the NULL-safe &lt;a href=&quot;../null-safe-equal/index&quot;&gt;&amp;lt;=&amp;gt;&lt;/a&gt; equality comparison operator is used.</source>
          <target state="translated">인수 중 하나가 NULL이면 NULL 안전 &lt;a href=&quot;../null-safe-equal/index&quot;&gt;&amp;lt;=&amp;gt;&lt;/a&gt; 동등 비교 연산자를 사용 하지 않으면 비교 결과는 NULL 입니다.</target>
        </trans-unit>
        <trans-unit id="3fea711b5e24cb963df25cefaf9b0d40af0023ee" translate="yes" xml:space="preserve">
          <source>If either clause is omitted, the default behavior for the omitted clause is &lt;code&gt;RESTRICT&lt;/code&gt;.</source>
          <target state="translated">어느 한 절이 생략되면 생략 된 절의 기본 동작은 &lt;code&gt;RESTRICT&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="461fc46cc4f3ca5fcbb14a3ee7d4046a8648da0b" translate="yes" xml:space="preserve">
          <source>If either of the arguments is a decimal number, the result is decimal.</source>
          <target state="translated">인수 중 하나가 10 진수이면 결과는 10 진수입니다.</target>
        </trans-unit>
        <trans-unit id="a9dbe1419133360f2352f5364a9a828b54d8e7ad" translate="yes" xml:space="preserve">
          <source>If either of the arguments is a string (char, varchar, text), the result is double.</source>
          <target state="translated">인수 중 하나가 문자열 (char, varchar, text)이면 결과는 두 배입니다.</target>
        </trans-unit>
        <trans-unit id="eb064e9ba68240e1af4abc8a88708fedd3370120" translate="yes" xml:space="preserve">
          <source>If either of the arguments is an approximate number (float, double), the result is double.</source>
          <target state="translated">인수 중 하나가 근사값 (float, double) 인 경우 결과는 두 배입니다.</target>
        </trans-unit>
        <trans-unit id="3699804924f93d8d607c763394dde1619540c4d4" translate="yes" xml:space="preserve">
          <source>If either of the arguments is of a temporal type with a non-zero fractional second precision (time(N), datetime(N), timestamp(N)), the result is decimal.</source>
          <target state="translated">인수 중 하나가 0이 아닌 소수 초 정밀도 (time (N), datetime (N), timestamp (N))를 갖는 시간 유형 인 경우 결과는 10 진수입니다.</target>
        </trans-unit>
        <trans-unit id="3fe8998e5882166277459acbf3ed32be674074c4" translate="yes" xml:space="preserve">
          <source>If either of the arguments is of a temporal type with a zero fractional second precision (time(0), date, datetime(0), timestamp(0)), the result may vary between int, int unsigned, bigint or bigint unsigned, depending on the exact data type combination.</source>
          <target state="translated">인수 중 하나가 소수 초 정밀도 (time (0), date, datetime (0), timestamp (0))가 0 인 시간 유형 인 경우 결과는 int, int unsigned, bigint 또는 bigint unsigned, 정확한 데이터 유형 조합에 따라</target>
        </trans-unit>
        <trans-unit id="f2d75ba4a25e6b88ba265b8fb9c44a0cf34c636f" translate="yes" xml:space="preserve">
          <source>If either of the previously mentioned system variables is set to &lt;code&gt;ON&lt;/code&gt;, then &lt;code&gt;OPTIMIZE TABLE&lt;/code&gt; will optimize some data without rebuilding the table. However, the file size will not be reduced.</source>
          <target state="translated">앞에서 언급 한 시스템 변수 중 하나가 &lt;code&gt;ON&lt;/code&gt; 으로 설정 되면 &lt;code&gt;OPTIMIZE TABLE&lt;/code&gt; 은 테이블을 다시 작성하지 않고 일부 데이터를 최적화합니다. 그러나 파일 크기는 줄어들지 않습니다.</target>
        </trans-unit>
        <trans-unit id="126c0440e2f2155a4aafd1f086872c6bb8742a17" translate="yes" xml:space="preserve">
          <source>If either the expression or the pattern is &lt;code&gt;NULL&lt;/code&gt;, the result is &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">표현식 또는 패턴이 &lt;code&gt;NULL&lt;/code&gt; 이면 결과는 &lt;code&gt;NULL&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d46d30d2d5b0f3afe445f79bb6149bc47a43b796" translate="yes" xml:space="preserve">
          <source>If errors like this occur, then critical &lt;a href=&quot;../system-tables/index&quot;&gt;system tables&lt;/a&gt; are either missing or are in the wrong location. The above error is quite common after an upgrade if the &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;option files&lt;/a&gt; set the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#basedir&quot;&gt;basedir&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#datadir&quot;&gt;datadir&lt;/a&gt;&lt;/code&gt; to a non-standard location, but the new server is using the default location. Therefore, make sure that the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#basedir&quot;&gt;basedir&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#datadir&quot;&gt;datadir&lt;/a&gt;&lt;/code&gt; variables are correctly set.</source>
          <target state="translated">이와 같은 오류가 발생하면 중요한 &lt;a href=&quot;../system-tables/index&quot;&gt;시스템 테이블&lt;/a&gt; 이 없거나 잘못된 위치에 있습니다. &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;옵션 파일&lt;/a&gt; 이 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#basedir&quot;&gt;basedir&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#datadir&quot;&gt;datadir&lt;/a&gt;&lt;/code&gt; 을 비표준 위치로 설정했지만 새 서버가 기본 위치를 사용하는 경우 업그레이드 후 위의 오류가 발생 합니다. 따라서 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#basedir&quot;&gt;basedir&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#datadir&quot;&gt;datadir&lt;/a&gt;&lt;/code&gt; 변수가 올바르게 설정되어 있는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="59cb28e02f8e1281549fc11a694990f590977d10" translate="yes" xml:space="preserve">
          <source>If expr is greater than or equal to min and expr is less than or equal to max, BETWEEN returns 1, otherwise it returns 0. This is equivalent to the expression (min &amp;lt;= expr AND expr &amp;lt;= max) if all the arguments are of the same type. Otherwise type conversion takes place according to the rules described at &lt;a href=&quot;../type-conversion/index&quot;&gt;Type Conversion&lt;/a&gt;, but applied to all the three arguments.</source>
          <target state="translated">expr이 min보다 크거나 같고 expr이 max보다 작거나 같으면 BETWEEN은 1을 리턴하고 그렇지 않으면 0을 리턴합니다. 모든 인수가 다음과 같은 경우 표현식 (min &amp;lt;= expr AND expr &amp;lt;= max) 같은 유형의. 그렇지 않으면 변환에 설명 된 규칙에 따라 발생하는 입력 &lt;a href=&quot;../type-conversion/index&quot;&gt;형식 변환&lt;/a&gt; 하지만, 세 가지 인수 모두에 적용.</target>
        </trans-unit>
        <trans-unit id="bab85475abdab5b1d620aa7b1fa4fc4e6e324694" translate="yes" xml:space="preserve">
          <source>If expr1 is TRUE, returns expr2; otherwise it returns expr3.</source>
          <target state="translated">expr1이 TRUE이면 expr2를 리턴합니다. 그렇지 않으면 expr3을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="90546835a6d0513f7ca0b1799ad2721e0bc6deb3" translate="yes" xml:space="preserve">
          <source>If expr1 is TRUE, returns expr2; otherwise returns expr3</source>
          <target state="translated">expr1이 TRUE이면 expr2를 리턴합니다. 그렇지 않으면 expr3을 반환</target>
        </trans-unit>
        <trans-unit id="2f6e9105002de0a764420ac63706ea88bb534845" translate="yes" xml:space="preserve">
          <source>If format is given, the result is formatted according to the format string, which is used the same way as listed in the entry for the &lt;a href=&quot;../date_format/index&quot;&gt;DATE_FORMAT()&lt;/a&gt; function.</source>
          <target state="translated">형식이 지정되면 결과는 형식 문자열에 따라 형식이 지정되며 &lt;a href=&quot;../date_format/index&quot;&gt;DATE_FORMAT ()&lt;/a&gt; 함수 의 항목에 나열된 것과 동일한 방식으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="edb0fbce34dc47e0e176d7e5b8fae2a1acc89215" translate="yes" xml:space="preserve">
          <source>If group_concat_max_len &amp;lt;= 512, the return type is &lt;a href=&quot;../varbinary/index&quot;&gt;VARBINARY&lt;/a&gt; or &lt;a href=&quot;../varchar/index&quot;&gt;VARCHAR&lt;/a&gt;; otherwise, the return type is &lt;a href=&quot;../blob/index&quot;&gt;BLOB&lt;/a&gt; or &lt;a href=&quot;../text/index&quot;&gt;TEXT&lt;/a&gt;. The choice between binary or non-binary types depends from the input.</source>
          <target state="translated">group_concat_max_len &amp;lt;= 512 인 경우 리턴 유형은 &lt;a href=&quot;../varbinary/index&quot;&gt;VARBINARY&lt;/a&gt; 또는 &lt;a href=&quot;../varchar/index&quot;&gt;VARCHAR입니다&lt;/a&gt; . 그렇지 않으면 리턴 유형은 &lt;a href=&quot;../blob/index&quot;&gt;BLOB&lt;/a&gt; 또는 &lt;a href=&quot;../text/index&quot;&gt;TEXT&lt;/a&gt; 입니다. 이진 또는 비 이진 유형 중에서 선택하는 것은 입력에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="a26a11b60ba1c80438add35a4fab2ba226543189" translate="yes" xml:space="preserve">
          <source>If hard commit and aria_group_commit_interval &amp;gt; 0</source>
          <target state="translated">하드 커밋 및 aria_group_commit_interval&amp;gt; 0 인 경우</target>
        </trans-unit>
        <trans-unit id="1ff06e1c60a795c6af80134eca2440e73c50dfa6" translate="yes" xml:space="preserve">
          <source>If hard commit and aria_group_commit_interval=0</source>
          <target state="translated">하드 커밋 및 aria_group_commit_interval = 0 인 경우</target>
        </trans-unit>
        <trans-unit id="01cee20400a91a71dd027bfe44946669c796dbdb" translate="yes" xml:space="preserve">
          <source>If hard group commit is enabled (aria_group_commit=&quot;hard&quot;)</source>
          <target state="translated">하드 그룹 커밋이 활성화 된 경우 (aria_group_commit = &quot;hard&quot;)</target>
        </trans-unit>
        <trans-unit id="1e6ff61c63938ded4020e4fb0f466c8d1b56f1ea" translate="yes" xml:space="preserve">
          <source>If innodb_buffer_pool_size is set to more than 1GB, &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_buffer_pool_instances&quot;&gt;innodb_buffer_pool_instances&lt;/a&gt; divides the InnoDB buffer pool into a specific number of instances. The default was 1 in &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt;, but for large systems with buffer pools of many gigabytes, many instances can help reduce contention concurrency. The default is 8 in &lt;a href=&quot;../what-is-mariadb-100/index&quot;&gt;MariaDB 10.0&lt;/a&gt;, with the exception of 32-bit Windows, where it depends on the value of &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_buffer_pool_instances&quot;&gt;innodb_buffer_pool_size&lt;/a&gt;. Each instance manages its own data structures and takes an equal portion of the total buffer pool size, so for example if innodb_buffer_pool_size is 4GB and innodb_buffer_pool_instances is set to 4, each instance will be 1GB. Each instance should ideally be at least 1GB in size.</source>
          <target state="translated">innodb_buffer_pool_size 더 1기가바이트 이상으로 설정하면 &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_buffer_pool_instances&quot;&gt;innodb_buffer_pool_instances의&lt;/a&gt; 인스턴스의 특정 번호로 나누는 이노 버퍼 풀. &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt; 의 기본값은 1입니다. 이지만 버퍼 풀이 기가 바이트 인 대규모 시스템의 경우 많은 인스턴스가 경합 동시성을 줄이는 데 도움이됩니다. 32 비트 Windows를 제외하고 &lt;a href=&quot;../what-is-mariadb-100/index&quot;&gt;MariaDB 10.0&lt;/a&gt; 의 기본값은 8 이며 &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_buffer_pool_instances&quot;&gt;innodb_buffer_pool_size&lt;/a&gt; 값에 따라 다릅니다 . 각 인스턴스는 자체 데이터 구조를 관리하고 총 버퍼 풀 크기의 동일한 부분을 차지하므로 예를 들어 innodb_buffer_pool_size가 4GB이고 innodb_buffer_pool_instances가 4로 설정된 경우 각 인스턴스는 1GB입니다. 각 인스턴스의 크기는 1GB 이상이어야합니다.</target>
        </trans-unit>
        <trans-unit id="83a2f113a4407faf3413931094a05bd8ce1c8eda" translate="yes" xml:space="preserve">
          <source>If installing a single combined functionality server with no plans to add additional servers, Single Node should be chosen.</source>
          <target state="translated">서버를 추가 할 계획없이 단일 기능 서버를 설치할 경우 단일 노드를 선택해야합니다.</target>
        </trans-unit>
        <trans-unit id="20e27b501e6ee844de03427cd2d21d5b1cf4ce23" translate="yes" xml:space="preserve">
          <source>If installing a single combined functionality server with no plans to add additional servers, Single Node should be chosen. Going from single server to multi-server configuration to another will require a re-installation of the MariaDB ColumnStore software.</source>
          <target state="translated">서버를 추가 할 계획없이 단일 기능 서버를 설치할 경우 단일 노드를 선택해야합니다. 단일 서버에서 다중 서버 구성으로 이동하려면 MariaDB ColumnStore 소프트웨어를 다시 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="09073039136ffa103c941b7d58ce4960a80c5152" translate="yes" xml:space="preserve">
          <source>If installing on a system where there is a need to multi servers initially planned in the future, you would be a multi server install instead of a single server install.</source>
          <target state="translated">나중에 초기에 다중 서버를 계획해야하는 시스템에 설치하는 경우 단일 서버 설치 대신 다중 서버 설치가됩니다.</target>
        </trans-unit>
        <trans-unit id="03c489def6f8b1691a065a4b38ae8a5a4f396e0d" translate="yes" xml:space="preserve">
          <source>If it doesn't already exist, you can use the sample configuration file, &lt;code&gt;sphinx.conf.dist&lt;/code&gt;. There is also sample data supplied that we can use for testing. Load the sample data (which creates two tables, &lt;code&gt;documents&lt;/code&gt; and &lt;code&gt;tags&lt;/code&gt; in the &lt;code&gt;test&lt;/code&gt; database), for example:</source>
          <target state="translated">존재하지 않는 경우 샘플 구성 파일 &lt;code&gt;sphinx.conf.dist&lt;/code&gt; 를 사용할 수 있습니다 . 테스트에 사용할 수있는 샘플 데이터도 있습니다. 샘플 데이터로드 ( &lt;code&gt;test&lt;/code&gt; 에서 두 개의 테이블, &lt;code&gt;documents&lt;/code&gt; 및 &lt;code&gt;tags&lt;/code&gt; 생성) 데이터베이스 ). 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="10313cbceff2e09dd562dd2035a811cdc7598319" translate="yes" xml:space="preserve">
          <source>If it has been correctly installed, &lt;a href=&quot;../show-engines/index&quot;&gt;SHOW ENGINES&lt;/a&gt; will list the Sequence storage engine as supported:</source>
          <target state="translated">올바르게 설치된 경우 &lt;a href=&quot;../show-engines/index&quot;&gt;SHOW ENGINES&lt;/a&gt; 는 시퀀스 스토리지 엔진을 지원되는 것으로 나열합니다.</target>
        </trans-unit>
        <trans-unit id="d557e942d1753c13960fd82c7fcb12a534cb6624" translate="yes" xml:space="preserve">
          <source>If it is &lt;code&gt;DISABLED&lt;/code&gt;, then the server was compiled with TLS support, but TLS is not enabled.</source>
          <target state="translated">이 경우 &lt;code&gt;DISABLED&lt;/code&gt; , 서버가 TLS 지원하도록 컴파일 되었으나, TLS는 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="357aee6bf326713765236d405e325bcf08786459" translate="yes" xml:space="preserve">
          <source>If it is &lt;code&gt;NO&lt;/code&gt;, then the server was not compiled with TLS support.</source>
          <target state="translated">이 경우 &lt;code&gt;NO&lt;/code&gt; 를 , 서버가 TLS 지원으로 컴파일되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="2a9dab232a5fd6aef9087a9527f81812806fc89e" translate="yes" xml:space="preserve">
          <source>If it is &lt;code&gt;YES&lt;/code&gt;, then the server was compiled with TLS support, and TLS is enabled.</source>
          <target state="translated">이 경우 &lt;code&gt;YES&lt;/code&gt; , 서버가 TLS 지원으로 컴파일하고, TLS가 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="c6f25e4d70589cf33e081d3590a1dcfc0c132f42" translate="yes" xml:space="preserve">
          <source>If it is InnoDB, the query should be rolled back. (Exceptions??)</source>
          <target state="translated">InnoDB 인 경우 쿼리를 롤백해야합니다. (예외 ??)</target>
        </trans-unit>
        <trans-unit id="1e3522b29737f27a1d8c7272ca6a5364594f77c7" translate="yes" xml:space="preserve">
          <source>If it is a crawler ('spider') that read all the pages, then it actually touched about 125,000,000 items to read all 5,000 pages.</source>
          <target state="translated">모든 페이지를 읽는 크롤러 ( '거미') 인 경우 실제로는 약 125,000,000 개의 항목을 터치하여 5,000 페이지를 모두 읽습니다.</target>
        </trans-unit>
        <trans-unit id="a188114c6fd49eaf1a99621a2ceec4a56900e3b8" translate="yes" xml:space="preserve">
          <source>If it is a relative path, then the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#general_log_file&quot;&gt;general_log_file&lt;/a&gt;&lt;/code&gt; is relative to the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#datadir&quot;&gt;datadir&lt;/a&gt;&lt;/code&gt; directory.</source>
          <target state="translated">상대 경로 인 경우 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#general_log_file&quot;&gt;general_log_file&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#datadir&quot;&gt;datadir&lt;/a&gt;&lt;/code&gt; 디렉토리에 상대적 입니다.</target>
        </trans-unit>
        <trans-unit id="ea122d9b1bd4cc491169def9b779ae5c641b2ee5" translate="yes" xml:space="preserve">
          <source>If it is a relative path, then the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#log_error&quot;&gt;log_error&lt;/a&gt;&lt;/code&gt; is relative to the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#datadir&quot;&gt;datadir&lt;/a&gt;&lt;/code&gt; directory.</source>
          <target state="translated">상대 경로 인 경우 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#log_error&quot;&gt;log_error&lt;/a&gt;&lt;/code&gt; 는 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#datadir&quot;&gt;datadir&lt;/a&gt;&lt;/code&gt; 디렉토리에 상대적 입니다.</target>
        </trans-unit>
        <trans-unit id="b9f50377949bdfe601f2a39eaf2bc21fb2ab5f1d" translate="yes" xml:space="preserve">
          <source>If it is a relative path, then the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#slow_query_log_file&quot;&gt;slow_query_log_file&lt;/a&gt;&lt;/code&gt; is relative to the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#datadir&quot;&gt;datadir&lt;/a&gt;&lt;/code&gt; directory.</source>
          <target state="translated">상대 경로 인 경우 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#slow_query_log_file&quot;&gt;slow_query_log_file&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#datadir&quot;&gt;datadir&lt;/a&gt;&lt;/code&gt; 디렉토리에 상대적 입니다.</target>
        </trans-unit>
        <trans-unit id="944f8f1f37f2ac24385ee68352d362dc9ce5f7b9" translate="yes" xml:space="preserve">
          <source>If it is prefixed with &lt;code&gt;FILE:&lt;/code&gt;, then it can be a path to a file that contains the plain-text encryption password.</source>
          <target state="translated">접 두부가 &lt;code&gt;FILE:&lt;/code&gt; 이면 일반 텍스트 암호화 비밀번호가 포함 된 파일의 경로 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce5fe7571c1082e5d94321cb9fd0cb036a1756d3" translate="yes" xml:space="preserve">
          <source>If it is undesirable that changes to the binlog on the slave affects the GTID replication position, then &lt;code&gt;master_use_gtid=slave_pos&lt;/code&gt; should be used. Then the slave will always connect to the master at the position of the last replicated GTID. This may avoid some surprises for users that expect behaviour consistent with traditional replication, where the replication position is never changed by local changes done on a server.</source>
          <target state="translated">슬레이브의 binlog 변경이 GTID 복제 위치에 영향을 미치는 것이 바람직하지 않은 경우 &lt;code&gt;master_use_gtid=slave_pos&lt;/code&gt; 를 사용해야합니다. 그런 다음 슬레이브는 항상 마지막으로 복제 된 GTID의 위치에서 마스터에 연결됩니다. 이것은 서버에서 수행 된 로컬 변경에 의해 복제 위치가 변경되지 않는 기존 복제와 일치하는 동작을 기대하는 사용자에게는 놀라운 일이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="a7625f403ec831fe19e1aa6e962eca01fcd3f768" translate="yes" xml:space="preserve">
          <source>If it's UNDEFINED (or the ALGORITHM clause is not used), MariaDB will choose what it thinks is the best algorithm. An algorithm can also be UNDEFINED if its defined as MERGE, but the view requires a temporary table.</source>
          <target state="translated">UNDEFINED이거나 ALGORITHM 절을 사용하지 않으면 MariaDB는 최상의 알고리즘이라고 생각하는 것을 선택합니다. 알고리즘이 MERGE로 정의 된 경우 알고리즘을 UNDEFINED로 지정할 수도 있지만 뷰에 임시 테이블이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="f1f4fbd68d81d8e26d18351f9836414f59bde96f" translate="yes" xml:space="preserve">
          <source>If it's set to &lt;code&gt;0&lt;/code&gt;, then heartbeats are disabled.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; 으로 설정되면 하트 비트가 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="570153a562589e506938c11b4adc455b7fcadc33" translate="yes" xml:space="preserve">
          <source>If its a multi-server system and ssh-keys are not configured between the servers, you will be required to provide the user password for the other servers. If ssh-keys are configured, then password parameter isn't required</source>
          <target state="translated">다중 서버 시스템과 ssh 키가 서버간에 구성되지 않은 경우 다른 서버의 사용자 비밀번호를 제공해야합니다. ssh 키가 구성된 경우 비밀번호 매개 변수가 필요하지 않습니다</target>
        </trans-unit>
        <trans-unit id="bcff3de86e7dcbca317880b9b65374720e508806" translate="yes" xml:space="preserve">
          <source>If its failing in the remote server install section, go via the install logs in /tmp to see why the failure occurred. It could be related to these issues:</source>
          <target state="translated">원격 서버 설치 섹션에서 실패하면 / tmp의 설치 로그를 통해 실패 원인을 확인하십시오. 다음과 같은 문제와 관련이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eaf385de842fce0b3c93d1297c337fa95ccf2153" translate="yes" xml:space="preserve">
          <source>If left out, the &lt;code&gt;DEFINER&lt;/code&gt; is treated as the account that created the stored routine or view. If the account creating the routine has the &lt;code&gt;SUPER&lt;/code&gt; privilege, another account can be specified as the &lt;code&gt;DEFINER&lt;/code&gt;.</source>
          <target state="translated">생략하면 &lt;code&gt;DEFINER&lt;/code&gt; 는 저장 루틴 또는 뷰를 생성 한 계정으로 취급됩니다. 루틴을 작성하는 계정에 &lt;code&gt;SUPER&lt;/code&gt; 특권 이 있으면 다른 계정을 &lt;code&gt;DEFINER&lt;/code&gt; 로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ccc33871a670df5dded45070bd810d0f65c893e4" translate="yes" xml:space="preserve">
          <source>If less than rate microseconds has passed since the last sync, then after buffers have been sent to disk, wait until rate microseconds has passed since last sync, do sync and return. This ensures that if we call sync infrequently we don't do any waits.</source>
          <target state="translated">마지막 동기화 이후 속도 마이크로 초 미만이 지나면 버퍼가 디스크로 전송 된 후 마지막 동기화 이후 속도 마이크로 초가 경과 할 때까지 기다렸다가 동기화 및 리턴하십시오. 이를 통해 동기화를 자주 호출하지 않으면 대기하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5362dfcff244dcbe90d359206036d2ebafad4777" translate="yes" xml:space="preserve">
          <source>If lock-ddl-per-table is not done, then Mariabackup would have to know all tables that were created or altered during the backup. See &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-16791&quot;&gt;MDEV-16791&lt;/a&gt;.</source>
          <target state="translated">테이블 당 lock-ddl이 수행되지 않으면 Mariabackup은 백업 중에 작성되거나 변경된 모든 테이블을 알아야합니다. &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-16791&quot;&gt;MDEV-16791을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="56355a71312088032d8567e066f8d6177df0ba39" translate="yes" xml:space="preserve">
          <source>If log tables exists:</source>
          <target state="translated">로그 테이블이 존재하는 경우 :</target>
        </trans-unit>
        <trans-unit id="87663dd54b06cd3118a286f808b1bc94f9cba322" translate="yes" xml:space="preserve">
          <source>If more than one of the &lt;strong&gt;Key&lt;/strong&gt; values applies to a given column of a table, &lt;strong&gt;Key&lt;/strong&gt; displays the one with the highest priority, in the order PRI, UNI, MUL.</source>
          <target state="translated">둘 이상의 &lt;strong&gt;키&lt;/strong&gt; 값이 테이블의 지정된 열에 적용되는 경우 &lt;strong&gt;키&lt;/strong&gt; 는 우선 순위가 가장 높은 값을 PRI, UNI, MUL 순서로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="3bf8e49e7ed852ce1a46ef2a893afa0117d0720a" translate="yes" xml:space="preserve">
          <source>If more than one unique index is matched, only the first is updated. It is not recommended to use this statement on tables with more than one unique index.</source>
          <target state="translated">둘 이상의 고유 인덱스가 일치하면 첫 번째 인덱스 만 업데이트됩니다. 고유 인덱스가 둘 이상인 테이블에서는이 명령문을 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="10ae0f4c509411c20e9a7f9ee8908f1797074f60" translate="yes" xml:space="preserve">
          <source>If multi-source replication is used, this statement applies to the default connection. It could be necessary to change the value of the &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#default_master_connection&quot;&gt;default_master_connection&lt;/a&gt;&lt;/code&gt; server system variable.</source>
          <target state="translated">다중 소스 복제가 사용되는 경우이 명령문은 기본 연결에 적용됩니다. &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#default_master_connection&quot;&gt;default_master_connection&lt;/a&gt;&lt;/code&gt; 서버 시스템 변수 의 값을 변경해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="59d5872de01573c421b02e831dd14b8ce97107f7" translate="yes" xml:space="preserve">
          <source>If multiple GTIDs are specified, then they must be with distinct replication domain ID, for example:</source>
          <target state="translated">여러 GTID가 지정된 경우 고유 한 복제 도메인 ID를 가져야합니다 (예 :</target>
        </trans-unit>
        <trans-unit id="0fa2998a5a8ef8da9adb6d70b33d0c6bc89423a3" translate="yes" xml:space="preserve">
          <source>If multiple MariaDB Server process are running on the same server, then at minimum, you will need to ensure that the different instances do not use the same &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#datadir&quot;&gt;datadir&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#port&quot;&gt;port&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#socket&quot;&gt;socket&lt;/a&gt;&lt;/code&gt;. The following example shows these options set in an &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;option file&lt;/a&gt;:</source>
          <target state="translated">여러 MariaDB 서버 프로세스가 동일한 서버에서 실행중인 경우 최소한 다른 인스턴스가 동일한 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#datadir&quot;&gt;datadir&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#port&quot;&gt;port&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#socket&quot;&gt;socket&lt;/a&gt;&lt;/code&gt; 을 사용하지 않아야 합니다 . 다음 예제는 &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;옵션 파일에&lt;/a&gt; 설정된 옵션을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="d9e005e2b03368aefd249081157d88b0d3f8d3e4" translate="yes" xml:space="preserve">
          <source>If my.cnf says type=ON and you later turn it OFF, it is not fully OFF. Ref: &lt;a href=&quot;https://bugs.mysql.com/bug.php?id=60696&quot;&gt;https://bugs.mysql.com/bug.php?id=60696&lt;/a&gt;</source>
          <target state="translated">my.cnf가 type = ON이라고 말하고 나중에 끄면 완전히 꺼지지 않습니다. 참조 : &lt;a href=&quot;https://bugs.mysql.com/bug.php?id=60696&quot;&gt;https://bugs.mysql.com/bug.php?id=60696&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c25fb38765dbaeeff5d78b6a671a9e7db059b9e0" translate="yes" xml:space="preserve">
          <source>If mysql-test-run.pl is started with the &lt;code&gt;--ssl&lt;/code&gt; option, it sets up a &lt;a href=&quot;../secure-connections-overview/index&quot;&gt;secure connection&lt;/a&gt; for all test cases. In this case, if mysqld does not support TLS, mysql-test-run.pl exits with an error message: &lt;code&gt;Couldn&amp;acute;t find support for SSL&lt;/code&gt;.</source>
          <target state="translated">mysql-test-run.pl이 &lt;code&gt;--ssl&lt;/code&gt; 옵션으로 시작되면 모든 테스트 사례에 대해 &lt;a href=&quot;../secure-connections-overview/index&quot;&gt;안전한 연결&lt;/a&gt; 을 설정합니다 . 이 경우 mysqld가 TLS를 지원하지 않으면 mysql-test-run.pl이 다음 오류 메시지와 함께 종료됩니다 . &lt;code&gt;Couldn&amp;acute;t find support for SSL&lt;/code&gt; 하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3584c3e17d8d42af8e619f90cdbcde385ae28ed4" translate="yes" xml:space="preserve">
          <source>If mysqld_safe cannot find the server, use this option to indicate the path name to the directory where the server is located.</source>
          <target state="translated">mysqld_safe가 서버를 찾을 수 없으면이 옵션을 사용하여 서버가있는 디렉토리의 경로 이름을 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="08bf0b60635b7b14dfec77f3314b4cb71b67ccf5" translate="yes" xml:space="preserve">
          <source>If mysqldump was utilized then the backup script is run:</source>
          <target state="translated">mysqldump가 사용 된 경우 백업 스크립트가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="2d9a7d4caa0fc48a98dede86068ad4846ed9c06c" translate="yes" xml:space="preserve">
          <source>If necessary, you can remove found MySQL packages before installing MariaDB.</source>
          <target state="translated">필요한 경우 MariaDB를 설치하기 전에 찾은 MySQL 패키지를 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="699a415989366c59de0d0a139aa2b6effb9939af" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;QUICK&lt;/code&gt; nor &lt;code&gt;EXTENDED&lt;/code&gt; is specified, MariaDB returns a live checksum if the table storage engine supports it and scans the table otherwise.</source>
          <target state="translated">&lt;code&gt;QUICK&lt;/code&gt; 또는 &lt;code&gt;EXTENDED&lt;/code&gt; 가 지정 되지 않은 경우 , MariaDB는 테이블 스토리지 엔진이이를 지원하면 라이브 체크섬을 리턴하고 그렇지 않으면 테이블을 스캔합니다.</target>
        </trans-unit>
        <trans-unit id="359f09cf4f6ca95912714f072049745b185689e8" translate="yes" xml:space="preserve">
          <source>If neither character set nor collation is provided, the database default will be used. If only the character set is provided, the default collation for that character set will be used . If only the collation is provided, the associated character set will be used. See &lt;a href=&quot;../supported-character-sets-and-collations/index&quot;&gt;Supported Character Sets and Collations&lt;/a&gt;.</source>
          <target state="translated">문자 집합이나 데이터 정렬이 제공되지 않으면 데이터베이스 기본값이 사용됩니다. 문자 세트 만 제공되는 경우 해당 문자 세트의 기본 데이터 정렬이 사용됩니다. 데이터 정렬 만 제공하면 관련 문자 집합이 사용됩니다. &lt;a href=&quot;../supported-character-sets-and-collations/index&quot;&gt;지원되는 문자 집합 및 데이터 정렬을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c9ec78a36613987bcb93e3fe3c840a9553e5f423" translate="yes" xml:space="preserve">
          <source>If neither collation nor character set is provided, the table default is used. If only the character set is specified, that character set's default collation is used, while if only the collation is specified, the associated character set is used.</source>
          <target state="translated">데이터 정렬이나 문자 집합이 제공되지 않으면 테이블 기본값이 사용됩니다. 문자 세트 만 지정하면 해당 문자 세트의 기본 데이터 정렬이 사용되며, 데이터 정렬 만 지정하면 연관된 문자 세트가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5854bbc26f1508675f7df4645c029d01f9654bc2" translate="yes" xml:space="preserve">
          <source>If neither of the above is true, you have to do this step manually:</source>
          <target state="translated">위의 어느 것도 해당되지 않으면이 단계를 수동으로 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="d74ebd68531b5d37d1f68ba77fa5ab7d9d75455d" translate="yes" xml:space="preserve">
          <source>If neither variable is set, the built-in list is used, which can be viewed by querying the &lt;a href=&quot;../information-schema-innodb_ft_default_stopword-table/index&quot;&gt;INNODB_FT_DEFAULT_STOPWORD table&lt;/a&gt; in the &lt;a href=&quot;../information_schema/index&quot;&gt;Information Schema&lt;/a&gt;.</source>
          <target state="translated">변수가 설정되지 않은 경우 내장 목록이 사용 되며 &lt;a href=&quot;../information_schema/index&quot;&gt;정보 스키마&lt;/a&gt; 의 &lt;a href=&quot;../information-schema-innodb_ft_default_stopword-table/index&quot;&gt;INNODB_FT_DEFAULT_STOPWORD 테이블&lt;/a&gt; 을 조회하여 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bf7dd148a9455ada5fe8a7ff5b7f2fb0c981f2c1" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;key_str&lt;/code&gt; argument is given, &lt;code&gt;DES_DECRYPT()&lt;/code&gt; examines the first byte of the encrypted string to determine the DES key number that was used to encrypt the original string, and then reads the key from the DES key file to decrypt the message. For this to work, the user must have the SUPER privilege. The key file can be specified with the &lt;code&gt;--des-key-file&lt;/code&gt; server option.</source>
          <target state="translated">&lt;code&gt;key_str&lt;/code&gt; 인수가 제공 되지 않으면 &lt;code&gt;DES_DECRYPT()&lt;/code&gt; 는 암호화 된 문자열의 첫 번째 바이트를 검사하여 원래 문자열을 암호화하는 데 사용 된 DES 키 번호를 판별 한 다음 DES 키 파일에서 키를 읽고 메시지를 해독합니다. 이것이 작동하려면 사용자에게 SUPER 권한이 있어야합니다. 키 파일은 &lt;code&gt;--des-key-file&lt;/code&gt; 서버 옵션 으로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c0e89803960926cc24a7580823adb339b5a45525" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;special_characters&lt;/code&gt; parameter is provided, by default &lt;code&gt;+-&amp;lt;&amp;gt;*()&quot;:&lt;/code&gt; are escaped.</source>
          <target state="translated">&lt;code&gt;special_characters&lt;/code&gt; 매개 변수가 제공 되지 않으면 기본적으로 &lt;code&gt;+-&amp;lt;&amp;gt;*()&quot;:&lt;/code&gt; 이스케이프됩니다.</target>
        </trans-unit>
        <trans-unit id="55eba54ddb942f7b88950aa9c326e1d7cd6d70c7" translate="yes" xml:space="preserve">
          <source>If no collation is provided, the collation will be set to the default collation for that character set. See &lt;a href=&quot;../supported-character-sets-and-collations/index&quot;&gt;Supported Character Sets and Collations&lt;/a&gt;.</source>
          <target state="translated">데이터 정렬이 제공되지 않으면 해당 문자 세트의 기본 데이터 정렬이 데이터 정렬로 설정됩니다. &lt;a href=&quot;../supported-character-sets-and-collations/index&quot;&gt;지원되는 문자 집합 및 데이터 정렬을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9ec03a276e56cfe5999896902e9c0ceb8f8ba2c4" translate="yes" xml:space="preserve">
          <source>If no database is given then all matching databases are shown. If no table is given, then all matching tables in database are shown. If no column is given, then all matching columns and column types in table are shown.</source>
          <target state="translated">데이터베이스가 제공되지 않으면 일치하는 모든 데이터베이스가 표시됩니다. 테이블이 제공되지 않으면 데이터베이스의 모든 일치하는 테이블이 표시됩니다. 열이 제공되지 않으면 테이블의 모든 일치하는 열과 열 유형이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="2572838d20a21da9b51127c916041a6679931315" translate="yes" xml:space="preserve">
          <source>If no more rows are available, a No Data condition occurs with &lt;code&gt;SQLSTATE&lt;/code&gt; value &lt;code&gt;02000&lt;/code&gt;. To detect this condition, you can set up a handler for it (or for a &lt;code&gt;NOT FOUND&lt;/code&gt; condition).</source>
          <target state="translated">사용 가능한 행이 더 이상 없으면 &lt;code&gt;SQLSTATE&lt;/code&gt; 값이 &lt;code&gt;02000&lt;/code&gt; 인 데이터 없음 조건이 발생합니다 . 이 조건을 감지하기 위해 처리기 (또는 &lt;code&gt;NOT FOUND&lt;/code&gt; 조건)에 대한 핸들러를 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fccda02db0b26d4e635725bc4979ca65e31cdfb5" translate="yes" xml:space="preserve">
          <source>If no option is provided, myisamchk will perform a check table. It is possible to check &lt;a href=&quot;../myisam/index&quot;&gt;MyISAM&lt;/a&gt; tables without shutting down or restricting access to the server by using &lt;a href=&quot;../check-table/index&quot;&gt;CHECK TABLE&lt;/a&gt; instead.</source>
          <target state="translated">옵션이 제공되지 않으면 myisamchk가 점검 테이블을 수행합니다. 대신 &lt;a href=&quot;../check-table/index&quot;&gt;CHECK TABLE&lt;/a&gt; 을 사용하여 서버에 대한 액세스를 종료하거나 제한하지 않고 &lt;a href=&quot;../myisam/index&quot;&gt;MyISAM&lt;/a&gt; 테이블 을 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="02c09151fa7e8d8d69d7c60ac32b8faedc7cbda3" translate="yes" xml:space="preserve">
          <source>If no rows were successfully inserted, LAST_INSERT_ID() returns 0.</source>
          <target state="translated">행이 성공적으로 삽입되지 않으면 LAST_INSERT_ID ()는 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c415eb78832ce6bdb2bcb4e561042d7db14c5386" translate="yes" xml:space="preserve">
          <source>If no schema is indicated as part of event_name, the default (current) schema is assumed.</source>
          <target state="translated">event_name의 일부로 스키마가 표시되지 않으면 기본 (현재) 스키마가 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="6e69697ac0901e7ff10a8fa554808fce55650472" translate="yes" xml:space="preserve">
          <source>If no service name is specified, then the plugin will use &lt;code&gt;mysql&lt;/code&gt; as the default &lt;a href=&quot;#configuring-the-pam-service&quot;&gt;PAM service name&lt;/a&gt;.</source>
          <target state="translated">서비스 이름을 지정하지 않으면 플러그인은 &lt;code&gt;mysql&lt;/code&gt; 을 기본 &lt;a href=&quot;#configuring-the-pam-service&quot;&gt;PAM 서비스 이름으로 사용&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="eea1e8e810a084b213dc42ad0a4ec9f1634ae1c8" translate="yes" xml:space="preserve">
          <source>If no when_value or search_condition matches the value tested and the &lt;code&gt;CASE&lt;/code&gt; statement contains no &lt;code&gt;ELSE&lt;/code&gt; clause, a Case not found for &lt;code&gt;CASE&lt;/code&gt; statement error results.</source>
          <target state="translated">when_value 또는 search_condition이 테스트 된 값과 일치 하지 않고 &lt;code&gt;CASE&lt;/code&gt; 문에 &lt;code&gt;ELSE&lt;/code&gt; 절이 없으면 &lt;code&gt;CASE&lt;/code&gt; 문 오류에 대한 케이스를 찾을 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="27bb70f6b4374a87239bcec2fac21a1cf35d715e" translate="yes" xml:space="preserve">
          <source>If non-zero, how long queries can run before being killed automatically.</source>
          <target state="translated">0이 아닌 경우 자동으로 종료되기 전에 쿼리를 얼마나 오래 실행할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="82cc268d6c3c0cf84f55dc1bd95247e04e040fce" translate="yes" xml:space="preserve">
          <source>If none of these options is provided, then the default is &lt;code&gt;--skip-syslog&lt;/code&gt;.</source>
          <target state="translated">이러한 옵션을 제공하지 않으면 기본값은 &lt;code&gt;--skip-syslog&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1061e3272d05985acac5966782cc2a9cd4db01ec" translate="yes" xml:space="preserve">
          <source>If not closed explicitly, a cursor is closed at the end of the compound statement in which it was declared.</source>
          <target state="translated">명시 적으로 닫히지 않으면 선언 된 복합 명령문의 끝에서 커서가 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="42d9806b3ecf0c33f769d42ff70fbeaf487c00af" translate="yes" xml:space="preserve">
          <source>If not enough, repeat, doubling the width of the square.</source>
          <target state="translated">충분하지 않으면 반복하여 사각형의 너비를 두 배로 늘립니다.</target>
        </trans-unit>
        <trans-unit id="491a01cfd6659e31f46619bcf28fe231c96b9f22" translate="yes" xml:space="preserve">
          <source>If not set, division by zero returns NULL. If set returns an error if one tries to update a column with 1/0 and returns a warning as well. Also see &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-8319&quot;&gt;MDEV-8319&lt;/a&gt;. Default since &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1024-release-notes/&quot;&gt;MariaDB 10.2.4&lt;/a&gt;.</source>
          <target state="translated">설정하지 않으면 0으로 나누기가 NULL을 반환합니다. set이 1/0으로 열을 업데이트하려고 시도하면 오류를 반환하고 경고도 반환합니다. &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-8319&quot;&gt;MDEV-8319&lt;/a&gt; 도 참조하십시오 . &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1024-release-notes/&quot;&gt;MariaDB 10.2.4&lt;/a&gt; 이후의 기본값 .</target>
        </trans-unit>
        <trans-unit id="64f783f15e250bd745ccbda8d2b00a1dccb9afea" translate="yes" xml:space="preserve">
          <source>If not set, if the available storage engine specified by a CREATE TABLE is not available, a warning is given and the default storage engine is used instead. If set, generate a 1286 error when creating a table if the specified &lt;a href=&quot;../storage-engines/index&quot;&gt;storage engine&lt;/a&gt; is not available. See also &lt;a href=&quot;../server-system-variables/index#enforce_storage_engine&quot;&gt;enforce_storage_engine&lt;/a&gt;. Default since &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1017-release-notes/&quot;&gt;MariaDB 10.1.7&lt;/a&gt;.</source>
          <target state="translated">설정하지 않으면 CREATE TABLE로 지정된 사용 가능한 스토리지 엔진을 사용할 수 없으면 경고가 표시되고 기본 스토리지 엔진이 대신 사용됩니다. 설정된 경우 지정된 &lt;a href=&quot;../storage-engines/index&quot;&gt;스토리지 엔진을&lt;/a&gt; 사용할 수없는 경우 테이블을 작성할 때 1286 오류를 생성하십시오 . &lt;a href=&quot;../server-system-variables/index#enforce_storage_engine&quot;&gt;enforce_storage_engine&lt;/a&gt; 도 참조하십시오 . &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1017-release-notes/&quot;&gt;MariaDB 10.1.7&lt;/a&gt; 이후의 기본값 .</target>
        </trans-unit>
        <trans-unit id="439f673304a4d4e6989425e6408b2ca25c7cf0b6" translate="yes" xml:space="preserve">
          <source>If omitted, the default is ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW.</source>
          <target state="translated">생략하면 기본값은 바인딩되지 않은 선행 및 현재 행 사이의 ROWS입니다.</target>
        </trans-unit>
        <trans-unit id="09aaff25360b325eb3fa70402bae6fd053bcdf0f" translate="yes" xml:space="preserve">
          <source>If one argument is decimal and the other argument is a floating point, they are compared as floating point values.</source>
          <target state="translated">한 인수가 10 진수이고 다른 인수가 부동 소수점이면 부동 소수점 값으로 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="c0db0806d488cb4427c258dde19d82dd8ee8c71a" translate="yes" xml:space="preserve">
          <source>If one argument is decimal and the other argument is decimal or integer, they are compared as decimals.</source>
          <target state="translated">한 인수가 10 진수이고 다른 인수가 10 진수 또는 정수인 경우 10 진수로 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="8ddcdc6874920e42c314cb6ae25ebba6c27b5ae8" translate="yes" xml:space="preserve">
          <source>If one doesn't use any connection name prefix for a &lt;code&gt;replicate..&lt;/code&gt; variable, then the value will be used as the default value for all connections that don't have a value set for this variable.</source>
          <target state="translated">&lt;code&gt;replicate..&lt;/code&gt; 변수에 연결 이름 접두사를 사용하지 않으면이 변수에 설정된 값이없는 모든 연결의 기본값으로 값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="10905d26b90b61585348ebebd3b4b913fce48820" translate="yes" xml:space="preserve">
          <source>If one gives an argument to LAST_INSERT_ID(), then it will return the value of the expression and the next call to LAST_INSERT_ID() will return the same value. The value will also be sent to the client and can be accessed by the &lt;a href=&quot;../mysql_insert_id/index&quot;&gt;mysql_insert_id&lt;/a&gt; function.</source>
          <target state="translated">LAST_INSERT_ID ()에 인수를 제공하면 표현식의 값을 리턴하고 다음에 LAST_INSERT_ID ()를 호출하면 동일한 값을 리턴합니다. 이 값은 클라이언트로 전송되며 &lt;a href=&quot;../mysql_insert_id/index&quot;&gt;mysql_insert_id&lt;/a&gt; 함수 로 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="45e8f63d2819023caf6fd486d2282f04993f1ba3" translate="yes" xml:space="preserve">
          <source>If one master connection or replication domain is currently processing a long-running query, it is possible that it will allocate all the worker threads in the pool, only to have them wait for the long-running query to complete, stalling any other master connection or replication domain, which will have to wait for a worker thread to become free.</source>
          <target state="translated">하나의 마스터 연결 또는 복제 도메인이 현재 장기 실행 쿼리를 처리하는 경우 풀에서 모든 작업자 스레드를 할당하고 장기 실행 쿼리가 완료 될 때까지 대기하여 다른 마스터 연결을 중단시킬 수 있습니다. 또는 작업자 도메인이 해제 될 때까지 기다려야하는 복제 도메인.</target>
        </trans-unit>
        <trans-unit id="02f3fe799606e4987d889d7bb5a486c669a5cfce" translate="yes" xml:space="preserve">
          <source>If one master fails, replication stops.</source>
          <target state="translated">하나의 마스터가 실패하면 복제가 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="1816608c994517c754216298620545958ac2e9ab" translate="yes" xml:space="preserve">
          <source>If one of the specified tables cannot be locked, none of the tables will be locked.</source>
          <target state="translated">지정된 테이블 중 하나를 잠글 수 없으면 테이블이 잠기지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a65d0ed39fbcc584925438b7417bf78ab198214f" translate="yes" xml:space="preserve">
          <source>If one runs &lt;code&gt;&lt;a href=&quot;../explain/index&quot;&gt;EXPLAIN&lt;/a&gt;&lt;/code&gt; for the above query in MySQL 5.1-5.6 or &lt;a href=&quot;../what-is-mariadb-51/index&quot;&gt;MariaDB 5.1&lt;/a&gt;-5.2, they'll get this plan:</source>
          <target state="translated">MySQL 5.1-5.6 또는 &lt;a href=&quot;../what-is-mariadb-51/index&quot;&gt;MariaDB 5.1&lt;/a&gt; -5.2 에서 위 쿼리에 대해 &lt;code&gt;&lt;a href=&quot;../explain/index&quot;&gt;EXPLAIN&lt;/a&gt;&lt;/code&gt; 을 실행 하면 다음 계획이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="b0c647acd61f859da6352a6d7b3a417022e4068b" translate="yes" xml:space="preserve">
          <source>If one runs the same query in &lt;a href=&quot;../what-is-mariadb-53/index&quot;&gt;MariaDB 5.3&lt;/a&gt;, they will get this plan:</source>
          <target state="translated">&lt;a href=&quot;../what-is-mariadb-53/index&quot;&gt;MariaDB 5.3&lt;/a&gt; 에서 동일한 쿼리를 실행하면 다음 계획을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="5c2ffff12e18e9b070af684a7e7270a1e2edc22c" translate="yes" xml:space="preserve">
          <source>If one runs this query in MariaDB/MySQL 5.6, they get this:</source>
          <target state="translated">MariaDB / MySQL 5.6에서이 쿼리를 실행하면 다음과 같은 결과를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="646006fbf7944a9e68984e20b9a3133be7a0983a" translate="yes" xml:space="preserve">
          <source>If one tries to insert into a sequence table, the single row will be updated. This allows &lt;a href=&quot;../mysqldump/index&quot;&gt;mysqldump&lt;/a&gt; to work but also gives the additional benefit that one can change all properties of a sequence with a single insert. New applications should of course also use &lt;code&gt;ALTER SEQUENCE&lt;/code&gt;.</source>
          <target state="translated">시퀀스 테이블에 삽입하려고하면 단일 행이 업데이트됩니다. 이렇게하면 &lt;a href=&quot;../mysqldump/index&quot;&gt;mysqldump&lt;/a&gt; 가 작동 할 수 있지만 단일 삽입으로 시퀀스의 모든 속성을 변경할 수 있다는 추가적인 이점이 있습니다. 새로운 응용 프로그램은 물론 &lt;code&gt;ALTER SEQUENCE&lt;/code&gt; 도 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="d384539a231a2a5e701b5f2c89104156f45f83f6" translate="yes" xml:space="preserve">
          <source>If one updates the &lt;code&gt;SEQUENCE&lt;/code&gt; with &lt;a href=&quot;../setval/index&quot;&gt;SETVAL()&lt;/a&gt; or &lt;a href=&quot;../alter-sequence/index&quot;&gt;ALTER SEQUENCE ... RESTART&lt;/a&gt;, &lt;code&gt;NEXT VALUE FOR&lt;/code&gt; will notice this and start from the next requested value.</source>
          <target state="translated">하나 개를 갱신하면 &lt;code&gt;SEQUENCE&lt;/code&gt; 와 &lt;a href=&quot;../setval/index&quot;&gt;SETVAL ()&lt;/a&gt; 또는 &lt;a href=&quot;../alter-sequence/index&quot;&gt;ALTER SEQUENCE ... RESTART는&lt;/a&gt; , &lt;code&gt;NEXT VALUE FOR&lt;/code&gt; 는 이 통지하고, 다음 요청 값에서 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="674dbdd7408d253c065090087e669788b39864b9" translate="yes" xml:space="preserve">
          <source>If one uses statement-based replication, they can just create the required triggers on the slave. The slave will run the statements from the binary log, which will cause the triggers to be invoked.</source>
          <target state="translated">명령문 기반 복제를 사용하는 경우 슬레이브에서 필요한 트리거를 작성할 수 있습니다. 슬레이브는 이진 로그에서 명령문을 실행하여 트리거가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="ab9fe974317d4790917aad8fd4521a2923c7a5dc" translate="yes" xml:space="preserve">
          <source>If one wants to distribute a table to a user that doesn't need write access to the table and one wants to minimize the storage size of the table, the recommended engine to use is Aria or MyISAM as one can pack the table with &lt;a href=&quot;../aria_pack/index&quot;&gt;aria_pack&lt;/a&gt; or &lt;a href=&quot;../myisampack/index&quot;&gt;myisampack&lt;/a&gt; respectively to make it notablly smaller. MyISAM is the most portable format as it's not dependent on whether the server settings are different. Aria and InnoDB require the same block size on both servers.</source>
          <target state="translated">테이블에 대한 쓰기 액세스가 필요하지 않은 사용자에게 테이블을 배포하고 테이블의 스토리지 크기를 최소화하려는 경우 &lt;a href=&quot;../aria_pack/index&quot;&gt;aria_pack&lt;/a&gt; 또는 aria_pack으로 테이블을 패킹 할 수 있으므로 권장되는 엔진은 Aria 또는 MyISAM입니다. &lt;a href=&quot;../myisampack/index&quot;&gt;myisampack은&lt;/a&gt; 각각 작게 만들었습니다. MyISAM은 서버 설정이 다른지 여부에 의존하지 않기 때문에 가장 휴대하기 쉬운 형식입니다. Aria와 InnoDB는 두 서버에서 동일한 블록 크기를 요구합니다.</target>
        </trans-unit>
        <trans-unit id="cc135c260c11431a2792344e1d6265411181543f" translate="yes" xml:space="preserve">
          <source>If one wants to use Sequences in a master-master setup or with Galera one should use &lt;code&gt;INCREMENT=0&lt;/code&gt;. This will tell the Sequence to use &lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#auto_increment_increment&quot;&gt;auto_increment_increment&lt;/a&gt; and &lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#auto_increment_offset&quot;&gt;auto_increment_offset&lt;/a&gt; to generate unique values for each server.</source>
          <target state="translated">마스터-마스터 셋업에서 또는 Galera와 함께 시퀀스를 사용하려면 &lt;code&gt;INCREMENT=0&lt;/code&gt; 을 사용해야합니다 . 그러면 시퀀스에 &lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#auto_increment_increment&quot;&gt;auto_increment_increment&lt;/a&gt; 및 &lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#auto_increment_offset&quot;&gt;auto_increment_offset&lt;/a&gt; 을 사용 하여 각 서버에 대해 고유 한 값을 생성하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="877d9e4ecac5039d5b247d857d494e4a5b55db2d" translate="yes" xml:space="preserve">
          <source>If only using &lt;a href=&quot;../myisam/index&quot;&gt;MyISAM&lt;/a&gt;, set &lt;a href=&quot;../myisam-system-variables/index#key_buffer_size&quot;&gt;key_buffer_size&lt;/a&gt; to 20% of &lt;strong&gt;available&lt;/strong&gt; RAM. (Plus &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_buffer_pool_size&quot;&gt;innodb_buffer_pool_size=0&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;../myisam/index&quot;&gt;MyISAM&lt;/a&gt; 만 사용하는 경우 &lt;a href=&quot;../myisam-system-variables/index#key_buffer_size&quot;&gt;key_buffer_size&lt;/a&gt; 를 &lt;strong&gt;사용 가능한&lt;/strong&gt; RAM의 20 %로 설정하십시오 . (플러스 &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_buffer_pool_size&quot;&gt;innodb_buffer_pool_size = 0&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="abcf724f71d78d59d93523c002c9fdac9a87a1af" translate="yes" xml:space="preserve">
          <source>If only using InnoDB, set &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_buffer_pool_size&quot;&gt;innodb_buffer_pool_size&lt;/a&gt; to 70% of &lt;strong&gt;available&lt;/strong&gt; RAM. (Plus &lt;a href=&quot;../myisam-system-variables/index#key_buffer_size&quot;&gt;key_buffer_size&lt;/a&gt; = 10M, small, but not zero.)</source>
          <target state="translated">InnoDB 만 사용하는 경우 &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_buffer_pool_size&quot;&gt;innodb_buffer_pool_size&lt;/a&gt; 를 &lt;strong&gt;사용 가능한&lt;/strong&gt; RAM의 70 %로 설정하십시오 . (플러스 &lt;a href=&quot;../myisam-system-variables/index#key_buffer_size&quot;&gt;key_buffer_size&lt;/a&gt; = 10M, 작지만 0은 아님)</target>
        </trans-unit>
        <trans-unit id="64f128a05f6c138da190ef882ff397aa7c56ca5a" translate="yes" xml:space="preserve">
          <source>If our system does not have &lt;code&gt;&lt;a href=&quot;https://linux.die.net/man/8/logrotate&quot;&gt;logrotate&lt;/a&gt;&lt;/code&gt; 3.8.9 or later, which is needed to support the &lt;code&gt;createolddir&lt;/code&gt; directive, then we will also need to create the relevant directory specified by the &lt;code&gt;olddir&lt;/code&gt; directive:</source>
          <target state="translated">시스템 에 &lt;code&gt;createolddir&lt;/code&gt; 지시문 을 지원하는 데 필요한 &lt;code&gt;&lt;a href=&quot;https://linux.die.net/man/8/logrotate&quot;&gt;logrotate&lt;/a&gt;&lt;/code&gt; 3.8.9 이상이없는 경우 &lt;code&gt;olddir&lt;/code&gt; 지시문으로 지정된 관련 디렉토리도 작성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e9b94a1a94842a1a8a6aa13de60f31da778f01bc" translate="yes" xml:space="preserve">
          <source>If parentheses are used, any number of spaces, tab characters and new line characters is allowed between the procedure's name and the open parenthesis.</source>
          <target state="translated">괄호를 사용하는 경우 프로 시저 이름과 열린 괄호 사이에 공백, 탭 문자 및 줄 바꾸기 문자를 얼마든지 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d14006577eb8e7be993ce1b75e10aebcf3c3a3a3" translate="yes" xml:space="preserve">
          <source>If partition is listed as DISABLED:</source>
          <target state="translated">파티션이 비활성화 됨으로 표시되는 경우 :</target>
        </trans-unit>
        <trans-unit id="38edb16bc0379c7473a53707396bc08f83f9f614" translate="yes" xml:space="preserve">
          <source>If password validation fails, then the original CrackLib error message can be viewed by executing &lt;code&gt;&lt;a href=&quot;../show-warnings/index&quot;&gt;SHOW WARNINGS&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">비밀번호 확인에 실패하면 &lt;code&gt;&lt;a href=&quot;../show-warnings/index&quot;&gt;SHOW WARNINGS&lt;/a&gt;&lt;/code&gt; 를 실행하여 원래 CrackLib 오류 메시지를 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="60cf22d8d7c5ec3d3fbfc23ad38cf206c719046f" translate="yes" xml:space="preserve">
          <source>If performing the MariaDB ColumnStore Multi-node Distributed Installation, the binary package only needs to be installed on Performance Module #1 (pm1). If performing Non-Distributed installs, the binary package is required to install the MariaDB ColumnStore on all the nodes in the system.</source>
          <target state="translated">MariaDB ColumnStore 다중 노드 분산 설치를 수행하는 경우 이진 패키지는 성능 모듈 # 1 (pm1)에만 설치하면됩니다. 비 분산 설치를 수행하는 경우 시스템의 모든 노드에 MariaDB ColumnStore를 설치하려면 이진 패키지가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="6b24ea4bc53839ae1597e6e7e0c93a6a842fc682" translate="yes" xml:space="preserve">
          <source>If performing the MariaDB ColumnStore Multi-node Distributed Installation, the post-install only needs to be run on Performance Module #1 (pm1). If performing Non-Distributed installs, the post-install needs to be run the MariaDB ColumnStore on all the nodes in the system.</source>
          <target state="translated">MariaDB ColumnStore 다중 노드 분산 설치를 수행하는 경우 설치 후 성능 모듈 # 1 (pm1)에서만 실행하면됩니다. 비 분산 설치를 수행하는 경우 시스템의 모든 노드에서 설치 후 MariaDB ColumnStore를 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="5867cbbf9ae1c2e3a3f2cff58e29684e8b39ad60" translate="yes" xml:space="preserve">
          <source>If performing the MariaDB ColumnStore Multi-node Non-Distributed installs, the 'columnstore' service needs to be started on all the nodes in the system except Performance Module #1 (pm1). postConfigure is run from pm1, which is documented in the next section</source>
          <target state="translated">MariaDB ColumnStore 다중 노드 비 분산 설치를 수행하는 경우 성능 모듈 # 1 (pm1)을 제외한 시스템의 모든 노드에서 'columnstore'서비스를 시작해야합니다. postConfigure는 다음 섹션에서 설명하는 pm1에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="82a58855f8c87b5fa4218dd3e89ce80868e3ecd6" translate="yes" xml:space="preserve">
          <source>If performing the distributed-mode installation across multiple node, the binary package only needs to be installed on Performance Module #1 (pm1). If performing a non-distributed installation, the binary package is required to install the MariaDB ColumnStore on all the nodes in the system.</source>
          <target state="translated">여러 노드에서 분산 모드 설치를 수행하는 경우 이진 패키지는 성능 모듈 # 1 (pm1)에만 설치하면됩니다. 비 분산 설치를 수행하는 경우 시스템의 모든 노드에 MariaDB ColumnStore를 설치하려면 이진 패키지가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="b34d8ba12d6da25d87184cd895cf702bcb000750" translate="yes" xml:space="preserve">
          <source>If performing the distributed-mode installation, post-install only needs to be run on Performance Module #1 (pm1). If performing non-distributed installations, post-install needs to be run on all the nodes in the system.</source>
          <target state="translated">분산 모드 설치를 수행하는 경우 설치 후 성능 모듈 # 1 (pm1)에서만 실행하면됩니다. 비 분산 설치를 수행하는 경우 시스템의 모든 노드에서 사후 설치를 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="0bed6f55bdbd7965e4b8f06530b40db3c5ecc0b7" translate="yes" xml:space="preserve">
          <source>If performing the non-distributed installation mode, the 'columnstore' service needs to be started on all nodes in the system except Performance Module #1 (pm1). postConfigure is on pm1, which is documented in the next section.</source>
          <target state="translated">비 분산 설치 모드를 수행하는 경우 성능 모듈 # 1 (pm1)을 제외한 시스템의 모든 노드에서 'columnstore'서비스를 시작해야합니다. postConfigure는 pm1에 ​​있으며 다음 섹션에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7cd28d04ba1bfdb1102f4384b9c5dc32fbeb9ad" translate="yes" xml:space="preserve">
          <source>If purge operations are lagging on a busy server, then this can be a tough situation to recover from. As a solution, InnoDB allows you to set the max purge lag. The max purge lag is defined as the maximum number of &lt;a href=&quot;../innodb-undo-log/index&quot;&gt;InnoDB undo log&lt;/a&gt; that can be waiting to be purged from the history until InnoDB begins delaying DML statements.</source>
          <target state="translated">사용중인 서버에서 제거 작업이 지연되는 경우 복구하기 어려운 상황이 될 수 있습니다. 솔루션으로 InnoDB를 사용하면 최대 퍼지 지연을 설정할 수 있습니다. 최대 제거 지연은 InnoDB가 DML 문 지연을 시작할 때까지 기록에서 제거 대기 할 수있는 최대 &lt;a href=&quot;../innodb-undo-log/index&quot;&gt;InnoDB 실행 취소 로그&lt;/a&gt; 수로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="dc37fca153883c6c2678c8115f34857d375e0a36" translate="yes" xml:space="preserve">
          <source>If query processing was interrupted during filesort, an error is returned in addition to the warning.</source>
          <target state="translated">파일 정렬 중에 쿼리 처리가 중단 된 경우 경고 외에 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3690127a536150a0d74fba79c77eb7a2b8a9d3ad" translate="yes" xml:space="preserve">
          <source>If read statements have a higher priority, the priority of an &lt;code&gt;INSERT&lt;/code&gt; can be changed via the &lt;code&gt;HIGH_PRIORITY&lt;/code&gt; attribute. However, the priority of other write statements cannot be raised individually.</source>
          <target state="translated">읽기 명령문의 우선 순위가 높은 경우, &lt;code&gt;INSERT&lt;/code&gt; 의 우선 순위 는 &lt;code&gt;HIGH_PRIORITY&lt;/code&gt; 속성을 통해 변경할 수 있습니다 . 그러나 다른 쓰기 문의 우선 순위를 개별적으로 높일 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="655845bd72361633897452f697166581b68a6c6c" translate="yes" xml:space="preserve">
          <source>If reference to a view causes execution of a stored function, privilege checking for statements executed within the function depend on whether the function is defined with a SQL SECURITY characteristic of DEFINER or INVOKER. If the security characteristic is DEFINER, the function runs with the privileges of its creator. If the characteristic is INVOKER, the function runs with the privileges determined by the view's SQL SECURITY characteristic.</source>
          <target state="translated">뷰에 대한 참조로 인해 저장된 함수가 실행되면 함수 내에서 실행 된 명령문에 대한 권한 검사는 함수가 DEFINER 또는 INVOKER의 SQL SECURITY 특성으로 정의되는지 여부에 따라 다릅니다. 보안 특성이 DEFINER 인 경우 함수는 작성자의 권한으로 실행됩니다. 특성이 INVOKER 인 경우, 함수는보기의 SQL SECURITY 특성에 의해 결정된 특권으로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="b49deff4dafea12fd82ac42c5772158b826d712c" translate="yes" xml:space="preserve">
          <source>If replication is currently running, reset the master so you can update its configuration:</source>
          <target state="translated">복제가 현재 실행중인 경우 마스터를 재설정하여 구성을 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6102e76138b8662d83f35aeeee1f839230ba1ed8" translate="yes" xml:space="preserve">
          <source>If replication is working correctly, both the values of &lt;code&gt;Slave_IO_Running&lt;/code&gt; and &lt;code&gt;Slave_SQL_Running&lt;/code&gt; should be &lt;code&gt;Yes&lt;/code&gt;:</source>
          <target state="translated">복제가 제대로 작동하면, 두 값 &lt;code&gt;Slave_IO_Running&lt;/code&gt; 및 &lt;code&gt;Slave_SQL_Running&lt;/code&gt; 는 해야한다 &lt;code&gt;Yes&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="61f75fb561251a37d7c39895ce87cc5c694eaab7" translate="yes" xml:space="preserve">
          <source>If row-based logging is used for a statement, and the session executing the statement has any temporary tables, row-based logging is used for the remaining statements until the temporary table is dropped. This is because temporary tables can't use row-based logging, so if it is used due to one of the above conditions, all subsequent statements using that table are unsafe. The server deals with this situation by treating all statements in the session as unsafe for statement-based logging until the temporary table is dropped.</source>
          <target state="translated">명령문에 행 기반 로깅이 사용되고 명령문을 실행하는 세션에 임시 테이블이있는 경우 임시 테이블이 삭제 될 때까지 나머지 명령문에 행 기반 로깅이 사용됩니다. 임시 테이블은 행 기반 로깅을 사용할 수 없기 때문에 위의 조건 중 하나로 인해 사용되는 경우 해당 테이블을 사용하는 모든 후속 명령문은 안전하지 않습니다. 서버는 임시 테이블이 삭제 될 때까지 세션의 모든 명령문을 명령문 기반 로깅에 안전하지 않은 것으로 처리하여이 상황을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="34ba66f2d1f198bb4b94d5e1955609b7e357975f" translate="yes" xml:space="preserve">
          <source>If running on an alternative system, or the commands are available, the following packages are required. You will need to check the repositories for the correct package names on your distribution - these may differ between distributions, or require additional packages:</source>
          <target state="translated">대체 시스템에서 실행 중이거나 명령을 사용할 수있는 경우 다음 패키지가 필요합니다. 배포판에 올바른 패키지 이름이 있는지 리포지토리를 확인해야합니다. 배포판마다 다를 수 있거나 추가 패키지가 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc9f1a1027a28ca444d15e92cd3276208521eb51" translate="yes" xml:space="preserve">
          <source>If semisynchronous replication is enabled on a server when &lt;a href=&quot;../replication-threads/index#threads-on-the-slave&quot;&gt;slave threads&lt;/a&gt; were already running, the slave I/O thread will need to be restarted to enable the slave to register as a semisynchronous slave when it connects to the master. For example:</source>
          <target state="translated">&lt;a href=&quot;../replication-threads/index#threads-on-the-slave&quot;&gt;슬레이브 스레드&lt;/a&gt; 가 이미 실행 중일 때 서버에서 반 동기식 복제가 활성화 된 경우 슬레이브 I / O 스레드를 다시 시작하여 슬레이브가 마스터에 연결될 때 세미 동기식 슬레이브로 등록 할 수 있도록해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="54c306e78a80429d1db737eb6fe0145b379870ff" translate="yes" xml:space="preserve">
          <source>If set don't generate an &lt;code&gt;AUTO_INCREMENT&lt;/code&gt; on &lt;code&gt;INSERT&lt;/code&gt; of zero in an &lt;code&gt;AUTO_INCREMENT&lt;/code&gt; column. Normally both &lt;code&gt;zero&lt;/code&gt; and &lt;code&gt;NULL&lt;/code&gt; generate new &lt;code&gt;AUTO_INCREMENT&lt;/code&gt; values.</source>
          <target state="translated">설정 하면 &lt;code&gt;AUTO_INCREMENT&lt;/code&gt; 열의 &lt;code&gt;INSERT&lt;/code&gt; 에서 &lt;code&gt;AUTO_INCREMENT&lt;/code&gt; 를 0으로 생성하지 않습니다 . 일반적으로 &lt;code&gt;zero&lt;/code&gt; 과 &lt;code&gt;NULL&lt;/code&gt; 은 새로운 &lt;code&gt;AUTO_INCREMENT&lt;/code&gt; 값을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="fc21a7f1f35245e0e5233ecc5352a825effa6a26" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;1&lt;/code&gt; (&lt;code&gt;0&lt;/code&gt; is default), MariaDB reverts to using the &lt;code&gt;&lt;a href=&quot;../authentication-plugin-mysql_old_password/index&quot;&gt;mysql_old_password&lt;/a&gt;&lt;/code&gt; authentication plugin by default for newly created users and passwords, instead of the &lt;code&gt;&lt;a href=&quot;../authentication-plugin-mysql_native_password/index&quot;&gt;mysql_native_password&lt;/a&gt;&lt;/code&gt; authentication plugin.</source>
          <target state="translated">&lt;code&gt;1&lt;/code&gt; 로 설정하면 ( &lt;code&gt;0&lt;/code&gt; 이 기본값 임) MariaDB는 &lt;code&gt;&lt;a href=&quot;../authentication-plugin-mysql_old_password/index&quot;&gt;mysql_old_password&lt;/a&gt;&lt;/code&gt; 인증 플러그인 대신 새로 작성된 사용자 및 비밀번호에 대해 기본적으로 mysql_old_password 인증 플러그인 사용으로 되돌 &lt;code&gt;&lt;a href=&quot;../authentication-plugin-mysql_native_password/index&quot;&gt;mysql_native_password&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c8ec21a68f403db326a96f8deef8d766a3a04ad" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;normal&lt;/code&gt;, it creates a &lt;code&gt;root@localhost&lt;/code&gt; account that authenticates with the &lt;code&gt;&lt;a href=&quot;../authentication-plugin-mysql_native_password/index&quot;&gt;mysql_native_password&lt;/a&gt;&lt;/code&gt; authentication plugin and that has no initial password set, which can be insecure. If set to &lt;code&gt;socket&lt;/code&gt;, it creates a &lt;code&gt;root@localhost&lt;/code&gt; account that authenticates with the &lt;code&gt;&lt;a href=&quot;../authentication-plugin-unix-socket/index&quot;&gt;unix_socket&lt;/a&gt;&lt;/code&gt; authentication plugin. Set to &lt;code&gt;normal&lt;/code&gt; by default. Available since &lt;a href=&quot;../what-is-mariadb-101/index&quot;&gt;MariaDB 10.1&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;normal&lt;/code&gt; 로 설정 하면 &lt;code&gt;&lt;a href=&quot;../authentication-plugin-mysql_native_password/index&quot;&gt;mysql_native_password&lt;/a&gt;&lt;/code&gt; 인증 플러그인으로 인증하고 초기 비밀번호가 설정되어 있지 않은 &lt;code&gt;root@localhost&lt;/code&gt; 계정을 작성 하므로 안전하지 않을 수 있습니다. &lt;code&gt;socket&lt;/code&gt; 으로 설정 되면 &lt;code&gt;&lt;a href=&quot;../authentication-plugin-unix-socket/index&quot;&gt;unix_socket&lt;/a&gt;&lt;/code&gt; 인증 플러그인으로 인증 하는 &lt;code&gt;root@localhost&lt;/code&gt; 계정을 만듭니다 . 기본적 으로 &lt;code&gt;normal&lt;/code&gt; 으로 설정하십시오. &lt;a href=&quot;../what-is-mariadb-101/index&quot;&gt;MariaDB 10.1&lt;/a&gt; 부터 사용 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="dccbce742c95c5d3f9a2815881afa654d3b40753" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;normal&lt;/code&gt;, it creates a &lt;code&gt;root@localhost&lt;/code&gt; account that authenticates with the &lt;code&gt;&lt;a href=&quot;../authentication-plugin-mysql_native_password/index&quot;&gt;mysql_native_password&lt;/a&gt;&lt;/code&gt; authentication plugin and that has no initial password set, which can be insecure. If set to &lt;code&gt;socket&lt;/code&gt;, it creates a &lt;code&gt;root@localhost&lt;/code&gt; account that authenticates with the &lt;code&gt;&lt;a href=&quot;../authentication-plugin-unix-socket/index&quot;&gt;unix_socket&lt;/a&gt;&lt;/code&gt; authentication plugin. Set to &lt;code&gt;socket&lt;/code&gt; by default from &lt;a href=&quot;../what-is-mariadb-104/index&quot;&gt;MariaDB 10.4&lt;/a&gt; (see &lt;a href=&quot;../authentication-from-mariadb-104/index&quot;&gt;Authentication from MariaDB 10.4&lt;/a&gt;), or &lt;code&gt;normal&lt;/code&gt; by default in earlier versions. Available since &lt;a href=&quot;../what-is-mariadb-101/index&quot;&gt;MariaDB 10.1&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;normal&lt;/code&gt; 로 설정 하면 &lt;code&gt;&lt;a href=&quot;../authentication-plugin-mysql_native_password/index&quot;&gt;mysql_native_password&lt;/a&gt;&lt;/code&gt; 인증 플러그인으로 인증하고 초기 비밀번호가 설정되어 있지 않은 &lt;code&gt;root@localhost&lt;/code&gt; 계정을 작성 하므로 안전하지 않을 수 있습니다. &lt;code&gt;socket&lt;/code&gt; 으로 설정 되면 &lt;code&gt;&lt;a href=&quot;../authentication-plugin-unix-socket/index&quot;&gt;unix_socket&lt;/a&gt;&lt;/code&gt; 인증 플러그인으로 인증 하는 &lt;code&gt;root@localhost&lt;/code&gt; 계정을 만듭니다 . &lt;a href=&quot;../what-is-mariadb-104/index&quot;&gt;MariaDB 10.4&lt;/a&gt; 에서 기본적 으로 &lt;code&gt;socket&lt;/code&gt; 으로 설정하거나 ( MariaDB 10.4 &lt;a href=&quot;../authentication-from-mariadb-104/index&quot;&gt;에서 인증&lt;/a&gt; 참조 ) 이전 버전에서는 기본적으로 &lt;code&gt;normal&lt;/code&gt; 로 설정하십시오. &lt;a href=&quot;../what-is-mariadb-101/index&quot;&gt;MariaDB 10.1&lt;/a&gt; 부터 사용 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="3481f63b436696e275054bb9de7ffdddcf2bd555" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;salvage&lt;/code&gt;, read access is permitted, but corrupted pages are ignored. &lt;a href=&quot;#innodb_file_per_table&quot;&gt;innodb_file_per_table&lt;/a&gt; must be enabled for this option. Previously named &lt;code&gt;innodb_pass_corrupt_table&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;salvage&lt;/code&gt; 로 설정하면 읽기 액세스가 허용되지만 손상된 페이지는 무시됩니다. 이 옵션에 대해 &lt;a href=&quot;#innodb_file_per_table&quot;&gt;innodb_file_per_table&lt;/a&gt; 을 활성화해야합니다. 이전에 이름이 &lt;code&gt;innodb_pass_corrupt_table&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="54c8fb0075ad41b19a54fb4e683fe411fe85a3a7" translate="yes" xml:space="preserve">
          <source>If so, then logging is now working...</source>
          <target state="translated">그렇다면 로깅이 작동하는 것입니다 ...</target>
        </trans-unit>
        <trans-unit id="e2643db810617e845effe061f4717da9a8dd3d5a" translate="yes" xml:space="preserve">
          <source>If soft group commit is enabled (aria_group_commit=&quot;soft&quot;)</source>
          <target state="translated">소프트 그룹 커밋이 활성화 된 경우 (aria_group_commit = &quot;soft&quot;)</target>
        </trans-unit>
        <trans-unit id="51ade892df749475bd96de8ae099ef24e057b187" translate="yes" xml:space="preserve">
          <source>If some of the &quot;Handler&quot; numbers look like the number of rows in the table, then there was a table scan.</source>
          <target state="translated">&quot;핸들러&quot;숫자 중 일부가 테이블의 행 수처럼 보이는 경우 테이블 스캔이있었습니다.</target>
        </trans-unit>
        <trans-unit id="d8b813e364dbb7f8019dad2f2d3d1ac3566c9c08" translate="yes" xml:space="preserve">
          <source>If some of the tables are using an index for which we have changed sort order.</source>
          <target state="translated">일부 테이블이 정렬 순서를 변경 한 인덱스를 사용하는 경우.</target>
        </trans-unit>
        <trans-unit id="ebbdb433271894faa03c6f2d1664befd7fd635cf" translate="yes" xml:space="preserve">
          <source>If spanning a pole or the dateline, a more complex SELECT is used.</source>
          <target state="translated">극점 또는 날짜 표시 줄에 걸쳐 있으면 더 복잡한 SELECT가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="024c4a58d16b0ae2f35c5f999c0c65c470bfa1ca" translate="yes" xml:space="preserve">
          <source>If specified, the third integer argument set the depth to search in the document. This means the maximum items in the paths (until &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1027-release-notes/&quot;&gt;MariaDB 10.2.7&lt;/a&gt;, the number of &amp;lsquo;:&amp;rsquo; separator characters in them plus one). This value defaults to 10 but can be increased for complex documents or reduced to set the maximum wanted depth of the returned paths.</source>
          <target state="translated">지정된 경우, 세 번째 정수 인수는 문서에서 검색 할 깊이를 설정합니다. 이는 경로의 최대 항목을 의미합니다 ( &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1027-release-notes/&quot;&gt;MariaDB 10.2.7&lt;/a&gt; 까지 ':'구분 문자 수에 1을 더한 값). 이 값의 기본값은 10이지만 복잡한 문서의 경우 값을 늘리거나 반환 된 경로의 원하는 최대 깊이를 설정하도록 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad192a0dea52656bafac4a972fd6e1c072fb9585" translate="yes" xml:space="preserve">
          <source>If strict SQL mode is not enabled, a &lt;a href=&quot;../varchar/index&quot;&gt;VARCHAR&lt;/a&gt; column longer than 65535 become &lt;a href=&quot;../text/index&quot;&gt;TEXT&lt;/a&gt;, and a &lt;a href=&quot;../varbinary/index&quot;&gt;VARBINARY&lt;/a&gt; columns longer than 65535 becomes a &lt;a href=&quot;../blob/index&quot;&gt;BLOB&lt;/a&gt;. If strict mode is enabled the silent changes will not be made, and an error will occur.</source>
          <target state="translated">엄격한 SQL 모드가 활성화되지 않으면 &lt;a href=&quot;../varchar/index&quot;&gt;VARCHAR의&lt;/a&gt; 이상 65,535되기보다는 열 &lt;a href=&quot;../text/index&quot;&gt;TEXT&lt;/a&gt; 및 &lt;a href=&quot;../varbinary/index&quot;&gt;VARBINARY의&lt;/a&gt; 이상 65,535 이상의 열이된다 &lt;a href=&quot;../blob/index&quot;&gt;BLOB&lt;/a&gt; . 엄격 모드를 사용하면 자동 변경이 수행되지 않고 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fceedd0b35a79194faebbe44a7f94bab3c5bbcde" translate="yes" xml:space="preserve">
          <source>If symbolic links are disabled with the &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-symbolic-links&quot;&gt;--symbolic-links&lt;/a&gt;&lt;/code&gt; option and the &lt;code&gt;skip&lt;/code&gt;&lt;a href=&quot;../mysqld-options/index#option-prefixes&quot;&gt;option prefix&lt;/a&gt; (i.e. --skip-symbolic-links), then the value will be &lt;code&gt;DISABLED&lt;/code&gt;.</source>
          <target state="translated">심볼릭 링크가 함께 사용할 경우 &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-symbolic-links&quot;&gt;--symbolic-links&lt;/a&gt;&lt;/code&gt; 옵션과 &lt;code&gt;skip&lt;/code&gt; &lt;a href=&quot;../mysqld-options/index#option-prefixes&quot;&gt;옵션 접두사&lt;/a&gt; (즉, --skip-심볼릭 링크), 값이 될 것입니다 &lt;code&gt;DISABLED&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88a74dd929d6284c032019dc10234ee1070839cc" translate="yes" xml:space="preserve">
          <source>If symbolic links are not supported, then the value will be &lt;code&gt;NO&lt;/code&gt;.</source>
          <target state="translated">기호 링크가 지원되지 않으면 값은 &lt;code&gt;NO&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1c4ffa287398c78a4c2ac8fe7bdaacc8d8b8e243" translate="yes" xml:space="preserve">
          <source>If symbolic links are supported, then the value will be &lt;code&gt;YES&lt;/code&gt;.</source>
          <target state="translated">기호 링크가 지원되는 경우 값은 &lt;code&gt;YES&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e4dba38ea6b2b6433badfc658eef7d33aed78d0c" translate="yes" xml:space="preserve">
          <source>If table is locked, wait instead of returning an error.</source>
          <target state="translated">테이블이 잠겨 있으면 오류를 반환하는 대신 기다리십시오.</target>
        </trans-unit>
        <trans-unit id="816b84d9d6063ad7baa4f83b031477c5be672acb" translate="yes" xml:space="preserve">
          <source>If that &lt;code&gt;SELECT&lt;/code&gt; returns no rows, then you still need to &lt;a href=&quot;#installing-the-plugin&quot;&gt;install the plugin&lt;/a&gt;.</source>
          <target state="translated">해당 &lt;code&gt;SELECT&lt;/code&gt; 가 행을 리턴하지 않으면 여전히 &lt;a href=&quot;#installing-the-plugin&quot;&gt;플러그인&lt;/a&gt; 을 설치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="50ffe4af199704c57ed87598cdaa3b0d93812361" translate="yes" xml:space="preserve">
          <source>If that does not work, then you can work around this problem by giving the user that runs &lt;code&gt;&lt;a href=&quot;../mysqld-options/index&quot;&gt;mysqld&lt;/a&gt;&lt;/code&gt; access to &lt;code&gt;/etc/shadow&lt;/code&gt;. For example, if the &lt;code&gt;mysql&lt;/code&gt; user runs &lt;code&gt;&lt;a href=&quot;../mysqld-options/index&quot;&gt;mysqld&lt;/a&gt;&lt;/code&gt;, then you could do the following:</source>
          <target state="translated">그래도 문제가 해결되지 않으면 &lt;code&gt;&lt;a href=&quot;../mysqld-options/index&quot;&gt;mysqld&lt;/a&gt;&lt;/code&gt; 를 실행하는 사용자 에게 &lt;code&gt;/etc/shadow&lt;/code&gt; 에 대한 액세스 권한을 부여하여이 문제를 해결할 수 있습니다 . 예를 들어, &lt;code&gt;mysql&lt;/code&gt; 사용자가 &lt;code&gt;&lt;a href=&quot;../mysqld-options/index&quot;&gt;mysqld&lt;/a&gt;&lt;/code&gt; 를 실행 하면 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f52ec087106d4fe585fcaad58cc8c811d3ccc7d" translate="yes" xml:space="preserve">
          <source>If that leads to swapping, cut both settings back. Suggest cutting them down proportionately.</source>
          <target state="translated">이것이 스와핑으로 이어지면 두 설정을 모두 줄입니다. 비례 적으로 줄 이도록 제안하십시오.</target>
        </trans-unit>
        <trans-unit id="7b1949de2214c7c411d936a529bb9afc6598c736" translate="yes" xml:space="preserve">
          <source>If that solved the problem, then it means that the current SELinux policy is the culprit. You need to adjust the SELinux policy or labels for MariaDB.</source>
          <target state="translated">문제가 해결되면 현재 SELinux 정책이 원인임을 의미합니다. MariaDB에 대한 SELinux 정책 또는 레이블을 조정해야합니다.</target>
        </trans-unit>
        <trans-unit id="ba1f3bfe9acd500494dcea7b953de67aa1de405c" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt; is enabled on a server, then the server will use the binary log-based transaction coordinator log. Otherwise, it will use the memory-mapped file-based transaction coordinator log.</source>
          <target state="translated">서버에서 &lt;a href=&quot;../binary-log/index&quot;&gt;이진 로그&lt;/a&gt; 가 활성화 된 경우 서버는 이진 로그 기반 트랜잭션 코디네이터 로그를 사용합니다. 그렇지 않으면 메모리 매핑 된 파일 기반 트랜잭션 조정자 로그를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="62cafa16c2caa9456d3473647a577db82cbb61f8" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt; is used, &lt;code&gt;CREATE TABLE ... SELECT&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../insert-select/index&quot;&gt;INSERT ... SELECT&lt;/a&gt;&lt;/code&gt; statements cannot use concurrent inserts. These statements acquire a read lock on the table, so concurrent inserts will need to wait. This way the log can be safely used to restore data.</source>
          <target state="translated">경우 &lt;a href=&quot;../binary-log/index&quot;&gt;바이너리 로그가&lt;/a&gt; 사용되며, &lt;code&gt;CREATE TABLE ... SELECT&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../insert-select/index&quot;&gt;INSERT ... SELECT&lt;/a&gt;&lt;/code&gt; 동시 삽입을 사용할 수 없습니다 문을. 이 명령문은 테이블에 대한 읽기 잠금을 획득하므로 동시 삽입은 대기해야합니다. 이런 식으로 로그를 안전하게 사용하여 데이터를 복원 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce65d22c88d843d31f992253aec3b52cbcc27994" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../metadata-lock-info/index&quot;&gt;metadata_lock_info&lt;/a&gt; plugin is installed, locks acquired with this function are visible in the &lt;a href=&quot;../information_schema/index&quot;&gt;Information Schema&lt;/a&gt;&lt;a href=&quot;../information-schema-metadata_lock_info-table/index&quot;&gt;METADATA_LOCK_INFO&lt;/a&gt; table.</source>
          <target state="translated">는 IF &lt;a href=&quot;../metadata-lock-info/index&quot;&gt;metadata_lock_info의&lt;/a&gt; 플러그인이 설치되어,이 기능을 획득 한 잠금은에서 볼 수 있습니다 &lt;a href=&quot;../information_schema/index&quot;&gt;정보 스키마 &lt;/a&gt;&lt;a href=&quot;../information-schema-metadata_lock_info-table/index&quot;&gt;METADATA_LOCK_INFO의&lt;/a&gt; 테이블.</target>
        </trans-unit>
        <trans-unit id="a790ed156a3492e9e940441e17a829c9efcea7fa" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../metadata-lock-info/index&quot;&gt;metadata_lock_info&lt;/a&gt; plugin is installed, the &lt;a href=&quot;../information-schema/index&quot;&gt;Information Schema&lt;/a&gt;&lt;code&gt;&lt;a href=&quot;../information-schema-metadata_lock_info-table/index&quot;&gt;metadata_lock_info&lt;/a&gt;&lt;/code&gt; table stores information about existing metadata locks.</source>
          <target state="translated">경우 &lt;a href=&quot;../metadata-lock-info/index&quot;&gt;metadata_lock_info&lt;/a&gt; 플러그인이 설치되면, &lt;a href=&quot;../information-schema/index&quot;&gt;정보 스키마 &lt;/a&gt; &lt;code&gt;&lt;a href=&quot;../information-schema-metadata_lock_info-table/index&quot;&gt;metadata_lock_info&lt;/a&gt;&lt;/code&gt; 기존의 메타 데이터 잠금에 대한 테이블 정보를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="86cdd4889d4d0a43a3721b00c3a70bb2fed6eb75" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../metadata_lock_info/index&quot;&gt;metadata_lock_info&lt;/a&gt; plugin is installed, the &lt;a href=&quot;../information_schema/index&quot;&gt;Information Schema&lt;/a&gt;&lt;a href=&quot;../information-schema-metadata_lock_info-table/index&quot;&gt;metadata_lock_info&lt;/a&gt; table contains information about locks of this kind (as well as &lt;a href=&quot;../metadata-locking/index&quot;&gt;metadata locks&lt;/a&gt;).</source>
          <target state="translated">경우 &lt;a href=&quot;../metadata_lock_info/index&quot;&gt;metadata_lock_info&lt;/a&gt; 플러그인이 설치되면, &lt;a href=&quot;../information_schema/index&quot;&gt;정보 스키마 &lt;/a&gt;&lt;a href=&quot;../information-schema-metadata_lock_info-table/index&quot;&gt;metadata_lock_info&lt;/a&gt; 표는이 종류의 잠금에 대한 정보 (뿐만 아니라 포함 &lt;a href=&quot;../metadata-locking/index&quot;&gt;메타 데이터 잠금&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="99069f239c88467d2041e076cc4aed06fab17f31" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../replication-threads/index#threads-on-the-slave&quot;&gt;slave threads&lt;/a&gt; are currently running, you first need to stop them by executing the &lt;code&gt;&lt;a href=&quot;../stop-slave/index&quot;&gt;STOP SLAVE&lt;/a&gt;&lt;/code&gt; statement. For example:</source>
          <target state="translated">경우 &lt;a href=&quot;../replication-threads/index#threads-on-the-slave&quot;&gt;슬레이브 스레드가&lt;/a&gt; 현재 실행중인 먼저 실행하여이를 중지해야 &lt;code&gt;&lt;a href=&quot;../stop-slave/index&quot;&gt;STOP SLAVE&lt;/a&gt;&lt;/code&gt; 의 문을. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="55086967d1cae399f7f73db9c23cae29b36e189c" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../server-system-variables/index#expire_logs_days&quot;&gt;expire_logs_days&lt;/a&gt; server system variable is not set to 0, the server automatically deletes binary log files after the given number of days.</source>
          <target state="translated">는 IF &lt;a href=&quot;../server-system-variables/index#expire_logs_days&quot;&gt;expire_logs_days의&lt;/a&gt; 서버 시스템 변수가 0으로 설정되지 않은 서버가 자동으로 일의 일정한 수 다음에 바이너리 로그 파일을 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="b075666a08a8bfca5f0a1117a215b96be6d67258" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../server-system-variables/index#have_crypt&quot;&gt;have_crypt&lt;/a&gt; system variable is set to &lt;code&gt;NO&lt;/code&gt; (because the crypt() system call is not available), the ENCRYPT function will always return NULL.</source>
          <target state="translated">는 IF &lt;a href=&quot;../server-system-variables/index#have_crypt&quot;&gt;have_crypt&lt;/a&gt; 시스템 변수로 설정되어 &lt;code&gt;NO&lt;/code&gt; (토굴 () 시스템 호출을 사용할 수 없기 때문에), 암호화 함수는 항상 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b26ec0139c9df9cfda6839db56acddf18bbc3f99" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../server-system-variables/index#max_join_size&quot;&gt;max_join_size&lt;/a&gt; variable (also called &lt;code&gt;sql_max_join_size&lt;/code&gt;) is set, then it will limit any SELECT statements that probably need to examine more than &lt;code&gt;MAX_JOIN_SIZE&lt;/code&gt; rows.</source>
          <target state="translated">는 IF &lt;a href=&quot;../server-system-variables/index#max_join_size&quot;&gt;MAX_JOIN_SIZE의&lt;/a&gt; 변수 (또한 &lt;code&gt;sql_max_join_size&lt;/code&gt; ) 설정, 그것은 아마보다 더 조사 할 필요가있는 SELECT 문이 제한됩니다 &lt;code&gt;MAX_JOIN_SIZE&lt;/code&gt; 의 행.</target>
        </trans-unit>
        <trans-unit id="ffc9f174c1ab17417be08ed3da747f81da1a5180" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../server-system-variables/index#max_statement_time&quot;&gt;max_statement_time&lt;/a&gt; variable is set, any query (excluding stored procedures) taking longer than the value of &lt;code&gt;max_statement_time&lt;/code&gt; (specified in seconds) to execute will be aborted. This can be set globally, by session, as well as per user and per query. See &lt;a href=&quot;../aborting-statements-that-take-longer-than-a-certain-time-to-execute/index&quot;&gt;Aborting statements that take longer than a certain time to execute&lt;/a&gt;.</source>
          <target state="translated">는 IF &lt;a href=&quot;../server-system-variables/index#max_statement_time&quot;&gt;max_statement_time의&lt;/a&gt; 변수가 설정의 값보다 오래 걸리는 모든 쿼리 (저장 프로 시저를 제외) &lt;code&gt;max_statement_time&lt;/code&gt; 실행 (초 단위로 지정)이 중단됩니다. 이는 세션 별, 사용자 별 및 쿼리별로 전역 적으로 설정할 수 있습니다. &lt;a href=&quot;../aborting-statements-that-take-longer-than-a-certain-time-to-execute/index&quot;&gt;실행하는 데 특정 시간보다 오래 걸리는 명령문 중단을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="84cd4c01e0a3edbbd974d387e9a401664743934c" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../server-system-variables/index#query_cache_type&quot;&gt;query_cache_type&lt;/a&gt; system variable is set to 2 or &lt;code&gt;DEMAND&lt;/code&gt;, and the current statement is cacheable, &lt;code&gt;SQL_CACHE&lt;/code&gt; causes the query to be cached and &lt;code&gt;SQL_NO_CACHE&lt;/code&gt; causes the query not to be cached. For &lt;code&gt;UNION&lt;/code&gt;s, &lt;code&gt;SQL_CACHE&lt;/code&gt; or &lt;code&gt;SQL_NO_CACHE&lt;/code&gt; should be specified for the first query. See also &lt;a href=&quot;../the-query-cache/index&quot;&gt;The Query Cache&lt;/a&gt; for more detail and a list of the types of statements that aren't cacheable.</source>
          <target state="translated">는 IF &lt;a href=&quot;../server-system-variables/index#query_cache_type&quot;&gt;query_cache_size를의&lt;/a&gt; 시스템 변수가 2로 설정되어 &lt;code&gt;DEMAND&lt;/code&gt; , 그리고 현재 명령문 캐시가, &lt;code&gt;SQL_CACHE&lt;/code&gt; 는 캐시 할 수있는 쿼리를 발생시키고 &lt;code&gt;SQL_NO_CACHE&lt;/code&gt; 는 하지 캐시 할 수있는 쿼리를 발생합니다. 들어 &lt;code&gt;UNION&lt;/code&gt; 의, &lt;code&gt;SQL_CACHE&lt;/code&gt; 또는 &lt;code&gt;SQL_NO_CACHE&lt;/code&gt; 는 첫 번째 질의에 대해 지정해야합니다. &lt;a href=&quot;../the-query-cache/index&quot;&gt;캐시&lt;/a&gt; 할 수없는 명령문 유형의 목록과 세부 사항 은 쿼리 캐시 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="57c5d232bccb7313a92beb87c31b91220dc11591" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../server-system-variables/index#sql_safe_updates&quot;&gt;sql_safe_updates&lt;/a&gt; variable is set, one can't execute an &lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt; or &lt;a href=&quot;../delete/index&quot;&gt;DELETE&lt;/a&gt; statement unless one specifies a key constraint in the &lt;code&gt;WHERE&lt;/code&gt; clause or provide a &lt;code&gt;LIMIT&lt;/code&gt; clause (or both).</source>
          <target state="translated">는 IF &lt;a href=&quot;../server-system-variables/index#sql_safe_updates&quot;&gt;sql_safe_updates의&lt;/a&gt; 변수가 설정되어, 하나는 실행되지 않을 수 &lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt; 또는 &lt;a href=&quot;../delete/index&quot;&gt;DELETE&lt;/a&gt; 하나 개를 지정하는 키 제한하지 않는 한 문을 &lt;code&gt;WHERE&lt;/code&gt; 절 또는 제공 &lt;code&gt;LIMIT&lt;/code&gt; 의 절 (또는 둘 다).</target>
        </trans-unit>
        <trans-unit id="178797b757c875590caa3369278c10a27d786253" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../server_audit-system-variables/index#server_audit_output_type&quot;&gt;server_audit_output_type&lt;/a&gt; variable is set to &lt;code&gt;syslog&lt;/code&gt; instead of the default, &lt;code&gt;file&lt;/code&gt;, the audit log file format will be as follows:</source>
          <target state="translated">는 IF &lt;a href=&quot;../server_audit-system-variables/index#server_audit_output_type&quot;&gt;server_audit_output_type의&lt;/a&gt; 변수가 설정되어 &lt;code&gt;syslog&lt;/code&gt; 에 기본, 대신 &lt;code&gt;file&lt;/code&gt; 다음과 같이 감사 로그 파일 형식은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="fbde2d84bd7fb6d9bcddb0820208a6cf483cb6b6" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../slow-query-log/index&quot;&gt;slow query log&lt;/a&gt; is enabled and the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#log_queries_not_using_indexes&quot;&gt;log_queries_not_using_indexes&lt;/a&gt;&lt;/code&gt; server system variable is &lt;code&gt;ON&lt;/code&gt;, the queries which do not use indexes are logged.</source>
          <target state="translated">는 IF &lt;a href=&quot;../slow-query-log/index&quot;&gt;슬로우 쿼리 로그가&lt;/a&gt; 활성화되고있다 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#log_queries_not_using_indexes&quot;&gt;log_queries_not_using_indexes&lt;/a&gt;&lt;/code&gt; 의 서버 시스템 변수가 &lt;code&gt;ON&lt;/code&gt; , 인덱스를 사용하지 않는 쿼리가 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="31c24c6a4ee0bf6047d6fd5745051207a315328b" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../sphinxse/index&quot;&gt;Sphinx Storage Engine&lt;/a&gt; is installed, the following is also supported:</source>
          <target state="translated">는 IF &lt;a href=&quot;../sphinxse/index&quot;&gt;스핑크스 저장소 엔진이&lt;/a&gt; 설치되어, 다음도 지원됩니다 :</target>
        </trans-unit>
        <trans-unit id="fde2444a6499ea594e613930552382bcf74c5fdb" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../sql-mode/index&quot;&gt;SQL_MODE&lt;/a&gt; is set to &lt;code&gt;MAXDB&lt;/code&gt;, TIMESTAMP fields will be silently converted to &lt;a href=&quot;../datetime/index&quot;&gt;DATETIME&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;../sql-mode/index&quot;&gt;SQL_MODE가&lt;/a&gt; 설정되어 &lt;code&gt;MAXDB&lt;/code&gt; , TIMESTAMP 필드는 자동으로 변환됩니다 &lt;a href=&quot;../datetime/index&quot;&gt;DATETIME&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e92b55a18bbc50b754ceb008074824137d2ae6f9" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../sql-mode/index&quot;&gt;strict mode&lt;/a&gt; is enabled, setting the query cache size to an invalid value will cause an error. Otherwise, it will be set to the nearest permitted value, and a warning will be triggered.</source>
          <target state="translated">경우 &lt;a href=&quot;../sql-mode/index&quot;&gt;엄격 모드가&lt;/a&gt; 활성화되어, 유효하지 않은 값으로 쿼리 캐시 크기를 설정하면 오류가 발생합니다. 그렇지 않으면 가장 가까운 허용 값으로 설정되고 경고가 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="db95f77b4e48fd506af19e8186975d9ae0723acd" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../system-tables/index&quot;&gt;system tables&lt;/a&gt; really do not exist, then you may need to create them with &lt;code&gt;&lt;a href=&quot;../mysql_install_db/index&quot;&gt;mysql_install_db&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;../installing-system-tables-mysql_install_db/index&quot;&gt;Installing System Tables (mysql_install_db)&lt;/a&gt; for more information.</source>
          <target state="translated">경우 &lt;a href=&quot;../system-tables/index&quot;&gt;시스템 테이블이&lt;/a&gt; 실제로 존재하지 않는, 당신은 그들을 만들어야 할 수도 있습니다 &lt;code&gt;&lt;a href=&quot;../mysql_install_db/index&quot;&gt;mysql_install_db&lt;/a&gt;&lt;/code&gt; 가 . 자세한 정보는 &lt;a href=&quot;../installing-system-tables-mysql_install_db/index&quot;&gt;시스템 테이블 설치 (mysql_install_db)&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="13c73d18f14d1181e4ceb609eee2f107032f6e4b" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_ft_user_stopword_table&quot;&gt;innodb_ft_user_stopword_table&lt;/a&gt; system variable is set, that table is used as a stopword list.</source>
          <target state="translated">경우] &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_ft_user_stopword_table&quot;&gt;innodb_ft_user_stopword_table&lt;/a&gt; 시스템 변수가 설정되고,이 테이블은 스톱 워드리스트로서 사용된다.</target>
        </trans-unit>
        <trans-unit id="bba38bd84c4e367f47a17b164dd4444c4b8891d2" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_status_output_locks&quot;&gt;innodb_status_output_locks&lt;/a&gt; system variable is set to &lt;code&gt;1&lt;/code&gt;, extended lock information will be displayed.</source>
          <target state="translated">경우] &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_status_output_locks&quot;&gt;innodb_status_output_locks의&lt;/a&gt; 시스템 변수로 설정 &lt;code&gt;1&lt;/code&gt; 확장 로크 정보가 표시된다.</target>
        </trans-unit>
        <trans-unit id="e7b42a5ab6959e42ab3f426879590ebe63c76031" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--&lt;/code&gt; option is not given, replace reads standard input and writes to standard output.</source>
          <target state="translated">는 IF &lt;code&gt;--&lt;/code&gt; 옵션이 제공되지 않으며, 대신 표준 입력을 읽고 표준 출력에 기록합니다.</target>
        </trans-unit>
        <trans-unit id="9c8cd4fc93ec671988c295ddc02f77311ead5c76" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--comments&lt;/code&gt; option and this option are given, &lt;code&gt;mysqldump&lt;/code&gt; produces a comment at the end of the dump of the following form:</source>
          <target state="translated">는 IF &lt;code&gt;--comments&lt;/code&gt; 의 옵션이 옵션이 제공됩니다, &lt;code&gt;mysqldump&lt;/code&gt; 는이 다음과 같은 형식의 덤프의 끝 부분에 주석을 생성합니다</target>
        </trans-unit>
        <trans-unit id="ccd8f2869ddb48b0c1eef992389a5bd43b3af1dd" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;#feedback_url&quot;&gt;feedback_url&lt;/a&gt;&lt;/code&gt; system variable is not set to an empty string, then the plugin will automatically send a report to all URLs in the list a few minutes after the server starts up and then once a week after that.</source>
          <target state="translated">는 IF &lt;code&gt;&lt;a href=&quot;#feedback_url&quot;&gt;feedback_url&lt;/a&gt;&lt;/code&gt; 의 시스템 변수가 빈 문자열로 설정되지 않은 서버가 시작되고 그 후 일주일에 한 번 몇 분 후, 플러그인은 자동으로 목록에있는 모든 URL에 대한 보고서를 보낼 것입니다.</target>
        </trans-unit>
        <trans-unit id="bf8508175d8beef274c78979f9e2d0e3b69c8778" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;#feedback_url&quot;&gt;feedback_url&lt;/a&gt;&lt;/code&gt; system variable is set to an empty string, then the plugin will &lt;strong&gt;not&lt;/strong&gt; automatically send any data. This may be necessary if outbound HTTP communication from your database server is not permitted. In this case, you can still upload the data manually, if you'd like.</source>
          <target state="translated">는 IF &lt;code&gt;&lt;a href=&quot;#feedback_url&quot;&gt;feedback_url&lt;/a&gt;&lt;/code&gt; 의 시스템 변수가 빈 문자열로 설정 한 다음 플러그인 할 &lt;strong&gt;수 없습니다&lt;/strong&gt; 자동으로 데이터를 전송합니다. 데이터베이스 서버로부터의 아웃 바운드 HTTP 통신이 허용되지 않는 경우에 필요할 수 있습니다. 이 경우 원하는 경우 데이터를 수동으로 업로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a4bb2da9621200078405f65accbc2db5a0efda1" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;../alter-table/index#lock&quot;&gt;LOCK&lt;/a&gt;&lt;/code&gt; clause is not explicitly set, then the operation uses &lt;code&gt;LOCK=DEFAULT&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;&lt;a href=&quot;../alter-table/index#lock&quot;&gt;LOCK&lt;/a&gt;&lt;/code&gt; 의 절을 명시 적으로 설정되어 있지 않은 경우, 동작 용도는 &lt;code&gt;LOCK=DEFAULT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc0bcc1193012d5aa3b4abada2c413d160d96bdf" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;../create-table/index#encryption_key_id&quot;&gt;ENCRYPTION_KEY_ID&lt;/a&gt;&lt;/code&gt; table option is not set for a table that uses &lt;a href=&quot;../innodb-enabling-encryption/index#enabling-encryption-for-manually-encrypted-tablespaces&quot;&gt;manually&lt;/a&gt; enabled encryption, then it will inherit the value from the &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_default_encryption_key_id&quot;&gt;innodb_default_encryption_key_id&lt;/a&gt;&lt;/code&gt; system variable. For example:</source>
          <target state="translated">는 IF &lt;code&gt;&lt;a href=&quot;../create-table/index#encryption_key_id&quot;&gt;ENCRYPTION_KEY_ID&lt;/a&gt;&lt;/code&gt; 의 테이블 옵션이 사용가있는 테이블에 대해 설정되지 않은 &lt;a href=&quot;../innodb-enabling-encryption/index#enabling-encryption-for-manually-encrypted-tablespaces&quot;&gt;수동&lt;/a&gt; 암호화를 활성화, 다음은의 값 상속 &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_default_encryption_key_id&quot;&gt;innodb_default_encryption_key_id&lt;/a&gt;&lt;/code&gt; 시스템 변수를. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="28749726bdc6838f81a58ec19467e3e5052fea26" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;../create-table/index#encryption_key_id&quot;&gt;ENCRYPTION_KEY_ID&lt;/a&gt;&lt;/code&gt; table option is not specified, then the table will be encrypted with the key identified by the &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_default_encryption_key_id&quot;&gt;innodb_default_encryption_key_id&lt;/a&gt;&lt;/code&gt; system variable. For example, you might create a table using a statement like this:</source>
          <target state="translated">는 IF &lt;code&gt;&lt;a href=&quot;../create-table/index#encryption_key_id&quot;&gt;ENCRYPTION_KEY_ID&lt;/a&gt;&lt;/code&gt; 의 테이블 옵션을 지정하지, 다음 테이블에 의해 확인 된 키를 사용하여 암호화됩니다 &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_default_encryption_key_id&quot;&gt;innodb_default_encryption_key_id&lt;/a&gt;&lt;/code&gt; 시스템 변수. 예를 들어 다음과 같은 명령문을 사용하여 테이블을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c20d213fac93d1d1e2f1d75344f1b4eb84174c06" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;../create-table/index#row_format&quot;&gt;ROW_FORMAT&lt;/a&gt;&lt;/code&gt; table option for this table is set to &lt;code&gt;&lt;a href=&quot;../innodb-storage-formats/index#compressed&quot;&gt;COMPRESSED&lt;/a&gt;&lt;/code&gt;, then this field contains the value of the compressed page size.</source>
          <target state="translated">이 테이블 의 &lt;code&gt;&lt;a href=&quot;../create-table/index#row_format&quot;&gt;ROW_FORMAT&lt;/a&gt;&lt;/code&gt; 테이블 옵션이 &lt;code&gt;&lt;a href=&quot;../innodb-storage-formats/index#compressed&quot;&gt;COMPRESSED&lt;/a&gt;&lt;/code&gt; 로 설정된 경우이 필드에는 압축 된 페이지 크기 값이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="a9a6e589b7605a7d6bd5e24cb9b42a8eaef5bba9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;../high_priority-and-low_priority-clauses/index&quot;&gt;LOW_PRIORITY&lt;/a&gt;&lt;/code&gt; keyword is used, insertions are delayed until no other clients are reading from the table. The &lt;code&gt;CONCURRENT&lt;/code&gt; keyword allowes the use of &lt;a href=&quot;../concurrent-inserts/index&quot;&gt;concurrent inserts&lt;/a&gt;. These clauses cannot be specified together.</source>
          <target state="translated">는 IF &lt;code&gt;&lt;a href=&quot;../high_priority-and-low_priority-clauses/index&quot;&gt;LOW_PRIORITY&lt;/a&gt;&lt;/code&gt; 의 키워드를 사용하는, 삽입은 다른 클라이언트가 테이블에서 읽기되지 않을 때까지 지연됩니다. &lt;code&gt;CONCURRENT&lt;/code&gt; 키워드의 사용 allowes &lt;a href=&quot;../concurrent-inserts/index&quot;&gt;동시 삽입을&lt;/a&gt; . 이 절은 함께 지정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5061e81fc7e8e135f33c23f40b676a8dca78d5e4" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;../library/create-table/index#key_block_size&quot;&gt;KEY_BLOCK_SIZE&lt;/a&gt;&lt;/code&gt; table option is &lt;strong&gt;not&lt;/strong&gt; set to some value, but the &lt;code&gt;&lt;a href=&quot;../create-table/index#row_format&quot;&gt;ROW_FORMAT&lt;/a&gt;&lt;/code&gt; table option is set to &lt;code&gt;COMPRESSED&lt;/code&gt; in a &lt;code&gt;&lt;a href=&quot;../create-table/index&quot;&gt;CREATE TABLE&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt;&lt;/code&gt; statement, then InnoDB uses a default value of &lt;code&gt;8&lt;/code&gt; for the &lt;code&gt;&lt;a href=&quot;../library/create-table/index#key_block_size&quot;&gt;KEY_BLOCK_SIZE&lt;/a&gt;&lt;/code&gt; table option. For example:</source>
          <target state="translated">는 IF &lt;code&gt;&lt;a href=&quot;../library/create-table/index#key_block_size&quot;&gt;KEY_BLOCK_SIZE&lt;/a&gt;&lt;/code&gt; 의 테이블 옵션이되어 &lt;strong&gt;있지&lt;/strong&gt; 어떤 값으로 설정하지만, &lt;code&gt;&lt;a href=&quot;../create-table/index#row_format&quot;&gt;ROW_FORMAT&lt;/a&gt;&lt;/code&gt; 의 테이블 옵션이 설정되어 &lt;code&gt;COMPRESSED&lt;/code&gt; A의 &lt;code&gt;&lt;a href=&quot;../create-table/index&quot;&gt;CREATE TABLE&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt;&lt;/code&gt; 문은 다음 InnoDB하지만 기본값 사용 &lt;code&gt;8&lt;/code&gt; 에 대한 &lt;code&gt;&lt;a href=&quot;../library/create-table/index#key_block_size&quot;&gt;KEY_BLOCK_SIZE&lt;/a&gt;&lt;/code&gt; 의 테이블 옵션을 선택합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4fafe99ecd823b7e0172cd4254f733081ec24d7e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-compress&quot;&gt;--compress&lt;/a&gt;&lt;/code&gt; option was provided, then this value will be &lt;code&gt;compressed&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-compress&quot;&gt;--compress&lt;/a&gt;&lt;/code&gt; 옵션이 제공 한 후이 값이됩니다 &lt;code&gt;compressed&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="05acab1113bfa32617bb457e464b396c332caefa" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-extra-lsndir&quot;&gt;--extra-lsndir&lt;/a&gt;&lt;/code&gt; option is provided, then an extra copy of this file will be saved in that directory.</source>
          <target state="translated">는 IF &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-extra-lsndir&quot;&gt;--extra-lsndir&lt;/a&gt;&lt;/code&gt; 의 옵션이 제공되며,이 파일의 추가 사본은 그 디렉토리에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="43cb2371e4720037438a6c2d65f364aaae2f7b14" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-galera-info&quot;&gt;--galera-info&lt;/a&gt;&lt;/code&gt; option is provided, then this file contains information about a &lt;a href=&quot;../galera/index&quot;&gt;Galera Cluster&lt;/a&gt; node's state.</source>
          <target state="translated">는 IF &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-galera-info&quot;&gt;--galera-info&lt;/a&gt;&lt;/code&gt; 옵션이 제공되며,이 파일은에 대한 정보가 포함 &lt;a href=&quot;../galera/index&quot;&gt;갈레 클러스터&lt;/a&gt; 노드의 상태를.</target>
        </trans-unit>
        <trans-unit id="c0109df029aa56c453d782bf34e0242d74ebc015" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-slave-info&quot;&gt;--slave-info&lt;/a&gt;&lt;/code&gt; option is provided, then this file contains the &lt;code&gt;&lt;a href=&quot;../change-master-to/index&quot;&gt;CHANGE MASTER&lt;/a&gt;&lt;/code&gt; command that can be used to set up a new server as a slave of the original server's master after the backup has been restored.</source>
          <target state="translated">는 IF &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-slave-info&quot;&gt;--slave-info&lt;/a&gt;&lt;/code&gt; 옵션이 제공되며,이 파일이 포함되어 &lt;code&gt;&lt;a href=&quot;../change-master-to/index&quot;&gt;CHANGE MASTER&lt;/a&gt;&lt;/code&gt; 백업이 복원 된 후 원래 서버의 마스터의 노예로 새 서버를 설정하는 데 사용할 수있는 명령을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3b5ba13543bdf5ed4f43f90388cb1fcfdd475a46" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-stream&quot;&gt;--stream&lt;/a&gt;&lt;/code&gt; option was &lt;strong&gt;not&lt;/strong&gt; provided, then this value will be &lt;code&gt;file&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-stream&quot;&gt;--stream&lt;/a&gt;&lt;/code&gt; 옵션이되었다 &lt;strong&gt;되지&lt;/strong&gt; 제공,이 값이됩니다 &lt;code&gt;file&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d20bf71d3629b1b2a2d8adc9e916b05b6e0d5305" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-stream&quot;&gt;--stream&lt;/a&gt;&lt;/code&gt; option was set to &lt;code&gt;xbstream&lt;/code&gt;, then this value will be &lt;code&gt;xbstream&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-stream&quot;&gt;--stream&lt;/a&gt;&lt;/code&gt; 옵션으로 설정되어 &lt;code&gt;xbstream&lt;/code&gt; ,이 값이 될 것입니다 &lt;code&gt;xbstream&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c2d95703749e2f262c5ca116bc9865e7b7dabef" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-plugin-load&quot;&gt;--plugin-load&lt;/a&gt;&lt;/code&gt; option is specified &lt;strong&gt;after&lt;/strong&gt; the &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-plugin-load-add&quot;&gt;--plugin-load-add&lt;/a&gt;&lt;/code&gt; option, then it will also reset the changes made by that option. For example, in the following case, the &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-plugin-load-add&quot;&gt;--plugin-load-add&lt;/a&gt;&lt;/code&gt; option does not do anything, because the subsequent &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-plugin-load&quot;&gt;--plugin-load&lt;/a&gt;&lt;/code&gt; option resets the plugin load list:</source>
          <target state="translated">는 IF &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-plugin-load&quot;&gt;--plugin-load&lt;/a&gt;&lt;/code&gt; 옵션이 지정된 &lt;strong&gt;후 &lt;/strong&gt; &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-plugin-load-add&quot;&gt;--plugin-load-add&lt;/a&gt;&lt;/code&gt; 옵션, 그것은 또한 옵션으로 변경 한 내용을 다시 설정합니다. 예를 들어 다음과 같은 경우 &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-plugin-load-add&quot;&gt;--plugin-load-add&lt;/a&gt;&lt;/code&gt; 옵션은 아무 것도하지 않습니다. 후속 &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-plugin-load&quot;&gt;--plugin-load&lt;/a&gt;&lt;/code&gt; 옵션은 플러그인로드 목록을 재설정 하기 때문입니다 .</target>
        </trans-unit>
        <trans-unit id="88f0f029090335292879c49b41c0cb5b5b529ccc" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-plugin-load&quot;&gt;--plugin-load&lt;/a&gt;&lt;/code&gt; option is specified &lt;strong&gt;multiple times&lt;/strong&gt;, then only the last instance will have any effect. For example, in the following case, the first instance of the option is reset:</source>
          <target state="translated">는 IF &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-plugin-load&quot;&gt;--plugin-load&lt;/a&gt;&lt;/code&gt; 옵션이 지정되어 &lt;strong&gt;여러 번&lt;/strong&gt; , 다음 마지막 인스턴스는 어떤 영향을 미칠 것입니다. 예를 들어 다음과 같은 경우 옵션의 첫 번째 인스턴스가 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="2b32655605dcb8df03d50109da8e60434f96aca7" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#slave_net_timeout&quot;&gt;slave_net_timeout&lt;/a&gt;&lt;/code&gt; system variable is set to a value that is lower than the current heartbeat interval, then a warning will be issued.</source>
          <target state="translated">경우] &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#slave_net_timeout&quot;&gt;slave_net_timeout&lt;/a&gt;&lt;/code&gt; 된 시스템 변수가 현재 응답 간격보다 낮은 값으로 설정 한 후 경고를 발행한다.</target>
        </trans-unit>
        <trans-unit id="bcc5fc3ac812c94fb7d1bc6c15ba059c599c9861" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;../reset-slave-connection_name/index&quot;&gt;RESET SLAVE&lt;/a&gt;&lt;/code&gt; statement is executed, then the heartbeat interval is reset to the default.</source>
          <target state="translated">는 IF &lt;code&gt;&lt;a href=&quot;../reset-slave-connection_name/index&quot;&gt;RESET SLAVE&lt;/a&gt;&lt;/code&gt; 문을 실행 한 후 하트 비트 간격이 기본값으로 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="705122d4e35c3ead68e1ccd1e0ace25ab5af7682" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#lc_messages&quot;&gt;lc_messages&lt;/a&gt;&lt;/code&gt; system variable is set to a valid &lt;a href=&quot;../server-locale/index&quot;&gt;locale&lt;/a&gt; name, but the server can't find an &lt;a href=&quot;../error-log/index#error-messages-file&quot;&gt;error message file&lt;/a&gt; for the language associated with the &lt;a href=&quot;../server-locale/index&quot;&gt;locale&lt;/a&gt;, then the default language will be used instead.</source>
          <target state="translated">경우 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#lc_messages&quot;&gt;lc_messages&lt;/a&gt;&lt;/code&gt; 시스템 변수가 유효로 설정되어 &lt;a href=&quot;../server-locale/index&quot;&gt;로케일&lt;/a&gt; 이름,하지만 서버가 찾을 수 없습니다 &lt;a href=&quot;../error-log/index#error-messages-file&quot;&gt;오류 메시지 파일&lt;/a&gt; 과 연관된 언어에 대한 &lt;a href=&quot;../server-locale/index&quot;&gt;로케일을&lt;/a&gt; 한 후 기본 언어가 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="58657f7436cc5c895780d438bd17bc52ff5a1343" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#log_error&quot;&gt;log_error&lt;/a&gt;&lt;/code&gt; system variable was set in an &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;option file&lt;/a&gt; or on the command-line, then it can still be unset by specifying &lt;code&gt;--skip-log-error&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#log_error&quot;&gt;log_error&lt;/a&gt;&lt;/code&gt; 시스템 변수가 설정 한 &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;옵션 파일&lt;/a&gt; 또는 명령 줄에서, 그것은 여전히 지정하여 해제 할 수 있습니다 &lt;code&gt;--skip-log-error&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a41e8c1c7edafaea36967568c755c2aac9066fe0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#query_cache_type&quot;&gt;query_cache_type&lt;/a&gt;&lt;/code&gt; system variable is set to &lt;code&gt;1&lt;/code&gt;, or &lt;code&gt;ON&lt;/code&gt;, all queries fitting the size constraints will be stored in the cache unless they contain a &lt;code&gt;SQL_NO_CACHE&lt;/code&gt; clause, or are of a nature that caching makes no sense, for example making use of a function that returns the current time. Check that &lt;code&gt;SQL_NO_CACHE&lt;/code&gt; will force server to don't use query cache locks.</source>
          <target state="translated">는 IF &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#query_cache_type&quot;&gt;query_cache_type&lt;/a&gt;&lt;/code&gt; 시스템 변수로 설정되어 &lt;code&gt;1&lt;/code&gt; , 또는 &lt;code&gt;ON&lt;/code&gt; 그들이 포함하지 않는 크기의 제약을 피팅 모든 쿼리는 캐시에 저장됩니다 &lt;code&gt;SQL_NO_CACHE&lt;/code&gt; 의 절을, 또는 캐시가 말이 안하는 성격의 함수의 예를하게 사용하기 위해, 현재 시간을 반환합니다. 있는지 확인 &lt;code&gt;SQL_NO_CACHE&lt;/code&gt; 는 쿼리 캐시 잠금을 사용하지 않는하기 위해 서버를 강제 할 것이다.</target>
        </trans-unit>
        <trans-unit id="a5a26a775953a5591f7ca258f39c3c408cce11e2" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#sql_notes&quot;&gt;sql_notes&lt;/a&gt;&lt;/code&gt; server variable is set to 1, Notes are included in the output of &lt;code&gt;SHOW WARNINGS&lt;/code&gt;; if it is set to 0, this statement will not show (or count) Notes.</source>
          <target state="translated">경우] &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#sql_notes&quot;&gt;sql_notes&lt;/a&gt;&lt;/code&gt; 의 서버 변수가 1로 설정되고, 노트의 출력에 포함 된 &lt;code&gt;SHOW WARNINGS&lt;/code&gt; ; 0으로 설정되면이 명령문은 메모를 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1a631596014cc597901323fbe7a81bec5b5ff3d3" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;../sql-mode/index&quot;&gt;SQL_MODE&lt;/a&gt;&lt;/code&gt; contains &lt;code&gt;STRICT_TRANS_TABLES&lt;/code&gt; and you are &lt;a href=&quot;../insert/index&quot;&gt;inserting&lt;/a&gt; into a transactional table (like InnoDB), or if the SQL_MODE contains &lt;code&gt;STRICT_ALL_TABLES&lt;/code&gt;, all &lt;code&gt;NOT NULL&lt;/code&gt; columns which does not have a &lt;code&gt;DEFAULT&lt;/code&gt; value (and is not &lt;a href=&quot;../auto_increment/index&quot;&gt;AUTO_INCREMENT&lt;/a&gt;) must be explicitly referenced in &lt;code&gt;INSERT&lt;/code&gt; statements. If not, an error like this is produced:</source>
          <target state="translated">는 IF &lt;code&gt;&lt;a href=&quot;../sql-mode/index&quot;&gt;SQL_MODE&lt;/a&gt;&lt;/code&gt; 가 포함 &lt;code&gt;STRICT_TRANS_TABLES&lt;/code&gt; 를 하면된다 &lt;a href=&quot;../insert/index&quot;&gt;삽입&lt;/a&gt; (이노 같은) 트랜잭션 테이블에, 또는 SQL_MODE가 포함 된 경우 &lt;code&gt;STRICT_ALL_TABLES&lt;/code&gt; 모든 &lt;code&gt;NOT NULL&lt;/code&gt; 이없는 열 &lt;code&gt;DEFAULT&lt;/code&gt; 의 값을 (그리고하지 &lt;a href=&quot;../auto_increment/index&quot;&gt;AUTO_INCREMENT을&lt;/a&gt; )를 명시 적으로 참조해야 &lt;code&gt;INSERT&lt;/code&gt; 의 문. 그렇지 않으면 다음과 같은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d4227174868c2614425b7ee9406a10151f33602e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_defragment&quot;&gt;innodb_defragment&lt;/a&gt;&lt;/code&gt; system variable is set to &lt;code&gt;OFF&lt;/code&gt;, and if the &lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_optimize_fulltext_only&quot;&gt;innodb_optimize_fulltext_only&lt;/a&gt;&lt;/code&gt; system variable is also set to &lt;code&gt;OFF&lt;/code&gt;, then &lt;code&gt;OPTIMIZE TABLE&lt;/code&gt; will be equivalent to &lt;code&gt;ALTER TABLE &amp;hellip; FORCE&lt;/code&gt;.</source>
          <target state="translated">경우] &lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_defragment&quot;&gt;innodb_defragment&lt;/a&gt;&lt;/code&gt; 시스템 변수로 설정 &lt;code&gt;OFF&lt;/code&gt; 경우 생성하고 &lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_optimize_fulltext_only&quot;&gt;innodb_optimize_fulltext_only&lt;/a&gt;&lt;/code&gt; 시스템 변수가 또한 설정되어 &lt;code&gt;OFF&lt;/code&gt; 후 &lt;code&gt;OPTIMIZE TABLE&lt;/code&gt; 상당 할 것이다 &lt;code&gt;ALTER TABLE &amp;hellip; FORCE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b2b49b9f1fb9685de9011d6a105aebafdec39f4f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ALLOW_INVALID_DATES&lt;/code&gt; flag is set, the invalid dates (for example, 30th February) are allowed. If not, if the &lt;code&gt;NO_ZERO_DATE&lt;/code&gt; is set, an error is produced; otherwise, a zero-date is returned.</source>
          <target state="translated">는 IF &lt;code&gt;ALLOW_INVALID_DATES&lt;/code&gt; 의 플래그가 설정되어, 유효하지 않은 날짜 (예를 들어, 2월 30일)를 사용할 수 있습니다. 그렇지 않으면 &lt;code&gt;NO_ZERO_DATE&lt;/code&gt; 가 설정되면 오류가 발생합니다. 그렇지 않으면 제로 날짜가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4cc567ab664440578981ccbcd534df755ea0e3de" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;CLIENT_MULTI_RESULTS&lt;/code&gt; API flag is set, &lt;code&gt;CALL&lt;/code&gt; can return any number of resultsets and the called stored procedure can execute prepared statements. If it is not set, at most one resultset can be returned and prepared statements cannot be used within procedures.</source>
          <target state="translated">는 IF &lt;code&gt;CLIENT_MULTI_RESULTS&lt;/code&gt; 의 API 플래그가 설정되어, &lt;code&gt;CALL&lt;/code&gt; 은 결과 집합의 수를 반환 할 수 있으며 호출 된 저장 프로 시저가 준비된 문을 실행할 수 있습니다. 설정하지 않으면 최대 하나의 결과 집합을 반환 할 수 있으며 준비된 문을 프로 시저 내에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="09f302bba4d452bf307abff5dee2010030334cdf" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;COPY&lt;/code&gt; algorithm is specified with the &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; clause or with the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#alter_algorithm&quot;&gt;alter_algorithm&lt;/a&gt;&lt;/code&gt; system variable, then the &lt;code&gt;COPY&lt;/code&gt; algorithm will be used even if it is not necessary. This can result in a lengthy table copy. If multiple &lt;code&gt;&lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt;&lt;/code&gt; operations are required that each require the table to be rebuilt, then it is best to specify all operations in a single &lt;code&gt;&lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt;&lt;/code&gt; statement, so that the table is only rebuilt once.</source>
          <target state="translated">는 IF &lt;code&gt;COPY&lt;/code&gt; 알고리즘이 지정 될 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 절 또는 함께 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#alter_algorithm&quot;&gt;alter_algorithm&lt;/a&gt;&lt;/code&gt; 의 시스템 변수, 다음 &lt;code&gt;COPY&lt;/code&gt; 알고리즘은 필요없는 경우에도 사용됩니다. 테이블 길이가 길어질 수 있습니다. 각각의 테이블을 재 빌드해야하는 복수의 &lt;code&gt;&lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt;&lt;/code&gt; 조작이 필요한 경우, 테이블을 한 번만 재 빌드 할 수 있도록 단일 &lt;code&gt;&lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt;&lt;/code&gt; 문 에서 모든 조작을 지정하는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="6e86f5147d841c8693edbcc6630694093cd2f54f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;COPY&lt;/code&gt; algorithm is used with an &lt;a href=&quot;../innodb/index&quot;&gt;InnoDB&lt;/a&gt; table, then the following statements apply:</source>
          <target state="translated">는 IF &lt;code&gt;COPY&lt;/code&gt; 알고리즘가 사용됩니다 &lt;a href=&quot;../innodb/index&quot;&gt;이노&lt;/a&gt; 테이블, 다음 문이 적용됩니다</target>
        </trans-unit>
        <trans-unit id="fadf6da480b0927041911868411b49db08b7ebe6" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;DEFAULT&lt;/code&gt; keyword is used but the column does not have a &lt;code&gt;DEFAULT&lt;/code&gt; value, an error like this is produced:</source>
          <target state="translated">경우 &lt;code&gt;DEFAULT&lt;/code&gt; 의 키워드가 사용되지만 열이없는 &lt;code&gt;DEFAULT&lt;/code&gt; 의 값을,이 같은 오류가 생성됩니다</target>
        </trans-unit>
        <trans-unit id="5d1cd2b600e4fba8428a8a86eb92bcb1ef26526b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ERROR_ON_DIVISION_BY_ZERO&lt;/code&gt;&lt;a href=&quot;../sql-mode/index&quot;&gt;SQL_MODE&lt;/a&gt; is used, a division by zero produces an error. Otherwise, it returns NULL.</source>
          <target state="translated">&lt;code&gt;ERROR_ON_DIVISION_BY_ZERO&lt;/code&gt; &lt;a href=&quot;../sql-mode/index&quot;&gt;SQL_MODE&lt;/a&gt; 를 사용 하면 0으로 나누면 오류가 발생합니다. 그렇지 않으면 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0319888c56d66776153e46fb5fb015ef7b1c5595" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ERROR_ON_DIVISION_BY_ZERO&lt;/code&gt;&lt;a href=&quot;../sql-mode/index&quot;&gt;SQL_MODE&lt;/a&gt; is used, any number modulus zero produces an error. Otherwise, it returns NULL.</source>
          <target state="translated">는 IF &lt;code&gt;ERROR_ON_DIVISION_BY_ZERO&lt;/code&gt; &lt;a href=&quot;../sql-mode/index&quot;&gt;SQL_MODE가&lt;/a&gt; 사용되며, 임의의 숫자 계수 제로 오류가 발생합니다. 그렇지 않으면 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1afd7470fed1f1fe79f8b97dd4bd4ac6755ac159" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;FOR SYSTEM_TIME&lt;/code&gt; clause is not used, the table will show the &lt;em&gt;current&lt;/em&gt; data, as if one had specified &lt;code&gt;FOR SYSTEM_TIME AS OF CURRENT_TIMESTAMP&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;FOR SYSTEM_TIME&lt;/code&gt; 절을 사용하지 않는 테이블이 표시됩니다 &lt;em&gt;현재&lt;/em&gt; 하나가 지정된 것처럼, 데이터를 &lt;code&gt;FOR SYSTEM_TIME AS OF CURRENT_TIMESTAMP&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e38b4c7b8a757ef5d496dd0144a697b70bfc8fb6" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;HIGH_NOT_PRECEDENCE&lt;/code&gt;&lt;a href=&quot;../sql-mode/index&quot;&gt;SQL_MODE&lt;/a&gt; is set, &lt;code&gt;NOT&lt;/code&gt; has the same precedence as &lt;code&gt;!&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;HIGH_NOT_PRECEDENCE&lt;/code&gt; 의&lt;a href=&quot;../sql-mode/index&quot;&gt;SQL_MODE가&lt;/a&gt; 설정되어, &lt;code&gt;NOT&lt;/code&gt; 과 같은 우선 순위가 &lt;code&gt;!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b1699f12f1edf127f30a53fb93ae39e57a67f110" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;IF EXISTS&lt;/code&gt; clause is used, MariaDB will return a note instead of an error if the plugin does not exist. See &lt;a href=&quot;../show-warnings/index&quot;&gt;SHOW WARNINGS&lt;/a&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;IF EXISTS&lt;/code&gt; 절은 사용되는 플러그인이 존재하지 않는 경우, MariaDB는 오류 대신 메모를 반환합니다. &lt;a href=&quot;../show-warnings/index&quot;&gt;경고 표시를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c3eda8b291566fae7304fe724fc3a9d315fb72c0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;IF EXISTS&lt;/code&gt; clause is used, MariaDB will return a note instead of an error if the plugin library does not exist. See &lt;a href=&quot;../show-warnings/index&quot;&gt;SHOW WARNINGS&lt;/a&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;IF EXISTS&lt;/code&gt; 절은 사용되는 플러그인 라이브러리가 존재하지 않는 경우, MariaDB는 오류 대신 메모를 반환합니다. &lt;a href=&quot;../show-warnings/index&quot;&gt;경고 표시를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a68c894857eca8918e46f54443cfc1bc9c114a63" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;IF EXISTS&lt;/code&gt; clause is used, MariaDB will return a note instead of an error if the user does not exist.</source>
          <target state="translated">는 IF &lt;code&gt;IF EXISTS&lt;/code&gt; 절을 사용하는 사용자가 존재하지 않는 경우, MariaDB는 오류 대신 메모를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2b11e75e87ec89cb6805650a92e03274cc03b96e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;IF EXISTS&lt;/code&gt; clause is used, MariaDB will return a warning instead of an error if the role does not exist.</source>
          <target state="translated">는 IF &lt;code&gt;IF EXISTS&lt;/code&gt; 절을 사용하는 역할이 존재하지 않는 경우, MariaDB는 오류 대신 경고를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="07aa51e45b2813184cfd1c960d61c2e265f414e1" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;IF EXISTS&lt;/code&gt; clause is used, then MariaDB will return a warning instead of an error if the index does not exist.</source>
          <target state="translated">는 IF &lt;code&gt;IF EXISTS&lt;/code&gt; 사용되는 절을 인덱스가 존재하지 않는 경우, MariaDB는 오류 대신 경고를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6a0f22b1035182f543d81f8b618898eff58d60fe" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;IF NOT EXISTS&lt;/code&gt; clause is used and the table exists, a note will be produced instead of an error.</source>
          <target state="translated">는 IF &lt;code&gt;IF NOT EXISTS&lt;/code&gt; 절을 사용하고 테이블이 존재, 메모 대신 오류로 생산 될 것이다.</target>
        </trans-unit>
        <trans-unit id="57e737da2654f00834b79984d2d936eaf69bdb1a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;IF NOT EXISTS&lt;/code&gt; clause is used, MariaDB will return a warning instead of an error if the event already exists. Cannot be used together with OR REPLACE.</source>
          <target state="translated">는 IF &lt;code&gt;IF NOT EXISTS&lt;/code&gt; 절을 사용하는 이벤트가 이미 존재하는 경우, MariaDB는 오류 대신 경고를 반환합니다. OR REPLACE와 함께 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2c8ea0a138e9b8acaf34bda49c8b6525d0cfe7a3" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;IF NOT EXISTS&lt;/code&gt; clause is used, the trigger will only be created if a trigger of the same name does not exist. If the trigger already exists, by default a warning will be returned.</source>
          <target state="translated">는 IF &lt;code&gt;IF NOT EXISTS&lt;/code&gt; 절은 사용되는 동일한 이름의 트리거가 존재하지 않는 경우, 트리거 만 생성됩니다. 트리거가 이미 존재하면 기본적으로 경고가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="ccbff25d9b4b0e69662375a9372a9f12adaf2dca" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;IF NOT EXISTS&lt;/code&gt; clause is used, then the index will only be created if an index with the same name does not already exist. If the index already exists, then a warning will be triggered by default.</source>
          <target state="translated">는 IF &lt;code&gt;IF NOT EXISTS&lt;/code&gt; 절은 사용되는 동일한 이름을 가진 인덱스가 존재하지 않는 경우, 인덱스 만 생성됩니다. 인덱스가 이미 존재하면 기본적으로 경고가 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="9be3cacc03d2fd7a501304ea149e88128ff69603" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;IGNORE_BAD_TABLE_OPTIONS&lt;/code&gt;&lt;a href=&quot;../sql-mode/index&quot;&gt;SQL_MODE&lt;/a&gt; is enabled, wrong table options generate a warning; otherwise, they generate an error.</source>
          <target state="translated">는 IF &lt;code&gt;IGNORE_BAD_TABLE_OPTIONS&lt;/code&gt; 의&lt;a href=&quot;../sql-mode/index&quot;&gt;SQL_MODE가&lt;/a&gt; 활성화되어, 잘못된 테이블 옵션은 경고를 생성; 그렇지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="313bde5a6e0e22bc3925da7bbe607223ed5120c7" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;IGNORE_SPACE&lt;/code&gt;&lt;a href=&quot;../sql-mode/index&quot;&gt;SQL_MODE&lt;/a&gt; flag is set, function names become reserved words.</source>
          <target state="translated">는 IF &lt;code&gt;IGNORE_SPACE&lt;/code&gt; 의&lt;a href=&quot;../sql-mode/index&quot;&gt;SQL_MODE의&lt;/a&gt; 플래그가 설정되어, 함수 이름은 예약어된다.</target>
        </trans-unit>
        <trans-unit id="3c011b5c20c93c144962724ee99790867e040a50" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;INPLACE&lt;/code&gt; algorithm is specified with the &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; clause or with the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#alter_algorithm&quot;&gt;alter_algorithm&lt;/a&gt;&lt;/code&gt; system variable and if the &lt;code&gt;&lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt;&lt;/code&gt; operation does not support the &lt;code&gt;INPLACE&lt;/code&gt; algorithm, then an error will be raised. For example:</source>
          <target state="translated">는 IF &lt;code&gt;INPLACE&lt;/code&gt; 의 알고리즘이 지정 될 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 절 또는 함께 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#alter_algorithm&quot;&gt;alter_algorithm&lt;/a&gt;&lt;/code&gt; 의 시스템 변수와 경우 &lt;code&gt;&lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt;&lt;/code&gt; 작업은 지원하지 않습니다 &lt;code&gt;INPLACE&lt;/code&gt; 의 알고리즘을, 다음 오류가 발생합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="74b842e83d67f3791d7d49fecf64b995e8862e4b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;INPLACE&lt;/code&gt; algorithm is used with an &lt;a href=&quot;../innodb/index&quot;&gt;InnoDB&lt;/a&gt; table, then the following statements apply:</source>
          <target state="translated">는 IF &lt;code&gt;INPLACE&lt;/code&gt; 의 알고리즘가 사용됩니다 &lt;a href=&quot;../innodb/index&quot;&gt;이노&lt;/a&gt; 테이블, 다음 문이 적용됩니다</target>
        </trans-unit>
        <trans-unit id="056d6d84190c6de78fa9b28c7be5c2e9fdf15928" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;INSTANT&lt;/code&gt; algorithm is specified with the &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; clause or with the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#alter_algorithm&quot;&gt;alter_algorithm&lt;/a&gt;&lt;/code&gt; system variable and if the &lt;code&gt;&lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt;&lt;/code&gt; operation does not support the &lt;code&gt;INSTANT&lt;/code&gt; algorithm, then an error will be raised. For example:</source>
          <target state="translated">는 IF &lt;code&gt;INSTANT&lt;/code&gt; 알고리즘이 지정 될 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 절 또는 함께 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#alter_algorithm&quot;&gt;alter_algorithm&lt;/a&gt;&lt;/code&gt; 의 시스템 변수와 경우 &lt;code&gt;&lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt;&lt;/code&gt; 작업이 지원하지 않는 &lt;code&gt;INSTANT&lt;/code&gt; 알고리즘을, 다음 오류가 발생합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="eade57a011ff9acb4d6e4f7085a4984b5b69f828" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;LOAD DATA LOCAL INFILE&lt;/code&gt; statement is disabled by either the server or the client and if the user attempts to execute it, then the server will cause the statement to fail with the following error message:</source>
          <target state="translated">경우 &lt;code&gt;LOAD DATA LOCAL INFILE&lt;/code&gt; 의 문이 서버 또는 클라이언트 중 하나에 의해 사용자의 시도를 실행하는 경우 비활성화되어, 서버는 다음과 같은 오류 메시지와 함께 실패 할 문을 발생합니다 :</target>
        </trans-unit>
        <trans-unit id="60496e2eeb3901b234d43a2d25c5c6e1e6f8c91b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;LOCK&lt;/code&gt; clause is not explicitly set, then the operation uses &lt;code&gt;LOCK=DEFAULT&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;LOCK&lt;/code&gt; 의 절을 명시 적으로 설정되어 있지 않은 경우, 동작 용도는 &lt;code&gt;LOCK=DEFAULT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f4438a2a4bfc84ab171af7e4d845dd7a341e4ac" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;NOCOPY&lt;/code&gt; algorithm is specified with the &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; clause or with the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#alter_algorithm&quot;&gt;alter_algorithm&lt;/a&gt;&lt;/code&gt; system variable and if the &lt;code&gt;&lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt;&lt;/code&gt; operation does not support the &lt;code&gt;NOCOPY&lt;/code&gt; algorithm, then an error will be raised. For example:</source>
          <target state="translated">경우 &lt;code&gt;NOCOPY&lt;/code&gt; 의 알고리즘이 지정 될 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 절 또는 함께 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#alter_algorithm&quot;&gt;alter_algorithm&lt;/a&gt;&lt;/code&gt; 의 시스템 변수와 경우 &lt;code&gt;&lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt;&lt;/code&gt; 작업은 지원하지 않습니다 &lt;code&gt;NOCOPY&lt;/code&gt; 의 알고리즘을, 다음 오류가 발생합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5588d90c9dd1029fb8ec07474f2015582a2f04c2" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;NO_AUTO_CREATE_USER&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;../sql-mode/index&quot;&gt;SQL_MODE&lt;/a&gt;&lt;/code&gt; is set, then accounts can only be created if authentication information is specified, or with a &lt;code&gt;&lt;a href=&quot;../create-user/index&quot;&gt;CREATE USER&lt;/a&gt;&lt;/code&gt; statement. If no authentication information is provided, &lt;code&gt;GRANT&lt;/code&gt; will produce an error when the specified account does not exist, for example:</source>
          <target state="translated">는 IF &lt;code&gt;NO_AUTO_CREATE_USER&lt;/code&gt; 의 &lt;code&gt;&lt;a href=&quot;../sql-mode/index&quot;&gt;SQL_MODE&lt;/a&gt;&lt;/code&gt; 가 설정 한 후 인증 정보가 지정된 경우에만 만들 수 있습니다 계정, 또는이와 &lt;code&gt;&lt;a href=&quot;../create-user/index&quot;&gt;CREATE USER&lt;/a&gt;&lt;/code&gt; 문을. 인증 정보가 제공 되지 않으면 지정된 계정이 존재하지 않을 때 &lt;code&gt;GRANT&lt;/code&gt; 가 오류를 생성합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="72a52c0db90c23131de9b9cb755a556f3ec3be3a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;OR REPLACE&lt;/code&gt; clause is used and if the index already exists, then instead of returning an error, the server will drop the existing index and replace it with the newly defined index.</source>
          <target state="translated">는 IF &lt;code&gt;OR REPLACE&lt;/code&gt; 절은 사용되는 인덱스가 이미 존재하는 경우, 다음 대신 오류를 반환하는 서버는 기존의 인덱스를 삭제하고 새로 정의 된 인덱스로 대체합니다.</target>
        </trans-unit>
        <trans-unit id="e17c3b30bdb3cb91a2e69d644741e2dadbec78bb" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;OR REPLACE&lt;/code&gt; clause is used and if the table already exists, then instead of returning an error, the server will drop the existing table and replace it with the newly defined table.</source>
          <target state="translated">는 IF &lt;code&gt;OR REPLACE&lt;/code&gt; 절은 사용하고 테이블이 이미 존재하는 경우, 다음 대신 오류를 반환하는 서버는 기존 테이블을 삭제하고 새로 정의 된 테이블로 교체하십시오.</target>
        </trans-unit>
        <trans-unit id="4d6a39ef53da2f07b5926935ae96f899f24b9dfc" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;PARTITION BY&lt;/code&gt; clause is used, the table will be &lt;a href=&quot;../managing-mariadb-partitioning/index&quot;&gt;partitioned&lt;/a&gt;. A partition method must be explicitly indicated for partitions and subpartitions. Partition methods are:</source>
          <target state="translated">는 IF &lt;code&gt;PARTITION BY&lt;/code&gt; 절을 사용, 테이블이됩니다 &lt;a href=&quot;../managing-mariadb-partitioning/index&quot;&gt;분할&lt;/a&gt; . 파티션 및 하위 파티션에 대해 파티션 방법을 명시 적으로 표시해야합니다. 파티션 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4b3f11c596c8790aabb94728b6419c6503d31670" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ROW_FORMAT&lt;/code&gt; table option is set to &lt;code&gt;FIXED&lt;/code&gt; for an InnoDB table, then the server will either return an error or a warning depending on the value of the &lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_strict_mode&quot;&gt;innodb_strict_mode&lt;/a&gt;&lt;/code&gt; system variable. If the &lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_strict_mode&quot;&gt;innodb_strict_mode&lt;/a&gt;&lt;/code&gt; system variable is set to &lt;code&gt;OFF&lt;/code&gt;, then a warning is issued, and MariaDB will create the table using the default row format for the specific MariaDB server version. If the &lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_strict_mode&quot;&gt;innodb_strict_mode&lt;/a&gt;&lt;/code&gt; system variable is set to &lt;code&gt;ON&lt;/code&gt;, then an error will be raised.</source>
          <target state="translated">는 IF &lt;code&gt;ROW_FORMAT&lt;/code&gt; 의 테이블 옵션이 설정되어 &lt;code&gt;FIXED&lt;/code&gt; InnoDB의 테이블에 대해, 서버는 중 오류 또는의 값에 따라 경고를 반환합니다 &lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_strict_mode&quot;&gt;innodb_strict_mode&lt;/a&gt;&lt;/code&gt; 의 시스템 변수를. 는 IF &lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_strict_mode&quot;&gt;innodb_strict_mode&lt;/a&gt;&lt;/code&gt; 의 시스템 변수로 설정되어 &lt;code&gt;OFF&lt;/code&gt; , 다음 경고가 발생하고, MariaDB는 특정 MariaDB 서버 버전의 기본 행 형식을 사용하여 테이블을 생성합니다. 는 IF &lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_strict_mode&quot;&gt;innodb_strict_mode&lt;/a&gt;&lt;/code&gt; 의 시스템 변수로 설정되어 &lt;code&gt;ON&lt;/code&gt; , 다음 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d805a49244c7e0be4d15f13710613e9887bffaa8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;SECURITY_TYPE&lt;/code&gt; is &lt;code&gt;DEFINER&lt;/code&gt;, this value indicates which user defined this routine.</source>
          <target state="translated">경우 &lt;code&gt;SECURITY_TYPE&lt;/code&gt; 가 있다 &lt;code&gt;DEFINER&lt;/code&gt; ,이 값은이 루틴을 정의하는 사용자를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="844008b922c3839c6cdb48b94a267e41a8d8e64d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ZEROFILL&lt;/code&gt; clause is specified, it should be placed directly after the type definition, before the &lt;code&gt;AS (&amp;lt;expression&amp;gt;)&lt;/code&gt;:</source>
          <target state="translated">경우] &lt;code&gt;ZEROFILL&lt;/code&gt; 의 절을 지정하고, 그것은 이전 타입 정의 직후에 배치되어야 &lt;code&gt;AS (&amp;lt;expression&amp;gt;)&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="724ffd5c9f6f6dc07250637cba0122a7ddc304ef" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ZEROFILL&lt;/code&gt; column option is specified for a column using a &lt;a href=&quot;../numeric-data-type-overview/index&quot;&gt;numeric&lt;/a&gt; data type, then the column will be set to &lt;code&gt;UNSIGNED&lt;/code&gt; and the spaces used by default to pad the field are replaced with zeros. &lt;code&gt;ZEROFILL&lt;/code&gt; is ignored in expressions or as part of a &lt;a href=&quot;../union/index&quot;&gt;UNION&lt;/a&gt;. &lt;code&gt;ZEROFILL&lt;/code&gt; is a non-standard MySQL and MariaDB enhancement.</source>
          <target state="translated">경우] &lt;code&gt;ZEROFILL&lt;/code&gt; 의 열 옵션이 사용 열에 대해 지정된 &lt;a href=&quot;../numeric-data-type-overview/index&quot;&gt;숫자&lt;/a&gt; 데이터 형식을, 그 칼럼이 설정 될 것이다 &lt;code&gt;UNSIGNED&lt;/code&gt; 패드 기본적 필드에서 사용하는 공간은 제로로 대체된다. &lt;code&gt;ZEROFILL&lt;/code&gt; 은 표현식에서 또는 &lt;a href=&quot;../union/index&quot;&gt;UNION의&lt;/a&gt; 일부로 무시됩니다 . &lt;code&gt;ZEROFILL&lt;/code&gt; 은 비표준 MySQL 및 MariaDB 향상입니다.</target>
        </trans-unit>
        <trans-unit id="62373b11a1f01b1935e8443e23a5259385907821" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;crypt_str&lt;/code&gt; argument does not appear to be an encrypted string, MariaDB returns the given crypt_str.</source>
          <target state="translated">&lt;code&gt;crypt_str&lt;/code&gt; 인수가 암호화 된 문자열이 아닌 경우 MariaDB는 주어진 crypt_str을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2d5f4f6d8d29ecb903dcd00b5ee4adc272f9f96d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;is_used&lt;/code&gt; argument is not given or is &lt;code&gt;1&lt;/code&gt; or &lt;code&gt;true&lt;/code&gt;, then the next used value will one after the given value. If &lt;code&gt;is_used&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; then the next generated value will be the given value.</source>
          <target state="translated">경우 &lt;code&gt;is_used&lt;/code&gt; 인수가 지정되지 않았거나 &lt;code&gt;1&lt;/code&gt; 또는 &lt;code&gt;true&lt;/code&gt; , 그 다음 사용되는 값이 주어진 값 하나씩을 것이다. 경우 &lt;code&gt;is_used&lt;/code&gt; 하는 것이다 &lt;code&gt;0&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 그 다음 생성 된 값이 소정 값이 될 것이다.</target>
        </trans-unit>
        <trans-unit id="e90fe4bef7a5fb58b96bb5adeb9e652b70fa90c5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;json_doc&lt;/code&gt; is not a valid JSON document, or if any of the paths are not valid, or contain a &lt;code&gt;*&lt;/code&gt; or &lt;code&gt;**&lt;/code&gt; wildcard, an error is returned.</source>
          <target state="translated">는 IF &lt;code&gt;json_doc&lt;/code&gt; 가 유효한 JSON 문서하지 않은 경로 중 하나가 유효하지 않은, 또는 포함 된 경우, 또는 &lt;code&gt;*&lt;/code&gt; 또는 &lt;code&gt;**&lt;/code&gt; 와일드 카드를, 오류가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="24b2af04c5c07912a9f50856633232f62c177a83" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;mysql&lt;/code&gt; database is edited indirectly, statement logging is used regardless of &lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#binlog_format&quot;&gt;binlog_format&lt;/a&gt; setting. Statements editing the &lt;code&gt;mysql&lt;/code&gt; database indirectly include &lt;a href=&quot;../grant/index&quot;&gt;GRANT&lt;/a&gt;, &lt;a href=&quot;../revoke/index&quot;&gt;REVOKE&lt;/a&gt;, &lt;a href=&quot;../set-password/index&quot;&gt;SET PASSWORD&lt;/a&gt;, &lt;a href=&quot;../rename-user/index&quot;&gt;RENAME USER&lt;/a&gt;, &lt;a href=&quot;../alter/index&quot;&gt;ALTER&lt;/a&gt;, &lt;a href=&quot;../drop/index&quot;&gt;DROP&lt;/a&gt; and &lt;a href=&quot;../create/index&quot;&gt;CREATE&lt;/a&gt; (except for the situation described below).</source>
          <target state="translated">는 IF &lt;code&gt;mysql&lt;/code&gt; 데이터베이스를 간접적으로 편집, 문 로깅에 관계없이 사용 &lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#binlog_format&quot;&gt;binlog_format의&lt;/a&gt; 설정. &lt;code&gt;mysql&lt;/code&gt; 데이터베이스를 편집하는 명령문 에는 &lt;a href=&quot;../grant/index&quot;&gt;GRANT&lt;/a&gt; , &lt;a href=&quot;../revoke/index&quot;&gt;REVOKE&lt;/a&gt; , &lt;a href=&quot;../set-password/index&quot;&gt;SET PASSWORD&lt;/a&gt; , &lt;a href=&quot;../rename-user/index&quot;&gt;RENAME USER&lt;/a&gt; , &lt;a href=&quot;../alter/index&quot;&gt;ALTER&lt;/a&gt; , &lt;a href=&quot;../drop/index&quot;&gt;DROP&lt;/a&gt; 및 &lt;a href=&quot;../create/index&quot;&gt;CREATE가&lt;/a&gt; 간접적으로 포함됩니다 (아래 설명 된 상황 제외).</target>
        </trans-unit>
        <trans-unit id="502c553d22a6e0a121b89d6680db28e08ed36f8c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;mysql&lt;/code&gt; user is running &lt;code&gt;mysqld&lt;/code&gt;, then we can do that by executing the following:</source>
          <target state="translated">는 IF &lt;code&gt;mysql&lt;/code&gt; 사용자가 실행중인 &lt;code&gt;mysqld&lt;/code&gt; 를을 , 우리는 다음을 실행하여 해당 작업을 수행 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="d7b4eb0d2f72c9ea6eda8cc74bf4e0d6020c5585" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;security_type&lt;/code&gt; is &lt;code&gt;DEFINER&lt;/code&gt;, this value indicates which user defined this routine.</source>
          <target state="translated">경우 &lt;code&gt;security_type&lt;/code&gt; 있다 &lt;code&gt;DEFINER&lt;/code&gt; ,이 값은이 루틴을 정의하는 사용자를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="800b446234b44692d026156beb13d2ba329f3d5c" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;-signal&lt;/em&gt; option is given, it specifies the name or number of the signal to send to each process. Otherwise, mysql_zap tries first with TERM (signal 15) and then with KILL (signal 9).</source>
          <target state="translated">경우 &lt;em&gt;- 신호&lt;/em&gt; 옵션이 주어, 각 프로세스에 보낼 이름이나 신호의 수를 지정합니다. 그렇지 않으면, mysql_zap는 먼저 TERM (신호 15)으로 시도한 다음 KILL (신호 9)로 시도합니다.</target>
        </trans-unit>
        <trans-unit id="6a8d5f72483c2a46b7d4bd0e42780d4838206956" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;id&lt;/em&gt; column of the remote table addressed by the &lt;em&gt;cnc_tab&lt;/em&gt; MYSQL table is indexed (which is likely if it is a key) you should also index the &lt;em&gt;id&lt;/em&gt; column of the MYSQL &lt;em&gt;cnc_tab&lt;/em&gt; table. If so, using &amp;ldquo;remote&amp;rdquo; indexing as does FEDERATED, only the useful rows of the remote table will be retrieved during the join process. However, because these rows are retrieved by separate &lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt; statements, this will be useful only when retrieving a few rows of a big table.</source>
          <target state="translated">&lt;em&gt;cnc_tab&lt;/em&gt; MYSQL 테이블로 주소가 지정된 원격 테이블 의 &lt;em&gt;id&lt;/em&gt; 열 이 색인화되는 경우 ( &lt;em&gt;키일&lt;/em&gt; 경우) MYSQL &lt;em&gt;cnc_tab&lt;/em&gt; 테이블 의 &lt;em&gt;id&lt;/em&gt; 열도 색인화해야 합니다. 그렇다면 FEDERATED와 같이 &quot;원격&quot;인덱싱을 사용하면 조인 프로세스 중에 원격 테이블의 유용한 행만 검색됩니다. 그러나 이러한 행은 별도의 &lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt; 문으로 검색되므로 큰 테이블의 몇 행을 검색 할 때만 유용합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="153731d172a41fc013f811fd394dc6dfa923d3d2" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;people&lt;/em&gt; table is indexed on &lt;em&gt;num&lt;/em&gt;, indexing will be used on the remote server. This, in all cases, will limit the amount of data to retrieve on the network.</source>
          <target state="translated">는 IF &lt;em&gt;사람들의&lt;/em&gt; 테이블에 색인 &lt;em&gt;NUM&lt;/em&gt; , 색인은 원격 서버에 사용됩니다. 모든 경우에 네트워크에서 검색 할 데이터의 양이 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="34e5d8a87dfb7569409365c22509644cdc11ea84" translate="yes" xml:space="preserve">
          <source>If the &lt;strong&gt;timer thread&lt;/strong&gt; were to detect a stall in a thread group, then it would either wake up a sleeping &lt;strong&gt;worker thread&lt;/strong&gt; or create a new &lt;strong&gt;worker thread&lt;/strong&gt; in that thread group. At that point, the thread group would have multiple active &lt;strong&gt;worker threads&lt;/strong&gt;. In other words, the thread group would be &lt;em&gt;oversubscribed&lt;/em&gt;.</source>
          <target state="translated">경우 &lt;strong&gt;타이머 스레드가&lt;/strong&gt; 스레드 그룹에서 마구간을 발견했다, 그것은 중 하나 자고 일어나 것입니다 &lt;strong&gt;작업자 스레드를&lt;/strong&gt; 하거나 새로 만들 &lt;strong&gt;작업자 스레드&lt;/strong&gt; 스레드 그룹을. 이때 스레드 그룹에는 여러 개의 활성 &lt;strong&gt;작업자 스레드가&lt;/strong&gt; 있습니다. 즉, 스레드 그룹이 &lt;em&gt;과다 구독&lt;/em&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="25ad31f9717ad3b6f3dea26cd4a04468ae2f8880" translate="yes" xml:space="preserve">
          <source>If the Audit Plugin has been configured to log connect events, it will log connects, disconnects, and failed connects. For a failed connection, the log includes the error code.</source>
          <target state="translated">감사 플러그인이 연결 이벤트를 기록하도록 구성된 경우 연결, 연결 끊기 및 연결 실패를 기록합니다. 연결이 실패하면 로그에 오류 코드가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="ba582813c318180e3a13e22b438f60ab63ca6368" translate="yes" xml:space="preserve">
          <source>If the CHARACTER SET binary attribute is specified, the column is created as the matching binary data type. A TEXT becomes a BLOB, CHAR a BINARY and VARCHAR a VARBINARY. ENUMs and SETs are created as defined.</source>
          <target state="translated">CHARACTER SET 이진 속성이 지정되면 열이 일치하는 이진 데이터 형식으로 만들어집니다. TEXT는 BLOB, CHAR a BINARY 및 VARCHAR는 VARBINARY가됩니다. ENUM 및 SET은 정의 된대로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="5f3519afc9c408ae593ba99e0ea2b1d725917350" translate="yes" xml:space="preserve">
          <source>If the CLASSPATH variable actually exists and if it is available inside MariaDB, so far so good. You can check this using an UDF function provided by CONNECT that returns environment variable values:</source>
          <target state="translated">CLASSPATH 변수가 실제로 존재하고 MariaDB 내부에서 사용 가능한 경우 지금까지는 좋습니다. 환경 변수 값을 리턴하는 CONNECT에서 제공하는 UDF 함수를 사용하여이를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30116455dd32886f8f42e97521d6edea990e6651" translate="yes" xml:space="preserve">
          <source>If the CSV file first record is the list of column names, specifying the &lt;code&gt;HEADER=1&lt;/code&gt; option will skip the first record on reading. On writing, if the file is empty, the column names record is automatically written.</source>
          <target state="translated">CSV 파일의 첫 번째 레코드가 열 이름 목록 인 경우 &lt;code&gt;HEADER=1&lt;/code&gt; 옵션을 지정하면 읽기시 첫 번째 레코드가 생략됩니다. 기록 할 때 파일이 비어 있으면 열 이름 레코드가 자동으로 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="c14dd5b3a5beaca9b504fca824ec7a679ba04340" translate="yes" xml:space="preserve">
          <source>If the CSV file is included in a ZIP file, the CREATE TABLE becomes:</source>
          <target state="translated">CSV 파일이 ZIP 파일에 포함 된 경우 CREATE TABLE은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1b9848a91f1656e63fcd45125e8d49c8892e7912" translate="yes" xml:space="preserve">
          <source>If the ColumnStore server was configured as a single server deployment, then the Columnstore.xml file will need the IP addresses updated from 127.0.0.1 to the actual ip / hostname of the ColumnStore server in order to be used on a remote SDK server. A simple sed statement should suffice for updating:</source>
          <target state="translated">ColumnStore 서버가 단일 서버 배치로 구성된 경우 Columnstore.xml 파일은 원격 SDK 서버에서 사용하려면 IP 주소가 127.0.0.1에서 ColumnStore 서버의 실제 ip / 호스트 이름으로 업데이트되어야합니다. 간단한 sed 문으로 업데이트하면 충분합니다.</target>
        </trans-unit>
        <trans-unit id="70c2890aed89ad9a9af6f9a7fcd08a7302e6b04e" translate="yes" xml:space="preserve">
          <source>If the IF EXISTS clause is used, MariaDB will not return an error if the server does not exist. Unlike all other statements, DROP SERVER IF EXISTS does not issue a note if the server does not exist. See &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-9400&quot;&gt;MDEV-9400&lt;/a&gt;.</source>
          <target state="translated">IF EXISTS 절을 사용하면 서버가 존재하지 않으면 MariaDB가 오류를 반환하지 않습니다. 다른 모든 명령문과 달리 DROP SERVER IF EXISTS는 서버가 존재하지 않으면 메모를 발행하지 않습니다. &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-9400&quot;&gt;MDEV-9400을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="398b9c438f88c23195f7f9ab170467f54f7dc07d" translate="yes" xml:space="preserve">
          <source>If the IF NOT EXISTS clause is used, MariaDB will return a warning instead of an error if the function already exists. Cannot be used together with OR REPLACE.</source>
          <target state="translated">IF NOT EXISTS 절을 사용하면 함수가 이미 존재하는 경우 MariaDB는 오류 대신 경고를 반환합니다. OR REPLACE와 함께 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c6ca60649cecc63d3a3258873bed13b99c39d4cb" translate="yes" xml:space="preserve">
          <source>If the IF NOT EXISTS clause is used, MariaDB will return a warning instead of an error if the server already exists. Cannot be used together with OR REPLACE.</source>
          <target state="translated">IF NOT EXISTS 절을 사용하면 서버가 이미 존재하는 경우 MariaDB는 오류 대신 경고를 반환합니다. OR REPLACE와 함께 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="aa2c4d85eb5475ac7cb09ffb2b5c2e4740478ac4" translate="yes" xml:space="preserve">
          <source>If the JAVA_HOME variable was exported as explained above, CONNECT can sometimes find it using this information. Otherwise, its search path can be added to the LD_LIBRARY_PATH environment variable. But all this is complicated because making environment variables permanent on Linux is painful (many different methods must be used depending on the Linux version and the used shell).</source>
          <target state="translated">위에서 설명한대로 JAVA_HOME 변수를 내 보낸 경우 CONNECT는 때때로이 정보를 사용하여 찾을 수 있습니다. 그렇지 않으면 검색 경로를 LD_LIBRARY_PATH 환경 변수에 추가 할 수 있습니다. 그러나 Linux에서 환경 변수를 영구적으로 만드는 것은 고통스럽기 때문에이 모든 것이 복잡합니다 (Linux 버전 및 사용 된 셸에 따라 다양한 방법을 사용해야 함).</target>
        </trans-unit>
        <trans-unit id="cdac2d7a2fac99d61f3d99401d4f150ded387ec4" translate="yes" xml:space="preserve">
          <source>If the JVM library (jvm.dll on Windows, libjvm.so on Linux) was not placed in the standard library load path, CONNECT cannot find it and must be told where to search for it. This happens in particular on Linux when the Oracle Javapackage was installed in a private location.</source>
          <target state="translated">JVM 라이브러리 (Windows의 경우 jvm.dll, Linux의 경우 libjvm.so)가 표준 라이브러리로드 경로에 없으면 CONNECT가이를 찾을 수 없으므로 검색 위치를 알려야합니다. 이것은 특히 Oracle Javapackage가 개인 위치에 설치된 Linux에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d0bee391312a2de7767654fb78b6399dedab0170" translate="yes" xml:space="preserve">
          <source>If the LEVEL clause is no provided, a default of 1 to the maximum for the collation is assumed.</source>
          <target state="translated">LEVEL 절이 제공되지 않으면 데이터 정렬의 기본값은 1에서 최대 값으로 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="459e4c0daebfa6318075b99bca9f96e5d5479744" translate="yes" xml:space="preserve">
          <source>If the LEVEL is specified without using a range, an optional modifier is permitted.</source>
          <target state="translated">범위를 사용하지 않고 LEVEL을 지정하면 선택적 수정자가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="4a9c72f5264185d052d08a664cc784806eaf85f8" translate="yes" xml:space="preserve">
          <source>If the MariaDB Client is is running on an external Server, then it would be the IP Address of that server.</source>
          <target state="translated">MariaDB 클라이언트가 외부 서버에서 실행중인 경우 해당 서버의 IP 주소가됩니다.</target>
        </trans-unit>
        <trans-unit id="5fbf5d80fb378f304c130041bdcb46004a215dbc" translate="yes" xml:space="preserve">
          <source>If the MariaDB server is running on Unix, then some additional configuration steps will need to be implemented in order to use the plugin.</source>
          <target state="translated">MariaDB 서버가 Unix에서 실행중인 경우 플러그인을 사용하려면 몇 가지 추가 구성 단계를 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="e4db1b993614144fd28a58dd0171ad2b83391f64" translate="yes" xml:space="preserve">
          <source>If the MariaDB server is running on Unix, then the KDC server will need to create a keytab file for the MariaDB server. The keytab file contains the service principal name, which is the identity that the MariaDB server will use to communicate with the KDC server. The keytab will need to be transferred to the MariaDB server, and the &lt;code&gt;mysqld&lt;/code&gt; server process will need read access to this keytab file.</source>
          <target state="translated">MariaDB 서버가 Unix에서 실행중인 경우 KDC 서버는 MariaDB 서버에 대한 키탭 파일을 작성해야합니다. 키탭 파일에는 서비스 주체 이름이 포함되어 있는데 이는 MariaDB 서버가 KDC 서버와 통신하는 데 사용할 ID입니다. 키탭을 MariaDB 서버로 전송해야하며 &lt;code&gt;mysqld&lt;/code&gt; 서버 프로세스는이 키탭 파일에 대한 읽기 액세스 권한이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="456aa71fca99ad137d28ad1e6ea6a066799e1937" translate="yes" xml:space="preserve">
          <source>If the MariaDB server is running on Unix, then the path to the keytab file that was previously created can be set by configuring the &lt;code&gt;&lt;a href=&quot;#gssapi_keytab_path&quot;&gt;gssapi_keytab_path&lt;/a&gt;&lt;/code&gt; system variable. This can be specified as a command-line argument to &lt;code&gt;&lt;a href=&quot;../mysqld-options/index&quot;&gt;mysqld&lt;/a&gt;&lt;/code&gt; or it can be specified in a relevant server &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;option group&lt;/a&gt; in an &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;option file&lt;/a&gt;. For example:</source>
          <target state="translated">MariaDB 서버가 Unix에서 실행중인 경우 &lt;code&gt;&lt;a href=&quot;#gssapi_keytab_path&quot;&gt;gssapi_keytab_path&lt;/a&gt;&lt;/code&gt; 시스템 변수를 구성하여 이전에 작성된 키탭 파일의 경로를 설정할 수 있습니다 . 이것은 &lt;code&gt;&lt;a href=&quot;../mysqld-options/index&quot;&gt;mysqld&lt;/a&gt;&lt;/code&gt; 에 대한 명령 행 인수로 지정되거나 &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;옵션 파일&lt;/a&gt; 의 관련 서버 &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;옵션 그룹&lt;/a&gt; 에서 지정 될 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ccfc401b902c384fa6ec0f3ca5b6e871f617d1ff" translate="yes" xml:space="preserve">
          <source>If the MariaDB server is running on Unix, then the plugin needs a service principal name in order to function.</source>
          <target state="translated">MariaDB 서버가 Unix에서 실행중인 경우, 플러그인이 작동하려면 서비스 프린시 펄 이름이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ffd63fff391e64864488616eb4edfa8817817466" translate="yes" xml:space="preserve">
          <source>If the MariaDB server is running on Windows, then no special configuration steps will need to be implemented in order to use the plugin, as long as the following is true:</source>
          <target state="translated">MariaDB 서버가 Windows에서 실행중인 경우 다음을 충족하는 한 플러그인을 사용하기 위해 특별한 구성 단계를 구현할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="1f7509bb0bb9b71bc35c212ea64913b917e1fc7a" translate="yes" xml:space="preserve">
          <source>If the MariaDB server is running on Windows, then the plugin does not usually need a service principal in order to function. However, if you want to use one anyway, then one can be created with the &lt;code&gt;&lt;a href=&quot;https://social.technet.microsoft.com/wiki/contents/articles/717.service-principal-names-spns-setspn-syntax-setspn-exe.aspx&quot;&gt;setspn&lt;/a&gt;&lt;/code&gt; utility.</source>
          <target state="translated">MariaDB 서버가 Windows에서 실행중인 경우, 플러그인이 작동하기 위해 일반적으로 서비스 주체가 필요하지 않습니다. 그러나 어쨌든 하나를 사용하려면 &lt;code&gt;&lt;a href=&quot;https://social.technet.microsoft.com/wiki/contents/articles/717.service-principal-names-spns-setspn-syntax-setspn-exe.aspx&quot;&gt;setspn&lt;/a&gt;&lt;/code&gt; 유틸리티 를 사용하여 하나를 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="93a5be4279cea04f185e76e9fdb4cadb2dcaad46" translate="yes" xml:space="preserve">
          <source>If the PAM service requires challenge-responses, multiple questions, or other similar complicated authentication schemes, then the PAM service is not compatible with &lt;code&gt;mysql_clear_password&lt;/code&gt; client authentication plugin. In that case, the &lt;code&gt;&lt;a href=&quot;#dialog&quot;&gt;dialog&lt;/a&gt;&lt;/code&gt; client authentication plugin will have to be used instead.</source>
          <target state="translated">PAM 서비스에 챌린지 응답, 여러 질문 또는 기타 유사한 복잡한 인증 체계가 필요한 경우 PAM 서비스는 &lt;code&gt;mysql_clear_password&lt;/code&gt; 클라이언트 인증 플러그인 과 호환되지 않습니다 . 이 경우 &lt;code&gt;&lt;a href=&quot;#dialog&quot;&gt;dialog&lt;/a&gt;&lt;/code&gt; 클라이언트 인증 플러그인을 대신 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="02d616fe719bbfe1ef80e23c5ba454ea78513a93" translate="yes" xml:space="preserve">
          <source>If the SDK is being installed to a server that is not part of a MariaDB ColumnStore server then it requires a local copy of the ColumnStore.xml file in order to determine how to connect to ColumnStore. The simplest approach is to copy this file from one of the ColumnStore servers to one of the following 2 locations on the SDK server ensuring read privileges for the OS user being used:</source>
          <target state="translated">SDK가 MariaDB ColumnStore 서버의 일부가 아닌 서버에 설치되는 경우 ColumnStore에 연결하는 방법을 결정하려면 ColumnStore.xml 파일의 로컬 사본이 필요합니다. 가장 간단한 방법은이 파일을 ColumnStore 서버 중 하나에서 SDK 서버의 다음 두 위치 중 하나로 복사하여 사용중인 OS 사용자에 대한 읽기 권한을 확보하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="08f10ee4c63fa45bb8e86283504d78bdaacd3b88" translate="yes" xml:space="preserve">
          <source>If the SEQUENCE storage engine is installed, it is not possible to create a table with a name which follows the SEQUENCE pattern:</source>
          <target state="translated">SEQUENCE 스토리지 엔진이 설치된 경우 SEQUENCE 패턴을 따르는 이름을 가진 테이블을 작성할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4198c498e582524e154672674ab44596089a7dd5" translate="yes" xml:space="preserve">
          <source>If the SQL SECURITY value is DEFINER but the definer account does not exist when the view is referenced, an error occurs.</source>
          <target state="translated">SQL SECURITY 값이 DEFINER이지만 뷰를 참조 할 때 정의 자 계정이 존재하지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="61a620b840bcb7ce7e0b0d9e073e8d9bf9b85ffe" translate="yes" xml:space="preserve">
          <source>If the SQLSTATE is not valid, the following error like this will be produced:</source>
          <target state="translated">SQLSTATE가 유효하지 않으면 다음과 같은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ef201dc1911f7dcd84447f62a846c31568a50cf8" translate="yes" xml:space="preserve">
          <source>If the SQL_MODE is strict (STRICT_ALL_TABLES or STRICT_TRANS_TABLES flags are specified), a 1366 error will be produced.</source>
          <target state="translated">SQL_MODE가 엄격한 경우 (STRICT_ALL_TABLES 또는 STRICT_TRANS_TABLES 플래그가 지정됨) 1366 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f4b0d898876deb488023abd71babbe2914ec1ad5" translate="yes" xml:space="preserve">
          <source>If the Spider table is partitioned, the name must be of the format &lt;code&gt;table_name#P#partition_name&lt;/code&gt;. The partition name can be viewed in the &lt;code&gt;mysql.spider_tables&lt;/code&gt; table, for example:</source>
          <target state="translated">Spider 테이블이 파티션 된 경우 이름은 &lt;code&gt;table_name#P#partition_name&lt;/code&gt; 형식이어야 합니다 . 파티션 이름은 다음과 같이 &lt;code&gt;mysql.spider_tables&lt;/code&gt; 테이블 에서 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="20d9657070bf6143795c800ef0bf347eec6c7343" translate="yes" xml:space="preserve">
          <source>If the Spider table is partitioned, you must set &quot;Spider table name&quot; with a part name such as &quot;table_name#P#part_name&quot;.</source>
          <target state="translated">Spider 테이블이 분할 된 경우 &quot;table_name # P # part_name&quot;과 같은 부품 이름으로 &quot;Spider table name&quot;을 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="b8fd6beaa4893a63765eecb6e25c7a5cac18a93f" translate="yes" xml:space="preserve">
          <source>If the WHERE does a lot of filtering, the ORDER BY is wasting a lot of time fetching rows only to filter them out. Using an INDEX matching the WHERE clause is better.</source>
          <target state="translated">WHERE가 많은 필터링을 수행하면 ORDER BY는 행을 필터링하기 위해 행을 가져 오는 데 많은 시간을 낭비하고 있습니다. WHERE 절과 일치하는 INDEX를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="95069b304bae29c3b19c10105010459738c34817" translate="yes" xml:space="preserve">
          <source>If the WHERE does very little filtering, fetching the rows in ORDER BY order avoids a sort and has little wasted effort (because of 'little filtering'). Using the INDEX matching the ORDER BY is better in this case.</source>
          <target state="translated">WHERE가 필터링을 거의 수행하지 않는 경우 ORDER BY 순서로 행을 가져 오면 정렬을 피하고 노력이 거의 필요하지 않습니다 ( '작은 필터링'으로 인해). 이 경우 ORDER BY와 일치하는 INDEX를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e38ce6a70c495b951ddbb095518d26657fbfe341" translate="yes" xml:space="preserve">
          <source>If the above test doesn't pass, check the logs in the &lt;code&gt;'var'&lt;/code&gt; directory. If there is a problem with the sphinx installation, the reason can probably be found in the log file at: &lt;code&gt;var/log/sphinx.sphinx/searchd/sphinx.log&lt;/code&gt;.</source>
          <target state="translated">위의 테스트를 통과하지 못하면 &lt;code&gt;'var'&lt;/code&gt; 디렉토리 의 로그를 확인하십시오 . 스핑크스 설치에 문제가있는 경우 로그 파일 &lt;code&gt;var/log/sphinx.sphinx/searchd/sphinx.log&lt;/code&gt; 에서 이유를 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="039b1a31438b605957a5a9cfab707586a40e9e3a" translate="yes" xml:space="preserve">
          <source>If the account does not yet exist, then &lt;code&gt;GRANT&lt;/code&gt; can implicitly create it. To implicitly create an account with &lt;code&gt;GRANT&lt;/code&gt;, a user is required to have the same privileges that would be required to explicitly create the account with the &lt;code&gt;CREATE USER&lt;/code&gt; statement.</source>
          <target state="translated">계정이 아직 없으면 &lt;code&gt;GRANT&lt;/code&gt; 는 암시 적으로 계정을 작성할 수 있습니다. &lt;code&gt;GRANT&lt;/code&gt; 로 계정을 내재적으로 작성하려면 &lt;code&gt;CREATE USER&lt;/code&gt; 문으로 계정을 명시 적으로 작성하는 데 필요한 권한과 동일한 권한이 사용자에게 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="ca5ebef3fb1c795765adc0226450f298ff4671e8" translate="yes" xml:space="preserve">
          <source>If the alias is prefixed by &amp;lsquo;json_&amp;rsquo; (to prevent escaping) the key name is stripped from that prefix.</source>
          <target state="translated">이스케이프를 방지하기 위해 별칭에 'json_'접두사가 붙으면 키 이름이 해당 접두사에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="74c368cd4f12d43f05b1d1702411583be7f66c62" translate="yes" xml:space="preserve">
          <source>If the answer that came back had been something other than a MariaDB package, then it is likely there would have been issues with running the MariaDB mysql client application.</source>
          <target state="translated">되돌아온 대답이 MariaDB 패키지 이외의 것이 었으면 MariaDB mysql 클라이언트 응용 프로그램을 실행하는 데 문제가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d17bd7982447dee538be8545bb536932e5810a96" translate="yes" xml:space="preserve">
          <source>If the argument is not a string value, it is converted into a string.</source>
          <target state="translated">인수가 문자열 값이 아닌 경우 문자열로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="542ad588a5c9153ad310e30f014a8d1a29344763" translate="yes" xml:space="preserve">
          <source>If the argument is used in the &lt;code&gt;WHERE&lt;/code&gt; clause, it can be be compared to a constant with &lt;code&gt;&amp;lt;&lt;/code&gt; or &lt;code&gt;&amp;lt;=&lt;/code&gt; in case of &lt;code&gt;MAX()&lt;/code&gt; and with &lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;gt;=&lt;/code&gt; in case of &lt;code&gt;MIN()&lt;/code&gt;.</source>
          <target state="translated">인수가 &lt;code&gt;WHERE&lt;/code&gt; 절 에서 사용되는 경우 &lt;code&gt;MAX()&lt;/code&gt; 경우 &lt;code&gt;&amp;lt;&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;=&lt;/code&gt; 및 &lt;code&gt;MIN()&lt;/code&gt; 경우 &lt;code&gt;&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;gt;=&lt;/code&gt; 인 상수와 비교 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bced761645d81d9edb2cdbc159468b11a900405a" translate="yes" xml:space="preserve">
          <source>If the backup has already been prepared, then &lt;code&gt;backup_type&lt;/code&gt; is set to &lt;code&gt;log-applied&lt;/code&gt;.</source>
          <target state="translated">백업이 이미 준비된 경우 &lt;code&gt;backup_type&lt;/code&gt; 은 &lt;code&gt;log-applied&lt;/code&gt; 로 설정 됩니다 .</target>
        </trans-unit>
        <trans-unit id="130d8aad6cbd4548cfb6bfc9c744396cb4334b60" translate="yes" xml:space="preserve">
          <source>If the backup is a &lt;a href=&quot;../full-backup-and-restore-with-mariabackup/index&quot;&gt;full backup&lt;/a&gt;, then &lt;code&gt;innodb_from_lsn&lt;/code&gt; has the value of &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">백업이 &lt;a href=&quot;../full-backup-and-restore-with-mariabackup/index&quot;&gt;전체 백업&lt;/a&gt; 인 경우 &lt;code&gt;innodb_from_lsn&lt;/code&gt; 의 값은 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1775f5f8a6799bad77afe13b5a69166d32a30dbb" translate="yes" xml:space="preserve">
          <source>If the backup is a &lt;a href=&quot;../partial-backup-and-restore-with-mariabackup/index&quot;&gt;partial backup&lt;/a&gt;, then this value will be &lt;code&gt;Y&lt;/code&gt;.</source>
          <target state="translated">백업이 &lt;a href=&quot;../partial-backup-and-restore-with-mariabackup/index&quot;&gt;부분 백업&lt;/a&gt; 인 경우이 값은 &lt;code&gt;Y&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fbe65690de64d3f103db74c84d27f9de305de37c" translate="yes" xml:space="preserve">
          <source>If the backup is a non-prepared &lt;a href=&quot;../full-backup-and-restore-with-mariabackup/index&quot;&gt;full backup&lt;/a&gt; or a non-prepared &lt;a href=&quot;../partial-backup-and-restore-with-mariabackup/index&quot;&gt;partial backup&lt;/a&gt;, then &lt;code&gt;backup_type&lt;/code&gt; is set to &lt;code&gt;full-backuped&lt;/code&gt;.</source>
          <target state="translated">백업이 준비되지 않은 &lt;a href=&quot;../full-backup-and-restore-with-mariabackup/index&quot;&gt;전체 백업&lt;/a&gt; 이거나 준비되지 않은 &lt;a href=&quot;../partial-backup-and-restore-with-mariabackup/index&quot;&gt;부분 백업&lt;/a&gt; 인 경우 &lt;code&gt;backup_type&lt;/code&gt; 은 &lt;code&gt;full-backuped&lt;/code&gt; 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="bdbe4ccbc8b9b74aba1f040ec23cc61f861be657" translate="yes" xml:space="preserve">
          <source>If the backup is a non-prepared &lt;a href=&quot;../incremental-backup-and-restore-with-mariabackup/index&quot;&gt;incremental backup&lt;/a&gt;, then &lt;code&gt;backup_type&lt;/code&gt; is set to &lt;code&gt;incremental&lt;/code&gt;.</source>
          <target state="translated">백업이 준비되지 않은 &lt;a href=&quot;../incremental-backup-and-restore-with-mariabackup/index&quot;&gt;증분 백업&lt;/a&gt; 인 경우 &lt;code&gt;backup_type&lt;/code&gt; 은 &lt;code&gt;incremental&lt;/code&gt; 으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="899ac4be82bd2abd4579eca07e500183201e5a41" translate="yes" xml:space="preserve">
          <source>If the backup is an &lt;a href=&quot;../incremental-backup-and-restore-with-mariabackup/index&quot;&gt;incremental backup&lt;/a&gt;, then &lt;code&gt;innodb_from_lsn&lt;/code&gt; has the value of the &lt;a href=&quot;../innodb-redo-log/index#log-sequence-number-lsn&quot;&gt;log sequence number (LSN)&lt;/a&gt; at which the backup started reading from the &lt;a href=&quot;../innodb-redo-log/index&quot;&gt;InnoDB redo log&lt;/a&gt;.</source>
          <target state="translated">백업이 &lt;a href=&quot;../incremental-backup-and-restore-with-mariabackup/index&quot;&gt;증분 백업&lt;/a&gt; 인 경우 &lt;code&gt;innodb_from_lsn&lt;/code&gt; 은 백업이 &lt;a href=&quot;../innodb-redo-log/index&quot;&gt;InnoDB 리두 로그&lt;/a&gt; 에서 읽기 시작한 &lt;a href=&quot;../innodb-redo-log/index#log-sequence-number-lsn&quot;&gt;LSN (로그 시퀀스 번호)&lt;/a&gt; 값을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="a0731ddbf7b31c6444b98622ade0453dfec979a2" translate="yes" xml:space="preserve">
          <source>If the backup is an &lt;a href=&quot;../incremental-backup-and-restore-with-mariabackup/index&quot;&gt;incremental backup&lt;/a&gt;, then this file contains changed pages for the table.</source>
          <target state="translated">백업이 &lt;a href=&quot;../incremental-backup-and-restore-with-mariabackup/index&quot;&gt;증분 백업&lt;/a&gt; 인 경우이 파일에는 변경된 테이블 페이지가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="befaabf5a4aa083158a5193aa20b724a3284d0c2" translate="yes" xml:space="preserve">
          <source>If the backup is an &lt;a href=&quot;../incremental-backup-and-restore-with-mariabackup/index&quot;&gt;incremental backup&lt;/a&gt;, then this file contains metadata about &lt;code&gt;&amp;lt;table&amp;gt;.delta&lt;/code&gt; files. The fields in this file are listed below.</source>
          <target state="translated">백업이 &lt;a href=&quot;../incremental-backup-and-restore-with-mariabackup/index&quot;&gt;증분 백업&lt;/a&gt; 인 경우이 파일에는 &lt;code&gt;&amp;lt;table&amp;gt;.delta&lt;/code&gt; 파일에 대한 메타 데이터가 포함 됩니다. 이 파일의 필드는 아래와 같습니다.</target>
        </trans-unit>
        <trans-unit id="7bc7e7c4888b8d1cb4bdad48f77b8e655477ebd1" translate="yes" xml:space="preserve">
          <source>If the backup is an &lt;a href=&quot;../incremental-backup-and-restore-with-mariabackup/index&quot;&gt;incremental backup&lt;/a&gt;, then this value will be &lt;code&gt;Y&lt;/code&gt;.</source>
          <target state="translated">백업이 &lt;a href=&quot;../incremental-backup-and-restore-with-mariabackup/index&quot;&gt;증분 백업&lt;/a&gt; 인 경우이 값은 &lt;code&gt;Y&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="560bc9fdc92b5c2ed10d2a14650e55cadd9bd9eb" translate="yes" xml:space="preserve">
          <source>If the backup noticed concurrent DDL, then it might fail with &quot;ALTER TABLE or OPTIMIZE TABLE was executed during backup&quot;.</source>
          <target state="translated">백업에서 동시 DDL을 발견 한 경우 &quot;백업 중 ALTER TABLE 또는 OPTIMIZE TABLE이 실행되었습니다&quot;와 함께 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eefb4f611dd81d9f45df3e60dca77434e5a33cf1" translate="yes" xml:space="preserve">
          <source>If the backup was taken of an existing slave server, then the new slave should already have the correct GTID position stored in the &lt;code&gt;&lt;a href=&quot;../mysqlgtid_slave_pos-table/index&quot;&gt;mysql.gtid_slave_pos&lt;/a&gt;&lt;/code&gt; table. This is assuming that this table was backed up and that it was backed up in a consistent manner with changes to other tables. In this case, there is no need to explicitly look up the GTID position on the old server and set it on the new slave - it will be already correctly loaded from the &lt;code&gt;&lt;a href=&quot;../mysqlgtid_slave_pos-table/index&quot;&gt;mysql.gtid_slave_pos&lt;/a&gt;&lt;/code&gt; table. This however does not work if the backup was taken from the master - because then the current GTID position is contained in the binary log, not in the &lt;code&gt;&lt;a href=&quot;../mysqlgtid_slave_pos-table/index&quot;&gt;mysql.gtid_slave_pos&lt;/a&gt;&lt;/code&gt; table or any other table.</source>
          <target state="translated">기존 슬레이브 서버에서 백업을 수행 한 경우 새 슬레이브에는 이미 &lt;code&gt;&lt;a href=&quot;../mysqlgtid_slave_pos-table/index&quot;&gt;mysql.gtid_slave_pos&lt;/a&gt;&lt;/code&gt; 테이블 에 올바른 GTID 위치가 저장되어 있어야 합니다. 이는이 테이블이 백업되었고 다른 테이블의 변경 사항과 일관된 방식으로 백업되었다고 가정합니다. 이 경우 이전 서버에서 GTID 위치를 명시 적으로 찾아서 새 슬레이브에 설정할 필요가 없습니다 . &lt;code&gt;&lt;a href=&quot;../mysqlgtid_slave_pos-table/index&quot;&gt;mysql.gtid_slave_pos&lt;/a&gt;&lt;/code&gt; 테이블 에서 이미 올바르게로드됩니다 . 다음 현재 GTID 위치가 바이너리 로그에 포함되어 있기 때문에,하지에 - 백업이 마스터에서 찍은 경우에 그러나 작동하지 않습니다 &lt;code&gt;&lt;a href=&quot;../mysqlgtid_slave_pos-table/index&quot;&gt;mysql.gtid_slave_pos&lt;/a&gt;&lt;/code&gt; 테이블 또는 다른 테이블이 입니다.</target>
        </trans-unit>
        <trans-unit id="a846d87f6f2d1e1feeaca76db5ec06a26db22909" translate="yes" xml:space="preserve">
          <source>If the binaries are already built, you can generate a binary tarball with</source>
          <target state="translated">바이너리가 이미 빌드 된 경우 다음을 사용하여 바이너리 tarball을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be61fe9fdf317bc1df18fe0583dade64b801e20d" translate="yes" xml:space="preserve">
          <source>If the binary log index file has been removed, or incorrectly manually edited, all of the above forms of purging log files will fail. The .index file is a plain text file, and can be manually recreated or edited so that it lists only the binary log files that are present, in numeric/age order.</source>
          <target state="translated">이진 로그 인덱스 파일이 제거되었거나 수동으로 잘못 편집 된 경우 위의 모든 형태의 제거 로그 파일이 실패합니다. .index 파일은 일반 텍스트 파일이며 존재하는 이진 로그 파일 만 숫자 / 나이 순서로 나열하도록 수동으로 다시 만들거나 편집 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31bee73dbc478569462fcaaeafc09e5774fcb4f6" translate="yes" xml:space="preserve">
          <source>If the binary log is enabled, all SQL statements will be logged as usual, and replicated to any slave servers. However, since rows are not stored, it is important to use statement-based rather than the row or mixed format, as &lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt; and &lt;a href=&quot;../delete/index&quot;&gt;DELETE&lt;/a&gt; statements are neither logged nor replicated. See &lt;a href=&quot;../binary-log-formats/index&quot;&gt;Binary Log Formats&lt;/a&gt;.</source>
          <target state="translated">이진 로그가 활성화되면 모든 SQL 문이 평소대로 기록되고 모든 슬레이브 서버에 복제됩니다. 그러나 행이 저장되지 않으므로 &lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt; 및 &lt;a href=&quot;../delete/index&quot;&gt;DELETE&lt;/a&gt; 문이 기록되거나 복제되지 않으므로 행 또는 혼합 형식 대신 문 기반을 사용해야 합니다. &lt;a href=&quot;../binary-log-formats/index&quot;&gt;이진 로그 형식&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="b72f8b9db92c0e43f1b6d3e6dcb0b8824206242d" translate="yes" xml:space="preserve">
          <source>If the binary logging format is &lt;a href=&quot;../binary-log-formats/index#mixed-logging&quot;&gt;mixed&lt;/a&gt; (the default from &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1024-release-notes/&quot;&gt;MariaDB 10.2.4&lt;/a&gt;), unsafe statements are logged using the row-based format, while safe statements use the statement-based format.</source>
          <target state="translated">이진 로깅 형식이 &lt;a href=&quot;../binary-log-formats/index#mixed-logging&quot;&gt;혼합 된 경우&lt;/a&gt; ( &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1024-release-notes/&quot;&gt;MariaDB 10.2.4&lt;/a&gt; 의 기본값) ) 안전하지 않은 명령문은 행 기반 형식을 사용하여 기록되지만 안전 명령문은 명령문 기반 형식을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="35e442578c104298c88e16b9d578799bc302cda7" translate="yes" xml:space="preserve">
          <source>If the binary logging format is &lt;a href=&quot;../binary-log-formats/index#row-based-logging&quot;&gt;row-based&lt;/a&gt;, all statements are logged normally, and the distinction between safe and unsafe is not made.</source>
          <target state="translated">이진 로깅 형식이 &lt;a href=&quot;../binary-log-formats/index#row-based-logging&quot;&gt;행 기반 인&lt;/a&gt; 경우 모든 명령문이 정상적으로 로깅되며 안전과 안전하지 않은 구분이 이루어지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="705c15e78d75a15f6b4b7597d6359bc70f51173f" translate="yes" xml:space="preserve">
          <source>If the binary logging format is &lt;a href=&quot;../binary-log-formats/index#statement-based-logging&quot;&gt;statement-based&lt;/a&gt; (the default until &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1023-release-notes/&quot;&gt;MariaDB 10.2.3&lt;/a&gt;), unsafe statements generate a warning and are logged normally.</source>
          <target state="translated">이진 로깅 형식이 &lt;a href=&quot;../binary-log-formats/index#statement-based-logging&quot;&gt;명령문 기반 인 경우&lt;/a&gt; ( &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1023-release-notes/&quot;&gt;MariaDB 10.2.3&lt;/a&gt; 까지의 기본값) ) 인 경우 안전하지 않은 명령문은 경고를 생성하고 정상적으로 로깅됩니다.</target>
        </trans-unit>
        <trans-unit id="7b43e170fa60f5f667816e089aece2ba5d7fbf4b" translate="yes" xml:space="preserve">
          <source>If the calculated value for redo log occupancy is too close to &lt;code&gt;1.0&lt;/code&gt;, then the InnoDB redo log capacity may be too small for the current workload.</source>
          <target state="translated">재실행 로그 점유에 대해 계산 된 값이 &lt;code&gt;1.0&lt;/code&gt; 에 너무 가까운 경우 경우 InnoDB 리두 로그 용량이 현재 워크로드에 비해 너무 작을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df281052cfc9a035fc21a38e60d264a7fa4083de" translate="yes" xml:space="preserve">
          <source>If the character set and collation are not specifically set in the statement, the database defaults at the time of creation will be used. If the database defaults change at a later stage, the stored function character set/collation will not be changed at the same time; the stored function needs to be dropped and recreated to ensure the same character set/collation as the database is used.</source>
          <target state="translated">명령문에서 문자 세트 및 데이터 정렬이 구체적으로 설정되지 않은 경우 작성시 데이터베이스 기본값이 사용됩니다. 데이터베이스 기본값이 나중 단계에서 변경되면 저장된 기능 문자 세트 / 콜 레이션이 동시에 변경되지 않습니다. 저장된 함수는 데이터베이스와 동일한 문자 세트 / 콜 레이션을 보장하기 위해 삭제하고 다시 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="7bb22023cd4e54e76fc790a73d877c15dc304198" translate="yes" xml:space="preserve">
          <source>If the client does &lt;strong&gt;not&lt;/strong&gt; use either the &lt;code&gt;libmysqlclient&lt;/code&gt; or &lt;a href=&quot;../mariadb-connector-c/index&quot;&gt;MariaDB Connector/C&lt;/a&gt; library, then you will have to determine which authentication plugins are supported by the specific client library used by the client.</source>
          <target state="translated">클라이언트가 &lt;code&gt;libmysqlclient&lt;/code&gt; 또는 &lt;a href=&quot;../mariadb-connector-c/index&quot;&gt;MariaDB Connector / C&lt;/a&gt; 라이브러리를 사용 하지 &lt;strong&gt;않는&lt;/strong&gt; 경우 클라이언트가 사용 하는 특정 클라이언트 라이브러리가 지원하는 인증 플러그인을 결정해야합니다.</target>
        </trans-unit>
        <trans-unit id="4650691424c09d777ba96ae0e7545c1ecb9bdcbc" translate="yes" xml:space="preserve">
          <source>If the client uses either the &lt;code&gt;libmysqlclient&lt;/code&gt; or &lt;a href=&quot;../mariadb-connector-c/index&quot;&gt;MariaDB Connector/C&lt;/a&gt; library, but the client is not bundled with either library's &lt;em&gt;optional&lt;/em&gt; client authentication plugins, then you can only use the conventional authentication plugins (like &lt;code&gt;&lt;a href=&quot;../authentication-plugin-mysql_native_password/index&quot;&gt;mysql_native_password&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../authentication-plugin-mysql_old_password/index&quot;&gt;mysql_old_password&lt;/a&gt;&lt;/code&gt;) and the non-conventional authentication plugins that don't require special client-side authentication plugins (like &lt;code&gt;&lt;a href=&quot;../authentication-plugin-unix-socket/index&quot;&gt;unix_socket&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../authentication-plugin-named-pipe/index&quot;&gt;named_pipe&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">클라이언트가 &lt;code&gt;libmysqlclient&lt;/code&gt; 또는 &lt;a href=&quot;../mariadb-connector-c/index&quot;&gt;MariaDB Connector / C&lt;/a&gt; 라이브러리를 사용하지만 클라이언트가 라이브러리의 &lt;em&gt;선택적&lt;/em&gt; 클라이언트 인증 플러그인 과 함께 번들로 제공되지 않은 경우, 기존 인증 플러그인 ( &lt;code&gt;&lt;a href=&quot;../authentication-plugin-mysql_native_password/index&quot;&gt;mysql_native_password&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../authentication-plugin-mysql_old_password/index&quot;&gt;mysql_old_password&lt;/a&gt;&lt;/code&gt; 와 같은 )과 비 전통적인 인증 플러그인 만 사용할 수 있습니다 &lt;code&gt;&lt;a href=&quot;../authentication-plugin-unix-socket/index&quot;&gt;unix_socket&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../authentication-plugin-named-pipe/index&quot;&gt;named_pipe&lt;/a&gt;&lt;/code&gt; 와 같은 특수한 클라이언트 측 인증 플러그인이 필요하지 않은 .</target>
        </trans-unit>
        <trans-unit id="f10e74401f2eeded5c8ca5cf9750a444ad0716df" translate="yes" xml:space="preserve">
          <source>If the cluster is not bootstrapped and &lt;code&gt;&lt;a href=&quot;../mysqld-options/index&quot;&gt;mysqld&lt;/a&gt;&lt;/code&gt; on the first node is just &lt;a href=&quot;../starting-and-stopping-mariadb-starting-and-stopping-mariadb/index&quot;&gt;started normally&lt;/a&gt;, then the node willl try to connect to at least one of the nodes listed in the &lt;code&gt;&lt;a href=&quot;../galera-cluster-system-variables/index#wsrep_cluster_address&quot;&gt;wsrep_cluster_address&lt;/a&gt;&lt;/code&gt; option. If no nodes are currently running, then this will fail. Bootstrapping the first node solves this problem.</source>
          <target state="translated">클러스터가 부트 스트랩되지 않고 첫 번째 노드의 &lt;code&gt;&lt;a href=&quot;../mysqld-options/index&quot;&gt;mysqld&lt;/a&gt;&lt;/code&gt; 가 &lt;a href=&quot;../starting-and-stopping-mariadb-starting-and-stopping-mariadb/index&quot;&gt;정상적으로 시작된&lt;/a&gt; 경우 노드는 &lt;code&gt;&lt;a href=&quot;../galera-cluster-system-variables/index#wsrep_cluster_address&quot;&gt;wsrep_cluster_address&lt;/a&gt;&lt;/code&gt; 에 나열된 노드 중 하나 이상에 연결을 시도합니다. 옵션에 . 현재 실행중인 노드가 없으면 실패합니다. 첫 번째 노드를 부트 스트랩하면이 문제가 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="a7b04993e7b983d675d27f9842c67763bb95c08c" translate="yes" xml:space="preserve">
          <source>If the column is not defined with &lt;code&gt;NOT NULL&lt;/code&gt;, &lt;code&gt;AUTO_INCREMENT&lt;/code&gt; or &lt;code&gt;TIMESTAMP&lt;/code&gt;, an explicit &lt;code&gt;DEFAULT NULL&lt;/code&gt; will be added. Note that in MySQL and in MariaDB before 10.1.6, you may get an explicit &lt;code&gt;DEFAULT&lt;/code&gt; for primary key parts, if not specified with NOT NULL.</source>
          <target state="translated">열이 &lt;code&gt;NOT NULL&lt;/code&gt; , &lt;code&gt;AUTO_INCREMENT&lt;/code&gt; 또는 &lt;code&gt;TIMESTAMP&lt;/code&gt; 로 정의 되지 않은 경우 명시 적 &lt;code&gt;DEFAULT NULL&lt;/code&gt; 이 추가됩니다. MySQL 및 10.1.6 이전의 MariaDB 에서는 NOT NULL로 지정되지 않은 경우 기본 키 부분에 대해 명시 적 &lt;code&gt;DEFAULT&lt;/code&gt; 를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ebf1f39df583b7c7756242a9e9b480e59800ffe5" translate="yes" xml:space="preserve">
          <source>If the column is not found NULL returned as a value of the column.</source>
          <target state="translated">열을 찾을 수 없으면 NULL을 열 값으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="301a59a187b1c9510e339cc5c81c57e23b4ccc70" translate="yes" xml:space="preserve">
          <source>If the column name starts with &lt;code&gt;rev:&lt;/code&gt;, the column family is reverse-ordered.</source>
          <target state="translated">열 이름이 &lt;code&gt;rev:&lt;/code&gt; 시작하는 경우 : 하면 열 패밀리가 역순입니다.</target>
        </trans-unit>
        <trans-unit id="935ae1692541e30a2cad7453bb6307e8e96bb858" translate="yes" xml:space="preserve">
          <source>If the columns in the new table are more than the rows returned by the query, the columns populated by the query will be placed after other columns. Note that if the strict &lt;code&gt;SQL_MODE&lt;/code&gt; is on, and the columns that are not names in the query do not have a &lt;code&gt;DEFAULT&lt;/code&gt; value, an error will raise and no rows will be copied.</source>
          <target state="translated">새 테이블의 열이 쿼리에서 반환 한 행보다 많은 경우 쿼리로 채워진 열은 다른 열 뒤에 배치됩니다. 엄격한 &lt;code&gt;SQL_MODE&lt;/code&gt; 가 켜져 있고 쿼리에서 이름이 아닌 열에 &lt;code&gt;DEFAULT&lt;/code&gt; 값 이 없으면 오류가 발생하고 행이 복사되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cee0a686d17146567e1559a50432e7f43a18bb45" translate="yes" xml:space="preserve">
          <source>If the command does not return any results, then either your &lt;code&gt;mysqld&lt;/code&gt; is statically linked to the TLS and cryptography library on your system or your &lt;code&gt;mysqld&lt;/code&gt; is not built with TLS and cryptography support at all.</source>
          <target state="translated">명령이 어떤 결과를 반환하지 않는 경우, 다음 중 당신의 &lt;code&gt;mysqld&lt;/code&gt; 를가 정적 시스템 또는에서 TLS 및 암호화 라이브러리에 연결되어 &lt;code&gt;mysqld&lt;/code&gt; 를 가 TLS 및 암호화 지원으로 전혀 구축되지 않은 것입니다.</target>
        </trans-unit>
        <trans-unit id="283285ab5ba0c0fdf3a12037a7a974c5046299dd" translate="yes" xml:space="preserve">
          <source>If the commands above fail, you can enable more compilation information by doing:</source>
          <target state="translated">위의 명령이 실패하면 다음을 수행하여 추가 컴파일 정보를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd0f37c80b4ed38133d3aec184c90f077fd3fb69" translate="yes" xml:space="preserve">
          <source>If the connection cannot be established, wait and retry instead of aborting.</source>
          <target state="translated">연결을 설정할 수 없으면 중단하지 말고 기다렸다가 다시 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="51055d541d7292e1f54c60b24a7244394f4acbd0" translate="yes" xml:space="preserve">
          <source>If the connection cannot be established, wait and retry instead of aborting. If a &lt;em&gt;count&lt;/em&gt; value is given, it indicates the number of times to retry. The default is one time.</source>
          <target state="translated">연결을 설정할 수 없으면 중단하지 말고 기다렸다가 다시 시도하십시오. 경우 &lt;em&gt;카운트&lt;/em&gt; 값이 주어진, 그것을 재 시도하는 횟수를 나타냅니다. 기본값은 한 번입니다.</target>
        </trans-unit>
        <trans-unit id="6c27a82cd3766f25ea4d17c7f527d8582a64e7a1" translate="yes" xml:space="preserve">
          <source>If the container doesn't start, or is not working properly, we can investigate with the following command:</source>
          <target state="translated">컨테이너가 시작되지 않거나 제대로 작동하지 않으면 다음 명령으로 조사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15d61e806f4ede2932b6832f70b5649181225b6a" translate="yes" xml:space="preserve">
          <source>If the data contains a time or (time correlated ascending value) column then significant performance gains will be achieved if the data is sorted by this field and also typically queried with a where clause on that column. This is because the system records a minimum and maximum value for each extent providing for a system maintained range partitioning scheme. This allows the system to completely eliminate scanning an extent map if the query includes a where clause for that field limiting the results to a subset of extent maps.</source>
          <target state="translated">데이터에 시간 또는 (시간 상관 오름차순) 열이 포함 된 경우,이 필드를 기준으로 데이터를 정렬하고 일반적으로 해당 열의 where 절을 사용하여 쿼리하면 상당한 성능 향상을 얻을 수 있습니다. 시스템이 시스템 유지 범위 ​​파티셔닝 체계를 제공하는 각 익스텐트의 최소값과 최대 값을 기록하기 때문입니다. 따라서 쿼리에 해당 필드에 대한 where 절이 포함되어 있으면 결과가 범위 맵의 하위 집합으로 제한되는 경우 범위 맵 스캔을 완전히 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e90c204ecf65cfa6cc5c538bdaea9ff007666414" translate="yes" xml:space="preserve">
          <source>If the data types differ from what you expect them to be based on a &lt;code&gt;CREATE TABLE&lt;/code&gt; statement, note that MariaDB sometimes changes data types when you create or alter a table. The conditions under which this occurs are described in the &lt;a href=&quot;../silent-column-changes/index&quot;&gt;Silent Column Changes&lt;/a&gt; article.</source>
          <target state="translated">데이터 유형이 &lt;code&gt;CREATE TABLE&lt;/code&gt; 문을 기반으로하는 데이터 유형과 다른 경우, 테이블을 작성하거나 변경할 때 MariaDB가 데이터 유형을 변경하는 경우가 있습니다. 이러한 상황은 &lt;a href=&quot;../silent-column-changes/index&quot;&gt;Silent Column Changes&lt;/a&gt; 기사에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c51cecd01f6a9e7fb5cdef87ab984c1851a0b46" translate="yes" xml:space="preserve">
          <source>If the default mode is set to use cpimport internally any output error files will be written to /usr/local/mariadb/columnstore/mysql/db directory (or equivalent directory for non root install). These can be consulted for troubleshooting any errors reported.</source>
          <target state="translated">기본 모드가 내부적으로 cpimport를 사용하도록 설정된 경우 모든 출력 오류 파일이 / usr / local / mariadb / columnstore / mysql / db 디렉토리 (또는 루트가 아닌 설치의 동등한 디렉토리)에 작성됩니다. 보고 된 오류 문제 해결에 대해서는 상담 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="370bddc219973b6a60b0d2b0ab1da9a264c2e1ad" translate="yes" xml:space="preserve">
          <source>If the dense_rank function is used the rank values would be 1,2,3,3,4 and for the row_number function the values would be 1,2,3,4,5.</source>
          <target state="translated">dense_rank 함수가 사용되면 순위 값은 1,2,3,3,4이고 row_number 함수의 경우 값은 1,2,3,4,5입니다.</target>
        </trans-unit>
        <trans-unit id="9417d27e35284576e10ed6d555286c3850380ab2" translate="yes" xml:space="preserve">
          <source>If the engine condition pushdown is OFF, it is necessary to set it ON with the &lt;a href=&quot;../server-system-variables/index#optimizer_switch&quot;&gt;optimizer_switch&lt;/a&gt; setting, for instance by:</source>
          <target state="translated">엔진 상태 푸시 다운이 OFF 인 경우, 다음과 같이 &lt;a href=&quot;../server-system-variables/index#optimizer_switch&quot;&gt;optimizer_switch&lt;/a&gt; 설정으로 ON으로 설정해야 합니다.</target>
        </trans-unit>
        <trans-unit id="0b1c7bae27bfb6916459eae760a5c00bc6bac691" translate="yes" xml:space="preserve">
          <source>If the engine is file-based, that is, it has non-empty list in the &lt;code&gt;tablefile_extensions&lt;/code&gt;, this method is optional. For any file-based engine that does not implement &lt;code&gt;discover_table_names()&lt;/code&gt;, MariaDB will automatically discover the list of all tables of this engine, by looking for files with the extension &lt;code&gt;tablefile_extensions[0]&lt;/code&gt;.</source>
          <target state="translated">엔진이 파일 기반 인 경우, 즉 &lt;code&gt;tablefile_extensions&lt;/code&gt; 에 비어 있지 않은 목록이있는 경우이 방법은 선택 사항입니다. &lt;code&gt;discover_table_names()&lt;/code&gt; 구현하지 않는 파일 기반 엔진의 경우 , MariaDB는 확장자가 &lt;code&gt;tablefile_extensions[0]&lt;/code&gt; 파일을 찾아이 엔진의 모든 테이블 목록을 자동으로 검색합니다 . .</target>
        </trans-unit>
        <trans-unit id="1d15e9eb23ec8a74a90f5c71ac1aee493fe8bd5e" translate="yes" xml:space="preserve">
          <source>If the event does not exist, the error &lt;code&gt;ERROR 1517 (HY000): Unknown event 'event_name'&lt;/code&gt; results. You can override this and cause the statement to generate a &lt;code&gt;NOTE&lt;/code&gt; for non-existent events instead by using &lt;code&gt;IF EXISTS&lt;/code&gt;. See &lt;code&gt;&lt;a href=&quot;../show-warnings/index&quot;&gt;SHOW WARNINGS&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이벤트가 존재하지 않으면 오류 &lt;code&gt;ERROR 1517 (HY000): Unknown event 'event_name'&lt;/code&gt; 발생합니다. 이를 무시하고 명령문이 &lt;code&gt;IF EXISTS&lt;/code&gt; 를 사용하여 존재하지 않는 이벤트에 대한 &lt;code&gt;NOTE&lt;/code&gt; 를 생성하도록 할 수 있습니다 . &lt;code&gt;&lt;a href=&quot;../show-warnings/index&quot;&gt;SHOW WARNINGS&lt;/a&gt;&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="233998e985fb777905b75cf223698c10974110ee" translate="yes" xml:space="preserve">
          <source>If the event scheduler is not running and &lt;code&gt;event_scheduler&lt;/code&gt; has been set to &lt;code&gt;OFF&lt;/code&gt;, use:</source>
          <target state="translated">이벤트 스케줄러가 실행 중이 아니며 &lt;code&gt;event_scheduler&lt;/code&gt; 가 &lt;code&gt;OFF&lt;/code&gt; 로 설정된 경우 경우 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7b8134d6212916d94a69b050a37e6ba837324ee5" translate="yes" xml:space="preserve">
          <source>If the expression is a valid IPv4 address, returns 1, otherwise returns 0.</source>
          <target state="translated">식이 유효한 IPv4 주소이면 1을 반환하고, 그렇지 않으면 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="eca33b4bde2ae660186b16973e6a00e4aa8302e7" translate="yes" xml:space="preserve">
          <source>If the facility is not compiled in, the system variable does not exist.</source>
          <target state="translated">기능이 컴파일되지 않은 경우 시스템 변수가 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="da23aa3c045e7d7f547241ea12a0f8abff4a6524" translate="yes" xml:space="preserve">
          <source>If the file does not exist or cannot be read because one of the preceding conditions is not satisfied, the function returns NULL.</source>
          <target state="translated">위의 조건 중 하나가 충족되지 않아 파일이 없거나 읽을 수없는 경우 함수는 NULL을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="15ec52423adfea61285d5dc0752dd32f209ce7d1" translate="yes" xml:space="preserve">
          <source>If the file system permissions for some MariaDB directory look fine, but the MariaDB &lt;a href=&quot;../error-log/index&quot;&gt;error log&lt;/a&gt; still has errors that look similar to the following:</source>
          <target state="translated">일부 MariaDB 디렉토리에 대한 파일 시스템 권한이 제대로 보이지만 MariaDB &lt;a href=&quot;../error-log/index&quot;&gt;오류 로그에&lt;/a&gt; 여전히 다음과 유사한 오류가있는 경우 :</target>
        </trans-unit>
        <trans-unit id="09c9c6eececb3626f8b509b2c8c1de447ee549bf" translate="yes" xml:space="preserve">
          <source>If the following error is received, most likely with a transaction LOAD DATA INFILE or INSERT INTO SELECT then it is recommended to break up the load into multiple smaller chunks, increase the VersionBufferFileSize setting, or consider a non transactional LOAD DATA INFILE or to use cpimport.</source>
          <target state="translated">트랜잭션 LOAD DATA INFILE 또는 INSERT INTO SELECT와 함께 다음과 같은 오류가 발생하면로드를 여러 개의 작은 청크로 나누고 VersionBufferFileSize 설정을 늘리거나 트랜잭션이 아닌 LOAD DATA INFILE을 고려하거나 cpimport를 사용하는 것이 좋습니다. .</target>
        </trans-unit>
        <trans-unit id="c14db1293e7c0fe439cc404ee6d8a9428c355832" translate="yes" xml:space="preserve">
          <source>If the format contains elements DDD or DDDD, the day of week name is skipped on input and ignored to calculate the internal date value. On output, the correct day of week name is generated and displayed.</source>
          <target state="translated">형식에 DDD 또는 DDDD 요소가 포함 된 경우 입력시 요일 이름을 건너 뛰고 내부 날짜 값을 계산하기 위해 무시합니다. 출력시 정확한 요일 이름이 생성되어 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="7e47e24bb6c5cd1286f7b4c37b25359cfecda906" translate="yes" xml:space="preserve">
          <source>If the given decimal position is &lt;code&gt;0&lt;/code&gt;, it rounds to return no decimal point or fractional part. You can optionally specify a &lt;a href=&quot;../server-locale/index&quot;&gt;locale&lt;/a&gt; value to format numbers to the pattern appropriate for the given region.</source>
          <target state="translated">주어진 소수점 위치가 &lt;code&gt;0&lt;/code&gt; 이면 소수점이나 소수 부분을 반환하지 않도록 반올림합니다. 선택적으로 &lt;a href=&quot;../server-locale/index&quot;&gt;로케일&lt;/a&gt; 값을 지정 하여 지정된 지역에 적합한 패턴으로 숫자를 형식화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d6ee7abf4ee80c76068b2f77344b8a1f3316fc89" translate="yes" xml:space="preserve">
          <source>If the given pattern occurs more than once, the &lt;code&gt;FIELD()&lt;/code&gt; function only returns the index of the first instance. If the given pattern is &lt;code&gt;NULL&lt;/code&gt;, the function returns &lt;code&gt;0&lt;/code&gt;, as a &lt;code&gt;NULL&lt;/code&gt; pattern always fails to match.</source>
          <target state="translated">주어진 패턴이 두 번 이상 발생하면 &lt;code&gt;FIELD()&lt;/code&gt; 함수는 첫 번째 인스턴스의 인덱스 만 반환합니다. 주어진 패턴이 &lt;code&gt;NULL&lt;/code&gt; 이면 함수는 &lt;code&gt;0&lt;/code&gt; 을 &lt;code&gt;NULL&lt;/code&gt; 로 반환 합니다 패턴이 항상 일치하는 데 실패합니다.</target>
        </trans-unit>
        <trans-unit id="9884e764912cbb224dc5c1c529a787bed0ee9fc5" translate="yes" xml:space="preserve">
          <source>If the host name is not provided, it is assumed to be &lt;code&gt;'%'&lt;/code&gt;.</source>
          <target state="translated">호스트 이름이 제공되지 않으면 &lt;code&gt;'%'&lt;/code&gt; 인 것으로 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="1a64ef2f65253128d00b43ae42586b0def0d926f" translate="yes" xml:space="preserve">
          <source>If the identical query is not found in the cache, the query will be processed normally and then stored, along with its result set, in the query cache. If the query is found in the cache, the results will be pulled from the cache, which is much quicker than processing it normally.</source>
          <target state="translated">캐시에서 동일한 쿼리를 찾지 못하면 쿼리는 정상적으로 처리 된 다음 결과 집합과 함께 쿼리 캐시에 저장됩니다. 캐시에서 쿼리가 발견되면 캐시에서 결과를 가져 오므로 일반적으로 처리하는 것보다 훨씬 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="da4280619b47b31985e6e3928b9caaede36043b1" translate="yes" xml:space="preserve">
          <source>If the index file should have a different name, for instance because several tables are created on the same data file with different indexes, specify the base index file name with the XFILE_NAME option.</source>
          <target state="translated">예를 들어 인덱스가 다른 동일한 데이터 파일에 여러 테이블이 작성되므로 인덱스 파일의 이름이 다른 경우 XFILE_NAME 옵션을 사용하여 기본 인덱스 파일 이름을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="ef4100dacaaf331b3b44f085e7d5962de458b038" translate="yes" xml:space="preserve">
          <source>If the integer part is zero, it can be omitted, but the literal must begin with a dot.</source>
          <target state="translated">정수 부분이 0이면 생략 할 수 있지만 리터럴은 점으로 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="55365ba7c39e8eee74a88811c5eaa6c07f7b2ad1" translate="yes" xml:space="preserve">
          <source>If the isolation level is set to &lt;a href=&quot;../set-transaction-isolation-level/index#serializable&quot;&gt;SERIALIZABLE&lt;/a&gt;, all plain &lt;code&gt;SELECT&lt;/code&gt; statements are converted to &lt;code&gt;SELECT ... LOCK IN SHARE MODE&lt;/code&gt;.</source>
          <target state="translated">분리 레벨이 &lt;a href=&quot;../set-transaction-isolation-level/index#serializable&quot;&gt;SERIALIZABLE&lt;/a&gt; 로 설정 되면 모든 일반 &lt;code&gt;SELECT&lt;/code&gt; 문이 &lt;code&gt;SELECT ... LOCK IN SHARE MODE&lt;/code&gt; 로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="2677c06319fd7cf71ae75b63cf5470609f63621e" translate="yes" xml:space="preserve">
          <source>If the json document is large, this can take up a large amount of time and storage space. It is all right when one simple json function is called &amp;ndash; it must be done anyway &amp;ndash; but is a waste of time and memory when json functions are used as parameters to other json functions.</source>
          <target state="translated">json 문서가 크면 시간과 저장 공간이 많이 걸릴 수 있습니다. 하나의 간단한 json 함수가 호출 될 때 괜찮습니다. 어쨌든 수행되어야합니다. 그러나 json 함수가 다른 json 함수의 매개 변수로 사용될 때 시간과 메모리가 낭비됩니다.</target>
        </trans-unit>
        <trans-unit id="06836e8a474301947a7f890ed076c67525570ae8" translate="yes" xml:space="preserve">
          <source>If the key file is encrypted, then the File Key Management plugin requires both the &lt;code&gt;&lt;a href=&quot;#file_key_management_filename&quot;&gt;file_key_management_filename&lt;/a&gt;&lt;/code&gt; and the &lt;code&gt;&lt;a href=&quot;#file_key_management_filekey&quot;&gt;file_key_management_filekey&lt;/a&gt;&lt;/code&gt; system variables to be configured.</source>
          <target state="translated">키 파일이 암호화 된 경우 File Key Management 플러그인은 &lt;code&gt;&lt;a href=&quot;#file_key_management_filename&quot;&gt;file_key_management_filename&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;#file_key_management_filekey&quot;&gt;file_key_management_filekey&lt;/a&gt;&lt;/code&gt; 시스템 변수를 모두 구성해야합니다.</target>
        </trans-unit>
        <trans-unit id="f01098e9f5f9fd9b29b2c26d82b4de761e2518ba" translate="yes" xml:space="preserve">
          <source>If the key file is unencrypted, then the File Key Management plugin only requires the &lt;code&gt;&lt;a href=&quot;#file_key_management_filename&quot;&gt;file_key_management_filename&lt;/a&gt;&lt;/code&gt; system variable to be configured.</source>
          <target state="translated">키 파일이 암호화되지 않은 경우 File Key Management 플러그인은 &lt;code&gt;&lt;a href=&quot;#file_key_management_filename&quot;&gt;file_key_management_filename&lt;/a&gt;&lt;/code&gt; 시스템 변수 만 구성하면됩니다.</target>
        </trans-unit>
        <trans-unit id="bdc1e1728d52c43c1c20201c4b06b32f8a754ca9" translate="yes" xml:space="preserve">
          <source>If the last argument contains a shell or SQL wildcard (*,?,% or _) then only what's matched by the wildcard is shown. If a database name contains any underscores, those should be escaped with a backslash (some Unix shells require two) to get a list of the proper tables or columns. &amp;ldquo;*&amp;rdquo; and &amp;ldquo;?&amp;rdquo; characters are converted into SQL &amp;ldquo;%&amp;rdquo; and &amp;ldquo;_&amp;rdquo; wildcard characters. This might cause some confusion when you try to display the columns for a table with a &amp;ldquo;_&amp;rdquo; in the name, because in this case, mysqlshow shows you only the table names that match the pattern. This is easily fixed by adding an extra &amp;ldquo;%&amp;rdquo; last on the command line as a separate argument.</source>
          <target state="translated">마지막 인수에 쉘 또는 SQL 와일드 카드 (*,?, % 또는 _)가 포함 된 경우 와일드 카드와 일치하는 항목 만 표시됩니다. 데이터베이스 이름에 밑줄이 포함 된 경우, 적절한 테이블 또는 열 목록을 가져 오려면 백 슬래시 (일부 Unix 쉘에 2 개 필요)로 이스케이프해야합니다. &amp;ldquo;*&amp;rdquo;와&amp;ldquo;?&amp;rdquo; 문자는 SQL&amp;ldquo;%&amp;rdquo;및&amp;ldquo;_&amp;rdquo;와일드 카드 문자로 변환됩니다. 이름에 &quot;_&quot;가있는 테이블의 열을 표시하려고하면 혼동이 발생할 수 있습니다.이 경우 mysqlshow는 패턴과 일치하는 테이블 이름 만 표시하기 때문입니다. 이것은 명령 행에서 마지막에 별도의 인수로 &quot;%&quot;를 추가하여 쉽게 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="82214aafcd204db70db6e046ad628603d0db50c0" translate="yes" xml:space="preserve">
          <source>If the last field has fixed length, the table should be referred as having the type &lt;code&gt;FIX&lt;/code&gt;. For instance, to create a table on the file &lt;em&gt;boys.txt&lt;/em&gt;:</source>
          <target state="translated">마지막 필드의 길이가 고정 된 경우 테이블은 &lt;code&gt;FIX&lt;/code&gt; 유형을 갖는 것으로 참조되어야합니다 . 예를 들어, 파일에 테이블을 작성하는 &lt;em&gt;boys.txt를&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="70de089c73267f94ff5a2587b78000f563e066f7" translate="yes" xml:space="preserve">
          <source>If the left argument of IN is the row: &lt;code&gt;(7, NULL, 9)
&lt;/code&gt;, and the result of the right subquery operand of IN is the table:</source>
          <target state="translated">IN의 왼쪽 인수가 &lt;code&gt;(7, NULL, 9) &lt;/code&gt; 행이고 IN 의 오른쪽 하위 쿼리 피연산자의 결과가 테이블 인 경우 :</target>
        </trans-unit>
        <trans-unit id="6ee643d7a26cce552b40b7d977fecca4fdd338d8" translate="yes" xml:space="preserve">
          <source>If the leftmost character is not a multi-byte character, ORD() returns the same value as the &lt;a href=&quot;../ascii/index&quot;&gt;ASCII()&lt;/a&gt; function.</source>
          <target state="translated">가장 왼쪽 문자가 멀티 바이트 문자가 아닌 경우 ORD ()는 &lt;a href=&quot;../ascii/index&quot;&gt;ASCII ()&lt;/a&gt; 함수 와 동일한 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="bd53a42489356752317f1b52b9670eeaa565b959" translate="yes" xml:space="preserve">
          <source>If the leftmost character of the string &lt;code&gt;str&lt;/code&gt; is a multi-byte character, returns the code for that character, calculated from the numeric values of its constituent bytes using this formula:</source>
          <target state="translated">문자열 &lt;code&gt;str&lt;/code&gt; 의 가장 왼쪽 문자가 멀티 바이트 문자 인 경우 다음 공식을 사용하여 구성 바이트의 숫자 값에서 계산 된 해당 문자의 코드를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="15ba74ac6d5c8b1cb6cea1c83acde8b4fa91576c" translate="yes" xml:space="preserve">
          <source>If the library that the system tries to use is not from a MariaDB package, the remedy is to remove the offending package (and possibly install or re-install the correct package) so that the correct library can be used.</source>
          <target state="translated">시스템이 사용하려고하는 라이브러리가 MariaDB 패키지가 아닌 경우, 해결 방법은 올바른 라이브러리를 사용할 수 있도록 문제가있는 패키지를 제거하고 올바른 패키지를 설치 또는 다시 설치하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="72302e911859ed58b98ea1bd746194c1943609a5" translate="yes" xml:space="preserve">
          <source>If the master crashes, then failover may involve some data loss, because the master may have committed transactions that had not yet been acknowledged by the slaves.</source>
          <target state="translated">마스터가 충돌하면 마스터가 아직 슬레이브에 의해 승인되지 않은 트랜잭션을 커밋했을 수 있기 때문에 장애 조치에 약간의 데이터 손실이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e2b85cfccfef64101cbd6a2379b82847fb69387" translate="yes" xml:space="preserve">
          <source>If the master crashes, then failover should be lossless, because all transactions committed on the master would have been replicated to the slave.</source>
          <target state="translated">마스터가 충돌하면 마스터에서 커밋 된 모든 트랜잭션이 슬레이브에 복제 되었기 때문에 장애 조치에 손실이 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="da2eedd1e4c432c7588ff289901b8820465b45ae" translate="yes" xml:space="preserve">
          <source>If the maximum length is exceeded, and &lt;a href=&quot;../sql-mode/index&quot;&gt;SQL strict mode&lt;/a&gt; is not enabled , the extra characters will be dropped with a warning. If strict mode is enabled, an error will occur.</source>
          <target state="translated">최대 길이를 초과하고 &lt;a href=&quot;../sql-mode/index&quot;&gt;SQL 엄격 모드&lt;/a&gt; 를 사용하지 않으면 추가 문자가 경고와 함께 삭제됩니다. 엄격 모드를 사용하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c9ee26f616b74225bb1febfafd658304e37a64e2" translate="yes" xml:space="preserve">
          <source>If the mysql client loses its connection to the server while sending a statement, it immediately and automatically tries to reconnect once to the server and send the statement again. However, even if mysql succeeds in reconnecting, your first connection has ended and all your previous session objects and settings are lost: temporary tables, the autocommit mode, and user-defined and session variables. Also, any current transaction rolls back. This behavior may be dangerous for you, as in the following example where the server was shut down and restarted between the first and second statements without you knowing it:</source>
          <target state="translated">명령문을 보내는 동안 mysql 클라이언트와 서버의 연결이 끊어지면 즉시 자동으로 서버에 다시 연결하고 명령문을 다시 보냅니다. 그러나 mysql이 재 연결에 성공하더라도 첫 번째 연결이 종료되고 임시 테이블, 자동 커밋 모드 및 사용자 정의 및 세션 변수와 같은 모든 이전 세션 객체 및 설정이 손실됩니다. 또한 모든 현재 트랜잭션이 롤백됩니다. 다음 예제에서 알 수없는 첫 번째 명령문과 두 번째 명령문 사이에서 서버가 종료되었다가 다시 시작된 것처럼이 동작은 위험 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ba94bbe925253a643cfda0102343ea4fa01026d" translate="yes" xml:space="preserve">
          <source>If the mysql database is edited directly, logging is performed as expected according to the &lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#binlog_format&quot;&gt;binlog_format&lt;/a&gt;. Statements that directly edit the mysql database include &lt;a href=&quot;../insert/index&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;../delete/index&quot;&gt;DELETE&lt;/a&gt;, &lt;a href=&quot;../replace/index&quot;&gt;REPLACE&lt;/a&gt;, &lt;a href=&quot;../do/index&quot;&gt;DO&lt;/a&gt;, &lt;a href=&quot;../load-data-infile/index&quot;&gt;LOAD DATA INFILE&lt;/a&gt;, &lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt;, and &lt;a href=&quot;../truncate-table/index&quot;&gt;TRUNCATE TABLE&lt;/a&gt;.</source>
          <target state="translated">mysql 데이터베이스를 직접 편집하면 &lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#binlog_format&quot;&gt;binlog_format&lt;/a&gt; 에 따라 예상대로 로깅이 수행됩니다 . mysql 데이터베이스를 직접 편집하는 명령문에는 &lt;a href=&quot;../insert/index&quot;&gt;INSERT&lt;/a&gt; , &lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt; , &lt;a href=&quot;../delete/index&quot;&gt;DELETE가 포함됩니다.&lt;/a&gt; , &lt;a href=&quot;../replace/index&quot;&gt;REPLACE&lt;/a&gt; , &lt;a href=&quot;../do/index&quot;&gt;DO&lt;/a&gt; , &lt;a href=&quot;../load-data-infile/index&quot;&gt;LOAD DATA INFILE&lt;/a&gt; , &lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt; 및 &lt;a href=&quot;../truncate-table/index&quot;&gt;TRUNCATE TABLE이&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="b87bfd60110884364ed7e4453319d6638b32f74c" translate="yes" xml:space="preserve">
          <source>If the mysqld process is killed during an &lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt; you may find a table named #sql-... in your data directory. In &lt;a href=&quot;../what-is-mariadb-103/index&quot;&gt;MariaDB 10.3&lt;/a&gt;, InnoDB tables with this prefix will de deleted automatically during startup. In &lt;a href=&quot;../what-is-mariadb-104/index&quot;&gt;MariaDB 10.4&lt;/a&gt; we will ensure that these temporary tables will always be deleted automatically.</source>
          <target state="translated">&lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt; 동안 mysqld 프로세스가 종료되면 데이터 디렉토리에서 #sql -...이라는 테이블을 찾을 수 있습니다. 에서 &lt;a href=&quot;../what-is-mariadb-103/index&quot;&gt;MariaDB 10.3&lt;/a&gt; ,이 접두사와 InnoDB 테이블은 시작시 자동으로 삭제 채워주. &lt;a href=&quot;../what-is-mariadb-104/index&quot;&gt;MariaDB 10.4&lt;/a&gt; 에서는 이러한 임시 테이블이 항상 자동으로 삭제되도록합니다.</target>
        </trans-unit>
        <trans-unit id="83c77666f7a1322a86c780745fdc17f068497801" translate="yes" xml:space="preserve">
          <source>If the named routine is available, each statement produces a result set. Each row in the result set corresponds to one &quot;instruction&quot; in the routine. The first column is Pos, which is an ordinal number beginning with 0. The second column is Instruction, which contains an SQL statement (usually changed from the original source), or a directive which has meaning only to the stored-routine handler.</source>
          <target state="translated">명명 된 루틴이 사용 가능한 경우 각 명령문은 결과 세트를 생성합니다. 결과 집합의 각 행은 루틴의 하나의 &quot;명령&quot;에 해당합니다. 첫 번째 열은 0으로 시작하는 서수 인 Pos입니다. 두 번째 열은 SQL 문 (보통 원래 소스에서 변경됨) 또는 저장된 루틴 처리기에만 의미가있는 지시문을 포함하는 Instruction입니다.</target>
        </trans-unit>
        <trans-unit id="1ea268612e31a4352e515f11f0a149d7183d0179" translate="yes" xml:space="preserve">
          <source>If the new primary key column is not defined as &lt;code&gt;&lt;a href=&quot;../create-table/index#null-and-not-null&quot;&gt;NOT NULL&lt;/a&gt;&lt;/code&gt;, then it is highly recommended for &lt;a href=&quot;../sql-mode/index#strict-mode&quot;&gt;strict mode&lt;/a&gt; to be enabled in &lt;code&gt;&lt;a href=&quot;../sql-mode/index&quot;&gt;SQL_MODE&lt;/a&gt;&lt;/code&gt;. Otherwise, &lt;code&gt;NULL&lt;/code&gt; values will be silently converted to the default value for the given data type, which is probably not the desired behavior in this scenario.</source>
          <target state="translated">새 기본 키 열이 &lt;code&gt;&lt;a href=&quot;../create-table/index#null-and-not-null&quot;&gt;NOT NULL&lt;/a&gt;&lt;/code&gt; 로 정의 되지 않은 경우 다음을 수행하는 것이 좋습니다.&lt;a href=&quot;../sql-mode/index#strict-mode&quot;&gt;&lt;/a&gt; &lt;code&gt;&lt;a href=&quot;../sql-mode/index&quot;&gt;SQL_MODE&lt;/a&gt;&lt;/code&gt; 에서 엄격 모드 를 사용 . 그렇지 않으면 &lt;code&gt;NULL&lt;/code&gt; 값이 주어진 데이터 유형에 대한 기본값으로 자동 변환되며이 시나리오에서는 바람직하지 않은 동작입니다.</target>
        </trans-unit>
        <trans-unit id="f20cc7e6fdded7395985fb512b7bdacf39f0a95a" translate="yes" xml:space="preserve">
          <source>If the new table has a primary key or &lt;code&gt;UNIQUE&lt;/code&gt; indexes, you can use the &lt;a href=&quot;../ignore/index&quot;&gt;IGNORE&lt;/a&gt; or &lt;code&gt;REPLACE&lt;/code&gt; keywords to handle duplicate key errors during the query. &lt;code&gt;IGNORE&lt;/code&gt; means that the newer values must not be inserted an identical value exists in the index. &lt;code&gt;REPLACE&lt;/code&gt; means that older values must be overwritten.</source>
          <target state="translated">새 테이블에 기본 키 또는 &lt;code&gt;UNIQUE&lt;/code&gt; 인덱스가 있으면 &lt;a href=&quot;../ignore/index&quot;&gt;IGNORE를&lt;/a&gt; 사용할 수 있습니다 또는 &lt;code&gt;REPLACE&lt;/code&gt; 키워드를 사용하여 쿼리 중에 중복 키 오류를 처리 . &lt;code&gt;IGNORE&lt;/code&gt; 는 새로운 값을 삽입해서는 안된다는 것을 의미합니다. 동일한 값이 색인에 존재합니다. &lt;code&gt;REPLACE&lt;/code&gt; 는 이전 값을 덮어 써야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d81899deac9e76e997a2de3f6e2830fd05701923" translate="yes" xml:space="preserve">
          <source>If the new table has a primary key or UNIQUE indexes, you can use &lt;a href=&quot;../ignore/index&quot;&gt;IGNORE&lt;/a&gt; to handle duplicate key errors during the query. The newer values will not be inserted if an identical value already exists.</source>
          <target state="translated">새 테이블에 기본 키 또는 UNIQUE 인덱스가 있으면 &lt;a href=&quot;../ignore/index&quot;&gt;IGNORE&lt;/a&gt; 를 사용 하여 쿼리 중에 중복 키 오류를 처리 할 수 있습니다 . 동일한 값이 이미 존재하면 새로운 값이 삽입되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="28431c77d2d1f122f363224bab46e1b8f9f87697" translate="yes" xml:space="preserve">
          <source>If the new value is higher than the current maximum value, the &lt;code&gt;AUTO_INCREMENT&lt;/code&gt; value is updated, so the next value will be higher. If the new value is lower than the current maximum value, the &lt;code&gt;AUTO_INCREMENT&lt;/code&gt; value remains unchanged.</source>
          <target state="translated">새 값이 현재 최대 값보다 높으면 &lt;code&gt;AUTO_INCREMENT&lt;/code&gt; 값이 업데이트되므로 다음 값이 높아집니다. 새 값이 현재 최대 값보다 낮은 경우 &lt;code&gt;AUTO_INCREMENT&lt;/code&gt; 값은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e260e31b7c523ea3bacd2362eef4d62e238923b8" translate="yes" xml:space="preserve">
          <source>If the node is a replication master, then its replication slaves only replicate transactions which are in the binary log, so this means that the transactions that correspond to Galera Cluster write-sets would not be replicated by any replication slaves by default. If you would like a node to write its replicated write sets to the &lt;a href=&quot;../../binary-log/index&quot;&gt;binary log&lt;/a&gt;, then you will have to set &lt;code&gt;&lt;a href=&quot;../../replication-and-binary-log-system-variables/index#log_slave_updates&quot;&gt;log_slave_updates=ON&lt;/a&gt;&lt;/code&gt;. If the node has any replication slaves, then this would also allow those slaves to replicate the transactions that corresponded to those write sets.</source>
          <target state="translated">노드가 복제 마스터 인 경우 복제 슬레이브는 이진 로그에있는 트랜잭션 만 복제하므로 Galera Cluster 쓰기 세트에 해당하는 트랜잭션은 기본적으로 복제 슬레이브에 의해 복제되지 않습니다. 노드가 복제 된 쓰기 세트를 &lt;a href=&quot;../../binary-log/index&quot;&gt;2 진 로그에&lt;/a&gt; 쓰도록하려면 &lt;code&gt;&lt;a href=&quot;../../replication-and-binary-log-system-variables/index#log_slave_updates&quot;&gt;log_slave_updates=ON&lt;/a&gt;&lt;/code&gt; 을 설정해야합니다 . 노드에 복제 슬레이브가있는 경우 해당 슬레이브가 해당 쓰기 세트에 해당하는 트랜잭션을 복제 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f7ad1a7fc2cc8f1dbdd75d1b3c86fe9f3efe339" translate="yes" xml:space="preserve">
          <source>If the node is a replication slave, then it is probably also a good idea to enable &lt;code&gt;&lt;a href=&quot;../../galera-cluster-system-variables/index#wsrep_restart_slave&quot;&gt;wsrep_restart_slave&lt;/a&gt;&lt;/code&gt;. When this is enabled, the node will restart its &lt;a href=&quot;../../replication-threads/index#threads-on-the-slave&quot;&gt;slave threads&lt;/a&gt; whenever it rejoins the cluster.</source>
          <target state="translated">노드가 복제 슬레이브 인 경우 &lt;code&gt;&lt;a href=&quot;../../galera-cluster-system-variables/index#wsrep_restart_slave&quot;&gt;wsrep_restart_slave&lt;/a&gt;&lt;/code&gt; 를 사용하는 것이 좋습니다. . 이것이 활성화되면 노드는 클러스터에 다시 참여할 때마다 &lt;a href=&quot;../../replication-threads/index#threads-on-the-slave&quot;&gt;슬레이브 스레드&lt;/a&gt; 를 다시 시작 합니다.</target>
        </trans-unit>
        <trans-unit id="ba5a5d895951d5575ade61c6c6c9ac22dbcc4ceb" translate="yes" xml:space="preserve">
          <source>If the node is a replication slave, then the node's &lt;a href=&quot;../../replication-threads/index#slave-sql-thread&quot;&gt;slave SQL thread&lt;/a&gt; will be applying transactions that it replicates from its replication master. Transactions applied by the slave SQL thread will only generate Galera Cluster write-sets if the node has &lt;code&gt;&lt;a href=&quot;../../replication-and-binary-log-system-variables/index#log_slave_updates&quot;&gt;log_slave_updates=ON&lt;/a&gt;&lt;/code&gt; set. Therefore, in order to replicate these transactions to the rest of the nodes in the cluster, &lt;code&gt;&lt;a href=&quot;../../replication-and-binary-log-system-variables/index#log_slave_updates&quot;&gt;log_slave_updates=ON&lt;/a&gt;&lt;/code&gt; must be set.</source>
          <target state="translated">노드가 복제 슬레이브 인 경우 노드의 &lt;a href=&quot;../../replication-threads/index#slave-sql-thread&quot;&gt;슬레이브 SQL 스레드&lt;/a&gt; 는 복제 마스터에서 복제 한 트랜잭션을 적용합니다. 노드에 &lt;code&gt;&lt;a href=&quot;../../replication-and-binary-log-system-variables/index#log_slave_updates&quot;&gt;log_slave_updates=ON&lt;/a&gt;&lt;/code&gt; 이있는 경우 슬레이브 SQL 스레드에 의해 적용된 트랜잭션은 Galera Cluster 쓰기 세트 만 생성합니다. 설정된 . 따라서 이러한 트랜잭션을 클러스터의 나머지 노드에 복제하려면 &lt;code&gt;&lt;a href=&quot;../../replication-and-binary-log-system-variables/index#log_slave_updates&quot;&gt;log_slave_updates=ON&lt;/a&gt;&lt;/code&gt; 을 설정 해야합니다.</target>
        </trans-unit>
        <trans-unit id="28059496587fa07409ec94f49df32e47588debcf" translate="yes" xml:space="preserve">
          <source>If the node is synchronizing with the cluster by performing a state transfer that allows access to the server, such as an &lt;a href=&quot;../getting-started-with-mariadb-galera-cluster/index#incremental-state-transfers-ists&quot;&gt;Incremental State Transfer (IST)&lt;/a&gt; or a &lt;a href=&quot;../introduction-to-state-snapshot-transfers-ssts/index&quot;&gt;State Snapshot Transfer(SST)&lt;/a&gt; that uses the &lt;code&gt;&lt;a href=&quot;../mysqldump/index&quot;&gt;mysqldump&lt;/a&gt;&lt;/code&gt; SST method, then you can check the status of the state transfer by connecting to the server through the &lt;code&gt;mysql&lt;/code&gt; client, then checking the &lt;code&gt;&lt;a href=&quot;../galera-cluster-status-variables/index#wsrep_local_state_uuid&quot;&gt;wsrep_local_state_uuid&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../galera-cluster-status-variables/index#wsrep_cluster_state_uuid&quot;&gt;wsrep_cluster_state_uuid&lt;/a&gt;&lt;/code&gt; status variables. When they equal each other, the node is in sync with the cluster.</source>
          <target state="translated">&lt;a href=&quot;../getting-started-with-mariadb-galera-cluster/index#incremental-state-transfers-ists&quot;&gt;IST (Incremental State Transfer)&lt;/a&gt; 또는 &lt;code&gt;&lt;a href=&quot;../mysqldump/index&quot;&gt;mysqldump&lt;/a&gt;&lt;/code&gt; SST 방법 을 사용하는 &lt;a href=&quot;../introduction-to-state-snapshot-transfers-ssts/index&quot;&gt;SST (State Snapshot Transfer &lt;/a&gt;) 와 같이 서버에 액세스 할 수있는 상태 전송을 수행하여 노드가 클러스터와 동기화중인 경우 상태 를 확인할 수 있습니다. &lt;code&gt;mysql&lt;/code&gt; 클라이언트를 통해 서버에 연결 한 다음 &lt;code&gt;&lt;a href=&quot;../galera-cluster-status-variables/index#wsrep_local_state_uuid&quot;&gt;wsrep_local_state_uuid&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../galera-cluster-status-variables/index#wsrep_cluster_state_uuid&quot;&gt;wsrep_cluster_state_uuid&lt;/a&gt;&lt;/code&gt; 상태 변수. 서로 같으면 노드가 클러스터와 동기화됩니다.</target>
        </trans-unit>
        <trans-unit id="36f10a5909b3dbe0bd69bbcc0ef82d5cf792472b" translate="yes" xml:space="preserve">
          <source>If the number of opened tables is increasing rapidly, you should look at increasing the table_open_cache value. Try to find a value that sees a slow, or possibly even no, increase in the number of opened tables.</source>
          <target state="translated">열린 테이블 수가 빠르게 증가하는 경우 table_open_cache 값이 증가하는지 확인해야합니다. 열린 테이블 수가 느리거나 증가하지 않는 값을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="540c15a01ff2acbf7be03ca8e408b9d0d7e9f302" translate="yes" xml:space="preserve">
          <source>If the operation requires the table to be rebuilt, then the operation might have to create temporary tables.</source>
          <target state="translated">조작에서 테이블을 재 빌드해야하는 경우 조작은 임시 테이블을 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="dc24860d6dbcd60518ea422545ff507b4b5a01b1" translate="yes" xml:space="preserve">
          <source>If the option is completely invalid, then remove it from the &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;option file&lt;/a&gt;.</source>
          <target state="translated">옵션이 완전히 유효하지 않으면 &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;옵션 파일&lt;/a&gt; 에서 제거 하십시오. .</target>
        </trans-unit>
        <trans-unit id="3e88211076d8d9be97aefcc3520a84b4fbcf7251" translate="yes" xml:space="preserve">
          <source>If the option is set in an &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;option file&lt;/a&gt; and if &lt;code&gt;&lt;a href=&quot;../mysql_install_db/index&quot;&gt;mysql_install_db&lt;/a&gt;&lt;/code&gt; is executed, then &lt;code&gt;&lt;a href=&quot;../mysql_install_db/index&quot;&gt;mysql_install_db&lt;/a&gt;&lt;/code&gt; will read this option from the &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;option file&lt;/a&gt;, and it will automatically set this option.</source>
          <target state="translated">옵션은 설정되어있는 경우 &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;옵션 파일&lt;/a&gt; 및 경우 &lt;code&gt;&lt;a href=&quot;../mysql_install_db/index&quot;&gt;mysql_install_db&lt;/a&gt;&lt;/code&gt; 가이 실행 된 후, &lt;code&gt;&lt;a href=&quot;../mysql_install_db/index&quot;&gt;mysql_install_db&lt;/a&gt;&lt;/code&gt; 가이 로부터이 옵션을 읽어 &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;옵션 파일을&lt;/a&gt; , 그리고 자동이 옵션을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="9822b11e34e7c4ddcb21f28c55268df70d63cf8e" translate="yes" xml:space="preserve">
          <source>If the option's name has changed, then fix the name.</source>
          <target state="translated">옵션 이름이 변경된 경우 이름을 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="564fcc35bb1270d6baafbca65c282be6a45a810c" translate="yes" xml:space="preserve">
          <source>If the option's valid values have changed, then change the option's value to a valid one.</source>
          <target state="translated">옵션의 유효한 값이 변경된 경우 옵션의 값을 유효한 값으로 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="fa15c35c83863d33f9fd5709db97c73decc33ca5" translate="yes" xml:space="preserve">
          <source>If the optional &lt;code&gt;OR REPLACE&lt;/code&gt; clause is used, it acts as a shortcut for:</source>
          <target state="translated">선택 품목 인 &lt;code&gt;OR REPLACE&lt;/code&gt; 절을 사용하면 다음에 대한 바로 가기 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="35894cf320db3a0f9b7ae4b4e15ea588d90b95f0" translate="yes" xml:space="preserve">
          <source>If the optional &lt;code&gt;OR REPLACE&lt;/code&gt; clause is used, it is basically a shortcut for:</source>
          <target state="translated">선택 품목 인 &lt;code&gt;OR REPLACE&lt;/code&gt; 절을 사용하는 경우 기본적으로 다음에 대한 단축키입니다.</target>
        </trans-unit>
        <trans-unit id="dc9f35ed6da1503c96ef77db1cfbf09247016947" translate="yes" xml:space="preserve">
          <source>If the original SQL statement has a result set from the foreign data source, the FederatedX storage engine iterates through the result set and converts each row and column to the internal handler format</source>
          <target state="translated">원래 SQL 문에 외부 데이터 소스의 결과 세트가있는 경우 FederatedX 스토리지 엔진은 결과 세트를 반복하고 각 행과 열을 내부 핸들러 형식으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="c72ae5dfbfc08f520b2551f172e64a5c1b20826d" translate="yes" xml:space="preserve">
          <source>If the original SQL statement only returns the number of rows returned (affected_rows), that number is added to the table stats which results in the user seeing how many rows were affected.</source>
          <target state="translated">원래 SQL 문이 리턴 된 행 수 (affected_rows) 만 리턴하면 해당 숫자가 테이블 통계에 추가되어 영향을받는 행 수를 사용자에게 표시합니다.</target>
        </trans-unit>
        <trans-unit id="dc36e1d9552c2046cf271f8e8ca4bcd6c6741053" translate="yes" xml:space="preserve">
          <source>If the password is specified using the &lt;code&gt;&lt;a href=&quot;../password/index&quot;&gt;PASSWORD()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../old_password/index&quot;&gt;OLD_PASSWORD()&lt;/a&gt;&lt;/code&gt; function, the literal text of the password should be given. If the password is specified without using either function, the password should be the already-encrypted password value as returned by &lt;code&gt;&lt;a href=&quot;../password/index&quot;&gt;PASSWORD()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../password/index&quot;&gt;PASSWORD()&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../old_password/index&quot;&gt;OLD_PASSWORD()&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 비밀번호를 지정한 경우 비밀번호 의 리터럴 텍스트를 제공해야합니다. 두 함수 중 하나를 사용하지 않고 비밀번호를 지정하는 경우 비밀번호는 &lt;code&gt;&lt;a href=&quot;../password/index&quot;&gt;PASSWORD()&lt;/a&gt;&lt;/code&gt; 리턴 한대로 이미 암호화 된 비밀번호 값이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="43e5d1e87419a67f936636b16cc2a8f21538a8ce" translate="yes" xml:space="preserve">
          <source>If the path does not exist, Transparent Hugepages are not enabled and you may continue.</source>
          <target state="translated">경로가 존재하지 않으면 Transparent Hugepages가 활성화되지 않고 계속 진행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c01cb555f9a2b4fee4e085eb0e99d333089ce32" translate="yes" xml:space="preserve">
          <source>If the pattern does not occur in the string list or if the string list is an empty string, the function returns &lt;code&gt;0&lt;/code&gt;. If either argument is &lt;code&gt;NULL&lt;/code&gt;, the function returns &lt;code&gt;NULL&lt;/code&gt;. The function does not return the correct result if the pattern contains a comma (&quot;&lt;code&gt;,&lt;/code&gt;&quot;) character.</source>
          <target state="translated">문자열 목록에서 패턴이 발생하지 않거나 문자열 목록이 빈 문자열 인 경우 함수는 &lt;code&gt;0&lt;/code&gt; 을 리턴합니다 . 인수 중 하나가 &lt;code&gt;NULL&lt;/code&gt; 이면 함수는 &lt;code&gt;NULL&lt;/code&gt; 을 반환 합니다 . 패턴에 쉼표 ( &quot;)가 포함 된 경우 함수는 올바른 결과를 반환하지 않습니다 &lt;code&gt;,&lt;/code&gt; &quot;) 문자 .</target>
        </trans-unit>
        <trans-unit id="1bebcf46f91e1630ca3d521631abd82aa654d95c" translate="yes" xml:space="preserve">
          <source>If the prepared statement contains a syntax error, PREPARE will fail. As a side effect, stored procedures can use it to check if a statement is valid. For example:</source>
          <target state="translated">준비된 명령문에 구문 오류가 있으면 PREPARE가 실패합니다. 부작용으로 저장 프로시 저는이를 사용하여 명령문이 유효한지 확인할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a29eeb691dd3c9c1401807d49b8371c471f7a45b" translate="yes" xml:space="preserve">
          <source>If the previous statement returned an error, the value of LAST_INSERT_ID() is undefined. For transactional tables, if the statement is rolled back due to an error, the value of LAST_INSERT_ID() is left undefined. For manual &lt;a href=&quot;../rollback/index&quot;&gt;ROLLBACK&lt;/a&gt;, the value of LAST_INSERT_ID() is not restored to that before the transaction; it remains as it was at the point of the ROLLBACK.</source>
          <target state="translated">이전 명령문이 오류를 리턴 한 경우 LAST_INSERT_ID () 값이 정의되지 않았습니다. 트랜잭션 테이블의 경우 오류로 인해 명령문이 롤백되면 LAST_INSERT_ID () 값이 정의되지 않은 상태로 남습니다. 수동 &lt;a href=&quot;../rollback/index&quot;&gt;롤백&lt;/a&gt; 의 경우 LAST_INSERT_ID () 값은 트랜잭션 이전의 값으로 복원되지 않습니다. ROLLBACK 시점에 그대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="b482acc5612d620627083a5038206c2dedf82717" translate="yes" xml:space="preserve">
          <source>If the problem is caused by a simple typo, then fix the typo.</source>
          <target state="translated">간단한 오타로 인해 문제가 발생한 경우 오타를 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="070e5648afb836d8f0c900a36d19c7524c662d8d" translate="yes" xml:space="preserve">
          <source>If the query contains a GROUP BY clause, the last group where the limit was reached will be discarded.</source>
          <target state="translated">쿼리에 GROUP BY 절이 포함 된 경우 제한에 도달 한 마지막 그룹이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="14ac1a70caaae4ed648f033dfb0a5e41678444f8" translate="yes" xml:space="preserve">
          <source>If the query doesn't match Cassandra's schema, they need to run Hive (or Pig), which have some kind of distributed join support. Hive/Pig compile queries to Map/reduce job which are ran across the whole cluster, so they will certainly beat Cassandra Storage Engine which runs on one mysqld node (you can have multiple mysqld nodes of course, but they will not cooperate with one another).</source>
          <target state="translated">쿼리가 Cassandra의 스키마와 일치하지 않으면 분산 조인 지원이있는 Hive (또는 Pig)를 실행해야합니다. Hive / Pig는 전체 클러스터에서 실행되는 Map / reduce 작업으로 쿼리를 컴파일하므로 하나의 mysqld 노드에서 실행되는 Cassandra Storage Engine을 확실히 능가합니다 (물론 여러 mysqld 노드를 가질 수 있지만 서로 협력하지는 않습니다) ).</target>
        </trans-unit>
        <trans-unit id="a835c3634a5b974d35c037db2d6cb108b14ce382" translate="yes" xml:space="preserve">
          <source>If the query is for instance &quot;&lt;code&gt;SELECT * FROM foo
&lt;/code&gt;&quot;, then the primary methods you would see with debug turned on would be first:</source>
          <target state="translated">쿼리가 예를 들어 &quot; &lt;code&gt;SELECT * FROM foo &lt;/code&gt; &quot;인 경우 디버그를 켠 상태에서 볼 수있는 기본 방법이 먼저입니다.</target>
        </trans-unit>
        <trans-unit id="bced0d10abcb2b8ca47f7253a414cc4bf1e6186a" translate="yes" xml:space="preserve">
          <source>If the query was &quot;&lt;code&gt;INSERT INTO foo (id, ts) VALUES (2, now());
&lt;/code&gt;&quot;, the trace would be:</source>
          <target state="translated">쿼리가 &quot; &lt;code&gt;INSERT INTO foo (id, ts) VALUES (2, now()); &lt;/code&gt; &quot;인 경우 추적은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="71e6c5de24d7578b409636039f922cc6522a3208" translate="yes" xml:space="preserve">
          <source>If the query was &quot;&lt;code&gt;UPDATE foo SET ts = now() WHERE id = 1;
&lt;/code&gt;&quot;, the resultant trace would be:</source>
          <target state="translated">쿼리가 &quot; &lt;code&gt;UPDATE foo SET ts = now() WHERE id = 1; &lt;/code&gt; &quot;인 경우 결과 추적은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cdc1f2fc88fd9fc78ae4310787e2862a2d4e6490" translate="yes" xml:space="preserve">
          <source>If the realm is not provided in the user account's definition, then the realm is &lt;strong&gt;not&lt;/strong&gt; used for comparison. Therefore, 'usr1@EXAMPLE.COM', 'usr1@EXAMPLE.CO.UK' and 'mymachine\usr1' would all identify as the following user account:</source>
          <target state="translated">영역이 사용자 계정 정의에 제공되지 않으면 영역은 &lt;strong&gt; 되지 않으면&lt;/strong&gt; 비교에 사용 &lt;strong&gt;되지 않습니다&lt;/strong&gt; . 따라서 'usr1@EXAMPLE.COM', 'usr1@EXAMPLE.CO.UK'및 'mymachine \ usr1'은 모두 다음 사용자 계정으로 식별됩니다.</target>
        </trans-unit>
        <trans-unit id="eecfb5276beb0a225484bd058e922c0fb39661ec" translate="yes" xml:space="preserve">
          <source>If the relay logs are taking up too much space on the slave, the &lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#relay_log_space_limit&quot;&gt;relay_log_space_limit&lt;/a&gt; system variable can be set to limit the size. The IO thread will stop until the SQL thread has cleared the backlog. By default there is no limit.</source>
          <target state="translated">릴레이 로그가 슬레이브에서 너무 많은 공간을 &lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#relay_log_space_limit&quot;&gt;차지하는&lt;/a&gt; 경우 relay_log_space_limit 시스템 변수를 설정하여 크기를 제한 할 수 있습니다. IO 스레드는 SQL 스레드가 백 로그를 지울 때까지 중지됩니다. 기본적으로 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="ea12c7bf70965531b9aa6ece0eabfc20b9b0c49c" translate="yes" xml:space="preserve">
          <source>If the result is a single row, &lt;a href=&quot;../select-into-variable/index&quot;&gt;SELECT ... INTO @var_name&lt;/a&gt; can also be used.</source>
          <target state="translated">결과가 단일 행인 경우 &lt;a href=&quot;../select-into-variable/index&quot;&gt;SELECT ... INTO @var_name&lt;/a&gt; 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2240fdd5a688020642cfc8344d4676c77ea5d860" translate="yes" xml:space="preserve">
          <source>If the result set is of reasonable size, it is also possible to specify the block_size option equal or slightly larger than the result set. The whole result set being read on the first fetch, can be accessed many times without having to do anything else.</source>
          <target state="translated">결과 세트의 크기가 적당한 경우 결과 세트와 같거나 약간 큰 block_size 옵션을 지정할 수도 있습니다. 첫 번째 페치에서 읽은 전체 결과 세트는 다른 작업을 수행하지 않고도 여러 번 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f1eb7edf166a7f396b85cd8167a3369a580f94f" translate="yes" xml:space="preserve">
          <source>If the return value is used in a REAL context or all arguments are real-valued, they are compared as reals.</source>
          <target state="translated">반환 값이 REAL 컨텍스트에서 사용되거나 모든 인수가 실제 값인 경우 실제 값과 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="8557395f06dfbfaa62f8336ea79ecec2bcc0d2ef" translate="yes" xml:space="preserve">
          <source>If the return value is used in an INTEGER context or all arguments are integer-valued, they are compared as integers.</source>
          <target state="translated">리턴 값이 INTEGER 컨텍스트에서 사용되거나 모든 인수가 정수 값인 경우 정수로 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="9ab97c3d7dfa33acf3fbabecda3ebbb53fda5441" translate="yes" xml:space="preserve">
          <source>If the routine name is the same as the name of a built-in SQL function, you must use a space between the name and the following parenthesis when defining the routine, or a syntax error occurs. This is also true when you invoke the routine later. For this reason, we suggest that it is better to avoid re-using the names of existing SQL functions for your own stored routines.</source>
          <target state="translated">루틴 이름이 내장 SQL 함수의 이름과 동일한 경우 루틴을 정의 할 때 이름과 다음 괄호 사이에 공백을 사용해야합니다. 그렇지 않으면 구문 오류가 발생합니다. 나중에 루틴을 호출 할 때도 마찬가지입니다. 이러한 이유로, 자체 저장 루틴에 기존 SQL 함수의 이름을 재사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="93fe3878c498cb0f9d7488c070b256a9451b18b0" translate="yes" xml:space="preserve">
          <source>If the same column needs to be referenced more than once in the projection list, a unique name is required for each column using a column alias.The total length of the name of a column, inclusive of length of functions, in the projection list must be 64 characters or less.</source>
          <target state="translated">투영 목록에서 동일한 열을 두 번 이상 참조해야하는 경우 열 별칭을 사용하여 각 열마다 고유 한 이름이 필요합니다. 투영 목록에서 함수 길이를 포함한 열 이름의 총 길이 64 자 이하 여야합니다.</target>
        </trans-unit>
        <trans-unit id="ccf1f9c891765b8eb711fc428516e4a1f44573b1" translate="yes" xml:space="preserve">
          <source>If the script tries to create the repository configuration file and one with that name already exists, then the script will rename the existing file with an extension in the format &quot;.old_[0-9]+&quot;, which would make the OS's package manager ignore the file. You can safely remove those files after you have confirmed that the updated repository configuration file works..</source>
          <target state="translated">스크립트가 저장소 구성 파일을 작성하려고 시도하고 해당 이름을 가진 파일이 이미 존재하는 경우, 스크립트는 &quot;.old_ [0-9] +&quot;형식의 확장자로 기존 파일의 이름을 바꾸어 OS의 패키지 관리자를 만듭니다. 파일을 무시하십시오. 업데이트 된 저장소 구성 파일이 작동하는지 확인한 후 해당 파일을 안전하게 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc01b167e82a3cc63637c78aae6928975394a79a" translate="yes" xml:space="preserve">
          <source>If the search criteria cannot be confined to an INDEX in a single table, this technique is doomed. I have another paper that discusses &quot;Lists&quot;, which solves that (which extra development work), and even improves on what is discussed here.</source>
          <target state="translated">단일 테이블에서 검색 기준을 INDEX로 제한 할 수없는 경우이 기술이 중단됩니다. &quot;목록&quot;에 대해 논의하는 또 다른 논문이 있는데,이 목록은이를 해결하고 (추가 개발 작업) 여기에서 논의 된 내용을 개선합니다.</target>
        </trans-unit>
        <trans-unit id="2fdc876e1ecc83788285360be9dd70744f3c134c" translate="yes" xml:space="preserve">
          <source>If the separator is &lt;code&gt;NULL&lt;/code&gt;, the result is &lt;code&gt;NULL&lt;/code&gt;; all other &lt;code&gt;NULL&lt;/code&gt; values are skipped. This makes &lt;code&gt;CONCAT_WS()&lt;/code&gt; suitable when you want to concatenate some values and avoid losing all information if one of them is &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">구분 기호가 &lt;code&gt;NULL&lt;/code&gt; 이면 결과는 &lt;code&gt;NULL&lt;/code&gt; 입니다 . 다른 모든 &lt;code&gt;NULL&lt;/code&gt; 값은 건너 뜁니다. &lt;code&gt;CONCAT_WS()&lt;/code&gt; 는 일부 값을 연결하고 그 중 하나가 &lt;code&gt;NULL&lt;/code&gt; 인 경우 모든 정보를 잃지 않도록 할 때 적합 합니다 .</target>
        </trans-unit>
        <trans-unit id="cebc198c7fcc18dc22e66473be13205160a8062f" translate="yes" xml:space="preserve">
          <source>If the sequence has not yet been used by the connection, &lt;code&gt;PREVIOUS VALUE FOR&lt;/code&gt; returns &lt;code&gt;NULL&lt;/code&gt; (same thing applies when the server is restarted, a new connection doesn't see a last value for an existing sequence).</source>
          <target state="translated">연결에서 시퀀스를 아직 사용하지 않은 경우 &lt;code&gt;PREVIOUS VALUE FOR&lt;/code&gt; 는 &lt;code&gt;NULL&lt;/code&gt; 을 반환 합니다 (서버가 다시 시작될 때도 동일한 사항이 적용되며 새 연결은 기존 시퀀스의 마지막 값을 보지 못함).</target>
        </trans-unit>
        <trans-unit id="b1055cd31edab25808077dc01d01f3219dee578f" translate="yes" xml:space="preserve">
          <source>If the server crashes, usually the Change Buffer is not empty. However, changes are not lost because they are written to the transaction logs, so they can be applied at server restart.</source>
          <target state="translated">서버가 충돌하면 일반적으로 변경 버퍼가 비어 있지 않습니다. 그러나 트랜잭션 로그에 기록되므로 변경 내용이 손실되지 않으므로 서버를 다시 시작할 때 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d10f347da36afe6984d5b169e0268b4002098f4" translate="yes" xml:space="preserve">
          <source>If the server does not find the &lt;a href=&quot;../error-log/index#error-messages-file&quot;&gt;error message file&lt;/a&gt; for the language, then it tries to interpret the value of the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#lc_messages_dir&quot;&gt;lc_messages_dir&lt;/a&gt;&lt;/code&gt; system variable as a direct path to the directory storing the specific language's &lt;a href=&quot;../error-log/index#error-messages-file&quot;&gt;error message file&lt;/a&gt;.</source>
          <target state="translated">서버가 언어에 대한 &lt;a href=&quot;../error-log/index#error-messages-file&quot;&gt;오류 메시지 파일&lt;/a&gt; 을 찾지 못하면 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#lc_messages_dir&quot;&gt;lc_messages_dir&lt;/a&gt;&lt;/code&gt; 시스템 변수 의 값을 특정 언어의 &lt;a href=&quot;../error-log/index#error-messages-file&quot;&gt;오류 메시지 파일을&lt;/a&gt; 저장하는 디렉토리의 직접 경로로 해석하려고 합니다 .</target>
        </trans-unit>
        <trans-unit id="c451bfab796013352323aff640c6b5d7de9f16a9" translate="yes" xml:space="preserve">
          <source>If the server does not find the &lt;a href=&quot;../error-log/index#error-messages-file&quot;&gt;error message file&lt;/a&gt; for the language, then it tries to interpret the value of this system variable as a direct path to the directory storing the specific language's &lt;a href=&quot;../error-log/index#error-messages-file&quot;&gt;error message file&lt;/a&gt;.</source>
          <target state="translated">서버가 언어에 대한 &lt;a href=&quot;../error-log/index#error-messages-file&quot;&gt;오류 메시지 파일&lt;/a&gt; 을 찾지 못하면 이 시스템 변수의 값을 특정 언어의 &lt;a href=&quot;../error-log/index#error-messages-file&quot;&gt;오류 메시지 파일을&lt;/a&gt; 저장하는 디렉토리의 직접 경로로 해석하려고 합니다 .</target>
        </trans-unit>
        <trans-unit id="cfa357b04c6dfedd7aeb2ab100a9c12f35157499" translate="yes" xml:space="preserve">
          <source>If the server finds that either the server-side or client-side default authentication plugin does not match the actual authentication plugin that should be used for the given user account, then the server restarts the authentication on either the server side or the client side.</source>
          <target state="translated">서버가 서버 측 또는 클라이언트 측 기본 인증 플러그인이 지정된 사용자 계정에 사용해야하는 실제 인증 플러그인과 일치하지 않는 것을 발견하면 서버는 서버 측 또는 클라이언트 측에서 인증을 다시 시작합니다.</target>
        </trans-unit>
        <trans-unit id="73c40183758d2c23f90a27211c2285aeaffe934e" translate="yes" xml:space="preserve">
          <source>If the server is &lt;a href=&quot;../what-is-mariadb-103/index&quot;&gt;MariaDB 10.3&lt;/a&gt; or later or if it is running &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt; and the &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_safe_truncate&quot;&gt;innodb_safe_truncate&lt;/a&gt;&lt;/code&gt; system variable is set to &lt;code&gt;OFF&lt;/code&gt;, then the format will actually be &lt;code&gt;&lt;code&gt;#&lt;/code&gt;sql-ib${TABLESPACE_ID}-${RAND}&lt;/code&gt;, where &lt;code&gt;${TABLESPACE_ID}&lt;/code&gt; is the table's tablespace ID within InnoDB and &lt;code&gt;${RAND}&lt;/code&gt; is a randomly initialized number. Therefore, the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#datadir&quot;&gt;datadir&lt;/a&gt;&lt;/code&gt; may contain files with file names like &lt;code&gt;&lt;code&gt;#&lt;/code&gt;sql-ib230291-1363966925.ibd&lt;/code&gt;.</source>
          <target state="translated">서버 인 경우 &lt;a href=&quot;../what-is-mariadb-103/index&quot;&gt;MariaDB 10.3&lt;/a&gt; 이상 또는 실행중인 경우 &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt; 과 &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_safe_truncate&quot;&gt;innodb_safe_truncate&lt;/a&gt;&lt;/code&gt; 시스템 변수하는 것은으로 설정되어 &lt;code&gt;OFF&lt;/code&gt; , 다음 형식은 실제로있을 것입니다 &lt;code&gt;&lt;code&gt;#&lt;/code&gt;sql-ib${TABLESPACE_ID}-${RAND}&lt;/code&gt; , &lt;code&gt;${TABLESPACE_ID}&lt;/code&gt; InnoDB 내 테이블의 테이블 스페이스 ID이고 &lt;code&gt;${RAND}&lt;/code&gt; 는 임의로 초기화 된 숫자입니다. 따라서 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#datadir&quot;&gt;datadir&lt;/a&gt;&lt;/code&gt; 에는 &lt;code&gt;&lt;code&gt;#&lt;/code&gt;sql-ib230291-1363966925.ibd&lt;/code&gt; 와 같은 파일 이름을 가진 파일이 포함될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="043d0dbbc096d65b2fb70240426c1e9a4d3b19ee" translate="yes" xml:space="preserve">
          <source>If the server is a &lt;a href=&quot;../replication/index&quot;&gt;replication slave&lt;/a&gt;, then this option causes Mariabackup to print the hostname of the slave's replication master and the &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt; file and position of the &lt;a href=&quot;../replication-threads/index#slave-sql-thread&quot;&gt;slave's SQL thread&lt;/a&gt; to &lt;code&gt;stdout&lt;/code&gt;.</source>
          <target state="translated">서버가 &lt;a href=&quot;../replication/index&quot;&gt;복제 슬레이브&lt;/a&gt; 인 경우이 옵션을 사용하면 Mariabackup이 슬레이브 복제 마스터의 호스트 이름과 &lt;a href=&quot;../binary-log/index&quot;&gt;이진 로그&lt;/a&gt; 파일 및 &lt;a href=&quot;../replication-threads/index#slave-sql-thread&quot;&gt;슬레이브 SQL 스레드의&lt;/a&gt; 위치 를 &lt;code&gt;stdout&lt;/code&gt; 에 인쇄 합니다.</target>
        </trans-unit>
        <trans-unit id="2506380e03a531c92b2920f25b7e2c8f5b73a868" translate="yes" xml:space="preserve">
          <source>If the server is configured to automatically re-encrypt table data with the newer version of the encryption key after the key is rotated, then that prevents an encryption key from being used for long periods of time.</source>
          <target state="translated">키를 회전 한 후 서버가 최신 버전의 암호화 키로 테이블 데이터를 자동으로 다시 암호화하도록 구성된 경우 암호화 키가 오랫동안 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5b53137634a06fdba37d42831dfac7fe67a06661" translate="yes" xml:space="preserve">
          <source>If the server is configured to simultaneously encrypt table data with multiple versions of the encryption key after the key is rotated, then that prevents all data from being leaked if a single encryption key version is compromised.</source>
          <target state="translated">키를 회전 한 후 서버가 여러 버전의 암호화 키로 테이블 데이터를 동시에 암호화하도록 구성된 경우 단일 암호화 키 버전이 손상된 경우 모든 데이터가 유출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2b876420fed01271cc28e5e28157a2e932102e4c" translate="yes" xml:space="preserve">
          <source>If the server is restarted at this point, then the &lt;a href=&quot;../auto_increment/index&quot;&gt;AUTO_INCREMENT&lt;/a&gt; counter will revert to &lt;code&gt;101&lt;/code&gt;, which is the persistent value set as part of the failed &lt;a href=&quot;../insert-ignore/index&quot;&gt;INSERT IGNORE&lt;/a&gt;.</source>
          <target state="translated">이 시점에서 서버가 다시 시작되면 &lt;a href=&quot;../auto_increment/index&quot;&gt;AUTO_INCREMENT&lt;/a&gt; 카운터는 &lt;code&gt;101&lt;/code&gt; 로 되돌아갑니다 . 이는 실패한 &lt;a href=&quot;../insert-ignore/index&quot;&gt;INSERT IGNORE의&lt;/a&gt; 일부로 설정된 지속적 값입니다 .</target>
        </trans-unit>
        <trans-unit id="14fa1dff75bbf99f497acceedeab1d81db3da6c2" translate="yes" xml:space="preserve">
          <source>If the server is running &lt;a href=&quot;../what-is-mariadb-101/index&quot;&gt;MariaDB 10.1&lt;/a&gt; or before or if it is running &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt; and the &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_safe_truncate&quot;&gt;innodb_safe_truncate&lt;/a&gt;&lt;/code&gt; system variable is set to &lt;code&gt;ON&lt;/code&gt;, then the renamed table will have a temporary table name in the format &lt;code&gt;&lt;code&gt;#&lt;/code&gt;sql-ib${TABLESPACE_ID}&lt;/code&gt;, where &lt;code&gt;${TABLESPACE_ID}&lt;/code&gt; is the table's tablespace ID within InnoDB. Therefore, the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#datadir&quot;&gt;datadir&lt;/a&gt;&lt;/code&gt; may contain files with file names like &lt;code&gt;&lt;code&gt;#&lt;/code&gt;sql-ib230291.ibd&lt;/code&gt;.</source>
          <target state="translated">서버가 실행중인 경우 &lt;a href=&quot;../what-is-mariadb-101/index&quot;&gt;MariaDB 10.1를&lt;/a&gt; 하기 전이나 실행중인 경우 또는 &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt; 과 &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_safe_truncate&quot;&gt;innodb_safe_truncate&lt;/a&gt;&lt;/code&gt; 시스템 변수로 설정되어 &lt;code&gt;ON&lt;/code&gt; , 다음 이름이 바뀐 테이블 형식으로 임시 테이블의 이름을 갖게됩니다 &lt;code&gt;&lt;code&gt;#&lt;/code&gt;sql-ib${TABLESPACE_ID}&lt;/code&gt; , &lt;code&gt;${TABLESPACE_ID}&lt;/code&gt; 는 InnoDB 내 테이블의 테이블 스페이스 ID입니다. 따라서 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#datadir&quot;&gt;datadir&lt;/a&gt;&lt;/code&gt; 에는 &lt;code&gt;&lt;code&gt;#&lt;/code&gt;sql-ib230291.ibd&lt;/code&gt; 와 같은 파일 이름을 가진 파일이 포함될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b9ec30b74604ccc5da35b7aef6c5d3deb66dc0fc" translate="yes" xml:space="preserve">
          <source>If the server is running, make sure you run a &lt;a href=&quot;../flush/index&quot;&gt;FLUSH TABLES&lt;/a&gt; statement first.</source>
          <target state="translated">서버가 실행중인 경우 &lt;a href=&quot;../flush/index&quot;&gt;FLUSH TABLES&lt;/a&gt; 문을 먼저 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="11b8438955db7e21e758fa2f6627c7663bcaebb3" translate="yes" xml:space="preserve">
          <source>If the server variable &lt;code&gt;log_warnings&lt;/code&gt; &amp;gt; 1 then you will get some information in the log about how the multi-master-info file is updated (mainly for debugging).</source>
          <target state="translated">서버 변수 &lt;code&gt;log_warnings&lt;/code&gt; &amp;gt; 1 인 경우 multi-master-info 파일이 업데이트되는 방법 (주로 디버깅 용)에 대한 일부 정보가 로그에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="95ad77d6f4a87a828cfbec01f611739f459d68f0" translate="yes" xml:space="preserve">
          <source>If the server was started with the &lt;code&gt;--skip-show-database&lt;/code&gt; option, you cannot use this statement at all unless you have the &lt;code&gt;&lt;a href=&quot;../grant/index&quot;&gt;SHOW DATABASES privilege&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">서버가 &lt;code&gt;--skip-show-database&lt;/code&gt; 옵션 으로 시작된 경우 &lt;code&gt;&lt;a href=&quot;../grant/index&quot;&gt;SHOW DATABASES privilege&lt;/a&gt;&lt;/code&gt; 이 없으면이 명령문을 전혀 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="a1150260ad9ded883beee3a92e41c924400d8e73" translate="yes" xml:space="preserve">
          <source>If the server's handshake packet contains a 20-byte scramble, then the client will default to the &lt;code&gt;&lt;a href=&quot;../authentication-plugin-mysql_native_password/index&quot;&gt;mysql_native_password&lt;/a&gt;&lt;/code&gt; authentication plugin.</source>
          <target state="translated">서버의 핸드 셰이크 패킷에 20 바이트 스크램블이 포함되어 있으면 클라이언트는 기본적으로 &lt;code&gt;&lt;a href=&quot;../authentication-plugin-mysql_native_password/index&quot;&gt;mysql_native_password&lt;/a&gt;&lt;/code&gt; 인증 플러그인을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="25b4e9483bcf9904da8028ef4acfa603872034b2" translate="yes" xml:space="preserve">
          <source>If the server's handshake packet contains a 9-byte scramble, then the client will default to the &lt;code&gt;&lt;a href=&quot;../authentication-plugin-mysql_old_password/index&quot;&gt;mysql_old_password&lt;/a&gt;&lt;/code&gt; authentication plugin.</source>
          <target state="translated">서버의 핸드 셰이크 패킷에 9 바이트 스크램블이 포함되어 있으면 클라이언트는 기본적으로 &lt;code&gt;&lt;a href=&quot;../authentication-plugin-mysql_old_password/index&quot;&gt;mysql_old_password&lt;/a&gt;&lt;/code&gt; 인증 플러그인을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b01d358c245a67d6865b5134fb7cc1c9076e1232" translate="yes" xml:space="preserve">
          <source>If the size of `Staging` changes depending on the busy versus idle times of the day, this pair of SQL statements has another comforting feature. The more rows in `Staging`, the more efficient the SQL runs, thereby helping compensate for the &quot;busy&quot; times.</source>
          <target state="translated">'스테이징'의 크기가 하루 중 사용량이 많은 시간과 유휴 시간에 따라 변경되면이 SQL 문 쌍에 또 다른 편안한 기능이 있습니다. 'Staging'에 행이 많을수록 SQL 실행이 더 효율적이므로 &quot;바쁜&quot;시간을 보상하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="8598f9313fc3d87057df092773723a2b2b60eec4" translate="yes" xml:space="preserve">
          <source>If the size of the temporary table is less than the tmp_table_size system variable, the table is a hash-indexed in-memory HEAP table. In the rare cases when the subquery result exceeds this limit, the temporary table is stored on disk in an ARIA or MyISAM B-tree indexed table (ARIA is the default).</source>
          <target state="translated">임시 테이블의 크기가 tmp_table_size 시스템 변수보다 작은 경우, 테이블은 해시 인덱스 인 메모리 HEAP 테이블입니다. 하위 쿼리 결과가이 제한을 초과하는 경우는 드물지만 임시 테이블은 디스크에 ARIA 또는 MyISAM B- 트리 인덱스 테이블 (ARIA가 기본값)에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="7a18412479418eea3371064d0b3f33791eff797e" translate="yes" xml:space="preserve">
          <source>If the slave has the &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-system-variables/index#log_slave_updates&quot;&gt;log_slave_updates&lt;/a&gt;&lt;/code&gt; system variable enabled and if the slave has the &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt; enabled, then every write by the &lt;a href=&quot;../replication-threads/index#slave-sql-thread&quot;&gt;slave's SQL thread&lt;/a&gt; will also go into the slave's &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt;. This means that &lt;a href=&quot;../gtid/index&quot;&gt;GTIDs&lt;/a&gt; of replicated transactions would be reflected in the value of the &lt;code&gt;&lt;a href=&quot;../gtid/index#gtid_binlog_pos&quot;&gt;gtid_binlog_pos&lt;/a&gt;&lt;/code&gt; system variable.</source>
          <target state="translated">슬레이브에 &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-system-variables/index#log_slave_updates&quot;&gt;log_slave_updates&lt;/a&gt;&lt;/code&gt; 시스템 변수가 활성화되어 있고 슬레이브에 &lt;a href=&quot;../binary-log/index&quot;&gt;이진 로그&lt;/a&gt; 가 활성화되어 있으면 &lt;a href=&quot;../replication-threads/index#slave-sql-thread&quot;&gt;슬레이브의 SQL 스레드에&lt;/a&gt; 의한 모든 쓰기 도 슬레이브의 &lt;a href=&quot;../binary-log/index&quot;&gt;이진 로그로 이동&lt;/a&gt; 합니다. 이 수단 &lt;a href=&quot;../gtid/index&quot;&gt;GTIDs&lt;/a&gt; 복제 거래의 값에 반영 될 &lt;code&gt;&lt;a href=&quot;../gtid/index#gtid_binlog_pos&quot;&gt;gtid_binlog_pos&lt;/a&gt;&lt;/code&gt; 의 시스템 변수.</target>
        </trans-unit>
        <trans-unit id="f408563151ebf4ed489348690ac81c0af99fd049" translate="yes" xml:space="preserve">
          <source>If the slave has the &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-system-variables/index#log_slave_updates&quot;&gt;log_slave_updates&lt;/a&gt;&lt;/code&gt; system variable enabled and if the slave has the &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt; enabled, then every write by the &lt;a href=&quot;index#slave-sql-thread&quot;&gt;slave's SQL thread&lt;/a&gt; will also go into the slave's &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt;. This means that &lt;a href=&quot;../gtid/index&quot;&gt;GTIDs&lt;/a&gt; of replicated transactions would be reflected in the value of the &lt;code&gt;&lt;a href=&quot;../gtid/index#gtid_binlog_pos&quot;&gt;gtid_binlog_pos&lt;/a&gt;&lt;/code&gt; system variable.</source>
          <target state="translated">슬레이브에 &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-system-variables/index#log_slave_updates&quot;&gt;log_slave_updates&lt;/a&gt;&lt;/code&gt; 시스템 변수가 활성화되어 있고 슬레이브에 &lt;a href=&quot;../binary-log/index&quot;&gt;이진 로그&lt;/a&gt; 가 활성화되어 있으면 &lt;a href=&quot;index#slave-sql-thread&quot;&gt;슬레이브의 SQL 스레드에&lt;/a&gt; 의한 모든 쓰기 도 슬레이브의 &lt;a href=&quot;../binary-log/index&quot;&gt;이진 로그로 이동&lt;/a&gt; 합니다. 이 수단 &lt;a href=&quot;../gtid/index&quot;&gt;GTIDs&lt;/a&gt; 복제 거래의 값에 반영 될 &lt;code&gt;&lt;a href=&quot;../gtid/index#gtid_binlog_pos&quot;&gt;gtid_binlog_pos&lt;/a&gt;&lt;/code&gt; 의 시스템 변수.</target>
        </trans-unit>
        <trans-unit id="3ff1381e29a777c89abd3b2949d47d149fa481fa" translate="yes" xml:space="preserve">
          <source>If the slave is replicating &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt; events that contain &lt;a href=&quot;../gtid/index&quot;&gt;GTIDs&lt;/a&gt;, then the &lt;a href=&quot;../replication-threads/index#slave-sql-thread&quot;&gt;slave's SQL thread&lt;/a&gt; will write every GTID that it applies to the &lt;code&gt;&lt;a href=&quot;../mysqlgtid_slave_pos-table/index&quot;&gt;mysql.gtid_slave_pos&lt;/a&gt;&lt;/code&gt; table. This GTID can be inspected and modified through the &lt;code&gt;&lt;a href=&quot;../gtid/index#gtid_slave_pos&quot;&gt;gtid_slave_pos&lt;/a&gt;&lt;/code&gt; system variable.</source>
          <target state="translated">슬레이브가 &lt;a href=&quot;../gtid/index&quot;&gt;GTIDs&lt;/a&gt; 가 포함 된 &lt;a href=&quot;../binary-log/index&quot;&gt;이진 로그&lt;/a&gt; 이벤트를 복제 하는 경우 &lt;a href=&quot;../replication-threads/index#slave-sql-thread&quot;&gt;슬레이브의 SQL 스레드&lt;/a&gt; 는 &lt;code&gt;&lt;a href=&quot;../mysqlgtid_slave_pos-table/index&quot;&gt;mysql.gtid_slave_pos&lt;/a&gt;&lt;/code&gt; 테이블에 적용되는 모든 GTID를 작성 합니다. 이 GTID는 &lt;code&gt;&lt;a href=&quot;../gtid/index#gtid_slave_pos&quot;&gt;gtid_slave_pos&lt;/a&gt;&lt;/code&gt; 시스템 변수를 통해 검사하고 수정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d9f819eb4855484f80e67c473fb4fb0050cb5ce4" translate="yes" xml:space="preserve">
          <source>If the slave is replicating &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt; events that contain &lt;a href=&quot;../gtid/index&quot;&gt;GTIDs&lt;/a&gt;, then the &lt;a href=&quot;index#slave-sql-thread&quot;&gt;slave's SQL thread&lt;/a&gt; will write every GTID that it applies to the &lt;code&gt;&lt;a href=&quot;../mysqlgtid_slave_pos-table/index&quot;&gt;mysql.gtid_slave_pos&lt;/a&gt;&lt;/code&gt; table. This GTID can be inspected and modified through the &lt;code&gt;&lt;a href=&quot;../gtid/index#gtid_slave_pos&quot;&gt;gtid_slave_pos&lt;/a&gt;&lt;/code&gt; system variable.</source>
          <target state="translated">슬레이브가 &lt;a href=&quot;../gtid/index&quot;&gt;GTIDs&lt;/a&gt; 가 포함 된 &lt;a href=&quot;../binary-log/index&quot;&gt;이진 로그&lt;/a&gt; 이벤트를 복제 하는 경우 &lt;a href=&quot;index#slave-sql-thread&quot;&gt;슬레이브의 SQL 스레드&lt;/a&gt; 는 &lt;code&gt;&lt;a href=&quot;../mysqlgtid_slave_pos-table/index&quot;&gt;mysql.gtid_slave_pos&lt;/a&gt;&lt;/code&gt; 테이블에 적용되는 모든 GTID를 작성 합니다. 이 GTID는 &lt;code&gt;&lt;a href=&quot;../gtid/index#gtid_slave_pos&quot;&gt;gtid_slave_pos&lt;/a&gt;&lt;/code&gt; 시스템 변수를 통해 검사하고 수정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="967631f0e1cb7ad7aeb67b855f0f5d5910e75e1b" translate="yes" xml:space="preserve">
          <source>If the slave is replicating normally, then the next step would be to &lt;a href=&quot;../starting-and-stopping-mariadb-starting-and-stopping-mariadb/index&quot;&gt;start the MariaDB Server process&lt;/a&gt; on the other nodes in the second cluster.</source>
          <target state="translated">슬레이브가 정상적으로 복제하는 경우 다음 단계는 두 번째 클러스터의 다른 노드에서 &lt;a href=&quot;../starting-and-stopping-mariadb-starting-and-stopping-mariadb/index&quot;&gt;MariaDB 서버 프로세스&lt;/a&gt; 를 시작하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="8f634f8e7c37201840ff399aade01bad246570d7" translate="yes" xml:space="preserve">
          <source>If the slave tries to connect starting at a GTID that is missing in the master's binlog, this is an error in GTID strict mode even if a GTID exists with a higher sequence number (this indicates a GTID on the slave missing on the master). Note that this error is controlled by the setting of GTID strict mode on the connecting slave server.</source>
          <target state="translated">슬레이브가 마스터의 binlog에없는 GTID에서 시작하여 연결을 시도하면, GTID가 더 높은 시퀀스 번호를 가지고 있어도 GTID 엄격 모드에서 오류가 발생합니다 (이는 마스터에서 누락 된 슬레이브의 GTID를 나타냄). 이 에러는 연결 슬레이브 서버에서 GTID 엄격 모드의 설정에 의해 제어됩니다.</target>
        </trans-unit>
        <trans-unit id="d89e5251548558d5ad5e04ee60f0127889f85569" translate="yes" xml:space="preserve">
          <source>If the source database server is a &lt;a href=&quot;../high-availability-performance-tuning-mariadb-replication/index&quot;&gt;replication slave&lt;/a&gt; of the desired replication master, then we should add the &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-slave-info&quot;&gt;--slave-info&lt;/a&gt;&lt;/code&gt; option, and possibly the &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-safe-slave-backup&quot;&gt;--safe-slave-backup&lt;/a&gt;&lt;/code&gt; option. For example:</source>
          <target state="translated">소스 데이터베이스 서버가 원하는 복제 마스터 의 &lt;a href=&quot;../high-availability-performance-tuning-mariadb-replication/index&quot;&gt;복제 슬레이브&lt;/a&gt; 인 경우 &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-slave-info&quot;&gt;--slave-info&lt;/a&gt;&lt;/code&gt; 옵션과 &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-safe-slave-backup&quot;&gt;--safe-slave-backup&lt;/a&gt;&lt;/code&gt; 옵션을 추가해야합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d58f01a699ed61a4fecfe1e13421d2f31c91dfec" translate="yes" xml:space="preserve">
          <source>If the specific authentication plugin uses the &lt;code&gt;authentication_string&lt;/code&gt; column, then this value for the account can be specified after a &lt;code&gt;USING&lt;/code&gt; or &lt;code&gt;AS&lt;/code&gt; keyword. For example, the &lt;a href=&quot;../authentication-plugin-pam/index&quot;&gt;PAM authentication plugin&lt;/a&gt; accepts a &lt;a href=&quot;../authentication-plugin-pam/index#configuring-the-pam-service&quot;&gt;service name&lt;/a&gt; that would go into the &lt;code&gt;authentication_string&lt;/code&gt; column for the account:</source>
          <target state="translated">특정 인증 플러그인이 &lt;code&gt;authentication_string&lt;/code&gt; 열을 사용하는 경우 계정에 대한이 값은 &lt;code&gt;USING&lt;/code&gt; 또는 &lt;code&gt;AS&lt;/code&gt; 키워드 뒤에 지정할 수 있습니다 . 예를 들어, &lt;a href=&quot;../authentication-plugin-pam/index&quot;&gt;PAM 인증 플러그인&lt;/a&gt; 은 계정 의 &lt;code&gt;authentication_string&lt;/code&gt; 열로 이동할 &lt;a href=&quot;../authentication-plugin-pam/index#configuring-the-pam-service&quot;&gt;서비스 이름&lt;/a&gt; 을 허용 합니다.</target>
        </trans-unit>
        <trans-unit id="e3ff5d6f779dc67f436644e59615fd635f0cf3fc" translate="yes" xml:space="preserve">
          <source>If the specified file does not exist, it is created when data is inserted into the table. If a &lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt; is issued before the file is created, the following error is produced:</source>
          <target state="translated">지정된 파일이 존재하지 않으면 데이터가 테이블에 삽입 될 때 작성됩니다. 경우 &lt;a href=&quot;../select/index&quot;&gt;SELECT가&lt;/a&gt; 파일이 생성되기 전에 발행, 다음과 같은 오류가 생성됩니다</target>
        </trans-unit>
        <trans-unit id="94f2d7e3bbc853c1cde026eebee045e7003a7cee" translate="yes" xml:space="preserve">
          <source>If the specified flag is already ON, the above example has no effect but does not produce an error.</source>
          <target state="translated">지정된 플래그가 이미 ON 인 경우 위 예제는 적용되지 않지만 오류는 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="90177af136b7ef336e8a95a5cd7f6cd858489547" translate="yes" xml:space="preserve">
          <source>If the specified statement has not been PREPAREd, an error similar to the following is produced:</source>
          <target state="translated">지정된 명령문이 PREPAREd가 아닌 경우 다음과 유사한 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="979e7b43a7a608ebd1b2bdc5c76a7265af37fdc2" translate="yes" xml:space="preserve">
          <source>If the specified statement has not been PREPAREd, an error similar to the following will be produced:</source>
          <target state="translated">지정된 명령문이 PREPAREd가 아닌 경우 다음과 유사한 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1d521f48e235661ffbc0fa600c5c6a7e3fae17cd" translate="yes" xml:space="preserve">
          <source>If the stopword list is changed, any existing full-text indexes need to be rebuilt</source>
          <target state="translated">중지 단어 목록이 변경되면 기존 전체 텍스트 인덱스를 다시 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="a6b82e6e2b89d7eadfb28246f532b07b76b3baf2" translate="yes" xml:space="preserve">
          <source>If the syntax for a given &lt;code&gt;SHOW&lt;/code&gt; statement includes a &lt;code&gt;LIKE 'pattern'&lt;/code&gt; part, &lt;code&gt;'pattern'&lt;/code&gt; is a string that can contain the SQL &quot;&lt;code&gt;%&lt;/code&gt;&quot; and &quot;&lt;code&gt;_&lt;/code&gt;&quot; wildcard characters. The pattern is useful for restricting statement output to matching values.</source>
          <target state="translated">주어진 &lt;code&gt;SHOW&lt;/code&gt; 문의 구문에 &lt;code&gt;LIKE 'pattern'&lt;/code&gt; 부분이 포함 된 경우 &lt;code&gt;'pattern'&lt;/code&gt; 은 SQL &quot; &lt;code&gt;%&lt;/code&gt; &quot;및 &quot; &lt;code&gt;_&lt;/code&gt; &quot;와일드 카드 문자를 포함 할 수있는 문자열입니다 . 이 패턴은 명령문 출력을 일치하는 값으로 제한하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="db2697d100130db7a3dfa5991c035854b3e6f1aa" translate="yes" xml:space="preserve">
          <source>If the system ever gets into DBRM Read-Only Mode, its best resolved by do a restart system form the 'pm1' module:</source>
          <target state="translated">시스템이 DBRM 읽기 전용 모드에 도달하면 'pm1'모듈에서 시스템을 다시 시작하여 가장 잘 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="dbb7ed5229843b287787ac9e19e438f6e5c4185f" translate="yes" xml:space="preserve">
          <source>If the system is unable to generate sequence numbers because that will not fit into the destination datatype (e.g. if the autoincrement column is a TINYINT datatype and you attempt to insert more than about 127 rows), the statement or job will fail. At this point you must either reset the autoincrement settings or drop the autoincrement column and add a new autoincrement column with a wider datatype.</source>
          <target state="translated">대상 데이터 유형에 맞지 않아서 시스템이 시퀀스 번호를 생성 할 수없는 경우 (예 : 자동 증가 열이 TINYINT 데이터 유형이고 약 127 개가 넘는 행을 삽입하려고하면) 명령문 또는 작업이 실패합니다. 이 시점에서 자동 증분 설정을 재설정하거나 자동 증분 열을 삭제하고 데이터 유형이 더 넓은 새 자동 증분 열을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="c58d3a14e7ba3827f2482cbfdd5a139ffc39e5d7" translate="yes" xml:space="preserve">
          <source>If the table already exists, an error similar to the following will be returned:</source>
          <target state="translated">테이블이 이미 존재하면 다음과 유사한 오류가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="972ef9891a69bc4a2980931d7dbd21c77f879eed" translate="yes" xml:space="preserve">
          <source>If the table contains a hidden &lt;code&gt;FTS_DOC_ID&lt;/code&gt; column due to a &lt;a href=&quot;../full-text-indexes/index&quot;&gt;FULLTEXT INDEX&lt;/a&gt;, then instant &lt;code&gt;&lt;a href=&quot;../alter-table/index#add-column&quot;&gt;ALTER TABLE ... ADD COLUMN&lt;/a&gt;&lt;/code&gt; will not be possible.</source>
          <target state="translated">&lt;a href=&quot;../full-text-indexes/index&quot;&gt;FULLTEXT INDEX&lt;/a&gt; 로 인해 테이블에 숨겨진 &lt;code&gt;FTS_DOC_ID&lt;/code&gt; 열이 있으면 인스턴트 &lt;code&gt;&lt;a href=&quot;../alter-table/index#add-column&quot;&gt;ALTER TABLE ... ADD COLUMN&lt;/a&gt;&lt;/code&gt; 을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7ee6ee4872b07a5513cc54e2b1a09e7bbf5a6d92" translate="yes" xml:space="preserve">
          <source>If the table has an &lt;code&gt;&lt;a href=&quot;../auto_increment/index&quot;&gt;AUTO_INCREMENT&lt;/a&gt;&lt;/code&gt; primary key and the statement inserts or updates a row, the &lt;code&gt;&lt;a href=&quot;../last_insert_id/index&quot;&gt;LAST_INSERT_ID()&lt;/a&gt;&lt;/code&gt; function returns its AUTO_INCREMENT value.</source>
          <target state="translated">테이블에 &lt;code&gt;&lt;a href=&quot;../auto_increment/index&quot;&gt;AUTO_INCREMENT&lt;/a&gt;&lt;/code&gt; 기본 키가 있고 명령문이 행을 삽입하거나 업데이트하는 경우 &lt;code&gt;&lt;a href=&quot;../last_insert_id/index&quot;&gt;LAST_INSERT_ID()&lt;/a&gt;&lt;/code&gt; 함수는 AUTO_INCREMENT 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="5dd1df1096d343287aa3b9a5bd7d7b6e1031b35c" translate="yes" xml:space="preserve">
          <source>If the table is a &lt;a href=&quot;../sequences/index&quot;&gt;sequence&lt;/a&gt;, then it will have the &lt;code&gt;SEQUENCE&lt;/code&gt; set to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">테이블이 &lt;a href=&quot;../sequences/index&quot;&gt;시퀀스&lt;/a&gt; 이면 &lt;code&gt;SEQUENCE&lt;/code&gt; 가로 설정됩니다. &lt;code&gt;1&lt;/code&gt; 로 .</target>
        </trans-unit>
        <trans-unit id="1396f0c4b3d6e63c33edbd2541571917557c7b9b" translate="yes" xml:space="preserve">
          <source>If the table is already using the &lt;code&gt;&lt;a href=&quot;../innodb-dynamic-row-format/index&quot;&gt;DYNAMIC&lt;/a&gt;&lt;/code&gt; row format, then another potential solution to this problem is to change the table schema, so that the row format can store more columns on overflow pages.</source>
          <target state="translated">테이블이 이미 사용중인 경우 &lt;code&gt;&lt;a href=&quot;../innodb-dynamic-row-format/index&quot;&gt;DYNAMIC&lt;/a&gt;&lt;/code&gt; 행 형식을경우이 문제점에 대한 또 다른 해결책은 테이블 스키마를 변경하여 행 형식이 오버 플로우 페이지에 더 많은 열을 저장할 수 있도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ac99f07d8b45a57d14a8cee81c25eecda09f837b" translate="yes" xml:space="preserve">
          <source>If the table is created on several zip files, it is specified as for all other multiple tables:</source>
          <target state="translated">테이블이 여러 zip 파일에 작성되면 다른 모든 여러 테이블에 대해 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="0d2d88db551d38ff4cad647c22ea4e304d6171ab" translate="yes" xml:space="preserve">
          <source>If the table is in a &lt;a href=&quot;../innodb-file-per-table-tablespaces/index&quot;&gt;file-per-table&lt;/a&gt; tablespace, and if &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encrypt_tables&quot;&gt;innodb_encrypt_tables&lt;/a&gt;&lt;/code&gt; is set to &lt;code&gt;ON&lt;/code&gt; or &lt;code&gt;FORCE&lt;/code&gt;, and if &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encryption_threads&quot;&gt;innodb_encryption_threads&lt;/a&gt;&lt;/code&gt; is set to a value greater than &lt;code&gt;0&lt;/code&gt;, then you can also set the specific encryption key for the table by using the &lt;code&gt;&lt;a href=&quot;../create-table/index#encryption_key_id&quot;&gt;ENCRYPTION_KEY_ID&lt;/a&gt;&lt;/code&gt; table option. For example:</source>
          <target state="translated">테이블이있는 경우 &lt;a href=&quot;../innodb-file-per-table-tablespaces/index&quot;&gt;파일 당 테이블&lt;/a&gt; 테이블, 그리고 경우 &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encrypt_tables&quot;&gt;innodb_encrypt_tables&lt;/a&gt;&lt;/code&gt; 이 설정되어 &lt;code&gt;ON&lt;/code&gt; 또는 &lt;code&gt;FORCE&lt;/code&gt; , 그리고 경우 &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encryption_threads&quot;&gt;innodb_encryption_threads&lt;/a&gt;&lt;/code&gt; 이 값 이상으로 설정 &lt;code&gt;0&lt;/code&gt; , 당신은 또한을 사용하여 테이블의 특정 암호화 키를 설정할 수 있습니다 &lt;code&gt;&lt;a href=&quot;../create-table/index#encryption_key_id&quot;&gt;ENCRYPTION_KEY_ID&lt;/a&gt;&lt;/code&gt; 테이블 옵션. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1d7d2461674d4b01018f5ee4ba5a948143b75432" translate="yes" xml:space="preserve">
          <source>If the table is made from several files such as emp01.csv, emp02.csv, etc., the standard create table would be:</source>
          <target state="translated">테이블이 emp01.csv, emp02.csv 등과 같은 여러 파일로 작성된 경우 표준 작성 테이블은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c715a545782b9ea37521a7f1027c3ffb422570e9" translate="yes" xml:space="preserve">
          <source>If the table is using either the &lt;code&gt;&lt;a href=&quot;../innodb-redundant-row-format/index&quot;&gt;REDUNDANT&lt;/a&gt;&lt;/code&gt; or the &lt;code&gt;&lt;a href=&quot;../innodb-compact-row-format/index&quot;&gt;COMPACT&lt;/a&gt;&lt;/code&gt; row format, then one potential solution to this problem is to convert the table to use the &lt;code&gt;&lt;a href=&quot;../innodb-dynamic-row-format/index&quot;&gt;DYNAMIC&lt;/a&gt;&lt;/code&gt; row format instead.</source>
          <target state="translated">테이블이 &lt;code&gt;&lt;a href=&quot;../innodb-redundant-row-format/index&quot;&gt;REDUNDANT&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../innodb-compact-row-format/index&quot;&gt;COMPACT&lt;/a&gt;&lt;/code&gt; 행 형식을 사용하는 경우이 문제에 대한 한 가지 가능한 해결책은 테이블을 대신 &lt;code&gt;&lt;a href=&quot;../innodb-dynamic-row-format/index&quot;&gt;DYNAMIC&lt;/a&gt;&lt;/code&gt; 행 형식 을 사용하도록 변환하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="4b8f93ff77fd45d0fcca01831211241e9ddf1a69" translate="yes" xml:space="preserve">
          <source>If the table name pattern for a filter is just specified as &lt;code&gt;%&lt;/code&gt;, then all tables in the database will be matched. In this case, the filter will also affect certain database-level statements, such as &lt;code&gt;&lt;a href=&quot;../create-database/index&quot;&gt;CREATE DATABASE&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../alter-database/index&quot;&gt;ALTER DATABASE&lt;/a&gt;&lt;/code&gt; and &lt;a href=&quot;../drop-database/index&quot;&gt;DROP DATABASE&lt;/a&gt;&lt;code&gt;.&lt;/code&gt;</source>
          <target state="translated">필터의 테이블 이름 패턴이 &lt;code&gt;%&lt;/code&gt; 로만 지정된 경우 데이터베이스의 모든 테이블이 일치합니다. 이 경우 필터는 &lt;code&gt;&lt;a href=&quot;../create-database/index&quot;&gt;CREATE DATABASE&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../alter-database/index&quot;&gt;ALTER DATABASE&lt;/a&gt;&lt;/code&gt; 및 &lt;a href=&quot;../drop-database/index&quot;&gt;DROP DATABASE&lt;/a&gt; 와 같은 특정 데이터베이스 레벨 명령문에도 영향을줍니다 &lt;code&gt;.&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="32a40b3c2d7990fe5f48f697d11c268d546bf007" translate="yes" xml:space="preserve">
          <source>If the table was initially void, further inserts will populate it according to the partition function. However, if the files did exist and contained data, this is your responsibility to determine what partition function actually matches the data distribution in them. This means in particular that partitioning by key or by hash cannot be used (except in exceptional cases) because you have almost no control over what the used algorithm does.</source>
          <target state="translated">테이블이 처음에 공백 인 경우 추가 삽입은 파티션 기능에 따라 테이블을 채 웁니다. 그러나 파일이 존재하고 데이터를 포함하는 경우, 실제로 어떤 파티션 함수가 데이터 분배와 일치하는지 판별하는 것은 사용자의 책임입니다. 이는 특히 사용 된 알고리즘의 기능을 거의 제어 할 수 없기 때문에 키 또는 해시별로 분할 할 수 없습니다 (예외의 경우 제외).</target>
        </trans-unit>
        <trans-unit id="527daae466537b2804f13142f4eecee602eb37b6" translate="yes" xml:space="preserve">
          <source>If the table were using the &lt;code&gt;REDUNDANT&lt;/code&gt; or &lt;code&gt;COMPACT&lt;/code&gt; row formats, then the error or warning would be the following:</source>
          <target state="translated">테이블이 &lt;code&gt;REDUNDANT&lt;/code&gt; 또는 &lt;code&gt;COMPACT&lt;/code&gt; 를 사용중인 경우 행 형식을 사용하는 경우 오류 또는 경고는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2a4be7f58b3f63927d93c28bffa72aa7b5467684" translate="yes" xml:space="preserve">
          <source>If the thread group already has active &lt;strong&gt;worker threads&lt;/strong&gt;, then the following condition also needs to be met:</source>
          <target state="translated">스레드 그룹에 이미 활성 &lt;strong&gt;작업자 스레드가있는 경우&lt;/strong&gt; 있는 경우 다음 조건도 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="6d2adf708460cb886775671622c5967918db91f5" translate="yes" xml:space="preserve">
          <source>If the time zone tables in the &lt;code&gt;&lt;a href=&quot;../the-mysql-database-tables/index&quot;&gt;mysql&lt;/a&gt;&lt;/code&gt; database were loaded, then a named time zone, such as &lt;code&gt;America/New_York&lt;/code&gt;, &lt;code&gt;Africa/Johannesburg&lt;/code&gt;, or &lt;code&gt;Europe/Helsinki&lt;/code&gt;, is also permissible. See &lt;a href=&quot;#mysql-time-zone-tables&quot;&gt;mysql Time Zone Tables&lt;/a&gt; below for more information.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../the-mysql-database-tables/index&quot;&gt;mysql&lt;/a&gt;&lt;/code&gt; 데이터베이스의 시간대 테이블 이로드 된 경우 &lt;code&gt;America/New_York&lt;/code&gt; , &lt;code&gt;Africa/Johannesburg&lt;/code&gt; 또는 &lt;code&gt;Europe/Helsinki&lt;/code&gt; 와 같은 명명 된 시간대 도 허용됩니다. &lt;a href=&quot;#mysql-time-zone-tables&quot;&gt;mysql 시간대 테이블을&lt;/a&gt; 참조하십시오 아래의 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8405d3030f141659b6bc8c1340b869084517f52f" translate="yes" xml:space="preserve">
          <source>If the trigger only reads from the other table, that table will be read locked. If the trigger writes to the other table, it will be write locked. If a table is read-locked for reading via &lt;code&gt;LOCK TABLES&lt;/code&gt;, but needs to be write-locked because it could be modified by a trigger, a write lock is taken.</source>
          <target state="translated">트리거가 다른 테이블에서 읽기만하는 경우 해당 테이블을 읽은 상태로 읽습니다. 트리거가 다른 테이블에 쓰면 쓰기가 잠 깁니다. &lt;code&gt;LOCK TABLES&lt;/code&gt; 를 통해 읽기 위해 테이블이 읽기 잠금 상태 인 경우 이지만 트리거에 의해 수정 될 수 있으므로 쓰기 잠금이 필요한 경우 쓰기 잠금이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="65c7204aa81ef2ccbcd4e7b652a42bd1b6d6d9f2" translate="yes" xml:space="preserve">
          <source>If the user account already exists and if you provide the &lt;code&gt;IDENTIFIED BY&lt;/code&gt; clause, then the user's password will be changed. You must have the privileges needed for the &lt;code&gt;&lt;a href=&quot;../set-password/index&quot;&gt;SET PASSWORD&lt;/a&gt;&lt;/code&gt; statement to change a user's password with &lt;code&gt;GRANT&lt;/code&gt;.</source>
          <target state="translated">사용자 계정이 이미 존재하고 &lt;code&gt;IDENTIFIED BY&lt;/code&gt; 절 을 제공 하면 사용자의 비밀번호가 변경됩니다. &lt;code&gt;GRANT&lt;/code&gt; 를 사용하여 사용자 비밀번호를 변경 하려면 &lt;code&gt;&lt;a href=&quot;../set-password/index&quot;&gt;SET PASSWORD&lt;/a&gt;&lt;/code&gt; 문에 필요한 권한이 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="6d1cbfdbf6de85e1c94fb69808849015fd4e7e4f" translate="yes" xml:space="preserve">
          <source>If the user neither has privilege to the routine nor the &lt;code&gt;&lt;a href=&quot;../grant/index&quot;&gt;SELECT&lt;/a&gt;&lt;/code&gt; privilege on &lt;code&gt;&lt;a href=&quot;../mysqlproc-table/index&quot;&gt;mysql.proc&lt;/a&gt;&lt;/code&gt; table, it raises Error 1305, informing them that the procedure does not exist.</source>
          <target state="translated">사용자에게 루틴에 대한 권한 이나 &lt;code&gt;&lt;a href=&quot;../mysqlproc-table/index&quot;&gt;mysql.proc&lt;/a&gt;&lt;/code&gt; 테이블 에 대한 &lt;code&gt;&lt;a href=&quot;../grant/index&quot;&gt;SELECT&lt;/a&gt;&lt;/code&gt; 권한 이 없으면 프로 시저가 존재하지 않음을 알리는 오류 1305가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3702e1e3037cb1536a474efb8ddec55421523e82" translate="yes" xml:space="preserve">
          <source>If the user skips a &lt;code&gt;BACKUP STAGE&lt;/code&gt;, then all intermediate backup stages will automatically be run. This will allow us to add new stages within the &lt;code&gt;BACKUP STAGE&lt;/code&gt; hierarchy in the future with even more precise locks without causing problems for tools using an earlier version of the &lt;code&gt;BACKUP STAGE&lt;/code&gt; implementation.</source>
          <target state="translated">사용자가 &lt;code&gt;BACKUP STAGE&lt;/code&gt; 를 건너 뛰면 모든 중간 백업 단계가 자동으로 실행됩니다. 이를 통해 우리 는 &lt;code&gt;BACKUP STAGE&lt;/code&gt; 구현 의 이전 버전을 사용하는 도구에 문제를 일으키지 않으면 서 훨씬 더 정확한 잠금으로 향후 &lt;code&gt;BACKUP STAGE&lt;/code&gt; 계층 구조 내에 새로운 단계를 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="af35c9740b028ef3883b49bd806a28f66b013f9e" translate="yes" xml:space="preserve">
          <source>If the user specifies &lt;code&gt;COPY&lt;/code&gt;, then InnoDB uses the &lt;code&gt;COPY&lt;/code&gt; algorithm.</source>
          <target state="translated">사용자가 &lt;code&gt;COPY&lt;/code&gt; 를 지정하면 InnoDB는 &lt;code&gt;COPY&lt;/code&gt; 알고리즘을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="91cab0ecf400f2d7c12d492e85622feb1832bee8" translate="yes" xml:space="preserve">
          <source>If the user specifies &lt;code&gt;DEFAULT&lt;/code&gt;, then InnoDB uses its default choice for the operation. The default choice is to use the most efficient algorithm supported by the operation. The default choice will also be used if no algorithm is specified. Therefore, if you want InnoDB to use the most efficient algorithm supported by an operation, then you usually do not have to explicitly specify any algorithm at all.</source>
          <target state="translated">사용자가 &lt;code&gt;DEFAULT&lt;/code&gt; 를 지정한 경우 InnoDB는 작업에 기본 선택을 사용합니다. 기본 선택은 조작에서 지원하는 가장 효율적인 알고리즘을 사용하는 것입니다. 알고리즘을 지정하지 않으면 기본 선택도 사용됩니다. 따라서 InnoDB가 작업에서 지원하는 가장 효율적인 알고리즘을 사용하도록하려면 일반적으로 알고리즘을 명시 적으로 지정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="03584866694981354af4d41246390cd7b194e5ad" translate="yes" xml:space="preserve">
          <source>If the user specifies any other algorithm, then InnoDB interprets that choice as the &lt;em&gt;least efficient&lt;/em&gt; algorithm that the user is willing to accept. This means that if the user specifies &lt;code&gt;INPLACE&lt;/code&gt;, then InnoDB will use the &lt;em&gt;most efficient&lt;/em&gt; algorithm supported by the specific operation from the set (&lt;code&gt;INPLACE&lt;/code&gt;, &lt;code&gt;NOCOPY&lt;/code&gt;, &lt;code&gt;INSTANT&lt;/code&gt;). Likewise, if the user specifies &lt;code&gt;NOCOPY&lt;/code&gt;, then InnoDB will use the &lt;em&gt;most efficient&lt;/em&gt; algorithm supported by the specific operation from the set (&lt;code&gt;NOCOPY&lt;/code&gt;, &lt;code&gt;INSTANT&lt;/code&gt;).</source>
          <target state="translated">사용자가 다른 알고리즘을 지정하면 InnoDB는 해당 선택을 사용자가 수락 할 &lt;em&gt;가장 효율적인&lt;/em&gt; 알고리즘 으로 해석합니다 . 즉, 사용자가 &lt;code&gt;INPLACE&lt;/code&gt; 를 지정하면 InnoDB는 세트의 특정 작업 ( &lt;code&gt;INPLACE&lt;/code&gt; , &lt;code&gt;NOCOPY&lt;/code&gt; , &lt;code&gt;INSTANT&lt;/code&gt; ) 에서 지원 하는 &lt;em&gt;가장 효율적인&lt;/em&gt; 알고리즘을 사용합니다 . 마찬가지로 사용자가 &lt;code&gt;NOCOPY&lt;/code&gt; 를 지정하면 InnoDB는 세트 ( &lt;code&gt;NOCOPY&lt;/code&gt; , &lt;code&gt;INSTANT&lt;/code&gt; ) 의 특정 작업에서 지원 하는 &lt;em&gt;가장 효율적인&lt;/em&gt; 알고리즘을 사용합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2d5504f8cfb9aaac4ba9344bd65f1d5883226ca9" translate="yes" xml:space="preserve">
          <source>If the user wants to run huge joins that touch a big fraction of table's data, for example:</source>
          <target state="translated">사용자가 테이블 데이터의 큰 부분을 터치하는 큰 조인을 실행하려는 경우 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6429ca9c1553f56f0d32680202faeeb6e762ca6f" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;DISABLED&lt;/code&gt;, then the server supports TLS, but TLS is &lt;strong&gt;not&lt;/strong&gt; enabled.</source>
          <target state="translated">값이 &lt;code&gt;DISABLED&lt;/code&gt; 인 경우 서버는 TLS를 지원하지만 TLS는 사용할 수 &lt;strong&gt;없습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="1c2fba8a5e165006c8f53da39f9eeb2efbe000d3" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;NO&lt;/code&gt;, then the server was not compiled with TLS support, so TLS cannot be enabled.</source>
          <target state="translated">값이 &lt;code&gt;NO&lt;/code&gt; 인 경우 서버는 TLS 지원으로 컴파일되지 않았으므로 TLS를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="835bd82fe6ca9290f5bb512e06735977a00f3f63" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;YES&lt;/code&gt;, then the server supports TLS, and TLS is enabled.</source>
          <target state="translated">값이 &lt;code&gt;YES&lt;/code&gt; 이면 서버는 TLS를 지원하고 TLS가 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="32f434e8ba7407f7e231a08983a1808e75d37cb8" translate="yes" xml:space="preserve">
          <source>If the value is set to 8 no block-based algorithm can be used for a join operation. The values from 1 to 8 correspond to the following variants of block-based join algorithms :</source>
          <target state="translated">값이 8로 설정되면 결합 조작에 블록 기반 알고리즘을 사용할 수 없습니다. 1에서 8까지의 값은 다음 블록 기반 결합 알고리즘 변형에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="5bf22c6e796e9588085ffb455189f637906f5f2b" translate="yes" xml:space="preserve">
          <source>If the value of &lt;a href=&quot;../server-system-variables/index#join_cache_level&quot;&gt;join_cache_level&lt;/a&gt; is set to N, any of block-based algorithms with the level greater than N is disallowed.</source>
          <target state="translated">&lt;a href=&quot;../server-system-variables/index#join_cache_level&quot;&gt;join_cache_level&lt;/a&gt; 의 값 을 N으로 설정하면 N보다 큰 레벨의 블록 기반 알고리즘은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e1ce3fe194b6acb71cb0db002a80475ce3ab9834" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#plugin_dir&quot;&gt;plugin_dir&lt;/a&gt;&lt;/code&gt; is a relative path name, it is taken to be relative to the MySQL base directory (the value of the &lt;code&gt;basedir&lt;/code&gt; system variable).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../server-system-variables/index#plugin_dir&quot;&gt;plugin_dir&lt;/a&gt;&lt;/code&gt; 의 값이 상대 경로 이름 인 경우 MySQL 기본 디렉토리 ( &lt;code&gt;basedir&lt;/code&gt; 시스템 변수의 값)를 기준으로합니다.</target>
        </trans-unit>
        <trans-unit id="20e0c6af4a720b15570c67d22420ce4255cbb550" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#plugin_dir&quot;&gt;plugin_dir&lt;/a&gt;&lt;/code&gt; is a relative path name, it is taken to be relative to the MySQL base directory (the value of the basedir system variable).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../server-system-variables/index#plugin_dir&quot;&gt;plugin_dir&lt;/a&gt;&lt;/code&gt; 의 값이 상대 경로 이름 인 경우 MySQL 기본 디렉토리 (basedir 시스템 변수의 값)를 기준으로합니다.</target>
        </trans-unit>
        <trans-unit id="8b11b343a1475e89d7bf68468f13de5028f36c27" translate="yes" xml:space="preserve">
          <source>If the variable has a session value, not specifying either GLOBAL or SESSION will be the same as specifying SESSION. If the variable only has a global value, not specifying GLOBAL or SESSION will apply to the change to the global value.</source>
          <target state="translated">변수에 세션 값이있는 경우 GLOBAL 또는 SESSION을 지정하지 않으면 SESSION을 지정하는 것과 같습니다. 변수에 전역 값만있는 경우 GLOBAL 또는 SESSION을 지정하지 않으면 전역 값 변경에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="1a6ebb2ebd1eaaa44d9e8f21deb43a9206aead47" translate="yes" xml:space="preserve">
          <source>If the wait completes without a timeout, 0 is returned. Passing NULL for the gtid-list makes the function return NULL immediately, without waiting.</source>
          <target state="translated">시간 초과없이 대기가 완료되면 0이 반환됩니다. gtid-list에 NULL을 전달하면 함수는 기다리지 않고 즉시 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c344fceb544b952d30953bcbdded5fa6b6478516" translate="yes" xml:space="preserve">
          <source>If there are &lt;code&gt;DELETE&lt;/code&gt; or &lt;code&gt;INSERT&lt;/code&gt; triggers, it works as following: any matched row is deleted, and then one or two rows are inserted. If the record is deleted completely, nothing is inserted.</source>
          <target state="translated">&lt;code&gt;DELETE&lt;/code&gt; 또는 &lt;code&gt;INSERT&lt;/code&gt; 트리거 가 있으면 다음과 같이 작동합니다. 일치하는 행이 삭제 된 후 하나 또는 두 개의 행이 삽입됩니다. 레코드가 완전히 삭제되면 아무것도 삽입되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a17ceeca2d3d7261b0b6a79ca415da8ef3e0bb51" translate="yes" xml:space="preserve">
          <source>If there are big gaps in `id` values (and there will after the first purge), then</source>
          <target state="translated">'id'값에 큰 차이가 있고 첫 번째 제거 이후에 ​​차이가있는 경우</target>
        </trans-unit>
        <trans-unit id="cabe10109f2ad1a19ca17f17dab5ae3601668701" translate="yes" xml:space="preserve">
          <source>If there are foreign keys, &lt;code&gt;ON DELETE&lt;/code&gt; action will be activated by &lt;code&gt;REPLACE&lt;/code&gt;.</source>
          <target state="translated">외래 키가 있으면 &lt;code&gt;REPLACE&lt;/code&gt; 에 의해 &lt;code&gt;ON DELETE&lt;/code&gt; 작업이 활성화됩니다 .</target>
        </trans-unit>
        <trans-unit id="c646d9399e38c1d7e942efc1c0522a42b5ed4e8f" translate="yes" xml:space="preserve">
          <source>If there are millions of rows in the table, this statement may take minutes, maybe hours.</source>
          <target state="translated">테이블에 수백만 행이있는 경우이 명령문은 몇 분, 몇 시간이 걸릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19c42c6663ff3cf0ca3f74b4cc2f54807c336aa0" translate="yes" xml:space="preserve">
          <source>If there are more closed parentheses than open parentheses, the error usually looks like this:</source>
          <target state="translated">열린 괄호보다 닫힌 괄호가 더 많으면 일반적으로 오류는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="89533adcd340d46a72bb682a248bf0f930d6a487" translate="yes" xml:space="preserve">
          <source>If there are more open parentheses than closed parentheses, the error usually looks like this:</source>
          <target state="translated">닫힌 괄호보다 열린 괄호가 더 많으면 일반적으로 오류는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8d428d5c5bf9fde1370adb2325df66d7287deb81" translate="yes" xml:space="preserve">
          <source>If there are more parts to the WHERE clause, you must stop now.</source>
          <target state="translated">WHERE 절에 더 많은 파트가 있으면 지금 중지해야합니다.</target>
        </trans-unit>
        <trans-unit id="c3e09fea3d5e333f13ae37d20256186c854915d0" translate="yes" xml:space="preserve">
          <source>If there are multiple columns in the ORDER BY, and there is a mixture of ASC and DESC, do not add the ORDER BY columns; they won't help; stop.</source>
          <target state="translated">ORDER BY에 여러 열이 있고 ASC와 DESC가 혼합 된 경우 ORDER BY 열을 추가하지 마십시오. 그들은 도움이되지 않습니다. 중지.</target>
        </trans-unit>
        <trans-unit id="3092a73c179a37403d90baeca259fd6dce7bce10" translate="yes" xml:space="preserve">
          <source>If there are multiple topics for each article, you need a many-to-many table.</source>
          <target state="translated">각 기사에 대해 여러 주제가있는 경우 다 대다 테이블이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="631458ea21557f82182f3ebac21b80817d96870a" translate="yes" xml:space="preserve">
          <source>If there are multiple triggers for the same action, then the triggers are shown in action order.</source>
          <target state="translated">동일한 조치에 대해 여러 트리거가있는 경우 트리거는 조치 순서로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="38de57bb4b7fa64df681ebd6e3777862b02d7a67" translate="yes" xml:space="preserve">
          <source>If there are no errors, &lt;code&gt;MaxScale-1&lt;/code&gt; is now running as a replication slave to &lt;code&gt;Server-1&lt;/code&gt;.</source>
          <target state="translated">오류가 없으면 &lt;code&gt;MaxScale-1&lt;/code&gt; 이 이제 &lt;code&gt;Server-1&lt;/code&gt; 의 복제 슬레이브로 실행 중 입니다.</target>
        </trans-unit>
        <trans-unit id="cc642b0dc5e63ff0b3b47c3ea1796519b6307dde" translate="yes" xml:space="preserve">
          <source>If there are some differences between the input file and table definition then the colxml utility can be utilized to handle these cases:</source>
          <target state="translated">입력 파일과 테이블 정의 사이에 약간의 차이가있는 경우 colxml 유틸리티를 사용하여 이러한 경우를 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="73caf658d243226eeb2225d26590bb653f7c83f6" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;my.cnf&lt;/code&gt; file in the MariaDB data directory, but not in the MariaDB base directory, &lt;code&gt;MYSQL_HOME&lt;/code&gt; is set to the MariaDB data directory.</source>
          <target state="translated">거기 경우 &lt;code&gt;my.cnf&lt;/code&gt; MariaDB의 기본 디렉토리에 MariaDB 데이터 디렉토리에있는 파일 있지만, &lt;code&gt;MYSQL_HOME&lt;/code&gt; 은 MariaDB 데이터 디렉토리로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="38cc95329b401982aa6c0123a9d7dff7d01b2852" translate="yes" xml:space="preserve">
          <source>If there is a GROUP BY, all the columns of the GROUP BY should now be added, in the specified order, to the INDEX you are building. (I do not know what happens if one of the columns is already in the INDEX.)</source>
          <target state="translated">GROUP BY가있는 경우 GROUP BY의 모든 열이 지정된 순서대로 작성중인 INDEX에 추가되어야합니다. (열 중 하나가 이미 INDEX에 있으면 어떻게 될지 모르겠습니다.)</target>
        </trans-unit>
        <trans-unit id="5048f27ffbd0855f2c9479b7c0132e24aae604b1" translate="yes" xml:space="preserve">
          <source>If there is a JOIN or GROUP BY or ORDER BY LIMIT in the subquery, that complicates the JOIN in new format. So, it might be better to use this pattern:</source>
          <target state="translated">하위 쿼리에 JOIN, GROUP BY 또는 ORDER BY LIMIT가 있으면 JOIN이 새 형식으로 복잡해집니다. 따라서이 패턴을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="a2241cfec2a63fa4fd05bfc6bade45fa517ac5c5" translate="yes" xml:space="preserve">
          <source>If there is a ORDER BY, all the columns of the ORDER BY should now be added, in the specified order, to the INDEX you are building.</source>
          <target state="translated">ORDER BY가있는 경우 ORDER BY의 모든 열이 지정된 순서대로 작성중인 INDEX에 추가되어야합니다.</target>
        </trans-unit>
        <trans-unit id="67df525b54c2b30268dce9aed1155e7da79107b3" translate="yes" xml:space="preserve">
          <source>If there is a bug in the Aria recovery code or in the code that generates the logs, or if the logs become corrupted, then mysqld may fail to start because Aria can't execute the logs at start up.</source>
          <target state="translated">Aria 복구 코드 또는 로그를 생성하는 코드에 버그가 있거나 로그가 손상된 경우 Aria가 시작시 로그를 실행할 수 없기 때문에 mysqld가 시작되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5b449f7b705adf8ad38bab234e98d0b0ddc105b" translate="yes" xml:space="preserve">
          <source>If there is a root user password in the MariaDB server Database, remember to setup the Password Configuration file on each User Module and Performance Module that has User Modules functionality.</source>
          <target state="translated">MariaDB 서버 데이터베이스에 루트 사용자 비밀번호가있는 경우 사용자 모듈 기능이있는 각 사용자 모듈 및 성능 모듈에서 비밀번호 구성 파일을 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="d0d4caa15e5f2b4260c08fca9e674dbda51dcf94" translate="yes" xml:space="preserve">
          <source>If there is already an existing slave running using old-style binlog filename/offset position, then this can be changed to use GTID directly. This can be useful for upgrades for example, or where there are already tools to setup new slaves using old-style binlog positions.</source>
          <target state="translated">이전 스타일 binlog 파일 이름 / 오프셋 위치를 사용하여 기존 슬레이브가 이미 실행중인 경우 GTID를 직접 사용하도록 변경할 수 있습니다. 예를 들어 업그레이드 또는 구식 binlog 위치를 사용하여 새 슬레이브를 설정하는 도구가 이미있는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="3a33c063f609aa52b2c0dbb818aab6a0ffcd2f21" translate="yes" xml:space="preserve">
          <source>If there is an &lt;code&gt;&lt;a href=&quot;../auto_increment/index&quot;&gt;AUTO_INCREMENT&lt;/a&gt;&lt;/code&gt; field, a new value will be generated.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../auto_increment/index&quot;&gt;AUTO_INCREMENT&lt;/a&gt;&lt;/code&gt; 필드 가 있으면 새로운 값이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="6be7257987b62d1090c3a1013f2c622e369c2e92" translate="yes" xml:space="preserve">
          <source>If there is no &lt;em&gt;x_init()&lt;/em&gt; function, or it has been called and did not return an error, &lt;em&gt;x()&lt;/em&gt; is then called once per row.</source>
          <target state="translated">거기에 더없는 경우 &lt;em&gt;x_init ()&lt;/em&gt; 함수 또는이 불려가 오류를 반환하지 않은, &lt;em&gt;X ()가&lt;/em&gt; 다음 행에 한 번이라고합니다.</target>
        </trans-unit>
        <trans-unit id="70f265e940898cb05c625f54fb99bdada2568e9a" translate="yes" xml:space="preserve">
          <source>If there is no PARTITION BY clause, all rows of the result set define the group.</source>
          <target state="translated">PARTITION BY 절이없는 경우 결과 세트의 모든 행이 그룹을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="dd6b6422436d3a15ea57d6a3c7e479b9a5b67651" translate="yes" xml:space="preserve">
          <source>If there is no current role, NULL is returned.</source>
          <target state="translated">현재 역할이 없으면 NULL이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1f26761c3965cb17c9bd40487c7f548ac71648b7" translate="yes" xml:space="preserve">
          <source>If there is no existing key, the statement runs as a regular INSERT:</source>
          <target state="translated">기존 키가 없으면 명령문은 일반 INSERT로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="449ad84f9f2954f3b0b4a55c391dcfd3c3336e75" translate="yes" xml:space="preserve">
          <source>If there is no match for the search string, the search fails. Use &lt;code&gt;HELP contents&lt;/code&gt; to see a list of the help categories:</source>
          <target state="translated">검색 문자열과 일치하는 항목이 없으면 검색이 실패합니다. &lt;code&gt;HELP contents&lt;/code&gt; 을 사용 하여 도움말 범주 목록을보십시오.</target>
        </trans-unit>
        <trans-unit id="9aec48c635749f1dbff18e7ad5b5e67e6e111499" translate="yes" xml:space="preserve">
          <source>If there is only one nameless master, or the default master (as specified by the &lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#default_master_connection&quot;&gt;default_master_connection&lt;/a&gt; system variable) is intended, &lt;code&gt;connection_name&lt;/code&gt; can be omitted. If provided, the &lt;code&gt;RESET SLAVE&lt;/code&gt; statement will apply to the specified master. &lt;code&gt;connection_name&lt;/code&gt; is case-insensitive.</source>
          <target state="translated">이름이없는 마스터가 하나만 있거나 기본 마스터 ( &lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#default_master_connection&quot;&gt;default_master_connection&lt;/a&gt; 시스템 변수에 의해 지정된 )가 의도 된 경우 &lt;code&gt;connection_name&lt;/code&gt; 을 생략 할 수 있습니다. 제공된 경우 &lt;code&gt;RESET SLAVE&lt;/code&gt; 문은 지정된 마스터에 적용됩니다. &lt;code&gt;connection_name&lt;/code&gt; 은 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3eab7f636daa55f449dcd0bb6e5adaee5cae9b45" translate="yes" xml:space="preserve">
          <source>If there is only one nameless master, or the default master (as specified by the &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#default_master_connection&quot;&gt;default_master_connection&lt;/a&gt;&lt;/code&gt; system variable) is intended, &lt;code&gt;connection_name&lt;/code&gt; can be omitted. If provided, the &lt;code&gt;SHOW RELAYLOG&lt;/code&gt; statement will apply to the specified master. &lt;code&gt;connection_name&lt;/code&gt; is case-insensitive.</source>
          <target state="translated">이름이없는 마스터가 하나만 있거나 기본 마스터 ( &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#default_master_connection&quot;&gt;default_master_connection&lt;/a&gt;&lt;/code&gt; 시스템 변수에 의해 지정된 )가 의도 된 경우 &lt;code&gt;connection_name&lt;/code&gt; 을 생략 할 수 있습니다. 제공되는 경우 &lt;code&gt;SHOW RELAYLOG&lt;/code&gt; 문은 지정된 마스터에 적용됩니다. &lt;code&gt;connection_name&lt;/code&gt; 은 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="063ad1e5504f957c4fe5d237354a950c219f801e" translate="yes" xml:space="preserve">
          <source>If there is only one nameless master, or the default master (as specified by the &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#default_master_connection&quot;&gt;default_master_connection&lt;/a&gt;&lt;/code&gt; system variable) is intended, &lt;code&gt;connection_name&lt;/code&gt; can be omitted. If provided, the &lt;code&gt;START SLAVE&lt;/code&gt; statement will apply to the specified master. &lt;code&gt;connection_name&lt;/code&gt; is case-insensitive.</source>
          <target state="translated">이름이없는 마스터가 하나만 있거나 기본 마스터 ( &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#default_master_connection&quot;&gt;default_master_connection&lt;/a&gt;&lt;/code&gt; 시스템 변수에 의해 지정된 )가 의도 된 경우 &lt;code&gt;connection_name&lt;/code&gt; 을 생략 할 수 있습니다. 제공되는 경우 &lt;code&gt;START SLAVE&lt;/code&gt; 문은 지정된 마스터에 적용됩니다. &lt;code&gt;connection_name&lt;/code&gt; 은 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d123fd2fe58cf22b6f12c555929b916e10274cd7" translate="yes" xml:space="preserve">
          <source>If there is only one nameless master, or the default master (as specified by the &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#default_master_connection&quot;&gt;default_master_connection&lt;/a&gt;&lt;/code&gt; system variable) is intended, &lt;code&gt;connection_name&lt;/code&gt; can be omitted. If provided, the &lt;code&gt;STOP SLAVE&lt;/code&gt; statement will apply to the specified master. &lt;code&gt;connection_name&lt;/code&gt; is case-insensitive.</source>
          <target state="translated">이름이없는 마스터가 하나만 있거나 기본 마스터 ( &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#default_master_connection&quot;&gt;default_master_connection&lt;/a&gt;&lt;/code&gt; 시스템 변수에 의해 지정된 )가 의도 된 경우 &lt;code&gt;connection_name&lt;/code&gt; 을 생략 할 수 있습니다. 제공되는 경우 &lt;code&gt;STOP SLAVE&lt;/code&gt; 문은 지정된 마스터에 적용됩니다. &lt;code&gt;connection_name&lt;/code&gt; 은 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8e56a08828e3c706cbe0f7df438db2da65b7c946" translate="yes" xml:space="preserve">
          <source>If there's an existing service listening on port 3306, the installer will create /usr/local/mariadb/etc/my.cnf with &lt;code&gt;skip-networking&lt;/code&gt;. You can edit this file to set an alternate port for MariaDB Server to listen on, or you can remove &lt;code&gt;skip-networking&lt;/code&gt; if you have disabled the daemon that had bound port 3306.</source>
          <target state="translated">포트 3306에서 수신 대기중인 기존 서비스가있는 경우 설치 프로그램은 &lt;code&gt;skip-networking&lt;/code&gt; 을 사용하여 /usr/local/mariadb/etc/my.cnf를 작성 합니다. 이 파일을 편집하여 MariaDB 서버가 청취 할 대체 포트를 설정하거나 포트 3306을 바인드 한 디먼을 비활성화 한 경우 &lt;code&gt;skip-networking&lt;/code&gt; 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="51264b19b300dff626bb564c131d6917794620f7" translate="yes" xml:space="preserve">
          <source>If these are not available, you will need to build Galera from source, as follows:</source>
          <target state="translated">이것들을 사용할 수 없다면, 다음과 같이 소스로부터 Galera를 빌드해야합니다 :</target>
        </trans-unit>
        <trans-unit id="6186cd09edb5484c33d927b9c54e7fd9a88a81a7" translate="yes" xml:space="preserve">
          <source>If they don't, the type and length of the columns in the result take into account the values returned by all of the SELECTs, so there is no need for explicit casting. Note that currently this is not the case for &lt;a href=&quot;../recursive-common-table-expressions-overview/index&quot;&gt;recursive CTEs&lt;/a&gt; - see &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-12325&quot;&gt;MDEV-12325&lt;/a&gt;.</source>
          <target state="translated">그렇지 않은 경우 결과의 열 유형과 길이는 모든 SELECT에서 반환 된 값을 고려하므로 명시 적 캐스팅이 필요하지 않습니다. 현재는 &lt;a href=&quot;../recursive-common-table-expressions-overview/index&quot;&gt;재귀 CTE&lt;/a&gt; 의 경우가 아닙니다 . &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-12325&quot;&gt;MDEV-12325를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c6f08ad8738468e8b62496aae720e5ea8e130c39" translate="yes" xml:space="preserve">
          <source>If they match, the distribution can be correct although this does not prove it. However, if they do not match, the distribution is surely wrong.</source>
          <target state="translated">일치하면 분포가 정확하지 않을 수 있지만 분포가 정확할 수 있습니다. 그러나 일치하지 않으면 배포가 잘못되었습니다.</target>
        </trans-unit>
        <trans-unit id="3ca83e5b192d8ee72eb5c398b1134bbf9a03d31e" translate="yes" xml:space="preserve">
          <source>If this checkbox is selected, the default storage engine is set to Innodb (or XtraDB) and the &lt;code&gt;sql_mode&lt;/code&gt; parameter is set to &quot;&lt;code&gt;NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES&lt;/code&gt;&quot;. You can also define the Innodb/Xtradb buffer pool size. The default buffer pool size is 12.5% of RAM and depending on your requirements you can give innodb more (up to 70-80% RAM). 32 bit versions of MariaDB have restrictions on maximum buffer pool size, which is approximately 1GB, due to virtual address space limitations for 32bit processes.</source>
          <target state="translated">이 확인란을 선택하면 기본 저장소 엔진이 Innodb (또는 XtraDB) 로 설정되고 &lt;code&gt;sql_mode&lt;/code&gt; 매개 변수는 &quot; &lt;code&gt;NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES&lt;/code&gt; &quot;로 설정됩니다 . Innodb / Xtradb 버퍼 풀 크기를 정의 할 수도 있습니다. 기본 버퍼 풀 크기는 RAM의 12.5 %이며 요구 사항에 따라 innodb에 더 많은 정보를 제공 할 수 있습니다 (최대 70-80 % RAM). 32 비트 버전의 MariaDB에는 32 비트 프로세스에 대한 가상 주소 공간 제한으로 인해 최대 버퍼 풀 크기 (약 1GB)에 대한 제한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2d599234756c7ab8ab28fd226736c27404ff65e" translate="yes" xml:space="preserve">
          <source>If this error is occurring because the file is in a custom location, then you can configure this location by setting the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#lc_messages_dir&quot;&gt;lc_messages_dir&lt;/a&gt;&lt;/code&gt; system variable either on the command-line or in a server &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;option group&lt;/a&gt; in an &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;option file&lt;/a&gt; prior to starting up the server. For example:</source>
          <target state="translated">파일이 사용자 정의 위치에 있기 때문에이 오류가 발생 하면 서버 를 시작하기 전에 명령 행 또는 &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;옵션 파일&lt;/a&gt; 의 서버 &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;옵션 그룹&lt;/a&gt; 에서 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#lc_messages_dir&quot;&gt;lc_messages_dir&lt;/a&gt;&lt;/code&gt; 시스템 변수 를 설정하여이 위치를 구성 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ca2e505a43f8f043c7e8ae49b4e45ec365690dcb" translate="yes" xml:space="preserve">
          <source>If this file is detected, &lt;a href=&quot;../mysqltest/index&quot;&gt;mysqltest&lt;/a&gt; will not start new tests until the file is removed (also MTR_STOP_FILE environment variable).</source>
          <target state="translated">이 파일이 발견되면, &lt;a href=&quot;../mysqltest/index&quot;&gt;mysqltest&lt;/a&gt; 는 파일이 제거 될 때까지 (MTR_STOP_FILE 환경 변수) 새로운 테스트를 시작하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a5e9078b79ebecc946eb9c5e9fe3ebb11615f762" translate="yes" xml:space="preserve">
          <source>If this found file is a &lt;code&gt;.rdiff&lt;/code&gt;, mtr continues walking down the list until the first &lt;code&gt;.result&lt;/code&gt; file is found. A &lt;code&gt;.rdiff&lt;/code&gt; is applied to that &lt;code&gt;.result&lt;/code&gt;.</source>
          <target state="translated">찾은 파일이 &lt;code&gt;.rdiff&lt;/code&gt; 이면 mtr은 첫 번째 &lt;code&gt;.result&lt;/code&gt; 파일을 찾을 때까지 목록을 계속 진행 합니다. &lt;code&gt;.rdiff&lt;/code&gt; 는 에 적용한 &lt;code&gt;.result&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f252030f89ce4588871d579750c73b069c97b5d9" translate="yes" xml:space="preserve">
          <source>If this happens, it is possible to increase the default limit using the MAXRES option, for instance:</source>
          <target state="translated">이 경우 MAXRES 옵션을 사용하여 기본 제한을 늘릴 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="df2a833a95576042cf167e681002968507693711" translate="yes" xml:space="preserve">
          <source>If this happens, you will see things like this in your mysqld.err file:</source>
          <target state="translated">이 경우 mysqld.err 파일에 다음과 같은 내용이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="9b59ea7f7e7aa1329b41fd5c93369666abaed451" translate="yes" xml:space="preserve">
          <source>If this is a problem, MAXVALUE can be specified as a value for the last partition. Note however that it is not possible to split partitions of an existing RANGE partitioned table. New partitions can be appended, but this will not be possible if the last partition's higher bound is MAXVALUE.</source>
          <target state="translated">이것이 문제이면 MAXVALUE를 마지막 파티션의 값으로 지정할 수 있습니다. 그러나 기존 RANGE 파티션 된 테이블의 파티션을 분할 할 수는 없습니다. 새 파티션을 추가 할 수 있지만 마지막 파티션의 상한이 MAXVALUE 인 경우에는 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="270573e03c8e9188154b05117d45900b74c16088" translate="yes" xml:space="preserve">
          <source>If this is not done, and the slave thread is already running, then it will continue to use asynchronous replication.</source>
          <target state="translated">이 작업을 수행하지 않고 슬레이브 스레드가 이미 실행 중이면 계속 비동기식 복제를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4207da40dc6918f2e129922e5383594a62c3373f" translate="yes" xml:space="preserve">
          <source>If this is not done, the Oracle JVM will start the usage tracker, which will create the hidden folder .oracle_jre_usage in the mysql home directory, which will cause a mysql dump of the server to fail.</source>
          <target state="translated">이 작업을 수행하지 않으면 Oracle JVM이 사용 추적기를 시작하여 mysql 홈 디렉토리에 숨겨진 폴더 .oracle_jre_usage를 생성하여 서버의 mysql 덤프가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="48eac7caeef3110461f92ed79aa1b765580fbb0b" translate="yes" xml:space="preserve">
          <source>If this is not the case, then you can find out if there is any modules missing that are required by OQGRAPH by doing:</source>
          <target state="translated">그렇지 않은 경우 다음을 수행하여 OQGRAPH에 필요한 누락 된 모듈이 있는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca7699f2757947d468539bc647ae426d3651ea1b" translate="yes" xml:space="preserve">
          <source>If this is set generate a warning (not an error) for wrong table option in CREATE TABLE. Also, since 10.0.13, do not comment out these wrong table options in &lt;a href=&quot;../show-create-table/index&quot;&gt;SHOW CREATE TABLE&lt;/a&gt;.</source>
          <target state="translated">이것이 설정되면 CREATE TABLE에서 잘못된 테이블 옵션에 대한 경고 (오류 아님)를 생성하십시오. 또한 10.0.13부터 &lt;a href=&quot;../show-create-table/index&quot;&gt;SHOW CREATE TABLE&lt;/a&gt; 에서 이러한 잘못된 테이블 옵션을 주석 처리하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="f3c904e6fbcacbef78988611407d37de49cd0909" translate="yes" xml:space="preserve">
          <source>If this is set to &lt;code&gt;NO&lt;/code&gt;, you cannot enable the query cache unless you rebuild or reinstall a version of MariaDB with the cache available.</source>
          <target state="translated">이것이 &lt;code&gt;NO&lt;/code&gt; 로 설정되면 사용 가능한 캐시가있는 MariaDB 버전을 다시 빌드하거나 다시 설치하지 않으면 쿼리 캐시를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e371f33975bd76197b927f7f778c5766f6caba13" translate="yes" xml:space="preserve">
          <source>If this is the case, as the text describes, delete the orphan &lt;code&gt;.frm&lt;/code&gt; file on the filesystem.</source>
          <target state="translated">이 경우 텍스트에 설명 된대로 파일 시스템 에서 orphan &lt;code&gt;.frm&lt;/code&gt; 파일을 삭제하십시오 .</target>
        </trans-unit>
        <trans-unit id="a2986d6214a92a3e75aa0d134f83141137f7ce49" translate="yes" xml:space="preserve">
          <source>If this locking strategy is not permitted for an operation, then an error is raised.</source>
          <target state="translated">이 잠금 전략이 조작에 허용되지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="32066bc36f9e38e882dfa3a366e62e7eb78aa931" translate="yes" xml:space="preserve">
          <source>If this operation completes without error, then the backup is ready to be restored.</source>
          <target state="translated">이 작업이 오류없이 완료되면 백업을 복원 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a1a24698bac128a6cdc8064b8acacb1e18240fe" translate="yes" xml:space="preserve">
          <source>If this option is provided during the &lt;code&gt;--prepare&lt;/code&gt; stage, then it tells Mariabackup to create &lt;code&gt;.cfg&lt;/code&gt; files for each &lt;a href=&quot;../innodb-file-per-table-tablespaces/index&quot;&gt;InnoDB file-per-table tablespace&lt;/a&gt;. These &lt;code&gt;.cfg&lt;/code&gt; files are used to &lt;a href=&quot;../innodb-file-per-table-tablespaces/index#copying-transportable-tablespaces&quot;&gt;import transportable tablespaces&lt;/a&gt; in the process of &lt;a href=&quot;../partial-backup-and-restore-with-mariabackup/index&quot;&gt;restoring partial backups&lt;/a&gt; and &lt;a href=&quot;../restoring-individual-tables-and-partitions-with-mariabackup/index&quot;&gt;restoring individual tables and partitions&lt;/a&gt;. .</source>
          <target state="translated">이 옵션이 기간 동안 제공되는 경우 &lt;code&gt;--prepare&lt;/code&gt; 단계, 그것은 만들 Mariabackup를 알려줍니다 &lt;code&gt;.cfg&lt;/code&gt; 를 각 파일 &lt;a href=&quot;../innodb-file-per-table-tablespaces/index&quot;&gt;InnoDB의 파일 당 테이블의 테이블 스페이스를&lt;/a&gt; . 이 &lt;code&gt;.cfg&lt;/code&gt; 파일은 &lt;a href=&quot;../partial-backup-and-restore-with-mariabackup/index&quot;&gt;부분 백업&lt;/a&gt; 을 &lt;a href=&quot;../restoring-individual-tables-and-partitions-with-mariabackup/index&quot;&gt;복원하고 개별 테이블 및 파티션&lt;/a&gt; 을 복원 하는 과정에서 &lt;a href=&quot;../innodb-file-per-table-tablespaces/index#copying-transportable-tablespaces&quot;&gt;전송 가능한 테이블 공간&lt;/a&gt; 을 가져 오는 데 사용됩니다 . .</target>
        </trans-unit>
        <trans-unit id="2218628c7785e9c9ead60f535ddb820aecbdb13e" translate="yes" xml:space="preserve">
          <source>If this option is used when preparing a backup, then only the redo log apply stage will be performed, and other stages of crash recovery will be ignored. This option is used with &lt;a href=&quot;../incremental-backup-and-restore-with-mariabackup/index&quot;&gt;incremental backups&lt;/a&gt;.</source>
          <target state="translated">백업을 준비 할 때이 옵션을 사용하면 리두 로그 적용 단계 만 수행되고 다른 단계의 응급 복구는 무시됩니다. 이 옵션은 &lt;a href=&quot;../incremental-backup-and-restore-with-mariabackup/index&quot;&gt;증분 백업&lt;/a&gt; 과 함께 사용 됩니다 .</target>
        </trans-unit>
        <trans-unit id="92e0d64da665f43b23c1980d5a9706fbc1341c4e" translate="yes" xml:space="preserve">
          <source>If this still fails, try restartSystem once more and try logging in again as this seems to resolve the issue.</source>
          <target state="translated">그래도 문제가 해결되지 않으면 시스템을 다시 시작한 다음 다시 로그인하여 문제를 해결하십시오.</target>
        </trans-unit>
        <trans-unit id="076da7ec71ae2a694da85eff2315e4d7709a3a50" translate="yes" xml:space="preserve">
          <source>If this system variable is set to &lt;code&gt;0&lt;/code&gt; (which is the default value), then no slave &lt;a href=&quot;../replication-threads/index#worker-threads&quot;&gt;worker threads&lt;/a&gt; will be created. Instead, when replication is enabled, &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt; events are applied by the slave's &lt;a href=&quot;../replication-threads/index#slave-sql-thread&quot;&gt;SQL thread&lt;/a&gt;.</source>
          <target state="translated">이 시스템 변수가 &lt;code&gt;0&lt;/code&gt; (기본값)으로 설정되면 슬레이브 &lt;a href=&quot;../replication-threads/index#worker-threads&quot;&gt;작업자 스레드&lt;/a&gt; 가 생성 되지 않습니다 . 대신 복제가 활성화되면 &lt;a href=&quot;../binary-log/index&quot;&gt;이진 로그&lt;/a&gt; 이벤트가 슬레이브의 &lt;a href=&quot;../replication-threads/index#slave-sql-thread&quot;&gt;SQL 스레드&lt;/a&gt; 에 의해 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="8864a963893c449d1df83b61d590581642ac9da8" translate="yes" xml:space="preserve">
          <source>If this system variable is set to a valid &lt;a href=&quot;../server-locale/index&quot;&gt;locale&lt;/a&gt; name, but the server can't find an &lt;a href=&quot;../error-log/index#error-messages-file&quot;&gt;error message file&lt;/a&gt; for the language associated with the &lt;a href=&quot;../server-locale/index&quot;&gt;locale&lt;/a&gt;, then the default language will be used instead.</source>
          <target state="translated">이 시스템 변수가 유효한 &lt;a href=&quot;../server-locale/index&quot;&gt;로케일&lt;/a&gt; 이름으로 설정되었지만 서버가 &lt;a href=&quot;../server-locale/index&quot;&gt;locale&lt;/a&gt; 과 연관된 언어에 대한 &lt;a href=&quot;../error-log/index#error-messages-file&quot;&gt;오류 메시지 파일&lt;/a&gt; 을 찾을 수없는 경우 기본 언어가 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="98a7b06e3969526b4d6c657d761d1cdea6774dfd" translate="yes" xml:space="preserve">
          <source>If this system variable is set to a value greater than &lt;code&gt;0&lt;/code&gt;, then its value will determine how many slave &lt;a href=&quot;../replication-threads/index#worker-threads&quot;&gt;worker threads&lt;/a&gt; will be created to apply &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt; events in parallel.</source>
          <target state="translated">이 시스템 변수가 &lt;code&gt;0&lt;/code&gt; 보다 큰 값으로 설정되면,이 값은 &lt;a href=&quot;../binary-log/index&quot;&gt;바이너리 로그&lt;/a&gt; 이벤트를 병렬 로 적용하기 위해 얼마나 많은 슬레이브 &lt;a href=&quot;../replication-threads/index#worker-threads&quot;&gt;작업자 스레드&lt;/a&gt; 가 작성 될지를 결정합니다 .</target>
        </trans-unit>
        <trans-unit id="c7600baa3e1562e5cd116093631f264600fd2b92" translate="yes" xml:space="preserve">
          <source>If this system variable is set, then the &lt;a href=&quot;../aria/index&quot;&gt;Aria&lt;/a&gt; storage engine will not lock a table when it decrements the table's in-file counter that keeps track of how many connections currently have the table open. See &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-19393&quot;&gt;MDEV-19393&lt;/a&gt; for more information.</source>
          <target state="translated">이 시스템 변수가 설정되면 &lt;a href=&quot;../aria/index&quot;&gt;Aria&lt;/a&gt; 스토리지 엔진은 테이블이 현재 열려있는 연결 수를 추적하는 테이블의 파일 내 카운터를 감소시킬 때 테이블을 잠그지 않습니다. 자세한 내용은 &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-19393&quot;&gt;MDEV-19393&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e4320050aac84297fbfa8bd10691f0967f562fec" translate="yes" xml:space="preserve">
          <source>If this system variable is set, then the &lt;a href=&quot;../myisam-storage-engine/index&quot;&gt;MyISAM&lt;/a&gt; storage engine will not use file-based locks. Otherwise, it will use the &lt;code&gt;&lt;a href=&quot;https://linux.die.net/man/2/fcntl&quot;&gt;fcntl()&lt;/a&gt;&lt;/code&gt; function with the &lt;code&gt;F_SETLK&lt;/code&gt; option to get file-based locks on Unix, and it will use the &lt;code&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/api/fileapi/nf-fileapi-lockfileex&quot;&gt;LockFileEx()&lt;/a&gt;&lt;/code&gt; function to get file-based locks on Windows.</source>
          <target state="translated">이 시스템 변수가 설정되면 &lt;a href=&quot;../myisam-storage-engine/index&quot;&gt;MyISAM&lt;/a&gt; 스토리지 엔진은 파일 기반 잠금을 사용하지 않습니다. 그렇지 않으면 &lt;code&gt;F_SETLK&lt;/code&gt; 옵션 과 함께 &lt;code&gt;&lt;a href=&quot;https://linux.die.net/man/2/fcntl&quot;&gt;fcntl()&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 Unix에서 파일 기반 잠금을 가져오고 &lt;code&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/api/fileapi/nf-fileapi-lockfileex&quot;&gt;LockFileEx()&lt;/a&gt;&lt;/code&gt; 함수를 사용하여 Windows에서 파일 기반 잠금을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="7c2721b05a9d45e86fc58d972dd5e2ee6dff58ce" translate="yes" xml:space="preserve">
          <source>If this system variable's value is &lt;strong&gt;not&lt;/strong&gt; prefixed with &lt;code&gt;FILE:&lt;/code&gt;, then it is interpreted as the plain-text encryption password. However, this is not recommended.</source>
          <target state="translated">이 시스템 변수 값 앞에 &lt;code&gt;FILE:&lt;/code&gt; 붙지 &lt;strong&gt;않으면&lt;/strong&gt; 일반 텍스트 암호화 비밀번호로 해석됩니다. 그러나 이것은 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3b4293fbfc32e459db105a4b7f4dd7c4465419ce" translate="yes" xml:space="preserve">
          <source>If this system variable's value is prefixed with &lt;code&gt;FILE:&lt;/code&gt;, then it is interpreted as a path to a file that contains the plain-text encryption password.</source>
          <target state="translated">이 시스템 변수의 값 앞에 &lt;code&gt;FILE:&lt;/code&gt; 이 붙으면 일반 텍스트 암호화 비밀번호가 포함 된 파일의 경로로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="af5c81a540e04f0f3af96881550e80c8019c532f" translate="yes" xml:space="preserve">
          <source>If this value is set too high, and the slave is far (eg. gigabytes of binlog) behind the master, then the &lt;a href=&quot;../replication-threads/index#slave-sql-thread&quot;&gt;SQL thread&lt;/a&gt; can quickly read all of that and fill up memory with huge amounts of binlog events faster than the &lt;a href=&quot;../replication-threads/index#worker-threads&quot;&gt;worker threads&lt;/a&gt; can consume them.</source>
          <target state="translated">이 값이 너무 높게 설정되고 슬레이브가 마스터보다 훨씬 멀리 떨어져 있으면 (예 : 기가 바이트의 binlog) &lt;a href=&quot;../replication-threads/index#slave-sql-thread&quot;&gt;SQL 스레드&lt;/a&gt; 는 해당 스레드 를 모두 빠르게 읽고 &lt;a href=&quot;../replication-threads/index#worker-threads&quot;&gt;작업자 스레드&lt;/a&gt; 보다 훨씬 많은 양의 binlog 이벤트로 메모리를 채울 수 있습니다. 그들을 소비하십시오.</target>
        </trans-unit>
        <trans-unit id="41984665301e859eb0b2759f2d44fbdbb5e99e7f" translate="yes" xml:space="preserve">
          <source>If this variable is non-NULL, it is assumed to specify a join prefix as a comma-separated list of table aliases:</source>
          <target state="translated">이 변수가 NULL이 아닌 경우, 조인 접두어를 쉼표로 구분 된 테이블 별명 목록으로 지정한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="3edfce12e01c82bcf7dc74beaf314aab31654508" translate="yes" xml:space="preserve">
          <source>If true, enables parallel execution of remote sub-tables.</source>
          <target state="translated">true 인 경우 원격 서브 테이블의 병렬 실행을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="39ae982e40ca91f0861c0e19e653ad4af6b6849b" translate="yes" xml:space="preserve">
          <source>If true, missing columns are accepted and return null values. Defaults to false.</source>
          <target state="translated">true 인 경우 누락 된 열이 허용되며 null 값을 반환합니다. 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="2f21710d53a3c8c29e965377d705a4a5f0b8208b" translate="yes" xml:space="preserve">
          <source>If used and the trigger already exists, instead of an error being returned, the existing trigger will be dropped and replaced by the newly defined trigger.</source>
          <target state="translated">오류가 반환되는 대신 사용되고 트리거가 이미 존재하는 경우 기존 트리거가 삭제되고 새로 정의 된 트리거로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="013bd8fceca4dfeb468b281655c19769aa5d85ce" translate="yes" xml:space="preserve">
          <source>If used out of a &lt;a href=&quot;../handler/index&quot;&gt;HANDLER&lt;/a&gt; construct, RESIGNAL produces the following error:</source>
          <target state="translated">&lt;a href=&quot;../handler/index&quot;&gt;HANDLER&lt;/a&gt; 구문에서 사용될 경우 RESIGNAL은 다음 오류를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="2184c781f092d051c5fe6d0e1071af8a94fc6226" translate="yes" xml:space="preserve">
          <source>If user account control is enabled (Vista or later), you will see this dialog. Click on &quot;Yes&quot;.</source>
          <target state="translated">사용자 계정 제어가 활성화 된 경우 (Vista 이상)이 대화 상자가 나타납니다. &quot;예&quot;를 클릭하십시오.</target>
        </trans-unit>
        <trans-unit id="e18c917a25886c7015cb7e1d419cbb98109b4542" translate="yes" xml:space="preserve">
          <source>If using &lt;a href=&quot;../what-is-mariadb-101/index&quot;&gt;MariaDB 10.1&lt;/a&gt; or earlier, and your applications often connect and disconnect to MariaDB, you should set up &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#thread_cache_size&quot;&gt;thread-cache-size&lt;/a&gt;&lt;/code&gt; to the number of concurrent queries threads you are typically running. This is important in MariaDB as we are using the &lt;a href=&quot;http://www.canonware.com/jemalloc/&quot;&gt;jemalloc&lt;/a&gt; memory allocator. &lt;a href=&quot;http://www.canonware.com/jemalloc/&quot;&gt;jemalloc&lt;/a&gt; usually has better performance when running many threads compared to other memory allocators, except if you create and destroy a lot of threads, in which case it will spend a lot of resources trying to manage thread specific storage. Having a thread cache will fix this problem.</source>
          <target state="translated">사용하는 경우 &lt;a href=&quot;../what-is-mariadb-101/index&quot;&gt;MariaDB 10.1&lt;/a&gt; 또는 이전 버전 및 응용 프로그램이 자주 MariaDB에 연결하고 연결 해제, 당신은 설정해야합니다 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#thread_cache_size&quot;&gt;thread-cache-size&lt;/a&gt;&lt;/code&gt; 동시 쿼리의 수는 일반적으로 실행중인 스레드를. 이것은 &lt;a href=&quot;http://www.canonware.com/jemalloc/&quot;&gt;jemalloc&lt;/a&gt; 메모리 할당자를 사용하고 있기 때문에 MariaDB에서 중요 합니다. 많은 스레드를 작성 및 제거하는 경우를 제외하고 &lt;a href=&quot;http://www.canonware.com/jemalloc/&quot;&gt;jemalloc은&lt;/a&gt; 일반적으로 다른 메모리 할당 자에 비해 많은 스레드를 실행할 때 성능이 더 우수합니다.이 경우 스레드 특정 스토리지를 관리하는 데 많은 자원이 소비됩니다. 스레드 캐시가 있으면이 문제가 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="04e1572728fb2b44a97821ab8069c17dc9a8103c" translate="yes" xml:space="preserve">
          <source>If using &lt;code&gt;--srcdir&lt;/code&gt; with out-of-directory builds, you will need to set this to the location of the build directory where built files reside.</source>
          <target state="translated">디렉토리 외부 빌드에서 &lt;code&gt;--srcdir&lt;/code&gt; 을 사용하는 경우 빌드 된 파일이있는 빌드 디렉토리의 위치로이를 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="113e2554648ffb541cad319a153e76d70144b834" translate="yes" xml:space="preserve">
          <source>If using MEMORY, remember that it is volatile -- recover from a crash by starting the ingestion over.</source>
          <target state="translated">MEMORY를 사용하는 경우 변동성이 있음을 기억하십시오. 수집을 다시 시작하여 충돌을 복구하십시오.</target>
        </trans-unit>
        <trans-unit id="0ab1c02f458c7a28b0afa0e55a27146a1b858ed8" translate="yes" xml:space="preserve">
          <source>If using a debug version of MariaDB, write a debugging log. A typical debug_options string is &amp;acute;d:t:o,file_name&amp;acute;. The default value is &amp;acute;d:t:o,/tmp/mysqldump.trace&amp;acute;. If using a non-debug version, &lt;code&gt;mysqldump&lt;/code&gt; will catch this and exit.</source>
          <target state="translated">디버그 버전의 MariaDB를 사용하는 경우 디버깅 로그를 작성하십시오. 일반적인 debug_options 문자열은&amp;ldquo;d : t : o, file_name&amp;rdquo;입니다. 기본값은&amp;ldquo;d : t : o, / tmp / mysqldump.trace&amp;rdquo;입니다. 비 디버거 버전을 사용하는 경우 &lt;code&gt;mysqldump&lt;/code&gt; 가이를 잡아서 종료합니다.</target>
        </trans-unit>
        <trans-unit id="8bfc2c398e57b6b1df30bd5292cafa054c25251a" translate="yes" xml:space="preserve">
          <source>If using the &lt;a href=&quot;https://downloads.mariadb.org/mariadb/repositories/&quot;&gt;YUM repositories&lt;/a&gt; on Fedora, Red Hat, or CentOS, first install the Cassandra storage engine package with:</source>
          <target state="translated">Fedora, Red Hat 또는 CentOS 에서 &lt;a href=&quot;https://downloads.mariadb.org/mariadb/repositories/&quot;&gt;YUM 저장소&lt;/a&gt; 를 사용하는 경우 먼저 다음과 같이 Cassandra 스토리지 엔진 패키지를 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="b12f3d90b18f9e76463b625cd5f1266d65f32352" translate="yes" xml:space="preserve">
          <source>If using the Debian or Ubuntu repositories, the Cassandra plugin is in the main MariaDB server package.</source>
          <target state="translated">데비안 또는 우분투 리포지토리를 사용하는 경우 Cassandra 플러그인은 기본 MariaDB 서버 패키지에 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3eb789703b266efc0a58992d961245b46a06a76" translate="yes" xml:space="preserve">
          <source>If utilizing ssh-keys and will be utilizing the MariaDB ColumnStore Data Redundancy feature, make sure you setup an ssh-key on the PM1 node to itself. This is required for Data Redundancy feature.</source>
          <target state="translated">ssh 키를 사용하고 MariaDB ColumnStore 데이터 중복 기능을 사용하는 경우 PM1 노드에서 ssh 키를 자체적으로 설정하십시오. 이는 데이터 중복 기능에 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a5f29875cc8aa00b09dbba442d009e7086f57d66" translate="yes" xml:space="preserve">
          <source>If utilizing ssh-keys and will be utilizing the MariaDB ColumnStore Data Replication feature, make sure you setup an ssh-key between all UM nodes. And if you enabled the Local Query Feature, will also need between all UM nodes and all PM nodes.</source>
          <target state="translated">ssh 키를 사용하고 MariaDB ColumnStore 데이터 복제 기능을 사용하는 경우 모든 UM 노드간에 ssh 키를 설정해야합니다. 로컬 쿼리 기능을 사용하도록 설정 한 경우 모든 UM 노드와 모든 PM 노드 사이에도 필요합니다.</target>
        </trans-unit>
        <trans-unit id="48064da7d2fbe4c5b71ca19a88f55ca51a72274d" translate="yes" xml:space="preserve">
          <source>If vsjitdebugger does not start, you can edit AeDebug registry key as mentioned in</source>
          <target state="translated">vsjitdebugger가 시작되지 않으면 위에서 언급 한대로 AeDebug 레지스트리 키를 편집 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="e7c95027e70fbbe97f70eb82c35989e2cce32773" translate="yes" xml:space="preserve">
          <source>If we chose to look for cities with a population greater than 7 million, the optimizer will use Materialization-Scan and &lt;code&gt;EXPLAIN&lt;/code&gt; will show this:</source>
          <target state="translated">인구가 7 백만 이상인 도시를 선택하기로 선택한 경우 옵티마이 저는 Materialization-Scan을 사용하고 &lt;code&gt;EXPLAIN&lt;/code&gt; 은 다음을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="58f805970bc8c114444114c7beca3659925e406a" translate="yes" xml:space="preserve">
          <source>If we consider different case characters, more complexity is added. A binary collation would evaluate the characters &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; differently, ordering them in a particular way. A case-insensitive collation would evaluate &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; equivalently, while the German phone book collation evaluates the characters &lt;code&gt;ue&lt;/code&gt; and &lt;code&gt;&amp;uuml;&lt;/code&gt; equivalently.</source>
          <target state="translated">다른 문자를 고려하면 더 복잡해집니다. 이진 데이터 정렬은 문자 평가할 것 및 &lt;code&gt;a&lt;/code&gt; 특정 방식으로 주문 다르게. 소문자를 구분하지 않는 데이터 정렬 평가 것 및 독일 전화 번호부 데이터 정렬은 문자를 평가하면서, 동등을 &lt;code&gt;ue&lt;/code&gt; 및 &lt;code&gt;&amp;uuml;&lt;/code&gt; 동등하게. &lt;code&gt;A&lt;/code&gt; &lt;code&gt;A&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1fbf204163a8f27c262beba4b0f73ccdae3cded5" translate="yes" xml:space="preserve">
          <source>If we convert the table to MyISAM, we will have these files:</source>
          <target state="translated">테이블을 MyISAM으로 변환하면 다음 파일이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="c7fcb9164291e599cb97957a5e6fa3867ae116ef" translate="yes" xml:space="preserve">
          <source>If we execute the query:</source>
          <target state="translated">쿼리를 실행하면 :</target>
        </trans-unit>
        <trans-unit id="d064e1857a4df146a812c6aa2b481acf16a737bc" translate="yes" xml:space="preserve">
          <source>If we had not used &lt;a href=&quot;../use-index/index&quot;&gt;USE INDEX&lt;/a&gt;, the &lt;code&gt;Name&lt;/code&gt; index would have been in &lt;code&gt;possible keys&lt;/code&gt;.</source>
          <target state="translated">우리가 사용하지 않았다면 &lt;a href=&quot;../use-index/index&quot;&gt;사용 색인&lt;/a&gt; 의 &lt;code&gt;Name&lt;/code&gt; 인덱스에했을 &lt;code&gt;possible keys&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="58a78a2eccc25cddcdf856655fb709a6a6b9ad5b" translate="yes" xml:space="preserve">
          <source>If we had not used USE INDEX, the Name index would have been in possible keys.</source>
          <target state="translated">USE INDEX를 사용하지 않았다면 Name 인덱스는 가능한 키에 있었을 것입니다.</target>
        </trans-unit>
        <trans-unit id="5a81686bd4d756df898e30601fa6d63a5c149a04" translate="yes" xml:space="preserve">
          <source>If we have a query with a join of three tables t1, t2, t3 such that table t1 is joined with table t2 and the result of this join operation is joined with table t3 then two join buffers can be used to execute the query. The first join buffer B1 is used to store the records comprising interesting fields of table t1, while the second join buffer B2 contains the records with fields from the partial join of t1 and t2. The interesting fields of any record r1 from B1 are copied into B2 for any record record r1,r2 from the partial join of t1 and t2. One could suggest storing in B2 just a pointer to the position of the r1 fields in B1 together with the interesting fields from t2. So for any record r2 matching the record r1 the buffer B2 would contain a reference to the fields of r1 in B1 and the fields of r2. In this case the buffer B2 is called incremental. Incremental buffers allow to avoid copying field values from one buffer into another. They also allow to save a significant amount of buffer space if for a record from t1 several matches from t2 are expected.</source>
          <target state="translated">테이블 t1이 테이블 t2와 조인되고이 조인 작업의 결과가 테이블 t3과 조인되도록 3 개의 테이블 t1, t2, t3이 조인 된 쿼리가있는 경우 2 개의 조인 버퍼를 사용하여 쿼리를 실행할 수 있습니다. 제 1 결합 버퍼 (B1)는 테이블 (t1)의 흥미로운 필드를 포함하는 레코드를 저장하는 데 사용되는 반면, 제 2 결합 버퍼 (B2)는 t1 및 t2의 부분 결합의 필드를 갖는 레코드를 포함한다. B1에서 레코드 r1의 흥미로운 필드는 t1 및 t2의 부분 조인에서 레코드 레코드 r1, r2에 대해 B2로 복사됩니다. t2의 흥미로운 필드와 함께 B1의 r1 필드 위치에 대한 포인터를 B2에 저장하는 것이 좋습니다. 따라서 레코드 r1과 일치하는 레코드 r2에 대해 버퍼 B2는 B1의 r1 필드와 r2 필드에 대한 참조를 포함합니다.이 경우 버퍼 B2를 증분이라고합니다. 증분 버퍼를 사용하면 한 버퍼에서 다른 버퍼로 필드 값을 복사하지 않아도됩니다. 또한 t1의 레코드에 대해 t2의 여러 일치가 예상되는 경우 상당한 양의 버퍼 공간을 절약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1b2e9e5ac5ea669c93829ef88776314862bddaf" translate="yes" xml:space="preserve">
          <source>If we know that there can be, at most, one country with with a given value of &lt;code&gt;Country.Code&lt;/code&gt; (we can tell that if we see that table Country has a primary key or unique index over that column), we can re-write this query as:</source>
          <target state="translated">주어진 &lt;code&gt;Country.Code&lt;/code&gt; 값을 가진 국가가 하나만있을 수 있음을 알고있는 경우 (국가 테이블에 해당 열에 대한 기본 키 또는 고유 인덱스가 있음을 알 수 있음) 다시 작성할 수 있습니다 이 쿼리는</target>
        </trans-unit>
        <trans-unit id="1df9beedc5cdbbc31428cab9730fd81ee8551707" translate="yes" xml:space="preserve">
          <source>If we run the same EXPLAIN in MySQL, we'll get:</source>
          <target state="translated">MySQL에서 동일한 EXPLAIN을 실행하면 다음과 같은 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8d2f6732abd2e111bc9ecb3123f552f46a82a5d" translate="yes" xml:space="preserve">
          <source>If we took the backup on the master, then the coordinates will be in the &lt;code&gt;&lt;a href=&quot;../files-created-by-mariabackup/index#xtrabackup_binlog_info&quot;&gt;xtrabackup_binlog_info&lt;/a&gt;&lt;/code&gt; file. If we took the backup on another slave and if we provided the &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-slave-info&quot;&gt;--slave-info&lt;/a&gt;&lt;/code&gt; option, then the coordinates will be in the file &lt;code&gt;&lt;a href=&quot;../files-created-by-mariabackup/index#xtrabackup_slave_info&quot;&gt;xtrabackup_slave_info&lt;/a&gt;&lt;/code&gt; file.</source>
          <target state="translated">마스터에서 백업을 수행 한 경우 좌표는 &lt;code&gt;&lt;a href=&quot;../files-created-by-mariabackup/index#xtrabackup_binlog_info&quot;&gt;xtrabackup_binlog_info&lt;/a&gt;&lt;/code&gt; 파일에 있습니다. 다른 슬레이브에서 백업을하고 &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-slave-info&quot;&gt;--slave-info&lt;/a&gt;&lt;/code&gt; 옵션을 제공 한 경우 좌표는 파일 &lt;code&gt;&lt;a href=&quot;../files-created-by-mariabackup/index#xtrabackup_slave_info&quot;&gt;xtrabackup_slave_info&lt;/a&gt;&lt;/code&gt; 파일에 있습니다.</target>
        </trans-unit>
        <trans-unit id="49e13f2a9c71ecef32cbcaa97e9662e1d5f64543" translate="yes" xml:space="preserve">
          <source>If we try to connect to the MariaDB server on &lt;code&gt;localhost&lt;/code&gt;, the client will bypass networking and attempt to connect to the server using a socket file in the local filesystem. However, this doesn't work when MariaDB is running inside a container because the server's filesystem is isolated from the host. The client can't access the socket file which is inside the container, so it fails to connect.</source>
          <target state="translated">&lt;code&gt;localhost&lt;/code&gt; 의 MariaDB 서버에 연결하려고 하면 클라이언트는 네트워킹을 무시하고 로컬 파일 시스템의 소켓 파일을 사용하여 서버에 연결을 시도합니다. 그러나 서버의 파일 시스템이 호스트와 분리되어 있기 때문에 MariaDB가 컨테이너 내에서 실행될 때는 작동하지 않습니다. 클라이언트는 컨테이너 내부에있는 소켓 파일에 액세스 할 수 없으므로 연결에 실패합니다.</target>
        </trans-unit>
        <trans-unit id="69310d37fd1790cd33701c84a4e70bc8544b1a15" translate="yes" xml:space="preserve">
          <source>If we want to allow authentication from LDAP users &lt;strong&gt;and&lt;/strong&gt; from local Unix users through &lt;code&gt;&lt;a href=&quot;https://linux.die.net/man/8/pam_unix&quot;&gt;pam_unix&lt;/a&gt;&lt;/code&gt;, while giving priority to the local users, then we could do this instead:</source>
          <target state="translated">로컬 사용자에게 우선 순위를 주면서 &lt;code&gt;&lt;a href=&quot;https://linux.die.net/man/8/pam_unix&quot;&gt;pam_unix&lt;/a&gt;&lt;/code&gt; 를 통해 LDAP 사용자 &lt;strong&gt;및&lt;/strong&gt; 로컬 Unix 사용자의 인증을 허용 하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="7974e787555be0ec79d5ce068474660ef5eb5b08" translate="yes" xml:space="preserve">
          <source>If we want to use GTIDs, then we will have to first set &lt;code&gt;&lt;a href=&quot;../gtid/index#gtid_slave_pos&quot;&gt;gtid_slave_pos&lt;/a&gt;&lt;/code&gt; to the &lt;a href=&quot;../gtid/index&quot;&gt;GTID&lt;/a&gt; coordinates that we pulled from either the &lt;code&gt;&lt;a href=&quot;../files-created-by-mariabackup/index#xtrabackup_binlog_info&quot;&gt;xtrabackup_binlog_info&lt;/a&gt;&lt;/code&gt; file or the &lt;code&gt;&lt;a href=&quot;../files-created-by-mariabackup/index#xtrabackup_slave_info&quot;&gt;xtrabackup_slave_info&lt;/a&gt;&lt;/code&gt; file in the backup directory. For example:</source>
          <target state="translated">GTID를 사용하려면 먼저 &lt;code&gt;&lt;a href=&quot;../gtid/index#gtid_slave_pos&quot;&gt;gtid_slave_pos&lt;/a&gt;&lt;/code&gt; 를 백업 디렉토리 의 &lt;code&gt;&lt;a href=&quot;../files-created-by-mariabackup/index#xtrabackup_binlog_info&quot;&gt;xtrabackup_binlog_info&lt;/a&gt;&lt;/code&gt; 파일 또는 &lt;code&gt;&lt;a href=&quot;../files-created-by-mariabackup/index#xtrabackup_slave_info&quot;&gt;xtrabackup_slave_info&lt;/a&gt;&lt;/code&gt; 파일에서 가져온 &lt;a href=&quot;../gtid/index&quot;&gt;GTID&lt;/a&gt; 좌표로 설정 해야 합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9c6bcc178d6fe74c4e7e9b1be6a185bb3728baed" translate="yes" xml:space="preserve">
          <source>If we want to use the &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt; file and position coordinates, then we would set &lt;code&gt;MASTER_LOG_FILE&lt;/code&gt; and &lt;code&gt;MASTER_LOG_POS&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;../change-master-to/index&quot;&gt;CHANGE MASTER TO&lt;/a&gt;&lt;/code&gt; command to the file and position coordinates that we pulled either the &lt;code&gt;&lt;a href=&quot;../files-created-by-mariabackup/index#xtrabackup_binlog_info&quot;&gt;xtrabackup_binlog_info&lt;/a&gt;&lt;/code&gt; file or the &lt;code&gt;&lt;a href=&quot;../files-created-by-mariabackup/index#xtrabackup_slave_info&quot;&gt;xtrabackup_slave_info&lt;/a&gt;&lt;/code&gt; file in the backup directory, depending on whether the backup was taken from the master or from a slave of the master. For example:</source>
          <target state="translated">우리가 사용하려는 경우 &lt;a href=&quot;../binary-log/index&quot;&gt;바이너리 로그&lt;/a&gt; 파일의 위치 좌표를, 우리가 설정합니다 &lt;code&gt;MASTER_LOG_FILE&lt;/code&gt; 과 &lt;code&gt;MASTER_LOG_POS&lt;/code&gt; 를 에 &lt;code&gt;&lt;a href=&quot;../change-master-to/index&quot;&gt;CHANGE MASTER TO&lt;/a&gt;&lt;/code&gt; 에 우리 중 하나를 뽑아하는 파일 및 위치 좌표를 명령 &lt;code&gt;&lt;a href=&quot;../files-created-by-mariabackup/index#xtrabackup_binlog_info&quot;&gt;xtrabackup_binlog_info&lt;/a&gt;&lt;/code&gt; 의 파일 또는 &lt;code&gt;&lt;a href=&quot;../files-created-by-mariabackup/index#xtrabackup_slave_info&quot;&gt;xtrabackup_slave_info&lt;/a&gt;&lt;/code&gt; 의 백업 디렉토리에있는 파일을에 따라 마스터에서 백업했는지 또는 마스터의 슬레이브에서 백업했는지 여부 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e5c2d19e8e83347bce1c5530726ebcf451c703ab" translate="yes" xml:space="preserve">
          <source>If write statements have a higher priority (default), the priority of individual write statements (&lt;a href=&quot;../insert/index&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;../replace/index&quot;&gt;REPLACE&lt;/a&gt;, &lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;../delete/index&quot;&gt;DELETE&lt;/a&gt;) can be changed via the &lt;code&gt;LOW_PRIORITY&lt;/code&gt; attribute, and the priority of a &lt;code&gt;SELECT&lt;/code&gt; statement can be raised via the &lt;code&gt;HIGH_PRIORITY&lt;/code&gt; attribute. Also, &lt;a href=&quot;../transactions-lock/index&quot;&gt;LOCK TABLES&lt;/a&gt; supports a &lt;code&gt;LOW_PRIORITY&lt;/code&gt; attribute for &lt;code&gt;WRITE&lt;/code&gt; locks.</source>
          <target state="translated">쓰기 명령문의 우선 순위가 더 높은 경우 (기본값) 개별 쓰기 명령문의 우선 순위 ( &lt;a href=&quot;../insert/index&quot;&gt;INSERT&lt;/a&gt; , &lt;a href=&quot;../replace/index&quot;&gt;REPLACE&lt;/a&gt; , &lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt; , &lt;a href=&quot;../delete/index&quot;&gt;DELETE&lt;/a&gt; )는 &lt;code&gt;LOW_PRIORITY&lt;/code&gt; 속성을 통해 변경 될 수 있으며 &lt;code&gt;SELECT&lt;/code&gt; 문의 우선 순위 는 &lt;code&gt;HIGH_PRIORITY&lt;/code&gt; 속성을 통해 올릴 수 있습니다 . 또한 &lt;a href=&quot;../transactions-lock/index&quot;&gt;LOCK TABLES&lt;/a&gt; 는 &lt;code&gt;WRITE&lt;/code&gt; 잠금에 대한 &lt;code&gt;LOW_PRIORITY&lt;/code&gt; 속성을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="f9f16c04f72556472acb82595b5ca0ada299fd1b" translate="yes" xml:space="preserve">
          <source>If x() returns a real, it is declared as follows:</source>
          <target state="translated">x ()가 실수를 반환하면 다음과 같이 선언됩니다.</target>
        </trans-unit>
        <trans-unit id="7f07c5f71352dedd0e5220d54457575dfecbc775" translate="yes" xml:space="preserve">
          <source>If x() returns a string (DECIMAL functions also return string values), it is declared as follows:</source>
          <target state="translated">x ()가 문자열을 반환하면 (DECIMAL 함수도 문자열 값을 반환) 다음과 같이 선언됩니다.</target>
        </trans-unit>
        <trans-unit id="e76698cbc20e3c723608d1413fd0c22f7ff7f4ac" translate="yes" xml:space="preserve">
          <source>If x() returns an integer, it is declared as follows:</source>
          <target state="translated">x ()가 정수를 반환하면 다음과 같이 선언됩니다.</target>
        </trans-unit>
        <trans-unit id="b1d68778b79c92fbed82646d74102f5f5e675ffa" translate="yes" xml:space="preserve">
          <source>If you &lt;a href=&quot;../starting-and-stopping-mariadb-starting-and-stopping-mariadb/index&quot;&gt;start&lt;/a&gt; MariaDB with &lt;code&gt;&lt;a href=&quot;../mysqld_safe/index&quot;&gt;mysqld_safe&lt;/a&gt;&lt;/code&gt;, then the error log can be redirected to the syslog. See &lt;a href=&quot;../mysqld_safe/index#configuring-mariadb-to-write-the-error-log-to-syslog&quot;&gt;mysqld_safe: Configuring MariaDB to Write the Error Log to Syslog&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../mysqld_safe/index&quot;&gt;mysqld_safe&lt;/a&gt;&lt;/code&gt; 로 MariaDB 를 &lt;a href=&quot;../starting-and-stopping-mariadb-starting-and-stopping-mariadb/index&quot;&gt;시작&lt;/a&gt; 하면 오류 로그를 syslog로 리디렉션 할 수 있습니다. 자세한 정보는 &lt;a href=&quot;../mysqld_safe/index#configuring-mariadb-to-write-the-error-log-to-syslog&quot;&gt;mysqld_safe : 오류 로그를 Syslog&lt;/a&gt; 에 쓰도록 MariaDB 구성 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5ffca10d9ad607384aed74807a8f5b347d1bd2b1" translate="yes" xml:space="preserve">
          <source>If you &lt;a href=&quot;../starting-and-stopping-mariadb-starting-and-stopping-mariadb/index&quot;&gt;start&lt;/a&gt; MariaDB with &lt;code&gt;&lt;a href=&quot;../systemd/index&quot;&gt;systemd&lt;/a&gt;&lt;/code&gt;, then the error log can also be redirected to the syslog. See &lt;a href=&quot;../systemd/index#configuring-mariadb-to-write-the-error-log-to-syslog&quot;&gt;Systemd: Configuring MariaDB to Write the Error Log to Syslog&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../systemd/index&quot;&gt;systemd&lt;/a&gt;&lt;/code&gt; 로 MariaDB 를 &lt;a href=&quot;../starting-and-stopping-mariadb-starting-and-stopping-mariadb/index&quot;&gt;시작&lt;/a&gt; 하면 오류 로그를 syslog로 리디렉션 할 수도 있습니다. 자세한 정보는 &lt;a href=&quot;../systemd/index#configuring-mariadb-to-write-the-error-log-to-syslog&quot;&gt;Systemd : 오류 로그를 Syslog&lt;/a&gt; 에 쓰도록 MariaDB 구성 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="da5fb99c8adcbdd323a8ba68c921edc50226d45d" translate="yes" xml:space="preserve">
          <source>If you KILL a DELETE (or any? query) on the master in the middle of its execution, what will be replicated?</source>
          <target state="translated">실행 도중 마스터에서 DELETE (또는 임의의 쿼리)를 종료하면 무엇이 복제됩니까?</target>
        </trans-unit>
        <trans-unit id="950adbfcc7fe0c43dc69ccee2a99cf1dd428e691" translate="yes" xml:space="preserve">
          <source>If you added the &lt;code&gt;apt&lt;/code&gt; repository by creating a &lt;a href=&quot;http://manpages.ubuntu.com/manpages/bionic/man5/sources.list.5.html&quot;&gt;source list&lt;/a&gt; file in &lt;code&gt;/etc/apt/sources.list.d/&lt;/code&gt;, then you can update the major release that the repository uses by updating the source list file in-place. For example, if you wanted to change the repository from &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt; to &lt;a href=&quot;../what-is-mariadb-103/index&quot;&gt;MariaDB 10.3&lt;/a&gt;, and if the source list file was at &lt;code&gt;/etc/apt/sources.list.d/MariaDB.list&lt;/code&gt;, then you could execute the following:</source>
          <target state="translated">&lt;code&gt;/etc/apt/sources.list.d/&lt;/code&gt; 에&lt;a href=&quot;http://manpages.ubuntu.com/manpages/bionic/man5/sources.list.5.html&quot;&gt;소스 목록&lt;/a&gt; 파일 을 작성 하여 &lt;code&gt;apt&lt;/code&gt; 저장소 를 추가 한 경우 , 소스 목록 파일을 그 자리에서 업데이트하여 저장소가 사용하는 주 릴리스를 업데이트 할 수 있습니다. 예를 들어, 리포지토리를 &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt; 에서 &lt;a href=&quot;../what-is-mariadb-103/index&quot;&gt;MariaDB 10.3&lt;/a&gt; 으로 변경 하고 소스 목록 파일이 &lt;code&gt;/etc/apt/sources.list.d/MariaDB.list&lt;/code&gt; 에있는 경우 다음을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5471092c49c107dac129da6ceba9f16e76acf974" translate="yes" xml:space="preserve">
          <source>If you added the &lt;code&gt;apt&lt;/code&gt; repository by creating a &lt;a href=&quot;https://manpages.ubuntu.com/manpages/bionic/man5/sources.list.5.html&quot;&gt;source list&lt;/a&gt; file in &lt;code&gt;/etc/apt/sources.list.d/&lt;/code&gt;, then you can update the major release that the repository uses by updating the source list file in-place. For example, if you wanted to change the repository from &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt; to &lt;a href=&quot;../what-is-mariadb-103/index&quot;&gt;MariaDB 10.3&lt;/a&gt;, and if the source list file was at &lt;code&gt;/etc/apt/sources.list.d/MariaDB.list&lt;/code&gt;, then you could execute the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aa6567a88df9ea473f681d95c4af8cc5ae72e7b" translate="yes" xml:space="preserve">
          <source>If you added the &lt;code&gt;apt&lt;/code&gt; repository by using the &lt;code&gt;&lt;a href=&quot;http://manpages.ubuntu.com/manpages/bionic/man1/add-apt-repository.1.html&quot;&gt;add-apt-repository&lt;/a&gt;&lt;/code&gt; command, then you can update the major release that the repository uses by using the the &lt;code&gt;&lt;a href=&quot;http://manpages.ubuntu.com/manpages/bionic/man1/add-apt-repository.1.html&quot;&gt;add-apt-repository&lt;/a&gt;&lt;/code&gt; command again.</source>
          <target state="translated">당신이 추가 한 경우 &lt;code&gt;apt&lt;/code&gt; 사용하여 저장소를 &lt;code&gt;&lt;a href=&quot;http://manpages.ubuntu.com/manpages/bionic/man1/add-apt-repository.1.html&quot;&gt;add-apt-repository&lt;/a&gt;&lt;/code&gt; 명령을 다음 주요 릴리스를 업데이트 할 수하여 사용하여 저장소를 사용하는 &lt;code&gt;&lt;a href=&quot;http://manpages.ubuntu.com/manpages/bionic/man1/add-apt-repository.1.html&quot;&gt;add-apt-repository&lt;/a&gt;&lt;/code&gt; 명령을 다시.</target>
        </trans-unit>
        <trans-unit id="b808672679a27b004b23cfcd5f2711d068984d07" translate="yes" xml:space="preserve">
          <source>If you added the &lt;code&gt;apt&lt;/code&gt; repository by using the &lt;code&gt;&lt;a href=&quot;https://manpages.ubuntu.com/manpages/bionic/man1/add-apt-repository.1.html&quot;&gt;add-apt-repository&lt;/a&gt;&lt;/code&gt; command, then you can update the major release that the repository uses by using the the &lt;code&gt;&lt;a href=&quot;https://manpages.ubuntu.com/manpages/bionic/man1/add-apt-repository.1.html&quot;&gt;add-apt-repository&lt;/a&gt;&lt;/code&gt; command again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f72c8f1913179b397a12e90e72ff769d1379bd85" translate="yes" xml:space="preserve">
          <source>If you already have an AWS account, you can skip this section.</source>
          <target state="translated">이미 AWS 계정이있는 경우이 섹션을 건너 뛸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5e5e2d165c7aee7246d40836ce08093a1f526be" translate="yes" xml:space="preserve">
          <source>If you also want to allow authentication from local Unix users, the &lt;code&gt;pam_unix&lt;/code&gt; PAM module adds &lt;a href=&quot;../authentication-plugin-pam/index#configuring-the-pam-service&quot;&gt;some additional configuration steps&lt;/a&gt; on a lot of systems. We basically have to give the user that runs &lt;code&gt;mysqld&lt;/code&gt; access to &lt;code&gt;/etc/shadow&lt;/code&gt;.</source>
          <target state="translated">로컬 Unix 사용자의 인증도 허용하려는 경우 &lt;code&gt;pam_unix&lt;/code&gt; PAM 모듈 은 많은 시스템에서 &lt;a href=&quot;../authentication-plugin-pam/index#configuring-the-pam-service&quot;&gt;몇 가지 추가 구성 단계&lt;/a&gt; 를 추가합니다 . 기본적으로 &lt;code&gt;mysqld&lt;/code&gt; 를 실행하는 사용자 에게 &lt;code&gt;/etc/shadow&lt;/code&gt; 에 대한 액세스 권한 을 부여해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ef1fcceebe9f1ee056866b7d8a9c7a771af7d74f" translate="yes" xml:space="preserve">
          <source>If you also want to change the collation, you have to use the &lt;code&gt;COLLATE&lt;/code&gt; operator:</source>
          <target state="translated">데이터 정렬을 변경하려면 &lt;code&gt;COLLATE&lt;/code&gt; 연산자 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6ecb092d594538de97f0a17e22336fa210fe9ba8" translate="yes" xml:space="preserve">
          <source>If you also want to remove config files, remove &lt;code&gt;/usr/local/mariadb/etc/&lt;/code&gt;</source>
          <target state="translated">구성 파일도 제거하려면 &lt;code&gt;/usr/local/mariadb/etc/&lt;/code&gt; 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="4a26ea9f822d07e230cc25f89316f65e02ab1dba" translate="yes" xml:space="preserve">
          <source>If you are 100% sure this applies to you, you can just run &lt;code&gt;mysql_upgrade&lt;/code&gt; with the &lt;code&gt;---upgrade-system-tables&lt;/code&gt; option.</source>
          <target state="translated">이것이 100 % 확실하다고 확신한다면 &lt;code&gt;---upgrade-system-tables&lt;/code&gt; 옵션으로 &lt;code&gt;mysql_upgrade&lt;/code&gt; 를 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="14e3dea444935aa87e6dc78008906039ab363be1" translate="yes" xml:space="preserve">
          <source>If you are GROUPing BY an expression (including function calls), you cannot use the GROUP BY; stop.</source>
          <target state="translated">표현식을 그룹화 (함수 호출 포함)하는 경우 GROUP BY를 사용할 수 없습니다. 중지.</target>
        </trans-unit>
        <trans-unit id="041c8f899a01c049daf358977022946a71866310" translate="yes" xml:space="preserve">
          <source>If you are ORDERing BY an expression (including function calls), you cannot use the ORDER BY; stop.</source>
          <target state="translated">함수 호출을 포함한 표현식을 ORDERING BY하면 ORDER BY를 사용할 수 없습니다. 중지.</target>
        </trans-unit>
        <trans-unit id="a32bf306eba551037d700c2a9a3dc05f2a577101" translate="yes" xml:space="preserve">
          <source>If you are a super user running a log batch job that you don't want to have logged (for example mysqldump), do:</source>
          <target state="translated">로그하지 않으려는 로그 배치 작업을 실행하는 수퍼 유저 인 경우 (예 : mysqldump) 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="7801ca9ceb9cbd90f37b44c310bf934efecdcfb9" translate="yes" xml:space="preserve">
          <source>If you are already logged in as 'guest' you will need to log out and back in again for this change to take effect.</source>
          <target state="translated">이미 'guest'로 로그인 한 경우이 변경 사항을 적용하려면 로그 아웃했다가 다시 로그인해야합니다.</target>
        </trans-unit>
        <trans-unit id="46d67cc633d18edd4b861fe32faacaa8b4305a64" translate="yes" xml:space="preserve">
          <source>If you are already logged in as 'mysql' you will need to log out and back in again for this change to take effect.</source>
          <target state="translated">이미 'mysql'로 로그인 한 경우이 변경 사항을 적용하려면 로그 아웃했다가 다시 로그인해야합니다.</target>
        </trans-unit>
        <trans-unit id="2c4cda792eae11ba2382deab155e92b1c55a46fc" translate="yes" xml:space="preserve">
          <source>If you are already logged in as 'mysql' you will need to logout, then login for this change to take effect.</source>
          <target state="translated">이미 'mysql'로 로그인 한 경우 로그 아웃 한 다음 로그인하여이 변경 사항을 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="efac9843e487372af3fd4603fd7889d73222c5bf" translate="yes" xml:space="preserve">
          <source>If you are already using &lt;a href=&quot;../what-is-mariadb-101/index&quot;&gt;MariaDB 10.1&lt;/a&gt; on your Debian 8 &quot;Jessie&quot; machine, you can choose to continue to use the MariaDB repositories or move to using the Debian repositories as with &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt; and 10.0. In either case, the upgrade will at most be just a minor upgrade from one version of &lt;a href=&quot;../what-is-mariadb-101/index&quot;&gt;MariaDB 10.1&lt;/a&gt; to a newer version. In the case that you are already on the current version of MariaDB that exists in the Debian repositories or a newer one) MariaDB will not be upgraded during the system upgrade but will be upgraded when future versions of MariaDB are released.</source>
          <target state="translated">데비안 8 &quot;Jessie&quot;머신에서 이미 &lt;a href=&quot;../what-is-mariadb-101/index&quot;&gt;MariaDB 10.1&lt;/a&gt; 을 사용하고 있다면 MariaDB 리포지토리를 계속 사용하거나 &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt; 및 10.0에서 와 같이 데비안 리포지토리를 사용하도록 선택할 수 있습니다 . 어느 경우 든 업그레이드는 기껏해야 한 버전의 &lt;a href=&quot;../what-is-mariadb-101/index&quot;&gt;MariaDB 10.1&lt;/a&gt; 에서 최신 버전으로 의 사소한 업그레이드 일뿐 입니다. 이미 데비안 리포지토리 또는 최신 버전에 존재하는 MariaDB의 현재 버전을 사용중인 경우 MariaDB는 시스템 업그레이드 중에 업그레이드되지 않지만 MariaDB의 향후 버전이 릴리스 될 때 업그레이드됩니다.</target>
        </trans-unit>
        <trans-unit id="f884ee496de08424aec0020fe7198a3d759d203e" translate="yes" xml:space="preserve">
          <source>If you are building a Galera cluster by starting with one node as a Slave to an existing non-Galera system, and if you have multi-row INSERTs that depend on AUTO_INCREMENTs, the read this Percona blog</source>
          <target state="translated">기존의 비 Galera 시스템의 슬레이브로 하나의 노드로 시작하여 Galera 클러스터를 구축하고 AUTO_INCREMENTs에 의존하는 다중 행 INSERT가있는 경우이 Percona 블로그를 읽으십시오</target>
        </trans-unit>
        <trans-unit id="447f2762cf463b6bf23d480859da96d3272aa379" translate="yes" xml:space="preserve">
          <source>If you are building a large table then for best performance add the index after the table is populated with data. This is to increase the insert performance and remove the index overhead during inserts.</source>
          <target state="translated">큰 테이블을 작성하는 경우 최상의 성능을 위해 테이블이 데이터로 채워진 후 색인을 추가하십시오. 이는 인서트 성능을 높이고 인서트 중에 인덱스 오버 헤드를 제거하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="dc92f1624ae68b5b133ea92a91e06af112fbb468" translate="yes" xml:space="preserve">
          <source>If you are calling mysql-test-run.pl directly, you do not need to specify a timeout.</source>
          <target state="translated">mysql-test-run.pl을 직접 호출하는 경우 시간 초과를 지정할 필요가 없습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
