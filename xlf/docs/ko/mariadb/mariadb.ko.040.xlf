<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="mariadb">
    <body>
      <group id="mariadb">
        <trans-unit id="0111242c184e6c7ea163b6e1c4d76a68a045d914" translate="yes" xml:space="preserve">
          <source>The InnoDB Buffer Pool size can be set dynamically from MariaDB 10.2.2.</source>
          <target state="translated">InnoDB 버퍼 풀 크기는 MariaDB 10.2.2에서 동적으로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b522be8b9b32aeafb07c58437a853cb0c686a08" translate="yes" xml:space="preserve">
          <source>The InnoDB Lock Monitor displays additional lock information.</source>
          <target state="translated">InnoDB 잠금 모니터는 추가 잠금 정보를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="f95c0ff11943f68d6e759c7f2584a4d4b258ef6e" translate="yes" xml:space="preserve">
          <source>The InnoDB Table Monitor is deprecated, and may be removed in a future version of MariaDB.</source>
          <target state="translated">InnoDB 테이블 모니터는 더 이상 사용되지 않으며 향후 MariaDB 버전에서 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="26ab10eac8e65bedad72bdad3a9a992936bbe607" translate="yes" xml:space="preserve">
          <source>The InnoDB Tablespace Monitor is deprecated, and may be removed in a future version of MariaDB.</source>
          <target state="translated">InnoDB 테이블 스페이스 모니터는 더 이상 사용되지 않으며 이후 버전의 MariaDB에서 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54dfecfaffde12c7e7f2bcddfbc402f5f8191261" translate="yes" xml:space="preserve">
          <source>The InnoDB storage engine does not maintain internal row counts. Transactions isolate writes, which means that concurrent transactions will not have the same row counts.</source>
          <target state="translated">InnoDB 스토리지 엔진은 내부 행 개수를 유지하지 않습니다. 트랜잭션은 쓰기를 분리합니다. 즉, 동시 트랜잭션의 행 수가 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="76c96f630ed2b8eb1f25f0125f8e43041fd14dc2" translate="yes" xml:space="preserve">
          <source>The InnoDB storage engine has the following limitations.</source>
          <target state="translated">InnoDB 스토리지 엔진에는 다음과 같은 제한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb3b86891dead00ab8134ccb77b922bbf8c82e20" translate="yes" xml:space="preserve">
          <source>The InnoDB-specific Information Schema tables also contain information about the InnoDB foreign keys. The foreign key information is stored in the &lt;code&gt;&lt;a href=&quot;../information-schema-innodb_sys_foreign-table/index&quot;&gt;INNODB_SYS_FOREIGN&lt;/a&gt;&lt;/code&gt;. Data about the individual columns are stored in &lt;code&gt;&lt;a href=&quot;../information-schema-innodb_sys_foreign_cols-table/index&quot;&gt;INNODB_SYS_FOREIGN_COLS&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">InnoDB 관련 정보 스키마 테이블에는 InnoDB 외래 키에 대한 정보도 포함되어 있습니다. 외래 키 정보는 &lt;code&gt;&lt;a href=&quot;../information-schema-innodb_sys_foreign-table/index&quot;&gt;INNODB_SYS_FOREIGN&lt;/a&gt;&lt;/code&gt; 에 저장됩니다 . 개별 컬럼에 대한 데이터는 &lt;code&gt;&lt;a href=&quot;../information-schema-innodb_sys_foreign_cols-table/index&quot;&gt;INNODB_SYS_FOREIGN_COLS&lt;/a&gt;&lt;/code&gt; 에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="e7e44932c25c2bba8f7ef36178b895da54d1c017" translate="yes" xml:space="preserve">
          <source>The Instance that was launched is ColumnStore Performance Module #1. This is the primary &quot;pm&quot; where the install process will always start. The install and configuration script, postConfigure is run to initiate the install process.</source>
          <target state="translated">시작된 인스턴스는 ColumnStore Performance Module # 1입니다. 설치 프로세스가 항상 시작되는 기본 &quot;pm&quot;입니다. 설치 및 구성 스크립트 postConfigure가 실행되어 설치 프로세스를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="0fe973d41969cb283c82bc7c59a02e3715c68288" translate="yes" xml:space="preserve">
          <source>The Ips table's size is proportional to the number of blocks. A million 'owned' blocks may be 20-50MB. This varies due to</source>
          <target state="translated">Ips 테이블의 크기는 블록 수에 비례합니다. 백만 개의 '소유'블록은 20-50MB 일 수 있습니다. 이로 인해 달라집니다</target>
        </trans-unit>
        <trans-unit id="649dbdbed59c99ee27c0f08fe7d26150be68f5ec" translate="yes" xml:space="preserve">
          <source>The JDBC table type should be distributed with all recent versions of MariaDB. However, if the automatic compilation of it is possible after the java JDK was installed, the complete distribution of it is not fully implemented in older versions. The distributed JdbcInterface.jar file contains the JdbcInterface wrapper only. New versions distribute a JavaWrappers.jar that contains all currently existing wrappers.</source>
          <target state="translated">JDBC 테이블 유형은 모든 최신 버전의 MariaDB와 함께 배포해야합니다. 그러나 Java JDK를 설치 한 후 자동 컴파일이 가능하면 완전한 배포가 이전 버전에서는 완전히 구현되지 않습니다. 분산 JdbcInterface.jar 파일에는 JdbcInterface 랩퍼 만 포함됩니다. 새로운 버전은 현재 존재하는 모든 래퍼를 포함하는 JavaWrappers.jar을 배포합니다.</target>
        </trans-unit>
        <trans-unit id="14753fffecdf467ad08beaae171e78b4edbf7825" translate="yes" xml:space="preserve">
          <source>The JDBC table type was introduced with Connect 1.04.0006, released with &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1022-release-notes/&quot;&gt;MariaDB 10.2.2&lt;/a&gt;, &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10117-release-notes/&quot;&gt;MariaDB 10.1.17&lt;/a&gt; and &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10027-release-notes/&quot;&gt;MariaDB 10.0.27&lt;/a&gt;.</source>
          <target state="translated">JDBC 테이블 유형은 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1022-release-notes/&quot;&gt;MariaDB 10.2.2&lt;/a&gt; , &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10117-release-notes/&quot;&gt;MariaDB 10.1.17&lt;/a&gt; 및 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10027-release-notes/&quot;&gt;MariaDB 10.0.27&lt;/a&gt; 과 함께 릴리스 된 Connect 1.04.0006과 함께 도입되었습니다 .</target>
        </trans-unit>
        <trans-unit id="1e5ad3e6c891cc0182e547cbd6d2bdac63b0b3aa" translate="yes" xml:space="preserve">
          <source>The JSON UDF&amp;rsquo;s and the direct Jpath &amp;ldquo;*&amp;rdquo; facility are powerful tools to convert table and files to the JSON format. For instance, the file &lt;code&gt;biblio3.json&lt;/code&gt; we used previously can be obtained by converting the &lt;code&gt;xsample.xml file&lt;/code&gt;. This can be done like this:</source>
          <target state="translated">JSON UDF와 직접 Jpath &quot;*&quot;기능은 테이블과 파일을 JSON 형식으로 변환하는 강력한 도구입니다. 예를 들어, 파일 &lt;code&gt;biblio3.json&lt;/code&gt; 우리가 이전에 사용되는 변환에 의해 얻을 수 &lt;code&gt;xsample.xml file&lt;/code&gt; . 이것은 다음과 같이 수행 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="3e558d500ac2ae41a1a25637c18b68a2efc791f3" translate="yes" xml:space="preserve">
          <source>The JSON alias was added in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1027-release-notes/&quot;&gt;MariaDB 10.2.7&lt;/a&gt;. This was done to make it possible to use JSON columns in &lt;a href=&quot;../binary-log-formats/index#statement-based&quot;&gt;statement based&lt;/a&gt;&lt;a href=&quot;../high-availability-performance-tuning-mariadb-replication/index&quot;&gt;replication&lt;/a&gt; from MySQL to MariaDB and to make it possible for MariaDB to read &lt;a href=&quot;../mysqldump/index&quot;&gt;mysqldumps&lt;/a&gt; from MySQL.</source>
          <target state="translated">JSON 별칭은 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1027-release-notes/&quot;&gt;MariaDB 10.2.7&lt;/a&gt; 에 추가되었습니다 . 이는 MySQL에서 MariaDB 로의 &lt;a href=&quot;../binary-log-formats/index#statement-based&quot;&gt;명령문 기반 &lt;/a&gt;&lt;a href=&quot;../high-availability-performance-tuning-mariadb-replication/index&quot;&gt;복제&lt;/a&gt; 에서 JSON 열을 사용 하고 MariaDB 가 MySQL에서 &lt;a href=&quot;../mysqldump/index&quot;&gt;mysqldump&lt;/a&gt; 를 읽을 수 있도록하기 위해 수행되었습니다 .</target>
        </trans-unit>
        <trans-unit id="a1be6d7d10f0fe28a95a5250b26e8df647543bb4" translate="yes" xml:space="preserve">
          <source>The JSON document can be queried and manipulated using MariaDB's &lt;a href=&quot;../json-functions/index&quot;&gt;JSON functions&lt;/a&gt;.</source>
          <target state="translated">MariaDB의 &lt;a href=&quot;../json-functions/index&quot;&gt;JSON 함수를&lt;/a&gt; 사용하여 JSON 문서를 쿼리하고 조작 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="abf90a3d4e91a2d98387382908c217df704af27d" translate="yes" xml:space="preserve">
          <source>The JSON document can be stored in a column that uses one of the following data types:</source>
          <target state="translated">JSON 문서는 다음 데이터 유형 중 하나를 사용하는 열에 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76ac4cfed95e8e33c833e2697466b7ae27ccd6a8" translate="yes" xml:space="preserve">
          <source>The JSON nosql language has all the features to be used as an alternative to dynamic columns. For instance, take the following example of dynamic columns:</source>
          <target state="translated">JSON nosql 언어에는 동적 열의 대안으로 사용될 모든 기능이 있습니다. 예를 들어 다음과 같은 동적 열 예를 들어보십시오.</target>
        </trans-unit>
        <trans-unit id="9a8c44eafc605af6ee270365a84414408bf557c7" translate="yes" xml:space="preserve">
          <source>The JSON table type was introduced in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10016-release-notes/&quot;&gt;MariaDB 10.0.16&lt;/a&gt;.</source>
          <target state="translated">JSON 테이블 유형은 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10016-release-notes/&quot;&gt;MariaDB 10.0.16&lt;/a&gt; 에서 도입되었습니다 .</target>
        </trans-unit>
        <trans-unit id="8cc5fda2c55061ca148a809ee7cda8a61e6ee24e" translate="yes" xml:space="preserve">
          <source>The JSON type in MySQL stores the JSON object in a compact form, not as &lt;a href=&quot;../longtext/index&quot;&gt;LONGTEXT&lt;/a&gt; as in MariaDB. This means that row based replication will not work for JSON types from MySQL to MariaDB.</source>
          <target state="translated">MySQL의 JSON 유형은 JSON 객체 를 MariaDB 처럼 &lt;a href=&quot;../longtext/index&quot;&gt;LONGTEXT가&lt;/a&gt; 아닌 간단한 형식으로 저장합니다 . 이것은 행 기반 복제가 MySQL에서 MariaDB에 이르는 JSON 유형에 대해 작동하지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="169321d0154130626442fd1130fcebb9ff840709" translate="yes" xml:space="preserve">
          <source>The Java SDK is installed on your system.</source>
          <target state="translated">Java SDK가 시스템에 설치되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7a037608717d9b786d6c2bea572cd44b298f7e1" translate="yes" xml:space="preserve">
          <source>The Java part needed to use the API in Java</source>
          <target state="translated">Java에서 API를 사용하는 데 필요한 Java 부분</target>
        </trans-unit>
        <trans-unit id="acf8646e18b69c79481dcbc8da88039bc016531f" translate="yes" xml:space="preserve">
          <source>The Java version of the SDK provides a very similar API to the C++ one so the pdf documentation can generally be transposed 1 for 1 to understand the API calls. A dedicated Java usage documentation was added with version 1.1.6.</source>
          <target state="translated">SDK의 Java 버전은 C ++ API와 매우 유사한 API를 제공하므로 pdf 문서는 일반적으로 1에서 1로 바뀌어 API 호출을 이해할 수 있습니다. 전용 Java 사용 설명서가 버전 1.1.6과 함께 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="f3e9a970ac2862c5167c1d7112c51c97ce3a5cfa" translate="yes" xml:space="preserve">
          <source>The JdbcInterface wrapper is always usable when Java is present on your machine. Binary distributions have this wrapper already compiled as a JdbcInterface.jar file installed in the plugin directory whose path is automatically included in the class path of the JVM. Therefore there is no need to worry about its path. Recent versions also add a JavaWrappers.jar that contains all wrappers.</source>
          <target state="translated">JdbcInterface 랩퍼는 시스템에 Java가있을 때 항상 사용할 수 있습니다. 바이너리 배포판에는이 래퍼가 JdbcInterface.jar 파일로 이미 컴파일되어 있으며,이 경로는 JVM의 클래스 경로에 자동으로 경로가 포함 된 플러그인 디렉토리에 설치되어 있습니다. 따라서 경로에 대해 걱정할 필요가 없습니다. 최신 버전은 또한 모든 랩퍼를 포함하는 JavaWrappers.jar을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="c9b4a0428de742b542c82cef77ae66737bccd37b" translate="yes" xml:space="preserve">
          <source>The Jira task for it was &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-9197&quot;&gt;MDEV-9197&lt;/a&gt;.</source>
          <target state="translated">Jira의 임무는 &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-9197&quot;&gt;MDEV-9197이었습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4d2e19a671783f0d9762f388ebbe3c1d49143988" translate="yes" xml:space="preserve">
          <source>The Jpath Specification</source>
          <target state="translated">Jpath 사양</target>
        </trans-unit>
        <trans-unit id="f079b7bfc444a5c7a678287cf3eb99c64eb18a83" translate="yes" xml:space="preserve">
          <source>The Jpath of the object option has the same syntax than the column Jpath but of course all array step must be specified using the [n] (until Connect 1.5) or n (from Connect 1.6) format.</source>
          <target state="translated">오브젝트 옵션의 Jpath는 Jpath 열과 동일한 구문을 갖지만 물론 모든 배열 단계는 [n] (Connect 1.5까지) 또는 n (Connect 1.6부터) 형식을 사용하여 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="87670262a12af8094ff79a9ed2b67cdce31b3770" translate="yes" xml:space="preserve">
          <source>The Kafka data adapter streams all messages published to Apache Kafka topics in Avro format to MariaDB AX automatically and continuously - enabling data from many sources to be streamed and collected for analysis without complex code. The Kafka adapter is built using &lt;a href=&quot;https://cwiki.apache.org/confluence/display/KAFKA/Clients#Clients-C/C++&quot;&gt;librdkafka&lt;/a&gt; and the &lt;a href=&quot;../columnstore-bulk-write-sdk&quot;&gt;MariaDB ColumnStore bulk write SDK&lt;/a&gt;</source>
          <target state="translated">Kafka 데이터 어댑터는 Apache Kafka 토픽에 게시 된 모든 메시지를 Avro 형식으로 MariaDB AX에 자동으로 지속적으로 스트리밍하여 복잡한 코드없이 분석을 위해 여러 소스의 데이터를 스트리밍 및 수집 할 수 있습니다. Kafka 어댑터는 &lt;a href=&quot;https://cwiki.apache.org/confluence/display/KAFKA/Clients#Clients-C/C++&quot;&gt;librdkafka&lt;/a&gt; 및 &lt;a href=&quot;../columnstore-bulk-write-sdk&quot;&gt;MariaDB ColumnStore 대량 쓰기 SDK를&lt;/a&gt; 사용하여 빌드됩니다.</target>
        </trans-unit>
        <trans-unit id="d4fb8dda155c417191583fdf91b69213638641eb" translate="yes" xml:space="preserve">
          <source>The Key ID is: &lt;code&gt;C74CD1D8&lt;/code&gt;</source>
          <target state="translated">키 ID는 &lt;code&gt;C74CD1D8&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0b447f27a07ecccf020d5d164cd2ac4ae38466f8" translate="yes" xml:space="preserve">
          <source>The KnowledgeBase page you linked seems to be wrong. Here is the output of: HELP 'timestamp';</source>
          <target state="translated">연결 한 KnowledgeBase 페이지가 잘못된 것 같습니다. 결과는 다음과 같습니다. HELP 'timestamp';</target>
        </trans-unit>
        <trans-unit id="c1b1c658231ed524b813ddadaa069b7aff9511c4" translate="yes" xml:space="preserve">
          <source>The LAG() function was first introduced with other &lt;a href=&quot;../window-functions/index&quot;&gt;window functions&lt;/a&gt; in &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt;.</source>
          <target state="translated">LAG는 () 함수는 처음 도입 된 다른 &lt;a href=&quot;../window-functions/index&quot;&gt;윈도우 함수&lt;/a&gt; 에 &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0f990a7224b9cf40d43c513b87fc2488a227a3ae" translate="yes" xml:space="preserve">
          <source>The LDAP user &lt;code&gt;foo&lt;/code&gt; should be mapped to the MariaDB user &lt;code&gt;bar&lt;/code&gt;. (&lt;code&gt;foo: bar&lt;/code&gt;)</source>
          <target state="translated">LDAP 사용자 &lt;code&gt;foo&lt;/code&gt; 는 MariaDB 사용자 &lt;code&gt;bar&lt;/code&gt; 매핑되어야합니다 . ( &lt;code&gt;foo: bar&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="7d786a2da71bac4c12d5f318880312ecf3409fa8" translate="yes" xml:space="preserve">
          <source>The LEAD() function was first introduced with other &lt;a href=&quot;../window-functions/index&quot;&gt;window functions&lt;/a&gt; in &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt;.</source>
          <target state="translated">리드 () 함수는 처음 도입 된 다른 &lt;a href=&quot;../window-functions/index&quot;&gt;윈도우 함수&lt;/a&gt; 에 &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0bb7f568e95a1ad4db14696e8247e8022b18f020" translate="yes" xml:space="preserve">
          <source>The LEFT JOIN .. IS NULL finds the `foo`s that are not yet in Foos.</source>
          <target state="translated">LEFT JOIN .. IS NULL은 아직 Foos에없는`foo`를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="8c6725f433c5521e7abafd076a63c60299dd21b9" translate="yes" xml:space="preserve">
          <source>The LIKE clause, if present on its own, indicates which function names to match.</source>
          <target state="translated">LIKE 절이있는 경우, 일치하는 함수 이름을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3b1e4050171d664afe34dccab96ded4c8b8950d0" translate="yes" xml:space="preserve">
          <source>The LIMIT clause, applied after WITH ROLLUP:</source>
          <target state="translated">WITH ROLLUP 뒤에 적용되는 LIMIT 절 :</target>
        </trans-unit>
        <trans-unit id="3d1274ff76eb9bf3c0ddc3e56322d53ed35b2ab1" translate="yes" xml:space="preserve">
          <source>The LOAD DATA INFILE statement reads rows from a text file into a table at a very high speed. The file name must be given as a literal string.</source>
          <target state="translated">LOAD DATA INFILE 문은 텍스트 파일의 행을 매우 빠른 속도로 테이블로 읽습니다. 파일 이름은 리터럴 문자열로 제공되어야합니다.</target>
        </trans-unit>
        <trans-unit id="49233d9999fbb0c9f09d9e1cddd3ffe32352d1d0" translate="yes" xml:space="preserve">
          <source>The LOAD XML statement reads data from an XML file into a table. The &lt;code&gt;file_name&lt;/code&gt; must be given as a literal string. The &lt;code&gt;tagname&lt;/code&gt; in the optional ROWS IDENTIFIED BY clause must also be given as a literal string, and must be surrounded by angle brackets (&amp;lt; and &amp;gt;).</source>
          <target state="translated">LOAD XML 문은 XML 파일에서 테이블로 데이터를 읽습니다. &lt;code&gt;file_name&lt;/code&gt; 리터럴 문자열로 제공해야합니다. &lt;code&gt;tagname&lt;/code&gt; 절에 의해 식별되는 옵션 행은 리터럴 문자열로 제공해야하며 (&amp;lt;및&amp;gt;) 꺾쇠 괄호로 묶어야합니다.</target>
        </trans-unit>
        <trans-unit id="0b44367ea2cf5d4614cf505f9f5b6ea6170183f2" translate="yes" xml:space="preserve">
          <source>The LXDE and Gnome images contain documentation under &lt;code&gt;/srv/PDF&lt;/code&gt;. Including instructions on how to create your own Debian live images in live mode (you need 16GB RAM or more to be able to do this). See the README, README.live, and live-manual.en.pdf files under &lt;code&gt;/srv/PDF&lt;/code&gt; for details.</source>
          <target state="translated">LXDE 및 Gnome 이미지에는 &lt;code&gt;/srv/PDF&lt;/code&gt; 에 문서가 있습니다. 라이브 모드에서 자신 만의 데비안 라이브 이미지를 만드는 방법에 대한 지침 포함 (이 작업을 수행하려면 16GB RAM 이상이 필요합니다). 자세한 내용은 &lt;code&gt;/srv/PDF&lt;/code&gt; 의 README, README.live 및 live-manual.en.pdf 파일 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="55581718a599a5ef704993f18f4a9d85821f094d" translate="yes" xml:space="preserve">
          <source>The Logical Block Identifier (LBID) for the block containing the physical row</source>
          <target state="translated">실제 행을 포함하는 블록의 논리 블록 식별자 (LBID)</target>
        </trans-unit>
        <trans-unit id="a512aa30de2a0e0801494268a7d884e0940203f2" translate="yes" xml:space="preserve">
          <source>The Logical Block Identifier (LBID) for the first block in the extent containing the physical row</source>
          <target state="translated">실제 행을 포함하는 익스텐트의 첫 번째 블록에 대한 논리 블록 식별자 (LBID)</target>
        </trans-unit>
        <trans-unit id="02bab62fbdfbd5e1d78fd0e97f77f334cc0909cd" translate="yes" xml:space="preserve">
          <source>The MBR (Minimum Bounding Rectangle), or Envelope is the bounding geometry, formed by the minimum and maximum (X,Y) coordinates:</source>
          <target state="translated">MBR (Minimum Bounding Rectangle) 또는 Envelope는 최소 및 최대 (X, Y) 좌표로 구성된 경계 형상입니다.</target>
        </trans-unit>
        <trans-unit id="7160a637a6c4040d642b1cecc880a092d8cb475d" translate="yes" xml:space="preserve">
          <source>The MEDIAN() &lt;a href=&quot;../window-functions/index&quot;&gt;window function&lt;/a&gt; was first introduced with in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1033-release-notes/&quot;&gt;MariaDB 10.3.3&lt;/a&gt;.</source>
          <target state="translated">MEDIAN () &lt;a href=&quot;../window-functions/index&quot;&gt;창 함수&lt;/a&gt; 는 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1033-release-notes/&quot;&gt;MariaDB 10.3.3&lt;/a&gt; 에서 처음 도입되었습니다 .</target>
        </trans-unit>
        <trans-unit id="186ce9773ea2d11e9a5d8828ab06ae498a9b1297" translate="yes" xml:space="preserve">
          <source>The MEMORY storage engine permits indexes to be either B-tree or Hash. Hash is the default type for MEMORY. See &lt;a href=&quot;../storage-engine-index-types/index&quot;&gt;Storage Engine index types&lt;/a&gt; for more on their characteristics.</source>
          <target state="translated">MEMORY 스토리지 엔진은 인덱스가 B- 트리 또는 해시가되도록합니다. MEMORY의 기본 유형은 해시입니다. 특성에 대한 자세한 내용은 &lt;a href=&quot;../storage-engine-index-types/index&quot;&gt;스토리지 엔진 인덱스 유형&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0e3046b93ac38c25a723ae75dded135f1228a347" translate="yes" xml:space="preserve">
          <source>The MERGE storage engine, also known as the MRG_MyISAM engine, is a collection of identical &lt;a href=&quot;../myisam/index&quot;&gt;MyISAM&lt;/a&gt; tables that can be used as one. &quot;Identical&quot; means that all tables have identical column and index information. You cannot merge MyISAM tables in which the columns are listed in a different order, do not have exactly the same columns, or have the indexes in different order. However, any or all of the MyISAM tables can be compressed with &lt;a href=&quot;../myisampack/index&quot;&gt;myisampack&lt;/a&gt;. Columns names and indexes names can be different, as long as data types and NULL/NOT NULL clauses are the same. Differences in table options such as AVG_ROW_LENGTH, MAX_ROWS, or PACK_KEYS do not matter.</source>
          <target state="translated">MRG_MyISAM 엔진이라고도하는 MERGE 스토리지 엔진 은 하나로서 사용할 수있는 동일한 &lt;a href=&quot;../myisam/index&quot;&gt;MyISAM&lt;/a&gt; 테이블 의 모음입니다 . &quot;동일&quot;은 모든 테이블에 동일한 열 및 인덱스 정보가 있음을 의미합니다. 열이 다른 순서로 나열되거나 정확히 같은 열이 없거나 다른 순서로 인덱스가있는 MyISAM 테이블을 병합 할 수 없습니다. 그러나 MyISAM 테이블 중 일부 또는 전부를 &lt;a href=&quot;../myisampack/index&quot;&gt;myisampack&lt;/a&gt; 으로 압축 할 수 있습니다 . 데이터 유형과 NULL / NOT NULL 절이 동일한 한 열 이름과 인덱스 이름이 다를 수 있습니다. AVG_ROW_LENGTH, MAX_ROWS 또는 PACK_KEYS와 같은 테이블 옵션의 차이점은 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6efe09d739ddbf5f8e824242d9e00c258bc7da61" translate="yes" xml:space="preserve">
          <source>The MSI installer package requires property names to be all capitals and contain only English letters. By convention, for a boolean property, an empty value means &quot;false&quot; and a non-empty is &quot;true&quot;.</source>
          <target state="translated">MSI 설치 프로그램 패키지는 속성 이름이 모두 대문자 여야하며 영어 문자 만 포함해야합니다. 일반적으로 부울 속성의 경우 빈 값은 &quot;false&quot;를 의미하고 비어 있지 않은 것은 &quot;true&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="d325b1e11ee216b84c2a18b2b5a10b871a4a0540" translate="yes" xml:space="preserve">
          <source>The MSI installer supports silent installations as well. In its simplest form silent installation with all defaults can be performed from an elevated command prompt like this:</source>
          <target state="translated">MSI 설치 관리자는 자동 설치도 지원합니다. 가장 간단한 형태의 모든 기본값으로 자동 설치는 다음과 같이 관리자 권한 명령 프롬프트에서 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b35fd8d938ff7db7a654aaa0a8824c62cb7ea323" translate="yes" xml:space="preserve">
          <source>The MYSQL type uses similar methods than the ODBC type to implement the &lt;a href=&quot;../insert/index&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt; and &lt;a href=&quot;../delete/index&quot;&gt;DELETE&lt;/a&gt; commands. Refer to the ODBC chapter for the restrictions concerning them.</source>
          <target state="translated">MYSQL 유형은 ODBC 유형과 유사한 메소드를 사용하여 &lt;a href=&quot;../insert/index&quot;&gt;INSERT&lt;/a&gt; , &lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt; 및 &lt;a href=&quot;../delete/index&quot;&gt;DELETE&lt;/a&gt; 명령 을 구현 합니다. 이에 관한 제한 사항은 ODBC 장을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3ccee13f86986624a602eace9c83ab1ce94607b9" translate="yes" xml:space="preserve">
          <source>The MariaDB &lt;a href=&quot;../error-log/index&quot;&gt;error log&lt;/a&gt; is not encrypted. The error log can contain query text and data in some cases, including crashes, assertion failures, and cases where InnoDB/XtraDB write monitor output to the log to aid in debugging. It can be sent to syslog too, if needed.</source>
          <target state="translated">MariaDB &lt;a href=&quot;../error-log/index&quot;&gt;오류 로그&lt;/a&gt; 는 암호화되지 않습니다. 오류 로그에는 충돌, 어설 션 오류 및 디버깅에 도움이되도록 InnoDB / XtraDB가 모니터 출력을 로그에 쓰는 경우를 포함하여 일부 경우 쿼리 텍스트 및 데이터가 포함될 수 있습니다. 필요한 경우 syslog에도 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="618b793e55cee9dea7831d9c6d2c96a8ced96bf9" translate="yes" xml:space="preserve">
          <source>The MariaDB &lt;a href=&quot;../getting-the-mariadb-source-code/index&quot;&gt;source code&lt;/a&gt; also contains some authentication plugins that are intended explicitly to be examples for developers. They are located in &lt;code&gt;plugin/auth_examples&lt;/code&gt;.</source>
          <target state="translated">MariaDB &lt;a href=&quot;../getting-the-mariadb-source-code/index&quot;&gt;소스 코드&lt;/a&gt; 에는 개발자를위한 예제를위한 인증 플러그인도 포함되어 있습니다. 그것들은 &lt;code&gt;plugin/auth_examples&lt;/code&gt; 에 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea0748523782820298417ccbd1c196acb652d8e2" translate="yes" xml:space="preserve">
          <source>The MariaDB &lt;code&gt;apt&lt;/code&gt; repository contains the last few versions of MariaDB. To show what versions are available, use the &lt;code&gt;&lt;a href=&quot;http://manpages.ubuntu.com/manpages/bionic/man8/apt-cache.8.html&quot;&gt;apt-cache&lt;/a&gt;&lt;/code&gt; command:</source>
          <target state="translated">MariaDB &lt;code&gt;apt&lt;/code&gt; 저장소에는 MariaDB 의 마지막 몇 버전이 포함되어 있습니다. 사용 가능한 버전을 표시하려면 &lt;code&gt;&lt;a href=&quot;http://manpages.ubuntu.com/manpages/bionic/man8/apt-cache.8.html&quot;&gt;apt-cache&lt;/a&gt;&lt;/code&gt; 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="9b89c963939398eab19d4903d949bc155c277f8a" translate="yes" xml:space="preserve">
          <source>The MariaDB &lt;code&gt;apt&lt;/code&gt; repository contains the last few versions of MariaDB. To show what versions are available, use the &lt;code&gt;&lt;a href=&quot;https://manpages.ubuntu.com/manpages/bionic/man8/apt-cache.8.html&quot;&gt;apt-cache&lt;/a&gt;&lt;/code&gt; command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6812fef9c62245a4e844794a43624afe139fc32" translate="yes" xml:space="preserve">
          <source>The MariaDB &lt;code&gt;systemd&lt;/code&gt; service was first released in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1018-release-notes/&quot;&gt;MariaDB 10.1.8&lt;/a&gt; on supported Linux distributions.</source>
          <target state="translated">MariaDB &lt;code&gt;systemd&lt;/code&gt; 서비스는 지원되는 Linux 배포판 에서 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1018-release-notes/&quot;&gt;MariaDB 10.1.8&lt;/a&gt; 로 처음 릴리스되었습니다 .</target>
        </trans-unit>
        <trans-unit id="e71ff7f7f073a076d438788b773341bda54491f0" translate="yes" xml:space="preserve">
          <source>The MariaDB &lt;code&gt;systemd&lt;/code&gt; service's journal can be queried by using the &lt;code&gt;&lt;a href=&quot;https://www.freedesktop.org/software/systemd/man/journalctl.html&quot;&gt;journalctl&lt;/a&gt;&lt;/code&gt; command. For example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://www.freedesktop.org/software/systemd/man/journalctl.html&quot;&gt;journalctl&lt;/a&gt;&lt;/code&gt; 명령 을 사용하여 MariaDB &lt;code&gt;systemd&lt;/code&gt; 서비스 저널을 조회 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d4a410ca2a617ddde03a075a73b0734d7c5a38c2" translate="yes" xml:space="preserve">
          <source>The MariaDB &lt;code&gt;yum&lt;/code&gt; repository also contains &lt;code&gt;&lt;a href=&quot;https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Developer_Guide/intro.debuginfo.html&quot;&gt;debuginfo&lt;/a&gt;&lt;/code&gt; packages. These package may be needed when &lt;a href=&quot;../how-to-produce-a-full-stack-trace-for-mysqld/index&quot;&gt;debugging a problem&lt;/a&gt;.</source>
          <target state="translated">MariaDB &lt;code&gt;yum&lt;/code&gt; 저장소에는 &lt;code&gt;&lt;a href=&quot;https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Developer_Guide/intro.debuginfo.html&quot;&gt;debuginfo&lt;/a&gt;&lt;/code&gt; 패키지 도 포함되어 있습니다 . 이러한 패키지는 &lt;a href=&quot;../how-to-produce-a-full-stack-trace-for-mysqld/index&quot;&gt;문제를 디버깅&lt;/a&gt; 할 때 필요할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ff96561ae6ccf2075d4be21594c047027dfaf9bc" translate="yes" xml:space="preserve">
          <source>The MariaDB &lt;code&gt;yum&lt;/code&gt; repository contains the last few versions of MariaDB. To show what versions are available, use the following command:</source>
          <target state="translated">MariaDB &lt;code&gt;yum&lt;/code&gt; 저장소에는 MariaDB 의 마지막 몇 버전이 포함되어 있습니다. 사용 가능한 버전을 표시하려면 다음 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="02e4f2da8f21803387cc27dd786c30f8e204dc05" translate="yes" xml:space="preserve">
          <source>The MariaDB &lt;code&gt;yum&lt;/code&gt; repository first added &lt;code&gt;&lt;a href=&quot;https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Developer_Guide/intro.debuginfo.html&quot;&gt;debuginfo&lt;/a&gt;&lt;/code&gt; packages in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5564-release-notes/&quot;&gt;MariaDB 5.5.64&lt;/a&gt;, &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10139-release-notes/&quot;&gt;MariaDB 10.1.39&lt;/a&gt;, &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10223-release-notes/&quot;&gt;MariaDB 10.2.23&lt;/a&gt;, &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10314-release-notes/&quot;&gt;MariaDB 10.3.14&lt;/a&gt;, and &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1044-release-notes/&quot;&gt;MariaDB 10.4.4&lt;/a&gt;.</source>
          <target state="translated">MariaDB &lt;code&gt;yum&lt;/code&gt; 저장소는 먼저 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5564-release-notes/&quot;&gt;MariaDB 5.5.64&lt;/a&gt; , &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10139-release-notes/&quot;&gt;MariaDB 10.1.39&lt;/a&gt; , &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10223-release-notes/&quot;&gt;MariaDB 10.2.23&lt;/a&gt; , &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10314-release-notes/&quot;&gt;MariaDB 10.3.14&lt;/a&gt; 및 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1044-release-notes/&quot;&gt;MariaDB 10.4.4&lt;/a&gt; 에 &lt;code&gt;&lt;a href=&quot;https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Developer_Guide/intro.debuginfo.html&quot;&gt;debuginfo&lt;/a&gt;&lt;/code&gt; 패키지를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="56c99ea96737d66e62188ef4a5933ded7d2ce5cd" translate="yes" xml:space="preserve">
          <source>The MariaDB &lt;code&gt;yum&lt;/code&gt; repository in this example contains &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10310-release-notes/&quot;&gt;MariaDB 10.3.10&lt;/a&gt;, &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10311-release-notes/&quot;&gt;MariaDB 10.3.11&lt;/a&gt;, and &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10312-release-notes/&quot;&gt;MariaDB 10.3.12&lt;/a&gt;. The CentOS base &lt;code&gt;yum&lt;/code&gt; repository also contains &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5560-release-notes/&quot;&gt;MariaDB 5.5.60&lt;/a&gt;.</source>
          <target state="translated">이 예제 의 MariaDB &lt;code&gt;yum&lt;/code&gt; 저장소에는 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10310-release-notes/&quot;&gt;MariaDB 10.3.10&lt;/a&gt; , &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10311-release-notes/&quot;&gt;MariaDB 10.3.11&lt;/a&gt; 및 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10312-release-notes/&quot;&gt;MariaDB 10.3.12&lt;/a&gt; 가 포함되어 있습니다 . CentOS 기본 &lt;code&gt;yum&lt;/code&gt; 저장소에는 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5560-release-notes/&quot;&gt;MariaDB 5.5.60&lt;/a&gt; 도 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="892e575c40136162f5f1d2dd2f63c5db387e04f5" translate="yes" xml:space="preserve">
          <source>The MariaDB &lt;code&gt;zypper&lt;/code&gt; repository also contains &lt;code&gt;&lt;a href=&quot;https://en.opensuse.org/openSUSE:Packaging_guidelines#Debuginfo&quot;&gt;debuginfo&lt;/a&gt;&lt;/code&gt; packages. These package may be needed when &lt;a href=&quot;../how-to-produce-a-full-stack-trace-for-mysqld/index&quot;&gt;debugging a problem&lt;/a&gt;.</source>
          <target state="translated">MariaDB &lt;code&gt;zypper&lt;/code&gt; 저장소에는 &lt;code&gt;&lt;a href=&quot;https://en.opensuse.org/openSUSE:Packaging_guidelines#Debuginfo&quot;&gt;debuginfo&lt;/a&gt;&lt;/code&gt; 패키지 도 포함되어 있습니다 . 이러한 패키지는 &lt;a href=&quot;../how-to-produce-a-full-stack-trace-for-mysqld/index&quot;&gt;문제를 디버깅&lt;/a&gt; 할 때 필요할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8bafb6d1f235feb413e1ae0702996f21652d11f0" translate="yes" xml:space="preserve">
          <source>The MariaDB &lt;code&gt;zypper&lt;/code&gt; repository contains the last few versions of MariaDB. To show what versions are available, use the following command:</source>
          <target state="translated">MariaDB &lt;code&gt;zypper&lt;/code&gt; 저장소에는 MariaDB 의 마지막 몇 버전이 포함되어 있습니다. 사용 가능한 버전을 표시하려면 다음 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="94c0795dea6c88768d7d2a109b74a1485d3905a8" translate="yes" xml:space="preserve">
          <source>The MariaDB &lt;code&gt;zypper&lt;/code&gt; repository first added &lt;code&gt;&lt;a href=&quot;https://en.opensuse.org/openSUSE:Packaging_guidelines#Debuginfo&quot;&gt;debuginfo&lt;/a&gt;&lt;/code&gt; packages in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5564-release-notes/&quot;&gt;MariaDB 5.5.64&lt;/a&gt;, &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10139-release-notes/&quot;&gt;MariaDB 10.1.39&lt;/a&gt;, &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10223-release-notes/&quot;&gt;MariaDB 10.2.23&lt;/a&gt;, &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10314-release-notes/&quot;&gt;MariaDB 10.3.14&lt;/a&gt;, and &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1044-release-notes/&quot;&gt;MariaDB 10.4.4&lt;/a&gt;.</source>
          <target state="translated">MariaDB &lt;code&gt;zypper&lt;/code&gt; 저장소는 먼저 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5564-release-notes/&quot;&gt;MariaDB 5.5.64&lt;/a&gt; , &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10139-release-notes/&quot;&gt;MariaDB 10.1.39&lt;/a&gt; , &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10223-release-notes/&quot;&gt;MariaDB 10.2.23&lt;/a&gt; , &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10314-release-notes/&quot;&gt;MariaDB 10.3.14&lt;/a&gt; 및 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1044-release-notes/&quot;&gt;MariaDB 10.4.4&lt;/a&gt; 에 &lt;code&gt;&lt;a href=&quot;https://en.opensuse.org/openSUSE:Packaging_guidelines#Debuginfo&quot;&gt;debuginfo&lt;/a&gt;&lt;/code&gt; 패키지를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="7bc32ecdf61ead7bb4eb54658d4b09081c6213d0" translate="yes" xml:space="preserve">
          <source>The MariaDB &lt;strong&gt;show processlist&lt;/strong&gt; command may be used to see a list of active queries on that UM:</source>
          <target state="translated">MariaDB &lt;strong&gt;show processlist&lt;/strong&gt; 명령을 사용하여 해당 UM에서 활성 쿼리 목록을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd66c63eaa6b660e5bbfb5276b658209c48c999b" translate="yes" xml:space="preserve">
          <source>The MariaDB Audit Plugin works with MariaDB, MySQL (as of, version 5.5.34 and 10.0.7) and Percona Server. MariaDB started including by default the Audit Plugin from versions 10.0.10 and 5.5.37, and it can be installed in any version from &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5520-release-notes/&quot;&gt;MariaDB 5.5.20&lt;/a&gt;.</source>
          <target state="translated">MariaDB 감사 플러그인은 MariaDB, MySQL (버전 5.5.34 및 10.0.7) 및 Percona 서버에서 작동합니다. MariaDB는 기본적으로 버전 10.0.10 및 5.5.37의 감사 플러그인을 포함하기 시작했으며 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5520-release-notes/&quot;&gt;MariaDB 5.5.20의&lt;/a&gt; 모든 버전에 설치할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="000f28a64f4766608e05ec80d5b2a19dbbfc4572" translate="yes" xml:space="preserve">
          <source>The MariaDB ColumnStore AMI Instance uses 'iops' EBS storage for improved performance over the standard storage type. But it also means that based on the number of Instances/Module you plan to launch, you will need to check your account to make sure you have the permissions to create enough 'iops' storages. Amazon does have a limit on this.</source>
          <target state="translated">MariaDB ColumnStore AMI 인스턴스는 표준 스토리지 유형보다 향상된 성능을 위해 'iops'EBS 스토리지를 사용합니다. 그러나 시작하려는 인스턴스 / 모듈 수에 따라 충분한 'iops'스토리지를 생성 할 수있는 권한이 있는지 계정을 확인해야합니다. 아마존에는 이에 대한 제한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca4eea4f8edb7263f1479c17c43d30e00dc9b5a1" translate="yes" xml:space="preserve">
          <source>The MariaDB ColumnStore AMI comes installed with the Amazon AWS-CLI Tool set package, version 1.11.36. The Amazon AWS-CLI Tools provides the capability to the MariaDB ColumnStore to create EC2 Instances and EBS storages. It allows allows for EC2 Instance/node failover, meaning if an EC2 Instance goes down or stops communicating, MariaDB ColumnStore will handle that problem keeping the system functional. This might consist of re-attaching an EBS storage device from the problem EC2 Performance Module to an another Performance Module in the system. Also if a EC2 Instance was to terminate, MariaDB ColumnStore will launch another EC2 Instance in its place.</source>
          <target state="translated">MariaDB ColumnStore AMI는 Amazon AWS-CLI 도구 세트 패키지 버전 1.11.36과 함께 설치됩니다. Amazon AWS-CLI 도구는 MariaDB ColumnStore에 EC2 인스턴스 및 EBS 스토리지를 생성 할 수있는 기능을 제공합니다. EC2 인스턴스 / 노드 장애 조치를 허용합니다. 즉, EC2 인스턴스가 다운되거나 통신이 중지되면 MariaDB ColumnStore는 시스템 기능을 유지하면서 해당 문제를 처리합니다. 이는 문제 EC2 성능 모듈에서 시스템의 다른 성능 모듈로 EBS 저장 장치를 다시 연결하는 것으로 구성 될 수 있습니다. 또한 EC2 인스턴스가 종료 된 경우 MariaDB ColumnStore는 대신 다른 EC2 인스턴스를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="153583ea7fa910d96421109a8a879714e5e4ca28" translate="yes" xml:space="preserve">
          <source>The MariaDB ColumnStore AMI is CentOS 7 based with MariaDB ColumnStore GA packages.</source>
          <target state="translated">MariaDB ColumnStore AMI는 MariaDB ColumnStore GA 패키지와 함께 CentOS 7입니다.</target>
        </trans-unit>
        <trans-unit id="0839f1ee37e5f62c1a275ce87370736be99bfbad" translate="yes" xml:space="preserve">
          <source>The MariaDB ColumnStore AMI is setup to be accessed and run from the &amp;lt;USER&amp;gt; account</source>
          <target state="translated">MariaDB ColumnStore AMI는 &amp;lt;USER&amp;gt; 계정에서 액세스하고 실행하도록 설정되었습니다.</target>
        </trans-unit>
        <trans-unit id="5db8856ffbf6102200a560e5182c746ee65a3aeb" translate="yes" xml:space="preserve">
          <source>The MariaDB ColumnStore Admin console that is run from the command line console as root user can be setup to be run for a non-root user, if you choose to do so.</source>
          <target state="translated">루트 사용자로 명령 행 콘솔에서 실행되는 MariaDB ColumnStore 관리 콘솔을 선택하면 루트가 아닌 사용자에 대해 실행되도록 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d6e4ece5f89e7c2d4feb4afc3b332eb78f0e81a" translate="yes" xml:space="preserve">
          <source>The MariaDB ColumnStore Data Adapters Packages are:</source>
          <target state="translated">MariaDB ColumnStore 데이터 어댑터 패키지는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cbdf3088e4c1b2377d40bf42c7624a41807c648a" translate="yes" xml:space="preserve">
          <source>The MariaDB ColumnStore Management Console allows you to configure, monitor, and manage the MariaDB ColumnStore system and servers. For more detailed information, see &lt;a href=&quot;../mariadb-columnstore-administrative-console/index&quot;&gt;MariaDB ColumnStore Administrative Console&lt;/a&gt;.</source>
          <target state="translated">MariaDB ColumnStore 관리 콘솔을 사용하면 MariaDB ColumnStore 시스템 및 서버를 구성, 모니터링 및 관리 할 수 ​​있습니다. 자세한 정보는 &lt;a href=&quot;../mariadb-columnstore-administrative-console/index&quot;&gt;MariaDB ColumnStore 관리 콘솔을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e12ac50b61f52da508b462531e99c65eb89cff33" translate="yes" xml:space="preserve">
          <source>The MariaDB ColumnStore Management Console allows you to configure, monitor, and manage the MariaDB ColumnStore system and servers. Once you have a running ColumnStore cluster, you can invoke the console from any of the &lt;a href=&quot;../columnstore-user-module/index&quot;&gt;UM&lt;/a&gt; or &lt;a href=&quot;../columnstore-performance-module/index&quot;&gt;PM&lt;/a&gt; nodes. The console utility is called mcsadmin</source>
          <target state="translated">MariaDB ColumnStore 관리 콘솔을 사용하면 MariaDB ColumnStore 시스템 및 서버를 구성, 모니터링 및 관리 할 수 ​​있습니다. 실행중인 ColumnStore 클러스터가 있으면 &lt;a href=&quot;../columnstore-user-module/index&quot;&gt;UM&lt;/a&gt; 또는 &lt;a href=&quot;../columnstore-performance-module/index&quot;&gt;PM&lt;/a&gt; 노드 에서 콘솔을 호출 할 수 있습니다 . 콘솔 유틸리티는 mcsadmin이라고합니다</target>
        </trans-unit>
        <trans-unit id="8c55fca4b25a6bf366649bc74e9a7f04a3b9f645" translate="yes" xml:space="preserve">
          <source>The MariaDB ColumnStore RPM and DEB Packages can be installed using yum/apt-get commands. Check here for additional Information:</source>
          <target state="translated">MariaDB ColumnStore RPM 및 DEB 패키지는 yum / apt-get 명령을 사용하여 설치할 수 있습니다. 추가 정보는 여기를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="7d75aa4e136f39884d659109f4898cc90bb61ca5" translate="yes" xml:space="preserve">
          <source>The MariaDB ColumnStore RPM, DEB and binary Packages can be installed along with all of the other packages that make up the AX package. Check here for additional Information:</source>
          <target state="translated">MariaDB ColumnStore RPM, DEB 및 이진 패키지는 AX 패키지를 구성하는 다른 모든 패키지와 함께 설치할 수 있습니다. 추가 정보는 여기를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="0f44a6ec0079ea31e68b84daedb30f883938387b" translate="yes" xml:space="preserve">
          <source>The MariaDB ColumnStore RPM, DEB and binary packages can be installed along with the other packages that make up the AX package. Check here for additional Information:</source>
          <target state="translated">MariaDB ColumnStore RPM, DEB 및 바이너리 패키지는 AX 패키지를 구성하는 다른 패키지와 함께 설치할 수 있습니다. 추가 정보는 여기를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="dbea994934813638fc0aabdaf3677aa88593e4aa" translate="yes" xml:space="preserve">
          <source>The MariaDB ColumnStore binary package can be installed from the MariaDB Downloads page. &amp;lt;CLICK&amp;gt; on the &quot;all versions&quot; link and then step down into the OS version to the bottom level directory where you will see 2 packages, one for rpm/deb and the bother for the binary. Select the binary package to download.</source>
          <target state="translated">MariaDB ColumnStore 바이너리 패키지는 MariaDB 다운로드 페이지에서 설치할 수 있습니다. &quot;모든 버전&quot;링크에서 &amp;lt;CLICK&amp;gt;을 누른 다음 OS 버전으로 내려가 최상위 레벨 디렉토리로 내려 가면 2 개의 패키지 (rpm / deb 용, 바이너리 용)가 표시됩니다. 다운로드 할 바이너리 패키지를 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="4f4b6208bb3b356831025eff4deb88c81a9b9847" translate="yes" xml:space="preserve">
          <source>The MariaDB ColumnStore binary package can be installed from the MariaDB Downloads page. &amp;lt;CLICK&amp;gt; on the &quot;all versions&quot; link and then step down into the OS version to the bottom level directory where you will see 2 packages, one for rpm/deb and the other for the binary. Select the binary package to download.</source>
          <target state="translated">MariaDB ColumnStore 바이너리 패키지는 MariaDB 다운로드 페이지에서 설치할 수 있습니다. &quot;모든 버전&quot;링크에서 &amp;lt;CLICK&amp;gt;을 누른 다음 OS 버전으로 내려가 최상위 디렉토리로 내려 가면 2 개의 패키지가 나타납니다. 하나는 rpm / deb 용이고 다른 하나는 바이너리 용입니다. 다운로드 할 바이너리 패키지를 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="6fffd573c96875330462163b4406ef7883491045" translate="yes" xml:space="preserve">
          <source>The MariaDB ColumnStore binary packages can be downloaded from &lt;a href=&quot;https://downloads.mariadb.com/ColumnStore/&quot;&gt;https://downloads.mariadb.com/ColumnStore/&lt;/a&gt;. Select version 1.2.1, then navigate to the appropriate package for your system. The binary package will have the extension '.bin.tar.gz' rather than '.rpm.tar.gz' or '.deb.tar.gz'.</source>
          <target state="translated">MariaDB ColumnStore 바이너리 패키지는 &lt;a href=&quot;https://downloads.mariadb.com/ColumnStore/&quot;&gt;https://downloads.mariadb.com/ColumnStore/&lt;/a&gt; 에서 다운로드 할 수 있습니다 . 버전 1.2.1을 선택한 다음 시스템에 적합한 패키지로 이동하십시오. 바이너리 패키지는 '.rpm.tar.gz'또는 '.deb.tar.gz'대신 '.bin.tar.gz'확장자를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="398caef87899596909cd4518c13abedd027eec84" translate="yes" xml:space="preserve">
          <source>The MariaDB ColumnStore binary packages can be downloaded from &lt;a href=&quot;https://downloads.mariadb.com/ColumnStore/&quot;&gt;https://downloads.mariadb.com/ColumnStore/&lt;/a&gt;. Select version 1.2.2, then navigate to the appropriate package for your system. The binary package will have the extension '.bin.tar.gz' rather than '.rpm.tar.gz' or '.deb.tar.gz'.</source>
          <target state="translated">MariaDB ColumnStore 바이너리 패키지는 &lt;a href=&quot;https://downloads.mariadb.com/ColumnStore/&quot;&gt;https://downloads.mariadb.com/ColumnStore/&lt;/a&gt; 에서 다운로드 할 수 있습니다 . 버전 1.2.2를 선택한 다음 시스템에 적합한 패키지로 이동하십시오. 바이너리 패키지는 '.rpm.tar.gz'또는 '.deb.tar.gz'대신 '.bin.tar.gz'확장자를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="ca60db96e633202e094d5b229c6ab16ecf1449ec" translate="yes" xml:space="preserve">
          <source>The MariaDB ColumnStore binary packages can be downloaded from &lt;a href=&quot;https://downloads.mariadb.com/ColumnStore/&quot;&gt;https://downloads.mariadb.com/ColumnStore/&lt;/a&gt;. Select version 1.2.5, then navigate to the appropriate package for your system. The binary package will have the extension '.bin.tar.gz' rather than '.rpm.tar.gz' or '.deb.tar.gz'.</source>
          <target state="translated">MariaDB ColumnStore 바이너리 패키지는 &lt;a href=&quot;https://downloads.mariadb.com/ColumnStore/&quot;&gt;https://downloads.mariadb.com/ColumnStore/&lt;/a&gt; 에서 다운로드 할 수 있습니다 . 버전 1.2.5를 선택한 다음 시스템에 적합한 패키지로 이동하십시오. 바이너리 패키지는 '.rpm.tar.gz'또는 '.deb.tar.gz'대신 '.bin.tar.gz'확장자를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="2085edf11d2df052b8437feea45fc023d6960538" translate="yes" xml:space="preserve">
          <source>The MariaDB ColumnStore daemon uses port 3306.</source>
          <target state="translated">MariaDB ColumnStore 데몬은 포트 3306을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="12ab69678ce2b1fcfc12438077d1cc2cb9b526f6" translate="yes" xml:space="preserve">
          <source>The MariaDB ColumnStore daemon utilizes port 3306.</source>
          <target state="translated">MariaDB ColumnStore 데몬은 포트 3306을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f45c4d02dad536ba01aa605ea195f7af992f6269" translate="yes" xml:space="preserve">
          <source>The MariaDB ColumnStore has 3 sets of database files. These files are also always backed up and restored together as part of the backup and restore process.</source>
          <target state="translated">MariaDB ColumnStore에는 3 개의 데이터베이스 파일 세트가 있습니다. 이러한 파일은 항상 백업 및 복원 프로세스의 일부로 함께 백업 및 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="07aa626b281c36035d40aecda823b30b9e9019f5" translate="yes" xml:space="preserve">
          <source>The MariaDB ColumnStore log files setup is done as part of the post-install/postConfigure installation process. If some some reason the MariaDB ColumnStore log files aren't being generated or the log-rotation is not working, then there might have been some install/setup error that occurred.</source>
          <target state="translated">MariaDB ColumnStore 로그 파일 설정은 설치 후 / 구성 후 설치 프로세스의 일부로 수행됩니다. MariaDB ColumnStore 로그 파일이 생성되지 않거나 로그 회전이 작동하지 않는 이유가 있으면 설치 / 설정 오류가 발생한 것일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d6b4b6dbb17c6f2620e4d09990e7d75fe3994e4" translate="yes" xml:space="preserve">
          <source>The MariaDB ColumnStore logrotate file is located in</source>
          <target state="translated">MariaDB ColumnStore 로그 회전 파일은 다음 위치에 있습니다.</target>
        </trans-unit>
        <trans-unit id="aadc7bb32d14e7bbdac873519b41751d19b7ebdb" translate="yes" xml:space="preserve">
          <source>The MariaDB ColumnStore process corefiles would be stored in /var/log/mariadb/columnstore/corefiles, that is if core file dumping is enabled on the system.</source>
          <target state="translated">MariaDB ColumnStore 프로세스 코어 파일은 / var / log / mariadb / columnstore / corefiles에 저장됩니다. 즉, 시스템에서 코어 파일 덤프가 활성화 된 경우입니다.</target>
        </trans-unit>
        <trans-unit id="452e675c643e8fee6dc645e8a793612eb488eb0a" translate="yes" xml:space="preserve">
          <source>The MariaDB ColumnStore uses TCP ports 3306, 8600 - 8630, 8700, and 8800. Port 3306 is the default port for clients to connect to the MariaDB server; the others are for internal communication and will need to be open between ColumnStore nodes.</source>
          <target state="translated">MariaDB ColumnStore는 TCP 포트 3306, 8600-8630, 8700 및 8800을 사용합니다. 포트 3306은 클라이언트가 MariaDB 서버에 연결하는 기본 포트입니다. 다른 하나는 내부 통신을위한 것이며 ColumnStore 노드 사이에 열려 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="3bdee3337f03e365c8f27836cafb081eb3d765ed" translate="yes" xml:space="preserve">
          <source>The MariaDB ColumnStore utilizes these ports 3306, 8600 - 8630, 8700, and 8800. So on multi-node installs, these ports will need to be accessible between the servers. So if there is any firewall software running on the system that could block these ports, either that firewall would need to be disabled as shown below or the ports listed above will need to be configured to allow both input and output on all servers within the firewall software. You will also want to allow these ports to be passed though on any routers that might be connected between the servers.</source>
          <target state="translated">MariaDB ColumnStore는 이러한 포트 3306, 8600-8630, 8700 및 8800을 사용합니다. 따라서 다중 노드 설치에서는 서버간에이 포트에 액세스 할 수 있어야합니다. 따라서 시스템에서 이러한 포트를 차단할 수있는 방화벽 소프트웨어가있는 경우 아래 그림과 같이 해당 방화벽을 비활성화하거나 위에 나열된 포트를 방화벽 내의 모든 서버에서 입력 및 출력을 허용하도록 구성해야합니다. 소프트웨어. 서버간에 연결된 라우터에서 이러한 포트를 전달할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c327f721dee19c0b1b4abb1c24e5e033a6f199fe" translate="yes" xml:space="preserve">
          <source>The MariaDB Columnstore CentOS 7 binary package is installed in the user account:.</source>
          <target state="translated">MariaDB Columnstore CentOS 7 바이너리 패키지는 사용자 계정에 설치됩니다.</target>
        </trans-unit>
        <trans-unit id="ea777b4b6fd406e29b0e142bf5b56f21ee966969" translate="yes" xml:space="preserve">
          <source>The MariaDB Foundation archives repositories of old minor releases at the following URL:</source>
          <target state="translated">MariaDB Foundation은 다음 URL에서 이전 부 릴리스의 저장소를 아카이브합니다.</target>
        </trans-unit>
        <trans-unit id="6046dc2f22569141f889cb197e870727d9a50463" translate="yes" xml:space="preserve">
          <source>The MariaDB Foundation provides a MariaDB repository for several Linux distributions that use &lt;code&gt;apt-get&lt;/code&gt; to manage packages. This repository contains software packages related to MariaDB Server, including the server itself, &lt;a href=&quot;../clients-utilities/index&quot;&gt;clients and utilities&lt;/a&gt;, &lt;a href=&quot;../client-libraries/index&quot;&gt;client libraries&lt;/a&gt;, &lt;a href=&quot;../plugins/index&quot;&gt;plugins&lt;/a&gt;, and &lt;a href=&quot;../mariabackup/index&quot;&gt;Mariabackup&lt;/a&gt;. The MariaDB Repository Configuration Tool can easily generate the appropriate commands to add the repository for your distribution.</source>
          <target state="translated">MariaDB Foundation은 &lt;code&gt;apt-get&lt;/code&gt; 을 사용하여 패키지를 관리 하는 여러 Linux 배포판에 MariaDB 리포지토리를 제공 합니다. 이 저장소에는 서버 자체, &lt;a href=&quot;../clients-utilities/index&quot;&gt;클라이언트 및 유틸리티&lt;/a&gt; , &lt;a href=&quot;../client-libraries/index&quot;&gt;클라이언트 라이브러리&lt;/a&gt; , &lt;a href=&quot;../plugins/index&quot;&gt;플러그인&lt;/a&gt; 및 &lt;a href=&quot;../mariabackup/index&quot;&gt;Mariabackup을&lt;/a&gt; 포함하여 MariaDB 서버와 관련된 소프트웨어 패키지가 포함되어 있습니다 . MariaDB 리포지토리 구성 도구는 배포를위한 리포지토리를 추가하는 적절한 명령을 쉽게 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b2d7db9ad0bb941cf5e68f2ca7ada5a269de4b9" translate="yes" xml:space="preserve">
          <source>The MariaDB Foundation provides a MariaDB repository for several Linux distributions that use &lt;code&gt;yum&lt;/code&gt; to manage packages. This repository contains software packages related to MariaDB Server, including the server itself, &lt;a href=&quot;../clients-utilities/index&quot;&gt;clients and utilities&lt;/a&gt;, &lt;a href=&quot;../client-libraries/index&quot;&gt;client libraries&lt;/a&gt;, &lt;a href=&quot;../plugins/index&quot;&gt;plugins&lt;/a&gt;, and &lt;a href=&quot;../mariabackup/index&quot;&gt;Mariabackup&lt;/a&gt;. The MariaDB Repository Configuration Tool can easily generate the appropriate configuration file to add the repository for your distribution.</source>
          <target state="translated">MariaDB Foundation은 &lt;code&gt;yum&lt;/code&gt; 을 사용 하여 패키지를 관리 하는 여러 Linux 배포판을위한 MariaDB 리포지토리를 제공 합니다. 이 저장소에는 서버 자체, &lt;a href=&quot;../clients-utilities/index&quot;&gt;클라이언트 및 유틸리티&lt;/a&gt; , &lt;a href=&quot;../client-libraries/index&quot;&gt;클라이언트 라이브러리&lt;/a&gt; , &lt;a href=&quot;../plugins/index&quot;&gt;플러그인&lt;/a&gt; 및 &lt;a href=&quot;../mariabackup/index&quot;&gt;Mariabackup을&lt;/a&gt; 포함하여 MariaDB 서버와 관련된 소프트웨어 패키지가 포함되어 있습니다 . MariaDB 리포지토리 구성 도구는 배포 용 리포지토리를 추가하기 위해 적절한 구성 파일을 쉽게 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74e4e2f9d2afd275d9366b6c3c864b7d5e1d1b32" translate="yes" xml:space="preserve">
          <source>The MariaDB Foundation provides a MariaDB repository for several Linux distributions that use &lt;code&gt;zypper&lt;/code&gt; to manage packages. This repository contains software packages related to MariaDB Server, including the server itself, &lt;a href=&quot;../clients-utilities/index&quot;&gt;clients and utilities&lt;/a&gt;, &lt;a href=&quot;../client-libraries/index&quot;&gt;client libraries&lt;/a&gt;, &lt;a href=&quot;../plugins/index&quot;&gt;plugins&lt;/a&gt;, and &lt;a href=&quot;../mariabackup/index&quot;&gt;Mariabackup&lt;/a&gt;. The MariaDB Repository Configuration Tool can easily generate the appropriate commands to add the repository for your distribution.</source>
          <target state="translated">MariaDB Foundation은 &lt;code&gt;zypper&lt;/code&gt; 를 사용 하여 패키지를 관리 하는 여러 Linux 배포판을위한 MariaDB 리포지토리를 제공 합니다. 이 저장소에는 서버 자체, &lt;a href=&quot;../clients-utilities/index&quot;&gt;클라이언트 및 유틸리티&lt;/a&gt; , &lt;a href=&quot;../client-libraries/index&quot;&gt;클라이언트 라이브러리&lt;/a&gt; , &lt;a href=&quot;../plugins/index&quot;&gt;플러그인&lt;/a&gt; 및 &lt;a href=&quot;../mariabackup/index&quot;&gt;Mariabackup을&lt;/a&gt; 포함하여 MariaDB 서버와 관련된 소프트웨어 패키지가 포함되어 있습니다 . MariaDB 리포지토리 구성 도구는 배포를위한 리포지토리를 추가하는 적절한 명령을 쉽게 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d62a85c3827f41b286ffd314412d6ab8e55c08f" translate="yes" xml:space="preserve">
          <source>The MariaDB GUI tool allows users to create and execute queries, develop and debug stored routines, automate database object management, and analyze table data via an intuitive interface. The MariaDB client provides utilities to compare schema and data and synchronize them. It includes data generating and database reporting tools, DB documenter, backup options with scheduling, and much more.</source>
          <target state="translated">MariaDB GUI 도구를 사용하면 직관적 인 인터페이스를 통해 쿼리를 생성 및 실행하고, 저장된 루틴을 개발 및 디버깅하고, 데이터베이스 객체 관리를 자동화하고, 테이블 데이터를 분석 할 수 있습니다. MariaDB 클라이언트는 스키마와 데이터를 비교하고 동기화하는 유틸리티를 제공합니다. 여기에는 데이터 생성 및 데이터베이스보고 도구, DB 문서 작성기, 예약 기능이있는 백업 옵션 등이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="590d784bf7aa68ec0756d7328eeabf57d7157e73" translate="yes" xml:space="preserve">
          <source>The MariaDB GUI tool allows users to create and execute queries, develop and debug stored routines, automate database object management, and analyze table data via an intuitive interface. The MariaDB client provides utilities to compare schema and data and synchronize them. It includes database reporting tools, backup options with scheduling, and much more.</source>
          <target state="translated">MariaDB GUI 도구를 사용하면 직관적 인 인터페이스를 통해 쿼리를 생성 및 실행하고, 저장된 루틴을 개발 및 디버깅하고, 데이터베이스 객체 관리를 자동화하고, 테이블 데이터를 분석 할 수 있습니다. MariaDB 클라이언트는 스키마와 데이터를 비교하고 동기화하는 유틸리티를 제공합니다. 여기에는 데이터베이스보고 도구, 스케줄링이있는 백업 옵션 등이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="6737ccffd9874cdf956f404548be8907617ff4e1" translate="yes" xml:space="preserve">
          <source>The MariaDB MaxScale server configuration above designates data manipulation statements such as &lt;code&gt;&lt;a href=&quot;../insert/index&quot;&gt;INSERT&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../delete/index&quot;&gt;DELETE&lt;/a&gt;&lt;/code&gt; as transactional and routes these statements to the MariaDB Servers. The other MaxScale server then streams the changes over to ColumnStore.</source>
          <target state="translated">위의 MariaDB MaxScale 서버 구성은 &lt;code&gt;&lt;a href=&quot;../insert/index&quot;&gt;INSERT&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../delete/index&quot;&gt;DELETE&lt;/a&gt;&lt;/code&gt; 와 같은 데이터 조작 명령문 을 트랜잭션으로 지정하고 이러한 명령문을 MariaDB 서버로 라우팅합니다. 그런 다음 다른 MaxScale 서버는 변경 사항을 ColumnStore로 스트리밍합니다.</target>
        </trans-unit>
        <trans-unit id="714bd7368f00908574dd6661bd307ebe9d17eb91" translate="yes" xml:space="preserve">
          <source>The MariaDB MaxScale server configuration above designates queries on tables other than bank.loan as transactional and routes them to the MariaDB Servers rather than ColumnStore. You can identify which server cluster the query executes on using the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#version_comment&quot;&gt;version_comment&lt;/a&gt;&lt;/code&gt; system variable.</source>
          <target state="translated">위의 MariaDB MaxScale 서버 구성은 bank.loan 이외의 테이블에 대한 쿼리를 트랜잭션으로 지정하고이를 ColumnStore가 아닌 MariaDB 서버로 라우팅합니다. &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#version_comment&quot;&gt;version_comment&lt;/a&gt;&lt;/code&gt; 시스템 변수 를 사용하여 쿼리가 실행되는 서버 클러스터를 식별 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c1cc23ec76507eb8f99c09e90391f3737d7e3935" translate="yes" xml:space="preserve">
          <source>The MariaDB MaxScale server configuration above designates queries on the bank.loans table as analytical queries and routes them to the MariaDB ColumnStore User Modules rather than the MariaDB Servers. You can identify which server cluster the query executes on using the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#version_comment&quot;&gt;version_comment&lt;/a&gt;&lt;/code&gt; system variable.</source>
          <target state="translated">위의 MariaDB MaxScale 서버 구성은 bank.loans 테이블의 쿼리를 분석 쿼리로 지정하고 MariaDB 서버가 아닌 MariaDB ColumnStore 사용자 모듈로 라우팅합니다. &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#version_comment&quot;&gt;version_comment&lt;/a&gt;&lt;/code&gt; 시스템 변수 를 사용하여 쿼리가 실행되는 서버 클러스터를 식별 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1e5c0dafd42ae8be2afc284154223634fa71f76b" translate="yes" xml:space="preserve">
          <source>The MariaDB Performance Schema is a feature for monitoring the performance of your MariaDB server.</source>
          <target state="translated">MariaDB 성능 스키마는 MariaDB 서버의 성능을 모니터링하기위한 기능입니다.</target>
        </trans-unit>
        <trans-unit id="3fc775b0bcf2e39053d1e36e26e4bd9f97c77be6" translate="yes" xml:space="preserve">
          <source>The MariaDB Server binaries distributed in this package do not read from .cnf files in /etc/. Instead, put .cnf files in /usr/local/mariadb/etc/.</source>
          <target state="translated">이 패키지에 배포 된 MariaDB 서버 바이너리는 / etc /의 .cnf 파일에서 읽지 않습니다. 대신 .cnf 파일을 / usr / local / mariadb / etc /에 넣으십시오.</target>
        </trans-unit>
        <trans-unit id="089a4e3382858369d9c4c00bab3ae2257979e4b5" translate="yes" xml:space="preserve">
          <source>The MariaDB Server performs any select list functions, &lt;code&gt;ORDER BY&lt;/code&gt; and &lt;code&gt;LIMIT&lt;/code&gt; operations on the result-set.</source>
          <target state="translated">MariaDB 서버 는 결과 집합에서 선택 목록 기능, &lt;code&gt;ORDER BY&lt;/code&gt; 및 &lt;code&gt;LIMIT&lt;/code&gt; 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="a8f08a2d9a21f8a64f7cb403c8f05c69b54217c4" translate="yes" xml:space="preserve">
          <source>The MariaDB Server returns the result-set to the client.</source>
          <target state="translated">MariaDB 서버는 결과 집합을 클라이언트에 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6dd20b9be7cf79478c0537d44458fd3086a40c82" translate="yes" xml:space="preserve">
          <source>The MariaDB Server should be backed up using one of the available backup methods described in the &lt;a href=&quot;../backup-and-restore-overview/index&quot;&gt;server backup and restore overview&lt;/a&gt;. Since the column store data is not stored within the MariaDB Server backup should run very quickly. Utilizing either &lt;a href=&quot;../mysqldump/index&quot;&gt;mysqldump&lt;/a&gt; or just backing up the directory are straightforward options.</source>
          <target state="translated">&lt;a href=&quot;../backup-and-restore-overview/index&quot;&gt;서버 백업 및 복원 개요에&lt;/a&gt; 설명 된 사용 가능한 백업 방법 중 하나를 사용하여 MariaDB 서버를 백업해야합니다 . 열 저장소 데이터는 MariaDB 서버 백업에 저장되지 않으므로 매우 빠르게 실행해야합니다. 중 하나를 활용 &lt;a href=&quot;../mysqldump/index&quot;&gt;mysqldump를을&lt;/a&gt; 하거나 디렉토리를 백업은 간단 옵션입니다.</target>
        </trans-unit>
        <trans-unit id="dbb91970b04e90e8ca0fac3e8d531a5d5e2595aa" translate="yes" xml:space="preserve">
          <source>The MariaDB Server will be logged here.</source>
          <target state="translated">MariaDB 서버가 여기에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="a90e33929bdf0fd92fd160f2aac768ea1922bddb" translate="yes" xml:space="preserve">
          <source>The MariaDB Servers and ColumnStore now contain the same data.</source>
          <target state="translated">MariaDB 서버와 ColumnStore는 이제 동일한 데이터를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="2acc236a3fdd9b4ef30c1c739c4b22246582070d" translate="yes" xml:space="preserve">
          <source>The MariaDB XA implementation is based on the X/Open CAE document Distributed Transaction Processing: The XA Specification. This document is published by The Open Group and available at &lt;a href=&quot;http://www.opengroup.org/public/pubs/catalog/c193.htm&quot;&gt;http://www.opengroup.org/public/pubs/catalog/c193.htm&lt;/a&gt;.</source>
          <target state="translated">MariaDB XA 구현은 X / Open CAE 문서 분산 트랜잭션 처리 : XA 사양을 기반으로합니다. 이 문서는 The Open Group에서 발행했으며 &lt;a href=&quot;http://www.opengroup.org/public/pubs/catalog/c193.htm&quot;&gt;http://www.opengroup.org/public/pubs/catalog/c193.htm&lt;/a&gt; 에서 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4e8d78f5758293160ec8b9f2cefbb72cd06095b3" translate="yes" xml:space="preserve">
          <source>The MariaDB XA implementation is based on the X/Open CAE document Distributed Transaction Processing: The XA Specification. This document is published by The Open Group and available at &lt;a href=&quot;https://www.opengroup.org/public/pubs/catalog/c193.htm&quot;&gt;http://www.opengroup.org/public/pubs/catalog/c193.htm&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d762b30f48a526831f774be91135caec214b17ea" translate="yes" xml:space="preserve">
          <source>The MariaDB implementation of this plugin is based on the &lt;a href=&quot;http://www.percona.com/docs/wiki/patches:userstatv2&quot;&gt;userstatv2 patch&lt;/a&gt; from Percona and Ourdelta. The original code comes from Google (Mark Callaghan's team) with additional work from Percona, Ourdelta, and Weldon Whipple. The MariaDB implementation provides the same functionality as the userstatv2 patch but a lot of changes have been made to make it faster and to better fit the MariaDB infrastructure.</source>
          <target state="translated">이 플러그인의 MariaDB 구현은 Percona 및 Ourdelta 의 &lt;a href=&quot;http://www.percona.com/docs/wiki/patches:userstatv2&quot;&gt;userstatv2 패치&lt;/a&gt; 를 기반으로합니다 . 원래 코드는 Percona, Ourdelta 및 Weldon Whipple의 추가 작업과 함께 Google (Mark Callaghan 팀)에서 제공합니다. MariaDB 구현은 userstatv2 패치와 동일한 기능을 제공하지만 MariaDB 인프라에 더 적합하고 더 적합하도록 많은 변경이 이루어졌습니다.</target>
        </trans-unit>
        <trans-unit id="d8edf728ad4c0a328e5e6e316687d9ecb5670547" translate="yes" xml:space="preserve">
          <source>The MariaDB project signs their MariaDB packages for Debian, Ubuntu, Fedora, CentOS, and Red Hat</source>
          <target state="translated">MariaDB 프로젝트는 데비안, 우분투, 페도라, CentOS 및 Red Hat을위한 MariaDB 패키지에 서명</target>
        </trans-unit>
        <trans-unit id="23302c9d0bf602c539b65f91a74e5cac38beaefb" translate="yes" xml:space="preserve">
          <source>The MariaDB project signs their MariaDB packages for Debian, Ubuntu, Fedora, CentOS, and Red Hat.</source>
          <target state="translated">MariaDB 프로젝트는 데비안, 우분투, 페도라, CentOS 및 Red Hat을위한 MariaDB 패키지에 서명합니다.</target>
        </trans-unit>
        <trans-unit id="1b68348be574642c62a0213661237e744d2ee344" translate="yes" xml:space="preserve">
          <source>The MariaDB query optimizer decides how best to execute each query based largely on the details of the indexes involved.</source>
          <target state="translated">MariaDB 쿼리 최적화 프로그램은 관련된 인덱스의 세부 정보를 기반으로 각 쿼리를 가장 잘 실행하는 방법을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="74719ab301181c10533d3665f97e9c2269ae8511" translate="yes" xml:space="preserve">
          <source>The MariaDB server UDF API: This allows utilization on all storage engines and is the implementation used if applied in the select list.</source>
          <target state="translated">MariaDB 서버 UDF API : 모든 스토리지 엔진에서 활용이 가능하며 선택 목록에 적용되는 경우 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d4513f83d65e1253cbdb53bf5773c51050ba5596" translate="yes" xml:space="preserve">
          <source>The MariaDB server host name.</source>
          <target state="translated">MariaDB 서버 호스트 이름</target>
        </trans-unit>
        <trans-unit id="6422e5a38026c8853c09f7a700c89e205b850aff" translate="yes" xml:space="preserve">
          <source>The MariaDB server imposes a number of limitations on &lt;a href=&quot;../user-defined-functions/index&quot;&gt;user-defined functions&lt;/a&gt; for security purposes.</source>
          <target state="translated">MariaDB 서버 는 보안을 위해 &lt;a href=&quot;../user-defined-functions/index&quot;&gt;사용자 정의 함수&lt;/a&gt; 에 여러 가지 제한을 둡니다 .</target>
        </trans-unit>
        <trans-unit id="d96e18661cad1cd20f2e01766f2da81265741225" translate="yes" xml:space="preserve">
          <source>The MariaDB server is running with the %s option so it cannot execute this statement</source>
          <target state="translated">MariaDB 서버가 % s 옵션으로 실행 중이므로이 명령문을 실행할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3149c52ecf65de430be2be820414d0d237ee0df0" translate="yes" xml:space="preserve">
          <source>The MariaDB server process is running as either a &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/services/networkservice-account&quot;&gt;NetworkService Account&lt;/a&gt; or a &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/ad/domain-user-accounts&quot;&gt;Domain User Account&lt;/a&gt;.</source>
          <target state="translated">MariaDB 서버 프로세스가 &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/services/networkservice-account&quot;&gt;NetworkService 계정&lt;/a&gt; 또는 &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/ad/domain-user-accounts&quot;&gt;도메인 사용자 계정으로&lt;/a&gt; 실행 중 입니다.</target>
        </trans-unit>
        <trans-unit id="652ef73c67467180278ed1a83ed49866dab08463" translate="yes" xml:space="preserve">
          <source>The MariaDB server's &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt; is a set of files containing &quot;events&quot; which represent modifications to the contents of a MariaDB database. These events are written in a binary (i.e. non-human-readable) format. The &lt;em&gt;mysqlbinlog&lt;/em&gt; utility is used to view these events in plain text.</source>
          <target state="translated">MariaDB 서버의 &lt;a href=&quot;../binary-log/index&quot;&gt;이진 로그&lt;/a&gt; 는 MariaDB 데이터베이스의 내용에 대한 수정을 나타내는 &quot;이벤트&quot;를 포함하는 파일 세트입니다. 이러한 이벤트는 이진 (즉 사람이 읽을 수없는) 형식으로 작성됩니다. &lt;em&gt;에서 mysqlbinlog&lt;/em&gt; 유틸리티는 일반 텍스트에서 이러한 이벤트를 볼하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1dc29c7dc4f949fbb046f81509411845220ebdc6" translate="yes" xml:space="preserve">
          <source>The MariaDB server's binary log is a set of files containing &quot;events&quot; which represent modifications to the contents of a MariaDB database. These events are written in a binary (i.e. non-human-readable) format. The mysqlbinlog utility is used to view these events in plain text.</source>
          <target state="translated">MariaDB 서버의 이진 로그는 MariaDB 데이터베이스의 내용에 대한 수정을 나타내는 &quot;이벤트&quot;를 포함하는 파일 세트입니다. 이러한 이벤트는 이진 (즉 사람이 읽을 수없는) 형식으로 작성됩니다. mysqlbinlog 유틸리티는 이러한 이벤트를 일반 텍스트로 보는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c28ed540c621c7001079e72c5b8c256e43732369" translate="yes" xml:space="preserve">
          <source>The MariaDB user name to use when connecting to the server.</source>
          <target state="translated">서버에 연결할 때 사용할 MariaDB 사용자 이름입니다.</target>
        </trans-unit>
        <trans-unit id="c45a7d461221531b90a9796978caa7143ddb2613" translate="yes" xml:space="preserve">
          <source>The MariaDB user name to use when connecting to the server. The default is root.</source>
          <target state="translated">서버에 연결할 때 사용할 MariaDB 사용자 이름입니다. 디폴트는 root입니다.</target>
        </trans-unit>
        <trans-unit id="d7c723a5563170d415b717a41b437da8af22d78b" translate="yes" xml:space="preserve">
          <source>The MariaDB user needs to be granted the execute privileges for these procedures and the select privileges for the tables in the &lt;em&gt;infinidb_querystats&lt;/em&gt; schema. Or, chances are, the following should just work for a super user:</source>
          <target state="translated">MariaDB 사용자에게는 이러한 프로 시저에 대한 실행 권한과 &lt;em&gt;infinidb_querystats&lt;/em&gt; 스키마 의 테이블에 대한 선택 권한이 부여되어야합니다 . 또는 다음은 수퍼 유저에게만 적용되어야합니다.</target>
        </trans-unit>
        <trans-unit id="1ea41dabd9240a95a62e952d6ee3ef81d64dea52" translate="yes" xml:space="preserve">
          <source>The MariaDB username to use when connecting to the server.</source>
          <target state="translated">서버에 연결할 때 사용할 MariaDB 사용자 이름입니다.</target>
        </trans-unit>
        <trans-unit id="951e95fe7fb26f5f5071633ca5702b954fb22a20" translate="yes" xml:space="preserve">
          <source>The Mariabackup utility performs physical backups and supports Data-at-Rest...</source>
          <target state="translated">Mariabackup 유틸리티는 실제 백업을 수행하고 미사용 데이터를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="27d10c70da730f027924f7a27f5b1009f826e470" translate="yes" xml:space="preserve">
          <source>The Master User Module will be assigned in the my.cnf file with SERVER-ID of 1. User Module #1 is the default Master at system startup. In the case of a failover where UM1 goes offline and another User Modules takes over as the Master, that User Module will be updated as SERVER-ID of 1. When User Module #1 recovers, it will be assigned a non 1 ID.</source>
          <target state="translated">마스터 사용자 모듈은 SERVER-ID가 1 인 my.cnf 파일에 할당됩니다. 사용자 모듈 # 1은 시스템 시작시 기본 마스터입니다. UM1이 오프라인 상태가되고 다른 사용자 모듈이 마스터로 대체되는 장애 조치의 경우 해당 사용자 모듈은 SERVER-ID 1로 업데이트됩니다. 사용자 모듈 # 1이 복구되면 1이 아닌 ID가 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="0bffd29cab3f687af427cf4baea21addae3d5633" translate="yes" xml:space="preserve">
          <source>The MaxScale CDC Data Adapter allows to stream change data events(binary log events) from MariaDB Master hosting non-columnstore engines(InnoDB, MyRocks, MyISAM) to MariaDB ColumnStore. In another words replicate data from MariaDB Master to MariaDB ColumnStore. It acts as a CDC Client for MaxScale and uses the events received from MaxScale as input to MariaDB ColumnStore Bulk Data API to push the data to MariaDB ColumnStore.</source>
          <target state="translated">MaxScale CDC 데이터 어댑터를 사용하면 비열 저장소 엔진 (InnoDB, MyRocks, MyISAM)을 호스팅하는 MariaDB Master에서 MariaDB ColumnStore로 변경 데이터 이벤트 (이진 로그 이벤트)를 스트리밍 할 수 있습니다. 즉, MariaDB Master에서 MariaDB ColumnStore로 데이터를 복제합니다. MaxScale의 CDC 클라이언트 역할을하며 MaxScale에서 수신 한 이벤트를 MariaDB ColumnStore 벌크 데이터 API에 대한 입력으로 사용하여 데이터를 MariaDB ColumnStore에 푸시합니다.</target>
        </trans-unit>
        <trans-unit id="cdd8c7a54a6a511f4498caf7f57e07644b3e4ca5" translate="yes" xml:space="preserve">
          <source>The MaxScale CDC Streaming Data Adapter allows you to stream binary log events from MariaDB Servers to MariaDB ColumnStore clusters. In order to use it, install the ColumnStore Bulk Write SDK and the MaxScale CDC Adapter packages on a dedicated host or on any MaxScale server that you want to use for data streaming, (&lt;code&gt;MaxScale-1&lt;/code&gt; in our sample deployment).</source>
          <target state="translated">MaxScale CDC 스트리밍 데이터 어댑터를 사용하면 이진 로그 이벤트를 MariaDB 서버에서 MariaDB ColumnStore 클러스터로 스트리밍 할 수 있습니다. 이를 사용하려면 전용 호스트 또는 데이터 스트리밍에 사용할 MaxScale 서버 ( 샘플 배포의 &lt;code&gt;MaxScale-1&lt;/code&gt; ) 에 ColumnStore Bulk Write SDK 및 MaxScale CDC Adapter 패키지를 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="39fee4ca9181a10c7601d0803455b7ba85f8a9f8" translate="yes" xml:space="preserve">
          <source>The MongoDB syntax for Jpath does not allow the CONNECT specific items on arrays. The same effect can still be obtained by a different way. For this, additional options are used when creating MONGO tables.</source>
          <target state="translated">Jpath의 MongoDB 구문은 배열의 CONNECT 특정 항목을 허용하지 않습니다. 다른 방법으로도 동일한 효과를 얻을 수 있습니다. 이를 위해 MONGO 테이블을 작성할 때 추가 옵션이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f5bf5beec54aa782ae9ada1ca7736f8d9ef4e229" translate="yes" xml:space="preserve">
          <source>The Monro</source>
          <target state="translated">몬로</target>
        </trans-unit>
        <trans-unit id="7efd1fadce781493557692b969bdeead60c93cb8" translate="yes" xml:space="preserve">
          <source>The MyISAM log records all changes to &lt;a href=&quot;../myisam/index&quot;&gt;MyISAM&lt;/a&gt; tables. It is not enabled by default. To enable it, start the server with the &lt;a href=&quot;../mysqld-options/index#-log-isam&quot;&gt;--log-isam&lt;/a&gt; option, for example:</source>
          <target state="translated">MyISAM 로그는 &lt;a href=&quot;../myisam/index&quot;&gt;MyISAM&lt;/a&gt; 테이블의 모든 변경 사항을 기록합니다 . 기본적으로 활성화되어 있지 않습니다. 이를 활성화하려면 &lt;a href=&quot;../mysqld-options/index#-log-isam&quot;&gt;--log-isam&lt;/a&gt; 옵션으로 서버를 시작하십시오 ( 예 :</target>
        </trans-unit>
        <trans-unit id="1c51e666cccb38bfa1409f3f3a2c70702bb98e1f" translate="yes" xml:space="preserve">
          <source>The MyISAM storage engine supports three different table storage formats</source>
          <target state="translated">MyISAM 스토리지 엔진은 세 가지 다른 테이블 스토리지 형식을 지원합니다</target>
        </trans-unit>
        <trans-unit id="ec81d36fff0a9d999e78fbcb60bc5a21ac0a7760" translate="yes" xml:space="preserve">
          <source>The MyISAM storage engine was the default storage engine from MySQL 3.23 until it was replaced by &lt;a href=&quot;../innodb/index&quot;&gt;InnoDB&lt;/a&gt; in MariaDB and MySQL 5.5. Historically, MyISAM is a replacement for the older ISAM engine, removed in MySQL 4.1.</source>
          <target state="translated">MyISAM 스토리지 엔진은 MariaDB 및 MySQL 5.5에서 &lt;a href=&quot;../innodb/index&quot;&gt;InnoDB&lt;/a&gt; 로 대체 될 때까지 MySQL 3.23의 기본 스토리지 엔진이었습니다 . 역사적으로 MyISAM은 MySQL 4.1에서 제거 된 이전 ISAM 엔진을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="5d3355386efd908ef9664d0dea3787ba5d71abe5" translate="yes" xml:space="preserve">
          <source>The MyISAM-like &lt;code&gt;DYNAMIC&lt;/code&gt; and &lt;code&gt;FIXED&lt;/code&gt; format are extremely simple and have very little space overhead, so it's hard to beat them for when it comes to simple scanning of unmodified data. The &lt;code&gt;DYNAMIC&lt;/code&gt; format does however get notably worse over time if you update the row a lot in a manner that increases the size of the row.</source>
          <target state="translated">MyISAM과 같은 &lt;code&gt;DYNAMIC&lt;/code&gt; 및 &lt;code&gt;FIXED&lt;/code&gt; 형식은 매우 간단하고 공간 오버 헤드가 거의 없으므로 수정되지 않은 데이터를 간단하게 스캔 할 때이를 극복하기가 어렵습니다. &lt;code&gt;DYNAMIC&lt;/code&gt; 당신이 행의 크기를 증가시키는 방식으로 열을 많이 업데이트 할 경우 형식은 그러나 시간이 지남에 특히 악화 않습니다.</target>
        </trans-unit>
        <trans-unit id="a5542264be4b5b5f4a753d376a87be111d1991f8" translate="yes" xml:space="preserve">
          <source>The MyRocks storage engine can also be installed via a package manager on Linux. In order to do so, your system needs to be configured to install from one of the MariaDB repositories.</source>
          <target state="translated">MyRocks 스토리지 엔진은 Linux의 패키지 관리자를 통해 설치할 수도 있습니다. 이렇게하려면 MariaDB 저장소 중 하나에서 설치하도록 시스템을 구성해야합니다.</target>
        </trans-unit>
        <trans-unit id="8916a87e04a0b3ff5c8343b1b16b722817d0ae3c" translate="yes" xml:space="preserve">
          <source>The MyRocks storage engine is included in &lt;a href=&quot;../installing-mariadb-binary-tarballs/index&quot;&gt;binary tarballs&lt;/a&gt; on Linux.</source>
          <target state="translated">MyRocks 스토리지 엔진은 Linux의 &lt;a href=&quot;../installing-mariadb-binary-tarballs/index&quot;&gt;바이너리 tarball&lt;/a&gt; 에 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f95e3b4a26b8d2af88209a0fd90850a0b2c0119" translate="yes" xml:space="preserve">
          <source>The MyRocks storage engine is included in &lt;a href=&quot;../installing-mariadb-msi-packages-on-windows/index&quot;&gt;MSI&lt;/a&gt; and &lt;a href=&quot;../installing-mariadb-windows-zip-packages/index&quot;&gt;ZIP&lt;/a&gt; packages on Windows.</source>
          <target state="translated">MyRocks 스토리지 엔진은 Windows의 &lt;a href=&quot;../installing-mariadb-msi-packages-on-windows/index&quot;&gt;MSI&lt;/a&gt; 및 &lt;a href=&quot;../installing-mariadb-windows-zip-packages/index&quot;&gt;ZIP&lt;/a&gt; 패키지에 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="765278e911f7024127b79b49e383a241372fe2a0" translate="yes" xml:space="preserve">
          <source>The MyRocks storage engine was first released in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1025-release-notes/&quot;&gt;MariaDB 10.2.5&lt;/a&gt;.</source>
          <target state="translated">MyRocks 스토리지 엔진은 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1025-release-notes/&quot;&gt;MariaDB 10.2.5&lt;/a&gt; 에서 처음 릴리스되었습니다 .</target>
        </trans-unit>
        <trans-unit id="fd4d90c3a4d99e921c82042fc0bd8d88c784734d" translate="yes" xml:space="preserve">
          <source>The MyRocks storage engine's shared library is included in MariaDB packages as the &lt;code&gt;ha_rocksdb.so&lt;/code&gt; or &lt;code&gt;ha_rocksdb.dll&lt;/code&gt; shared library on systems where it can be built. The plugin was first included in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1025-release-notes/&quot;&gt;MariaDB 10.2.5&lt;/a&gt;.</source>
          <target state="translated">MyRocks 스토리지 엔진의 공유 라이브러리는 MariaDB 패키지 에 빌드 할 수있는 시스템에서 &lt;code&gt;ha_rocksdb.so&lt;/code&gt; 또는 &lt;code&gt;ha_rocksdb.dll&lt;/code&gt; 공유 라이브러리 로 포함되어 있습니다. 플러그인은 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1025-release-notes/&quot;&gt;MariaDB 10.2.5&lt;/a&gt; 에 처음 포함되었습니다 .</target>
        </trans-unit>
        <trans-unit id="d069adff90abb877bb8939ca5f8e5f25af1ec118" translate="yes" xml:space="preserve">
          <source>The MySQL version of &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#max_statement_time&quot;&gt;max_statement_time&lt;/a&gt;&lt;/code&gt; is defined in millseconds, not seconds</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../server-system-variables/index#max_statement_time&quot;&gt;max_statement_time&lt;/a&gt;&lt;/code&gt; 의 MySQL 버전은 초가 아닌 밀리 초로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="9f0a79ff206a18614896ee4d0a7ff536d607ba6f" translate="yes" xml:space="preserve">
          <source>The MySQL/MariaDB connectors retrieve all the rows returned by one query and keep them in a memory cache. This is generally fine in most cases, but not when retrieving a large result set that can make the query fail with a memory exhausted exception.</source>
          <target state="translated">MySQL / MariaDB 커넥터는 하나의 쿼리에서 반환 된 모든 행을 검색하여 메모리 캐시에 보관합니다. 대부분의 경우 문제가 없지만 메모리 소진 예외로 인해 쿼리가 실패 할 수있는 큰 결과 집합을 검색 할 때는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7d74ae90554996e51f868b765256be12cb9617aa" translate="yes" xml:space="preserve">
          <source>The NDB cluster engine does not support changing the binlog format on the fly yet</source>
          <target state="translated">NDB 클러스터 엔진은 아직 binlog 형식 변경을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6c3cf93d5b849c1b15b8faf8de81753283d73942" translate="yes" xml:space="preserve">
          <source>The NTH_VALUE() function was first introduced with other &lt;a href=&quot;../window-functions/index&quot;&gt;window functions&lt;/a&gt; in &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt;.</source>
          <target state="translated">NTH_VALUE () 함수는 처음 도입 된 다른 &lt;a href=&quot;../window-functions/index&quot;&gt;윈도우 함수&lt;/a&gt; 에 &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="61c0d53224386c15a6c537d9765666af02edb773" translate="yes" xml:space="preserve">
          <source>The NTILE() function was first introduced with &lt;a href=&quot;../window-functions/index&quot;&gt;window functions&lt;/a&gt; in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1020-release-notes/&quot;&gt;MariaDB 10.2.0&lt;/a&gt;.</source>
          <target state="translated">NTILE () 함수는 처음 도입 된 &lt;a href=&quot;../window-functions/index&quot;&gt;윈도우 함수&lt;/a&gt; 의 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1020-release-notes/&quot;&gt;MariaDB 10.2.0&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="589ec140e7272e1049b0b25e46f9122356443b8c" translate="yes" xml:space="preserve">
          <source>The NTile window function allows for breaking up a data set into portions assigned a numeric value to each portion of the range. NTile(4) breaks the data up into quartiles (4 sets). The example query produces a report of all opportunities summarizing the quartile boundaries of amount values.</source>
          <target state="translated">NTile 창 기능을 사용하면 데이터 세트를 범위의 각 부분에 숫자 값이 할당 된 부분으로 나눌 수 있습니다. NTile (4)는 데이터를 사 분위수 (4 세트)로 나눕니다. 예제 쿼리는 금액 값의 사 분위 경계를 요약하는 모든 기회에 대한 보고서를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="35f0de90296cbe16b8e4953ad12c93e10b05a4be" translate="yes" xml:space="preserve">
          <source>The Name of the Process (example: ProcessMonitor) followed by the pid enclosed into []</source>
          <target state="translated">프로세스 이름 (예 : ProcessMonitor) 다음에 []로 묶인 pid</target>
        </trans-unit>
        <trans-unit id="79073eaaf28c99d8f76b395dbe1e9f7e71fdc264" translate="yes" xml:space="preserve">
          <source>The Netherlands</source>
          <target state="translated">네덜란드</target>
        </trans-unit>
        <trans-unit id="bde7bfd92a7f7df004973f41505376c51a2b629a" translate="yes" xml:space="preserve">
          <source>The Nodir option (Windows)</source>
          <target state="translated">Nodir 옵션 (Windows)</target>
        </trans-unit>
        <trans-unit id="98e120105f93993e51ac25b702d46b6df6a3c67b" translate="yes" xml:space="preserve">
          <source>The OAM addDbRoot command is used to create the physical storage (dbroot):</source>
          <target state="translated">OAM addDbRoot 명령은 실제 ​​스토리지 (dbroot)를 작성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2f598c9d4dfa191ce06a869aaff0dc3128d668fa" translate="yes" xml:space="preserve">
          <source>The ODBC defined attributes are:</source>
          <target state="translated">ODBC 정의 속성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c5008ede9b53ab26f299dcfb63db9e17bd374487" translate="yes" xml:space="preserve">
          <source>The OEM table MONGO (see &lt;a href=&quot;../connect-oem-table-example/index&quot;&gt;CONNECT - OEM Table Example&lt;/a&gt; for an example with source) permits using MONGO-like tables with MariaDB binary distributions containing but not enabling the &lt;a href=&quot;../connect-mongo-table-type/index&quot;&gt;MONGO table type&lt;/a&gt;</source>
          <target state="translated">OEM 테이블 MONGO ( 소스가있는 예제는 &lt;a href=&quot;../connect-oem-table-example/index&quot;&gt;CONNECT-OEM 테이블 예&lt;/a&gt; 참조 )는 &lt;a href=&quot;../connect-mongo-table-type/index&quot;&gt;MONGO 테이블 유형을&lt;/a&gt; 포함하지만 사용하지 않는 MariaDB 이진 분산으로 MONGO 유사 테이블을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6724eebad42bedbbf04866e3d1e2449d08818d89" translate="yes" xml:space="preserve">
          <source>The OQGRAPH storage engine exists as a separate package in the repositories for &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1007-release-notes/&quot;&gt;MariaDB 10.0.7&lt;/a&gt; and later. On Ubuntu and Debian the package is called &lt;code&gt;mariadb-oqgraph-engine-10.0&lt;/code&gt; or &lt;code&gt;mariadb-plugin-oqgraph&lt;/code&gt;. On Red Hat, CentOS, and Fedora the package is called &lt;code&gt;MariaDB-oqgraph-engine&lt;/code&gt;. To install the plugin, first install the appropriate package and then install the plugin using the &lt;a href=&quot;../install-soname/index&quot;&gt;INSTALL SONAME&lt;/a&gt; or &lt;a href=&quot;../install-plugin/index&quot;&gt;INSTALL PLUGIN&lt;/a&gt; commands.</source>
          <target state="translated">OQGRAPH 스토리지 엔진은 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1007-release-notes/&quot;&gt;MariaDB&lt;/a&gt; 10.0.7 이상의 저장소에 별도의 패키지로 존재합니다 . 우분투와 데비안에서 패키지는 &lt;code&gt;mariadb-oqgraph-engine-10.0&lt;/code&gt; 또는 &lt;code&gt;mariadb-plugin-oqgraph&lt;/code&gt; 입니다. Red Hat, CentOS 및 Fedora에서 패키지는 &lt;code&gt;MariaDB-oqgraph-engine&lt;/code&gt; 입니다. 플러그인을 설치하려면 먼저 적절한 패키지를 설치 한 다음 &lt;a href=&quot;../install-soname/index&quot;&gt;INSTALL SONAME&lt;/a&gt; 또는 &lt;a href=&quot;../install-plugin/index&quot;&gt;INSTALL PLUGIN&lt;/a&gt; 명령을 사용하여 플러그인을 설치하십시오 .</target>
        </trans-unit>
        <trans-unit id="f7bd80c5fd310acd26c153551a1374d707b4a587" translate="yes" xml:space="preserve">
          <source>The ORDER BY clause presents results in a specific order. Note that the ORDER BY clause represents a statement that is post-processed by MariaDB. The following statement returns an ordered &lt;em&gt;quantity&lt;/em&gt; column from the &lt;em&gt;lineitem&lt;/em&gt; table.</source>
          <target state="translated">ORDER BY 절은 특정 순서로 결과를 제공합니다. ORDER BY 절은 MariaDB에 의해 사후 처리되는 명령문을 나타냅니다. 다음 명령문은 &lt;em&gt;lineitem&lt;/em&gt; 테이블 에서 주문 &lt;em&gt;수량&lt;/em&gt; 열을 리턴 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6c74267674b4d479b9ead94095f3f99a10281844" translate="yes" xml:space="preserve">
          <source>The OS and MariaDB have allocated all the 'first' RAM.</source>
          <target state="translated">OS와 MariaDB는 모든 '첫 번째'RAM을 할당했습니다.</target>
        </trans-unit>
        <trans-unit id="30b48b5c67b0f521e978c16f25ead290397eaa43" translate="yes" xml:space="preserve">
          <source>The OS has some limit on the number of open files it will let a process have. Each table needs 1 to 3 open files. Each PARTITION is effectively a table. Most operations on a partitioned table open _all_ partitions.</source>
          <target state="translated">OS는 프로세스가 가질 수있는 열린 파일 수에 제한이 있습니다. 각 테이블에는 1-3 개의 열린 파일이 필요합니다. 각 PARTITION은 사실상 테이블입니다. 파티션 된 테이블에 대한 대부분의 작업은 _all_ 파티션을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="ec94ba54ae6843fdd2f6bdff6003b4cf04123bc0" translate="yes" xml:space="preserve">
          <source>The OS is not limited by 4GB, but MariaDB is.</source>
          <target state="translated">OS는 4GB로 제한되지 않지만 MariaDB는 제한적입니다.</target>
        </trans-unit>
        <trans-unit id="230255419dd2534eb882a400679f1277cf8e5691" translate="yes" xml:space="preserve">
          <source>The OS needs to allocate something. Ouch -- it is out of room in the one CPU where it is willing to allocate its stuff, so it swaps out some of MariaDB. Bad.</source>
          <target state="translated">OS는 무언가를 할당해야합니다. 아야-하나의 CPU에서 물건을 할당하려고하는 공간이 부족하므로 MariaDB의 일부를 교환합니다. 나쁜.</target>
        </trans-unit>
        <trans-unit id="ebefadc1a7162027935540066037b1badbd42698" translate="yes" xml:space="preserve">
          <source>The Ocelot GUI (ocelotgui), a database client, allows users to connect to a MySQL or MariaDB DBMS server, enter SQL statements, and receive results. Some of its features are: syntax highlighting, user-settable colors and fonts for each part of the screen, result-set displays with multi-line rows and resizable columns, and a debugger.</source>
          <target state="translated">데이터베이스 클라이언트 인 Ocelot GUI (ocelotgui)를 통해 사용자는 MySQL 또는 MariaDB DBMS 서버에 연결하고 SQL 문을 입력하고 결과를 수신 할 수 있습니다. 그 기능 중 일부는 구문 강조, 화면의 각 부분에 대한 사용자 설정 가능한 색상 및 글꼴, 여러 줄의 행과 크기 조정 가능한 열이있는 결과 세트 표시 및 디버거입니다.</target>
        </trans-unit>
        <trans-unit id="ef4d3d7fa52483639333421ec7046c90d730d8aa" translate="yes" xml:space="preserve">
          <source>The Open Query GRAPH computation engine, or OQGRAPH as the engine itself is called, allows you to handle hierarchies (tree structures) and complex graphs (nodes having many connections in several directions).</source>
          <target state="translated">Open Query GRAPH 계산 엔진 또는 엔진 자체가 호출되는 OQGRAPH를 사용하면 계층 구조 (트리 구조)와 복잡한 그래프 (여러 방향으로 많은 연결이있는 노드)를 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="95e7199bdf4c547dbf52ccc689db745c67430fee" translate="yes" xml:space="preserve">
          <source>The Oracle mode version of the function can be accessed outside of Oracle mode by using &lt;code&gt;LPAD_ORACLE&lt;/code&gt; as the function name.</source>
          <target state="translated">함수의 Oracle 모드 버전은 &lt;code&gt;LPAD_ORACLE&lt;/code&gt; 을 함수 이름으로 사용하여 Oracle 모드 외부에서 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4149bb0f90d4a16b5066141f7bed83cb8351b67d" translate="yes" xml:space="preserve">
          <source>The Oracle mode version of the function can be accessed outside of Oracle mode by using &lt;code&gt;LTRIM_ORACLE&lt;/code&gt; as the function name.</source>
          <target state="translated">함수의 Oracle 모드 버전은 &lt;code&gt;LTRIM_ORACLE&lt;/code&gt; 을 함수 이름으로 사용하여 Oracle 모드 외부에서 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2ff78386e7ab7e4554f2289f6fb0af2eb25bc4a8" translate="yes" xml:space="preserve">
          <source>The Oracle mode version of the function can be accessed outside of Oracle mode by using &lt;code&gt;RPAD_ORACLE&lt;/code&gt; as the function name.</source>
          <target state="translated">함수의 Oracle 모드 버전은 함수 이름으로 &lt;code&gt;RPAD_ORACLE&lt;/code&gt; 을 사용하여 Oracle 모드 외부에서 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f210e181b921fe293195011a385a6c488d72b964" translate="yes" xml:space="preserve">
          <source>The Oracle mode version of the function can be accessed outside of Oracle mode by using &lt;code&gt;RTRIM_ORACLE&lt;/code&gt; as the function name.</source>
          <target state="translated">함수의 Oracle 모드 버전은 함수 이름으로 &lt;code&gt;RTRIM_ORACLE&lt;/code&gt; 을 사용하여 Oracle 모드 외부에서 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d3da3ffe5338038a889b267e20e54e326e739416" translate="yes" xml:space="preserve">
          <source>The Oracle mode version of the function can be accessed outside of Oracle mode by using &lt;code&gt;TRIM_ORACLE&lt;/code&gt; as the function name.</source>
          <target state="translated">함수의 Oracle 모드 버전은 함수 이름으로 &lt;code&gt;TRIM_ORACLE&lt;/code&gt; 을 사용하여 Oracle 모드 외부에서 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5d338bcc28d7c22814ade45029f528286a39785a" translate="yes" xml:space="preserve">
          <source>The PAM plugin can also be utilized for LDAP group authentication. A good reference written by a MariaDB support engineer on setting up OpenLDAP can be found &lt;a href=&quot;http://www.geoffmontee.com/configuring-ldap-authentication-and-group-mapping-with-mariadb/&quot;&gt;here&lt;/a&gt;. Some additional notes that may be of help:</source>
          <target state="translated">PAM 플러그인은 LDAP 그룹 인증에도 사용될 수 있습니다. OpenLDAP 설정에 대한 MariaDB 지원 엔지니어가 작성한 좋은 참고 자료는 &lt;a href=&quot;http://www.geoffmontee.com/configuring-ldap-authentication-and-group-mapping-with-mariadb/&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다 . 도움이 될만한 추가 참고 사항 :</target>
        </trans-unit>
        <trans-unit id="15cb1388a2daf7d8a22b16172ab72d7532299814" translate="yes" xml:space="preserve">
          <source>The PAM user mapping library must be built and installed locally:</source>
          <target state="translated">PAM 사용자 매핑 라이브러리는 로컬로 구축 및 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="5ef082514cb8dec6ba63d9c3246d244245b2f1f2" translate="yes" xml:space="preserve">
          <source>The PARTITION clause is supported for all DML statements:</source>
          <target state="translated">PARTITION 절은 모든 DML 문에 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="51d633e6ec4602913ca4bfd8e1fb6c5d41fcf573" translate="yes" xml:space="preserve">
          <source>The PARTITION clause was introduced in &lt;a href=&quot;../what-is-mariadb-100/index&quot;&gt;MariaDB 10.0&lt;/a&gt;. It can be used in both the INSERT and the SELECT part. See &lt;a href=&quot;../partition-pruning-and-selection/index&quot;&gt;Partition Pruning and Selection&lt;/a&gt; for details.</source>
          <target state="translated">PARTITION 절은 &lt;a href=&quot;../what-is-mariadb-100/index&quot;&gt;MariaDB 10.0&lt;/a&gt; 에서 도입되었습니다 . INSERT 및 SELECT 부분 모두에 사용할 수 있습니다. 자세한 내용은 &lt;a href=&quot;../partition-pruning-and-selection/index&quot;&gt;파티션 정리 및 선택&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d317944c3a610dba3dd849e53c6fc44ee545b204" translate="yes" xml:space="preserve">
          <source>The PARTITION clause was introduced in &lt;a href=&quot;../what-is-mariadb-100/index&quot;&gt;MariaDB 10.0&lt;/a&gt;. See &lt;a href=&quot;../partition-pruning-and-selection/index&quot;&gt;Partition Pruning and Selection&lt;/a&gt; for details.</source>
          <target state="translated">PARTITION 절은 &lt;a href=&quot;../what-is-mariadb-100/index&quot;&gt;MariaDB 10.0&lt;/a&gt; 에서 도입되었습니다 . 자세한 내용은 &lt;a href=&quot;../partition-pruning-and-selection/index&quot;&gt;파티션 정리 및 선택&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4bb2f1d16b4eb03a3d00e9158ed9b85d20d26c20" translate="yes" xml:space="preserve">
          <source>The PASSWORD() function is used for hashing passwords for use in authentication by the MariaDB server. It is not intended for use in other applications.</source>
          <target state="translated">PASSWORD () 함수는 MariaDB 서버의 인증에 사용하기 위해 비밀번호를 해싱하는 데 사용됩니다. 다른 응용 프로그램에서 사용하기위한 것이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="2ee87ca69138e9e32b27f0360a2e45f8f7e852fc" translate="yes" xml:space="preserve">
          <source>The PBXT versions in various releases are:</source>
          <target state="translated">다양한 릴리스의 PBXT 버전은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7ddcceef9d06bbebe00e60a2711eb6b3932c6a27" translate="yes" xml:space="preserve">
          <source>The PERCENTILE_CONT() &lt;a href=&quot;../window-functions/index&quot;&gt;window function&lt;/a&gt; was first introduced with in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1033-release-notes/&quot;&gt;MariaDB 10.3.3&lt;/a&gt;.</source>
          <target state="translated">PERCENTILE_CONT () &lt;a href=&quot;../window-functions/index&quot;&gt;창 함수&lt;/a&gt; 는 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1033-release-notes/&quot;&gt;MariaDB 10.3.3&lt;/a&gt; 에서 처음 도입되었습니다 .</target>
        </trans-unit>
        <trans-unit id="30b5a70fc7c41825dc233112143f6e03def73dae" translate="yes" xml:space="preserve">
          <source>The PERCENTILE_DISC() &lt;a href=&quot;../window-functions/index&quot;&gt;window function&lt;/a&gt; was first introduced with in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1033-release-notes/&quot;&gt;MariaDB 10.3.3&lt;/a&gt;.</source>
          <target state="translated">PERCENTILE_DISC () &lt;a href=&quot;../window-functions/index&quot;&gt;창 함수&lt;/a&gt; 는 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1033-release-notes/&quot;&gt;MariaDB 10.3.3&lt;/a&gt; 에서 처음 도입되었습니다 .</target>
        </trans-unit>
        <trans-unit id="5193429f533ad3096e4cf17e437217c19704c482" translate="yes" xml:space="preserve">
          <source>The PERCENT_RANK() function was first introduced with &lt;a href=&quot;../window-functions/index&quot;&gt;window functions&lt;/a&gt; in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1020-release-notes/&quot;&gt;MariaDB 10.2.0&lt;/a&gt;.</source>
          <target state="translated">PERCENT_RANK () 함수는 처음 도입 된 &lt;a href=&quot;../window-functions/index&quot;&gt;윈도우 함수&lt;/a&gt; 의 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1020-release-notes/&quot;&gt;MariaDB 10.2.0&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bec06cc4f7f7e396d7d5f0bd89e3b2f2d448a3bd" translate="yes" xml:space="preserve">
          <source>The PM from which the query was launched. This function will return NULL if the query is launched from a standalone UM</source>
          <target state="translated">쿼리가 시작된 PM 쿼리가 독립형 UM에서 시작된 경우이 함수는 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="49aa9ef78f34ddd88dc65c128e9220378357bc08" translate="yes" xml:space="preserve">
          <source>The PM processes the request using many threads and returns its response. These generally take a fraction of a second up to a low number of seconds depending on the amount of Physical I/O and the performance of that storage.</source>
          <target state="translated">PM은 많은 스레드를 사용하여 요청을 처리하고 응답을 반환합니다. 일반적으로 물리적 I / O의 양과 해당 스토리지의 성능에 따라 1 초에서 최대 몇 초까지 소요됩니다.</target>
        </trans-unit>
        <trans-unit id="f6fac984c89edfad2d08716a125e4273995cb405" translate="yes" xml:space="preserve">
          <source>The PM where the physical row resides</source>
          <target state="translated">실제 행이있는 PM</target>
        </trans-unit>
        <trans-unit id="74d9c84a526db4072e64d48405bbc898e84028a5" translate="yes" xml:space="preserve">
          <source>The PMs do not require a public LAN access as they only need to communicate with the UMs, unless the local query feature is desired.</source>
          <target state="translated">로컬 쿼리 기능이 필요하지 않으면 PM은 UM과 통신하기 만하면되므로 공용 LAN 액세스가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6195c83320c365801b7a2a2bf8507d1a549f35c9" translate="yes" xml:space="preserve">
          <source>The PMs do not require a public LAN access as they only need to communicate with the UMs.</source>
          <target state="translated">PM은 UM과 통신하기 만하면되므로 공용 LAN 액세스가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a7313ce9eb2e53614fd06a49470ef3d48bab42c6" translate="yes" xml:space="preserve">
          <source>The PRIMARY KEY must</source>
          <target state="translated">기본 키는</target>
        </trans-unit>
        <trans-unit id="289646bda68879f3f2c5fe5a7812694ed7870732" translate="yes" xml:space="preserve">
          <source>The PROCEDURE Clause of the SELECT Statement.</source>
          <target state="translated">SELECT 문의 PROCEDURE 절</target>
        </trans-unit>
        <trans-unit id="94a613ecf4b4c3d863b6892e8c74a9140d9eae83" translate="yes" xml:space="preserve">
          <source>The PROCEDURE clause cannot be used in a view definition, and it cannot be used if a view is referenced in the FROM clause.</source>
          <target state="translated">PROCEDURE 절은보기 정의에서 사용될 수 없으며, FROM 절에서보기가 참조되면 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="43f25e975bf86d7d63d0a76d21ce38873eeedfbd" translate="yes" xml:space="preserve">
          <source>The Park Slope Chipshop</source>
          <target state="translated">파크 슬로프 칩숍</target>
        </trans-unit>
        <trans-unit id="02d3322041b08eb1b0c7e4536915a6bb22a74a0f" translate="yes" xml:space="preserve">
          <source>The Performance Module is composed of a number of processes</source>
          <target state="translated">성능 모듈은 여러 프로세스로 구성됩니다</target>
        </trans-unit>
        <trans-unit id="743c49ebd034e4d0c46e5c67dd4bf7a41dd6db57" translate="yes" xml:space="preserve">
          <source>The Performance Module or Modules carry out predicate filtering, join processing, initial aggregation of data from local or external storage, then send the data back to the User Module.</source>
          <target state="translated">성능 모듈 (들)은 술어 필터링, 결합 처리, 로컬 또는 외부 스토리지에서 데이터의 초기 집계를 수행 한 다음 데이터를 사용자 모듈로 다시 보냅니다.</target>
        </trans-unit>
        <trans-unit id="0672b47a86654debb20bec45bea87ad43b9b9c04" translate="yes" xml:space="preserve">
          <source>The Performance Module performs I/O operations in support of read and write processing. It doesn't see the query itself, but only a set of instructions given to it by a &lt;a href=&quot;../columnstore-user-module/index&quot;&gt;User Module&lt;/a&gt;.</source>
          <target state="translated">성능 모듈은 읽기 및 쓰기 처리를 지원하기 위해 I / O 작업을 수행합니다. 쿼리 자체는 보이지 않지만 &lt;a href=&quot;../columnstore-user-module/index&quot;&gt;사용자 모듈이&lt;/a&gt; 제공 한 일련의 명령 만 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9bad7fb40c8ea5f8577127ce513d6a03c6b8e5fa" translate="yes" xml:space="preserve">
          <source>The Performance Module processes loads and writes to the underlying persistent storage. It uses two processes to handle this: WriteEngineServer and cpimport.</source>
          <target state="translated">성능 모듈은 기본 영구 스토리지에 대한로드 및 쓰기를 처리합니다. 이를 처리하기 위해 WriteEngineServer와 cpimport라는 두 가지 프로세스를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a9514bfc9a23964cc46e90cb21bfcd3ff89b3278" translate="yes" xml:space="preserve">
          <source>The Performance Module uses a shared nothing data cache. When it first accesses data, it operates on data as instructed by the &lt;a href=&quot;../columnstore-user-module/index&quot;&gt;User Module&lt;/a&gt; and caches it in an LRU-based buffer for subsequent access.</source>
          <target state="translated">성능 모듈은 공유 데이터 캐시를 사용합니다. 데이터에 처음 액세스 할 때 &lt;a href=&quot;../columnstore-user-module/index&quot;&gt;사용자 모듈의&lt;/a&gt; 지시에 따라 데이터에서 작동하고 후속 액세스를 위해 LRU 기반 버퍼에 캐시합니다.</target>
        </trans-unit>
        <trans-unit id="e2b2962f011d97d56da6681a55c16779dcff85da" translate="yes" xml:space="preserve">
          <source>The Performance Schema digest is a normalized form of a statement, with the specific data values removed. It allows statistics to be gathered for similar kinds of statements.</source>
          <target state="translated">성능 스키마 다이제스트는 특정 데이터 값이 제거 된 정규화 된 명령문 양식입니다. 유사한 종류의 문장에 대한 통계를 수집 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20d9a7e1809aea8e04c9e16fc63e55b3d7afcbde" translate="yes" xml:space="preserve">
          <source>The Performance Schema is a feature for monitoring server performance that was introduced in &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt;.</source>
          <target state="translated">성능 스키마는 &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt; 에 도입 된 서버 성능을 모니터링하는 기능입니다 .</target>
        </trans-unit>
        <trans-unit id="8b3d1a2b69dedc75641ae27aaf61a43d6e6cf972" translate="yes" xml:space="preserve">
          <source>The Performance Schema was introduced in &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt;.</source>
          <target state="translated">성능 스키마는 &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt; 에서 도입되었습니다 .</target>
        </trans-unit>
        <trans-unit id="390c3ad7ba6a9d08ed03ce082e7a105438674d9c" translate="yes" xml:space="preserve">
          <source>The Performance-Module 3 will become the active Parent OAM Module</source>
          <target state="translated">Performance-Module 3이 활성 Parent OAM 모듈이됩니다</target>
        </trans-unit>
        <trans-unit id="8653b4c98bc63953d997cc9747e739f7a14bc86e" translate="yes" xml:space="preserve">
          <source>The Pivot table type of CONNECT makes doing this much simpler.</source>
          <target state="translated">피벗 테이블 형식의 CONNECT를 사용하면이 작업이 훨씬 간단 해집니다.</target>
        </trans-unit>
        <trans-unit id="4c0c2a7cbdf7c4dce84822578586d271b5a6e9ef" translate="yes" xml:space="preserve">
          <source>The Pre-install setup time will take longer with the Non-Distributed Installation, but the system Install and startup via the install app 'postConfigure' will be faster.</source>
          <target state="translated">비 분산 설치에서는 사전 설치 설정 시간이 더 오래 걸리지 만 설치 앱 'postConfigure'를 통한 시스템 설치 및 시작이 더 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="ca30c488a38850671b35af98c1c8f644173d2ebc" translate="yes" xml:space="preserve">
          <source>The Pre-install setup time would be shorter with the Non-Distributed Installation, but the system Install and startup via the install app 'postConfigure' will be take longer.</source>
          <target state="translated">비 분산 설치에서는 사전 설치 설정 시간이 짧아 지지만 설치 앱 'postConfigure'를 통한 시스템 설치 및 시작 시간이 더 오래 걸립니다.</target>
        </trans-unit>
        <trans-unit id="1403fb0ad4ec41d6b2d02ce7da3c2c08c3417601" translate="yes" xml:space="preserve">
          <source>The PrimProc process has one job queue for each priority level and thread assigned to each queue. The number of threads assigned to each queue is configurable using the following elements in the configuration file:</source>
          <target state="translated">PrimProc 프로세스에는 각 우선 순위 레벨 및 각 큐에 지정된 스레드마다 하나의 작업 큐가 있습니다. 각 큐에 지정된 스레드 수는 구성 파일에서 다음 요소를 사용하여 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5dbf7502dd99da71ff41bd702e46df4cbe4e0958" translate="yes" xml:space="preserve">
          <source>The Primary Process, or PrimProc, handles query execution. The &lt;a href=&quot;../columnstore-user-module/index&quot;&gt;User Modules&lt;/a&gt; process queries from the application into instructions that are sent to the Performance Module. PrimProc executes these instructions as block oriented I/O operations to perform predicate filtering, join processing, and the initial aggregation of data, after which PrimProc sends the data back to the User Module.</source>
          <target state="translated">기본 프로세스 또는 PrimProc은 쿼리 실행을 처리합니다. &lt;a href=&quot;../columnstore-user-module/index&quot;&gt;사용자 모듈&lt;/a&gt; 프로세스는 성능 모듈로 전송되는 명령으로 응용 프로그램에서 쿼리합니다. PrimProc은 이러한 명령어를 블록 지향 I / O 작업으로 실행하여 술어 필터링, 결합 처리 및 초기 데이터 집계를 수행 한 후 PrimProc이 데이터를 사용자 모듈로 다시 보냅니다.</target>
        </trans-unit>
        <trans-unit id="355c15d3884285cbe9de6e8c0623457a61fdc6ca" translate="yes" xml:space="preserve">
          <source>The Problem</source>
          <target state="translated">문제</target>
        </trans-unit>
        <trans-unit id="dad3bb8c1e0cb73f079af561d19c1e221f7f3212" translate="yes" xml:space="preserve">
          <source>The Process Manager, or ProcMgr, is the process responsible for starting, monitoring and restarting all MariaDB ColumnStore processes on the Performance Module.</source>
          <target state="translated">프로세스 관리자 또는 ProcMgr은 성능 모듈에서 모든 MariaDB ColumnStore 프로세스를 시작, 모니터링 및 다시 시작하는 프로세스입니다.</target>
        </trans-unit>
        <trans-unit id="d2e0c7df75fb7fe9654cd92b7bf7a9b8949618ca" translate="yes" xml:space="preserve">
          <source>The Python 2/Spark part including ColumnStoreExporter</source>
          <target state="translated">ColumnStoreExporter를 포함한 Python 2 / Spark 부분</target>
        </trans-unit>
        <trans-unit id="4665805b0ca14788d69b446ae34828ac77f27992" translate="yes" xml:space="preserve">
          <source>The Python 3/Spark part including ColumnStoreExporter</source>
          <target state="translated">ColumnStoreExporter를 포함한 Python 3 / Spark 부분</target>
        </trans-unit>
        <trans-unit id="c88b98162f03b385097af8e5c87da4a4e652de4f" translate="yes" xml:space="preserve">
          <source>The Python part needed to use the API in Python 2</source>
          <target state="translated">Python 2에서 API를 사용하는 데 필요한 Python 부분</target>
        </trans-unit>
        <trans-unit id="5f3ad45f8ee0ba3a04d73e965cec40ebbb829ff8" translate="yes" xml:space="preserve">
          <source>The Python part needed to use the API in Python 3</source>
          <target state="translated">Python 3에서 Python을 사용하는 데 필요한 Python 부분</target>
        </trans-unit>
        <trans-unit id="b1d1b48881c92e13a5cda128b880f43f26f6164c" translate="yes" xml:space="preserve">
          <source>The QC, unless it is OFF &amp;amp; 0, is consulted for _every_ SELECT.</source>
          <target state="translated">OFF 및 0이 아닌 한 QC는 _every_ SELECT를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="d4ba93da9d7d694ff57c914dcf82af7f9d687dfe" translate="yes" xml:space="preserve">
          <source>The Query Cache</source>
          <target state="translated">쿼리 캐시</target>
        </trans-unit>
        <trans-unit id="92439253dda7ce38c9cc7f737d07d6591ae52a99" translate="yes" xml:space="preserve">
          <source>The Query Cache uses blocks of variable length, and over time may become fragmented. A high &lt;code&gt;Qcache_free_blocks&lt;/code&gt; relative to &lt;code&gt;Qcache_total_blocks&lt;/code&gt; may indicate fragmentation. &lt;code&gt;&lt;a href=&quot;../flush-query-cache/index&quot;&gt;FLUSH QUERY CACHE&lt;/a&gt;&lt;/code&gt; will defragment the query cache without dropping any queries :</source>
          <target state="translated">쿼리 캐시는 가변 길이의 블록을 사용하며 시간이 지남에 따라 조각화 될 수 있습니다. &lt;code&gt;Qcache_total_blocks&lt;/code&gt; 에 비해 높은 &lt;code&gt;Qcache_free_blocks&lt;/code&gt; 는 조각화를 나타낼 수있다. &lt;code&gt;&lt;a href=&quot;../flush-query-cache/index&quot;&gt;FLUSH QUERY CACHE&lt;/a&gt;&lt;/code&gt; 는 쿼리를 삭제하지 않고 쿼리 캐시 조각 모음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="449419b1d223e5d1addfe0bef7df755870966189" translate="yes" xml:space="preserve">
          <source>The R Environment</source>
          <target state="translated">R 환경</target>
        </trans-unit>
        <trans-unit id="8125cba6707f7f3131266dbda46ed8701eb9df61" translate="yes" xml:space="preserve">
          <source>The R Programming language has support for the H2O.ai library (&lt;a href=&quot;https://cran.r-project.org/web/packages/h2o/index.html&quot;&gt;h2o&lt;/a&gt;), which enables to create in-memory multi-cluster GPU powered machine learning models.</source>
          <target state="translated">R 프로그래밍 언어는 메모리 내 다중 클러스터 GPU 기반 머신 러닝 모델을 만들 수 있는 H2O.ai 라이브러리 ( &lt;a href=&quot;https://cran.r-project.org/web/packages/h2o/index.html&quot;&gt;h2o&lt;/a&gt; )를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="c088e226c3e1ac4352484bbcddeba8513ace6124" translate="yes" xml:space="preserve">
          <source>The RANGE partitioning type is used to assign each partition a range of values generated by the partitioning expression. Ranges must be ordered, contiguous and non-overlapping. The minimum value is always included in the first range. The highest value may or may not be included in the last range.</source>
          <target state="translated">RANGE 파티셔닝 유형은 각 파티션에 파티셔닝 표현식으로 생성 된 값 범위를 지정하는 데 사용됩니다. 범위는 연속적이며 겹치지 않도록 주문해야합니다. 최소값은 항상 첫 번째 범위에 포함됩니다. 가장 높은 값은 마지막 범위에 포함되거나 포함되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bc3fba086892c05de68df85ad892b86eb5be018" translate="yes" xml:space="preserve">
          <source>The RANGE partitioning type is used to assign each partition a range of values.</source>
          <target state="translated">RANGE 파티셔닝 유형은 각 파티션에 값 범위를 지정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3f13a98b9e2420f58a0b760ab8cdbd31a0ea320b" translate="yes" xml:space="preserve">
          <source>The RANK() function was first introduced with &lt;a href=&quot;../window-functions/index&quot;&gt;window functions&lt;/a&gt; in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1020-release-notes/&quot;&gt;MariaDB 10.2.0&lt;/a&gt;.</source>
          <target state="translated">랭크 () 함수는 처음 도입 된 &lt;a href=&quot;../window-functions/index&quot;&gt;윈도우 함수&lt;/a&gt; 의 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1020-release-notes/&quot;&gt;MariaDB 10.2.0&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="027f2003bc6fc3896ab20ce964b9cdf02f1d6b6b" translate="yes" xml:space="preserve">
          <source>The REDUNDANT row format is the original non-compacted row format.</source>
          <target state="translated">REDUNDANT 행 형식은 원래 비 압축 행 형식입니다.</target>
        </trans-unit>
        <trans-unit id="e0af1526f2f0fb6e1904b39ce7c132fa8e1469ac" translate="yes" xml:space="preserve">
          <source>The RENAME TABLE statement renames one or more ColumnStore tables.</source>
          <target state="translated">RENAME TABLE 문은 하나 이상의 ColumnStore 테이블 이름을 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="86a3f3c87bfe59a74646d4162a7b097850e9e3e4" translate="yes" xml:space="preserve">
          <source>The RENAME USER statement renames existing MariaDB accounts. To use it, you must have the global &lt;code&gt;&lt;a href=&quot;../grant/index#global-privileges&quot;&gt;CREATE USER&lt;/a&gt;&lt;/code&gt; privilege or the &lt;code&gt;&lt;a href=&quot;../grant/index#table-privileges&quot;&gt;UPDATE&lt;/a&gt;&lt;/code&gt; privilege for the &lt;code&gt;mysql&lt;/code&gt; database. Each account is named using the same format as for the &lt;code&gt;&lt;a href=&quot;../create-user/index&quot;&gt;CREATE USER&lt;/a&gt;&lt;/code&gt; statement; for example, &lt;code&gt;'jeffrey'@'localhost'&lt;/code&gt;. If you specify only the user name part of the account name, a host name part of &lt;code&gt;'%'&lt;/code&gt; is used.</source>
          <target state="translated">RENAME USER 문은 기존 MariaDB 계정의 이름을 바꿉니다. 이를 사용하려면 &lt;code&gt;mysql&lt;/code&gt; 데이터베이스에 대한 글로벌 &lt;code&gt;&lt;a href=&quot;../grant/index#global-privileges&quot;&gt;CREATE USER&lt;/a&gt;&lt;/code&gt; 권한 또는 &lt;code&gt;&lt;a href=&quot;../grant/index#table-privileges&quot;&gt;UPDATE&lt;/a&gt;&lt;/code&gt; 권한이 있어야 합니다. 각 계정은 &lt;code&gt;&lt;a href=&quot;../create-user/index&quot;&gt;CREATE USER&lt;/a&gt;&lt;/code&gt; 문과 동일한 형식으로 이름이 지정됩니다 . 예를 들어, &lt;code&gt;'jeffrey'@'localhost'&lt;/code&gt; 입니다. 계정 이름의 사용자 이름 부분 만 지정하면 &lt;code&gt;'%'&lt;/code&gt; 의 호스트 이름 부분 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a670c15dcdd79c05b5ab7c8a937628e9b3145b2e" translate="yes" xml:space="preserve">
          <source>The RENAME clause allows you to rename a table.The following example renames the orders table:</source>
          <target state="translated">RENAME 절을 사용하면 테이블의 이름을 바꿀 수 있습니다. 다음 예는 orders 테이블의 이름을 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="e0e0776956a415dfeba2789242089bf08f53219b" translate="yes" xml:space="preserve">
          <source>The RENAME is atomic, so the INSERT process(es) never find that `Staging` is missing.</source>
          <target state="translated">RENAME은 원 자성이므로 INSERT 프로세스는 스테이징이 누락되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fe5b4bd97d28281a7f19c5ffeea424eae87499d7" translate="yes" xml:space="preserve">
          <source>The REST UI is installed in &lt;code&gt;/usr/share/shard-query/ui&lt;/code&gt; by default.</source>
          <target state="translated">REST UI는 기본적으로 &lt;code&gt;/usr/share/shard-query/ui&lt;/code&gt; 에 설치 됩니다.</target>
        </trans-unit>
        <trans-unit id="82c0d6584badef7a8a6f31ac73a84b504eef4c47" translate="yes" xml:space="preserve">
          <source>The RESTRICT clause limits the table to being dropped in the front end only. This could be useful when the table has been dropped on one user module, and needs to be synced to others.</source>
          <target state="translated">RESTRICT 절은 테이블이 프론트 엔드에서만 삭제되도록 제한합니다. 한 사용자 모듈에서 테이블을 삭제하고 다른 사용자 모듈과 동기화해야 할 때 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96393f5628be8f1ab2794e51981aeab879843e71" translate="yes" xml:space="preserve">
          <source>The ROLLBACK statement undoes transactions that have not been permanently saved to the database with the COMMIT statement.You cannot rollback changes to table properties including ALTER, CREATE, or DROP TABLE statements.</source>
          <target state="translated">ROLLBACK 문은 COMMIT 문을 사용하여 데이터베이스에 영구적으로 저장되지 않은 트랜잭션을 실행 취소합니다. ALTER, CREATE 또는 DROP TABLE 문을 포함하여 테이블 특성에 대한 변경 사항을 롤백 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9365e9fd2f3a5cf1e6716b8c750dc0f314bda04c" translate="yes" xml:space="preserve">
          <source>The RPM's needed for the installation are all available on the MariaDB website and are given below:</source>
          <target state="translated">설치에 필요한 RPM은 MariaDB 웹 사이트에서 모두 사용할 수 있으며 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f01dac93e48fc2632a48204f7e24f77c0c62940c" translate="yes" xml:space="preserve">
          <source>The S3 engine uses it's own page cache, modified to be able to handle reading blocks from S3 (of size &lt;code&gt;s3_block_size&lt;/code&gt;). Internally the S3 page cache uses pages of &lt;a href=&quot;../aria-system-variables/index#aria_block_size&quot;&gt;aria-block-size&lt;/a&gt; for splitting the blocks read from S3.</source>
          <target state="translated">S3 엔진은 자체 페이지 캐시를 사용하며 S3 ( &lt;code&gt;s3_block_size&lt;/code&gt; 크기 ) 의 읽기 블록을 처리 할 수 ​​있도록 수정되었습니다 . 내부적으로 S3 페이지 캐시는 S3에서 읽은 블록을 분할하기 위해 &lt;a href=&quot;../aria-system-variables/index#aria_block_size&quot;&gt;aria-block-size&lt;/a&gt; 페이지를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="8c87c855907ed079ef3268c99b67bd4c4ccf1b54" translate="yes" xml:space="preserve">
          <source>The S3 storage engine is based on the Aria code.</source>
          <target state="translated">S3 스토리지 엔진은 Aria 코드를 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="3a86e39f3d83cc683c44171566da34800e5ea6f5" translate="yes" xml:space="preserve">
          <source>The S3 storage engine supports full &lt;a href=&quot;../table-discovery/index&quot;&gt;MariaDB discovery&lt;/a&gt;. This means that if you have the S3 storage engine enabled and properly configured, the table stored in S3 will automatically be discovered when it's accessed with &lt;a href=&quot;../show-tables/index&quot;&gt;SHOW TABLES&lt;/a&gt;, &lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt; or any other operation that tries to access it. In the case of SELECT, the .frm file from S3 will be copied to the local storage to speed up future accesses.</source>
          <target state="translated">S3 스토리지 엔진은 전체 &lt;a href=&quot;../table-discovery/index&quot;&gt;MariaDB 감지를&lt;/a&gt; 지원합니다 . 즉, S3 스토리지 엔진을 활성화하고 올바르게 구성한 경우 &lt;a href=&quot;../show-tables/index&quot;&gt;SHOW TABLES&lt;/a&gt; , &lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt; 또는 액세스하려는 다른 작업 으로 S3에 저장된 테이블이 자동으로 검색됩니다 . SELECT의 경우 S3의 .frm 파일이 로컬 저장소로 복사되어 향후 액세스 속도를 높입니다.</target>
        </trans-unit>
        <trans-unit id="16d0969e072dd763b12a0a1de9266b16664d9186" translate="yes" xml:space="preserve">
          <source>The SD and CD variables are the directories of the CONNECT source files and the one containing the libcpprest.so lib. They can be edited to match those on your machine OD is the directory that was made to contain the object files.</source>
          <target state="translated">SD 및 CD 변수는 CONNECT 소스 파일의 디렉토리와 libcpprest.so lib를 포함하는 디렉토리입니다. 머신의 OD와 일치하도록 편집 할 수 있습니다. OD는 오브젝트 파일을 포함하도록 작성된 디렉토리입니다.</target>
        </trans-unit>
        <trans-unit id="35f20ea67756fb3edf9a0a84b383ef08b42c2f97" translate="yes" xml:space="preserve">
          <source>The SELECT expressions will need &quot;a.&quot; prefixing the column names.</source>
          <target state="translated">SELECT 표현식에는 &quot;a&quot;가 필요합니다. 열 이름 앞에 붙습니다.</target>
        </trans-unit>
        <trans-unit id="08178b6d5bd3a836aa7206a7907a5d193a5fd327" translate="yes" xml:space="preserve">
          <source>The SELECT query returns:</source>
          <target state="translated">SELECT 쿼리는 다음을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="18d645ba2831bf9496aba89e3c9c2d0a52ce6381" translate="yes" xml:space="preserve">
          <source>The SELECT statement cannot contain a subquery in the FROM clause.</source>
          <target state="translated">SELECT 문은 FROM 절에 서브 쿼리를 포함 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c584ffe54316a90d5ddfabe529ef66dcbb4c0ed6" translate="yes" xml:space="preserve">
          <source>The SELECT statement cannot refer to prepared statement parameters.</source>
          <target state="translated">SELECT 문은 준비된 명령문 매개 변수를 참조 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="20c1b3c109f9c1bc0d3f0394d9c769919ab5c882" translate="yes" xml:space="preserve">
          <source>The SELECT statement cannot refer to system or user variables.</source>
          <target state="translated">SELECT 문은 시스템 또는 사용자 변수를 참조 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="cb49c4856d622c76854e3958c9eaa66095af882f" translate="yes" xml:space="preserve">
          <source>The SELECT statement is used to query the database and display table data. You can add many clauses to filter the data.</source>
          <target state="translated">SELECT 문은 데이터베이스를 조회하고 테이블 데이터를 표시하는 데 사용됩니다. 많은 절을 추가하여 데이터를 필터링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af6458a332faef4cc43292d316d0dc229462939a" translate="yes" xml:space="preserve">
          <source>The SELECT would examine more than MAX_JOIN_SIZE rows; check your WHERE and use SET SQL_BIG_SELECTS=1 or SET MAX_JOIN_SIZE=# if the SELECT is okay</source>
          <target state="translated">SELECT는 MAX_JOIN_SIZE보다 많은 행을 검사합니다. WHERE를 확인하고 SELECT가 올 바르면 SET SQL_BIG_SELECTS = 1 또는 SET MAX_JOIN_SIZE = #을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6a80a409298731d738439453221b612cb18ab44c" translate="yes" xml:space="preserve">
          <source>The SELECTs get messy -- multiple JOINs</source>
          <target state="translated">SELECT가 지저분해진다-여러 개의 JOIN</target>
        </trans-unit>
        <trans-unit id="6f47d344611e7dbe542ff898ac7e964c8e560b4f" translate="yes" xml:space="preserve">
          <source>The SET commands</source>
          <target state="translated">SET 명령</target>
        </trans-unit>
        <trans-unit id="3cd1779fa67ec77dc97fbd639b0e07fa8f3b014e" translate="yes" xml:space="preserve">
          <source>The SHORT data type contains signed &lt;a href=&quot;../smallint/index&quot;&gt;integer numeric 2-byte&lt;/a&gt; values (the &lt;em&gt;short integer&lt;/em&gt; of the C language) ranging from &lt;code&gt;&amp;ndash;32,768&lt;/code&gt; to &lt;code&gt;32,767&lt;/code&gt; for signed type and &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;65,535&lt;/code&gt; for unsigned type.</source>
          <target state="translated">쇼트 데이터 타입 서명 포함 &lt;a href=&quot;../smallint/index&quot;&gt;숫자 2 바이트 정수&lt;/a&gt; 값합니다 ( &lt;em&gt;짧은 정수&lt;/em&gt; 이르기까지 C 언어) &lt;code&gt;&amp;ndash;32,768&lt;/code&gt; 에 &lt;code&gt;32,767&lt;/code&gt; 서명 유형과 &lt;code&gt;0&lt;/code&gt; 으로 &lt;code&gt;65,535&lt;/code&gt; 의 부호없는 타입.</target>
        </trans-unit>
        <trans-unit id="8bdafcf4073d0f7f78e6109dc4c5370bba3a115e" translate="yes" xml:space="preserve">
          <source>The SP cache</source>
          <target state="translated">SP 캐시</target>
        </trans-unit>
        <trans-unit id="4d9744f6b605814ed79c99ad35a2f2b863253e86" translate="yes" xml:space="preserve">
          <source>The SQL button can be used to generate DDL based on the defined mapping and to execute it.</source>
          <target state="translated">SQL 버튼을 사용하여 정의 된 매핑을 기반으로 DDL을 생성하고 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2a6c562439750f4d6d67c73d9d854b7586b617a" translate="yes" xml:space="preserve">
          <source>The SQL commands INSERT, UPDATE and DELETE are fully supported for JSON tables. For INSERT and UPDATE, if the target values are simple values, there are no problems.</source>
          <target state="translated">SQL 명령 INSERT, UPDATE 및 DELETE는 JSON 테이블에서 완전히 지원됩니다. INSERT 및 UPDATE의 경우 대상 값이 단순 값이면 문제가 없습니다.</target>
        </trans-unit>
        <trans-unit id="8fbd98a0ddad11d5b6df6e2c8290707397231a65" translate="yes" xml:space="preserve">
          <source>The SQL data type</source>
          <target state="translated">SQL 데이터 유형</target>
        </trans-unit>
        <trans-unit id="1654fd02429936b62327fedd6a2d5cb5a7ee15af" translate="yes" xml:space="preserve">
          <source>The SQL defining the event.</source>
          <target state="translated">이벤트를 정의하는 SQL</target>
        </trans-unit>
        <trans-unit id="edc851b254e8c570026655b785c6ae7ae5b35139" translate="yes" xml:space="preserve">
          <source>The SQL statement, or &lt;code&gt;NULL&lt;/code&gt; if the command is not associated with an SQL statement.</source>
          <target state="translated">SQL 문, 또는 &lt;code&gt;NULL&lt;/code&gt; 이 명령은 SQL 문으로 연결되어 있지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="77f9f3ced97b42aa85a678d220a85ee7a80bae91" translate="yes" xml:space="preserve">
          <source>The SQL type name</source>
          <target state="translated">SQL 유형 이름</target>
        </trans-unit>
        <trans-unit id="da5487a97f9c1e99c02595f62c141d2597a64c94" translate="yes" xml:space="preserve">
          <source>The SQLDataSources function returns a result set having the following columns:</source>
          <target state="translated">SQLDataSources 함수는 다음 열이있는 결과 세트를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="90c436da8fbf6be072e56ba9f64c26999af12400" translate="yes" xml:space="preserve">
          <source>The SQLDrivers function returns a result set having the following columns:</source>
          <target state="translated">SQLDrivers 함수는 다음 열이있는 결과 세트를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="dfaf3d907eb710749bd19f334b78c035909abdd0" translate="yes" xml:space="preserve">
          <source>The SQLTables function returns a result set having the following columns:</source>
          <target state="translated">SQLTables 함수는 다음 열이있는 결과 세트를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="59398a234b4d027cb27fda69e1661a6d4b7c4a92" translate="yes" xml:space="preserve">
          <source>The ST_BOUNDARY function was introduced in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1012-release-notes/&quot;&gt;MariaDB 10.1.2&lt;/a&gt;</source>
          <target state="translated">ST_BOUNDARY 함수는 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1012-release-notes/&quot;&gt;MariaDB 10.1.2&lt;/a&gt; 에서 도입되었습니다</target>
        </trans-unit>
        <trans-unit id="c571015129e85da8bdc08459823fe1fbd525b36c" translate="yes" xml:space="preserve">
          <source>The ST_IsRing function was introduced in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1012-release-notes/&quot;&gt;MariaDB 10.1.2&lt;/a&gt;</source>
          <target state="translated">ST_IsRing 함수는 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1012-release-notes/&quot;&gt;MariaDB 10.1.2&lt;/a&gt; 에서 도입되었습니다</target>
        </trans-unit>
        <trans-unit id="27ce5d57382e91b7bee48c8a3e9b28ca98d50785" translate="yes" xml:space="preserve">
          <source>The ST_RELATE() function was introduced in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1012-release-notes/&quot;&gt;MariaDB 10.1.2&lt;/a&gt;</source>
          <target state="translated">ST_RELATE () 함수는 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1012-release-notes/&quot;&gt;MariaDB 10.1.2&lt;/a&gt; 에서 도입되었습니다</target>
        </trans-unit>
        <trans-unit id="336978eb74cd607c19974dae8d02952655088b67" translate="yes" xml:space="preserve">
          <source>The Scala/Spark part including ColumnStoreExporter</source>
          <target state="translated">ColumnStoreExporter를 포함한 Scala / Spark 부분</target>
        </trans-unit>
        <trans-unit id="14f4955b0dec34242d74638dca4d5bfb49ef673c" translate="yes" xml:space="preserve">
          <source>The Sphinx package and daemon are named &lt;code&gt;sphinxsearch&lt;/code&gt;.</source>
          <target state="translated">Sphinx 패키지 및 데몬의 이름은 &lt;code&gt;sphinxsearch&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f99bfea74c039bc2590f00f7ac67f9a4eee34a2b" translate="yes" xml:space="preserve">
          <source>The Sphinx storage engine (SphinxSE) is a storage engine that talks to searchd (the Sphinx daemon) to enable text searching. Sphinx and SphinxSE is used as a faster and more customizable alternative to MariaDB's &lt;a href=&quot;../full-text-indexes/index&quot;&gt;built-in full-text search&lt;/a&gt;.</source>
          <target state="translated">스핑크스 스토리지 엔진 (SphinxSE)은 텍스트 검색을 가능하게하기 위해 검색 (스핑크스 데몬)과 통신하는 스토리지 엔진입니다. Sphinx 및 SphinxSE는 MariaDB의 &lt;a href=&quot;../full-text-indexes/index&quot;&gt;내장 전체 텍스트 검색에&lt;/a&gt; 대한보다 빠르고 사용자 정의 가능한 대안으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="85378073605d9ad9c28d6a6a7f96b4c6a2b7c6ba" translate="yes" xml:space="preserve">
          <source>The Spider documentation on the MariaDB Knowledge Base is currently incomplete. See the Spider website for more: &lt;a href=&quot;http://spiderformysql.com/&quot;&gt;http://spiderformysql.com/&lt;/a&gt;, as well as the &lt;a href=&quot;http://bazaar.launchpad.net/~kentokushiba/spiderformysql/spider-1.0-doc/files&quot;&gt;spider-1.0-doc&lt;/a&gt; and &lt;a href=&quot;http://bazaar.launchpad.net/~kentokushiba/spiderformysql/spider-2.0-doc/files&quot;&gt;spider-2.0-doc&lt;/a&gt; repositories.</source>
          <target state="translated">MariaDB 기술 자료의 Spider 설명서가 현재 불완전합니다. 자세한 내용은 Spider 웹 사이트 ( &lt;a href=&quot;http://spiderformysql.com/&quot;&gt;http://spiderformysql.com/&lt;/a&gt; )와 &lt;a href=&quot;http://bazaar.launchpad.net/~kentokushiba/spiderformysql/spider-1.0-doc/files&quot;&gt;spider-1.0-doc&lt;/a&gt; 및 &lt;a href=&quot;http://bazaar.launchpad.net/~kentokushiba/spiderformysql/spider-2.0-doc/files&quot;&gt;spider-2.0-doc&lt;/a&gt; 리포지토리를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="736c5ef9b04d27dbc8e04d73ee948ea45ee680ed" translate="yes" xml:space="preserve">
          <source>The Spider documentation on the MariaDB Knowledge Base is currently incomplete. See the Spider website for more: &lt;a href=&quot;http://spiderformysql.com/&quot;&gt;http://spiderformysql.com/&lt;/a&gt;, as well as the &lt;a href=&quot;https://bazaar.launchpad.net/~kentokushiba/spiderformysql/spider-1.0-doc/files&quot;&gt;spider-1.0-doc&lt;/a&gt; and &lt;a href=&quot;https://bazaar.launchpad.net/~kentokushiba/spiderformysql/spider-2.0-doc/files&quot;&gt;spider-2.0-doc&lt;/a&gt; repositories.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebc58fccb94b9eb3ebd1ea145bcccdca4bff115a" translate="yes" xml:space="preserve">
          <source>The Spider storage engine is a &lt;a href=&quot;../storage-engines/index&quot;&gt;storage engine&lt;/a&gt; with built-in sharding features. It supports partitioning and &lt;a href=&quot;../xa-transactions/index&quot;&gt;xa transactions&lt;/a&gt;, and allows tables of different MariaDB instances to be handled as if they were on the same instance. It refers to one possible implementation of ISO/IEC 9075-9:2008 SQL/MED.</source>
          <target state="translated">Spider 스토리지 엔진은 샤딩 기능이 내장 된 &lt;a href=&quot;../storage-engines/index&quot;&gt;스토리지 엔진&lt;/a&gt; 입니다. 파티셔닝 및 &lt;a href=&quot;../xa-transactions/index&quot;&gt;xa 트랜잭션을&lt;/a&gt; 지원하며 서로 다른 MariaDB 인스턴스의 테이블을 마치 동일한 인스턴스에있는 것처럼 처리 할 수 ​​있습니다. ISO / IEC 9075-9 : 2008 SQL / MED의 가능한 구현을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4bda787cfd01ead3ed2f03a417d86a2b7c431a49" translate="yes" xml:space="preserve">
          <source>The Spider storage engine supports partitioning and &lt;a href=&quot;../xa-transactions/index&quot;&gt;xa transactions&lt;/a&gt;, and allows tables of different MariaDB instances to be handled as if they were on the same instance.</source>
          <target state="translated">Spider 스토리지 엔진은 파티셔닝 및 &lt;a href=&quot;../xa-transactions/index&quot;&gt;xa 트랜잭션을&lt;/a&gt; 지원하며 다른 MariaDB 인스턴스의 테이블이 마치 동일한 인스턴스에있는 것처럼 처리 될 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="1d6838f2b3913faad2c135eba4673021f1e8d638" translate="yes" xml:space="preserve">
          <source>The Spider storage engine supports partitioning and XA transactions, and allows tables of different MariaDB instances to be handled as if they were on the same instance.</source>
          <target state="translated">Spider 스토리지 엔진은 파티셔닝 및 XA 트랜잭션을 지원하며 다른 MariaDB 인스턴스의 테이블이 마치 동일한 인스턴스에있는 것처럼 처리 될 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="e4409dba48789b58e9323ae98da006ff7a0c4429" translate="yes" xml:space="preserve">
          <source>The Spider storage engine was first released in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1004-release-notes/&quot;&gt;MariaDB 10.0.4&lt;/a&gt;.</source>
          <target state="translated">Spider 스토리지 엔진은 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1004-release-notes/&quot;&gt;MariaDB 10.0.4&lt;/a&gt; 에서 처음 릴리스되었습니다 .</target>
        </trans-unit>
        <trans-unit id="7707296c56d927527745a871be6d0a553ea18759" translate="yes" xml:space="preserve">
          <source>The Spider storage engine was introduced in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1004-release-notes/&quot;&gt;MariaDB 10.0.4&lt;/a&gt;</source>
          <target state="translated">스파이더 스토리지 엔진은 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1004-release-notes/&quot;&gt;MariaDB 10.0.4&lt;/a&gt; 에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="4039c2764938cff2eb1adfd504abd1593e282a75" translate="yes" xml:space="preserve">
          <source>The Spider storage engine was introduced in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1004-release-notes/&quot;&gt;MariaDB 10.0.4&lt;/a&gt; and updated to latest Spider version in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1034-release-notes/&quot;&gt;MariaDB 10.3.4&lt;/a&gt;</source>
          <target state="translated">Spider 스토리지 엔진은 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1004-release-notes/&quot;&gt;MariaDB 10.0.4&lt;/a&gt; 에서 도입 되었으며 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1034-release-notes/&quot;&gt;MariaDB 10.3.4의&lt;/a&gt; 최신 Spider 버전으로 업데이트되었습니다.</target>
        </trans-unit>
        <trans-unit id="5e57759f90943da38fe4f296ece302143820e3e5" translate="yes" xml:space="preserve">
          <source>The Subdir option</source>
          <target state="translated">하위 디렉토리 옵션</target>
        </trans-unit>
        <trans-unit id="f7774162b0a8ad810d1d60aed8cfc92e477c364d" translate="yes" xml:space="preserve">
          <source>The System can go into DBRM Read-Only Mode due to these conditions, a failure while doing a DDL/DML command, network problem between servers where the DBRM could get distributed to the other servers from Performance Module 1, and some failover scenarios. It will be shown by the follow alarm. This alarm along with all critical alarms will be displayed when user logs into the Columnstore Admin Console 'mcsadmin'.</source>
          <target state="translated">이러한 조건, DDL / DML 명령 수행 중 장애, DBRM이 Performance Module 1에서 다른 서버로 분배 될 수있는 서버 간의 네트워크 문제 및 일부 장애 조치 시나리오로 인해 시스템이 DBRM 읽기 전용 모드로 전환 될 수 있습니다. 팔로우 알람으로 표시됩니다. 사용자가 Columnstore 관리 콘솔 'mcsadmin'에 로그인하면 모든 중요 경보와 함께이 경보가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="6a6c21f8f4598f7e20db5087048ac7c8bef1a079" translate="yes" xml:space="preserve">
          <source>The TABID special column can be used to see from which table the rows come from and to restrict the access to only some of the sub-tables.</source>
          <target state="translated">TABID 특수 열을 사용하여 행이 어느 테이블에서 왔는지 확인하고 일부 서브 테이블에만 액세스를 제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f6a35583576be3dd3b46c2f0492ccdfafb785d5" translate="yes" xml:space="preserve">
          <source>The TCP/IP port number to use for connecting to the server. The default is 3306.</source>
          <target state="translated">서버 연결에 사용할 TCP / IP 포트 번호입니다. 기본값은 3306입니다.</target>
        </trans-unit>
        <trans-unit id="db23edee2f869d6b1f01bdd43c82c23a3a3d4249" translate="yes" xml:space="preserve">
          <source>The TCP/IP port number to use for the connection.</source>
          <target state="translated">연결에 사용할 TCP / IP 포트 번호입니다.</target>
        </trans-unit>
        <trans-unit id="22b0635b58bf63db2d2a461816c54df84ee4a77c" translate="yes" xml:space="preserve">
          <source>The TCP/IP port number to use when connecting to the local server.</source>
          <target state="translated">로컬 서버에 연결할 때 사용할 TCP / IP 포트 번호입니다.</target>
        </trans-unit>
        <trans-unit id="7421b6fb7a9b2875261721064615e9e5c9894136" translate="yes" xml:space="preserve">
          <source>The TINY data type contains &lt;a href=&quot;../tinyint/index&quot;&gt;integer numeric 1-byte&lt;/a&gt; values (the &lt;em&gt;char&lt;/em&gt; of the C language) ranging from &lt;code&gt;&amp;ndash;128&lt;/code&gt; to &lt;code&gt;127&lt;/code&gt; for signed type and &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;255&lt;/code&gt; for unsigned type. For some table types, TYPE_TINY is used to represent Boolean values (0 is false, anything else is true).</source>
          <target state="translated">작은 데이터 형식을 포함 &lt;a href=&quot;../tinyint/index&quot;&gt;숫자 1 바이트 정수&lt;/a&gt; 값합니다 ( &lt;em&gt;숯&lt;/em&gt; 이르기까지 C 언어) &lt;code&gt;&amp;ndash;128&lt;/code&gt; 로 &lt;code&gt;127&lt;/code&gt; 에 서명 유형과 &lt;code&gt;0&lt;/code&gt; 으로 &lt;code&gt;255&lt;/code&gt; 부호 타입. 일부 테이블 유형의 경우 TYPE_TINY는 부울 값을 나타내는 데 사용됩니다 (0은 false, 다른 것은 true).</target>
        </trans-unit>
        <trans-unit id="3a428af5c7c02376a344f3d2fe8e84fa32f47d0d" translate="yes" xml:space="preserve">
          <source>The TLS options are used for providing information about &lt;a href=&quot;../data-in-transit-encryption/index&quot;&gt;TLS&lt;/a&gt;. The options can be set even on slaves that are compiled without TLS support. The TLS options are saved to either the default &lt;code&gt;master.info&lt;/code&gt; file or the file that is configured by the &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-master-info-file&quot;&gt;master_info_file&lt;/a&gt;&lt;/code&gt; option, but these TLS options are ignored unless the slave supports TLS.</source>
          <target state="translated">TLS 옵션에 대한 정보를 제공하기 위해 사용하는 &lt;a href=&quot;../data-in-transit-encryption/index&quot;&gt;TLS&lt;/a&gt; . TLS 지원없이 컴파일 된 슬레이브에서도 옵션을 설정할 수 있습니다. TLS 옵션은 기본 &lt;code&gt;master.info&lt;/code&gt; 파일 또는 &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-master-info-file&quot;&gt;master_info_file&lt;/a&gt;&lt;/code&gt; 옵션으로 구성된 파일에 저장 되지만 슬레이브가 TLS를 지원하지 않으면 이러한 TLS 옵션은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="5b05c0bc582f8a5db6c8db64251650eff22548bf" translate="yes" xml:space="preserve">
          <source>The TLS protocol versions that are supported depend on the underlying TLS library used by the specific MariaDB binary.</source>
          <target state="translated">지원되는 TLS 프로토콜 버전은 특정 MariaDB 바이너리에서 사용하는 기본 TLS 라이브러리에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="52535a875897ede58f380b43589653b56f908587" translate="yes" xml:space="preserve">
          <source>The TO_BASE64() function was introduced in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1005-release-notes/&quot;&gt;MariaDB 10.0.5&lt;/a&gt;.</source>
          <target state="translated">TO_BASE64 () 함수는 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1005-release-notes/&quot;&gt;MariaDB 10.0.5&lt;/a&gt; 에서 도입되었습니다 .</target>
        </trans-unit>
        <trans-unit id="09e09c3a4f0d12428747c8595c3e056dcb622e2f" translate="yes" xml:space="preserve">
          <source>The TRUNCATE function truncates a number to a specified number of decimal places.</source>
          <target state="translated">TRUNCATE 함수는 숫자를 지정된 소수 자릿수로 자릅니다.</target>
        </trans-unit>
        <trans-unit id="d6ead07a4a35beb6ebd5d86360e8dab3438ad35d" translate="yes" xml:space="preserve">
          <source>The TokuDB storage engine is for use in high-performance and write-intensive environments, offering increased compression and better performance.</source>
          <target state="translated">TokuDB 스토리지 엔진은 고성능 및 쓰기 집약적 환경에서 사용되며 압축률이 향상되고 성능이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="3cf968a49fe46a081ca3e3599585b2559e71921e" translate="yes" xml:space="preserve">
          <source>The UDF class should be defined in file &lt;strong&gt;udfsdk.h&lt;/strong&gt; and implemented in file &lt;strong&gt;udfsdk.cpp&lt;/strong&gt;. It is easiest to adapt the example classes for new instance but each class must implement the &lt;em&gt;funcexp::Func&lt;/em&gt; C++ class definition:</source>
          <target state="translated">UDF 본 클래스는 파일에 정의되어야한다 &lt;strong&gt;udfsdk.h&lt;/strong&gt; 및 파일에 구현 &lt;strong&gt;udfsdk.cpp&lt;/strong&gt; . 새 인스턴스에 예제 클래스를 적용하는 것이 가장 쉽지만 각 클래스는 &lt;em&gt;funcexp :: Func&lt;/em&gt; C ++ 클래스 정의를 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="52ffde3aca966cf5bb5b9b88b48c4221a303c6d4" translate="yes" xml:space="preserve">
          <source>The UDF function &lt;a href=&quot;../spider_copy_tables/index&quot;&gt;spider_copy_tables&lt;/a&gt; is available for copying table data from the source link ID to the destination link ID list without stopping your service for copying</source>
          <target state="translated">UDF 기능 &lt;a href=&quot;../spider_copy_tables/index&quot;&gt;spider_copy_tables&lt;/a&gt; 는 복사 서비스를 중지하지 않고 소스 링크 ID에서 대상 링크 ID 목록으로 테이블 데이터를 복사하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d4bd33cb83706b8e9c9b6647bfa7b08408af64b" translate="yes" xml:space="preserve">
          <source>The UDF is packed together with the storage engine, in the same binary named ha_sphinx.so. Register the UDF using the following statement:</source>
          <target state="translated">UDF는 ha_sphinx.so라는 동일한 2 진 파일로 스토리지 엔진과 함께 제공됩니다. 다음 명령문을 사용하여 UDF를 등록하십시오.</target>
        </trans-unit>
        <trans-unit id="cce820193e0f2c46fefea2a6c39d18954ab74060" translate="yes" xml:space="preserve">
          <source>The UI would recognize those, then generate a SELECT with something like</source>
          <target state="translated">UI는이를 인식하고 다음과 같은 방법으로 SELECT를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="56cdca7a01896b40b67b3544e4a43ee7b2341399" translate="yes" xml:space="preserve">
          <source>The UM issues up to &lt;em&gt;MaxOutstandingRequests&lt;/em&gt; number of batch primitive steps.</source>
          <target state="translated">UM은 최대 &lt;em&gt;MaxOutstandingRequests&lt;/em&gt; 수의 일괄 처리 기본 단계 를 발행 합니다.</target>
        </trans-unit>
        <trans-unit id="8af5b06d77118c53532619a10ee1eb39cdb14e33" translate="yes" xml:space="preserve">
          <source>The UM will issue new requests as prior requests complete maintaining the maximum number of outstanding requests.</source>
          <target state="translated">UM은 이전 요청이 완료된 최대 요청 수를 유지하면서 새로운 요청을 발행합니다.</target>
        </trans-unit>
        <trans-unit id="63b60118ca6f3cd7043ae6b3ef7609abf4a338b2" translate="yes" xml:space="preserve">
          <source>The UMs most likely require at least one public interface to access the MySQL server front end from the site LAN. This interface can be a separate physical or logical connection from the PM interconnect.</source>
          <target state="translated">UM에는 사이트 LAN에서 MySQL 서버 프런트 엔드에 액세스하기 위해 적어도 하나의 공용 인터페이스가 필요합니다. 이 인터페이스는 PM 상호 연결과 별도의 물리적 또는 논리적 연결 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a99d12851898a3bb7fa33e56db263ffc8d51bbde" translate="yes" xml:space="preserve">
          <source>The UNION can have global &lt;a href=&quot;../order-by/index&quot;&gt;ORDER BY&lt;/a&gt; and &lt;a href=&quot;../limit/index&quot;&gt;LIMIT&lt;/a&gt; clauses, which affect the whole resultset. If the columns retrieved by individual SELECT statements have an alias (AS), the ORDER BY must use that alias, not the real column names.</source>
          <target state="translated">UNION에는 전역 &lt;a href=&quot;../order-by/index&quot;&gt;ORDER BY&lt;/a&gt; 및 &lt;a href=&quot;../limit/index&quot;&gt;LIMIT&lt;/a&gt; 절이 있을 수 있으며 전체 결과 집합에 영향을줍니다. 개별 SELECT 문으로 검색된 열에 별명 (AS)이있는 경우 ORDER BY는 실제 열 이름이 아닌 해당 별명을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="b9ac62122af4e2fde3ebe35522959ede7668aaa8" translate="yes" xml:space="preserve">
          <source>The UPDATE statement changes data stored in rows.</source>
          <target state="translated">UPDATE 문은 행에 저장된 데이터를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="4b65eaf8e1678334975d1b10fa0786ffd7f3ef83" translate="yes" xml:space="preserve">
          <source>The UPDATE statement changes data stored in rows. Syntax Single-table syntax: UPDATE tabl</source>
          <target state="translated">UPDATE 문은 행에 저장된 데이터를 변경합니다. 구문 단일 테이블 구문 : UPDATE tabl</target>
        </trans-unit>
        <trans-unit id="992ad3332072acc0c1da960c20e0326f8a3cbb6a" translate="yes" xml:space="preserve">
          <source>The URI of a REST request.. From &lt;a href=&quot;../connect/index&quot;&gt;Connect 1.06.0010&lt;/a&gt;.</source>
          <target state="translated">REST 요청의 URI입니다. From &lt;a href=&quot;../connect/index&quot;&gt;Connect 1.06.0010&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="27cb1bd5654ed304fc02aa4bb960620e72df6d41" translate="yes" xml:space="preserve">
          <source>The URL varies depending on the connected DBMS. Refer to the documentation of the specific JDBC driver for a description of the syntax to use. User and password can also be specified in the option list.</source>
          <target state="translated">URL은 연결된 DBMS에 따라 다릅니다. 사용할 구문에 대한 설명은 특정 JDBC 드라이버의 문서를 참조하십시오. 옵션 목록에서 사용자 및 비밀번호를 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f06a9e0a972c8ad48b39092acdaebf4c87ad619" translate="yes" xml:space="preserve">
          <source>The UUID_SHORT() return value is constructed this way:</source>
          <target state="translated">UUID_SHORT () 반환 값은 다음과 같이 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="7b958a580b175d89e6f15f570709235df6bc7431" translate="yes" xml:space="preserve">
          <source>The Unix socket file that the server should use when listening for local connections.</source>
          <target state="translated">로컬 연결을 청취 할 때 서버가 사용해야하는 Unix 소켓 파일.</target>
        </trans-unit>
        <trans-unit id="ebd3deb9cdbdcf319bcbb126baa4bd8d6d082603" translate="yes" xml:space="preserve">
          <source>The Unix socket file to use for connections to localhost.</source>
          <target state="translated">localhost에 연결하는 데 사용할 Unix 소켓 파일</target>
        </trans-unit>
        <trans-unit id="68730f7a9a8291f926cc8bbaa31caaef6577bfef" translate="yes" xml:space="preserve">
          <source>The Unix user &lt;code&gt;foo&lt;/code&gt; should be mapped to the MariaDB user &lt;code&gt;bar&lt;/code&gt;. (&lt;code&gt;foo: bar&lt;/code&gt;)</source>
          <target state="translated">유닉스 사용자 &lt;code&gt;foo&lt;/code&gt; 는 MariaDB 사용자 &lt;code&gt;bar&lt;/code&gt; 매핑되어야합니다 . ( &lt;code&gt;foo: bar&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="9cb971bd6c5b46e7fbd085df13bc1712e02a9610" translate="yes" xml:space="preserve">
          <source>The Update Rule; one of &lt;code&gt;CASCADE&lt;/code&gt;, &lt;code&gt;SET NULL&lt;/code&gt;, &lt;code&gt;SET DEFAULT&lt;/code&gt;, &lt;code&gt;RESTRICT&lt;/code&gt;, &lt;code&gt;NO ACTION&lt;/code&gt;.</source>
          <target state="translated">업데이트 규칙; &lt;code&gt;CASCADE&lt;/code&gt; , &lt;code&gt;SET NULL&lt;/code&gt; , &lt;code&gt;SET DEFAULT&lt;/code&gt; , &lt;code&gt;RESTRICT&lt;/code&gt; , &lt;code&gt;NO ACTION&lt;/code&gt; 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="1d5d02dcec34ee44a7db85f7c358a0f30db36d17" translate="yes" xml:space="preserve">
          <source>The User Module / ExeMgr implements any window function calculations, as well as any necessary sorting on the result-set. It then returns the result-set to the server.</source>
          <target state="translated">사용자 모듈 / ExeMgr은 모든 윈도우 함수 계산과 결과 집합에 필요한 정렬을 구현합니다. 그런 다음 결과 집합을 서버로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="61bc3b7d1a298d8835c0cf5294f22f269b885177" translate="yes" xml:space="preserve">
          <source>The User Module contains several processes, including &lt;code&gt;&lt;a href=&quot;#mariadb-server&quot;&gt;mysqld&lt;/a&gt;&lt;/code&gt;, &lt;a href=&quot;#execution-manager&quot;&gt;ExeMgr&lt;/a&gt;, and &lt;a href=&quot;#distribution-managers&quot;&gt;distribution managers&lt;/a&gt;.</source>
          <target state="translated">사용자 모듈에는 &lt;code&gt;&lt;a href=&quot;#mariadb-server&quot;&gt;mysqld&lt;/a&gt;&lt;/code&gt; , &lt;a href=&quot;#execution-manager&quot;&gt;ExeMgr&lt;/a&gt; 및 &lt;a href=&quot;#distribution-managers&quot;&gt;배포 관리자를&lt;/a&gt; 포함한 여러 프로세스가 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2a24324acf368196cace8c5709d596bf651a9267" translate="yes" xml:space="preserve">
          <source>The User Module converts the MariaDB execution plan and optimizes the given objects into a ColumnStore execution plan. It then determines the steps needed to run the query and the order in which they need to be run.</source>
          <target state="translated">사용자 모듈은 MariaDB 실행 계획을 변환하고 지정된 오브젝트를 ColumnStore 실행 계획으로 최적화합니다. 그런 다음 쿼리를 실행하는 데 필요한 단계와 실행 순서를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="e40a064a084eecb79f5cfc5a145eaa846d1205e3" translate="yes" xml:space="preserve">
          <source>The User Module manages and controls the operation of end user queries. It maintains the state of each query, issues requests to one or more Performance Modules to process the query, and resolves the query by aggregating the various result-sets from all participating Performance Modules into the one returned to the end user.</source>
          <target state="translated">사용자 모듈은 최종 사용자 쿼리 작업을 관리하고 제어합니다. 각 쿼리의 상태를 유지하고 쿼리를 처리하기 위해 하나 이상의 성능 모듈에 요청을 발행하고 모든 참여 성능 모듈의 다양한 결과 집합을 최종 사용자에게 반환 된 결과 집합으로 집계하여 쿼리를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="96d5c24220b00f20cc3fbf9c2b2f9b0d0d076127" translate="yes" xml:space="preserve">
          <source>The User Module manages and controls the operation of end-user queries</source>
          <target state="translated">사용자 모듈은 최종 사용자 쿼리 작업을 관리하고 제어합니다</target>
        </trans-unit>
        <trans-unit id="6135cde6963fd33dc56dee849b266731b7754616" translate="yes" xml:space="preserve">
          <source>The User Module performs the final result-set aggregation and composes the result-set for the query.</source>
          <target state="translated">사용자 모듈은 최종 결과 집합 집계를 수행하고 쿼리에 대한 결과 집합을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="7ebeb1a91257decfb1fa6f089a4f8dbf449b4e22" translate="yes" xml:space="preserve">
          <source>The User Module runs &lt;code&gt;mysqld&lt;/code&gt;. This is the MariaDB Server running with ColumnStore. It performs the same tasks as a normal MariaDB Server deployment: validating connections, parsing SQL statements, SQL plan generation, and final result-set distribution.</source>
          <target state="translated">사용자 모듈은 &lt;code&gt;mysqld&lt;/code&gt; 를 실행 합니다. 이것이 ColumnStore로 실행되는 MariaDB 서버입니다. 연결 확인, SQL 구문 분석, SQL 계획 생성 및 최종 결과 집합 배포와 같은 일반 MariaDB 서버 배포와 동일한 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="eba55cfcc67515035741597284b4b7caf752a112" translate="yes" xml:space="preserve">
          <source>The User Module then consults the Extent Map to determine which Performance Modules to consult for the data it needs, it then performs Extent Elimination, eliminating any Performance Modules from the list that only contain data outside the range of what the query requires.</source>
          <target state="translated">그런 다음 사용자 모듈은 Extent Map을 참조하여 필요한 데이터에 대해 어떤 성능 모듈을 참조할지 결정한 다음 Extent Elimination을 수행하여 쿼리에서 요구하는 범위 밖의 데이터 만 포함하는 목록에서 성능 모듈을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="2c7e4149933888c6a3faa3e533723ac8464e0e11" translate="yes" xml:space="preserve">
          <source>The User Module then sends commands to one or more Performance Modules to perform block I/O operations.</source>
          <target state="translated">그런 다음 사용자 모듈은 하나 이상의 성능 모듈에 명령을 보내 블록 I / O 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="94778ecd74d4122f2a4600d7f18d0134257e2b49" translate="yes" xml:space="preserve">
          <source>The User Statistics feature was first released in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-520-release-notes/&quot;&gt;MariaDB 5.2.0&lt;/a&gt;. The feature was moved to the &lt;code&gt;userstat&lt;/code&gt; plugin in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1011-release-notes/&quot;&gt;MariaDB 10.1.1&lt;/a&gt;.</source>
          <target state="translated">사용자 통계 기능은 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-520-release-notes/&quot;&gt;MariaDB 5.2.0&lt;/a&gt; 에서 처음 릴리스되었습니다 . 이 기능은 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1011-release-notes/&quot;&gt;MariaDB 10.1.1&lt;/a&gt; 의 &lt;code&gt;userstat&lt;/code&gt; 플러그인 으로 이동되었습니다 .</target>
        </trans-unit>
        <trans-unit id="abd58ecbc1c8e3f09e2f6cd20a5d0b588e902cfd" translate="yes" xml:space="preserve">
          <source>The VARBINARY type is similar to the &lt;a href=&quot;../sql_language-data_types-varchar/index&quot;&gt;VARCHAR&lt;/a&gt; type, but stores binary byte strings rather than non-binary character strings. &lt;code&gt;M&lt;/code&gt; represents the maximum column length in bytes.</source>
          <target state="translated">VARBINARY 유형은 &lt;a href=&quot;../sql_language-data_types-varchar/index&quot;&gt;VARCHAR&lt;/a&gt; 유형 과 유사 하지만 이진이 아닌 문자열 대신 이진 바이트 문자열을 저장합니다. &lt;code&gt;M&lt;/code&gt; 은 최대 열 길이 (바이트)를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3103ec4fdb85460b9d04e372764332456c344da9" translate="yes" xml:space="preserve">
          <source>The VIR virtual type for the CONNECT handler was introduced in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10015-release-notes/&quot;&gt;MariaDB 10.0.15&lt;/a&gt;.</source>
          <target state="translated">CONNECT 핸들러의 VIR 가상 유형은 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10015-release-notes/&quot;&gt;MariaDB 10.0.15&lt;/a&gt; 에서 도입되었습니다 .</target>
        </trans-unit>
        <trans-unit id="18753458b2a807dc738529d4d78dcd1306fcd0f5" translate="yes" xml:space="preserve">
          <source>The Version Buffer uses in-memory hash tables to supply memory access to in-flight transaction information. It starts at 4MB with the memory region growing from that amount to handle blocks that are being modified by a transaction. Each entry in the hash table is a 40-byte reference to the 8KB block being modified.</source>
          <target state="translated">버전 버퍼는 메모리 내 해시 테이블을 사용하여 기내 트랜잭션 정보에 대한 메모리 액세스를 제공합니다. 트랜잭션에 의해 수정되는 블록을 처리하기 위해 메모리 영역이 그 양에서 증가하면서 4MB에서 시작합니다. 해시 테이블의 각 항목은 수정중인 8KB 블록에 대한 40 바이트 참조입니다.</target>
        </trans-unit>
        <trans-unit id="811a5167648fc149535ba7ef17a0d8449f0286e3" translate="yes" xml:space="preserve">
          <source>The VersionBufferFileSize setting is updated in the ColumnStore.xml typically located under /usr/local/mariadb/columnstore/etc. This dictates the size of the version buffer file on disk which provides DML transactional consistency. The default value is '1GB' which reserves up to a 1 Gigabyte file size. Modify this on the PM1 node and restart the system if you require a larger value.</source>
          <target state="translated">VersionBufferFileSize 설정은 일반적으로 / usr / local / mariadb / columnstore / etc 아래에있는 ColumnStore.xml에서 업데이트됩니다. 이는 DML 트랜잭션 일관성을 제공하는 디스크의 버전 버퍼 파일 크기를 나타냅니다. 기본값은 '1GB'이며 최대 1 기가 바이트 파일 크기를 예약합니다. PM1 노드에서이를 수정하고 더 큰 값이 필요한 경우 시스템을 다시 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="5a6c5b7e187f27d438294ea799e4c9de2c12c957" translate="yes" xml:space="preserve">
          <source>The WEIGHT_STRING function was introduced in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1005-release-notes/&quot;&gt;MariaDB 10.0.5&lt;/a&gt;.</source>
          <target state="translated">WEIGHT_STRING 함수는 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1005-release-notes/&quot;&gt;MariaDB 10.0.5&lt;/a&gt; 에서 도입되었습니다 .</target>
        </trans-unit>
        <trans-unit id="b848b2404c62c25eef7d0e71ec8958889e7d738e" translate="yes" xml:space="preserve">
          <source>The WHERE clause and the &lt;a href=&quot;../order-by/index&quot;&gt;ORDER BY&lt;/a&gt; may even make it so that all 50,000 items have to be read, just to find the 10 items for page 1!</source>
          <target state="translated">WHERE 절과 &lt;a href=&quot;../order-by/index&quot;&gt;ORDER BY&lt;/a&gt; 는 1 페이지의 10 개 항목을 찾기 위해 50,000 개 항목을 모두 읽어야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8fa4a53856f3b535661e907cbb30c0325781acb7" translate="yes" xml:space="preserve">
          <source>The WHERE clause filters data retrieval based on criteria. Note that &lt;em&gt;column_alias&lt;/em&gt; cannot be used in the WHERE clause.The following statement returns rows in the region table where the region = &amp;lsquo;ASIA&amp;rsquo;:</source>
          <target state="translated">WHERE 절은 기준에 따라 데이터 검색을 필터링합니다. 참고 &lt;em&gt;column_alias는&lt;/em&gt; 어디 지역 = '아시아'지역 테이블에서 WHERE clause.The 다음 문 반환 행에서 사용할 수 없습니다 :</target>
        </trans-unit>
        <trans-unit id="0433c7a1d2b9fb4a47afba90d43d0e144354dd74" translate="yes" xml:space="preserve">
          <source>The WHERE clause limits which rows needed (whether indexed or not).</source>
          <target state="translated">WHERE 절은 필요한 행 (인덱싱 여부)을 제한합니다.</target>
        </trans-unit>
        <trans-unit id="7fedf90946149784c37e85a439c1ba5f70117f2b" translate="yes" xml:space="preserve">
          <source>The WITH CHECK OPTION clause can be given for an updatable view to prevent inserts or updates to rows except those for which the WHERE clause in the select_statement is true.</source>
          <target state="translated">select_statement의 WHERE 절이 true 인 행을 제외하고 행에 대한 삽입 또는 갱신을 방지하기 위해 갱신 가능 뷰에 WITH CHECK OPTION 절을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96e30ef37c8144ef99e577a0611c7c38fef6cc77" translate="yes" xml:space="preserve">
          <source>The WITH CHECK OPTION clause is used to prevent updates or inserts to views unless the WHERE clause in the SELECT statement is true.</source>
          <target state="translated">WITH CHECK OPTION 절은 SELECT 문의 WHERE 절이 true가 아닌 경우보기에 대한 갱신 또는 삽입을 방지하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2f0e3d55a444e135f2e57c5c5eb4755a9b029ae2" translate="yes" xml:space="preserve">
          <source>The WSREP provider for &lt;a href=&quot;../galera/index&quot;&gt;Galera&lt;/a&gt; 3.</source>
          <target state="translated">&lt;a href=&quot;../galera/index&quot;&gt;Galera&lt;/a&gt; 3 의 WSREP 제공자 .</target>
        </trans-unit>
        <trans-unit id="bc27f9fc827b050579d929ec08677feaf633a966" translate="yes" xml:space="preserve">
          <source>The WSREP provider for &lt;a href=&quot;../galera/index&quot;&gt;Galera&lt;/a&gt; 4.</source>
          <target state="translated">&lt;a href=&quot;../galera/index&quot;&gt;Galera&lt;/a&gt; 4 용 WSREP 제공자 .</target>
        </trans-unit>
        <trans-unit id="fe095799248c1c5f4d0aa11ac343edfcfd3fd095" translate="yes" xml:space="preserve">
          <source>The WSREP_STATUS table makes &lt;a href=&quot;../galera/index&quot;&gt;Galera&lt;/a&gt; node cluster status information available through the &lt;a href=&quot;../information-schema/index&quot;&gt;Information Schema&lt;/a&gt;. The same information can be returned using the &lt;code&gt;&lt;a href=&quot;../show-wsrep_status/index&quot;&gt;SHOW WSREP_STATUS&lt;/a&gt;&lt;/code&gt; statement. Only users with the &lt;code&gt;&lt;a href=&quot;../grant/index&quot;&gt;SUPER&lt;/a&gt;&lt;/code&gt; privilege can access information from this table.</source>
          <target state="translated">WSREP_STATUS 테이블은 &lt;a href=&quot;../galera/index&quot;&gt;Galera&lt;/a&gt; 노드 클러스터 상태 정보를 &lt;a href=&quot;../information-schema/index&quot;&gt;정보 스키마를&lt;/a&gt; 통해 사용 가능하게합니다 . &lt;code&gt;&lt;a href=&quot;../show-wsrep_status/index&quot;&gt;SHOW WSREP_STATUS&lt;/a&gt;&lt;/code&gt; 문을 사용하여 동일한 정보를 리턴 할 수 있습니다 . &lt;code&gt;&lt;a href=&quot;../grant/index&quot;&gt;SUPER&lt;/a&gt;&lt;/code&gt; 권한 이있는 사용자 만이 테이블의 정보에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4339d90d4e21d4825a7700781fb0d6aeaa01ccda" translate="yes" xml:space="preserve">
          <source>The Well-Known Text (WKT) representation of Geometry is designed to exchange geometry data in ASCII form. Examples of the basic geometry types include:</source>
          <target state="translated">WKT (Well-Known Text) 표시는 ASCII 형식으로 지오메트리 데이터를 교환하도록 설계되었습니다. 기본 지오메트리 유형의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a3b561edfef7631d85f969757df6779179071ae1" translate="yes" xml:space="preserve">
          <source>The Well-Known Text (WKT) representation of Geometry is designed to exchange geometry data in ASCII form. This section has articles on WKT in MariaDB.</source>
          <target state="translated">WKT (Well-Known Text) 표시는 ASCII 형식으로 지오메트리 데이터를 교환하도록 설계되었습니다. 이 섹션에는 MariaDB의 WKT에 대한 기사가 있습니다.</target>
        </trans-unit>
        <trans-unit id="de3042a6f44c4930813649dfe2d4f05538dc76d2" translate="yes" xml:space="preserve">
          <source>The Windows implementation is completely different &amp;ndash; MariaDB's uses native Windows threadpooling, while Oracle's implementation includes a convenience function &lt;em&gt;WSAPoll()&lt;/em&gt; (provided for convenience to port Unix applications). As a consequence of relying on &lt;em&gt;WSAPoll()&lt;/em&gt;, Oracle's implementation will not work with named pipes and shared memory connections.</source>
          <target state="translated">Windows 구현은 완전히 다릅니다. MariaDB는 기본 Windows 스레드 &lt;em&gt;풀링을&lt;/em&gt; 사용하지만 Oracle 구현에는 편의 기능 &lt;em&gt;WSAPoll ()&lt;/em&gt; (유닉스 응용 프로그램을 편리하게 제공하기 위해 제공)이 포함되어 있습니다. &lt;em&gt;WSAPoll ()&lt;/em&gt; 에 의존 한 결과 Oracle의 구현은 명명 된 파이프 및 공유 메모리 연결에서 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="53952c6f914863edb0d06450c0ca5a77ad54d2e6" translate="yes" xml:space="preserve">
          <source>The Windows implementation of the thread pool uses a native thread pool created with the &lt;code&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/api/threadpoolapiset/nf-threadpoolapiset-createthreadpool&quot;&gt;CreateThreadpool&lt;/a&gt;&lt;/code&gt; API.</source>
          <target state="translated">스레드 풀의 Windows 구현은 &lt;code&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/api/threadpoolapiset/nf-threadpoolapiset-createthreadpool&quot;&gt;CreateThreadpool&lt;/a&gt;&lt;/code&gt; API로 작성된 기본 스레드 풀을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="7b912561a0c7672c4e6c8ae3216e34fca7bd0267" translate="yes" xml:space="preserve">
          <source>The Windows installer for &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-526-release-notes/&quot;&gt;MariaDB 5.2.6&lt;/a&gt; and higher will set the data directory ACL to include full access rights for the user who runs the setup to prevent this issue from happening.</source>
          <target state="translated">&lt;a href=&quot;https://mariadb.com/kb/en/mariadb-526-release-notes/&quot;&gt;MariaDB 5.2.6 이상용&lt;/a&gt; Windows 설치 프로그램은 이 문제가 발생하지 않도록 설정을 실행하는 사용자에 대한 모든 액세스 권한을 포함하도록 데이터 디렉토리 ACL을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="a8cacd63a8d3729b567e7d3913ca5c49a6fc975e" translate="yes" xml:space="preserve">
          <source>The Windows server is joined to a domain.</source>
          <target state="translated">Windows 서버가 도메인에 가입되었습니다.</target>
        </trans-unit>
        <trans-unit id="c7d43264eb650ae8ef5b0f5a3977638408d8a7bd" translate="yes" xml:space="preserve">
          <source>The Windows service created with this option &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/Services/automatically-starting-services&quot;&gt;auto-starts&lt;/a&gt;. If you want a service that is &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/Services/starting-services-on-demand&quot;&gt;started on demand&lt;/a&gt;, then use the &lt;code&gt;&lt;a href=&quot;#install-manual&quot;&gt;--install-manual&lt;/a&gt;&lt;/code&gt; option.</source>
          <target state="translated">이 옵션으로 작성된 Windows 서비스는 &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/Services/automatically-starting-services&quot;&gt;자동 시작됩니다&lt;/a&gt; . &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/Services/starting-services-on-demand&quot;&gt;요청시&lt;/a&gt; 서비스를 시작 하려면 &lt;code&gt;&lt;a href=&quot;#install-manual&quot;&gt;--install-manual&lt;/a&gt;&lt;/code&gt; 옵션 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ed5e83ab337171cc41235884fdb701b3faaca8b9" translate="yes" xml:space="preserve">
          <source>The Windows service created with this option is &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/Services/starting-services-on-demand&quot;&gt;started on demand&lt;/a&gt;. If you want a service that &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/Services/automatically-starting-services&quot;&gt;auto-starts&lt;/a&gt;, use the &lt;code&gt;&lt;a href=&quot;#install&quot;&gt;--install&lt;/a&gt;&lt;/code&gt; option.</source>
          <target state="translated">이 옵션으로 생성 된 Windows 서비스는 &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/Services/starting-services-on-demand&quot;&gt;요청시 시작됩니다&lt;/a&gt; . &lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/Services/automatically-starting-services&quot;&gt;자동 시작&lt;/a&gt; 서비스를 원하면 &lt;code&gt;&lt;a href=&quot;#install&quot;&gt;--install&lt;/a&gt;&lt;/code&gt; 옵션을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="5e631e934a77425e511f4ab4831c411ec027f38a" translate="yes" xml:space="preserve">
          <source>The Windows version of &lt;code&gt;mysql_install_db&lt;/code&gt;: &lt;code&gt;&lt;a href=&quot;../mysql_install_dbexe/index&quot;&gt;mysql_install_db.exe&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;mysql_install_db&lt;/code&gt; 의 Windows 버전 : &lt;code&gt;&lt;a href=&quot;../mysql_install_dbexe/index&quot;&gt;mysql_install_db.exe&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="206261d287dd5c84a53169c6456cfc54e9f4efe2" translate="yes" xml:space="preserve">
          <source>The X co-ordinate is 2.0</source>
          <target state="translated">X 좌표는 2.0입니다</target>
        </trans-unit>
        <trans-unit id="e37eb0749d2a4ba13e0765c6dbe51be4e7205f20" translate="yes" xml:space="preserve">
          <source>The XtraDB/InnoDB recovery mode is a mode used for recovering from emergency situations. The &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_force_recovery&quot;&gt;innodb_force_recovery&lt;/a&gt; server system variable sets the recovery mode. A mode of 0 is normal use, while the higher the mode, the more stringent the restrictions. Higher modes incorporate all limitations of the lower modes.</source>
          <target state="translated">XtraDB / InnoDB 복구 모드는 응급 상황에서 복구하는 데 사용되는 모드입니다. &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_force_recovery&quot;&gt;innodb_force_recovery의&lt;/a&gt; 서버 시스템 변수 복구 모드를 설정한다. 0의 모드는 일반적으로 사용되지만 모드가 높을수록 제한이 더 엄격합니다. 높은 모드는 낮은 모드의 모든 한계를 통합합니다.</target>
        </trans-unit>
        <trans-unit id="0f30bc0b64ab7d4f233d1ce696b2464f90ae6715" translate="yes" xml:space="preserve">
          <source>The Y-co-ordinate is 4.0</source>
          <target state="translated">Y 좌표는 4.0입니다</target>
        </trans-unit>
        <trans-unit id="05b60dd0bec3dc32dfca478a8dd77b9f271bcde5" translate="yes" xml:space="preserve">
          <source>The ]&lt;a href=&quot;../integer/index&quot;&gt;INTEGER&lt;/a&gt; type contains signed integer numeric 4-byte values (the &lt;em&gt;int/ of the C language) ranging from &lt;code&gt;&amp;ndash;2,147,483,648&lt;/code&gt; to &lt;code&gt;2,147,483,647&lt;/code&gt; for signed type and &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;4,294,967,295&lt;/code&gt; for unsigned type.&lt;/em&gt;</source>
          <target state="translated">] &lt;a href=&quot;../integer/index&quot;&gt;INTEGER의&lt;/a&gt; 유형 (숫자 4 바이트 값은 부호있는 정수 포함 &lt;em&gt;범위 INT / C 언어의) &lt;code&gt;&amp;ndash;2,147,483,648&lt;/code&gt; 에 &lt;code&gt;2,147,483,647&lt;/code&gt; 서명 형식 및 &lt;code&gt;0&lt;/code&gt; 에 &lt;code&gt;4,294,967,295&lt;/code&gt; 부호 타입.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bb8c1e44a7548618d229a0677a0a9ae2ac6ff944" translate="yes" xml:space="preserve">
          <source>The `&amp;lt;database&amp;gt;` and `&amp;lt;table&amp;gt;` define the table that is streamed to ColumnStore. This table should exist on the master server where MaxScale is reading events from. If the table is not created on ColumnStore, the adapter will print instructions on how to define it in the correct way.</source>
          <target state="translated">`&amp;lt;database&amp;gt;`및`&amp;lt;table&amp;gt;`은 ColumnStore로 스트리밍되는 테이블을 정의합니다. 이 테이블은 MaxScale이 이벤트를 읽는 마스터 서버에 있어야합니다. 테이블이 ColumnStore에서 작성되지 않으면 어댑터는 올바른 방법으로 테이블을 정의하는 방법에 대한 지시 사항을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="8a0c56b78870b13d2325745b5d8913d030074170" translate="yes" xml:space="preserve">
          <source>The `&amp;lt;user&amp;gt;` and `&amp;lt;password&amp;gt;` are the users created for the CDC user, `&amp;lt;host&amp;gt;` is the MaxScale address and `&amp;lt;port&amp;gt;` is the port where the CDC service listener is listening.</source>
          <target state="translated">`&amp;lt;user&amp;gt;`및 &amp;lt;&amp;lt; password&amp;gt;`는 CDC 사용자를 위해 작성된 사용자이고`&amp;lt;host&amp;gt;`는 MaxScale 주소이고`&amp;lt;port&amp;gt;`는 CDC 서비스 리스너가 청취하는 포트입니다.</target>
        </trans-unit>
        <trans-unit id="db9f2b4b3261196b5c167fbe739b636ee830d964" translate="yes" xml:space="preserve">
          <source>The `-c` flag is optional if you are running the adapter on the server where ColumnStore is located.</source>
          <target state="translated">`-c` 플래그는 ColumnStore가있는 서버에서 어댑터를 실행중인 경우 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="b970c8f499057ed1a891831049c518fcfc7e511f" translate="yes" xml:space="preserve">
          <source>The `Country` table is first, followed by the `City` table.</source>
          <target state="translated">`Country` 테이블이 먼저오고 그 다음에`City` 테이블이옵니다.</target>
        </trans-unit>
        <trans-unit id="1b8adcaaf3067f377f42c08f6567fd95cec24d5a" translate="yes" xml:space="preserve">
          <source>The ability to create stored aggregate functions was added in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1033-release-notes/&quot;&gt;MariaDB 10.3.3&lt;/a&gt;.</source>
          <target state="translated">저장된 집계 함수를 생성하는 기능이 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1033-release-notes/&quot;&gt;MariaDB 10.3.3&lt;/a&gt; 에 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="e6570ee9bf6de30017fe02141a6faef0e9442e68" translate="yes" xml:space="preserve">
          <source>The ability to restore individual tables and partitions relies on &lt;a href=&quot;../innodb-file-per-table-tablespaces/index#copying-transportable-tablespaces&quot;&gt;InnoDB's transportable tablespaces&lt;/a&gt;. For MariaDB to import tablespaces like these, &lt;a href=&quot;../xtradb-and-innodb/index&quot;&gt;InnoDB&lt;/a&gt; looks for a file with a &lt;code&gt;.cfg&lt;/code&gt; extension. For Mariabackup to create these files, you also need to add the &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-export&quot;&gt;--export&lt;/a&gt;&lt;/code&gt; option during the prepare step.</source>
          <target state="translated">개별 테이블 및 파티션을 복원하는 기능은 &lt;a href=&quot;../innodb-file-per-table-tablespaces/index#copying-transportable-tablespaces&quot;&gt;InnoDB의 전송 가능한 테이블 스페이스&lt;/a&gt; 에 의존합니다 . MariaDB가 이와 같은 테이블 스페이스를 가져 오기 위해 &lt;a href=&quot;../xtradb-and-innodb/index&quot;&gt;InnoDB&lt;/a&gt; 는 확장명 이 &lt;code&gt;.cfg&lt;/code&gt; 인 파일을 찾습니다 . Mariabackup에서 이러한 파일을 만들려면 준비 단계 에서 &lt;code&gt;&lt;a href=&quot;../mariabackup-options/index#-export&quot;&gt;--export&lt;/a&gt;&lt;/code&gt; 옵션 을 추가해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a99160aa8b65d7bd92af884553d3da66da9f76ae" translate="yes" xml:space="preserve">
          <source>The above PAM service configuration file also instructs the PAM authentication framework that for an &lt;strong&gt;account&lt;/strong&gt; (i.e. type=&lt;code&gt;&lt;a href=&quot;http://www.linux-pam.org/Linux-PAM-html/mwg-expected-of-module-acct.html&quot;&gt;account&lt;/a&gt;&lt;/code&gt;) to be valid, it is &lt;strong&gt;required&lt;/strong&gt; that the &lt;code&gt;pam_unix.so&lt;/code&gt; PAM module returns a success.</source>
          <target state="translated">위의 PAM 서비스 구성 파일은 또한 PAM 인증 프레임 워크에 &lt;strong&gt;계정&lt;/strong&gt; (예 : type = &lt;code&gt;&lt;a href=&quot;http://www.linux-pam.org/Linux-PAM-html/mwg-expected-of-module-acct.html&quot;&gt;account&lt;/a&gt;&lt;/code&gt; )이 유효하기 &lt;strong&gt;위해서는 &lt;/strong&gt; &lt;code&gt;pam_unix.so&lt;/code&gt; PAM 모듈이 성공을 반환 &lt;strong&gt;해야&lt;/strong&gt; 한다고 지시합니다 .</target>
        </trans-unit>
        <trans-unit id="2f317a73d7fbc48ae62c75a40184b49dd5ddb169" translate="yes" xml:space="preserve">
          <source>The above PAM service configuration file also provides the &lt;code&gt;audit&lt;/code&gt; module argument to the &lt;code&gt;pam_unix&lt;/code&gt; PAM module. The &lt;a href=&quot;https://linux.die.net/man/8/pam_unix&quot;&gt;pam_unix manual&lt;/a&gt; says that this module argument enables extreme debug logging to the syslog.</source>
          <target state="translated">위의 PAM 서비스 구성 파일은 또한 &lt;code&gt;pam_unix&lt;/code&gt; PAM 모듈에 &lt;code&gt;audit&lt;/code&gt; 모듈 인수를 제공합니다 . &lt;a href=&quot;https://linux.die.net/man/8/pam_unix&quot;&gt;은 pam_unix 설명서는&lt;/a&gt; 이 모듈 인수가 syslog에 극단적 인 디버그 로깅을 할 수 있다고 말한다.</target>
        </trans-unit>
        <trans-unit id="4f657620f60700e3b9797f7a59807d9a2584fdb9" translate="yes" xml:space="preserve">
          <source>The above PAM service configuration file instructs the PAM authentication framework that for successful &lt;strong&gt;authentication&lt;/strong&gt; (i.e. type=&lt;code&gt;&lt;a href=&quot;http://www.linux-pam.org/Linux-PAM-html/mwg-expected-of-module-auth.html&quot;&gt;auth&lt;/a&gt;&lt;/code&gt;), it is &lt;strong&gt;required&lt;/strong&gt; that the &lt;code&gt;pam_unix.so&lt;/code&gt; PAM module returns a success.</source>
          <target state="translated">위의 PAM 서비스 구성 파일은 성공을 위해하는 PAM 인증 프레임 워크를 지시 &lt;strong&gt;인증&lt;/strong&gt; (즉, 유형 = &lt;code&gt;&lt;a href=&quot;http://www.linux-pam.org/Linux-PAM-html/mwg-expected-of-module-auth.html&quot;&gt;auth&lt;/a&gt;&lt;/code&gt; )이되어 &lt;strong&gt;필요한&lt;/strong&gt; 그 &lt;code&gt;pam_unix.so&lt;/code&gt; 의 PAM 모듈 반환 성공.</target>
        </trans-unit>
        <trans-unit id="649ea8c19af62cb952f4ce8dc6c22ffe93175787" translate="yes" xml:space="preserve">
          <source>The above assumes you are just testing major versions of MariaDB. If you are testing specific versions, use directory names like &lt;code&gt;mariadb-5.3.2&lt;/code&gt;</source>
          <target state="translated">위의 내용은 MariaDB의 주요 버전 만 테스트한다고 가정합니다. 특정 버전을 테스트하는 경우 &lt;code&gt;mariadb-5.3.2&lt;/code&gt; 와 같은 디렉토리 이름을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9a448f84c2bd085e0a5e0690b50ad399a42abff9" translate="yes" xml:space="preserve">
          <source>The above can be replaced with:</source>
          <target state="translated">위의 내용은 다음으로 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5b0ab05ca7320310b6fd7145fe744cdceb67d78" translate="yes" xml:space="preserve">
          <source>The above can make a huge difference on performance. There is also a catch, though:</source>
          <target state="translated">위의 내용은 성능에 큰 차이를 만들 수 있습니다. 그러나 캐치도 있습니다.</target>
        </trans-unit>
        <trans-unit id="893f05acb5ace678a61bd89ff46c72ac3aac68bc" translate="yes" xml:space="preserve">
          <source>The above changes the test table on the slave to rocksdb without registering the change in the binary log.</source>
          <target state="translated">이진 로그에 변경 사항을 등록하지 않고 슬레이브의 테스트 테이블을 rocksdb로 변경합니다.</target>
        </trans-unit>
        <trans-unit id="6a5e4369c8c4ab2783ef45b6eceb0e9db19e60c9" translate="yes" xml:space="preserve">
          <source>The above commands create two files in the working directory: The &lt;code&gt;ca-key.pem&lt;/code&gt; private key and the &lt;code&gt;ca.pem&lt;/code&gt; X509 certificate are both are used by the CA to create self-signed X509 certificates below.</source>
          <target state="translated">위의 명령은 작업 디렉토리에 두 개의 파일을 작성합니다. &lt;code&gt;ca-key.pem&lt;/code&gt; 개인 키와 &lt;code&gt;ca.pem&lt;/code&gt; X509 인증서는 모두 CA가 아래에서 자체 서명 된 X509 인증서를 작성하는 데 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e6f2d281eaaca8fbd730fe9197b99b66fc4d5a5a" translate="yes" xml:space="preserve">
          <source>The above comparison was made using</source>
          <target state="translated">위의 비교는</target>
        </trans-unit>
        <trans-unit id="142777cabee0ec576dbddd0f9cd9d573ecbb7f9b" translate="yes" xml:space="preserve">
          <source>The above conditions are not required if the server variable &lt;a href=&quot;../server-system-variables/index#log_bin_trust_function_creators&quot;&gt;log_bin_trust_function_creators&lt;/a&gt; is set to &lt;code&gt;1&lt;/code&gt; - by default it is set to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">서버 변수 &lt;a href=&quot;../server-system-variables/index#log_bin_trust_function_creators&quot;&gt;log_bin_trust_function_creators&lt;/a&gt; 가 &lt;code&gt;1&lt;/code&gt; 로 설정된 경우 위의 조건이 필요하지 않습니다. 기본적으로 &lt;code&gt;0&lt;/code&gt; 으로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0b28ec9d359f43ee6782a4ad7e07f90ab8d7bd7" translate="yes" xml:space="preserve">
          <source>The above ensures that all non-transactional tables are properly flushed to disk before the snapshot is done. Using &lt;code&gt;BACKUP STAGE&lt;/code&gt; commands is also more efficient than using the &lt;code&gt;&lt;a href=&quot;../flush/index&quot;&gt;FLUSH TABLES WITH READ LOCK&lt;/a&gt;&lt;/code&gt; command as the above set of commands will not block or be blocked by write operations to transactional tables.</source>
          <target state="translated">위의 내용은 스냅 샷을 작성하기 전에 모든 비 트랜잭션 테이블이 디스크로 올바르게 플러시되도록합니다. 사용 &lt;code&gt;BACKUP STAGE&lt;/code&gt; 명령은 또한 사용하는 것보다 더 효율적이다 &lt;code&gt;&lt;a href=&quot;../flush/index&quot;&gt;FLUSH TABLES WITH READ LOCK&lt;/a&gt;&lt;/code&gt; 명령의 상기 세트가 차단되지 않거나 트랜잭션 테이블에 기록 동작에 의해 차단되는 바와 같이 명령.</target>
        </trans-unit>
        <trans-unit id="9543d8f441eda63bea706afac27d7cd099806410" translate="yes" xml:space="preserve">
          <source>The above example builds a release configured for 32 bit systems in a subdirectory named &lt;code&gt;bld&lt;/code&gt;. &quot;&lt;code&gt;cmake ...&lt;/code&gt;&quot; is the configuration step, &quot;&lt;code&gt;cmake --build . --config Relwithdebinfo&lt;/code&gt;&quot; is the build step.</source>
          <target state="translated">위의 예제는 &lt;code&gt;bld&lt;/code&gt; 라는 서브 디렉토리에 32 비트 시스템 용으로 구성된 릴리스를 빌드합니다 . &quot; &lt;code&gt;cmake ...&lt;/code&gt; &quot;는 구성 단계 &quot; &lt;code&gt;cmake --build . --config Relwithdebinfo&lt;/code&gt; &quot;는 빌드 단계입니다.</target>
        </trans-unit>
        <trans-unit id="062990a8e48e69c1890f4a2fbfa8340be617d759" translate="yes" xml:space="preserve">
          <source>The above example can also be rewritten to define the digit part as a subpattern as well:</source>
          <target state="translated">숫자 부분을 하위 패턴으로 정의하기 위해 위 예제를 다시 작성할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a755fb6933e888a897710e8a5bda2196472307d" translate="yes" xml:space="preserve">
          <source>The above example can be partitioned, so that the window functions are over a particular field grouping such as owner and accumulate within that grouping. This is achieved by adding the syntax &quot;partition by &amp;lt;columns&amp;gt;&quot; in the window function clause.</source>
          <target state="translated">위의 예제는 분할 될 수 있으므로 창 기능은 소유자와 같은 특정 필드 그룹을 통해 해당 그룹 내에 누적됩니다. 창 함수 절에 &quot;partition by &amp;lt;columns&amp;gt;&quot;구문을 추가하면됩니다.</target>
        </trans-unit>
        <trans-unit id="2ef122e555dc712bd1bb67e9ab5885b3c98fb9d3" translate="yes" xml:space="preserve">
          <source>The above example could indicate a poorly performing cache. More queries have been added, and more queries have been dropped, than have actually been used.</source>
          <target state="translated">위의 예는 캐시 성능이 저하되었음을 나타냅니다. 실제로 사용 된 것보다 많은 쿼리가 추가되었고 더 많은 쿼리가 삭제되었습니다.</target>
        </trans-unit>
        <trans-unit id="d10ddeb13fdde2bd13da06fe7953aaeb15e0acdc" translate="yes" xml:space="preserve">
          <source>The above example illustrates that when the added columns are declared NOT NULL, a DEFAULT value must be available, either implied by the data type or set explicitly by the user. The expression need not be constant, but it must not refer to the columns of the table, such as DEFAULT u+1 (a MariaDB extension). The DEFAULT current_timestamp() would be evaluated at the time of the ALTER TABLE and apply to each row, like it does for non-instant ALTER TABLE. If a subsequent ALTER TABLE changes the DEFAULT value for subsequent INSERT, the values of the columns in existing records will naturally be unaffected.</source>
          <target state="translated">위의 예는 추가 된 열이 NOT NULL로 선언 될 때 DEFAULT 값을 사용할 수 있어야하며 데이터 유형에 의해 암시되거나 사용자가 명시 적으로 설정해야합니다. 표현식은 일정하지 않아도되지만 DEFAULT u + 1 (MariaDB 확장)과 같은 테이블 열을 참조하면 안됩니다. DEFAULT current_timestamp ()는 ALTER TABLE 시간에 평가되며 즉시 ALTER TABLE이 아닌 ALTER TABLE의 경우와 같이 각 행에 적용됩니다. 후속 ALTER TABLE이 후속 INSERT의 DEFAULT 값을 변경하면 기존 레코드의 열 값은 자연스럽게 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6f7426e03c4d509db6671267edac0884d189f9ba" translate="yes" xml:space="preserve">
          <source>The above example is computed as follows:</source>
          <target state="translated">위의 예는 다음과 같이 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="89a07257527d8e2736ca50f57b1563ff9375d9e6" translate="yes" xml:space="preserve">
          <source>The above example requires a stopSystem to unassign the db root from the pm server. RemoveDBRoot can only be performed on a started system as it checks whether the db root has data or not. Many other permutations of commands are of course possible including moving a db root to another pm server.</source>
          <target state="translated">위의 예제에서는 stopSystem이 pm 서버에서 db 루트를 할당 해제해야합니다. RemoveDBRoot는 db 루트에 데이터가 있는지 여부를 확인하므로 시작된 시스템에서만 수행 할 수 있습니다. db 루트를 다른 pm 서버로 이동하는 것을 포함하여 다른 많은 명령 순열도 물론 가능합니다.</target>
        </trans-unit>
        <trans-unit id="94cb38b09bb7ec55228e1ce73fac49616e945897" translate="yes" xml:space="preserve">
          <source>The above example returns:</source>
          <target state="translated">위의 예는 다음을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e3c3dee8a8c643c36a602c9166bfd73b0ccd92a4" translate="yes" xml:space="preserve">
          <source>The above examples introduce the syntax, but are not very useful on their own. It's the special characters that give regular expressions their power.</source>
          <target state="translated">위의 예제는 구문을 소개하지만 그 자체로는 그다지 유용하지 않습니다. 정규 표현식에 힘을주는 특수 문자입니다.</target>
        </trans-unit>
        <trans-unit id="180d1168ed3e590c8f0526fd9add849641992ade" translate="yes" xml:space="preserve">
          <source>The above features yield several benefits for a DBMS clustering solution, including:</source>
          <target state="translated">위의 기능은 다음을 포함하여 DBMS 클러스터링 솔루션에 몇 가지 이점을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2eddbaadde2edc5bb5a88b9f03fce51bd776dec1" translate="yes" xml:space="preserve">
          <source>The above instructions assume &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt; or higher.</source>
          <target state="translated">위의 지침에서는 &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt; 이상을 가정 합니다.</target>
        </trans-unit>
        <trans-unit id="02f8be19441f359ecee9ae220a7540260d919713" translate="yes" xml:space="preserve">
          <source>The above is identical to &lt;code&gt;mysqladmin shutdown&lt;/code&gt;.</source>
          <target state="translated">위의 내용은 &lt;code&gt;mysqladmin shutdown&lt;/code&gt; 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="7745d47f460b27f80cce272e4e08f8d7812d39a1" translate="yes" xml:space="preserve">
          <source>The above is the same as:</source>
          <target state="translated">위와 동일합니다 :</target>
        </trans-unit>
        <trans-unit id="623292b847382fdf19b782ce80054eec0e7b48ff" translate="yes" xml:space="preserve">
          <source>The above logic for a single table join extrapolates out to multi table joins where the small table values are precalculated and performed as one single scan against the large table. This works well for the typical star schema case joining multiple dimension tables with a large fact table. For some join scenarios it may be necessary to sequence joins to create the intermediate datasets for joining, this would happen for instance with a snowflake schema structure. In some extreme cases it may be hard for the optimizer to be able to determine the most optimal join path. In this case a hint is available to force a join ordering. The INFINIDB_ORDERED hint will force the first table in the from clause to be considered the largest table and override any statistics based decision, for example:</source>
          <target state="translated">단일 테이블 조인에 대한 위의 논리는 작은 테이블 값이 미리 계산되어 큰 테이블에 대한 단일 스캔으로 수행되는 다중 테이블 조인으로 추정됩니다. 이는 여러 팩트 테이블을 큰 팩트 테이블과 조인하는 일반적인 스타 스키마 사례에 적합합니다. 일부 조인 시나리오의 경우 조인을위한 중간 데이터 세트를 작성하기 위해 조인을 시퀀싱해야 할 수도 있습니다. 예를 들어 눈송이 스키마 구조에서 발생합니다. 극단적 인 경우 옵티마이 저가 최적의 조인 경로를 결정하기 어려울 수 있습니다. 이 경우 조인 순서를 강제하기위한 힌트를 사용할 수 있습니다. INFINIDB_ORDERED 힌트는 from 절의 첫 번째 테이블을 가장 큰 테이블로 간주하고 통계 기반 결정을 무시합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3da74ac48458cdb1eaeb903b82233108338a62d4" translate="yes" xml:space="preserve">
          <source>The above optimization also works for &lt;a href=&quot;../subqueries/index&quot;&gt;subqueries&lt;/a&gt;:</source>
          <target state="translated">위의 최적화는 &lt;a href=&quot;../subqueries/index&quot;&gt;하위 쿼리&lt;/a&gt; 에도 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="47551396703600538d35cbcce25fc95ce2fb0751" translate="yes" xml:space="preserve">
          <source>The above query asks for the &lt;code&gt;orderkeys&lt;/code&gt; of the orders placed on 1992-07-01 which contain parts with a retail price greater than $2095.</source>
          <target state="translated">위 쿼리는 &lt;code&gt;orderkeys&lt;/code&gt; 에 주문한 주문 키에 대해 소매 가격이 $ 2095보다 큰 부품을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="9af1b28b0dd2faa991b99064c36dc29c0741806a" translate="yes" xml:space="preserve">
          <source>The above query makes use of the default to define the window frame. It could be written explicitly as follows:</source>
          <target state="translated">위 쿼리는 기본값을 사용하여 창 프레임을 정의합니다. 다음과 같이 명시 적으로 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c65fe9f1bf10ee4eb0e73e34e8cf333c6ca6f799" translate="yes" xml:space="preserve">
          <source>The above shows that the mysql command-line client is using the library &lt;code&gt;/usr/lib/libmysqlclient.so.16&lt;/code&gt; and that that library is part of the &lt;code&gt;libmariadbclient16&lt;/code&gt; Ubuntu package. Unsurprisingly, the mysql command-line client works perfectly on this system.</source>
          <target state="translated">위의 내용은 mysql 명령 행 클라이언트가 &lt;code&gt;/usr/lib/libmysqlclient.so.16&lt;/code&gt; 라이브러리를 사용 하고 있으며 해당 라이브러리가 &lt;code&gt;libmariadbclient16&lt;/code&gt; Ubuntu 패키지의 일부임을 보여 줍니다 . 당연히 mysql 명령 행 클라이언트는이 시스템에서 완벽하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="66e32819db3a0f8629ab7d1fb440e953dd0d40b1" translate="yes" xml:space="preserve">
          <source>The above values are the defaults. If you would like to run multiple MariaDB Server instances on the same server, then you will need to set unique values for each instance.</source>
          <target state="translated">위의 값이 기본값입니다. 동일한 서버에서 여러 MariaDB 서버 인스턴스를 실행하려면 각 인스턴스에 대해 고유 한 값을 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="1d24da2489bd4f50ac572d18df10baa721fa36f8" translate="yes" xml:space="preserve">
          <source>The above will tell the &lt;code&gt;configure&lt;/code&gt; script where your MySQL/MariaDB installation is.</source>
          <target state="translated">위는 MySQL / MariaDB 설치 위치를 &lt;code&gt;configure&lt;/code&gt; 스크립트에 알려줍니다 .</target>
        </trans-unit>
        <trans-unit id="8f7d14fd6f642b0431dba27327ce7b3b12f605ef" translate="yes" xml:space="preserve">
          <source>The access mode specifies whether the transaction is allowed to write data or not. By default, transactions are in &lt;code&gt;READ WRITE&lt;/code&gt; mode (see the &lt;a href=&quot;../server-system-variables/index#tx_read_only&quot;&gt;tx_read_only&lt;/a&gt; system variable). &lt;code&gt;READ ONLY&lt;/code&gt; mode allows the storage engine to apply optimizations that cannot be used for transactions which write data. The only exception to this rule is that read only transactions can perform DDL statements on temporary tables.</source>
          <target state="translated">액세스 모드는 트랜잭션이 데이터를 쓸 수 있는지 여부를 지정합니다. 기본적으로 트랜잭션은 &lt;code&gt;READ WRITE&lt;/code&gt; 모드에 있습니다 ( &lt;a href=&quot;../server-system-variables/index#tx_read_only&quot;&gt;tx_read_only&lt;/a&gt; 시스템 변수 참조 ). &lt;code&gt;READ ONLY&lt;/code&gt; 모드에서는 스토리지 엔진이 데이터를 쓰는 트랜잭션에 사용할 수없는 최적화를 적용 할 수 있습니다. 이 규칙의 유일한 예외는 읽기 전용 트랜잭션이 임시 테이블에서 DDL 문을 수행 할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8c8c07f5f30779113fd3b42ea70d399847ebe7ad" translate="yes" xml:space="preserve">
          <source>The access mode specifies whether the transaction is allowed to write data or not. By default, transactions are in &lt;code&gt;READ WRITE&lt;/code&gt; mode (see the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#tx_read_only&quot;&gt;tx_read_only&lt;/a&gt;&lt;/code&gt; system variable). &lt;code&gt;READ ONLY&lt;/code&gt; mode allows the storage engine to apply optimizations that cannot be used for transactions which write data. The only exception to this rule is that read only transactions can perform DDL statements on temporary tables.</source>
          <target state="translated">액세스 모드는 트랜잭션이 데이터를 쓸 수 있는지 여부를 지정합니다. 기본적으로 트랜잭션은 &lt;code&gt;READ WRITE&lt;/code&gt; 모드에 있습니다 ( &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#tx_read_only&quot;&gt;tx_read_only&lt;/a&gt;&lt;/code&gt; 시스템 변수 참조 ). &lt;code&gt;READ ONLY&lt;/code&gt; 모드에서는 스토리지 엔진이 데이터를 쓰는 트랜잭션에 사용할 수없는 최적화를 적용 할 수 있습니다. 이 규칙의 유일한 예외는 읽기 전용 트랜잭션이 임시 테이블에서 DDL 문을 수행 할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d4a20f7798a19f9a20c4207e3bf69733950d929e" translate="yes" xml:space="preserve">
          <source>The account must use TLS and must have a valid X509 certificate. Also, the Certificate Authority must be the one specified via the string &lt;code&gt;issuer&lt;/code&gt;. This option implies &lt;code&gt;REQUIRE X509&lt;/code&gt;. This option can be combined with the &lt;code&gt;SUBJECT&lt;/code&gt;, and &lt;code&gt;CIPHER&lt;/code&gt; options in any order.</source>
          <target state="translated">계정은 TLS를 사용해야하며 유효한 X509 인증서가 있어야합니다. 또한 인증 기관은 문자열 &lt;code&gt;issuer&lt;/code&gt; 를 통해 지정된 인증 기관이어야합니다 . 이 옵션은 &lt;code&gt;REQUIRE X509&lt;/code&gt; 를 의미합니다 . 이 옵션은 임의의 순서로 &lt;code&gt;SUBJECT&lt;/code&gt; 및 &lt;code&gt;CIPHER&lt;/code&gt; 옵션 과 결합 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="faa4a402be363109cb7336f051f343f7433963e5" translate="yes" xml:space="preserve">
          <source>The account must use TLS and must have a valid X509 certificate. Also, the certificate's Subject must be the one specified via the string &lt;code&gt;subject&lt;/code&gt;. This option implies &lt;code&gt;REQUIRE X509&lt;/code&gt;. This option can be combined with the &lt;code&gt;ISSUER&lt;/code&gt;, and &lt;code&gt;CIPHER&lt;/code&gt; options in any order.</source>
          <target state="translated">계정은 TLS를 사용해야하며 유효한 X509 인증서가 있어야합니다. 또한 인증서의 주제는 문자열 &lt;code&gt;subject&lt;/code&gt; 를 통해 지정된 것이어야합니다 . 이 옵션은 &lt;code&gt;REQUIRE X509&lt;/code&gt; 를 의미합니다 . 이 옵션은 &lt;code&gt;ISSUER&lt;/code&gt; 및 &lt;code&gt;CIPHER&lt;/code&gt; 옵션 과 함께 임의의 순서 로 결합 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ab877844c857ab5077813c963fdb6fd548b53528" translate="yes" xml:space="preserve">
          <source>The account must use TLS and must have a valid X509 certificate. This option implies &lt;code&gt;REQUIRE SSL&lt;/code&gt;. This option cannot be combined with other TLS options.</source>
          <target state="translated">계정은 TLS를 사용해야하며 유효한 X509 인증서가 있어야합니다. 이 옵션은 &lt;code&gt;REQUIRE SSL&lt;/code&gt; 의미 합니다 . 이 옵션은 다른 TLS 옵션과 함께 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="74fdd4703588e1657f0773534341fabf62dda8fc" translate="yes" xml:space="preserve">
          <source>The account must use TLS, but no valid X509 certificate is required. Also, the encryption used for the connection must use one of the methods specified in the string &lt;code&gt;cipher&lt;/code&gt;. This option implies &lt;code&gt;REQUIRE SSL&lt;/code&gt;. This option can be combined with the &lt;code&gt;ISSUER&lt;/code&gt;, and &lt;code&gt;SUBJECT&lt;/code&gt; options in any order.</source>
          <target state="translated">계정은 TLS를 사용해야하지만 유효한 X509 인증서는 필요하지 않습니다. 또한 연결에 사용 된 암호화는 문자열 &lt;code&gt;cipher&lt;/code&gt; 에 지정된 방법 중 하나를 사용해야합니다 . 이 옵션은 &lt;code&gt;REQUIRE SSL&lt;/code&gt; 의미 합니다 . 이 옵션은 &lt;code&gt;ISSUER&lt;/code&gt; 및 &lt;code&gt;SUBJECT&lt;/code&gt; 옵션 과 함께 임의의 순서 로 결합 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="96a812ac45824189d0a2dcc9fdea5e0286d17e0d" translate="yes" xml:space="preserve">
          <source>The account must use TLS, but no valid X509 certificate is required. This option cannot be combined with other TLS options.</source>
          <target state="translated">계정은 TLS를 사용해야하지만 유효한 X509 인증서는 필요하지 않습니다. 이 옵션은 다른 TLS 옵션과 함께 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c7d4581228a0d3d077082086a2956497301b5e4b" translate="yes" xml:space="preserve">
          <source>The account that created the trigger, in the form &lt;code&gt;user_name@host_name&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;user_name@host_name&lt;/code&gt; 형식으로 트리거를 생성 한 계정</target>
        </trans-unit>
        <trans-unit id="598b8a8961f7a08bcb10cd44e726949a44a223f9" translate="yes" xml:space="preserve">
          <source>The account used when you connect determines which permissions you have when attempting to modify existing permissions in the grant tables.</source>
          <target state="translated">연결시 사용 된 계정에 따라 권한 부여 테이블에서 기존 권한을 수정하려고 할 때 사용 권한이 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="bbd36c1cc003e9e62300dfab90dfc4746e5eac2a" translate="yes" xml:space="preserve">
          <source>The addition of the &lt;code&gt;WITH ROLLUP&lt;/code&gt; modifier in this example adds an extra row that aggregates both years:</source>
          <target state="translated">의 추가 &lt;code&gt;WITH ROLLUP&lt;/code&gt; 이 예에서는 수정은 추가 행을 추가 집계 두 년이 :</target>
        </trans-unit>
        <trans-unit id="e2cee90c86026adda9294bb00ae20ed181f858bc" translate="yes" xml:space="preserve">
          <source>The addition of the AGGREGATE keyword, so &lt;code&gt;CREATE AGGREGATE FUNCTION&lt;/code&gt;</source>
          <target state="translated">AGGREGATE 키워드가 추가되어 &lt;code&gt;CREATE AGGREGATE FUNCTION&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="98a3e12a853bed52d368a539129ce40ea0095668" translate="yes" xml:space="preserve">
          <source>The addition of the TIME_MS column is based on the microsec_process patch, developed by &lt;a href=&quot;http://www.percona.com/&quot;&gt;Percona&lt;/a&gt;.</source>
          <target state="translated">TIME_MS 열의 추가는 &lt;a href=&quot;http://www.percona.com/&quot;&gt;Percona가&lt;/a&gt; 개발 한 microsec_process 패치를 기반으로합니다 .</target>
        </trans-unit>
        <trans-unit id="edd018893218df05cfce468d52abc8d8034f98c0" translate="yes" xml:space="preserve">
          <source>The address &quot;Off the end&quot; (255.255.255.255+1 - represented as NULL).</source>
          <target state="translated">&quot;끝에서 벗어난&quot;주소 (255.255.255.255 + 1-NULL로 표시)</target>
        </trans-unit>
        <trans-unit id="8b8f996331bd4f52fdee74fb4e22d91caf36bc31" translate="yes" xml:space="preserve">
          <source>The address &quot;Off the end&quot; (ffff.ffff.ffff.ffff.ffff.ffff.ffff.ffff+1 is represented by NULL).</source>
          <target state="translated">&quot;끝에서 벗어난&quot;주소 (ffff.ffff.ffff.ffff.ffff.ffff.ffff.ffff + 1은 NULL로 표시됨)</target>
        </trans-unit>
        <trans-unit id="3683bc14af9115388b9d42a95d8e0f8c31dd55c6" translate="yes" xml:space="preserve">
          <source>The advantage of &lt;a href=&quot;../flush-tables-for-export/index&quot;&gt;FLUSH TABLES table_name FOR EXPORT&lt;/a&gt; is that the table is read locked until &lt;a href=&quot;https://mariadb.com/lock-tables-and-unlock-tables&quot;&gt;UNLOCK TABLES&lt;/a&gt; is executed.</source>
          <target state="translated">&lt;a href=&quot;../flush-tables-for-export/index&quot;&gt;FLUSH TABLES table_name FOR EXPORT&lt;/a&gt; 의 장점은 &lt;a href=&quot;https://mariadb.com/lock-tables-and-unlock-tables&quot;&gt;UNLOCK TABLES&lt;/a&gt; 가 실행될 때까지 테이블을 읽기 잠금 상태라는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="e95fc3b6664ade1c38910cc14dc6c0c485cc5262" translate="yes" xml:space="preserve">
          <source>The advantages of the &lt;code&gt;PAGE&lt;/code&gt; format (compared to &lt;code&gt;DYNAMIC&lt;/code&gt; or &lt;code&gt;FIXED&lt;/code&gt;) for non-transactional tables are:</source>
          <target state="translated">비 트랜잭션 테이블 에 대한 &lt;code&gt;PAGE&lt;/code&gt; 형식 ( &lt;code&gt;DYNAMIC&lt;/code&gt; 또는 &lt;code&gt;FIXED&lt;/code&gt; 와 비교) 의 장점은 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="47b220de6f01c4d11708a4eb1d5649d96eb7578e" translate="yes" xml:space="preserve">
          <source>The affected rows, or -1 in case of error, or the result number of column if the command returns a result set.</source>
          <target state="translated">영향을받는 행 또는 오류의 경우 -1 또는 명령이 결과 세트를 리턴하는 경우 결과 열 수.</target>
        </trans-unit>
        <trans-unit id="052fd9e524e5e7a091878b38f361a3a987397d74" translate="yes" xml:space="preserve">
          <source>The algorithm</source>
          <target state="translated">알고리즘</target>
        </trans-unit>
        <trans-unit id="5a9b4698e5995809803d2eb986cd91ed070a27a8" translate="yes" xml:space="preserve">
          <source>The algorithm is embodied in a &lt;a href=&quot;../stored-procedures/index&quot;&gt;stored procedure&lt;/a&gt; because of its complexity.</source>
          <target state="translated">알고리즘은 복잡하기 때문에 &lt;a href=&quot;../stored-procedures/index&quot;&gt;저장 프로 시저에&lt;/a&gt; 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="c9abcd4085c4eab9007148e82151e018d64565b0" translate="yes" xml:space="preserve">
          <source>The algorithm performs a join operation of tables t1 and t2 according to the following schema.</source>
          <target state="translated">알고리즘은 다음 스키마에 따라 테이블 t1 및 t2의 조인 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="188f31ac8399a1d892ea8497c8da16a2c3f36f6e" translate="yes" xml:space="preserve">
          <source>The algorithm used in the view. See &lt;a href=&quot;../view-algorithms/index&quot;&gt;View Algorithms&lt;/a&gt;.</source>
          <target state="translated">뷰에서 사용되는 알고리즘. &lt;a href=&quot;../view-algorithms/index&quot;&gt;알고리즘보기를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2ee1ca3fe51af36cb6a5c97dc6bd5dffef97f1ba" translate="yes" xml:space="preserve">
          <source>The allowed actions for &lt;code&gt;ON DELETE&lt;/code&gt; and &lt;code&gt;ON UPDATE&lt;/code&gt; are:</source>
          <target state="translated">&lt;code&gt;ON DELETE&lt;/code&gt; 및 &lt;code&gt;ON UPDATE&lt;/code&gt; 에 허용되는 조치 는 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="38fd75fb0a2dc63d570242bfce578c6d7e07667e" translate="yes" xml:space="preserve">
          <source>The amount of I/O capacity available to InnoDB can be configured by setting the &lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_io_capacity&quot;&gt;innodb_io_capacity&lt;/a&gt;&lt;/code&gt; system variable. This system variable can be changed dynamically with &lt;code&gt;&lt;a href=&quot;../set/index#global-session&quot;&gt;SET GLOBAL&lt;/a&gt;&lt;/code&gt;. For example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_io_capacity&quot;&gt;innodb_io_capacity&lt;/a&gt;&lt;/code&gt; 시스템 변수를 설정하여 InnoDB에 사용 가능한 I / O 용량을 구성 할 수 있습니다 . 이 시스템 변수는 &lt;code&gt;&lt;a href=&quot;../set/index#global-session&quot;&gt;SET GLOBAL&lt;/a&gt;&lt;/code&gt; 을 사용 하여 동적으로 변경할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b704ecc4acdfa5010ed50a6f98eac19303503a12" translate="yes" xml:space="preserve">
          <source>The amount of memory used by the process.</source>
          <target state="translated">프로세스가 사용하는 메모리의 양.</target>
        </trans-unit>
        <trans-unit id="565ae51438b16b5e41e83e89503cbc7de7ba8cc3" translate="yes" xml:space="preserve">
          <source>The amount of the compressed file used, NULL if this is an uncompressed file</source>
          <target state="translated">사용 된 압축 파일의 양. 압축되지 않은 파일 인 경우 NULL</target>
        </trans-unit>
        <trans-unit id="ff7377b665de5ed1f330925916dcab1862fb37db" translate="yes" xml:space="preserve">
          <source>The amount of time that Mariabackup held its locks.</source>
          <target state="translated">Mariabackup이 잠금을 유지 한 시간입니다.</target>
        </trans-unit>
        <trans-unit id="769363bfbf134ac151bee8e0321c390e610b7ccf" translate="yes" xml:space="preserve">
          <source>The amount of time, in milliseconds, the process has been in its current state.</source>
          <target state="translated">프로세스가 현재 상태 인 시간 (밀리 초)입니다.</target>
        </trans-unit>
        <trans-unit id="6a05fd575abf7fb634c868bf61a85625988dff20" translate="yes" xml:space="preserve">
          <source>The amount of time, in seconds, the process has been in its current state. For a slave SQL thread before &lt;a href=&quot;../what-is-mariadb-101/index&quot;&gt;MariaDB 10.1&lt;/a&gt;, this is the time in seconds between the last replicated event's timestamp and the slave machine's real time.</source>
          <target state="translated">프로세스가 현재 상태에 있었던 시간 (초)입니다. &lt;a href=&quot;../what-is-mariadb-101/index&quot;&gt;MariaDB 10.1&lt;/a&gt; 이전의 슬레이브 SQL 스레드의 경우 , 이것은 마지막으로 복제 된 이벤트의 타임 스탬프와 슬레이브 시스템의 실시간 사이의 시간 (초)입니다.</target>
        </trans-unit>
        <trans-unit id="8e5b009fa3e954a1965e2285d5671781d813ce5d" translate="yes" xml:space="preserve">
          <source>The answer is: SQL is a statically-typed language. The SQL interpreter needs to know the datatypes of all expressions before the query is run (for example, when one is using prepared statements and runs &lt;code&gt;&quot;select COLUMN_GET(...)&quot;&lt;/code&gt;, the prepared statement API requires the server to inform the client about the datatype of the column being read before the query is executed and the server can see what datatype the column actually has).</source>
          <target state="translated">대답은 다음과 같습니다. SQL은 정적으로 형식화 된 언어입니다. SQL 인터프리터는 쿼리가 실행되기 전에 모든 표현식의 데이터 유형을 알아야합니다 (예 : 준비된 명령문을 사용하고 &lt;code&gt;&quot;select COLUMN_GET(...)&quot;&lt;/code&gt; 을 실행하는 경우 준비된 명령문 API는 서버에 클라이언트에 대해 정보를 제공해야합니다. 쿼리가 실행되기 전에 읽고있는 열의 데이터 유형이며 서버는 열에 실제로 어떤 데이터 유형이 있는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a434aef6d95776343186843ec50dee8b03539de3" translate="yes" xml:space="preserve">
          <source>The appropriate release notes listed &lt;a href=&quot;https://mariadb.com/kb/en/columnstore-release-notes/&quot;&gt;here&lt;/a&gt; document CVEs fixed within a given release. Additional information can also be found at &lt;a href=&quot;../security/index&quot;&gt;Security Vulnerabilities Fixed in MariaDB&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://mariadb.com/kb/en/columnstore-release-notes/&quot;&gt;여기에&lt;/a&gt; 나열된 해당 릴리스 노트 에는 특정 릴리스에서 수정 된 CVE가 설명되어 있습니다 . 추가 정보는 &lt;a href=&quot;../security/index&quot;&gt;MariaDB의 보안 취약점 수정에서&lt;/a&gt; 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bcebb20dfdfdf075d75452e69d60a4e8863896eb" translate="yes" xml:space="preserve">
          <source>The appropriate restoration method corresponding to the backup utility used should be performed first to restore the MariaDB server instance.</source>
          <target state="translated">MariaDB 서버 인스턴스를 복원하려면 먼저 사용 된 백업 유틸리티에 해당하는 적절한 복원 방법을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="d3ba1cb83ed1a6ebfec85014248382ee41c3cba1" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;str&lt;/code&gt; will be converted to string first if it is not a string. A NULL argument will return a NULL result.</source>
          <target state="translated">인수 &lt;code&gt;str&lt;/code&gt; 은 문자열이 아닌 경우 먼저 문자열로 변환됩니다. NULL 인수는 NULL 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9cb39b44caf5b64db14bf7bf7453704c18034918" translate="yes" xml:space="preserve">
          <source>The argument &lt;em&gt;&lt;code&gt;N&lt;/code&gt;&lt;/em&gt; is interpreted as an integer, but may be specified as an integer or a string. The minimum base is 2 and the maximum base is 36. If &lt;em&gt;&lt;code&gt;to_base&lt;/code&gt;&lt;/em&gt; is a negative number, &lt;em&gt;&lt;code&gt;N&lt;/code&gt;&lt;/em&gt; is regarded as a signed number. Otherwise, &lt;em&gt;&lt;code&gt;N&lt;/code&gt;&lt;/em&gt; is treated as unsigned. &lt;code&gt;CONV()&lt;/code&gt; works with 64-bit precision.</source>
          <target state="translated">인수 &lt;em&gt; &lt;code&gt;N&lt;/code&gt; &lt;/em&gt; 은 정수로 해석되지만 정수 또는 문자열로 지정 될 수 있습니다. 최소 밑은 2이고 최대 밑은 36입니다. &lt;em&gt; &lt;code&gt;to_base&lt;/code&gt; &lt;/em&gt; 가 음수 인 경우 &lt;em&gt; &lt;code&gt;N&lt;/code&gt; &lt;/em&gt; 은 부호있는 숫자로 간주됩니다. 그렇지 않으면 &lt;em&gt; &lt;code&gt;N&lt;/code&gt; &lt;/em&gt; 은 부호없는 것으로 처리됩니다. &lt;code&gt;CONV()&lt;/code&gt; 는 64 비트 정밀도로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="e9487d807c45bf75015b5c53a6c0037cf444bd17" translate="yes" xml:space="preserve">
          <source>The argument to &lt;code&gt;&lt;a href=&quot;../password/index&quot;&gt;PASSWORD()&lt;/a&gt;&lt;/code&gt; and the password given to MariaDB clients can be of arbitrary length.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../password/index&quot;&gt;PASSWORD()&lt;/a&gt;&lt;/code&gt; 대한 인수 와 MariaDB 클라이언트에 제공된 암호의 길이는 임의의 길이 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1ba262d1bb3dc676d2d7f097200f15b4dea9c66" translate="yes" xml:space="preserve">
          <source>The argument to &lt;code&gt;MIN()&lt;/code&gt; and &lt;code&gt;MAX()&lt;/code&gt; is a simple column reference that is part of a key.</source>
          <target state="translated">&lt;code&gt;MIN()&lt;/code&gt; 및 &lt;code&gt;MAX()&lt;/code&gt; 에 대한 인수 는 키의 일부인 간단한 열 참조입니다.</target>
        </trans-unit>
        <trans-unit id="1ae93e5c53872f366e64179346e6173da96de357" translate="yes" xml:space="preserve">
          <source>The arguments are optional and are used as follows:</source>
          <target state="translated">인수는 선택 사항이며 다음과 같이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="91337b0313caf1690897a15766b4704711e9d667" translate="yes" xml:space="preserve">
          <source>The arguments that were provided to Mariabackup when it performed the backup.</source>
          <target state="translated">백업을 수행 할 때 Mariabackup에 제공된 인수입니다.</target>
        </trans-unit>
        <trans-unit id="c998e16c5b4351bb0e2be434896563b3c9e44ed9" translate="yes" xml:space="preserve">
          <source>The array ends with a &lt;code&gt;HA_TOPTION_END&lt;/code&gt; macro.</source>
          <target state="translated">배열은 &lt;code&gt;HA_TOPTION_END&lt;/code&gt; 매크로로 끝납니다 .</target>
        </trans-unit>
        <trans-unit id="e5898985979c9bc69f2fd2748c513bf46acddb9e" translate="yes" xml:space="preserve">
          <source>The array specification can also indicate how it must be processed:</source>
          <target state="translated">배열 사양은 또한 처리 방법을 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b9bfbc94bc2eac8c7815202c7b57821d7608a05" translate="yes" xml:space="preserve">
          <source>The arrays are declared statically, as in the following example:</source>
          <target state="translated">배열은 다음 예제와 같이 정적으로 선언됩니다.</target>
        </trans-unit>
        <trans-unit id="d144900cd29da20ba230b69030839c1e76e7ba17" translate="yes" xml:space="preserve">
          <source>The article presents two &quot;good&quot; solutions. They differ in ways that make neither of them 'perfect'; you should try both and weigh the pros and cons.</source>
          <target state="translated">이 기사에서는 두 가지 &quot;좋은&quot;솔루션을 제시합니다. 그것들은 그들 모두를 '완벽한'것으로 만드는 방식이 다릅니다. 둘 다 시도하고 장단점을 측정해야합니다.</target>
        </trans-unit>
        <trans-unit id="592232df6932f06a0dd756d9b450d43368da8bbb" translate="yes" xml:space="preserve">
          <source>The assisted discovery API is pretty much independent from the automatic discovery API. An engine can implement either of them or both (or none); there is no requirement to support automatic discovery if only assisted discovery is needed.</source>
          <target state="translated">지원 검색 API는 자동 검색 API와 거의 독립적입니다. 엔진은 그들 중 하나 또는 둘 다를 구현할 수 있습니다. 보조 검색 만 필요한 경우 자동 검색을 지원할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="60f31b6a6fd02371fa6e9e848a1963d2747c40b2" translate="yes" xml:space="preserve">
          <source>The associations between tables indexes and key caches are lost on server restart. To recreate them automatically, it is necessary to configure caches in a &lt;a href=&quot;../mysqld-configuration-files-and-groups/index&quot;&gt;configuration file&lt;/a&gt; and include some &lt;code&gt;CACHE INDEX&lt;/code&gt; (and optionally &lt;code&gt;&lt;a href=&quot;../load-index/index&quot;&gt;LOAD INDEX&lt;/a&gt;&lt;/code&gt;) statements in the init file.</source>
          <target state="translated">서버를 다시 시작할 때 테이블 인덱스와 키 캐시 간의 연결이 끊어집니다. 자동으로 다시 작성하려면 &lt;a href=&quot;../mysqld-configuration-files-and-groups/index&quot;&gt;구성 파일&lt;/a&gt; 에서 캐시를 구성 하고 init 파일에 일부 &lt;code&gt;CACHE INDEX&lt;/code&gt; (및 선택적으로 &lt;code&gt;&lt;a href=&quot;../load-index/index&quot;&gt;LOAD INDEX&lt;/a&gt;&lt;/code&gt; ) 문을 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="c14e915e96b217be2d05b972dbe89432dc699dd2" translate="yes" xml:space="preserve">
          <source>The assumption is that the copy thread will be able to keep up with server. It should always be able keep up, if the redo log is big enough.</source>
          <target state="translated">복사 스레드가 서버를 유지할 수 있다고 가정합니다. 리두 로그가 충분히 크면 항상 유지할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="1e310d115b9b48eb2f23308b951251514a4a7918" translate="yes" xml:space="preserve">
          <source>The atomic group &lt;code&gt;(?&amp;gt;bc|b)&lt;/code&gt; in the above example can be &quot;translated&quot; as &quot;if there is &lt;code&gt;bc&lt;/code&gt;, then don't try to match as &lt;code&gt;b&lt;/code&gt;&quot;. So &lt;code&gt;b&lt;/code&gt; can match only if &lt;code&gt;bc&lt;/code&gt; is not found.</source>
          <target state="translated">위 예제에서 원자 그룹 &lt;code&gt;(?&amp;gt;bc|b)&lt;/code&gt; 은 &quot; &lt;code&gt;bc&lt;/code&gt; 가 있으면 &lt;code&gt;b&lt;/code&gt; 로 일치 시키려고 시도하지 않음 &quot;으로 &quot;번역&quot;될 수 있습니다 . 따라서 &lt;code&gt;b&lt;/code&gt; 는 &lt;code&gt;bc&lt;/code&gt; 를 찾을 수없는 경우에만 일치 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f2220b915e2926b6304934376f838c4ac334589b" translate="yes" xml:space="preserve">
          <source>The audit log is a set of records written as a list of fields to a file in plain‐text format</source>
          <target state="translated">감사 로그는 일반 텍스트 형식으로 파일에 필드 목록으로 작성된 레코드 세트입니다.</target>
        </trans-unit>
        <trans-unit id="ce61dea47ee964dc87b04c6d7ebd88a3f198a4ce" translate="yes" xml:space="preserve">
          <source>The audit plugin logs user access to MariaDB and its objects. The audit trail (i.e., audit log) is a set of records, written as a list of fields to a file in a plain‐text format. The fields in the log are separated by commas. The format used for the plugin's own log file is slightly different from the format used if it logs to the system log because it has its own standard format. The general format for the logging to the plugin's own file is defined like the following:</source>
          <target state="translated">감사 플러그인은 MariaDB 및 해당 개체에 대한 사용자 액세스를 기록합니다. 감사 내역 (예 : 감사 로그)은 필드 목록으로 일반 텍스트 형식으로 파일에 기록되는 레코드 집합입니다. 로그의 필드는 쉼표로 구분됩니다. 플러그인 자체 로그 파일에 사용되는 형식은 자체 표준 형식을 가지고 있기 때문에 시스템 로그에 로그하는 경우 사용되는 형식과 약간 다릅니다. 플러그인 자체 파일에 로깅하는 일반적인 형식은 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="11934b971df5973a4acc4a86109ee0e0ebf381cf" translate="yes" xml:space="preserve">
          <source>The authentication of users is delegated to plugins.</source>
          <target state="translated">사용자 인증은 플러그인에 위임됩니다.</target>
        </trans-unit>
        <trans-unit id="77a9fd1eac5207347b641f3359d45607e43a170a" translate="yes" xml:space="preserve">
          <source>The authentication options for the &lt;code&gt;GRANT&lt;/code&gt; statement are the same as those for the &lt;code&gt;&lt;a href=&quot;../create-user/index&quot;&gt;CREATE USER&lt;/a&gt;&lt;/code&gt; statement.</source>
          <target state="translated">&lt;code&gt;GRANT&lt;/code&gt; 문의 인증 옵션 은 &lt;code&gt;&lt;a href=&quot;../create-user/index&quot;&gt;CREATE USER&lt;/a&gt;&lt;/code&gt; 문의 인증 옵션 과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="8f84e1e157546fb7d9b967b98557a5baedf2b066" translate="yes" xml:space="preserve">
          <source>The authentication plugin API is extensively documented in the &lt;a href=&quot;../getting-the-mariadb-source-code/index&quot;&gt;source code&lt;/a&gt; in the following files:</source>
          <target state="translated">인증 플러그인 API는 다음 파일 의 &lt;a href=&quot;../getting-the-mariadb-source-code/index&quot;&gt;소스 코드&lt;/a&gt; 에 광범위하게 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="48c5857102272f5b376cf039cf6bfac5c276c07b" translate="yes" xml:space="preserve">
          <source>The authentication process is a conversation between the server and a client. MariaDB implements both server-side and client-side authentication plugins.</source>
          <target state="translated">인증 프로세스는 서버와 클라이언트 간의 대화입니다. MariaDB는 서버 측 및 클라이언트 측 인증 플러그인을 모두 구현합니다.</target>
        </trans-unit>
        <trans-unit id="e95bad08aa5ca18f668772c0028fbe836a2b7aca" translate="yes" xml:space="preserve">
          <source>The availability status for the column which is either &quot;Available&quot;, &quot;Unavailable&quot; or &quot;Out of service&quot;</source>
          <target state="translated">&quot;사용 가능&quot;, &quot;사용 불가능&quot;또는 &quot;서비스 불가능&quot;인 열의 사용 가능 상태</target>
        </trans-unit>
        <trans-unit id="cb51feff259a2798ef259e2b2be9ad77e1d69213" translate="yes" xml:space="preserve">
          <source>The available DEB packages depend on the specific MariaDB release series.</source>
          <target state="translated">사용 가능한 DEB 패키지는 특정 MariaDB 릴리스 시리즈에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="dabfb6dc90e3bb8264ccb065cdd2375e5a9c3a1a" translate="yes" xml:space="preserve">
          <source>The available RPM packages depend on the specific MariaDB release series.</source>
          <target state="translated">사용 가능한 RPM 패키지는 특정 MariaDB 릴리스 시리즈에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="815500618796f81e034d79b1a56331e3d3f36026" translate="yes" xml:space="preserve">
          <source>The available table `Presidents` looks like:</source>
          <target state="translated">사용 가능한 테이블`Presidents`는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="793cbfec5b31ad128554c6d21c441eb19a4d613a" translate="yes" xml:space="preserve">
          <source>The available wrappers are:</source>
          <target state="translated">사용 가능한 랩퍼는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e648affec42a04226da9ee8faa56cea857ad7e69" translate="yes" xml:space="preserve">
          <source>The average of all input values.</source>
          <target state="translated">모든 입력 값의 평균입니다.</target>
        </trans-unit>
        <trans-unit id="3f7d6a2f352b3db898cadaf5c78074222f8f9216" translate="yes" xml:space="preserve">
          <source>The background script would round the count off.</source>
          <target state="translated">백그라운드 스크립트는 카운트를 반올림합니다.</target>
        </trans-unit>
        <trans-unit id="4410f08f3311d6df1f0f5e77eb8932d40b10aa83" translate="yes" xml:space="preserve">
          <source>The backtick character can be used as part of an identifier. In that case the identifier needs to be quoted. The quote character can be the backtick, but in that case, the backtick in the name must be escaped with another backtick.</source>
          <target state="translated">백틱 문자는 식별자의 일부로 사용할 수 있습니다. 이 경우 식별자를 인용해야합니다. 따옴표 문자는 백틱이 될 수 있지만이 경우 이름의 백틱은 다른 백틱으로 이스케이프되어야합니다.</target>
        </trans-unit>
        <trans-unit id="58946d3e0dee039b5be858683263dfee7b2fab43" translate="yes" xml:space="preserve">
          <source>The backup fails if the &lt;code&gt;Slave_open_temp_tables&lt;/code&gt; doesn't reach zero after the timeout period set by the &lt;code&gt;&lt;a href=&quot;#-safe-slave-backup-timeout&quot;&gt;--safe-slave-backup-timeout&lt;/a&gt;&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#-safe-slave-backup-timeout&quot;&gt;--safe-slave-backup-timeout&lt;/a&gt;&lt;/code&gt; 옵션으로 설정된 시간 초과 기간 후에 &lt;code&gt;Slave_open_temp_tables&lt;/code&gt; 가 0에 도달하지 않으면 백업이 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="0bbbd334a7e0c2bb8f7fd63ae5d27835e1ddfd44" translate="yes" xml:space="preserve">
          <source>The backup for each table consists of its .frm format file and .MYD data file. The restore operation restores those files, and then uses them to rebuild the .MYI index file. Restoring takes longer than backing up due to the need to rebuild the indexes. The more indexes the table has, the longer it takes.</source>
          <target state="translated">각 테이블의 백업은 .frm 형식 파일과 .MYD 데이터 파일로 구성됩니다. 복원 작업은 해당 파일을 복원 한 다음이를 사용하여 .MYI 색인 파일을 다시 작성합니다. 인덱스를 다시 작성해야하므로 복원하는 데 백업 시간보다 오래 걸립니다. 테이블에 인덱스가 많을수록 시간이 오래 걸립니다.</target>
        </trans-unit>
        <trans-unit id="22e78eed196546eda3533bc3f73d52b663694b32" translate="yes" xml:space="preserve">
          <source>The backup utility mysqldump produces backup files containing the SQL statements needed to recreate the database. As a result, it restores a database with the bare minimum data rather than any additional information that might have built up in the tablespace file.</source>
          <target state="translated">백업 유틸리티 mysqldump는 데이터베이스를 재생성하는 데 필요한 SQL 문이 포함 된 백업 파일을 생성합니다. 결과적으로 테이블 스페이스 파일에 구축 된 추가 정보가 아닌 최소 데이터로 데이터베이스를 복원합니다.</target>
        </trans-unit>
        <trans-unit id="97f06310e2cd847412aaf0b1ae501304d4c61dd5" translate="yes" xml:space="preserve">
          <source>The bad news is that if it works all right for some previous versions of the MySQL driver, it does not work for new versions as well as for the MariaDB driver that apparently ignores the cancel command. The good news is that you can use an old MySQL driver to access MariaDB databases. It is also possible that this bug will be fixed in future versions of the drivers.</source>
          <target state="translated">나쁜 소식은 일부 이전 버전의 MySQL 드라이버에서 제대로 작동하면 cancel 명령을 무시하는 MariaDB 드라이버뿐만 아니라 새 버전에서도 작동하지 않는다는 것입니다. 좋은 소식은 오래된 MySQL 드라이버를 사용하여 MariaDB 데이터베이스에 액세스 할 수 있다는 것입니다. 이 버그는 향후 버전의 드라이버에서 수정 될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="47006af6608c78a65c232846f7790c230f8aec6f" translate="yes" xml:space="preserve">
          <source>The base C++ part needed to execute programs</source>
          <target state="translated">프로그램을 실행하는 데 필요한 기본 C ++ 부분</target>
        </trans-unit>
        <trans-unit id="c771e9647b61f8c2594c99ddece672fb3e1faa2a" translate="yes" xml:space="preserve">
          <source>The base Geometry class has subclasses for Point, Curve, Surface and GeometryCollection</source>
          <target state="translated">기본 Geometry 클래스에는 Point, Curve, Surface 및 GeometryCollection에 대한 서브 클래스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce61630956707d1776bbb7fea9d7852c8da5609a" translate="yes" xml:space="preserve">
          <source>The base Geometry class has subclasses for Point, Curve, Surface, and GeometryCollection:</source>
          <target state="translated">기본 Geometry 클래스에는 Point, Curve, Surface 및 GeometryCollection에 대한 하위 클래스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f921da8ab5830400260ccffedc183cf54c238ed" translate="yes" xml:space="preserve">
          <source>The base class</source>
          <target state="translated">기본 수업</target>
        </trans-unit>
        <trans-unit id="c67a60d21e82e98b78af95a06bde849b4c325a26" translate="yes" xml:space="preserve">
          <source>The base directory for the server.</source>
          <target state="translated">서버의 기본 디렉토리입니다.</target>
        </trans-unit>
        <trans-unit id="c3490cc7f48e4ba38346fbe81ac5167a7403c5ae" translate="yes" xml:space="preserve">
          <source>The basic Vagrant setup can be found at &lt;a href=&quot;https://github.com/mariadb-corporation/mariadb-columnstore-vagrant&quot;&gt;GitHub&lt;/a&gt;. Clone this repository and follow the Readme.md instructions.</source>
          <target state="translated">기본 Vagrant 설정은 &lt;a href=&quot;https://github.com/mariadb-corporation/mariadb-columnstore-vagrant&quot;&gt;GitHub&lt;/a&gt; 에서 찾을 수 있습니다 . 이 저장소를 복제하고 Readme.md 지침을 따르십시오.</target>
        </trans-unit>
        <trans-unit id="b0498852b0b485b15efa6904878d6260c0050fac" translate="yes" xml:space="preserve">
          <source>The basic difference between synchronous and asynchronous replication is that &quot;synchronous&quot; replication guarantees that if a change happened on one node in the cluster, then the change will happen on other nodes in the cluster &quot;synchronously&quot;, or at the same time. &quot;Asynchronous&quot; replication gives no guarantees about the delay between applying changes on &quot;master&quot; node and the propagation of changes to &quot;slave&quot; nodes. The delay with &quot;asynchronous&quot; replication can be short or long. This also implies that if master node crashes in an &quot;asynchronous&quot; replication topology, then some of the latest changes may be lost.</source>
          <target state="translated">동기 복제와 비동기 복제의 기본 차이점은 &quot;동기&quot;복제는 클러스터의 한 노드에서 변경이 발생하면 클러스터의 다른 노드에서 &quot;동기&quot;로 또는 동시에 변경이 발생한다는 것을 보장한다는 것입니다. &quot;비동기&quot;복제는 &quot;마스터&quot;노드에 변경 사항을 적용하는 것과 &quot;슬레이브&quot;노드에 변경 사항을 전파하는 것 사이의 지연에 대해 보증하지 않습니다. &quot;비동기&quot;복제의 지연은 짧거나 길 수 있습니다. 이는 마스터 노드가 &quot;비동기식&quot;복제 토폴로지에서 충돌하는 경우 최신 변경 사항 중 일부가 손실 될 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="4d74defc92695d086b8821e1a2fd58d6f5b0e2da" translate="yes" xml:space="preserve">
          <source>The basic functionality of how FederatedX works is:</source>
          <target state="translated">FederatedX 작동 방식의 기본 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="633de737417ede64b184394ea0b18637468ea405" translate="yes" xml:space="preserve">
          <source>The basic geometry type is &lt;code&gt;GEOMETRY&lt;/code&gt;. But the type can be more specific. The following types are supported:</source>
          <target state="translated">기본 지오메트리 유형은 &lt;code&gt;GEOMETRY&lt;/code&gt; 입니다. 그러나 유형이 더 구체적 일 수 있습니다. 다음 유형이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="f539185da69e9028d322662cdbcb36ccabd3b428" translate="yes" xml:space="preserve">
          <source>The basic idea behind table elimination is that sometimes it is possible to resolve a query without even accessing some of the tables that the query refers to. One can invent many kinds of such cases, but in Table Elimination we targeted only a certain class of SQL constructs that one ends up writing when they are querying &lt;a href=&quot;../database-normalization/index&quot;&gt;highly-normalized&lt;/a&gt; data.</source>
          <target state="translated">테이블 제거의 기본 개념은 때때로 쿼리가 참조하는 일부 테이블에 액세스하지 않고도 쿼리를 해결할 수 있다는 것입니다. 이러한 경우를 여러 가지 발명 할 수 있지만 테이블 제거에서는 &lt;a href=&quot;../database-normalization/index&quot;&gt;정규화 된&lt;/a&gt; 데이터를 쿼리 할 때 작성하는 특정 SQL 구문 클래스 만 대상으로했습니다 .</target>
        </trans-unit>
        <trans-unit id="5de8909745495bf6fe769ca2b344807ffcab62ea" translate="yes" xml:space="preserve">
          <source>The basic idea behind table elimination is that sometimes it is possible to...</source>
          <target state="translated">테이블 제거의 기본 아이디어는 때때로 가능하다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="92bcafa124f6fc91f15e52fb5d6189b407be69d7" translate="yes" xml:space="preserve">
          <source>The basic idea of subquery materialization is to execute the subquery and store its result in an internal temporary table indexed on all its columns. Naturally, this is possible only when the subquery is non-correlated. The IN predicate tests whether its left operand is present in the subquery result. Therefore it is not necessary to store duplicate subquery result rows in the temporary table. Storing only unique subquery rows provides two benefits - the size of the temporary table is smaller, and the index on all its columns can be unique.</source>
          <target state="translated">하위 쿼리 구체화의 기본 아이디어는 하위 쿼리를 실행하고 결과를 모든 열에서 인덱스 된 내부 임시 테이블에 저장하는 것입니다. 당연히 이것은 하위 쿼리가 상관되지 않은 경우에만 가능합니다. IN 술어는 왼쪽 피연산자가 서브 쿼리 결과에 있는지 여부를 테스트합니다. 따라서 임시 테이블에 중복 하위 쿼리 결과 행을 저장할 필요가 없습니다. 고유 한 하위 쿼리 행만 저장하면 두 가지 이점이 있습니다. 임시 테이블의 크기가 더 작고 모든 열의 인덱스가 고유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef890164bcc5d3d5f6e0f7907602274f986e03c8" translate="yes" xml:space="preserve">
          <source>The basic principle of the new files used by multi source replication is that they have the same name as the original relay log files suffixed with &lt;code&gt;connection_name&lt;/code&gt; before the extension. The main exception is the file that holds all connection is named as the normal &lt;code&gt;master-info-file&lt;/code&gt; with a &lt;code&gt;multi-&lt;/code&gt; prefix.</source>
          <target state="translated">다중 소스 복제에 사용되는 새 파일의 기본 원칙은 확장명 앞에 &lt;code&gt;connection_name&lt;/code&gt; 접미사가 붙은 원래 릴레이 로그 파일과 이름이 동일하다는 것 입니다. 주요 예외는 모든 연결을 유지하는 파일이 &lt;code&gt;multi-&lt;/code&gt; 접두사를 가진 일반 &lt;code&gt;master-info-file&lt;/code&gt; 로 명명 된 것 입니다.</target>
        </trans-unit>
        <trans-unit id="b1ac96163d9afa876d82add2c3c3139f23627945" translate="yes" xml:space="preserve">
          <source>The basic steps to using these SQL tracing stored functions are:</source>
          <target state="translated">이러한 SQL 추적 저장 함수를 사용하는 기본 단계는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b55b47763b3498da9eb3cb74acb7fa69a118d0a2" translate="yes" xml:space="preserve">
          <source>The basic terminology (&quot;Fact Table&quot;, &quot;&lt;a href=&quot;../database-normalization/index&quot;&gt;Normalization&lt;/a&gt;&quot;, etc) is covered in that document.</source>
          <target state="translated">기본 용어 ( &quot;팩트 테이블&quot;, &quot; &lt;a href=&quot;../database-normalization/index&quot;&gt;정규화&lt;/a&gt; &quot;등)는 해당 문서에서 다룹니다.</target>
        </trans-unit>
        <trans-unit id="d90a07d8238b4ac6f9814d22bdbf60e1d066dfee" translate="yes" xml:space="preserve">
          <source>The behavior of this function depends on the value of the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#old_passwords&quot;&gt;old_passwords&lt;/a&gt;&lt;/code&gt; system variable.</source>
          <target state="translated">이 함수의 동작은 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#old_passwords&quot;&gt;old_passwords&lt;/a&gt;&lt;/code&gt; 시스템 변수 의 값에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="9c18f1d2e6a0a704bab1fb8f27fbecf20f169429" translate="yes" xml:space="preserve">
          <source>The behaviour of &lt;code&gt;OPTIMIZE TABLE&lt;/code&gt; is unchanged by default, and to enable this new feature, you need to set the &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_defragment&quot;&gt;innodb_defragment&lt;/a&gt; system variable to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;OPTIMIZE TABLE&lt;/code&gt; 의 동작은 기본적으로 변경되지 않으며이 새로운 기능을 사용하려면 &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_defragment&quot;&gt;innodb_defragment&lt;/a&gt; 시스템 변수를 &lt;code&gt;1&lt;/code&gt; 로 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="178af92b9b255a34934599774b27f63703b86c5d" translate="yes" xml:space="preserve">
          <source>The benefit is expected to be bigger for io-bound loads.</source>
          <target state="translated">io-bound 부하의 경우 이점이 더 커질 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="533da698a60d7295dd854543088e2dadecc2853d" translate="yes" xml:space="preserve">
          <source>The benefit of mysqlreport is that it allows you to very quickly see a wide array of performance indicators for your MariaDB server which would otherwise need to be calculated by hand from all the various SHOW STATUS values. For example, the Index Read Ratio is an important value but it's not present in SHOW STATUS; it's an inferred value (the ratio of Key_reads to Key_read_requests).</source>
          <target state="translated">mysqlreport의 장점은 MariaDB 서버에 대한 다양한 성능 표시기를 매우 빠르게 볼 수 있다는 것입니다. 그렇지 않으면 모든 다양한 SHOW STATUS 값에서 직접 계산해야합니다. 예를 들어, 인덱스 읽기 비율은 중요한 값이지만 SHOW STATUS에는 없습니다. 추론 된 값 (Key_reads와 Key_read_requests의 비율)입니다.</target>
        </trans-unit>
        <trans-unit id="b4e8eeb101c316ffdd8cbbee3a344b3c876498cb" translate="yes" xml:space="preserve">
          <source>The benefit of using &lt;code&gt;IGNORE_INDEX&lt;/code&gt; instead of &lt;code&gt;USE_INDEX&lt;/code&gt; is that it will not disable a new index which you may add later.</source>
          <target state="translated">사용의 장점 &lt;code&gt;IGNORE_INDEX&lt;/code&gt; 대신 &lt;code&gt;USE_INDEX&lt;/code&gt; 은 당신이 나중에 추가 할 수있는 새로운 인덱스를 사용하지 않도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="fb85b2242485f9d062cd3eef20103a1d6bfaf7ea" translate="yes" xml:space="preserve">
          <source>The benefit of using IGNORE_INDEX instead of &lt;a href=&quot;../use-index/index&quot;&gt;USE_INDEX&lt;/a&gt; is that it will not disable a new index which you may add later.</source>
          <target state="translated">대신 IGNORE_INDEX 사용의 장점 &lt;a href=&quot;../use-index/index&quot;&gt;USE_INDEX은&lt;/a&gt; 당신이 나중에 추가 할 수있는 새로운 인덱스를 사용하지 않도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="4f329093d339d852d05f087ec1d0811e9216bcd5" translate="yes" xml:space="preserve">
          <source>The benefits will be similar to those listed for &lt;code&gt;range&lt;/code&gt; access.</source>
          <target state="translated">이점은 &lt;code&gt;range&lt;/code&gt; 액세스 에 대해 나열된 이점과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="f072dd1f5ba8ccaf2c620f1852301ff754e870ac" translate="yes" xml:space="preserve">
          <source>The best solution is probably to do it in some form of client code (PHP, etc). MySQL and MariaDB do not have a syntax for SELECT that will do the work for you. The code provided here uses a &lt;a href=&quot;../stored-procedures/index&quot;&gt;stored procedure&lt;/a&gt; to generate code to pivot the data, and then runs the code.</source>
          <target state="translated">가장 좋은 해결책은 아마도 어떤 형태의 클라이언트 코드 (PHP 등)로 수행하는 것입니다. MySQL과 MariaDB에는 당신을 위해 일할 SELECT 구문이 없습니다. 여기에 제공된 코드는 &lt;a href=&quot;../stored-procedures/index&quot;&gt;저장 프로 시저&lt;/a&gt; 를 사용 하여 데이터를 피벗하는 코드를 생성 한 다음 코드를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="3a6c36962626c907720eb488e8a4695eea4687e0" translate="yes" xml:space="preserve">
          <source>The best way to drop all tables in a database is by executing &lt;code&gt;&lt;a href=&quot;../drop-database/index&quot;&gt;DROP DATABASE&lt;/a&gt;&lt;/code&gt;, which will drop the database itself, and all tables in it.</source>
          <target state="translated">데이터베이스에서 모든 테이블을 삭제하는 가장 좋은 방법은 &lt;code&gt;&lt;a href=&quot;../drop-database/index&quot;&gt;DROP DATABASE&lt;/a&gt;&lt;/code&gt; 를 실행 하여 데이터베이스 자체와 데이터베이스의 모든 테이블을 삭제하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="dfd89306003a5683579aed8c47eeec0fe71ec695" translate="yes" xml:space="preserve">
          <source>The big goal is to minimize the disk hits. Let's itemize how few disk hits are needed. When finding the latest articles with 'normal' code, you will probably find that it is doing significant scans of the Articles table, failing to quickly home in on the 10 rows you want. With this design, there is only one extra disk hit:</source>
          <target state="translated">가장 큰 목표는 디스크 적중을 최소화하는 것입니다. 필요한 디스크 적중 횟수를 항목별로 정리해 보겠습니다. '보통'코드가있는 최신 기사를 찾을 때 기사 테이블을 많이 스캔하여 원하는 10 개 행으로 빠르게 이동하지 못하는 것을 알 수 있습니다. 이 디자인에서는 추가 디스크 히트가 하나만 있습니다.</target>
        </trans-unit>
        <trans-unit id="7371c5f6bbbcae653dd563e07911cbba37d259b7" translate="yes" xml:space="preserve">
          <source>The big win for Case #1: DROP PARTITION is a lot faster than DELETEing a lot of rows.</source>
          <target state="translated">사례 # 1 : DROP PARTITION의 큰 승리는 많은 행을 삭제하는 것보다 훨씬 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="fe2cbe6a1d5ecca5efb590cb8df11e497cdfb265" translate="yes" xml:space="preserve">
          <source>The big win for Case #2: Scanning fewer rows.</source>
          <target state="translated">사례 # 2의 가장 큰 승리 : 적은 행 스캔.</target>
        </trans-unit>
        <trans-unit id="b978551b2a8db1c634bfe1d0410ea591ccd0b36b" translate="yes" xml:space="preserve">
          <source>The big win for Case #3: Improving caching to decrease I/O to speed up operations.</source>
          <target state="translated">사례 # 3의 큰 승리 : 작업 속도를 높이기 위해 I / O를 줄이기위한 캐싱 개선.</target>
        </trans-unit>
        <trans-unit id="a86b41e500fcaf48410ef64f03c09d25c79d8b3c" translate="yes" xml:space="preserve">
          <source>The big win for Case #4: Quickly moving a partition in between tables (or servers).</source>
          <target state="translated">사례 # 4의 큰 승리 : 테이블 (또는 서버)간에 파티션을 빠르게 이동합니다.</target>
        </trans-unit>
        <trans-unit id="349534e00ad3de3df3f249bc9aebd792d684b039" translate="yes" xml:space="preserve">
          <source>The binaries in MariaDB Corporation's &lt;strong&gt;MariaDB Repository&lt;/strong&gt; are currently identical to the binaries in MariaDB Foundation's MariaDB Repository that is configured with the &lt;a href=&quot;https://downloads.mariadb.org/mariadb/repositories/&quot;&gt;MariaDB Repository Configuration Tool&lt;/a&gt;.</source>
          <target state="translated">MariaDB Corporation &lt;strong&gt;MariaDB 리포지토리&lt;/strong&gt; 의 바이너리는 현재 &lt;a href=&quot;https://downloads.mariadb.org/mariadb/repositories/&quot;&gt;MariaDB 리포지토리 구성 도구로&lt;/a&gt; 구성된 MariaDB Foundation MariaDB 리포지토리의 바이너리와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="ec21d0632657685e63dc1693b0ea0e6ec8aad68d" translate="yes" xml:space="preserve">
          <source>The binary hybrid live iso images with multiple-choices inside the boot menu allow for the assignment of two different IPs. (e.g. for testing of clustered database operations)</source>
          <target state="translated">부팅 메뉴에 다중 선택 항목이있는 이진 하이브리드 라이브 ISO 이미지를 사용하면 서로 다른 두 가지 IP를 할당 할 수 있습니다. (예 : 클러스터 데이터베이스 운영 테스트)</target>
        </trans-unit>
        <trans-unit id="a81ecf176093fc24ee7ec0ce1cbf99a2c2628a22" translate="yes" xml:space="preserve">
          <source>The binary is compiled for debugging and optimized to be used with &lt;a href=&quot;http://www.valgrind.org/&quot;&gt;valgrind&lt;/a&gt;.</source>
          <target state="translated">바이너리는 디버깅을 위해 컴파일되고 &lt;a href=&quot;http://www.valgrind.org/&quot;&gt;valgrind&lt;/a&gt; 와 함께 사용하도록 최적화됩니다 .</target>
        </trans-unit>
        <trans-unit id="4663162a221ca34ac75ee453e492068fdc3138ca" translate="yes" xml:space="preserve">
          <source>The binary is compiled with all symbols (gcc -g) and the &lt;code&gt;&lt;a href=&quot;../creating-a-trace-file/index&quot;&gt;DBUG&lt;/a&gt;&lt;/code&gt; log system is enabled.</source>
          <target state="translated">바이너리는 모든 기호 (gcc -g)로 컴파일되고 &lt;code&gt;&lt;a href=&quot;../creating-a-trace-file/index&quot;&gt;DBUG&lt;/a&gt;&lt;/code&gt; 로그 시스템이 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="9e30b5170bb7e32fae352892cec9b3894a7dfb69" translate="yes" xml:space="preserve">
          <source>The binary log</source>
          <target state="translated">이진 로그</target>
        </trans-unit>
        <trans-unit id="20d216855617eba3e69ebc47811c9594b42d01b2" translate="yes" xml:space="preserve">
          <source>The binary log contains a record of all changes to the databases</source>
          <target state="translated">이진 로그에는 데이터베이스에 대한 모든 변경 사항이 기록되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf22a227d7c80dfee73fcc76fc117f8f1ebec754" translate="yes" xml:space="preserve">
          <source>The binary log contains a record of all changes to the databases, both data and structure, as well as how long each statement took to execute. It consists of a set of binary log files and an index.</source>
          <target state="translated">이진 로그에는 데이터베이스에 대한 모든 변경 사항 (데이터 및 구조)과 각 명령문 실행 시간이 기록되어 있습니다. 이진 로그 파일 집합과 인덱스로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="1107eee380de2178a535f0e193bf7ed1ab6806b4" translate="yes" xml:space="preserve">
          <source>The binary log contains a record of all changes to the databases, both data and structure. It consists of a set of binary log files and an index.</source>
          <target state="translated">이진 로그에는 데이터베이스의 모든 변경 사항 (데이터 및 구조)에 대한 기록이 포함됩니다. 이진 로그 파일 집합과 인덱스로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="f8891fc74c0e1473297d174c28693fbdfa79aaa8" translate="yes" xml:space="preserve">
          <source>The binary log dump thread runs on the master and dumps the &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt; to the slave. This thread can be identified by running the &lt;code&gt;&lt;a href=&quot;../show-processlist/index&quot;&gt;SHOW PROCESSLIST&lt;/a&gt;&lt;/code&gt; statement and finding the thread where the &lt;a href=&quot;../thread-command-values/index&quot;&gt;thread command&lt;/a&gt; is &lt;code&gt;&quot;Binlog Dump&quot;&lt;/code&gt;.</source>
          <target state="translated">이진 로그 덤프 스레드는 마스터에서 실행되고 &lt;a href=&quot;../binary-log/index&quot;&gt;이진 로그&lt;/a&gt; 를 슬레이브에 덤프합니다 . 이 스레드는 &lt;code&gt;&lt;a href=&quot;../show-processlist/index&quot;&gt;SHOW PROCESSLIST&lt;/a&gt;&lt;/code&gt; 문 을 실행 하고 &lt;a href=&quot;../thread-command-values/index&quot;&gt;스레드 명령&lt;/a&gt; 이 &lt;code&gt;&quot;Binlog Dump&quot;&lt;/code&gt; 인스레드를 찾아서 식별 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="86c7dbb639f85da1e6ef2ba54849fec24d29fd1d" translate="yes" xml:space="preserve">
          <source>The binary log file '%s' is logically corrupted: %s</source>
          <target state="translated">이진 로그 파일 '% s'이 (가) 논리적으로 손상되었습니다 : % s</target>
        </trans-unit>
        <trans-unit id="525b96d681edfbf67302ca99e2fa273f2502b95f" translate="yes" xml:space="preserve">
          <source>The binary log files will have a series of numbers as filename extensions. Each additional binary log will increment the extension number, so the oldest binary logs will have lower numbers, the most recent, higher numbers.</source>
          <target state="translated">이진 로그 파일은 파일 이름 확장자로 일련의 숫자를 갖습니다. 각 추가 이진 로그는 내선 번호를 증가 시키므로 가장 오래된 이진 로그는 더 낮은 숫자, 가장 최근의 높은 숫자를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="014301def100847c7f5211fe8c6404a6dd110242" translate="yes" xml:space="preserve">
          <source>The binary log index file contains a master list of all the binary logs, in order.</source>
          <target state="translated">이진 로그 색인 파일에는 모든 이진 로그의 마스터 목록이 순서대로 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="82466abe58f0fcd92ad4ef606cdacc9cfc0213b6" translate="yes" xml:space="preserve">
          <source>The binary log index file will by default have the same name as the individual binary logs, with the extension .index. You can specify an alternative name with the &lt;code&gt;--log-bin-index[=filename]&lt;/code&gt;&lt;a href=&quot;../mysqld-options-full-list/index&quot;&gt;option&lt;/a&gt;.</source>
          <target state="translated">이진 로그 인덱스 파일은 기본적으로 확장자가 .index 인 개별 이진 로그와 이름이 동일합니다. &lt;code&gt;--log-bin-index[=filename]&lt;/code&gt; &lt;a href=&quot;../mysqld-options-full-list/index&quot;&gt;옵션으로&lt;/a&gt; 대체 이름을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e599203f78cb96928b035ebffb3af8ec42b9741a" translate="yes" xml:space="preserve">
          <source>The binary that provides the UDF is named sphinx.so and is automatically built and installed to the proper location along with SphinxSE itself. Register the UDF using the following statement:</source>
          <target state="translated">UDF를 제공하는 바이너리 이름은 sphinx.so이며 SphinxSE 자체와 함께 적절한 위치에 자동으로 빌드되어 설치됩니다. 다음 명령문을 사용하여 UDF를 등록하십시오.</target>
        </trans-unit>
        <trans-unit id="a1e2c7cc5b4da59cb3a832da55583f2059d34f9c" translate="yes" xml:space="preserve">
          <source>The binlog event type &lt;code&gt;Annotate_rows_log_event&lt;/code&gt; was introduced in &lt;a href=&quot;../what-is-mariadb-53/index&quot;&gt;MariaDB 5.3&lt;/a&gt;. Until &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1024-release-notes/&quot;&gt;MariaDB 10.2.4&lt;/a&gt;, it was off by default (so as not to change the binary log format and to allow one to replicate &lt;a href=&quot;../what-is-mariadb-53/index&quot;&gt;MariaDB 5.3&lt;/a&gt; to MySQL/&lt;a href=&quot;../what-is-mariadb-51/index&quot;&gt;MariaDB 5.1&lt;/a&gt;). You can enable this with &lt;code&gt;&lt;a href=&quot;#master-option-binlog-annotate-row-events&quot;&gt;--binlog-annotate-row-events&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">binlog 이벤트 유형 &lt;code&gt;Annotate_rows_log_event&lt;/code&gt; 가 &lt;a href=&quot;../what-is-mariadb-53/index&quot;&gt;MariaDB 5.3&lt;/a&gt; 에서 도입되었습니다 . &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1024-release-notes/&quot;&gt;MariaDB 10.2.4&lt;/a&gt; 까지는 바이너리 로그 형식을 변경하지 않고 &lt;a href=&quot;../what-is-mariadb-53/index&quot;&gt;MariaDB 5.3&lt;/a&gt; 을 MySQL / &lt;a href=&quot;../what-is-mariadb-51/index&quot;&gt;MariaDB 5.1&lt;/a&gt; 에 복제 할 수 있도록 기본적으로 꺼져있었습니다 . &lt;code&gt;&lt;a href=&quot;#master-option-binlog-annotate-row-events&quot;&gt;--binlog-annotate-row-events&lt;/a&gt;&lt;/code&gt; 로이를 활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b2f9c469978f199ab0ddb45873a4d9c3fb9bc676" translate="yes" xml:space="preserve">
          <source>The binlog on the master is missing the GTID %u-%u-%llu requested by the slave (even though a subsequent sequence number does exist), and GTID strict mode is enabled</source>
          <target state="translated">마스터의 binlog에 슬레이브가 요청한 GTID % u- % u- % llu가없고 (다음 시퀀스 번호가 존재하더라도) GTID 엄격 모드가 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="b4a0fb340b0d5c09a3e5320eab31feb07570a559" translate="yes" xml:space="preserve">
          <source>The block index files are faster to make and much smaller than standard index files.</source>
          <target state="translated">블록 인덱스 파일은 표준 인덱스 파일보다 더 빠르며 훨씬 작습니다.</target>
        </trans-unit>
        <trans-unit id="482f15aa69982b1fa8c778313838bef300f930e9" translate="yes" xml:space="preserve">
          <source>The block offset for the data file, each data file can contain multiple extents for a column</source>
          <target state="translated">데이터 파일의 블록 오프셋, 각 데이터 파일은 열에 대한 여러 범위를 포함 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="eaccc836f15874580768c174e7dbca530dad97c9" translate="yes" xml:space="preserve">
          <source>The buffer pool attempts to keep frequently-used blocks in the buffer, and so essentially works as two sublists, a &lt;em&gt;new&lt;/em&gt; sublist of recently-used information, and an &lt;em&gt;old&lt;/em&gt; sublist of older information. By default, 37% of the list is reserved for the old list.</source>
          <target state="translated">버퍼 풀의 시도는 버퍼에 자주 사용되는 블록을 유지하고, 그래서 기본적으로 두 개의 하위 목록하는로 작동하는 &lt;em&gt;새로운&lt;/em&gt; 최근에 사용되는 정보의 하위 목록 및 &lt;em&gt;오래된&lt;/em&gt; 오래된 정보의 하위 목록. 기본적으로 목록의 37 %는 이전 목록 용으로 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b15bacbc28b4fc9451ec6d50eb192d0eb1c94167" translate="yes" xml:space="preserve">
          <source>The buffer pool can be dumped and restored since &lt;a href=&quot;../what-is-mariadb-100/index&quot;&gt;MariaDB 10.0&lt;/a&gt;.</source>
          <target state="translated">버퍼 풀은 &lt;a href=&quot;../what-is-mariadb-100/index&quot;&gt;MariaDB 10.0&lt;/a&gt; 이후 덤프 및 복원 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="15cc0dc9a662531b49b93394c75597831ba492fd" translate="yes" xml:space="preserve">
          <source>The buffer refills and scans of the second operand that look for matches in the join buffer are performed again and again until the records of first operand are exhausted.</source>
          <target state="translated">결합 버퍼에서 일치를 찾는 두 번째 피연산자의 버퍼 리필 및 스캔은 첫 번째 피연산자의 레코드가 소진 될 때까지 반복해서 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="bc1226cc7b216255534f7448ea17e0a0a64debb9" translate="yes" xml:space="preserve">
          <source>The buffer size for TCP/IP and socket communication.</source>
          <target state="translated">TCP / IP 및 소켓 통신의 버퍼 크기입니다.</target>
        </trans-unit>
        <trans-unit id="52bc28baf311efaf3c7d0f42abfc686d89c8446b" translate="yes" xml:space="preserve">
          <source>The buffer size for TCP/IP and socket communication. Default is 16KB.</source>
          <target state="translated">TCP / IP 및 소켓 통신의 버퍼 크기입니다. 기본값은 16KB입니다.</target>
        </trans-unit>
        <trans-unit id="5729a75b1c90322c0e68caba73448c7a18dfd604" translate="yes" xml:space="preserve">
          <source>The build process is as follows</source>
          <target state="translated">빌드 과정은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="d23303e67aababd4bb15b113fe7e1a4cac501a24" translate="yes" xml:space="preserve">
          <source>The build process is not fully streamlined yet. It is</source>
          <target state="translated">빌드 프로세스가 아직 간소화되지 않았습니다. 그것은</target>
        </trans-unit>
        <trans-unit id="4aa264d539dac8a78be5b828eb21124261d32af6" translate="yes" xml:space="preserve">
          <source>The bulk loads are an append operation to a table so they allow existing data to be read and remain unaffected during the process.</source>
          <target state="translated">벌크로드는 테이블에 추가 작업이므로 기존 데이터를 읽고 처리하는 동안 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b7567ee9f9c50c4b4c3410106ef27d2ded8967df" translate="yes" xml:space="preserve">
          <source>The bulk loads do not write their data operations to the transaction log; they are not transactional in nature but are considered an atomic operation at this time. Information markers, however, are placed in the transaction log so the DBA is aware that a bulk operation did occur.</source>
          <target state="translated">벌크로드는 데이터 작업을 트랜잭션 로그에 쓰지 않습니다. 그것들은 본질적으로 거래 적이 지 않지만 현재 원자 연산으로 간주됩니다. 그러나 정보 표시자는 트랜잭션 로그에 배치되므로 DBA는 대량 작업이 발생했음을 인식합니다.</target>
        </trans-unit>
        <trans-unit id="21c95a513d69ba90eda45a9b1855d87045d9baa1" translate="yes" xml:space="preserve">
          <source>The cache implementation itself is simple and straightforward, a hashtable wrapped in a class and a C API (see APIs below).</source>
          <target state="translated">캐시 구현 자체는 간단하고 간단하며 클래스와 C API로 래핑 된 해시 테이블입니다 (아래 API 참조).</target>
        </trans-unit>
        <trans-unit id="91922ceda3cf9c8ce0058f21ee28e035ddb98b58" translate="yes" xml:space="preserve">
          <source>The cache is completely transparent for a user; MariaDB makes sure that it always stores the actual table definition and invalidates the &lt;code&gt;.frm&lt;/code&gt; file automatically when it becomes out of date. This can happen, for example, if a user copies a new &lt;a href=&quot;../archive/index&quot;&gt;Archive&lt;/a&gt; table into the datadir and forgets to delete the &lt;code&gt;.frm&lt;/code&gt; file of the old table with the same name.</source>
          <target state="translated">캐시는 사용자에게 완전히 투명합니다. MariaDB는 항상 실제 테이블 정의를 저장하고 &lt;code&gt;.frm&lt;/code&gt; 파일이 오래되면 자동으로 무효화합니다 . 예를 들어, 사용자가 새 &lt;a href=&quot;../archive/index&quot;&gt;Archive&lt;/a&gt; 테이블을 datadir에 복사 하고 동일한 이름을 가진 이전 테이블 의 &lt;code&gt;.frm&lt;/code&gt; 파일 을 삭제하는 것을 잊은 경우에 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a13674b44ae5c470be9d2beb0895f6fea27313ee" translate="yes" xml:space="preserve">
          <source>The cache: sp_cache.h</source>
          <target state="translated">캐시 : sp_cache.h</target>
        </trans-unit>
        <trans-unit id="d8c8e95e02c08385e6018aed10a53744e025a1d6" translate="yes" xml:space="preserve">
          <source>The case of &lt;code&gt;NULL&lt;/code&gt; is not relevant. &lt;code&gt;\N&lt;/code&gt; (uppercase) is an alias for &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NULL&lt;/code&gt; 의 경우는 관련이 없습니다. &lt;code&gt;\N&lt;/code&gt; (대문자)은 &lt;code&gt;NULL&lt;/code&gt; 의 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="f6aa90139a597c4f76d1718de34a9b1668f77675" translate="yes" xml:space="preserve">
          <source>The case of deleted lines is handled in a specific way for DBF tables. Deleted lines are not removed from the file but are &quot;soft deleted&quot; meaning they are marked as deleted. In particular, the number of lines contained in the file header does not take care of soft deleted lines. This is why if you execute these two commands applied to a DBF table named &lt;em&gt;tabdbf&lt;/em&gt;:</source>
          <target state="translated">삭제 된 행의 경우 DBF 테이블에 대해 특정 방식으로 처리됩니다. 삭제 된 줄은 파일에서 제거되지 않지만 &quot;소프트 삭제&quot;이므로 삭제 된 것으로 표시됩니다. 특히 파일 헤더에 포함 된 줄 수는 소프트 삭제 된 줄을 처리하지 않습니다. 이것이 &lt;em&gt;tabdbf&lt;/em&gt; 라는 DBF 테이블에 적용된이 두 명령을 실행하는 이유입니다 .</target>
        </trans-unit>
        <trans-unit id="6c377e9ea5db4d333a8fcaa80e2a986a42e6114c" translate="yes" xml:space="preserve">
          <source>The catalog function used by a &lt;a href=&quot;../connect-table-types-catalog-tables/index&quot;&gt;catalog table&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../connect-table-types-catalog-tables/index&quot;&gt;카탈로그 테이블에서&lt;/a&gt; 사용하는 카탈로그 함수 입니다.</target>
        </trans-unit>
        <trans-unit id="d07fcc0933de1bfd31e515b7ac8dc090ad3eebcb" translate="yes" xml:space="preserve">
          <source>The certificate and keys will be read from the option file.</source>
          <target state="translated">옵션 파일에서 인증서와 키를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="abefbabe25687277fca33aeb3472ce6306b5db1b" translate="yes" xml:space="preserve">
          <source>The change buffer only contains changes to the indexes. Changes to UNIQUE indexes are primary keys cannot be buffered, because InnoDB has to read the disk to check for duplicate values.</source>
          <target state="translated">변경 버퍼에는 인덱스 변경 사항 만 포함됩니다. InnoDB는 중복 값을 확인하기 위해 디스크를 읽어야하기 때문에 UNIQUE 인덱스의 변경 사항은 기본 키는 버퍼링 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7f96588d7c05b582e5f72068ff71619fd3d2c635" translate="yes" xml:space="preserve">
          <source>The character set of string literals that do not have a character set introducer is determined by the &lt;a href=&quot;../server-system-variables/index#character_set_connection&quot;&gt;character_set_connection&lt;/a&gt; system variable.</source>
          <target state="translated">문자 세트 도입자가없는 문자열 리터럴의 문자 세트는 &lt;a href=&quot;../server-system-variables/index#character_set_connection&quot;&gt;character_set_connection&lt;/a&gt; 시스템 변수에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="82b6f106fc2397d1830f30c5d00b10bd5f67a3f1" translate="yes" xml:space="preserve">
          <source>The character set that the error messages are returned in is determined by the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#character_set_results&quot;&gt;character_set_results&lt;/a&gt;&lt;/code&gt; variable, which defaults to UTF8.</source>
          <target state="translated">오류 메시지가 리턴되는 문자 세트는 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#character_set_results&quot;&gt;character_set_results&lt;/a&gt;&lt;/code&gt; 변수에 의해 결정되며 기본값은 UTF8입니다.</target>
        </trans-unit>
        <trans-unit id="4bbe1155f7835be3026766489b57ead1e62557a5" translate="yes" xml:space="preserve">
          <source>The character set used in the external file or data source.</source>
          <target state="translated">외부 파일 또는 데이터 소스에서 사용되는 문자 세트.</target>
        </trans-unit>
        <trans-unit id="f5879e59859c91210cc4004e08058a95c878579d" translate="yes" xml:space="preserve">
          <source>The character set used to send statements to the server, and results back to the client.</source>
          <target state="translated">서버로 명령문을 전송하고 클라이언트에게 결과를 보내는 데 사용되는 문자 세트입니다.</target>
        </trans-unit>
        <trans-unit id="73ffd3cf83e9c09f5d35c02774144fb7e64085ca" translate="yes" xml:space="preserve">
          <source>The charset should use 1-byte characters (so, unicode-based collations are not included)</source>
          <target state="translated">문자셋은 1 바이트 문자를 사용해야합니다 (따라서 유니 코드 기반 데이터 정렬은 포함되지 않음)</target>
        </trans-unit>
        <trans-unit id="c1a0b442ea745155c46d3b7edceb5b716c56dab1" translate="yes" xml:space="preserve">
          <source>The checkpoint age is the amount of data written to the InnoDB redo log since the last checkpoint.</source>
          <target state="translated">체크 포인트 보존 기간은 마지막 체크 포인트 이후 InnoDB 리두 로그에 기록 된 데이터의 양입니다.</target>
        </trans-unit>
        <trans-unit id="124e779cd9fa0edbd4ff2bde4fae2a4bca3f0400" translate="yes" xml:space="preserve">
          <source>The choice between these algorithms depends on the session variable &lt;a href=&quot;../connect-system-variables/index#connect_use_tempfile&quot;&gt;connect_use_tempfile&lt;/a&gt;.</source>
          <target state="translated">이러한 알고리즘 중에서 선택하는 것은 세션 변수 &lt;a href=&quot;../connect-system-variables/index#connect_use_tempfile&quot;&gt;connect_use_tempfile&lt;/a&gt; 에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="8e53b3f738c6c21e9293059e65531b3759616de7" translate="yes" xml:space="preserve">
          <source>The choice depends on which is faster (insertion or processing). There are tradeoffs; a single processing thread avoids some locks, but lacks some parallelism.</source>
          <target state="translated">선택은 어느 것이 더 빠른지 (삽입 또는 처리)에 달려 있습니다. 트레이드 오프가 있습니다. 단일 처리 스레드는 일부 잠금을 피하지만 병렬 처리가 부족합니다.</target>
        </trans-unit>
        <trans-unit id="766b6b48f52aabba5aedca436c480949e9c39f4a" translate="yes" xml:space="preserve">
          <source>The choice of which of several non-unique indexes to use is based on the cardinality of indexes; the one that is most selective (has the smallest average number of rows per distinct tuple of column values) is preferred. Note that for this choice to be effective, for most storage engines (like MyISAM, InnoDB) it is necessary to make sure &lt;a href=&quot;../analyze-table/index&quot;&gt;ANALYZE TABLE&lt;/a&gt; has been run on the slave, otherwise statistics about index cardinality will not be available. In the absence of index cardinality, the first unique index will be chosen, if any, else the first non-unique index.</source>
          <target state="translated">사용할 고유하지 않은 여러 인덱스 중 하나를 선택하는 것은 인덱스의 카디널리티를 기반으로합니다. 가장 선택적인 것 (열 값의 별개의 튜플 당 가장 작은 평균 행 수를 가짐)이 선호됩니다. 이 선택이 효과적이기 위해서는 대부분의 스토리지 엔진 (MyISAM, InnoDB와 같은)의 경우 &lt;a href=&quot;../analyze-table/index&quot;&gt;ANALYZE TABLE&lt;/a&gt; 이 슬레이브에서 실행되어야합니다. 그렇지 않으면 인덱스 카디널리티에 대한 통계를 사용할 수 없습니다. 인덱스 카디널리티가 없으면 첫 번째 고유 인덱스 (있는 경우)가 아닌 다른 첫 번째 고유 인덱스가 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="5fcbd57acb7478c549cabb09bc950c162594925a" translate="yes" xml:space="preserve">
          <source>The clause is not applicable to &lt;code&gt;&lt;a href=&quot;../delete/index&quot;&gt;DELETE&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt;&lt;/code&gt; statements, and if used in those statements produces a syntax error.</source>
          <target state="translated">이 절은 &lt;code&gt;&lt;a href=&quot;../delete/index&quot;&gt;DELETE&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt;&lt;/code&gt; 문에 적용 할 수 없으며 해당 명령문에서 사용되는 경우 구문 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3cabd77df2dbd935f2f078548a0160b3a408e9a2" translate="yes" xml:space="preserve">
          <source>The client &lt;a href=&quot;../data-types-character-sets-and-collations/index&quot;&gt;character set&lt;/a&gt; when the trigger was created, from the session value of the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#character_set_client&quot;&gt;character_set_client&lt;/a&gt;&lt;/code&gt; system variable.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../server-system-variables/index#character_set_client&quot;&gt;character_set_client&lt;/a&gt;&lt;/code&gt; 시스템 변수 의 세션 값에서 트리거가 작성 될 때 클라이언트 &lt;a href=&quot;../data-types-character-sets-and-collations/index&quot;&gt;문자 세트&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0546ab14833459bf420450158a2b656c26ab4c88" translate="yes" xml:space="preserve">
          <source>The client &lt;a href=&quot;../data-types-character-sets-and-collations/index&quot;&gt;character set&lt;/a&gt; when the view was created, from the session value of the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#character_set_client&quot;&gt;character_set_client&lt;/a&gt;&lt;/code&gt; system variable.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../server-system-variables/index#character_set_client&quot;&gt;character_set_client&lt;/a&gt;&lt;/code&gt; 시스템 변수 의 세션 값에서보기를 작성할 때 클라이언트 &lt;a href=&quot;../data-types-character-sets-and-collations/index&quot;&gt;문자 세트&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a9203dc825dcce52577f6ced94d0e61f78d9b006" translate="yes" xml:space="preserve">
          <source>The client &lt;a href=&quot;../data-types-character-sets-and-collations/index&quot;&gt;collation&lt;/a&gt; when the trigger was created, from the session value of the &lt;a href=&quot;../server-system-variables/index#collation_connection&quot;&gt;collation_connection&lt;/a&gt; system variable.</source>
          <target state="translated">&lt;a href=&quot;../server-system-variables/index#collation_connection&quot;&gt;collation_connection&lt;/a&gt; 시스템 변수 의 세션 값에서 트리거가 작성 될 때 클라이언트 &lt;a href=&quot;../data-types-character-sets-and-collations/index&quot;&gt;데이터 정렬&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8830418f99fb5565380fa604e5bc5a9a3ef57307" translate="yes" xml:space="preserve">
          <source>The client &lt;a href=&quot;../data-types-character-sets-and-collations/index&quot;&gt;collation&lt;/a&gt; when the view was created, from the session value of the &lt;a href=&quot;../server-system-variables/index#collation_connection&quot;&gt;collation_connection&lt;/a&gt; system variable.</source>
          <target state="translated">&lt;a href=&quot;../server-system-variables/index#collation_connection&quot;&gt;collation_connection&lt;/a&gt; 시스템 변수 의 세션 값에서보기가 작성 될 때 클라이언트 &lt;a href=&quot;../data-types-character-sets-and-collations/index&quot;&gt;데이터 정렬&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bb155e9aa8479087975a14fcc95e47fae7159cf7" translate="yes" xml:space="preserve">
          <source>The client can execute &lt;a href=&quot;../transactions-lock/index&quot;&gt;UNLOCK TABLES&lt;/a&gt;.</source>
          <target state="translated">클라이언트는 &lt;a href=&quot;../transactions-lock/index&quot;&gt;UNLOCK TABLES를&lt;/a&gt; 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bb505ca3ef4706869b62b31d0e32270cba4defd8" translate="yes" xml:space="preserve">
          <source>The client library is smaller and faster for connection. The server library is more optimized and can be used in case of heavy load usage.</source>
          <target state="translated">클라이언트 라이브러리는 더 작고 연결 속도가 빠릅니다. 서버 라이브러리는보다 최적화되어 있으며로드 사용량이 많은 경우에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="239fecc41982a9bb4371568e1347c6aa7f9c7076" translate="yes" xml:space="preserve">
          <source>The client sends the query using cp850.</source>
          <target state="translated">클라이언트는 cp850을 사용하여 쿼리를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="dd2adfa583c2ee006a7d24ab57fbe411aa57131b" translate="yes" xml:space="preserve">
          <source>The client's process ID.</source>
          <target state="translated">클라이언트의 프로세스 ID</target>
        </trans-unit>
        <trans-unit id="e39ab2ab7632b6dd8a57bdcf28b8bb04bd7459fb" translate="yes" xml:space="preserve">
          <source>The client-side component of the &lt;code&gt;&lt;a href=&quot;../authentication-plugin-gssapi/index&quot;&gt;gssapi&lt;/a&gt;&lt;/code&gt; authentication plugin.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../authentication-plugin-gssapi/index&quot;&gt;gssapi&lt;/a&gt;&lt;/code&gt; 인증 플러그인 의 클라이언트 측 구성 요소입니다 .</target>
        </trans-unit>
        <trans-unit id="b97e0a62c740b822a02a830b44d92ef08c8e5b82" translate="yes" xml:space="preserve">
          <source>The cluster address can also contain a comma-separated list of multiple members of the cluster. It is good practice to list all possible members of the cluster, for example &lt;code&gt;gcomm:&lt;em&gt;&amp;lt;node1 name or ip&amp;gt;,&amp;lt;node2 name or ip2&amp;gt;,&amp;lt;node3 name or ip&amp;gt;&lt;/em&gt;&lt;/code&gt;. Alternately if multicast is use put the multicast address instead of the list of nodes. Each member address or multicast address can specify &lt;code&gt;&amp;lt;node name or ip&amp;gt;:&amp;lt;port&amp;gt;&lt;/code&gt; if a non-default port is used.</source>
          <target state="translated">클러스터 주소에는 쉼표로 구분 된 여러 클러스터 멤버 목록이 포함될 수도 있습니다. 가능한 모든 클러스터 구성원을 나열하는 것이 좋습니다 (예 &lt;code&gt;gcomm:&lt;em&gt;&amp;lt;node1 name or ip&amp;gt;,&amp;lt;node2 name or ip2&amp;gt;,&amp;lt;node3 name or ip&amp;gt;&lt;/em&gt;&lt;/code&gt; . 또는 멀티 캐스트를 사용하는 경우 노드 목록 대신 멀티 캐스트 주소를 넣으십시오. 기본이 아닌 포트를 사용하는 경우 각 구성원 주소 또는 멀티 캐스트 주소는 &lt;code&gt;&amp;lt;node name or ip&amp;gt;:&amp;lt;port&amp;gt;&lt;/code&gt; 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3ddfbba6fa99aaa1a3683c48da4019a6fa4960d1" translate="yes" xml:space="preserve">
          <source>The cluster address shouldn't be empty like &lt;code&gt;gcomm://&lt;/code&gt;. This should never be hardcoded into any configuration files.</source>
          <target state="translated">&lt;code&gt;gcomm://&lt;/code&gt; 과 같이 클러스터 주소는 비워 둘 수 없습니다 . 이것은 구성 파일에 하드 코딩되어서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="9676bd2f7ab81e1ff99ef0b1fffa71b65362b66c" translate="yes" xml:space="preserve">
          <source>The cluster nodes can be configured to invoke a command when cluster membership or node status changes. This mechanism can also be used to communicate the event to some external monitoring agent. This is configured by setting &lt;code&gt;&lt;a href=&quot;../galera-cluster-system-variables/index#wsrep_notify_cmd&quot;&gt;wsrep_notify_cmd&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;http://galeracluster.com/documentation-webpages/notificationcmd.html&quot;&gt;Galera Cluster documentation: Notification Command&lt;/a&gt; for more information.</source>
          <target state="translated">클러스터 멤버쉽 또는 노드 상태가 변경 될 때 명령을 호출하도록 클러스터 노드를 구성 할 수 있습니다. 이 메커니즘은 이벤트를 일부 외부 모니터링 에이전트와 통신하는 데에도 사용될 수 있습니다. 이것은 &lt;code&gt;&lt;a href=&quot;../galera-cluster-system-variables/index#wsrep_notify_cmd&quot;&gt;wsrep_notify_cmd&lt;/a&gt;&lt;/code&gt; 를 설정하여 구성됩니다 . 자세한 내용은 &lt;a href=&quot;http://galeracluster.com/documentation-webpages/notificationcmd.html&quot;&gt;Galera Cluster 설명서 : 알림 명령&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a1cc1341b616765e73df12063a5b822e7dccdce0" translate="yes" xml:space="preserve">
          <source>The code changes can be built using make within the directory &lt;strong&gt;utils/udfsdk&lt;/strong&gt;, this will create the following libraries in the same directory:</source>
          <target state="translated">&lt;strong&gt;utils / udfsdk&lt;/strong&gt; 디렉토리 내에서 make를 사용하여 코드 변경 사항을 빌드 할 수 있습니다 . 그러면 동일한 디렉토리에 다음 라이브러리가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="60722563984f2aa8f95493fd6a31f9f98762e5b7" translate="yes" xml:space="preserve">
          <source>The code enforces that consecutive blocks never have the same 'owner', so the table is of 'minimal' size. Your application can assume that such is always the case.</source>
          <target state="translated">이 코드는 연속 블록이 동일한 '소유자'를 갖지 않도록 강제하므로 테이블의 크기는 '최소'입니다. 응용 프로그램은 항상 그런 경우라고 가정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9544f2d4bcaaa9a198e3bb2f2f687ad9a91ddfae" translate="yes" xml:space="preserve">
          <source>The code for handling IP address is more complex, but the overall structure is the same as for IPv4. Launch into it only if you need IPv6.</source>
          <target state="translated">IP 주소 처리 코드는 더 복잡하지만 전체 구조는 IPv4와 동일합니다. IPv6이 필요한 경우에만 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="18caf4d4240fc06ed4f287a9f9907f7a138c9e2b" translate="yes" xml:space="preserve">
          <source>The code for this can be found in storage/maria/ma_loghandler.c::translog_flush()</source>
          <target state="translated">이에 대한 코드는 storage / maria / ma_loghandler.c :: translog_flush ()에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ece6a093614927fe9fa0535fb18fba61645326c4" translate="yes" xml:space="preserve">
          <source>The code has been benchmarked at about 20 microseconds per call on a 2011-vintage PC. If you had to check a million points, that would take 20 seconds -- far too much for a web application. So, one goal of the Procedure that uses it will be to minimize the usage of this function. With the code presented here, the function need be called only a few dozen or few hundred times, except in pathological cases.</source>
          <target state="translated">이 코드는 2011 년 빈티지 PC에서 호출 당 약 20 마이크로 초로 벤치마킹되었습니다. 백만 포인트를 확인해야한다면 웹 애플리케이션에는 너무 많은 20 초가 걸립니다. 따라서 절차를 사용하는 한 가지 목표는이 기능의 사용을 최소화하는 것입니다. 여기에 표시된 코드를 사용하면 병리학 적 사례를 제외하고 함수를 수십 또는 수백 번만 호출하면됩니다.</target>
        </trans-unit>
        <trans-unit id="0510eb7e61450cec6c8fba1f4d1c44145cc8d7ad" translate="yes" xml:space="preserve">
          <source>The code is in bazaar branch at &lt;a href=&quot;https://code.launchpad.net/~maria-captains/maria/5.5-cassandra&quot;&gt;lp:~maria-captains/maria/5.5-cassandra&lt;/a&gt;.</source>
          <target state="translated">코드는 &lt;a href=&quot;https://code.launchpad.net/~maria-captains/maria/5.5-cassandra&quot;&gt;lp : ~ maria-captains / maria / 5.5-cassandra의&lt;/a&gt; 시장 지점에 있습니다.</target>
        </trans-unit>
        <trans-unit id="61d05ad9bf4dcd7895f427070266d5655ddfa576" translate="yes" xml:space="preserve">
          <source>The code is more complex.</source>
          <target state="translated">코드가 더 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="ab517e2a8ba12a27ab2bbd36c075257a2d62e599" translate="yes" xml:space="preserve">
          <source>The code:</source>
          <target state="translated">코드:</target>
        </trans-unit>
        <trans-unit id="4d3e5931e11c8cab9ae4176adc35a4bc18204353" translate="yes" xml:space="preserve">
          <source>The collation (sorting order) for an index column has changed</source>
          <target state="translated">인덱스 열의 데이터 정렬 (정렬 순서)이 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="4e4f2dac124689b9a02fc1dc6ec8f1bfafae401f" translate="yes" xml:space="preserve">
          <source>The collation case sensitivity can be overwritten using the (?i) and (?-i) PCRE flags.</source>
          <target state="translated">(? i) 및 (? -i) PCRE 플래그를 사용하여 데이터 정렬 대 / 소문자 구분을 덮어 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bcd78c88d6129c9571269d54954d1a3afffc14d7" translate="yes" xml:space="preserve">
          <source>The collation clause is optional. If not defined (or if &lt;code&gt;DEFAULT&lt;/code&gt; is specified), the &lt;a href=&quot;../supported-character-sets-and-collations/index&quot;&gt;default collation for the character set&lt;/a&gt; will be used.</source>
          <target state="translated">데이터 정렬 절은 선택 사항입니다. 정의되지 않은 경우 (또는 &lt;code&gt;DEFAULT&lt;/code&gt; 가 지정된 경우) &lt;a href=&quot;../supported-character-sets-and-collations/index&quot;&gt;문자 세트&lt;/a&gt; 의 기본 데이터 정렬 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5e548b166acb1b1833baa9510a2d73b0aeacdece" translate="yes" xml:space="preserve">
          <source>The color of optimization indicates which version of MySQL/MariaDB it was available in (see legend below)</source>
          <target state="translated">최적화 색상은 사용 가능한 MySQL / MariaDB 버전을 나타냅니다 (아래 범례 참조).</target>
        </trans-unit>
        <trans-unit id="e009027394b2121796512415695ebfb8062a6707" translate="yes" xml:space="preserve">
          <source>The column &lt;code&gt;MTYPE&lt;/code&gt; uses a numeric column type identifier, which has the following values:</source>
          <target state="translated">열 &lt;code&gt;MTYPE&lt;/code&gt; 은 숫자 열 유형 식별자를 사용하며 다음 값을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="52c5681365efbbb7c197ad0bc46cfda038d6d21e" translate="yes" xml:space="preserve">
          <source>The column &lt;em&gt;id&lt;/em&gt; is declared as a key, and the table type is now MYSQL. This makes Sub-tables accessed by calling a MariaDB server as MYSQL tables do. Note that this modifies only the way CONNECT sub-tables are accessed.</source>
          <target state="translated">열 &lt;em&gt;ID&lt;/em&gt; 는 키로 선언되었으며 이제 테이블 유형은 MYSQL입니다. 이렇게하면 MYSQL 테이블처럼 MariaDB 서버를 호출하여 하위 테이블에 액세스 할 수 있습니다. 이는 CONNECT 서브 테이블에 액세스하는 방식 만 수정합니다.</target>
        </trans-unit>
        <trans-unit id="54a9b032d9ab800a4a794fc84d9ea9808df8335f" translate="yes" xml:space="preserve">
          <source>The column DEFAULT value can be a maximum of 64 characters.</source>
          <target state="translated">DEFAULT 열 값은 최대 64 자입니다.</target>
        </trans-unit>
        <trans-unit id="2ad11286544ee67a93fd1f63b14b35974abf797b" translate="yes" xml:space="preserve">
          <source>The column definition has two sets of columns:</source>
          <target state="translated">열 정의에는 두 개의 열 세트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="bcd1ccfba59d5910ccee3cb307236ecf03b4c129" translate="yes" xml:space="preserve">
          <source>The column definitions. This can be also left to CONNECT to find them using the discovery MariaDB feature.</source>
          <target state="translated">열 정의. Discover MariaDB 기능을 사용하여 찾도록 CONNECT 상태로 둘 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="322a0a9332ace7d5ac2566250b3e354bcd3d7b13" translate="yes" xml:space="preserve">
          <source>The column descriptions can be retrieved by the discovery process for table types allowing it. It cannot be done for multiple tables or multiple entries. A catalog table can be created by adding &lt;em&gt;catfunc=columns&lt;/em&gt;. This can be used to show the column definitions of multiple tables. &lt;em&gt;Multiple&lt;/em&gt; must be set to false and the column definitions will be the ones of the first table or entry.</source>
          <target state="translated">열 설명은이를 허용하는 테이블 유형에 대한 감지 프로세스에서 검색 할 수 있습니다. 여러 테이블 또는 여러 항목에 대해 수행 할 수 없습니다. &lt;em&gt;catfunc = columns&lt;/em&gt; 를 추가하여 카탈로그 테이블을 작성할 수 있습니다 . 여러 테이블의 열 정의를 표시하는 데 사용할 수 있습니다. &lt;em&gt;배수&lt;/em&gt; 는 false로 설정해야하며 열 정의는 첫 번째 테이블 또는 항목의 정의입니다.</target>
        </trans-unit>
        <trans-unit id="d75c4c2a1124909ed0fbf43d5625e4be450da0b7" translate="yes" xml:space="preserve">
          <source>The column format for some table types.</source>
          <target state="translated">일부 테이블 유형의 열 형식입니다.</target>
        </trans-unit>
        <trans-unit id="9404e6c4a739c4d2a2633c1a0899e4916b326270" translate="yes" xml:space="preserve">
          <source>The column is a &lt;code&gt;TIMESTAMP&lt;/code&gt; column that is automatically updated on &lt;code&gt;INSERT&lt;/code&gt; and &lt;code&gt;UPDATE&lt;/code&gt;.</source>
          <target state="translated">열은 &lt;code&gt;INSERT&lt;/code&gt; 및 &lt;code&gt;UPDATE&lt;/code&gt; 시 자동으로 업데이트 되는 &lt;code&gt;TIMESTAMP&lt;/code&gt; 열입니다 .</target>
        </trans-unit>
        <trans-unit id="719d94d816421ac56c5b0b586f81d962b7f9538a" translate="yes" xml:space="preserve">
          <source>The column list of &lt;a href=&quot;../connect-table-types-occur-table-type/index&quot;&gt;OCCUR&lt;/a&gt; tables or $project of &lt;a href=&quot;../connect-mongo-table-type-accessing-collections-from-mongodb/index&quot;&gt;MONGO&lt;/a&gt; tables.</source>
          <target state="translated">의 열 목록이 &lt;a href=&quot;../connect-table-types-occur-table-type/index&quot;&gt;발생하는&lt;/a&gt; 테이블 또는 $ 프로젝트 &lt;a href=&quot;../connect-mongo-table-type-accessing-collections-from-mongodb/index&quot;&gt;몽고의&lt;/a&gt; 테이블을.</target>
        </trans-unit>
        <trans-unit id="8877423f2b68c7ff8fba891d48e70b2cc4383429" translate="yes" xml:space="preserve">
          <source>The column must be an integer type.</source>
          <target state="translated">열은 정수 유형이어야합니다.</target>
        </trans-unit>
        <trans-unit id="8420d2c88df44919ff7832e5423eccf9e0e7b65d" translate="yes" xml:space="preserve">
          <source>The column name</source>
          <target state="translated">열 이름</target>
        </trans-unit>
        <trans-unit id="3332de3cc0774a8729f30f6305f5efc7afddd0e7" translate="yes" xml:space="preserve">
          <source>The column names from the first &lt;code&gt;SELECT&lt;/code&gt; statement are used as the column names for the results returned. Selected columns listed in corresponding positions of each SELECT statement should have the same data type. (For example, the first column selected by the first statement should have the same type as the first column selected by the other statements.)</source>
          <target state="translated">첫 번째 &lt;code&gt;SELECT&lt;/code&gt; 의 열 이름 문의 열 이름은 반환 된 결과의 열 이름으로 사용됩니다. 각 SELECT 문의 해당 위치에 나열된 선택 열의 데이터 형식은 동일해야합니다. 예를 들어 첫 번째 문에서 선택한 첫 번째 열은 다른 문에서 선택한 첫 번째 열과 동일한 유형이어야합니다.</target>
        </trans-unit>
        <trans-unit id="addefbdad97efaaa9331f2ea6823400b53590387" translate="yes" xml:space="preserve">
          <source>The column names of the tables must be the names (case insensitive) of the properties you want to retrieve. For instance:</source>
          <target state="translated">테이블의 열 이름은 검색하려는 특성의 이름 (대소 문자 구분)이어야합니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="afbfb41842fa79d604031b0fe0075c1c1a59c3a2" translate="yes" xml:space="preserve">
          <source>The column privilege type. See &lt;a href=&quot;../grant/index#column-privileges&quot;&gt;Column Privileges&lt;/a&gt; for details.</source>
          <target state="translated">열 권한 유형입니다. &lt;a href=&quot;../grant/index#column-privileges&quot;&gt;열 권한&lt;/a&gt; 참조 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="35dbc6ea3b5f85c1722b8fd37711cc648a596227" translate="yes" xml:space="preserve">
          <source>The column sequence number, starting at 1.</source>
          <target state="translated">1부터 시작하는 열 시퀀스 번호입니다.</target>
        </trans-unit>
        <trans-unit id="f9adab651dbb2955afe280cdcff76121cd44a669" translate="yes" xml:space="preserve">
          <source>The column that will contain the section name can have any name but must specify &lt;code&gt;flag=1&lt;/code&gt;. All other columns must have the names of the keys we want to display (case insensitive). The type can be character or numeric depending on the key value type, and the length is the maximum expected length for the key value. Once done, the statement:</source>
          <target state="translated">섹션 이름을 포함 할 열은 이름을 가질 수 있지만 &lt;code&gt;flag=1&lt;/code&gt; 을 지정해야합니다. . 다른 모든 열에는 표시하려는 키 이름이 있어야합니다 (대소 문자 구분). 유형은 키 값 유형에 따라 문자 또는 숫자 일 수 있으며 길이는 키 값의 최대 예상 길이입니다. 완료되면, 진술 :</target>
        </trans-unit>
        <trans-unit id="7b4a33bd59f590b687f5251cd96e67d7e06c3f5c" translate="yes" xml:space="preserve">
          <source>The column was created with the &lt;code&gt;AUTO_INCREMENT&lt;/code&gt; keyword.</source>
          <target state="translated">이 열은 &lt;code&gt;AUTO_INCREMENT&lt;/code&gt; 키워드 로 작성되었습니다 .</target>
        </trans-unit>
        <trans-unit id="8f4f89d9da126ffc45ae3080efdc4d33c10f4e6c" translate="yes" xml:space="preserve">
          <source>The column was created with the &lt;code&gt;PERSISTENT&lt;/code&gt; keyword. (New in 5.3)</source>
          <target state="translated">열은 &lt;code&gt;PERSISTENT&lt;/code&gt; 로 작성되었습니다. 키워드로 . (5.3의 새로운 기능)</target>
        </trans-unit>
        <trans-unit id="3285baf4c709f91fe1feea3475a326ee62c89849" translate="yes" xml:space="preserve">
          <source>The column was created with the &lt;code&gt;VIRTUAL&lt;/code&gt; keyword. (New in 5.3)</source>
          <target state="translated">&lt;code&gt;VIRTUAL&lt;/code&gt; 을 사용하여 열이 생성되었습니다. 키워드 . (5.3의 새로운 기능)</target>
        </trans-unit>
        <trans-unit id="918e7c1b1d93c1773f1a4fd6c893afa613b54b16" translate="yes" xml:space="preserve">
          <source>The column's &lt;a href=&quot;../data-types/index&quot;&gt;data type&lt;/a&gt;.</source>
          <target state="translated">열의 &lt;a href=&quot;../data-types/index&quot;&gt;데이터 유형&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c1d8e186e10c47bf50125b39f1b4d6c4c55414c0" translate="yes" xml:space="preserve">
          <source>The column's sequence in the index, beginning with &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;1&lt;/code&gt; 로 시작하는 인덱스의 열 순서 .</target>
        </trans-unit>
        <trans-unit id="0228ac73326b80c7bd518fbd78eb4dada0f9736c" translate="yes" xml:space="preserve">
          <source>The columnar disk storage format is unchanged between InfiniDB 4.X and MariaDB ColumnStore allowing for a software upgrade on the same system. This document outlines an approach to perform the upgrade.</source>
          <target state="translated">InfiniDB 4.X와 MariaDB ColumnStore 간에는 원주 디스크 스토리지 형식이 변경되지 않으므로 동일한 시스템에서 소프트웨어를 업그레이드 할 수 있습니다. 이 문서는 업그레이드 수행 방법을 간략하게 설명합니다.</target>
        </trans-unit>
        <trans-unit id="263b5a6595c4aa3ec205a744eca262dc51aac437" translate="yes" xml:space="preserve">
          <source>The columnar disk storage format is unchanged between InfiniDB 4.X and MariaDB ColumnStore allowing for relatively straightforward data migration utilizing backup and restore logic. This document outlines an approach to perform the migration that can be adapted to your particular needs.</source>
          <target state="translated">컬럼 형 디스크 스토리지 형식은 InfiniDB 4.X와 MariaDB ColumnStore간에 변경되지 않으므로 백업 및 복원 논리를 사용하여 비교적 간단한 데이터 마이그레이션이 가능합니다. 이 문서는 특정 요구에 맞게 마이그레이션을 수행하는 방법을 간략하게 설명합니다.</target>
        </trans-unit>
        <trans-unit id="7ad88c2134daa4198b29190973ef84564045e234" translate="yes" xml:space="preserve">
          <source>The columns headings in the output are as follows:</source>
          <target state="translated">출력에서 열 제목은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f75864b387a3d01440cda5406dc7b356765316e3" translate="yes" xml:space="preserve">
          <source>The columns in EXPLAIN ... SELECT</source>
          <target state="translated">EXPLAIN ... SELECT의 열</target>
        </trans-unit>
        <trans-unit id="db96e1687023157a2a0ac123897bdee41810f38c" translate="yes" xml:space="preserve">
          <source>The columns in the child table must be an index, or the leftmost part of an index. Index prefixes are not supported (thus, &lt;a href=&quot;../text/index&quot;&gt;TEXT&lt;/a&gt; and &lt;a href=&quot;../blob/index&quot;&gt;BLOB&lt;/a&gt; columns cannot be used as foreign keys). If MariaDB automatically creates an index for the foreign key (because it does not exist and is not explicitly created), its name will be &lt;code&gt;index_name&lt;/code&gt;.</source>
          <target state="translated">자식 테이블의 열은 인덱스이거나 인덱스의 가장 왼쪽 부분이어야합니다. 인덱스 접두사는 지원되지 않습니다 (따라서 &lt;a href=&quot;../text/index&quot;&gt;TEXT&lt;/a&gt; 및 &lt;a href=&quot;../blob/index&quot;&gt;BLOB&lt;/a&gt; 열은 외래 키로 사용할 수 없습니다). MariaDB가 외래 키에 대한 인덱스를 자동으로 생성하면 (존재하지 않고 명시 적으로 생성되지 않기 때문에) 해당 이름은 &lt;code&gt;index_name&lt;/code&gt; 이됩니다. 입니다.</target>
        </trans-unit>
        <trans-unit id="89cd2bf6aca88be2a4e30e5e3b9b6dedfb9d72fa" translate="yes" xml:space="preserve">
          <source>The columns list is optional. It specifies which values are explicitly inserted, and in which order. If this clause is not specified, all values must be explicitly specified, in the same order they are listed in the table definition.</source>
          <target state="translated">열 목록은 선택 사항입니다. 명시 적으로 삽입 된 값과 순서를 지정합니다. 이 절이 지정되지 않은 경우 모든 값은 테이블 정의에 나열된 순서대로 명시 적으로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="999da00fd210ddebdf02dbcfb29f0c45f6eb5808" translate="yes" xml:space="preserve">
          <source>The columns of this table are:</source>
          <target state="translated">이 테이블의 열은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f5b71c1b3b0b14896d832eb401f22eb92f0c5a4b" translate="yes" xml:space="preserve">
          <source>The columns shown in &lt;code&gt;SHOW PROCESSLIST
&lt;/code&gt; are:</source>
          <target state="translated">&lt;code&gt;SHOW PROCESSLIST &lt;/code&gt; 에 표시된 열 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bf12763feff1fa31b2e40475b4823c5b6b80da75" translate="yes" xml:space="preserve">
          <source>The columnstoreBackup option -n [value] limits the number parallel rsync commands executed at a given time. The default 5 means up to 5 DBRoots will kick off rysnc commands to various PMs and the backup system will wait until all are complete and verified successful. At this time it will kick off another 5 DBRoots. The progress indicator should reflect the percentage of total completion and not individual rysnc commands. This value can be set higher via the -n command but if the number of DBRoots present in the system is large enough there may be a performance hit on system processing or network bandwidth limitations.</source>
          <target state="translated">columnstoreBackup 옵션 -n [value]는 주어진 시간에 실행되는 병렬 rsync 명령의 수를 제한합니다. 기본값 5는 최대 5 개의 DBRoot가 다양한 PM에 대한 rysnc 명령을 시작 함을 의미하며 백업 시스템은 모두 완료되고 확인 될 때까지 기다립니다. 이때 다른 5 개의 DBRoot가 시작됩니다. 진행률 표시기는 개별 rysnc 명령이 아닌 전체 완료율을 반영해야합니다. 이 값은 -n 명령을 통해 더 높게 설정할 수 있지만 시스템에 존재하는 DBRoot의 수가 충분히 많으면 시스템 처리 또는 네트워크 대역폭 제한에서 성능이 저하 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1458109675cf1f7d6c53c04fab8b2c1df45d6de8" translate="yes" xml:space="preserve">
          <source>The columnstoreRestore option -n [value] limits the number parallel rsync commands executed at a given time. The default 5 means up to 5 DBRoots will kick off rysnc commands to various PMs and the backup system will wait until all are complete and verified successful. At this time it will kick off another 5 DBRoots. The progress indicator should reflect the percentage of total completion and not individual rysnc commands. This value can be set higher via the -n command but if the number of DBRoots present in the system is large enough there may be a performance hit on system processing or network bandwidth limitations.</source>
          <target state="translated">columnstoreRestore 옵션 -n [value]는 주어진 시간에 실행되는 병렬 rsync 명령의 수를 제한합니다. 기본값 5는 최대 5 개의 DBRoot가 다양한 PM에 대한 rysnc 명령을 시작 함을 의미하며 백업 시스템은 모두 완료되고 확인 될 때까지 기다립니다. 이때 다른 5 개의 DBRoot가 시작됩니다. 진행률 표시기는 개별 rysnc 명령이 아닌 전체 완료율을 반영해야합니다. 이 값은 -n 명령을 통해 더 높게 설정할 수 있지만 시스템에 존재하는 DBRoot의 수가 충분히 많으면 시스템 처리 또는 네트워크 대역폭 제한에서 성능이 저하 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="626b3e6a153a1423c3644cb7034c4fcb72d818d6" translate="yes" xml:space="preserve">
          <source>The columnstore_files table provides information about each file associated with extensions. Each extension can reuse a file at different block offsets so this is not a 1:1 relationship to the columnstore_extents table.</source>
          <target state="translated">columnstore_files 테이블은 확장자와 연관된 각 파일에 대한 정보를 제공합니다. 각 확장은 서로 다른 블록 오프셋에서 파일을 재사용 할 수 있으므로 columnstore_extents 테이블과의 1 : 1 관계가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="00e6b8f2633a29c746fb54d4ed3794315bcc3dee" translate="yes" xml:space="preserve">
          <source>The combination of these enables massive parallel processing (MPP) for query-intensive environments.</source>
          <target state="translated">이러한 조합을 통해 쿼리 집약적 인 환경에 대규모 병렬 처리 (MPP)가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="d73c491908c71fb3999f98055fa9c4c613f290f7" translate="yes" xml:space="preserve">
          <source>The comma separated list of TBL table sub-tables.</source>
          <target state="translated">쉼표로 구분 된 TBL 테이블 서브 테이블 목록.</target>
        </trans-unit>
        <trans-unit id="244887ec047399065fdc17753ad60b4fe9229a26" translate="yes" xml:space="preserve">
          <source>The command has 3 possible options:</source>
          <target state="translated">이 명령에는 3 가지 가능한 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fb2f96aa138a1e7954f505415456911a6b3fd28" translate="yes" xml:space="preserve">
          <source>The command line option influences the readable value of the &lt;a href=&quot;../server-system-variables/index#debug_sync&quot;&gt;debug_sync&lt;/a&gt; system variable.</source>
          <target state="translated">명령 행 옵션은 &lt;a href=&quot;../server-system-variables/index#debug_sync&quot;&gt;debug_sync&lt;/a&gt; 시스템 변수 의 읽기 가능한 값에 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="3083227c9b9702057305bd546af1f4ca067121e2" translate="yes" xml:space="preserve">
          <source>The command to execute (the default)</source>
          <target state="translated">실행할 명령 (기본값)</target>
        </trans-unit>
        <trans-unit id="03e3d91ed6f4653eb877f8a613c821692b31c06b" translate="yes" xml:space="preserve">
          <source>The command to execute.</source>
          <target state="translated">실행할 명령입니다.</target>
        </trans-unit>
        <trans-unit id="60a7ef1f9c8fe9d4ee0c7962442a7bc80c333b64" translate="yes" xml:space="preserve">
          <source>The command to use &lt;code&gt;mariabackup&lt;/code&gt; and the general syntax is:</source>
          <target state="translated">&lt;code&gt;mariabackup&lt;/code&gt; 및 일반 구문 을 사용하는 명령 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="96439e85a787a594933cdbf9b98cf4a3f51fdbdb" translate="yes" xml:space="preserve">
          <source>The command to use &lt;code&gt;mysql.server&lt;/code&gt; and the general syntax is:</source>
          <target state="translated">&lt;code&gt;mysql.server&lt;/code&gt; 및 일반 구문 을 사용하는 명령 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b68b80f50802630fcf9b6d6cb2e7e824fda98c10" translate="yes" xml:space="preserve">
          <source>The command to use &lt;code&gt;mysql&lt;/code&gt; and the general syntax is:</source>
          <target state="translated">&lt;code&gt;mysql&lt;/code&gt; 과 일반 구문 을 사용하는 명령 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ba20f4ebc8efd3b602cd15cc43b752b8d65b7ceb" translate="yes" xml:space="preserve">
          <source>The command to use &lt;code&gt;mysqladmin&lt;/code&gt; and the general syntax is:</source>
          <target state="translated">&lt;code&gt;mysqladmin&lt;/code&gt; 및 일반 구문 을 사용하는 명령 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="18a969115be6fcf82ac5cf7de21b8f22d5558a1e" translate="yes" xml:space="preserve">
          <source>The command to use &lt;code&gt;mysqld_multi&lt;/code&gt; and the general syntax is:</source>
          <target state="translated">&lt;code&gt;mysqld_multi&lt;/code&gt; 를 사용하는 명령 과 일반적인 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3145df2e180a420ed211c67f779298dad1f8c2a1" translate="yes" xml:space="preserve">
          <source>The command to use &lt;code&gt;mysqld_safe&lt;/code&gt; and the general syntax is:</source>
          <target state="translated">&lt;code&gt;mysqld_safe&lt;/code&gt; 를 사용하는 명령 과 일반적인 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="eaae701c69d1407413d34815fb0996f9bd07eefc" translate="yes" xml:space="preserve">
          <source>The command to use &lt;code&gt;mysqlimport&lt;/code&gt; and the general syntax is:</source>
          <target state="translated">&lt;code&gt;mysqlimport&lt;/code&gt; 및 일반 구문 을 사용하는 명령 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c89d638e14dc11ad6464fbe9782bc75f709d96e6" translate="yes" xml:space="preserve">
          <source>The command to use &lt;code&gt;mysqlslap&lt;/code&gt; and the general syntax is:</source>
          <target state="translated">&lt;code&gt;mysqlslap&lt;/code&gt; 및 일반 구문 을 사용하는 명령 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="05cc5b776bdee143fdaf047c00764026956e7c0a" translate="yes" xml:space="preserve">
          <source>The command to use &lt;code&gt;xtrabackup&lt;/code&gt; and the general syntax is:</source>
          <target state="translated">&lt;code&gt;xtrabackup&lt;/code&gt; 및 일반 구문 을 사용하는 명령 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e82c34623f602e115c7ae67db887f722ca2fea01" translate="yes" xml:space="preserve">
          <source>The command type. See &lt;a href=&quot;../thread-command-values/index&quot;&gt;Thread Command Values&lt;/a&gt;.</source>
          <target state="translated">명령 유형 &lt;a href=&quot;../thread-command-values/index&quot;&gt;스레드 명령 값을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="535462f00c1746019aba6e2ab1fa21f8fbf6cce2" translate="yes" xml:space="preserve">
          <source>The command used to import the GPG public key is the same on both Debian and Ubuntu. For example:</source>
          <target state="translated">GPG 공개 키를 가져 오는 데 사용되는 명령은 데비안과 우분투에서 동일합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1d31a5964a342dbe4afdd7f58ac4461b63bcf049" translate="yes" xml:space="preserve">
          <source>The command will do a number of checks to verify that the table data is self-consistent.</source>
          <target state="translated">이 명령은 여러 가지 검사를 수행하여 테이블 데이터가 일관성이 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="f32c861feb1073a4932684a9bc9c0b3f4bb7c478" translate="yes" xml:space="preserve">
          <source>The command:</source>
          <target state="translated">명령 :</target>
        </trans-unit>
        <trans-unit id="496a8ec24945ecf69c05d26826b04e59343db70e" translate="yes" xml:space="preserve">
          <source>The commands UPDATE, INSERT, and DELETE can be used with DBF tables. The DELETE command marks the deleted lines as suppressed but keeps them in the file. The INSERT command, if it is used to populate a newly created table, constructs the file header before inserting new lines.</source>
          <target state="translated">UPDATE, INSERT 및 DELETE 명령은 DBF 테이블과 함께 사용할 수 있습니다. DELETE 명령은 삭제 된 행을 억제 된 것으로 표시하지만 파일에 유지합니다. INSERT 명령은 새로 작성된 테이블을 채우는 데 사용되는 경우 새 행을 삽입하기 전에 파일 헤더를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="03a664ce02d955ecc4459d2bd50f3f1fff561500" translate="yes" xml:space="preserve">
          <source>The commands below will show how to make a different User Module the Master MySQL replication module. There are some cases where User Module #2 make have become the Master during a failover scenario or some other case and you want to make User Module #1 the Master once again. These are the commands to do this.</source>
          <target state="translated">아래 명령은 다른 사용자 모듈을 마스터 MySQL 복제 모듈로 만드는 방법을 보여줍니다. 장애 조치 시나리오에서 사용자 모듈 # 2 make가 마스터가 된 경우가 있거나 다른 경우가 있습니다. 이를 수행하기위한 명령이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e055d0f54abddc25c8b034e581adc98fb7ee6e3b" translate="yes" xml:space="preserve">
          <source>The commands to use for building PBXT</source>
          <target state="translated">PBXT 빌드에 사용할 명령</target>
        </trans-unit>
        <trans-unit id="f0dd5b90ef6be1c3ac8909368eaeb9feb1dcde70" translate="yes" xml:space="preserve">
          <source>The commands to use for building the &lt;a href=&quot;../compiling-mariadb-from-source/index&quot;&gt;MariaDB 5.5 source&lt;/a&gt; with PBXT:</source>
          <target state="translated">PBXT로 &lt;a href=&quot;../compiling-mariadb-from-source/index&quot;&gt;MariaDB 5.5 소스&lt;/a&gt; 를 빌드하는 데 사용할 명령 :</target>
        </trans-unit>
        <trans-unit id="4bd2642353985ab2f31f0244ddff5309396cbf7c" translate="yes" xml:space="preserve">
          <source>The comment provided in the &lt;code&gt;&lt;a href=&quot;../create-event/index&quot;&gt;CREATE EVENT&lt;/a&gt;&lt;/code&gt; statement, or an empty string if none.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../create-event/index&quot;&gt;CREATE EVENT&lt;/a&gt;&lt;/code&gt; 문에 제공된 주석 또는 비어있는 문자열 (없는 경우).</target>
        </trans-unit>
        <trans-unit id="97b160aff22e3b2342d41635d324d19da94396ed" translate="yes" xml:space="preserve">
          <source>The companion &lt;a href=&quot;../data-warehousing-techniques/index&quot;&gt;Data Warehouse article&lt;/a&gt; folds SQL #2 into the INSERT INTO Fact. But you may need host_id for further normalization steps and/or Summarization steps, so this explicit UPDATE shown here is often better.</source>
          <target state="translated">동반 &lt;a href=&quot;../data-warehousing-techniques/index&quot;&gt;데이터웨어 하우스 기사는&lt;/a&gt; SQL # 2를 INSERT INTO Fact로 접습니다. 그러나 추가 정규화 단계 및 / 또는 요약 단계를 위해 host_id가 필요할 수 있으므로 여기에 표시된이 명시 적 UPDATE가 더 좋습니다.</target>
        </trans-unit>
        <trans-unit id="18e68e7d4d6fc1af0af111b0bf92724e391c9553" translate="yes" xml:space="preserve">
          <source>The comparison operator used plays an important role. If two values are compared with &amp;lt;=&amp;gt; (see the &lt;a href=&quot;../null-safe-equal/index&quot;&gt;null-safe-equal&lt;/a&gt; comparison operator), and both are null, 1 is returned. If the same values are compared with = (see the &lt;a href=&quot;../equal/index&quot;&gt;equal&lt;/a&gt; comparison operator) null is returned. For example:</source>
          <target state="translated">사용 된 비교 연산자는 중요한 역할을합니다. 두 값이 &amp;lt;=&amp;gt;와 비교되고 ( &lt;a href=&quot;../null-safe-equal/index&quot;&gt;null-safe-equal&lt;/a&gt; 비교 연산자 참조) 둘 다 null이면 1이 반환됩니다. 동일한 값을 =와 비교 하면 ( &lt;a href=&quot;../equal/index&quot;&gt;등가&lt;/a&gt; 비교 연산자 참조 ) null이 반환됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f714c06bb3785d6df5fca8077cba68ca25614bca" translate="yes" xml:space="preserve">
          <source>The comparison operators include: !=, &amp;lt;, &amp;lt;=, &amp;lt;=&amp;gt;, &amp;gt;=, &amp;gt;, etc...</source>
          <target state="translated">비교 연산자에는! =, &amp;lt;, &amp;lt;=, &amp;lt;=&amp;gt;,&amp;gt; =,&amp;gt; 등이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9bb2973e90b60f1863fd88889286c3e84fbe12a2" translate="yes" xml:space="preserve">
          <source>The complete process of testing is governed and monitored by the &lt;em&gt;mysql-test-run.pl&lt;/em&gt; driver script, or &lt;em&gt;mtr&lt;/em&gt; for short (for convenience, &lt;code&gt;mtr&lt;/code&gt; is created as a symbolic link to &lt;code&gt;mysql-test-run.pl&lt;/code&gt;). The mtr script is responsible for preparing the test environment, creating a list of all tests to run, running them, and producing the report at the end. It can run many tests in parallel, execute tests in an order which minimizes server restarts (as they are slow), run tests in a debugger or under valgrind or strace, and so on.</source>
          <target state="translated">테스트의 전체 프로세스는 &lt;em&gt;mysql-test-run.pl&lt;/em&gt; 드라이버 스크립트 또는 &lt;em&gt;mtr&lt;/em&gt; 로 짧게 관리 및 모니터링됩니다 ( &lt;code&gt;mtr&lt;/code&gt; 은 편의상 &lt;code&gt;mysql-test-run.pl&lt;/code&gt; 에 대한 심볼릭 링크로 작성 됨 ). mtr 스크립트는 테스트 환경 준비, 실행할 모든 테스트 목록 작성, 실행 및 마지막에 보고서 작성을 담당합니다. 많은 테스트를 병렬로 실행하고, 서버 재시작을 최소화하는 순서로 테스트를 실행하고 (느리게 진행됨) 디버거 또는 valgrind 또는 strace 등에서 테스트를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="491415eab91ed1e12ba2cfd61e5257023fee1fc8" translate="yes" xml:space="preserve">
          <source>The complexity of the code is in the discovery of the PARTITION names, especially of the oldest and the 'next'.</source>
          <target state="translated">코드의 복잡성은 PARTITION 이름, 특히 가장 오래된 것과 다음 것의 발견에 있습니다.</target>
        </trans-unit>
        <trans-unit id="01c7e382a3ef4d24ad1a9f30af87d0dbfe74909c" translate="yes" xml:space="preserve">
          <source>The compressed page size, or zero if uncompressed.</source>
          <target state="translated">압축 된 페이지 크기이거나 압축되지 않은 경우 0입니다.</target>
        </trans-unit>
        <trans-unit id="1d85261d2eac3357d2a56e4d26533813f3025a73" translate="yes" xml:space="preserve">
          <source>The compression level can be set to any value between &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;9&lt;/code&gt;. The default compression level is &lt;code&gt;6&lt;/code&gt;. The range goes from the fastest to the most compact, which means that &lt;code&gt;1&lt;/code&gt; is the fastest and &lt;code&gt;9&lt;/code&gt; is the most compact.</source>
          <target state="translated">압축 수준은 &lt;code&gt;1&lt;/code&gt; 에서 &lt;code&gt;9&lt;/code&gt; 사이의 값으로 설정할 수 있습니다 . 기본 압축 수준은 &lt;code&gt;6&lt;/code&gt; 입니다. 범위는 가장 빠른 것에서 가장 작은 것까지갑니다. 즉, &lt;code&gt;1&lt;/code&gt; 이 가장 빠르고 &lt;code&gt;9&lt;/code&gt; 가 가장 작습니다.</target>
        </trans-unit>
        <trans-unit id="df187ee2172901cc9713cc311bbfd2426837d9f5" translate="yes" xml:space="preserve">
          <source>The compression level for individual tables can also be configured by setting the &lt;code&gt;&lt;a href=&quot;../create-table/index#page_compression_level&quot;&gt;PAGE_COMPRESSION_LEVEL&lt;/a&gt;&lt;/code&gt; table option for the table. For example:</source>
          <target state="translated">테이블에 대해 &lt;code&gt;&lt;a href=&quot;../create-table/index#page_compression_level&quot;&gt;PAGE_COMPRESSION_LEVEL&lt;/a&gt;&lt;/code&gt; 테이블 옵션을 설정하여 개별 테이블의 압축 레벨을 구성 할 수도 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ace4d9526a5aa9ae52a5299861dbd363625906ed" translate="yes" xml:space="preserve">
          <source>The compression level's supported values range from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;9&lt;/code&gt;. The range goes from the fastest to the most compact, which means that &lt;code&gt;1&lt;/code&gt; is the fastest and &lt;code&gt;9&lt;/code&gt; is the most compact.</source>
          <target state="translated">압축 레벨의 지원되는 값의 범위 &lt;code&gt;1&lt;/code&gt; 에 &lt;code&gt;9&lt;/code&gt; . 범위는 가장 빠른 것에서 가장 작은 것까지갑니다. 즉, &lt;code&gt;1&lt;/code&gt; 이 가장 빠르고 &lt;code&gt;9&lt;/code&gt; 가 가장 작습니다.</target>
        </trans-unit>
        <trans-unit id="08ff86346b2ed1396a4b704dffc87dcc407a10c9" translate="yes" xml:space="preserve">
          <source>The compression_ratio() procedure calculates the average compression ratio across all the compressed extents in ColumnStore. It is called using:</source>
          <target state="translated">compression_ratio () 프로시 저는 ColumnStore의 모든 압축 익스텐트에 대한 평균 압축 비율을 계산합니다. 다음을 사용하여 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="9310343571fd859234c38792efe0b64c5bfe1712" translate="yes" xml:space="preserve">
          <source>The concept of multiple tables can be extended to ODBC tables when they are physically represented by files, for instance to Excel or Access tables. The condition is that the connect string for the table must contain a field DBQ=&lt;em&gt;filename&lt;/em&gt;, in which wildcard characters can be included as for multiple=1 tables in their filename. For instance, a table contained in several Excel files CA200401.xls, CA200402.xls, ...CA200412.xls can be created by a command such as:</source>
          <target state="translated">여러 테이블의 개념은 파일로 물리적으로 표현 될 때 (예 : Excel 또는 Access 테이블) ODBC 테이블로 확장 될 수 있습니다. 조건은 테이블의 연결 문자열에 DBQ = &lt;em&gt;filename&lt;/em&gt; 필드가 포함되어야하며 , 여기서 와일드 카드 문자는 &lt;em&gt;파일 이름&lt;/em&gt; 에 여러 개의 1 테이블에 대한 와일드 카드 문자를 포함 할 수 있습니다. 예를 들어, 여러 Excel 파일 CA200401.xls, CA200402.xls, ... CA200412.xls에 포함 된 테이블은 다음과 같은 명령으로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab47dc63f41d88e467fe7e8572f72e09d4c9edef" translate="yes" xml:space="preserve">
          <source>The condition properties that can be read with GET DIAGNOSTICS are the same that can be set with SIGNAL and RESIGNAL statements. They are explained in the &lt;a href=&quot;../diagnostics-area/index&quot;&gt;diagnostics area&lt;/a&gt; page. However, there is one more property: RETURNED_SQLSTATE, which indicates the condition's &lt;a href=&quot;../sqlstate/index&quot;&gt;SQLSTATE&lt;/a&gt;.</source>
          <target state="translated">GET DIAGNOSTICS로 읽을 수있는 조건 특성은 SIGNAL 및 RESIGNAL 문으로 설정할 수있는 것과 동일합니다. &lt;a href=&quot;../diagnostics-area/index&quot;&gt;진단 영역&lt;/a&gt; 페이지에 설명되어 있습니다 . 그러나 조건의 &lt;a href=&quot;../sqlstate/index&quot;&gt;SQLSTATE&lt;/a&gt; 를 나타내는 RETURNED_SQLSTATE 특성이 하나 더 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c4d80ccf3a6bacd265b7f2afb1dc15448cdabfa5" translate="yes" xml:space="preserve">
          <source>The conditions differ depending on whether &lt;a href=&quot;../binary-log-formats/index#statement-based&quot;&gt;statement-based&lt;/a&gt; or &lt;a href=&quot;../binary-log-formats/index#row-based&quot;&gt;row-based replication&lt;/a&gt; is used.</source>
          <target state="translated">조건은 &lt;a href=&quot;../binary-log-formats/index#statement-based&quot;&gt;명령문 기반&lt;/a&gt; 또는 &lt;a href=&quot;../binary-log-formats/index#row-based&quot;&gt;행 기반 복제의&lt;/a&gt; 사용 여부에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="42db5747c0a3750103181a05fe30b8fd3df90450" translate="yes" xml:space="preserve">
          <source>The conditions for &lt;code&gt;LOAD DATA FROM MASTER&lt;/code&gt; apply here as well. For example, &lt;code&gt;LOAD TABLE FROM MASTER&lt;/code&gt; works only for MyISAM tables. The timeout notes for &lt;code&gt;LOAD DATA FROM MASTER&lt;/code&gt; apply as well.</source>
          <target state="translated">&lt;code&gt;LOAD DATA FROM MASTER&lt;/code&gt; 의 조건도 여기에 적용됩니다. 예를 들어, &lt;code&gt;LOAD TABLE FROM MASTER&lt;/code&gt; 는 MyISAM 테이블에 대해서만 작동합니다. &lt;code&gt;LOAD DATA FROM MASTER&lt;/code&gt; 에 대한 시간 초과 노트도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="94fff76148e7aab1341071557826bb33ef66a301" translate="yes" xml:space="preserve">
          <source>The config file for the S3 test system can be found at &lt;code&gt;suite/s3/my.cnf&lt;/code&gt;. To enable testing you have to edit this file and add the s3 connection options to the end of the file. It should look something like this after editing:</source>
          <target state="translated">S3 테스트 시스템의 구성 파일은 &lt;code&gt;suite/s3/my.cnf&lt;/code&gt; 에서 찾을 수 있습니다 . 테스트를 사용하려면이 파일을 편집하고 파일 끝에 s3 연결 옵션을 추가해야합니다. 편집 후 다음과 같이 보일 것입니다 :</target>
        </trans-unit>
        <trans-unit id="9f7b8ecde117003a10ef222efffcd9a9f6dcab67" translate="yes" xml:space="preserve">
          <source>The configuration file &lt;em&gt; /usr/local/spark/conf/sparks-default.conf &lt;/em&gt; should be created or updated to point to the BulkWriteAPI and ColumnStoreExporter libraries. Their paths depend on the OS you are using.</source>
          <target state="translated">구성 파일 &lt;em&gt;/usr/local/spark/conf/sparks-default.conf&lt;/em&gt; 는 BulkWriteAPI 및 ColumnStoreExporter 라이브러리를 가리 키도록 작성 또는 업데이트되어야합니다. 경로는 사용중인 OS에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="b60a426ef959496d6006ca0b1481c09562275205" translate="yes" xml:space="preserve">
          <source>The configuration file &lt;em&gt; /usr/local/spark/conf/sparks-default.conf &lt;/em&gt; should be created or updated to point to the jdbc directory:</source>
          <target state="translated">jdbc 디렉토리를 가리 키도록 &lt;em&gt;/usr/local/spark/conf/sparks-default.conf&lt;/em&gt; 구성 파일을 작성하거나 업데이트해야합니다.</target>
        </trans-unit>
        <trans-unit id="77cd2397f9bec0ca1128c9ffa4ae62165d46e46b" translate="yes" xml:space="preserve">
          <source>The configuration file for the &lt;code&gt;pam_user_map&lt;/code&gt; PAM module is &lt;code&gt;/etc/security/user_map.conf&lt;/code&gt;. Based on our hypothetical requirements, ours would look like:</source>
          <target state="translated">&lt;code&gt;pam_user_map&lt;/code&gt; PAM 모듈 의 구성 파일 은 &lt;code&gt;/etc/security/user_map.conf&lt;/code&gt; 입니다. 우리의 가상 요구 사항에 따라 다음과 같이 보입니다.</target>
        </trans-unit>
        <trans-unit id="734b67c7248650a8358fe7ca6066bf7500a54eff" translate="yes" xml:space="preserve">
          <source>The configuration parameters are maintained in the /usr/local/mariadb/columnstore/etc/Columnstore.xml file. In a multiple server deployment these should only be edited on the PM1 server as this will be automatically replicated to other servers by the system. A system restart will be required for the configuration change to take affect.</source>
          <target state="translated">구성 매개 변수는 /usr/local/mariadb/columnstore/etc/Columnstore.xml 파일에서 유지 보수됩니다. 다중 서버 배포에서는 시스템에 의해 다른 서버에 자동으로 복제되므로 PM1 서버에서만 편집해야합니다. 구성 변경 사항을 적용하려면 시스템을 다시 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="3d1608aa430d2b6f4df8c01181f2c5eb57689aa1" translate="yes" xml:space="preserve">
          <source>The configured value of the &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#slave_parallel_max_queued&quot;&gt;slave_parallel_max_queued&lt;/a&gt;&lt;/code&gt; system variable is actually allocated for each &lt;a href=&quot;../replication-threads/index#worker-threads&quot;&gt;worker thread&lt;/a&gt;, so the total allocation is actually equivalent to the following:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#slave_parallel_max_queued&quot;&gt;slave_parallel_max_queued&lt;/a&gt;&lt;/code&gt; 시스템 변수 의 구성된 값 은 실제로 각 &lt;a href=&quot;../replication-threads/index#worker-threads&quot;&gt;작업자 스레드&lt;/a&gt; 에 할당되므로 총 할당량은 실제로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9756164f2bc8b5d05cd48f5472252bbde3cc5207" translate="yes" xml:space="preserve">
          <source>The configured value of this system variable is actually allocated for each &lt;a href=&quot;../replication-threads/index#worker-threads&quot;&gt;worker thread&lt;/a&gt;, so the total allocation is actually equivalent to the following:</source>
          <target state="translated">이 시스템 변수의 구성된 값은 실제로 각 &lt;a href=&quot;../replication-threads/index#worker-threads&quot;&gt;작업자 스레드&lt;/a&gt; 에 할당되므로 총 할당량은 실제로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5e231cc26422804eb0e0e5aab3845f11b53c9d8c" translate="yes" xml:space="preserve">
          <source>The connect options given to &lt;code&gt;mysql_upgrade&lt;/code&gt; are passed along to &lt;a href=&quot;../mysqlcheck/index&quot;&gt;mysqlcheck&lt;/a&gt; and &lt;a href=&quot;../mysql-command-line-client/index&quot;&gt;mysql&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;mysql_upgrade&lt;/code&gt; 에 지정된 연결 옵션 은 &lt;a href=&quot;../mysqlcheck/index&quot;&gt;mysqlcheck&lt;/a&gt; 및 &lt;a href=&quot;../mysql-command-line-client/index&quot;&gt;mysql에&lt;/a&gt; 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="72dcec72419505e3be63f73100269098f73a7a91" translate="yes" xml:space="preserve">
          <source>The connect_json_grp_size variable cannot be accessed. The group size is set to 100.</source>
          <target state="translated">connect_json_grp_size 변수에 액세스 할 수 없습니다. 그룹 크기는 100으로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f235c7957c0ee439a3363d991edca2b63ab7fb8" translate="yes" xml:space="preserve">
          <source>The connection client's host name, or NULL if an internal thread.</source>
          <target state="translated">연결 클라이언트의 호스트 이름이거나 내부 스레드 인 경우 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="69f572b7b84ab3cd55168bd299f421316f7f45ee" translate="yes" xml:space="preserve">
          <source>The connection handle.</source>
          <target state="translated">연결 핸들.</target>
        </trans-unit>
        <trans-unit id="891ed311c5cccb44872bd06b24c545e3028ebc48" translate="yes" xml:space="preserve">
          <source>The connection name may include any characters and should be less than 64 characters. Connection names are compared without regard to case (case insensitive). You should preferably keep the connection name short as it will be used as a suffix for relay logs and master info index files.</source>
          <target state="translated">연결 이름에는 문자가 포함될 수 있으며 64 자 이하 여야합니다. 대소 문자를 구분하지 않고 연결 이름을 비교합니다 (대소 문자 구분). 릴레이 로그 및 마스터 정보 인덱스 파일의 접미사로 사용되므로 연결 이름을 짧게 유지하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f3ff6c6aca9352e6b72398f536b676a909b641e6" translate="yes" xml:space="preserve">
          <source>The connection protocol (tcp, socket, pipe, memory) to use for connecting to the server. Useful when other connection parameters would cause a protocol to be used other than the one you want.</source>
          <target state="translated">서버 연결에 사용할 연결 프로토콜 (tcp, 소켓, 파이프, 메모리) 다른 연결 매개 변수로 인해 원하는 프로토콜 이외의 프로토콜이 사용되는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="eb633794c6915019dc6861540e69441599064e95" translate="yes" xml:space="preserve">
          <source>The connection protocol to use for connecting to the server (TCP, SOCKET, PIPE, MEMORY). It is useful when the other connection parameters normally would cause a protocol to be used other than the one you want.</source>
          <target state="translated">서버 연결에 사용할 연결 프로토콜 (TCP, SOCKET, PIPE, MEMORY). 다른 연결 매개 변수가 일반적으로 원하는 프로토콜 이외의 다른 프로토콜을 사용하게 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b17a2145d82879976aa62b405b63d6779ad453a2" translate="yes" xml:space="preserve">
          <source>The connection string can have the same syntax as that used by FEDERATED</source>
          <target state="translated">연결 문자열은 FEDERATED에서 사용 된 것과 동일한 구문을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f14f7dbf4e40d1f9509fbbb67fac9074ca2d1782" translate="yes" xml:space="preserve">
          <source>The connection string, when specified for the table, is lost by the partition engine. The workaround is to specify the connection string in the &lt;em&gt;option_list&lt;/em&gt;.</source>
          <target state="translated">테이블에 지정된 연결 문자열은 파티션 엔진에 의해 유실됩니다. 해결 방법은 &lt;em&gt;option_list에&lt;/em&gt; 연결 문자열을 지정하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="f3ee61c430698fe7e088934f8a63d6881912c0f7" translate="yes" xml:space="preserve">
          <source>The connection user name.</source>
          <target state="translated">연결 사용자 이름</target>
        </trans-unit>
        <trans-unit id="3867e50d1a39a289988c231ba0be156d484f7032" translate="yes" xml:space="preserve">
          <source>The connection's client user name for the connection, or &lt;code&gt;NULL&lt;/code&gt; if an internal thread.</source>
          <target state="translated">연결에 대한 연결의 클라이언트 사용자 이름이거나 내부 스레드 인 경우 &lt;code&gt;NULL&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0ee1f6e45239bbe51865eafacd2058ee4e54cd6a" translate="yes" xml:space="preserve">
          <source>The connection's client user name for the connection, or NULL if an internal thread.</source>
          <target state="translated">연결에 대한 연결의 클라이언트 사용자 이름이거나 내부 스레드 인 경우 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="e4f805ede78f986cb649705501d8cacb10d13e69" translate="yes" xml:space="preserve">
          <source>The connector implemented support for this authentication plugin in a separate &lt;a href=&quot;https://docs.microsoft.com/en-us/nuget/what-is-nuget&quot;&gt;NuGet&lt;/a&gt; package called &lt;code&gt;&lt;a href=&quot;https://www.nuget.org/packages/MySqlConnector.Authentication.Ed25519/&quot;&gt;MySqlConnector.Authentication.Ed25519&lt;/a&gt;&lt;/code&gt;. After the package is installed, your application must call &lt;code&gt;Ed25519AuthenticationPlugin.Install&lt;/code&gt; to enable it.</source>
          <target state="translated">별도의에서이 인증 플러그인 커넥터 구현 지원 &lt;a href=&quot;https://docs.microsoft.com/en-us/nuget/what-is-nuget&quot;&gt;NuGet의&lt;/a&gt; 패키지라는 &lt;code&gt;&lt;a href=&quot;https://www.nuget.org/packages/MySqlConnector.Authentication.Ed25519/&quot;&gt;MySqlConnector.Authentication.Ed25519&lt;/a&gt;&lt;/code&gt; 을 . 패키지가 설치되면 응용 프로그램에서 &lt;code&gt;Ed25519AuthenticationPlugin.Install&lt;/code&gt; 을 호출 하여 활성화해야합니다.</target>
        </trans-unit>
        <trans-unit id="0672bcd10ee4ba10b1cf01ce12b3ff22d995f533" translate="yes" xml:space="preserve">
          <source>The constants TRUE and FALSE evaluate to 1 and 0, respectively. The constant names can be written in any lettercase.</source>
          <target state="translated">상수 TRUE 및 FALSE는 각각 1과 0으로 평가됩니다. 상수 이름은 모든 소문자로 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8bd71afab29c771f747cb67bdae749daa083ec1" translate="yes" xml:space="preserve">
          <source>The constructed SQL statement is sent to the Foreign data source through libmysql using the mysql client API</source>
          <target state="translated">생성 된 SQL 문은 mysql 클라이언트 API를 사용하여 libmysql을 통해 외부 데이터 소스로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="55e4df8cac7666997e1ac9bdbadb86024484c358" translate="yes" xml:space="preserve">
          <source>The container can also be stopped like this:</source>
          <target state="translated">컨테이너는 다음과 같이 멈출 수도 있습니다 :</target>
        </trans-unit>
        <trans-unit id="44fcff1e95fb354cfdca498589f22e7f87632c52" translate="yes" xml:space="preserve">
          <source>The container will not be destroyed by this command. The data will still live inside the container, even if MariaDB is not running. To restart the container and see our data, we can issue:</source>
          <target state="translated">컨테이너는이 명령으로 파괴되지 않습니다. MariaDB가 실행 중이 아니더라도 데이터는 컨테이너 내부에 계속 남아 있습니다. 컨테이너를 다시 시작하고 데이터를 보려면 다음을 발행하십시오.</target>
        </trans-unit>
        <trans-unit id="a4b39279ef79795a67d0f65f375c5ff8141eb2d4" translate="yes" xml:space="preserve">
          <source>The contents of the log tables is not logged in the &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt; thus cannot be replicated.</source>
          <target state="translated">로그 테이블의 내용은 &lt;a href=&quot;../binary-log/index&quot;&gt;이진 로그에 기록&lt;/a&gt; 되지 않으므로 복제 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c337ea037c6fe6b7ff1eba81d4f4c5432f8f7eab" translate="yes" xml:space="preserve">
          <source>The conversion happens if the following conditions are met:</source>
          <target state="translated">다음 조건이 충족되면 변환이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="904796503414cb8da4b325284b826ff6886c0716" translate="yes" xml:space="preserve">
          <source>The conversion rules are as follows: if the identifier is made up only of basic Latin numbers, letters and/or the underscore character, the encoding matches the name (see however &lt;a href=&quot;../identifier-case-sensitivity/index&quot;&gt;Identifier Case Sensitivity&lt;/a&gt;). Otherwise they are encoded according to the following table:</source>
          <target state="translated">변환 규칙은 다음과 같습니다. 식별자가 기본 라틴 숫자, 문자 및 밑줄 문자로만 구성된 경우 인코딩이 이름과 일치합니다 (그러나 &lt;a href=&quot;../identifier-case-sensitivity/index&quot;&gt;식별자 대소&lt;/a&gt; 문자 구분 참조 ). 그렇지 않으면 다음 표에 따라 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="ef8868c024f51ebacc5307310573e8c2f748d007" translate="yes" xml:space="preserve">
          <source>The coordinates will be in the &lt;code&gt;&lt;a href=&quot;../files-created-by-mariabackup/index#xtrabackup_binlog_info&quot;&gt;xtrabackup_binlog_info&lt;/a&gt;&lt;/code&gt; file.</source>
          <target state="translated">좌표는 &lt;code&gt;&lt;a href=&quot;../files-created-by-mariabackup/index#xtrabackup_binlog_info&quot;&gt;xtrabackup_binlog_info&lt;/a&gt;&lt;/code&gt; 파일에 있습니다.</target>
        </trans-unit>
        <trans-unit id="164cf0c9c8ab6d96eb1dc3fddadf94203d3dbf03" translate="yes" xml:space="preserve">
          <source>The core server.</source>
          <target state="translated">핵심 서버.</target>
        </trans-unit>
        <trans-unit id="f2603518d4d873b7b266fd277970b5ea9aece26b" translate="yes" xml:space="preserve">
          <source>The correct path should have been &amp;lsquo;second:*&amp;rsquo; (or from &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1028-release-notes/&quot;&gt;MariaDB 10.2.8&lt;/a&gt;, &amp;lsquo;second.*&amp;rsquo;), but in this simple case the function was able to make it right. The returned item:</source>
          <target state="translated">올바른 경로는 'second : *'(또는 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1028-release-notes/&quot;&gt;MariaDB 10.2.8&lt;/a&gt; , 'second. *') 여야 하지만이 간단한 경우 함수가 올바르게 수행 할 수있었습니다. 반품 된 상품 :</target>
        </trans-unit>
        <trans-unit id="87268a5e812152d7eaca64723306c3087ef9eee9" translate="yes" xml:space="preserve">
          <source>The correlation coefficient for non-null pairs in a group.</source>
          <target state="translated">그룹에서 널이 아닌 쌍에 대한 상관 계수입니다.</target>
        </trans-unit>
        <trans-unit id="dd5dbd06d7741b42d1fb0c31a2ba2ba5bb6592e7" translate="yes" xml:space="preserve">
          <source>The corresponding &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt; position of the current &lt;a href=&quot;../relay-log/index&quot;&gt;relay log&lt;/a&gt; position of the slave's SQL thread can be checked by executing the &lt;code&gt;&lt;a href=&quot;../show-slave-status/index&quot;&gt;SHOW SLAVE STATUS&lt;/a&gt;&lt;/code&gt; statement. It will be shown as the &lt;code&gt;Relay_Master_Log_File&lt;/code&gt; and &lt;code&gt;Exec_Master_Log_Pos&lt;/code&gt; columns.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../show-slave-status/index&quot;&gt;SHOW SLAVE STATUS&lt;/a&gt;&lt;/code&gt; 문 을 실행하여 슬레이브 SQL 스레드의 현재 &lt;a href=&quot;../relay-log/index&quot;&gt;릴레이 로그&lt;/a&gt; 위치의 해당 &lt;a href=&quot;../binary-log/index&quot;&gt;2 진 로그&lt;/a&gt; 위치를 확인할 수 있습니다 . 그것은로 표시됩니다 &lt;code&gt;Relay_Master_Log_File&lt;/code&gt; 및 &lt;code&gt;Exec_Master_Log_Pos&lt;/code&gt; 열.</target>
        </trans-unit>
        <trans-unit id="ac3fe4e967fa4f2f0f62aa3c4f33a557c3ff6cfd" translate="yes" xml:space="preserve">
          <source>The corresponding java jar must be also be included in the java classpath. The packaged install is built and tested with OpenJDK 8.</source>
          <target state="translated">해당 java jar도 java 클래스 경로에 포함되어야합니다. 패키지 설치는 OpenJDK 8로 빌드 및 테스트되었습니다.</target>
        </trans-unit>
        <trans-unit id="1e2402448922edf51241fd4a9a9aba53521d45fd" translate="yes" xml:space="preserve">
          <source>The corresponding row in the table is deleted when a connection terminates.</source>
          <target state="translated">연결이 종료되면 테이블의 해당 행이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="69583d0106f4e72ac977ab3ae090689caad6d593" translate="yes" xml:space="preserve">
          <source>The count can be reset for all users using &lt;code&gt;&lt;a href=&quot;../flush/index&quot;&gt;FLUSH USER_RESOURCES&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../flush/index&quot;&gt;FLUSH PRIVILEGES&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../mysqladmin/index&quot;&gt;mysqladmin reload&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../flush/index&quot;&gt;FLUSH USER_RESOURCES&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../flush/index&quot;&gt;FLUSH PRIVILEGES&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../mysqladmin/index&quot;&gt;mysqladmin reload&lt;/a&gt;&lt;/code&gt; 를 사용하여 모든 사용자의 수를 재설정 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3452f705802fbfa996a26dc5bd3ba944dd62b637" translate="yes" xml:space="preserve">
          <source>The count of rows affected by &lt;code&gt;TRUNCATE TABLE&lt;/code&gt; is accurate only when it is mapped to a &lt;code&gt;DELETE&lt;/code&gt; statement.</source>
          <target state="translated">&lt;code&gt;TRUNCATE TABLE&lt;/code&gt; 의 영향을받는 행 수는 &lt;code&gt;DELETE&lt;/code&gt; 문에 매핑 된 경우에만 정확 합니다.</target>
        </trans-unit>
        <trans-unit id="c890db0325ffba9e04c3db388c012aa7bcbe98d9" translate="yes" xml:space="preserve">
          <source>The create table statement shall be like this:</source>
          <target state="translated">테이블 생성 명령문은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="efd19884103c739b8ecd0f9d5dda73b30d2a1ad1" translate="yes" xml:space="preserve">
          <source>The create table will simply create the .frm file, and within the &lt;code&gt;CREATE TABLE
&lt;/code&gt; SQL statement, there SHALL be any of the following :</source>
          <target state="translated">create 테이블은 단순히 .frm 파일을 생성하고 &lt;code&gt;CREATE TABLE &lt;/code&gt; SQL 문 내에 다음 중 하나가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="2282fd279bef4bbe36b144f5af7de6357874e6fc" translate="yes" xml:space="preserve">
          <source>The creation of some temporary tables could not be rolled back.</source>
          <target state="translated">일부 임시 테이블 작성을 롤백 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6e23f7e929d93340e42b71dfdaf0283fda8a44b9" translate="yes" xml:space="preserve">
          <source>The creator of a routine is the account that ran the &lt;code&gt;&lt;a href=&quot;../create-function/index&quot;&gt;CREATE FUNCTION&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../create-procedure/index&quot;&gt;CREATE PROCEDURE&lt;/a&gt;&lt;/code&gt; statement, regardless of whether a &lt;code&gt;DEFINER&lt;/code&gt; is provided. The definer is by default the creator unless otherwise specified.</source>
          <target state="translated">루틴 작성자 는 &lt;code&gt;DEFINER&lt;/code&gt; 제공 여부에 관계없이 &lt;code&gt;&lt;a href=&quot;../create-function/index&quot;&gt;CREATE FUNCTION&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../create-procedure/index&quot;&gt;CREATE PROCEDURE&lt;/a&gt;&lt;/code&gt; 문 을 실행 한 계정입니다 . 별도의 지정이없는 한 기본적으로 정의자는 작성자입니다.</target>
        </trans-unit>
        <trans-unit id="1ef339c8500c72e064f5768d0fec0c4322fb6c85" translate="yes" xml:space="preserve">
          <source>The credentials file will need to be readable by the &quot;mysql&quot; user, but it does not need to be readable by any other user.</source>
          <target state="translated">자격 증명 파일은 &quot;mysql&quot;사용자가 읽을 수 있어야하지만 다른 사용자가 읽을 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="5b947b05874b09aeb17753e93c3f5e2df944f75c" translate="yes" xml:space="preserve">
          <source>The cumulative CPU time elapsed while servicing this client's connections. Note that this number may be wrong on SMP system if there was a CPU migration for the thread during the execution of the query.</source>
          <target state="translated">이 클라이언트의 연결을 서비스하는 동안 누적 CPU 시간이 경과했습니다. 쿼리 실행 중 스레드에 대한 CPU 마이그레이션이있는 경우 SMP 시스템에서이 숫자가 잘못 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61983fd84a3654623d21adb86141122b64bbaf04" translate="yes" xml:space="preserve">
          <source>The cumulative CPU time elapsed while servicing this user's connections.</source>
          <target state="translated">이 사용자의 연결을 처리하는 동안 누적 CPU 시간이 경과했습니다.</target>
        </trans-unit>
        <trans-unit id="0e90b2bd12e4c18f1a6f1b469bd608b563fe0bfc" translate="yes" xml:space="preserve">
          <source>The cumulative number of seconds elapsed while there were connections from this client.</source>
          <target state="translated">이 클라이언트에서 연결하는 동안 누적 시간 (초)이 경과했습니다.</target>
        </trans-unit>
        <trans-unit id="db135890710274c0fdd0176f253945741a6805b9" translate="yes" xml:space="preserve">
          <source>The cumulative number of seconds elapsed while there were connections from this user.</source>
          <target state="translated">이 사용자로부터 연결하는 동안 누적 시간 (초)이 경과했습니다.</target>
        </trans-unit>
        <trans-unit id="66c3cefc5eead98e1f6f62fa9d32c547d003ef47" translate="yes" xml:space="preserve">
          <source>The cumulative number of seconds there was activity on connections from this client.</source>
          <target state="translated">이 클라이언트의 연결에 대한 활동이 누적 된 시간 (초)입니다.</target>
        </trans-unit>
        <trans-unit id="4f2a8328167fa77c7ae8066a6eefad5ef8623893" translate="yes" xml:space="preserve">
          <source>The cumulative number of seconds there was activity on connections from this user.</source>
          <target state="translated">이 사용자의 연결에 대한 활동이 누적 된 시간 (초)입니다.</target>
        </trans-unit>
        <trans-unit id="f1cdbc63856586cb4dd56c0a87f1c1a984664dc8" translate="yes" xml:space="preserve">
          <source>The current &lt;a href=&quot;../what-is-mariadb-galera-cluster/index#galera-versions&quot;&gt;versions&lt;/a&gt; of the Galera wsrep provider library are &lt;code&gt;26.4.2&lt;/code&gt; for &lt;a href=&quot;../galera/index&quot;&gt;Galera&lt;/a&gt; 4 and &lt;code&gt;25.3.27&lt;/code&gt; for &lt;a href=&quot;../galera/index&quot;&gt;Galera&lt;/a&gt; 3.</source>
          <target state="translated">현재 &lt;a href=&quot;../what-is-mariadb-galera-cluster/index#galera-versions&quot;&gt;버전&lt;/a&gt; 갈레 wsrep 제공 라이브러리는 &lt;code&gt;26.4.2&lt;/code&gt; 에 대한 &lt;a href=&quot;../galera/index&quot;&gt;갈레&lt;/a&gt; 4 &lt;code&gt;25.3.27&lt;/code&gt; 에 대한 &lt;a href=&quot;../galera/index&quot;&gt;갈레&lt;/a&gt; 3.</target>
        </trans-unit>
        <trans-unit id="77a93b3ecea20584d97a3714a0f8d290fd54d947" translate="yes" xml:space="preserve">
          <source>The current CONNECT handler is a GA (stable) release. It was written starting both from an aborted project written for MySQL in 2004 and from the &amp;ldquo;DBCONNECT&amp;rdquo; program. It was tested on all the examples described in this document, and is distributed with a set of 53 test cases. Here is a not limited list of future developments:</source>
          <target state="translated">현재 CONNECT 핸들러는 GA (stable) 릴리스입니다. 2004 년 MySQL 용으로 작성된 중단 된 프로젝트와 &quot;DBCONNECT&quot;프로그램에서 시작되었습니다. 이 문서에 설명 된 모든 예제에서 테스트되었으며 53 개의 테스트 사례와 함께 배포됩니다. 다음은 향후 개발의 제한 목록이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="c0c33b43c829443451f87150ec5d79367dd62167" translate="yes" xml:space="preserve">
          <source>The current CONNECT handler is a stable release.</source>
          <target state="translated">현재 CONNECT 핸들러는 안정적인 릴리스입니다.</target>
        </trans-unit>
        <trans-unit id="e85b5458d4d79d6a841229aac56abb3831501e48" translate="yes" xml:space="preserve">
          <source>The current DB name</source>
          <target state="translated">현재 DB 이름</target>
        </trans-unit>
        <trans-unit id="6d3435c9f86003c928aeef0c797b4a90292a53ef" translate="yes" xml:space="preserve">
          <source>The current INDEXes will encourage an order.</source>
          <target state="translated">현재 인덱스는 주문을 권장합니다.</target>
        </trans-unit>
        <trans-unit id="87e576def481a20ee8ecf963263ad6b9bff13184" translate="yes" xml:space="preserve">
          <source>The current MariaDB thread pool was implemented in &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt;. It replaced the legacy thread pool that was introduced in &lt;a href=&quot;../what-is-mariadb-51/index&quot;&gt;MariaDB 5.1&lt;/a&gt;. The main drawback of the previous solution was that this pool was static&amp;ndash;it had a fixed number of threads. Static thread pools can have their merits, for some limited use cases, such as cases where callbacks executed by the threads never block and do not depend on each other. For example, iimagine something like an echo server.</source>
          <target state="translated">현재 MariaDB 스레드 풀은 &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt; 에서 구현되었습니다 . &lt;a href=&quot;../what-is-mariadb-51/index&quot;&gt;MariaDB 5.1&lt;/a&gt; 에 도입 된 레거시 스레드 풀을 대체했습니다 . 이전 솔루션의 주요 단점은이 풀이 정적 인 것이므로 고정 된 수의 스레드가 있다는 것입니다. 정적 스레드 풀은 스레드에 의해 실행되는 콜백이 절대로 차단되지 않고 서로 의존하지 않는 경우와 같은 일부 제한된 사용 사례의 장점을 가질 수 있습니다. 예를 들어, 에코 서버와 같은 것을 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="ea2eb397b548d6f806eb87724977a5081f262e08" translate="yes" xml:space="preserve">
          <source>The current TCP/IP port or socket file.</source>
          <target state="translated">현재 TCP / IP 포트 또는 소켓 파일</target>
        </trans-unit>
        <trans-unit id="a37eacb9cb6b97a84b308bb443ec962cd273d864" translate="yes" xml:space="preserve">
          <source>The current day of the week in three-letter format (Mon, Tue, ...).</source>
          <target state="translated">요일은 3 글자 형식 (Mon, Tue, ...)입니다.</target>
        </trans-unit>
        <trans-unit id="c2f911c67feda4a99fb96585162a79f72d801e17" translate="yes" xml:space="preserve">
          <source>The current delimiter.</source>
          <target state="translated">현재 분리 문자.</target>
        </trans-unit>
        <trans-unit id="b1180aa3bbcd892ab5190254a960b4535d8a7ff6" translate="yes" xml:space="preserve">
          <source>The current directory (sql/data) is also placed by CONNECT at the beginning of the class path.</source>
          <target state="translated">현재 디렉토리 (sql / data)는 클래스 경로의 시작 부분에 CONNECT에 의해 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="c6cb9e565b3158599f61f6ed064e490361d2fe72" translate="yes" xml:space="preserve">
          <source>The current global server time zone can be viewed by looking at the global value of the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#time_zone&quot;&gt;time_zone&lt;/a&gt;&lt;/code&gt; system variable. For example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../server-system-variables/index#time_zone&quot;&gt;time_zone&lt;/a&gt;&lt;/code&gt; 시스템 변수 의 전역 값을 보면 현재 전역 서버 시간대를 볼 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="67bb97dbdf0dfc17086e85e30646df5fcf55b690" translate="yes" xml:space="preserve">
          <source>The current goal is to keep the code stable and fix all bugs.</source>
          <target state="translated">현재 목표는 코드를 안정적으로 유지하고 모든 버그를 수정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2cef57123a5b729b69a9336ab7f6df7df668d16c" translate="yes" xml:space="preserve">
          <source>The current month in numeric format.</source>
          <target state="translated">현재 월을 숫자 형식으로 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="86a74788454a732660afa3e0a2f29ad06eb52009" translate="yes" xml:space="preserve">
          <source>The current month in three-letter format (Jan, Feb, ...).</source>
          <target state="translated">현재 3 개월 형식의 월 (1 월, 2 월, ...).</target>
        </trans-unit>
        <trans-unit id="bd9412e0e508a2107cb05d786c3fd441ff100ca3" translate="yes" xml:space="preserve">
          <source>The current package install supports Python 2.7 and Python 3. Once installed the library is available for immediate use on the system. A dedicated Python usage documentation was added with version 1.1.6.</source>
          <target state="translated">현재 패키지 설치는 Python 2.7 및 Python 3을 지원합니다. 일단 설치되면 라이브러리를 시스템에서 즉시 사용할 수 있습니다. 전용 Python 사용 설명서가 버전 1.1.6과 함께 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="69f10ba50da2e9195e9769e393673b804420fdd8" translate="yes" xml:space="preserve">
          <source>The current role is in the &lt;a href=&quot;../information-schema-enabled_roles-table/index&quot;&gt;ENABLED_ROLES&lt;/a&gt; Information Schema table.</source>
          <target state="translated">현재 역할은 &lt;a href=&quot;../information-schema-enabled_roles-table/index&quot;&gt;ENABLED_ROLES&lt;/a&gt; 정보 스키마 테이블에 있습니다.</target>
        </trans-unit>
        <trans-unit id="eed10dbeaa148aa890fd250a3ca460d8df197379" translate="yes" xml:space="preserve">
          <source>The current row and the following row:</source>
          <target state="translated">현재 행과 다음 행 :</target>
        </trans-unit>
        <trans-unit id="b5e24b391d2055f1e6bed5dc79bffad159bba92b" translate="yes" xml:space="preserve">
          <source>The current session time zone can be viewed by looking at the session value of the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#time_zone&quot;&gt;time_zone&lt;/a&gt;&lt;/code&gt; system variable. For example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../server-system-variables/index#time_zone&quot;&gt;time_zone&lt;/a&gt;&lt;/code&gt; 시스템 변수 의 세션 값을 보면 현재 세션 시간대를 볼 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3d1856c6f903a392c5b792d8cf37f75c0e637072" translate="yes" xml:space="preserve">
          <source>The current time in seconds</source>
          <target state="translated">현재 시간 (초)</target>
        </trans-unit>
        <trans-unit id="0404c690bd07ca3222a423fd879d7567ecac5bb5" translate="yes" xml:space="preserve">
          <source>The current time, in 24-hour military time (0&amp;ndash;23).</source>
          <target state="translated">24 시간제 (0&amp;ndash;23)의 현재 시간입니다.</target>
        </trans-unit>
        <trans-unit id="b01cdf85c31a609f47f9f222ff851153039a67e8" translate="yes" xml:space="preserve">
          <source>The current time, standard 12-hour time (1&amp;ndash;12).</source>
          <target state="translated">현재 시간, 표준 12 시간 시간 (1&amp;ndash;12).</target>
        </trans-unit>
        <trans-unit id="e250e80fec944a05c137c64252ee75edc980eb42" translate="yes" xml:space="preserve">
          <source>The current umask can be determined by running the 'umask' command: A value of 022 can be set in the current session or in /etc/profile with the command:</source>
          <target state="translated">'umask'명령을 실행하여 현재 umask를 판별 할 수 있습니다. 022 값은 현재 세션 또는 / etc / profile에서 다음 명령으로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c145e8b947ef4ff7ae8d0b60a2e6ecd2fe2fa053" translate="yes" xml:space="preserve">
          <source>The current umask can be determined:</source>
          <target state="translated">현재 umask를 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8a9c40731fee07ea77848c2de2a63617236f1c9" translate="yes" xml:space="preserve">
          <source>The current user</source>
          <target state="translated">현재 사용자</target>
        </trans-unit>
        <trans-unit id="ea4f8786f7dcae128a043bced3d6196eef2fb587" translate="yes" xml:space="preserve">
          <source>The current user is invalid.</source>
          <target state="translated">현재 사용자가 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fd0a78cc820e4a1fffc38afd09cf778f0ee83584" translate="yes" xml:space="preserve">
          <source>The current version of Aria is 1.5. The goal of this release is to develop a crash-safe alternative to MyISAM. That is, when MariaDB restarts after a crash, Aria recovers all tables to the state as of the start of a statement or at the start of the last &lt;code&gt;LOCK TABLES&lt;/code&gt; statement.</source>
          <target state="translated">Aria의 현재 버전은 1.5입니다. 이 릴리스의 목표는 MyISAM에 대한 충돌 방지 대안을 개발하는 것입니다. 즉, 충돌 후 MariaDB가 다시 시작되면 Aria는 모든 테이블을 명령문 시작 시점 또는 마지막 &lt;code&gt;LOCK TABLES&lt;/code&gt; 문 시작 시점의 상태로 복구합니다 .</target>
        </trans-unit>
        <trans-unit id="ba34adb66cf7bde98ac8aed3476e1e0a42b26824" translate="yes" xml:space="preserve">
          <source>The current year, four digits.</source>
          <target state="translated">현재 연도, 네 자리 숫자.</target>
        </trans-unit>
        <trans-unit id="73b46b013c1171a770717f1030ee09e971998fc0" translate="yes" xml:space="preserve">
          <source>The current year, two digits.</source>
          <target state="translated">현재 연도, 두 자리 숫자</target>
        </trans-unit>
        <trans-unit id="2b0a9adb0c9f6296280b5571ed74936d6d7156fc" translate="yes" xml:space="preserve">
          <source>The currently executing statement does not affect the value of LAST_INSERT_ID(). Suppose that you generate an AUTO_INCREMENT value with one statement, and then refer to LAST_INSERT_ID() in a multiple-row INSERT statement that inserts rows into a table with its own AUTO_INCREMENT column. The value of LAST_INSERT_ID() will remain stable in the second statement; its value for the second and later rows is not affected by the earlier row insertions. (However, if you mix references to LAST_INSERT_ID() and LAST_INSERT_ID(expr), the effect is undefined.)</source>
          <target state="translated">현재 실행중인 명령문은 LAST_INSERT_ID ()의 값에 영향을 미치지 않습니다. 하나의 명령문으로 AUTO_INCREMENT 값을 생성 한 다음 자체 AUTO_INCREMENT 컬럼이있는 테이블에 행을 삽입하는 다중 행 INSERT 문에서 LAST_INSERT_ID ()를 참조한다고 가정하십시오. LAST_INSERT_ID ()의 값은 두 번째 명령문에서 안정적으로 유지됩니다. 두 번째 및 이후 행에 대한 값은 이전 행 삽입의 영향을받지 않습니다. 그러나 LAST_INSERT_ID () 및 LAST_INSERT_ID (expr)에 대한 참조를 혼합하면 효과가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="39ddffe963dad9522001c346e346b03d2cbb21f8" translate="yes" xml:space="preserve">
          <source>The currently used port</source>
          <target state="translated">현재 사용 된 포트</target>
        </trans-unit>
        <trans-unit id="89d51c846ec589605edef386937c1fdc531a2d54" translate="yes" xml:space="preserve">
          <source>The daemon's executable is &lt;code&gt;mariadbd&lt;/code&gt;, not &lt;code&gt;mysqld&lt;/code&gt;. You should take this into account if you have scripts, tools, or workflows that look for processes named &quot;mysqld&quot;. You can also invoke &lt;code&gt;mysqld&lt;/code&gt; to start the server; edit /Library/LaunchDaemons/com.mariadb.server.plist if you want to do that permanently.</source>
          <target state="translated">데몬의 실행은 &lt;code&gt;mariadbd&lt;/code&gt; 하지 &lt;code&gt;mysqld&lt;/code&gt; 를 . &quot;mysqld&quot;라는 프로세스를 찾는 스크립트, 도구 또는 워크 플로우가있는 경우이를 고려해야합니다. &lt;code&gt;mysqld&lt;/code&gt; 를 호출 하여 서버를 시작할 수도 있습니다 . 영구적으로 수행하려면 /Library/LaunchDaemons/com.mariadb.server.plist를 편집하십시오.</target>
        </trans-unit>
        <trans-unit id="a818bcef8604c2c52c7916463cd0d2a4913d9db8" translate="yes" xml:space="preserve">
          <source>The data and the PRIMARY KEY are &quot;clustered&quot; together in on BTree.</source>
          <target state="translated">데이터와 기본 키는 BTree에서 &quot;클러스터&quot;됩니다.</target>
        </trans-unit>
        <trans-unit id="d68103163e276c4fc54ffd1fe53a7dcdcc1ec753" translate="yes" xml:space="preserve">
          <source>The data can then be loaded into the simpletable table with the following syntax:</source>
          <target state="translated">그런 다음 다음 구문을 사용하여 단순 테이블에 데이터를로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b7f4a21ca192f08a0b5d256c565c2f38b623000" translate="yes" xml:space="preserve">
          <source>The data directory for the server.</source>
          <target state="translated">서버의 데이터 디렉토리</target>
        </trans-unit>
        <trans-unit id="0ff9e533776312499aa4fac3b05feb0756b76305" translate="yes" xml:space="preserve">
          <source>The data file and the index file can be placed on different devices to improve speed.</source>
          <target state="translated">데이터 파일과 인덱스 파일을 다른 장치에 배치하여 속도를 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f93989fdf0d2813527170be3bd95cf9fc87c7d80" translate="yes" xml:space="preserve">
          <source>The data files that Mariabackup creates in the target directory are not point-in-time consistent, given that the data files are copied at different times during the backup operation. If you try to restore from these files, InnoDB notices the inconsistencies and crashes to protect you from corruption</source>
          <target state="translated">Mariabackup이 대상 디렉토리에 작성하는 데이터 파일은 백업 조작 중 데이터 파일이 다른 시간에 복사되는 경우 특정 시점에 일관성이 없습니다. 이러한 파일에서 복원하려고하면 InnoDB가 불일치를 발견하고 손상으로부터 보호합니다.</target>
        </trans-unit>
        <trans-unit id="82d75cac2c3ee05c4e95208b25db8a97c42dfea3" translate="yes" xml:space="preserve">
          <source>The data here represents one-directional starting and ending nodes. So node 2 has paths to node 3 and node 6, while node 6 has no paths to any other node.</source>
          <target state="translated">여기의 데이터는 단방향 시작 및 끝 노드를 나타냅니다. 따라서 노드 2에는 노드 3과 노드 6에 대한 경로가 있고 노드 6에는 다른 노드에 대한 경로가 없습니다.</target>
        </trans-unit>
        <trans-unit id="8f1665579686ecdb85406c7ade983cb3f29afba1" translate="yes" xml:space="preserve">
          <source>The data is strings (not numeric) -- Remove &quot;SUM&quot; (but keep the expression); remove the SUM...AS TOTAL line.</source>
          <target state="translated">데이터는 문자열입니다 (숫자가 아님)- &quot;SUM&quot;을 제거합니다 (그러나 표현식은 유지). SUM ... AS TOTAL 줄을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="bbb57d921d749e669e9f787fdbc7e353b47c8b3a" translate="yes" xml:space="preserve">
          <source>The data length for the column</source>
          <target state="translated">열의 데이터 길이</target>
        </trans-unit>
        <trans-unit id="b89e3890145601ef789c20a4f75c5e383c33bee4" translate="yes" xml:space="preserve">
          <source>The data model is targeted at denormalized data, cassandra docs and user stories all mention the practice of creating/populating a dedicated column family (=table) for each type of query you're going to run.</source>
          <target state="translated">데이터 모델은 비정규 화 된 데이터, cassandra 문서 및 사용자 사례를 대상으로 실행하려는 각 유형의 쿼리에 대해 전용 열 패밀리 (= 테이블)를 작성 / 채우는 방법을 언급합니다.</target>
        </trans-unit>
        <trans-unit id="3249ef60198cf7a7a9241497752c716aa8b58ae3" translate="yes" xml:space="preserve">
          <source>The data node is now ready for use. You can test it by attempting to connect the MariaDB client to the data from the Spider node. For instance, assuming the data node is at the IP address 192.168.1.5, SSH into the Spider node then try to establish a client connection.</source>
          <target state="translated">이제 데이터 노드를 사용할 준비가되었습니다. MariaDB 클라이언트를 Spider 노드의 데이터에 연결하여 테스트 할 수 있습니다. 예를 들어, 데이터 노드가 IP 주소 192.168.1.5에 있다고 가정하면 Spider 노드에 SSH를 연결 한 다음 클라이언트 연결을 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="8dfebb93698cd7d5d1aa84d8132eeec05d5c5318" translate="yes" xml:space="preserve">
          <source>The data source connection string '%s' is not in the correct format</source>
          <target state="translated">데이터 소스 연결 문자열 '% s'이 (가) 올바른 형식이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="8946a2317137a7a682718f30b31428c117c91abb" translate="yes" xml:space="preserve">
          <source>The data source. This is specified in the connection option.</source>
          <target state="translated">데이터 소스 이것은 연결 옵션에 지정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="078d31e3c1487ac55f0bdf3ffec6fb324fdcab59" translate="yes" xml:space="preserve">
          <source>The data type for the column</source>
          <target state="translated">열의 데이터 유형</target>
        </trans-unit>
        <trans-unit id="988ed563f43acbea432da967b6427cc5f2f5db48" translate="yes" xml:space="preserve">
          <source>The data type, length and &lt;a href=&quot;../data-types-character-sets-and-collations/index&quot;&gt;character set and collation&lt;/a&gt; are all taken from the result returned by the subquery. The result of a subquery can always be NULL, that is, no result returned. Even if the original value is defined as NOT NULL, this is disregarded.</source>
          <target state="translated">데이터 유형, 길이 및 &lt;a href=&quot;../data-types-character-sets-and-collations/index&quot;&gt;문자 집합 및 데이터 정렬&lt;/a&gt; 은 모두 하위 쿼리에서 반환 된 결과에서 가져옵니다. 하위 쿼리의 결과는 항상 NULL 일 수 있습니다. 즉 결과가 반환되지 않습니다. 원래 값이 NOT NULL로 정의되어 있어도 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="c9e1c238e4d5708685bdf87f0a37c2a4a1554b15" translate="yes" xml:space="preserve">
          <source>The data types currently supported by CONNECT are:</source>
          <target state="translated">CONNECT가 현재 지원하는 데이터 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ce7d3f8216cf8ea30cb37c0cee115a928bc7b3d2" translate="yes" xml:space="preserve">
          <source>The data width for the extent</source>
          <target state="translated">익스텐트의 데이터 너비</target>
        </trans-unit>
        <trans-unit id="08dae27e361f25a16bf195e11a96c979d7eac5c9" translate="yes" xml:space="preserve">
          <source>The data will not be re-compressed immediately. However, all new SST files will use the new compression settings, so as data gets inserted/updated the column family will gradually start using the new option.</source>
          <target state="translated">데이터는 즉시 다시 압축되지 않습니다. 그러나 모든 새 SST 파일은 새 압축 설정을 사용하므로 데이터가 삽입 / 업데이트 될 때 열 패밀리는 점차 새 옵션을 사용하기 시작합니다.</target>
        </trans-unit>
        <trans-unit id="a01f3626518432fe08459562366f06441232e188" translate="yes" xml:space="preserve">
          <source>The data&amp;lt;N&amp;gt; directories should simply be copied from the backup location or restored via an appropriate backup or snapshot utility. For example:</source>
          <target state="translated">data &amp;lt;N&amp;gt; 디렉토리는 백업 위치에서 복사하거나 적절한 백업 또는 스냅 샷 유틸리티를 통해 복원해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2cb31ad01c4e0b2f73bf71b19bb9f499d4f61190" translate="yes" xml:space="preserve">
          <source>The database connection configuration follows PDI&amp;rsquo;s default schema.</source>
          <target state="translated">데이터베이스 연결 구성은 PDI의 기본 스키마를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="226cf25b4f7191ebe8ad641ed00dc415b2b37aad" translate="yes" xml:space="preserve">
          <source>The database name can be omitted from the first syntax, in which case the statement applies to the default database.</source>
          <target state="translated">데이터베이스 이름은 첫 번째 구문에서 생략 할 수 있으며이 경우 명령문은 기본 데이터베이스에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="f109f7bd07a24e2837ade61355bf80d1f7622f33" translate="yes" xml:space="preserve">
          <source>The database schema for the table</source>
          <target state="translated">테이블의 데이터베이스 스키마</target>
        </trans-unit>
        <trans-unit id="3f68a068c806f6b198f9e7af35eacebc18d45119" translate="yes" xml:space="preserve">
          <source>The database to use for the tests. The default is test.</source>
          <target state="translated">테스트에 사용할 데이터베이스입니다. 기본값은 test입니다.</target>
        </trans-unit>
        <trans-unit id="efaf8a98e7baaed7ead133d604afa4659f16fea5" translate="yes" xml:space="preserve">
          <source>The database where the table is located.</source>
          <target state="translated">테이블이있는 데이터베이스입니다.</target>
        </trans-unit>
        <trans-unit id="dac49215343559f842f187ba9f50c35eab21e8ba" translate="yes" xml:space="preserve">
          <source>The datatype for the 'address' in the table must be ordered, and should be as compact as possible.</source>
          <target state="translated">표에서 '주소'의 데이터 유형은 주문해야하며 가능한 한 간결해야합니다.</target>
        </trans-unit>
        <trans-unit id="58e44ee8556c797e7b454027f722065e5de90f5e" translate="yes" xml:space="preserve">
          <source>The datatype of an 'owner' (MEDIUMINT UNSIGNED: 0..16M) -- adjust if needed.</source>
          <target state="translated">'소유자'의 데이터 유형 (MEDIUMINT UNSIGNED : 0..16M)-필요한 경우 조정하십시오.</target>
        </trans-unit>
        <trans-unit id="f987aa27ce30e8bd4231477af115a42a95f73aa5" translate="yes" xml:space="preserve">
          <source>The datatype of an 'owner' (MEDIUMINT UNSIGNED: 0..16M); 'free' is represented by 0. You may need a bigger datatype.</source>
          <target state="translated">'소유자'의 데이터 유형 (MEDIUMINT UNSIGNED : 0..16M); 'free'는 0으로 표시됩니다. 더 큰 데이터 유형이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a574e6ddfee6396978d08c7a158fa54ca165715" translate="yes" xml:space="preserve">
          <source>The date format used to interpret the date.</source>
          <target state="translated">날짜를 해석하는 데 사용되는 날짜 형식입니다.</target>
        </trans-unit>
        <trans-unit id="5c869b3b6309e23c5f8f69b659517ed683375f49" translate="yes" xml:space="preserve">
          <source>The date must be specified with the format in which CIM DATETIME values are stored (WMI uses the date and time formats defined by the Distributed Management Task Force).</source>
          <target state="translated">날짜는 CIM DATETIME 값이 저장되는 형식으로 지정해야합니다 (WMI는 Distributed Management Task Force에서 정의한 날짜 및 시간 형식을 사용합니다).</target>
        </trans-unit>
        <trans-unit id="3c086c35e15bb16b05b376bffecaed538e312226" translate="yes" xml:space="preserve">
          <source>The date rows in the table are defined like this: `PTY_USR_PASSWORD_DATE` DATE NULL DEFAULT NULL,</source>
          <target state="translated">테이블의 날짜 행은 다음과 같이 정의됩니다 :`PTY_USR_PASSWORD_DATE` DATE NULL DEFAULT NULL,</target>
        </trans-unit>
        <trans-unit id="0234865fb51aa8d0a6f3a1515e372b58931648b1" translate="yes" xml:space="preserve">
          <source>The date the table was created</source>
          <target state="translated">테이블이 작성된 날짜</target>
        </trans-unit>
        <trans-unit id="8765e5388717f1c48d2a9c425a054102952876c1" translate="yes" xml:space="preserve">
          <source>The date type YYYY-MM-DD</source>
          <target state="translated">날짜 유형 YYYY-MM-DD</target>
        </trans-unit>
        <trans-unit id="fbf3e303ef03feb83f8f1b5b3a3b8d828c54acc1" translate="yes" xml:space="preserve">
          <source>The date, time, or datetime values contained in &lt;code&gt;str&lt;/code&gt; should be given in the format indicated by format. If str contains an illegal date, time, or datetime value, &lt;code&gt;STR_TO_DATE()&lt;/code&gt; returns &lt;code&gt;NULL&lt;/code&gt;. An illegal value also produces a warning.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 에 포함 된 날짜, 시간 또는 날짜 / 시간 값 은 형식으로 표시된 형식으로 제공되어야합니다. str에 잘못된 날짜, 시간 또는 날짜 / 시간 값이 포함 된 경우 &lt;code&gt;STR_TO_DATE()&lt;/code&gt; 는 &lt;code&gt;NULL&lt;/code&gt; 을 반환 합니다 . 잘못된 값도 경고를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="9ad90dcb823bec16ebb37efa75a23e836dfe191e" translate="yes" xml:space="preserve">
          <source>The datetime expression is in the format 'YYYY-MM-DD hh:mm:ss'.</source>
          <target state="translated">날짜 / 시간 표현식은 'YYYY-MM-DD hh : mm : ss'형식입니다.</target>
        </trans-unit>
        <trans-unit id="d5118560e3de0b5aa9f2b42620895c0774d78e3a" translate="yes" xml:space="preserve">
          <source>The datetime field might have duplicates -- this can cause troubles</source>
          <target state="translated">날짜 시간 필드에 중복이있을 수 있습니다. 이로 인해 문제가 발생할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="430ab4ec2a7978032eb59f393a2cba445abb853d" translate="yes" xml:space="preserve">
          <source>The decision to enable concurrent insert for a table is done when the table is opened. If you change the value of &lt;code&gt;concurrent_insert&lt;/code&gt; it will only affect new opened tables. If you want it to work for also for tables in use or cached, you should do &lt;code&gt;&lt;a href=&quot;../flush/index&quot;&gt;FLUSH TABLES&lt;/a&gt;&lt;/code&gt; after setting the variable.</source>
          <target state="translated">테이블을 열 때 테이블에 동시 삽입을 사용하기로 결정합니다. 당신의 값을 변경하는 경우 &lt;code&gt;concurrent_insert&lt;/code&gt; 을 만 새 열 테이블에 영향을 미칠 것입니다. 사용 중이거나 캐시 된 테이블에서도 작동하게 하려면 변수를 설정 한 후 &lt;code&gt;&lt;a href=&quot;../flush/index&quot;&gt;FLUSH TABLES&lt;/a&gt;&lt;/code&gt; 를 수행해야 합니다.</target>
        </trans-unit>
        <trans-unit id="51ef3d70a9c66003597b87cd6ba32482937d4bee" translate="yes" xml:space="preserve">
          <source>The declarations order is the following:</source>
          <target state="translated">선언 순서는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2c0506b66fe8b7a288e858a670b71b7ba5c906e2" translate="yes" xml:space="preserve">
          <source>The default 37% reserved for the old list can be adjusted by changing the value of &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_old_blocks_pct&quot;&gt;innodb_old_blocks_pct&lt;/a&gt;. It can accept anything between between 5% and 95%.</source>
          <target state="translated">이전 목록에 예약 된 기본 37 %는 &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_old_blocks_pct&quot;&gt;innodb_old_blocks_pct&lt;/a&gt; 값을 변경하여 조정할 수 있습니다 . 5 %에서 95 % 사이의 값을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ea493c8610b9c67827239dc455ca369a8ac0427" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;../aria-storage-formats/index&quot;&gt;row format&lt;/a&gt; is PAGE, and the PAGE by default means transactional. The TRANSACTIONAL and ROW_FORMAT options interact as follows:</source>
          <target state="translated">기본 &lt;a href=&quot;../aria-storage-formats/index&quot;&gt;행 형식&lt;/a&gt; 은 PAGE이며 기본적으로 PAGE는 트랜잭션을 의미합니다. TRANSACTIONAL 및 ROW_FORMAT 옵션은 다음과 같이 상호 작용합니다.</target>
        </trans-unit>
        <trans-unit id="4796f635b297ec3cc4f319ed3a84775a7529a5d0" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;../data-types-character-sets-and-collations/index&quot;&gt;collation&lt;/a&gt; (and character set) for the database, at the time the routine was created.</source>
          <target state="translated">루틴이 작성 될 때 데이터베이스 의 기본 &lt;a href=&quot;../data-types-character-sets-and-collations/index&quot;&gt;데이터 정렬&lt;/a&gt; (및 문자 세트)</target>
        </trans-unit>
        <trans-unit id="e7c74fd5d9f6120a06470af9dda4e7ee1d078899" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;mysql.gtid_slave_pos&lt;/code&gt; table will be initially created using the default storage engine set for the server (which itself defaults to InnoDB). If the application load is primarily non-transactional MyISAM or Aria tables, it can be beneficial to change the storage engine to avoid including an InnoDB update with every operation:</source>
          <target state="translated">기본 &lt;code&gt;mysql.gtid_slave_pos&lt;/code&gt; 테이블은 초기에 서버에 대해 설정된 기본 스토리지 엔진 (기본값은 InnoDB)을 사용하여 작성됩니다. 응용 프로그램로드가 주로 비 트랜잭션 MyISAM 또는 Aria 테이블 인 경우 모든 작업에 InnoDB 업데이트가 포함되지 않도록 스토리지 엔진을 변경하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c9a62b53f4f1bedece8dbe50206a6ccad3a82bf2" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;root&lt;/code&gt; user accounts created by &lt;code&gt;&lt;a href=&quot;../mysql_install_db/index&quot;&gt;mysql_install_db&lt;/a&gt;&lt;/code&gt; have this privilege. For example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../mysql_install_db/index&quot;&gt;mysql_install_db&lt;/a&gt;&lt;/code&gt; 에 의해 생성 된 기본 &lt;code&gt;root&lt;/code&gt; 사용자 계정 에는이 권한이 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ad52f0c7e82fabec3ec1669ae2875ec9eef317be" translate="yes" xml:space="preserve">
          <source>The default InnoDB stopword list differs from the default MyISAM list, being much shorter, and contains the following words:</source>
          <target state="translated">기본 InnoDB 중지 단어 목록은 기본 MyISAM 목록과 다르며 훨씬 짧으며 다음 단어가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d802df8cf2f80b5e242e5f1f6141aa2e7285b0c8" translate="yes" xml:space="preserve">
          <source>The default MariaDB ColumnStore installation process supports a Distributed installation functionality for Multi-Node installs. With Distributed,the MariaDB ColumnStore packages only needed to be installed on the Performance Module #1 node. MariaDB ColumnStore would distributed the packages across to the other nodes in the system and will install them automatically.</source>
          <target state="translated">기본 MariaDB ColumnStore 설치 프로세스는 다중 노드 설치를위한 분산 설치 기능을 지원합니다. 분산을 사용하면 MariaDB ColumnStore 패키지는 성능 모듈 # 1 노드에만 설치하면됩니다. MariaDB ColumnStore는 패키지를 시스템의 다른 노드로 분산시켜 자동으로 설치합니다.</target>
        </trans-unit>
        <trans-unit id="7fe12748039c0a887ed1fde0ac013124bdfa4cce" translate="yes" xml:space="preserve">
          <source>The default MariaDB ColumnStore installation process supports a Non-Distributed installation functionality for Multi-Node installs. With Non-Distributed, the MariaDB ColumnStore packages needed to be installed on all the nodes.</source>
          <target state="translated">기본 MariaDB ColumnStore 설치 프로세스는 다중 노드 설치를위한 비 분산 설치 기능을 지원합니다. 비 분산으로 MariaDB ColumnStore 패키지를 모든 노드에 설치해야했습니다.</target>
        </trans-unit>
        <trans-unit id="aaf089489cd9048ad42eff74f528656544f8abde" translate="yes" xml:space="preserve">
          <source>The default MariaDB ColumnStore installation process supports a Non-Distributed installation mode for multi-node deployments. With this option, the user will need to install the ColumnStore packages manually on each node.</source>
          <target state="translated">기본 MariaDB ColumnStore 설치 프로세스는 다중 노드 배포를위한 비 분산 설치 모드를 지원합니다. 이 옵션을 사용하면 각 노드에 ColumnStore 패키지를 수동으로 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="1d2ad1938411cdb750a85675c786490d70d42e8e" translate="yes" xml:space="preserve">
          <source>The default approaches can be changed by setting the &lt;a href=&quot;../aria-server-system-variables/index#aria_stats_method&quot;&gt;aria_stats_method&lt;/a&gt;, &lt;a href=&quot;../myisam-server-system-variables/index#myisam_stats_method&quot;&gt;myisam_stats_method&lt;/a&gt; and &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_stats_method&quot;&gt;innodb_stats_method&lt;/a&gt; server variables.</source>
          <target state="translated">&lt;a href=&quot;../aria-server-system-variables/index#aria_stats_method&quot;&gt;aria_stats_method&lt;/a&gt; , &lt;a href=&quot;../myisam-server-system-variables/index#myisam_stats_method&quot;&gt;myisam_stats_method&lt;/a&gt; 및 &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_stats_method&quot;&gt;innodb_stats_method&lt;/a&gt; 서버 변수 를 설정하여 기본 접근 방식을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e0a175c66a2c2b637b34d3c32876dd6f36dbe7f7" translate="yes" xml:space="preserve">
          <source>The default behavior, which occurs if &lt;code&gt;ALGORITHM=DEFAULT&lt;/code&gt; is specified, or if &lt;code&gt;ALGORITHM&lt;/code&gt; is not specified at all, usually only makes a copy if the operation doesn't support being done in-place at all. In this case, the &lt;em&gt;most efficient&lt;/em&gt; available algorithm will usually be used.</source>
          <target state="translated">&lt;code&gt;ALGORITHM=DEFAULT&lt;/code&gt; 가 지정되거나 &lt;code&gt;ALGORITHM&lt;/code&gt; 이 지정되지 않은 경우 발생하는 기본 동작 은 일반적으로 작업이 제대로 수행되지 않는 경우에만 사본을 작성합니다. 이 경우 &lt;em&gt;가장 효율적인&lt;/em&gt; 가용 알고리즘이 일반적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9040f5e4bc419935385393666a798fef9bc51cac" translate="yes" xml:space="preserve">
          <source>The default behavior, which occurs if &lt;code&gt;ALGORITHM=DEFAULT&lt;/code&gt; is specified, or if &lt;code&gt;ALGORITHM&lt;/code&gt; is not specified at all, usually only makes a copy if the operation doesn't support being done in-place at all. In this case, the most efficient available algorithm will usually be used.</source>
          <target state="translated">&lt;code&gt;ALGORITHM=DEFAULT&lt;/code&gt; 가 지정되거나 &lt;code&gt;ALGORITHM&lt;/code&gt; 이 지정되지 않은 경우 발생하는 기본 동작 은 일반적으로 작업이 제대로 수행되지 않는 경우에만 사본을 작성합니다. 이 경우 가장 효율적인 가용 알고리즘이 일반적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="adc0b9ab5436338899f297c733cb29882ec66a7b" translate="yes" xml:space="preserve">
          <source>The default behavior, which occurs if &lt;code&gt;LOCK=DEFAULT&lt;/code&gt; is specified, or if &lt;code&gt;LOCK&lt;/code&gt; is not specified at all, acquire the least restrictive lock on the table that is supported for the specific operation. This permits the maximum amount of concurrency that is supported for the specific operation.</source>
          <target state="translated">&lt;code&gt;LOCK=DEFAULT&lt;/code&gt; 가 지정되거나 &lt;code&gt;LOCK&lt;/code&gt; 이 지정되지 않은 경우 발생하는 기본 작동 은 특정 조작에 대해 지원되는 테이블에서 최소 제한 잠금을 획득합니다. 이를 통해 특정 작업에 지원되는 최대 동시성을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="0c702a0d392c7c68847667e394f043cdefbfe359" translate="yes" xml:space="preserve">
          <source>The default behaviour (multiline match is off)</source>
          <target state="translated">기본 동작 (여러 줄 일치가 꺼져 있음)</target>
        </trans-unit>
        <trans-unit id="506e28b20ba9f3cca6a343c08da7c1513268d204" translate="yes" xml:space="preserve">
          <source>The default client-side authentication plugin depends on a few factors.</source>
          <target state="translated">기본 클라이언트 측 인증 플러그인은 몇 가지 요소에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="c85eba5969058b052b6847058fa6d647c09942f6" translate="yes" xml:space="preserve">
          <source>The default compression level can be configured by setting the &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_compression_level&quot;&gt;innodb_compression_level&lt;/a&gt;&lt;/code&gt; system variable.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_compression_level&quot;&gt;innodb_compression_level&lt;/a&gt;&lt;/code&gt; 시스템 변수를 설정하여 기본 압축 수준을 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9c294bb9780fb756ae1a7977827523b6fe88f191" translate="yes" xml:space="preserve">
          <source>The default configuration file is called &lt;code&gt;sphinx.conf&lt;/code&gt;, usually located in &lt;code&gt;/etc/sphinxsearch&lt;/code&gt; (Debian/Ubuntu), &lt;code&gt;/etc/sphinx/sphinx.conf.&lt;/code&gt; (Red Hat/CentOS) or &lt;code&gt;C:\Sphinx\sphinx.conf&lt;/code&gt; (Windows).</source>
          <target state="translated">기본 구성 파일은 &lt;code&gt;sphinx.conf&lt;/code&gt; 이며 대개 &lt;code&gt;/etc/sphinxsearch&lt;/code&gt; (Debian / Ubuntu), &lt;code&gt;/etc/sphinx/sphinx.conf.&lt;/code&gt; (Red Hat / CentOS) 또는 &lt;code&gt;C:\Sphinx\sphinx.conf&lt;/code&gt; (Windows).</target>
        </trans-unit>
        <trans-unit id="bf73f2f4373f69a88373f87a3366ec81b2c811fc" translate="yes" xml:space="preserve">
          <source>The default database of the process (NULL if no default).</source>
          <target state="translated">프로세스의 기본 데이터베이스입니다 (기본값이 없으면 NULL).</target>
        </trans-unit>
        <trans-unit id="d41ef4748ef24fae61fe9a9fbf7d82d4cd586510" translate="yes" xml:space="preserve">
          <source>The default database of the sub-tables is the current database or if not, can be specified in the DBNAME option. For the tables that are not in the default database, this can be specified in the table list. For instance, to create a table based on the French table &lt;em&gt;employe&lt;/em&gt; in the current database and on the English table &lt;em&gt;employee&lt;/em&gt; of the &lt;em&gt;db2&lt;/em&gt; database, the syntax of the create statement can be:</source>
          <target state="translated">서브 테이블의 기본 데이터베이스는 현재 데이터베이스이거나 그렇지 않은 경우 DBNAME 옵션에서 지정할 수 있습니다. 기본 데이터베이스에없는 테이블의 경우 테이블 목록에서 지정할 수 있습니다. 예를 들어, 프랑스의 테이블을 기반으로 테이블을 만들 &lt;em&gt;직원당&lt;/em&gt; 현재 데이터베이스와 영어 테이블에 &lt;em&gt;직원&lt;/em&gt; 의 &lt;em&gt;DB2는&lt;/em&gt; 데이터베이스를 만들기 문의 구문은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="049b7282e03c9a7472c2445bc26bbc9689c7e8f5" translate="yes" xml:space="preserve">
          <source>The default database.</source>
          <target state="translated">기본 데이터베이스</target>
        </trans-unit>
        <trans-unit id="aabce014fb379505d61fc02494bebaa5f010a811" translate="yes" xml:space="preserve">
          <source>The default delimiter in the &lt;a href=&quot;../mysql-client/index&quot;&gt;mysql&lt;/a&gt; client is the semicolon.</source>
          <target state="translated">&lt;a href=&quot;../mysql-client/index&quot;&gt;mysql&lt;/a&gt; 클라이언트 의 기본 구분자 는 세미콜론입니다.</target>
        </trans-unit>
        <trans-unit id="46db27dcceb764f3fe718155104c57f6c3067243" translate="yes" xml:space="preserve">
          <source>The default delimiter of the CSV input file is a comma (&amp;lsquo;&lt;strong&gt;,&lt;/strong&gt;&amp;rsquo;) and can be changed through the command line parameter -d. Only one character delimiters are currently supported.</source>
          <target state="translated">CSV 입력 파일의 기본 분리 문자는 쉼표 ( ' &lt;strong&gt;,&lt;/strong&gt; ')이며 명령 행 매개 변수 -d를 통해 변경할 수 있습니다. 현재 하나의 문자 분리 문자 만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="47bcbaafff04a997da65561bce0f8ebd9e1b8a11" translate="yes" xml:space="preserve">
          <source>The default distribution mode has changed from 'distributed' to 'non-distributed'. During an upgrade, however, the default is to use the distribution mode used in the original installation. The options '-d' and '-n' can always be used to override the default.</source>
          <target state="translated">기본 배포 모드가 '분산'에서 '비 분산'으로 변경되었습니다. 그러나 업그레이드하는 동안 기본값은 원래 설치에 사용 된 배포 모드를 사용하는 것입니다. '-d'및 '-n'옵션은 항상 기본값을 재정의하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1779ac8335a4a63a06c8c192cfb459582268fe9" translate="yes" xml:space="preserve">
          <source>The default flags for &lt;a href=&quot;../server-system-variables/index#optimizer_switch&quot;&gt;optimizer_switch&lt;/a&gt; do not help much:</source>
          <target state="translated">&lt;a href=&quot;../server-system-variables/index#optimizer_switch&quot;&gt;optimizer_switch&lt;/a&gt; 의 기본 플래그 는별로 도움이되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="62b3eb4dd5ffb91cd70aedcdc613729131ac12b4" translate="yes" xml:space="preserve">
          <source>The default for &lt;a href=&quot;../spider_bg_direct_sql/index&quot;&gt;spider_bg_direct_sql&lt;/a&gt; is to access concurrently all backends. If you have multiple partitions store inside a single backend, you still can increase parallelism affecting different channels to each partitions.</source>
          <target state="translated">&lt;a href=&quot;../spider_bg_direct_sql/index&quot;&gt;spider_bg_direct_sql&lt;/a&gt; 의 기본값은 모든 백엔드에 동시에 액세스하는 것입니다. 단일 백엔드 내에 여러 파티션이 저장되어있는 경우에도 각 파티션의 다른 채널에 영향을주는 병렬 처리를 늘릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bae632ccb53b0ed651b25eb89678717147702392" translate="yes" xml:space="preserve">
          <source>The default group suffix can also be specified via the &lt;code&gt;MYSQL_GROUP_SUFFIX&lt;/code&gt;&lt;a href=&quot;../mariadb-environment-variables/index&quot;&gt;environment variable&lt;/a&gt;.</source>
          <target state="translated">기본 그룹 접미사는 &lt;code&gt;MYSQL_GROUP_SUFFIX&lt;/code&gt; &lt;a href=&quot;../mariadb-environment-variables/index&quot;&gt;환경 변수&lt;/a&gt; 를 통해 지정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="767d092539e82d8e392dc47c42f8ce9747e05778" translate="yes" xml:space="preserve">
          <source>The default is '&lt;code&gt;FOR JOIN&lt;/code&gt;', which means that the hint only affects how the &lt;code&gt;WHERE&lt;/code&gt; clause is optimized.</source>
          <target state="translated">기본값은 ' &lt;code&gt;FOR JOIN&lt;/code&gt; '이며 힌트는 &lt;code&gt;WHERE&lt;/code&gt; 절이 최적화되는 .</target>
        </trans-unit>
        <trans-unit id="d97c26f5522d7fd763d4cec57a21a588a8aa1266" translate="yes" xml:space="preserve">
          <source>The default is 'FOR JOIN', which means that the hint only affects how the WHERE clause is optimized.</source>
          <target state="translated">기본값은 'FOR JOIN'이며 힌트는 WHERE 절이 최적화되는 방식에만 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="d06f087792b322c8768e782cc6a507808edc67c6" translate="yes" xml:space="preserve">
          <source>The default is zero, no delay.</source>
          <target state="translated">기본값은 0이며 지연이 없습니다.</target>
        </trans-unit>
        <trans-unit id="7ccc57284826fa218886e5d2c328a99ad30c6e2b" translate="yes" xml:space="preserve">
          <source>The default key is set using the &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_default_encryption_key_id&quot;&gt;innodb_default_encryption_key_id&lt;/a&gt;&lt;/code&gt; system variable.</source>
          <target state="translated">기본 키는 &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_default_encryption_key_id&quot;&gt;innodb_default_encryption_key_id&lt;/a&gt;&lt;/code&gt; 를 사용하여 설정됩니다. 시스템 변수를 .</target>
        </trans-unit>
        <trans-unit id="0cfe8ad2872b82413f66f04662d0472d1a34391b" translate="yes" xml:space="preserve">
          <source>The default mode while XtraDB/InnoDB is running normally. Until &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1027-release-notes/&quot;&gt;MariaDB 10.2.7&lt;/a&gt;, it was the only mode permitting changes to the data. From &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1027-release-notes/&quot;&gt;MariaDB 10.2.7&lt;/a&gt;, write transactions are permitted with innodb_force_recovery&amp;lt;=3.</source>
          <target state="translated">XtraDB / InnoDB가 정상적으로 실행되는 동안 기본 모드입니다. &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1027-release-notes/&quot;&gt;MariaDB 10.2.7&lt;/a&gt; 까지는 데이터 변경을 허용하는 유일한 모드였습니다. 에서 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1027-release-notes/&quot;&gt;MariaDB 10.2.7&lt;/a&gt; innodb_force_recovery &amp;lt;= 3으로 쓰기 트랜잭션이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="38b6ecf51d095b455263467aa405e001abe02467" translate="yes" xml:space="preserve">
          <source>The default number of rotations is &lt;code&gt;9&lt;/code&gt;.</source>
          <target state="translated">기본 회전 수는 &lt;code&gt;9&lt;/code&gt; 입니다. 입니다.</target>
        </trans-unit>
        <trans-unit id="3066974bd8f56128231cfed26a2dcd1b323688cc" translate="yes" xml:space="preserve">
          <source>The default operation is update (&lt;code&gt;-u&lt;/code&gt;). If a recovery is done (&lt;code&gt;-r&lt;/code&gt;), all writes and possibly updates and deletes are done and errors are only counted. The default log file name is &lt;code&gt;myisam.log&lt;/code&gt; for &lt;code&gt;myisamlog&lt;/code&gt; and &lt;code&gt;isam.log&lt;/code&gt; for &lt;code&gt;isamlog&lt;/code&gt; if no &lt;code&gt;log_file&lt;/code&gt; argument is given. If tables are named on the command line, only those tables are updated.</source>
          <target state="translated">기본 작업은 업데이트 ( &lt;code&gt;-u&lt;/code&gt; )입니다. 복구가 완료되면 ( &lt;code&gt;-r&lt;/code&gt; ) 모든 쓰기 및 업데이트 및 삭제가 수행되고 오류 만 계산됩니다. 기본 로그 파일 이름은 &lt;code&gt;myisam.log&lt;/code&gt; 경우 &lt;code&gt;myisamlog&lt;/code&gt; 이고 &lt;code&gt;log_file&lt;/code&gt; 이없는 경우 &lt;code&gt;isamlog&lt;/code&gt; 의 경우 &lt;code&gt;isam.log&lt;/code&gt; 입니다. 인수가 지정 입니다. 명령 행에 테이블 이름이 지정된 경우 해당 테이블 만 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="aa78f619e52edfa504b4a943935fe3aaa817e5d9" translate="yes" xml:space="preserve">
          <source>The default option will be &lt;code&gt;-a&lt;/code&gt; (&lt;code&gt;--analyze&lt;/code&gt;)</source>
          <target state="translated">기본 옵션은 &lt;code&gt;-a&lt;/code&gt; ( &lt;code&gt;--analyze&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="dc991ab2e7d3e8ccb2838265dbce8f6ea5a218cf" translate="yes" xml:space="preserve">
          <source>The default option will be &lt;code&gt;-o&lt;/code&gt; (&lt;code&gt;--optimize&lt;/code&gt;)</source>
          <target state="translated">기본 옵션은 &lt;code&gt;-o&lt;/code&gt; ( &lt;code&gt;--optimize&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="a996a13b51ccb8e943651ccb321608aa483e4d02" translate="yes" xml:space="preserve">
          <source>The default option will be &lt;code&gt;-r&lt;/code&gt; (&lt;code&gt;--repair&lt;/code&gt;)</source>
          <target state="translated">기본 옵션은 &lt;code&gt;-r&lt;/code&gt; ( &lt;code&gt;--repair&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="58bee35522c1d66e3ed7e3804898fd67ce15b48d" translate="yes" xml:space="preserve">
          <source>The default package installation directory is /usr/local/mariadb/columnstore The location of the temporary files created by MariaDB ColumnStore is /tmp/columnstore_tmp.</source>
          <target state="translated">기본 패키지 설치 디렉토리는 / usr / local / mariadb / columnstore입니다. MariaDB ColumnStore가 생성 한 임시 파일의 위치는 / tmp / columnstore_tmp입니다.</target>
        </trans-unit>
        <trans-unit id="8f63c5fe1ecc4964580eeb0d26a371c8e9b62034" translate="yes" xml:space="preserve">
          <source>The default package installation directory is the home directory of the user account. The location of the temporary files created by MariaDB ColumnStore is $HOME/.tmp</source>
          <target state="translated">기본 패키지 설치 디렉토리는 사용자 계정의 홈 디렉토리입니다. MariaDB ColumnStore에 의해 작성된 임시 파일의 위치는 $ HOME / .tmp입니다.</target>
        </trans-unit>
        <trans-unit id="dd82256ab8ae8e23719741ce93ed0170753dc861" translate="yes" xml:space="preserve">
          <source>The default rate is &lt;code&gt;1&lt;/code&gt; (every error is logged).</source>
          <target state="translated">기본 속도는 &lt;code&gt;1&lt;/code&gt; 입니다 (모든 오류가 기록됨).</target>
        </trans-unit>
        <trans-unit id="5a80de15f3587becf6e0198af4e4ac4359e13d40" translate="yes" xml:space="preserve">
          <source>The default role is stored in a new column in the &lt;code&gt;&lt;a href=&quot;../mysqluser-table/index&quot;&gt;mysql.user&lt;/a&gt;&lt;/code&gt; table, and currently viewing this table is the only way to see which role has been assigned to a user as the default.</source>
          <target state="translated">기본 역할은 &lt;code&gt;&lt;a href=&quot;../mysqluser-table/index&quot;&gt;mysql.user&lt;/a&gt;&lt;/code&gt; 테이블 의 새 열에 저장되며 현재이 테이블을 보는 것이 사용자에게 어떤 역할이 기본값으로 할당되었는지 확인하는 유일한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="d821c5cacbbaf707755825ec0e43ac9f2c1da093" translate="yes" xml:space="preserve">
          <source>The default search path on Windows for the my.ini file is:</source>
          <target state="translated">my.ini 파일에 대한 Windows의 기본 검색 경로는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="83d57485f9693946823ad389782f413bfbc26e99" translate="yes" xml:space="preserve">
          <source>The default setting encourages the server to use swap. Since there probably won't be much else on the database server besides MariaDB processes to put into swap, you'll probably want to reduce this to zero to avoid swapping as much as possible. You can change the default by adding a line to the &lt;code&gt;sysctl.conf&lt;/code&gt; file (usually found in &lt;code&gt;/etc/sysctl.conf&lt;/code&gt;).</source>
          <target state="translated">기본 설정은 서버가 스왑을 사용하도록 권장합니다. 스왑에 넣을 MariaDB 프로세스 외에 데이터베이스 서버에는 다른 것이 많지 않기 때문에 가능한 한 스왑을 피하기 위해 이것을 0으로 줄이려고 할 것입니다. &lt;code&gt;sysctl.conf&lt;/code&gt; 파일에 줄을 추가하여 기본값을 변경할 수 있습니다 (보통 &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; 에 있음) ).</target>
        </trans-unit>
        <trans-unit id="d88c5f4b9259e108261ae435211653bb7a424780" translate="yes" xml:space="preserve">
          <source>The default setting for vm.swappiness is set to 30. This setting can be overridden by user on each instance.</source>
          <target state="translated">vm.swappiness의 기본 설정은 30으로 설정되어 있습니다.이 설정은 각 인스턴스에서 사용자가 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ad161ea715ff8762270572bcab5c037af7dfea7" translate="yes" xml:space="preserve">
          <source>The default setting of 022 in /etc/profile is what is recommended. It it required that it the setting doesn't end with a 7, like 077. Example, on a root install, mysqld that runs as 'mysql' user needs to be able to read the MariaDB ColumnStore configuration file, Columnstore.xml. So a last digit of 7 would prevent this and cause the install to fail.</source>
          <target state="translated">/ etc / profile에서 022의 기본 설정이 권장됩니다. 설정은 077과 같이 7로 끝나지 않아야했습니다. 예를 들어, 루트 설치에서 'mysql'사용자로 실행되는 mysqld는 MariaDB ColumnStore 구성 파일 인 Columnstore.xml을 읽을 수 있어야합니다. 따라서 마지막 숫자 7은이를 방지하고 설치에 실패합니다.</target>
        </trans-unit>
        <trans-unit id="634b008f4f4efdf72e5918f4439c51b03cc480d9" translate="yes" xml:space="preserve">
          <source>The default setting of 022 is what is recommended. ColumnStore requires that it not end with a 7, like 077. For example, on a root installation, mysqld runs as the mysql user, and needs to be able to read the ColumnStore configuration file, which likely is not owned by mysql. If it were, then the other ColumnStore processes could not read it.</source>
          <target state="translated">기본 설정 인 022가 권장됩니다. ColumnStore는 077과 같이 7로 끝나지 않아야합니다. 예를 들어, 루트 설치에서 mysqld는 mysql 사용자로 실행되며 mysql이 소유하지 않은 ColumnStore 구성 파일을 읽을 수 있어야합니다. 그렇다면 다른 ColumnStore 프로세스가 읽을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="577df56f03fb79f56f126d7e9bb183268d4f537e" translate="yes" xml:space="preserve">
          <source>The default size is 100 rows, which can be changed by modifying the &lt;code&gt;&lt;a href=&quot;../performance-schema-system-variables/index#performance_schema_setup_actors_size&quot;&gt;performance_schema_setup_actors_size&lt;/a&gt;&lt;/code&gt; system variable at server startup.</source>
          <target state="translated">기본 크기는 100 행이며 서버 시작시 &lt;code&gt;&lt;a href=&quot;../performance-schema-system-variables/index#performance_schema_setup_actors_size&quot;&gt;performance_schema_setup_actors_size&lt;/a&gt;&lt;/code&gt; 시스템 변수를 수정하여 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8ad74329b6e643e70b97c421aa523caf3d72bf31" translate="yes" xml:space="preserve">
          <source>The default systemd unit file also sets &lt;a href=&quot;https://www.freedesktop.org/software/systemd/man/systemd.exec.html#ProtectSystem=&quot;&gt;ProtectSystem=full&lt;/a&gt;, which places restrictions on writing to a few other directories. Overwriting this with &lt;code&gt;ProtectSystem=off&lt;/code&gt; in the same way as above will restore access to these directories.</source>
          <target state="translated">기본 시스템 단위 파일은 &lt;a href=&quot;https://www.freedesktop.org/software/systemd/man/systemd.exec.html#ProtectSystem=&quot;&gt;ProtectSystem = full을&lt;/a&gt; 설정 하여 다른 몇 가지 디렉토리에 쓰는 데 제한을 둡니다. 위와 동일한 방식으로 &lt;code&gt;ProtectSystem=off&lt;/code&gt; 로이를 덮어 쓰면 이러한 디렉토리에 대한 액세스가 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="a44cd595a42d9ed5c6d45de9bd8c0e1111e87c8b" translate="yes" xml:space="preserve">
          <source>The default username is: user and the password is mpp.</source>
          <target state="translated">기본 사용자 이름은 user이고 암호는 mpp입니다.</target>
        </trans-unit>
        <trans-unit id="cf5fe604fb05ca7624218be61fc7f1186a55c2da" translate="yes" xml:space="preserve">
          <source>The default value 8192, should be ok for most cases. The only problem with a higher value is that it takes longer to find a packed key in the block as one has to search roughly 8192/2 to find each key. We plan to fix this by adding a dictionary at the end of the page to be able to do a binary search within the block before starting a scan. Until this is done and key lookups takes too long time even if you are not hitting disk, then you should consider making this smaller.</source>
          <target state="translated">대부분의 경우 기본값은 8192입니다. 더 높은 값을 가진 유일한 문제는 각 키를 찾기 위해 대략 8192/2를 검색해야하기 때문에 블록에서 팩 키를 찾는 데 시간이 더 걸린다는 것입니다. 스캔을 시작하기 전에 블록 내에서 이진 검색을 수행 할 수 있도록 페이지 끝에 사전을 추가하여이 문제를 해결할 계획입니다. 이 작업을 수행하고 디스크를 치지 않아도 키 조회에 시간이 오래 걸리면이를 더 작게 만드는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="17a3a7c58f0f305decef7066e4c7eb46f90ea14d" translate="yes" xml:space="preserve">
          <source>The default value for the column</source>
          <target state="translated">열의 기본값</target>
        </trans-unit>
        <trans-unit id="b10dbbed333528b19aaae32cb29ed91043c0c055" translate="yes" xml:space="preserve">
          <source>The default value is ' ', to be compatible with MySQL 5.1.</source>
          <target state="translated">MySQL 5.1과 호환되는 기본값은 ''입니다.</target>
        </trans-unit>
        <trans-unit id="308d1aef8c35a970835fea4609fa423262666721" translate="yes" xml:space="preserve">
          <source>The default value is 0, which causes Mariabackup to not attempt killing any queries.</source>
          <target state="translated">기본값은 0이며, Mariabackup은 쿼리 종료를 시도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="12f491c0ff8df09a4013c2e4d7cf48521cbf239a" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;OFF&lt;/code&gt;, which means new tables are not compressed.</source>
          <target state="translated">기본값은 &lt;code&gt;OFF&lt;/code&gt; 입니다 . 이는 새 테이블이 압축되지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="dfc8e416794b230081bfa06bfbd810ecf8bc36f0" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;SYSTEM&lt;/code&gt;, which indicates that the system time zone defined in the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#system_time_zone&quot;&gt;system_time_zone&lt;/a&gt;&lt;/code&gt; system variable will be used. See &lt;a href=&quot;#system-time-zone&quot;&gt;System Time Zone&lt;/a&gt; below for more information.</source>
          <target state="translated">기본값은 &lt;code&gt;SYSTEM&lt;/code&gt; 이며 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#system_time_zone&quot;&gt;system_time_zone&lt;/a&gt;&lt;/code&gt; 시스템 변수에 정의 된 시스템 시간대 가 사용됨 을 나타냅니다 . 자세한 내용은 아래 &lt;a href=&quot;#system-time-zone&quot;&gt;시스템 시간대&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1c7067f1a3c9ff0f3a7a609a821370d1e6532694" translate="yes" xml:space="preserve">
          <source>The default value will be used if you &lt;code&gt;&lt;a href=&quot;../insert/index&quot;&gt;INSERT&lt;/a&gt;&lt;/code&gt; a row without specifying a value for that column, or if you specify &lt;code&gt;&lt;a href=&quot;../default/index&quot;&gt;DEFAULT&lt;/a&gt;&lt;/code&gt; for that column. Before &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1021-release-notes/&quot;&gt;MariaDB 10.2.1&lt;/a&gt; you couldn't usually provide an expression or function to evaluate at insertion time. You had to provide a constant default value instead. The one exception is that you may use &lt;code&gt;&lt;a href=&quot;../now/index&quot;&gt;CURRENT_TIMESTAMP&lt;/a&gt;&lt;/code&gt; as the default value for a &lt;code&gt;&lt;a href=&quot;../timestamp/index&quot;&gt;TIMESTAMP&lt;/a&gt;&lt;/code&gt; column to use the current timestamp at insertion time.</source>
          <target state="translated">해당 열에 값을 지정하지 않고 행 을 &lt;code&gt;&lt;a href=&quot;../insert/index&quot;&gt;INSERT&lt;/a&gt;&lt;/code&gt; 하거나 해당 열에 &lt;code&gt;&lt;a href=&quot;../default/index&quot;&gt;DEFAULT&lt;/a&gt;&lt;/code&gt; 를 지정하면 기본값 이 사용됩니다. &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1021-release-notes/&quot;&gt;MariaDB 10.2.1&lt;/a&gt; 이전 에는 일반적으로 삽입시 평가할 표현식이나 함수를 제공 할 수 없었습니다. 대신 상수 기본값을 제공해야했습니다. 한 가지 예외는 삽입 시간에 현재 시간 소인을 사용하기 위해 &lt;code&gt;&lt;a href=&quot;../now/index&quot;&gt;CURRENT_TIMESTAMP&lt;/a&gt;&lt;/code&gt; 를 &lt;code&gt;&lt;a href=&quot;../timestamp/index&quot;&gt;TIMESTAMP&lt;/a&gt;&lt;/code&gt; 열의 기본값으로 사용할 수 있다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="0df3eea3bf8226ddd55052235efe1b1f4a3dfb84" translate="yes" xml:space="preserve">
          <source>The default wrapper, JdbcInterface, is the only one distributed with binary distribution. It uses the standard way to get a connection to the drivers via the DriverManager.getConnection method. Other wrappers, only available with source distribution, enable connection to a Data Source, eventually implementing pooling. However, they must be compiled and installed manually.</source>
          <target state="translated">기본 래퍼 인 JdbcInterface는 바이너리 배포판으로 배포 된 유일한 래퍼입니다. 표준 방법을 사용하여 DriverManager.getConnection 메소드를 통해 드라이버에 연결합니다. 소스 분배에서만 사용 가능한 다른 랩퍼는 데이터 소스에 연결하여 결국 풀링을 구현할 수 있습니다. 그러나 수동으로 컴파일하고 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="2b4bd4c3021071135230280b8bf8b808a09180ed" translate="yes" xml:space="preserve">
          <source>The defaults are 60, 30, and 10 respectively. Each queue is given at least 1 thread so there is neither 'idle' priority configuration possible nor starvation. The number of threads started is normalized such that 100% = 2 * (the number of cores on the machine). The user can overbook or underbook their CPUs however they want. This is an example of how threads are assigned on an 8-core system using the defaults.</source>
          <target state="translated">기본값은 각각 60, 30 및 10입니다. 각 대기열에는 최소한 하나의 스레드가 제공되므로 '유휴'우선 순위 구성이 불가능하거나 기아 상태가 아닙니다. 시작된 스레드 수는 100 % = 2 * (시스템의 코어 수)가되도록 정규화됩니다. 사용자는 원하는 CPU를 초과 예약 또는 예약 예약 할 수 있습니다. 이것은 기본값을 사용하여 8 코어 시스템에서 스레드를 지정하는 방법의 예입니다.</target>
        </trans-unit>
        <trans-unit id="0f27e0918920cfde1c72ac772128a3c38c2dea40" translate="yes" xml:space="preserve">
          <source>The definition cannot refer to a TEMPORARY table, and you cannot create a TEMPORARY view.</source>
          <target state="translated">정의는 TEMPORARY 테이블을 참조 할 수 없으며 TEMPORARY보기를 작성할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b0d80cc53029e3ee39451be1cb28c9fc59fadcf5" translate="yes" xml:space="preserve">
          <source>The definition for table %`s is too big</source>
          <target state="translated">테이블 %의 정의가 너무 큽니다.</target>
        </trans-unit>
        <trans-unit id="206802afcf86a510588ae4c8fb6abae260b0c63c" translate="yes" xml:space="preserve">
          <source>The definition for timestamp is: &quot;The TIMESTAMP data type is used for values that contain both date and time parts. TIMESTAMP has a range of '1970-01-01 00:00:01' UTC to '2038-01-19 03:14:07' UTC.&quot;</source>
          <target state="translated">타임 스탬프에 대한 정의는 다음과 같습니다. &quot;TIMESTAMP 데이터 유형은 날짜 및 시간 부분을 모두 포함하는 값에 사용됩니다. TIMESTAMP의 범위는 '1970-01-01 00:00:01'UTC에서 '2038-01-19 03 : 14:07 'UTC. &quot;</target>
        </trans-unit>
        <trans-unit id="2a7baff4944a28239cf7e6df876079c5edeabf1a" translate="yes" xml:space="preserve">
          <source>The definition of table '%s' prevents operation %s on table '%s'.</source>
          <target state="translated">테이블 '% s'의 정의는 테이블 '% s'의 작업 % s을 (를) 방지합니다.</target>
        </trans-unit>
        <trans-unit id="7dce39f784de311b80444ca9820138586d3b0900" translate="yes" xml:space="preserve">
          <source>The definition of the default &lt;code&gt;root@localhost&lt;/code&gt; user account is:</source>
          <target state="translated">기본 &lt;code&gt;root@localhost&lt;/code&gt; 사용자 계정 의 정의 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c195d6a8d888318314e6d99f8d7552896cc3d81a" translate="yes" xml:space="preserve">
          <source>The definition of the other default &lt;code&gt;root&lt;/code&gt; accounts is similar.</source>
          <target state="translated">다른 기본 &lt;code&gt;root&lt;/code&gt; 계정 의 정의 는 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="f41eee54dda73aac969daf6ff179007f8be15bc4" translate="yes" xml:space="preserve">
          <source>The definition of this &lt;code&gt;mysql@localhost&lt;/code&gt; user account is similar to the &lt;code&gt;root@localhost&lt;/code&gt; user account:</source>
          <target state="translated">이 &lt;code&gt;mysql@localhost&lt;/code&gt; 사용자 계정 의 정의는 &lt;code&gt;root@localhost&lt;/code&gt; 사용자 계정 과 유사 합니다.</target>
        </trans-unit>
        <trans-unit id="de6af92f541707441646b281f2c1cbfd6d90cf96" translate="yes" xml:space="preserve">
          <source>The definitions of two example authentication plugins called &lt;code&gt;two_questions&lt;/code&gt; and &lt;code&gt;three_attempts&lt;/code&gt; can be seen in &lt;code&gt;plugin/auth_examples/dialog_examples.c&lt;/code&gt;. These authentication plugins demonstrate how to communicate with the user using the &lt;code&gt;&lt;a href=&quot;../authentication-plugin-pam/index#dialog&quot;&gt;dialog&lt;/a&gt;&lt;/code&gt; client authentication plugin.</source>
          <target state="translated">&lt;code&gt;two_questions&lt;/code&gt; 및 &lt;code&gt;three_attempts&lt;/code&gt; 라는 두 가지 인증 플러그인의 정의는 &lt;code&gt;plugin/auth_examples/dialog_examples.c&lt;/code&gt; 에서 볼 수 있습니다 . 이 인증 플러그인은 &lt;code&gt;&lt;a href=&quot;../authentication-plugin-pam/index#dialog&quot;&gt;dialog&lt;/a&gt;&lt;/code&gt; 클라이언트 인증 플러그인을 사용하여 사용자와 통신하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="d9e5f1fb94e1d559e8e7fd6c02f5d6991dd41097" translate="yes" xml:space="preserve">
          <source>The definitive list of reserved words for each version is all words that are listed in the &lt;code&gt;sql/lex.h&lt;/code&gt; file that are not listed in the &lt;code&gt;keyword&lt;/code&gt; rule of &lt;code&gt;sql/sql_yacc.yy&lt;/code&gt;, or the &lt;code&gt;keyword_sp&lt;/code&gt; rule that &lt;code&gt;keyword&lt;/code&gt; rule includes.</source>
          <target state="translated">각 버전의 예약어 목록은 &lt;code&gt;keyword&lt;/code&gt; 규칙 &lt;code&gt;sql/sql_yacc.yy&lt;/code&gt; 또는 &lt;code&gt;keyword&lt;/code&gt; 규칙에 포함 된 &lt;code&gt;keyword_sp&lt;/code&gt; 규칙에 나열되지 않은 &lt;code&gt;sql/lex.h&lt;/code&gt; 파일에 나열된 모든 단어입니다 .</target>
        </trans-unit>
        <trans-unit id="74c11c8a4c6fae78d71276315297d813c9227dde" translate="yes" xml:space="preserve">
          <source>The delay in seconds between test executions.</source>
          <target state="translated">테스트 실행 사이의 지연 시간 (초)입니다.</target>
        </trans-unit>
        <trans-unit id="ce1e051dc9c1a0ee13a11a75f9c0f42ddded91d9" translate="yes" xml:space="preserve">
          <source>The delete or update operations triggered by foreign keys do not activate &lt;a href=&quot;../triggers/index&quot;&gt;triggers&lt;/a&gt; and are not counted in the &lt;a href=&quot;../server-status-variables/index#com_delete&quot;&gt;Com_delete&lt;/a&gt; and &lt;a href=&quot;../server-status-variables/index#com_update&quot;&gt;Com_update&lt;/a&gt; status variables.</source>
          <target state="translated">외래 키에 의해 트리거 삭제 또는 업데이트 작업을 활성화하지 않는 &lt;a href=&quot;../triggers/index&quot;&gt;트리거&lt;/a&gt; 와에 포함되지 않습니다 &lt;a href=&quot;../server-status-variables/index#com_delete&quot;&gt;Com_delete&lt;/a&gt; 및 &lt;a href=&quot;../server-status-variables/index#com_update&quot;&gt;Com_update&lt;/a&gt; 상태 변수.</target>
        </trans-unit>
        <trans-unit id="e126ab2459d537ea6b96429fd88406a23260667a" translate="yes" xml:space="preserve">
          <source>The delimiter between the date part and the time part can be a &lt;code&gt;T&lt;/code&gt; or any sequence of space characters (including tabs, new lines and carriage returns).</source>
          <target state="translated">날짜 부분과 시간 부분 사이의 구분 기호는 &lt;code&gt;T&lt;/code&gt; 또는 공백 문자 시퀀스 (탭, 줄 바꿈 및 캐리지 리턴 포함) 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c77785bab6067357dffd6fc7d199cec3eaf161a1" translate="yes" xml:space="preserve">
          <source>The description below applies to &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1014-release-notes/&quot;&gt;MariaDB 10.1.4&lt;/a&gt; and later</source>
          <target state="translated">아래의 설명은 적용 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1014-release-notes/&quot;&gt;MariaDB 10.1.4&lt;/a&gt; 이상</target>
        </trans-unit>
        <trans-unit id="0223f211c5e8c2f729357c1f600a7c1d65c57441" translate="yes" xml:space="preserve">
          <source>The description for &lt;code&gt;&lt;a href=&quot;../show-columns/index&quot;&gt;SHOW COLUMNS&lt;/a&gt;&lt;/code&gt; provides more information about the output columns.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../show-columns/index&quot;&gt;SHOW COLUMNS&lt;/a&gt;&lt;/code&gt; 에 대한 설명 은 출력 열에 대한 자세한 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="368b218122e3cab9e5a1dd21b6559b98fac336ca" translate="yes" xml:space="preserve">
          <source>The description of specific database objects is read out from the COMMENT property of the self-described objects to which this property is attributed.</source>
          <target state="translated">특정 데이터베이스 오브젝트에 대한 설명은이 특성이 부여 된 자체 설명 오브젝트의 COMMENT 특성에서 읽습니다.</target>
        </trans-unit>
        <trans-unit id="e52e0bd2494a617c11fa87c1801dc06e9f932b60" translate="yes" xml:space="preserve">
          <source>The design was brainstormed in April by engineers from MariaDB Corporation, Alibaba and Tencent. A prototype was developed by Vin Chen (陈福荣) from the Tencent Game DBA Team.</source>
          <target state="translated">이 디자인은 MariaDB Corporation, Alibaba 및 Tencent의 엔지니어들에 의해 4 월에 브레인 스토밍되었습니다. 프로토 타입은 Tencent Game DBA 팀의 Vin Chen (陈福荣)이 개발했습니다.</target>
        </trans-unit>
        <trans-unit id="f66743df69b114016cfcfdefe76ea2c270a42117" translate="yes" xml:space="preserve">
          <source>The desires</source>
          <target state="translated">욕망</target>
        </trans-unit>
        <trans-unit id="5e02dace3480e05a1603c5d7b3bbae5f69a065fc" translate="yes" xml:space="preserve">
          <source>The details about the errors are printed into the &lt;a href=&quot;../error-log/index&quot;&gt;error log&lt;/a&gt;. If &lt;a href=&quot;../server-system-variables/index#log_warnings&quot;&gt;log_warnings&lt;/a&gt; &amp;gt; 2, the error log will also have some informational messages which can help with troubleshooting.</source>
          <target state="translated">오류에 대한 자세한 내용은 &lt;a href=&quot;../error-log/index&quot;&gt;오류 로그에&lt;/a&gt; 인쇄됩니다 . 경우 &lt;a href=&quot;../server-system-variables/index#log_warnings&quot;&gt;log_warnings&lt;/a&gt; &amp;gt; 2, 오류 로그는 문제 해결에 도움이되는 몇 가지 정보 메시지를해야합니다.</target>
        </trans-unit>
        <trans-unit id="eec268c361ea8518ee977a92107fb560ac33bb53" translate="yes" xml:space="preserve">
          <source>The development kit can be found under the &lt;a href=&quot;https://github.com/mariadb-corporation/mariadb-columnstore-engine/tree/master/utils/udfsdk&quot;&gt;utils/udfsdk&lt;/a&gt; directory of the mariadb-columnstore-engine source tree. To develop a user defined function requires you to set up a development environment and be comfortable with c++ development. To setup a ColumnStore development environment please follow the instructions on dependencies in the &lt;a href=&quot;https://github.com/mariadb-corporation/mariadb-columnstore-server&quot;&gt;ColumnStore server fork&lt;/a&gt; repository.</source>
          <target state="translated">개발 키트는 mariadb-columnstore-engine 소스 트리 의 &lt;a href=&quot;https://github.com/mariadb-corporation/mariadb-columnstore-engine/tree/master/utils/udfsdk&quot;&gt;utils / udfsdk&lt;/a&gt; 디렉토리에 있습니다. 사용자 정의 함수를 개발하려면 개발 환경을 설정하고 c ++ 개발에 익숙해야합니다. ColumnStore 개발 환경을 설정하려면 &lt;a href=&quot;https://github.com/mariadb-corporation/mariadb-columnstore-server&quot;&gt;ColumnStore 서버 포크&lt;/a&gt; 저장소의 종속성에 대한 지시 사항을 따르십시오 .</target>
        </trans-unit>
        <trans-unit id="57e5f6892aa1a1bcd5912221224b174c3e14ce97" translate="yes" xml:space="preserve">
          <source>The dgcov tool helps you check the coverage for new code</source>
          <target state="translated">dgcov 도구를 사용하면 새 코드의 적용 범위를 확인할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="3741d8d57bf74827001d4aa2cc42f36ea37f125b" translate="yes" xml:space="preserve">
          <source>The diagnostics area contains information about the error conditions which were produced by an SQL statement, as well as some information about the statement which generated them.</source>
          <target state="translated">진단 영역에는 SQL 문에 의해 생성 된 오류 조건에 대한 정보와이를 생성 한 명령문에 대한 정보가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6d64572e10d20f0d57f68f8b85c76c556a08a8a" translate="yes" xml:space="preserve">
          <source>The dictionary object ID for the column (NULL if there is no dictionary object</source>
          <target state="translated">열의 사전 오브젝트 ID (사전 오브젝트가없는 경우 NULL)</target>
        </trans-unit>
        <trans-unit id="2c31ee2fc3f6c4f9fa32918ef27a345ee32dab4e" translate="yes" xml:space="preserve">
          <source>The difference is between these two SQL statements is, if there are two editions of &lt;em&gt;Das Kapital&lt;/em&gt; (with different page counts), then the self-join example will return the books which are longer than the shortest edition of &lt;em&gt;Das Kapital&lt;/em&gt;. That might be the wrong answer, since the original question didn't ask for &quot;... longer than &lt;code&gt;ANY&lt;/code&gt; book named &lt;em&gt;Das Kapital&lt;/em&gt;&quot; (it seems to contain a false assumption that there's only one edition).</source>
          <target state="translated">이 두 SQL 문의 차이점은, 페이지 수가 다른 &lt;em&gt;Das Kapital&lt;/em&gt; 판이 두 개인 경우 자체 결합 예제는 가장 짧은 판인 &lt;em&gt;Das Kapital&lt;/em&gt; 보다 긴 책을 리턴합니다 . 원래 질문에 &quot;... &lt;em&gt;Das Kapital&lt;/em&gt; 이라는 &lt;code&gt;ANY&lt;/code&gt; 책 보다 더 길다&quot;는 요청을하지 않았기 때문에 오답 일 수 있습니다 (단 하나의 판만 있다는 잘못된 가정이 포함되어 있음).&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="205b468c74023974b124bdbb42dcd8ff27083742" translate="yes" xml:space="preserve">
          <source>The difference is that with &lt;code&gt;SQL_SMALL_RESULT&lt;/code&gt; a temporary table is used.</source>
          <target state="translated">차이점은 &lt;code&gt;SQL_SMALL_RESULT&lt;/code&gt; 에서는 임시 테이블이 사용 된다는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="4ad978de670918b76a89dd4cf4fbe5dea11e2e5f" translate="yes" xml:space="preserve">
          <source>The different &lt;code&gt;RESET&lt;/code&gt; options are:</source>
          <target state="translated">다른 &lt;code&gt;RESET&lt;/code&gt; 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="590228e3abed8d113d40c4fa5afebde9119ed4cc" translate="yes" xml:space="preserve">
          <source>The different &lt;code&gt;SQL_MODE&lt;/code&gt; values are:</source>
          <target state="translated">다른 &lt;code&gt;SQL_MODE&lt;/code&gt; 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b7ba925f94372a611ef3e5e1f2905fe2a4504821" translate="yes" xml:space="preserve">
          <source>The different flush options are:</source>
          <target state="translated">다른 플러시 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6347cbb9b71b9b37a4887a72756f4434bcf94816" translate="yes" xml:space="preserve">
          <source>The different kind of transactions can be identified in the output of &lt;a href=&quot;../mysqlbinlog/index&quot;&gt;mysqlbinlog&lt;/a&gt;. For example:</source>
          <target state="translated">&lt;a href=&quot;../mysqlbinlog/index&quot;&gt;mysqlbinlog&lt;/a&gt; 의 출력에서 ​​다른 종류의 트랜잭션을 식별 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="30d149266e173ddf13918088f98295cdb269611b" translate="yes" xml:space="preserve">
          <source>The different values of &lt;code&gt;OLD_MODE&lt;/code&gt; are:</source>
          <target state="translated">&lt;code&gt;OLD_MODE&lt;/code&gt; 의 다른 값은 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="44a6f9609151836039033bf5b70da67093a98b94" translate="yes" xml:space="preserve">
          <source>The different variables and modes to use to affect how MariaDB works.</source>
          <target state="translated">MariaDB 작동 방식에 영향을주는 데 사용되는 다양한 변수 및 모드</target>
        </trans-unit>
        <trans-unit id="b877f062122167bd013364bfb3f586aff2815230" translate="yes" xml:space="preserve">
          <source>The digest text is limited to 1024 bytes. Queries exceeding this limit are truncated with '...', meaning that long queries that would otherwise have different digests may share the same digest.</source>
          <target state="translated">다이제스트 텍스트는 1024 바이트로 제한됩니다. 이 제한을 초과하는 쿼리는 '...'으로 잘립니다. 즉, 다른 다이제스트가있는 긴 쿼리는 동일한 다이제스트를 공유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ef8eb0b169549026e188f03c1d1b694163981c4" translate="yes" xml:space="preserve">
          <source>The directory of data files to be used during testing. The default location is the data directory under the location given by the &lt;code&gt;--stress-suite-basedir&lt;/code&gt; option.</source>
          <target state="translated">테스트 중에 사용될 데이터 파일의 디렉토리. 기본 위치는 &lt;code&gt;--stress-suite-basedir&lt;/code&gt; 옵션으로 지정된 위치 아래의 데이터 디렉토리 입니다.</target>
        </trans-unit>
        <trans-unit id="8fa58a933e4f75a5d5f174aa8f5b081de65d755b" translate="yes" xml:space="preserve">
          <source>The directory specified by &lt;code&gt;&lt;a href=&quot;../ssltls-system-variables/index#ssl_capath&quot;&gt;ssl_capath&lt;/a&gt;&lt;/code&gt; needs to be run through the &lt;code&gt;&lt;a href=&quot;https://www.openssl.org/docs/man1.1.1/man1/rehash.html&quot;&gt;openssl rehash&lt;/a&gt;&lt;/code&gt; command. For example, if the following is configured:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../ssltls-system-variables/index#ssl_capath&quot;&gt;ssl_capath&lt;/a&gt;&lt;/code&gt; 로 지정된 디렉토리 는 &lt;code&gt;&lt;a href=&quot;https://www.openssl.org/docs/man1.1.1/man1/rehash.html&quot;&gt;openssl rehash&lt;/a&gt;&lt;/code&gt; 명령을 통해 실행해야합니다 . 예를 들어, 다음이 구성된 경우 :</target>
        </trans-unit>
        <trans-unit id="0185c2209c598c47c44104a1230b0f1f5c676651" translate="yes" xml:space="preserve">
          <source>The directory specified by &lt;code&gt;&lt;a href=&quot;../ssltls-system-variables/index#ssl_crlpath&quot;&gt;ssl_crlpath&lt;/a&gt;&lt;/code&gt; needs to be run through the &lt;code&gt;&lt;a href=&quot;https://www.openssl.org/docs/man1.1.1/man1/rehash.html&quot;&gt;openssl rehash&lt;/a&gt;&lt;/code&gt; command. For example, if the following is configured:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../ssltls-system-variables/index#ssl_crlpath&quot;&gt;ssl_crlpath&lt;/a&gt;&lt;/code&gt; 로 지정된 디렉토리 는 &lt;code&gt;&lt;a href=&quot;https://www.openssl.org/docs/man1.1.1/man1/rehash.html&quot;&gt;openssl rehash&lt;/a&gt;&lt;/code&gt; 명령을 통해 실행해야합니다 . 예를 들어, 다음이 구성된 경우 :</target>
        </trans-unit>
        <trans-unit id="68fa2fee2fde12944e478c89c50afe3f66106cf2" translate="yes" xml:space="preserve">
          <source>The directory specified by this option needs to be run through the &lt;code&gt;&lt;a href=&quot;https://www.openssl.org/docs/man1.1.1/man1/rehash.html&quot;&gt;openssl rehash&lt;/a&gt;&lt;/code&gt; command.</source>
          <target state="translated">이 옵션으로 지정된 디렉토리는 &lt;code&gt;&lt;a href=&quot;https://www.openssl.org/docs/man1.1.1/man1/rehash.html&quot;&gt;openssl rehash&lt;/a&gt;&lt;/code&gt; 명령을 통해 실행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5c593c7c4573fa344aba29d08262659f038f4ed5" translate="yes" xml:space="preserve">
          <source>The directory storing the binary logs will contain a binary log index, as well as the individual binary log files.</source>
          <target state="translated">이진 로그를 저장하는 디렉토리에는 이진 로그 색인과 개별 이진 로그 파일이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="5b23c896b55a164906192746fbc2ab1aaa1f27dd" translate="yes" xml:space="preserve">
          <source>The directory where files generated from the test run is stored (default: ./var). Specifying a ramdisk or tmpfs will speed up tests. The environment variable MYSQLTEST_VARDIR will be set to the path for this directory, whether it has the default value or has been set explicitly. This may be referred to in tests.</source>
          <target state="translated">테스트 실행에서 생성 된 파일이 저장되는 디렉토리 (기본값 : ./var) 램 디스크 또는 tmpfs를 지정하면 테스트 속도가 빨라집니다. 환경 변수 MYSQLTEST_VARDIR은 기본값이 있거나 명시 적으로 설정되었는지 여부에 관계없이이 디렉토리의 경로로 설정됩니다. 이것은 테스트에서 참조 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f029332fcea5adbd83e01b12afb979d27dcd7a20" translate="yes" xml:space="preserve">
          <source>The directory where temporary files are stored (default: ./var/tmp). The environment variable MYSQL_TMP_DIR will be set to the path for this directory, whether it has the default value or has been set explicitly. This may be referred to in tests.</source>
          <target state="translated">임시 파일이 저장되는 디렉토리 (기본값 : ./var/tmp) 환경 변수 MYSQL_TMP_DIR은 기본값이 있거나 명시 적으로 설정되었는지 여부에 관계없이이 디렉토리의 경로로 설정됩니다. 이것은 테스트에서 참조 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ce77b0e31456b76874f5b71eb80b7ef569b5f91" translate="yes" xml:space="preserve">
          <source>The disadvantages are:</source>
          <target state="translated">단점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="75e7a5b13bf1b66a6290b8b7a1cca61b081bc9c4" translate="yes" xml:space="preserve">
          <source>The disk device being used will need to have its user permissions set to the non-root user name. This is an example command run as 'root' user setting the user ownership of dbroot /dev/sda1 to non-root user of 'guest':</source>
          <target state="translated">사용중인 디스크 장치의 사용자 권한이 루트가 아닌 사용자 이름으로 설정되어 있어야합니다. 다음은 dbroot / dev / sda1의 사용자 소유권을 루트가 아닌 'guest'사용자로 설정하는 'root'사용자로 실행되는 명령 예제입니다.</target>
        </trans-unit>
        <trans-unit id="a082d057aa0bebdf084318a740f137ea1c1b1694" translate="yes" xml:space="preserve">
          <source>The disk device being used will need to have its user permissions set to the non-root user name. This is an example command run as 'root' user setting the user ownership of dbroot /dev/sda1 to non-root user of 'mysql':</source>
          <target state="translated">사용중인 디스크 장치의 사용자 권한이 루트가 아닌 사용자 이름으로 설정되어 있어야합니다. 다음은 dbroot / dev / sda1의 사용자 소유권을 루트가 아닌 'mysql'사용자로 설정하는 'root'사용자로 실행되는 명령 예제입니다.</target>
        </trans-unit>
        <trans-unit id="bfaade5f31afcc79a214d4ba1b050bb44272089d" translate="yes" xml:space="preserve">
          <source>The disk drive (Windows)</source>
          <target state="translated">디스크 드라이브 (Windows)</target>
        </trans-unit>
        <trans-unit id="c7553c1d246aebe5d1fa332aa563a4f6053096b0" translate="yes" xml:space="preserve">
          <source>The disk file size for the extent</source>
          <target state="translated">익스텐트의 디스크 파일 크기</target>
        </trans-unit>
        <trans-unit id="063eea689ee41d365d6b6fc0ed7061cc1cd74ac2" translate="yes" xml:space="preserve">
          <source>The disk footprint is smaller; Smaller --&amp;gt; More cacheable --&amp;gt; Faster</source>
          <target state="translated">디스크 풋 프린트가 더 작습니다. 작게-&amp;gt; 더 캐시 가능-&amp;gt; 더 빠름</target>
        </trans-unit>
        <trans-unit id="ae782290989cf53870cef84d4f2ba30c2f225fbf" translate="yes" xml:space="preserve">
          <source>The disk-based &lt;a href=&quot;http://galeracluster.com/documentation-webpages/statetransfer.html#write-set-cache-gcache&quot;&gt;Galera gcache&lt;/a&gt; is not encrypted (&lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-8072&quot;&gt;MDEV-8072&lt;/a&gt;).</source>
          <target state="translated">디스크 기반 &lt;a href=&quot;http://galeracluster.com/documentation-webpages/statetransfer.html#write-set-cache-gcache&quot;&gt;Galera gcache&lt;/a&gt; 는 암호화되지 않습니다 ( &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-8072&quot;&gt;MDEV-8072&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="5e38b1b886cc567d2dd1acae5abe1772b73229c0" translate="yes" xml:space="preserve">
          <source>The disk-based &lt;a href=&quot;http://galeracluster.com/documentation-webpages/statetransfer.html#write-set-cache-gcache&quot;&gt;Galera gcache&lt;/a&gt; is not encrypted (&lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-8072&quot;&gt;MDEV-8072&lt;/a&gt;). This is planned for &lt;a href=&quot;../what-is-mariadb-104/index&quot;&gt;MariaDB 10.4&lt;/a&gt;.</source>
          <target state="translated">디스크 기반 &lt;a href=&quot;http://galeracluster.com/documentation-webpages/statetransfer.html#write-set-cache-gcache&quot;&gt;Galera gcache&lt;/a&gt; 는 암호화되지 않습니다 ( &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-8072&quot;&gt;MDEV-8072&lt;/a&gt; ). 이것은 &lt;a href=&quot;../what-is-mariadb-104/index&quot;&gt;MariaDB 10.4&lt;/a&gt; 용으로 계획되었습니다 .</target>
        </trans-unit>
        <trans-unit id="c239285f7b74194509e0b0e265abcfc72aa8c779" translate="yes" xml:space="preserve">
          <source>The displayed result:</source>
          <target state="translated">표시된 결과 :</target>
        </trans-unit>
        <trans-unit id="2f22734ccd96f8323a8e4c0c98ec9fd3fbb9d678" translate="yes" xml:space="preserve">
          <source>The distance between two geometries</source>
          <target state="translated">두 도형 사이의 거리</target>
        </trans-unit>
        <trans-unit id="4aaa734f5665d20deb5ae83caf583af56d273a15" translate="yes" xml:space="preserve">
          <source>The distance between two geometries.</source>
          <target state="translated">두 도형 사이의 거리입니다.</target>
        </trans-unit>
        <trans-unit id="4fc48a9d6bb93e2976ebbce69c2f0d35f0b1d87d" translate="yes" xml:space="preserve">
          <source>The distinction between &lt;a href=&quot;../dense_rank/index&quot;&gt;DENSE_RANK()&lt;/a&gt;, &lt;a href=&quot;../rank/index&quot;&gt;RANK()&lt;/a&gt; and ROW_NUMBER():</source>
          <target state="translated">&lt;a href=&quot;../dense_rank/index&quot;&gt;DENSE_RANK ()&lt;/a&gt; , &lt;a href=&quot;../rank/index&quot;&gt;RANK ()&lt;/a&gt; 및 ROW_NUMBER () 의 차이점 :</target>
        </trans-unit>
        <trans-unit id="35745a8725a06a68d2d39343c1c8293e956bf4f2" translate="yes" xml:space="preserve">
          <source>The distinction between &lt;a href=&quot;../dense_rank/index&quot;&gt;DENSE_RANK()&lt;/a&gt;, RANK() and &lt;a href=&quot;../row_number/index&quot;&gt;ROW_NUMBER()&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;../dense_rank/index&quot;&gt;DENSE_RANK ()&lt;/a&gt; , RANK () 및 &lt;a href=&quot;../row_number/index&quot;&gt;ROW_NUMBER ()&lt;/a&gt; 의 차이점 :</target>
        </trans-unit>
        <trans-unit id="5ab7231a199f8cc17b2473961af67ca5c98d05a4" translate="yes" xml:space="preserve">
          <source>The distinction between DENSE_RANK(), &lt;a href=&quot;../rank/index&quot;&gt;RANK()&lt;/a&gt; and &lt;a href=&quot;../row_number/index&quot;&gt;ROW_NUMBER()&lt;/a&gt;:</source>
          <target state="translated">DENSE_RANK (), &lt;a href=&quot;../rank/index&quot;&gt;RANK ()&lt;/a&gt; 및 &lt;a href=&quot;../row_number/index&quot;&gt;ROW_NUMBER ()&lt;/a&gt; 의 차이점 :</target>
        </trans-unit>
        <trans-unit id="2bc260de65b2bb1ecb271e5788f301048148bc5b" translate="yes" xml:space="preserve">
          <source>The distributions currently supported by the script include:</source>
          <target state="translated">스크립트가 현재 지원하는 배포판은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="caa07e485574cecdf6529ec19bac1649613e1519" translate="yes" xml:space="preserve">
          <source>The document is accepted, but the coordinates for higher coordinate dimensions are stripped off.</source>
          <target state="translated">문서는 수락되지만 더 높은 좌표 치수의 좌표는 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="2cb8a7ddb5844a34a5bf957c3479ef634602f192" translate="yes" xml:space="preserve">
          <source>The documentation below is the best place to get started with building and developing against the C++ SDK. Some sample programs are installed to /usr/share/doc/mcsapi/ for review.</source>
          <target state="translated">아래 문서는 C ++ SDK에 대한 빌드 및 개발을 시작하기에 가장 좋은 장소입니다. 일부 샘플 프로그램은 검토를 위해 / usr / share / doc / mcsapi /에 설치됩니다.</target>
        </trans-unit>
        <trans-unit id="eb99950b29462b234c3bb44e2075f5cadcaaf159" translate="yes" xml:space="preserve">
          <source>The domain ID, the first component of the GTID, is used to handle this.</source>
          <target state="translated">GTID의 첫 번째 구성 요소 인 도메인 ID가이를 처리하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1bf7eec15d5b047a4d37876a1f424af0823e20d2" translate="yes" xml:space="preserve">
          <source>The double write buffer provides such a copy.</source>
          <target state="translated">이중 쓰기 버퍼는 이러한 사본을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b4168a497c02a273c1bfd840f646c8d0300bb858" translate="yes" xml:space="preserve">
          <source>The drawback is that there could be more than 1000 items with a single id. In most practical cases, that is unlikely.</source>
          <target state="translated">단점은 단일 ID를 가진 1000 개가 넘는 항목이있을 수 있다는 것입니다. 대부분의 실제 경우에는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aad2239e225a6fcba3cba1cd5070e82a0781a692" translate="yes" xml:space="preserve">
          <source>The duds</source>
          <target state="translated">친구</target>
        </trans-unit>
        <trans-unit id="ba7a25a0cde9952856c256f099bde55cca5b5f8c" translate="yes" xml:space="preserve">
          <source>The dump will be fully non-blocking if both the mysqldump program and the queried server include the necessary feature (eg. both are from &lt;a href=&quot;../what-is-mariadb-52/index&quot;&gt;MariaDB 5.2&lt;/a&gt;-rpl, 5.3, or higher). In other cases, it will fall back to the old blocking method using &lt;code&gt;FLUSH TABLES WITH READ LOCK&lt;/code&gt;.</source>
          <target state="translated">mysqldump 프로그램과 쿼리 된 서버 모두에 필요한 기능이 포함되어 있으면 덤프는 완전히 비 차단됩니다 (예 : 둘 다 &lt;a href=&quot;../what-is-mariadb-52/index&quot;&gt;MariaDB 5.2&lt;/a&gt; -rpl, 5.3 이상). 다른 경우에는 &lt;code&gt;FLUSH TABLES WITH READ LOCK&lt;/code&gt; 을 사용하여 이전 차단 방법으로 대체 됩니다.</target>
        </trans-unit>
        <trans-unit id="b399e2c1793c53c4cd1b6ffe1d0c08a36122aac9" translate="yes" xml:space="preserve">
          <source>The duration of stress testing in seconds.</source>
          <target state="translated">스트레스 테스트 기간 (초)입니다.</target>
        </trans-unit>
        <trans-unit id="306d4049687e329902a2b18abf743d69ae281d1f" translate="yes" xml:space="preserve">
          <source>The dynamic columns feature was introduced into MariaDB in two steps:</source>
          <target state="translated">동적 열 기능은 다음 두 단계로 MariaDB에 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="6dd4500796a911583c2bab648b63d187c15ea239" translate="yes" xml:space="preserve">
          <source>The easiest approach is to run MariaDB Server in an EC2 instance that has an IAM Role with User access to the CMK you wish to use. You can give key access privileges to a Role already attached to your EC2 instance, or you can create a new IAM Role and attach it to an already-running EC2 instance. If you've done that, no further credentials management is required and you do not need to create a &lt;code&gt;credentials&lt;/code&gt; file.</source>
          <target state="translated">가장 쉬운 방법은 사용하려는 CMK에 대한 사용자 액세스 권한이있는 IAM 역할이있는 EC2 인스턴스에서 MariaDB 서버를 실행하는 것입니다. EC2 인스턴스에 이미 연결된 역할에 키 액세스 권한을 부여하거나 새 IAM 역할을 생성하여 이미 실행중인 EC2 인스턴스에 연결할 수 있습니다. 그렇게 한 경우 추가 자격 증명 관리가 필요하지 않으며 &lt;code&gt;credentials&lt;/code&gt; 파일 을 만들 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="9c479039a74cc11d845b681e01525fac17371920" translate="yes" xml:space="preserve">
          <source>The easiest way to allow the &lt;code&gt;&lt;a href=&quot;https://linux.die.net/man/8/logrotate&quot;&gt;logrotate&lt;/a&gt;&lt;/code&gt; utility to authenticate with MariaDB is to configure the &lt;code&gt;root@localhost&lt;/code&gt; user account to use &lt;code&gt;&lt;a href=&quot;../authentication-plugin-unix-socket/index&quot;&gt;unix_socket&lt;/a&gt;&lt;/code&gt; authentication.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://linux.die.net/man/8/logrotate&quot;&gt;logrotate&lt;/a&gt;&lt;/code&gt; 유틸리티가 MariaDB를 인증 하도록하는 가장 쉬운 방법 은 &lt;code&gt;&lt;a href=&quot;../authentication-plugin-unix-socket/index&quot;&gt;unix_socket&lt;/a&gt;&lt;/code&gt; 인증 을 사용 하도록 &lt;code&gt;root@localhost&lt;/code&gt; 사용자 계정을 구성하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="99741afc7b2545e5739764ebc1a36c9d51889dbc" translate="yes" xml:space="preserve">
          <source>The easiest way to create a user account with the &lt;code&gt;mysql_native_password&lt;/code&gt; authentication plugin is to make sure that &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#old_passwords&quot;&gt;old_passwords=0&lt;/a&gt;&lt;/code&gt; is set, and then create a user account via &lt;code&gt;&lt;a href=&quot;../create-user/index&quot;&gt;CREATE USER&lt;/a&gt;&lt;/code&gt; that does not specify an authentication plugin, but does specify a password via the &lt;code&gt;&lt;a href=&quot;../create-user/index#identified-by-password&quot;&gt;IDENTIFIED BY&lt;/a&gt;&lt;/code&gt; clause. For example:</source>
          <target state="translated">&lt;code&gt;mysql_native_password&lt;/code&gt; 인증 플러그인 으로 사용자 계정을 작성하는 가장 쉬운 방법 은 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#old_passwords&quot;&gt;old_passwords=0&lt;/a&gt;&lt;/code&gt; 이 설정되어 있는지 확인한 다음 인증 플러그인을 지정하지 않지만 &lt;code&gt;&lt;a href=&quot;../create-user/index#identified-by-password&quot;&gt;IDENTIFIED BY&lt;/a&gt;&lt;/code&gt; 를 통해 비밀번호를 지정하는 &lt;code&gt;&lt;a href=&quot;../create-user/index&quot;&gt;CREATE USER&lt;/a&gt;&lt;/code&gt; 를 통해 사용자 계정을 작성하는 것입니다. 절. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="61d5f22b9f06e6c2b9eb0e163abdb014b57520c8" translate="yes" xml:space="preserve">
          <source>The easiest way to create a user account with the &lt;code&gt;mysql_old_password&lt;/code&gt; authentication plugin is to make sure that &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#old_passwords&quot;&gt;old_passwords=1&lt;/a&gt;&lt;/code&gt; is set, and then create a user account via &lt;code&gt;&lt;a href=&quot;../create-user/index&quot;&gt;CREATE USER&lt;/a&gt;&lt;/code&gt; that does not specify an authentication plugin, but does specify a password via the &lt;code&gt;&lt;a href=&quot;../create-user/index#identified-by-password&quot;&gt;IDENTIFIED BY&lt;/a&gt;&lt;/code&gt; clause. For example:</source>
          <target state="translated">&lt;code&gt;mysql_old_password&lt;/code&gt; 인증 플러그인 으로 사용자 계정을 만드는 가장 쉬운 방법 은 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#old_passwords&quot;&gt;old_passwords=1&lt;/a&gt;&lt;/code&gt; 이 설정되어 있는지 확인한 다음 인증 플러그인을 지정하지 않지만 &lt;code&gt;&lt;a href=&quot;../create-user/index#identified-by-password&quot;&gt;IDENTIFIED BY&lt;/a&gt;&lt;/code&gt; 를 통해 비밀번호를 지정하는 &lt;code&gt;&lt;a href=&quot;../create-user/index&quot;&gt;CREATE USER&lt;/a&gt;&lt;/code&gt; 를 통해 사용자 계정을 작성하는 것입니다. 절. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2bf49dc744a2750c96f2409f3d95956fda20d0bb" translate="yes" xml:space="preserve">
          <source>The easiest way to create an InnoDB table that uses the &lt;code&gt;REDUNDANT&lt;/code&gt; row format is by setting the &lt;code&gt;&lt;a href=&quot;../create-table/index#row_format&quot;&gt;ROW_FORMAT&lt;/a&gt;&lt;/code&gt; table option to &lt;code&gt;REDUNDANT&lt;/code&gt; in a &lt;code&gt;&lt;a href=&quot;../create-table/index&quot;&gt;CREATE TABLE&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt;&lt;/code&gt; statement.</source>
          <target state="translated">&lt;code&gt;REDUNDANT&lt;/code&gt; 행 형식 을 사용하는 InnoDB 테이블을 작성하는 가장 쉬운 방법 은 &lt;code&gt;&lt;a href=&quot;../create-table/index&quot;&gt;CREATE TABLE&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt;&lt;/code&gt; 문 에서 &lt;code&gt;&lt;a href=&quot;../create-table/index#row_format&quot;&gt;ROW_FORMAT&lt;/a&gt;&lt;/code&gt; 테이블 옵션을 &lt;code&gt;REDUNDANT&lt;/code&gt; 로 설정하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="c6a382121dcead509f15831d12f40b861fee1004" translate="yes" xml:space="preserve">
          <source>The easiest way to get basic information on plugins is with &lt;code&gt;&lt;a href=&quot;../show-plugins/index&quot;&gt;SHOW PLUGINS&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">플러그인에 대한 기본 정보를 얻는 가장 쉬운 방법은 &lt;code&gt;&lt;a href=&quot;../show-plugins/index&quot;&gt;SHOW PLUGINS&lt;/a&gt;&lt;/code&gt; 를 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="c2311a5c3a091768db57e17e488a004de3d470ce" translate="yes" xml:space="preserve">
          <source>The easiest way to give the AWS key management plugin access to the key is to create an IAM Role with access to the key, and to apply that IAM Role to an EC2 instance where MariaDB Server runs.</source>
          <target state="translated">AWS 키 관리 플러그인에 키에 대한 액세스 권한을 부여하는 가장 쉬운 방법은 키에 대한 액세스 권한이있는 IAM 역할을 생성하고 해당 IAM 역할을 MariaDB 서버가 실행되는 EC2 인스턴스에 적용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3a93a66a6df4b22e88a903537256998b5e4fa26c" translate="yes" xml:space="preserve">
          <source>The easiest way to use MariaDB on Docker is choosing a MariaDB image and creating a container.</source>
          <target state="translated">Docker에서 MariaDB를 사용하는 가장 쉬운 방법은 MariaDB 이미지를 선택하고 컨테이너를 만드는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e7cad2ca31920237d88835f3b27ccb00f4000a09" translate="yes" xml:space="preserve">
          <source>The effect of many of these bugs is that the table seems to &lt;em&gt;forget&lt;/em&gt; that its tablespace file is in the &lt;a href=&quot;#non-canonical-storage-format-caused-by-some-operations&quot;&gt;non-canonical storage format&lt;/a&gt;.</source>
          <target state="translated">이러한 많은 버그의 영향으로 인해 테이블 ​​스페이스 파일이 &lt;a href=&quot;#non-canonical-storage-format-caused-by-some-operations&quot;&gt;비정규 스토리지 형식&lt;/a&gt; 임을 테이블이 &lt;em&gt;잊어 버린&lt;/em&gt; 것 같습니다 .</target>
        </trans-unit>
        <trans-unit id="19ce296542d0593c32762963f298bf809e468e6b" translate="yes" xml:space="preserve">
          <source>The effect of this is that a flush (write of logs + sync) will save all data for all threads/transactions that have been waiting since the last flush.</source>
          <target state="translated">그 결과 플러시 (로그 쓰기 + 동기화)는 마지막 플러시 이후 대기 한 모든 스레드 / 트랜잭션에 대한 모든 데이터를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="78c877b4788978896d0ef1031e75b08caa66ac0b" translate="yes" xml:space="preserve">
          <source>The effective maximum size might be lower than what is set, depending on the server's available physical RAM and the per-process limit determined by the operating system.</source>
          <target state="translated">유효 최대 크기는 서버의 사용 가능한 실제 RAM 및 운영 체제에 의해 결정된 프로세스 별 한계에 따라 설정된 것보다 작을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="87b8dbd1535844d7535461db87892cfdf3890eb6" translate="yes" xml:space="preserve">
          <source>The effects of terminating the query because of LIMIT ROWS EXAMINED are as follows:</source>
          <target state="translated">LIMIT ROWS EXAMINED로 인한 쿼리 종료 효과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="417c1667574165df9df6636cb81e2ec0248aec18" translate="yes" xml:space="preserve">
          <source>The effects of the &lt;code&gt;AFTER_COMMIT&lt;/code&gt; wait point are:</source>
          <target state="translated">&lt;code&gt;AFTER_COMMIT&lt;/code&gt; 대기 점 의 영향은 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a9794f720ac3a115ef23a9d0828085d2d77e5ec9" translate="yes" xml:space="preserve">
          <source>The effects of the &lt;code&gt;AFTER_SYNC&lt;/code&gt; wait point are:</source>
          <target state="translated">&lt;code&gt;AFTER_SYNC&lt;/code&gt; 대기 점 의 효과는 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ef35d5021be576b800f83ad9cc81bf4ab50bff30" translate="yes" xml:space="preserve">
          <source>The effects of this clause are as follows:</source>
          <target state="translated">이 절의 효과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3d7252ffecf91cf75edc313c8ffb225477bf53f5" translate="yes" xml:space="preserve">
          <source>The efficiency of the subquery cache is visible in 2 statistical variables:</source>
          <target state="translated">하위 쿼리 캐시의 효율성은 두 가지 통계 변수에서 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e6fa13f01ad308976ace4519ee246d214af729d" translate="yes" xml:space="preserve">
          <source>The emails are formatted as JSON. Further customization of the CloudWatch email workflow is beyond the scope of this document.</source>
          <target state="translated">이메일은 JSON 형식으로되어 있습니다. CloudWatch 이메일 워크 플로우의 추가 사용자 정의는이 문서에서 다루지 않습니다.</target>
        </trans-unit>
        <trans-unit id="514728cc69a3b0f297d0e970aa2c201c3b9b4949" translate="yes" xml:space="preserve">
          <source>The enabled role name, or &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">역할 이름 또는 활성화 &lt;code&gt;NULL&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="b0cd55844a116ca7dd1526cfbdf6c8ac65873862" translate="yes" xml:space="preserve">
          <source>The encoding of the new document, defaulting to UTF-8.</source>
          <target state="translated">새 문서의 인코딩으로 기본값은 UTF-8입니다.</target>
        </trans-unit>
        <trans-unit id="99b0ebd10511b85d35c8376eff4f1d2609f785f4" translate="yes" xml:space="preserve">
          <source>The encryption algorithm can be configured by setting the &lt;code&gt;&lt;a href=&quot;#file_key_management_encryption_algorithm&quot;&gt;file_key_management_encryption_algorithm&lt;/a&gt;&lt;/code&gt; system variable.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#file_key_management_encryption_algorithm&quot;&gt;file_key_management_encryption_algorithm&lt;/a&gt;&lt;/code&gt; 시스템 변수를 설정하여 암호화 알고리즘을 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="256d38188df14f58b0a87b370c0f7eb124e00377" translate="yes" xml:space="preserve">
          <source>The encryption key is created from the &lt;a href=&quot;https://en.wikipedia.org/wiki/SHA-1&quot;&gt;SHA-1&lt;/a&gt; hash of the encryption password.</source>
          <target state="translated">암호화 키는 암호화 비밀번호 의 &lt;a href=&quot;https://en.wikipedia.org/wiki/SHA-1&quot;&gt;SHA-1&lt;/a&gt; 해시 에서 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="41c7b55e9160a0c4d33cea6df270b271161815ff" translate="yes" xml:space="preserve">
          <source>The encryption key size can be 128-bits, 192-bits, or 256-bits.</source>
          <target state="translated">암호화 키 크기는 128 비트, 192 비트 또는 256 비트 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f10d090808b3157461fc57f4e03d14346d750680" translate="yes" xml:space="preserve">
          <source>The encryption key to use is chosen based on the second argument to &lt;code&gt;DES_ENCRYPT()&lt;/code&gt;, if one was given. With no argument, the first key from the DES key file is used. With a &lt;em&gt;&lt;code&gt;key_num&lt;/code&gt;&lt;/em&gt; argument, the given key number (0-9) from the DES key file is used. With a &lt;em&gt;&lt;code&gt;key_str&lt;/code&gt;&lt;/em&gt; argument, the given key string is used to encrypt &lt;em&gt;&lt;code&gt;str&lt;/code&gt;&lt;/em&gt;.</source>
          <target state="translated">사용할 암호화 키는 &lt;code&gt;DES_ENCRYPT()&lt;/code&gt; 의 두 번째 인수 ( 제공된 경우 ) 를 기반으로 선택 됩니다. 인수없이 DES 키 파일의 첫 번째 키가 사용됩니다. A를 &lt;em&gt; &lt;code&gt;key_num&lt;/code&gt; &lt;/em&gt; 인수는 DES 키 파일에서 지정된 키 번호 (0-9)가 사용됩니다. A를 &lt;em&gt; &lt;code&gt;key_str&lt;/code&gt; &lt;/em&gt; 인수, 지정된 키 문자열을 암호화하는 데 사용되는 &lt;em&gt; &lt;code&gt;str&lt;/code&gt; &lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="8a85fae242c5e51736e43f20a8b3429f5bf828ea" translate="yes" xml:space="preserve">
          <source>The encryption password has a max length of 256 characters.</source>
          <target state="translated">암호화 비밀번호의 최대 길이는 256 자입니다.</target>
        </trans-unit>
        <trans-unit id="1f4886bc35d9da9d5bf9c3d9bc1918713b0857b3" translate="yes" xml:space="preserve">
          <source>The engine (in the &lt;code&gt;::check_if_incompatible_data()&lt;/code&gt; method) is responsible for comparing new values of the attributes from the &lt;code&gt;HA_CREATE_INFO&lt;/code&gt; structure with the old values from the table and returning &lt;code&gt;COMPATIBLE_DATA_NO&lt;/code&gt; if they were changed in such a way that requires the table to be rebuild.</source>
          <target state="translated">엔진 ( &lt;code&gt;::check_if_incompatible_data()&lt;/code&gt; 메소드에서)은 &lt;code&gt;HA_CREATE_INFO&lt;/code&gt; 구조 의 속성의 새 값을 테이블의 이전 값과 비교 하고 테이블을 다시 빌드해야하는 방식으로 변경된 경우 &lt;code&gt;COMPATIBLE_DATA_NO&lt;/code&gt; 를 리턴 합니다. .</target>
        </trans-unit>
        <trans-unit id="b983e238749ada292e7d51160ce8c765cac78a01" translate="yes" xml:space="preserve">
          <source>The engine declared attributes can be specified per field, index, or table in the &lt;code&gt;CREATE TABLE&lt;/code&gt; or &lt;code&gt;ALTER TABLE&lt;/code&gt;. The syntax is the conventional:</source>
          <target state="translated">엔진 선언 속성은 &lt;code&gt;CREATE TABLE&lt;/code&gt; 또는 &lt;code&gt;ALTER TABLE&lt;/code&gt; 의 필드, 색인 또는 테이블별로 지정할 수 있습니다 . 구문은 일반적인 것입니다.</target>
        </trans-unit>
        <trans-unit id="b924bad3a1ba6014ff42d0258cf712303bf81fd8" translate="yes" xml:space="preserve">
          <source>The engine declares a structure &lt;code&gt;ha_table_option_struct
&lt;/code&gt; that will hold values of these new attributes.</source>
          <target state="translated">엔진은 이러한 새 속성의 값을 보유 할 구조 &lt;code&gt;ha_table_option_struct &lt;/code&gt; 를 선언 합니다.</target>
        </trans-unit>
        <trans-unit id="e6d4312c17ab22a14c61f345c03141e75450154c" translate="yes" xml:space="preserve">
          <source>The engine-independent table statistics feature was first implemented in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1001-release-notes/&quot;&gt;MariaDB 10.0.1&lt;/a&gt; and, it was first enabled for queries by default in &lt;a href=&quot;../what-is-mariadb-104/index&quot;&gt;MariaDB 10.4&lt;/a&gt;.</source>
          <target state="translated">엔진 독립적 인 테이블 통계 기능은 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1001-release-notes/&quot;&gt;MariaDB 10.0.1&lt;/a&gt; 에서 처음 구현 되었으며 &lt;a href=&quot;../what-is-mariadb-104/index&quot;&gt;MariaDB 10.4&lt;/a&gt; 에서 기본적으로 쿼리에 대해 활성화되었습니다 .</target>
        </trans-unit>
        <trans-unit id="64f381eac0509ac415386a7c54bc3275ca02a312" translate="yes" xml:space="preserve">
          <source>The entire thread pool has fewer than &lt;code&gt;&lt;a href=&quot;../thread-pool-system-status-variables/index#thread_pool_max_threads&quot;&gt;thread_pool_max_threads&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">전체 스레드 풀의 수가 &lt;code&gt;&lt;a href=&quot;../thread-pool-system-status-variables/index#thread_pool_max_threads&quot;&gt;thread_pool_max_threads&lt;/a&gt;&lt;/code&gt; 보다 적습니다 .</target>
        </trans-unit>
        <trans-unit id="44760457fb2620b60a528c76c48239268435f0ff" translate="yes" xml:space="preserve">
          <source>The equal sign as an assignment operator.</source>
          <target state="translated">대입 연산자로서의 등호.</target>
        </trans-unit>
        <trans-unit id="8cbe73d669665cac60cb02ab98378e2a4de1e02b" translate="yes" xml:space="preserve">
          <source>The equal sign is optional.</source>
          <target state="translated">등호는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="b727e27c45d6d2fce848ff0fa7511edd6e2d1613" translate="yes" xml:space="preserve">
          <source>The equal sign is used as both an assignment operator in certain contexts, and as a &lt;a href=&quot;../equal/index&quot;&gt;comparison operator&lt;/a&gt;. When used as assignment operator, the value on the right is assigned to the variable (or column, in some contexts) on the left.</source>
          <target state="translated">등호는 특정 상황에서 대입 연산자와 &lt;a href=&quot;../equal/index&quot;&gt;비교 연산자로 사용&lt;/a&gt; 됩니다. 대입 연산자로 사용하면 오른쪽의 값이 왼쪽의 변수 (또는 일부 상황에서는 열)에 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="ccd88d84610130b3071b6998690d5a7aac7c532c" translate="yes" xml:space="preserve">
          <source>The equivalent &lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt; query would be:</source>
          <target state="translated">동등한 &lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt; 쿼리는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="81de9e0970f18e08b356337824e4f928b546b9c7" translate="yes" xml:space="preserve">
          <source>The equivalent of above, if done specifying all the connection parameters</source>
          <target state="translated">모든 연결 매개 변수를 지정한 경우 위와 동일</target>
        </trans-unit>
        <trans-unit id="ea8d5fcec6c02dcea7714f2a1bdbc0a424fa94d2" translate="yes" xml:space="preserve">
          <source>The error is also produced if the table is properly define, but an underlying table's definition changes at some point in time.</source>
          <target state="translated">테이블이 올바르게 정의 된 경우에도 오류가 발생하지만 기본 테이블의 정의는 특정 시점에서 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="37e72e0a765a9f31b9916b814ae4cd4d77e87c32" translate="yes" xml:space="preserve">
          <source>The error is very descriptive.</source>
          <target state="translated">오류는 매우 설명 적입니다.</target>
        </trans-unit>
        <trans-unit id="83bc66e5e3f481dac86296f443e66472712a2eec" translate="yes" xml:space="preserve">
          <source>The error log</source>
          <target state="translated">오류 로그</target>
        </trans-unit>
        <trans-unit id="d19ac0743e5471edf5d60aca08ec9dacc0232b8a" translate="yes" xml:space="preserve">
          <source>The error log contains a record of critical errors that occurred during the server's operation, table corruption, start and stop information.</source>
          <target state="translated">오류 로그에는 서버 작동, 테이블 손상, 시작 및 중지 정보 중 발생한 심각한 오류 레코드가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="1d6a5a82cdfaf63bdece53c6e4f3ad01328150cf" translate="yes" xml:space="preserve">
          <source>The error message will be a bit more descriptive in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10217-release-notes/&quot;&gt;MariaDB 10.2.17&lt;/a&gt; and later:</source>
          <target state="translated">오류 메시지는 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10217-release-notes/&quot;&gt;MariaDB 10.2.17&lt;/a&gt; 이상에서 조금 더 설명 적입니다 .</target>
        </trans-unit>
        <trans-unit id="9717d9a0c700663662ff03c979eb367b79dac966" translate="yes" xml:space="preserve">
          <source>The error properties, their type and their default values are explained in the &lt;a href=&quot;../diagnostics-area/index&quot;&gt;diagnostics area&lt;/a&gt; page.</source>
          <target state="translated">오류 속성, 유형 및 기본값은 &lt;a href=&quot;../diagnostics-area/index&quot;&gt;진단 영역&lt;/a&gt; 페이지에 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="561e298790e5ba03b32c83827b664250a73fd5af" translate="yes" xml:space="preserve">
          <source>The escape sequence &lt;code&gt;\K&lt;/code&gt; causes any previously matched characters to be excluded from the final matched sequence. For example, the pattern: &lt;code&gt;(foo)\Kbar&lt;/code&gt; matches &lt;code&gt;foobar&lt;/code&gt;, but reports that it has matched &lt;code&gt;bar&lt;/code&gt;. This feature is similar to a look-behind assertion. However, in this case, the part of the subject before the real match does not have to be of fixed length:</source>
          <target state="translated">이스케이프 시퀀스 &lt;code&gt;\K&lt;/code&gt; 하면 이전에 일치 한 문자가 최종 일치 시퀀스에서 제외됩니다. 예를 들어, &lt;code&gt;(foo)\Kbar&lt;/code&gt; 패턴 은 &lt;code&gt;foobar&lt;/code&gt; 와 일치 하지만 &lt;code&gt;bar&lt;/code&gt; 와 일치한다고보고합니다 . 이 기능은 룩 어스 어설 션과 유사합니다. 그러나이 경우 실제 경기 전 주제의 길이는 고정 길이 일 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="a2eee29afcaa7cc2723b6a373311fdebfe21050f" translate="yes" xml:space="preserve">
          <source>The event can be an INSERT, and UPDATE or a DELETE. The trigger can be executed BEFORE or AFTER the event. Until &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1023-release-notes/&quot;&gt;MariaDB 10.2.3&lt;/a&gt;, a table could have only one trigger defined for each event/timing combination: for example, a table could only have one BEFORE INSERT trigger.</source>
          <target state="translated">이벤트는 INSERT, UPDATE 또는 DELETE 일 수 있습니다. 이벤트 전 또는 후에 트리거를 실행할 수 있습니다. &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1023-release-notes/&quot;&gt;MariaDB 10.2.3&lt;/a&gt; 까지 테이블에는 각 이벤트 / 타이밍 조합에 대해 정의 된 트리거가 하나만있을 수 있습니다. 예를 들어, 테이블에는 BEFORE INSERT 트리거가 하나만있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="558198626b6df51b68971c0e1bb5999c228cbafa" translate="yes" xml:space="preserve">
          <source>The event queue contains items, but the next activation is at some time in the future.</source>
          <target state="translated">이벤트 대기열에는 항목이 포함되어 있지만 다음 번에는 다음에 활성화 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="4a4c24e414f93866653dbb7276100e689ddf1943" translate="yes" xml:space="preserve">
          <source>The event that activates the trigger. One of &lt;code&gt;INSERT&lt;/code&gt;, &lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;'DELETE&lt;/code&gt;.</source>
          <target state="translated">트리거를 활성화하는 이벤트입니다. &lt;code&gt;INSERT&lt;/code&gt; , &lt;code&gt;UPDATE&lt;/code&gt; 또는 &lt;code&gt;'DELETE&lt;/code&gt; 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="9c3f59d3960c60dd9649957c79f238a37a3c8275" translate="yes" xml:space="preserve">
          <source>The event_name must be a valid MariaDB identifier with a maximum length of 64 characters. It may be delimited using back ticks, and may be qualified with the name of a database schema. An event is associated with both a MariaDB user (the definer) and a schema, and its name must be unique among names of events within that schema. In general, the rules governing event names are the same as those for names of stored routines. See &lt;a href=&quot;../identifier-names/index&quot;&gt;Identifier Names&lt;/a&gt;.</source>
          <target state="translated">event_name은 최대 64 자의 유효한 MariaDB 식별자 여야합니다. 백틱을 사용하여 구분할 수 있으며 데이터베이스 스키마 이름으로 규정 될 수 있습니다. 이벤트는 MariaDB 사용자 (정의 자) 및 스키마와 연관되며 해당 이름은 해당 스키마 내의 이벤트 이름 중에서 고유해야합니다. 일반적으로 이벤트 이름을 관리하는 규칙은 저장된 루틴의 이름과 동일합니다. &lt;a href=&quot;../identifier-names/index&quot;&gt;식별자 이름을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7b8edcc9ab892ec81737b314e48a08dd9c810c77" translate="yes" xml:space="preserve">
          <source>The events that can be compressed are the events that normally can be of a significant size: Query events (for DDL and DML in &lt;a href=&quot;../binary-log-formats/index#statement-based&quot;&gt;statement-based&lt;/a&gt;&lt;a href=&quot;../standard-replication/index&quot;&gt;replication&lt;/a&gt;), and row events (for DML in &lt;a href=&quot;../binary-log-formats/index#row-based&quot;&gt;row-based&lt;/a&gt;&lt;a href=&quot;../standard-replication/index&quot;&gt;replication&lt;/a&gt;).</source>
          <target state="translated">압축 할 수있는 이벤트는 일반적으로 크기가 &lt;a href=&quot;../binary-log-formats/index#statement-based&quot;&gt;클&lt;/a&gt; 수있는 이벤트입니다. 쿼리 이벤트 ( 문 기반 &lt;a href=&quot;../standard-replication/index&quot;&gt;복제의&lt;/a&gt; DDL 및 DML의 경우 ) 및 행 이벤트 ( &lt;a href=&quot;../binary-log-formats/index#row-based&quot;&gt;행 기반 &lt;/a&gt;&lt;a href=&quot;../standard-replication/index&quot;&gt;복제의&lt;/a&gt; DML의 경우 )입니다.</target>
        </trans-unit>
        <trans-unit id="ebbe5a235dfb526812b941cabbbc2cbf0801edad" translate="yes" xml:space="preserve">
          <source>The events_statements_current table, along with many other new &lt;a href=&quot;../list-of-performance-schema-tables/index&quot;&gt;Performance Schema tables&lt;/a&gt;, was added in &lt;a href=&quot;../what-is-mariadb-100/index&quot;&gt;MariaDB 10.0&lt;/a&gt;</source>
          <target state="translated">다른 많은 새로운 &lt;a href=&quot;../list-of-performance-schema-tables/index&quot;&gt;성능 스키마 테이블&lt;/a&gt; 과 함께 events_statements_current 테이블 이 &lt;a href=&quot;../what-is-mariadb-100/index&quot;&gt;MariaDB 10.0&lt;/a&gt; 에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="5d81b616754f0201e298ab1ad14b995ad16aec33" translate="yes" xml:space="preserve">
          <source>The exact meaning of the additional argument would depend on the specific authentication plugin.</source>
          <target state="translated">추가 인수의 정확한 의미는 특정 인증 플러그인에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="3b43558bd9adf9b58c9f7eb268670b641c81d6e5" translate="yes" xml:space="preserve">
          <source>The exact place depends on your system. The &lt;code&gt;mysql.server&lt;/code&gt; file contains instructions of how to use and fine tune it.</source>
          <target state="translated">정확한 위치는 시스템에 따라 다릅니다. &lt;code&gt;mysql.server&lt;/code&gt; 를의 파일을 사용하고 미세 조정을하는 방법에 대한 지침이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea897ead4dc74df5576d4ce805b71bf0ad6a6bc3" translate="yes" xml:space="preserve">
          <source>The example below uses &lt;code&gt;WITH&lt;/code&gt; in a subquery:</source>
          <target state="translated">아래 예제 는 하위 쿼리에서 &lt;code&gt;WITH&lt;/code&gt; 를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="bd8baa5682eb393a9cb3438b0e28e9b058a20a17" translate="yes" xml:space="preserve">
          <source>The example file above includes a &lt;code&gt;gpgkey&lt;/code&gt; line to automatically fetch the GPG public key that is used to verify the digital signatures of the packages in our repositories. This allows the the &lt;code&gt;yum&lt;/code&gt;, &lt;code&gt;dnf&lt;/code&gt;, and &lt;code&gt;rpm&lt;/code&gt; utilities to verify the integrity of the packages that they install.</source>
          <target state="translated">위의 예제 파일에는 저장소에있는 패키지의 디지털 서명을 확인하는 데 사용되는 GPG 공개 키를 자동으로 가져 오는 &lt;code&gt;gpgkey&lt;/code&gt; 행이 포함되어 있습니다. 이를 통해 &lt;code&gt;yum&lt;/code&gt; , &lt;code&gt;dnf&lt;/code&gt; 및 &lt;code&gt;rpm&lt;/code&gt; 유틸리티는 설치 한 패키지의 무결성을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23634536b9f742bcceaaa2d7b8fdf23f32596ca3" translate="yes" xml:space="preserve">
          <source>The example of declaring the attributes and comparing the values for the &lt;code&gt;ALTER TABLE&lt;/code&gt; can be found in the EXAMPLE engine.</source>
          <target state="translated">속성 선언 및 &lt;code&gt;ALTER TABLE&lt;/code&gt; 값 비교 의 예는 EXAMPLE 엔진에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2b708bf75ae085865dd0f0e01ecab317c3b4375" translate="yes" xml:space="preserve">
          <source>The examples are all based on the following simplified sales opportunity table:</source>
          <target state="translated">예제는 모두 다음과 같은 단순화 된 영업 기회 테이블을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="96867199f347c84bb0db389a2fa42175874732f5" translate="yes" xml:space="preserve">
          <source>The examples are: &lt;code&gt;latin1_general_ci&lt;/code&gt;, &lt;code&gt;latin1_general_cs&lt;/code&gt;, &lt;code&gt;latin1_swedish_ci&lt;/code&gt;, etc.</source>
          <target state="translated">예는 &lt;code&gt;latin1_general_ci&lt;/code&gt; , &lt;code&gt;latin1_general_cs&lt;/code&gt; , &lt;code&gt;latin1_swedish_ci&lt;/code&gt; 등입니다.</target>
        </trans-unit>
        <trans-unit id="2edc930298c8218a94e99d58e6bd6f358491b009" translate="yes" xml:space="preserve">
          <source>The examples below use the &lt;a href=&quot;../hex/index&quot;&gt;HEX()&lt;/a&gt; function to represent non-printable results in hexadecimal format.</source>
          <target state="translated">아래 예는 &lt;a href=&quot;../hex/index&quot;&gt;HEX ()&lt;/a&gt; 함수를 사용하여 인쇄 할 수없는 결과를 16 진수 형식으로 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a678c6035fd3ffa2d0f58962c262e1dc7a6cb216" translate="yes" xml:space="preserve">
          <source>The examples in this document assume a root install with the packages installed in /usr/local. For non-root system, just substitute /usr/local with $HOME, which is the non-root user home directory.</source>
          <target state="translated">이 문서의 예제는 / ​​usr / local에 패키지가 설치된 루트 설치를 가정합니다. 루트가 아닌 시스템의 경우, 루트가 아닌 사용자 홈 디렉토리 인 $ HOME으로 / usr / local을 대체하십시오.</target>
        </trans-unit>
        <trans-unit id="8ee87432424524684058d5dadb33cf2e448aaa95" translate="yes" xml:space="preserve">
          <source>The examples we have seen so far are files that, even they can be formatted in different ways (blanks, tabs, carriage return and line feed are ignored when parsing them), respect the JSON syntax and are made of only one item (Object or Array). Like for XML files, they are entirely parsed and a memory representation is made used to process them. This implies that they are of reasonable size to avoid an out of memory condition. Tables based on such files are recognized by the option Pretty=2 that we did not specify above because this is the default.</source>
          <target state="translated">우리가 지금까지 본 예제는 심지어 다른 방식으로 포맷 할 수있는 파일입니다 (공백, 탭, 캐리지 리턴 및 줄 바꿈은 파싱 할 때 무시됩니다) .JSON 구문을 존중하고 하나의 항목 (Object 또는 정렬). XML 파일과 마찬가지로 파일이 완전히 파싱되고 메모리 표현이 처리에 사용됩니다. 이는 메모리 부족 상태를 피하기 위해 크기가 적당하다는 것을 의미합니다. 이러한 파일을 기반으로하는 테이블은 기본값이기 때문에 위에서 지정하지 않은 Pretty = 2 옵션으로 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="a9342a2251ea4fdbb442582a7889a2f22e830675" translate="yes" xml:space="preserve">
          <source>The execution continued after the command in error because of the MAXERR option. Normally this would have stopped the execution.</source>
          <target state="translated">MAXERR 옵션으로 인해 명령이 오류 후에 계속 실행되었습니다. 일반적으로 이것은 실행을 중지했을 것입니다.</target>
        </trans-unit>
        <trans-unit id="4c32a714e1e22ebc430ba5a6a00c2ed733b8a85b" translate="yes" xml:space="preserve">
          <source>The existence of UDFs are checked during the lexical analysis (in sql_lex.cc:find_keyword()). This has the drawback that they must exist before they are referred to, which was ok before SPs existed, but then it becomes a problem. The first implementation of SP FUNCTIONs will work the same way, but this should be fixed a.s.a.p. (This will required some reworking of the way UDFs are handled, which is why it's not done from the start.) For the time being, a FUNCTION is detected the same way, and returns the token SP_FUNC. During the parsing we only check for the *existence* of the function, we don't parse it, since wa can't call the parser recursively.</source>
          <target state="translated">어휘 분석 중에 UDF가 있는지 확인합니다 (sql_lex.cc:find_keyword ()). 이것은 SP가 존재하기 전에는 문제가되었지만 참조하기 전에 반드시 존재해야한다는 단점이 있습니다. SP FUNCTION의 첫 번째 구현은 같은 방식으로 작동하지만 최대한 빨리 수정해야합니다 (이는 UDF가 처리되는 방식을 일부 재 작업해야하므로 처음부터 완료되지 않은 이유입니다). 같은 방식으로 감지하고 토큰 SP_FUNC를 반환합니다. 구문 분석 중에는 함수의 * 존재 여부 만 확인합니다. wa는 구문 분석기를 재귀 적으로 호출 할 수 없기 때문에 구문 분석하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="df5363742dc5e755f531af8a91ac52b3e7deb616" translate="yes" xml:space="preserve">
          <source>The expression to get a random integer from a given range is the following:</source>
          <target state="translated">주어진 범위에서 임의의 정수를 얻는 표현식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5ea20c2f8d56178e0270839c2b2e3c7d7791e4e9" translate="yes" xml:space="preserve">
          <source>The expression used for computing the column value in a &lt;a href=&quot;../virtual-computed-columns/index&quot;&gt;generated (virtual, or computed)&lt;/a&gt; column.</source>
          <target state="translated">&lt;a href=&quot;../virtual-computed-columns/index&quot;&gt;생성 된 (가상 또는 계산 된)&lt;/a&gt; 열 에서 열 값을 계산하는 데 사용되는 표현식 입니다.</target>
        </trans-unit>
        <trans-unit id="ca121de33d95373e7c06e3c4b37928881ea594fb" translate="yes" xml:space="preserve">
          <source>The external datatype for an 'address' should be whatever is convenient for the application.</source>
          <target state="translated">'주소'의 외부 데이터 유형은 응용 프로그램에 편리한 것이어야합니다.</target>
        </trans-unit>
        <trans-unit id="66fadbc5d9c9f3615eadd90f79e829b1f706a9b6" translate="yes" xml:space="preserve">
          <source>The external filesystems will need to be owned by the new user. This is an example command run as root setting the owner and group of dbroot /dev/sda1 to the mysql user:</source>
          <target state="translated">외부 파일 시스템은 새로운 사용자가 소유해야합니다. dbroot / dev / sda1의 소유자와 그룹을 mysql 사용자로 설정하여 루트로 실행되는 명령 예입니다.</target>
        </trans-unit>
        <trans-unit id="54b4160080351fa4af6452e5b58cbdf568bddf60" translate="yes" xml:space="preserve">
          <source>The external table &lt;a href=&quot;../connect-table-types-overview/index&quot;&gt;type&lt;/a&gt;: &lt;a href=&quot;../connect-dos-and-fix-table-types/index&quot;&gt;DOS&lt;/a&gt;, &lt;a href=&quot;../connect-dos-and-fix-table-types/index&quot;&gt;FIX&lt;/a&gt;, &lt;a href=&quot;../connect-bin-table-type/index&quot;&gt;BIN&lt;/a&gt;, &lt;a href=&quot;../connect-csv-and-fmt-table-types/index&quot;&gt;CSV&lt;/a&gt;, &lt;a href=&quot;../connect-csv-and-fmt-table-types/index&quot;&gt;FMT&lt;/a&gt;, &lt;a href=&quot;../connect-xml-table-type/index&quot;&gt;XML&lt;/a&gt;, &lt;a href=&quot;../connect-json-table-type/index&quot;&gt;JSON&lt;/a&gt;, &lt;a href=&quot;../connect-ini-table-type/index&quot;&gt;INI&lt;/a&gt;, &lt;a href=&quot;../connect-dbf-table-type/index&quot;&gt;DBF&lt;/a&gt;, &lt;a href=&quot;../connect-vec-table-type/index&quot;&gt;VEC&lt;/a&gt;, &lt;a href=&quot;../connect-table-types-odbc-table-type-accessing-tables-from-other-dbms/index&quot;&gt;ODBC&lt;/a&gt;, &lt;a href=&quot;../connect-jdbc-table-type-accessing-tables-from-other-dbms/index&quot;&gt;JDBC&lt;/a&gt;, &lt;a href=&quot;../connect-table-types-mysql-table-type-accessing-mysqlmariadb-tables/index&quot;&gt;MYSQL&lt;/a&gt;, &lt;a href=&quot;../connect-table-types-tbl-table-type-table-list/index&quot;&gt;TBL&lt;/a&gt;, &lt;a href=&quot;../connect-table-types-proxy-table-type/index&quot;&gt;PROXY&lt;/a&gt;, &lt;a href=&quot;../connect-table-types-xcol-table-type/index&quot;&gt;XCOL&lt;/a&gt;, &lt;a href=&quot;../connect-table-types-occur-table-type/index&quot;&gt;OCCUR&lt;/a&gt;, &lt;a href=&quot;../connect-table-types-pivot-table-type/index&quot;&gt;PIVOT&lt;/a&gt;, &lt;a href=&quot;../connect-zipped-file-tables/index&quot;&gt;ZIP&lt;/a&gt;, &lt;a href=&quot;../connect-table-types-vir/index&quot;&gt;VIR&lt;/a&gt;, &lt;a href=&quot;../connect-table-types-special-virtual-tables/index#dir-type&quot;&gt;DIR&lt;/a&gt;, &lt;a href=&quot;../connect-table-types-special-virtual-tables/index#windows-management-instrumentation-table-type-wmi&quot;&gt;WMI&lt;/a&gt;, &lt;a href=&quot;../connect-table-types-special-virtual-tables/index#mac-address-table-type-mac&quot;&gt;MAC&lt;/a&gt;, and &lt;a href=&quot;../connect-table-types-oem/index&quot;&gt;OEM&lt;/a&gt;. Defaults to &lt;a href=&quot;../connect-dos-and-fix-table-types/index&quot;&gt;DOS&lt;/a&gt;, &lt;a href=&quot;../connect-table-types-mysql-table-type-accessing-mysqlmariadb-tables/index&quot;&gt;MYSQL&lt;/a&gt;, or &lt;a href=&quot;../connect-table-types-proxy-table-type/index&quot;&gt;PROXY&lt;/a&gt; depending on what options are used.</source>
          <target state="translated">외부 테이블 &lt;a href=&quot;../connect-table-types-overview/index&quot;&gt;유형&lt;/a&gt; : &lt;a href=&quot;../connect-dos-and-fix-table-types/index&quot;&gt;DOS&lt;/a&gt; , &lt;a href=&quot;../connect-dos-and-fix-table-types/index&quot;&gt;FIX&lt;/a&gt; , &lt;a href=&quot;../connect-bin-table-type/index&quot;&gt;BIN&lt;/a&gt; , &lt;a href=&quot;../connect-csv-and-fmt-table-types/index&quot;&gt;CSV&lt;/a&gt; , &lt;a href=&quot;../connect-csv-and-fmt-table-types/index&quot;&gt;FMT&lt;/a&gt; , &lt;a href=&quot;../connect-xml-table-type/index&quot;&gt;XML&lt;/a&gt; , &lt;a href=&quot;../connect-json-table-type/index&quot;&gt;JSON&lt;/a&gt; , &lt;a href=&quot;../connect-ini-table-type/index&quot;&gt;INI&lt;/a&gt; , &lt;a href=&quot;../connect-dbf-table-type/index&quot;&gt;DBF&lt;/a&gt; , &lt;a href=&quot;../connect-vec-table-type/index&quot;&gt;VEC&lt;/a&gt; , &lt;a href=&quot;../connect-table-types-odbc-table-type-accessing-tables-from-other-dbms/index&quot;&gt;ODBC&lt;/a&gt; , &lt;a href=&quot;../connect-jdbc-table-type-accessing-tables-from-other-dbms/index&quot;&gt;JDBC&lt;/a&gt; , &lt;a href=&quot;../connect-table-types-mysql-table-type-accessing-mysqlmariadb-tables/index&quot;&gt;MYSQL&lt;/a&gt; , &lt;a href=&quot;../connect-table-types-tbl-table-type-table-list/index&quot;&gt;TBL&lt;/a&gt; , &lt;a href=&quot;../connect-table-types-proxy-table-type/index&quot;&gt;PROXY&lt;/a&gt; , &lt;a href=&quot;../connect-table-types-xcol-table-type/index&quot;&gt;XCOL&lt;/a&gt; , &lt;a href=&quot;../connect-table-types-occur-table-type/index&quot;&gt;OCCUR&lt;/a&gt; , &lt;a href=&quot;../connect-table-types-pivot-table-type/index&quot;&gt;PIVOT&lt;/a&gt; , &lt;a href=&quot;../connect-zipped-file-tables/index&quot;&gt;ZIP&lt;/a&gt; , &lt;a href=&quot;../connect-table-types-vir/index&quot;&gt;VIR&lt;/a&gt; , &lt;a href=&quot;../connect-table-types-special-virtual-tables/index#dir-type&quot;&gt;DIR&lt;/a&gt; , &lt;a href=&quot;../connect-table-types-special-virtual-tables/index#windows-management-instrumentation-table-type-wmi&quot;&gt;WMI&lt;/a&gt; , &lt;a href=&quot;../connect-table-types-special-virtual-tables/index#mac-address-table-type-mac&quot;&gt;MAC&lt;/a&gt; 및 &lt;a href=&quot;../connect-table-types-oem/index&quot;&gt;OEM&lt;/a&gt; . 기본적으로 &lt;a href=&quot;../connect-dos-and-fix-table-types/index&quot;&gt;DOS&lt;/a&gt;사용되는 옵션에 따라 , &lt;a href=&quot;../connect-table-types-mysql-table-type-accessing-mysqlmariadb-tables/index&quot;&gt;MYSQL&lt;/a&gt; 또는 &lt;a href=&quot;../connect-table-types-proxy-table-type/index&quot;&gt;PROXY&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3c677ed2881d84479cf361f08be998f4320586b3" translate="yes" xml:space="preserve">
          <source>The facility is enabled by default in the test suite, but can be disabled with:</source>
          <target state="translated">기능은 테스트 스위트에서 기본적으로 사용 가능하지만 다음을 사용하여 사용 불가능하게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="589ef6c1e08ac1e167ee3446ef022aa73020934d" translate="yes" xml:space="preserve">
          <source>The fact that a &lt;code&gt;UNIQUE&lt;/code&gt; constraint can be &lt;code&gt;NULL&lt;/code&gt; is often overlooked. In SQL any &lt;code&gt;NULL&lt;/code&gt; is never equal to anything, not even to another &lt;code&gt;NULL&lt;/code&gt;. Consequently, a &lt;code&gt;UNIQUE&lt;/code&gt; constraint will not prevent one from storing duplicate rows if they contain null values:</source>
          <target state="translated">&lt;code&gt;UNIQUE&lt;/code&gt; 제약 조건이 &lt;code&gt;NULL&lt;/code&gt; 일 수 있다는 사실 은 종종 간과됩니다. SQL에서 &lt;code&gt;NULL&lt;/code&gt; 은 다른 &lt;code&gt;NULL&lt;/code&gt; 과 전혀 같지 않습니다 . 결과적으로 &lt;code&gt;UNIQUE&lt;/code&gt; 제약 조건은 null 값을 포함하는 경우 중복 행을 저장하지 못하게합니다.</target>
        </trans-unit>
        <trans-unit id="2eef4da6accff97b368e59550104d0a4c9f81394" translate="yes" xml:space="preserve">
          <source>The failure threshold can be configured by setting the &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_compression_failure_threshold_pct&quot;&gt;innodb_compression_failure_threshold_pct&lt;/a&gt;&lt;/code&gt; system variable.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_compression_failure_threshold_pct&quot;&gt;innodb_compression_failure_threshold_pct&lt;/a&gt;&lt;/code&gt; 시스템 변수를 설정하여 실패 임계 값을 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8f9bee6279232e43e273473a0f39e0510485af33" translate="yes" xml:space="preserve">
          <source>The feature was based upon a patch by Davi Arnaut.</source>
          <target state="translated">이 기능은 Davi Arnaut의 패치를 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="e322340601321360ca0a052e0c7795f1e2cc4a5d" translate="yes" xml:space="preserve">
          <source>The feature was originally implemented as a Google Summer of Code 2009 project by Joseph Lukas.</source>
          <target state="translated">이 기능은 원래 Joseph Lukas가 Google Summer of Code 2009 프로젝트로 구현 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="61944e217dd5291c60d51ac602bf5202c3dceaa1" translate="yes" xml:space="preserve">
          <source>The features in MariaDB 10.0</source>
          <target state="translated">MariaDB 10.0의 기능</target>
        </trans-unit>
        <trans-unit id="44860408f24789724b02921e5c55dc46ea91e3ee" translate="yes" xml:space="preserve">
          <source>The features in MariaDB 10.1</source>
          <target state="translated">MariaDB 10.1의 기능</target>
        </trans-unit>
        <trans-unit id="dde7fe4a6117e6ac4d6828d6188398d2cdd9fd65" translate="yes" xml:space="preserve">
          <source>The features in MariaDB 10.2</source>
          <target state="translated">MariaDB 10.2의 기능</target>
        </trans-unit>
        <trans-unit id="219f8cd79f7d627c93215423418102e25a3bddcb" translate="yes" xml:space="preserve">
          <source>The features in MariaDB 10.3</source>
          <target state="translated">MariaDB 10.3의 기능</target>
        </trans-unit>
        <trans-unit id="9e21c019fc3af72e1c60cc74cebbdd0ca8adf0e7" translate="yes" xml:space="preserve">
          <source>The features in MariaDB 10.4</source>
          <target state="translated">MariaDB 10.4의 기능</target>
        </trans-unit>
        <trans-unit id="6d3a4f0f594df04b7549036f087146a6b8c8c2a7" translate="yes" xml:space="preserve">
          <source>The features in MariaDB 10.5</source>
          <target state="translated">MariaDB 10.5의 기능</target>
        </trans-unit>
        <trans-unit id="b31c10ee9453af64994d8425af2b9377afa14c5f" translate="yes" xml:space="preserve">
          <source>The features in MariaDB 5.5</source>
          <target state="translated">MariaDB 5.5의 기능</target>
        </trans-unit>
        <trans-unit id="4515dc71608a7e1e9220b7dc040a215c7146f95e" translate="yes" xml:space="preserve">
          <source>The fetch size determines the number of rows that are internally retrieved by the driver on each interaction with the DBMS. Its default value depends on the JDBC driver. It is equal to 10 for some drivers but not for the MySQL or MariaDB connectors.</source>
          <target state="translated">페치 크기는 DBMS와의 각 상호 작용에서 드라이버가 내부적으로 검색하는 행 수를 결정합니다. 기본값은 JDBC 드라이버에 따라 다릅니다. 일부 드라이버의 경우 10이지만 MySQL 또는 MariaDB 커넥터의 경우는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="d8872fc929e00ef53a42875f797f6b419047504c" translate="yes" xml:space="preserve">
          <source>The field has leading zeros</source>
          <target state="translated">이 필드에는 선행 0이 있습니다</target>
        </trans-unit>
        <trans-unit id="009ac1dbc2ceeaa78401c4fbf883d96cbfd5e598" translate="yes" xml:space="preserve">
          <source>The field is a BINARY(10), so padding of two '\0's are inserted, causing comparisons that don't take this into account to fail:</source>
          <target state="translated">이 필드는 BINARY (10)이므로 두 '\ 0'의 패딩이 삽입되어이를 고려하지 않은 비교가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="8bb0af8b0b70580762453dacbfda86fa54d92682" translate="yes" xml:space="preserve">
          <source>The field length in characters</source>
          <target state="translated">문자로 된 필드 길이</target>
        </trans-unit>
        <trans-unit id="b826b4ecda8af0ac33d89467f3d2929c22fd709a" translate="yes" xml:space="preserve">
          <source>The field length option if the date representation is different than the standard type size.</source>
          <target state="translated">날짜 표현이 표준 유형 크기와 다른 경우 필드 길이 옵션입니다.</target>
        </trans-unit>
        <trans-unit id="d4d5755634351662b3ede19ebe40db54238eed56" translate="yes" xml:space="preserve">
          <source>The field offsets and the file record length are calculated according the column internal format and eventually modified by the field format. It is not necessary to specify them for a packed binary file without line endings. If a line ending is desired, specify the ending option or specify the &lt;code&gt;lrecl&lt;/code&gt; option adding the ending width. The table can be filled by:</source>
          <target state="translated">필드 오프셋 및 파일 레코드 길이는 열 내부 형식에 따라 계산되고 결국 필드 형식으로 수정됩니다. 줄 끝없이 압축 이진 파일에 대해서는 지정할 필요가 없습니다. 줄 끝이 필요한 경우 끝 옵션을 지정하거나 끝 너비를 추가하여 &lt;code&gt;lrecl&lt;/code&gt; 옵션을 지정하십시오 . 테이블은 다음과 같이 채워질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="27cd2e3364d99d44c7e0ee081c26fe2c01aa016a" translate="yes" xml:space="preserve">
          <source>The field recognition format used to delimit the date in the input record.</source>
          <target state="translated">입력 레코드에서 날짜를 구분하는 데 사용되는 필드 인식 형식입니다.</target>
        </trans-unit>
        <trans-unit id="b67e1a5ae3c744c187a6a9bc50ed92cf96284710" translate="yes" xml:space="preserve">
          <source>The field width in the file is 3 characters. This is the value used to calculate the offset of the next field if it is not specified. If this length is not specified, it defaults to the MySQL default type length.</source>
          <target state="translated">파일의 필드 너비는 3 자입니다. 지정되지 않은 경우 다음 필드의 오프셋을 계산하는 데 사용되는 값입니다. 이 길이를 지정하지 않으면 기본값은 MySQL 기본 유형 길이입니다.</target>
        </trans-unit>
        <trans-unit id="e2cc62600d0f2e9d18651abaabb13c4fd935b543" translate="yes" xml:space="preserve">
          <source>The field width in the file is 4 characters, the size of a binary integer. This is the value used to calculate the offset of the next field if it is not specified. Therefore, if the next field is placed 5 characters after this one, this declaration is not enough, and the flag option will have to be used on the next field.</source>
          <target state="translated">파일의 필드 너비는 2 진 정수의 크기 인 4 자입니다. 지정되지 않은 경우 다음 필드의 오프셋을 계산하는 데 사용되는 값입니다. 따라서 다음 필드가이 필드 다음에 5자를 놓으면이 선언으로는 충분하지 않으며 다음 필드에서 플래그 옵션을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="401622311d22225c029e921915f26dde361f053b" translate="yes" xml:space="preserve">
          <source>The field_format options we used above can be specified to locate more precisely where and what information to retrieve using an Xpath-like syntax. For instance:</source>
          <target state="translated">위에서 사용한 field_format 옵션은 Xpath와 같은 구문을 사용하여 검색 할 정보를보다 정확하게 찾을 수 있도록 지정할 수 있습니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="ef137b766ca030c1160317f9d0cdd0e9fe710a7d" translate="yes" xml:space="preserve">
          <source>The fields between quotes are read and the quotes discarded. On writing, fields will be quoted only if they contain the separator character or begin with the quoting character. If they contain the quoting character, it will be doubled.</source>
          <target state="translated">따옴표 사이의 필드를 읽고 따옴표를 버립니다. 글을 쓸 때 필드는 구분 문자를 포함하거나 인용 문자로 시작하는 경우에만 인용됩니다. 인용 문자가 포함되어 있으면 두 배가됩니다.</target>
        </trans-unit>
        <trans-unit id="1b83b1a851b4a3fae4d68cfca190b320665cd815" translate="yes" xml:space="preserve">
          <source>The fifth number is an IEEE 802 node number that provides spatial uniqueness. A random number is substituted if the latter is not available (for example, because the host computer has no Ethernet card, or we do not know how to find the hardware address of an interface on your operating system). In this case, spatial uniqueness cannot be guaranteed. Nevertheless, a collision should have very low probability.</source>
          <target state="translated">다섯 번째 숫자는 공간 고유성을 제공하는 IEEE 802 노드 번호입니다. 예를 들어 호스트 컴퓨터에 이더넷 카드가 없거나 운영 체제에서 인터페이스의 하드웨어 주소를 찾는 방법을 모르기 때문에 임의의 숫자가 후자를 대체합니다. 이 경우 공간적 고유성을 보장 할 수 없습니다. 그럼에도 불구하고 충돌 가능성은 매우 낮습니다.</target>
        </trans-unit>
        <trans-unit id="137bee97c60d82fad7dbb1adb89ee2b3365348a9" translate="yes" xml:space="preserve">
          <source>The file '%s' must be in the database directory or be readable by all</source>
          <target state="translated">'% s'파일은 데이터베이스 디렉토리에 있거나 모두 읽을 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="2a025c7a450f0cb1b6cce001d08fe4b310d7b38a" translate="yes" xml:space="preserve">
          <source>The file (path) base name for table index files. Can be absolute or relative to the data directory. Defaults to the file name.</source>
          <target state="translated">테이블 인덱스 파일의 파일 (경로) 기본 이름입니다. 데이터 디렉토리에 대해 절대적이거나 상대적 일 수 있습니다. 파일 이름이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="064408389f4f0bb8e4e21f1917c5df17ee591639" translate="yes" xml:space="preserve">
          <source>The file (path) name for all table types based on files. Can be absolute or relative to the current data directory. If not specified, this is an &lt;a href=&quot;../inward-and-outward-tables/index#inward-tables&quot;&gt;Inward table&lt;/a&gt; and a default value is used.</source>
          <target state="translated">파일을 기반으로하는 모든 테이블 유형의 파일 (경로) 이름입니다. 현재 데이터 디렉토리에 대해 절대적이거나 상대적 일 수 있습니다. 지정하지 않으면이 &lt;a href=&quot;../inward-and-outward-tables/index#inward-tables&quot;&gt;테이블&lt;/a&gt; 이 안쪽 테이블 이며 기본값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="12dc4052e13fee7136305ccb640c8813feab29e4" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;mongo.def&lt;/code&gt;: (required only on Windows)</source>
          <target state="translated">&lt;code&gt;mongo.def&lt;/code&gt; 파일 : (Windows에서만 필요)</target>
        </trans-unit>
        <trans-unit id="bc5ad08e2430f008a4646ff856a63bc4ba80a805" translate="yes" xml:space="preserve">
          <source>The file &lt;em&gt;path/name&lt;/em&gt; is given by the &lt;code&gt;FILE_NAME&lt;/code&gt; option. If it is a relative path/name, it will be relative to the database directory, the one containing the table &lt;code&gt;.FRM&lt;/code&gt; file.</source>
          <target state="translated">파일 &lt;em&gt;경로 / 이름&lt;/em&gt; 은 &lt;code&gt;FILE_NAME&lt;/code&gt; 옵션으로 제공됩니다. 상대 경로 / 이름 인 경우 테이블 &lt;code&gt;.FRM&lt;/code&gt; 파일을 포함하는 데이터베이스 디렉토리를 기준으로 합니다.</target>
        </trans-unit>
        <trans-unit id="cbeb90df66e552b9478774ce1d9dce51e6608839" translate="yes" xml:space="preserve">
          <source>The file attribute</source>
          <target state="translated">파일 속성</target>
        </trans-unit>
        <trans-unit id="ff0eccfbc58c35e2bff09cf605645acf8ed63e97" translate="yes" xml:space="preserve">
          <source>The file contains test names and a comment (that should explain why the test was disabled), separated by a colon. Lines that start with a hash sign (&lt;code&gt;#&lt;/code&gt;) are ignored. A typical &lt;code&gt;disabled.def&lt;/code&gt; may look like this (note that a hash sign in the middle of a line does not start a comment):</source>
          <target state="translated">파일에는 테스트 이름과 주석 (테스트가 비활성화 된 이유를 설명해야 함)이 콜론으로 구분되어 있습니다. 해시 기호 ( &lt;code&gt;#&lt;/code&gt; )로 시작하는 줄 은 무시됩니다. 일반적인 &lt;code&gt;disabled.def&lt;/code&gt; 는 다음과 같습니다 (행 중간의 해시 기호는 주석을 시작하지 않습니다).</target>
        </trans-unit>
        <trans-unit id="fa6f156f3c3e34db14335bffb1b11a38ea063275" translate="yes" xml:space="preserve">
          <source>The file contains the values of the &lt;code&gt;&lt;a href=&quot;../galera-cluster-status-variables/index#wsrep_local_state_uuid&quot;&gt;wsrep_local_state_uuid&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../galera-cluster-status-variables/index#wsrep_last_committed&quot;&gt;wsrep_last_committed&lt;/a&gt;&lt;/code&gt; status variables.</source>
          <target state="translated">파일에는 &lt;code&gt;&lt;a href=&quot;../galera-cluster-status-variables/index#wsrep_local_state_uuid&quot;&gt;wsrep_local_state_uuid&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../galera-cluster-status-variables/index#wsrep_last_committed&quot;&gt;wsrep_last_committed&lt;/a&gt;&lt;/code&gt; 상태 변수 의 값이 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="58ce1d05816fcc3fbc14a80b83bb1c1c9fbfc4bd" translate="yes" xml:space="preserve">
          <source>The file creation date</source>
          <target state="translated">파일 작성일</target>
        </trans-unit>
        <trans-unit id="d8dc7111478f23cc21118f8062f02a2ac8f61534" translate="yes" xml:space="preserve">
          <source>The file must not exist. It cannot be overwritten. A user needs the &lt;a href=&quot;../grant/index#global-privileges&quot;&gt;FILE&lt;/a&gt; privilege to run this statement. Also, MariaDB needs permission to write files in the specified location. If the &lt;a href=&quot;../server-system-variables/index#secure_file_priv&quot;&gt;secure_file_priv&lt;/a&gt; system variable is set to a non-empty directory name, the file can only be written to that directory.</source>
          <target state="translated">파일이 존재하지 않아야합니다. 덮어 쓸 수 없습니다. 이 명령문을 실행 하려면 사용자에게 &lt;a href=&quot;../grant/index#global-privileges&quot;&gt;FILE&lt;/a&gt; 권한이 필요합니다 . 또한 MariaDB는 지정된 위치에 파일을 쓸 수있는 권한이 필요합니다. 는 IF &lt;a href=&quot;../server-system-variables/index#secure_file_priv&quot;&gt;secure_file_priv&lt;/a&gt; 시스템 변수가 비어 있지 않은 디렉토리 이름으로 설정, 파일은 해당 디렉토리에 기록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d4dc29e8759446c4abe35a55f487df1ada678ee" translate="yes" xml:space="preserve">
          <source>The file name</source>
          <target state="translated">파일 이름</target>
        </trans-unit>
        <trans-unit id="90158e30360c44476b260728050247847eec1638" translate="yes" xml:space="preserve">
          <source>The file name is optional when the json document comes from a Jbin_File function because the returned structure makes it available. For instance, to convert back the json file tb.json to pretty= 0, this can be simply done by:</source>
          <target state="translated">리턴 된 구조가 사용 가능하므로 json 문서가 Jbin_File 함수에서 제공 될 때 파일 이름은 선택 사항입니다. 예를 들어, json 파일 tb.json을 pretty = 0으로 다시 변환하려면 다음을 수행하면됩니다.</target>
        </trans-unit>
        <trans-unit id="d5c8bb17148652caae0ac98dcd58d9ff327d6f5f" translate="yes" xml:space="preserve">
          <source>The file name is the .MAI index file. The extension can be omitted, although keeping it permits wildcards, such as</source>
          <target state="translated">파일 이름은 .MAI 인덱스 파일입니다. 확장명은 다음과 같은 와일드 카드를 허용하지만 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="01eba8a32a22892cf45a54b487124ea037f14a2e" translate="yes" xml:space="preserve">
          <source>The file names are generated from the partition names.</source>
          <target state="translated">파일 이름은 파티션 이름에서 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="80097d78e7fc0f449fae5ec012cfa79cf62a43d9" translate="yes" xml:space="preserve">
          <source>The file names of dropped tables can also be read from &lt;code&gt;ddl.log&lt;/code&gt;.</source>
          <target state="translated">삭제 된 테이블의 파일 이름은 &lt;code&gt;ddl.log&lt;/code&gt; 에서도 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="216e28f4324641fb3cdccfbb12b7055cee9cd53d" translate="yes" xml:space="preserve">
          <source>The file names of newly created tables can be read from &lt;code&gt;ddl.log&lt;/code&gt;.</source>
          <target state="translated">새로 작성된 테이블의 파일 이름은 &lt;code&gt;ddl.log&lt;/code&gt; 에서 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3dfee6711855b6ddc5dbd39bf0264b8f9f5a2ab9" translate="yes" xml:space="preserve">
          <source>The file names of renamed tables can also be read from &lt;code&gt;ddl.log&lt;/code&gt;, so the files can be renamed instead of re-copying them.</source>
          <target state="translated">이름이 바뀐 테이블의 파일 이름은 &lt;code&gt;ddl.log&lt;/code&gt; 에서도 읽을 수 있으므로 파일을 다시 복사하지 않고 이름을 바꿀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="863d7e4121b5d75c65b19b76759c4ad014ad19ae" translate="yes" xml:space="preserve">
          <source>The file path</source>
          <target state="translated">파일 경로</target>
        </trans-unit>
        <trans-unit id="2dd72c7a3a16d78c61d1a1d5271c52e7b3f0f02d" translate="yes" xml:space="preserve">
          <source>The file record size (often calculated by default).</source>
          <target state="translated">파일 레코드 크기 (종종 기본적으로 계산 됨)</target>
        </trans-unit>
        <trans-unit id="d01baf4bf974a152198fed8f2a84f510af8bfeea" translate="yes" xml:space="preserve">
          <source>The file size</source>
          <target state="translated">파일 크기</target>
        </trans-unit>
        <trans-unit id="e716e25da0c13c73e2332018aa0977c0e578d0db" translate="yes" xml:space="preserve">
          <source>The file tabfic.def: (required only on Windows)</source>
          <target state="translated">tabfic.def 파일 : (Windows에서만 필요)</target>
        </trans-unit>
        <trans-unit id="1877a25032a3c97f901299de7fe2d862abd8a733" translate="yes" xml:space="preserve">
          <source>The file type</source>
          <target state="translated">파일 타입</target>
        </trans-unit>
        <trans-unit id="cb99b39efb1ddf00a9246eb33020578bbf67cb89" translate="yes" xml:space="preserve">
          <source>The file type is JSON by default. If not, it must be specified like this:</source>
          <target state="translated">파일 형식은 기본적으로 JSON입니다. 그렇지 않은 경우 다음과 같이 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="e3ad5b91b3081fd9b1384f38b41b8f3703fe231b" translate="yes" xml:space="preserve">
          <source>The file which contains the buffer pool dump is specified via the &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_buffer_pool_filename&quot;&gt;innodb_buffer_pool_filename&lt;/a&gt; system variable.</source>
          <target state="translated">버퍼 풀 덤프를 포함하는 파일은 &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_buffer_pool_filename&quot;&gt;innodb_buffer_pool_filename&lt;/a&gt; 시스템 변수 를 통해 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="58e9e3692b290399283ef69cd7ae8b581def0d87" translate="yes" xml:space="preserve">
          <source>The filenames will be in the form `&amp;lt;processName&amp;gt;.&amp;lt;processID&amp;gt;.log`. These are similar to the crash traces that can be found in the MariaDB server log files if MariaDB server crashes.</source>
          <target state="translated">파일 이름은`&amp;lt;processName&amp;gt;. &amp;lt;processID&amp;gt; .log` 형식입니다. 이는 MariaDB 서버가 충돌하는 경우 MariaDB 서버 로그 파일에서 찾을 수있는 충돌 추적과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="937a5abf71c5ac243cb532da6a5b7917577c2b0e" translate="yes" xml:space="preserve">
          <source>The files are not point-in-time consistent as data may change during copy.</source>
          <target state="translated">복사하는 동안 데이터가 변경 될 수 있으므로 파일이 특정 시점과 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="465c52ccec1dc2a40893f734fab7fe3fadebbe33" translate="yes" xml:space="preserve">
          <source>The filesystem is not the most important aspect of MariaDB performance. Far more important are available RAM, drive speed, the system variable settings (see &lt;a href=&quot;../hardware-optimization/index&quot;&gt;Hardware Optimization&lt;/a&gt; and &lt;a href=&quot;../system-variables/index&quot;&gt;System Variables&lt;/a&gt;).</source>
          <target state="translated">파일 시스템은 MariaDB 성능의 가장 중요한 측면이 아닙니다. 사용 가능한 RAM, 드라이브 속도, 시스템 변수 설정이 훨씬 더 중요합니다 ( &lt;a href=&quot;../hardware-optimization/index&quot;&gt;하드웨어 최적화&lt;/a&gt; 및 &lt;a href=&quot;../system-variables/index&quot;&gt;시스템 변수 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="23c165c836a439824c0c7596fd601514711580ac" translate="yes" xml:space="preserve">
          <source>The filter data structure is currently an ordered array of rowids. (a Bloom filter would be better here and will probably be introduced in the future versions).</source>
          <target state="translated">필터 데이터 구조는 현재 정렬 된 rowid 배열입니다. (Bloom 필터가 여기에서 더 좋으며 향후 버전에서 도입 될 것입니다).</target>
        </trans-unit>
        <trans-unit id="84ab04def461b15abd063c9fbe040996b7933444" translate="yes" xml:space="preserve">
          <source>The first 9 rows, coming from the French table, have a null for the &lt;em&gt;sex&lt;/em&gt; value. They would have 0 if the sex column had been created NOT NULL.</source>
          <target state="translated">프랑스어 테이블에서 오는 처음 9 개의 행은 &lt;em&gt;섹스&lt;/em&gt; 값에 대해 널을 갖습니다. 섹스 컬럼이 NOT NULL로 작성된 경우 0이됩니다.</target>
        </trans-unit>
        <trans-unit id="15b1268a2cd0c620c5e51eee9e2426fa646b5cce" translate="yes" xml:space="preserve">
          <source>The first and most challenging one is to return as many rows than there are authors, the other columns being repeated as if we had make a join between the author column and the rest of the table. To achieve this, simply specify the &amp;ldquo;multiple&amp;rdquo; node name and the &amp;ldquo;expand&amp;rdquo; option when creating the table. For instance, we can create the &lt;em&gt;xsamp2&lt;/em&gt; table like this:</source>
          <target state="translated">가장 어려운 첫 번째 과제는 저자보다 많은 행을 반환하는 것입니다. 다른 열은 마치 저자 열과 나머지 테이블을 조인 한 것처럼 반복됩니다. 이를 위해서는 간단히 테이블을 만들 때 &quot;여러&quot;노드 이름과 &quot;확장&quot;옵션을 지정하십시오. 예를 들어 다음과 같이 &lt;em&gt;xsamp2&lt;/em&gt; 테이블을 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c35f10990f0b52a1d880369c676a247586e9bd00" translate="yes" xml:space="preserve">
          <source>The first argument must be a JSON array string. Then all other arguments are added as members of this array. For example:</source>
          <target state="translated">첫 번째 인수는 JSON 배열 문자열이어야합니다. 그런 다음 다른 모든 인수가이 배열의 멤버로 추가됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="13f6ef342f6c7e2f59f9dbb2b9ff7003fd7fea0d" translate="yes" xml:space="preserve">
          <source>The first argument must be a JSON item. The second argument is the item to be located. This function returns the paths to all locations of the item as an array of strings. For example:</source>
          <target state="translated">첫 번째 인수는 JSON 항목이어야합니다. 두 번째 인수는 찾을 항목입니다. 이 함수는 항목의 모든 위치에 대한 경로를 문자열 배열로 반환합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="99b012bda0ffa73775d78da94a49e1cab0817c19" translate="yes" xml:space="preserve">
          <source>The first argument must be a JSON object. The second argument is added as a pair to this object. For example:</source>
          <target state="translated">첫 번째 인수는 JSON 객체 여야합니다. 두 번째 인수는이 객체에 쌍으로 추가됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d81a398ad5fa9995617b923e1bccda1a8e0cd805" translate="yes" xml:space="preserve">
          <source>The first argument must be a JSON object. The second argument is the key of the pair to delete. For example:</source>
          <target state="translated">첫 번째 인수는 JSON 객체 여야합니다. 두 번째 인수는 삭제할 쌍의 키입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="887a1a4c7b4ecaef1ecc7619160cf435aa7ad907" translate="yes" xml:space="preserve">
          <source>The first argument must be a JSON object. This function returns an array containing the list of all keys existing in the object. For example:</source>
          <target state="translated">첫 번째 인수는 JSON 객체 여야합니다. 이 함수는 객체에 존재하는 모든 키 목록을 포함하는 배열을 반환합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="18e6c79fc21fecc0331e334048e3a7fa7375d765" translate="yes" xml:space="preserve">
          <source>The first argument must be a JSON tree. The second argument is the item to be located. The item to be located can be a constant or a json item. Constant values must be equal in type and value to be found. This is &quot;shallow equality&quot; &amp;ndash; strings, integers and doubles won't match.</source>
          <target state="translated">첫 번째 인수는 JSON 트리 여야합니다. 두 번째 인수는 찾을 항목입니다. 위치 할 항목은 상수 또는 json 항목 일 수 있습니다. 상수 값은 유형 및 값이 같아야합니다. 이것은 &quot;shallow equality&quot;입니다 &amp;ndash; 문자열, 정수 및 복식은 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5f53c9c621e12d52578bea54661412385dacd736" translate="yes" xml:space="preserve">
          <source>The first argument must be a file name. This function returns the text of the file that is supposed to be a json file. If only one argument is specified, the file text is returned without being parsed. Up to two additional arguments can be specified:</source>
          <target state="translated">첫 번째 인수는 파일 이름이어야합니다. 이 함수는 json 파일이어야하는 파일의 텍스트를 반환합니다. 인수가 하나만 지정된 경우 파일 텍스트가 구문 분석되지 않고 리턴됩니다. 최대 2 개의 추가 인수를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0b129880c1fefe4126a8b3bc930b29816b9b912" translate="yes" xml:space="preserve">
          <source>The first argument must be a json item (if it is just a string, Jfile_Make will try its best to see if it is a json item or an input file name). The following arguments are a string file name and an integer pretty value (defaulting to 2) in any order. This function creates a json file containing the first argument item.</source>
          <target state="translated">첫 번째 인수는 json 항목이어야합니다 (단지 문자열 인 경우 Jfile_Make는 json 항목인지 또는 입력 파일 이름인지 확인하기 위해 최선을 다할 것입니다). 다음 인수는 문자열 파일 이름과 정수의 예쁜 값 (기본값은 2)입니다. 이 함수는 첫 번째 인수 항목을 포함하는 json 파일을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="d6718e85c1f0e5458e806ab733bb19b9415522d9" translate="yes" xml:space="preserve">
          <source>The first argument should be a JSON array. The second argument is an integer indicating the rank (0 based conforming to general json usage) of the element to delete. For example:</source>
          <target state="translated">첫 번째 인수는 JSON 배열이어야합니다. 두 번째 인수는 삭제할 요소의 순위 (일반 json 사용법에 따라 0)를 나타내는 정수입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4b57d5af93e4a98561492e75a0ddcdca0bfca738" translate="yes" xml:space="preserve">
          <source>The first argument should be a JSON item. If it is a string with no alias, it will be converted as a json item. The second argument is the path of the item to be located in the first argument and returned, eventually converted according to the used function. For example:</source>
          <target state="translated">첫 번째 인수는 JSON 항목이어야합니다. 별명이없는 문자열 인 경우 json 항목으로 변환됩니다. 두 번째 인수는 첫 번째 인수에 있고 반환 된 항목의 경로이며, 결국 사용 된 함수에 따라 변환됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3273eede13c0b661a8844baa6967ca4b66016ce7" translate="yes" xml:space="preserve">
          <source>The first byte indicates the byte order. 00 for big endian, or 01 for little endian.</source>
          <target state="translated">첫 번째 바이트는 바이트 순서를 나타냅니다. 빅 엔디안의 경우 00, 리틀 엔디안의 경우 01</target>
        </trans-unit>
        <trans-unit id="e61a9f91c353a4a3f4110dd0099e7ec9d22b923d" translate="yes" xml:space="preserve">
          <source>The first character of all table and column names should be an ASCII letter (a-z A-Z).</source>
          <target state="translated">모든 테이블 및 열 이름의 첫 문자는 ASCII 문자 (az AZ) 여야합니다.</target>
        </trans-unit>
        <trans-unit id="9eac03392b750f64fb9d08d4dbb508be2259f982" translate="yes" xml:space="preserve">
          <source>The first example fails to match, as while the &lt;code&gt;Ma&lt;/code&gt; matches, either &lt;code&gt;i&lt;/code&gt; or &lt;code&gt;r&lt;/code&gt; only matches once before the &lt;code&gt;ia&lt;/code&gt; characters at the end.</source>
          <target state="translated">&lt;code&gt;Ma&lt;/code&gt; 가 일치 하는 동안 &lt;code&gt;i&lt;/code&gt; 또는 &lt;code&gt;r&lt;/code&gt; 은 마지막에 &lt;code&gt;ia&lt;/code&gt; 문자 앞에 한 번만 일치 하므로 첫 번째 예제는 일치하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="75625641a5df8a21125bead5f9391e5a3f2e2008" translate="yes" xml:space="preserve">
          <source>The first insert specifies a valid UUID character representation. The second one set it to NULL. The third one (a void string) generates a Java random UUID. UPDATE commands obey the same specification.</source>
          <target state="translated">첫 번째 삽입은 유효한 UUID 문자 표현을 지정합니다. 두 번째는 NULL로 설정했습니다. 세 번째 (공백 문자열)는 Java 임의 UUID를 생성합니다. UPDATE 명령은 동일한 사양을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="897d2f8eabda1344fa724375a8b60137c65e620f" translate="yes" xml:space="preserve">
          <source>The first issue is addressed by the way data file names are constructed. For instance let us suppose we want to make a table from the fixed formatted files:</source>
          <target state="translated">첫 번째 문제는 데이터 파일 이름이 구성되는 방식으로 해결됩니다. 예를 들어 고정 형식의 파일로 테이블을 만들고 싶다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="993cc0b745fff2d530dd0727fcbd468ad9e7cd1e" translate="yes" xml:space="preserve">
          <source>The first line should contain the name of the library object file, with no extension. The other lines list the names of the components. Each value should be on a separate line, and the &lt;code&gt;#&lt;/code&gt; character at the start of the line indicates a comment.</source>
          <target state="translated">첫 번째 행에는 확장자가없는 라이브러리 오브젝트 파일의 이름이 포함되어야합니다. 다른 줄에는 구성 요소 이름이 나열됩니다. 각 값은 별도의 줄에 있어야하며 &lt;code&gt;#&lt;/code&gt; 의 시작 부분에있는 문자는 주석을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="92d282bc9c813d02331eaf184b4d5df0347d86f1" translate="yes" xml:space="preserve">
          <source>The first method can be used to install the plugin without restarting the server. You can install the plugin dynamically by executing &lt;code&gt;&lt;a href=&quot;../install-soname/index&quot;&gt;INSTALL SONAME&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../install-plugin/index&quot;&gt;INSTALL PLUGIN&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">첫 번째 방법은 서버를 다시 시작하지 않고 플러그인을 설치하는 데 사용할 수 있습니다. &lt;code&gt;&lt;a href=&quot;../install-soname/index&quot;&gt;INSTALL SONAME&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../install-plugin/index&quot;&gt;INSTALL PLUGIN&lt;/a&gt;&lt;/code&gt; 을 실행하여 플러그인을 동적으로 설치할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="52892959e584399bcbe7f8a75aaeee07ea03b4d3" translate="yes" xml:space="preserve">
          <source>The first method can be used to install the plugin without restarting the server. You can install the plugin dynamically by executing &lt;code&gt;&lt;a href=&quot;../install-soname/index&quot;&gt;INSTALL SONAME&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../install-plugin/index&quot;&gt;INSTALL PLUGIN&lt;/a&gt;&lt;/code&gt;. For example:</source>
          <target state="translated">첫 번째 방법은 서버를 다시 시작하지 않고 플러그인을 설치하는 데 사용할 수 있습니다. &lt;code&gt;&lt;a href=&quot;../install-soname/index&quot;&gt;INSTALL SONAME&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../install-plugin/index&quot;&gt;INSTALL PLUGIN&lt;/a&gt;&lt;/code&gt; 을 실행하여 플러그인을 동적으로 설치할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="47197acc50ed52083f8ca4c74ac06dd0510680cc" translate="yes" xml:space="preserve">
          <source>The first number 0 is the domain ID, which is specific for global transaction ID (more on this below). It is a 32-bit unsigned integer.</source>
          <target state="translated">첫 번째 숫자 0은 도메인 ID이며 글로벌 트랜잭션 ID에 고유합니다 (자세한 내용은 아래 참조). 부호없는 32 비트 정수입니다.</target>
        </trans-unit>
        <trans-unit id="0e016372c5c7caf17449fb9539a0c5d96b774c57" translate="yes" xml:space="preserve">
          <source>The first one specifies a required integer field (&lt;code&gt;%d&lt;/code&gt;), the second line describes a field that can be an integer, but can be replaced by a &quot;-&quot; (or any other) character. Specifying the format specification for this column as a character field (&lt;code&gt;%s&lt;/code&gt;) enables to recognize it with no error in all cases. Later on, this field will be converted to integer by the column read function, and a null 0 value will be generated for field specified in their format as non-numeric.</source>
          <target state="translated">첫 번째는 필수 정수 필드 ( &lt;code&gt;%d&lt;/code&gt; )를 지정하고 두 번째 행은 정수일 수 있지만 &quot;-&quot;(또는 다른 문자) 문자로 대체 할 수있는 필드를 설명합니다. 이 열의 형식 지정을 문자 필드 ( &lt;code&gt;%s&lt;/code&gt; )로 지정하면 모든 경우에 오류없이이를 인식 할 수 있습니다. 나중에이 필드는 열 읽기 함수에 의해 정수로 변환되며, 숫자가 아닌 형식으로 지정된 필드에 대해 null 0 값이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="e65b7a9ce631baffac8a55d950f1ea0c87c5af06" translate="yes" xml:space="preserve">
          <source>The first problem is solved by preparing the srcdef view to receive clauses. The above example srcdef becomes:</source>
          <target state="translated">첫 번째 문제점은 절을 수신하도록 srcdef보기를 준비하여 해결됩니다. 위의 srcdef 예제는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3929037d5843d325b6f727025fa0e377c72bd2a3" translate="yes" xml:space="preserve">
          <source>The first query returns no rows, 0 are valid values and not NULL. The second query replies:</source>
          <target state="translated">첫 번째 쿼리는 행을 반환하지 않습니다. 0은 유효한 값이며 NULL이 아닙니다. 두 번째 쿼리는 다음과 같이 응답합니다.</target>
        </trans-unit>
        <trans-unit id="0dd1f1656879b7d10e2cca4f32a798201aa248de" translate="yes" xml:space="preserve">
          <source>The first query shows that the authenticated user is 'geoff@localhost' while current user is 'dba@localhost'. This shows that the session authenticated as geoff and proxied to dba correctly.</source>
          <target state="translated">첫 번째 쿼리는 인증 된 사용자는 'geoff @ localhost'이고 현재 사용자는 'dba @ localhost'입니다. 이는 세션이 geoff로 인증되고 dba로 올바르게 프록시되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5063dc1a74bc4a712142058078183c69607e1b0b" translate="yes" xml:space="preserve">
          <source>The first returns true because the pattern &quot;Mari&quot; exists in the expression &quot;Maria&quot;. When the order is reversed, the result is false, as the pattern &quot;Maria&quot; does not exist in the expression &quot;Mari&quot;</source>
          <target state="translated">&quot;Mari&quot;패턴이 &quot;Maria&quot;표현식에 존재하므로 첫 번째는 true를 리턴합니다. 순서가 반대로되면 패턴 &quot;Maria&quot;가 &quot;Mari&quot;표현식에 없기 때문에 결과는 false입니다.</target>
        </trans-unit>
        <trans-unit id="aaa102169526b7128be194acf3b067921a9fdefc" translate="yes" xml:space="preserve">
          <source>The first row is displayed as:</source>
          <target state="translated">첫 번째 행은 다음과 같이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="8df2a68f15bc8559c795090270b3b55f06e13ab5" translate="yes" xml:space="preserve">
          <source>The first select received the table name &lt;code&gt;&amp;amp;lt;subquery2&amp;amp;gt;&lt;/code&gt;. This is the table that we got as a result of the materialization of the select with &lt;code&gt;id=2&lt;/code&gt;.</source>
          <target state="translated">첫 번째 선택은 &lt;code&gt;&amp;amp;lt;subquery2&amp;amp;gt;&lt;/code&gt; . 이것은 &lt;code&gt;id=2&lt;/code&gt; 인 select의 구체화의 결과로 얻은 테이블입니다 .</target>
        </trans-unit>
        <trans-unit id="1253dacdca6bfdcc113db518922538bf846e2df0" translate="yes" xml:space="preserve">
          <source>The first step for most Linux distributions is to copy the &lt;code&gt;mysql.server&lt;/code&gt; script to &lt;code&gt;/etc/init.d/&lt;/code&gt; and make it executable:</source>
          <target state="translated">대부분의 Linux 배포판의 첫 단계는 &lt;code&gt;mysql.server&lt;/code&gt; 스크립트를 &lt;code&gt;/etc/init.d/&lt;/code&gt; 에 복사하는 것입니다. 실행 가능하게하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="45075375b9ee0bfb318dba65642ac5c7560c1de4" translate="yes" xml:space="preserve">
          <source>The first step is to configure the locations and file names of logs. To make the log rotation configuration easier, it can be best to put these logs in a dedicated log directory.</source>
          <target state="translated">첫 번째 단계는 로그의 위치와 파일 이름을 구성하는 것입니다. 로그 회전 구성을보다 쉽게하려면 이러한 로그를 전용 로그 디렉토리에 두는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="ec73c2c4065c57a0010626fb23608b53d8f512a1" translate="yes" xml:space="preserve">
          <source>The first step is to decide what order the optimizer will go through the tables. If you cannot figure it out, then you may need to be pessimistic and create two indexes for each table -- one assuming the table will be used first, one assiming that it will come later in the table order.</source>
          <target state="translated">첫 번째 단계는 옵티마이 저가 테이블을 통과하는 순서를 결정하는 것입니다. 이를 파악할 수 없으면 비관적이며 각 테이블에 대해 두 개의 인덱스를 만들어야합니다. 하나는 테이블이 먼저 사용된다고 가정하고 다른 하나는 나중에 테이블 순서로 올 것입니다.</target>
        </trans-unit>
        <trans-unit id="cd3b5debc704c8fd014738a69026b1cb76a3b437" translate="yes" xml:space="preserve">
          <source>The first step is to simply take and prepare a fresh &lt;a href=&quot;../full-backup-and-restore-with-mariabackup/index&quot;&gt;full backup&lt;/a&gt; of a database server in the &lt;a href=&quot;../replication-overview/index#common-replication-setups&quot;&gt;replication topology&lt;/a&gt;. If the source database server is the desired replication master, then we do not need to add any additional options when taking the full backup. For example:</source>
          <target state="translated">첫 번째 단계는 &lt;a href=&quot;../replication-overview/index#common-replication-setups&quot;&gt;복제 토폴로지&lt;/a&gt; 에서 데이터베이스 서버의 &lt;a href=&quot;../full-backup-and-restore-with-mariabackup/index&quot;&gt;전체 백업&lt;/a&gt; 을 간단히 준비하고 준비하는 것 입니다. 입니다. 소스 데이터베이스 서버가 원하는 복제 마스터 인 경우 전체 백업을 수행 할 때 추가 옵션을 추가 할 필요가 없습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6fdaaf5cbda48d7a887c61e1545b6353d0c021c0" translate="yes" xml:space="preserve">
          <source>The first step is to simply take and prepare a fresh &lt;a href=&quot;../full-backup-and-restore-with-mariabackup/index&quot;&gt;full backup&lt;/a&gt; of the node that you have chosen to be the replication master. For example:</source>
          <target state="translated">첫 번째 단계는 복제 마스터로 선택한 노드의 &lt;a href=&quot;../full-backup-and-restore-with-mariabackup/index&quot;&gt;전체 백업&lt;/a&gt; 을 간단히 준비하고 준비하는 것 입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9aad99314c711cba9d8bd27d2dea39fba15249b5" translate="yes" xml:space="preserve">
          <source>The first syntax returns the position of the first occurrence of substring &lt;code&gt;substr&lt;/code&gt; in string &lt;code&gt;str&lt;/code&gt;. The second syntax returns the position of the first occurrence of substring &lt;code&gt;substr&lt;/code&gt; in string &lt;code&gt;str&lt;/code&gt;, starting at position &lt;code&gt;pos&lt;/code&gt;. Returns 0 if &lt;code&gt;substr&lt;/code&gt; is not in &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">첫 번째 구문은 문자열 &lt;code&gt;str&lt;/code&gt; 에서 substring &lt;code&gt;substr&lt;/code&gt; 이 처음 나타나는 위치를 반환합니다 . 두 번째 구문은 &lt;code&gt;pos&lt;/code&gt; 위치에서 시작하여 문자열 &lt;code&gt;str&lt;/code&gt; 에서 substring &lt;code&gt;substr&lt;/code&gt; 이 처음 나타나는 위치를 반환합니다 . &lt;code&gt;substr&lt;/code&gt; 이 &lt;code&gt;str&lt;/code&gt; 에 없으면 0을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="1c5ccf8416f0fc806f09c98af67b35c5e3f18824" translate="yes" xml:space="preserve">
          <source>The first table is the INFORMATION_SCHMEA.COLUMNSTORE_TABLES. This contains information about the tables inside ColumnStore. The table layout is as follows:</source>
          <target state="translated">첫 번째 테이블은 INFORMATION_SCHMEA.COLUMNSTORE_TABLES입니다. 여기에는 ColumnStore 내부의 테이블에 대한 정보가 포함됩니다. 테이블 레이아웃은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9e69cc1ddfac0d9900e77873addbf85ff7ac5d40" translate="yes" xml:space="preserve">
          <source>The first thing the MariaDB optimizer does is to merge the &lt;code&gt;VIEW&lt;/code&gt; definition into the query to obtain:</source>
          <target state="translated">MariaDB 최적화 프로그램이 수행하는 첫 번째 작업은 &lt;code&gt;VIEW&lt;/code&gt; 정의를 쿼리에 병합 하여 다음을 얻는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c930a56746861dd778da8db1da8dc3305350e1d6" translate="yes" xml:space="preserve">
          <source>The first thing the MariaDB optimizer does is to merge the VIEW definition ...</source>
          <target state="translated">MariaDB 옵티마이 저가하는 첫 번째 일은 VIEW 정의를 병합하는 것입니다 ...</target>
        </trans-unit>
        <trans-unit id="ed61349b82880739506588d4240277cfeef0b585" translate="yes" xml:space="preserve">
          <source>The first thread sends all changed buffers to disk. This is repeated as long as there are new LSNs added. The process can not loop forever because we have a limited number of threads and they will wait for the data to be synced.</source>
          <target state="translated">첫 번째 스레드는 변경된 모든 버퍼를 디스크로 보냅니다. 새로운 LSN이 추가되는 한이 과정이 반복됩니다. 스레드 수가 제한되어 있고 데이터가 동기화 될 때까지 대기하기 때문에 프로세스가 영원히 반복 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9bd5fbd01d7d86aaaf1a4da0a30f10e47db997d8" translate="yes" xml:space="preserve">
          <source>The first three columns of the search table must have a type of &lt;code&gt;BIGINT&lt;/code&gt; for the 1st column (document id), &lt;code&gt;INTEGER&lt;/code&gt; or &lt;code&gt;BIGINT&lt;/code&gt; for the 2nd column (match weight), and &lt;code&gt;VARCHAR&lt;/code&gt; or &lt;code&gt;TEXT&lt;/code&gt; for the 3rd column (your query), respectively. This mapping is fixed; you cannot omit any of these three required columns, or move them around, or change types. Also, the query column must be indexed; all the others must be kept unindexed. Column names are ignored so you can use arbitrary ones.</source>
          <target state="translated">검색 테이블의 처음 세 열에는 각각 첫 번째 열 (문서 ID)에 대한 &lt;code&gt;BIGINT&lt;/code&gt; 유형 , 두 번째 열에 대한 &lt;code&gt;INTEGER&lt;/code&gt; 또는 &lt;code&gt;BIGINT&lt;/code&gt; (일치 가중치) 및 세 번째 열 (쿼리)에 대한 &lt;code&gt;VARCHAR&lt;/code&gt; 또는 &lt;code&gt;TEXT&lt;/code&gt; 가 있어야합니다. 이 매핑은 고정되어 있습니다. 이 세 가지 필수 열을 생략하거나 이동하거나 유형을 변경할 수 없습니다. 또한 조회 열을 색인화해야합니다. 나머지는 모두 색인화되지 않은 상태로 유지해야합니다. 열 이름은 무시되므로 임의의 이름을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="740ed8e32ec15c4551b3b582f4da042a6ba55601" translate="yes" xml:space="preserve">
          <source>The first three numbers are generated from a timestamp.</source>
          <target state="translated">처음 세 숫자는 타임 스탬프에서 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="274828c0f174cc37ccff294dc6227bcfd2c9814c" translate="yes" xml:space="preserve">
          <source>The first three strategies have flags in @@optimizer_switch that can be used to disable them. The &lt;code&gt;DuplicateWeedout&lt;/code&gt; strategy does not have a flag. This was done for a reason, as that strategy is the catch-all strategy and it can handle all kinds of subqueries, in all kinds of join orders. (We're slowly moving to the point where it will be possible to run with &lt;code&gt;FirstMatch&lt;/code&gt; enabled and everything else disabled but we are not there yet.)</source>
          <target state="translated">처음 세 가지 전략에는 @@ optimizer_switch에 플래그가있어이를 비활성화하는 데 사용할 수 있습니다. &lt;code&gt;DuplicateWeedout&lt;/code&gt; 의 전략은 플래그를 가지고 있지 않습니다. 이는 전략이 포괄 전략이며 모든 종류의 조인 순서에서 모든 종류의 하위 쿼리를 처리 할 수 ​​있기 때문에 이유가 있습니다. ( &lt;code&gt;FirstMatch&lt;/code&gt; 를 사용하고 다른 모든 기능을 사용하지 않고 실행할 수있는 지점으로 천천히 이동하고 있지만 아직은 없습니다.)</target>
        </trans-unit>
        <trans-unit id="342ca98e1e0f216bbbf545a869171d4548497d82" translate="yes" xml:space="preserve">
          <source>The first two names, ordered alphabetically:</source>
          <target state="translated">알파벳순으로 정렬 된 처음 두 이름 :</target>
        </trans-unit>
        <trans-unit id="b2b55376ed3cb4924eae982e1c5c95cfa4900ef9" translate="yes" xml:space="preserve">
          <source>The first two syntaxes; &lt;code&gt;X'value'&lt;/code&gt; and x'&lt;code&gt;value&lt;/code&gt;, follow the SQL standard, and behave as a string in all contexts in MariaDB since &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1003-release-notes/&quot;&gt;MariaDB 10.0.3&lt;/a&gt; and &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5531-release-notes/&quot;&gt;MariaDB 5.5.31&lt;/a&gt; (fixing &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-4489&quot;&gt;MDEV-4489&lt;/a&gt;). The latter syntax, 0x&lt;code&gt;value&lt;/code&gt;, is a MySQL/MariaDB extension for hex hybrids and behaves as a string or as a number depending on context. MySQL treats all syntaxes the same, so there may be different results in MariaDB and MySQL (see below).</source>
          <target state="translated">처음 두 구문; &lt;code&gt;X'value'&lt;/code&gt; 및 X' &lt;code&gt;value&lt;/code&gt; 이후 MariaDB의 모든 상황에서 문자열로 SQL 표준 및 행동하라 따라 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1003-release-notes/&quot;&gt;MariaDB 10.0.3&lt;/a&gt; 및 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5531-release-notes/&quot;&gt;MariaDB 5.5.31을&lt;/a&gt; (고정 &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-4489&quot;&gt;인 mdev-4489을&lt;/a&gt; ). 후자의 구문 인 0x &lt;code&gt;value&lt;/code&gt; 는 16 진 하이브리드를위한 MySQL / MariaDB 확장이며 컨텍스트에 따라 문자열 또는 숫자로 동작합니다. MySQL은 모든 구문을 동일하게 취급하므로 MariaDB와 MySQL의 결과가 다를 수 있습니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="85cf141ce03d74400cb8b52935c235863e06a638" translate="yes" xml:space="preserve">
          <source>The first version returns the result where value=compare_value. The second version returns the result for the first condition that is true. If there was no matching result value, the result after ELSE is returned, or NULL if there is no ELSE part.</source>
          <target state="translated">첫 번째 버전은 value = compare_value 인 결과를 반환합니다. 두 번째 버전은 첫 번째 조건에 해당하는 결과를 반환합니다. 일치하는 결과 값이 없으면 ELSE 이후의 결과가 리턴되고 ELSE 부분이 없으면 NULL이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="4b06b2a8cb7fdd8e64020490e95afb6ad2cb01aa" translate="yes" xml:space="preserve">
          <source>The first way involves doing a full scan on the materialized table, so we call it &quot;Materialization-scan&quot;.</source>
          <target state="translated">첫 번째 방법은 구체화 된 테이블에서 전체 스캔을 수행하는 것이므로 &quot;재료 화 스캔&quot;이라고합니다.</target>
        </trans-unit>
        <trans-unit id="8670b0fcc56459073188968c7dfb5a9cbf216cb5" translate="yes" xml:space="preserve">
          <source>The first way is to check the &lt;a href=&quot;../server-status-variables/index#sort_priority_queue_sorts&quot;&gt;Sort_priority_queue_sorts&lt;/a&gt; status variable. It shows the number of times that sorting was done through a priority queue. (The total number of times sorting was done is a sum &lt;a href=&quot;../server-status-variables/index#sort_range&quot;&gt;Sort_range&lt;/a&gt; and &lt;a href=&quot;../server-status-variables/index#sort_scan&quot;&gt;Sort_scan&lt;/a&gt;).</source>
          <target state="translated">첫 번째 방법은 &lt;a href=&quot;../server-status-variables/index#sort_priority_queue_sorts&quot;&gt;Sort_priority_queue_sorts&lt;/a&gt; 상태 변수 를 확인하는 것 입니다. 우선 순위 큐를 통해 정렬이 수행 된 횟수를 보여줍니다. (정렬 된 총 횟수는 &lt;a href=&quot;../server-status-variables/index#sort_range&quot;&gt;Sort_range&lt;/a&gt; 및 &lt;a href=&quot;../server-status-variables/index#sort_scan&quot;&gt;Sort_scan&lt;/a&gt; 의 합계 입니다.)</target>
        </trans-unit>
        <trans-unit id="df43f0ad66ab1552b1c9b3402bd1f8f4eee1bd55" translate="yes" xml:space="preserve">
          <source>The first way is to regard it as a table having one line per section, the columns being the keys you want to display. In this case, the CREATE statement could be:</source>
          <target state="translated">첫 번째 방법은이 섹션을 섹션 당 하나의 행이있는 테이블로 간주하는 것입니다. 열은 표시하려는 키입니다. 이 경우 CREATE 문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2e714b0eeb4c05338d50becfdff28b1aed52b0c3" translate="yes" xml:space="preserve">
          <source>The first way uses a Connection String whose components describe what is needed to establish the connection. It is the most complete way to do it and by default CONNECT uses it.</source>
          <target state="translated">첫 번째 방법은 구성 요소가 연결을 설정하는 데 필요한 것을 설명하는 연결 문자열을 사용합니다. 이를 수행하는 가장 완벽한 방법이며 기본적으로 CONNECT가 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ad1d2de5e5f6c7ccb2d4a1b7a3d1a85b497572e1" translate="yes" xml:space="preserve">
          <source>The first_value and last_value functions allow determining the first and last values of a given range. Combined with a group by this allows summarizing opening and closing values. The example shows a more complex case where detailed information is presented for first and last opportunity by quarter.</source>
          <target state="translated">first_value 및 last_value 함수를 사용하면 주어진 범위의 첫 번째 및 마지막 값을 결정할 수 있습니다. 이를 통해 그룹과 결합하면 시가와 마감가를 요약 할 수 있습니다. 이 예는 분기 별 첫 번째 및 마지막 기회에 대한 자세한 정보가 제공되는 더 복잡한 경우를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="b75b43d747c72a362fd55e20afc84bfbc4d05ef8" translate="yes" xml:space="preserve">
          <source>The fix for &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-12112&quot;&gt;MDEV-12112&lt;/a&gt; that was included in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10138-release-notes/&quot;&gt;MariaDB 10.1.38&lt;/a&gt;, &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10220-release-notes/&quot;&gt;MariaDB 10.2.20&lt;/a&gt;, and &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10312-release-notes/&quot;&gt;MariaDB 10.3.12&lt;/a&gt; changed the way that MariaDB distinguishes between encrypted and unencrypted pages, so that it is less likely to mistake an unencrypted page for an encrypted page.</source>
          <target state="translated">&lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10138-release-notes/&quot;&gt;MariaDB 10.1.38&lt;/a&gt; , &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10220-release-notes/&quot;&gt;MariaDB 10.2.20&lt;/a&gt; 및 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10312-release-notes/&quot;&gt;MariaDB 10.3.12&lt;/a&gt; 에 포함 된 &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-12112&quot;&gt;MDEV-12112에&lt;/a&gt; 대한 수정은 MariaDB가 암호화 된 페이지와 암호화되지 않은 페이지를 구별하는 방식을 변경하여 암호화되지 않은 페이지를 암호화하지 않은 페이지로 착각 할 가능성이 줄었습니다. 암호화 된 페이지.</target>
        </trans-unit>
        <trans-unit id="b6262450795f00f209155b8a7ca1cc6e11b76f18" translate="yes" xml:space="preserve">
          <source>The fix is to &lt;code&gt;&lt;a href=&quot;../delete/index&quot;&gt;DELETE&lt;/a&gt;&lt;/code&gt; the row in the &lt;code&gt;&lt;a href=&quot;../mysqldb-table/index&quot;&gt;mysql.db&lt;/a&gt;&lt;/code&gt; table and then execute &lt;code&gt;&lt;a href=&quot;../flush/index&quot;&gt;FLUSH PRIVILEGES&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">수정은 &lt;code&gt;&lt;a href=&quot;../mysqldb-table/index&quot;&gt;mysql.db&lt;/a&gt;&lt;/code&gt; 테이블 에서 행 을 &lt;code&gt;&lt;a href=&quot;../delete/index&quot;&gt;DELETE&lt;/a&gt;&lt;/code&gt; 한 다음 &lt;code&gt;&lt;a href=&quot;../flush/index&quot;&gt;FLUSH PRIVILEGES&lt;/a&gt;&lt;/code&gt; 를 실행하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="c21f0d13acc0ce75c4d694b592de31aeba427392" translate="yes" xml:space="preserve">
          <source>The fixes were made as a response to complaints by MariaDB customers, so they fix real-world optimization problems. The fixes are a bit hard to describe (as the &lt;code&gt;ORDER BY&lt;/code&gt; optimizer is complicated), but here's a short description:</source>
          <target state="translated">이 수정은 MariaDB 고객의 불만에 대한 응답으로 작성되었으므로 실제 최적화 문제를 해결합니다. 수정 프로그램은 &lt;code&gt;ORDER BY&lt;/code&gt; 옵티마이 저가 복잡 하기 때문에 설명하기 약간 어렵지만 간단한 설명은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="40fc0747cf1430b323ad575c89cf1d92cc854d6c" translate="yes" xml:space="preserve">
          <source>The flag field returns the dict_table_t::flags that correspond to the data dictionary record.</source>
          <target state="translated">플래그 필드는 데이터 사전 레코드에 해당하는 dict_table_t :: flags를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="b3d1c92222a49c12ac6fad046212c8e4d65d65e0" translate="yes" xml:space="preserve">
          <source>The flipping step uses a fast, atomic, RENAME.</source>
          <target state="translated">뒤집기 단계는 빠른 원자 RENAME을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="50a7c0b7f2536267a297dacc382f41aaa271ef35" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;../cassandra-status-variables/index&quot;&gt;status variables&lt;/a&gt; are available:</source>
          <target state="translated">사용 가능한 &lt;a href=&quot;../cassandra-status-variables/index&quot;&gt;상태 변수&lt;/a&gt; 는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="3bd3418eada422974904fd20fceb9e0af2a181fa" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;../cassandra-system-variables/index&quot;&gt;system variables&lt;/a&gt; are available:</source>
          <target state="translated">다음과 같은 &lt;a href=&quot;../cassandra-system-variables/index&quot;&gt;시스템 변수&lt;/a&gt; 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c14af4dc2bf7ddca9d669ea2dd61fe90974ba8d" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;../user-defined-functions/index&quot;&gt;UDf's&lt;/a&gt; are available with the &lt;a href=&quot;../spider/index&quot;&gt;Spider Storage Engine&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../spider/index&quot;&gt;Spider Storage Engine&lt;/a&gt; 과 함께 다음 &lt;a href=&quot;../user-defined-functions/index&quot;&gt;UDf&lt;/a&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="47906466558872a40a384d3a19919224906816c7" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;&lt;a href=&quot;../show/index&quot;&gt;SHOW&lt;/a&gt;&lt;/code&gt; statements can be extended by using a &lt;code&gt;WHERE&lt;/code&gt; clause and a &lt;code&gt;LIKE&lt;/code&gt; clause to refine the results:</source>
          <target state="translated">&lt;code&gt;WHERE&lt;/code&gt; 절과 &lt;code&gt;LIKE&lt;/code&gt; 절을 사용하여 다음 &lt;code&gt;&lt;a href=&quot;../show/index&quot;&gt;SHOW&lt;/a&gt;&lt;/code&gt; 문을 확장 하여 결과를 구체화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a213109958f6ce23f8e613c909f784c91ba84fd5" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;INFORMATION_SCHEMA&lt;/code&gt; tables can be used to monitor the performances of XtraDB/InnoDB compressed tables:</source>
          <target state="translated">다음 &lt;code&gt;INFORMATION_SCHEMA&lt;/code&gt; 테이블을 사용하여 XtraDB / InnoDB 압축 테이블의 성능을 모니터 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eef3162046520792d04448c772dcd83e9d3cd9ba" translate="yes" xml:space="preserve">
          <source>The following MariaDB MaxScale versions are currently supported:</source>
          <target state="translated">다음과 같은 MariaDB MaxScale 버전이 현재 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="6a3b191c1459e1fd176cdecd48a1782dd9179f57" translate="yes" xml:space="preserve">
          <source>The following MariaDB versions are currently supported:</source>
          <target state="translated">다음과 같은 MariaDB 버전이 현재 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="3f82e4028fb58b6b6a41f81932e58925e2709830" translate="yes" xml:space="preserve">
          <source>The following NoSQL types are supported:</source>
          <target state="translated">다음과 같은 NoSQL 유형이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="59c1cc0875271f59e529d5f4aabefc5262f141e9" translate="yes" xml:space="preserve">
          <source>The following R Statements can be used for importing a MariaDB table to H2O.ai using the R Front End:</source>
          <target state="translated">R 프론트 엔드를 사용하여 MariaDB 테이블을 H2O.ai로 가져 오는 데 다음 R 명령문을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39271407441c0953c1c533b9cc503912b34a0573" translate="yes" xml:space="preserve">
          <source>The following SQL queries are not supported</source>
          <target state="translated">다음 SQL 쿼리는 지원되지 않습니다</target>
        </trans-unit>
        <trans-unit id="3ddc44e2ed9a85258be0da7bcf1e7430ab96a27a" translate="yes" xml:space="preserve">
          <source>The following SQL statements are not permitted inside any &lt;a href=&quot;../stored-programs-and-views/index&quot;&gt;stored routines&lt;/a&gt; (&lt;a href=&quot;../stored-functions/index&quot;&gt;stored functions&lt;/a&gt;, &lt;a href=&quot;../stored-procedures/index&quot;&gt;stored procedures&lt;/a&gt;, &lt;a href=&quot;../events/index&quot;&gt;events&lt;/a&gt; or &lt;a href=&quot;../triggers/index&quot;&gt;triggers&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;../stored-programs-and-views/index&quot;&gt;저장된&lt;/a&gt; SQL 루틴 ( &lt;a href=&quot;../stored-functions/index&quot;&gt;저장 함수&lt;/a&gt; , &lt;a href=&quot;../stored-procedures/index&quot;&gt;저장 프로 시저&lt;/a&gt; , &lt;a href=&quot;../events/index&quot;&gt;이벤트&lt;/a&gt; 또는 &lt;a href=&quot;../triggers/index&quot;&gt;트리거&lt;/a&gt; ) 에서는 다음 SQL 문이 허용되지 않습니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
