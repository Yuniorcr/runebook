<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="gcc">
    <body>
      <group id="gcc">
        <trans-unit id="73691e44c058afa420e3a5b298659ae385093f25" translate="yes" xml:space="preserve">
          <source>Conform to the language syntax of Objective-C 1.0, the language recognized by GCC 4.0. This only affects the Objective-C additions to the C/C++ language; it does not affect conformance to C/C++ standards, which is controlled by the separate C/C++ dialect option flags. When this option is used with the Objective-C or Objective-C++ compiler, any Objective-C syntax that is not recognized by GCC 4.0 is rejected. This is useful if you need to make sure that your Objective-C code can be compiled with older versions of GCC.</source>
          <target state="translated">GCC 4.0에서 인식되는 언어 인 Objective-C 1.0의 언어 구문을 준수합니다. 이것은 C / C ++ 언어에 대한 Objective-C 추가에만 영향을줍니다. 별도의 C / C ++ 언어 옵션 플래그에 의해 제어되는 C / C ++ 표준 준수에 영향을 미치지 않습니다. 이 옵션을 Objective-C 또는 Objective-C ++ 컴파일러와 함께 사용하면 GCC 4.0에서 인식되지 않는 Objective-C 구문이 거부됩니다. Objective-C 코드를 이전 버전의 GCC로 컴파일 할 수 있어야하는 경우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="276327c90b14e9bc39dc498e6536c698c6fb7874" translate="yes" xml:space="preserve">
          <source>Conformance to the same ABI and the same behavior of implementation-defined features are both relevant for compatibility.</source>
          <target state="translated">동일한 ABI 및 구현 정의 기능의 동일한 동작에 대한 적합성은 호환성과 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="af74bda50719fa1b3103b3627d3eb38149eb7313" translate="yes" xml:space="preserve">
          <source>Consider (as in C99 subclause 6.7.5 paragraph 4) a declaration &lt;code&gt;T
D1&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; contains declaration specifiers that specify a type &lt;var&gt;Type&lt;/var&gt; (such as &lt;code&gt;int&lt;/code&gt;) and &lt;code&gt;D1&lt;/code&gt; is a declarator that contains an identifier &lt;var&gt;ident&lt;/var&gt;. The type specified for &lt;var&gt;ident&lt;/var&gt; for derived declarators whose type does not include an attribute specifier is as in the ISO C standard.</source>
          <target state="translated">(C99 하위 조항 6.7.5 단락 4에서와 같이) 선언 &lt;code&gt;T D1&lt;/code&gt; 고려하십시오 . 여기서 &lt;code&gt;T&lt;/code&gt; 는 유형 &lt;var&gt;Type&lt;/var&gt; (예 : &lt;code&gt;int&lt;/code&gt; ) 을 지정하는 선언 지정자를 포함 하고 &lt;code&gt;D1&lt;/code&gt; 은 식별자 &lt;var&gt;ident&lt;/var&gt; 를 포함하는 선언자입니다 . 속성 지정자를 포함하지 않는 파생 선언자에 대해 &lt;var&gt;ident&lt;/var&gt; 에 지정된 형식은 ISO C 표준과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9b667c089da7e561b4d6f55e12e93a78181226e5" translate="yes" xml:space="preserve">
          <source>Consider all &lt;code&gt;static&lt;/code&gt; functions called once for inlining into their caller even if they are not marked &lt;code&gt;inline&lt;/code&gt;. If a call to a given function is integrated, then the function is not output as assembler code in its own right.</source>
          <target state="translated">모든 고려 &lt;code&gt;static&lt;/code&gt; 가 표시되지 않은 경우에도 자신의 호출자에 인라인에 대해 한 번 호출되는 함수 &lt;code&gt;inline&lt;/code&gt; . 주어진 함수에 대한 호출이 통합되면 함수는 그 자체로 어셈블러 코드로 출력되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="35a3be8ed672f20c07ec027046430f867cf3e587" translate="yes" xml:space="preserve">
          <source>Consider all functions for inlining, even if they are not declared inline. The compiler heuristically decides which functions are worth integrating in this way.</source>
          <target state="translated">인라인으로 선언되지 않은 경우에도 인라인을위한 모든 함수를 고려하십시오. 컴파일러는 이러한 방식으로 통합 할 가치가있는 기능을 경험적으로 결정합니다.</target>
        </trans-unit>
        <trans-unit id="7b85816a30be72db5578a7db246b88f298f1a216" translate="yes" xml:space="preserve">
          <source>Consider that instructions that may throw exceptions but don&amp;rsquo;t otherwise contribute to the execution of the program can be optimized away. This option is enabled by default for the Ada front end, as permitted by the Ada language specification. Optimization passes that cause dead exceptions to be removed are enabled independently at different optimization levels.</source>
          <target state="translated">예외를 발생시킬 수 있지만 프로그램 실행에 기여하지 않는 명령어는 최적화 할 수 있습니다. 이 옵션은 Ada 언어 사양에서 허용하는대로 Ada 프론트 엔드에 기본적으로 사용됩니다. 데드 예외를 제거하는 최적화 단계는 다른 최적화 수준에서 독립적으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="56b80af072fa83ee95788ec24e46c4595598d634" translate="yes" xml:space="preserve">
          <source>Consider the following example,</source>
          <target state="translated">다음 예를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="a59af01b7f010c19c9dde4af8032ceeec0657a9d" translate="yes" xml:space="preserve">
          <source>Consider type &lt;code&gt;int&lt;/code&gt; to be 16 bits wide, like &lt;code&gt;short int&lt;/code&gt;. Additionally, parameters passed on the stack are also aligned to a 16-bit boundary even on targets whose API mandates promotion to 32-bit.</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; 유형을 &lt;code&gt;short int&lt;/code&gt; 처럼 16 비트 폭으로 간주하십시오 . 또한 스택에 전달 된 매개 변수는 API가 32 비트 승격을 요구하는 대상에서도 16 비트 경계에 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="14249be6954dd348580bb1e0a79129f5f1192211" translate="yes" xml:space="preserve">
          <source>Constant 255.</source>
          <target state="translated">상수 255.</target>
        </trans-unit>
        <trans-unit id="7c36129cdf24a616a089dfb7d284688c9138762e" translate="yes" xml:space="preserve">
          <source>Constant 65535.</source>
          <target state="translated">상수 65535.</target>
        </trans-unit>
        <trans-unit id="7ebcf06cc87a00b632c948fbc204e56f0827cd01" translate="yes" xml:space="preserve">
          <source>Constant &lt;var&gt;n&lt;/var&gt;, where &lt;var&gt;n&lt;/var&gt; is a single-digit constant in the range 0 to 4.</source>
          <target state="translated">상수 &lt;var&gt;n&lt;/var&gt; . 여기서 &lt;var&gt;n&lt;/var&gt; 은 0-4 범위의 한 자리 상수입니다.</target>
        </trans-unit>
        <trans-unit id="37323b42fe56e6f04c3dbbef4d9fbb95b7fc380b" translate="yes" xml:space="preserve">
          <source>Constant for arithmetic/logical operations. This is like &lt;code&gt;i&lt;/code&gt;, except that for position independent code, no symbols / expressions needing relocations are allowed.</source>
          <target state="translated">산술 / 논리 연산을위한 상수. 위치 독립적 코드의 경우 재배치가 필요한 기호 / 표현이 허용되지 않는다는 점을 제외하면 &lt;code&gt;i&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="c7644d686263ca6ceaeace041caa08f8c6cf68aa" translate="yes" xml:space="preserve">
          <source>Constant greater than -1, less than 64</source>
          <target state="translated">-1보다 크고 64보다 작은 상수</target>
        </trans-unit>
        <trans-unit id="09c49e4a44186e5736b6b3d234fbcdd1b306818b" translate="yes" xml:space="preserve">
          <source>Constant greater than -64, less than 1</source>
          <target state="translated">-64보다 크고 1보다 작은 상수</target>
        </trans-unit>
        <trans-unit id="629c52a6147c82fa4c525c23e4812fa96465cd8a" translate="yes" xml:space="preserve">
          <source>Constant integer -1</source>
          <target state="translated">상수 정수 -1</target>
        </trans-unit>
        <trans-unit id="721c7841ba7521d9d4cd87f007487a95dabae8a8" translate="yes" xml:space="preserve">
          <source>Constant integer 0</source>
          <target state="translated">상수 정수 0</target>
        </trans-unit>
        <trans-unit id="4c0d77dad954cfa376cbed314919134fe483d92e" translate="yes" xml:space="preserve">
          <source>Constant integer 1</source>
          <target state="translated">상수 정수 1</target>
        </trans-unit>
        <trans-unit id="a0be78fc92c33b25cda27188d52e852922b4e406" translate="yes" xml:space="preserve">
          <source>Constant integer 2</source>
          <target state="translated">상수 정수 2</target>
        </trans-unit>
        <trans-unit id="202072b2675376ab5d42618242f422abd21566ab" translate="yes" xml:space="preserve">
          <source>Constant integer 8, 16, or 24</source>
          <target state="translated">상수 정수 8, 16 또는 24</target>
        </trans-unit>
        <trans-unit id="5bf3f3ad783e97cd6b61e26de5af436d02b8dbc8" translate="yes" xml:space="preserve">
          <source>Constant integer with a value of 0x7fffffff.</source>
          <target state="translated">값이 0x7fffffff 인 정수입니다.</target>
        </trans-unit>
        <trans-unit id="4b2e9b490d5b5f4c17de70d9c9fdf5aa2b4b1450" translate="yes" xml:space="preserve">
          <source>Constant larger than 31</source>
          <target state="translated">31보다 큰 상수</target>
        </trans-unit>
        <trans-unit id="47f3d5d59a235c75b0766f99a2edf9666aa348c9" translate="yes" xml:space="preserve">
          <source>Constant that fits in 8 bits</source>
          <target state="translated">8 비트에 맞는 상수</target>
        </trans-unit>
        <trans-unit id="719b7b797492e1507d09c13adb21a02c3fe64069" translate="yes" xml:space="preserve">
          <source>Constant whose negation is a signed 16-bit constant</source>
          <target state="translated">부정이 부호있는 16 비트 상수 인 상수</target>
        </trans-unit>
        <trans-unit id="180e678224087bf03d6c9c2f7ac11f4d9834fa9a" translate="yes" xml:space="preserve">
          <source>Constant zero</source>
          <target state="translated">상수 제로</target>
        </trans-unit>
        <trans-unit id="a9100a8537fb85e4bf388bedae7d5d58f76e7b6e" translate="yes" xml:space="preserve">
          <source>Constant?</source>
          <target state="translated">Constant?</target>
        </trans-unit>
        <trans-unit id="7efcb4b4f328cdb249f8926cb267f61ac8015a9d" translate="yes" xml:space="preserve">
          <source>Constraints for &lt;code&gt;asm&lt;/code&gt; operands</source>
          <target state="translated">&lt;code&gt;asm&lt;/code&gt; 피연산자에 대한 제약</target>
        </trans-unit>
        <trans-unit id="3e3f7e5411ee0f1fda2ac40b39097fae6a9abb77" translate="yes" xml:space="preserve">
          <source>Constructs webs as commonly used for register allocation purposes and assign each web individual pseudo register. This allows the register allocation pass to operate on pseudos directly, but also strengthens several other optimization passes, such as CSE, loop optimizer and trivial dead code remover. It can, however, make debugging impossible, since variables no longer stay in a &amp;ldquo;home register&amp;rdquo;.</source>
          <target state="translated">레지스터 할당 목적으로 일반적으로 사용되는 웹을 구성하고 각 웹 개별 의사 레지스터를 할당합니다. 이를 통해 레지스터 할당 패스가 의사에서 직접 작동 할 수 있지만 CSE, 루프 최적화 및 사소한 데드 코드 리무버와 같은 다른 여러 최적화 패스가 강화됩니다. 그러나 변수가 더 이상 &quot;홈 레지스터&quot;에 남아 있지 않으므로 디버깅을 불가능하게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4f501afecf0b8b5f3993371f4f6074a753dc0e6" translate="yes" xml:space="preserve">
          <source>Contributors to GCC</source>
          <target state="translated">GCC에 기고자</target>
        </trans-unit>
        <trans-unit id="4648a291e89516ba0f4f56b93d6fdb1d01cfd9c4" translate="yes" xml:space="preserve">
          <source>Control GCC&amp;rsquo;s optimizations to produce output suitable for live-patching.</source>
          <target state="translated">라이브 패치에 적합한 출력을 생성하도록 GCC의 최적화를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="bcc7b6b362569344fe25ab394774bd26a1bf6f6a" translate="yes" xml:space="preserve">
          <source>Control how GCC aligns variables. Supported values for &lt;var&gt;type&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">GCC가 변수를 정렬하는 방법을 제어합니다. &lt;var&gt;type&lt;/var&gt; 에 지원되는 값 은 '</target>
        </trans-unit>
        <trans-unit id="7e88213c055c1aca5596a30dea879bf4859e75f5" translate="yes" xml:space="preserve">
          <source>Control how many registers are used to pass integer arguments. By default, no registers are used to pass arguments, and at most 3 registers can be used. You can control this behavior for a specific function by using the function attribute &lt;code&gt;regparm&lt;/code&gt;. See &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;.</source>
          <target state="translated">정수 인수를 전달하는 데 사용되는 레지스터 수를 제어하십시오. 기본적으로 레지스터를 사용하여 인수를 전달하지 않으며 최대 3 개의 레지스터를 사용할 수 있습니다. 함수 속성 &lt;code&gt;regparm&lt;/code&gt; 을 사용하여 특정 함수에 대해이 동작을 제어 할 수 있습니다 . &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;기능 속성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ae31e36dd1f96d1b47c3f78f649f25722c9f1d7b" translate="yes" xml:space="preserve">
          <source>Control if warning triggered by the &lt;code&gt;warn_if_not_aligned&lt;/code&gt; attribute should be issued. This is enabled by default. Use</source>
          <target state="translated">&lt;code&gt;warn_if_not_aligned&lt;/code&gt; 속성 에 의해 경고가 트리거되는지 여부를 제어하십시오 . 기본적으로 활성화되어 있습니다. 사용하다</target>
        </trans-unit>
        <trans-unit id="a2f461ee948da2dba5ee60b9ffddb2967c79a05b" translate="yes" xml:space="preserve">
          <source>Control the IEEE compliance of floating-point comparisons, which affects the handling of cases where the result of a comparison is unordered. By default</source>
          <target state="translated">부동 소수점 비교의 IEEE 준수를 제어하여 비교 결과가 정렬되지 않은 경우의 처리에 영향을줍니다. 기본적으로</target>
        </trans-unit>
        <trans-unit id="2afb7e07aedef4a32dbbca185426a76a2840c4b0" translate="yes" xml:space="preserve">
          <source>Control the dumping at various stages of inter-procedural analysis language tree to a file. The file name is generated by appending a switch specific suffix to the source file name, and the file is created in the same directory as the output file. The following dumps are possible:</source>
          <target state="translated">절차 간 분석 언어 트리의 다양한 단계에서 파일로의 덤프를 제어합니다. 파일 이름은 소스 파일 이름에 스위치 특정 접미사를 추가하여 생성되며 파일은 출력 파일과 동일한 디렉토리에 작성됩니다. 다음과 같은 덤프가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="f18aaf944d2648faf5bedcbbdbf1ddd945fad607" translate="yes" xml:space="preserve">
          <source>Control the dumping at various stages of processing the intermediate language tree to a file. If the &amp;lsquo;</source>
          <target state="translated">중간 언어 트리를 처리하는 다양한 단계에서 파일로의 덤프를 제어하십시오. '</target>
        </trans-unit>
        <trans-unit id="c0a71f6d1404f7b16378e5d31c9c7e2a41e97704" translate="yes" xml:space="preserve">
          <source>Control the dumping of language-specific information. The &lt;var&gt;options&lt;/var&gt; and &lt;var&gt;filename&lt;/var&gt; portions behave as described in the</source>
          <target state="translated">언어 별 정보의 덤프를 제어합니다. &lt;var&gt;options&lt;/var&gt; 및 &lt;var&gt;filename&lt;/var&gt; 에서 설명한대로 작동 부</target>
        </trans-unit>
        <trans-unit id="d78b6d3fd867212c02526e9987edeed79105b1e7" translate="yes" xml:space="preserve">
          <source>Control the probability of the expression having the specified value. This parameter takes a percentage (i.e. 0 ... 100) as input.</source>
          <target state="translated">표현식이 지정된 값을 가질 확률을 제어하십시오. 이 매개 변수는 입력으로 백분율 (예 : 0 ... 100)을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3bc8404322e32343cc4763c8bd1ae2d2c9dab937" translate="yes" xml:space="preserve">
          <source>Control the verbosity of the dump file for the integrated register allocator. The default value is 5. If the value &lt;var&gt;n&lt;/var&gt; is greater or equal to 10, the dump output is sent to stderr using the same format as &lt;var&gt;n&lt;/var&gt; minus 10.</source>
          <target state="translated">통합 레지스터 할당 자에 대한 덤프 파일의 상세 정도를 제어하십시오. 기본값은 5입니다. 값 &lt;var&gt;n&lt;/var&gt; 이 10보다 크거나 같으면 &lt;var&gt;n&lt;/var&gt; -10 과 같은 형식을 사용하여 덤프 출력이 stderr로 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="f9bae08f2081e939f273d8f52a1db45d82560f46" translate="yes" xml:space="preserve">
          <source>Control whether GCC aligns &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;long double&lt;/code&gt;, and &lt;code&gt;long long&lt;/code&gt; variables on a two-word boundary or a one-word boundary. Aligning &lt;code&gt;double&lt;/code&gt; variables on a two-word boundary produces code that runs somewhat faster on a Pentium at the expense of more memory.</source>
          <target state="translated">GCC가 &lt;code&gt;double&lt;/code&gt; , &lt;code&gt;long double&lt;/code&gt; 및 &lt;code&gt;long long&lt;/code&gt; 변수를 두 단어 경계 또는 한 단어 경계에 정렬할지 여부를 제어합니다 . 두 단어 경계에서 &lt;code&gt;double&lt;/code&gt; 변수를 정렬 하면 더 많은 메모리를 사용하여 펜티엄에서 더 빠르게 실행되는 코드가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="8f446d353bc1e77fdd352360a3275f518dfbc090" translate="yes" xml:space="preserve">
          <source>Control whether GCC aligns &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;long long&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, and &lt;code&gt;long double&lt;/code&gt; variables on a 32-bit boundary (</source>
          <target state="translated">GCC 가 32 비트 경계에서 &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;long&lt;/code&gt; , &lt;code&gt;long long&lt;/code&gt; , &lt;code&gt;float&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; 및 &lt;code&gt;long double&lt;/code&gt; 변수를 정렬할지 여부를 제어합니다 (</target>
        </trans-unit>
        <trans-unit id="75311304fc882ae2426d795d34cedb8140da086e" translate="yes" xml:space="preserve">
          <source>Control whether or not the compiler uses IEEE floating-point comparisons. These correctly handle the case where the result of a comparison is unordered.</source>
          <target state="translated">컴파일러가 IEEE 부동 소수점 비교를 사용할지 여부를 제어합니다. 이것들은 비교 결과가 정렬되지 않은 경우를 올바르게 처리합니다.</target>
        </trans-unit>
        <trans-unit id="62bad428ae7c19b0490d45917456075bd42d88a6" translate="yes" xml:space="preserve">
          <source>Controlling header files and macro definitions. Also, getting dependency information for Make.</source>
          <target state="translated">헤더 파일 및 매크로 정의 제어 또한 Make에 대한 종속성 정보를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="e99744632595e185715acaad17e041aa084fa9ba" translate="yes" xml:space="preserve">
          <source>Controlling how diagnostics should be formatted.</source>
          <target state="translated">진단 형식 지정 방법을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="e7841aeb7ad7a7b2bbd17b2d58521eec5ba1a4f0" translate="yes" xml:space="preserve">
          <source>Controlling the kind of output: an executable, object files, assembler files, or preprocessed source.</source>
          <target state="translated">출력 종류 제어 : 실행 파일, 객체 파일, 어셈블러 파일 또는 사전 처리 된 소스.</target>
        </trans-unit>
        <trans-unit id="c6ecef85f48d8878d76bfb7e0a0331e88e337d9a" translate="yes" xml:space="preserve">
          <source>Controlling the variant of C language compiled.</source>
          <target state="translated">컴파일 된 C 언어의 변형 제어</target>
        </trans-unit>
        <trans-unit id="35f36b715e771eac424fea4a5652ad0db1feb811" translate="yes" xml:space="preserve">
          <source>Controls optimization dumps from various optimization passes. If the &amp;lsquo;</source>
          <target state="translated">다양한 최적화 단계에서 최적화 덤프를 제어합니다. '</target>
        </trans-unit>
        <trans-unit id="eae41d379a4cfbab73e910f93e19e6f3bad5167f" translate="yes" xml:space="preserve">
          <source>Controls whether TLS variables may be accessed with offsets from the TLS segment register (&lt;code&gt;%gs&lt;/code&gt; for 32-bit, &lt;code&gt;%fs&lt;/code&gt; for 64-bit), or whether the thread base pointer must be added. Whether or not this is valid depends on the operating system, and whether it maps the segment to cover the entire TLS area.</source>
          <target state="translated">TLS 세그먼트 레지스터에서 오프셋을 사용하여 TLS 변수에 액세스 할 수 있는지 ( 32 비트의 경우 &lt;code&gt;%fs&lt;/code&gt; &lt;code&gt;%gs&lt;/code&gt; , 64 비트의 경우 % fs ) 또는 스레드 기본 포인터를 추가해야하는지 여부를 제어합니다. 이것이 유효한지 여부는 운영 체제 및 전체 TLS 영역을 커버하도록 세그먼트를 맵핑하는지 여부에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="eb9ef4e6ab162f6fc8a3bf857fc774382a954629" translate="yes" xml:space="preserve">
          <source>Conversely, &lt;code&gt;bar&lt;/code&gt; and the call to &lt;code&gt;foo&lt;/code&gt; in the fourth marked line are used in contexts that do depend on the type of &lt;code&gt;T&lt;/code&gt;, so they are only looked up at the point of instantiation, and you can provide declarations for them after declaring the template, but before instantiating it. In particular, if you instantiate &lt;code&gt;A::f&amp;lt;int&amp;gt;&lt;/code&gt;, the last line will call an overloaded &lt;code&gt;::foo(int)&lt;/code&gt; if one was provided, even if after the declaration of &lt;code&gt;struct A&lt;/code&gt;.</source>
          <target state="translated">반대로, 네 번째 표시된 줄에서 &lt;code&gt;bar&lt;/code&gt; 및 &lt;code&gt;foo&lt;/code&gt; 호출 은 &lt;code&gt;T&lt;/code&gt; 유형에 따라 달라지는 컨텍스트에서 사용 되므로 인스턴스화 시점에서만 조회되므로 템플릿을 선언 한 후 선언을 제공 할 수 있습니다. 그러나 인스턴스화하기 전에. 특히 &lt;code&gt;A::f&amp;lt;int&amp;gt;&lt;/code&gt; 를 인스턴스화 하면 &lt;code&gt;struct A&lt;/code&gt; 선언 후라도 마지막 행은 과부하 된 &lt;code&gt;::foo(int)&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="1dbc54a6ca4a64275cd12138ea70589c4f463e73" translate="yes" xml:space="preserve">
          <source>Conversely, if the register is a call-clobbered register, making calls to functions that use standard ABI may lose contents of the variable. Such calls may be created by the compiler even if none are evident in the original program, for example when libgcc functions are used to make up for unavailable instructions.</source>
          <target state="translated">반대로 레지스터가 콜 클로버 레지스터 인 경우 표준 ABI를 사용하는 함수를 호출하면 변수의 내용이 손실 될 수 있습니다. 이러한 호출은 원래 프로그램에 명백하지 않은 경우에도 (예 : libgcc 함수를 사용하여 사용할 수없는 명령어를 보충하는 경우) 컴파일러에서 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff7d2b7b709500e425e46256b872f1c524a8fe88" translate="yes" xml:space="preserve">
          <source>Conversely, when you include the same header file in a main source file that declares it as &amp;lsquo;</source>
          <target state="translated">반대로, 동일한 헤더 파일을 기본 소스 파일에 포함하면 '</target>
        </trans-unit>
        <trans-unit id="f8292e36ff2425ba64b2fca8bba18ef8c5d24cbf" translate="yes" xml:space="preserve">
          <source>Conversion from double precision to single precision.</source>
          <target state="translated">배정 밀도에서 단 정밀도로 변환</target>
        </trans-unit>
        <trans-unit id="e8f87ba256340926897664cced7edc0ce8ec124d" translate="yes" xml:space="preserve">
          <source>Conversion from floating point to signed or unsigned integer types, with truncation towards zero.</source>
          <target state="translated">부동 소수점에서 부호있는 또는 부호없는 정수 유형으로 변환 (잘림이 0을 향함)</target>
        </trans-unit>
        <trans-unit id="e8ec2eea2629558824283e676ad9bac71b3d3e53" translate="yes" xml:space="preserve">
          <source>Conversion from signed or unsigned integer types to floating-point types.</source>
          <target state="translated">부호있는 또는 부호없는 정수 유형에서 부동 소수점 유형으로 변환</target>
        </trans-unit>
        <trans-unit id="416cd3e7b0ad0f46f99e977b880dc368db1cdff8" translate="yes" xml:space="preserve">
          <source>Conversion from single precision to double precision.</source>
          <target state="translated">단 정도에서 배정도로 변환</target>
        </trans-unit>
        <trans-unit id="0fc5b8691f90f80b04961e22033d17dee1964933" translate="yes" xml:space="preserve">
          <source>Conversion from single-precision floating point to signed integer, rounding to the nearest integer and ties away from zero. This corresponds to the &lt;code&gt;__builtin_lroundf&lt;/code&gt; function when</source>
          <target state="translated">단 정밀도 부동 소수점에서 부호있는 정수로 변환하여 가장 가까운 정수로 반올림하고 0에서 멀어지게합니다. 이것은 &lt;code&gt;__builtin_lroundf&lt;/code&gt; 함수에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="536e910ea0e856f9ebf3793f69bec672bb95cd2c" translate="yes" xml:space="preserve">
          <source>Conversions by prototypes between fixed/floating-point values and vice versa. The absence of these prototypes when compiling with traditional C causes serious problems. This is a subset of the possible conversion warnings; for the full set use</source>
          <target state="translated">고정 소수점 / 부동 소수점 값 간의 프로토 타입 변환 및 그 반대로 변환 기존 C로 컴파일 할 때 이러한 프로토 타입이 없으면 심각한 문제가 발생합니다. 이것은 가능한 변환 경고의 일부입니다. 전 세트 사용</target>
        </trans-unit>
        <trans-unit id="0912352accd4bfa1711e2febca470cb4f85bbc4c" translate="yes" xml:space="preserve">
          <source>Conversions:</source>
          <target state="translated">Conversions:</target>
        </trans-unit>
        <trans-unit id="baf1df2f34189a80f5d58da24bff382fe6f23f9c" translate="yes" xml:space="preserve">
          <source>Convert a 128-bit IEEE floating point value to &lt;code&gt;double&lt;/code&gt; using round to odd as the rounding mode.</source>
          <target state="translated">반올림 모드로 반올림을 사용하여 128 비트 IEEE 부동 소수점 값을 &lt;code&gt;double&lt;/code&gt; 변환 하십시오.</target>
        </trans-unit>
        <trans-unit id="c5f6051eea145ce2adef0c8027dd705cfcc7007e" translate="yes" xml:space="preserve">
          <source>Convert function return with &lt;var&gt;choice&lt;/var&gt;. The default is &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;choice&lt;/var&gt; 함수 리턴을 변환하십시오 . 기본값은 '</target>
        </trans-unit>
        <trans-unit id="454c8084600f90536a1954e8c20d848d81c823ed" translate="yes" xml:space="preserve">
          <source>Convert indirect call and jump with &lt;var&gt;choice&lt;/var&gt;. The default is &amp;lsquo;</source>
          <target state="translated">간접 전화를 변환하고 &lt;var&gt;choice&lt;/var&gt; . 기본값은 '</target>
        </trans-unit>
        <trans-unit id="e6098cfb721df754afe96180a874c8cc3a1a8ded" translate="yes" xml:space="preserve">
          <source>Convert pair lower to single (&lt;code&gt;cvt.s.pl&lt;/code&gt;).</source>
          <target state="translated">쌍을 단일로 변환하십시오 ( &lt;code&gt;cvt.s.pl&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="52f3ab191bdd722d1394008161cded401dd949a0" translate="yes" xml:space="preserve">
          <source>Convert pair to paired single (&lt;code&gt;cvt.ps.s&lt;/code&gt;).</source>
          <target state="translated">페어를 페어 드 싱글 ( &lt;code&gt;cvt.ps.s&lt;/code&gt; )로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="dbfe6d8e23313dd7f9196c8cdcc1c08381a49c43" translate="yes" xml:space="preserve">
          <source>Convert pair upper to single (&lt;code&gt;cvt.s.pu&lt;/code&gt;).</source>
          <target state="translated">pair upper를 single로 변환하십시오 ( &lt;code&gt;cvt.s.pu&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="055bbf265923b2e5410a5e939d7297c0c9f2b211" translate="yes" xml:space="preserve">
          <source>Convert paired single to paired word (&lt;code&gt;cvt.pw.ps&lt;/code&gt;).</source>
          <target state="translated">쌍을 이루는 단일 단어를 쌍을 이루는 단어로 변환하십시오 ( &lt;code&gt;cvt.pw.ps&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="8b6b177ab15aa362100af3868aea344b1c1501b0" translate="yes" xml:space="preserve">
          <source>Convert paired word to paired single (&lt;code&gt;cvt.ps.pw&lt;/code&gt;).</source>
          <target state="translated">짝을 이루는 단어를 짝을 이루는 싱글로 변환하십시오 ( &lt;code&gt;cvt.ps.pw&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="3b04bf1a5e85023c3eed3599d79cb09164690ab2" translate="yes" xml:space="preserve">
          <source>Copy Assignment operators copy virtual bases twice</source>
          <target state="translated">복사 할당 연산자는 가상베이스를 두 번 복사합니다.</target>
        </trans-unit>
        <trans-unit id="d5eae2b9f3ad758ce3ef79fc7015a6ffa9156eac" translate="yes" xml:space="preserve">
          <source>Copyright &amp;copy; 1988-2019 Free Software Foundation, Inc.</source>
          <target state="translated">저작권 &amp;copy; 1988-2019 Free Software Foundation, Inc.</target>
        </trans-unit>
        <trans-unit id="aa5bc69c89234b43d34e0f300cbb8e8580610fdc" translate="yes" xml:space="preserve">
          <source>Core control register class.</source>
          <target state="translated">핵심 제어 레지스터 클래스.</target>
        </trans-unit>
        <trans-unit id="26ed802e7eb78ff2045b4541fe370087376fea5e" translate="yes" xml:space="preserve">
          <source>Cost to assume for a multiply instruction, with &amp;lsquo;</source>
          <target state="translated">곱하기 명령어의 가정 비용은 '</target>
        </trans-unit>
        <trans-unit id="c2ddd3bb796bfb895719a519a79aeec2d836822b" translate="yes" xml:space="preserve">
          <source>Cost, roughly measured as the cost of a single typical machine instruction, at which GCSE optimizations do not constrain the distance an expression can travel. This is currently supported only in the code hoisting pass. The lesser the cost, the more aggressive code hoisting is. Specifying 0 allows all expressions to travel unrestricted distances.</source>
          <target state="translated">GCSE 최적화가 표현식이 이동할 수있는 거리를 제한하지 않는 단일 일반 기계 명령어의 비용으로 대략 측정 된 비용. 이것은 현재 코드 호이 스팅 패스에서만 지원됩니다. 비용이 적을수록 코드 호이 스팅이 더욱 활발해집니다. 0을 지정하면 모든 표현식이 무제한 거리를 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73a8cda37ae16987b1b76b7dd95bcc1d393efb64" translate="yes" xml:space="preserve">
          <source>Create a canonical counter for number of iterations in loops for which determining number of iterations requires complicated analysis. Later optimizations then may determine the number easily. Useful especially in connection with unrolling.</source>
          <target state="translated">반복 횟수를 결정하는 데 복잡한 분석이 필요한 루프의 반복 횟수에 대한 표준 카운터를 만듭니다. 나중에 최적화하면 숫자를 쉽게 결정할 수 있습니다. 언 롤링과 관련하여 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="abd404fec245486ddadc6af0006baee144b9f9b5" translate="yes" xml:space="preserve">
          <source>Create a shared object. It is recommended that</source>
          <target state="translated">공유 객체를 만듭니다. 다음을 권장합니다</target>
        </trans-unit>
        <trans-unit id="f1fd203b49f15a9115d31d7e6edbf2d093ba7de0" translate="yes" xml:space="preserve">
          <source>Create constant pools in the compiler instead of deferring it to the assembler. This option is the default and required for correct code generation on CK801 and CK802, and is optional on other processors.</source>
          <target state="translated">컴파일러에 지연 풀을 지정하지 않고 컴파일러에서 상수 풀을 작성하십시오. 이 옵션은 기본값이며 CK801 및 CK802에서 올바른 코드 생성에 필요하며 다른 프로세서에서는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="b23e0354f5ad5eff5e150918b9120e5576f9697a" translate="yes" xml:space="preserve">
          <source>Create long file names for included source files. For example, if the header file</source>
          <target state="translated">포함 된 소스 파일의 긴 파일 이름을 작성하십시오. 예를 들어 헤더 파일이</target>
        </trans-unit>
        <trans-unit id="e38ae255fe9e80cdce8fdaed0460f9c86fe6b8ba" translate="yes" xml:space="preserve">
          <source>Creates a new &amp;lsquo;</source>
          <target state="translated">새로운 '</target>
        </trans-unit>
        <trans-unit id="99dfbad76db4acc6eb91954940ce7b9993db8870" translate="yes" xml:space="preserve">
          <source>Creates an inter-thread happens-before constraint from the release (or stronger) semantic store to this acquire load. Can prevent hoisting of code to before the operation.</source>
          <target state="translated">릴리스 (또는 더 강한) 시맨틱 저장소에서이 획득로드까지 스레드 간 발생 제한 조건을 작성합니다. 작업 전에 코드를 들어 올리는 것을 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="281a58c77cb45edf43cfdf897384199b4ab0a3ee" translate="yes" xml:space="preserve">
          <source>Creates an inter-thread happens-before constraint to acquire (or stronger) semantic loads that read from this release store. Can prevent sinking of code to after the operation.</source>
          <target state="translated">이 릴리스 저장소에서 읽은 의미로드를 획득하기 위해 스레드 간 발생 제한 조건을 작성합니다. 작업 후 코드가 싱킹되는 것을 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67ae8f8fb8bba8ab92d3a89b17a6600fa05951e3" translate="yes" xml:space="preserve">
          <source>Creates and defines a register class. These register classes can be used by inline &lt;code&gt;asm&lt;/code&gt; constructs. &lt;var&gt;registers&lt;/var&gt; may be a single register, register range separated by ellipses, or comma-separated list of those. Example:</source>
          <target state="translated">레지스터 클래스를 작성하고 정의합니다. 이 레지스터 클래스는 인라인 &lt;code&gt;asm&lt;/code&gt; 구문 으로 사용할 수 있습니다 . &lt;var&gt;registers&lt;/var&gt; 는 단일 레지스터, 타원으로 구분 된 레지스터 범위 또는 쉼표로 구분 된 목록 일 수 있습니다. 예:</target>
        </trans-unit>
        <trans-unit id="6e67e7d1e719647852b7fdbba193a58bb75ed395" translate="yes" xml:space="preserve">
          <source>Critical functions disable interrupts upon entry and restore the previous interrupt state upon exit. Critical functions cannot also have the &lt;code&gt;naked&lt;/code&gt;, &lt;code&gt;reentrant&lt;/code&gt; or &lt;code&gt;interrupt&lt;/code&gt; attributes.</source>
          <target state="translated">중요한 기능은 진입시 인터럽트를 비활성화하고 종료시 이전 인터럽트 상태를 복원합니다. 중요한 함수는 &lt;code&gt;naked&lt;/code&gt; , &lt;code&gt;reentrant&lt;/code&gt; 또는 &lt;code&gt;interrupt&lt;/code&gt; 속성을 가질 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c3cb5c6e6c93496c35c07eb658977d77e8d997f1" translate="yes" xml:space="preserve">
          <source>Current argument is the name of a library or startup file of some sort. Search for that file in a standard list of directories and substitute the full name found. The current working directory is included in the list of directories scanned.</source>
          <target state="translated">현재 인수는 일종의 라이브러리 또는 시작 파일 이름입니다. 표준 디렉토리 목록에서 해당 파일을 검색하고 찾은 전체 이름으로 대체하십시오. 현재 작업 디렉토리가 스캔 된 디렉토리 목록에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="27ed6e70669ea07173e0ff90384757c33382fb6e" translate="yes" xml:space="preserve">
          <source>Current argument is the name of a linker script. Search for that file in the current list of directories to scan for libraries. If the file is located insert a</source>
          <target state="translated">현재 인수는 링커 스크립트의 이름입니다. 라이브러리를 스캔 할 현재 디렉토리 목록에서 해당 파일을 검색하십시오. 파일이있는 경우</target>
        </trans-unit>
        <trans-unit id="318f590d6974d7ec1e4d3da7f86481fca68df621" translate="yes" xml:space="preserve">
          <source>Current gcov-tool supports the following functionalities:</source>
          <target state="translated">현재 gcov-tool은 다음 기능을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="883949fd66aefc2f68b17e769896d2b8ef7a23bf" translate="yes" xml:space="preserve">
          <source>Currently the x86 GNU/Linux target provides an implementation based on Intel Control-flow Enforcement Technology (CET).</source>
          <target state="translated">현재 x86 GNU / Linux 대상은 Intel CET (Control-flow Enforcement Technology) 기반 구현을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4e2c32ee916d61bb5fb82fcf33fd745d76fa8899" translate="yes" xml:space="preserve">
          <source>Currently this feature only works for</source>
          <target state="translated">현재이 기능은</target>
        </trans-unit>
        <trans-unit id="0990f74b9abadf3ef16d92f66dc8a33347d7b30f" translate="yes" xml:space="preserve">
          <source>Currently, ARM and AArch64 back ends do not support ACLE 2.0 fully. Both back ends support CRC32 intrinsics and the ARM back end supports the Coprocessor intrinsics, all from</source>
          <target state="translated">현재 ARM 및 AArch64 백엔드는 ACLE 2.0을 완전히 지원하지 않습니다. 두 백엔드는 모두 CRC32 내장 함수를 지원하고 ARM 백엔드는 보조 프로세서 내장 함수를 모두 지원합니다.</target>
        </trans-unit>
        <trans-unit id="31736ea72fe4084b8c34c06d50c0f1b2816826be" translate="yes" xml:space="preserve">
          <source>Currently, GCC defines &lt;code&gt;__STDC__&lt;/code&gt; unconditionally. This provides good results in practice.</source>
          <target state="translated">현재 GCC는 &lt;code&gt;__STDC__&lt;/code&gt; 를 무조건 정의합니다 . 이것은 실제로 좋은 결과를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2f63ff4fabd516030a0097fd6f4d244c1efad6e8" translate="yes" xml:space="preserve">
          <source>Currently, the attribute is ignored for inlined functions. If the attribute is applied to a symbol &lt;em&gt;definition&lt;/em&gt;, an error is reported. If a symbol previously declared &lt;code&gt;dllimport&lt;/code&gt; is later defined, the attribute is ignored in subsequent references, and a warning is emitted. The attribute is also overridden by a subsequent declaration as &lt;code&gt;dllexport&lt;/code&gt;.</source>
          <target state="translated">현재 인라인 함수의 경우 속성이 무시됩니다. 속성이 기호 &lt;em&gt;정의에&lt;/em&gt; 적용 되면 오류가보고됩니다. 이전에 &lt;code&gt;dllimport&lt;/code&gt; 로 선언 된 기호 가 나중에 정의되면 이후 참조에서 속성이 무시되고 경고가 발생합니다. &lt;code&gt;dllexport&lt;/code&gt; 라는 후속 선언으로 속성이 재정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="590e74950b3a359e45f46ccc033df08293e7e8d0" translate="yes" xml:space="preserve">
          <source>Currently, the preferred dialect makes plain bit-fields signed, because this is simplest. Since &lt;code&gt;int&lt;/code&gt; is the same as &lt;code&gt;signed int&lt;/code&gt; in every other context, it is cleanest for them to be the same in bit-fields as well.</source>
          <target state="translated">현재 선호하는 방언은 일반 비트 필드에 서명을합니다. 이것이 가장 단순하기 때문입니다. &lt;code&gt;int&lt;/code&gt; 는 다른 모든 상황에서 &lt;code&gt;signed int&lt;/code&gt; 와 동일 하기 때문에 비트 필드에서도 동일하게 유지되는 것이 가장 깨끗합니다.</target>
        </trans-unit>
        <trans-unit id="62ab12d09721515fc5fde562eb0862cdc8c3be63" translate="yes" xml:space="preserve">
          <source>Currently, there are two Blackfin-specific built-in functions. These are used for generating &lt;code&gt;CSYNC&lt;/code&gt; and &lt;code&gt;SSYNC&lt;/code&gt; machine insns without using inline assembly; by using these built-in functions the compiler can automatically add workarounds for hardware errata involving these instructions. These functions are named as follows:</source>
          <target state="translated">현재 두 개의 Blackfin 전용 내장 기능이 있습니다. 인라인 어셈블리를 사용하지 않고 &lt;code&gt;CSYNC&lt;/code&gt; 및 &lt;code&gt;SSYNC&lt;/code&gt; 머신 인스 턴 을 생성하는 데 사용됩니다 . 이러한 내장 함수를 사용하여 컴파일러는 이러한 명령어와 관련된 하드웨어 정오표에 대한 해결 방법을 자동으로 추가 할 수 있습니다. 이러한 기능의 이름은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3463fd1fcbee98183382ce3e6bfb37d05534e64b" translate="yes" xml:space="preserve">
          <source>Custom instruction assignments given by individual</source>
          <target state="translated">개인별 맞춤형 교육 과제</target>
        </trans-unit>
        <trans-unit id="f2bc7d2b6265d22c6647e1fcd64c13f072748076" translate="yes" xml:space="preserve">
          <source>D documentation code (Ddoc).</source>
          <target state="translated">D 문서 코드 (Ddoc).</target>
        </trans-unit>
        <trans-unit id="2c7c0a531f3f523f274fda8de9447eb2371b07a9" translate="yes" xml:space="preserve">
          <source>D interface file.</source>
          <target state="translated">D 인터페이스 파일.</target>
        </trans-unit>
        <trans-unit id="6e41c2f41f21895821ff2de4b2b537b418d821df" translate="yes" xml:space="preserve">
          <source>D register</source>
          <target state="translated">D 레지스터</target>
        </trans-unit>
        <trans-unit id="2b608c731b27a1c96a6f8a0e732c2d9673589c56" translate="yes" xml:space="preserve">
          <source>D source code.</source>
          <target state="translated">D 소스 코드.</target>
        </trans-unit>
        <trans-unit id="6e946b779e60851d5c244c3ad74774cbf9f1d48d" translate="yes" xml:space="preserve">
          <source>DD</source>
          <target state="translated">DD</target>
        </trans-unit>
        <trans-unit id="333132be138ba9ace941111a0f174248952df7a1" translate="yes" xml:space="preserve">
          <source>DF</source>
          <target state="translated">DF</target>
        </trans-unit>
        <trans-unit id="53a81edefe355889dccbacb38a4a1453f4e85785" translate="yes" xml:space="preserve">
          <source>DL</source>
          <target state="translated">DL</target>
        </trans-unit>
        <trans-unit id="8fe69de0441ad2ce15deb455eb1d3b4c6713b22c" translate="yes" xml:space="preserve">
          <source>Data file relocation.</source>
          <target state="translated">데이터 파일 재배치</target>
        </trans-unit>
        <trans-unit id="12293b22c91f6b4096277825dea65487973f1c86" translate="yes" xml:space="preserve">
          <source>Data prefetch does not generate faults if &lt;var&gt;addr&lt;/var&gt; is invalid, but the address expression itself must be valid. For example, a prefetch of &lt;code&gt;p-&amp;gt;next&lt;/code&gt; does not fault if &lt;code&gt;p-&amp;gt;next&lt;/code&gt; is not a valid address, but evaluation faults if &lt;code&gt;p&lt;/code&gt; is not a valid address.</source>
          <target state="translated">&lt;var&gt;addr&lt;/var&gt; 가 유효하지 않은 경우 데이터 프리 페치는 결함을 생성하지 않지만 주소 표현식 자체는 유효해야합니다. 예를 들어, 프리 페치 &lt;code&gt;p-&amp;gt;next&lt;/code&gt; 이상 발생하지 않는 &lt;code&gt;p-&amp;gt;next&lt;/code&gt; 경우 유효한 주소 아니지만 평가 결함 &lt;code&gt;p&lt;/code&gt; 유효한 주소 아니다.</target>
        </trans-unit>
        <trans-unit id="c2a93a0b6a01599dcd1bcda6f09bcde290d7a928" translate="yes" xml:space="preserve">
          <source>Data register</source>
          <target state="translated">데이터 레지스터</target>
        </trans-unit>
        <trans-unit id="46a7bcc6b46e84d9b5870e2cd0ac98f1bdb1402e" translate="yes" xml:space="preserve">
          <source>Data register (arbitrary general purpose register)</source>
          <target state="translated">데이터 레지스터 (임의 범용 레지스터)</target>
        </trans-unit>
        <trans-unit id="47be067ca541e17c43e79dffecbcbbad2c9d9a08" translate="yes" xml:space="preserve">
          <source>Data type: &lt;strong id=&quot;index-struct-_005f_005fhtm_005ftdb&quot;&gt;struct __htm_tdb&lt;/strong&gt;</source>
          <target state="translated">데이터 유형 : &lt;strong id=&quot;index-struct-_005f_005fhtm_005ftdb&quot;&gt;struct __htm_tdb&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2310e7e6984f7b9841fe3043d76bb8748b8032aa" translate="yes" xml:space="preserve">
          <source>Data types for complex numbers.</source>
          <target state="translated">복소수에 대한 데이터 유형.</target>
        </trans-unit>
        <trans-unit id="c002fd4f69749774cd614b7282439760b0a132f5" translate="yes" xml:space="preserve">
          <source>Debug dumps can be enabled with a</source>
          <target state="translated">디버그 덤프는</target>
        </trans-unit>
        <trans-unit id="d5a9f22c83f9299405413f6e5e553516a6cf6903" translate="yes" xml:space="preserve">
          <source>Debugging (</source>
          <target state="translated">디버깅</target>
        </trans-unit>
        <trans-unit id="b7b96436cf5229d16fb5897e129a114445f95678" translate="yes" xml:space="preserve">
          <source>Debugging Options</source>
          <target state="translated">디버깅 옵션</target>
        </trans-unit>
        <trans-unit id="aff6d1089cf54da46ac69c2183c78d051d04eff0" translate="yes" xml:space="preserve">
          <source>Decimal Floating Types.</source>
          <target state="translated">십진 부동 유형.</target>
        </trans-unit>
        <trans-unit id="6a66960857760a2cd63559ec52ee94a4a711e705" translate="yes" xml:space="preserve">
          <source>Declarations of external variables and functions within a block apply only to the block containing the declaration. In other words, they have the same scope as any other declaration in the same place.</source>
          <target state="translated">블록 내의 외부 변수 및 함수 선언은 선언을 포함하는 블록에만 적용됩니다. 다시 말해, 같은 장소에있는 다른 선언과 동일한 범위를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="226f69acb8ae88a869e2645962bf30e8ec7e974f" translate="yes" xml:space="preserve">
          <source>Declares the instruction to be commutative for this operand and the following operand. This means that the compiler may interchange the two operands if that is the cheapest way to make all operands fit the constraints. &amp;lsquo;</source>
          <target state="translated">이 피연산자와 다음 피연산자에 대해 명령을 정식으로 선언합니다. 이것은 모든 피연산자가 제약 조건에 맞도록하는 가장 저렴한 방법 인 경우 컴파일러가 두 피연산자를 교환 할 수 있음을 의미합니다. '</target>
        </trans-unit>
        <trans-unit id="6e381a53c21bfca57ae3c6418395aa6805faa3e6" translate="yes" xml:space="preserve">
          <source>Declaring multiple function versions.</source>
          <target state="translated">여러 기능 버전 선언</target>
        </trans-unit>
        <trans-unit id="9df458345b87f143e1443622e3689e81c8f18de5" translate="yes" xml:space="preserve">
          <source>Declaring objects with &lt;code&gt;uncached&lt;/code&gt; allows you to exclude data-cache participation in load and store operations on those objects without involving the additional semantic implications of &lt;code&gt;volatile&lt;/code&gt;. The &lt;code&gt;.di&lt;/code&gt; instruction suffix is used for all loads and stores of data declared &lt;code&gt;uncached&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;uncached&lt;/code&gt; 객체를 선언 하면 &lt;code&gt;volatile&lt;/code&gt; 의 추가 의미 적 의미를 포함하지 않고 해당 객체에 대한로드 및 저장 작업에서 데이터 캐시 참여를 제외 할 수 있습니다 . &lt;code&gt;.di&lt;/code&gt; 명령 접미사는 모든 부하에 사용되며 데이터의 저장 선언 &lt;code&gt;uncached&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dea979b67c132bc175e1957da54321717a0b3e04" translate="yes" xml:space="preserve">
          <source>Declaring that functions have no side effects, or that they can never return.</source>
          <target state="translated">함수에 부작용이 없거나 반환 할 수 없음을 선언합니다.</target>
        </trans-unit>
        <trans-unit id="63030d3cd1e02a687549d142e20f0269121d2b83" translate="yes" xml:space="preserve">
          <source>Declaring the variable</source>
          <target state="translated">변수 선언</target>
        </trans-unit>
        <trans-unit id="b2609010c78f10c37fecace799c32d84a8b0113e" translate="yes" xml:space="preserve">
          <source>Declaring zero-length arrays in other contexts, including as interior members of structure objects or as non-member objects, is discouraged. Accessing elements of zero-length arrays declared in such contexts is undefined and may be diagnosed.</source>
          <target state="translated">구조 객체의 내부 멤버 또는 비 멤버 객체를 포함하여 다른 컨텍스트에서 길이가 0 인 배열을 선언하지 않는 것이 좋습니다. 이러한 맥락에서 선언 된 길이가 0 인 배열의 요소에 액세스하는 것은 정의되어 있지 않으며 진단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0ce91fb53831d435a29b5632774a3c603665597" translate="yes" xml:space="preserve">
          <source>Declaring zero-length arrays is allowed in GNU C as an extension. A zero-length array can be useful as the last element of a structure that is really a header for a variable-length object:</source>
          <target state="translated">길이가 0 인 배열 선언은 GNU C에서 확장으로 허용됩니다. 길이가 0 인 배열은 실제로 가변 길이 객체의 헤더 인 구조의 마지막 요소로 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ccbb003fcbbef0455a040407eca25644a68c8af" translate="yes" xml:space="preserve">
          <source>Default instruction scheduling parameters are used for values that select an architecture and not an implementation. These are &amp;lsquo;</source>
          <target state="translated">기본 명령어 스케줄링 매개 변수는 구현이 아닌 아키텍처를 선택하는 값에 사용됩니다. 이것들은 '</target>
        </trans-unit>
        <trans-unit id="ba9d931a2de4e95a1c6e18f4c96c1c9b9529c7aa" translate="yes" xml:space="preserve">
          <source>Default to 64-bit memory allocation routines.</source>
          <target state="translated">기본적으로 64 비트 메모리 할당 루틴.</target>
        </trans-unit>
        <trans-unit id="bc0e52c70e2e3d40aed76c210b466f12c8a6307d" translate="yes" xml:space="preserve">
          <source>Default visibility corresponds to &amp;ldquo;external linkage&amp;rdquo; in the language.</source>
          <target state="translated">기본 가시성은 언어의 &quot;외부 연결&quot;에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="422c626b9da356260a74af4c444e356b1dff1705" translate="yes" xml:space="preserve">
          <source>Default visibility is the normal case for the object file format. This value is available for the visibility attribute to override other options that may change the assumed visibility of entities.</source>
          <target state="translated">기본 가시성은 객체 파일 형식의 일반적인 경우입니다. 이 값은 가시성 속성이 엔티티의 가정 가시성을 변경시킬 수있는 다른 옵션을 대체하기 위해 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="dcc8364c434a51851187f20fa9cd4e3c3aefb760" translate="yes" xml:space="preserve">
          <source>Define a copy constructor and an assignment operator for classes with dynamically-allocated memory.</source>
          <target state="translated">동적으로 할당 된 메모리가있는 클래스에 대한 복사 생성자와 할당 연산자를 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="5e2f8d06c00c297c0f950f50c2f9216e48b9c380" translate="yes" xml:space="preserve">
          <source>Define additional macros required for using the POSIX threads library. You should use this option consistently for both compilation and linking. This option is supported on GNU/Linux targets, most other Unix derivatives, and also on x86 Cygwin and MinGW targets.</source>
          <target state="translated">POSIX 스레드 라이브러리 사용에 필요한 추가 매크로를 정의하십시오. 이 옵션은 컴파일 및 링크 모두에 일관되게 사용해야합니다. 이 옵션은 GNU / Linux 대상, 대부분의 다른 유닉스 파생물 및 x86 Cygwin 및 MinGW 대상에서도 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="8c097d198bbcce6c15c43b9673925ec2a844aa50" translate="yes" xml:space="preserve">
          <source>Define an argument called &lt;var&gt;key&lt;/var&gt; with a value of &lt;var&gt;value&lt;/var&gt; for the plugin called &lt;var&gt;name&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;name&lt;/var&gt; 이라는 플러그인 의 &lt;var&gt;value&lt;/var&gt; &lt;var&gt;key&lt;/var&gt; 라는 인수를 정의하십시오 .</target>
        </trans-unit>
        <trans-unit id="3b065b864c454ddad2ef2e2ee36967d76b136921" translate="yes" xml:space="preserve">
          <source>Define how many insn groups (cycles) are examined for a dependency on a stalled insn that is a candidate for premature removal from the queue of stalled insns. This has an effect only during the second scheduling pass, and only if</source>
          <target state="translated">지연된 insns의 대기열에서 조기에 제거 할 수있는 지연된 insn에 대한 종속성에 대해 검사되는 insn 그룹 (사이클) 수를 정의하십시오. 이는 두 번째 예약 단계 중에 만 적용되며</target>
        </trans-unit>
        <trans-unit id="d9b9a323e114f08ae98c07403af86c1b8b068b0b" translate="yes" xml:space="preserve">
          <source>Define how many insns (if any) can be moved prematurely from the queue of stalled insns into the ready list during the second scheduling pass.</source>
          <target state="translated">두 번째 예약 단계에서 지연된 insns 대기열에서 준비 목록으로 얼마나 많은 insns (있는 경우)를 조기에 이동할 수 있는지 정의합니다.</target>
        </trans-unit>
        <trans-unit id="b02590046df70d51175d1e6e43007843fa86e90a" translate="yes" xml:space="preserve">
          <source>Defining a register variable does not reserve the register. Other than when invoking the Extended &lt;code&gt;asm&lt;/code&gt;, the contents of the specified register are not guaranteed. For this reason, the following uses are explicitly &lt;em&gt;not&lt;/em&gt; supported. If they appear to work, it is only happenstance, and may stop working as intended due to (seemingly) unrelated changes in surrounding code, or even minor changes in the optimization of a future version of gcc:</source>
          <target state="translated">레지스터 변수를 정의해도 레지스터가 예약되지 않습니다. Extended &lt;code&gt;asm&lt;/code&gt; 을 호출 할 때 외에는 지정된 레지스터의 내용이 보장되지 않습니다. 이러한 이유로 다음 용도는 명시 적으로 지원 &lt;em&gt;되지 않습니다&lt;/em&gt; . 그것들이 작동하는 것처럼 보이는 경우에만 발생하며 주변 코드의 관련없는 변경으로 인해 또는 의도적으로 gcc의 향후 버전 최적화에 대한 약간의 변경으로 인해 의도 한대로 작동하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="827f9d9fc11f005c60202a566cf0397ae86dd11d" translate="yes" xml:space="preserve">
          <source>Defining inline functions (as fast as macros).</source>
          <target state="translated">인라인 함수 정의 (매크로만큼 빠름).</target>
        </trans-unit>
        <trans-unit id="85adcd212de2e338813907851ee4a5662c5f1efc" translate="yes" xml:space="preserve">
          <source>Defining variables residing in specified registers.</source>
          <target state="translated">지정된 레지스터에 상주하는 변수 정의</target>
        </trans-unit>
        <trans-unit id="83ee69015768e1155b22074ebd3a36cc37e95cce" translate="yes" xml:space="preserve">
          <source>Delay execution for &lt;var&gt;ticks&lt;/var&gt; cycles. Note that this built-in does not take into account the effect of interrupts that might increase delay time. &lt;var&gt;ticks&lt;/var&gt; must be a compile-time integer constant; delays with a variable number of cycles are not supported.</source>
          <target state="translated">&lt;var&gt;ticks&lt;/var&gt; 주기 실행 지연 이 내장 기능은 지연 시간을 증가시킬 수있는 인터럽트의 영향을 고려하지 않습니다. &lt;var&gt;ticks&lt;/var&gt; 은 컴파일 타임 정수 상수 여야합니다. 가변주기 수의 지연은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1610d19a0a48226750b3049b914e4786781d22cd" translate="yes" xml:space="preserve">
          <source>Deleting &amp;ldquo;empty&amp;rdquo; loops.</source>
          <target state="translated">&quot;빈&quot;루프를 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="36a3093d26bbd3d1360751144e1efe12aeac3836" translate="yes" xml:space="preserve">
          <source>Depending on the target and how GCC was configured, a slightly different set of optimizations may be enabled at each</source>
          <target state="translated">대상 및 GCC 구성 방법에 따라 각각 약간 씩 다른 최적화 세트를 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="c9892e7a514c42b2b22214f98f72a5abf448bce9" translate="yes" xml:space="preserve">
          <source>Describes the type of hardware multiply supported by the target. Accepted values are &amp;lsquo;</source>
          <target state="translated">대상이 지원하는 하드웨어 유형을 설명합니다. 허용되는 값은 '</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="230a2f1369c19e9bed8580ef0c388abed833d36f" translate="yes" xml:space="preserve">
          <source>Despite the nomenclature, &amp;lsquo;</source>
          <target state="translated">명명법에도 불구하고 '</target>
        </trans-unit>
        <trans-unit id="bd519eb03ed0c213fdab64aa985771c57b8bf1cd" translate="yes" xml:space="preserve">
          <source>Detect floating-point division by zero. Unlike other similar options,</source>
          <target state="translated">부동 소수점 나누기를 0으로 감지합니다. 다른 유사한 옵션과 달리</target>
        </trans-unit>
        <trans-unit id="f275b676db5ca45003e8d7fdde53e395b48ae26a" translate="yes" xml:space="preserve">
          <source>Detect integer division by zero as well as &lt;code&gt;INT_MIN / -1&lt;/code&gt; division.</source>
          <target state="translated">&lt;code&gt;INT_MIN / -1&lt;/code&gt; 나누기 뿐만 아니라 0으로 정수 나누기를 감지하십시오 .</target>
        </trans-unit>
        <trans-unit id="1f073b8e3005614eac7c90dae6865076fed02ebe" translate="yes" xml:space="preserve">
          <source>Detect paths that trigger erroneous or undefined behavior due to a null value being used in a way forbidden by a &lt;code&gt;returns_nonnull&lt;/code&gt; or &lt;code&gt;nonnull&lt;/code&gt; attribute. Isolate those paths from the main control flow and turn the statement with erroneous or undefined behavior into a trap. This is not currently enabled, but may be enabled by</source>
          <target state="translated">&lt;code&gt;returns_nonnull&lt;/code&gt; 또는 &lt;code&gt;nonnull&lt;/code&gt; 특성에 의해 금지 된 방식으로 사용되는 null 값으로 인해 잘못되었거나 정의되지 않은 동작을 트리거하는 경로를 감지 합니다. 이러한 경로를 기본 제어 플로우에서 분리하고 잘못되었거나 정의되지 않은 동작이있는 명령문을 트랩으로 바꾸십시오. 현재 사용하도록 설정되어 있지 않지만</target>
        </trans-unit>
        <trans-unit id="6fd69cb31930da8cd040a4ffab1183319f8c09e1" translate="yes" xml:space="preserve">
          <source>Detect paths that trigger erroneous or undefined behavior due to dereferencing a null pointer. Isolate those paths from the main control flow and turn the statement with erroneous or undefined behavior into a trap. This flag is enabled by default at</source>
          <target state="translated">널 포인터 역 참조로 인해 잘못되었거나 정의되지 않은 동작을 트리거하는 경로를 감지하십시오. 이러한 경로를 기본 제어 플로우에서 분리하고 잘못되었거나 정의되지 않은 동작이있는 명령문을 트랩으로 바꾸십시오. 이 플래그는 기본적으로</target>
        </trans-unit>
        <trans-unit id="b579efc699383256e0ea46438d32e07c0012bfb5" translate="yes" xml:space="preserve">
          <source>Determine the language standard. See &lt;a href=&quot;standards#Standards&quot;&gt;Language Standards Supported by GCC&lt;/a&gt;, for details of these standard versions. This option is currently only supported when compiling C or C++.</source>
          <target state="translated">언어 표준을 결정하십시오. 이러한 표준 버전에 대한 자세한 내용은 &lt;a href=&quot;standards#Standards&quot;&gt;GCC&lt;/a&gt; 에서 지원하는 언어 표준을 참조하십시오 . 이 옵션은 현재 C 또는 C ++를 컴파일 할 때만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="86070f5116cf4fafa20ed47f8a131328fabf7c26" translate="yes" xml:space="preserve">
          <source>Determined by ABI.</source>
          <target state="translated">ABI에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="3673862083301334f396f6717a9c4dfccba740e6" translate="yes" xml:space="preserve">
          <source>Determined by ABI. The options</source>
          <target state="translated">ABI에 의해 결정됩니다. 옵션</target>
        </trans-unit>
        <trans-unit id="95662524b23c122195f82746bb2090bea580b1d6" translate="yes" xml:space="preserve">
          <source>Determining the alignment of a function, type or variable.</source>
          <target state="translated">함수, 유형 또는 변수의 정렬을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="1e53b5ee672acae1a69a324148d3c1bc9485a2b5" translate="yes" xml:space="preserve">
          <source>Developer Options</source>
          <target state="translated">개발자 옵션</target>
        </trans-unit>
        <trans-unit id="76b02b7503c565a218e0634291f3750002ba2b81" translate="yes" xml:space="preserve">
          <source>Devices belonging to &lt;code&gt;avrtiny&lt;/code&gt; and &lt;code&gt;avrxmega3&lt;/code&gt; can access flash memory by means of &lt;code&gt;LD*&lt;/code&gt; instructions because the flash memory is mapped into the RAM address space. There is &lt;em&gt;no need&lt;/em&gt; for language extensions like &lt;code&gt;__flash&lt;/code&gt; or attribute &lt;a href=&quot;variable-attributes#AVR-Variable-Attributes&quot;&gt;&lt;code&gt;progmem&lt;/code&gt;&lt;/a&gt;. The default linker description files for these devices cater for that feature and &lt;code&gt;.rodata&lt;/code&gt; stays in flash: The compiler just generates &lt;code&gt;LD*&lt;/code&gt; instructions, and the linker script adds core specific offsets to all &lt;code&gt;.rodata&lt;/code&gt; symbols: &lt;code&gt;0x4000&lt;/code&gt; in the case of &lt;code&gt;avrtiny&lt;/code&gt; and &lt;code&gt;0x8000&lt;/code&gt; in the case of &lt;code&gt;avrxmega3&lt;/code&gt;. See &lt;a href=&quot;avr-options#AVR-Options&quot;&gt;AVR Options&lt;/a&gt; for a list of respective devices.</source>
          <target state="translated">플래시 메모리가 RAM 주소 공간에 매핑되므로 &lt;code&gt;avrtiny&lt;/code&gt; 및 &lt;code&gt;avrxmega3&lt;/code&gt; 에 속하는 장치 는 &lt;code&gt;LD*&lt;/code&gt; 명령어 를 통해 플래시 메모리에 액세스 할 수 있습니다 . 없습니다 &lt;em&gt;필요&lt;/em&gt; 같은 언어 확장에 대한 &lt;code&gt;__flash&lt;/code&gt; 또는 속성 &lt;a href=&quot;variable-attributes#AVR-Variable-Attributes&quot;&gt; &lt;code&gt;progmem&lt;/code&gt; 은&lt;/a&gt; . 이러한 장치의 기본 링커 설명 파일이 그 기능과 맞추 &lt;code&gt;.rodata&lt;/code&gt; 플래시에서 숙박 : 컴파일러는 생성 &lt;code&gt;LD*&lt;/code&gt; 지시하고, 링커 스크립트는 모든 핵심 특정 오프셋을 추가 &lt;code&gt;.rodata&lt;/code&gt; 심볼 : &lt;code&gt;0x4000&lt;/code&gt; 으로을 의 경우 &lt;code&gt;avrtiny&lt;/code&gt; 및 &lt;code&gt;0x8000&lt;/code&gt; 이 에 ~의 경우에 &lt;code&gt;avrxmega3&lt;/code&gt; . 각 장치 목록은 &lt;a href=&quot;avr-options#AVR-Options&quot;&gt;AVR 옵션&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ce3941724906083a5cbd3b764ac34bb494078fce" translate="yes" xml:space="preserve">
          <source>Diagnostic Message Formatting Options</source>
          <target state="translated">진단 메시지 형식 옵션</target>
        </trans-unit>
        <trans-unit id="3f68058e1e87ea41d8c9d3c7c1f94f8140abe531" translate="yes" xml:space="preserve">
          <source>Diagnostics can have child diagnostics. For example, this error and note:</source>
          <target state="translated">진단에는 어린이 진단이있을 수 있습니다. 예를 들어,이 오류 및 참고 사항 :</target>
        </trans-unit>
        <trans-unit id="f2f5c489e6e2397fb8b9f0a64fb5a021b4c96f8f" translate="yes" xml:space="preserve">
          <source>Diagnostics consist of all the output sent to stderr by GCC.</source>
          <target state="translated">진단은 GCC에 의해 stderr로 전송 된 모든 출력으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="3545c8182bd90d9cc3755c0e6e77d7f64b0e4f2b" translate="yes" xml:space="preserve">
          <source>Different sets of tools are interoperable if they generate files that can be used in the same program. The set of tools includes compilers, assemblers, linkers, libraries, header files, startup files, and debuggers. Binaries produced by different sets of tools are not interoperable unless they implement the same ABI. This applies to different versions of the same tools as well as tools from different vendors.</source>
          <target state="translated">동일한 프로그램에서 사용할 수있는 파일을 생성하는 경우 서로 다른 도구 세트를 상호 운용 할 수 있습니다. 도구 세트에는 컴파일러, 어셈블러, 링커, 라이브러리, 헤더 파일, 시작 파일 및 디버거가 포함됩니다. 서로 다른 도구 세트로 생성 된 바이너리는 동일한 ABI를 구현하지 않으면 상호 운용 할 수 없습니다. 이는 동일한 도구의 다른 버전과 다른 공급 업체의 도구에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="356087678cfa620825af09ad133165c6564b44fe" translate="yes" xml:space="preserve">
          <source>Direct the linker to not merge together strings in the debugging information that are identical in different object files. Merging is not supported by all assemblers or linkers. Merging decreases the size of the debug information in the output file at the cost of increasing link processing time. Merging is enabled by default.</source>
          <target state="translated">링커가 다른 객체 파일에서 동일한 디버깅 정보에서 문자열을 병합하지 않도록 지시합니다. 모든 어셈블러 또는 링커에서 병합을 지원하지는 않습니다. 병합하면 링크 처리 시간이 증가함에 따라 출력 파일의 디버그 정보 크기가 줄어 듭니다. 병합은 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7eb0eda4de9f69bec3e03226fe8296271cfe198f" translate="yes" xml:space="preserve">
          <source>Directories specified with</source>
          <target state="translated">로 지정된 디렉토리</target>
        </trans-unit>
        <trans-unit id="f710acdf8c3a36b577ab367527e400e4e4519a38" translate="yes" xml:space="preserve">
          <source>Directory Options</source>
          <target state="translated">디렉토리 옵션</target>
        </trans-unit>
        <trans-unit id="9a7d4e0687b14e2b7cda406900b802782cd50a62" translate="yes" xml:space="preserve">
          <source>Disable</source>
          <target state="translated">Disable</target>
        </trans-unit>
        <trans-unit id="2d24b1d992d1c4af780c8f9d61b9c942a6314962" translate="yes" xml:space="preserve">
          <source>Disable (do not disable) use of the &lt;code&gt;jal&lt;/code&gt; instruction. Calling functions using &lt;code&gt;jal&lt;/code&gt; is more efficient but requires the caller and callee to be in the same 256 megabyte segment.</source>
          <target state="translated">&lt;code&gt;jal&lt;/code&gt; 명령어 사용을 비활성화 (비활성화하지 않음)합니다 . &lt;code&gt;jal&lt;/code&gt; 을 사용한 호출 기능 은 더 효율적이지만 호출자와 호출 수신자는 동일한 256MB 세그먼트에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="df30c5939a2b24c38598155ef45390b83313cc5d" translate="yes" xml:space="preserve">
          <source>Disable (or enable) optimizations that use the small data section. This may be useful for working around optimizer bugs.</source>
          <target state="translated">작은 데이터 섹션을 사용하는 최적화를 비활성화 (또는 활성화)하십시오. 최적화 프로그램 버그를 해결하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f2ac79b60fc58bb07e366adfa0ca3573c94fc1b" translate="yes" xml:space="preserve">
          <source>Disable (or re-enable) the generation of PC-relative jump instructions.</source>
          <target state="translated">PC 기준 점프 명령 생성을 비활성화 (또는 다시 활성화)하십시오.</target>
        </trans-unit>
        <trans-unit id="e288cae69ca3cd91f647a069f6407394ee8f11c1" translate="yes" xml:space="preserve">
          <source>Disable (or re-enable) the generation of hardware floating point instructions. This option is only significant when the target architecture is &amp;lsquo;</source>
          <target state="translated">하드웨어 부동 소수점 명령어 생성을 비활성화 (또는 다시 활성화)합니다. 이 옵션은 대상 아키텍처가 '</target>
        </trans-unit>
        <trans-unit id="b671582f983bdaa2dca5a8611789524ffa3c4ce1" translate="yes" xml:space="preserve">
          <source>Disable &lt;code&gt;lr&lt;/code&gt; and &lt;code&gt;sr&lt;/code&gt; instructions from using FPX extension aux registers.</source>
          <target state="translated">FPX 확장 보조 레지스터를 사용 하지 않도록 &lt;code&gt;lr&lt;/code&gt; 및 &lt;code&gt;sr&lt;/code&gt; 명령어를 비활성화 합니다 .</target>
        </trans-unit>
        <trans-unit id="c1660e5f22d4c71c2ee4abdaec7f4aef18aa78c9" translate="yes" xml:space="preserve">
          <source>Disable IPA pass &lt;var&gt;pass&lt;/var&gt;. &lt;var&gt;pass&lt;/var&gt; is the pass name. If the same pass is statically invoked in the compiler multiple times, the pass name should be appended with a sequential number starting from 1.</source>
          <target state="translated">IPA 패스 &lt;var&gt;pass&lt;/var&gt; 비활성화합니다 . &lt;var&gt;pass&lt;/var&gt; 는 패스 이름입니다. 동일한 패스가 컴파일러에서 정적으로 여러 번 호출되면 패스 이름에 1부터 시작하는 순차적 번호가 추가되어야합니다.</target>
        </trans-unit>
        <trans-unit id="9d85b585d1d05ada062cacb1bc9babcd262635c5" translate="yes" xml:space="preserve">
          <source>Disable RTL pass &lt;var&gt;pass&lt;/var&gt;. &lt;var&gt;pass&lt;/var&gt; is the pass name. If the same pass is statically invoked in the compiler multiple times, the pass name should be appended with a sequential number starting from 1. &lt;var&gt;range-list&lt;/var&gt; is a comma-separated list of function ranges or assembler names. Each range is a number pair separated by a colon. The range is inclusive in both ends. If the range is trivial, the number pair can be simplified as a single number. If the function&amp;rsquo;s call graph node&amp;rsquo;s &lt;var&gt;uid&lt;/var&gt; falls within one of the specified ranges, the &lt;var&gt;pass&lt;/var&gt; is disabled for that function. The &lt;var&gt;uid&lt;/var&gt; is shown in the function header of a dump file, and the pass names can be dumped by using option</source>
          <target state="translated">RTL 패스 &lt;var&gt;pass&lt;/var&gt; 비활성화합니다 . &lt;var&gt;pass&lt;/var&gt; 는 패스 이름입니다. 동일한 패스가 컴파일러에서 정적으로 여러 번 호출되는 경우 패스 이름에 1부터 시작하는 순차적 번호가 추가되어야합니다. &lt;var&gt;range-list&lt;/var&gt; 는 쉼표로 구분 된 함수 범위 또는 어셈블러 이름 목록입니다. 각 범위는 콜론으로 구분 된 숫자 쌍입니다. 범위는 양쪽 끝을 포함합니다. 범위가 사소한 경우 숫자 쌍을 단일 숫자로 단순화 할 수 있습니다. 함수의 호출 그래프 노드의 &lt;var&gt;uid&lt;/var&gt; 가 지정된 범위 중 하나에 속하면 해당 함수에 대한 &lt;var&gt;pass&lt;/var&gt; 가 비활성화됩니다. &lt;var&gt;uid&lt;/var&gt; 덤프 파일의 함수 헤더에 표시되고, 통과 이름이 옵션을 사용하여 덤프 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="7472182885a7c5023818095d70ccee0a1003a982" translate="yes" xml:space="preserve">
          <source>Disable Wpedantic warnings about constructs used in MFC, such as implicit int and getting a pointer to member function via non-standard syntax.</source>
          <target state="translated">암시 적 int 및 비표준 구문을 통해 멤버 함수에 대한 포인터 가져 오기와 같이 MFC에 사용 된 구문에 대한 Wpedantic 경고를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="d634773489054e3f820c752b2fe8a75da7d7b819" translate="yes" xml:space="preserve">
          <source>Disable all estimate instructions, equivalent to</source>
          <target state="translated">모든 추정 명령을 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="24c834ead83a4d1ebc3aa24aef6d4685246dfacb" translate="yes" xml:space="preserve">
          <source>Disable any machine-specific peephole optimizations. The difference between</source>
          <target state="translated">기계 별 들여다 보는 구멍 최적화를 비활성화하십시오. 차이점</target>
        </trans-unit>
        <trans-unit id="dd10c462b4994eb3982bf5bd6da47ab31464aa34" translate="yes" xml:space="preserve">
          <source>Disable built-in declarations of functions that are not mandated by ANSI/ISO C. These include &lt;code&gt;ffs&lt;/code&gt;, &lt;code&gt;alloca&lt;/code&gt;, &lt;code&gt;_exit&lt;/code&gt;, &lt;code&gt;index&lt;/code&gt;, &lt;code&gt;bzero&lt;/code&gt;, &lt;code&gt;conjf&lt;/code&gt;, and other related functions.</source>
          <target state="translated">ANSI / ISO C에서 요구하지 않는 내장 함수 선언을 비활성화합니다. 여기에는 &lt;code&gt;ffs&lt;/code&gt; , &lt;code&gt;alloca&lt;/code&gt; , &lt;code&gt;_exit&lt;/code&gt; , &lt;code&gt;index&lt;/code&gt; , &lt;code&gt;bzero&lt;/code&gt; , &lt;code&gt;conjf&lt;/code&gt; 및 기타 관련 함수가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="e02b6f324995da402dd843cdd3b4c4bea9e780ea" translate="yes" xml:space="preserve">
          <source>Disable compilation effects of</source>
          <target state="translated">의 컴파일 효과 비활성화</target>
        </trans-unit>
        <trans-unit id="4deddc96335abb292813c9ba7387aa150fa39b18" translate="yes" xml:space="preserve">
          <source>Disable compiler generated atomic sequences and emit library calls for atomic operations. This is the default if the target is not &lt;code&gt;sh*-*-linux*&lt;/code&gt;.</source>
          <target state="translated">컴파일러에서 생성 한 원자 시퀀스를 비활성화하고 원자 연산을위한 라이브러리 호출을 내 보냅니다. 대상이 &lt;code&gt;sh*-*-linux*&lt;/code&gt; 가 아닌 경우 이것이 기본값 입니다.</target>
        </trans-unit>
        <trans-unit id="e03c896d7744b1b31e15f0be1dc55290d5dd4d98" translate="yes" xml:space="preserve">
          <source>Disable diagnostics that the standard says a compiler does not need to issue. Currently, the only such diagnostic issued by G++ is the one for a name having multiple meanings within a class.</source>
          <target state="translated">표준에서 컴파일러가 실행할 필요가 없다고 진단을 비활성화합니다. 현재, G ++에 의해 발행 된 그러한 진단은 클래스 내에서 여러 의미를 갖는 이름에 대한 것입니다.</target>
        </trans-unit>
        <trans-unit id="15a8077f24c55fd5c21ad0119861505db428aa18" translate="yes" xml:space="preserve">
          <source>Disable generation of &lt;code&gt;bcnz&lt;/code&gt; instructions.</source>
          <target state="translated">&lt;code&gt;bcnz&lt;/code&gt; 명령어 생성을 비활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="5286938aafbdfcae094ead274d86fb0eb12ec590" translate="yes" xml:space="preserve">
          <source>Disable generation of information about every class with virtual functions for use by the C++ run-time type identification features (&lt;code&gt;dynamic_cast&lt;/code&gt; and &lt;code&gt;typeid&lt;/code&gt;). If you don&amp;rsquo;t use those parts of the language, you can save some space by using this flag. Note that exception handling uses the same information, but G++ generates it as needed. The &lt;code&gt;dynamic_cast&lt;/code&gt; operator can still be used for casts that do not require run-time type information, i.e. casts to &lt;code&gt;void *&lt;/code&gt; or to unambiguous base classes.</source>
          <target state="translated">C ++ 런타임 유형 식별 기능 ( &lt;code&gt;dynamic_cast&lt;/code&gt; 및 &lt;code&gt;typeid&lt;/code&gt; ) 에서 사용할 가상 함수를 사용하여 모든 클래스에 대한 정보 생성을 사용하지 않도록 설정하십시오 . 해당 언어 부분을 사용하지 않으면이 플래그를 사용하여 공간을 절약 할 수 있습니다. 예외 처리는 동일한 정보를 사용하지만 G ++는 필요에 따라 정보를 생성합니다. &lt;code&gt;dynamic_cast&lt;/code&gt; 는의 연산자는 여전히에, 즉 캐스트 실행시의 형태 정보를 필요로하지 않는 캐스트에 사용할 수 있습니다 &lt;code&gt;void *&lt;/code&gt; 또는 명확한 기본 클래스에.</target>
        </trans-unit>
        <trans-unit id="2c5d893b2d5daa4c819c5a8197085e49914249d8" translate="yes" xml:space="preserve">
          <source>Disable global interrupt.</source>
          <target state="translated">글로벌 인터럽트를 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="5c285b2217d4516708f07171dfd66ed9be6d9834" translate="yes" xml:space="preserve">
          <source>Disable instruction scheduling across basic blocks, which is normally enabled when scheduling before register allocation, i.e. with</source>
          <target state="translated">레지스터 할당 전에 스케줄링 할 때 일반적으로 활성화되는 기본 블록에서 명령어 스케줄링을 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="0e98c6ae6e073a4473bf45d5938dfbe138a13b1c" translate="yes" xml:space="preserve">
          <source>Disable interprocedural optimizations between the function with this attribute and its callers, as if the body of the function is not available when optimizing callers and the callers are unavailable when optimizing the body. This attribute implies &lt;code&gt;noinline&lt;/code&gt;, &lt;code&gt;noclone&lt;/code&gt; and &lt;code&gt;no_icf&lt;/code&gt; attributes. However, this attribute is not equivalent to a combination of other attributes, because its purpose is to suppress existing and future optimizations employing interprocedural analysis, including those that do not have an attribute suitable for disabling them individually. This attribute is supported mainly for the purpose of testing the compiler.</source>
          <target state="translated">호출자를 최적화 할 때 함수 본문을 사용할 수없고 본문을 최적화 할 때 호출자를 사용할 수없는 것처럼이 속성을 가진 함수와 호출자간에 프로 시저 간 최적화를 비활성화하십시오. 이 속성은 &lt;code&gt;noinline&lt;/code&gt; , &lt;code&gt;noclone&lt;/code&gt; 및 &lt;code&gt;no_icf&lt;/code&gt; 속성을 의미 합니다. 그러나이 속성은 다른 속성의 조합과 동일하지 않습니다. 그 목적은 개별적으로 비활성화하기에 적합한 속성이없는 것을 포함하여 절차 간 분석을 사용하는 기존 및 미래의 최적화를 억제하는 것입니다. 이 속성은 주로 컴파일러 테스트를 위해 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="c37151a8e5f5341e877c6066a7b31e954ab243b6" translate="yes" xml:space="preserve">
          <source>Disable lazy binding of function calls. This option is the default and is defined for compatibility with Diab.</source>
          <target state="translated">함수 호출의 지연 바인딩을 비활성화합니다. 이 옵션은 기본값이며 Diab와의 호환성을 위해 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="79f399771b0bd71907b7340d736452ada0291344" translate="yes" xml:space="preserve">
          <source>Disable linking effects of</source>
          <target state="translated">의 연결 효과 비활성화</target>
        </trans-unit>
        <trans-unit id="609817ad0deecdec8c6b793819e36a0c5e4631a2" translate="yes" xml:space="preserve">
          <source>Disable nested conditional execution optimizations.</source>
          <target state="translated">중첩 된 조건부 실행 최적화를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="252fe391b1a4b9d960215788262ee75bfd6c19f6" translate="yes" xml:space="preserve">
          <source>Disable optimization of &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; in conditional execution.</source>
          <target state="translated">&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 및 &lt;code&gt;||&lt;/code&gt; 최적화 비활성화 조건부 실행.</target>
        </trans-unit>
        <trans-unit id="161926f247c9f892e24d049743fa9253ac876603" translate="yes" xml:space="preserve">
          <source>Disable sharing of stack slots allocated for pseudo-registers. Each pseudo-register that does not get a hard register gets a separate stack slot, and as a result function stack frames are larger.</source>
          <target state="translated">의사 레지스터에 할당 된 스택 슬롯 공유를 비활성화합니다. 하드 레지스터를 얻지 못하는 각각의 의사 레지스터는 별도의 스택 슬롯을 얻으므로 결과적으로 스택 프레임이 더 큽니다.</target>
        </trans-unit>
        <trans-unit id="c4a9a68d37ad2c1a1ec5ead44b9d2a2ec4d10976" translate="yes" xml:space="preserve">
          <source>Disable sharing of stack slots used for saving call-used hard registers living through a call. Each hard register gets a separate stack slot, and as a result function stack frames are larger.</source>
          <target state="translated">통화를 통해 존재하는 통화 사용 하드 레지스터를 저장하는 데 사용되는 스택 슬롯 공유를 비활성화합니다. 각 하드 레지스터는 별도의 스택 슬롯을 가지며 결과적으로 스택 프레임이 더 큽니다.</target>
        </trans-unit>
        <trans-unit id="64d3adeb52b81d55606f0c9f79019d7885ab8d8f" translate="yes" xml:space="preserve">
          <source>Disable speculative motion of non-load instructions, which is normally enabled when scheduling before register allocation, i.e. with</source>
          <target state="translated">비로드 명령어의 추론 적 모션을 비활성화합니다. 이는 일반적으로 레지스터 할당 전에 스케줄링 할 때 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="1b9e6a10d7feb88af30d21664dcd930d0d3d0e48" translate="yes" xml:space="preserve">
          <source>Disable the ARCompact-specific pass to generate conditional execution instructions.</source>
          <target state="translated">조건부 실행 명령을 생성하려면 ARCompact 특정 패스를 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="e7b7d0aa54600e475f975b3ad94c992870425a43" translate="yes" xml:space="preserve">
          <source>Disable the ARM-state integer division extension.</source>
          <target state="translated">ARM 상태 정수 나누기 확장을 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="9ae205131ae6c1f0b1ad1d6cdc75d88e53999201" translate="yes" xml:space="preserve">
          <source>Disable the Advanced SIMD instructions (does not disable floating point).</source>
          <target state="translated">고급 SIMD 명령어를 비활성화합니다 (부동 소수점은 비활성화하지 않음).</target>
        </trans-unit>
        <trans-unit id="57b7e24dd0dd62653de9bd626e4944fa6899e1dd" translate="yes" xml:space="preserve">
          <source>Disable the DSP extension.</source>
          <target state="translated">DSP 확장을 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="734f786ab444d8f65fc0c46cdddee12bfda3218d" translate="yes" xml:space="preserve">
          <source>Disable the DSP instructions on &amp;lsquo;</source>
          <target state="translated">'에서 DSP 명령어 비활성화</target>
        </trans-unit>
        <trans-unit id="c7d8376c95023cbfb7c660163253089208b34ece" translate="yes" xml:space="preserve">
          <source>Disable the cryptographic extension.</source>
          <target state="translated">암호화 확장 기능을 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="7f3f13b931ffd3d75ba124cd726692f8712aa12e" translate="yes" xml:space="preserve">
          <source>Disable the cryptographic instructions.</source>
          <target state="translated">암호화 지침을 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="354594897b575026e6476d5a01060d1ccbb17336" translate="yes" xml:space="preserve">
          <source>Disable the diagnostic for converting a bound pointer to member function to a plain pointer.</source>
          <target state="translated">바인딩 된 포인터를 멤버 함수로 변환하여 일반 포인터로 변환하는 진단 기능을 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="c0bf355bf048a8a4bc609b141cbb68d7e3532d66" translate="yes" xml:space="preserve">
          <source>Disable the floating-point and Advanced SIMD instructions.</source>
          <target state="translated">부동 소수점 및 고급 SIMD 명령어를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="f50bf78f4ef90550849e16bf00e7f8fd3e26a980" translate="yes" xml:space="preserve">
          <source>Disable the floating-point extension.</source>
          <target state="translated">부동 소수점 확장을 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="04850fd68730a9ccdd397aa31033dbe8ded5b8ec" translate="yes" xml:space="preserve">
          <source>Disable the floating-point extensions.</source>
          <target state="translated">부동 소수점 확장을 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="c08d0916688b59b4478dd3a8a8d551babc61d679" translate="yes" xml:space="preserve">
          <source>Disable the floating-point instructions.</source>
          <target state="translated">부동 소수점 명령어를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="005c34c6f1c2fb8f1d59d1e3c41e0a0a2122f930" translate="yes" xml:space="preserve">
          <source>Disable the floating-point, Advanced SIMD and cryptographic instructions.</source>
          <target state="translated">부동 소수점, 고급 SIMD 및 암호화 명령어를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="9c28f6f627d67c9bbae1a8f36d817bb71ee86b5b" translate="yes" xml:space="preserve">
          <source>Disable the insertion of cache barriers. This is the default setting.</source>
          <target state="translated">캐시 장벽 삽입을 비활성화합니다. 이것이 기본 설정입니다.</target>
        </trans-unit>
        <trans-unit id="f56b2447b6cc6f830b2511a8763a44abd8412f42" translate="yes" xml:space="preserve">
          <source>Disable the optimization pass that scans for opportunities to use &amp;ldquo;decrement and branch&amp;rdquo; instructions on a count register instead of instruction sequences that decrement a register, compare it against zero, and then branch based upon the result. This option is only meaningful on architectures that support such instructions, which include x86, PowerPC, IA-64 and S/390. Note that the</source>
          <target state="translated">레지스터를 감소시키고 0과 비교 한 다음 결과를 기반으로 분기하는 명령어 시퀀스 대신 카운트 레지스터에서 &quot;감소 및 분기&quot;명령어를 사용할 기회를 스캔하는 최적화 패스를 비활성화합니다. 이 옵션은 x86, PowerPC, IA-64 및 S / 390을 포함하여 이러한 명령어를 지원하는 아키텍처에서만 의미가 있습니다. 참고</target>
        </trans-unit>
        <trans-unit id="c15dc65887ffe75f7696788f129ef9f9ee6c4b19" translate="yes" xml:space="preserve">
          <source>Disable the use of conditional execution.</source>
          <target state="translated">조건부 실행 사용을 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="47a29a4761de80ec38be8a0cf5e531389fb7bc55" translate="yes" xml:space="preserve">
          <source>Disable the use of conditional set instructions.</source>
          <target state="translated">조건부 설정 명령어 사용을 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="5cb2b9c6309800d129c0dac9ca4f0d952c4c16ba" translate="yes" xml:space="preserve">
          <source>Disable the use of conditional-move instructions.</source>
          <target state="translated">조건부 이동 명령어 사용을 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="c4ab5898827402073a5b1c951bd92d3ef7f4f26a" translate="yes" xml:space="preserve">
          <source>Disable the warning about a throw-expression that will immediately result in a call to &lt;code&gt;terminate&lt;/code&gt;.</source>
          <target state="translated">throw-expression에 대한 경고를 비활성화하면 즉시 &lt;code&gt;terminate&lt;/code&gt; 호출이 발생 합니다 .</target>
        </trans-unit>
        <trans-unit id="9e916b556b452967e0dcb5e2d11c70ff45829cad" translate="yes" xml:space="preserve">
          <source>Disable the warning about the case when a conversion function converts an object to the same type, to a base class of that type, or to void; such a conversion function will never be called.</source>
          <target state="translated">변환 함수가 객체를 동일한 유형, 해당 유형의 기본 클래스 또는 void로 변환하는 경우에 대한 경고를 비활성화합니다. 이러한 변환 함수는 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="97813576f6a1f168ea49d44405f937b0428780d3" translate="yes" xml:space="preserve">
          <source>Disable transformations and optimizations that assume default floating-point rounding behavior. This is round-to-zero for all floating point to integer conversions, and round-to-nearest for all other arithmetic truncations. This option should be specified for programs that change the FP rounding mode dynamically, or that may be executed with a non-default rounding mode. This option disables constant folding of floating-point expressions at compile time (which may be affected by rounding mode) and arithmetic transformations that are unsafe in the presence of sign-dependent rounding modes.</source>
          <target state="translated">기본 부동 소수점 반올림 동작을 가정하는 변환 및 최적화를 비활성화합니다. 이것은 모든 부동 소수점 대 정수 변환의 경우 0으로 반올림되고 다른 모든 산술 잘림의 경우 가장 가까운 반올림입니다. 이 옵션은 FP 반올림 모드를 동적으로 변경하거나 기본이 아닌 반올림 모드로 실행될 수있는 프로그램에 지정해야합니다. 이 옵션을 사용하면 컴파일시 부동 소수점 식을 계속 접을 수 없으며 (반올림 모드의 영향을받을 수 있음) 부호 종속적 반올림 모드가있을 때 안전하지 않은 산술 변환이 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="fa652af71b1d233eeae7ac973249eb12d16d530a" translate="yes" xml:space="preserve">
          <source>Disable tree pass &lt;var&gt;pass&lt;/var&gt;. See</source>
          <target state="translated">트리 패스 &lt;var&gt;pass&lt;/var&gt; 비활성화합니다 . 보다</target>
        </trans-unit>
        <trans-unit id="c43ef83976903738f93a9dacec55c01d9094fe2c" translate="yes" xml:space="preserve">
          <source>Disable use of the small data area. Variables are put into one of &lt;code&gt;.data&lt;/code&gt;, &lt;code&gt;.bss&lt;/code&gt;, or &lt;code&gt;.rodata&lt;/code&gt; (unless the &lt;code&gt;section&lt;/code&gt; attribute has been specified). This is the default.</source>
          <target state="translated">작은 데이터 영역 사용을 비활성화하십시오. 변수는 &lt;code&gt;.data&lt;/code&gt; , &lt;code&gt;.bss&lt;/code&gt; 또는 &lt;code&gt;.rodata&lt;/code&gt; 중 하나에 저장됩니다 ( &lt;code&gt;section&lt;/code&gt; 속성이 지정 되지 않은 경우). 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="dd6879ec12c29349f77ab51cc9ef664f2b926a46" translate="yes" xml:space="preserve">
          <source>Disable warnings when non-template friend functions are declared within a template. In very old versions of GCC that predate implementation of the ISO standard, declarations such as &amp;lsquo;</source>
          <target state="translated">템플릿이 아닌 친구 기능이 템플릿 내에 선언되면 경고를 비활성화합니다. ISO 표준을 구현하기 이전의 매우 오래된 GCC 버전에서 '</target>
        </trans-unit>
        <trans-unit id="75de5d4a7b64d839362aa8d626128e23f7764239" translate="yes" xml:space="preserve">
          <source>Disabled at level</source>
          <target state="translated">수준에서 비활성화</target>
        </trans-unit>
        <trans-unit id="bf492e44698b816bac566d70d52b5954c19119dd" translate="yes" xml:space="preserve">
          <source>Disabled by default.</source>
          <target state="translated">기본적으로 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="aac880794e7e82b2a88791e338313ba16ba15074" translate="yes" xml:space="preserve">
          <source>Disables all the optional instructions enabled by</source>
          <target state="translated">에 의해 활성화 된 모든 옵션 명령을 비활성화합니다</target>
        </trans-unit>
        <trans-unit id="870d995d131280874dc4cc508b91ef24ce1bb25e" translate="yes" xml:space="preserve">
          <source>Disables the SIMD (but not floating-point) instructions on &amp;lsquo;</source>
          <target state="translated">'에서 SIMD (부동 소수점 제외) 명령어 사용 안함</target>
        </trans-unit>
        <trans-unit id="a27996206286cd961e06403639946454e47385b1" translate="yes" xml:space="preserve">
          <source>Disables the double-precision component of the floating-point instructions on &amp;lsquo;</source>
          <target state="translated">'에서 부동 소수점 명령어의 배정 밀도 구성 요소를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="f08047d7bdf26e21f60892f7f2f9f2faee1af25c" translate="yes" xml:space="preserve">
          <source>Disables the floating-point instructions on &amp;lsquo;</source>
          <target state="translated">'에서 부동 소수점 명령어를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="df9e25965e3555d25ff57722cb18d00af55afb9e" translate="yes" xml:space="preserve">
          <source>Disables warnings about the generation of inefficient code. These warnings can be generated, for example, when compiling code that performs byte-level memory operations on the MAC AE type. The MAC AE has no hardware support for byte-level memory operations, so all byte load/stores must be synthesized from word load/store operations. This is inefficient and a warning is generated to indicate that you should rewrite the code to avoid byte operations, or to target an AE type that has the necessary hardware support. This option disables these warnings.</source>
          <target state="translated">비효율적 인 코드 생성에 대한 경고를 비활성화합니다. 이러한 경고는 예를 들어 MAC AE 유형에서 바이트 수준 메모리 작업을 수행하는 코드를 컴파일 할 때 생성 될 수 있습니다. MAC AE는 바이트 수준 메모리 작업을 하드웨어 적으로 지원하지 않으므로 모든 바이트로드 / 저장은 워드로드 / 저장 작업에서 합성해야합니다. 이는 비효율적이며 바이트 작업을 피하거나 필요한 하드웨어 지원이있는 AE 유형을 대상으로 코드를 다시 작성해야한다는 경고가 생성됩니다. 이 옵션은 이러한 경고를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="8c83476e13772d4a0c7d47269ca8280ee489e48a" translate="yes" xml:space="preserve">
          <source>Disallow using extensions of later DWARF standard version than selected with</source>
          <target state="translated">로 선택된 DWARF 표준 버전의 확장자를 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="48fef3c4f4f198a3fc747aaf4241ba4c8fd572a6" translate="yes" xml:space="preserve">
          <source>Discover read-only, write-only and non-addressable static variables. Enabled by default at</source>
          <target state="translated">읽기 전용, 쓰기 전용 및 주소 지정이 불가능한 정적 변수를 발견하십시오. 에서 기본적으로 활성화</target>
        </trans-unit>
        <trans-unit id="fcb652ea128e958ac5cce84cb6ef8250a1be8fe4" translate="yes" xml:space="preserve">
          <source>Discover which functions are pure or constant. Enabled by default at</source>
          <target state="translated">어떤 함수가 순수하거나 상수인지 확인하십시오. 에서 기본적으로 활성화</target>
        </trans-unit>
        <trans-unit id="a208f773f4cc31e2ce047d428bfcf70af185cc47" translate="yes" xml:space="preserve">
          <source>Discover which static variables do not escape the compilation unit. Enabled by default at</source>
          <target state="translated">컴파일 단위를 벗어나지 않는 정적 변수를 찾으십시오. 에서 기본적으로 활성화</target>
        </trans-unit>
        <trans-unit id="651cd5d45dfead116269d73c1f57b41b4dbd0dc9" translate="yes" xml:space="preserve">
          <source>Dispatching a call to another function.</source>
          <target state="translated">다른 함수에 대한 호출을 전달합니다.</target>
        </trans-unit>
        <trans-unit id="81b470ecff5209cbe640ee9ba4362aba6ca2d2e9" translate="yes" xml:space="preserve">
          <source>Display all of the optimization options supported by the compiler.</source>
          <target state="translated">컴파일러가 지원하는 모든 최적화 옵션을 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="72c8c0bfdf122469f724652953f16cbdb6f10057" translate="yes" xml:space="preserve">
          <source>Display all of the options controlling warning messages produced by the compiler.</source>
          <target state="translated">컴파일러가 생성 한 경고 메시지를 제어하는 ​​모든 옵션을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="aed462cd18dddfb7255b08046613981f43dcc83d" translate="yes" xml:space="preserve">
          <source>Display demangled function names in output. The default is to show mangled function names.</source>
          <target state="translated">출력에 얽힌 함수 이름을 표시합니다. 디폴트는 맹 글링 된 함수 이름을 표시하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="265008e8627ab28c29c4c783e5dfd9614fe2af35" translate="yes" xml:space="preserve">
          <source>Display help about using &lt;code&gt;gcov-dump&lt;/code&gt; (on the standard output), and exit without doing any further processing.</source>
          <target state="translated">표준 출력에서 &lt;code&gt;gcov-dump&lt;/code&gt; 사용에 대한 도움말을 표시 하고 추가 처리없이 종료합니다.</target>
        </trans-unit>
        <trans-unit id="e12fbb96aff9cead22e458e9ec3c8f5e63fa5684" translate="yes" xml:space="preserve">
          <source>Display help about using &lt;code&gt;gcov-tool&lt;/code&gt; (on the standard output), and exit without doing any further processing.</source>
          <target state="translated">&lt;code&gt;gcov-tool&lt;/code&gt; (표준 출력) 사용에 대한 도움말을 표시 하고 추가 처리없이 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="c2a32dd6399128ea64f2e8805722cf5f0f40906c" translate="yes" xml:space="preserve">
          <source>Display help about using &lt;code&gt;gcov&lt;/code&gt; (on the standard output), and exit without doing any further processing.</source>
          <target state="translated">표준 출력에서 &lt;code&gt;gcov&lt;/code&gt; 사용에 대한 도움말을 표시 하고 추가 처리없이 종료합니다.</target>
        </trans-unit>
        <trans-unit id="05abc5bf9b915eda30e5f0fa5412f4d00c71675a" translate="yes" xml:space="preserve">
          <source>Display only those options that are undocumented.</source>
          <target state="translated">문서화되지 않은 옵션 만 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="f03b0f7a546ee49a503453f7975e25ffe065c35f" translate="yes" xml:space="preserve">
          <source>Display options taking an argument that appears after an equal sign in the same continuous piece of text, such as: &amp;lsquo;</source>
          <target state="translated">동일한 연속 텍스트에서 등호 뒤에 나오는 인수를 취하는 표시 옵션 (예 : '</target>
        </trans-unit>
        <trans-unit id="78dd198d091922fefb8d713c3d97e47984a683e2" translate="yes" xml:space="preserve">
          <source>Display options taking an argument that appears as a separate word following the original option, such as: &amp;lsquo;</source>
          <target state="translated">원래 옵션 다음에 별도의 단어로 나타나는 인수를 취하는 표시 옵션 (예 : '</target>
        </trans-unit>
        <trans-unit id="3034576017d5b01854a8c0bd7d19d6bd34b0118e" translate="yes" xml:space="preserve">
          <source>Display target-specific options. Unlike the</source>
          <target state="translated">대상별 옵션을 표시합니다. 달리</target>
        </trans-unit>
        <trans-unit id="344037446b18226df15907aaf4b6b36a2c93c89d" translate="yes" xml:space="preserve">
          <source>Display the &lt;code&gt;gcov-dump&lt;/code&gt; version number (on the standard output), and exit without doing any further processing.</source>
          <target state="translated">디스플레이 &lt;code&gt;gcov-dump&lt;/code&gt; 더 이상의 처리를하지 않고 버전 (표준 출력에) 번호 및 종료.</target>
        </trans-unit>
        <trans-unit id="35cc61bd60aed0586a7ab81a239eee8b50af7443" translate="yes" xml:space="preserve">
          <source>Display the &lt;code&gt;gcov-tool&lt;/code&gt; version number (on the standard output), and exit without doing any further processing.</source>
          <target state="translated">디스플레이 &lt;code&gt;gcov-tool&lt;/code&gt; 더 이상의 처리를하지 않고 버전 (표준 출력에) 번호 및 종료.</target>
        </trans-unit>
        <trans-unit id="b6e074d4004bd50fbdfdcf5bba3331e5f56c291a" translate="yes" xml:space="preserve">
          <source>Display the &lt;code&gt;gcov&lt;/code&gt; version number (on the standard output), and exit without doing any further processing.</source>
          <target state="translated">표준 출력 에서 &lt;code&gt;gcov&lt;/code&gt; 버전 번호를 표시하고 추가 처리없이 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="cef9fe7c4ae3fd66d0616ac76fb1a92ba4cf451e" translate="yes" xml:space="preserve">
          <source>Display the options supported for &lt;var&gt;language&lt;/var&gt;, where &lt;var&gt;language&lt;/var&gt; is the name of one of the languages supported in this version of GCC.</source>
          <target state="translated">&lt;var&gt;language&lt;/var&gt; 에 지원되는 옵션을 표시합니다 . 여기서 &lt;var&gt;language&lt;/var&gt; 는이 GCC 버전에서 지원되는 언어 중 하나의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="9ab2c82abfc8159be6e9fa8d50b69489311c099e" translate="yes" xml:space="preserve">
          <source>Display the options that are common to all languages.</source>
          <target state="translated">모든 언어에 공통적 인 옵션을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="0ec31abb5e51897ba8130f63f01229988bd5728b" translate="yes" xml:space="preserve">
          <source>Display the progress on the standard output.</source>
          <target state="translated">표준 출력에 진행 상황을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="6dbb61eb69b04350133e621d0c73b06d5ccc9c5b" translate="yes" xml:space="preserve">
          <source>Display the values recognized by the</source>
          <target state="translated">에 의해 인식되는 값을 표시</target>
        </trans-unit>
        <trans-unit id="34d093aadfdac161b403733078a63e69c40898c6" translate="yes" xml:space="preserve">
          <source>Display the version number and copyrights of the invoked GCC.</source>
          <target state="translated">호출 된 GCC의 버전 번호와 저작권을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="26dfbbd6de78ea5ea887b6576aa7df3d1cced839" translate="yes" xml:space="preserve">
          <source>Disregard strict standards compliance.</source>
          <target state="translated">엄격한 표준 준수를 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="810ca5fb4bf9b88327a090dfa7228390b8a8933b" translate="yes" xml:space="preserve">
          <source>Distances are measured from the beginning of functions when using the</source>
          <target state="translated">거리는 사용시 기능의 시작부터 측정됩니다</target>
        </trans-unit>
        <trans-unit id="700c5d1f81b1eabfd1898baf4899894e603c6ec2" translate="yes" xml:space="preserve">
          <source>Distinguish between prefix and postfix forms of increment and decrement operators.</source>
          <target state="translated">접두사와 접미사 형식의 증분 및 감소 연산자를 구별합니다.</target>
        </trans-unit>
        <trans-unit id="15d45d388da758d77a316f2815f529d6f4aa8a47" translate="yes" xml:space="preserve">
          <source>Do (don&amp;rsquo;t) generate code that uses the fused multiply/add or multiply/subtract instructions. The default is to use these instructions.</source>
          <target state="translated">융합 곱셈 / 더하기 또는 곱하기 / 빼기 명령어를 사용하는 코드를 생성하지 마십시오. 기본값은이 지침을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="fa3eae74d7b2c9843e7a1a146ef2fdd2dc03d4df" translate="yes" xml:space="preserve">
          <source>Do alignment optimizations for call instructions.</source>
          <target state="translated">통화 지침에 대한 정렬 최적화를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="66402eadff3f8314991b18d5e3fc15f2b633b72a" translate="yes" xml:space="preserve">
          <source>Do not (do) assume that unaligned memory references are handled by the system.</source>
          <target state="translated">정렬되지 않은 메모리 참조가 시스템에 의해 처리된다고 가정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="54f30aa11a7322472ca655cc5794b473a6db2cb4" translate="yes" xml:space="preserve">
          <source>Do not affect the &lt;code&gt;long_call&lt;/code&gt; or &lt;code&gt;short_call&lt;/code&gt; attributes of subsequent functions.</source>
          <target state="translated">후속 함수 의 &lt;code&gt;long_call&lt;/code&gt; 또는 &lt;code&gt;short_call&lt;/code&gt; 속성 에는 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="1d4def84337c056fee739188d13fda579c041fe7" translate="yes" xml:space="preserve">
          <source>Do not align the destination of inlined string operations. This switch reduces code size and improves performance in case the destination is already aligned, but GCC doesn&amp;rsquo;t know about it.</source>
          <target state="translated">인라인 문자열 조작의 대상을 정렬하지 마십시오. 이 스위치는 대상이 이미 정렬되어 있지만 GCC가이를 알지 못하는 경우 코드 크기를 줄이고 성능을 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="0de4bbafb6a75d9a2bf9d1dffc4ce55c0685a9e6" translate="yes" xml:space="preserve">
          <source>Do not allow constant data to be placed in code sections. Additionally, when compiling for ELF object format give all text sections the ELF processor-specific section attribute &lt;code&gt;SHF_ARM_PURECODE&lt;/code&gt;. This option is only available when generating non-pic code for M-profile targets with the MOVT instruction.</source>
          <target state="translated">상수 데이터를 코드 섹션에 배치하지 마십시오. 또한 ELF 객체 형식을 컴파일 할 때 모든 텍스트 섹션에 ELF 프로세서 관련 섹션 속성 &lt;code&gt;SHF_ARM_PURECODE&lt;/code&gt; 를 제공하십시오 . 이 옵션은 MOVT 명령어를 사용하여 M 프로파일 대상에 대해 비 피크 코드를 생성 할 때만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03d8305d540b6aba4d4042404329e432ca465541" translate="yes" xml:space="preserve">
          <source>Do not allow the built-in functions &lt;code&gt;ceil&lt;/code&gt;, &lt;code&gt;floor&lt;/code&gt;, &lt;code&gt;round&lt;/code&gt; and &lt;code&gt;trunc&lt;/code&gt;, and their &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;long
double&lt;/code&gt; variants, to generate code that raises the &amp;ldquo;inexact&amp;rdquo; floating-point exception for noninteger arguments. ISO C99 and C11 allow these functions to raise the &amp;ldquo;inexact&amp;rdquo; exception, but ISO/IEC TS 18661-1:2014, the C bindings to IEEE 754-2008, does not allow these functions to do so.</source>
          <target state="translated">내장 함수 &lt;code&gt;ceil&lt;/code&gt; , &lt;code&gt;floor&lt;/code&gt; , &lt;code&gt;round&lt;/code&gt; 및 &lt;code&gt;trunc&lt;/code&gt; , &lt;code&gt;float&lt;/code&gt; 및 &lt;code&gt;long double&lt;/code&gt; 변형을 허용하여 정수가 아닌 인수에 대해 &quot;inexact&quot;부동 소수점 예외를 발생시키는 코드를 생성 하지 마십시오 . ISO C99 및 C11에서는 이러한 함수가 &quot;inexact&quot;예외를 발생시킬 수 있지만 IEEE 754-2008에 대한 C 바인딩 인 ISO / IEC TS 18661-1 : 2014에서는 이러한 함수를 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f3ff2c5279a75029bc339b07e7530899c9302db8" translate="yes" xml:space="preserve">
          <source>Do not allow the compiler to generate &lt;em&gt;Long Instruction Word&lt;/em&gt; instructions. This option defines the preprocessor macro &lt;code&gt;__NO_LIW__&lt;/code&gt;.</source>
          <target state="translated">컴파일러가 &lt;em&gt;Long Instruction Word&lt;/em&gt; 명령어 를 생성하도록 허용하지 마십시오 . 이 옵션은 전 처리기 매크로 &lt;code&gt;__NO_LIW__&lt;/code&gt; 를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="308fe4eb96a98c640686f8d44a99dca853e4e2bc" translate="yes" xml:space="preserve">
          <source>Do not allow the compiler to generate &lt;em&gt;SETLB&lt;/em&gt; or &lt;em&gt;Lcc&lt;/em&gt; instructions. This option defines the preprocessor macro &lt;code&gt;__NO_SETLB__&lt;/code&gt;.</source>
          <target state="translated">컴파일러가 &lt;em&gt;SETLB&lt;/em&gt; 또는 &lt;em&gt;Lcc&lt;/em&gt; 명령어 를 생성하도록 허용하지 마십시오 . 이 옵션은 전 처리기 매크로 &lt;code&gt;__NO_SETLB__&lt;/code&gt; 를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="c30c06515f3c7a9db38f03e0071054e61d0d6bea" translate="yes" xml:space="preserve">
          <source>Do not apply the &lt;code&gt;longcall&lt;/code&gt; attribute to subsequent function declarations.</source>
          <target state="translated">&lt;code&gt;longcall&lt;/code&gt; 속성을 후속 함수 선언에 적용하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="6c726465b100e603972419cccdc343f480a4a19b" translate="yes" xml:space="preserve">
          <source>Do not assume a large TLS segment when generating thread-local code.</source>
          <target state="translated">스레드 로컬 코드를 생성 할 때 큰 TLS 세그먼트를 가정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="728fc451cc179eebcc18f5c6344c5c0c36dd581d" translate="yes" xml:space="preserve">
          <source>Do not assume that registers saved by the calling function are restored before calling the &lt;code&gt;noreturn&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;noreturn&lt;/code&gt; 기능을 호출하기 전에 호출 기능으로 저장된 레지스터가 복원된다고 가정하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="e33e43a1033f382fce00f6b8091a2ad6b0b4e974" translate="yes" xml:space="preserve">
          <source>Do not assume that the code being compiled won&amp;rsquo;t link against any ID shared libraries. Slower code is generated for jump and call insns.</source>
          <target state="translated">컴파일되는 코드가 ID 공유 라이브러리와 링크되지 않는다고 가정하지 마십시오. 점프 및 호출 함수에 대해 느린 코드가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="91704a7cde69df99e26557a8fcaceedc0c021417" translate="yes" xml:space="preserve">
          <source>Do not assume the width of floating-point registers.</source>
          <target state="translated">부동 소수점 레지스터의 너비를 가정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="56a17068976fe756a1e89e46ec309c06e7526fbb" translate="yes" xml:space="preserve">
          <source>Do not attempt to schedule the preceding instruction into the delay slot of a branch instruction placed at the end of a short loop of six instructions or fewer and always schedule a &lt;code&gt;nop&lt;/code&gt; instruction there instead. The short loop bug under certain conditions causes loops to execute only once or twice, due to a hardware bug in the R5900 chip. The workaround is implemented by the assembler rather than by GCC.</source>
          <target state="translated">6 개 이하의 짧은 루프 끝에 위치한 분기 명령의 지연 슬롯에 선행 명령을 예약하지 말고 항상 &lt;code&gt;nop&lt;/code&gt; 명령을 예약하십시오 . 특정 조건에서 짧은 루프 버그로 인해 R5900 칩의 하드웨어 버그로 인해 루프가 한두 번만 실행됩니다. 해결 방법은 GCC가 아닌 어셈블러에서 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="d2be752bd5c8aabe79c7a8b900f158b404d70833" translate="yes" xml:space="preserve">
          <source>Do not consider type &lt;code&gt;int&lt;/code&gt; to be 16 bits wide. This is the default.</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; 유형 을 16 비트 너비로 간주하지 마십시오 . 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="08c20a0490ee73056523e456a376bd15da68e3f1" translate="yes" xml:space="preserve">
          <source>Do not create the &lt;code&gt;gcov&lt;/code&gt; output file.</source>
          <target state="translated">&lt;code&gt;gcov&lt;/code&gt; 출력 파일을 작성하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="61bd4083e901aa03be2fec075c5a07232b9c93d4" translate="yes" xml:space="preserve">
          <source>Do not discard comments, including during macro expansion. This is like</source>
          <target state="translated">매크로 확장을 포함하여 주석을 버리지 마십시오. 이것은 같다</target>
        </trans-unit>
        <trans-unit id="094e1651c852304b7a16e16ed4d0185ecd59b26b" translate="yes" xml:space="preserve">
          <source>Do not discard comments. All comments are passed through to the output file, except for comments in processed directives, which are deleted along with the directive.</source>
          <target state="translated">주석을 버리지 마십시오. 처리 된 지시문의 주석을 제외한 모든 주석은 출력 파일로 전달되며, 지시문과 함께 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="91b2c99fa330a126f06708c6cdfa9c96a1c2ca48" translate="yes" xml:space="preserve">
          <source>Do not emit instructions with side effects in addressing modes other than post-increment.</source>
          <target state="translated">후행 증가 이외의 어드레싱 모드에서는 부작용이있는 명령어를 방출하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="8e8fcc0f33555f7707b3fe0e2c86d30a856ae4de" translate="yes" xml:space="preserve">
          <source>Do not emit the extra code to use the routines specified in the C++ ABI for thread-safe initialization of local statics. You can use this option to reduce code size slightly in code that doesn&amp;rsquo;t need to be thread-safe.</source>
          <target state="translated">로컬 정적의 스레드 안전 초기화를 위해 C ++ ABI에 지정된 루틴을 사용하기 위해 추가 코드를 생성하지 마십시오. 이 옵션을 사용하면 스레드로부터 안전하지 않아도되는 코드에서 코드 크기를 약간 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a50320f9ab85e604d11edb3fea826b2a1de37844" translate="yes" xml:space="preserve">
          <source>Do not enforce a 32-byte alignment for loops. This is the default.</source>
          <target state="translated">루프에 대해 32 바이트 정렬을 강요하지 마십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="891fab210e7a9b122822bf86387a01881f014d38" translate="yes" xml:space="preserve">
          <source>Do not expand any functions inline apart from those marked with the &lt;code&gt;always_inline&lt;/code&gt; attribute. This is the default when not optimizing.</source>
          <target state="translated">&lt;code&gt;always_inline&lt;/code&gt; 속성으로 표시된 기능 외에 인라인을 확장하지 마십시오 . 최적화하지 않을 때의 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="e55929ae438e9efde315189f7933071caa5c75d9" translate="yes" xml:space="preserve">
          <source>Do not expand any symbolic links, resolve references to &amp;lsquo;</source>
          <target state="translated">기호 링크를 확장하지 말고 '</target>
        </trans-unit>
        <trans-unit id="76bc4e801782e79c379029a2b2d98ead9b1c58f2" translate="yes" xml:space="preserve">
          <source>Do not expect a sequence of &lt;code&gt;asm&lt;/code&gt; statements to remain perfectly consecutive after compilation, even when you are using the &lt;code&gt;volatile&lt;/code&gt; qualifier. If certain instructions need to remain consecutive in the output, put them in a single multi-instruction &lt;code&gt;asm&lt;/code&gt; statement.</source>
          <target state="translated">&lt;code&gt;volatile&lt;/code&gt; 한정자를 사용하는 경우에도 컴파일 후 일련의 &lt;code&gt;asm&lt;/code&gt; 문이 완벽하게 연속적으로 유지 되는 것을 기대하지 마십시오 . 특정 명령이 출력에서 ​​연속적으로 유지되어야하는 경우 단일 다중 명령 &lt;code&gt;asm&lt;/code&gt; 문에 넣으십시오 .</target>
        </trans-unit>
        <trans-unit id="1357d76978b996f4f01f805d2256a79e656aef14" translate="yes" xml:space="preserve">
          <source>Do not expect a sequence of &lt;code&gt;asm&lt;/code&gt; statements to remain perfectly consecutive after compilation. If certain instructions need to remain consecutive in the output, put them in a single multi-instruction &lt;code&gt;asm&lt;/code&gt; statement. Note that GCC&amp;rsquo;s optimizers can move &lt;code&gt;asm&lt;/code&gt; statements relative to other code, including across jumps.</source>
          <target state="translated">컴파일 후 일련의 &lt;code&gt;asm&lt;/code&gt; 문이 완벽하게 연속적으로 유지 될 것으로 기대하지 마십시오 . 특정 명령이 출력에서 ​​연속적으로 유지되어야하는 경우 단일 다중 명령 &lt;code&gt;asm&lt;/code&gt; 문에 넣으십시오 . GCC의 옵티마이 저는 점프를 포함하여 다른 코드와 관련하여 &lt;code&gt;asm&lt;/code&gt; 문을 이동할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="84b3d7d09c0c54d717842f06c98dbd62ec42f930" translate="yes" xml:space="preserve">
          <source>Do not generate 16-bit instructions.</source>
          <target state="translated">16 비트 명령어를 생성하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="ad6e921329e0de0a14badc58726b2429a811f03b" translate="yes" xml:space="preserve">
          <source>Do not generate &lt;code&gt;mpy&lt;/code&gt;-family instructions for ARC700. This option is deprecated.</source>
          <target state="translated">ARC700에 대한 &lt;code&gt;mpy&lt;/code&gt; 제품군 명령어를 생성하지 마십시오 . 이 옵션은 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="677bb296fc46c470e0c30284fe52bf50c8bf95e0" translate="yes" xml:space="preserve">
          <source>Do not generate GP-relative accesses.</source>
          <target state="translated">GP 기준 액세스를 생성하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="f71d5f68821b30e885b1156b06fcb682f984e58f" translate="yes" xml:space="preserve">
          <source>Do not generate code that can only run in supervisor mode. This is relevant only for the &lt;code&gt;casa&lt;/code&gt; instruction emitted for the LEON3 processor. This is the default.</source>
          <target state="translated">감독자 모드에서만 실행할 수있는 코드를 생성하지 마십시오. 이것은 LEON3 프로세서에 대해 방출 된 &lt;code&gt;casa&lt;/code&gt; 명령 에만 해당됩니다 . 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="0295c6ec8a8e0c073456a9cdaa9ef67d389ca72d" translate="yes" xml:space="preserve">
          <source>Do not generate code that reads program memory.</source>
          <target state="translated">프로그램 메모리를 읽는 코드를 생성하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="2a55e3aa2938e0b388b8a2f34ed44323717c2975" translate="yes" xml:space="preserve">
          <source>Do not generate code to avoid bugs in the multiply instructions for the MN10300 processors.</source>
          <target state="translated">MN10300 프로세서에 대한 곱하기 명령어에서 버그를 피하기 위해 코드를 생성하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="6775dd83d160f5e2159511baea19387bf2da721f" translate="yes" xml:space="preserve">
          <source>Do not generate code using features specific to the AM33 processor. This is the default.</source>
          <target state="translated">AM33 프로세서 전용 기능을 사용하여 코드를 생성하지 마십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="159947dfd1a4fc3fd4fb823f295379e5ec4d1e29" translate="yes" xml:space="preserve">
          <source>Do not generate conditional move instructions.</source>
          <target state="translated">조건부 이동 명령을 생성하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="2a7c63697c44693e6c631b03a4bcdf4c623d8e94" translate="yes" xml:space="preserve">
          <source>Do not generate floating-point instructions; use library calls instead. This is the default for 68000, 68010, and 68832 targets. It is also the default for ColdFire devices that have no FPU.</source>
          <target state="translated">부동 소수점 명령어를 생성하지 마십시오. 대신 라이브러리 호출을 사용하십시오. 68000, 68010 및 68832 대상의 기본값입니다. FPU가없는 ColdFire 장비의 기본값이기도합니다.</target>
        </trans-unit>
        <trans-unit id="2cc223b18a9c8fe85db4c5fdd1a4568ac5523351" translate="yes" xml:space="preserve">
          <source>Do not generate inline code for &lt;code&gt;sqrt&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;sqrt&lt;/code&gt; 에 대한 인라인 코드를 생성하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="7dccee88899cb101fdf1122d7b6f87cc5ad98128" translate="yes" xml:space="preserve">
          <source>Do not generate inline code for divides of floating-point values.</source>
          <target state="translated">부동 소수점 값을 나누기 위해 인라인 코드를 생성하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="db0d6f198e71d6a0581c6b52ba5d158f3703dad4" translate="yes" xml:space="preserve">
          <source>Do not generate inline code for divides of integer values.</source>
          <target state="translated">정수 값을 나누기 위해 인라인 코드를 생성하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="5bf145c70d37b823fa320934be3a45f2f5b58879" translate="yes" xml:space="preserve">
          <source>Do not generate performance extension 2 instructions.</source>
          <target state="translated">성능 확장 2 명령어를 생성하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="3b1b47a62d265ff0109bc6fe295c353c7dfbd942" translate="yes" xml:space="preserve">
          <source>Do not generate performance extension instructions.</source>
          <target state="translated">성능 확장 명령어를 생성하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="b028375dbf2397374ef15ae6807634be0bef9937" translate="yes" xml:space="preserve">
          <source>Do not generate sdata references. This is the default for tool chains built for &lt;code&gt;arc-linux-uclibc&lt;/code&gt; and &lt;code&gt;arceb-linux-uclibc&lt;/code&gt; targets.</source>
          <target state="translated">sdata 참조를 생성하지 마십시오. 이는 &lt;code&gt;arc-linux-uclibc&lt;/code&gt; 및 &lt;code&gt;arceb-linux-uclibc&lt;/code&gt; 대상 용으로 빌드 된 툴 체인의 기본값입니다 .</target>
        </trans-unit>
        <trans-unit id="543afe0ee34f2553275fc1e0d4f92ae4d031e11e" translate="yes" xml:space="preserve">
          <source>Do not generate string extension instructions.</source>
          <target state="translated">문자열 확장 명령어를 생성하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="35172dff465f7db05c87cd9d0fa618a5943366ff" translate="yes" xml:space="preserve">
          <source>Do not generate v3 push25/pop25 instructions.</source>
          <target state="translated">v3 push25 / pop25 명령어를 생성하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="57a412ef71d36d080e33196062eae1a348ffd9a5" translate="yes" xml:space="preserve">
          <source>Do not guess branch probabilities using heuristics.</source>
          <target state="translated">휴리스틱을 사용하여 분기 확률을 추측하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="c3b0780d488de79c8fb5609252ace9e026b5485c" translate="yes" xml:space="preserve">
          <source>Do not link in the C run-time initialization object file.</source>
          <target state="translated">C 런타임 초기화 오브젝트 파일에서 링크하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="1be7375d07ff18651b91e6f0b8f72660024d9706" translate="yes" xml:space="preserve">
          <source>Do not mark ABI switches in e_flags.</source>
          <target state="translated">e_flags에 ABI 스위치를 표시하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="431d0ac813eff431a021eadf038696c3b8c0a701" translate="yes" xml:space="preserve">
          <source>Do not optimize (do optimize) basic blocks that use the same index pointer 4 or more times to copy pointer into the &lt;code&gt;ep&lt;/code&gt; register, and use the shorter &lt;code&gt;sld&lt;/code&gt; and &lt;code&gt;sst&lt;/code&gt; instructions. The</source>
          <target state="translated">포인터를 &lt;code&gt;ep&lt;/code&gt; 레지스터 에 복사하기 위해 동일한 인덱스 포인터를 4 번 이상 사용하는 기본 블록을 최적화 (최적화)하지 말고 더 짧은 &lt;code&gt;sld&lt;/code&gt; 및 &lt;code&gt;sst&lt;/code&gt; 명령어를 사용하십시오. 그만큼</target>
        </trans-unit>
        <trans-unit id="79c5f07fbe7818d1561eea80118156e770e03da3" translate="yes" xml:space="preserve">
          <source>Do not optimize block moves, use &lt;code&gt;memcpy&lt;/code&gt;.</source>
          <target state="translated">블록 이동을 최적화하지 말고 &lt;code&gt;memcpy&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="1c81bdb6603f6660bfebcf5b1c10715d6960adf2" translate="yes" xml:space="preserve">
          <source>Do not or do generate unaligned memory accesses. The default is set depending on whether the processor we are optimizing for supports fast unaligned access or not.</source>
          <target state="translated">정렬되지 않은 메모리 액세스를 생성하지 마십시오. 기본값은 최적화하려는 프로세서가 빠른 정렬되지 않은 액세스를 지원하는지 여부에 따라 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="4a89ae960644f6dae44b3cb05c0d0550f4cbdda0" translate="yes" xml:space="preserve">
          <source>Do not output certain jump instructions (&lt;code&gt;aobleq&lt;/code&gt; and so on) that the Unix assembler for the VAX cannot handle across long ranges.</source>
          <target state="translated">VAX 용 Unix 어셈블러가 장거리를 처리 할 수없는 특정 점프 명령 ( &lt;code&gt;aobleq&lt;/code&gt; 등)을 출력하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="f8a3ee3da0c5dc6481bc333868effaef20cfecb3" translate="yes" xml:space="preserve">
          <source>Do not pack VLIW instructions.</source>
          <target state="translated">VLIW 지침을 포장하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="5cf0a2e01f314e50aac688fcc0637765ffe183d2" translate="yes" xml:space="preserve">
          <source>Do not predefine any system-specific or GCC-specific macros. The standard predefined macros remain defined.</source>
          <target state="translated">시스템 특정 또는 GCC 특정 매크로를 미리 정의하지 마십시오. 사전 정의 된 표준 매크로는 정의 된 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="490cb97bfac29c7944f438d394a40917ab27b463" translate="yes" xml:space="preserve">
          <source>Do not print column numbers in diagnostics. This may be necessary if diagnostics are being scanned by a program that does not understand the column numbers, such as &lt;code&gt;dejagnu&lt;/code&gt;.</source>
          <target state="translated">진단시 열 번호를 인쇄하지 마십시오. &lt;code&gt;dejagnu&lt;/code&gt; 와 같은 열 번호를 이해하지 못하는 프로그램이 진단을 스캔하는 경우 필요할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5a166eec1d3e160d989368c024582f88a817fbe4" translate="yes" xml:space="preserve">
          <source>Do not put function addresses in registers; make each instruction that calls a constant function contain the function&amp;rsquo;s address explicitly.</source>
          <target state="translated">기능 주소를 레지스터에 넣지 마십시오. 상수 함수를 호출하는 각 명령어에 함수의 주소가 명시 적으로 포함되도록합니다.</target>
        </trans-unit>
        <trans-unit id="42d099b873c7985f112edf3c200fc2a3b03ec5d0" translate="yes" xml:space="preserve">
          <source>Do not recognize &lt;code&gt;asm&lt;/code&gt;, &lt;code&gt;inline&lt;/code&gt; or &lt;code&gt;typeof&lt;/code&gt; as a keyword, so that code can use these words as identifiers. You can use the keywords &lt;code&gt;__asm__&lt;/code&gt;, &lt;code&gt;__inline__&lt;/code&gt; and &lt;code&gt;__typeof__&lt;/code&gt; instead.</source>
          <target state="translated">코드에서 이러한 단어를 식별자로 사용할 수 있도록 &lt;code&gt;asm&lt;/code&gt; , &lt;code&gt;inline&lt;/code&gt; 또는 &lt;code&gt;typeof&lt;/code&gt; 를 키워드로 인식하지 마십시오 . 대신 &lt;code&gt;__asm__&lt;/code&gt; , &lt;code&gt;__inline__&lt;/code&gt; 및 &lt;code&gt;__typeof__&lt;/code&gt; 키워드를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4748c7a1ef517bb9ba562d1dfbac2e153a84b556" translate="yes" xml:space="preserve">
          <source>Do not recognize &lt;code&gt;typeof&lt;/code&gt; as a keyword, so that code can use this word as an identifier. You can use the keyword &lt;code&gt;__typeof__&lt;/code&gt; instead. This option is implied by the strict ISO C++ dialects:</source>
          <target state="translated">코드에서이 단어를 식별자로 사용할 수 있도록 &lt;code&gt;typeof&lt;/code&gt; 를 키워드로 인식하지 마십시오 . 대신 &lt;code&gt;__typeof__&lt;/code&gt; 키워드를 사용할 수 있습니다 . 이 옵션은 엄격한 ISO C ++ 방언으로 암시됩니다.</target>
        </trans-unit>
        <trans-unit id="0184fc6ad01e42f8636e2c8922ca8fae3a1d46de" translate="yes" xml:space="preserve">
          <source>Do not reorder functions or variables marked &lt;code&gt;no_reorder&lt;/code&gt; against each other or top level assembler statements the executable. The actual order in the program will depend on the linker command line. Static variables marked like this are also not removed. This has a similar effect as the</source>
          <target state="translated">&lt;code&gt;no_reorder&lt;/code&gt; 로 표시된 함수 나 변수 를 서로 재정렬 하거나 최상위 어셈블러에서 실행 파일을 진술 하지 마십시오 . 프로그램의 실제 순서는 링커 명령 줄에 따라 다릅니다. 이와 같이 표시된 정적 변수도 제거되지 않습니다. 이것은</target>
        </trans-unit>
        <trans-unit id="8ddac79842e7bae2915ad838f14a89d8d6021356" translate="yes" xml:space="preserve">
          <source>Do not reorder top-level functions, variables, and &lt;code&gt;asm&lt;/code&gt; statements. Output them in the same order that they appear in the input file. When this option is used, unreferenced static variables are not removed. This option is intended to support existing code that relies on a particular ordering. For new code, it is better to use attributes when possible.</source>
          <target state="translated">최상위 함수, 변수 및 &lt;code&gt;asm&lt;/code&gt; 문을 재정렬하지 마십시오 . 입력 파일에 나타나는 순서대로 출력하십시오. 이 옵션을 사용하면 참조되지 않은 정적 변수는 제거되지 않습니다. 이 옵션은 특정 순서에 의존하는 기존 코드를 지원하기위한 것입니다. 새 코드의 경우 가능하면 속성을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e09f89632800cad3603644ff83e1a579b7e4eb4f" translate="yes" xml:space="preserve">
          <source>Do not run a pass to pack branches into VLIW instructions.</source>
          <target state="translated">분기를 VLIW 지침으로 포장하기 위해 패스를 실행하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="0dba1f61030583d8ab48fd80d73e6a5afaf9d194" translate="yes" xml:space="preserve">
          <source>Do not save registers in &lt;code&gt;main&lt;/code&gt;. The effect is the same like attaching attribute &lt;a href=&quot;avr-function-attributes#AVR-Function-Attributes&quot;&gt;&lt;code&gt;OS_task&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;main&lt;/code&gt;. It is activated per default if optimization is on.</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 레지스터를 저장하지 마십시오 . 결과는 속성 &lt;a href=&quot;avr-function-attributes#AVR-Function-Attributes&quot;&gt; &lt;code&gt;OS_task&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;main&lt;/code&gt; 에 첨부하는 것과 같습니다 . 최적화가 켜져 있으면 기본적으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="9b74c0ce30e69827202932531a3c2d31b17cec32" translate="yes" xml:space="preserve">
          <source>Do not search for header files in the C++-specific standard directories, but do still search the other standard directories. (This option is used when building the C++ library.)</source>
          <target state="translated">C ++ 특정 표준 디렉토리에서 헤더 파일을 검색하지 말고 다른 표준 디렉토리를 계속 검색하십시오. (이 옵션은 C ++ 라이브러리를 빌드 할 때 사용됩니다.)</target>
        </trans-unit>
        <trans-unit id="10d644d96645c398a65f49953416f8df18eac09b" translate="yes" xml:space="preserve">
          <source>Do not search for header files in the standard directories specific to C++, but do still search the other standard directories. (This option is used when building the C++ library.)</source>
          <target state="translated">C ++에 특정한 표준 디렉토리에서 헤더 파일을 검색하지 말고 다른 표준 디렉토리를 계속 검색하십시오. (이 옵션은 C ++ 라이브러리를 빌드 할 때 사용됩니다.)</target>
        </trans-unit>
        <trans-unit id="6ee81949a7a2777f7208e1e6ee75bc8ae9472923" translate="yes" xml:space="preserve">
          <source>Do not search the standard system directories for header files. Only the directories explicitly specified with</source>
          <target state="translated">표준 시스템 디렉토리에서 헤더 파일을 검색하지 마십시오. 로 명시 적으로 지정된 디렉토리 만</target>
        </trans-unit>
        <trans-unit id="eb16433a9f72928c54140581a05d1867ea26ccd7" translate="yes" xml:space="preserve">
          <source>Do not set &lt;code&gt;errno&lt;/code&gt; after calling math functions that are executed with a single instruction, e.g., &lt;code&gt;sqrt&lt;/code&gt;. A program that relies on IEEE exceptions for math error handling may want to use this flag for speed while maintaining IEEE arithmetic compatibility.</source>
          <target state="translated">&lt;code&gt;sqrt&lt;/code&gt; 와 같은 단일 명령어로 실행되는 수학 함수를 호출 한 후 &lt;code&gt;errno&lt;/code&gt; 를 설정하지 마십시오 . 수학 오류 처리를 위해 IEEE 예외에 의존하는 프로그램은 IEEE 산술 호환성을 유지하면서 속도를 위해이 플래그를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20c8d2c68cfa75e481382ec2a217fdac468ae476" translate="yes" xml:space="preserve">
          <source>Do not store floating-point variables in registers, and inhibit other options that might change whether a floating-point value is taken from a register or memory.</source>
          <target state="translated">부동 소수점 변수를 레지스터에 저장하지 말고 부동 소수점 값을 레지스터에서 가져 오는지 또는 메모리에서 가져 오는지를 변경할 수있는 다른 옵션을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="1e223b8f5150edab41b25d5219e57c17c3a59917" translate="yes" xml:space="preserve">
          <source>Do not substitute constants for known return value of formatted output functions such as &lt;code&gt;sprintf&lt;/code&gt;, &lt;code&gt;snprintf&lt;/code&gt;, &lt;code&gt;vsprintf&lt;/code&gt;, and &lt;code&gt;vsnprintf&lt;/code&gt; (but not &lt;code&gt;printf&lt;/code&gt; of &lt;code&gt;fprintf&lt;/code&gt;). This transformation allows GCC to optimize or even eliminate branches based on the known return value of these functions called with arguments that are either constant, or whose values are known to be in a range that makes determining the exact return value possible. For example, when</source>
          <target state="translated">같은 형식의 출력 기능의 알려진 반환 값없는 대신 상수 수행 &lt;code&gt;sprintf&lt;/code&gt; 와 , &lt;code&gt;snprintf&lt;/code&gt; , &lt;code&gt;vsprintf&lt;/code&gt; 및 &lt;code&gt;vsnprintf&lt;/code&gt; (그러나 &lt;code&gt;printf&lt;/code&gt; 와 의 &lt;code&gt;fprintf&lt;/code&gt; ). 이 변환을 통해 GCC는 상수이거나 값이 정확한 반환 값을 결정할 수있는 범위에있는 인수로 불리는 이러한 함수의 알려진 반환 값을 기반으로 분기를 최적화하거나 제거 할 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="cf78eba26b5aa804017da1ef12f012cd3682e1fb" translate="yes" xml:space="preserve">
          <source>Do not treat the operator name keywords &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;bitand&lt;/code&gt;, &lt;code&gt;bitor&lt;/code&gt;, &lt;code&gt;compl&lt;/code&gt;, &lt;code&gt;not&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt; and &lt;code&gt;xor&lt;/code&gt; as synonyms as keywords.</source>
          <target state="translated">운영자 이름 키워드를 취급하지 마십시오 &lt;code&gt;and&lt;/code&gt; , &lt;code&gt;bitand&lt;/code&gt; , &lt;code&gt;bitor&lt;/code&gt; , &lt;code&gt;compl&lt;/code&gt; , &lt;code&gt;not&lt;/code&gt; , &lt;code&gt;or&lt;/code&gt; 및 &lt;code&gt;xor&lt;/code&gt; 키워드로 동의어로.</target>
        </trans-unit>
        <trans-unit id="a51f0c8e8070d0d16a2b1996318508b466a43f6d" translate="yes" xml:space="preserve">
          <source>Do not try to dynamically allocate condition code registers, only use &lt;code&gt;icc0&lt;/code&gt; and &lt;code&gt;fcc0&lt;/code&gt;.</source>
          <target state="translated">조건 코드 레지스터를 동적으로 할당하지 말고 &lt;code&gt;icc0&lt;/code&gt; 및 &lt;code&gt;fcc0&lt;/code&gt; 만 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="e4b145e8904eea56f7b19e2cc3eedad3e7a2b834" translate="yes" xml:space="preserve">
          <source>Do not use (do use) external functions to save and restore registers at the prologue and epilogue of a function. The external functions are slower, but use less code space if more than one function saves the same number of registers. The</source>
          <target state="translated">함수의 프롤로그 및 에필로그에서 레지스터를 저장하고 복원하기 위해 외부 함수를 사용하지 마십시오. 외부 함수는 느리지 만 둘 이상의 함수가 동일한 수의 레지스터를 저장하는 경우 코드 공간을 적게 사용하십시오. 그만큼</target>
        </trans-unit>
        <trans-unit id="00d7092da6abac6816723cc9e024cce735f69d9a" translate="yes" xml:space="preserve">
          <source>Do not use &lt;code&gt;__gcc_isr&lt;/code&gt; pseudo instructions in a function with the &lt;code&gt;interrupt&lt;/code&gt; or &lt;code&gt;signal&lt;/code&gt; attribute aka. interrupt service routine (ISR). Use this attribute if the preamble of the ISR prologue should always read</source>
          <target state="translated">&lt;code&gt;interrupt&lt;/code&gt; 또는 &lt;code&gt;signal&lt;/code&gt; 속성이 일명 인 함수에는 &lt;code&gt;__gcc_isr&lt;/code&gt; 의사 명령어를 사용하지 마십시오 . 인터럽트 서비스 루틴 (ISR). ISR 프롤로그의 프리앰블이 항상 읽어야하는 경우이 속성을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="18d8580e81e8dfe5a32f7016f417e2eb0471dcb3" translate="yes" xml:space="preserve">
          <source>Do not use a so-called &amp;ldquo;red zone&amp;rdquo; for x86-64 code. The red zone is mandated by the x86-64 ABI; it is a 128-byte area beyond the location of the stack pointer that is not modified by signal or interrupt handlers and therefore can be used for temporary data without adjusting the stack pointer. The flag</source>
          <target state="translated">x86-64 코드에는 소위 &quot;적색 영역&quot;을 사용하지 마십시오. 적색 구역은 x86-64 ABI에 의해 규정됩니다. 신호 또는 인터럽트 처리기로 수정되지 않은 스택 포인터의 위치를 ​​넘어 128 바이트 영역이므로 스택 포인터를 조정하지 않고도 임시 데이터에 사용할 수 있습니다. 깃발</target>
        </trans-unit>
        <trans-unit id="18a500f76abd74325a0b47c0d5b69985957db494" translate="yes" xml:space="preserve">
          <source>Do not use condition-code results from previous instruction; always emit compare and test instructions before use of condition codes.</source>
          <target state="translated">이전 명령의 조건 코드 결과를 사용하지 마십시오. 조건 코드를 사용하기 전에 항상 비교 및 ​​테스트 지침을 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="8b90672d13ea8faf72441a2154876e77530d1d87" translate="yes" xml:space="preserve">
          <source>Do not use div and mod instructions.</source>
          <target state="translated">div 및 mod 명령어를 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="a1c8552434007f4da99e51d45212d527e1753ccf" translate="yes" xml:space="preserve">
          <source>Do not use double word instructions.</source>
          <target state="translated">더블 워드 명령어를 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="3da98d0922de975e727ce6056f533717a8befbdb" translate="yes" xml:space="preserve">
          <source>Do not use floating-point coprocessor instructions. Implement floating-point calculations using library calls instead.</source>
          <target state="translated">부동 소수점 보조 프로세서 명령어를 사용하지 마십시오. 대신 라이브러리 호출을 사용하여 부동 소수점 계산을 구현하십시오.</target>
        </trans-unit>
        <trans-unit id="9fdd545e439d4b4617a15eacf8cd9e4f96ac14e8" translate="yes" xml:space="preserve">
          <source>Do not use floating-point double instructions.</source>
          <target state="translated">부동 소수점 이중 명령어를 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="95fd53c42ee138555aacbc40f7b4326fe9304fd6" translate="yes" xml:space="preserve">
          <source>Do not use hardware floating point.</source>
          <target state="translated">하드웨어 부동 소수점을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="97b2ddca9650ddbadc66a49ca355676910df5582" translate="yes" xml:space="preserve">
          <source>Do not use jump tables for switch statements even where it would be more efficient than other code generation strategies. This option is of use in conjunction with</source>
          <target state="translated">다른 코드 생성 전략보다 효율적인 경우에도 switch 문에 점프 테이블을 사용하지 마십시오. 이 옵션은 다음과 함께 사용됩니다</target>
        </trans-unit>
        <trans-unit id="66b43b46849088f20d198292bf3b1d8b62697198" translate="yes" xml:space="preserve">
          <source>Do not use media instructions.</source>
          <target state="translated">용지 지침을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="0a7e7f9ca7cad5a355cdeb3565cfa6b4acd871ea" translate="yes" xml:space="preserve">
          <source>Do not use multiply and add/subtract instructions.</source>
          <target state="translated">곱하기 및 더하기 / 빼기 명령어를 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="8d9e83aee940103d590cb767e0456c5b78e32683" translate="yes" xml:space="preserve">
          <source>Do not use table-based fast divide for small numbers. The default is to use the fast divide at</source>
          <target state="translated">작은 숫자에는 테이블 기반 빠른 나누기를 사용하지 마십시오. 기본값은 빠른 나누기를 사용하는 것입니다</target>
        </trans-unit>
        <trans-unit id="05b033596194e8c7885a56cfce16297eb0279fb4" translate="yes" xml:space="preserve">
          <source>Do not use the C library or system libraries tightly coupled with it when linking. Still link with the startup files,</source>
          <target state="translated">링크 할 때 C 라이브러리 또는 시스템 라이브러리를 밀접하게 결합하여 사용하지 마십시오. 여전히 시작 파일과 연결</target>
        </trans-unit>
        <trans-unit id="7597081c858717e7804a44bce422498f190040a9" translate="yes" xml:space="preserve">
          <source>Do not use the FPU registers for return values of functions.</source>
          <target state="translated">함수의 반환 값에 FPU 레지스터를 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="1d16a9b15ecbbe19aaee48f8f83799d98bf40097" translate="yes" xml:space="preserve">
          <source>Do not use the PLT for external function calls in position-independent code. Instead, load the callee address at call sites from the GOT and branch to it. This leads to more efficient code by eliminating PLT stubs and exposing GOT loads to optimizations. On architectures such as 32-bit x86 where PLT stubs expect the GOT pointer in a specific register, this gives more register allocation freedom to the compiler. Lazy binding requires use of the PLT; with</source>
          <target state="translated">위치 독립적 인 코드에서 외부 함수 호출에 PLT를 사용하지 마십시오. 대신, GOT에서 호출 사이트의 수신자 주소를로드하고 그 주소로 분기하십시오. 이는 PLT 스텁을 제거하고 GOT로드를 최적화에 노출함으로써보다 효율적인 코드로 이어집니다. PLT 스터브가 특정 레지스터에서 GOT 포인터를 기대하는 32 비트 x86과 같은 아키텍처에서는 컴파일러에 더 많은 레지스터 할당 자유를 제공합니다. 게으른 결합에는 PLT를 사용해야합니다. 와</target>
        </trans-unit>
        <trans-unit id="0ea4440b962126227be7707085ba73c227777ab2" translate="yes" xml:space="preserve">
          <source>Do not use the bit-field instructions. The</source>
          <target state="translated">비트 필드 명령어를 사용하지 마십시오. 그만큼</target>
        </trans-unit>
        <trans-unit id="be4c2d58ea2c75689a1e197b8bce077dc3baf8e4" translate="yes" xml:space="preserve">
          <source>Do not use the standard system libraries when linking. Only the libraries you specify are passed to the linker, and options specifying linkage of the system libraries, such as</source>
          <target state="translated">연결할 때 표준 시스템 라이브러리를 사용하지 마십시오. 지정한 라이브러리 만 링커에 전달되고 시스템 라이브러리의 링크를 지정하는 옵션 (예 :</target>
        </trans-unit>
        <trans-unit id="1749ead3f9e7878168e9e856a83790c8110a2327" translate="yes" xml:space="preserve">
          <source>Do not use the standard system startup files or libraries when linking. No startup files and only the libraries you specify are passed to the linker, and options specifying linkage of the system libraries, such as</source>
          <target state="translated">링크 할 때 표준 시스템 시작 파일 또는 라이브러리를 사용하지 마십시오. 시작 파일이없고 지정한 라이브러리 만 링커에 전달되고 시스템 라이브러리의 링크를 지정하는 옵션 (예 :</target>
        </trans-unit>
        <trans-unit id="c08b8394a0f77286bf2dfe4eba4ed4f08b60e58a" translate="yes" xml:space="preserve">
          <source>Do not use the standard system startup files when linking. The standard system libraries are used normally, unless</source>
          <target state="translated">연결할 때 표준 시스템 시작 파일을 사용하지 마십시오. 표준 시스템 라이브러리는 일반적으로 사용되지 않는 한</target>
        </trans-unit>
        <trans-unit id="52b9f7e2d461f74673bbbc8c6515110fc50b3657" translate="yes" xml:space="preserve">
          <source>Do not use type qualifiers such as &lt;code&gt;const&lt;/code&gt; and &lt;code&gt;volatile&lt;/code&gt;, as the outcome may be contrary to expectations. In particular, using the &lt;code&gt;volatile&lt;/code&gt; qualifier does not fully prevent the compiler from optimizing accesses to the register.</source>
          <target state="translated">결과가 예상과 상충 될 수 있으므로 &lt;code&gt;const&lt;/code&gt; 및 &lt;code&gt;volatile&lt;/code&gt; 과 같은 유형 한정자를 사용하지 마십시오 . 특히, &lt;code&gt;volatile&lt;/code&gt; 한정자를 사용 한다고해서 컴파일러가 레지스터에 대한 액세스를 최적화하는 것을 완전히 막을 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="78d5320a817e4a255712f70b363a7e985f54d40c" translate="yes" xml:space="preserve">
          <source>Do not use type qualifiers such as &lt;code&gt;const&lt;/code&gt; and &lt;code&gt;volatile&lt;/code&gt;, as the outcome may be contrary to expectations. In particular, when the &lt;code&gt;const&lt;/code&gt; qualifier is used, the compiler may substitute the variable with its initializer in &lt;code&gt;asm&lt;/code&gt; statements, which may cause the corresponding operand to appear in a different register.</source>
          <target state="translated">결과가 예상과 상충 될 수 있으므로 &lt;code&gt;const&lt;/code&gt; 및 &lt;code&gt;volatile&lt;/code&gt; 과 같은 유형 한정자를 사용하지 마십시오 . 특히 &lt;code&gt;const&lt;/code&gt; 한정자를 사용하면 컴파일러는 변수를 &lt;code&gt;asm&lt;/code&gt; 문 에서 이니셜 라이저로 대체 하여 해당 피연산자가 다른 레지스터에 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a1518a9d7c5d3a374a0e3380575da8c6a0c3463" translate="yes" xml:space="preserve">
          <source>Do not use weak symbol support, even if it is provided by the linker. By default, G++ uses weak symbols if they are available. This option exists only for testing, and should not be used by end-users; it results in inferior code and has no benefits. This option may be removed in a future release of G++.</source>
          <target state="translated">링커에서 제공 한 경우에도 약한 심볼 지원을 사용하지 마십시오. 기본적으로 G ++는 사용 가능한 경우 약한 기호를 사용합니다. 이 옵션은 테스트 용으로 만 사용되며 최종 사용자가 사용해서는 안됩니다. 코드가 열등하고 이점이 없습니다. 이 옵션은 향후 G ++ 릴리스에서 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c6a44b0e85a6edc81e27b7d2eeb886e6e3cf31e" translate="yes" xml:space="preserve">
          <source>Do not warn about compile-time integer division by zero. Floating-point division by zero is not warned about, as it can be a legitimate way of obtaining infinities and NaNs.</source>
          <target state="translated">컴파일 타임 정수를 0으로 나누는 것에 대해 경고하지 마십시오. 부동 소수점을 0으로 나누는 것은 무한대와 NaN을 얻는 합법적 인 방법 일 수 있으므로 경고하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5c0402a3d7a93e89c19d0b2bc886627da9bb7bce" translate="yes" xml:space="preserve">
          <source>Do not warn about compile-time overflow in constant expressions.</source>
          <target state="translated">상수 식에서 컴파일 타임 오버플로에 대해 경고하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="f3164f98334eb82394edc2af61f2d8e4ea49e902" translate="yes" xml:space="preserve">
          <source>Do not warn about incompatible integer to pointer and pointer to integer conversions. This warning is about implicit conversions; for explicit conversions the warnings</source>
          <target state="translated">호환되지 않는 정수 대 포인터 및 포인터 대 정수 변환에 대해 경고하지 마십시오. 이 경고는 암시 적 변환에 관한 것입니다. 명시적인 변환을 위해 경고</target>
        </trans-unit>
        <trans-unit id="9ee34e26cbf6dcdf9bae6a606eba5f147e3812eb" translate="yes" xml:space="preserve">
          <source>Do not warn about misuses of pragmas, such as incorrect parameters, invalid syntax, or conflicts between pragmas. See also</source>
          <target state="translated">잘못된 매개 변수, 잘못된 구문 또는 pragma 간의 충돌과 같은 pragma 오용에 대해 경고하지 마십시오. 또한보십시오</target>
        </trans-unit>
        <trans-unit id="2fba612926859cd3b2ec30d821b233c2c88e411e" translate="yes" xml:space="preserve">
          <source>Do not warn about returning a pointer (or in C++, a reference) to a variable that goes out of scope after the function returns.</source>
          <target state="translated">함수가 리턴 된 후 범위를 벗어난 변수에 대한 포인터 (또는 C ++에서는 참조)를 리턴하는 것에 대해 경고하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="e20062785b98beaefd7db7d397190023d3d7d01c" translate="yes" xml:space="preserve">
          <source>Do not warn about usage of deprecated features. See &lt;a href=&quot;deprecated-features#Deprecated-Features&quot;&gt;Deprecated Features&lt;/a&gt;.</source>
          <target state="translated">더 이상 사용되지 않는 기능의 사용에 대해 경고하지 마십시오. 더 이상 &lt;a href=&quot;deprecated-features#Deprecated-Features&quot;&gt;사용되지 않는 기능을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5741a81d36ae80d4f66c3d238560cf727f6d2221" translate="yes" xml:space="preserve">
          <source>Do not warn about usage of functions (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;) declared with &lt;code&gt;warning&lt;/code&gt; attribute. By default, this warning is enabled.</source>
          <target state="translated">&lt;code&gt;warning&lt;/code&gt; 속성으로 선언 된 함수 사용 ( &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;함수 속성&lt;/a&gt; 참조)에 대해 경고하지 마십시오 . 이 경고는 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="569882ee6769c783a7c673619d2b596b07ae7884" translate="yes" xml:space="preserve">
          <source>Do not warn about uses of &lt;code&gt;std::initializer_list&lt;/code&gt; that are likely to result in dangling pointers. Since the underlying array for an &lt;code&gt;initializer_list&lt;/code&gt; is handled like a normal C++ temporary object, it is easy to inadvertently keep a pointer to the array past the end of the array&amp;rsquo;s lifetime. For example:</source>
          <target state="translated">매달려 포인터가 발생할 수있는 &lt;code&gt;std::initializer_list&lt;/code&gt; 사용에 대해 경고하지 마십시오 . &lt;code&gt;initializer_list&lt;/code&gt; 의 기본 배열 은 일반 C ++ 임시 오브젝트처럼 처리되므로 배열의 수명이 다한 후에 배열에 대한 포인터를 실수로 쉽게 유지할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e7879bd2657e4473a1347324fd997f9cdc3d041e" translate="yes" xml:space="preserve">
          <source>Do not warn about uses of functions (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;), variables (see &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;), and types (see &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Type Attributes&lt;/a&gt;) marked as deprecated by using the &lt;code&gt;deprecated&lt;/code&gt; attribute.</source>
          <target state="translated">더 이상 사용 &lt;code&gt;deprecated&lt;/code&gt; 속성 을 사용하여 더 이상 사용되지 않는 것으로 표시된 함수 ( &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;함수 속성&lt;/a&gt; 참조 ), 변수 ( &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;변수 속성&lt;/a&gt; 참조 ) 및 유형 ( &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;유형 속성&lt;/a&gt; 참조) 사용에 대해 경고하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="b2ba657c651e9df665e818d59934ea7360d21f9d" translate="yes" xml:space="preserve">
          <source>Do not warn for conversions between &lt;code&gt;NULL&lt;/code&gt; and non-pointer types.</source>
          <target state="translated">&lt;code&gt;NULL&lt;/code&gt; 과 비 포인터 유형 간의 변환에 대해 경고하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="f3c7034f14450f34ae37fb2f3dc3f8309df1df4c" translate="yes" xml:space="preserve">
          <source>Do not warn if a caller of a function marked with attribute &lt;code&gt;warn_unused_result&lt;/code&gt; (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;) does not use its return value. The default is</source>
          <target state="translated">속성 &lt;code&gt;warn_unused_result&lt;/code&gt; ( &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;함수 속성&lt;/a&gt; 참조) 로 표시된 함수의 호출자가 리턴 값을 사용하지 않는 경우 경고하지 마십시오 . 디폴트는</target>
        </trans-unit>
        <trans-unit id="e5c44e9dcc0d0d2cc0d4fcbe48e1b3887ed71621" translate="yes" xml:space="preserve">
          <source>Do not warn if a multicharacter constant (&amp;lsquo;</source>
          <target state="translated">다중 문자 상수 ( '</target>
        </trans-unit>
        <trans-unit id="474d345e0c92820e39935346f3f6f08e315a2c69" translate="yes" xml:space="preserve">
          <source>Do not warn if a priority from 0 to 100 is used for constructor or destructor. The use of constructor and destructor attributes allow you to assign a priority to the constructor/destructor to control its order of execution before &lt;code&gt;main&lt;/code&gt; is called or after it returns. The priority values must be greater than 100 as the compiler reserves priority values between 0&amp;ndash;100 for the implementation.</source>
          <target state="translated">생성자 또는 소멸자에 0-100의 우선 순위가 사용되는 경우 경고하지 마십시오. 생성자 및 소멸자 속성을 사용하면 생성자 / 소멸자에 우선 순위를 지정하여 &lt;code&gt;main&lt;/code&gt; 이 호출 되기 전 또는 반환 된 후에 실행 순서를 제어 할 수 있습니다. 컴파일러가 구현을 위해 0-100 사이의 우선 순위 값을 예약하므로 우선 순위 값은 100보다 커야합니다.</target>
        </trans-unit>
        <trans-unit id="c5958651457da08de9e91cd3ae0fc547368da59b" translate="yes" xml:space="preserve">
          <source>Do not warn if an unexpected &lt;code&gt;__attribute__&lt;/code&gt; is used, such as unrecognized attributes, function attributes applied to variables, etc. This does not stop errors for incorrect use of supported attributes.</source>
          <target state="translated">인식 할 수없는 속성, 변수에 적용된 함수 속성 등과 같이 예기치 않은 &lt;code&gt;__attribute__&lt;/code&gt; 가 사용 된 경우 경고하지 마십시오 . 지원되는 속성을 잘못 사용하더라도 오류가 중지되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="776e98d1dffbde23efe71be5b00aaf8afcebd19f" translate="yes" xml:space="preserve">
          <source>Do not warn if certain built-in macros are redefined. This suppresses warnings for redefinition of &lt;code&gt;__TIMESTAMP__&lt;/code&gt;, &lt;code&gt;__TIME__&lt;/code&gt;, &lt;code&gt;__DATE__&lt;/code&gt;, &lt;code&gt;__FILE__&lt;/code&gt;, and &lt;code&gt;__BASE_FILE__&lt;/code&gt;.</source>
          <target state="translated">특정 내장 매크로가 재정의되면 경고하지 마십시오. 이것은 &lt;code&gt;__TIMESTAMP__&lt;/code&gt; , &lt;code&gt;__TIME__&lt;/code&gt; , &lt;code&gt;__DATE__&lt;/code&gt; , &lt;code&gt;__FILE__&lt;/code&gt; 및 &lt;code&gt;__BASE_FILE__&lt;/code&gt; 의 재정의에 대한 경고를 표시하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a5961961b151110f8171f9f71097fa474a97d41f" translate="yes" xml:space="preserve">
          <source>Do not warn if type qualifiers on arrays which are pointer targets are being discarded. Typically, the compiler warns if a &lt;code&gt;const int (*)[]&lt;/code&gt; variable is passed to a function that takes a &lt;code&gt;int (*)[]&lt;/code&gt; parameter. This option can be used to suppress such a warning.</source>
          <target state="translated">포인터 대상인 배열의 형식 한정자가 삭제되는 경우 경고하지 마십시오. 일반적으로 컴파일러는 &lt;code&gt;const int (*)[]&lt;/code&gt; 변수가 &lt;code&gt;int (*)[]&lt;/code&gt; 매개 변수 를 사용하는 함수에 전달 되는지 경고합니다 . 이 옵션은 이러한 경고를 억제하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f6ac391aa1f66b1759edea5545511d490e350b4" translate="yes" xml:space="preserve">
          <source>Do not warn if type qualifiers on pointers are being discarded. Typically, the compiler warns if a &lt;code&gt;const char *&lt;/code&gt; variable is passed to a function that takes a &lt;code&gt;char *&lt;/code&gt; parameter. This option can be used to suppress such a warning.</source>
          <target state="translated">포인터의 타입 한정자를 버리고 있는지 경고하지 마십시오. 일반적으로 컴파일러에서는 &lt;code&gt;const char *&lt;/code&gt; 변수가 &lt;code&gt;char *&lt;/code&gt; 매개 변수 를 사용하는 함수에 전달 되는지 경고합니다 . 이 옵션은 이러한 경고를 억제하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2237d0ea4af513f919bfca5807318b7adb31ba01" translate="yes" xml:space="preserve">
          <source>Do not warn on suspicious constructs involving reverse scalar storage order.</source>
          <target state="translated">역 스칼라 저장 순서와 관련된 의심스러운 구성에 대해서는 경고하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="505f6f0a22dd44c4b12ed8d2e6a399fe3806c159" translate="yes" xml:space="preserve">
          <source>Do not warn when attempting to free an object that was not allocated on the heap.</source>
          <target state="translated">힙에 할당되지 않은 오브젝트를 해제하려고 할 때 경고하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="b41e5f71b800c0d75e8bc4c789587d50634e7b35" translate="yes" xml:space="preserve">
          <source>Do not warn when there is a conversion between pointers that have incompatible types. This warning is for cases not covered by</source>
          <target state="translated">호환되지 않는 유형을 가진 포인터 사이에 변환이있을 때 경고하지 마십시오. 이 경고는</target>
        </trans-unit>
        <trans-unit id="7288e67492dfae2c91a3de07cd384be7cd59dcec" translate="yes" xml:space="preserve">
          <source>Do not warn whenever a local variable shadows an instance variable in an Objective-C method.</source>
          <target state="translated">Objective-C 메소드에서 로컬 변수가 인스턴스 변수를 가리게 될 때마다 경고하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="a828e7021a3bac6b8a79dcdabca3402745cfbb45" translate="yes" xml:space="preserve">
          <source>Do not warn whenever an &lt;code&gt;#else&lt;/code&gt; or an &lt;code&gt;#endif&lt;/code&gt; are followed by text. This sometimes happens in older programs with code of the form</source>
          <target state="translated">&lt;code&gt;#else&lt;/code&gt; 또는 &lt;code&gt;#endif&lt;/code&gt; 뒤에 텍스트가 올 때마다 경고하지 마십시오 . 이것은 때때로 코드 형식의 구형 프로그램에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="12e3a14254e97e0a14b8cdd90a112ee9ef9f78f5" translate="yes" xml:space="preserve">
          <source>Do nothing. Code written for the Borland model works fine, but each translation unit contains instances of each of the templates it uses. The duplicate instances will be discarded by the linker, but in a large program, this can lead to an unacceptable amount of code duplication in object files or shared libraries.</source>
          <target state="translated">아무것도하지 마세요. Borland 모델 용으로 작성된 코드는 잘 작동하지만 각 번역 단위에는 사용하는 각 템플릿의 인스턴스가 포함됩니다. 중복 인스턴스는 링커에 의해 삭제되지만 큰 프로그램에서는 개체 파일 또는 공유 라이브러리에서 허용되지 않는 양의 코드 복제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36f05070ba1aa8ebb373ea5159cf72f76e048943" translate="yes" xml:space="preserve">
          <source>Do or don&amp;rsquo;t use hardware floating-point divide and square root instructions. This requires the F or D extensions for floating-point registers. The default is to use them if the specified architecture has these instructions.</source>
          <target state="translated">하드웨어 부동 소수점 나누기 및 제곱근 명령어를 사용하거나 사용하지 않습니다. 부동 소수점 레지스터의 경우 F 또는 D 확장이 필요합니다. 지정된 아키텍처에 이러한 지침이있는 경우 기본값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="57a1444191ca5bb7028d2e6eff0344f434565ffa" translate="yes" xml:space="preserve">
          <source>Do or don&amp;rsquo;t use hardware instructions for integer division. This requires the M extension. The default is to use them if the specified architecture has these instructions.</source>
          <target state="translated">정수 나누기에 하드웨어 명령어를 사용하거나 사용하지 마십시오. M 확장이 필요합니다. 지정된 아키텍처에 이러한 지침이있는 경우 기본값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ddefab05090bb15a5eac377b4c14800d5252c830" translate="yes" xml:space="preserve">
          <source>Do or don&amp;rsquo;t use smaller but slower prologue and epilogue code that uses library function calls. The default is to use fast inline prologues and epilogues.</source>
          <target state="translated">라이브러리 함수 호출을 사용하는 작지만 느린 프롤로그 및 에필로그 코드를 사용하거나 사용하지 마십시오. 기본값은 빠른 인라인 프롤로그 및 에필로그를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="96ba75d321eadfeb26cc86353736e08f35e773ab" translate="yes" xml:space="preserve">
          <source>Do output those jump instructions, on the assumption that the GNU assembler is being used.</source>
          <target state="translated">GNU 어셈블러가 사용된다는 가정하에 이러한 점프 명령을 출력하십시오.</target>
        </trans-unit>
        <trans-unit id="4d204a72f0077f832ff1f2432253a2d1ae4c41b8" translate="yes" xml:space="preserve">
          <source>Do stack checking using information placed into L1 scratchpad memory by the uClinux kernel.</source>
          <target state="translated">uClinux 커널이 L1 스크래치 패드 메모리에 배치 한 정보를 사용하여 스택 검사를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="63c71786896a4df72c3bdfbb021ed8f95f3c7268" translate="yes" xml:space="preserve">
          <source>Do use the bit-field instructions. The</source>
          <target state="translated">비트 필드 명령어를 사용하십시오. 그만큼</target>
        </trans-unit>
        <trans-unit id="aeab84fbb87aa1ae0148d00185bbbe64a7f1de75" translate="yes" xml:space="preserve">
          <source>Do/do not align destination of inlined string operations.</source>
          <target state="translated">인라인 문자열 조작의 대상을 정렬 /하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="bc45e676c4601147aa81205b6b35bbce28a0956f" translate="yes" xml:space="preserve">
          <source>Dollar sign is allowed in identifiers.</source>
          <target state="translated">식별자에는 달러 기호가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="68e93316f665d706cb16fce9b665aecabf389d83" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t (or do) generate assembler code for the DWARF line number debugging info. This may be useful when not using the GNU assembler.</source>
          <target state="translated">DWARF 라인 번호 디버깅 정보에 대한 어셈블러 코드를 생성하지 마십시오. GNU 어셈블러를 사용하지 않을 때 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f51bdbcf76c028728ebe02e5fd8a3a1a4630491b" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t allocate any register in the range &lt;code&gt;r32&lt;/code&gt;&amp;hellip;&lt;code&gt;r63&lt;/code&gt;. That allows code to run on hardware variants that lack these registers.</source>
          <target state="translated">&lt;code&gt;r32&lt;/code&gt; &amp;hellip; &lt;code&gt;r63&lt;/code&gt; 범위의 레지스터를 할당하지 마십시오 . 이를 통해 이러한 레지스터가없는 하드웨어 변형에서 코드를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0696f924a6a7aba65bb0c521d005ad21d730a7e5" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t allow (allow) the compiler generating privileged mode code. Specifying</source>
          <target state="translated">컴파일러가 권한 모드 코드를 생성하는 것을 허용하지 마십시오. 지정</target>
        </trans-unit>
        <trans-unit id="b4aac26fa88db757f99f48797196bd3cbd91bc9d" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t emit code for implicit instantiations of inline templates, either. The default is to handle inlines differently so that compiles with and without optimization need the same set of explicit instantiations.</source>
          <target state="translated">인라인 템플릿의 암시 적 인스턴스화를위한 코드도 생성하지 마십시오. 기본값은 인라인을 다르게 처리하여 최적화가 있거나없는 컴파일에 동일한 명시 적 인스턴스화 세트가 필요하도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c69befd629431a6e029cd45dbc6aab7876d6d7d6" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t generate code to check for violation of exception specifications at run time. This option violates the C++ standard, but may be useful for reducing code size in production builds, much like defining &lt;code&gt;NDEBUG&lt;/code&gt;. This does not give user code permission to throw exceptions in violation of the exception specifications; the compiler still optimizes based on the specifications, so throwing an unexpected exception results in undefined behavior at run time.</source>
          <target state="translated">런타임시 예외 사양 위반을 확인하는 코드를 생성하지 마십시오. 이 옵션은 C ++ 표준을 위반하지만 &lt;code&gt;NDEBUG&lt;/code&gt; 정의와 같이 프로덕션 빌드에서 코드 크기를 줄이는 데 유용 할 수 있습니다 . 이것은 예외 코드를 위반하여 예외를 던질 수있는 권한을 사용자 코드에 부여하지 않습니다. 컴파일러는 여전히 사양을 기반으로 최적화하므로 예기치 않은 예외가 발생하면 런타임에 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f8291058c6a41a1212fed5bdc0b889e02ad54e73" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t generate extra code to prevent CSYNC or SSYNC instructions from occurring too soon after a conditional branch.</source>
          <target state="translated">조건부 분기 후 CSYNC 또는 SSYNC 명령이 너무 빨리 발생하지 않도록 추가 코드를 생성하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="92fc05375382df9e90695eff3a44465379a9fc8a" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t generate extra code to prevent speculative loads from occurring.</source>
          <target state="translated">추론 적로드가 발생하지 않도록 추가 코드를 생성하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="841b2c5913f27dd6d0a0b75be4041ed9060e2a5b" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t indicate any priority for target registers.</source>
          <target state="translated">대상 레지스터에 우선 순위를 표시하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="316b458b3b915800cc227cb589b8354e8997e031" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t insert NOPs.</source>
          <target state="translated">NOP를 삽입하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="ff257b74ea5cefc2a6c99dc46dcf1ce2fc00c3e9" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t keep the frame pointer in a register for leaf functions. This avoids the instructions to save, set up and restore frame pointers and makes an extra register available in leaf functions.</source>
          <target state="translated">리프 함수의 레지스터에 프레임 포인터를 유지하지 마십시오. 이렇게하면 프레임 포인터를 저장, 설정 및 복원하라는 지시를 피하고 리프 함수에서 추가 레지스터를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="29fcb114afda8378c254d0362fee3390fc31a076" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t keep the frame pointer in a register for leaf functions. This avoids the instructions to save, set up, and restore frame pointers and makes an extra register available in leaf functions. The option</source>
          <target state="translated">리프 함수의 레지스터에 프레임 포인터를 유지하지 마십시오. 이렇게하면 프레임 포인터를 저장, 설정 및 복원하라는 지시를 피하고 리프 함수에서 추가 레지스터를 사용할 수 있습니다. 옵션</target>
        </trans-unit>
        <trans-unit id="ba01c69254f25c86224b738f06e6534bc4f3d911" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t link against AVR-LibC&amp;rsquo;s device specific library &lt;code&gt;lib&amp;lt;mcu&amp;gt;.a&lt;/code&gt;.</source>
          <target state="translated">AVR-LibC의 장치 별 라이브러리 &lt;code&gt;lib&amp;lt;mcu&amp;gt;.a&lt;/code&gt; 연결하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="e29b08debc2f8c83b43cab1a04eee2f4d727ea03" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t output a &lt;code&gt;.size&lt;/code&gt; assembler directive, or anything else that would cause trouble if the function is split in the middle, and the two halves are placed at locations far apart in memory. This option is used when compiling</source>
          <target state="translated">&lt;code&gt;.size&lt;/code&gt; 어셈블러 지시문 또는 함수가 중간에 분할되고 두 개의 반쪽이 메모리에서 멀리 떨어진 위치에 배치되면 문제를 일으킬 수있는 어떤 것도 출력하지 마십시오 . 이 옵션은 컴파일 할 때 사용됩니다</target>
        </trans-unit>
        <trans-unit id="d01cd709102ba1930825f66a542ae471f0249850" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t produce a dynamically linked position independent executable.</source>
          <target state="translated">동적으로 링크 된 위치 독립적 실행 파일을 생성하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="0d7422ae3d66c98a5899ca6447dbd9bcec60457e" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t recognize built-in functions that do not begin with &amp;lsquo;</source>
          <target state="translated">'로 시작하지 않는 내장 함수를 인식하지 못합니다</target>
        </trans-unit>
        <trans-unit id="700e3402560c020ff640d0360da073b7f29b63b2" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t try to return a reference when you must return an object.</source>
          <target state="translated">객체를 반환해야 할 때 참조를 반환하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="af0c2963603baeac9b84a7601cb10b5b24bf9b5d" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t use less than 25-bit addressing range for calls, which is the offset available for an unconditional branch-and-link instruction. Conditional execution of function calls is suppressed, to allow use of the 25-bit range, rather than the 21-bit range with conditional branch-and-link. This is the default for tool chains built for &lt;code&gt;arc-linux-uclibc&lt;/code&gt; and &lt;code&gt;arceb-linux-uclibc&lt;/code&gt; targets.</source>
          <target state="translated">무조건 분기 및 링크 명령에 사용할 수있는 오프셋 인 통화에 25 비트 미만의 주소 지정 범위를 사용하지 마십시오. 조건부 분기 및 링크가있는 21 비트 범위가 아닌 25 비트 범위를 사용할 수 있도록 함수 호출의 조건부 실행이 억제됩니다. 이는 &lt;code&gt;arc-linux-uclibc&lt;/code&gt; 및 &lt;code&gt;arceb-linux-uclibc&lt;/code&gt; 대상 용으로 빌드 된 툴 체인의 기본값입니다 .</target>
        </trans-unit>
        <trans-unit id="71dc31daaf7ec06b2fa4f05018881b81c4bb5538" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t use the &lt;code&gt;__cxa_get_exception_ptr&lt;/code&gt; runtime routine. This causes &lt;code&gt;std::uncaught_exception&lt;/code&gt; to be incorrect, but is necessary if the runtime routine is not available.</source>
          <target state="translated">&lt;code&gt;__cxa_get_exception_ptr&lt;/code&gt; 런타임 루틴을 사용하지 마십시오 . 이로 인해 &lt;code&gt;std::uncaught_exception&lt;/code&gt; 이 올바르지 않지만 런타임 루틴을 사용할 수없는 경우 필요합니다.</target>
        </trans-unit>
        <trans-unit id="8dcc5d27681a8bdad6a9cb3ee54a8968b968d227" translate="yes" xml:space="preserve">
          <source>Double-precision floating point:</source>
          <target state="translated">배정 밀도 부동 소수점 :</target>
        </trans-unit>
        <trans-unit id="ed1ceb86db6df41816a7c2bb25eb2a7096005f14" translate="yes" xml:space="preserve">
          <source>Double-precision minimum and maximum. These instructions are only generated if</source>
          <target state="translated">배정 밀도 최소 및 최대. 이 명령어는 다음과 같은 경우에만 생성됩니다</target>
        </trans-unit>
        <trans-unit id="37d9eb125267c27f5502a1a9d084767dc36a78f0" translate="yes" xml:space="preserve">
          <source>Double-precision trigonometric and exponential functions. These instructions are only generated if</source>
          <target state="translated">배정 밀도 삼각 함수 및 지수 함수. 이 명령어는 다음과 같은 경우에만 생성됩니다</target>
        </trans-unit>
        <trans-unit id="6df71cfe44fe533eddb81c22b571782849f6b7cc" translate="yes" xml:space="preserve">
          <source>Double-word integers&amp;mdash;&lt;code&gt;long long int&lt;/code&gt;.</source>
          <target state="translated">더블 워드 정수 &amp;mdash; &lt;code&gt;long long int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc953a7def63cef4cb68fb70c5f14bea1b94cf60" translate="yes" xml:space="preserve">
          <source>Downgrade some diagnostics about nonconformant code from errors to warnings. Thus, using</source>
          <target state="translated">부적합한 코드에 대한 일부 진단을 오류에서 경고로 다운 그레이드하십시오. 따라서</target>
        </trans-unit>
        <trans-unit id="01180802e3e84af7a4d8039eea60df66e24e2e3d" translate="yes" xml:space="preserve">
          <source>Due to a limitation the &lt;code&gt;__builtin_has_attribute&lt;/code&gt; function returns &lt;code&gt;false&lt;/code&gt; for the &lt;code&gt;mode&lt;/code&gt; attribute even if the type or variable referenced by the &lt;var&gt;type-or-expression&lt;/var&gt; argument was declared with one. The function is also not supported with labels, and in C with enumerators.</source>
          <target state="translated">제한으로 인해 &lt;code&gt;__builtin_has_attribute&lt;/code&gt; 함수는 &lt;var&gt;type-or-expression&lt;/var&gt; 인수가 참조하는 유형 또는 변수 가 1로 선언 된 경우에도 &lt;code&gt;mode&lt;/code&gt; 속성에 대해 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 이 기능은 레이블과 열거자가있는 C에서도 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eaa7b08f0e0c97160e76284248f06868dbcb58d2" translate="yes" xml:space="preserve">
          <source>Due to delay slot scheduling and interactions between operand numbers, literal sizes, instruction lengths, and the support for conditional execution, the target-independent pass to generate conditional execution is often lacking, so the ARC port has kept a special pass around that tries to find more conditional execution generation opportunities after register allocation, branch shortening, and delay slot scheduling have been done. This pass generally, but not always, improves performance and code size, at the cost of extra compilation time, which is why there is an option to switch it off. If you have a problem with call instructions exceeding their allowable offset range because they are conditionalized, you should consider using</source>
          <target state="translated">피연산자 번호, 리터럴 크기, 명령어 길이 및 조건부 실행 지원 간의 지연 슬롯 스케줄링 및 상호 작용으로 인해 조건부 실행을 생성하기위한 대상 독립적 패스가 종종 부족하므로 ARC 포트는 레지스터 할당, 분기 단축 및 지연 슬롯 스케줄링이 완료된 후 더 많은 조건부 실행 생성 기회를 찾습니다. 이 패스는 일반적으로 항상 그렇지는 않지만 추가 컴파일 시간을 희생하여 성능 및 코드 크기를 향상 시키므로이를 해제 할 수있는 옵션이 있습니다. 조건에 따라 통화 지시가 허용 오프셋 범위를 초과하는 데 문제가있는 경우 사용을 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="8570e266a139eea3cf33870c783885655692c297" translate="yes" xml:space="preserve">
          <source>Due to differences in 64-bit ABIs, any Microsoft ABI function that calls a System V ABI function must consider RSI, RDI and XMM6-15 as clobbered. By default, the code for saving and restoring these registers is emitted inline, resulting in fairly lengthy prologues and epilogues. Using</source>
          <target state="translated">64 비트 ABI의 차이로 인해 System V ABI 함수를 호출하는 모든 Microsoft ABI 함수는 RSI, RDI 및 XMM6-15를 클로버로 간주해야합니다. 기본적으로 이러한 레지스터를 저장하고 복원하는 코드는 인라인으로 방출되므로 프롤로그와 에필로그가 상당히 길어집니다. 사용</target>
        </trans-unit>
        <trans-unit id="55dc1ed426258fad4287ccc3186c8799b4478fe2" translate="yes" xml:space="preserve">
          <source>Dump after RTL generation.</source>
          <target state="translated">RTL 생성 후 덤프</target>
        </trans-unit>
        <trans-unit id="55112da270658f739f4dfb65c2070abbe0a2de15" translate="yes" xml:space="preserve">
          <source>Dump after all rtl has been unshared.</source>
          <target state="translated">모든 rtl이 공유 해제 된 후 덤프</target>
        </trans-unit>
        <trans-unit id="17713d860b95f07f88ad9a9c6f46bff3093dd8bf" translate="yes" xml:space="preserve">
          <source>Dump after auto-inc-dec discovery. This pass is only run on architectures that have auto inc or auto dec instructions.</source>
          <target state="translated">자동 -inc-dec 감지 후 덤프. 이 단계는 auto inc 또는 auto dec 명령이있는 아키텍처에서만 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="4544c05126cdb19431a178314ee1eee9792fb198" translate="yes" xml:space="preserve">
          <source>Dump after block reordering.</source>
          <target state="translated">블록 재정렬 후 덤프.</target>
        </trans-unit>
        <trans-unit id="78c9d4108223d54d2d9b5209aec4c77ba61f990a" translate="yes" xml:space="preserve">
          <source>Dump after branch alignments have been computed.</source>
          <target state="translated">분기 정렬 후 덤프가 계산되었습니다.</target>
        </trans-unit>
        <trans-unit id="becf6aa3d2a32b64f568f0ff4ffede5097942c5f" translate="yes" xml:space="preserve">
          <source>Dump after cleaning up the barrier instructions.</source>
          <target state="translated">배리어 지침을 청소 한 후 덤프하십시오.</target>
        </trans-unit>
        <trans-unit id="4157bd0dc462fb4b9de6813e4b6322c3ce89115d" translate="yes" xml:space="preserve">
          <source>Dump after combining stack adjustments.</source>
          <target state="translated">스택 조정을 결합한 후 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="ca08541014a668445bc90fdf9e0e75729f2449db" translate="yes" xml:space="preserve">
          <source>Dump after common sequence discovery.</source>
          <target state="translated">공통 시퀀스 발견 후 덤프</target>
        </trans-unit>
        <trans-unit id="003a4c3463d2348777de9c3ec96a83fded9a133b" translate="yes" xml:space="preserve">
          <source>Dump after conversion from GCC&amp;rsquo;s &amp;ldquo;flat register file&amp;rdquo; registers to the x87&amp;rsquo;s stack-like registers. This pass is only run on x86 variants.</source>
          <target state="translated">GCC의 &quot;플랫 레지스터 파일&quot;레지스터에서 x87의 스택 형 레지스터로 변환 후 덤프. 이 패스는 x86 변형에서만 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="83008119d9369fbf18b0ada0441c79a07768ec53" translate="yes" xml:space="preserve">
          <source>Dump after conversion of EH handling range regions.</source>
          <target state="translated">EH 처리 범위 영역의 변환 후 덤프.</target>
        </trans-unit>
        <trans-unit id="3bf729ea33ed64d3ed60d59c687162fd5feb227f" translate="yes" xml:space="preserve">
          <source>Dump after converting from cfglayout mode.</source>
          <target state="translated">cfglayout 모드에서 변환 한 후 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="8c3c2b3635d622c5e7ba8ea735eb12810fb32bac" translate="yes" xml:space="preserve">
          <source>Dump after converting to cfglayout mode.</source>
          <target state="translated">cfglayout 모드로 변환 한 후 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="c3336c59217d8a52dec6ae53e20f9f151f5f642d" translate="yes" xml:space="preserve">
          <source>Dump after converting virtual registers to hard registers.</source>
          <target state="translated">가상 레지스터를 하드 레지스터로 변환 한 후 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="9e4924e7d7139d25008b3b0767ee0c48540ad8c8" translate="yes" xml:space="preserve">
          <source>Dump after delayed branch scheduling.</source>
          <target state="translated">지연된 지점 예약 후 덤프</target>
        </trans-unit>
        <trans-unit id="d2764959e209d321913a6a9e66c4ca5ca11ad126" translate="yes" xml:space="preserve">
          <source>Dump after duplicating the computed gotos.</source>
          <target state="translated">계산 된 고 토스를 복제 한 후 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="6e4665a9117fc08d9bbcca5529570f4270193b64" translate="yes" xml:space="preserve">
          <source>Dump after finalization of EH handling code.</source>
          <target state="translated">EH 처리 코드가 완료된 후 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="0bd2968b703fd689e056f9d8a3839eaca5ddccc9" translate="yes" xml:space="preserve">
          <source>Dump after fixing rtl statements that have unsatisfied in/out constraints.</source>
          <target state="translated">입력 / 출력 제약 조건이 만족되지 않는 rtl 문을 수정 한 후 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="1f6440e322c9dbaaa59c98dce4c47af3058d32dc" translate="yes" xml:space="preserve">
          <source>Dump after function inlining.</source>
          <target state="translated">함수 인라인 후 덤프</target>
        </trans-unit>
        <trans-unit id="988226cdeaba5c3515016a8a81c5ff5fb6cd975a" translate="yes" xml:space="preserve">
          <source>Dump after generating the function prologues and epilogues.</source>
          <target state="translated">함수 프롤로그 및 에필로그를 생성 한 후 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="337d4408dd5282e57a077069c98fc55c719caf17" translate="yes" xml:space="preserve">
          <source>Dump after hard register copy propagation.</source>
          <target state="translated">하드 레지스터 복사 전파 후 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="6cfe830bfa04c4483b1574a46bcfd925bca4b994" translate="yes" xml:space="preserve">
          <source>Dump after iterated register allocation.</source>
          <target state="translated">반복 된 레지스터 할당 후 덤프.</target>
        </trans-unit>
        <trans-unit id="1332404cd20a620c3e5eef9263282d44f935e6c1" translate="yes" xml:space="preserve">
          <source>Dump after jump bypassing and control flow optimizations.</source>
          <target state="translated">점프 바이 패스 및 제어 흐름 최적화 후 덤프.</target>
        </trans-unit>
        <trans-unit id="bbeda7ae9b9627b581ee42ee3d7f61a589a6f9b2" translate="yes" xml:space="preserve">
          <source>Dump after live range splitting.</source>
          <target state="translated">라이브 범위 분할 후 덤프</target>
        </trans-unit>
        <trans-unit id="35f1d73925595e51018771690ad76fb0f4a1f233" translate="yes" xml:space="preserve">
          <source>Dump after modulo scheduling. This pass is only run on some architectures.</source>
          <target state="translated">모듈로 스케줄링 후 덤프. 이 패스는 일부 아키텍처에서만 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="d76e4430e6a8233563404db6f071f4d94eacdd64" translate="yes" xml:space="preserve">
          <source>Dump after partitioning hot and cold basic blocks.</source>
          <target state="translated">핫 및 콜드 기본 블록을 분할 한 후 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="93dacaa1e7ab1044d9cdae673b25a3808eaccbc6" translate="yes" xml:space="preserve">
          <source>Dump after performing the machine dependent reorganization pass, if that pass exists.</source>
          <target state="translated">머신 종속 재구성 패스를 수행 한 후 해당 패스가 있으면 덤프하십시오.</target>
        </trans-unit>
        <trans-unit id="b6bdb28476f2b3244c70b802b4bb64b0a7243f10" translate="yes" xml:space="preserve">
          <source>Dump after post-reload optimizations.</source>
          <target state="translated">재로드 후 최적화 후 덤프.</target>
        </trans-unit>
        <trans-unit id="88e826a50b33b907232b8a297fb0c5a8f9b2749b" translate="yes" xml:space="preserve">
          <source>Dump after register renumbering.</source>
          <target state="translated">레지스터 번호를 다시 매긴 후 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="ababff05976fea728752ca7d70fe16f292f0407d" translate="yes" xml:space="preserve">
          <source>Dump after removing redundant mode switches.</source>
          <target state="translated">중복 모드 스위치를 제거한 후 덤프하십시오.</target>
        </trans-unit>
        <trans-unit id="017c4f83a9a4f5ea41d958881b5ab4ae0e8a9034" translate="yes" xml:space="preserve">
          <source>Dump after shortening branches.</source>
          <target state="translated">분기를 단축 한 후 덤프하십시오.</target>
        </trans-unit>
        <trans-unit id="b3771d727095e3610636bea776ecdc1fc695644e" translate="yes" xml:space="preserve">
          <source>Dump after sibling call optimizations.</source>
          <target state="translated">형제 통화 최적화 후 덤프.</target>
        </trans-unit>
        <trans-unit id="c8dbbab140317072ef733bc98b57dcf08d1828c7" translate="yes" xml:space="preserve">
          <source>Dump after sign/zero extension elimination.</source>
          <target state="translated">부호 제거 / 제로 확장 제거 후 덤프.</target>
        </trans-unit>
        <trans-unit id="e9bbcf22fbbd3795374ba7c5550d62449e5abb59" translate="yes" xml:space="preserve">
          <source>Dump after the RTL instruction combination pass.</source>
          <target state="translated">RTL 명령어 조합 통과 후 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="feffc80f8e62ccde9b555546a5afb7ff2768d0f7" translate="yes" xml:space="preserve">
          <source>Dump after the computation of the initial value sets.</source>
          <target state="translated">초기 값 세트 계산 후 덤프.</target>
        </trans-unit>
        <trans-unit id="5bf6c1aae6940dca8add6967093968d70664b454" translate="yes" xml:space="preserve">
          <source>Dump after the initialization of the registers.</source>
          <target state="translated">레지스터 초기화 후 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="d22e8f2d8c89989fe194bf7d0b0983f1d445d944" translate="yes" xml:space="preserve">
          <source>Dump after the peephole pass.</source>
          <target state="translated">들여다 보는 구멍 통과 후 덤프.</target>
        </trans-unit>
        <trans-unit id="9201f61bd4694de8e9a9ab14f3cc717f0cf63945" translate="yes" xml:space="preserve">
          <source>Dump after the second jump optimization.</source>
          <target state="translated">두 번째 점프 최적화 후 덤프.</target>
        </trans-unit>
        <trans-unit id="418c902efcddfdb022a1c7b5bf343ea52897c514" translate="yes" xml:space="preserve">
          <source>Dump after the standalone dead code elimination passes.</source>
          <target state="translated">독립 실행 형 코드 제거가 통과 된 후 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="79702f60e31788035dc7ae01b75a7919074a5bce" translate="yes" xml:space="preserve">
          <source>Dump after variable tracking.</source>
          <target state="translated">변수 추적 후 덤프</target>
        </trans-unit>
        <trans-unit id="907510a3aae3ec8d9be507f0c620d65e786ea7f0" translate="yes" xml:space="preserve">
          <source>Dump all macro definitions, at the end of preprocessing, in addition to normal output.</source>
          <target state="translated">사전 처리가 끝나면 일반 출력 외에 모든 매크로 정의를 덤프하십시오.</target>
        </trans-unit>
        <trans-unit id="c5efd5b60f90b713fff2357c80d7db933b0250ab" translate="yes" xml:space="preserve">
          <source>Dump class hierarchy information. Virtual table information is emitted unless &amp;rsquo;</source>
          <target state="translated">클래스 계층 정보를 덤프합니다. 가상 테이블 정보는 '</target>
        </trans-unit>
        <trans-unit id="7bc6ef641876378e44aa64caddde9a5c6398af12" translate="yes" xml:space="preserve">
          <source>Dump content of records.</source>
          <target state="translated">레코드 내용을 덤프하십시오.</target>
        </trans-unit>
        <trans-unit id="b65d037ae2af66afd4c389367c4bc6cdd9830974" translate="yes" xml:space="preserve">
          <source>Dump debugging information generated during the debug generation phase.</source>
          <target state="translated">디버그 생성 단계에서 생성 된 디버깅 정보를 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="c9b2d27d13ca1550be85a391df7269704a34e8f9" translate="yes" xml:space="preserve">
          <source>Dump debugging information generated during the early debug generation phase.</source>
          <target state="translated">초기 디버그 생성 단계에서 생성 된 디버깅 정보를 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="5d5bde1ac03861eb7f209733ddfd1025c1c70bcf" translate="yes" xml:space="preserve">
          <source>Dump instruction size and location in the assembly code.</source>
          <target state="translated">어셈블리 코드에서 명령 크기 및 위치를 덤프하십시오.</target>
        </trans-unit>
        <trans-unit id="754b569854e205d185835c2d9673785b92b6f32c" translate="yes" xml:space="preserve">
          <source>Dump interface declarations for all classes seen in the source file to a file named</source>
          <target state="translated">소스 파일에 표시된 모든 클래스에 대한 인터페이스 선언을 이름이 지정된 파일로 덤프하십시오.</target>
        </trans-unit>
        <trans-unit id="e881c92154f92df37cd4957d4fba3b310ed362c0" translate="yes" xml:space="preserve">
          <source>Dump out a</source>
          <target state="translated">밖으로 덤프</target>
        </trans-unit>
        <trans-unit id="72d2bf1fd50afe65e57f8ac99ba069fc8e23ed58" translate="yes" xml:space="preserve">
          <source>Dump positions of records.</source>
          <target state="translated">레코드 위치를 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="09ac4bde087663de0f3a006b963a6f5235611c2d" translate="yes" xml:space="preserve">
          <source>Dump the RTL in the assembler output as a comment before each instruction. Also turns on</source>
          <target state="translated">각 명령어 앞에 주석으로 어셈블러 출력에서 ​​RTL을 덤프하십시오. 또한 켜</target>
        </trans-unit>
        <trans-unit id="5d265d5ceeb36fc58845a8b5aa258590ef02cc80" translate="yes" xml:space="preserve">
          <source>Dump the final internal representation (RTL) to &lt;var&gt;file&lt;/var&gt;. If the optional argument is omitted (or if &lt;var&gt;file&lt;/var&gt; is &lt;code&gt;.&lt;/code&gt;), the name of the dump file is determined by appending &lt;code&gt;.gkd&lt;/code&gt; to the compilation output file name.</source>
          <target state="translated">최종 내부 표현 (RTL)을 &lt;var&gt;file&lt;/var&gt; 에 덤프 하십시오 . 선택적 인수가 생략 된 경우 (또는 &lt;var&gt;file&lt;/var&gt; 이 &lt;code&gt;.&lt;/code&gt; 인 경우 ) 덤프 출력 파일의 이름은 컴파일 출력 파일 이름에 &lt;code&gt;.gkd&lt;/code&gt; 를 추가하여 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="6290582c1c9788e12ed9d3f73eafdd3bbcd4abf7" translate="yes" xml:space="preserve">
          <source>Dump the raw internal tree data. This option is applicable to C++ only.</source>
          <target state="translated">원시 내부 트리 데이터를 덤프하십시오. 이 옵션은 C ++에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="5c09bbbb574ea9794181ca0910564f4164221e71" translate="yes" xml:space="preserve">
          <source>Dumps information about call-graph optimization, unused function removal, and inlining decisions.</source>
          <target state="translated">호출 그래프 최적화, 미사용 함수 제거 및 인라인 결정에 대한 정보를 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="c057075d7f6d1311d665f05607d5a1143e726ae5" translate="yes" xml:space="preserve">
          <source>Duplicate instances of a template can be avoided by defining an explicit instantiation in one object file, and preventing the compiler from doing implicit instantiations in any other object files by using an explicit instantiation declaration, using the &lt;code&gt;extern template&lt;/code&gt; syntax:</source>
          <target state="translated">하나의 오브젝트 파일에서 명시 적 인스턴스화를 정의하고 &lt;code&gt;extern template&lt;/code&gt; 구문 을 사용하여 명시 적 인스턴스화 선언을 사용하여 컴파일러가 다른 오브젝트 파일에서 암시 적 인스턴스화를 수행하지 못하게함으로써 템플리트의 중복 인스턴스를 피할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="873001cb1e8e159e206fe4747ed8630083de92b7" translate="yes" xml:space="preserve">
          <source>During its analysis of function bodies, IPA-CP employs alias analysis in order to track values pointed to by function parameters. In order not spend too much time analyzing huge functions, it gives up and consider all memory clobbered after examining</source>
          <target state="translated">기능 본문을 분석하는 동안 IPA-CP는 기능 매개 변수가 가리키는 값을 추적하기 위해 별명 분석을 사용합니다. 거대한 기능을 분석하는 데 너무 많은 시간을 소비하지 않기 위해 검사 후 모든 메모리가 폐기 된 것을 포기하고 고려</target>
        </trans-unit>
        <trans-unit id="35ad8603f50d24cddaa26acc281e43114f0f03d6" translate="yes" xml:space="preserve">
          <source>During the incremental link (by</source>
          <target state="translated">증분 링크 중</target>
        </trans-unit>
        <trans-unit id="6e5d8e172227784c44cef25322c1d84b5b1ed089" translate="yes" xml:space="preserve">
          <source>During the link-time optimization warn about type mismatches in global declarations from different compilation units. Requires</source>
          <target state="translated">링크 타임 최적화 중에 다른 컴파일 단위의 전역 선언에서 형식 불일치에 대해 경고합니다. 필요</target>
        </trans-unit>
        <trans-unit id="1ed8a7568d4927beb8ca9fcc2f434426a2ed3775" translate="yes" xml:space="preserve">
          <source>Dynamic rounding mode. A field in the floating-point control register (&lt;var&gt;fpcr&lt;/var&gt;, see Alpha architecture reference manual) controls the rounding mode in effect. The C library initializes this register for rounding towards plus infinity. Thus, unless your program modifies the &lt;var&gt;fpcr&lt;/var&gt;, &amp;lsquo;</source>
          <target state="translated">동적 반올림 모드. 부동 소수점 제어 레지스터의 필드 ( &lt;var&gt;fpcr&lt;/var&gt; , 알파 아키텍처 참조 설명서 참조)는 실제로 반올림 모드를 제어합니다. C 라이브러리는 +를 무한대로 반올림하기 위해이 레지스터를 초기화합니다. 따라서 프로그램이 &lt;var&gt;fpcr&lt;/var&gt; 을 수정하지 않으면 '</target>
        </trans-unit>
        <trans-unit id="ee61e1d4359d2101e0207f1f6ab138bc105fa253" translate="yes" xml:space="preserve">
          <source>Dynamically allocate condition code registers.</source>
          <target state="translated">조건 코드 레지스터를 동적으로 할당합니다.</target>
        </trans-unit>
        <trans-unit id="e0184adedf913b076626646d3f52c3b49c39ad6d" translate="yes" xml:space="preserve">
          <source>E</source>
          <target state="translated">E</target>
        </trans-unit>
        <trans-unit id="8424e737649ba7f5ce9529e01136274dd622c253" translate="yes" xml:space="preserve">
          <source>E+</source>
          <target state="translated">E+</target>
        </trans-unit>
        <trans-unit id="b86bd135c70e92d6b2051a988af8d8fd3b21cb67" translate="yes" xml:space="preserve">
          <source>E-</source>
          <target state="translated">E-</target>
        </trans-unit>
        <trans-unit id="fa4a7a170f7075560c98a976572cae386b13a240" translate="yes" xml:space="preserve">
          <source>E.g.</source>
          <target state="translated">E.g.</target>
        </trans-unit>
        <trans-unit id="180b58cf69b13102962b17f297dd40af5fac3b7a" translate="yes" xml:space="preserve">
          <source>EAM register &lt;code&gt;mdb&lt;/code&gt;</source>
          <target state="translated">EAM 레지스터 &lt;code&gt;mdb&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4183eec55a2657bd56f5a3f286167e22c41277ca" translate="yes" xml:space="preserve">
          <source>EAM register &lt;code&gt;mdc&lt;/code&gt;</source>
          <target state="translated">EAM 레지스터 &lt;code&gt;mdc&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="042b890a506cb1f86b057af9f2065c60f0543326" translate="yes" xml:space="preserve">
          <source>ESC</source>
          <target state="translated">ESC</target>
        </trans-unit>
        <trans-unit id="ef29ed353f79614b0af0aa06877e0e8365ad41a3" translate="yes" xml:space="preserve">
          <source>EV</source>
          <target state="translated">EV</target>
        </trans-unit>
        <trans-unit id="8404c13b819cbc829893e6fcf7e6b011dc8afafa" translate="yes" xml:space="preserve">
          <source>EXEC register (EXEC_LO and EXEC_HI)</source>
          <target state="translated">EXEC 레지스터 (EXEC_LO 및 EXEC_HI)</target>
        </trans-unit>
        <trans-unit id="3633746b067241666bc462dcfe7a24ff23a8db68" translate="yes" xml:space="preserve">
          <source>Each</source>
          <target state="translated">Each</target>
        </trans-unit>
        <trans-unit id="ec76a07122ba99b0a9685803ebd0fcbd4bc2bfc8" translate="yes" xml:space="preserve">
          <source>Each &amp;lsquo;</source>
          <target state="translated">각 '</target>
        </trans-unit>
        <trans-unit id="7a238e89c65aac1db813f790141cd6a1706499a7" translate="yes" xml:space="preserve">
          <source>Each &lt;var&gt;branch&lt;/var&gt; has the following form:</source>
          <target state="translated">각 &lt;var&gt;branch&lt;/var&gt; 은 다음과 같은 형식으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="3994e33e5e0917632f9e9de329b4a0f3ad3998af" translate="yes" xml:space="preserve">
          <source>Each &lt;var&gt;file&lt;/var&gt; has the following form:</source>
          <target state="translated">각 &lt;var&gt;file&lt;/var&gt; 의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c75857c9773e24edc3bfc44893ae2b0b910e079d" translate="yes" xml:space="preserve">
          <source>Each &lt;var&gt;function&lt;/var&gt; has the following form:</source>
          <target state="translated">각 &lt;var&gt;function&lt;/var&gt; 의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="62acae4631fd900e861a22b9b523800b0a789662" translate="yes" xml:space="preserve">
          <source>Each &lt;var&gt;line&lt;/var&gt; has the following form:</source>
          <target state="translated">각 &lt;var&gt;line&lt;/var&gt; 의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1c50fb88397b0c7346926cd4cd765575f7023e36" translate="yes" xml:space="preserve">
          <source>Each architecture defines additional constraints. These constraints are used by the compiler itself for instruction generation, as well as for &lt;code&gt;asm&lt;/code&gt; statements; therefore, some of the constraints are not particularly useful for &lt;code&gt;asm&lt;/code&gt;. Here is a summary of some of the machine-dependent constraints available on some particular machines; it includes both constraints that are useful for &lt;code&gt;asm&lt;/code&gt; and constraints that aren&amp;rsquo;t. The compiler source file mentioned in the table heading for each architecture is the definitive reference for the meanings of that architecture&amp;rsquo;s constraints.</source>
          <target state="translated">각 아키텍처는 추가 제약 조건을 정의합니다. 이러한 제약 조건은 컴파일러 자체에서 명령 생성 및 &lt;code&gt;asm&lt;/code&gt; 문에 사용됩니다. 따라서 일부 제약 조건은 특히 &lt;code&gt;asm&lt;/code&gt; 에 유용하지 않습니다 . 다음은 특정 머신에서 사용할 수있는 머신 종속 제약 사항을 요약 한 것입니다. &lt;code&gt;asm&lt;/code&gt; 에 유용한 제약과 그렇지 않은 제약을 모두 포함합니다 . 각 아키텍처의 테이블 제목에 언급 된 컴파일러 소스 파일은 해당 아키텍처 제약 조건의 의미에 대한 결정적인 참조입니다.</target>
        </trans-unit>
        <trans-unit id="9a8f7e527e362e2f465669113fa77cfedd4d35d0" translate="yes" xml:space="preserve">
          <source>Each argument to the macro appears only once in the expansion of the macro. This prevents the size of the macro expansion growing exponentially when calls to such macros are nested inside arguments of such macros.</source>
          <target state="translated">매크로에 대한 각 인수는 매크로 확장시 한 번만 나타납니다. 이렇게하면 해당 매크로에 대한 호출이 해당 매크로의 인수 안에 중첩 될 때 매크로 확장의 크기가 기하 급수적으로 커지는 것을 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76b41f32117ccc7bbc36f4b00ab7cb610cec2b62" translate="yes" xml:space="preserve">
          <source>Each argument, with the type encoding, followed by the offset (in bytes) of the argument in the list of parameters.</source>
          <target state="translated">매개 변수 목록에서 인수의 오프셋 (바이트)이 뒤에 오는 인코딩 유형의 각 인수.</target>
        </trans-unit>
        <trans-unit id="e6b2353f285a19086a3e061a5dcfed498d63a240" translate="yes" xml:space="preserve">
          <source>Each identifier is visible from where it is declared until the end of the enclosing block.</source>
          <target state="translated">각 식별자는 선언 된 위치에서 둘러싸는 블록의 끝까지 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="01e3221d2b21a8f447ed5a0ced29ddbea2cbee30" translate="yes" xml:space="preserve">
          <source>Each implementation shall include documentation that identifies all conditionally-supported constructs that it does not support (C++0x 1.4).</source>
          <target state="translated">각 구현에는 지원하지 않는 모든 조건부 지원 구문을 식별하는 문서가 포함되어야합니다 (C ++ 0x 1.4).</target>
        </trans-unit>
        <trans-unit id="701d795fb8ee42f93e3f4a253aa01935ee62e44d" translate="yes" xml:space="preserve">
          <source>Each kind of machine has a default for what &lt;code&gt;char&lt;/code&gt; should be. It is either like &lt;code&gt;unsigned char&lt;/code&gt; by default or like &lt;code&gt;signed char&lt;/code&gt; by default.</source>
          <target state="translated">각 종류의 기계에는 &lt;code&gt;char&lt;/code&gt; 의 기본값 이 있습니다. 기본적으로 &lt;code&gt;unsigned char&lt;/code&gt; 와 같 거나 기본적으로 &lt;code&gt;signed char&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="ef05478f4365f65d0ddfa7b0d492a5a495d01714" translate="yes" xml:space="preserve">
          <source>Each of the following options must be the same when building and using the precompiled header:</source>
          <target state="translated">사전 컴파일 된 헤더를 빌드하고 사용할 때 다음 옵션 각각이 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="12375fa3bc94216fddfb3082e628f5277fd37349" translate="yes" xml:space="preserve">
          <source>Each of these represents a register constraint for an individual register, from r0 to r10.</source>
          <target state="translated">이들 각각은 r0에서 r10까지의 개별 레지스터에 대한 레지스터 제약 조건을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c7c856c52d5df36a325270b79c39dbe4777d924c" translate="yes" xml:space="preserve">
          <source>Each target machine supported by GCC can have its own options&amp;mdash;for example, to allow you to compile for a particular processor variant or ABI, or to control optimizations specific to that machine. By convention, the names of machine-specific options start with &amp;lsquo;</source>
          <target state="translated">GCC가 지원하는 각 대상 시스템에는 고유 한 옵션이있을 수 있습니다. 예를 들어 특정 프로세서 변형 또는 ABI를 위해 컴파일하거나 해당 시스템에 맞는 최적화를 제어 할 수 있습니다. 일반적으로 기계 별 옵션의 이름은 '</target>
        </trans-unit>
        <trans-unit id="e1bf5c8e09d672f359406f3ca337be92c84db460" translate="yes" xml:space="preserve">
          <source>Each variable&amp;rsquo;s value is a list of directories separated by a special character, much like &lt;code&gt;PATH&lt;/code&gt;, in which to look for header files. The special character, &lt;code&gt;PATH_SEPARATOR&lt;/code&gt;, is target-dependent and determined at GCC build time. For Microsoft Windows-based targets it is a semicolon, and for almost all other targets it is a colon.</source>
          <target state="translated">각 변수의 값은 헤더 파일을 찾을 수있는 &lt;code&gt;PATH&lt;/code&gt; 와 같이 특수 문자로 구분 된 디렉토리 목록입니다 . 특수 문자 &lt;code&gt;PATH_SEPARATOR&lt;/code&gt; 는 대상에 따라 다르며 GCC 빌드시 결정됩니다. Microsoft Windows 기반 대상의 경우 세미콜론이고 거의 모든 다른 대상의 경우 콜론입니다.</target>
        </trans-unit>
        <trans-unit id="9fc7669bba8b360ced14bcd0e63ab75ab5c8df7f" translate="yes" xml:space="preserve">
          <source>Embedded statements are not allowed in constant expressions, such as the value of an enumeration constant, the width of a bit-field, or the initial value of a static variable.</source>
          <target state="translated">열거 형 상수 값, 비트 필드 너비 또는 정적 변수의 초기 값과 같은 상수 식에는 포함 문을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="948e9b48ea593e051a4153362a7090d684f2c222" translate="yes" xml:space="preserve">
          <source>Emit (do not emit) RISC-V attribute to record extra information into ELF objects. This feature requires at least binutils 2.32.</source>
          <target state="translated">추가 정보를 ELF 개체에 기록하려면 RISC-V 특성을 방출 (방출하지 않음)하십시오. 이 기능에는 최소한 binutils 2.32가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="070ac08031f3d1c435e4576ba37695a82ca0786d" translate="yes" xml:space="preserve">
          <source>Emit (do not emit) code that allows &lt;code&gt;_mcount&lt;/code&gt; to modify the calling function&amp;rsquo;s return address. When enabled, this option extends the usual &lt;code&gt;_mcount&lt;/code&gt; interface with a new &lt;var&gt;ra-address&lt;/var&gt; parameter, which has type &lt;code&gt;intptr_t *&lt;/code&gt; and is passed in register &lt;code&gt;$12&lt;/code&gt;. &lt;code&gt;_mcount&lt;/code&gt; can then modify the return address by doing both of the following:</source>
          <target state="translated">&lt;code&gt;_mcount&lt;/code&gt; 가 호출 함수의 반환 주소를 수정할 수 있도록하는 코드를 방출 (방출하지 마십시오) 합니다. 활성화되면이 옵션은 &lt;code&gt;intptr_t *&lt;/code&gt; 유형을 가지며 &lt;code&gt;$12&lt;/code&gt; 레지스터로 전달 되는 새로운 &lt;var&gt;ra-address&lt;/var&gt; 매개 변수로 일반적인 &lt;code&gt;_mcount&lt;/code&gt; 인터페이스를 확장합니다 . 그런 다음 &lt;code&gt;_mcount&lt;/code&gt; 는 다음 두 가지를 모두 수행하여 반송 주소를 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff5e30537593e35e64b6a16b2c1bdbe42c087863" translate="yes" xml:space="preserve">
          <source>Emit .gnu_attribute assembly directives to set tag/value pairs in a .gnu.attributes section that specify ABI variations in function parameters or return values.</source>
          <target state="translated">.gnu_attribute 어셈블리 지시문을 내보내 함수 매개 변수 또는 반환 값의 ABI 변형을 지정하는 .gnu.attributes 섹션에서 태그 / 값 쌍을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="20bf9a915993aa5a7a1666c72b879d8cd3f7ac3e" translate="yes" xml:space="preserve">
          <source>Emit &lt;code&gt;.stack_size&lt;/code&gt; directives for each function in the assembly output. This option defaults to off.</source>
          <target state="translated">어셈블리 출력의 각 함수에 대해 &lt;code&gt;.stack_size&lt;/code&gt; 지시문을 방출 하십시오 . 이 옵션은 기본적으로 해제되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f04fa21301da1a9e382b512bcad8e362a751619" translate="yes" xml:space="preserve">
          <source>Emit &lt;code&gt;static&lt;/code&gt; functions into the object file, even if the function is never used.</source>
          <target state="translated">함수가 절대 사용되지 않더라도 &lt;code&gt;static&lt;/code&gt; 함수를 오브젝트 파일로 방출 하십시오.</target>
        </trans-unit>
        <trans-unit id="cb38e0a4e398a1b8eae664d56e6c229db862f612" translate="yes" xml:space="preserve">
          <source>Emit &lt;var&gt;num&lt;/var&gt; NOPs before every other generated instruction.</source>
          <target state="translated">생성 된 다른 모든 명령어 전에 &lt;var&gt;num&lt;/var&gt; NOP를 방출 합니다.</target>
        </trans-unit>
        <trans-unit id="3da3562e4f5b4b2c349aec3c276d4ecf1abb3a7e" translate="yes" xml:space="preserve">
          <source>Emit DWARF unwind info as compiler generated &lt;code&gt;.eh_frame&lt;/code&gt; section instead of using GAS &lt;code&gt;.cfi_*&lt;/code&gt; directives.</source>
          <target state="translated">GAS &lt;code&gt;.cfi_*&lt;/code&gt; 지시문 을 사용하는 대신 컴파일러에서 생성 된 &lt;code&gt;.eh_frame&lt;/code&gt; 섹션 으로 DWARF 해제 정보를 방출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="661cfa361d4a5be25ea38381adeec0544f3162ba" translate="yes" xml:space="preserve">
          <source>Emit a special marker instructing &lt;code&gt;ld(1)&lt;/code&gt; not to statically link in the resulting object file, and allow &lt;code&gt;dyld(1)&lt;/code&gt; to load it in at run time instead. This is used in conjunction with the Fix-and-Continue debugging mode, where the object file in question may be recompiled and dynamically reloaded in the course of program execution, without the need to restart the program itself. Currently, Fix-and-Continue functionality is only available in conjunction with the NeXT runtime on Mac OS X 10.3 and later.</source>
          <target state="translated">결과 객체 파일에서 &lt;code&gt;ld(1)&lt;/code&gt; 가 정적으로 링크하지 않도록 지시하는 특수 마커를 생성하고 대신 &lt;code&gt;dyld(1)&lt;/code&gt; 가 런타임에로드 하도록 허용 합니다. 이는 수정 및 계속 디버깅 모드와 함께 사용되며, 프로그램 자체를 다시 시작할 필요없이 프로그램 실행 과정에서 문제의 오브젝트 파일을 다시 컴파일하고 동적으로 다시로드 할 수 있습니다. 현재 Fix-and-Continue 기능은 Mac OS X 10.3 이상에서 NeXT 런타임과 연계해서 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e8645e36e17a7945813986a8d0a71d3821820d0" translate="yes" xml:space="preserve">
          <source>Emit a warning if the current function exceeds the given frame size. Because this is a compile-time check it doesn&amp;rsquo;t need to be a real problem when the program runs. It is intended to identify functions that most probably cause a stack overflow. It is useful to be used in an environment with limited stack size e.g. the linux kernel.</source>
          <target state="translated">현재 기능이 지정된 프레임 크기를 초과하면 경고가 발생합니다. 이것은 컴파일 타임 검사이기 때문에 프로그램이 실행될 때 실제 문제가 될 필요는 없습니다. 스택 오버플로를 일으킬 가능성이있는 함수를 식별하기위한 것입니다. 스택 크기가 제한된 환경 (예 : Linux 커널)에서 사용하는 것이 유용합니다.</target>
        </trans-unit>
        <trans-unit id="e60a4bf4bc37e66d9947816b7195c8391e4776d0" translate="yes" xml:space="preserve">
          <source>Emit a warning if the function calls &lt;code&gt;alloca&lt;/code&gt; or uses dynamically-sized arrays. This is generally a bad idea with a limited stack size.</source>
          <target state="translated">함수가 &lt;code&gt;alloca&lt;/code&gt; 를 호출 하거나 동적 크기 배열을 사용 하는 경우 경고를 발생시킵니다 . 이것은 일반적으로 제한된 스택 크기로 나쁜 생각입니다.</target>
        </trans-unit>
        <trans-unit id="9b489883dd494ef67ae3146bb7729487672712a9" translate="yes" xml:space="preserve">
          <source>Emit callgraph information.</source>
          <target state="translated">콜 그래프 정보를 방출합니다.</target>
        </trans-unit>
        <trans-unit id="f2b5ec1d50c73d9342d0da2e8de77ea3e8b06bfb" translate="yes" xml:space="preserve">
          <source>Emit debug information for struct-like types only when the base name of the compilation source file matches the base name of file in which the struct is defined.</source>
          <target state="translated">컴파일 소스 파일의 기본 이름이 구조체가 정의 된 파일의 기본 이름과 일치하는 경우에만 구조체와 유사한 유형에 대한 디버그 정보를 방출하십시오.</target>
        </trans-unit>
        <trans-unit id="ea8ad7a3ce89000c68597a212e3b7e178630bf37" translate="yes" xml:space="preserve">
          <source>Emit debug information for struct-like types only when the base name of the compilation source file matches the base name of file in which the type is defined, unless the struct is a template or defined in a system header.</source>
          <target state="translated">구조체가 템플릿이거나 시스템 헤더에 정의되어 있지 않는 한 컴파일 소스 파일의 기본 이름이 형식이 정의 된 파일의 기본 이름과 일치하는 경우에만 구조체와 같은 형식에 대한 디버그 정보를 방출하십시오.</target>
        </trans-unit>
        <trans-unit id="bcf9409c139607d0741250959d86960d9d3fc823" translate="yes" xml:space="preserve">
          <source>Emit debugging information for all symbols and types.</source>
          <target state="translated">모든 심볼 및 유형에 대한 디버깅 정보를 방출합니다.</target>
        </trans-unit>
        <trans-unit id="8a7c3f8e8609e257b077878b6041fc34297f5e52" translate="yes" xml:space="preserve">
          <source>Emit debugging information for symbols that are used. For stabs debugging format, this enables</source>
          <target state="translated">사용되는 심볼에 대한 디버깅 정보를 방출합니다. 찌르기 디버깅 형식의 경우</target>
        </trans-unit>
        <trans-unit id="b01323833aaf7728ad582d052fc8f41810ddeadf" translate="yes" xml:space="preserve">
          <source>Emit extra code to check for buffer overflows, such as stack smashing attacks. This is done by adding a guard variable to functions with vulnerable objects. This includes functions that call &lt;code&gt;alloca&lt;/code&gt;, and functions with buffers larger than 8 bytes. The guards are initialized when a function is entered and then checked when the function exits. If a guard check fails, an error message is printed and the program exits.</source>
          <target state="translated">스택 스매싱 공격과 같은 버퍼 오버플로를 확인하기 위해 추가 코드를 방출합니다. 취약한 객체가있는 함수에 보호 변수를 추가하면됩니다. 여기에는 &lt;code&gt;alloca&lt;/code&gt; 를 호출하는 함수와 8 바이트보다 큰 버퍼가있는 함수가 포함됩니다. 가드는 기능이 입력 될 때 초기화되고 기능이 종료 될 때 확인됩니다. 가드 검사에 실패하면 오류 메시지가 인쇄되고 프로그램이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="141c4b8396ef386665e92dca002cbfbddd934501" translate="yes" xml:space="preserve">
          <source>Emit fix-it hints in a machine-parseable format, suitable for consumption by IDEs. For each fix-it, a line will be printed after the relevant diagnostic, starting with the string &amp;ldquo;fix-it:&amp;rdquo;. For example:</source>
          <target state="translated">IDE에서 사용하기에 적합한 기계 구문 분석 가능한 형식으로 수정 힌트를 방출합니다. 각 수정 사항에 대해 문자열 &quot;fix-it :&quot;로 시작하여 관련 진단 후에 행이 인쇄됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1a5a47bca88794809e7e2a3bb7e287c60614c83b" translate="yes" xml:space="preserve">
          <source>Emit function prologues only before parts of the function that need it, rather than at the top of the function. This flag is enabled by default at</source>
          <target state="translated">함수 프롤로그는 함수의 맨 위가 아니라 함수가 필요한 함수의 일부 전에 만 실행됩니다. 이 플래그는 기본적으로</target>
        </trans-unit>
        <trans-unit id="7a29575e26772eb5ddc3404ae8049245b33348e5" translate="yes" xml:space="preserve">
          <source>Emit location column information into DWARF debugging information, rather than just file and line. This option is enabled by default.</source>
          <target state="translated">위치 열 정보를 파일과 행이 아닌 DWARF 디버깅 정보로 내 보냅니다. 이 옵션은 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="669b4b85cda6e8d55a22a680d295c7c66356a584" translate="yes" xml:space="preserve">
          <source>Emit perf-like colored output for hot lines. Legend of the color scale is printed at the very beginning of the output file.</source>
          <target state="translated">핫라인을위한 성능과 같은 컬러 출력을 방출합니다. 컬러 스케일의 범례는 출력 파일의 맨 처음에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="bf88babe6e871b26c963f43a03a560a58bbbd726" translate="yes" xml:space="preserve">
          <source>Emit statistics about front-end processing at the end of the compilation. This option is supported only by the C++ front end, and the information is generally only useful to the G++ development team.</source>
          <target state="translated">컴파일 종료시 프론트 엔드 처리에 대한 통계를 방출합니다. 이 옵션은 C ++ 프론트 엔드에서만 지원되며 정보는 일반적으로 G ++ 개발 팀에게만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="986149807dd103440d26581e0c8034fe654a931b" translate="yes" xml:space="preserve">
          <source>Emit variables declared &lt;code&gt;static const&lt;/code&gt; when optimization isn&amp;rsquo;t turned on, even if the variables aren&amp;rsquo;t referenced.</source>
          <target state="translated">변수가 참조되지 않더라도 최적화가 설정되지 않은 경우 &lt;code&gt;static const&lt;/code&gt; 선언 된 변수를 방출합니다 .</target>
        </trans-unit>
        <trans-unit id="7039662b9ecdfee8f51909b1bca797f2d5646847" translate="yes" xml:space="preserve">
          <source>Empty. Empty attributes are ignored.</source>
          <target state="translated">빈. 빈 속성은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="dee5764f5fbac8ea9eadf819b59721dd60ce4b7b" translate="yes" xml:space="preserve">
          <source>En_US</source>
          <target state="translated">En_US</target>
        </trans-unit>
        <trans-unit id="20063ad9053289cecaa20ae630ed2dd758282a07" translate="yes" xml:space="preserve">
          <source>Enable</source>
          <target state="translated">Enable</target>
        </trans-unit>
        <trans-unit id="4fa0f6fb6e440f220b80c6c2d4888a44c80062d9" translate="yes" xml:space="preserve">
          <source>Enable &amp;lsquo;</source>
          <target state="translated">'사용</target>
        </trans-unit>
        <trans-unit id="e92d7b5eafccf1d9c2c8bae0da3467a97bfe43eb" translate="yes" xml:space="preserve">
          <source>Enable (disable) an optimization that pairs consecutive load or store instructions to enable load/store bonding. This option is enabled by default but only takes effect when the selected architecture is known to support bonding.</source>
          <target state="translated">로드 / 스토어 본딩을 활성화하기 위해 연속로드 또는 저장 명령어를 쌍으로하는 최적화를 활성화 (비활성화)합니다. 이 옵션은 기본적으로 활성화되어 있지만 선택한 아키텍처가 본딩을 지원하는 것으로 알려진 경우에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="a5876c1f4b70b8a6258f54ff9e4b48ce21c8e2cc" translate="yes" xml:space="preserve">
          <source>Enable (disable) frame header optimization in the o32 ABI. When using the o32 ABI, calling functions will allocate 16 bytes on the stack for the called function to write out register arguments. When enabled, this optimization will suppress the allocation of the frame header if it can be determined that it is unused.</source>
          <target state="translated">o32 ABI에서 프레임 헤더 최적화를 활성화 (비활성화)합니다. o32 ABI를 사용할 때 호출 함수는 호출 된 함수가 레지스터 인수를 기록하기 위해 스택에 16 바이트를 할당합니다. 이 최적화를 사용하면 프레임 헤더가 사용되지 않는 것으로 판별 될 수있는 경우 프레임 헤더 할당이 억제됩니다.</target>
        </trans-unit>
        <trans-unit id="69fa958a8a2e61f2783ede1c3821c1af600c12f1" translate="yes" xml:space="preserve">
          <source>Enable (disable) generation of &lt;code&gt;synci&lt;/code&gt; instructions on architectures that support it. The &lt;code&gt;synci&lt;/code&gt; instructions (if enabled) are generated when &lt;code&gt;__builtin___clear_cache&lt;/code&gt; is compiled.</source>
          <target state="translated">이를 지원하는 아키텍처 에서 &lt;code&gt;synci&lt;/code&gt; 명령 생성을 활성화 (비활성화) 합니다. &lt;code&gt;synci&lt;/code&gt; 때 지침 (활성화 된 경우) 발생 &lt;code&gt;__builtin___clear_cache&lt;/code&gt; 가 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="affa7a90abe6524cdcc085355a0cf87de25de669" translate="yes" xml:space="preserve">
          <source>Enable (disable) the use of the built-in functions that allow direct access to the Hardware Transactional Memory (HTM) instructions that were added in version 2.07 of the PowerPC ISA.</source>
          <target state="translated">PowerPC ISA 버전 2.07에 추가 된 HTM (Hardware Transactional Memory) 명령어에 직접 액세스 할 수있는 내장 기능 사용을 활성화 (비활성화)합니다.</target>
        </trans-unit>
        <trans-unit id="a9d43112761b398944fa6b8aebeadd62b27a6873" translate="yes" xml:space="preserve">
          <source>Enable (disable) use of the &lt;code&gt;%hi()&lt;/code&gt; and &lt;code&gt;%lo()&lt;/code&gt; assembler relocation operators. This option has been superseded by</source>
          <target state="translated">&lt;code&gt;%hi()&lt;/code&gt; 및 &lt;code&gt;%lo()&lt;/code&gt; 어셈블러 재배치 연산자 사용을 활성화 (비활성화)합니다 . 이 옵션은 다음으로 대체되었습니다.</target>
        </trans-unit>
        <trans-unit id="22e717c26fa88a4531e1982fba5a0708a2d39b81" translate="yes" xml:space="preserve">
          <source>Enable (disable) use of the &lt;code&gt;mad&lt;/code&gt;, &lt;code&gt;madu&lt;/code&gt; and &lt;code&gt;mul&lt;/code&gt; instructions, as provided by the R4650 ISA.</source>
          <target state="translated">R4650 ISA에서 제공 하는 &lt;code&gt;mad&lt;/code&gt; , &lt;code&gt;madu&lt;/code&gt; 및 &lt;code&gt;mul&lt;/code&gt; 명령어 사용을 활성화 (비활성화)합니다 .</target>
        </trans-unit>
        <trans-unit id="d7e0884ba3d3cc932c864d47a1ad9e75ce9d3f27" translate="yes" xml:space="preserve">
          <source>Enable (disable) use of the &lt;code&gt;madd&lt;/code&gt; and &lt;code&gt;msub&lt;/code&gt; integer instructions. The default is</source>
          <target state="translated">&lt;code&gt;madd&lt;/code&gt; 및 &lt;code&gt;msub&lt;/code&gt; 정수 명령어 사용을 활성화 (비활성화)합니다 . 디폴트는</target>
        </trans-unit>
        <trans-unit id="fb69f64525577d36a129060c4be04db4c7157197" translate="yes" xml:space="preserve">
          <source>Enable (disable) use of the floating-point multiply-accumulate instructions, when they are available. The default is</source>
          <target state="translated">사용 가능한 경우 부동 소수점 곱셈 누적 명령어 사용을 활성화 (비활성화)합니다. 디폴트는</target>
        </trans-unit>
        <trans-unit id="a72dea94649019bb860dd9ef3c4021f60f45fa32" translate="yes" xml:space="preserve">
          <source>Enable 64-bit AIX ABI and calling convention: 64-bit pointers, 64-bit &lt;code&gt;long&lt;/code&gt; type, and the infrastructure needed to support them. Specifying</source>
          <target state="translated">64 비트 AIX ABI 및 호출 규칙 : 64 비트 포인터, 64 비트 &lt;code&gt;long&lt;/code&gt; 유형 및이를 지원하는 데 필요한 인프라를 사용하십시오. 지정</target>
        </trans-unit>
        <trans-unit id="e8bed769cd5303c03eac96915f98c0018f45868e" translate="yes" xml:space="preserve">
          <source>Enable &lt;code&gt;div&lt;/code&gt; and &lt;code&gt;rem&lt;/code&gt; instructions for ARCv2 cores.</source>
          <target state="translated">ARCv2 코어에 &lt;code&gt;div&lt;/code&gt; 및 &lt;code&gt;rem&lt;/code&gt; 명령어를 활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="2b739befdde9d37b726baa741659e214041a11f0" translate="yes" xml:space="preserve">
          <source>Enable AddressSanitizer for Linux kernel. See &lt;a href=&quot;https://github.com/google/kasan/wiki&quot;&gt;https://github.com/google/kasan/wiki&lt;/a&gt; for more details.</source>
          <target state="translated">Linux 커널 용 AddressSanitizer를 사용하십시오. 자세한 내용은 &lt;a href=&quot;https://github.com/google/kasan/wiki&quot;&gt;https://github.com/google/kasan/wiki&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="dd5750bb548742f5f6797880a8c614d311fe2963" translate="yes" xml:space="preserve">
          <source>Enable AddressSanitizer, a fast memory error detector. Memory access instructions are instrumented to detect out-of-bounds and use-after-free bugs. The option enables</source>
          <target state="translated">빠른 메모리 오류 감지기 인 AddressSanitizer를 활성화하십시오. 메모리 액세스 명령어는 범위를 벗어난 버그와 사용 후 버그를 감지하도록 설계되었습니다. 이 옵션은</target>
        </trans-unit>
        <trans-unit id="b884f9df2c0fdf875f501de19eb4a43163aded4e" translate="yes" xml:space="preserve">
          <source>Enable Advanced SIMD instructions. This also enables floating-point instructions. This is on by default for all possible values for options</source>
          <target state="translated">고급 SIMD 지침을 활성화하십시오. 또한 부동 소수점 명령어도 활성화합니다. 옵션의 모든 가능한 값에 대해서는 기본적으로 켜져 있습니다.</target>
        </trans-unit>
        <trans-unit id="1737ee87e4af9d47c80e040e08ffbf40c4cf4499" translate="yes" xml:space="preserve">
          <source>Enable C-SKY DSP, Enhanced DSP, or Vector DSP instructions, respectively. All of these options default to off.</source>
          <target state="translated">C-SKY DSP, Enhanced DSP 또는 Vector DSP 명령어를 각각 활성화하십시오. 이러한 모든 옵션은 기본적으로 해제되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="460dd2625e669a6da5fd8971a359142b70341354" translate="yes" xml:space="preserve">
          <source>Enable C-SKY security instructions; the default is off.</source>
          <target state="translated">C-SKY 보안 지침을 활성화하십시오. 기본값은 꺼져 있습니다.</target>
        </trans-unit>
        <trans-unit id="be1993c993457eac4e123ff5ca8683dff8eb6707" translate="yes" xml:space="preserve">
          <source>Enable C-SKY trust instructions; the default is off.</source>
          <target state="translated">C-SKY 신뢰 지침을 활성화합니다. 기본값은 꺼져 있습니다.</target>
        </trans-unit>
        <trans-unit id="db19cd91956a3cc7c7ec589751c003754ab24a04" translate="yes" xml:space="preserve">
          <source>Enable CFG-sensitive rematerialization in LRA. Instead of loading values of spilled pseudos, LRA tries to rematerialize (recalculate) values if it is profitable.</source>
          <target state="translated">LRA에서 CFG에 민감한 rematerialization을 활성화하십시오. 유출 된 유사 값을로드하는 대신 LRA는 수익성이있는 경우 값을 다시 구체화 (재 계산)하려고합니다.</target>
        </trans-unit>
        <trans-unit id="3228c63b76a89731a999face742dbc8e98e43fb7" translate="yes" xml:space="preserve">
          <source>Enable CRC extension. This is on by default for</source>
          <target state="translated">CRC 확장을 활성화하십시오. 이것은 기본적으로 켜져 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f57bb69abaacf2d80f6a8ad9ba44e14d8d03b75" translate="yes" xml:space="preserve">
          <source>Enable CRIS-specific verbose debug-related information in the assembly code. This option also has the effect of turning off the &amp;lsquo;</source>
          <target state="translated">어셈블리 코드에서 CRIS 관련 상세 디버그 관련 정보를 활성화하십시오. 이 옵션은 또한 '</target>
        </trans-unit>
        <trans-unit id="a77b829448e4eeb6288384fb17669c5c039a4b5e" translate="yes" xml:space="preserve">
          <source>Enable Crypto extension. This also enables Advanced SIMD and floating-point instructions.</source>
          <target state="translated">암호화 확장을 활성화합니다. 또한 고급 SIMD 및 부동 소수점 명령어도 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="c34f6f6c7e11aa9f0332985736de3e72e193f5ba" translate="yes" xml:space="preserve">
          <source>Enable FP16 extension. This also enables floating-point instructions.</source>
          <target state="translated">FP16 확장을 활성화하십시오. 또한 부동 소수점 명령어도 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="2babb7d5abaf4060eeca52d7ae4316df315816d6" translate="yes" xml:space="preserve">
          <source>Enable FP16 fmla extension. This also enables FP16 extensions and floating-point instructions. This option is enabled by default for</source>
          <target state="translated">FP16 fmla 확장을 활성화하십시오. 또한 FP16 확장 및 부동 소수점 명령어를 사용할 수 있습니다. 이 옵션은 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a8ba9a41b704d15493ebc76a0b1f017540a81f2" translate="yes" xml:space="preserve">
          <source>Enable IPA pass &lt;var&gt;pass&lt;/var&gt;. &lt;var&gt;pass&lt;/var&gt; is the pass name. If the same pass is statically invoked in the compiler multiple times, the pass name should be appended with a sequential number starting from 1.</source>
          <target state="translated">IPA 패스 &lt;var&gt;pass&lt;/var&gt; 활성화합니다 . &lt;var&gt;pass&lt;/var&gt; 는 패스 이름입니다. 동일한 패스가 컴파일러에서 정적으로 여러 번 호출되면 패스 이름에 1부터 시작하는 순차적 번호가 추가되어야합니다.</target>
        </trans-unit>
        <trans-unit id="17d5ca6696a8cdc79b6dc05a7cd14c4945472844" translate="yes" xml:space="preserve">
          <source>Enable Large System Extension instructions. This is on by default for</source>
          <target state="translated">대형 시스템 확장 지시 사항을 사용하십시오. 이것은 기본적으로 켜져 있습니다.</target>
        </trans-unit>
        <trans-unit id="5313db34f510b6a28a51ef561341a7742309082f" translate="yes" xml:space="preserve">
          <source>Enable LeakSanitizer, a memory leak detector. This option only matters for linking of executables and the executable is linked against a library that overrides &lt;code&gt;malloc&lt;/code&gt; and other allocator functions. See &lt;a href=&quot;https://github.com/google/sanitizers/wiki/AddressSanitizerLeakSanitizer&quot;&gt;https://github.com/google/sanitizers/wiki/AddressSanitizerLeakSanitizer&lt;/a&gt; for more details. The run-time behavior can be influenced using the &lt;code&gt;LSAN_OPTIONS&lt;/code&gt; environment variable. The option cannot be combined with</source>
          <target state="translated">메모리 누출 감지기 인 LeakSanitizer를 활성화하십시오. 이 옵션은 실행 파일의 링크에만 중요하며 실행 파일은 &lt;code&gt;malloc&lt;/code&gt; 및 기타 할당 자 기능 을 대체하는 라이브러리에 연결 됩니다. 자세한 내용은 &lt;a href=&quot;https://github.com/google/sanitizers/wiki/AddressSanitizerLeakSanitizer&quot;&gt;https://github.com/google/sanitizers/wiki/AddressSanitizerLeakSanitizer&lt;/a&gt; 를 참조하십시오. &lt;code&gt;LSAN_OPTIONS&lt;/code&gt; 환경 변수를 사용하여 런타임 동작에 영향을 줄 수 있습니다 . 이 옵션은</target>
        </trans-unit>
        <trans-unit id="963f7996b716be1c17df5a79ae31f2f9bb23a517" translate="yes" xml:space="preserve">
          <source>Enable Local Register Allocation. This is still experimental for ARC, so by default the compiler uses standard reload (i.e.</source>
          <target state="translated">로컬 레지스터 할당을 활성화합니다. 이것은 여전히 ​​ARC 실험 중이므로 기본적으로 컴파일러는 표준 재로드를 사용합니다 (예 :</target>
        </trans-unit>
        <trans-unit id="3bd13a89a3ec768d816679409bb63a5907cc342b" translate="yes" xml:space="preserve">
          <source>Enable Local Register Allocation. This is still experimental for FT32, so by default the compiler uses standard reload.</source>
          <target state="translated">로컬 레지스터 할당을 활성화합니다. 이것은 여전히 ​​FT32에서 실험 중이므로 기본적으로 컴파일러는 표준 재로드를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7fa9e4dd118db6c43acdd9765995f0465281818a" translate="yes" xml:space="preserve">
          <source>Enable Local Register Allocation. This is the default for SPARC since GCC 7 so</source>
          <target state="translated">로컬 레지스터 할당을 활성화합니다. 이것이 GCC 7 이후 SPARC의 기본값이므로</target>
        </trans-unit>
        <trans-unit id="89bbfd96b1406df4e9daca603ac86b980c364e5c" translate="yes" xml:space="preserve">
          <source>Enable RTL pass &lt;var&gt;pass&lt;/var&gt;. See</source>
          <target state="translated">RTL 패스 &lt;var&gt;pass&lt;/var&gt; 활성화합니다 . 보다</target>
        </trans-unit>
        <trans-unit id="f44412802c3209f5d9e4e5d01f1b31cdf41ef7c0" translate="yes" xml:space="preserve">
          <source>Enable Round Double Multiply Accumulate instructions. This is on by default for</source>
          <target state="translated">Round Double Multiply Accumulate 명령어를 활성화합니다. 이것은 기본적으로 켜져 있습니다.</target>
        </trans-unit>
        <trans-unit id="1332af3411aa268a3ef4a1b41bc0ae5d1edc2594" translate="yes" xml:space="preserve">
          <source>Enable Scalable Vector Extension instructions. This also enables Advanced SIMD and floating-point instructions.</source>
          <target state="translated">Scalable Vector Extension 지침을 활성화합니다. 또한 고급 SIMD 및 부동 소수점 명령어도 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="082f6e4a45595d5f7a3a2a560115400fb4ee2b89" translate="yes" xml:space="preserve">
          <source>Enable ThreadSanitizer, a fast data race detector. Memory access instructions are instrumented to detect data race bugs. See &lt;a href=&quot;https://github.com/google/sanitizers/wiki#threadsanitizer&quot;&gt;https://github.com/google/sanitizers/wiki#threadsanitizer&lt;/a&gt; for more details. The run-time behavior can be influenced using the &lt;code&gt;TSAN_OPTIONS&lt;/code&gt; environment variable; see &lt;a href=&quot;https://github.com/google/sanitizers/wiki/ThreadSanitizerFlags&quot;&gt;https://github.com/google/sanitizers/wiki/ThreadSanitizerFlags&lt;/a&gt; for a list of supported options. The option cannot be combined with</source>
          <target state="translated">빠른 데이터 레이스 탐지기 인 ThreadSanitizer를 활성화합니다. 메모리 액세스 명령은 데이터 레이스 버그를 감지하도록 설계되었습니다. 자세한 내용은 &lt;a href=&quot;https://github.com/google/sanitizers/wiki#threadsanitizer&quot;&gt;https://github.com/google/sanitizers/wiki#threadsanitizer&lt;/a&gt; 를 참조하십시오. 런타임 동작은 &lt;code&gt;TSAN_OPTIONS&lt;/code&gt; 환경 변수를 사용하여 영향을받을 수 있습니다 . 지원되는 옵션 목록 은 &lt;a href=&quot;https://github.com/google/sanitizers/wiki/ThreadSanitizerFlags&quot;&gt;https://github.com/google/sanitizers/wiki/ThreadSanitizerFlags&lt;/a&gt; 를 참조 하십시오 . 이 옵션은</target>
        </trans-unit>
        <trans-unit id="949a1a6c2112a203d7294b63f617d43e64b4229c" translate="yes" xml:space="preserve">
          <source>Enable UndefinedBehaviorSanitizer, a fast undefined behavior detector. Various computations are instrumented to detect undefined behavior at runtime. Current suboptions are:</source>
          <target state="translated">빠른 정의되지 않은 동작 탐지기 인 UndefinedBehaviorSanitizer를 활성화합니다. 런타임시 정의되지 않은 동작을 감지하기 위해 다양한 계산이 수행됩니다. 현재 하위 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="96f5c056cf8c5a806da05ed8b96789bc0b6d048b" translate="yes" xml:space="preserve">
          <source>Enable all estimate instructions.</source>
          <target state="translated">모든 추정 지침을 활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="df3c7c5cb30d8d0e87829e7d5c48c82259c25cb7" translate="yes" xml:space="preserve">
          <source>Enable all language-specific dumps.</source>
          <target state="translated">모든 언어 별 덤프를 활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="ae518ed7bc949ae822d65bcaeff9c7041fb826a6" translate="yes" xml:space="preserve">
          <source>Enable allocation of values to registers that are clobbered by function calls, by emitting extra instructions to save and restore the registers around such calls. Such allocation is done only when it seems to result in better code.</source>
          <target state="translated">이러한 호출 주위에 레지스터를 저장 및 복원하기위한 추가 명령을 생성하여 함수 호출에 의해 방해되는 레지스터에 값을 할당 할 수 있습니다. 이러한 할당은 더 나은 코드를 얻는 것처럼 보일 때만 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="0a0fd86a97f36ba3d21ddbe6e9254e7a16fbfe18" translate="yes" xml:space="preserve">
          <source>Enable and control dumping of pass statistics in a separate file. The file name is generated by appending a suffix ending in &amp;lsquo;</source>
          <target state="translated">별도의 파일에서 통과 통계 덤프를 활성화하고 제어합니다. 파일 이름은 '로 끝나는 접미사를 추가하여 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="f6804494e75f7aaede40247da0a4be9cdb7a84eb" translate="yes" xml:space="preserve">
          <source>Enable asan allocas/VLAs protection.</source>
          <target state="translated">asan allocas / VLAs 보호를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="61fd83dce0b4c24f54b3d95d0aba14e424d6bcbf" translate="yes" xml:space="preserve">
          <source>Enable automatic template instantiation at link time. This option also implies</source>
          <target state="translated">링크 타임에 자동 템플릿 인스턴스화를 활성화합니다. 이 옵션은 또한</target>
        </trans-unit>
        <trans-unit id="803437b7c125524ce44c25382c66dec8a107376e" translate="yes" xml:space="preserve">
          <source>Enable barrel-shift instructions.</source>
          <target state="translated">배럴 시프트 명령을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="dd1a569881fabce4df110c82ea43f4ea0973b717" translate="yes" xml:space="preserve">
          <source>Enable bbit peephole2.</source>
          <target state="translated">bbit peephole2를 활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="1e317e7bf07e0ef1d8933e0c682ab5ffc4c86dfe" translate="yes" xml:space="preserve">
          <source>Enable buffer overflow detection for global objects. This kind of protection is enabled by default if you are using</source>
          <target state="translated">글로벌 오브젝트에 버퍼 오버 플로우 감지를 사용하십시오. 이러한 종류의 보호는 사용하는 경우 기본적으로 활성화됩니다</target>
        </trans-unit>
        <trans-unit id="0ff2936ea712569b3e61003e75e4a3a94ca881aa" translate="yes" xml:space="preserve">
          <source>Enable buffer overflow detection for memory reads. This kind of protection is enabled by default when using</source>
          <target state="translated">메모리 읽기에 버퍼 오버 플로우 감지를 사용하십시오. 이러한 종류의 보호는 사용할 때 기본적으로 활성화됩니다</target>
        </trans-unit>
        <trans-unit id="c11c559ccc97fad4b1acec42a5bfc66eb0c4fd61" translate="yes" xml:space="preserve">
          <source>Enable buffer overflow detection for memory writes. This kind of protection is enabled by default when using</source>
          <target state="translated">메모리 쓰기에 버퍼 오버 플로우 감지를 사용하십시오. 이러한 종류의 보호는 사용할 때 기본적으로 활성화됩니다</target>
        </trans-unit>
        <trans-unit id="c2ab49f5ce7f3d41ded69401c310972e445af621" translate="yes" xml:space="preserve">
          <source>Enable buffer overflow detection for stack objects. This kind of protection is enabled by default when using</source>
          <target state="translated">스택 객체에 대한 버퍼 오버플로 감지를 활성화합니다. 이러한 종류의 보호는 사용할 때 기본적으로 활성화됩니다</target>
        </trans-unit>
        <trans-unit id="bcd2fc731b6ca5ce8904f8dd2548970ab5fbc93a" translate="yes" xml:space="preserve">
          <source>Enable cache bypass for volatile references.</source>
          <target state="translated">휘발성 참조에 대해 캐시 바이 패스를 활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="dc4973bdf3e5300316096cd00a6ec0877e4070c6" translate="yes" xml:space="preserve">
          <source>Enable code density instructions for ARC EM. This option is on by default for ARC HS.</source>
          <target state="translated">ARC EM에 대한 코드 밀도 명령어를 활성화합니다. 이 옵션은 ARC HS에 기본적으로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f26f87d795cdafd882a37f7cf6106b44c65db50" translate="yes" xml:space="preserve">
          <source>Enable code instrumentation of control-flow transfers to increase program security by checking that target addresses of control-flow transfer instructions (such as indirect function call, function return, indirect jump) are valid. This prevents diverting the flow of control to an unexpected target. This is intended to protect against such threats as Return-oriented Programming (ROP), and similarly call/jmp-oriented programming (COP/JOP).</source>
          <target state="translated">제어 흐름 전송의 코드 계측을 사용하여 제어 흐름 전송 명령의 대상 주소 (예 : 간접 함수 호출, 함수 반환, 간접 점프)가 유효한지 확인하여 프로그램 보안을 강화하십시오. 이렇게하면 제어 흐름이 예기치 않은 대상으로 전환되는 것을 방지 할 수 있습니다. 이는 ROP (Return-Oriented Programming) 및 COP / JOP (Call / Jmp-Oriented Programming)와 같은 위협으로부터 보호하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="b04ea9a65f69d1ed270cd68689d1e12352618b80" translate="yes" xml:space="preserve">
          <source>Enable compact &lt;code&gt;casesi&lt;/code&gt; pattern. This is the default for</source>
          <target state="translated">컴팩트 한 &lt;code&gt;casesi&lt;/code&gt; 패턴을 활성화합니다 . 이것이 기본값입니다</target>
        </trans-unit>
        <trans-unit id="0c57839724a2712f31a1af12f90ff1f615581733" translate="yes" xml:space="preserve">
          <source>Enable constructor/destructor feature.</source>
          <target state="translated">생성자 / 소멸자 기능을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="975ccca01950f97ce533ac489aa7f20116354de0" translate="yes" xml:space="preserve">
          <source>Enable coprocessor instructions; the default is off.</source>
          <target state="translated">보조 프로세서 명령어를 활성화합니다. 기본값은 꺼져 있습니다.</target>
        </trans-unit>
        <trans-unit id="133e4f830a510ad1f945a9a4b1965c6cdd0bf2e0" translate="yes" xml:space="preserve">
          <source>Enable coverage-guided fuzzing code instrumentation. Inserts a call to &lt;code&gt;__sanitizer_cov_trace_pc&lt;/code&gt; into every basic block.</source>
          <target state="translated">적용 범위 안내 퍼지 코드 계측을 활성화합니다. &lt;code&gt;__sanitizer_cov_trace_pc&lt;/code&gt; 에 대한 호출을 모든 기본 블록에 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="787d37d09881b29ce95c34e07e7021e04de78815" translate="yes" xml:space="preserve">
          <source>Enable dataflow guided fuzzing code instrumentation. Inserts a call to &lt;code&gt;__sanitizer_cov_trace_cmp1&lt;/code&gt;, &lt;code&gt;__sanitizer_cov_trace_cmp2&lt;/code&gt;, &lt;code&gt;__sanitizer_cov_trace_cmp4&lt;/code&gt; or &lt;code&gt;__sanitizer_cov_trace_cmp8&lt;/code&gt; for integral comparison with both operands variable or &lt;code&gt;__sanitizer_cov_trace_const_cmp1&lt;/code&gt;, &lt;code&gt;__sanitizer_cov_trace_const_cmp2&lt;/code&gt;, &lt;code&gt;__sanitizer_cov_trace_const_cmp4&lt;/code&gt; or &lt;code&gt;__sanitizer_cov_trace_const_cmp8&lt;/code&gt; for integral comparison with one operand constant, &lt;code&gt;__sanitizer_cov_trace_cmpf&lt;/code&gt; or &lt;code&gt;__sanitizer_cov_trace_cmpd&lt;/code&gt; for float or double comparisons and &lt;code&gt;__sanitizer_cov_trace_switch&lt;/code&gt; for switch statements.</source>
          <target state="translated">데이터 흐름 안내 퍼징 코드 계측을 활성화합니다. 삽입물 호출 &lt;code&gt;__sanitizer_cov_trace_cmp1&lt;/code&gt; , &lt;code&gt;__sanitizer_cov_trace_cmp2&lt;/code&gt; , &lt;code&gt;__sanitizer_cov_trace_cmp4&lt;/code&gt; 또는 &lt;code&gt;__sanitizer_cov_trace_cmp8&lt;/code&gt; 피연산자 변수 또는 둘다와 일체 비교 &lt;code&gt;__sanitizer_cov_trace_const_cmp1&lt;/code&gt; , &lt;code&gt;__sanitizer_cov_trace_const_cmp2&lt;/code&gt; , &lt;code&gt;__sanitizer_cov_trace_const_cmp4&lt;/code&gt; 또는 &lt;code&gt;__sanitizer_cov_trace_const_cmp8&lt;/code&gt; 하나의 피연산자 상수 일체 비교를 &lt;code&gt;__sanitizer_cov_trace_cmpf&lt;/code&gt; 또는 &lt;code&gt;__sanitizer_cov_trace_cmpd&lt;/code&gt; 플로트 또는 더블 및 비교 용 &lt;code&gt;__sanitizer_cov_trace_switch&lt;/code&gt; 스위치 문.</target>
        </trans-unit>
        <trans-unit id="1af777f40a3150cb8ba378da9ca8aedaaf114176" translate="yes" xml:space="preserve">
          <source>Enable deduction of a template type parameter as &lt;code&gt;std::initializer_list&lt;/code&gt; from a brace-enclosed initializer list, i.e.</source>
          <target state="translated">중괄호로 묶인 이니셜 라이저 목록에서 &lt;code&gt;std::initializer_list&lt;/code&gt; 로 템플리트 유형 매개 변수를 추론 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="699beaa366dd56ec35a2702d45f2103e1f67c4dc" translate="yes" xml:space="preserve">
          <source>Enable detection for built-in functions. This kind of protection is enabled by default when using</source>
          <target state="translated">내장 기능을 감지 할 수 있습니다. 이러한 종류의 보호는 사용할 때 기본적으로 활성화됩니다</target>
        </trans-unit>
        <trans-unit id="d53fecd502038ea015d9795c95247289bc1d17ab" translate="yes" xml:space="preserve">
          <source>Enable detection of use-after-return. This kind of protection is enabled by default when using the</source>
          <target state="translated">반환 후 사용 감지를 활성화합니다. 이러한 종류의 보호는 기본적으로</target>
        </trans-unit>
        <trans-unit id="22325b2d023fcd4619a9818a760c689af219e959" translate="yes" xml:space="preserve">
          <source>Enable divide and modulus instructions.</source>
          <target state="translated">나누기 및 모듈러스 명령어를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="6860f8ad3c912d9de1bc957db83ae37ff4acd2f1" translate="yes" xml:space="preserve">
          <source>Enable double load/store operations for ARC HS cores.</source>
          <target state="translated">ARC HS 코어에 대한 이중로드 / 저장 작업을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="f30747b51f35d511a8324038d0ec742af8852f12" translate="yes" xml:space="preserve">
          <source>Enable dumping various statistics about the pass (not honored by every dump option).</source>
          <target state="translated">패스에 대한 다양한 통계를 덤프 할 수 있습니다 (모든 덤프 옵션이 준수하지는 않음).</target>
        </trans-unit>
        <trans-unit id="e61159e5abc9e858d3e7dc68248bef77e7e66569" translate="yes" xml:space="preserve">
          <source>Enable dumps from all OMP (Offloading and Multi Processing) optimizations.</source>
          <target state="translated">모든 OMP (Offloading and Multi Processing) 최적화에서 덤프를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="126e933efdf810fc684f2a27ed78c7f4a97f9db5" translate="yes" xml:space="preserve">
          <source>Enable dumps from all inlining optimizations.</source>
          <target state="translated">모든 인라인 최적화에서 덤프를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="d0c94685fdabc0e86d42873897a8642d64c915a0" translate="yes" xml:space="preserve">
          <source>Enable dumps from all interprocedural optimizations.</source>
          <target state="translated">모든 절차 적 최적화에서 덤프를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="f4a495e6ab007e96555960123af4b2e049e343cb" translate="yes" xml:space="preserve">
          <source>Enable dumps from all loop optimizations.</source>
          <target state="translated">모든 루프 최적화에서 덤프를 활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="da404a0e7964dc17445f8eab1557032d44193e2a" translate="yes" xml:space="preserve">
          <source>Enable dumps from all optimizations. This is a superset of the optimization groups listed above.</source>
          <target state="translated">모든 최적화에서 덤프를 사용하십시오. 이것은 위에 나열된 최적화 그룹의 상위 집합입니다.</target>
        </trans-unit>
        <trans-unit id="82fd093708bd37548045d3e8dc300297a204bb93" translate="yes" xml:space="preserve">
          <source>Enable dumps from all vectorization optimizations.</source>
          <target state="translated">모든 벡터화 최적화에서 덤프를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1ca26bbd13d508b47dfc0ff9aedfd700309873f0" translate="yes" xml:space="preserve">
          <source>Enable emission of special debug stores within HSA kernels which are then read and reported by libgomp plugin. Generation of these stores is disabled by default, use</source>
          <target state="translated">HSA 커널 내에서 특수 디버그 저장소를 생성 한 다음 libgomp 플러그인에서 읽고보고합니다. 이 상점의 생성은 기본적으로 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="92b0248c8870fe4857fc02d723bd02f0d5d911ee" translate="yes" xml:space="preserve">
          <source>Enable exception handling. Generates extra code needed to propagate exceptions. For some targets, this implies GCC generates frame unwind information for all functions, which can produce significant data size overhead, although it does not affect execution. If you do not specify this option, GCC enables it by default for languages like C++ that normally require exception handling, and disables it for languages like C that do not normally require it. However, you may need to enable this option when compiling C code that needs to interoperate properly with exception handlers written in C++. You may also wish to disable this option if you are compiling older C++ programs that don&amp;rsquo;t use exception handling.</source>
          <target state="translated">예외 처리를 활성화하십시오. 예외를 전파하는 데 필요한 추가 코드를 생성합니다. 일부 대상의 경우 GCC가 모든 기능에 대해 프레임 해제 정보를 생성하므로 실행에 영향을 미치지 않지만 상당한 데이터 크기 오버 헤드가 발생할 수 있습니다. 이 옵션을 지정하지 않으면 GCC는 일반적으로 예외 처리가 필요한 C ++와 같은 언어에 대해 기본적으로이 기능을 활성화하고 일반적으로 필요하지 않은 C와 같은 언어에 대해서는 비활성화합니다. 그러나 C ++로 작성된 예외 핸들러와 올바르게 상호 운용해야하는 C 코드를 컴파일 할 때이 옵션을 사용해야합니다. 예외 처리를 사용하지 않는 구형 C ++ 프로그램을 컴파일하는 경우이 옵션을 비활성화 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="291b92d09ee9fff716f8b0be8063487213868bdd" translate="yes" xml:space="preserve">
          <source>Enable floating-point instructions. This is on by default for all possible values for options</source>
          <target state="translated">부동 소수점 명령어를 활성화합니다. 옵션의 모든 가능한 값에 대해서는 기본적으로 켜져 있습니다.</target>
        </trans-unit>
        <trans-unit id="39904b8795d477fdb077dab2b449e06a2b1bd74a" translate="yes" xml:space="preserve">
          <source>Enable garbage collection (GC) in Objective-C and Objective-C++ programs. This option is only available with the NeXT runtime; the GNU runtime has a different garbage collection implementation that does not require special compiler flags.</source>
          <target state="translated">Objective-C 및 Objective-C ++ 프로그램에서 가비지 콜렉션 (GC)을 사용하십시오. 이 옵션은 NeXT 런타임에서만 사용할 수 있습니다. GNU 런타임에는 특별한 컴파일러 플래그가 필요하지 않은 다른 가비지 콜렉션 구현이 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb9fbffb72277aaa3548891dbb1b3b1153391a9e" translate="yes" xml:space="preserve">
          <source>Enable generation of ARC SIMD instructions via target-specific builtins. Only valid for</source>
          <target state="translated">대상별 내장을 통해 ARC SIMD 명령어를 생성 할 수 있습니다. 에 대해서만 유효</target>
        </trans-unit>
        <trans-unit id="64de54a950fd518ed74414f068843cdf15d9e810" translate="yes" xml:space="preserve">
          <source>Enable generation of linemarkers in the preprocessor output that let the compiler know the current working directory at the time of preprocessing. When this option is enabled, the preprocessor emits, after the initial linemarker, a second linemarker with the current working directory followed by two slashes. GCC uses this directory, when it&amp;rsquo;s present in the preprocessed input, as the directory emitted as the current working directory in some debugging information formats. This option is implicitly enabled if debugging information is enabled, but this can be inhibited with the negated form</source>
          <target state="translated">사전 처리시 컴파일러에게 현재 작업 디렉토리를 알려주는 전 처리기 출력에서 ​​라인 마커 생성을 활성화합니다. 이 옵션이 활성화되면 전처리 기는 초기 라인 마커 이후에 현재 작업 디렉토리와 두 개의 슬래시가있는 두 번째 라인 마커를 방출합니다. GCC는 사전 처리 된 입력에있을 때이 디렉토리를 일부 디버깅 정보 형식으로 현재 작업 디렉토리로 생성 한 디렉토리로 사용합니다. 이 옵션은 디버깅 정보가 활성화 된 경우 암시 적으로 활성화되지만 부정 형식으로 억제 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="4f6c2330300990f23059abacc5ecdfe5f1dc0281" translate="yes" xml:space="preserve">
          <source>Enable generation of unaligned load and store instructions.</source>
          <target state="translated">정렬되지 않은로드 및 저장 명령어 생성을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="d26f3d711c1a65ce5ae7ed795204b286f03213ae" translate="yes" xml:space="preserve">
          <source>Enable global interrupt.</source>
          <target state="translated">글로벌 인터럽트를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="2f452efb25c68aa75fbb01603256e25885a6060f" translate="yes" xml:space="preserve">
          <source>Enable handling of OpenACC directives &lt;code&gt;#pragma acc&lt;/code&gt; in C/C++ and &lt;code&gt;!$acc&lt;/code&gt; in Fortran. When</source>
          <target state="translated">C / C ++에서 OpenACC 지시문 &lt;code&gt;#pragma acc&lt;/code&gt; 및 Fortran에서 &lt;code&gt;!$acc&lt;/code&gt; 를 처리 할 수 ​​있습니다. 언제</target>
        </trans-unit>
        <trans-unit id="2ca92300312c8fc1987b891433bf16fbf5350717" translate="yes" xml:space="preserve">
          <source>Enable handling of OpenMP directives &lt;code&gt;#pragma omp&lt;/code&gt; in C/C++ and &lt;code&gt;!$omp&lt;/code&gt; in Fortran. When</source>
          <target state="translated">C / C ++에서 OpenMP 지시문 &lt;code&gt;#pragma omp&lt;/code&gt; 및 Fortran에서 &lt;code&gt;!$omp&lt;/code&gt; 를 처리 할 수 ​​있습니다. 언제</target>
        </trans-unit>
        <trans-unit id="f764c2e81a54602d1c0862a3fd8d88c71c27e5ef" translate="yes" xml:space="preserve">
          <source>Enable handling of OpenMP&amp;rsquo;s SIMD directives with &lt;code&gt;#pragma omp&lt;/code&gt; in C/C++ and &lt;code&gt;!$omp&lt;/code&gt; in Fortran. Other OpenMP directives are ignored.</source>
          <target state="translated">C / C ++에서 &lt;code&gt;#pragma omp&lt;/code&gt; 를 사용 하고 Fortran에서 &lt;code&gt;!$omp&lt;/code&gt; 를 사용하여 OpenMP의 SIMD 지시문을 처리 할 수 있습니다. 다른 OpenMP 지시문은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="325afe18f0a625fafbd824b05e823388581382ad" translate="yes" xml:space="preserve">
          <source>Enable inlining of PLT entries in function calls to functions that are not known to bind locally. It has no effect without</source>
          <target state="translated">로컬로 바인딩되지 않은 함수에 대한 함수 호출에서 PLT 항목 인라인을 활성화합니다. 없이는 효과가 없습니다</target>
        </trans-unit>
        <trans-unit id="26c34a078cd9b46fb0bd484cd235d46f5c53f46b" translate="yes" xml:space="preserve">
          <source>Enable internal consistency checking. The default depends on the compiler configuration.</source>
          <target state="translated">내부 일관성 검사를 활성화합니다. 기본값은 컴파일러 구성에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="b40ab07f35e9ecebed6c91979cb9c80321b2c600" translate="yes" xml:space="preserve">
          <source>Enable interrupt stack instructions; the default is off.</source>
          <target state="translated">인터럽트 스택 명령을 활성화합니다. 기본값은 꺼져 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd58b676d0e4ba40cac9f6295490ba16f891fad5" translate="yes" xml:space="preserve">
          <source>Enable kernel development mode. The</source>
          <target state="translated">커널 개발 모드를 활성화하십시오. 그만큼</target>
        </trans-unit>
        <trans-unit id="6942946c621ac80c436737b7a31ee339272c871d" translate="yes" xml:space="preserve">
          <source>Enable lazy binding of function calls. This option is equivalent to</source>
          <target state="translated">함수 호출의 지연 바인딩을 사용하십시오. 이 옵션은</target>
        </trans-unit>
        <trans-unit id="c3e68f8f7d9888cb3d2e2d66e5738f0a5b7bffcf" translate="yes" xml:space="preserve">
          <source>Enable linker relaxation. Linker relaxation is a process whereby the linker attempts to reduce the size of a program by finding shorter versions of various instructions. Disabled by default.</source>
          <target state="translated">링커 이완을 활성화하십시오. 링커 완화는 링커가 다양한 명령의 짧은 버전을 찾아서 프로그램 크기를 줄이려고하는 프로세스입니다. 기본적으로 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0765f61b18fd9b0cd981b0d3115e02320dabdb7a" translate="yes" xml:space="preserve">
          <source>Enable loop epilogue vectorization using smaller vector size.</source>
          <target state="translated">더 작은 벡터 크기를 사용하여 루프 에필로그 벡터화를 활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="04769dddbdca1dd3af29e66b89d9df24ccfdaae0" translate="yes" xml:space="preserve">
          <source>Enable more detailed dumps (not honored by every dump option). Also include information from the optimization passes.</source>
          <target state="translated">더 자세한 덤프를 활성화하십시오 (모든 덤프 옵션에서 사용하지는 않음). 최적화 단계의 정보도 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="9f3bf571af4fb133a9ed845eaa94347bdecede5e" translate="yes" xml:space="preserve">
          <source>Enable multiply instructions.</source>
          <target state="translated">곱하기 명령어를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="6bdc85b650029e698104b9394508a12676ccb6ec" translate="yes" xml:space="preserve">
          <source>Enable multiprocessor instructions; the default is off.</source>
          <target state="translated">멀티 프로세서 명령어를 활성화합니다. 기본값은 꺼져 있습니다.</target>
        </trans-unit>
        <trans-unit id="dae98acaa0a30e3960a49dff4e2a8d6c6a98eb29" translate="yes" xml:space="preserve">
          <source>Enable nested conditional execution optimizations (default).</source>
          <target state="translated">중첩 된 조건부 실행 최적화를 활성화합니다 (기본값).</target>
        </trans-unit>
        <trans-unit id="0523e9bf64ec1c9137b9f17ae48ec467d581e674" translate="yes" xml:space="preserve">
          <source>Enable optimization of &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; in conditional execution (default).</source>
          <target state="translated">&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 및 &lt;code&gt;||&lt;/code&gt; 최적화 사용 조건부 실행 (기본값)</target>
        </trans-unit>
        <trans-unit id="43cad454d19cf94092ebd0b65a6a9f9c7c63ffa9" translate="yes" xml:space="preserve">
          <source>Enable options usually used for instrumenting application to produce profile useful for later recompilation with profile feedback based optimization. You must use</source>
          <target state="translated">프로파일 피드백 기반 최적화를 통해 나중에 다시 컴파일하는 데 유용한 프로파일을 생성하기 위해 계측 응용 프로그램에 일반적으로 사용되는 옵션을 활성화합니다. 당신은 사용해야합니다</target>
        </trans-unit>
        <trans-unit id="9425982687d5465084a29222f1e8d83738debfbc" translate="yes" xml:space="preserve">
          <source>Enable or disable PC-relative literal loads. With this option literal pools are accessed using a single instruction and emitted after each function. This limits the maximum size of functions to 1MB. This is enabled by default for</source>
          <target state="translated">PC 기준 리터럴로드를 활성화 또는 비활성화합니다. 이 옵션을 사용하면 리터럴 풀이 단일 명령을 사용하여 액세스되고 각 기능 후에 생성됩니다. 최대 기능 크기를 1MB로 제한합니다. 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f213f1158c65a76a7da3e44d0dfb546afeb1c37d" translate="yes" xml:space="preserve">
          <source>Enable or disable emitting &lt;code&gt;mul&lt;/code&gt;, &lt;code&gt;mulx&lt;/code&gt; and &lt;code&gt;div&lt;/code&gt; family of instructions by the compiler. The default is to emit &lt;code&gt;mul&lt;/code&gt; and not emit &lt;code&gt;div&lt;/code&gt; and &lt;code&gt;mulx&lt;/code&gt;.</source>
          <target state="translated">컴파일러가 &lt;code&gt;mul&lt;/code&gt; , &lt;code&gt;mulx&lt;/code&gt; 및 &lt;code&gt;div&lt;/code&gt; 명령을 방출 할 수 있도록 설정하거나 해제 합니다. 기본값은 &lt;code&gt;mul&lt;/code&gt; 을 방출 하고 &lt;code&gt;div&lt;/code&gt; 및 &lt;code&gt;mulx&lt;/code&gt; 를 방출하지 않는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="a0c735f45199333d31330ebeb1c39ca77bf91fab" translate="yes" xml:space="preserve">
          <source>Enable or disable generation of Nios II R2 BMX (bit manipulation) and CDX (code density) instructions. Enabling these instructions also requires</source>
          <target state="translated">Nios II R2 BMX (비트 조작) 및 CDX (코드 밀도) 명령어 생성을 활성화 또는 비활성화합니다. 이 지침을 활성화하려면</target>
        </trans-unit>
        <trans-unit id="e82224b52a26ba48a5b113f09b7fcf8cc858a9c2" translate="yes" xml:space="preserve">
          <source>Enable or disable generation of additional code to track speculative execution through conditional branches. The tracking state can then be used by the compiler when expanding calls to &lt;code&gt;__builtin_speculation_safe_copy&lt;/code&gt; to permit a more efficient code sequence to be generated.</source>
          <target state="translated">조건부 분기를 통한 추론 적 실행을 추적하기 위해 추가 코드 생성을 활성화 또는 비활성화합니다. 그런 다음 &lt;code&gt;__builtin_speculation_safe_copy&lt;/code&gt; 에 대한 호출을 확장 할 때 컴파일러가 추적 상태를 사용 하여보다 효율적인 코드 시퀀스를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8588fb4dd2a8d4f96274711c0f8a3dcffa809a3b" translate="yes" xml:space="preserve">
          <source>Enable or disable the division approximation. This option only has an effect if</source>
          <target state="translated">나누기 근사를 활성화하거나 비활성화합니다. 이 옵션은 다음과 같은 경우에만 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="da4836dd8fd423982dc5d807088aa304a1a7fb40" translate="yes" xml:space="preserve">
          <source>Enable or disable the reciprocal square root approximation. This option only has an effect if</source>
          <target state="translated">역수 제곱근 근사를 활성화 또는 비활성화합니다. 이 옵션은 다음과 같은 경우에만 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6cd2e01bcd6daa77f123d3562e525b53f2208b99" translate="yes" xml:space="preserve">
          <source>Enable or disable the square root approximation. This option only has an effect if</source>
          <target state="translated">제곱근 근사를 활성화 또는 비활성화합니다. 이 옵션은 다음과 같은 경우에만 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6d5d7b63171cb59117cb5da0b6d0ce6a7318345" translate="yes" xml:space="preserve">
          <source>Enable or disable the workaround for the ARM Cortex-A53 erratum number 835769. This involves inserting a NOP instruction between memory instructions and 64-bit integer multiply-accumulate instructions.</source>
          <target state="translated">ARM Cortex-A53 에라타 번호 835769에 대한 대안을 활성화하거나 비활성화합니다. 여기에는 메모리 명령어와 64 비트 정수 곱하기 누산 명령어 사이에 NOP 명령어 삽입이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="1b8e841a5a6d9c6fdc72f5d2c3b9462219761996" translate="yes" xml:space="preserve">
          <source>Enable or disable the workaround for the ARM Cortex-A53 erratum number 843419. This erratum workaround is made at link time and this will only pass the corresponding flag to the linker.</source>
          <target state="translated">ARM Cortex-A53 에라타 번호 843419에 대한 대안을 활성화하거나 비활성화하십시오.이 에라타 대안은 링크 타임에 이루어지며 해당 플래그 만 링커에 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="e8d2c7af76155c379ab5d5ec1df26431744e4771" translate="yes" xml:space="preserve">
          <source>Enable or disable use of &lt;code&gt;CONST16&lt;/code&gt; instructions for loading constant values. The &lt;code&gt;CONST16&lt;/code&gt; instruction is currently not a standard option from Tensilica. When enabled, &lt;code&gt;CONST16&lt;/code&gt; instructions are always used in place of the standard &lt;code&gt;L32R&lt;/code&gt; instructions. The use of &lt;code&gt;CONST16&lt;/code&gt; is enabled by default only if the &lt;code&gt;L32R&lt;/code&gt; instruction is not available.</source>
          <target state="translated">상수 값을로드하기 위해 &lt;code&gt;CONST16&lt;/code&gt; 명령어 사용을 활성화 또는 비활성화 합니다. &lt;code&gt;CONST16&lt;/code&gt; 의 명령은 현재 텐 실리카의 표준 옵션이 아닙니다. 활성화되면 &lt;code&gt;CONST16&lt;/code&gt; 명령어는 항상 표준 &lt;code&gt;L32R&lt;/code&gt; 명령어 대신 사용됩니다 . 의 사용 &lt;code&gt;CONST16&lt;/code&gt; 는 유일한 경우 기본적으로 활성화되어 &lt;code&gt;L32R&lt;/code&gt; 의 명령을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="87ea222da3a42af40a5b89fab414b5a2466d4691" translate="yes" xml:space="preserve">
          <source>Enable or disable use of Branch Likely instructions, regardless of the default for the selected architecture. By default, Branch Likely instructions may be generated if they are supported by the selected architecture. An exception is for the MIPS32 and MIPS64 architectures and processors that implement those architectures; for those, Branch Likely instructions are not be generated by default because the MIPS32 and MIPS64 architectures specifically deprecate their use.</source>
          <target state="translated">선택한 아키텍처의 기본값에 관계없이 분기 가능 명령어 사용을 활성화 또는 비활성화합니다. 기본적으로 Branch Likely 명령어는 선택한 아키텍처에서 지원되는 경우 생성 될 수 있습니다. MIPS32 및 MIPS64 아키텍처와 해당 아키텍처를 구현하는 프로세서는 예외입니다. MIPS32 및 MIPS64 아키텍처에서는 특히 사용이 중단되므로 Branch Likely 명령어는 기본적으로 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6f7c7366f13d27cab3029da7a7c328e36fbdbb28" translate="yes" xml:space="preserve">
          <source>Enable or disable use of fused multiply/add and multiply/subtract instructions in the floating-point option. This has no effect if the floating-point option is not also enabled. Disabling fused multiply/add and multiply/subtract instructions forces the compiler to use separate instructions for the multiply and add/subtract operations. This may be desirable in some cases where strict IEEE 754-compliant results are required: the fused multiply add/subtract instructions do not round the intermediate result, thereby producing results with &lt;em&gt;more&lt;/em&gt; bits of precision than specified by the IEEE standard. Disabling fused multiply add/subtract instructions also ensures that the program output is not sensitive to the compiler&amp;rsquo;s ability to combine multiply and add/subtract operations.</source>
          <target state="translated">부동 소수점 옵션에서 융합 곱셈 / 추가 및 곱하기 / 빼기 명령어 사용을 활성화 또는 비활성화합니다. 부동 소수점 옵션도 사용하지 않으면 효과가 없습니다. 융합 곱하기 / 더하기 및 곱하기 / 빼기 명령어를 비활성화하면 컴파일러는 곱하기 및 더하기 / 빼기 연산에 대해 별도의 명령어를 사용합니다. 이는 엄격한 IEEE 754 호환 결과가 필요한 일부 경우에 바람직 할 수 있습니다. 융합 곱셈 더하기 / 빼기 명령어는 중간 결과를 반올림하지 않으므로 IEEE 표준에 지정된 것보다 &lt;em&gt;더 높은&lt;/em&gt; 정밀도로 결과를 생성합니다 . 융합 곱하기 더하기 / 빼기 명령어를 비활성화하면 프로그램 출력이 곱하기와 더하기 / 빼기 연산을 결합하는 컴파일러의 능력에 민감하지 않게됩니다.</target>
        </trans-unit>
        <trans-unit id="f2d29f4186409cdd0269837c4398f5ca04568394" translate="yes" xml:space="preserve">
          <source>Enable other detailed optimization information (only available in certain passes).</source>
          <target state="translated">다른 상세 최적화 정보를 활성화하십시오 (특정 패스에서만 사용 가능).</target>
        </trans-unit>
        <trans-unit id="338cf5f95ce763c97fbfe82953390f719fbef967" translate="yes" xml:space="preserve">
          <source>Enable parsing of function definitions marked with &lt;code&gt;__GIMPLE&lt;/code&gt;. This is an experimental feature that allows unit testing of GIMPLE passes.</source>
          <target state="translated">&lt;code&gt;__GIMPLE&lt;/code&gt; 로 표시된 함수 정의 구문 분석을 사용하십시오 . 이것은 GIMPLE 패스의 단위 테스트를 허용하는 실험 기능입니다.</target>
        </trans-unit>
        <trans-unit id="f3fcc68975389b930adf047407384e4de7afa86d" translate="yes" xml:space="preserve">
          <source>Enable pre-reload use of the &lt;code&gt;cbranchsi&lt;/code&gt; pattern.</source>
          <target state="translated">&lt;code&gt;cbranchsi&lt;/code&gt; 패턴 의 사전 재로드 사용을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7aca1894ee9ae073c5e50327164b18c35adaf0e4" translate="yes" xml:space="preserve">
          <source>Enable profile feedback-directed optimizations, and the following optimizations, many of which are generally profitable only with profile feedback available:</source>
          <target state="translated">프로파일 피드백 지향 최적화 및 다음 최적화를 사용하십시오. 이러한 최적화 중 다수는 일반적으로 사용 가능한 프로파일 피드백으로 만 수익성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b22143dddf716e38b0694ad2ca7a60178731d02" translate="yes" xml:space="preserve">
          <source>Enable register pressure sensitive insn scheduling before register allocation. This only makes sense when scheduling before register allocation is enabled, i.e. with</source>
          <target state="translated">레지스터 할당 전에 레지스터 압력 감지 기능을 사용하도록 설정합니다. 이것은 레지스터 할당이 활성화되기 전에 스케줄링하는 경우에만 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0432e33b5c323c92ba751b7a0171493013f8ec2" translate="yes" xml:space="preserve">
          <source>Enable sampling-based feedback-directed optimizations, and the following optimizations, many of which are generally profitable only with profile feedback available:</source>
          <target state="translated">샘플링 기반 피드백 지향 최적화 및 다음 최적화를 사용하십시오.이 중 대부분은 일반적으로 사용 가능한 프로파일 피드백으로 만 수익성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9201f89c6bef5151370e84b69891107c6c6b6ade" translate="yes" xml:space="preserve">
          <source>Enable sanitization of local variables to detect use-after-scope bugs. The option sets</source>
          <target state="translated">범위 사용 후 버그를 감지하기 위해 로컬 변수를 살균 할 수 있습니다. 옵션 세트</target>
        </trans-unit>
        <trans-unit id="37f6c409f5734729b3dae114f8c39805c8586c4f" translate="yes" xml:space="preserve">
          <source>Enable showing basic block boundaries (disabled in raw dumps).</source>
          <target state="translated">기본 블록 경계 표시를 활성화합니다 (원시 덤프에서 비활성화 됨).</target>
        </trans-unit>
        <trans-unit id="92f2f939a0618b052e264a0ddefa5df5b7f5e756" translate="yes" xml:space="preserve">
          <source>Enable showing line numbers for statements.</source>
          <target state="translated">문의 줄 번호 표시를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="fd380e6ae8aa5c4cc3cef79ab2ea9026b97f5fbd" translate="yes" xml:space="preserve">
          <source>Enable showing missed optimization information (only available in certain passes).</source>
          <target state="translated">누락 된 최적화 정보 표시를 활성화합니다 (특정 패스에서만 사용 가능).</target>
        </trans-unit>
        <trans-unit id="0d329eb30c66df2a8bec3e0f68514d20ab1b9f92" translate="yes" xml:space="preserve">
          <source>Enable showing optimization information (only available in certain passes).</source>
          <target state="translated">최적화 정보 표시를 활성화합니다 (특정 패스에서만 사용 가능).</target>
        </trans-unit>
        <trans-unit id="f10fcf4d31c6a2b2451c140a8a88da810228a75d" translate="yes" xml:space="preserve">
          <source>Enable showing scalar evolution analysis details.</source>
          <target state="translated">스칼라 진화 분석 세부 사항 표시를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1fa4da5aa5a1df45f7fc17506d98a1fa44e7ec97" translate="yes" xml:space="preserve">
          <source>Enable showing the EH region number holding each statement.</source>
          <target state="translated">각 명세서를 보유한 EH 지역 번호 표시를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="c8bfc39b577282d7a982b0609ca5e212d2e36522" translate="yes" xml:space="preserve">
          <source>Enable showing the tree dump for each statement.</source>
          <target state="translated">각 명령문에 대한 트리 덤프 표시를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c1965c688248d83e371ce542160789f937fce791" translate="yes" xml:space="preserve">
          <source>Enable showing the unique ID (&lt;code&gt;DECL_UID&lt;/code&gt;) for each variable.</source>
          <target state="translated">각 변수에 대해 고유 ID ( &lt;code&gt;DECL_UID&lt;/code&gt; )를 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="2c8e86f5a7b56d45f646fe90ecd4602077ea1bdc" translate="yes" xml:space="preserve">
          <source>Enable showing virtual operands for every statement.</source>
          <target state="translated">모든 명령문에 가상 피연산자를 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7287e0e84335a843622d1b816ceb09d5c05aa749" translate="yes" xml:space="preserve">
          <source>Enable sign extend instructions.</source>
          <target state="translated">부호 확장 명령어를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="2106aa3d9fb87ebeededad40a76e40f9c935fadd" translate="yes" xml:space="preserve">
          <source>Enable software pipelining of innermost loops during selective scheduling. This option has no effect unless one of</source>
          <target state="translated">선택적 스케줄링 중에 가장 안쪽 루프의 소프트웨어 파이프 라이닝을 활성화합니다. 이 옵션은 다음 중 하나가 아니면 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="523a4757398235b8bbb90229026fc9eed157dbee" translate="yes" xml:space="preserve">
          <source>Enable special code to work around file systems which only permit very short file names, such as MS-DOS.</source>
          <target state="translated">MS-DOS와 같이 매우 짧은 파일 이름 만 허용하는 파일 시스템에서 특수 코드가 작동하도록합니다.</target>
        </trans-unit>
        <trans-unit id="3536f2d6d38314050bafe0d10aa71b6595a43eae" translate="yes" xml:space="preserve">
          <source>Enable streaming of mangled types names of C++ types and their unification at link time. This increases size of LTO object files, but enables diagnostics about One Definition Rule violations.</source>
          <target state="translated">C ++ 유형의 맹 글링 된 유형 이름 및 링크시 통합을 스트리밍 할 수 있습니다. 이는 LTO 오브젝트 파일의 크기를 늘리지 만 하나의 정의 규칙 위반에 대한 진단을 가능하게합니다.</target>
        </trans-unit>
        <trans-unit id="07a4edd982a3edcc355177edde03a13c0e84c57f" translate="yes" xml:space="preserve">
          <source>Enable support for &lt;code&gt;char8_t&lt;/code&gt; as adopted for C++2a. This includes the addition of a new &lt;code&gt;char8_t&lt;/code&gt; fundamental type, changes to the types of UTF-8 string and character literals, new signatures for user-defined literals, associated standard library updates, and new &lt;code&gt;__cpp_char8_t&lt;/code&gt; and &lt;code&gt;__cpp_lib_char8_t&lt;/code&gt; feature test macros.</source>
          <target state="translated">C ++ 2a에 채택 된 &lt;code&gt;char8_t&lt;/code&gt; 를 지원합니다 . 여기에는 새로운 &lt;code&gt;char8_t&lt;/code&gt; 기본 유형 추가, UTF-8 문자열 및 문자 리터럴 유형 변경, 사용자 정의 리터럴에 대한 새 서명, 관련 표준 라이브러리 업데이트 및 새로운 &lt;code&gt;__cpp_char8_t&lt;/code&gt; 및 &lt;code&gt;__cpp_lib_char8_t&lt;/code&gt; 기능 테스트 매크로가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="86deb01ddbea29be60b5e5fa22319efa9cd9ea02" translate="yes" xml:space="preserve">
          <source>Enable support for C++17 &lt;code&gt;new&lt;/code&gt; of types that require more alignment than &lt;code&gt;void* ::operator new(std::size_t)&lt;/code&gt; provides. A numeric argument such as &lt;code&gt;-faligned-new=32&lt;/code&gt; can be used to specify how much alignment (in bytes) is provided by that function, but few users will need to override the default of &lt;code&gt;alignof(std::max_align_t)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;void* ::operator new(std::size_t)&lt;/code&gt; 제공하는 것보다 더 정렬이 필요한 C ++ 17의 &lt;code&gt;new&lt;/code&gt; 유형에 대한 지원을 활성화 합니다. &lt;code&gt;-faligned-new=32&lt;/code&gt; 와 같은 숫자 인수를 사용하여 해당 함수에서 제공하는 정렬 (바이트) 수를 지정할 수 있지만 기본 &lt;code&gt;alignof(std::max_align_t)&lt;/code&gt; 를 재정의해야하는 사용자는 거의 없습니다 .</target>
        </trans-unit>
        <trans-unit id="e96dd7f9b95634f8def4cef0c03097523e0ad470" translate="yes" xml:space="preserve">
          <source>Enable support for the C++ Extensions for Concepts Technical Specification, ISO 19217 (2015), which allows code like</source>
          <target state="translated">다음과 같은 코드를 허용하는 Concepts Technical Specification, ISO 19217 (2015)에 대한 C ++ Extensions 지원</target>
        </trans-unit>
        <trans-unit id="f069479e84a1d7c81e6433a171bacdd46bd05f77" translate="yes" xml:space="preserve">
          <source>Enable syntactic support for structured exception handling in Objective-C, similar to what is offered by C++. This option is required to use the Objective-C keywords &lt;code&gt;@try&lt;/code&gt;, &lt;code&gt;@throw&lt;/code&gt;, &lt;code&gt;@catch&lt;/code&gt;, &lt;code&gt;@finally&lt;/code&gt; and &lt;code&gt;@synchronized&lt;/code&gt;. This option is available with both the GNU runtime and the NeXT runtime (but not available in conjunction with the NeXT runtime on Mac OS X 10.2 and earlier).</source>
          <target state="translated">C ++에서 제공하는 것과 유사한 Objective-C의 구조적 예외 처리에 대한 구문 지원을 사용하십시오. 이 옵션은 Objective-C 키워드 &lt;code&gt;@try&lt;/code&gt; , &lt;code&gt;@throw&lt;/code&gt; , &lt;code&gt;@catch&lt;/code&gt; , &lt;code&gt;@finally&lt;/code&gt; 및 &lt;code&gt;@synchronized&lt;/code&gt; 를 사용하는 데 필요합니다 . 이 옵션은 GNU 런타임과 NeXT 런타임에서 모두 사용할 수 있습니다 (Mac OS X 10.2 및 이전 버전에서는 NeXT 런타임과 함께 사용할 수 없음).</target>
        </trans-unit>
        <trans-unit id="2d795a0556dc7d4b23ca50c7c054a8e91a0bb9da" translate="yes" xml:space="preserve">
          <source>Enable the Armv8-a Execution and Data Prediction Restriction instructions. This option is only to enable the extension at the assembler level and does not affect code generation. This option is enabled by default for</source>
          <target state="translated">Armv8-a 실행 및 데이터 예측 제한 지침을 활성화하십시오. 이 옵션은 어셈블러 수준에서 확장을 활성화하기위한 것일뿐 코드 생성에는 영향을 미치지 않습니다. 이 옵션은 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d449b6d30f1777aba3aa927c43beb1ba1eca16be" translate="yes" xml:space="preserve">
          <source>Enable the Armv8-a Speculation Barrier instruction. This option is only to enable the extension at the assembler level and does not affect code generation. This option is enabled by default for</source>
          <target state="translated">Armv8-a Speculation Barrier 명령어를 활성화합니다. 이 옵션은 어셈블러 수준에서 확장을 활성화하기위한 것일뿐 코드 생성에는 영향을 미치지 않습니다. 이 옵션은 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f3b4e86290c1a4d9bac5d679d03a802d662a426" translate="yes" xml:space="preserve">
          <source>Enable the Armv8-a Speculative Store Bypass Safe instruction. This option is only to enable the extension at the assembler level and does not affect code generation. This option is enabled by default for</source>
          <target state="translated">Armv8-a 추측 저장소 우회 안전 명령어를 활성화합니다. 이 옵션은 어셈블러 수준에서 확장을 활성화하기위한 것일뿐 코드 생성에는 영향을 미치지 않습니다. 이 옵션은 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb4dff47dd10c4d2d29138894fb337bf731a4703" translate="yes" xml:space="preserve">
          <source>Enable the Armv8-a aes and pmull crypto extension. This also enables Advanced SIMD instructions.</source>
          <target state="translated">Armv8-a aes 및 pmull 암호화 확장을 활성화합니다. 또한 고급 SIMD 명령어도 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="e878790ea268c6c3c0f09ca24b1f8d32605101d6" translate="yes" xml:space="preserve">
          <source>Enable the Armv8-a sha2 crypto extension. This also enables Advanced SIMD instructions.</source>
          <target state="translated">armv8-a sha2 암호화 확장을 활성화하십시오. 또한 고급 SIMD 명령어도 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="712d78d3897110fb983a6b1ce64ceb649bbc8b13" translate="yes" xml:space="preserve">
          <source>Enable the Armv8.5-a Memory Tagging Extensions. This option is only to enable the extension at the assembler level and does not affect code generation.</source>
          <target state="translated">Armv8.5-a 메모리 태그 확장을 활성화하십시오. 이 옵션은 어셈블러 수준에서 확장을 활성화하기위한 것일뿐 코드 생성에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="95fc60e33111a67c5486993a8b351f8b44d07966" translate="yes" xml:space="preserve">
          <source>Enable the Armv8.5-a Random Number instructions. This option is only to enable the extension at the assembler level and does not affect code generation.</source>
          <target state="translated">Armv8.5-a 난수 명령어를 활성화합니다. 이 옵션은 어셈블러 수준에서 확장을 활성화하기위한 것일뿐 코드 생성에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5baad961c199027af6ce41f297ba396c80d7b6e4" translate="yes" xml:space="preserve">
          <source>Enable the Dot Product extension. This also enables Advanced SIMD instructions.</source>
          <target state="translated">Dot Product 확장을 활성화하십시오. 또한 고급 SIMD 명령어도 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="75d41529d8ccf751d43eb43b131c2899752ea6dc" translate="yes" xml:space="preserve">
          <source>Enable the P0136 adjustment to the semantics of C++11 constructor inheritance. This is part of C++17 but also considered to be a Defect Report against C++11 and C++14. This flag is enabled by default unless</source>
          <target state="translated">C ++ 11 생성자 상속의 시맨틱에 P0136 조정을 사용하십시오. 이것은 C ++ 17의 일부이지만 C ++ 11 및 C ++ 14에 대한 결함 보고서로 간주됩니다. 이 플래그는 기본적으로 활성화되어 있습니다</target>
        </trans-unit>
        <trans-unit id="3336547cc155fdebeb020d2a6fd267e14851b493" translate="yes" xml:space="preserve">
          <source>Enable the P0522 resolution to Core issue 150, template template parameters and default arguments: this allows a template with default template arguments as an argument for a template template parameter with fewer template parameters. This flag is enabled by default for</source>
          <target state="translated">핵심 문제 150, 템플릿 템플릿 매개 변수 및 기본 인수에 대한 P0522 해상도를 활성화합니다. 이렇게하면 기본 템플릿 인수가있는 템플릿이 템플릿 매개 변수가 적은 템플릿 템플릿 매개 변수의 인수로 사용할 수 있습니다. 이 플래그는 기본적으로 활성화되어 있습니다</target>
        </trans-unit>
        <trans-unit id="e10cb464cd66cc6979f0f2bd645896f8d79b1002" translate="yes" xml:space="preserve">
          <source>Enable the RcPc extension. This does not change code generation from GCC, but is passed on to the assembler, enabling inline asm statements to use instructions from the RcPc extension.</source>
          <target state="translated">RcPc 확장을 활성화하십시오. 이것은 GCC에서 코드 생성을 변경하지 않지만 인라인 asm 문이 RcPc 확장의 명령을 사용할 수 있도록 어셈블러로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="b8bb0e2cd28800659cbb25749c903e1e45881bcd" translate="yes" xml:space="preserve">
          <source>Enable the Statistical Profiling extension. This option is only to enable the extension at the assembler level and does not affect code generation.</source>
          <target state="translated">통계 프로파일 링 확장을 사용하십시오. 이 옵션은 어셈블러 수준에서 확장을 활성화하기위한 것일뿐 코드 생성에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d2bf0d0b92eedbfd9d708906c85f1c2c0761dac3" translate="yes" xml:space="preserve">
          <source>Enable the approximation for scalar division.</source>
          <target state="translated">스칼라 나누기에 대한 근사값을 활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="089b193263b191426125d1b838990e7a8cad6bd6" translate="yes" xml:space="preserve">
          <source>Enable the approximation for scalar square root.</source>
          <target state="translated">스칼라 제곱근에 대한 근사값을 활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="9c93085948ceb9475fc7f62f768a72b094e0ccf8" translate="yes" xml:space="preserve">
          <source>Enable the approximation for vectorized division.</source>
          <target state="translated">벡터화 된 나눗셈에 대한 근사치를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="57c9384569cf978709f6ae7436442c4140ae097a" translate="yes" xml:space="preserve">
          <source>Enable the approximation for vectorized square root.</source>
          <target state="translated">벡터화 된 제곱근에 대한 근사를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="a491c3894437f3620a7562cbc06a8ae940a33c10" translate="yes" xml:space="preserve">
          <source>Enable the built-in global declarations</source>
          <target state="translated">내장 전역 선언 사용</target>
        </trans-unit>
        <trans-unit id="2237d50ade0b28ca43195c6d9a72499aa22da748" translate="yes" xml:space="preserve">
          <source>Enable the compiler to directly use a symbol name as an address in a load/store instruction, without first loading it into a register. Typically, the use of this option generates larger programs, which run faster than when the option isn&amp;rsquo;t used. However, the results vary from program to program, so it is left as a user option, rather than being permanently enabled.</source>
          <target state="translated">컴파일러가 심볼 이름을 레지스터에 먼저로드하지 않고로드 / 저장 명령어의 주소로 직접 사용할 수 있도록합니다. 일반적으로이 옵션을 사용하면 옵션을 사용하지 않을 때보 다 더 빠르게 실행되는 더 큰 프로그램이 생성됩니다. 그러나 결과는 프로그램마다 다르므로 영구적으로 활성화되지 않고 사용자 옵션으로 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="41ed1ab2ec5c1611d830306ad10031d9f9977d65" translate="yes" xml:space="preserve">
          <source>Enable the critical-path heuristic in the scheduler. This heuristic favors instructions on the critical path. This is enabled by default when scheduling is enabled, i.e. with</source>
          <target state="translated">스케줄러에서 임계 경로 휴리스틱을 활성화하십시오. 이 휴리스틱은 중요한 경로에 대한 지침을 선호합니다. 스케줄링이 활성화 된 경우 기본적으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="4067ddde2438b48af6e32a24a3e86763ffbd4275" translate="yes" xml:space="preserve">
          <source>Enable the default instructions, equivalent to</source>
          <target state="translated">기본 명령어를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="8f1e0508bfc454c7d53eb8b99b0581386011e857" translate="yes" xml:space="preserve">
          <source>Enable the dependent-count heuristic in the scheduler. This heuristic favors the instruction that has more instructions depending on it. This is enabled by default when scheduling is enabled, i.e. with</source>
          <target state="translated">스케줄러에서 종속 카운트 휴리스틱을 활성화하십시오. 이 휴리스틱은 명령에 따라 더 많은 명령이있는 명령을 선호합니다. 스케줄링이 활성화 된 경우 기본적으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="507033c0f31508a95a83480597cd9ac155e65d9c" translate="yes" xml:space="preserve">
          <source>Enable the documented workaround for the back-to-back store errata of the GR712RC processor.</source>
          <target state="translated">GR712RC 프로세서의 백투백 저장소 정오표에 대해 문서화 된 해결책을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="eef2a052e4462aff6add94764479243457e98b05" translate="yes" xml:space="preserve">
          <source>Enable the documented workaround for the back-to-back store errata of the UT699E/UT700 processor.</source>
          <target state="translated">UT699E / UT700 프로세서의 백투백 저장소 정오표에 대해 문서화 된 해결책을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="decf2a901923b7e9eb5ca1ab92693295f143a06a" translate="yes" xml:space="preserve">
          <source>Enable the documented workaround for the single erratum of the Atmel AT697F processor (which corresponds to erratum #13 of the AT697E processor).</source>
          <target state="translated">Atmel AT697F 프로세서의 단일 정오표 (AT697E 프로세서의 정오표 # 13에 해당)에 대해 문서화 된 해결 방법을 활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="bcb5bb2598740b13546a58b17f6d5aa7c7ba6853" translate="yes" xml:space="preserve">
          <source>Enable the documented workarounds for the floating-point errata and the data cache nullify errata of the UT699 processor.</source>
          <target state="translated">부동 소수점 정오표 및 데이터 캐시에 대해 문서화 된 임시 해결책을 사용 가능하게하여 UT699 프로세서의 정오표를 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="43eeb910cdee4c766507663e6e771a799fe37d3f" translate="yes" xml:space="preserve">
          <source>Enable the double-precision reciprocal approximation instructions.</source>
          <target state="translated">배정도 역 근사 명령어를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="446e6f12ce2775419c21aa646c548678ff1569c1" translate="yes" xml:space="preserve">
          <source>Enable the double-precision reciprocal square root approximation instructions.</source>
          <target state="translated">배정도 역 제곱근 근사 명령어를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="71718fe9aa5b48da1b26c519c152f829f75fb0c0" translate="yes" xml:space="preserve">
          <source>Enable the extended &lt;code&gt;lrw&lt;/code&gt; instruction. This option defaults to on for CK801 and off otherwise.</source>
          <target state="translated">확장 된 &lt;code&gt;lrw&lt;/code&gt; 명령어를 활성화하십시오 . 이 옵션의 기본값은 CK801의 경우 on이고 그렇지 않은 경우 off입니다.</target>
        </trans-unit>
        <trans-unit id="26a17bc6f3de31676776135a782cd9c993e95087" translate="yes" xml:space="preserve">
          <source>Enable the generation of conditional moves.</source>
          <target state="translated">조건부 이동 생성을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="04969a109a871e39815667dea2edea4731968533" translate="yes" xml:space="preserve">
          <source>Enable the group heuristic in the scheduler. This heuristic favors the instruction that belongs to a schedule group. This is enabled by default when scheduling is enabled, i.e. with</source>
          <target state="translated">스케줄러에서 그룹 휴리스틱을 활성화하십시오. 이 휴리스틱은 스케줄 그룹에 속하는 명령을 선호합니다. 스케줄링이 활성화 된 경우 기본적으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="74416a1c4632bd2c9719e7f267cc78921917bec4" translate="yes" xml:space="preserve">
          <source>Enable the identity transformation for graphite. For every SCoP we generate the polyhedral representation and transform it back to gimple. Using</source>
          <target state="translated">흑연에 대한 항등 변환을 활성화합니다. 모든 SCoP에 대해 우리는 다면체 표현을 생성하고 다시 여드름으로 변환합니다. 사용</target>
        </trans-unit>
        <trans-unit id="d52969e42d36857a708d794bd442398a6f2b1d5e" translate="yes" xml:space="preserve">
          <source>Enable the isl based loop nest optimizer. This is a generic loop nest optimizer based on the Pluto optimization algorithms. It calculates a loop structure optimized for data-locality and parallelism. This option is experimental.</source>
          <target state="translated">isl 기반 루프 네스트 옵티 마이저를 사용하십시오. 이것은 Pluto 최적화 알고리즘에 기반한 일반적인 루프 네스트 최적화 프로그램입니다. 데이터 지역 및 병렬 처리에 최적화 된 루프 구조를 계산합니다. 이 옵션은 실험적입니다.</target>
        </trans-unit>
        <trans-unit id="08b7ee5bf2b0eaab5c12a44d79b227e23ee0c0f5" translate="yes" xml:space="preserve">
          <source>Enable the last-instruction heuristic in the scheduler. This heuristic favors the instruction that is less dependent on the last instruction scheduled. This is enabled by default when scheduling is enabled, i.e. with</source>
          <target state="translated">스케줄러에서 마지막 명령 휴리스틱을 활성화하십시오. 이 휴리스틱은 마지막으로 예약 된 명령에 덜 의존하는 명령을 선호합니다. 스케줄링이 활성화 된 경우 기본적으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="dc56e6084e464db3d7d083e493fb69fc336bcfc3" translate="yes" xml:space="preserve">
          <source>Enable the optimization pass in the HP-UX linker. Note this makes symbolic debugging impossible. It also triggers a bug in the HP-UX 8 and HP-UX 9 linkers in which they give bogus error messages when linking some programs.</source>
          <target state="translated">HP-UX 링커에서 최적화 패스를 활성화하십시오. 이로 인해 기호 디버깅이 불가능합니다. 또한 일부 프로그램을 연결할 때 가짜 오류 메시지를 표시하는 HP-UX 8 및 HP-UX 9 링커에서 버그를 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="8008915ad05d64b6cc01c8698eac6fdda560f6c1" translate="yes" xml:space="preserve">
          <source>Enable the rank heuristic in the scheduler. This heuristic favors the instruction belonging to a basic block with greater size or frequency. This is enabled by default when scheduling is enabled, i.e. with</source>
          <target state="translated">스케줄러에서 순위 휴리스틱을 활성화하십시오. 이 휴리스틱은 더 큰 크기 나 주파수를 가진 기본 블록에 속하는 명령을 선호합니다. 스케줄링이 활성화 된 경우 기본적으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="e6ed1ceef09b312da3bb73bea4902c46d06845e0" translate="yes" xml:space="preserve">
          <source>Enable the reciprocal approximation instructions for both single and double precision.</source>
          <target state="translated">단 정밀도와 배정 밀도에 대해 역 근사 명령어를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="4c8e53d3299e21b3cf3fba9ff55c2082c7b6b1ec" translate="yes" xml:space="preserve">
          <source>Enable the reciprocal square root approximation instructions for both single and double precision.</source>
          <target state="translated">단 정밀도와 배정 밀도 모두에 대해 상호 제곱근 근사 명령어를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="21fb72c5396788f3586c523b20f25c7cd0196802" translate="yes" xml:space="preserve">
          <source>Enable the sha512 and sha3 crypto extension. This also enables Advanced SIMD instructions. Use of this option with architectures prior to Armv8.2-A is not supported.</source>
          <target state="translated">sha512 및 sha3 암호화 확장을 사용하십시오. 또한 고급 SIMD 명령어도 활성화합니다. Armv8.2-A 이전의 아키텍처에서는이 옵션을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ac17a049cdd1860b9740d6573dbf1dae4507b37b" translate="yes" xml:space="preserve">
          <source>Enable the single-precision reciprocal approximation instructions.</source>
          <target state="translated">단 정밀도 역 근사 명령어를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="a4aef85fc3ef145e7cf3738dcc41b55cc33d82a4" translate="yes" xml:space="preserve">
          <source>Enable the single-precision reciprocal square root approximation instructions.</source>
          <target state="translated">단 정밀도 역 근사 근사 명령을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="0a29cdf0e1f32dd82e6b20680fbd0f552bb364b2" translate="yes" xml:space="preserve">
          <source>Enable the sm3 and sm4 crypto extension. This also enables Advanced SIMD instructions. Use of this option with architectures prior to Armv8.2-A is not supported.</source>
          <target state="translated">sm3 및 sm4 암호화 확장을 활성화하십시오. 또한 고급 SIMD 명령어도 활성화합니다. Armv8.2-A 이전의 아키텍처에서는이 옵션을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="cab5f01ba7747ba0641df8f437ad352196c1c6d3" translate="yes" xml:space="preserve">
          <source>Enable the speculative instruction heuristic in the scheduler. This heuristic favors speculative instructions with greater dependency weakness. This is enabled by default when scheduling is enabled, i.e. with</source>
          <target state="translated">스케줄러에서 추론 적 명령 휴리스틱을 활성화합니다. 이 휴리스틱은 더 큰 의존성 약점을 가진 투기 명령을 선호합니다. 스케줄링이 활성화 된 경우 기본적으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="e847a09656f326765748affab74d130a0fbbbfb3" translate="yes" xml:space="preserve">
          <source>Enable the use (disable) of the built-in functions that allow direct access to the cryptographic instructions that were added in version 2.07 of the PowerPC ISA.</source>
          <target state="translated">PowerPC ISA 버전 2.07에 추가 된 암호화 명령어에 직접 액세스 할 수있는 내장 기능을 사용 (사용 안함)합니다.</target>
        </trans-unit>
        <trans-unit id="0beb7325ebbd427ff6f653a5586006076fc19189" translate="yes" xml:space="preserve">
          <source>Enable the use of &lt;code&gt;GPREL&lt;/code&gt; relocations in the FDPIC ABI for data that is known to be in read-only sections. It&amp;rsquo;s enabled by default, except for</source>
          <target state="translated">읽기 전용 섹션에있는 데이터에 대해 FDPIC ABI에서 &lt;code&gt;GPREL&lt;/code&gt; 재배치를 사용할 수 있습니다. 다음을 제외하고 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b3e38bf3ad012b6637b58a91ae68d4399ef997c" translate="yes" xml:space="preserve">
          <source>Enable the use of a minimum runtime environment - no static initializers or constructors. This is intended for memory-constrained devices. The compiler includes special symbols in some objects that tell the linker and runtime which code fragments are required.</source>
          <target state="translated">정적 이니셜 라이저 또는 생성자가없는 최소 런타임 환경을 사용하십시오. 이것은 메모리가 제한된 장치를위한 것입니다. 컴파일러에는 링커와 런타임에 필요한 코드 조각을 알려주는 특수 기호가 일부 객체에 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e3906c56ec37b4268552279d6414d35519910f2" translate="yes" xml:space="preserve">
          <source>Enable the use of assembler directives only GAS understands.</source>
          <target state="translated">GAS 만 이해하는 어셈블러 지시문 사용을 활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="8315949440093bd19b322b38da5ef593bd5c1273" translate="yes" xml:space="preserve">
          <source>Enable the use of bit manipulation instructions on SH2A.</source>
          <target state="translated">SH2A에서 비트 조작 명령을 사용하도록 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="776b7d037afae7efec8fa9845c5ffbd3bad3e0de" translate="yes" xml:space="preserve">
          <source>Enable the use of conditional execution (default).</source>
          <target state="translated">조건부 실행 사용을 활성화합니다 (기본값).</target>
        </trans-unit>
        <trans-unit id="3f92036c53e4d3d87aa05d99ffc56331dbaf7cbe" translate="yes" xml:space="preserve">
          <source>Enable the use of conditional set instructions (default).</source>
          <target state="translated">조건부 설정 명령어 사용을 활성화합니다 (기본값).</target>
        </trans-unit>
        <trans-unit id="f02a7f12f7eb0e41accd67fcdeeacad0f7a7fbae" translate="yes" xml:space="preserve">
          <source>Enable the use of conditional-move instructions (default).</source>
          <target state="translated">조건부 이동 명령어 사용을 활성화합니다 (기본값).</target>
        </trans-unit>
        <trans-unit id="8bd8c14864a3dc22ad6416f43c205d177280cc14" translate="yes" xml:space="preserve">
          <source>Enable the use of indexed loads. This can be problematic because some optimizers then assume that indexed stores exist, which is not the case.</source>
          <target state="translated">인덱싱 된로드 사용을 활성화합니다. 일부 최적화 프로그램은 인덱싱 된 저장소가 존재한다고 가정하기 때문에 문제가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa24f968931ae6f6108870656a7843c7774cc339" translate="yes" xml:space="preserve">
          <source>Enable the use of multiply-accumulate instructions. Disabled by default.</source>
          <target state="translated">곱하기 누적 명령어 사용을 활성화합니다. 기본적으로 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7a1f017f17fab4284673c060b8b2143eec98325" translate="yes" xml:space="preserve">
          <source>Enable the use of odd-numbered single-precision floating-point registers for the o32 ABI. This is the default for processors that are known to support these registers. When using the o32 FPXX ABI,</source>
          <target state="translated">o32 ABI에 홀수의 단 정밀도 부동 소수점 레지스터를 사용할 수 있습니다. 이 레지스터를 지원하는 것으로 알려진 프로세서의 기본값입니다. o32 FPXX ABI를 사용하는 경우</target>
        </trans-unit>
        <trans-unit id="ea76b09fecc8949f24ae03f9a3f42c9fa0287c50" translate="yes" xml:space="preserve">
          <source>Enable the use of pre/post modify with register displacement.</source>
          <target state="translated">레지스터 변위와 함께 사전 / 사후 수정 사용을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="6635132d2079387847468168f8edcfc7554ca84f" translate="yes" xml:space="preserve">
          <source>Enable the use of the instruction &lt;code&gt;fmovd&lt;/code&gt;. Check</source>
          <target state="translated">&lt;code&gt;fmovd&lt;/code&gt; 명령어 사용을 활성화합니다 . 검사</target>
        </trans-unit>
        <trans-unit id="a2fdf0058d830cee1f93b69f832936392dc9ed46" translate="yes" xml:space="preserve">
          <source>Enable tree pass &lt;var&gt;pass&lt;/var&gt;. See</source>
          <target state="translated">트리 패스 &lt;var&gt;pass&lt;/var&gt; 활성화합니다 . 보다</target>
        </trans-unit>
        <trans-unit id="b8f020346acd5709653f3c40d525659258a1b9db" translate="yes" xml:space="preserve">
          <source>Enable use of &lt;code&gt;bi&lt;/code&gt; or &lt;code&gt;bih&lt;/code&gt; instructions to implement jump tables.</source>
          <target state="translated">사용 가능 &lt;code&gt;bi&lt;/code&gt; 또는 &lt;code&gt;bih&lt;/code&gt; 점프 테이블을 구현하는 지침을.</target>
        </trans-unit>
        <trans-unit id="79a73d3f193a6e6ff330a4b9de3265b919526bff" translate="yes" xml:space="preserve">
          <source>Enable use of the extended instructions of the FT32B processor.</source>
          <target state="translated">FT32B 프로세서의 확장 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6d0438ac8bb52c3d5f5f9c3df1e29694d4f64211" translate="yes" xml:space="preserve">
          <source>Enable user-defined instructions.</source>
          <target state="translated">사용자 정의 지침을 활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="289e8ab3bafc79cd3d4d7a33238e966c5c4d7a05" translate="yes" xml:space="preserve">
          <source>Enable verbose cost model dumping in the debug dump files. This option is provided for use in debugging the compiler.</source>
          <target state="translated">디버그 덤프 파일에서 자세한 비용 모델 덤프를 사용하십시오. 이 옵션은 컴파일러 디버깅에 사용하기 위해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="5698cf3230e865992f3f27c124b887d7d8c62160" translate="yes" xml:space="preserve">
          <source>Enable/disable bit-field layout compatible with the native Microsoft Windows compiler.</source>
          <target state="translated">기본 Microsoft Windows 컴파일러와 호환되는 비트 필드 레이아웃을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="ec1922decad109f864b4cf7878296aa732c83b64" translate="yes" xml:space="preserve">
          <source>Enable/disable inlining of string operations.</source>
          <target state="translated">문자열 작업 인라인을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="77a9782fdfbab35d94a1e98b3a7fd934623ad240" translate="yes" xml:space="preserve">
          <source>Enable/disable the &lt;var&gt;__float128&lt;/var&gt; keyword for IEEE 128-bit floating point and use either software emulation for IEEE 128-bit floating point or hardware instructions.</source>
          <target state="translated">IEEE 128 비트 부동 소수점에 대해 &lt;var&gt;__float128&lt;/var&gt; 키워드를 활성화 / 비활성화하고 IEEE 128 비트 부동 소수점에 대한 소프트웨어 에뮬레이션 또는 하드웨어 명령어를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="eef257e319b773e37c267992617c97ed3ff87e5c" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of RCPSS, RCPPS, RSQRTSS and RSQRTPS instructions followed an additional Newton-Raphson step instead of doing a floating-point division.</source>
          <target state="translated">RCPSS, RCPPS, RSQRTSS 및 RSQRTPS 명령어 생성을 활성화 / 비활성화하여 부동 소수점 나누기 대신 추가 Newton-Raphson 단계를 수행했습니다.</target>
        </trans-unit>
        <trans-unit id="ce9687705ccc627a85aa74c6222e1c475cf39951" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of floating point that depends on IEEE arithmetic.</source>
          <target state="translated">IEEE 산술에 따라 부동 소수점 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="e06af20ef568b69c3362691eda73268a45b5e6fb" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the 3DNow! instructions.</source>
          <target state="translated">3DNow! 생성을 활성화 / 비활성화합니다. 명령.</target>
        </trans-unit>
        <trans-unit id="8ea30fdab63dafe3dc7fc652cf67136424f3b625" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the &lt;code&gt;sin&lt;/code&gt;, &lt;code&gt;cos&lt;/code&gt;, and &lt;code&gt;sqrt&lt;/code&gt; instructions on the 387 floating-point unit.</source>
          <target state="translated">387 부동 소수점 단위 에서 &lt;code&gt;sin&lt;/code&gt; , &lt;code&gt;cos&lt;/code&gt; 및 &lt;code&gt;sqrt&lt;/code&gt; 명령어 생성을 활성화 / 비활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="d2ce898ea3fbbf85aca7bdcebad5257c4339a871" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the ADX instructions.</source>
          <target state="translated">ADX 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="8c51cd7ffa80497e01030865d76bb3aa852e4b11" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AES instructions.</source>
          <target state="translated">AES 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="139f5148751f41ac5e236f52ce09ecaba429fae5" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX instructions.</source>
          <target state="translated">AVX 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="c03537f2a6f562c3bdf507ee0385caa610905340" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX2 instructions.</source>
          <target state="translated">AVX2 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="2f46ca2cd644ae06703a20fd137f758ec86b545b" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX5124FMAPS instructions.</source>
          <target state="translated">AVX5124FMAPS 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="07c3fb12af13a9cd69b78d9bc8b1bf44bce2f703" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX5124VNNIW instructions.</source>
          <target state="translated">AVX5124VNNIW 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="3754f28eb3ff315a901b1086241414b36cdc2445" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512BITALG instructions.</source>
          <target state="translated">AVX512BITALG 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="9d757b2f48a6a1b6957e3c46cfd35f8cef5e43f2" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512BW instructions.</source>
          <target state="translated">AVX512BW 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="d3c2cb946f575c062fed2315966b199b452fa19e" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512CD instructions.</source>
          <target state="translated">AVX512CD 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="55f4758594e3826b45c045f868cd0c0b6fe314a5" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512DQ instructions.</source>
          <target state="translated">AVX512DQ 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="868a5a7c9ba2cab10b4dbee05b59b72caa86a0f1" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512ER instructions.</source>
          <target state="translated">AVX512ER 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="40cf4ec0c6bc30ab932552059f3f09cac003af63" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512F instructions.</source>
          <target state="translated">AVX512F 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="ba0e32798c4a1b18ba185f7a8c7a840f7e7480c5" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512IFMA instructions.</source>
          <target state="translated">AVX512IFMA 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="cfee43efb9eef88de6b588ce9a55a47d1e02ac8b" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512PF instructions.</source>
          <target state="translated">AVX512PF 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="1d9376176900a884770b47d4b38ffe3800952fda" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512VBMI instructions.</source>
          <target state="translated">AVX512VBMI 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="5315cd056026db5157cf29bd04c56d18b6d556b6" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512VBMI2 instructions.</source>
          <target state="translated">AVX512VBMI2 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="ddf56de8dc48259cd81ab8285e90003fb25e73e2" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512VL instructions.</source>
          <target state="translated">AVX512VL 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="26241a02deae96e24160a0ca3f3cc5c41033dbf3" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512VNNI instructions.</source>
          <target state="translated">AVX512VNNI 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="84a8ab5234b9fa4c56baeffdaee98c552e89549f" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512VPOPCNTDQ instructions.</source>
          <target state="translated">AVX512VPOPCNTDQ 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="dae7d1054e24eee8d8b487043aaad1fc5f1db574" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the BMI instructions.</source>
          <target state="translated">BMI 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="3d72a8758536f6a87e94a41fe37b66f09beef533" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the BMI2 instructions.</source>
          <target state="translated">BMI2 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="b738e70323169015d6a48d84ae40dd6c29e5217d" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the CLD before string moves.</source>
          <target state="translated">문자열이 이동하기 전에 CLD 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="d65d8d65a18d1cfa6dc9c78ebdaad5ad563343cb" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the CLDEMOTE instructions.</source>
          <target state="translated">CLDEMOTE 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="ccb6f558360b355b894e7ea63cd154a997ed12e8" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the CLFLUSHOPT instructions.</source>
          <target state="translated">CLFLUSHOPT 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="f0801d5d70f8b9df1efe3aea49e8a0671ca5bfec" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the CLWB instructions.</source>
          <target state="translated">CLWB 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="94ecea85bbdafb56613082f3e5be7c02237756ed" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the CLZERO instructions.</source>
          <target state="translated">CLZERO 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="f8d79a3c698ec42fbe32e73864266b011f951b2f" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the CMPXCHG16B instructions.</source>
          <target state="translated">CMPXCHG16B 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="b0bd05f01479f2861886a517faf455f95df939c9" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the CRC32 instructions.</source>
          <target state="translated">CRC32 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="d6440333fc0c90bc6217f92335430eaed3b0c3e6" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the F16C instructions.</source>
          <target state="translated">F16C 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="5cea65073f4a60c1177a3414fc29a42c91b72246" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the FMA instructions.</source>
          <target state="translated">FMA 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="99871ac8f6615a85bb6ff6e756bf21d0a7db8138" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the FMA4 instructions.</source>
          <target state="translated">FMA4 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="4820cc9a7748ec354eac413d8f383da9dd67e717" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the FSGSBASE instructions.</source>
          <target state="translated">FSGSBASE 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="60644d857fe08e2846e93707df49f0bca9fb4a3e" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the FXSR instructions.</source>
          <target state="translated">FXSR 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="0d58cb597f94125b583603aeaf0cb6d6fac80c1b" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the GFNI instructions.</source>
          <target state="translated">GFNI 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="9578e9d5e6eece4df004759dd7fc90f39eea18e0" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the HLE instruction prefixes.</source>
          <target state="translated">HLE 명령어 접두사 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="549533ddadf886e04d518c98906dae343a33a8ce" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the LWP instructions.</source>
          <target state="translated">LWP 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="8c3785d4101d06b824b0b36311920e0a30ccd2d9" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the LZCNT instructions.</source>
          <target state="translated">LZCNT 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="574261210d9c97190453b59ddf32621dc2c86c69" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the MMX instructions.</source>
          <target state="translated">MMX 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="45a7da12e51c3e52b7908907f0dfac053d1882c4" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the MOVBE instructions.</source>
          <target state="translated">MOVBE 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="75cfc04edcd4dee4218a715cae2bd3ac7fa16a7e" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the MOVDIR64B instructions.</source>
          <target state="translated">MOVDIR64B 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="c6371db2050fdd103c6d197692dfd64140187f4a" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the MOVDIRI instructions.</source>
          <target state="translated">MOVDIRI 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="6e98e7f5d53a1e3439a31b14070244368aebebfe" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the MWAITX instructions.</source>
          <target state="translated">MWAITX 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="dc37894f7a2ce025aaeba83cdca8f3ca819436f1" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the PCLMUL instructions.</source>
          <target state="translated">PCLMUL 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="c6ecdb5d5fff5ea045de6d2ca8023861f04ebc4d" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the PCONFIG instructions.</source>
          <target state="translated">PCONFIG 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="a081a1e7a08745213d7883c3b5236130fe755e13" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the PKU instructions.</source>
          <target state="translated">PKU 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="e9e69747966699a82f308dbbadb71d6e9fb92d92" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the POPCNT instruction.</source>
          <target state="translated">POPCNT 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="f9ed3efe60bd11688e60a3f2cb5a1ff252d812d0" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the PREFETCHW instruction.</source>
          <target state="translated">PREFETCHW 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="006748470b229e9088cb61bc26a1257f2c9a8615" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the PREFETCHWT1 instructions.</source>
          <target state="translated">PREFETCHWT1 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="2447c34a50f2bd64c3943526353f34051a55f5aa" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the PTWRITE instructions.</source>
          <target state="translated">PTWRITE 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="5735ee8db2baf84da1ef868849fd1bf84c1f8c11" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the RDPID instructions.</source>
          <target state="translated">RDPID 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="0b0a5749ac92e20b8e558766d0dd8d71d8adeeaf" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the RDRND instructions.</source>
          <target state="translated">RDRND 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="4913a7bcb28cb1f12173c4058eaf61ab9315d7d3" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the RDSEED instructions.</source>
          <target state="translated">RDSEED 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="300142c2ef84f7df525c1aa21af494a1e7bead9f" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the RTM instructions.</source>
          <target state="translated">RTM 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="0d2ad4e123ffd7abb18aa9c974df2646f0d5508c" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the SAHF instructions.</source>
          <target state="translated">SAHF 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="632f005a4b74a3843a3298d0871cbe50c5ad6aa9" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the SGX instructions.</source>
          <target state="translated">SGX 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="6b57bd12c5e2df48fa7d7e43ba31d0995c7f5553" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the SHA instructions.</source>
          <target state="translated">SHA 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="b5d7ecf6e517427fea4ad12abde111a42bd74cea" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the SSE instructions.</source>
          <target state="translated">SSE 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="1f0972ae163067735798e2e6f4187300ae1137e4" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the SSE2 instructions.</source>
          <target state="translated">SSE2 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="b03632fda4a2d3d92f1cf4eac7cca05dbc5a7516" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the SSE3 instructions.</source>
          <target state="translated">SSE3 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="5e9b999ddb7457a054d66bdaa2de1a8f647ad215" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the SSE4 instructions (both SSE4.1 and SSE4.2).</source>
          <target state="translated">SSE4 명령어 생성 (SSE4.1 및 SSE4.2 모두)을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="21d0ef801e5d8043d92d8c50dd3d6daaddab55a0" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the SSE4A instructions.</source>
          <target state="translated">SSE4A 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="ab7b78506bfd06d655fee8ea1068706000cbeacf" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the SSSE3 instructions.</source>
          <target state="translated">SSSE3 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="f0e97c519b39b4830d04c86470ddf48b233a76c5" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the TBM instructions.</source>
          <target state="translated">TBM 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="f3acd83d7172837bca3d0b44672674470b67ff86" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the VAES instructions.</source>
          <target state="translated">VAES 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="9789894eea8adf6b88ad98db26058bba573138b8" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the VPCLMULQDQ instructions.</source>
          <target state="translated">VPCLMULQDQ 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="b524ba4aef3ce6873b5b0e11048e23307db06122" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the WAITPKG instructions.</source>
          <target state="translated">WAITPKG 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="a045e3b2a45d14170b9039170f7578c3d2713015" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the WBNOINVD instructions.</source>
          <target state="translated">WBNOINVD 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="e40cfbce647b2c7f9ddf7f4f626656cc3a1bc167" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the XOP instructions.</source>
          <target state="translated">XOP 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="af8da63fa2d12d8f18afd42b233c4d37ee867c63" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the XSAVE instructions.</source>
          <target state="translated">XSAVE 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="1233b5b867e3f5dba2db3c438d3d6df18bde5ef8" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the XSAVEC instructions.</source>
          <target state="translated">XSAVEC 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="a0a9e371f8da9a97cd65e604007429c825f18769" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the XSAVEOPT instructions.</source>
          <target state="translated">XSAVEOPT 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="40e3ea0db494aa36d313e852fcbfd0f81556503b" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the XSAVES instructions.</source>
          <target state="translated">XSAVES 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="fe009b6bf64ee12df513906e2d5837b5e1c97910" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the advanced bit instructions.</source>
          <target state="translated">고급 비트 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="da867b2b85cc94070610ef36f96c5698f745a3ec" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the enhanced 3DNow! instructions.</source>
          <target state="translated">향상된 3DNow! 생성을 활성화 / 비활성화합니다. 명령.</target>
        </trans-unit>
        <trans-unit id="7b3bd531bffe003f20aeec31cfccd8602793b41a" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the inline code to do small string operations and calling the library routines for large operations.</source>
          <target state="translated">인라인 코드 생성을 활성화 / 비활성화하여 작은 문자열 작업을 수행하고 큰 작업을위한 라이브러리 루틴을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="902acc4f79ae76c2d32a7b6c514f8deac67c62fb" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the sse4.1 instructions.</source>
          <target state="translated">sse4.1 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="2a2818a0c367c053dac063d194f234ec531d06f2" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the sse4.2 instructions.</source>
          <target state="translated">sse4.2 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="37e917a07fa74d7e4e6dadb9579fbc16f97ae659" translate="yes" xml:space="preserve">
          <source>Enable/disable the shadow stack built-in functions from CET.</source>
          <target state="translated">CET에서 섀도 스택 내장 기능을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="e907f9b58bf0706e2b41d509db8ed99ad239f467" translate="yes" xml:space="preserve">
          <source>Enable/disable using ISA 3.0 hardware instructions to support the &lt;var&gt;__float128&lt;/var&gt; data type.</source>
          <target state="translated">&lt;var&gt;__float128&lt;/var&gt; 데이터 형식 을 지원하기 위해 ISA 3.0 하드웨어 지침을 사용하여 활성화 / 비활성화 합니다.</target>
        </trans-unit>
        <trans-unit id="4b32f2d1dc57603e53cae07a8b8cf8dd5b0f7205" translate="yes" xml:space="preserve">
          <source>Enabled at levels</source>
          <target state="translated">레벨에서 사용 가능</target>
        </trans-unit>
        <trans-unit id="a2d7a1ae5b45c7663ff5c6c74c01638ab9ca0806" translate="yes" xml:space="preserve">
          <source>Enabled by</source>
          <target state="translated">에 의해 활성화</target>
        </trans-unit>
        <trans-unit id="87971a35b8aed293eb3378e3d8ac5721ecb5cb96" translate="yes" xml:space="preserve">
          <source>Enabled by default at</source>
          <target state="translated">에서 기본적으로 활성화</target>
        </trans-unit>
        <trans-unit id="bcd7c586f5c724dfc09404aaf2a878d0206e9f76" translate="yes" xml:space="preserve">
          <source>Enabled by default when</source>
          <target state="translated">기본적으로 활성화</target>
        </trans-unit>
        <trans-unit id="4f94ea1c93e5664c46cd416ea64f7cc9936467d8" translate="yes" xml:space="preserve">
          <source>Enabled by default with</source>
          <target state="translated">기본적으로 활성화</target>
        </trans-unit>
        <trans-unit id="261c7b9c3b776bec501c26a9d2fe4d480d9d16f7" translate="yes" xml:space="preserve">
          <source>Enabled by default.</source>
          <target state="translated">기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3d5b773827f9c4413a2fc452aae96dd06f591fd" translate="yes" xml:space="preserve">
          <source>Enabled for Alpha, AArch64 and x86 at levels</source>
          <target state="translated">레벨에서 알파, AArch64 및 x86에 사용</target>
        </trans-unit>
        <trans-unit id="217f8e562e876828812e90f53725615d6901cc9d" translate="yes" xml:space="preserve">
          <source>Enabled for x86 at levels</source>
          <target state="translated">레벨에서 x86에 사용</target>
        </trans-unit>
        <trans-unit id="44ce21fc6a64ad296ee8e3cda3bcb2b9759adebf" translate="yes" xml:space="preserve">
          <source>Enabled with</source>
          <target state="translated">사용</target>
        </trans-unit>
        <trans-unit id="979f6df4ed2e6e9238efa8b3ebc9f087264e476a" translate="yes" xml:space="preserve">
          <source>Enables (</source>
          <target state="translated">사용 (</target>
        </trans-unit>
        <trans-unit id="7eae3793cec99e5fa487fe453e12770d55076d5b" translate="yes" xml:space="preserve">
          <source>Enables (or disables) reading and writing of 16- and 32- bit values from addresses that are not 16- or 32- bit aligned. By default unaligned access is disabled for all pre-ARMv6, all ARMv6-M and for ARMv8-M Baseline architectures, and enabled for all other architectures. If unaligned access is not enabled then words in packed data structures are accessed a byte at a time.</source>
          <target state="translated">16 비트 또는 32 비트로 정렬되지 않은 주소에서 16 비트 및 32 비트 값을 읽고 쓸 수있게합니다. 기본적으로 정렬되지 않은 액세스는 모든 ARMv6 이전, 모든 ARMv6-M 및 ARMv8-M베이스 라인 아키텍처에서 비활성화되고 다른 모든 아키텍처에서 활성화됩니다. 정렬되지 않은 액세스가 활성화되지 않은 경우 묶음 데이터 구조의 단어는 한 번에 한 바이트 씩 액세스됩니다.</target>
        </trans-unit>
        <trans-unit id="b65eaeca3be0a544da578e950cb68230b9d67b03" translate="yes" xml:space="preserve">
          <source>Enables IVC2 scheduling. IVC2 is a 64-bit VLIW coprocessor.</source>
          <target state="translated">IVC2 스케줄링을 사용합니다. IVC2는 64 비트 VLIW 보조 프로세서입니다.</target>
        </trans-unit>
        <trans-unit id="f8bfc926b8449de54aa34c3f95b4955d0fe52d4e" translate="yes" xml:space="preserve">
          <source>Enables all inter-procedural analysis dumps.</source>
          <target state="translated">모든 절차 간 분석 덤프를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="39e032a23d350be5be02b628822ab23ba3864dfe" translate="yes" xml:space="preserve">
          <source>Enables all the optional instructions&amp;mdash;average, multiply, divide, bit operations, leading zero, absolute difference, min/max, clip, and saturation.</source>
          <target state="translated">평균, 곱하기, 나누기, 비트 연산, 선행 제로, 절대 차이, 최소 / 최대, 클립 및 채도 등 모든 선택적 명령을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dcd06b68e12a4e252dc788f4fd7792582f994c23" translate="yes" xml:space="preserve">
          <source>Enables expression of values of induction variables in later iterations of the unrolled loop using the value in the first iteration. This breaks long dependency chains, thus improving efficiency of the scheduling passes.</source>
          <target state="translated">첫 번째 반복의 값을 사용하여 언 롤링 된 루프의 이후 반복에서 유도 변수의 값을 표현할 수 있습니다. 이로 인해 긴 종속성 체인이 중단되므로 스케줄링 패스의 효율성이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="7564b980df27ae9794a4d64f8c88854f784c151d" translate="yes" xml:space="preserve">
          <source>Enables or disables the use of the string manipulation instructions &lt;code&gt;SMOVF&lt;/code&gt;, &lt;code&gt;SCMPU&lt;/code&gt;, &lt;code&gt;SMOVB&lt;/code&gt;, &lt;code&gt;SMOVU&lt;/code&gt;, &lt;code&gt;SUNTIL&lt;/code&gt;&lt;code&gt;SWHILE&lt;/code&gt; and also the &lt;code&gt;RMPA&lt;/code&gt; instruction. These instructions may prefetch data, which is not safe to do if accessing an I/O register. (See section 12.2.7 of the RX62N Group User&amp;rsquo;s Manual for more information).</source>
          <target state="translated">문자열 조작 명령어 &lt;code&gt;SMOVF&lt;/code&gt; , &lt;code&gt;SCMPU&lt;/code&gt; , &lt;code&gt;SMOVB&lt;/code&gt; , &lt;code&gt;SMOVU&lt;/code&gt; , &lt;code&gt;SUNTIL&lt;/code&gt; &lt;code&gt;SWHILE&lt;/code&gt; 및 &lt;code&gt;RMPA&lt;/code&gt; 명령어 사용을 활성화 또는 비활성화합니다 . 이러한 명령어는 데이터를 프리 페치 할 수 있으며, 이는 I / O 레지스터에 액세스하는 경우 안전하지 않습니다. (자세한 내용은 RX62N 그룹 사용 설명서의 12.2.7 섹션을 참조하십시오).</target>
        </trans-unit>
        <trans-unit id="b2d56a3e8dc64cdea92b5b177de5eee2ddc022a5" translate="yes" xml:space="preserve">
          <source>Enables support for &lt;code&gt;double&lt;/code&gt; and &lt;code&gt;long long&lt;/code&gt; types to be aligned on 8-byte boundaries. The default is to restrict the alignment of all objects to at most 4-bytes. When</source>
          <target state="translated">8 바이트 경계 에서 &lt;code&gt;double&lt;/code&gt; 및 &lt;code&gt;long long&lt;/code&gt; 유형을 지원할 수 있습니다. 기본값은 모든 객체의 정렬을 최대 4 바이트로 제한하는 것입니다. 언제</target>
        </trans-unit>
        <trans-unit id="85b9ecfc95ed087be71f719ded533eb947f09555" translate="yes" xml:space="preserve">
          <source>Enables support for all single- and double-precision floating-point hardware extensions. Not available for ARC EM.</source>
          <target state="translated">모든 단 정밀도 및 배정 밀도 부동 소수점 하드웨어 확장을 지원합니다. ARC EM에는 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f75e5afbbe9ab70b1263a70cb8894e0664caf0b1" translate="yes" xml:space="preserve">
          <source>Enables support for all single-precision floating-point hardware extensions.</source>
          <target state="translated">모든 단 정밀도 부동 소수점 하드웨어 확장을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="7883565cb4fb9258e363d1f2d7f38e140fa66bc4" translate="yes" xml:space="preserve">
          <source>Enables support for double-precision floating-point and fused multiply and add hardware extensions. This option includes option &amp;lsquo;</source>
          <target state="translated">배정 밀도 부동 소수점 및 융합 곱셈을 지원하고 하드웨어 확장을 추가합니다. 이 옵션에는 '</target>
        </trans-unit>
        <trans-unit id="09688a51318111fb1133a1873f85c86a0dd2d24a" translate="yes" xml:space="preserve">
          <source>Enables support for double-precision floating-point hardware extensions using double-precision assist instructions. All single-precision floating-point hardware extensions are also enabled. This option is only available for ARC EM.</source>
          <target state="translated">배정도 지원 명령어를 사용하여 배정도 부동 소수점 하드웨어 확장을 지원할 수 있습니다. 모든 단 정밀도 부동 소수점 하드웨어 확장도 활성화됩니다. 이 옵션은 ARC EM에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="998d962adb014531e7dc98dfd0f68752292543ee" translate="yes" xml:space="preserve">
          <source>Enables support for double-precision floating-point hardware extensions using double-precision assist instructions. The single-precision floating-point and fused multiply and add hardware extensions are also enabled. This option is only available for ARC EM.</source>
          <target state="translated">배정도 지원 명령어를 사용하여 배정도 부동 소수점 하드웨어 확장을 지원할 수 있습니다. 단 정밀도 부동 소수점 및 융합 곱셈 및 하드웨어 확장 추가도 가능합니다. 이 옵션은 ARC EM에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d9fab6d5bc5404d7e456a561365555b9e55a46b" translate="yes" xml:space="preserve">
          <source>Enables support for double-precision floating-point hardware extensions using double-precision assist instructions. The single-precision floating-point extension is also enabled. This option is only available for ARC EM.</source>
          <target state="translated">배정도 지원 명령어를 사용하여 배정도 부동 소수점 하드웨어 확장을 지원할 수 있습니다. 단 정밀도 부동 소수점 확장도 활성화됩니다. 이 옵션은 ARC EM에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8714aef39627cf0d1b3a7e36332dd7526fef4382" translate="yes" xml:space="preserve">
          <source>Enables support for double-precision floating-point hardware extensions using double-precision assist instructions. The single-precision floating-point, square-root, and divide extensions are also enabled. This option is only available for ARC EM.</source>
          <target state="translated">배정도 지원 명령어를 사용하여 배정도 부동 소수점 하드웨어 확장을 지원할 수 있습니다. 단 정밀도 부동 소수점, 제곱근 및 나누기 확장도 활성화됩니다. 이 옵션은 ARC EM에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="88614dbf859eb550fe6ea83089c08ee2a35b6c5a" translate="yes" xml:space="preserve">
          <source>Enables support for double-precision floating-point hardware extensions. The single-precision floating-point extension is also enabled. Not available for ARC EM.</source>
          <target state="translated">배정 밀도 부동 소수점 하드웨어 확장을 지원합니다. 단 정밀도 부동 소수점 확장도 활성화됩니다. ARC EM에는 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ed75b445d9416dbdcca6532a5b9e4ba16b46347a" translate="yes" xml:space="preserve">
          <source>Enables support for double-precision floating-point, square-root and divide hardware extensions. This option includes option &amp;lsquo;</source>
          <target state="translated">배정 밀도 부동 소수점, 제곱근 및 분할 하드웨어 확장을 지원합니다. 이 옵션에는 '</target>
        </trans-unit>
        <trans-unit id="4020a8753a0799a59f9043cec8f1b76a8cbf21f5" translate="yes" xml:space="preserve">
          <source>Enables support for single-precision floating-point and fused multiply and add hardware extensions.</source>
          <target state="translated">단 정밀도 부동 소수점 및 융합 곱셈을 지원하고 하드웨어 확장을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="739ef3a6f4ad193608707def042ed976fbb38794" translate="yes" xml:space="preserve">
          <source>Enables support for single-precision floating-point hardware extensions.</source>
          <target state="translated">단 정밀도 부동 소수점 하드웨어 확장을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="69030e58955d3b24f425bf1f743dd072b9ea41e4" translate="yes" xml:space="preserve">
          <source>Enables support for single-precision floating-point, square-root and divide hardware extensions.</source>
          <target state="translated">단 정밀도 부동 소수점, 제곱근 및 분할 하드웨어 확장을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="dd589dcd1e2f89f81d2aa1944b9d5b300d0537d9" translate="yes" xml:space="preserve">
          <source>Enables support for specific floating-point hardware extensions for ARCv2 cores. Supported values for &lt;var&gt;fpu&lt;/var&gt; are:</source>
          <target state="translated">ARCv2 코어에 대한 특정 부동 소수점 하드웨어 확장을 지원합니다. &lt;var&gt;fpu&lt;/var&gt; 에 지원되는 값 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="40edc654abf50990a91d4feb4df5e9d34bf7f47f" translate="yes" xml:space="preserve">
          <source>Enables support for the RH850 version of the V850 ABI. This is the default. With this version of the ABI the following rules apply:</source>
          <target state="translated">V850 ABI의 RH850 버전을 지원합니다. 이것이 기본값입니다. 이 버전의 ABI에서는 다음 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="a3ccc0d52f2a100abeb7168c2966e22df181fb16" translate="yes" xml:space="preserve">
          <source>Enables support for the old GCC version of the V850 ABI. With this version of the ABI the following rules apply:</source>
          <target state="translated">V850 ABI의 이전 GCC 버전을 지원합니다. 이 버전의 ABI에서는 다음 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="13d14b8a88583d4801772d41f78d731f585ac76d" translate="yes" xml:space="preserve">
          <source>Enables the 32-bit coprocessor&amp;rsquo;s instructions.</source>
          <target state="translated">32 비트 보조 프로세서의 명령어를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="37f8bcfc01e8c9f171283b3e6b96664748ea2f0b" translate="yes" xml:space="preserve">
          <source>Enables the 64-bit coprocessor&amp;rsquo;s instructions.</source>
          <target state="translated">64 비트 보조 프로세서의 명령어를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="866afe4dc503faaed460c73ebf4e30e8a9116810" translate="yes" xml:space="preserve">
          <source>Enables the &lt;code&gt;abs&lt;/code&gt; instruction, which is the absolute difference between two registers.</source>
          <target state="translated">&lt;code&gt;abs&lt;/code&gt; 레지스터를 활성화합니다. 이는 두 레지스터 간의 절대 차이입니다.</target>
        </trans-unit>
        <trans-unit id="50cf3b6e541adf62bd77b142fc53a61d05fc7c9c" translate="yes" xml:space="preserve">
          <source>Enables the &lt;code&gt;ave&lt;/code&gt; instruction, which computes the average of two registers.</source>
          <target state="translated">두 레지스터의 평균을 계산 하는 &lt;code&gt;ave&lt;/code&gt; 명령어를 활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="2e8478914d75d996b9e9464d4ca7119db6662af4" translate="yes" xml:space="preserve">
          <source>Enables the &lt;code&gt;clip&lt;/code&gt; instruction. Note that</source>
          <target state="translated">&lt;code&gt;clip&lt;/code&gt; 명령을 활성화합니다 . 참고</target>
        </trans-unit>
        <trans-unit id="e97f2d1656d0f25d2a745cdd7d099a3de6f71833" translate="yes" xml:space="preserve">
          <source>Enables the &lt;code&gt;div&lt;/code&gt; and &lt;code&gt;divu&lt;/code&gt; instructions.</source>
          <target state="translated">&lt;code&gt;div&lt;/code&gt; 및 &lt;code&gt;divu&lt;/code&gt; 명령어를 활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="13fbaebc3f1567a809a1ff5ab5607726671f6a6a" translate="yes" xml:space="preserve">
          <source>Enables the &lt;code&gt;leadz&lt;/code&gt; (leading zero) instruction.</source>
          <target state="translated">&lt;code&gt;leadz&lt;/code&gt; (제로 선행) 명령을 활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="1da519d84df5ff1b705dd7abe77d948ec006a771" translate="yes" xml:space="preserve">
          <source>Enables the &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; instructions.</source>
          <target state="translated">&lt;code&gt;min&lt;/code&gt; 및 &lt;code&gt;max&lt;/code&gt; 명령을 활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="4da5357bac4df4fb4da7516696ce5726e90631ac" translate="yes" xml:space="preserve">
          <source>Enables the &lt;code&gt;repeat&lt;/code&gt; and &lt;code&gt;erepeat&lt;/code&gt; instructions, used for low-overhead looping.</source>
          <target state="translated">수 있도록 &lt;code&gt;repeat&lt;/code&gt; 및 &lt;code&gt;erepeat&lt;/code&gt; 낮은 오버 헤드 루프에 사용 지침을.</target>
        </trans-unit>
        <trans-unit id="b4f230bdb2809992da1b8ee11728eb1397ea6487" translate="yes" xml:space="preserve">
          <source>Enables the bit operation instructions&amp;mdash;bit test (&lt;code&gt;btstm&lt;/code&gt;), set (&lt;code&gt;bsetm&lt;/code&gt;), clear (&lt;code&gt;bclrm&lt;/code&gt;), invert (&lt;code&gt;bnotm&lt;/code&gt;), and test-and-set (&lt;code&gt;tas&lt;/code&gt;).</source>
          <target state="translated">비트 테스트 명령 (비트 테스트 ( &lt;code&gt;btstm&lt;/code&gt; ), 설정 ( &lt;code&gt;bsetm&lt;/code&gt; ), 클리어 ( &lt;code&gt;bclrm&lt;/code&gt; ), 반전 ( &lt;code&gt;bnotm&lt;/code&gt; ) 및 테스트 및 설정 ( &lt;code&gt;tas&lt;/code&gt; ))을 활성화 합니다.</target>
        </trans-unit>
        <trans-unit id="650b34422af73f1c39adc7884ebaf0f44be9cbe6" translate="yes" xml:space="preserve">
          <source>Enables the coprocessor instructions. By default, this is a 32-bit coprocessor. Note that the coprocessor is normally enabled via the</source>
          <target state="translated">보조 프로세서 명령어를 활성화합니다. 기본적으로 이것은 32 비트 코 프로세서입니다. 보조 프로세서는 일반적으로</target>
        </trans-unit>
        <trans-unit id="849d54c65b67142ad3610bf0ff41505e124671a1" translate="yes" xml:space="preserve">
          <source>Enables the cryptographic instructions on &amp;lsquo;</source>
          <target state="translated">'에서 암호화 지침을 사용하도록 설정합니다.</target>
        </trans-unit>
        <trans-unit id="e300897cde7331a4be041e33bbcd7fc9ca650ebe" translate="yes" xml:space="preserve">
          <source>Enables the generation of position independent data. When enabled any access to constant data is done via an offset from a base address held in a register. This allows the location of constant data to be determined at run time without requiring the executable to be relocated, which is a benefit to embedded applications with tight memory constraints. Data that can be modified is not affected by this option.</source>
          <target state="translated">위치 독립적 인 데이터를 생성 할 수 있습니다. 활성화되면 상수 데이터에 대한 액세스는 레지스터에있는 기본 주소의 오프셋을 통해 수행됩니다. 따라서 실행 파일을 재배치 할 필요없이 런타임에 상수 데이터의 위치를 ​​결정할 수 있습니다. 이는 메모리 제약이 엄격한 임베디드 응용 프로그램의 이점입니다. 수정할 수있는 데이터는이 옵션의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cf1918bfd22c209206d2846ea3d88a19e3a73f7d" translate="yes" xml:space="preserve">
          <source>Enables the loop invariant motion pass in the RTL loop optimizer. Enabled at level</source>
          <target state="translated">RTL 루프 최적화 프로그램에서 루프 불변 모션 패스를 활성화합니다. 레벨에서 사용 가능</target>
        </trans-unit>
        <trans-unit id="ecd974872f6eca7f7d4ae7dac04ee2a0a333973d" translate="yes" xml:space="preserve">
          <source>Enables the multiplication and multiply-accumulate instructions.</source>
          <target state="translated">곱셈 및 곱셈 누적 명령어를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="7fc40693c14939b54a70a171fa80eb19af8d1f4b" translate="yes" xml:space="preserve">
          <source>Enables the saturation instructions. Note that the compiler does not currently generate these itself, but this option is included for compatibility with other tools, like &lt;code&gt;as&lt;/code&gt;.</source>
          <target state="translated">채도 지시를 활성화합니다. 컴파일러는 현재 이러한 자체를 생성하지 않지만,이 옵션을 같은 다른 도구와의 호환성을 위해 포함되어 있습니다 &lt;code&gt;as&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e1d7284a520ac6d5afcc167354eeade161094006" translate="yes" xml:space="preserve">
          <source>Enables the use of a linker plugin during link-time optimization. This option relies on plugin support in the linker, which is available in gold or in GNU ld 2.21 or newer.</source>
          <target state="translated">링크 타임 최적화 중에 링커 플러그인을 사용할 수 있습니다. 이 옵션은 골드 또는 GNU ld 2.21 이상에서 사용할 수있는 링커의 플러그인 지원에 의존합니다.</target>
        </trans-unit>
        <trans-unit id="118989c6873866bc4e811127fbd742299b49d5aa" translate="yes" xml:space="preserve">
          <source>Enables the use of the e3v5 LOOP instruction. The use of this instruction is not enabled by default when the e3v5 architecture is selected because its use is still experimental.</source>
          <target state="translated">e3v5 LOOP 명령어를 사용할 수 있습니다. 이 명령어는 e3v5 아키텍처가 아직 실험적이기 때문에 선택 될 때 기본적으로 활성화되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e218c1fa9772e443eea87ffbfc5f0dee5a840cd5" translate="yes" xml:space="preserve">
          <source>Enables using Neon to handle scalar 64-bits operations. This is disabled by default since the cost of moving data from core registers to Neon is high.</source>
          <target state="translated">Neon을 사용하여 스칼라 64 비트 작업을 처리 할 수 ​​있습니다. 코어 레지스터에서 네온으로 데이터를 이동하는 비용이 높기 때문에 기본적으로 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="93ce405e36a27a5a639a5f340a06317ff8160589" translate="yes" xml:space="preserve">
          <source>Enabling profiling and extra run-time error checking.</source>
          <target state="translated">프로파일 링 및 추가 런타임 오류 검사 사용</target>
        </trans-unit>
        <trans-unit id="5821fec7ee87050117e2081a31b307f34868a8ad" translate="yes" xml:space="preserve">
          <source>Encoding</source>
          <target state="translated">Encoding</target>
        </trans-unit>
        <trans-unit id="1819780111faf7544a66daa1d16d7611734230e4" translate="yes" xml:space="preserve">
          <source>End lock elision on a lock variable. Memory order must be &lt;code&gt;__ATOMIC_RELEASE&lt;/code&gt; or stronger.</source>
          <target state="translated">잠금 변수에서 종료 잠금 제거. 메모리 순서는 &lt;code&gt;__ATOMIC_RELEASE&lt;/code&gt; 이상 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="69cc11cd813a9fd03e4e1fc6cf5b510b36e19495" translate="yes" xml:space="preserve">
          <source>Enforces total ordering with all other &lt;code&gt;__ATOMIC_SEQ_CST&lt;/code&gt; operations.</source>
          <target state="translated">다른 모든 &lt;code&gt;__ATOMIC_SEQ_CST&lt;/code&gt; 작업 과 함께 전체 주문을 시행 합니다.</target>
        </trans-unit>
        <trans-unit id="73b1dc6c07adcccbcc5d5e8b0eff931a874c6d38" translate="yes" xml:space="preserve">
          <source>Enumerator Attributes</source>
          <target state="translated">열거 자 속성</target>
        </trans-unit>
        <trans-unit id="761809a73bf6c1d0fb389d9bcb324c7d577436ca" translate="yes" xml:space="preserve">
          <source>Env vars that affect GCC.</source>
          <target state="translated">GCC에 영향을 미치는 환경 변수.</target>
        </trans-unit>
        <trans-unit id="ea26afcbc28cf64cc5104756e2576f023e89221a" translate="yes" xml:space="preserve">
          <source>Epiphany&amp;mdash;</source>
          <target state="translated">Epiphany&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="fdd6abe4d3e43555fd6a8a4c1cf45b848e487e53" translate="yes" xml:space="preserve">
          <source>Equivalent to</source>
          <target state="translated">에 해당</target>
        </trans-unit>
        <trans-unit id="0492deafa8eba22fc0afe8f6e0c0ba64239ba223" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;r&lt;/code&gt;; retained for backwards compatibility.</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; 과 같습니다 . 이전 버전과의 호환성을 위해 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="5ca07fcd394d3a2e5866991bf00cbd021a139de4" translate="yes" xml:space="preserve">
          <source>Errors in the 1990 ISO C standard were corrected in two Technical Corrigenda published in 1994 and 1996. GCC does not support the uncorrected version.</source>
          <target state="translated">1990 년 ISO C 표준의 오류는 1994 년과 1996 년에 발표 된 2 개의 기술 코리 젠다에서 수정되었습니다. GCC는 수정되지 않은 버전을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9bd134a89f5b4b95f3127d3f912224b4af14b70c" translate="yes" xml:space="preserve">
          <source>Errors in the 1999 ISO C standard were corrected in three Technical Corrigenda published in 2001, 2004 and 2007. GCC does not support the uncorrected version.</source>
          <target state="translated">1999 년 ISO C 표준의 오류는 2001 년, 2004 년 및 2007 년에 발표 된 3 개의 Technical Corrigenda에서 수정되었습니다. GCC는 수정되지 않은 버전을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6e25566cabac14a5da9bfa8653af8b052717aff4" translate="yes" xml:space="preserve">
          <source>Estimate on average number of instructions that are executed before prefetch finishes. The distance prefetched ahead is proportional to this constant. Increasing this number may also lead to less streams being prefetched (see</source>
          <target state="translated">프리 페치가 완료되기 전에 실행되는 평균 명령어 수를 추정하십시오. 미리 가져온 거리는이 상수에 비례합니다. 이 수를 늘리면 프리 페치되는 스트림이 줄어들 수도 있습니다 (참조</target>
        </trans-unit>
        <trans-unit id="72b4ac99601ca6a847d5bc2efd8309225cad447d" translate="yes" xml:space="preserve">
          <source>Evaluate member access, array subscripting, and shift expressions in left-to-right order, and evaluate assignment in right-to-left order, as adopted for C++17. Enabled by default with</source>
          <target state="translated">C ++ 17에 채택 된대로 멤버 액세스, 배열 첨자 및 시프트 표현식을 왼쪽에서 오른쪽 순서로 평가하고 오른쪽에서 왼쪽 순서로 지정을 평가하십시오. 기본적으로 활성화</target>
        </trans-unit>
        <trans-unit id="ed6e92089eb6b24b347c4f30cb7670720994b11e" translate="yes" xml:space="preserve">
          <source>Even if</source>
          <target state="translated">설사</target>
        </trans-unit>
        <trans-unit id="8ba62c67150da80165ae50905d020111dae00562" translate="yes" xml:space="preserve">
          <source>Even if a recovery mode is turned on the compiler side, it needs to be also enabled on the runtime library side, otherwise the failures are still fatal. The runtime library defaults to &lt;code&gt;halt_on_error=0&lt;/code&gt; for ThreadSanitizer and UndefinedBehaviorSanitizer, while default value for AddressSanitizer is &lt;code&gt;halt_on_error=1&lt;/code&gt;. This can be overridden through setting the &lt;code&gt;halt_on_error&lt;/code&gt; flag in the corresponding environment variable.</source>
          <target state="translated">복구 모드가 컴파일러 쪽에서 켜져 있어도 런타임 라이브러리 쪽에서도 활성화해야합니다. 그렇지 않으면 오류가 여전히 치명적입니다. ThreadSanitizer 및 UndefinedBehaviorSanitizer 의 경우 런타임 라이브러리의 기본값은 &lt;code&gt;halt_on_error=0&lt;/code&gt; 이고 AddressSanitizer의 기본값은 &lt;code&gt;halt_on_error=1&lt;/code&gt; 입니다. 이는 해당 환경 변수에서 &lt;code&gt;halt_on_error&lt;/code&gt; 플래그 를 설정하여 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="da53370f643fa43e1823dc15023009c950cb897a" translate="yes" xml:space="preserve">
          <source>Even if a zero-length bit-field is not followed by a normal bit-field, it may still affect the alignment of the structure:</source>
          <target state="translated">길이가 0 인 비트 필드 뒤에 일반 비트 필드가없는 경우에도 구조의 정렬에 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b825b64ce454de632ebee37b594db5436e47422" translate="yes" xml:space="preserve">
          <source>Even if this switch is enabled, not all function calls are turned into long calls. The heuristic is that static functions, functions that have the &lt;code&gt;short_call&lt;/code&gt; attribute, functions that are inside the scope of a &lt;code&gt;#pragma no_long_calls&lt;/code&gt; directive, and functions whose definitions have already been compiled within the current compilation unit are not turned into long calls. The exceptions to this rule are that weak function definitions, functions with the &lt;code&gt;long_call&lt;/code&gt; attribute or the &lt;code&gt;section&lt;/code&gt; attribute, and functions that are within the scope of a &lt;code&gt;#pragma long_calls&lt;/code&gt; directive are always turned into long calls.</source>
          <target state="translated">이 스위치를 사용하더라도 모든 기능 호출이 긴 호출로 변환되는 것은 아닙니다. 휴리스틱은 정적 함수, &lt;code&gt;short_call&lt;/code&gt; 속성 이있는 함수, &lt;code&gt;#pragma no_long_calls&lt;/code&gt; 지시문 범위 내에있는 함수 및 현재 컴파일 단위 내에서 정의가 이미 컴파일 된 함수는 긴 호출로 변환되지 않는다는 것입니다. 이 규칙의 예외는 약한 함수 정의, &lt;code&gt;long_call&lt;/code&gt; 속성 또는 &lt;code&gt;section&lt;/code&gt; 속성이있는 함수 및 &lt;code&gt;#pragma long_calls&lt;/code&gt; 지시문 의 범위 내에있는 함수 는 항상 긴 호출로 바뀌는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a177b98fd2580c16f017a412cd7670171b404cf0" translate="yes" xml:space="preserve">
          <source>Even if you specify</source>
          <target state="translated">지정한 경우에도</target>
        </trans-unit>
        <trans-unit id="026e995923c6387a8240f24bd1c3774f9d66883c" translate="yes" xml:space="preserve">
          <source>Even register</source>
          <target state="translated">등록</target>
        </trans-unit>
        <trans-unit id="1873ee5db4140cfb18dab53240c9f43c6ee8669a" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;sum&lt;/code&gt; is accumulated in the loop, no use is made of that summation, so the accumulation can be removed.</source>
          <target state="translated">루프에 &lt;code&gt;sum&lt;/code&gt; 가 누적 되더라도 해당 합계 는 사용되지 않으므로 누적을 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b22f73b585732fa4671fb4003533ee7b0a1cf1d" translate="yes" xml:space="preserve">
          <source>Even-numbered D register</source>
          <target state="translated">짝수 D 레지스터</target>
        </trans-unit>
        <trans-unit id="7a684983474ccc7c72520e56a87f8aeb051b1c6b" translate="yes" xml:space="preserve">
          <source>Even-numbered accumulator register.</source>
          <target state="translated">짝수 누산기 레지스터.</target>
        </trans-unit>
        <trans-unit id="5d57aa9755d20359a2247e4c26c56f18f53bb2c4" translate="yes" xml:space="preserve">
          <source>Every data object has an alignment requirement. The alignment requirement for all data except structures, unions, and arrays is either the size of the object or the current packing size (specified with either the &lt;code&gt;aligned&lt;/code&gt; attribute or the &lt;code&gt;pack&lt;/code&gt; pragma), whichever is less. For structures, unions, and arrays, the alignment requirement is the largest alignment requirement of its members. Every object is allocated an offset so that:</source>
          <target state="translated">모든 데이터 개체에는 정렬 요구 사항이 있습니다. 구조체, 공용체 및 배열을 제외한 모든 데이터의 정렬 요구 사항은 객체의 크기 또는 현재 패킹 크기 ( &lt;code&gt;aligned&lt;/code&gt; 속성 또는 &lt;code&gt;pack&lt;/code&gt; pragma로 지정됨 ) 중 작은 값입니다. 구조체, 공용체 및 배열의 ​​경우 정렬 요구 사항은 멤버의 가장 큰 정렬 요구 사항입니다. 모든 객체에는 다음과 같은 오프셋이 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="f8971cb366f8a5972e5437f17d61872668933fb6" translate="yes" xml:space="preserve">
          <source>Exact power of 2</source>
          <target state="translated">2의 정확한 힘</target>
        </trans-unit>
        <trans-unit id="54ce059465b2a026c1f41bec2bf7eb93331ac554" translate="yes" xml:space="preserve">
          <source>Exactly like</source>
          <target state="translated">정확히 같은</target>
        </trans-unit>
        <trans-unit id="ec471d84b36457f0d9d75c03377c9e3cd5f3de93" translate="yes" xml:space="preserve">
          <source>Example of use:</source>
          <target state="translated">사용 예 :</target>
        </trans-unit>
        <trans-unit id="861245b8779c3c0a240081e66f72046983ca7d16" translate="yes" xml:space="preserve">
          <source>Example usage</source>
          <target state="translated">사용법 예</target>
        </trans-unit>
        <trans-unit id="98859dfb330cbeca8950e6e5316d288484dfa387" translate="yes" xml:space="preserve">
          <source>Example usage of these low level built-in functions may look like:</source>
          <target state="translated">이러한 저수준 내장 함수의 사용 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="3203ec56f6623a12f68979ebebcaf218b0674056" translate="yes" xml:space="preserve">
          <source>Examples of code with undefined behavior are &lt;code&gt;a = a++;&lt;/code&gt;, &lt;code&gt;a[n]
= b[n++]&lt;/code&gt; and &lt;code&gt;a[i++] = i;&lt;/code&gt;. Some more complicated cases are not diagnosed by this option, and it may give an occasional false positive result, but in general it has been found fairly effective at detecting this sort of problem in programs.</source>
          <target state="translated">동작이 정의되지 않은 코드의 예는 &lt;code&gt;a = a++;&lt;/code&gt; , &lt;code&gt;a[n] = b[n++]&lt;/code&gt; 및 &lt;code&gt;a[i++] = i;&lt;/code&gt; . 좀 더 복잡한 경우는이 옵션으로 진단되지 않으며 가끔 오 탐지를 유발할 수 있지만 일반적으로 프로그램에서 이러한 종류의 문제를 감지하는 데 상당히 효과적입니다.</target>
        </trans-unit>
        <trans-unit id="ac2978569b0d96ea67fa55ae3fcac3a58dbeaa7e" translate="yes" xml:space="preserve">
          <source>Examples of the use cases for this tool are:</source>
          <target state="translated">이 도구의 사용 사례는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="911d893025886382ab91769b068aa06459b40499" translate="yes" xml:space="preserve">
          <source>Exception handlers differ from interrupt handlers because the system pushes an error code on the stack. An exception handler declaration is similar to that for an interrupt handler, but with a different mandatory function signature. The compiler arranges to pop the error code off the stack before the &lt;code&gt;IRET&lt;/code&gt; instruction.</source>
          <target state="translated">시스템이 스택에서 오류 코드를 푸시하기 때문에 예외 처리기는 인터럽트 처리기와 다릅니다. 예외 처리기 선언은 인터럽트 처리기의 경우와 비슷하지만 필수 함수 서명이 다릅니다. 컴파일러는 &lt;code&gt;IRET&lt;/code&gt; 명령 전에 오류 코드를 스택에서 팝합니다 .</target>
        </trans-unit>
        <trans-unit id="d60ce999e28bc42ef5590e1790afd26bd6f33f60" translate="yes" xml:space="preserve">
          <source>Exception handlers should only be used for exceptions that push an error code; you should use an interrupt handler in other cases. The system will crash if the wrong kind of handler is used.</source>
          <target state="translated">예외 처리기는 오류 코드를 발생시키는 예외에만 사용해야합니다. 다른 경우에는 인터럽트 처리기를 사용해야합니다. 잘못된 종류의 핸들러를 사용하면 시스템이 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="61c358f1bb209146fb6ebbb188045ae7738fdddb" translate="yes" xml:space="preserve">
          <source>Execution and Data Prediction Restriction Instructions.</source>
          <target state="translated">실행 및 데이터 예측 제한 지침.</target>
        </trans-unit>
        <trans-unit id="cd06a6fd64c8b50d4558cb3316fd26ee9feb5746" translate="yes" xml:space="preserve">
          <source>Expand &lt;code&gt;adddi3&lt;/code&gt; and &lt;code&gt;subdi3&lt;/code&gt; at RTL generation time into &lt;code&gt;add.f&lt;/code&gt;, &lt;code&gt;adc&lt;/code&gt; etc. This option is deprecated.</source>
          <target state="translated">RTL 생성시 &lt;code&gt;adddi3&lt;/code&gt; 및 &lt;code&gt;subdi3&lt;/code&gt; 을 &lt;code&gt;add.f&lt;/code&gt; , &lt;code&gt;adc&lt;/code&gt; 등 으로 확장하십시오 .이 옵션은 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ad01d735326a2f6603f39ee595dd5b05ec416e8b" translate="yes" xml:space="preserve">
          <source>Expand into an inline loop.</source>
          <target state="translated">인라인 루프로 확장하십시오.</target>
        </trans-unit>
        <trans-unit id="5ddf0ba44f58c348b4ec4063056d25a8b4689f7a" translate="yes" xml:space="preserve">
          <source>Expand using i386 &lt;code&gt;rep&lt;/code&gt; prefix of the specified size.</source>
          <target state="translated">지정된 크기의 i386 &lt;code&gt;rep&lt;/code&gt; 접두사를 사용하여 확장하십시오 .</target>
        </trans-unit>
        <trans-unit id="7720f0269a2d383f2dd786328047f312351d0105" translate="yes" xml:space="preserve">
          <source>Explain what alignment considerations lead to the decision to make an instruction short or long.</source>
          <target state="translated">어떤 정렬 고려 사항이 지시를 짧게 또는 길게 결정하기로 결정했는지 설명하십시오.</target>
        </trans-unit>
        <trans-unit id="69ccd30207ce48099a948be1541f4d6a441981f8" translate="yes" xml:space="preserve">
          <source>Explicit instantiations can be used for the largest or most frequently duplicated instances, without having to know exactly which other instances are used in the rest of the program. You can scatter the explicit instantiations throughout your program, perhaps putting them in the translation units where the instances are used or the translation units that define the templates themselves; you can put all of the explicit instantiations you need into one big file; or you can create small files like</source>
          <target state="translated">프로그램의 나머지 부분에서 어떤 다른 인스턴스가 사용되는지 정확히 알 필요없이 가장 큰 인스턴스 또는 가장 자주 복제되는 인스턴스에 대해 명시 적 인스턴스를 사용할 수 있습니다. 프로그램 전체에 명시 적 인스턴스를 분산시켜 인스턴스가 사용되는 변환 단위 또는 템플리트 자체를 정의하는 변환 단위에 넣을 수 있습니다. 필요한 모든 명시 적 인스턴스를 하나의 큰 파일에 넣을 수 있습니다. 또는 작은 파일을 만들 수 있습니다</target>
        </trans-unit>
        <trans-unit id="83042939fc50e1e36ef864fc1e78eae1c62725bf" translate="yes" xml:space="preserve">
          <source>Explicitly instantiated inline methods are unaffected by this option as their linkage might otherwise cross a shared library boundary. See &lt;a href=&quot;template-instantiation#Template-Instantiation&quot;&gt;Template Instantiation&lt;/a&gt;.</source>
          <target state="translated">명시 적으로 인스턴스화 된 인라인 메소드는 링크가 공유 라이브러리 경계를 넘을 수 있으므로이 옵션의 영향을받지 않습니다. &lt;a href=&quot;template-instantiation#Template-Instantiation&quot;&gt;템플릿 인스턴스화를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="61bd3ccba4b2c3767215774893d82391e0bc09ab" translate="yes" xml:space="preserve">
          <source>Expressions are currently only contracted if</source>
          <target state="translated">표현식은 현재 다음과 같은 경우에만 계약됩니다.</target>
        </trans-unit>
        <trans-unit id="83c4bb072fc47e954ad84b1ea046adec27e854fd" translate="yes" xml:space="preserve">
          <source>Expressions that may be cast to the union type are those whose type matches at least one of the members of the union. Thus, given the following union and variables:</source>
          <target state="translated">공용체 유형으로 캐스트 될 수있는 표현식은 형식이 공용체 멤버 중 하나 이상과 일치하는 표현식입니다. 따라서 다음과 같은 합집합과 변수가 주어집니다.</target>
        </trans-unit>
        <trans-unit id="ed9daef21d2e4305e648aee577dd1d6036550745" translate="yes" xml:space="preserve">
          <source>Extend (do not extend) the</source>
          <target state="translated">연장 (확장하지 않음)</target>
        </trans-unit>
        <trans-unit id="20891f4ff37ed22f4675dae3faaf487875cf701e" translate="yes" xml:space="preserve">
          <source>Extend the current ABI with a particular extension, or remove such extension. Valid values are &amp;lsquo;</source>
          <target state="translated">특정 확장으로 현재 ABI를 확장하거나 해당 확장을 제거하십시오. 유효한 값은 '</target>
        </trans-unit>
        <trans-unit id="91653b5f0401d6aa2a22ebdd6efdf9699bdaeb42" translate="yes" xml:space="preserve">
          <source>Extended &lt;code&gt;asm&lt;/code&gt; statements have to be inside a C function, so to write inline assembly language at file scope (&amp;ldquo;top-level&amp;rdquo;), outside of C functions, you must use basic &lt;code&gt;asm&lt;/code&gt;. You can use this technique to emit assembler directives, define assembly language macros that can be invoked elsewhere in the file, or write entire functions in assembly language. Basic &lt;code&gt;asm&lt;/code&gt; statements outside of functions may not use any qualifiers.</source>
          <target state="translated">확장 된 &lt;code&gt;asm&lt;/code&gt; 문은 C 함수 내에 있어야하므로 C 함수 외부의 파일 범위 ( &quot;최상위 수준&quot;)에서 인라인 어셈블리 언어를 작성하려면 기본 &lt;code&gt;asm&lt;/code&gt; 을 사용해야합니다 . 이 기술을 사용하여 어셈블러 지시문을 생성하거나 파일의 다른 곳에서 호출 할 수있는 어셈블리 언어 매크로를 정의하거나 전체 함수를 어셈블리 언어로 작성할 수 있습니다. 함수 외부의 기본 &lt;code&gt;asm&lt;/code&gt; 문은 한정자를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="04a315d0cc75470cd36dfd3cb992c3efb5b94ebf" translate="yes" xml:space="preserve">
          <source>Extended alignments up to &lt;em&gt;2^{28}&lt;/em&gt; (bytes) are supported for objects of automatic storage duration. Alignments supported for objects of static and thread storage duration are determined by the ABI.</source>
          <target state="translated">자동 스토리지 기간의 오브젝트에 대해 최대 &lt;em&gt;2 ^ {28}&lt;/em&gt; (바이트)의 확장 정렬 이 지원됩니다. 정적 및 스레드 저장 기간의 개체에 지원되는 정렬은 ABI에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="342b07a4e48b541946d49b2270415ae84b1aef83" translate="yes" xml:space="preserve">
          <source>Extended registers are not stored on stack before execution of function with monitor attribute. Default option is</source>
          <target state="translated">확장 된 레지스터는 모니터 속성으로 기능을 실행하기 전에 스택에 저장되지 않습니다. 기본 옵션은</target>
        </trans-unit>
        <trans-unit id="57cf6f586241383946ebaa10651980906e2e7008" translate="yes" xml:space="preserve">
          <source>Extended registers are stored on stack before execution of function with monitor attribute. Default option is</source>
          <target state="translated">확장 레지스터는 모니터 속성으로 기능을 실행하기 전에 스택에 저장됩니다. 기본 옵션은</target>
        </trans-unit>
        <trans-unit id="c9dbca1f0ee851a1a4128829e444f15ff917ef20" translate="yes" xml:space="preserve">
          <source>Extra time accounted by inliner for function overhead such as time needed to execute function prologue and epilogue</source>
          <target state="translated">함수 프롤로그 및 에필로그를 실행하는 데 필요한 시간과 같은 함수 오버 헤드로 인해 인라이너에서 추가 시간 처리</target>
        </trans-unit>
        <trans-unit id="e69f20e9f683920d3fb4329abd951e878b1f9372" translate="yes" xml:space="preserve">
          <source>F</source>
          <target state="translated">F</target>
        </trans-unit>
        <trans-unit id="6b84b9421bc7074ef9cc3088b04a6a18d77c5b2a" translate="yes" xml:space="preserve">
          <source>FMA instructions.</source>
          <target state="translated">FMA 지침.</target>
        </trans-unit>
        <trans-unit id="cbf2cb3fe36db407f3a3f0c5e7fef7fc69c6ce00" translate="yes" xml:space="preserve">
          <source>FMA4 instructions.</source>
          <target state="translated">FMA4 지침.</target>
        </trans-unit>
        <trans-unit id="b911450c0baee87cf3722095b3e43b717fb436bb" translate="yes" xml:space="preserve">
          <source>FP or VSX register to hold 64-bit doubles for direct moves or NO_REGS.</source>
          <target state="translated">직접 이동 또는 NO_REGS를 위해 64 비트 더블을 보유하는 FP 또는 VSX 레지스터.</target>
        </trans-unit>
        <trans-unit id="faed2456bafb04f8c1fb3d816c3c01f0fb54a75c" translate="yes" xml:space="preserve">
          <source>FP or VSX register to hold 64-bit integers for VSX insns or NO_REGS.</source>
          <target state="translated">VSX insns 또는 NO_REGS에 대해 64 비트 정수를 보유하는 FP 또는 VSX 레지스터</target>
        </trans-unit>
        <trans-unit id="09f3e1a89b6305e70a6393d549d66dbbcfd2f8f3" translate="yes" xml:space="preserve">
          <source>FP or VSX register to hold 64-bit integers for direct moves or NO_REGS.</source>
          <target state="translated">직접 이동 또는 NO_REGS를 위해 64 비트 정수를 보유하는 FP 또는 VSX 레지스터.</target>
        </trans-unit>
        <trans-unit id="ec3d1f378b46e7073f89e8d2b44ffed3f4925fb8" translate="yes" xml:space="preserve">
          <source>FP or VSX register to perform ISA 2.07 float ops or NO_REGS.</source>
          <target state="translated">ISA 2.07 float ops 또는 NO_REGS를 수행하기위한 FP 또는 VSX 레지스터.</target>
        </trans-unit>
        <trans-unit id="c07c5ae5e3671f1039b7da098eb0348a7624af7b" translate="yes" xml:space="preserve">
          <source>FP or VSX register to perform float operations under</source>
          <target state="translated">FP 또는 VSX 레지스터에서 플로트 연산을 수행</target>
        </trans-unit>
        <trans-unit id="a924751782c4ee4b5b496793046fc57512ab59f9" translate="yes" xml:space="preserve">
          <source>FP register if</source>
          <target state="translated">FP 등록</target>
        </trans-unit>
        <trans-unit id="5b1d99e5f9118d7c70848e6ad6167bba8b0b23d3" translate="yes" xml:space="preserve">
          <source>FPSCR</source>
          <target state="translated">FPSCR</target>
        </trans-unit>
        <trans-unit id="ff875f9855f1361e4b30af2d77d0d9c23d4bdca2" translate="yes" xml:space="preserve">
          <source>FRV&amp;mdash;</source>
          <target state="translated">FRV&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="230d241b3d82558160cd5187f1fe9d9c435b18d5" translate="yes" xml:space="preserve">
          <source>FSF GCC on Darwin does not create &amp;ldquo;fat&amp;rdquo; object files; it creates an object file for the single architecture that GCC was built to target. Apple&amp;rsquo;s GCC on Darwin does create &amp;ldquo;fat&amp;rdquo; files if multiple</source>
          <target state="translated">Darwin의 FSF GCC는 &quot;지방&quot;개체 파일을 만들지 않습니다. GCC가 대상으로 구축 한 단일 아키텍처에 대한 객체 파일을 생성합니다. Darwin에있는 Apple의 GCC는 여러 개의 &quot;지방&quot;파일을 생성합니다</target>
        </trans-unit>
        <trans-unit id="7a156574143e4ca84e24da6dfdb279cf456cca04" translate="yes" xml:space="preserve">
          <source>FT32&amp;mdash;</source>
          <target state="translated">FT32&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="599d4afb33240eb91ea2840bb9ba8f1ff44bf581" translate="yes" xml:space="preserve">
          <source>Fat LTO objects are object files that contain both the intermediate language and the object code. This makes them usable for both LTO linking and normal linking. This option is effective only when compiling with</source>
          <target state="translated">팻 LTO 객체는 중간 언어와 객체 코드를 모두 포함하는 객체 파일입니다. 이를 통해 LTO 연결과 일반 연결 모두에 사용할 수 있습니다. 이 옵션은 컴파일 할 때만 유효합니다</target>
        </trans-unit>
        <trans-unit id="ad565d9d01d0e0bf91fd6a8532f6d81613338901" translate="yes" xml:space="preserve">
          <source>Feature</source>
          <target state="translated">Feature</target>
        </trans-unit>
        <trans-unit id="909a10c01414726d2e86792cc51fea9d589c8fb6" translate="yes" xml:space="preserve">
          <source>Feature Modifiers</source>
          <target state="translated">기능 수정 자</target>
        </trans-unit>
        <trans-unit id="c796b811ac5dce8d8e36d70db0e07e63b27d5eab" translate="yes" xml:space="preserve">
          <source>Feature modifiers used with</source>
          <target state="translated">함께 사용되는 기능 수정 자</target>
        </trans-unit>
        <trans-unit id="aa0dd17c258c743dbea5c193ddf09bb6cebf5964" translate="yes" xml:space="preserve">
          <source>Fields of the &lt;var&gt;branch&lt;/var&gt; element have following semantics:</source>
          <target state="translated">&lt;var&gt;branch&lt;/var&gt; 요소의 필드 는 다음과 같은 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="9cc6e9443d376e5757bc3441d57c3f310bf11770" translate="yes" xml:space="preserve">
          <source>Fields of the &lt;var&gt;file&lt;/var&gt; element have following semantics:</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt; 요소의 필드 는 다음과 같은 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="95d9f92882f18f3b5a67ac3eeafb040cc8cd3ea3" translate="yes" xml:space="preserve">
          <source>Fields of the &lt;var&gt;function&lt;/var&gt; element have following semantics:</source>
          <target state="translated">&lt;var&gt;function&lt;/var&gt; 요소의 필드 는 다음과 같은 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="55692b6d4a213073df2d182e70897f1d18b6852c" translate="yes" xml:space="preserve">
          <source>Fields of the root element have following semantics:</source>
          <target state="translated">루트 요소의 필드는 다음과 같은 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="fba211bc33a4751c92e11eae269c5fe4195a12b5" translate="yes" xml:space="preserve">
          <source>Finally &amp;lsquo;</source>
          <target state="translated">드디어 '</target>
        </trans-unit>
        <trans-unit id="fa45d699cd27babdae75f4a8d69ed2b5379e7a87" translate="yes" xml:space="preserve">
          <source>Finally, consider:</source>
          <target state="translated">마지막으로 다음을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="6901050dc8495daab10889e0ec9cf3617e7fb433" translate="yes" xml:space="preserve">
          <source>Finally, note how we declared the &lt;code&gt;len&lt;/code&gt; argument and the return value to be of type &lt;code&gt;unsigned long&lt;/code&gt;. They could also be declared to be of type &lt;code&gt;unsigned int&lt;/code&gt; and everything would still work.</source>
          <target state="translated">마지막으로 &lt;code&gt;len&lt;/code&gt; 인수와 반환 값을 &lt;code&gt;unsigned long&lt;/code&gt; 유형으로 선언 한 방법에 주목하십시오 . 또한 &lt;code&gt;unsigned int&lt;/code&gt; 유형으로 선언 될 수 있으며 모든 것이 여전히 작동합니다.</target>
        </trans-unit>
        <trans-unit id="e5f1ab577d27769ef2407d2da5789ec6bcd34e2a" translate="yes" xml:space="preserve">
          <source>Finally, there is a complication when encoding &lt;code&gt;const char *&lt;/code&gt; versus &lt;code&gt;char * const&lt;/code&gt;. Because &lt;code&gt;char *&lt;/code&gt; is encoded as &lt;code&gt;*&lt;/code&gt; and not as &lt;code&gt;^c&lt;/code&gt;, there is no way to express the fact that &lt;code&gt;r&lt;/code&gt; applies to the pointer or to the pointee.</source>
          <target state="translated">마지막으로 &lt;code&gt;const char *&lt;/code&gt; 와 &lt;code&gt;char * const&lt;/code&gt; 인코딩 할 때 문제가 발생 합니다. 때문에 &lt;code&gt;char *&lt;/code&gt; 로 부호화 &lt;code&gt;*&lt;/code&gt; 및하지 &lt;code&gt;^c&lt;/code&gt; 있다는 사실을 표현하는 방법이 없다 &lt;code&gt;r&lt;/code&gt; 포인터 나 pointee 적용이.</target>
        </trans-unit>
        <trans-unit id="8d30428380add9f793c9b319edf17d149e4e4f73" translate="yes" xml:space="preserve">
          <source>Find the pass dump in a file whose name is composed of three components separated by a period: the name of the source file GCC was invoked to compile, a numeric suffix indicating the pass number followed by the letter &amp;lsquo;</source>
          <target state="translated">이름으로 마침표로 구분 된 세 가지 구성 요소로 구성된 파일에서 패스 덤프를 찾으십시오. 소스 파일 GCC가 컴파일을 위해 호출되어 패스 번호를 나타내는 숫자 접미 부와 '</target>
        </trans-unit>
        <trans-unit id="e29b12881247aeb3ff64dc0cee23e3331d67217f" translate="yes" xml:space="preserve">
          <source>Fine-tune size optimization with regards to instruction lengths and alignment. The recognized values for &lt;var&gt;level&lt;/var&gt; are:</source>
          <target state="translated">명령어 길이 및 정렬과 관련하여 크기를 미세 조정하십시오. &lt;var&gt;level&lt;/var&gt; 에 대해 인식되는 값 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ac0c5ec00d58b3e74a205bd50ea7108335fcb5b8" translate="yes" xml:space="preserve">
          <source>First SSE register (&lt;code&gt;%xmm0&lt;/code&gt;).</source>
          <target state="translated">첫 번째 SSE 레지스터 ( &lt;code&gt;%xmm0&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="846211171f7db5bd2bab9f64d61f4530995ca5a0" translate="yes" xml:space="preserve">
          <source>First, the argument corresponding to a transparent union type can be of any type in the union; no cast is required. Also, if the union contains a pointer type, the corresponding argument can be a null pointer constant or a void pointer expression; and if the union contains a void pointer type, the corresponding argument can be any pointer expression. If the union member type is a pointer, qualifiers like &lt;code&gt;const&lt;/code&gt; on the referenced type must be respected, just as with normal pointer conversions.</source>
          <target state="translated">먼저 투명한 공용체 유형에 해당하는 인수는 공용체의 모든 유형이 될 수 있습니다. 캐스트가 필요하지 않습니다. 또한 공용체에 포인터 유형이 포함 된 경우 해당 인수는 널 포인터 상수 또는 공백 포인터 표현식 일 수 있습니다. 공용체에 void 포인터 유형이 포함 된 경우 해당 인수는 모든 포인터 표현식 일 수 있습니다. 공용체 멤버 형식이 포인터 인 경우 일반 포인터 변환과 마찬가지로 참조 형식의 &lt;code&gt;const&lt;/code&gt; 와 같은 한정자 가 존중되어야합니다.</target>
        </trans-unit>
        <trans-unit id="15ab13a54971de84d7939a64c563f0a383d5df53" translate="yes" xml:space="preserve">
          <source>Fixed form Fortran source code that must be preprocessed (with the traditional preprocessor).</source>
          <target state="translated">사전 처리해야하는 고정 양식 Fortran 소스 코드 (전통적인 전 처리기 사용).</target>
        </trans-unit>
        <trans-unit id="5552528a96a767723e84e4196dd1b4ccd0182f5d" translate="yes" xml:space="preserve">
          <source>Fixed form Fortran source code that should not be preprocessed.</source>
          <target state="translated">전처리해서는 안되는 고정 양식 포트란 소스 코드.</target>
        </trans-unit>
        <trans-unit id="a31ce070cf9649524c3cf990ab1f1ab74aaffaa3" translate="yes" xml:space="preserve">
          <source>Fixed limit on the size of the static frame of functions: when it is topped by a particular function, stack checking is not reliable and a warning is issued by the compiler.</source>
          <target state="translated">정적 함수 프레임의 크기에 대한 고정 된 제한 : 특정 함수가 차지할 때 스택 검사가 신뢰할 수없고 컴파일러에서 경고를 발행합니다.</target>
        </trans-unit>
        <trans-unit id="85452dd45f77555cfc8a81ff291dd73781c80f82" translate="yes" xml:space="preserve">
          <source>Fixed-Point Types.</source>
          <target state="translated">고정 소수점 유형.</target>
        </trans-unit>
        <trans-unit id="9f75981b930fd7189960fca9ba3bbc1796113fd3" translate="yes" xml:space="preserve">
          <source>Fixed-point data values contain fractional and optional integral parts. The format of fixed-point data varies and depends on the target machine.</source>
          <target state="translated">고정 소수점 데이터 값에는 분수 및 선택적 정수 부분이 포함됩니다. 고정 소수점 데이터의 형식은 다양하며 대상 시스템에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="cb9fd0ce1881fdc78c0697ef42b75b52d214196d" translate="yes" xml:space="preserve">
          <source>Fixed-point types are supported by the DWARF debug information format.</source>
          <target state="translated">고정 소수점 유형은 DWARF 디버그 정보 형식에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="265c5eecf02fb4f371ef39bcfe52b0dfc566b452" translate="yes" xml:space="preserve">
          <source>Flag the first routine whose name starts with &lt;var&gt;prefix&lt;/var&gt; as the main routine for the debugger.</source>
          <target state="translated">디버거의 기본 루틴으로 이름이 &lt;var&gt;prefix&lt;/var&gt; 로 시작하는 첫 번째 루틴을 플래그하십시오 .</target>
        </trans-unit>
        <trans-unit id="b3390bf7e3c55aee432834653f4b1f941089ffde" translate="yes" xml:space="preserve">
          <source>Flexible array members are written as &lt;code&gt;contents[]&lt;/code&gt; without the &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">유연한 배열 멤버는 &lt;code&gt;0&lt;/code&gt; 없이 &lt;code&gt;contents[]&lt;/code&gt; 로 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="78dbcf864480c990f48bdd0342e3500b8c1282bd" translate="yes" xml:space="preserve">
          <source>Flexible array members have incomplete type, and so the &lt;code&gt;sizeof&lt;/code&gt; operator may not be applied. As a quirk of the original implementation of zero-length arrays, &lt;code&gt;sizeof&lt;/code&gt; evaluates to zero.</source>
          <target state="translated">유연한 배열 구성원의 유형이 불완전하므로 &lt;code&gt;sizeof&lt;/code&gt; 연산자가 적용되지 않을 수 있습니다. 길이가 0 인 배열의 원래 구현의 단점으로 &lt;code&gt;sizeof&lt;/code&gt; 는 0으로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="417d40e05d0999fe399d7881ccf242563a660e4a" translate="yes" xml:space="preserve">
          <source>Flexible array members may only appear as the last member of a &lt;code&gt;struct&lt;/code&gt; that is otherwise non-empty.</source>
          <target state="translated">유연한 배열 멤버 는 그렇지 않으면 비어 있지 않은 &lt;code&gt;struct&lt;/code&gt; 의 마지막 멤버로만 나타날 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7ffa11ebef97287859a0bb0cd563e4e8b95df556" translate="yes" xml:space="preserve">
          <source>Floating point constant 0.</source>
          <target state="translated">부동 소수점 상수 0.</target>
        </trans-unit>
        <trans-unit id="4560e48bbc91965a1ad028ff4792c55d56a0a598" translate="yes" xml:space="preserve">
          <source>Floating point constant that can be loaded into a register with one instruction per word</source>
          <target state="translated">워드 당 하나의 명령으로 레지스터에로드 할 수있는 부동 소수점 상수</target>
        </trans-unit>
        <trans-unit id="c516f23fc0c0d103a2cd7b68a6433df4fc2451d6" translate="yes" xml:space="preserve">
          <source>Floating point constant that is legal for store immediate</source>
          <target state="translated">즉시 상점에 유효한 부동 소수점 상수</target>
        </trans-unit>
        <trans-unit id="32a95fa9a487a375449247a65d3193bb1004c1f0" translate="yes" xml:space="preserve">
          <source>Floating point constant that is not a 68881 constant</source>
          <target state="translated">68881 상수가 아닌 부동 소수점 상수</target>
        </trans-unit>
        <trans-unit id="79fb00b4bc62aed23a250b86e31fbd72d18840a5" translate="yes" xml:space="preserve">
          <source>Floating point constant zero</source>
          <target state="translated">부동 소수점 상수 제로</target>
        </trans-unit>
        <trans-unit id="af1bda543b578583ca4289ffad142bd3d77692c3" translate="yes" xml:space="preserve">
          <source>Floating point register</source>
          <target state="translated">부동 소수점 레지스터</target>
        </trans-unit>
        <trans-unit id="573ca6d44dc3da178f33a1539aefbe9a7a969613" translate="yes" xml:space="preserve">
          <source>Floating point register (containing 32-bit value)</source>
          <target state="translated">부동 소수점 레지스터 (32 비트 값 포함)</target>
        </trans-unit>
        <trans-unit id="b5c02f93e377f6b8a0b2a78a784d0d990452bae9" translate="yes" xml:space="preserve">
          <source>Floating point register (containing 64-bit value)</source>
          <target state="translated">부동 소수점 레지스터 (64 비트 값 포함)</target>
        </trans-unit>
        <trans-unit id="ef449f8f1e197b3fc12f9a7bbd29815185c01715" translate="yes" xml:space="preserve">
          <source>Floating point register (deprecated)</source>
          <target state="translated">부동 소수점 레지스터 (더 이상 사용되지 않음)</target>
        </trans-unit>
        <trans-unit id="f7558c1a4bb9c6d833aca45e4903e960fa15f358" translate="yes" xml:space="preserve">
          <source>Floating point register if</source>
          <target state="translated">부동 소수점 레지스터</target>
        </trans-unit>
        <trans-unit id="c165ca40457d305eb7d330afdb797521f5de1b77" translate="yes" xml:space="preserve">
          <source>Floating point register if direct moves are available, or NO_REGS.</source>
          <target state="translated">직접 이동이 가능한 경우 부동 소수점 레지스터 또는 NO_REGS</target>
        </trans-unit>
        <trans-unit id="5262899d7f774e7136ab629899288cb3977b1a82" translate="yes" xml:space="preserve">
          <source>Floating point register if the LFIWAX instruction is enabled or NO_REGS.</source>
          <target state="translated">LFIWAX 명령어가 활성화되어 있거나 NO_REGS 인 경우 부동 소수점 레지스터.</target>
        </trans-unit>
        <trans-unit id="37f6e14594705b3a931f7fb11f09da2da0b4cf9c" translate="yes" xml:space="preserve">
          <source>Floating point register if the LFIWZX instruction is enabled or NO_REGS.</source>
          <target state="translated">LFIWZX 명령어가 활성화되었거나 NO_REGS 인 경우 부동 소수점 레지스터.</target>
        </trans-unit>
        <trans-unit id="92eb4ccc2dc9e99f2247ac815df53adacfbc08da" translate="yes" xml:space="preserve">
          <source>Floating point register if the STFIWX instruction is enabled or NO_REGS.</source>
          <target state="translated">STFIWX 명령어가 활성화되거나 NO_REGS 인 경우 부동 소수점 레지스터.</target>
        </trans-unit>
        <trans-unit id="aaae0bc8bed9980f091aa46b02c6dcb5a52b76ec" translate="yes" xml:space="preserve">
          <source>Floating point register, Advanced SIMD vector register or SVE vector register</source>
          <target state="translated">부동 소수점 레지스터, 고급 SIMD 벡터 레지스터 또는 SVE 벡터 레지스터</target>
        </trans-unit>
        <trans-unit id="16c68eba878493a77d0c164e7869af76e99d9145" translate="yes" xml:space="preserve">
          <source>Floating point registers AC0 through AC3. These can be loaded from/to memory with a single instruction.</source>
          <target state="translated">부동 소수점 레지스터 AC0-AC3. 단일 명령으로 메모리에서로드하거나 메모리로로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83ce48a9f40c05895bc4e20f6bb82f032e76933d" translate="yes" xml:space="preserve">
          <source>Floating point registers AC4 and AC5. These cannot be loaded from/to memory with a single instruction.</source>
          <target state="translated">부동 소수점 레지스터 AC4 및 AC5. 단일 명령으로 메모리에서로드하거나 메모리로로드 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f58b0d70fd4d764630301aac0286ba68330e3308" translate="yes" xml:space="preserve">
          <source>Floating-point condition code register.</source>
          <target state="translated">부동 소수점 조건 코드 레지스터.</target>
        </trans-unit>
        <trans-unit id="b56c9d5aa5cba048b4016e56db5b37a9156be6f1" translate="yes" xml:space="preserve">
          <source>Floating-point constant 0.0</source>
          <target state="translated">부동 소수점 상수 0.0</target>
        </trans-unit>
        <trans-unit id="11ca0595ff5b1cee498ed130d48a9d7ef77d2ce2" translate="yes" xml:space="preserve">
          <source>Floating-point constant 0.0 or 1.0</source>
          <target state="translated">부동 소수점 상수 0.0 또는 1.0</target>
        </trans-unit>
        <trans-unit id="3af5f60b6556d63fbe7c6434e046d0c15fe3ffe1" translate="yes" xml:space="preserve">
          <source>Floating-point constant whose integral representation can be moved into an integer register using a high/lo_sum instruction sequence</source>
          <target state="translated">high / lo_sum 명령어 시퀀스를 사용하여 정수 표현으로 정수 표현을 이동할 수있는 부동 소수점 상수</target>
        </trans-unit>
        <trans-unit id="c0e1876d49ff7a36e4b65c8a5784d9cd7a8e4781" translate="yes" xml:space="preserve">
          <source>Floating-point constant whose integral representation can be moved into an integer register using a single mov instruction</source>
          <target state="translated">단일 mov 명령어를 사용하여 정수 표현으로 정수 표현을 이동할 수있는 부동 소수점 상수</target>
        </trans-unit>
        <trans-unit id="500223502156611a39a78dc4c23517d86e8a772f" translate="yes" xml:space="preserve">
          <source>Floating-point constant whose integral representation can be moved into an integer register using a single sethi instruction</source>
          <target state="translated">단일 sethi 명령어를 사용하여 정수 표현으로 정수 표현을 이동할 수있는 부동 소수점 상수</target>
        </trans-unit>
        <trans-unit id="95fef479c80cb031fff0832cf86c7d5b4d064fb7" translate="yes" xml:space="preserve">
          <source>Floating-point instructions are only generated for 32-bit floating-point values, however, so the FPU hardware is not used for doubles if the</source>
          <target state="translated">부동 소수점 명령어는 32 비트 부동 소수점 값에 대해서만 생성되므로 FPU 하드웨어는</target>
        </trans-unit>
        <trans-unit id="f213ef5758f227bd35596edf6ff5e36aed746a21" translate="yes" xml:space="preserve">
          <source>Floating-point minimum and maximum. These instructions are only generated if</source>
          <target state="translated">부동 소수점 최소 및 최대. 이 명령어는 다음과 같은 경우에만 생성됩니다</target>
        </trans-unit>
        <trans-unit id="92610c4245848bdded34c9ee994e62b738188b93" translate="yes" xml:space="preserve">
          <source>Floating-point register</source>
          <target state="translated">부동 소수점 레지스터</target>
        </trans-unit>
        <trans-unit id="e5380eea89f6db263d5d241526df6bedd0bd11ff" translate="yes" xml:space="preserve">
          <source>Floating-point register on the SPARC-V8 architecture and lower floating-point register on the SPARC-V9 architecture.</source>
          <target state="translated">SPARC-V8 아키텍처의 부동 소수점 레지스터 및 SPARC-V9 아키텍처의 낮은 부동 소수점 레지스터</target>
        </trans-unit>
        <trans-unit id="2b69cf45a938c9e06197f0424f9a02b9aa9f002d" translate="yes" xml:space="preserve">
          <source>Floating-point register. It is equivalent to &amp;lsquo;</source>
          <target state="translated">부동 소수점 레지스터 '</target>
        </trans-unit>
        <trans-unit id="8ed13acd5482c325b73e858b30874f469fb342d2" translate="yes" xml:space="preserve">
          <source>Floating-point register. It is only valid on the SPARC-V9 architecture when the Visual Instruction Set is available.</source>
          <target state="translated">부동 소수점 레지스터 비주얼 명령어 세트가 사용 가능한 경우 SPARC-V9 아키텍처에서만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="d0d6928cc5c4254d825994f1f03f5fa64bf43b02" translate="yes" xml:space="preserve">
          <source>Floating-point trigonometric and exponential functions. These instructions are only generated if</source>
          <target state="translated">부동 소수점 삼각 함수 및 지수 함수 이 명령어는 다음과 같은 경우에만 생성됩니다</target>
        </trans-unit>
        <trans-unit id="cebba3f2674f659c3ac76a05e885a881a3fcce6d" translate="yes" xml:space="preserve">
          <source>Floating-point zero</source>
          <target state="translated">부동 소수점 제로</target>
        </trans-unit>
        <trans-unit id="c245efe80db566f234058018cbe48e4698e1bcb0" translate="yes" xml:space="preserve">
          <source>Floating-point zero.</source>
          <target state="translated">부동 소수점 제로.</target>
        </trans-unit>
        <trans-unit id="bc0561e46ee46f1370ce39f7bd133e69f6b47448" translate="yes" xml:space="preserve">
          <source>Flushing registers to memory has performance implications and may be an issue for time-sensitive code. You can provide better information to GCC to avoid this, as shown in the following examples. At a minimum, aliasing rules allow GCC to know what memory &lt;em&gt;doesn&amp;rsquo;t&lt;/em&gt; need to be flushed.</source>
          <target state="translated">레지스터를 메모리로 플러시하는 것은 성능에 영향을 미치며 시간에 민감한 코드의 문제 일 수 있습니다. 다음 예와 같이 GCC에 더 나은 정보를 제공하여이를 피할 수 있습니다. 최소한 앨리어싱 규칙을 통해 GCC는 메모리 를 비울 필요 &lt;em&gt;가없는&lt;/em&gt; 것을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d035cae4646bbea859b3aa6a64d528d7a19fea6" translate="yes" xml:space="preserve">
          <source>Follow the EABI requirement of always creating a frame pointer whenever a stack frame is allocated. This option is enabled by default and can be disabled with</source>
          <target state="translated">스택 프레임이 할당 될 때마다 항상 프레임 포인터를 작성해야한다는 EABI 요구 사항을 따르십시오. 이 옵션은 기본적으로 활성화되어 있으며</target>
        </trans-unit>
        <trans-unit id="ec0c3b76630fd745381cc215a284820af75a683a" translate="yes" xml:space="preserve">
          <source>Footnotes</source>
          <target state="translated">Footnotes</target>
        </trans-unit>
        <trans-unit id="9203a30acc55d5bd89f275fd6b63f1da488b512a" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;t2&lt;/code&gt;, &lt;code&gt;bar&lt;/code&gt; is placed at offset 2, rather than offset 1. Accordingly, the size of &lt;code&gt;t2&lt;/code&gt; is 4. For &lt;code&gt;t3&lt;/code&gt;, the zero-length bit-field does not affect the alignment of &lt;code&gt;bar&lt;/code&gt; or, as a result, the size of the structure.</source>
          <target state="translated">들면 &lt;code&gt;t2&lt;/code&gt; , &lt;code&gt;bar&lt;/code&gt; 의 크기 2 오프셋 배치보다는 따라서 1 오프셋 &lt;code&gt;t2&lt;/code&gt; 4입니다 &lt;code&gt;t3&lt;/code&gt; , 길이가 0 인 비트 필드는의 배향에 영향을 미치지 않는 &lt;code&gt;bar&lt;/code&gt; , 그 결과의 크기 또는 구조.</target>
        </trans-unit>
        <trans-unit id="c0e04e76cdfed448d6c782b7f817b6eea03c0f50" translate="yes" xml:space="preserve">
          <source>For &lt;var&gt;n&lt;/var&gt; greater than zero,</source>
          <target state="translated">들면 &lt;var&gt;n&lt;/var&gt; 개의 0보다 크면,</target>
        </trans-unit>
        <trans-unit id="fda527468e7c30de6308efd890e87b3a3fff811b" translate="yes" xml:space="preserve">
          <source>For ARC, a function marked with the &lt;code&gt;long_call&lt;/code&gt; attribute is always called using register-indirect jump-and-link instructions, thereby enabling the called function to be placed anywhere within the 32-bit address space. A function marked with the &lt;code&gt;medium_call&lt;/code&gt; attribute will always be close enough to be called with an unconditional branch-and-link instruction, which has a 25-bit offset from the call site. A function marked with the &lt;code&gt;short_call&lt;/code&gt; attribute will always be close enough to be called with a conditional branch-and-link instruction, which has a 21-bit offset from the call site.</source>
          <target state="translated">ARC의 경우, &lt;code&gt;long_call&lt;/code&gt; 속성으로 표시된 함수 는 항상 레지스터 간접 점프 앤 링크 명령어를 사용하여 호출되므로 호출 된 함수를 32 비트 주소 공간 내의 어느 곳에 나 배치 할 수 있습니다. &lt;code&gt;medium_call&lt;/code&gt; 속성으로 표시된 함수 는 항상 무조건 분기 및 링크 명령어로 호출 할 수있을 정도로 가깝습니다.이 명령어는 호출 사이트에서 25 비트 오프셋을 갖습니다. &lt;code&gt;short_call&lt;/code&gt; 속성으로 표시된 함수 는 항상 조건부 분기 및 링크 명령어로 호출 할 수있을 정도로 가깝습니다.이 명령어는 호출 사이트에서 21 비트 오프셋을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="6adc57b693c8942df2cd231eba32d27dd15cba72" translate="yes" xml:space="preserve">
          <source>For C and C++ source and include files, generate corresponding Ada specs. See &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gnat_ugn/Generating-Ada-Bindings-for-C-and-C_002b_002b-headers.html#Generating-Ada-Bindings-for-C-and-C_002b_002b-headers&quot;&gt;Generating Ada Bindings for C and C++ headers&lt;/a&gt; in GNAT User&amp;rsquo;s Guide, which provides detailed documentation on this feature.</source>
          <target state="translated">C 및 C ++ 소스 및 포함 파일의 경우 해당 Ada 스펙을 생성하십시오. 이 기능에 대한 자세한 문서를 제공하는 GNAT 사용 설명서의 &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gnat_ugn/Generating-Ada-Bindings-for-C-and-C_002b_002b-headers.html#Generating-Ada-Bindings-for-C-and-C_002b_002b-headers&quot;&gt;C 및 C ++ 헤더&lt;/a&gt; 에 대한 Ada 바인딩 생성을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a54d6337d3721d977a537facc549a93425ea6c7b" translate="yes" xml:space="preserve">
          <source>For C only, warn about a &lt;code&gt;return&lt;/code&gt; statement with an expression in a function whose return type is &lt;code&gt;void&lt;/code&gt;, unless the expression type is also &lt;code&gt;void&lt;/code&gt;. As a GNU extension, the latter case is accepted without a warning unless</source>
          <target state="translated">C의 경우에만 약 경고 &lt;code&gt;return&lt;/code&gt; 반환 타입 함수의 식을 문 &lt;code&gt;void&lt;/code&gt; 표현 형식도되지 않는, &lt;code&gt;void&lt;/code&gt; . GNU 확장으로서 후자의 경우는 경고없이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="2ec28d96fea6d9177d31ee6cda12fa27a81380e2" translate="yes" xml:space="preserve">
          <source>For C++ this also warns for some cases of unnecessary parentheses in declarations, which can indicate an attempt at a function call instead of a declaration:</source>
          <target state="translated">C ++의 경우 선언에서 불필요한 괄호가있는 경우를 경고하며 선언 대신 함수 호출 시도를 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1ba0033d082d3c48e09cd4d28a77031c040292c" translate="yes" xml:space="preserve">
          <source>For C++ types with non-trivial constructors and/or destructors it is impossible for the compiler to determine whether a variable of this type is truly unused if it is not referenced. This type attribute informs the compiler that variables of this type should be warned about if they appear to be unused, just like variables of fundamental types.</source>
          <target state="translated">사소하지 않은 생성자 및 / 또는 소멸자가있는 C ++ 유형의 경우, 컴파일러가이 유형의 변수가 참조되지 않은 경우 실제로 사용되지 않는지 여부를 판별 할 수 없습니다. 이 유형 속성은 기본 유형의 변수와 같이이 유형의 변수가 사용되지 않는 것으로 나타나면 경고해야한다는 것을 컴파일러에 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="0ae259ea1be0c205a219871342f05ea5c73b071c" translate="yes" xml:space="preserve">
          <source>For C++, also warn for confusing overload resolution for user-defined conversions; and conversions that never use a type conversion operator: conversions to &lt;code&gt;void&lt;/code&gt;, the same type, a base class or a reference to them. Warnings about conversions between signed and unsigned integers are disabled by default in C++ unless</source>
          <target state="translated">C ++의 경우 사용자 정의 변환을위한 혼란스러운 과부하 해결에 대해서도 경고합니다. 유형 변환 연산자를 사용하지 않는 변환 : &lt;code&gt;void&lt;/code&gt; 로 변환 , 동일한 유형, 기본 클래스 또는 이들에 대한 참조. 부호없는 정수와 부호없는 정수 사이의 변환에 대한 경고는 C ++에서 기본적으로 비활성화되어 있습니다</target>
        </trans-unit>
        <trans-unit id="e062686eecb3f26c45c0833c30627154026b2d61" translate="yes" xml:space="preserve">
          <source>For C++11 and later standards, narrowing conversions are diagnosed by default, as required by the standard. A narrowing conversion from a constant produces an error, and a narrowing conversion from a non-constant produces a warning, but</source>
          <target state="translated">C ++ 11 이상 표준의 경우 표준에서 요구하는대로 축소 변환이 기본적으로 진단됩니다. 상수에서 좁히는 변환은 오류를 생성하고, 상수가 아닌 좁아진 변환은 경고를 생성하지만</target>
        </trans-unit>
        <trans-unit id="f97e8575f9ec69703e8c96b79759e90bcf7fbfd5" translate="yes" xml:space="preserve">
          <source>For C, overloaded functions are implemented with macros so the following does not work:</source>
          <target state="translated">C의 경우 오버로드 된 함수는 매크로로 구현되므로 다음이 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9bcf8fa5038512fc6bcb9ac1f639a794219e10dd" translate="yes" xml:space="preserve">
          <source>For Microsoft Windows targets the use of the &lt;code&gt;dllimport&lt;/code&gt; attribute on functions is not necessary, but provides a small performance benefit by eliminating a thunk in the DLL. The use of the &lt;code&gt;dllimport&lt;/code&gt; attribute on imported variables can be avoided by passing the</source>
          <target state="translated">Microsoft Windows 대상의 경우 함수 에서 &lt;code&gt;dllimport&lt;/code&gt; 속성을 사용할 필요는 없지만 DLL에서 썽크를 제거하여 약간의 성능 이점을 제공합니다. 가져온 변수 에서 &lt;code&gt;dllimport&lt;/code&gt; 속성을 사용 하면 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b439766be6cedb98071044e5f74180de17ccd28" translate="yes" xml:space="preserve">
          <source>For Microsoft Windows targets there are alternative methods for including the symbol in the DLL&amp;rsquo;s export table such as using a</source>
          <target state="translated">Microsoft Windows 대상의 경우 DLL 내보내기 테이블에 기호를 포함하는 것과 같은 대체 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0f97011eddc4db6c5d876ee996866a2e41c88d5" translate="yes" xml:space="preserve">
          <source>For Objective-C dialects, &lt;code&gt;NSString&lt;/code&gt; (or &lt;code&gt;__NSString__&lt;/code&gt;) is recognized in the same context. Declarations including these format attributes are parsed for correct syntax, however the result of checking of such format strings is not yet defined, and is not carried out by this version of the compiler.</source>
          <target state="translated">Objective-C 방언의 경우 &lt;code&gt;NSString&lt;/code&gt; (또는 &lt;code&gt;__NSString__&lt;/code&gt; )은 동일한 컨텍스트에서 인식됩니다. 이러한 형식 속성을 포함한 선언은 올바른 구문을 위해 구문 분석되지만 이러한 형식 문자열을 검사 한 결과는 아직 정의되지 않았으며이 버전의 컴파일러에서 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7b8c007aa57d34905e4e1143a8c9e0a695e59978" translate="yes" xml:space="preserve">
          <source>For Objective-C dialects, the &lt;code&gt;format-arg&lt;/code&gt; attribute may refer to an &lt;code&gt;NSString&lt;/code&gt; reference for compatibility with the &lt;code&gt;format&lt;/code&gt; attribute above.</source>
          <target state="translated">Objective-C 언어의 경우 &lt;code&gt;format-arg&lt;/code&gt; 속성은 위 의 &lt;code&gt;format&lt;/code&gt; 속성 과의 호환성을 위해 &lt;code&gt;NSString&lt;/code&gt; 참조를 참조 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="92a499e6d28c647e0ab66f857f55afedfae35b1a" translate="yes" xml:space="preserve">
          <source>For PMF constants (i.e. expressions of the form &amp;lsquo;</source>
          <target state="translated">PMF 상수 (예 : '</target>
        </trans-unit>
        <trans-unit id="da58c329594be0295cc2415f6a69d9838ef88a83" translate="yes" xml:space="preserve">
          <source>For SysV/x86-64, unions with &lt;code&gt;long double&lt;/code&gt; members are passed in memory as specified in psABI. For example:</source>
          <target state="translated">SysV / x86-64의 경우 &lt;code&gt;long double&lt;/code&gt; 구성원이있는 공용체는 psABI에 지정된대로 메모리에 전달됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1e5082f805fe556d28e82883360f1cc9602556d6" translate="yes" xml:space="preserve">
          <source>For a branch, if it was executed at least once, then a percentage indicating the number of times the branch was taken divided by the number of times the branch was executed will be printed. Otherwise, the message &amp;ldquo;never executed&amp;rdquo; is printed.</source>
          <target state="translated">분기의 경우 분기가 한 번 이상 실행 된 경우 분기를 수행 한 횟수를 분기가 실행 된 횟수로 나눈 백분율이 인쇄됩니다. 그렇지 않으면 &quot;never execution&quot;메시지가 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="c55de54fa0492ae593f558830d0cb1158609d3e6" translate="yes" xml:space="preserve">
          <source>For a call, if it was executed at least once, then a percentage indicating the number of times the call returned divided by the number of times the call was executed will be printed. This will usually be 100%, but may be less for functions that call &lt;code&gt;exit&lt;/code&gt; or &lt;code&gt;longjmp&lt;/code&gt;, and thus may not return every time they are called.</source>
          <target state="translated">호출의 경우, 호출이 한 번 이상 실행 된 경우, 호출 된 횟수를 호출 한 횟수로 나눈 백분율을 인쇄합니다. 일반적으로 100 %이지만 &lt;code&gt;exit&lt;/code&gt; 또는 &lt;code&gt;longjmp&lt;/code&gt; 를 호출하는 함수의 경우 더 적을 수 있으므로 호출 할 때마다 반환되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d3a2fcd90b12dd021860d8f2094fd5bb769b990" translate="yes" xml:space="preserve">
          <source>For all builtins, &lt;code&gt;__builtin_arc_&lt;var&gt;someinsn&lt;/var&gt;&lt;/code&gt;, the header file</source>
          <target state="translated">모든 내장 인 &lt;code&gt;__builtin_arc_&lt;var&gt;someinsn&lt;/var&gt;&lt;/code&gt; , 헤더 파일</target>
        </trans-unit>
        <trans-unit id="2d0b11d5fd63069d7902f804e3faa32968adf01d" translate="yes" xml:space="preserve">
          <source>For all of these except the last, the compiler automatically ignores the precompiled header if the conditions aren&amp;rsquo;t met. If you find an option combination that doesn&amp;rsquo;t work and doesn&amp;rsquo;t cause the precompiled header to be ignored, please consider filing a bug report, see &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Bugs.html#Bugs&quot;&gt;Bugs&lt;/a&gt;.</source>
          <target state="translated">마지막을 제외한 모든 것의 경우 조건이 충족되지 않으면 컴파일러는 사전 컴파일 된 헤더를 자동으로 무시합니다. 작동하지 않고 사전 컴파일 된 헤더를 무시하지 않는 옵션 조합을 찾으면 버그 보고서 제출을 고려하십시오 ( &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Bugs.html#Bugs&quot;&gt;버그&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="58f02a64f2f86869e0c0753651765b098a5d48fc" translate="yes" xml:space="preserve">
          <source>For an automatic (i.e. local) variable, if there exists a path from the function entry to a use of the variable that is initialized, but there exist some other paths for which the variable is not initialized, the compiler emits a warning if it cannot prove the uninitialized paths are not executed at run time.</source>
          <target state="translated">자동 (예 : 로컬) 변수의 경우 함수 항목에서 초기화 된 변수 사용까지의 경로가 있지만 변수가 초기화되지 않은 다른 경로가 있으면 컴파일러에서 변수를 초기화 할 수없는 경우 경고를 표시합니다 초기화되지 않은 경로가 런타임에 실행되지 않음을 증명하십시오.</target>
        </trans-unit>
        <trans-unit id="66413344ffac4ff8769f77f6b83c7166f806eb53" translate="yes" xml:space="preserve">
          <source>For any declared symbols matching &lt;var&gt;name&lt;/var&gt;, this does three things to that symbol: it forces the symbol to be located at the given address (a number), it forces the symbol to be volatile, and it changes the symbol&amp;rsquo;s scope to be static. This pragma exists for compatibility with other compilers, but note that the common &lt;code&gt;1234H&lt;/code&gt; numeric syntax is not supported (use &lt;code&gt;0x1234&lt;/code&gt; instead). Example:</source>
          <target state="translated">&lt;var&gt;name&lt;/var&gt; 과 일치하는 선언 된 심볼의 경우이 심볼에 대해 세 가지 작업을 수행합니다. 심볼을 지정된 주소 (숫자)에 위치시키고 심볼을 휘발성으로 만들고 심볼의 범위를 정적으로 변경합니다. 이 pragma는 다른 컴파일러와의 호환성을 위해 존재하지만 일반적인 &lt;code&gt;1234H&lt;/code&gt; 숫자 구문은 지원되지 않습니다 ( 대신 &lt;code&gt;0x1234&lt;/code&gt; 사용). 예:</target>
        </trans-unit>
        <trans-unit id="a150049db7b708562952c9c177d8b88f32edb151" translate="yes" xml:space="preserve">
          <source>For any given input file, the file name suffix determines what kind of compilation is done:</source>
          <target state="translated">주어진 입력 파일에 대해 파일 이름 접미사가 수행되는 컴파일 종류를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="07d18512cc77ea85f9b39807bf636696e007c1f0" translate="yes" xml:space="preserve">
          <source>For any input register that is implicitly popped by an &lt;code&gt;asm&lt;/code&gt;, it is necessary to know how to adjust the stack to compensate for the pop. If any non-popped input is closer to the top of the reg-stack than the implicitly popped register, it would not be possible to know what the stack looked like&amp;mdash;it&amp;rsquo;s not clear how the rest of the stack &amp;ldquo;slides up&amp;rdquo;.</source>
          <target state="translated">암시 적으로 &lt;code&gt;asm&lt;/code&gt; 에 의해 팝되는 입력 레지스터의 경우, 팝을 보상하기 위해 스택을 조정하는 방법을 알아야합니다. 팝되지 않은 입력이 내재적으로 팝된 레지스터보다 reg-stack의 상단에 더 가까우면 스택의 모양을 알 수 없으며 나머지 스택이 어떻게 미끄러지는지 명확하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f70c821669087836df1b08a79652756521c81032" translate="yes" xml:space="preserve">
          <source>For basic &lt;code&gt;asm&lt;/code&gt; with non-empty assembler string GCC assumes the assembler block does not change any general purpose registers, but it may read or write any globally accessible variable.</source>
          <target state="translated">비어 있지 않은 어셈블러 문자열이있는 기본 &lt;code&gt;asm&lt;/code&gt; 의 경우 GCC는 어셈블러 블록이 범용 레지스터를 변경하지 않지만 전역 적으로 액세스 가능한 변수를 읽거나 쓸 수 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="5e325c0c804529598de8767ff4c99ad5a3e91e4a" translate="yes" xml:space="preserve">
          <source>For compatibility with Microsoft Windows compilers, GCC supports &amp;lsquo;</source>
          <target state="translated">Microsoft Windows 컴파일러와의 호환성을 위해 GCC는 '</target>
        </trans-unit>
        <trans-unit id="2e68646242b9dd84443ad785c99336fb66a4c416" translate="yes" xml:space="preserve">
          <source>For compatibility with Microsoft Windows compilers, GCC supports a set of &lt;code&gt;#pragma&lt;/code&gt; directives that change the maximum alignment of members of structures (other than zero-width bit-fields), unions, and classes subsequently defined. The &lt;var&gt;n&lt;/var&gt; value below always is required to be a small power of two and specifies the new alignment in bytes.</source>
          <target state="translated">Microsoft Windows 컴파일러와의 호환성을 위해 GCC는 구조의 멤버 (폭이 0 인 비트 필드 이외), 공용체 및 이후에 정의 된 클래스의 최대 정렬을 변경하는 &lt;code&gt;#pragma&lt;/code&gt; 지시문 집합을 지원합니다 . 아래 의 &lt;var&gt;n&lt;/var&gt; 값은 항상 2의 작은 제곱이어야하며 새 정렬을 바이트 단위로 지정합니다.</target>
        </trans-unit>
        <trans-unit id="2922cd58b39e0ff05824f3d77b79c0fe7423d78f" translate="yes" xml:space="preserve">
          <source>For compatibility with SVR4, GCC supports a set of &lt;code&gt;#pragma&lt;/code&gt; directives for declaring symbols to be weak, and defining weak aliases.</source>
          <target state="translated">SVR4와의 호환성을 위해 GCC는 기호를 약한 것으로 선언하고 약한 별칭을 정의하기위한 일련의 &lt;code&gt;#pragma&lt;/code&gt; 지시문을 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="47783006d3b2d24697c7b14be6b4ca265bdb02d0" translate="yes" xml:space="preserve">
          <source>For compatibility with existing code written for compiler versions that did not implement attributes on nested declarators, some laxity is allowed in the placing of attributes. If an attribute that only applies to types is applied to a declaration, it is treated as applying to the type of that declaration. If an attribute that only applies to declarations is applied to the type of a declaration, it is treated as applying to that declaration; and, for compatibility with code placing the attributes immediately before the identifier declared, such an attribute applied to a function return type is treated as applying to the function type, and such an attribute applied to an array element type is treated as applying to the array type. If an attribute that only applies to function types is applied to a pointer-to-function type, it is treated as applying to the pointer target type; if such an attribute is applied to a function return type that is not a pointer-to-function type, it is treated as applying to the function type.</source>
          <target state="translated">중첩 된 선언자에서 속성을 구현하지 않은 컴파일러 버전 용으로 작성된 기존 코드와의 호환성을 위해 속성 배치에 약간의 여유가 허용됩니다. 형식에만 적용되는 특성이 선언에 적용되면 해당 선언의 형식에 적용되는 것으로 간주됩니다. 선언에만 적용되는 속성이 선언 유형에 적용되면 해당 선언에 적용되는 것으로 간주됩니다. 그리고 선언 된 식별자 바로 앞에 속성을 배치하는 코드와의 호환성을 위해, 함수 리턴 타입에 적용된 속성은 함수 타입에 적용되는 것으로 취급되고, 배열 요소 타입에 적용된 속성은 어레이에 적용되는 것으로 취급된다 유형. 함수 유형에만 적용되는 속성이 포인터 대 함수 유형에 적용되는 경우,포인터 대상 유형에 적용되는 것으로 간주됩니다. 이러한 속성이 포인터 대 함수 유형이 아닌 함수 리턴 유형에 적용되는 경우 함수 유형에 적용되는 것으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="55c454a21201bdfc3a9a886c367d99786c9c4842" translate="yes" xml:space="preserve">
          <source>For compatibility, it&amp;rsquo;s always newlib for elf now.</source>
          <target state="translated">호환성을 위해 항상 엘프를위한 newlib입니다.</target>
        </trans-unit>
        <trans-unit id="4859bddb1e6f097bf4875ee4cd32afb8f33d13e6" translate="yes" xml:space="preserve">
          <source>For convenience, it is allowed to use a binary vector operation where one operand is a scalar. In that case the compiler transforms the scalar operand into a vector where each element is the scalar from the operation. The transformation happens only if the scalar could be safely converted to the vector-element type. Consider the following code.</source>
          <target state="translated">편의상 하나의 피연산자가 스칼라 인 이진 벡터 연산을 사용할 수 있습니다. 이 경우 컴파일러는 스칼라 피연산자를 각 요소가 연산의 스칼라 인 벡터로 변환합니다. 스칼라를 벡터 요소 유형으로 안전하게 변환 할 수있는 경우에만 변환이 발생합니다. 다음 코드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="3d923f6f173753b3c978292a218e04d22288b211" translate="yes" xml:space="preserve">
          <source>For conversion to a type of width &lt;em&gt;N&lt;/em&gt;, the value is reduced modulo &lt;em&gt;2^N&lt;/em&gt; to be within range of the type; no signal is raised.</source>
          <target state="translated">폭 &lt;em&gt;N&lt;/em&gt; 의 타입으로 변환하기 위해 , 값은 타입의 범위 내에 있도록 모듈로 &lt;em&gt;2 ^ N&lt;/em&gt; 로 감소된다 ; 신호가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3216191fb385483c1e97afafeea464af935a4944" translate="yes" xml:space="preserve">
          <source>For devices not in &lt;code&gt;avrtiny&lt;/code&gt; or &lt;code&gt;avrxmega3&lt;/code&gt;, any data including read-only data is located in RAM (the generic address space) because flash memory is not visible in the RAM address space. In order to locate read-only data in flash memory &lt;em&gt;and&lt;/em&gt; to generate the right instructions to access this data without using (inline) assembler code, special address spaces are needed.</source>
          <target state="translated">&lt;code&gt;avrtiny&lt;/code&gt; 또는 &lt;code&gt;avrxmega3&lt;/code&gt; 에 있지 않은 장치의 경우 RAM 주소 공간에는 플래시 메모리가 표시되지 않으므로 읽기 전용 데이터를 포함한 모든 데이터는 RAM (일반 주소 공간)에 있습니다. 플래시 메모리에 읽기 전용 데이터를 찾을하기 위해 &lt;em&gt;및&lt;/em&gt; (인라인) 어셈블러 코드를 사용하지 않고이 데이터에 액세스 할 수있는 권한 지침을 생성하기 위해, 특수 주소 공간이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="0733ee9be6e082cc123e5464c02486573ae7f9cd" translate="yes" xml:space="preserve">
          <source>For documentation of &lt;code&gt;altivec&lt;/code&gt; attribute please see the documentation in &lt;a href=&quot;type-attributes#PowerPC-Type-Attributes&quot;&gt;PowerPC Type Attributes&lt;/a&gt;.</source>
          <target state="translated">의 문서에 대해서는, &lt;code&gt;altivec&lt;/code&gt; 속성에 문서를 참조하십시오 &lt;a href=&quot;type-attributes#PowerPC-Type-Attributes&quot;&gt;파워 유형 속성&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eb3f33ef599bbcb991ed9de189514be3fb2765a7" translate="yes" xml:space="preserve">
          <source>For each Objective-C class, check if any of its instance variables is a C++ object with a non-trivial default constructor. If so, synthesize a special &lt;code&gt;- (id) .cxx_construct&lt;/code&gt; instance method which runs non-trivial default constructors on any such instance variables, in order, and then return &lt;code&gt;self&lt;/code&gt;. Similarly, check if any instance variable is a C++ object with a non-trivial destructor, and if so, synthesize a special &lt;code&gt;- (void) .cxx_destruct&lt;/code&gt; method which runs all such default destructors, in reverse order.</source>
          <target state="translated">각 Objective-C 클래스에 대해 인스턴스 변수가 사소한 기본 생성자를 가진 C ++ 객체인지 확인하십시오. 그렇다면, 그러한 인스턴스 변수에서 사소한 기본 생성자를 순서대로 실행 하는 특수한 &lt;code&gt;- (id) .cxx_construct&lt;/code&gt; 인스턴스 메소드를 합성 한 다음 &lt;code&gt;self&lt;/code&gt; 를 리턴하십시오 . 마찬가지로, 인스턴스 변수가 사소한 소멸자가없는 C ++ 객체인지 확인하고, 존재하는 경우 모든 기본 소멸자를 역순으로 실행 하는 특수 &lt;code&gt;- (void) .cxx_destruct&lt;/code&gt; 메소드를 합성하십시오 .</target>
        </trans-unit>
        <trans-unit id="ecabcf6fb487210c3e414abe28454af79991a5a8" translate="yes" xml:space="preserve">
          <source>For each basic block, a line is printed after the last line of the basic block describing the branch or call that ends the basic block. There can be multiple branches and calls listed for a single source line if there are multiple basic blocks that end on that line. In this case, the branches and calls are each given a number. There is no simple way to map these branches and calls back to source constructs. In general, though, the lowest numbered branch or call will correspond to the leftmost construct on the source line.</source>
          <target state="translated">각 기본 블록에 대해 기본 블록을 종료하는 분기 또는 호출을 설명하는 기본 블록의 마지막 라인 뒤에 라인이 인쇄됩니다. 해당 회선에서 끝나는 기본 블록이 여러 개인 경우 단일 소스 회선에 대해 여러 개의 분기 및 호출이 나열 될 수 있습니다. 이 경우 지점과 통화에는 각각 번호가 지정됩니다. 이러한 브랜치를 맵핑하고 소스 구성을 다시 호출하는 간단한 방법은 없습니다. 그러나 일반적으로 가장 낮은 번호의 분기 또는 호출은 소스 라인에서 가장 왼쪽에있는 구성에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="7d57dddd1f25be9ff5b83775303a0d6d59fce852" translate="yes" xml:space="preserve">
          <source>For each built-in function for AVR, there is an equally named, uppercase built-in macro defined. That way users can easily query if or if not a specific built-in is implemented or not. For example, if &lt;code&gt;__builtin_avr_nop&lt;/code&gt; is available the macro &lt;code&gt;__BUILTIN_AVR_NOP&lt;/code&gt; is defined to &lt;code&gt;1&lt;/code&gt; and undefined otherwise.</source>
          <target state="translated">AVR의 각 내장 기능에 대해 동일한 이름의 대문자 내장 매크로가 정의되어 있습니다. 이를 통해 사용자는 특정 내장 기능이 구현되었는지 여부를 쉽게 쿼리 할 수 ​​있습니다. 예를 들어 &lt;code&gt;__builtin_avr_nop&lt;/code&gt; 를 사용할 수 있으면 매크로 &lt;code&gt;__BUILTIN_AVR_NOP&lt;/code&gt; 가 &lt;code&gt;1&lt;/code&gt; 로 정의되고 그렇지 않으면 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d11a6b019eb02c22d6e7924e271f0d952fce8600" translate="yes" xml:space="preserve">
          <source>For each function, a line is printed showing how many times the function is called, how many times it returns and what percentage of the function&amp;rsquo;s blocks were executed.</source>
          <target state="translated">각 함수에 대해 함수 호출 횟수, 반환 횟수 및 실행 된 함수 블록의 백분율을 나타내는 행이 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="4bcb841b4282f8986587d3e6966d3ed8c8dbe585" translate="yes" xml:space="preserve">
          <source>For each language compiled by GCC for which there is a standard, GCC attempts to follow one or more versions of that standard, possibly with some exceptions, and possibly with some extensions.</source>
          <target state="translated">표준이있는 GCC에서 컴파일 한 각 언어에 대해 GCC는 해당 표준의 하나 이상의 버전을 따르려고 시도합니다 (일부 예외 및 확장 가능).</target>
        </trans-unit>
        <trans-unit id="454897cc2fe9ad183bab2f7040fb6e5f25d9835d" translate="yes" xml:space="preserve">
          <source>For each named address space supported by avr-gcc there is an equally named but uppercase built-in macro defined. The purpose is to facilitate testing if respective address space support is available or not:</source>
          <target state="translated">avr-gcc가 지원하는 각각의 명명 된 주소 공간에 대해 동일하게 명명되었지만 대문자 내장 매크로가 정의되어 있습니다. 각 주소 공간 지원이 가능한지 여부를 테스트하기 위해 다음과 같은 목적이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3f4882138b251f321ad16e203354e1a8d314d76" translate="yes" xml:space="preserve">
          <source>For each of the other indicated dump files (</source>
          <target state="translated">표시된 다른 덤프 파일 (</target>
        </trans-unit>
        <trans-unit id="52f8ea439a283b5dc96c21715d0fefc3004bcf28" translate="yes" xml:space="preserve">
          <source>For each subprogram to be run, the compiler driver first tries the</source>
          <target state="translated">각 서브 프로그램이 실행될 때마다 컴파일러 드라이버는 먼저</target>
        </trans-unit>
        <trans-unit id="fdc4fc8f69b51e6f564843d4ff6b4102d66402dd" translate="yes" xml:space="preserve">
          <source>For even more AVR-specific built-in macros see &lt;a href=&quot;named-address-spaces#AVR-Named-Address-Spaces&quot;&gt;AVR Named Address Spaces&lt;/a&gt; and &lt;a href=&quot;avr-built_002din-functions#AVR-Built_002din-Functions&quot;&gt;AVR Built-in Functions&lt;/a&gt;.</source>
          <target state="translated">더 많은 AVR 관련 내장 매크로에 대해서는 &lt;a href=&quot;named-address-spaces#AVR-Named-Address-Spaces&quot;&gt;AVR 명명 된 주소 공간&lt;/a&gt; 및 &lt;a href=&quot;avr-built_002din-functions#AVR-Built_002din-Functions&quot;&gt;AVR 내장 기능을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1baa0cc1603bf61303a12aa930a0094973d11cab" translate="yes" xml:space="preserve">
          <source>For example in the structure below, the member array &lt;code&gt;x&lt;/code&gt; is packed so that it immediately follows &lt;code&gt;a&lt;/code&gt; with no intervening padding:</source>
          <target state="translated">아래의 구조에서 예를 들면, 부재 어레이 &lt;code&gt;x&lt;/code&gt; 즉시 따르도록 가득 &lt;code&gt;a&lt;/code&gt; 중재하는 패딩 :</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="67c7bfe6911146baef42ccf95311646fa6de1225" translate="yes" xml:space="preserve">
          <source>For example, &amp;lsquo;</source>
          <target state="translated">예를 들어 '</target>
        </trans-unit>
        <trans-unit id="f35aae572eaa511b9e1fec745e2f41aff9a397c4" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;-MT '$(objpfx)foo.o'&lt;/code&gt; might give</source>
          <target state="translated">예를 들어, &lt;code&gt;-MT '$(objpfx)foo.o'&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="687851312bf05d13456ec79c098b24da9ffe5635" translate="yes" xml:space="preserve">
          <source>For example, GCC warns about &lt;code&gt;i&lt;/code&gt; being uninitialized in the following snippet only when</source>
          <target state="translated">에 대해 예를 들어, GCC는 경고 &lt;code&gt;i&lt;/code&gt; 경우에만 다음 코드에서 초기화되지 않은되고</target>
        </trans-unit>
        <trans-unit id="481bf59d3e774632a4ae291477b6e304f7e4939c" translate="yes" xml:space="preserve">
          <source>For example, a bounded case of &lt;code&gt;alloca&lt;/code&gt; could be:</source>
          <target state="translated">예를 들어, &lt;code&gt;alloca&lt;/code&gt; 의 경계 사례는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b71521cff46dbe352ddadd34594ed3081919fa62" translate="yes" xml:space="preserve">
          <source>For example, a method with no arguments and returning &lt;code&gt;int&lt;/code&gt; would have the signature &lt;code&gt;i8@0:4&lt;/code&gt; if the size of a pointer is 4. The signature is interpreted as follows: the &lt;code&gt;i&lt;/code&gt; is the return type (an &lt;code&gt;int&lt;/code&gt;), the &lt;code&gt;8&lt;/code&gt; is the total size of the parameters in bytes (two pointers each of size 4), the &lt;code&gt;@0&lt;/code&gt; is the first parameter (an object at byte offset &lt;code&gt;0&lt;/code&gt;) and &lt;code&gt;:4&lt;/code&gt; is the second parameter (a &lt;code&gt;SEL&lt;/code&gt; at byte offset &lt;code&gt;4&lt;/code&gt;).</source>
          <target state="translated">예를 들어, 인수가없고 &lt;code&gt;int&lt;/code&gt; 를 리턴하는 메소드 는 포인터의 크기가 &lt;code&gt;i8@0:4&lt;/code&gt; 경우 서명 i8 @ 0 : 4를 갖습니다 . 서명은 다음과 같이 해석됩니다. &lt;code&gt;i&lt;/code&gt; 는 리턴 유형 ( &lt;code&gt;int&lt;/code&gt; ), &lt;code&gt;8&lt;/code&gt; 은 바이트 단위의 매개 변수의 총 크기 (각 크기 4의 포인터 2 개), &lt;code&gt;@0&lt;/code&gt; 은 첫 번째 매개 변수 (바이트 오프셋 &lt;code&gt;0&lt;/code&gt; 의 오브젝트 )이고 &lt;code&gt;:4&lt;/code&gt; 는 두 번째 매개 변수 ( 바이트 오프셋 &lt;code&gt;4&lt;/code&gt; 의 &lt;code&gt;SEL&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="68ba042328cca36e153d2c8dab7d8879565e3845" translate="yes" xml:space="preserve">
          <source>For example, a program may use a function &lt;code&gt;strfunc&lt;/code&gt; that returns &lt;code&gt;string&lt;/code&gt; objects, and another function &lt;code&gt;charfunc&lt;/code&gt; that operates on pointers to &lt;code&gt;char&lt;/code&gt;:</source>
          <target state="translated">예를 들어, 프로그램은 &lt;code&gt;string&lt;/code&gt; 객체 를 반환 하는 함수 &lt;code&gt;strfunc&lt;/code&gt; 와 &lt;code&gt;char&lt;/code&gt; 에 대한 포인터에서 작동하는 다른 함수 &lt;code&gt;charfunc&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="88bf56d21a567365b50f7c0d1260f3e77c253d14" translate="yes" xml:space="preserve">
          <source>For example, a spec string like this:</source>
          <target state="translated">예를 들어 다음과 같은 사양 문자열은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9636aa78a9470d85d5322503884f630474bbcbd8" translate="yes" xml:space="preserve">
          <source>For example, an address which is constant is offsettable; so is an address that is the sum of a register and a constant (as long as a slightly larger constant is also within the range of address-offsets supported by the machine); but an autoincrement or autodecrement address is not offsettable. More complicated indirect/indexed addresses may or may not be offsettable depending on the other addressing modes that the machine supports.</source>
          <target state="translated">예를 들어, 일정한 주소는 오프셋 가능합니다. 레지스터와 상수의 합인 주소도 있습니다 (약간 큰 상수가 기계가 지원하는 주소 오프셋 범위 내에있는 한). 그러나 자동 증가 또는 자동 감소 주소는 오프셋 가능하지 않습니다. 기계가 지원하는 다른 주소 지정 모드에 따라 더 복잡한 간접 / 색인 주소는 오프셋 가능하거나 오프셋 가능하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb39fad998b5526c7cd037c77aee5706a45b5058" translate="yes" xml:space="preserve">
          <source>For example, by default a structure containing nothing but 8 &lt;code&gt;unsigned&lt;/code&gt; bit-fields of length 1 is aligned to a 4-byte boundary and has a size of 4 bytes. By using</source>
          <target state="translated">예를 들어, 기본적 으로 길이가 1 인 8 개의 &lt;code&gt;unsigned&lt;/code&gt; 비트 필드 만 포함하는 구조 는 4 바이트 경계에 정렬되며 크기는 4 바이트입니다. 사용하여</target>
        </trans-unit>
        <trans-unit id="44c92e45a35c2e3631a1416540d7623d393688e2" translate="yes" xml:space="preserve">
          <source>For example, code using the standard ISA encoding cannot jump directly to MIPS16 or microMIPS code; it must either use a call or an indirect jump.</source>
          <target state="translated">예를 들어 표준 ISA 인코딩을 사용하는 코드는 MIPS16 또는 microMIPS 코드로 직접 이동할 수 없습니다. 호출 또는 간접 점프를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="6d3c95f985f19da9d6dbc1a830c9da53b0e26416" translate="yes" xml:space="preserve">
          <source>For example, given this C source file:</source>
          <target state="translated">예를 들어,이 C 소스 파일이 주어진 경우 :</target>
        </trans-unit>
        <trans-unit id="f0defbb763ebb18b66cf3162b2b446b84c5034e8" translate="yes" xml:space="preserve">
          <source>For example, if an x86 compiler supports two dialects (&amp;lsquo;</source>
          <target state="translated">예를 들어, x86 컴파일러가 두 개의 방언 ( '</target>
        </trans-unit>
        <trans-unit id="9b3c7e9c23ebc44c980aef19936a5699e234861d" translate="yes" xml:space="preserve">
          <source>For example, if the object file</source>
          <target state="translated">예를 들어 객체 파일이</target>
        </trans-unit>
        <trans-unit id="6277fc8469340ab02cc75749b9fdf00e3b3028a6" translate="yes" xml:space="preserve">
          <source>For example, if the target machine requires a &lt;code&gt;double&lt;/code&gt; value to be aligned on an 8-byte boundary, then &lt;code&gt;__alignof__ (double)&lt;/code&gt; is 8. This is true on many RISC machines. On more traditional machine designs, &lt;code&gt;__alignof__ (double)&lt;/code&gt; is 4 or even 2.</source>
          <target state="translated">예를 들어, 대상 시스템 에서 8 바이트 경계에 정렬하기 위해 &lt;code&gt;double&lt;/code&gt; 값이 필요한 경우 &lt;code&gt;__alignof__ (double)&lt;/code&gt; 은 8입니다. 이는 많은 RISC 시스템에서 적용됩니다. 보다 전통적인 기계 설계에서 &lt;code&gt;__alignof__ (double)&lt;/code&gt; 은 4 또는 2입니다.</target>
        </trans-unit>
        <trans-unit id="ace71a372dd9faf87968abc19f07a8c712084e3c" translate="yes" xml:space="preserve">
          <source>For example, in the following function the call to &lt;code&gt;g&lt;/code&gt; is unsafe because when &lt;code&gt;overalign&lt;/code&gt; is non-zero, the space allocated by &lt;code&gt;__builtin_alloca_with_align&lt;/code&gt; may have been released at the end of the &lt;code&gt;if&lt;/code&gt; statement in which it was called.</source>
          <target state="translated">예를 들어, 다음 함수에서 &lt;code&gt;overalign&lt;/code&gt; 이 0이 아닌 경우 &lt;code&gt;__builtin_alloca_with_align&lt;/code&gt; 에 의해 할당 된 공간 이 호출 된 &lt;code&gt;if&lt;/code&gt; 문의 끝에서 해제되었을 수 있으므로 &lt;code&gt;g&lt;/code&gt; 에 대한 호출 은 안전하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b982bcc761519bf794d14c5f76ed85a5c03967e1" translate="yes" xml:space="preserve">
          <source>For example, in the following, each call to function &lt;code&gt;foo&lt;/code&gt; will print a line similar to &lt;code&gt;&quot;file.c:123: foo: message&quot;&lt;/code&gt; with the name of the file and the line number of the &lt;code&gt;printf&lt;/code&gt; call, the name of the function &lt;code&gt;foo&lt;/code&gt;, followed by the word &lt;code&gt;message&lt;/code&gt;.</source>
          <target state="translated">예를 들어, 다음에서 &lt;code&gt;foo&lt;/code&gt; 함수를 호출 할 때마다 &lt;code&gt;&quot;file.c:123: foo: message&quot;&lt;/code&gt; 와 유사한 행을 파일 이름과 &lt;code&gt;printf&lt;/code&gt; 호출 의 행 번호 , &lt;code&gt;foo&lt;/code&gt; 함수 이름을 사용하여 인쇄합니다. &lt;code&gt;message&lt;/code&gt; 뒤에 단어 가 옵니다 .</target>
        </trans-unit>
        <trans-unit id="55f28e4d67f6e114f470b97bac400ac0e25f6328" translate="yes" xml:space="preserve">
          <source>For example, on the 68000 in a fullword instruction it is possible to use an immediate operand; but if the immediate value is between -128 and 127, better code results from loading the value into a register and using the register. This is because the load into the register can be done with a &amp;lsquo;</source>
          <target state="translated">예를 들어, 전체 단어 명령어의 68000에서 즉시 피연산자를 사용할 수 있습니다. 그러나 즉시 값이 -128과 127 사이이면 값을 레지스터에로드하고 레지스터를 사용하여 더 나은 코드를 생성합니다. 레지스터로의로드는 '</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
