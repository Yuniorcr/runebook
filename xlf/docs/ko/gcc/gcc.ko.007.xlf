<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="gcc">
    <body>
      <group id="gcc">
        <trans-unit id="adca7822f575134857a5ee57f78ae4fe66d4c44f" translate="yes" xml:space="preserve">
          <source>As an optimization, G++ sometimes gives array compound literals longer lifetimes: when the array either appears outside a function or has a &lt;code&gt;const&lt;/code&gt;-qualified type. If &lt;code&gt;foo&lt;/code&gt; and its initializer had elements of type &lt;code&gt;char *const&lt;/code&gt; rather than &lt;code&gt;char *&lt;/code&gt;, or if &lt;code&gt;foo&lt;/code&gt; were a global variable, the array would have static storage duration. But it is probably safest just to avoid the use of array compound literals in C++ code.</source>
          <target state="translated">최적화로서, G ++는 때때로 배열 복합 리터럴을 더 긴 수명을 제공합니다 : 배열이 함수 외부에 나타나거나 &lt;code&gt;const&lt;/code&gt; 한정 유형을 가질 때 . 경우 &lt;code&gt;foo&lt;/code&gt; 는 그 이니셜 라이저 타입의 요소를 가지고 &lt;code&gt;char *const&lt;/code&gt; 하기보다는 &lt;code&gt;char *&lt;/code&gt; 경우, 또는 &lt;code&gt;foo&lt;/code&gt; 전역 변수했다, 배열은 정적 저장 기간을 가질 것이다. 그러나 C ++ 코드에서 배열 복합 리터럴을 사용하지 않는 것이 가장 안전합니다.</target>
        </trans-unit>
        <trans-unit id="4440512ea926e0e3e9623211be65c0fe001b769e" translate="yes" xml:space="preserve">
          <source>As another example,</source>
          <target state="translated">다른 예로서,</target>
        </trans-unit>
        <trans-unit id="c2d7d2d398b725a8ff7f6339f33b58fb71e37c73" translate="yes" xml:space="preserve">
          <source>As another example, the following call to &lt;code&gt;strncpy&lt;/code&gt; results in copying to &lt;code&gt;d&lt;/code&gt; just the characters preceding the terminating NUL, without appending the NUL to the end. Assuming the result of &lt;code&gt;strncpy&lt;/code&gt; is necessarily a NUL-terminated string is a common mistake, and so the call is diagnosed. To avoid the warning when the result is not expected to be NUL-terminated, call &lt;code&gt;memcpy&lt;/code&gt; instead.</source>
          <target state="translated">또 다른 예로서, &lt;code&gt;strncpy&lt;/code&gt; 에 대한 다음 호출 은 종료 NUL을 끝에 추가하지 않고 종료 NUL 앞에 오는 문자 만 &lt;code&gt;d&lt;/code&gt; 에 복사합니다 . &lt;code&gt;strncpy&lt;/code&gt; 의 결과 가 반드시 NUL 종료 문자열 이라고 가정하는 것은 일반적인 실수이므로 호출이 진단됩니다. 결과가 NUL로 종료 될 것으로 예상되지 않을 때 경고를 피하려면 대신 &lt;code&gt;memcpy&lt;/code&gt; 를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="f22e08722bb8e7ce646a0894d86b714e1a18ddc2" translate="yes" xml:space="preserve">
          <source>As bit-fields are not individually addressable, volatile bit-fields may be implicitly read when written to, or when adjacent bit-fields are accessed. Bit-field operations may be optimized such that adjacent bit-fields are only partially accessed, if they straddle a storage unit boundary. For these reasons it is unwise to use volatile bit-fields to access hardware.</source>
          <target state="translated">비트 필드는 개별적으로 어드레스 가능하지 않기 때문에, 휘발성 비트 필드는 기록 될 때 또는 인접한 비트 필드가 액세스 될 때 암시 적으로 판독 될 수있다. 비트 필드 동작은 인접한 비트 필드가 저장 장치 경계에 걸쳐있는 경우 부분적으로 만 액세스되도록 최적화 될 수있다. 이러한 이유로 휘발성 비트 필드를 사용하여 하드웨어에 액세스하는 것은 현명하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="54cb09a605966e1ec9e0e0780e8355b83cacd9f7" translate="yes" xml:space="preserve">
          <source>As discussed in &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;, this attribute allows specification of target-specific compilation options.</source>
          <target state="translated">&lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;공통 기능 속성&lt;/a&gt; 에서 논의한 바와 같이이 속성을 사용하면 대상별 컴파일 옵션을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c47f4f2d2c816a9b7574ec5c08de30912daa2a80" translate="yes" xml:space="preserve">
          <source>As for &amp;lsquo;</source>
          <target state="translated">'에 관해서는</target>
        </trans-unit>
        <trans-unit id="71478357402c28a54c8c6fca58d451aad7e53ab5" translate="yes" xml:space="preserve">
          <source>As in standard C++ and ISO C99, the elements of an aggregate initializer for an automatic variable are not required to be constant expressions in GNU C. Here is an example of an initializer with run-time varying elements:</source>
          <target state="translated">표준 C ++ 및 ISO C99에서와 같이 자동 변수에 대한 집계 이니셜 라이저 요소는 GNU C에서 상수 표현식 일 필요는 없습니다. 다음은 런타임 가변 요소가있는 초기화 프로그램의 예입니다.</target>
        </trans-unit>
        <trans-unit id="e19fab7ccaf71008439ad46e66a6dd8a8249abc0" translate="yes" xml:space="preserve">
          <source>As in the preceding example, you can explicitly specify the alignment (in bytes) that you wish the compiler to use for a given &lt;code&gt;struct&lt;/code&gt; or &lt;code&gt;union&lt;/code&gt; type. Alternatively, you can leave out the alignment factor and just ask the compiler to align a type to the maximum useful alignment for the target machine you are compiling for. For example, you could write:</source>
          <target state="translated">앞의 예제에서와 같이 컴파일러가 주어진 &lt;code&gt;struct&lt;/code&gt; 또는 &lt;code&gt;union&lt;/code&gt; 유형 에 사용할 정렬 (바이트)을 명시 적으로 지정할 수 있습니다 . 또는 정렬 인수를 제외하고 컴파일러에게 컴파일하려는 대상 머신에 대한 최대 유용한 정렬로 유형을 정렬하도록 요청할 수 있습니다. 예를 들어 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b67040c22389d40183c4661602eeb071108d65a1" translate="yes" xml:space="preserve">
          <source>As in the preceding examples, you can explicitly specify the alignment (in bytes) that you wish the compiler to use for a given variable or structure field. Alternatively, you can leave out the alignment factor and just ask the compiler to align a variable or field to the default alignment for the target architecture you are compiling for. The default alignment is sufficient for all scalar types, but may not be enough for all vector types on a target that supports vector operations. The default alignment is fixed for a particular target ABI.</source>
          <target state="translated">앞의 예제에서와 같이 컴파일러가 주어진 변수 또는 구조 필드에 사용할 정렬 (바이트)을 명시 적으로 지정할 수 있습니다. 또는 정렬 인수를 제외하고 컴파일러에게 변수 또는 필드를 컴파일하려는 대상 아키텍처의 기본 정렬에 정렬하도록 요청할 수 있습니다. 기본 정렬은 모든 스칼라 유형에 충분하지만 벡터 연산을 지원하는 대상의 모든 벡터 유형에 충분하지 않을 수 있습니다. 기본 정렬은 특정 대상 ABI에 대해 고정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4953117cca7e33df31955c24738168de010b1a14" translate="yes" xml:space="preserve">
          <source>As long as the stack frame backchain is not used, code generated with</source>
          <target state="translated">스택 프레임 백 체인을 사용하지 않는 한</target>
        </trans-unit>
        <trans-unit id="55612a0f57841c9314e7eae808cb715df500b680" translate="yes" xml:space="preserve">
          <source>As mentioned above, the new exceptions do not support handling types other than Objective-C objects. Furthermore, when used from Objective-C++, the Objective-C exception model does not interoperate with C++ exceptions at this time. This means you cannot &lt;code&gt;@throw&lt;/code&gt; an exception from Objective-C and &lt;code&gt;catch&lt;/code&gt; it in C++, or vice versa (i.e., &lt;code&gt;throw &amp;hellip; @catch&lt;/code&gt;).</source>
          <target state="translated">위에서 언급했듯이 새로운 예외는 Objective-C 객체 이외의 유형을 처리하는 것을 지원하지 않습니다. 또한 Objective-C ++에서 사용될 때 Objective-C 예외 모델은 현재 C ++ 예외와 상호 운용되지 않습니다. 이 방법은 당신이 할 수 &lt;code&gt;@throw&lt;/code&gt; 목표 - C에서 예외를하고 &lt;code&gt;catch&lt;/code&gt; C ++, 또는 그 반대 (즉, 그것을 &lt;code&gt;throw &amp;hellip; @catch&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="294a250033394e9398ee357e8a3028f8f81f0fc0" translate="yes" xml:space="preserve">
          <source>As new Intel processors are deployed in the marketplace, the behavior of this option will change. Therefore, if you upgrade to a newer version of GCC, code generation controlled by this option will change to reflect the most current Intel processors at the time that version of GCC is released.</source>
          <target state="translated">새로운 인텔 프로세서가 시장에 배포됨에 따라이 옵션의 동작이 변경됩니다. 따라서 최신 버전의 GCC로 업그레이드하는 경우이 옵션으로 제어되는 코드 생성은 해당 버전의 GCC가 출시 될 때 최신 인텔 프로세서를 반영하도록 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="071c1df1bb91e5145c672769a3ad43fada5e0f32" translate="yes" xml:space="preserve">
          <source>As new processors are deployed in the marketplace, the behavior of this option will change. Therefore, if you upgrade to a newer version of GCC, code generation controlled by this option will change to reflect the processors that are most common at the time that version of GCC is released.</source>
          <target state="translated">새로운 프로세서가 시장에 배포됨에 따라이 옵션의 동작이 변경됩니다. 따라서 최신 버전의 GCC로 업그레이드하는 경우이 옵션으로 제어되는 코드 생성은 해당 버전의 GCC가 출시 될 때 가장 일반적인 프로세서를 반영하도록 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="3744f46b0905194e3e22c08ee725283caaeed6c9" translate="yes" xml:space="preserve">
          <source>As of the GCC 4.7.1 release, GCC supports the Go 1 language standard, described at &lt;a href=&quot;https://golang.org/doc/go1&quot;&gt;https://golang.org/doc/go1&lt;/a&gt;.</source>
          <target state="translated">GCC 4.7.1 릴리스부터 GCC는 &lt;a href=&quot;https://golang.org/doc/go1&quot;&gt;https://golang.org/doc/go1에&lt;/a&gt; 설명 된 Go 1 언어 표준을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="e64c1bee27f99a750cc73752558d5aa035a91d3b" translate="yes" xml:space="preserve">
          <source>As of this writing, only the NeXT runtime on Mac OS X 10.4 and later has support for invoking the &lt;code&gt;- (id) .cxx_construct&lt;/code&gt; and &lt;code&gt;- (void) .cxx_destruct&lt;/code&gt; methods.</source>
          <target state="translated">이 글을 쓰는 시점에서 Mac OS X 10.4 이상의 NeXT 런타임에서만 &lt;code&gt;- (id) .cxx_construct&lt;/code&gt; 및 &lt;code&gt;- (void) .cxx_destruct&lt;/code&gt; 메소드 호출을 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="190838497fcc16bfeb19ed9bf8cb7b33b5859658" translate="yes" xml:space="preserve">
          <source>As of this writing, there are no SPARC implementations that have hardware support for the quad-word floating-point instructions. They all invoke a trap handler for one of these instructions, and then the trap handler emulates the effect of the instruction. Because of the trap handler overhead, this is much slower than calling the ABI library routines. Thus the</source>
          <target state="translated">이 글을 쓰는 시점에서 쿼드 워드 부동 소수점 명령어를 하드웨어로 지원하는 SPARC 구현은 없습니다. 이들은 모두 이들 명령어 중 하나에 대한 트랩 핸들러를 호출 한 다음 트랩 핸들러가 명령의 효과를 에뮬레이트합니다. 트랩 처리기 오버 헤드로 인해 ABI 라이브러리 루틴을 호출하는 것보다 훨씬 느립니다. 그래서</target>
        </trans-unit>
        <trans-unit id="ea115f65d5a89a6a0ce102bba12e75c8b98c940e" translate="yes" xml:space="preserve">
          <source>As part of the Security Extensions GCC implements the intrinsics below. FPTR is used here to mean any function pointer type.</source>
          <target state="translated">보안 확장의 일부로 GCC는 아래의 내장 기능을 구현합니다. FPTR은 여기에서 함수 포인터 유형을 의미하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="44e4fff7ccbcdce5ca766f79d5a621ec9dbe0d23" translate="yes" xml:space="preserve">
          <source>As part of the Security Extensions GCC implements two new function attributes: &lt;code&gt;cmse_nonsecure_entry&lt;/code&gt; and &lt;code&gt;cmse_nonsecure_call&lt;/code&gt;.</source>
          <target state="translated">보안 확장의 일부로 GCC는 &lt;code&gt;cmse_nonsecure_entry&lt;/code&gt; 및 &lt;code&gt;cmse_nonsecure_call&lt;/code&gt; 의 두 가지 새로운 기능 속성을 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="7eaf9c2848babad871d614fdc58e037312c5b34b" translate="yes" xml:space="preserve">
          <source>As per</source>
          <target state="translated">에 따라</target>
        </trans-unit>
        <trans-unit id="77bdd745d898a259ccaad1e7c0edf927d13bbb62" translate="yes" xml:space="preserve">
          <source>As per the previous level, but also show events for the entry to each function.</source>
          <target state="translated">As per the previous level, but also show events for the entry to each function.</target>
        </trans-unit>
        <trans-unit id="51c247ef3385f14a80d57ef00798ecd37f7339e8" translate="yes" xml:space="preserve">
          <source>As per the previous level, but also show events relating to control flow that are significant to triggering the issue (e.g. &amp;ldquo;true path taken&amp;rdquo; at a conditional).</source>
          <target state="translated">As per the previous level, but also show events relating to control flow that are significant to triggering the issue (e.g. &amp;ldquo;true path taken&amp;rdquo; at a conditional).</target>
        </trans-unit>
        <trans-unit id="2efe9a9ef3b6fb5fc179ca740391f6374be999fe" translate="yes" xml:space="preserve">
          <source>As per the previous level, but show all control flow events, not just significant ones.</source>
          <target state="translated">As per the previous level, but show all control flow events, not just significant ones.</target>
        </trans-unit>
        <trans-unit id="dc6f3f1d276c90c5e06c8b6bf28158a5a889bccd" translate="yes" xml:space="preserve">
          <source>As permitted by ISO C11 and for compatibility with other compilers, GCC allows you to define a structure or union that contains, as fields, structures and unions without names. For example:</source>
          <target state="translated">ISO C11에서 허용하고 다른 컴파일러와의 호환성을 위해 GCC를 사용하면 이름없이 필드, 구조 및 공용체를 포함하는 구조 또는 공용체를 정의 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cd38e2252e3cfbc1562a66af3fc83a7b3476b926" translate="yes" xml:space="preserve">
          <source>As required by ISO C++, GCC considers member functions defined within the body of a class to be marked inline even if they are not explicitly declared with the &lt;code&gt;inline&lt;/code&gt; keyword. You can override this with</source>
          <target state="translated">ISO C ++에서 요구하는대로 GCC는 클래스 본문 내에 정의 된 멤버 함수가 &lt;code&gt;inline&lt;/code&gt; 키워드로 명시 적으로 선언되지 않은 경우에도 인라인으로 표시되는 것으로 간주 합니다. 이것을 재정의 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="ee86d176185420b2cd516cd28e0d2c038499f36a" translate="yes" xml:space="preserve">
          <source>As with all outermost parameter qualifiers, &lt;code&gt;__restrict__&lt;/code&gt; is ignored in function definition matching. This means you only need to specify &lt;code&gt;__restrict__&lt;/code&gt; in a function definition, rather than in a function prototype as well.</source>
          <target state="translated">모든 가장 바깥 쪽 매개 변수 한정자와 마찬가지로 &lt;code&gt;__restrict__&lt;/code&gt; 는 함수 정의 일치에서 무시됩니다. 즉 , 함수 프로토 타입이 아니라 함수 정의에 &lt;code&gt;__restrict__&lt;/code&gt; 만 지정하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="ba3fbd93824241c0022727ea0aaa70098dbf8058" translate="yes" xml:space="preserve">
          <source>As with global register variables, it is recommended that you choose a register that is normally saved and restored by function calls on your machine, so that calls to library routines will not clobber it.</source>
          <target state="translated">전역 레지스터 변수와 마찬가지로 일반적으로 시스템의 함수 호출에 의해 저장 및 복원되는 레지스터를 선택하여 라이브러리 루틴에 대한 호출이이를 방해하지 않도록하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="9d9e595b377650b7d530b408f01a2295e9aa3eb5" translate="yes" xml:space="preserve">
          <source>As with the C front end, G++ understands the C99 feature of restricted pointers, specified with the &lt;code&gt;__restrict__&lt;/code&gt;, or &lt;code&gt;__restrict&lt;/code&gt; type qualifier. Because you cannot compile C++ by specifying the</source>
          <target state="translated">C 프런트 엔드와 마찬가지로 G ++는 &lt;code&gt;__restrict__&lt;/code&gt; 또는 &lt;code&gt;__restrict&lt;/code&gt; 유형 한정자로 지정된 제한된 포인터의 C99 기능을 이해합니다 . 다음을 지정하여 C ++를 컴파일 할 수 없기 때문에</target>
        </trans-unit>
        <trans-unit id="21e7da79fc603087dc1baeac067752aa75dc3fe9" translate="yes" xml:space="preserve">
          <source>Assembler Options</source>
          <target state="translated">어셈블러 옵션</target>
        </trans-unit>
        <trans-unit id="bcf5f12f4332ce70ca2c9b5133dda1d57f7cdf19" translate="yes" xml:space="preserve">
          <source>Assembler code that must be preprocessed.</source>
          <target state="translated">사전 처리해야하는 어셈블러 코드</target>
        </trans-unit>
        <trans-unit id="f9cab59729ce9a72e9592405aff1f8fcf01f46db" translate="yes" xml:space="preserve">
          <source>Assembler code.</source>
          <target state="translated">어셈블러 코드.</target>
        </trans-unit>
        <trans-unit id="32b8b4178e9d441788dbf96199839a839961313d" translate="yes" xml:space="preserve">
          <source>Assembler names for data:</source>
          <target state="translated">데이터의 어셈블러 이름 :</target>
        </trans-unit>
        <trans-unit id="a60468da111a0ab238610d89ab550d7cb3db7634" translate="yes" xml:space="preserve">
          <source>Assembler names for functions:</source>
          <target state="translated">함수의 어셈블러 이름 :</target>
        </trans-unit>
        <trans-unit id="c09492c8b5916e81a92681e73286dd4d053d0d64" translate="yes" xml:space="preserve">
          <source>Assembly output</source>
          <target state="translated">조립 출력</target>
        </trans-unit>
        <trans-unit id="c20d25392b6fcd428956d9fadf904cf6f25c34c2" translate="yes" xml:space="preserve">
          <source>Assert that compilation targets a freestanding environment. This implies</source>
          <target state="translated">컴파일이 독립 환경을 대상으로한다고 주장하십시오. 이것은 암시</target>
        </trans-unit>
        <trans-unit id="d5b5344f90d89057b5b4c1d64f39bf480cc87ed4" translate="yes" xml:space="preserve">
          <source>Assert that compilation targets a hosted environment. This implies</source>
          <target state="translated">컴파일이 호스팅 된 환경을 대상으로한다고 주장하십시오. 이것은 암시</target>
        </trans-unit>
        <trans-unit id="3d6a91afbb703874ed1adcc1fc07fbc355255566" translate="yes" xml:space="preserve">
          <source>Assignments are also expressions and have an rvalue. However when assigning to a scalar volatile, the volatile object is not reread, regardless of whether the assignment expression&amp;rsquo;s rvalue is used or not. If the assignment&amp;rsquo;s rvalue is used, the value is that assigned to the volatile object. For instance, there is no read of &lt;var&gt;vobj&lt;/var&gt; in all the following cases:</source>
          <target state="translated">할당도 표현식이며 rvalue가 있습니다. 그러나 스칼라 휘발성에 할당 할 때 할당 식의 rvalue 사용 여부에 관계없이 휘발성 객체를 다시 읽지 않습니다. 할당의 rvalue가 사용되는 경우, 값은 휘발성 객체에 할당 된 값입니다. 예를 들어 다음과 같은 모든 경우 에 &lt;var&gt;vobj&lt;/var&gt; 를 읽을 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="0c40f851ca2e4b0159b069f87df3cdf0c325569f" translate="yes" xml:space="preserve">
          <source>Assume (do not assume) that all symbols have 32-bit values, regardless of the selected ABI. This option is useful in combination with</source>
          <target state="translated">선택한 ABI에 관계없이 모든 심볼에 32 비트 값이 있다고 가정합니다. 이 옵션은</target>
        </trans-unit>
        <trans-unit id="29f90ada4a3fec867ca24dbc5026596c24d16fc4" translate="yes" xml:space="preserve">
          <source>Assume (do not assume) that externally-defined data is in a small data section if the size of that data is within the</source>
          <target state="translated">해당 데이터의 크기가 데이터 범위 내에 있으면 외부 정의 데이터가 작은 데이터 섹션에 있다고 가정</target>
        </trans-unit>
        <trans-unit id="2cfe16d43985ee39e482829ca4a8dfdcb2d636f4" translate="yes" xml:space="preserve">
          <source>Assume (do not assume) that the reciprocal estimate instructions provide higher-precision estimates than is mandated by the PowerPC ABI.</source>
          <target state="translated">상호 추정 명령이 PowerPC ABI에서 요구하는 것보다 더 정밀한 추정을 제공한다고 가정합니다 (상정하지 마십시오).</target>
        </trans-unit>
        <trans-unit id="ec6f2df5d90d0e07067a08f77629a109a7baeb7c" translate="yes" xml:space="preserve">
          <source>Assume (do not assume) that the reciprocal estimate instructions provide higher-precision estimates than is mandated by the PowerPC ABI. Selecting</source>
          <target state="translated">상호 추정 명령이 PowerPC ABI에서 요구하는 것보다 더 정밀한 추정을 제공한다고 가정합니다 (상정하지 마십시오). 선택</target>
        </trans-unit>
        <trans-unit id="813b5f0f913426f167f43f6e9f2605b43322e0d6" translate="yes" xml:space="preserve">
          <source>Assume (do not assume) that the static and dynamic linkers support PLTs and copy relocations. This option only affects</source>
          <target state="translated">정적 및 동적 링커는 PLT 및 사본 재배치를 지원한다고 가정합니다 (상정하지 마십시오). 이 옵션은 다음에 만 영향을줍니다</target>
        </trans-unit>
        <trans-unit id="6218242555601cfde6dcb1f0fb4410c65b0c0afe" translate="yes" xml:space="preserve">
          <source>Assume (do not assume) that zero displacement conditional branch instructions &lt;code&gt;bt&lt;/code&gt; and &lt;code&gt;bf&lt;/code&gt; are fast. If</source>
          <target state="translated">제로 변위 조건부 분기 명령 &lt;code&gt;bt&lt;/code&gt; 및 &lt;code&gt;bf&lt;/code&gt; 가 빠르다고 가정합니다. 만약</target>
        </trans-unit>
        <trans-unit id="4d87b438e6a49fee40ee2b8e75d048b2cb33a8d4" translate="yes" xml:space="preserve">
          <source>Assume &lt;code&gt;int&lt;/code&gt; to be 8-bit integer. This affects the sizes of all types: a &lt;code&gt;char&lt;/code&gt; is 1 byte, an &lt;code&gt;int&lt;/code&gt; is 1 byte, a &lt;code&gt;long&lt;/code&gt; is 2 bytes, and &lt;code&gt;long long&lt;/code&gt; is 4 bytes. Please note that this option does not conform to the C standards, but it results in smaller code size.</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; 를 8 비트 정수로 가정하십시오 . 이것은 모든 유형의 크기에 영향을줍니다. &lt;code&gt;char&lt;/code&gt; 은 1 바이트, &lt;code&gt;int&lt;/code&gt; 는 1 바이트, &lt;code&gt;long&lt;/code&gt; 은 2 바이트, &lt;code&gt;long long&lt;/code&gt; 은 4 바이트입니다. 이 옵션은 C 표준을 준수하지 않지만 코드 크기가 더 작아집니다.</target>
        </trans-unit>
        <trans-unit id="5c2bc85ec675432aace4d6922b50129cffa86b60" translate="yes" xml:space="preserve">
          <source>Assume &lt;var&gt;num&lt;/var&gt; to be the cost for a branch instruction. Higher numbers make the compiler try to generate more branch-free code if possible. If not specified the value is selected depending on the processor type that is being compiled for.</source>
          <target state="translated">&lt;var&gt;num&lt;/var&gt; 은 분기 명령어의 비용 이라고 가정 합니다. 숫자가 높을수록 컴파일러는 가능하면 더 많은 분기없는 코드를 생성하려고합니다. 지정하지 않으면 값은 컴파일중인 프로세서 유형에 따라 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="a18b03a98d3895d8de33097ebfdc73e386381f27" translate="yes" xml:space="preserve">
          <source>Assume a large TLS segment when generating thread-local code.</source>
          <target state="translated">스레드 로컬 코드를 생성 할 때 큰 TLS 세그먼트를 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="dcc9240dada623776592057c6e5b8a92da4c9b4e" translate="yes" xml:space="preserve">
          <source>Assume addresses can be loaded as 16-bit unsigned values. This does not apply to function addresses for which</source>
          <target state="translated">주소를 부호없는 16 비트 값으로로드 할 수 있다고 가정합니다. 기능 주소에는 적용되지 않습니다</target>
        </trans-unit>
        <trans-unit id="fb31614e67999bd6734c6361178e2cdabb52e555" translate="yes" xml:space="preserve">
          <source>Assume all objects live in the lower 16MB of memory (so that their addresses can be loaded with the &lt;code&gt;ld24&lt;/code&gt; instruction), and assume all subroutines are reachable with the &lt;code&gt;bl&lt;/code&gt; instruction. This is the default.</source>
          <target state="translated">모든 객체가 16MB 이하의 메모리에 있고 ( &lt;code&gt;ld24&lt;/code&gt; 명령어로 주소를로드 할 수 있도록 ) &lt;code&gt;bl&lt;/code&gt; 명령어를 사용 하여 모든 서브 루틴에 도달 할 수 있다고 가정합니다 . 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="c507ae5c9607f036356273bef8470c3d07a51113" translate="yes" xml:space="preserve">
          <source>Assume inline assembler is using unified asm syntax. The default is currently off which implies divided syntax. This option has no impact on Thumb2. However, this may change in future releases of GCC. Divided syntax should be considered deprecated.</source>
          <target state="translated">인라인 어셈블러가 통합 asm 구문을 사용한다고 가정합니다. 기본값은 현재 꺼져 있으며 분할 구문을 의미합니다. 이 옵션은 Thumb2에 영향을 미치지 않습니다. 그러나 이는 향후 GCC 릴리스에서 변경 될 수 있습니다. 구분 된 구문은 더 이상 사용되지 않는 것으로 간주해야합니다.</target>
        </trans-unit>
        <trans-unit id="db05f7ded93295035bf91b215647f3c25bb15bd8" translate="yes" xml:space="preserve">
          <source>Assume loading data from flash is slower than fetching instruction. Therefore literal load is minimized for better performance. This option is only supported when compiling for ARMv7 M-profile and off by default. It conflicts with</source>
          <target state="translated">플래시에서 데이터를로드하는 것이 명령을 가져 오는 것보다 느리다고 가정하십시오. 따라서 성능 향상을 위해 리터럴로드가 최소화됩니다. 이 옵션은 ARMv7 M 프로파일을 컴파일 할 때만 지원되며 기본적으로 해제되어 있습니다. 충돌</target>
        </trans-unit>
        <trans-unit id="d4a16bcb883f109ce15025d3902db389e542f4a1" translate="yes" xml:space="preserve">
          <source>Assume objects may be anywhere in the 32-bit address space (the compiler generates &lt;code&gt;seth/add3&lt;/code&gt; instructions to load their addresses), and assume all subroutines are reachable with the &lt;code&gt;bl&lt;/code&gt; instruction.</source>
          <target state="translated">객체가 32 비트 주소 공간의 어느 곳에 나있을 수 있다고 가정하고 (컴파일러는 주소를로드하기 위해 &lt;code&gt;seth/add3&lt;/code&gt; 명령어를 생성 함 ) &lt;code&gt;bl&lt;/code&gt; 명령어를 사용 하여 모든 서브 루틴에 도달 할 수 있다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="7d339dd7aa4708a54eb51d13312b9c328ad3f5e5" translate="yes" xml:space="preserve">
          <source>Assume objects may be anywhere in the 32-bit address space (the compiler generates &lt;code&gt;seth/add3&lt;/code&gt; instructions to load their addresses), and assume subroutines may not be reachable with the &lt;code&gt;bl&lt;/code&gt; instruction (the compiler generates the much slower &lt;code&gt;seth/add3/jl&lt;/code&gt; instruction sequence).</source>
          <target state="translated">객체가 32 비트 주소 공간의 어느 곳에 나있을 수 있다고 가정하고 (컴파일러는 주소를로드하기 위해 &lt;code&gt;seth/add3&lt;/code&gt; 명령어를 생성 함 ) &lt;code&gt;bl&lt;/code&gt; 명령어를 사용하여 서브 루틴에 도달 할 수 없다고 가정 합니다 (컴파일러는 훨씬 느린 &lt;code&gt;seth/add3/jl&lt;/code&gt; 명령어를 생성 함) 순서).</target>
        </trans-unit>
        <trans-unit id="c85e043c6d4b72a1f02e91090d703114e74e4f8f" translate="yes" xml:space="preserve">
          <source>Assume that &lt;code&gt;RJMP&lt;/code&gt; and &lt;code&gt;RCALL&lt;/code&gt; can target the whole program memory.</source>
          <target state="translated">&lt;code&gt;RJMP&lt;/code&gt; 및 &lt;code&gt;RCALL&lt;/code&gt; 이 전체 프로그램 메모리를 대상으로 할 수 있다고 가정하십시오 .</target>
        </trans-unit>
        <trans-unit id="33caf9125270759b9ef9dbfd91c8e100e633839c" translate="yes" xml:space="preserve">
          <source>Assume that ICPLBs are enabled at run time. This has an effect on certain anomaly workarounds. For Linux targets, the default is to assume ICPLBs are enabled; for standalone applications the default is off.</source>
          <target state="translated">ICPLB가 런타임에 사용 가능하다고 가정하십시오. 이는 특정 예외 해결 방법에 영향을줍니다. Linux 대상의 경우 기본값은 ICPLB가 사용 가능한 것으로 가정하는 것입니다. 독립형 응용 프로그램의 경우 기본값은 해제입니다.</target>
        </trans-unit>
        <trans-unit id="b5ac123daea99f10bd295c162e2bdc33dbbb4983" translate="yes" xml:space="preserve">
          <source>Assume that a loop with an exit will eventually take the exit and not loop indefinitely. This allows the compiler to remove loops that otherwise have no side-effects, not considering eventual endless looping as such.</source>
          <target state="translated">Assume that a loop with an exit will eventually take the exit and not loop indefinitely. This allows the compiler to remove loops that otherwise have no side-effects, not considering eventual endless looping as such.</target>
        </trans-unit>
        <trans-unit id="ed72c79186a186d46e787e25dd72b1da5c105ed8" translate="yes" xml:space="preserve">
          <source>Assume that all Objective-C message dispatches (&lt;code&gt;[receiver
message:arg]&lt;/code&gt;) in this translation unit ensure that the receiver is not &lt;code&gt;nil&lt;/code&gt;. This allows for more efficient entry points in the runtime to be used. This option is only available in conjunction with the NeXT runtime and ABI version 0 or 1.</source>
          <target state="translated">이 변환 단위의 모든 Objective-C 메시지 디스패치 ( &lt;code&gt;[receiver message:arg]&lt;/code&gt; )가 수신자가 &lt;code&gt;nil&lt;/code&gt; 이 아닌지 확인한다고 가정하십시오 . 이를 통해 런타임에서보다 효율적인 진입 점이 사용될 수 있습니다. 이 옵션은 NeXT 런타임 및 ABI 버전 0 또는 1과 함께 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="866258482a2aa9fcb54dee6ab333e2e33fa56a9f" translate="yes" xml:space="preserve">
          <source>Assume that all data in static storage can be accessed by LDS / STS instructions. This option has only an effect on reduced Tiny devices like ATtiny40. See also the &lt;code&gt;absdata&lt;/code&gt;&lt;a href=&quot;variable-attributes#AVR-Variable-Attributes&quot;&gt;variable attribute&lt;/a&gt;.</source>
          <target state="translated">정적 스토리지의 모든 데이터는 LDS / STS 명령으로 액세스 할 수 있다고 가정하십시오. 이 옵션은 ATtiny40과 같이 축소 된 Tiny 장치에만 영향을줍니다. &lt;code&gt;absdata&lt;/code&gt; &lt;a href=&quot;variable-attributes#AVR-Variable-Attributes&quot;&gt;변수 속성&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9ef3d0ef83e6f997acb69f32efa34ce5f18bfd5d" translate="yes" xml:space="preserve">
          <source>Assume that doubles have 8-byte alignment. This is the default.</source>
          <target state="translated">더블은 8 바이트 정렬을 가정합니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="856f36f37f5770dafc37ec4f5ce9ae4ba43b9ab0" translate="yes" xml:space="preserve">
          <source>Assume that floating-point registers are 32 bits wide.</source>
          <target state="translated">부동 소수점 레지스터의 너비가 32 비트라고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="89754b304532c00897fca86b5c5a4a2fdb8ea856" translate="yes" xml:space="preserve">
          <source>Assume that floating-point registers are 64 bits wide.</source>
          <target state="translated">부동 소수점 레지스터의 폭이 64 비트라고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="6c5971ed7912aa4bcfc190d25dcfc54913916046" translate="yes" xml:space="preserve">
          <source>Assume that floating-point stores and loads are not likely to cause a conflict when placed into the same instruction group. This option is disabled by default.</source>
          <target state="translated">부동 소수점 저장 및로드가 동일한 명령어 그룹에 배치 될 때 충돌을 일으키지 않을 것이라고 가정하십시오. 이 옵션은 기본적으로 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="79ddd95e70fe2bc8d68e335f2358d8d016cca43e" translate="yes" xml:space="preserve">
          <source>Assume that general-purpose registers are 32 bits wide.</source>
          <target state="translated">범용 레지스터의 폭이 32 비트라고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="67b1eea988cecf507f4140115cf0f3a04a0b6bc0" translate="yes" xml:space="preserve">
          <source>Assume that general-purpose registers are 64 bits wide.</source>
          <target state="translated">범용 레지스터의 폭이 64 비트라고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="d05b8de7cb58ad911a3c660af041154da0f70378" translate="yes" xml:space="preserve">
          <source>Assume that programs cannot safely dereference null pointers, and that no code or data element resides at address zero. This option enables simple constant folding optimizations at all optimization levels. In addition, other optimization passes in GCC use this flag to control global dataflow analyses that eliminate useless checks for null pointers; these assume that a memory access to address zero always results in a trap, so that if a pointer is checked after it has already been dereferenced, it cannot be null.</source>
          <target state="translated">프로그램이 널 포인터를 안전하게 역 참조 할 수없고 주소 0에 코드 나 데이터 요소가없는 것으로 가정하십시오. 이 옵션을 사용하면 모든 최적화 수준에서 간단한 상수 폴딩 최적화가 가능합니다. 또한 GCC의 다른 최적화 단계에서는이 플래그를 사용하여 null 포인터에 대한 쓸모없는 검사를 제거하는 전역 데이터 흐름 분석을 제어합니다. 이들은 주소 0에 대한 메모리 액세스가 항상 트랩을 초래한다고 가정하므로 포인터가 이미 역 참조 된 후에 포인터가 검사되면 널이 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="076633874f4c1995b07023b5b94aab209c515c86" translate="yes" xml:space="preserve">
          <source>Assume that runtime support has been provided and so omit the simulator library (</source>
          <target state="translated">런타임 지원이 제공되었다고 가정하고 시뮬레이터 라이브러리를 생략하십시오 (</target>
        </trans-unit>
        <trans-unit id="42823e20bce5001093b19d4ebc090a1f52fb87fe" translate="yes" xml:space="preserve">
          <source>Assume that runtime support has been provided and so there is no need to include the simulator library (</source>
          <target state="translated">런타임 지원이 제공되어 시뮬레이터 라이브러리를 포함 할 필요가 없다고 가정하십시오 (</target>
        </trans-unit>
        <trans-unit id="0d530f525409fd98b58f0bb247b2945e9f43679e" translate="yes" xml:space="preserve">
          <source>Assume that the current compilation unit represents the whole program being compiled. All public functions and variables with the exception of &lt;code&gt;main&lt;/code&gt; and those merged by attribute &lt;code&gt;externally_visible&lt;/code&gt; become static functions and in effect are optimized more aggressively by interprocedural optimizers.</source>
          <target state="translated">현재 컴파일 단위가 컴파일되는 전체 프로그램을 나타낸다고 가정하십시오. &lt;code&gt;main&lt;/code&gt; 을 제외한 모든 공용 함수 및 변수와 &lt;code&gt;externally_visible&lt;/code&gt; 속성으로 병합 된 변수는 정적 함수가되며 실제로는 절차 적 최적화에 의해보다 적극적으로 최적화됩니다.</target>
        </trans-unit>
        <trans-unit id="d4cfc093a537b06194880f65fa701bc5be05c19f" translate="yes" xml:space="preserve">
          <source>Assume that the device supports the Read-Modify-Write instructions &lt;code&gt;XCH&lt;/code&gt;, &lt;code&gt;LAC&lt;/code&gt;, &lt;code&gt;LAS&lt;/code&gt; and &lt;code&gt;LAT&lt;/code&gt;.</source>
          <target state="translated">장치가 Read-Modify-Write 명령어 &lt;code&gt;XCH&lt;/code&gt; , &lt;code&gt;LAC&lt;/code&gt; , &lt;code&gt;LAS&lt;/code&gt; 및 &lt;code&gt;LAT&lt;/code&gt; 를 지원한다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="766547e453a1be99c1e3faccd183445d895ac153" translate="yes" xml:space="preserve">
          <source>Assume that the displacement between the text and data segments is fixed at static link time. This allows data to be referenced by offset from start of text address instead of GOT since PC-relative addressing is not supported.</source>
          <target state="translated">텍스트와 데이터 세그먼트 사이의 변위가 정적 링크 시간에 고정되었다고 가정하십시오. PC 기준 주소 지정이 지원되지 않으므로 GOT 대신 텍스트 주소 시작에서 오프셋으로 데이터를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ebfb14654d3ce6ee7fc14d89650e1df706d43a0e" translate="yes" xml:space="preserve">
          <source>Assume that the displacement between the text and data segments is fixed at static link time. This permits using PC-relative addressing operations to access data known to be in the data segment. For non-VxWorks RTP targets, this option is enabled by default. When disabled on such targets, it will enable</source>
          <target state="translated">텍스트와 데이터 세그먼트 사이의 변위가 정적 링크 시간에 고정되었다고 가정하십시오. 이를 통해 PC 상대 주소 지정 작업을 사용하여 데이터 세그먼트에있는 것으로 알려진 데이터에 액세스 할 수 있습니다. VxWorks RTP 대상이 아닌 경우이 옵션은 기본적으로 활성화되어 있습니다. 이러한 대상에서 비활성화되면 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="38bffa713c2a7cd96b200f3894b2b7a3ab419ebb" translate="yes" xml:space="preserve">
          <source>Assume that the flash memory has a size of &lt;var&gt;num&lt;/var&gt; times 64 KiB.</source>
          <target state="translated">플래시 메모리의 크기는 &lt;var&gt;num&lt;/var&gt; 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="0381000794bbd2c3b341dcaa9dd877537e5d82e9" translate="yes" xml:space="preserve">
          <source>Assume that the floating-point coprocessor only supports single-precision operations.</source>
          <target state="translated">부동 소수점 보조 프로세서는 단 정밀도 연산 만 지원한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="da28820fdda9574eb1ba106e15f86ccdafa0352f" translate="yes" xml:space="preserve">
          <source>Assume that the floating-point coprocessor supports double-precision operations. This is the default.</source>
          <target state="translated">부동 소수점 보조 프로세서는 배정도 연산을 지원한다고 가정합니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="fdfa0bfee5480efa2b5e12152c0e653e6cc25473" translate="yes" xml:space="preserve">
          <source>Assume that the handler uses a shadow register set, instead of the main general-purpose registers. An optional argument &lt;code&gt;intstack&lt;/code&gt; is supported to indicate that the shadow register set contains a valid stack pointer.</source>
          <target state="translated">핸들러가 기본 범용 레지스터 대신 새도우 레지스터 세트를 사용한다고 가정하십시오. 섀도우 레지스터 세트에 유효한 스택 포인터가 있음을 나타 내기 위해 선택적 인수 &lt;code&gt;intstack&lt;/code&gt; 이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="cb05f1c18ebd5a07940293ac38328ed8480807dc" translate="yes" xml:space="preserve">
          <source>Assume that the program is arbitrarily large. This is the default.</source>
          <target state="translated">프로그램이 임의로 큰 것으로 가정하십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="bea8e60014028d1c1e2350ea91c13bef18cfe395" translate="yes" xml:space="preserve">
          <source>Assume the incoming stack is aligned to a 2 raised to &lt;var&gt;num&lt;/var&gt; byte boundary. If</source>
          <target state="translated">들어오는 스택이 2에서 &lt;var&gt;num&lt;/var&gt; 바이트 경계 까지 올렸다고 가정합니다 . 만약</target>
        </trans-unit>
        <trans-unit id="2b0c018c4bbeac1a835b6bc4f97980f45c5201f9" translate="yes" xml:space="preserve">
          <source>At level &lt;var&gt;2&lt;/var&gt;, the call in the example above is again diagnosed, but this time because with &lt;var&gt;a&lt;/var&gt; equal to a 32-bit &lt;code&gt;INT_MIN&lt;/code&gt; the first &lt;code&gt;%i&lt;/code&gt; directive will write some of its digits beyond the end of the destination buffer. To make the call safe regardless of the values of the two variables, the size of the destination buffer must be increased to at least 34 bytes. GCC includes the minimum size of the buffer in an informational note following the warning.</source>
          <target state="translated">레벨에서 &lt;var&gt;2&lt;/var&gt; 위의 예에서 호출은 다시 진단되지만이 시간 때문에 32 비트와 동일 &lt;code&gt;INT_MIN&lt;/code&gt; 제 &lt;code&gt;%i&lt;/code&gt; 지정 목적지 버퍼의 끝을 넘어 그 숫자들을 쓸 것이다. 두 변수의 값에 관계없이 호출을 안전하게하려면 대상 버퍼의 크기를 34 바이트 이상으로 늘려야합니다. GCC는 경고 다음에 정보 메모에 버퍼의 최소 크기를 포함합니다. &lt;var&gt;a&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="3ddf0f631ce882bb84e3fb93f118fee7f5a7f5f9" translate="yes" xml:space="preserve">
          <source>At present, GCC only provides support for operations on 32-bit vectors. The vector type associated with 8-bit integer data is usually called &lt;code&gt;v4i8&lt;/code&gt;, the vector type associated with Q7 is usually called &lt;code&gt;v4q7&lt;/code&gt;, the vector type associated with 16-bit integer data is usually called &lt;code&gt;v2i16&lt;/code&gt;, and the vector type associated with Q15 is usually called &lt;code&gt;v2q15&lt;/code&gt;. They can be defined in C as follows:</source>
          <target state="translated">현재 GCC는 32 비트 벡터에 대한 연산 만 지원합니다. 8 비트 정수 데이터와 연관된 벡터 유형은 일반적으로 호출 &lt;code&gt;v4i8&lt;/code&gt; Q7과 연관된 벡터 유형은 일반적으로 호출되면 &lt;code&gt;v4q7&lt;/code&gt; 16 비트 정수 데이터와 연관된 벡터 유형은 일반적으로 호출, &lt;code&gt;v2i16&lt;/code&gt; 및 Q15와 연관된 벡터 유형은 일반적 &lt;code&gt;v2q15&lt;/code&gt; 라고 합니다 . C에서 다음과 같이 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7562b8145986b9d15bbe747f7453ec31fbcb23e3" translate="yes" xml:space="preserve">
          <source>At present, a declaration to which &lt;code&gt;weakref&lt;/code&gt; is attached can only be &lt;code&gt;static&lt;/code&gt;.</source>
          <target state="translated">현재 &lt;code&gt;weakref&lt;/code&gt; 가 첨부 된 선언 은 &lt;code&gt;static&lt;/code&gt; 만 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="e4135487f1e326a7c07cb63519ab457040bcc6fd" translate="yes" xml:space="preserve">
          <source>At present, the first parameter in a function prototype must have some type specifier that is not an attribute specifier; this resolves an ambiguity in the interpretation of &lt;code&gt;void f(int
(__attribute__((foo)) x))&lt;/code&gt;, but is subject to change. At present, if the parentheses of a function declarator contain only attributes then those attributes are ignored, rather than yielding an error or warning or implying a single parameter of type int, but this is subject to change.</source>
          <target state="translated">현재 함수 프로토 타입의 첫 번째 매개 변수에는 속성 지정자가 아닌 일부 유형 지정자가 있어야합니다. 이것은 &lt;code&gt;void f(int (__attribute__((foo)) x))&lt;/code&gt; 의 해석에 대한 모호성을 해결 하지만 변경 될 수 있습니다. 현재 함수 선언자의 괄호에 속성 만 포함 된 경우 오류나 경고를 생성하거나 int 유형의 단일 매개 변수를 암시하지 않고 해당 속성이 무시되지만 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aba1eab05ac64c3b09192d2f6e850b4049723108" translate="yes" xml:space="preserve">
          <source>At the user level, the extension is visible with a new storage class keyword: &lt;code&gt;__thread&lt;/code&gt;. For example:</source>
          <target state="translated">사용자 레벨에서 확장은 새 스토리지 클래스 키워드 &lt;code&gt;__thread&lt;/code&gt; 로 볼 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="822a22d01653371bac14c53e07474f5d45325389" translate="yes" xml:space="preserve">
          <source>At this level</source>
          <target state="translated">이 수준에서</target>
        </trans-unit>
        <trans-unit id="87ea658ed4a4a90d1fc99e8e69012153c56f031c" translate="yes" xml:space="preserve">
          <source>At this level, in addition to diagnosing all the same constructs as at level 1, a diagnostic is also issued for placement new expressions that construct an object in the last member of structure whose type is an array of a single element and whose size is less than the size of the object being constructed. While the previous example would be diagnosed, the following construct makes use of the flexible member array extension to avoid the warning at level 2.</source>
          <target state="translated">이 레벨에서 레벨 1과 동일한 모든 구문을 진단하는 것 외에도 유형이 단일 요소의 배열이고 크기가 작은 구조의 마지막 멤버에 오브젝트를 구성하는 새 표현식 배치에 대한 진단도 발행됩니다. 구성되는 객체의 크기보다 이전 예제는 진단되었지만 다음 구성은 레벨 2의 경고를 피하기 위해 유연한 멤버 배열 확장을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="899a58ab48a1eeb8b5da7677f79db54f17f5ac4a" translate="yes" xml:space="preserve">
          <source>At this level, interprocedural call and return events are displayed, along with the most pertinent state-change events relating to a diagnostic. For example, for a double-&lt;code&gt;free&lt;/code&gt; diagnostic, both calls to &lt;code&gt;free&lt;/code&gt; will be shown.</source>
          <target state="translated">At this level, interprocedural call and return events are displayed, along with the most pertinent state-change events relating to a diagnostic. For example, for a double- &lt;code&gt;free&lt;/code&gt; diagnostic, both calls to &lt;code&gt;free&lt;/code&gt; will be shown.</target>
        </trans-unit>
        <trans-unit id="01d0144240e3a9879fbee890a976db3a3119bfe0" translate="yes" xml:space="preserve">
          <source>At this time GCC tries to detect also a few terminals that are known to not implement the URL feature, and have bugs or at least had bugs in some versions that are still in use, where the URL escapes are likely to misbehave, i.e. print garbage on the screen. That list is currently xfce4-terminal, certain known to be buggy gnome-terminal versions, the linux console, and mingw. This check can be skipped with the</source>
          <target state="translated">At this time GCC tries to detect also a few terminals that are known to not implement the URL feature, and have bugs or at least had bugs in some versions that are still in use, where the URL escapes are likely to misbehave, i.e. print garbage on the screen. That list is currently xfce4-terminal, certain known to be buggy gnome-terminal versions, the linux console, and mingw. This check can be skipped with the</target>
        </trans-unit>
        <trans-unit id="27bef66661f5c0b03146d1698ca3afb51d9a26fb" translate="yes" xml:space="preserve">
          <source>Atomic built-in functions with memory model.</source>
          <target state="translated">메모리 모델에 내장 된 기능.</target>
        </trans-unit>
        <trans-unit id="4ce1364206864236a22c5c48cd625fe86883adb2" translate="yes" xml:space="preserve">
          <source>Atomic types are not permitted for bit-fields.</source>
          <target state="translated">비트 필드에는 원자 유형이 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b41c8daf0a5d584177e036c6b54eb5d698ff31ca" translate="yes" xml:space="preserve">
          <source>Attempt to avoid false dependencies in scheduled code by making use of registers left over after register allocation. This optimization most benefits processors with lots of registers. Depending on the debug information format adopted by the target, however, it can make debugging impossible, since variables no longer stay in a &amp;ldquo;home register&amp;rdquo;.</source>
          <target state="translated">레지스터 할당 후 남은 레지스터를 사용하여 스케줄 된 코드에서 잘못된 종속성을 피하십시오. 이 최적화는 레지스터가 많은 프로세서에 가장 유용합니다. 그러나 대상에서 채택한 디버그 정보 형식에 따라 변수가 더 이상 &quot;홈 레지스터&quot;에 남아 있지 않으므로 디버깅이 불가능해질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6f5acede0fbb18382444dea8c6c4247f6477d4a" translate="yes" xml:space="preserve">
          <source>Attempt to convert calls to virtual functions to direct calls. This is done both within a procedure and interprocedurally as part of indirect inlining (</source>
          <target state="translated">호출을 가상 함수로 변환하여 직접 호출로 전환하십시오. 이는 간접 인라이닝의 일부로 절차 내에서 그리고 절차 적으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="23ecd786dc35f08a1baffd99e6e7d5e25ec53b58" translate="yes" xml:space="preserve">
          <source>Attempt to convert calls to virtual functions to speculative direct calls. Based on the analysis of the type inheritance graph, determine for a given call the set of likely targets. If the set is small, preferably of size 1, change the call into a conditional deciding between direct and indirect calls. The speculative calls enable more optimizations, such as inlining. When they seem useless after further optimization, they are converted back into original form.</source>
          <target state="translated">가상 함수 호출을 추론 적 직접 호출로 변환하려고합니다. 유형 상속 그래프의 분석을 기반으로 주어진 호출에 대해 가능한 대상 세트를 결정하십시오. 세트가 작고, 바람직하게는 크기가 1 인 경우, 직접 및 간접 호출 사이의 조건부 결정으로 호출을 변경하십시오. 투기 호출은 인라인과 같은 더 많은 최적화를 가능하게합니다. 추가 최적화 후 쓸모가없는 것처럼 보이면 원래 형태로 다시 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="015c279bf199fbda7e73b9795378a6fd0b0af2c9" translate="yes" xml:space="preserve">
          <source>Attempt to decrease register pressure through register live range shrinkage. This is helpful for fast processors with small or moderate size register sets.</source>
          <target state="translated">레지스터 라이브 범위 축소를 ​​통해 레지스터 압력을 낮추십시오. 이는 레지스터 크기가 작거나 중간 인 고속 프로세서에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="687510f6384de354811653c1b3a65669791e13da" translate="yes" xml:space="preserve">
          <source>Attempt to determine location views that can be omitted from location view lists. This requires the compiler to have very accurate insn length estimates, which isn&amp;rsquo;t always the case, and it may cause incorrect view lists to be generated silently when using an assembler that does not support location view lists. The GNU assembler will flag any such error as a &lt;code&gt;view number mismatch&lt;/code&gt;. This is only enabled on ports that define a reliable estimation function.</source>
          <target state="translated">위치보기 목록에서 생략 할 수있는 위치보기를 결정하십시오. 이것은 컴파일러가 매우 정확한 insn 길이 추정치를 가져야하며, 항상 그런 것은 아니며 위치 뷰 목록을 지원하지 않는 어셈블러를 사용할 때 잘못된 뷰 목록이 자동으로 생성 될 수 있습니다. GNU 어셈블러는 이러한 오류를 &lt;code&gt;view number mismatch&lt;/code&gt; 합니다. 신뢰할 수있는 추정 기능을 정의하는 포트에서만 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="aac236b78fdffe9d37dcfcf412e47b1651113242" translate="yes" xml:space="preserve">
          <source>Attempt to keep the stack boundary aligned to a 2 raised to &lt;var&gt;num&lt;/var&gt; byte boundary. If</source>
          <target state="translated">스택 경계를 2에서 &lt;var&gt;num&lt;/var&gt; 바이트 경계 까지 올린 상태로 유지하십시오 . 만약</target>
        </trans-unit>
        <trans-unit id="c862c84dcea1c34fb363ef2530e074c7fb9ff011" translate="yes" xml:space="preserve">
          <source>Attempt to merge identical constants (string constants and floating-point constants) across compilation units.</source>
          <target state="translated">컴파일 단위에서 동일한 상수 (문자열 상수 및 부동 소수점 상수)를 병합하려고합니다.</target>
        </trans-unit>
        <trans-unit id="50e4bd95dd66a112841cf4cd0b134789556e574d" translate="yes" xml:space="preserve">
          <source>Attempt to merge identical constants and identical variables.</source>
          <target state="translated">동일한 상수와 동일한 변수를 병합하십시오.</target>
        </trans-unit>
        <trans-unit id="0f797d45d3d320c615fd705a20d8464b1c6f92f0" translate="yes" xml:space="preserve">
          <source>Attempt to minimize stack usage. The compiler attempts to use less stack space, even if that makes the program slower. This option implies setting the</source>
          <target state="translated">스택 사용을 최소화하십시오. 컴파일러는 프로그램을 더 느리게 만들더라도 더 적은 스택 공간을 사용하려고합니다. 이 옵션은</target>
        </trans-unit>
        <trans-unit id="1d6331b92854e1a7daaaa3b254ef23d3e2705563" translate="yes" xml:space="preserve">
          <source>Attempt to remove redundant extension instructions. This is especially helpful for the x86-64 architecture, which implicitly zero-extends in 64-bit registers after writing to their lower 32-bit half.</source>
          <target state="translated">중복 확장 명령을 제거하십시오. 이것은 x86-64 아키텍처에 특히 유용합니다. x86-64 아키텍처는 하위 32 비트 절반에 쓴 후 64 비트 레지스터에서 암시 적으로 0으로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="af8cd75ee0ed545b02a70bb0db32f4bb7b0a164a" translate="yes" xml:space="preserve">
          <source>Attempt to transform conditional jumps in the innermost loops to branch-less equivalents. The intent is to remove control-flow from the innermost loops in order to improve the ability of the vectorization pass to handle these loops. This is enabled by default if vectorization is enabled.</source>
          <target state="translated">가장 안쪽 루프의 조건부 점프를 분기없는 등가로 변환하려고합니다. 이러한 루프를 처리하는 벡터화 패스의 기능을 향상시키기 위해 가장 안쪽 루프에서 제어 흐름을 제거하는 것이 목적입니다. 벡터화가 활성화 된 경우 기본적으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="a82b9d3f6e114711b5045a6cdf1e499c5d11c4fa" translate="yes" xml:space="preserve">
          <source>Attempt to transform conditional jumps into branch-less equivalents. This includes use of conditional moves, min, max, set flags and abs instructions, and some tricks doable by standard arithmetics. The use of conditional execution on chips where it is available is controlled by</source>
          <target state="translated">조건부 점프를 분기없는 등가로 변환하려고합니다. 여기에는 조건부 이동, 최소, 최대, 설정 플래그 및 abs 명령어 사용과 표준 산술로 수행 할 수있는 몇 가지 트릭이 포함됩니다. 사용 가능한 칩에서 조건부 실행의 사용은 다음에 의해 제어됩니다.</target>
        </trans-unit>
        <trans-unit id="1ffd089c28cbc3f051c86ecbaa3c75b1a01df17f" translate="yes" xml:space="preserve">
          <source>Attempt to utilize both instruction sets at once. This effectively doubles the amount of available registers, and on chips with separate execution units for 387 and SSE the execution resources too. Use this option with care, as it is still experimental, because the GCC register allocator does not model separate functional units well, resulting in unstable performance.</source>
          <target state="translated">두 명령어 세트를 동시에 사용하십시오. 이것은 사용 가능한 레지스터의 양을 효과적으로 두 배로 늘리고 387에 대한 별도의 실행 단위를 가진 칩과 SSE의 실행 리소스도 효과적으로 배가시킵니다. GCC 레지스터 할당 기는 별도의 기능 단위를 제대로 모델링하지 않으므로 성능이 불안정하므로이 옵션은 아직 실험 중이므로주의해서 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="768394a0c657893c518e749955ef528cb8973c45" translate="yes" xml:space="preserve">
          <source>Attribute specifiers may be mixed with type qualifiers appearing inside the &lt;code&gt;[]&lt;/code&gt; of a parameter array declarator, in the C99 construct by which such qualifiers are applied to the pointer to which the array is implicitly converted. Such attribute specifiers apply to the pointer, not to the array, but at present this is not implemented and they are ignored.</source>
          <target state="translated">속성 한정자는 배열이 암시 적으로 변환되는 포인터에 이러한 한정자가 적용되는 C99 구문에서 매개 변수 배열 선언자 의 &lt;code&gt;[]&lt;/code&gt; 안에 나타나는 형식 한정자와 혼합 될 수 있습니다 . 이러한 속성 지정자는 배열이 아닌 포인터에 적용되지만 현재는 구현되지 않으며 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="f15f9fabc9141a4fd02709ab1f144944da1df77d" translate="yes" xml:space="preserve">
          <source>Attributes considered include &lt;code&gt;alloc_align&lt;/code&gt;, &lt;code&gt;alloc_size&lt;/code&gt;, &lt;code&gt;cold&lt;/code&gt;, &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;hot&lt;/code&gt;, &lt;code&gt;leaf&lt;/code&gt;, &lt;code&gt;malloc&lt;/code&gt;, &lt;code&gt;nonnull&lt;/code&gt;, &lt;code&gt;noreturn&lt;/code&gt;, &lt;code&gt;nothrow&lt;/code&gt;, &lt;code&gt;pure&lt;/code&gt;, &lt;code&gt;returns_nonnull&lt;/code&gt;, and &lt;code&gt;returns_twice&lt;/code&gt;.</source>
          <target state="translated">고려되는 속성에는 &lt;code&gt;alloc_align&lt;/code&gt; , &lt;code&gt;alloc_size&lt;/code&gt; , &lt;code&gt;cold&lt;/code&gt; , &lt;code&gt;const&lt;/code&gt; , &lt;code&gt;hot&lt;/code&gt; , &lt;code&gt;leaf&lt;/code&gt; , &lt;code&gt;malloc&lt;/code&gt; , &lt;code&gt;nonnull&lt;/code&gt; , &lt;code&gt;noreturn&lt;/code&gt; , &lt;code&gt;nothrow&lt;/code&gt; , &lt;code&gt;pure&lt;/code&gt; , &lt;code&gt;returns_nonnull&lt;/code&gt; 및 &lt;code&gt;returns_twice&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="1e72cecf4ee93be8444bf26683f3314180b4f20f" translate="yes" xml:space="preserve">
          <source>Augment variable location lists with progressive view numbers implied from the line number table. This enables debug information consumers to inspect state at certain points of the program, even if no instructions associated with the corresponding source locations are present at that point. If the assembler lacks support for view numbers in line number tables, this will cause the compiler to emit the line number table, which generally makes them somewhat less compact. The augmented line number tables and location lists are fully backward-compatible, so they can be consumed by debug information consumers that are not aware of these augmentations, but they won&amp;rsquo;t derive any benefit from them either.</source>
          <target state="translated">행 번호 테이블에서 암시적인 점진적 뷰 번호로 변수 위치 목록을 보강하십시오. 이를 통해 디버그 정보 소비자는 해당 소스 위치와 관련된 명령이없는 경우에도 프로그램의 특정 지점에서 상태를 검사 할 수 있습니다. 어셈블러에서 행 번호 테이블의 뷰 번호에 대한 지원이 부족한 경우 컴파일러에서 행 번호 테이블을 생성하므로 일반적으로 압축이 다소 줄어 듭니다. 기능 보강 된 행 번호 테이블 및 위치 목록은 이전 버전과 완전히 호환되므로 이러한 기능 보강을 인식하지 못하는 디버그 정보 소비자가이를 사용할 수 있지만 이들 중 어느 것도 이점을 얻지 못합니다.</target>
        </trans-unit>
        <trans-unit id="e028ddf293b9280450ea608fcf02b6afb803a5cf" translate="yes" xml:space="preserve">
          <source>Automatically convert relative source file names to absolute path names in the</source>
          <target state="translated">에서 상대 소스 파일 이름을 절대 경로 이름으로 자동 변환</target>
        </trans-unit>
        <trans-unit id="5484fc94aa2d1ceccb816e9c671bdaec50d90ef7" translate="yes" xml:space="preserve">
          <source>Average number of iterations of a loop.</source>
          <target state="translated">루프의 평균 반복 횟수입니다.</target>
        </trans-unit>
        <trans-unit id="04f04d96d845a90ad835e69c3cba86443a61a89a" translate="yes" xml:space="preserve">
          <source>Avoid or allow generating memory accesses that may not be aligned on a natural object boundary as described in the architecture specification.</source>
          <target state="translated">아키텍처 사양에 설명 된대로 자연 객체 경계에 정렬되지 않은 메모리 액세스 생성을 피하거나 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="ae4f281df5a5d0ff3cad6371f76d5c29b6d953ec" translate="yes" xml:space="preserve">
          <source>B</source>
          <target state="translated">B</target>
        </trans-unit>
        <trans-unit id="25ec48c867ed8bb8e6f96a8b43aad4372bc4578a" translate="yes" xml:space="preserve">
          <source>B register</source>
          <target state="translated">B 레지스터</target>
        </trans-unit>
        <trans-unit id="cde782be8b675144b1c3a413d952e5058ca53d38" translate="yes" xml:space="preserve">
          <source>BL</source>
          <target state="translated">BL</target>
        </trans-unit>
        <trans-unit id="7a64a2253d2959f0bf9362ab5d3438b38d98d231" translate="yes" xml:space="preserve">
          <source>BMI instructions.</source>
          <target state="translated">BMI 지침.</target>
        </trans-unit>
        <trans-unit id="a694b7ba8977f0d1b0d7c872c114539da755bd3b" translate="yes" xml:space="preserve">
          <source>BMI2 instructions.</source>
          <target state="translated">BMI2 지침.</target>
        </trans-unit>
        <trans-unit id="bfdb06081cf1ce665b573d70cc38b7b454902ff9" translate="yes" xml:space="preserve">
          <source>BRIG files (binary representation of HSAIL).</source>
          <target state="translated">BRIG 파일 (HSAIL의 이진 표현).</target>
        </trans-unit>
        <trans-unit id="089ea9746c8cbdc04b34721f820ba603e6881ff2" translate="yes" xml:space="preserve">
          <source>Base pointer register (r28&amp;ndash;r31)</source>
          <target state="translated">기본 포인터 레지스터 (r28&amp;ndash;r31)</target>
        </trans-unit>
        <trans-unit id="92f76287d800c12dfd6b51ad7e80eed03e92c213" translate="yes" xml:space="preserve">
          <source>Base::Base</source>
          <target state="translated">Base::Base</target>
        </trans-unit>
        <trans-unit id="9039faeb6333b5e373bf646f9ff036f287abc6be" translate="yes" xml:space="preserve">
          <source>Base::operator=</source>
          <target state="translated">Base::operator=</target>
        </trans-unit>
        <trans-unit id="7b3a608459615b9bc19c9d4a294c3d2c0cd4a8a0" translate="yes" xml:space="preserve">
          <source>Basic use of constraints.</source>
          <target state="translated">제약 조건의 기본 사용.</target>
        </trans-unit>
        <trans-unit id="d5770040433fcf2fed9fca7319c3ac627f6efe91" translate="yes" xml:space="preserve">
          <source>Be aware of this when performing timing tests, for instance the following loop can be completely removed, provided &lt;code&gt;some_expression&lt;/code&gt; can provably not change any global state.</source>
          <target state="translated">예를 들어 &lt;code&gt;some_expression&lt;/code&gt; 이 전역 상태를 변경할 수없는 경우 다음 루프를 완전히 제거 할 수있는 등 타이밍 테스트를 수행 할 때이 점에 유의하십시오 .</target>
        </trans-unit>
        <trans-unit id="6d4c386efa741fabb074be3b34ff11b267e4e0d7" translate="yes" xml:space="preserve">
          <source>Be aware that headers from outside your project, in particular system headers and headers from any other library you use, may not be expecting to be compiled with visibility other than the default. You may need to explicitly say &lt;code&gt;#pragma GCC visibility push(default)&lt;/code&gt; before including any such headers.</source>
          <target state="translated">프로젝트 외부의 헤더, 특히 사용하는 다른 라이브러리의 헤더 및 시스템 헤더는 기본값 이외의 가시성으로 컴파일되지 않을 수도 있습니다. 이러한 헤더를 포함하기 전에 &lt;code&gt;#pragma GCC visibility push(default)&lt;/code&gt; 를 명시 적으로 말해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b31e54ef88fe124b0da9af9ee2524cfb6800e5f0" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;__builtin_longjmp&lt;/code&gt; depends on the function return mechanism to restore the stack context, it cannot be called from the same function calling &lt;code&gt;__builtin_setjmp&lt;/code&gt; to initialize &lt;var&gt;buf&lt;/var&gt;. It can only be called from a function called (directly or indirectly) from the function calling &lt;code&gt;__builtin_setjmp&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;__builtin_longjmp&lt;/code&gt; 는 스택 컨텍스트를 복원하는 함수 반환 메커니즘에 의존 하기 때문에 &lt;var&gt;buf&lt;/var&gt; 를 초기화하기 위해 &lt;code&gt;__builtin_setjmp&lt;/code&gt; 를 호출하는 동일한 함수에서 호출 할 수 없습니다 . &lt;code&gt;__builtin_setjmp&lt;/code&gt; 를 호출하는 함수에서 (직접 또는 간접적으로) 호출 된 함수에서만 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d94ff60e2bbcd755c2d21600b1c5beacc8d88e0e" translate="yes" xml:space="preserve">
          <source>Because of the interactions between synchronization and exception handling, you can only use &lt;code&gt;@synchronized&lt;/code&gt; when compiling with exceptions enabled, that is with the command line option</source>
          <target state="translated">동기화와 예외 처리 간의 상호 작용으로 인해 예외가 활성화 된 경우 즉, 명령 줄 옵션을 사용하여 &lt;code&gt;@synchronized&lt;/code&gt; 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc31609fad1f0a543a7bf312e8fc7b4e085e75b6" translate="yes" xml:space="preserve">
          <source>Because of the special nature of the flag output operands, the constraint may not include alternatives.</source>
          <target state="translated">플래그 출력 피연산자의 특성으로 인해 제약 조건에 대체 항목이 포함되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74b7dab219d7dd89ab8e51f25903de3035d7b00a" translate="yes" xml:space="preserve">
          <source>Because of the way GCC instruments calls, a call count can be shown after a line with no individual blocks. As you can see, line 33 contains a basic block that was not executed.</source>
          <target state="translated">GCC가 통화를 계측하는 방식으로 인해 개별 블록이없는 회선 뒤에 통화 수를 표시 할 수 있습니다. 보다시피, 33 행에는 실행되지 않은 기본 블록이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba975e496f98093e5f2ea388a49453725d139a4b" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;asm&lt;/code&gt; statement unconditionally transfers control out of the function, control never reaches the end of the function body. The &lt;code&gt;__builtin_unreachable&lt;/code&gt; is in fact unreachable and communicates this fact to the compiler.</source>
          <target state="translated">때문에 &lt;code&gt;asm&lt;/code&gt; 문이 무조건 전송이 기능의 출력 제어, 제어 함수 본문의 끝에 도달하지 않습니다. &lt;code&gt;__builtin_unreachable&lt;/code&gt; 는 사실에 도달 할 수없는 컴파일러에이 사실을 전달한다.</target>
        </trans-unit>
        <trans-unit id="a314cc1449bd666eda6884b69e668c28f95c1087" translate="yes" xml:space="preserve">
          <source>Before you can use this option, you must first generate profiling information. See &lt;a href=&quot;instrumentation-options#Instrumentation-Options&quot;&gt;Instrumentation Options&lt;/a&gt;, for information about the</source>
          <target state="translated">이 옵션을 사용하려면 먼저 프로파일 링 정보를 생성해야합니다. 에 대한 정보는 &lt;a href=&quot;instrumentation-options#Instrumentation-Options&quot;&gt;계측 옵션을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5ba07a31df23960760847e555518779312499558" translate="yes" xml:space="preserve">
          <source>Below</source>
          <target state="translated">Below</target>
        </trans-unit>
        <trans-unit id="5788148d39b8d5244dcdc29f7a93a22a6334768d" translate="yes" xml:space="preserve">
          <source>Besides declarations, the file indicates, in comments, the origin of each declaration (source file and line), whether the declaration was implicit, prototyped or unprototyped (&amp;lsquo;</source>
          <target state="translated">선언 외에도 파일은 선언에서 선언이 암시 적이든 프로토 타입이든 프로토 타입이 아닌지 ( '원본 파일과 줄)의 출처를 나타냅니다 ('</target>
        </trans-unit>
        <trans-unit id="51eccbcd60621399284c614907bba67ce4fca17c" translate="yes" xml:space="preserve">
          <source>Beware that on some ELF systems this attribute is unsuitable for global functions in shared libraries with lazy binding (which is the default). Lazy binding sends the first call via resolving code in the loader, which might assume EAX, EDX and ECX can be clobbered, as per the standard calling conventions. Solaris 8 is affected by this. Systems with the GNU C Library version 2.1 or higher and FreeBSD are believed to be safe since the loaders there save EAX, EDX and ECX. (Lazy binding can be disabled with the linker or the loader if desired, to avoid the problem.)</source>
          <target state="translated">일부 ELF 시스템에서이 속성은 지연 바인딩 (기본값)이있는 공유 라이브러리의 전역 함수에 적합하지 않습니다. 지연 바인딩은 표준 호출 규칙에 따라 EAX, EDX 및 ECX가 클로버 될 수 있다고 가정 할 수있는 로더의 코드 해석을 통해 첫 번째 호출을 보냅니다. Solaris 8은이 영향을받습니다. GNU C 라이브러리 버전 2.1 이상과 FreeBSD를 갖춘 시스템은 로더가 EAX, EDX 및 ECX를 저장하므로 안전하다고 생각됩니다. (문제가 발생하지 않도록 원하는 경우 링커 또는 로더를 사용하여 지연 바인딩을 비활성화 할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="2c5d61cd9cd2849c270a6af03ebe1306ad2048ca" translate="yes" xml:space="preserve">
          <source>Binary Compatibility</source>
          <target state="translated">이진 호환성</target>
        </trans-unit>
        <trans-unit id="8668d27514898ff49d03fb634b072fd0aba7e0f7" translate="yes" xml:space="preserve">
          <source>Binary arithmetic operations.</source>
          <target state="translated">이진 산술 연산.</target>
        </trans-unit>
        <trans-unit id="18e9b92cdcd75a69e0946923d3da4f8d0a7fd71d" translate="yes" xml:space="preserve">
          <source>Binary compatibility encompasses several related concepts:</source>
          <target state="translated">이진 호환성에는 몇 가지 관련 개념이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="f8ed98dae9970ec4cee447405cb8c658f46ef706" translate="yes" xml:space="preserve">
          <source>Binary constants using the &amp;lsquo;</source>
          <target state="translated">'를 사용하는 이진 상수</target>
        </trans-unit>
        <trans-unit id="666bffac0affe44914b807024f7928a6d6ca6941" translate="yes" xml:space="preserve">
          <source>Bind references to global symbols when building a shared object. Warn about any unresolved references (unless overridden by the link editor option</source>
          <target state="translated">공유 객체를 만들 때 전역 심볼에 대한 참조를 바인딩합니다. 링크 에디터 옵션으로 오버라이드하지 않는 한, 해결되지 않은 참조에 대해 경고</target>
        </trans-unit>
        <trans-unit id="628682c1112ff8669d8fed436fe1daac74760ad6" translate="yes" xml:space="preserve">
          <source>Bit reversal. Return the result of reversing the bits in &lt;var&gt;value&lt;/var&gt;. Bit 15 is swapped with bit 0, bit 14 is swapped with bit 1, and so on.</source>
          <target state="translated">비트 반전. 비트 &lt;var&gt;value&lt;/var&gt; 을 반전 한 결과를 반환합니다 . 비트 15는 비트 0으로 교체되고 비트 14는 비트 1로 교체됩니다.</target>
        </trans-unit>
        <trans-unit id="2eb3706f981c5da19b9c626f35ee7ccc246608e1" translate="yes" xml:space="preserve">
          <source>Bitwise operators act on the representation of the value including both the sign and value bits, where the sign bit is considered immediately above the highest-value value bit. Signed &amp;lsquo;</source>
          <target state="translated">비트 연산자는 부호 비트와 값 비트를 포함하여 값의 표현에 작용합니다. 여기서 부호 비트는 최고 값 값 비트 바로 위에 간주됩니다. '서명</target>
        </trans-unit>
        <trans-unit id="8b063c3045af1663a8359f63f1ffd9a1d853789c" translate="yes" xml:space="preserve">
          <source>Blackfin family&amp;mdash;</source>
          <target state="translated">블랙 핀 가족 &amp;mdash;</target>
        </trans-unit>
        <trans-unit id="0daa776b5dad37eac562c1bddec1cfa040024e9a" translate="yes" xml:space="preserve">
          <source>Borland C++ solved the template instantiation problem by adding the code equivalent of common blocks to their linker; the compiler emits template instances in each translation unit that uses them, and the linker collapses them together. The advantage of this model is that the linker only has to consider the object files themselves; there is no external complexity to worry about. The disadvantage is that compilation time is increased because the template code is being compiled repeatedly. Code written for this model tends to include definitions of all templates in the header file, since they must be seen to be instantiated.</source>
          <target state="translated">Borland C ++는 공통 블록과 동등한 코드를 링커에 추가하여 템플릿 인스턴스화 문제를 해결했습니다. 컴파일러는이를 사용하는 각 변환 단위로 템플릿 인스턴스를 생성하고 링커는이를 축소합니다. 이 모델의 장점은 링커가 객체 파일 자체 만 고려하면된다는 것입니다. 걱정할 외부 복잡성이 없습니다. 단점은 템플릿 코드가 반복적으로 컴파일되기 때문에 컴파일 시간이 증가한다는 것입니다. 이 모델 용으로 작성된 코드는 인스턴스화되는 것으로 보여야하므로 헤더 파일에 모든 템플릿의 정의를 포함하는 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="200e3a355b82a42f3341fd59904fc5750775b807" translate="yes" xml:space="preserve">
          <source>Borland model</source>
          <target state="translated">볼랜드 모델</target>
        </trans-unit>
        <trans-unit id="06b22f59b253dcf9c37ea4fe24c6526c4dd1e47c" translate="yes" xml:space="preserve">
          <source>Both global and local variables can be associated with a register. The consequences of performing this association are very different between the two, as explained in the sections below.</source>
          <target state="translated">글로벌 변수와 로컬 변수는 모두 레지스터와 연관 될 수 있습니다. 이 연결을 수행하면 아래 섹션에서 설명하는 것처럼이 연결의 결과가 매우 다릅니다.</target>
        </trans-unit>
        <trans-unit id="fc4416d6a83edb82efd0f4cdffd08c5cd70ca428" translate="yes" xml:space="preserve">
          <source>Bound on number of candidates for induction variables, below which all candidates are considered for each use in induction variable optimizations. If there are more candidates than this, only the most relevant ones are considered to avoid quadratic time complexity.</source>
          <target state="translated">유도 변수에 대한 후보 수에 제한이 있으며,이 범위 미만에서는 유도 변수 최적화에 각 용도에 대해 모든 후보가 고려됩니다. 이보다 더 많은 후보가있는 경우, 2 차 시간 복잡성을 피하기 위해 가장 관련성이 높은 후보 만 고려됩니다.</target>
        </trans-unit>
        <trans-unit id="430f77e04bd4e8702495c79a5ebb639d2a4812c8" translate="yes" xml:space="preserve">
          <source>Bound on size of expressions used in the scalar evolutions analyzer. Large expressions slow the analyzer.</source>
          <target state="translated">스칼라 진화 분석기에서 사용되는 표현식의 크기에 제한이 있습니다. 큰 표현은 분석기를 느리게합니다.</target>
        </trans-unit>
        <trans-unit id="f0e549afa5762802ff68ea72f123883ebb295578" translate="yes" xml:space="preserve">
          <source>Bound on the complexity of the expressions in the scalar evolutions analyzer. Complex expressions slow the analyzer.</source>
          <target state="translated">스칼라 진화 분석기에서 표현의 복잡성에 바운드. 복잡한 표현은 분석기를 느리게합니다.</target>
        </trans-unit>
        <trans-unit id="c2a6a8fa6e2e8a317cd5dd66c604413295e3eb45" translate="yes" xml:space="preserve">
          <source>Bound on the cost of an expression to compute the number of iterations.</source>
          <target state="translated">반복 횟수를 계산하기 위해 식의 비용을 제한합니다.</target>
        </trans-unit>
        <trans-unit id="26981c43732b427e5b2eae3c3cb43a791d6ce820" translate="yes" xml:space="preserve">
          <source>Brain half-precision floating-point instructions. This also enables Advanced SIMD and floating-point instructions.</source>
          <target state="translated">Brain half-precision floating-point instructions. This also enables Advanced SIMD and floating-point instructions.</target>
        </trans-unit>
        <trans-unit id="ebb1b62c34f820227fd0537f593962386bf2cc61" translate="yes" xml:space="preserve">
          <source>Branch register</source>
          <target state="translated">지점 등록</target>
        </trans-unit>
        <trans-unit id="a833b9b5c7959a93636f56f73df394e8d3c434e8" translate="yes" xml:space="preserve">
          <source>Branches are present only with &lt;var&gt;-b&lt;/var&gt; option. Fields of the &lt;var&gt;line&lt;/var&gt; element have following semantics:</source>
          <target state="translated">분기에는 &lt;var&gt;-b&lt;/var&gt; 옵션 만 있습니다. &lt;var&gt;line&lt;/var&gt; 요소의 필드 는 다음과 같은 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="a6495e1aabddcd6526141ce6efe62824f5a7eae3" translate="yes" xml:space="preserve">
          <source>Brief list of all options, without explanations.</source>
          <target state="translated">설명없이 모든 옵션의 간략한 목록.</target>
        </trans-unit>
        <trans-unit id="654ffe48f6054af226250c2aa3867b5fc4c80bcc" translate="yes" xml:space="preserve">
          <source>Bugs we will fix later.</source>
          <target state="translated">나중에 고칠 버그.</target>
        </trans-unit>
        <trans-unit id="de5bfe3fd9b6538bfa34acbeb7a505866d87ffce" translate="yes" xml:space="preserve">
          <source>Build a standalone application for Core A of BF561 when using the one-application-per-core programming model. Proper start files and link scripts are used to support Core A, and the macro &lt;code&gt;__BFIN_COREA&lt;/code&gt; is defined. This option can only be used in conjunction with</source>
          <target state="translated">코어 별 단일 애플리케이션 프로그래밍 모델을 사용할 때 BF561의 코어 A에 대한 독립형 애플리케이션을 빌드하십시오. 코어 A를 지원하기 위해 올바른 시작 파일 및 링크 스크립트가 사용되며 매크로 &lt;code&gt;__BFIN_COREA&lt;/code&gt; 가 정의됩니다. 이 옵션은 다음과 함께 만 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="6320906d93f259f860a69b97e3abeb20581c59d7" translate="yes" xml:space="preserve">
          <source>Build a standalone application for Core B of BF561 when using the one-application-per-core programming model. Proper start files and link scripts are used to support Core B, and the macro &lt;code&gt;__BFIN_COREB&lt;/code&gt; is defined. When this option is used, &lt;code&gt;coreb_main&lt;/code&gt; should be used instead of &lt;code&gt;main&lt;/code&gt;. This option can only be used in conjunction with</source>
          <target state="translated">코어 별 단일 애플리케이션 프로그래밍 모델을 사용할 때 BF561의 코어 B에 대한 독립형 애플리케이션을 빌드하십시오. 코어 B를 지원하기 위해 올바른 시작 파일과 링크 스크립트가 사용되며 매크로 &lt;code&gt;__BFIN_COREB&lt;/code&gt; 가 정의됩니다. 이 옵션을 사용하면, &lt;code&gt;coreb_main&lt;/code&gt; 대신 사용해야합니다 &lt;code&gt;main&lt;/code&gt; . 이 옵션은 다음과 함께 만 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="e010c48c400b5b030ac052e6ece9a00978fee8f4" translate="yes" xml:space="preserve">
          <source>Build a standalone application for SDRAM. Proper start files and link scripts are used to put the application into SDRAM, and the macro &lt;code&gt;__BFIN_SDRAM&lt;/code&gt; is defined. The loader should initialize SDRAM before loading the application.</source>
          <target state="translated">SDRAM을위한 독립형 애플리케이션을 빌드하십시오. 올바른 시작 파일과 링크 스크립트는 응용 프로그램을 SDRAM에 넣는 데 사용되며 매크로 &lt;code&gt;__BFIN_SDRAM&lt;/code&gt; 이 정의됩니다. 로더는 애플리케이션을로드하기 전에 SDRAM을 초기화해야합니다.</target>
        </trans-unit>
        <trans-unit id="93828509d9639cf155e61322b59daf0187eb136a" translate="yes" xml:space="preserve">
          <source>Build a standalone application for multicore Blackfin processors. This option causes proper start files and link scripts supporting multicore to be used, and defines the macro &lt;code&gt;__BFIN_MULTICORE&lt;/code&gt;. It can only be used with</source>
          <target state="translated">멀티 코어 Blackfin 프로세서를위한 독립형 애플리케이션을 구축하십시오. 이 옵션을 사용하면 멀티 코어를 지원하는 올바른 시작 파일과 링크 스크립트가 사용되고 &lt;code&gt;__BFIN_MULTICORE&lt;/code&gt; 매크로를 정의합니다 . 함께 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="f3ef0f891e9c255998243907e244b5b488c698cb" translate="yes" xml:space="preserve">
          <source>Build-in macro that resolves to a decimal number that identifies the architecture and depends on the</source>
          <target state="translated">아키텍처를 식별하는 10 진수로 해석되는 내장 매크로</target>
        </trans-unit>
        <trans-unit id="2d34970179e2bcbb0ecc79b090b87f98043678d3" translate="yes" xml:space="preserve">
          <source>Building data dependencies is expensive for very large loops. This parameter limits the number of data references in loops that are considered for data dependence analysis. These large loops are no handled by the optimizations using loop data dependencies.</source>
          <target state="translated">데이터 종속성을 구축하는 것은 매우 큰 루프에 비용이 많이 듭니다. 이 매개 변수는 데이터 종속성 분석에 고려되는 루프의 데이터 참조 수를 제한합니다. 이러한 큰 루프는 루프 데이터 종속성을 사용하는 최적화에 의해 처리되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2d296efa2545fd43e5ab712c86bbcd120531a39c" translate="yes" xml:space="preserve">
          <source>Built-in Function:  &lt;strong id=&quot;index-_005f_005fbuiltin_005fva_005farg_005fpack&quot;&gt;__builtin_va_arg_pack&lt;/strong&gt; ()</source>
          <target state="translated">내장 함수 : &lt;strong id=&quot;index-_005f_005fbuiltin_005fva_005farg_005fpack&quot;&gt;__builtin_va_arg_pack&lt;/strong&gt; ()</target>
        </trans-unit>
        <trans-unit id="77cea55a1a3d5467f8414836cb770a0b2fa5b655" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005fadd_005ffetch&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_add_fetch&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">내장 함수 : &lt;strong&gt;__atomic_add_fetch &lt;/strong&gt; &lt;var id=&quot;index-_005f_005fatomic_005fadd_005ffetch&quot;&gt;type&lt;/var&gt; ( &lt;var&gt;type&lt;/var&gt; * ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="65f1c3be3667c2fa06bb169c518b6d4d03675142" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005fand_005ffetch&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_and_fetch&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">내장 함수 : &lt;var id=&quot;index-_005f_005fatomic_005fand_005ffetch&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_and_fetch&lt;/strong&gt; ( &lt;var&gt;type&lt;/var&gt; * ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</target>
        </trans-unit>
        <trans-unit id="a03055a0cd281ae02bbb4f07ca3c585700a7af0b" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005fexchange_005fn&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_exchange_n&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">내장 함수 : &lt;strong&gt;__atomic_exchange_n &lt;/strong&gt; &lt;var id=&quot;index-_005f_005fatomic_005fexchange_005fn&quot;&gt;type&lt;/var&gt; ( &lt;var&gt;type&lt;/var&gt; * ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6eb648ab26ef838877bc3cc4ee57b8ff3c3ec10d" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005fadd&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_fetch_add&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">내장 기능 : &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005fadd&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_fetch_add&lt;/strong&gt; ( &lt;var&gt;type&lt;/var&gt; * PTR, &lt;var&gt;type&lt;/var&gt; 발, INT의 memorder)</target>
        </trans-unit>
        <trans-unit id="caf737dd7d0b652a623f88bdd6fd64fcd63596e4" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005fand&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_fetch_and&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">내장 기능 : &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005fand&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_fetch_and&lt;/strong&gt; ( &lt;var&gt;type&lt;/var&gt; * PTR, &lt;var&gt;type&lt;/var&gt; 발, INT의 memorder)</target>
        </trans-unit>
        <trans-unit id="f9b1604908ceaddf5e7b79ba9db81f0f1c23485e" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005fnand&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_fetch_nand&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">내장 기능 : &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005fnand&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_fetch_nand&lt;/strong&gt; ( &lt;var&gt;type&lt;/var&gt; * PTR, &lt;var&gt;type&lt;/var&gt; 발, INT의 memorder)</target>
        </trans-unit>
        <trans-unit id="45f4365ebf0124211f5cb2705e77bd2bfd90775d" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005for&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_fetch_or&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">내장 기능 : &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005for&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_fetch_or&lt;/strong&gt; ( &lt;var&gt;type&lt;/var&gt; * PTR, &lt;var&gt;type&lt;/var&gt; 발, INT의 memorder)</target>
        </trans-unit>
        <trans-unit id="cf646256d882577bfba56a5678e5b9426274e60b" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005fsub&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_fetch_sub&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">내장 기능 : &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005fsub&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_fetch_sub&lt;/strong&gt; ( &lt;var&gt;type&lt;/var&gt; * PTR, &lt;var&gt;type&lt;/var&gt; 발, INT memorder를)</target>
        </trans-unit>
        <trans-unit id="5041b1cf8f3a6577d287aff4388265cba990c15b" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005fxor&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_fetch_xor&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">내장 기능 : &lt;var id=&quot;index-_005f_005fatomic_005ffetch_005fxor&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_fetch_xor&lt;/strong&gt; ( &lt;var&gt;type&lt;/var&gt; * PTR, &lt;var&gt;type&lt;/var&gt; 발, INT의 memorder)</target>
        </trans-unit>
        <trans-unit id="75268ab0697eb9af1dc5c6b541d4d1ba8ac4dbf6" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005fload_005fn&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_load_n&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, int memorder)</source>
          <target state="translated">내장 기능 : &lt;var id=&quot;index-_005f_005fatomic_005fload_005fn&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_load_n&lt;/strong&gt; ( &lt;var&gt;type&lt;/var&gt; * PTR, INT의 memorder)</target>
        </trans-unit>
        <trans-unit id="cd00e4ef24b741036ea643da78829d2849f8f8d7" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005fnand_005ffetch&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_nand_fetch&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">내장 함수 : &lt;var id=&quot;index-_005f_005fatomic_005fnand_005ffetch&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_nand_fetch&lt;/strong&gt; ( &lt;var&gt;type&lt;/var&gt; * ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</target>
        </trans-unit>
        <trans-unit id="a4657eb44924236cf67282c47ad4d932f5594137" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005for_005ffetch&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_or_fetch&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">내장 기능 : &lt;var id=&quot;index-_005f_005fatomic_005for_005ffetch&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_or_fetch&lt;/strong&gt; ( &lt;var&gt;type&lt;/var&gt; * PTR, &lt;var&gt;type&lt;/var&gt; 발, INT memorder를)</target>
        </trans-unit>
        <trans-unit id="57b4ecf7d291340ab5ae6cc114b7f02d58e8a705" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005fsub_005ffetch&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_sub_fetch&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">내장 함수 : &lt;var id=&quot;index-_005f_005fatomic_005fsub_005ffetch&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_sub_fetch&lt;/strong&gt; ( &lt;var&gt;type&lt;/var&gt; * ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</target>
        </trans-unit>
        <trans-unit id="a52f64419e32735eabc4e3c18aa68dedfb2e4625" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fatomic_005fxor_005ffetch&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__atomic_xor_fetch&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">내장 함수 : &lt;var id=&quot;index-_005f_005fatomic_005fxor_005ffetch&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__atomic_xor_fetch&lt;/strong&gt; ( &lt;var&gt;type&lt;/var&gt; * ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</target>
        </trans-unit>
        <trans-unit id="1167cb7b44d7d9f620598ea0aefcbfdf9dc55a1f" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fbuiltin_005fcall_005fwith_005fstatic_005fchain-1&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__builtin_call_with_static_chain&lt;/strong&gt; (&lt;var&gt;call_exp&lt;/var&gt;, &lt;var&gt;pointer_exp&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : &lt;strong&gt;__builtin_call_with_static_chain&lt;/strong&gt; ( &lt;var&gt;call_exp&lt;/var&gt; , &lt;var&gt;pointer_exp&lt;/var&gt; ) &lt;var id=&quot;index-_005f_005fbuiltin_005fcall_005fwith_005fstatic_005fchain-1&quot;&gt;type&lt;/var&gt; &lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="34f799a7c8358da11b0de0991867b1ca62dd416b" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fbuiltin_005fchoose_005fexpr&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__builtin_choose_expr&lt;/strong&gt; (&lt;var&gt;const_exp&lt;/var&gt;, &lt;var&gt;exp1&lt;/var&gt;, &lt;var&gt;exp2&lt;/var&gt;)</source>
          <target state="translated">내장 기능 : &lt;var id=&quot;index-_005f_005fbuiltin_005fchoose_005fexpr&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__builtin_choose_expr&lt;/strong&gt; ( &lt;var&gt;const_exp&lt;/var&gt; , &lt;var&gt;exp1&lt;/var&gt; , &lt;var&gt;exp2&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="11e363a3b892d8f6c1c1fdfdd845f80862a3606b" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fbuiltin_005fcomplex&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__builtin_complex&lt;/strong&gt; (&lt;var&gt;real&lt;/var&gt;, &lt;var&gt;imag&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : &lt;strong&gt;__builtin_complex&lt;/strong&gt; ( &lt;var&gt;real&lt;/var&gt; , &lt;var&gt;imag&lt;/var&gt; ) &lt;var id=&quot;index-_005f_005fbuiltin_005fcomplex&quot;&gt;type&lt;/var&gt; &lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9eec0865162048e6dccab85fb3d740aa5f07fc05" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fbuiltin_005fspeculation_005fsafe_005fvalue-1&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__builtin_speculation_safe_value&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; val, &lt;var&gt;type&lt;/var&gt; failval)</source>
          <target state="translated">내장 기능 : &lt;var id=&quot;index-_005f_005fbuiltin_005fspeculation_005fsafe_005fvalue-1&quot;&gt;type&lt;/var&gt; &lt;strong&gt;__builtin_speculation_safe_value&lt;/strong&gt; ( &lt;var&gt;type&lt;/var&gt; 발, &lt;var&gt;type&lt;/var&gt; failval)</target>
        </trans-unit>
        <trans-unit id="7c5c7616bd765dd4fc8d843ce99908ad16336f51" translate="yes" xml:space="preserve">
          <source>Built-in Function: &lt;var id=&quot;index-_005f_005fbuiltin_005ftgmath&quot;&gt;type&lt;/var&gt;&lt;strong&gt;__builtin_tgmath&lt;/strong&gt; (&lt;var&gt;functions&lt;/var&gt;, &lt;var&gt;arguments&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : &lt;strong&gt;__builtin_tgmath &lt;/strong&gt; &lt;var id=&quot;index-_005f_005fbuiltin_005ftgmath&quot;&gt;type&lt;/var&gt; ( &lt;var&gt;functions&lt;/var&gt; , &lt;var&gt;arguments&lt;/var&gt; )&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e3600affbf40f82a1f599528ce0f72402f629874" translate="yes" xml:space="preserve">
          <source>Built-in Function: Pmode &lt;strong id=&quot;index-_005f_005fbuiltin_005fextend_005fpointer-1&quot;&gt;__builtin_extend_pointer&lt;/strong&gt; (void * x)</source>
          <target state="translated">내장 함수 : Pmode &lt;strong id=&quot;index-_005f_005fbuiltin_005fextend_005fpointer-1&quot;&gt;__builtin_extend_pointer&lt;/strong&gt; (void * x)</target>
        </trans-unit>
        <trans-unit id="b7ca6e3021fea0b720388d29d28e89de6177efaa" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Decimal128 &lt;strong id=&quot;index-_005f_005fbuiltin_005finfd128&quot;&gt;__builtin_infd128&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : _Decimal128 &lt;strong id=&quot;index-_005f_005fbuiltin_005finfd128&quot;&gt;__builtin_infd128&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="bf8fbba0296cd046f79b2f8fac454e9f96b680c3" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Decimal128 &lt;strong id=&quot;index-_005f_005fbuiltin_005fnand128&quot;&gt;__builtin_nand128&lt;/strong&gt; (const char *str)</source>
          <target state="translated">내장 함수 : _Decimal128 &lt;strong id=&quot;index-_005f_005fbuiltin_005fnand128&quot;&gt;__builtin_nand128&lt;/strong&gt; (const char * str)</target>
        </trans-unit>
        <trans-unit id="ad3f5c8f497e0e257636ccbaf6459ad1ad8e6479" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Decimal32 &lt;strong id=&quot;index-_005f_005fbuiltin_005finfd32&quot;&gt;__builtin_infd32&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : _Decimal32 &lt;strong id=&quot;index-_005f_005fbuiltin_005finfd32&quot;&gt;__builtin_infd32&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="2d12b2517571e9887a8920d94ebf233b53b0d3e9" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Decimal32 &lt;strong id=&quot;index-_005f_005fbuiltin_005fnand32&quot;&gt;__builtin_nand32&lt;/strong&gt; (const char *str)</source>
          <target state="translated">내장 함수 : _Decimal32 &lt;strong id=&quot;index-_005f_005fbuiltin_005fnand32&quot;&gt;__builtin_nand32&lt;/strong&gt; (const char * str)</target>
        </trans-unit>
        <trans-unit id="c4f59dbda6a0f6f12e013b7d8146bb95b52fddbf" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Decimal64 &lt;strong id=&quot;index-_005f_005fbuiltin_005finfd64&quot;&gt;__builtin_infd64&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : _Decimal64 &lt;strong id=&quot;index-_005f_005fbuiltin_005finfd64&quot;&gt;__builtin_infd64&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="dcf12c95c5e2671a78a61f716ad8c91e6ab3dca2" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Decimal64 &lt;strong id=&quot;index-_005f_005fbuiltin_005fnand64&quot;&gt;__builtin_nand64&lt;/strong&gt; (const char *str)</source>
          <target state="translated">내장 함수 : _Decimal64 &lt;strong id=&quot;index-_005f_005fbuiltin_005fnand64&quot;&gt;__builtin_nand64&lt;/strong&gt; (const char * str)</target>
        </trans-unit>
        <trans-unit id="e065d1bdd11d40eb46afaa76c7e3c275e0e7c656" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Float&lt;var id=&quot;index-_005f_005fbuiltin_005fhuge_005fvalfn&quot;&gt;n&lt;/var&gt;&lt;strong&gt;__builtin_huge_valf&lt;var&gt;n&lt;/var&gt;&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : _Float &lt;var id=&quot;index-_005f_005fbuiltin_005fhuge_005fvalfn&quot;&gt;n&lt;/var&gt; &lt;strong&gt;__builtin_huge_valf &lt;var&gt;n&lt;/var&gt; &lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="bc1ad27f368302d827ffdedc2f161e1a34576916" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Float&lt;var id=&quot;index-_005f_005fbuiltin_005fhuge_005fvalfnx&quot;&gt;n&lt;/var&gt;x &lt;strong&gt;__builtin_huge_valf&lt;var&gt;n&lt;/var&gt;x&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : _Float &lt;var id=&quot;index-_005f_005fbuiltin_005fhuge_005fvalfnx&quot;&gt;n&lt;/var&gt; x &lt;strong&gt;__builtin_huge_valf &lt;var&gt;n&lt;/var&gt; x&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="4f4a5dc00bc657abe7ad80938a7d60c8e79b5015" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Float&lt;var id=&quot;index-_005f_005fbuiltin_005finffn&quot;&gt;n&lt;/var&gt;&lt;strong&gt;__builtin_inff&lt;var&gt;n&lt;/var&gt;&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : _Float &lt;var id=&quot;index-_005f_005fbuiltin_005finffn&quot;&gt;n&lt;/var&gt; &lt;strong&gt;__builtin_inff &lt;var&gt;n&lt;/var&gt; &lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="28b60d24ae373b1240786dec7b198434f539e010" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Float&lt;var id=&quot;index-_005f_005fbuiltin_005finffnx&quot;&gt;n&lt;/var&gt;&lt;strong&gt;__builtin_inff&lt;var&gt;n&lt;/var&gt;x&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : _Float &lt;var id=&quot;index-_005f_005fbuiltin_005finffnx&quot;&gt;n&lt;/var&gt; &lt;strong&gt;__builtin_inff &lt;var&gt;n&lt;/var&gt; x&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="bf9f5f175d78dc2baeeae0348c4b4da7826acad2" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Float&lt;var id=&quot;index-_005f_005fbuiltin_005fnanfn&quot;&gt;n&lt;/var&gt;&lt;strong&gt;__builtin_nanf&lt;var&gt;n&lt;/var&gt;&lt;/strong&gt; (const char *str)</source>
          <target state="translated">내장 함수 : _Float &lt;var id=&quot;index-_005f_005fbuiltin_005fnanfn&quot;&gt;n&lt;/var&gt; &lt;strong&gt;__builtin_nanf &lt;var&gt;n&lt;/var&gt; &lt;/strong&gt; (const char * str)</target>
        </trans-unit>
        <trans-unit id="d8897a35cb1a3842c5a7b59ff4525f61eb36974a" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Float&lt;var id=&quot;index-_005f_005fbuiltin_005fnanfnx&quot;&gt;n&lt;/var&gt;x &lt;strong&gt;__builtin_nanf&lt;var&gt;n&lt;/var&gt;x&lt;/strong&gt; (const char *str)</source>
          <target state="translated">내장 함수 : _Float &lt;var id=&quot;index-_005f_005fbuiltin_005fnanfnx&quot;&gt;n&lt;/var&gt; x &lt;strong&gt;__builtin_nanf &lt;var&gt;n&lt;/var&gt; x&lt;/strong&gt; (const char * str)</target>
        </trans-unit>
        <trans-unit id="1bd15fd91da1a9d9a87216c52e010f17bc3d22e6" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Float&lt;var id=&quot;index-_005f_005fbuiltin_005fnansfn&quot;&gt;n&lt;/var&gt;&lt;strong&gt;__builtin_nansf&lt;var&gt;n&lt;/var&gt;&lt;/strong&gt; (const char *str)</source>
          <target state="translated">내장 함수 : _Float &lt;var id=&quot;index-_005f_005fbuiltin_005fnansfn&quot;&gt;n&lt;/var&gt; &lt;strong&gt;__builtin_nansf &lt;var&gt;n&lt;/var&gt; &lt;/strong&gt; (const char * str)</target>
        </trans-unit>
        <trans-unit id="615e03fdb9ea794729a2a1d7c358b1e301921c3b" translate="yes" xml:space="preserve">
          <source>Built-in Function: _Float&lt;var id=&quot;index-_005f_005fbuiltin_005fnansfnx&quot;&gt;n&lt;/var&gt;x &lt;strong&gt;__builtin_nansf&lt;var&gt;n&lt;/var&gt;x&lt;/strong&gt; (const char *str)</source>
          <target state="translated">내장 함수 : _Float &lt;var id=&quot;index-_005f_005fbuiltin_005fnansfnx&quot;&gt;n&lt;/var&gt; x &lt;strong&gt;__builtin_nansf &lt;var&gt;n&lt;/var&gt; x&lt;/strong&gt; (const char * str)</target>
        </trans-unit>
        <trans-unit id="f520d1247e2979f87ba6e5662e70795dbd438963" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fatomic_005falways_005flock_005ffree&quot;&gt;__atomic_always_lock_free&lt;/strong&gt; (size_t size, void *ptr)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fatomic_005falways_005flock_005ffree&quot;&gt;__atomic_always_lock_free&lt;/strong&gt; (size_t 크기, void * ptr)</target>
        </trans-unit>
        <trans-unit id="24b1fe88fa6197e2c0740249ab472fde949dc447" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fatomic_005fcompare_005fexchange&quot;&gt;__atomic_compare_exchange&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; *expected, &lt;var&gt;type&lt;/var&gt; *desired, bool weak, int success_memorder, int failure_memorder)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fatomic_005fcompare_005fexchange&quot;&gt;__atomic_compare_exchange&lt;/strong&gt; ( &lt;var&gt;type&lt;/var&gt; * ptr, &lt;var&gt;type&lt;/var&gt; * 예상, &lt;var&gt;type&lt;/var&gt; * 희망, 부울 약함, int success_memorder, int failure_memorder)</target>
        </trans-unit>
        <trans-unit id="e0cae369ba572d6fc730f1208ec5ebfd8c31b5c9" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fatomic_005fcompare_005fexchange_005fn&quot;&gt;__atomic_compare_exchange_n&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; *expected, &lt;var&gt;type&lt;/var&gt; desired, bool weak, int success_memorder, int failure_memorder)</source>
          <target state="translated">내장 함수 : 부울 &lt;strong id=&quot;index-_005f_005fatomic_005fcompare_005fexchange_005fn&quot;&gt;__atomic_compare_exchange_n&lt;/strong&gt; ( &lt;var&gt;type&lt;/var&gt; * PTR, &lt;var&gt;type&lt;/var&gt; * 예상 &lt;var&gt;type&lt;/var&gt; 원하는 약한, INT success_memorder을 bool에, INT failure_memorder)</target>
        </trans-unit>
        <trans-unit id="e6ff9b335ec817f16bd5f09bc44d64b4868726b1" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fatomic_005fis_005flock_005ffree&quot;&gt;__atomic_is_lock_free&lt;/strong&gt; (size_t size, void *ptr)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fatomic_005fis_005flock_005ffree&quot;&gt;__atomic_is_lock_free&lt;/strong&gt; (size_t 크기, void * ptr)</target>
        </trans-unit>
        <trans-unit id="24aee6114b477fd331dab8c2aef844fb97f49851" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fatomic_005ftest_005fand_005fset&quot;&gt;__atomic_test_and_set&lt;/strong&gt; (void *ptr, int memorder)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fatomic_005ftest_005fand_005fset&quot;&gt;__atomic_test_and_set&lt;/strong&gt; (void * ptr, int memorder)</target>
        </trans-unit>
        <trans-unit id="64b8a4ae04512641547c12a9c73d39675cb460a9" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fadd_005foverflow&quot;&gt;__builtin_add_overflow&lt;/strong&gt; (&lt;var&gt;type1&lt;/var&gt; a, &lt;var&gt;type2&lt;/var&gt; b, &lt;var&gt;type3&lt;/var&gt; *res)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fadd_005foverflow&quot;&gt;__builtin_add_overflow&lt;/strong&gt; ( &lt;var&gt;type1&lt;/var&gt; a, &lt;var&gt;type2&lt;/var&gt; b, &lt;var&gt;type3&lt;/var&gt; * res)</target>
        </trans-unit>
        <trans-unit id="af59554b89a8bf55a3dc48af48346f20f06e852a" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fadd_005foverflow_005fp&quot;&gt;__builtin_add_overflow_p&lt;/strong&gt; (&lt;var&gt;type1&lt;/var&gt; a, &lt;var&gt;type2&lt;/var&gt; b, &lt;var&gt;type3&lt;/var&gt; c)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fadd_005foverflow_005fp&quot;&gt;__builtin_add_overflow_p&lt;/strong&gt; ( &lt;var&gt;type1&lt;/var&gt; a, &lt;var&gt;type2&lt;/var&gt; b, &lt;var&gt;type3&lt;/var&gt; c)</target>
        </trans-unit>
        <trans-unit id="be98828c48e0d16aa6b6e2421edf84970dc86a6f" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fhas_005fattribute-1&quot;&gt;__builtin_has_attribute&lt;/strong&gt; (&lt;var&gt;type-or-expression&lt;/var&gt;, &lt;var&gt;attribute&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fhas_005fattribute-1&quot;&gt;__builtin_has_attribute&lt;/strong&gt; ( &lt;var&gt;type-or-expression&lt;/var&gt; , &lt;var&gt;attribute&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="b7e50b8a64da2b188793a4579bb5cae5cac82268" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fis_005fconstant_005fevaluated&quot;&gt;__builtin_is_constant_evaluated&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fis_005fconstant_005fevaluated&quot;&gt;__builtin_is_constant_evaluated&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="ee9d3aabacf2156e5d393cd93749ff7c8037d66e" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fmul_005foverflow&quot;&gt;__builtin_mul_overflow&lt;/strong&gt; (&lt;var&gt;type1&lt;/var&gt; a, &lt;var&gt;type2&lt;/var&gt; b, &lt;var&gt;type3&lt;/var&gt; *res)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fmul_005foverflow&quot;&gt;__builtin_mul_overflow&lt;/strong&gt; ( &lt;var&gt;type1&lt;/var&gt; a, &lt;var&gt;type2&lt;/var&gt; b, &lt;var&gt;type3&lt;/var&gt; * res)</target>
        </trans-unit>
        <trans-unit id="8fd735437fc9239fd342fe45001594bf9731cdde" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fmul_005foverflow_005fp&quot;&gt;__builtin_mul_overflow_p&lt;/strong&gt; (&lt;var&gt;type1&lt;/var&gt; a, &lt;var&gt;type2&lt;/var&gt; b, &lt;var&gt;type3&lt;/var&gt; c)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fmul_005foverflow_005fp&quot;&gt;__builtin_mul_overflow_p&lt;/strong&gt; ( &lt;var&gt;type1&lt;/var&gt; a, &lt;var&gt;type2&lt;/var&gt; b, &lt;var&gt;type3&lt;/var&gt; c)</target>
        </trans-unit>
        <trans-unit id="25ee4265411f06ce5b584d4448bc72ef70be2921" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsadd_005foverflow&quot;&gt;__builtin_sadd_overflow&lt;/strong&gt; (int a, int b, int *res)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsadd_005foverflow&quot;&gt;__builtin_sadd_overflow&lt;/strong&gt; (int a, int b, int * res)</target>
        </trans-unit>
        <trans-unit id="69472084a70d9c551110645ab2de32722f859a56" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsaddl_005foverflow&quot;&gt;__builtin_saddl_overflow&lt;/strong&gt; (long int a, long int b, long int *res)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsaddl_005foverflow&quot;&gt;__builtin_saddl_overflow&lt;/strong&gt; (long int a, long int b, long int * res)</target>
        </trans-unit>
        <trans-unit id="d167da624174d67a584837afb39ffafce3529192" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsaddll_005foverflow&quot;&gt;__builtin_saddll_overflow&lt;/strong&gt; (long long int a, long long int b, long long int *res)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsaddll_005foverflow&quot;&gt;__builtin_saddll_overflow&lt;/strong&gt; (long long int a, long long int b, long long int * res)</target>
        </trans-unit>
        <trans-unit id="0751d990e1a6176428723a69b8b9d35eb80fd837" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsmul_005foverflow&quot;&gt;__builtin_smul_overflow&lt;/strong&gt; (int a, int b, int *res)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsmul_005foverflow&quot;&gt;__builtin_smul_overflow&lt;/strong&gt; (int a, int b, int * res)</target>
        </trans-unit>
        <trans-unit id="956b1e662b4c40d70010047e2d0274713e3963f3" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsmull_005foverflow&quot;&gt;__builtin_smull_overflow&lt;/strong&gt; (long int a, long int b, long int *res)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsmull_005foverflow&quot;&gt;__builtin_smull_overflow&lt;/strong&gt; (long int a, long int b, long int * res)</target>
        </trans-unit>
        <trans-unit id="90b14c01667b17099ca43e693ecf1b190d3e0c9b" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsmulll_005foverflow&quot;&gt;__builtin_smulll_overflow&lt;/strong&gt; (long long int a, long long int b, long long int *res)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsmulll_005foverflow&quot;&gt;__builtin_smulll_overflow&lt;/strong&gt; (long long int a, long long int b, long long int * res)</target>
        </trans-unit>
        <trans-unit id="77b2f488874750806435b3aaff4f191420925191" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fssub_005foverflow&quot;&gt;__builtin_ssub_overflow&lt;/strong&gt; (int a, int b, int *res)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fssub_005foverflow&quot;&gt;__builtin_ssub_overflow&lt;/strong&gt; (int a, int b, int * res)</target>
        </trans-unit>
        <trans-unit id="49724eb9cf1b5f433d9a763058afdd03539a15c8" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fssubl_005foverflow&quot;&gt;__builtin_ssubl_overflow&lt;/strong&gt; (long int a, long int b, long int *res)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fssubl_005foverflow&quot;&gt;__builtin_ssubl_overflow&lt;/strong&gt; (long int a, long int b, long int * res)</target>
        </trans-unit>
        <trans-unit id="8bb17f1956b296109f50ac2e4c7c8a50ec613924" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fssubll_005foverflow&quot;&gt;__builtin_ssubll_overflow&lt;/strong&gt; (long long int a, long long int b, long long int *res)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fssubll_005foverflow&quot;&gt;__builtin_ssubll_overflow&lt;/strong&gt; (long long int a, long long int b, long long int * res)</target>
        </trans-unit>
        <trans-unit id="3ca0d6297a605dc41e2b859a3577a44be6641a95" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsub_005foverflow&quot;&gt;__builtin_sub_overflow&lt;/strong&gt; (&lt;var&gt;type1&lt;/var&gt; a, &lt;var&gt;type2&lt;/var&gt; b, &lt;var&gt;type3&lt;/var&gt; *res)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsub_005foverflow&quot;&gt;__builtin_sub_overflow&lt;/strong&gt; ( &lt;var&gt;type1&lt;/var&gt; a, &lt;var&gt;type2&lt;/var&gt; b, &lt;var&gt;type3&lt;/var&gt; * res)</target>
        </trans-unit>
        <trans-unit id="cc3ccbf74e07a994d7fa1a99c72273b8a5afff58" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsub_005foverflow_005fp&quot;&gt;__builtin_sub_overflow_p&lt;/strong&gt; (&lt;var&gt;type1&lt;/var&gt; a, &lt;var&gt;type2&lt;/var&gt; b, &lt;var&gt;type3&lt;/var&gt; c)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fsub_005foverflow_005fp&quot;&gt;__builtin_sub_overflow_p&lt;/strong&gt; ( &lt;var&gt;type1&lt;/var&gt; a, &lt;var&gt;type2&lt;/var&gt; b, &lt;var&gt;type3&lt;/var&gt; c)</target>
        </trans-unit>
        <trans-unit id="5b02b9649ef1800e43226f7e7109d8bbef8357dc" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fuadd_005foverflow&quot;&gt;__builtin_uadd_overflow&lt;/strong&gt; (unsigned int a, unsigned int b, unsigned int *res)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fuadd_005foverflow&quot;&gt;__builtin_uadd_overflow&lt;/strong&gt; (부호없는 int a, 부호없는 int b, 부호없는 int * res)</target>
        </trans-unit>
        <trans-unit id="567411aa095944ed062923c573393ad7b9494fcc" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fuaddl_005foverflow&quot;&gt;__builtin_uaddl_overflow&lt;/strong&gt; (unsigned long int a, unsigned long int b, unsigned long int *res)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fuaddl_005foverflow&quot;&gt;__builtin_uaddl_overflow&lt;/strong&gt; (부호없는 long int a, 부호없는 long int b, 부호없는 long int * res)</target>
        </trans-unit>
        <trans-unit id="a7d580478c24cd4b2a59ce2c1f75d3bbd1e01675" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fuaddll_005foverflow&quot;&gt;__builtin_uaddll_overflow&lt;/strong&gt; (unsigned long long int a, unsigned long long int b, unsigned long long int *res)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fuaddll_005foverflow&quot;&gt;__builtin_uaddll_overflow&lt;/strong&gt; (부호없는 long long int a, 부호없는 long long int b, 부호없는 long long int * res)</target>
        </trans-unit>
        <trans-unit id="4df720b89a79aa504ee2325733fecf62f5d154df" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fumul_005foverflow&quot;&gt;__builtin_umul_overflow&lt;/strong&gt; (unsigned int a, unsigned int b, unsigned int *res)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fumul_005foverflow&quot;&gt;__builtin_umul_overflow&lt;/strong&gt; (부호없는 int a, 부호없는 int b, 부호없는 int * res)</target>
        </trans-unit>
        <trans-unit id="127b7aa724932fc0c15543b161cf5ca336f40c65" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fumull_005foverflow&quot;&gt;__builtin_umull_overflow&lt;/strong&gt; (unsigned long int a, unsigned long int b, unsigned long int *res)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fumull_005foverflow&quot;&gt;__builtin_umull_overflow&lt;/strong&gt; (부호없는 long int a, 부호없는 long int b, 부호없는 long int * res)</target>
        </trans-unit>
        <trans-unit id="6e0e5de085f1421cd056a7b7c2d1ac4593a791e8" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fumulll_005foverflow&quot;&gt;__builtin_umulll_overflow&lt;/strong&gt; (unsigned long long int a, unsigned long long int b, unsigned long long int *res)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fumulll_005foverflow&quot;&gt;__builtin_umulll_overflow&lt;/strong&gt; (부호없는 long long int a, 부호없는 long long int b, 부호없는 long long int * res)</target>
        </trans-unit>
        <trans-unit id="43f0099aa9a654a142bfe318e5e28643d8ddc6f6" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fusub_005foverflow&quot;&gt;__builtin_usub_overflow&lt;/strong&gt; (unsigned int a, unsigned int b, unsigned int *res)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fusub_005foverflow&quot;&gt;__builtin_usub_overflow&lt;/strong&gt; (부호없는 int a, 부호없는 int b, 부호없는 int * res)</target>
        </trans-unit>
        <trans-unit id="1c5542c5653c759c2ffcd0eb56e8e4fce2653611" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fusubl_005foverflow&quot;&gt;__builtin_usubl_overflow&lt;/strong&gt; (unsigned long int a, unsigned long int b, unsigned long int *res)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fusubl_005foverflow&quot;&gt;__builtin_usubl_overflow&lt;/strong&gt; (부호없는 long int a, 부호없는 long int b, 부호없는 long int * res)</target>
        </trans-unit>
        <trans-unit id="8967205f7b6c405e734e918e4030fc20dcc7a6e8" translate="yes" xml:space="preserve">
          <source>Built-in Function: bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fusubll_005foverflow&quot;&gt;__builtin_usubll_overflow&lt;/strong&gt; (unsigned long long int a, unsigned long long int b, unsigned long long int *res)</source>
          <target state="translated">내장 함수 : bool &lt;strong id=&quot;index-_005f_005fbuiltin_005fusubll_005foverflow&quot;&gt;__builtin_usubll_overflow&lt;/strong&gt; (부호없는 long long int a, 부호없는 long long int b, 부호없는 long long int * res)</target>
        </trans-unit>
        <trans-unit id="3d3ebe01d55449070f5b00bc45933b6ab0472f70" translate="yes" xml:space="preserve">
          <source>Built-in Function: const char * &lt;strong id=&quot;index-_005f_005fbuiltin_005fFILE&quot;&gt;__builtin_FILE&lt;/strong&gt; ()</source>
          <target state="translated">내장 함수 : const char * &lt;strong id=&quot;index-_005f_005fbuiltin_005fFILE&quot;&gt;__builtin_FILE&lt;/strong&gt; ()</target>
        </trans-unit>
        <trans-unit id="0721ec3a797458f28da3b2711e9fc2d2af1823e2" translate="yes" xml:space="preserve">
          <source>Built-in Function: const char * &lt;strong id=&quot;index-_005f_005fbuiltin_005fFUNCTION&quot;&gt;__builtin_FUNCTION&lt;/strong&gt; ()</source>
          <target state="translated">내장 함수 : const char * &lt;strong id=&quot;index-_005f_005fbuiltin_005fFUNCTION&quot;&gt;__builtin_FUNCTION&lt;/strong&gt; ()</target>
        </trans-unit>
        <trans-unit id="2a1712d1ad359c0cac12cd7a3537116bd9e795fc" translate="yes" xml:space="preserve">
          <source>Built-in Function: double &lt;strong id=&quot;index-_005f_005fbuiltin_005fhuge_005fval&quot;&gt;__builtin_huge_val&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : double &lt;strong id=&quot;index-_005f_005fbuiltin_005fhuge_005fval&quot;&gt;__builtin_huge_val&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="ffafe4d74af74fb9ca60ea9821704b751632b93c" translate="yes" xml:space="preserve">
          <source>Built-in Function: double &lt;strong id=&quot;index-_005f_005fbuiltin_005finf&quot;&gt;__builtin_inf&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : double &lt;strong id=&quot;index-_005f_005fbuiltin_005finf&quot;&gt;__builtin_inf&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="2864a0d09a57cc7f91ca4ff8697942e0585349f6" translate="yes" xml:space="preserve">
          <source>Built-in Function: double &lt;strong id=&quot;index-_005f_005fbuiltin_005fnan&quot;&gt;__builtin_nan&lt;/strong&gt; (const char *str)</source>
          <target state="translated">내장 함수 : double &lt;strong id=&quot;index-_005f_005fbuiltin_005fnan&quot;&gt;__builtin_nan&lt;/strong&gt; (const char * str)</target>
        </trans-unit>
        <trans-unit id="51bc6d3e017f472618e17d8b483f22c00009407c" translate="yes" xml:space="preserve">
          <source>Built-in Function: double &lt;strong id=&quot;index-_005f_005fbuiltin_005fnans&quot;&gt;__builtin_nans&lt;/strong&gt; (const char *str)</source>
          <target state="translated">내장 함수 : double &lt;strong id=&quot;index-_005f_005fbuiltin_005fnans&quot;&gt;__builtin_nans&lt;/strong&gt; (const char * str)</target>
        </trans-unit>
        <trans-unit id="b40603712a54f648b2195d490214834e3f8465f8" translate="yes" xml:space="preserve">
          <source>Built-in Function: double &lt;strong id=&quot;index-_005f_005fbuiltin_005fpowi-1&quot;&gt;__builtin_powi&lt;/strong&gt; (double, int)</source>
          <target state="translated">내장 함수 : double &lt;strong id=&quot;index-_005f_005fbuiltin_005fpowi-1&quot;&gt;__builtin_powi&lt;/strong&gt; (double, int)</target>
        </trans-unit>
        <trans-unit id="37264a6694867df8b96fcd2a07266108a13c8c2e" translate="yes" xml:space="preserve">
          <source>Built-in Function: float &lt;strong id=&quot;index-_005f_005fbuiltin_005fhuge_005fvalf&quot;&gt;__builtin_huge_valf&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : float &lt;strong id=&quot;index-_005f_005fbuiltin_005fhuge_005fvalf&quot;&gt;__builtin_huge_valf&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="605b7b7bd5e72cf972739ddb673591e051dadcd8" translate="yes" xml:space="preserve">
          <source>Built-in Function: float &lt;strong id=&quot;index-_005f_005fbuiltin_005finff&quot;&gt;__builtin_inff&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : float &lt;strong id=&quot;index-_005f_005fbuiltin_005finff&quot;&gt;__builtin_inff&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="a84c6b7adfcd7dc51b670ecde42ed816377e7198" translate="yes" xml:space="preserve">
          <source>Built-in Function: float &lt;strong id=&quot;index-_005f_005fbuiltin_005fnanf&quot;&gt;__builtin_nanf&lt;/strong&gt; (const char *str)</source>
          <target state="translated">내장 함수 : float &lt;strong id=&quot;index-_005f_005fbuiltin_005fnanf&quot;&gt;__builtin_nanf&lt;/strong&gt; (const char * str)</target>
        </trans-unit>
        <trans-unit id="ae6f3577a561b5595beef7b2c40d9183bbecdc53" translate="yes" xml:space="preserve">
          <source>Built-in Function: float &lt;strong id=&quot;index-_005f_005fbuiltin_005fnansf&quot;&gt;__builtin_nansf&lt;/strong&gt; (const char *str)</source>
          <target state="translated">내장 함수 : float &lt;strong id=&quot;index-_005f_005fbuiltin_005fnansf&quot;&gt;__builtin_nansf&lt;/strong&gt; (const char * str)</target>
        </trans-unit>
        <trans-unit id="a17547d96b5dcfda1585e7b927ed2efd4413b34e" translate="yes" xml:space="preserve">
          <source>Built-in Function: float &lt;strong id=&quot;index-_005f_005fbuiltin_005fpowif-1&quot;&gt;__builtin_powif&lt;/strong&gt; (float, int)</source>
          <target state="translated">내장 함수 : float &lt;strong id=&quot;index-_005f_005fbuiltin_005fpowif-1&quot;&gt;__builtin_powif&lt;/strong&gt; (float, int)</target>
        </trans-unit>
        <trans-unit id="5af70608a64ebe69db59d9a08864316c44173d0e" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fLINE&quot;&gt;__builtin_LINE&lt;/strong&gt; ()</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fLINE&quot;&gt;__builtin_LINE&lt;/strong&gt; ()</target>
        </trans-unit>
        <trans-unit id="48642fe0ecb713fe1c2c62aceb4756a077c1f773" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005faligned&quot;&gt;__builtin_arc_aligned&lt;/strong&gt; (void *&lt;var&gt;val&lt;/var&gt;, int &lt;var&gt;alignval&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005faligned&quot;&gt;__builtin_arc_aligned&lt;/strong&gt; (void * &lt;var&gt;val&lt;/var&gt; , int &lt;var&gt;alignval&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="d03ad02fdd87a3d6c105f1b3776333e8f10a10d5" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fdivaw&quot;&gt;__builtin_arc_divaw&lt;/strong&gt; (int &lt;var&gt;a&lt;/var&gt;, int &lt;var&gt;b&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fdivaw&quot;&gt;__builtin_arc_divaw&lt;/strong&gt; (int &lt;var&gt;a&lt;/var&gt; , int &lt;var&gt;b&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="9c45a4bbd1df9874258bef23963c99d6fdf07ecc" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fnorm&quot;&gt;__builtin_arc_norm&lt;/strong&gt; (int &lt;var&gt;src&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fnorm&quot;&gt;__builtin_arc_norm&lt;/strong&gt; (int &lt;var&gt;src&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="343cfc12f31c0a60920faf8b433b92fcf3f860cf" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fswap&quot;&gt;__builtin_arc_swap&lt;/strong&gt; (int &lt;var&gt;src&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fswap&quot;&gt;__builtin_arc_swap&lt;/strong&gt; (int &lt;var&gt;src&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="4d84191dd5a2bd1c0e1ed8ebf20f4a6e76b3cbe6" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclrsb&quot;&gt;__builtin_clrsb&lt;/strong&gt; (int x)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclrsb&quot;&gt;__builtin_clrsb&lt;/strong&gt; (int x)</target>
        </trans-unit>
        <trans-unit id="26c48a9f003c2411e7dd88432db5f58cb7b19302" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclrsbl&quot;&gt;__builtin_clrsbl&lt;/strong&gt; (long)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclrsbl&quot;&gt;__builtin_clrsbl&lt;/strong&gt; (long)</target>
        </trans-unit>
        <trans-unit id="def7076c73776e0b25f88bdee6855cecbffd2e2a" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclrsbll&quot;&gt;__builtin_clrsbll&lt;/strong&gt; (long long)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclrsbll&quot;&gt;__builtin_clrsbll&lt;/strong&gt; (long long)</target>
        </trans-unit>
        <trans-unit id="68a0ab60ba16fc861473b90def46ecb8b60b639d" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclz&quot;&gt;__builtin_clz&lt;/strong&gt; (unsigned int x)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclz&quot;&gt;__builtin_clz&lt;/strong&gt; (부호없는 int x)</target>
        </trans-unit>
        <trans-unit id="af52cee1c123c25328e32f99b41a08f4a5682992" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclzl&quot;&gt;__builtin_clzl&lt;/strong&gt; (unsigned long)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclzl&quot;&gt;__builtin_clzl&lt;/strong&gt; (부호없는 long)</target>
        </trans-unit>
        <trans-unit id="f3a7c4157a06fcdbaf2b34c2852b5f5191d70ac6" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclzll&quot;&gt;__builtin_clzll&lt;/strong&gt; (unsigned long long)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fclzll&quot;&gt;__builtin_clzll&lt;/strong&gt; (부호없는 long long)</target>
        </trans-unit>
        <trans-unit id="e47a14a24701e5c3353b9003a2bdd96c5e473a94" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fconstant_005fp&quot;&gt;__builtin_constant_p&lt;/strong&gt; (&lt;var&gt;exp&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fconstant_005fp&quot;&gt;__builtin_constant_p&lt;/strong&gt; ( &lt;var&gt;exp&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="ef14ea6a7a4d27be1b6d59915aed4bf7b4b1a9b6" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005fis&quot;&gt;__builtin_cpu_is&lt;/strong&gt; (const char *&lt;var&gt;cpuname&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005fis&quot;&gt;__builtin_cpu_is&lt;/strong&gt; (const char * &lt;var&gt;cpuname&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="b3f1d6da484baf586ba4417cd2ac456d3490d574" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005fis-1&quot;&gt;__builtin_cpu_is&lt;/strong&gt; (const char *&lt;var&gt;cpuname&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005fis-1&quot;&gt;__builtin_cpu_is&lt;/strong&gt; (const char * &lt;var&gt;cpuname&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="8f5e90517840f43dd21b0d12105cc6839b7ba276" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005fsupports&quot;&gt;__builtin_cpu_supports&lt;/strong&gt; (const char *&lt;var&gt;feature&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005fsupports&quot;&gt;__builtin_cpu_supports&lt;/strong&gt; (const char * &lt;var&gt;feature&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="be485791899d037b9a8263a3418dab2b9ad4f3b5" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005fsupports-1&quot;&gt;__builtin_cpu_supports&lt;/strong&gt; (const char *&lt;var&gt;feature&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005fsupports-1&quot;&gt;__builtin_cpu_supports&lt;/strong&gt; (const char * &lt;var&gt;feature&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="7f22b95a5cdd587669aed9814a5480962c20cb7d" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fctz&quot;&gt;__builtin_ctz&lt;/strong&gt; (unsigned int x)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fctz&quot;&gt;__builtin_ctz&lt;/strong&gt; (부호없는 int x)</target>
        </trans-unit>
        <trans-unit id="8e1e06b0d6fb4ae3123c409271d97e77380c487c" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fctzl&quot;&gt;__builtin_ctzl&lt;/strong&gt; (unsigned long)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fctzl&quot;&gt;__builtin_ctzl&lt;/strong&gt; (부호없는 long)</target>
        </trans-unit>
        <trans-unit id="20a1238733f66fff846c6029aaa32b6b42066621" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fctzll&quot;&gt;__builtin_ctzll&lt;/strong&gt; (unsigned long long)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fctzll&quot;&gt;__builtin_ctzll&lt;/strong&gt; (부호없는 long long)</target>
        </trans-unit>
        <trans-unit id="0937729bdd117da89bde58b2fd5056203d7a7e12" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fffs&quot;&gt;__builtin_ffs&lt;/strong&gt; (int x)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fffs&quot;&gt;__builtin_ffs&lt;/strong&gt; (int x)</target>
        </trans-unit>
        <trans-unit id="c820dda274694fd7c04aa653b01ff9cf75ba5bae" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fffsl&quot;&gt;__builtin_ffsl&lt;/strong&gt; (long)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fffsl&quot;&gt;__builtin_ffsl&lt;/strong&gt; (long)</target>
        </trans-unit>
        <trans-unit id="0419174c77d9db8a178954419d9e7c6e3dc80183" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fffsll&quot;&gt;__builtin_ffsll&lt;/strong&gt; (long long)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fffsll&quot;&gt;__builtin_ffsll&lt;/strong&gt; (long long)</target>
        </trans-unit>
        <trans-unit id="d32b1e79ff752f0a0ce225c7feb84f484de727e9" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005ffpclassify-1&quot;&gt;__builtin_fpclassify&lt;/strong&gt; (int, int, int, int, int, ...)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005ffpclassify-1&quot;&gt;__builtin_fpclassify&lt;/strong&gt; (int, int, int, int, int, ...)</target>
        </trans-unit>
        <trans-unit id="e67b5cb4d37226ea2da9240fb2bf4c5fbfb5a8e1" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fgoacc_005fparlevel_005fid&quot;&gt;__builtin_goacc_parlevel_id&lt;/strong&gt; (int x)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fgoacc_005fparlevel_005fid&quot;&gt;__builtin_goacc_parlevel_id&lt;/strong&gt; (int x)</target>
        </trans-unit>
        <trans-unit id="6e97eb7d6696130c1b12f3a195f09c5fe85037ac" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fgoacc_005fparlevel_005fsize&quot;&gt;__builtin_goacc_parlevel_size&lt;/strong&gt; (int x)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fgoacc_005fparlevel_005fsize&quot;&gt;__builtin_goacc_parlevel_size&lt;/strong&gt; (int x)</target>
        </trans-unit>
        <trans-unit id="6d1c7c86aea003afe938bab829e378b0663f340f" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fisinf_005fsign-1&quot;&gt;__builtin_isinf_sign&lt;/strong&gt; (...)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fisinf_005fsign-1&quot;&gt;__builtin_isinf_sign&lt;/strong&gt; (...)</target>
        </trans-unit>
        <trans-unit id="b6364cb6c54b3f23f200e94c257634d572b72a2b" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fmfsr&quot;&gt;__builtin_nds32_mfsr&lt;/strong&gt; (int &lt;var&gt;sr&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fmfsr&quot;&gt;__builtin_nds32_mfsr&lt;/strong&gt; (int &lt;var&gt;sr&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="75355c68c6a70985d49c27c009882adbab77b765" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fmfusr&quot;&gt;__builtin_nds32_mfusr&lt;/strong&gt; (int &lt;var&gt;usr&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fmfusr&quot;&gt;__builtin_nds32_mfusr&lt;/strong&gt; (int &lt;var&gt;usr&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="4ea0be9b20abc1e8c8611e711574fc9d068aecdf" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fparity&quot;&gt;__builtin_parity&lt;/strong&gt; (unsigned int x)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fparity&quot;&gt;__builtin_parity&lt;/strong&gt; (부호없는 int x)</target>
        </trans-unit>
        <trans-unit id="d2674768572b8928e01401026a8478558c974780" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fparityl&quot;&gt;__builtin_parityl&lt;/strong&gt; (unsigned long)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fparityl&quot;&gt;__builtin_parityl&lt;/strong&gt; (부호없는 long)</target>
        </trans-unit>
        <trans-unit id="ee9664e69ce71d737f813b0b4d98ebf2574871d2" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fparityll&quot;&gt;__builtin_parityll&lt;/strong&gt; (unsigned long long)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fparityll&quot;&gt;__builtin_parityll&lt;/strong&gt; (부호없는 long long)</target>
        </trans-unit>
        <trans-unit id="f4ff1595ae9b712ea80b334ac2a6cdea20f82b68" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fpopcount&quot;&gt;__builtin_popcount&lt;/strong&gt; (unsigned int x)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fpopcount&quot;&gt;__builtin_popcount&lt;/strong&gt; (부호없는 int x)</target>
        </trans-unit>
        <trans-unit id="06a51eea95b9b1a09db27133b891662e30ce0448" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fpopcountl&quot;&gt;__builtin_popcountl&lt;/strong&gt; (unsigned long)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fpopcountl&quot;&gt;__builtin_popcountl&lt;/strong&gt; (부호없는 long)</target>
        </trans-unit>
        <trans-unit id="cdd076b3e2da0133a80ede36a8b399d240589b8d" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fpopcountll&quot;&gt;__builtin_popcountll&lt;/strong&gt; (unsigned long long)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fpopcountll&quot;&gt;__builtin_popcountll&lt;/strong&gt; (부호없는 long long)</target>
        </trans-unit>
        <trans-unit id="81ba97f2fd93c345aa1ebd2ae07061c6b3b1e18d" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvfachi&quot;&gt;__builtin_rx_mvfachi&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvfachi&quot;&gt;__builtin_rx_mvfachi&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="bc349ef1269f6645b577d9e0423a3da86a3c0c64" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvfacmi&quot;&gt;__builtin_rx_mvfacmi&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvfacmi&quot;&gt;__builtin_rx_mvfacmi&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="3c6283c7dae9e9bf7ecb0b6d081f4b083bb18c46" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvfc&quot;&gt;__builtin_rx_mvfc&lt;/strong&gt; (int)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvfc&quot;&gt;__builtin_rx_mvfc&lt;/strong&gt; (int)</target>
        </trans-unit>
        <trans-unit id="061b61de0614f91eda3a2e79ebd09fdb750a9e0f" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005frevw&quot;&gt;__builtin_rx_revw&lt;/strong&gt; (int)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005frevw&quot;&gt;__builtin_rx_revw&lt;/strong&gt; (int)</target>
        </trans-unit>
        <trans-unit id="90ac1419f6405c9d67980323a8c6db2b17519fa4" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fsat&quot;&gt;__builtin_rx_sat&lt;/strong&gt; (int)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fsat&quot;&gt;__builtin_rx_sat&lt;/strong&gt; (int)</target>
        </trans-unit>
        <trans-unit id="ba08ce759241ad5b54043023fc31cb69ea10ef12" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005fsetjmp&quot;&gt;__builtin_setjmp&lt;/strong&gt; (intptr_t *&lt;var&gt;buf&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005fsetjmp&quot;&gt;__builtin_setjmp&lt;/strong&gt; (intptr_t * &lt;var&gt;buf&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="3b5f4e2e49e883c140bdde81a146113e7826c6e9" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftbegin&quot;&gt;__builtin_tbegin&lt;/strong&gt; (void*)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftbegin&quot;&gt;__builtin_tbegin&lt;/strong&gt; (void *)</target>
        </trans-unit>
        <trans-unit id="00769436b2cde422b3b7011657e79f1018006b03" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftbegin_005fnofloat&quot;&gt;__builtin_tbegin_nofloat&lt;/strong&gt; (void*)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftbegin_005fnofloat&quot;&gt;__builtin_tbegin_nofloat&lt;/strong&gt; (void *)</target>
        </trans-unit>
        <trans-unit id="b626c4c35bdf8b837ccbdac21dccf04d3259501c" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftbegin_005fretry&quot;&gt;__builtin_tbegin_retry&lt;/strong&gt; (void*, int)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftbegin_005fretry&quot;&gt;__builtin_tbegin_retry&lt;/strong&gt; (void *, int)</target>
        </trans-unit>
        <trans-unit id="7b0e1df41de31ed2e428c07e756094f54001f4e6" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftbegin_005fretry_005fnofloat&quot;&gt;__builtin_tbegin_retry_nofloat&lt;/strong&gt; (void*, int)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftbegin_005fretry_005fnofloat&quot;&gt;__builtin_tbegin_retry_nofloat&lt;/strong&gt; (void *, int)</target>
        </trans-unit>
        <trans-unit id="5a37cc4aa4480ad9e51ba1642145972ee824d1c3" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftend&quot;&gt;__builtin_tend&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftend&quot;&gt;__builtin_tend&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="b156bfa334cc82648dee3d2f253e789fdf0de655" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftx_005fnesting_005fdepth&quot;&gt;__builtin_tx_nesting_depth&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftx_005fnesting_005fdepth&quot;&gt;__builtin_tx_nesting_depth&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="7d1b9cf1258d4a3f36ac2384619d6f6feef8480b" translate="yes" xml:space="preserve">
          <source>Built-in Function: int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftypes_005fcompatible_005fp&quot;&gt;__builtin_types_compatible_p&lt;/strong&gt; (&lt;var&gt;type1&lt;/var&gt;, &lt;var&gt;type2&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : int &lt;strong id=&quot;index-_005f_005fbuiltin_005ftypes_005fcompatible_005fp&quot;&gt;__builtin_types_compatible_p&lt;/strong&gt; ( &lt;var&gt;type1&lt;/var&gt; , &lt;var&gt;type2&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="ab0fd3c8fa261ef1e9881453b5ce3996db8b353f" translate="yes" xml:space="preserve">
          <source>Built-in Function: long &lt;strong id=&quot;index-_005f_005fbuiltin_005fexpect&quot;&gt;__builtin_expect&lt;/strong&gt; (long &lt;var&gt;exp&lt;/var&gt;, long &lt;var&gt;c&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : long &lt;strong id=&quot;index-_005f_005fbuiltin_005fexpect&quot;&gt;__builtin_expect&lt;/strong&gt; (long &lt;var&gt;exp&lt;/var&gt; , long &lt;var&gt;c&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="f748429dddf7f60efd21f75bc9d96a2f04db2076" translate="yes" xml:space="preserve">
          <source>Built-in Function: long &lt;strong id=&quot;index-_005f_005fbuiltin_005fexpect_005fwith_005fprobability&quot;&gt;__builtin_expect_with_probability&lt;/strong&gt;</source>
          <target state="translated">내장 함수 : long &lt;strong id=&quot;index-_005f_005fbuiltin_005fexpect_005fwith_005fprobability&quot;&gt;__builtin_expect_with_probability&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="971be5dbeae5d7765bfe0bd927cc0410ae39a447" translate="yes" xml:space="preserve">
          <source>Built-in Function: long double &lt;strong id=&quot;index-_005f_005fbuiltin_005fhuge_005fvall&quot;&gt;__builtin_huge_vall&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : long double &lt;strong id=&quot;index-_005f_005fbuiltin_005fhuge_005fvall&quot;&gt;__builtin_huge_vall&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="f890816fdc58a1aea60b82df935d886c00b2bf15" translate="yes" xml:space="preserve">
          <source>Built-in Function: long double &lt;strong id=&quot;index-_005f_005fbuiltin_005finfl&quot;&gt;__builtin_infl&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : long double &lt;strong id=&quot;index-_005f_005fbuiltin_005finfl&quot;&gt;__builtin_infl&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="4324db719b621df0af588063a194c3f4173810b5" translate="yes" xml:space="preserve">
          <source>Built-in Function: long double &lt;strong id=&quot;index-_005f_005fbuiltin_005fnanl&quot;&gt;__builtin_nanl&lt;/strong&gt; (const char *str)</source>
          <target state="translated">내장 함수 : long double &lt;strong id=&quot;index-_005f_005fbuiltin_005fnanl&quot;&gt;__builtin_nanl&lt;/strong&gt; (const char * str)</target>
        </trans-unit>
        <trans-unit id="05afbb2ee64f8e1c3ac88b778a44096576c7f966" translate="yes" xml:space="preserve">
          <source>Built-in Function: long double &lt;strong id=&quot;index-_005f_005fbuiltin_005fnansl&quot;&gt;__builtin_nansl&lt;/strong&gt; (const char *str)</source>
          <target state="translated">내장 함수 : long double &lt;strong id=&quot;index-_005f_005fbuiltin_005fnansl&quot;&gt;__builtin_nansl&lt;/strong&gt; (const char * str)</target>
        </trans-unit>
        <trans-unit id="2b868b2b6ef31f0d2806eabe890d6c604ddddf56" translate="yes" xml:space="preserve">
          <source>Built-in Function: long double &lt;strong id=&quot;index-_005f_005fbuiltin_005fpowil-1&quot;&gt;__builtin_powil&lt;/strong&gt; (long double, int)</source>
          <target state="translated">내장 함수 : long double &lt;strong id=&quot;index-_005f_005fbuiltin_005fpowil-1&quot;&gt;__builtin_powil&lt;/strong&gt; (long double, int)</target>
        </trans-unit>
        <trans-unit id="d356427c6ff17cd4bc34021c1341be077bc0c8a1" translate="yes" xml:space="preserve">
          <source>Built-in Function: short int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fnormw&quot;&gt;__builtin_arc_normw&lt;/strong&gt; (short int &lt;var&gt;src&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : short int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fnormw&quot;&gt;__builtin_arc_normw&lt;/strong&gt; (short int &lt;var&gt;src&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="f029118b8798750fa6c678264c3c7762285f4d28" translate="yes" xml:space="preserve">
          <source>Built-in Function: size_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fobject_005fsize-1&quot;&gt;__builtin_object_size&lt;/strong&gt; (const void * &lt;var&gt;ptr&lt;/var&gt;, int &lt;var&gt;type&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : size_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fobject_005fsize-1&quot;&gt;__builtin_object_size&lt;/strong&gt; (const void * &lt;var&gt;ptr&lt;/var&gt; , int &lt;var&gt;type&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="e7554947332f78bb70c0521290e9a6608845a4d1" translate="yes" xml:space="preserve">
          <source>Built-in Function: size_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fobject_005fsize-3&quot;&gt;__builtin_object_size&lt;/strong&gt; (const void * &lt;var&gt;ptr&lt;/var&gt;, int &lt;var&gt;type&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : size_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fobject_005fsize-3&quot;&gt;__builtin_object_size&lt;/strong&gt; (const void * &lt;var&gt;ptr&lt;/var&gt; , int &lt;var&gt;type&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="989a30653b65ffed34f5682558a8970a9aa0e644" translate="yes" xml:space="preserve">
          <source>Built-in Function: size_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fva_005farg_005fpack_005flen&quot;&gt;__builtin_va_arg_pack_len&lt;/strong&gt; ()</source>
          <target state="translated">내장 함수 : size_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fva_005farg_005fpack_005flen&quot;&gt;__builtin_va_arg_pack_len&lt;/strong&gt; ()</target>
        </trans-unit>
        <trans-unit id="22d331467c48fe2922c4d1d28e785562b4d984a9" translate="yes" xml:space="preserve">
          <source>Built-in Function: uint16_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fbswap16&quot;&gt;__builtin_bswap16&lt;/strong&gt; (uint16_t x)</source>
          <target state="translated">내장 함수 : uint16_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fbswap16&quot;&gt;__builtin_bswap16&lt;/strong&gt; (uint16_t x)</target>
        </trans-unit>
        <trans-unit id="c1726e6c424d7f99d5018566837c4927b7db5948" translate="yes" xml:space="preserve">
          <source>Built-in Function: uint32_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fbswap32&quot;&gt;__builtin_bswap32&lt;/strong&gt; (uint32_t x)</source>
          <target state="translated">내장 함수 : uint32_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fbswap32&quot;&gt;__builtin_bswap32&lt;/strong&gt; (uint32_t x)</target>
        </trans-unit>
        <trans-unit id="3c5352b73e73ceeb994fa2584683f756d8f9d112" translate="yes" xml:space="preserve">
          <source>Built-in Function: uint64_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fbswap64&quot;&gt;__builtin_bswap64&lt;/strong&gt; (uint64_t x)</source>
          <target state="translated">내장 함수 : uint64_t &lt;strong id=&quot;index-_005f_005fbuiltin_005fbswap64&quot;&gt;__builtin_bswap64&lt;/strong&gt; (uint64_t x)</target>
        </trans-unit>
        <trans-unit id="abc61c858b13f41c2e5ca8e8946562bef29c71f9" translate="yes" xml:space="preserve">
          <source>Built-in Function: unsigned &lt;strong id=&quot;index-long&quot;&gt;long&lt;/strong&gt; long __builtin_bpf_load_byte (unsigned long long &lt;var&gt;offset&lt;/var&gt;)</source>
          <target state="translated">Built-in Function: unsigned &lt;strong id=&quot;index-long&quot;&gt;long&lt;/strong&gt; long __builtin_bpf_load_byte (unsigned long long &lt;var&gt;offset&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="aa41c7be715e464532b85eaa4dc6a456f1c00215" translate="yes" xml:space="preserve">
          <source>Built-in Function: unsigned &lt;strong id=&quot;index-long-1&quot;&gt;long&lt;/strong&gt; long __builtin_bpf_load_half (unsigned long long &lt;var&gt;offset&lt;/var&gt;)</source>
          <target state="translated">Built-in Function: unsigned &lt;strong id=&quot;index-long-1&quot;&gt;long&lt;/strong&gt; long __builtin_bpf_load_half (unsigned long long &lt;var&gt;offset&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="7b96451756f237a6911f0f759acff406d9ac6251" translate="yes" xml:space="preserve">
          <source>Built-in Function: unsigned &lt;strong id=&quot;index-long-2&quot;&gt;long&lt;/strong&gt; long __builtin_bpf_load_word (unsigned long long &lt;var&gt;offset&lt;/var&gt;)</source>
          <target state="translated">Built-in Function: unsigned &lt;strong id=&quot;index-long-2&quot;&gt;long&lt;/strong&gt; long __builtin_bpf_load_word (unsigned long long &lt;var&gt;offset&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="509ae15fd2e87932ac8b26cb6b1d223cd12aa699" translate="yes" xml:space="preserve">
          <source>Built-in Function: unsigned int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fcore_005fread&quot;&gt;__builtin_arc_core_read&lt;/strong&gt; (unsigned int &lt;var&gt;regno&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : unsigned int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fcore_005fread&quot;&gt;__builtin_arc_core_read&lt;/strong&gt; (unsigned int &lt;var&gt;regno&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="930e355c3b80a5a9fc58fc1acd0a189dee429782" translate="yes" xml:space="preserve">
          <source>Built-in Function: unsigned int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005flr&quot;&gt;__builtin_arc_lr&lt;/strong&gt; (unsigned int &lt;var&gt;auxr&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : unsigned int &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005flr&quot;&gt;__builtin_arc_lr&lt;/strong&gt; (unsigned int &lt;var&gt;auxr&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="fe43f813f2eb2f9db208678d8efd3062ab0ae06f" translate="yes" xml:space="preserve">
          <source>Built-in Function: unsigned int &lt;strong id=&quot;index-_005f_005fbuiltin_005fsh_005fget_005ffpscr&quot;&gt;__builtin_sh_get_fpscr&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : unsigned int &lt;strong id=&quot;index-_005f_005fbuiltin_005fsh_005fget_005ffpscr&quot;&gt;__builtin_sh_get_fpscr&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="7bd053e0e0e0c481f2fd8761cce8fb20e0497500" translate="yes" xml:space="preserve">
          <source>Built-in Function: void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fapply&quot;&gt;__builtin_apply&lt;/strong&gt; (void (*&lt;var&gt;function&lt;/var&gt;)(), void *&lt;var&gt;arguments&lt;/var&gt;, size_t &lt;var&gt;size&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fapply&quot;&gt;__builtin_apply&lt;/strong&gt; (void (* &lt;var&gt;function&lt;/var&gt; ) (), void * &lt;var&gt;arguments&lt;/var&gt; , size_t &lt;var&gt;size&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="34fa5cc333ec1b465b8bc1469ac13a9805646394" translate="yes" xml:space="preserve">
          <source>Built-in Function: void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fapply_005fargs&quot;&gt;__builtin_apply_args&lt;/strong&gt; ()</source>
          <target state="translated">내장 함수 : void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fapply_005fargs&quot;&gt;__builtin_apply_args&lt;/strong&gt; ()</target>
        </trans-unit>
        <trans-unit id="ae3f4e7eb7b92dd81ca2567a194a5a901d0bfe5f" translate="yes" xml:space="preserve">
          <source>Built-in Function: void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fassume_005faligned&quot;&gt;__builtin_assume_aligned&lt;/strong&gt; (const void *&lt;var&gt;exp&lt;/var&gt;, size_t &lt;var&gt;align&lt;/var&gt;, ...)</source>
          <target state="translated">내장 함수 : void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fassume_005faligned&quot;&gt;__builtin_assume_aligned&lt;/strong&gt; (const void * &lt;var&gt;exp&lt;/var&gt; , size_t &lt;var&gt;align&lt;/var&gt; , ...)</target>
        </trans-unit>
        <trans-unit id="89fd532a50930c3b77686313f0365b067e8b2061" translate="yes" xml:space="preserve">
          <source>Built-in Function: void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fextract_005freturn_005faddr&quot;&gt;__builtin_extract_return_addr&lt;/strong&gt; (void *&lt;var&gt;addr&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fextract_005freturn_005faddr&quot;&gt;__builtin_extract_return_addr&lt;/strong&gt; (void * &lt;var&gt;addr&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="af5db4b2531bc00d2c26aa89ffd98b83b1ec2ffd" translate="yes" xml:space="preserve">
          <source>Built-in Function: void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fframe_005faddress&quot;&gt;__builtin_frame_address&lt;/strong&gt; (unsigned int &lt;var&gt;level&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fframe_005faddress&quot;&gt;__builtin_frame_address&lt;/strong&gt; (부호없는 int &lt;var&gt;level&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="d65d4d6005c36effe3b2d9cb5dc89b8f157bffcd" translate="yes" xml:space="preserve">
          <source>Built-in Function: void * &lt;strong id=&quot;index-_005f_005fbuiltin_005ffrob_005freturn_005faddr&quot;&gt;__builtin_frob_return_addr&lt;/strong&gt; (void *&lt;var&gt;addr&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : void * &lt;strong id=&quot;index-_005f_005fbuiltin_005ffrob_005freturn_005faddr&quot;&gt;__builtin_frob_return_addr&lt;/strong&gt; (void * &lt;var&gt;addr&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="0ae549b690a18db077d51fc88ddfe8895c32f392" translate="yes" xml:space="preserve">
          <source>Built-in Function: void * &lt;strong id=&quot;index-_005f_005fbuiltin_005ffrob_005freturn_005faddress&quot;&gt;__builtin_frob_return_address&lt;/strong&gt; (void *&lt;var&gt;addr&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : void * &lt;strong id=&quot;index-_005f_005fbuiltin_005ffrob_005freturn_005faddress&quot;&gt;__builtin_frob_return_address&lt;/strong&gt; (void * &lt;var&gt;addr&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="570bc19f96ffb431d4ed4e07d4a76a73d90b1bab" translate="yes" xml:space="preserve">
          <source>Built-in Function: void * &lt;strong id=&quot;index-_005f_005fbuiltin_005freturn_005faddress&quot;&gt;__builtin_return_address&lt;/strong&gt; (unsigned int &lt;var&gt;level&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : void * &lt;strong id=&quot;index-_005f_005fbuiltin_005freturn_005faddress&quot;&gt;__builtin_return_address&lt;/strong&gt; (부호없는 int &lt;var&gt;level&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="2a17d8a48dd1cfb01e5eca9e0fefb74ccd1f3e19" translate="yes" xml:space="preserve">
          <source>Built-in Function: void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fthread_005fpointer&quot;&gt;__builtin_thread_pointer&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : void * &lt;strong id=&quot;index-_005f_005fbuiltin_005fthread_005fpointer&quot;&gt;__builtin_thread_pointer&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="f386f8fa1a3ce61aaddb01d8f87e99be90ce722e" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_002a_005f_005fbuiltin_005falloca&quot;&gt;*__builtin_alloca&lt;/strong&gt; (size_t size)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_002a_005f_005fbuiltin_005falloca&quot;&gt;* __ builtin_alloca&lt;/strong&gt; (size_t size)</target>
        </trans-unit>
        <trans-unit id="c063cc66ca8c65c97e5563c39a35ab67426b4796" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_002a_005f_005fbuiltin_005falloca_005fwith_005falign&quot;&gt;*__builtin_alloca_with_align&lt;/strong&gt; (size_t size, size_t alignment)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_002a_005f_005fbuiltin_005falloca_005fwith_005falign&quot;&gt;* __ builtin_alloca_with_align&lt;/strong&gt; (size_t size, size_t alignment)</target>
        </trans-unit>
        <trans-unit id="9c9a2cc82b83f94f4d0c65d76c51d114da95b31b" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_002a_005f_005fbuiltin_005falloca_005fwith_005falign_005fand_005fmax&quot;&gt;*__builtin_alloca_with_align_and_max&lt;/strong&gt; (size_t size, size_t alignment, size_t max_size)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_002a_005f_005fbuiltin_005falloca_005fwith_005falign_005fand_005fmax&quot;&gt;* __ builtin_alloca_with_align_and_max&lt;/strong&gt; (size_t size, size_t alignment, size_t max_size)</target>
        </trans-unit>
        <trans-unit id="9362d0fd68d2bba012773ea9bf47a7cf19548a71" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fatomic_005fclear&quot;&gt;__atomic_clear&lt;/strong&gt; (bool *ptr, int memorder)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fatomic_005fclear&quot;&gt;__atomic_clear&lt;/strong&gt; (bool * ptr, int memorder)</target>
        </trans-unit>
        <trans-unit id="af38ddba7b2c30fcdbcb19cb7f7f28b84121aca6" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fatomic_005fexchange&quot;&gt;__atomic_exchange&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; *val, &lt;var&gt;type&lt;/var&gt; *ret, int memorder)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fatomic_005fexchange&quot;&gt;__atomic_exchange&lt;/strong&gt; ( &lt;var&gt;type&lt;/var&gt; * ptr, &lt;var&gt;type&lt;/var&gt; * val, &lt;var&gt;type&lt;/var&gt; * ret, int memorder)</target>
        </trans-unit>
        <trans-unit id="81cf5ada4648091ed72e1aa65aae72b350e8c4d3" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fatomic_005fload&quot;&gt;__atomic_load&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; *ret, int memorder)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fatomic_005fload&quot;&gt;__atomic_load&lt;/strong&gt; ( &lt;var&gt;type&lt;/var&gt; * ptr, &lt;var&gt;type&lt;/var&gt; * ret, int memorder)</target>
        </trans-unit>
        <trans-unit id="a339c94ea5a60096d289e4b1ba778af9caadce5c" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fatomic_005fsignal_005ffence&quot;&gt;__atomic_signal_fence&lt;/strong&gt; (int memorder)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fatomic_005fsignal_005ffence&quot;&gt;__atomic_signal_fence&lt;/strong&gt; (int memorder)</target>
        </trans-unit>
        <trans-unit id="a1bcb5179154226f5bada80a127d69eae1eb5cec" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fatomic_005fstore&quot;&gt;__atomic_store&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; *val, int memorder)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fatomic_005fstore&quot;&gt;__atomic_store&lt;/strong&gt; ( &lt;var&gt;type&lt;/var&gt; * ptr, &lt;var&gt;type&lt;/var&gt; * val, int memorder)</target>
        </trans-unit>
        <trans-unit id="0a97d93631348e25f6183eb76cee2e101979f75e" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fatomic_005fstore_005fn&quot;&gt;__atomic_store_n&lt;/strong&gt; (&lt;var&gt;type&lt;/var&gt; *ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fatomic_005fstore_005fn&quot;&gt;__atomic_store_n&lt;/strong&gt; ( &lt;var&gt;type&lt;/var&gt; * ptr, &lt;var&gt;type&lt;/var&gt; val, int memorder)</target>
        </trans-unit>
        <trans-unit id="2d340009d0a0b7de28ca2e66c34cf11a1340bae0" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fatomic_005fthread_005ffence&quot;&gt;__atomic_thread_fence&lt;/strong&gt; (int memorder)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fatomic_005fthread_005ffence&quot;&gt;__atomic_thread_fence&lt;/strong&gt; (int memorder)</target>
        </trans-unit>
        <trans-unit id="de406e12d51eaad788fc9e9d5903dcbf3bcb9513" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005f_005f_005fclear_005fcache&quot;&gt;__builtin___clear_cache&lt;/strong&gt; (void *&lt;var&gt;begin&lt;/var&gt;, void *&lt;var&gt;end&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005f_005f_005fclear_005fcache&quot;&gt;__builtin___clear_cache&lt;/strong&gt; (void * &lt;var&gt;begin&lt;/var&gt; , void * &lt;var&gt;end&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="fbdc79fbdaaac306ca33e716a38d2039cdbc731c" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fbrk&quot;&gt;__builtin_arc_brk&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fbrk&quot;&gt;__builtin_arc_brk&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="41dfbf690d1f1831d27b0be428eb428d5c08e800" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fcore_005fwrite&quot;&gt;__builtin_arc_core_write&lt;/strong&gt; (unsigned int &lt;var&gt;regno&lt;/var&gt;, unsigned int &lt;var&gt;val&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fcore_005fwrite&quot;&gt;__builtin_arc_core_write&lt;/strong&gt; (부호없는 int &lt;var&gt;regno&lt;/var&gt; , 부호없는 int &lt;var&gt;val&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="938747d2d81b773df4eb146dc47c371852f38281" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fflag&quot;&gt;__builtin_arc_flag&lt;/strong&gt; (unsigned int &lt;var&gt;a&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fflag&quot;&gt;__builtin_arc_flag&lt;/strong&gt; (부호없는 int &lt;var&gt;a&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="dacbc2eeaf144c8f5f67ca6a60249f78488adc0b" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fmul64&quot;&gt;__builtin_arc_mul64&lt;/strong&gt; (int &lt;var&gt;a&lt;/var&gt;, int &lt;var&gt;b&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fmul64&quot;&gt;__builtin_arc_mul64&lt;/strong&gt; (int &lt;var&gt;a&lt;/var&gt; , int &lt;var&gt;b&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="5df39d3186b8d524cef79461c8ccbf9360ab5670" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fmulu64&quot;&gt;__builtin_arc_mulu64&lt;/strong&gt; (unsigned int &lt;var&gt;a&lt;/var&gt;, unsigned int &lt;var&gt;b&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fmulu64&quot;&gt;__builtin_arc_mulu64&lt;/strong&gt; (부호없는 int &lt;var&gt;a&lt;/var&gt; , 부호없는 int &lt;var&gt;b&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="f6b3b375828d6b123d4a73fe0837a99b6630234e" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fnop&quot;&gt;__builtin_arc_nop&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fnop&quot;&gt;__builtin_arc_nop&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="3e99485526d0fd614866e77c7a635130751c7b1d" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005frtie&quot;&gt;__builtin_arc_rtie&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005frtie&quot;&gt;__builtin_arc_rtie&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="5cc0e84fe67d81076fbea0352fb8f5781564ffca" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fsleep&quot;&gt;__builtin_arc_sleep&lt;/strong&gt; (int &lt;var&gt;a&lt;/var&gt;</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fsleep&quot;&gt;__builtin_arc_sleep&lt;/strong&gt; (int &lt;var&gt;a&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="39ed65244aa708bd181a626a0afcf9435d2147f5" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fsr&quot;&gt;__builtin_arc_sr&lt;/strong&gt; (unsigned int &lt;var&gt;auxr&lt;/var&gt;, unsigned int &lt;var&gt;val&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fsr&quot;&gt;__builtin_arc_sr&lt;/strong&gt; (부호없는 int &lt;var&gt;auxr&lt;/var&gt; , 부호없는 int &lt;var&gt;val&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="f420eb345d10d7bfd574d6a3346de63183adc893" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fswi&quot;&gt;__builtin_arc_swi&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fswi&quot;&gt;__builtin_arc_swi&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="b42e0753d14b76f3a20b1e491681f5295a8dc135" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fsync&quot;&gt;__builtin_arc_sync&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005fsync&quot;&gt;__builtin_arc_sync&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="78cc7129f46ffcafd69b91e8eda56456c2ecced9" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005ftrap_005fs&quot;&gt;__builtin_arc_trap_s&lt;/strong&gt; (unsigned int &lt;var&gt;c&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005ftrap_005fs&quot;&gt;__builtin_arc_trap_s&lt;/strong&gt; (부호없는 int &lt;var&gt;c&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="627e1715f16535c4e6e435528706da2168cf77df" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005funimp_005fs&quot;&gt;__builtin_arc_unimp_s&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005farc_005funimp_005fs&quot;&gt;__builtin_arc_unimp_s&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="b29e71f1f17adad688b68068d1063df98d3d4aee" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005finit&quot;&gt;__builtin_cpu_init&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005finit&quot;&gt;__builtin_cpu_init&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="ae429fc5f0112c7890dcdff589f10f47deea16dd" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005finit-1&quot;&gt;__builtin_cpu_init&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005fcpu_005finit-1&quot;&gt;__builtin_cpu_init&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="d3cd845b205509711bbf6256051511ce8b3607ab" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005flongjmp&quot;&gt;__builtin_longjmp&lt;/strong&gt; (intptr_t *&lt;var&gt;buf&lt;/var&gt;, int &lt;var&gt;val&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005flongjmp&quot;&gt;__builtin_longjmp&lt;/strong&gt; (intptr_t * &lt;var&gt;buf&lt;/var&gt; , int &lt;var&gt;val&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="fff14e5c46a00a91c0c0603fe5f170bde38d705e" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fisb&quot;&gt;__builtin_nds32_isb&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fisb&quot;&gt;__builtin_nds32_isb&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="fe5501c6b5d93e7b033487f6a848dd334597db03" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fisync&quot;&gt;__builtin_nds32_isync&lt;/strong&gt; (int *&lt;var&gt;addr&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fisync&quot;&gt;__builtin_nds32_isync&lt;/strong&gt; (int * &lt;var&gt;addr&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="841f0b2bab051a37cafce912e8b554544bed4ffb" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fmtsr&quot;&gt;__builtin_nds32_mtsr&lt;/strong&gt; (int &lt;var&gt;value&lt;/var&gt;, int &lt;var&gt;sr&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fmtsr&quot;&gt;__builtin_nds32_mtsr&lt;/strong&gt; (int &lt;var&gt;value&lt;/var&gt; , int &lt;var&gt;sr&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="df8bab86f6689c778da28b14954604543548fb9b" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fmtusr&quot;&gt;__builtin_nds32_mtusr&lt;/strong&gt; (int &lt;var&gt;value&lt;/var&gt;, int &lt;var&gt;usr&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fmtusr&quot;&gt;__builtin_nds32_mtusr&lt;/strong&gt; (int &lt;var&gt;value&lt;/var&gt; , int &lt;var&gt;usr&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="cc7672c01bcce0ae5cb385b443579f1f0e814383" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fsetgie_005fdis&quot;&gt;__builtin_nds32_setgie_dis&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fsetgie_005fdis&quot;&gt;__builtin_nds32_setgie_dis&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="01c2cb53755ea177e9b7bcabfb291e59bf8c8d8b" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fsetgie_005fen&quot;&gt;__builtin_nds32_setgie_en&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnds32_005fsetgie_005fen&quot;&gt;__builtin_nds32_setgie_en&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="2f23c91db2e471b60a85c1d974b337410d93c4ae" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnon_005ftx_005fstore&quot;&gt;__builtin_non_tx_store&lt;/strong&gt; (uint64_t *, uint64_t)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005fnon_005ftx_005fstore&quot;&gt;__builtin_non_tx_store&lt;/strong&gt; (uint64_t *, uint64_t)</target>
        </trans-unit>
        <trans-unit id="2321505821d1604108a7105b3b6858f231f0c9ea" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fprefetch&quot;&gt;__builtin_prefetch&lt;/strong&gt; (const void *&lt;var&gt;addr&lt;/var&gt;, ...)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005fprefetch&quot;&gt;__builtin_prefetch&lt;/strong&gt; (const void * &lt;var&gt;addr&lt;/var&gt; , ...)</target>
        </trans-unit>
        <trans-unit id="fe3fc0ac7968932105d1c1d3ab50d7b85cfe594b" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005freturn&quot;&gt;__builtin_return&lt;/strong&gt; (void *&lt;var&gt;result&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005freturn&quot;&gt;__builtin_return&lt;/strong&gt; (void * &lt;var&gt;result&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="a1a8dfdf0491f60d9f3285d8de87cb556335dd7c" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fbrk&quot;&gt;__builtin_rx_brk&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fbrk&quot;&gt;__builtin_rx_brk&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="baafeee4f82f6b2b3615bbf58d2dd0b69de47091" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fclrpsw&quot;&gt;__builtin_rx_clrpsw&lt;/strong&gt; (int)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fclrpsw&quot;&gt;__builtin_rx_clrpsw&lt;/strong&gt; (int)</target>
        </trans-unit>
        <trans-unit id="40ac58e52ec8cfeb1ed0ce17f884d6ca28de4bb2" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fint&quot;&gt;__builtin_rx_int&lt;/strong&gt; (int)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fint&quot;&gt;__builtin_rx_int&lt;/strong&gt; (int)</target>
        </trans-unit>
        <trans-unit id="60f5dc479a3c9ca583cab1eca4c28279f3d7220a" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmachi&quot;&gt;__builtin_rx_machi&lt;/strong&gt; (int, int)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmachi&quot;&gt;__builtin_rx_machi&lt;/strong&gt; (int, int)</target>
        </trans-unit>
        <trans-unit id="8e28f28fffe61c4b4679e59b89330fa5d0042874" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmaclo&quot;&gt;__builtin_rx_maclo&lt;/strong&gt; (int, int)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmaclo&quot;&gt;__builtin_rx_maclo&lt;/strong&gt; (int, int)</target>
        </trans-unit>
        <trans-unit id="46c536195bce3a86157c9c49ee77c45d3577dcc4" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmulhi&quot;&gt;__builtin_rx_mulhi&lt;/strong&gt; (int, int)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmulhi&quot;&gt;__builtin_rx_mulhi&lt;/strong&gt; (int, int)</target>
        </trans-unit>
        <trans-unit id="5621acbcbc1163f811efb159aa50ed209c490ad9" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmullo&quot;&gt;__builtin_rx_mullo&lt;/strong&gt; (int, int)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmullo&quot;&gt;__builtin_rx_mullo&lt;/strong&gt; (int, int)</target>
        </trans-unit>
        <trans-unit id="227762640b3aca70bd083850fd27548557a69595" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvtachi&quot;&gt;__builtin_rx_mvtachi&lt;/strong&gt; (int)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvtachi&quot;&gt;__builtin_rx_mvtachi&lt;/strong&gt; (int)</target>
        </trans-unit>
        <trans-unit id="4eefd425b2ddf508a48e8a2189b6454058653fea" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvtaclo&quot;&gt;__builtin_rx_mvtaclo&lt;/strong&gt; (int)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvtaclo&quot;&gt;__builtin_rx_mvtaclo&lt;/strong&gt; (int)</target>
        </trans-unit>
        <trans-unit id="662dad4c2fd795f4f1dddab9d3e0737c1c8a5708" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvtc&quot;&gt;__builtin_rx_mvtc&lt;/strong&gt; (int reg, int val)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvtc&quot;&gt;__builtin_rx_mvtc&lt;/strong&gt; (int reg, int val)</target>
        </trans-unit>
        <trans-unit id="276391cb278528b1f872b1280affb29edbd7927c" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvtipl&quot;&gt;__builtin_rx_mvtipl&lt;/strong&gt; (int)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fmvtipl&quot;&gt;__builtin_rx_mvtipl&lt;/strong&gt; (int)</target>
        </trans-unit>
        <trans-unit id="700036ac6c5189b95316dbc5c4ae3b0309325df1" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fracw&quot;&gt;__builtin_rx_racw&lt;/strong&gt; (int)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fracw&quot;&gt;__builtin_rx_racw&lt;/strong&gt; (int)</target>
        </trans-unit>
        <trans-unit id="c48b2b82b14ae8b91fdb2fe28e06b8ea0b1cb522" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005frmpa&quot;&gt;__builtin_rx_rmpa&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005frmpa&quot;&gt;__builtin_rx_rmpa&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="4595d30c690a3b8c89c7807c08a9959f30d56800" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fround&quot;&gt;__builtin_rx_round&lt;/strong&gt; (float)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fround&quot;&gt;__builtin_rx_round&lt;/strong&gt; (float)</target>
        </trans-unit>
        <trans-unit id="c5948033a96e4003655c71953e27a3f9741045b3" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fsetpsw&quot;&gt;__builtin_rx_setpsw&lt;/strong&gt; (int)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fsetpsw&quot;&gt;__builtin_rx_setpsw&lt;/strong&gt; (int)</target>
        </trans-unit>
        <trans-unit id="f89dbf6d50890784687748f168df8d729aebf79c" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fwait&quot;&gt;__builtin_rx_wait&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005frx_005fwait&quot;&gt;__builtin_rx_wait&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="95b218b72a2c6b938556ce1a8c8a3cca255a13b1" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fset_005fthread_005fpointer&quot;&gt;__builtin_set_thread_pointer&lt;/strong&gt; (void *&lt;var&gt;ptr&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005fset_005fthread_005fpointer&quot;&gt;__builtin_set_thread_pointer&lt;/strong&gt; (void * &lt;var&gt;ptr&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="2db4725d0eae1acd204db5ae18744d85101db3ea" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005fsh_005fset_005ffpscr&quot;&gt;__builtin_sh_set_fpscr&lt;/strong&gt; (unsigned int &lt;var&gt;val&lt;/var&gt;)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005fsh_005fset_005ffpscr&quot;&gt;__builtin_sh_set_fpscr&lt;/strong&gt; (부호없는 int &lt;var&gt;val&lt;/var&gt; )</target>
        </trans-unit>
        <trans-unit id="f9baaf9b0798ed586e63831552a408b61b1a992c" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005ftabort&quot;&gt;__builtin_tabort&lt;/strong&gt; (int)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005ftabort&quot;&gt;__builtin_tabort&lt;/strong&gt; (int)</target>
        </trans-unit>
        <trans-unit id="d228c7f65857695f955c2630b92714965d36378f" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005ftbeginc&quot;&gt;__builtin_tbeginc&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005ftbeginc&quot;&gt;__builtin_tbeginc&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="94689ecdbd4d60ff7b0fd602ce7245bc7b6beb10" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005ftrap&quot;&gt;__builtin_trap&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005ftrap&quot;&gt;__builtin_trap&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="4a1c671de0baf7c15aaf53f248312afd293d5b33" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005ftx_005fassist&quot;&gt;__builtin_tx_assist&lt;/strong&gt; (int)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005ftx_005fassist&quot;&gt;__builtin_tx_assist&lt;/strong&gt; (int)</target>
        </trans-unit>
        <trans-unit id="5904be3f2c9a60beac8be0103847c267a6f80e80" translate="yes" xml:space="preserve">
          <source>Built-in Function: void &lt;strong id=&quot;index-_005f_005fbuiltin_005funreachable&quot;&gt;__builtin_unreachable&lt;/strong&gt; (void)</source>
          <target state="translated">내장 함수 : void &lt;strong id=&quot;index-_005f_005fbuiltin_005funreachable&quot;&gt;__builtin_unreachable&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="836cf5a0e71cae3a60324503179866ad686508a7" translate="yes" xml:space="preserve">
          <source>Built-in functions for limited buffer overflow checking.</source>
          <target state="translated">제한된 버퍼 오버 플로우 검사를위한 내장 기능.</target>
        </trans-unit>
        <trans-unit id="d4b5ba0eb7000fc998fff5b209a2516ba2e54a3f" translate="yes" xml:space="preserve">
          <source>Built-in functions specific to particular targets.</source>
          <target state="translated">특정 대상에 고유 한 내장 기능.</target>
        </trans-unit>
        <trans-unit id="253258e2e82600175022e888019e1f8e9ab9c3a1" translate="yes" xml:space="preserve">
          <source>Built-in functions to perform arithmetics and arithmetic overflow checking.</source>
          <target state="translated">산술 및 산술 오버 플로우 검사를 수행하는 내장 함수.</target>
        </trans-unit>
        <trans-unit id="4708bb7371d5b0f788e5028a015745453830a6ee" translate="yes" xml:space="preserve">
          <source>Built-in macros, macros defined on the command line, and macros defined in include files are not warned about.</source>
          <target state="translated">내장 매크로, 명령 행에 정의 된 매크로 및 포함 파일에 정의 된 매크로는 경고되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="606b68375f39bb1e243e870d45cdf01eab0caad3" translate="yes" xml:space="preserve">
          <source>But if you need to debug a problem with method signatures and need to know how they are implemented (i.e., the &amp;ldquo;ABI&amp;rdquo;), read on.</source>
          <target state="translated">그러나 메소드 시그니처 관련 문제점을 디버그해야하고 구현 방법 (예 : &quot;ABI&quot;)을 알아야하는 경우 계속 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="18ba03b4395ba58ba0713d75a0907aa6ed34a2f6" translate="yes" xml:space="preserve">
          <source>But in the definition of &lt;code&gt;foo&lt;/code&gt;, the file-scope type is used because that is available to be inherited. Thus, the definition and the prototype do not match, and you get an error.</source>
          <target state="translated">그러나 &lt;code&gt;foo&lt;/code&gt; 의 정의 에서는 파일 범위 유형이 상속 될 수 있기 때문에 사용됩니다. 따라서 정의와 프로토 타입이 일치하지 않아 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="54f71fd5d9e178736a8b25951cca5312e798d273" translate="yes" xml:space="preserve">
          <source>But in this example, the &lt;code&gt;std::move&lt;/code&gt; call prevents copy elision.</source>
          <target state="translated">그러나이 예제에서 &lt;code&gt;std::move&lt;/code&gt; 호출은 복사 제거를 방지합니다.</target>
        </trans-unit>
        <trans-unit id="cf56c043a9173e054f17c75c7e06c6a5d352b771" translate="yes" xml:space="preserve">
          <source>But this definition computes either &lt;var id=&quot;index-side-effects_002c-macro-argument&quot;&gt;a&lt;/var&gt; or &lt;var&gt;b&lt;/var&gt; twice, with bad results if the operand has side effects. In GNU C, if you know the type of the operands (here taken as &lt;code&gt;int&lt;/code&gt;), you can avoid this problem by defining the macro as follows:</source>
          <target state="translated">그러나이 정의 는 피연산자가 부작용을 갖는 경우 나쁜 결과와 함께 &lt;var id=&quot;index-side-effects_002c-macro-argument&quot;&gt;a&lt;/var&gt; 또는 &lt;var&gt;b&lt;/var&gt; 를 두 번 계산합니다 . GNU C에서 피연산자의 유형을 알고 있다면 (여기서는 &lt;code&gt;int&lt;/code&gt; 로 간주) 다음과 같이 매크로를 정의하여이 문제를 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="089c24745336688f5099a4bd50557aedc8fc6fff" translate="yes" xml:space="preserve">
          <source>By contrast, PCC on most target machines returns structures and unions of any size by copying the data into an area of static storage, and then returning the address of that storage as if it were a pointer value. The caller must copy the data from that memory area to the place where the value is wanted. GCC does not use this method because it is slower and nonreentrant.</source>
          <target state="translated">반대로, 대부분의 대상 시스템의 PCC는 데이터를 정적 스토리지 영역에 복사 한 다음 포인터 값인 것처럼 해당 스토리지의 주소를 리턴하여 모든 크기의 구조 및 공용체를 리턴합니다. 호출자는 해당 메모리 영역에서 값을 원하는 위치로 데이터를 복사해야합니다. GCC는 속도가 느리고 재진입 할 ​​수 없으므로이 방법을 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8e8864b0dc6da1e44443610d33567bb75bb81d17" translate="yes" xml:space="preserve">
          <source>By declaring a function inline, you can direct GCC to make calls to that function faster. One way GCC can achieve this is to integrate that function&amp;rsquo;s code into the code for its callers. This makes execution faster by eliminating the function-call overhead; in addition, if any of the actual argument values are constant, their known values may permit simplifications at compile time so that not all of the inline function&amp;rsquo;s code needs to be included. The effect on code size is less predictable; object code may be larger or smaller with function inlining, depending on the particular case. You can also direct GCC to try to integrate all &amp;ldquo;simple enough&amp;rdquo; functions into their callers with the option</source>
          <target state="translated">함수를 인라인으로 선언하면 GCC가 해당 함수를 더 빨리 호출하도록 지시 할 수 있습니다. GCC가이를 달성 할 수있는 한 가지 방법은 해당 함수의 코드를 호출자의 코드에 통합하는 것입니다. 이것은 함수 호출 오버 헤드를 제거함으로써 실행을 더 빠르게 만듭니다. 또한 실제 인수 값이 일정하면 알려진 값으로 인해 컴파일 타임에 단순화가 가능하므로 모든 인라인 함수 코드를 포함 할 필요는 없습니다. 코드 크기에 대한 영향은 예측하기 어렵습니다. 특정 경우에 따라 함수 인라인으로 객체 코드가 더 크거나 작을 수 있습니다. 또한 옵션을 사용하여 모든 &quot;간단한&quot;기능을 호출자에게 통합하도록 GCC에 지시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="571c61d917cc3bc4c5e2835a5dd40c5c41bd768f" translate="yes" xml:space="preserve">
          <source>By default (unless configured otherwise), GCC generates code for the GR5 variant of the Visium architecture.</source>
          <target state="translated">기본적으로 (별도로 구성되지 않은 경우) GCC는 Visium 아키텍처의 GR5 변형에 대한 코드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="8ff1bd96a4bdcc76b002de9ee97861c9f804a0dc" translate="yes" xml:space="preserve">
          <source>By default (unless configured otherwise), GCC generates code for the V7 variant of the SPARC architecture. With</source>
          <target state="translated">기본적으로 (다른 구성이없는 한) GCC는 SPARC 아키텍처의 V7 변형에 대한 코드를 생성합니다. 와</target>
        </trans-unit>
        <trans-unit id="44c806b35c6f92efecb7ce7748b95c7a4f87c40c" translate="yes" xml:space="preserve">
          <source>By default GCC inlines string operations only when the destination is known to be aligned to least a 4-byte boundary. This enables more inlining and increases code size, but may improve performance of code that depends on fast &lt;code&gt;memcpy&lt;/code&gt; and &lt;code&gt;memset&lt;/code&gt; for short lengths. The option enables inline expansion of &lt;code&gt;strlen&lt;/code&gt; for all pointer alignments.</source>
          <target state="translated">기본적으로 GCC는 대상이 최소 4 바이트 경계로 정렬 된 것으로 알려진 경우에만 문자열 작업을 인라인합니다. 이는 더 많은 인라인을 가능하게하고 코드 크기를 증가 시키지만 짧은 길이의 빠른 &lt;code&gt;memcpy&lt;/code&gt; 및 &lt;code&gt;memset&lt;/code&gt; 에 의존하는 코드의 성능을 향상시킬 수 있습니다 . 이 옵션은 모든 포인터 정렬에 대해 &lt;code&gt;strlen&lt;/code&gt; 의 인라인 확장을 활성화 합니다.</target>
        </trans-unit>
        <trans-unit id="ee5c102e65c6f170a209b204a4dbc9b094f06846" translate="yes" xml:space="preserve">
          <source>By default GCC inlines string operations only when the destination is known to be aligned to least a 4-byte boundary. This enables more inlining and increases code size, but may improve performance of code that depends on fast &lt;code&gt;memcpy&lt;/code&gt;, &lt;code&gt;strlen&lt;/code&gt;, and &lt;code&gt;memset&lt;/code&gt; for short lengths.</source>
          <target state="translated">기본적으로 GCC는 대상이 최소 4 바이트 경계에 정렬 된 것으로 알려진 경우에만 문자열 작업을 인라인합니다. 이렇게하면 인라인이 향상되고 코드 크기가 증가하지만 빠른 &lt;code&gt;memcpy&lt;/code&gt; , &lt;code&gt;strlen&lt;/code&gt; 및 &lt;code&gt;memset&lt;/code&gt; 에 따라 짧은 길이 의 코드 성능이 향상 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="828f5d805ef0fc5866d738b0ffbff970c7d7f41f" translate="yes" xml:space="preserve">
          <source>By default assume that all calls are far away so that a longer and more expensive calling sequence is required. This is required for calls farther than 32 megabytes (33,554,432 bytes) from the current location. A short call is generated if the compiler knows the call cannot be that far away. This setting can be overridden by the &lt;code&gt;shortcall&lt;/code&gt; function attribute, or by &lt;code&gt;#pragma
longcall(0)&lt;/code&gt;.</source>
          <target state="translated">기본적으로 모든 통화가 멀리 떨어져 있기 때문에 더 길고 비싼 통화 순서가 필요합니다. 현재 위치에서 32MB (33,554,432 바이트)를 초과하는 통화에 필요합니다. 컴파일러가 호출을 멀리 할 수 ​​없다는 것을 알고 있으면 짧은 호출이 생성됩니다. 이 설정은 &lt;code&gt;shortcall&lt;/code&gt; 함수 속성 또는 &lt;code&gt;#pragma longcall(0)&lt;/code&gt; 으로 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e7d64d02eb42b84df503cac7606206757e75fdfc" translate="yes" xml:space="preserve">
          <source>By default instance variables in Objective-C can be accessed as if they were local variables from within the methods of the class they&amp;rsquo;re declared in. This can lead to shadowing between instance variables and other variables declared either locally inside a class method or globally with the same name. Specifying the</source>
          <target state="translated">기본적으로 Objective-C의 인스턴스 변수는 선언 된 클래스의 메서드 내에서 로컬 변수 인 것처럼 액세스 할 수 있습니다. 이로 인해 인스턴스 변수와 클래스 메서드 내에서 로컬로 선언되거나 전역 적으로 선언 된 다른 변수간에 그림자가 생길 수 있습니다. 같은 이름으로. 지정</target>
        </trans-unit>
        <trans-unit id="812f601802f8d41b61d44c3f0bd220d17f966e00" translate="yes" xml:space="preserve">
          <source>By default it is treated as &lt;code&gt;signed int&lt;/code&gt; but this may be changed by the</source>
          <target state="translated">기본적으로 &lt;code&gt;signed int&lt;/code&gt; 로 취급 되지만 이것은</target>
        </trans-unit>
        <trans-unit id="42ef9328c623bad5538b4f26249da5459c5c08d3" translate="yes" xml:space="preserve">
          <source>By default or when</source>
          <target state="translated">기본적으로 또는 언제</target>
        </trans-unit>
        <trans-unit id="3fa72f6f9c5a94c5d09caf64d4a1e9c339e8bb7c" translate="yes" xml:space="preserve">
          <source>By default the analyzer attempts to simplify analysis by merging sufficiently similar states at each program point as it builds its &amp;ldquo;exploded graph&amp;rdquo;. With</source>
          <target state="translated">기본적으로 분석기는 &quot;분해 된 그래프&quot;를 작성할 때 각 프로그램 지점에서 충분히 유사한 상태를 병합하여 분석을 단순화하려고합니다. 와</target>
        </trans-unit>
        <trans-unit id="238d21ed5942f525fb456a138be81dac5934eca2" translate="yes" xml:space="preserve">
          <source>By default the analyzer attempts to simplify analysis by purging aspects of state at a program point that appear to no longer be relevant e.g. the values of locals that aren&amp;rsquo;t accessed later in the function and which aren&amp;rsquo;t relevant to leak analysis.</source>
          <target state="translated">기본적으로 분석기는 더 이상 관련이없는 것으로 보이는 프로그램 지점 (예 : 함수에서 나중에 액세스하지 않고 누출 분석과 관련이없는 로컬 값)에서 상태 측면을 제거하여 분석을 단순화하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="c9b76575429db7ab5c66debc083d774f7e949e1c" translate="yes" xml:space="preserve">
          <source>By default this feature is not enabled. The default can be restored via the</source>
          <target state="translated">기본적으로이 기능은 활성화되어 있지 않습니다. 를 통해 기본값을 복원 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="be7bad4b8f0ace00e1f8f2cdea4bdacee4c90882" translate="yes" xml:space="preserve">
          <source>By default when the C++ frontend prints diagnostics showing mismatching template types, common parts of the types are printed as &amp;ldquo;[...]&amp;rdquo; to simplify the error message. For example:</source>
          <target state="translated">기본적으로 C ++ 프론트 엔드에서 일치하지 않는 템플리트 유형을 표시하는 진단을 인쇄 할 때 오류 메시지를 단순화하기 위해 유형의 공통 부분이 &quot;[...]&quot;로 인쇄됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e5c0fdbe4acada00b33542c8af5765b2142c6787" translate="yes" xml:space="preserve">
          <source>By default, GCC also provides some additional extensions to the C++ language that on rare occasions conflict with the C++ standard. See &lt;a href=&quot;c_002b_002b-dialect-options#C_002b_002b-Dialect-Options&quot;&gt;Options Controlling C++ Dialect&lt;/a&gt;. Use of the</source>
          <target state="translated">기본적으로 GCC는 드문 경우지만 C ++ 표준과 충돌하는 C ++ 언어에 대한 추가 확장을 제공합니다. &lt;a href=&quot;c_002b_002b-dialect-options#C_002b_002b-Dialect-Options&quot;&gt;C ++ 방언 제어 옵션을&lt;/a&gt; 참조하십시오 . 의 사용</target>
        </trans-unit>
        <trans-unit id="1b721c8be1fed47cd95a2b324cc0ec1f3f3fd2db" translate="yes" xml:space="preserve">
          <source>By default, GCC emits an error message if the feedback profiles do not match the source code. This error can be turned into a warning by using</source>
          <target state="translated">피드백 프로파일이 소스 코드와 일치하지 않으면 기본적으로 GCC는 오류 메시지를 표시합니다. 이 오류는 다음을 사용하여 경고로 바뀔 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68205120aabfb538f7bc7f4202c9b447a1cf9091" translate="yes" xml:space="preserve">
          <source>By default, GCC generates a branch hint instruction to avoid pipeline stalls for always-taken or probably-taken branches. A hint is not generated closer than 8 instructions away from its branch. There is little reason to disable them, except for debugging purposes, or to make an object a little bit smaller.</source>
          <target state="translated">기본적으로 GCC는 분기 또는 분기 분기에 대한 파이프 라인 중단을 피하기 위해 분기 힌트 명령어를 생성합니다. 힌트는 브랜치에서 멀리 떨어진 8 개 명령 이상으로 생성되지 않습니다. 디버깅 목적을 제외하고 객체를 약간 작게 만드는 것을 제외하고는 비활성화 할 이유가 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="0f0fae0fc27ffb4e00a4f068905f564a20595bd8" translate="yes" xml:space="preserve">
          <source>By default, GCC generates code assuming that addresses are never larger than 18 bits. With</source>
          <target state="translated">기본적으로 GCC는 주소가 18 비트보다 크지 않다고 가정하여 코드를 생성합니다. 와</target>
        </trans-unit>
        <trans-unit id="bfc14d5fdff5ebfd96cb93f60f01d2cd55db824a" translate="yes" xml:space="preserve">
          <source>By default, GCC ignores trigraphs, but in standard-conforming modes it converts them. See the</source>
          <target state="translated">기본적으로 GCC는 3 점을 무시하지만 표준 준수 모드에서는 3 점을 변환합니다. 참조</target>
        </trans-unit>
        <trans-unit id="7b2b09a4a457e7ae05463c18b24ed251756826ce" translate="yes" xml:space="preserve">
          <source>By default, GCC inserts NOPs to increase dual issue when it expects it to increase performance. &lt;var&gt;n&lt;/var&gt; can be a value from 0 to 10. A smaller &lt;var&gt;n&lt;/var&gt; inserts fewer NOPs. 10 is the default, 0 is the same as</source>
          <target state="translated">기본적으로 GCC는 NOP를 삽입하여 성능을 향상시킬 것으로 예상되는 경우 이중 문제를 증가시킵니다. &lt;var&gt;n&lt;/var&gt; 은 0에서 10 사이의 값일 수 있습니다 . &lt;var&gt;n&lt;/var&gt; 이 작을수록 NOP가 적습니다. 10은 기본값이고 0은</target>
        </trans-unit>
        <trans-unit id="fb6ff38e6ed640debf4ee9a5067811f24a626ac7" translate="yes" xml:space="preserve">
          <source>By default, GCC limits the size of functions that can be inlined. This flag allows coarse control of this limit. &lt;var&gt;n&lt;/var&gt; is the size of functions that can be inlined in number of pseudo instructions.</source>
          <target state="translated">기본적으로 GCC는 인라인 될 수있는 기능의 크기를 제한합니다. 이 플래그를 사용하면이 제한을 대략적으로 제어 할 수 있습니다. &lt;var&gt;n&lt;/var&gt; 은 여러 의사 명령어로 인라인 될 수있는 함수의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="9bf107b2c0510e1f5a934dedd69183ab9f3da713" translate="yes" xml:space="preserve">
          <source>By default, GCC links against startup code that assumes the SPU-style main function interface (which has an unconventional parameter list). With</source>
          <target state="translated">기본적으로 GCC는 SPU 스타일의 주 기능 인터페이스 (전통적인 매개 변수 목록이 있음)를 가정하는 시작 코드와 연결됩니다. 와</target>
        </trans-unit>
        <trans-unit id="7b2fda2cbe2c03ae974fe1e7172dd8c82c7ece3a" translate="yes" xml:space="preserve">
          <source>By default, GCC provides some extensions to the C language that, on rare occasions conflict with the C standard. See &lt;a href=&quot;c-extensions#C-Extensions&quot;&gt;Extensions to the C Language Family&lt;/a&gt;. Some features that are part of the C99 standard are accepted as extensions in C90 mode, and some features that are part of the C11 standard are accepted as extensions in C90 and C99 modes. Use of the</source>
          <target state="translated">기본적으로 GCC는 C 언어에 대한 일부 확장을 제공하며 드문 경우에 C 표준과 충돌합니다. &lt;a href=&quot;c-extensions#C-Extensions&quot;&gt;C 언어 제품군으로의 확장을&lt;/a&gt; 참조하십시오 . C99 표준의 일부인 일부 기능은 C90 모드에서 확장으로 허용되고 C11 표준의 일부인 일부 기능은 C90 및 C99 모드에서 확장으로 허용됩니다. 의 사용</target>
        </trans-unit>
        <trans-unit id="9893f2e72481c2382557fc2f081ec3a8e97bc79b" translate="yes" xml:space="preserve">
          <source>By default, an edge in this graph can contain the effects of a run of multiple statements within a basic block. With</source>
          <target state="translated">기본적으로이 그래프의 간선에는 기본 블록 내에서 여러 명령문 실행의 효과가 포함될 수 있습니다. 와</target>
        </trans-unit>
        <trans-unit id="2e7c9e5570dcde91269bdc30909a64efa434ef4f" translate="yes" xml:space="preserve">
          <source>By default, each diagnostic emitted includes text indicating the command-line option that directly controls the diagnostic (if such an option is known to the diagnostic machinery). Specifying the</source>
          <target state="translated">기본적으로 방출되는 각 진단에는 진단을 직접 제어하는 ​​명령 줄 옵션을 나타내는 텍스트가 포함됩니다 (이러한 옵션이 진단 장치에 알려진 경우). 지정</target>
        </trans-unit>
        <trans-unit id="6a4309cf8cee66811505f90edea42d61f9045107" translate="yes" xml:space="preserve">
          <source>By default, each diagnostic emitted includes the original source line and a caret &amp;lsquo;</source>
          <target state="translated">기본적으로 방출되는 각 진단에는 원본 소스 라인과 캐럿 '</target>
        </trans-unit>
        <trans-unit id="bac331913dd18e98186423b1f11ca77a9b8683cf" translate="yes" xml:space="preserve">
          <source>By default, no debug information is produced for symbols that are not actually used. Use this option if you want debug information for all symbols.</source>
          <target state="translated">기본적으로 실제로 사용되지 않는 기호에 대해서는 디버그 정보가 생성되지 않습니다. 모든 기호에 대한 디버그 정보를 원하는 경우이 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7763701cba03a5661d0405bf0959714c47202a4e" translate="yes" xml:space="preserve">
          <source>By default, only &amp;ldquo;high-level&amp;rdquo; messages are emitted. This option enables additional, more detailed, messages, which are likely to only be of interest to GCC developers.</source>
          <target state="translated">기본적으로 &quot;높은 수준&quot;메시지 만 표시됩니다. 이 옵션을 사용하면 GCC 개발자에게만 관심이있는보다 자세한 추가 메시지를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98a82faa0eba738f33fea70355cca2f77f4d752d" translate="yes" xml:space="preserve">
          <source>By default, the analysis silently stops if the code is too complicated for the analyzer to fully explore and it reaches an internal limit. The</source>
          <target state="translated">기본적으로 분석기가 완전히 탐색하기에는 코드가 너무 복잡하고 내부 한계에 도달하면 분석이 자동으로 중지됩니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="7d31796fedde16b57588ddd5284b3abd8463c996" translate="yes" xml:space="preserve">
          <source>By default, the assembler file name for a source file is made by replacing the suffix &amp;lsquo;</source>
          <target state="translated">기본적으로 소스 파일의 어셈블러 파일 이름은 접미사 '</target>
        </trans-unit>
        <trans-unit id="10caadf2568f37c4e4608d0c62719e2855118ce6" translate="yes" xml:space="preserve">
          <source>By default, the dump will contain messages about successful optimizations (equivalent to</source>
          <target state="translated">기본적으로 덤프에는 성공적인 최적화에 대한 메시지가 포함됩니다 (</target>
        </trans-unit>
        <trans-unit id="ae9a2b16ff551e2f7ff627c2fd6228056bed25a8" translate="yes" xml:space="preserve">
          <source>By default, the keyword &lt;code&gt;__vector&lt;/code&gt; is added. The macro &lt;code&gt;vector&lt;/code&gt; is defined in &lt;code&gt;&amp;lt;spu_intrinsics.h&amp;gt;&lt;/code&gt; and can be undefined.</source>
          <target state="translated">기본적으로 키워드 &lt;code&gt;__vector&lt;/code&gt; 가 추가됩니다. 매크로 &lt;code&gt;vector&lt;/code&gt; 는 &lt;code&gt;&amp;lt;spu_intrinsics.h&amp;gt;&lt;/code&gt; 에 정의되어 있으며 정의 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b102924aa2fe89599576741a2bd8c5becb0889f6" translate="yes" xml:space="preserve">
          <source>By default, the object file name for a source file is made by replacing the suffix &amp;lsquo;</source>
          <target state="translated">기본적으로 소스 파일의 오브젝트 파일 이름은 접미사 '</target>
        </trans-unit>
        <trans-unit id="4e689c10c02894b0d8e0dcec9a7f6bd5f47a0486" translate="yes" xml:space="preserve">
          <source>By default, when printing source code (via</source>
          <target state="translated">기본적으로 소스 코드를 인쇄 할 때</target>
        </trans-unit>
        <trans-unit id="f618b8855eb83706e0dd5ba4b20f8784c6acdce1" translate="yes" xml:space="preserve">
          <source>Byte swap. Return the result of swapping the upper and lower bytes of &lt;var&gt;value&lt;/var&gt;.</source>
          <target state="translated">바이트 스왑. &lt;var&gt;value&lt;/var&gt; 의 상위 및 하위 바이트를 교체 한 결과를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="32096c2e0eff33d844ee6d675407ace18289357d" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>
        </trans-unit>
        <trans-unit id="8c7f20acc9bb2d58739f2e1f94cb9494f549d093" translate="yes" xml:space="preserve">
          <source>C Language Options</source>
          <target state="translated">C 언어 옵션</target>
        </trans-unit>
        <trans-unit id="4f2345e5746cc2edc7fabec343cb3f91233c3786" translate="yes" xml:space="preserve">
          <source>C and Objective-C-only Warning Options</source>
          <target state="translated">C 및 Objective-C 전용 경고 옵션</target>
        </trans-unit>
        <trans-unit id="a16bcf14a78c44b6bfc6c36207ff504cb459f2ef" translate="yes" xml:space="preserve">
          <source>C code</source>
          <target state="translated">C 코드</target>
        </trans-unit>
        <trans-unit id="43bd1aa29c2f227114eb9168f3aeb20a853ce287" translate="yes" xml:space="preserve">
          <source>C contains many standard functions that return a value that most programs choose to ignore. One obvious example is &lt;code&gt;printf&lt;/code&gt;. Warning about this practice only leads the defensive programmer to clutter programs with dozens of casts to &lt;code&gt;void&lt;/code&gt;. Such casts are required so frequently that they become visual noise. Writing those casts becomes so automatic that they no longer convey useful information about the intentions of the programmer. For functions where the return value should never be ignored, use the &lt;code&gt;warn_unused_result&lt;/code&gt; function attribute (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;).</source>
          <target state="translated">C에는 대부분의 프로그램이 무시하기로 선택한 값을 반환하는 많은 표준 함수가 포함되어 있습니다. 한 가지 분명한 예는 &lt;code&gt;printf&lt;/code&gt; 입니다. 이러한 행위에 대해 경고 만에 캐스트 수십 혼란 프로그램에 대한 방어 프로그래머 리드 &lt;code&gt;void&lt;/code&gt; . 이러한 캐스트는 시각 노이즈가되기 위해 너무 자주 요구됩니다. 이러한 캐스트를 작성하면 프로그래머의 의도에 대한 유용한 정보를 더 이상 전달할 수 없게됩니다. 리턴 값을 무시해서는 &lt;code&gt;warn_unused_result&lt;/code&gt; 함수의 경우 warn_unused_result 함수 속성을 사용 하십시오 ( &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;함수 속성&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="b3d334ba58e80b66d4161266b799ef1fa9dce232" translate="yes" xml:space="preserve">
          <source>C flag clear or unsigned less than</source>
          <target state="translated">C 플래그 지우기 또는 부호 없음</target>
        </trans-unit>
        <trans-unit id="aa17b2be06e6856744ee3e4f2479342954c18298" translate="yes" xml:space="preserve">
          <source>C flag set or unsigned greater than equal</source>
          <target state="translated">C 플래그가 설정되었거나 같지 않은 부호 없음</target>
        </trans-unit>
        <trans-unit id="6cc85e5ef0494952e2e594d8f572f0cb62561829" translate="yes" xml:space="preserve">
          <source>C has the concept of volatile objects. These are normally accessed by pointers and used for accessing hardware or inter-thread communication. The standard encourages compilers to refrain from optimizations concerning accesses to volatile objects, but leaves it implementation defined as to what constitutes a volatile access. The minimum requirement is that at a sequence point all previous accesses to volatile objects have stabilized and no subsequent accesses have occurred. Thus an implementation is free to reorder and combine volatile accesses that occur between sequence points, but cannot do so for accesses across a sequence point. The use of volatile does not allow you to violate the restriction on updating objects multiple times between two sequence points.</source>
          <target state="translated">C는 휘발성 객체의 개념을 가지고 있습니다. 이들은 일반적으로 포인터에 의해 액세스되며 하드웨어 또는 스레드 간 통신에 액세스하는 데 사용됩니다. 이 표준은 컴파일러가 휘발성 객체에 대한 액세스와 관련된 최적화를 자제하도록 권장하지만, 휘발성 액세스를 구성하는 요소에 대해 정의 된 구현을 유지합니다. 최소 요구 사항은 시퀀스 지점에서 휘발성 개체에 대한 이전의 모든 액세스가 안정화되고 후속 액세스가 발생하지 않은 것입니다. 따라서 구현은 시퀀스 포인트 사이에서 발생하는 휘발성 액세스를 자유롭게 재정렬하고 결합 할 수 있지만 시퀀스 포인트를 통한 액세스에는 그렇게 할 수 없습니다. 휘발성을 사용하면 두 시퀀스 포인트 사이에서 객체를 여러 번 업데이트하는 데 대한 제한을 위반할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c49f69bf7866959fd041d254d44ecd95bab5ba98" translate="yes" xml:space="preserve">
          <source>C register.</source>
          <target state="translated">C 레지스터.</target>
        </trans-unit>
        <trans-unit id="2327d3d6eb8a5f7ce91755caf9e65d7a2e7dc1de" translate="yes" xml:space="preserve">
          <source>C source code that must be preprocessed.</source>
          <target state="translated">전처리해야하는 C 소스 코드.</target>
        </trans-unit>
        <trans-unit id="61f8a2e0d02a243e776c6bb9750832b606cb81e5" translate="yes" xml:space="preserve">
          <source>C source code that should not be preprocessed.</source>
          <target state="translated">전처리해서는 안되는 C 소스 코드.</target>
        </trans-unit>
        <trans-unit id="11548c240585bf5af759bc0a6b301b88b353e27e" translate="yes" xml:space="preserve">
          <source>C++ Language Options</source>
          <target state="translated">C ++ 언어 옵션</target>
        </trans-unit>
        <trans-unit id="57f68a93b1bb79e369d8676d696444f1cbbc7bb2" translate="yes" xml:space="preserve">
          <source>C++ comments are recognized.</source>
          <target state="translated">C ++ 주석이 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="7f61cc8037210ca9970d93d649a42c41aee100de" translate="yes" xml:space="preserve">
          <source>C++ concepts provide much-improved support for generic programming. In particular, they allow the specification of constraints on template arguments. The constraints are used to extend the usual overloading and partial specialization capabilities of the language, allowing generic data structures and algorithms to be &amp;ldquo;refined&amp;rdquo; based on their properties rather than their type names.</source>
          <target state="translated">C ++ 개념은 일반 프로그래밍에 대한 개선 된 지원을 제공합니다. 특히 템플릿 인수에 대한 제약 조건을 지정할 수 있습니다. 제약 조건은 언어의 일반적인 오버로딩 및 부분 특수화 기능을 확장하는 데 사용되므로 일반 데이터 구조 및 알고리즘을 유형 이름이 아닌 속성을 기반으로 &quot;정의&quot;할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98cd14ec337b46f3c719029c11a0be19021fb2b8" translate="yes" xml:space="preserve">
          <source>C++ header file to be turned into a precompiled header or Ada spec.</source>
          <target state="translated">미리 컴파일 된 헤더 또는 Ada 사양으로 변환 할 C ++ 헤더 파일</target>
        </trans-unit>
        <trans-unit id="f7bc99762b7f83b6b621c845d769390544ce75a0" translate="yes" xml:space="preserve">
          <source>C++ is a complex language and an evolving one, and its standard definition (the ISO C++ standard) was only recently completed. As a result, your C++ compiler may occasionally surprise you, even when its behavior is correct. This section discusses some areas that frequently give rise to questions of this sort.</source>
          <target state="translated">C ++는 복잡한 언어이며 진화하는 언어이며 표준 정의 (ISO C ++ 표준)는 최근에 완료되었습니다. 결과적으로 C ++ 컴파일러는 동작이 올바르더라도 놀라게 할 수 있습니다. 이 섹션에서는 이러한 종류의 질문을 자주 발생시키는 일부 영역에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="e84a747565fa51df782491a580d39e6a3f403239" translate="yes" xml:space="preserve">
          <source>C++ requires information about types to be written out in order to implement &amp;lsquo;</source>
          <target state="translated">C ++에서는 '을 구현하기 위해 형식에 대한 정보를 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="fda8008d202b2d7ff2b02b361c7ea913221a6d44" translate="yes" xml:space="preserve">
          <source>C++ source code that must be preprocessed. Note that in &amp;lsquo;</source>
          <target state="translated">사전 처리해야하는 C ++ 소스 코드. '에서</target>
        </trans-unit>
        <trans-unit id="99fa7c5a2c337828c11bc2c4ade3aae26a30fe89" translate="yes" xml:space="preserve">
          <source>C++ source code that should not be preprocessed.</source>
          <target state="translated">전처리해서는 안되는 C ++ 소스 코드.</target>
        </trans-unit>
        <trans-unit id="cc9e861072d065eff5c8caf3bd72ac42f37e3e61" translate="yes" xml:space="preserve">
          <source>C++ source files conventionally use one of the suffixes &amp;lsquo;</source>
          <target state="translated">C ++ 소스 파일은 일반적으로 접미사 중 하나를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e4d70d761fb7676ae22ebe197ff2d2dd053c553d" translate="yes" xml:space="preserve">
          <source>C++ templates were the first language feature to require more intelligence from the environment than was traditionally found on a UNIX system. Somehow the compiler and linker have to make sure that each template instance occurs exactly once in the executable if it is needed, and not at all otherwise. There are two basic approaches to this problem, which are referred to as the Borland model and the Cfront model.</source>
          <target state="translated">C ++ 템플릿은 UNIX 시스템에서 일반적으로 발견 된 것보다 환경에서 더 많은 정보를 요구하는 최초의 언어 기능이었습니다. 어떻게 든 컴파일러와 링커는 필요한 경우 각 템플릿 인스턴스가 실행 파일에서 정확히 한 번만 발생하는지 확인해야합니다. 이 문제에 대한 두 가지 기본 접근 방식이 있는데,이를 Borland 모델과 Cfront 모델이라고합니다.</target>
        </trans-unit>
        <trans-unit id="16bd188cbd64c4bf1a17218266102bf9d269e075" translate="yes" xml:space="preserve">
          <source>C++ virtual functions are implemented in most compilers using a lookup table, known as a vtable. The vtable contains pointers to the virtual functions provided by a class, and each object of the class contains a pointer to its vtable (or vtables, in some multiple-inheritance situations). If the class declares any non-inline, non-pure virtual functions, the first one is chosen as the &amp;ldquo;key method&amp;rdquo; for the class, and the vtable is only emitted in the translation unit where the key method is defined.</source>
          <target state="translated">C ++ 가상 함수는 vtable이라는 룩업 테이블을 사용하여 대부분의 컴파일러에서 구현됩니다. vtable에는 클래스가 제공하는 가상 함수에 대한 포인터가 포함되며 클래스의 각 객체에는 해당 vtable에 대한 포인터 (또는 여러 상속 상황에서 vtable)가 포함됩니다. 클래스가 인라인이 아닌 순수한 가상 함수를 선언하면 첫 번째 함수가 클래스의 &quot;키 메소드&quot;로 선택되고 vtable은 키 메소드가 정의 된 변환 단위에서만 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="17265012fdaf7b797d7862b29ff392331cd3a4a0" translate="yes" xml:space="preserve">
          <source>C++17 provides a standard way to suppress the</source>
          <target state="translated">C ++ 17은</target>
        </trans-unit>
        <trans-unit id="f78d571177e03968d05d81e87283c743f9bd11eb" translate="yes" xml:space="preserve">
          <source>C, C++, Objective-C or Objective-C++ header file to be turned into a precompiled header (default), or C, C++ header file to be turned into an Ada spec (via the</source>
          <target state="translated">사전 컴파일 된 헤더로 변환 될 C, C ++, Objective-C 또는 Objective-C ++ 헤더 파일 (기본값) 또는 Ada 스펙으로 변환 될 C, C ++ 헤더 파일 (</target>
        </trans-unit>
        <trans-unit id="6297518e9deb3ffb36cfb4da17e5731d4f43ddd3" translate="yes" xml:space="preserve">
          <source>C-EUCJP</source>
          <target state="translated">C-EUCJP</target>
        </trans-unit>
        <trans-unit id="fea2102020df627a3fcd18f01c6b90d1d1ebc0a5" translate="yes" xml:space="preserve">
          <source>C-JIS</source>
          <target state="translated">C-JIS</target>
        </trans-unit>
        <trans-unit id="8aed662488c94d21a572d72dd344a0c46e870bc0" translate="yes" xml:space="preserve">
          <source>C-SJIS</source>
          <target state="translated">C-SJIS</target>
        </trans-unit>
        <trans-unit id="e1c33b8c4686460cd515031a9d28c68a3cfcef87" translate="yes" xml:space="preserve">
          <source>C-SKY&amp;mdash;</source>
          <target state="translated">C-SKY&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="e66b4865aad9938d99c99c6f4ab23939ca58e09e" translate="yes" xml:space="preserve">
          <source>C99 Annex F is followed.</source>
          <target state="translated">C99 Annex F가 뒤 따릅니다.</target>
        </trans-unit>
        <trans-unit id="0817809900308ce7f22b686082215869550cf931" translate="yes" xml:space="preserve">
          <source>C99 restricted pointers and references.</source>
          <target state="translated">C99 제한 포인터 및 참조</target>
        </trans-unit>
        <trans-unit id="792d9ffa119c05fda74148cc441c8be905361027" translate="yes" xml:space="preserve">
          <source>CALL_INSN</source>
          <target state="translated">CALL_INSN</target>
        </trans-unit>
        <trans-unit id="a4c1d0441ce79e81e5b485ea5fcda7d1c56b743e" translate="yes" xml:space="preserve">
          <source>CB</source>
          <target state="translated">CB</target>
        </trans-unit>
        <trans-unit id="7c9c078a9c0f1169f25be27f38940093778bb37c" translate="yes" xml:space="preserve">
          <source>CET Function: ret_type &lt;strong id=&quot;index-_005fget_005fssp&quot;&gt;_get_ssp&lt;/strong&gt; (void)</source>
          <target state="translated">CET 함수 : ret_type &lt;strong id=&quot;index-_005fget_005fssp&quot;&gt;_get_ssp&lt;/strong&gt; (void)</target>
        </trans-unit>
        <trans-unit id="01ab10eefead0e21345d5d4e4f22d758ced4568b" translate="yes" xml:space="preserve">
          <source>CET Function: void &lt;strong id=&quot;index-_005finc_005fssp&quot;&gt;_inc_ssp&lt;/strong&gt; (unsigned int)</source>
          <target state="translated">CET 함수 : void &lt;strong id=&quot;index-_005finc_005fssp&quot;&gt;_inc_ssp&lt;/strong&gt; (부호없는 int)</target>
        </trans-unit>
        <trans-unit id="feca3790fce7c96d6df26540c7b4128215a81089" translate="yes" xml:space="preserve">
          <source>CMOV instruction.</source>
          <target state="translated">CMOV 명령.</target>
        </trans-unit>
        <trans-unit id="c2711a4d5237b1b481ba6a122e49ae7f80826ead" translate="yes" xml:space="preserve">
          <source>CPU does not have a timebase (eg, 601 and 403gx).</source>
          <target state="translated">CPU에는 타임베이스가 없습니다 (예 : 601 및 403gx).</target>
        </trans-unit>
        <trans-unit id="ca704ae8911deda5afe0231823961924eb739a85" translate="yes" xml:space="preserve">
          <source>CPU has a CELL broadband engine.</source>
          <target state="translated">CPU에는 CELL 광대역 엔진이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f3f4709b09760afc34be4c56dc4c6225a92c342" translate="yes" xml:space="preserve">
          <source>CPU has a SIMD/Vector Unit.</source>
          <target state="translated">CPU에는 SIMD / 벡터 장치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7513f4d098c1065cad2f73416dc6c7b6d28bb7ca" translate="yes" xml:space="preserve">
          <source>CPU has a SPE double precision floating point unit.</source>
          <target state="translated">CPU에는 SPE 배정도 부동 소수점 단위가 있습니다.</target>
        </trans-unit>
        <trans-unit id="249044ceb00915a3621d91cc9c9342822f5d3a2e" translate="yes" xml:space="preserve">
          <source>CPU has a SPE single precision floating point unit.</source>
          <target state="translated">CPU에는 SPE 단 정밀도 부동 소수점 단위가 있습니다.</target>
        </trans-unit>
        <trans-unit id="afc457a7d1f6c70e1a12a91ad1a70b454e13c88b" translate="yes" xml:space="preserve">
          <source>CPU has a decimal floating point unit.</source>
          <target state="translated">CPU에는 10 진 부동 소수점 단위가 있습니다.</target>
        </trans-unit>
        <trans-unit id="daecf052e0ef6eddacd32a707988a46a48b10a26" translate="yes" xml:space="preserve">
          <source>CPU has a floating point unit.</source>
          <target state="translated">CPU에는 부동 소수점 단위가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e350ba25d5b50e7eecaa8cd017e06461b70e0e96" translate="yes" xml:space="preserve">
          <source>CPU has a memory management unit.</source>
          <target state="translated">CPU에는 메모리 관리 장치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d25b3ec38c741ef05546cfa00487c01e86a288da" translate="yes" xml:space="preserve">
          <source>CPU has a signal processing extension unit.</source>
          <target state="translated">CPU에는 신호 처리 확장 장치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6cdbd18b45d3ceafe188679188c10b0e63fc06b" translate="yes" xml:space="preserve">
          <source>CPU has hardware transaction memory instructions.</source>
          <target state="translated">CPU에는 하드웨어 트랜잭션 메모리 명령이 있습니다.</target>
        </trans-unit>
        <trans-unit id="817e69cd99aa2fae8e8cb1ea4ccb1e7cade39e36" translate="yes" xml:space="preserve">
          <source>CPU has unified I/D cache.</source>
          <target state="translated">CPU가 I / D 캐시를 통합했습니다.</target>
        </trans-unit>
        <trans-unit id="a85030d258895560b198880492e35a8dc7104678" translate="yes" xml:space="preserve">
          <source>CPU support simultaneous multi-threading.</source>
          <target state="translated">CPU는 동시 멀티 스레딩을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="1fa8be29b90ade4bb4d6c9abca15ef4efb5cea12" translate="yes" xml:space="preserve">
          <source>CPU supports 128-bit IEEE binary floating point instructions.</source>
          <target state="translated">CPU는 128 비트 IEEE 이진 부동 소수점 명령어를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="d0ec10bc634bb744e9ff5bc9b6ccebe2f8a4c1fd" translate="yes" xml:space="preserve">
          <source>CPU supports 32-bit mode execution.</source>
          <target state="translated">CPU는 32 비트 모드 실행을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="c550c34cceac587d8bfa3d110ce84630536005e1" translate="yes" xml:space="preserve">
          <source>CPU supports 64-bit mode execution.</source>
          <target state="translated">CPU는 64 비트 모드 실행을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="969f1a1bfc594794e1d088866f33884cafe4c0a3" translate="yes" xml:space="preserve">
          <source>CPU supports ISA 2.00 (eg, POWER4)</source>
          <target state="translated">CPU는 ISA 2.00 (예 : POWER4)을 지원합니다</target>
        </trans-unit>
        <trans-unit id="f021a7b007d311f22fec3723c62516e8f3a0319b" translate="yes" xml:space="preserve">
          <source>CPU supports ISA 2.02 (eg, POWER5)</source>
          <target state="translated">CPU는 ISA 2.02 (예 : POWER5)를 지원합니다</target>
        </trans-unit>
        <trans-unit id="ee64c969eb8481f0eae6c612175233cd07361227" translate="yes" xml:space="preserve">
          <source>CPU supports ISA 2.03 (eg, POWER5+)</source>
          <target state="translated">CPU는 ISA 2.03 (예 : POWER5 +)을 지원합니다</target>
        </trans-unit>
        <trans-unit id="13964fdc29b60cfc0a706e4cb0569a01c55f1208" translate="yes" xml:space="preserve">
          <source>CPU supports ISA 2.05 (eg, POWER6)</source>
          <target state="translated">CPU는 ISA 2.05 (예 : POWER6)를 지원합니다</target>
        </trans-unit>
        <trans-unit id="4ba1460155478447375ae1fb486a30ad51582aec" translate="yes" xml:space="preserve">
          <source>CPU supports ISA 2.05 (eg, POWER6) extended opcodes mffgpr and mftgpr.</source>
          <target state="translated">CPU는 ISA 2.05 (예 : POWER6) 확장 opcode mffgpr 및 mftgpr을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="990b205fa1433a7d0dc63ad9070ee91af0800dd1" translate="yes" xml:space="preserve">
          <source>CPU supports ISA 2.06 (eg, POWER7)</source>
          <target state="translated">CPU는 ISA 2.06 (예 : POWER7)을 지원합니다</target>
        </trans-unit>
        <trans-unit id="6a9081f5b37e7737655ad795c102d5fe7087b65d" translate="yes" xml:space="preserve">
          <source>CPU supports ISA 2.07 (eg, POWER8)</source>
          <target state="translated">CPU는 ISA 2.07 (예 : POWER8)을 지원합니다</target>
        </trans-unit>
        <trans-unit id="dcf25ddc902c83eba265e85451df12c824bf2a7b" translate="yes" xml:space="preserve">
          <source>CPU supports ISA 3.0 (eg, POWER9)</source>
          <target state="translated">CPU는 ISA 3.0 (예 : POWER9)을 지원합니다</target>
        </trans-unit>
        <trans-unit id="6092133b8e23ee5373746ec5bc5db76ea54238a4" translate="yes" xml:space="preserve">
          <source>CPU supports ISA 3.1 (eg, POWER10)</source>
          <target state="translated">CPU는 ISA 3.1 (예 : POWER10)을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="055a8304e60c6c298c280b0809896894a417c35e" translate="yes" xml:space="preserve">
          <source>CPU supports a little-endian mode that uses address swizzling.</source>
          <target state="translated">CPU는 주소 스위 즐링을 사용하는 리틀 엔디안 모드를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="255ddfc220c178db8c2fdf2c3d887268be52afce" translate="yes" xml:space="preserve">
          <source>CPU supports event base branching.</source>
          <target state="translated">CPU는 이벤트 기반 분기를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="7a546c031cbdf8f942b2e95c5d11fb1b52e9cc57" translate="yes" xml:space="preserve">
          <source>CPU supports hardware transaction memory but does not support the &lt;code&gt;tsuspend.&lt;/code&gt; instruction.</source>
          <target state="translated">CPU는 하드웨어 트랜잭션 메모리를 지원하지만 &lt;code&gt;tsuspend.&lt;/code&gt; 는 지원하지 않습니다 . 교수.</target>
        </trans-unit>
        <trans-unit id="98cc31dee3a3972d6c8549b9b9d63935ff74bd07" translate="yes" xml:space="preserve">
          <source>CPU supports icache snooping capabilities.</source>
          <target state="translated">CPU는 icache 스누핑 기능을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="86a7a3dc0108d58ef63d3f6ab2c6e0a72b7c8029" translate="yes" xml:space="preserve">
          <source>CPU supports the &lt;code&gt;darn&lt;/code&gt; (deliver a random number) instruction.</source>
          <target state="translated">CPU는 &lt;code&gt;darn&lt;/code&gt; (난수 전달) 명령을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="77d7a3e63ab0326c7992c2322e10e155757df7b2" translate="yes" xml:space="preserve">
          <source>CPU supports the Embedded ISA category.</source>
          <target state="translated">CPU는 Embedded ISA 범주를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="c159e0e90690ac6c2f371b7dff8ce2db12767971" translate="yes" xml:space="preserve">
          <source>CPU supports the PA Semi 6T CORE ISA.</source>
          <target state="translated">CPU는 PA Semi 6T CORE ISA를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="2267dd90003bf8b5f66bba6f8158082ed6e95240" translate="yes" xml:space="preserve">
          <source>CPU supports the data stream control register.</source>
          <target state="translated">CPU는 데이터 스트림 제어 레지스터를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="45a297e9cc9f2eb5df0912ac8e91302da6382422" translate="yes" xml:space="preserve">
          <source>CPU supports the integer select instruction.</source>
          <target state="translated">CPU는 정수 선택 명령어를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="2e306759e72b16093678ea3f4c4c712cd49b17a9" translate="yes" xml:space="preserve">
          <source>CPU supports the matrix-multiply assist instructions.</source>
          <target state="translated">CPU는 행렬 곱하기 지원 명령을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="99a95efc8023d10b71a08bff59a8789aa22a0fb6" translate="yes" xml:space="preserve">
          <source>CPU supports the old POWER ISA (eg, 601)</source>
          <target state="translated">CPU는 기존 POWER ISA를 지원합니다 (예 : 601)</target>
        </trans-unit>
        <trans-unit id="309f8ee6774ef217dd65020d0047499e145915f8" translate="yes" xml:space="preserve">
          <source>CPU supports the set of compatible performance monitoring events.</source>
          <target state="translated">CPU는 호환 가능한 성능 모니터링 이벤트 세트를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="654d56ee4aa1191ad640c84c9cda741472551b11" translate="yes" xml:space="preserve">
          <source>CPU supports the target address register.</source>
          <target state="translated">CPU는 대상 주소 레지스터를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="2b74cd2604db8f416c0c904f549425dc7576345f" translate="yes" xml:space="preserve">
          <source>CPU supports the vector cryptography instructions.</source>
          <target state="translated">CPU는 벡터 암호화 명령어를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="2910c789b3b4293207054dd9a2e43cc18d433b78" translate="yes" xml:space="preserve">
          <source>CPU supports the vector-scalar extension.</source>
          <target state="translated">CPU는 벡터 스칼라 확장을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="41c99496e20c6a12697b36d694855c474afbe5bb" translate="yes" xml:space="preserve">
          <source>CPU supports true little-endian mode.</source>
          <target state="translated">CPU는 진정한 리틀 엔디안 모드를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="2ec7e4eb5fc127660ed425c7dcd89cd8eddc4bc5" translate="yes" xml:space="preserve">
          <source>CPUs based on AMD Family 10h cores with x86-64 instruction set support. (This supersets MMX, SSE, SSE2, SSE3, SSE4A, 3DNow!, enhanced 3DNow!, ABM and 64-bit instruction set extensions.)</source>
          <target state="translated">x86-64 명령어 세트를 지원하는 AMD 제품군 10h 코어 기반 CPU. (이것은 MMX, SSE, SSE2, SSE3, SSE4A, 3DNow !, 향상된 3DNow !, ABM 및 64 비트 명령어 세트 확장을 수퍼 셋합니다.)</target>
        </trans-unit>
        <trans-unit id="b84062366ba14fb3f3b6ff6b47d03c475a3828a9" translate="yes" xml:space="preserve">
          <source>CPUs based on AMD Family 14h cores with x86-64 instruction set support. (This supersets MMX, SSE, SSE2, SSE3, SSSE3, SSE4A, CX16, ABM and 64-bit instruction set extensions.)</source>
          <target state="translated">x86-64 명령어 세트를 지원하는 AMD 제품군 14h 코어 기반 CPU. (이것은 MMX, SSE, SSE2, SSE3, SSSE3, SSE4A, CX16, ABM 및 64 비트 명령어 세트 확장을 수퍼 셋합니다.)</target>
        </trans-unit>
        <trans-unit id="7cd17945f4d7f7d90dbb7eb4390b3e09de24051b" translate="yes" xml:space="preserve">
          <source>CPUs based on AMD Family 15h cores with x86-64 instruction set support. (This supersets FMA4, AVX, XOP, LWP, AES, PCLMUL, CX16, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM and 64-bit instruction set extensions.)</source>
          <target state="translated">x86-64 명령어 세트를 지원하는 AMD 제품군 15h 코어 기반 CPU. (이 수퍼 세트는 FMA4, AVX, XOP, LWP, AES, PCLMUL, CX16, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM 및 64 비트 명령어 세트 확장입니다.)</target>
        </trans-unit>
        <trans-unit id="113524bb3893cb5857442da17502358001cf141b" translate="yes" xml:space="preserve">
          <source>CPUs based on AMD Family 15h cores with x86-64 instruction set support. (This supersets FMA4, AVX, XOP, LWP, AES, PCL_MUL, CX16, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM and 64-bit instruction set extensions.)</source>
          <target state="translated">x86-64 명령어 세트를 지원하는 AMD 제품군 15h 코어 기반 CPU. (이것은 FMA4, AVX, XOP, LWP, AES, PCL_MUL, CX16, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM 및 64 비트 명령어 세트 확장을 수퍼 셋합니다.)</target>
        </trans-unit>
        <trans-unit id="de84db6df1b92636fc4cae8a7a0a74534cf2484c" translate="yes" xml:space="preserve">
          <source>CPUs based on AMD Family 16h cores with x86-64 instruction set support. This includes MOVBE, F16C, BMI, AVX, PCLMUL, AES, SSE4.2, SSE4.1, CX16, ABM, SSE4A, SSSE3, SSE3, SSE2, SSE, MMX and 64-bit instruction set extensions.</source>
          <target state="translated">x86-64 명령어 세트를 지원하는 AMD 제품군 16h 코어 기반 CPU. 여기에는 MOVBE, F16C, BMI, AVX, PCLMUL, AES, SSE4.2, SSE4.1, CX16, ABM, SSE4A, SSSE3, SSE3, SSE2, SSE, MMX 및 64 비트 명령어 세트 확장이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="47a0219528807f6268d19e1c7ca96f3e9c601c1e" translate="yes" xml:space="preserve">
          <source>CPUs based on AMD Family 16h cores with x86-64 instruction set support. This includes MOVBE, F16C, BMI, AVX, PCL_MUL, AES, SSE4.2, SSE4.1, CX16, ABM, SSE4A, SSSE3, SSE3, SSE2, SSE, MMX and 64-bit instruction set extensions.</source>
          <target state="translated">x86-64 명령어 세트를 지원하는 AMD 제품군 16h 코어 기반 CPU. 여기에는 MOVBE, F16C, BMI, AVX, PCL_MUL, AES, SSE4.2, SSE4.1, CX16, ABM, SSE4A, SSSE3, SSE3, SSE2, SSE, MMX 및 64 비트 명령어 세트 확장이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="762cf7076b068d306d32ea79b0d0e2277121f2b5" translate="yes" xml:space="preserve">
          <source>CR</source>
          <target state="translated">CR</target>
        </trans-unit>
        <trans-unit id="5e1fb0077df92097ce069aa21ed47aa03c3d5c5d" translate="yes" xml:space="preserve">
          <source>CR16 Architecture&amp;mdash;</source>
          <target state="translated">CR16 아키텍처</target>
        </trans-unit>
        <trans-unit id="f9c744e8c0ecb712753e6342db41d199b59d9bf6" translate="yes" xml:space="preserve">
          <source>CTR</source>
          <target state="translated">CTR</target>
        </trans-unit>
        <trans-unit id="58ad68590efc1385d2b4fd64a16b4b9f8cfaaa44" translate="yes" xml:space="preserve">
          <source>Call operand, const_int, for absolute calls.</source>
          <target state="translated">절대 호출을 위해 피연산자 const_int를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="3373e7e79f4085d8f7291896ef1d3760c15083be" translate="yes" xml:space="preserve">
          <source>Call operand, reg, for indirect calls</source>
          <target state="translated">간접 호출에 대한 호출 피연산자, reg</target>
        </trans-unit>
        <trans-unit id="3c51d11770c5ea3546c0d152d73faf160c859f37" translate="yes" xml:space="preserve">
          <source>Call operand, symbol, for relative calls.</source>
          <target state="translated">상대 호출에 대한 호출 피연산자, 기호.</target>
        </trans-unit>
        <trans-unit id="f0c515fe9bf062328bec62182c3bb93d352208ec" translate="yes" xml:space="preserve">
          <source>Call the named function &lt;var&gt;function&lt;/var&gt;, passing it &lt;var&gt;args&lt;/var&gt;. &lt;var&gt;args&lt;/var&gt; is first processed as a nested spec string, then split into an argument vector in the usual fashion. The function returns a string which is processed as if it had appeared literally as part of the current spec.</source>
          <target state="translated">명명 된 함수 &lt;var&gt;function&lt;/var&gt; 호출하여 &lt;var&gt;args&lt;/var&gt; 를 전달합니다 . &lt;var&gt;args&lt;/var&gt; 는 먼저 중첩 된 스펙 문자열로 처리 된 다음 일반적인 방식으로 인수 벡터로 분할됩니다. 이 함수는 문자 그대로 현재 사양의 일부로 나타난 것처럼 처리되는 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4b1ccc6ccff0a4b4d69b01f9c83e0859c8e4f058" translate="yes" xml:space="preserve">
          <source>Calling conventions are a subset of an ABI that specify of how arguments are passed and function results are returned.</source>
          <target state="translated">호출 규칙은 인수가 전달되고 함수 결과가 반환되는 방식을 지정하는 ABI의 하위 집합입니다.</target>
        </trans-unit>
        <trans-unit id="8e13d2ff4cf44ed7d75b8cee9472ba906dfafd20" translate="yes" xml:space="preserve">
          <source>Calling this function with a nonzero argument can have unpredictable effects, including crashing the calling program. As a result, calls that are considered unsafe are diagnosed when the</source>
          <target state="translated">0이 아닌 인수로이 함수를 호출하면 호출 프로그램의 크래쉬를 포함하여 예측할 수없는 결과가 발생할 수 있습니다. 결과적으로 안전하지 않은 것으로 간주되는 통화는</target>
        </trans-unit>
        <trans-unit id="fc12921ff6d4899e4dc68b34cc1cd37e3157e57e" translate="yes" xml:space="preserve">
          <source>Calls a library function that performs the operation in double precision floating point. Division by zero causes a floating-point exception. This is the default for SHcompact with FPU. Specifying this for targets that do not have a double precision FPU defaults to &lt;code&gt;call-div1&lt;/code&gt;.</source>
          <target state="translated">배정 밀도 부동 소수점에서 연산을 수행하는 라이브러리 함수를 호출합니다. 0으로 나누면 부동 소수점 예외가 발생합니다. 이것이 FPU를 사용한 SHcompact의 기본값입니다. 배정 밀도 FPU가없는 대상에 대해이를 지정하면 기본값은 &lt;code&gt;call-div1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="29e8cd2fa85f5515142e26b60a518bb56cd4bcb6" translate="yes" xml:space="preserve">
          <source>Calls a library function that uses a lookup table for small divisors and the &lt;code&gt;div1&lt;/code&gt; instruction with case distinction for larger divisors. Division by zero calculates an unspecified result and does not trap. This is the default for SH4. Specifying this for targets that do not have dynamic shift instructions defaults to &lt;code&gt;call-div1&lt;/code&gt;.</source>
          <target state="translated">작은 제수의 경우 찾아보기 테이블을 사용하고 큰 제수의 경우 대소 문자를 구분 하는 &lt;code&gt;div1&lt;/code&gt; 명령어 를 사용하는 라이브러리 함수를 호출합니다 . 0으로 나누기는 지정되지 않은 결과를 계산하고 트랩하지 않습니다. 이것이 SH4의 기본값입니다. 동적 이동 명령이없는 대상에 대해이를 지정하면 기본값은 &lt;code&gt;call-div1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b66ee13b0a48eb1333567adb5302965969bbf50a" translate="yes" xml:space="preserve">
          <source>Calls a library function that uses the single-step division instruction &lt;code&gt;div1&lt;/code&gt; to perform the operation. Division by zero calculates an unspecified result and does not trap. This is the default except for SH4, SH2A and SHcompact.</source>
          <target state="translated">단일 단계 나누기 명령어 &lt;code&gt;div1&lt;/code&gt; 을 사용하여 작업을 수행 하는 라이브러리 함수를 호출합니다 . 0으로 나누기는 지정되지 않은 결과를 계산하고 트랩하지 않습니다. SH4, SH2A 및 SHcompact를 제외한 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="b45cc51de5de6fd998285ffd2412d7b2646d5ad0" translate="yes" xml:space="preserve">
          <source>Calls to &lt;code&gt;foo&lt;/code&gt; are mapped to calls to &lt;code&gt;foo{20040821}&lt;/code&gt;.</source>
          <target state="translated">에 전화 &lt;code&gt;foo&lt;/code&gt; 는이 호출에 매핑되는 &lt;code&gt;foo{20040821}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="293878ce1781e2ea1bacb79578feb3fbe4be3315" translate="yes" xml:space="preserve">
          <source>Calls to external functions with this attribute must return to the current compilation unit only by return or by exception handling. In particular, a leaf function is not allowed to invoke callback functions passed to it from the current compilation unit, directly call functions exported by the unit, or &lt;code&gt;longjmp&lt;/code&gt; into the unit. Leaf functions might still call functions from other compilation units and thus they are not necessarily leaf in the sense that they contain no function calls at all.</source>
          <target state="translated">이 속성을 가진 외부 함수에 대한 호출은 리턴 또는 예외 처리를 통해서만 현재 컴파일 단위로 리턴해야합니다. 특히 리프 함수는 현재 컴파일 단위에서 전달 된 콜백 함수를 호출하거나 장치에서 내 보낸 함수를 직접 호출하거나 단위로 &lt;code&gt;longjmp&lt;/code&gt; 를 호출 할 수 없습니다 . 리프 함수는 여전히 다른 컴파일 단위의 함수를 호출 할 수 있으므로 함수 호출이 전혀 없다는 의미에서 반드시 리프 일 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="4271715ba8546178ce2b0fafe7396f6340205ed7" translate="yes" xml:space="preserve">
          <source>Calls to functions that have no observable effects on the state of the program other than to return a value may lend themselves to optimizations such as common subexpression elimination. Declaring such functions with the &lt;code&gt;pure&lt;/code&gt; attribute allows GCC to avoid emitting some calls in repeated invocations of the function with the same argument values.</source>
          <target state="translated">값을 반환하는 것 이외의 다른 프로그램 상태에 영향을 미치지 않는 함수를 호출하면 일반적인 하위 표현식 제거와 같은 최적화에 적합 할 수 있습니다. &lt;code&gt;pure&lt;/code&gt; 속성으로 이러한 함수를 선언 하면 GCC는 동일한 인수 값으로 함수를 반복적으로 호출 할 때 일부 호출이 발생하지 않도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b52d0ab938b444cac1b9e9d1c160806cd6da345" translate="yes" xml:space="preserve">
          <source>Calls to functions whose return value is not affected by changes to the observable state of the program and that have no observable effects on such state other than to return a value may lend themselves to optimizations such as common subexpression elimination. Declaring such functions with the &lt;code&gt;const&lt;/code&gt; attribute allows GCC to avoid emitting some calls in repeated invocations of the function with the same argument values.</source>
          <target state="translated">반환 값이 프로그램의 관찰 가능한 상태 변경에 의해 영향을받지 않고 값을 반환하는 것 이외의 상태에 대해 관찰 가능한 영향이없는 함수를 호출하면 일반적인 하위 표현식 제거와 같은 최적화에 적합 할 수 있습니다. &lt;code&gt;const&lt;/code&gt; 속성을 사용 하여 이러한 함수를 선언 하면 GCC는 동일한 인수 값으로 함수를 반복적으로 호출 할 때 일부 호출이 발생하지 않도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8eba46ecad008a4e218a210a71672db04d7e157" translate="yes" xml:space="preserve">
          <source>Cancel an assertion with the predicate &lt;var&gt;predicate&lt;/var&gt; and answer &lt;var&gt;answer&lt;/var&gt;.</source>
          <target state="translated">술어 &lt;var&gt;predicate&lt;/var&gt; 로 어설 션을 취소 하고 응답을 &lt;var&gt;answer&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="59d15eea66865b0282cb17c0e3120ed653071f95" translate="yes" xml:space="preserve">
          <source>Cancel any previous definition of &lt;var&gt;name&lt;/var&gt;, either built in or provided with a</source>
          <target state="translated">내장 또는 제공되는 &lt;var&gt;name&lt;/var&gt; 의 이전 정의를 취소하십시오 .</target>
        </trans-unit>
        <trans-unit id="192387cfc73b539ff900c725ddee4d021db73db5" translate="yes" xml:space="preserve">
          <source>Casting to union type from any member of the union.</source>
          <target state="translated">노조 구성원으로부터 노조 유형으로 캐스팅.</target>
        </trans-unit>
        <trans-unit id="b08eca4544a17d0207cde77668a933d9951e246a" translate="yes" xml:space="preserve">
          <source>Cause gas to print out tomcat statistics.</source>
          <target state="translated">가스가 바람둥이 통계를 출력하게합니다.</target>
        </trans-unit>
        <trans-unit id="5a1bd09378f19d49cb410444dadaeb9f88738a8a" translate="yes" xml:space="preserve">
          <source>Cause the errors having to do with files that have the wrong architecture to be fatal.</source>
          <target state="translated">잘못된 아키텍처를 가진 파일과 관련된 오류가 치명적일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5019333f8c270c0e57b171951e0397047e39d35e" translate="yes" xml:space="preserve">
          <source>Causes GCC to remember the state of the diagnostics as of each &lt;code&gt;push&lt;/code&gt;, and restore to that point at each &lt;code&gt;pop&lt;/code&gt;. If a &lt;code&gt;pop&lt;/code&gt; has no matching &lt;code&gt;push&lt;/code&gt;, the command-line options are restored.</source>
          <target state="translated">GCC가 각 &lt;code&gt;push&lt;/code&gt; 시점 의 진단 상태를 기억하고 각 &lt;code&gt;pop&lt;/code&gt; 에서 해당 지점으로 복원합니다 . 경우 &lt;code&gt;pop&lt;/code&gt; 일치가없는 &lt;code&gt;push&lt;/code&gt; 명령 줄 옵션이 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="667cccec716e1283ccef9e29985511e0bdf9e0a0" translate="yes" xml:space="preserve">
          <source>Causes all functions to default to the &lt;code&gt;.far&lt;/code&gt; section. Without this option, functions default to the &lt;code&gt;.near&lt;/code&gt; section.</source>
          <target state="translated">모든 기능이 &lt;code&gt;.far&lt;/code&gt; 섹션 으로 기본 설정됩니다 . 이 옵션이 없으면 기능은 기본적으로 &lt;code&gt;.near&lt;/code&gt; 섹션입니다.</target>
        </trans-unit>
        <trans-unit id="e30905206e2b1ac1064f6ac3bbe5bd6c803a6b79" translate="yes" xml:space="preserve">
          <source>Causes all variables to default to the &lt;code&gt;.tiny&lt;/code&gt; section. Note that there is a 65536-byte limit to this section. Accesses to these variables use the &lt;code&gt;%gp&lt;/code&gt; base register.</source>
          <target state="translated">모든 변수의 기본값은 &lt;code&gt;.tiny&lt;/code&gt; 섹션입니다. 이 섹션에는 65536 바이트 제한이 있습니다. 이러한 변수에 대한 액세스는 &lt;code&gt;%gp&lt;/code&gt; 기본 레지스터를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="98be0c7de301463de1c80070885a43330018a0b2" translate="yes" xml:space="preserve">
          <source>Causes constant variables to be placed in the &lt;code&gt;.near&lt;/code&gt; section.</source>
          <target state="translated">상수 변수를 &lt;code&gt;.near&lt;/code&gt; 섹션에 배치 합니다.</target>
        </trans-unit>
        <trans-unit id="655599ac8eaa0291e221b62364ffdf96a51309de" translate="yes" xml:space="preserve">
          <source>Causes the output file to be marked such that the dynamic linker will bind all undefined references when the file is loaded or launched.</source>
          <target state="translated">파일이로드되거나 시작될 때 동적 링커가 정의되지 않은 모든 참조를 바인딩하도록 출력 파일이 표시되도록합니다.</target>
        </trans-unit>
        <trans-unit id="c48452dfc4582d4eee857576d8fb13bb7694884b" translate="yes" xml:space="preserve">
          <source>Causes variables to be assigned to the &lt;code&gt;.far&lt;/code&gt; section by default.</source>
          <target state="translated">기본적으로 변수가 &lt;code&gt;.far&lt;/code&gt; 섹션에 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="13cb136a09a7c1b01f2dc417dcf7c22b8038c03d" translate="yes" xml:space="preserve">
          <source>Causes variables to be assigned to the &lt;code&gt;.near&lt;/code&gt; section by default.</source>
          <target state="translated">기본적으로 변수가 &lt;code&gt;.near&lt;/code&gt; 섹션에 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="efdb8f56a4df91a529ce6b66e59857019a48ac1f" translate="yes" xml:space="preserve">
          <source>Certain ABI-changing flags are required to match in all compilation units, and trying to override this at link time with a conflicting value is ignored. This includes options such as</source>
          <target state="translated">모든 컴파일 단위에서 일치하는 특정 ABI 변경 플래그가 필요하며 링크 시간에 충돌하는 값으로이를 대체하려는 시도는 무시됩니다. 여기에는 다음과 같은 옵션이 포함됩니다</target>
        </trans-unit>
        <trans-unit id="a8db3b10d95cbc07c88dbe64efa680baa0d22c3b" translate="yes" xml:space="preserve">
          <source>Certain local variables aren&amp;rsquo;t recognized by debuggers when you compile with optimization.</source>
          <target state="translated">최적화를 사용하여 컴파일 할 때 디버거가 특정 로컬 변수를 인식하지 못합니다.</target>
        </trans-unit>
        <trans-unit id="be7c527dd55f67d739c97b4f416bd42f396b0844" translate="yes" xml:space="preserve">
          <source>Cfront model</source>
          <target state="translated">정면 모델</target>
        </trans-unit>
        <trans-unit id="1aba59b0fc2fb3ed3ce5d3423cf83addc1f152f7" translate="yes" xml:space="preserve">
          <source>Change ABI to use double word insns.</source>
          <target state="translated">이중 단어 insns를 사용하도록 ABI를 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="9f8ed70cb1d356e0b695cceb7ab02d866b216534" translate="yes" xml:space="preserve">
          <source>Change paragraph 1</source>
          <target state="translated">단락 1 변경</target>
        </trans-unit>
        <trans-unit id="3cb692fbb429d564d86c14c1772ab21a4cec5d73" translate="yes" xml:space="preserve">
          <source>Change paragraph 2</source>
          <target state="translated">단락 2 변경</target>
        </trans-unit>
        <trans-unit id="9b9fbfc9cacb726e629a9636bbe98d28a8d83b9b" translate="yes" xml:space="preserve">
          <source>Change paragraph 2 to</source>
          <target state="translated">단락 2를</target>
        </trans-unit>
        <trans-unit id="cb241f39f5fa8625fba68e7d9da30611af7534b7" translate="yes" xml:space="preserve">
          <source>Change the current ABI to use IBM extended-precision long double. This is not likely to work if your system defaults to using IEEE extended-precision long double. If you change the long double type from IEEE extended-precision, the compiler will issue a warning unless you use the</source>
          <target state="translated">IBM 확장 정밀도 long double을 사용하도록 현재 ABI를 변경하십시오. 시스템이 IEEE 확장 정밀 long double을 기본으로 사용하는 경우에는 작동하지 않을 수 있습니다. IEEE 확장 정밀도에서 long double 유형을 변경하면 컴파일러에서</target>
        </trans-unit>
        <trans-unit id="8b05bb4515e125b765f13f146e5cba54744fff37" translate="yes" xml:space="preserve">
          <source>Change the current ABI to use IEEE extended-precision long double. This is not likely to work if your system defaults to using IBM extended-precision long double. If you change the long double type from IBM extended-precision, the compiler will issue a warning unless you use the</source>
          <target state="translated">IEEE 확장 정밀 long double을 사용하도록 현재 ABI를 변경하십시오. 시스템이 기본적으로 IBM 확장 정밀 long double을 사용하는 경우에는 작동하지 않을 수 있습니다. IBM 확장 정밀도에서 long double 유형을 변경하면 컴파일러는 다음을 사용하지 않는 한 경고를 발행합니다.</target>
        </trans-unit>
        <trans-unit id="24cf332293e237ad325e62a5ee2905fadea5402b" translate="yes" xml:space="preserve">
          <source>Change the current ABI to use the ELFv1 ABI. This is the default ABI for big-endian PowerPC 64-bit Linux. Overriding the default ABI requires special system support and is likely to fail in spectacular ways.</source>
          <target state="translated">ELFv1 ABI를 사용하도록 현재 ABI를 변경하십시오. 빅 엔디안 PowerPC 64 비트 Linux의 기본 ABI입니다. 기본 ABI를 재정의하려면 특별한 시스템 지원이 필요하며 놀라운 방식으로 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ed54cd4038a43f7d20137c040c4f60546641dbf" translate="yes" xml:space="preserve">
          <source>Change the current ABI to use the ELFv2 ABI. This is the default ABI for little-endian PowerPC 64-bit Linux. Overriding the default ABI requires special system support and is likely to fail in spectacular ways.</source>
          <target state="translated">ELFv2 ABI를 사용하도록 현재 ABI를 변경하십시오. 이것은 리틀 엔디안 PowerPC 64 비트 Linux의 기본 ABI입니다. 기본 ABI를 재정의하려면 특별한 시스템 지원이 필요하며 놀라운 방식으로 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85a1bd4814c92b33b933c24808e3438fdd28e471" translate="yes" xml:space="preserve">
          <source>Change the preferred SIMD mode to SImode. The default is</source>
          <target state="translated">선호하는 SIMD 모드를 SImode로 변경하십시오. 디폴트는</target>
        </trans-unit>
        <trans-unit id="1693787c0c1da76f7df927835bc9d253ab1baa96" translate="yes" xml:space="preserve">
          <source>Change the target of the rule emitted by dependency generation. By default CPP takes the name of the main input file, deletes any directory components and any file suffix such as &amp;lsquo;</source>
          <target state="translated">종속성 생성에 의해 생성 된 규칙의 대상을 변경하십시오. 기본적으로 CPP는 기본 입력 파일의 이름을 사용하고 디렉토리 구성 요소 및 '와 같은 파일 접미 부를 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="aca39a5b032e87a9c462bafacf2e62ade09bc55e" translate="yes" xml:space="preserve">
          <source>Check calls to &lt;code&gt;printf&lt;/code&gt; and &lt;code&gt;scanf&lt;/code&gt;, etc., to make sure that the arguments supplied have types appropriate to the format string specified, and that the conversions specified in the format string make sense. This includes standard functions, and others specified by format attributes (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;), in the &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;scanf&lt;/code&gt;, &lt;code&gt;strftime&lt;/code&gt; and &lt;code&gt;strfmon&lt;/code&gt; (an X/Open extension, not in the C standard) families (or other target-specific families). Which functions are checked without format attributes having been specified depends on the standard version selected, and such checks of functions without the attribute specified are disabled by</source>
          <target state="translated">제공된 인수에 지정된 형식 문자열에 적합한 유형이 있고 형식 문자열에 지정된 변환이 의미가 있는지 &lt;code&gt;printf&lt;/code&gt; 및 &lt;code&gt;scanf&lt;/code&gt; 등의 호출을 확인하십시오. 이 형식 특성 (참조가 지정한 표준 기능 등이 포함 &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;기능 속성&lt;/a&gt; )에서에서 &lt;code&gt;printf&lt;/code&gt; , &lt;code&gt;scanf&lt;/code&gt; 와 , &lt;code&gt;strftime&lt;/code&gt; 및 &lt;code&gt;strfmon&lt;/code&gt; (안 C 표준의 X / 열기 확장) 가족 (또는 다른 대상별 가정). 형식 속성을 지정하지 않고 확인할 기능은 선택한 표준 버전에 따라 다르며, 특성을 지정하지 않은 기능 확인은</target>
        </trans-unit>
        <trans-unit id="c6a3f453fdd63ac92077276df83570873739aa07" translate="yes" xml:space="preserve">
          <source>Check for 64 bits wide constants for add/sub instructions</source>
          <target state="translated">추가 / 서브 명령어에 대한 64 비트 폭 상수 확인</target>
        </trans-unit>
        <trans-unit id="fac4c7c683a989d8b06bb9ece7f678cee49ed294" translate="yes" xml:space="preserve">
          <source>Check that the pointer returned by &lt;code&gt;operator new&lt;/code&gt; is non-null before attempting to modify the storage allocated. This check is normally unnecessary because the C++ standard specifies that &lt;code&gt;operator new&lt;/code&gt; only returns &lt;code&gt;0&lt;/code&gt; if it is declared &lt;code&gt;throw()&lt;/code&gt;, in which case the compiler always checks the return value even without this option. In all other cases, when &lt;code&gt;operator new&lt;/code&gt; has a non-empty exception specification, memory exhaustion is signalled by throwing &lt;code&gt;std::bad_alloc&lt;/code&gt;. See also &amp;lsquo;</source>
          <target state="translated">할당 된 스토리지를 수정하기 전에 &lt;code&gt;operator new&lt;/code&gt; 가 리턴 한 포인터 가 널이 아닌지 점검하십시오 . C ++ 표준은 &lt;code&gt;operator new&lt;/code&gt; 가 &lt;code&gt;throw()&lt;/code&gt; 로 선언 된 경우 &lt;code&gt;0&lt;/code&gt; 만 반환 하도록 지정하므로이 검사는 일반적으로 불필요 합니다.이 경우 컴파일러는이 옵션 없이도 항상 반환 값을 확인합니다. 다른 모든 경우에 &lt;code&gt;operator new&lt;/code&gt; 비어 있지 않은 예외 사양이있는 경우 &lt;code&gt;std::bad_alloc&lt;/code&gt; 시켜 메모리 소진을 알립니다 . 또한보십시오 '</target>
        </trans-unit>
        <trans-unit id="81e890de105f29124c3560894740b09b086a655a" translate="yes" xml:space="preserve">
          <source>Check the code for syntax errors, but don&amp;rsquo;t do anything beyond that.</source>
          <target state="translated">코드에 구문 오류가 있는지 확인하지만 그 이상은 수행하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="5b609f7a36a96f87c3d3229801dbbe278531362e" translate="yes" xml:space="preserve">
          <source>Checking the number and type of arguments to a function which has an old-fashioned definition and no prototype.</source>
          <target state="translated">구식 정의가 있고 프로토 타입이없는 함수에 대한 인수의 수와 유형 확인</target>
        </trans-unit>
        <trans-unit id="fd9acb009d6a873fdb579dcb1f012d6d507dcf76" translate="yes" xml:space="preserve">
          <source>Choose a data model. The choices for &lt;var&gt;model&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">데이터 모델을 선택하십시오. &lt;var&gt;model&lt;/var&gt; 선택 은 '</target>
        </trans-unit>
        <trans-unit id="8d3369d8e5fea9b901b46c632d20401df2fdb02c" translate="yes" xml:space="preserve">
          <source>Choose between the two available implementations of</source>
          <target state="translated">사용 가능한 두 가지 구현 중에서 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="41e3a1c87aff0500a839e105b5b619da6d89b8a6" translate="yes" xml:space="preserve">
          <source>Choose integer type as 32-bit wide.</source>
          <target state="translated">정수 유형을 32 비트 너비로 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="fd477ac5e4063d79ef6de9d30fdf3c13757351dd" translate="yes" xml:space="preserve">
          <source>Choose startup files and linker script suitable for the simulator.</source>
          <target state="translated">시뮬레이터에 적합한 시작 파일 및 링커 스크립트를 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="a7c124dc3d6f2fff1283f2960f19679f618eb758" translate="yes" xml:space="preserve">
          <source>Chopped rounding mode. Floating-point numbers are rounded towards zero.</source>
          <target state="translated">다진 라운딩 모드. 부동 소수점 숫자는 0으로 반올림됩니다.</target>
        </trans-unit>
        <trans-unit id="baeeaf6c90ab7667596e853c19ec9377ba1a6bed" translate="yes" xml:space="preserve">
          <source>Chunk size of omp schedule for loops parallelized by parloops.</source>
          <target state="translated">parloops에 의해 병렬화 된 루프에 대한 omp 스케줄의 청크 크기.</target>
        </trans-unit>
        <trans-unit id="39f6c5316b94c42ede9e8f3c0902f04af5a47ac9" translate="yes" xml:space="preserve">
          <source>Clobber descriptions may not in any way overlap with an input or output operand. For example, you may not have an operand describing a register class with one member when listing that register in the clobber list. Variables declared to live in specific registers (see &lt;a href=&quot;explicit-register-variables#Explicit-Register-Variables&quot;&gt;Explicit Register Variables&lt;/a&gt;) and used as &lt;code&gt;asm&lt;/code&gt; input or output operands must have no part mentioned in the clobber description. In particular, there is no way to specify that input operands get modified without also specifying them as output operands.</source>
          <target state="translated">클로버 설명은 입력 또는 출력 피연산자와 겹치지 않을 수 있습니다. 예를 들어, 클로버 목록에 해당 레지스터를 나열 할 때 하나의 멤버로 레지스터 클래스를 설명하는 피연산자가 없을 수 있습니다. 특정 레지스터에 존재하도록 선언되고 ( &lt;a href=&quot;explicit-register-variables#Explicit-Register-Variables&quot;&gt;명시 적 레지스터 변수&lt;/a&gt; 참조 ) &lt;code&gt;asm&lt;/code&gt; 입력 또는 출력 피연산자 로 사용되는 변수 는 클로버 설명에 언급되지 않아야합니다. 특히, 입력 피연산자를 출력 피연산자로 지정하지 않고 입력 피연산자가 수정되도록 지정할 수있는 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="e7d5e82c3d8cf6aecb50f1c3dec1dfd81862c300" translate="yes" xml:space="preserve">
          <source>Code Generation Options</source>
          <target state="translated">코드 생성 옵션</target>
        </trans-unit>
        <trans-unit id="de73aa04e00c631b2bba60472a9b4cb42f90647b" translate="yes" xml:space="preserve">
          <source>Code generation tweaks that disable, respectively, splitting of 32-bit loads, generation of post-increment addresses, and generation of post-modify addresses. The defaults are</source>
          <target state="translated">32 비트로드 분할, 사후 증가 주소 생성 및 사후 수정 주소 생성을 각각 비활성화하는 코드 생성 조정. 기본값은</target>
        </trans-unit>
        <trans-unit id="0acb8ba8662201458fc8762cdc2bfb973da3d9b7" translate="yes" xml:space="preserve">
          <source>Code like this may run successfully under some other compilers, particularly obsolete cfront-based compilers that delete temporaries along with normal local variables. However, the GNU C++ behavior is standard-conforming, so if your program depends on late destruction of temporaries it is not portable.</source>
          <target state="translated">이와 같은 코드는 다른 컴파일러, 특히 일반 로컬 변수와 함께 임시를 삭제하는 오래된 cfront 기반 컴파일러에서 성공적으로 실행될 수 있습니다. 그러나 GNU C ++ 동작은 표준을 준수하므로 프로그램이 일시적인 파괴에 의존하는 경우 이식성이 없습니다.</target>
        </trans-unit>
        <trans-unit id="d477ef0f890f99da791a35a9c4922d4a6b4caa9b" translate="yes" xml:space="preserve">
          <source>Code that (effectively) clobbers bits of &lt;code&gt;SREG&lt;/code&gt; other than the &lt;code&gt;I&lt;/code&gt;-flag by writing to the memory location of &lt;code&gt;SREG&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SREG&lt;/code&gt; 의 메모리 위치에 써서 &lt;code&gt;I&lt;/code&gt; 플래그 이외 의 SREG 비트를 (효과적으로) 클로버 하는 &lt;code&gt;SREG&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22aee03764143c3347036737d5c49aa3c48b93fe" translate="yes" xml:space="preserve">
          <source>Code that uses inline assembler to jump to a different function which expects (parts of) the prologue code as outlined above to be present.</source>
          <target state="translated">인라인 어셈블러를 사용하여 위에서 설명한대로 프롤로그 코드의 일부를 예상하는 다른 함수로 이동하는 코드입니다.</target>
        </trans-unit>
        <trans-unit id="a04d4be0af028c55d37a5eda8e2e9e52e00d9883" translate="yes" xml:space="preserve">
          <source>Collect and dump debug information into a temporary file if an internal compiler error (ICE) occurs.</source>
          <target state="translated">내부 컴파일러 오류 (ICE)가 발생하면 디버그 정보를 임시 파일로 수집하고 덤프하십시오.</target>
        </trans-unit>
        <trans-unit id="3de9bf73c20469d02f33a82c6c1b964c35ca72c5" translate="yes" xml:space="preserve">
          <source>Collect the profiles for different set of inputs, and use this tool to merge them. One can specify the weight to factor in the relative importance of each input.</source>
          <target state="translated">다른 입력 세트에 대한 프로파일을 수집하고이 도구를 사용하여 병합하십시오. 각 입력의 상대적 중요성을 고려하여 가중치를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="674fdd25c0f94978ce5404bf7783af22ebecb1fb" translate="yes" xml:space="preserve">
          <source>Combine increments or decrements of addresses with memory accesses. This pass is always skipped on architectures that do not have instructions to support this. Enabled by default at</source>
          <target state="translated">주소 증가 또는 감소를 메모리 액세스와 결합합니다. 이 단계는이를 지원하기위한 지침이없는 아키텍처에서는 항상 건너 뜁니다. 에서 기본적으로 활성화</target>
        </trans-unit>
        <trans-unit id="5c675961000becf8ff6422c0eeb1b9242b5fdf0f" translate="yes" xml:space="preserve">
          <source>Combines the effects of both &lt;code&gt;__ATOMIC_ACQUIRE&lt;/code&gt; and &lt;code&gt;__ATOMIC_RELEASE&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;__ATOMIC_ACQUIRE&lt;/code&gt; 및 &lt;code&gt;__ATOMIC_RELEASE&lt;/code&gt; 의 효과를 결합합니다 .</target>
        </trans-unit>
        <trans-unit id="4393d8b520a9b50ddef09d9f77984a620fcf38de" translate="yes" xml:space="preserve">
          <source>Combining several classes is possible, although this usually restricts the output so much that there is nothing to display. One case where it does work, however, is when one of the classes is &lt;var&gt;target&lt;/var&gt;. For example, to display all the target-specific optimization options, use:</source>
          <target state="translated">일반적으로 출력을 너무 제한하여 표시 할 항목이 없지만 여러 클래스를 결합 할 수 있습니다. 그러나 작동하는 한 가지 경우는 클래스 중 하나가 &lt;var&gt;target&lt;/var&gt; 일 때 입니다. 예를 들어 모든 대상별 최적화 옵션을 표시하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="72a257637f31b3509bd8ac95d015b26d1c5d9ce9" translate="yes" xml:space="preserve">
          <source>Command options supported by &amp;lsquo;</source>
          <target state="translated">'에서 지원하는 명령 옵션</target>
        </trans-unit>
        <trans-unit id="8e5bbd00924927db3116b7ce896a99d0d6c09a71" translate="yes" xml:space="preserve">
          <source>Commit the current transaction. When no transaction is active this faults. All memory side effects of the transaction become visible to other threads in an atomic manner.</source>
          <target state="translated">현재 트랜잭션을 커밋하십시오. 활성화 된 트랜잭션이 없으면이 결함이 발생합니다. 트랜잭션의 모든 메모리 부작용은 원자적인 방식으로 다른 스레드에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="953dbfff4f1c2d7c9623cfa81345a412c8c95e6f" translate="yes" xml:space="preserve">
          <source>Common misunderstandings with GNU C++.</source>
          <target state="translated">GNU C ++의 일반적인 오해.</target>
        </trans-unit>
        <trans-unit id="99484341af697bedb30f82944a2b8048a7bd9d3b" translate="yes" xml:space="preserve">
          <source>Compare at most &lt;var&gt;num&lt;/var&gt; string bytes with inline code. If the difference or end of string is not found at the end of the inline compare a call to &lt;code&gt;strcmp&lt;/code&gt; or &lt;code&gt;strncmp&lt;/code&gt; will take care of the rest of the comparison. The default is 64 bytes.</source>
          <target state="translated">최대 &lt;var&gt;num&lt;/var&gt; 문자열 바이트를 인라인 코드와 비교하십시오 . 인라인 끝에서 문자열의 차이 또는 끝을 찾을 수 없으면 &lt;code&gt;strcmp&lt;/code&gt; 또는 &lt;code&gt;strncmp&lt;/code&gt; 에 대한 호출 이 나머지 비교를 처리합니다. 기본값은 64 바이트입니다.</target>
        </trans-unit>
        <trans-unit id="7e11797436f7910f8bb83ca2860c72513034685a" translate="yes" xml:space="preserve">
          <source>Comparison of four paired-single values (&lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt;/&lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt;, &lt;code&gt;bc1any4t&lt;/code&gt;/&lt;code&gt;bc1any4f&lt;/code&gt;).</source>
          <target state="translated">4 개의 단일 쌍 값 비교 ( &lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; / &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; , &lt;code&gt;bc1any4t&lt;/code&gt; / &lt;code&gt;bc1any4f&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c8cb7f422f46057d6869362d0511c9090d3a1fd7" translate="yes" xml:space="preserve">
          <source>Comparison of two paired-single values (&lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt;, &lt;code&gt;bc1t&lt;/code&gt;/&lt;code&gt;bc1f&lt;/code&gt;).</source>
          <target state="translated">두 쌍의 단일 값 비교 ( &lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; , &lt;code&gt;bc1t&lt;/code&gt; / &lt;code&gt;bc1f&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="11a9160f31b23e32c54ba7fe5458de10730189d9" translate="yes" xml:space="preserve">
          <source>Comparison of two paired-single values (&lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt;/&lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt;, &lt;code&gt;bc1any2t&lt;/code&gt;/&lt;code&gt;bc1any2f&lt;/code&gt;).</source>
          <target state="translated">두 쌍의 단일 값 비교 ( &lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; / &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; , &lt;code&gt;bc1any2t&lt;/code&gt; / &lt;code&gt;bc1any2f&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="651d13a7683a8781ee0feea932b0d34d198ddce8" translate="yes" xml:space="preserve">
          <source>Comparison operations.</source>
          <target state="translated">비교 연산.</target>
        </trans-unit>
        <trans-unit id="1adbeb956bb205e79fa3fa9ca1c2daca593fb1fa" translate="yes" xml:space="preserve">
          <source>Compatibilities with earlier definitions of C++.</source>
          <target state="translated">C ++의 이전 정의와의 호환성</target>
        </trans-unit>
        <trans-unit id="51c2b0659cd05018587a8d43545227600a32a376" translate="yes" xml:space="preserve">
          <source>Compilation can involve up to four stages: preprocessing, compilation proper, assembly and linking, always in that order. GCC is capable of preprocessing and compiling several files either into several assembler input files, or into one assembler input file; then each assembler input file produces an object file, and linking combines all the object files (those newly compiled, and those specified as input) into an executable file.</source>
          <target state="translated">컴파일은 최대 4 단계 (전처리, 적절한 컴파일, 어셈블리 및 링크)를 항상 순서대로 포함 할 수 있습니다. GCC는 여러 파일을 여러 개의 어셈블러 입력 파일 또는 한 개의 어셈블러 입력 파일로 사전 처리하고 컴파일 할 수 있습니다. 그런 다음 각 어셈블러 입력 파일은 객체 파일을 생성하고 링크는 모든 객체 파일 (새로 컴파일 된 파일 및 입력으로 지정된 파일)을 실행 파일로 결합합니다.</target>
        </trans-unit>
        <trans-unit id="1f490d968ba17b1a6b9c49acd428a6392e787830" translate="yes" xml:space="preserve">
          <source>Compile ARCv2 code with a multiplier design option. You can specify the option using either a string or numeric value for &lt;var&gt;multo&lt;/var&gt;. &amp;lsquo;</source>
          <target state="translated">승수 설계 옵션으로 ARCv2 코드를 컴파일하십시오. &lt;var&gt;multo&lt;/var&gt; 에 문자열 또는 숫자 값을 사용하여 옵션을 지정할 수 있습니다 . '</target>
        </trans-unit>
        <trans-unit id="4a90dd66273f8436ce33369f342227123629a080" translate="yes" xml:space="preserve">
          <source>Compile code assuming that IEEE signaling NaNs may generate user-visible traps during floating-point operations. Setting this option disables optimizations that may change the number of exceptions visible with signaling NaNs. This option implies</source>
          <target state="translated">IEEE 신호 NaN이 부동 소수점 연산 중에 사용자가 볼 수있는 트랩을 생성 할 수 있다고 가정 한 코드를 컴파일하십시오. 이 옵션을 설정하면 신호 NaN에 표시되는 예외 수를 변경할 수있는 최적화가 비활성화됩니다. 이 옵션은</target>
        </trans-unit>
        <trans-unit id="9970fa5395affc7dc93ea1ed06f8fdd6c082c5bc" translate="yes" xml:space="preserve">
          <source>Compile code assuming that floating-point operations cannot generate user-visible traps. These traps include division by zero, overflow, underflow, inexact result and invalid operation. This option requires that</source>
          <target state="translated">부동 소수점 연산이 사용자가 볼 수있는 트랩을 생성 할 수 없다고 가정하여 코드를 컴파일하십시오. 이러한 트랩에는 0으로 나누기, 오버플로, 언더 플로, 부정확 한 결과 및 잘못된 작업이 포함됩니다. 이 옵션은</target>
        </trans-unit>
        <trans-unit id="7167229840a9f09cf85e4d3c02813e6e3f7c2954" translate="yes" xml:space="preserve">
          <source>Compile code assuming that pointers to the PPU address space accessed via the &lt;code&gt;__ea&lt;/code&gt; named address space qualifier are either 32 or 64 bits wide. The default is 32 bits. As this is an ABI-changing option, all object code in an executable must be compiled with the same setting.</source>
          <target state="translated">&lt;code&gt;__ea&lt;/code&gt; 명명 된 주소 공간 한정자 를 통해 액세스 한 PPU 주소 공간에 대한 포인터의 너비 가 32 비트 또는 64 비트 라고 가정하고 코드를 컴파일합니다 . 디폴트는 32 비트입니다. 이것은 ABI 변경 옵션이므로 실행 파일의 모든 객체 코드는 동일한 설정으로 컴파일해야합니다.</target>
        </trans-unit>
        <trans-unit id="31103695d6eecad4fc985951c0af142d11cd5c1a" translate="yes" xml:space="preserve">
          <source>Compile code compatible with Android platform. This is the default on &amp;lsquo;</source>
          <target state="translated">Android 플랫폼과 호환되는 코드를 컴파일하십시오. '의 기본값입니다</target>
        </trans-unit>
        <trans-unit id="894efb97728307a39eeed2699c1c4e4bd26dd9dc" translate="yes" xml:space="preserve">
          <source>Compile code for big-endian mode. This is the default.</source>
          <target state="translated">빅 엔디안 모드를위한 코드를 컴파일하십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="d1832ee4b35f2abfa3f4e141edadd28f18085110" translate="yes" xml:space="preserve">
          <source>Compile code for big-endian targets. Use of these options is now deprecated. Big-endian code is supported by configuring GCC to build &lt;code&gt;arceb-elf32&lt;/code&gt; and &lt;code&gt;arceb-linux-uclibc&lt;/code&gt; targets, for which big endian is the default.</source>
          <target state="translated">빅 엔디안 타겟을위한 컴파일 코드. 이 옵션은 더 이상 사용되지 않습니다. big-endian 코드는 &lt;code&gt;arceb-elf32&lt;/code&gt; 및 &lt;code&gt;arceb-linux-uclibc&lt;/code&gt; 대상 을 빌드하도록 GCC를 구성하여 지원됩니다 . big endian이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="be8c22e36ad1f39109ec2efd6cc1a81d955acd13" translate="yes" xml:space="preserve">
          <source>Compile code for little-endian mode.</source>
          <target state="translated">리틀 엔디안 모드를위한 코드를 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="9b8ec4f965ec58185bb6754ac805aafeb89d3ae4" translate="yes" xml:space="preserve">
          <source>Compile code for little-endian targets. Use of these options is now deprecated. Little-endian code is supported by configuring GCC to build &lt;code&gt;arc-elf32&lt;/code&gt; and &lt;code&gt;arc-linux-uclibc&lt;/code&gt; targets, for which little endian is the default.</source>
          <target state="translated">리틀 엔디안 대상에 대한 코드를 컴파일하십시오. 이 옵션은 더 이상 사용되지 않습니다. 리틀 엔디안 코드는 &lt;code&gt;arc-elf32&lt;/code&gt; 및 &lt;code&gt;arc-linux-uclibc&lt;/code&gt; 대상 을 빌드하도록 GCC를 구성하여 지원되며 리틀 엔디안이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="b9cb11574bb395057387b096cea7b6d6f515f971" translate="yes" xml:space="preserve">
          <source>Compile code for the processor in big-endian mode.</source>
          <target state="translated">빅 엔디안 모드에서 프로세서의 코드를 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="9f489feb9b6caedf9bb6320c99f84e7364f3077b" translate="yes" xml:space="preserve">
          <source>Compile code for the processor in little-endian mode.</source>
          <target state="translated">리틀 엔디안 모드에서 프로세서의 코드를 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="39bc5e8e166e8b03d8be316efdd326cda59c0f57" translate="yes" xml:space="preserve">
          <source>Compile for ARC 600 CPU with &lt;code&gt;norm&lt;/code&gt; and 32x16-bit multiply instructions enabled.</source>
          <target state="translated">&lt;code&gt;norm&lt;/code&gt; 및 32x16 비트 곱하기 명령어를 사용 하여 ARC 600 CPU를 컴파일합니다 .</target>
        </trans-unit>
        <trans-unit id="17be7dfb615c6d886c0d693b9048e7e155b99fb6" translate="yes" xml:space="preserve">
          <source>Compile for ARC 600 CPU with &lt;code&gt;norm&lt;/code&gt; and &lt;code&gt;mul64&lt;/code&gt;-family instructions enabled.</source>
          <target state="translated">&lt;code&gt;norm&lt;/code&gt; 및 &lt;code&gt;mul64&lt;/code&gt; 제품군 명령어를 사용 하여 ARC 600 CPU를 컴파일하십시오 .</target>
        </trans-unit>
        <trans-unit id="d7f2d72dcd31900923f3da8d539cfc9292aa3f8e" translate="yes" xml:space="preserve">
          <source>Compile for ARC 600 CPU with &lt;code&gt;norm&lt;/code&gt; instructions enabled.</source>
          <target state="translated">&lt;code&gt;norm&lt;/code&gt; 명령어를 사용 하여 ARC 600 CPU를 컴파일하십시오 .</target>
        </trans-unit>
        <trans-unit id="16696f4c8426aaf6854eeea45ee7e1bd467edd27" translate="yes" xml:space="preserve">
          <source>Compile for ARC 601 CPU with &lt;code&gt;norm&lt;/code&gt; and 32x16-bit multiply instructions enabled.</source>
          <target state="translated">&lt;code&gt;norm&lt;/code&gt; 및 32x16 비트 곱하기 명령어를 사용 하여 ARC 601 CPU를 컴파일합니다 .</target>
        </trans-unit>
        <trans-unit id="5bca932c9c4e343d44b89be260ad06bfe429ab8a" translate="yes" xml:space="preserve">
          <source>Compile for ARC 601 CPU with &lt;code&gt;norm&lt;/code&gt; and &lt;code&gt;mul64&lt;/code&gt;-family instructions enabled.</source>
          <target state="translated">&lt;code&gt;norm&lt;/code&gt; 및 &lt;code&gt;mul64&lt;/code&gt; -family 명령어를 사용 하여 ARC 601 CPU를 컴파일하십시오 .</target>
        </trans-unit>
        <trans-unit id="02df7632e889a6c5616971f35e12edcc4a5d8c62" translate="yes" xml:space="preserve">
          <source>Compile for ARC 601 CPU with &lt;code&gt;norm&lt;/code&gt; instructions enabled.</source>
          <target state="translated">&lt;code&gt;norm&lt;/code&gt; 명령어가 활성화 된 ARC 601 CPU를 컴파일합니다 .</target>
        </trans-unit>
        <trans-unit id="b7fdc4d4b7214e5e7819e3d3a90236053d8b22cd" translate="yes" xml:space="preserve">
          <source>Compile for ARC 700 on NPS400 chip.</source>
          <target state="translated">NPS400 칩에서 ARC 700을 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="1e4380f255d2d18d4e8f267e7678f7435eab73b8" translate="yes" xml:space="preserve">
          <source>Compile for ARC EM CPU with no hardware extensions.</source>
          <target state="translated">하드웨어 확장이없는 ARC EM CPU를 위해 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="d617eff21e80138509c5fb71d3dfb75e71687f6e" translate="yes" xml:space="preserve">
          <source>Compile for ARC EM minimalist configuration featuring reduced register set.</source>
          <target state="translated">레지스터 세트가 축소 된 ARC EM 미니멀리즘 구성을위한 컴파일</target>
        </trans-unit>
        <trans-unit id="75b4e707d87f6b65d51c529906a072e95ff89b29" translate="yes" xml:space="preserve">
          <source>Compile for ARC EM.</source>
          <target state="translated">ARC EM을 위해 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="da70dd835733600356587db74a19ff09214dbd17" translate="yes" xml:space="preserve">
          <source>Compile for ARC EM4 CPU.</source>
          <target state="translated">ARC EM4 CPU를 위해 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="a460d3a31969ec154e7b1632e56830c60250b541" translate="yes" xml:space="preserve">
          <source>Compile for ARC EM4 DMIPS CPU with single-precision floating-point and double assist instructions.</source>
          <target state="translated">단 정밀도 부동 소수점 및 이중 지원 명령어로 ARC EM4 DMIPS CPU를 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="a5b00683884602ca4044736a233bc8c892a0f636" translate="yes" xml:space="preserve">
          <source>Compile for ARC EM4 DMIPS CPU with the single-precision floating-point extension.</source>
          <target state="translated">단 정밀도 부동 소수점 확장을 사용하여 ARC EM4 DMIPS CPU를 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="88b1ffe9efdf7ea63c9f3422bb5547df94d22ce1" translate="yes" xml:space="preserve">
          <source>Compile for ARC EM4 DMIPS CPU.</source>
          <target state="translated">ARC EM4 DMIPS CPU를 위해 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="086d9196358fe7f0fa7f3e7051ae4fc4f433b7ae" translate="yes" xml:space="preserve">
          <source>Compile for ARC HS CPU with no hardware extensions except the atomic instructions.</source>
          <target state="translated">원자 명령어를 제외하고 하드웨어 확장이없는 ARC HS CPU를 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="cacfee18847f11dad685598d36ea6ee3b6957c02" translate="yes" xml:space="preserve">
          <source>Compile for ARC HS.</source>
          <target state="translated">ARC HS를위한 컴파일</target>
        </trans-unit>
        <trans-unit id="847cd27652d52b58f36a4f2e5ea5cead4371673c" translate="yes" xml:space="preserve">
          <source>Compile for ARC HS34 CPU.</source>
          <target state="translated">ARC HS34 CPU를 위해 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="d44b3581972b8ea0a69f39fb0ebefd762b42bbe7" translate="yes" xml:space="preserve">
          <source>Compile for ARC HS38 CPU with all hardware extensions on.</source>
          <target state="translated">모든 하드웨어 확장이 설정된 ARC HS38 CPU를 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="4c711906d8e4d4a87fb48440c2cfaa0c80bee620" translate="yes" xml:space="preserve">
          <source>Compile for ARC HS38 CPU.</source>
          <target state="translated">ARC HS38 CPU를 위해 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="8348ca27592b892d967948ee652e94376f711101" translate="yes" xml:space="preserve">
          <source>Compile for ARC600. Aliases:</source>
          <target state="translated">ARC600을 위해 컴파일하십시오. 별칭 :</target>
        </trans-unit>
        <trans-unit id="9c0fc8bbbde2253a58a83a11623bea243e8a7c8b" translate="yes" xml:space="preserve">
          <source>Compile for ARC601. Alias:</source>
          <target state="translated">ARC601을 위해 컴파일하십시오. 별명:</target>
        </trans-unit>
        <trans-unit id="05e0d990baf06011ef4d82bdf9df53fdce00286b" translate="yes" xml:space="preserve">
          <source>Compile for ARC700. Aliases:</source>
          <target state="translated">ARC700을 위해 컴파일하십시오. 별칭 :</target>
        </trans-unit>
        <trans-unit id="e278797da8990f0ccb7f07f045508cd4010b76aa" translate="yes" xml:space="preserve">
          <source>Compile for GCN3 Fiji devices (gfx803).</source>
          <target state="translated">GCN3 피지 장치 (gfx803) 용으로 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="713b8f86530a1c2d9a5d702e486321c4dc351849" translate="yes" xml:space="preserve">
          <source>Compile for GCN5 Vega 10 devices (gfx900).</source>
          <target state="translated">GCN5 Vega 10 장치 (gfx900) 용으로 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="b90b725a08b6d96eebe36b77a50cd90bcf52390d" translate="yes" xml:space="preserve">
          <source>Compile for GCN5 Vega 20 devices (gfx906).</source>
          <target state="translated">GCN5 Vega 20 장치 (gfx906) 용으로 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="d6c48f84ed7faf104f474152b0d3bc268ee56eba" translate="yes" xml:space="preserve">
          <source>Compile or assemble the source files, but do not link. The linking stage simply is not done. The ultimate output is in the form of an object file for each source file.</source>
          <target state="translated">소스 파일을 컴파일하거나 어셈블하지만 링크하지는 마십시오. 연결 단계는 단순히 수행되지 않습니다. 최종 출력은 각 소스 파일에 대한 오브젝트 파일 형식입니다.</target>
        </trans-unit>
        <trans-unit id="aada22a2dba27d65c33f8d484ca9df970f74fa8a" translate="yes" xml:space="preserve">
          <source>Compile the source files additionally with</source>
          <target state="translated">소스 파일을 추가로 컴파일</target>
        </trans-unit>
        <trans-unit id="8e1d1625ee50b70503b880bddd8c2899625cfd1d" translate="yes" xml:space="preserve">
          <source>Compile the source files with</source>
          <target state="translated">소스 파일을 컴파일</target>
        </trans-unit>
        <trans-unit id="bae2f3f4c4da22165b65f81f0ab47bfdf72e5a74" translate="yes" xml:space="preserve">
          <source>Compile your code with</source>
          <target state="translated">와 코드를 컴파일</target>
        </trans-unit>
        <trans-unit id="61a5380160ff93557be23ea688dad9be208e4dbd" translate="yes" xml:space="preserve">
          <source>Compile your template-using code with</source>
          <target state="translated">템플릿 사용 코드를 사용하여 컴파일</target>
        </trans-unit>
        <trans-unit id="bb1fb4ab4c5c8120d8c582a624d0a9ac53f55fe3" translate="yes" xml:space="preserve">
          <source>Compiler encoding</source>
          <target state="translated">컴파일러 인코딩</target>
        </trans-unit>
        <trans-unit id="24922f29f09454ba5b177fdcf5e81c9543043eef" translate="yes" xml:space="preserve">
          <source>Compiler support for type traits.</source>
          <target state="translated">유형 특성에 대한 컴파일러 지원</target>
        </trans-unit>
        <trans-unit id="2d58377b2111c9408f411d965f3b8abfb37ec05b" translate="yes" xml:space="preserve">
          <source>Compiling C++ programs.</source>
          <target state="translated">C ++ 프로그램 컴파일</target>
        </trans-unit>
        <trans-unit id="ed13de84ad4a0f0cd9e6bd0e630f5cc19d816c7d" translate="yes" xml:space="preserve">
          <source>Compiling a header once, and using it many times.</source>
          <target state="translated">헤더를 한 번 컴파일하고 여러 번 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a9cb191f84bf0e0a5fd4e8fafa0cbeb0ce255ebb" translate="yes" xml:space="preserve">
          <source>Compiling with</source>
          <target state="translated">로 컴파일</target>
        </trans-unit>
        <trans-unit id="8097f9a2f49c7bb34a8f3d4a23b5682dee4f13c4" translate="yes" xml:space="preserve">
          <source>Complex multiplication and division follow Fortran rules. Range reduction is done as part of complex division, but there is no checking whether the result of a complex multiplication or division is &lt;code&gt;NaN
+ I*NaN&lt;/code&gt;, with an attempt to rescue the situation in that case.</source>
          <target state="translated">복잡한 곱셈과 나눗셈은 포트란 규칙을 따릅니다. 범위 축소는 복소수 나눗셈의 일부로 수행되지만 복소수 곱셈 또는 나눗셈의 결과가 &lt;code&gt;NaN + I*NaN&lt;/code&gt; 인지 여부는 확인되지 않으며 ,이 경우 상황을 구조하려고합니다.</target>
        </trans-unit>
        <trans-unit id="e323088fd5a174d70e9a002849c8a4e688bcae61" translate="yes" xml:space="preserve">
          <source>Complex types</source>
          <target state="translated">복잡한 유형</target>
        </trans-unit>
        <trans-unit id="a513e209b739423b55158eb7f0004ee614ede0ee" translate="yes" xml:space="preserve">
          <source>Comply with the calling conventions defined by Renesas.</source>
          <target state="translated">Renesas가 정의한 통화 규약을 준수하십시오.</target>
        </trans-unit>
        <trans-unit id="7ca1263e4404b74af40b4e0106fd5b298bab578a" translate="yes" xml:space="preserve">
          <source>Comply with the calling conventions defined for GCC before the Renesas conventions were available. This option is the default for all targets of the SH toolchain.</source>
          <target state="translated">르네사스 협약을 사용하기 전에 GCC에 대해 정의 된 통화 규칙을 준수하십시오. 이 옵션은 SH 툴체인의 모든 대상에 대한 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="8065b09eb57234d64105b727689f45402502d3a0" translate="yes" xml:space="preserve">
          <source>Compound literals for scalar types and union types are also allowed. In the following example the variable &lt;code&gt;i&lt;/code&gt; is initialized to the value &lt;code&gt;2&lt;/code&gt;, the result of incrementing the unnamed object created by the compound literal.</source>
          <target state="translated">스칼라 유형 및 공용체 유형의 복합 리터럴도 허용됩니다. 다음 예제에서 변수 &lt;code&gt;i&lt;/code&gt; 는 값 &lt;code&gt;2&lt;/code&gt; 로 초기화되며 , 그 결과 복합 리터럴에 의해 생성 된 명명되지 않은 객체가 증가합니다.</target>
        </trans-unit>
        <trans-unit id="a6bff82561ec7274ee97d8914e7822d45d55dda6" translate="yes" xml:space="preserve">
          <source>Compound literals give structures, unions or arrays as values.</source>
          <target state="translated">복합 리터럴은 구조, 공용체 또는 배열을 값으로 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9966e73a786b7c65f837b6274e264d2ae3402caf" translate="yes" xml:space="preserve">
          <source>Compress all code using the Ft32B code compression scheme.</source>
          <target state="translated">Ft32B 코드 압축 체계를 사용하여 모든 코드를 압축하십시오.</target>
        </trans-unit>
        <trans-unit id="6c77d95794a767632393b14f518d98416da9d81b" translate="yes" xml:space="preserve">
          <source>Compute the overlap score between the two specified profile directories. The overlap score is computed based on the arc profiles. It is defined as the sum of min (p1_counter[i] / p1_sum_all, p2_counter[i] / p2_sum_all), for all arc counter i, where p1_counter[i] and p2_counter[i] are two matched counters and p1_sum_all and p2_sum_all are the sum of counter values in profile 1 and profile 2, respectively.</source>
          <target state="translated">지정된 두 프로파일 디렉토리 사이의 오버랩 스코어를 계산하십시오. 오버랩 점수는 아크 프로파일을 기반으로 계산됩니다. p1_counter [i] 및 p2_counter [i]는 일치하는 두 카운터이고 p1_sum_all 및 p2_sum_all은 모든 아크 카운터 i에 대해 최소의 합 (p1_counter [i] / p1_sum_all, p2_counter [i] / p2_sum_all)으로 정의됩니다. 프로필 1과 프로필 2의 카운터 값 합계</target>
        </trans-unit>
        <trans-unit id="e0428c06ffccfdc67cd165569d403d34631d68a4" translate="yes" xml:space="preserve">
          <source>Condition code register</source>
          <target state="translated">조건 코드 레지스터</target>
        </trans-unit>
        <trans-unit id="0ae2a8a1d30f4ab16342776ecad8922a8468db3e" translate="yes" xml:space="preserve">
          <source>Condition register field 0, &lt;code&gt;cr0&lt;/code&gt;.</source>
          <target state="translated">조건 레지스터 필드 0, &lt;code&gt;cr0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e7cba93bc22565aab9f967f87bf72c15fbda6979" translate="yes" xml:space="preserve">
          <source>Conditional move based on absolute comparison (&lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt;, &lt;code&gt;movt.ps&lt;/code&gt;/&lt;code&gt;movf.ps&lt;/code&gt;).</source>
          <target state="translated">절대 비교에 따른 조건부 이동 ( &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; , &lt;code&gt;movt.ps&lt;/code&gt; / &lt;code&gt;movf.ps&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ef8ee622eb15147934b0f1ea15e7848c0fa98464" translate="yes" xml:space="preserve">
          <source>Conditional move based on floating-point comparison (&lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt;, &lt;code&gt;movt.ps&lt;/code&gt;/&lt;code&gt;movf.ps&lt;/code&gt;).</source>
          <target state="translated">부동 소수점 비교 ( &lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; , &lt;code&gt;movt.ps&lt;/code&gt; / &lt;code&gt;movf.ps&lt;/code&gt; )에 기반한 조건부 이동 .</target>
        </trans-unit>
        <trans-unit id="34fb4ffc803fecfe4e7aef7908f668b60686f196" translate="yes" xml:space="preserve">
          <source>Configure a board specific runtime. This will be passed to the linker for newlib board library linking. The default is &lt;code&gt;or1ksim&lt;/code&gt;.</source>
          <target state="translated">보드 별 런타임을 구성하십시오. 이것은 newlib 보드 라이브러리 링크를 위해 링커로 전달됩니다. 기본값은 &lt;code&gt;or1ksim&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="73691e44c058afa420e3a5b298659ae385093f25" translate="yes" xml:space="preserve">
          <source>Conform to the language syntax of Objective-C 1.0, the language recognized by GCC 4.0. This only affects the Objective-C additions to the C/C++ language; it does not affect conformance to C/C++ standards, which is controlled by the separate C/C++ dialect option flags. When this option is used with the Objective-C or Objective-C++ compiler, any Objective-C syntax that is not recognized by GCC 4.0 is rejected. This is useful if you need to make sure that your Objective-C code can be compiled with older versions of GCC.</source>
          <target state="translated">GCC 4.0에서 인식되는 언어 인 Objective-C 1.0의 언어 구문을 준수합니다. 이것은 C / C ++ 언어에 대한 Objective-C 추가에만 영향을줍니다. 별도의 C / C ++ 언어 옵션 플래그에 의해 제어되는 C / C ++ 표준 준수에 영향을 미치지 않습니다. 이 옵션을 Objective-C 또는 Objective-C ++ 컴파일러와 함께 사용하면 GCC 4.0에서 인식되지 않는 Objective-C 구문이 거부됩니다. Objective-C 코드를 이전 버전의 GCC로 컴파일 할 수 있어야하는 경우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="276327c90b14e9bc39dc498e6536c698c6fb7874" translate="yes" xml:space="preserve">
          <source>Conformance to the same ABI and the same behavior of implementation-defined features are both relevant for compatibility.</source>
          <target state="translated">동일한 ABI 및 구현 정의 기능의 동일한 동작에 대한 적합성은 호환성과 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="af74bda50719fa1b3103b3627d3eb38149eb7313" translate="yes" xml:space="preserve">
          <source>Consider (as in C99 subclause 6.7.5 paragraph 4) a declaration &lt;code&gt;T
D1&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; contains declaration specifiers that specify a type &lt;var&gt;Type&lt;/var&gt; (such as &lt;code&gt;int&lt;/code&gt;) and &lt;code&gt;D1&lt;/code&gt; is a declarator that contains an identifier &lt;var&gt;ident&lt;/var&gt;. The type specified for &lt;var&gt;ident&lt;/var&gt; for derived declarators whose type does not include an attribute specifier is as in the ISO C standard.</source>
          <target state="translated">(C99 하위 조항 6.7.5 단락 4에서와 같이) 선언 &lt;code&gt;T D1&lt;/code&gt; 고려하십시오 . 여기서 &lt;code&gt;T&lt;/code&gt; 는 유형 &lt;var&gt;Type&lt;/var&gt; (예 : &lt;code&gt;int&lt;/code&gt; ) 을 지정하는 선언 지정자를 포함 하고 &lt;code&gt;D1&lt;/code&gt; 은 식별자 &lt;var&gt;ident&lt;/var&gt; 를 포함하는 선언자입니다 . 속성 지정자를 포함하지 않는 파생 선언자에 대해 &lt;var&gt;ident&lt;/var&gt; 에 지정된 형식은 ISO C 표준과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9b667c089da7e561b4d6f55e12e93a78181226e5" translate="yes" xml:space="preserve">
          <source>Consider all &lt;code&gt;static&lt;/code&gt; functions called once for inlining into their caller even if they are not marked &lt;code&gt;inline&lt;/code&gt;. If a call to a given function is integrated, then the function is not output as assembler code in its own right.</source>
          <target state="translated">모든 고려 &lt;code&gt;static&lt;/code&gt; 가 표시되지 않은 경우에도 자신의 호출자에 인라인에 대해 한 번 호출되는 함수 &lt;code&gt;inline&lt;/code&gt; . 주어진 함수에 대한 호출이 통합되면 함수는 그 자체로 어셈블러 코드로 출력되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="35a3be8ed672f20c07ec027046430f867cf3e587" translate="yes" xml:space="preserve">
          <source>Consider all functions for inlining, even if they are not declared inline. The compiler heuristically decides which functions are worth integrating in this way.</source>
          <target state="translated">인라인으로 선언되지 않은 경우에도 인라인을위한 모든 함수를 고려하십시오. 컴파일러는 이러한 방식으로 통합 할 가치가있는 기능을 경험적으로 결정합니다.</target>
        </trans-unit>
        <trans-unit id="7b85816a30be72db5578a7db246b88f298f1a216" translate="yes" xml:space="preserve">
          <source>Consider that instructions that may throw exceptions but don&amp;rsquo;t otherwise contribute to the execution of the program can be optimized away. This option is enabled by default for the Ada front end, as permitted by the Ada language specification. Optimization passes that cause dead exceptions to be removed are enabled independently at different optimization levels.</source>
          <target state="translated">예외를 발생시킬 수 있지만 프로그램 실행에 기여하지 않는 명령어는 최적화 할 수 있습니다. 이 옵션은 Ada 언어 사양에서 허용하는대로 Ada 프론트 엔드에 기본적으로 사용됩니다. 데드 예외를 제거하는 최적화 단계는 다른 최적화 수준에서 독립적으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="56b80af072fa83ee95788ec24e46c4595598d634" translate="yes" xml:space="preserve">
          <source>Consider the following example,</source>
          <target state="translated">다음 예를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="a59af01b7f010c19c9dde4af8032ceeec0657a9d" translate="yes" xml:space="preserve">
          <source>Consider type &lt;code&gt;int&lt;/code&gt; to be 16 bits wide, like &lt;code&gt;short int&lt;/code&gt;. Additionally, parameters passed on the stack are also aligned to a 16-bit boundary even on targets whose API mandates promotion to 32-bit.</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; 유형을 &lt;code&gt;short int&lt;/code&gt; 처럼 16 비트 폭으로 간주하십시오 . 또한 스택에 전달 된 매개 변수는 API가 32 비트 승격을 요구하는 대상에서도 16 비트 경계에 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="14249be6954dd348580bb1e0a79129f5f1192211" translate="yes" xml:space="preserve">
          <source>Constant 255.</source>
          <target state="translated">상수 255.</target>
        </trans-unit>
        <trans-unit id="7c36129cdf24a616a089dfb7d284688c9138762e" translate="yes" xml:space="preserve">
          <source>Constant 65535.</source>
          <target state="translated">상수 65535.</target>
        </trans-unit>
        <trans-unit id="7ebcf06cc87a00b632c948fbc204e56f0827cd01" translate="yes" xml:space="preserve">
          <source>Constant &lt;var&gt;n&lt;/var&gt;, where &lt;var&gt;n&lt;/var&gt; is a single-digit constant in the range 0 to 4.</source>
          <target state="translated">상수 &lt;var&gt;n&lt;/var&gt; . 여기서 &lt;var&gt;n&lt;/var&gt; 은 0-4 범위의 한 자리 상수입니다.</target>
        </trans-unit>
        <trans-unit id="37323b42fe56e6f04c3dbbef4d9fbb95b7fc380b" translate="yes" xml:space="preserve">
          <source>Constant for arithmetic/logical operations. This is like &lt;code&gt;i&lt;/code&gt;, except that for position independent code, no symbols / expressions needing relocations are allowed.</source>
          <target state="translated">산술 / 논리 연산을위한 상수. 위치 독립적 코드의 경우 재배치가 필요한 기호 / 표현이 허용되지 않는다는 점을 제외하면 &lt;code&gt;i&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="c7644d686263ca6ceaeace041caa08f8c6cf68aa" translate="yes" xml:space="preserve">
          <source>Constant greater than -1, less than 64</source>
          <target state="translated">-1보다 크고 64보다 작은 상수</target>
        </trans-unit>
        <trans-unit id="09c49e4a44186e5736b6b3d234fbcdd1b306818b" translate="yes" xml:space="preserve">
          <source>Constant greater than -64, less than 1</source>
          <target state="translated">-64보다 크고 1보다 작은 상수</target>
        </trans-unit>
        <trans-unit id="629c52a6147c82fa4c525c23e4812fa96465cd8a" translate="yes" xml:space="preserve">
          <source>Constant integer -1</source>
          <target state="translated">상수 정수 -1</target>
        </trans-unit>
        <trans-unit id="721c7841ba7521d9d4cd87f007487a95dabae8a8" translate="yes" xml:space="preserve">
          <source>Constant integer 0</source>
          <target state="translated">상수 정수 0</target>
        </trans-unit>
        <trans-unit id="4c0d77dad954cfa376cbed314919134fe483d92e" translate="yes" xml:space="preserve">
          <source>Constant integer 1</source>
          <target state="translated">상수 정수 1</target>
        </trans-unit>
        <trans-unit id="a0be78fc92c33b25cda27188d52e852922b4e406" translate="yes" xml:space="preserve">
          <source>Constant integer 2</source>
          <target state="translated">상수 정수 2</target>
        </trans-unit>
        <trans-unit id="202072b2675376ab5d42618242f422abd21566ab" translate="yes" xml:space="preserve">
          <source>Constant integer 8, 16, or 24</source>
          <target state="translated">상수 정수 8, 16 또는 24</target>
        </trans-unit>
        <trans-unit id="5bf3f3ad783e97cd6b61e26de5af436d02b8dbc8" translate="yes" xml:space="preserve">
          <source>Constant integer with a value of 0x7fffffff.</source>
          <target state="translated">값이 0x7fffffff 인 정수입니다.</target>
        </trans-unit>
        <trans-unit id="4b2e9b490d5b5f4c17de70d9c9fdf5aa2b4b1450" translate="yes" xml:space="preserve">
          <source>Constant larger than 31</source>
          <target state="translated">31보다 큰 상수</target>
        </trans-unit>
        <trans-unit id="47f3d5d59a235c75b0766f99a2edf9666aa348c9" translate="yes" xml:space="preserve">
          <source>Constant that fits in 8 bits</source>
          <target state="translated">8 비트에 맞는 상수</target>
        </trans-unit>
        <trans-unit id="719b7b797492e1507d09c13adb21a02c3fe64069" translate="yes" xml:space="preserve">
          <source>Constant whose negation is a signed 16-bit constant</source>
          <target state="translated">부정이 부호있는 16 비트 상수 인 상수</target>
        </trans-unit>
        <trans-unit id="180e678224087bf03d6c9c2f7ac11f4d9834fa9a" translate="yes" xml:space="preserve">
          <source>Constant zero</source>
          <target state="translated">상수 제로</target>
        </trans-unit>
        <trans-unit id="a9100a8537fb85e4bf388bedae7d5d58f76e7b6e" translate="yes" xml:space="preserve">
          <source>Constant?</source>
          <target state="translated">Constant?</target>
        </trans-unit>
        <trans-unit id="7efcb4b4f328cdb249f8926cb267f61ac8015a9d" translate="yes" xml:space="preserve">
          <source>Constraints for &lt;code&gt;asm&lt;/code&gt; operands</source>
          <target state="translated">&lt;code&gt;asm&lt;/code&gt; 피연산자에 대한 제약</target>
        </trans-unit>
        <trans-unit id="3e3f7e5411ee0f1fda2ac40b39097fae6a9abb77" translate="yes" xml:space="preserve">
          <source>Constructs webs as commonly used for register allocation purposes and assign each web individual pseudo register. This allows the register allocation pass to operate on pseudos directly, but also strengthens several other optimization passes, such as CSE, loop optimizer and trivial dead code remover. It can, however, make debugging impossible, since variables no longer stay in a &amp;ldquo;home register&amp;rdquo;.</source>
          <target state="translated">레지스터 할당 목적으로 일반적으로 사용되는 웹을 구성하고 각 웹 개별 의사 레지스터를 할당합니다. 이를 통해 레지스터 할당 패스가 의사에서 직접 작동 할 수 있지만 CSE, 루프 최적화 및 사소한 데드 코드 리무버와 같은 다른 여러 최적화 패스가 강화됩니다. 그러나 변수가 더 이상 &quot;홈 레지스터&quot;에 남아 있지 않으므로 디버깅을 불가능하게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4f501afecf0b8b5f3993371f4f6074a753dc0e6" translate="yes" xml:space="preserve">
          <source>Contributors to GCC</source>
          <target state="translated">GCC에 기고자</target>
        </trans-unit>
        <trans-unit id="4648a291e89516ba0f4f56b93d6fdb1d01cfd9c4" translate="yes" xml:space="preserve">
          <source>Control GCC&amp;rsquo;s optimizations to produce output suitable for live-patching.</source>
          <target state="translated">라이브 패치에 적합한 출력을 생성하도록 GCC의 최적화를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="2000010d8fcae415d2b9780e43435379e14ee053" translate="yes" xml:space="preserve">
          <source>Control how GCC aligns variables and constants of array, structure, or union types. Supported values for &lt;var&gt;type&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">GCC가 배열, 구조 또는 공용체 유형의 변수 및 상수를 정렬하는 방법을 제어합니다. &lt;var&gt;type&lt;/var&gt; 지원되는 값 은 '</target>
        </trans-unit>
        <trans-unit id="bcc7b6b362569344fe25ab394774bd26a1bf6f6a" translate="yes" xml:space="preserve">
          <source>Control how GCC aligns variables. Supported values for &lt;var&gt;type&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">GCC가 변수를 정렬하는 방법을 제어합니다. &lt;var&gt;type&lt;/var&gt; 에 지원되는 값 은 '</target>
        </trans-unit>
        <trans-unit id="7e88213c055c1aca5596a30dea879bf4859e75f5" translate="yes" xml:space="preserve">
          <source>Control how many registers are used to pass integer arguments. By default, no registers are used to pass arguments, and at most 3 registers can be used. You can control this behavior for a specific function by using the function attribute &lt;code&gt;regparm&lt;/code&gt;. See &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;.</source>
          <target state="translated">정수 인수를 전달하는 데 사용되는 레지스터 수를 제어하십시오. 기본적으로 레지스터를 사용하여 인수를 전달하지 않으며 최대 3 개의 레지스터를 사용할 수 있습니다. 함수 속성 &lt;code&gt;regparm&lt;/code&gt; 을 사용하여 특정 함수에 대해이 동작을 제어 할 수 있습니다 . &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;기능 속성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ae31e36dd1f96d1b47c3f78f649f25722c9f1d7b" translate="yes" xml:space="preserve">
          <source>Control if warning triggered by the &lt;code&gt;warn_if_not_aligned&lt;/code&gt; attribute should be issued. This is enabled by default. Use</source>
          <target state="translated">&lt;code&gt;warn_if_not_aligned&lt;/code&gt; 속성 에 의해 경고가 트리거되는지 여부를 제어하십시오 . 기본적으로 활성화되어 있습니다. 사용하다</target>
        </trans-unit>
        <trans-unit id="9e5c3f2f79d503814d4fe18475f20d72c26564d7" translate="yes" xml:space="preserve">
          <source>Control if warnings triggered by the &lt;code&gt;warn_if_not_aligned&lt;/code&gt; attribute should be issued. These warnings are enabled by default.</source>
          <target state="translated">&lt;code&gt;warn_if_not_aligned&lt;/code&gt; 속성 에 의해 트리거 된 경고를 발행 해야하는지 여부를 제어합니다 . 이러한 경고는 기본적으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="7631dd8867c98dbe9aea4e0521ca0a270c9af1bd" translate="yes" xml:space="preserve">
          <source>Control level of reproducibility of profile gathered by &lt;code&gt;-fprofile-generate&lt;/code&gt;. This makes it possible to rebuild program with same outcome which is useful, for example, for distribution packages.</source>
          <target state="translated">&lt;code&gt;-fprofile-generate&lt;/code&gt; 에서 수집 한 프로필의 재현성 수준을 제어합니다 . 이를 통해 예를 들어 배포 패키지에 유용한 동일한 결과로 프로그램을 다시 빌드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2f461ee948da2dba5ee60b9ffddb2967c79a05b" translate="yes" xml:space="preserve">
          <source>Control the IEEE compliance of floating-point comparisons, which affects the handling of cases where the result of a comparison is unordered. By default</source>
          <target state="translated">부동 소수점 비교의 IEEE 준수를 제어하여 비교 결과가 정렬되지 않은 경우의 처리에 영향을줍니다. 기본적으로</target>
        </trans-unit>
        <trans-unit id="2afb7e07aedef4a32dbbca185426a76a2840c4b0" translate="yes" xml:space="preserve">
          <source>Control the dumping at various stages of inter-procedural analysis language tree to a file. The file name is generated by appending a switch specific suffix to the source file name, and the file is created in the same directory as the output file. The following dumps are possible:</source>
          <target state="translated">절차 간 분석 언어 트리의 다양한 단계에서 파일로의 덤프를 제어합니다. 파일 이름은 소스 파일 이름에 스위치 특정 접미사를 추가하여 생성되며 파일은 출력 파일과 동일한 디렉토리에 작성됩니다. 다음과 같은 덤프가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="f18aaf944d2648faf5bedcbbdbf1ddd945fad607" translate="yes" xml:space="preserve">
          <source>Control the dumping at various stages of processing the intermediate language tree to a file. If the &amp;lsquo;</source>
          <target state="translated">중간 언어 트리를 처리하는 다양한 단계에서 파일로의 덤프를 제어하십시오. '</target>
        </trans-unit>
        <trans-unit id="c0a71f6d1404f7b16378e5d31c9c7e2a41e97704" translate="yes" xml:space="preserve">
          <source>Control the dumping of language-specific information. The &lt;var&gt;options&lt;/var&gt; and &lt;var&gt;filename&lt;/var&gt; portions behave as described in the</source>
          <target state="translated">언어 별 정보의 덤프를 제어합니다. &lt;var&gt;options&lt;/var&gt; 및 &lt;var&gt;filename&lt;/var&gt; 에서 설명한대로 작동 부</target>
        </trans-unit>
        <trans-unit id="d78b6d3fd867212c02526e9987edeed79105b1e7" translate="yes" xml:space="preserve">
          <source>Control the probability of the expression having the specified value. This parameter takes a percentage (i.e. 0 ... 100) as input.</source>
          <target state="translated">표현식이 지정된 값을 가질 확률을 제어하십시오. 이 매개 변수는 입력으로 백분율 (예 : 0 ... 100)을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3bc8404322e32343cc4763c8bd1ae2d2c9dab937" translate="yes" xml:space="preserve">
          <source>Control the verbosity of the dump file for the integrated register allocator. The default value is 5. If the value &lt;var&gt;n&lt;/var&gt; is greater or equal to 10, the dump output is sent to stderr using the same format as &lt;var&gt;n&lt;/var&gt; minus 10.</source>
          <target state="translated">통합 레지스터 할당 자에 대한 덤프 파일의 상세 정도를 제어하십시오. 기본값은 5입니다. 값 &lt;var&gt;n&lt;/var&gt; 이 10보다 크거나 같으면 &lt;var&gt;n&lt;/var&gt; -10 과 같은 형식을 사용하여 덤프 출력이 stderr로 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="f9bae08f2081e939f273d8f52a1db45d82560f46" translate="yes" xml:space="preserve">
          <source>Control whether GCC aligns &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;long double&lt;/code&gt;, and &lt;code&gt;long long&lt;/code&gt; variables on a two-word boundary or a one-word boundary. Aligning &lt;code&gt;double&lt;/code&gt; variables on a two-word boundary produces code that runs somewhat faster on a Pentium at the expense of more memory.</source>
          <target state="translated">GCC가 &lt;code&gt;double&lt;/code&gt; , &lt;code&gt;long double&lt;/code&gt; 및 &lt;code&gt;long long&lt;/code&gt; 변수를 두 단어 경계 또는 한 단어 경계에 정렬할지 여부를 제어합니다 . 두 단어 경계에서 &lt;code&gt;double&lt;/code&gt; 변수를 정렬 하면 더 많은 메모리를 사용하여 펜티엄에서 더 빠르게 실행되는 코드가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="8f446d353bc1e77fdd352360a3275f518dfbc090" translate="yes" xml:space="preserve">
          <source>Control whether GCC aligns &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;long long&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, and &lt;code&gt;long double&lt;/code&gt; variables on a 32-bit boundary (</source>
          <target state="translated">GCC 가 32 비트 경계에서 &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;long&lt;/code&gt; , &lt;code&gt;long long&lt;/code&gt; , &lt;code&gt;float&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; 및 &lt;code&gt;long double&lt;/code&gt; 변수를 정렬할지 여부를 제어합니다 (</target>
        </trans-unit>
        <trans-unit id="75311304fc882ae2426d795d34cedb8140da086e" translate="yes" xml:space="preserve">
          <source>Control whether or not the compiler uses IEEE floating-point comparisons. These correctly handle the case where the result of a comparison is unordered.</source>
          <target state="translated">컴파일러가 IEEE 부동 소수점 비교를 사용할지 여부를 제어합니다. 이것들은 비교 결과가 정렬되지 않은 경우를 올바르게 처리합니다.</target>
        </trans-unit>
        <trans-unit id="62bad428ae7c19b0490d45917456075bd42d88a6" translate="yes" xml:space="preserve">
          <source>Controlling header files and macro definitions. Also, getting dependency information for Make.</source>
          <target state="translated">헤더 파일 및 매크로 정의 제어 또한 Make에 대한 종속성 정보를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="e99744632595e185715acaad17e041aa084fa9ba" translate="yes" xml:space="preserve">
          <source>Controlling how diagnostics should be formatted.</source>
          <target state="translated">진단 형식 지정 방법을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="e7841aeb7ad7a7b2bbd17b2d58521eec5ba1a4f0" translate="yes" xml:space="preserve">
          <source>Controlling the kind of output: an executable, object files, assembler files, or preprocessed source.</source>
          <target state="translated">출력 종류 제어 : 실행 파일, 객체 파일, 어셈블러 파일 또는 사전 처리 된 소스.</target>
        </trans-unit>
        <trans-unit id="c6ecef85f48d8878d76bfb7e0a0331e88e337d9a" translate="yes" xml:space="preserve">
          <source>Controlling the variant of C language compiled.</source>
          <target state="translated">컴파일 된 C 언어의 변형 제어</target>
        </trans-unit>
        <trans-unit id="35f36b715e771eac424fea4a5652ad0db1feb811" translate="yes" xml:space="preserve">
          <source>Controls optimization dumps from various optimization passes. If the &amp;lsquo;</source>
          <target state="translated">다양한 최적화 단계에서 최적화 덤프를 제어합니다. '</target>
        </trans-unit>
        <trans-unit id="addf45283fa1231bccd97d1a11480f865b18f29c" translate="yes" xml:space="preserve">
          <source>Controls warnings if a shift count is greater than or equal to the bit width of the type. This warning is enabled by default.</source>
          <target state="translated">시프트 카운트가 유형의 비트 너비보다 크거나 같은 경우 경고를 제어합니다. 이 경고는 기본적으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="5c8bc0ebce27c4f8597b1ed37dbc7e6eb2315759" translate="yes" xml:space="preserve">
          <source>Controls warnings if a shift count is negative. This warning is enabled by default.</source>
          <target state="translated">시프트 카운트가 음수 인 경우 경고를 제어합니다. 이 경고는 기본적으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="eae41d379a4cfbab73e910f93e19e6f3bad5167f" translate="yes" xml:space="preserve">
          <source>Controls whether TLS variables may be accessed with offsets from the TLS segment register (&lt;code&gt;%gs&lt;/code&gt; for 32-bit, &lt;code&gt;%fs&lt;/code&gt; for 64-bit), or whether the thread base pointer must be added. Whether or not this is valid depends on the operating system, and whether it maps the segment to cover the entire TLS area.</source>
          <target state="translated">TLS 세그먼트 레지스터에서 오프셋을 사용하여 TLS 변수에 액세스 할 수 있는지 ( 32 비트의 경우 &lt;code&gt;%fs&lt;/code&gt; &lt;code&gt;%gs&lt;/code&gt; , 64 비트의 경우 % fs ) 또는 스레드 기본 포인터를 추가해야하는지 여부를 제어합니다. 이것이 유효한지 여부는 운영 체제 및 전체 TLS 영역을 커버하도록 세그먼트를 맵핑하는지 여부에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="eb9ef4e6ab162f6fc8a3bf857fc774382a954629" translate="yes" xml:space="preserve">
          <source>Conversely, &lt;code&gt;bar&lt;/code&gt; and the call to &lt;code&gt;foo&lt;/code&gt; in the fourth marked line are used in contexts that do depend on the type of &lt;code&gt;T&lt;/code&gt;, so they are only looked up at the point of instantiation, and you can provide declarations for them after declaring the template, but before instantiating it. In particular, if you instantiate &lt;code&gt;A::f&amp;lt;int&amp;gt;&lt;/code&gt;, the last line will call an overloaded &lt;code&gt;::foo(int)&lt;/code&gt; if one was provided, even if after the declaration of &lt;code&gt;struct A&lt;/code&gt;.</source>
          <target state="translated">반대로, 네 번째 표시된 줄에서 &lt;code&gt;bar&lt;/code&gt; 및 &lt;code&gt;foo&lt;/code&gt; 호출 은 &lt;code&gt;T&lt;/code&gt; 유형에 따라 달라지는 컨텍스트에서 사용 되므로 인스턴스화 시점에서만 조회되므로 템플릿을 선언 한 후 선언을 제공 할 수 있습니다. 그러나 인스턴스화하기 전에. 특히 &lt;code&gt;A::f&amp;lt;int&amp;gt;&lt;/code&gt; 를 인스턴스화 하면 &lt;code&gt;struct A&lt;/code&gt; 선언 후라도 마지막 행은 과부하 된 &lt;code&gt;::foo(int)&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="1dbc54a6ca4a64275cd12138ea70589c4f463e73" translate="yes" xml:space="preserve">
          <source>Conversely, if the register is a call-clobbered register, making calls to functions that use standard ABI may lose contents of the variable. Such calls may be created by the compiler even if none are evident in the original program, for example when libgcc functions are used to make up for unavailable instructions.</source>
          <target state="translated">반대로 레지스터가 콜 클로버 레지스터 인 경우 표준 ABI를 사용하는 함수를 호출하면 변수의 내용이 손실 될 수 있습니다. 이러한 호출은 원래 프로그램에 명백하지 않은 경우에도 (예 : libgcc 함수를 사용하여 사용할 수없는 명령어를 보충하는 경우) 컴파일러에서 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff7d2b7b709500e425e46256b872f1c524a8fe88" translate="yes" xml:space="preserve">
          <source>Conversely, when you include the same header file in a main source file that declares it as &amp;lsquo;</source>
          <target state="translated">반대로, 동일한 헤더 파일을 기본 소스 파일에 포함하면 '</target>
        </trans-unit>
        <trans-unit id="f8292e36ff2425ba64b2fca8bba18ef8c5d24cbf" translate="yes" xml:space="preserve">
          <source>Conversion from double precision to single precision.</source>
          <target state="translated">배정 밀도에서 단 정밀도로 변환</target>
        </trans-unit>
        <trans-unit id="e8f87ba256340926897664cced7edc0ce8ec124d" translate="yes" xml:space="preserve">
          <source>Conversion from floating point to signed or unsigned integer types, with truncation towards zero.</source>
          <target state="translated">부동 소수점에서 부호있는 또는 부호없는 정수 유형으로 변환 (잘림이 0을 향함)</target>
        </trans-unit>
        <trans-unit id="e8ec2eea2629558824283e676ad9bac71b3d3e53" translate="yes" xml:space="preserve">
          <source>Conversion from signed or unsigned integer types to floating-point types.</source>
          <target state="translated">부호있는 또는 부호없는 정수 유형에서 부동 소수점 유형으로 변환</target>
        </trans-unit>
        <trans-unit id="416cd3e7b0ad0f46f99e977b880dc368db1cdff8" translate="yes" xml:space="preserve">
          <source>Conversion from single precision to double precision.</source>
          <target state="translated">단 정도에서 배정도로 변환</target>
        </trans-unit>
        <trans-unit id="0fc5b8691f90f80b04961e22033d17dee1964933" translate="yes" xml:space="preserve">
          <source>Conversion from single-precision floating point to signed integer, rounding to the nearest integer and ties away from zero. This corresponds to the &lt;code&gt;__builtin_lroundf&lt;/code&gt; function when</source>
          <target state="translated">단 정밀도 부동 소수점에서 부호있는 정수로 변환하여 가장 가까운 정수로 반올림하고 0에서 멀어지게합니다. 이것은 &lt;code&gt;__builtin_lroundf&lt;/code&gt; 함수에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="536e910ea0e856f9ebf3793f69bec672bb95cd2c" translate="yes" xml:space="preserve">
          <source>Conversions by prototypes between fixed/floating-point values and vice versa. The absence of these prototypes when compiling with traditional C causes serious problems. This is a subset of the possible conversion warnings; for the full set use</source>
          <target state="translated">고정 소수점 / 부동 소수점 값 간의 프로토 타입 변환 및 그 반대로 변환 기존 C로 컴파일 할 때 이러한 프로토 타입이 없으면 심각한 문제가 발생합니다. 이것은 가능한 변환 경고의 일부입니다. 전 세트 사용</target>
        </trans-unit>
        <trans-unit id="0912352accd4bfa1711e2febca470cb4f85bbc4c" translate="yes" xml:space="preserve">
          <source>Conversions:</source>
          <target state="translated">Conversions:</target>
        </trans-unit>
        <trans-unit id="baf1df2f34189a80f5d58da24bff382fe6f23f9c" translate="yes" xml:space="preserve">
          <source>Convert a 128-bit IEEE floating point value to &lt;code&gt;double&lt;/code&gt; using round to odd as the rounding mode.</source>
          <target state="translated">반올림 모드로 반올림을 사용하여 128 비트 IEEE 부동 소수점 값을 &lt;code&gt;double&lt;/code&gt; 변환 하십시오.</target>
        </trans-unit>
        <trans-unit id="c5f6051eea145ce2adef0c8027dd705cfcc7007e" translate="yes" xml:space="preserve">
          <source>Convert function return with &lt;var&gt;choice&lt;/var&gt;. The default is &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;choice&lt;/var&gt; 함수 리턴을 변환하십시오 . 기본값은 '</target>
        </trans-unit>
        <trans-unit id="454c8084600f90536a1954e8c20d848d81c823ed" translate="yes" xml:space="preserve">
          <source>Convert indirect call and jump with &lt;var&gt;choice&lt;/var&gt;. The default is &amp;lsquo;</source>
          <target state="translated">간접 전화를 변환하고 &lt;var&gt;choice&lt;/var&gt; . 기본값은 '</target>
        </trans-unit>
        <trans-unit id="e6098cfb721df754afe96180a874c8cc3a1a8ded" translate="yes" xml:space="preserve">
          <source>Convert pair lower to single (&lt;code&gt;cvt.s.pl&lt;/code&gt;).</source>
          <target state="translated">쌍을 단일로 변환하십시오 ( &lt;code&gt;cvt.s.pl&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="52f3ab191bdd722d1394008161cded401dd949a0" translate="yes" xml:space="preserve">
          <source>Convert pair to paired single (&lt;code&gt;cvt.ps.s&lt;/code&gt;).</source>
          <target state="translated">페어를 페어 드 싱글 ( &lt;code&gt;cvt.ps.s&lt;/code&gt; )로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="dbfe6d8e23313dd7f9196c8cdcc1c08381a49c43" translate="yes" xml:space="preserve">
          <source>Convert pair upper to single (&lt;code&gt;cvt.s.pu&lt;/code&gt;).</source>
          <target state="translated">pair upper를 single로 변환하십시오 ( &lt;code&gt;cvt.s.pu&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="055bbf265923b2e5410a5e939d7297c0c9f2b211" translate="yes" xml:space="preserve">
          <source>Convert paired single to paired word (&lt;code&gt;cvt.pw.ps&lt;/code&gt;).</source>
          <target state="translated">쌍을 이루는 단일 단어를 쌍을 이루는 단어로 변환하십시오 ( &lt;code&gt;cvt.pw.ps&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="8b6b177ab15aa362100af3868aea344b1c1501b0" translate="yes" xml:space="preserve">
          <source>Convert paired word to paired single (&lt;code&gt;cvt.ps.pw&lt;/code&gt;).</source>
          <target state="translated">짝을 이루는 단어를 짝을 이루는 싱글로 변환하십시오 ( &lt;code&gt;cvt.ps.pw&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="3b04bf1a5e85023c3eed3599d79cb09164690ab2" translate="yes" xml:space="preserve">
          <source>Copy Assignment operators copy virtual bases twice</source>
          <target state="translated">복사 할당 연산자는 가상베이스를 두 번 복사합니다.</target>
        </trans-unit>
        <trans-unit id="d5eae2b9f3ad758ce3ef79fc7015a6ffa9156eac" translate="yes" xml:space="preserve">
          <source>Copyright &amp;copy; 1988-2019 Free Software Foundation, Inc.</source>
          <target state="translated">저작권 &amp;copy; 1988-2019 Free Software Foundation, Inc.</target>
        </trans-unit>
        <trans-unit id="00d80b436f1c8689f9094a048f0b7d3b3fb4eee4" translate="yes" xml:space="preserve">
          <source>Copyright &amp;copy; 1988-2020 Free Software Foundation, Inc.</source>
          <target state="translated">저작권 &amp;copy; 1988-2020 Free Software Foundation, Inc.</target>
        </trans-unit>
        <trans-unit id="aa5bc69c89234b43d34e0f300cbb8e8580610fdc" translate="yes" xml:space="preserve">
          <source>Core control register class.</source>
          <target state="translated">핵심 제어 레지스터 클래스.</target>
        </trans-unit>
        <trans-unit id="26ed802e7eb78ff2045b4541fe370087376fea5e" translate="yes" xml:space="preserve">
          <source>Cost to assume for a multiply instruction, with &amp;lsquo;</source>
          <target state="translated">곱하기 명령어의 가정 비용은 '</target>
        </trans-unit>
        <trans-unit id="c2ddd3bb796bfb895719a519a79aeec2d836822b" translate="yes" xml:space="preserve">
          <source>Cost, roughly measured as the cost of a single typical machine instruction, at which GCSE optimizations do not constrain the distance an expression can travel. This is currently supported only in the code hoisting pass. The lesser the cost, the more aggressive code hoisting is. Specifying 0 allows all expressions to travel unrestricted distances.</source>
          <target state="translated">GCSE 최적화가 표현식이 이동할 수있는 거리를 제한하지 않는 단일 일반 기계 명령어의 비용으로 대략 측정 된 비용. 이것은 현재 코드 호이 스팅 패스에서만 지원됩니다. 비용이 적을수록 코드 호이 스팅이 더욱 활발해집니다. 0을 지정하면 모든 표현식이 무제한 거리를 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73a8cda37ae16987b1b76b7dd95bcc1d393efb64" translate="yes" xml:space="preserve">
          <source>Create a canonical counter for number of iterations in loops for which determining number of iterations requires complicated analysis. Later optimizations then may determine the number easily. Useful especially in connection with unrolling.</source>
          <target state="translated">반복 횟수를 결정하는 데 복잡한 분석이 필요한 루프의 반복 횟수에 대한 표준 카운터를 만듭니다. 나중에 최적화하면 숫자를 쉽게 결정할 수 있습니다. 언 롤링과 관련하여 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="abd404fec245486ddadc6af0006baee144b9f9b5" translate="yes" xml:space="preserve">
          <source>Create a shared object. It is recommended that</source>
          <target state="translated">공유 객체를 만듭니다. 다음을 권장합니다</target>
        </trans-unit>
        <trans-unit id="f1fd203b49f15a9115d31d7e6edbf2d093ba7de0" translate="yes" xml:space="preserve">
          <source>Create constant pools in the compiler instead of deferring it to the assembler. This option is the default and required for correct code generation on CK801 and CK802, and is optional on other processors.</source>
          <target state="translated">컴파일러에 지연 풀을 지정하지 않고 컴파일러에서 상수 풀을 작성하십시오. 이 옵션은 기본값이며 CK801 및 CK802에서 올바른 코드 생성에 필요하며 다른 프로세서에서는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="b23e0354f5ad5eff5e150918b9120e5576f9697a" translate="yes" xml:space="preserve">
          <source>Create long file names for included source files. For example, if the header file</source>
          <target state="translated">포함 된 소스 파일의 긴 파일 이름을 작성하십시오. 예를 들어 헤더 파일이</target>
        </trans-unit>
        <trans-unit id="e38ae255fe9e80cdce8fdaed0460f9c86fe6b8ba" translate="yes" xml:space="preserve">
          <source>Creates a new &amp;lsquo;</source>
          <target state="translated">새로운 '</target>
        </trans-unit>
        <trans-unit id="99dfbad76db4acc6eb91954940ce7b9993db8870" translate="yes" xml:space="preserve">
          <source>Creates an inter-thread happens-before constraint from the release (or stronger) semantic store to this acquire load. Can prevent hoisting of code to before the operation.</source>
          <target state="translated">릴리스 (또는 더 강한) 시맨틱 저장소에서이 획득로드까지 스레드 간 발생 제한 조건을 작성합니다. 작업 전에 코드를 들어 올리는 것을 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="281a58c77cb45edf43cfdf897384199b4ab0a3ee" translate="yes" xml:space="preserve">
          <source>Creates an inter-thread happens-before constraint to acquire (or stronger) semantic loads that read from this release store. Can prevent sinking of code to after the operation.</source>
          <target state="translated">이 릴리스 저장소에서 읽은 의미로드를 획득하기 위해 스레드 간 발생 제한 조건을 작성합니다. 작업 후 코드가 싱킹되는 것을 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67ae8f8fb8bba8ab92d3a89b17a6600fa05951e3" translate="yes" xml:space="preserve">
          <source>Creates and defines a register class. These register classes can be used by inline &lt;code&gt;asm&lt;/code&gt; constructs. &lt;var&gt;registers&lt;/var&gt; may be a single register, register range separated by ellipses, or comma-separated list of those. Example:</source>
          <target state="translated">레지스터 클래스를 작성하고 정의합니다. 이 레지스터 클래스는 인라인 &lt;code&gt;asm&lt;/code&gt; 구문 으로 사용할 수 있습니다 . &lt;var&gt;registers&lt;/var&gt; 는 단일 레지스터, 타원으로 구분 된 레지스터 범위 또는 쉼표로 구분 된 목록 일 수 있습니다. 예:</target>
        </trans-unit>
        <trans-unit id="6e67e7d1e719647852b7fdbba193a58bb75ed395" translate="yes" xml:space="preserve">
          <source>Critical functions disable interrupts upon entry and restore the previous interrupt state upon exit. Critical functions cannot also have the &lt;code&gt;naked&lt;/code&gt;, &lt;code&gt;reentrant&lt;/code&gt; or &lt;code&gt;interrupt&lt;/code&gt; attributes.</source>
          <target state="translated">중요한 기능은 진입시 인터럽트를 비활성화하고 종료시 이전 인터럽트 상태를 복원합니다. 중요한 함수는 &lt;code&gt;naked&lt;/code&gt; , &lt;code&gt;reentrant&lt;/code&gt; 또는 &lt;code&gt;interrupt&lt;/code&gt; 속성을 가질 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c3cb5c6e6c93496c35c07eb658977d77e8d997f1" translate="yes" xml:space="preserve">
          <source>Current argument is the name of a library or startup file of some sort. Search for that file in a standard list of directories and substitute the full name found. The current working directory is included in the list of directories scanned.</source>
          <target state="translated">현재 인수는 일종의 라이브러리 또는 시작 파일 이름입니다. 표준 디렉토리 목록에서 해당 파일을 검색하고 찾은 전체 이름으로 대체하십시오. 현재 작업 디렉토리가 스캔 된 디렉토리 목록에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="27ed6e70669ea07173e0ff90384757c33382fb6e" translate="yes" xml:space="preserve">
          <source>Current argument is the name of a linker script. Search for that file in the current list of directories to scan for libraries. If the file is located insert a</source>
          <target state="translated">현재 인수는 링커 스크립트의 이름입니다. 라이브러리를 스캔 할 현재 디렉토리 목록에서 해당 파일을 검색하십시오. 파일이있는 경우</target>
        </trans-unit>
        <trans-unit id="318f590d6974d7ec1e4d3da7f86481fca68df621" translate="yes" xml:space="preserve">
          <source>Current gcov-tool supports the following functionalities:</source>
          <target state="translated">현재 gcov-tool은 다음 기능을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="883949fd66aefc2f68b17e769896d2b8ef7a23bf" translate="yes" xml:space="preserve">
          <source>Currently the x86 GNU/Linux target provides an implementation based on Intel Control-flow Enforcement Technology (CET).</source>
          <target state="translated">현재 x86 GNU / Linux 대상은 Intel CET (Control-flow Enforcement Technology) 기반 구현을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4e2c32ee916d61bb5fb82fcf33fd745d76fa8899" translate="yes" xml:space="preserve">
          <source>Currently this feature only works for</source>
          <target state="translated">현재이 기능은</target>
        </trans-unit>
        <trans-unit id="0990f74b9abadf3ef16d92f66dc8a33347d7b30f" translate="yes" xml:space="preserve">
          <source>Currently, ARM and AArch64 back ends do not support ACLE 2.0 fully. Both back ends support CRC32 intrinsics and the ARM back end supports the Coprocessor intrinsics, all from</source>
          <target state="translated">현재 ARM 및 AArch64 백엔드는 ACLE 2.0을 완전히 지원하지 않습니다. 두 백엔드는 모두 CRC32 내장 함수를 지원하고 ARM 백엔드는 보조 프로세서 내장 함수를 모두 지원합니다.</target>
        </trans-unit>
        <trans-unit id="31736ea72fe4084b8c34c06d50c0f1b2816826be" translate="yes" xml:space="preserve">
          <source>Currently, GCC defines &lt;code&gt;__STDC__&lt;/code&gt; unconditionally. This provides good results in practice.</source>
          <target state="translated">현재 GCC는 &lt;code&gt;__STDC__&lt;/code&gt; 를 무조건 정의합니다 . 이것은 실제로 좋은 결과를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2f63ff4fabd516030a0097fd6f4d244c1efad6e8" translate="yes" xml:space="preserve">
          <source>Currently, the attribute is ignored for inlined functions. If the attribute is applied to a symbol &lt;em&gt;definition&lt;/em&gt;, an error is reported. If a symbol previously declared &lt;code&gt;dllimport&lt;/code&gt; is later defined, the attribute is ignored in subsequent references, and a warning is emitted. The attribute is also overridden by a subsequent declaration as &lt;code&gt;dllexport&lt;/code&gt;.</source>
          <target state="translated">현재 인라인 함수의 경우 속성이 무시됩니다. 속성이 기호 &lt;em&gt;정의에&lt;/em&gt; 적용 되면 오류가보고됩니다. 이전에 &lt;code&gt;dllimport&lt;/code&gt; 로 선언 된 기호 가 나중에 정의되면 이후 참조에서 속성이 무시되고 경고가 발생합니다. &lt;code&gt;dllexport&lt;/code&gt; 라는 후속 선언으로 속성이 재정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="590e74950b3a359e45f46ccc033df08293e7e8d0" translate="yes" xml:space="preserve">
          <source>Currently, the preferred dialect makes plain bit-fields signed, because this is simplest. Since &lt;code&gt;int&lt;/code&gt; is the same as &lt;code&gt;signed int&lt;/code&gt; in every other context, it is cleanest for them to be the same in bit-fields as well.</source>
          <target state="translated">현재 선호하는 방언은 일반 비트 필드에 서명을합니다. 이것이 가장 단순하기 때문입니다. &lt;code&gt;int&lt;/code&gt; 는 다른 모든 상황에서 &lt;code&gt;signed int&lt;/code&gt; 와 동일 하기 때문에 비트 필드에서도 동일하게 유지되는 것이 가장 깨끗합니다.</target>
        </trans-unit>
        <trans-unit id="62ab12d09721515fc5fde562eb0862cdc8c3be63" translate="yes" xml:space="preserve">
          <source>Currently, there are two Blackfin-specific built-in functions. These are used for generating &lt;code&gt;CSYNC&lt;/code&gt; and &lt;code&gt;SSYNC&lt;/code&gt; machine insns without using inline assembly; by using these built-in functions the compiler can automatically add workarounds for hardware errata involving these instructions. These functions are named as follows:</source>
          <target state="translated">현재 두 개의 Blackfin 전용 내장 기능이 있습니다. 인라인 어셈블리를 사용하지 않고 &lt;code&gt;CSYNC&lt;/code&gt; 및 &lt;code&gt;SSYNC&lt;/code&gt; 머신 인스 턴 을 생성하는 데 사용됩니다 . 이러한 내장 함수를 사용하여 컴파일러는 이러한 명령어와 관련된 하드웨어 정오표에 대한 해결 방법을 자동으로 추가 할 수 있습니다. 이러한 기능의 이름은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3463fd1fcbee98183382ce3e6bfb37d05534e64b" translate="yes" xml:space="preserve">
          <source>Custom instruction assignments given by individual</source>
          <target state="translated">개인별 맞춤형 교육 과제</target>
        </trans-unit>
        <trans-unit id="f2bc7d2b6265d22c6647e1fcd64c13f072748076" translate="yes" xml:space="preserve">
          <source>D documentation code (Ddoc).</source>
          <target state="translated">D 문서 코드 (Ddoc).</target>
        </trans-unit>
        <trans-unit id="2c7c0a531f3f523f274fda8de9447eb2371b07a9" translate="yes" xml:space="preserve">
          <source>D interface file.</source>
          <target state="translated">D 인터페이스 파일.</target>
        </trans-unit>
        <trans-unit id="6e41c2f41f21895821ff2de4b2b537b418d821df" translate="yes" xml:space="preserve">
          <source>D register</source>
          <target state="translated">D 레지스터</target>
        </trans-unit>
        <trans-unit id="2b608c731b27a1c96a6f8a0e732c2d9673589c56" translate="yes" xml:space="preserve">
          <source>D source code.</source>
          <target state="translated">D 소스 코드.</target>
        </trans-unit>
        <trans-unit id="6e946b779e60851d5c244c3ad74774cbf9f1d48d" translate="yes" xml:space="preserve">
          <source>DD</source>
          <target state="translated">DD</target>
        </trans-unit>
        <trans-unit id="333132be138ba9ace941111a0f174248952df7a1" translate="yes" xml:space="preserve">
          <source>DF</source>
          <target state="translated">DF</target>
        </trans-unit>
        <trans-unit id="53a81edefe355889dccbacb38a4a1453f4e85785" translate="yes" xml:space="preserve">
          <source>DL</source>
          <target state="translated">DL</target>
        </trans-unit>
        <trans-unit id="8fe69de0441ad2ce15deb455eb1d3b4c6713b22c" translate="yes" xml:space="preserve">
          <source>Data file relocation.</source>
          <target state="translated">데이터 파일 재배치</target>
        </trans-unit>
        <trans-unit id="12293b22c91f6b4096277825dea65487973f1c86" translate="yes" xml:space="preserve">
          <source>Data prefetch does not generate faults if &lt;var&gt;addr&lt;/var&gt; is invalid, but the address expression itself must be valid. For example, a prefetch of &lt;code&gt;p-&amp;gt;next&lt;/code&gt; does not fault if &lt;code&gt;p-&amp;gt;next&lt;/code&gt; is not a valid address, but evaluation faults if &lt;code&gt;p&lt;/code&gt; is not a valid address.</source>
          <target state="translated">&lt;var&gt;addr&lt;/var&gt; 가 유효하지 않은 경우 데이터 프리 페치는 결함을 생성하지 않지만 주소 표현식 자체는 유효해야합니다. 예를 들어, 프리 페치 &lt;code&gt;p-&amp;gt;next&lt;/code&gt; 이상 발생하지 않는 &lt;code&gt;p-&amp;gt;next&lt;/code&gt; 경우 유효한 주소 아니지만 평가 결함 &lt;code&gt;p&lt;/code&gt; 유효한 주소 아니다.</target>
        </trans-unit>
        <trans-unit id="c2a93a0b6a01599dcd1bcda6f09bcde290d7a928" translate="yes" xml:space="preserve">
          <source>Data register</source>
          <target state="translated">데이터 레지스터</target>
        </trans-unit>
        <trans-unit id="46a7bcc6b46e84d9b5870e2cd0ac98f1bdb1402e" translate="yes" xml:space="preserve">
          <source>Data register (arbitrary general purpose register)</source>
          <target state="translated">데이터 레지스터 (임의 범용 레지스터)</target>
        </trans-unit>
        <trans-unit id="47be067ca541e17c43e79dffecbcbbad2c9d9a08" translate="yes" xml:space="preserve">
          <source>Data type: &lt;strong id=&quot;index-struct-_005f_005fhtm_005ftdb&quot;&gt;struct __htm_tdb&lt;/strong&gt;</source>
          <target state="translated">데이터 유형 : &lt;strong id=&quot;index-struct-_005f_005fhtm_005ftdb&quot;&gt;struct __htm_tdb&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2310e7e6984f7b9841fe3043d76bb8748b8032aa" translate="yes" xml:space="preserve">
          <source>Data types for complex numbers.</source>
          <target state="translated">복소수에 대한 데이터 유형.</target>
        </trans-unit>
        <trans-unit id="c002fd4f69749774cd614b7282439760b0a132f5" translate="yes" xml:space="preserve">
          <source>Debug dumps can be enabled with a</source>
          <target state="translated">디버그 덤프는</target>
        </trans-unit>
        <trans-unit id="d5a9f22c83f9299405413f6e5e553516a6cf6903" translate="yes" xml:space="preserve">
          <source>Debugging (</source>
          <target state="translated">디버깅</target>
        </trans-unit>
        <trans-unit id="b7b96436cf5229d16fb5897e129a114445f95678" translate="yes" xml:space="preserve">
          <source>Debugging Options</source>
          <target state="translated">디버깅 옵션</target>
        </trans-unit>
        <trans-unit id="aff6d1089cf54da46ac69c2183c78d051d04eff0" translate="yes" xml:space="preserve">
          <source>Decimal Floating Types.</source>
          <target state="translated">십진 부동 유형.</target>
        </trans-unit>
        <trans-unit id="6a66960857760a2cd63559ec52ee94a4a711e705" translate="yes" xml:space="preserve">
          <source>Declarations of external variables and functions within a block apply only to the block containing the declaration. In other words, they have the same scope as any other declaration in the same place.</source>
          <target state="translated">블록 내의 외부 변수 및 함수 선언은 선언을 포함하는 블록에만 적용됩니다. 다시 말해, 같은 장소에있는 다른 선언과 동일한 범위를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="226f69acb8ae88a869e2645962bf30e8ec7e974f" translate="yes" xml:space="preserve">
          <source>Declares the instruction to be commutative for this operand and the following operand. This means that the compiler may interchange the two operands if that is the cheapest way to make all operands fit the constraints. &amp;lsquo;</source>
          <target state="translated">이 피연산자와 다음 피연산자에 대해 명령을 정식으로 선언합니다. 이것은 모든 피연산자가 제약 조건에 맞도록하는 가장 저렴한 방법 인 경우 컴파일러가 두 피연산자를 교환 할 수 있음을 의미합니다. '</target>
        </trans-unit>
        <trans-unit id="6e381a53c21bfca57ae3c6418395aa6805faa3e6" translate="yes" xml:space="preserve">
          <source>Declaring multiple function versions.</source>
          <target state="translated">여러 기능 버전 선언</target>
        </trans-unit>
        <trans-unit id="9df458345b87f143e1443622e3689e81c8f18de5" translate="yes" xml:space="preserve">
          <source>Declaring objects with &lt;code&gt;uncached&lt;/code&gt; allows you to exclude data-cache participation in load and store operations on those objects without involving the additional semantic implications of &lt;code&gt;volatile&lt;/code&gt;. The &lt;code&gt;.di&lt;/code&gt; instruction suffix is used for all loads and stores of data declared &lt;code&gt;uncached&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;uncached&lt;/code&gt; 객체를 선언 하면 &lt;code&gt;volatile&lt;/code&gt; 의 추가 의미 적 의미를 포함하지 않고 해당 객체에 대한로드 및 저장 작업에서 데이터 캐시 참여를 제외 할 수 있습니다 . &lt;code&gt;.di&lt;/code&gt; 명령 접미사는 모든 부하에 사용되며 데이터의 저장 선언 &lt;code&gt;uncached&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dea979b67c132bc175e1957da54321717a0b3e04" translate="yes" xml:space="preserve">
          <source>Declaring that functions have no side effects, or that they can never return.</source>
          <target state="translated">함수에 부작용이 없거나 반환 할 수 없음을 선언합니다.</target>
        </trans-unit>
        <trans-unit id="63030d3cd1e02a687549d142e20f0269121d2b83" translate="yes" xml:space="preserve">
          <source>Declaring the variable</source>
          <target state="translated">변수 선언</target>
        </trans-unit>
        <trans-unit id="b2609010c78f10c37fecace799c32d84a8b0113e" translate="yes" xml:space="preserve">
          <source>Declaring zero-length arrays in other contexts, including as interior members of structure objects or as non-member objects, is discouraged. Accessing elements of zero-length arrays declared in such contexts is undefined and may be diagnosed.</source>
          <target state="translated">구조 객체의 내부 멤버 또는 비 멤버 객체를 포함하여 다른 컨텍스트에서 길이가 0 인 배열을 선언하지 않는 것이 좋습니다. 이러한 맥락에서 선언 된 길이가 0 인 배열의 요소에 액세스하는 것은 정의되어 있지 않으며 진단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0ce91fb53831d435a29b5632774a3c603665597" translate="yes" xml:space="preserve">
          <source>Declaring zero-length arrays is allowed in GNU C as an extension. A zero-length array can be useful as the last element of a structure that is really a header for a variable-length object:</source>
          <target state="translated">길이가 0 인 배열 선언은 GNU C에서 확장으로 허용됩니다. 길이가 0 인 배열은 실제로 가변 길이 객체의 헤더 인 구조의 마지막 요소로 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ccbb003fcbbef0455a040407eca25644a68c8af" translate="yes" xml:space="preserve">
          <source>Default instruction scheduling parameters are used for values that select an architecture and not an implementation. These are &amp;lsquo;</source>
          <target state="translated">기본 명령어 스케줄링 매개 변수는 구현이 아닌 아키텍처를 선택하는 값에 사용됩니다. 이것들은 '</target>
        </trans-unit>
        <trans-unit id="ba9d931a2de4e95a1c6e18f4c96c1c9b9529c7aa" translate="yes" xml:space="preserve">
          <source>Default to 64-bit memory allocation routines.</source>
          <target state="translated">기본적으로 64 비트 메모리 할당 루틴.</target>
        </trans-unit>
        <trans-unit id="bc0e52c70e2e3d40aed76c210b466f12c8a6307d" translate="yes" xml:space="preserve">
          <source>Default visibility corresponds to &amp;ldquo;external linkage&amp;rdquo; in the language.</source>
          <target state="translated">기본 가시성은 언어의 &quot;외부 연결&quot;에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="422c626b9da356260a74af4c444e356b1dff1705" translate="yes" xml:space="preserve">
          <source>Default visibility is the normal case for the object file format. This value is available for the visibility attribute to override other options that may change the assumed visibility of entities.</source>
          <target state="translated">기본 가시성은 객체 파일 형식의 일반적인 경우입니다. 이 값은 가시성 속성이 엔티티의 가정 가시성을 변경시킬 수있는 다른 옵션을 대체하기 위해 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="dcc8364c434a51851187f20fa9cd4e3c3aefb760" translate="yes" xml:space="preserve">
          <source>Define a copy constructor and an assignment operator for classes with dynamically-allocated memory.</source>
          <target state="translated">동적으로 할당 된 메모리가있는 클래스에 대한 복사 생성자와 할당 연산자를 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="5e2f8d06c00c297c0f950f50c2f9216e48b9c380" translate="yes" xml:space="preserve">
          <source>Define additional macros required for using the POSIX threads library. You should use this option consistently for both compilation and linking. This option is supported on GNU/Linux targets, most other Unix derivatives, and also on x86 Cygwin and MinGW targets.</source>
          <target state="translated">POSIX 스레드 라이브러리 사용에 필요한 추가 매크로를 정의하십시오. 이 옵션은 컴파일 및 링크 모두에 일관되게 사용해야합니다. 이 옵션은 GNU / Linux 대상, 대부분의 다른 유닉스 파생물 및 x86 Cygwin 및 MinGW 대상에서도 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="8c097d198bbcce6c15c43b9673925ec2a844aa50" translate="yes" xml:space="preserve">
          <source>Define an argument called &lt;var&gt;key&lt;/var&gt; with a value of &lt;var&gt;value&lt;/var&gt; for the plugin called &lt;var&gt;name&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;name&lt;/var&gt; 이라는 플러그인 의 &lt;var&gt;value&lt;/var&gt; &lt;var&gt;key&lt;/var&gt; 라는 인수를 정의하십시오 .</target>
        </trans-unit>
        <trans-unit id="3b065b864c454ddad2ef2e2ee36967d76b136921" translate="yes" xml:space="preserve">
          <source>Define how many insn groups (cycles) are examined for a dependency on a stalled insn that is a candidate for premature removal from the queue of stalled insns. This has an effect only during the second scheduling pass, and only if</source>
          <target state="translated">지연된 insns의 대기열에서 조기에 제거 할 수있는 지연된 insn에 대한 종속성에 대해 검사되는 insn 그룹 (사이클) 수를 정의하십시오. 이는 두 번째 예약 단계 중에 만 적용되며</target>
        </trans-unit>
        <trans-unit id="d9b9a323e114f08ae98c07403af86c1b8b068b0b" translate="yes" xml:space="preserve">
          <source>Define how many insns (if any) can be moved prematurely from the queue of stalled insns into the ready list during the second scheduling pass.</source>
          <target state="translated">두 번째 예약 단계에서 지연된 insns 대기열에서 준비 목록으로 얼마나 많은 insns (있는 경우)를 조기에 이동할 수 있는지 정의합니다.</target>
        </trans-unit>
        <trans-unit id="c71f73e3c6f3ec478d5a3cb4a896c06575c34175" translate="yes" xml:space="preserve">
          <source>Define the value of the global environment variable &amp;lsquo;</source>
          <target state="translated">전역 환경 변수 '의 값을 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="007a5a1c8e0d06fa894878b70ba1b2c632ffae5b" translate="yes" xml:space="preserve">
          <source>Defined if</source>
          <target state="translated">정의 된 경우</target>
        </trans-unit>
        <trans-unit id="461eb2c6003ae0aaa3a339d944fe5cf6fb4d9e9b" translate="yes" xml:space="preserve">
          <source>Defined if the compiler supports 32-bit double resp. 64-bit double. The actual layout is specified by option</source>
          <target state="translated">컴파일러가 32 비트 double resp를 지원하는 경우 정의됩니다. 64 비트 double. 실제 레이아웃은 옵션으로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="b02590046df70d51175d1e6e43007843fa86e90a" translate="yes" xml:space="preserve">
          <source>Defining a register variable does not reserve the register. Other than when invoking the Extended &lt;code&gt;asm&lt;/code&gt;, the contents of the specified register are not guaranteed. For this reason, the following uses are explicitly &lt;em&gt;not&lt;/em&gt; supported. If they appear to work, it is only happenstance, and may stop working as intended due to (seemingly) unrelated changes in surrounding code, or even minor changes in the optimization of a future version of gcc:</source>
          <target state="translated">레지스터 변수를 정의해도 레지스터가 예약되지 않습니다. Extended &lt;code&gt;asm&lt;/code&gt; 을 호출 할 때 외에는 지정된 레지스터의 내용이 보장되지 않습니다. 이러한 이유로 다음 용도는 명시 적으로 지원 &lt;em&gt;되지 않습니다&lt;/em&gt; . 그것들이 작동하는 것처럼 보이는 경우에만 발생하며 주변 코드의 관련없는 변경으로 인해 또는 의도적으로 gcc의 향후 버전 최적화에 대한 약간의 변경으로 인해 의도 한대로 작동하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="827f9d9fc11f005c60202a566cf0397ae86dd11d" translate="yes" xml:space="preserve">
          <source>Defining inline functions (as fast as macros).</source>
          <target state="translated">인라인 함수 정의 (매크로만큼 빠름).</target>
        </trans-unit>
        <trans-unit id="85adcd212de2e338813907851ee4a5662c5f1efc" translate="yes" xml:space="preserve">
          <source>Defining variables residing in specified registers.</source>
          <target state="translated">지정된 레지스터에 상주하는 변수 정의</target>
        </trans-unit>
        <trans-unit id="83ee69015768e1155b22074ebd3a36cc37e95cce" translate="yes" xml:space="preserve">
          <source>Delay execution for &lt;var&gt;ticks&lt;/var&gt; cycles. Note that this built-in does not take into account the effect of interrupts that might increase delay time. &lt;var&gt;ticks&lt;/var&gt; must be a compile-time integer constant; delays with a variable number of cycles are not supported.</source>
          <target state="translated">&lt;var&gt;ticks&lt;/var&gt; 주기 실행 지연 이 내장 기능은 지연 시간을 증가시킬 수있는 인터럽트의 영향을 고려하지 않습니다. &lt;var&gt;ticks&lt;/var&gt; 은 컴파일 타임 정수 상수 여야합니다. 가변주기 수의 지연은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1610d19a0a48226750b3049b914e4786781d22cd" translate="yes" xml:space="preserve">
          <source>Deleting &amp;ldquo;empty&amp;rdquo; loops.</source>
          <target state="translated">&quot;빈&quot;루프를 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="36a3093d26bbd3d1360751144e1efe12aeac3836" translate="yes" xml:space="preserve">
          <source>Depending on the target and how GCC was configured, a slightly different set of optimizations may be enabled at each</source>
          <target state="translated">대상 및 GCC 구성 방법에 따라 각각 약간 씩 다른 최적화 세트를 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="c9892e7a514c42b2b22214f98f72a5abf448bce9" translate="yes" xml:space="preserve">
          <source>Describes the type of hardware multiply supported by the target. Accepted values are &amp;lsquo;</source>
          <target state="translated">대상이 지원하는 하드웨어 유형을 설명합니다. 허용되는 값은 '</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="230a2f1369c19e9bed8580ef0c388abed833d36f" translate="yes" xml:space="preserve">
          <source>Despite the nomenclature, &amp;lsquo;</source>
          <target state="translated">명명법에도 불구하고 '</target>
        </trans-unit>
        <trans-unit id="bd519eb03ed0c213fdab64aa985771c57b8bf1cd" translate="yes" xml:space="preserve">
          <source>Detect floating-point division by zero. Unlike other similar options,</source>
          <target state="translated">부동 소수점 나누기를 0으로 감지합니다. 다른 유사한 옵션과 달리</target>
        </trans-unit>
        <trans-unit id="f275b676db5ca45003e8d7fdde53e395b48ae26a" translate="yes" xml:space="preserve">
          <source>Detect integer division by zero as well as &lt;code&gt;INT_MIN / -1&lt;/code&gt; division.</source>
          <target state="translated">&lt;code&gt;INT_MIN / -1&lt;/code&gt; 나누기 뿐만 아니라 0으로 정수 나누기를 감지하십시오 .</target>
        </trans-unit>
        <trans-unit id="1f073b8e3005614eac7c90dae6865076fed02ebe" translate="yes" xml:space="preserve">
          <source>Detect paths that trigger erroneous or undefined behavior due to a null value being used in a way forbidden by a &lt;code&gt;returns_nonnull&lt;/code&gt; or &lt;code&gt;nonnull&lt;/code&gt; attribute. Isolate those paths from the main control flow and turn the statement with erroneous or undefined behavior into a trap. This is not currently enabled, but may be enabled by</source>
          <target state="translated">&lt;code&gt;returns_nonnull&lt;/code&gt; 또는 &lt;code&gt;nonnull&lt;/code&gt; 특성에 의해 금지 된 방식으로 사용되는 null 값으로 인해 잘못되었거나 정의되지 않은 동작을 트리거하는 경로를 감지 합니다. 이러한 경로를 기본 제어 플로우에서 분리하고 잘못되었거나 정의되지 않은 동작이있는 명령문을 트랩으로 바꾸십시오. 현재 사용하도록 설정되어 있지 않지만</target>
        </trans-unit>
        <trans-unit id="6fd69cb31930da8cd040a4ffab1183319f8c09e1" translate="yes" xml:space="preserve">
          <source>Detect paths that trigger erroneous or undefined behavior due to dereferencing a null pointer. Isolate those paths from the main control flow and turn the statement with erroneous or undefined behavior into a trap. This flag is enabled by default at</source>
          <target state="translated">널 포인터 역 참조로 인해 잘못되었거나 정의되지 않은 동작을 트리거하는 경로를 감지하십시오. 이러한 경로를 기본 제어 플로우에서 분리하고 잘못되었거나 정의되지 않은 동작이있는 명령문을 트랩으로 바꾸십시오. 이 플래그는 기본적으로</target>
        </trans-unit>
        <trans-unit id="b579efc699383256e0ea46438d32e07c0012bfb5" translate="yes" xml:space="preserve">
          <source>Determine the language standard. See &lt;a href=&quot;standards#Standards&quot;&gt;Language Standards Supported by GCC&lt;/a&gt;, for details of these standard versions. This option is currently only supported when compiling C or C++.</source>
          <target state="translated">언어 표준을 결정하십시오. 이러한 표준 버전에 대한 자세한 내용은 &lt;a href=&quot;standards#Standards&quot;&gt;GCC&lt;/a&gt; 에서 지원하는 언어 표준을 참조하십시오 . 이 옵션은 현재 C 또는 C ++를 컴파일 할 때만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="86070f5116cf4fafa20ed47f8a131328fabf7c26" translate="yes" xml:space="preserve">
          <source>Determined by ABI.</source>
          <target state="translated">ABI에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="3673862083301334f396f6717a9c4dfccba740e6" translate="yes" xml:space="preserve">
          <source>Determined by ABI. The options</source>
          <target state="translated">ABI에 의해 결정됩니다. 옵션</target>
        </trans-unit>
        <trans-unit id="95662524b23c122195f82746bb2090bea580b1d6" translate="yes" xml:space="preserve">
          <source>Determining the alignment of a function, type or variable.</source>
          <target state="translated">함수, 유형 또는 변수의 정렬을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="1e53b5ee672acae1a69a324148d3c1bc9485a2b5" translate="yes" xml:space="preserve">
          <source>Developer Options</source>
          <target state="translated">개발자 옵션</target>
        </trans-unit>
        <trans-unit id="76b02b7503c565a218e0634291f3750002ba2b81" translate="yes" xml:space="preserve">
          <source>Devices belonging to &lt;code&gt;avrtiny&lt;/code&gt; and &lt;code&gt;avrxmega3&lt;/code&gt; can access flash memory by means of &lt;code&gt;LD*&lt;/code&gt; instructions because the flash memory is mapped into the RAM address space. There is &lt;em&gt;no need&lt;/em&gt; for language extensions like &lt;code&gt;__flash&lt;/code&gt; or attribute &lt;a href=&quot;variable-attributes#AVR-Variable-Attributes&quot;&gt;&lt;code&gt;progmem&lt;/code&gt;&lt;/a&gt;. The default linker description files for these devices cater for that feature and &lt;code&gt;.rodata&lt;/code&gt; stays in flash: The compiler just generates &lt;code&gt;LD*&lt;/code&gt; instructions, and the linker script adds core specific offsets to all &lt;code&gt;.rodata&lt;/code&gt; symbols: &lt;code&gt;0x4000&lt;/code&gt; in the case of &lt;code&gt;avrtiny&lt;/code&gt; and &lt;code&gt;0x8000&lt;/code&gt; in the case of &lt;code&gt;avrxmega3&lt;/code&gt;. See &lt;a href=&quot;avr-options#AVR-Options&quot;&gt;AVR Options&lt;/a&gt; for a list of respective devices.</source>
          <target state="translated">플래시 메모리가 RAM 주소 공간에 매핑되므로 &lt;code&gt;avrtiny&lt;/code&gt; 및 &lt;code&gt;avrxmega3&lt;/code&gt; 에 속하는 장치 는 &lt;code&gt;LD*&lt;/code&gt; 명령어 를 통해 플래시 메모리에 액세스 할 수 있습니다 . 없습니다 &lt;em&gt;필요&lt;/em&gt; 같은 언어 확장에 대한 &lt;code&gt;__flash&lt;/code&gt; 또는 속성 &lt;a href=&quot;variable-attributes#AVR-Variable-Attributes&quot;&gt; &lt;code&gt;progmem&lt;/code&gt; 은&lt;/a&gt; . 이러한 장치의 기본 링커 설명 파일이 그 기능과 맞추 &lt;code&gt;.rodata&lt;/code&gt; 플래시에서 숙박 : 컴파일러는 생성 &lt;code&gt;LD*&lt;/code&gt; 지시하고, 링커 스크립트는 모든 핵심 특정 오프셋을 추가 &lt;code&gt;.rodata&lt;/code&gt; 심볼 : &lt;code&gt;0x4000&lt;/code&gt; 으로을 의 경우 &lt;code&gt;avrtiny&lt;/code&gt; 및 &lt;code&gt;0x8000&lt;/code&gt; 이 에 ~의 경우에 &lt;code&gt;avrxmega3&lt;/code&gt; . 각 장치 목록은 &lt;a href=&quot;avr-options#AVR-Options&quot;&gt;AVR 옵션&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ce3941724906083a5cbd3b764ac34bb494078fce" translate="yes" xml:space="preserve">
          <source>Diagnostic Message Formatting Options</source>
          <target state="translated">진단 메시지 형식 옵션</target>
        </trans-unit>
        <trans-unit id="24dd6971b6b8e1e14c204ff9047942c4efd19644" translate="yes" xml:space="preserve">
          <source>Diagnostic messages can optionally have an associated &lt;a href=&quot;https://cwe.mitre.org/index.html&quot;&gt;CWE&lt;/a&gt; identifier. GCC itself only provides such metadata for some of the</source>
          <target state="translated">진단 메시지는 선택적으로 연관된 &lt;a href=&quot;https://cwe.mitre.org/index.html&quot;&gt;CWE&lt;/a&gt; 식별자를 가질 수 있습니다 . GCC 자체는 일부</target>
        </trans-unit>
        <trans-unit id="e6bef0ef417e13647c36cc079b8003855e534522" translate="yes" xml:space="preserve">
          <source>Diagnostic options such as</source>
          <target state="translated">다음과 같은 진단 옵션</target>
        </trans-unit>
        <trans-unit id="3f68058e1e87ea41d8c9d3c7c1f94f8140abe531" translate="yes" xml:space="preserve">
          <source>Diagnostics can have child diagnostics. For example, this error and note:</source>
          <target state="translated">진단에는 어린이 진단이있을 수 있습니다. 예를 들어,이 오류 및 참고 사항 :</target>
        </trans-unit>
        <trans-unit id="f2f5c489e6e2397fb8b9f0a64fb5a021b4c96f8f" translate="yes" xml:space="preserve">
          <source>Diagnostics consist of all the output sent to stderr by GCC.</source>
          <target state="translated">진단은 GCC에 의해 stderr로 전송 된 모든 출력으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="3545c8182bd90d9cc3755c0e6e77d7f64b0e4f2b" translate="yes" xml:space="preserve">
          <source>Different sets of tools are interoperable if they generate files that can be used in the same program. The set of tools includes compilers, assemblers, linkers, libraries, header files, startup files, and debuggers. Binaries produced by different sets of tools are not interoperable unless they implement the same ABI. This applies to different versions of the same tools as well as tools from different vendors.</source>
          <target state="translated">동일한 프로그램에서 사용할 수있는 파일을 생성하는 경우 서로 다른 도구 세트를 상호 운용 할 수 있습니다. 도구 세트에는 컴파일러, 어셈블러, 링커, 라이브러리, 헤더 파일, 시작 파일 및 디버거가 포함됩니다. 서로 다른 도구 세트로 생성 된 바이너리는 동일한 ABI를 구현하지 않으면 상호 운용 할 수 없습니다. 이는 동일한 도구의 다른 버전과 다른 공급 업체의 도구에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="356087678cfa620825af09ad133165c6564b44fe" translate="yes" xml:space="preserve">
          <source>Direct the linker to not merge together strings in the debugging information that are identical in different object files. Merging is not supported by all assemblers or linkers. Merging decreases the size of the debug information in the output file at the cost of increasing link processing time. Merging is enabled by default.</source>
          <target state="translated">링커가 다른 객체 파일에서 동일한 디버깅 정보에서 문자열을 병합하지 않도록 지시합니다. 모든 어셈블러 또는 링커에서 병합을 지원하지는 않습니다. 병합하면 링크 처리 시간이 증가함에 따라 출력 파일의 디버그 정보 크기가 줄어 듭니다. 병합은 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7eb0eda4de9f69bec3e03226fe8296271cfe198f" translate="yes" xml:space="preserve">
          <source>Directories specified with</source>
          <target state="translated">로 지정된 디렉토리</target>
        </trans-unit>
        <trans-unit id="f710acdf8c3a36b577ab367527e400e4e4519a38" translate="yes" xml:space="preserve">
          <source>Directory Options</source>
          <target state="translated">디렉토리 옵션</target>
        </trans-unit>
        <trans-unit id="9a7d4e0687b14e2b7cda406900b802782cd50a62" translate="yes" xml:space="preserve">
          <source>Disable</source>
          <target state="translated">Disable</target>
        </trans-unit>
        <trans-unit id="2d24b1d992d1c4af780c8f9d61b9c942a6314962" translate="yes" xml:space="preserve">
          <source>Disable (do not disable) use of the &lt;code&gt;jal&lt;/code&gt; instruction. Calling functions using &lt;code&gt;jal&lt;/code&gt; is more efficient but requires the caller and callee to be in the same 256 megabyte segment.</source>
          <target state="translated">&lt;code&gt;jal&lt;/code&gt; 명령어 사용을 비활성화 (비활성화하지 않음)합니다 . &lt;code&gt;jal&lt;/code&gt; 을 사용한 호출 기능 은 더 효율적이지만 호출자와 호출 수신자는 동일한 256MB 세그먼트에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="df30c5939a2b24c38598155ef45390b83313cc5d" translate="yes" xml:space="preserve">
          <source>Disable (or enable) optimizations that use the small data section. This may be useful for working around optimizer bugs.</source>
          <target state="translated">작은 데이터 섹션을 사용하는 최적화를 비활성화 (또는 활성화)하십시오. 최적화 프로그램 버그를 해결하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f2ac79b60fc58bb07e366adfa0ca3573c94fc1b" translate="yes" xml:space="preserve">
          <source>Disable (or re-enable) the generation of PC-relative jump instructions.</source>
          <target state="translated">PC 기준 점프 명령 생성을 비활성화 (또는 다시 활성화)하십시오.</target>
        </trans-unit>
        <trans-unit id="e288cae69ca3cd91f647a069f6407394ee8f11c1" translate="yes" xml:space="preserve">
          <source>Disable (or re-enable) the generation of hardware floating point instructions. This option is only significant when the target architecture is &amp;lsquo;</source>
          <target state="translated">하드웨어 부동 소수점 명령어 생성을 비활성화 (또는 다시 활성화)합니다. 이 옵션은 대상 아키텍처가 '</target>
        </trans-unit>
        <trans-unit id="b671582f983bdaa2dca5a8611789524ffa3c4ce1" translate="yes" xml:space="preserve">
          <source>Disable &lt;code&gt;lr&lt;/code&gt; and &lt;code&gt;sr&lt;/code&gt; instructions from using FPX extension aux registers.</source>
          <target state="translated">FPX 확장 보조 레지스터를 사용 하지 않도록 &lt;code&gt;lr&lt;/code&gt; 및 &lt;code&gt;sr&lt;/code&gt; 명령어를 비활성화 합니다 .</target>
        </trans-unit>
        <trans-unit id="c1660e5f22d4c71c2ee4abdaec7f4aef18aa78c9" translate="yes" xml:space="preserve">
          <source>Disable IPA pass &lt;var&gt;pass&lt;/var&gt;. &lt;var&gt;pass&lt;/var&gt; is the pass name. If the same pass is statically invoked in the compiler multiple times, the pass name should be appended with a sequential number starting from 1.</source>
          <target state="translated">IPA 패스 &lt;var&gt;pass&lt;/var&gt; 비활성화합니다 . &lt;var&gt;pass&lt;/var&gt; 는 패스 이름입니다. 동일한 패스가 컴파일러에서 정적으로 여러 번 호출되면 패스 이름에 1부터 시작하는 순차적 번호가 추가되어야합니다.</target>
        </trans-unit>
        <trans-unit id="9d85b585d1d05ada062cacb1bc9babcd262635c5" translate="yes" xml:space="preserve">
          <source>Disable RTL pass &lt;var&gt;pass&lt;/var&gt;. &lt;var&gt;pass&lt;/var&gt; is the pass name. If the same pass is statically invoked in the compiler multiple times, the pass name should be appended with a sequential number starting from 1. &lt;var&gt;range-list&lt;/var&gt; is a comma-separated list of function ranges or assembler names. Each range is a number pair separated by a colon. The range is inclusive in both ends. If the range is trivial, the number pair can be simplified as a single number. If the function&amp;rsquo;s call graph node&amp;rsquo;s &lt;var&gt;uid&lt;/var&gt; falls within one of the specified ranges, the &lt;var&gt;pass&lt;/var&gt; is disabled for that function. The &lt;var&gt;uid&lt;/var&gt; is shown in the function header of a dump file, and the pass names can be dumped by using option</source>
          <target state="translated">RTL 패스 &lt;var&gt;pass&lt;/var&gt; 비활성화합니다 . &lt;var&gt;pass&lt;/var&gt; 는 패스 이름입니다. 동일한 패스가 컴파일러에서 정적으로 여러 번 호출되는 경우 패스 이름에 1부터 시작하는 순차적 번호가 추가되어야합니다. &lt;var&gt;range-list&lt;/var&gt; 는 쉼표로 구분 된 함수 범위 또는 어셈블러 이름 목록입니다. 각 범위는 콜론으로 구분 된 숫자 쌍입니다. 범위는 양쪽 끝을 포함합니다. 범위가 사소한 경우 숫자 쌍을 단일 숫자로 단순화 할 수 있습니다. 함수의 호출 그래프 노드의 &lt;var&gt;uid&lt;/var&gt; 가 지정된 범위 중 하나에 속하면 해당 함수에 대한 &lt;var&gt;pass&lt;/var&gt; 가 비활성화됩니다. &lt;var&gt;uid&lt;/var&gt; 덤프 파일의 함수 헤더에 표시되고, 통과 이름이 옵션을 사용하여 덤프 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="7472182885a7c5023818095d70ccee0a1003a982" translate="yes" xml:space="preserve">
          <source>Disable Wpedantic warnings about constructs used in MFC, such as implicit int and getting a pointer to member function via non-standard syntax.</source>
          <target state="translated">암시 적 int 및 비표준 구문을 통해 멤버 함수에 대한 포인터 가져 오기와 같이 MFC에 사용 된 구문에 대한 Wpedantic 경고를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="d634773489054e3f820c752b2fe8a75da7d7b819" translate="yes" xml:space="preserve">
          <source>Disable all estimate instructions, equivalent to</source>
          <target state="translated">모든 추정 명령을 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="24c834ead83a4d1ebc3aa24aef6d4685246dfacb" translate="yes" xml:space="preserve">
          <source>Disable any machine-specific peephole optimizations. The difference between</source>
          <target state="translated">기계 별 들여다 보는 구멍 최적화를 비활성화하십시오. 차이점</target>
        </trans-unit>
        <trans-unit id="dd10c462b4994eb3982bf5bd6da47ab31464aa34" translate="yes" xml:space="preserve">
          <source>Disable built-in declarations of functions that are not mandated by ANSI/ISO C. These include &lt;code&gt;ffs&lt;/code&gt;, &lt;code&gt;alloca&lt;/code&gt;, &lt;code&gt;_exit&lt;/code&gt;, &lt;code&gt;index&lt;/code&gt;, &lt;code&gt;bzero&lt;/code&gt;, &lt;code&gt;conjf&lt;/code&gt;, and other related functions.</source>
          <target state="translated">ANSI / ISO C에서 요구하지 않는 내장 함수 선언을 비활성화합니다. 여기에는 &lt;code&gt;ffs&lt;/code&gt; , &lt;code&gt;alloca&lt;/code&gt; , &lt;code&gt;_exit&lt;/code&gt; , &lt;code&gt;index&lt;/code&gt; , &lt;code&gt;bzero&lt;/code&gt; , &lt;code&gt;conjf&lt;/code&gt; 및 기타 관련 함수가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="e02b6f324995da402dd843cdd3b4c4bea9e780ea" translate="yes" xml:space="preserve">
          <source>Disable compilation effects of</source>
          <target state="translated">의 컴파일 효과 비활성화</target>
        </trans-unit>
        <trans-unit id="4deddc96335abb292813c9ba7387aa150fa39b18" translate="yes" xml:space="preserve">
          <source>Disable compiler generated atomic sequences and emit library calls for atomic operations. This is the default if the target is not &lt;code&gt;sh*-*-linux*&lt;/code&gt;.</source>
          <target state="translated">컴파일러에서 생성 한 원자 시퀀스를 비활성화하고 원자 연산을위한 라이브러리 호출을 내 보냅니다. 대상이 &lt;code&gt;sh*-*-linux*&lt;/code&gt; 가 아닌 경우 이것이 기본값 입니다.</target>
        </trans-unit>
        <trans-unit id="e03c896d7744b1b31e15f0be1dc55290d5dd4d98" translate="yes" xml:space="preserve">
          <source>Disable diagnostics that the standard says a compiler does not need to issue. Currently, the only such diagnostic issued by G++ is the one for a name having multiple meanings within a class.</source>
          <target state="translated">표준에서 컴파일러가 실행할 필요가 없다고 진단을 비활성화합니다. 현재, G ++에 의해 발행 된 그러한 진단은 클래스 내에서 여러 의미를 갖는 이름에 대한 것입니다.</target>
        </trans-unit>
        <trans-unit id="15a8077f24c55fd5c21ad0119861505db428aa18" translate="yes" xml:space="preserve">
          <source>Disable generation of &lt;code&gt;bcnz&lt;/code&gt; instructions.</source>
          <target state="translated">&lt;code&gt;bcnz&lt;/code&gt; 명령어 생성을 비활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="5286938aafbdfcae094ead274d86fb0eb12ec590" translate="yes" xml:space="preserve">
          <source>Disable generation of information about every class with virtual functions for use by the C++ run-time type identification features (&lt;code&gt;dynamic_cast&lt;/code&gt; and &lt;code&gt;typeid&lt;/code&gt;). If you don&amp;rsquo;t use those parts of the language, you can save some space by using this flag. Note that exception handling uses the same information, but G++ generates it as needed. The &lt;code&gt;dynamic_cast&lt;/code&gt; operator can still be used for casts that do not require run-time type information, i.e. casts to &lt;code&gt;void *&lt;/code&gt; or to unambiguous base classes.</source>
          <target state="translated">C ++ 런타임 유형 식별 기능 ( &lt;code&gt;dynamic_cast&lt;/code&gt; 및 &lt;code&gt;typeid&lt;/code&gt; ) 에서 사용할 가상 함수를 사용하여 모든 클래스에 대한 정보 생성을 사용하지 않도록 설정하십시오 . 해당 언어 부분을 사용하지 않으면이 플래그를 사용하여 공간을 절약 할 수 있습니다. 예외 처리는 동일한 정보를 사용하지만 G ++는 필요에 따라 정보를 생성합니다. &lt;code&gt;dynamic_cast&lt;/code&gt; 는의 연산자는 여전히에, 즉 캐스트 실행시의 형태 정보를 필요로하지 않는 캐스트에 사용할 수 있습니다 &lt;code&gt;void *&lt;/code&gt; 또는 명확한 기본 클래스에.</target>
        </trans-unit>
        <trans-unit id="2c5d893b2d5daa4c819c5a8197085e49914249d8" translate="yes" xml:space="preserve">
          <source>Disable global interrupt.</source>
          <target state="translated">글로벌 인터럽트를 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="5c285b2217d4516708f07171dfd66ed9be6d9834" translate="yes" xml:space="preserve">
          <source>Disable instruction scheduling across basic blocks, which is normally enabled when scheduling before register allocation, i.e. with</source>
          <target state="translated">레지스터 할당 전에 스케줄링 할 때 일반적으로 활성화되는 기본 블록에서 명령어 스케줄링을 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="0e98c6ae6e073a4473bf45d5938dfbe138a13b1c" translate="yes" xml:space="preserve">
          <source>Disable interprocedural optimizations between the function with this attribute and its callers, as if the body of the function is not available when optimizing callers and the callers are unavailable when optimizing the body. This attribute implies &lt;code&gt;noinline&lt;/code&gt;, &lt;code&gt;noclone&lt;/code&gt; and &lt;code&gt;no_icf&lt;/code&gt; attributes. However, this attribute is not equivalent to a combination of other attributes, because its purpose is to suppress existing and future optimizations employing interprocedural analysis, including those that do not have an attribute suitable for disabling them individually. This attribute is supported mainly for the purpose of testing the compiler.</source>
          <target state="translated">호출자를 최적화 할 때 함수 본문을 사용할 수없고 본문을 최적화 할 때 호출자를 사용할 수없는 것처럼이 속성을 가진 함수와 호출자간에 프로 시저 간 최적화를 비활성화하십시오. 이 속성은 &lt;code&gt;noinline&lt;/code&gt; , &lt;code&gt;noclone&lt;/code&gt; 및 &lt;code&gt;no_icf&lt;/code&gt; 속성을 의미 합니다. 그러나이 속성은 다른 속성의 조합과 동일하지 않습니다. 그 목적은 개별적으로 비활성화하기에 적합한 속성이없는 것을 포함하여 절차 간 분석을 사용하는 기존 및 미래의 최적화를 억제하는 것입니다. 이 속성은 주로 컴파일러 테스트를 위해 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="c37151a8e5f5341e877c6066a7b31e954ab243b6" translate="yes" xml:space="preserve">
          <source>Disable lazy binding of function calls. This option is the default and is defined for compatibility with Diab.</source>
          <target state="translated">함수 호출의 지연 바인딩을 비활성화합니다. 이 옵션은 기본값이며 Diab와의 호환성을 위해 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="79f399771b0bd71907b7340d736452ada0291344" translate="yes" xml:space="preserve">
          <source>Disable linking effects of</source>
          <target state="translated">의 연결 효과 비활성화</target>
        </trans-unit>
        <trans-unit id="609817ad0deecdec8c6b793819e36a0c5e4631a2" translate="yes" xml:space="preserve">
          <source>Disable nested conditional execution optimizations.</source>
          <target state="translated">중첩 된 조건부 실행 최적화를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="252fe391b1a4b9d960215788262ee75bfd6c19f6" translate="yes" xml:space="preserve">
          <source>Disable optimization of &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; in conditional execution.</source>
          <target state="translated">&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 및 &lt;code&gt;||&lt;/code&gt; 최적화 비활성화 조건부 실행.</target>
        </trans-unit>
        <trans-unit id="161926f247c9f892e24d049743fa9253ac876603" translate="yes" xml:space="preserve">
          <source>Disable sharing of stack slots allocated for pseudo-registers. Each pseudo-register that does not get a hard register gets a separate stack slot, and as a result function stack frames are larger.</source>
          <target state="translated">의사 레지스터에 할당 된 스택 슬롯 공유를 비활성화합니다. 하드 레지스터를 얻지 못하는 각각의 의사 레지스터는 별도의 스택 슬롯을 얻으므로 결과적으로 스택 프레임이 더 큽니다.</target>
        </trans-unit>
        <trans-unit id="c4a9a68d37ad2c1a1ec5ead44b9d2a2ec4d10976" translate="yes" xml:space="preserve">
          <source>Disable sharing of stack slots used for saving call-used hard registers living through a call. Each hard register gets a separate stack slot, and as a result function stack frames are larger.</source>
          <target state="translated">통화를 통해 존재하는 통화 사용 하드 레지스터를 저장하는 데 사용되는 스택 슬롯 공유를 비활성화합니다. 각 하드 레지스터는 별도의 스택 슬롯을 가지며 결과적으로 스택 프레임이 더 큽니다.</target>
        </trans-unit>
        <trans-unit id="64d3adeb52b81d55606f0c9f79019d7885ab8d8f" translate="yes" xml:space="preserve">
          <source>Disable speculative motion of non-load instructions, which is normally enabled when scheduling before register allocation, i.e. with</source>
          <target state="translated">비로드 명령어의 추론 적 모션을 비활성화합니다. 이는 일반적으로 레지스터 할당 전에 스케줄링 할 때 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="1b9e6a10d7feb88af30d21664dcd930d0d3d0e48" translate="yes" xml:space="preserve">
          <source>Disable the ARCompact-specific pass to generate conditional execution instructions.</source>
          <target state="translated">조건부 실행 명령을 생성하려면 ARCompact 특정 패스를 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="e7b7d0aa54600e475f975b3ad94c992870425a43" translate="yes" xml:space="preserve">
          <source>Disable the ARM-state integer division extension.</source>
          <target state="translated">ARM 상태 정수 나누기 확장을 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="9ae205131ae6c1f0b1ad1d6cdc75d88e53999201" translate="yes" xml:space="preserve">
          <source>Disable the Advanced SIMD instructions (does not disable floating point).</source>
          <target state="translated">고급 SIMD 명령어를 비활성화합니다 (부동 소수점은 비활성화하지 않음).</target>
        </trans-unit>
        <trans-unit id="57b7e24dd0dd62653de9bd626e4944fa6899e1dd" translate="yes" xml:space="preserve">
          <source>Disable the DSP extension.</source>
          <target state="translated">DSP 확장을 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="734f786ab444d8f65fc0c46cdddee12bfda3218d" translate="yes" xml:space="preserve">
          <source>Disable the DSP instructions on &amp;lsquo;</source>
          <target state="translated">'에서 DSP 명령어 비활성화</target>
        </trans-unit>
        <trans-unit id="c7d8376c95023cbfb7c660163253089208b34ece" translate="yes" xml:space="preserve">
          <source>Disable the cryptographic extension.</source>
          <target state="translated">암호화 확장 기능을 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="7f3f13b931ffd3d75ba124cd726692f8712aa12e" translate="yes" xml:space="preserve">
          <source>Disable the cryptographic instructions.</source>
          <target state="translated">암호화 지침을 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="354594897b575026e6476d5a01060d1ccbb17336" translate="yes" xml:space="preserve">
          <source>Disable the diagnostic for converting a bound pointer to member function to a plain pointer.</source>
          <target state="translated">바인딩 된 포인터를 멤버 함수로 변환하여 일반 포인터로 변환하는 진단 기능을 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="c0bf355bf048a8a4bc609b141cbb68d7e3532d66" translate="yes" xml:space="preserve">
          <source>Disable the floating-point and Advanced SIMD instructions.</source>
          <target state="translated">부동 소수점 및 고급 SIMD 명령어를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="f50bf78f4ef90550849e16bf00e7f8fd3e26a980" translate="yes" xml:space="preserve">
          <source>Disable the floating-point extension.</source>
          <target state="translated">부동 소수점 확장을 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="04850fd68730a9ccdd397aa31033dbe8ded5b8ec" translate="yes" xml:space="preserve">
          <source>Disable the floating-point extensions.</source>
          <target state="translated">부동 소수점 확장을 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="c08d0916688b59b4478dd3a8a8d551babc61d679" translate="yes" xml:space="preserve">
          <source>Disable the floating-point instructions.</source>
          <target state="translated">부동 소수점 명령어를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="005c34c6f1c2fb8f1d59d1e3c41e0a0a2122f930" translate="yes" xml:space="preserve">
          <source>Disable the floating-point, Advanced SIMD and cryptographic instructions.</source>
          <target state="translated">부동 소수점, 고급 SIMD 및 암호화 명령어를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="9c28f6f627d67c9bbae1a8f36d817bb71ee86b5b" translate="yes" xml:space="preserve">
          <source>Disable the insertion of cache barriers. This is the default setting.</source>
          <target state="translated">캐시 장벽 삽입을 비활성화합니다. 이것이 기본 설정입니다.</target>
        </trans-unit>
        <trans-unit id="f56b2447b6cc6f830b2511a8763a44abd8412f42" translate="yes" xml:space="preserve">
          <source>Disable the optimization pass that scans for opportunities to use &amp;ldquo;decrement and branch&amp;rdquo; instructions on a count register instead of instruction sequences that decrement a register, compare it against zero, and then branch based upon the result. This option is only meaningful on architectures that support such instructions, which include x86, PowerPC, IA-64 and S/390. Note that the</source>
          <target state="translated">레지스터를 감소시키고 0과 비교 한 다음 결과를 기반으로 분기하는 명령어 시퀀스 대신 카운트 레지스터에서 &quot;감소 및 분기&quot;명령어를 사용할 기회를 스캔하는 최적화 패스를 비활성화합니다. 이 옵션은 x86, PowerPC, IA-64 및 S / 390을 포함하여 이러한 명령어를 지원하는 아키텍처에서만 의미가 있습니다. 참고</target>
        </trans-unit>
        <trans-unit id="c15dc65887ffe75f7696788f129ef9f9ee6c4b19" translate="yes" xml:space="preserve">
          <source>Disable the use of conditional execution.</source>
          <target state="translated">조건부 실행 사용을 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="47a29a4761de80ec38be8a0cf5e531389fb7bc55" translate="yes" xml:space="preserve">
          <source>Disable the use of conditional set instructions.</source>
          <target state="translated">조건부 설정 명령어 사용을 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="5cb2b9c6309800d129c0dac9ca4f0d952c4c16ba" translate="yes" xml:space="preserve">
          <source>Disable the use of conditional-move instructions.</source>
          <target state="translated">조건부 이동 명령어 사용을 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="c4ab5898827402073a5b1c951bd92d3ef7f4f26a" translate="yes" xml:space="preserve">
          <source>Disable the warning about a throw-expression that will immediately result in a call to &lt;code&gt;terminate&lt;/code&gt;.</source>
          <target state="translated">throw-expression에 대한 경고를 비활성화하면 즉시 &lt;code&gt;terminate&lt;/code&gt; 호출이 발생 합니다 .</target>
        </trans-unit>
        <trans-unit id="9e916b556b452967e0dcb5e2d11c70ff45829cad" translate="yes" xml:space="preserve">
          <source>Disable the warning about the case when a conversion function converts an object to the same type, to a base class of that type, or to void; such a conversion function will never be called.</source>
          <target state="translated">변환 함수가 객체를 동일한 유형, 해당 유형의 기본 클래스 또는 void로 변환하는 경우에 대한 경고를 비활성화합니다. 이러한 변환 함수는 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="97813576f6a1f168ea49d44405f937b0428780d3" translate="yes" xml:space="preserve">
          <source>Disable transformations and optimizations that assume default floating-point rounding behavior. This is round-to-zero for all floating point to integer conversions, and round-to-nearest for all other arithmetic truncations. This option should be specified for programs that change the FP rounding mode dynamically, or that may be executed with a non-default rounding mode. This option disables constant folding of floating-point expressions at compile time (which may be affected by rounding mode) and arithmetic transformations that are unsafe in the presence of sign-dependent rounding modes.</source>
          <target state="translated">기본 부동 소수점 반올림 동작을 가정하는 변환 및 최적화를 비활성화합니다. 이것은 모든 부동 소수점 대 정수 변환의 경우 0으로 반올림되고 다른 모든 산술 잘림의 경우 가장 가까운 반올림입니다. 이 옵션은 FP 반올림 모드를 동적으로 변경하거나 기본이 아닌 반올림 모드로 실행될 수있는 프로그램에 지정해야합니다. 이 옵션을 사용하면 컴파일시 부동 소수점 식을 계속 접을 수 없으며 (반올림 모드의 영향을받을 수 있음) 부호 종속적 반올림 모드가있을 때 안전하지 않은 산술 변환이 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="fa652af71b1d233eeae7ac973249eb12d16d530a" translate="yes" xml:space="preserve">
          <source>Disable tree pass &lt;var&gt;pass&lt;/var&gt;. See</source>
          <target state="translated">트리 패스 &lt;var&gt;pass&lt;/var&gt; 비활성화합니다 . 보다</target>
        </trans-unit>
        <trans-unit id="c43ef83976903738f93a9dacec55c01d9094fe2c" translate="yes" xml:space="preserve">
          <source>Disable use of the small data area. Variables are put into one of &lt;code&gt;.data&lt;/code&gt;, &lt;code&gt;.bss&lt;/code&gt;, or &lt;code&gt;.rodata&lt;/code&gt; (unless the &lt;code&gt;section&lt;/code&gt; attribute has been specified). This is the default.</source>
          <target state="translated">작은 데이터 영역 사용을 비활성화하십시오. 변수는 &lt;code&gt;.data&lt;/code&gt; , &lt;code&gt;.bss&lt;/code&gt; 또는 &lt;code&gt;.rodata&lt;/code&gt; 중 하나에 저장됩니다 ( &lt;code&gt;section&lt;/code&gt; 속성이 지정 되지 않은 경우). 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="dd6879ec12c29349f77ab51cc9ef664f2b926a46" translate="yes" xml:space="preserve">
          <source>Disable warnings when non-template friend functions are declared within a template. In very old versions of GCC that predate implementation of the ISO standard, declarations such as &amp;lsquo;</source>
          <target state="translated">템플릿이 아닌 친구 기능이 템플릿 내에 선언되면 경고를 비활성화합니다. ISO 표준을 구현하기 이전의 매우 오래된 GCC 버전에서 '</target>
        </trans-unit>
        <trans-unit id="75de5d4a7b64d839362aa8d626128e23f7764239" translate="yes" xml:space="preserve">
          <source>Disabled at level</source>
          <target state="translated">수준에서 비활성화</target>
        </trans-unit>
        <trans-unit id="bf492e44698b816bac566d70d52b5954c19119dd" translate="yes" xml:space="preserve">
          <source>Disabled by default.</source>
          <target state="translated">기본적으로 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="aac880794e7e82b2a88791e338313ba16ba15074" translate="yes" xml:space="preserve">
          <source>Disables all the optional instructions enabled by</source>
          <target state="translated">에 의해 활성화 된 모든 옵션 명령을 비활성화합니다</target>
        </trans-unit>
        <trans-unit id="870d995d131280874dc4cc508b91ef24ce1bb25e" translate="yes" xml:space="preserve">
          <source>Disables the SIMD (but not floating-point) instructions on &amp;lsquo;</source>
          <target state="translated">'에서 SIMD (부동 소수점 제외) 명령어 사용 안함</target>
        </trans-unit>
        <trans-unit id="a27996206286cd961e06403639946454e47385b1" translate="yes" xml:space="preserve">
          <source>Disables the double-precision component of the floating-point instructions on &amp;lsquo;</source>
          <target state="translated">'에서 부동 소수점 명령어의 배정 밀도 구성 요소를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="f08047d7bdf26e21f60892f7f2f9f2faee1af25c" translate="yes" xml:space="preserve">
          <source>Disables the floating-point instructions on &amp;lsquo;</source>
          <target state="translated">'에서 부동 소수점 명령어를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="df9e25965e3555d25ff57722cb18d00af55afb9e" translate="yes" xml:space="preserve">
          <source>Disables warnings about the generation of inefficient code. These warnings can be generated, for example, when compiling code that performs byte-level memory operations on the MAC AE type. The MAC AE has no hardware support for byte-level memory operations, so all byte load/stores must be synthesized from word load/store operations. This is inefficient and a warning is generated to indicate that you should rewrite the code to avoid byte operations, or to target an AE type that has the necessary hardware support. This option disables these warnings.</source>
          <target state="translated">비효율적 인 코드 생성에 대한 경고를 비활성화합니다. 이러한 경고는 예를 들어 MAC AE 유형에서 바이트 수준 메모리 작업을 수행하는 코드를 컴파일 할 때 생성 될 수 있습니다. MAC AE는 바이트 수준 메모리 작업을 하드웨어 적으로 지원하지 않으므로 모든 바이트로드 / 저장은 워드로드 / 저장 작업에서 합성해야합니다. 이는 비효율적이며 바이트 작업을 피하거나 필요한 하드웨어 지원이있는 AE 유형을 대상으로 코드를 다시 작성해야한다는 경고가 생성됩니다. 이 옵션은 이러한 경고를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="8c83476e13772d4a0c7d47269ca8280ee489e48a" translate="yes" xml:space="preserve">
          <source>Disallow using extensions of later DWARF standard version than selected with</source>
          <target state="translated">로 선택된 DWARF 표준 버전의 확장자를 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="48fef3c4f4f198a3fc747aaf4241ba4c8fd572a6" translate="yes" xml:space="preserve">
          <source>Discover read-only, write-only and non-addressable static variables. Enabled by default at</source>
          <target state="translated">읽기 전용, 쓰기 전용 및 주소 지정이 불가능한 정적 변수를 발견하십시오. 에서 기본적으로 활성화</target>
        </trans-unit>
        <trans-unit id="fcb652ea128e958ac5cce84cb6ef8250a1be8fe4" translate="yes" xml:space="preserve">
          <source>Discover which functions are pure or constant. Enabled by default at</source>
          <target state="translated">어떤 함수가 순수하거나 상수인지 확인하십시오. 에서 기본적으로 활성화</target>
        </trans-unit>
        <trans-unit id="a208f773f4cc31e2ce047d428bfcf70af185cc47" translate="yes" xml:space="preserve">
          <source>Discover which static variables do not escape the compilation unit. Enabled by default at</source>
          <target state="translated">컴파일 단위를 벗어나지 않는 정적 변수를 찾으십시오. 에서 기본적으로 활성화</target>
        </trans-unit>
        <trans-unit id="651cd5d45dfead116269d73c1f57b41b4dbd0dc9" translate="yes" xml:space="preserve">
          <source>Dispatching a call to another function.</source>
          <target state="translated">다른 함수에 대한 호출을 전달합니다.</target>
        </trans-unit>
        <trans-unit id="81b470ecff5209cbe640ee9ba4362aba6ca2d2e9" translate="yes" xml:space="preserve">
          <source>Display all of the optimization options supported by the compiler.</source>
          <target state="translated">컴파일러가 지원하는 모든 최적화 옵션을 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="72c8c0bfdf122469f724652953f16cbdb6f10057" translate="yes" xml:space="preserve">
          <source>Display all of the options controlling warning messages produced by the compiler.</source>
          <target state="translated">컴파일러가 생성 한 경고 메시지를 제어하는 ​​모든 옵션을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="aed462cd18dddfb7255b08046613981f43dcc83d" translate="yes" xml:space="preserve">
          <source>Display demangled function names in output. The default is to show mangled function names.</source>
          <target state="translated">출력에 얽힌 함수 이름을 표시합니다. 디폴트는 맹 글링 된 함수 이름을 표시하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="265008e8627ab28c29c4c783e5dfd9614fe2af35" translate="yes" xml:space="preserve">
          <source>Display help about using &lt;code&gt;gcov-dump&lt;/code&gt; (on the standard output), and exit without doing any further processing.</source>
          <target state="translated">표준 출력에서 &lt;code&gt;gcov-dump&lt;/code&gt; 사용에 대한 도움말을 표시 하고 추가 처리없이 종료합니다.</target>
        </trans-unit>
        <trans-unit id="e12fbb96aff9cead22e458e9ec3c8f5e63fa5684" translate="yes" xml:space="preserve">
          <source>Display help about using &lt;code&gt;gcov-tool&lt;/code&gt; (on the standard output), and exit without doing any further processing.</source>
          <target state="translated">&lt;code&gt;gcov-tool&lt;/code&gt; (표준 출력) 사용에 대한 도움말을 표시 하고 추가 처리없이 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="c2a32dd6399128ea64f2e8805722cf5f0f40906c" translate="yes" xml:space="preserve">
          <source>Display help about using &lt;code&gt;gcov&lt;/code&gt; (on the standard output), and exit without doing any further processing.</source>
          <target state="translated">표준 출력에서 &lt;code&gt;gcov&lt;/code&gt; 사용에 대한 도움말을 표시 하고 추가 처리없이 종료합니다.</target>
        </trans-unit>
        <trans-unit id="05abc5bf9b915eda30e5f0fa5412f4d00c71675a" translate="yes" xml:space="preserve">
          <source>Display only those options that are undocumented.</source>
          <target state="translated">문서화되지 않은 옵션 만 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="f03b0f7a546ee49a503453f7975e25ffe065c35f" translate="yes" xml:space="preserve">
          <source>Display options taking an argument that appears after an equal sign in the same continuous piece of text, such as: &amp;lsquo;</source>
          <target state="translated">동일한 연속 텍스트에서 등호 뒤에 나오는 인수를 취하는 표시 옵션 (예 : '</target>
        </trans-unit>
        <trans-unit id="78dd198d091922fefb8d713c3d97e47984a683e2" translate="yes" xml:space="preserve">
          <source>Display options taking an argument that appears as a separate word following the original option, such as: &amp;lsquo;</source>
          <target state="translated">원래 옵션 다음에 별도의 단어로 나타나는 인수를 취하는 표시 옵션 (예 : '</target>
        </trans-unit>
        <trans-unit id="3034576017d5b01854a8c0bd7d19d6bd34b0118e" translate="yes" xml:space="preserve">
          <source>Display target-specific options. Unlike the</source>
          <target state="translated">대상별 옵션을 표시합니다. 달리</target>
        </trans-unit>
        <trans-unit id="344037446b18226df15907aaf4b6b36a2c93c89d" translate="yes" xml:space="preserve">
          <source>Display the &lt;code&gt;gcov-dump&lt;/code&gt; version number (on the standard output), and exit without doing any further processing.</source>
          <target state="translated">디스플레이 &lt;code&gt;gcov-dump&lt;/code&gt; 더 이상의 처리를하지 않고 버전 (표준 출력에) 번호 및 종료.</target>
        </trans-unit>
        <trans-unit id="35cc61bd60aed0586a7ab81a239eee8b50af7443" translate="yes" xml:space="preserve">
          <source>Display the &lt;code&gt;gcov-tool&lt;/code&gt; version number (on the standard output), and exit without doing any further processing.</source>
          <target state="translated">디스플레이 &lt;code&gt;gcov-tool&lt;/code&gt; 더 이상의 처리를하지 않고 버전 (표준 출력에) 번호 및 종료.</target>
        </trans-unit>
        <trans-unit id="b6e074d4004bd50fbdfdcf5bba3331e5f56c291a" translate="yes" xml:space="preserve">
          <source>Display the &lt;code&gt;gcov&lt;/code&gt; version number (on the standard output), and exit without doing any further processing.</source>
          <target state="translated">표준 출력 에서 &lt;code&gt;gcov&lt;/code&gt; 버전 번호를 표시하고 추가 처리없이 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="e1dab73554637fba73ebd51cac08053a6ac2d5d1" translate="yes" xml:space="preserve">
          <source>Display the dump tool help.</source>
          <target state="translated">덤프 도구 도움말을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="cef9fe7c4ae3fd66d0616ac76fb1a92ba4cf451e" translate="yes" xml:space="preserve">
          <source>Display the options supported for &lt;var&gt;language&lt;/var&gt;, where &lt;var&gt;language&lt;/var&gt; is the name of one of the languages supported in this version of GCC.</source>
          <target state="translated">&lt;var&gt;language&lt;/var&gt; 에 지원되는 옵션을 표시합니다 . 여기서 &lt;var&gt;language&lt;/var&gt; 는이 GCC 버전에서 지원되는 언어 중 하나의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="ecaf3dad0e5ad7c6fd0a0b9f49a9e6fe224ab8c8" translate="yes" xml:space="preserve">
          <source>Display the options supported for &lt;var&gt;language&lt;/var&gt;, where &lt;var&gt;language&lt;/var&gt; is the name of one of the languages supported in this version of GCC. If an option is supported by all languages, one needs to select &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;language&lt;/var&gt; 에 대해 지원되는 옵션을 표시합니다 . 여기서 &lt;var&gt;language&lt;/var&gt; 는이 버전의 GCC에서 지원되는 언어 중 하나의 이름입니다. 옵션이 모든 언어에서 지원되는 경우 '</target>
        </trans-unit>
        <trans-unit id="9ab2c82abfc8159be6e9fa8d50b69489311c099e" translate="yes" xml:space="preserve">
          <source>Display the options that are common to all languages.</source>
          <target state="translated">모든 언어에 공통적 인 옵션을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="0ec31abb5e51897ba8130f63f01229988bd5728b" translate="yes" xml:space="preserve">
          <source>Display the progress on the standard output.</source>
          <target state="translated">표준 출력에 진행 상황을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="6dbb61eb69b04350133e621d0c73b06d5ccc9c5b" translate="yes" xml:space="preserve">
          <source>Display the values recognized by the</source>
          <target state="translated">에 의해 인식되는 값을 표시</target>
        </trans-unit>
        <trans-unit id="34d093aadfdac161b403733078a63e69c40898c6" translate="yes" xml:space="preserve">
          <source>Display the version number and copyrights of the invoked GCC.</source>
          <target state="translated">호출 된 GCC의 버전 번호와 저작권을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="26dfbbd6de78ea5ea887b6576aa7df3d1cced839" translate="yes" xml:space="preserve">
          <source>Disregard strict standards compliance.</source>
          <target state="translated">엄격한 표준 준수를 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="810ca5fb4bf9b88327a090dfa7228390b8a8933b" translate="yes" xml:space="preserve">
          <source>Distances are measured from the beginning of functions when using the</source>
          <target state="translated">거리는 사용시 기능의 시작부터 측정됩니다</target>
        </trans-unit>
        <trans-unit id="700c5d1f81b1eabfd1898baf4899894e603c6ec2" translate="yes" xml:space="preserve">
          <source>Distinguish between prefix and postfix forms of increment and decrement operators.</source>
          <target state="translated">접두사와 접미사 형식의 증분 및 감소 연산자를 구별합니다.</target>
        </trans-unit>
        <trans-unit id="15d45d388da758d77a316f2815f529d6f4aa8a47" translate="yes" xml:space="preserve">
          <source>Do (don&amp;rsquo;t) generate code that uses the fused multiply/add or multiply/subtract instructions. The default is to use these instructions.</source>
          <target state="translated">융합 곱셈 / 더하기 또는 곱하기 / 빼기 명령어를 사용하는 코드를 생성하지 마십시오. 기본값은이 지침을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="fa3eae74d7b2c9843e7a1a146ef2fdd2dc03d4df" translate="yes" xml:space="preserve">
          <source>Do alignment optimizations for call instructions.</source>
          <target state="translated">통화 지침에 대한 정렬 최적화를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="66402eadff3f8314991b18d5e3fc15f2b633b72a" translate="yes" xml:space="preserve">
          <source>Do not (do) assume that unaligned memory references are handled by the system.</source>
          <target state="translated">정렬되지 않은 메모리 참조가 시스템에 의해 처리된다고 가정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="54f30aa11a7322472ca655cc5794b473a6db2cb4" translate="yes" xml:space="preserve">
          <source>Do not affect the &lt;code&gt;long_call&lt;/code&gt; or &lt;code&gt;short_call&lt;/code&gt; attributes of subsequent functions.</source>
          <target state="translated">후속 함수 의 &lt;code&gt;long_call&lt;/code&gt; 또는 &lt;code&gt;short_call&lt;/code&gt; 속성 에는 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="1d4def84337c056fee739188d13fda579c041fe7" translate="yes" xml:space="preserve">
          <source>Do not align the destination of inlined string operations. This switch reduces code size and improves performance in case the destination is already aligned, but GCC doesn&amp;rsquo;t know about it.</source>
          <target state="translated">인라인 문자열 조작의 대상을 정렬하지 마십시오. 이 스위치는 대상이 이미 정렬되어 있지만 GCC가이를 알지 못하는 경우 코드 크기를 줄이고 성능을 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="0de4bbafb6a75d9a2bf9d1dffc4ce55c0685a9e6" translate="yes" xml:space="preserve">
          <source>Do not allow constant data to be placed in code sections. Additionally, when compiling for ELF object format give all text sections the ELF processor-specific section attribute &lt;code&gt;SHF_ARM_PURECODE&lt;/code&gt;. This option is only available when generating non-pic code for M-profile targets with the MOVT instruction.</source>
          <target state="translated">상수 데이터를 코드 섹션에 배치하지 마십시오. 또한 ELF 객체 형식을 컴파일 할 때 모든 텍스트 섹션에 ELF 프로세서 관련 섹션 속성 &lt;code&gt;SHF_ARM_PURECODE&lt;/code&gt; 를 제공하십시오 . 이 옵션은 MOVT 명령어를 사용하여 M 프로파일 대상에 대해 비 피크 코드를 생성 할 때만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78254c6c406c6c1d161d9cea04f2b296c2dea358" translate="yes" xml:space="preserve">
          <source>Do not allow constant data to be placed in code sections. Additionally, when compiling for ELF object format give all text sections the ELF processor-specific section attribute &lt;code&gt;SHF_ARM_PURECODE&lt;/code&gt;. This option is only available when generating non-pic code for M-profile targets.</source>
          <target state="translated">상수 데이터가 코드 섹션에 배치되는 것을 허용하지 마십시오. 또한 ELF 객체 형식을 위해 컴파일 할 때 모든 텍스트 섹션에 ELF 프로세서 별 섹션 속성 &lt;code&gt;SHF_ARM_PURECODE&lt;/code&gt; 를 제공 합니다. 이 옵션은 M- 프로필 대상에 대해 픽이 아닌 코드를 생성 할 때만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d843db312bcca2cdf09a7f1fe7ee427392d62fac" translate="yes" xml:space="preserve">
          <source>Do not allow the built-in functions &lt;code&gt;ceil&lt;/code&gt;, &lt;code&gt;floor&lt;/code&gt;, &lt;code&gt;round&lt;/code&gt; and &lt;code&gt;trunc&lt;/code&gt;, and their &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;long
double&lt;/code&gt; variants, to generate code that raises the &amp;ldquo;inexact&amp;rdquo; floating-point exception for noninteger arguments. ISO C99 and C11 allow these functions to raise the &amp;ldquo;inexact&amp;rdquo; exception, but ISO/IEC TS 18661-1:2014, the C bindings to IEEE 754-2008, as integrated into ISO C2X, does not allow these functions to do so.</source>
          <target state="translated">내장 함수 &lt;code&gt;ceil&lt;/code&gt; , &lt;code&gt;floor&lt;/code&gt; , &lt;code&gt;round&lt;/code&gt; 및 &lt;code&gt;trunc&lt;/code&gt; , &lt;code&gt;float&lt;/code&gt; 및 &lt;code&gt;long double&lt;/code&gt; 변형이 정수가 아닌 인수에 대해 &quot;inexact&quot;부동 소수점 예외를 발생시키는 코드를 생성 하도록 허용하지 마십시오 . ISO C99 및 C11에서는 이러한 함수가 &quot;inexact&quot;예외를 발생시킬 수 있지만 ISO C2X에 통합 된 IEEE 754-2008에 대한 C 바인딩 인 ISO / IEC TS 18661-1 : 2014는 이러한 기능을 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="03d8305d540b6aba4d4042404329e432ca465541" translate="yes" xml:space="preserve">
          <source>Do not allow the built-in functions &lt;code&gt;ceil&lt;/code&gt;, &lt;code&gt;floor&lt;/code&gt;, &lt;code&gt;round&lt;/code&gt; and &lt;code&gt;trunc&lt;/code&gt;, and their &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;long
double&lt;/code&gt; variants, to generate code that raises the &amp;ldquo;inexact&amp;rdquo; floating-point exception for noninteger arguments. ISO C99 and C11 allow these functions to raise the &amp;ldquo;inexact&amp;rdquo; exception, but ISO/IEC TS 18661-1:2014, the C bindings to IEEE 754-2008, does not allow these functions to do so.</source>
          <target state="translated">내장 함수 &lt;code&gt;ceil&lt;/code&gt; , &lt;code&gt;floor&lt;/code&gt; , &lt;code&gt;round&lt;/code&gt; 및 &lt;code&gt;trunc&lt;/code&gt; , &lt;code&gt;float&lt;/code&gt; 및 &lt;code&gt;long double&lt;/code&gt; 변형을 허용하여 정수가 아닌 인수에 대해 &quot;inexact&quot;부동 소수점 예외를 발생시키는 코드를 생성 하지 마십시오 . ISO C99 및 C11에서는 이러한 함수가 &quot;inexact&quot;예외를 발생시킬 수 있지만 IEEE 754-2008에 대한 C 바인딩 인 ISO / IEC TS 18661-1 : 2014에서는 이러한 함수를 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f3ff2c5279a75029bc339b07e7530899c9302db8" translate="yes" xml:space="preserve">
          <source>Do not allow the compiler to generate &lt;em&gt;Long Instruction Word&lt;/em&gt; instructions. This option defines the preprocessor macro &lt;code&gt;__NO_LIW__&lt;/code&gt;.</source>
          <target state="translated">컴파일러가 &lt;em&gt;Long Instruction Word&lt;/em&gt; 명령어 를 생성하도록 허용하지 마십시오 . 이 옵션은 전 처리기 매크로 &lt;code&gt;__NO_LIW__&lt;/code&gt; 를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="308fe4eb96a98c640686f8d44a99dca853e4e2bc" translate="yes" xml:space="preserve">
          <source>Do not allow the compiler to generate &lt;em&gt;SETLB&lt;/em&gt; or &lt;em&gt;Lcc&lt;/em&gt; instructions. This option defines the preprocessor macro &lt;code&gt;__NO_SETLB__&lt;/code&gt;.</source>
          <target state="translated">컴파일러가 &lt;em&gt;SETLB&lt;/em&gt; 또는 &lt;em&gt;Lcc&lt;/em&gt; 명령어 를 생성하도록 허용하지 마십시오 . 이 옵션은 전 처리기 매크로 &lt;code&gt;__NO_SETLB__&lt;/code&gt; 를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="c30c06515f3c7a9db38f03e0071054e61d0d6bea" translate="yes" xml:space="preserve">
          <source>Do not apply the &lt;code&gt;longcall&lt;/code&gt; attribute to subsequent function declarations.</source>
          <target state="translated">&lt;code&gt;longcall&lt;/code&gt; 속성을 후속 함수 선언에 적용하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="6c726465b100e603972419cccdc343f480a4a19b" translate="yes" xml:space="preserve">
          <source>Do not assume a large TLS segment when generating thread-local code.</source>
          <target state="translated">스레드 로컬 코드를 생성 할 때 큰 TLS 세그먼트를 가정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="728fc451cc179eebcc18f5c6344c5c0c36dd581d" translate="yes" xml:space="preserve">
          <source>Do not assume that registers saved by the calling function are restored before calling the &lt;code&gt;noreturn&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;noreturn&lt;/code&gt; 기능을 호출하기 전에 호출 기능으로 저장된 레지스터가 복원된다고 가정하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="e33e43a1033f382fce00f6b8091a2ad6b0b4e974" translate="yes" xml:space="preserve">
          <source>Do not assume that the code being compiled won&amp;rsquo;t link against any ID shared libraries. Slower code is generated for jump and call insns.</source>
          <target state="translated">컴파일되는 코드가 ID 공유 라이브러리와 링크되지 않는다고 가정하지 마십시오. 점프 및 호출 함수에 대해 느린 코드가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="91704a7cde69df99e26557a8fcaceedc0c021417" translate="yes" xml:space="preserve">
          <source>Do not assume the width of floating-point registers.</source>
          <target state="translated">부동 소수점 레지스터의 너비를 가정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="56a17068976fe756a1e89e46ec309c06e7526fbb" translate="yes" xml:space="preserve">
          <source>Do not attempt to schedule the preceding instruction into the delay slot of a branch instruction placed at the end of a short loop of six instructions or fewer and always schedule a &lt;code&gt;nop&lt;/code&gt; instruction there instead. The short loop bug under certain conditions causes loops to execute only once or twice, due to a hardware bug in the R5900 chip. The workaround is implemented by the assembler rather than by GCC.</source>
          <target state="translated">6 개 이하의 짧은 루프 끝에 위치한 분기 명령의 지연 슬롯에 선행 명령을 예약하지 말고 항상 &lt;code&gt;nop&lt;/code&gt; 명령을 예약하십시오 . 특정 조건에서 짧은 루프 버그로 인해 R5900 칩의 하드웨어 버그로 인해 루프가 한두 번만 실행됩니다. 해결 방법은 GCC가 아닌 어셈블러에서 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="d2be752bd5c8aabe79c7a8b900f158b404d70833" translate="yes" xml:space="preserve">
          <source>Do not consider type &lt;code&gt;int&lt;/code&gt; to be 16 bits wide. This is the default.</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; 유형 을 16 비트 너비로 간주하지 마십시오 . 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="08c20a0490ee73056523e456a376bd15da68e3f1" translate="yes" xml:space="preserve">
          <source>Do not create the &lt;code&gt;gcov&lt;/code&gt; output file.</source>
          <target state="translated">&lt;code&gt;gcov&lt;/code&gt; 출력 파일을 작성하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="61bd4083e901aa03be2fec075c5a07232b9c93d4" translate="yes" xml:space="preserve">
          <source>Do not discard comments, including during macro expansion. This is like</source>
          <target state="translated">매크로 확장을 포함하여 주석을 버리지 마십시오. 이것은 같다</target>
        </trans-unit>
        <trans-unit id="094e1651c852304b7a16e16ed4d0185ecd59b26b" translate="yes" xml:space="preserve">
          <source>Do not discard comments. All comments are passed through to the output file, except for comments in processed directives, which are deleted along with the directive.</source>
          <target state="translated">주석을 버리지 마십시오. 처리 된 지시문의 주석을 제외한 모든 주석은 출력 파일로 전달되며, 지시문과 함께 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="91b2c99fa330a126f06708c6cdfa9c96a1c2ca48" translate="yes" xml:space="preserve">
          <source>Do not emit instructions with side effects in addressing modes other than post-increment.</source>
          <target state="translated">후행 증가 이외의 어드레싱 모드에서는 부작용이있는 명령어를 방출하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="8e8fcc0f33555f7707b3fe0e2c86d30a856ae4de" translate="yes" xml:space="preserve">
          <source>Do not emit the extra code to use the routines specified in the C++ ABI for thread-safe initialization of local statics. You can use this option to reduce code size slightly in code that doesn&amp;rsquo;t need to be thread-safe.</source>
          <target state="translated">로컬 정적의 스레드 안전 초기화를 위해 C ++ ABI에 지정된 루틴을 사용하기 위해 추가 코드를 생성하지 마십시오. 이 옵션을 사용하면 스레드로부터 안전하지 않아도되는 코드에서 코드 크기를 약간 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a50320f9ab85e604d11edb3fea826b2a1de37844" translate="yes" xml:space="preserve">
          <source>Do not enforce a 32-byte alignment for loops. This is the default.</source>
          <target state="translated">루프에 대해 32 바이트 정렬을 강요하지 마십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="891fab210e7a9b122822bf86387a01881f014d38" translate="yes" xml:space="preserve">
          <source>Do not expand any functions inline apart from those marked with the &lt;code&gt;always_inline&lt;/code&gt; attribute. This is the default when not optimizing.</source>
          <target state="translated">&lt;code&gt;always_inline&lt;/code&gt; 속성으로 표시된 기능 외에 인라인을 확장하지 마십시오 . 최적화하지 않을 때의 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="e55929ae438e9efde315189f7933071caa5c75d9" translate="yes" xml:space="preserve">
          <source>Do not expand any symbolic links, resolve references to &amp;lsquo;</source>
          <target state="translated">기호 링크를 확장하지 말고 '</target>
        </trans-unit>
        <trans-unit id="76bc4e801782e79c379029a2b2d98ead9b1c58f2" translate="yes" xml:space="preserve">
          <source>Do not expect a sequence of &lt;code&gt;asm&lt;/code&gt; statements to remain perfectly consecutive after compilation, even when you are using the &lt;code&gt;volatile&lt;/code&gt; qualifier. If certain instructions need to remain consecutive in the output, put them in a single multi-instruction &lt;code&gt;asm&lt;/code&gt; statement.</source>
          <target state="translated">&lt;code&gt;volatile&lt;/code&gt; 한정자를 사용하는 경우에도 컴파일 후 일련의 &lt;code&gt;asm&lt;/code&gt; 문이 완벽하게 연속적으로 유지 되는 것을 기대하지 마십시오 . 특정 명령이 출력에서 ​​연속적으로 유지되어야하는 경우 단일 다중 명령 &lt;code&gt;asm&lt;/code&gt; 문에 넣으십시오 .</target>
        </trans-unit>
        <trans-unit id="1357d76978b996f4f01f805d2256a79e656aef14" translate="yes" xml:space="preserve">
          <source>Do not expect a sequence of &lt;code&gt;asm&lt;/code&gt; statements to remain perfectly consecutive after compilation. If certain instructions need to remain consecutive in the output, put them in a single multi-instruction &lt;code&gt;asm&lt;/code&gt; statement. Note that GCC&amp;rsquo;s optimizers can move &lt;code&gt;asm&lt;/code&gt; statements relative to other code, including across jumps.</source>
          <target state="translated">컴파일 후 일련의 &lt;code&gt;asm&lt;/code&gt; 문이 완벽하게 연속적으로 유지 될 것으로 기대하지 마십시오 . 특정 명령이 출력에서 ​​연속적으로 유지되어야하는 경우 단일 다중 명령 &lt;code&gt;asm&lt;/code&gt; 문에 넣으십시오 . GCC의 옵티마이 저는 점프를 포함하여 다른 코드와 관련하여 &lt;code&gt;asm&lt;/code&gt; 문을 이동할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="84b3d7d09c0c54d717842f06c98dbd62ec42f930" translate="yes" xml:space="preserve">
          <source>Do not generate 16-bit instructions.</source>
          <target state="translated">16 비트 명령어를 생성하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="ad6e921329e0de0a14badc58726b2429a811f03b" translate="yes" xml:space="preserve">
          <source>Do not generate &lt;code&gt;mpy&lt;/code&gt;-family instructions for ARC700. This option is deprecated.</source>
          <target state="translated">ARC700에 대한 &lt;code&gt;mpy&lt;/code&gt; 제품군 명령어를 생성하지 마십시오 . 이 옵션은 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="677bb296fc46c470e0c30284fe52bf50c8bf95e0" translate="yes" xml:space="preserve">
          <source>Do not generate GP-relative accesses.</source>
          <target state="translated">GP 기준 액세스를 생성하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="f71d5f68821b30e885b1156b06fcb682f984e58f" translate="yes" xml:space="preserve">
          <source>Do not generate code that can only run in supervisor mode. This is relevant only for the &lt;code&gt;casa&lt;/code&gt; instruction emitted for the LEON3 processor. This is the default.</source>
          <target state="translated">감독자 모드에서만 실행할 수있는 코드를 생성하지 마십시오. 이것은 LEON3 프로세서에 대해 방출 된 &lt;code&gt;casa&lt;/code&gt; 명령 에만 해당됩니다 . 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="0295c6ec8a8e0c073456a9cdaa9ef67d389ca72d" translate="yes" xml:space="preserve">
          <source>Do not generate code that reads program memory.</source>
          <target state="translated">프로그램 메모리를 읽는 코드를 생성하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="2a55e3aa2938e0b388b8a2f34ed44323717c2975" translate="yes" xml:space="preserve">
          <source>Do not generate code to avoid bugs in the multiply instructions for the MN10300 processors.</source>
          <target state="translated">MN10300 프로세서에 대한 곱하기 명령어에서 버그를 피하기 위해 코드를 생성하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="6775dd83d160f5e2159511baea19387bf2da721f" translate="yes" xml:space="preserve">
          <source>Do not generate code using features specific to the AM33 processor. This is the default.</source>
          <target state="translated">AM33 프로세서 전용 기능을 사용하여 코드를 생성하지 마십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="159947dfd1a4fc3fd4fb823f295379e5ec4d1e29" translate="yes" xml:space="preserve">
          <source>Do not generate conditional move instructions.</source>
          <target state="translated">조건부 이동 명령을 생성하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="2a7c63697c44693e6c631b03a4bcdf4c623d8e94" translate="yes" xml:space="preserve">
          <source>Do not generate floating-point instructions; use library calls instead. This is the default for 68000, 68010, and 68832 targets. It is also the default for ColdFire devices that have no FPU.</source>
          <target state="translated">부동 소수점 명령어를 생성하지 마십시오. 대신 라이브러리 호출을 사용하십시오. 68000, 68010 및 68832 대상의 기본값입니다. FPU가없는 ColdFire 장비의 기본값이기도합니다.</target>
        </trans-unit>
        <trans-unit id="2cc223b18a9c8fe85db4c5fdd1a4568ac5523351" translate="yes" xml:space="preserve">
          <source>Do not generate inline code for &lt;code&gt;sqrt&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;sqrt&lt;/code&gt; 에 대한 인라인 코드를 생성하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="7dccee88899cb101fdf1122d7b6f87cc5ad98128" translate="yes" xml:space="preserve">
          <source>Do not generate inline code for divides of floating-point values.</source>
          <target state="translated">부동 소수점 값을 나누기 위해 인라인 코드를 생성하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="db0d6f198e71d6a0581c6b52ba5d158f3703dad4" translate="yes" xml:space="preserve">
          <source>Do not generate inline code for divides of integer values.</source>
          <target state="translated">정수 값을 나누기 위해 인라인 코드를 생성하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="5bf145c70d37b823fa320934be3a45f2f5b58879" translate="yes" xml:space="preserve">
          <source>Do not generate performance extension 2 instructions.</source>
          <target state="translated">성능 확장 2 명령어를 생성하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="3b1b47a62d265ff0109bc6fe295c353c7dfbd942" translate="yes" xml:space="preserve">
          <source>Do not generate performance extension instructions.</source>
          <target state="translated">성능 확장 명령어를 생성하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="b028375dbf2397374ef15ae6807634be0bef9937" translate="yes" xml:space="preserve">
          <source>Do not generate sdata references. This is the default for tool chains built for &lt;code&gt;arc-linux-uclibc&lt;/code&gt; and &lt;code&gt;arceb-linux-uclibc&lt;/code&gt; targets.</source>
          <target state="translated">sdata 참조를 생성하지 마십시오. 이는 &lt;code&gt;arc-linux-uclibc&lt;/code&gt; 및 &lt;code&gt;arceb-linux-uclibc&lt;/code&gt; 대상 용으로 빌드 된 툴 체인의 기본값입니다 .</target>
        </trans-unit>
        <trans-unit id="543afe0ee34f2553275fc1e0d4f92ae4d031e11e" translate="yes" xml:space="preserve">
          <source>Do not generate string extension instructions.</source>
          <target state="translated">문자열 확장 명령어를 생성하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="35172dff465f7db05c87cd9d0fa618a5943366ff" translate="yes" xml:space="preserve">
          <source>Do not generate v3 push25/pop25 instructions.</source>
          <target state="translated">v3 push25 / pop25 명령어를 생성하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="57a412ef71d36d080e33196062eae1a348ffd9a5" translate="yes" xml:space="preserve">
          <source>Do not guess branch probabilities using heuristics.</source>
          <target state="translated">휴리스틱을 사용하여 분기 확률을 추측하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="c3b0780d488de79c8fb5609252ace9e026b5485c" translate="yes" xml:space="preserve">
          <source>Do not link in the C run-time initialization object file.</source>
          <target state="translated">C 런타임 초기화 오브젝트 파일에서 링크하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="1be7375d07ff18651b91e6f0b8f72660024d9706" translate="yes" xml:space="preserve">
          <source>Do not mark ABI switches in e_flags.</source>
          <target state="translated">e_flags에 ABI 스위치를 표시하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="431d0ac813eff431a021eadf038696c3b8c0a701" translate="yes" xml:space="preserve">
          <source>Do not optimize (do optimize) basic blocks that use the same index pointer 4 or more times to copy pointer into the &lt;code&gt;ep&lt;/code&gt; register, and use the shorter &lt;code&gt;sld&lt;/code&gt; and &lt;code&gt;sst&lt;/code&gt; instructions. The</source>
          <target state="translated">포인터를 &lt;code&gt;ep&lt;/code&gt; 레지스터 에 복사하기 위해 동일한 인덱스 포인터를 4 번 이상 사용하는 기본 블록을 최적화 (최적화)하지 말고 더 짧은 &lt;code&gt;sld&lt;/code&gt; 및 &lt;code&gt;sst&lt;/code&gt; 명령어를 사용하십시오. 그만큼</target>
        </trans-unit>
        <trans-unit id="79c5f07fbe7818d1561eea80118156e770e03da3" translate="yes" xml:space="preserve">
          <source>Do not optimize block moves, use &lt;code&gt;memcpy&lt;/code&gt;.</source>
          <target state="translated">블록 이동을 최적화하지 말고 &lt;code&gt;memcpy&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="1c81bdb6603f6660bfebcf5b1c10715d6960adf2" translate="yes" xml:space="preserve">
          <source>Do not or do generate unaligned memory accesses. The default is set depending on whether the processor we are optimizing for supports fast unaligned access or not.</source>
          <target state="translated">정렬되지 않은 메모리 액세스를 생성하지 마십시오. 기본값은 최적화하려는 프로세서가 빠른 정렬되지 않은 액세스를 지원하는지 여부에 따라 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="4a89ae960644f6dae44b3cb05c0d0550f4cbdda0" translate="yes" xml:space="preserve">
          <source>Do not output certain jump instructions (&lt;code&gt;aobleq&lt;/code&gt; and so on) that the Unix assembler for the VAX cannot handle across long ranges.</source>
          <target state="translated">VAX 용 Unix 어셈블러가 장거리를 처리 할 수없는 특정 점프 명령 ( &lt;code&gt;aobleq&lt;/code&gt; 등)을 출력하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="f8a3ee3da0c5dc6481bc333868effaef20cfecb3" translate="yes" xml:space="preserve">
          <source>Do not pack VLIW instructions.</source>
          <target state="translated">VLIW 지침을 포장하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="5cf0a2e01f314e50aac688fcc0637765ffe183d2" translate="yes" xml:space="preserve">
          <source>Do not predefine any system-specific or GCC-specific macros. The standard predefined macros remain defined.</source>
          <target state="translated">시스템 특정 또는 GCC 특정 매크로를 미리 정의하지 마십시오. 사전 정의 된 표준 매크로는 정의 된 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="490cb97bfac29c7944f438d394a40917ab27b463" translate="yes" xml:space="preserve">
          <source>Do not print column numbers in diagnostics. This may be necessary if diagnostics are being scanned by a program that does not understand the column numbers, such as &lt;code&gt;dejagnu&lt;/code&gt;.</source>
          <target state="translated">진단시 열 번호를 인쇄하지 마십시오. &lt;code&gt;dejagnu&lt;/code&gt; 와 같은 열 번호를 이해하지 못하는 프로그램이 진단을 스캔하는 경우 필요할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5a166eec1d3e160d989368c024582f88a817fbe4" translate="yes" xml:space="preserve">
          <source>Do not put function addresses in registers; make each instruction that calls a constant function contain the function&amp;rsquo;s address explicitly.</source>
          <target state="translated">기능 주소를 레지스터에 넣지 마십시오. 상수 함수를 호출하는 각 명령어에 함수의 주소가 명시 적으로 포함되도록합니다.</target>
        </trans-unit>
        <trans-unit id="42d099b873c7985f112edf3c200fc2a3b03ec5d0" translate="yes" xml:space="preserve">
          <source>Do not recognize &lt;code&gt;asm&lt;/code&gt;, &lt;code&gt;inline&lt;/code&gt; or &lt;code&gt;typeof&lt;/code&gt; as a keyword, so that code can use these words as identifiers. You can use the keywords &lt;code&gt;__asm__&lt;/code&gt;, &lt;code&gt;__inline__&lt;/code&gt; and &lt;code&gt;__typeof__&lt;/code&gt; instead.</source>
          <target state="translated">코드에서 이러한 단어를 식별자로 사용할 수 있도록 &lt;code&gt;asm&lt;/code&gt; , &lt;code&gt;inline&lt;/code&gt; 또는 &lt;code&gt;typeof&lt;/code&gt; 를 키워드로 인식하지 마십시오 . 대신 &lt;code&gt;__asm__&lt;/code&gt; , &lt;code&gt;__inline__&lt;/code&gt; 및 &lt;code&gt;__typeof__&lt;/code&gt; 키워드를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4748c7a1ef517bb9ba562d1dfbac2e153a84b556" translate="yes" xml:space="preserve">
          <source>Do not recognize &lt;code&gt;typeof&lt;/code&gt; as a keyword, so that code can use this word as an identifier. You can use the keyword &lt;code&gt;__typeof__&lt;/code&gt; instead. This option is implied by the strict ISO C++ dialects:</source>
          <target state="translated">코드에서이 단어를 식별자로 사용할 수 있도록 &lt;code&gt;typeof&lt;/code&gt; 를 키워드로 인식하지 마십시오 . 대신 &lt;code&gt;__typeof__&lt;/code&gt; 키워드를 사용할 수 있습니다 . 이 옵션은 엄격한 ISO C ++ 방언으로 암시됩니다.</target>
        </trans-unit>
        <trans-unit id="d988b2ea918cdfbb994dc84b28dcc9b828621817" translate="yes" xml:space="preserve">
          <source>Do not remove unused C++ allocations in dead code elimination.</source>
          <target state="translated">데드 코드 제거에서 사용하지 않는 C ++ 할당을 제거하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="0184fc6ad01e42f8636e2c8922ca8fae3a1d46de" translate="yes" xml:space="preserve">
          <source>Do not reorder functions or variables marked &lt;code&gt;no_reorder&lt;/code&gt; against each other or top level assembler statements the executable. The actual order in the program will depend on the linker command line. Static variables marked like this are also not removed. This has a similar effect as the</source>
          <target state="translated">&lt;code&gt;no_reorder&lt;/code&gt; 로 표시된 함수 나 변수 를 서로 재정렬 하거나 최상위 어셈블러에서 실행 파일을 진술 하지 마십시오 . 프로그램의 실제 순서는 링커 명령 줄에 따라 다릅니다. 이와 같이 표시된 정적 변수도 제거되지 않습니다. 이것은</target>
        </trans-unit>
        <trans-unit id="8ddac79842e7bae2915ad838f14a89d8d6021356" translate="yes" xml:space="preserve">
          <source>Do not reorder top-level functions, variables, and &lt;code&gt;asm&lt;/code&gt; statements. Output them in the same order that they appear in the input file. When this option is used, unreferenced static variables are not removed. This option is intended to support existing code that relies on a particular ordering. For new code, it is better to use attributes when possible.</source>
          <target state="translated">최상위 함수, 변수 및 &lt;code&gt;asm&lt;/code&gt; 문을 재정렬하지 마십시오 . 입력 파일에 나타나는 순서대로 출력하십시오. 이 옵션을 사용하면 참조되지 않은 정적 변수는 제거되지 않습니다. 이 옵션은 특정 순서에 의존하는 기존 코드를 지원하기위한 것입니다. 새 코드의 경우 가능하면 속성을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e09f89632800cad3603644ff83e1a579b7e4eb4f" translate="yes" xml:space="preserve">
          <source>Do not run a pass to pack branches into VLIW instructions.</source>
          <target state="translated">분기를 VLIW 지침으로 포장하기 위해 패스를 실행하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="0dba1f61030583d8ab48fd80d73e6a5afaf9d194" translate="yes" xml:space="preserve">
          <source>Do not save registers in &lt;code&gt;main&lt;/code&gt;. The effect is the same like attaching attribute &lt;a href=&quot;avr-function-attributes#AVR-Function-Attributes&quot;&gt;&lt;code&gt;OS_task&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;main&lt;/code&gt;. It is activated per default if optimization is on.</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 레지스터를 저장하지 마십시오 . 결과는 속성 &lt;a href=&quot;avr-function-attributes#AVR-Function-Attributes&quot;&gt; &lt;code&gt;OS_task&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;main&lt;/code&gt; 에 첨부하는 것과 같습니다 . 최적화가 켜져 있으면 기본적으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="9b74c0ce30e69827202932531a3c2d31b17cec32" translate="yes" xml:space="preserve">
          <source>Do not search for header files in the C++-specific standard directories, but do still search the other standard directories. (This option is used when building the C++ library.)</source>
          <target state="translated">C ++ 특정 표준 디렉토리에서 헤더 파일을 검색하지 말고 다른 표준 디렉토리를 계속 검색하십시오. (이 옵션은 C ++ 라이브러리를 빌드 할 때 사용됩니다.)</target>
        </trans-unit>
        <trans-unit id="10d644d96645c398a65f49953416f8df18eac09b" translate="yes" xml:space="preserve">
          <source>Do not search for header files in the standard directories specific to C++, but do still search the other standard directories. (This option is used when building the C++ library.)</source>
          <target state="translated">C ++에 특정한 표준 디렉토리에서 헤더 파일을 검색하지 말고 다른 표준 디렉토리를 계속 검색하십시오. (이 옵션은 C ++ 라이브러리를 빌드 할 때 사용됩니다.)</target>
        </trans-unit>
        <trans-unit id="6ee81949a7a2777f7208e1e6ee75bc8ae9472923" translate="yes" xml:space="preserve">
          <source>Do not search the standard system directories for header files. Only the directories explicitly specified with</source>
          <target state="translated">표준 시스템 디렉토리에서 헤더 파일을 검색하지 마십시오. 로 명시 적으로 지정된 디렉토리 만</target>
        </trans-unit>
        <trans-unit id="eb16433a9f72928c54140581a05d1867ea26ccd7" translate="yes" xml:space="preserve">
          <source>Do not set &lt;code&gt;errno&lt;/code&gt; after calling math functions that are executed with a single instruction, e.g., &lt;code&gt;sqrt&lt;/code&gt;. A program that relies on IEEE exceptions for math error handling may want to use this flag for speed while maintaining IEEE arithmetic compatibility.</source>
          <target state="translated">&lt;code&gt;sqrt&lt;/code&gt; 와 같은 단일 명령어로 실행되는 수학 함수를 호출 한 후 &lt;code&gt;errno&lt;/code&gt; 를 설정하지 마십시오 . 수학 오류 처리를 위해 IEEE 예외에 의존하는 프로그램은 IEEE 산술 호환성을 유지하면서 속도를 위해이 플래그를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20c8d2c68cfa75e481382ec2a217fdac468ae476" translate="yes" xml:space="preserve">
          <source>Do not store floating-point variables in registers, and inhibit other options that might change whether a floating-point value is taken from a register or memory.</source>
          <target state="translated">부동 소수점 변수를 레지스터에 저장하지 말고 부동 소수점 값을 레지스터에서 가져 오는지 또는 메모리에서 가져 오는지를 변경할 수있는 다른 옵션을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="1e223b8f5150edab41b25d5219e57c17c3a59917" translate="yes" xml:space="preserve">
          <source>Do not substitute constants for known return value of formatted output functions such as &lt;code&gt;sprintf&lt;/code&gt;, &lt;code&gt;snprintf&lt;/code&gt;, &lt;code&gt;vsprintf&lt;/code&gt;, and &lt;code&gt;vsnprintf&lt;/code&gt; (but not &lt;code&gt;printf&lt;/code&gt; of &lt;code&gt;fprintf&lt;/code&gt;). This transformation allows GCC to optimize or even eliminate branches based on the known return value of these functions called with arguments that are either constant, or whose values are known to be in a range that makes determining the exact return value possible. For example, when</source>
          <target state="translated">같은 형식의 출력 기능의 알려진 반환 값없는 대신 상수 수행 &lt;code&gt;sprintf&lt;/code&gt; 와 , &lt;code&gt;snprintf&lt;/code&gt; , &lt;code&gt;vsprintf&lt;/code&gt; 및 &lt;code&gt;vsnprintf&lt;/code&gt; (그러나 &lt;code&gt;printf&lt;/code&gt; 와 의 &lt;code&gt;fprintf&lt;/code&gt; ). 이 변환을 통해 GCC는 상수이거나 값이 정확한 반환 값을 결정할 수있는 범위에있는 인수로 불리는 이러한 함수의 알려진 반환 값을 기반으로 분기를 최적화하거나 제거 할 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="cf78eba26b5aa804017da1ef12f012cd3682e1fb" translate="yes" xml:space="preserve">
          <source>Do not treat the operator name keywords &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;bitand&lt;/code&gt;, &lt;code&gt;bitor&lt;/code&gt;, &lt;code&gt;compl&lt;/code&gt;, &lt;code&gt;not&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt; and &lt;code&gt;xor&lt;/code&gt; as synonyms as keywords.</source>
          <target state="translated">운영자 이름 키워드를 취급하지 마십시오 &lt;code&gt;and&lt;/code&gt; , &lt;code&gt;bitand&lt;/code&gt; , &lt;code&gt;bitor&lt;/code&gt; , &lt;code&gt;compl&lt;/code&gt; , &lt;code&gt;not&lt;/code&gt; , &lt;code&gt;or&lt;/code&gt; 및 &lt;code&gt;xor&lt;/code&gt; 키워드로 동의어로.</target>
        </trans-unit>
        <trans-unit id="a51f0c8e8070d0d16a2b1996318508b466a43f6d" translate="yes" xml:space="preserve">
          <source>Do not try to dynamically allocate condition code registers, only use &lt;code&gt;icc0&lt;/code&gt; and &lt;code&gt;fcc0&lt;/code&gt;.</source>
          <target state="translated">조건 코드 레지스터를 동적으로 할당하지 말고 &lt;code&gt;icc0&lt;/code&gt; 및 &lt;code&gt;fcc0&lt;/code&gt; 만 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="e4b145e8904eea56f7b19e2cc3eedad3e7a2b834" translate="yes" xml:space="preserve">
          <source>Do not use (do use) external functions to save and restore registers at the prologue and epilogue of a function. The external functions are slower, but use less code space if more than one function saves the same number of registers. The</source>
          <target state="translated">함수의 프롤로그 및 에필로그에서 레지스터를 저장하고 복원하기 위해 외부 함수를 사용하지 마십시오. 외부 함수는 느리지 만 둘 이상의 함수가 동일한 수의 레지스터를 저장하는 경우 코드 공간을 적게 사용하십시오. 그만큼</target>
        </trans-unit>
        <trans-unit id="00d7092da6abac6816723cc9e024cce735f69d9a" translate="yes" xml:space="preserve">
          <source>Do not use &lt;code&gt;__gcc_isr&lt;/code&gt; pseudo instructions in a function with the &lt;code&gt;interrupt&lt;/code&gt; or &lt;code&gt;signal&lt;/code&gt; attribute aka. interrupt service routine (ISR). Use this attribute if the preamble of the ISR prologue should always read</source>
          <target state="translated">&lt;code&gt;interrupt&lt;/code&gt; 또는 &lt;code&gt;signal&lt;/code&gt; 속성이 일명 인 함수에는 &lt;code&gt;__gcc_isr&lt;/code&gt; 의사 명령어를 사용하지 마십시오 . 인터럽트 서비스 루틴 (ISR). ISR 프롤로그의 프리앰블이 항상 읽어야하는 경우이 속성을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="18d8580e81e8dfe5a32f7016f417e2eb0471dcb3" translate="yes" xml:space="preserve">
          <source>Do not use a so-called &amp;ldquo;red zone&amp;rdquo; for x86-64 code. The red zone is mandated by the x86-64 ABI; it is a 128-byte area beyond the location of the stack pointer that is not modified by signal or interrupt handlers and therefore can be used for temporary data without adjusting the stack pointer. The flag</source>
          <target state="translated">x86-64 코드에는 소위 &quot;적색 영역&quot;을 사용하지 마십시오. 적색 구역은 x86-64 ABI에 의해 규정됩니다. 신호 또는 인터럽트 처리기로 수정되지 않은 스택 포인터의 위치를 ​​넘어 128 바이트 영역이므로 스택 포인터를 조정하지 않고도 임시 데이터에 사용할 수 있습니다. 깃발</target>
        </trans-unit>
        <trans-unit id="18a500f76abd74325a0b47c0d5b69985957db494" translate="yes" xml:space="preserve">
          <source>Do not use condition-code results from previous instruction; always emit compare and test instructions before use of condition codes.</source>
          <target state="translated">이전 명령의 조건 코드 결과를 사용하지 마십시오. 조건 코드를 사용하기 전에 항상 비교 및 ​​테스트 지침을 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="8b90672d13ea8faf72441a2154876e77530d1d87" translate="yes" xml:space="preserve">
          <source>Do not use div and mod instructions.</source>
          <target state="translated">div 및 mod 명령어를 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="a1c8552434007f4da99e51d45212d527e1753ccf" translate="yes" xml:space="preserve">
          <source>Do not use double word instructions.</source>
          <target state="translated">더블 워드 명령어를 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="3da98d0922de975e727ce6056f533717a8befbdb" translate="yes" xml:space="preserve">
          <source>Do not use floating-point coprocessor instructions. Implement floating-point calculations using library calls instead.</source>
          <target state="translated">부동 소수점 보조 프로세서 명령어를 사용하지 마십시오. 대신 라이브러리 호출을 사용하여 부동 소수점 계산을 구현하십시오.</target>
        </trans-unit>
        <trans-unit id="9fdd545e439d4b4617a15eacf8cd9e4f96ac14e8" translate="yes" xml:space="preserve">
          <source>Do not use floating-point double instructions.</source>
          <target state="translated">부동 소수점 이중 명령어를 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="95fd53c42ee138555aacbc40f7b4326fe9304fd6" translate="yes" xml:space="preserve">
          <source>Do not use hardware floating point.</source>
          <target state="translated">하드웨어 부동 소수점을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="97b2ddca9650ddbadc66a49ca355676910df5582" translate="yes" xml:space="preserve">
          <source>Do not use jump tables for switch statements even where it would be more efficient than other code generation strategies. This option is of use in conjunction with</source>
          <target state="translated">다른 코드 생성 전략보다 효율적인 경우에도 switch 문에 점프 테이블을 사용하지 마십시오. 이 옵션은 다음과 함께 사용됩니다</target>
        </trans-unit>
        <trans-unit id="66b43b46849088f20d198292bf3b1d8b62697198" translate="yes" xml:space="preserve">
          <source>Do not use media instructions.</source>
          <target state="translated">용지 지침을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="0a7e7f9ca7cad5a355cdeb3565cfa6b4acd871ea" translate="yes" xml:space="preserve">
          <source>Do not use multiply and add/subtract instructions.</source>
          <target state="translated">곱하기 및 더하기 / 빼기 명령어를 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="8d9e83aee940103d590cb767e0456c5b78e32683" translate="yes" xml:space="preserve">
          <source>Do not use table-based fast divide for small numbers. The default is to use the fast divide at</source>
          <target state="translated">작은 숫자에는 테이블 기반 빠른 나누기를 사용하지 마십시오. 기본값은 빠른 나누기를 사용하는 것입니다</target>
        </trans-unit>
        <trans-unit id="05b033596194e8c7885a56cfce16297eb0279fb4" translate="yes" xml:space="preserve">
          <source>Do not use the C library or system libraries tightly coupled with it when linking. Still link with the startup files,</source>
          <target state="translated">링크 할 때 C 라이브러리 또는 시스템 라이브러리를 밀접하게 결합하여 사용하지 마십시오. 여전히 시작 파일과 연결</target>
        </trans-unit>
        <trans-unit id="7597081c858717e7804a44bce422498f190040a9" translate="yes" xml:space="preserve">
          <source>Do not use the FPU registers for return values of functions.</source>
          <target state="translated">함수의 반환 값에 FPU 레지스터를 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="1d16a9b15ecbbe19aaee48f8f83799d98bf40097" translate="yes" xml:space="preserve">
          <source>Do not use the PLT for external function calls in position-independent code. Instead, load the callee address at call sites from the GOT and branch to it. This leads to more efficient code by eliminating PLT stubs and exposing GOT loads to optimizations. On architectures such as 32-bit x86 where PLT stubs expect the GOT pointer in a specific register, this gives more register allocation freedom to the compiler. Lazy binding requires use of the PLT; with</source>
          <target state="translated">위치 독립적 인 코드에서 외부 함수 호출에 PLT를 사용하지 마십시오. 대신, GOT에서 호출 사이트의 수신자 주소를로드하고 그 주소로 분기하십시오. 이는 PLT 스텁을 제거하고 GOT로드를 최적화에 노출함으로써보다 효율적인 코드로 이어집니다. PLT 스터브가 특정 레지스터에서 GOT 포인터를 기대하는 32 비트 x86과 같은 아키텍처에서는 컴파일러에 더 많은 레지스터 할당 자유를 제공합니다. 게으른 결합에는 PLT를 사용해야합니다. 와</target>
        </trans-unit>
        <trans-unit id="0ea4440b962126227be7707085ba73c227777ab2" translate="yes" xml:space="preserve">
          <source>Do not use the bit-field instructions. The</source>
          <target state="translated">비트 필드 명령어를 사용하지 마십시오. 그만큼</target>
        </trans-unit>
        <trans-unit id="be4c2d58ea2c75689a1e197b8bce077dc3baf8e4" translate="yes" xml:space="preserve">
          <source>Do not use the standard system libraries when linking. Only the libraries you specify are passed to the linker, and options specifying linkage of the system libraries, such as</source>
          <target state="translated">연결할 때 표준 시스템 라이브러리를 사용하지 마십시오. 지정한 라이브러리 만 링커에 전달되고 시스템 라이브러리의 링크를 지정하는 옵션 (예 :</target>
        </trans-unit>
        <trans-unit id="1749ead3f9e7878168e9e856a83790c8110a2327" translate="yes" xml:space="preserve">
          <source>Do not use the standard system startup files or libraries when linking. No startup files and only the libraries you specify are passed to the linker, and options specifying linkage of the system libraries, such as</source>
          <target state="translated">링크 할 때 표준 시스템 시작 파일 또는 라이브러리를 사용하지 마십시오. 시작 파일이없고 지정한 라이브러리 만 링커에 전달되고 시스템 라이브러리의 링크를 지정하는 옵션 (예 :</target>
        </trans-unit>
        <trans-unit id="c08b8394a0f77286bf2dfe4eba4ed4f08b60e58a" translate="yes" xml:space="preserve">
          <source>Do not use the standard system startup files when linking. The standard system libraries are used normally, unless</source>
          <target state="translated">연결할 때 표준 시스템 시작 파일을 사용하지 마십시오. 표준 시스템 라이브러리는 일반적으로 사용되지 않는 한</target>
        </trans-unit>
        <trans-unit id="52b9f7e2d461f74673bbbc8c6515110fc50b3657" translate="yes" xml:space="preserve">
          <source>Do not use type qualifiers such as &lt;code&gt;const&lt;/code&gt; and &lt;code&gt;volatile&lt;/code&gt;, as the outcome may be contrary to expectations. In particular, using the &lt;code&gt;volatile&lt;/code&gt; qualifier does not fully prevent the compiler from optimizing accesses to the register.</source>
          <target state="translated">결과가 예상과 상충 될 수 있으므로 &lt;code&gt;const&lt;/code&gt; 및 &lt;code&gt;volatile&lt;/code&gt; 과 같은 유형 한정자를 사용하지 마십시오 . 특히, &lt;code&gt;volatile&lt;/code&gt; 한정자를 사용 한다고해서 컴파일러가 레지스터에 대한 액세스를 최적화하는 것을 완전히 막을 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="78d5320a817e4a255712f70b363a7e985f54d40c" translate="yes" xml:space="preserve">
          <source>Do not use type qualifiers such as &lt;code&gt;const&lt;/code&gt; and &lt;code&gt;volatile&lt;/code&gt;, as the outcome may be contrary to expectations. In particular, when the &lt;code&gt;const&lt;/code&gt; qualifier is used, the compiler may substitute the variable with its initializer in &lt;code&gt;asm&lt;/code&gt; statements, which may cause the corresponding operand to appear in a different register.</source>
          <target state="translated">결과가 예상과 상충 될 수 있으므로 &lt;code&gt;const&lt;/code&gt; 및 &lt;code&gt;volatile&lt;/code&gt; 과 같은 유형 한정자를 사용하지 마십시오 . 특히 &lt;code&gt;const&lt;/code&gt; 한정자를 사용하면 컴파일러는 변수를 &lt;code&gt;asm&lt;/code&gt; 문 에서 이니셜 라이저로 대체 하여 해당 피연산자가 다른 레지스터에 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a1518a9d7c5d3a374a0e3380575da8c6a0c3463" translate="yes" xml:space="preserve">
          <source>Do not use weak symbol support, even if it is provided by the linker. By default, G++ uses weak symbols if they are available. This option exists only for testing, and should not be used by end-users; it results in inferior code and has no benefits. This option may be removed in a future release of G++.</source>
          <target state="translated">링커에서 제공 한 경우에도 약한 심볼 지원을 사용하지 마십시오. 기본적으로 G ++는 사용 가능한 경우 약한 기호를 사용합니다. 이 옵션은 테스트 용으로 만 사용되며 최종 사용자가 사용해서는 안됩니다. 코드가 열등하고 이점이 없습니다. 이 옵션은 향후 G ++ 릴리스에서 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c6a44b0e85a6edc81e27b7d2eeb886e6e3cf31e" translate="yes" xml:space="preserve">
          <source>Do not warn about compile-time integer division by zero. Floating-point division by zero is not warned about, as it can be a legitimate way of obtaining infinities and NaNs.</source>
          <target state="translated">컴파일 타임 정수를 0으로 나누는 것에 대해 경고하지 마십시오. 부동 소수점을 0으로 나누는 것은 무한대와 NaN을 얻는 합법적 인 방법 일 수 있으므로 경고하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5c0402a3d7a93e89c19d0b2bc886627da9bb7bce" translate="yes" xml:space="preserve">
          <source>Do not warn about compile-time overflow in constant expressions.</source>
          <target state="translated">상수 식에서 컴파일 타임 오버플로에 대해 경고하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="f3164f98334eb82394edc2af61f2d8e4ea49e902" translate="yes" xml:space="preserve">
          <source>Do not warn about incompatible integer to pointer and pointer to integer conversions. This warning is about implicit conversions; for explicit conversions the warnings</source>
          <target state="translated">호환되지 않는 정수 대 포인터 및 포인터 대 정수 변환에 대해 경고하지 마십시오. 이 경고는 암시 적 변환에 관한 것입니다. 명시적인 변환을 위해 경고</target>
        </trans-unit>
        <trans-unit id="9ee34e26cbf6dcdf9bae6a606eba5f147e3812eb" translate="yes" xml:space="preserve">
          <source>Do not warn about misuses of pragmas, such as incorrect parameters, invalid syntax, or conflicts between pragmas. See also</source>
          <target state="translated">잘못된 매개 변수, 잘못된 구문 또는 pragma 간의 충돌과 같은 pragma 오용에 대해 경고하지 마십시오. 또한보십시오</target>
        </trans-unit>
        <trans-unit id="2fba612926859cd3b2ec30d821b233c2c88e411e" translate="yes" xml:space="preserve">
          <source>Do not warn about returning a pointer (or in C++, a reference) to a variable that goes out of scope after the function returns.</source>
          <target state="translated">함수가 리턴 된 후 범위를 벗어난 변수에 대한 포인터 (또는 C ++에서는 참조)를 리턴하는 것에 대해 경고하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="92098da2097ee55c0bcb42fe16576932a7b751af" translate="yes" xml:space="preserve">
          <source>Do not warn about stray tokens after &lt;code&gt;#else&lt;/code&gt; and &lt;code&gt;#endif&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;#else&lt;/code&gt; 및 &lt;code&gt;#endif&lt;/code&gt; 뒤에있는 표유 토큰에 대해 경고하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="e20062785b98beaefd7db7d397190023d3d7d01c" translate="yes" xml:space="preserve">
          <source>Do not warn about usage of deprecated features. See &lt;a href=&quot;deprecated-features#Deprecated-Features&quot;&gt;Deprecated Features&lt;/a&gt;.</source>
          <target state="translated">더 이상 사용되지 않는 기능의 사용에 대해 경고하지 마십시오. 더 이상 &lt;a href=&quot;deprecated-features#Deprecated-Features&quot;&gt;사용되지 않는 기능을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5741a81d36ae80d4f66c3d238560cf727f6d2221" translate="yes" xml:space="preserve">
          <source>Do not warn about usage of functions (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;) declared with &lt;code&gt;warning&lt;/code&gt; attribute. By default, this warning is enabled.</source>
          <target state="translated">&lt;code&gt;warning&lt;/code&gt; 속성으로 선언 된 함수 사용 ( &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;함수 속성&lt;/a&gt; 참조)에 대해 경고하지 마십시오 . 이 경고는 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="569882ee6769c783a7c673619d2b596b07ae7884" translate="yes" xml:space="preserve">
          <source>Do not warn about uses of &lt;code&gt;std::initializer_list&lt;/code&gt; that are likely to result in dangling pointers. Since the underlying array for an &lt;code&gt;initializer_list&lt;/code&gt; is handled like a normal C++ temporary object, it is easy to inadvertently keep a pointer to the array past the end of the array&amp;rsquo;s lifetime. For example:</source>
          <target state="translated">매달려 포인터가 발생할 수있는 &lt;code&gt;std::initializer_list&lt;/code&gt; 사용에 대해 경고하지 마십시오 . &lt;code&gt;initializer_list&lt;/code&gt; 의 기본 배열 은 일반 C ++ 임시 오브젝트처럼 처리되므로 배열의 수명이 다한 후에 배열에 대한 포인터를 실수로 쉽게 유지할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e7879bd2657e4473a1347324fd997f9cdc3d041e" translate="yes" xml:space="preserve">
          <source>Do not warn about uses of functions (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;), variables (see &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;), and types (see &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Type Attributes&lt;/a&gt;) marked as deprecated by using the &lt;code&gt;deprecated&lt;/code&gt; attribute.</source>
          <target state="translated">더 이상 사용 &lt;code&gt;deprecated&lt;/code&gt; 속성 을 사용하여 더 이상 사용되지 않는 것으로 표시된 함수 ( &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;함수 속성&lt;/a&gt; 참조 ), 변수 ( &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;변수 속성&lt;/a&gt; 참조 ) 및 유형 ( &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;유형 속성&lt;/a&gt; 참조) 사용에 대해 경고하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="e33f23c639b6d41c2c3035fff8afee57ebc3fce6" translate="yes" xml:space="preserve">
          <source>Do not warn for calls to bounded string manipulation functions such as &lt;code&gt;strncat&lt;/code&gt;, &lt;code&gt;strncpy&lt;/code&gt;, and &lt;code&gt;stpncpy&lt;/code&gt; that may either truncate the copied string or leave the destination unchanged.</source>
          <target state="translated">&lt;code&gt;strncat&lt;/code&gt; , &lt;code&gt;strncpy&lt;/code&gt; 및 &lt;code&gt;stpncpy&lt;/code&gt; 와 같이 복사 된 문자열을 자르거나 대상을 변경하지 않은 상태로 둘 수있는 제한된 문자열 조작 함수에 대한 호출에 대해 경고하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="b2ba657c651e9df665e818d59934ea7360d21f9d" translate="yes" xml:space="preserve">
          <source>Do not warn for conversions between &lt;code&gt;NULL&lt;/code&gt; and non-pointer types.</source>
          <target state="translated">&lt;code&gt;NULL&lt;/code&gt; 과 비 포인터 유형 간의 변환에 대해 경고하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="f3c7034f14450f34ae37fb2f3dc3f8309df1df4c" translate="yes" xml:space="preserve">
          <source>Do not warn if a caller of a function marked with attribute &lt;code&gt;warn_unused_result&lt;/code&gt; (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;) does not use its return value. The default is</source>
          <target state="translated">속성 &lt;code&gt;warn_unused_result&lt;/code&gt; ( &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;함수 속성&lt;/a&gt; 참조) 로 표시된 함수의 호출자가 리턴 값을 사용하지 않는 경우 경고하지 마십시오 . 디폴트는</target>
        </trans-unit>
        <trans-unit id="fb9755e0253eb1306289d1103fce8726c90aae41" translate="yes" xml:space="preserve">
          <source>Do not warn if a class type has a base or a field whose type uses the anonymous namespace or depends on a type with no linkage. If a type A depends on a type B with no or internal linkage, defining it in multiple translation units would be an ODR violation because the meaning of B is different in each translation unit. If A only appears in a single translation unit, the best way to silence the warning is to give it internal linkage by putting it in an anonymous namespace as well. The compiler doesn&amp;rsquo;t give this warning for types defined in the main .C file, as those are unlikely to have multiple definitions.</source>
          <target state="translated">클래스 유형에 유형이 익명 네임 스페이스를 사용하거나 링크가없는 유형에 종속 된 기본 또는 필드가있는 경우 경고하지 마십시오. 유형 A가 내부 연결이 없거나 내부 연결이없는 유형 B에 종속 된 경우 B의 의미가 각 번역 단위에서 다르기 때문에 여러 번역 단위로 정의하면 ODR 위반이됩니다. A가 단일 번역 단위에만 나타나는 경우 경고를 무음 화하는 가장 좋은 방법은 익명 네임 스페이스에도 넣어 내부 연결을 제공하는 것입니다. 컴파일러는 기본 .C 파일에 정의 된 유형에 대해이 경고를 표시하지 않습니다. 여러 정의가있을 가능성이 낮기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="e5c44e9dcc0d0d2cc0d4fcbe48e1b3887ed71621" translate="yes" xml:space="preserve">
          <source>Do not warn if a multicharacter constant (&amp;lsquo;</source>
          <target state="translated">다중 문자 상수 ( '</target>
        </trans-unit>
        <trans-unit id="443e1e0e70a448710aa93209ae6dd62fb7533f28" translate="yes" xml:space="preserve">
          <source>Do not warn if a pointer is compared with a zero character constant. This usually means that the pointer was meant to be dereferenced. For example:</source>
          <target state="translated">포인터가 0 문자 상수와 비교되는 경우 경고하지 않습니다. 이것은 일반적으로 포인터가 역 참조됨을 의미합니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="474d345e0c92820e39935346f3f6f08e315a2c69" translate="yes" xml:space="preserve">
          <source>Do not warn if a priority from 0 to 100 is used for constructor or destructor. The use of constructor and destructor attributes allow you to assign a priority to the constructor/destructor to control its order of execution before &lt;code&gt;main&lt;/code&gt; is called or after it returns. The priority values must be greater than 100 as the compiler reserves priority values between 0&amp;ndash;100 for the implementation.</source>
          <target state="translated">생성자 또는 소멸자에 0-100의 우선 순위가 사용되는 경우 경고하지 마십시오. 생성자 및 소멸자 속성을 사용하면 생성자 / 소멸자에 우선 순위를 지정하여 &lt;code&gt;main&lt;/code&gt; 이 호출 되기 전 또는 반환 된 후에 실행 순서를 제어 할 수 있습니다. 컴파일러가 구현을 위해 0-100 사이의 우선 순위 값을 예약하므로 우선 순위 값은 100보다 커야합니다.</target>
        </trans-unit>
        <trans-unit id="732973795e8a7e32daa52d09fac5902c9d2be92b" translate="yes" xml:space="preserve">
          <source>Do not warn if a property for an Objective-C object has no assign semantics specified.</source>
          <target state="translated">Objective-C 개체의 속성에 할당 의미 체계가 지정되지 않은 경우 경고하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9a797405ed28a43b7b96611721ab2d6938e13b2f" translate="yes" xml:space="preserve">
          <source>Do not warn if an initialized field with side effects is overridden when using designated initializers (see &lt;a href=&quot;designated-inits#Designated-Inits&quot;&gt;Designated Initializers&lt;/a&gt;). This warning is enabled by default.</source>
          <target state="translated">부작용이 초기화 된 필드가 지정된 이니셜 라이저를 사용하는 경우를 오버라이드 (override)하는 경우 경고하지 마십시오 (참조 &lt;a href=&quot;designated-inits#Designated-Inits&quot;&gt;지정 이니셜을&lt;/a&gt; ). 이 경고는 기본적으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="c5958651457da08de9e91cd3ae0fc547368da59b" translate="yes" xml:space="preserve">
          <source>Do not warn if an unexpected &lt;code&gt;__attribute__&lt;/code&gt; is used, such as unrecognized attributes, function attributes applied to variables, etc. This does not stop errors for incorrect use of supported attributes.</source>
          <target state="translated">인식 할 수없는 속성, 변수에 적용된 함수 속성 등과 같이 예기치 않은 &lt;code&gt;__attribute__&lt;/code&gt; 가 사용 된 경우 경고하지 마십시오 . 지원되는 속성을 잘못 사용하더라도 오류가 중지되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="776e98d1dffbde23efe71be5b00aaf8afcebd19f" translate="yes" xml:space="preserve">
          <source>Do not warn if certain built-in macros are redefined. This suppresses warnings for redefinition of &lt;code&gt;__TIMESTAMP__&lt;/code&gt;, &lt;code&gt;__TIME__&lt;/code&gt;, &lt;code&gt;__DATE__&lt;/code&gt;, &lt;code&gt;__FILE__&lt;/code&gt;, and &lt;code&gt;__BASE_FILE__&lt;/code&gt;.</source>
          <target state="translated">특정 내장 매크로가 재정의되면 경고하지 마십시오. 이것은 &lt;code&gt;__TIMESTAMP__&lt;/code&gt; , &lt;code&gt;__TIME__&lt;/code&gt; , &lt;code&gt;__DATE__&lt;/code&gt; , &lt;code&gt;__FILE__&lt;/code&gt; 및 &lt;code&gt;__BASE_FILE__&lt;/code&gt; 의 재정의에 대한 경고를 표시하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a5961961b151110f8171f9f71097fa474a97d41f" translate="yes" xml:space="preserve">
          <source>Do not warn if type qualifiers on arrays which are pointer targets are being discarded. Typically, the compiler warns if a &lt;code&gt;const int (*)[]&lt;/code&gt; variable is passed to a function that takes a &lt;code&gt;int (*)[]&lt;/code&gt; parameter. This option can be used to suppress such a warning.</source>
          <target state="translated">포인터 대상인 배열의 형식 한정자가 삭제되는 경우 경고하지 마십시오. 일반적으로 컴파일러는 &lt;code&gt;const int (*)[]&lt;/code&gt; 변수가 &lt;code&gt;int (*)[]&lt;/code&gt; 매개 변수 를 사용하는 함수에 전달 되는지 경고합니다 . 이 옵션은 이러한 경고를 억제하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f6ac391aa1f66b1759edea5545511d490e350b4" translate="yes" xml:space="preserve">
          <source>Do not warn if type qualifiers on pointers are being discarded. Typically, the compiler warns if a &lt;code&gt;const char *&lt;/code&gt; variable is passed to a function that takes a &lt;code&gt;char *&lt;/code&gt; parameter. This option can be used to suppress such a warning.</source>
          <target state="translated">포인터의 타입 한정자를 버리고 있는지 경고하지 마십시오. 일반적으로 컴파일러에서는 &lt;code&gt;const char *&lt;/code&gt; 변수가 &lt;code&gt;char *&lt;/code&gt; 매개 변수 를 사용하는 함수에 전달 되는지 경고합니다 . 이 옵션은 이러한 경고를 억제하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2237d0ea4af513f919bfca5807318b7adb31ba01" translate="yes" xml:space="preserve">
          <source>Do not warn on suspicious constructs involving reverse scalar storage order.</source>
          <target state="translated">역 스칼라 저장 순서와 관련된 의심스러운 구성에 대해서는 경고하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="dbb582054a4578d09382786263898193b0ff21b0" translate="yes" xml:space="preserve">
          <source>Do not warn upon questionable usage of the macros used to handle variable arguments like &lt;code&gt;va_start&lt;/code&gt;. These warnings are enabled by default.</source>
          <target state="translated">&lt;code&gt;va_start&lt;/code&gt; 와 같은 변수 인수를 처리하는 데 사용되는 매크로의 의심스러운 사용에 대해 경고하지 마십시오 . 이러한 경고는 기본적으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="b084ddd7e0fe08b48906115755ffa4e3da32fe0c" translate="yes" xml:space="preserve">
          <source>Do not warn when HSAIL cannot be emitted for the compiled function or OpenMP construct. These warnings are enabled by default.</source>
          <target state="translated">컴파일 된 함수 또는 OpenMP 구문에 대해 HSAIL을 내보낼 수없는 경우 경고하지 않습니다. 이러한 경고는 기본적으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="7781876bcee57ab05b4c1b6a1db698152f3d5c11" translate="yes" xml:space="preserve">
          <source>Do not warn when a &lt;code&gt;switch&lt;/code&gt; statement contains statements between the controlling expression and the first case label, which will never be executed. For example:</source>
          <target state="translated">&lt;code&gt;switch&lt;/code&gt; 문에 제어 표현식과 첫 번째 case 레이블 사이에 명령문이 포함되어 있을 때 경고하지 마십시오 . 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="28680d2e20ffb7926eea11f38e1b6b85ce89c733" translate="yes" xml:space="preserve">
          <source>Do not warn when a &lt;code&gt;switch&lt;/code&gt; statement has an index of boolean type and the case values are outside the range of a boolean type. It is possible to suppress this warning by casting the controlling expression to a type other than &lt;code&gt;bool&lt;/code&gt;. For example:</source>
          <target state="translated">&lt;code&gt;switch&lt;/code&gt; 문에 부울 유형의 인덱스가 있고 케이스 값이 부울 유형의 범위를 벗어난 경우 경고하지 않습니다 . 제어 표현식을 &lt;code&gt;bool&lt;/code&gt; 이외의 유형으로 캐스트하여이 경고를 억제 할 수 있습니다 . 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="9af5475a41b51138661971a42f878b92d42b232b" translate="yes" xml:space="preserve">
          <source>Do not warn when a conversion function converts an object to the same type, to a base class of that type, or to void; such a conversion function will never be called.</source>
          <target state="translated">변환 함수가 객체를 동일한 유형, 해당 유형의 기본 클래스 또는 void로 변환 할 때 경고하지 마십시오. 이러한 변환 함수는 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="00c13e36c06e819c05d426233228bd8a2938fb6e" translate="yes" xml:space="preserve">
          <source>Do not warn when a string or character literal is followed by a ud-suffix which does not begin with an underscore. As a conforming extension, GCC treats such suffixes as separate preprocessing tokens in order to maintain backwards compatibility with code that uses formatting macros from &lt;code&gt;&amp;lt;inttypes.h&amp;gt;&lt;/code&gt;. For example:</source>
          <target state="translated">문자열 또는 문자 리터럴 뒤에 밑줄로 시작하지 않는 ud-suffix가 올 때 경고하지 마십시오. 적합한 확장으로서 GCC는 &lt;code&gt;&amp;lt;inttypes.h&amp;gt;&lt;/code&gt; 의 형식화 매크로를 사용하는 코드와의 하위 호환성을 유지하기 위해 이러한 접미사를 별도의 전처리 토큰으로 취급합니다 . 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="505f6f0a22dd44c4b12ed8d2e6a399fe3806c159" translate="yes" xml:space="preserve">
          <source>Do not warn when attempting to free an object that was not allocated on the heap.</source>
          <target state="translated">힙에 할당되지 않은 오브젝트를 해제하려고 할 때 경고하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="0eea2eb346314f258d9bd4887c4a7d0ac495ba36" translate="yes" xml:space="preserve">
          <source>Do not warn when deleting a pointer to incomplete type, which may cause undefined behavior at runtime. This warning is enabled by default.</source>
          <target state="translated">불완전한 유형에 대한 포인터를 삭제할 때 경고하지 마십시오. 런타임에 정의되지 않은 동작이 발생할 수 있습니다. 이 경고는 기본적으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="94889f68926578d446953d9dc1636114cf6715d6" translate="yes" xml:space="preserve">
          <source>Do not warn when the &lt;code&gt;sizeof&lt;/code&gt; operator is applied to a parameter that is declared as an array in a function definition. This warning is enabled by default for C and C++ programs.</source>
          <target state="translated">함수 정의에서 배열로 선언 된 매개 변수에 &lt;code&gt;sizeof&lt;/code&gt; 연산자가 적용될 때 경고하지 않습니다 . 이 경고는 C 및 C ++ 프로그램에 대해 기본적으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="d665894bec0cb8c7c615758edc8127e2b609bfec" translate="yes" xml:space="preserve">
          <source>Do not warn when the address of packed member of struct or union is taken, which usually results in an unaligned pointer value. This is enabled by default.</source>
          <target state="translated">일반적으로 정렬되지 않은 포인터 값이 발생하는 struct 또는 union의 패킹 된 멤버 주소를 사용할 때 경고하지 마십시오. 이것은 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b41e5f71b800c0d75e8bc4c789587d50634e7b35" translate="yes" xml:space="preserve">
          <source>Do not warn when there is a conversion between pointers that have incompatible types. This warning is for cases not covered by</source>
          <target state="translated">호환되지 않는 유형을 가진 포인터 사이에 변환이있을 때 경고하지 마십시오. 이 경고는</target>
        </trans-unit>
        <trans-unit id="7288e67492dfae2c91a3de07cd384be7cd59dcec" translate="yes" xml:space="preserve">
          <source>Do not warn whenever a local variable shadows an instance variable in an Objective-C method.</source>
          <target state="translated">Objective-C 메소드에서 로컬 변수가 인스턴스 변수를 가리게 될 때마다 경고하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="a828e7021a3bac6b8a79dcdabca3402745cfbb45" translate="yes" xml:space="preserve">
          <source>Do not warn whenever an &lt;code&gt;#else&lt;/code&gt; or an &lt;code&gt;#endif&lt;/code&gt; are followed by text. This sometimes happens in older programs with code of the form</source>
          <target state="translated">&lt;code&gt;#else&lt;/code&gt; 또는 &lt;code&gt;#endif&lt;/code&gt; 뒤에 텍스트가 올 때마다 경고하지 마십시오 . 이것은 때때로 코드 형식의 구형 프로그램에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="12e3a14254e97e0a14b8cdd90a112ee9ef9f78f5" translate="yes" xml:space="preserve">
          <source>Do nothing. Code written for the Borland model works fine, but each translation unit contains instances of each of the templates it uses. The duplicate instances will be discarded by the linker, but in a large program, this can lead to an unacceptable amount of code duplication in object files or shared libraries.</source>
          <target state="translated">아무것도하지 마세요. Borland 모델 용으로 작성된 코드는 잘 작동하지만 각 번역 단위에는 사용하는 각 템플릿의 인스턴스가 포함됩니다. 중복 인스턴스는 링커에 의해 삭제되지만 큰 프로그램에서는 개체 파일 또는 공유 라이브러리에서 허용되지 않는 양의 코드 복제가 발생할 수 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
