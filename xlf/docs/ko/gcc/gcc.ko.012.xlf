<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="gcc">
    <body>
      <group id="gcc">
        <trans-unit id="21c7fe9d52d84289272bf156d75da1baf041f576" translate="yes" xml:space="preserve">
          <source>Since G++ now defaults to updating the ABI with each major release, normally</source>
          <target state="translated">G ++는 이제 기본적으로 각 주요 릴리스로 ABI를 업데이트하므로 일반적으로</target>
        </trans-unit>
        <trans-unit id="f22660df453a96c806164b9cde945b16ac8135b9" translate="yes" xml:space="preserve">
          <source>Since GCC does not parse the assembler template, it has no visibility of any symbols it references. This may result in GCC discarding those symbols as unreferenced unless they are also listed as input, output, or goto operands.</source>
          <target state="translated">GCC는 어셈블러 템플릿을 구문 분석하지 않으므로 참조하는 심볼을 볼 수 없습니다. 따라서 입력, 출력 또는 이동 피연산자로 나열되지 않으면 GCC에서 해당 심볼을 참조되지 않은 것으로 버릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b000a8b411ebdceb551939a35ee69b160bbe25b6" translate="yes" xml:space="preserve">
          <source>Since ISO C99 defines this function in terms of &lt;code&gt;strtod&lt;/code&gt;, which we do not implement, a description of the parsing is in order. The string is parsed as by &lt;code&gt;strtol&lt;/code&gt;; that is, the base is recognized by leading &amp;lsquo;</source>
          <target state="translated">ISO C99는이 기능 을 우리가 구현하지 않은 &lt;code&gt;strtod&lt;/code&gt; 로 정의하므로 구문 분석에 대한 설명이 순서대로 이루어집니다. 문자열은 &lt;code&gt;strtol&lt;/code&gt; 에 의해 구문 분석됩니다 . 즉, 기본은 '</target>
        </trans-unit>
        <trans-unit id="892917377ab8c3ffb653fb42e72d9ed1bdd00343" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;__builtin_alloca&lt;/code&gt; function doesn&amp;rsquo;t validate its argument it is the responsibility of its caller to make sure the argument doesn&amp;rsquo;t cause it to exceed the stack size limit. The &lt;code&gt;__builtin_alloca&lt;/code&gt; function is provided to make it possible to allocate on the stack arrays of bytes with an upper bound that may be computed at run time. Since C99 Variable Length Arrays offer similar functionality under a portable, more convenient, and safer interface they are recommended instead, in both C99 and C++ programs where GCC provides them as an extension. See &lt;a href=&quot;variable-length#Variable-Length&quot;&gt;Variable Length&lt;/a&gt;, for details.</source>
          <target state="translated">이후 &lt;code&gt;__builtin_alloca&lt;/code&gt; 의 기능은 인수를 확인하지 않습니다이 만드는 호출자의 책임입니다 확인 인수는 스택의 크기 제한을 초과 할 수 없습니다. &lt;code&gt;__builtin_alloca&lt;/code&gt; 의 기능이 가능 상부가 런타임에 계산 될 수 있다는 결합하여 바이트 스택 어레이에 할당 할 수 있도록 제공된다. C99 가변 길이 어레이는 이식 가능하고 더 편리하며 안전한 인터페이스 하에서 유사한 기능을 제공하므로 GCC가 확장으로 제공하는 C99 및 C ++ 프로그램 모두에서 대신 권장됩니다. 자세한 내용은 &lt;a href=&quot;variable-length#Variable-Length&quot;&gt;가변 길이&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4baf9c380b14381cf54e66f25724ec841c6dbbc1" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;__builtin_alloca_with_align&lt;/code&gt; function doesn&amp;rsquo;t validate its &lt;var&gt;size&lt;/var&gt; argument it is the responsibility of its caller to make sure the argument doesn&amp;rsquo;t cause it to exceed the stack size limit. The &lt;code&gt;__builtin_alloca_with_align&lt;/code&gt; function is provided to make it possible to allocate on the stack overaligned arrays of bytes with an upper bound that may be computed at run time. Since C99 Variable Length Arrays offer the same functionality under a portable, more convenient, and safer interface they are recommended instead, in both C99 and C++ programs where GCC provides them as an extension. See &lt;a href=&quot;variable-length#Variable-Length&quot;&gt;Variable Length&lt;/a&gt;, for details.</source>
          <target state="translated">이후 &lt;code&gt;__builtin_alloca_with_align&lt;/code&gt; 기능의 유효성을 검사하지 않는 &lt;var&gt;size&lt;/var&gt; 인수를가 만드는 호출자의 책임입니다 확인 인수는 스택의 크기 제한을 초과 할 수 없습니다. &lt;code&gt;__builtin_alloca_with_align&lt;/code&gt; 기능 가능 상부가 런타임에 계산 될 수 있다는 결합하여 바이트 overaligned 스택 어레이에 할당 할 수 있도록 제공된다. C99 가변 길이 어레이는 이식 가능하고 편리하며 안전한 인터페이스 하에서 동일한 기능을 제공하므로 GCC가 확장으로 제공하는 C99 및 C ++ 프로그램 모두에서 대신 권장됩니다. 자세한 내용은 &lt;a href=&quot;variable-length#Variable-Length&quot;&gt;가변 길이&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0258c9861f729a6d6a1e77969495b52ec885eef9" translate="yes" xml:space="preserve">
          <source>Since the two variable &lt;code&gt;i&lt;/code&gt; in the example above have incompatible types, enabling only</source>
          <target state="translated">위의 예제에서 두 변수 &lt;code&gt;i&lt;/code&gt; 는 호환되지 않는 유형을 가지고 있기 때문에</target>
        </trans-unit>
        <trans-unit id="d388c0730bf40209b77631102dd7aa30902cc328" translate="yes" xml:space="preserve">
          <source>Since there are occasions where a switch case fall through is desirable, GCC provides an attribute, &lt;code&gt;__attribute__ ((fallthrough))&lt;/code&gt;, that is to be used along with a null statement to suppress this warning that would normally occur:</source>
          <target state="translated">전환 사례가 필요한 경우가 있으므로 GCC는 &lt;code&gt;__attribute__ ((fallthrough))&lt;/code&gt; 속성을 제공합니다.이 속성 은 일반적으로 발생하는이 경고를 억제하기 위해 null 문과 함께 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9d33bdb0c97347197e4dad14823945cd2f7cbcbd" translate="yes" xml:space="preserve">
          <source>Single functions can be exempted from inlining by marking them with the &lt;code&gt;noinline&lt;/code&gt; attribute.</source>
          <target state="translated">&lt;code&gt;noinline&lt;/code&gt; 속성을 사용하여 단일 함수를 인라인에서 제외 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e677e33f125717883b72d6689c2a09bd6ab65171" translate="yes" xml:space="preserve">
          <source>Single-precision floating point:</source>
          <target state="translated">단 정밀도 부동 소수점 :</target>
        </trans-unit>
        <trans-unit id="76bd493ed8bb81652313a482dd8f8e1005d241c8" translate="yes" xml:space="preserve">
          <source>Size of max partition for WHOPR (in estimated instructions). to provide an upper bound for individual size of partition. Meant to be used only with balanced partitioning.</source>
          <target state="translated">WHOPR의 최대 파티션 크기 (예상 지침). 개별 파티션 크기에 대한 상한을 제공합니다. 균형 잡힌 파티셔닝과 함께 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="e240bffdb5210e2a9fb3c1ceaef0728216aabbc4" translate="yes" xml:space="preserve">
          <source>Size of minimal partition for WHOPR (in estimated instructions). This prevents expenses of splitting very small programs into too many partitions.</source>
          <target state="translated">WHOPR의 최소 파티션 크기 (예상 지침). 이것은 아주 작은 프로그램을 너무 많은 파티션으로 나누는 비용을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="feac389ca59136d24edc664765fb58951d1a7cbe" translate="yes" xml:space="preserve">
          <source>Slightly looser rules for escaped newlines.</source>
          <target state="translated">탈출 줄 바꿈에 대한 규칙이 약간 느슨합니다.</target>
        </trans-unit>
        <trans-unit id="6ae97113b3cf739a346d55e68c010f462fdbf99d" translate="yes" xml:space="preserve">
          <source>Small integer constants can use a shared data structure, reducing the compiler&amp;rsquo;s memory usage and increasing its speed. This sets the maximum value of a shared integer constant.</source>
          <target state="translated">작은 정수 상수는 공유 데이터 구조를 사용하여 컴파일러의 메모리 사용량을 줄이고 속도를 높일 수 있습니다. 공유 정수 상수의 최대 값을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="3c352006f28e617e3092550875bb98a37c3e499d" translate="yes" xml:space="preserve">
          <source>Small model objects live in the lower 16MB of memory (so that their addresses can be loaded with the &lt;code&gt;ld24&lt;/code&gt; instruction), and are callable with the &lt;code&gt;bl&lt;/code&gt; instruction.</source>
          <target state="translated">작은 모델 객체는 16MB 이하의 메모리에 &lt;code&gt;ld24&lt;/code&gt; 하며 ( ld24 명령어로 주소를로드 할 수 있음 ) &lt;code&gt;bl&lt;/code&gt; 명령어 로 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a3714fde637fe384ead8d5eb02c1a4c25f02d146" translate="yes" xml:space="preserve">
          <source>Small model objects live in the lower 16MB of memory (so that their addresses can be loaded with the &lt;code&gt;ld24&lt;/code&gt; instruction).</source>
          <target state="translated">작은 모델 객체는 16MB 이하의 메모리에 저장되므로 해당 주소를 &lt;code&gt;ld24&lt;/code&gt; 명령어 로로드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="87cc781515efd4b579bb2ce6bb66d4b4e6b7b78a" translate="yes" xml:space="preserve">
          <source>So the first alternative for the 68000&amp;rsquo;s logical-or could be written as &lt;code&gt;&quot;+m&quot; (output) : &quot;ir&quot; (input)&lt;/code&gt;. The second could be &lt;code&gt;&quot;+r&quot; 
(output): &quot;irm&quot; (input)&lt;/code&gt;. However, the fact that two memory locations cannot be used in a single instruction prevents simply using &lt;code&gt;&quot;+rm&quot; 
(output) : &quot;irm&quot; (input)&lt;/code&gt;. Using multi-alternatives, this might be written as &lt;code&gt;&quot;+m,r&quot; (output) : &quot;ir,irm&quot; (input)&lt;/code&gt;. This describes all the available alternatives to the compiler, allowing it to choose the most efficient one for the current conditions.</source>
          <target state="translated">따라서 68000 논리 또는 논리에 대한 첫 번째 대안은 &lt;code&gt;&quot;+m&quot; (output) : &quot;ir&quot; (input)&lt;/code&gt; 로 쓸 수 있습니다 . 두 번째는 &lt;code&gt;&quot;+r&quot; (output): &quot;irm&quot; (input)&lt;/code&gt; 있습니다. 그러나 단일 명령어에서 두 개의 메모리 위치를 사용할 수 없다는 사실은 단순히 &lt;code&gt;&quot;+rm&quot; (output) : &quot;irm&quot; (input)&lt;/code&gt; 사용하지 못하게 합니다. 다중 대체를 사용하면 &lt;code&gt;&quot;+m,r&quot; (output) : &quot;ir,irm&quot; (input)&lt;/code&gt; 으로 쓸 수 있습니다 . 여기에는 컴파일러에 대해 사용 가능한 모든 대안이 설명되어있어 현재 조건에 가장 효율적인 대안을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3274a855ec94ec43ea5e4111fdadde792b5b93db" translate="yes" xml:space="preserve">
          <source>So, for example,</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="059987d18facbbac8112608278433db26ec67739" translate="yes" xml:space="preserve">
          <source>Software developers also use coverage testing in concert with testsuites, to make sure software is actually good enough for a release. Testsuites can verify that a program works as expected; a coverage program tests to see how much of the program is exercised by the testsuite. Developers can then determine what kinds of test cases need to be added to the testsuites to create both better testing and a better final product.</source>
          <target state="translated">소프트웨어 개발자는 테스트 슈트와 함께 커버리지 테스트를 사용하여 소프트웨어가 실제로 릴리스에 충분한 지 확인합니다. 응시자는 프로그램이 예상대로 작동하는지 확인할 수 있습니다. 커버리지 프로그램은 테스트 스위트가 얼마나 많은 프로그램을 실행하는지 확인합니다. 그런 다음 개발자는 테스트 슈트에 어떤 종류의 테스트 사례를 추가하여 더 나은 테스트와 더 나은 최종 제품을 만들지 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fb15357d03c25c5a9704aae9669697852ee9b79" translate="yes" xml:space="preserve">
          <source>Solaris targets support the &lt;code&gt;cmn_err&lt;/code&gt; (or &lt;code&gt;__cmn_err__&lt;/code&gt;) format check. &lt;code&gt;cmn_err&lt;/code&gt; accepts a subset of the standard &lt;code&gt;printf&lt;/code&gt; conversions, and the two-argument &lt;code&gt;%b&lt;/code&gt; conversion for displaying bit-fields. See the Solaris man page for &lt;code&gt;cmn_err&lt;/code&gt; for more information.</source>
          <target state="translated">Solaris 대상은 &lt;code&gt;cmn_err&lt;/code&gt; (또는 &lt;code&gt;__cmn_err__&lt;/code&gt; ) 형식 확인을 지원합니다 . &lt;code&gt;cmn_err&lt;/code&gt; 는 표준 &lt;code&gt;printf&lt;/code&gt; 변환 의 서브 세트 와 비트 필드를 표시하기위한 두 개의 인수 &lt;code&gt;%b&lt;/code&gt; 변환을 허용합니다. 자세한 내용은 &lt;code&gt;cmn_err&lt;/code&gt; 에 대한 Solaris 매뉴얼 페이지 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="00b2aad45d07b70e1b7eefea74316913901b6e42" translate="yes" xml:space="preserve">
          <source>Some</source>
          <target state="translated">Some</target>
        </trans-unit>
        <trans-unit id="50992012bdba46e4be18c1991255dee68fa34161" translate="yes" xml:space="preserve">
          <source>Some 387 emulators do not support the &lt;code&gt;sin&lt;/code&gt;, &lt;code&gt;cos&lt;/code&gt; and &lt;code&gt;sqrt&lt;/code&gt; instructions for the 387. Specify this option to avoid generating those instructions. This option is overridden when</source>
          <target state="translated">일부 387 에뮬레이터는 387에 대한 &lt;code&gt;sin&lt;/code&gt; , &lt;code&gt;cos&lt;/code&gt; 및 &lt;code&gt;sqrt&lt;/code&gt; 명령어를 지원하지 않습니다 . 이러한 명령어가 생성되지 않도록하려면이 옵션을 지정하십시오. 이 옵션은 다음과 같은 경우 재정의됩니다.</target>
        </trans-unit>
        <trans-unit id="e8e19b82266af7db1443a3fea1acad2ebf9ad814" translate="yes" xml:space="preserve">
          <source>Some &lt;code&gt;asm&lt;/code&gt; statements may need extra stack space for internal calculations. This can be guaranteed by clobbering stack registers unrelated to the inputs and outputs.</source>
          <target state="translated">일부 &lt;code&gt;asm&lt;/code&gt; 문은 내부 계산을 위해 추가 스택 공간이 필요할 수 있습니다. 이는 입력 및 출력과 관련이없는 스택 레지스터를 클로버 링하여 보장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9932d75815f4a1da8b9c3167803247d114d4d3e" translate="yes" xml:space="preserve">
          <source>Some AVR devices (AT90S8515, ATmega103) must not skip 32-bit instructions because of a hardware erratum. Skip instructions are &lt;code&gt;SBRS&lt;/code&gt;, &lt;code&gt;SBRC&lt;/code&gt;, &lt;code&gt;SBIS&lt;/code&gt;, &lt;code&gt;SBIC&lt;/code&gt; and &lt;code&gt;CPSE&lt;/code&gt;. The second macro is only defined if &lt;code&gt;__AVR_HAVE_JMP_CALL__&lt;/code&gt; is also set.</source>
          <target state="translated">일부 AVR 장치 (AT90S8515, ATmega103)는 하드웨어 오류 때문에 32 비트 명령어를 건너 뛰지 않아야합니다. 건너 뛰기 명령어는 &lt;code&gt;SBRS&lt;/code&gt; , &lt;code&gt;SBRC&lt;/code&gt; , &lt;code&gt;SBIS&lt;/code&gt; , &lt;code&gt;SBIC&lt;/code&gt; 및 &lt;code&gt;CPSE&lt;/code&gt; 입니다. 두 번째 매크로는 &lt;code&gt;__AVR_HAVE_JMP_CALL__&lt;/code&gt; 도 설정 한 경우에만 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="b8587f1a252be44a26b4bf83b41b8cacfabe3c53" translate="yes" xml:space="preserve">
          <source>Some AVR devices support memories larger than the 64 KiB range that can be accessed with 16-bit pointers. To access memory locations outside this 64 KiB range, the content of a &lt;code&gt;RAMP&lt;/code&gt; register is used as high part of the address: The &lt;code&gt;X&lt;/code&gt;, &lt;code&gt;Y&lt;/code&gt;, &lt;code&gt;Z&lt;/code&gt; address register is concatenated with the &lt;code&gt;RAMPX&lt;/code&gt;, &lt;code&gt;RAMPY&lt;/code&gt;, &lt;code&gt;RAMPZ&lt;/code&gt; special function register, respectively, to get a wide address. Similarly, &lt;code&gt;RAMPD&lt;/code&gt; is used together with direct addressing.</source>
          <target state="translated">일부 AVR 장치는 16 비트 포인터로 액세스 할 수있는 64 KiB 범위보다 큰 메모리를 지원합니다. 이 64 KiB 범위 밖의 메모리 위치에 액세스하기 위해 &lt;code&gt;RAMP&lt;/code&gt; 레지스터 의 내용이 주소의 높은 부분으로 사용됩니다. &lt;code&gt;X&lt;/code&gt; , &lt;code&gt;Y&lt;/code&gt; , &lt;code&gt;Z&lt;/code&gt; 주소 레지스터는 각각 &lt;code&gt;RAMPX&lt;/code&gt; , &lt;code&gt;RAMPY&lt;/code&gt; , &lt;code&gt;RAMPZ&lt;/code&gt; 특수 기능 레지스터와 연결되어 있습니다. 넓은 주소. 마찬가지로 &lt;code&gt;RAMPD&lt;/code&gt; 는 직접 주소 지정과 함께 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b652248718bfad5072f0c61fa63785c614519d9b" translate="yes" xml:space="preserve">
          <source>Some Cortex-M3 cores can cause data corruption when &lt;code&gt;ldrd&lt;/code&gt; instructions with overlapping destination and base registers are used. This option avoids generating these instructions. This option is enabled by default when</source>
          <target state="translated">대상과 기준 레지스터가 겹치는 &lt;code&gt;ldrd&lt;/code&gt; 명령어를 사용 하면 일부 Cortex-M3 코어가 데이터 손상을 일으킬 수 있습니다 . 이 옵션은 이러한 명령어 생성을 피합니다. 이 옵션은 기본적으로 활성화되어 있습니다</target>
        </trans-unit>
        <trans-unit id="de0fd695fef81a6e3c397b49019c4e2e00e1f0cc" translate="yes" xml:space="preserve">
          <source>Some GCC compilation options cause the compiler to generate code that does not conform to the platform&amp;rsquo;s default ABI. Other options cause different program behavior for implementation-defined features that are not covered by an ABI. These options are provided for consistency with other compilers that do not follow the platform&amp;rsquo;s default ABI or the usual behavior of implementation-defined features for the platform. Be very careful about using such options.</source>
          <target state="translated">일부 GCC 컴파일 옵션으로 인해 컴파일러는 플랫폼의 기본 ABI를 준수하지 않는 코드를 생성합니다. 다른 옵션은 ABI에서 다루지 않는 구현 정의 기능에 대해 다른 프로그램 동작을 유발합니다. 이러한 옵션은 플랫폼의 기본 ABI 또는 플랫폼에 대한 구현 정의 기능의 일반적인 동작을 따르지 않는 다른 컴파일러와의 일관성을 위해 제공됩니다. 이러한 옵션 사용에 매우주의하십시오.</target>
        </trans-unit>
        <trans-unit id="0325ca2d082f6bb9f5d1e5e855cb8121b2560adb" translate="yes" xml:space="preserve">
          <source>Some ISO C testsuites report failure when the compiler does not produce an error message for a certain program.</source>
          <target state="translated">컴파일러가 특정 프로그램에 대해 오류 메시지를 생성하지 않으면 일부 ISO C 테스트 스위트에서 오류가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="84f1bb1b30ec55b3fd5d6eb1c7f6faa03400485d" translate="yes" xml:space="preserve">
          <source>Some additional environment variables affect the behavior of the preprocessor.</source>
          <target state="translated">일부 추가 환경 변수는 전 처리기의 동작에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="5045e735a2d8c7129e122a97ea30410aa9319aed" translate="yes" xml:space="preserve">
          <source>Some assemblers only support this flag when &lt;var&gt;n&lt;/var&gt; is a power of two; in that case, it is rounded up.</source>
          <target state="translated">일부 어셈블러 는 &lt;var&gt;n&lt;/var&gt; 이 2의 거듭 제곱 일 때만이 플래그를 지원합니다 . 이 경우 반올림됩니다.</target>
        </trans-unit>
        <trans-unit id="2ceba313d16765bb5b6ec17c1ebb8d3d9c14df42" translate="yes" xml:space="preserve">
          <source>Some attributes only make sense for C++ programs.</source>
          <target state="translated">일부 속성은 C ++ 프로그램에만 적합합니다.</target>
        </trans-unit>
        <trans-unit id="81c2a3663ddcd2a93314c07f339088b18a9513ff" translate="yes" xml:space="preserve">
          <source>Some cases of unnamed fields in structures and unions are only accepted with this option. See &lt;a href=&quot;unnamed-fields#Unnamed-Fields&quot;&gt;Unnamed struct/union fields within structs/unions&lt;/a&gt;, for details.</source>
          <target state="translated">구조 및 공용체에서 이름없는 필드의 일부 경우는이 옵션으로 만 허용됩니다. 자세한 내용 &lt;a href=&quot;unnamed-fields#Unnamed-Fields&quot;&gt;은 structs / unions 내의 Unnamed struct / union 필드&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="15750fff39388c96e233f1fff7614239f8996f69" translate="yes" xml:space="preserve">
          <source>Some characters in ISO 10646 have distinct meanings but look identical in some fonts or display methodologies, especially once formatting has been applied. For instance &lt;code&gt;\u207F&lt;/code&gt;, &amp;ldquo;SUPERSCRIPT LATIN SMALL LETTER N&amp;rdquo;, displays just like a regular &lt;code&gt;n&lt;/code&gt; that has been placed in a superscript. ISO 10646 defines the &lt;em&gt;NFKC&lt;/em&gt; normalization scheme to convert all these into a standard form as well, and GCC warns if your code is not in NFKC if you use</source>
          <target state="translated">ISO 10646의 일부 문자는 고유 한 의미를 갖지만 서식이 적용된 후 일부 글꼴 또는 표시 방법에서는 동일하게 보입니다. 예를 들어 &lt;code&gt;\u207F&lt;/code&gt; &quot;SUPERSCRIPT LATIN SMALL LETTER N&quot; 은 위첨자에 배치 된 일반 &lt;code&gt;n&lt;/code&gt; 과 같이 표시됩니다 . ISO 10646은 &lt;em&gt;NFKC&lt;/em&gt; 정규화 체계를 정의 &lt;em&gt;하여이&lt;/em&gt; 모든 것을 표준 형식으로 변환하고, 사용하는 경우 코드가 NFKC에 없으면 GCC에서 경고합니다</target>
        </trans-unit>
        <trans-unit id="5d2e5736cfa0533f11cc548a18ee8de7127f23cf" translate="yes" xml:space="preserve">
          <source>Some checkers are disabled by default (even with</source>
          <target state="translated">일부 체커는 기본적으로 비활성화되어 있습니다 (</target>
        </trans-unit>
        <trans-unit id="06da659fa22deee4cc3d56729c6b4abce7edba00" translate="yes" xml:space="preserve">
          <source>Some choices depend on the externally determined ABI for the platform (including standard character encodings) which GCC follows; these are listed as &amp;ldquo;determined by ABI&amp;rdquo; below. See &lt;a href=&quot;compatibility#Compatibility&quot;&gt;Binary Compatibility&lt;/a&gt;, and &lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;http://gcc.gnu.org/readings.html&lt;/a&gt;. Some choices are documented in the preprocessor manual. See &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Implementation_002ddefined-behavior.html#Implementation_002ddefined-behavior&quot;&gt;Implementation-defined behavior&lt;/a&gt; in The C Preprocessor. Some choices are documented in the corresponding document for the C language. See &lt;a href=&quot;c-implementation#C-Implementation&quot;&gt;C Implementation&lt;/a&gt;. Some choices are made by the library and operating system (or other environment when compiling for a freestanding environment); refer to their documentation for details.</source>
          <target state="translated">일부 선택은 GCC가 따르는 플랫폼 (표준 문자 인코딩 포함)에 대해 외부에서 결정된 ABI에 따라 다릅니다. 이들은 아래 &quot;ABI에서 결정&quot;으로 표시됩니다. 참조 &lt;a href=&quot;compatibility#Compatibility&quot;&gt;이진 호환성&lt;/a&gt; 및 &lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;http://gcc.gnu.org/readings.html&lt;/a&gt; . 일부 선택 사항은 전 처리기 매뉴얼에 설명되어 있습니다. C 프리 프로세서의 &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Implementation_002ddefined-behavior.html#Implementation_002ddefined-behavior&quot;&gt;구현 정의 동작&lt;/a&gt; 을 참조하십시오 . 일부 선택 사항은 C 언어에 해당하는 문서에 문서화되어 있습니다. &lt;a href=&quot;c-implementation#C-Implementation&quot;&gt;C 구현을&lt;/a&gt; 참조하십시오 . 라이브러리와 운영 체제 (또는 독립 환경을 위해 컴파일 할 때 다른 환경)가 일부를 선택합니다. 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="258878cc764e88fa980c6c9ddf4a6f80e9d5cd8f" translate="yes" xml:space="preserve">
          <source>Some choices depend on the externally determined ABI for the platform (including standard character encodings) which GCC follows; these are listed as &amp;ldquo;determined by ABI&amp;rdquo; below. See &lt;a href=&quot;compatibility#Compatibility&quot;&gt;Binary Compatibility&lt;/a&gt;, and &lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;http://gcc.gnu.org/readings.html&lt;/a&gt;. Some choices are documented in the preprocessor manual. See &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Implementation_002ddefined-behavior.html#Implementation_002ddefined-behavior&quot;&gt;Implementation-defined behavior&lt;/a&gt; in The C Preprocessor. Some choices are made by the library and operating system (or other environment when compiling for a freestanding environment); refer to their documentation for details.</source>
          <target state="translated">일부 선택은 GCC가 따르는 플랫폼 (표준 문자 인코딩 포함)에 대해 외부에서 결정된 ABI에 따라 다릅니다. 이들은 아래 &quot;ABI에서 결정&quot;으로 표시됩니다. 참조 &lt;a href=&quot;compatibility#Compatibility&quot;&gt;이진 호환성&lt;/a&gt; 및 &lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;http://gcc.gnu.org/readings.html&lt;/a&gt; . 일부 선택 사항은 전 처리기 매뉴얼에 설명되어 있습니다. C 프리 프로세서의 &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Implementation_002ddefined-behavior.html#Implementation_002ddefined-behavior&quot;&gt;구현 정의 동작&lt;/a&gt; 을 참조하십시오 . 라이브러리와 운영 체제 (또는 독립 환경을 위해 컴파일 할 때 다른 환경)가 일부를 선택합니다. 자세한 내용은 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="afb5cf203b032f066b2dfc525a737fb2a1d04d8b" translate="yes" xml:space="preserve">
          <source>Some choices depend on the externally determined ABI for the platform (including standard character encodings) which GCC follows; these are listed as &amp;ldquo;determined by ABI&amp;rdquo; below. See &lt;a href=&quot;compatibility#Compatibility&quot;&gt;Binary Compatibility&lt;/a&gt;, and &lt;a href=&quot;https://gcc.gnu.org/readings.html&quot;&gt;http://gcc.gnu.org/readings.html&lt;/a&gt;. Some choices are documented in the preprocessor manual. See &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/cpp/Implementation_002ddefined-behavior.html#Implementation_002ddefined-behavior&quot;&gt;Implementation-defined behavior&lt;/a&gt; in The C Preprocessor. Some choices are documented in the corresponding document for the C language. See &lt;a href=&quot;c-implementation#C-Implementation&quot;&gt;C Implementation&lt;/a&gt;. Some choices are made by the library and operating system (or other environment when compiling for a freestanding environment); refer to their documentation for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de8c383a4d14bd786f9c38989c42c2d66e840bf7" translate="yes" xml:space="preserve">
          <source>Some choices depend on the externally determined ABI for the platform (including standard character encodings) which GCC follows; these are listed as &amp;ldquo;determined by ABI&amp;rdquo; below. See &lt;a href=&quot;compatibility#Compatibility&quot;&gt;Binary Compatibility&lt;/a&gt;, and &lt;a href=&quot;https://gcc.gnu.org/readings.html&quot;&gt;http://gcc.gnu.org/readings.html&lt;/a&gt;. Some choices are documented in the preprocessor manual. See &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/cpp/Implementation_002ddefined-behavior.html#Implementation_002ddefined-behavior&quot;&gt;Implementation-defined behavior&lt;/a&gt; in The C Preprocessor. Some choices are made by the library and operating system (or other environment when compiling for a freestanding environment); refer to their documentation for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15506c8b8d5d6b275040aeee640a2a5a3f7d4d37" translate="yes" xml:space="preserve">
          <source>Some common examples of pure functions are &lt;code&gt;strlen&lt;/code&gt; or &lt;code&gt;memcmp&lt;/code&gt;. Interesting non-pure functions are functions with infinite loops or those depending on volatile memory or other system resource, that may change between consecutive calls (such as the standard C &lt;code&gt;feof&lt;/code&gt; function in a multithreading environment).</source>
          <target state="translated">순수한 함수의 일반적인 예는 &lt;code&gt;strlen&lt;/code&gt; 또는 &lt;code&gt;memcmp&lt;/code&gt; 입니다. 흥미 비 순수 함수 (예컨대 표준 C와 같은 연속 호출간에 변경 될 무한 루프 또는 휘발성 메모리 또는 다른 시스템 리소스에 따라 그와 함수이다 &lt;code&gt;feof&lt;/code&gt; 멀티 스레딩 환경의 작용).</target>
        </trans-unit>
        <trans-unit id="12ce1dfd34507685834493a64bea0bb0f207ab99" translate="yes" xml:space="preserve">
          <source>Some computer manufacturers have published Application Binary Interface standards which specify that plain bit-fields should be unsigned. It is a mistake, however, to say anything about this issue in an ABI. This is because the handling of plain bit-fields distinguishes two dialects of C. Both dialects are meaningful on every type of machine. Whether a particular object file was compiled using signed bit-fields or unsigned is of no concern to other object files, even if they access the same bit-fields in the same data structures.</source>
          <target state="translated">일부 컴퓨터 제조업체는 일반 비트 필드를 서명하지 않도록 지정하는 Application Binary Interface 표준을 발표했습니다. 그러나 ABI에서이 문제에 대해 언급하는 것은 실수입니다. 일반 비트 필드의 처리는 C의 두 가지 방언을 구별하기 때문입니다. 두 방언은 모든 유형의 기계에서 의미가 있습니다. 특정 객체 파일이 부호있는 비트 필드를 사용하여 컴파일되었는지 또는 부호 없는지 여부는 동일한 데이터 구조에서 동일한 비트 필드에 액세스하더라도 다른 객체 파일과 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="71e1ac9ab0109c68aee90fe9c98e8024ac2ba20a" translate="yes" xml:space="preserve">
          <source>Some configurations of the compiler also support additional target-specific options, usually for compatibility with other compilers on the same platform.</source>
          <target state="translated">컴파일러의 일부 구성은 일반적으로 동일한 플랫폼에서 다른 컴파일러와의 호환성을 위해 추가 대상별 옵션을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="efc299e6d6d519531f7a42935a2ff0371856c97e" translate="yes" xml:space="preserve">
          <source>Some developers use Local Register Variables in an attempt to improve gcc&amp;rsquo;s allocation of registers, especially in large functions. In this case the register name is essentially a hint to the register allocator. While in some instances this can generate better code, improvements are subject to the whims of the allocator/optimizers. Since there are no guarantees that your improvements won&amp;rsquo;t be lost, this usage of Local Register Variables is discouraged.</source>
          <target state="translated">일부 개발자는 특히 큰 함수에서 gcc의 레지스터 할당을 개선하기 위해 로컬 레지스터 변수를 사용합니다. 이 경우 레지스터 이름은 기본적으로 레지스터 할당 자에 대한 힌트입니다. 경우에 따라 더 나은 코드를 생성 할 수 있지만 개선 사항은 할당 자 / 최적화 프로그램에 영향을받습니다. 개선 사항이 손실되지 않을 것이라는 보장은 없으므로 이러한 로컬 레지스터 변수 사용은 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cd13c19c4da21f1c5afd2756424c80ed7c852869" translate="yes" xml:space="preserve">
          <source>Some devices support reading from flash memory by means of &lt;code&gt;LD*&lt;/code&gt; instructions. The flash memory is seen in the data address space at an offset of &lt;code&gt;__AVR_PM_BASE_ADDRESS__&lt;/code&gt;. If this macro is not defined, this feature is not available. If defined, the address space is linear and there is no need to put &lt;code&gt;.rodata&lt;/code&gt; into RAM. This is handled by the default linker description file, and is currently available for &lt;code&gt;avrtiny&lt;/code&gt; and &lt;code&gt;avrxmega3&lt;/code&gt;. Even more convenient, there is no need to use address spaces like &lt;code&gt;__flash&lt;/code&gt; or features like attribute &lt;code&gt;progmem&lt;/code&gt; and &lt;code&gt;pgm_read_*&lt;/code&gt;.</source>
          <target state="translated">일부 장치는 &lt;code&gt;LD*&lt;/code&gt; 명령어를 통해 플래시 메모리에서 읽기를 지원 합니다. 플래시 메모리는 &lt;code&gt;__AVR_PM_BASE_ADDRESS__&lt;/code&gt; 의 오프셋에서 데이터 주소 공간에 표시 됩니다. 이 매크로가 정의되어 있지 않으면이 기능을 사용할 수 없습니다. 정의 된 경우 주소 공간은 선형이며 &lt;code&gt;.rodata&lt;/code&gt; 를 RAM 에 넣을 필요가 없습니다 . 이것은 기본 링커 설명 파일에 의해 처리되며 현재 &lt;code&gt;avrtiny&lt;/code&gt; 및 &lt;code&gt;avrxmega3&lt;/code&gt; 에 사용 가능합니다 . 더욱 편리하고, 같은 사용의 주소 공간을 필요가 없습니다 &lt;code&gt;__flash&lt;/code&gt; 속성과 같은 또는 기능 &lt;code&gt;progmem&lt;/code&gt; 및 &lt;code&gt;pgm_read_*&lt;/code&gt; 은 .</target>
        </trans-unit>
        <trans-unit id="12cca45385c65440f1fac5331dbdc800f8010a0a" translate="yes" xml:space="preserve">
          <source>Some features that are in ISO C99 but not C90 or C++ are also, as extensions, accepted by GCC in C90 mode and in C++.</source>
          <target state="translated">ISO C99에는 있지만 C90 또는 C ++에는없는 일부 기능은 확장으로 CCC 모드 및 C ++에서 GCC에 의해 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="768fab3712868916420b11c9d81a46a5d1e9bab0" translate="yes" xml:space="preserve">
          <source>Some file formats do not support arbitrary sections so the &lt;code&gt;section&lt;/code&gt; attribute is not available on all platforms. If you need to map the entire contents of a module to a particular section, consider using the facilities of the linker instead.</source>
          <target state="translated">일부 파일 형식은 임의 섹션을 지원하지 않으므로 모든 플랫폼 에서 &lt;code&gt;section&lt;/code&gt; 속성을 사용할 수 없습니다. 모듈의 전체 내용을 특정 섹션에 매핑해야하는 경우 대신 링커 기능을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="63737560dbee375bb4595f35dcce3b604d447957" translate="yes" xml:space="preserve">
          <source>Some function attributes take one or more arguments that refer to the function&amp;rsquo;s parameters by their positions within the function parameter list. Such attribute arguments are referred to as &lt;em&gt;positional arguments&lt;/em&gt;. Unless specified otherwise, positional arguments that specify properties of parameters with pointer types can also specify the same properties of the implicit C++ &lt;code&gt;this&lt;/code&gt; argument in non-static member functions, and of parameters of reference to a pointer type. For ordinary functions, position one refers to the first parameter on the list. In C++ non-static member functions, position one refers to the implicit &lt;code&gt;this&lt;/code&gt; pointer. The same restrictions and effects apply to function attributes used with ordinary functions or C++ member functions.</source>
          <target state="translated">일부 함수 속성은 함수 매개 변수 목록 내의 위치에 따라 함수의 매개 변수를 참조하는 하나 이상의 인수를 사용합니다. 이러한 속성 인수를 &lt;em&gt;위치 인수&lt;/em&gt; 라고합니다 . 달리 지정하지 않는 한 포인터 유형으로 매개 변수의 속성을 지정하는 위치 인수 는 비 정적 멤버 함수에서 암시 적 C ++ &lt;code&gt;this&lt;/code&gt; 인수와 포인터 유형에 대한 참조 매개 변수의 동일한 속성을 지정할 수도 있습니다 . 일반 기능의 경우 위치 1은 목록의 첫 번째 매개 변수를 나타냅니다. C ++ 비 정적 멤버 함수에서 위치 1은 암시 적 &lt;code&gt;this&lt;/code&gt; 포인터를 나타냅니다 . 일반 함수 또는 C ++ 멤버 함수에 사용되는 함수 속성에도 동일한 제한 사항 및 효과가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="fb33f99a987006c02f399310559443d2a427b3a7" translate="yes" xml:space="preserve">
          <source>Some lines of information at the start have &lt;var&gt;line_number&lt;/var&gt; of zero. These preamble lines are of the form</source>
          <target state="translated">시작시 일부 정보 줄의 &lt;var&gt;line_number&lt;/var&gt; 는 0입니다. 이 프리앰블 라인은</target>
        </trans-unit>
        <trans-unit id="9e5021e481328ac057640ef2a536800d9166dbbe" translate="yes" xml:space="preserve">
          <source>Some linkers are capable of detecting out-of-range calls and generating glue code on the fly. On these systems, long calls are unnecessary and generate slower code. As of this writing, the AIX linker can do this, as can the GNU linker for PowerPC/64. It is planned to add this feature to the GNU linker for 32-bit PowerPC systems as well.</source>
          <target state="translated">일부 링커는 범위를 벗어난 호출을 감지하고 즉시 접착제 코드를 생성 할 수 있습니다. 이러한 시스템에서는 긴 호출이 불필요하며 더 느린 코드를 생성합니다. 이 글을 쓰는 시점에서 AIX 링커는 PowerPC / 64 용 GNU 링커와 마찬가지로이 작업을 수행 할 수 있습니다. 32 비트 PowerPC 시스템 용 GNU 링커에도이 기능을 추가 할 계획입니다.</target>
        </trans-unit>
        <trans-unit id="e7ded2d98e8ad6e738cfb416e0e144f7c6488a8f" translate="yes" xml:space="preserve">
          <source>Some machines never actually require alignment; they allow references to any data type even at an odd address. For these machines, &lt;code&gt;__alignof__&lt;/code&gt; reports the smallest alignment that GCC gives the data type, usually as mandated by the target ABI.</source>
          <target state="translated">일부 기계는 실제로 정렬이 필요하지 않습니다. 홀수 주소에서도 모든 데이터 유형에 대한 참조를 허용합니다. 이러한 시스템의 경우 &lt;code&gt;__alignof__&lt;/code&gt; 는 일반적으로 대상 ABI에서 규정 한대로 GCC가 데이터 유형에 제공하는 최소 정렬을보고합니다.</target>
        </trans-unit>
        <trans-unit id="e609cdc1429a6fcb8d2a4566b95c795a179f9f38" translate="yes" xml:space="preserve">
          <source>Some more examples of the use of &lt;code&gt;typeof&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; 사용에 대한 몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="97a9b6bbb4ff568061400bba291a0fa95f27baca" translate="yes" xml:space="preserve">
          <source>Some object formats, like ELF, allow interposing of symbols by the dynamic linker. This means that for symbols exported from the DSO, the compiler cannot perform interprocedural propagation, inlining and other optimizations in anticipation that the function or variable in question may change. While this feature is useful, for example, to rewrite memory allocation functions by a debugging implementation, it is expensive in the terms of code quality. With</source>
          <target state="translated">ELF와 같은 일부 객체 형식을 사용하면 동적 링커에서 심볼을 삽입 할 수 있습니다. 이는 DSO에서 내 보낸 심볼의 경우 컴파일러가 문제의 함수 나 변수가 변경 될 것으로 예상하여 프로 시저 간 전파, 인라인 및 기타 최적화를 수행 할 수 없음을 의미합니다. 이 기능은 예를 들어 디버깅 구현으로 메모리 할당 기능을 다시 작성하는 데 유용하지만 코드 품질 측면에서 비용이 많이 듭니다. 와</target>
        </trans-unit>
        <trans-unit id="53b2cdebe3092f05376eba4dc6edb1163b208474" translate="yes" xml:space="preserve">
          <source>Some of these problems are due to bugs in other software, some are missing features that are too much work to add, and some are places where people&amp;rsquo;s opinions differ as to what is best.</source>
          <target state="translated">이러한 문제 중 일부는 다른 소프트웨어의 버그로 인해 발생하고 일부는 추가하기에는 너무 많은 기능이 누락되어 있으며 일부는 사람들의 의견이 가장 좋은 부분과 다른 곳입니다.</target>
        </trans-unit>
        <trans-unit id="e5a8bcdbd9732dbb47db6e251241faa598f69eaa" translate="yes" xml:space="preserve">
          <source>Some operands need to be in particular places on the stack. All output operands fall in this category&amp;mdash;GCC has no other way to know which registers the outputs appear in unless you indicate this in the constraints.</source>
          <target state="translated">일부 피연산자는 스택의 특정 위치에 있어야합니다. 모든 출력 피연산자는이 범주에 속합니다. GCC는 제약 조건에이를 표시하지 않으면 출력이 표시되는 레지스터를 알 수있는 다른 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="7bc3611475871be65cea3ae1eb8a4118c1e3da02" translate="yes" xml:space="preserve">
          <source>Some options for compiling C programs, such as</source>
          <target state="translated">다음과 같은 C 프로그램 컴파일을위한 일부 옵션</target>
        </trans-unit>
        <trans-unit id="9aab2dd921eb504a0a6bf04d60fa17f07ef07e59" translate="yes" xml:space="preserve">
          <source>Some options take one or more arguments typically separated either by a space or by the equals sign (&amp;lsquo;</source>
          <target state="translated">일부 옵션은 일반적으로 공백 또는 등호 ( '</target>
        </trans-unit>
        <trans-unit id="b09c01fb6d97b0be636c36b27746781fe632f575" translate="yes" xml:space="preserve">
          <source>Some options, such as</source>
          <target state="translated">같은 일부 옵션</target>
        </trans-unit>
        <trans-unit id="8b764d6df82f9df721fda3ecd882ae472b0abef6" translate="yes" xml:space="preserve">
          <source>Some other command-line options starting with</source>
          <target state="translated">로 시작하는 다른 명령 줄 옵션</target>
        </trans-unit>
        <trans-unit id="2b1de7c862240cc77fd4597210b6bd463edb0754" translate="yes" xml:space="preserve">
          <source>Some spurious warnings can be avoided if you declare all the functions you use that never return as &lt;code&gt;noreturn&lt;/code&gt;. See &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;noreturn&lt;/code&gt; 으로 반환되지 않는 사용하는 모든 함수를 선언하면 일부 잘못된 경고를 피할 수 있습니다 . &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;기능 속성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0b7a7ebb3620b1d731c5783bb7dadf2877e0be61" translate="yes" xml:space="preserve">
          <source>Some targets have a special register that holds the &amp;ldquo;flags&amp;rdquo; for the result of an operation or comparison. Normally, the contents of that register are either unmodifed by the asm, or the &lt;code&gt;asm&lt;/code&gt; statement is considered to clobber the contents.</source>
          <target state="translated">일부 대상에는 작업 또는 비교 결과에 대한 &quot;플래그&quot;를 보유하는 특수 레지스터가 있습니다. 일반적으로 해당 레지스터의 내용은 asm에 의해 수정되지 않거나 &lt;code&gt;asm&lt;/code&gt; 문은 내용을 클로버하는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="ece7407fc707518ca6db13a249080d20314edfb1" translate="yes" xml:space="preserve">
          <source>Some targets require that GCC track the size of each instruction used in order to generate correct code. Because the final length of the code produced by an &lt;code&gt;asm&lt;/code&gt; statement is only known by the assembler, GCC must make an estimate as to how big it will be. It does this by counting the number of instructions in the pattern of the &lt;code&gt;asm&lt;/code&gt; and multiplying that by the length of the longest instruction supported by that processor. (When working out the number of instructions, it assumes that any occurrence of a newline or of whatever statement separator character is supported by the assembler &amp;mdash; typically &amp;lsquo;</source>
          <target state="translated">일부 대상에서는 GCC가 올바른 코드를 생성하기 위해 사용되는 각 명령의 크기를 추적해야합니다. &lt;code&gt;asm&lt;/code&gt; 문으로 생성 된 코드의 최종 길이 는 어셈블러에서만 알 수 있으므로 GCC는 코드의 크기를 예측해야합니다. 이는 &lt;code&gt;asm&lt;/code&gt; 패턴의 명령어 수를 세고 해당 프로세서가 지원하는 가장 긴 명령어 길이를 곱하여 수행합니다. (명령의 수를 계산할 때 개행 문자 또는 명령문 구분 기호 문자가 어셈블러에서 지원되는 것으로 가정합니다. 일반적으로 '</target>
        </trans-unit>
        <trans-unit id="d9a576a0cb85284fa181b1af5cb015b4bd820399" translate="yes" xml:space="preserve">
          <source>Some targets, e.g. x86 and PowerPC, support the &lt;code&gt;#pragma ms_struct&lt;/code&gt; directive which lays out structures and unions subsequently defined as the documented &lt;code&gt;__attribute__ ((ms_struct))&lt;/code&gt;.</source>
          <target state="translated">x86 및 PowerPC와 같은 일부 대상 은 문서화 된 &lt;code&gt;__attribute__ ((ms_struct))&lt;/code&gt; 로 정의 된 구조 및 공용체를 &lt;code&gt;#pragma ms_struct&lt;/code&gt; 하는 #pragma ms_struct 지시문을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="32c528c0b130160ed58ee14f8bbba2d7a132054b" translate="yes" xml:space="preserve">
          <source>Some users try to use</source>
          <target state="translated">일부 사용자는 사용하려고합니다</target>
        </trans-unit>
        <trans-unit id="c714f3fa36461f2e5681ce26cd399297f4a56453" translate="yes" xml:space="preserve">
          <source>Some users try to use &lt;code&gt;__STDC__&lt;/code&gt; to check for the availability of certain library facilities. This is actually incorrect usage in an ISO C program, because the ISO C standard says that a conforming freestanding implementation should define &lt;code&gt;__STDC__&lt;/code&gt; even though it does not have the library facilities. &amp;lsquo;</source>
          <target state="translated">일부 사용자는 &lt;code&gt;__STDC__&lt;/code&gt; 를 사용하여 특정 라이브러리 기능의 사용 가능 여부를 확인 하려고합니다 . ISO C 표준 에서는 라이브러리 기능이 없더라도 적합한 독립 실행 형 구현에 &lt;code&gt;__STDC__&lt;/code&gt; 를 정의해야하므로 ISO C 프로그램에서는 실제로 잘못 사용됩니다 . '</target>
        </trans-unit>
        <trans-unit id="6c0811681aff3d220c177a6ae42df51a4668d70d" translate="yes" xml:space="preserve">
          <source>Sometimes a single instruction has multiple alternative sets of possible operands. For example, on the 68000, a logical-or instruction can combine register or an immediate value into memory, or it can combine any kind of operand into a register; but it cannot combine one memory location into another.</source>
          <target state="translated">때로는 단일 명령어에 여러 가지 가능한 피연산자 세트가 있습니다. 예를 들어, 68000에서 논리 또는 명령어는 레지스터 또는 즉시 값을 메모리에 결합하거나 모든 종류의 피연산자를 레지스터에 결합 할 수 있습니다. 그러나 한 메모리 위치를 다른 메모리 위치로 결합 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="bcdf40850f5e7d0e40bbaa8bc961e1b76a034440" translate="yes" xml:space="preserve">
          <source>Sometimes it is desirable to write code using a mix of generic vector operations (for clarity) and machine-specific vector intrinsics (to access vector instructions that are not exposed via generic built-ins). On x86, intrinsic functions for integer vectors typically use the same vector type &lt;code&gt;__m128i&lt;/code&gt; irrespective of how they interpret the vector, making it necessary to cast their arguments and return values from/to other vector types. In C, you can make use of a &lt;code&gt;union&lt;/code&gt; type:</source>
          <target state="translated">때로는 일반 벡터 연산 (명확성을 위해)과 머신 별 벡터 내장 함수 (일반 내장 기능을 통해 노출되지 않은 벡터 명령어에 액세스)를 혼합하여 코드를 작성하는 것이 바람직합니다. x86에서 정수 벡터에 대한 내장 함수는 일반적으로 벡터 를 해석하는 방법에 관계없이 동일한 벡터 유형 &lt;code&gt;__m128i&lt;/code&gt; 를 사용하므로 인수를 캐스팅하고 다른 벡터 유형으로 /에서 다른 값으로 값을 반환해야합니다. C에서는 &lt;code&gt;union&lt;/code&gt; 유형 을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e7b9f7e78924f4429d79b3875d59ae1541b656fb" translate="yes" xml:space="preserve">
          <source>Sometimes people say that defining &lt;code&gt;__STDC__&lt;/code&gt; in a compiler that does not completely conform to the ISO C standard somehow violates the standard. This is illogical. The standard is a standard for compilers that claim to support ISO C, such as &amp;lsquo;</source>
          <target state="translated">때때로 사람들 은 ISO C 표준을 완전히 준수하지 않는 컴파일러에서 &lt;code&gt;__STDC__&lt;/code&gt; 를 정의 하면 표준을 위반한다고 말합니다. 이것은 비논리적입니다. 이 표준은 ISO C를 지원한다고 주장하는 컴파일러의 표준입니다 (예 : '</target>
        </trans-unit>
        <trans-unit id="c41073d5b9e69b8696bff1b0838e6f995522031e" translate="yes" xml:space="preserve">
          <source>Sort the symbols according to size.</source>
          <target state="translated">크기에 따라 기호를 정렬하십시오.</target>
        </trans-unit>
        <trans-unit id="f71bf34c2cf4ef01fa642de620de6d3ffbf6ba33" translate="yes" xml:space="preserve">
          <source>Sort the symbols alphabetically.</source>
          <target state="translated">기호를 알파벳순으로 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="8110c50df0a3ae32bff485105c38a69468d7fdd2" translate="yes" xml:space="preserve">
          <source>Special constraints for some particular machines.</source>
          <target state="translated">특정 기계에 대한 특수 제한.</target>
        </trans-unit>
        <trans-unit id="2ba4930cab85f2e9501af3573b08b92708f7a0ae" translate="yes" xml:space="preserve">
          <source>Special format strings</source>
          <target state="translated">특수 형식 문자열</target>
        </trans-unit>
        <trans-unit id="2a9d5504a562859df5546c189640d36f2ebdc1bd" translate="yes" xml:space="preserve">
          <source>Special syntax for implementing &lt;code&gt;offsetof&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;offsetof&lt;/code&gt; 구현을위한 특수 구문 .</target>
        </trans-unit>
        <trans-unit id="253477bfce70caeee68c5d46f4cbdd5958d04b09" translate="yes" xml:space="preserve">
          <source>Specifier</source>
          <target state="translated">Specifier</target>
        </trans-unit>
        <trans-unit id="fae65de83d82c109b91ff281d719a67482b13328" translate="yes" xml:space="preserve">
          <source>Specifies a C lvalue expression to hold the output, typically a variable name. The enclosing parentheses are a required part of the syntax.</source>
          <target state="translated">출력을 보유 할 C lvalue 표현식 (일반적으로 변수 이름)을 지정합니다. 괄호는 구문의 필수 부분입니다.</target>
        </trans-unit>
        <trans-unit id="05513a361baed0fc6bc2b4e7e1181bfda41a5c6c" translate="yes" xml:space="preserve">
          <source>Specifies a symbolic name for the operand. Reference the name in the assembler template by enclosing it in square brackets (i.e. &amp;lsquo;</source>
          <target state="translated">피연산자의 기호 이름을 지정합니다. 대괄호로 묶어 어셈블러 템플릿에서 이름을 참조하십시오 (예 : '</target>
        </trans-unit>
        <trans-unit id="c765ec9a6362d918fb2bf1565e87927ec8cd6358" translate="yes" xml:space="preserve">
          <source>Specifies general-purposes registers that the processor automatically saves/restores on interrupt entry and exit. &lt;var&gt;register-range&lt;/var&gt; is specified as two registers separated by a dash. The register range always starts with &lt;code&gt;r0&lt;/code&gt;, the upper limit is &lt;code&gt;fp&lt;/code&gt; register. &lt;var&gt;blink&lt;/var&gt; and &lt;var&gt;lp_count&lt;/var&gt; are optional. This option is only valid for ARC EM and ARC HS cores.</source>
          <target state="translated">프로세서가 인터럽트 입력 및 종료시 자동으로 저장 / 복원 할 범용 레지스터를 지정합니다. &lt;var&gt;register-range&lt;/var&gt; 는 대시로 구분 된 두 개의 레지스터로 지정됩니다. 레지스터 범위는 항상 &lt;code&gt;r0&lt;/code&gt; 으로 시작하며 상한은 &lt;code&gt;fp&lt;/code&gt; 레지스터입니다. &lt;var&gt;blink&lt;/var&gt; 및 &lt;var&gt;lp_count&lt;/var&gt; 는 선택 사항입니다. 이 옵션은 ARC EM 및 ARC HS 코어에만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="f3854791e88bad573a0be4f46ed869cefa1b475c" translate="yes" xml:space="preserve">
          <source>Specifies maximal growth of large function caused by inlining in percents. For example, parameter value 100 limits large function growth to 2.0 times the original size.</source>
          <target state="translated">백분율로 인라인으로 인해 큰 함수의 최대 성장을 지정합니다. 예를 들어, 매개 변수 값 100은 큰 함수 증가를 원래 크기의 2.0 배로 제한합니다.</target>
        </trans-unit>
        <trans-unit id="dfe06371f415167055f13157f6cd31af5c5dbd88" translate="yes" xml:space="preserve">
          <source>Specifies maximal growth of large stack frames caused by inlining in percents. For example, parameter value 1000 limits large stack frame growth to 11 times the original size.</source>
          <target state="translated">백분율로 인라인으로 인해 큰 스택 프레임의 최대 증가를 지정합니다. 예를 들어, 매개 변수 값 1000은 큰 스택 프레임 증가를 원래 크기의 11 배로 제한합니다.</target>
        </trans-unit>
        <trans-unit id="94731e3c8ea6ab127a428ca6dbbe480337db1263" translate="yes" xml:space="preserve">
          <source>Specifies maximal overall growth of the compilation unit caused by inlining. For example, parameter value 20 limits unit growth to 1.2 times the original size. Cold functions (either marked cold via an attribute or by profile feedback) are not accounted into the unit size.</source>
          <target state="translated">인라인으로 인한 컴파일 단위의 최대 전체 증가를 지정합니다. 예를 들어, 매개 변수 값 20은 단위 크기를 원래 크기의 1.2 배로 제한합니다. 냉기 기능 (속성 또는 프로필 피드백을 통해 냉기 표시)은 단위 크기에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f6a6169df4d1b9f4ae3a854ae149c4bc3eb831c7" translate="yes" xml:space="preserve">
          <source>Specifies maximal overall growth of the compilation unit caused by interprocedural constant propagation. For example, parameter value 10 limits unit growth to 1.1 times the original size.</source>
          <target state="translated">interprocedural constant propagation으로 인한 컴파일 단위의 최대 전체 성장을 지정합니다. 예를 들어, 매개 변수 값 10은 단위 크기를 원래 크기의 1.1 배로 제한합니다.</target>
        </trans-unit>
        <trans-unit id="c09858fd018d531b5e4ff4ecd665a6f14de1bdc3" translate="yes" xml:space="preserve">
          <source>Specifies that interrupt handler functions should preserve the MDUC registers. This is only necessary if normal code might use the MDUC registers, for example because it performs multiplication and division operations. The default is to ignore the MDUC registers as this makes the interrupt handlers faster. The target option -mg13 needs to be passed for this to work as this feature is only available on the G13 target (S2 core). The MDUC registers will only be saved if the interrupt handler performs a multiplication or division operation or it calls another function.</source>
          <target state="translated">인터럽트 핸들러 함수가 MDUC 레지스터를 보존하도록 지정합니다. 이것은 예를 들어 곱셈과 나눗셈 연산을 수행하기 때문에 일반 코드가 MDUC 레지스터를 사용할 수있는 경우에만 필요합니다. 인터럽트 처리기가 더 빠르기 때문에 MDUC 레지스터를 무시하는 것이 기본값입니다. 이 기능이 작동하려면 대상 옵션 -mg13을 전달해야합니다.이 기능은 G13 대상 (S2 코어)에서만 사용할 수 있습니다. MDUC 레지스터는 인터럽트 핸들러가 곱셈 또는 나눗셈 연산을 수행하거나 다른 함수를 호출하는 경우에만 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="e16a3667d78dbf88b960c5650973c17d00b701b4" translate="yes" xml:space="preserve">
          <source>Specifies that interrupt handler functions should preserve the accumulator register. This is only necessary if normal code might use the accumulator register, for example because it performs 64-bit multiplications. The default is to ignore the accumulator as this makes the interrupt handlers faster.</source>
          <target state="translated">인터럽트 핸들러 함수가 누산기 레지스터를 유지하도록 지정합니다. 예를 들어 64 비트 곱셈을 수행하기 때문에 일반 코드가 누산기 레지스터를 사용할 수있는 경우에만 필요합니다. 인터럽트 처리기가 더 빠르기 때문에 기본값은 누산기를 무시하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b7effad23ab12e24339284e6f0eafe7d16434faa" translate="yes" xml:space="preserve">
          <source>Specifies that the PRU CTABLE entry given by &lt;var&gt;index&lt;/var&gt; has the value &lt;var&gt;constant_address&lt;/var&gt;. This enables GCC to emit LBCO/SBCO instructions when the load/store address is known and can be addressed with some CTABLE entry. For example:</source>
          <target state="translated">&lt;var&gt;index&lt;/var&gt; 에 의해 제공된 PRU CTABLE 항목 이 &lt;var&gt;constant_address&lt;/var&gt; 값을 갖도록 지정합니다 . 이렇게하면로드 / 저장 주소가 알려져 있고 일부 CTABLE 항목으로 주소를 지정할 수있을 때 GCC가 LBCO / SBCO 명령을 내 보냅니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="dd671f6f6086870972e15aa7905ec8f7db267ac7" translate="yes" xml:space="preserve">
          <source>Specifies that the cache cannot be flushed by using a trap.</source>
          <target state="translated">트랩을 사용하여 캐시를 플러시 할 수 없도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="47947b45b4744585e55d8f763014a0ae39516e00" translate="yes" xml:space="preserve">
          <source>Specifies that the program will be run on the simulator. This causes an alternate runtime library to be linked in which supports, for example, file I/O. You must not use this option when generating programs that will run on real hardware; you must provide your own runtime library for whatever I/O functions are needed.</source>
          <target state="translated">프로그램이 시뮬레이터에서 실행되도록 지정합니다. 이로 인해 대체 I / O와 같은 대체 런타임 라이브러리가 링크됩니다. 실제 하드웨어에서 실행될 프로그램을 생성 할 때는이 옵션을 사용하지 않아야합니다. 필요한 I / O 함수에 대해 고유 한 런타임 라이브러리를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="92a7b7c9a6c346e8818d5fec33b1b2c04de8591c" translate="yes" xml:space="preserve">
          <source>Specifies that the program will be run on the simulator. This causes an alternate runtime startup and library to be linked. You must not use this option when generating programs that will run on real hardware; you must provide your own runtime library for whatever I/O functions are needed.</source>
          <target state="translated">프로그램이 시뮬레이터에서 실행되도록 지정합니다. 이로 인해 대체 런타임 시작 및 라이브러리가 링크됩니다. 실제 하드웨어에서 실행될 프로그램을 생성 할 때는이 옵션을 사용하지 않아야합니다. 필요한 I / O 함수에 대해 고유 한 런타임 라이브러리를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="cc31c50b75b75e6cf86f872d21ade4b77825de9f" translate="yes" xml:space="preserve">
          <source>Specifies that the program will be run on the simulator. This causes the simulator BSP provided by libgloss to be linked in. This option has effect only for &amp;lsquo;</source>
          <target state="translated">프로그램이 시뮬레이터에서 실행되도록 지정합니다. 이로 인해 libgloss에서 제공 한 시뮬레이터 BSP가 연결됩니다.이 옵션은 '</target>
        </trans-unit>
        <trans-unit id="4b908ebdba88cf2c2a293fda93618017153fd58b" translate="yes" xml:space="preserve">
          <source>Specifies the ABI type to use for vectorizing intrinsics using an external library. Supported values for &lt;var&gt;type&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">외부 라이브러리를 사용하여 내장 함수를 벡터화하는 데 사용할 ABI 유형을 지정합니다. &lt;var&gt;type&lt;/var&gt; 에 지원되는 값 은 '</target>
        </trans-unit>
        <trans-unit id="df8e8fddb7d07761c1b84aad23b4814d921c564b" translate="yes" xml:space="preserve">
          <source>Specifies the ABI type to use for vectorizing intrinsics using an external library. The only type supported at present is &amp;lsquo;</source>
          <target state="translated">외부 라이브러리를 사용하여 내장 함수를 벡터화하는 데 사용할 ABI 유형을 지정합니다. 현재 지원되는 유일한 유형은 '</target>
        </trans-unit>
        <trans-unit id="3e1277fdc0689b726ff15cccd084ddbac36979fe" translate="yes" xml:space="preserve">
          <source>Specifies the ISA to use. Accepted values are &amp;lsquo;</source>
          <target state="translated">사용할 ISA를 지정합니다. 허용되는 값은 '</target>
        </trans-unit>
        <trans-unit id="5ca955df8b960b04d79d7dd74115e500bda85663" translate="yes" xml:space="preserve">
          <source>Specifies the RL78 core to target. The default is the G14 core, also known as an S3 core or just RL78. The G13 or S2 core does not have multiply or divide instructions, instead it uses a hardware peripheral for these operations. The G10 or S1 core does not have register banks, so it uses a different calling convention.</source>
          <target state="translated">대상으로 지정할 RL78 코어를 지정합니다. 기본값은 S14 코어 또는 RL78이라고도하는 G14 코어입니다. G13 또는 S2 코어에는 곱하기 또는 나누기 명령어가 없으며 대신 이러한 작업에 하드웨어 주변 장치를 사용합니다. G10 또는 S1 코어에는 레지스터 뱅크가 없으므로 다른 호출 규칙을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f635669de18bf56a687958d1a8c71186afb495b2" translate="yes" xml:space="preserve">
          <source>Specifies the TLS dialect to use for this function. The behavior and permissible arguments are the same as for the command-line option</source>
          <target state="translated">이 기능에 사용할 TLS 언어를 지정합니다. 동작 및 허용 가능한 인수는 명령 행 옵션과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="c52b2c30fecaf2eb67f980f2baf7835c6acbf2e9" translate="yes" xml:space="preserve">
          <source>Specifies the architecture version and architectural extensions to use for this function. The behavior and permissible arguments are the same as for the</source>
          <target state="translated">이 기능에 사용할 아키텍처 버전 및 아키텍처 확장을 지정합니다. 동작 및 허용 가능한 인수는</target>
        </trans-unit>
        <trans-unit id="dbbb7ebc147f28ae0dcd4250f31f3d8fd9cac55e" translate="yes" xml:space="preserve">
          <source>Specifies the core for which to tune the performance of this function and also whose architectural features to use. The behavior and valid arguments are the same as for the</source>
          <target state="translated">이 기능의 성능을 조정하고 아키텍처 기능을 사용할 코어를 지정합니다. 동작 및 유효한 인수는</target>
        </trans-unit>
        <trans-unit id="fe58a5c95595be8f2a1ff92d9451c73415b5a99d" translate="yes" xml:space="preserve">
          <source>Specifies the core for which to tune the performance of this function. The behavior and permissible arguments are the same as for the</source>
          <target state="translated">이 기능의 성능을 조정할 코어를 지정합니다. 동작 및 허용 가능한 인수는</target>
        </trans-unit>
        <trans-unit id="28873c2fbf7d823a74544bebc8a6344119496c82" translate="yes" xml:space="preserve">
          <source>Specifies the fpu for which to tune the performance of this function. The behavior and permissible arguments are the same as for the</source>
          <target state="translated">이 함수의 성능을 조정할 fpu를 지정합니다. 동작 및 허용 가능한 인수는</target>
        </trans-unit>
        <trans-unit id="cce88289fcb8b24761c893dbf247fdd528b95133" translate="yes" xml:space="preserve">
          <source>Specifies the function to call to flush the I and D caches, or to not call any such function. If called, the function must take the same arguments as the common &lt;code&gt;_flush_func&lt;/code&gt;, that is, the address of the memory range for which the cache is being flushed, the size of the memory range, and the number 3 (to flush both caches). The default depends on the target GCC was configured for, but commonly is either &lt;code&gt;_flush_func&lt;/code&gt; or &lt;code&gt;__cpu_flush&lt;/code&gt;.</source>
          <target state="translated">I 및 D 캐시를 플러시하거나 그러한 함수를 호출하지 않도록 호출 할 함수를 지정합니다. 호출되면 함수는 공통 &lt;code&gt;_flush_func&lt;/code&gt; 와 동일한 인수 , 즉 캐시가 플러시되는 메모리 범위의 주소, 메모리 범위의 크기 및 숫자 3 (두 캐시를 플러시하기 위해)과 동일한 인수를 가져야 합니다. 기본값은 GCC가 구성된 대상에 따라 다르지만 일반적으로 &lt;code&gt;_flush_func&lt;/code&gt; 또는 &lt;code&gt;__cpu_flush&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7671feaad590d7ec398f51bb4af652d4dc88ce38" translate="yes" xml:space="preserve">
          <source>Specifies the identification number of the ID-based shared library being compiled. Specifying a value of 0 generates more compact code; specifying other values forces the allocation of that number to the current library but is no more space- or time-efficient than omitting this option.</source>
          <target state="translated">컴파일중인 ID 기반 공유 라이브러리의 식별 번호를 지정합니다. 값을 0으로 지정하면보다 간단한 코드가 생성됩니다. 다른 값을 지정하면 해당 번호를 현재 라이브러리에 강제로 할당하지만이 옵션을 생략하는 것보다 공간이나 시간 효율적이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="99738458ed498047e95197f3c00800b279d2d584" translate="yes" xml:space="preserve">
          <source>Specifies the identification number of the ID-based shared library being compiled. Specifying a value of 0 generates more compact code; specifying other values forces the allocation of that number to the current library, but is no more space- or time-efficient than omitting this option.</source>
          <target state="translated">컴파일중인 ID 기반 공유 라이브러리의 식별 번호를 지정합니다. 값을 0으로 지정하면보다 간단한 코드가 생성됩니다. 다른 값을 지정하면 해당 번호를 현재 라이브러리에 강제로 할당하지만이 옵션을 생략하는 것보다 공간이나 시간 효율적이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c1e382c74800682d2e9f3b74a1844826dd2ecb62" translate="yes" xml:space="preserve">
          <source>Specifies the maximum number of instructions an out-of-line copy of a self-recursive inline function can grow into by performing recursive inlining.</source>
          <target state="translated">재귀 인라인을 수행하여 자체 재귀 인라인 함수의 라인 외부 사본이 증가 할 수있는 최대 명령 수를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="a5e540e476e706af7ae2a630f97b45afd6de5bb3" translate="yes" xml:space="preserve">
          <source>Specifies the maximum recursion depth used for recursive inlining.</source>
          <target state="translated">재귀 인라이닝에 사용되는 최대 재귀 깊이를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="842831f7e4e5d29f3e7d0beec2854a0216bc6e42" translate="yes" xml:space="preserve">
          <source>Specifies the maximum size in bytes of global and static variables which can be placed into the small data area. Using the small data area can lead to smaller and faster code, but the size of area is limited and it is up to the programmer to ensure that the area does not overflow. Also when the small data area is used one of the RX&amp;rsquo;s registers (usually &lt;code&gt;r13&lt;/code&gt;) is reserved for use pointing to this area, so it is no longer available for use by the compiler. This could result in slower and/or larger code if variables are pushed onto the stack instead of being held in this register.</source>
          <target state="translated">작은 데이터 영역에 배치 할 수있는 전역 및 정적 변수의 최대 크기를 바이트 단위로 지정합니다. 작은 데이터 영역을 사용하면 코드가 더 작고 빨라질 수 있지만 영역의 크기는 제한되어 있으며 영역이 오버플로되지 않도록 프로그래머에게 달려 있습니다. 또한 작은 데이터 영역이 사용되는 경우 RX 레지스터 중 하나 (일반적으로 &lt;code&gt;r13&lt;/code&gt; )는이 영역을 가리키는 용도로 예약되어 있으므로 더 이상 컴파일러에서 사용할 수 없습니다. 변수가이 레지스터에 유지되는 대신 스택에 푸시되면 코드가 느리거나 더 커질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7412a6cb9b0e0f8b6e7f0d0e77fd2140ccfb86a1" translate="yes" xml:space="preserve">
          <source>Specifies the maximum size, in bytes, of a constant that can be used as an operand in a RX instruction. Although the RX instruction set does allow constants of up to 4 bytes in length to be used in instructions, a longer value equates to a longer instruction. Thus in some circumstances it can be beneficial to restrict the size of constants that are used in instructions. Constants that are too big are instead placed into a constant pool and referenced via register indirection.</source>
          <target state="translated">RX 명령어에서 피연산자로 사용할 수있는 상수의 최대 크기 (바이트)를 지정합니다. RX 명령어 세트는 명령어에 최대 4 바이트 길이의 상수를 사용할 수 있지만 값이 클수록 명령어가 길어집니다. 따라서 어떤 상황에서는 명령어에 사용되는 상수의 크기를 제한하는 것이 유리할 수 있습니다. 너무 큰 상수는 대신 상수 풀에 배치되고 레지스터 간접 참조를 통해 참조됩니다.</target>
        </trans-unit>
        <trans-unit id="f498cab10962b0798c0931ba2f63475387ade694" translate="yes" xml:space="preserve">
          <source>Specifies the name of the operating system function to call to flush the cache. The default is &amp;lsquo;</source>
          <target state="translated">캐시를 플러시하기 위해 호출 할 운영 체제 기능의 이름을 지정합니다. 기본값은 '</target>
        </trans-unit>
        <trans-unit id="4cb9f9dd93932f78051a635c26202d7d8e5535cd" translate="yes" xml:space="preserve">
          <source>Specifies the name of the target Blackfin processor. Currently, &lt;var&gt;cpu&lt;/var&gt; can be one of &amp;lsquo;</source>
          <target state="translated">대상 Blackfin 프로세서의 이름을 지정합니다. 현재 &lt;var&gt;cpu&lt;/var&gt; 는 '</target>
        </trans-unit>
        <trans-unit id="c0803aab785a2e20aedd243e17212d6d9ce8548e" translate="yes" xml:space="preserve">
          <source>Specifies the number of memory-based pseudo-registers GCC uses during code generation. These pseudo-registers are used like real registers, so there is a tradeoff between GCC&amp;rsquo;s ability to fit the code into available registers, and the performance penalty of using memory instead of registers. Note that all modules in a program must be compiled with the same value for this option. Because of that, you must not use this option with GCC&amp;rsquo;s default runtime libraries.</source>
          <target state="translated">코드 생성 중에 GCC가 사용하는 메모리 기반 의사 레지스터 수를 지정합니다. 이러한 의사 레지스터는 실제 레지스터처럼 사용되므로 GCC의 코드를 사용 가능한 레지스터에 맞추는 기능과 레지스터 대신 메모리를 사용하는 경우 성능이 저하됩니다. 프로그램의 모든 모듈은이 옵션에 대해 동일한 값으로 컴파일되어야합니다. 따라서 GCC의 기본 런타임 라이브러리와 함께이 옵션을 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="22f3ed905850cb42bd6d50bb52af7907bc7a581e" translate="yes" xml:space="preserve">
          <source>Specifies the number of registers replicated in second register bank on entry to fast interrupt. Fast interrupts are interrupts with the highest priority level P0. These interrupts save only PC and STATUS32 registers to avoid memory transactions during interrupt entry and exit sequences. Use this option when you are using fast interrupts in an ARC V2 family processor. Permitted values are 4, 8, 16, and 32.</source>
          <target state="translated">빠른 인터럽트를 시작할 때 두 번째 레지스터 뱅크에 복제 된 레지스터 수를 지정합니다. 빠른 인터럽트는 우선 순위 레벨 P0이 가장 높은 인터럽트입니다. 이 인터럽트는 인터럽트 입력 및 종료 시퀀스 중 메모리 트랜잭션을 피하기 위해 PC 및 STATUS32 레지스터 만 저장합니다. ARC V2 제품군 프로세서에서 빠른 인터럽트를 사용하는 경우이 옵션을 사용하십시오. 허용되는 값은 4, 8, 16 및 32입니다.</target>
        </trans-unit>
        <trans-unit id="affdb413ade6c559688aa8325514465c16425b76" translate="yes" xml:space="preserve">
          <source>Specifies the trap number to use to flush the cache. The default is 12. Valid numbers are between 0 and 15 inclusive.</source>
          <target state="translated">캐시를 비울 때 사용할 트랩 번호를 지정합니다. 기본값은 12입니다. 유효한 숫자는 0에서 15 사이입니다.</target>
        </trans-unit>
        <trans-unit id="c90e51847549c6d7bfb26f9d83f651beb9507ea1" translate="yes" xml:space="preserve">
          <source>Specifies the type of hardware multiplication and division support to be used. The simplest is &lt;code&gt;none&lt;/code&gt;, which uses software for both multiplication and division. This is the default. The &lt;code&gt;g13&lt;/code&gt; value is for the hardware multiply/divide peripheral found on the RL78/G13 (S2 core) targets. The &lt;code&gt;g14&lt;/code&gt; value selects the use of the multiplication and division instructions supported by the RL78/G14 (S3 core) parts. The value &lt;code&gt;rl78&lt;/code&gt; is an alias for &lt;code&gt;g14&lt;/code&gt; and the value &lt;code&gt;mg10&lt;/code&gt; is an alias for &lt;code&gt;none&lt;/code&gt;.</source>
          <target state="translated">사용할 하드웨어 곱셈 및 나눗셈 지원 유형을 지정합니다. 가장 간단한 방법은 곱셈과 나눗셈 모두에 소프트웨어를 사용하는 &lt;code&gt;none&lt;/code&gt; 입니다. 이것이 기본값입니다. &lt;code&gt;g13&lt;/code&gt; 값을 곱하기 위해 하드웨어 /를 RL78 / G13 (S2 코어) 타겟의 주변 FOUND 분할된다. &lt;code&gt;g14&lt;/code&gt; 값 RL78 / G14 (S3 코어) 부에 의해지지 된 곱셈과 나눗셈 명령의 사용을 선택한다. &lt;code&gt;rl78&lt;/code&gt; 값 은 &lt;code&gt;g14&lt;/code&gt; 의 별명 이고 &lt;code&gt;mg10&lt;/code&gt; 값 은 &lt;code&gt;none&lt;/code&gt; 의 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="6f81d16d95cc0305e73b474da06956f8e11e96d3" translate="yes" xml:space="preserve">
          <source>Specifies whether FP exceptions are enabled. This affects how FP instructions are scheduled for some processors. The default is that FP exceptions are enabled.</source>
          <target state="translated">FP 예외 사용 여부를 지정합니다. 이는 일부 프로세서의 FP 명령어 예약 방법에 영향을줍니다. 기본적으로 FP 예외가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="72b43446cb2dd4e94fe26ad69b18b9bf05535ef3" translate="yes" xml:space="preserve">
          <source>Specifies which coprocessor registers are available to the register allocator. &lt;var&gt;registers&lt;/var&gt; may be a single register, register range separated by ellipses, or comma-separated list of those. Example:</source>
          <target state="translated">레지스터 할당자가 사용할 수있는 보조 프로세서 레지스터를 지정합니다. &lt;var&gt;registers&lt;/var&gt; 는 단일 레지스터, 타원으로 구분 된 레지스터 범위 또는 쉼표로 구분 된 목록 일 수 있습니다. 예:</target>
        </trans-unit>
        <trans-unit id="0598db288f6f533223b56d068b56fd87125317c1" translate="yes" xml:space="preserve">
          <source>Specifies which coprocessor registers are to be saved and restored by any function using them. &lt;var&gt;registers&lt;/var&gt; may be a single register, register range separated by ellipses, or comma-separated list of those. Example:</source>
          <target state="translated">어떤 보조 프로세서 레지스터를 사용하여 어떤 기능으로 저장 및 복원 할 것인지 지정합니다. &lt;var&gt;registers&lt;/var&gt; 는 단일 레지스터, 타원으로 구분 된 레지스터 범위 또는 쉼표로 구분 된 목록 일 수 있습니다. 예:</target>
        </trans-unit>
        <trans-unit id="c1b3620228a9a55d3a61b6172646e0fda8c7d9e2" translate="yes" xml:space="preserve">
          <source>Specifies which floating-point ABI to use. Permissible values are: &amp;lsquo;</source>
          <target state="translated">사용할 부동 소수점 ABI를 지정합니다. 허용되는 값은 '</target>
        </trans-unit>
        <trans-unit id="a477d8dab7ef5cc90c58a41d06ca3494aeba078f" translate="yes" xml:space="preserve">
          <source>Specify</source>
          <target state="translated">Specify</target>
        </trans-unit>
        <trans-unit id="b7d7c4da380841e46021fb0ca037b1a5efba92c6" translate="yes" xml:space="preserve">
          <source>Specify &lt;var&gt;prefix&lt;/var&gt; as the prefix for subsequent</source>
          <target state="translated">후속 &lt;var&gt;prefix&lt;/var&gt; 로 접두사를 지정 하십시오.</target>
        </trans-unit>
        <trans-unit id="a1b75d36373bf0a158266aad4b0685acf54bdd9f" translate="yes" xml:space="preserve">
          <source>Specify Atmel AVR instruction set architectures (ISA) or MCU type.</source>
          <target state="translated">Atmel AVR 명령어 세트 아키텍처 (ISA) 또는 MCU 유형을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="d5ced711925ce2b86f2945855d11a9f765bdf3b8" translate="yes" xml:space="preserve">
          <source>Specify a register to hold the constant -1, which makes loading small negative constants and certain bitmasks faster. Allowable values for &lt;var&gt;reg&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">상수 -1을 유지하도록 레지스터를 지정하면 작은 음수 상수 및 특정 비트 마스크를 더 빨리로드 할 수 있습니다. &lt;var&gt;reg&lt;/var&gt; 에 허용되는 값 은 '</target>
        </trans-unit>
        <trans-unit id="ee4e72d685bf13ccdca2b955146686e94f4dd820" translate="yes" xml:space="preserve">
          <source>Specify bit size of immediate TLS offsets. Valid values are 12, 24, 32, 48. This option requires binutils 2.26 or newer.</source>
          <target state="translated">즉시 TLS 오프셋의 비트 크기를 지정하십시오. 유효한 값은 12, 24, 32, 48입니다.이 옵션에는 binutils 2.26 이상이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="0ee5fd4c06f208dc72a94346beb5b066cc520b6c" translate="yes" xml:space="preserve">
          <source>Specify bit size of immediate TLS offsets. Valid values are 14, 22, and 64.</source>
          <target state="translated">즉시 TLS 오프셋의 비트 크기를 지정하십시오. 유효한 값은 14, 22 및 64입니다.</target>
        </trans-unit>
        <trans-unit id="e3d343f19f5a896581a51d8a250efd477d791df5" translate="yes" xml:space="preserve">
          <source>Specify both</source>
          <target state="translated">둘 다 지정</target>
        </trans-unit>
        <trans-unit id="790583d2504db1e70b776b6337942849b2d5671c" translate="yes" xml:space="preserve">
          <source>Specify default compute dimensions for parallel offload regions that do not explicitly specify. The &lt;var&gt;geom&lt;/var&gt; value is a triple of &amp;rsquo;:&amp;rsquo;-separated sizes, in order &amp;rsquo;gang&amp;rsquo;, &amp;rsquo;worker&amp;rsquo; and, &amp;rsquo;vector&amp;rsquo;. A size can be omitted, to use a target-specific default value.</source>
          <target state="translated">명시 적으로 지정하지 않은 병렬 오프로드 영역의 기본 계산 차원을 지정하십시오. &lt;var&gt;geom&lt;/var&gt; 값의 트리플이다 ''- 순서 갱단 ','작업자 '와,'벡터 '에서 크기를 분리 하였다. 대상별 기본값을 사용하기 위해 크기를 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0c09fd54e93619fc886af47d25ab910da3f1f1d" translate="yes" xml:space="preserve">
          <source>Specify desired number of partitions produced during WHOPR compilation. The number of partitions should exceed the number of CPUs used for compilation.</source>
          <target state="translated">WHOPR 컴파일 중에 생성되는 파티션 수를 지정하십시오. 파티션 수는 컴파일에 사용 된 CPU 수를 초과해야합니다.</target>
        </trans-unit>
        <trans-unit id="ddd74922c1fffe0660ee607e7c8c05e6b9c36231" translate="yes" xml:space="preserve">
          <source>Specify either the directory containing the gcov data files, or the object path name. The</source>
          <target state="translated">gcov 데이터 파일을 포함하는 디렉토리 또는 오브젝트 경로 이름을 지정하십시오. 그만큼</target>
        </trans-unit>
        <trans-unit id="a8bb63ac54bf2ea3fd989f2a3dede75fee9c409d" translate="yes" xml:space="preserve">
          <source>Specify explicitly the &lt;var&gt;language&lt;/var&gt; for the following input files (rather than letting the compiler choose a default based on the file name suffix). This option applies to all following input files until the next</source>
          <target state="translated">컴파일러에서 파일 이름 접미사를 기반으로 기본값을 선택하지 않고 다음 입력 파일 의 &lt;var&gt;language&lt;/var&gt; 를 명시 적으로 지정 하십시오. 이 옵션은 다음까지 모든 다음 입력 파일에 적용됩니다</target>
        </trans-unit>
        <trans-unit id="1dece3d1baf820f578333563e62b95b8ee062ffd" translate="yes" xml:space="preserve">
          <source>Specify growth that the early inliner can make. In effect it increases the amount of inlining for code having a large abstraction penalty.</source>
          <target state="translated">초기 라이너가 만들 수있는 성장을 지정하십시오. 사실상 추상화 패널티가 큰 코드의 인라인 양이 증가합니다.</target>
        </trans-unit>
        <trans-unit id="8b0123ff59c8271225f538f6c8fc4517d3e5946e" translate="yes" xml:space="preserve">
          <source>Specify how many &lt;var&gt;bytes&lt;/var&gt; of stack space will be requested for each GPU thread (wave-front). Beware that there may be many threads and limited memory available. The size of the stack allocation may also have an impact on run-time performance. The default is 32KB when using OpenACC or OpenMP, and 1MB otherwise.</source>
          <target state="translated">각 GPU 스레드 (wave-front)에 대해 요청 될 스택 공간의 &lt;var&gt;bytes&lt;/var&gt; 를 지정하십시오 . 사용 가능한 스레드가 많고 메모리가 제한 될 수 있습니다. 스택 할당의 크기는 런타임 성능에도 영향을 줄 수 있습니다. OpenACC 또는 OpenMP를 사용하는 경우 기본값은 32KB이고 그렇지 않은 경우 1MB입니다.</target>
        </trans-unit>
        <trans-unit id="6b4cd64add8e5ab4a64ac446bfe3679786b4245a" translate="yes" xml:space="preserve">
          <source>Specify how to print paths of control-flow events for diagnostics that have such a path associated with them.</source>
          <target state="translated">이러한 경로가 연관된 진단에 대한 제어 흐름 이벤트의 경로를 인쇄하는 방법을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="de9c99e300af9c8b6bed1288c468edd9f4ff0049" translate="yes" xml:space="preserve">
          <source>Specify integer and floating-point calling convention. &lt;var&gt;ABI-string&lt;/var&gt; contains two parts: the size of integer types and the registers used for floating-point types. For example &amp;lsquo;</source>
          <target state="translated">정수 및 부동 소수점 호출 규칙을 지정하십시오. &lt;var&gt;ABI-string&lt;/var&gt; 은 정수 유형의 크기와 부동 소수점 유형에 사용되는 레지스터의 두 부분으로 구성됩니다. 예를 들어 '</target>
        </trans-unit>
        <trans-unit id="d83c8944a923ba0afcb420deeb5f2d35c92d90c2" translate="yes" xml:space="preserve">
          <source>Specify that intrinsic library functions are being compiled, passing all values in registers, no matter the size.</source>
          <target state="translated">크기에 상관없이 레지스터의 모든 값을 전달하여 내장 라이브러리 함수를 컴파일하도록 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="ece1c6c2bc5985e3475fb38d94d339c81045f6ff" translate="yes" xml:space="preserve">
          <source>Specify that the assembler should encode SSE instructions with VEX prefix. The option</source>
          <target state="translated">어셈블러가 SEX 명령어를 VEX 접두사로 인코딩하도록 지정하십시오. 옵션</target>
        </trans-unit>
        <trans-unit id="b6e1f7a9d2a1718382e7b4d035866fa5b223eb27" translate="yes" xml:space="preserve">
          <source>Specify that the program entry point is &lt;var&gt;entry&lt;/var&gt;. The argument is interpreted by the linker; the GNU linker accepts either a symbol name or an address.</source>
          <target state="translated">프로그램 진입 점이 entry임을 지정 &lt;var&gt;entry&lt;/var&gt; . 인수는 링커에 의해 해석됩니다. GNU 링커는 심볼 이름 또는 주소를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="109f76cb76b9bdcac0640d708d9f5aa531701516" translate="yes" xml:space="preserve">
          <source>Specify that the target processor is the V850.</source>
          <target state="translated">대상 프로세서가 V850임을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="e795d47484c6aa284871594487a90d959a680146" translate="yes" xml:space="preserve">
          <source>Specify that the target processor is the V850E. The preprocessor constant &lt;code&gt;__v850e__&lt;/code&gt; is defined if this option is used.</source>
          <target state="translated">대상 프로세서가 V850E임을 지정하십시오. 이 옵션을 사용하면 전 처리기 상수 &lt;code&gt;__v850e__&lt;/code&gt; 가 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="8b95c4ac2d723888f85d1eb5d22f7c525dcae0da" translate="yes" xml:space="preserve">
          <source>Specify that the target processor is the V850E1. The preprocessor constants &lt;code&gt;__v850e1__&lt;/code&gt; and &lt;code&gt;__v850e__&lt;/code&gt; are defined if this option is used.</source>
          <target state="translated">대상 프로세서가 V850E1임을 지정하십시오. 이 옵션을 사용하면 전 처리기 상수 &lt;code&gt;__v850e1__&lt;/code&gt; 및 &lt;code&gt;__v850e__&lt;/code&gt; 가 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="978d09824c615036a75f151e3f181a0c030be29d" translate="yes" xml:space="preserve">
          <source>Specify that the target processor is the V850E2. The preprocessor constant &lt;code&gt;__v850e2__&lt;/code&gt; is defined if this option is used.</source>
          <target state="translated">대상 프로세서가 V850E2임을 지정하십시오. 이 옵션을 사용하면 전 처리기 상수 &lt;code&gt;__v850e2__&lt;/code&gt; 가 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="ed32c1d3fe9b0d91dac78559f89b829020d693b3" translate="yes" xml:space="preserve">
          <source>Specify that the target processor is the V850E2V3. The preprocessor constant &lt;code&gt;__v850e2v3__&lt;/code&gt; is defined if this option is used.</source>
          <target state="translated">대상 프로세서가 V850E2V3임을 지정하십시오. 이 옵션을 사용하면 전 처리기 상수 &lt;code&gt;__v850e2v3__&lt;/code&gt; 이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="45dfef0c4ebf051e18bbb6d800fab624cbb970fb" translate="yes" xml:space="preserve">
          <source>Specify that the target processor is the V850E3V5. The preprocessor constant &lt;code&gt;__v850e3v5__&lt;/code&gt; is defined if this option is used.</source>
          <target state="translated">대상 프로세서가 V850E3V5임을 지정하십시오. 이 옵션을 사용하면 전 처리기 상수 &lt;code&gt;__v850e3v5__&lt;/code&gt; 가 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="c53303aa9a3d3e7e971e5fac1f2e4c19510c6915" translate="yes" xml:space="preserve">
          <source>Specify that the target processor is the V850E3V5. This is an alias for the</source>
          <target state="translated">대상 프로세서가 V850E3V5임을 지정하십시오. 이것은의 별칭입니다</target>
        </trans-unit>
        <trans-unit id="f54503d1104c416ab9f70cb3eb9892d2467505fc" translate="yes" xml:space="preserve">
          <source>Specify that the target processor is the V850ES. This is an alias for the</source>
          <target state="translated">대상 프로세서가 V850ES임을 지정하십시오. 이것은의 별칭입니다</target>
        </trans-unit>
        <trans-unit id="ffbfc8af222c9971b65ff46dc8c44a1dab74c77d" translate="yes" xml:space="preserve">
          <source>Specify the ABI variant to output code for.</source>
          <target state="translated">코드를 출력 할 ABI 변형을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="20a7ba111bd81efdcb44d105c109fea8a9201317" translate="yes" xml:space="preserve">
          <source>Specify the C-SKY target architecture. Valid values for &lt;var&gt;arch&lt;/var&gt; are: &amp;lsquo;</source>
          <target state="translated">C-SKY 대상 아키텍처를 지정하십시오. &lt;var&gt;arch&lt;/var&gt; 의 유효한 값 은 '</target>
        </trans-unit>
        <trans-unit id="11e0bbd00da02b87a4bf01c5c95da5cd4e1c7d2f" translate="yes" xml:space="preserve">
          <source>Specify the C-SKY target processor. Valid values for &lt;var&gt;cpu&lt;/var&gt; are: &amp;lsquo;</source>
          <target state="translated">C-SKY 대상 프로세서를 지정하십시오. &lt;var&gt;cpu&lt;/var&gt; 유효한 값 은 다음과 같습니다. '</target>
        </trans-unit>
        <trans-unit id="fbd43e450dfe7c7020abde276dbd9a11edafebb9" translate="yes" xml:space="preserve">
          <source>Specify the PRU MCU variant to use. Check Newlib for the exact list of supported MCUs.</source>
          <target state="translated">사용할 PRU MCU 변형을 지정합니다. 지원되는 MCU의 정확한 목록은 Newlib를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="bc89fadc7861eb9269a2f0ab8fd00ec9f83fdfcb" translate="yes" xml:space="preserve">
          <source>Specify the SCORE5 as the target architecture.</source>
          <target state="translated">SCORE5를 대상 아키텍처로 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="80ac17f93e6b558b7b64a2653f4a0db05f2f20e9" translate="yes" xml:space="preserve">
          <source>Specify the SCORE5U of the target architecture.</source>
          <target state="translated">대상 아키텍처의 SCORE5U를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="e2e0fec7f878028d3e3295fde4a330a4137fef1a" translate="yes" xml:space="preserve">
          <source>Specify the SCORE7 as the target architecture. This is the default.</source>
          <target state="translated">SCORE7을 대상 아키텍처로 지정하십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="3faa14b10ee7726e8a0c19877d4b1bbbf4106dd0" translate="yes" xml:space="preserve">
          <source>Specify the SCORE7D as the target architecture.</source>
          <target state="translated">SCORE7D를 대상 아키텍처로 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="7c8f7f5802b742a1c6e69d2f1fd902f62c599e4f" translate="yes" xml:space="preserve">
          <source>Specify the access model for the thread local storage pointer. The valid models are &amp;lsquo;</source>
          <target state="translated">스레드 로컬 스토리지 포인터의 액세스 모델을 지정하십시오. 유효한 모델은 '</target>
        </trans-unit>
        <trans-unit id="4fe4d9d926d51c315bc40fdf7c449529e2dcee8d" translate="yes" xml:space="preserve">
          <source>Specify the architecture to generate code for in compiling the function.</source>
          <target state="translated">함수를 컴파일 할 때 코드를 생성 할 아키텍처를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="13ac0518f9e486f66b03f2a62260517f22563228" translate="yes" xml:space="preserve">
          <source>Specify the architecture to generate code for when compiling the function. If you select the &lt;code&gt;target(&quot;cpu=power7&quot;)&lt;/code&gt; attribute when generating 32-bit code, VSX and AltiVec instructions are not generated unless you use the</source>
          <target state="translated">함수를 컴파일 할 때 코드를 생성 할 아키텍처를 지정하십시오. 32 비트 코드를 생성 할 때 &lt;code&gt;target(&quot;cpu=power7&quot;)&lt;/code&gt; 속성 을 선택하면 VSX 및 AltiVec 명령어는 다음을 사용하지 않으면 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="815118b1ba2fa776327569310aabc51b60f85457" translate="yes" xml:space="preserve">
          <source>Specify the architecture to tune for in compiling the function.</source>
          <target state="translated">함수를 컴파일 할 때 조정할 아키텍처를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="c736ab6b1828855a9d2fe005636f63dbc18a00fc" translate="yes" xml:space="preserve">
          <source>Specify the architecture to tune for when compiling the function. If you do not specify the &lt;code&gt;target(&quot;tune=&lt;var&gt;TUNE&lt;/var&gt;&quot;)&lt;/code&gt; attribute and you do specify the &lt;code&gt;target(&quot;cpu=&lt;var&gt;CPU&lt;/var&gt;&quot;)&lt;/code&gt; attribute, compilation tunes for the &lt;var&gt;CPU&lt;/var&gt; architecture, and not the default tuning specified on the command line.</source>
          <target state="translated">함수를 컴파일 할 때 조정할 아키텍처를 지정하십시오. 당신은 지정하지 않으면 &lt;code&gt;target(&quot;tune=&lt;var&gt;TUNE&lt;/var&gt;&quot;)&lt;/code&gt; 속성을 당신은 지정 할 &lt;code&gt;target(&quot;cpu=&lt;var&gt;CPU&lt;/var&gt;&quot;)&lt;/code&gt; 속성의에 대한 컴파일 곡 &lt;var&gt;CPU&lt;/var&gt; 의 아키텍처, 그리고 명령 행에 지정된 기본 튜닝.</target>
        </trans-unit>
        <trans-unit id="cb717a175d86a7113193ef8b41cb494223988553" translate="yes" xml:space="preserve">
          <source>Specify the dialect to use for accessing thread local storage. Two &lt;var&gt;dialect&lt;/var&gt;s are supported&amp;mdash;&amp;lsquo;</source>
          <target state="translated">스레드 로컬 스토리지에 액세스하는 데 사용할 방언을 지정하십시오. 두 가지 &lt;var&gt;dialect&lt;/var&gt; 이 지원됩니다 &amp;mdash; '</target>
        </trans-unit>
        <trans-unit id="b0bb1382b2b688a4ca78557929489507a5c35134" translate="yes" xml:space="preserve">
          <source>Specify the format of the &lt;code&gt;__fp16&lt;/code&gt; half-precision floating-point type. Permissible names are &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;__fp16&lt;/code&gt; 반 정밀도 부동 소수점 유형 의 형식을 지정하십시오 . 허용되는 이름은 '</target>
        </trans-unit>
        <trans-unit id="54ccdaa4f82b5c59817de75dfddfa096068b5632" translate="yes" xml:space="preserve">
          <source>Specify the name of the target architecture and, optionally, one or more feature modifiers. This option has the form</source>
          <target state="translated">대상 아키텍처의 이름과 선택적으로 하나 이상의 기능 수정자를 지정하십시오. 이 옵션의 형태는</target>
        </trans-unit>
        <trans-unit id="db2ae06942e745baa6c648898511743a3997f671" translate="yes" xml:space="preserve">
          <source>Specify the name of the target architecture.</source>
          <target state="translated">대상 아키텍처의 이름을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="5bd735b6bf455d85d0ce6fea68c71abb062c337b" translate="yes" xml:space="preserve">
          <source>Specify the name of the target processor for which GCC should tune the performance of the code. Permissible values for this option are: &amp;lsquo;</source>
          <target state="translated">GCC가 코드 성능을 조정해야하는 대상 프로세서의 이름을 지정하십시오. 이 옵션에 허용되는 값은 '</target>
        </trans-unit>
        <trans-unit id="4403ce6e54a70cfa6d14c2a2335877fa18af0100" translate="yes" xml:space="preserve">
          <source>Specify the name of the target processor, optionally suffixed by one or more feature modifiers. This option has the form</source>
          <target state="translated">선택적으로 하나 이상의 기능 수정 자로 접미사로 지정된 대상 프로세서 이름을 지정하십시오. 이 옵션의 형태는</target>
        </trans-unit>
        <trans-unit id="4092610bf9412a688b5dccb4c11f819e1c6c07fc" translate="yes" xml:space="preserve">
          <source>Specify the number of bits in an SVE vector register. This option only has an effect when SVE is enabled.</source>
          <target state="translated">SVE 벡터 레지스터의 비트 수를 지정하십시오. 이 옵션은 SVE가 활성화 된 경우에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="e688b24a3a041ea4cb98f3c1a8d73b1e4471b5fc" translate="yes" xml:space="preserve">
          <source>Specify the number of registers to reserve for fast interrupt handler functions. The value &lt;var&gt;N&lt;/var&gt; can be between 0 and 4. A value of 1 means that register &lt;code&gt;r13&lt;/code&gt; is reserved for the exclusive use of fast interrupt handlers. A value of 2 reserves &lt;code&gt;r13&lt;/code&gt; and &lt;code&gt;r12&lt;/code&gt;. A value of 3 reserves &lt;code&gt;r13&lt;/code&gt;, &lt;code&gt;r12&lt;/code&gt; and &lt;code&gt;r11&lt;/code&gt;, and a value of 4 reserves &lt;code&gt;r13&lt;/code&gt; through &lt;code&gt;r10&lt;/code&gt;. A value of 0, the default, does not reserve any registers.</source>
          <target state="translated">빠른 인터럽트 핸들러 기능을 위해 예약 할 레지스터 수를 지정하십시오. 값 &lt;var&gt;N&lt;/var&gt; 은 0과 4 사이 일 수 있습니다. 값 1은 레지스터 &lt;code&gt;r13&lt;/code&gt; 이 고속 인터럽트 처리기 전용으로 예약되어 있음을 의미합니다 . 2 값은 &lt;code&gt;r13&lt;/code&gt; 과 &lt;code&gt;r12&lt;/code&gt; 를 예약 합니다 . 3의 값은 &lt;code&gt;r13&lt;/code&gt; , &lt;code&gt;r12&lt;/code&gt; 및 &lt;code&gt;r11&lt;/code&gt; 을 예약하고 4의 값은 &lt;code&gt;r13&lt;/code&gt; 에서 &lt;code&gt;r10&lt;/code&gt; 을 예약 합니다. 기본값 인 0은 레지스터를 예약하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="96cf955f0da2fdbcd4bc1c6671a0522d71316b38" translate="yes" xml:space="preserve">
          <source>Specify the partitioning algorithm used by the link-time optimizer. The value is either &amp;lsquo;</source>
          <target state="translated">링크 타임 옵티마이 저가 사용하는 파티셔닝 알고리즘을 지정하십시오. 값은 '</target>
        </trans-unit>
        <trans-unit id="5f46dcee93a04ae249c6b3def708b00260f2a519" translate="yes" xml:space="preserve">
          <source>Specify the register to be used for PIC addressing. For standard PIC base case, the default is any suitable register determined by compiler. For single PIC base case, the default is &amp;lsquo;</source>
          <target state="translated">PIC 주소 지정에 사용할 레지스터를 지정하십시오. 표준 PIC 기본 경우, 기본값은 컴파일러에 의해 결정된 적절한 레지스터입니다. 단일 PIC 기본 경우의 기본값은 '</target>
        </trans-unit>
        <trans-unit id="9157006b777e209a57da158df2f68846623d8678" translate="yes" xml:space="preserve">
          <source>Specify the size of each cache block, which must be a power of 2 between 4 and 512.</source>
          <target state="translated">각 캐시 블록의 크기를 지정하십시오. 4와 512 사이의 2의 제곱이어야합니다.</target>
        </trans-unit>
        <trans-unit id="edab8f619041277bee138aa740d3f8bdb844feca" translate="yes" xml:space="preserve">
          <source>Specify the size of each interrupt vector, which must be 4 or 16.</source>
          <target state="translated">각 인터럽트 벡터의 크기를 4 또는 16이어야합니다.</target>
        </trans-unit>
        <trans-unit id="dde0e6e48055b68c9dfa72618fe117ee2653e7c8" translate="yes" xml:space="preserve">
          <source>Specify the size of the operating system provided stack guard as 2 raised to &lt;var&gt;num&lt;/var&gt; bytes. Higher values may reduce the number of explicit probes, but a value larger than the operating system provided guard will leave code vulnerable to stack clash style attacks.</source>
          <target state="translated">운영 체제에서 제공 한 스택 가드의 크기를 2 바이트 에서 &lt;var&gt;num&lt;/var&gt; 바이트로 지정하십시오. 값이 클수록 명시 적 프로브의 수는 줄어들지 만 운영 체제에서 제공 한 가드보다 큰 값은 스택 충돌 스타일 공격에 코드를 취약하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="4bee625f3585900ec98450bcf9d2c818f2c00803" translate="yes" xml:space="preserve">
          <source>Specify the struct-like types for which the compiler generates debug information. The intent is to reduce duplicate struct debug information between different object files within the same program.</source>
          <target state="translated">컴파일러가 디버그 정보를 생성하는 구조체와 유사한 유형을 지정하십시오. 의도는 동일한 프로그램 내에서 다른 오브젝트 파일 사이의 중복 struct 디버그 정보를 줄이는 것입니다.</target>
        </trans-unit>
        <trans-unit id="4e0fd0bd7b4133166f8983f5ca490beae5286735" translate="yes" xml:space="preserve">
          <source>Specify the width of the &lt;code&gt;lp_count&lt;/code&gt; register. Valid values for &lt;var&gt;width&lt;/var&gt; are 8, 16, 20, 24, 28 and 32 bits. The default width is fixed to 32 bits. If the width is less than 32, the compiler does not attempt to transform loops in your program to use the zero-delay loop mechanism unless it is known that the &lt;code&gt;lp_count&lt;/code&gt; register can hold the required loop-counter value. Depending on the width specified, the compiler and run-time library might continue to use the loop mechanism for various needs. This option defines macro &lt;code&gt;__ARC_LPC_WIDTH__&lt;/code&gt; with the value of &lt;var&gt;width&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;lp_count&lt;/code&gt; 레지스터 의 너비를 지정하십시오 . &lt;var&gt;width&lt;/var&gt; 유효한 값 은 8, 16, 20, 24, 28 및 32 비트입니다. 기본 너비는 32 비트로 고정됩니다. 너비가 32보다 작은 경우 &lt;code&gt;lp_count&lt;/code&gt; 레지스터가 필요한 루프 카운터 값을 보유 할 수 있다는 것이 알려지지 않은 경우 컴파일러는 프로그램에서 루프를 변환하여 0 지연 루프 메커니즘을 사용하지 않습니다 . 지정된 너비에 따라 컴파일러 및 런타임 라이브러리는 다양한 요구에 따라 루프 메커니즘을 계속 사용할 수 있습니다. 이 옵션은 매크로 값 &lt;code&gt;__ARC_LPC_WIDTH__&lt;/code&gt; 를 &lt;var&gt;width&lt;/var&gt; 값으로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="ef84b64c518f868fe3c1456dcd8b940ed2f5f518" translate="yes" xml:space="preserve">
          <source>Specify thread pointer register number.</source>
          <target state="translated">스레드 포인터 레지스터 번호를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="0795a2fa90067cc8a239666f6041471cc59a29ac" translate="yes" xml:space="preserve">
          <source>Specify whether GCC may generate code that reads from executable sections. There are three possible settings:</source>
          <target state="translated">GCC가 실행 가능 섹션에서 읽는 코드를 생성 할 수 있는지 여부를 지정하십시오. 세 가지 가능한 설정이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d19282618f9569137fcb9b5340c3ea42b2a33ba2" translate="yes" xml:space="preserve">
          <source>Specify whether GCC should insert cache barriers to avoid the side effects of speculation on R10K processors.</source>
          <target state="translated">R10K 프로세서에 대한 추측의 부작용을 피하기 위해 GCC가 캐시 장벽을 삽입해야하는지 여부를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="1440f232d0fc9c6f8894e1bd99ffd6ec679cd656" translate="yes" xml:space="preserve">
          <source>Specify which floating-point unit to use. You must specify the &lt;code&gt;target(&quot;fpmath=sse,387&quot;)&lt;/code&gt; option as &lt;code&gt;target(&quot;fpmath=sse+387&quot;)&lt;/code&gt; because the comma would separate different options.</source>
          <target state="translated">사용할 부동 소수점 단위를 지정하십시오. 당신은 지정해야 &lt;code&gt;target(&quot;fpmath=sse,387&quot;)&lt;/code&gt; 등의 옵션 &lt;code&gt;target(&quot;fpmath=sse+387&quot;)&lt;/code&gt; 쉼표 다른 옵션을 구분하기 때문.</target>
        </trans-unit>
        <trans-unit id="f360040b863c4a298bd666b8b6b30d2471ac8011" translate="yes" xml:space="preserve">
          <source>Specifying</source>
          <target state="translated">Specifying</target>
        </trans-unit>
        <trans-unit id="99167fd0d0a95abb4e35db3c3f342b56f873f72a" translate="yes" xml:space="preserve">
          <source>Specifying &amp;lsquo;</source>
          <target state="translated">'지정</target>
        </trans-unit>
        <trans-unit id="d1885b005623a5f02d47b85a83ced0900c30f8b7" translate="yes" xml:space="preserve">
          <source>Specifying a combination that is not valid for the current architecture causes GCC to synthesize the instructions using a narrower mode. For example, if you specify a variable of type &lt;code&gt;V4SI&lt;/code&gt; and your architecture does not allow for this specific SIMD type, GCC produces code that uses 4 &lt;code&gt;SIs&lt;/code&gt;.</source>
          <target state="translated">현재 아키텍처에 유효하지 않은 조합을 지정하면 GCC는 더 좁은 모드를 사용하여 명령어를 합성합니다. 예를 들어 &lt;code&gt;V4SI&lt;/code&gt; 유형의 변수를 지정하고 아키텍처에서이 특정 SIMD 유형을 허용하지 않으면 GCC는 4 &lt;code&gt;SIs&lt;/code&gt; 를 사용하는 코드를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="2e7e05645dcca05e87ea389d828aa6bfe5f9fa1f" translate="yes" xml:space="preserve">
          <source>Specifying a larger number can produce faster, more efficient code, but can also increase the size of the program. Different values are potentially incompatible. Code compiled with one value cannot necessarily expect to work with code or libraries compiled with another value, if they exchange information using structures or unions.</source>
          <target state="translated">더 큰 수를 지정하면 더 빠르고 효율적인 코드를 생성 할 수 있지만 프로그램 크기를 늘릴 수도 있습니다. 다른 값은 호환되지 않을 수 있습니다. 한 값으로 컴파일 된 코드는 구조 또는 공용체를 사용하여 정보를 교환하는 경우 다른 값으로 컴파일 된 코드 또는 라이브러리와 작동 할 것으로 예상 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="03c6ae3356882b0eeb6636e77ccaa0aba81823b0" translate="yes" xml:space="preserve">
          <source>Specifying attributes of types.</source>
          <target state="translated">유형의 속성 지정</target>
        </trans-unit>
        <trans-unit id="9e1c53b45f7e03f5a8d931294deb320e271bf08b" translate="yes" xml:space="preserve">
          <source>Specifying attributes of variables.</source>
          <target state="translated">변수의 속성 지정</target>
        </trans-unit>
        <trans-unit id="5db2ee21c24dcdf45bcae194cf2ecad708afe6a7" translate="yes" xml:space="preserve">
          <source>Specifying attributes on enumerators.</source>
          <target state="translated">열거 자에 속성 지정</target>
        </trans-unit>
        <trans-unit id="ae68580bc0d24f5d44a4b1108b3374a4cbf533b1" translate="yes" xml:space="preserve">
          <source>Specifying attributes on labels.</source>
          <target state="translated">레이블에 속성 지정</target>
        </trans-unit>
        <trans-unit id="6f4d8f85b31cb45df6efc5370ca55a06e5b2185a" translate="yes" xml:space="preserve">
          <source>Specifying attributes on statements.</source>
          <target state="translated">명령문에 속성 지정</target>
        </trans-unit>
        <trans-unit id="c4fb77efc8cd285dcec19a190e5fd370517a59b0" translate="yes" xml:space="preserve">
          <source>Specifying conventions for function calls, data layout and register usage.</source>
          <target state="translated">함수 호출, 데이터 레이아웃 및 레지스터 사용법에 대한 규칙을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="8a322c1f2da20dac777d0e24ef37843a3925d344" translate="yes" xml:space="preserve">
          <source>Specifying libraries and so on.</source>
          <target state="translated">라이브러리 지정 등.</target>
        </trans-unit>
        <trans-unit id="35c808a95c8bd97d1d48f311fe3d1ff9cbb26d16" translate="yes" xml:space="preserve">
          <source>Specifying target attributes on individual functions or performing link-time optimization across translation units compiled with different target options can affect function inlining rules:</source>
          <target state="translated">개별 함수에서 대상 속성을 지정하거나 다른 대상 옵션으로 컴파일 된 변환 단위에서 링크 시간 최적화를 수행하면 함수 인라인 규칙에 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ee9cc1aa83bf2a8aaa7d549089eae697b9df2fe" translate="yes" xml:space="preserve">
          <source>Specifying the</source>
          <target state="translated">지정</target>
        </trans-unit>
        <trans-unit id="be769970f9d0ab94f326ad5f60920cc958cef495" translate="yes" xml:space="preserve">
          <source>Specifying the assembler name to use for a C symbol.</source>
          <target state="translated">C 심볼에 사용할 어셈블러 이름을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="b768e2f08c0d665e3b9b9a2f57c49ac37e0b4986" translate="yes" xml:space="preserve">
          <source>Speculation Barrier Instruction.</source>
          <target state="translated">투기 방벽 지시.</target>
        </trans-unit>
        <trans-unit id="e39eb4a0ece25ea3aad502401ffe4e7271da49e1" translate="yes" xml:space="preserve">
          <source>Speculatively hoist loads from both branches of an if-then-else if the loads are from adjacent locations in the same structure and the target architecture has a conditional move instruction. This flag is enabled by default at</source>
          <target state="translated">하중이 동일한 구조의 인접한 위치에서 왔고 대상 아키텍처에 조건부 이동 명령이있는 경우 if-then-else의 두 분기에서 추측 적으로 하중을 가중시킵니다. 이 플래그는 기본적으로</target>
        </trans-unit>
        <trans-unit id="e6c7808e8703d45ea319f5ac9cfea72c1d3b2c26" translate="yes" xml:space="preserve">
          <source>Split 32-byte AVX unaligned load and store.</source>
          <target state="translated">32 바이트 AVX 정렬되지 않은로드 및 저장.</target>
        </trans-unit>
        <trans-unit id="a66f8bdb0cdd7c740f8bab1b871317c083f59cec" translate="yes" xml:space="preserve">
          <source>Split a loop into two if it contains a condition that&amp;rsquo;s always true for one side of the iteration space and false for the other.</source>
          <target state="translated">반복 공간의 한쪽에 대해 항상 참이고 다른쪽에 대해 거짓 인 조건이 포함 된 경우 루프를 두 개로 나눕니다.</target>
        </trans-unit>
        <trans-unit id="7e793f0b9e2c47f7ff51cea5a83ac494564f9b01" translate="yes" xml:space="preserve">
          <source>Split paths leading to loop backedges. This can improve dead code elimination and common subexpression elimination. This is enabled by default at</source>
          <target state="translated">루프 백 에지로 이어지는 분할 경로. 이는 데드 코드 제거 및 공통 하위 표현식 제거를 향상시킬 수 있습니다. 이것은 기본적으로 활성화되어 있습니다</target>
        </trans-unit>
        <trans-unit id="c19cf5ca00368b6bf60823f07c7f7db52961a1db" translate="yes" xml:space="preserve">
          <source>Split the include path. This option has been deprecated. Please use</source>
          <target state="translated">포함 경로를 분할하십시오. 이 옵션은 더 이상 사용되지 않습니다. 사용하십시오</target>
        </trans-unit>
        <trans-unit id="03d6628c91b12235f628c3f0849b814233af5af3" translate="yes" xml:space="preserve">
          <source>Split vector moves into single word moves before reload. In theory this can give better register allocation, but so far the reverse seems to be generally the case.</source>
          <target state="translated">다시로드하기 전에 분할 벡터가 단일 단어 이동으로 이동합니다. 이론적으로 이것은 더 나은 레지스터 할당을 줄 수 있지만, 지금까지는 그 반대가 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="9b6e2276ec4ca5446d91dd4b3bca6fc9336a2104" translate="yes" xml:space="preserve">
          <source>Stack clash protection involves probing stack space as it is allocated. This param controls the maximum distance between probes into the stack as 2 raised to &lt;var&gt;num&lt;/var&gt; bytes. Higher values may reduce the number of explicit probes, but a value larger than the operating system provided guard will leave code vulnerable to stack clash style attacks.</source>
          <target state="translated">스택 충돌 보호에는 스택 공간이 할당 될 때 프로빙이 포함됩니다. 이 매개 변수는 프로브에서 스택까지의 최대 거리를 2 바이트 에서 &lt;var&gt;num&lt;/var&gt; 바이트로 올림으로 제어 합니다. 값이 클수록 명시 적 프로브의 수가 줄어들 수 있지만 운영 체제에서 제공 한 가드보다 큰 값은 스택 충돌 스타일 공격에 코드를 취약하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="42423254dd8ef2b598b3ee0e697e74e7db04abbc" translate="yes" xml:space="preserve">
          <source>Stack pointer register (SP).</source>
          <target state="translated">스택 포인터 레지스터 (SP).</target>
        </trans-unit>
        <trans-unit id="1d47e20f0d3ac51ec48cf366af32c77c2669b54f" translate="yes" xml:space="preserve">
          <source>Stack pointer register (SPH:SPL)</source>
          <target state="translated">스택 포인터 레지스터 (SPH : SPL)</target>
        </trans-unit>
        <trans-unit id="d8ceeae642420027f1322393a2a3a2e2bcca2060" translate="yes" xml:space="preserve">
          <source>Stack register $sp.</source>
          <target state="translated">스택 레지스터 $ sp.</target>
        </trans-unit>
        <trans-unit id="19b7dc1683e0d583c27f00412d344ea74bdf5a0a" translate="yes" xml:space="preserve">
          <source>Stack variables are not affected by linker restrictions; GCC can properly align them on any target.</source>
          <target state="translated">스택 변수는 링커 제한의 영향을받지 않습니다. GCC는 모든 대상에 올바르게 정렬 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac5a8f549a994c1b8e4dd80d24db9f3996eea422" translate="yes" xml:space="preserve">
          <source>Standard 80387 floating point constant.</source>
          <target state="translated">표준 80387 부동 소수점 상수.</target>
        </trans-unit>
        <trans-unit id="257c765fd4761dbfb8a7c22158ae9ccc2a9c0d89" translate="yes" xml:space="preserve">
          <source>Standard C requires that pointer types used with &lt;code&gt;va_arg&lt;/code&gt; in functions with variable argument lists either must be compatible with that of the actual argument, or that one type must be a pointer to &lt;code&gt;void&lt;/code&gt; and the other a pointer to a character type. GNU C implements the POSIX XSI extension that additionally permits the use of &lt;code&gt;va_arg&lt;/code&gt; with a pointer type to receive arguments of any other pointer type.</source>
          <target state="translated">표준 C에서는 가변 인수 목록이있는 함수에서 &lt;code&gt;va_arg&lt;/code&gt; 와 함께 사용되는 포인터 유형 이 실제 인수의 유형과 호환 가능하거나 한 유형이 &lt;code&gt;void&lt;/code&gt; 에 대한 포인터 이고 다른 유형이 문자 유형에 대한 포인터 여야합니다 . GNU C는 POSIX XSI 확장을 구현하여 포인터 유형과 함께 &lt;code&gt;va_arg&lt;/code&gt; 를 사용하여 다른 포인터 유형의 인수를 수신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f7654adc68a64f36e03bf390845ec45238411d8" translate="yes" xml:space="preserve">
          <source>Standard C90 requires the elements of an initializer to appear in a fixed order, the same as the order of the elements in the array or structure being initialized.</source>
          <target state="translated">표준 C90에서는 초기화하는 요소가 초기화되는 배열 또는 구조의 요소 순서와 같은 고정 된 순서로 표시되어야합니다.</target>
        </trans-unit>
        <trans-unit id="b23b0b38a39d349a3165d9fefce6588293b09611" translate="yes" xml:space="preserve">
          <source>Standard system directories are scanned.</source>
          <target state="translated">표준 시스템 디렉토리가 스캔됩니다.</target>
        </trans-unit>
        <trans-unit id="7f3657857ae8fa83a5a6acb61ee0490999a1f0da" translate="yes" xml:space="preserve">
          <source>Start a RTM (Restricted Transactional Memory) transaction. Returns &lt;code&gt;_XBEGIN_STARTED&lt;/code&gt; when the transaction started successfully (note this is not 0, so the constant has to be explicitly tested).</source>
          <target state="translated">RTM (Restricted Transactional Memory) 트랜잭션을 시작하십시오. 트랜잭션이 성공적으로 시작되면 &lt;code&gt;_XBEGIN_STARTED&lt;/code&gt; 를 리턴합니다 (이 값이 0이 아니므로 상수를 명시 적으로 테스트해야 함).</target>
        </trans-unit>
        <trans-unit id="d321cb5e91b977aa5f4a76bb28fcd908795d2d2b" translate="yes" xml:space="preserve">
          <source>Start lock elision on a lock variable. Memory order must be &lt;code&gt;__ATOMIC_ACQUIRE&lt;/code&gt; or stronger.</source>
          <target state="translated">잠금 변수에서 잠금 제거를 시작하십시오. 메모리 순서는 &lt;code&gt;__ATOMIC_ACQUIRE&lt;/code&gt; 이상 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="d710b21a9b9bf4c6c45243e4c0bf0c7460f48764" translate="yes" xml:space="preserve">
          <source>Starting with GCC 3.2, GCC binary conventions for C++ are based on a written, vendor-neutral C++ ABI that was designed to be specific to 64-bit Itanium but also includes generic specifications that apply to any platform. This C++ ABI is also implemented by other compiler vendors on some platforms, notably GNU/Linux and BSD systems. We have tried hard to provide a stable ABI that will be compatible with future GCC releases, but it is possible that we will encounter problems that make this difficult. Such problems could include different interpretations of the C++ ABI by different vendors, bugs in the ABI, or bugs in the implementation of the ABI in different compilers. GCC&amp;rsquo;s</source>
          <target state="translated">GCC 3.2부터 C ++에 대한 GCC 바이너리 규칙은 64 비트 Itanium에 맞게 설계되었지만 모든 플랫폼에 적용되는 일반 사양을 포함하는 공급 업체 중립적 인 C ++ ABI를 기반으로합니다. 이 C ++ ABI는 일부 플랫폼, 특히 GNU / Linux 및 BSD 시스템의 다른 컴파일러 공급 업체에서도 구현합니다. 향후 GCC 릴리스와 호환 될 안정적인 ABI를 제공하려고 노력했지만이를 어렵게 만드는 문제가 발생할 수 있습니다. 이러한 문제에는 다른 공급 업체에 의한 C ++ ABI의 다른 해석, ABI의 버그 또는 다른 컴파일러의 ABI 구현 버그가 포함될 수 있습니다. GCC</target>
        </trans-unit>
        <trans-unit id="e0603cbbfdea44aa94fc492612a783b691bd4ebd" translate="yes" xml:space="preserve">
          <source>Starting with GCC 4.7.0, the traditional GNU runtime API is no longer available.</source>
          <target state="translated">GCC 4.7.0부터는 기존 GNU 런타임 API를 더 이상 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0d99177a777348b93d27364c0bfe456087ad31a7" translate="yes" xml:space="preserve">
          <source>Statement Attributes</source>
          <target state="translated">명령문 속성</target>
        </trans-unit>
        <trans-unit id="9a5ff5b401235fc57fb6c95d79c8c8b7116e1c37" translate="yes" xml:space="preserve">
          <source>States an expression as an assumption, and if possible, verifies that the assumption is valid. For example, &lt;code&gt;assume(n &amp;gt; 0)&lt;/code&gt;.</source>
          <target state="translated">표현을 가정으로 표시하고 가능한 경우 가정이 유효한지 확인합니다. 예를 들어, &lt;code&gt;assume(n &amp;gt; 0)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c22f2edc68615de37762f51b4fa28235f463b8f3" translate="yes" xml:space="preserve">
          <source>Static Analyzer Options</source>
          <target state="translated">정적 분석기 옵션</target>
        </trans-unit>
        <trans-unit id="0f44280770a4ee1097a4edddc52f0cd05d85a900" translate="yes" xml:space="preserve">
          <source>Static libraries are archives of object files, and have file names like</source>
          <target state="translated">정적 라이브러리는 객체 파일의 아카이브이며 다음과 같은 파일 이름을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="c46e734f5fd8510b9e062efd2082eeb14db6af81" translate="yes" xml:space="preserve">
          <source>Static member declarations are not definitions</source>
          <target state="translated">정적 멤버 선언은 정의가 아닙니다</target>
        </trans-unit>
        <trans-unit id="d94ff9dc4d646834a0535298621e393784d6f1d3" translate="yes" xml:space="preserve">
          <source>Stop after the preprocessing stage; do not run the compiler proper. The output is in the form of preprocessed source code, which is sent to the standard output.</source>
          <target state="translated">전처리 단계 후 중지하십시오. 컴파일러를 올바르게 실행하지 마십시오. 출력은 사전 처리 된 소스 코드 형식으로 표준 출력으로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="2daee47861dfd3c59bf8ff060a32e292f65fec05" translate="yes" xml:space="preserve">
          <source>Stop after the stage of compilation proper; do not assemble. The output is in the form of an assembler code file for each non-assembler input file specified.</source>
          <target state="translated">컴파일 단계가 끝나면 중지하십시오. 조립하지 마십시오. 출력은 지정된 각 비 어셈블러 입력 파일에 대한 어셈블러 코드 파일 형식입니다.</target>
        </trans-unit>
        <trans-unit id="8347e9bfc02ac3a60787813c10d80e9ff680d75e" translate="yes" xml:space="preserve">
          <source>Stop forward growth if the best edge has probability lower than this threshold.</source>
          <target state="translated">최상의 에지가이 임계 값보다 낮은 확률을 가지면 앞으로 성장을 중지하십시오.</target>
        </trans-unit>
        <trans-unit id="93e3b1851a75fdb25f8f9ca9807e49174553cf12" translate="yes" xml:space="preserve">
          <source>Stop forward growth if the probability of best edge is less than this threshold (in percent). Used when profile feedback is available.</source>
          <target state="translated">최상의 에지 확률이이 임계 값 (%)보다 작 으면 앞으로 성장을 중지하십시오. 프로파일 피드백이 사용 가능한 경우에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5b2c101566fb4988550c86b87f1d88d336f66263" translate="yes" xml:space="preserve">
          <source>Stop reverse growth when the reverse probability of best edge is less than this threshold (in percent).</source>
          <target state="translated">최고 에지의 역 확률이이 임계 값보다 작은 경우 역 성장을 중지하십시오 (백분율).</target>
        </trans-unit>
        <trans-unit id="5b4aff278c0fdce3e7f55f32e7c895daaa47f804" translate="yes" xml:space="preserve">
          <source>Stop tail duplication once code growth has reached given percentage. This is a rather artificial limit, as most of the duplicates are eliminated later in cross jumping, so it may be set to much higher values than is the desired code growth.</source>
          <target state="translated">코드 증가가 주어진 백분율에 도달하면 꼬리 복제를 중지합니다. 이것은 대부분의 복제물이 나중에 크로스 점프에서 제거되므로 원하는 코드 증가보다 훨씬 높은 값으로 설정 될 수 있기 때문에 다소 인공적인 한계입니다.</target>
        </trans-unit>
        <trans-unit id="e5524f873f830633dc8a23de8cf2d30b3d74c34d" translate="yes" xml:space="preserve">
          <source>Store (do not store) the address of the caller&amp;rsquo;s frame as backchain pointer into the callee&amp;rsquo;s stack frame. A backchain may be needed to allow debugging using tools that do not understand DWARF call frame information. When</source>
          <target state="translated">발신자의 프레임 주소를 수신자의 스택 프레임에 백 체인 포인터로 저장 (저장하지 않음)합니다. DWARF 호출 프레임 정보를 이해하지 못하는 도구를 사용하여 디버깅을 허용하려면 백 체인이 필요할 수 있습니다. 언제</target>
        </trans-unit>
        <trans-unit id="b16037d0dfeba50e99ce7619111826617ed26b77" translate="yes" xml:space="preserve">
          <source>Store data (but not code) in the big-endian format. The default is</source>
          <target state="translated">빅 엔디안 형식으로 데이터 (코드는 아님)를 저장하십시오. 디폴트는</target>
        </trans-unit>
        <trans-unit id="d1b3895de4641414ac79dc4d41b3d54519e0dbbf" translate="yes" xml:space="preserve">
          <source>Store the usual &amp;ldquo;temporary&amp;rdquo; intermediate files permanently. If the</source>
          <target state="translated">일반적인 &quot;임시&quot;중간 파일을 영구적으로 저장하십시오. 만약</target>
        </trans-unit>
        <trans-unit id="825a3542481737ba30d5e3c1a289571cd11217e5" translate="yes" xml:space="preserve">
          <source>Store the usual &amp;ldquo;temporary&amp;rdquo; intermediate files permanently; place them in the current directory and name them based on the source file. Thus, compiling</source>
          <target state="translated">일반적인 &quot;임시&quot;중간 파일을 영구적으로 저장하십시오. 현재 디렉토리에 배치하고 소스 파일을 기반으로 이름을 지정하십시오. 따라서 컴파일</target>
        </trans-unit>
        <trans-unit id="6a52a11a90147dcb5f7e83906aec646860b00234" translate="yes" xml:space="preserve">
          <source>Storing into the pointer can be done likewise with the same union.</source>
          <target state="translated">포인터에 저장하는 것은 동일한 조합으로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e43c92861ad3e02cc7239ce0887aa080085a685" translate="yes" xml:space="preserve">
          <source>Storing the new address in &lt;code&gt;*&lt;var&gt;ra-address&lt;/var&gt;&lt;/code&gt;, if &lt;var&gt;ra-address&lt;/var&gt; is nonnull.</source>
          <target state="translated">&lt;var&gt;ra-address&lt;/var&gt; 가 널이 아닌 경우 새 주소를 &lt;code&gt;*&lt;var&gt;ra-address&lt;/var&gt;&lt;/code&gt; address에 저장</target>
        </trans-unit>
        <trans-unit id="d51f83d4384be85e0661264f111bae505e048852" translate="yes" xml:space="preserve">
          <source>Stream extra information needed for aggressive devirtualization when running the link-time optimizer in local transformation mode. This option enables more devirtualization but significantly increases the size of streamed data. For this reason it is disabled by default.</source>
          <target state="translated">로컬 변환 모드에서 링크 시간 최적화 프로그램을 실행할 때 공격적인 가상화에 필요한 추가 정보를 스트리밍하십시오. 이 옵션을 사용하면 더 많은 가상화가 가능하지만 스트리밍 데이터의 크기가 크게 늘어납니다. 이러한 이유로 기본적으로 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="474bfcc8400d6e8dacea61eec4b30865208de5b9" translate="yes" xml:space="preserve">
          <source>Structure members are stored sequentially in the order in which they are declared: the first member has the lowest memory address and the last member the highest.</source>
          <target state="translated">구조 멤버는 선언 된 순서대로 순차적으로 저장됩니다. 첫 번째 멤버는 가장 낮은 메모리 주소를 가지고 마지막 멤버는 가장 높은 주소를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="c3de1ed2a463e2a1c2ff86baf892b9da62d4e4d8" translate="yes" xml:space="preserve">
          <source>Structure of the JSON is following:</source>
          <target state="translated">JSON의 구조는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4a4ea855e21caf3a76611861328cfb1249cb6b2a" translate="yes" xml:space="preserve">
          <source>Structures with no members.</source>
          <target state="translated">멤버가없는 구조</target>
        </trans-unit>
        <trans-unit id="9075bc2ab7ab689b643437d474f305a0857530db" translate="yes" xml:space="preserve">
          <source>Stubs are generated automatically by the linker if the following two conditions are met:</source>
          <target state="translated">다음 두 조건이 충족되면 링커에서 스텁을 자동으로 생성합니다.</target>
        </trans-unit>
        <trans-unit id="9013b380508240de43628bfd190a9b994da8e678" translate="yes" xml:space="preserve">
          <source>Substitute a file name that has suffix &lt;var&gt;suffix&lt;/var&gt; and is chosen once per compilation, and mark the argument in the same way as &amp;lsquo;</source>
          <target state="translated">접미사가 파일 이름으로 대체 &lt;var&gt;suffix&lt;/var&gt; 및 편집에 한 번 선택, 그리고 '과 같은 방법으로 인수를 표시</target>
        </trans-unit>
        <trans-unit id="5a84f064e80a6c0f3317c7855f9c6ac2c41131d2" translate="yes" xml:space="preserve">
          <source>Substitute any of</source>
          <target state="translated">다음 중 하나를 대체하십시오</target>
        </trans-unit>
        <trans-unit id="998b2b0ec7c7cc0618199202723cd62e2208d036" translate="yes" xml:space="preserve">
          <source>Substitute one &amp;lsquo;</source>
          <target state="translated">하나를 '</target>
        </trans-unit>
        <trans-unit id="2d0f6708feea91da92348701c1acca054bd497b6" translate="yes" xml:space="preserve">
          <source>Substitute the basename of the input file being processed. This is the substring up to (and not including) the last period and not including the directory.</source>
          <target state="translated">처리중인 입력 파일의 기본 이름을 대체하십시오. 이것은 마지막 기간까지의 하위 문자열이며 디렉토리를 포함하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1de1b430997906cd235f8cdbc3a04979f0ce1846" translate="yes" xml:space="preserve">
          <source>Substitute the contents of spec string &lt;var&gt;name&lt;/var&gt; at this point.</source>
          <target state="translated">이 시점에서 스펙 문자열 &lt;var&gt;name&lt;/var&gt; 의 내용을 대체하십시오 .</target>
        </trans-unit>
        <trans-unit id="fd2fde2ae73c8516cb1a3cac098e2359e8a7c33a" translate="yes" xml:space="preserve">
          <source>Substitute the name of the input file being processed.</source>
          <target state="translated">처리중인 입력 파일의 이름을 대체하십시오.</target>
        </trans-unit>
        <trans-unit id="ae8eaa414e533e6922c45c08150cca1cb19b9be1" translate="yes" xml:space="preserve">
          <source>Substitute the variable part of a matched option. See below. Note that each comma in the substituted string is replaced by a single space.</source>
          <target state="translated">일치하는 옵션의 변수 부분을 대체하십시오. 아래를 참조하십시오. 대체 된 문자열의 각 쉼표는 단일 공백으로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="43dec03cdd027bda7c71fa5dcb7ea1dab00d8963" translate="yes" xml:space="preserve">
          <source>Substitutes &lt;code&gt;X&lt;/code&gt; if either &lt;code&gt;-S&lt;/code&gt; or &lt;code&gt;-P&lt;/code&gt; is given to GCC. This may be combined with &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;-S&lt;/code&gt; 또는 &lt;code&gt;-P&lt;/code&gt; 가 GCC에 제공 되면 &lt;code&gt;X&lt;/code&gt; 를 대체 합니다. 이것은 '</target>
        </trans-unit>
        <trans-unit id="e6be527872250ba01c3017e89b857046ca96045c" translate="yes" xml:space="preserve">
          <source>Substitutes &lt;code&gt;X&lt;/code&gt; if one or more switches whose names start with &lt;code&gt;-S&lt;/code&gt; are specified to GCC. Normally &lt;code&gt;X&lt;/code&gt; is substituted only once, no matter how many such switches appeared. However, if &lt;code&gt;%*&lt;/code&gt; appears somewhere in &lt;code&gt;X&lt;/code&gt;, then &lt;code&gt;X&lt;/code&gt; is substituted once for each matching switch, with the &lt;code&gt;%*&lt;/code&gt; replaced by the part of that switch matching the &lt;code&gt;*&lt;/code&gt;.</source>
          <target state="translated">이름이 &lt;code&gt;-S&lt;/code&gt; 로 시작하는 하나 이상의 스위치가 GCC로 지정된 경우 &lt;code&gt;X&lt;/code&gt; 를 대체 합니다. 일반적으로 &lt;code&gt;X&lt;/code&gt; 는 이러한 스위치의 수에 관계없이 한 번만 대체됩니다. 그러나 &lt;code&gt;%*&lt;/code&gt; 어딘가에 표시 &lt;code&gt;X&lt;/code&gt; 후 &lt;code&gt;X&lt;/code&gt; 는 와 일치하는 각 스위치에 대해 한 번 치환 &lt;code&gt;%*&lt;/code&gt; 매칭 해당 스위치의 부품으로 대체 &lt;code&gt;*&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="786d7f6a8f7f27970f79f53feb14051559d33597" translate="yes" xml:space="preserve">
          <source>Substitutes &lt;code&gt;X&lt;/code&gt;, if &lt;em&gt;not&lt;/em&gt; processing a file with suffix &lt;code&gt;S&lt;/code&gt;.</source>
          <target state="translated">접미사가 &lt;code&gt;S&lt;/code&gt; 인 파일을 처리 &lt;em&gt;하지 않는&lt;/em&gt; 경우 &lt;code&gt;X&lt;/code&gt; 를 대체 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="864ccc2fa9d07c116ad04b8eeaefd7787e81b65c" translate="yes" xml:space="preserve">
          <source>Substitutes &lt;code&gt;X&lt;/code&gt;, if not processing a file for language &lt;code&gt;S&lt;/code&gt;.</source>
          <target state="translated">언어 &lt;code&gt;S&lt;/code&gt; 에 대한 파일을 처리하지 않는 경우 &lt;code&gt;X&lt;/code&gt; 를 대체 합니다.</target>
        </trans-unit>
        <trans-unit id="64dfa62f2736f224c236543aa31324e1526b2435" translate="yes" xml:space="preserve">
          <source>Substitutes &lt;code&gt;X&lt;/code&gt;, if processing a file for language &lt;code&gt;S&lt;/code&gt;.</source>
          <target state="translated">언어 &lt;code&gt;S&lt;/code&gt; 의 파일을 처리하는 경우 &lt;code&gt;X&lt;/code&gt; 를 대체 합니다.</target>
        </trans-unit>
        <trans-unit id="a6dded313927000e1a3934ea810bce16c0a202a3" translate="yes" xml:space="preserve">
          <source>Substitutes &lt;code&gt;X&lt;/code&gt;, if processing a file with suffix &lt;code&gt;S&lt;/code&gt;.</source>
          <target state="translated">접미사 &lt;code&gt;S&lt;/code&gt; 로 파일을 처리하는 경우 &lt;code&gt;X&lt;/code&gt; 를 대체 합니다.</target>
        </trans-unit>
        <trans-unit id="d0531e0f44345fcee0b59ff85181d8e187cb0d34" translate="yes" xml:space="preserve">
          <source>Substitutes &lt;code&gt;X&lt;/code&gt;, if the</source>
          <target state="translated">&lt;code&gt;X&lt;/code&gt; 를 대체 합니다.</target>
        </trans-unit>
        <trans-unit id="381da79492b4d41df2595656917a76e838b4035d" translate="yes" xml:space="preserve">
          <source>Substitutes &lt;var&gt;.SUFFIX&lt;/var&gt; for the suffixes of a matched switch&amp;rsquo;s args when it is subsequently output with &amp;lsquo;</source>
          <target state="translated">대용 &lt;var&gt;.SUFFIX&lt;/var&gt; 은 출력과 후속 때 '정합 스위치의 인수의 접미사</target>
        </trans-unit>
        <trans-unit id="330d507dbe426595b8910e78b9c215b447059d1c" translate="yes" xml:space="preserve">
          <source>Substitutes all the switches specified to GCC whose names start with &lt;code&gt;-S&lt;/code&gt;, but which also take an argument. This is used for switches like</source>
          <target state="translated">이름이 &lt;code&gt;-S&lt;/code&gt; 로 시작 하지만 인수를 갖는 GCC로 지정된 모든 스위치를 대체합니다 . 이것은 다음과 같은 스위치에 사용됩니다</target>
        </trans-unit>
        <trans-unit id="83c0a4e01bdd2a1adfb064f09d23d09f40d1cc63" translate="yes" xml:space="preserve">
          <source>Substitutes the &lt;code&gt;-S&lt;/code&gt; switch, if that switch is given to GCC. If that switch is not specified, this substitutes nothing. Note that the leading dash is omitted when specifying this option, and it is automatically inserted if the substitution is performed. Thus the spec string &amp;lsquo;</source>
          <target state="translated">해당 스위치가 GCC에 제공되면 &lt;code&gt;-S&lt;/code&gt; 스위치를 대체합니다 . 해당 스위치를 지정하지 않으면 아무것도 대체하지 않습니다. 이 옵션을 지정할 때는 선행 대시가 생략되며 대체를 수행하면 자동으로 삽입됩니다. 따라서 사양 문자열 '</target>
        </trans-unit>
        <trans-unit id="3c13db3d4f7d55a97362e7f68ba24cf3424c2837" translate="yes" xml:space="preserve">
          <source>Substitutes the last file name generated with &amp;lsquo;</source>
          <target state="translated">'로 생성 된 마지막 파일 이름을'</target>
        </trans-unit>
        <trans-unit id="4b4f52841be7dd8b1c205fb48bea71f8dc73cc8b" translate="yes" xml:space="preserve">
          <source>Substitutes the name of the &lt;code&gt;HOST_BIT_BUCKET&lt;/code&gt;, if any, and if it is writable, and if</source>
          <target state="translated">&lt;code&gt;HOST_BIT_BUCKET&lt;/code&gt; 의 이름 (있는 경우) 및 쓰기 가능한 경우 및</target>
        </trans-unit>
        <trans-unit id="510d92a70f7a6df088d50db8add12d77997610de" translate="yes" xml:space="preserve">
          <source>Substitutes the names of all the output files, with spaces automatically placed around them. You should write spaces around the &amp;lsquo;</source>
          <target state="translated">모든 출력 파일의 이름을 공백으로 자동 대체합니다. '주위에 공백을 써야합니다.</target>
        </trans-unit>
        <trans-unit id="37e406a2f9f9f2524ce85dd8f1df47e0fcb53fb6" translate="yes" xml:space="preserve">
          <source>Substitutes the standard macro predefinitions for the current target machine. Use this when running &lt;code&gt;cpp&lt;/code&gt;.</source>
          <target state="translated">현재 대상 시스템의 표준 매크로 사전 정의를 대체합니다. &lt;code&gt;cpp&lt;/code&gt; 를 실행할 때 이것을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="601b96766181d9e1c5aa982978f52e20aab04d35" translate="yes" xml:space="preserve">
          <source>Substitutes the suffix for object files. Note that this is handled specially when it immediately follows &amp;lsquo;</source>
          <target state="translated">오브젝트 파일의 접미 부를 대체합니다. 이는 '바로 다음에 올 때 특별히 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="ebb148237b08e3751f6fc1e4dce1cbcd763ff06d" translate="yes" xml:space="preserve">
          <source>Subtraction, multiplication, division, and the logical operations operate in a similar manner. Likewise, the result of using the unary minus or complement operators on a vector type is a vector whose elements are the negative or complemented values of the corresponding elements in the operand.</source>
          <target state="translated">빼기, 곱하기, 나누기 및 논리 연산은 비슷한 방식으로 작동합니다. 마찬가지로, 벡터 유형에 단항 빼기 또는 보수 연산자를 사용한 결과는 요소가 피연산자에서 해당 요소의 음수 또는 보수 값인 벡터입니다.</target>
        </trans-unit>
        <trans-unit id="9ed92f9622e5eda43509c60bb3049fa12fe5ec7f" translate="yes" xml:space="preserve">
          <source>Such a feature would work only occasionally&amp;mdash;only for calls that appear in the same file as the called function, following the definition. The only way to check all calls reliably is to add a prototype for the function. But adding a prototype eliminates the motivation for this feature. So the feature is not worthwhile.</source>
          <target state="translated">이러한 기능은 정의에 따라 호출 된 기능과 동일한 파일에 나타나는 호출에 대해서만 가끔 작동합니다. 모든 호출을 안정적으로 확인하는 유일한 방법은 함수의 프로토 타입을 추가하는 것입니다. 그러나 프로토 타입을 추가하면이 기능에 대한 동기가 제거됩니다. 따라서이 기능은 가치가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5af0feab651599b508e437900c6cfc81abd2fe41" translate="yes" xml:space="preserve">
          <source>Such accesses are supported, subject to the same requirements for synchronization for concurrent accesses as for concurrent accesses to any object.</source>
          <target state="translated">이러한 액세스는 모든 개체에 대한 동시 액세스와 동일한 동시 액세스 동기화 요구 사항에 따라 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="4cfbaa1bf62e72b4bca886bc067e3bd96ad98df4" translate="yes" xml:space="preserve">
          <source>Such an array of label values serves a purpose much like that of the &lt;code&gt;switch&lt;/code&gt; statement. The &lt;code&gt;switch&lt;/code&gt; statement is cleaner, so use that rather than an array unless the problem does not fit a &lt;code&gt;switch&lt;/code&gt; statement very well.</source>
          <target state="translated">이러한 레이블 값 배열은 &lt;code&gt;switch&lt;/code&gt; 문과 매우 유사한 용도로 사용 됩니다. &lt;code&gt;switch&lt;/code&gt; 문은 문제가 맞지 않는 아니라면 배열이 아닌 것을 사용, 청소기 &lt;code&gt;switch&lt;/code&gt; 아주 잘 문을.</target>
        </trans-unit>
        <trans-unit id="4348530a5b230f9786021cf2cdbed2168537bbe7" translate="yes" xml:space="preserve">
          <source>Such an object is normally accessed by pointers and used for accessing hardware. In most expressions, it is intuitively obvious what is a read and what is a write. For example</source>
          <target state="translated">이러한 객체는 일반적으로 포인터에 의해 액세스되며 하드웨어 액세스에 사용됩니다. 대부분의 표현에서 읽기와 쓰기가 무엇인지 직관적으로 분명합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="7e9903330f56016812404c897216c2074bedf62f" translate="yes" xml:space="preserve">
          <source>Such argument passing is supported, using the same pass-by-invisible-reference approach used for normal function arguments of such types.</source>
          <target state="translated">이러한 인수 전달은 해당 유형의 일반 함수 인수에 사용 된 것과 같은 보이지 않는 참조 방식을 사용하여 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="fdaf5b5f6a3d1715a900b4b2779de302364392a5" translate="yes" xml:space="preserve">
          <source>Such assignments must be very common; warning about them would cause more annoyance than good.</source>
          <target state="translated">이러한 과제는 매우 일반적이어야합니다. 그들에 대한 경고는 선보다 더 많은 성가심을 유발할 것입니다.</target>
        </trans-unit>
        <trans-unit id="fc536d9f079301ea3cff9bd45f17bf843dbe50ad" translate="yes" xml:space="preserve">
          <source>Such built-in functions are provided for &lt;code&gt;memcpy&lt;/code&gt;, &lt;code&gt;mempcpy&lt;/code&gt;, &lt;code&gt;memmove&lt;/code&gt;, &lt;code&gt;memset&lt;/code&gt;, &lt;code&gt;strcpy&lt;/code&gt;, &lt;code&gt;stpcpy&lt;/code&gt;, &lt;code&gt;strncpy&lt;/code&gt;, &lt;code&gt;strcat&lt;/code&gt; and &lt;code&gt;strncat&lt;/code&gt;.</source>
          <target state="translated">이러한 내장 함수는 &lt;code&gt;memcpy&lt;/code&gt; , &lt;code&gt;mempcpy&lt;/code&gt; , &lt;code&gt;memmove&lt;/code&gt; , &lt;code&gt;memset&lt;/code&gt; , &lt;code&gt;strcpy&lt;/code&gt; , &lt;code&gt;stpcpy&lt;/code&gt; , &lt;code&gt;strncpy&lt;/code&gt; , &lt;code&gt;strcat&lt;/code&gt; 및 &lt;code&gt;strncat&lt;/code&gt; 에 제공 됩니다.</target>
        </trans-unit>
        <trans-unit id="7a73b44a4d02b7ee2f589148448bb9f1b269841d" translate="yes" xml:space="preserve">
          <source>Such code is suitable for level 0 PA systems and kernels.</source>
          <target state="translated">이러한 코드는 레벨 0 PA 시스템 및 커널에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="221482fe63639c70a1d813f43faebcec11cd2c30" translate="yes" xml:space="preserve">
          <source>Such expressions are rvalues, and GCC implements this as a read of the volatile object being pointed to.</source>
          <target state="translated">이러한 표현은 rvalue이며 GCC는이를 가리키는 휘발성 객체의 읽기로이를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="44cf0f4f846947a1f248438be1e959f7db481213" translate="yes" xml:space="preserve">
          <source>Such tokens may not be concatenated.</source>
          <target state="translated">이러한 토큰은 연결되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bba52ae9199f8bd23584e0938f470a93242074f" translate="yes" xml:space="preserve">
          <source>Support &lt;em&gt;IBM RS/6000 SP&lt;/em&gt;&lt;em&gt;Parallel Environment&lt;/em&gt; (PE). Link an application written to use message passing with special startup code to enable the application to run. The system must have PE installed in the standard location (</source>
          <target state="translated">지원 &lt;em&gt;IBM의 RS / 6000 SP의 &lt;/em&gt;&lt;em&gt;병렬 환경&lt;/em&gt; (PE). 응용 프로그램을 실행할 수 있도록 특수 시작 코드와 함께 메시지 전달을 사용하도록 작성된 응용 프로그램을 연결하십시오. 시스템의 표준 위치에 PE가 설치되어 있어야합니다 (</target>
        </trans-unit>
        <trans-unit id="075bd5530c2b703c7849a9e331065651957bda71" translate="yes" xml:space="preserve">
          <source>Support ISO C trigraphs. These are three-character sequences, all starting with &amp;lsquo;</source>
          <target state="translated">ISO C trigraph를 지원합니다. 이것들은 모두 3 자로 시작하며 모두 '</target>
        </trans-unit>
        <trans-unit id="8219e8938cf7630391bdb51b3542081a049cff2c" translate="yes" xml:space="preserve">
          <source>Support all ISO C90 programs (certain GNU extensions that conflict with ISO C90 are disabled). Same as</source>
          <target state="translated">모든 ISO C90 프로그램을 지원합니다 (ISO C90과 충돌하는 특정 GNU 확장은 비활성화되어 있음). 와 동일</target>
        </trans-unit>
        <trans-unit id="54fea23628caa918a67b27ac084d811f983c065d" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;+resolveInstanceMethod:&lt;/code&gt; and &lt;code&gt;resolveClassMethod:&lt;/code&gt; was added to the GNU Objective-C runtime in GCC version 4.6.</source>
          <target state="translated">&lt;code&gt;+resolveInstanceMethod:&lt;/code&gt; 및 &lt;code&gt;resolveClassMethod:&lt;/code&gt; 에 대한 지원 이 GCC 버전 4.6의 GNU Objective-C 런타임에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="dd68cf9e9a0ec7bc0fc781d9f962022790ff0418" translate="yes" xml:space="preserve">
          <source>Support for decimal floating types includes the arithmetic operators add, subtract, multiply, divide; unary arithmetic operators; relational operators; equality operators; and conversions to and from integer and other floating types. Use a suffix &amp;lsquo;</source>
          <target state="translated">십진 부동 유형에 대한 지원에는 산술 연산자 더하기, 빼기, 곱하기, 나누기; 단항 산술 연산자; 관계 연산자; 평등 연산자; 정수 및 기타 부동 유형과의 변환. 접미사 '</target>
        </trans-unit>
        <trans-unit id="81ca39c921120d2adfd04ac948aaa079d0c3ae01" translate="yes" xml:space="preserve">
          <source>Support for fixed-point types includes:</source>
          <target state="translated">고정 소수점 유형에 대한 지원은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5e968c4a4e334d0a74a0d1d72a11bad05634a930" translate="yes" xml:space="preserve">
          <source>Support for garbage collection with the GNU runtime has been added by using a powerful conservative garbage collector, known as the Boehm-Demers-Weiser conservative garbage collector.</source>
          <target state="translated">Boehm-Demers-Weiser 보수 가비지 수집기라고하는 강력한 보수 가비지 수집기를 사용하여 GNU 런타임으로 가비지 수집에 대한 지원이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="03b50bd9ac9ebf90f9a5662b1d0f6ab814a76b5a" translate="yes" xml:space="preserve">
          <source>Support for streams has been removed and the string to be printed will always be sent to stdout via the &lt;code&gt;write&lt;/code&gt; syscall. The string is not buffered before it is sent to write.</source>
          <target state="translated">스트림에 대한 지원이 제거되었으며 인쇄 할 문자열은 항상 &lt;code&gt;write&lt;/code&gt; syscall을 통해 stdout으로 전송됩니다 . 문자열은 쓰기 위해 전송되기 전에 버퍼링되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0504a68e0c39cc0a79b57df0e39cf16b54d9e942" translate="yes" xml:space="preserve">
          <source>Support for these additional types includes the arithmetic operators: add, subtract, multiply, divide; unary arithmetic operators; relational operators; equality operators; and conversions to and from integer and other floating types. Use a suffix &amp;lsquo;</source>
          <target state="translated">이러한 추가 유형에 대한 지원에는 산술 연산자가 포함됩니다. 더하기, 빼기, 곱하기, 나누기; 단항 산술 연산자; 관계 연산자; 평등 연산자; 정수 및 기타 부동 유형과의 변환. 접미사 '</target>
        </trans-unit>
        <trans-unit id="43f86c51be480704f6fd0e7ee0fe1bad4e5dee50" translate="yes" xml:space="preserve">
          <source>Support thread-safe exception handling on MinGW. Programs that rely on thread-safe exception handling must compile and link all code with the</source>
          <target state="translated">MinGW에서 스레드 안전 예외 처리를 지원합니다. 스레드 안전 예외 처리에 의존하는 프로그램은 모든 코드를 컴파일하고 링크해야합니다.</target>
        </trans-unit>
        <trans-unit id="b789d7421ca6bd2ef122f7c0fe30f55f0075ed29" translate="yes" xml:space="preserve">
          <source>Supported values for &lt;var&gt;cpu&lt;/var&gt; are</source>
          <target state="translated">&lt;var&gt;cpu&lt;/var&gt; 지원되는 값 은</target>
        </trans-unit>
        <trans-unit id="4bb84e33320d5d24d55a608a57ed95d8069c1f60" translate="yes" xml:space="preserve">
          <source>Supported values for &lt;var&gt;cpu_type&lt;/var&gt; are</source>
          <target state="translated">&lt;var&gt;cpu_type&lt;/var&gt; 에 지원되는 값은 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e586e3e5b6ddb947a96ee95bbf9931e047b7a75c" translate="yes" xml:space="preserve">
          <source>Suppose for example you have a &lt;code&gt;FileStream&lt;/code&gt; class that declares &lt;code&gt;Stdin&lt;/code&gt;, &lt;code&gt;Stdout&lt;/code&gt; and &lt;code&gt;Stderr&lt;/code&gt; as global variables, like below:</source>
          <target state="translated">예를 들어 &lt;code&gt;Stdin&lt;/code&gt; , &lt;code&gt;Stdout&lt;/code&gt; 및 &lt;code&gt;Stderr&lt;/code&gt; 을 아래와 같이 전역 변수로 선언 하는 &lt;code&gt;FileStream&lt;/code&gt; 클래스 가 있다고 가정하십시오 .</target>
        </trans-unit>
        <trans-unit id="e59b9335cfc4b19ac5e0c2f6fad649ab56af701c" translate="yes" xml:space="preserve">
          <source>Suppose the type &lt;code&gt;uid_t&lt;/code&gt; happens to be &lt;code&gt;short&lt;/code&gt;. ISO C does not allow this example, because subword arguments in old-style non-prototype definitions are promoted. Therefore in this example the function definition&amp;rsquo;s argument is really an &lt;code&gt;int&lt;/code&gt;, which does not match the prototype argument type of &lt;code&gt;short&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;uid_t&lt;/code&gt; 유형 이 &lt;code&gt;short&lt;/code&gt; 가정하십시오 . 구식 비 프로토 타입 정의의 하위 단어 인수가 승격되므로 ISO C에서는이 예를 허용하지 않습니다. 따라서이 예제에서 함수 정의의 인수는 실제로 &lt;code&gt;int&lt;/code&gt; 이며 프로토 타입 인수 유형 &lt;code&gt;short&lt;/code&gt; 와 일치하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="48ba8dd72d18863780aea11859486731c35e5eea" translate="yes" xml:space="preserve">
          <source>Suppress the generation of link options to search libdld.sl when the</source>
          <target state="translated">다음과 같은 경우 libdld.sl을 검색하기위한 링크 옵션 생성을 억제하십시오.</target>
        </trans-unit>
        <trans-unit id="d35c9ca6cfae417ba88541dbae7bd0b48fb96152" translate="yes" xml:space="preserve">
          <source>Suppress warning messages emitted by &lt;code&gt;#warning&lt;/code&gt; directives.</source>
          <target state="translated">&lt;code&gt;#warning&lt;/code&gt; 지시문에서 생성 한 경고 메시지를 표시하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7f779f6a3dd8fc46f68f940fe5b38cc8f0332cb0" translate="yes" xml:space="preserve">
          <source>Suppress warnings about inheriting from a virtual base with a non-trivial C++11 move assignment operator. This is dangerous because if the virtual base is reachable along more than one path, it is moved multiple times, which can mean both objects end up in the moved-from state. If the move assignment operator is written to avoid moving from a moved-from object, this warning can be disabled.</source>
          <target state="translated">사소한 C ++ 11 이동 할당 연산자를 사용하여 가상 기반에서 상속하는 것에 대한 경고를 표시하지 않습니다. 가상베이스가 둘 이상의 경로를 따라 도달 할 수있는 경우 여러 번 이동하므로 두 개체가 모두 이동 시작 상태에있게됩니다. 이동 할당 연산자가 이동 된 오브젝트에서 이동하지 않도록 작성되면이 경고를 사용하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48a42269132ea484d01ac088e414c9e42de642c6" translate="yes" xml:space="preserve">
          <source>Suppress warnings about use of C++11 inheriting constructors when the base class inherited from has a C variadic constructor; the warning is on by default because the ellipsis is not inherited.</source>
          <target state="translated">상속 된 기본 클래스에 C variadic 생성자가있을 때 C ++ 11 상속 생성자의 사용에 대한 경고를 표시하지 않습니다. 생략 부호가 상속되지 않으므로 경고가 기본적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cb3aae6f5324c78295db9baccb5bafa853510ca1" translate="yes" xml:space="preserve">
          <source>Suppress warnings from applying the &lt;code&gt;offsetof&lt;/code&gt; macro to a non-POD type. According to the 2014 ISO C++ standard, applying &lt;code&gt;offsetof&lt;/code&gt; to a non-standard-layout type is undefined. In existing C++ implementations, however, &lt;code&gt;offsetof&lt;/code&gt; typically gives meaningful results. This flag is for users who are aware that they are writing nonportable code and who have deliberately chosen to ignore the warning about it.</source>
          <target state="translated">매크로 의 &lt;code&gt;offsetof&lt;/code&gt; 을 비 POD 유형에 적용하는 경고를 억제 합니다. 2014 ISO C ++ 표준에 따르면 비표준 레이아웃 유형에 &lt;code&gt;offsetof&lt;/code&gt; 을 적용 하는 것은 정의되어 있지 않습니다. 그러나 기존 C ++ 구현에서 &lt;code&gt;offsetof&lt;/code&gt; 는 일반적으로 의미있는 결과를 제공합니다. 이 플래그는 이식 불가능한 코드를 작성하고 있고 고의적으로 경고를 무시하기로 선택한 사용자를위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="ba83304e4c99868bbbe79f9fdcf9011c9415eab0" translate="yes" xml:space="preserve">
          <source>Suppress warnings from casts from a pointer to an integer type of a different size.</source>
          <target state="translated">포인터에서 다른 크기의 정수 유형으로 캐스트 할 때 경고를 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ef9b18daa97b7e3ff555e42290cbf027c56dba77" translate="yes" xml:space="preserve">
          <source>Suppress warnings from casts to pointer type of an integer of a different size. In C++, casting to a pointer type of smaller size is an error.</source>
          <target state="translated">캐스트에서 다른 크기의 정수 포인터 유형으로 경고를 표시하지 않습니다. C ++에서 더 작은 크기의 포인터 유형으로 캐스트하는 것은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="d5c7bd9509193e71d10cdb667e9063dd06de3280" translate="yes" xml:space="preserve">
          <source>Suppress warnings when a positional initializer is used to initialize a structure that has been marked with the &lt;code&gt;designated_init&lt;/code&gt; attribute.</source>
          <target state="translated">&lt;code&gt;designated_init&lt;/code&gt; 이니셜 라이저를 사용하여 specified_init 속성 으로 표시된 구조를 초기화 할 때 경고를 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b5db30b4023b1a002e3bf61c91080c305981c620" translate="yes" xml:space="preserve">
          <source>Switch ARM/Thumb modes on alternating functions. This option is provided for regression testing of mixed Thumb/ARM code generation, and is not intended for ordinary use in compiling code.</source>
          <target state="translated">교번 기능에서 ARM / Thumb 모드를 전환합니다. 이 옵션은 혼합 Thumb / ARM 코드 생성의 회귀 테스트를 위해 제공되며 코드를 컴파일 할 때 일반적으로 사용하기위한 것이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="d7301da94a751f6929a8a4eed4be94e8d5777d3a" translate="yes" xml:space="preserve">
          <source>Switch initialization conversion refuses to create arrays that are bigger than</source>
          <target state="translated">스위치 초기화 변환은보다 큰 배열을 생성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aaf2d10ad0dec99d41b3214114d91b1b2422b89f" translate="yes" xml:space="preserve">
          <source>Switch to code generation variant that allows to execute all threads in each warp, while maintaining memory state and side effects as if only one thread in each warp was active outside of OpenMP SIMD regions. All atomic operations and calls to runtime (malloc, free, vprintf) are conditionally executed (iff current lane index equals the master lane index), and the register being assigned is copied via a shuffle instruction from the master lane. Outside of SIMD regions lane 0 is the master; inside, each thread sees itself as the master. Shared memory array &lt;code&gt;int __nvptx_uni[]&lt;/code&gt; stores all-zeros or all-ones bitmasks for each warp, indicating current mode (0 outside of SIMD regions). Each thread can bitwise-and the bitmask at position &lt;code&gt;tid.y&lt;/code&gt; with current lane index to compute the master lane index.</source>
          <target state="translated">각 워프의 모든 스레드를 실행할 수있는 코드 생성 변형으로 전환하면서 각 워프의 스레드 하나만 OpenMP SIMD 영역 외부에서 활성화 된 것처럼 메모리 상태와 부작용을 유지합니다. 모든 원자 연산 및 런타임 호출 (malloc, free, vprintf)은 조건부로 실행되며 (현재 레인 인덱스가 마스터 레인 인덱스와 같으면) 마스터 레지스터에서 셔플 명령을 통해 할당 된 레지스터가 복사됩니다. SIMD 영역 외부의 레인 0이 마스터입니다. 내부에서 각 스레드는 마스터로 간주됩니다. 공유 메모리 배열 &lt;code&gt;int __nvptx_uni[]&lt;/code&gt; 는 각 워프에 대한 0 또는 1 비트 비트 마스크를 저장하여 현재 모드를 나타냅니다 (0 SIMD 영역 외부). 각 스레드는 비트 단위로 위치 &lt;code&gt;tid.y&lt;/code&gt; 의 비트 마스크 현재 레인 인덱스를 사용하여 마스터 레인 인덱스를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="df31493a786b81749ab4d7d1c6bbb6b81f2ef537" translate="yes" xml:space="preserve">
          <source>Symbolic constant for call/jump instruction.</source>
          <target state="translated">호출 / 점프 명령에 대한 기호 상수.</target>
        </trans-unit>
        <trans-unit id="d02b75640f5617b344a6fd481b4fcf74a33c7dab" translate="yes" xml:space="preserve">
          <source>Synonyms for</source>
          <target state="translated">의 동의어</target>
        </trans-unit>
        <trans-unit id="a7f02fe7170bb60802488281e7b6535e4525bc7a" translate="yes" xml:space="preserve">
          <source>Syntax without an explicit &lt;var&gt;opts&lt;/var&gt; parameter is deprecated. It is equivalent to specifying an &lt;var&gt;opts&lt;/var&gt; list of:</source>
          <target state="translated">명시적인 &lt;var&gt;opts&lt;/var&gt; 매개 변수가 없는 구문 은 더 이상 사용되지 않습니다. 다음의 &lt;var&gt;opts&lt;/var&gt; 목록 을 지정하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="fb5461d0f57b9c531d984331d59cfb9c2b43a2f9" translate="yes" xml:space="preserve">
          <source>System V Release 4 small data area reference</source>
          <target state="translated">System V 릴리스 4 소규모 데이터 영역 참조</target>
        </trans-unit>
        <trans-unit id="e4a39789bd7be8b8dfec91a966c5aa35d6a313b6" translate="yes" xml:space="preserve">
          <source>TI ABI specifies that function (code) pointers are 16-bit, whereas GNU supports only 32-bit data and code pointers.</source>
          <target state="translated">TI ABI는 함수 (코드) 포인터가 16 비트 인 반면 GNU는 32 비트 데이터 및 코드 포인터 만 지원하도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="2218a74f01f0ccb4e48f5247664f57112a4f0aaf" translate="yes" xml:space="preserve">
          <source>TI C6X family&amp;mdash;</source>
          <target state="translated">TI C6X 제품군 &amp;mdash;</target>
        </trans-unit>
        <trans-unit id="c941de06f499163c146e2988a363757665dd2da4" translate="yes" xml:space="preserve">
          <source>TILE-Gx&amp;mdash;</source>
          <target state="translated">TILE-Gx&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="94413aebaec1d35ed29622efe6a91644c6c91dd4" translate="yes" xml:space="preserve">
          <source>TILEPro&amp;mdash;</source>
          <target state="translated">TILEPro&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="9730d4326a7b8a0d13c2be3b7fe29b80ad152bf6" translate="yes" xml:space="preserve">
          <source>Table of Contents</source>
          <target state="translated">목차</target>
        </trans-unit>
        <trans-unit id="ecd7eecc4f728ae74383a27923d7203db8bfeb4c" translate="yes" xml:space="preserve">
          <source>Take advantage of linker relaxations to reduce the number of instructions required to materialize symbol addresses. The default is to take advantage of linker relaxations.</source>
          <target state="translated">링커 완화를 활용하여 심볼 주소를 구체화하는 데 필요한 명령 수를 줄입니다. 디폴트는 링커 완화를 이용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="01d35405dd4f6f085c687c5306bb4a6e617f2e88" translate="yes" xml:space="preserve">
          <source>Taking the address of a &lt;code&gt;union&lt;/code&gt; or a &lt;code&gt;struct&lt;/code&gt; with reverse scalar storage order is permitted.</source>
          <target state="translated">a의 주소를 복용 &lt;code&gt;union&lt;/code&gt; 또는 &lt;code&gt;struct&lt;/code&gt; 역 스칼라 저장 순서로하는 것이 허용된다.</target>
        </trans-unit>
        <trans-unit id="9ff36b684e3489808b01be7efb64c6849f9ba0f5" translate="yes" xml:space="preserve">
          <source>Taking the address of a label may generate errors from the HP-UX PA assembler. GAS for the PA does not have this problem.</source>
          <target state="translated">레이블 주소를 가져 오면 HP-UX PA 어셈블러에서 오류가 발생할 수 있습니다. PA의 GAS에는이 문제가 없습니다.</target>
        </trans-unit>
        <trans-unit id="8c7129ffec0f9a33a9ffe8b44de153b8593725b3" translate="yes" xml:space="preserve">
          <source>Taking the address of a scalar field of a &lt;code&gt;union&lt;/code&gt; or a &lt;code&gt;struct&lt;/code&gt; with reverse scalar storage order is not permitted and yields an error.</source>
          <target state="translated">&lt;code&gt;union&lt;/code&gt; 의 스칼라 필드 또는 리버스 스칼라 저장 순서를 가진 &lt;code&gt;struct&lt;/code&gt; 의 주소를 가져 오는 것은 허용되지 않으며 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9f5bfaf20daa2c55100557696546e467c263a569" translate="yes" xml:space="preserve">
          <source>Taking the address of an array field, whose component is scalar, of a &lt;code&gt;union&lt;/code&gt; or a &lt;code&gt;struct&lt;/code&gt; with reverse scalar storage order is permitted but yields a warning, unless</source>
          <target state="translated">구성 요소가 스칼라, &lt;code&gt;union&lt;/code&gt; 또는 역 스칼라 저장 순서가 있는 &lt;code&gt;struct&lt;/code&gt; 의 배열 필드 주소를 사용할 수 있지만 경고가 표시되지 않는 한</target>
        </trans-unit>
        <trans-unit id="eb41297adae8dd10c30aff884697e8695add6957" translate="yes" xml:space="preserve">
          <source>Taking this into account, it is important to note the following:</source>
          <target state="translated">이를 고려할 때 다음 사항에 유의해야합니다.</target>
        </trans-unit>
        <trans-unit id="c69e706d0180e6de86eaea828036822f65c39e90" translate="yes" xml:space="preserve">
          <source>Target architectures are encouraged to provide their own patterns for each of the atomic built-in functions. If no target is provided, the original non-memory model set of &amp;lsquo;</source>
          <target state="translated">대상 아키텍처는 각 원자 기본 제공 기능에 대해 고유 한 패턴을 제공하도록 권장됩니다. 대상이 제공되지 않으면 원래 비 메모리 모델 세트 인 '</target>
        </trans-unit>
        <trans-unit id="f7c745960637a96625efff80e3b7b6cb80a28125" translate="yes" xml:space="preserve">
          <source>Target has split instruction and data space. Implies -m45.</source>
          <target state="translated">대상에 분할 명령과 데이터 공간이 있습니다. -m45를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="70857ff656af8497b29b5cea7cede66fd2b8d04e" translate="yes" xml:space="preserve">
          <source>Target-specific attributes that affect the identity of a type, such as ia32 calling conventions on a function type (stdcall, regparm, etc.), did not affect the mangled name, leading to name collisions when function pointers were used as template arguments.</source>
          <target state="translated">함수 유형에 대한 ia32 호출 규칙 (stdcall, regparm 등)과 같은 유형의 ID에 영향을주는 대상별 속성은 맹 글링 된 이름에 영향을 미치지 않아 함수 포인터를 템플릿 인수로 사용할 때 이름 충돌이 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="55ac9adb172fe07da9b52a8103d4a87829fbaae5" translate="yes" xml:space="preserve">
          <source>Target-specific options, such as compiling for a specific processor variant.</source>
          <target state="translated">특정 프로세서 변형에 대한 컴파일과 같은 대상별 옵션</target>
        </trans-unit>
        <trans-unit id="82a660e45a245ce196b4fdfa2d1b2b50ce849614" translate="yes" xml:space="preserve">
          <source>Tell the MIPS assembler to not run its preprocessor over user assembler files (with a &amp;lsquo;</source>
          <target state="translated">MIPS 어셈블러에 사용자 어셈블러 파일에 대해 사전 처리기를 실행하지 않도록 지시하십시오 ( '</target>
        </trans-unit>
        <trans-unit id="68c3b5335b5c0cc22332ebfdb31ac1bb53445273" translate="yes" xml:space="preserve">
          <source>Tells the compiler that any variable marked with the &lt;code&gt;io&lt;/code&gt; attribute is to be considered volatile.</source>
          <target state="translated">컴파일러에게 &lt;code&gt;io&lt;/code&gt; 속성으로 표시된 모든 변수 는 휘발성으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="6c80eca69977e6b469c44eecba1a817d3b44f7d0" translate="yes" xml:space="preserve">
          <source>Tells the compiler to perform function calls by first loading the address of the function into a register and then performing a subroutine call on this register. This switch is needed if the target function lies outside of the 24-bit addressing range of the offset-based version of subroutine call instruction.</source>
          <target state="translated">함수의 주소를 레지스터에 먼저로드 한 다음이 레지스터에서 서브 루틴 호출을 수행하여 컴파일러에게 함수 호출을 수행하도록 지시합니다. 대상 기능이 서브 루틴 호출 명령의 오프셋 기반 버전의 24 비트 주소 지정 범위를 벗어나는 경우이 스위치가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="f7974b9f9368d29b382ac1425edcaf88973b1540" translate="yes" xml:space="preserve">
          <source>Tells the compiler to perform function calls by first loading the address of the function into a register and then performing a subroutine call on this register. This switch is needed if the target function lies outside of the 64-megabyte addressing range of the offset-based version of subroutine call instruction.</source>
          <target state="translated">함수의 주소를 레지스터에 먼저로드 한 다음이 레지스터에서 서브 루틴 호출을 수행하여 컴파일러에게 함수 호출을 수행하도록 지시합니다. 대상 스위치가 서브 루틴 호출 명령의 오프셋 기반 버전의 64MB 주소 범위를 벗어나는 경우이 스위치가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="4035c3eab8e73aa47237d7e7a48fe4ab59208c8f" translate="yes" xml:space="preserve">
          <source>Template Instantiations</source>
          <target state="translated">템플릿 인스턴스화</target>
        </trans-unit>
        <trans-unit id="eb2cd45b5c86db640ab845c9538624992d63586f" translate="yes" xml:space="preserve">
          <source>Temporaries may vanish before you expect</source>
          <target state="translated">예상하기 전에 임시가 사라질 수 있습니다</target>
        </trans-unit>
        <trans-unit id="9f5670dc2252e3e0202f196c05a183f0e891e7ce" translate="yes" xml:space="preserve">
          <source>Temporary assist register $ta (i.e. $r15).</source>
          <target state="translated">임시 지원 등록 $ ta (예 : $ r15).</target>
        </trans-unit>
        <trans-unit id="f01689c0a988a52e1980b89817f9a193bf32f058" translate="yes" xml:space="preserve">
          <source>Temporary register r0</source>
          <target state="translated">임시 레지스터 r0</target>
        </trans-unit>
        <trans-unit id="eb69100c455a5efc5c637f0862041f54fcc63021" translate="yes" xml:space="preserve">
          <source>That code overwrites the variable &lt;code&gt;Index&lt;/code&gt; (&amp;lsquo;</source>
          <target state="translated">이 코드는 변수 &lt;code&gt;Index&lt;/code&gt; ( '</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">The</target>
        </trans-unit>
        <trans-unit id="3d372c7173ccc49ed5f8266482156df6e30a1a0e" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;bool&amp;rdquo; version returns &lt;code&gt;true&lt;/code&gt; if the comparison is successful and &lt;var&gt;newval&lt;/var&gt; is written. The &amp;ldquo;val&amp;rdquo; version returns the contents of &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; before the operation.</source>
          <target state="translated">&amp;ldquo;bool&amp;rdquo;버전은 비교에 성공하고 &lt;var&gt;newval&lt;/var&gt; 이 기록 되면 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . &quot;val&quot;버전 은 작업 전에 &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; &lt;var&gt;ptr&lt;/var&gt; 의 내용을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="09bc8f2a14ab55c654c682384317bfec0642af39" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;signature&amp;rdquo; is a null-terminated string, composed of the following:</source>
          <target state="translated">&quot;서명&quot;은 다음과 같이 구성된 null로 끝나는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="4c06e97499a27f0f80d31e89637ece588d8ec278" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;user time&amp;rdquo; and the &amp;ldquo;system time&amp;rdquo; are moved before the program name, and the options passed to the program are displayed, so that one can later tell what file was being compiled, and with which options.</source>
          <target state="translated">&amp;ldquo;사용자 시간&amp;rdquo;과&amp;ldquo;시스템 시간&amp;rdquo;은 프로그램 이름보다 먼저 이동하고 프로그램에 전달 된 옵션이 표시되므로 나중에 컴파일 할 파일과 옵션을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ed4c9f9933dd9e4b8da3ca824145866c18f6a63" translate="yes" xml:space="preserve">
          <source>The &amp;lsquo;</source>
          <target state="translated">'</target>
        </trans-unit>
        <trans-unit id="9820649111d032078a2e341b12a064c77a65bbc2" translate="yes" xml:space="preserve">
          <source>The 16-bit &lt;code&gt;R10&lt;/code&gt; register.</source>
          <target state="translated">16 비트 &lt;code&gt;R10&lt;/code&gt; 레지스터</target>
        </trans-unit>
        <trans-unit id="8cd88b0aaf75b51696b24c3768a2b1a20915edac" translate="yes" xml:space="preserve">
          <source>The 16-bit &lt;code&gt;R8&lt;/code&gt; register.</source>
          <target state="translated">16 비트 &lt;code&gt;R8&lt;/code&gt; 레지스터</target>
        </trans-unit>
        <trans-unit id="b1272239002f51f4809e26667c1b13c1b964633d" translate="yes" xml:space="preserve">
          <source>The 1998 ISO C++ standard plus the 2003 technical corrigendum and some additional defect reports. Same as</source>
          <target state="translated">1998 년 ISO C ++ 표준과 2003 기술 표준 및 일부 추가 결함 보고서. 와 동일</target>
        </trans-unit>
        <trans-unit id="cfd06b261fe64d273c59c563a73adcb4a19fda6b" translate="yes" xml:space="preserve">
          <source>The 2011 ISO C++ standard plus amendments. The name &amp;lsquo;</source>
          <target state="translated">2011 ISO C ++ 표준 및 수정 사항. 이름 '</target>
        </trans-unit>
        <trans-unit id="e0824fd4223b0cb3aeed48d8b77f3a1b17acde06" translate="yes" xml:space="preserve">
          <source>The 2014 ISO C++ standard plus amendments. The name &amp;lsquo;</source>
          <target state="translated">2014 ISO C ++ 표준 및 수정 사항 이름 '</target>
        </trans-unit>
        <trans-unit id="d75bfd00cf21586d8e597fcc9ed0b86883eb1dfa" translate="yes" xml:space="preserve">
          <source>The 2017 ISO C++ standard plus amendments. The name &amp;lsquo;</source>
          <target state="translated">2017 ISO C ++ 표준 및 수정 사항 이름 '</target>
        </trans-unit>
        <trans-unit id="9e4484fd6590cd7f36b6fdf94168a5387d0e46c3" translate="yes" xml:space="preserve">
          <source>The 4.1, 4.2 and 4.3 series of GCC ignore the &lt;code&gt;packed&lt;/code&gt; attribute on bit-fields of type &lt;code&gt;char&lt;/code&gt;. This has been fixed in GCC 4.4 but the change can lead to differences in the structure layout. GCC informs you when the offset of such a field has changed in GCC 4.4. For example there is no longer a 4-bit padding between field &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; in this structure:</source>
          <target state="translated">4.1, 4.2 및 4.3 시리즈 GCC는 &lt;code&gt;char&lt;/code&gt; 유형의 비트 필드 에서 &lt;code&gt;packed&lt;/code&gt; 속성을 무시합니다 . 이것은 GCC 4.4에서 수정되었지만 구조 레이아웃에 차이가 생길 수 있습니다. GCC 4.4에서 이러한 필드의 오프셋이 변경되면 GCC에서 알려줍니다. 예를 들어이 구조에서 필드 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 사이에 더 이상 4 비트 패딩이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="8937102670278bcd3018a5a5c9e549b76146be93" translate="yes" xml:space="preserve">
          <source>The 4.1, 4.2 and 4.3 series of GCC ignore the &lt;code&gt;packed&lt;/code&gt; attribute on bit-fields of type &lt;code&gt;char&lt;/code&gt;. This was fixed in GCC 4.4 but the change can lead to differences in the structure layout. GCC informs you when the offset of such a field has changed in GCC 4.4. For example there is no longer a 4-bit padding between field &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; in this structure:</source>
          <target state="translated">4.1, 4.2 및 4.3 시리즈의 GCC는 &lt;code&gt;char&lt;/code&gt; 유형의 비트 필드 에서 &lt;code&gt;packed&lt;/code&gt; 속성을 무시합니다 . 이것은 GCC 4.4에서 수정되었지만 변경으로 인해 구조 레이아웃이 다를 수 있습니다. GCC는 이러한 필드의 오프셋이 GCC 4.4에서 변경된 경우 알려줍니다. 예를 들어 다음 구조에서 필드 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 사이에 더 이상 4 비트 패딩이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="909967fe10a21a246a86aeb337d0842e478f43ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;cc&quot;&lt;/code&gt; clobber indicates that the assembler code modifies the flags register. On some machines, GCC represents the condition codes as a specific hardware register; &lt;code&gt;&quot;cc&quot;&lt;/code&gt; serves to name this register. On other machines, condition code handling is different, and specifying &lt;code&gt;&quot;cc&quot;&lt;/code&gt; has no effect. But it is valid no matter what the target.</source>
          <target state="translated">&lt;code&gt;&quot;cc&quot;&lt;/code&gt; 소지품은 어셈블러 코드가 플래그를 등록 수정을 나타냅니다. 일부 컴퓨터에서 GCC는 조건 코드를 특정 하드웨어 레지스터로 나타냅니다. &lt;code&gt;&quot;cc&quot;&lt;/code&gt; 는이 레지스터의 이름을 지정합니다. 다른 시스템에서는 조건 코드 처리가 다르며 &lt;code&gt;&quot;cc&quot;&lt;/code&gt; 를 지정해 도 아무런 영향이 없습니다. 그러나 대상이 무엇이든 유효합니다.</target>
        </trans-unit>
        <trans-unit id="f2534a799a74c45e086749f66cd7d314d0f206ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;memory&quot;&lt;/code&gt; clobber tells the compiler that the assembly code performs memory reads or writes to items other than those listed in the input and output operands (for example, accessing the memory pointed to by one of the input parameters). To ensure memory contains correct values, GCC may need to flush specific register values to memory before executing the &lt;code&gt;asm&lt;/code&gt;. Further, the compiler does not assume that any values read from memory before an &lt;code&gt;asm&lt;/code&gt; remain unchanged after that &lt;code&gt;asm&lt;/code&gt;; it reloads them as needed. Using the &lt;code&gt;&quot;memory&quot;&lt;/code&gt; clobber effectively forms a read/write memory barrier for the compiler.</source>
          <target state="translated">&lt;code&gt;&quot;memory&quot;&lt;/code&gt; 어셈블리 코드 행하고 메모리 (메모리의 입력 파라미터들 중 하나에 의해 지정된 액세스, 예를 들어) 판독하거나 입출력 피연산자에 나열된 것 이외의 항목을 기록하는 소지품 컴파일러 말한다. 메모리에 올바른 값이 포함되도록하기 위해 GCC는 &lt;code&gt;asm&lt;/code&gt; 을 실행하기 전에 특정 레지스터 값을 메모리로 플러시해야합니다 . 또한, 컴파일러는 전에 값을 메모리로부터 읽어지지 않으며 &lt;code&gt;asm&lt;/code&gt; 그 후 변하지 &lt;code&gt;asm&lt;/code&gt; ; 필요에 따라 다시로드합니다. 은 Using &lt;code&gt;&quot;memory&quot;&lt;/code&gt; 소지품 효과적으로 컴파일러에 대한 읽기 / 쓰기 메모리 장벽을 형성한다.</target>
        </trans-unit>
        <trans-unit id="287b2b66c9a7de19b9dd84de221d8d45c3b97aec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#pragma GCC target&lt;/code&gt; pragma is presently implemented for x86, ARM, AArch64, PowerPC, S/390, and Nios II targets only.</source>
          <target state="translated">&lt;code&gt;#pragma GCC target&lt;/code&gt; 래그는 현재 86 구현되고, ARM, AArch64, 파워, S / 390 및 니오스 II 타겟 만.</target>
        </trans-unit>
        <trans-unit id="3ccfce523413ade3933dc06559f7495350ab0dd4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;&amp;amp;foo&lt;/code&gt; expressions for the same label might have different values if the containing function is inlined or cloned. If a program relies on them being always the same, &lt;code&gt;__attribute__((__noinline__,__noclone__))&lt;/code&gt; should be used to prevent inlining and cloning. If &lt;code&gt;&amp;amp;&amp;amp;foo&lt;/code&gt; is used in a static variable initializer, inlining and cloning is forbidden.</source>
          <target state="translated">포함하는 함수가 인라인되거나 복제 된 경우 동일한 레이블 의 &lt;code&gt;&amp;amp;&amp;amp;foo&lt;/code&gt; 표현식에 다른 값이있을 수 있습니다. 프로그램이 항상 동일하다고 의존하는 경우 &lt;code&gt;__attribute__((__noinline__,__noclone__))&lt;/code&gt; 을 사용하여 인라인 및 복제를 방지해야합니다. 경우 &lt;code&gt;&amp;amp;&amp;amp;foo&lt;/code&gt; 인라인, 정적 변수의 초기화에 사용되는 복제는 금지되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="33e1502637058c6ab49c207cf28a3e3142aca9a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+load&lt;/code&gt; implementation in the GNU runtime guarantees you the following things:</source>
          <target state="translated">&lt;code&gt;+load&lt;/code&gt; 는 GNU 런타임의 구현은 다음 사항을 보장한다 :</target>
        </trans-unit>
        <trans-unit id="91dd9757303b9f56bf3b6cb9119e24fe8a8727f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+load&lt;/code&gt; is a method that is not overridden by categories. If a class and a category of it both implement &lt;code&gt;+load&lt;/code&gt;, both methods are invoked. This allows some additional initializations to be performed in a category.</source>
          <target state="translated">&lt;code&gt;+load&lt;/code&gt; 범주에 의해 오버라이드 (override)되지 않는 방법이다. 클래스와 그 범주가 둘 다 &lt;code&gt;+load&lt;/code&gt; 를 구현 하면 두 메소드가 모두 호출됩니다. 이를 통해 카테고리에서 일부 추가 초기화를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="772d2fc6151afb4fb1792207ec49f4a45839a16b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+load&lt;/code&gt; method is also invoked when a bundle is dynamically loaded into your running program. This happens automatically without any intervening operation from you. When you write bundles and you need to write &lt;code&gt;+load&lt;/code&gt; you can safely create and send messages to objects whose classes already exist in the running program. The same restrictions as above apply to classes defined in bundle.</source>
          <target state="translated">&lt;code&gt;+load&lt;/code&gt; 번들이 동적으로 실행되는 프로그램에로드 할 때 방법도 호출됩니다. 이 작업은 사용자의 개입없이 자동으로 수행됩니다. 번들을 작성하고 &lt;code&gt;+load&lt;/code&gt; 를 작성해야하는 경우 실행중인 프로그램에 클래스가 이미 존재하는 오브젝트에 메시지를 안전하게 작성하고 보낼 수 있습니다. 위와 동일한 제한 사항이 번들에 정의 된 클래스에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="dc6d2c3cb15d85f1417842f0fbdf998d14486ba5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;- (id) .cxx_construct&lt;/code&gt; and &lt;code&gt;- (void) .cxx_destruct&lt;/code&gt; methods thusly generated only operate on instance variables declared in the current Objective-C class, and not those inherited from superclasses. It is the responsibility of the Objective-C runtime to invoke all such methods in an object&amp;rsquo;s inheritance hierarchy. The &lt;code&gt;- (id) .cxx_construct&lt;/code&gt; methods are invoked by the runtime immediately after a new object instance is allocated; the &lt;code&gt;- (void) .cxx_destruct&lt;/code&gt; methods are invoked immediately before the runtime deallocates an object instance.</source>
          <target state="translated">따라서 생성 된 &lt;code&gt;- (id) .cxx_construct&lt;/code&gt; 및 &lt;code&gt;- (void) .cxx_destruct&lt;/code&gt; 메소드는 수퍼 클래스에서 상속 된 것이 아니라 현재 Objective-C 클래스에 선언 된 인스턴스 변수에서만 작동합니다. Objective-C 런타임은 오브젝트의 상속 계층 구조에서 이러한 모든 메소드를 호출해야합니다. &lt;code&gt;- (id) .cxx_construct&lt;/code&gt; 방법은 새로운 객체 인스턴스가 할당 직후의 실행에 의해 호출되며 은 &lt;code&gt;- (void) .cxx_destruct&lt;/code&gt; 런타임 개체 인스턴스 할당을 해제하기 전에 방법은 즉시 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="e7108ce8eed259a604477fdf012b421d600214df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@finally&lt;/code&gt; clause, if present, will be executed upon exit from the immediately preceding &lt;code&gt;@try &amp;hellip; @catch&lt;/code&gt; section. This will happen regardless of whether any exceptions are thrown, caught or rethrown inside the &lt;code&gt;@try &amp;hellip; @catch&lt;/code&gt; section, analogously to the behavior of the &lt;code&gt;finally&lt;/code&gt; clause in Java.</source>
          <target state="translated">&lt;code&gt;@finally&lt;/code&gt; 의 조항이있는 경우, 직전에서 종료시 실행됩니다 &lt;code&gt;@try &amp;hellip; @catch&lt;/code&gt; 섹션을 참조하십시오. 이는 &lt;code&gt;@try &amp;hellip; @catch&lt;/code&gt; 섹션 내에서 예외가 발생, 잡히거나 다시 발생하는지 여부에 관계없이 Java 의 &lt;code&gt;finally&lt;/code&gt; 절의 동작과 유사하게 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="478f5300c419fd9f1ddbebddc4f1aa8b783e2f52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@throw&lt;/code&gt; statement may appear anywhere in an Objective-C or Objective-C++ program; when used inside of a &lt;code&gt;@catch&lt;/code&gt; block, the &lt;code&gt;@throw&lt;/code&gt; may appear without an argument (as shown above), in which case the object caught by the &lt;code&gt;@catch&lt;/code&gt; will be rethrown.</source>
          <target state="translated">&lt;code&gt;@throw&lt;/code&gt; 의 문은 오브젝티브 C 또는 목표 - C ++ 프로그램에 어디서나 나타날 수 있습니다; &lt;code&gt;@catch&lt;/code&gt; 블록 내부에서 사용될 때 &lt;code&gt;@throw&lt;/code&gt; 는 인수없이 나타날 수 있습니다 (위 그림 참조).이 경우 &lt;code&gt;@catch&lt;/code&gt; 에 의해 잡힌 객체 가 다시 throw됩니다.</target>
        </trans-unit>
        <trans-unit id="e66bfb70bc3d8564c8867b596c9daf7ef51239bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;A&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 레지스터.</target>
        </trans-unit>
        <trans-unit id="7abbdb5d09af41601d4b6214589f91ad242a72c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;AX&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;AX&lt;/code&gt; 의 레지스터.</target>
        </trans-unit>
        <trans-unit id="e8869263f41399bf1548d77cd0b06fdeab5b6090" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;B&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;B&lt;/code&gt; 를 등록한다.</target>
        </trans-unit>
        <trans-unit id="00b8662f23339aa40fc33f83b8bce9ef615fd089" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BC&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;BC&lt;/code&gt; 의 레지스터.</target>
        </trans-unit>
        <trans-unit id="fafb503a49e3e2b7cffac8865ce407955e8ba5c4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;C&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;C&lt;/code&gt; 에 등록한다.</target>
        </trans-unit>
        <trans-unit id="c945285a14de09364b5e9d34fc7e6e4e9171bb55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;D&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;D&lt;/code&gt; 의 레지스터.</target>
        </trans-unit>
        <trans-unit id="f334445b19ebbcdfd81f6a6a62d0c7c6a38f5f11" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DE&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;DE&lt;/code&gt; 레지스터.</target>
        </trans-unit>
        <trans-unit id="84d9046824f2223a9b4a7038c1fdd6a7981413ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;E&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;E&lt;/code&gt; 의 레지스터.</target>
        </trans-unit>
        <trans-unit id="5f8a2094444afcd8a79b22ed65059e8f2a29f862" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;H&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;H&lt;/code&gt; 에 등록한다.</target>
        </trans-unit>
        <trans-unit id="2d1c2a880567113429c4b1cc1d7e5ee3f5c01334" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HL&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;HL&lt;/code&gt; 의 레지스터.</target>
        </trans-unit>
        <trans-unit id="eb2a84b1e54ac92e546337e928dcc83ba5c11f03" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;L&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;L&lt;/code&gt; 에 등록한다.</target>
        </trans-unit>
        <trans-unit id="d88299e2896aeb367bb70fd25b9a5db675642c06" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LC_CTYPE&lt;/code&gt; environment variable specifies character classification. GCC uses it to determine the character boundaries in a string; this is needed for some multibyte encodings that contain quote and escape characters that are otherwise interpreted as a string end or escape.</source>
          <target state="translated">&lt;code&gt;LC_CTYPE&lt;/code&gt; 의 환경 변수를 지정 문자 분류. GCC는이를 사용하여 문자열의 문자 경계를 결정합니다. 이는 문자열 끝 또는 이스케이프로 해석되는 따옴표 및 이스케이프 문자가 포함 된 일부 멀티 바이트 인코딩에 필요합니다.</target>
        </trans-unit>
        <trans-unit id="fd95cbfac63c17d00419fc1cfbc5f410bf724a2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LC_MESSAGES&lt;/code&gt; environment variable specifies the language to use in diagnostic messages.</source>
          <target state="translated">&lt;code&gt;LC_MESSAGES&lt;/code&gt; 의 환경 변수는 진단 메시지에 사용할 언어를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="59d7ad50b2abf1611438129375bb15e01da761cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OS_main&lt;/code&gt; attribute can be used when there &lt;em&gt;is guarantee&lt;/em&gt; that interrupts are disabled at the time when the function is entered. This saves resources when the stack pointer has to be changed to set up a frame for local variables.</source>
          <target state="translated">&lt;code&gt;OS_main&lt;/code&gt; 에 있을 때 속성을 사용할 수 있습니다 &lt;em&gt;보장&lt;/em&gt; 기능을 입력 할 때 인터럽트 시간에 비활성화됩니다. 이는 로컬 변수에 대한 프레임을 설정하기 위해 스택 포인터를 변경해야 할 때 리소스를 절약합니다.</target>
        </trans-unit>
        <trans-unit id="20f1e35a5360b1f14267221fb24f61e47178d10d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OS_task&lt;/code&gt; attribute can be used when there is &lt;em&gt;no guarantee&lt;/em&gt; that interrupts are disabled at that time when the function is entered like for, e.g. task functions in a multi-threading operating system. In that case, changing the stack pointer register is guarded by save/clear/restore of the global interrupt enable flag.</source>
          <target state="translated">&lt;code&gt;OS_task&lt;/code&gt; 의 가없는 경우 속성은 사용할 수있는 &lt;em&gt;보장&lt;/em&gt; 기능이에 대한처럼 입력 할 때 인터럽트가 멀티 스레딩 운영 체제에, 그 시간에 예를 들어 작업 기능을 사용할 수 있는지가. 이 경우 스택 인터럽트 레지스터 변경은 전역 인터럽트 활성화 플래그의 저장 / 삭제 / 복원에 의해 보호됩니다.</target>
        </trans-unit>
        <trans-unit id="973b834abbbf1594a420dbfab9c679298adbbcc2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PSW&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;PSW&lt;/code&gt; 의 레지스터.</target>
        </trans-unit>
        <trans-unit id="03b6c46fda7548d67fe293013e4597e13b6cc3ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SP&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;SP&lt;/code&gt; 에 등록한다.</target>
        </trans-unit>
        <trans-unit id="77c3ff8f2bcfaf9382aab427535123ecf6e87b0c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;X&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;X&lt;/code&gt; 의 레지스터.</target>
        </trans-unit>
        <trans-unit id="f7925d7fc0ef32aa9ba1ce9e18d90f31a2b1041d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;_Float128&lt;/code&gt; type is supported on all systems where &lt;code&gt;__float128&lt;/code&gt; is supported or where &lt;code&gt;long double&lt;/code&gt; has the IEEE binary128 format. The &lt;code&gt;_Float64x&lt;/code&gt; type is supported on all systems where &lt;code&gt;__float128&lt;/code&gt; is supported. The &lt;code&gt;_Float32&lt;/code&gt; type is supported on all systems supporting IEEE binary32; the &lt;code&gt;_Float64&lt;/code&gt; and &lt;code&gt;_Float32x&lt;/code&gt; types are supported on all systems supporting IEEE binary64. The &lt;code&gt;_Float16&lt;/code&gt; type is supported on AArch64 systems by default, and on ARM systems when the IEEE format for 16-bit floating-point types is selected with</source>
          <target state="translated">&lt;code&gt;_Float128&lt;/code&gt; 의 유형은 어디에 모든 시스템에서 지원됩니다 &lt;code&gt;__float128&lt;/code&gt; 가 지원됩니다 어디서 &lt;code&gt;long double&lt;/code&gt; 는 IEEE binary128 형식이 있습니다. &lt;code&gt;_Float64x&lt;/code&gt; 의 유형은 모든 시스템에서 지원됩니다 &lt;code&gt;__float128&lt;/code&gt; 이 지원됩니다. &lt;code&gt;_Float32&lt;/code&gt; 의 유형은 IEEE의 binary32을 지원하는 모든 시스템에서 지원됩니다; &lt;code&gt;_Float64&lt;/code&gt; 및 &lt;code&gt;_Float32x&lt;/code&gt; 유형은 IEEE의 binary64을 지원하는 모든 시스템에서 지원됩니다. &lt;code&gt;_Float16&lt;/code&gt; 의 유형은 기본적으로 AArch64 시스템에서 지원되며, ARM 시스템에서 16 비트 부동 소수점 유형에 대한 IEEE 포맷으로 선택한 경우</target>
        </trans-unit>
        <trans-unit id="85103cf2482f16ae09dc93810b2ec0258970e808" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;_HTM_FIRST_USER_ABORT_CODE&lt;/code&gt; defined in &lt;code&gt;htmintrin.h&lt;/code&gt; specifies the first abort code which can be used for &lt;code&gt;__builtin_tabort&lt;/code&gt;. Values below this threshold are reserved for machine use.</source>
          <target state="translated">&lt;code&gt;_HTM_FIRST_USER_ABORT_CODE&lt;/code&gt; 정의 &lt;code&gt;htmintrin.h&lt;/code&gt; 가 사용될 수있는 제 중단 코드 지정 &lt;code&gt;__builtin_tabort&lt;/code&gt; 를 . 이 임계 값 미만의 값은 기계 용으로 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="392542e4dc2c75d48ed6b1e9e4e666156b2ab35d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__attribute__&lt;/code&gt; keyword is followed by an attribute specification enclosed in double parentheses.</source>
          <target state="translated">&lt;code&gt;__attribute__&lt;/code&gt; 의 키워드는 이중 괄호 안에 속성 사양에 따른다.</target>
        </trans-unit>
        <trans-unit id="0f8acb405a5cf121cc5773d2c4339fe65a77bcf5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_alloca&lt;/code&gt; function must be called at block scope. The function allocates an object &lt;var&gt;size&lt;/var&gt; bytes large on the stack of the calling function. The object is aligned on the default stack alignment boundary for the target determined by the &lt;code&gt;__BIGGEST_ALIGNMENT__&lt;/code&gt; macro. The &lt;code&gt;__builtin_alloca&lt;/code&gt; function returns a pointer to the first byte of the allocated object. The lifetime of the allocated object ends just before the calling function returns to its caller. This is so even when &lt;code&gt;__builtin_alloca&lt;/code&gt; is called within a nested block.</source>
          <target state="translated">&lt;code&gt;__builtin_alloca&lt;/code&gt; 의 기능 블록 범위에서 호출해야합니다. 이 함수 는 호출 함수의 스택에 큰 객체 &lt;var&gt;size&lt;/var&gt; 바이트를 할당합니다 . &lt;code&gt;__BIGGEST_ALIGNMENT__&lt;/code&gt; 매크로에 의해 결정된 대상의 기본 스택 정렬 경계에서 객체가 정렬됩니다 . &lt;code&gt;__builtin_alloca&lt;/code&gt; 의 기능은 할당 된 객체의 첫 번째 바이트에 대한 포인터를 반환합니다. 할당 된 객체의 수명은 호출 함수가 호출자에게 반환되기 직전에 종료됩니다. &lt;code&gt;__builtin_alloca&lt;/code&gt; 가 중첩 블록 내에서 호출 된 경우에도 마찬가지 입니다.</target>
        </trans-unit>
        <trans-unit id="699047c637b673c64e86fa3b74734bf759b728ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_alloca_with_align&lt;/code&gt; function must be called at block scope. The function allocates an object &lt;var&gt;size&lt;/var&gt; bytes large on the stack of the calling function. The allocated object is aligned on the boundary specified by the argument &lt;var&gt;alignment&lt;/var&gt; whose unit is given in bits (not bytes). The &lt;var&gt;size&lt;/var&gt; argument must be positive and not exceed the stack size limit. The &lt;var&gt;alignment&lt;/var&gt; argument must be a constant integer expression that evaluates to a power of 2 greater than or equal to &lt;code&gt;CHAR_BIT&lt;/code&gt; and less than some unspecified maximum. Invocations with other values are rejected with an error indicating the valid bounds. The function returns a pointer to the first byte of the allocated object. The lifetime of the allocated object ends at the end of the block in which the function was called. The allocated storage is released no later than just before the calling function returns to its caller, but may be released at the end of the block in which the function was called.</source>
          <target state="translated">&lt;code&gt;__builtin_alloca_with_align&lt;/code&gt; 기능 블록 범위에서 호출해야합니다. 이 함수 는 호출 함수의 스택에 큰 객체 &lt;var&gt;size&lt;/var&gt; 바이트를 할당합니다 . 할당 된 객체는 바이트 단위가 아닌 비트 단위로 인수 &lt;var&gt;alignment&lt;/var&gt; 의해 지정된 경계에 정렬됩니다 . &lt;var&gt;size&lt;/var&gt; 인수는 긍정적 스택의 크기 제한을 초과 할 수 없습니다. &lt;var&gt;alignment&lt;/var&gt; 인자보다 더 큰 2의 거듭 제곱으로 평가하거나 동일한 것을 일정한 정수 식이어야 &lt;code&gt;CHAR_BIT&lt;/code&gt; 지정되지 않은 최대 값보다 적습니다. 다른 값을 가진 호출은 유효한 범위를 나타내는 오류와 함께 거부됩니다. 이 함수는 할당 된 객체의 첫 번째 바이트에 대한 포인터를 반환합니다. 할당 된 객체의 수명은 함수가 호출 된 블록의 끝에서 끝납니다. 할당 된 스토리지는 호출 함수가 호출자에게 리턴하기 직전에 해제되지만, 함수가 호출 된 블록의 끝에서 해제 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d14b3efa7fa2847225bae57a72e4dc716953742d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_byte_in_range&lt;/code&gt; and &lt;code&gt;__builtin_byte_in_either_range&lt;/code&gt; require an environment supporting ISA 3.0 or later. For these two functions, the &lt;code&gt;range&lt;/code&gt; argument is encoded as 4 bytes, organized as &lt;code&gt;hi_1:lo_1:hi_2:lo_2&lt;/code&gt;. The &lt;code&gt;__builtin_byte_in_range&lt;/code&gt; function returns a non-zero value if and only if its &lt;code&gt;u&lt;/code&gt; argument is within the range bounded between &lt;code&gt;lo_2&lt;/code&gt; and &lt;code&gt;hi_2&lt;/code&gt; inclusive. The &lt;code&gt;__builtin_byte_in_either_range&lt;/code&gt; function returns non-zero if and only if its &lt;code&gt;u&lt;/code&gt; argument is within either the range bounded between &lt;code&gt;lo_1&lt;/code&gt; and &lt;code&gt;hi_1&lt;/code&gt; inclusive or the range bounded between &lt;code&gt;lo_2&lt;/code&gt; and &lt;code&gt;hi_2&lt;/code&gt; inclusive.</source>
          <target state="translated">&lt;code&gt;__builtin_byte_in_range&lt;/code&gt; 및 &lt;code&gt;__builtin_byte_in_either_range&lt;/code&gt; 는 나중에 ISA 3.0 이상을 지원하는 환경이 필요합니다. 이 두 함수의 경우 &lt;code&gt;range&lt;/code&gt; 인수는 4 바이트로 인코딩되며 &lt;code&gt;hi_1:lo_1:hi_2:lo_2&lt;/code&gt; 로 구성 됩니다. &lt;code&gt;__builtin_byte_in_range&lt;/code&gt; 의 함수는 0이 아닌 값을 반환하는 경우 및 그 경우에만 &lt;code&gt;u&lt;/code&gt; 인수 사이 경계 범위 내 &lt;code&gt;lo_2&lt;/code&gt; 및 &lt;code&gt;hi_2&lt;/code&gt; 포함. &lt;code&gt;__builtin_byte_in_either_range&lt;/code&gt; 의 기능은 비 - 제로를 반환하는 경우 및 그 경우에만 &lt;code&gt;u&lt;/code&gt; 인수 경계 사이의 범위 내에 하나 &lt;code&gt;lo_1&lt;/code&gt; 및 &lt;code&gt;hi_1&lt;/code&gt; 포함 또는 &lt;code&gt;lo_2&lt;/code&gt; 와 &lt;code&gt;hi_2&lt;/code&gt; ( 포함) 사이의 범위 .</target>
        </trans-unit>
        <trans-unit id="e9c90a92a294d6da36a67b6812f4d7f784a68c50" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_byte_in_set&lt;/code&gt; function requires a 64-bit environment supporting ISA 3.0 or later. This function returns a non-zero value if and only if its &lt;code&gt;u&lt;/code&gt; argument exactly equals one of the eight bytes contained within its 64-bit &lt;code&gt;set&lt;/code&gt; argument.</source>
          <target state="translated">&lt;code&gt;__builtin_byte_in_set&lt;/code&gt; 의 기능 이상 또는 3.0 ISA를 지원하는 64 비트 환경을 필요로한다. 이 함수는 &lt;code&gt;u&lt;/code&gt; 인수가 64 비트 &lt;code&gt;set&lt;/code&gt; 인수에 포함 된 8 바이트 중 하나와 정확히 일치하는 경우에만 0이 아닌 값을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="fb729367b3d36e784ee118ae00a98821f8cbe5c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_cmpb&lt;/code&gt; function performs a byte-wise compare on the contents of its two arguments, returning the result of the byte-wise comparison as the returned value. For each byte comparison, the corresponding byte of the return value holds 0xff if the input bytes are equal and 0 if the input bytes are not equal. If either of the arguments to this built-in function is wider than 32 bits, the function call expands into the form that expects &lt;code&gt;unsigned long long int&lt;/code&gt; arguments which is only available on 64-bit targets.</source>
          <target state="translated">&lt;code&gt;__builtin_cmpb&lt;/code&gt; 의 기능 수행이 바이트 와이즈 리턴 값과 바이트 - 방식의 비교 결과를 반환하는 두 개의 인자의 내용을 비교한다. 각 바이트 비교에서, 리턴 값의 해당 바이트는 입력 바이트가 같으면 0xff를 보유하고 입력 바이트가 같지 않으면 0을 보유합니다. 이 내장 함수에 대한 인수 중 하나가 32 비트보다 넓은 경우 함수 호출은 &lt;code&gt;unsigned long long int&lt;/code&gt; 인수가 64 비트 대상에서만 사용 가능한 형식으로 확장됩니다 .</target>
        </trans-unit>
        <trans-unit id="26cf6e5166e71a9dc3d72ae3910f453428861ff1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_cpu_is&lt;/code&gt; function requires GLIBC 2.23 or newer which exports the hardware capability bits. GCC defines the macro &lt;code&gt;__BUILTIN_CPU_SUPPORTS__&lt;/code&gt; if the &lt;code&gt;__builtin_cpu_supports&lt;/code&gt; built-in function is fully supported.</source>
          <target state="translated">&lt;code&gt;__builtin_cpu_is&lt;/code&gt; 의 기능은 하드웨어 성능 비트를 수출 GLIBC 2.23 이상이 필요합니다. &lt;code&gt;__builtin_cpu_supports&lt;/code&gt; 내장 기능이 완전히 지원되는 경우 GCC는 &lt;code&gt;__BUILTIN_CPU_SUPPORTS__&lt;/code&gt; 매크로를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="225ecb4eafc9e778fee170a226e93b379e52b096" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_cpu_supports&lt;/code&gt; function requires GLIBC 2.23 or newer which exports the hardware capability bits. GCC defines the macro &lt;code&gt;__BUILTIN_CPU_SUPPORTS__&lt;/code&gt; if the &lt;code&gt;__builtin_cpu_supports&lt;/code&gt; built-in function is fully supported.</source>
          <target state="translated">&lt;code&gt;__builtin_cpu_supports&lt;/code&gt; 의 기능은 하드웨어 성능 비트를 수출 GLIBC 2.23 이상이 필요합니다. &lt;code&gt;__builtin_cpu_supports&lt;/code&gt; 내장 기능이 완전히 지원되는 경우 GCC는 &lt;code&gt;__BUILTIN_CPU_SUPPORTS__&lt;/code&gt; 매크로를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="9d549e750824586a0354c272406d5e4e5816a0ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_darn&lt;/code&gt; and &lt;code&gt;__builtin_darn_raw&lt;/code&gt; functions require a 64-bit environment supporting ISA 3.0 or later. The &lt;code&gt;__builtin_darn&lt;/code&gt; function provides a 64-bit conditioned random number. The &lt;code&gt;__builtin_darn_raw&lt;/code&gt; function provides a 64-bit raw random number. The &lt;code&gt;__builtin_darn_32&lt;/code&gt; function provides a 32-bit conditioned random number.</source>
          <target state="translated">&lt;code&gt;__builtin_darn&lt;/code&gt; 및 &lt;code&gt;__builtin_darn_raw&lt;/code&gt; 기능 이상 3.0 ISA를 지원하는 64 비트 환경을 필요로한다. &lt;code&gt;__builtin_darn&lt;/code&gt; 의 기능은 64 비트 난수 조절을 제공한다. &lt;code&gt;__builtin_darn_raw&lt;/code&gt; 함수는 64 비트 원시 난수를 제공한다. &lt;code&gt;__builtin_darn_32&lt;/code&gt; 의 기능은 32 비트 난수 조절을 제공한다.</target>
        </trans-unit>
        <trans-unit id="fc4f02a6f5765f9e617ea8ee9a4170e4b962d403" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_dfp_dtstsfi_eq&lt;/code&gt; function returns a non-zero value if and only if the number of signficant digits of its &lt;code&gt;value&lt;/code&gt; argument equals its &lt;code&gt;comparison&lt;/code&gt; argument. The &lt;code&gt;__builtin_dfp_dtstsfi_eq_dd&lt;/code&gt; and &lt;code&gt;__builtin_dfp_dtstsfi_eq_td&lt;/code&gt; functions behave similarly, but require that the type of the &lt;code&gt;value&lt;/code&gt; argument be &lt;code&gt;__Decimal64&lt;/code&gt; and &lt;code&gt;__Decimal128&lt;/code&gt; respectively.</source>
          <target state="translated">&lt;code&gt;__builtin_dfp_dtstsfi_eq&lt;/code&gt; 의 와의 signficant 자릿수 경우에만 경우 함수는 0이 아닌 값을 반환 &lt;code&gt;value&lt;/code&gt; 인수가 동일 &lt;code&gt;comparison&lt;/code&gt; 인수를. &lt;code&gt;__builtin_dfp_dtstsfi_eq_dd&lt;/code&gt; 및 &lt;code&gt;__builtin_dfp_dtstsfi_eq_td&lt;/code&gt; 기능이 유사하게 동작하지만, 유형 것을 요구 &lt;code&gt;value&lt;/code&gt; 인수가 될 &lt;code&gt;__Decimal64&lt;/code&gt; 및 &lt;code&gt;__Decimal128&lt;/code&gt; 각각.</target>
        </trans-unit>
        <trans-unit id="57591fb5134dd8d315ee0a2d1522ee30d9827c9f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_dfp_dtstsfi_gt&lt;/code&gt; function returns a non-zero value if and only if the number of signficant digits of its &lt;code&gt;value&lt;/code&gt; argument is greater than its &lt;code&gt;comparison&lt;/code&gt; argument. The &lt;code&gt;__builtin_dfp_dtstsfi_gt_dd&lt;/code&gt; and &lt;code&gt;__builtin_dfp_dtstsfi_gt_td&lt;/code&gt; functions behave similarly, but require that the type of the &lt;code&gt;value&lt;/code&gt; argument be &lt;code&gt;__Decimal64&lt;/code&gt; and &lt;code&gt;__Decimal128&lt;/code&gt; respectively.</source>
          <target state="translated">&lt;code&gt;__builtin_dfp_dtstsfi_gt&lt;/code&gt; 의 함수는 0이 아닌 값을 반환하는 경우와의 signficant 자리수에만 &lt;code&gt;value&lt;/code&gt; 인자는보다 큰 &lt;code&gt;comparison&lt;/code&gt; 인수. &lt;code&gt;__builtin_dfp_dtstsfi_gt_dd&lt;/code&gt; 및 &lt;code&gt;__builtin_dfp_dtstsfi_gt_td&lt;/code&gt; 기능이 유사하게 동작하지만, 유형 것을 요구 &lt;code&gt;value&lt;/code&gt; 인수가 될 &lt;code&gt;__Decimal64&lt;/code&gt; 및 &lt;code&gt;__Decimal128&lt;/code&gt; 각각.</target>
        </trans-unit>
        <trans-unit id="b01dbf5e64c194eb164595e23ee9b740573ded8e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_dfp_dtstsfi_lt&lt;/code&gt; function returns a non-zero value if and only if the number of signficant digits of its &lt;code&gt;value&lt;/code&gt; argument is less than its &lt;code&gt;comparison&lt;/code&gt; argument. The &lt;code&gt;__builtin_dfp_dtstsfi_lt_dd&lt;/code&gt; and &lt;code&gt;__builtin_dfp_dtstsfi_lt_td&lt;/code&gt; functions behave similarly, but require that the type of the &lt;code&gt;value&lt;/code&gt; argument be &lt;code&gt;__Decimal64&lt;/code&gt; and &lt;code&gt;__Decimal128&lt;/code&gt; respectively.</source>
          <target state="translated">&lt;code&gt;__builtin_dfp_dtstsfi_lt&lt;/code&gt; 의 함수는 0이 아닌 값을 반환하는 경우와의 signficant 자리수에만 &lt;code&gt;value&lt;/code&gt; 인자는 그보다 적은 &lt;code&gt;comparison&lt;/code&gt; 인수. &lt;code&gt;__builtin_dfp_dtstsfi_lt_dd&lt;/code&gt; 및 &lt;code&gt;__builtin_dfp_dtstsfi_lt_td&lt;/code&gt; 기능이 유사하게 동작하지만, 유형 것을 요구 &lt;code&gt;value&lt;/code&gt; 인수가 될 &lt;code&gt;__Decimal64&lt;/code&gt; 및 &lt;code&gt;__Decimal128&lt;/code&gt; 각각.</target>
        </trans-unit>
        <trans-unit id="b4420e5d860b7c4bb7ba6d7a8d1a6213bfe7043a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_dfp_dtstsfi_ov&lt;/code&gt; function returns a non-zero value if and only if its &lt;code&gt;value&lt;/code&gt; argument has an undefined number of significant digits, such as when &lt;code&gt;value&lt;/code&gt; is an encoding of &lt;code&gt;NaN&lt;/code&gt;. The &lt;code&gt;__builtin_dfp_dtstsfi_ov_dd&lt;/code&gt; and &lt;code&gt;__builtin_dfp_dtstsfi_ov_td&lt;/code&gt; functions behave similarly, but require that the type of the &lt;code&gt;value&lt;/code&gt; argument be &lt;code&gt;__Decimal64&lt;/code&gt; and &lt;code&gt;__Decimal128&lt;/code&gt; respectively.</source>
          <target state="translated">&lt;code&gt;__builtin_dfp_dtstsfi_ov&lt;/code&gt; 의 함수는 0이 아닌 값을 반환하는 경우 및 그 경우에만 &lt;code&gt;value&lt;/code&gt; 인자는 경우와 유효 숫자의 정의되지 않은 수의 보유 &lt;code&gt;value&lt;/code&gt; 의 부호화 인 &lt;code&gt;NaN&lt;/code&gt; 이이 . &lt;code&gt;__builtin_dfp_dtstsfi_ov_dd&lt;/code&gt; 및 &lt;code&gt;__builtin_dfp_dtstsfi_ov_td&lt;/code&gt; 기능이 유사하게 동작하지만, 유형 것을 요구 &lt;code&gt;value&lt;/code&gt; 인수가 될 &lt;code&gt;__Decimal64&lt;/code&gt; 및 &lt;code&gt;__Decimal128&lt;/code&gt; 각각.</target>
        </trans-unit>
        <trans-unit id="a0bfeb225a5faf6d6577d095e4bb9f94249f0a3d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_has_attribute&lt;/code&gt; function evaluates to an integer constant expression equal to &lt;code&gt;true&lt;/code&gt; if the symbol or type referenced by the &lt;var&gt;type-or-expression&lt;/var&gt; argument has been declared with the &lt;var&gt;attribute&lt;/var&gt; referenced by the second argument. For an &lt;var&gt;type-or-expression&lt;/var&gt; argument that does not reference a symbol, since attributes do not apply to expressions the built-in consider the type of the argument. Neither argument is evaluated. The &lt;var&gt;type-or-expression&lt;/var&gt; argument is subject to the same restrictions as the argument to &lt;code&gt;typeof&lt;/code&gt; (see &lt;a href=&quot;typeof#Typeof&quot;&gt;Typeof&lt;/a&gt;). The &lt;var&gt;attribute&lt;/var&gt; argument is an attribute name optionally followed by a comma-separated list of arguments enclosed in parentheses. Both forms of attribute names&amp;mdash;with and without double leading and trailing underscores&amp;mdash;are recognized. See &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;Attribute Syntax&lt;/a&gt;, for details. When no attribute arguments are specified for an attribute that expects one or more arguments the function returns &lt;code&gt;true&lt;/code&gt; if &lt;var&gt;type-or-expression&lt;/var&gt; has been declared with the attribute regardless of the attribute argument values. Arguments provided for an attribute that expects some are validated and matched up to the provided number. The function returns &lt;code&gt;true&lt;/code&gt; if all provided arguments match. For example, the first call to the function below evaluates to &lt;code&gt;true&lt;/code&gt; because &lt;code&gt;x&lt;/code&gt; is declared with the &lt;code&gt;aligned&lt;/code&gt; attribute but the second call evaluates to &lt;code&gt;false&lt;/code&gt; because &lt;code&gt;x&lt;/code&gt; is declared &lt;code&gt;aligned (8)&lt;/code&gt; and not &lt;code&gt;aligned (4)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;__builtin_has_attribute&lt;/code&gt; 의 정수 상수 식과 기능들을 평가는 동일한 &lt;code&gt;true&lt;/code&gt; 에 의해 참조 심볼 또는 입력하면 &lt;var&gt;type-or-expression&lt;/var&gt; 인수는 선언 된 &lt;var&gt;attribute&lt;/var&gt; 번째 인수에 의해 참조. 를 들어 &lt;var&gt;type-or-expression&lt;/var&gt; 속성은 내장 된 인수의 유형을 고려 표현에 적용되지 않기 때문에, 기호를 참조하지 않는 인수입니다. 어느 쪽의 인수도 평가되지 않습니다. &lt;var&gt;type-or-expression&lt;/var&gt; 인자의 인수와 동일한 제한 될 &lt;code&gt;typeof&lt;/code&gt; (참조 &lt;a href=&quot;typeof#Typeof&quot;&gt;대해서 typeof을&lt;/a&gt; ). &lt;var&gt;attribute&lt;/var&gt; argument는 선택적으로 괄호로 묶인 쉼표로 구분 된 인수 목록이 뒤에 오는 속성 이름입니다. 이중 선행 및 후행 밑줄을 포함하거나 포함하지 않는 두 가지 속성 이름 형식이 모두 인식됩니다. 자세한 내용은 &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;속성 구문&lt;/a&gt; 을 참조하십시오. 하나 이상의 인수를 예상하는 속성에 속성 인수가 지정되지 않은 경우 , 속성 인수 값에 관계없이 &lt;var&gt;type-or-expression&lt;/var&gt; 이 속성으로 선언 된 경우 함수는 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다. 일부가 검증되고 제공된 수와 일치 할 것으로 예상되는 속성에 제공된 인수 제공된 인수가 모두 일치하면 이 함수는 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 예를 들어, 아래 함수에 대한 첫 번째 호출은 &lt;code&gt;true&lt;/code&gt; 로 평가됩니다.왜냐하면 &lt;code&gt;x&lt;/code&gt; 는 &lt;code&gt;aligned&lt;/code&gt; 속성으로 선언 되었지만 &lt;code&gt;x&lt;/code&gt; 는 &lt;code&gt;aligned (8)&lt;/code&gt; 이고 &lt;code&gt;aligned (4)&lt;/code&gt; 되지 않은 (4) 이기 때문에 두 번째 호출은 &lt;code&gt;false&lt;/code&gt; 로 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="5cbfc7ec73fa262c76440a5134fc2d0584d6a4cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_is_constant_evaluated&lt;/code&gt; function is available only in C++. The built-in is intended to be used by implementations of the &lt;code&gt;std::is_constant_evaluated&lt;/code&gt; C++ function. Programs should make use of the latter function rather than invoking the built-in directly.</source>
          <target state="translated">&lt;code&gt;__builtin_is_constant_evaluated&lt;/code&gt; 기능은 C ++에서 사용할 수 있습니다. 내장은 &lt;code&gt;std::is_constant_evaluated&lt;/code&gt; C ++ 함수의 구현에서 사용하기위한 것 입니다. 프로그램은 내장 기능을 직접 호출하지 않고 후자의 기능을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="8c4494406f2455746a4c649b18a2c01e01f2fd9b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_mffsl&lt;/code&gt; uses the ISA 3.0 &lt;code&gt;mffsl&lt;/code&gt; instruction to read the FPSCR. The instruction is a lower latency version of the &lt;code&gt;mffs&lt;/code&gt; instruction. If the &lt;code&gt;mffsl&lt;/code&gt; instruction is not available, then the builtin uses the older &lt;code&gt;mffs&lt;/code&gt; instruction to read the FPSCR.</source>
          <target state="translated">&lt;code&gt;__builtin_mffsl&lt;/code&gt; 이 는 ISA 3.0 사용 &lt;code&gt;mffsl&lt;/code&gt; 의 FPSCR을 읽을 수있는 교육을. 명령어는 &lt;code&gt;mffs&lt;/code&gt; 명령어 의 낮은 대기 시간 버전입니다 . 는 IF &lt;code&gt;mffsl&lt;/code&gt; 의 지시가없는 한 다음 내장은 이전 사용 &lt;code&gt;mffs&lt;/code&gt; 의 FPSCR을 읽을 수있는 교육을.</target>
        </trans-unit>
        <trans-unit id="1c6f10224f071b484a2f23cb973dde539bd04b1f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_pack_ibm128&lt;/code&gt; function takes two &lt;code&gt;double&lt;/code&gt; arguments and returns a &lt;code&gt;__ibm128&lt;/code&gt; value that combines the two arguments.</source>
          <target state="translated">&lt;code&gt;__builtin_pack_ibm128&lt;/code&gt; 의 기능이 개 소요 &lt;code&gt;double&lt;/code&gt; 인수와 반환 &lt;code&gt;__ibm128&lt;/code&gt; 의 값 즉 콤바인 두 개의 인수를.</target>
        </trans-unit>
        <trans-unit id="ce45c9f46fdb649818045c7651274a51c7c9b814" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_pack_longdouble&lt;/code&gt; function takes two &lt;code&gt;double&lt;/code&gt; arguments and returns a &lt;code&gt;long double&lt;/code&gt; value that combines the two arguments. The &lt;code&gt;__builtin_pack_longdouble&lt;/code&gt; function is only available if &lt;code&gt;long double&lt;/code&gt; uses the IBM extended double representation.</source>
          <target state="translated">&lt;code&gt;__builtin_pack_longdouble&lt;/code&gt; 함수는 두 개의 소요 &lt;code&gt;double&lt;/code&gt; 인수와 반환 &lt;code&gt;long double&lt;/code&gt; 값 즉 콤바인 두 개의 인수를. &lt;code&gt;__builtin_pack_longdouble&lt;/code&gt; 기능이있는 경우에만 사용할 수 있습니다 &lt;code&gt;long double&lt;/code&gt; 는 IBM이 두 표현을 확장 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8465d06a8e70b59990aa3c2108eef59db7b2906e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_ppc_get_timebase&lt;/code&gt; and &lt;code&gt;__builtin_ppc_mftb&lt;/code&gt; functions generate instructions to read the Time Base Register. The &lt;code&gt;__builtin_ppc_get_timebase&lt;/code&gt; function may generate multiple instructions and always returns the 64 bits of the Time Base Register. The &lt;code&gt;__builtin_ppc_mftb&lt;/code&gt; function always generates one instruction and returns the Time Base Register value as an unsigned long, throwing away the most significant word on 32-bit environments. The &lt;code&gt;__builtin_mffs&lt;/code&gt; return the value of the FPSCR register. Note, ISA 3.0 supports the &lt;code&gt;__builtin_mffsl()&lt;/code&gt; which permits software to read the control and non-sticky status bits in the FSPCR without the higher latency associated with accessing the sticky status bits. The &lt;code&gt;__builtin_mtfsb0&lt;/code&gt; and &lt;code&gt;__builtin_mtfsb1&lt;/code&gt; take the bit to change as an argument. The valid bit range is between 0 and 31. The builtins map to the &lt;code&gt;mtfsb0&lt;/code&gt; and &lt;code&gt;mtfsb1&lt;/code&gt; instructions which take the argument and add 32. Hence these instructions only modify the FPSCR[32:63] bits by changing the specified bit to a zero or one respectively. The &lt;code&gt;__builtin_set_fpscr_rn&lt;/code&gt; builtin allows changing both of the floating point rounding mode bits. The argument is a 2-bit value. The argument can either be a &lt;code&gt;const int&lt;/code&gt; or stored in a variable. The builtin uses the ISA 3.0 instruction &lt;code&gt;mffscrn&lt;/code&gt; if available, otherwise it reads the FPSCR, masks the current rounding mode bits out and OR&amp;rsquo;s in the new value.</source>
          <target state="translated">&lt;code&gt;__builtin_ppc_get_timebase&lt;/code&gt; 및 &lt;code&gt;__builtin_ppc_mftb&lt;/code&gt; 기능은 타임베이스 등록을 읽을 수있는 지침을 생성합니다. &lt;code&gt;__builtin_ppc_get_timebase&lt;/code&gt; 의 기능은 여러 개의 명령어를 생성하고 항상 시간 자료 등록의 64 비트를 반환 할 수 있습니다. &lt;code&gt;__builtin_ppc_mftb&lt;/code&gt; 의 함수는 항상 32 비트 환경에서 가장 중요한 단어를 버리고, 긴 부호로 하나의 명령어 및 반환 타임베이스 레지스터 값을 생성합니다. &lt;code&gt;__builtin_mffs&lt;/code&gt; 는 FPSCR 레지스터의 값을 반환합니다. ISA 3.0은 &lt;code&gt;__builtin_mffsl()&lt;/code&gt; 지원합니다.이는 소프트웨어가 고정 상태 비트 액세스와 관련된 높은 대기 시간없이 FSPCR에서 제어 및 비 고정 상태 비트를 읽을 수 있도록합니다. &lt;code&gt;__builtin_mtfsb0&lt;/code&gt; 은 과 &lt;code&gt;__builtin_mtfsb1&lt;/code&gt; 인수로 변화 비트를 취할. 유효한 비트 범위는 0과 31 사이입니다. 내장 은 인수를 취하고 32를 추가 하는 &lt;code&gt;mtfsb0&lt;/code&gt; 및 &lt;code&gt;mtfsb1&lt;/code&gt; 명령어에 매핑됩니다 . 따라서 이러한 명령어는 지정된 비트를 0 또는 1로 변경하여 FPSCR [32:63] 비트 만 수정합니다. 각기. &lt;code&gt;__builtin_set_fpscr_rn&lt;/code&gt; 내장 모드 비트를 라운딩 부동 소수점의 양을 변경 허용한다. 인수는 2 비트 값입니다. 인수는 &lt;code&gt;const int&lt;/code&gt; 일 수 있습니다.또는 변수에 저장됩니다. &lt;code&gt;mffscrn&lt;/code&gt; 사용 가능한 경우 ISA 3.0 명령어 mffscrn을 사용하고, 그렇지 않으면 FPSCR을 읽고 현재 반올림 모드 비트를 마스킹하고 OR을 새 값으로 마스킹합니다.</target>
        </trans-unit>
        <trans-unit id="f74488ec411590dcc75315f19183a037dc14b9ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_ppc_get_timebase&lt;/code&gt; and &lt;code&gt;__builtin_ppc_mftb&lt;/code&gt; functions generate instructions to read the Time Base Register. The &lt;code&gt;__builtin_ppc_get_timebase&lt;/code&gt; function may generate multiple instructions and always returns the 64 bits of the Time Base Register. The &lt;code&gt;__builtin_ppc_mftb&lt;/code&gt; function always generates one instruction and returns the Time Base Register value as an unsigned long, throwing away the most significant word on 32-bit environments. The &lt;code&gt;__builtin_mffs&lt;/code&gt; return the value of the FPSCR register. Note, ISA 3.0 supports the &lt;code&gt;__builtin_mffsl()&lt;/code&gt; which permits software to read the control and non-sticky status bits in the FSPCR without the higher latency associated with accessing the sticky status bits. The &lt;code&gt;__builtin_mtfsf&lt;/code&gt; takes a constant 8-bit integer field mask and a double precision floating point argument and generates the &lt;code&gt;mtfsf&lt;/code&gt; (extended mnemonic) instruction to write new values to selected fields of the FPSCR. The &lt;code&gt;__builtin_mtfsb0&lt;/code&gt; and &lt;code&gt;__builtin_mtfsb1&lt;/code&gt; take the bit to change as an argument. The valid bit range is between 0 and 31. The builtins map to the &lt;code&gt;mtfsb0&lt;/code&gt; and &lt;code&gt;mtfsb1&lt;/code&gt; instructions which take the argument and add 32. Hence these instructions only modify the FPSCR[32:63] bits by changing the specified bit to a zero or one respectively. The &lt;code&gt;__builtin_set_fpscr_rn&lt;/code&gt; builtin allows changing both of the floating point rounding mode bits. The argument is a 2-bit value. The argument can either be a &lt;code&gt;const int&lt;/code&gt; or stored in a variable. The builtin uses the ISA 3.0 instruction &lt;code&gt;mffscrn&lt;/code&gt; if available, otherwise it reads the FPSCR, masks the current rounding mode bits out and OR&amp;rsquo;s in the new value.</source>
          <target state="translated">&lt;code&gt;__builtin_ppc_get_timebase&lt;/code&gt; 및 &lt;code&gt;__builtin_ppc_mftb&lt;/code&gt; 기능은 타임베이스 등록을 읽을 수있는 지침을 생성합니다. &lt;code&gt;__builtin_ppc_get_timebase&lt;/code&gt; 의 기능은 여러 개의 명령어를 생성하고 항상 시간 자료 등록의 64 비트를 반환 할 수 있습니다. &lt;code&gt;__builtin_ppc_mftb&lt;/code&gt; 의 함수는 항상 32 비트 환경에서 가장 중요한 단어를 버리고, 긴 부호로 하나의 명령어 및 반환 타임베이스 레지스터 값을 생성합니다. &lt;code&gt;__builtin_mffs&lt;/code&gt; 는 FPSCR 레지스터의 값을 반환합니다. ISA 3.0은 &lt;code&gt;__builtin_mffsl()&lt;/code&gt; 지원합니다.이를 통해 소프트웨어는 고정 상태 비트에 액세스하는 것과 관련된 더 높은 대기 시간없이 FSPCR에서 제어 및 고정되지 않은 상태 비트를 읽을 수 있습니다. &lt;code&gt;__builtin_mtfsf&lt;/code&gt; 는 일정한 8 비트 정수 필드 마스크와 배정 밀도 부동 소수점 인수를 상기 생성 &lt;code&gt;mtfsf&lt;/code&gt; FPSCR의 선택된 필드에 새로운 값을 기입하기 (확장 니모닉) 명령. &lt;code&gt;__builtin_mtfsb0&lt;/code&gt; 은 과 &lt;code&gt;__builtin_mtfsb1&lt;/code&gt; 인수로 변화 비트를 취할. 유효한 비트 범위는 0에서 31 사이입니다. 내장 기능은 &lt;code&gt;mtfsb0&lt;/code&gt; 및 &lt;code&gt;mtfsb1&lt;/code&gt; 에 매핑됩니다.인수를 취하고 32를 더하는 명령어. 따라서이 명령어는 지정된 비트를 각각 0 또는 1로 변경하여 FPSCR [32:63] 비트 만 수정합니다. &lt;code&gt;__builtin_set_fpscr_rn&lt;/code&gt; 내장 모드 비트를 라운딩 부동 소수점의 양을 변경 허용한다. 인수는 2 비트 값입니다. 인수는 &lt;code&gt;const int&lt;/code&gt; 이거나 변수에 저장 될 수 있습니다 . 내장은 사용 가능한 경우 ISA 3.0 명령 &lt;code&gt;mffscrn&lt;/code&gt; 을 사용하고, 그렇지 않으면 FPSCR을 읽고 현재 반올림 모드 비트를 마스킹하고 새 값에서 OR을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="198788e1a597fcc05831a074890ff7147c3e1998" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_recipdiv&lt;/code&gt;, and &lt;code&gt;__builtin_recipdivf&lt;/code&gt; functions generate multiple instructions to implement division using the reciprocal estimate instructions.</source>
          <target state="translated">&lt;code&gt;__builtin_recipdiv&lt;/code&gt; 및 &lt;code&gt;__builtin_recipdivf&lt;/code&gt; 기능 역수 추정 지침을 사용하여 분할을 구현하는 다수의 명령들을 발생시킨다.</target>
        </trans-unit>
        <trans-unit id="eca84e06c376750982f7cbde8f6e8edd81f796b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_unpack_ibm128&lt;/code&gt; function takes a &lt;code&gt;__ibm128&lt;/code&gt; argument and a compile time constant of 0 or 1. If the constant is 0, the first &lt;code&gt;double&lt;/code&gt; within the &lt;code&gt;__ibm128&lt;/code&gt; is returned, otherwise the second &lt;code&gt;double&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;__builtin_unpack_ibm128&lt;/code&gt; 의 기능은 얻어 &lt;code&gt;__ibm128&lt;/code&gt; 의 인자 및 정수 0, 첫번째 경우는 0 또는 1의 컴파일 시간 상수 &lt;code&gt;double&lt;/code&gt; 내의 &lt;code&gt;__ibm128&lt;/code&gt; 반환되고, 그렇지 않으면 두 번째 &lt;code&gt;double&lt;/code&gt; 리턴된다.</target>
        </trans-unit>
        <trans-unit id="48855b25f6a50b8b8736a064f19a8b37e730a064" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__builtin_unpack_longdouble&lt;/code&gt; function takes a &lt;code&gt;long double&lt;/code&gt; argument and a compile time constant of 0 or 1. If the constant is 0, the first &lt;code&gt;double&lt;/code&gt; within the &lt;code&gt;long double&lt;/code&gt; is returned, otherwise the second &lt;code&gt;double&lt;/code&gt; is returned. The &lt;code&gt;__builtin_unpack_longdouble&lt;/code&gt; function is only available if &lt;code&gt;long double&lt;/code&gt; uses the IBM extended double representation.</source>
          <target state="translated">&lt;code&gt;__builtin_unpack_longdouble&lt;/code&gt; 함수 걸리는 &lt;code&gt;long double&lt;/code&gt; 인자는 0 또는 1 인 정수 0 인 경우의 컴파일 시간 상수, 제 &lt;code&gt;double&lt;/code&gt; 내의 &lt;code&gt;long double&lt;/code&gt; 반환되고, 그렇지 않으면 두 번째 &lt;code&gt;double&lt;/code&gt; 리턴된다. &lt;code&gt;__builtin_unpack_longdouble&lt;/code&gt; 기능이있는 경우에만 사용할 수 있습니다 &lt;code&gt;long double&lt;/code&gt; 는 IBM이 두 표현을 확장 사용합니다.</target>
        </trans-unit>
        <trans-unit id="cf7f4f10325e1d8819fa9c82ff898e127032c07d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__flash&lt;/code&gt; qualifier locates data in the &lt;code&gt;.progmem.data&lt;/code&gt; section. Data is read using the &lt;code&gt;LPM&lt;/code&gt; instruction. Pointers to this address space are 16 bits wide.</source>
          <target state="translated">&lt;code&gt;__flash&lt;/code&gt; 데이터의 위치를 규정 &lt;code&gt;.progmem.data&lt;/code&gt; 섹션을 참조하십시오. &lt;code&gt;LPM&lt;/code&gt; 명령어를 사용하여 데이터를 읽습니다 . 이 주소 공간에 대한 포인터의 폭은 16 비트입니다.</target>
        </trans-unit>
        <trans-unit id="097ea3d6342e0a23a9235845e85db17d4022ac6d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__fp16&lt;/code&gt; type may only be used as an argument to intrinsics defined in &lt;code&gt;&amp;lt;arm_fp16.h&amp;gt;&lt;/code&gt;, or as a storage format. For purposes of arithmetic and other operations, &lt;code&gt;__fp16&lt;/code&gt; values in C or C++ expressions are automatically promoted to &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;__fp16&lt;/code&gt; 의 타입은 정의 내장 인수로서 이용 될 수있다 &lt;code&gt;&amp;lt;arm_fp16.h&amp;gt;&lt;/code&gt; 또는 저장 포맷. 산술 및 기타 연산을 위해 C 또는 C ++ 표현식의 &lt;code&gt;__fp16&lt;/code&gt; 값은 자동으로 &lt;code&gt;float&lt;/code&gt; 로 승격됩니다 .</target>
        </trans-unit>
        <trans-unit id="ec03917f805a8e50fbb98586530e665bfe69da73" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__thread&lt;/code&gt; specifier can be applied only to the names of objects and to anonymous unions.</source>
          <target state="translated">&lt;code&gt;__thread&lt;/code&gt; 의 지정은 객체의 이름과 익명 조합에 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3af60ab1131c66623c0fb9cd375a6e888cff899" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__thread&lt;/code&gt; specifier may be applied to any global, file-scoped static, function-scoped static, or static data member of a class. It may not be applied to block-scoped automatic or non-static data member.</source>
          <target state="translated">&lt;code&gt;__thread&lt;/code&gt; 의 지정자 클래스의 전역 파일 범위의 정적 기능 범위의 고정 또는 정적 데이터 부재에 적용될 수있다. 블록 범위의 자동 또는 비 정적 데이터 멤버에는 적용되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8177fe879ae4fe2cff503c3513d84606c176b85" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__thread&lt;/code&gt; specifier may be used alone, with the &lt;code&gt;extern&lt;/code&gt; or &lt;code&gt;static&lt;/code&gt; specifiers, but with no other storage class specifier. When used with &lt;code&gt;extern&lt;/code&gt; or &lt;code&gt;static&lt;/code&gt;, &lt;code&gt;__thread&lt;/code&gt; must appear immediately after the other storage class specifier.</source>
          <target state="translated">&lt;code&gt;__thread&lt;/code&gt; 의 지정은 함께 단독으로 사용할 수 있고 &lt;code&gt;extern&lt;/code&gt; 이나 &lt;code&gt;static&lt;/code&gt; 지정자,하지만 다른 스토리지 클래스 지정자. &lt;code&gt;extern&lt;/code&gt; 또는 &lt;code&gt;static&lt;/code&gt; 과 함께 사용되는 경우 &lt;code&gt;__thread&lt;/code&gt; 는 다른 스토리지 클래스 지정자 바로 다음에 나타나야합니다.</target>
        </trans-unit>
        <trans-unit id="63dae9f24b29dc710773ce4dac88b4e87c3c52d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__thread&lt;/code&gt; specifier shall be used only with variables.</source>
          <target state="translated">&lt;code&gt;__thread&lt;/code&gt; 의 지정은 변수와 함께 사용한다.</target>
        </trans-unit>
        <trans-unit id="adf603edfc142efac4a9a3b77d51d44293820a8f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__trampolines_start&lt;/code&gt; symbol is defined in the linker script.</source>
          <target state="translated">&lt;code&gt;__trampolines_start&lt;/code&gt; 의 기호는 링커 스크립트에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="375e8541e5237f24ef902439af8b3c21cd835020" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;d&lt;/code&gt; registers. This class is used for instructions that return double word results in the &lt;code&gt;ax:dx&lt;/code&gt; register pair. Single word values will be allocated either in &lt;code&gt;ax&lt;/code&gt; or &lt;code&gt;dx&lt;/code&gt;. For example on i386 the following implements &lt;code&gt;rdtsc&lt;/code&gt;:</source>
          <target state="translated">및 &lt;code&gt;d&lt;/code&gt; 레지스터. 이 클래스는 &lt;code&gt;ax:dx&lt;/code&gt; 레지스터 쌍 에서 더블 워드 결과를 반환하는 명령어에 사용됩니다 . 단일 단어 값은 &lt;code&gt;ax&lt;/code&gt; 또는 &lt;code&gt;dx&lt;/code&gt; 로 할당됩니다 . 예를 들어 i386에서 다음은 &lt;code&gt;rdtsc&lt;/code&gt; 를 구현합니다 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a0d40f91f92592e29ec24cddc648e15fc94fdbdb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;a&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 레지스터.</target>
        </trans-unit>
        <trans-unit id="bf9b97f6ebb578cc8aa854722849a8e5b4602c9c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;abi_tag&lt;/code&gt; attribute can be applied to a function, variable, or class declaration. It modifies the mangled name of the entity to incorporate the tag name, in order to distinguish the function or class from an earlier version with a different ABI; perhaps the class has changed size, or the function has a different return type that is not encoded in the mangled name.</source>
          <target state="translated">&lt;code&gt;abi_tag&lt;/code&gt; 의 특성 함수, 변수 또는 클래스 선언에 적용될 수있다. 다른 ABI를 가진 이전 버전과 기능 또는 클래스를 구별하기 위해 태그 이름을 통합하도록 엔티티의 엉망인 이름을 수정합니다. 클래스의 크기가 변경되었거나 함수에 맹 글링 된 이름으로 인코딩되지 않은 다른 반환 유형이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7fe3aef8751a598cb1fd1f579f51dc2e77fc03d5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;access&lt;/code&gt; attribute enables the detection of invalid or unsafe accesses by functions to which they apply or their callers, as well as write-only accesses to objects that are never read from. Such accesses may be diagnosed by warnings such as</source>
          <target state="translated">&lt;code&gt;access&lt;/code&gt; 속성은 그들이 적용되는 기능 또는 발신자에 의해 무효 또는 안전하지 않은 액세스의 검출뿐만 아니라, 쓰기 전용에서 읽어 본 적이 된 개체에 액세스 할 수 있습니다. 이러한 액세스는 다음과 같은 경고로 진단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3485b263c83290ae97682123760b0adc0b05426c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;access&lt;/code&gt; attribute specifies that a function to whose by-reference arguments the attribute applies accesses the referenced object according to &lt;var&gt;access-mode&lt;/var&gt;. The &lt;var&gt;access-mode&lt;/var&gt; argument is required and must be one of three names: &lt;code&gt;read_only&lt;/code&gt;, &lt;code&gt;read_write&lt;/code&gt;, or &lt;code&gt;write_only&lt;/code&gt;. The remaining two are positional arguments.</source>
          <target state="translated">&lt;code&gt;access&lt;/code&gt; 속성 지정하는 속성을 적용하여, 그 참조하는 인자 함수에 따라 참조 된 개체에 액세스하는 &lt;var&gt;access-mode&lt;/var&gt; . &lt;var&gt;access-mode&lt;/var&gt; 인수가 필요하며 세 가지 이름 중 하나 여야합니다 &lt;code&gt;read_only&lt;/code&gt; , &lt;code&gt;read_write&lt;/code&gt; 또는 &lt;code&gt;write_only&lt;/code&gt; . 나머지 두 개는 위치 인수입니다.</target>
        </trans-unit>
        <trans-unit id="2ecdfed9d96d6be598a27e07d494142206025586" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;alias&lt;/code&gt; attribute causes the declaration to be emitted as an alias for another symbol, which must be specified. For instance,</source>
          <target state="translated">&lt;code&gt;alias&lt;/code&gt; 속성 선언 지정해야 다른 심볼에 대한 별칭으로 출사되도록. 예를 들어</target>
        </trans-unit>
        <trans-unit id="7e61edae77066dd3dc159fcdac928cd068378010" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;alias&lt;/code&gt; attribute causes the declaration to be emitted as an alias for another symbol, which must have been previously declared with the same type, and for variables, also the same size and alignment. Declaring an alias with a different type than the target is undefined and may be diagnosed. As an example, the following declarations:</source>
          <target state="translated">&lt;code&gt;alias&lt;/code&gt; 속성 선언 이전과 동일한 유형 선언되어 있어야 다른 심볼에 대한 별칭으로 출사되도록, 변수, 동일한 크기와 정렬. 대상과 다른 유형으로 별칭을 선언하는 것은 정의되지 않았으며 진단 될 수 있습니다. 예를 들어 다음 선언은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="eb2be5f23f4d95994e296cf8157df7b27aa96115" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;alias&lt;/code&gt; variable attribute causes the declaration to be emitted as an alias for another symbol known as an &lt;em&gt;alias target&lt;/em&gt;. Except for top-level qualifiers the alias target must have the same type as the alias. For instance, the following</source>
          <target state="translated">&lt;code&gt;alias&lt;/code&gt; 가변 속성 선언이 알려진 다른 심볼에 대한 별칭으로 출사되도록 &lt;em&gt;별명 타겟&lt;/em&gt; . 최상위 수준 한정자를 제외하고 별칭 대상은 별칭과 동일한 유형을 가져야합니다. 예를 들어, 다음</target>
        </trans-unit>
        <trans-unit id="0bf61029ae4ce438827c598f61cf786192d3f583" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;aligned&lt;/code&gt; attribute can also be used for functions (see &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;.)</source>
          <target state="translated">&lt;code&gt;aligned&lt;/code&gt; 특성은 (보고 기능에 사용할 수있는 &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;일반 기능 특성&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="116110dd4cf7976fa8985541dcc415370c4044c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;aligned&lt;/code&gt; attribute can also be used for variables and fields (see &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;.)</source>
          <target state="translated">&lt;code&gt;aligned&lt;/code&gt; 속성은 변수 필드에 사용될 수있다 (참조 : &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;가변 속성&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="5b5ae34d39ede17878fd463e5860c5561589d603" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;aligned&lt;/code&gt; attribute specifies a minimum alignment (in bytes) for variables of the specified type. When specified, &lt;var&gt;alignment&lt;/var&gt; must be a power of 2. Specifying no &lt;var&gt;alignment&lt;/var&gt; argument implies the maximum alignment for the target, which is often, but by no means always, 8 or 16 bytes. For example, the declarations:</source>
          <target state="translated">&lt;code&gt;aligned&lt;/code&gt; 속성은 지정된 타입의 변수 (바이트)의 최소 정렬을 지정한다. 지정 될 때 &lt;var&gt;alignment&lt;/var&gt; 은 2의 거듭 제곱이어야합니다. &lt;var&gt;alignment&lt;/var&gt; 인수를 지정하지 않으면 대상의 최대 정렬이 필요하지만 항상 8 바이트 또는 16 바이트는 아닙니다. 예를 들어, 선언 :</target>
        </trans-unit>
        <trans-unit id="84a176d406c41abb708c1f3ca71eadfaf0924f9d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;aligned&lt;/code&gt; attribute specifies a minimum alignment for the first instruction of the function, measured in bytes. When specified, &lt;var&gt;alignment&lt;/var&gt; must be an integer constant power of 2. Specifying no &lt;var&gt;alignment&lt;/var&gt; argument implies the ideal alignment for the target. The &lt;code&gt;__alignof__&lt;/code&gt; operator can be used to determine what that is (see &lt;a href=&quot;alignment#Alignment&quot;&gt;Alignment&lt;/a&gt;). The attribute has no effect when a definition for the function is not provided in the same translation unit.</source>
          <target state="translated">&lt;code&gt;aligned&lt;/code&gt; 특성은 바이트 단위 함수의 첫 번째 명령을위한 최소 정렬을 지정한다. 지정 될 때 &lt;var&gt;alignment&lt;/var&gt; 은 2의 정수 상수 제곱이어야합니다. &lt;var&gt;alignment&lt;/var&gt; 인수를 지정하지 않으면 대상에 대한 이상적인 정렬을 의미합니다. &lt;code&gt;__alignof__&lt;/code&gt; 의 연산자는 그 (참조 무엇인지 확인하는 데 사용할 수 있습니다 &lt;a href=&quot;alignment#Alignment&quot;&gt;정렬을&lt;/a&gt; ). 함수에 대한 정의가 동일한 변환 단위로 제공되지 않으면 속성이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8ba9bd3f254f0cc2bc69cd8b105c1d09efd2f77c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;aligned&lt;/code&gt; attribute specifies a minimum alignment for the variable or structure field, measured in bytes. When specified, &lt;var&gt;alignment&lt;/var&gt; must be an integer constant power of 2. Specifying no &lt;var&gt;alignment&lt;/var&gt; argument implies the maximum alignment for the target, which is often, but by no means always, 8 or 16 bytes.</source>
          <target state="translated">&lt;code&gt;aligned&lt;/code&gt; 특성은 바이트 단위 가변 구조 또는 필드의 최소 정렬을 지정. 지정 될 때 &lt;var&gt;alignment&lt;/var&gt; 는 정수 상수 2의 정수 여야합니다. &lt;var&gt;alignment&lt;/var&gt; 인수를 지정하지 않으면 대상에 대한 최대 정렬이 필요하지만 항상 8 바이트 또는 16 바이트는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="f46b2b0bb9e3e850ca63944ddf914702b4818ed3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;alloc_align&lt;/code&gt; attribute may be applied to a function that returns a pointer and takes at least one argument of an integer or enumerated type. It indicates that the returned pointer is aligned on a boundary given by the function argument at &lt;var&gt;position&lt;/var&gt;. Meaningful alignments are powers of 2 greater than one. GCC uses this information to improve pointer alignment analysis.</source>
          <target state="translated">&lt;code&gt;alloc_align&lt;/code&gt; 속성 포인터를 리턴하고, 정수 또는 열거 형 중 적어도 하나 개의 인수를 취하는 함수에 적용될 수있다. 반환 된 포인터가 &lt;var&gt;position&lt;/var&gt; 의 함수 인수가 제공 한 경계에 정렬되었음을 나타냅니다 . 의미있는 정렬은 1보다 큰 2의 거듭 제곱입니다. GCC는이 정보를 사용하여 포인터 정렬 분석을 개선합니다.</target>
        </trans-unit>
        <trans-unit id="8797cd128649602028c5dfdc7369a0575f411979" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;alloc_size&lt;/code&gt; attribute may be applied to a function that returns a pointer and takes at least one argument of an integer or enumerated type. It indicates that the returned pointer points to memory whose size is given by the function argument at &lt;var&gt;position-1&lt;/var&gt;, or by the product of the arguments at &lt;var&gt;position-1&lt;/var&gt; and &lt;var&gt;position-2&lt;/var&gt;. Meaningful sizes are positive values less than &lt;code&gt;PTRDIFF_MAX&lt;/code&gt;. GCC uses this information to improve the results of &lt;code&gt;__builtin_object_size&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;alloc_size&lt;/code&gt; 의 속성이 리턴 포인터 함수에 적용하고, 정수 또는 열거 된 유형의 적어도 하나 개의 인자를 할 수있다. 리턴 된 포인터가 size가 &lt;var&gt;position-1&lt;/var&gt; 의 함수 인수 또는 &lt;var&gt;position-1&lt;/var&gt; 및 &lt;var&gt;position-2&lt;/var&gt; 의 인수 곱에 의해 주어진 메모리를 가리킴을 나타냅니다 . 의미있는 크기는 &lt;code&gt;PTRDIFF_MAX&lt;/code&gt; 보다 작은 양수 값 입니다. GCC는이 정보를 사용하여 &lt;code&gt;__builtin_object_size&lt;/code&gt; 결과를 개선합니다 .</target>
        </trans-unit>
        <trans-unit id="f06aab07630994254a1a8fb1c75da104d280fc4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;alloc_size&lt;/code&gt; type attribute may be applied to the definition of a type of a function that returns a pointer and takes at least one argument of an integer type. It indicates that the returned pointer points to an object whose size is given by the function argument at &lt;var&gt;position-1&lt;/var&gt;, or by the product of the arguments at &lt;var&gt;position-1&lt;/var&gt; and &lt;var&gt;position-2&lt;/var&gt;. Meaningful sizes are positive values less than &lt;code&gt;PTRDIFF_MAX&lt;/code&gt;. Other sizes are disagnosed when detected. GCC uses this information to improve the results of &lt;code&gt;__builtin_object_size&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;alloc_size&lt;/code&gt; 의 유형 속성은 해당 함수 리턴 포인터의 유형의 정의에 적용된 정수 타입 중 적어도 하나 개의 인자를 할 수있다. 반환 된 포인터가 &lt;var&gt;position-1&lt;/var&gt; 의 함수 인수 또는 &lt;var&gt;position-1&lt;/var&gt; 과 &lt;var&gt;position-2&lt;/var&gt; 의 인수 곱으로 크기가 지정된 객체를 가리킴을 나타냅니다 . 의미있는 크기는 &lt;code&gt;PTRDIFF_MAX&lt;/code&gt; 보다 작은 양수 값 입니다. 다른 크기는 감지되면 무시됩니다. GCC는이 정보를 사용하여 &lt;code&gt;__builtin_object_size&lt;/code&gt; 결과를 개선합니다 .</target>
        </trans-unit>
        <trans-unit id="065a219ddaff6d679a0be49eb2bd7f719e312c3d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;alloc_size&lt;/code&gt; variable attribute may be applied to the declaration of a pointer to a function that returns a pointer and takes at least one argument of an integer type. It indicates that the returned pointer points to an object whose size is given by the function argument at &lt;var&gt;position-1&lt;/var&gt;, or by the product of the arguments at &lt;var&gt;position-1&lt;/var&gt; and &lt;var&gt;position-2&lt;/var&gt;. Meaningful sizes are positive values less than &lt;code&gt;PTRDIFF_MAX&lt;/code&gt;. Other sizes are disagnosed when detected. GCC uses this information to improve the results of &lt;code&gt;__builtin_object_size&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;alloc_size&lt;/code&gt; 의 변수 특성은 리턴 포인터 함수 포인터의 선언에 적용된 정수 타입 중 적어도 하나 개의 인자를 할 수있다. 반환 된 포인터가 &lt;var&gt;position-1&lt;/var&gt; 의 함수 인수 또는 &lt;var&gt;position-1&lt;/var&gt; 과 &lt;var&gt;position-2&lt;/var&gt; 의 인수 곱으로 크기가 지정된 객체를 나타냅니다 . 의미있는 크기는 &lt;code&gt;PTRDIFF_MAX&lt;/code&gt; 보다 작은 양수 값 입니다. 다른 크기는 감지되면 무시됩니다. GCC는이 정보를 사용하여 &lt;code&gt;__builtin_object_size&lt;/code&gt; 결과를 개선합니다 .</target>
        </trans-unit>
        <trans-unit id="cbdc1421fb579e3bcb9c9ed2bb5181ffe0b47ee4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;asm&lt;/code&gt; keyword allows you to embed assembler instructions within C code. GCC provides two forms of inline &lt;code&gt;asm&lt;/code&gt; statements. A &lt;em&gt;basic &lt;code&gt;asm&lt;/code&gt;&lt;/em&gt; statement is one with no operands (see &lt;a href=&quot;basic-asm#Basic-Asm&quot;&gt;Basic Asm&lt;/a&gt;), while an &lt;em&gt;extended &lt;code&gt;asm&lt;/code&gt;&lt;/em&gt; statement (see &lt;a href=&quot;extended-asm#Extended-Asm&quot;&gt;Extended Asm&lt;/a&gt;) includes one or more operands. The extended form is preferred for mixing C and assembly language within a function, but to include assembly language at top level you must use basic &lt;code&gt;asm&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;asm&lt;/code&gt; 키워드는 C 코드 내 포함 어셈블러 지침을 수행 할 수 있습니다. GCC는 두 가지 형식의 인라인 &lt;code&gt;asm&lt;/code&gt; 문을 제공합니다. &lt;em&gt;기본 &lt;code&gt;asm&lt;/code&gt; &lt;/em&gt; 문이없는 피연산자 하나 (참조입니다 &lt;a href=&quot;basic-asm#Basic-Asm&quot;&gt;기본은 ASM&lt;/a&gt; 동안) &lt;em&gt;확장 &lt;code&gt;asm&lt;/code&gt; &lt;/em&gt; 문 (참조 &lt;a href=&quot;extended-asm#Extended-Asm&quot;&gt;어셈블러에 확장&lt;/a&gt; ) 하나 이상의 피연산자가 포함되어 있습니다. 확장 된 형식은 함수 내에서 C와 어셈블리 언어를 혼합하는 데 선호되지만 최상위에 어셈블리 언어를 포함하려면 기본 &lt;code&gt;asm&lt;/code&gt; 을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c83f20d0e6ffe18a83c8f1ea64e1025e8b4e3b79" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;asm&lt;/code&gt; keyword is a GNU extension. When writing code that can be compiled with</source>
          <target state="translated">&lt;code&gt;asm&lt;/code&gt; 키워드는 GNU 확장이다. 컴파일 할 수있는 코드를 작성할 때</target>
        </trans-unit>
        <trans-unit id="5154cd3afb55ec67fd254011d045e0b4c9d93a08" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;asm&lt;/code&gt; statement allows you to include assembly instructions directly within C code. This may help you to maximize performance in time-sensitive code or to access assembly instructions that are not readily available to C programs.</source>
          <target state="translated">&lt;code&gt;asm&lt;/code&gt; 문을 직접 C 코드 내에서 조립 지침을 포함시킬 수 있습니다. 이를 통해 시간에 민감한 코드의 성능을 최대화하거나 C 프로그램에서 쉽게 사용할 수없는 어셈블리 명령어에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="889a71d5c542b05221a1fea4fb081bfa156749e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;assume_aligned&lt;/code&gt; attribute may be applied to a function that returns a pointer. It indicates that the returned pointer is aligned on a boundary given by &lt;var&gt;alignment&lt;/var&gt;. If the attribute has two arguments, the second argument is misalignment &lt;var&gt;offset&lt;/var&gt;. Meaningful values of &lt;var&gt;alignment&lt;/var&gt; are powers of 2 greater than one. Meaningful values of &lt;var&gt;offset&lt;/var&gt; are greater than zero and less than &lt;var&gt;alignment&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;assume_aligned&lt;/code&gt; 속성은 포인터를 반환하는 함수에 적용 할 수있다. 반환 된 포인터가 &lt;var&gt;alignment&lt;/var&gt; 로 지정된 경계에 정렬되어 있음을 나타냅니다 . 속성에 두 개의 인수가있는 경우 두 번째 인수는 misalignment &lt;var&gt;offset&lt;/var&gt; 입니다. 의미있는 &lt;var&gt;alignment&lt;/var&gt; 값은 1보다 큰 2의 거듭 제곱입니다. 의미있는 &lt;var&gt;offset&lt;/var&gt; 값은 0보다 크고 &lt;var&gt;alignment&lt;/var&gt; 보다 작습니다 .</target>
        </trans-unit>
        <trans-unit id="e7eb78f1e02d22076254e95ec303c8093068484f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;aux&lt;/code&gt; attribute is used to directly access the ARC&amp;rsquo;s auxiliary register space from C. The auxilirary register number is given via attribute argument.</source>
          <target state="translated">&lt;code&gt;aux&lt;/code&gt; 속성 직접 auxilirary 레지스터 번호 속성 인수로 주어진 C.에서 ARC의 보조 레지스터 공간에 액세스하기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="b63bd6b23aa2da11430c3217df7f40955b5b703f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;b&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; 등록한다.</target>
        </trans-unit>
        <trans-unit id="0166d882668eb629f4c81b26d5f43ba89f13484a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;c&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; 레지스터.</target>
        </trans-unit>
        <trans-unit id="07fada73a7cf214a1328d2a6e8cd842b7cf5c1a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cf_check&lt;/code&gt; attribute on a function is used to inform the compiler that ENDBR instruction should be placed at the function entry when</source>
          <target state="translated">함수 의 &lt;code&gt;cf_check&lt;/code&gt; 속성은 컴파일러에게 ENDBR 명령어가 함수 입력에 배치되어야 함을 알리는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ca2675a5f39c8ca20fe391d93c61cca5056e32cc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cleanup&lt;/code&gt; attribute runs a function when the variable goes out of scope. This attribute can only be applied to auto function scope variables; it may not be applied to parameters or variables with static storage duration. The function must take one parameter, a pointer to a type compatible with the variable. The return value of the function (if any) is ignored.</source>
          <target state="translated">&lt;code&gt;cleanup&lt;/code&gt; 변수가 범위를 벗어나면 속성은 함수를 실행합니다. 이 속성은 자동 기능 범위 변수에만 적용 할 수 있습니다. 정적 저장 시간을 갖는 매개 변수 또는 변수에는 적용되지 않을 수 있습니다. 함수는 변수와 호환되는 유형에 대한 포인터 인 하나의 매개 변수를 가져야합니다. 함수의 리턴 값 (있는 경우)은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="85d44203c9f2ae9c43811502121d3c877febd137" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cold&lt;/code&gt; attribute on functions is used to inform the compiler that the function is unlikely to be executed. The function is optimized for size rather than speed and on many targets it is placed into a special subsection of the text section so all cold functions appear close together, improving code locality of non-cold parts of program. The paths leading to calls of cold functions within code are marked as unlikely by the branch prediction mechanism. It is thus useful to mark functions used to handle unlikely conditions, such as &lt;code&gt;perror&lt;/code&gt;, as cold to improve optimization of hot functions that do call marked functions in rare occasions.</source>
          <target state="translated">함수 의 &lt;code&gt;cold&lt;/code&gt; 속성은 컴파일러에게 함수가 실행되지 않을 것임을 알리는 데 사용됩니다. 이 기능은 속도보다는 크기에 맞게 최적화되어 있으며 많은 대상에서 텍스트 섹션의 특수 하위 섹션에 배치되므로 모든 콜드 기능이 서로 가깝게 표시되어 비 콜드 프로그램 부분의 코드 위치가 향상됩니다. 코드 내에서 콜드 함수 호출로 이어지는 경로는 분기 예측 메커니즘에 따라 표시되지 않습니다. 따라서 드문 경우에 표시된 함수를 호출하는 핫 함수의 최적화를 개선하기 위해 &lt;code&gt;perror&lt;/code&gt; 와 같은 가능성이 낮은 조건을 처리하는 데 사용되는 함수 를 콜드 로 표시하는 것이 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="baaebf592a1c26312204d234ba4d0961fa9cfdc4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cold&lt;/code&gt; attribute on labels is used to inform the compiler that the path following the label is unlikely to be executed. This attribute is used in cases where &lt;code&gt;__builtin_expect&lt;/code&gt; cannot be used, for instance with computed goto or &lt;code&gt;asm goto&lt;/code&gt;.</source>
          <target state="translated">레이블 의 &lt;code&gt;cold&lt;/code&gt; 속성은 레이블 뒤의 경로가 실행되지 않을 것임을 컴파일러에 알리는 데 사용됩니다. 이 속성은 계산 된 goto 또는 &lt;code&gt;asm goto&lt;/code&gt; 와 같이 &lt;code&gt;__builtin_expect&lt;/code&gt; 를 사용할 수없는 경우에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="84aae041fbfd493303c7dc6f97608b2aa0f0cfea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;common&lt;/code&gt; attribute requests GCC to place a variable in &amp;ldquo;common&amp;rdquo; storage. The &lt;code&gt;nocommon&lt;/code&gt; attribute requests the opposite&amp;mdash;to allocate space for it directly.</source>
          <target state="translated">&lt;code&gt;common&lt;/code&gt; 속성은 &quot;일반적인&quot;스토리지 변수를 배치 GCC를 요청합니다. &lt;code&gt;nocommon&lt;/code&gt; 속성은 반대-에 직접위한 공간을 할당 요청합니다.</target>
        </trans-unit>
        <trans-unit id="09440712407e39d94a0cdcf960e85948cfc3c350" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;const&lt;/code&gt; attribute imposes greater restrictions on a function&amp;rsquo;s definition than the similar &lt;code&gt;pure&lt;/code&gt; attribute. Declaring the same function with both the &lt;code&gt;const&lt;/code&gt; and the &lt;code&gt;pure&lt;/code&gt; attribute is diagnosed. Because a const function cannot have any observable side effects it does not make sense for it to return &lt;code&gt;void&lt;/code&gt;. Declaring such a function is diagnosed.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 속성은 유사한보다 함수의 정의에 큰 제한을 부과하는 &lt;code&gt;pure&lt;/code&gt; 속성을. &lt;code&gt;const&lt;/code&gt; 와 &lt;code&gt;pure&lt;/code&gt; 속성 을 모두 사용하여 동일한 함수를 선언하면 진단됩니다. const 함수는 관찰 가능한 부작용을 가질 수 없으므로 &lt;code&gt;void&lt;/code&gt; 를 반환하는 것은 의미가 없습니다 . 이러한 기능을 선언하면 진단됩니다.</target>
        </trans-unit>
        <trans-unit id="db8d892c81dcdfdd626d5be4bd09dab512df4f9b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;const&lt;/code&gt; attribute prohibits a function from reading objects that affect its return value between successive invocations. However, functions declared with the attribute can safely read objects that do not change their return value, such as non-volatile constants.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 속성은 연속적인 호출 사이의 반환 값에 영향을주는 객체를 읽는 기능을 금지합니다. 그러나 속성으로 선언 된 함수는 비 휘발성 상수와 같이 반환 값을 변경하지 않는 객체를 안전하게 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99106b80230d2cf73a73b452a0a31c02c4de491f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;constructor&lt;/code&gt; attribute causes the function to be called automatically before execution enters &lt;code&gt;main ()&lt;/code&gt;. Similarly, the &lt;code&gt;destructor&lt;/code&gt; attribute causes the function to be called automatically after &lt;code&gt;main ()&lt;/code&gt; completes or &lt;code&gt;exit ()&lt;/code&gt; is called. Functions with these attributes are useful for initializing data that is used implicitly during the execution of the program.</source>
          <target state="translated">&lt;code&gt;constructor&lt;/code&gt; 실행 들어가기 전에 속성이 자동으로 호출하는 기능을 일으키는 &lt;code&gt;main ()&lt;/code&gt; . 마찬가지로 &lt;code&gt;destructor&lt;/code&gt; 속성을 사용하면 &lt;code&gt;main ()&lt;/code&gt; 이 완료되거나 &lt;code&gt;exit ()&lt;/code&gt; 가 호출 된 후 함수가 자동으로 호출됩니다 . 이러한 속성을 가진 함수는 프로그램 실행 중 내재적으로 사용되는 데이터를 초기화하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="7f891d087177f42fcc2b6b6abd03f036315d60bd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;copy&lt;/code&gt; attribute applies the set of attributes with which &lt;var&gt;function&lt;/var&gt; has been declared to the declaration of the function to which the attribute is applied. The attribute is designed for libraries that define aliases or function resolvers that are expected to specify the same set of attributes as their targets. The &lt;code&gt;copy&lt;/code&gt; attribute can be used with functions, variables, or types. However, the kind of symbol to which the attribute is applied (either function or variable) must match the kind of symbol to which the argument refers. The &lt;code&gt;copy&lt;/code&gt; attribute copies only syntactic and semantic attributes but not attributes that affect a symbol&amp;rsquo;s linkage or visibility such as &lt;code&gt;alias&lt;/code&gt;, &lt;code&gt;visibility&lt;/code&gt;, or &lt;code&gt;weak&lt;/code&gt;. The &lt;code&gt;deprecated&lt;/code&gt; and &lt;code&gt;target_clones&lt;/code&gt; attribute are also not copied. See &lt;a href=&quot;common-type-attributes#Common-Type-Attributes&quot;&gt;Common Type Attributes&lt;/a&gt;. See &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Common Variable Attributes&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;copy&lt;/code&gt; 특성이되는 속성 세트 적용 &lt;var&gt;function&lt;/var&gt; 속성이 적용되는 함수의 선언을 선언하고있다. 이 속성은 대상과 동일한 속성 세트를 지정할 것으로 예상되는 별칭 또는 함수 해석기를 정의하는 라이브러리 용으로 설계되었습니다. &lt;code&gt;copy&lt;/code&gt; 특성 함수, 변수 또는 종류를 사용할 수있다. 그러나 속성이 적용되는 기호의 종류 (함수 또는 변수)는 인수가 참조하는 기호의 종류와 일치해야합니다. &lt;code&gt;copy&lt;/code&gt; 속성은 구문 및 의미 속성 만 복사 하지만 &lt;code&gt;alias&lt;/code&gt; , &lt;code&gt;visibility&lt;/code&gt; 과 같은 기호의 연결 또는 가시성에 영향을주는 속성 은 복사 하지 않습니다., 또는 &lt;code&gt;weak&lt;/code&gt; . &lt;code&gt;deprecated&lt;/code&gt; 및 &lt;code&gt;target_clones&lt;/code&gt; 속성은 복사되지 않습니다. &lt;a href=&quot;common-type-attributes#Common-Type-Attributes&quot;&gt;공통 유형 속성을&lt;/a&gt; 참조하십시오 . &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;공통 변수 속성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1214564b5cbc84df3e7da6094de27b7006df5a48" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;copy&lt;/code&gt; attribute applies the set of attributes with which &lt;var&gt;function&lt;/var&gt; has been declared to the declaration of the function to which the attribute is applied. The attribute is designed for libraries that define aliases or function resolvers that are expected to specify the same set of attributes as their targets. The &lt;code&gt;copy&lt;/code&gt; attribute can be used with functions, variables, or types. However, the kind of symbol to which the attribute is applied (either function or variable) must match the kind of symbol to which the argument refers. The &lt;code&gt;copy&lt;/code&gt; attribute copies only syntactic and semantic attributes but not attributes that affect a symbol&amp;rsquo;s linkage or visibility such as &lt;code&gt;alias&lt;/code&gt;, &lt;code&gt;visibility&lt;/code&gt;, or &lt;code&gt;weak&lt;/code&gt;. The &lt;code&gt;deprecated&lt;/code&gt; attribute is also not copied. See &lt;a href=&quot;common-type-attributes#Common-Type-Attributes&quot;&gt;Common Type Attributes&lt;/a&gt;. See &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Common Variable Attributes&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;copy&lt;/code&gt; 특성이되는 속성 세트 적용 &lt;var&gt;function&lt;/var&gt; 속성이 적용되는 함수의 선언을 선언하고있다. 속성은 대상과 동일한 속성 세트를 지정해야하는 별명 또는 함수 분석기를 정의하는 라이브러리를 위해 설계되었습니다. &lt;code&gt;copy&lt;/code&gt; 특성 함수, 변수 또는 종류를 사용할 수있다. 그러나 속성이 적용되는 기호 종류 (함수 또는 변수)는 인수가 참조하는 기호 종류와 일치해야합니다. &lt;code&gt;copy&lt;/code&gt; 속성은 구문 및 의미 속성 만 복사 하지만 &lt;code&gt;alias&lt;/code&gt; , &lt;code&gt;visibility&lt;/code&gt; 등 심볼의 연결 또는 가시성에 영향을주는 속성 은 복사 하지 않습니다.또는 &lt;code&gt;weak&lt;/code&gt; . 더 &lt;code&gt;deprecated&lt;/code&gt; 속성도 복사되지 않습니다. &lt;a href=&quot;common-type-attributes#Common-Type-Attributes&quot;&gt;공통 유형 속성을&lt;/a&gt; 참조하십시오 . &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;공통 변수 속성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="592273a5e05d6744ed0bd5dc37c91bbe97b23cb1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;copy&lt;/code&gt; attribute applies the set of attributes with which &lt;var&gt;variable&lt;/var&gt; has been declared to the declaration of the variable to which the attribute is applied. The attribute is designed for libraries that define aliases that are expected to specify the same set of attributes as the aliased symbols. The &lt;code&gt;copy&lt;/code&gt; attribute can be used with variables, functions or types. However, the kind of symbol to which the attribute is applied (either varible or function) must match the kind of symbol to which the argument refers. The &lt;code&gt;copy&lt;/code&gt; attribute copies only syntactic and semantic attributes but not attributes that affect a symbol&amp;rsquo;s linkage or visibility such as &lt;code&gt;alias&lt;/code&gt;, &lt;code&gt;visibility&lt;/code&gt;, or &lt;code&gt;weak&lt;/code&gt;. The &lt;code&gt;deprecated&lt;/code&gt; attribute is also not copied. See &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;. See &lt;a href=&quot;common-type-attributes#Common-Type-Attributes&quot;&gt;Common Type Attributes&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;copy&lt;/code&gt; 특성이되는 속성 세트 적용 &lt;var&gt;variable&lt;/var&gt; 속성이 적용되는 변수의 선언을 선언하고있다. 이 속성은 별명 기호와 동일한 속성 세트를 지정해야하는 별명을 정의하는 라이브러리를 위해 설계되었습니다. &lt;code&gt;copy&lt;/code&gt; 특성 변수, 함수 타입 또는 함께 사용될 수있다. 그러나 속성이 적용되는 심볼 종류 (변수 또는 함수)는 인수가 참조하는 심볼 종류와 일치해야합니다. &lt;code&gt;copy&lt;/code&gt; 속성은 구문 및 의미 속성 만 복사 하지만 &lt;code&gt;alias&lt;/code&gt; , &lt;code&gt;visibility&lt;/code&gt; 또는 &lt;code&gt;weak&lt;/code&gt; 과 같은 심볼의 링크 또는 가시성에 영향을주는 속성 은 복사 하지 않습니다.. 더 &lt;code&gt;deprecated&lt;/code&gt; 속성도 복사되지 않습니다. &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;공통 기능 속성을&lt;/a&gt; 참조하십시오 . &lt;a href=&quot;common-type-attributes#Common-Type-Attributes&quot;&gt;공통 유형 속성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a505e2a0a73ab045449836d4a18bec5c0bc8127e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;copy&lt;/code&gt; attribute applies the set of attributes with which the type of the &lt;var&gt;expression&lt;/var&gt; has been declared to the declaration of the type to which the attribute is applied. The attribute is designed for libraries that define aliases that are expected to specify the same set of attributes as the aliased symbols. The &lt;code&gt;copy&lt;/code&gt; attribute can be used with types, variables, or functions. However, the kind of symbol to which the attribute is applied (either varible or function) must match the kind of symbol to which the argument refers. The &lt;code&gt;copy&lt;/code&gt; attribute copies only syntactic and semantic attributes but not attributes that affect a symbol&amp;rsquo;s linkage or visibility such as &lt;code&gt;alias&lt;/code&gt;, &lt;code&gt;visibility&lt;/code&gt;, or &lt;code&gt;weak&lt;/code&gt;. The &lt;code&gt;deprecated&lt;/code&gt; attribute is also not copied. See &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;. See &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Common Variable Attributes&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;copy&lt;/code&gt; 특성은 유형되는 속성 세트 적용 &lt;var&gt;expression&lt;/var&gt; 특성이 적용되는 타입의 선언을 선언하고있다. 이 속성은 별명 기호와 동일한 속성 세트를 지정해야하는 별명을 정의하는 라이브러리를 위해 설계되었습니다. &lt;code&gt;copy&lt;/code&gt; 속성 타입, 변수 또는 기능을 사용할 수있다. 그러나 속성이 적용되는 심볼 종류 (변수 또는 함수)는 인수가 참조하는 심볼 종류와 일치해야합니다. &lt;code&gt;copy&lt;/code&gt; 와 같은 기호의 연결 또는 가시성에 영향을 미치는 속성 만 복사 구문과 의미 론적 속성이 아닌 속성 &lt;code&gt;alias&lt;/code&gt; , &lt;code&gt;visibility&lt;/code&gt; , 또는 &lt;code&gt;weak&lt;/code&gt; . 더 &lt;code&gt;deprecated&lt;/code&gt; 속성도 복사되지 않습니다. &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;공통 기능 속성을&lt;/a&gt; 참조하십시오 . &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;공통 변수 속성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f8a4a7841fe7fe34c4f48a65b187a7fb8df9b582" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;d&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;d&lt;/code&gt; 등록한다.</target>
        </trans-unit>
        <trans-unit id="024895282c898bc3d4211d4724e2af4880224cde" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute can also be used for functions and types (see &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;, see &lt;a href=&quot;common-type-attributes#Common-Type-Attributes&quot;&gt;Common Type Attributes&lt;/a&gt;).</source>
          <target state="translated">더 &lt;code&gt;deprecated&lt;/code&gt; 속성은 함수 및 유형에도 사용할 수 있습니다 ( &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;공통 함수 속성&lt;/a&gt; 참조, &lt;a href=&quot;common-type-attributes#Common-Type-Attributes&quot;&gt;공통 유형 속성&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="162fc2b6ed9e6c2908900a7eb89f4726020462d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute can also be used for functions and variables (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;, see &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;.)</source>
          <target state="translated">더 &lt;code&gt;deprecated&lt;/code&gt; 속성은 함수 및 변수에도 사용할 수 있습니다 ( &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;함수 속성&lt;/a&gt; 참조, &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;변수 속성&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="b2cfdb164eda8f42cf6433c514a0ea224366c785" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute can also be used for variables and types (see &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;, see &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Type Attributes&lt;/a&gt;.)</source>
          <target state="translated">더 &lt;code&gt;deprecated&lt;/code&gt; 속성은 변수 및 유형에도 사용할 수 있습니다 ( &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;변수 속성&lt;/a&gt; 참조, &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;유형 속성&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="cad1e87fce264d36291150600cb66c57e91c1432" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute results in a warning if the enumerator is used anywhere in the source file. This is useful when identifying enumerators that are expected to be removed in a future version of a program. The warning also includes the location of the declaration of the deprecated enumerator, to enable users to easily find further information about why the enumerator is deprecated, or what they should do instead. Note that the warnings only occurs for uses.</source>
          <target state="translated">&lt;code&gt;deprecated&lt;/code&gt; 경고의 속성 결과는 열거는 소스 파일에서 임의의 장소에서 사용하는 경우. 향후 버전의 프로그램에서 제거 될 것으로 예상되는 열거자를 식별 할 때 유용합니다. 경고에는 더 이상 사용되지 않는 열거 자의 선언 위치가 포함되어있어 사용자가 열거자가 더 이상 사용되지 않는 이유 또는 대신 수행해야하는 작업에 대한 추가 정보를 쉽게 찾을 수 있습니다. 경고는 용도로만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="20e0cb154d9e21da1f2de2ead88f358575c22b29" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute results in a warning if the function is used anywhere in the source file. This is useful when identifying functions that are expected to be removed in a future version of a program. The warning also includes the location of the declaration of the deprecated function, to enable users to easily find further information about why the function is deprecated, or what they should do instead. Note that the warnings only occurs for uses:</source>
          <target state="translated">더 &lt;code&gt;deprecated&lt;/code&gt; 속성은 함수가 소스 파일의 어느 곳에서나 사용되는 경우 경고를 발생시킵니다. 이것은 향후 버전의 프로그램에서 제거 될 것으로 예상되는 기능을 식별 할 때 유용합니다. 경고에는 더 이상 사용되지 않는 함수 선언 위치가 포함되어있어 사용자가 함수가 더 이상 사용되지 않는 이유 또는 대신 수행해야하는 작업에 대한 추가 정보를 쉽게 찾을 수 있습니다. 경고는 다음 용도로만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7280557c8bb44f2fb4dbaff815426552ad4804e8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute results in a warning if the type is used anywhere in the source file. This is useful when identifying types that are expected to be removed in a future version of a program. If possible, the warning also includes the location of the declaration of the deprecated type, to enable users to easily find further information about why the type is deprecated, or what they should do instead. Note that the warnings only occur for uses and then only if the type is being applied to an identifier that itself is not being declared as deprecated.</source>
          <target state="translated">더 &lt;code&gt;deprecated&lt;/code&gt; 속성은 유형이 소스 파일의 어느 곳에서나 사용되는 경우 경고를 발생시킵니다. 향후 버전의 프로그램에서 제거 될 것으로 예상되는 유형을 식별 할 때 유용합니다. 가능한 경우 경고에는 더 이상 사용되지 않는 유형의 선언 위치가 포함되어있어 사용자가 유형이 더 이상 사용되지 않는 이유 또는 대신 수행해야하는 작업에 대한 추가 정보를 쉽게 찾을 수 있습니다. 경고는 사용시에만 발생하며 유형 자체가 사용되지 않는 것으로 선언되지 않은 식별자에 유형이 적용되는 경우에만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="597712de9335903c130e7df57d7a0ba95b08639b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deprecated&lt;/code&gt; attribute results in a warning if the variable is used anywhere in the source file. This is useful when identifying variables that are expected to be removed in a future version of a program. The warning also includes the location of the declaration of the deprecated variable, to enable users to easily find further information about why the variable is deprecated, or what they should do instead. Note that the warning only occurs for uses:</source>
          <target state="translated">더 &lt;code&gt;deprecated&lt;/code&gt; 속성은 변수가 소스 파일의 어느 곳에서나 사용되는 경우 경고를 발생시킵니다. 이것은 향후 버전의 프로그램에서 제거 될 것으로 예상되는 변수를 식별 할 때 유용합니다. 경고에는 더 이상 사용되지 않는 변수의 선언 위치가 포함되어있어 사용자가 변수가 더 이상 사용되지 않는 이유 또는 대신 수행해야하는 작업에 대한 추가 정보를 쉽게 찾을 수 있습니다. 경고는 다음 용도로만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="344b31eee254fd7731082259002ff33f9b48b98f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;di&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;di&lt;/code&gt; 레지스터.</target>
        </trans-unit>
        <trans-unit id="1650914162ce3f6c59a952f96564a05c9635bff9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dllimport&lt;/code&gt; and &lt;code&gt;dllexport&lt;/code&gt; attributes are described in &lt;a href=&quot;microsoft-windows-function-attributes#Microsoft-Windows-Function-Attributes&quot;&gt;Microsoft Windows Function Attributes&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;dllimport&lt;/code&gt; 와 &lt;code&gt;dllexport&lt;/code&gt; 속성에 설명되어 &lt;a href=&quot;microsoft-windows-function-attributes#Microsoft-Windows-Function-Attributes&quot;&gt;마이크로 소프트 윈도우 기능 속성&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="602269999e7f262d03410dcdc10e151a9ba7ec4f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;either&lt;/code&gt; attribute is special. It tells the linker to place the object into the corresponding &lt;code&gt;lower&lt;/code&gt; section if there is room for it. If there is insufficient room then the object is placed into the corresponding &lt;code&gt;upper&lt;/code&gt; section instead. Note that the placement algorithm is not very sophisticated. It does not attempt to find an optimal packing of the &lt;code&gt;lower&lt;/code&gt; sections. It just makes one pass over the objects and does the best that it can. Using the</source>
          <target state="translated">&lt;code&gt;either&lt;/code&gt; 속성은 특별하다. 링커는 객체를 위한 공간이있는 경우 해당 &lt;code&gt;lower&lt;/code&gt; 섹션에 객체를 배치하도록 지시합니다 . 공간이 충분하지 않으면 객체가 대신 해당 &lt;code&gt;upper&lt;/code&gt; 섹션에 배치 됩니다. 배치 알고리즘은 매우 정교하지 않습니다. &lt;code&gt;lower&lt;/code&gt; 섹션 의 최적 패킹을 찾으려고하지는 않습니다 . 그것은 단지 하나의 객체를 통과시키고 가능한 최선을 다합니다. 사용하여</target>
        </trans-unit>
        <trans-unit id="127ffb86a9524294853f3ef1fc5800cb8a1c3768" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fallthrough&lt;/code&gt; attribute with a null statement serves as a fallthrough statement. It hints to the compiler that a statement that falls through to another case label, or user-defined label in a switch statement is intentional and thus the</source>
          <target state="translated">null 문 이있는 &lt;code&gt;fallthrough&lt;/code&gt; 속성은 fallthrough 문으로 사용됩니다. 컴파일러에게 다른 케이스 레이블 또는 switch 문의 사용자 정의 레이블로 넘어가는 명령문은 의도적이므로</target>
        </trans-unit>
        <trans-unit id="6830b1617bcd576d4ef6cff9b6f00ee4b5966d52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fixincludes&lt;/code&gt; script interacts badly with automounters; if the directory of system header files is automounted, it tends to be unmounted while &lt;code&gt;fixincludes&lt;/code&gt; is running. This would seem to be a bug in the automounter. We don&amp;rsquo;t know any good way to work around it.</source>
          <target state="translated">&lt;code&gt;fixincludes&lt;/code&gt; 잘못의 automounter와 스크립트 상호 작용; 시스템 헤더 파일의 디렉토리가 자동 마운트 된 경우 &lt;code&gt;fixincludes&lt;/code&gt; 가 실행되는 동안 마운트 해제되는 경향이 있습니다 . 이것은 자동 마운터의 버그 인 것 같습니다. 우리는 그것을 해결하는 좋은 방법을 모른다.</target>
        </trans-unit>
        <trans-unit id="c63425a2cbc7b99cbe7ca99c3dbf9d57e95519bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;format&lt;/code&gt; attribute allows you to identify your own functions that take format strings as arguments, so that GCC can check the calls to these functions for errors. The compiler always (unless</source>
          <target state="translated">&lt;code&gt;format&lt;/code&gt; 속성을 사용하면 GCC는 오류에 대해이 함수에 대한 호출을 확인하실 수 있습니다 그래서, 인수로 형식 문자열을 자신의 기능을 식별 할 수 있습니다. 컴파일러는 항상</target>
        </trans-unit>
        <trans-unit id="8186a0d48987dddde9af17dcccbd13ea17379b53" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;format&lt;/code&gt; attribute specifies that a function takes &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;scanf&lt;/code&gt;, &lt;code&gt;strftime&lt;/code&gt; or &lt;code&gt;strfmon&lt;/code&gt; style arguments that should be type-checked against a format string. For example, the declaration:</source>
          <target state="translated">&lt;code&gt;format&lt;/code&gt; 함수가 소요되는 속성 지정 &lt;code&gt;printf&lt;/code&gt; , &lt;code&gt;scanf&lt;/code&gt; 와 , &lt;code&gt;strftime&lt;/code&gt; 또는 &lt;code&gt;strfmon&lt;/code&gt; 해야 스타일의 인수 형식 문자열에 대해 유형-확인. 예를 들어, 선언 :</target>
        </trans-unit>
        <trans-unit id="85cee214b83f923e35c9402c26181e376eaa3ea2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;format_arg&lt;/code&gt; attribute allows you to identify your own functions that modify format strings, so that GCC can check the calls to &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;scanf&lt;/code&gt;, &lt;code&gt;strftime&lt;/code&gt; or &lt;code&gt;strfmon&lt;/code&gt; type function whose operands are a call to one of your own function. The compiler always treats &lt;code&gt;gettext&lt;/code&gt;, &lt;code&gt;dgettext&lt;/code&gt;, and &lt;code&gt;dcgettext&lt;/code&gt; in this manner except when strict ISO C support is requested by</source>
          <target state="translated">&lt;code&gt;format_arg&lt;/code&gt; 의 속성은 수정 형식 문자열이 때문에 GCC가에 대한 호출 확인 할 수 있는지 자신의 기능을 식별 할 수 &lt;code&gt;printf&lt;/code&gt; , &lt;code&gt;scanf&lt;/code&gt; 와 , &lt;code&gt;strftime&lt;/code&gt; 또는 &lt;code&gt;strfmon&lt;/code&gt; 그 피연산자 자신의 기능 중 하나를 호출있는 유형의 기능을. 컴파일러는 엄격한 ISO C 지원을 요청한 경우를 제외하고 는 항상 &lt;code&gt;gettext&lt;/code&gt; , &lt;code&gt;dgettext&lt;/code&gt; 및 &lt;code&gt;dcgettext&lt;/code&gt; 를 이러한 방식으로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="3daa7d7140f7871d6b8af467ff44e71c895472e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;format_arg&lt;/code&gt; attribute specifies that a function takes one or more format strings for a &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;scanf&lt;/code&gt;, &lt;code&gt;strftime&lt;/code&gt; or &lt;code&gt;strfmon&lt;/code&gt; style function and modifies it (for example, to translate it into another language), so the result can be passed to a &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;scanf&lt;/code&gt;, &lt;code&gt;strftime&lt;/code&gt; or &lt;code&gt;strfmon&lt;/code&gt; style function (with the remaining arguments to the format function the same as they would have been for the unmodified string). Multiple &lt;code&gt;format_arg&lt;/code&gt; attributes may be applied to the same function, each designating a distinct parameter as a format string. For example, the declaration:</source>
          <target state="translated">&lt;code&gt;format_arg&lt;/code&gt; 함수에 대한 하나 이상의 형식 문자열 걸리는 속성 지정 &lt;code&gt;printf&lt;/code&gt; , &lt;code&gt;scanf&lt;/code&gt; 와 , &lt;code&gt;strftime&lt;/code&gt; 또는 &lt;code&gt;strfmon&lt;/code&gt; 결과가 전달 될 수 있도록, 스타일 기능과 수정을 (예를 들어, 다른 언어로 번역) &lt;code&gt;printf&lt;/code&gt; , &lt;code&gt;scanf&lt;/code&gt; 와 , &lt;code&gt;strftime&lt;/code&gt; 또는 &lt;code&gt;strfmon&lt;/code&gt; 스타일 함수 (수정되지 않은 문자열과 동일한 형식 함수의 나머지 인수 포함). 여러 개의 &lt;code&gt;format_arg&lt;/code&gt; 속성이 동일한 함수에 적용될 수 있으며 각각 고유 한 매개 변수를 형식 문자열로 지정합니다. 예를 들어, 선언 :</target>
        </trans-unit>
        <trans-unit id="cca4e3fc744cfd6bb4409a911b1eaa70a4a7b0f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gcc&lt;/code&gt; program accepts options and file names as operands. Many options have multi-letter names; therefore multiple single-letter options may &lt;em&gt;not&lt;/em&gt; be grouped:</source>
          <target state="translated">&lt;code&gt;gcc&lt;/code&gt; 프로그램은 피연산자로 옵션과 파일 이름을 받아들입니다. 많은 옵션에는 여러 글자로 된 이름이 있습니다. 따라서 여러 개의 단일 문자 옵션이 그룹화 &lt;em&gt;되지 않을&lt;/em&gt; 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13501a1cf6115328de048bf9d04f10c4c82f956e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getenv&lt;/code&gt; spec function takes two arguments: an environment variable name and a string. If the environment variable is not defined, a fatal error is issued. Otherwise, the return value is the value of the environment variable concatenated with the string. For example, if &lt;code&gt;TOPDIR&lt;/code&gt; is defined as</source>
          <target state="translated">&lt;code&gt;getenv&lt;/code&gt; 환경 변수 이름과 문자열 : 사양 함수는 두 개의 인수를 취합니다. 환경 변수가 정의되지 않으면 치명적인 오류가 발생합니다. 그렇지 않으면, 리턴 값은 문자열과 연결된 환경 변수의 값입니다. 예를 들어 &lt;code&gt;TOPDIR&lt;/code&gt; 이 다음과 같이 정의 된 경우</target>
        </trans-unit>
        <trans-unit id="7e47220a0b9fe1eafb603003bb97378e81c55693" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hot&lt;/code&gt; attribute on a function is used to inform the compiler that the function is a hot spot of the compiled program. The function is optimized more aggressively and on many targets it is placed into a special subsection of the text section so all hot functions appear close together, improving locality.</source>
          <target state="translated">함수 의 &lt;code&gt;hot&lt;/code&gt; 속성은 함수가 컴파일 된 프로그램의 핫스팟임을 컴파일러에 알리는 데 사용됩니다. 이 기능은보다 적극적으로 최적화되며 많은 대상에서 텍스트 섹션의 특수 하위 섹션에 배치되므로 모든 핫 기능이 서로 가깝게 표시되어 지역성이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="bdc71e7bb730a8ac55c634493d73dbda68f4ce5e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hot&lt;/code&gt; attribute on a label is used to inform the compiler that the path following the label is more likely than paths that are not so annotated. This attribute is used in cases where &lt;code&gt;__builtin_expect&lt;/code&gt; cannot be used, for instance with computed goto or &lt;code&gt;asm goto&lt;/code&gt;.</source>
          <target state="translated">레이블 의 &lt;code&gt;hot&lt;/code&gt; 속성은 레이블 다음에 오는 경로가 주석이없는 경로보다 컴파일러에 알리는 데 사용됩니다. 이 속성은 계산 된 goto 또는 &lt;code&gt;asm goto&lt;/code&gt; 와 같이 &lt;code&gt;__builtin_expect&lt;/code&gt; 를 사용할 수없는 경우에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="f61dd8421805c3f1f1761646164b13228bc83b34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if-exists-else&lt;/code&gt; spec function is similar to the &lt;code&gt;if-exists&lt;/code&gt; spec function, except that it takes two arguments. The first argument is an absolute pathname to a file. If the file exists, &lt;code&gt;if-exists-else&lt;/code&gt; returns the pathname. If it does not exist, it returns the second argument. This way, &lt;code&gt;if-exists-else&lt;/code&gt; can be used to select one file or another, based on the existence of the first. Here is a small example of its usage:</source>
          <target state="translated">&lt;code&gt;if-exists-else&lt;/code&gt; 사양 기능은 비슷합니다 &lt;code&gt;if-exists&lt;/code&gt; 사양 기능을,이 2 개 개의 인수를 취하는 것을 제외하고. 첫 번째 인수는 파일의 절대 경로 이름입니다. 파일이 존재하면 &lt;code&gt;if-exists-else&lt;/code&gt; 는 경로 이름을 반환합니다. 존재하지 않으면 두 번째 인수를 반환합니다. 이 방법으로 &lt;code&gt;if-exists-else&lt;/code&gt; 를 사용하여 첫 번째 파일의 존재 여부에 따라 하나의 파일 또는 다른 파일을 선택할 수 있습니다. 다음은 사용법의 작은 예입니다.</target>
        </trans-unit>
        <trans-unit id="ca2fcf31ed2dc4dabd85a0634ae9ce4991a720f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if-exists&lt;/code&gt; spec function takes one argument, an absolute pathname to a file. If the file exists, &lt;code&gt;if-exists&lt;/code&gt; returns the pathname. Here is a small example of its usage:</source>
          <target state="translated">&lt;code&gt;if-exists&lt;/code&gt; 사양 함수는 하나의 인자는 파일에 대한 절대 경로 걸린다. 파일이 존재 &lt;code&gt;if-exists&lt;/code&gt; 하는 경우 경로 이름을 리턴합니다. 다음은 사용법의 작은 예입니다.</target>
        </trans-unit>
        <trans-unit id="2f39b443650f9aa0609294fd86fb2e3c92efa3ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ifunc&lt;/code&gt; attribute is used to mark a function as an indirect function using the STT_GNU_IFUNC symbol type extension to the ELF standard. This allows the resolution of the symbol value to be determined dynamically at load time, and an optimized version of the routine to be selected for the particular processor or other system characteristics determined then. To use this attribute, first define the implementation functions available, and a resolver function that returns a pointer to the selected implementation function. The implementation functions&amp;rsquo; declarations must match the API of the function being implemented. The resolver should be declared to be a function taking no arguments and returning a pointer to a function of the same type as the implementation. For example:</source>
          <target state="translated">&lt;code&gt;ifunc&lt;/code&gt; 의 속성은 ELF 표준에 STT_GNU_IFUNC 심볼 유형 확장을 이용한 간접적 인 함수로 함수를 표시하기 위해 사용된다. 이것은 심볼 시간의 해상도가로드 타임에 동적으로 결정될 수있게하고, 특정 프로세서 또는 그 후 결정된 다른 시스템 특성에 대해 루틴의 최적화 된 버전이 선택되도록한다. 이 속성을 사용하려면 먼저 사용 가능한 구현 함수와 선택한 구현 함수에 대한 포인터를 리턴하는 리졸버 함수를 정의하십시오. 구현 함수의 선언은 구현중인 함수의 API와 일치해야합니다. 리졸버는 인수를 취하지 않고 구현과 동일한 유형의 함수에 대한 포인터를 리턴하는 함수로 선언되어야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c93b19f3af6a498a18dbae7f15fda07496789c8c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;indirect_return&lt;/code&gt; attribute can be applied to a function, as well as variable or type of function pointer to inform the compiler that the function may return via indirect branch.</source>
          <target state="translated">&lt;code&gt;indirect_return&lt;/code&gt; 의 특성 함수는 간접 분기로 반환 할 수있는 컴파일러에 통보하는 기능뿐만 아니라, 변수 또는 함수 포인터의 형태로 적용될 수있다.</target>
        </trans-unit>
        <trans-unit id="f9d323a0cf85010c427cc0692ec1f74e288bfb70" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;int&lt;/code&gt; type specifies the &lt;em&gt;base type&lt;/em&gt;, while the attribute specifies the vector size for the variable, measured in bytes. For example, the declaration above causes the compiler to set the mode for the &lt;code&gt;v4si&lt;/code&gt; type to be 16 bytes wide and divided into &lt;code&gt;int&lt;/code&gt; sized units. For a 32-bit &lt;code&gt;int&lt;/code&gt; this means a vector of 4 units of 4 bytes, and the corresponding mode of &lt;code&gt;foo&lt;/code&gt; is V4SI.</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; 유형을 지정 &lt;em&gt;기본 유형&lt;/em&gt; 속성이 바이트 단위로 측정 변수의 벡터 크기를 지정하면서. 예를 들어, 위 선언은 컴파일러가 &lt;code&gt;v4si&lt;/code&gt; 유형 의 모드를 16 바이트 너비로 설정하고 &lt;code&gt;int&lt;/code&gt; 크기 단위 로 나누도록 합니다. 32 비트 &lt;code&gt;int&lt;/code&gt; 의 경우 이는 4 바이트의 4 단위 벡터를 의미하며 해당 &lt;code&gt;foo&lt;/code&gt; 모드 는 V4SI입니다.</target>
        </trans-unit>
        <trans-unit id="2ad85eea7d52841e376253f17a96317ee40b42d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lo&lt;/code&gt; register. Use this register to store values that are no bigger than a word.</source>
          <target state="translated">&lt;code&gt;lo&lt;/code&gt; 레지스터. 단어보다 크지 않은 값을 저장하려면이 레지스터를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d59f696ee7163d6ae5bf39bf73c4a8eee9fb142c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;longcall&lt;/code&gt; attribute indicates that the function might be far away from the call site and require a different (more expensive) calling sequence. The &lt;code&gt;shortcall&lt;/code&gt; attribute indicates that the function is always close enough for the shorter calling sequence to be used. These attributes override both the</source>
          <target state="translated">&lt;code&gt;longcall&lt;/code&gt; 의 특성은 함수가 멀리 호출 사이트에서하고 다른 (더 비싼)를 호출 순서가 필요할 수 있음을 나타냅니다. &lt;code&gt;shortcall&lt;/code&gt; 의 속성은 짧은 호출 시퀀스가 사용하는 기능이 항상 충분히 가까이 있음을 나타냅니다. 이러한 속성은</target>
        </trans-unit>
        <trans-unit id="fcca42c392befdcaa88d2e6501ea9388ada93b12" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;longcall&lt;/code&gt; attribute indicates that the function might be far away from the call site and require a different (more expensive) calling sequence. The &lt;code&gt;shortcall&lt;/code&gt; attribute indicates that the function is always close enough for the shorter calling sequence to be used. These attributes override the</source>
          <target state="translated">&lt;code&gt;longcall&lt;/code&gt; 의 특성은 함수가 멀리 호출 사이트에서하고 다른 (더 비싼)를 호출 순서가 필요할 수 있음을 나타냅니다. &lt;code&gt;shortcall&lt;/code&gt; 의 속성은 짧은 호출 시퀀스가 사용하는 기능이 항상 충분히 가까이 있음을 나타냅니다. 이러한 속성은</target>
        </trans-unit>
        <trans-unit id="dc876d3a5eef5293c3403c1a8361253a45afc935" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;movf&lt;/code&gt; functions are similar but use &lt;code&gt;movf.ps&lt;/code&gt; instead of &lt;code&gt;movt.ps&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;movf&lt;/code&gt; 기능은 유사하지만 사용 &lt;code&gt;movf.ps&lt;/code&gt; 대신 &lt;code&gt;movt.ps&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7edfc9a06b3d4812f5bd4584647b1d884b0e5206" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;movt&lt;/code&gt; functions return the value &lt;var&gt;x&lt;/var&gt; computed by:</source>
          <target state="translated">&lt;code&gt;movt&lt;/code&gt; 함수 값 답례 &lt;var&gt;x&lt;/var&gt; 에 의해 산출 :</target>
        </trans-unit>
        <trans-unit id="2610b35bdca1d94154ca3ae8683caf9dc99891a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mutationsPtr&lt;/code&gt; field of the &lt;code&gt;NSFastEnumerationState&lt;/code&gt; is used to keep track of mutations. It should point to a number; before working on each object, the fast enumeration loop will check that this number has not changed. If it has, a mutation has happened and the fast enumeration will abort. So, &lt;code&gt;mutationsPtr&lt;/code&gt; could be set to point to some sort of version number of your collection, which is increased by one every time there is a change (for example when an object is added or removed). Or, if you are content with less strict mutation checks, it could point to the number of objects in your collection or some other value that can be checked to perform an approximate check that the collection has not been mutated.</source>
          <target state="translated">&lt;code&gt;NSFastEnumerationState&lt;/code&gt; 의 &lt;code&gt;mutationsPtr&lt;/code&gt; 필드는 돌연변이 를 추적하는 데 사용됩니다. 숫자를 가리켜 야합니다. 각 객체에 대해 작업하기 전에 빠른 열거 루프는이 숫자가 변경되지 않았는지 확인합니다. 그렇다면 돌연변이가 발생하여 빠른 열거가 중단됩니다. 따라서 &lt;code&gt;mutationsPtr&lt;/code&gt; 은 컬렉션의 일종의 버전 번호를 가리 키도록 설정 될 수 있으며, 변경 될 때마다 (예 : 객체가 추가되거나 제거 될 때마다) 증가합니다. 또는 돌연변이 검사가 덜 엄격한 콘텐츠 인 경우 컬렉션의 개체 수 또는 컬렉션이 변경되지 않았는지 대략적인 검사를 수행하기 위해 확인할 수있는 다른 값을 가리킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eba0a2fef84c6754af39561a4cc5765385e357d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_profile_instrument_function&lt;/code&gt; attribute on functions is used to inform the compiler that it should not process any profile feedback based optimization code instrumentation.</source>
          <target state="translated">함수 의 &lt;code&gt;no_profile_instrument_function&lt;/code&gt; 속성은 컴파일러에게 프로파일 피드백 기반 최적화 코드 계측을 처리해서는 안된다는 것을 알리는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0918428dc764c04c359b85f748a679bc412726a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_sanitize&lt;/code&gt; attribute on functions is used to inform the compiler that it should not do sanitization of all options mentioned in &lt;var&gt;sanitize_option&lt;/var&gt;. A list of values acceptable by</source>
          <target state="translated">함수 의 &lt;code&gt;no_sanitize&lt;/code&gt; 속성은 컴파일러에게 &lt;var&gt;sanitize_option&lt;/var&gt; 에 언급 된 모든 옵션을 살균하지 않아야 함을 알리는 데 사용됩니다 . 허용 가능한 값 목록</target>
        </trans-unit>
        <trans-unit id="9e7127aec5521f1afa980b41ce3dbea36752798e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_sanitize&lt;/code&gt; attribute on functions is used to inform the compiler that it should not do sanitization of any option mentioned in &lt;var&gt;sanitize_option&lt;/var&gt;. A list of values acceptable by the</source>
          <target state="translated">함수 의 &lt;code&gt;no_sanitize&lt;/code&gt; 속성은 &lt;var&gt;sanitize_option&lt;/var&gt; 에 언급 된 옵션을 삭제 하지 않아야 함을 컴파일러에 알리는 데 사용됩니다 . 허용되는 값 목록</target>
        </trans-unit>
        <trans-unit id="598d3a3720c7288dc59d302cd06d4d62ac827b23" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_sanitize_address&lt;/code&gt; attribute on functions is used to inform the compiler that it should not instrument memory accesses in the function when compiling with the</source>
          <target state="translated">함수 의 &lt;code&gt;no_sanitize_address&lt;/code&gt; 속성은 컴파일러로 컴파일 할 때 함수에서 메모리 액세스를 계측해서는 안됨을 컴파일러에 알리는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b0f00909d80fd99a1bd86005010002c8eae19649" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_sanitize_thread&lt;/code&gt; attribute on functions is used to inform the compiler that it should not instrument memory accesses in the function when compiling with the</source>
          <target state="translated">함수 의 &lt;code&gt;no_sanitize_thread&lt;/code&gt; 속성은 컴파일러로 컴파일 할 때 함수에서 메모리 액세스를 계측해서는 안됨을 컴파일러에 알리는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7a12b0e3b686d055271b195be15ed20337782164" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_sanitize_undefined&lt;/code&gt; attribute on functions is used to inform the compiler that it should not check for undefined behavior in the function when compiling with the</source>
          <target state="translated">함수 의 &lt;code&gt;no_sanitize_undefined&lt;/code&gt; 속성은 컴파일러가</target>
        </trans-unit>
        <trans-unit id="fc8d4f077478dc90f16e53c6d13ee06401059297" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nocf_check&lt;/code&gt; attribute is applied to an object&amp;rsquo;s type. In case of assignment of a function address or a function pointer to another pointer, the attribute is not carried over from the right-hand object&amp;rsquo;s type; the type of left-hand object stays unchanged. The compiler checks for &lt;code&gt;nocf_check&lt;/code&gt; attribute mismatch and reports a warning in case of mismatch.</source>
          <target state="translated">&lt;code&gt;nocf_check&lt;/code&gt; 의 속성은 객체의 유형에 적용됩니다. 함수 주소 또는 함수 포인터를 다른 포인터에 할당하는 경우 속성은 오른쪽 객체 유형에서 전달되지 않습니다. 왼쪽 개체의 유형은 변경되지 않습니다. 컴파일러는 &lt;code&gt;nocf_check&lt;/code&gt; 속성 불일치를 확인하고 불일치 할 경우 경고를보고합니다.</target>
        </trans-unit>
        <trans-unit id="037064bc2bccfb10212ace859111994bc55ff79f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nocf_check&lt;/code&gt; attribute on a function is used to inform the compiler that the function&amp;rsquo;s prologue should not be instrumented when compiled with the</source>
          <target state="translated">함수 의 &lt;code&gt;nocf_check&lt;/code&gt; 속성은 컴파일러에게 함수의 프롤로그를 계측 할 때 계측해서는 안됨을 알리는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="59968503e9385085cb3eaa290a16cdafff616101" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nocf_check&lt;/code&gt; attribute on a type of pointer to function is used to inform the compiler that a call through the pointer should not be instrumented when compiled with the</source>
          <target state="translated">&lt;code&gt;nocf_check&lt;/code&gt; 의 포인터를 통해 통화가 계측되지 않아야한다는 컴파일시 함수 포인터 유형의 속성이 컴파일러에 알리는 데 사용된다</target>
        </trans-unit>
        <trans-unit id="814b4e15c6c880738e37bebfa650ba3630bcdb26" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nonnull&lt;/code&gt; attribute may be applied to a function that takes at least one argument of a pointer type. It indicates that the referenced arguments must be non-null pointers. For instance, the declaration:</source>
          <target state="translated">&lt;code&gt;nonnull&lt;/code&gt; 이 아닌 속성은 포인터 유형의 적어도 하나의 인수를 취하는 함수에 적용될 수 있습니다. 참조 된 인수는 널이 아닌 포인터 여야 함을 나타냅니다. 예를 들어, 선언 :</target>
        </trans-unit>
        <trans-unit id="390c2fb36f2ab88e24c7fbba27c3b067ccacf7b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nonstring&lt;/code&gt; variable attribute specifies that an object or member declaration with type array of &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;signed char&lt;/code&gt;, or &lt;code&gt;unsigned char&lt;/code&gt;, or pointer to such a type is intended to store character arrays that do not necessarily contain a terminating &lt;code&gt;NUL&lt;/code&gt;. This is useful in detecting uses of such arrays or pointers with functions that expect &lt;code&gt;NUL&lt;/code&gt;-terminated strings, and to avoid warnings when such an array or pointer is used as an argument to a bounded string manipulation function such as &lt;code&gt;strncpy&lt;/code&gt;. For example, without the attribute, GCC will issue a warning for the &lt;code&gt;strncpy&lt;/code&gt; call below because it may truncate the copy without appending the terminating &lt;code&gt;NUL&lt;/code&gt; character. Using the attribute makes it possible to suppress the warning. However, when the array is declared with the attribute the call to &lt;code&gt;strlen&lt;/code&gt; is diagnosed because when the array doesn&amp;rsquo;t contain a &lt;code&gt;NUL&lt;/code&gt;-terminated string the call is undefined. To copy, compare, of search non-string character arrays use the &lt;code&gt;memcpy&lt;/code&gt;, &lt;code&gt;memcmp&lt;/code&gt;, &lt;code&gt;memchr&lt;/code&gt;, and other functions that operate on arrays of bytes. In addition, calling &lt;code&gt;strnlen&lt;/code&gt; and &lt;code&gt;strndup&lt;/code&gt; with such arrays is safe provided a suitable bound is specified, and not diagnosed.</source>
          <target state="translated">&lt;code&gt;nonstring&lt;/code&gt; 유형의 배열 개체 또는 멤버 선언 것을 가변 속성 지정 &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;signed char&lt;/code&gt; 또는 &lt;code&gt;unsigned char&lt;/code&gt; 그러한 유형 또는 포인터는 반드시 종단 포함하지 않는 저장 문자 배열을 의도 &lt;code&gt;NUL&lt;/code&gt; 를 . 이는 &lt;code&gt;NUL&lt;/code&gt; 종료 문자열 을 예상하는 함수가있는 이러한 배열 또는 포인터의 사용을 감지 하고 이러한 배열 또는 포인터가 &lt;code&gt;strncpy&lt;/code&gt; 와 같은 바운드 문자열 조작 함수의 인수로 사용될 때 경고를 피하는 데 유용합니다 . 예를 들어 속성이 없으면 GCC는 &lt;code&gt;strncpy&lt;/code&gt; 에 대한 경고를 발행합니다.종료 &lt;code&gt;NUL&lt;/code&gt; 문자를 추가하지 않고 사본을자를 수 있으므로 아래로 전화하십시오 . 이 속성을 사용하면 경고를 억제 할 수 있습니다. 그러나 배열에 속성이 선언 된 경우 배열에 &lt;code&gt;NUL&lt;/code&gt; 종료 문자열이 포함되어 있지 않으면 호출이 정의되지 않기 때문에 &lt;code&gt;strlen&lt;/code&gt; 호출 이 진단됩니다 . 검색 문자열이 아닌 문자 배열을 복사, 비교하려면 &lt;code&gt;memcpy&lt;/code&gt; , &lt;code&gt;memcmp&lt;/code&gt; , &lt;code&gt;memchr&lt;/code&gt; 및 바이트 배열에서 작동하는 기타 함수를 사용하십시오 . 또한 적절한 범위가 지정되고 진단되지 않은 경우 이러한 배열로 &lt;code&gt;strnlen&lt;/code&gt; 및 &lt;code&gt;strndup&lt;/code&gt; 을 호출하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="bfce49165a44d874594bfffebd1dbb2dbd0c7094" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;noplt&lt;/code&gt; attribute is the counterpart to option</source>
          <target state="translated">&lt;code&gt;noplt&lt;/code&gt; 의 속성은 옵션으로 대응이다</target>
        </trans-unit>
        <trans-unit id="0300bf5cb9eee09bcd3c5b59946b4122f915396c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;noplt&lt;/code&gt; attribute on function &lt;code&gt;foo&lt;/code&gt; tells the compiler to assume that the function &lt;code&gt;foo&lt;/code&gt; is externally defined and that the call to &lt;code&gt;foo&lt;/code&gt; must avoid the PLT in position-independent code.</source>
          <target state="translated">함수 &lt;code&gt;foo&lt;/code&gt; 의 &lt;code&gt;noplt&lt;/code&gt; 속성 은 컴파일러에게 함수 &lt;code&gt;foo&lt;/code&gt; 가 외부 적으로 정의되어 있으며 &lt;code&gt;foo&lt;/code&gt; 를 호출하면 위치 독립적 인 코드에서 PLT를 피해야 한다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="3e2a9d3dba3dc91ebe5e03bbafab67f8838787f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;noreturn&lt;/code&gt; keyword does not affect the exceptional path when that applies: a &lt;code&gt;noreturn&lt;/code&gt;-marked function may still return to the caller by throwing an exception or calling &lt;code&gt;longjmp&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;noreturn&lt;/code&gt; A : 그 적용 할 때 키워드는 뛰어난 경로에 영향을주지 않습니다 &lt;code&gt;noreturn&lt;/code&gt; -marked 기능은 여전히 예외를 던지는 또는 호출하여 호출자에게 반환 할 수 있습니다 &lt;code&gt;longjmp&lt;/code&gt; 를을 .</target>
        </trans-unit>
        <trans-unit id="0ede64b6031c14f35d5f8cb3935b7f6f8ada1843" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;noreturn&lt;/code&gt; keyword tells the compiler to assume that &lt;code&gt;fatal&lt;/code&gt; cannot return. It can then optimize without regard to what would happen if &lt;code&gt;fatal&lt;/code&gt; ever did return. This makes slightly better code. More importantly, it helps avoid spurious warnings of uninitialized variables.</source>
          <target state="translated">&lt;code&gt;noreturn&lt;/code&gt; 키워드는 가정하는 컴파일러를 알려줍니다 &lt;code&gt;fatal&lt;/code&gt; 캔 반환하지. 그러면 &lt;code&gt;fatal&lt;/code&gt; 경우 어떻게 될지에 관계없이 최적화 할 수 있습니다 . 이것은 약간 더 나은 코드를 만듭니다. 더 중요한 것은 초기화되지 않은 변수에 대한 잘못된 경고를 피하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="322a4c52099d05e4a78d3c92d5bcf0059fa4fd77" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nothrow&lt;/code&gt; attribute is used to inform the compiler that a function cannot throw an exception. For example, most functions in the standard C library can be guaranteed not to throw an exception with the notable exceptions of &lt;code&gt;qsort&lt;/code&gt; and &lt;code&gt;bsearch&lt;/code&gt; that take function pointer arguments.</source>
          <target state="translated">&lt;code&gt;nothrow&lt;/code&gt; 의 특성 함수는 예외를 발생 할 수있는 컴파일러에 알리는 데 사용된다. 예를 들어, 표준 C 라이브러리의 대부분의 함수는 함수 포인터 인수를 취하는 &lt;code&gt;qsort&lt;/code&gt; 및 &lt;code&gt;bsearch&lt;/code&gt; 의 예외를 제외하고 예외를 발생시키지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="207d7791a2ec8b451439c9235cbe7bcf5c27be6d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;optimize&lt;/code&gt; attribute is used to specify that a function is to be compiled with different optimization options than specified on the command line. Valid arguments are constant non-negative integers and strings. Each numeric argument specifies an optimization &lt;var&gt;level&lt;/var&gt;. Each &lt;var&gt;string&lt;/var&gt; argument consists of one or more comma-separated substrings. Each substring that begins with the letter &lt;code&gt;O&lt;/code&gt; refers to an optimization option such as</source>
          <target state="translated">&lt;code&gt;optimize&lt;/code&gt; 속성은 함수가 명령 줄에 지정된 것과 다른 최적화 옵션으로 컴파일되어야 함을 지정하는 데 사용됩니다. 유효한 인수는 음이 아닌 정수 및 문자열입니다. 각 숫자 인수는 최적화 &lt;var&gt;level&lt;/var&gt; 지정합니다 . 각 &lt;var&gt;string&lt;/var&gt; 인수는 하나 이상의 쉼표로 구분 된 하위 문자열로 구성됩니다. 문자 &lt;code&gt;O&lt;/code&gt; 로 시작하는 각 하위 문자열은 다음과 같은 최적화 옵션을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="826d9e0c3c8b85ab7196ae31fb079d73a80bdae9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;packed&lt;/code&gt; attribute specifies that a structure member should have the smallest possible alignment&amp;mdash;one bit for a bit-field and one byte otherwise, unless a larger value is specified with the &lt;code&gt;aligned&lt;/code&gt; attribute. The attribute does not apply to non-member objects.</source>
          <target state="translated">&lt;code&gt;packed&lt;/code&gt; 큰 값이 지정되지 않는 속성을 지정하는 구조 부재는 달리 작은 가능한 배향 하나의 비트 필드의 비트 및 하나의 바이트를 가져야 &lt;code&gt;aligned&lt;/code&gt; 속성. 멤버가 아닌 개체에는이 특성이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="39beb9f00633eee839c4a2a5158a15d6e464e28e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pass-through-libs&lt;/code&gt; spec function takes any number of arguments. It finds any</source>
          <target state="translated">&lt;code&gt;pass-through-libs&lt;/code&gt; 사양 함수는 인수의 수 걸린다. 그것은 발견</target>
        </trans-unit>
        <trans-unit id="89c9a7db255ec3b8e7cca6652c90ae20f65b9a86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;patchable_function_entry&lt;/code&gt; function attribute can be used to change the number of NOPs to any desired value. The two-value syntax is the same as for the command-line switch</source>
          <target state="translated">&lt;code&gt;patchable_function_entry&lt;/code&gt; 의 함수 특성은 NOP를 원하는 값의 수를 변경하기 위해 사용될 수있다. 2 값 구문은 명령 행 스위치와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="e838ae744489fc704636367520fe3b637d47e7f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pcs&lt;/code&gt; attribute can be used to control the calling convention used for a function on ARM. The attribute takes an argument that specifies the calling convention to use.</source>
          <target state="translated">&lt;code&gt;pcs&lt;/code&gt; 속성은 ARM의 기능을 위해 사용되는 호출 방식을 제어하기 위해 사용될 수있다. 이 속성은 사용할 호출 규칙을 지정하는 인수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="bbf4d6b72a577c7b95004980e1bce0048594d8dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;print-asm-header&lt;/code&gt; function takes no arguments and simply prints a banner like:</source>
          <target state="translated">&lt;code&gt;print-asm-header&lt;/code&gt; 함수는 인수를하지 않고 단순히 같은 배너를 인쇄 :</target>
        </trans-unit>
        <trans-unit id="cb4fc17c6269a43f696bb9bef92ec98733094225" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pure&lt;/code&gt; attribute imposes similar but looser restrictions on a function&amp;rsquo;s definition than the &lt;code&gt;const&lt;/code&gt; attribute: &lt;code&gt;pure&lt;/code&gt; allows the function to read any non-volatile memory, even if it changes in between successive invocations of the function. Declaring the same function with both the &lt;code&gt;pure&lt;/code&gt; and the &lt;code&gt;const&lt;/code&gt; attribute is diagnosed. Because a pure function cannot have any observable side effects it does not make sense for such a function to return &lt;code&gt;void&lt;/code&gt;. Declaring such a function is diagnosed.</source>
          <target state="translated">&lt;code&gt;pure&lt;/code&gt; 속성은보다 함수의 정의에 유사하지만 느슨한 제한이 부과 &lt;code&gt;const&lt;/code&gt; 속성을 : &lt;code&gt;pure&lt;/code&gt; 이 함수의 연속적인 호출 사이에서 변경 되어도, 함수가 비 휘발성 메모리를 읽을 수 있습니다. &lt;code&gt;pure&lt;/code&gt; 및 &lt;code&gt;const&lt;/code&gt; 속성을 사용 하여 동일한 함수를 선언하면 진단됩니다. 순수한 함수는 관찰 가능한 부작용을 가질 수 없기 때문에 그러한 함수가 &lt;code&gt;void&lt;/code&gt; 를 반환하는 것은 의미가 없습니다 . 이러한 기능을 선언하면 진단됩니다.</target>
        </trans-unit>
        <trans-unit id="323eb04f8039811b3bb58c82bccb097f2a6f7bce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pure&lt;/code&gt; attribute prohibits a function from modifying the state of the program that is observable by means other than inspecting the function&amp;rsquo;s return value. However, functions declared with the &lt;code&gt;pure&lt;/code&gt; attribute can safely read any non-volatile objects, and modify the value of objects in a way that does not affect their return value or the observable state of the program.</source>
          <target state="translated">&lt;code&gt;pure&lt;/code&gt; 특성은 함수의 리턴 값을 검사 이외의 방법에 의해 관찰 할 프로그램의 상태를 수정하는 기능을 금지한다. 그러나 &lt;code&gt;pure&lt;/code&gt; 속성으로 선언 된 함수는 비 휘발성 오브젝트를 안전하게 읽고 리턴 값 또는 프로그램의 관찰 가능한 상태에 영향을주지 않는 방식으로 오브젝트 값을 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24119821985c46d89b11400454926b0593b3b50d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read_only&lt;/code&gt; access mode specifies that the pointer to which it applies is used to read the referenced object but not write to it. Unless the argument specifying the size of the access denoted by &lt;var&gt;size-index&lt;/var&gt; is zero, the referenced object must be initialized. The mode implies a stronger guarantee than the &lt;code&gt;const&lt;/code&gt; qualifier which, when cast away from a pointer, does not prevent the pointed-to object from being modified. Examples of the use of the &lt;code&gt;read_only&lt;/code&gt; access mode is the argument to the &lt;code&gt;puts&lt;/code&gt; function, or the second and third arguments to the &lt;code&gt;memcpy&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;read_only&lt;/code&gt; 가 적용되는 포인터가 참조 된 개체를 읽는 데 사용하지만,되지 않도록 액세스 모드 지정에 쓸. &lt;var&gt;size-index&lt;/var&gt; 로 표시된 액세스 크기를 지정하는 인수 가 0이 아니면 참조 된 개체를 초기화해야합니다. 모드 는 포인터에서 캐스트 될 때 가리키는 객체가 수정되는 것을 방지하지 않는 &lt;code&gt;const&lt;/code&gt; 한정자 보다 더 강력한 보증을 의미합니다 . &lt;code&gt;read_only&lt;/code&gt; 액세스 모드 사용의 예는 &lt;code&gt;puts&lt;/code&gt; 함수에 대한 인수 또는 &lt;code&gt;memcpy&lt;/code&gt; 함수에 대한 두 번째 및 세 번째 인수 입니다.</target>
        </trans-unit>
        <trans-unit id="88a3f3d3b23da8341683a81df31a980b08cf319c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read_write&lt;/code&gt; access mode applies to arguments of pointer types without the &lt;code&gt;const&lt;/code&gt; qualifier. It specifies that the pointer to which it applies is used to both read and write the referenced object. Unless the argument specifying the size of the access denoted by &lt;var&gt;size-index&lt;/var&gt; is zero, the object referenced by the pointer must be initialized. An example of the use of the &lt;code&gt;read_write&lt;/code&gt; access mode is the first argument to the &lt;code&gt;strcat&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;read_write&lt;/code&gt; 액세스 모드는 않고 포인터 타입의 인수를 적용 &lt;code&gt;const&lt;/code&gt; 를 규정. 적용되는 포인터가 참조 된 객체를 읽고 쓰는 데 모두 사용되도록 지정합니다. &lt;var&gt;size-index&lt;/var&gt; 로 표시된 액세스 크기를 지정하는 인수 가 0이 아닌 경우 포인터가 참조하는 개체를 초기화해야합니다. &lt;code&gt;read_write&lt;/code&gt; 액세스 모드 사용의 예 는 &lt;code&gt;strcat&lt;/code&gt; 함수에 대한 첫 번째 인수 입니다.</target>
        </trans-unit>
        <trans-unit id="1720331b79d485f642342587a0a4961224f570c6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;register&lt;/code&gt; specifier affects code generation only in these ways:</source>
          <target state="translated">&lt;code&gt;register&lt;/code&gt; 지정은 다음과 같은 방법으로 코드 생성에 영향을 미칩니다</target>
        </trans-unit>
        <trans-unit id="a5258162416b278a0bfac9c4c7558d341c9154f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;remove-outfile&lt;/code&gt; spec function takes one argument. It looks for the first argument in the outfiles array and removes it. Here is a small example its usage:</source>
          <target state="translated">&lt;code&gt;remove-outfile&lt;/code&gt; 사양 기능은 하나 개의 인수를합니다. outfiles 배열에서 첫 번째 인수를 찾아서 제거합니다. 다음은 사용법에 대한 작은 예입니다.</target>
        </trans-unit>
        <trans-unit id="55bb4e8d3fe19956428bf774ea204bd862418b82" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;replace-outfile&lt;/code&gt; spec function takes two arguments. It looks for the first argument in the outfiles array and replaces it with the second argument. Here is a small example of its usage:</source>
          <target state="translated">&lt;code&gt;replace-outfile&lt;/code&gt; 사양 함수는 두 개의 인수를 취합니다. outfiles 배열에서 첫 번째 인수를 찾아서 두 번째 인수로 바꿉니다. 다음은 사용법의 작은 예입니다.</target>
        </trans-unit>
        <trans-unit id="9408f2030b23dd54137985158e8c003e073220be" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;returns_nonnull&lt;/code&gt; attribute specifies that the function return value should be a non-null pointer. For instance, the declaration:</source>
          <target state="translated">&lt;code&gt;returns_nonnull&lt;/code&gt; 속성 지정 함수 반환 값은 비 - 널 포인터되어야한다고. 예를 들어, 선언 :</target>
        </trans-unit>
        <trans-unit id="3e04bc9de35eb5e502accce1b00b75bbadd857dc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;returns_twice&lt;/code&gt; attribute tells the compiler that a function may return more than one time. The compiler ensures that all registers are dead before calling such a function and emits a warning about the variables that may be clobbered after the second return from the function. Examples of such functions are &lt;code&gt;setjmp&lt;/code&gt; and &lt;code&gt;vfork&lt;/code&gt;. The &lt;code&gt;longjmp&lt;/code&gt;-like counterpart of such function, if any, might need to be marked with the &lt;code&gt;noreturn&lt;/code&gt; attribute.</source>
          <target state="translated">&lt;code&gt;returns_twice&lt;/code&gt; 의 속성은 함수가 더 한 시간보다 반환 할 수있는 컴파일러를 알려줍니다. 컴파일러는 이러한 함수를 호출하기 전에 모든 레지스터가 종료되었는지 확인하고 함수에서 두 번째 리턴 후 클로버 될 수있는 변수에 대한 경고를 표시합니다. 이러한 함수의 예는 &lt;code&gt;setjmp&lt;/code&gt; 및 &lt;code&gt;vfork&lt;/code&gt; 입니다. 그러한 함수 의 &lt;code&gt;longjmp&lt;/code&gt; 와 비슷한 함수는 &lt;code&gt;noreturn&lt;/code&gt; 속성 으로 표시해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d109540c91de909173d68023125715d31c5696c6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rtd&lt;/code&gt; instruction is supported by the 68010, 68020, 68030, 68040, 68060 and CPU32 processors, but not by the 68000 or 5200.</source>
          <target state="translated">&lt;code&gt;rtd&lt;/code&gt; 명령이 아니라 68000 또는 5200에 의해, 68010, 68020, 68030, 68040, 68060 및 CPU32 프로세서에 의해 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="d6a97b87fbba98b99c49488ce8d99f3965e9820d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scalar_cmp_exp_gt&lt;/code&gt;, &lt;code&gt;scalar_cmp_exp_lt&lt;/code&gt;, &lt;code&gt;scalar_cmp_exp_eq&lt;/code&gt;, and &lt;code&gt;scalar_cmp_exp_unordered&lt;/code&gt; built-in functions return a non-zero value if &lt;code&gt;arg1&lt;/code&gt; is greater than, less than, equal to, or not comparable to &lt;code&gt;arg2&lt;/code&gt; respectively. The arguments are not comparable if one or the other equals NaN (not a number).</source>
          <target state="translated">&lt;code&gt;scalar_cmp_exp_gt&lt;/code&gt; , &lt;code&gt;scalar_cmp_exp_lt&lt;/code&gt; , &lt;code&gt;scalar_cmp_exp_eq&lt;/code&gt; 및 &lt;code&gt;scalar_cmp_exp_unordered&lt;/code&gt; 내장 함수 경우 영이 아닌 값을 반환 &lt;code&gt;arg1&lt;/code&gt; , 이하보다 큰 같거나 비슷하지 &lt;code&gt;arg2&lt;/code&gt; 각각. 하나 또는 다른 하나가 NaN (숫자가 아님)이면 인수는 비교할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8ed56e8dd6f8e41dde6e37a24332591f1ce27f7a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scalar_extract_exp&lt;/code&gt; and &lt;code&gt;scalar_extract_sig&lt;/code&gt; functions require a 64-bit environment supporting ISA 3.0 or later. The &lt;code&gt;scalar_extract_exp&lt;/code&gt; and &lt;code&gt;scalar_extract_sig&lt;/code&gt; built-in functions return the significand and the biased exponent value respectively of their &lt;code&gt;source&lt;/code&gt; arguments. When supplied with a 64-bit &lt;code&gt;source&lt;/code&gt; argument, the result returned by &lt;code&gt;scalar_extract_sig&lt;/code&gt; has the &lt;code&gt;0x0010000000000000&lt;/code&gt; bit set if the function&amp;rsquo;s &lt;code&gt;source&lt;/code&gt; argument is in normalized form. Otherwise, this bit is set to 0. When supplied with a 128-bit &lt;code&gt;source&lt;/code&gt; argument, the &lt;code&gt;0x00010000000000000000000000000000&lt;/code&gt; bit of the result is treated similarly. Note that the sign of the significand is not represented in the result returned from the &lt;code&gt;scalar_extract_sig&lt;/code&gt; function. Use the &lt;code&gt;scalar_test_neg&lt;/code&gt; function to test the sign of its &lt;code&gt;double&lt;/code&gt; argument.</source>
          <target state="translated">&lt;code&gt;scalar_extract_exp&lt;/code&gt; 및 &lt;code&gt;scalar_extract_sig&lt;/code&gt; 기능 이상 3.0 ISA를 지원하는 64 비트 환경을 필요로한다. &lt;code&gt;scalar_extract_exp&lt;/code&gt; 및 &lt;code&gt;scalar_extract_sig&lt;/code&gt; 내장 함수는 자신의 각각 유효 숫자와 바이어스 지수 값을 반환 &lt;code&gt;source&lt;/code&gt; 인수. 64 비트 &lt;code&gt;source&lt;/code&gt; 인수가 제공 될 때 &lt;code&gt;scalar_extract_sig&lt;/code&gt; 에 의해 리턴 된 결과 는 함수의 &lt;code&gt;source&lt;/code&gt; 인수가 정규화 된 형식 인 경우 &lt;code&gt;0x0010000000000000&lt;/code&gt; 비트 세트를 갖습니다 . 그렇지 않으면이 비트는 0으로 설정됩니다. 128 비트 &lt;code&gt;source&lt;/code&gt; 인수가 제공되면 &lt;code&gt;0x00010000000000000000000000000000&lt;/code&gt; 약간의 결과가 유사하게 취급됩니다. significand의 부호는 &lt;code&gt;scalar_extract_sig&lt;/code&gt; 함수 에서 반환 된 결과에 표시되지 않습니다 . &lt;code&gt;scalar_test_neg&lt;/code&gt; 함수를 사용하여 &lt;code&gt;double&lt;/code&gt; 인수 의 부호를 테스트하십시오 .</target>
        </trans-unit>
        <trans-unit id="1f38aa375929331668f316b9a82c74ab6cc36489" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scalar_extract_exp&lt;/code&gt; and &lt;code&gt;scalar_extract_sig&lt;/code&gt; functions require a 64-bit environment supporting ISA 3.0 or later. The &lt;code&gt;scalar_extract_exp&lt;/code&gt; and &lt;code&gt;scalar_extract_sig&lt;/code&gt; built-in functions return the significand and the biased exponent value respectively of their &lt;code&gt;source&lt;/code&gt; arguments. When supplied with a 64-bit &lt;code&gt;source&lt;/code&gt; argument, the result returned by &lt;code&gt;scalar_extract_sig&lt;/code&gt; has the &lt;code&gt;0x0010000000000000&lt;/code&gt; bit set if the function&amp;rsquo;s &lt;code&gt;source&lt;/code&gt; argument is in normalized form. Otherwise, this bit is set to 0. When supplied with a 128-bit &lt;code&gt;source&lt;/code&gt; argument, the &lt;code&gt;0x00010000000000000000000000000000&lt;/code&gt; bit of the result is treated similarly. Note that the sign of the significand is not represented in the result returned from the &lt;code&gt;scalar_extract_sig&lt;/code&gt; function. Use the &lt;code&gt;scalar_test_neg&lt;/code&gt; function to test the sign of its &lt;code&gt;double&lt;/code&gt; argument. The &lt;code&gt;vec_msum&lt;/code&gt; functions perform a vector multiply-sum, returning the result of arg1*arg2+arg3. ISA 3.0 adds support for vec_msum returning a vector int128 result.</source>
          <target state="translated">&lt;code&gt;scalar_extract_exp&lt;/code&gt; 및 &lt;code&gt;scalar_extract_sig&lt;/code&gt; 기능 이상 3.0 ISA를 지원하는 64 비트 환경을 필요로한다. &lt;code&gt;scalar_extract_exp&lt;/code&gt; 및 &lt;code&gt;scalar_extract_sig&lt;/code&gt; 내장 함수는 자신의 각각 유효 숫자와 바이어스 지수 값을 반환 &lt;code&gt;source&lt;/code&gt; 인수. 64 비트가 공급되면 &lt;code&gt;source&lt;/code&gt; 인수에 의해 리턴 된 결과 &lt;code&gt;scalar_extract_sig&lt;/code&gt; 는 갖는다 &lt;code&gt;0x0010000000000000&lt;/code&gt; 함수의 경우 비트 세트를 &lt;code&gt;source&lt;/code&gt; 인수 정규화 형태이다. 그렇지 않으면이 비트는 0으로 설정됩니다. 128 비트 &lt;code&gt;source&lt;/code&gt; 인수 와 함께 제공되면 &lt;code&gt;0x00010000000000000000000000000000&lt;/code&gt; 결과의 비트는 유사하게 취급됩니다. significand의 부호는 &lt;code&gt;scalar_extract_sig&lt;/code&gt; 함수 에서 반환 된 결과에 표시되지 않습니다 . &lt;code&gt;double&lt;/code&gt; 인수 의 부호를 테스트 하려면 &lt;code&gt;scalar_test_neg&lt;/code&gt; 함수를 사용하십시오 . &lt;code&gt;vec_msum&lt;/code&gt; 의 기능은 ARG1 ARG2 * +에서 arg3의 결과를 반환하는 벡터 곱셈 - 합을 수행한다. ISA 3.0은 벡터 int128 결과를 반환하는 vec_msum에 대한 지원을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="a572c2c2b0d3df765ec4322dbf92c35c2e4cbc19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scalar_insert_exp&lt;/code&gt; functions require a 64-bit environment supporting ISA 3.0 or later. When supplied with a 64-bit first argument, the &lt;code&gt;scalar_insert_exp&lt;/code&gt; built-in function returns a double-precision floating point value that is constructed by assembling the values of its &lt;code&gt;significand&lt;/code&gt; and &lt;code&gt;exponent&lt;/code&gt; arguments. The sign of the result is copied from the most significant bit of the &lt;code&gt;significand&lt;/code&gt; argument. The significand and exponent components of the result are composed of the least significant 11 bits of the &lt;code&gt;exponent&lt;/code&gt; argument and the least significant 52 bits of the &lt;code&gt;significand&lt;/code&gt; argument respectively.</source>
          <target state="translated">&lt;code&gt;scalar_insert_exp&lt;/code&gt; 의 기능 이상 또는 3.0 ISA를 지원하는 64 비트 환경을 필요로한다. 64 비트 첫 번째 인수가 제공되면 &lt;code&gt;scalar_insert_exp&lt;/code&gt; 내장 함수는 &lt;code&gt;significand&lt;/code&gt; 및 &lt;code&gt;exponent&lt;/code&gt; 인수 의 값을 조합하여 구성된 배정 밀도 부동 소수점 값을 리턴합니다 . 결과의 부호는 &lt;code&gt;significand&lt;/code&gt; 인수 의 가장 중요한 부분에서 복사됩니다 . 결과의 유효 및 지수 성분은 각각 &lt;code&gt;exponent&lt;/code&gt; 인수 의 최하위 11 비트 및 &lt;code&gt;significand&lt;/code&gt; 인수 의 최하위 52 비트로 구성 됩니다.</target>
        </trans-unit>
        <trans-unit id="30e5f673754badb55457e9f6e18bad2fb7c8867f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scalar_test_data_class&lt;/code&gt; built-in function returns 1 if any of the condition tests enabled by the value of the &lt;code&gt;condition&lt;/code&gt; variable are true, and 0 otherwise. The &lt;code&gt;condition&lt;/code&gt; argument must be a compile-time constant integer with value not exceeding 127. The &lt;code&gt;condition&lt;/code&gt; argument is encoded as a bitmask with each bit enabling the testing of a different condition, as characterized by the following:</source>
          <target state="translated">&lt;code&gt;scalar_test_data_class&lt;/code&gt; 는 의 값으로 사용 조건 시험의 경우 함수가 반환 한 내장 &lt;code&gt;condition&lt;/code&gt; 변수에 해당하고, 그렇지 않으면 0. &lt;code&gt;condition&lt;/code&gt; 인자 값 (127) 이하로 컴파일 시간 상수 정수이어야 &lt;code&gt;condition&lt;/code&gt; 은 다음을 특징으로 인수를, 다른 조건의 테스트를 가능하게 각 비트와 비트 마스크로서 부호화된다 :</target>
        </trans-unit>
        <trans-unit id="8baf3f4610726735a8a214eff212593a1cbf0b19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scalar_test_neg&lt;/code&gt; built-in function returns 1 if its &lt;code&gt;source&lt;/code&gt; argument holds a negative value, 0 otherwise.</source>
          <target state="translated">&lt;code&gt;scalar_test_neg&lt;/code&gt; 는 내장 함수가 반환 1의 경우 &lt;code&gt;source&lt;/code&gt; 인수가 음의 값, 그렇지 않으면 0을 보유하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="312b5b4b73e9b711ee72f43d70d664005613348e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;selectany&lt;/code&gt; attribute causes an initialized global variable to have link-once semantics. When multiple definitions of the variable are encountered by the linker, the first is selected and the remainder are discarded. Following usage by the Microsoft compiler, the linker is told &lt;em&gt;not&lt;/em&gt; to warn about size or content differences of the multiple definitions.</source>
          <target state="translated">&lt;code&gt;selectany&lt;/code&gt; 의 속성은 링크 한 번 의미를 가지고 초기화 된 전역 변수가 발생합니다. 링커에서 변수의 여러 정의를 발견하면 첫 번째가 선택되고 나머지는 삭제됩니다. 링커는 Microsoft 컴파일러의 사용에 따라 여러 정의의 크기 또는 내용 차이에 대해 경고 &lt;em&gt;하지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7bbd5708df7b8ad51e26c82827c5a8837087e1d7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;selectany&lt;/code&gt; attribute is only available on Microsoft Windows targets. You can use &lt;code&gt;__declspec (selectany)&lt;/code&gt; as a synonym for &lt;code&gt;__attribute__ ((selectany))&lt;/code&gt; for compatibility with other compilers.</source>
          <target state="translated">&lt;code&gt;selectany&lt;/code&gt; 의 속성은 마이크로 소프트 Windows 대상에서만 사용할 수 있습니다. 다른 컴파일러와의 호환성을 위해 &lt;code&gt;__declspec (selectany)&lt;/code&gt; 을 &lt;code&gt;__attribute__ ((selectany))&lt;/code&gt; 의 동의어로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="14873a7d123565ace388d75f6ab559389f994c52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shared&lt;/code&gt; attribute is only available on Microsoft Windows.</source>
          <target state="translated">&lt;code&gt;shared&lt;/code&gt; 속성은 마이크로 소프트 윈도우에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9085a2da6609ed3bc0fa42e0bccb84c58724a810" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;si&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;si&lt;/code&gt; 레지스터.</target>
        </trans-unit>
        <trans-unit id="5a2831e5752e0e20c3cf70a499fe35cbe998dc8c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;state&lt;/code&gt; and &lt;code&gt;extra&lt;/code&gt; fields of the &lt;code&gt;NSFastEnumerationState&lt;/code&gt; structure allows your collection object to keep track of the state of the enumeration. In a simple array implementation, &lt;code&gt;state&lt;/code&gt; may keep track of the index of the last object that was returned, and &lt;code&gt;extra&lt;/code&gt; may be unused.</source>
          <target state="translated">&lt;code&gt;NSFastEnumerationState&lt;/code&gt; 구조 의 &lt;code&gt;state&lt;/code&gt; 및 &lt;code&gt;extra&lt;/code&gt; 필드를 사용하면 컬렉션 개체가 열거 상태를 추적 할 수 있습니다. 간단한 배열 구현에서 &lt;code&gt;state&lt;/code&gt; 는 마지막으로 반환 된 객체의 인덱스를 추적 할 수 있으며 &lt;code&gt;extra&lt;/code&gt; 는 사용되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c61038602bd0b5479d4058a6d4baafd6a0c2107" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;struct __htm_tdb&lt;/code&gt; defined in &lt;code&gt;htmintrin.h&lt;/code&gt; describes the structure of the transaction diagnostic block as specified in the Principles of Operation manual chapter 5-91.</source>
          <target state="translated">&lt;code&gt;struct __htm_tdb&lt;/code&gt; 정의 &lt;code&gt;htmintrin.h&lt;/code&gt; 는 사용 설명서 제 5-91의 원리에 지정된 트랜잭션 진단 블록의 구조를 설명한다.</target>
        </trans-unit>
        <trans-unit id="1669605966a6a01f0ff15b0d1cc0c388abd2971a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;target&lt;/code&gt; attribute can be used for instance to have a function compiled with a different ISA (instruction set architecture) than the default. &amp;lsquo;</source>
          <target state="translated">예를 들어 , &lt;code&gt;target&lt;/code&gt; 속성은 기본값과 다른 ISA (명령 세트 아키텍처)로 컴파일 된 함수를 갖는 데 사용될 수 있습니다. '</target>
        </trans-unit>
        <trans-unit id="9c500ff15f72b79070a64c0e0436e7dcdc9aaf0d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;target_clones&lt;/code&gt; attribute is used to specify that a function be cloned into multiple versions compiled with different target options than specified on the command line. The supported options and restrictions are the same as for &lt;code&gt;target&lt;/code&gt; attribute.</source>
          <target state="translated">&lt;code&gt;target_clones&lt;/code&gt; 의 특성 함수는 명령 줄에 지정된 것과 다른 타겟 옵션 컴파일 여러 버전에 클로닝되도록 지정하는 데 사용된다. 지원되는 옵션 및 제한 사항은 &lt;code&gt;target&lt;/code&gt; 속성 과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="ccf91998c7f416dcbd90db0b120c7a4f8d3b089f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tls_model&lt;/code&gt; attribute sets thread-local storage model (see &lt;a href=&quot;thread_002dlocal#Thread_002dLocal&quot;&gt;Thread-Local&lt;/a&gt;) of a particular &lt;code&gt;__thread&lt;/code&gt; variable, overriding</source>
          <target state="translated">&lt;code&gt;tls_model&lt;/code&gt; 의 속성 세트 스레드 로컬 스토리지 모델 (참조 : &lt;a href=&quot;thread_002dlocal#Thread_002dLocal&quot;&gt;스레드 로컬&lt;/a&gt; 특정의) &lt;code&gt;__thread&lt;/code&gt; 의 무시 변수</target>
        </trans-unit>
        <trans-unit id="2f43feeb5f6870d9594f888564bad52895276f45" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vec_absd&lt;/code&gt;, &lt;code&gt;vec_absdb&lt;/code&gt;, &lt;code&gt;vec_absdh&lt;/code&gt;, and &lt;code&gt;vec_absdw&lt;/code&gt; built-in functions each computes the absolute differences of the pairs of vector elements supplied in its two vector arguments, placing the absolute differences into the corresponding elements of the vector result.</source>
          <target state="translated">&lt;code&gt;vec_absd&lt;/code&gt; , &lt;code&gt;vec_absdb&lt;/code&gt; , &lt;code&gt;vec_absdh&lt;/code&gt; 및 &lt;code&gt;vec_absdw&lt;/code&gt; 내장 함수를 각각 계산하는 벡터 결과에 대응하는 요소에 차이 절대 배치는 두 벡터 인수 공급 벡터 요소의 쌍의 절대 차이.</target>
        </trans-unit>
        <trans-unit id="cc17321076f6146e9d0eff176ccfd2642bdf04e8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vec_all_nez&lt;/code&gt;, &lt;code&gt;vec_any_eqz&lt;/code&gt;, and &lt;code&gt;vec_cmpnez&lt;/code&gt; perform pairwise comparisons between the elements at the same positions within their two vector arguments. The &lt;code&gt;vec_all_nez&lt;/code&gt; function returns a non-zero value if and only if all pairwise comparisons are not equal and no element of either vector argument contains a zero. The &lt;code&gt;vec_any_eqz&lt;/code&gt; function returns a non-zero value if and only if at least one pairwise comparison is equal or if at least one element of either vector argument contains a zero. The &lt;code&gt;vec_cmpnez&lt;/code&gt; function returns a vector of the same type as its two arguments, within which each element consists of all ones to denote that either the corresponding elements of the incoming arguments are not equal or that at least one of the corresponding elements contains zero. Otherwise, the element of the returned vector contains all zeros.</source>
          <target state="translated">&lt;code&gt;vec_all_nez&lt;/code&gt; , &lt;code&gt;vec_any_eqz&lt;/code&gt; 및 &lt;code&gt;vec_cmpnez&lt;/code&gt; 는 그들의 두 벡터 인수 내에서 동일한 위치의 요소들 간의 쌍대 비교를 수행한다. &lt;code&gt;vec_all_nez&lt;/code&gt; 의 기능은 0이 아닌 값을 반환하는 경우 모든 페어의 비교는 동일하지와 두 벡터 인수의 어떤 요소가 0을 포함하지 않는 경우에만 가능합니다. &lt;code&gt;vec_any_eqz&lt;/code&gt; 의 함수는 0이 아닌 값을 리턴하는 경우, 적어도 하나 개의 쌍대 비교 같거나 어느 벡터 인자 중 적어도 하나 개의 요소가 0을 포함하는 경우에만 경우. &lt;code&gt;vec_cmpnez&lt;/code&gt; 함수는 두 인수와 동일한 유형의 벡터를 반환하며, 각 요소는 들어오는 인수의 해당 요소가 같지 않거나 해당 요소 중 하나 이상에 0이 포함되어 있음을 나타 내기 위해 모든 요소로 구성됩니다. 그렇지 않으면 반환 된 벡터 요소에 모두 0이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="a9ea2035fded0002d7bb2f5901563d260d2323cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vec_cntlz_lsbb&lt;/code&gt; function returns the count of the number of consecutive leading byte elements (starting from position 0 within the supplied vector argument) for which the least-significant bit equals zero. The &lt;code&gt;vec_cnttz_lsbb&lt;/code&gt; function returns the count of the number of consecutive trailing byte elements (starting from position 15 and counting backwards within the supplied vector argument) for which the least-significant bit equals zero.</source>
          <target state="translated">&lt;code&gt;vec_cntlz_lsbb&lt;/code&gt; 의 함수는 연속 선두 바이트 소자의 수의 카운트가 최하위 비트가 0 인하는 (제공된 인수 벡터 내의 위치 0에서 시작) 리턴한다. &lt;code&gt;vec_cnttz_lsbb&lt;/code&gt; 의 함수 반환 연속 후행 바이트 소자의 수의 카운트 (위치 15에서 시작하고, 제공된 인수 벡터 내에 거꾸로 카운트) 최하위 비트가 0 인하는.</target>
        </trans-unit>
        <trans-unit id="01b02bbdd65d95e68fbfa45f0222f7cae6e029b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vec_extract_sig&lt;/code&gt; and &lt;code&gt;vec_extract_exp&lt;/code&gt; built-in functions return vectors representing the significands and biased exponent values of their &lt;code&gt;source&lt;/code&gt; arguments respectively. Within the result vector returned by &lt;code&gt;vec_extract_sig&lt;/code&gt;, the &lt;code&gt;0x800000&lt;/code&gt; bit of each vector element returned when the function&amp;rsquo;s &lt;code&gt;source&lt;/code&gt; argument is of type &lt;code&gt;float&lt;/code&gt; is set to 1 if the corresponding floating point value is in normalized form. Otherwise, this bit is set to 0. When the &lt;code&gt;source&lt;/code&gt; argument is of type &lt;code&gt;double&lt;/code&gt;, the &lt;code&gt;0x10000000000000&lt;/code&gt; bit within each of the result vector&amp;rsquo;s elements is set according to the same rules. Note that the sign of the significand is not represented in the result returned from the &lt;code&gt;vec_extract_sig&lt;/code&gt; function. To extract the sign bits, use the &lt;code&gt;vec_cpsgn&lt;/code&gt; function, which returns a new vector within which all of the sign bits of its second argument vector are overwritten with the sign bits copied from the coresponding elements of its first argument vector, and all other (non-sign) bits of the second argument vector are copied unchanged into the result vector.</source>
          <target state="translated">&lt;code&gt;vec_extract_sig&lt;/code&gt; 및 &lt;code&gt;vec_extract_exp&lt;/code&gt; 내장 함수는 자신의 significands 및 바이어스 지수 값을 나타내는 벡터를 돌려 &lt;code&gt;source&lt;/code&gt; 를 각각 인수. 에 의해 반환 된 결과 벡터 내 &lt;code&gt;vec_extract_sig&lt;/code&gt; 은 &lt;code&gt;0x800000&lt;/code&gt; 함수의 경우, 각 벡터의 요소의 비트가 리턴 &lt;code&gt;source&lt;/code&gt; 인수 형이다 &lt;code&gt;float&lt;/code&gt; 대응하는 부동 소수점 값은 정규화 된 형태 인 경우에 1로 설정된다. 그렇지 않으면이 비트는 0으로 설정됩니다. &lt;code&gt;source&lt;/code&gt; 인수가 &lt;code&gt;double&lt;/code&gt; 유형 인 경우 &lt;code&gt;0x10000000000000&lt;/code&gt; 각각의 결과 벡터 요소 내의 비트는 동일한 규칙에 따라 설정된다. significand의 부호는 &lt;code&gt;vec_extract_sig&lt;/code&gt; 함수 에서 반환 된 결과에 표시되지 않습니다 . 부호 비트를 추출하려면 &lt;code&gt;vec_cpsgn&lt;/code&gt; 함수를 사용하십시오 .이 함수는 두 번째 인수 벡터의 모든 부호 비트를 첫 번째 인수 벡터의 핵심 응답 요소에서 복사 한 부호 비트로 덮어 쓰는 새 벡터를 반환합니다. 두 번째 인수 벡터의 -sign) 비트는 변경되지 않고 결과 벡터로 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="5a829a08652f6801fcbd433b37bbf07c5d838fb5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vec_insert_exp&lt;/code&gt; built-in functions return a vector of single- or double-precision floating point values constructed by assembling the values of their &lt;code&gt;significands&lt;/code&gt; and &lt;code&gt;exponents&lt;/code&gt; arguments into the corresponding elements of the returned vector. The sign of each element of the result is copied from the most significant bit of the corresponding entry within the &lt;code&gt;significands&lt;/code&gt; argument. Note that the relevant bits of the &lt;code&gt;significands&lt;/code&gt; argument are the same, for both integer and floating point types. The significand and exponent components of each element of the result are composed of the least significant bits of the corresponding &lt;code&gt;significands&lt;/code&gt; element and the least significant bits of the corresponding &lt;code&gt;exponents&lt;/code&gt; element.</source>
          <target state="translated">&lt;code&gt;vec_insert_exp&lt;/code&gt; 내장 함수는 값 조립하여 구성 단일 또는 배정 밀도 부동 소수점 값의 벡터 반환 &lt;code&gt;significands&lt;/code&gt; 와 &lt;code&gt;exponents&lt;/code&gt; 반환 벡터의 해당 요소로 인수를. 결과의 각 요소의 부호는 &lt;code&gt;significands&lt;/code&gt; 인수 내의 해당 항목의 최상위 비트에서 복사됩니다 . 정수 및 부동 소수점 유형 모두 &lt;code&gt;significands&lt;/code&gt; 인수 의 관련 비트가 동일합니다. 결과의 각 요소의 유효 및 지수 성분은 해당 &lt;code&gt;significands&lt;/code&gt; 의 최소 ​​유효 비트로 구성됩니다.요소와 해당 &lt;code&gt;exponents&lt;/code&gt; 요소 의 최하위 비트 .</target>
        </trans-unit>
        <trans-unit id="0a91af05019f6d272dc741d0e069fe70406b3512" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vec_revb&lt;/code&gt; built-in function reverses the bytes on an element by element basis. A vector of &lt;code&gt;vector unsigned char&lt;/code&gt; or &lt;code&gt;vector signed char&lt;/code&gt; reverses the bytes in the whole word.</source>
          <target state="translated">&lt;code&gt;vec_revb&lt;/code&gt; 내장 된 기능 요소별로 요소에 바이트를 반전시킵니다. 의 벡터 &lt;code&gt;vector unsigned char&lt;/code&gt; 또는 &lt;code&gt;vector signed char&lt;/code&gt; 전체 단어 바이트를 반전시킵니다.</target>
        </trans-unit>
        <trans-unit id="9de89009a6ac207492ea21a351e324b964d19bce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vec_rsqrt&lt;/code&gt;, &lt;code&gt;__builtin_rsqrt&lt;/code&gt;, and &lt;code&gt;__builtin_rsqrtf&lt;/code&gt; functions generate multiple instructions to implement the reciprocal sqrt functionality using reciprocal sqrt estimate instructions.</source>
          <target state="translated">는 &lt;code&gt;vec_rsqrt&lt;/code&gt; , &lt;code&gt;__builtin_rsqrt&lt;/code&gt; 및 &lt;code&gt;__builtin_rsqrtf&lt;/code&gt; 의 기능은 여러 지침 상호 SQRT 추정 지침에 따라 상호 SQRT 기능을 구현하기 위해 생성합니다.</target>
        </trans-unit>
        <trans-unit id="246e48e9c9edd5f446bb04be8d23c0491da1918c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vec_slv&lt;/code&gt; and &lt;code&gt;vec_srv&lt;/code&gt; functions operate on all of the bytes of their &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;shift_distance&lt;/code&gt; arguments in parallel. The behavior of the &lt;code&gt;vec_slv&lt;/code&gt; is as if there existed a temporary array of 17 unsigned characters &lt;code&gt;slv_array&lt;/code&gt; within which elements 0 through 15 are the same as the entries in the &lt;code&gt;src&lt;/code&gt; array and element 16 equals 0. The result returned from the &lt;code&gt;vec_slv&lt;/code&gt; function is a &lt;code&gt;__vector&lt;/code&gt; of 16 unsigned characters within which element &lt;code&gt;i&lt;/code&gt; is computed using the C expression &lt;code&gt;0xff &amp;amp; (*((unsigned short *)(slv_array + i)) &amp;lt;&amp;lt; (0x07 &amp;amp;
shift_distance[i]))&lt;/code&gt;, with this resulting value coerced to the &lt;code&gt;unsigned char&lt;/code&gt; type. The behavior of the &lt;code&gt;vec_srv&lt;/code&gt; is as if there existed a temporary array of 17 unsigned characters &lt;code&gt;srv_array&lt;/code&gt; within which element 0 equals zero and elements 1 through 16 equal the elements 0 through 15 of the &lt;code&gt;src&lt;/code&gt; array. The result returned from the &lt;code&gt;vec_srv&lt;/code&gt; function is a &lt;code&gt;__vector&lt;/code&gt; of 16 unsigned characters within which element &lt;code&gt;i&lt;/code&gt; is computed using the C expression &lt;code&gt;0xff &amp;amp; (*((unsigned short *)(srv_array + i)) &amp;gt;&amp;gt;
(0x07 &amp;amp; shift_distance[i]))&lt;/code&gt;, with this resulting value coerced to the &lt;code&gt;unsigned char&lt;/code&gt; type.</source>
          <target state="translated">&lt;code&gt;vec_slv&lt;/code&gt; 및 &lt;code&gt;vec_srv&lt;/code&gt; 기능은 자신의 모든 바이트에서 작동 &lt;code&gt;src&lt;/code&gt; 와 &lt;code&gt;shift_distance&lt;/code&gt; 병렬로 인수. &lt;code&gt;vec_slv&lt;/code&gt; 의 동작은 요소 0에서 15가 &lt;code&gt;src&lt;/code&gt; 배열 의 항목 과 동일하고 요소 16이 0 인 17 개의 부호없는 문자 &lt;code&gt;slv_array&lt;/code&gt; 의 임시 배열이 존재하는 것처럼 &lt;code&gt;vec_slv&lt;/code&gt; 함수 에서 반환 된 결과 는 &lt;code&gt;__vector&lt;/code&gt; 입니다. C 표현식 &lt;code&gt;0xff &amp;amp; (*((unsigned short *)(slv_array + i)) &amp;lt;&amp;lt; (0x07 &amp;amp; shift_distance[i]))&lt;/code&gt; 사용하여 요소 &lt;code&gt;i&lt;/code&gt; 가 계산 되는 16 개의 부호없는 문자 중이 결과 값을 &lt;code&gt;unsigned char&lt;/code&gt; 유형으로 강제 변환 합니다. &lt;code&gt;vec_srv&lt;/code&gt; 의 동작은 요소 0이 0이고 요소 1-16이 &lt;code&gt;src&lt;/code&gt; 배열 의 요소 &lt;code&gt;srv_array&lt;/code&gt; 와 같은 17 개의 부호없는 문자 srv_array 의 임시 배열이있는 것처럼 보입니다 . &lt;code&gt;vec_srv&lt;/code&gt; 함수 에서 반환 된 결과 는 16 개의 부호없는 문자로 구성된 &lt;code&gt;__vector&lt;/code&gt; 이며 요소 &lt;code&gt;i&lt;/code&gt; 는 C 표현식 &lt;code&gt;0xff &amp;amp; (*((unsigned short *)(srv_array + i)) &amp;gt;&amp;gt; (0x07 &amp;amp; shift_distance[i]))&lt;/code&gt; ,이 결과 값은 &lt;code&gt;unsigned char&lt;/code&gt; 유형으로 강제 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="6a1b591d1d5bc9da82b7b03dcf8d2e3d88da8bb6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vec_test_data_class&lt;/code&gt; built-in function returns a vector representing the results of testing the &lt;code&gt;source&lt;/code&gt; vector for the condition selected by the &lt;code&gt;condition&lt;/code&gt; argument. The &lt;code&gt;condition&lt;/code&gt; argument must be a compile-time constant integer with value not exceeding 127. The &lt;code&gt;condition&lt;/code&gt; argument is encoded as a bitmask with each bit enabling the testing of a different condition, as characterized by the following:</source>
          <target state="translated">&lt;code&gt;vec_test_data_class&lt;/code&gt; 는 내장 함수가 반환 테스트의 결과를 나타내는 벡터 &lt;code&gt;source&lt;/code&gt; 에 의해 선택된 조건에 대한 벡터 &lt;code&gt;condition&lt;/code&gt; 인수를. &lt;code&gt;condition&lt;/code&gt; 인자 값 (127) 이하로 컴파일 시간 상수 정수이어야 &lt;code&gt;condition&lt;/code&gt; 은 다음을 특징으로 인수를, 다른 조건의 테스트를 가능하게 각 비트와 비트 마스크로서 부호화된다 :</target>
        </trans-unit>
        <trans-unit id="991ae395a453d861dfb8c7b24fc2cbc3ce4b3da0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vec_xl_len&lt;/code&gt; and &lt;code&gt;vec_xst_len&lt;/code&gt; functions require a 64-bit environment supporting ISA 3.0 or later. The &lt;code&gt;vec_xl_len&lt;/code&gt; function loads a variable length vector from memory. The &lt;code&gt;vec_xst_len&lt;/code&gt; function stores a variable length vector to memory. With both the &lt;code&gt;vec_xl_len&lt;/code&gt; and &lt;code&gt;vec_xst_len&lt;/code&gt; functions, the &lt;code&gt;addr&lt;/code&gt; argument represents the memory address to or from which data will be transferred, and the &lt;code&gt;len&lt;/code&gt; argument represents the number of bytes to be transferred, as computed by the C expression &lt;code&gt;min((len &amp;amp; 0xff), 16)&lt;/code&gt;. If this expression&amp;rsquo;s value is not a multiple of the vector element&amp;rsquo;s size, the behavior of this function is undefined. In the case that the underlying computer is configured to run in big-endian mode, the data transfer moves bytes 0 to &lt;code&gt;(len - 1)&lt;/code&gt; of the corresponding vector. In little-endian mode, the data transfer moves bytes &lt;code&gt;(16 - len)&lt;/code&gt; to &lt;code&gt;15&lt;/code&gt; of the corresponding vector. For the load function, any bytes of the result vector that are not loaded from memory are set to zero. The value of the &lt;code&gt;addr&lt;/code&gt; argument need not be aligned on a multiple of the vector&amp;rsquo;s element size.</source>
          <target state="translated">&lt;code&gt;vec_xl_len&lt;/code&gt; 및 &lt;code&gt;vec_xst_len&lt;/code&gt; 기능 이상 3.0 ISA를 지원하는 64 비트 환경을 필요로한다. &lt;code&gt;vec_xl_len&lt;/code&gt; 기능로드 메모리에서 가변 길이 벡터. &lt;code&gt;vec_xst_len&lt;/code&gt; 함수 저장 메모리에 가변 길이 벡터. 모두 함께 &lt;code&gt;vec_xl_len&lt;/code&gt; 및 &lt;code&gt;vec_xst_len&lt;/code&gt; 함수는 &lt;code&gt;addr&lt;/code&gt; 인자 데이터가 전송 될 또는로부터 메모리 어드레스를 나타내고, &lt;code&gt;len&lt;/code&gt; 인수는 C 식에 의해 계산 된 바와 같이, 전송 될 바이트의 수를 나타내는 &lt;code&gt;min((len &amp;amp; 0xff), 16)&lt;/code&gt; . 이 표현식의 값이 벡터 요소 크기의 배수가 아닌 경우이 함수의 동작은 정의되지 않습니다. 기본 컴퓨터가 빅 엔디안 모드에서 실행되도록 구성된 경우 데이터 전송은 바이트 0을 해당 벡터의 &lt;code&gt;(len - 1)&lt;/code&gt; 로 이동합니다 . 리틀 엔디안 모드에서 데이터 전송은 바이트 &lt;code&gt;(16 - len)&lt;/code&gt; 를 해당 벡터의 &lt;code&gt;15&lt;/code&gt; 로 이동합니다 . 로드 함수의 경우 메모리에서로드되지 않은 결과 벡터의 바이트는 0으로 설정됩니다. &lt;code&gt;addr&lt;/code&gt; 인수 의 값은 벡터의 요소 크기의 배수에 정렬 될 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="32f436c7a33759092d0385b9b27659581036ece3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vec_xlx&lt;/code&gt; and &lt;code&gt;vec_xrx&lt;/code&gt; functions extract the single element selected by the &lt;code&gt;index&lt;/code&gt; argument from the vector represented by the &lt;code&gt;data&lt;/code&gt; argument. The &lt;code&gt;index&lt;/code&gt; argument always specifies a byte offset, regardless of the size of the vector element. With &lt;code&gt;vec_xlx&lt;/code&gt;, &lt;code&gt;index&lt;/code&gt; is the offset of the first byte of the element to be extracted. With &lt;code&gt;vec_xrx&lt;/code&gt;, &lt;code&gt;index&lt;/code&gt; represents the last byte of the element to be extracted, measured from the right end of the vector. In other words, the last byte of the element to be extracted is found at position &lt;code&gt;(15 - index)&lt;/code&gt;. There is no requirement that &lt;code&gt;index&lt;/code&gt; be a multiple of the vector element size. However, if the size of the vector element added to &lt;code&gt;index&lt;/code&gt; is greater than 15, the content of the returned value is undefined.</source>
          <target state="translated">&lt;code&gt;vec_xlx&lt;/code&gt; 및 &lt;code&gt;vec_xrx&lt;/code&gt; 기능에 의해 선택된 하나의 원소 추출 &lt;code&gt;index&lt;/code&gt; 에 의해 표현되는 벡터로부터 인자 &lt;code&gt;data&lt;/code&gt; 인수. &lt;code&gt;index&lt;/code&gt; 인수에 관계없이 항상 벡터 요소의 크기, 바이트 오프셋을 지정한다. 함께 &lt;code&gt;vec_xlx&lt;/code&gt; , &lt;code&gt;index&lt;/code&gt; 추출 할 수있는 소자의 첫번째 바이트 오프셋된다. 함께 &lt;code&gt;vec_xrx&lt;/code&gt; , &lt;code&gt;index&lt;/code&gt; 벡터의 우측 단부로부터 측정 추출하는 요소의 마지막 바이트를 나타낸다. 다시 말해, 추출 할 요소의 마지막 바이트는 위치 &lt;code&gt;(15 - index)&lt;/code&gt; 있습니다. &lt;code&gt;index&lt;/code&gt; 이 필요하지 않습니다벡터 요소 크기의 배수 여야합니다. 그러나 &lt;code&gt;index&lt;/code&gt; 에 추가 된 벡터 요소의 크기 가 15보다 크면 반환 된 값의 내용이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1ebaac2fb10fbefef121de501464e717714b8367" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vector_size&lt;/code&gt; attribute is only applicable to integral and floating scalars, although arrays, pointers, and function return values are allowed in conjunction with this construct. Only sizes that are positive power-of-two multiples of the base type size are currently allowed.</source>
          <target state="translated">&lt;code&gt;vector_size&lt;/code&gt; 의 배열, 포인터, 함수 반환 값이 작 제물과 함께 허용되지만 속성은 정수와 부동 스칼라에만 적용된다. 기본 유형 크기의 양의 제곱의 배수 인 크기 만 현재 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="837b5049d27cb5d3caabb0997e45a1cbb234446d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vliw&lt;/code&gt; attribute tells the compiler to emit instructions in VLIW mode instead of core mode. Note that this attribute is not allowed unless a VLIW coprocessor has been configured and enabled through command-line options.</source>
          <target state="translated">&lt;code&gt;vliw&lt;/code&gt; 속성은 VLIW 모드 대신 핵심 모드에서 발광 지침 컴파일러를 알려줍니다. VLIW 코 프로세서가 명령 행 옵션을 통해 구성되고 사용 가능하지 않으면이 속성이 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="42d2812dccb310da3b37a59c6a8e7a142b29dac3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;warn_unused_result&lt;/code&gt; attribute causes a warning to be emitted if a caller of the function with this attribute does not use its return value. This is useful for functions where not checking the result is either a security problem or always a bug, such as &lt;code&gt;realloc&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;warn_unused_result&lt;/code&gt; 의 속성은이 속성과 함수의 호출자가 반환 값을 사용하지 않을 경우 경고가 방출되도록한다. 결과를 확인하지 않는 것이 보안 문제이거나 항상 &lt;code&gt;realloc&lt;/code&gt; 과 같은 버그 인 함수에 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="0d86cabe39f6b2eca4b3f76217c522746181a80f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;weak&lt;/code&gt; attribute causes a declaration of an external symbol to be emitted as a weak symbol rather than a global. This is primarily useful in defining library functions that can be overridden in user code, though it can also be used with non-function declarations. The overriding symbol must have the same type as the weak symbol. In addition, if it designates a variable it must also have the same size and alignment as the weak symbol. Weak symbols are supported for ELF targets, and also for a.out targets when using the GNU assembler and linker.</source>
          <target state="translated">&lt;code&gt;weak&lt;/code&gt; 특성은 오히려 글로벌보다 약한 심볼로 출사되는 외부 심볼의 선언을 야기한다. 이는 주로 사용자 코드에서 재정의 할 수있는 라이브러리 함수를 정의하는 데 유용하지만 비 함수 선언과 함께 사용할 수도 있습니다. 대체 기호는 약한 기호와 동일한 유형을 가져야합니다. 또한 변수를 지정하는 경우 약한 기호와 동일한 크기와 정렬을 가져야합니다. ELF 타겟과 GNU 어셈블러 및 링커를 사용할 때 a.out 타겟에 대해 약한 기호가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="d64e3cfe5255e69eafb7d485c8c088e61fa4d8a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;weak&lt;/code&gt; attribute causes the declaration to be emitted as a weak symbol rather than a global. This is primarily useful in defining library functions that can be overridden in user code, though it can also be used with non-function declarations. Weak symbols are supported for ELF targets, and also for a.out targets when using the GNU assembler and linker.</source>
          <target state="translated">&lt;code&gt;weak&lt;/code&gt; 특성은 오히려 글로벌보다 약한 심볼로 방출 될 선언시킨다. 이것은 함수 코드가 아닌 선언에도 사용될 수 있지만 사용자 코드에서 재정의 할 수있는 라이브러리 함수를 정의 할 때 주로 유용합니다. 약한 기호는 ELF 대상과 GNU 어셈블러 및 링커를 사용할 때 a.out 대상에도 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="4250f8084c2d37890c56691349397dd644e93eba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;weak&lt;/code&gt; attribute is described in &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;weak&lt;/code&gt; 특성에서 설명하는 &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;일반적인 기능 속성&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0fd7b693a88b68899809d3dfabebee19f1a4688b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;weakref&lt;/code&gt; attribute marks a declaration as a weak reference. Without arguments, it should be accompanied by an &lt;code&gt;alias&lt;/code&gt; attribute naming the target symbol. Alternatively, &lt;var&gt;target&lt;/var&gt; may be given as an argument to &lt;code&gt;weakref&lt;/code&gt; itself, naming the target definition of the alias. The &lt;var&gt;target&lt;/var&gt; must have the same type as the declaration. In addition, if it designates a variable it must also have the same size and alignment as the declaration. In either form of the declaration &lt;code&gt;weakref&lt;/code&gt; implicitly marks the declared symbol as &lt;code&gt;weak&lt;/code&gt;. Without a &lt;var&gt;target&lt;/var&gt; given as an argument to &lt;code&gt;weakref&lt;/code&gt; or to &lt;code&gt;alias&lt;/code&gt;, &lt;code&gt;weakref&lt;/code&gt; is equivalent to &lt;code&gt;weak&lt;/code&gt; (in that case the declaration may be &lt;code&gt;extern&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;weakref&lt;/code&gt; 속성 표시 약한 참조로 선언. 인수가 없으면 대상 기호의 이름을 지정 하는 &lt;code&gt;alias&lt;/code&gt; 속성 이 동반되어야합니다 . 또는 &lt;var&gt;target&lt;/var&gt; 은 별칭의 대상 정의 이름을 지정하여 &lt;code&gt;weakref&lt;/code&gt; 자체에 대한 인수로 제공 될 수 있습니다 . &lt;var&gt;target&lt;/var&gt; 선언과 같은 유형이 있어야합니다. 또한 변수를 지정하는 경우 선언과 크기 및 정렬도 동일해야합니다. 어떤 형태의 선언에서든 &lt;code&gt;weakref&lt;/code&gt; 는 선언 된 기호를 &lt;code&gt;weak&lt;/code&gt; 것으로 암시 적으로 표시합니다 . 없이 &lt;var&gt;target&lt;/var&gt; 에 인수로 주어진 &lt;code&gt;weakref&lt;/code&gt; 하거나 &lt;code&gt;alias&lt;/code&gt; , &lt;code&gt;weakref&lt;/code&gt; 는 &lt;code&gt;weak&lt;/code&gt; 와 동일합니다 (이 경우 선언은 &lt;code&gt;extern&lt;/code&gt; 일 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="362aefd1f311374abf7ac9d8d10e9633ea762db5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;weakref&lt;/code&gt; attribute marks a declaration as a weak reference. Without arguments, it should be accompanied by an &lt;code&gt;alias&lt;/code&gt; attribute naming the target symbol. Optionally, the &lt;var&gt;target&lt;/var&gt; may be given as an argument to &lt;code&gt;weakref&lt;/code&gt; itself. In either case, &lt;code&gt;weakref&lt;/code&gt; implicitly marks the declaration as &lt;code&gt;weak&lt;/code&gt;. Without a &lt;var&gt;target&lt;/var&gt;, given as an argument to &lt;code&gt;weakref&lt;/code&gt; or to &lt;code&gt;alias&lt;/code&gt;, &lt;code&gt;weakref&lt;/code&gt; is equivalent to &lt;code&gt;weak&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;weakref&lt;/code&gt; 속성 표시 약한 참조로 선언. 인수가 없으면 대상 기호의 이름을 지정 하는 &lt;code&gt;alias&lt;/code&gt; 속성 이 동반되어야합니다 . 선택적으로 &lt;var&gt;target&lt;/var&gt; 은 &lt;code&gt;weakref&lt;/code&gt; 자체에 대한 인수로 제공 될 수 있습니다 . 두 경우 모두 &lt;code&gt;weakref&lt;/code&gt; 는 암시 적으로 선언을 &lt;code&gt;weak&lt;/code&gt; 로 표시합니다 . 없이 &lt;var&gt;target&lt;/var&gt; 인수로 주어진 &lt;code&gt;weakref&lt;/code&gt; 거나 &lt;code&gt;alias&lt;/code&gt; , &lt;code&gt;weakref&lt;/code&gt; 는 동등 &lt;code&gt;weak&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31c2b38693187358ef61afd2bbcd821fce4cea47" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;write_only&lt;/code&gt; access mode applies to arguments of pointer types without the &lt;code&gt;const&lt;/code&gt; qualifier. It specifies that the pointer to which it applies is used to write to the referenced object but not read from it. The object referenced by the pointer need not be initialized. An example of the use of the &lt;code&gt;write_only&lt;/code&gt; access mode is the first argument to the &lt;code&gt;strcpy&lt;/code&gt; function, or the first two arguments to the &lt;code&gt;fgets&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;write_only&lt;/code&gt; 액세스 모드는 않고 포인터 타입의 인수를 적용 &lt;code&gt;const&lt;/code&gt; 를 규정. 적용되는 포인터가 참조 된 개체에 쓰는 데 사용되지만 읽기는 사용되지 않도록 지정합니다. 포인터가 참조하는 개체는 초기화 할 필요가 없습니다. &lt;code&gt;write_only&lt;/code&gt; 액세스 모드 사용의 예는 &lt;code&gt;strcpy&lt;/code&gt; 함수에 대한 첫 번째 인수 또는 &lt;code&gt;fgets&lt;/code&gt; 함수에 대한 처음 두 인수 입니다.</target>
        </trans-unit>
        <trans-unit id="a5580c84e305bbd75698ac25971a0df43ef6cc5f" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;call_exp&lt;/var&gt; expression must be a function call, and the &lt;var&gt;pointer_exp&lt;/var&gt; expression must be a pointer. The &lt;var&gt;pointer_exp&lt;/var&gt; is passed to the function call in the target&amp;rsquo;s static chain location. The result of builtin is the result of the function call.</source>
          <target state="translated">&lt;var&gt;call_exp&lt;/var&gt; 의 표현식은 함수 호출이어야하며 &lt;var&gt;pointer_exp&lt;/var&gt; 의 표현은 포인터이어야합니다. &lt;var&gt;pointer_exp&lt;/var&gt; 는 대상의 정적 체인 위치의 함수 호출에 전달된다. 내장의 결과는 함수 호출의 결과입니다.</target>
        </trans-unit>
        <trans-unit id="47808f5c44d74211446dd3107371068aa638bc2f" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;information&lt;/var&gt; is human readable, but designed to be simple enough for machine parsing too.</source>
          <target state="translated">&lt;var&gt;information&lt;/var&gt; 사람이 읽을 수 있지만 기계가 너무 구문 분석에 대한 간단한 충분하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="2e82b6b86f048807c7ae6131df8cf24c8fb6345a" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;level&lt;/var&gt; argument must be a constant integer.</source>
          <target state="translated">&lt;var&gt;level&lt;/var&gt; 인수는 상수 정수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="2457707eff68e08cd199be4e3c699bc3aefc86a0" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;level&lt;/var&gt; argument should be one of the following:</source>
          <target state="translated">&lt;var&gt;level&lt;/var&gt; 인수는 다음 중 하나 여야합니다 :</target>
        </trans-unit>
        <trans-unit id="9e08ee76b1da2a0a7eab6aae9dc5ab5a92291dc1" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;level&lt;/var&gt; can be one of:</source>
          <target state="translated">&lt;var&gt;level&lt;/var&gt; 중 하나가 될 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="07133152e9a0d85287182cf9221be477141dff40" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;oldname&lt;/var&gt; used by &lt;code&gt;#pragma redefine_extname&lt;/code&gt; is always the C-language name.</source>
          <target state="translated">&lt;var&gt;oldname&lt;/var&gt; 에 의해 사용 &lt;code&gt;#pragma redefine_extname&lt;/code&gt; 항상 C 언어 이름입니다.</target>
        </trans-unit>
        <trans-unit id="f9388ad5137ed5dfa5588bcfa11755abc3ce7181" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;options&lt;/var&gt; can be divided into three groups:</source>
          <target state="translated">&lt;var&gt;options&lt;/var&gt; 세 그룹으로 나눌 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="c19aabaea762edf72b5cc0612746c317d8ff2de8" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;os&lt;/var&gt; argument is the object size &lt;var&gt;s&lt;/var&gt; points to, like in the other built-in functions. There is a small difference in the behavior though, if &lt;var&gt;os&lt;/var&gt; is &lt;code&gt;(size_t) -1&lt;/code&gt;, the built-in functions are optimized into the non-checking functions only if &lt;var&gt;flag&lt;/var&gt; is 0, otherwise the checking function is called with &lt;var&gt;os&lt;/var&gt; argument set to &lt;code&gt;(size_t) -1&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;os&lt;/var&gt; 인수가 객체의 크기 &lt;var&gt;s&lt;/var&gt; 에서 같은 지점에 다른 내장 함수. &lt;var&gt;os&lt;/var&gt; 가 &lt;code&gt;(size_t) -1&lt;/code&gt; 인 경우 동작에 약간의 차이가 있습니다. &lt;var&gt;flag&lt;/var&gt; 가 0 인 경우 에만 내장 함수가 비 검사 함수로 최적화됩니다. 그렇지 않으면 검사 함수는 &lt;var&gt;os&lt;/var&gt; 인수가 &lt;code&gt;(size_t) -1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99051c6bb8529049d31b5150a695460a96f0eb50" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;string&lt;/var&gt; can either be a number (decimal, octal or hex) or an arbitrary string (in which case it&amp;rsquo;s converted to a number by computing CRC32).</source>
          <target state="translated">&lt;var&gt;string&lt;/var&gt; 어느 번호 (소수점 이하, 진수 또는 16 진수) 또는 임의의 문자열 (이 경우,이 CRC32를 계산하여 숫자로 변환 것)을 할 수있다.</target>
        </trans-unit>
        <trans-unit id="e2a9a665b951d617734d12093bb7933ae309b7f0" translate="yes" xml:space="preserve">
          <source>The &lt;var&gt;string&lt;/var&gt; should be different for every file you compile.</source>
          <target state="translated">&lt;var&gt;string&lt;/var&gt; 컴파일 모든 파일에 대해 달라야합니다.</target>
        </trans-unit>
        <trans-unit id="e5cf6b74b693d7f4748254b48ea16e3b5621f730" translate="yes" xml:space="preserve">
          <source>The ABI tags apply to a name, so all instantiations and specializations of a template have the same tags. The attribute will be ignored if applied to an explicit specialization or instantiation.</source>
          <target state="translated">ABI 태그는 이름에 적용되므로 템플릿의 모든 인스턴스화 및 전문화에는 동일한 태그가 있습니다. 명시적인 특수화 또는 인스턴스화에 적용된 경우이 속성은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="d6e578589905c0491635616be2b8a8085308fc15" translate="yes" xml:space="preserve">
          <source>The AIX calling convention was extended but not initially documented to handle an obscure K&amp;amp;R C case of calling a function that takes the address of its arguments with fewer arguments than declared. IBM XL compilers access floating-point arguments that do not fit in the RSA from the stack when a subroutine is compiled without optimization. Because always storing floating-point arguments on the stack is inefficient and rarely needed, this option is not enabled by default and only is necessary when calling subroutines compiled by IBM XL compilers without optimization.</source>
          <target state="translated">AIX 호출 규칙이 확장되었지만 선언 된 것보다 적은 수의 인수로 인수의 주소를 취하는 함수를 호출하는 모호한 K &amp;amp; R C 사례를 처리하기 위해 처음에는 문서화되지 않았습니다. IBM XL 컴파일러는 서브 루틴이 최적화없이 컴파일 될 때 스택에서 RSA에 맞지 않는 부동 소수점 인수에 액세스합니다. 스택에 항상 부동 소수점 인수를 저장하는 것이 비효율적이고 거의 필요하지 않기 때문에이 옵션은 기본적으로 사용되지 않으며 최적화없이 IBM XL 컴파일러에 의해 컴파일 된 서브 루틴을 호출 할 때만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="0286e5ab4aaa67941386b2ad2370f9a09da6cea5" translate="yes" xml:space="preserve">
          <source>The ARM attribute &lt;code&gt;Tag_CPU_unaligned_access&lt;/code&gt; is set in the generated object file to either true or false, depending upon the setting of this option. If unaligned access is enabled then the preprocessor symbol &lt;code&gt;__ARM_FEATURE_UNALIGNED&lt;/code&gt; is also defined.</source>
          <target state="translated">ARM 속성 &lt;code&gt;Tag_CPU_unaligned_access&lt;/code&gt; 는이 옵션의 설정에 따라 생성 된 오브젝트 파일에서 true 또는 false로 설정됩니다. 정렬되지 않은 액세스가 가능하면 전 처리기 기호 &lt;code&gt;__ARM_FEATURE_UNALIGNED&lt;/code&gt; 도 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="38b655dda41c627fb0c53750526171175cc9f72b" translate="yes" xml:space="preserve">
          <source>The ARM target defines pragmas for controlling the default addition of &lt;code&gt;long_call&lt;/code&gt; and &lt;code&gt;short_call&lt;/code&gt; attributes to functions. See &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;, for information about the effects of these attributes.</source>
          <target state="translated">ARM 대상은 함수 에 &lt;code&gt;long_call&lt;/code&gt; 및 &lt;code&gt;short_call&lt;/code&gt; 속성 의 기본 추가를 제어하기위한 pragma를 정의 합니다. 이러한 속성의 영향에 대한 정보는 &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;함수 속성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="180b9a433ddcfbb50e74358632373510b9ae0866" translate="yes" xml:space="preserve">
          <source>The ARM target provides hardware support for conversions between &lt;code&gt;__fp16&lt;/code&gt; and &lt;code&gt;float&lt;/code&gt; values as an extension to VFP and NEON (Advanced SIMD), and from ARMv8-A provides hardware support for conversions between &lt;code&gt;__fp16&lt;/code&gt; and &lt;code&gt;double&lt;/code&gt; values. GCC generates code using these hardware instructions if you compile with options to select an FPU that provides them; for example,</source>
          <target state="translated">ARM 대상은 VFP 및 NEON (Advanced SIMD)의 확장으로 &lt;code&gt;__fp16&lt;/code&gt; 과 &lt;code&gt;float&lt;/code&gt; 값 간의 변환을 위한 하드웨어 지원을 제공 하고 ARMv8-A에서 &lt;code&gt;__fp16&lt;/code&gt; 과 &lt;code&gt;double&lt;/code&gt; 값 간의 변환을 위한 하드웨어 지원을 제공 합니다. GCC는 옵션으로 컴파일하여 FPU를 제공하는 FPU를 선택하면 이러한 하드웨어 명령어를 사용하여 코드를 생성합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="74677651175ff4a21af34df2adc4b16af0c62864" translate="yes" xml:space="preserve">
          <source>The ARM-state integer division instructions.</source>
          <target state="translated">ARM 상태 정수 나누기 명령어입니다.</target>
        </trans-unit>
        <trans-unit id="25504eb2b5db6b1309f7e3ea71e7847bbe69ef9e" translate="yes" xml:space="preserve">
          <source>The ARMv8-A Advanced SIMD and floating-point instructions.</source>
          <target state="translated">ARMv8-A 고급 SIMD 및 부동 소수점 명령어</target>
        </trans-unit>
        <trans-unit id="7f8a18de7f60ebb2b7344b3e4891cc4342f1a12d" translate="yes" xml:space="preserve">
          <source>The ARMv8.1-A Advanced SIMD and floating-point instructions.</source>
          <target state="translated">ARMv8.1-A 고급 SIMD 및 부동 소수점 명령어</target>
        </trans-unit>
        <trans-unit id="33734522bf6eef68d24bf96c977fe3c147340232" translate="yes" xml:space="preserve">
          <source>The ARMv8.3-A Advanced SIMD and floating-point instructions as well as the Dot Product extension.</source>
          <target state="translated">Dot Product 확장뿐만 아니라 ARMv8.3-A Advanced SIMD 및 부동 소수점 명령어.</target>
        </trans-unit>
        <trans-unit id="2e1c8ef545821a2ae5bcfc55a26fd3b81629816e" translate="yes" xml:space="preserve">
          <source>The AT&amp;amp;T C++ translator, Cfront, solved the template instantiation problem by creating the notion of a template repository, an automatically maintained place where template instances are stored. A more modern version of the repository works as follows: As individual object files are built, the compiler places any template definitions and instantiations encountered in the repository. At link time, the link wrapper adds in the objects in the repository and compiles any needed instances that were not previously emitted. The advantages of this model are more optimal compilation speed and the ability to use the system linker; to implement the Borland model a compiler vendor also needs to replace the linker. The disadvantages are vastly increased complexity, and thus potential for error; for some code this can be just as transparent, but in practice it can been very difficult to build multiple programs in one directory and one program in multiple directories. Code written for this model tends to separate definitions of non-inline member templates into a separate file, which should be compiled separately.</source>
          <target state="translated">AT &amp;amp; T C ++ 변환기 인 Cfront는 템플리트 인스턴스가 저장되는 자동 유지 보수 위치 인 템플리트 저장소의 개념을 작성하여 템플리트 인스턴스화 문제점을 해결했습니다. 최신 버전의 저장소는 다음과 같이 작동합니다. 개별 오브젝트 파일이 빌드되면 컴파일러는 저장소에서 발견 된 템플리트 정의 및 인스턴스를 배치합니다. 링크 시간에 링크 랩퍼는 저장소의 오브젝트를 추가하고 이전에 생성되지 않은 필요한 인스턴스를 컴파일합니다. 이 모델의 장점은보다 최적의 컴파일 속도와 시스템 링커 사용 기능입니다. Borland 모델을 구현하려면 컴파일러 공급 업체도 링커를 교체해야합니다. 단점은 복잡성이 크게 증가하여 오류 가능성이 있다는 것입니다. 일부 코드의 경우 이것은 투명 할 수 있습니다.그러나 실제로는 하나의 디렉토리에 여러 프로그램을 작성하고 여러 디렉토리에 하나의 프로그램을 작성하는 것은 매우 어려울 수 있습니다. 이 모델을 위해 작성된 코드는 인라인이 아닌 멤버 템플릿의 정의를 별도의 파일로 분리하는 경향이 있으며, 별도로 컴파일해야합니다.</target>
        </trans-unit>
        <trans-unit id="b2f96e374cb7c3be8b863693d2e8387693d91334" translate="yes" xml:space="preserve">
          <source>The AVR hardware globally disables interrupts when an interrupt is executed. Interrupt handler functions defined with the &lt;code&gt;signal&lt;/code&gt; attribute do not re-enable interrupts. It is save to enable interrupts in a &lt;code&gt;signal&lt;/code&gt; handler. This &amp;ldquo;save&amp;rdquo; only applies to the code generated by the compiler and not to the IRQ layout of the application which is responsibility of the application.</source>
          <target state="translated">인터럽트가 실행될 때 AVR 하드웨어는 전체적으로 인터럽트를 비활성화합니다. &lt;code&gt;signal&lt;/code&gt; 속성으로 정의 된 인터럽트 핸들러 함수는 인터럽트를 다시 활성화하지 않습니다. &lt;code&gt;signal&lt;/code&gt; 처리기 에서 인터럽트를 활성화하기 위해 저장됩니다 . 이 &quot;저장&quot;은 컴파일러가 생성 한 코드에만 적용되며 응용 프로그램의 책임 인 응용 프로그램의 IRQ 레이아웃에는 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="819e5dd1ebff38014ce3cc47fe71028f5e880298" translate="yes" xml:space="preserve">
          <source>The Advanced SIMD (Neon) v1 and the VFPv3 floating-point instructions, with the half-precision floating-point conversion operations.</source>
          <target state="translated">반 정밀도 부동 소수점 변환 연산이 포함 된 Advanced SIMD (Neon) v1 및 VFPv3 부동 소수점 명령어.</target>
        </trans-unit>
        <trans-unit id="04a974f086b15b184d16af3fa03c2b5403d55b20" translate="yes" xml:space="preserve">
          <source>The Advanced SIMD (Neon) v1 and the VFPv3 floating-point instructions. The extension &amp;lsquo;</source>
          <target state="translated">Advanced SIMD (Neon) v1 및 VFPv3 부동 소수점 명령어. 확장 '</target>
        </trans-unit>
        <trans-unit id="3b1828fb03b38714492461b5c83b7a35d9811c07" translate="yes" xml:space="preserve">
          <source>The Advanced SIMD (Neon) v1 and the VFPv3 floating-point instructions. The extensions &amp;lsquo;</source>
          <target state="translated">Advanced SIMD (Neon) v1 및 VFPv3 부동 소수점 명령어. 확장 '</target>
        </trans-unit>
        <trans-unit id="25f15c2fd3a5e4f09bf2de0e8dd88934f187e30c" translate="yes" xml:space="preserve">
          <source>The Advanced SIMD (Neon) v2 and the VFPv4 floating-point instructions.</source>
          <target state="translated">Advanced SIMD (Neon) v2 및 VFPv4 부동 소수점 명령어.</target>
        </trans-unit>
        <trans-unit id="8fb627100c24fb77ea39c11992a8aa490fe9b6bf" translate="yes" xml:space="preserve">
          <source>The Advanced SIMD (Neon) v2 and the VFPv4 floating-point instructions. The extension &amp;lsquo;</source>
          <target state="translated">Advanced SIMD (Neon) v2 및 VFPv4 부동 소수점 명령어. 확장 '</target>
        </trans-unit>
        <trans-unit id="a0b4e865040163440dd355cb51993ec44628f3a4" translate="yes" xml:space="preserve">
          <source>The Alpha architecture implements floating-point hardware optimized for maximum performance. It is mostly compliant with the IEEE floating-point standard. However, for full compliance, software assistance is required. This option generates code fully IEEE-compliant code &lt;em&gt;except&lt;/em&gt; that the &lt;var&gt;inexact-flag&lt;/var&gt; is not maintained (see below). If this option is turned on, the preprocessor macro &lt;code&gt;_IEEE_FP&lt;/code&gt; is defined during compilation. The resulting code is less efficient but is able to correctly support denormalized numbers and exceptional IEEE values such as not-a-number and plus/minus infinity. Other Alpha compilers call this option</source>
          <target state="translated">Alpha 아키텍처는 최대 성능을 위해 최적화 된 부동 소수점 하드웨어를 구현합니다. 대부분 IEEE 부동 소수점 표준을 준수합니다. 그러나 완전한 준수를 위해서는 소프트웨어 지원이 필요합니다. 이 옵션 은 &lt;var&gt;inexact-flag&lt;/var&gt; 가 유지되지 않는 &lt;em&gt;것을 제외하고&lt;/em&gt; 는 코드를 IEEE 호환 코드로 생성합니다 (아래 참조). 이 옵션이 켜져 있으면 전 처리기 매크로 &lt;code&gt;_IEEE_FP&lt;/code&gt; 가 컴파일 중에 정의됩니다. 결과 코드는 비효율적이지만 비정규 화 된 숫자와 비 숫자 및 플러스 / 마이너스 무한대와 같은 예외적 인 IEEE 값을 올바르게 지원할 수 있습니다. 다른 알파 컴파일러는이 옵션을 호출</target>
        </trans-unit>
        <trans-unit id="a224b29d0d210a4ad06df789e64da22f568f6054" translate="yes" xml:space="preserve">
          <source>The AltiVec built-in functions described in this section are available on the PowerPC family of processors starting with ISA 2.06 or later. These are normally enabled by adding</source>
          <target state="translated">이 섹션에서 설명하는 AltiVec 내장 기능은 ISA 2.06 이상부터 PowerPC 프로세서 제품군에서 사용할 수 있습니다. 이들은 일반적으로 추가하여 활성화됩니다</target>
        </trans-unit>
        <trans-unit id="224e64a8094f6a857fb86e36e422aa4067f4740c" translate="yes" xml:space="preserve">
          <source>The C and C++ language specifications differ when an object is accessed in a void context:</source>
          <target state="translated">C 및 C ++ 언어 사양은 void 컨텍스트에서 객체에 액세스 할 때 다릅니다.</target>
        </trans-unit>
        <trans-unit id="0ef06715d23eab6e0953d0e3dffa82f688ece5af" translate="yes" xml:space="preserve">
          <source>The C and C++ standards define the order in which expressions in a C/C++ program are evaluated in terms of &lt;em&gt;sequence points&lt;/em&gt;, which represent a partial ordering between the execution of parts of the program: those executed before the sequence point, and those executed after it. These occur after the evaluation of a full expression (one which is not part of a larger expression), after the evaluation of the first operand of a &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;||&lt;/code&gt;, &lt;code&gt;? :&lt;/code&gt; or &lt;code&gt;,&lt;/code&gt; (comma) operator, before a function is called (but after the evaluation of its arguments and the expression denoting the called function), and in certain other places. Other than as expressed by the sequence point rules, the order of evaluation of subexpressions of an expression is not specified. All these rules describe only a partial order rather than a total order, since, for example, if two functions are called within one expression with no sequence point between them, the order in which the functions are called is not specified. However, the standards committee have ruled that function calls do not overlap.</source>
          <target state="translated">C 및 C ++ 표준은 C / C ++ 프로그램의 표현식이 &lt;em&gt;시퀀스 포인트&lt;/em&gt; 로 평가되는 순서를 정의합니다. &lt;em&gt;시퀀스 포인트&lt;/em&gt; 는 프로그램의 일부 실행 사이의 부분적인 순서를 나타냅니다. 그것. 이는 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; , &lt;code&gt;||&lt;/code&gt; 의 첫 번째 피연산자를 평가 한 후 전체 표현식 (더 큰 표현식의 일부가 아닌)을 평가 한 후에 발생합니다. , &lt;code&gt;? :&lt;/code&gt; 또는 &lt;code&gt;,&lt;/code&gt; (쉼표) 연산자, 함수가 호출되기 전 (하지만 인수 및 호출 된 함수를 나타내는 식의 평가 후) 및 기타 특정 위치에서. 시퀀스 포인트 규칙으로 표현 된 것 이외의 표현식의 하위 표현식 평가 순서는 지정되어 있지 않습니다. 예를 들어, 두 함수가 하나의 표현식 내에서 시퀀스 포인트없이 호출되는 경우 함수가 호출되는 순서는 지정되지 않으므로 이러한 모든 규칙은 전체 순서가 아닌 부분 순서 만 설명합니다. 그러나 표준위원회는 함수 호출이 겹치지 않도록 판결했습니다.</target>
        </trans-unit>
        <trans-unit id="ef19b8344a45aab20d25a471f2eb0b887d44fb1e" translate="yes" xml:space="preserve">
          <source>The C++ ABI requires multiple entry points for constructors and destructors: one for a base subobject, one for a complete object, and one for a virtual destructor that calls operator delete afterwards. For a hierarchy with virtual bases, the base and complete variants are clones, which means two copies of the function. With this option, the base and complete variants are changed to be thunks that call a common implementation.</source>
          <target state="translated">C ++ ABI에는 생성자 및 소멸자에 대한 여러 진입 점이 필요합니다. 하나는 기본 하위 오브젝트, 하나는 완전한 오브젝트, 다른 하나는 운영자 삭제를 호출하는 가상 소멸자입니다. 가상 기반이있는 계층의 경우 기본 및 전체 변형은 복제본이므로 함수의 두 복사본을 의미합니다. 이 옵션을 사용하면 기본 및 전체 변형이 공통 구현을 호출하는 썽 크로 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="e88e1274e3c31338e664afbec99b09eac3f5a529" translate="yes" xml:space="preserve">
          <source>The C++ front end implements syntactic extensions that allow compile-time determination of various characteristics of a type (or of a pair of types).</source>
          <target state="translated">C ++ 프런트 엔드는 형식 (또는 한 쌍의 형식)의 다양한 특성을 컴파일 타임으로 결정할 수있는 구문 확장을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="ec04375b745b1f1c4ce1f6fa5f903e079a94852c" translate="yes" xml:space="preserve">
          <source>The C++ language was further revised in 2017 and ISO/IEC 14882:2017 was published. This is referred to as C++17, and before publication was often referred to as C++1z. GCC supports all the changes in the new specification. For further details see &lt;a href=&quot;https://gcc.gnu.org/projects/cxx-status.html#cxx1z&quot;&gt;https://gcc.gnu.org/projects/cxx-status.html#cxx1z&lt;/a&gt;. Use the option</source>
          <target state="translated">C ++ 언어는 2017 년에 추가로 개정되었으며 ISO / IEC 14882 : 2017이 게시되었습니다. 이를 C ++ 17이라고하며 게시하기 전에 종종 C ++ 1z라고했습니다. GCC는 새로운 사양의 모든 변경 사항을 지원합니다. 자세한 내용은 &lt;a href=&quot;https://gcc.gnu.org/projects/cxx-status.html#cxx1z&quot;&gt;https://gcc.gnu.org/projects/cxx-status.html#cxx1z를&lt;/a&gt; 참조 하십시오 . 옵션을 사용하십시오</target>
        </trans-unit>
        <trans-unit id="bcdb3a64fa68982d2e2c4cbdd5d9be1a69decab7" translate="yes" xml:space="preserve">
          <source>The C++ library used with a C++ compiler includes the Standard C++ Library, with functionality defined in the C++ Standard, plus language runtime support. The runtime support is included in a C++ ABI, but there is no formal ABI for the Standard C++ Library. Two implementations of that library are interoperable if one follows the de-facto ABI of the other and if they are both built with the same compiler, or with compilers that conform to the same ABI for C++ compiler and runtime support.</source>
          <target state="translated">C ++ 컴파일러와 함께 사용되는 C ++ 라이브러리에는 표준 C ++ 라이브러리와 C ++ 표준에 정의 된 기능 및 언어 런타임 지원이 포함됩니다. 런타임 지원은 C ++ ABI에 포함되어 있지만 표준 C ++ 라이브러리에 대한 공식 ABI는 없습니다. 해당 라이브러리의 두 가지 구현은 하나가 다른 ABI의 사실상 ABI를 따르고 동일한 컴파일러로 빌드되거나 C ++ 컴파일러 및 런타임 지원에 대해 동일한 ABI를 준수하는 컴파일러와 호환되는 경우 상호 운용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="b030a2dbb3c8b3c3ceafa77d7dbaf4d97c312843" translate="yes" xml:space="preserve">
          <source>The C++ standard allows an implementation to omit creating a temporary that is only used to initialize another object of the same type. Specifying this option disables that optimization, and forces G++ to call the copy constructor in all cases. This option also causes G++ to call trivial member functions which otherwise would be expanded inline.</source>
          <target state="translated">C ++ 표준은 구현이 동일한 유형의 다른 오브젝트를 초기화하는 데만 사용되는 임시 작성을 생략하도록합니다. 이 옵션을 지정하면 해당 최적화가 비활성화되고 모든 경우에 G ++에서 복사 생성자를 강제로 호출합니다. 이 옵션은 또한 G ++가 사소한 멤버 함수를 호출하도록하며, 그렇지 않으면 인라인으로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="c549c47d787f5172f4a63d73dccb4d86a5de3eaa" translate="yes" xml:space="preserve">
          <source>The C++ standard differs from the C standard in its treatment of volatile objects. It fails to specify what constitutes a volatile access, except to say that C++ should behave in a similar manner to C with respect to volatiles, where possible. However, the different lvalueness of expressions between C and C++ complicate the behavior. G++ behaves the same as GCC for volatile access, See &lt;a href=&quot;c-extensions#C-Extensions&quot;&gt;Volatiles&lt;/a&gt;, for a description of GCC&amp;rsquo;s behavior.</source>
          <target state="translated">C ++ 표준은 휘발성 객체 처리에서 C 표준과 다릅니다. C ++이 가능한 경우 휘발성에 대해 C와 비슷한 방식으로 행동해야한다는 것을 제외하고는 휘발성 액세스를 구성하는 것을 지정하지 않습니다. 그러나 C와 C ++ 사이의 다른 lvalue 표현은 동작을 복잡하게합니다. G ++는 휘발성 액세스를 위해 GCC와 동일하게 작동합니다 ( GCC의 동작에 대한 설명은 &lt;a href=&quot;c-extensions#C-Extensions&quot;&gt;Volatiles&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="949a50a0730c5f7ad89696edd9c2072338129167" translate="yes" xml:space="preserve">
          <source>The C++ standard just uses the term &amp;ldquo;dependent&amp;rdquo; for names that depend on the type or value of template parameters. This shorter term will also be used in the rest of this section.</source>
          <target state="translated">C ++ 표준은 템플릿 매개 변수의 유형 또는 값에 따라 이름에 &quot;종속&quot;이라는 용어를 사용합니다. 이 단기는이 섹션의 나머지 부분에서도 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7681d0e5c1533a0361ba254a5958bd845de12e17" translate="yes" xml:space="preserve">
          <source>The C++ standard prescribes that all names that are not dependent on template parameters are bound to their present definitions when parsing a template function or class.&lt;a href=&quot;#FOOT5&quot; id=&quot;DOCF5&quot; name=&quot;DOCF5&quot;&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt; Only names that are dependent are looked up at the point of instantiation. For example, consider</source>
          <target state="translated">C ++ 표준은 템플리트 매개 변수 또는 클래스를 구문 분석 할 때 템플리트 매개 변수에 종속되지 않는 모든 이름이 현재 정의에 바인드되도록 규정합니다. &lt;a href=&quot;#FOOT5&quot; id=&quot;DOCF5&quot; name=&quot;DOCF5&quot;&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt; 인스턴스화 시점에서 종속적 인 이름 만 찾습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="253e6af722c0841d38d6e4f298c9a3cde3c002be" translate="yes" xml:space="preserve">
          <source>The C++ standard specifies that &amp;lsquo;</source>
          <target state="translated">C ++ 표준은 '</target>
        </trans-unit>
        <trans-unit id="7e51d56fadfe74149ae162a54ac1fe3c8b16dbb0" translate="yes" xml:space="preserve">
          <source>The C++ standard specifies that such expressions do not undergo lvalue to rvalue conversion, and that the type of the dereferenced object may be incomplete. The C++ standard does not specify explicitly that it is lvalue to rvalue conversion that is responsible for causing an access. There is reason to believe that it is, because otherwise certain simple expressions become undefined. However, because it would surprise most programmers, G++ treats dereferencing a pointer to volatile object of complete type as GCC would do for an equivalent type in C. When the object has incomplete type, G++ issues a warning; if you wish to force an error, you must force a conversion to rvalue with, for instance, a static cast.</source>
          <target state="translated">C ++ 표준은 이러한 표현식이 lvalue에서 rvalue로 변환되지 않으며 역 참조 된 오브젝트의 유형이 불완전 할 수 있음을 지정합니다. C ++ 표준은 액세스의 원인이되는 lvalue에서 rvalue 로의 변환임을 명시 적으로 지정하지 않습니다. 그렇지 않으면 특정 간단한 표현이 정의되지 않기 때문에 그것을 믿을만한 이유가 있습니다. 그러나 대부분의 프로그래머에게는 놀라 울 것이기 때문에 G ++는 GCC가 C의 동등한 유형에 대해 수행하는 것처럼 완전한 유형의 휘발성 객체에 대한 포인터를 역 참조하는 것으로 간주합니다. 객체가 불완전한 유형 인 경우 G ++는 경고를 표시합니다. 오류를 발생 시키려면 정적 캐스트 등을 사용하여 rvalue로 변환을 강제 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="73a31b9577ac049499e169205951815b4d802407" translate="yes" xml:space="preserve">
          <source>The C++11 and OpenMP standards allow &lt;code&gt;thread_local&lt;/code&gt; and &lt;code&gt;threadprivate&lt;/code&gt; variables to have dynamic (runtime) initialization. To support this, any use of such a variable goes through a wrapper function that performs any necessary initialization. When the use and definition of the variable are in the same translation unit, this overhead can be optimized away, but when the use is in a different translation unit there is significant overhead even if the variable doesn&amp;rsquo;t actually need dynamic initialization. If the programmer can be sure that no use of the variable in a non-defining TU needs to trigger dynamic initialization (either because the variable is statically initialized, or a use of the variable in the defining TU will be executed before any uses in another TU), they can avoid this overhead with the</source>
          <target state="translated">C ++ 11 및 OpenMP 표준은 &lt;code&gt;thread_local&lt;/code&gt; 및 &lt;code&gt;threadprivate&lt;/code&gt; 를 허용합니다.동적 (런타임) 초기화를위한 변수. 이를 지원하기 위해 이러한 변수를 사용하면 필요한 초기화를 수행하는 랩퍼 기능이 사용됩니다. 변수의 사용 및 정의가 동일한 변환 단위에 있으면이 오버 헤드를 최적화 할 수 있지만, 다른 변환 단위에 사용하는 경우 변수에 실제로 동적 초기화가 필요하지 않더라도 상당한 오버 헤드가 있습니다. 프로그래머가 비정의 TU에서 변수를 사용하지 않아도 동적 초기화를 트리거 할 필요가 없다고 확신 할 수있는 경우 (변수가 정적으로 초기화되거나 정의 된 TU의 변수 사용이 다른 용도로 사용되기 전에 실행 됨) TU)를 사용하면 이러한 오버 헤드를 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da8ab7209d2ba607c1022648449bd576dc30ecb4" translate="yes" xml:space="preserve">
          <source>The C++17 standard will define the order of evaluation of operands in more cases: in particular it requires that the right-hand side of an assignment be evaluated before the left-hand side, so the above examples are no longer undefined. But this option will still warn about them, to help people avoid writing code that is undefined in C and earlier revisions of C++.</source>
          <target state="translated">C ++ 17 표준은 더 많은 경우에 피연산자의 평가 순서를 정의합니다. 특히 할당의 오른쪽이 왼쪽보다 먼저 평가되어야하므로 위의 예제는 더 이상 정의되지 않습니다. 그러나이 옵션은 C 및 이전 C ++ 개정판에서 정의되지 않은 코드를 작성하는 것을 방지하기 위해 여전히 경고를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="463aa5596934552e20b1c86daa9eff2befcfafd9" translate="yes" xml:space="preserve">
          <source>The C++17 standard will define the order of evaluation of operands in more cases: in particular it requires that the right-hand side of an assignment be evaluated before the left-hand side, so the above examples are no longer undefined. But this warning will still warn about them, to help people avoid writing code that is undefined in C and earlier revisions of C++.</source>
          <target state="translated">C ++ 17 표준은 더 많은 경우에 피연산자 평가 순서를 정의합니다. 특히 할당의 오른쪽을 왼쪽보다 먼저 평가해야하므로 위의 예는 더 이상 정의되지 않습니다. 그러나이 경고는 사람들이 C와 C ++의 이전 개정판에서 정의되지 않은 코드를 작성하지 않도록 돕기 위해 여전히 경고합니다.</target>
        </trans-unit>
        <trans-unit id="3f8518a5ffcdc724e580f436c8e8861c47a79dbf" translate="yes" xml:space="preserve">
          <source>The CC register.</source>
          <target state="translated">CC 레지스터.</target>
        </trans-unit>
        <trans-unit id="aac83138ffc7dedbba141af64e9e3833a7581060" translate="yes" xml:space="preserve">
          <source>The Cyclic Redundancy Check (CRC) instructions.</source>
          <target state="translated">순환 중복 검사 (CRC) 지침.</target>
        </trans-unit>
        <trans-unit id="26d3b88b25735a58406b058569b742cd7ef6e371" translate="yes" xml:space="preserve">
          <source>The DSP instructions.</source>
          <target state="translated">DSP 명령어.</target>
        </trans-unit>
        <trans-unit id="8a394fdb5f659a018583a4b282fa046a537ed960" translate="yes" xml:space="preserve">
          <source>The Darwin tools vary in their behavior when presented with an ISA mismatch. The assembler,</source>
          <target state="translated">Darwin 도구는 ISA 불일치가있을 때 동작이 다양합니다. 어셈블러</target>
        </trans-unit>
        <trans-unit id="c474ab61fc35bcc3be354a3a5837d9c0d40e8830" translate="yes" xml:space="preserve">
          <source>The GCC port for AArch64 only supports the IEEE 754-2008 format, and does not require use of the</source>
          <target state="translated">AArch64 용 GCC 포트는 IEEE 754-2008 형식 만 지원하며</target>
        </trans-unit>
        <trans-unit id="0079c12261c57d6bab6a15c723b1304a15531596" translate="yes" xml:space="preserve">
          <source>The GNU C compiler supports both dialects; you can specify the signed dialect with</source>
          <target state="translated">GNU C 컴파일러는 두 언어를 모두 지원합니다. 서명 된 방언을 지정할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="9a9482fb99a743f48dbd7859a7e8e12b5401b580" translate="yes" xml:space="preserve">
          <source>The GNU C preprocessor recognizes several pragmas in addition to the compiler pragmas documented here. Refer to the CPP manual for more information.</source>
          <target state="translated">GNU C 전처리 기는 여기에 설명 된 컴파일러 pragma 외에도 여러 pragma를 인식합니다. 자세한 내용은 CPP 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0227d0ba5f10912bdc54f8efb32ad7ab5a1942f8" translate="yes" xml:space="preserve">
          <source>The GNU Objective-C runtime provides a hook, called &lt;code&gt;__objc_msg_forward2&lt;/code&gt;, which is called by &lt;code&gt;objc_msg_lookup()&lt;/code&gt; when it cannot find a method implementation in the runtime tables and after calling &lt;code&gt;+resolveInstanceMethod:&lt;/code&gt; and &lt;code&gt;+resolveClassMethod:&lt;/code&gt; has been attempted and did not succeed in dynamically registering the method.</source>
          <target state="translated">GNU Objective-C 런타임은 &lt;code&gt;__objc_msg_forward2&lt;/code&gt; 라는 후크를 제공하는데 , 이는 런타임 테이블에서 메소드 구현을 찾을 수없고 &lt;code&gt;+resolveInstanceMethod:&lt;/code&gt; 및 &lt;code&gt;+resolveClassMethod:&lt;/code&gt; 호출 한 후 &lt;code&gt;objc_msg_lookup()&lt;/code&gt; 의해 호출 되며 동적으로 성공하지 못했습니다. 메소드 등록</target>
        </trans-unit>
        <trans-unit id="c32c2c0d5cf1c06ca2fc7f8fc5108f046c90f6d6" translate="yes" xml:space="preserve">
          <source>The GNU Objective-C runtime provides a way that allows you to execute code before the execution of the program enters the &lt;code&gt;main&lt;/code&gt; function. The code is executed on a per-class and a per-category basis, through a special class method &lt;code&gt;+load&lt;/code&gt;.</source>
          <target state="translated">GNU Objective-C 런타임은 프로그램 실행이 &lt;code&gt;main&lt;/code&gt; 기능에 들어가기 전에 코드를 실행할 수있는 방법을 제공 합니다. 코드는 특수 클래스 메소드 &lt;code&gt;+load&lt;/code&gt; 를 통해 클래스 및 범주별로 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="6204b4438d0b4bf08e65cf328298ab3f8520d1f5" translate="yes" xml:space="preserve">
          <source>The GNU Objective-C runtime provides an API that allows you to interact with the Objective-C runtime system, querying the live runtime structures and even manipulating them. This allows you for example to inspect and navigate classes, methods and protocols; to define new classes or new methods, and even to modify existing classes or protocols.</source>
          <target state="translated">GNU Objective-C 런타임은 Objective-C 런타임 시스템과 상호 작용하여 라이브 런타임 구조를 쿼리하고 조작 할 수있는 API를 제공합니다. 예를 들어 클래스, 메소드 및 프로토콜을 검사하고 탐색 할 수 있습니다. 새로운 클래스 나 새로운 메소드를 정의하고 기존 클래스 나 프로토콜을 수정하기 위해.</target>
        </trans-unit>
        <trans-unit id="4882007657bbd3b9904317ecd7c9122b201adae0" translate="yes" xml:space="preserve">
          <source>The GNU Objective-C runtime provides an API which is similar to the one provided by the &amp;ldquo;Objective-C 2.0&amp;rdquo; Apple/NeXT Objective-C runtime. The API is documented in the public header files of the GNU Objective-C runtime:</source>
          <target state="translated">GNU Objective-C 런타임은 &quot;Objective-C 2.0&quot;Apple / NeXT Objective-C 런타임에서 제공하는 것과 유사한 API를 제공합니다. API는 GNU Objective-C 런타임의 공개 헤더 파일에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="bda523f70e2cc81aec3a5420312f2dc14631e90d" translate="yes" xml:space="preserve">
          <source>The GNU Objective-C runtime used to provide a different API, which we call the &amp;ldquo;traditional&amp;rdquo; GNU Objective-C runtime API. Functions belonging to this API are easy to recognize because they use a different naming convention, such as &lt;code&gt;class_get_super_class()&lt;/code&gt; (traditional API) instead of &lt;code&gt;class_getSuperclass()&lt;/code&gt; (modern API). Software using this API includes the file</source>
          <target state="translated">GNU Objective-C 런타임은 &quot;전통적인&quot;GNU Objective-C 런타임 API라고하는 다른 API를 제공하는 데 사용되었습니다. 이 API에 속하는 함수 는 &lt;code&gt;class_getSuperclass()&lt;/code&gt; (현대 API) 대신 &lt;code&gt;class_get_super_class()&lt;/code&gt; (전통 API) 와 같은 다른 명명 규칙을 사용하기 때문에 쉽게 인식 할 수 있습니다 . 이 API를 사용하는 소프트웨어는 파일을 포함합니다</target>
        </trans-unit>
        <trans-unit id="a580b32a37e3e1afb84412437056129293c1db6e" translate="yes" xml:space="preserve">
          <source>The GNU Project and GNU/Linux</source>
          <target state="translated">GNU 프로젝트와 GNU / Linux</target>
        </trans-unit>
        <trans-unit id="fbf08e863571f4a8147fed0d98f89d3a6cc1c1c5" translate="yes" xml:space="preserve">
          <source>The GNU Project and GNU/Linux.</source>
          <target state="translated">GNU 프로젝트와 GNU / Linux.</target>
        </trans-unit>
        <trans-unit id="565581be4558eda62440473a382dca36e2293950" translate="yes" xml:space="preserve">
          <source>The GNU compiler can produce two kinds of diagnostics: errors and warnings. Each kind has a different purpose:</source>
          <target state="translated">GNU 컴파일러는 오류와 경고의 두 가지 진단을 생성 할 수 있습니다. 각 종류의 목적은 다릅니다 :</target>
        </trans-unit>
        <trans-unit id="0ef6aa50a29b9e95c494d3259dc5f4a2758d594d" translate="yes" xml:space="preserve">
          <source>The GNU compiler provides these extensions to the C++ language (and you can also use most of the C language extensions in your C++ programs). If you want to write code that checks whether these features are available, you can test for the GNU compiler the same way as for C programs: check for a predefined macro &lt;code&gt;__GNUC__&lt;/code&gt;. You can also use &lt;code&gt;__GNUG__&lt;/code&gt; to test specifically for GNU C++ (see &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html#Common-Predefined-Macros&quot;&gt;Predefined Macros&lt;/a&gt; in The GNU C Preprocessor).</source>
          <target state="translated">GNU 컴파일러는 이러한 확장을 C ++ 언어로 제공하며 C ++ 프로그램에서 대부분의 C 언어 확장을 사용할 수도 있습니다. 이러한 기능을 사용할 수 있는지 확인하는 코드를 작성하려면 C 프로그램과 동일한 방법으로 GNU 컴파일러를 테스트 할 수 있습니다 . 사전 정의 된 매크로 &lt;code&gt;__GNUC__&lt;/code&gt; 확인 . &lt;code&gt;__GNUG__&lt;/code&gt; 를 사용 하여 GNU C ++에 대해 특별히 테스트 할 수도 있습니다 ( GNU C 전 처리기의 &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html#Common-Predefined-Macros&quot;&gt;사전 정의 된 매크로&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="01dfd2dfdc3ff7f1b0a50a6ec344c326c46c8c49" translate="yes" xml:space="preserve">
          <source>The GNU compiler provides these extensions to the C++ language (and you can also use most of the C language extensions in your C++ programs). If you want to write code that checks whether these features are available, you can test for the GNU compiler the same way as for C programs: check for a predefined macro &lt;code&gt;__GNUC__&lt;/code&gt;. You can also use &lt;code&gt;__GNUG__&lt;/code&gt; to test specifically for GNU C++ (see &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html#Common-Predefined-Macros&quot;&gt;Predefined Macros&lt;/a&gt; in The GNU C Preprocessor).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdd4d4c02d395886b71e823798e0aedf04f540c0" translate="yes" xml:space="preserve">
          <source>The GNU linker (beginning with version 2.16) has the necessary support for this option. If your linker does not support this option, the header file aspect of</source>
          <target state="translated">GNU 링커 (버전 2.16으로 시작)는이 옵션에 필요한 지원을 제공합니다. 링커가이 옵션을 지원하지 않으면 헤더 파일의</target>
        </trans-unit>
        <trans-unit id="649e8f725ce325928e9d3758e5501f5eb08d8098" translate="yes" xml:space="preserve">
          <source>The HP-UX implementation of setlocale in libc has a dependency on libdld.sl. There isn&amp;rsquo;t an archive version of libdld.sl. Thus, when the</source>
          <target state="translated">libc에서 setlocale의 HP-UX 구현은 libdld.sl에 종속됩니다. libdld.sl의 아카이브 버전이 없습니다. 따라서</target>
        </trans-unit>
        <trans-unit id="e6712fd16e48687aa09a28dcd06ca5cfec22cf46" translate="yes" xml:space="preserve">
          <source>The HTM builtins (with the exception of &lt;code&gt;__builtin_tbegin&lt;/code&gt;) return the full 4-bit condition register value set by their associated hardware instruction. The header file &lt;code&gt;htmintrin.h&lt;/code&gt; defines some macros that can be used to decipher the return value. The &lt;code&gt;__builtin_tbegin&lt;/code&gt; builtin returns a simple &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; value depending on whether a transaction was successfully started or not. The arguments of the builtins match exactly the type and order of the associated hardware instruction&amp;rsquo;s operands, except for the &lt;code&gt;__builtin_tcheck&lt;/code&gt; builtin, which does not take any input arguments. Refer to the ISA manual for a description of each instruction&amp;rsquo;s operands.</source>
          <target state="translated">HTM 내장 ( &lt;code&gt;__builtin_tbegin&lt;/code&gt; 제외 )은 관련 하드웨어 명령으로 설정된 전체 4 비트 조건 레지스터 값을 반환합니다. 헤더 파일 &lt;code&gt;htmintrin.h&lt;/code&gt; 는 반환 값을 해독하는 데 사용할 수있는 매크로를 정의합니다. &lt;code&gt;__builtin_tbegin&lt;/code&gt; 간단한 반환 내장 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 값은 트랜잭션이 성공적으로 시작 아닌지 여부에 따라 달라집니다. 내장 인수는 입력 인수를받지 않는 &lt;code&gt;__builtin_tcheck&lt;/code&gt; 내장을 제외하고 연관된 하드웨어 명령어 피연산자의 유형 및 순서와 정확히 일치합니다 . 각 명령어의 피연산자에 대한 설명은 ISA 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="87dbb117c6f13df65961818e4b7b41562cf362b8" translate="yes" xml:space="preserve">
          <source>The IA-64 back end supports the following variable attribute:</source>
          <target state="translated">IA-64 백엔드는 다음 변수 속성을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="03f6d255f23aeee8dc7ee63e3c04d489d6fd6b28" translate="yes" xml:space="preserve">
          <source>The ISA and hardware multiply supported for the different MCUs is hard-coded into GCC. However, an external &amp;lsquo;</source>
          <target state="translated">다른 MCU에 대해 지원되는 ISA 및 하드웨어 곱셈은 GCC에 하드 코딩됩니다. 그러나 외부 '</target>
        </trans-unit>
        <trans-unit id="a2f39a7601ef937b791997651319caebaf1d1db8" translate="yes" xml:space="preserve">
          <source>The ISO C standard defines (in clause 4) two classes of conforming implementation. A &lt;em&gt;conforming hosted implementation&lt;/em&gt; supports the whole standard including all the library facilities; a &lt;em&gt;conforming freestanding implementation&lt;/em&gt; is only required to provide certain library facilities: those in &lt;code&gt;&amp;lt;float.h&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;limits.h&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;stdarg.h&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt;; since AMD1, also those in &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt;; since C99, also those in &lt;code&gt;&amp;lt;stdbool.h&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;stdint.h&amp;gt;&lt;/code&gt;; and since C11, also those in &lt;code&gt;&amp;lt;stdalign.h&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;stdnoreturn.h&amp;gt;&lt;/code&gt;. In addition, complex types, added in C99, are not required for freestanding implementations.</source>
          <target state="translated">ISO C 표준은 (4 절에서) 두 가지 준수 구현 클래스를 정의합니다. &lt;em&gt;준수 호스팅 구현은&lt;/em&gt; 도서관 시설을 모두 포함한 전체 표준을 지원합니다; &lt;em&gt;구현하는 것은 자립 따르는&lt;/em&gt; 특정 라이브러리 기능을 제공해야한다 : 그 안에 &lt;code&gt;&amp;lt;float.h&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;limits.h&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;stdarg.h&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt; ; AMD1부터 &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt; 의 AMD1 ; C99 이후로, &lt;code&gt;&amp;lt;stdbool.h&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;stdint.h&amp;gt;&lt;/code&gt; 의 것들 ; C11부터 &lt;code&gt;&amp;lt;stdalign.h&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;stdnoreturn.h&amp;gt;&lt;/code&gt; . 또한 C99에 추가 된 복잡한 유형은 독립 실행 형 구현에 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4df8e4ece265376ae0055a7b2b932c764c91156b" translate="yes" xml:space="preserve">
          <source>The ISO C standard leaves it up to the implementation whether a bit-field declared plain &lt;code&gt;int&lt;/code&gt; is signed or not. This in effect creates two alternative dialects of C.</source>
          <target state="translated">ISO C 표준은 일반 &lt;code&gt;int&lt;/code&gt; 로 선언 된 비트 필드의 서명 여부에 따라 구현에 적용 됩니다. 이로 인해 C의 두 가지 다른 방언이 만들어집니다.</target>
        </trans-unit>
        <trans-unit id="bced80c01ede6829408bc604cd122f3ce07d3569" translate="yes" xml:space="preserve">
          <source>The ISO C++14 library also defines the &amp;lsquo;</source>
          <target state="translated">ISO C ++ 14 라이브러리는 '</target>
        </trans-unit>
        <trans-unit id="de0f27c3596685d686fd3d285d5ba869620aa947" translate="yes" xml:space="preserve">
          <source>The ISO C90 functions &lt;code&gt;abort&lt;/code&gt;, &lt;code&gt;abs&lt;/code&gt;, &lt;code&gt;acos&lt;/code&gt;, &lt;code&gt;asin&lt;/code&gt;, &lt;code&gt;atan2&lt;/code&gt;, &lt;code&gt;atan&lt;/code&gt;, &lt;code&gt;calloc&lt;/code&gt;, &lt;code&gt;ceil&lt;/code&gt;, &lt;code&gt;cosh&lt;/code&gt;, &lt;code&gt;cos&lt;/code&gt;, &lt;code&gt;exit&lt;/code&gt;, &lt;code&gt;exp&lt;/code&gt;, &lt;code&gt;fabs&lt;/code&gt;, &lt;code&gt;floor&lt;/code&gt;, &lt;code&gt;fmod&lt;/code&gt;, &lt;code&gt;fprintf&lt;/code&gt;, &lt;code&gt;fputs&lt;/code&gt;, &lt;code&gt;free&lt;/code&gt;, &lt;code&gt;frexp&lt;/code&gt;, &lt;code&gt;fscanf&lt;/code&gt;, &lt;code&gt;isalnum&lt;/code&gt;, &lt;code&gt;isalpha&lt;/code&gt;, &lt;code&gt;iscntrl&lt;/code&gt;, &lt;code&gt;isdigit&lt;/code&gt;, &lt;code&gt;isgraph&lt;/code&gt;, &lt;code&gt;islower&lt;/code&gt;, &lt;code&gt;isprint&lt;/code&gt;, &lt;code&gt;ispunct&lt;/code&gt;, &lt;code&gt;isspace&lt;/code&gt;, &lt;code&gt;isupper&lt;/code&gt;, &lt;code&gt;isxdigit&lt;/code&gt;, &lt;code&gt;tolower&lt;/code&gt;, &lt;code&gt;toupper&lt;/code&gt;, &lt;code&gt;labs&lt;/code&gt;, &lt;code&gt;ldexp&lt;/code&gt;, &lt;code&gt;log10&lt;/code&gt;, &lt;code&gt;log&lt;/code&gt;, &lt;code&gt;malloc&lt;/code&gt;, &lt;code&gt;memchr&lt;/code&gt;, &lt;code&gt;memcmp&lt;/code&gt;, &lt;code&gt;memcpy&lt;/code&gt;, &lt;code&gt;memset&lt;/code&gt;, &lt;code&gt;modf&lt;/code&gt;, &lt;code&gt;pow&lt;/code&gt;, &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;putchar&lt;/code&gt;, &lt;code&gt;puts&lt;/code&gt;, &lt;code&gt;realloc&lt;/code&gt;, &lt;code&gt;scanf&lt;/code&gt;, &lt;code&gt;sinh&lt;/code&gt;, &lt;code&gt;sin&lt;/code&gt;, &lt;code&gt;snprintf&lt;/code&gt;, &lt;code&gt;sprintf&lt;/code&gt;, &lt;code&gt;sqrt&lt;/code&gt;, &lt;code&gt;sscanf&lt;/code&gt;, &lt;code&gt;strcat&lt;/code&gt;, &lt;code&gt;strchr&lt;/code&gt;, &lt;code&gt;strcmp&lt;/code&gt;, &lt;code&gt;strcpy&lt;/code&gt;, &lt;code&gt;strcspn&lt;/code&gt;, &lt;code&gt;strlen&lt;/code&gt;, &lt;code&gt;strncat&lt;/code&gt;, &lt;code&gt;strncmp&lt;/code&gt;, &lt;code&gt;strncpy&lt;/code&gt;, &lt;code&gt;strpbrk&lt;/code&gt;, &lt;code&gt;strrchr&lt;/code&gt;, &lt;code&gt;strspn&lt;/code&gt;, &lt;code&gt;strstr&lt;/code&gt;, &lt;code&gt;tanh&lt;/code&gt;, &lt;code&gt;tan&lt;/code&gt;, &lt;code&gt;vfprintf&lt;/code&gt;, &lt;code&gt;vprintf&lt;/code&gt; and &lt;code&gt;vsprintf&lt;/code&gt; are all recognized as built-in functions unless</source>
          <target state="translated">ISO C90 함수 &lt;code&gt;abort&lt;/code&gt; , &lt;code&gt;abs&lt;/code&gt; , &lt;code&gt;acos&lt;/code&gt; , &lt;code&gt;asin&lt;/code&gt; , &lt;code&gt;atan2&lt;/code&gt; , &lt;code&gt;atan&lt;/code&gt; , &lt;code&gt;calloc&lt;/code&gt; , &lt;code&gt;ceil&lt;/code&gt; , &lt;code&gt;cosh&lt;/code&gt; , &lt;code&gt;cos&lt;/code&gt; , &lt;code&gt;exit&lt;/code&gt; , &lt;code&gt;exp&lt;/code&gt; , &lt;code&gt;fabs&lt;/code&gt; , &lt;code&gt;floor&lt;/code&gt; , &lt;code&gt;fmod&lt;/code&gt; , &lt;code&gt;fprintf&lt;/code&gt; , &lt;code&gt;fputs&lt;/code&gt; , &lt;code&gt;free&lt;/code&gt; , &lt;code&gt;frexp&lt;/code&gt; , &lt;code&gt;fscanf&lt;/code&gt; , &lt;code&gt;isalnum&lt;/code&gt; , &lt;code&gt;isalpha&lt;/code&gt; , &lt;code&gt;iscntrl&lt;/code&gt; , &lt;code&gt;isdigit&lt;/code&gt; , &lt;code&gt;isgraph&lt;/code&gt; , &lt;code&gt;islower&lt;/code&gt; 와 , &lt;code&gt;isprint&lt;/code&gt; , &lt;code&gt;ispunct&lt;/code&gt; , &lt;code&gt;isspace&lt;/code&gt; 와 , &lt;code&gt;isupper&lt;/code&gt; , &lt;code&gt;isxdigit&lt;/code&gt; , &lt;code&gt;tolower&lt;/code&gt; 를 , &lt;code&gt;toupper&lt;/code&gt; , &lt;code&gt;labs&lt;/code&gt; , &lt;code&gt;ldexp&lt;/code&gt; , &lt;code&gt;log10&lt;/code&gt; , &lt;code&gt;log&lt;/code&gt; , &lt;code&gt;malloc&lt;/code&gt; 에 , &lt;code&gt;memchr&lt;/code&gt; , &lt;code&gt;memcmp&lt;/code&gt; 는 , &lt;code&gt;memcpy&lt;/code&gt; , &lt;code&gt;memset&lt;/code&gt; 함수 , &lt;code&gt;modf&lt;/code&gt; 는 , &lt;code&gt;pow&lt;/code&gt; , &lt;code&gt;printf&lt;/code&gt; 와 , &lt;code&gt;putchar&lt;/code&gt; , &lt;code&gt;puts&lt;/code&gt; , &lt;code&gt;realloc&lt;/code&gt; 을 , &lt;code&gt;scanf&lt;/code&gt; 와 , &lt;code&gt;sinh&lt;/code&gt; , &lt;code&gt;sin&lt;/code&gt; , &lt;code&gt;snprintf&lt;/code&gt; , &lt;code&gt;sprintf&lt;/code&gt; 를 , &lt;code&gt;sqrt&lt;/code&gt; , &lt;code&gt;sscanf&lt;/code&gt; 에서 , &lt;code&gt;strcat&lt;/code&gt; 와 , &lt;code&gt;strchr&lt;/code&gt; 과 , &lt;code&gt;strcmp&lt;/code&gt; , &lt;code&gt;strcpy&lt;/code&gt; 와 , &lt;code&gt;strcspn&lt;/code&gt; , &lt;code&gt;strlen&lt;/code&gt; , &lt;code&gt;strncat&lt;/code&gt; , &lt;code&gt;strncmp&lt;/code&gt; , &lt;code&gt;strncpy&lt;/code&gt; 에서 , &lt;code&gt;strpbrk&lt;/code&gt; , &lt;code&gt;strrchr&lt;/code&gt; , &lt;code&gt;strspn&lt;/code&gt; , &lt;code&gt;strstr&lt;/code&gt; , &lt;code&gt;tanh&lt;/code&gt; , &lt;code&gt;tan&lt;/code&gt; , &lt;code&gt;vfprintf&lt;/code&gt; , &lt;code&gt;vprintf&lt;/code&gt; 및 &lt;code&gt;vsprintf&lt;/code&gt; 는 모두 내장으로 인정 기능에서</target>
        </trans-unit>
        <trans-unit id="67ca06952bac1aee629481893fc1242a0df75d20" translate="yes" xml:space="preserve">
          <source>The ISO C90 functions &lt;code&gt;abort&lt;/code&gt;, &lt;code&gt;abs&lt;/code&gt;, &lt;code&gt;acos&lt;/code&gt;, &lt;code&gt;asin&lt;/code&gt;, &lt;code&gt;atan2&lt;/code&gt;, &lt;code&gt;atan&lt;/code&gt;, &lt;code&gt;calloc&lt;/code&gt;, &lt;code&gt;ceil&lt;/code&gt;, &lt;code&gt;cosh&lt;/code&gt;, &lt;code&gt;cos&lt;/code&gt;, &lt;code&gt;exit&lt;/code&gt;, &lt;code&gt;exp&lt;/code&gt;, &lt;code&gt;fabs&lt;/code&gt;, &lt;code&gt;floor&lt;/code&gt;, &lt;code&gt;fmod&lt;/code&gt;, &lt;code&gt;fprintf&lt;/code&gt;, &lt;code&gt;fputs&lt;/code&gt;, &lt;code&gt;frexp&lt;/code&gt;, &lt;code&gt;fscanf&lt;/code&gt;, &lt;code&gt;isalnum&lt;/code&gt;, &lt;code&gt;isalpha&lt;/code&gt;, &lt;code&gt;iscntrl&lt;/code&gt;, &lt;code&gt;isdigit&lt;/code&gt;, &lt;code&gt;isgraph&lt;/code&gt;, &lt;code&gt;islower&lt;/code&gt;, &lt;code&gt;isprint&lt;/code&gt;, &lt;code&gt;ispunct&lt;/code&gt;, &lt;code&gt;isspace&lt;/code&gt;, &lt;code&gt;isupper&lt;/code&gt;, &lt;code&gt;isxdigit&lt;/code&gt;, &lt;code&gt;tolower&lt;/code&gt;, &lt;code&gt;toupper&lt;/code&gt;, &lt;code&gt;labs&lt;/code&gt;, &lt;code&gt;ldexp&lt;/code&gt;, &lt;code&gt;log10&lt;/code&gt;, &lt;code&gt;log&lt;/code&gt;, &lt;code&gt;malloc&lt;/code&gt;, &lt;code&gt;memchr&lt;/code&gt;, &lt;code&gt;memcmp&lt;/code&gt;, &lt;code&gt;memcpy&lt;/code&gt;, &lt;code&gt;memset&lt;/code&gt;, &lt;code&gt;modf&lt;/code&gt;, &lt;code&gt;pow&lt;/code&gt;, &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;putchar&lt;/code&gt;, &lt;code&gt;puts&lt;/code&gt;, &lt;code&gt;scanf&lt;/code&gt;, &lt;code&gt;sinh&lt;/code&gt;, &lt;code&gt;sin&lt;/code&gt;, &lt;code&gt;snprintf&lt;/code&gt;, &lt;code&gt;sprintf&lt;/code&gt;, &lt;code&gt;sqrt&lt;/code&gt;, &lt;code&gt;sscanf&lt;/code&gt;, &lt;code&gt;strcat&lt;/code&gt;, &lt;code&gt;strchr&lt;/code&gt;, &lt;code&gt;strcmp&lt;/code&gt;, &lt;code&gt;strcpy&lt;/code&gt;, &lt;code&gt;strcspn&lt;/code&gt;, &lt;code&gt;strlen&lt;/code&gt;, &lt;code&gt;strncat&lt;/code&gt;, &lt;code&gt;strncmp&lt;/code&gt;, &lt;code&gt;strncpy&lt;/code&gt;, &lt;code&gt;strpbrk&lt;/code&gt;, &lt;code&gt;strrchr&lt;/code&gt;, &lt;code&gt;strspn&lt;/code&gt;, &lt;code&gt;strstr&lt;/code&gt;, &lt;code&gt;tanh&lt;/code&gt;, &lt;code&gt;tan&lt;/code&gt;, &lt;code&gt;vfprintf&lt;/code&gt;, &lt;code&gt;vprintf&lt;/code&gt; and &lt;code&gt;vsprintf&lt;/code&gt; are all recognized as built-in functions unless</source>
          <target state="translated">는 ISO C90 기능을 &lt;code&gt;abort&lt;/code&gt; , &lt;code&gt;abs&lt;/code&gt; , &lt;code&gt;acos&lt;/code&gt; , &lt;code&gt;asin&lt;/code&gt; , &lt;code&gt;atan2&lt;/code&gt; , &lt;code&gt;atan&lt;/code&gt; , &lt;code&gt;calloc&lt;/code&gt; , &lt;code&gt;ceil&lt;/code&gt; , &lt;code&gt;cosh&lt;/code&gt; , &lt;code&gt;cos&lt;/code&gt; , &lt;code&gt;exit&lt;/code&gt; , &lt;code&gt;exp&lt;/code&gt; , &lt;code&gt;fabs&lt;/code&gt; , &lt;code&gt;floor&lt;/code&gt; , &lt;code&gt;fmod&lt;/code&gt; , &lt;code&gt;fprintf&lt;/code&gt; 와 , &lt;code&gt;fputs&lt;/code&gt; , &lt;code&gt;frexp&lt;/code&gt; 와 , &lt;code&gt;fscanf&lt;/code&gt; , &lt;code&gt;isalnum&lt;/code&gt; , &lt;code&gt;isalpha&lt;/code&gt; 에 , &lt;code&gt;iscntrl&lt;/code&gt; , &lt;code&gt;isdigit&lt;/code&gt; 에를 , &lt;code&gt;isgraph&lt;/code&gt; , 더 &lt;code&gt;islower&lt;/code&gt; , &lt;code&gt;isprint&lt;/code&gt; , &lt;code&gt;ispunct&lt;/code&gt; , &lt;code&gt;isspace&lt;/code&gt; 와 , &lt;code&gt;isupper&lt;/code&gt; , &lt;code&gt;isxdigit&lt;/code&gt; , &lt;code&gt;tolower&lt;/code&gt; 를 , &lt;code&gt;toupper&lt;/code&gt; , &lt;code&gt;labs&lt;/code&gt; , &lt;code&gt;ldexp&lt;/code&gt; , &lt;code&gt;log10&lt;/code&gt; , &lt;code&gt;log&lt;/code&gt; , &lt;code&gt;malloc&lt;/code&gt; 에 , &lt;code&gt;memchr&lt;/code&gt; , &lt;code&gt;memcmp&lt;/code&gt; 는 , &lt;code&gt;memcpy&lt;/code&gt; , &lt;code&gt;memset&lt;/code&gt; 함수 , &lt;code&gt;modf&lt;/code&gt; 는 , &lt;code&gt;pow&lt;/code&gt; , &lt;code&gt;printf&lt;/code&gt; 와 , &lt;code&gt;putchar&lt;/code&gt; , &lt;code&gt;puts&lt;/code&gt; , &lt;code&gt;scanf&lt;/code&gt; 와 , &lt;code&gt;sinh&lt;/code&gt; , &lt;code&gt;sin&lt;/code&gt; , &lt;code&gt;snprintf&lt;/code&gt; , &lt;code&gt;sprintf&lt;/code&gt; 와 , &lt;code&gt;sqrt&lt;/code&gt; , &lt;code&gt;sscanf&lt;/code&gt; 를 , &lt;code&gt;strcat&lt;/code&gt; 와 , &lt;code&gt;strchr&lt;/code&gt; 과 , &lt;code&gt;strcmp&lt;/code&gt; , &lt;code&gt;strcpy&lt;/code&gt; 와 , &lt;code&gt;strcspn&lt;/code&gt; , &lt;code&gt;strlen&lt;/code&gt; , &lt;code&gt;strncat&lt;/code&gt; , &lt;code&gt;strncmp&lt;/code&gt; , &lt;code&gt;strncpy&lt;/code&gt; 에서 , &lt;code&gt;strpbrk&lt;/code&gt; , &lt;code&gt;strrchr&lt;/code&gt; , &lt;code&gt;strspn&lt;/code&gt; , &lt;code&gt;strstr&lt;/code&gt; 과 , &lt;code&gt;tanh&lt;/code&gt; , &lt;code&gt;tan&lt;/code&gt; , &lt;code&gt;vfprintf&lt;/code&gt; , &lt;code&gt;vprintf&lt;/code&gt; 및 &lt;code&gt;vsprintf&lt;/code&gt; 는 내장으로 기능을 모두 인식하지 않는 한</target>
        </trans-unit>
        <trans-unit id="ae47f0c159fa493b3beadffa3ea4146c32c1e50a" translate="yes" xml:space="preserve">
          <source>The ISO C94 functions &lt;code&gt;iswalnum&lt;/code&gt;, &lt;code&gt;iswalpha&lt;/code&gt;, &lt;code&gt;iswcntrl&lt;/code&gt;, &lt;code&gt;iswdigit&lt;/code&gt;, &lt;code&gt;iswgraph&lt;/code&gt;, &lt;code&gt;iswlower&lt;/code&gt;, &lt;code&gt;iswprint&lt;/code&gt;, &lt;code&gt;iswpunct&lt;/code&gt;, &lt;code&gt;iswspace&lt;/code&gt;, &lt;code&gt;iswupper&lt;/code&gt;, &lt;code&gt;iswxdigit&lt;/code&gt;, &lt;code&gt;towlower&lt;/code&gt; and &lt;code&gt;towupper&lt;/code&gt; are handled as built-in functions except in strict ISO C90 mode (</source>
          <target state="translated">는 ISO C94 함수 &lt;code&gt;iswalnum&lt;/code&gt; , &lt;code&gt;iswalpha&lt;/code&gt; , &lt;code&gt;iswcntrl&lt;/code&gt; , &lt;code&gt;iswdigit&lt;/code&gt; , &lt;code&gt;iswgraph&lt;/code&gt; , &lt;code&gt;iswlower&lt;/code&gt; , &lt;code&gt;iswprint&lt;/code&gt; , &lt;code&gt;iswpunct&lt;/code&gt; , &lt;code&gt;iswspace&lt;/code&gt; , &lt;code&gt;iswupper&lt;/code&gt; , &lt;code&gt;iswxdigit&lt;/code&gt; , &lt;code&gt;towlower&lt;/code&gt; 및 &lt;code&gt;towupper&lt;/code&gt; 은 으로 처리됩니다 내장 함수 엄격한 ISO C90 모드를 제외하고 (</target>
        </trans-unit>
        <trans-unit id="6cca21d213324c7eb2448728bd34ae61f7e19024" translate="yes" xml:space="preserve">
          <source>The ISO C99 functions &lt;code&gt;_Exit&lt;/code&gt;, &lt;code&gt;acoshf&lt;/code&gt;, &lt;code&gt;acoshl&lt;/code&gt;, &lt;code&gt;acosh&lt;/code&gt;, &lt;code&gt;asinhf&lt;/code&gt;, &lt;code&gt;asinhl&lt;/code&gt;, &lt;code&gt;asinh&lt;/code&gt;, &lt;code&gt;atanhf&lt;/code&gt;, &lt;code&gt;atanhl&lt;/code&gt;, &lt;code&gt;atanh&lt;/code&gt;, &lt;code&gt;cabsf&lt;/code&gt;, &lt;code&gt;cabsl&lt;/code&gt;, &lt;code&gt;cabs&lt;/code&gt;, &lt;code&gt;cacosf&lt;/code&gt;, &lt;code&gt;cacoshf&lt;/code&gt;, &lt;code&gt;cacoshl&lt;/code&gt;, &lt;code&gt;cacosh&lt;/code&gt;, &lt;code&gt;cacosl&lt;/code&gt;, &lt;code&gt;cacos&lt;/code&gt;, &lt;code&gt;cargf&lt;/code&gt;, &lt;code&gt;cargl&lt;/code&gt;, &lt;code&gt;carg&lt;/code&gt;, &lt;code&gt;casinf&lt;/code&gt;, &lt;code&gt;casinhf&lt;/code&gt;, &lt;code&gt;casinhl&lt;/code&gt;, &lt;code&gt;casinh&lt;/code&gt;, &lt;code&gt;casinl&lt;/code&gt;, &lt;code&gt;casin&lt;/code&gt;, &lt;code&gt;catanf&lt;/code&gt;, &lt;code&gt;catanhf&lt;/code&gt;, &lt;code&gt;catanhl&lt;/code&gt;, &lt;code&gt;catanh&lt;/code&gt;, &lt;code&gt;catanl&lt;/code&gt;, &lt;code&gt;catan&lt;/code&gt;, &lt;code&gt;cbrtf&lt;/code&gt;, &lt;code&gt;cbrtl&lt;/code&gt;, &lt;code&gt;cbrt&lt;/code&gt;, &lt;code&gt;ccosf&lt;/code&gt;, &lt;code&gt;ccoshf&lt;/code&gt;, &lt;code&gt;ccoshl&lt;/code&gt;, &lt;code&gt;ccosh&lt;/code&gt;, &lt;code&gt;ccosl&lt;/code&gt;, &lt;code&gt;ccos&lt;/code&gt;, &lt;code&gt;cexpf&lt;/code&gt;, &lt;code&gt;cexpl&lt;/code&gt;, &lt;code&gt;cexp&lt;/code&gt;, &lt;code&gt;cimagf&lt;/code&gt;, &lt;code&gt;cimagl&lt;/code&gt;, &lt;code&gt;cimag&lt;/code&gt;, &lt;code&gt;clogf&lt;/code&gt;, &lt;code&gt;clogl&lt;/code&gt;, &lt;code&gt;clog&lt;/code&gt;, &lt;code&gt;conjf&lt;/code&gt;, &lt;code&gt;conjl&lt;/code&gt;, &lt;code&gt;conj&lt;/code&gt;, &lt;code&gt;copysignf&lt;/code&gt;, &lt;code&gt;copysignl&lt;/code&gt;, &lt;code&gt;copysign&lt;/code&gt;, &lt;code&gt;cpowf&lt;/code&gt;, &lt;code&gt;cpowl&lt;/code&gt;, &lt;code&gt;cpow&lt;/code&gt;, &lt;code&gt;cprojf&lt;/code&gt;, &lt;code&gt;cprojl&lt;/code&gt;, &lt;code&gt;cproj&lt;/code&gt;, &lt;code&gt;crealf&lt;/code&gt;, &lt;code&gt;creall&lt;/code&gt;, &lt;code&gt;creal&lt;/code&gt;, &lt;code&gt;csinf&lt;/code&gt;, &lt;code&gt;csinhf&lt;/code&gt;, &lt;code&gt;csinhl&lt;/code&gt;, &lt;code&gt;csinh&lt;/code&gt;, &lt;code&gt;csinl&lt;/code&gt;, &lt;code&gt;csin&lt;/code&gt;, &lt;code&gt;csqrtf&lt;/code&gt;, &lt;code&gt;csqrtl&lt;/code&gt;, &lt;code&gt;csqrt&lt;/code&gt;, &lt;code&gt;ctanf&lt;/code&gt;, &lt;code&gt;ctanhf&lt;/code&gt;, &lt;code&gt;ctanhl&lt;/code&gt;, &lt;code&gt;ctanh&lt;/code&gt;, &lt;code&gt;ctanl&lt;/code&gt;, &lt;code&gt;ctan&lt;/code&gt;, &lt;code&gt;erfcf&lt;/code&gt;, &lt;code&gt;erfcl&lt;/code&gt;, &lt;code&gt;erfc&lt;/code&gt;, &lt;code&gt;erff&lt;/code&gt;, &lt;code&gt;erfl&lt;/code&gt;, &lt;code&gt;erf&lt;/code&gt;, &lt;code&gt;exp2f&lt;/code&gt;, &lt;code&gt;exp2l&lt;/code&gt;, &lt;code&gt;exp2&lt;/code&gt;, &lt;code&gt;expm1f&lt;/code&gt;, &lt;code&gt;expm1l&lt;/code&gt;, &lt;code&gt;expm1&lt;/code&gt;, &lt;code&gt;fdimf&lt;/code&gt;, &lt;code&gt;fdiml&lt;/code&gt;, &lt;code&gt;fdim&lt;/code&gt;, &lt;code&gt;fmaf&lt;/code&gt;, &lt;code&gt;fmal&lt;/code&gt;, &lt;code&gt;fmaxf&lt;/code&gt;, &lt;code&gt;fmaxl&lt;/code&gt;, &lt;code&gt;fmax&lt;/code&gt;, &lt;code&gt;fma&lt;/code&gt;, &lt;code&gt;fminf&lt;/code&gt;, &lt;code&gt;fminl&lt;/code&gt;, &lt;code&gt;fmin&lt;/code&gt;, &lt;code&gt;hypotf&lt;/code&gt;, &lt;code&gt;hypotl&lt;/code&gt;, &lt;code&gt;hypot&lt;/code&gt;, &lt;code&gt;ilogbf&lt;/code&gt;, &lt;code&gt;ilogbl&lt;/code&gt;, &lt;code&gt;ilogb&lt;/code&gt;, &lt;code&gt;imaxabs&lt;/code&gt;, &lt;code&gt;isblank&lt;/code&gt;, &lt;code&gt;iswblank&lt;/code&gt;, &lt;code&gt;lgammaf&lt;/code&gt;, &lt;code&gt;lgammal&lt;/code&gt;, &lt;code&gt;lgamma&lt;/code&gt;, &lt;code&gt;llabs&lt;/code&gt;, &lt;code&gt;llrintf&lt;/code&gt;, &lt;code&gt;llrintl&lt;/code&gt;, &lt;code&gt;llrint&lt;/code&gt;, &lt;code&gt;llroundf&lt;/code&gt;, &lt;code&gt;llroundl&lt;/code&gt;, &lt;code&gt;llround&lt;/code&gt;, &lt;code&gt;log1pf&lt;/code&gt;, &lt;code&gt;log1pl&lt;/code&gt;, &lt;code&gt;log1p&lt;/code&gt;, &lt;code&gt;log2f&lt;/code&gt;, &lt;code&gt;log2l&lt;/code&gt;, &lt;code&gt;log2&lt;/code&gt;, &lt;code&gt;logbf&lt;/code&gt;, &lt;code&gt;logbl&lt;/code&gt;, &lt;code&gt;logb&lt;/code&gt;, &lt;code&gt;lrintf&lt;/code&gt;, &lt;code&gt;lrintl&lt;/code&gt;, &lt;code&gt;lrint&lt;/code&gt;, &lt;code&gt;lroundf&lt;/code&gt;, &lt;code&gt;lroundl&lt;/code&gt;, &lt;code&gt;lround&lt;/code&gt;, &lt;code&gt;nearbyintf&lt;/code&gt;, &lt;code&gt;nearbyintl&lt;/code&gt;, &lt;code&gt;nearbyint&lt;/code&gt;, &lt;code&gt;nextafterf&lt;/code&gt;, &lt;code&gt;nextafterl&lt;/code&gt;, &lt;code&gt;nextafter&lt;/code&gt;, &lt;code&gt;nexttowardf&lt;/code&gt;, &lt;code&gt;nexttowardl&lt;/code&gt;, &lt;code&gt;nexttoward&lt;/code&gt;, &lt;code&gt;remainderf&lt;/code&gt;, &lt;code&gt;remainderl&lt;/code&gt;, &lt;code&gt;remainder&lt;/code&gt;, &lt;code&gt;remquof&lt;/code&gt;, &lt;code&gt;remquol&lt;/code&gt;, &lt;code&gt;remquo&lt;/code&gt;, &lt;code&gt;rintf&lt;/code&gt;, &lt;code&gt;rintl&lt;/code&gt;, &lt;code&gt;rint&lt;/code&gt;, &lt;code&gt;roundf&lt;/code&gt;, &lt;code&gt;roundl&lt;/code&gt;, &lt;code&gt;round&lt;/code&gt;, &lt;code&gt;scalblnf&lt;/code&gt;, &lt;code&gt;scalblnl&lt;/code&gt;, &lt;code&gt;scalbln&lt;/code&gt;, &lt;code&gt;scalbnf&lt;/code&gt;, &lt;code&gt;scalbnl&lt;/code&gt;, &lt;code&gt;scalbn&lt;/code&gt;, &lt;code&gt;snprintf&lt;/code&gt;, &lt;code&gt;tgammaf&lt;/code&gt;, &lt;code&gt;tgammal&lt;/code&gt;, &lt;code&gt;tgamma&lt;/code&gt;, &lt;code&gt;truncf&lt;/code&gt;, &lt;code&gt;truncl&lt;/code&gt;, &lt;code&gt;trunc&lt;/code&gt;, &lt;code&gt;vfscanf&lt;/code&gt;, &lt;code&gt;vscanf&lt;/code&gt;, &lt;code&gt;vsnprintf&lt;/code&gt; and &lt;code&gt;vsscanf&lt;/code&gt; are handled as built-in functions except in strict ISO C90 mode (</source>
          <target state="translated">이소 C99 함수 &lt;code&gt;_Exit&lt;/code&gt; , &lt;code&gt;acoshf&lt;/code&gt; , &lt;code&gt;acoshl&lt;/code&gt; , &lt;code&gt;acosh&lt;/code&gt; , &lt;code&gt;asinhf&lt;/code&gt; , &lt;code&gt;asinhl&lt;/code&gt; , &lt;code&gt;asinh&lt;/code&gt; , &lt;code&gt;atanhf&lt;/code&gt; , &lt;code&gt;atanhl&lt;/code&gt; , &lt;code&gt;atanh&lt;/code&gt; , &lt;code&gt;cabsf&lt;/code&gt; , &lt;code&gt;cabsl&lt;/code&gt; , &lt;code&gt;cabs&lt;/code&gt; , &lt;code&gt;cacosf&lt;/code&gt; , &lt;code&gt;cacoshf&lt;/code&gt; , &lt;code&gt;cacoshl&lt;/code&gt; , &lt;code&gt;cacosh&lt;/code&gt; , &lt;code&gt;cacosl&lt;/code&gt; , &lt;code&gt;cacos&lt;/code&gt; , &lt;code&gt;cargf&lt;/code&gt; , &lt;code&gt;cargl&lt;/code&gt; , &lt;code&gt;carg&lt;/code&gt; , &lt;code&gt;casinf&lt;/code&gt; , &lt;code&gt;casinhf&lt;/code&gt; , &lt;code&gt;casinhl&lt;/code&gt; , &lt;code&gt;casinh&lt;/code&gt; , &lt;code&gt;casinl&lt;/code&gt; , &lt;code&gt;casin&lt;/code&gt; , &lt;code&gt;catanf&lt;/code&gt; , &lt;code&gt;catanhf&lt;/code&gt; , &lt;code&gt;catanhl&lt;/code&gt; , &lt;code&gt;catanh&lt;/code&gt; , &lt;code&gt;catanl&lt;/code&gt; , &lt;code&gt;catan&lt;/code&gt; , &lt;code&gt;cbrtf&lt;/code&gt; , &lt;code&gt;cbrtl&lt;/code&gt; , &lt;code&gt;cbrt&lt;/code&gt; , &lt;code&gt;ccosf&lt;/code&gt; , &lt;code&gt;ccoshf&lt;/code&gt; , &lt;code&gt;ccoshl&lt;/code&gt; , &lt;code&gt;ccosh&lt;/code&gt; , &lt;code&gt;ccosl&lt;/code&gt; , &lt;code&gt;ccos&lt;/code&gt; , &lt;code&gt;cexpf&lt;/code&gt; , &lt;code&gt;cexpl&lt;/code&gt; , &lt;code&gt;cexp&lt;/code&gt; , &lt;code&gt;cimagf&lt;/code&gt; , &lt;code&gt;cimagl&lt;/code&gt; , &lt;code&gt;cimag&lt;/code&gt; , &lt;code&gt;clogf&lt;/code&gt; , &lt;code&gt;clogl&lt;/code&gt; , &lt;code&gt;clog&lt;/code&gt; , &lt;code&gt;conjf&lt;/code&gt; , &lt;code&gt;conjl&lt;/code&gt; , &lt;code&gt;conj&lt;/code&gt; , &lt;code&gt;copysignf&lt;/code&gt; , &lt;code&gt;copysignl&lt;/code&gt; , &lt;code&gt;copysign&lt;/code&gt; , &lt;code&gt;cpowf&lt;/code&gt; , &lt;code&gt;cpowl&lt;/code&gt; , &lt;code&gt;cpow&lt;/code&gt; , &lt;code&gt;cprojf&lt;/code&gt; , &lt;code&gt;cprojl&lt;/code&gt; , &lt;code&gt;cproj&lt;/code&gt; , &lt;code&gt;crealf&lt;/code&gt; , &lt;code&gt;creall&lt;/code&gt; , &lt;code&gt;creal&lt;/code&gt; , &lt;code&gt;csinf&lt;/code&gt; , &lt;code&gt;csinhf&lt;/code&gt; , &lt;code&gt;csinhl&lt;/code&gt; , &lt;code&gt;csinh&lt;/code&gt; , &lt;code&gt;csinl&lt;/code&gt; , &lt;code&gt;csin&lt;/code&gt; , &lt;code&gt;csqrtf&lt;/code&gt; , &lt;code&gt;csqrtl&lt;/code&gt; , &lt;code&gt;csqrt&lt;/code&gt; , &lt;code&gt;ctanf&lt;/code&gt; , &lt;code&gt;ctanhf&lt;/code&gt; , &lt;code&gt;ctanhl&lt;/code&gt; , &lt;code&gt;ctanh&lt;/code&gt; , &lt;code&gt;ctanl&lt;/code&gt; , &lt;code&gt;ctan&lt;/code&gt; , &lt;code&gt;erfcf&lt;/code&gt; , &lt;code&gt;erfcl&lt;/code&gt; , &lt;code&gt;erfc&lt;/code&gt; , &lt;code&gt;erff&lt;/code&gt; , &lt;code&gt;erfl&lt;/code&gt; , &lt;code&gt;erf&lt;/code&gt; , &lt;code&gt;exp2f&lt;/code&gt; , &lt;code&gt;exp2l&lt;/code&gt; , &lt;code&gt;exp2&lt;/code&gt; , &lt;code&gt;expm1f&lt;/code&gt; , &lt;code&gt;expm1l&lt;/code&gt; , &lt;code&gt;expm1&lt;/code&gt; , &lt;code&gt;fdimf&lt;/code&gt; , &lt;code&gt;fdiml&lt;/code&gt; , &lt;code&gt;fdim&lt;/code&gt; , &lt;code&gt;fmaf&lt;/code&gt; , &lt;code&gt;fmal&lt;/code&gt; , &lt;code&gt;fmaxf&lt;/code&gt; , &lt;code&gt;fmaxl&lt;/code&gt; , &lt;code&gt;fmax&lt;/code&gt; , &lt;code&gt;fma&lt;/code&gt; , &lt;code&gt;fminf&lt;/code&gt; , &lt;code&gt;fminl&lt;/code&gt; , &lt;code&gt;fmin&lt;/code&gt; , &lt;code&gt;hypotf&lt;/code&gt; , &lt;code&gt;hypotl&lt;/code&gt; , &lt;code&gt;hypot&lt;/code&gt; , &lt;code&gt;ilogbf&lt;/code&gt; , &lt;code&gt;ilogbl&lt;/code&gt; , &lt;code&gt;ilogb&lt;/code&gt; , &lt;code&gt;imaxabs&lt;/code&gt; , &lt;code&gt;isblank&lt;/code&gt; , &lt;code&gt;iswblank&lt;/code&gt; , &lt;code&gt;lgammaf&lt;/code&gt; , &lt;code&gt;lgammal&lt;/code&gt; , &lt;code&gt;lgamma&lt;/code&gt; , &lt;code&gt;llabs&lt;/code&gt; , &lt;code&gt;llrintf&lt;/code&gt; , &lt;code&gt;llrintl&lt;/code&gt; , &lt;code&gt;llrint&lt;/code&gt; , &lt;code&gt;llroundf&lt;/code&gt; , &lt;code&gt;llroundl&lt;/code&gt; , &lt;code&gt;llround&lt;/code&gt; , &lt;code&gt;log1pf&lt;/code&gt; , &lt;code&gt;log1pl&lt;/code&gt; , &lt;code&gt;log1p&lt;/code&gt; , &lt;code&gt;log2f&lt;/code&gt; , &lt;code&gt;log2l&lt;/code&gt; , &lt;code&gt;log2&lt;/code&gt; , &lt;code&gt;logbf&lt;/code&gt; , &lt;code&gt;logbl&lt;/code&gt; , &lt;code&gt;logb&lt;/code&gt; 에 , &lt;code&gt;lrintf&lt;/code&gt; , &lt;code&gt;lrintl&lt;/code&gt; , &lt;code&gt;lrint&lt;/code&gt; , &lt;code&gt;lroundf&lt;/code&gt; , &lt;code&gt;lroundl&lt;/code&gt; , &lt;code&gt;lround&lt;/code&gt; , &lt;code&gt;nearbyintf&lt;/code&gt; , &lt;code&gt;nearbyintl&lt;/code&gt; , &lt;code&gt;nearbyint&lt;/code&gt; , &lt;code&gt;nextafterf&lt;/code&gt; , &lt;code&gt;nextafterl&lt;/code&gt; , &lt;code&gt;nextafter&lt;/code&gt; , &lt;code&gt;nexttowardf&lt;/code&gt; , &lt;code&gt;nexttowardl&lt;/code&gt; , &lt;code&gt;nexttoward&lt;/code&gt; , &lt;code&gt;remainderf&lt;/code&gt; , &lt;code&gt;remainderl&lt;/code&gt; , &lt;code&gt;remainder&lt;/code&gt; , &lt;code&gt;remquof&lt;/code&gt; , &lt;code&gt;remquol&lt;/code&gt; , &lt;code&gt;remquo&lt;/code&gt; , &lt;code&gt;rintf&lt;/code&gt; , &lt;code&gt;rintl&lt;/code&gt; , &lt;code&gt;rint&lt;/code&gt; , &lt;code&gt;roundf&lt;/code&gt; , &lt;code&gt;roundl&lt;/code&gt; , &lt;code&gt;round&lt;/code&gt; , &lt;code&gt;scalblnf&lt;/code&gt; , &lt;code&gt;scalblnl&lt;/code&gt; , &lt;code&gt;scalbln&lt;/code&gt; , &lt;code&gt;scalbnf&lt;/code&gt; , &lt;code&gt;scalbnl&lt;/code&gt; , &lt;code&gt;scalbn&lt;/code&gt; , &lt;code&gt;snprintf&lt;/code&gt; , &lt;code&gt;tgammaf&lt;/code&gt; , &lt;code&gt;tgammal&lt;/code&gt; , &lt;code&gt;tgamma&lt;/code&gt; , &lt;code&gt;truncf&lt;/code&gt; , &lt;code&gt;truncl&lt;/code&gt; , &lt;code&gt;trunc&lt;/code&gt; , &lt;code&gt;vfscanf&lt;/code&gt; , &lt;code&gt;vscanf&lt;/code&gt; , &lt;code&gt;vsnprintf&lt;/code&gt; 및 &lt;code&gt;vsscanf&lt;/code&gt; 는 엄격한 ISO C90 모드를 제외하고 내장 함수로 처리됩니다 (</target>
        </trans-unit>
        <trans-unit id="2784e50b776c95c529ea8bb486ce2750890944bf" translate="yes" xml:space="preserve">
          <source>The ISO type of an integer constant has a different width or signedness from its traditional type. This warning is only issued if the base of the constant is ten. I.e. hexadecimal or octal values, which typically represent bit patterns, are not warned about.</source>
          <target state="translated">정수 상수의 ISO 유형은 기존 유형과 너비 또는 부호가 다릅니다. 이 경고는 상수의 밑이 10 인 경우에만 발행됩니다. 즉, 일반적으로 비트 패턴을 나타내는 16 진 또는 8 진 값은 경고하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="82a12be836835137fbdc59e2c7d2766dbca00a8c" translate="yes" xml:space="preserve">
          <source>The JSON is emitted as one line, without formatting; the examples below have been formatted for clarity.</source>
          <target state="translated">JSON은 형식화없이 한 줄로 생성됩니다. 아래 예제는 명확성을 위해 형식화되었습니다.</target>
        </trans-unit>
        <trans-unit id="a08b3636d7c444216df0829b96c5cf7186a63397" translate="yes" xml:space="preserve">
          <source>The M-Profile Vector Extension (MVE) integer and single precision floating-point instructions.</source>
          <target state="translated">MVE (M-Profile Vector Extension) 정수 및 단 정밀도 부동 소수점 명령어입니다.</target>
        </trans-unit>
        <trans-unit id="121628a4764ae0bea2f22e038677fd81cecafe48" translate="yes" xml:space="preserve">
          <source>The M-Profile Vector Extension (MVE) integer instructions.</source>
          <target state="translated">MVE (M-Profile Vector Extension) 정수 명령어입니다.</target>
        </trans-unit>
        <trans-unit id="4a22ef3a7780246abe5b933d687f802ceaac7fd9" translate="yes" xml:space="preserve">
          <source>The MIPS DSP Application-Specific Extension (ASE) includes new instructions that are designed to improve the performance of DSP and media applications. It provides instructions that operate on packed 8-bit/16-bit integer data, Q7, Q15 and Q31 fractional data.</source>
          <target state="translated">MIPS DSP ASE (Application-Specific Extension)에는 DSP 및 미디어 응용 프로그램의 성능을 향상 시키도록 설계된 새로운 명령이 포함되어 있습니다. 팩형 8 비트 / 16 비트 정수 데이터, Q7, Q15 및 Q31 분수 데이터에서 작동하는 명령어를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f5ed4155655f597ba1ea8fb1a082975a691dee38" translate="yes" xml:space="preserve">
          <source>The MIPS-3D Application-Specific Extension (ASE) includes additional paired-single instructions that are designed to improve the performance of 3D graphics operations. Support for these instructions is controlled by the</source>
          <target state="translated">MIPS-3D ASE (Application-Specific Extension)에는 3D 그래픽 작업의 성능을 향상 시키도록 설계된 추가 단일 쌍 명령이 포함되어 있습니다. 이 지침에 대한 지원은</target>
        </trans-unit>
        <trans-unit id="2568887586875d72638add2c316850a652079522" translate="yes" xml:space="preserve">
          <source>The MIPS64 architecture includes a number of instructions that operate on pairs of single-precision floating-point values. Each pair is packed into a 64-bit floating-point register, with one element being designated the &amp;ldquo;upper half&amp;rdquo; and the other being designated the &amp;ldquo;lower half&amp;rdquo;.</source>
          <target state="translated">MIPS64 아키텍처에는 단 정밀도 부동 소수점 값 쌍에서 작동하는 많은 명령이 포함되어 있습니다. 각 쌍은 64 비트 부동 소수점 레지스터로 압축되며 한 요소는 &quot;상반부&quot;로 지정되고 다른 요소는 &quot;하반부&quot;로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="19791c6fc0c7878cc7c0d81440fdc8b3deac6cc4" translate="yes" xml:space="preserve">
          <source>The MSP430 hardware ensures that interrupts are disabled on entry to &lt;code&gt;interrupt&lt;/code&gt; functions, and restores the previous interrupt state on exit. The &lt;code&gt;critical&lt;/code&gt; attribute is therefore redundant on &lt;code&gt;interrupt&lt;/code&gt; functions.</source>
          <target state="translated">MSP430 하드웨어는 진입시 &lt;code&gt;interrupt&lt;/code&gt; 기능 이 비활성화되도록 하고 종료시 이전 인터럽트 상태를 복원합니다. 따라서 &lt;code&gt;critical&lt;/code&gt; 특성은 &lt;code&gt;interrupt&lt;/code&gt; 기능에서 중복됩니다 .</target>
        </trans-unit>
        <trans-unit id="324add0fab22223316ad270b660243d491e201b4" translate="yes" xml:space="preserve">
          <source>The MeP target has a number of addressing modes and busses. The &lt;code&gt;near&lt;/code&gt; space spans the standard memory space&amp;rsquo;s first 16 megabytes (24 bits). The &lt;code&gt;far&lt;/code&gt; space spans the entire 32-bit memory space. The &lt;code&gt;based&lt;/code&gt; space is a 128-byte region in the memory space that is addressed relative to the &lt;code&gt;$tp&lt;/code&gt; register. The &lt;code&gt;tiny&lt;/code&gt; space is a 65536-byte region relative to the &lt;code&gt;$gp&lt;/code&gt; register. In addition to these memory regions, the MeP target has a separate 16-bit control bus which is specified with &lt;code&gt;cb&lt;/code&gt; attributes.</source>
          <target state="translated">MeP 대상에는 여러 주소 지정 모드와 버스가 있습니다. &lt;code&gt;near&lt;/code&gt; 공간 표준 메모리 공간의 처음 16 메가 바이트 (24 비트)에 걸쳐있다. &lt;code&gt;far&lt;/code&gt; 공간 전체에 걸쳐있는 32 비트의 메모리 공간. &lt;code&gt;based&lt;/code&gt; 공간은 상대적인 어드레싱되는 메모리 공간의 128 바이트 영역 인 &lt;code&gt;$tp&lt;/code&gt; 레지스터. &lt;code&gt;tiny&lt;/code&gt; 공간은에 65536 바이트 지역 기준으로 &lt;code&gt;$gp&lt;/code&gt; 등록합니다. 이러한 메모리 영역 외에도 MeP 대상에는 &lt;code&gt;cb&lt;/code&gt; 속성으로 지정된 별도의 16 비트 제어 버스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d8a7015c96baf068daea7c993c23e530f568f5f" translate="yes" xml:space="preserve">
          <source>The Medium/Anywhere code model for embedded systems: 64-bit addresses, the text and data segments must be less than 2GB in size, both starting anywhere in memory (determined at link time). The global register %g4 points to the base of the data segment. Programs are statically linked and PIC is not supported.</source>
          <target state="translated">임베디드 시스템을위한 중간 / 어디에나 코드 모델 : 64 비트 주소, 텍스트 및 데이터 세그먼트의 크기는 메모리의 어느 곳에서나 (링크 타임에 결정됨) 2GB보다 작아야합니다. 글로벌 레지스터 % g4는 데이터 세그먼트의베이스를 가리 킵니다. 프로그램은 정적으로 링크되어 있으며 PIC는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cc31a18cddf7a0f78efe693458fe2d9afe6d7019" translate="yes" xml:space="preserve">
          <source>The Medium/Anywhere code model: 64-bit addresses, programs may be linked anywhere in memory, the text and data segments must be less than 2GB in size and the data segment must be located within 2GB of the text segment.</source>
          <target state="translated">Medium / Anywhere 코드 모델 : 64 비트 주소, 프로그램은 메모리의 어느 위치 에나 연결될 수 있으며 텍스트 및 데이터 세그먼트의 크기는 2GB보다 작아야하고 데이터 세그먼트는 텍스트 세그먼트의 2GB 내에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="7e3c5ad40e25357a2525dfa3cd571c1d3bd7d34a" translate="yes" xml:space="preserve">
          <source>The Medium/Low code model: 64-bit addresses, programs must be linked in the low 32 bits of memory. Programs can be statically or dynamically linked.</source>
          <target state="translated">보통 / 낮은 코드 모델 : 64 비트 주소, 프로그램은 낮은 32 비트 메모리에 연결되어야합니다. 프로그램은 정적으로 또는 동적으로 링크 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b39ba546b4adedbbf99b1b31d01ec7fac76520a" translate="yes" xml:space="preserve">
          <source>The Medium/Middle code model: 64-bit addresses, programs must be linked in the low 44 bits of memory, the text and data segments must be less than 2GB in size and the data segment must be located within 2GB of the text segment.</source>
          <target state="translated">중간 / 중간 코드 모델 : 64 비트 주소, 프로그램은 하위 44 비트 메모리에 연결되어야하며 텍스트 및 데이터 세그먼트의 크기는 2GB보다 작아야하며 데이터 세그먼트는 텍스트 세그먼트의 2GB 내에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="da2b29936b818cfc1e5a3a58f7738a9fa0c881c1" translate="yes" xml:space="preserve">
          <source>The Microsoft structure layout algorithm is fairly simple with the exception of the bit-field packing. The padding and alignment of members of structures and whether a bit-field can straddle a storage-unit boundary are determine by these rules:</source>
          <target state="translated">비트 필드 패킹을 제외하고 Microsoft 구조 레이아웃 알고리즘은 매우 간단합니다. 구조 멤버의 패딩 및 정렬과 비트 필드가 저장 장치 경계를 걸을 수 있는지 여부는 다음 규칙에 따라 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="aeff520b5677f801f6da4eeb7f1e51a9a569cd01" translate="yes" xml:space="preserve">
          <source>The NOP instructions are inserted at&amp;mdash;and maybe before, depending on &lt;var&gt;M&lt;/var&gt;&amp;mdash;the function entry address, even before the prologue.</source>
          <target state="translated">NOP 명령어는 프롤로그 앞에도 기능 입력 주소 앞에 (어쩌면 &lt;var&gt;M&lt;/var&gt; 에 따라) 삽입 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff55b141ae724be4a1c090f09197c4cc8d0b49e5" translate="yes" xml:space="preserve">
          <source>The Objective-C 2.0 language extensions and features are automatically enabled; they include properties (via the &lt;code&gt;@property&lt;/code&gt;, &lt;code&gt;@synthesize&lt;/code&gt; and &lt;code&gt;@dynamic keywords&lt;/code&gt;), fast enumeration (not available in Objective-C++), attributes for methods (such as &lt;code&gt;deprecated&lt;/code&gt;, &lt;code&gt;noreturn&lt;/code&gt;, &lt;code&gt;sentinel&lt;/code&gt;, &lt;code&gt;format&lt;/code&gt;), the &lt;code&gt;unused&lt;/code&gt; attribute for method arguments, the &lt;code&gt;@package&lt;/code&gt; keyword for instance variables and the &lt;code&gt;@optional&lt;/code&gt; and &lt;code&gt;@required&lt;/code&gt; keywords in protocols. You can disable all these Objective-C 2.0 language extensions with the option</source>
          <target state="translated">Objective-C 2.0 언어 확장 및 기능은 자동으로 사용 가능합니다. 속성 ( &lt;code&gt;@property&lt;/code&gt; , &lt;code&gt;@synthesize&lt;/code&gt; 및 &lt;code&gt;@dynamic keywords&lt;/code&gt; ), 빠른 열거 (Objective-C ++에서는 사용할 수 없음), 메소드 속성 (예 : &lt;code&gt;deprecated&lt;/code&gt; , &lt;code&gt;noreturn&lt;/code&gt; , &lt;code&gt;sentinel&lt;/code&gt; , &lt;code&gt;format&lt;/code&gt; ), 메소드 인수에 &lt;code&gt;unused&lt;/code&gt; 속성, 인스턴스 변수 의 &lt;code&gt;@package&lt;/code&gt; 키워드 및 프로토콜 의 &lt;code&gt;@optional&lt;/code&gt; 및 &lt;code&gt;@required&lt;/code&gt; 키워드 옵션을 사용하여 이러한 Objective-C 2.0 언어 확장을 모두 비활성화 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="c6923a9108193e35102064afa9eda743cb37bdd9" translate="yes" xml:space="preserve">
          <source>The Objective-C compiler generates type encodings for all the types. These type encodings are used at runtime to find out information about selectors and methods and about objects and classes.</source>
          <target state="translated">Objective-C 컴파일러는 모든 유형에 대한 유형 인코딩을 생성합니다. 이러한 유형 인코딩은 런타임시 선택기 및 메소드와 객체 및 클래스에 대한 정보를 찾기 위해 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e464bd6510d0d75994dbae5961cb9df5baed7b28" translate="yes" xml:space="preserve">
          <source>The Objective-C exception and synchronization syntax (that is, the keywords &lt;code&gt;@try&lt;/code&gt;, &lt;code&gt;@throw&lt;/code&gt;, &lt;code&gt;@catch&lt;/code&gt;, &lt;code&gt;@finally&lt;/code&gt; and &lt;code&gt;@synchronized&lt;/code&gt;) is supported by GCC and is enabled with the option</source>
          <target state="translated">Objective-C 예외 및 동기화 구문 (즉, 키워드 &lt;code&gt;@try&lt;/code&gt; , &lt;code&gt;@throw&lt;/code&gt; , &lt;code&gt;@catch&lt;/code&gt; , &lt;code&gt;@finally&lt;/code&gt; 및 &lt;code&gt;@synchronized&lt;/code&gt; )은 GCC에서 지원되며 옵션으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="504b920d3ddaa29eaf4f4d2837867a09bb928c21" translate="yes" xml:space="preserve">
          <source>The One Definition Rule is relaxed for types without explicit visibility specifications that are defined in more than one shared object: those declarations are permitted if they are permitted when this option is not used.</source>
          <target state="translated">하나 이상의 정의 규칙은 둘 이상의 공유 객체에 정의 된 명시 적 가시성 사양이없는 유형에 적합합니다.이 옵션을 사용하지 않을 때 허용되는 경우 이러한 선언이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="2d22810fdfaa073bc94d2050ac8533154c085f11" translate="yes" xml:space="preserve">
          <source>The RL78 back end supports the &lt;code&gt;saddr&lt;/code&gt; variable attribute. This specifies placement of the corresponding variable in the SADDR area, which can be accessed more efficiently than the default memory region.</source>
          <target state="translated">RL78 백엔드는 &lt;code&gt;saddr&lt;/code&gt; 변수 속성을 지원 합니다. 이는 기본 메모리 영역보다 더 효율적으로 액세스 할 수있는 SADDR 영역에 해당 변수의 배치를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="1c75a1f23dddf5a55d85a877757468d10500aab3" translate="yes" xml:space="preserve">
          <source>The RS/6000 and PowerPC targets define one pragma for controlling whether or not the &lt;code&gt;longcall&lt;/code&gt; attribute is added to function declarations by default. This pragma overrides the</source>
          <target state="translated">RS / 6000 및 PowerPC 대상 은 기본적으로 &lt;code&gt;longcall&lt;/code&gt; 속성이 함수 선언에 추가 되는지 여부를 제어하기위한 하나의 pragma를 정의합니다 . 이 pragma는</target>
        </trans-unit>
        <trans-unit id="549fc0bcd99c9fa57f4b149326299d99007e47ae" translate="yes" xml:space="preserve">
          <source>The SCOUNT and POS bits of the DSP control register are global. The WRDSP, EXTPDP, EXTPDPV and MTHLIP instructions modify the SCOUNT and POS bits. During optimization, the compiler does not delete these instructions and it does not delete calls to functions containing these instructions.</source>
          <target state="translated">DSP 제어 레지스터의 SCOUNT 및 POS 비트는 글로벌입니다. WRDSP, EXTPDP, EXTPDPV 및 MTHLIP 명령어는 SCOUNT 및 POS 비트를 수정합니다. 최적화 중에 컴파일러는 이러한 명령어를 삭제하지 않으며 이러한 명령어가 포함 된 함수에 대한 호출을 삭제하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="feed8b7325d666bcdf4c1efd5aa692caea9e4e2d" translate="yes" xml:space="preserve">
          <source>The SPU supports the &lt;code&gt;spu_vector&lt;/code&gt; attribute for variables. For documentation of this attribute please see the documentation in &lt;a href=&quot;type-attributes#SPU-Type-Attributes&quot;&gt;SPU Type Attributes&lt;/a&gt;.</source>
          <target state="translated">SPU는 변수에 대한 &lt;code&gt;spu_vector&lt;/code&gt; 속성을 지원합니다 . 이 속성에 대한 설명서는 &lt;a href=&quot;type-attributes#SPU-Type-Attributes&quot;&gt;SPU 유형 속성&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e00194fefd3abe9f6e9c4ed0e24c5f1cdb3e71d6" translate="yes" xml:space="preserve">
          <source>The Solaris target supports &lt;code&gt;#pragma redefine_extname&lt;/code&gt; (see &lt;a href=&quot;symbol_002drenaming-pragmas#Symbol_002dRenaming-Pragmas&quot;&gt;Symbol-Renaming Pragmas&lt;/a&gt;). It also supports additional &lt;code&gt;#pragma&lt;/code&gt; directives for compatibility with the system compiler.</source>
          <target state="translated">Solaris 대상은 &lt;code&gt;#pragma redefine_extname&lt;/code&gt; 을 지원합니다 ( &lt;a href=&quot;symbol_002drenaming-pragmas#Symbol_002dRenaming-Pragmas&quot;&gt;Symbol-Renaming Pragmas&lt;/a&gt; 참조 ). 또한 시스템 컴파일러와의 호환성을 위해 추가 &lt;code&gt;#pragma&lt;/code&gt; 지시문을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="b577e7bfa4d5d277a90aa967bc9fa309870fa29b" translate="yes" xml:space="preserve">
          <source>The V850 back end supports these function attributes:</source>
          <target state="translated">V850 백엔드는 다음 기능 속성을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="87ba99adc7a79652db01be899ada60245b8a9d21" translate="yes" xml:space="preserve">
          <source>The VFPv2 floating-point instructions. The extension &amp;lsquo;</source>
          <target state="translated">VFPv2 부동 소수점 명령어. 확장 '</target>
        </trans-unit>
        <trans-unit id="259f6621f353addf35de203c6cc21ec70166871f" translate="yes" xml:space="preserve">
          <source>The VFPv3 floating-point instructions with 16 double-precision registers and the half-precision floating-point conversion operations.</source>
          <target state="translated">16 개의 배정 밀도 레지스터와 반 정밀도 부동 소수점 변환 연산이있는 VFPv3 부동 소수점 명령어.</target>
        </trans-unit>
        <trans-unit id="69bbc2d35ac5910370025649743d2c9e7aba8bec" translate="yes" xml:space="preserve">
          <source>The VFPv3 floating-point instructions with 16 double-precision registers. The extension +vfpv3-d16 can be used as an alias for this extension.</source>
          <target state="translated">16 개의 배정 밀도 레지스터가있는 VFPv3 부동 소수점 명령어. 확장자 + vfpv3-d16을이 확장자의 별명으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d392f4c1ad45a7ce6a0755dbe2047b64e45ba0e" translate="yes" xml:space="preserve">
          <source>The VFPv3 floating-point instructions, with 16 double-precision registers and the half-precision floating-point conversion operations.</source>
          <target state="translated">16 개의 배정 밀도 레지스터와 반 정밀도 부동 소수점 변환 연산이 포함 된 VFPv3 부동 소수점 명령어.</target>
        </trans-unit>
        <trans-unit id="9ea0bf30af6241dd74e66058037f24ca2aa3b024" translate="yes" xml:space="preserve">
          <source>The VFPv3 floating-point instructions, with 16 double-precision registers.</source>
          <target state="translated">16 개의 배정 밀도 레지스터가있는 VFPv3 부동 소수점 명령어.</target>
        </trans-unit>
        <trans-unit id="8c44d40609c70bac64a3214e9aba6ea5f2799b31" translate="yes" xml:space="preserve">
          <source>The VFPv3 floating-point instructions, with 16 double-precision registers. The extension &amp;lsquo;</source>
          <target state="translated">16 개의 배정 밀도 레지스터가있는 VFPv3 부동 소수점 명령어. 확장 '</target>
        </trans-unit>
        <trans-unit id="69ba42177cf602fb7a0ed600eac827a8de6a449b" translate="yes" xml:space="preserve">
          <source>The VFPv3 floating-point instructions, with 32 double-precision registers and the half-precision floating-point conversion operations.</source>
          <target state="translated">32 개의 배정 밀도 레지스터와 반 정밀도 부동 소수점 변환 연산이있는 VFPv3 부동 소수점 명령어.</target>
        </trans-unit>
        <trans-unit id="193d13643a69320727d206517bd62145a8c8f03c" translate="yes" xml:space="preserve">
          <source>The VFPv3 floating-point instructions, with 32 double-precision registers.</source>
          <target state="translated">32 개의 배정 밀도 레지스터가있는 VFPv3 부동 소수점 명령어.</target>
        </trans-unit>
        <trans-unit id="a0936e97cd9c57c2c85efdbe6388f42baca5f03d" translate="yes" xml:space="preserve">
          <source>The VFPv4 floating-point instructions, with 16 double-precision registers.</source>
          <target state="translated">16 개의 배정 밀도 레지스터가있는 VFPv4 부동 소수점 명령어.</target>
        </trans-unit>
        <trans-unit id="103d1acc3dfe417798e6bd838ba4fc9709451552" translate="yes" xml:space="preserve">
          <source>The VFPv4 floating-point instructions, with 16 double-precision registers. The extension &amp;lsquo;</source>
          <target state="translated">16 개의 배정 밀도 레지스터가있는 VFPv4 부동 소수점 명령어. 확장 '</target>
        </trans-unit>
        <trans-unit id="06ddcf864547f4dbeda808689e788fca6e819171" translate="yes" xml:space="preserve">
          <source>The VFPv4 floating-point instructions, with 32 double-precision registers.</source>
          <target state="translated">32 개의 배정 밀도 레지스터가있는 VFPv4 부동 소수점 명령어.</target>
        </trans-unit>
        <trans-unit id="9285ccf7646c59c98d31930bdd84e56c45d5fd26" translate="yes" xml:space="preserve">
          <source>The VR4130 pipeline is two-way superscalar, but can only issue two instructions together if the first one is 8-byte aligned. When this option is enabled, GCC aligns pairs of instructions that it thinks should execute in parallel.</source>
          <target state="translated">VR4130 파이프 라인은 양방향 슈퍼 스칼라이지만 첫 번째 명령이 8 바이트로 정렬 된 경우 두 명령 만 함께 발행 할 수 있습니다. 이 옵션을 사용하면 GCC는 병렬로 실행해야한다고 생각되는 명령어 쌍을 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="cb154aff394215a4189b3dafa08992907beaeea3" translate="yes" xml:space="preserve">
          <source>The VSX instruction set (</source>
          <target state="translated">VSX 명령어 세트 (</target>
        </trans-unit>
        <trans-unit id="5a0171ba1b31d3315fbbfaace918d589c6b61613" translate="yes" xml:space="preserve">
          <source>The abbreviation &lt;em&gt;GCC&lt;/em&gt; has multiple meanings in common use. The current official meaning is &amp;ldquo;GNU Compiler Collection&amp;rdquo;, which refers generically to the complete suite of tools. The name historically stood for &amp;ldquo;GNU C Compiler&amp;rdquo;, and this usage is still common when the emphasis is on compiling C programs. Finally, the name is also used when speaking of the &lt;em&gt;language-independent&lt;/em&gt; component of GCC: code shared among the compilers for all supported languages.</source>
          <target state="translated">약어 &lt;em&gt;GCC&lt;/em&gt; 는 일반적으로 사용되는 여러 가지 의미를 갖습니다. 현재 공식적인 의미는&amp;ldquo;GNU Compiler Collection&amp;rdquo;이며, 이는 일반적으로 전체 도구 모음을 나타냅니다. 그 이름은 역사적으로&amp;ldquo;GNU C Compiler&amp;rdquo;의 약자였으며,이 사용법은 C 프로그램 컴파일에 중점을두고있을 때 여전히 일반적입니다. 마지막으로, 이름은 GCC 의 &lt;em&gt;언어 독립적 인&lt;/em&gt; 구성 요소를 말할 때도 사용됩니다 . 지원되는 모든 언어에 대해 컴파일러간에 공유되는 코드입니다.</target>
        </trans-unit>
        <trans-unit id="3a9d23d169ba3b72eeef6725cec43a13a50013c2" translate="yes" xml:space="preserve">
          <source>The above generates bytecode for</source>
          <target state="translated">위의 바이트 코드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="34a36dd9deec63b753f5d433c0dd87cbce7edcf4" translate="yes" xml:space="preserve">
          <source>The above lines are equivalent to the following:</source>
          <target state="translated">위의 줄은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a39976e643ac6d1dc6fe3e4366ed3a13dea2466b" translate="yes" xml:space="preserve">
          <source>The above target attributes can be specified as follows:</source>
          <target state="translated">위의 대상 속성은 다음과 같이 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed1f637f7dae694f5c4cfc72955bdf63e2cee6a2" translate="yes" xml:space="preserve">
          <source>The accuracy is unknown.</source>
          <target state="translated">정확도는 알려져 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="120b6f184277986efda6f906c93a195e4dc7e853" translate="yes" xml:space="preserve">
          <source>The accuracy of the floating-point operations and of the library functions in &lt;code&gt;&amp;lt;math.h&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt; that return floating-point results (C90, C99 and C11 5.2.4.2.2).</source>
          <target state="translated">부동 소수점 결과를 반환하는 &lt;code&gt;&amp;lt;math.h&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt; 의 부동 소수점 연산 및 라이브러리 함수의 정확성 (C90, C99 및 C11 5.2.4.2.2).</target>
        </trans-unit>
        <trans-unit id="80f0b076d52d6244bc6636b163e80827a773f50c" translate="yes" xml:space="preserve">
          <source>The actual register chosen to hold the constant data base address depends upon whether the</source>
          <target state="translated">일정한 데이터베이스 주소를 유지하기 위해 선택된 실제 레지스터는</target>
        </trans-unit>
        <trans-unit id="a30a65f7051569a9a9c6241a0c50efdd3d1de863" translate="yes" xml:space="preserve">
          <source>The added &lt;var&gt;flag&lt;/var&gt; argument is passed unchanged to &lt;code&gt;__sprintf_chk&lt;/code&gt; etc. functions and can contain implementation specific flags on what additional security measures the checking function might take, such as handling &lt;code&gt;%n&lt;/code&gt; differently.</source>
          <target state="translated">추가 된 &lt;var&gt;flag&lt;/var&gt; 인수는 &lt;code&gt;__sprintf_chk&lt;/code&gt; 등의 함수로 변경되지 않고 전달 되며 검사 기능이 수행 할 수있는 추가 보안 조치 (예 : &lt;code&gt;%n&lt;/code&gt; 다르게 처리)에 대한 구현 특정 플래그를 포함 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8e6f66f554f454fd60e4196cbe8c25320dedb4b7" translate="yes" xml:space="preserve">
          <source>The added comments include:</source>
          <target state="translated">추가 된 의견은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5c6f1012ead9ec76811fd2e9243c4b72f326472d" translate="yes" xml:space="preserve">
          <source>The additional block information is of the form</source>
          <target state="translated">추가 블록 정보는 형식입니다</target>
        </trans-unit>
        <trans-unit id="79eafbe5ef62b1bf562656c8ccc8660f517c4542" translate="yes" xml:space="preserve">
          <source>The address as returned by &lt;code&gt;__builtin_return_address&lt;/code&gt; may have to be fed through this function to get the actual encoded address. For example, on the 31-bit S/390 platform the highest bit has to be masked out, or on SPARC platforms an offset has to be added for the true next instruction to be executed.</source>
          <target state="translated">&lt;code&gt;__builtin_return_address&lt;/code&gt; 에 의해 반환 된 주소는 이 코드를 통해 실제 인코딩 된 주소를 가져와야합니다. 예를 들어, 31 비트 S / 390 플랫폼에서 가장 높은 비트를 마스크하거나 SPARC 플랫폼에서 다음 명령을 실행하려면 오프셋을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="9133fefd38b502d139962641eb1473acc29ca6ef" translate="yes" xml:space="preserve">
          <source>The addressability of a particular object can be set with the &lt;code&gt;model&lt;/code&gt; attribute.</source>
          <target state="translated">특정 객체의 주소 지정 가능성은 &lt;code&gt;model&lt;/code&gt; 속성 으로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8b38ea0caa823f37a2f086f0d1bc57b4b47d283c" translate="yes" xml:space="preserve">
          <source>The alignment of non-bit-field members of structures (C90 6.5.2.1, C99 and C11 6.7.2.1).</source>
          <target state="translated">비 비트 필드 구성원 구조의 정렬 (C90 6.5.2.1, C99 및 C11 6.7.2.1).</target>
        </trans-unit>
        <trans-unit id="322481284c6908feb9887b9dd7bb912960123985" translate="yes" xml:space="preserve">
          <source>The alternate keywords &lt;code&gt;__asm__&lt;/code&gt;, &lt;code&gt;__extension__&lt;/code&gt;, &lt;code&gt;__inline__&lt;/code&gt; and &lt;code&gt;__typeof__&lt;/code&gt; continue to work despite</source>
          <target state="translated">대체 키워드 &lt;code&gt;__asm__&lt;/code&gt; , &lt;code&gt;__extension__&lt;/code&gt; , &lt;code&gt;__inline__&lt;/code&gt; 및 &lt;code&gt;__typeof__&lt;/code&gt; 은 계속 작동하지만</target>
        </trans-unit>
        <trans-unit id="8e728c9fa7b9e6ce4962fad39896909da2bde1ee" translate="yes" xml:space="preserve">
          <source>The analogous feature in Fortran is called an assigned goto, but that name seems inappropriate in C, where one can do more than simply store label addresses in label variables.</source>
          <target state="translated">Fortran의 유사한 기능을 할당 된 goto라고하지만이 이름은 C에서 부적절 해 보입니다. 여기서는 레이블 주소에 레이블 주소를 저장하는 것 이상을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14c11777761d5f46c1a9fb516ac0c2ee4a9cb68d" translate="yes" xml:space="preserve">
          <source>The application binary interface implemented by a C or C++ compiler affects code generation and runtime support for:</source>
          <target state="translated">C 또는 C ++ 컴파일러로 구현 된 응용 프로그램 바이너리 인터페이스는 다음에 대한 코드 생성 및 런타임 지원에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="29b549ce42574a44cc4510011757b7ba9fd1935c" translate="yes" xml:space="preserve">
          <source>The approximate maximum amount of memory that can be allocated in order to perform the global common subexpression elimination optimization. If more memory than specified is required, the optimization is not done.</source>
          <target state="translated">전역 공통 하위 표현식 제거 최적화를 수행하기 위해 할당 할 수있는 대략적인 최대 메모리 양입니다. 지정된 것보다 많은 메모리가 필요한 경우 최적화가 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="01165ed876927994264f7a9cab383ccc4af10540" translate="yes" xml:space="preserve">
          <source>The argument can be a list of strings of arbitrary length. The strings are sorted on output, so the order of the list is unimportant.</source>
          <target state="translated">인수는 임의 길이의 문자열 목록 일 수 있습니다. 문자열은 출력에 따라 정렬되므로 목록의 순서는 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="59d49582cbfaa16c6712e0f374a5a6c15a857459" translate="yes" xml:space="preserve">
          <source>The argument to</source>
          <target state="translated">에 대한 논쟁</target>
        </trans-unit>
        <trans-unit id="d44a319a963da0f3902d413f244d251258e282dd" translate="yes" xml:space="preserve">
          <source>The arguments to &lt;code&gt;__builtin_tgmath&lt;/code&gt; are at least two pointers to functions, followed by the arguments to the type-generic macro (which will be passed as arguments to the selected function). All the pointers to functions must be pointers to prototyped functions, none of which may have variable arguments, and all of which must have the same number of parameters; the number of parameters of the first function determines how many arguments to &lt;code&gt;__builtin_tgmath&lt;/code&gt; are interpreted as function pointers, and how many as the arguments to the called function.</source>
          <target state="translated">&lt;code&gt;__builtin_tgmath&lt;/code&gt; 에 대한 인수는 함수 에 대한 포인터 두 개 이상이며 유형-일반 매크로에 대한 인수 (선택한 함수에 인수로 전달됨)입니다. 함수에 대한 모든 포인터는 프로토 타입 함수에 대한 포인터 여야하며,이 중 어느 것도 변수 인수를 가질 수 없으며, 모두 동일한 수의 매개 변수를 가져야합니다. 첫 번째 함수의 매개 변수 수에 따라 &lt;code&gt;__builtin_tgmath&lt;/code&gt; 에 대한 인수 수 는 함수 포인터로 해석되고 호출 된 함수에 대한 인수 수는 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="966ac956bf197ec8f0ba6771423c919858f24a7d" translate="yes" xml:space="preserve">
          <source>The arguments to the built-in functions can be divided into three groups: register numbers, compile-time constants and run-time values. In order to make this classification clear at a glance, the arguments and return values are given the following pseudo types:</source>
          <target state="translated">내장 함수에 대한 인수는 레지스터 번호, 컴파일 시간 상수 및 런타임 값의 세 그룹으로 나눌 수 있습니다. 이 분류를 한눈에 명확하게하기 위해 인수와 반환 값에는 다음과 같은 의사 유형이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="c829863ade5431c1682f5d64360267aae12a2fb8" translate="yes" xml:space="preserve">
          <source>The attribute can also be applied to an inline namespace, but does not affect the mangled name of the namespace; in this case it is only used for</source>
          <target state="translated">속성은 인라인 네임 스페이스에도 적용 할 수 있지만 네임 스페이스의 맹 글링 된 이름에는 영향을 미치지 않습니다. 이 경우에만 사용됩니다</target>
        </trans-unit>
        <trans-unit id="ed02eb26a29f10b556adacd30701241deccd245e" translate="yes" xml:space="preserve">
          <source>The attribute cannot be used to decrease the alignment of a function previously declared with a more restrictive alignment; only to increase it. Attempts to do otherwise are diagnosed. Some targets specify a minimum default alignment for functions that is greater than 1. On such targets, specifying a less restrictive alignment is silently ignored. Using the attribute overrides the effect of the</source>
          <target state="translated">더 제한적인 정렬로 이전에 선언 된 함수의 정렬을 줄이려면이 속성을 사용할 수 없습니다. 그것을 증가시키기 위해서만. 그렇지 않으면 시도가 진단됩니다. 일부 대상은 1보다 큰 함수에 대해 최소 기본 정렬을 지정합니다. 이러한 대상에서 덜 제한적인 정렬을 지정하는 것은 자동으로 무시됩니다. 속성을 사용하면</target>
        </trans-unit>
        <trans-unit id="ae26e49e643c3950ed6f72c5632f4fffd355af07" translate="yes" xml:space="preserve">
          <source>The attribute has no effect on functions defined within the current compilation unit. This is to allow easy merging of multiple compilation units into one, for example, by using the link-time optimization. For this reason the attribute is not allowed on types to annotate indirect calls.</source>
          <target state="translated">이 속성은 현재 컴파일 단위 내에 정의 된 함수에는 영향을 미치지 않습니다. 예를 들어 링크 타임 최적화를 사용하여 여러 컴파일 단위를 하나로 쉽게 병합 할 수 있습니다. 이러한 이유로 유형에서 속성에 간접 호출에 주석을 달 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="87e6916763209960cf7a9bdaddf003a5218d3bef" translate="yes" xml:space="preserve">
          <source>The attribute is automatically set with a position of 0 for the built-in functions &lt;code&gt;execl&lt;/code&gt; and &lt;code&gt;execlp&lt;/code&gt;. The built-in function &lt;code&gt;execle&lt;/code&gt; has the attribute set with a position of 1.</source>
          <target state="translated">내장 함수 &lt;code&gt;execl&lt;/code&gt; 및 &lt;code&gt;execlp&lt;/code&gt; 에 대해 속성은 위치 0으로 자동 설정됩니다 . 내장 함수 &lt;code&gt;execle&lt;/code&gt; 에는 위치가 1로 설정된 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe2a754094a48aee11cc854617f21a28a6c915b2" translate="yes" xml:space="preserve">
          <source>The attribute is ignored for undefined symbols.</source>
          <target state="translated">정의되지 않은 기호의 경우 속성이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="c20b877bf7007b2fcc50da9d21f8618882a3644d" translate="yes" xml:space="preserve">
          <source>The attribute is intended for library functions to improve dataflow analysis. The compiler takes the hint that any data not escaping the current compilation unit cannot be used or modified by the leaf function. For example, the &lt;code&gt;sin&lt;/code&gt; function is a leaf function, but &lt;code&gt;qsort&lt;/code&gt; is not.</source>
          <target state="translated">이 속성은 데이터 흐름 분석을 개선하기위한 라이브러리 함수를위한 것입니다. 컴파일러는 현재 컴파일 단위를 벗어나지 않는 데이터는 리프 함수로 사용하거나 수정할 수 없다는 힌트를 얻습니다. 예를 들어, &lt;code&gt;sin&lt;/code&gt; 함수는 리프 함수이지만 &lt;code&gt;qsort&lt;/code&gt; 는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cdb101c8aa868b197540d1e1e07e514397c2827e" translate="yes" xml:space="preserve">
          <source>The attribute parameters configure what values are passed into the kernel function by the GPU drivers, via the initial register state. Some values are used by the compiler, and therefore forced on. Enabling other options may break assumptions in the compiler and/or run-time libraries.</source>
          <target state="translated">속성 매개 변수는 초기 레지스터 상태를 통해 GPU 드라이버가 커널 함수에 전달할 값을 구성합니다. 일부 값은 컴파일러에서 사용되므로 강제 실행됩니다. 다른 옵션을 활성화하면 컴파일러 및 / 또는 런타임 라이브러리에서 가정이 깨질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f37e3b5bceea5d68174fbdb23337f013d5dc061b" translate="yes" xml:space="preserve">
          <source>The attributes work in conjunction with a linker script that has been augmented to specify where to place sections with a &lt;code&gt;.lower&lt;/code&gt; and a &lt;code&gt;.upper&lt;/code&gt; prefix. So, for example, as well as placing the &lt;code&gt;.data&lt;/code&gt; section, the script also specifies the placement of a &lt;code&gt;.lower.data&lt;/code&gt; and a &lt;code&gt;.upper.data&lt;/code&gt; section. The intention is that &lt;code&gt;lower&lt;/code&gt; sections are placed into a small but easier to access memory region and the upper sections are placed into a larger, but slower to access, region.</source>
          <target state="translated">속성은 &lt;code&gt;.lower&lt;/code&gt; 및 &lt;code&gt;.upper&lt;/code&gt; 접두어로 섹션을 배치 할 위치를 지정하기 위해 기능이 보강 된 링커 스크립트와 함께 작동 합니다. 예를 들어, &lt;code&gt;.data&lt;/code&gt; 섹션 을 배치 할뿐만 아니라 스크립트는 &lt;code&gt;.lower.data&lt;/code&gt; 및 &lt;code&gt;.upper.data&lt;/code&gt; 섹션 의 배치도 지정 합니다. 의도이다 &lt;code&gt;lower&lt;/code&gt; 섹션 작지만 쉽게 액세스 메모리 영역에 배치되고, 상기 상부 섹션이, 크지 만, 액세스 속도가 느린 영역에 배치된다.</target>
        </trans-unit>
        <trans-unit id="10feff4fc0898bcb9645a7662553ea298f34abd3" translate="yes" xml:space="preserve">
          <source>The authoritative manual on Objective-C 2.0 is available from Apple:</source>
          <target state="translated">Objective-C 2.0의 권위있는 매뉴얼은 Apple에서 구할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6ef9f24ededd45d5c51229d5801270991d5579a" translate="yes" xml:space="preserve">
          <source>The basic built-in functions described in this section are available on the PowerPC family of processors starting with ISA 2.05 or later. Unless specific options are explicitly disabled on the command line, specifying option</source>
          <target state="translated">이 섹션에서 설명하는 기본 내장 기능은 ISA 2.05 이상으로 시작하는 PowerPC 프로세서 제품군에서 사용할 수 있습니다. 명령 줄에서 특정 옵션을 명시 적으로 비활성화하지 않은 경우 옵션 지정</target>
        </trans-unit>
        <trans-unit id="edbf04361cb171c9ec574af51f9f9931b1811352" translate="yes" xml:space="preserve">
          <source>The basic built-in functions described in this section are available on the PowerPC family of processors starting with ISA 2.07 or later. Unless specific options are explicitly disabled on the command line, specifying option</source>
          <target state="translated">이 섹션에서 설명하는 기본 내장 기능은 ISA 2.07 이상으로 시작하는 PowerPC 프로세서 제품군에서 사용할 수 있습니다. 명령 줄에서 특정 옵션을 명시 적으로 비활성화하지 않은 경우 옵션 지정</target>
        </trans-unit>
        <trans-unit id="70f8648696a80bbf371453c7d66873b6ed3c1e9f" translate="yes" xml:space="preserve">
          <source>The basic built-in functions described in this section are available on the PowerPC family of processors starting with ISA 3.0 or later. Unless specific options are explicitly disabled on the command line, specifying option</source>
          <target state="translated">이 섹션에서 설명하는 기본 내장 기능은 ISA 3.0 이상으로 시작하는 PowerPC 프로세서 제품군에서 사용할 수 있습니다. 명령 줄에서 특정 옵션을 명시 적으로 비활성화하지 않은 경우 옵션 지정</target>
        </trans-unit>
        <trans-unit id="b5753c392332963f289e128617ea50b9de09b52f" translate="yes" xml:space="preserve">
          <source>The behavior of most of these points are dependent on the implementation of the C library, and are not defined by GCC itself.</source>
          <target state="translated">이러한 점들 대부분의 동작은 C 라이브러리의 구현에 의존하며 GCC 자체에 의해 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="12799856c643d4a305ab2b4319a6be1f011a91bc" translate="yes" xml:space="preserve">
          <source>The behavior of these points are dependent on the implementation of the C library, and are not defined by GCC itself.</source>
          <target state="translated">이러한 점의 동작은 C 라이브러리의 구현에 따라 다르며 GCC 자체에 의해 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="98ca99f07d3faae58eb40bce10f1e4e864f854e3" translate="yes" xml:space="preserve">
          <source>The behavior of this switch is not quite the same as marking the methods as hidden directly, because it does not affect static variables local to the function or cause the compiler to deduce that the function is defined in only one shared object.</source>
          <target state="translated">이 스위치의 동작은 메서드에 직접 숨겨진 것으로 표시하는 것과 동일하지 않습니다. 함수에 로컬 인 정적 변수에 영향을 미치지 않거나 컴파일러가 함수가 하나의 공유 객체에만 정의되어 있다고 추론 할 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="7d6b7cdf4a6f4c034253043f3e78682296fde54a" translate="yes" xml:space="preserve">
          <source>The behavior on each recognized non-&lt;code&gt;STDC #pragma&lt;/code&gt; directive (C90 6.8.6, C99 and C11 6.10.6).</source>
          <target state="translated">인식 된 각 비 &lt;code&gt;STDC #pragma&lt;/code&gt; 지시문 (C90 6.8.6, C99 및 C11 6.10.6)의 동작</target>
        </trans-unit>
        <trans-unit id="78838b89d1e6169626813ca34b5663bfb106ff9a" translate="yes" xml:space="preserve">
          <source>The best solution to such a problem is to put the text into an actual C comment delimited by &amp;lsquo;</source>
          <target state="translated">이러한 문제에 대한 가장 좋은 해결책은 텍스트를 '로 구분 된 실제 C 주석에 넣는 것입니다.</target>
        </trans-unit>
        <trans-unit id="cbc968ad31a477faa2208668bddbf016d38a55ba" translate="yes" xml:space="preserve">
          <source>The built-in compare types&amp;ndash;eq, ne, gtu, ltu, geu, and leu.</source>
          <target state="translated">내장 비교 유형-eq, ne, gtu, ltu, geu 및 leu</target>
        </trans-unit>
        <trans-unit id="ce0a88d34ad669c64ab3760c61374b2e37e4cc3c" translate="yes" xml:space="preserve">
          <source>The built-in function &lt;code&gt;__builtin_complex&lt;/code&gt; is provided for use in implementing the ISO C11 macros &lt;code&gt;CMPLXF&lt;/code&gt;, &lt;code&gt;CMPLX&lt;/code&gt; and &lt;code&gt;CMPLXL&lt;/code&gt;. &lt;var&gt;real&lt;/var&gt; and &lt;var&gt;imag&lt;/var&gt; must have the same type, a real binary floating-point type, and the result has the corresponding complex type with real and imaginary parts &lt;var&gt;real&lt;/var&gt; and &lt;var&gt;imag&lt;/var&gt;. Unlike &amp;lsquo;</source>
          <target state="translated">내장 함수 &lt;code&gt;__builtin_complex&lt;/code&gt; 는 ISO C11 매크로 &lt;code&gt;CMPLXF&lt;/code&gt; , &lt;code&gt;CMPLX&lt;/code&gt; 및 &lt;code&gt;CMPLXL&lt;/code&gt; 구현에 사용하기 위해 제공됩니다 . &lt;var&gt;real&lt;/var&gt; 및 &lt;var&gt;imag&lt;/var&gt; 는 동일한 유형, 실제 이진 부동 소수점 유형을 가져야하며 결과는 real 및 허수 부분 인 &lt;var&gt;real&lt;/var&gt; 및 &lt;var&gt;imag&lt;/var&gt; 과 해당 복합 유형을 갖습니다 . '와 달리</target>
        </trans-unit>
        <trans-unit id="4172235cf37ce3bd8136a03cb1f1f52ca1bd1d30" translate="yes" xml:space="preserve">
          <source>The built-in function &lt;code&gt;__builtin_tgmath&lt;/code&gt;, available only for C and Objective-C, calls a function determined according to the rules of &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt; macros. It is intended to be used in implementations of that header, so that expansions of macros from that header only expand each of their arguments once, to avoid problems when calls to such macros are nested inside the arguments of other calls to such macros; in addition, it results in better diagnostics for invalid calls to &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt; macros than implementations using other GNU C language features. For example, the &lt;code&gt;pow&lt;/code&gt; type-generic macro might be defined as:</source>
          <target state="translated">C 및 Objective-C에만 사용 가능한 내장 함수 &lt;code&gt;__builtin_tgmath&lt;/code&gt; 는 &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt; 매크로 의 규칙에 따라 결정된 함수를 호출 합니다. 해당 헤더의 구현에 사용되므로 해당 헤더의 매크로 확장은 각 인수를 한 번만 확장하여 해당 매크로에 대한 호출이 해당 매크로에 대한 다른 호출의 인수 내에 중첩 될 때 문제를 방지합니다. 또한 다른 GNU C 언어 기능을 사용하는 구현보다 &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt; 매크로에 대한 잘못된 호출에 대한 진단 기능이 향상되었습니다. 예를 들어, &lt;code&gt;pow&lt;/code&gt; type-generic 매크로는 다음과 같이 정의 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4ab6bdc7a525221a10db36f04ba0ea776ca5cba" translate="yes" xml:space="preserve">
          <source>The built-in function can be used where a variable appears to be used in a safe way, but the CPU, due to speculative execution may temporarily ignore the bounds checks. Consider, for example, the following function:</source>
          <target state="translated">내장 함수는 변수가 안전한 방식으로 사용되는 것처럼 보일 수 있지만 추론 적 실행으로 인해 CPU는 경계 검사를 일시적으로 무시할 수 있습니다. 예를 들어 다음 기능을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="a003f5f8fd45a849966ac7beaa6dcf85e370f177" translate="yes" xml:space="preserve">
          <source>The built-in function will either cause execution to stall until the conditional branch has been fully resolved, or it may permit speculative execution to continue, but using 0 instead of &lt;code&gt;untrusted_value&lt;/code&gt; if that exceeds the limit.</source>
          <target state="translated">내장 함수는 조건부 분기가 완전히 해결 될 때까지 실행을 정지 시키거나 추론 적 실행을 계속할 수 있지만 한계를 초과하면 &lt;code&gt;untrusted_value&lt;/code&gt; 대신 0을 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="23fbf2c81175bf34ed4b14a9d7849c7a6ed67337" translate="yes" xml:space="preserve">
          <source>The built-in functions are optimized into the normal string functions like &lt;code&gt;memcpy&lt;/code&gt; if the last argument is &lt;code&gt;(size_t) -1&lt;/code&gt; or if it is known at compile time that the destination object will not be overflowed. If the compiler can determine at compile time that the object will always be overflowed, it issues a warning.</source>
          <target state="translated">내장 함수는 마지막 인수가 &lt;code&gt;(size_t) -1&lt;/code&gt; 이거나 컴파일 타임에 대상 객체가 오버플로되지 않는 것으로 알려진 경우 &lt;code&gt;memcpy&lt;/code&gt; 와 같은 일반 문자열 함수에 최적화됩니다 . 컴파일러가 컴파일 타임에 객체가 항상 오버플로 될 것이라고 결정할 수 있으면 경고가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="97b0909bb726639d57f4621d69b4f030cedbb5e2" translate="yes" xml:space="preserve">
          <source>The built-in functions promote the first two operands into infinite precision signed type and perform addition on those promoted operands. The result is then cast to the type of the third argument. If the cast result is equal to the infinite precision result, the built-in functions return &lt;code&gt;false&lt;/code&gt;, otherwise they return &lt;code&gt;true&lt;/code&gt;. The value of the third argument is ignored, just the side effects in the third argument are evaluated, and no integral argument promotions are performed on the last argument. If the third argument is a bit-field, the type used for the result cast has the precision and signedness of the given bit-field, rather than precision and signedness of the underlying type.</source>
          <target state="translated">내장 함수는 처음 두 피연산자를 무한 정밀도 부호 유형으로 승격시키고 승격 된 피연산자에 대한 추가를 수행합니다. 그런 다음 결과는 세 번째 인수 유형으로 캐스트됩니다. 캐스트 결과가 무한 정밀도 결과와 같으면 내장 함수가 &lt;code&gt;false&lt;/code&gt; 를 리턴하고 그렇지 않으면 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 세 번째 인수의 값은 무시되고 세 번째 인수의 부작용 만 평가되며 마지막 인수에 대해 완전한 인수 승격이 수행되지 않습니다. 세 번째 인수가 비트 필드 인 경우 결과 캐스트에 사용 된 유형은 기본 유형의 정밀도 및 부호가 아니라 주어진 비트 필드의 정밀도 및 부호를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="b3bbc4c3c1cb9c4fe70210b2dfdbc17fe5153882" translate="yes" xml:space="preserve">
          <source>The built-in functions supported are:</source>
          <target state="translated">지원되는 내장 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="334b3175e81dee6f1e168a0be44f3b7d957b1be7" translate="yes" xml:space="preserve">
          <source>The built-in macros&amp;rsquo; names follow the scheme &lt;code&gt;__AVR_&lt;var&gt;Device&lt;/var&gt;__&lt;/code&gt; where &lt;var&gt;Device&lt;/var&gt; is the device name as from the AVR user manual. The difference between &lt;var&gt;Device&lt;/var&gt; in the built-in macro and &lt;var&gt;device&lt;/var&gt; in</source>
          <target state="translated">내장 매크로의 이름은 &lt;code&gt;__AVR_&lt;var&gt;Device&lt;/var&gt;__&lt;/code&gt; 체계를 따릅니다. 여기서 &lt;var&gt;Device&lt;/var&gt; 는 AVR 사용 설명서의 장치 이름입니다. 차이 &lt;var&gt;Device&lt;/var&gt; 내장 매크로의 &lt;var&gt;device&lt;/var&gt; 에서</target>
        </trans-unit>
        <trans-unit id="62f099d3393656bddb7d8b0dd222e5a223f8d688" translate="yes" xml:space="preserve">
          <source>The built-in versions of these functions use GCC&amp;rsquo;s normal mechanisms to save and restore registers using the stack on function entry and exit. The jump buffer argument &lt;var&gt;buf&lt;/var&gt; holds only the information needed to restore the stack frame, rather than the entire set of saved register values.</source>
          <target state="translated">이러한 함수의 내장 버전은 GCC의 일반 메커니즘을 사용하여 함수 입력 및 종료시 스택을 사용하여 레지스터를 저장하고 복원합니다. 점프 버퍼 인수 &lt;var&gt;buf&lt;/var&gt; 는 전체 저장된 레지스터 값 세트가 아니라 스택 프레임을 복원하는 데 필요한 정보 만 보유합니다.</target>
        </trans-unit>
        <trans-unit id="4488c1d75b7b81f78b64d60c26fdf9ed24d8f3bf" translate="yes" xml:space="preserve">
          <source>The call-clobbered integer registers.</source>
          <target state="translated">콜 클로버 정수 레지스터.</target>
        </trans-unit>
        <trans-unit id="0b277cbf75c7f621fb1dabe16f1a3a2fa8a7f4cc" translate="yes" xml:space="preserve">
          <source>The caller copies function arguments passed by hidden reference. This option should be used with care as it is not compatible with the default 32-bit runtime. However, only aggregates larger than eight bytes are passed by hidden reference and the option provides better compatibility with OpenMP.</source>
          <target state="translated">호출자는 숨겨진 참조로 전달 된 함수 인수를 복사합니다. 이 옵션은 기본 32 비트 런타임과 호환되지 않으므로주의해서 사용해야합니다. 그러나 8 바이트보다 큰 집계 만 숨겨진 참조로 전달되며이 옵션은 OpenMP와의 호환성을 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="b583bb229dda327522feb6b40a364f4908fd1bf3" translate="yes" xml:space="preserve">
          <source>The carry register.</source>
          <target state="translated">캐리 레지스터.</target>
        </trans-unit>
        <trans-unit id="c7287b1af6a41a31db6c4fc8adca45c0df1d456b" translate="yes" xml:space="preserve">
          <source>The change to the types of UTF-8 string and character literals introduces incompatibilities with ISO C++11 and later standards. For example, the following code is well-formed under ISO C++11, but is ill-formed when</source>
          <target state="translated">UTF-8 문자열 및 문자 리터럴 유형으로 변경하면 ISO C ++ 11 이상의 표준과 호환되지 않습니다. 예를 들어 다음 코드는 ISO C ++ 11에서 잘 구성되어 있지만 다음과 같은 경우에는 잘못 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="9023ce61724bbabe84554211f1682a5b7d26a59b" translate="yes" xml:space="preserve">
          <source>The character &amp;lsquo;</source>
          <target state="translated">캐릭터 '</target>
        </trans-unit>
        <trans-unit id="519631b15cf0936ab9bd0c60033ca6acf8715c58" translate="yes" xml:space="preserve">
          <source>The choices for &lt;var&gt;cpu-type&lt;/var&gt; are the same as for</source>
          <target state="translated">&lt;var&gt;cpu-type&lt;/var&gt; 의 선택 은 다음과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="682ea402eec35d575ae857912b781a6cde1e0d53" translate="yes" xml:space="preserve">
          <source>The choices for &lt;var&gt;cpu-type&lt;/var&gt; are:</source>
          <target state="translated">&lt;var&gt;cpu-type&lt;/var&gt; 대한 선택 사항 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8623d02fccd10cdf135414efb4d8dedf3d5298b1" translate="yes" xml:space="preserve">
          <source>The code above would iterate over all objects in &lt;code&gt;array&lt;/code&gt;. For each of them, it assigns it to &lt;code&gt;object&lt;/code&gt;, then executes the &lt;code&gt;Do something with 'object'&lt;/code&gt; statements.</source>
          <target state="translated">위의 코드는 &lt;code&gt;array&lt;/code&gt; 모든 객체를 반복합니다 . 그들 각각에 대해 그것을 &lt;code&gt;object&lt;/code&gt; 에 할당 한 다음 &lt;code&gt;Do something with 'object'&lt;/code&gt; 문으로 무언가 를 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="990cbdb236536d3c2c7b3b4ad41a30dc08b70c1d" translate="yes" xml:space="preserve">
          <source>The colors are defined by the environment variable &lt;code&gt;GCC_COLORS&lt;/code&gt;. Its value is a colon-separated list of capabilities and Select Graphic Rendition (SGR) substrings. SGR commands are interpreted by the terminal or terminal emulator. (See the section in the documentation of your text terminal for permitted values and their meanings as character attributes.) These substring values are integers in decimal representation and can be concatenated with semicolons. Common values to concatenate include &amp;lsquo;</source>
          <target state="translated">색상은 환경 변수 &lt;code&gt;GCC_COLORS&lt;/code&gt; 에 의해 정의됩니다 . 이 값은 콜론으로 구분 된 기능 목록과 SGR (Select Graphic Rendition) 하위 문자열입니다. SGR 명령은 터미널 또는 터미널 에뮬레이터에 의해 해석됩니다. (허용되는 값 및 문자 속성으로서의 의미에 대해서는 텍스트 터미널 문서의 섹션을 참조하십시오.)이 하위 문자열 값은 10 진수로 정수이며 세미콜론으로 연결할 수 있습니다. 연결하는 일반적인 값은 '</target>
        </trans-unit>
        <trans-unit id="34aa8249352c8e598246fe5c42924ea343806e93" translate="yes" xml:space="preserve">
          <source>The comment needs to be followed after optional whitespace and other comments by &lt;code&gt;case&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt; keywords or by a user label that precedes some &lt;code&gt;case&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt; label.</source>
          <target state="translated">주석은 선택적 공백과 &lt;code&gt;case&lt;/code&gt; 또는 &lt;code&gt;default&lt;/code&gt; 키워드 또는 일부 &lt;code&gt;case&lt;/code&gt; 또는 &lt;code&gt;default&lt;/code&gt; 레이블 앞에 오는 사용자 레이블이 뒤에옵니다 .</target>
        </trans-unit>
        <trans-unit id="f4f1f40d78278988845f6e6d5dd1df865371c25c" translate="yes" xml:space="preserve">
          <source>The comments are intended for humans rather than machines and hence the precise format of the comments is subject to change.</source>
          <target state="translated">주석은 기계가 아닌 사람을위한 것이며 주석의 정확한 형식은 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92f39136333428ef92d0ab34cd6ec4175f20f2a6" translate="yes" xml:space="preserve">
          <source>The common src/dest memory addressing modes.</source>
          <target state="translated">일반적인 src / dest 메모리 어드레싱 모드.</target>
        </trans-unit>
        <trans-unit id="23d24a28b1d2dd308a7ff9954bb96ae5aaa048ba" translate="yes" xml:space="preserve">
          <source>The common subset of the ARMv7-A, ARMv7-R and ARMv7-M architectures.</source>
          <target state="translated">ARMv7-A, ARMv7-R 및 ARMv7-M 아키텍처의 공통 하위 집합입니다.</target>
        </trans-unit>
        <trans-unit id="17c10738c483ffe85f7448f4cbfe545afae5514b" translate="yes" xml:space="preserve">
          <source>The compiler assumes that &lt;code&gt;EIND&lt;/code&gt; never changes during the startup code or during the application. In particular, &lt;code&gt;EIND&lt;/code&gt; is not saved/restored in function or interrupt service routine prologue/epilogue.</source>
          <target state="translated">컴파일러는 시작 코드 또는 응용 프로그램 중에 &lt;code&gt;EIND&lt;/code&gt; 가 변경되지 않는다고 가정합니다 . 특히, &lt;code&gt;EIND&lt;/code&gt; 는 기능 또는 인터럽트 서비스 루틴 프롤로그 / 에필로그에 저장 / 복원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8983abbfe719941604e388ad4f86efe2a35d89a4" translate="yes" xml:space="preserve">
          <source>The compiler automatically sets the alignment for the declared variable or field to &lt;code&gt;__BIGGEST_ALIGNMENT__&lt;/code&gt;. Doing this can often make copy operations more efficient, because the compiler can use whatever instructions copy the biggest chunks of memory when performing copies to or from the variables or fields that you have aligned this way. Note that the value of &lt;code&gt;__BIGGEST_ALIGNMENT__&lt;/code&gt; may change depending on command-line options.</source>
          <target state="translated">컴파일러는 선언 된 변수 또는 필드의 정렬을 자동으로 &lt;code&gt;__BIGGEST_ALIGNMENT__&lt;/code&gt; 로 설정 합니다. 컴파일러는 이러한 방법으로 정렬 한 변수 나 필드에서 복사를 수행 할 때 가장 큰 메모리 청크를 복사하는 명령어를 사용할 수 있기 때문에 복사 작업을보다 효율적으로 수행 할 수 있습니다. &lt;code&gt;__BIGGEST_ALIGNMENT__&lt;/code&gt; 의 값은 명령 줄 옵션에 따라 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e7e2956c5fa63410dcde9892cdb317e8b9bdabe" translate="yes" xml:space="preserve">
          <source>The compiler can accept several base standards, such as &amp;lsquo;</source>
          <target state="translated">컴파일러는 다음과 같은 몇 가지 기본 표준을 수용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae77b7d999c147c822471a0c6078013beaa6bc78" translate="yes" xml:space="preserve">
          <source>The compiler checks to see if the path provided by</source>
          <target state="translated">컴파일러는 경로가 제공하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="e75bc3167776cc7681a2a3309af02b07eee5f4ff" translate="yes" xml:space="preserve">
          <source>The compiler contains estimates of the number of clock cycles for &amp;ldquo;typical&amp;rdquo; EV4 &amp;amp; EV5 hardware for the Level 1, 2 &amp;amp; 3 caches (also called Dcache, Scache, and Bcache), as well as to main memory. Note that L3 is only valid for EV5.</source>
          <target state="translated">컴파일러에는 주 메모리뿐만 아니라 레벨 1, 2 및 3 캐시 (Dcache, Scache 및 Bcache라고도 함)에 대한 &quot;일반적인&quot;EV4 및 EV5 하드웨어의 클럭주기 수에 대한 추정값이 포함되어 있습니다. L3은 EV5에만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="8338416b67f14201602d466304368b7f468175f5" translate="yes" xml:space="preserve">
          <source>The compiler copies the assembler instructions in a basic &lt;code&gt;asm&lt;/code&gt; verbatim to the assembly language output file, without processing dialects or any of the &amp;lsquo;</source>
          <target state="translated">컴파일러 복사 기본에서 어셈블러 지침 &lt;code&gt;asm&lt;/code&gt; 어셈블리 언어 출력 파일에 그대로, '방언 또는 중 하나를 처리하지 않고</target>
        </trans-unit>
        <trans-unit id="d28532eae1da814b4665d28f7dd4fbb9e0aec8b2" translate="yes" xml:space="preserve">
          <source>The compiler driver program runs one or more of the subprograms &lt;code&gt;cpp&lt;/code&gt;, &lt;code&gt;cc1&lt;/code&gt;, &lt;code&gt;as&lt;/code&gt; and &lt;code&gt;ld&lt;/code&gt;. It tries &lt;var&gt;prefix&lt;/var&gt; as a prefix for each program it tries to run, both with and without &amp;lsquo;</source>
          <target state="translated">컴파일러 드라이버 프로그램은 하나 이상의 서브 프로그램 &lt;code&gt;cpp&lt;/code&gt; , &lt;code&gt;cc1&lt;/code&gt; , &lt;code&gt;as&lt;/code&gt; 및 &lt;code&gt;ld&lt;/code&gt; 를 실행 합니다. 그것은 시도 &lt;var&gt;prefix&lt;/var&gt; '와없이 모두가 실행하려고 각 프로그램에 대한 접두사로</target>
        </trans-unit>
        <trans-unit id="9b9b15ff6acdc5c85d5777579b9105147bc703cb" translate="yes" xml:space="preserve">
          <source>The compiler emits such &lt;code&gt;gs&lt;/code&gt; modifiers for code labels in the following situations:</source>
          <target state="translated">컴파일러 는 다음 상황에서 코드 레이블에 대해 이러한 &lt;code&gt;gs&lt;/code&gt; 수정자를 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="1aa76bdb9ae1bbf7aa774ff7d0e6d298e86f04a3" translate="yes" xml:space="preserve">
          <source>The compiler generates special code to access the variable &lt;code&gt;i&lt;/code&gt;. It may use runtime library support, or generate special machine instructions to access that address space.</source>
          <target state="translated">컴파일러는 변수 &lt;code&gt;i&lt;/code&gt; 에 액세스하기위한 특수 코드를 생성 합니다. 런타임 라이브러리 지원을 사용하거나 해당 주소 공간에 액세스하기위한 특수 기계 명령어를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d157d680a0dc51afbbd2163137f4b54277c4701" translate="yes" xml:space="preserve">
          <source>The compiler is configured to be used together with AVR-Libc. See the</source>
          <target state="translated">컴파일러는 AVR-Libc와 함께 사용하도록 구성되어 있습니다. 참조</target>
        </trans-unit>
        <trans-unit id="fdab34c680d8fa9373eabc63f94733d605cf2016" translate="yes" xml:space="preserve">
          <source>The compiler may generate calls to &lt;code&gt;memcmp&lt;/code&gt;, &lt;code&gt;memset&lt;/code&gt;, &lt;code&gt;memcpy&lt;/code&gt; and &lt;code&gt;memmove&lt;/code&gt;. These entries are usually resolved by entries in libc. These entry points should be supplied through some other mechanism when this option is specified.</source>
          <target state="translated">컴파일러는 &lt;code&gt;memcmp&lt;/code&gt; , &lt;code&gt;memset&lt;/code&gt; , &lt;code&gt;memcpy&lt;/code&gt; 및 &lt;code&gt;memmove&lt;/code&gt; 에 대한 호출을 생성 할 수 있습니다 . 이러한 항목은 일반적으로 libc의 항목으로 해결됩니다. 이 진입 점은이 옵션이 지정 될 때 다른 메커니즘을 통해 제공되어야합니다.</target>
        </trans-unit>
        <trans-unit id="197f6accb1b57a2d3b7bbd9dc901a8f9853c9909" translate="yes" xml:space="preserve">
          <source>The compiler may move the addition back before the &lt;code&gt;volatile asm&lt;/code&gt; statement. To make it work as expected, add an artificial dependency to the &lt;code&gt;asm&lt;/code&gt; by referencing a variable in the subsequent code, for example:</source>
          <target state="translated">컴파일러는 &lt;code&gt;volatile asm&lt;/code&gt; 문 이전에 추가를 다시 이동할 수 있습니다 . 예상대로 작동하게하려면 다음 코드에서 변수를 참조 하여 &lt;code&gt;asm&lt;/code&gt; 에 인공 종속성을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="2d9dc939c11511961a2efd9a38375989ea973bee" translate="yes" xml:space="preserve">
          <source>The compiler never sets &lt;code&gt;EIND&lt;/code&gt;.</source>
          <target state="translated">컴파일러는 &lt;code&gt;EIND&lt;/code&gt; 를 설정하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d5c65d66d80d8006703599470ce9ad6d678c7518" translate="yes" xml:space="preserve">
          <source>The compiler performs optimization based on the knowledge it has of the program. Compiling multiple files at once to a single output file mode allows the compiler to use information gained from all of the files when compiling each of them.</source>
          <target state="translated">컴파일러는 프로그램에 대한 지식을 기반으로 최적화를 수행합니다. 한 번에 여러 파일을 단일 출력 파일 모드로 컴파일하면 컴파일러가 각 파일을 컴파일 할 때 모든 파일에서 얻은 정보를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="059a79983e1d0cd8bbb8de563c5411cbd5695493" translate="yes" xml:space="preserve">
          <source>The compiler rearranges the member initializers for &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; to match the declaration order of the members, emitting a warning to that effect. This warning is enabled by</source>
          <target state="translated">컴파일러는 &lt;code&gt;i&lt;/code&gt; 및 &lt;code&gt;j&lt;/code&gt; 의 멤버 이니셜 라이저를 멤버 의 선언 순서와 일치하도록 재 배열하여 해당 효과에 대한 경고를 표시합니다. 이 경고는</target>
        </trans-unit>
        <trans-unit id="6f7ea77386532c48049a0ac434d425f5c9cdb9e9" translate="yes" xml:space="preserve">
          <source>The compiler uses &lt;code&gt;EIND&lt;/code&gt; implicitly in &lt;code&gt;EICALL&lt;/code&gt;/&lt;code&gt;EIJMP&lt;/code&gt; instructions or might read &lt;code&gt;EIND&lt;/code&gt; directly in order to emulate an indirect call/jump by means of a &lt;code&gt;RET&lt;/code&gt; instruction.</source>
          <target state="translated">컴파일러 사용은 &lt;code&gt;EIND&lt;/code&gt; 에서 암시 적으로 &lt;code&gt;EICALL&lt;/code&gt; / &lt;code&gt;EIJMP&lt;/code&gt; 의 지시 또는 읽을 수 &lt;code&gt;EIND&lt;/code&gt; 에 의해 간접적으로 호출 / 점프를 에뮬레이션하기 위해 직접 &lt;code&gt;RET&lt;/code&gt; 의 명령.</target>
        </trans-unit>
        <trans-unit id="a697129b447131da9ef72d7d16ecc19d13cde06f" translate="yes" xml:space="preserve">
          <source>The compiler uses a variety of heuristics to determine whether or not to inline a function. For example, the compiler takes into account the size of the function being inlined and the amount of inlining that has already been done in the current function. Therefore, seemingly insignificant changes in the source program can cause the warnings produced by</source>
          <target state="translated">컴파일러는 다양한 휴리스틱을 사용하여 함수를 인라인할지 여부를 결정합니다. 예를 들어, 컴파일러는 인라인되는 함수의 크기와 현재 함수에서 이미 수행 된 인라인의 양을 고려합니다. 따라서 소스 프로그램에서별로 중요하지 않은 변경 사항이 발생하면 다음과 같은 경고가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37e71b48c058bf8bd050867961b9167f5825927e" translate="yes" xml:space="preserve">
          <source>The compiler will attempt to use hardware instructions to implement these built-in functions where possible, like conditional jump on overflow after addition, conditional jump on carry etc.</source>
          <target state="translated">컴파일러는 추가 후 오버플로 조건부 점프, 캐리 조건부 점프 등과 같은 가능한 경우 이러한 내장 함수를 구현하기 위해 하드웨어 명령어를 사용하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="1f76bb0a6a769fd6051ac5f386b3821fb4f8794e" translate="yes" xml:space="preserve">
          <source>The concatenated &lt;code&gt;hi&lt;/code&gt; and &lt;code&gt;lo&lt;/code&gt; registers. Use this register to store doubleword values.</source>
          <target state="translated">연결된 &lt;code&gt;hi&lt;/code&gt; 및 &lt;code&gt;lo&lt;/code&gt; 레지스터. 더블 레지스터 값을 저장하려면이 레지스터를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="99e27c97d9f5e63a4ed1ab3fd7f4a5a1d329e043" translate="yes" xml:space="preserve">
          <source>The conditional text &lt;code&gt;X&lt;/code&gt; in a &amp;lsquo;</source>
          <target state="translated">조건부 텍스트 &lt;code&gt;X&lt;/code&gt; 는 '에서</target>
        </trans-unit>
        <trans-unit id="a43dc662cd7d08ba0c1419ce7462e0ce31ad7cad" translate="yes" xml:space="preserve">
          <source>The constant -1</source>
          <target state="translated">상수 -1</target>
        </trans-unit>
        <trans-unit id="b06d0b57697105de48b17a361b846597d95ea06a" translate="yes" xml:space="preserve">
          <source>The constant 0.</source>
          <target state="translated">상수 0</target>
        </trans-unit>
        <trans-unit id="40c6bdbaee6c04b3fea04b89e43f4576ad393c2b" translate="yes" xml:space="preserve">
          <source>The constant 4096</source>
          <target state="translated">상수 4096</target>
        </trans-unit>
        <trans-unit id="2dcf3547f5273811228bed3353ffa4e638845233" translate="yes" xml:space="preserve">
          <source>The constant all-ones, for floating-point.</source>
          <target state="translated">부동 소수점에 대한 상수 올인원.</target>
        </trans-unit>
        <trans-unit id="d766b475adfc1a095915836fa6b0ad31150ade7f" translate="yes" xml:space="preserve">
          <source>The constant string objects are by default instances of the &lt;code&gt;NXConstantString&lt;/code&gt; class which is provided by the GNU Objective-C runtime. To get the definition of this class you must include the</source>
          <target state="translated">상수 문자열 객체는 기본적으로 GNU Objective-C 런타임에서 제공 하는 &lt;code&gt;NXConstantString&lt;/code&gt; 클래스의 인스턴스입니다 . 이 클래스의 정의를 얻으려면</target>
        </trans-unit>
        <trans-unit id="66bea79ec7c08d8354c118573be3f32ece7da1fe" translate="yes" xml:space="preserve">
          <source>The constant zero</source>
          <target state="translated">상수 제로</target>
        </trans-unit>
        <trans-unit id="0934955261fabaea67e58ba0c7b8bdff156718f6" translate="yes" xml:space="preserve">
          <source>The constant zero or one</source>
          <target state="translated">상수 0 또는 1</target>
        </trans-unit>
        <trans-unit id="910f5457ff53fa25b37247787227a27d85f14892" translate="yes" xml:space="preserve">
          <source>The constraint matches if the specified part of a constant has a value different from its other parts.</source>
          <target state="translated">상수의 지정된 부분이 다른 부분과 다른 값을 갖는 경우 제한 조건이 일치합니다.</target>
        </trans-unit>
        <trans-unit id="d2273d82451da8273035b5677a47ae31f7f347c8" translate="yes" xml:space="preserve">
          <source>The contents of &lt;var&gt;definition&lt;/var&gt; are tokenized and processed as if they appeared during translation phase three in a &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;definition&lt;/var&gt; 의 내용은 번역 단계 3에서 '</target>
        </trans-unit>
        <trans-unit id="3b752ddcb3035f47ee09a797efcd12407968ef21" translate="yes" xml:space="preserve">
          <source>The convenience of this extension is that &lt;code&gt;f1&lt;/code&gt; has the desired type, eliminating the need to consistently refer to &lt;code&gt;f2.f1&lt;/code&gt;.</source>
          <target state="translated">이 확장의 편리함은 &lt;code&gt;f1&lt;/code&gt; 이 원하는 유형을 가지 &lt;code&gt;f2.f1&lt;/code&gt; 을 일관되게 참조 할 필요가 없다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="6eb402cf1ad5d2ebe2ca4cbf79d4710d25aab043" translate="yes" xml:space="preserve">
          <source>The correct solution of the above problem is to use the &lt;code&gt;+load&lt;/code&gt; method instead of &lt;code&gt;+initialize&lt;/code&gt;:</source>
          <target state="translated">위의 문제에 대한 올바른 해결책 은 &lt;code&gt;+initialize&lt;/code&gt; 대신 &lt;code&gt;+load&lt;/code&gt; 메소드 를 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="195548e33bab5979c07277ae9248599cd2872bd1" translate="yes" xml:space="preserve">
          <source>The count register, &lt;code&gt;ctr&lt;/code&gt;.</source>
          <target state="translated">카운트 레지스터, &lt;code&gt;ctr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f5773d425eed0cc1da37ec24e48650c9ef1f3309" translate="yes" xml:space="preserve">
          <source>The cryptographic instructions.</source>
          <target state="translated">암호화 지침.</target>
        </trans-unit>
        <trans-unit id="3b148cbd7e0801501003f1c6b7a5b5ed93ac8a89" translate="yes" xml:space="preserve">
          <source>The cryptographic instructions. This also enables the Advanced SIMD and floating-point instructions as well as the Dot Product extension.</source>
          <target state="translated">암호화 지침. 또한 고급 SIMD 및 부동 소수점 명령어와 Dot Product 확장을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bebf33834922696e2e3f146a7028c6f38f3d8ce5" translate="yes" xml:space="preserve">
          <source>The cryptographic instructions. This also enables the Advanced SIMD and floating-point instructions.</source>
          <target state="translated">암호화 지침. 또한 고급 SIMD 및 부동 소수점 명령어도 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="3b57febbf4c477f2667a31f8b5a1e7554fec41ce" translate="yes" xml:space="preserve">
          <source>The current</source>
          <target state="translated">현재</target>
        </trans-unit>
        <trans-unit id="0c616918c11c60074662af2cce8d7bf0b00b006e" translate="yes" xml:space="preserve">
          <source>The current implementation of LTO makes no attempt to generate bytecode that is portable between different types of hosts. The bytecode files are versioned and there is a strict version check, so bytecode files generated in one version of GCC do not work with an older or newer version of GCC.</source>
          <target state="translated">현재 LTO 구현에서는 다른 유형의 호스트간에 이식 가능한 바이트 코드를 생성하지 않습니다. 바이트 코드 파일은 버전이 지정되고 엄격한 버전 검사가 있으므로 한 버전의 GCC에서 생성 된 바이트 코드 파일은 이전 또는 최신 버전의 GCC와 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3c2f64218f4b3df3bf76a18bea506a72c2b53fb3" translate="yes" xml:space="preserve">
          <source>The current locale used to convert a wide character constant consisting of a single multibyte character that maps to a member of the extended execution character set into a corresponding wide character code (C90 6.1.3.4, C99 and C11 6.4.4.4).</source>
          <target state="translated">현재 로케일은 확장 실행 문자 세트의 멤버에 맵핑되는 단일 멀티 바이트 문자로 구성된 와이드 문자 상수를 해당 와이드 문자 코드 (C90 6.1.3.4, C99 및 C11 6.4.4.4)로 변환하는 데 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="a8b517f5ebe96bc26ba29bd9df7b451bc7264848" translate="yes" xml:space="preserve">
          <source>The current locale used to convert a wide string literal into corresponding wide character codes (C90 6.1.4, C99 and C11 6.4.5).</source>
          <target state="translated">현재 로케일은 넓은 문자열 리터럴을 해당하는 넓은 문자 코드 (C90 6.1.4, C99 및 C11 6.4.5)로 변환하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cdee0986787f12266222c4757db3c96510d2856b" translate="yes" xml:space="preserve">
          <source>The data in the</source>
          <target state="translated">의 데이터</target>
        </trans-unit>
        <trans-unit id="ad21981df5f9d5df0a92c3202b31e09f62748eca" translate="yes" xml:space="preserve">
          <source>The data segment must be within 512KB while the read-only data segment can be within 4GB addressing space. The text segment should be still within 16MB addressing space.</source>
          <target state="translated">데이터 세그먼트는 512KB 내에 있어야하고 읽기 전용 데이터 세그먼트는 4GB 주소 공간 내에있을 수 있습니다. 텍스트 세그먼트는 여전히 16MB 주소 공간 내에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="308218254edaf858c826e3717d9728c20e8ea1e8" translate="yes" xml:space="preserve">
          <source>The decimal floating types are &lt;code&gt;_Decimal32&lt;/code&gt;, &lt;code&gt;_Decimal64&lt;/code&gt;, and &lt;code&gt;_Decimal128&lt;/code&gt;. They use a radix of ten, unlike the floating types &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, and &lt;code&gt;long double&lt;/code&gt; whose radix is not specified by the C standard but is usually two.</source>
          <target state="translated">십진 부동 유형은 &lt;code&gt;_Decimal32&lt;/code&gt; , &lt;code&gt;_Decimal64&lt;/code&gt; 및 &lt;code&gt;_Decimal128&lt;/code&gt; 입니다. 부동 유형 &lt;code&gt;float&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; 및 &lt;code&gt;long double&lt;/code&gt; 과 달리 기수는 C 표준으로 지정되지 않지만 보통 2 인 기수는 10을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="4ed195636dddaed157754b6f5efb512126f16823" translate="yes" xml:space="preserve">
          <source>The declaration of an identifier for a variable that has block scope that specifies &lt;code&gt;__thread&lt;/code&gt; shall also specify either &lt;code&gt;extern&lt;/code&gt; or &lt;code&gt;static&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;__thread&lt;/code&gt; 를 지정하는 블록 범위를 가진 변수에 대한 식별자 선언은 &lt;code&gt;extern&lt;/code&gt; 또는 &lt;code&gt;static&lt;/code&gt; 을 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="539622d22b3611e1a0d2bdec661bbb3d138ab211" translate="yes" xml:space="preserve">
          <source>The default</source>
          <target state="translated">기본</target>
        </trans-unit>
        <trans-unit id="2d93ba84906186c36a266b5450164ecc57295a2f" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;GCC_COLORS&lt;/code&gt; is</source>
          <target state="translated">기본 &lt;code&gt;GCC_COLORS&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="cd78088e10f5ca7d05051ca6c08ccd0393bc0395" translate="yes" xml:space="preserve">
          <source>The default choice depends on the target.</source>
          <target state="translated">기본 선택은 대상에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="24583facb0777645f4006ae576dc03c661b296bf" translate="yes" xml:space="preserve">
          <source>The default depends on how the compiler has been configured. It can be any of the above &lt;var&gt;WHEN&lt;/var&gt; options.</source>
          <target state="translated">기본값은 컴파일러가 구성된 방식에 따라 다릅니다. 위의 &lt;var&gt;WHEN&lt;/var&gt; 옵션 중 하나 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="821efaa8e812e852d4a90373d231a1a43df2b45f" translate="yes" xml:space="preserve">
          <source>The default depends on the specific target configuration. Note that the LP64 and ILP32 ABIs are not link-compatible; you must compile your entire program with the same ABI, and link with a compatible set of libraries.</source>
          <target state="translated">기본값은 특정 대상 구성에 따라 다릅니다. LP64 및 ILP32 ABI는 링크 호환되지 않습니다. 전체 프로그램을 동일한 ABI로 컴파일하고 호환되는 라이브러리 세트와 링크해야합니다.</target>
        </trans-unit>
        <trans-unit id="073f483a59a39bdd6290fbf3294619a632dc2b8a" translate="yes" xml:space="preserve">
          <source>The default depends on the specific target configuration. Note that the hard-float and soft-float ABIs are not link-compatible; you must compile your entire program with the same ABI, and link with a compatible set of libraries.</source>
          <target state="translated">기본값은 특정 대상 구성에 따라 다릅니다. 하드-플로트 및 소프트-플로트 ABI는 링크 호환되지 않습니다. 전체 프로그램을 동일한 ABI로 컴파일하고 호환되는 라이브러리 세트와 링크해야합니다.</target>
        </trans-unit>
        <trans-unit id="83926f7ff8324784f23d17c03f2640efad441ea9" translate="yes" xml:space="preserve">
          <source>The default for</source>
          <target state="translated">의 기본값</target>
        </trans-unit>
        <trans-unit id="c9e7e18cf6d489e9159a83316e730a739e99cc90" translate="yes" xml:space="preserve">
          <source>The default for this argument is system dependent, users who want a specific calling convention should specify one explicitly. The valid calling conventions are: &amp;lsquo;</source>
          <target state="translated">이 인수의 기본값은 시스템에 따라 다르므로 특정 호출 규칙을 원하는 사용자는 명시 적으로 지정해야합니다. 유효한 통화 규칙은 다음과 같습니다. '</target>
        </trans-unit>
        <trans-unit id="92d2141e4257c252bb28809158d1f4e1362f7a44" translate="yes" xml:space="preserve">
          <source>The default for this option is &amp;lsquo;</source>
          <target state="translated">이 옵션의 기본값은 '</target>
        </trans-unit>
        <trans-unit id="5842694f6173b42e85122f8c60c286aa7ddb9932" translate="yes" xml:space="preserve">
          <source>The default is</source>
          <target state="translated">디폴트는</target>
        </trans-unit>
        <trans-unit id="f12e5a4f7dd6f8646e20a0f33147742e17617209" translate="yes" xml:space="preserve">
          <source>The default is &amp;lsquo;</source>
          <target state="translated">기본값은 '</target>
        </trans-unit>
        <trans-unit id="5d068c3eaa8d9ce215b5361f4b44c855149b5984" translate="yes" xml:space="preserve">
          <source>The default is 30% + 70% * (RAM/1GB) with an upper bound of 100% when RAM &amp;gt;= 1GB. If &lt;code&gt;getrlimit&lt;/code&gt; is available, the notion of &amp;ldquo;RAM&amp;rdquo; is the smallest of actual RAM and &lt;code&gt;RLIMIT_DATA&lt;/code&gt; or &lt;code&gt;RLIMIT_AS&lt;/code&gt;. If GCC is not able to calculate RAM on a particular platform, the lower bound of 30% is used. Setting this parameter and</source>
          <target state="translated">RAM&amp;gt; = 1GB 인 경우 기본값은 30 % + 70 % * (RAM / 1GB)입니다. &lt;code&gt;getrlimit&lt;/code&gt; 를 사용할 수있는 경우 &amp;ldquo;RAM&amp;rdquo;개념은 실제 RAM 및 &lt;code&gt;RLIMIT_DATA&lt;/code&gt; 또는 &lt;code&gt;RLIMIT_AS&lt;/code&gt; 중에서 가장 작 습니다 . GCC가 특정 플랫폼에서 RAM을 계산할 수 없으면 하한 30 %가 사용됩니다. 이 매개 변수 설정</target>
        </trans-unit>
        <trans-unit id="cce96b424afaca2d610cda8bfb3dce73bc563484" translate="yes" xml:space="preserve">
          <source>The default is the smaller of RAM/8, RLIMIT_RSS, or a limit that tries to ensure that RLIMIT_DATA or RLIMIT_AS are not exceeded, but with a lower bound of 4096 (four megabytes) and an upper bound of 131072 (128 megabytes). If GCC is not able to calculate RAM on a particular platform, the lower bound is used. Setting this parameter very large effectively disables garbage collection. Setting this parameter and</source>
          <target state="translated">기본값은 RAM / 8, RLIMIT_RSS보다 작거나 RLIMIT_DATA 또는 RLIMIT_AS가 초과되지 않도록 하한 값이지만 하한은 4096 (4 메가 바이트)이고 상한은 131072 (128 메가 바이트)입니다. GCC가 특정 플랫폼에서 RAM을 계산할 수없는 경우 하한이 사용됩니다. 이 매개 변수를 매우 크게 설정하면 가비지 수집이 효과적으로 비활성화됩니다. 이 매개 변수 설정</target>
        </trans-unit>
        <trans-unit id="cfa3b0a93016b2ef8689d14e510c93e9df2d4e56" translate="yes" xml:space="preserve">
          <source>The default is to allow these instructions, but it is not possible for GCC to reliably detect all circumstances where a string instruction might be used to access an I/O register, so their use cannot be disabled automatically. Instead it is reliant upon the programmer to use the</source>
          <target state="translated">기본값은 이러한 명령어를 허용하는 것이지만 GCC가 문자열 명령어를 사용하여 I / O 레지스터에 액세스 할 수있는 모든 상황을 안정적으로 감지 할 수 없으므로 사용을 자동으로 비활성화 할 수 없습니다. 대신에 프로그래머가</target>
        </trans-unit>
        <trans-unit id="b3f67e8f5424b41ebf8e66523efa318016a862fb" translate="yes" xml:space="preserve">
          <source>The default is to not maintain the backchain.</source>
          <target state="translated">디폴트는 백 체인을 유지하지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a0a0e13c8768face52cb8f602f8efb80a446348b" translate="yes" xml:space="preserve">
          <source>The default is to not use the packed stack layout.</source>
          <target state="translated">기본 설정은 묶음 스택 레이아웃을 사용하지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="edb857f688cb7de8ba1fbdc52989269bb35500d9" translate="yes" xml:space="preserve">
          <source>The default is usually</source>
          <target state="translated">기본값은 보통</target>
        </trans-unit>
        <trans-unit id="d74d1893ecb7357c9e0df6cf36fc2bbcbd00a365" translate="yes" xml:space="preserve">
          <source>The default linker script is arranged for code with &lt;code&gt;EIND = 0&lt;/code&gt;. If code is supposed to work for a setup with &lt;code&gt;EIND != 0&lt;/code&gt;, a custom linker script has to be used in order to place the sections whose name start with &lt;code&gt;.trampolines&lt;/code&gt; into the segment where &lt;code&gt;EIND&lt;/code&gt; points to.</source>
          <target state="translated">기본 링커 스크립트는 &lt;code&gt;EIND = 0&lt;/code&gt; 코드에 정렬됩니다 . 코드가 &lt;code&gt;EIND != 0&lt;/code&gt; 설정에서 작동해야한다면 , 이름이 &lt;code&gt;.trampolines&lt;/code&gt; 로 시작하는 섹션을 &lt;code&gt;EIND&lt;/code&gt; 가 가리키는 세그먼트 에 배치하려면 사용자 정의 링커 스크립트를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="27ca561e84dd9753757548b177e64c001dc72487" translate="yes" xml:space="preserve">
          <source>The default memory model for the processor and operating system.</source>
          <target state="translated">프로세서 및 운영 체제의 기본 메모리 모델</target>
        </trans-unit>
        <trans-unit id="1d2c3331e29b4e0f75190cbcac7d2cc2935baa6d" translate="yes" xml:space="preserve">
          <source>The default size of &lt;code&gt;int&lt;/code&gt;s, &lt;code&gt;long&lt;/code&gt;s and pointers depends on the ABI. All the supported ABIs use 32-bit &lt;code&gt;int&lt;/code&gt;s. The n64 ABI uses 64-bit &lt;code&gt;long&lt;/code&gt;s, as does the 64-bit EABI; the others use 32-bit &lt;code&gt;long&lt;/code&gt;s. Pointers are the same size as &lt;code&gt;long&lt;/code&gt;s, or the same size as integer registers, whichever is smaller.</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; , &lt;code&gt;long&lt;/code&gt; 및 포인터 의 기본 크기 는 ABI에 따라 다릅니다. 지원되는 모든 ABI는 32 비트 &lt;code&gt;int&lt;/code&gt; 합니다. n64 ABI는 64 비트 EABI와 마찬가지로 64 비트 &lt;code&gt;long&lt;/code&gt; 을 사용합니다 . 나머지는 32 비트 &lt;code&gt;long&lt;/code&gt; 을 사용 합니다. 포인터는 &lt;code&gt;long&lt;/code&gt; 과 크기가 같 거나 정수 레지스터와 크기가 더 작은 쪽입니다.</target>
        </trans-unit>
        <trans-unit id="c7b0f9504e79ddd153856cb5f4d8eb1074e6f4cb" translate="yes" xml:space="preserve">
          <source>The default state for the &lt;code&gt;FENV_ACCESS&lt;/code&gt; pragma (C99 and C11 7.6.1).</source>
          <target state="translated">&lt;code&gt;FENV_ACCESS&lt;/code&gt; pragma 의 기본 상태 (C99 및 C11 7.6.1).</target>
        </trans-unit>
        <trans-unit id="177e9fccdcf6129808c994646c54fbba2a07d2f1" translate="yes" xml:space="preserve">
          <source>The default state for the &lt;code&gt;FP_CONTRACT&lt;/code&gt; pragma (C99 and C11 7.12.2).</source>
          <target state="translated">&lt;code&gt;FP_CONTRACT&lt;/code&gt; pragma (C99 및 C11 7.12.2) 의 기본 상태입니다 .</target>
        </trans-unit>
        <trans-unit id="2aba487b3647bdb911ee4d93a6d6e3bbfd1ab912" translate="yes" xml:space="preserve">
          <source>The default target is automatically quoted, as if it were given with</source>
          <target state="translated">기본 대상은 마치 다음과 같이 제공된 것처럼 자동으로 인용됩니다.</target>
        </trans-unit>
        <trans-unit id="33b715cc53246030b15f24132e973369879e225c" translate="yes" xml:space="preserve">
          <source>The default value is zero, which disables this feature. Note, this feature is not enabled by default with higher optimization levels (</source>
          <target state="translated">기본값은 0이며이 기능을 비활성화합니다. 이 기능은 기본적으로 더 높은 최적화 수준 (</target>
        </trans-unit>
        <trans-unit id="bbd9601e22b31b48a224ffc4033c0ab4f7fbfa78" translate="yes" xml:space="preserve">
          <source>The default value of &lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt; is</source>
          <target state="translated">&lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt; 의 기본값 은</target>
        </trans-unit>
        <trans-unit id="209814b876827ae56a611572209eb49a8bba5de1" translate="yes" xml:space="preserve">
          <source>The default value of this option is determined by the application binary interface for the target processor.</source>
          <target state="translated">이 옵션의 기본값은 대상 프로세서의 응용 프로그램 바이너리 인터페이스에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="59182b861f448516d9a37ab74276ea6b6b33c147" translate="yes" xml:space="preserve">
          <source>The default value of this option is enabled, thus the only useful form of the option is</source>
          <target state="translated">이 옵션의 기본값은 활성화되어 있으므로 유일하게 유용한 옵션은</target>
        </trans-unit>
        <trans-unit id="1a823e9ffdad4eb9044013582624dc9752e06eea" translate="yes" xml:space="preserve">
          <source>The default warning level of the</source>
          <target state="translated">의 기본 경고 수준</target>
        </trans-unit>
        <trans-unit id="c7308db0e02a6c747424ae6a4742ab7d5a6523ec" translate="yes" xml:space="preserve">
          <source>The default when in a standards compliant mode (</source>
          <target state="translated">표준 호환 모드 인 경우 기본값 (</target>
        </trans-unit>
        <trans-unit id="c45a650c66e86b129ff1159a971751cec60bc96d" translate="yes" xml:space="preserve">
          <source>The default without</source>
          <target state="translated">없는 기본</target>
        </trans-unit>
        <trans-unit id="ecb6ca065b9096c7acde0b3f9da92272ca10172c" translate="yes" xml:space="preserve">
          <source>The default x86-32 ABI assumes that the callee pops the stack for hidden pointer. However, on x86-32 Microsoft Windows targets, the compiler assumes that the caller pops the stack for hidden pointer.</source>
          <target state="translated">기본 x86-32 ABI는 수신자가 숨겨진 포인터에 대해 스택을 팝한다고 가정합니다. 그러나 x86-32 Microsoft Windows 대상에서 컴파일러는 호출자가 숨겨진 포인터에 대해 스택을 팝한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="a2e6fba24182b6c22f37f14e5bbdf01ab49ea815" translate="yes" xml:space="preserve">
          <source>The default, if no C language dialect options are given, is</source>
          <target state="translated">C 언어 방언 옵션이 제공되지 않은 경우 기본값은</target>
        </trans-unit>
        <trans-unit id="94e40f79f518daef10239cd573498a0a9fbea872" translate="yes" xml:space="preserve">
          <source>The default, if no C++ language dialect options are given, is</source>
          <target state="translated">C ++ 언어 방언 옵션이 제공되지 않은 경우 기본값은</target>
        </trans-unit>
        <trans-unit id="63d161b7c381e191c75f2893e8fc452452e1e3d3" translate="yes" xml:space="preserve">
          <source>The definition given in the Intel documentation allows only for the use of the types &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;long long&lt;/code&gt; or their unsigned counterparts. GCC allows any scalar type that is 1, 2, 4 or 8 bytes in size other than the C type &lt;code&gt;_Bool&lt;/code&gt; or the C++ type &lt;code&gt;bool&lt;/code&gt;. Operations on pointer arguments are performed as if the operands were of the &lt;code&gt;uintptr_t&lt;/code&gt; type. That is, they are not scaled by the size of the type to which the pointer points.</source>
          <target state="translated">인텔 설명서에 제공된 정의에 따라 &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;long&lt;/code&gt; , &lt;code&gt;long long&lt;/code&gt; 또는 서명되지 않은 상대방 유형 만 사용할 수 있습니다 . GCC는 C 유형 &lt;code&gt;_Bool&lt;/code&gt; 또는 C ++ 유형 &lt;code&gt;bool&lt;/code&gt; 이외의 1, 2, 4 또는 8 바이트 크기의 스칼라 유형을 허용합니다 . 피연산자가 &lt;code&gt;uintptr_t&lt;/code&gt; 유형 인 것처럼 포인터 인수에 대한 조작이 수행됩니다 . 즉, 포인터가 가리키는 유형의 크기에 따라 크기가 조정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="12d18656502db6e4e9c93de0479a82b56cb9d524" translate="yes" xml:space="preserve">
          <source>The definitions for &lt;code&gt;__DATE__&lt;/code&gt; and &lt;code&gt;__TIME__&lt;/code&gt; when respectively, the date and time of translation are not available (C90 6.8.8, C99 6.10.8, C11 6.10.8.1).</source>
          <target state="translated">&lt;code&gt;__DATE__&lt;/code&gt; 및 &lt;code&gt;__TIME__&lt;/code&gt; 에 대한 정의는 각각 번역 날짜 및 시간을 사용할 수 없습니다 (C90 6.8.8, C99 6.10.8, C11 6.10.8.1).</target>
        </trans-unit>
        <trans-unit id="d50e31983578e620136495305e55ed145625f1a3" translate="yes" xml:space="preserve">
          <source>The denominator n of fraction 1/n of the execution frequency of the entry block of a function that a basic block of this function needs to at least have in order to be considered hot. The default is 1000, which means that a basic block is considered hot in a function if it is executed more frequently than 1/1000 of the frequency of the entry block of the function. 0 means that it is never considered hot.</source>
          <target state="translated">이 함수의 기본 블록이 핫한 것으로 간주되기 위해 최소한 가져야하는 함수의 시작 블록 실행 빈도의 분수 1 / n의 분모 n입니다. 기본값은 1000입니다. 즉, 기본 블록이 함수의 시작 블록 빈도의 1/1000보다 자주 실행되는 경우 함수에서 핫으로 간주됩니다. 0은 뜨거운 것으로 간주되지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="75cdf285dab576e728fe4c1726581875dabc3071" translate="yes" xml:space="preserve">
          <source>The denominator n of fraction 1/n of the maximal execution count of a basic block in the entire program that a basic block needs to at least have in order to be considered hot. The default is 10000, which means that a basic block is considered hot if its execution count is greater than 1/10000 of the maximal execution count. 0 means that it is never considered hot. Used in non-LTO mode.</source>
          <target state="translated">전체 프로그램에서 기본 블록의 최대 실행 횟수 중 분수 1 / n의 분모 n은 기본 블록이 핫한 것으로 간주되기 위해 최소한 가져야하는 것입니다. 기본값은 10000입니다. 즉, 실행 횟수가 최대 실행 횟수의 1/10000보다 크면 기본 블록이 핫으로 간주됩니다. 0은 뜨거운 것으로 간주되지 않음을 의미합니다. 비 LTO 모드에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d8711313846a248f0818ef2198a1524b06952be7" translate="yes" xml:space="preserve">
          <source>The denominator n of fraction 1/n of the number of profiled runs of the entire program below which the execution count of a basic block must be in order for the basic block to be considered unlikely executed. The default is 20, which means that a basic block is considered unlikely executed if it is executed in fewer than 1/20, or 5%, of the runs of the program. 0 means that it is always considered unlikely executed.</source>
          <target state="translated">기본 블록이 실행될 가능성이없는 것으로 간주 되려면 기본 블록의 실행 횟수가 아래에 있어야하는 전체 프로그램의 프로파일 링 된 실행 수 중 분수 1 / n의 분모 n입니다. 기본값은 20입니다. 즉, 프로그램 실행의 1/20 또는 5 % 미만으로 실행되는 경우 기본 블록이 실행되지 않을 것으로 간주됩니다. 0은 항상 실행 가능성이 낮은 것으로 간주됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="a09ae46c0bc04395fafa29f4371d3dd1f0905098" translate="yes" xml:space="preserve">
          <source>The depth of search in the dominator tree for expressions to hoist. This is used to avoid quadratic behavior in hoisting algorithm. The value of 0 does not limit on the search, but may slow down compilation of huge functions.</source>
          <target state="translated">호이 스팅 할 식에 대한 도미네이터 트리에서의 검색 깊이. 호이 스팅 알고리즘에서 2 차 동작을 피하기 위해 사용됩니다. 0 값은 검색을 제한하지 않지만 거대한 함수의 컴파일 속도를 늦출 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14934208c61e859a6e7eb6b441a06008f55e391f" translate="yes" xml:space="preserve">
          <source>The device / architecture belongs to the XMEGA family of devices.</source>
          <target state="translated">장치 / 아키텍처는 XMEGA 장치 제품군에 속합니다.</target>
        </trans-unit>
        <trans-unit id="0848b55d6ef92bf5b121f28a3f70167cf843e9f0" translate="yes" xml:space="preserve">
          <source>The device has Read-Modify-Write instructions (XCH, LAC, LAS and LAT).</source>
          <target state="translated">이 장치에는 Read-Modify-Write 명령어 (XCH, LAC, LAS 및 LAT)가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c94be4f62c4adcfc5a43023ae724a73e574f4d44" translate="yes" xml:space="preserve">
          <source>The device has a hardware multiplier.</source>
          <target state="translated">이 장치에는 하드웨어 승수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="40eec38c7059a6f4d65d7d4102f16aec3f9f23ce" translate="yes" xml:space="preserve">
          <source>The device has the &lt;code&gt;EIJMP&lt;/code&gt; and &lt;code&gt;EICALL&lt;/code&gt; instructions. This is the case for devices with more than 128 KiB of program memory. This also means that the program counter (PC) is 3 bytes wide.</source>
          <target state="translated">장치에는 &lt;code&gt;EIJMP&lt;/code&gt; 및 &lt;code&gt;EICALL&lt;/code&gt; 명령이 있습니다. 128KiB 이상의 프로그램 메모리가있는 장치의 경우입니다. 이는 또한 프로그램 카운터 (PC)의 폭이 3 바이트임을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="7183cfd675e5fad71be960e9de6faa5f999d51c4" translate="yes" xml:space="preserve">
          <source>The device has the &lt;code&gt;ELPM R&lt;var&gt;n&lt;/var&gt;,Z&lt;/code&gt; and &lt;code&gt;ELPM
R&lt;var&gt;n&lt;/var&gt;,Z+&lt;/code&gt; instructions.</source>
          <target state="translated">이 장치에는 &lt;code&gt;ELPM R&lt;var&gt;n&lt;/var&gt;,Z&lt;/code&gt; 및 &lt;code&gt;ELPM R&lt;var&gt;n&lt;/var&gt;,Z+&lt;/code&gt; 명령이 있습니다.</target>
        </trans-unit>
        <trans-unit id="124acdeb9487e33b6bf2adad9222c95480d5e077" translate="yes" xml:space="preserve">
          <source>The device has the &lt;code&gt;ELPM&lt;/code&gt; instruction.</source>
          <target state="translated">장치에는 &lt;code&gt;ELPM&lt;/code&gt; 명령이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ace169ce6eef96ce4c8d2efd5bee4eef88f9d4da" translate="yes" xml:space="preserve">
          <source>The device has the &lt;code&gt;JMP&lt;/code&gt; and &lt;code&gt;CALL&lt;/code&gt; instructions. This is the case for devices with more than 8 KiB of program memory.</source>
          <target state="translated">장치에는 &lt;code&gt;JMP&lt;/code&gt; 및 &lt;code&gt;CALL&lt;/code&gt; 명령어가 있습니다. 프로그램 메모리가 8KiB 이상인 장치의 경우입니다.</target>
        </trans-unit>
        <trans-unit id="c648d34bf5dc6505ae5b97362b5aa073400b3ded" translate="yes" xml:space="preserve">
          <source>The device has the &lt;code&gt;LPM R&lt;var&gt;n&lt;/var&gt;,Z&lt;/code&gt; and &lt;code&gt;LPM R&lt;var&gt;n&lt;/var&gt;,Z+&lt;/code&gt; instructions.</source>
          <target state="translated">장치에는 &lt;code&gt;LPM R&lt;var&gt;n&lt;/var&gt;,Z&lt;/code&gt; 및 &lt;code&gt;LPM R&lt;var&gt;n&lt;/var&gt;,Z+&lt;/code&gt; 명령이 있습니다.</target>
        </trans-unit>
        <trans-unit id="aeb599358087e9ab1d870c33d3b39e9eeb6c15cf" translate="yes" xml:space="preserve">
          <source>The device has the &lt;code&gt;MOVW&lt;/code&gt; instruction to perform 16-bit register-register moves.</source>
          <target state="translated">이 장치에는 16 비트 레지스터 레지스터 이동을 수행 하는 &lt;code&gt;MOVW&lt;/code&gt; 명령이 있습니다.</target>
        </trans-unit>
        <trans-unit id="83a1356b9ac9ce24c84c12bd07e29feb04f94c12" translate="yes" xml:space="preserve">
          <source>The device has the &lt;code&gt;RAMPD&lt;/code&gt;, &lt;code&gt;RAMPX&lt;/code&gt;, &lt;code&gt;RAMPY&lt;/code&gt;, &lt;code&gt;RAMPZ&lt;/code&gt; special function register, respectively.</source>
          <target state="translated">이 장치에는 각각 &lt;code&gt;RAMPD&lt;/code&gt; , &lt;code&gt;RAMPX&lt;/code&gt; , &lt;code&gt;RAMPY&lt;/code&gt; , &lt;code&gt;RAMPZ&lt;/code&gt; 특수 기능 레지스터가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7440edf5c9a0d8bde64b1ecefe74df7b62918795" translate="yes" xml:space="preserve">
          <source>The device has the SPH (high part of stack pointer) special function register or has an 8-bit stack pointer, respectively. The definition of these macros is affected by</source>
          <target state="translated">이 장치에는 SPH (스택 포인터의 높은 부분) 특수 기능 레지스터가 있거나 각각 8 비트 스택 포인터가 있습니다. 이 매크로의 정의는 다음의 영향을받습니다.</target>
        </trans-unit>
        <trans-unit id="a15f34c198926a24e4b29d121787f367b6273a1a" translate="yes" xml:space="preserve">
          <source>The diff may or may not be colorized, following the same rules as for diagnostics (see</source>
          <target state="translated">diff는 진단과 동일한 규칙에 따라 색상이 지정되거나 표시되지 않을 수 있습니다 (참조</target>
        </trans-unit>
        <trans-unit id="bfb8bac86341e0faa063bc2c7464731f3754920b" translate="yes" xml:space="preserve">
          <source>The differences to the &lt;code&gt;naked&lt;/code&gt; function attribute are:</source>
          <target state="translated">&lt;code&gt;naked&lt;/code&gt; 함수 속성 의 차이점 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="caa2f3d0586724648ad5dc95b2dd6a57770fcc55" translate="yes" xml:space="preserve">
          <source>The direction of rounding when a floating-point number is converted to a narrower floating-point number (C90 6.2.1.4, C99 and C11 6.3.1.5).</source>
          <target state="translated">부동 소수점 숫자를 더 좁은 부동 소수점 숫자로 변환 할 때 반올림 방향 (C90 6.2.1.4, C99 및 C11 6.3.1.5).</target>
        </trans-unit>
        <trans-unit id="26fb3de478c5cf1596d7cf8a88ab611eedc18b11" translate="yes" xml:space="preserve">
          <source>The direction of rounding when an integer is converted to a floating-point number that cannot exactly represent the original value (C90 6.2.1.3, C99 and C11 6.3.1.4).</source>
          <target state="translated">정수가 원래 값 (C90 6.2.1.3, C99 및 C11 6.3.1.4)을 정확하게 나타낼 수없는 부동 소수점 숫자로 변환 될 때 반올림 방향.</target>
        </trans-unit>
        <trans-unit id="9c2a89eb8a493cddb0e17d65209367b348e4e331" translate="yes" xml:space="preserve">
          <source>The earliest version of MacOS X that this executable will run on is &lt;var&gt;version&lt;/var&gt;. Typical values of &lt;var&gt;version&lt;/var&gt; include &lt;code&gt;10.1&lt;/code&gt;, &lt;code&gt;10.2&lt;/code&gt;, and &lt;code&gt;10.3.9&lt;/code&gt;.</source>
          <target state="translated">이 실행 파일이 실행될 MacOS X의 초기 버전은 &lt;var&gt;version&lt;/var&gt; 입니다. &lt;var&gt;version&lt;/var&gt; 일반적인 값 은 &lt;code&gt;10.1&lt;/code&gt; , &lt;code&gt;10.2&lt;/code&gt; 및 &lt;code&gt;10.3.9&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4dc00d4d1ee11aa29f8972e4481c89ebd51afb01" translate="yes" xml:space="preserve">
          <source>The easiest way of satisfying these restrictions is to compile and link every module with the same</source>
          <target state="translated">이러한 제한을 만족시키는 가장 쉬운 방법은 모든 모듈을 컴파일하고 링크하는 것입니다</target>
        </trans-unit>
        <trans-unit id="ee24dbb06c4125c8c59c873450e471ac0298f125" translate="yes" xml:space="preserve">
          <source>The effect is equivalent to moving all references to the alias to a separate translation unit, renaming the alias to the aliased symbol, declaring it as weak, compiling the two separate translation units and performing a link with relocatable output (i.e. &lt;code&gt;ld -r&lt;/code&gt;) on them.</source>
          <target state="translated">이 효과는 별칭에 대한 모든 참조를 별도의 번역 단위로 이동하고, 별칭을 별칭이있는 기호로 이름을 바꾸고, 약한 것으로 선언하고, 두 개의 개별 번역 단위를 컴파일하고, 재배치 가능한 출력 (예 : &lt;code&gt;ld -r&lt;/code&gt; )을 사용 하여 링크를 수행하는 것과 같습니다 . 그들.</target>
        </trans-unit>
        <trans-unit id="40ce96812102dd380fc896f02591a99db980d416" translate="yes" xml:space="preserve">
          <source>The effect is equivalent to moving all references to the alias to a separate translation unit, renaming the alias to the aliased symbol, declaring it as weak, compiling the two separate translation units and performing a link with relocatable output (ie: &lt;code&gt;ld -r&lt;/code&gt;) on them.</source>
          <target state="translated">이 효과는 별명에 대한 모든 참조를 별개의 변환 단위로 이동하고 별명을 별명으로 바꾼 별명을 약한 것으로 선언하고 두 개의 별개의 변환 단위를 컴파일하고 재배치 가능 출력 (예 : &lt;code&gt;ld -r&lt;/code&gt; ) 으로 링크를 수행하는 것과 같습니다. 그들에.</target>
        </trans-unit>
        <trans-unit id="2fcdd3faf7319592c843ba96ea56c638eff89d9c" translate="yes" xml:space="preserve">
          <source>The effect of this is that GCC may, effectively, mark inline methods with &lt;code&gt;__attribute__ ((visibility (&quot;hidden&quot;)))&lt;/code&gt; so that they do not appear in the export table of a DSO and do not require a PLT indirection when used within the DSO. Enabling this option can have a dramatic effect on load and link times of a DSO as it massively reduces the size of the dynamic export table when the library makes heavy use of templates.</source>
          <target state="translated">이로 인해 GCC는 인라인 메소드를 &lt;code&gt;__attribute__ ((visibility (&quot;hidden&quot;)))&lt;/code&gt; 효과적으로 표시 하여 DSO의 익스포트 테이블에 나타나지 않고 PLT 간접 참조가 필요하지 않습니다. DSO. 이 옵션을 활성화하면 라이브러리가 템플릿을 많이 사용하는 경우 동적 내보내기 테이블의 크기가 크게 줄어들 기 때문에 DSO의로드 및 링크 시간에 큰 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0339dc59fd2ec7a99f69b1c58fc9500261d6af02" translate="yes" xml:space="preserve">
          <source>The effectiveness of some warnings depends on optimizations also being enabled. For example</source>
          <target state="translated">일부 경고의 효과는 활성화 된 최적화에 따라 달라집니다. 예를 들면</target>
        </trans-unit>
        <trans-unit id="a80b8b3ee96e1537d805054b77f62723800f759b" translate="yes" xml:space="preserve">
          <source>The elements of the input vectors are numbered in memory ordering of &lt;var&gt;vec0&lt;/var&gt; beginning at 0 and &lt;var&gt;vec1&lt;/var&gt; beginning at &lt;var&gt;N&lt;/var&gt;. The elements of &lt;var&gt;mask&lt;/var&gt; are considered modulo &lt;var&gt;N&lt;/var&gt; in the single-operand case and modulo &lt;em&gt;2*&lt;var&gt;N&lt;/var&gt;&lt;/em&gt; in the two-operand case.</source>
          <target state="translated">입력 벡터의 요소는 0에서 시작 하는 &lt;var&gt;vec0&lt;/var&gt; 및 &lt;var&gt;N&lt;/var&gt; 에서 시작하는 &lt;var&gt;vec1&lt;/var&gt; 의 메모리 순서로 번호가 매겨집니다 . 의 요소 &lt;var&gt;mask&lt;/var&gt; 모듈로 간주 &lt;var&gt;N&lt;/var&gt; 단일 피연산자 경우와 모듈로 &lt;em&gt;2 * &lt;/em&gt;&lt;em&gt; &lt;var&gt;N&lt;/var&gt; 을&lt;/em&gt; 두 피연산자 경우.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="03329c8955d8e056ec3aa9ef42249119fe358d03" translate="yes" xml:space="preserve">
          <source>The encoding of any of &lt;code&gt;wchar_t&lt;/code&gt;, &lt;code&gt;char16_t&lt;/code&gt;, and &lt;code&gt;char32_t&lt;/code&gt; where the corresponding standard encoding macro (&lt;code&gt;__STDC_ISO_10646__&lt;/code&gt;, &lt;code&gt;__STDC_UTF_16__&lt;/code&gt;, or &lt;code&gt;__STDC_UTF_32__&lt;/code&gt;) is not defined (C11 6.10.8.2).</source>
          <target state="translated">임의의 인코딩 &lt;code&gt;wchar_t&lt;/code&gt; , &lt;code&gt;char16_t&lt;/code&gt; 및 &lt;code&gt;char32_t&lt;/code&gt; 해당 규격 부호화 매크로 (여기서 &lt;code&gt;__STDC_ISO_10646__&lt;/code&gt; , &lt;code&gt;__STDC_UTF_16__&lt;/code&gt; 또는 &lt;code&gt;__STDC_UTF_32__&lt;/code&gt; 가 )가 정의되지 않은 경우 (C11 6.10.8.2).</target>
        </trans-unit>
        <trans-unit id="f0c42b29af2e3bb28afd21f635c0f39721670e06" translate="yes" xml:space="preserve">
          <source>The encoding of bit-fields has changed to allow bit-fields to be properly handled by the runtime functions that compute sizes and alignments of types that contain bit-fields. The previous encoding contained only the size of the bit-field. Using only this information it is not possible to reliably compute the size occupied by the bit-field. This is very important in the presence of the Boehm&amp;rsquo;s garbage collector because the objects are allocated using the typed memory facility available in this collector. The typed memory allocation requires information about where the pointers are located inside the object.</source>
          <target state="translated">비트 필드 인코딩은 비트 필드를 포함하는 유형의 크기와 정렬을 계산하는 런타임 함수에 의해 비트 필드를 올바르게 처리 할 수 ​​있도록 변경되었습니다. 이전 인코딩에는 비트 필드의 크기 만 포함되었습니다. 이 정보 만 사용하면 비트 필드가 차지하는 크기를 안정적으로 계산할 수 없습니다. 오브젝트는이 콜렉터에서 사용 가능한 유형화 된 메모리 기능을 사용하여 할당되므로 Boehm의 가비지 콜렉터가있는 경우 매우 중요합니다. 유형이 지정된 메모리 할당에는 포인터가 객체 내부에있는 위치에 대한 정보가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="32de7cb2a746befc3519adabd406682f138c91dc" translate="yes" xml:space="preserve">
          <source>The encoding of the branch hint instruction limits the hint to be within 256 instructions of the branch it is affecting. By default, GCC makes sure it is within 125.</source>
          <target state="translated">분기 힌트 명령어의 인코딩은 힌트가 영향을받는 분기의 256 명령어 내에 있도록 힌트를 제한합니다. 기본적으로 GCC는 125 이내인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="86931df671f82bbbca9166c366a69eb90410e2f2" translate="yes" xml:space="preserve">
          <source>The environment variable &lt;code&gt;GCC_COMPARE_DEBUG&lt;/code&gt;, if defined, non-empty and nonzero, implicitly enables</source>
          <target state="translated">비어 있지 않고 0이 아닌 환경 변수 &lt;code&gt;GCC_COMPARE_DEBUG&lt;/code&gt; 는 암시 적으로 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="f1abddc031f4887620e779e03fa9bce246eca769" translate="yes" xml:space="preserve">
          <source>The error is only generated if the pragma is present in the code after pre-processing has been completed. It does not matter however if the code containing the pragma is unreachable:</source>
          <target state="translated">사전 처리가 완료된 후 pragma가 코드에있는 경우에만 오류가 생성됩니다. 그러나 pragma를 포함하는 코드에 도달 할 수없는 경우에는 문제가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="62217b180fda693fac806123c3cedff899bcd7c2" translate="yes" xml:space="preserve">
          <source>The evaluation methods characterized by non-standard negative values of &lt;code&gt;FLT_EVAL_METHOD&lt;/code&gt; (C99 and C11 5.2.4.2.2).</source>
          <target state="translated">&lt;code&gt;FLT_EVAL_METHOD&lt;/code&gt; 의 비표준 음성 값 (C99 및 C11 5.2.4.2.2)을 특징으로하는 평가 방법 .</target>
        </trans-unit>
        <trans-unit id="e7ca0d5b7ee5cf7cc21b906f53631f0432c41aa1" translate="yes" xml:space="preserve">
          <source>The example above is correctly written as:</source>
          <target state="translated">위의 예는 다음과 같이 올바르게 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="2262d7979d1e6f669d9d267628d7f1a5e043c047" translate="yes" xml:space="preserve">
          <source>The execution counts are cumulative. If the example program were executed again without removing the</source>
          <target state="translated">실행 횟수는 누적됩니다. 예제 프로그램을 제거하지 않고 다시 실행 한 경우</target>
        </trans-unit>
        <trans-unit id="30cd9cacada80b254b465216587c60514745e9e0" translate="yes" xml:space="preserve">
          <source>The exported header file declaring the function the user calls would contain:</source>
          <target state="translated">사용자 호출에 포함 된 함수를 선언하는 내 보낸 헤더 파일 :</target>
        </trans-unit>
        <trans-unit id="6a3b0d1b517a2735ccea32622e6c16bbe062c918" translate="yes" xml:space="preserve">
          <source>The extended version of &lt;code&gt;__builtin_expect&lt;/code&gt; is not supported.</source>
          <target state="translated">&lt;code&gt;__builtin_expect&lt;/code&gt; 의 확장 버전은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e5f79933f130a6010408a53873b5c18d791196b0" translate="yes" xml:space="preserve">
          <source>The extended version of the ARMv7-A architecture with support for virtualization.</source>
          <target state="translated">가상화를 지원하는 ARMv7-A 아키텍처의 확장 버전입니다.</target>
        </trans-unit>
        <trans-unit id="f69903151111d03e37009b513bcf8f14816a93e4" translate="yes" xml:space="preserve">
          <source>The extent to which suggestions made by using the &lt;code&gt;register&lt;/code&gt; storage-class specifier are effective (C90 6.5.1, C99 and C11 6.7.1).</source>
          <target state="translated">&lt;code&gt;register&lt;/code&gt; 스토리지 클래스 지정자 를 사용하여 제안한 범위 가 유효합니다 (C90 6.5.1, C99 및 C11 6.7.1).</target>
        </trans-unit>
        <trans-unit id="99d4acdb059ef7e8275eb6991f7b3fdb57cb4d7e" translate="yes" xml:space="preserve">
          <source>The extent to which suggestions made by using the inline function specifier are effective (C99 and C11 6.7.4).</source>
          <target state="translated">인라인 함수 지정자를 사용하여 제안한 범위가 유효합니다 (C99 및 C11 6.7.4).</target>
        </trans-unit>
        <trans-unit id="04fbc7508d5d457aedc840547581d13fb785d13c" translate="yes" xml:space="preserve">
          <source>The file</source>
          <target state="translated">파일</target>
        </trans-unit>
        <trans-unit id="be1544009a06e2ed9b8c04313febbe4a5054a34c" translate="yes" xml:space="preserve">
          <source>The filename and replacement string escape backslash as &amp;ldquo;\\&quot;, tab as &amp;ldquo;\t&amp;rdquo;, newline as &amp;ldquo;\n&amp;rdquo;, double quotes as &amp;ldquo;\&quot;&amp;rdquo;, non-printable characters as octal (e.g. vertical tab as &amp;ldquo;\013&amp;rdquo;).</source>
          <target state="translated">파일 이름 및 대체 문자열 이스케이프 백 슬래시는 &quot;\\&quot;, 탭은 &quot;\ t&quot;, 줄 바꿈은 &quot;\ n&quot;, 큰 따옴표는 &quot;\&quot; &quot;, 인쇄 할 수없는 문자는 8 진수 (예 : 세로 탭은&quot;\ 013 &quot; ).</target>
        </trans-unit>
        <trans-unit id="052b9a9ce595b22df1664059ccb4ac71ceb3b652" translate="yes" xml:space="preserve">
          <source>The files used by gcov.</source>
          <target state="translated">gcov가 사용하는 파일.</target>
        </trans-unit>
        <trans-unit id="5f9146bf44aa8a552083fbcdde4f12b382de6ccc" translate="yes" xml:space="preserve">
          <source>The first argument is the address of the start of the current function, which may be looked up exactly in the symbol table.</source>
          <target state="translated">첫 번째 인수는 현재 함수의 시작 주소이며 심볼 테이블에서 정확하게 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d40b2392c804eafb9e2a38b040dcc6ad4b8a38cb" translate="yes" xml:space="preserve">
          <source>The first argument, &lt;var&gt;auxv&lt;/var&gt;, is the address of an auxiliary register, the second argument, &lt;var&gt;val&lt;/var&gt;, is a compile time constant to be written to the register. Generates:</source>
          <target state="translated">첫 번째 인수 &lt;var&gt;auxv&lt;/var&gt; 는 보조 레지스터의 주소이고 두 번째 인수 &lt;var&gt;val&lt;/var&gt; 은 레지스터에 기록 할 컴파일 시간 상수입니다. 생성합니다 :</target>
        </trans-unit>
        <trans-unit id="1bb8468783d812fcfe3a90c5c3005fc31c3a8b43" translate="yes" xml:space="preserve">
          <source>The first built-in function allows arbitrary integral types for operands and the result type must be pointer to some integral type other than enumerated or boolean type, the rest of the built-in functions have explicit integer types.</source>
          <target state="translated">첫 번째 내장 함수는 피연산자에 대해 임의의 정수 유형을 허용하며 결과 유형은 열거 형 또는 부울 유형이 아닌 일부 정수 유형에 대한 포인터 여야하며 나머지 내장 함수에는 명시 적 정수 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="766dbe1354f0d010e9b9752b025269447d8bacdc" translate="yes" xml:space="preserve">
          <source>The first number on each line is the &amp;ldquo;user time&amp;rdquo;, that is time spent executing the program itself. The second number is &amp;ldquo;system time&amp;rdquo;, time spent executing operating system routines on behalf of the program. Both numbers are in seconds.</source>
          <target state="translated">각 줄의 첫 번째 숫자는&amp;ldquo;사용자 시간&amp;rdquo;, 즉 프로그램 자체를 실행하는 데 소요 된 시간입니다. 두 번째 숫자는&amp;ldquo;시스템 시간&amp;rdquo;이며 프로그램 대신 운영 체제 루틴을 실행하는 데 소요 된 시간입니다. 두 숫자는 초입니다.</target>
        </trans-unit>
        <trans-unit id="7705a0a1f8fdbe72b6eed476ebaac5e4596393cb" translate="yes" xml:space="preserve">
          <source>The first operand is the number of a register to be written, the second operand is a compile time constant to write into that register. Generates:</source>
          <target state="translated">첫 번째 피연산자는 기록 할 레지스터의 수이고, 두 번째 피연산자는 해당 레지스터에 기록 할 컴파일 시간 상수입니다. 생성합니다 :</target>
        </trans-unit>
        <trans-unit id="5403326826a0ff4e3670389f165daf4e08127b0b" translate="yes" xml:space="preserve">
          <source>The first step in using these extensions is to provide the necessary data types. This should be done using an appropriate &lt;code&gt;typedef&lt;/code&gt;:</source>
          <target state="translated">이러한 확장을 사용하는 첫 번째 단계는 필요한 데이터 유형을 제공하는 것입니다. 적절한 &lt;code&gt;typedef&lt;/code&gt; 를 사용하여 수행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0180fb5f9566434bbaf5187f78b901ca8a7ed3d8" translate="yes" xml:space="preserve">
          <source>The first two invocations to GCC save a bytecode representation of GIMPLE into special ELF sections inside</source>
          <target state="translated">GCC를 처음 두 번 호출하면 GIMPLE의 바이트 코드 표현이 내부의 특수 ELF 섹션에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="d7463018cc3efdf04fea2a1a9520f2dcaa8a917d" translate="yes" xml:space="preserve">
          <source>The fixed-point types are &lt;code&gt;short _Fract&lt;/code&gt;, &lt;code&gt;_Fract&lt;/code&gt;, &lt;code&gt;long _Fract&lt;/code&gt;, &lt;code&gt;long long _Fract&lt;/code&gt;, &lt;code&gt;unsigned short _Fract&lt;/code&gt;, &lt;code&gt;unsigned _Fract&lt;/code&gt;, &lt;code&gt;unsigned long _Fract&lt;/code&gt;, &lt;code&gt;unsigned long long _Fract&lt;/code&gt;, &lt;code&gt;_Sat short _Fract&lt;/code&gt;, &lt;code&gt;_Sat _Fract&lt;/code&gt;, &lt;code&gt;_Sat long _Fract&lt;/code&gt;, &lt;code&gt;_Sat long long _Fract&lt;/code&gt;, &lt;code&gt;_Sat unsigned short _Fract&lt;/code&gt;, &lt;code&gt;_Sat unsigned _Fract&lt;/code&gt;, &lt;code&gt;_Sat unsigned long _Fract&lt;/code&gt;, &lt;code&gt;_Sat unsigned long long _Fract&lt;/code&gt;, &lt;code&gt;short _Accum&lt;/code&gt;, &lt;code&gt;_Accum&lt;/code&gt;, &lt;code&gt;long _Accum&lt;/code&gt;, &lt;code&gt;long long _Accum&lt;/code&gt;, &lt;code&gt;unsigned short _Accum&lt;/code&gt;, &lt;code&gt;unsigned _Accum&lt;/code&gt;, &lt;code&gt;unsigned long _Accum&lt;/code&gt;, &lt;code&gt;unsigned long long _Accum&lt;/code&gt;, &lt;code&gt;_Sat short _Accum&lt;/code&gt;, &lt;code&gt;_Sat _Accum&lt;/code&gt;, &lt;code&gt;_Sat long _Accum&lt;/code&gt;, &lt;code&gt;_Sat long long _Accum&lt;/code&gt;, &lt;code&gt;_Sat unsigned short _Accum&lt;/code&gt;, &lt;code&gt;_Sat unsigned _Accum&lt;/code&gt;, &lt;code&gt;_Sat unsigned long _Accum&lt;/code&gt;, &lt;code&gt;_Sat unsigned long long _Accum&lt;/code&gt;.</source>
          <target state="translated">고정 소수점 형식은 &lt;code&gt;short _Fract&lt;/code&gt; , &lt;code&gt;_Fract&lt;/code&gt; , &lt;code&gt;long _Fract&lt;/code&gt; , &lt;code&gt;long long _Fract&lt;/code&gt; , &lt;code&gt;unsigned short _Fract&lt;/code&gt; , &lt;code&gt;unsigned _Fract&lt;/code&gt; , &lt;code&gt;unsigned long _Fract&lt;/code&gt; , &lt;code&gt;unsigned long long _Fract&lt;/code&gt; , &lt;code&gt;_Sat short _Fract&lt;/code&gt; , &lt;code&gt;_Sat _Fract&lt;/code&gt; , &lt;code&gt;_Sat long _Fract&lt;/code&gt; , &lt;code&gt;_Sat long long _Fract&lt;/code&gt; , &lt;code&gt;_Sat unsigned short _Fract&lt;/code&gt; , &lt;code&gt;_Sat unsigned _Fract&lt;/code&gt; , &lt;code&gt;_Sat unsigned long _Fract&lt;/code&gt; , &lt;code&gt;_Sat unsigned long long _Fract&lt;/code&gt; , &lt;code&gt;short _Accum&lt;/code&gt; , &lt;code&gt;_Accum&lt;/code&gt; , &lt;code&gt;long _Accum&lt;/code&gt; , &lt;code&gt;long long _Accum&lt;/code&gt; , &lt;code&gt;unsigned short _Accum&lt;/code&gt; , &lt;code&gt;unsigned _Accum&lt;/code&gt; , &lt;code&gt;unsigned long _Accum&lt;/code&gt; , &lt;code&gt;unsigned long long _Accum&lt;/code&gt; , &lt;code&gt;_Sat short _Accum&lt;/code&gt; , &lt;code&gt;_Sat _Accum&lt;/code&gt; , &lt;code&gt;_Sat long _Accum&lt;/code&gt; , &lt;code&gt;_Sat long long _Accum&lt;/code&gt; , &lt;code&gt;_Sat unsigned short _Accum&lt;/code&gt; , &lt;code&gt;_Sat unsigned _Accum&lt;/code&gt; , &lt;code&gt;_Sat unsigned long _Accum&lt;/code&gt; , &lt;code&gt;_Sat unsigned long long _Accum&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3caefb409c9894c159fb9e3de06457a892f7b065" translate="yes" xml:space="preserve">
          <source>The flag makes these changes to GCC&amp;rsquo;s linkage model:</source>
          <target state="translated">이 플래그는 GCC의 연계 모델을 다음과 같이 변경합니다.</target>
        </trans-unit>
        <trans-unit id="e89357c25217d9e6ea0399e085ee6ac916e2228f" translate="yes" xml:space="preserve">
          <source>The flag output constraints are not supported in thumb1 mode.</source>
          <target state="translated">플래그 출력 제약 조건은 thumb1 모드에서 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="398abcfd0bda984ca55650d923231a3e23d99caf" translate="yes" xml:space="preserve">
          <source>The flag output constraints for the ARM family are of the form &amp;lsquo;</source>
          <target state="translated">ARM 제품군에 대한 플래그 출력 제약 조건은 '</target>
        </trans-unit>
        <trans-unit id="467579e58b2ed3f9e1f5da092ecc00a08220e553" translate="yes" xml:space="preserve">
          <source>The flag output constraints for the x86 family are of the form &amp;lsquo;</source>
          <target state="translated">x86 제품군의 플래그 출력 제한 조건은 '</target>
        </trans-unit>
        <trans-unit id="08b70c97084691cff3ef37f7ca63544f38157171" translate="yes" xml:space="preserve">
          <source>The flags register.</source>
          <target state="translated">플래그가 등록됩니다.</target>
        </trans-unit>
        <trans-unit id="bdec47de335eba5411aba4ed82b1290026a8b9df" translate="yes" xml:space="preserve">
          <source>The floating-point constant 0.0</source>
          <target state="translated">부동 소수점 상수 0.0</target>
        </trans-unit>
        <trans-unit id="ec2c9b05e5630a06e86a36a4fbe950b6561191c6" translate="yes" xml:space="preserve">
          <source>The following</source>
          <target state="translated">다음과 같은</target>
        </trans-unit>
        <trans-unit id="3c5af523cdaaa4e1970de9cf32fc6b6194b0929d" translate="yes" xml:space="preserve">
          <source>The following CPU names can be detected:</source>
          <target state="translated">다음과 같은 CPU 이름을 감지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f10647ac5c4280bde68061d0442176ac21bf7e2" translate="yes" xml:space="preserve">
          <source>The following additional built-in functions are also available for the PowerPC family of processors, starting with ISA 3.0 (</source>
          <target state="translated">ISA 3.0부터 PowerPC 프로세서 제품군에 대해 다음과 같은 추가 내장 기능을 사용할 수 있습니다 (</target>
        </trans-unit>
        <trans-unit id="1929bf7289a9ecdc2dad5969b2604877133b0494" translate="yes" xml:space="preserve">
          <source>The following additional built-in functions are also available for the PowerPC family of processors, starting with ISA 3.0 or later:</source>
          <target state="translated">ISA 3.0 이상부터 PowerPC 프로세서 제품군에 대해 다음과 같은 추가 내장 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b6e450e5b4547d8cc58a1ea785d39c551b41c7f" translate="yes" xml:space="preserve">
          <source>The following are a set of changes to ISO/IEC 14882:1998 (aka C++98) that document the exact semantics of the language extension.</source>
          <target state="translated">다음은 언어 확장의 정확한 의미를 설명하는 ISO / IEC 14882 : 1998 (일명 C ++ 98)의 변경 사항입니다.</target>
        </trans-unit>
        <trans-unit id="973ba60cc5ca780083859b39f3e2346700d51250" translate="yes" xml:space="preserve">
          <source>The following are a set of changes to ISO/IEC 9899:1999 (aka C99) that document the exact semantics of the language extension.</source>
          <target state="translated">다음은 언어 확장의 정확한 의미를 설명하는 ISO / IEC 9899 : 1999 (일명 C99)의 변경 사항입니다.</target>
        </trans-unit>
        <trans-unit id="ebfbe098b1dd5eca0cbfbb3ca87cce639c317631" translate="yes" xml:space="preserve">
          <source>The following attributes are available on Microsoft Windows and Symbian OS targets.</source>
          <target state="translated">Microsoft Windows 및 Symbian OS 대상에서 다음 속성을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75d2d7b6e92a2c518243634b77f2438ea7a789b2" translate="yes" xml:space="preserve">
          <source>The following attributes are supported on most targets.</source>
          <target state="translated">대부분의 대상에서 다음 속성이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="f3abf3f6e4762f0945d50d1dadcf30c08d9bb36f" translate="yes" xml:space="preserve">
          <source>The following basic built-in functions require</source>
          <target state="translated">다음과 같은 기본 내장 기능이 필요합니다</target>
        </trans-unit>
        <trans-unit id="e3618b6444ab4403d286bb790c65250955a9b750" translate="yes" xml:space="preserve">
          <source>The following basic built-in functions, which are also supported on x86 targets, require</source>
          <target state="translated">x86 대상에서도 지원되는 다음과 같은 기본 내장 기능이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="369096374260c4b128f072244e93419c1bf1630f" translate="yes" xml:space="preserve">
          <source>The following built-in function is always available.</source>
          <target state="translated">다음과 같은 내장 기능을 항상 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0dad43e81aa335fef875c6f114a13ef9920a9d7" translate="yes" xml:space="preserve">
          <source>The following built-in function is available when</source>
          <target state="translated">다음과 같은 내장 기능을 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="04398186d020848766aea5fdd0b1552e99124d98" translate="yes" xml:space="preserve">
          <source>The following built-in functions allow checking if simple arithmetic operation would overflow.</source>
          <target state="translated">다음의 내장 함수를 사용하면 간단한 산술 연산이 오버플로되는지 검사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c890e563c5fad880f7759533a175fe222845037" translate="yes" xml:space="preserve">
          <source>The following built-in functions allow performing simple arithmetic operations together with checking whether the operations overflowed.</source>
          <target state="translated">다음과 같은 내장 함수를 사용하면 연산이 오버플로되었는지 여부를 확인하는 동시에 간단한 산술 연산을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="036eb93cb5a048428c65535ab685e9ef099b6ed1" translate="yes" xml:space="preserve">
          <source>The following built-in functions approximately match the requirements for the C++11 memory model. They are all identified by being prefixed with &amp;lsquo;</source>
          <target state="translated">다음 내장 함수는 C ++ 11 메모리 모델의 요구 사항과 거의 일치합니다. 그것들은 모두 접두사 '</target>
        </trans-unit>
        <trans-unit id="bdf24977f571452f19f365486502e966dab5d0e9" translate="yes" xml:space="preserve">
          <source>The following built-in functions are also available for the PowerPC family of processors, starting with ISA 3.0 or later (</source>
          <target state="translated">ISA 3.0 이상부터 PowerPC 프로세서 제품군에 대해 다음과 같은 내장 기능을 사용할 수 있습니다 (</target>
        </trans-unit>
        <trans-unit id="3d2195469599cbd3dc33d7718d1e125824d6001b" translate="yes" xml:space="preserve">
          <source>The following built-in functions are also available on all PowerPC processors:</source>
          <target state="translated">모든 PowerPC 프로세서에서 다음과 같은 내장 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="813e5a763e7aaceeb023e2843416ac3c7a436f0e" translate="yes" xml:space="preserve">
          <source>The following built-in functions are always available and can be used to check the target platform type.</source>
          <target state="translated">다음과 같은 내장 기능을 항상 사용할 수 있으며 대상 플랫폼 유형을 확인하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3a8ba0cceaa78de81b273be464b1e1bbe129653" translate="yes" xml:space="preserve">
          <source>The following built-in functions are always available.</source>
          <target state="translated">다음과 같은 내장 기능을 항상 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ecfceed60efae2019076e7ea0c389384453f2603" translate="yes" xml:space="preserve">
          <source>The following built-in functions are always available. They all generate a Nios II Custom Instruction. The name of the function represents the types that the function takes and returns. The letter before the &lt;code&gt;n&lt;/code&gt; is the return type or void if absent. The &lt;code&gt;n&lt;/code&gt; represents the first parameter to all the custom instructions, the custom instruction number. The two letters after the &lt;code&gt;n&lt;/code&gt; represent the up to two parameters to the function.</source>
          <target state="translated">다음과 같은 내장 기능을 항상 사용할 수 있습니다. 그들은 모두 Nios II Custom Instruction을 생성합니다. 함수의 이름은 함수가 가져오고 리턴하는 유형을 나타냅니다. &lt;code&gt;n&lt;/code&gt; 앞의 문자 는 반환 유형이거나없는 경우 void입니다. &lt;code&gt;n&lt;/code&gt; 모든 사용자 명령은 사용자 명령 번호 제 파라미터를 나타낸다. &lt;code&gt;n&lt;/code&gt; 다음의 두 문자 는 함수에 대한 최대 두 개의 매개 변수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1af31ca0a6a69044f40261c9e3766a7bcb45f606" translate="yes" xml:space="preserve">
          <source>The following built-in functions are always available. They all generate the machine instruction that is part of the name.</source>
          <target state="translated">다음과 같은 내장 기능을 항상 사용할 수 있습니다. 모두 이름의 일부인 기계 명령어를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="f2ff9df600bfad81ae439ad951e20e63358dbf59" translate="yes" xml:space="preserve">
          <source>The following built-in functions are always with</source>
          <target state="translated">다음 내장 기능은 항상</target>
        </trans-unit>
        <trans-unit id="458872e50bacb1837e94edbee1f56e422633f9ac" translate="yes" xml:space="preserve">
          <source>The following built-in functions are available for eBPF targets.</source>
          <target state="translated">다음 내장 함수는 eBPF 대상에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a04c80c36791193b7507cbe8aa1b633c63c489df" translate="yes" xml:space="preserve">
          <source>The following built-in functions are available for the PowerPC family of processors, starting with ISA 3.0 or later (</source>
          <target state="translated">ISA 3.0 이상부터 PowerPC 프로세서 제품군에 대해 다음과 같은 내장 기능을 사용할 수 있습니다 (</target>
        </trans-unit>
        <trans-unit id="f55e084e6b2bbe2c1d4a74d78f9b5a79a08af791" translate="yes" xml:space="preserve">
          <source>The following built-in functions are available on Linux 64-bit systems that use the ISA 3.0 instruction set (</source>
          <target state="translated">다음 내장 기능은 ISA 3.0 명령어 세트를 사용하는 Linux 64 비트 시스템에서 사용할 수 있습니다 (</target>
        </trans-unit>
        <trans-unit id="60ee9c1229ed14f7445701a16ac0e8900c850fff" translate="yes" xml:space="preserve">
          <source>The following built-in functions are available on systems that use the OSF/1 PALcode. Normally they invoke the &lt;code&gt;rduniq&lt;/code&gt; and &lt;code&gt;wruniq&lt;/code&gt; PAL calls, but when invoked with</source>
          <target state="translated">다음 내장 기능은 OSF / 1 PALcode를 사용하는 시스템에서 사용 가능합니다. 일반적으로 그들은 &lt;code&gt;rduniq&lt;/code&gt; 및 &lt;code&gt;wruniq&lt;/code&gt; PAL 호출을 호출하지만</target>
        </trans-unit>
        <trans-unit id="b74dd20c718ebc6e02b444b4df3b1293b7b777b2" translate="yes" xml:space="preserve">
          <source>The following built-in functions are available when</source>
          <target state="translated">다음과 같은 내장 기능을 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="776fae37ac2c3903c04468f14c58000c2d1da4aa" translate="yes" xml:space="preserve">
          <source>The following built-in functions are available when hardware decimal floating point (</source>
          <target state="translated">하드웨어 10 진 부동 소수점 (</target>
        </trans-unit>
        <trans-unit id="8714301d00c50c02cc49a9653de9815ca07de516" translate="yes" xml:space="preserve">
          <source>The following built-in functions are changed to generate new SSE4.1 instructions when</source>
          <target state="translated">다음과 같은 내장 기능이 다음과 같은 경우 새 SSE4.1 명령어를 생성하도록 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="b44b1444a99a16bc850f8161bf3acb0269e3baa5" translate="yes" xml:space="preserve">
          <source>The following built-in functions are changed to generate new SSE4.2 instructions when</source>
          <target state="translated">다음과 같은 내장 함수가 다음과 같은 경우 새 SSE4.2 명령어를 생성하도록 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="eabb92d44c62afaf48fdd22b40e596e4fd090919" translate="yes" xml:space="preserve">
          <source>The following built-in functions are intended to be compatible with those described in the Intel Itanium Processor-specific Application Binary Interface, section 7.4. As such, they depart from normal GCC practice by not using the &amp;lsquo;</source>
          <target state="translated">다음 내장 기능은 Intel Itanium 프로세서 관련 응용 프로그램 이진 인터페이스 섹션 7.4에 설명 된 기능과 호환되도록 설계되었습니다. 따라서 '</target>
        </trans-unit>
        <trans-unit id="831ee0ed207b248768e0caf3e133139a3eef8c8d" translate="yes" xml:space="preserve">
          <source>The following built-in functions are made available by</source>
          <target state="translated">다음과 같은 내장 기능을 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="919b7b433192dee8b53ccb79ce4649060e122b82" translate="yes" xml:space="preserve">
          <source>The following built-in functions are made available either with</source>
          <target state="translated">다음과 같은 내장 기능을 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="6ccb74ff52e53e43a5c01fd32034e69dc2ae153d" translate="yes" xml:space="preserve">
          <source>The following built-in functions are provided for ARC targets. The built-ins generate the corresponding assembly instructions. In the examples given below, the generated code often requires an operand or result to be in a register. Where necessary further code will be generated to ensure this is true, but for brevity this is not described in each case.</source>
          <target state="translated">다음 내장 기능이 ARC 대상에 제공됩니다. 내장 기능은 해당 조립 지침을 생성합니다. 아래 예제에서 생성 된 코드는 종종 피연산자 또는 결과가 레지스터에 있어야합니다. 필요한 경우 이것이 사실인지 확인하기 위해 추가 코드가 생성되지만 간결성을 위해 각 경우에 설명되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="75e740a11dbfb99edbd20d26c1a8e83fccd42794" translate="yes" xml:space="preserve">
          <source>The following built-in functions are supported on the SH1, SH2, SH3 and SH4 families of processors:</source>
          <target state="translated">SH1, SH2, SH3 및 SH4 프로세서 제품군에서는 다음과 같은 내장 기능이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="f89feba67398daada2fcc2ab442cabeeabf1732a" translate="yes" xml:space="preserve">
          <source>The following built-in functions map directly to a particular MIPS DSP REV 2 instruction. Please refer to the architecture specification for details on what each instruction does.</source>
          <target state="translated">다음 내장 기능은 특정 MIPS DSP REV 2 명령어에 직접 매핑됩니다. 각 명령어의 기능에 대한 자세한 내용은 아키텍처 사양을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f21bc507e92bf45d2cc2ac3a1f9c044c10482e71" translate="yes" xml:space="preserve">
          <source>The following built-in functions map directly to a particular MIPS DSP instruction. Please refer to the architecture specification for details on what each instruction does.</source>
          <target state="translated">다음 내장 기능은 특정 MIPS DSP 명령에 직접 매핑됩니다. 각 명령어의 기능에 대한 자세한 내용은 아키텍처 사양을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b9487d4f044e41716b6891b45e9753c6c90cda37" translate="yes" xml:space="preserve">
          <source>The following built-in spec functions are provided:</source>
          <target state="translated">다음과 같은 내장 스펙 기능이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="2786d4ea3cbfa4ab2030f517cdaa8499a49060e7" translate="yes" xml:space="preserve">
          <source>The following built-in vector functions are available for the PowerPC family of processors, starting with ISA 3.0 or later (</source>
          <target state="translated">다음 내장 벡터 기능은 ISA 3.0 이상부터 PowerPC 프로세서 제품군에 사용할 수 있습니다 (</target>
        </trans-unit>
        <trans-unit id="1a38882cce5b0e920f7bd6e773e987b24fc62b96" translate="yes" xml:space="preserve">
          <source>The following choices of &lt;var&gt;name&lt;/var&gt; are available on AArch64 targets:</source>
          <target state="translated">AArch64 대상에서 다음과 같은 &lt;var&gt;name&lt;/var&gt; 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffd16ee07975a361776687491f1d62adb24d9f69" translate="yes" xml:space="preserve">
          <source>The following code initializes a variable &lt;code&gt;pfoo&lt;/code&gt; located in static storage with a 24-bit address:</source>
          <target state="translated">다음 코드 는 정적 저장소에 있는 변수 &lt;code&gt;pfoo&lt;/code&gt; 를 24 비트 주소로 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="8780ef62a5e7e11e92254999b8a74301b194fac1" translate="yes" xml:space="preserve">
          <source>The following example demonstrates a case where you need to use the &lt;code&gt;volatile&lt;/code&gt; qualifier. It uses the x86 &lt;code&gt;rdtsc&lt;/code&gt; instruction, which reads the computer&amp;rsquo;s time-stamp counter. Without the &lt;code&gt;volatile&lt;/code&gt; qualifier, the optimizers might assume that the &lt;code&gt;asm&lt;/code&gt; block will always return the same value and therefore optimize away the second call.</source>
          <target state="translated">다음 예제는 &lt;code&gt;volatile&lt;/code&gt; 한정자 를 사용해야하는 경우를 보여줍니다 . 컴퓨터의 타임 스탬프 카운터를 읽는 x86 &lt;code&gt;rdtsc&lt;/code&gt; 명령어를 사용합니다 . &lt;code&gt;volatile&lt;/code&gt; 한정자가 없으면 옵티마이 저는 &lt;code&gt;asm&lt;/code&gt; 블록이 항상 동일한 값을 리턴 한다고 가정 하여 두 번째 호출을 최적화합니다.</target>
        </trans-unit>
        <trans-unit id="4b55ceed13d64aeb896ca2cdaff9ea36b6ca968e" translate="yes" xml:space="preserve">
          <source>The following example shows an &lt;code&gt;asm goto&lt;/code&gt; that uses a memory clobber.</source>
          <target state="translated">다음 예제는 메모리 클로버를 사용 하는 &lt;code&gt;asm goto&lt;/code&gt; 를 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="1ff7cf2e98d1cdb33c85dfebf8c45ca797099418" translate="yes" xml:space="preserve">
          <source>The following examples are all valid uses of these attributes on Epiphany targets:</source>
          <target state="translated">다음 예제는 Epiphany 대상에서 이러한 속성을 모두 올바르게 사용합니다.</target>
        </trans-unit>
        <trans-unit id="133fac7dc52d4be5d02e2ee9f610bd07e27fcb98" translate="yes" xml:space="preserve">
          <source>The following extension options are common to the listed CPUs:</source>
          <target state="translated">다음 확장 옵션은 나열된 CPU에 공통입니다.</target>
        </trans-unit>
        <trans-unit id="585cd94a6c81e37ef942855a4e92760bf2aec5f9" translate="yes" xml:space="preserve">
          <source>The following features can be detected:</source>
          <target state="translated">다음과 같은 기능을 감지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4cbf90dbd434ca4f2150e22b1aa4b1a78b14c334" translate="yes" xml:space="preserve">
          <source>The following floating-point built-in functions are always available. All of them implement the function that is part of the name.</source>
          <target state="translated">다음과 같은 부동 소수점 내장 함수를 항상 사용할 수 있습니다. 그들 모두는 이름의 일부인 기능을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="e1be7f4828f104915bab6627d884213aaa11c9fc" translate="yes" xml:space="preserve">
          <source>The following functions require</source>
          <target state="translated">다음 기능이 필요합니다</target>
        </trans-unit>
        <trans-unit id="31dedf0887f3cce8587f9fc85d3da325ab3058ce" translate="yes" xml:space="preserve">
          <source>The following functions require option</source>
          <target state="translated">다음 기능에는 옵션이 필요합니다</target>
        </trans-unit>
        <trans-unit id="f640e02367945c84624ea0fa79ae818fc5491bf9" translate="yes" xml:space="preserve">
          <source>The following high level HTM interface is made available by including &lt;code&gt;&amp;lt;htmxlintrin.h&amp;gt;&lt;/code&gt; and using</source>
          <target state="translated">&lt;code&gt;&amp;lt;htmxlintrin.h&amp;gt;&lt;/code&gt; 를 포함 하고 다음을 사용하여 다음과 같은 고급 HTM 인터페이스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="102c1a366ea24351d92a6971e3810fc18f2df2f4" translate="yes" xml:space="preserve">
          <source>The following i386 example uses the &lt;var&gt;asmSymbolicName&lt;/var&gt; syntax. It produces the same result as the code above, but some may consider it more readable or more maintainable since reordering index numbers is not necessary when adding or removing operands. The names &lt;code&gt;aIndex&lt;/code&gt; and &lt;code&gt;aMask&lt;/code&gt; are only used in this example to emphasize which names get used where. It is acceptable to reuse the names &lt;code&gt;Index&lt;/code&gt; and &lt;code&gt;Mask&lt;/code&gt;.</source>
          <target state="translated">다음 i386 예제는 &lt;var&gt;asmSymbolicName&lt;/var&gt; 구문을 사용 합니다. 위의 코드와 동일한 결과를 생성하지만 일부는 피연산자를 추가하거나 제거 할 때 인덱스 번호를 다시 정렬 할 필요가 없으므로 더 읽기 쉽고 유지 관리가 용이하다고 생각할 수 있습니다. 이 예제에서는 &lt;code&gt;aIndex&lt;/code&gt; 및 &lt;code&gt;aMask&lt;/code&gt; 라는 이름 만 사용하여 어디에서 어떤 이름이 사용되는지 강조합니다. &lt;code&gt;Index&lt;/code&gt; 및 &lt;code&gt;Mask&lt;/code&gt; 이름을 재사용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6e6249e0b2946138511bcb4a6acddccaf21d75a" translate="yes" xml:space="preserve">
          <source>The following interfaces are supported for the generic and specific AltiVec operations and the AltiVec predicates. In cases where there is a direct mapping between generic and specific operations, only the generic names are shown here, although the specific operations can also be used.</source>
          <target state="translated">일반 및 특정 AltiVec 조작 및 AltiVec 술어에 대해 다음 인터페이스가 지원됩니다. 일반 작업과 특정 작업간에 직접 매핑이있는 경우 특정 작업을 사용할 수도 있지만 여기에는 일반 이름 만 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="641482ab6aae43e810063e867385af29b325d058" translate="yes" xml:space="preserve">
          <source>The following is a complete list of all the SIMD built-ins provided for ARC, grouped by calling signature.</source>
          <target state="translated">다음은 서명을 호출하여 그룹화 한 ARC 용으로 제공되는 모든 SIMD 내장 목록입니다.</target>
        </trans-unit>
        <trans-unit id="59aaf754b53dd8275d60f36863885f1f7f538958" translate="yes" xml:space="preserve">
          <source>The following keywords are reserved for concepts.</source>
          <target state="translated">다음 키워드는 개념을 위해 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ea9055e3c282c50c68c6d2aeac0047e44355ae3" translate="yes" xml:space="preserve">
          <source>The following language-independent options do not enable specific warnings but control the kinds of diagnostics produced by GCC.</source>
          <target state="translated">다음 언어 독립적 옵션은 특정 경고를 활성화하지 않지만 GCC에서 생성 된 진단 종류를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="d9f20c0f07be1621f3a5ece2a524e2a15cb445a2" translate="yes" xml:space="preserve">
          <source>The following low level built-in functions are available with</source>
          <target state="translated">다음과 같은 저수준 내장 기능을 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="b73379da25dc8349b928d96eecb55babb0495892" translate="yes" xml:space="preserve">
          <source>The following machine modes are available for use with MMX built-in functions (see &lt;a href=&quot;vector-extensions#Vector-Extensions&quot;&gt;Vector Extensions&lt;/a&gt;): &lt;code&gt;V2SI&lt;/code&gt; for a vector of two 32-bit integers, &lt;code&gt;V4HI&lt;/code&gt; for a vector of four 16-bit integers, and &lt;code&gt;V8QI&lt;/code&gt; for a vector of eight 8-bit integers. Some of the built-in functions operate on MMX registers as a whole 64-bit entity, these use &lt;code&gt;V1DI&lt;/code&gt; as their mode.</source>
          <target state="translated">다음 기계 모드는 MMX와 함께 사용할 수 있습니다이 내장 함수 (참조 &lt;a href=&quot;vector-extensions#Vector-Extensions&quot;&gt;벡터 확장&lt;/a&gt; ) : &lt;code&gt;V2SI&lt;/code&gt; 을 두 개의 32 비트 정수의 벡터, &lt;code&gt;V4HI&lt;/code&gt; 네 16 비트 정수의 벡터 및 대한 &lt;code&gt;V8QI&lt;/code&gt; 여덟 (8)의 벡터 비트 정수 내장 함수 중 일부는 MMX 레지스터에서 전체 64 비트 엔터티로 작동하며 &lt;code&gt;V1DI&lt;/code&gt; 를 모드로 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="7cf3a8e89705f68be72e746786d162672425cfef" translate="yes" xml:space="preserve">
          <source>The following multi-instruction functions are also available. In each case, &lt;var&gt;cond&lt;/var&gt; can be any of the 16 floating-point conditions: &lt;code&gt;f&lt;/code&gt;, &lt;code&gt;un&lt;/code&gt;, &lt;code&gt;eq&lt;/code&gt;, &lt;code&gt;ueq&lt;/code&gt;, &lt;code&gt;olt&lt;/code&gt;, &lt;code&gt;ult&lt;/code&gt;, &lt;code&gt;ole&lt;/code&gt;, &lt;code&gt;ule&lt;/code&gt;, &lt;code&gt;sf&lt;/code&gt;, &lt;code&gt;ngle&lt;/code&gt;, &lt;code&gt;seq&lt;/code&gt;, &lt;code&gt;ngl&lt;/code&gt;, &lt;code&gt;lt&lt;/code&gt;, &lt;code&gt;nge&lt;/code&gt;, &lt;code&gt;le&lt;/code&gt; or &lt;code&gt;ngt&lt;/code&gt;.</source>
          <target state="translated">다음과 같은 다중 지시 기능도 사용할 수 있습니다. 각각의 경우에, &lt;var&gt;cond&lt;/var&gt; 16 : 부동 소수점 조건 중 하나가 될 수있는 &lt;code&gt;f&lt;/code&gt; , &lt;code&gt;un&lt;/code&gt; , &lt;code&gt;eq&lt;/code&gt; , &lt;code&gt;ueq&lt;/code&gt; , &lt;code&gt;olt&lt;/code&gt; , &lt;code&gt;ult&lt;/code&gt; , &lt;code&gt;ole&lt;/code&gt; , &lt;code&gt;ule&lt;/code&gt; , &lt;code&gt;sf&lt;/code&gt; , &lt;code&gt;ngle&lt;/code&gt; , &lt;code&gt;seq&lt;/code&gt; , &lt;code&gt;ngl&lt;/code&gt; , &lt;code&gt;lt&lt;/code&gt; , &lt;code&gt;nge&lt;/code&gt; , &lt;code&gt;le&lt;/code&gt; 또는 &lt;code&gt;ngt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d0ee4cac44eb1ea6ef3d346a27ca60807cc0101" translate="yes" xml:space="preserve">
          <source>The following option controls the dump verbosity:</source>
          <target state="translated">다음 옵션은 덤프 상세도를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="abb8267f4643a3a1e1226701a4af5aa70991f141" translate="yes" xml:space="preserve">
          <source>The following options are enabled:</source>
          <target state="translated">다음과 같은 옵션이 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="81ad9c293f6f20ff40e11231422dcfe5f5c7994f" translate="yes" xml:space="preserve">
          <source>The following options are maintained for backward compatibility, but are now deprecated and will be removed in a future release:</source>
          <target state="translated">다음 옵션은 이전 버전과의 호환성을 위해 유지되지만 더 이상 사용되지 않으며 향후 릴리스에서 제거 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="830e32827e2b8144f32b52b0121c8d7081e1b6a0" translate="yes" xml:space="preserve">
          <source>The following options are passed through to the assembler, and also define preprocessor macro symbols.</source>
          <target state="translated">다음 옵션은 어셈블러로 전달되며 전 처리기 매크로 기호도 정의합니다.</target>
        </trans-unit>
        <trans-unit id="3893bff29544ccfaa517cc2326f9ca49c8a38aa9" translate="yes" xml:space="preserve">
          <source>The following options are passed through to the linker:</source>
          <target state="translated">다음 옵션이 링커로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="3c36d7938f4b3037d603daaacf0e18dc02039404" translate="yes" xml:space="preserve">
          <source>The following options control compiler behavior regarding floating-point arithmetic. These options trade off between speed and correctness. All must be specifically enabled.</source>
          <target state="translated">다음 옵션은 부동 소수점 산술과 관련된 컴파일러 동작을 제어합니다. 이러한 옵션은 속도와 정확성간에 균형을 유지합니다. 모두 구체적으로 활성화해야합니다.</target>
        </trans-unit>
        <trans-unit id="86976c9ace4c113da10573eddefe715e4cb2f672" translate="yes" xml:space="preserve">
          <source>The following options control how the assembly code is annotated:</source>
          <target state="translated">다음 옵션은 어셈블리 코드에 주석이 달린 방법을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="14f279a10a5e010786a9e225f2aacc08d5d8248b" translate="yes" xml:space="preserve">
          <source>The following options control optimizations that may improve performance, but are not enabled by any</source>
          <target state="translated">다음 옵션은 성능을 향상시킬 수있는 최적화를 제어하지만</target>
        </trans-unit>
        <trans-unit id="55fd5087fff35ad2ed3317068955b447140094de" translate="yes" xml:space="preserve">
          <source>The following options control specific optimizations. They are either activated by</source>
          <target state="translated">다음 옵션은 특정 최적화를 제어합니다. 그들은에 의해 활성화</target>
        </trans-unit>
        <trans-unit id="97f1dd31a84415d7a8f21c8572a9ef06924b80bb" translate="yes" xml:space="preserve">
          <source>The following options control the analyzer.</source>
          <target state="translated">다음 옵션은 분석기를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="d75b9b815cb70c1acb6a0a4fa3f69dee634495bb" translate="yes" xml:space="preserve">
          <source>The following options control the architecture variant for which code is being compiled:</source>
          <target state="translated">다음 옵션은 코드가 컴파일되는 아키텍처 변형을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="99d7d28f2f9b185e45e491d2e2f8457796b4ee30" translate="yes" xml:space="preserve">
          <source>The following options control the dialect of C (or languages derived from C, such as C++, Objective-C and Objective-C++) that the compiler accepts:</source>
          <target state="translated">다음 옵션은 컴파일러에서 허용하는 C (또는 C에서 파생 된 언어 (예 : C ++, Objective-C 및 Objective-C ++))를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="813aeaa760a029b92e3d877fed33fc8e7a96dc7f" translate="yes" xml:space="preserve">
          <source>The following options control the semantics of generated code:</source>
          <target state="translated">다음 옵션은 생성 된 코드의 의미를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="d3598ddb012ba205521fc6ee02e575b5bc46a933" translate="yes" xml:space="preserve">
          <source>The following options control which kinds of messages should be emitted:</source>
          <target state="translated">다음 옵션은 어떤 종류의 메시지를 생성해야하는지 제어합니다.</target>
        </trans-unit>
        <trans-unit id="4d212367144c7ffb5256031004f3dbec4705f316" translate="yes" xml:space="preserve">
          <source>The following options fine tune code generation:</source>
          <target state="translated">다음 옵션은 코드 생성을 미세 조정합니다.</target>
        </trans-unit>
        <trans-unit id="e686313bb7d2bb5ed9fc2b2f596d5d6ba9508b34" translate="yes" xml:space="preserve">
          <source>The following paired-single functions map directly to a particular MIPS instruction. Please refer to the architecture specification for details on what each instruction does.</source>
          <target state="translated">다음의 한 쌍의 단일 기능은 특정 MIPS 명령에 직접 매핑됩니다. 각 명령어의 기능에 대한 자세한 내용은 아키텍처 사양을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d31f26e42333950d2b2ffa071557eac8358219f6" translate="yes" xml:space="preserve">
          <source>The following pragmas are available for all architectures running the Darwin operating system. These are useful for compatibility with other Mac OS compilers.</source>
          <target state="translated">Darwin 운영 체제를 실행하는 모든 아키텍처에 대해 다음 pragma를 사용할 수 있습니다. 다른 Mac OS 컴파일러와의 호환성에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="5efd4f1d1fe7f21c34100607d9ffdb85cb1ed570" translate="yes" xml:space="preserve">
          <source>The following set of built-in functions are available to gain access to the HTM specific special purpose registers.</source>
          <target state="translated">다음과 같은 내장 기능 세트를 사용하여 HTM 전용 특수 레지스터에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe37409b5b6fb37c45d0db10dbe34cd37d4dfd29" translate="yes" xml:space="preserve">
          <source>The following statements are identical:</source>
          <target state="translated">다음 내용은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="4c95f76a6048996b1dcedbb4002de26c05b62460" translate="yes" xml:space="preserve">
          <source>The following take a &lt;code&gt;__v8hi&lt;/code&gt; argument and three &lt;code&gt;int&lt;/code&gt; arguments and return no result. The second argument must be a 3-bit compile-time constant, identifying the 16-bit sub-register to be stored, the third argument must be a 3-bit compile time constants, indicating one the registers I0-I7, and the fourth argument must be an 8-bit compile time constant.</source>
          <target state="translated">다음은 &lt;code&gt;__v8hi&lt;/code&gt; 인수와 세 개의 &lt;code&gt;int&lt;/code&gt; 인수를 사용하여 결과를 반환하지 않습니다. 두 번째 인수는 저장 될 16 비트 하위 레지스터를 식별하는 3 비트 컴파일 타임 상수 여야하고, 세 번째 인수는 레지스터 I0-I7을 나타내는 3 비트 컴파일 시간 상수 여야합니다. 인수는 8 비트 컴파일 시간 상수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="5da4f813451b70864b4ac68a9c6bb25ff058833e" translate="yes" xml:space="preserve">
          <source>The following take a &lt;code&gt;__v8hi&lt;/code&gt; argument and two &lt;code&gt;int&lt;/code&gt; arguments and return a &lt;code&gt;__v8hi&lt;/code&gt; result. The second argument must be a 3-bit compile time constants, indicating one the registers I0-I7, and the third argument must be an 8-bit compile time constant.</source>
          <target state="translated">다음은 &lt;code&gt;__v8hi&lt;/code&gt; 인수와 두 개의 &lt;code&gt;int&lt;/code&gt; 인수를 사용하여 &lt;code&gt;__v8hi&lt;/code&gt; 결과를 반환합니다 . 두 번째 인수는 레지스터 I0-I7을 나타내는 3 비트 컴파일 시간 상수 여야하며 세 번째 인수는 8 비트 컴파일 시간 상수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="559f51894eceb199907d056ff4f4a6285c76d1d1" translate="yes" xml:space="preserve">
          <source>The following take a &lt;code&gt;__v8hi&lt;/code&gt; argument and two &lt;code&gt;int&lt;/code&gt; arguments and return no result. The second argument must be a 3-bit compile time constants, indicating one the registers I0-I7, and the third argument must be an 8-bit compile time constant.</source>
          <target state="translated">다음은 &lt;code&gt;__v8hi&lt;/code&gt; 인수와 두 개의 &lt;code&gt;int&lt;/code&gt; 인수를 사용하여 결과를 반환하지 않습니다. 두 번째 인수는 레지스터 I0-I7을 나타내는 3 비트 컴파일 시간 상수 여야하며 세 번째 인수는 8 비트 컴파일 시간 상수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="19babaec618194855f5c8b00e66e42a23a7c9b80" translate="yes" xml:space="preserve">
          <source>The following take a single &lt;code&gt;__v8hi&lt;/code&gt; argument and return a &lt;code&gt;__v8hi&lt;/code&gt; result:</source>
          <target state="translated">다음은 단일 &lt;code&gt;__v8hi&lt;/code&gt; 인수를 사용하여 &lt;code&gt;__v8hi&lt;/code&gt; 결과를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="24b4a9f9391a5e9fb5aa4cf91d4033a4a1ba3911" translate="yes" xml:space="preserve">
          <source>The following take an &lt;code&gt;int&lt;/code&gt; argument and return no result:</source>
          <target state="translated">다음은 &lt;code&gt;int&lt;/code&gt; 인수를 사용하여 결과를 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1708876febe0e46c893dfd70681ac1b1b3aa8762" translate="yes" xml:space="preserve">
          <source>The following take one &lt;code&gt;__v8hi&lt;/code&gt; and one &lt;code&gt;int&lt;/code&gt; argument and return a &lt;code&gt;__v8hi&lt;/code&gt; result:</source>
          <target state="translated">다음은 하나의 &lt;code&gt;__v8hi&lt;/code&gt; 와 하나의 &lt;code&gt;int&lt;/code&gt; 인수를 사용하여 &lt;code&gt;__v8hi&lt;/code&gt; 결과를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="3ad9bd81f972d4f83266bbddb59970dde24eddc0" translate="yes" xml:space="preserve">
          <source>The following take one &lt;code&gt;__v8hi&lt;/code&gt; argument and one &lt;code&gt;int&lt;/code&gt; argument which must be a 3-bit compile time constant indicating a register number I0-I7. They return a &lt;code&gt;__v8hi&lt;/code&gt; result.</source>
          <target state="translated">다음 은 레지스터 번호 I0-I7을 나타내는 3 비트 컴파일 시간 상수 여야하는 하나의 &lt;code&gt;__v8hi&lt;/code&gt; 인수와 하나의 &lt;code&gt;int&lt;/code&gt; 인수를 사용합니다. &lt;code&gt;__v8hi&lt;/code&gt; 결과를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="bc2a1ecceb07161357bd0a5bf4b1cca5ccc19add" translate="yes" xml:space="preserve">
          <source>The following take one &lt;code&gt;__v8hi&lt;/code&gt; argument and one &lt;code&gt;int&lt;/code&gt; argument which must be a 6-bit compile time constant. They return a &lt;code&gt;__v8hi&lt;/code&gt; result.</source>
          <target state="translated">다음 은 6 비트 컴파일 시간 상수 여야하는 하나의 &lt;code&gt;__v8hi&lt;/code&gt; 인수와 하나의 &lt;code&gt;int&lt;/code&gt; 인수를 사용합니다. &lt;code&gt;__v8hi&lt;/code&gt; 결과를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c720afe018ece35380697d65f42b49460f2c3700" translate="yes" xml:space="preserve">
          <source>The following take one &lt;code&gt;__v8hi&lt;/code&gt; argument and one &lt;code&gt;int&lt;/code&gt; argument which must be a 8-bit compile time constant. They return a &lt;code&gt;__v8hi&lt;/code&gt; result.</source>
          <target state="translated">다음은 하나의 &lt;code&gt;__v8hi&lt;/code&gt; 인수와 하나의 &lt;code&gt;int&lt;/code&gt; 인수를 가져야하며 8 비트 컴파일 시간 상수 여야합니다. &lt;code&gt;__v8hi&lt;/code&gt; 결과를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="0015b52d89388ff44035be55e55280be0b4aaeb6" translate="yes" xml:space="preserve">
          <source>The following take two &lt;code&gt;__v8hi&lt;/code&gt; arguments and return a &lt;code&gt;__v8hi&lt;/code&gt; result:</source>
          <target state="translated">다음은 두 개의 &lt;code&gt;__v8hi&lt;/code&gt; 인수를 사용하여 &lt;code&gt;__v8hi&lt;/code&gt; 결과를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="074063c3bbf2515afebb90aeb39ce860c2e31da4" translate="yes" xml:space="preserve">
          <source>The following take two &lt;code&gt;int&lt;/code&gt; arguments and return a &lt;code&gt;__v8hi&lt;/code&gt; result. The first argument must be a 3-bit compile time constants, indicating one the registers I0-I7, and the second argument must be an 8-bit compile time constant.</source>
          <target state="translated">다음은 두 개의 &lt;code&gt;int&lt;/code&gt; 인수를 사용하여 &lt;code&gt;__v8hi&lt;/code&gt; 결과를 반환합니다 . 첫 번째 인수는 레지스터 I0-I7을 나타내는 3 비트 컴파일 시간 상수 여야하고 두 번째 인수는 8 비트 컴파일 시간 상수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="e5b1b82914edb80d2ca00848561437d84a1f1eb2" translate="yes" xml:space="preserve">
          <source>The following take two &lt;code&gt;int&lt;/code&gt; arguments and return no result. The first argument must a 3-bit compile time constant indicating one of the DR0-DR7 DMA setup channels:</source>
          <target state="translated">다음은 두 개의 &lt;code&gt;int&lt;/code&gt; 인수를 사용하여 결과를 반환하지 않습니다. 첫 번째 인수는 DR0-DR7 DMA 설정 채널 중 하나를 나타내는 3 비트 컴파일 시간 상수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="14c057c170ec53d564774b373c4a36cf121034de" translate="yes" xml:space="preserve">
          <source>The following take two &lt;code&gt;int&lt;/code&gt; arguments and return no result:</source>
          <target state="translated">다음은 두 개의 &lt;code&gt;int&lt;/code&gt; 인수를 사용하고 결과를 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c73d90b3764a03700faea9b5a80499c3a3c6ee74" translate="yes" xml:space="preserve">
          <source>The following take two &lt;code&gt;int&lt;/code&gt; arguments, the second of which which must be a 8-bit compile time constant. They return a &lt;code&gt;__v8hi&lt;/code&gt; result:</source>
          <target state="translated">다음은 두 개의 &lt;code&gt;int&lt;/code&gt; 인수를 취하는데, 두 번째 인수는 8 비트 컴파일 시간 상수 여야합니다. &lt;code&gt;__v8hi&lt;/code&gt; 결과를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="7604a9689ceddf3a88ac390cfb640c35daa9929f" translate="yes" xml:space="preserve">
          <source>The following target-specific function attributes are available for the AArch64 target. For the most part, these options mirror the behavior of similar command-line options (see &lt;a href=&quot;aarch64-options#AArch64-Options&quot;&gt;AArch64 Options&lt;/a&gt;), but on a per-function basis.</source>
          <target state="translated">AArch64 대상에 대해 다음과 같은 대상별 기능 속성을 사용할 수 있습니다. 대부분의 경우 이러한 옵션은 유사한 명령 줄 옵션 ( &lt;a href=&quot;aarch64-options#AArch64-Options&quot;&gt;AArch64 옵션&lt;/a&gt; 참조 ) 의 동작을 기능별로 반영합니다.</target>
        </trans-unit>
        <trans-unit id="2a9dcb7afea2063b88c3f0d0bf8b210d678cf434" translate="yes" xml:space="preserve">
          <source>The following type attributes are supported on most targets.</source>
          <target state="translated">다음 유형 속성은 대부분의 대상에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="7ea3e81960cea1d06fa9fca33b75a29a1d4f2d4a" translate="yes" xml:space="preserve">
          <source>The following values of &lt;var&gt;insn&lt;/var&gt; are supported. Except as otherwise noted, floating-point operations are expected to be implemented with normal IEEE 754 semantics and correspond directly to the C operators or the equivalent GCC built-in functions (see &lt;a href=&quot;other-builtins#Other-Builtins&quot;&gt;Other Builtins&lt;/a&gt;).</source>
          <target state="translated">다음과 같은 &lt;var&gt;insn&lt;/var&gt; 값 이 지원됩니다. 달리 언급 된 경우를 제외하고, 부동 소수점 연산은 일반적인 IEEE 754 시맨틱으로 구현 될 것으로 예상되며 C 연산자 또는 동등한 GCC 내장 함수에 직접 대응됩니다 ( &lt;a href=&quot;other-builtins#Other-Builtins&quot;&gt;기타 내장&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="da10b4f1472639ab267cde98b6118ed2bb143912" translate="yes" xml:space="preserve">
          <source>The formats are checked against the format features supported by GNU libc version 2.2. These include all ISO C90 and C99 features, as well as features from the Single Unix Specification and some BSD and GNU extensions. Other library implementations may not support all these features; GCC does not support warning about features that go beyond a particular library&amp;rsquo;s limitations. However, if</source>
          <target state="translated">형식은 GNU libc 버전 2.2에서 지원하는 형식 기능과 비교하여 확인됩니다. 여기에는 모든 ISO C90 및 C99 기능과 단일 Unix 사양 및 일부 BSD 및 GNU 확장 기능이 포함됩니다. 다른 라이브러리 구현은 이러한 기능을 모두 지원하지 않을 수 있습니다. GCC는 특정 라이브러리 제한을 넘어서는 기능에 대한 경고를 지원하지 않습니다. 그러나</target>
        </trans-unit>
        <trans-unit id="3fd329b7b6e510f8c7f38ab04501976f2c6f4c71" translate="yes" xml:space="preserve">
          <source>The forwarding method implementation thus created is returned by &lt;code&gt;objc_msg_lookup()&lt;/code&gt; and is executed as if it was a normal method implementation. When the forwarding method implementation is called, it is usually expected to pack all arguments into some sort of object (typically, an &lt;code&gt;NSInvocation&lt;/code&gt; in a &amp;ldquo;Foundation&amp;rdquo; library), and hand it over to the programmer (&lt;code&gt;forwardInvocation:&lt;/code&gt;) who is then allowed to manipulate the method invocation using a high-level API provided by the &amp;ldquo;Foundation&amp;rdquo; library. For example, the programmer may want to examine the method invocation arguments and name and potentially change them before forwarding the method invocation to one or more local objects (&lt;code&gt;performInvocation:&lt;/code&gt;) or even to remote objects (by using Distributed Objects or some other mechanism). When all this completes, the return value is passed back and must be returned correctly to the original caller.</source>
          <target state="translated">이렇게 생성 된 포워딩 메소드 구현은 &lt;code&gt;objc_msg_lookup()&lt;/code&gt; 의해 반환되며 마치 일반적인 메소드 구현 인 것처럼 실행됩니다. 전달 메소드 구현이 호출되면 일반적으로 모든 인수를 일종의 오브젝트 (일반적으로 &quot;파운데이션&quot;라이브러리 의 &lt;code&gt;NSInvocation&lt;/code&gt; )로 &lt;code&gt;forwardInvocation:&lt;/code&gt; 후 프로그래머 ( forwardInvocation :) 에게 전달해야합니다. &quot;Foundation&quot;라이브러리에서 제공하는 고급 API를 사용하여 메소드 호출을 조작하십시오. 예를 들어, 프로그래머는 메소드 호출 인수 및 이름을 검사하여 메소드 호출을 하나 이상의 로컬 오브젝트 ( &lt;code&gt;performInvocation:&lt;/code&gt; ) 또는 심지어 원격 객체 (분산 객체 또는 다른 메커니즘을 사용) 이 모든 것이 완료되면 반환 값이 다시 전달되고 원래 호출자에게 올바르게 반환되어야합니다.</target>
        </trans-unit>
        <trans-unit id="370cce3123cd6103545b49952aa7ecfe80d28686" translate="yes" xml:space="preserve">
          <source>The four non-arithmetic functions (load, store, exchange, and compare_exchange) all have a generic version as well. This generic version works on any data type. It uses the lock-free built-in function if the specific data type size makes that possible; otherwise, an external call is left to be resolved at run time. This external call is the same format with the addition of a &amp;lsquo;</source>
          <target state="translated">4 개의 비 산술 함수 (load, store, exchange 및 compare_exchange)도 모두 일반 버전입니다. 이 일반 버전은 모든 데이터 유형에서 작동합니다. 특정 데이터 유형 크기로 가능하면 잠금없는 내장 기능을 사용합니다. 그렇지 않으면 런타임시 외부 통화가 해결됩니다. 이 외부 통화는 '</target>
        </trans-unit>
        <trans-unit id="bc7082dbfb46d172471e10794421761522292732" translate="yes" xml:space="preserve">
          <source>The frame is the area on the stack that holds local variables and saved registers. The frame address is normally the address of the first word pushed on to the stack by the function. However, the exact definition depends upon the processor and the calling convention. If the processor has a dedicated frame pointer register, and the function has a frame, then &lt;code&gt;__builtin_frame_address&lt;/code&gt; returns the value of the frame pointer register.</source>
          <target state="translated">프레임은 로컬 변수와 저장된 레지스터를 보유하는 스택의 영역입니다. 프레임 주소는 일반적으로 함수에 의해 스택에 푸시 된 첫 번째 단어의 주소입니다. 그러나 정확한 정의는 프로세서와 호출 규칙에 따라 다릅니다. 프로세서에 전용 프레임 포인터 레지스터가 있고 함수에 프레임 이 있으면 &lt;code&gt;__builtin_frame_address&lt;/code&gt; 는 프레임 포인터 레지스터의 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="91be25b4a97f2d4dcdca61df07841207c68074ea" translate="yes" xml:space="preserve">
          <source>The front end also exposes a number of internal mechanism that can be used to simplify the writing of type traits. Note that some of these traits are likely to be removed in the future.</source>
          <target state="translated">프론트 엔드는 또한 유형 특성의 작성을 단순화하는 데 사용할 수있는 많은 내부 메커니즘을 제공합니다. 이러한 특성 중 일부는 나중에 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0002fd6e851a03368550f6c8393985028e5a22a9" translate="yes" xml:space="preserve">
          <source>The function may cause execution to pause until it is known that the code is no-longer being executed speculatively (in which case &lt;var&gt;val&lt;/var&gt; can be returned, as above); or</source>
          <target state="translated">이 함수는 코드가 더 이상 추론 적으로 실행되지 않는다는 것을 알 때까지 실행을 일시 중지시킬 수 있습니다 (이 경우 &lt;var&gt;val&lt;/var&gt; 은 위와 같이 반환 될 수 있음). 또는</target>
        </trans-unit>
        <trans-unit id="c285a5c6cfe9015607ff4a0e2ac733ad987d0e25" translate="yes" xml:space="preserve">
          <source>The function may use target-dependent speculation tracking state to cause &lt;var&gt;failval&lt;/var&gt; to be returned when it is known that speculative execution has incorrectly predicted a conditional branch operation.</source>
          <target state="translated">이 함수는 목표 종속 추론 추적 상태를 사용하여 추론 적 실행이 조건부 분기 연산을 잘못 예측 한 경우 &lt;var&gt;failval&lt;/var&gt; 가 반환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1910cbf4d249572210143c348f1416c66e710621" translate="yes" xml:space="preserve">
          <source>The function parameter denoting the allocated alignment is specified by one constant integer argument whose number is the argument of the attribute. Argument numbering starts at one.</source>
          <target state="translated">할당 된 정렬을 나타내는 함수 매개 변수는 숫자가 속성의 인수 인 하나의 상수 정수 인수로 지정됩니다. 인수 번호 매기기는 하나에서 시작합니다.</target>
        </trans-unit>
        <trans-unit id="3b052040572f76188271e0e3e0c80c35be66f2c8" translate="yes" xml:space="preserve">
          <source>The function parameter(s) denoting the allocated size are specified by one or two integer arguments supplied to the attribute. The allocated size is either the value of the single function argument specified or the product of the two function arguments specified. Argument numbering starts at one for ordinary functions, and at two for C++ non-static member functions.</source>
          <target state="translated">할당 된 크기를 나타내는 함수 매개 변수는 속성에 제공된 하나 또는 두 개의 정수 인수로 지정됩니다. 할당 된 크기는 지정된 단일 함수 인수의 값이거나 지정된 두 함수 인수의 곱입니다. 인수 번호 매기기는 일반 함수의 경우 한 개에서 시작하고 C ++ 비 정적 멤버 함수의 경우 두 개에서 시작합니다.</target>
        </trans-unit>
        <trans-unit id="0ca979696b9a2800aa34523d4083bf5a14d799aa" translate="yes" xml:space="preserve">
          <source>The function saves the arg pointer register, structure value address, and all registers that might be used to pass arguments to a function into a block of memory allocated on the stack. Then it returns the address of that block.</source>
          <target state="translated">이 함수는 인수 포인터 레지스터, 구조 값 주소 및 함수에 인수를 전달하는 데 사용될 수있는 모든 레지스터를 스택에 할당 된 메모리 블록에 저장합니다. 그런 다음 해당 블록의 주소를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6872e4d72d8fbbd9743faadfaad51d5d8e08d8dc" translate="yes" xml:space="preserve">
          <source>The functions listed below map directly to FR-V I-type instructions.</source>
          <target state="translated">아래에 나열된 기능은 FR-V I- 타입 명령어에 직접 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="c602f6bdf5c7225fe620c26f84e8de50c7071a07" translate="yes" xml:space="preserve">
          <source>The functions listed below map directly to FR-V M-type instructions.</source>
          <target state="translated">아래에 나열된 기능은 FR-V M 유형 명령어에 직접 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="d757b37f17b7bb17dc67a24428e9f56b268f5c5e" translate="yes" xml:space="preserve">
          <source>The functions listed below map directly to a particular MIPS-3D instruction. Please refer to the architecture specification for more details on what each instruction does.</source>
          <target state="translated">아래 나열된 기능은 특정 MIPS-3D 명령어에 직접 매핑됩니다. 각 명령어의 기능에 대한 자세한 내용은 아키텍처 사양을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="636b8102a37675bf78355f0f6bba2ff462438334" translate="yes" xml:space="preserve">
          <source>The functions supported are:</source>
          <target state="translated">지원되는 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ad7023ac286f3db88bfb11b7cae18fc097b31af2" translate="yes" xml:space="preserve">
          <source>The half-precision floating-point data processing instructions. This also enables the Advanced SIMD and floating-point instructions as well as the Dot Product extension and the half-precision floating-point fmla extension.</source>
          <target state="translated">반 정밀도 부동 소수점 데이터 처리 명령어. 또한 고급 SIMD 및 부동 소수점 명령어와 Dot Product 확장 및 반 정밀도 부동 소수점 fmla 확장이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="58f4f715483c2871dde2ce2ca0d2db8aca84c869" translate="yes" xml:space="preserve">
          <source>The half-precision floating-point data processing instructions. This also enables the Advanced SIMD and floating-point instructions.</source>
          <target state="translated">반 정밀도 부동 소수점 데이터 처리 명령어. 또한 고급 SIMD 및 부동 소수점 명령어도 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="11520bb64917989439d0bd1e50b448954652e968" translate="yes" xml:space="preserve">
          <source>The half-precision floating-point fmla extension. This also enables the half-precision floating-point extension and Advanced SIMD and floating-point instructions.</source>
          <target state="translated">반 정밀도 부동 소수점 fmla 확장입니다. 또한 반 정밀도 부동 소수점 확장과 고급 SIMD 및 부동 소수점 명령어를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddd47b9fa117c203d0b4afbba7a0a4bc59d68406" translate="yes" xml:space="preserve">
          <source>The hardware multiply routines disable interrupts whilst running and restore the previous interrupt state when they finish. This makes them safe to use inside interrupt handlers as well as in normal code.</source>
          <target state="translated">하드웨어 곱하기 루틴은 실행 중 인터럽트를 비활성화하고 이전 인터럽트 상태가 완료되면 복원합니다. 이를 통해 인터럽트 핸들러 내부와 일반 코드에서 안전하게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1700f28ed95fcc91e5f3613066db6eabb50e9b1f" translate="yes" xml:space="preserve">
          <source>The header files contain detailed documentation for each function in the GNU Objective-C runtime API.</source>
          <target state="translated">헤더 파일에는 GNU Objective-C 런타임 API의 각 기능에 대한 자세한 설명서가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="bef3ae0649be61ff8ea14c16eb476e462ede9be4" translate="yes" xml:space="preserve">
          <source>The high part (bits 12 and upwards) of the pc-relative address of a symbol within 4GB of the instruction</source>
          <target state="translated">명령어의 4GB 내에있는 심볼의 pc 기준 주소의 상위 부분 (비트 12 이상)</target>
        </trans-unit>
        <trans-unit id="ea0d4a97e0e09b3d462961a102c172f60bf94df3" translate="yes" xml:space="preserve">
          <source>The iWMMX GR registers.</source>
          <target state="translated">iWMMX GR 레지스터.</target>
        </trans-unit>
        <trans-unit id="2ad23a41b556be75b4554217ab7b7da89d6570d2" translate="yes" xml:space="preserve">
          <source>The iWMMX co-processor registers.</source>
          <target state="translated">iWMMX 보조 프로세서 레지스터.</target>
        </trans-unit>
        <trans-unit id="b46a70e92f765a7f4dbecade6890d0ae606db8e1" translate="yes" xml:space="preserve">
          <source>The idea behind this is that sometimes it is convenient (for the programmer) to consider floating-point values as approximations to infinitely precise real numbers. If you are doing this, then you need to compute (by analyzing the code, or in some other way) the maximum or likely maximum error that the computation introduces, and allow for it when performing comparisons (and when producing output, but that&amp;rsquo;s a different problem). In particular, instead of testing for equality, you should check to see whether the two values have ranges that overlap; and this is done with the relational operators, so equality comparisons are probably mistaken.</source>
          <target state="translated">이 뒤에 숨겨진 아이디어는 때때로 (프로그래머에게) 부동 소수점 값을 무한정의 실수에 대한 근사치로 간주하는 것이 편리하다는 것입니다. 이 작업을 수행하는 경우 계산에서 발생하는 최대 또는 가능한 최대 오류를 계산하여 코드를 분석하거나 다른 방법으로 계산해야하며 비교를 수행 할 때 (및 출력을 생성 할 때) 허용해야합니다. 다른 문제). 특히, 동등성을 테스트하는 대신 두 값의 범위가 겹치는 지 확인해야합니다. 그리고 이것은 관계 연산자로 이루어 지므로 평등 비교는 아마도 잘못된 것입니다.</target>
        </trans-unit>
        <trans-unit id="c0a98af2de248cc10c278826d9411559e39eee26" translate="yes" xml:space="preserve">
          <source>The identifier &lt;code&gt;__func__&lt;/code&gt; is implicitly declared by the translator as if, immediately following the opening brace of each function definition, the declaration</source>
          <target state="translated">&lt;code&gt;__func__&lt;/code&gt; 식별자 는 마치 각 함수 정의의 여는 중괄호 바로 다음에 선언처럼 마치 번역자에 의해 암시 적으로 선언됩니다.</target>
        </trans-unit>
        <trans-unit id="13fbfb86cc636b25b4f8dbf9788be6becd2407c7" translate="yes" xml:space="preserve">
          <source>The immediate value 0x01.</source>
          <target state="translated">즉시 값 0x01.</target>
        </trans-unit>
        <trans-unit id="52de78dd0ef761fa638ed2df23930f5359ca4c01" translate="yes" xml:space="preserve">
          <source>The immediate value 0x7ff.</source>
          <target state="translated">즉각적인 값 0x7ff.</target>
        </trans-unit>
        <trans-unit id="178295c2520a8328225a3e14f6430b205aa477b7" translate="yes" xml:space="preserve">
          <source>The immediate value 0xff.</source>
          <target state="translated">즉각적인 값 0xff.</target>
        </trans-unit>
        <trans-unit id="ba38c21b26ea7ac3618ca4682f483633c0168822" translate="yes" xml:space="preserve">
          <source>The immediate value 0xffff.</source>
          <target state="translated">즉각적인 값 0xffff.</target>
        </trans-unit>
        <trans-unit id="f3edc2d2bcd9f411eb9c02f201cf5906b594ce1b" translate="yes" xml:space="preserve">
          <source>The immediate value that can be simply set high 20-bit.</source>
          <target state="translated">단순히 높은 20 비트로 설정할 수있는 즉각적인 값.</target>
        </trans-unit>
        <trans-unit id="f3b3ce3b975ce4bb65c0a8ad20428b556134b6e5" translate="yes" xml:space="preserve">
          <source>The immediate value with power of 2 minus 1.</source>
          <target state="translated">2 빼기 1의 제곱을 가진 즉각적인 값.</target>
        </trans-unit>
        <trans-unit id="cdad57dc1c93e8c86249089910e5d64e47612ed8" translate="yes" xml:space="preserve">
          <source>The immediate value with power of 2.</source>
          <target state="translated">2의 거듭 제곱을 사용한 즉각적인 가치.</target>
        </trans-unit>
        <trans-unit id="292bc2fc3bad9eb92ff6853193b506ffc6d78c40" translate="yes" xml:space="preserve">
          <source>The impacted functions are determined by the compiler&amp;rsquo;s interprocedural optimizations. For example, a caller is impacted when inlining a function into its caller, cloning a function and changing its caller to call this new clone, or extracting a function&amp;rsquo;s pureness/constness information to optimize its direct or indirect callers, etc.</source>
          <target state="translated">영향을받는 함수는 컴파일러의 절차 간 최적화에 의해 결정됩니다. 예를 들어, 호출자는 호출자에게 함수를 인라인하거나, 함수를 복제하고 호출자를 변경하여이 새 복제본을 호출하거나, 함수의 순도 / 고정도 정보를 추출하여 직접 또는 간접 호출자 등을 최적화 할 때 영향을받습니다.</target>
        </trans-unit>
        <trans-unit id="788e9c101326291dabb53f85af22d398e9b836ec" translate="yes" xml:space="preserve">
          <source>The implementation of messaging in the GNU Objective-C runtime is designed to be portable, and so is based on standard C.</source>
          <target state="translated">GNU Objective-C 런타임에서 메시징 구현은 이식 가능하도록 설계되었으며 표준 C를 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="4de99bcf5ddd6a719a8ac7733daede651bd9f548" translate="yes" xml:space="preserve">
          <source>The important thing to keep in mind is that to enable link-time optimizations you need to use the GCC driver to perform the link step. GCC automatically performs link-time optimization if any of the objects involved were compiled with the</source>
          <target state="translated">명심해야 할 것은 링크 타임 최적화를 가능하게하려면 GCC 드라이버를 사용하여 링크 단계를 수행해야한다는 것입니다. GCC는 관련 개체 중 하나를 사용하여 컴파일 된 경우 링크 타임 최적화를 자동으로 수행합니다.</target>
        </trans-unit>
        <trans-unit id="9a2b4fb08fe8eee4956db02cb6f8d3c3fb54b6e4" translate="yes" xml:space="preserve">
          <source>The index values must be constant expressions, even if the array being initialized is automatic.</source>
          <target state="translated">초기화되는 배열이 자동 인 경우에도 색인 값은 상수 표현식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="20238db563baf6821f8bed87f8777e30be3fd316" translate="yes" xml:space="preserve">
          <source>The induction variable optimizations give up on loops that contain more induction variable uses.</source>
          <target state="translated">유도 변수 최적화는 더 많은 유도 변수 사용을 포함하는 루프를 포기합니다.</target>
        </trans-unit>
        <trans-unit id="99b9ae56dc4f69f455cd2846f1efc86548a4f0b0" translate="yes" xml:space="preserve">
          <source>The instructions generated by the following builtins are not considered as candidates for scheduling. They are not moved around by the compiler during scheduling, and thus can be expected to appear where they are put in the C code:</source>
          <target state="translated">다음 내장에서 생성 된 명령어는 예약 후보로 간주되지 않습니다. 스케줄링하는 동안 컴파일러에 의해 이동되지 않으므로 C 코드에 넣은 곳에 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0143a1fa40596d46b920e516a49bccafb05c6756" translate="yes" xml:space="preserve">
          <source>The integer constant -1.</source>
          <target state="translated">정수 상수 -1.</target>
        </trans-unit>
        <trans-unit id="0304e4a19fa9d570fa64154ef073c85be9e9d234" translate="yes" xml:space="preserve">
          <source>The integer constant -2.</source>
          <target state="translated">정수 상수 -2.</target>
        </trans-unit>
        <trans-unit id="20219359f9654d4bb60ad841282922f1407f31ff" translate="yes" xml:space="preserve">
          <source>The integer constant 0.</source>
          <target state="translated">정수 상수 0.</target>
        </trans-unit>
        <trans-unit id="84b9a3c5e77c93a53f2664cad25c5af25a563160" translate="yes" xml:space="preserve">
          <source>The integer constant 0xffffffff.</source>
          <target state="translated">정수 상수 0xffffffff.</target>
        </trans-unit>
        <trans-unit id="0900ba8234ff692dd368ac2562960d9c24b87490" translate="yes" xml:space="preserve">
          <source>The integer constant 0xffffffff00000000.</source>
          <target state="translated">정수 상수 0xffffffff00000000.</target>
        </trans-unit>
        <trans-unit id="1704120ef6a8406a0d73d119b3bae3d2fd6db0c7" translate="yes" xml:space="preserve">
          <source>The integer constant 1.</source>
          <target state="translated">정수 상수 1</target>
        </trans-unit>
        <trans-unit id="f7733e70947e25f6ba4f15b855fbc6bb56230e77" translate="yes" xml:space="preserve">
          <source>The integer constant 2.</source>
          <target state="translated">정수 상수 2.</target>
        </trans-unit>
        <trans-unit id="2e4afdbd5f6f64969b9a9086ed5845106d1e1df4" translate="yes" xml:space="preserve">
          <source>The integer type compatible with each enumerated type (C90 6.5.2.2, C99 and C11 6.7.2.2).</source>
          <target state="translated">열거 된 각 유형 (C90 6.5.2.2, C99 및 C11 6.7.2.2)과 호환되는 정수 유형입니다.</target>
        </trans-unit>
        <trans-unit id="d4f4c82404325b1bedf2b678bda8824c1372dc16" translate="yes" xml:space="preserve">
          <source>The integer zero constant.</source>
          <target state="translated">정수 영 상수.</target>
        </trans-unit>
        <trans-unit id="7f5eb05da6eb2941255dd1f24db7755004fe0fb6" translate="yes" xml:space="preserve">
          <source>The intended use can be e.g.</source>
          <target state="translated">의도 된 용도는 예를 들어</target>
        </trans-unit>
        <trans-unit id="eec03e559122067c46321a3d23e2fe242aaa628b" translate="yes" xml:space="preserve">
          <source>The intrinsic &lt;code&gt;void __tile_network_barrier (void)&lt;/code&gt; is used to guarantee that no network operations before it are reordered with those after it.</source>
          <target state="translated">본질적인 &lt;code&gt;void __tile_network_barrier (void)&lt;/code&gt; 는 네트워크 조작이 그 이전의 순서와 재순환 되지 않도록 보장하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2b326f68cedc113119b7cfc329617004f7ca5d0f" translate="yes" xml:space="preserve">
          <source>The intrinsics provided are listed below; each is named after the machine instruction to which it corresponds, with suffixes added as appropriate to distinguish intrinsics that expand to the same machine instruction yet have different argument types. Refer to the architecture documentation for a description of the functionality of each instruction.</source>
          <target state="translated">제공되는 내장 기능은 다음과 같습니다. 각각은 해당 기계 명령어의 이름을 따서 명명되며, 동일한 기계 명령어로 확장하지만 다른 인수 유형을 갖는 내장 함수를 구별하기 위해 적절한 접미사가 추가됩니다. 각 명령어의 기능에 대한 설명은 아키텍처 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3a0e26ddf5eff18eeea3fbd0b9d1cb136b8b4213" translate="yes" xml:space="preserve">
          <source>The intrinsics provided are listed below; each is named after the machine instruction.</source>
          <target state="translated">제공되는 내장 기능은 다음과 같습니다. 각각은 기계 명령의 이름을 따서 명명됩니다.</target>
        </trans-unit>
        <trans-unit id="3eef6d5321de2f795448068015c7c54f1ed1296f" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;@compatibility_alias&lt;/code&gt; allows you to define a class name as equivalent to another class name. For example:</source>
          <target state="translated">키워드 &lt;code&gt;@compatibility_alias&lt;/code&gt; 를 사용하면 클래스 이름을 다른 클래스 이름과 동등한 것으로 정의 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dae34f2a2b2a52f07242474e58c01e8458c373a3" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;__alignof__&lt;/code&gt; determines the alignment requirement of a function, object, or a type, or the minimum alignment usually required by a type. Its syntax is just like &lt;code&gt;sizeof&lt;/code&gt; and C11 &lt;code&gt;_Alignof&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;__alignof__&lt;/code&gt; 키워드 는 함수, 객체 또는 유형의 정렬 요구 사항 또는 일반적으로 유형에 필요한 최소 정렬을 결정합니다. 구문은 &lt;code&gt;sizeof&lt;/code&gt; 및 C11 &lt;code&gt;_Alignof&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="0e11754fcd951a085d6544dab003aaba8cd78a6c" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;__attribute__&lt;/code&gt; allows you to specify special properties of variables, function parameters, or structure, union, and, in C++, class members. This &lt;code&gt;__attribute__&lt;/code&gt; keyword is followed by an attribute specification enclosed in double parentheses. Some attributes are currently defined generically for variables. Other attributes are defined for variables on particular target systems. Other attributes are available for functions (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;), labels (see &lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;Label Attributes&lt;/a&gt;), enumerators (see &lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;Enumerator Attributes&lt;/a&gt;), statements (see &lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;Statement Attributes&lt;/a&gt;), and for types (see &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Type Attributes&lt;/a&gt;). Other front ends might define more attributes (see &lt;a href=&quot;c_002b_002b-extensions#C_002b_002b-Extensions&quot;&gt;Extensions to the C++ Language&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;__attribute__&lt;/code&gt; 키워드를 사용하면 변수, 함수 매개 변수 또는 구조, 공용체 및 C ++에서 클래스 멤버의 특수 속성을 지정할 수 있습니다. 이 &lt;code&gt;__attribute__&lt;/code&gt; 키워드 뒤에는 괄호로 묶인 속성 스펙이옵니다. 일부 속성은 현재 변수에 대해 일반적으로 정의되어 있습니다. 다른 대상 속성은 특정 대상 시스템의 변수에 대해 정의됩니다. 함수 ( &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;함수 속성&lt;/a&gt; 참조 ), 레이블 ( &lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;레이블 속성&lt;/a&gt; 참조 ), 열거 자 ( &lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;열거 속성&lt;/a&gt; 참조 ), 명령문 ( &lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;문 속성&lt;/a&gt; 참조 ) 및 유형 ( &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;유형 속성&lt;/a&gt; 참조)에 대해 다른 속성을 사용할 수 있습니다 . 다른 프런트 엔드는 더 많은 속성을 정의 할 수 있습니다 (참조&lt;a href=&quot;c_002b_002b-extensions#C_002b_002b-Extensions&quot;&gt;C ++ 언어 확장&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="a4cf059503889f054506ae99e86330f0d94efc6c" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;__attribute__&lt;/code&gt; allows you to specify various special properties of types. Some type attributes apply only to structure and union types, and in C++, also class types, while others can apply to any type defined via a &lt;code&gt;typedef&lt;/code&gt; declaration. Unless otherwise specified, the same restrictions and effects apply to attributes regardless of whether a type is a trivial structure or a C++ class with user-defined constructors, destructors, or a copy assignment.</source>
          <target state="translated">&lt;code&gt;__attribute__&lt;/code&gt; 키워드를 사용하면 다양한 유형의 특수 속성을 지정할 수 있습니다. 일부 유형 속성은 구조 및 공용체 유형에만 적용되고 C ++에서는 클래스 유형에도 적용되며 다른 유형 속성은 &lt;code&gt;typedef&lt;/code&gt; 선언을 통해 정의 된 모든 유형에 적용 할 수 있습니다 . 달리 지정하지 않는 한 유형이 사소한 구조인지 또는 사용자 정의 생성자, 소멸자 또는 사본 할당이있는 C ++ 클래스인지에 관계없이 동일한 제한 및 효과가 속성에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="1572dc96be7f5e014878efc69fdfd49b0ae87eea" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;__thread&lt;/code&gt; applied to a non-local object gives the object thread storage duration.</source>
          <target state="translated">로컬이 아닌 객체에 적용된 &lt;code&gt;__thread&lt;/code&gt; 키워드 는 객체 스레드 저장 기간을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="39b19603ff8ee793099ac42a05990562491ebaf2" translate="yes" xml:space="preserve">
          <source>The label declaration defines the label &lt;em&gt;name&lt;/em&gt;, but does not define the label itself. You must do this in the usual way, with &lt;code&gt;&lt;var&gt;label&lt;/var&gt;:&lt;/code&gt;, within the statements of the statement expression.</source>
          <target state="translated">레이블 선언은 레이블 &lt;em&gt;이름을&lt;/em&gt; 정의하지만 레이블 자체는 정의하지 않습니다. 명령문 표현식의 명령문 내에서 &lt;code&gt;&lt;var&gt;label&lt;/var&gt;:&lt;/code&gt; 을 사용하여 일반적인 방식으로이를 수행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="428f4e4c9e8e6a37b249e009bb97c82a44c2fb8f" translate="yes" xml:space="preserve">
          <source>The language-independent component of GCC includes the majority of the optimizers, as well as the &amp;ldquo;back ends&amp;rdquo; that generate machine code for various processors.</source>
          <target state="translated">GCC의 언어 독립적 구성 요소에는 대부분의 옵티 마이저와 다양한 프로세서에 대한 기계 코드를 생성하는 &quot;백엔드&quot;가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="005fac6b181ca927cb2a738c000f5da953afe1b7" translate="yes" xml:space="preserve">
          <source>The last thing in the compound statement should be an expression followed by a semicolon; the value of this subexpression serves as the value of the entire construct. (If you use some other kind of statement last within the braces, the construct has type &lt;code&gt;void&lt;/code&gt;, and thus effectively no value.)</source>
          <target state="translated">복합 명령문의 마지막 것은 세미콜론 뒤에 오는 표현식이어야합니다. 이 하위 표현식의 값은 전체 구문의 값으로 사용됩니다. (중괄호 내에서 마지막으로 다른 종류의 명령문을 사용하면 구문의 유형이 &lt;code&gt;void&lt;/code&gt; 이므로 사실상 값이 없습니다.)</target>
        </trans-unit>
        <trans-unit id="206e1d46d7d3ee120b67ca48c1a3f104346b70ef" translate="yes" xml:space="preserve">
          <source>The length of an array is computed once when the storage is allocated and is remembered for the scope of the array in case you access it with &lt;code&gt;sizeof&lt;/code&gt;.</source>
          <target state="translated">스토리지의 길이는 스토리지가 할당 될 때 한 번 계산되며 &lt;code&gt;sizeof&lt;/code&gt; 로 액세스 할 경우 스토리지 범위에 대해 기억됩니다 .</target>
        </trans-unit>
        <trans-unit id="ce058b55eed72e669ebdbd6e3aba9093499b97c5" translate="yes" xml:space="preserve">
          <source>The letters represent the following data types:</source>
          <target state="translated">문자는 다음 데이터 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="77263b459d57cfcd71f0acd14e32e54e7be714c9" translate="yes" xml:space="preserve">
          <source>The lifetime of a compiler generated temporary is well defined by the C++ standard. When a lifetime of a temporary ends, and if the temporary lives in memory, the optimizing compiler has the freedom to reuse its stack space with other temporaries or scoped local variables whose live range does not overlap with it. However some of the legacy code relies on the behavior of older compilers in which temporaries&amp;rsquo; stack space is not reused, the aggressive stack reuse can lead to runtime errors. This option is used to control the temporary stack reuse optimization.</source>
          <target state="translated">컴파일러에서 임시로 생성 한 수명은 C ++ 표준에 의해 잘 정의됩니다. 임시 수명이 끝나고 메모리에 임시 수명이있는 경우 최적화 컴파일러는 스택 범위가 다른 임시 또는 범위 변수와 겹치지 않는 범위가 지정된 로컬 변수와 함께 자유롭게 다시 사용할 수 있습니다. 그러나 일부 레거시 코드는 임시 스택 공간을 재사용하지 않는 구형 컴파일러의 동작에 의존하므로 공격적인 스택 재사용으로 인해 런타임 오류가 발생할 수 있습니다. 이 옵션은 임시 스택 재사용 최적화를 제어하는 ​​데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="499ee472bf57c8d5ea52c4b866109362dfcc7841" translate="yes" xml:space="preserve">
          <source>The limit applies &lt;em&gt;after&lt;/em&gt; string constant concatenation, and does not count the trailing NUL. In C90, the limit was 509 characters; in C99, it was raised to 4095. C++98 does not specify a normative minimum maximum, so we do not diagnose overlength strings in C++.</source>
          <target state="translated">문자열 상수 연결 &lt;em&gt;후&lt;/em&gt; 한계가 적용되며 후미 NUL은 계산하지 않습니다. C90에서 한도는 509 자입니다. C99에서는 4095로 올렸습니다. C ++ 98은 표준 최소 최대 값을 지정하지 않으므로 C ++에서 길이가 긴 문자열을 진단하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e6c688d4fc373af85820537cf244755f93f3571e" translate="yes" xml:space="preserve">
          <source>The limit specifying large stack frames. While inlining the algorithm is trying to not grow past this limit too much.</source>
          <target state="translated">큰 스택 프레임을 지정하는 한계입니다. 알고리즘을 인라인하는 동안이 한계를 초과하여 성장하지 않으려 고합니다.</target>
        </trans-unit>
        <trans-unit id="85f90ab304447934cd7fe1bd66dac4bb5697c076" translate="yes" xml:space="preserve">
          <source>The limit specifying large translation unit. Growth caused by inlining of units larger than this limit is limited by</source>
          <target state="translated">큰 번역 단위를 지정하는 한도입니다. 이 한계보다 큰 단위의 인라인으로 인한 성장은</target>
        </trans-unit>
        <trans-unit id="24d66aaeb77b8d51a696a30383b9a88d8d0ffec4" translate="yes" xml:space="preserve">
          <source>The limit specifying really large functions. For functions larger than this limit after inlining, inlining is constrained by</source>
          <target state="translated">실제로 큰 기능을 지정하는 한계입니다. 인라인 후이 한계보다 큰 함수의 경우 인라인은 다음과 같이 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="c3e28be9ccc81004da7fffd01a2901be4871fc54" translate="yes" xml:space="preserve">
          <source>The link register, &lt;code&gt;lr&lt;/code&gt;.</source>
          <target state="translated">링크 레지스터, &lt;code&gt;lr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26f2bb016c8b0766650946224b7ac36870093175" translate="yes" xml:space="preserve">
          <source>The linker searches a standard list of directories for the library. The directories searched include several standard system directories plus any that you specify with</source>
          <target state="translated">링커는 라이브러리의 표준 디렉토리 목록을 검색합니다. 검색된 디렉토리에는 여러 표준 시스템 디렉토리와 함께 지정한 디렉토리가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="78e4e4eb1e36ecbe1ce8c7bd81da2158dd82d6a9" translate="yes" xml:space="preserve">
          <source>The loader for SPU does not handle dynamic relocations. By default, GCC gives an error when it generates code that requires a dynamic relocation.</source>
          <target state="translated">SPU 용 로더는 동적 재배치를 처리하지 않습니다. 기본적으로 GCC는 동적 재배치가 필요한 코드를 생성 할 때 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="168977c575f70c81d88c067d5911fa44bdb4a1dc" translate="yes" xml:space="preserve">
          <source>The local label feature is useful for complex macros. If a macro contains nested loops, a &lt;code&gt;goto&lt;/code&gt; can be useful for breaking out of them. However, an ordinary label whose scope is the whole function cannot be used: if the macro can be expanded several times in one function, the label is multiply defined in that function. A local label avoids this problem. For example:</source>
          <target state="translated">로컬 레이블 기능은 복잡한 매크로에 유용합니다. 매크로에 중첩 루프가 포함 된 경우 &lt;code&gt;goto&lt;/code&gt; 는이를 분리하는 데 유용 할 수 있습니다. 그러나 범위가 전체 함수 인 일반 레이블은 사용할 수 없습니다. 매크로를 한 함수에서 여러 번 확장 할 수 있으면 해당 함수에서 레이블이 여러 번 정의됩니다. 로컬 레이블은이 문제를 방지합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d40c92db025f666809a32030712abb46e10389b2" translate="yes" xml:space="preserve">
          <source>The location is expressed as a half-open range, expressed as a count of bytes, starting at byte 1 for the initial column. In the above example, bytes 3 through 20 of line 45 of &amp;ldquo;test.c&amp;rdquo; are to be replaced with the given string:</source>
          <target state="translated">위치는 반열 범위로 표시되며, 바이트 수로 표시되며 초기 열의 바이트 1에서 시작합니다. 위의 예에서, &quot;test.c&quot;의 45 행의 3-20 바이트는 주어진 문자열로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="068a4b98cf23f1dbecfe9f83dd38994bfe05765c" translate="yes" xml:space="preserve">
          <source>The locations within &lt;code&gt;#pragma&lt;/code&gt; directives where header name preprocessing tokens are recognized (C11 6.4, C11 6.4.7).</source>
          <target state="translated">헤더 이름 사전 처리 토큰이 인식되는 &lt;code&gt;#pragma&lt;/code&gt; 지시문 내의 위치 (C11 6.4, C11 6.4.7).</target>
        </trans-unit>
        <trans-unit id="fc6965c74c684a5066713cd45514db9bb14c9963" translate="yes" xml:space="preserve">
          <source>The long long types are only implemented for 64-bit code generation.</source>
          <target state="translated">long long 유형은 64 비트 코드 생성에만 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="6b21e2c583138d02ccff65c0acb02831c06a2211" translate="yes" xml:space="preserve">
          <source>The low registers r0 - r15.</source>
          <target state="translated">로우 레지스터 r0-r15.</target>
        </trans-unit>
        <trans-unit id="ed4899b603c3d7a32aa6ba260f62f9b063dd80a8" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;__CET__&lt;/code&gt; is defined when</source>
          <target state="translated">&lt;code&gt;__CET__&lt;/code&gt; 매크로 는</target>
        </trans-unit>
        <trans-unit id="835cec1112f64c57bd44cb4fd1c6251993152130" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;__STRICT_ANSI__&lt;/code&gt; is predefined when the</source>
          <target state="translated">매크로 &lt;code&gt;__STRICT_ANSI__&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="4af0e1087a3dafe7b329598208d0e7bd6efe70c3" translate="yes" xml:space="preserve">
          <source>The main use case of the built-in is to determine whether a &lt;code&gt;constexpr&lt;/code&gt; function is being called in a &lt;code&gt;constexpr&lt;/code&gt; context. A call to the function evaluates to a core constant expression with the value &lt;code&gt;true&lt;/code&gt; if and only if it occurs within the evaluation of an expression or conversion that is manifestly constant-evaluated as defined in the C++ standard. Manifestly constant-evaluated contexts include constant-expressions, the conditions of &lt;code&gt;constexpr if&lt;/code&gt; statements, constraint-expressions, and initializers of variables usable in constant expressions. For more details refer to the latest revision of the C++ standard.</source>
          <target state="translated">기본 제공 사용 사례는 &lt;code&gt;constexpr&lt;/code&gt; 함수가 &lt;code&gt;constexpr&lt;/code&gt; 컨텍스트 에서 호출 되는지 여부를 판별하는 것 입니다. 함수에 대한 호출 은 C ++ 표준에 정의 된대로 명시 적으로 상수 평가 된 표현식 또는 변환의 평가에서 발생하는 경우에만 &lt;code&gt;true&lt;/code&gt; 값을 갖는 핵심 상수 표현식으로 평가됩니다. 상수 상수 평가 컨텍스트에는 상수 표현식, &lt;code&gt;constexpr if&lt;/code&gt; 문의 조건, 제약 표현식 및 상수 표현식에 사용할 수있는 변수의 이니셜 라이저가 포함됩니다. 자세한 내용은 최신 C ++ 표준 개정판을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="44703f46619b4bb3387fbb3a9a4987ca25838ebf" translate="yes" xml:space="preserve">
          <source>The mangling was changed in</source>
          <target state="translated">맹 글링이 바뀌었다</target>
        </trans-unit>
        <trans-unit id="86f9d67774b219fd5194ad2624b61ab77f3088cf" translate="yes" xml:space="preserve">
          <source>The mapping between physical source file multibyte characters and the source character set in translation phase 1 (C90, C99 and C11 5.1.1.2).</source>
          <target state="translated">실제 소스 파일 멀티 바이트 문자와 변환 단계 1에서 소스 문자 세트 (C90, C99 및 C11 5.1.1.2) 간의 맵핑</target>
        </trans-unit>
        <trans-unit id="63322b3a774c9974339e8944410fb9a8c6f8ebf4" translate="yes" xml:space="preserve">
          <source>The mapping of members of the source character set (in character constants and string literals) to members of the execution character set (C90 6.1.3.4, C99 and C11 6.4.4.4, C90, C99 and C11 5.1.1.2).</source>
          <target state="translated">소스 문자 세트 멤버 (문자 상수 및 문자열 리터럴)를 실행 문자 세트 멤버 (C90 6.1.3.4, C99 및 C11 6.4.4.4, C90, C99 및 C11 5.1.1.2)에 맵핑</target>
        </trans-unit>
        <trans-unit id="6bc3864d5e277c6ac4690c5e9d3fdbf817cb1a7c" translate="yes" xml:space="preserve">
          <source>The max number of reload pseudos which are considered during spilling a non-reload pseudo.</source>
          <target state="translated">재장 전하지 않은 의사를 엎 지르는 동안 고려되는 재 장전 의사의 최대 수입니다.</target>
        </trans-unit>
        <trans-unit id="4f47dce047d8beaa87edf8a1fdc1bf827620a7f2" translate="yes" xml:space="preserve">
          <source>The maximum alignment for SIMD vector mode types. &lt;var&gt;num&lt;/var&gt; may be 4 or 8. The default is 8. Note that this is an ABI change, even though many library function interfaces are unaffected if they don&amp;rsquo;t use SIMD vector modes in places that affect size and/or alignment of relevant types.</source>
          <target state="translated">SIMD 벡터 모드 유형의 최대 정렬입니다. &lt;var&gt;num&lt;/var&gt; 은 4 또는 8 일 수 있습니다. 기본값은 8입니다. 많은 라이브러리 함수 인터페이스가 관련 유형의 크기 및 / 또는 정렬에 영향을주는 장소에서 SIMD 벡터 모드를 사용하지 않는 경우 많은 라이브러리 함수 인터페이스가 영향을받지 않더라도 ABI 변경입니다.</target>
        </trans-unit>
        <trans-unit id="666ee1692153a86b3ec75a197326eda3a0d60489" translate="yes" xml:space="preserve">
          <source>The maximum amount of iterations of the pass over the function. This is used to limit compilation time in tree tail merging.</source>
          <target state="translated">함수를 통과하는 최대 반복 횟수입니다. 이는 트리 테일 병합에서 컴파일 시간을 제한하는 데 사용됩니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
