<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="gcc">
    <body>
      <group id="gcc">
        <trans-unit id="aeab84fbb87aa1ae0148d00185bbbe64a7f1de75" translate="yes" xml:space="preserve">
          <source>Do/do not align destination of inlined string operations.</source>
          <target state="translated">인라인 문자열 조작의 대상을 정렬 /하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="bc45e676c4601147aa81205b6b35bbce28a0956f" translate="yes" xml:space="preserve">
          <source>Dollar sign is allowed in identifiers.</source>
          <target state="translated">식별자에는 달러 기호가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="68e93316f665d706cb16fce9b665aecabf389d83" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t (or do) generate assembler code for the DWARF line number debugging info. This may be useful when not using the GNU assembler.</source>
          <target state="translated">DWARF 라인 번호 디버깅 정보에 대한 어셈블러 코드를 생성하지 마십시오. GNU 어셈블러를 사용하지 않을 때 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c37914471f4a30f8d34225039b83103b924890c2" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t add</source>
          <target state="translated">추가하지 마십시오</target>
        </trans-unit>
        <trans-unit id="f51bdbcf76c028728ebe02e5fd8a3a1a4630491b" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t allocate any register in the range &lt;code&gt;r32&lt;/code&gt;&amp;hellip;&lt;code&gt;r63&lt;/code&gt;. That allows code to run on hardware variants that lack these registers.</source>
          <target state="translated">&lt;code&gt;r32&lt;/code&gt; &amp;hellip; &lt;code&gt;r63&lt;/code&gt; 범위의 레지스터를 할당하지 마십시오 . 이를 통해 이러한 레지스터가없는 하드웨어 변형에서 코드를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0696f924a6a7aba65bb0c521d005ad21d730a7e5" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t allow (allow) the compiler generating privileged mode code. Specifying</source>
          <target state="translated">컴파일러가 권한 모드 코드를 생성하는 것을 허용하지 마십시오. 지정</target>
        </trans-unit>
        <trans-unit id="b4aac26fa88db757f99f48797196bd3cbd91bc9d" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t emit code for implicit instantiations of inline templates, either. The default is to handle inlines differently so that compiles with and without optimization need the same set of explicit instantiations.</source>
          <target state="translated">인라인 템플릿의 암시 적 인스턴스화를위한 코드도 생성하지 마십시오. 기본값은 인라인을 다르게 처리하여 최적화가 있거나없는 컴파일에 동일한 명시 적 인스턴스화 세트가 필요하도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c69befd629431a6e029cd45dbc6aab7876d6d7d6" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t generate code to check for violation of exception specifications at run time. This option violates the C++ standard, but may be useful for reducing code size in production builds, much like defining &lt;code&gt;NDEBUG&lt;/code&gt;. This does not give user code permission to throw exceptions in violation of the exception specifications; the compiler still optimizes based on the specifications, so throwing an unexpected exception results in undefined behavior at run time.</source>
          <target state="translated">런타임시 예외 사양 위반을 확인하는 코드를 생성하지 마십시오. 이 옵션은 C ++ 표준을 위반하지만 &lt;code&gt;NDEBUG&lt;/code&gt; 정의와 같이 프로덕션 빌드에서 코드 크기를 줄이는 데 유용 할 수 있습니다 . 이것은 예외 코드를 위반하여 예외를 던질 수있는 권한을 사용자 코드에 부여하지 않습니다. 컴파일러는 여전히 사양을 기반으로 최적화하므로 예기치 않은 예외가 발생하면 런타임에 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f8291058c6a41a1212fed5bdc0b889e02ad54e73" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t generate extra code to prevent CSYNC or SSYNC instructions from occurring too soon after a conditional branch.</source>
          <target state="translated">조건부 분기 후 CSYNC 또는 SSYNC 명령이 너무 빨리 발생하지 않도록 추가 코드를 생성하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="92fc05375382df9e90695eff3a44465379a9fc8a" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t generate extra code to prevent speculative loads from occurring.</source>
          <target state="translated">추론 적로드가 발생하지 않도록 추가 코드를 생성하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="841b2c5913f27dd6d0a0b75be4041ed9060e2a5b" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t indicate any priority for target registers.</source>
          <target state="translated">대상 레지스터에 우선 순위를 표시하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="316b458b3b915800cc227cb589b8354e8997e031" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t insert NOPs.</source>
          <target state="translated">NOP를 삽입하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="ff257b74ea5cefc2a6c99dc46dcf1ce2fc00c3e9" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t keep the frame pointer in a register for leaf functions. This avoids the instructions to save, set up and restore frame pointers and makes an extra register available in leaf functions.</source>
          <target state="translated">리프 함수의 레지스터에 프레임 포인터를 유지하지 마십시오. 이렇게하면 프레임 포인터를 저장, 설정 및 복원하라는 지시를 피하고 리프 함수에서 추가 레지스터를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="29fcb114afda8378c254d0362fee3390fc31a076" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t keep the frame pointer in a register for leaf functions. This avoids the instructions to save, set up, and restore frame pointers and makes an extra register available in leaf functions. The option</source>
          <target state="translated">리프 함수의 레지스터에 프레임 포인터를 유지하지 마십시오. 이렇게하면 프레임 포인터를 저장, 설정 및 복원하라는 지시를 피하고 리프 함수에서 추가 레지스터를 사용할 수 있습니다. 옵션</target>
        </trans-unit>
        <trans-unit id="ba01c69254f25c86224b738f06e6534bc4f3d911" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t link against AVR-LibC&amp;rsquo;s device specific library &lt;code&gt;lib&amp;lt;mcu&amp;gt;.a&lt;/code&gt;.</source>
          <target state="translated">AVR-LibC의 장치 별 라이브러리 &lt;code&gt;lib&amp;lt;mcu&amp;gt;.a&lt;/code&gt; 연결하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="e29b08debc2f8c83b43cab1a04eee2f4d727ea03" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t output a &lt;code&gt;.size&lt;/code&gt; assembler directive, or anything else that would cause trouble if the function is split in the middle, and the two halves are placed at locations far apart in memory. This option is used when compiling</source>
          <target state="translated">&lt;code&gt;.size&lt;/code&gt; 어셈블러 지시문 또는 함수가 중간에 분할되고 두 개의 반쪽이 메모리에서 멀리 떨어진 위치에 배치되면 문제를 일으킬 수있는 어떤 것도 출력하지 마십시오 . 이 옵션은 컴파일 할 때 사용됩니다</target>
        </trans-unit>
        <trans-unit id="d01cd709102ba1930825f66a542ae471f0249850" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t produce a dynamically linked position independent executable.</source>
          <target state="translated">동적으로 링크 된 위치 독립적 실행 파일을 생성하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="0d7422ae3d66c98a5899ca6447dbd9bcec60457e" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t recognize built-in functions that do not begin with &amp;lsquo;</source>
          <target state="translated">'로 시작하지 않는 내장 함수를 인식하지 못합니다</target>
        </trans-unit>
        <trans-unit id="700e3402560c020ff640d0360da073b7f29b63b2" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t try to return a reference when you must return an object.</source>
          <target state="translated">객체를 반환해야 할 때 참조를 반환하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="af0c2963603baeac9b84a7601cb10b5b24bf9b5d" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t use less than 25-bit addressing range for calls, which is the offset available for an unconditional branch-and-link instruction. Conditional execution of function calls is suppressed, to allow use of the 25-bit range, rather than the 21-bit range with conditional branch-and-link. This is the default for tool chains built for &lt;code&gt;arc-linux-uclibc&lt;/code&gt; and &lt;code&gt;arceb-linux-uclibc&lt;/code&gt; targets.</source>
          <target state="translated">무조건 분기 및 링크 명령에 사용할 수있는 오프셋 인 통화에 25 비트 미만의 주소 지정 범위를 사용하지 마십시오. 조건부 분기 및 링크가있는 21 비트 범위가 아닌 25 비트 범위를 사용할 수 있도록 함수 호출의 조건부 실행이 억제됩니다. 이는 &lt;code&gt;arc-linux-uclibc&lt;/code&gt; 및 &lt;code&gt;arceb-linux-uclibc&lt;/code&gt; 대상 용으로 빌드 된 툴 체인의 기본값입니다 .</target>
        </trans-unit>
        <trans-unit id="71dc31daaf7ec06b2fa4f05018881b81c4bb5538" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t use the &lt;code&gt;__cxa_get_exception_ptr&lt;/code&gt; runtime routine. This causes &lt;code&gt;std::uncaught_exception&lt;/code&gt; to be incorrect, but is necessary if the runtime routine is not available.</source>
          <target state="translated">&lt;code&gt;__cxa_get_exception_ptr&lt;/code&gt; 런타임 루틴을 사용하지 마십시오 . 이로 인해 &lt;code&gt;std::uncaught_exception&lt;/code&gt; 이 올바르지 않지만 런타임 루틴을 사용할 수없는 경우 필요합니다.</target>
        </trans-unit>
        <trans-unit id="8dcc5d27681a8bdad6a9cb3ee54a8968b968d227" translate="yes" xml:space="preserve">
          <source>Double-precision floating point:</source>
          <target state="translated">배정 밀도 부동 소수점 :</target>
        </trans-unit>
        <trans-unit id="ed1ceb86db6df41816a7c2bb25eb2a7096005f14" translate="yes" xml:space="preserve">
          <source>Double-precision minimum and maximum. These instructions are only generated if</source>
          <target state="translated">배정 밀도 최소 및 최대. 이 명령어는 다음과 같은 경우에만 생성됩니다</target>
        </trans-unit>
        <trans-unit id="37d9eb125267c27f5502a1a9d084767dc36a78f0" translate="yes" xml:space="preserve">
          <source>Double-precision trigonometric and exponential functions. These instructions are only generated if</source>
          <target state="translated">배정 밀도 삼각 함수 및 지수 함수. 이 명령어는 다음과 같은 경우에만 생성됩니다</target>
        </trans-unit>
        <trans-unit id="6df71cfe44fe533eddb81c22b571782849f6b7cc" translate="yes" xml:space="preserve">
          <source>Double-word integers&amp;mdash;&lt;code&gt;long long int&lt;/code&gt;.</source>
          <target state="translated">더블 워드 정수 &amp;mdash; &lt;code&gt;long long int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc953a7def63cef4cb68fb70c5f14bea1b94cf60" translate="yes" xml:space="preserve">
          <source>Downgrade some diagnostics about nonconformant code from errors to warnings. Thus, using</source>
          <target state="translated">부적합한 코드에 대한 일부 진단을 오류에서 경고로 다운 그레이드하십시오. 따라서</target>
        </trans-unit>
        <trans-unit id="01180802e3e84af7a4d8039eea60df66e24e2e3d" translate="yes" xml:space="preserve">
          <source>Due to a limitation the &lt;code&gt;__builtin_has_attribute&lt;/code&gt; function returns &lt;code&gt;false&lt;/code&gt; for the &lt;code&gt;mode&lt;/code&gt; attribute even if the type or variable referenced by the &lt;var&gt;type-or-expression&lt;/var&gt; argument was declared with one. The function is also not supported with labels, and in C with enumerators.</source>
          <target state="translated">제한으로 인해 &lt;code&gt;__builtin_has_attribute&lt;/code&gt; 함수는 &lt;var&gt;type-or-expression&lt;/var&gt; 인수가 참조하는 유형 또는 변수 가 1로 선언 된 경우에도 &lt;code&gt;mode&lt;/code&gt; 속성에 대해 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 이 기능은 레이블과 열거자가있는 C에서도 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eaa7b08f0e0c97160e76284248f06868dbcb58d2" translate="yes" xml:space="preserve">
          <source>Due to delay slot scheduling and interactions between operand numbers, literal sizes, instruction lengths, and the support for conditional execution, the target-independent pass to generate conditional execution is often lacking, so the ARC port has kept a special pass around that tries to find more conditional execution generation opportunities after register allocation, branch shortening, and delay slot scheduling have been done. This pass generally, but not always, improves performance and code size, at the cost of extra compilation time, which is why there is an option to switch it off. If you have a problem with call instructions exceeding their allowable offset range because they are conditionalized, you should consider using</source>
          <target state="translated">피연산자 번호, 리터럴 크기, 명령어 길이 및 조건부 실행 지원 간의 지연 슬롯 스케줄링 및 상호 작용으로 인해 조건부 실행을 생성하기위한 대상 독립적 패스가 종종 부족하므로 ARC 포트는 레지스터 할당, 분기 단축 및 지연 슬롯 스케줄링이 완료된 후 더 많은 조건부 실행 생성 기회를 찾습니다. 이 패스는 일반적으로 항상 그렇지는 않지만 추가 컴파일 시간을 희생하여 성능 및 코드 크기를 향상 시키므로이를 해제 할 수있는 옵션이 있습니다. 조건에 따라 통화 지시가 허용 오프셋 범위를 초과하는 데 문제가있는 경우 사용을 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="8570e266a139eea3cf33870c783885655692c297" translate="yes" xml:space="preserve">
          <source>Due to differences in 64-bit ABIs, any Microsoft ABI function that calls a System V ABI function must consider RSI, RDI and XMM6-15 as clobbered. By default, the code for saving and restoring these registers is emitted inline, resulting in fairly lengthy prologues and epilogues. Using</source>
          <target state="translated">64 비트 ABI의 차이로 인해 System V ABI 함수를 호출하는 모든 Microsoft ABI 함수는 RSI, RDI 및 XMM6-15를 클로버로 간주해야합니다. 기본적으로 이러한 레지스터를 저장하고 복원하는 코드는 인라인으로 방출되므로 프롤로그와 에필로그가 상당히 길어집니다. 사용</target>
        </trans-unit>
        <trans-unit id="408f58f18488b8883676547177ce8b939c3a83db" translate="yes" xml:space="preserve">
          <source>Dump a representation of the &amp;ldquo;exploded graph&amp;rdquo; suitable for viewing with GraphViz to</source>
          <target state="translated">GraphViz로보기에 적합한 &quot;분해 된 그래프&quot;의 표현을 덤프하여</target>
        </trans-unit>
        <trans-unit id="169bc667798b22c68aedd5d55d686c15e2808baf" translate="yes" xml:space="preserve">
          <source>Dump a representation of the call graph suitable for viewing with GraphViz to</source>
          <target state="translated">GraphViz로보기에 적합한 호출 그래프의 표현을 덤프하여</target>
        </trans-unit>
        <trans-unit id="57d46471a4ce7f3b77f03f78421a9baa93db393b" translate="yes" xml:space="preserve">
          <source>Dump a textual representation of the &amp;ldquo;exploded graph&amp;rdquo; to</source>
          <target state="translated">&quot;분해 된 그래프&quot;의 텍스트 표현을 덤프</target>
        </trans-unit>
        <trans-unit id="ca50a32f407b97e3b5dbaa8c49a491f9e0224426" translate="yes" xml:space="preserve">
          <source>Dump a textual representation of the &amp;ldquo;exploded graph&amp;rdquo; to one dump file per node, to</source>
          <target state="translated">&quot;분해 된 그래프&quot;의 텍스트 표현을 노드 당 하나의 덤프 파일로 덤프하여</target>
        </trans-unit>
        <trans-unit id="55dc1ed426258fad4287ccc3186c8799b4478fe2" translate="yes" xml:space="preserve">
          <source>Dump after RTL generation.</source>
          <target state="translated">RTL 생성 후 덤프</target>
        </trans-unit>
        <trans-unit id="55112da270658f739f4dfb65c2070abbe0a2de15" translate="yes" xml:space="preserve">
          <source>Dump after all rtl has been unshared.</source>
          <target state="translated">모든 rtl이 공유 해제 된 후 덤프</target>
        </trans-unit>
        <trans-unit id="17713d860b95f07f88ad9a9c6f46bff3093dd8bf" translate="yes" xml:space="preserve">
          <source>Dump after auto-inc-dec discovery. This pass is only run on architectures that have auto inc or auto dec instructions.</source>
          <target state="translated">자동 -inc-dec 감지 후 덤프. 이 단계는 auto inc 또는 auto dec 명령이있는 아키텍처에서만 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="4544c05126cdb19431a178314ee1eee9792fb198" translate="yes" xml:space="preserve">
          <source>Dump after block reordering.</source>
          <target state="translated">블록 재정렬 후 덤프.</target>
        </trans-unit>
        <trans-unit id="78c9d4108223d54d2d9b5209aec4c77ba61f990a" translate="yes" xml:space="preserve">
          <source>Dump after branch alignments have been computed.</source>
          <target state="translated">분기 정렬 후 덤프가 계산되었습니다.</target>
        </trans-unit>
        <trans-unit id="becf6aa3d2a32b64f568f0ff4ffede5097942c5f" translate="yes" xml:space="preserve">
          <source>Dump after cleaning up the barrier instructions.</source>
          <target state="translated">배리어 지침을 청소 한 후 덤프하십시오.</target>
        </trans-unit>
        <trans-unit id="4157bd0dc462fb4b9de6813e4b6322c3ce89115d" translate="yes" xml:space="preserve">
          <source>Dump after combining stack adjustments.</source>
          <target state="translated">스택 조정을 결합한 후 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="ca08541014a668445bc90fdf9e0e75729f2449db" translate="yes" xml:space="preserve">
          <source>Dump after common sequence discovery.</source>
          <target state="translated">공통 시퀀스 발견 후 덤프</target>
        </trans-unit>
        <trans-unit id="003a4c3463d2348777de9c3ec96a83fded9a133b" translate="yes" xml:space="preserve">
          <source>Dump after conversion from GCC&amp;rsquo;s &amp;ldquo;flat register file&amp;rdquo; registers to the x87&amp;rsquo;s stack-like registers. This pass is only run on x86 variants.</source>
          <target state="translated">GCC의 &quot;플랫 레지스터 파일&quot;레지스터에서 x87의 스택 형 레지스터로 변환 후 덤프. 이 패스는 x86 변형에서만 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="83008119d9369fbf18b0ada0441c79a07768ec53" translate="yes" xml:space="preserve">
          <source>Dump after conversion of EH handling range regions.</source>
          <target state="translated">EH 처리 범위 영역의 변환 후 덤프.</target>
        </trans-unit>
        <trans-unit id="3bf729ea33ed64d3ed60d59c687162fd5feb227f" translate="yes" xml:space="preserve">
          <source>Dump after converting from cfglayout mode.</source>
          <target state="translated">cfglayout 모드에서 변환 한 후 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="8c3c2b3635d622c5e7ba8ea735eb12810fb32bac" translate="yes" xml:space="preserve">
          <source>Dump after converting to cfglayout mode.</source>
          <target state="translated">cfglayout 모드로 변환 한 후 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="c3336c59217d8a52dec6ae53e20f9f151f5f642d" translate="yes" xml:space="preserve">
          <source>Dump after converting virtual registers to hard registers.</source>
          <target state="translated">가상 레지스터를 하드 레지스터로 변환 한 후 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="9e4924e7d7139d25008b3b0767ee0c48540ad8c8" translate="yes" xml:space="preserve">
          <source>Dump after delayed branch scheduling.</source>
          <target state="translated">지연된 지점 예약 후 덤프</target>
        </trans-unit>
        <trans-unit id="d2764959e209d321913a6a9e66c4ca5ca11ad126" translate="yes" xml:space="preserve">
          <source>Dump after duplicating the computed gotos.</source>
          <target state="translated">계산 된 고 토스를 복제 한 후 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="6e4665a9117fc08d9bbcca5529570f4270193b64" translate="yes" xml:space="preserve">
          <source>Dump after finalization of EH handling code.</source>
          <target state="translated">EH 처리 코드가 완료된 후 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="0bd2968b703fd689e056f9d8a3839eaca5ddccc9" translate="yes" xml:space="preserve">
          <source>Dump after fixing rtl statements that have unsatisfied in/out constraints.</source>
          <target state="translated">입력 / 출력 제약 조건이 만족되지 않는 rtl 문을 수정 한 후 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="1f6440e322c9dbaaa59c98dce4c47af3058d32dc" translate="yes" xml:space="preserve">
          <source>Dump after function inlining.</source>
          <target state="translated">함수 인라인 후 덤프</target>
        </trans-unit>
        <trans-unit id="988226cdeaba5c3515016a8a81c5ff5fb6cd975a" translate="yes" xml:space="preserve">
          <source>Dump after generating the function prologues and epilogues.</source>
          <target state="translated">함수 프롤로그 및 에필로그를 생성 한 후 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="337d4408dd5282e57a077069c98fc55c719caf17" translate="yes" xml:space="preserve">
          <source>Dump after hard register copy propagation.</source>
          <target state="translated">하드 레지스터 복사 전파 후 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="6cfe830bfa04c4483b1574a46bcfd925bca4b994" translate="yes" xml:space="preserve">
          <source>Dump after iterated register allocation.</source>
          <target state="translated">반복 된 레지스터 할당 후 덤프.</target>
        </trans-unit>
        <trans-unit id="1332404cd20a620c3e5eef9263282d44f935e6c1" translate="yes" xml:space="preserve">
          <source>Dump after jump bypassing and control flow optimizations.</source>
          <target state="translated">점프 바이 패스 및 제어 흐름 최적화 후 덤프.</target>
        </trans-unit>
        <trans-unit id="bbeda7ae9b9627b581ee42ee3d7f61a589a6f9b2" translate="yes" xml:space="preserve">
          <source>Dump after live range splitting.</source>
          <target state="translated">라이브 범위 분할 후 덤프</target>
        </trans-unit>
        <trans-unit id="35f1d73925595e51018771690ad76fb0f4a1f233" translate="yes" xml:space="preserve">
          <source>Dump after modulo scheduling. This pass is only run on some architectures.</source>
          <target state="translated">모듈로 스케줄링 후 덤프. 이 패스는 일부 아키텍처에서만 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="d76e4430e6a8233563404db6f071f4d94eacdd64" translate="yes" xml:space="preserve">
          <source>Dump after partitioning hot and cold basic blocks.</source>
          <target state="translated">핫 및 콜드 기본 블록을 분할 한 후 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="93dacaa1e7ab1044d9cdae673b25a3808eaccbc6" translate="yes" xml:space="preserve">
          <source>Dump after performing the machine dependent reorganization pass, if that pass exists.</source>
          <target state="translated">머신 종속 재구성 패스를 수행 한 후 해당 패스가 있으면 덤프하십시오.</target>
        </trans-unit>
        <trans-unit id="b6bdb28476f2b3244c70b802b4bb64b0a7243f10" translate="yes" xml:space="preserve">
          <source>Dump after post-reload optimizations.</source>
          <target state="translated">재로드 후 최적화 후 덤프.</target>
        </trans-unit>
        <trans-unit id="88e826a50b33b907232b8a297fb0c5a8f9b2749b" translate="yes" xml:space="preserve">
          <source>Dump after register renumbering.</source>
          <target state="translated">레지스터 번호를 다시 매긴 후 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="ababff05976fea728752ca7d70fe16f292f0407d" translate="yes" xml:space="preserve">
          <source>Dump after removing redundant mode switches.</source>
          <target state="translated">중복 모드 스위치를 제거한 후 덤프하십시오.</target>
        </trans-unit>
        <trans-unit id="017c4f83a9a4f5ea41d958881b5ab4ae0e8a9034" translate="yes" xml:space="preserve">
          <source>Dump after shortening branches.</source>
          <target state="translated">분기를 단축 한 후 덤프하십시오.</target>
        </trans-unit>
        <trans-unit id="b3771d727095e3610636bea776ecdc1fc695644e" translate="yes" xml:space="preserve">
          <source>Dump after sibling call optimizations.</source>
          <target state="translated">형제 통화 최적화 후 덤프.</target>
        </trans-unit>
        <trans-unit id="c8dbbab140317072ef733bc98b57dcf08d1828c7" translate="yes" xml:space="preserve">
          <source>Dump after sign/zero extension elimination.</source>
          <target state="translated">부호 제거 / 제로 확장 제거 후 덤프.</target>
        </trans-unit>
        <trans-unit id="e9bbcf22fbbd3795374ba7c5550d62449e5abb59" translate="yes" xml:space="preserve">
          <source>Dump after the RTL instruction combination pass.</source>
          <target state="translated">RTL 명령어 조합 통과 후 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="feffc80f8e62ccde9b555546a5afb7ff2768d0f7" translate="yes" xml:space="preserve">
          <source>Dump after the computation of the initial value sets.</source>
          <target state="translated">초기 값 세트 계산 후 덤프.</target>
        </trans-unit>
        <trans-unit id="5bf6c1aae6940dca8add6967093968d70664b454" translate="yes" xml:space="preserve">
          <source>Dump after the initialization of the registers.</source>
          <target state="translated">레지스터 초기화 후 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="d22e8f2d8c89989fe194bf7d0b0983f1d445d944" translate="yes" xml:space="preserve">
          <source>Dump after the peephole pass.</source>
          <target state="translated">들여다 보는 구멍 통과 후 덤프.</target>
        </trans-unit>
        <trans-unit id="9201f61bd4694de8e9a9ab14f3cc717f0cf63945" translate="yes" xml:space="preserve">
          <source>Dump after the second jump optimization.</source>
          <target state="translated">두 번째 점프 최적화 후 덤프.</target>
        </trans-unit>
        <trans-unit id="418c902efcddfdb022a1c7b5bf343ea52897c514" translate="yes" xml:space="preserve">
          <source>Dump after the standalone dead code elimination passes.</source>
          <target state="translated">독립 실행 형 코드 제거가 통과 된 후 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="79702f60e31788035dc7ae01b75a7919074a5bce" translate="yes" xml:space="preserve">
          <source>Dump after variable tracking.</source>
          <target state="translated">변수 추적 후 덤프</target>
        </trans-unit>
        <trans-unit id="907510a3aae3ec8d9be507f0c620d65e786ea7f0" translate="yes" xml:space="preserve">
          <source>Dump all macro definitions, at the end of preprocessing, in addition to normal output.</source>
          <target state="translated">사전 처리가 끝나면 일반 출력 외에 모든 매크로 정의를 덤프하십시오.</target>
        </trans-unit>
        <trans-unit id="c5efd5b60f90b713fff2357c80d7db933b0250ab" translate="yes" xml:space="preserve">
          <source>Dump class hierarchy information. Virtual table information is emitted unless &amp;rsquo;</source>
          <target state="translated">클래스 계층 정보를 덤프합니다. 가상 테이블 정보는 '</target>
        </trans-unit>
        <trans-unit id="7bc6ef641876378e44aa64caddde9a5c6398af12" translate="yes" xml:space="preserve">
          <source>Dump content of records.</source>
          <target state="translated">레코드 내용을 덤프하십시오.</target>
        </trans-unit>
        <trans-unit id="b65d037ae2af66afd4c389367c4bc6cdd9830974" translate="yes" xml:space="preserve">
          <source>Dump debugging information generated during the debug generation phase.</source>
          <target state="translated">디버그 생성 단계에서 생성 된 디버깅 정보를 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="c9b2d27d13ca1550be85a391df7269704a34e8f9" translate="yes" xml:space="preserve">
          <source>Dump debugging information generated during the early debug generation phase.</source>
          <target state="translated">초기 디버그 생성 단계에서 생성 된 디버깅 정보를 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="1abef1a2a1cc464ec73ba64187b2cddb0b1c7d96" translate="yes" xml:space="preserve">
          <source>Dump initial values of the variables.</source>
          <target state="translated">변수의 초기 값을 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="5d5bde1ac03861eb7f209733ddfd1025c1c70bcf" translate="yes" xml:space="preserve">
          <source>Dump instruction size and location in the assembly code.</source>
          <target state="translated">어셈블리 코드에서 명령 크기 및 위치를 덤프하십시오.</target>
        </trans-unit>
        <trans-unit id="754b569854e205d185835c2d9673785b92b6f32c" translate="yes" xml:space="preserve">
          <source>Dump interface declarations for all classes seen in the source file to a file named</source>
          <target state="translated">소스 파일에 표시된 모든 클래스에 대한 인터페이스 선언을 이름이 지정된 파일로 덤프하십시오.</target>
        </trans-unit>
        <trans-unit id="71af018e18b101632a18de688096b3fe9f9a731e" translate="yes" xml:space="preserve">
          <source>Dump internal details about what the analyzer is doing to</source>
          <target state="translated">분석기가 수행하는 작업에 대한 내부 세부 정보 덤프</target>
        </trans-unit>
        <trans-unit id="e377d6eb44f5fb68248439a06aca414e07626287" translate="yes" xml:space="preserve">
          <source>Dump internal details about what the analyzer is doing to stderr. This option overrides</source>
          <target state="translated">분석기가 stderr에 수행하는 작업에 대한 내부 세부 정보를 덤프합니다. 이 옵션은</target>
        </trans-unit>
        <trans-unit id="657cfbab09055c61a05bd93612f91cf2d2f1bab3" translate="yes" xml:space="preserve">
          <source>Dump only the defined symbols.</source>
          <target state="translated">정의 된 기호 만 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="e881c92154f92df37cd4957d4fba3b310ed362c0" translate="yes" xml:space="preserve">
          <source>Dump out a</source>
          <target state="translated">밖으로 덤프</target>
        </trans-unit>
        <trans-unit id="72d2bf1fd50afe65e57f8ac99ba069fc8e23ed58" translate="yes" xml:space="preserve">
          <source>Dump positions of records.</source>
          <target state="translated">레코드 위치를 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="62f71366775032a269dc239f7ef38d5ece6fef12" translate="yes" xml:space="preserve">
          <source>Dump representations of the &amp;ldquo;supergraph&amp;rdquo; suitable for viewing with GraphViz to</source>
          <target state="translated">GraphViz로보기에 적합한 &quot;수퍼 그래프&quot;의 표현을 덤프하여</target>
        </trans-unit>
        <trans-unit id="09ac4bde087663de0f3a006b963a6f5235611c2d" translate="yes" xml:space="preserve">
          <source>Dump the RTL in the assembler output as a comment before each instruction. Also turns on</source>
          <target state="translated">각 명령어 앞에 주석으로 어셈블러 출력에서 ​​RTL을 덤프하십시오. 또한 켜</target>
        </trans-unit>
        <trans-unit id="0be5cff07653f79d7c01424690f5d095b8fcbb7d" translate="yes" xml:space="preserve">
          <source>Dump the demangled output.</source>
          <target state="translated">왜곡 된 출력을 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="1726ca951812ad3322375de05b128457cc9a8ced" translate="yes" xml:space="preserve">
          <source>Dump the details of LTO objects.</source>
          <target state="translated">LTO 개체의 세부 정보를 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="171aa9511579073802041f0a2e60b1934e57be91" translate="yes" xml:space="preserve">
          <source>Dump the details of specific symbol.</source>
          <target state="translated">특정 기호의 세부 사항을 덤프하십시오.</target>
        </trans-unit>
        <trans-unit id="5d265d5ceeb36fc58845a8b5aa258590ef02cc80" translate="yes" xml:space="preserve">
          <source>Dump the final internal representation (RTL) to &lt;var&gt;file&lt;/var&gt;. If the optional argument is omitted (or if &lt;var&gt;file&lt;/var&gt; is &lt;code&gt;.&lt;/code&gt;), the name of the dump file is determined by appending &lt;code&gt;.gkd&lt;/code&gt; to the compilation output file name.</source>
          <target state="translated">최종 내부 표현 (RTL)을 &lt;var&gt;file&lt;/var&gt; 에 덤프 하십시오 . 선택적 인수가 생략 된 경우 (또는 &lt;var&gt;file&lt;/var&gt; 이 &lt;code&gt;.&lt;/code&gt; 인 경우 ) 덤프 출력 파일의 이름은 컴파일 출력 파일 이름에 &lt;code&gt;.gkd&lt;/code&gt; 를 추가하여 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="6290582c1c9788e12ed9d3f73eafdd3bbcd4abf7" translate="yes" xml:space="preserve">
          <source>Dump the raw internal tree data. This option is applicable to C++ only.</source>
          <target state="translated">원시 내부 트리 데이터를 덤프하십시오. 이 옵션은 C ++에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="1afb37f8221633019abbbb6e4139e775923345d4" translate="yes" xml:space="preserve">
          <source>Dump the specific gimple body.</source>
          <target state="translated">특정 김플 바디를 버리십시오.</target>
        </trans-unit>
        <trans-unit id="be1097bb2eea2f70c64d4c1cb70ed1c5ba583376" translate="yes" xml:space="preserve">
          <source>Dump the statistics of gimple statements.</source>
          <target state="translated">gimple 문의 통계를 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="3a4757ccb92c3f2e13c8881d180d079b3623ccf0" translate="yes" xml:space="preserve">
          <source>Dump the statistics of tree types.</source>
          <target state="translated">트리 유형의 통계를 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="1f4cd598ed5041028b59e01e68f001fefceb7ea6" translate="yes" xml:space="preserve">
          <source>Dump the statistics of trees.</source>
          <target state="translated">나무의 통계를 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="3b93daf63f806cdb033463ad6f03043c2e411af3" translate="yes" xml:space="preserve">
          <source>Dump the symbols in order of occurrence.</source>
          <target state="translated">발생 순서대로 기호를 덤프하십시오.</target>
        </trans-unit>
        <trans-unit id="389f264332906b0c1d732e39c64a371de3b149c7" translate="yes" xml:space="preserve">
          <source>Dump the symbols in reverse order.</source>
          <target state="translated">기호를 역순으로 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="5c09bbbb574ea9794181ca0910564f4164221e71" translate="yes" xml:space="preserve">
          <source>Dumps information about call-graph optimization, unused function removal, and inlining decisions.</source>
          <target state="translated">호출 그래프 최적화, 미사용 함수 제거 및 인라인 결정에 대한 정보를 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="3288dac3087a7accf2fa127698249b8034a173fa" translate="yes" xml:space="preserve">
          <source>Dumps list of details of functions and variables.</source>
          <target state="translated">함수 및 변수의 세부 사항 목록을 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="c057075d7f6d1311d665f05607d5a1143e726ae5" translate="yes" xml:space="preserve">
          <source>Duplicate instances of a template can be avoided by defining an explicit instantiation in one object file, and preventing the compiler from doing implicit instantiations in any other object files by using an explicit instantiation declaration, using the &lt;code&gt;extern template&lt;/code&gt; syntax:</source>
          <target state="translated">하나의 오브젝트 파일에서 명시 적 인스턴스화를 정의하고 &lt;code&gt;extern template&lt;/code&gt; 구문 을 사용하여 명시 적 인스턴스화 선언을 사용하여 컴파일러가 다른 오브젝트 파일에서 암시 적 인스턴스화를 수행하지 못하게함으로써 템플리트의 중복 인스턴스를 피할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="873001cb1e8e159e206fe4747ed8630083de92b7" translate="yes" xml:space="preserve">
          <source>During its analysis of function bodies, IPA-CP employs alias analysis in order to track values pointed to by function parameters. In order not spend too much time analyzing huge functions, it gives up and consider all memory clobbered after examining</source>
          <target state="translated">기능 본문을 분석하는 동안 IPA-CP는 기능 매개 변수가 가리키는 값을 추적하기 위해 별명 분석을 사용합니다. 거대한 기능을 분석하는 데 너무 많은 시간을 소비하지 않기 위해 검사 후 모든 메모리가 폐기 된 것을 포기하고 고려</target>
        </trans-unit>
        <trans-unit id="35ad8603f50d24cddaa26acc281e43114f0f03d6" translate="yes" xml:space="preserve">
          <source>During the incremental link (by</source>
          <target state="translated">증분 링크 중</target>
        </trans-unit>
        <trans-unit id="6e5d8e172227784c44cef25322c1d84b5b1ed089" translate="yes" xml:space="preserve">
          <source>During the link-time optimization warn about type mismatches in global declarations from different compilation units. Requires</source>
          <target state="translated">링크 타임 최적화 중에 다른 컴파일 단위의 전역 선언에서 형식 불일치에 대해 경고합니다. 필요</target>
        </trans-unit>
        <trans-unit id="3941436ae2dc30b7d71f0708c7f73c50626caec3" translate="yes" xml:space="preserve">
          <source>During the link-time optimization, do not warn about type mismatches in global declarations from different compilation units. Requires</source>
          <target state="translated">링크 시간 최적화 중에 다른 컴파일 단위의 전역 선언에서 유형 불일치에 대해 경고하지 마십시오. 필요</target>
        </trans-unit>
        <trans-unit id="1ed8a7568d4927beb8ca9fcc2f434426a2ed3775" translate="yes" xml:space="preserve">
          <source>Dynamic rounding mode. A field in the floating-point control register (&lt;var&gt;fpcr&lt;/var&gt;, see Alpha architecture reference manual) controls the rounding mode in effect. The C library initializes this register for rounding towards plus infinity. Thus, unless your program modifies the &lt;var&gt;fpcr&lt;/var&gt;, &amp;lsquo;</source>
          <target state="translated">동적 반올림 모드. 부동 소수점 제어 레지스터의 필드 ( &lt;var&gt;fpcr&lt;/var&gt; , 알파 아키텍처 참조 설명서 참조)는 실제로 반올림 모드를 제어합니다. C 라이브러리는 +를 무한대로 반올림하기 위해이 레지스터를 초기화합니다. 따라서 프로그램이 &lt;var&gt;fpcr&lt;/var&gt; 을 수정하지 않으면 '</target>
        </trans-unit>
        <trans-unit id="ee61e1d4359d2101e0207f1f6ab138bc105fa253" translate="yes" xml:space="preserve">
          <source>Dynamically allocate condition code registers.</source>
          <target state="translated">조건 코드 레지스터를 동적으로 할당합니다.</target>
        </trans-unit>
        <trans-unit id="e0184adedf913b076626646d3f52c3b49c39ad6d" translate="yes" xml:space="preserve">
          <source>E</source>
          <target state="translated">E</target>
        </trans-unit>
        <trans-unit id="8424e737649ba7f5ce9529e01136274dd622c253" translate="yes" xml:space="preserve">
          <source>E+</source>
          <target state="translated">E+</target>
        </trans-unit>
        <trans-unit id="b86bd135c70e92d6b2051a988af8d8fd3b21cb67" translate="yes" xml:space="preserve">
          <source>E-</source>
          <target state="translated">E-</target>
        </trans-unit>
        <trans-unit id="fa4a7a170f7075560c98a976572cae386b13a240" translate="yes" xml:space="preserve">
          <source>E.g.</source>
          <target state="translated">E.g.</target>
        </trans-unit>
        <trans-unit id="180b58cf69b13102962b17f297dd40af5fac3b7a" translate="yes" xml:space="preserve">
          <source>EAM register &lt;code&gt;mdb&lt;/code&gt;</source>
          <target state="translated">EAM 레지스터 &lt;code&gt;mdb&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4183eec55a2657bd56f5a3f286167e22c41277ca" translate="yes" xml:space="preserve">
          <source>EAM register &lt;code&gt;mdc&lt;/code&gt;</source>
          <target state="translated">EAM 레지스터 &lt;code&gt;mdc&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="042b890a506cb1f86b057af9f2065c60f0543326" translate="yes" xml:space="preserve">
          <source>ESC</source>
          <target state="translated">ESC</target>
        </trans-unit>
        <trans-unit id="db3a4c6dcbc964f457aa623cff604baca1fe6abf" translate="yes" xml:space="preserve">
          <source>ESC \</source>
          <target state="translated">ESC \</target>
        </trans-unit>
        <trans-unit id="ef29ed353f79614b0af0aa06877e0e8365ad41a3" translate="yes" xml:space="preserve">
          <source>EV</source>
          <target state="translated">EV</target>
        </trans-unit>
        <trans-unit id="8404c13b819cbc829893e6fcf7e6b011dc8afafa" translate="yes" xml:space="preserve">
          <source>EXEC register (EXEC_LO and EXEC_HI)</source>
          <target state="translated">EXEC 레지스터 (EXEC_LO 및 EXEC_HI)</target>
        </trans-unit>
        <trans-unit id="3633746b067241666bc462dcfe7a24ff23a8db68" translate="yes" xml:space="preserve">
          <source>Each</source>
          <target state="translated">Each</target>
        </trans-unit>
        <trans-unit id="ec76a07122ba99b0a9685803ebd0fcbd4bc2bfc8" translate="yes" xml:space="preserve">
          <source>Each &amp;lsquo;</source>
          <target state="translated">각 '</target>
        </trans-unit>
        <trans-unit id="7a238e89c65aac1db813f790141cd6a1706499a7" translate="yes" xml:space="preserve">
          <source>Each &lt;var&gt;branch&lt;/var&gt; has the following form:</source>
          <target state="translated">각 &lt;var&gt;branch&lt;/var&gt; 은 다음과 같은 형식으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="3994e33e5e0917632f9e9de329b4a0f3ad3998af" translate="yes" xml:space="preserve">
          <source>Each &lt;var&gt;file&lt;/var&gt; has the following form:</source>
          <target state="translated">각 &lt;var&gt;file&lt;/var&gt; 의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c75857c9773e24edc3bfc44893ae2b0b910e079d" translate="yes" xml:space="preserve">
          <source>Each &lt;var&gt;function&lt;/var&gt; has the following form:</source>
          <target state="translated">각 &lt;var&gt;function&lt;/var&gt; 의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="62acae4631fd900e861a22b9b523800b0a789662" translate="yes" xml:space="preserve">
          <source>Each &lt;var&gt;line&lt;/var&gt; has the following form:</source>
          <target state="translated">각 &lt;var&gt;line&lt;/var&gt; 의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1c50fb88397b0c7346926cd4cd765575f7023e36" translate="yes" xml:space="preserve">
          <source>Each architecture defines additional constraints. These constraints are used by the compiler itself for instruction generation, as well as for &lt;code&gt;asm&lt;/code&gt; statements; therefore, some of the constraints are not particularly useful for &lt;code&gt;asm&lt;/code&gt;. Here is a summary of some of the machine-dependent constraints available on some particular machines; it includes both constraints that are useful for &lt;code&gt;asm&lt;/code&gt; and constraints that aren&amp;rsquo;t. The compiler source file mentioned in the table heading for each architecture is the definitive reference for the meanings of that architecture&amp;rsquo;s constraints.</source>
          <target state="translated">각 아키텍처는 추가 제약 조건을 정의합니다. 이러한 제약 조건은 컴파일러 자체에서 명령 생성 및 &lt;code&gt;asm&lt;/code&gt; 문에 사용됩니다. 따라서 일부 제약 조건은 특히 &lt;code&gt;asm&lt;/code&gt; 에 유용하지 않습니다 . 다음은 특정 머신에서 사용할 수있는 머신 종속 제약 사항을 요약 한 것입니다. &lt;code&gt;asm&lt;/code&gt; 에 유용한 제약과 그렇지 않은 제약을 모두 포함합니다 . 각 아키텍처의 테이블 제목에 언급 된 컴파일러 소스 파일은 해당 아키텍처 제약 조건의 의미에 대한 결정적인 참조입니다.</target>
        </trans-unit>
        <trans-unit id="9a8f7e527e362e2f465669113fa77cfedd4d35d0" translate="yes" xml:space="preserve">
          <source>Each argument to the macro appears only once in the expansion of the macro. This prevents the size of the macro expansion growing exponentially when calls to such macros are nested inside arguments of such macros.</source>
          <target state="translated">매크로에 대한 각 인수는 매크로 확장시 한 번만 나타납니다. 이렇게하면 해당 매크로에 대한 호출이 해당 매크로의 인수 안에 중첩 될 때 매크로 확장의 크기가 기하 급수적으로 커지는 것을 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76b41f32117ccc7bbc36f4b00ab7cb610cec2b62" translate="yes" xml:space="preserve">
          <source>Each argument, with the type encoding, followed by the offset (in bytes) of the argument in the list of parameters.</source>
          <target state="translated">매개 변수 목록에서 인수의 오프셋 (바이트)이 뒤에 오는 인코딩 유형의 각 인수.</target>
        </trans-unit>
        <trans-unit id="e6b2353f285a19086a3e061a5dcfed498d63a240" translate="yes" xml:space="preserve">
          <source>Each identifier is visible from where it is declared until the end of the enclosing block.</source>
          <target state="translated">각 식별자는 선언 된 위치에서 둘러싸는 블록의 끝까지 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="01e3221d2b21a8f447ed5a0ced29ddbea2cbee30" translate="yes" xml:space="preserve">
          <source>Each implementation shall include documentation that identifies all conditionally-supported constructs that it does not support (C++0x 1.4).</source>
          <target state="translated">각 구현에는 지원하지 않는 모든 조건부 지원 구문을 식별하는 문서가 포함되어야합니다 (C ++ 0x 1.4).</target>
        </trans-unit>
        <trans-unit id="701d795fb8ee42f93e3f4a253aa01935ee62e44d" translate="yes" xml:space="preserve">
          <source>Each kind of machine has a default for what &lt;code&gt;char&lt;/code&gt; should be. It is either like &lt;code&gt;unsigned char&lt;/code&gt; by default or like &lt;code&gt;signed char&lt;/code&gt; by default.</source>
          <target state="translated">각 종류의 기계에는 &lt;code&gt;char&lt;/code&gt; 의 기본값 이 있습니다. 기본적으로 &lt;code&gt;unsigned char&lt;/code&gt; 와 같 거나 기본적으로 &lt;code&gt;signed char&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="ef05478f4365f65d0ddfa7b0d492a5a495d01714" translate="yes" xml:space="preserve">
          <source>Each of the following options must be the same when building and using the precompiled header:</source>
          <target state="translated">사전 컴파일 된 헤더를 빌드하고 사용할 때 다음 옵션 각각이 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="12375fa3bc94216fddfb3082e628f5277fd37349" translate="yes" xml:space="preserve">
          <source>Each of these represents a register constraint for an individual register, from r0 to r10.</source>
          <target state="translated">이들 각각은 r0에서 r10까지의 개별 레지스터에 대한 레지스터 제약 조건을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c7c856c52d5df36a325270b79c39dbe4777d924c" translate="yes" xml:space="preserve">
          <source>Each target machine supported by GCC can have its own options&amp;mdash;for example, to allow you to compile for a particular processor variant or ABI, or to control optimizations specific to that machine. By convention, the names of machine-specific options start with &amp;lsquo;</source>
          <target state="translated">GCC가 지원하는 각 대상 시스템에는 고유 한 옵션이있을 수 있습니다. 예를 들어 특정 프로세서 변형 또는 ABI를 위해 컴파일하거나 해당 시스템에 맞는 최적화를 제어 할 수 있습니다. 일반적으로 기계 별 옵션의 이름은 '</target>
        </trans-unit>
        <trans-unit id="e1bf5c8e09d672f359406f3ca337be92c84db460" translate="yes" xml:space="preserve">
          <source>Each variable&amp;rsquo;s value is a list of directories separated by a special character, much like &lt;code&gt;PATH&lt;/code&gt;, in which to look for header files. The special character, &lt;code&gt;PATH_SEPARATOR&lt;/code&gt;, is target-dependent and determined at GCC build time. For Microsoft Windows-based targets it is a semicolon, and for almost all other targets it is a colon.</source>
          <target state="translated">각 변수의 값은 헤더 파일을 찾을 수있는 &lt;code&gt;PATH&lt;/code&gt; 와 같이 특수 문자로 구분 된 디렉토리 목록입니다 . 특수 문자 &lt;code&gt;PATH_SEPARATOR&lt;/code&gt; 는 대상에 따라 다르며 GCC 빌드시 결정됩니다. Microsoft Windows 기반 대상의 경우 세미콜론이고 거의 모든 다른 대상의 경우 콜론입니다.</target>
        </trans-unit>
        <trans-unit id="9fc7669bba8b360ced14bcd0e63ab75ab5c8df7f" translate="yes" xml:space="preserve">
          <source>Embedded statements are not allowed in constant expressions, such as the value of an enumeration constant, the width of a bit-field, or the initial value of a static variable.</source>
          <target state="translated">열거 형 상수 값, 비트 필드 너비 또는 정적 변수의 초기 값과 같은 상수 식에는 포함 문을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="948e9b48ea593e051a4153362a7090d684f2c222" translate="yes" xml:space="preserve">
          <source>Emit (do not emit) RISC-V attribute to record extra information into ELF objects. This feature requires at least binutils 2.32.</source>
          <target state="translated">추가 정보를 ELF 개체에 기록하려면 RISC-V 특성을 방출 (방출하지 않음)하십시오. 이 기능에는 최소한 binutils 2.32가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="070ac08031f3d1c435e4576ba37695a82ca0786d" translate="yes" xml:space="preserve">
          <source>Emit (do not emit) code that allows &lt;code&gt;_mcount&lt;/code&gt; to modify the calling function&amp;rsquo;s return address. When enabled, this option extends the usual &lt;code&gt;_mcount&lt;/code&gt; interface with a new &lt;var&gt;ra-address&lt;/var&gt; parameter, which has type &lt;code&gt;intptr_t *&lt;/code&gt; and is passed in register &lt;code&gt;$12&lt;/code&gt;. &lt;code&gt;_mcount&lt;/code&gt; can then modify the return address by doing both of the following:</source>
          <target state="translated">&lt;code&gt;_mcount&lt;/code&gt; 가 호출 함수의 반환 주소를 수정할 수 있도록하는 코드를 방출 (방출하지 마십시오) 합니다. 활성화되면이 옵션은 &lt;code&gt;intptr_t *&lt;/code&gt; 유형을 가지며 &lt;code&gt;$12&lt;/code&gt; 레지스터로 전달 되는 새로운 &lt;var&gt;ra-address&lt;/var&gt; 매개 변수로 일반적인 &lt;code&gt;_mcount&lt;/code&gt; 인터페이스를 확장합니다 . 그런 다음 &lt;code&gt;_mcount&lt;/code&gt; 는 다음 두 가지를 모두 수행하여 반송 주소를 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff5e30537593e35e64b6a16b2c1bdbe42c087863" translate="yes" xml:space="preserve">
          <source>Emit .gnu_attribute assembly directives to set tag/value pairs in a .gnu.attributes section that specify ABI variations in function parameters or return values.</source>
          <target state="translated">.gnu_attribute 어셈블리 지시문을 내보내 함수 매개 변수 또는 반환 값의 ABI 변형을 지정하는 .gnu.attributes 섹션에서 태그 / 값 쌍을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="20bf9a915993aa5a7a1666c72b879d8cd3f7ac3e" translate="yes" xml:space="preserve">
          <source>Emit &lt;code&gt;.stack_size&lt;/code&gt; directives for each function in the assembly output. This option defaults to off.</source>
          <target state="translated">어셈블리 출력의 각 함수에 대해 &lt;code&gt;.stack_size&lt;/code&gt; 지시문을 방출 하십시오 . 이 옵션은 기본적으로 해제되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f04fa21301da1a9e382b512bcad8e362a751619" translate="yes" xml:space="preserve">
          <source>Emit &lt;code&gt;static&lt;/code&gt; functions into the object file, even if the function is never used.</source>
          <target state="translated">함수가 절대 사용되지 않더라도 &lt;code&gt;static&lt;/code&gt; 함수를 오브젝트 파일로 방출 하십시오.</target>
        </trans-unit>
        <trans-unit id="cb38e0a4e398a1b8eae664d56e6c229db862f612" translate="yes" xml:space="preserve">
          <source>Emit &lt;var&gt;num&lt;/var&gt; NOPs before every other generated instruction.</source>
          <target state="translated">생성 된 다른 모든 명령어 전에 &lt;var&gt;num&lt;/var&gt; NOP를 방출 합니다.</target>
        </trans-unit>
        <trans-unit id="3da3562e4f5b4b2c349aec3c276d4ecf1abb3a7e" translate="yes" xml:space="preserve">
          <source>Emit DWARF unwind info as compiler generated &lt;code&gt;.eh_frame&lt;/code&gt; section instead of using GAS &lt;code&gt;.cfi_*&lt;/code&gt; directives.</source>
          <target state="translated">GAS &lt;code&gt;.cfi_*&lt;/code&gt; 지시문 을 사용하는 대신 컴파일러에서 생성 된 &lt;code&gt;.eh_frame&lt;/code&gt; 섹션 으로 DWARF 해제 정보를 방출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="661cfa361d4a5be25ea38381adeec0544f3162ba" translate="yes" xml:space="preserve">
          <source>Emit a special marker instructing &lt;code&gt;ld(1)&lt;/code&gt; not to statically link in the resulting object file, and allow &lt;code&gt;dyld(1)&lt;/code&gt; to load it in at run time instead. This is used in conjunction with the Fix-and-Continue debugging mode, where the object file in question may be recompiled and dynamically reloaded in the course of program execution, without the need to restart the program itself. Currently, Fix-and-Continue functionality is only available in conjunction with the NeXT runtime on Mac OS X 10.3 and later.</source>
          <target state="translated">결과 객체 파일에서 &lt;code&gt;ld(1)&lt;/code&gt; 가 정적으로 링크하지 않도록 지시하는 특수 마커를 생성하고 대신 &lt;code&gt;dyld(1)&lt;/code&gt; 가 런타임에로드 하도록 허용 합니다. 이는 수정 및 계속 디버깅 모드와 함께 사용되며, 프로그램 자체를 다시 시작할 필요없이 프로그램 실행 과정에서 문제의 오브젝트 파일을 다시 컴파일하고 동적으로 다시로드 할 수 있습니다. 현재 Fix-and-Continue 기능은 Mac OS X 10.3 이상에서 NeXT 런타임과 연계해서 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e8645e36e17a7945813986a8d0a71d3821820d0" translate="yes" xml:space="preserve">
          <source>Emit a warning if the current function exceeds the given frame size. Because this is a compile-time check it doesn&amp;rsquo;t need to be a real problem when the program runs. It is intended to identify functions that most probably cause a stack overflow. It is useful to be used in an environment with limited stack size e.g. the linux kernel.</source>
          <target state="translated">현재 기능이 지정된 프레임 크기를 초과하면 경고가 발생합니다. 이것은 컴파일 타임 검사이기 때문에 프로그램이 실행될 때 실제 문제가 될 필요는 없습니다. 스택 오버플로를 일으킬 가능성이있는 함수를 식별하기위한 것입니다. 스택 크기가 제한된 환경 (예 : Linux 커널)에서 사용하는 것이 유용합니다.</target>
        </trans-unit>
        <trans-unit id="e60a4bf4bc37e66d9947816b7195c8391e4776d0" translate="yes" xml:space="preserve">
          <source>Emit a warning if the function calls &lt;code&gt;alloca&lt;/code&gt; or uses dynamically-sized arrays. This is generally a bad idea with a limited stack size.</source>
          <target state="translated">함수가 &lt;code&gt;alloca&lt;/code&gt; 를 호출 하거나 동적 크기 배열을 사용 하는 경우 경고를 발생시킵니다 . 이것은 일반적으로 제한된 스택 크기로 나쁜 생각입니다.</target>
        </trans-unit>
        <trans-unit id="9b489883dd494ef67ae3146bb7729487672712a9" translate="yes" xml:space="preserve">
          <source>Emit callgraph information.</source>
          <target state="translated">콜 그래프 정보를 방출합니다.</target>
        </trans-unit>
        <trans-unit id="f2b5ec1d50c73d9342d0da2e8de77ea3e8b06bfb" translate="yes" xml:space="preserve">
          <source>Emit debug information for struct-like types only when the base name of the compilation source file matches the base name of file in which the struct is defined.</source>
          <target state="translated">컴파일 소스 파일의 기본 이름이 구조체가 정의 된 파일의 기본 이름과 일치하는 경우에만 구조체와 유사한 유형에 대한 디버그 정보를 방출하십시오.</target>
        </trans-unit>
        <trans-unit id="ea8ad7a3ce89000c68597a212e3b7e178630bf37" translate="yes" xml:space="preserve">
          <source>Emit debug information for struct-like types only when the base name of the compilation source file matches the base name of file in which the type is defined, unless the struct is a template or defined in a system header.</source>
          <target state="translated">구조체가 템플릿이거나 시스템 헤더에 정의되어 있지 않는 한 컴파일 소스 파일의 기본 이름이 형식이 정의 된 파일의 기본 이름과 일치하는 경우에만 구조체와 같은 형식에 대한 디버그 정보를 방출하십시오.</target>
        </trans-unit>
        <trans-unit id="bcf9409c139607d0741250959d86960d9d3fc823" translate="yes" xml:space="preserve">
          <source>Emit debugging information for all symbols and types.</source>
          <target state="translated">모든 심볼 및 유형에 대한 디버깅 정보를 방출합니다.</target>
        </trans-unit>
        <trans-unit id="8a7c3f8e8609e257b077878b6041fc34297f5e52" translate="yes" xml:space="preserve">
          <source>Emit debugging information for symbols that are used. For stabs debugging format, this enables</source>
          <target state="translated">사용되는 심볼에 대한 디버깅 정보를 방출합니다. 찌르기 디버깅 형식의 경우</target>
        </trans-unit>
        <trans-unit id="c7be7022731d1d4e89f739d3f084947002265870" translate="yes" xml:space="preserve">
          <source>Emit diagnostics showing where nodes in the &amp;ldquo;exploded graph&amp;rdquo; are in relation to the program source.</source>
          <target state="translated">&quot;분해 된 그래프&quot;의 노드가 프로그램 소스와 관련된 위치를 보여주는 진단을 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="b01323833aaf7728ad582d052fc8f41810ddeadf" translate="yes" xml:space="preserve">
          <source>Emit extra code to check for buffer overflows, such as stack smashing attacks. This is done by adding a guard variable to functions with vulnerable objects. This includes functions that call &lt;code&gt;alloca&lt;/code&gt;, and functions with buffers larger than 8 bytes. The guards are initialized when a function is entered and then checked when the function exits. If a guard check fails, an error message is printed and the program exits.</source>
          <target state="translated">스택 스매싱 공격과 같은 버퍼 오버플로를 확인하기 위해 추가 코드를 방출합니다. 취약한 객체가있는 함수에 보호 변수를 추가하면됩니다. 여기에는 &lt;code&gt;alloca&lt;/code&gt; 를 호출하는 함수와 8 바이트보다 큰 버퍼가있는 함수가 포함됩니다. 가드는 기능이 입력 될 때 초기화되고 기능이 종료 될 때 확인됩니다. 가드 검사에 실패하면 오류 메시지가 인쇄되고 프로그램이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="0b4704d417754dd3e2fa8536b703ca97736ecd33" translate="yes" xml:space="preserve">
          <source>Emit extra code to check for buffer overflows, such as stack smashing attacks. This is done by adding a guard variable to functions with vulnerable objects. This includes functions that call &lt;code&gt;alloca&lt;/code&gt;, and functions with buffers larger than or equal to 8 bytes. The guards are initialized when a function is entered and then checked when the function exits. If a guard check fails, an error message is printed and the program exits. Only variables that are actually allocated on the stack are considered, optimized away variables or variables allocated in registers don&amp;rsquo;t count.</source>
          <target state="translated">스택 스매싱 공격과 같은 버퍼 오버플로를 확인하기 위해 추가 코드를 내 보냅니다. 이는 취약한 개체가있는 함수에 보호 변수를 추가하여 수행됩니다. 여기에는 &lt;code&gt;alloca&lt;/code&gt; 를 호출하는 함수와 8 바이트 이상의 버퍼 가있는 함수가 포함 됩니다. 가드는 함수가 입력 될 때 초기화되고 함수가 종료 될 때 확인됩니다. 가드 검사에 실패하면 오류 메시지가 인쇄되고 프로그램이 종료됩니다. 실제로 스택에 할당 된 변수 만 고려되며 최적화 된 어웨이 변수 또는 레지스터에 할당 된 변수는 계산되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="141c4b8396ef386665e92dca002cbfbddd934501" translate="yes" xml:space="preserve">
          <source>Emit fix-it hints in a machine-parseable format, suitable for consumption by IDEs. For each fix-it, a line will be printed after the relevant diagnostic, starting with the string &amp;ldquo;fix-it:&amp;rdquo;. For example:</source>
          <target state="translated">IDE에서 사용하기에 적합한 기계 구문 분석 가능한 형식으로 수정 힌트를 방출합니다. 각 수정 사항에 대해 문자열 &quot;fix-it :&quot;로 시작하여 관련 진단 후에 행이 인쇄됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1a5a47bca88794809e7e2a3bb7e287c60614c83b" translate="yes" xml:space="preserve">
          <source>Emit function prologues only before parts of the function that need it, rather than at the top of the function. This flag is enabled by default at</source>
          <target state="translated">함수 프롤로그는 함수의 맨 위가 아니라 함수가 필요한 함수의 일부 전에 만 실행됩니다. 이 플래그는 기본적으로</target>
        </trans-unit>
        <trans-unit id="7a29575e26772eb5ddc3404ae8049245b33348e5" translate="yes" xml:space="preserve">
          <source>Emit location column information into DWARF debugging information, rather than just file and line. This option is enabled by default.</source>
          <target state="translated">위치 열 정보를 파일과 행이 아닌 DWARF 디버깅 정보로 내 보냅니다. 이 옵션은 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="669b4b85cda6e8d55a22a680d295c7c66356a584" translate="yes" xml:space="preserve">
          <source>Emit perf-like colored output for hot lines. Legend of the color scale is printed at the very beginning of the output file.</source>
          <target state="translated">핫라인을위한 성능과 같은 컬러 출력을 방출합니다. 컬러 스케일의 범례는 출력 파일의 맨 처음에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="bf88babe6e871b26c963f43a03a560a58bbbd726" translate="yes" xml:space="preserve">
          <source>Emit statistics about front-end processing at the end of the compilation. This option is supported only by the C++ front end, and the information is generally only useful to the G++ development team.</source>
          <target state="translated">컴파일 종료시 프론트 엔드 처리에 대한 통계를 방출합니다. 이 옵션은 C ++ 프론트 엔드에서만 지원되며 정보는 일반적으로 G ++ 개발 팀에게만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="986149807dd103440d26581e0c8034fe654a931b" translate="yes" xml:space="preserve">
          <source>Emit variables declared &lt;code&gt;static const&lt;/code&gt; when optimization isn&amp;rsquo;t turned on, even if the variables aren&amp;rsquo;t referenced.</source>
          <target state="translated">변수가 참조되지 않더라도 최적화가 설정되지 않은 경우 &lt;code&gt;static const&lt;/code&gt; 선언 된 변수를 방출합니다 .</target>
        </trans-unit>
        <trans-unit id="7039662b9ecdfee8f51909b1bca797f2d5646847" translate="yes" xml:space="preserve">
          <source>Empty. Empty attributes are ignored.</source>
          <target state="translated">빈. 빈 속성은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="dee5764f5fbac8ea9eadf819b59721dd60ce4b7b" translate="yes" xml:space="preserve">
          <source>En_US</source>
          <target state="translated">En_US</target>
        </trans-unit>
        <trans-unit id="20063ad9053289cecaa20ae630ed2dd758282a07" translate="yes" xml:space="preserve">
          <source>Enable</source>
          <target state="translated">Enable</target>
        </trans-unit>
        <trans-unit id="4fa0f6fb6e440f220b80c6c2d4888a44c80062d9" translate="yes" xml:space="preserve">
          <source>Enable &amp;lsquo;</source>
          <target state="translated">'사용</target>
        </trans-unit>
        <trans-unit id="e92d7b5eafccf1d9c2c8bae0da3467a97bfe43eb" translate="yes" xml:space="preserve">
          <source>Enable (disable) an optimization that pairs consecutive load or store instructions to enable load/store bonding. This option is enabled by default but only takes effect when the selected architecture is known to support bonding.</source>
          <target state="translated">로드 / 스토어 본딩을 활성화하기 위해 연속로드 또는 저장 명령어를 쌍으로하는 최적화를 활성화 (비활성화)합니다. 이 옵션은 기본적으로 활성화되어 있지만 선택한 아키텍처가 본딩을 지원하는 것으로 알려진 경우에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="a5876c1f4b70b8a6258f54ff9e4b48ce21c8e2cc" translate="yes" xml:space="preserve">
          <source>Enable (disable) frame header optimization in the o32 ABI. When using the o32 ABI, calling functions will allocate 16 bytes on the stack for the called function to write out register arguments. When enabled, this optimization will suppress the allocation of the frame header if it can be determined that it is unused.</source>
          <target state="translated">o32 ABI에서 프레임 헤더 최적화를 활성화 (비활성화)합니다. o32 ABI를 사용할 때 호출 함수는 호출 된 함수가 레지스터 인수를 기록하기 위해 스택에 16 바이트를 할당합니다. 이 최적화를 사용하면 프레임 헤더가 사용되지 않는 것으로 판별 될 수있는 경우 프레임 헤더 할당이 억제됩니다.</target>
        </trans-unit>
        <trans-unit id="69fa958a8a2e61f2783ede1c3821c1af600c12f1" translate="yes" xml:space="preserve">
          <source>Enable (disable) generation of &lt;code&gt;synci&lt;/code&gt; instructions on architectures that support it. The &lt;code&gt;synci&lt;/code&gt; instructions (if enabled) are generated when &lt;code&gt;__builtin___clear_cache&lt;/code&gt; is compiled.</source>
          <target state="translated">이를 지원하는 아키텍처 에서 &lt;code&gt;synci&lt;/code&gt; 명령 생성을 활성화 (비활성화) 합니다. &lt;code&gt;synci&lt;/code&gt; 때 지침 (활성화 된 경우) 발생 &lt;code&gt;__builtin___clear_cache&lt;/code&gt; 가 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="affa7a90abe6524cdcc085355a0cf87de25de669" translate="yes" xml:space="preserve">
          <source>Enable (disable) the use of the built-in functions that allow direct access to the Hardware Transactional Memory (HTM) instructions that were added in version 2.07 of the PowerPC ISA.</source>
          <target state="translated">PowerPC ISA 버전 2.07에 추가 된 HTM (Hardware Transactional Memory) 명령어에 직접 액세스 할 수있는 내장 기능 사용을 활성화 (비활성화)합니다.</target>
        </trans-unit>
        <trans-unit id="a9d43112761b398944fa6b8aebeadd62b27a6873" translate="yes" xml:space="preserve">
          <source>Enable (disable) use of the &lt;code&gt;%hi()&lt;/code&gt; and &lt;code&gt;%lo()&lt;/code&gt; assembler relocation operators. This option has been superseded by</source>
          <target state="translated">&lt;code&gt;%hi()&lt;/code&gt; 및 &lt;code&gt;%lo()&lt;/code&gt; 어셈블러 재배치 연산자 사용을 활성화 (비활성화)합니다 . 이 옵션은 다음으로 대체되었습니다.</target>
        </trans-unit>
        <trans-unit id="22e717c26fa88a4531e1982fba5a0708a2d39b81" translate="yes" xml:space="preserve">
          <source>Enable (disable) use of the &lt;code&gt;mad&lt;/code&gt;, &lt;code&gt;madu&lt;/code&gt; and &lt;code&gt;mul&lt;/code&gt; instructions, as provided by the R4650 ISA.</source>
          <target state="translated">R4650 ISA에서 제공 하는 &lt;code&gt;mad&lt;/code&gt; , &lt;code&gt;madu&lt;/code&gt; 및 &lt;code&gt;mul&lt;/code&gt; 명령어 사용을 활성화 (비활성화)합니다 .</target>
        </trans-unit>
        <trans-unit id="d7e0884ba3d3cc932c864d47a1ad9e75ce9d3f27" translate="yes" xml:space="preserve">
          <source>Enable (disable) use of the &lt;code&gt;madd&lt;/code&gt; and &lt;code&gt;msub&lt;/code&gt; integer instructions. The default is</source>
          <target state="translated">&lt;code&gt;madd&lt;/code&gt; 및 &lt;code&gt;msub&lt;/code&gt; 정수 명령어 사용을 활성화 (비활성화)합니다 . 디폴트는</target>
        </trans-unit>
        <trans-unit id="fb69f64525577d36a129060c4be04db4c7157197" translate="yes" xml:space="preserve">
          <source>Enable (disable) use of the floating-point multiply-accumulate instructions, when they are available. The default is</source>
          <target state="translated">사용 가능한 경우 부동 소수점 곱셈 누적 명령어 사용을 활성화 (비활성화)합니다. 디폴트는</target>
        </trans-unit>
        <trans-unit id="b555e3f0b555bfa87127103aa19a5b771c06eb1e" translate="yes" xml:space="preserve">
          <source>Enable 32-bit Floating point Matrix Multiply instructions. This also enables SVE instructions. Use of this option with architectures prior to Armv8.2-A is not supported.</source>
          <target state="translated">32 비트 부동 소수점 행렬 곱하기 명령어를 활성화합니다. 이것은 또한 SVE 명령어를 활성화합니다. Armv8.2-A 이전 아키텍처에서는이 옵션을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a72dea94649019bb860dd9ef3c4021f60f45fa32" translate="yes" xml:space="preserve">
          <source>Enable 64-bit AIX ABI and calling convention: 64-bit pointers, 64-bit &lt;code&gt;long&lt;/code&gt; type, and the infrastructure needed to support them. Specifying</source>
          <target state="translated">64 비트 AIX ABI 및 호출 규칙 : 64 비트 포인터, 64 비트 &lt;code&gt;long&lt;/code&gt; 유형 및이를 지원하는 데 필요한 인프라를 사용하십시오. 지정</target>
        </trans-unit>
        <trans-unit id="7b3c726da78dba7ee2a5726b767895d7cdc32731" translate="yes" xml:space="preserve">
          <source>Enable 64-bit Floating point Matrix Multiply instructions. This also enables SVE instructions. Use of this option with architectures prior to Armv8.2-A is not supported.</source>
          <target state="translated">64 비트 부동 소수점 행렬 곱하기 명령어를 활성화합니다. 이것은 또한 SVE 명령어를 활성화합니다. Armv8.2-A 이전 아키텍처에서는이 옵션을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6ded79f10cf70cf5831bdeffd10c676f4e368113" translate="yes" xml:space="preserve">
          <source>Enable 8-bit Integer Matrix Multiply instructions. This also enables Advanced SIMD and floating-point instructions. This option is enabled by default for</source>
          <target state="translated">8 비트 정수 행렬 곱하기 명령어를 활성화합니다. 또한 고급 SIMD 및 부동 소수점 명령어를 사용할 수 있습니다. 이 옵션은 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8bed769cd5303c03eac96915f98c0018f45868e" translate="yes" xml:space="preserve">
          <source>Enable &lt;code&gt;div&lt;/code&gt; and &lt;code&gt;rem&lt;/code&gt; instructions for ARCv2 cores.</source>
          <target state="translated">ARCv2 코어에 &lt;code&gt;div&lt;/code&gt; 및 &lt;code&gt;rem&lt;/code&gt; 명령어를 활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="2b739befdde9d37b726baa741659e214041a11f0" translate="yes" xml:space="preserve">
          <source>Enable AddressSanitizer for Linux kernel. See &lt;a href=&quot;https://github.com/google/kasan/wiki&quot;&gt;https://github.com/google/kasan/wiki&lt;/a&gt; for more details.</source>
          <target state="translated">Linux 커널 용 AddressSanitizer를 사용하십시오. 자세한 내용은 &lt;a href=&quot;https://github.com/google/kasan/wiki&quot;&gt;https://github.com/google/kasan/wiki&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="dd5750bb548742f5f6797880a8c614d311fe2963" translate="yes" xml:space="preserve">
          <source>Enable AddressSanitizer, a fast memory error detector. Memory access instructions are instrumented to detect out-of-bounds and use-after-free bugs. The option enables</source>
          <target state="translated">빠른 메모리 오류 감지기 인 AddressSanitizer를 활성화하십시오. 메모리 액세스 명령어는 범위를 벗어난 버그와 사용 후 버그를 감지하도록 설계되었습니다. 이 옵션은</target>
        </trans-unit>
        <trans-unit id="b884f9df2c0fdf875f501de19eb4a43163aded4e" translate="yes" xml:space="preserve">
          <source>Enable Advanced SIMD instructions. This also enables floating-point instructions. This is on by default for all possible values for options</source>
          <target state="translated">고급 SIMD 지침을 활성화하십시오. 또한 부동 소수점 명령어도 활성화합니다. 옵션의 모든 가능한 값에 대해서는 기본적으로 켜져 있습니다.</target>
        </trans-unit>
        <trans-unit id="1737ee87e4af9d47c80e040e08ffbf40c4cf4499" translate="yes" xml:space="preserve">
          <source>Enable C-SKY DSP, Enhanced DSP, or Vector DSP instructions, respectively. All of these options default to off.</source>
          <target state="translated">C-SKY DSP, Enhanced DSP 또는 Vector DSP 명령어를 각각 활성화하십시오. 이러한 모든 옵션은 기본적으로 해제되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="460dd2625e669a6da5fd8971a359142b70341354" translate="yes" xml:space="preserve">
          <source>Enable C-SKY security instructions; the default is off.</source>
          <target state="translated">C-SKY 보안 지침을 활성화하십시오. 기본값은 꺼져 있습니다.</target>
        </trans-unit>
        <trans-unit id="be1993c993457eac4e123ff5ca8683dff8eb6707" translate="yes" xml:space="preserve">
          <source>Enable C-SKY trust instructions; the default is off.</source>
          <target state="translated">C-SKY 신뢰 지침을 활성화합니다. 기본값은 꺼져 있습니다.</target>
        </trans-unit>
        <trans-unit id="db19cd91956a3cc7c7ec589751c003754ab24a04" translate="yes" xml:space="preserve">
          <source>Enable CFG-sensitive rematerialization in LRA. Instead of loading values of spilled pseudos, LRA tries to rematerialize (recalculate) values if it is profitable.</source>
          <target state="translated">LRA에서 CFG에 민감한 rematerialization을 활성화하십시오. 유출 된 유사 값을로드하는 대신 LRA는 수익성이있는 경우 값을 다시 구체화 (재 계산)하려고합니다.</target>
        </trans-unit>
        <trans-unit id="3228c63b76a89731a999face742dbc8e98e43fb7" translate="yes" xml:space="preserve">
          <source>Enable CRC extension. This is on by default for</source>
          <target state="translated">CRC 확장을 활성화하십시오. 이것은 기본적으로 켜져 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f57bb69abaacf2d80f6a8ad9ba44e14d8d03b75" translate="yes" xml:space="preserve">
          <source>Enable CRIS-specific verbose debug-related information in the assembly code. This option also has the effect of turning off the &amp;lsquo;</source>
          <target state="translated">어셈블리 코드에서 CRIS 관련 상세 디버그 관련 정보를 활성화하십시오. 이 옵션은 또한 '</target>
        </trans-unit>
        <trans-unit id="a77b829448e4eeb6288384fb17669c5c039a4b5e" translate="yes" xml:space="preserve">
          <source>Enable Crypto extension. This also enables Advanced SIMD and floating-point instructions.</source>
          <target state="translated">암호화 확장을 활성화합니다. 또한 고급 SIMD 및 부동 소수점 명령어도 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="c34f6f6c7e11aa9f0332985736de3e72e193f5ba" translate="yes" xml:space="preserve">
          <source>Enable FP16 extension. This also enables floating-point instructions.</source>
          <target state="translated">FP16 확장을 활성화하십시오. 또한 부동 소수점 명령어도 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="2babb7d5abaf4060eeca52d7ae4316df315816d6" translate="yes" xml:space="preserve">
          <source>Enable FP16 fmla extension. This also enables FP16 extensions and floating-point instructions. This option is enabled by default for</source>
          <target state="translated">FP16 fmla 확장을 활성화하십시오. 또한 FP16 확장 및 부동 소수점 명령어를 사용할 수 있습니다. 이 옵션은 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a8ba9a41b704d15493ebc76a0b1f017540a81f2" translate="yes" xml:space="preserve">
          <source>Enable IPA pass &lt;var&gt;pass&lt;/var&gt;. &lt;var&gt;pass&lt;/var&gt; is the pass name. If the same pass is statically invoked in the compiler multiple times, the pass name should be appended with a sequential number starting from 1.</source>
          <target state="translated">IPA 패스 &lt;var&gt;pass&lt;/var&gt; 활성화합니다 . &lt;var&gt;pass&lt;/var&gt; 는 패스 이름입니다. 동일한 패스가 컴파일러에서 정적으로 여러 번 호출되면 패스 이름에 1부터 시작하는 순차적 번호가 추가되어야합니다.</target>
        </trans-unit>
        <trans-unit id="17d5ca6696a8cdc79b6dc05a7cd14c4945472844" translate="yes" xml:space="preserve">
          <source>Enable Large System Extension instructions. This is on by default for</source>
          <target state="translated">대형 시스템 확장 지시 사항을 사용하십시오. 이것은 기본적으로 켜져 있습니다.</target>
        </trans-unit>
        <trans-unit id="5313db34f510b6a28a51ef561341a7742309082f" translate="yes" xml:space="preserve">
          <source>Enable LeakSanitizer, a memory leak detector. This option only matters for linking of executables and the executable is linked against a library that overrides &lt;code&gt;malloc&lt;/code&gt; and other allocator functions. See &lt;a href=&quot;https://github.com/google/sanitizers/wiki/AddressSanitizerLeakSanitizer&quot;&gt;https://github.com/google/sanitizers/wiki/AddressSanitizerLeakSanitizer&lt;/a&gt; for more details. The run-time behavior can be influenced using the &lt;code&gt;LSAN_OPTIONS&lt;/code&gt; environment variable. The option cannot be combined with</source>
          <target state="translated">메모리 누출 감지기 인 LeakSanitizer를 활성화하십시오. 이 옵션은 실행 파일의 링크에만 중요하며 실행 파일은 &lt;code&gt;malloc&lt;/code&gt; 및 기타 할당 자 기능 을 대체하는 라이브러리에 연결 됩니다. 자세한 내용은 &lt;a href=&quot;https://github.com/google/sanitizers/wiki/AddressSanitizerLeakSanitizer&quot;&gt;https://github.com/google/sanitizers/wiki/AddressSanitizerLeakSanitizer&lt;/a&gt; 를 참조하십시오. &lt;code&gt;LSAN_OPTIONS&lt;/code&gt; 환경 변수를 사용하여 런타임 동작에 영향을 줄 수 있습니다 . 이 옵션은</target>
        </trans-unit>
        <trans-unit id="963f7996b716be1c17df5a79ae31f2f9bb23a517" translate="yes" xml:space="preserve">
          <source>Enable Local Register Allocation. This is still experimental for ARC, so by default the compiler uses standard reload (i.e.</source>
          <target state="translated">로컬 레지스터 할당을 활성화합니다. 이것은 여전히 ​​ARC 실험 중이므로 기본적으로 컴파일러는 표준 재로드를 사용합니다 (예 :</target>
        </trans-unit>
        <trans-unit id="3bd13a89a3ec768d816679409bb63a5907cc342b" translate="yes" xml:space="preserve">
          <source>Enable Local Register Allocation. This is still experimental for FT32, so by default the compiler uses standard reload.</source>
          <target state="translated">로컬 레지스터 할당을 활성화합니다. 이것은 여전히 ​​FT32에서 실험 중이므로 기본적으로 컴파일러는 표준 재로드를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7fa9e4dd118db6c43acdd9765995f0465281818a" translate="yes" xml:space="preserve">
          <source>Enable Local Register Allocation. This is the default for SPARC since GCC 7 so</source>
          <target state="translated">로컬 레지스터 할당을 활성화합니다. 이것이 GCC 7 이후 SPARC의 기본값이므로</target>
        </trans-unit>
        <trans-unit id="89bbfd96b1406df4e9daca603ac86b980c364e5c" translate="yes" xml:space="preserve">
          <source>Enable RTL pass &lt;var&gt;pass&lt;/var&gt;. See</source>
          <target state="translated">RTL 패스 &lt;var&gt;pass&lt;/var&gt; 활성화합니다 . 보다</target>
        </trans-unit>
        <trans-unit id="f44412802c3209f5d9e4e5d01f1b31cdf41ef7c0" translate="yes" xml:space="preserve">
          <source>Enable Round Double Multiply Accumulate instructions. This is on by default for</source>
          <target state="translated">Round Double Multiply Accumulate 명령어를 활성화합니다. 이것은 기본적으로 켜져 있습니다.</target>
        </trans-unit>
        <trans-unit id="d370af9affe58a56b9b5454d4d92570e141e8b8f" translate="yes" xml:space="preserve">
          <source>Enable SVE2 aes instructions. This also enables SVE2 instructions.</source>
          <target state="translated">SVE2 aes 지침을 활성화합니다. 이것은 또한 SVE2 명령어를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="c3f75e37c4e4e45b9963ff233f2e2820dcfb4fb8" translate="yes" xml:space="preserve">
          <source>Enable SVE2 bitperm instructions. This also enables SVE2 instructions.</source>
          <target state="translated">SVE2 bitperm 명령을 활성화합니다. 이것은 또한 SVE2 명령어를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="2bbf22cee4e50726f4cae0a5e266998649407231" translate="yes" xml:space="preserve">
          <source>Enable SVE2 sha3 instructions. This also enables SVE2 instructions.</source>
          <target state="translated">SVE2 sha3 지침을 활성화합니다. 이것은 또한 SVE2 명령어를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="2c7cde27311588c6804e4c9ac9068d7a4af84b22" translate="yes" xml:space="preserve">
          <source>Enable SVE2 sm4 instructions. This also enables SVE2 instructions.</source>
          <target state="translated">SVE2 sm4 지침을 활성화합니다. 이것은 또한 SVE2 명령어를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="1332af3411aa268a3ef4a1b41bc0ae5d1edc2594" translate="yes" xml:space="preserve">
          <source>Enable Scalable Vector Extension instructions. This also enables Advanced SIMD and floating-point instructions.</source>
          <target state="translated">Scalable Vector Extension 지침을 활성화합니다. 또한 고급 SIMD 및 부동 소수점 명령어도 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="082f6e4a45595d5f7a3a2a560115400fb4ee2b89" translate="yes" xml:space="preserve">
          <source>Enable ThreadSanitizer, a fast data race detector. Memory access instructions are instrumented to detect data race bugs. See &lt;a href=&quot;https://github.com/google/sanitizers/wiki#threadsanitizer&quot;&gt;https://github.com/google/sanitizers/wiki#threadsanitizer&lt;/a&gt; for more details. The run-time behavior can be influenced using the &lt;code&gt;TSAN_OPTIONS&lt;/code&gt; environment variable; see &lt;a href=&quot;https://github.com/google/sanitizers/wiki/ThreadSanitizerFlags&quot;&gt;https://github.com/google/sanitizers/wiki/ThreadSanitizerFlags&lt;/a&gt; for a list of supported options. The option cannot be combined with</source>
          <target state="translated">빠른 데이터 레이스 탐지기 인 ThreadSanitizer를 활성화합니다. 메모리 액세스 명령은 데이터 레이스 버그를 감지하도록 설계되었습니다. 자세한 내용은 &lt;a href=&quot;https://github.com/google/sanitizers/wiki#threadsanitizer&quot;&gt;https://github.com/google/sanitizers/wiki#threadsanitizer&lt;/a&gt; 를 참조하십시오. 런타임 동작은 &lt;code&gt;TSAN_OPTIONS&lt;/code&gt; 환경 변수를 사용하여 영향을받을 수 있습니다 . 지원되는 옵션 목록 은 &lt;a href=&quot;https://github.com/google/sanitizers/wiki/ThreadSanitizerFlags&quot;&gt;https://github.com/google/sanitizers/wiki/ThreadSanitizerFlags&lt;/a&gt; 를 참조 하십시오 . 이 옵션은</target>
        </trans-unit>
        <trans-unit id="949a1a6c2112a203d7294b63f617d43e64b4229c" translate="yes" xml:space="preserve">
          <source>Enable UndefinedBehaviorSanitizer, a fast undefined behavior detector. Various computations are instrumented to detect undefined behavior at runtime. Current suboptions are:</source>
          <target state="translated">빠른 정의되지 않은 동작 탐지기 인 UndefinedBehaviorSanitizer를 활성화합니다. 런타임시 정의되지 않은 동작을 감지하기 위해 다양한 계산이 수행됩니다. 현재 하위 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="96f5c056cf8c5a806da05ed8b96789bc0b6d048b" translate="yes" xml:space="preserve">
          <source>Enable all estimate instructions.</source>
          <target state="translated">모든 추정 지침을 활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="df3c7c5cb30d8d0e87829e7d5c48c82259c25cb7" translate="yes" xml:space="preserve">
          <source>Enable all language-specific dumps.</source>
          <target state="translated">모든 언어 별 덤프를 활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="ae518ed7bc949ae822d65bcaeff9c7041fb826a6" translate="yes" xml:space="preserve">
          <source>Enable allocation of values to registers that are clobbered by function calls, by emitting extra instructions to save and restore the registers around such calls. Such allocation is done only when it seems to result in better code.</source>
          <target state="translated">이러한 호출 주위에 레지스터를 저장 및 복원하기위한 추가 명령을 생성하여 함수 호출에 의해 방해되는 레지스터에 값을 할당 할 수 있습니다. 이러한 할당은 더 나은 코드를 얻는 것처럼 보일 때만 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="0a0fd86a97f36ba3d21ddbe6e9254e7a16fbfe18" translate="yes" xml:space="preserve">
          <source>Enable and control dumping of pass statistics in a separate file. The file name is generated by appending a suffix ending in &amp;lsquo;</source>
          <target state="translated">별도의 파일에서 통과 통계 덤프를 활성화하고 제어합니다. 파일 이름은 '로 끝나는 접미사를 추가하여 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="f6804494e75f7aaede40247da0a4be9cdb7a84eb" translate="yes" xml:space="preserve">
          <source>Enable asan allocas/VLAs protection.</source>
          <target state="translated">asan allocas / VLAs 보호를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="61fd83dce0b4c24f54b3d95d0aba14e424d6bcbf" translate="yes" xml:space="preserve">
          <source>Enable automatic template instantiation at link time. This option also implies</source>
          <target state="translated">링크 타임에 자동 템플릿 인스턴스화를 활성화합니다. 이 옵션은 또한</target>
        </trans-unit>
        <trans-unit id="803437b7c125524ce44c25382c66dec8a107376e" translate="yes" xml:space="preserve">
          <source>Enable barrel-shift instructions.</source>
          <target state="translated">배럴 시프트 명령을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="dd1a569881fabce4df110c82ea43f4ea0973b717" translate="yes" xml:space="preserve">
          <source>Enable bbit peephole2.</source>
          <target state="translated">bbit peephole2를 활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="180b32141a3f8a46f27f030b1d9db7ce44e7c46b" translate="yes" xml:space="preserve">
          <source>Enable brain half-precision floating-point instructions. This also enables Advanced SIMD and floating-point instructions. This option is enabled by default for</source>
          <target state="translated">두뇌 반 정밀도 부동 소수점 명령어를 사용합니다. 또한 고급 SIMD 및 부동 소수점 명령어를 사용할 수 있습니다. 이 옵션은 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e317e7bf07e0ef1d8933e0c682ab5ffc4c86dfe" translate="yes" xml:space="preserve">
          <source>Enable buffer overflow detection for global objects. This kind of protection is enabled by default if you are using</source>
          <target state="translated">글로벌 오브젝트에 버퍼 오버 플로우 감지를 사용하십시오. 이러한 종류의 보호는 사용하는 경우 기본적으로 활성화됩니다</target>
        </trans-unit>
        <trans-unit id="0ff2936ea712569b3e61003e75e4a3a94ca881aa" translate="yes" xml:space="preserve">
          <source>Enable buffer overflow detection for memory reads. This kind of protection is enabled by default when using</source>
          <target state="translated">메모리 읽기에 버퍼 오버 플로우 감지를 사용하십시오. 이러한 종류의 보호는 사용할 때 기본적으로 활성화됩니다</target>
        </trans-unit>
        <trans-unit id="c11c559ccc97fad4b1acec42a5bfc66eb0c4fd61" translate="yes" xml:space="preserve">
          <source>Enable buffer overflow detection for memory writes. This kind of protection is enabled by default when using</source>
          <target state="translated">메모리 쓰기에 버퍼 오버 플로우 감지를 사용하십시오. 이러한 종류의 보호는 사용할 때 기본적으로 활성화됩니다</target>
        </trans-unit>
        <trans-unit id="c2ab49f5ce7f3d41ded69401c310972e445af621" translate="yes" xml:space="preserve">
          <source>Enable buffer overflow detection for stack objects. This kind of protection is enabled by default when using</source>
          <target state="translated">스택 객체에 대한 버퍼 오버플로 감지를 활성화합니다. 이러한 종류의 보호는 사용할 때 기본적으로 활성화됩니다</target>
        </trans-unit>
        <trans-unit id="bcd2fc731b6ca5ce8904f8dd2548970ab5fbc93a" translate="yes" xml:space="preserve">
          <source>Enable cache bypass for volatile references.</source>
          <target state="translated">휘발성 참조에 대해 캐시 바이 패스를 활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="dc4973bdf3e5300316096cd00a6ec0877e4070c6" translate="yes" xml:space="preserve">
          <source>Enable code density instructions for ARC EM. This option is on by default for ARC HS.</source>
          <target state="translated">ARC EM에 대한 코드 밀도 명령어를 활성화합니다. 이 옵션은 ARC HS에 기본적으로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f26f87d795cdafd882a37f7cf6106b44c65db50" translate="yes" xml:space="preserve">
          <source>Enable code instrumentation of control-flow transfers to increase program security by checking that target addresses of control-flow transfer instructions (such as indirect function call, function return, indirect jump) are valid. This prevents diverting the flow of control to an unexpected target. This is intended to protect against such threats as Return-oriented Programming (ROP), and similarly call/jmp-oriented programming (COP/JOP).</source>
          <target state="translated">제어 흐름 전송의 코드 계측을 사용하여 제어 흐름 전송 명령의 대상 주소 (예 : 간접 함수 호출, 함수 반환, 간접 점프)가 유효한지 확인하여 프로그램 보안을 강화하십시오. 이렇게하면 제어 흐름이 예기치 않은 대상으로 전환되는 것을 방지 할 수 있습니다. 이는 ROP (Return-Oriented Programming) 및 COP / JOP (Call / Jmp-Oriented Programming)와 같은 위협으로부터 보호하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="b04ea9a65f69d1ed270cd68689d1e12352618b80" translate="yes" xml:space="preserve">
          <source>Enable compact &lt;code&gt;casesi&lt;/code&gt; pattern. This is the default for</source>
          <target state="translated">컴팩트 한 &lt;code&gt;casesi&lt;/code&gt; 패턴을 활성화합니다 . 이것이 기본값입니다</target>
        </trans-unit>
        <trans-unit id="0c57839724a2712f31a1af12f90ff1f615581733" translate="yes" xml:space="preserve">
          <source>Enable constructor/destructor feature.</source>
          <target state="translated">생성자 / 소멸자 기능을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="975ccca01950f97ce533ac489aa7f20116354de0" translate="yes" xml:space="preserve">
          <source>Enable coprocessor instructions; the default is off.</source>
          <target state="translated">보조 프로세서 명령어를 활성화합니다. 기본값은 꺼져 있습니다.</target>
        </trans-unit>
        <trans-unit id="133e4f830a510ad1f945a9a4b1965c6cdd0bf2e0" translate="yes" xml:space="preserve">
          <source>Enable coverage-guided fuzzing code instrumentation. Inserts a call to &lt;code&gt;__sanitizer_cov_trace_pc&lt;/code&gt; into every basic block.</source>
          <target state="translated">적용 범위 안내 퍼지 코드 계측을 활성화합니다. &lt;code&gt;__sanitizer_cov_trace_pc&lt;/code&gt; 에 대한 호출을 모든 기본 블록에 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="787d37d09881b29ce95c34e07e7021e04de78815" translate="yes" xml:space="preserve">
          <source>Enable dataflow guided fuzzing code instrumentation. Inserts a call to &lt;code&gt;__sanitizer_cov_trace_cmp1&lt;/code&gt;, &lt;code&gt;__sanitizer_cov_trace_cmp2&lt;/code&gt;, &lt;code&gt;__sanitizer_cov_trace_cmp4&lt;/code&gt; or &lt;code&gt;__sanitizer_cov_trace_cmp8&lt;/code&gt; for integral comparison with both operands variable or &lt;code&gt;__sanitizer_cov_trace_const_cmp1&lt;/code&gt;, &lt;code&gt;__sanitizer_cov_trace_const_cmp2&lt;/code&gt;, &lt;code&gt;__sanitizer_cov_trace_const_cmp4&lt;/code&gt; or &lt;code&gt;__sanitizer_cov_trace_const_cmp8&lt;/code&gt; for integral comparison with one operand constant, &lt;code&gt;__sanitizer_cov_trace_cmpf&lt;/code&gt; or &lt;code&gt;__sanitizer_cov_trace_cmpd&lt;/code&gt; for float or double comparisons and &lt;code&gt;__sanitizer_cov_trace_switch&lt;/code&gt; for switch statements.</source>
          <target state="translated">데이터 흐름 안내 퍼징 코드 계측을 활성화합니다. 삽입물 호출 &lt;code&gt;__sanitizer_cov_trace_cmp1&lt;/code&gt; , &lt;code&gt;__sanitizer_cov_trace_cmp2&lt;/code&gt; , &lt;code&gt;__sanitizer_cov_trace_cmp4&lt;/code&gt; 또는 &lt;code&gt;__sanitizer_cov_trace_cmp8&lt;/code&gt; 피연산자 변수 또는 둘다와 일체 비교 &lt;code&gt;__sanitizer_cov_trace_const_cmp1&lt;/code&gt; , &lt;code&gt;__sanitizer_cov_trace_const_cmp2&lt;/code&gt; , &lt;code&gt;__sanitizer_cov_trace_const_cmp4&lt;/code&gt; 또는 &lt;code&gt;__sanitizer_cov_trace_const_cmp8&lt;/code&gt; 하나의 피연산자 상수 일체 비교를 &lt;code&gt;__sanitizer_cov_trace_cmpf&lt;/code&gt; 또는 &lt;code&gt;__sanitizer_cov_trace_cmpd&lt;/code&gt; 플로트 또는 더블 및 비교 용 &lt;code&gt;__sanitizer_cov_trace_switch&lt;/code&gt; 스위치 문.</target>
        </trans-unit>
        <trans-unit id="1af777f40a3150cb8ba378da9ca8aedaaf114176" translate="yes" xml:space="preserve">
          <source>Enable deduction of a template type parameter as &lt;code&gt;std::initializer_list&lt;/code&gt; from a brace-enclosed initializer list, i.e.</source>
          <target state="translated">중괄호로 묶인 이니셜 라이저 목록에서 &lt;code&gt;std::initializer_list&lt;/code&gt; 로 템플리트 유형 매개 변수를 추론 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="699beaa366dd56ec35a2702d45f2103e1f67c4dc" translate="yes" xml:space="preserve">
          <source>Enable detection for built-in functions. This kind of protection is enabled by default when using</source>
          <target state="translated">내장 기능을 감지 할 수 있습니다. 이러한 종류의 보호는 사용할 때 기본적으로 활성화됩니다</target>
        </trans-unit>
        <trans-unit id="d53fecd502038ea015d9795c95247289bc1d17ab" translate="yes" xml:space="preserve">
          <source>Enable detection of use-after-return. This kind of protection is enabled by default when using the</source>
          <target state="translated">반환 후 사용 감지를 활성화합니다. 이러한 종류의 보호는 기본적으로</target>
        </trans-unit>
        <trans-unit id="22325b2d023fcd4619a9818a760c689af219e959" translate="yes" xml:space="preserve">
          <source>Enable divide and modulus instructions.</source>
          <target state="translated">나누기 및 모듈러스 명령어를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="6860f8ad3c912d9de1bc957db83ae37ff4acd2f1" translate="yes" xml:space="preserve">
          <source>Enable double load/store operations for ARC HS cores.</source>
          <target state="translated">ARC HS 코어에 대한 이중로드 / 저장 작업을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="f30747b51f35d511a8324038d0ec742af8852f12" translate="yes" xml:space="preserve">
          <source>Enable dumping various statistics about the pass (not honored by every dump option).</source>
          <target state="translated">패스에 대한 다양한 통계를 덤프 할 수 있습니다 (모든 덤프 옵션이 준수하지는 않음).</target>
        </trans-unit>
        <trans-unit id="e61159e5abc9e858d3e7dc68248bef77e7e66569" translate="yes" xml:space="preserve">
          <source>Enable dumps from all OMP (Offloading and Multi Processing) optimizations.</source>
          <target state="translated">모든 OMP (Offloading and Multi Processing) 최적화에서 덤프를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="126e933efdf810fc684f2a27ed78c7f4a97f9db5" translate="yes" xml:space="preserve">
          <source>Enable dumps from all inlining optimizations.</source>
          <target state="translated">모든 인라인 최적화에서 덤프를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="d0c94685fdabc0e86d42873897a8642d64c915a0" translate="yes" xml:space="preserve">
          <source>Enable dumps from all interprocedural optimizations.</source>
          <target state="translated">모든 절차 적 최적화에서 덤프를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="f4a495e6ab007e96555960123af4b2e049e343cb" translate="yes" xml:space="preserve">
          <source>Enable dumps from all loop optimizations.</source>
          <target state="translated">모든 루프 최적화에서 덤프를 활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="da404a0e7964dc17445f8eab1557032d44193e2a" translate="yes" xml:space="preserve">
          <source>Enable dumps from all optimizations. This is a superset of the optimization groups listed above.</source>
          <target state="translated">모든 최적화에서 덤프를 사용하십시오. 이것은 위에 나열된 최적화 그룹의 상위 집합입니다.</target>
        </trans-unit>
        <trans-unit id="82fd093708bd37548045d3e8dc300297a204bb93" translate="yes" xml:space="preserve">
          <source>Enable dumps from all vectorization optimizations.</source>
          <target state="translated">모든 벡터화 최적화에서 덤프를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1ca26bbd13d508b47dfc0ff9aedfd700309873f0" translate="yes" xml:space="preserve">
          <source>Enable emission of special debug stores within HSA kernels which are then read and reported by libgomp plugin. Generation of these stores is disabled by default, use</source>
          <target state="translated">HSA 커널 내에서 특수 디버그 저장소를 생성 한 다음 libgomp 플러그인에서 읽고보고합니다. 이 상점의 생성은 기본적으로 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="92b0248c8870fe4857fc02d723bd02f0d5d911ee" translate="yes" xml:space="preserve">
          <source>Enable exception handling. Generates extra code needed to propagate exceptions. For some targets, this implies GCC generates frame unwind information for all functions, which can produce significant data size overhead, although it does not affect execution. If you do not specify this option, GCC enables it by default for languages like C++ that normally require exception handling, and disables it for languages like C that do not normally require it. However, you may need to enable this option when compiling C code that needs to interoperate properly with exception handlers written in C++. You may also wish to disable this option if you are compiling older C++ programs that don&amp;rsquo;t use exception handling.</source>
          <target state="translated">예외 처리를 활성화하십시오. 예외를 전파하는 데 필요한 추가 코드를 생성합니다. 일부 대상의 경우 GCC가 모든 기능에 대해 프레임 해제 정보를 생성하므로 실행에 영향을 미치지 않지만 상당한 데이터 크기 오버 헤드가 발생할 수 있습니다. 이 옵션을 지정하지 않으면 GCC는 일반적으로 예외 처리가 필요한 C ++와 같은 언어에 대해 기본적으로이 기능을 활성화하고 일반적으로 필요하지 않은 C와 같은 언어에 대해서는 비활성화합니다. 그러나 C ++로 작성된 예외 핸들러와 올바르게 상호 운용해야하는 C 코드를 컴파일 할 때이 옵션을 사용해야합니다. 예외 처리를 사용하지 않는 구형 C ++ 프로그램을 컴파일하는 경우이 옵션을 비활성화 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="291b92d09ee9fff716f8b0be8063487213868bdd" translate="yes" xml:space="preserve">
          <source>Enable floating-point instructions. This is on by default for all possible values for options</source>
          <target state="translated">부동 소수점 명령어를 활성화합니다. 옵션의 모든 가능한 값에 대해서는 기본적으로 켜져 있습니다.</target>
        </trans-unit>
        <trans-unit id="39904b8795d477fdb077dab2b449e06a2b1bd74a" translate="yes" xml:space="preserve">
          <source>Enable garbage collection (GC) in Objective-C and Objective-C++ programs. This option is only available with the NeXT runtime; the GNU runtime has a different garbage collection implementation that does not require special compiler flags.</source>
          <target state="translated">Objective-C 및 Objective-C ++ 프로그램에서 가비지 콜렉션 (GC)을 사용하십시오. 이 옵션은 NeXT 런타임에서만 사용할 수 있습니다. GNU 런타임에는 특별한 컴파일러 플래그가 필요하지 않은 다른 가비지 콜렉션 구현이 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb9fbffb72277aaa3548891dbb1b3b1153391a9e" translate="yes" xml:space="preserve">
          <source>Enable generation of ARC SIMD instructions via target-specific builtins. Only valid for</source>
          <target state="translated">대상별 내장을 통해 ARC SIMD 명령어를 생성 할 수 있습니다. 에 대해서만 유효</target>
        </trans-unit>
        <trans-unit id="3476de902c479834e38b15661f3b7c3cc2032cce" translate="yes" xml:space="preserve">
          <source>Enable generation of compare and set flag with immediate (&lt;code&gt;l.sf*i&lt;/code&gt;) instructions. By default extra instructions will be generated to store the immediate to a register first.</source>
          <target state="translated">즉시 ( &lt;code&gt;l.sf*i&lt;/code&gt; ) 명령어 로 비교 생성 및 플래그 설정을 활성화 합니다. 기본적으로 즉시 레지스터에 즉시 저장하기 위해 추가 명령이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="d50921b35a0d76feb95a28aea9efb5fcae7e1038" translate="yes" xml:space="preserve">
          <source>Enable generation of conditional move (&lt;code&gt;l.cmov&lt;/code&gt;) instructions. By default the equivalent will be generated using set and branch.</source>
          <target state="translated">조건부 이동 ( &lt;code&gt;l.cmov&lt;/code&gt; ) 명령 생성을 활성화 합니다. 기본적으로 등가물은 set 및 branch를 사용하여 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="64de54a950fd518ed74414f068843cdf15d9e810" translate="yes" xml:space="preserve">
          <source>Enable generation of linemarkers in the preprocessor output that let the compiler know the current working directory at the time of preprocessing. When this option is enabled, the preprocessor emits, after the initial linemarker, a second linemarker with the current working directory followed by two slashes. GCC uses this directory, when it&amp;rsquo;s present in the preprocessed input, as the directory emitted as the current working directory in some debugging information formats. This option is implicitly enabled if debugging information is enabled, but this can be inhibited with the negated form</source>
          <target state="translated">사전 처리시 컴파일러에게 현재 작업 디렉토리를 알려주는 전 처리기 출력에서 ​​라인 마커 생성을 활성화합니다. 이 옵션이 활성화되면 전처리 기는 초기 라인 마커 이후에 현재 작업 디렉토리와 두 개의 슬래시가있는 두 번째 라인 마커를 방출합니다. GCC는 사전 처리 된 입력에있을 때이 디렉토리를 일부 디버깅 정보 형식으로 현재 작업 디렉토리로 생성 한 디렉토리로 사용합니다. 이 옵션은 디버깅 정보가 활성화 된 경우 암시 적으로 활성화되지만 부정 형식으로 억제 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="588970c3346f8b21ca330055ce039842b7c95dc3" translate="yes" xml:space="preserve">
          <source>Enable generation of rotate right (&lt;code&gt;l.ror&lt;/code&gt;) instructions. By default functions from</source>
          <target state="translated">오른쪽으로 회전 ( &lt;code&gt;l.ror&lt;/code&gt; ) 명령 생성을 활성화 합니다. 기본적으로</target>
        </trans-unit>
        <trans-unit id="4410c960b2144b2a5392d7e9052119e5a2916ace" translate="yes" xml:space="preserve">
          <source>Enable generation of rotate right with immediate (&lt;code&gt;l.rori&lt;/code&gt;) instructions. By default functions from</source>
          <target state="translated">즉각적인 ( &lt;code&gt;l.rori&lt;/code&gt; ) 명령으로 오른쪽 회전 생성을 활성화 합니다. 기본적으로</target>
        </trans-unit>
        <trans-unit id="1d2f560a395cf8229af315865d428228064bb2c4" translate="yes" xml:space="preserve">
          <source>Enable generation of shift with immediate (&lt;code&gt;l.srai&lt;/code&gt;, &lt;code&gt;l.srli&lt;/code&gt;, &lt;code&gt;l.slli&lt;/code&gt;) instructions. By default extra instructions will be generated to store the immediate to a register first.</source>
          <target state="translated">즉각적인 ( &lt;code&gt;l.srai&lt;/code&gt; , &lt;code&gt;l.srli&lt;/code&gt; , &lt;code&gt;l.slli&lt;/code&gt; ) 명령어를 사용하여 시프트 생성을 활성화 합니다. 기본적으로 즉시 레지스터에 즉시 저장하기 위해 추가 명령이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="c64d914c46ba456fccc83d7a0d7c17c411a4e40e" translate="yes" xml:space="preserve">
          <source>Enable generation of sign extension (&lt;code&gt;l.ext*&lt;/code&gt;) instructions. By default memory loads are used to perform sign extension.</source>
          <target state="translated">부호 확장 ( &lt;code&gt;l.ext*&lt;/code&gt; ) 명령어 생성을 활성화 합니다. 기본적으로 메모리로드는 부호 확장을 수행하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4f6c2330300990f23059abacc5ecdfe5f1dc0281" translate="yes" xml:space="preserve">
          <source>Enable generation of unaligned load and store instructions.</source>
          <target state="translated">정렬되지 않은로드 및 저장 명령어 생성을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="d26f3d711c1a65ce5ae7ed795204b286f03213ae" translate="yes" xml:space="preserve">
          <source>Enable global interrupt.</source>
          <target state="translated">글로벌 인터럽트를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="2f452efb25c68aa75fbb01603256e25885a6060f" translate="yes" xml:space="preserve">
          <source>Enable handling of OpenACC directives &lt;code&gt;#pragma acc&lt;/code&gt; in C/C++ and &lt;code&gt;!$acc&lt;/code&gt; in Fortran. When</source>
          <target state="translated">C / C ++에서 OpenACC 지시문 &lt;code&gt;#pragma acc&lt;/code&gt; 및 Fortran에서 &lt;code&gt;!$acc&lt;/code&gt; 를 처리 할 수 ​​있습니다. 언제</target>
        </trans-unit>
        <trans-unit id="2ca92300312c8fc1987b891433bf16fbf5350717" translate="yes" xml:space="preserve">
          <source>Enable handling of OpenMP directives &lt;code&gt;#pragma omp&lt;/code&gt; in C/C++ and &lt;code&gt;!$omp&lt;/code&gt; in Fortran. When</source>
          <target state="translated">C / C ++에서 OpenMP 지시문 &lt;code&gt;#pragma omp&lt;/code&gt; 및 Fortran에서 &lt;code&gt;!$omp&lt;/code&gt; 를 처리 할 수 ​​있습니다. 언제</target>
        </trans-unit>
        <trans-unit id="f764c2e81a54602d1c0862a3fd8d88c71c27e5ef" translate="yes" xml:space="preserve">
          <source>Enable handling of OpenMP&amp;rsquo;s SIMD directives with &lt;code&gt;#pragma omp&lt;/code&gt; in C/C++ and &lt;code&gt;!$omp&lt;/code&gt; in Fortran. Other OpenMP directives are ignored.</source>
          <target state="translated">C / C ++에서 &lt;code&gt;#pragma omp&lt;/code&gt; 를 사용 하고 Fortran에서 &lt;code&gt;!$omp&lt;/code&gt; 를 사용하여 OpenMP의 SIMD 지시문을 처리 할 수 있습니다. 다른 OpenMP 지시문은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="325afe18f0a625fafbd824b05e823388581382ad" translate="yes" xml:space="preserve">
          <source>Enable inlining of PLT entries in function calls to functions that are not known to bind locally. It has no effect without</source>
          <target state="translated">로컬로 바인딩되지 않은 함수에 대한 함수 호출에서 PLT 항목 인라인을 활성화합니다. 없이는 효과가 없습니다</target>
        </trans-unit>
        <trans-unit id="26c34a078cd9b46fb0bd484cd235d46f5c53f46b" translate="yes" xml:space="preserve">
          <source>Enable internal consistency checking. The default depends on the compiler configuration.</source>
          <target state="translated">내부 일관성 검사를 활성화합니다. 기본값은 컴파일러 구성에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="b40ab07f35e9ecebed6c91979cb9c80321b2c600" translate="yes" xml:space="preserve">
          <source>Enable interrupt stack instructions; the default is off.</source>
          <target state="translated">인터럽트 스택 명령을 활성화합니다. 기본값은 꺼져 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd58b676d0e4ba40cac9f6295490ba16f891fad5" translate="yes" xml:space="preserve">
          <source>Enable kernel development mode. The</source>
          <target state="translated">커널 개발 모드를 활성화하십시오. 그만큼</target>
        </trans-unit>
        <trans-unit id="6942946c621ac80c436737b7a31ee339272c871d" translate="yes" xml:space="preserve">
          <source>Enable lazy binding of function calls. This option is equivalent to</source>
          <target state="translated">함수 호출의 지연 바인딩을 사용하십시오. 이 옵션은</target>
        </trans-unit>
        <trans-unit id="c3e68f8f7d9888cb3d2e2d66e5738f0a5b7bffcf" translate="yes" xml:space="preserve">
          <source>Enable linker relaxation. Linker relaxation is a process whereby the linker attempts to reduce the size of a program by finding shorter versions of various instructions. Disabled by default.</source>
          <target state="translated">링커 이완을 활성화하십시오. 링커 완화는 링커가 다양한 명령의 짧은 버전을 찾아서 프로그램 크기를 줄이려고하는 프로세스입니다. 기본적으로 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0765f61b18fd9b0cd981b0d3115e02320dabdb7a" translate="yes" xml:space="preserve">
          <source>Enable loop epilogue vectorization using smaller vector size.</source>
          <target state="translated">더 작은 벡터 크기를 사용하여 루프 에필로그 벡터화를 활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="04769dddbdca1dd3af29e66b89d9df24ccfdaae0" translate="yes" xml:space="preserve">
          <source>Enable more detailed dumps (not honored by every dump option). Also include information from the optimization passes.</source>
          <target state="translated">더 자세한 덤프를 활성화하십시오 (모든 덤프 옵션에서 사용하지는 않음). 최적화 단계의 정보도 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="9f3bf571af4fb133a9ed845eaa94347bdecede5e" translate="yes" xml:space="preserve">
          <source>Enable multiply instructions.</source>
          <target state="translated">곱하기 명령어를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="6bdc85b650029e698104b9394508a12676ccb6ec" translate="yes" xml:space="preserve">
          <source>Enable multiprocessor instructions; the default is off.</source>
          <target state="translated">멀티 프로세서 명령어를 활성화합니다. 기본값은 꺼져 있습니다.</target>
        </trans-unit>
        <trans-unit id="dae98acaa0a30e3960a49dff4e2a8d6c6a98eb29" translate="yes" xml:space="preserve">
          <source>Enable nested conditional execution optimizations (default).</source>
          <target state="translated">중첩 된 조건부 실행 최적화를 활성화합니다 (기본값).</target>
        </trans-unit>
        <trans-unit id="0523e9bf64ec1c9137b9f17ae48ec467d581e674" translate="yes" xml:space="preserve">
          <source>Enable optimization of &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; in conditional execution (default).</source>
          <target state="translated">&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 및 &lt;code&gt;||&lt;/code&gt; 최적화 사용 조건부 실행 (기본값)</target>
        </trans-unit>
        <trans-unit id="43cad454d19cf94092ebd0b65a6a9f9c7c63ffa9" translate="yes" xml:space="preserve">
          <source>Enable options usually used for instrumenting application to produce profile useful for later recompilation with profile feedback based optimization. You must use</source>
          <target state="translated">프로파일 피드백 기반 최적화를 통해 나중에 다시 컴파일하는 데 유용한 프로파일을 생성하기 위해 계측 응용 프로그램에 일반적으로 사용되는 옵션을 활성화합니다. 당신은 사용해야합니다</target>
        </trans-unit>
        <trans-unit id="9425982687d5465084a29222f1e8d83738debfbc" translate="yes" xml:space="preserve">
          <source>Enable or disable PC-relative literal loads. With this option literal pools are accessed using a single instruction and emitted after each function. This limits the maximum size of functions to 1MB. This is enabled by default for</source>
          <target state="translated">PC 기준 리터럴로드를 활성화 또는 비활성화합니다. 이 옵션을 사용하면 리터럴 풀이 단일 명령을 사용하여 액세스되고 각 기능 후에 생성됩니다. 최대 기능 크기를 1MB로 제한합니다. 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="37cd8da3fdbfa9f8188d860129119fec2bfd100c" translate="yes" xml:space="preserve">
          <source>Enable or disable calls to out-of-line helpers to implement atomic operations. These helpers will, at runtime, determine if the LSE instructions from ARMv8.1-A can be used; if not, they will use the load/store-exclusive instructions that are present in the base ARMv8.0 ISA.</source>
          <target state="translated">원자 적 작업을 구현하기 위해 라인 외부 도우미에 대한 호출을 활성화하거나 비활성화합니다. 이러한 도우미는 런타임에 ARMv8.1-A의 LSE 명령어를 사용할 수 있는지 여부를 결정합니다. 그렇지 않은 경우 기본 ARMv8.0 ISA에있는로드 / 저장 전용 명령어를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1a34d5bdfa8a40aec1348063e5f43f0a38a44e4b" translate="yes" xml:space="preserve">
          <source>Enable or disable calls to out-of-line helpers to implement atomic operations. This corresponds to the behavior of the command line options</source>
          <target state="translated">원자 적 작업을 구현하기 위해 라인 외부 도우미에 대한 호출을 활성화하거나 비활성화합니다. 이것은 명령 줄 옵션의 동작에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="f213f1158c65a76a7da3e44d0dfb546afeb1c37d" translate="yes" xml:space="preserve">
          <source>Enable or disable emitting &lt;code&gt;mul&lt;/code&gt;, &lt;code&gt;mulx&lt;/code&gt; and &lt;code&gt;div&lt;/code&gt; family of instructions by the compiler. The default is to emit &lt;code&gt;mul&lt;/code&gt; and not emit &lt;code&gt;div&lt;/code&gt; and &lt;code&gt;mulx&lt;/code&gt;.</source>
          <target state="translated">컴파일러가 &lt;code&gt;mul&lt;/code&gt; , &lt;code&gt;mulx&lt;/code&gt; 및 &lt;code&gt;div&lt;/code&gt; 명령을 방출 할 수 있도록 설정하거나 해제 합니다. 기본값은 &lt;code&gt;mul&lt;/code&gt; 을 방출 하고 &lt;code&gt;div&lt;/code&gt; 및 &lt;code&gt;mulx&lt;/code&gt; 를 방출하지 않는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="a0c735f45199333d31330ebeb1c39ca77bf91fab" translate="yes" xml:space="preserve">
          <source>Enable or disable generation of Nios II R2 BMX (bit manipulation) and CDX (code density) instructions. Enabling these instructions also requires</source>
          <target state="translated">Nios II R2 BMX (비트 조작) 및 CDX (코드 밀도) 명령어 생성을 활성화 또는 비활성화합니다. 이 지침을 활성화하려면</target>
        </trans-unit>
        <trans-unit id="e82224b52a26ba48a5b113f09b7fcf8cc858a9c2" translate="yes" xml:space="preserve">
          <source>Enable or disable generation of additional code to track speculative execution through conditional branches. The tracking state can then be used by the compiler when expanding calls to &lt;code&gt;__builtin_speculation_safe_copy&lt;/code&gt; to permit a more efficient code sequence to be generated.</source>
          <target state="translated">조건부 분기를 통한 추론 적 실행을 추적하기 위해 추가 코드 생성을 활성화 또는 비활성화합니다. 그런 다음 &lt;code&gt;__builtin_speculation_safe_copy&lt;/code&gt; 에 대한 호출을 확장 할 때 컴파일러가 추적 상태를 사용 하여보다 효율적인 코드 시퀀스를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8588fb4dd2a8d4f96274711c0f8a3dcffa809a3b" translate="yes" xml:space="preserve">
          <source>Enable or disable the division approximation. This option only has an effect if</source>
          <target state="translated">나누기 근사를 활성화하거나 비활성화합니다. 이 옵션은 다음과 같은 경우에만 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="da4836dd8fd423982dc5d807088aa304a1a7fb40" translate="yes" xml:space="preserve">
          <source>Enable or disable the reciprocal square root approximation. This option only has an effect if</source>
          <target state="translated">역수 제곱근 근사를 활성화 또는 비활성화합니다. 이 옵션은 다음과 같은 경우에만 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6cd2e01bcd6daa77f123d3562e525b53f2208b99" translate="yes" xml:space="preserve">
          <source>Enable or disable the square root approximation. This option only has an effect if</source>
          <target state="translated">제곱근 근사를 활성화 또는 비활성화합니다. 이 옵션은 다음과 같은 경우에만 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6d5d7b63171cb59117cb5da0b6d0ce6a7318345" translate="yes" xml:space="preserve">
          <source>Enable or disable the workaround for the ARM Cortex-A53 erratum number 835769. This involves inserting a NOP instruction between memory instructions and 64-bit integer multiply-accumulate instructions.</source>
          <target state="translated">ARM Cortex-A53 에라타 번호 835769에 대한 대안을 활성화하거나 비활성화합니다. 여기에는 메모리 명령어와 64 비트 정수 곱하기 누산 명령어 사이에 NOP 명령어 삽입이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="1b8e841a5a6d9c6fdc72f5d2c3b9462219761996" translate="yes" xml:space="preserve">
          <source>Enable or disable the workaround for the ARM Cortex-A53 erratum number 843419. This erratum workaround is made at link time and this will only pass the corresponding flag to the linker.</source>
          <target state="translated">ARM Cortex-A53 에라타 번호 843419에 대한 대안을 활성화하거나 비활성화하십시오.이 에라타 대안은 링크 타임에 이루어지며 해당 플래그 만 링커에 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="e8d2c7af76155c379ab5d5ec1df26431744e4771" translate="yes" xml:space="preserve">
          <source>Enable or disable use of &lt;code&gt;CONST16&lt;/code&gt; instructions for loading constant values. The &lt;code&gt;CONST16&lt;/code&gt; instruction is currently not a standard option from Tensilica. When enabled, &lt;code&gt;CONST16&lt;/code&gt; instructions are always used in place of the standard &lt;code&gt;L32R&lt;/code&gt; instructions. The use of &lt;code&gt;CONST16&lt;/code&gt; is enabled by default only if the &lt;code&gt;L32R&lt;/code&gt; instruction is not available.</source>
          <target state="translated">상수 값을로드하기 위해 &lt;code&gt;CONST16&lt;/code&gt; 명령어 사용을 활성화 또는 비활성화 합니다. &lt;code&gt;CONST16&lt;/code&gt; 의 명령은 현재 텐 실리카의 표준 옵션이 아닙니다. 활성화되면 &lt;code&gt;CONST16&lt;/code&gt; 명령어는 항상 표준 &lt;code&gt;L32R&lt;/code&gt; 명령어 대신 사용됩니다 . 의 사용 &lt;code&gt;CONST16&lt;/code&gt; 는 유일한 경우 기본적으로 활성화되어 &lt;code&gt;L32R&lt;/code&gt; 의 명령을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="87ea222da3a42af40a5b89fab414b5a2466d4691" translate="yes" xml:space="preserve">
          <source>Enable or disable use of Branch Likely instructions, regardless of the default for the selected architecture. By default, Branch Likely instructions may be generated if they are supported by the selected architecture. An exception is for the MIPS32 and MIPS64 architectures and processors that implement those architectures; for those, Branch Likely instructions are not be generated by default because the MIPS32 and MIPS64 architectures specifically deprecate their use.</source>
          <target state="translated">선택한 아키텍처의 기본값에 관계없이 분기 가능 명령어 사용을 활성화 또는 비활성화합니다. 기본적으로 Branch Likely 명령어는 선택한 아키텍처에서 지원되는 경우 생성 될 수 있습니다. MIPS32 및 MIPS64 아키텍처와 해당 아키텍처를 구현하는 프로세서는 예외입니다. MIPS32 및 MIPS64 아키텍처에서는 특히 사용이 중단되므로 Branch Likely 명령어는 기본적으로 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6f7c7366f13d27cab3029da7a7c328e36fbdbb28" translate="yes" xml:space="preserve">
          <source>Enable or disable use of fused multiply/add and multiply/subtract instructions in the floating-point option. This has no effect if the floating-point option is not also enabled. Disabling fused multiply/add and multiply/subtract instructions forces the compiler to use separate instructions for the multiply and add/subtract operations. This may be desirable in some cases where strict IEEE 754-compliant results are required: the fused multiply add/subtract instructions do not round the intermediate result, thereby producing results with &lt;em&gt;more&lt;/em&gt; bits of precision than specified by the IEEE standard. Disabling fused multiply add/subtract instructions also ensures that the program output is not sensitive to the compiler&amp;rsquo;s ability to combine multiply and add/subtract operations.</source>
          <target state="translated">부동 소수점 옵션에서 융합 곱셈 / 추가 및 곱하기 / 빼기 명령어 사용을 활성화 또는 비활성화합니다. 부동 소수점 옵션도 사용하지 않으면 효과가 없습니다. 융합 곱하기 / 더하기 및 곱하기 / 빼기 명령어를 비활성화하면 컴파일러는 곱하기 및 더하기 / 빼기 연산에 대해 별도의 명령어를 사용합니다. 이는 엄격한 IEEE 754 호환 결과가 필요한 일부 경우에 바람직 할 수 있습니다. 융합 곱셈 더하기 / 빼기 명령어는 중간 결과를 반올림하지 않으므로 IEEE 표준에 지정된 것보다 &lt;em&gt;더 높은&lt;/em&gt; 정밀도로 결과를 생성합니다 . 융합 곱하기 더하기 / 빼기 명령어를 비활성화하면 프로그램 출력이 곱하기와 더하기 / 빼기 연산을 결합하는 컴파일러의 능력에 민감하지 않게됩니다.</target>
        </trans-unit>
        <trans-unit id="f2d29f4186409cdd0269837c4398f5ca04568394" translate="yes" xml:space="preserve">
          <source>Enable other detailed optimization information (only available in certain passes).</source>
          <target state="translated">다른 상세 최적화 정보를 활성화하십시오 (특정 패스에서만 사용 가능).</target>
        </trans-unit>
        <trans-unit id="338cf5f95ce763c97fbfe82953390f719fbef967" translate="yes" xml:space="preserve">
          <source>Enable parsing of function definitions marked with &lt;code&gt;__GIMPLE&lt;/code&gt;. This is an experimental feature that allows unit testing of GIMPLE passes.</source>
          <target state="translated">&lt;code&gt;__GIMPLE&lt;/code&gt; 로 표시된 함수 정의 구문 분석을 사용하십시오 . 이것은 GIMPLE 패스의 단위 테스트를 허용하는 실험 기능입니다.</target>
        </trans-unit>
        <trans-unit id="f3fcc68975389b930adf047407384e4de7afa86d" translate="yes" xml:space="preserve">
          <source>Enable pre-reload use of the &lt;code&gt;cbranchsi&lt;/code&gt; pattern.</source>
          <target state="translated">&lt;code&gt;cbranchsi&lt;/code&gt; 패턴 의 사전 재로드 사용을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7aca1894ee9ae073c5e50327164b18c35adaf0e4" translate="yes" xml:space="preserve">
          <source>Enable profile feedback-directed optimizations, and the following optimizations, many of which are generally profitable only with profile feedback available:</source>
          <target state="translated">프로파일 피드백 지향 최적화 및 다음 최적화를 사용하십시오. 이러한 최적화 중 다수는 일반적으로 사용 가능한 프로파일 피드백으로 만 수익성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd16226a248d7401935b2178b12d750c5c2d817f" translate="yes" xml:space="preserve">
          <source>Enable reduced code size &lt;code&gt;printf&lt;/code&gt; and &lt;code&gt;puts&lt;/code&gt; library functions. The &amp;lsquo;</source>
          <target state="translated">축소 된 코드 크기 &lt;code&gt;printf&lt;/code&gt; 를 활성화 하고 라이브러리 함수를 &lt;code&gt;puts&lt;/code&gt; . '</target>
        </trans-unit>
        <trans-unit id="9b22143dddf716e38b0694ad2ca7a60178731d02" translate="yes" xml:space="preserve">
          <source>Enable register pressure sensitive insn scheduling before register allocation. This only makes sense when scheduling before register allocation is enabled, i.e. with</source>
          <target state="translated">레지스터 할당 전에 레지스터 압력 감지 기능을 사용하도록 설정합니다. 이것은 레지스터 할당이 활성화되기 전에 스케줄링하는 경우에만 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0432e33b5c323c92ba751b7a0171493013f8ec2" translate="yes" xml:space="preserve">
          <source>Enable sampling-based feedback-directed optimizations, and the following optimizations, many of which are generally profitable only with profile feedback available:</source>
          <target state="translated">샘플링 기반 피드백 지향 최적화 및 다음 최적화를 사용하십시오.이 중 대부분은 일반적으로 사용 가능한 프로파일 피드백으로 만 수익성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9201f89c6bef5151370e84b69891107c6c6b6ade" translate="yes" xml:space="preserve">
          <source>Enable sanitization of local variables to detect use-after-scope bugs. The option sets</source>
          <target state="translated">범위 사용 후 버그를 감지하기 위해 로컬 변수를 살균 할 수 있습니다. 옵션 세트</target>
        </trans-unit>
        <trans-unit id="37f6c409f5734729b3dae114f8c39805c8586c4f" translate="yes" xml:space="preserve">
          <source>Enable showing basic block boundaries (disabled in raw dumps).</source>
          <target state="translated">기본 블록 경계 표시를 활성화합니다 (원시 덤프에서 비활성화 됨).</target>
        </trans-unit>
        <trans-unit id="92f2f939a0618b052e264a0ddefa5df5b7f5e756" translate="yes" xml:space="preserve">
          <source>Enable showing line numbers for statements.</source>
          <target state="translated">문의 줄 번호 표시를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="fd380e6ae8aa5c4cc3cef79ab2ea9026b97f5fbd" translate="yes" xml:space="preserve">
          <source>Enable showing missed optimization information (only available in certain passes).</source>
          <target state="translated">누락 된 최적화 정보 표시를 활성화합니다 (특정 패스에서만 사용 가능).</target>
        </trans-unit>
        <trans-unit id="0d329eb30c66df2a8bec3e0f68514d20ab1b9f92" translate="yes" xml:space="preserve">
          <source>Enable showing optimization information (only available in certain passes).</source>
          <target state="translated">최적화 정보 표시를 활성화합니다 (특정 패스에서만 사용 가능).</target>
        </trans-unit>
        <trans-unit id="f10fcf4d31c6a2b2451c140a8a88da810228a75d" translate="yes" xml:space="preserve">
          <source>Enable showing scalar evolution analysis details.</source>
          <target state="translated">스칼라 진화 분석 세부 사항 표시를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1fa4da5aa5a1df45f7fc17506d98a1fa44e7ec97" translate="yes" xml:space="preserve">
          <source>Enable showing the EH region number holding each statement.</source>
          <target state="translated">각 명세서를 보유한 EH 지역 번호 표시를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="c8bfc39b577282d7a982b0609ca5e212d2e36522" translate="yes" xml:space="preserve">
          <source>Enable showing the tree dump for each statement.</source>
          <target state="translated">각 명령문에 대한 트리 덤프 표시를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c1965c688248d83e371ce542160789f937fce791" translate="yes" xml:space="preserve">
          <source>Enable showing the unique ID (&lt;code&gt;DECL_UID&lt;/code&gt;) for each variable.</source>
          <target state="translated">각 변수에 대해 고유 ID ( &lt;code&gt;DECL_UID&lt;/code&gt; )를 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="2c8e86f5a7b56d45f646fe90ecd4602077ea1bdc" translate="yes" xml:space="preserve">
          <source>Enable showing virtual operands for every statement.</source>
          <target state="translated">모든 명령문에 가상 피연산자를 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7287e0e84335a843622d1b816ceb09d5c05aa749" translate="yes" xml:space="preserve">
          <source>Enable sign extend instructions.</source>
          <target state="translated">부호 확장 명령어를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="2106aa3d9fb87ebeededad40a76e40f9c935fadd" translate="yes" xml:space="preserve">
          <source>Enable software pipelining of innermost loops during selective scheduling. This option has no effect unless one of</source>
          <target state="translated">선택적 스케줄링 중에 가장 안쪽 루프의 소프트웨어 파이프 라이닝을 활성화합니다. 이 옵션은 다음 중 하나가 아니면 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="523a4757398235b8bbb90229026fc9eed157dbee" translate="yes" xml:space="preserve">
          <source>Enable special code to work around file systems which only permit very short file names, such as MS-DOS.</source>
          <target state="translated">MS-DOS와 같이 매우 짧은 파일 이름 만 허용하는 파일 시스템에서 특수 코드가 작동하도록합니다.</target>
        </trans-unit>
        <trans-unit id="3536f2d6d38314050bafe0d10aa71b6595a43eae" translate="yes" xml:space="preserve">
          <source>Enable streaming of mangled types names of C++ types and their unification at link time. This increases size of LTO object files, but enables diagnostics about One Definition Rule violations.</source>
          <target state="translated">C ++ 유형의 맹 글링 된 유형 이름 및 링크시 통합을 스트리밍 할 수 있습니다. 이는 LTO 오브젝트 파일의 크기를 늘리지 만 하나의 정의 규칙 위반에 대한 진단을 가능하게합니다.</target>
        </trans-unit>
        <trans-unit id="07a4edd982a3edcc355177edde03a13c0e84c57f" translate="yes" xml:space="preserve">
          <source>Enable support for &lt;code&gt;char8_t&lt;/code&gt; as adopted for C++2a. This includes the addition of a new &lt;code&gt;char8_t&lt;/code&gt; fundamental type, changes to the types of UTF-8 string and character literals, new signatures for user-defined literals, associated standard library updates, and new &lt;code&gt;__cpp_char8_t&lt;/code&gt; and &lt;code&gt;__cpp_lib_char8_t&lt;/code&gt; feature test macros.</source>
          <target state="translated">C ++ 2a에 채택 된 &lt;code&gt;char8_t&lt;/code&gt; 를 지원합니다 . 여기에는 새로운 &lt;code&gt;char8_t&lt;/code&gt; 기본 유형 추가, UTF-8 문자열 및 문자 리터럴 유형 변경, 사용자 정의 리터럴에 대한 새 서명, 관련 표준 라이브러리 업데이트 및 새로운 &lt;code&gt;__cpp_char8_t&lt;/code&gt; 및 &lt;code&gt;__cpp_lib_char8_t&lt;/code&gt; 기능 테스트 매크로가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="86deb01ddbea29be60b5e5fa22319efa9cd9ea02" translate="yes" xml:space="preserve">
          <source>Enable support for C++17 &lt;code&gt;new&lt;/code&gt; of types that require more alignment than &lt;code&gt;void* ::operator new(std::size_t)&lt;/code&gt; provides. A numeric argument such as &lt;code&gt;-faligned-new=32&lt;/code&gt; can be used to specify how much alignment (in bytes) is provided by that function, but few users will need to override the default of &lt;code&gt;alignof(std::max_align_t)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;void* ::operator new(std::size_t)&lt;/code&gt; 제공하는 것보다 더 정렬이 필요한 C ++ 17의 &lt;code&gt;new&lt;/code&gt; 유형에 대한 지원을 활성화 합니다. &lt;code&gt;-faligned-new=32&lt;/code&gt; 와 같은 숫자 인수를 사용하여 해당 함수에서 제공하는 정렬 (바이트) 수를 지정할 수 있지만 기본 &lt;code&gt;alignof(std::max_align_t)&lt;/code&gt; 를 재정의해야하는 사용자는 거의 없습니다 .</target>
        </trans-unit>
        <trans-unit id="e96dd7f9b95634f8def4cef0c03097523e0ad470" translate="yes" xml:space="preserve">
          <source>Enable support for the C++ Extensions for Concepts Technical Specification, ISO 19217 (2015), which allows code like</source>
          <target state="translated">다음과 같은 코드를 허용하는 Concepts Technical Specification, ISO 19217 (2015)에 대한 C ++ Extensions 지원</target>
        </trans-unit>
        <trans-unit id="14e7ef08a35724e34d06ae98a57c52f37db35541" translate="yes" xml:space="preserve">
          <source>Enable support for the C++ coroutines extension (experimental).</source>
          <target state="translated">C ++ 코 루틴 확장에 대한 지원을 활성화합니다 (실험적).</target>
        </trans-unit>
        <trans-unit id="f069479e84a1d7c81e6433a171bacdd46bd05f77" translate="yes" xml:space="preserve">
          <source>Enable syntactic support for structured exception handling in Objective-C, similar to what is offered by C++. This option is required to use the Objective-C keywords &lt;code&gt;@try&lt;/code&gt;, &lt;code&gt;@throw&lt;/code&gt;, &lt;code&gt;@catch&lt;/code&gt;, &lt;code&gt;@finally&lt;/code&gt; and &lt;code&gt;@synchronized&lt;/code&gt;. This option is available with both the GNU runtime and the NeXT runtime (but not available in conjunction with the NeXT runtime on Mac OS X 10.2 and earlier).</source>
          <target state="translated">C ++에서 제공하는 것과 유사한 Objective-C의 구조적 예외 처리에 대한 구문 지원을 사용하십시오. 이 옵션은 Objective-C 키워드 &lt;code&gt;@try&lt;/code&gt; , &lt;code&gt;@throw&lt;/code&gt; , &lt;code&gt;@catch&lt;/code&gt; , &lt;code&gt;@finally&lt;/code&gt; 및 &lt;code&gt;@synchronized&lt;/code&gt; 를 사용하는 데 필요합니다 . 이 옵션은 GNU 런타임과 NeXT 런타임에서 모두 사용할 수 있습니다 (Mac OS X 10.2 및 이전 버전에서는 NeXT 런타임과 함께 사용할 수 없음).</target>
        </trans-unit>
        <trans-unit id="2d795a0556dc7d4b23ca50c7c054a8e91a0bb9da" translate="yes" xml:space="preserve">
          <source>Enable the Armv8-a Execution and Data Prediction Restriction instructions. This option is only to enable the extension at the assembler level and does not affect code generation. This option is enabled by default for</source>
          <target state="translated">Armv8-a 실행 및 데이터 예측 제한 지침을 활성화하십시오. 이 옵션은 어셈블러 수준에서 확장을 활성화하기위한 것일뿐 코드 생성에는 영향을 미치지 않습니다. 이 옵션은 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fdfa6853fe490f741b25fcc657be1e589731130" translate="yes" xml:space="preserve">
          <source>Enable the Armv8-a Scalable Vector Extension 2. This also enables SVE instructions.</source>
          <target state="translated">Armv8-a Scalable Vector Extension 2를 활성화합니다. 그러면 SVE 명령어도 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="d449b6d30f1777aba3aa927c43beb1ba1eca16be" translate="yes" xml:space="preserve">
          <source>Enable the Armv8-a Speculation Barrier instruction. This option is only to enable the extension at the assembler level and does not affect code generation. This option is enabled by default for</source>
          <target state="translated">Armv8-a Speculation Barrier 명령어를 활성화합니다. 이 옵션은 어셈블러 수준에서 확장을 활성화하기위한 것일뿐 코드 생성에는 영향을 미치지 않습니다. 이 옵션은 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f3b4e86290c1a4d9bac5d679d03a802d662a426" translate="yes" xml:space="preserve">
          <source>Enable the Armv8-a Speculative Store Bypass Safe instruction. This option is only to enable the extension at the assembler level and does not affect code generation. This option is enabled by default for</source>
          <target state="translated">Armv8-a 추측 저장소 우회 안전 명령어를 활성화합니다. 이 옵션은 어셈블러 수준에서 확장을 활성화하기위한 것일뿐 코드 생성에는 영향을 미치지 않습니다. 이 옵션은 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb4dff47dd10c4d2d29138894fb337bf731a4703" translate="yes" xml:space="preserve">
          <source>Enable the Armv8-a aes and pmull crypto extension. This also enables Advanced SIMD instructions.</source>
          <target state="translated">Armv8-a aes 및 pmull 암호화 확장을 활성화합니다. 또한 고급 SIMD 명령어도 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="e878790ea268c6c3c0f09ca24b1f8d32605101d6" translate="yes" xml:space="preserve">
          <source>Enable the Armv8-a sha2 crypto extension. This also enables Advanced SIMD instructions.</source>
          <target state="translated">armv8-a sha2 암호화 확장을 활성화하십시오. 또한 고급 SIMD 명령어도 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="712d78d3897110fb983a6b1ce64ceb649bbc8b13" translate="yes" xml:space="preserve">
          <source>Enable the Armv8.5-a Memory Tagging Extensions. This option is only to enable the extension at the assembler level and does not affect code generation.</source>
          <target state="translated">Armv8.5-a 메모리 태그 확장을 활성화하십시오. 이 옵션은 어셈블러 수준에서 확장을 활성화하기위한 것일뿐 코드 생성에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9079a098e5a352f9d4734819ee7434e8414e46a7" translate="yes" xml:space="preserve">
          <source>Enable the Armv8.5-a Memory Tagging Extensions. Use of this option with architectures prior to Armv8.5-A is not supported.</source>
          <target state="translated">Armv8.5-a 메모리 태그 지정 확장을 활성화합니다. Armv8.5-A 이전 아키텍처에서는이 옵션을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="95fc60e33111a67c5486993a8b351f8b44d07966" translate="yes" xml:space="preserve">
          <source>Enable the Armv8.5-a Random Number instructions. This option is only to enable the extension at the assembler level and does not affect code generation.</source>
          <target state="translated">Armv8.5-a 난수 명령어를 활성화합니다. 이 옵션은 어셈블러 수준에서 확장을 활성화하기위한 것일뿐 코드 생성에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="180be0b78efe4d6cb3cafec86af33875c8613d90" translate="yes" xml:space="preserve">
          <source>Enable the Custom Datapath Extension (CDE) on selected coprocessors according to the numbers given in the options in the range 0 to 7.</source>
          <target state="translated">0 ~ 7 범위의 옵션에 제공된 숫자에 따라 선택한 보조 프로세서에서 CDE (Custom Datapath Extension)를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="5baad961c199027af6ce41f297ba396c80d7b6e4" translate="yes" xml:space="preserve">
          <source>Enable the Dot Product extension. This also enables Advanced SIMD instructions.</source>
          <target state="translated">Dot Product 확장을 활성화하십시오. 또한 고급 SIMD 명령어도 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="75d41529d8ccf751d43eb43b131c2899752ea6dc" translate="yes" xml:space="preserve">
          <source>Enable the P0136 adjustment to the semantics of C++11 constructor inheritance. This is part of C++17 but also considered to be a Defect Report against C++11 and C++14. This flag is enabled by default unless</source>
          <target state="translated">C ++ 11 생성자 상속의 시맨틱에 P0136 조정을 사용하십시오. 이것은 C ++ 17의 일부이지만 C ++ 11 및 C ++ 14에 대한 결함 보고서로 간주됩니다. 이 플래그는 기본적으로 활성화되어 있습니다</target>
        </trans-unit>
        <trans-unit id="3336547cc155fdebeb020d2a6fd267e14851b493" translate="yes" xml:space="preserve">
          <source>Enable the P0522 resolution to Core issue 150, template template parameters and default arguments: this allows a template with default template arguments as an argument for a template template parameter with fewer template parameters. This flag is enabled by default for</source>
          <target state="translated">핵심 문제 150, 템플릿 템플릿 매개 변수 및 기본 인수에 대한 P0522 해상도를 활성화합니다. 이렇게하면 기본 템플릿 인수가있는 템플릿이 템플릿 매개 변수가 적은 템플릿 템플릿 매개 변수의 인수로 사용할 수 있습니다. 이 플래그는 기본적으로 활성화되어 있습니다</target>
        </trans-unit>
        <trans-unit id="e10cb464cd66cc6979f0f2bd645896f8d79b1002" translate="yes" xml:space="preserve">
          <source>Enable the RcPc extension. This does not change code generation from GCC, but is passed on to the assembler, enabling inline asm statements to use instructions from the RcPc extension.</source>
          <target state="translated">RcPc 확장을 활성화하십시오. 이것은 GCC에서 코드 생성을 변경하지 않지만 인라인 asm 문이 RcPc 확장의 명령을 사용할 수 있도록 어셈블러로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="b8bb0e2cd28800659cbb25749c903e1e45881bcd" translate="yes" xml:space="preserve">
          <source>Enable the Statistical Profiling extension. This option is only to enable the extension at the assembler level and does not affect code generation.</source>
          <target state="translated">통계 프로파일 링 확장을 사용하십시오. 이 옵션은 어셈블러 수준에서 확장을 활성화하기위한 것일뿐 코드 생성에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1fe6b0760edee391f1d108920f04662238f04b99" translate="yes" xml:space="preserve">
          <source>Enable the Transactional Memory Extension.</source>
          <target state="translated">트랜잭션 메모리 확장을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="d2bf0d0b92eedbfd9d708906c85f1c2c0761dac3" translate="yes" xml:space="preserve">
          <source>Enable the approximation for scalar division.</source>
          <target state="translated">스칼라 나누기에 대한 근사값을 활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="089b193263b191426125d1b838990e7a8cad6bd6" translate="yes" xml:space="preserve">
          <source>Enable the approximation for scalar square root.</source>
          <target state="translated">스칼라 제곱근에 대한 근사값을 활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="9c93085948ceb9475fc7f62f768a72b094e0ccf8" translate="yes" xml:space="preserve">
          <source>Enable the approximation for vectorized division.</source>
          <target state="translated">벡터화 된 나눗셈에 대한 근사치를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="57c9384569cf978709f6ae7436442c4140ae097a" translate="yes" xml:space="preserve">
          <source>Enable the approximation for vectorized square root.</source>
          <target state="translated">벡터화 된 제곱근에 대한 근사를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="a491c3894437f3620a7562cbc06a8ae940a33c10" translate="yes" xml:space="preserve">
          <source>Enable the built-in global declarations</source>
          <target state="translated">내장 전역 선언 사용</target>
        </trans-unit>
        <trans-unit id="2237d50ade0b28ca43195c6d9a72499aa22da748" translate="yes" xml:space="preserve">
          <source>Enable the compiler to directly use a symbol name as an address in a load/store instruction, without first loading it into a register. Typically, the use of this option generates larger programs, which run faster than when the option isn&amp;rsquo;t used. However, the results vary from program to program, so it is left as a user option, rather than being permanently enabled.</source>
          <target state="translated">컴파일러가 심볼 이름을 레지스터에 먼저로드하지 않고로드 / 저장 명령어의 주소로 직접 사용할 수 있도록합니다. 일반적으로이 옵션을 사용하면 옵션을 사용하지 않을 때보 다 더 빠르게 실행되는 더 큰 프로그램이 생성됩니다. 그러나 결과는 프로그램마다 다르므로 영구적으로 활성화되지 않고 사용자 옵션으로 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="41ed1ab2ec5c1611d830306ad10031d9f9977d65" translate="yes" xml:space="preserve">
          <source>Enable the critical-path heuristic in the scheduler. This heuristic favors instructions on the critical path. This is enabled by default when scheduling is enabled, i.e. with</source>
          <target state="translated">스케줄러에서 임계 경로 휴리스틱을 활성화하십시오. 이 휴리스틱은 중요한 경로에 대한 지침을 선호합니다. 스케줄링이 활성화 된 경우 기본적으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="4067ddde2438b48af6e32a24a3e86763ffbd4275" translate="yes" xml:space="preserve">
          <source>Enable the default instructions, equivalent to</source>
          <target state="translated">기본 명령어를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="8f1e0508bfc454c7d53eb8b99b0581386011e857" translate="yes" xml:space="preserve">
          <source>Enable the dependent-count heuristic in the scheduler. This heuristic favors the instruction that has more instructions depending on it. This is enabled by default when scheduling is enabled, i.e. with</source>
          <target state="translated">스케줄러에서 종속 카운트 휴리스틱을 활성화하십시오. 이 휴리스틱은 명령에 따라 더 많은 명령이있는 명령을 선호합니다. 스케줄링이 활성화 된 경우 기본적으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="507033c0f31508a95a83480597cd9ac155e65d9c" translate="yes" xml:space="preserve">
          <source>Enable the documented workaround for the back-to-back store errata of the GR712RC processor.</source>
          <target state="translated">GR712RC 프로세서의 백투백 저장소 정오표에 대해 문서화 된 해결책을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="eef2a052e4462aff6add94764479243457e98b05" translate="yes" xml:space="preserve">
          <source>Enable the documented workaround for the back-to-back store errata of the UT699E/UT700 processor.</source>
          <target state="translated">UT699E / UT700 프로세서의 백투백 저장소 정오표에 대해 문서화 된 해결책을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="decf2a901923b7e9eb5ca1ab92693295f143a06a" translate="yes" xml:space="preserve">
          <source>Enable the documented workaround for the single erratum of the Atmel AT697F processor (which corresponds to erratum #13 of the AT697E processor).</source>
          <target state="translated">Atmel AT697F 프로세서의 단일 정오표 (AT697E 프로세서의 정오표 # 13에 해당)에 대해 문서화 된 해결 방법을 활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="bcb5bb2598740b13546a58b17f6d5aa7c7ba6853" translate="yes" xml:space="preserve">
          <source>Enable the documented workarounds for the floating-point errata and the data cache nullify errata of the UT699 processor.</source>
          <target state="translated">부동 소수점 정오표 및 데이터 캐시에 대해 문서화 된 임시 해결책을 사용 가능하게하여 UT699 프로세서의 정오표를 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="43eeb910cdee4c766507663e6e771a799fe37d3f" translate="yes" xml:space="preserve">
          <source>Enable the double-precision reciprocal approximation instructions.</source>
          <target state="translated">배정도 역 근사 명령어를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="446e6f12ce2775419c21aa646c548678ff1569c1" translate="yes" xml:space="preserve">
          <source>Enable the double-precision reciprocal square root approximation instructions.</source>
          <target state="translated">배정도 역 제곱근 근사 명령어를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="71718fe9aa5b48da1b26c519c152f829f75fb0c0" translate="yes" xml:space="preserve">
          <source>Enable the extended &lt;code&gt;lrw&lt;/code&gt; instruction. This option defaults to on for CK801 and off otherwise.</source>
          <target state="translated">확장 된 &lt;code&gt;lrw&lt;/code&gt; 명령어를 활성화하십시오 . 이 옵션의 기본값은 CK801의 경우 on이고 그렇지 않은 경우 off입니다.</target>
        </trans-unit>
        <trans-unit id="26a17bc6f3de31676776135a782cd9c993e95087" translate="yes" xml:space="preserve">
          <source>Enable the generation of conditional moves.</source>
          <target state="translated">조건부 이동 생성을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="04969a109a871e39815667dea2edea4731968533" translate="yes" xml:space="preserve">
          <source>Enable the group heuristic in the scheduler. This heuristic favors the instruction that belongs to a schedule group. This is enabled by default when scheduling is enabled, i.e. with</source>
          <target state="translated">스케줄러에서 그룹 휴리스틱을 활성화하십시오. 이 휴리스틱은 스케줄 그룹에 속하는 명령을 선호합니다. 스케줄링이 활성화 된 경우 기본적으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="74416a1c4632bd2c9719e7f267cc78921917bec4" translate="yes" xml:space="preserve">
          <source>Enable the identity transformation for graphite. For every SCoP we generate the polyhedral representation and transform it back to gimple. Using</source>
          <target state="translated">흑연에 대한 항등 변환을 활성화합니다. 모든 SCoP에 대해 우리는 다면체 표현을 생성하고 다시 여드름으로 변환합니다. 사용</target>
        </trans-unit>
        <trans-unit id="d52969e42d36857a708d794bd442398a6f2b1d5e" translate="yes" xml:space="preserve">
          <source>Enable the isl based loop nest optimizer. This is a generic loop nest optimizer based on the Pluto optimization algorithms. It calculates a loop structure optimized for data-locality and parallelism. This option is experimental.</source>
          <target state="translated">isl 기반 루프 네스트 옵티 마이저를 사용하십시오. 이것은 Pluto 최적화 알고리즘에 기반한 일반적인 루프 네스트 최적화 프로그램입니다. 데이터 지역 및 병렬 처리에 최적화 된 루프 구조를 계산합니다. 이 옵션은 실험적입니다.</target>
        </trans-unit>
        <trans-unit id="08b7ee5bf2b0eaab5c12a44d79b227e23ee0c0f5" translate="yes" xml:space="preserve">
          <source>Enable the last-instruction heuristic in the scheduler. This heuristic favors the instruction that is less dependent on the last instruction scheduled. This is enabled by default when scheduling is enabled, i.e. with</source>
          <target state="translated">스케줄러에서 마지막 명령 휴리스틱을 활성화하십시오. 이 휴리스틱은 마지막으로 예약 된 명령에 덜 의존하는 명령을 선호합니다. 스케줄링이 활성화 된 경우 기본적으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="dc56e6084e464db3d7d083e493fb69fc336bcfc3" translate="yes" xml:space="preserve">
          <source>Enable the optimization pass in the HP-UX linker. Note this makes symbolic debugging impossible. It also triggers a bug in the HP-UX 8 and HP-UX 9 linkers in which they give bogus error messages when linking some programs.</source>
          <target state="translated">HP-UX 링커에서 최적화 패스를 활성화하십시오. 이로 인해 기호 디버깅이 불가능합니다. 또한 일부 프로그램을 연결할 때 가짜 오류 메시지를 표시하는 HP-UX 8 및 HP-UX 9 링커에서 버그를 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="8008915ad05d64b6cc01c8698eac6fdda560f6c1" translate="yes" xml:space="preserve">
          <source>Enable the rank heuristic in the scheduler. This heuristic favors the instruction belonging to a basic block with greater size or frequency. This is enabled by default when scheduling is enabled, i.e. with</source>
          <target state="translated">스케줄러에서 순위 휴리스틱을 활성화하십시오. 이 휴리스틱은 더 큰 크기 나 주파수를 가진 기본 블록에 속하는 명령을 선호합니다. 스케줄링이 활성화 된 경우 기본적으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="e6ed1ceef09b312da3bb73bea4902c46d06845e0" translate="yes" xml:space="preserve">
          <source>Enable the reciprocal approximation instructions for both single and double precision.</source>
          <target state="translated">단 정밀도와 배정 밀도에 대해 역 근사 명령어를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="4c8e53d3299e21b3cf3fba9ff55c2082c7b6b1ec" translate="yes" xml:space="preserve">
          <source>Enable the reciprocal square root approximation instructions for both single and double precision.</source>
          <target state="translated">단 정밀도와 배정 밀도 모두에 대해 상호 제곱근 근사 명령어를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="21fb72c5396788f3586c523b20f25c7cd0196802" translate="yes" xml:space="preserve">
          <source>Enable the sha512 and sha3 crypto extension. This also enables Advanced SIMD instructions. Use of this option with architectures prior to Armv8.2-A is not supported.</source>
          <target state="translated">sha512 및 sha3 암호화 확장을 사용하십시오. 또한 고급 SIMD 명령어도 활성화합니다. Armv8.2-A 이전의 아키텍처에서는이 옵션을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ac17a049cdd1860b9740d6573dbf1dae4507b37b" translate="yes" xml:space="preserve">
          <source>Enable the single-precision reciprocal approximation instructions.</source>
          <target state="translated">단 정밀도 역 근사 명령어를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="a4aef85fc3ef145e7cf3738dcc41b55cc33d82a4" translate="yes" xml:space="preserve">
          <source>Enable the single-precision reciprocal square root approximation instructions.</source>
          <target state="translated">단 정밀도 역 근사 근사 명령을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="0a29cdf0e1f32dd82e6b20680fbd0f552bb364b2" translate="yes" xml:space="preserve">
          <source>Enable the sm3 and sm4 crypto extension. This also enables Advanced SIMD instructions. Use of this option with architectures prior to Armv8.2-A is not supported.</source>
          <target state="translated">sm3 및 sm4 암호화 확장을 활성화하십시오. 또한 고급 SIMD 명령어도 활성화합니다. Armv8.2-A 이전의 아키텍처에서는이 옵션을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="cab5f01ba7747ba0641df8f437ad352196c1c6d3" translate="yes" xml:space="preserve">
          <source>Enable the speculative instruction heuristic in the scheduler. This heuristic favors speculative instructions with greater dependency weakness. This is enabled by default when scheduling is enabled, i.e. with</source>
          <target state="translated">스케줄러에서 추론 적 명령 휴리스틱을 활성화합니다. 이 휴리스틱은 더 큰 의존성 약점을 가진 투기 명령을 선호합니다. 스케줄링이 활성화 된 경우 기본적으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="e847a09656f326765748affab74d130a0fbbbfb3" translate="yes" xml:space="preserve">
          <source>Enable the use (disable) of the built-in functions that allow direct access to the cryptographic instructions that were added in version 2.07 of the PowerPC ISA.</source>
          <target state="translated">PowerPC ISA 버전 2.07에 추가 된 암호화 명령어에 직접 액세스 할 수있는 내장 기능을 사용 (사용 안함)합니다.</target>
        </trans-unit>
        <trans-unit id="0beb7325ebbd427ff6f653a5586006076fc19189" translate="yes" xml:space="preserve">
          <source>Enable the use of &lt;code&gt;GPREL&lt;/code&gt; relocations in the FDPIC ABI for data that is known to be in read-only sections. It&amp;rsquo;s enabled by default, except for</source>
          <target state="translated">읽기 전용 섹션에있는 데이터에 대해 FDPIC ABI에서 &lt;code&gt;GPREL&lt;/code&gt; 재배치를 사용할 수 있습니다. 다음을 제외하고 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b3e38bf3ad012b6637b58a91ae68d4399ef997c" translate="yes" xml:space="preserve">
          <source>Enable the use of a minimum runtime environment - no static initializers or constructors. This is intended for memory-constrained devices. The compiler includes special symbols in some objects that tell the linker and runtime which code fragments are required.</source>
          <target state="translated">정적 이니셜 라이저 또는 생성자가없는 최소 런타임 환경을 사용하십시오. 이것은 메모리가 제한된 장치를위한 것입니다. 컴파일러에는 링커와 런타임에 필요한 코드 조각을 알려주는 특수 기호가 일부 객체에 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e3906c56ec37b4268552279d6414d35519910f2" translate="yes" xml:space="preserve">
          <source>Enable the use of assembler directives only GAS understands.</source>
          <target state="translated">GAS 만 이해하는 어셈블러 지시문 사용을 활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="8315949440093bd19b322b38da5ef593bd5c1273" translate="yes" xml:space="preserve">
          <source>Enable the use of bit manipulation instructions on SH2A.</source>
          <target state="translated">SH2A에서 비트 조작 명령을 사용하도록 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="776b7d037afae7efec8fa9845c5ffbd3bad3e0de" translate="yes" xml:space="preserve">
          <source>Enable the use of conditional execution (default).</source>
          <target state="translated">조건부 실행 사용을 활성화합니다 (기본값).</target>
        </trans-unit>
        <trans-unit id="3f92036c53e4d3d87aa05d99ffc56331dbaf7cbe" translate="yes" xml:space="preserve">
          <source>Enable the use of conditional set instructions (default).</source>
          <target state="translated">조건부 설정 명령어 사용을 활성화합니다 (기본값).</target>
        </trans-unit>
        <trans-unit id="f02a7f12f7eb0e41accd67fcdeeacad0f7a7fbae" translate="yes" xml:space="preserve">
          <source>Enable the use of conditional-move instructions (default).</source>
          <target state="translated">조건부 이동 명령어 사용을 활성화합니다 (기본값).</target>
        </trans-unit>
        <trans-unit id="8bd8c14864a3dc22ad6416f43c205d177280cc14" translate="yes" xml:space="preserve">
          <source>Enable the use of indexed loads. This can be problematic because some optimizers then assume that indexed stores exist, which is not the case.</source>
          <target state="translated">인덱싱 된로드 사용을 활성화합니다. 일부 최적화 프로그램은 인덱싱 된 저장소가 존재한다고 가정하기 때문에 문제가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa24f968931ae6f6108870656a7843c7774cc339" translate="yes" xml:space="preserve">
          <source>Enable the use of multiply-accumulate instructions. Disabled by default.</source>
          <target state="translated">곱하기 누적 명령어 사용을 활성화합니다. 기본적으로 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7a1f017f17fab4284673c060b8b2143eec98325" translate="yes" xml:space="preserve">
          <source>Enable the use of odd-numbered single-precision floating-point registers for the o32 ABI. This is the default for processors that are known to support these registers. When using the o32 FPXX ABI,</source>
          <target state="translated">o32 ABI에 홀수의 단 정밀도 부동 소수점 레지스터를 사용할 수 있습니다. 이 레지스터를 지원하는 것으로 알려진 프로세서의 기본값입니다. o32 FPXX ABI를 사용하는 경우</target>
        </trans-unit>
        <trans-unit id="ea76b09fecc8949f24ae03f9a3f42c9fa0287c50" translate="yes" xml:space="preserve">
          <source>Enable the use of pre/post modify with register displacement.</source>
          <target state="translated">레지스터 변위와 함께 사전 / 사후 수정 사용을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="6635132d2079387847468168f8edcfc7554ca84f" translate="yes" xml:space="preserve">
          <source>Enable the use of the instruction &lt;code&gt;fmovd&lt;/code&gt;. Check</source>
          <target state="translated">&lt;code&gt;fmovd&lt;/code&gt; 명령어 사용을 활성화합니다 . 검사</target>
        </trans-unit>
        <trans-unit id="a2fdf0058d830cee1f93b69f832936392dc9ed46" translate="yes" xml:space="preserve">
          <source>Enable tree pass &lt;var&gt;pass&lt;/var&gt;. See</source>
          <target state="translated">트리 패스 &lt;var&gt;pass&lt;/var&gt; 활성화합니다 . 보다</target>
        </trans-unit>
        <trans-unit id="b8f020346acd5709653f3c40d525659258a1b9db" translate="yes" xml:space="preserve">
          <source>Enable use of &lt;code&gt;bi&lt;/code&gt; or &lt;code&gt;bih&lt;/code&gt; instructions to implement jump tables.</source>
          <target state="translated">사용 가능 &lt;code&gt;bi&lt;/code&gt; 또는 &lt;code&gt;bih&lt;/code&gt; 점프 테이블을 구현하는 지침을.</target>
        </trans-unit>
        <trans-unit id="79a73d3f193a6e6ff330a4b9de3265b919526bff" translate="yes" xml:space="preserve">
          <source>Enable use of the extended instructions of the FT32B processor.</source>
          <target state="translated">FT32B 프로세서의 확장 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6d0438ac8bb52c3d5f5f9c3df1e29694d4f64211" translate="yes" xml:space="preserve">
          <source>Enable user-defined instructions.</source>
          <target state="translated">사용자 정의 지침을 활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="289e8ab3bafc79cd3d4d7a33238e966c5c4d7a05" translate="yes" xml:space="preserve">
          <source>Enable verbose cost model dumping in the debug dump files. This option is provided for use in debugging the compiler.</source>
          <target state="translated">디버그 덤프 파일에서 자세한 비용 모델 덤프를 사용하십시오. 이 옵션은 컴파일러 디버깅에 사용하기 위해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="5698cf3230e865992f3f27c124b887d7d8c62160" translate="yes" xml:space="preserve">
          <source>Enable/disable bit-field layout compatible with the native Microsoft Windows compiler.</source>
          <target state="translated">기본 Microsoft Windows 컴파일러와 호환되는 비트 필드 레이아웃을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="ec1922decad109f864b4cf7878296aa732c83b64" translate="yes" xml:space="preserve">
          <source>Enable/disable inlining of string operations.</source>
          <target state="translated">문자열 작업 인라인을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="77a9782fdfbab35d94a1e98b3a7fd934623ad240" translate="yes" xml:space="preserve">
          <source>Enable/disable the &lt;var&gt;__float128&lt;/var&gt; keyword for IEEE 128-bit floating point and use either software emulation for IEEE 128-bit floating point or hardware instructions.</source>
          <target state="translated">IEEE 128 비트 부동 소수점에 대해 &lt;var&gt;__float128&lt;/var&gt; 키워드를 활성화 / 비활성화하고 IEEE 128 비트 부동 소수점에 대한 소프트웨어 에뮬레이션 또는 하드웨어 명령어를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="eef257e319b773e37c267992617c97ed3ff87e5c" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of RCPSS, RCPPS, RSQRTSS and RSQRTPS instructions followed an additional Newton-Raphson step instead of doing a floating-point division.</source>
          <target state="translated">RCPSS, RCPPS, RSQRTSS 및 RSQRTPS 명령어 생성을 활성화 / 비활성화하여 부동 소수점 나누기 대신 추가 Newton-Raphson 단계를 수행했습니다.</target>
        </trans-unit>
        <trans-unit id="ce9687705ccc627a85aa74c6222e1c475cf39951" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of floating point that depends on IEEE arithmetic.</source>
          <target state="translated">IEEE 산술에 따라 부동 소수점 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="e06af20ef568b69c3362691eda73268a45b5e6fb" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the 3DNow! instructions.</source>
          <target state="translated">3DNow! 생성을 활성화 / 비활성화합니다. 명령.</target>
        </trans-unit>
        <trans-unit id="8ea30fdab63dafe3dc7fc652cf67136424f3b625" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the &lt;code&gt;sin&lt;/code&gt;, &lt;code&gt;cos&lt;/code&gt;, and &lt;code&gt;sqrt&lt;/code&gt; instructions on the 387 floating-point unit.</source>
          <target state="translated">387 부동 소수점 단위 에서 &lt;code&gt;sin&lt;/code&gt; , &lt;code&gt;cos&lt;/code&gt; 및 &lt;code&gt;sqrt&lt;/code&gt; 명령어 생성을 활성화 / 비활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="d2ce898ea3fbbf85aca7bdcebad5257c4339a871" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the ADX instructions.</source>
          <target state="translated">ADX 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="8c51cd7ffa80497e01030865d76bb3aa852e4b11" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AES instructions.</source>
          <target state="translated">AES 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="139f5148751f41ac5e236f52ce09ecaba429fae5" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX instructions.</source>
          <target state="translated">AVX 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="c03537f2a6f562c3bdf507ee0385caa610905340" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX2 instructions.</source>
          <target state="translated">AVX2 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="2f46ca2cd644ae06703a20fd137f758ec86b545b" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX5124FMAPS instructions.</source>
          <target state="translated">AVX5124FMAPS 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="07c3fb12af13a9cd69b78d9bc8b1bf44bce2f703" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX5124VNNIW instructions.</source>
          <target state="translated">AVX5124VNNIW 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="3754f28eb3ff315a901b1086241414b36cdc2445" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512BITALG instructions.</source>
          <target state="translated">AVX512BITALG 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="9d757b2f48a6a1b6957e3c46cfd35f8cef5e43f2" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512BW instructions.</source>
          <target state="translated">AVX512BW 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="d3c2cb946f575c062fed2315966b199b452fa19e" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512CD instructions.</source>
          <target state="translated">AVX512CD 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="55f4758594e3826b45c045f868cd0c0b6fe314a5" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512DQ instructions.</source>
          <target state="translated">AVX512DQ 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="868a5a7c9ba2cab10b4dbee05b59b72caa86a0f1" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512ER instructions.</source>
          <target state="translated">AVX512ER 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="40cf4ec0c6bc30ab932552059f3f09cac003af63" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512F instructions.</source>
          <target state="translated">AVX512F 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="ba0e32798c4a1b18ba185f7a8c7a840f7e7480c5" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512IFMA instructions.</source>
          <target state="translated">AVX512IFMA 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="cfee43efb9eef88de6b588ce9a55a47d1e02ac8b" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512PF instructions.</source>
          <target state="translated">AVX512PF 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="1d9376176900a884770b47d4b38ffe3800952fda" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512VBMI instructions.</source>
          <target state="translated">AVX512VBMI 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="5315cd056026db5157cf29bd04c56d18b6d556b6" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512VBMI2 instructions.</source>
          <target state="translated">AVX512VBMI2 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="ddf56de8dc48259cd81ab8285e90003fb25e73e2" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512VL instructions.</source>
          <target state="translated">AVX512VL 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="26241a02deae96e24160a0ca3f3cc5c41033dbf3" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512VNNI instructions.</source>
          <target state="translated">AVX512VNNI 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="84a8ab5234b9fa4c56baeffdaee98c552e89549f" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the AVX512VPOPCNTDQ instructions.</source>
          <target state="translated">AVX512VPOPCNTDQ 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="dae7d1054e24eee8d8b487043aaad1fc5f1db574" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the BMI instructions.</source>
          <target state="translated">BMI 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="3d72a8758536f6a87e94a41fe37b66f09beef533" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the BMI2 instructions.</source>
          <target state="translated">BMI2 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="b738e70323169015d6a48d84ae40dd6c29e5217d" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the CLD before string moves.</source>
          <target state="translated">문자열이 이동하기 전에 CLD 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="d65d8d65a18d1cfa6dc9c78ebdaad5ad563343cb" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the CLDEMOTE instructions.</source>
          <target state="translated">CLDEMOTE 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="ccb6f558360b355b894e7ea63cd154a997ed12e8" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the CLFLUSHOPT instructions.</source>
          <target state="translated">CLFLUSHOPT 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="f0801d5d70f8b9df1efe3aea49e8a0671ca5bfec" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the CLWB instructions.</source>
          <target state="translated">CLWB 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="94ecea85bbdafb56613082f3e5be7c02237756ed" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the CLZERO instructions.</source>
          <target state="translated">CLZERO 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="f8d79a3c698ec42fbe32e73864266b011f951b2f" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the CMPXCHG16B instructions.</source>
          <target state="translated">CMPXCHG16B 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="b0bd05f01479f2861886a517faf455f95df939c9" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the CRC32 instructions.</source>
          <target state="translated">CRC32 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="d6440333fc0c90bc6217f92335430eaed3b0c3e6" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the F16C instructions.</source>
          <target state="translated">F16C 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="5cea65073f4a60c1177a3414fc29a42c91b72246" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the FMA instructions.</source>
          <target state="translated">FMA 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="99871ac8f6615a85bb6ff6e756bf21d0a7db8138" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the FMA4 instructions.</source>
          <target state="translated">FMA4 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="4820cc9a7748ec354eac413d8f383da9dd67e717" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the FSGSBASE instructions.</source>
          <target state="translated">FSGSBASE 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="60644d857fe08e2846e93707df49f0bca9fb4a3e" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the FXSR instructions.</source>
          <target state="translated">FXSR 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="0d58cb597f94125b583603aeaf0cb6d6fac80c1b" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the GFNI instructions.</source>
          <target state="translated">GFNI 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="9578e9d5e6eece4df004759dd7fc90f39eea18e0" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the HLE instruction prefixes.</source>
          <target state="translated">HLE 명령어 접두사 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="549533ddadf886e04d518c98906dae343a33a8ce" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the LWP instructions.</source>
          <target state="translated">LWP 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="8c3785d4101d06b824b0b36311920e0a30ccd2d9" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the LZCNT instructions.</source>
          <target state="translated">LZCNT 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="574261210d9c97190453b59ddf32621dc2c86c69" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the MMX instructions.</source>
          <target state="translated">MMX 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="45a7da12e51c3e52b7908907f0dfac053d1882c4" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the MOVBE instructions.</source>
          <target state="translated">MOVBE 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="75cfc04edcd4dee4218a715cae2bd3ac7fa16a7e" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the MOVDIR64B instructions.</source>
          <target state="translated">MOVDIR64B 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="c6371db2050fdd103c6d197692dfd64140187f4a" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the MOVDIRI instructions.</source>
          <target state="translated">MOVDIRI 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="6e98e7f5d53a1e3439a31b14070244368aebebfe" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the MWAITX instructions.</source>
          <target state="translated">MWAITX 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="dc37894f7a2ce025aaeba83cdca8f3ca819436f1" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the PCLMUL instructions.</source>
          <target state="translated">PCLMUL 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="c6ecdb5d5fff5ea045de6d2ca8023861f04ebc4d" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the PCONFIG instructions.</source>
          <target state="translated">PCONFIG 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="a081a1e7a08745213d7883c3b5236130fe755e13" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the PKU instructions.</source>
          <target state="translated">PKU 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="e9e69747966699a82f308dbbadb71d6e9fb92d92" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the POPCNT instruction.</source>
          <target state="translated">POPCNT 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="f9ed3efe60bd11688e60a3f2cb5a1ff252d812d0" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the PREFETCHW instruction.</source>
          <target state="translated">PREFETCHW 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="006748470b229e9088cb61bc26a1257f2c9a8615" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the PREFETCHWT1 instructions.</source>
          <target state="translated">PREFETCHWT1 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="2447c34a50f2bd64c3943526353f34051a55f5aa" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the PTWRITE instructions.</source>
          <target state="translated">PTWRITE 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="5735ee8db2baf84da1ef868849fd1bf84c1f8c11" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the RDPID instructions.</source>
          <target state="translated">RDPID 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="0b0a5749ac92e20b8e558766d0dd8d71d8adeeaf" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the RDRND instructions.</source>
          <target state="translated">RDRND 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="4913a7bcb28cb1f12173c4058eaf61ab9315d7d3" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the RDSEED instructions.</source>
          <target state="translated">RDSEED 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="300142c2ef84f7df525c1aa21af494a1e7bead9f" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the RTM instructions.</source>
          <target state="translated">RTM 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="0d2ad4e123ffd7abb18aa9c974df2646f0d5508c" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the SAHF instructions.</source>
          <target state="translated">SAHF 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="632f005a4b74a3843a3298d0871cbe50c5ad6aa9" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the SGX instructions.</source>
          <target state="translated">SGX 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="6b57bd12c5e2df48fa7d7e43ba31d0995c7f5553" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the SHA instructions.</source>
          <target state="translated">SHA 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="b5d7ecf6e517427fea4ad12abde111a42bd74cea" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the SSE instructions.</source>
          <target state="translated">SSE 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="1f0972ae163067735798e2e6f4187300ae1137e4" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the SSE2 instructions.</source>
          <target state="translated">SSE2 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="b03632fda4a2d3d92f1cf4eac7cca05dbc5a7516" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the SSE3 instructions.</source>
          <target state="translated">SSE3 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="5e9b999ddb7457a054d66bdaa2de1a8f647ad215" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the SSE4 instructions (both SSE4.1 and SSE4.2).</source>
          <target state="translated">SSE4 명령어 생성 (SSE4.1 및 SSE4.2 모두)을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="21d0ef801e5d8043d92d8c50dd3d6daaddab55a0" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the SSE4A instructions.</source>
          <target state="translated">SSE4A 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="ab7b78506bfd06d655fee8ea1068706000cbeacf" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the SSSE3 instructions.</source>
          <target state="translated">SSSE3 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="f0e97c519b39b4830d04c86470ddf48b233a76c5" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the TBM instructions.</source>
          <target state="translated">TBM 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="f3acd83d7172837bca3d0b44672674470b67ff86" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the VAES instructions.</source>
          <target state="translated">VAES 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="9789894eea8adf6b88ad98db26058bba573138b8" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the VPCLMULQDQ instructions.</source>
          <target state="translated">VPCLMULQDQ 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="b524ba4aef3ce6873b5b0e11048e23307db06122" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the WAITPKG instructions.</source>
          <target state="translated">WAITPKG 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="a045e3b2a45d14170b9039170f7578c3d2713015" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the WBNOINVD instructions.</source>
          <target state="translated">WBNOINVD 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="e40cfbce647b2c7f9ddf7f4f626656cc3a1bc167" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the XOP instructions.</source>
          <target state="translated">XOP 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="af8da63fa2d12d8f18afd42b233c4d37ee867c63" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the XSAVE instructions.</source>
          <target state="translated">XSAVE 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="1233b5b867e3f5dba2db3c438d3d6df18bde5ef8" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the XSAVEC instructions.</source>
          <target state="translated">XSAVEC 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="a0a9e371f8da9a97cd65e604007429c825f18769" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the XSAVEOPT instructions.</source>
          <target state="translated">XSAVEOPT 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="40e3ea0db494aa36d313e852fcbfd0f81556503b" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the XSAVES instructions.</source>
          <target state="translated">XSAVES 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="fe009b6bf64ee12df513906e2d5837b5e1c97910" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the advanced bit instructions.</source>
          <target state="translated">고급 비트 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="da867b2b85cc94070610ef36f96c5698f745a3ec" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the enhanced 3DNow! instructions.</source>
          <target state="translated">향상된 3DNow! 생성을 활성화 / 비활성화합니다. 명령.</target>
        </trans-unit>
        <trans-unit id="7b3bd531bffe003f20aeec31cfccd8602793b41a" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the inline code to do small string operations and calling the library routines for large operations.</source>
          <target state="translated">인라인 코드 생성을 활성화 / 비활성화하여 작은 문자열 작업을 수행하고 큰 작업을위한 라이브러리 루틴을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="902acc4f79ae76c2d32a7b6c514f8deac67c62fb" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the sse4.1 instructions.</source>
          <target state="translated">sse4.1 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="2a2818a0c367c053dac063d194f234ec531d06f2" translate="yes" xml:space="preserve">
          <source>Enable/disable the generation of the sse4.2 instructions.</source>
          <target state="translated">sse4.2 명령어 생성을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="37e917a07fa74d7e4e6dadb9579fbc16f97ae659" translate="yes" xml:space="preserve">
          <source>Enable/disable the shadow stack built-in functions from CET.</source>
          <target state="translated">CET에서 섀도 스택 내장 기능을 활성화 / 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="e907f9b58bf0706e2b41d509db8ed99ad239f467" translate="yes" xml:space="preserve">
          <source>Enable/disable using ISA 3.0 hardware instructions to support the &lt;var&gt;__float128&lt;/var&gt; data type.</source>
          <target state="translated">&lt;var&gt;__float128&lt;/var&gt; 데이터 형식 을 지원하기 위해 ISA 3.0 하드웨어 지침을 사용하여 활성화 / 비활성화 합니다.</target>
        </trans-unit>
        <trans-unit id="41e598e82b094b60e50ff17f84b1a81de5e43516" translate="yes" xml:space="preserve">
          <source>Enabled at level</source>
          <target state="translated">수준에서 활성화</target>
        </trans-unit>
        <trans-unit id="4b32f2d1dc57603e53cae07a8b8cf8dd5b0f7205" translate="yes" xml:space="preserve">
          <source>Enabled at levels</source>
          <target state="translated">레벨에서 사용 가능</target>
        </trans-unit>
        <trans-unit id="a2d7a1ae5b45c7663ff5c6c74c01638ab9ca0806" translate="yes" xml:space="preserve">
          <source>Enabled by</source>
          <target state="translated">에 의해 활성화</target>
        </trans-unit>
        <trans-unit id="87971a35b8aed293eb3378e3d8ac5721ecb5cb96" translate="yes" xml:space="preserve">
          <source>Enabled by default at</source>
          <target state="translated">에서 기본적으로 활성화</target>
        </trans-unit>
        <trans-unit id="bcd7c586f5c724dfc09404aaf2a878d0206e9f76" translate="yes" xml:space="preserve">
          <source>Enabled by default when</source>
          <target state="translated">기본적으로 활성화</target>
        </trans-unit>
        <trans-unit id="4f94ea1c93e5664c46cd416ea64f7cc9936467d8" translate="yes" xml:space="preserve">
          <source>Enabled by default with</source>
          <target state="translated">기본적으로 활성화</target>
        </trans-unit>
        <trans-unit id="261c7b9c3b776bec501c26a9d2fe4d480d9d16f7" translate="yes" xml:space="preserve">
          <source>Enabled by default.</source>
          <target state="translated">기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3d5b773827f9c4413a2fc452aae96dd06f591fd" translate="yes" xml:space="preserve">
          <source>Enabled for Alpha, AArch64 and x86 at levels</source>
          <target state="translated">레벨에서 알파, AArch64 및 x86에 사용</target>
        </trans-unit>
        <trans-unit id="217f8e562e876828812e90f53725615d6901cc9d" translate="yes" xml:space="preserve">
          <source>Enabled for x86 at levels</source>
          <target state="translated">레벨에서 x86에 사용</target>
        </trans-unit>
        <trans-unit id="44ce21fc6a64ad296ee8e3cda3bcb2b9759adebf" translate="yes" xml:space="preserve">
          <source>Enabled with</source>
          <target state="translated">사용</target>
        </trans-unit>
        <trans-unit id="979f6df4ed2e6e9238efa8b3ebc9f087264e476a" translate="yes" xml:space="preserve">
          <source>Enables (</source>
          <target state="translated">사용 (</target>
        </trans-unit>
        <trans-unit id="7eae3793cec99e5fa487fe453e12770d55076d5b" translate="yes" xml:space="preserve">
          <source>Enables (or disables) reading and writing of 16- and 32- bit values from addresses that are not 16- or 32- bit aligned. By default unaligned access is disabled for all pre-ARMv6, all ARMv6-M and for ARMv8-M Baseline architectures, and enabled for all other architectures. If unaligned access is not enabled then words in packed data structures are accessed a byte at a time.</source>
          <target state="translated">16 비트 또는 32 비트로 정렬되지 않은 주소에서 16 비트 및 32 비트 값을 읽고 쓸 수있게합니다. 기본적으로 정렬되지 않은 액세스는 모든 ARMv6 이전, 모든 ARMv6-M 및 ARMv8-M베이스 라인 아키텍처에서 비활성화되고 다른 모든 아키텍처에서 활성화됩니다. 정렬되지 않은 액세스가 활성화되지 않은 경우 묶음 데이터 구조의 단어는 한 번에 한 바이트 씩 액세스됩니다.</target>
        </trans-unit>
        <trans-unit id="b65eaeca3be0a544da578e950cb68230b9d67b03" translate="yes" xml:space="preserve">
          <source>Enables IVC2 scheduling. IVC2 is a 64-bit VLIW coprocessor.</source>
          <target state="translated">IVC2 스케줄링을 사용합니다. IVC2는 64 비트 VLIW 보조 프로세서입니다.</target>
        </trans-unit>
        <trans-unit id="f8bfc926b8449de54aa34c3f95b4955d0fe52d4e" translate="yes" xml:space="preserve">
          <source>Enables all inter-procedural analysis dumps.</source>
          <target state="translated">모든 절차 간 분석 덤프를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="39e032a23d350be5be02b628822ab23ba3864dfe" translate="yes" xml:space="preserve">
          <source>Enables all the optional instructions&amp;mdash;average, multiply, divide, bit operations, leading zero, absolute difference, min/max, clip, and saturation.</source>
          <target state="translated">평균, 곱하기, 나누기, 비트 연산, 선행 제로, 절대 차이, 최소 / 최대, 클립 및 채도 등 모든 선택적 명령을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dcd06b68e12a4e252dc788f4fd7792582f994c23" translate="yes" xml:space="preserve">
          <source>Enables expression of values of induction variables in later iterations of the unrolled loop using the value in the first iteration. This breaks long dependency chains, thus improving efficiency of the scheduling passes.</source>
          <target state="translated">첫 번째 반복의 값을 사용하여 언 롤링 된 루프의 이후 반복에서 유도 변수의 값을 표현할 수 있습니다. 이로 인해 긴 종속성 체인이 중단되므로 스케줄링 패스의 효율성이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="7564b980df27ae9794a4d64f8c88854f784c151d" translate="yes" xml:space="preserve">
          <source>Enables or disables the use of the string manipulation instructions &lt;code&gt;SMOVF&lt;/code&gt;, &lt;code&gt;SCMPU&lt;/code&gt;, &lt;code&gt;SMOVB&lt;/code&gt;, &lt;code&gt;SMOVU&lt;/code&gt;, &lt;code&gt;SUNTIL&lt;/code&gt;&lt;code&gt;SWHILE&lt;/code&gt; and also the &lt;code&gt;RMPA&lt;/code&gt; instruction. These instructions may prefetch data, which is not safe to do if accessing an I/O register. (See section 12.2.7 of the RX62N Group User&amp;rsquo;s Manual for more information).</source>
          <target state="translated">문자열 조작 명령어 &lt;code&gt;SMOVF&lt;/code&gt; , &lt;code&gt;SCMPU&lt;/code&gt; , &lt;code&gt;SMOVB&lt;/code&gt; , &lt;code&gt;SMOVU&lt;/code&gt; , &lt;code&gt;SUNTIL&lt;/code&gt; &lt;code&gt;SWHILE&lt;/code&gt; 및 &lt;code&gt;RMPA&lt;/code&gt; 명령어 사용을 활성화 또는 비활성화합니다 . 이러한 명령어는 데이터를 프리 페치 할 수 있으며, 이는 I / O 레지스터에 액세스하는 경우 안전하지 않습니다. (자세한 내용은 RX62N 그룹 사용 설명서의 12.2.7 섹션을 참조하십시오).</target>
        </trans-unit>
        <trans-unit id="b2d56a3e8dc64cdea92b5b177de5eee2ddc022a5" translate="yes" xml:space="preserve">
          <source>Enables support for &lt;code&gt;double&lt;/code&gt; and &lt;code&gt;long long&lt;/code&gt; types to be aligned on 8-byte boundaries. The default is to restrict the alignment of all objects to at most 4-bytes. When</source>
          <target state="translated">8 바이트 경계 에서 &lt;code&gt;double&lt;/code&gt; 및 &lt;code&gt;long long&lt;/code&gt; 유형을 지원할 수 있습니다. 기본값은 모든 객체의 정렬을 최대 4 바이트로 제한하는 것입니다. 언제</target>
        </trans-unit>
        <trans-unit id="85b9ecfc95ed087be71f719ded533eb947f09555" translate="yes" xml:space="preserve">
          <source>Enables support for all single- and double-precision floating-point hardware extensions. Not available for ARC EM.</source>
          <target state="translated">모든 단 정밀도 및 배정 밀도 부동 소수점 하드웨어 확장을 지원합니다. ARC EM에는 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f75e5afbbe9ab70b1263a70cb8894e0664caf0b1" translate="yes" xml:space="preserve">
          <source>Enables support for all single-precision floating-point hardware extensions.</source>
          <target state="translated">모든 단 정밀도 부동 소수점 하드웨어 확장을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="7883565cb4fb9258e363d1f2d7f38e140fa66bc4" translate="yes" xml:space="preserve">
          <source>Enables support for double-precision floating-point and fused multiply and add hardware extensions. This option includes option &amp;lsquo;</source>
          <target state="translated">배정 밀도 부동 소수점 및 융합 곱셈을 지원하고 하드웨어 확장을 추가합니다. 이 옵션에는 '</target>
        </trans-unit>
        <trans-unit id="09688a51318111fb1133a1873f85c86a0dd2d24a" translate="yes" xml:space="preserve">
          <source>Enables support for double-precision floating-point hardware extensions using double-precision assist instructions. All single-precision floating-point hardware extensions are also enabled. This option is only available for ARC EM.</source>
          <target state="translated">배정도 지원 명령어를 사용하여 배정도 부동 소수점 하드웨어 확장을 지원할 수 있습니다. 모든 단 정밀도 부동 소수점 하드웨어 확장도 활성화됩니다. 이 옵션은 ARC EM에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="998d962adb014531e7dc98dfd0f68752292543ee" translate="yes" xml:space="preserve">
          <source>Enables support for double-precision floating-point hardware extensions using double-precision assist instructions. The single-precision floating-point and fused multiply and add hardware extensions are also enabled. This option is only available for ARC EM.</source>
          <target state="translated">배정도 지원 명령어를 사용하여 배정도 부동 소수점 하드웨어 확장을 지원할 수 있습니다. 단 정밀도 부동 소수점 및 융합 곱셈 및 하드웨어 확장 추가도 가능합니다. 이 옵션은 ARC EM에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d9fab6d5bc5404d7e456a561365555b9e55a46b" translate="yes" xml:space="preserve">
          <source>Enables support for double-precision floating-point hardware extensions using double-precision assist instructions. The single-precision floating-point extension is also enabled. This option is only available for ARC EM.</source>
          <target state="translated">배정도 지원 명령어를 사용하여 배정도 부동 소수점 하드웨어 확장을 지원할 수 있습니다. 단 정밀도 부동 소수점 확장도 활성화됩니다. 이 옵션은 ARC EM에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8714aef39627cf0d1b3a7e36332dd7526fef4382" translate="yes" xml:space="preserve">
          <source>Enables support for double-precision floating-point hardware extensions using double-precision assist instructions. The single-precision floating-point, square-root, and divide extensions are also enabled. This option is only available for ARC EM.</source>
          <target state="translated">배정도 지원 명령어를 사용하여 배정도 부동 소수점 하드웨어 확장을 지원할 수 있습니다. 단 정밀도 부동 소수점, 제곱근 및 나누기 확장도 활성화됩니다. 이 옵션은 ARC EM에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="88614dbf859eb550fe6ea83089c08ee2a35b6c5a" translate="yes" xml:space="preserve">
          <source>Enables support for double-precision floating-point hardware extensions. The single-precision floating-point extension is also enabled. Not available for ARC EM.</source>
          <target state="translated">배정 밀도 부동 소수점 하드웨어 확장을 지원합니다. 단 정밀도 부동 소수점 확장도 활성화됩니다. ARC EM에는 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ed75b445d9416dbdcca6532a5b9e4ba16b46347a" translate="yes" xml:space="preserve">
          <source>Enables support for double-precision floating-point, square-root and divide hardware extensions. This option includes option &amp;lsquo;</source>
          <target state="translated">배정 밀도 부동 소수점, 제곱근 및 분할 하드웨어 확장을 지원합니다. 이 옵션에는 '</target>
        </trans-unit>
        <trans-unit id="4020a8753a0799a59f9043cec8f1b76a8cbf21f5" translate="yes" xml:space="preserve">
          <source>Enables support for single-precision floating-point and fused multiply and add hardware extensions.</source>
          <target state="translated">단 정밀도 부동 소수점 및 융합 곱셈을 지원하고 하드웨어 확장을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="739ef3a6f4ad193608707def042ed976fbb38794" translate="yes" xml:space="preserve">
          <source>Enables support for single-precision floating-point hardware extensions.</source>
          <target state="translated">단 정밀도 부동 소수점 하드웨어 확장을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="69030e58955d3b24f425bf1f743dd072b9ea41e4" translate="yes" xml:space="preserve">
          <source>Enables support for single-precision floating-point, square-root and divide hardware extensions.</source>
          <target state="translated">단 정밀도 부동 소수점, 제곱근 및 분할 하드웨어 확장을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="dd589dcd1e2f89f81d2aa1944b9d5b300d0537d9" translate="yes" xml:space="preserve">
          <source>Enables support for specific floating-point hardware extensions for ARCv2 cores. Supported values for &lt;var&gt;fpu&lt;/var&gt; are:</source>
          <target state="translated">ARCv2 코어에 대한 특정 부동 소수점 하드웨어 확장을 지원합니다. &lt;var&gt;fpu&lt;/var&gt; 에 지원되는 값 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="40edc654abf50990a91d4feb4df5e9d34bf7f47f" translate="yes" xml:space="preserve">
          <source>Enables support for the RH850 version of the V850 ABI. This is the default. With this version of the ABI the following rules apply:</source>
          <target state="translated">V850 ABI의 RH850 버전을 지원합니다. 이것이 기본값입니다. 이 버전의 ABI에서는 다음 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="a3ccc0d52f2a100abeb7168c2966e22df181fb16" translate="yes" xml:space="preserve">
          <source>Enables support for the old GCC version of the V850 ABI. With this version of the ABI the following rules apply:</source>
          <target state="translated">V850 ABI의 이전 GCC 버전을 지원합니다. 이 버전의 ABI에서는 다음 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="13d14b8a88583d4801772d41f78d731f585ac76d" translate="yes" xml:space="preserve">
          <source>Enables the 32-bit coprocessor&amp;rsquo;s instructions.</source>
          <target state="translated">32 비트 보조 프로세서의 명령어를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="37f8bcfc01e8c9f171283b3e6b96664748ea2f0b" translate="yes" xml:space="preserve">
          <source>Enables the 64-bit coprocessor&amp;rsquo;s instructions.</source>
          <target state="translated">64 비트 보조 프로세서의 명령어를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="866afe4dc503faaed460c73ebf4e30e8a9116810" translate="yes" xml:space="preserve">
          <source>Enables the &lt;code&gt;abs&lt;/code&gt; instruction, which is the absolute difference between two registers.</source>
          <target state="translated">&lt;code&gt;abs&lt;/code&gt; 레지스터를 활성화합니다. 이는 두 레지스터 간의 절대 차이입니다.</target>
        </trans-unit>
        <trans-unit id="50cf3b6e541adf62bd77b142fc53a61d05fc7c9c" translate="yes" xml:space="preserve">
          <source>Enables the &lt;code&gt;ave&lt;/code&gt; instruction, which computes the average of two registers.</source>
          <target state="translated">두 레지스터의 평균을 계산 하는 &lt;code&gt;ave&lt;/code&gt; 명령어를 활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="2e8478914d75d996b9e9464d4ca7119db6662af4" translate="yes" xml:space="preserve">
          <source>Enables the &lt;code&gt;clip&lt;/code&gt; instruction. Note that</source>
          <target state="translated">&lt;code&gt;clip&lt;/code&gt; 명령을 활성화합니다 . 참고</target>
        </trans-unit>
        <trans-unit id="e97f2d1656d0f25d2a745cdd7d099a3de6f71833" translate="yes" xml:space="preserve">
          <source>Enables the &lt;code&gt;div&lt;/code&gt; and &lt;code&gt;divu&lt;/code&gt; instructions.</source>
          <target state="translated">&lt;code&gt;div&lt;/code&gt; 및 &lt;code&gt;divu&lt;/code&gt; 명령어를 활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="13fbaebc3f1567a809a1ff5ab5607726671f6a6a" translate="yes" xml:space="preserve">
          <source>Enables the &lt;code&gt;leadz&lt;/code&gt; (leading zero) instruction.</source>
          <target state="translated">&lt;code&gt;leadz&lt;/code&gt; (제로 선행) 명령을 활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="1da519d84df5ff1b705dd7abe77d948ec006a771" translate="yes" xml:space="preserve">
          <source>Enables the &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; instructions.</source>
          <target state="translated">&lt;code&gt;min&lt;/code&gt; 및 &lt;code&gt;max&lt;/code&gt; 명령을 활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="4da5357bac4df4fb4da7516696ce5726e90631ac" translate="yes" xml:space="preserve">
          <source>Enables the &lt;code&gt;repeat&lt;/code&gt; and &lt;code&gt;erepeat&lt;/code&gt; instructions, used for low-overhead looping.</source>
          <target state="translated">수 있도록 &lt;code&gt;repeat&lt;/code&gt; 및 &lt;code&gt;erepeat&lt;/code&gt; 낮은 오버 헤드 루프에 사용 지침을.</target>
        </trans-unit>
        <trans-unit id="b4f230bdb2809992da1b8ee11728eb1397ea6487" translate="yes" xml:space="preserve">
          <source>Enables the bit operation instructions&amp;mdash;bit test (&lt;code&gt;btstm&lt;/code&gt;), set (&lt;code&gt;bsetm&lt;/code&gt;), clear (&lt;code&gt;bclrm&lt;/code&gt;), invert (&lt;code&gt;bnotm&lt;/code&gt;), and test-and-set (&lt;code&gt;tas&lt;/code&gt;).</source>
          <target state="translated">비트 테스트 명령 (비트 테스트 ( &lt;code&gt;btstm&lt;/code&gt; ), 설정 ( &lt;code&gt;bsetm&lt;/code&gt; ), 클리어 ( &lt;code&gt;bclrm&lt;/code&gt; ), 반전 ( &lt;code&gt;bnotm&lt;/code&gt; ) 및 테스트 및 설정 ( &lt;code&gt;tas&lt;/code&gt; ))을 활성화 합니다.</target>
        </trans-unit>
        <trans-unit id="650b34422af73f1c39adc7884ebaf0f44be9cbe6" translate="yes" xml:space="preserve">
          <source>Enables the coprocessor instructions. By default, this is a 32-bit coprocessor. Note that the coprocessor is normally enabled via the</source>
          <target state="translated">보조 프로세서 명령어를 활성화합니다. 기본적으로 이것은 32 비트 코 프로세서입니다. 보조 프로세서는 일반적으로</target>
        </trans-unit>
        <trans-unit id="849d54c65b67142ad3610bf0ff41505e124671a1" translate="yes" xml:space="preserve">
          <source>Enables the cryptographic instructions on &amp;lsquo;</source>
          <target state="translated">'에서 암호화 지침을 사용하도록 설정합니다.</target>
        </trans-unit>
        <trans-unit id="e300897cde7331a4be041e33bbcd7fc9ca650ebe" translate="yes" xml:space="preserve">
          <source>Enables the generation of position independent data. When enabled any access to constant data is done via an offset from a base address held in a register. This allows the location of constant data to be determined at run time without requiring the executable to be relocated, which is a benefit to embedded applications with tight memory constraints. Data that can be modified is not affected by this option.</source>
          <target state="translated">위치 독립적 인 데이터를 생성 할 수 있습니다. 활성화되면 상수 데이터에 대한 액세스는 레지스터에있는 기본 주소의 오프셋을 통해 수행됩니다. 따라서 실행 파일을 재배치 할 필요없이 런타임에 상수 데이터의 위치를 ​​결정할 수 있습니다. 이는 메모리 제약이 엄격한 임베디드 응용 프로그램의 이점입니다. 수정할 수있는 데이터는이 옵션의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cf1918bfd22c209206d2846ea3d88a19e3a73f7d" translate="yes" xml:space="preserve">
          <source>Enables the loop invariant motion pass in the RTL loop optimizer. Enabled at level</source>
          <target state="translated">RTL 루프 최적화 프로그램에서 루프 불변 모션 패스를 활성화합니다. 레벨에서 사용 가능</target>
        </trans-unit>
        <trans-unit id="ecd974872f6eca7f7d4ae7dac04ee2a0a333973d" translate="yes" xml:space="preserve">
          <source>Enables the multiplication and multiply-accumulate instructions.</source>
          <target state="translated">곱셈 및 곱셈 누적 명령어를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="7fc40693c14939b54a70a171fa80eb19af8d1f4b" translate="yes" xml:space="preserve">
          <source>Enables the saturation instructions. Note that the compiler does not currently generate these itself, but this option is included for compatibility with other tools, like &lt;code&gt;as&lt;/code&gt;.</source>
          <target state="translated">채도 지시를 활성화합니다. 컴파일러는 현재 이러한 자체를 생성하지 않지만,이 옵션을 같은 다른 도구와의 호환성을 위해 포함되어 있습니다 &lt;code&gt;as&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e1d7284a520ac6d5afcc167354eeade161094006" translate="yes" xml:space="preserve">
          <source>Enables the use of a linker plugin during link-time optimization. This option relies on plugin support in the linker, which is available in gold or in GNU ld 2.21 or newer.</source>
          <target state="translated">링크 타임 최적화 중에 링커 플러그인을 사용할 수 있습니다. 이 옵션은 골드 또는 GNU ld 2.21 이상에서 사용할 수있는 링커의 플러그인 지원에 의존합니다.</target>
        </trans-unit>
        <trans-unit id="118989c6873866bc4e811127fbd742299b49d5aa" translate="yes" xml:space="preserve">
          <source>Enables the use of the e3v5 LOOP instruction. The use of this instruction is not enabled by default when the e3v5 architecture is selected because its use is still experimental.</source>
          <target state="translated">e3v5 LOOP 명령어를 사용할 수 있습니다. 이 명령어는 e3v5 아키텍처가 아직 실험적이기 때문에 선택 될 때 기본적으로 활성화되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e218c1fa9772e443eea87ffbfc5f0dee5a840cd5" translate="yes" xml:space="preserve">
          <source>Enables using Neon to handle scalar 64-bits operations. This is disabled by default since the cost of moving data from core registers to Neon is high.</source>
          <target state="translated">Neon을 사용하여 스칼라 64 비트 작업을 처리 할 수 ​​있습니다. 코어 레지스터에서 네온으로 데이터를 이동하는 비용이 높기 때문에 기본적으로 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="93ce405e36a27a5a639a5f340a06317ff8160589" translate="yes" xml:space="preserve">
          <source>Enabling profiling and extra run-time error checking.</source>
          <target state="translated">프로파일 링 및 추가 런타임 오류 검사 사용</target>
        </trans-unit>
        <trans-unit id="e90d4bd4a0cd6ad11d1267ee1ab362b6754a6129" translate="yes" xml:space="preserve">
          <source>Enabling this option effectively enables the following warnings:</source>
          <target state="translated">이 옵션을 활성화하면 다음 경고가 효과적으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="5821fec7ee87050117e2081a31b307f34868a8ad" translate="yes" xml:space="preserve">
          <source>Encoding</source>
          <target state="translated">Encoding</target>
        </trans-unit>
        <trans-unit id="1819780111faf7544a66daa1d16d7611734230e4" translate="yes" xml:space="preserve">
          <source>End lock elision on a lock variable. Memory order must be &lt;code&gt;__ATOMIC_RELEASE&lt;/code&gt; or stronger.</source>
          <target state="translated">잠금 변수에서 종료 잠금 제거. 메모리 순서는 &lt;code&gt;__ATOMIC_RELEASE&lt;/code&gt; 이상 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="69cc11cd813a9fd03e4e1fc6cf5b510b36e19495" translate="yes" xml:space="preserve">
          <source>Enforces total ordering with all other &lt;code&gt;__ATOMIC_SEQ_CST&lt;/code&gt; operations.</source>
          <target state="translated">다른 모든 &lt;code&gt;__ATOMIC_SEQ_CST&lt;/code&gt; 작업 과 함께 전체 주문을 시행 합니다.</target>
        </trans-unit>
        <trans-unit id="73b1dc6c07adcccbcc5d5e8b0eff931a874c6d38" translate="yes" xml:space="preserve">
          <source>Enumerator Attributes</source>
          <target state="translated">열거 자 속성</target>
        </trans-unit>
        <trans-unit id="761809a73bf6c1d0fb389d9bcb324c7d577436ca" translate="yes" xml:space="preserve">
          <source>Env vars that affect GCC.</source>
          <target state="translated">GCC에 영향을 미치는 환경 변수.</target>
        </trans-unit>
        <trans-unit id="ea26afcbc28cf64cc5104756e2576f023e89221a" translate="yes" xml:space="preserve">
          <source>Epiphany&amp;mdash;</source>
          <target state="translated">Epiphany&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="fdd6abe4d3e43555fd6a8a4c1cf45b848e487e53" translate="yes" xml:space="preserve">
          <source>Equivalent to</source>
          <target state="translated">에 해당</target>
        </trans-unit>
        <trans-unit id="0492deafa8eba22fc0afe8f6e0c0ba64239ba223" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;r&lt;/code&gt;; retained for backwards compatibility.</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; 과 같습니다 . 이전 버전과의 호환성을 위해 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="5ca07fcd394d3a2e5866991bf00cbd021a139de4" translate="yes" xml:space="preserve">
          <source>Errors in the 1990 ISO C standard were corrected in two Technical Corrigenda published in 1994 and 1996. GCC does not support the uncorrected version.</source>
          <target state="translated">1990 년 ISO C 표준의 오류는 1994 년과 1996 년에 발표 된 2 개의 기술 코리 젠다에서 수정되었습니다. GCC는 수정되지 않은 버전을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9bd134a89f5b4b95f3127d3f912224b4af14b70c" translate="yes" xml:space="preserve">
          <source>Errors in the 1999 ISO C standard were corrected in three Technical Corrigenda published in 2001, 2004 and 2007. GCC does not support the uncorrected version.</source>
          <target state="translated">1999 년 ISO C 표준의 오류는 2001 년, 2004 년 및 2007 년에 발표 된 3 개의 Technical Corrigenda에서 수정되었습니다. GCC는 수정되지 않은 버전을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6e25566cabac14a5da9bfa8653af8b052717aff4" translate="yes" xml:space="preserve">
          <source>Estimate on average number of instructions that are executed before prefetch finishes. The distance prefetched ahead is proportional to this constant. Increasing this number may also lead to less streams being prefetched (see</source>
          <target state="translated">프리 페치가 완료되기 전에 실행되는 평균 명령어 수를 추정하십시오. 미리 가져온 거리는이 상수에 비례합니다. 이 수를 늘리면 프리 페치되는 스트림이 줄어들 수도 있습니다 (참조</target>
        </trans-unit>
        <trans-unit id="72b4ac99601ca6a847d5bc2efd8309225cad447d" translate="yes" xml:space="preserve">
          <source>Evaluate member access, array subscripting, and shift expressions in left-to-right order, and evaluate assignment in right-to-left order, as adopted for C++17. Enabled by default with</source>
          <target state="translated">C ++ 17에 채택 된대로 멤버 액세스, 배열 첨자 및 시프트 표현식을 왼쪽에서 오른쪽 순서로 평가하고 오른쪽에서 왼쪽 순서로 지정을 평가하십시오. 기본적으로 활성화</target>
        </trans-unit>
        <trans-unit id="ed6e92089eb6b24b347c4f30cb7670720994b11e" translate="yes" xml:space="preserve">
          <source>Even if</source>
          <target state="translated">설사</target>
        </trans-unit>
        <trans-unit id="8ba62c67150da80165ae50905d020111dae00562" translate="yes" xml:space="preserve">
          <source>Even if a recovery mode is turned on the compiler side, it needs to be also enabled on the runtime library side, otherwise the failures are still fatal. The runtime library defaults to &lt;code&gt;halt_on_error=0&lt;/code&gt; for ThreadSanitizer and UndefinedBehaviorSanitizer, while default value for AddressSanitizer is &lt;code&gt;halt_on_error=1&lt;/code&gt;. This can be overridden through setting the &lt;code&gt;halt_on_error&lt;/code&gt; flag in the corresponding environment variable.</source>
          <target state="translated">복구 모드가 컴파일러 쪽에서 켜져 있어도 런타임 라이브러리 쪽에서도 활성화해야합니다. 그렇지 않으면 오류가 여전히 치명적입니다. ThreadSanitizer 및 UndefinedBehaviorSanitizer 의 경우 런타임 라이브러리의 기본값은 &lt;code&gt;halt_on_error=0&lt;/code&gt; 이고 AddressSanitizer의 기본값은 &lt;code&gt;halt_on_error=1&lt;/code&gt; 입니다. 이는 해당 환경 변수에서 &lt;code&gt;halt_on_error&lt;/code&gt; 플래그 를 설정하여 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="da53370f643fa43e1823dc15023009c950cb897a" translate="yes" xml:space="preserve">
          <source>Even if a zero-length bit-field is not followed by a normal bit-field, it may still affect the alignment of the structure:</source>
          <target state="translated">길이가 0 인 비트 필드 뒤에 일반 비트 필드가없는 경우에도 구조의 정렬에 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b825b64ce454de632ebee37b594db5436e47422" translate="yes" xml:space="preserve">
          <source>Even if this switch is enabled, not all function calls are turned into long calls. The heuristic is that static functions, functions that have the &lt;code&gt;short_call&lt;/code&gt; attribute, functions that are inside the scope of a &lt;code&gt;#pragma no_long_calls&lt;/code&gt; directive, and functions whose definitions have already been compiled within the current compilation unit are not turned into long calls. The exceptions to this rule are that weak function definitions, functions with the &lt;code&gt;long_call&lt;/code&gt; attribute or the &lt;code&gt;section&lt;/code&gt; attribute, and functions that are within the scope of a &lt;code&gt;#pragma long_calls&lt;/code&gt; directive are always turned into long calls.</source>
          <target state="translated">이 스위치를 사용하더라도 모든 기능 호출이 긴 호출로 변환되는 것은 아닙니다. 휴리스틱은 정적 함수, &lt;code&gt;short_call&lt;/code&gt; 속성 이있는 함수, &lt;code&gt;#pragma no_long_calls&lt;/code&gt; 지시문 범위 내에있는 함수 및 현재 컴파일 단위 내에서 정의가 이미 컴파일 된 함수는 긴 호출로 변환되지 않는다는 것입니다. 이 규칙의 예외는 약한 함수 정의, &lt;code&gt;long_call&lt;/code&gt; 속성 또는 &lt;code&gt;section&lt;/code&gt; 속성이있는 함수 및 &lt;code&gt;#pragma long_calls&lt;/code&gt; 지시문 의 범위 내에있는 함수 는 항상 긴 호출로 바뀌는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a177b98fd2580c16f017a412cd7670171b404cf0" translate="yes" xml:space="preserve">
          <source>Even if you specify</source>
          <target state="translated">지정한 경우에도</target>
        </trans-unit>
        <trans-unit id="026e995923c6387a8240f24bd1c3774f9d66883c" translate="yes" xml:space="preserve">
          <source>Even register</source>
          <target state="translated">등록</target>
        </trans-unit>
        <trans-unit id="1873ee5db4140cfb18dab53240c9f43c6ee8669a" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;sum&lt;/code&gt; is accumulated in the loop, no use is made of that summation, so the accumulation can be removed.</source>
          <target state="translated">루프에 &lt;code&gt;sum&lt;/code&gt; 가 누적 되더라도 해당 합계 는 사용되지 않으므로 누적을 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b22f73b585732fa4671fb4003533ee7b0a1cf1d" translate="yes" xml:space="preserve">
          <source>Even-numbered D register</source>
          <target state="translated">짝수 D 레지스터</target>
        </trans-unit>
        <trans-unit id="7a684983474ccc7c72520e56a87f8aeb051b1c6b" translate="yes" xml:space="preserve">
          <source>Even-numbered accumulator register.</source>
          <target state="translated">짝수 누산기 레지스터.</target>
        </trans-unit>
        <trans-unit id="5d57aa9755d20359a2247e4c26c56f18f53bb2c4" translate="yes" xml:space="preserve">
          <source>Every data object has an alignment requirement. The alignment requirement for all data except structures, unions, and arrays is either the size of the object or the current packing size (specified with either the &lt;code&gt;aligned&lt;/code&gt; attribute or the &lt;code&gt;pack&lt;/code&gt; pragma), whichever is less. For structures, unions, and arrays, the alignment requirement is the largest alignment requirement of its members. Every object is allocated an offset so that:</source>
          <target state="translated">모든 데이터 개체에는 정렬 요구 사항이 있습니다. 구조체, 공용체 및 배열을 제외한 모든 데이터의 정렬 요구 사항은 객체의 크기 또는 현재 패킹 크기 ( &lt;code&gt;aligned&lt;/code&gt; 속성 또는 &lt;code&gt;pack&lt;/code&gt; pragma로 지정됨 ) 중 작은 값입니다. 구조체, 공용체 및 배열의 ​​경우 정렬 요구 사항은 멤버의 가장 큰 정렬 요구 사항입니다. 모든 객체에는 다음과 같은 오프셋이 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="f8971cb366f8a5972e5437f17d61872668933fb6" translate="yes" xml:space="preserve">
          <source>Exact power of 2</source>
          <target state="translated">2의 정확한 힘</target>
        </trans-unit>
        <trans-unit id="54ce059465b2a026c1f41bec2bf7eb93331ac554" translate="yes" xml:space="preserve">
          <source>Exactly like</source>
          <target state="translated">정확히 같은</target>
        </trans-unit>
        <trans-unit id="ec471d84b36457f0d9d75c03377c9e3cd5f3de93" translate="yes" xml:space="preserve">
          <source>Example of use:</source>
          <target state="translated">사용 예 :</target>
        </trans-unit>
        <trans-unit id="861245b8779c3c0a240081e66f72046983ca7d16" translate="yes" xml:space="preserve">
          <source>Example usage</source>
          <target state="translated">사용법 예</target>
        </trans-unit>
        <trans-unit id="98859dfb330cbeca8950e6e5316d288484dfa387" translate="yes" xml:space="preserve">
          <source>Example usage of these low level built-in functions may look like:</source>
          <target state="translated">이러한 저수준 내장 함수의 사용 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="3203ec56f6623a12f68979ebebcaf218b0674056" translate="yes" xml:space="preserve">
          <source>Examples of code with undefined behavior are &lt;code&gt;a = a++;&lt;/code&gt;, &lt;code&gt;a[n]
= b[n++]&lt;/code&gt; and &lt;code&gt;a[i++] = i;&lt;/code&gt;. Some more complicated cases are not diagnosed by this option, and it may give an occasional false positive result, but in general it has been found fairly effective at detecting this sort of problem in programs.</source>
          <target state="translated">동작이 정의되지 않은 코드의 예는 &lt;code&gt;a = a++;&lt;/code&gt; , &lt;code&gt;a[n] = b[n++]&lt;/code&gt; 및 &lt;code&gt;a[i++] = i;&lt;/code&gt; . 좀 더 복잡한 경우는이 옵션으로 진단되지 않으며 가끔 오 탐지를 유발할 수 있지만 일반적으로 프로그램에서 이러한 종류의 문제를 감지하는 데 상당히 효과적입니다.</target>
        </trans-unit>
        <trans-unit id="ac2978569b0d96ea67fa55ae3fcac3a58dbeaa7e" translate="yes" xml:space="preserve">
          <source>Examples of the use cases for this tool are:</source>
          <target state="translated">이 도구의 사용 사례는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="911d893025886382ab91769b068aa06459b40499" translate="yes" xml:space="preserve">
          <source>Exception handlers differ from interrupt handlers because the system pushes an error code on the stack. An exception handler declaration is similar to that for an interrupt handler, but with a different mandatory function signature. The compiler arranges to pop the error code off the stack before the &lt;code&gt;IRET&lt;/code&gt; instruction.</source>
          <target state="translated">시스템이 스택에서 오류 코드를 푸시하기 때문에 예외 처리기는 인터럽트 처리기와 다릅니다. 예외 처리기 선언은 인터럽트 처리기의 경우와 비슷하지만 필수 함수 서명이 다릅니다. 컴파일러는 &lt;code&gt;IRET&lt;/code&gt; 명령 전에 오류 코드를 스택에서 팝합니다 .</target>
        </trans-unit>
        <trans-unit id="d60ce999e28bc42ef5590e1790afd26bd6f33f60" translate="yes" xml:space="preserve">
          <source>Exception handlers should only be used for exceptions that push an error code; you should use an interrupt handler in other cases. The system will crash if the wrong kind of handler is used.</source>
          <target state="translated">예외 처리기는 오류 코드를 발생시키는 예외에만 사용해야합니다. 다른 경우에는 인터럽트 처리기를 사용해야합니다. 잘못된 종류의 핸들러를 사용하면 시스템이 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="61c358f1bb209146fb6ebbb188045ae7738fdddb" translate="yes" xml:space="preserve">
          <source>Execution and Data Prediction Restriction Instructions.</source>
          <target state="translated">실행 및 데이터 예측 제한 지침.</target>
        </trans-unit>
        <trans-unit id="cd06a6fd64c8b50d4558cb3316fd26ee9feb5746" translate="yes" xml:space="preserve">
          <source>Expand &lt;code&gt;adddi3&lt;/code&gt; and &lt;code&gt;subdi3&lt;/code&gt; at RTL generation time into &lt;code&gt;add.f&lt;/code&gt;, &lt;code&gt;adc&lt;/code&gt; etc. This option is deprecated.</source>
          <target state="translated">RTL 생성시 &lt;code&gt;adddi3&lt;/code&gt; 및 &lt;code&gt;subdi3&lt;/code&gt; 을 &lt;code&gt;add.f&lt;/code&gt; , &lt;code&gt;adc&lt;/code&gt; 등 으로 확장하십시오 .이 옵션은 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ad01d735326a2f6603f39ee595dd5b05ec416e8b" translate="yes" xml:space="preserve">
          <source>Expand into an inline loop.</source>
          <target state="translated">인라인 루프로 확장하십시오.</target>
        </trans-unit>
        <trans-unit id="5ddf0ba44f58c348b4ec4063056d25a8b4689f7a" translate="yes" xml:space="preserve">
          <source>Expand using i386 &lt;code&gt;rep&lt;/code&gt; prefix of the specified size.</source>
          <target state="translated">지정된 크기의 i386 &lt;code&gt;rep&lt;/code&gt; 접두사를 사용하여 확장하십시오 .</target>
        </trans-unit>
        <trans-unit id="7720f0269a2d383f2dd786328047f312351d0105" translate="yes" xml:space="preserve">
          <source>Explain what alignment considerations lead to the decision to make an instruction short or long.</source>
          <target state="translated">어떤 정렬 고려 사항이 지시를 짧게 또는 길게 결정하기로 결정했는지 설명하십시오.</target>
        </trans-unit>
        <trans-unit id="69ccd30207ce48099a948be1541f4d6a441981f8" translate="yes" xml:space="preserve">
          <source>Explicit instantiations can be used for the largest or most frequently duplicated instances, without having to know exactly which other instances are used in the rest of the program. You can scatter the explicit instantiations throughout your program, perhaps putting them in the translation units where the instances are used or the translation units that define the templates themselves; you can put all of the explicit instantiations you need into one big file; or you can create small files like</source>
          <target state="translated">프로그램의 나머지 부분에서 어떤 다른 인스턴스가 사용되는지 정확히 알 필요없이 가장 큰 인스턴스 또는 가장 자주 복제되는 인스턴스에 대해 명시 적 인스턴스를 사용할 수 있습니다. 프로그램 전체에 명시 적 인스턴스를 분산시켜 인스턴스가 사용되는 변환 단위 또는 템플리트 자체를 정의하는 변환 단위에 넣을 수 있습니다. 필요한 모든 명시 적 인스턴스를 하나의 큰 파일에 넣을 수 있습니다. 또는 작은 파일을 만들 수 있습니다</target>
        </trans-unit>
        <trans-unit id="83042939fc50e1e36ef864fc1e78eae1c62725bf" translate="yes" xml:space="preserve">
          <source>Explicitly instantiated inline methods are unaffected by this option as their linkage might otherwise cross a shared library boundary. See &lt;a href=&quot;template-instantiation#Template-Instantiation&quot;&gt;Template Instantiation&lt;/a&gt;.</source>
          <target state="translated">명시 적으로 인스턴스화 된 인라인 메소드는 링크가 공유 라이브러리 경계를 넘을 수 있으므로이 옵션의 영향을받지 않습니다. &lt;a href=&quot;template-instantiation#Template-Instantiation&quot;&gt;템플릿 인스턴스화를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="61bd3ccba4b2c3767215774893d82391e0bc09ab" translate="yes" xml:space="preserve">
          <source>Expressions are currently only contracted if</source>
          <target state="translated">표현식은 현재 다음과 같은 경우에만 계약됩니다.</target>
        </trans-unit>
        <trans-unit id="83c4bb072fc47e954ad84b1ea046adec27e854fd" translate="yes" xml:space="preserve">
          <source>Expressions that may be cast to the union type are those whose type matches at least one of the members of the union. Thus, given the following union and variables:</source>
          <target state="translated">공용체 유형으로 캐스트 될 수있는 표현식은 형식이 공용체 멤버 중 하나 이상과 일치하는 표현식입니다. 따라서 다음과 같은 합집합과 변수가 주어집니다.</target>
        </trans-unit>
        <trans-unit id="ed9daef21d2e4305e648aee577dd1d6036550745" translate="yes" xml:space="preserve">
          <source>Extend (do not extend) the</source>
          <target state="translated">연장 (확장하지 않음)</target>
        </trans-unit>
        <trans-unit id="20891f4ff37ed22f4675dae3faaf487875cf701e" translate="yes" xml:space="preserve">
          <source>Extend the current ABI with a particular extension, or remove such extension. Valid values are &amp;lsquo;</source>
          <target state="translated">특정 확장으로 현재 ABI를 확장하거나 해당 확장을 제거하십시오. 유효한 값은 '</target>
        </trans-unit>
        <trans-unit id="91653b5f0401d6aa2a22ebdd6efdf9699bdaeb42" translate="yes" xml:space="preserve">
          <source>Extended &lt;code&gt;asm&lt;/code&gt; statements have to be inside a C function, so to write inline assembly language at file scope (&amp;ldquo;top-level&amp;rdquo;), outside of C functions, you must use basic &lt;code&gt;asm&lt;/code&gt;. You can use this technique to emit assembler directives, define assembly language macros that can be invoked elsewhere in the file, or write entire functions in assembly language. Basic &lt;code&gt;asm&lt;/code&gt; statements outside of functions may not use any qualifiers.</source>
          <target state="translated">확장 된 &lt;code&gt;asm&lt;/code&gt; 문은 C 함수 내에 있어야하므로 C 함수 외부의 파일 범위 ( &quot;최상위 수준&quot;)에서 인라인 어셈블리 언어를 작성하려면 기본 &lt;code&gt;asm&lt;/code&gt; 을 사용해야합니다 . 이 기술을 사용하여 어셈블러 지시문을 생성하거나 파일의 다른 곳에서 호출 할 수있는 어셈블리 언어 매크로를 정의하거나 전체 함수를 어셈블리 언어로 작성할 수 있습니다. 함수 외부의 기본 &lt;code&gt;asm&lt;/code&gt; 문은 한정자를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="04a315d0cc75470cd36dfd3cb992c3efb5b94ebf" translate="yes" xml:space="preserve">
          <source>Extended alignments up to &lt;em&gt;2^{28}&lt;/em&gt; (bytes) are supported for objects of automatic storage duration. Alignments supported for objects of static and thread storage duration are determined by the ABI.</source>
          <target state="translated">자동 스토리지 기간의 오브젝트에 대해 최대 &lt;em&gt;2 ^ {28}&lt;/em&gt; (바이트)의 확장 정렬 이 지원됩니다. 정적 및 스레드 저장 기간의 개체에 지원되는 정렬은 ABI에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="342b07a4e48b541946d49b2270415ae84b1aef83" translate="yes" xml:space="preserve">
          <source>Extended registers are not stored on stack before execution of function with monitor attribute. Default option is</source>
          <target state="translated">확장 된 레지스터는 모니터 속성으로 기능을 실행하기 전에 스택에 저장되지 않습니다. 기본 옵션은</target>
        </trans-unit>
        <trans-unit id="57cf6f586241383946ebaa10651980906e2e7008" translate="yes" xml:space="preserve">
          <source>Extended registers are stored on stack before execution of function with monitor attribute. Default option is</source>
          <target state="translated">확장 레지스터는 모니터 속성으로 기능을 실행하기 전에 스택에 저장됩니다. 기본 옵션은</target>
        </trans-unit>
        <trans-unit id="c9dbca1f0ee851a1a4128829e444f15ff917ef20" translate="yes" xml:space="preserve">
          <source>Extra time accounted by inliner for function overhead such as time needed to execute function prologue and epilogue</source>
          <target state="translated">함수 프롤로그 및 에필로그를 실행하는 데 필요한 시간과 같은 함수 오버 헤드로 인해 인라이너에서 추가 시간 처리</target>
        </trans-unit>
        <trans-unit id="e69f20e9f683920d3fb4329abd951e878b1f9372" translate="yes" xml:space="preserve">
          <source>F</source>
          <target state="translated">F</target>
        </trans-unit>
        <trans-unit id="6b84b9421bc7074ef9cc3088b04a6a18d77c5b2a" translate="yes" xml:space="preserve">
          <source>FMA instructions.</source>
          <target state="translated">FMA 지침.</target>
        </trans-unit>
        <trans-unit id="cbf2cb3fe36db407f3a3f0c5e7fef7fc69c6ce00" translate="yes" xml:space="preserve">
          <source>FMA4 instructions.</source>
          <target state="translated">FMA4 지침.</target>
        </trans-unit>
        <trans-unit id="b911450c0baee87cf3722095b3e43b717fb436bb" translate="yes" xml:space="preserve">
          <source>FP or VSX register to hold 64-bit doubles for direct moves or NO_REGS.</source>
          <target state="translated">직접 이동 또는 NO_REGS를 위해 64 비트 더블을 보유하는 FP 또는 VSX 레지스터.</target>
        </trans-unit>
        <trans-unit id="faed2456bafb04f8c1fb3d816c3c01f0fb54a75c" translate="yes" xml:space="preserve">
          <source>FP or VSX register to hold 64-bit integers for VSX insns or NO_REGS.</source>
          <target state="translated">VSX insns 또는 NO_REGS에 대해 64 비트 정수를 보유하는 FP 또는 VSX 레지스터</target>
        </trans-unit>
        <trans-unit id="09f3e1a89b6305e70a6393d549d66dbbcfd2f8f3" translate="yes" xml:space="preserve">
          <source>FP or VSX register to hold 64-bit integers for direct moves or NO_REGS.</source>
          <target state="translated">직접 이동 또는 NO_REGS를 위해 64 비트 정수를 보유하는 FP 또는 VSX 레지스터.</target>
        </trans-unit>
        <trans-unit id="ec3d1f378b46e7073f89e8d2b44ffed3f4925fb8" translate="yes" xml:space="preserve">
          <source>FP or VSX register to perform ISA 2.07 float ops or NO_REGS.</source>
          <target state="translated">ISA 2.07 float ops 또는 NO_REGS를 수행하기위한 FP 또는 VSX 레지스터.</target>
        </trans-unit>
        <trans-unit id="c07c5ae5e3671f1039b7da098eb0348a7624af7b" translate="yes" xml:space="preserve">
          <source>FP or VSX register to perform float operations under</source>
          <target state="translated">FP 또는 VSX 레지스터에서 플로트 연산을 수행</target>
        </trans-unit>
        <trans-unit id="a924751782c4ee4b5b496793046fc57512ab59f9" translate="yes" xml:space="preserve">
          <source>FP register if</source>
          <target state="translated">FP 등록</target>
        </trans-unit>
        <trans-unit id="5b1d99e5f9118d7c70848e6ad6167bba8b0b23d3" translate="yes" xml:space="preserve">
          <source>FPSCR</source>
          <target state="translated">FPSCR</target>
        </trans-unit>
        <trans-unit id="ff875f9855f1361e4b30af2d77d0d9c23d4bdca2" translate="yes" xml:space="preserve">
          <source>FRV&amp;mdash;</source>
          <target state="translated">FRV&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="230d241b3d82558160cd5187f1fe9d9c435b18d5" translate="yes" xml:space="preserve">
          <source>FSF GCC on Darwin does not create &amp;ldquo;fat&amp;rdquo; object files; it creates an object file for the single architecture that GCC was built to target. Apple&amp;rsquo;s GCC on Darwin does create &amp;ldquo;fat&amp;rdquo; files if multiple</source>
          <target state="translated">Darwin의 FSF GCC는 &quot;지방&quot;개체 파일을 만들지 않습니다. GCC가 대상으로 구축 한 단일 아키텍처에 대한 객체 파일을 생성합니다. Darwin에있는 Apple의 GCC는 여러 개의 &quot;지방&quot;파일을 생성합니다</target>
        </trans-unit>
        <trans-unit id="7a156574143e4ca84e24da6dfdb279cf456cca04" translate="yes" xml:space="preserve">
          <source>FT32&amp;mdash;</source>
          <target state="translated">FT32&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="599d4afb33240eb91ea2840bb9ba8f1ff44bf581" translate="yes" xml:space="preserve">
          <source>Fat LTO objects are object files that contain both the intermediate language and the object code. This makes them usable for both LTO linking and normal linking. This option is effective only when compiling with</source>
          <target state="translated">팻 LTO 객체는 중간 언어와 객체 코드를 모두 포함하는 객체 파일입니다. 이를 통해 LTO 연결과 일반 연결 모두에 사용할 수 있습니다. 이 옵션은 컴파일 할 때만 유효합니다</target>
        </trans-unit>
        <trans-unit id="ad565d9d01d0e0bf91fd6a8532f6d81613338901" translate="yes" xml:space="preserve">
          <source>Feature</source>
          <target state="translated">Feature</target>
        </trans-unit>
        <trans-unit id="909a10c01414726d2e86792cc51fea9d589c8fb6" translate="yes" xml:space="preserve">
          <source>Feature Modifiers</source>
          <target state="translated">기능 수정 자</target>
        </trans-unit>
        <trans-unit id="c796b811ac5dce8d8e36d70db0e07e63b27d5eab" translate="yes" xml:space="preserve">
          <source>Feature modifiers used with</source>
          <target state="translated">함께 사용되는 기능 수정 자</target>
        </trans-unit>
        <trans-unit id="aa0dd17c258c743dbea5c193ddf09bb6cebf5964" translate="yes" xml:space="preserve">
          <source>Fields of the &lt;var&gt;branch&lt;/var&gt; element have following semantics:</source>
          <target state="translated">&lt;var&gt;branch&lt;/var&gt; 요소의 필드 는 다음과 같은 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="9cc6e9443d376e5757bc3441d57c3f310bf11770" translate="yes" xml:space="preserve">
          <source>Fields of the &lt;var&gt;file&lt;/var&gt; element have following semantics:</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt; 요소의 필드 는 다음과 같은 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="95d9f92882f18f3b5a67ac3eeafb040cc8cd3ea3" translate="yes" xml:space="preserve">
          <source>Fields of the &lt;var&gt;function&lt;/var&gt; element have following semantics:</source>
          <target state="translated">&lt;var&gt;function&lt;/var&gt; 요소의 필드 는 다음과 같은 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="55692b6d4a213073df2d182e70897f1d18b6852c" translate="yes" xml:space="preserve">
          <source>Fields of the root element have following semantics:</source>
          <target state="translated">루트 요소의 필드는 다음과 같은 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="fba211bc33a4751c92e11eae269c5fe4195a12b5" translate="yes" xml:space="preserve">
          <source>Finally &amp;lsquo;</source>
          <target state="translated">드디어 '</target>
        </trans-unit>
        <trans-unit id="24e09f2eaae1d9afb97c63e8aa6a65a24f91f73b" translate="yes" xml:space="preserve">
          <source>Finally if the parameter is &lt;code&gt;&quot;&lt;var&gt;name2&lt;/var&gt;@@&lt;var&gt;nodename&lt;/var&gt;&quot;&lt;/code&gt; then in addition to creating a symbol version (as if &lt;code&gt;&quot;&lt;var&gt;name2&lt;/var&gt;@&lt;var&gt;nodename&lt;/var&gt;&quot;&lt;/code&gt; was used) the version will be also used to resolve &lt;var&gt;name2&lt;/var&gt; by the linker.</source>
          <target state="translated">마지막으로 매개 변수가 &lt;code&gt;&quot;&lt;var&gt;name2&lt;/var&gt;@@&lt;var&gt;nodename&lt;/var&gt;&quot;&lt;/code&gt; 이면 심볼 버전을 만드는 것 외에도 ( &lt;code&gt;&quot;&lt;var&gt;name2&lt;/var&gt;@&lt;var&gt;nodename&lt;/var&gt;&quot;&lt;/code&gt; 이 사용 된 것처럼 ) 버전은 링커에 의해 &lt;var&gt;name2&lt;/var&gt; 를 확인 하는데도 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="889bce84d14bf80370f700a385229e627febe04d" translate="yes" xml:space="preserve">
          <source>Finally, GCC will examine &amp;lsquo;</source>
          <target state="translated">마지막으로 GCC는 '</target>
        </trans-unit>
        <trans-unit id="fa45d699cd27babdae75f4a8d69ed2b5379e7a87" translate="yes" xml:space="preserve">
          <source>Finally, consider:</source>
          <target state="translated">마지막으로 다음을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="6901050dc8495daab10889e0ec9cf3617e7fb433" translate="yes" xml:space="preserve">
          <source>Finally, note how we declared the &lt;code&gt;len&lt;/code&gt; argument and the return value to be of type &lt;code&gt;unsigned long&lt;/code&gt;. They could also be declared to be of type &lt;code&gt;unsigned int&lt;/code&gt; and everything would still work.</source>
          <target state="translated">마지막으로 &lt;code&gt;len&lt;/code&gt; 인수와 반환 값을 &lt;code&gt;unsigned long&lt;/code&gt; 유형으로 선언 한 방법에 주목하십시오 . 또한 &lt;code&gt;unsigned int&lt;/code&gt; 유형으로 선언 될 수 있으며 모든 것이 여전히 작동합니다.</target>
        </trans-unit>
        <trans-unit id="e5f1ab577d27769ef2407d2da5789ec6bcd34e2a" translate="yes" xml:space="preserve">
          <source>Finally, there is a complication when encoding &lt;code&gt;const char *&lt;/code&gt; versus &lt;code&gt;char * const&lt;/code&gt;. Because &lt;code&gt;char *&lt;/code&gt; is encoded as &lt;code&gt;*&lt;/code&gt; and not as &lt;code&gt;^c&lt;/code&gt;, there is no way to express the fact that &lt;code&gt;r&lt;/code&gt; applies to the pointer or to the pointee.</source>
          <target state="translated">마지막으로 &lt;code&gt;const char *&lt;/code&gt; 와 &lt;code&gt;char * const&lt;/code&gt; 인코딩 할 때 문제가 발생 합니다. 때문에 &lt;code&gt;char *&lt;/code&gt; 로 부호화 &lt;code&gt;*&lt;/code&gt; 및하지 &lt;code&gt;^c&lt;/code&gt; 있다는 사실을 표현하는 방법이 없다 &lt;code&gt;r&lt;/code&gt; 포인터 나 pointee 적용이.</target>
        </trans-unit>
        <trans-unit id="8d30428380add9f793c9b319edf17d149e4e4f73" translate="yes" xml:space="preserve">
          <source>Find the pass dump in a file whose name is composed of three components separated by a period: the name of the source file GCC was invoked to compile, a numeric suffix indicating the pass number followed by the letter &amp;lsquo;</source>
          <target state="translated">이름으로 마침표로 구분 된 세 가지 구성 요소로 구성된 파일에서 패스 덤프를 찾으십시오. 소스 파일 GCC가 컴파일을 위해 호출되어 패스 번호를 나타내는 숫자 접미 부와 '</target>
        </trans-unit>
        <trans-unit id="e29b12881247aeb3ff64dc0cee23e3331d67217f" translate="yes" xml:space="preserve">
          <source>Fine-tune size optimization with regards to instruction lengths and alignment. The recognized values for &lt;var&gt;level&lt;/var&gt; are:</source>
          <target state="translated">명령어 길이 및 정렬과 관련하여 크기를 미세 조정하십시오. &lt;var&gt;level&lt;/var&gt; 에 대해 인식되는 값 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ac0c5ec00d58b3e74a205bd50ea7108335fcb5b8" translate="yes" xml:space="preserve">
          <source>First SSE register (&lt;code&gt;%xmm0&lt;/code&gt;).</source>
          <target state="translated">첫 번째 SSE 레지스터 ( &lt;code&gt;%xmm0&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="846211171f7db5bd2bab9f64d61f4530995ca5a0" translate="yes" xml:space="preserve">
          <source>First, the argument corresponding to a transparent union type can be of any type in the union; no cast is required. Also, if the union contains a pointer type, the corresponding argument can be a null pointer constant or a void pointer expression; and if the union contains a void pointer type, the corresponding argument can be any pointer expression. If the union member type is a pointer, qualifiers like &lt;code&gt;const&lt;/code&gt; on the referenced type must be respected, just as with normal pointer conversions.</source>
          <target state="translated">먼저 투명한 공용체 유형에 해당하는 인수는 공용체의 모든 유형이 될 수 있습니다. 캐스트가 필요하지 않습니다. 또한 공용체에 포인터 유형이 포함 된 경우 해당 인수는 널 포인터 상수 또는 공백 포인터 표현식 일 수 있습니다. 공용체에 void 포인터 유형이 포함 된 경우 해당 인수는 모든 포인터 표현식 일 수 있습니다. 공용체 멤버 형식이 포인터 인 경우 일반 포인터 변환과 마찬가지로 참조 형식의 &lt;code&gt;const&lt;/code&gt; 와 같은 한정자 가 존중되어야합니다.</target>
        </trans-unit>
        <trans-unit id="15ab13a54971de84d7939a64c563f0a383d5df53" translate="yes" xml:space="preserve">
          <source>Fixed form Fortran source code that must be preprocessed (with the traditional preprocessor).</source>
          <target state="translated">사전 처리해야하는 고정 양식 Fortran 소스 코드 (전통적인 전 처리기 사용).</target>
        </trans-unit>
        <trans-unit id="5552528a96a767723e84e4196dd1b4ccd0182f5d" translate="yes" xml:space="preserve">
          <source>Fixed form Fortran source code that should not be preprocessed.</source>
          <target state="translated">전처리해서는 안되는 고정 양식 포트란 소스 코드.</target>
        </trans-unit>
        <trans-unit id="a31ce070cf9649524c3cf990ab1f1ab74aaffaa3" translate="yes" xml:space="preserve">
          <source>Fixed limit on the size of the static frame of functions: when it is topped by a particular function, stack checking is not reliable and a warning is issued by the compiler.</source>
          <target state="translated">정적 함수 프레임의 크기에 대한 고정 된 제한 : 특정 함수가 차지할 때 스택 검사가 신뢰할 수없고 컴파일러에서 경고를 발행합니다.</target>
        </trans-unit>
        <trans-unit id="85452dd45f77555cfc8a81ff291dd73781c80f82" translate="yes" xml:space="preserve">
          <source>Fixed-Point Types.</source>
          <target state="translated">고정 소수점 유형.</target>
        </trans-unit>
        <trans-unit id="9f75981b930fd7189960fca9ba3bbc1796113fd3" translate="yes" xml:space="preserve">
          <source>Fixed-point data values contain fractional and optional integral parts. The format of fixed-point data varies and depends on the target machine.</source>
          <target state="translated">고정 소수점 데이터 값에는 분수 및 선택적 정수 부분이 포함됩니다. 고정 소수점 데이터의 형식은 다양하며 대상 시스템에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="cb9fd0ce1881fdc78c0697ef42b75b52d214196d" translate="yes" xml:space="preserve">
          <source>Fixed-point types are supported by the DWARF debug information format.</source>
          <target state="translated">고정 소수점 유형은 DWARF 디버그 정보 형식에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="265c5eecf02fb4f371ef39bcfe52b0dfc566b452" translate="yes" xml:space="preserve">
          <source>Flag the first routine whose name starts with &lt;var&gt;prefix&lt;/var&gt; as the main routine for the debugger.</source>
          <target state="translated">디버거의 기본 루틴으로 이름이 &lt;var&gt;prefix&lt;/var&gt; 로 시작하는 첫 번째 루틴을 플래그하십시오 .</target>
        </trans-unit>
        <trans-unit id="b3390bf7e3c55aee432834653f4b1f941089ffde" translate="yes" xml:space="preserve">
          <source>Flexible array members are written as &lt;code&gt;contents[]&lt;/code&gt; without the &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">유연한 배열 멤버는 &lt;code&gt;0&lt;/code&gt; 없이 &lt;code&gt;contents[]&lt;/code&gt; 로 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="78dbcf864480c990f48bdd0342e3500b8c1282bd" translate="yes" xml:space="preserve">
          <source>Flexible array members have incomplete type, and so the &lt;code&gt;sizeof&lt;/code&gt; operator may not be applied. As a quirk of the original implementation of zero-length arrays, &lt;code&gt;sizeof&lt;/code&gt; evaluates to zero.</source>
          <target state="translated">유연한 배열 구성원의 유형이 불완전하므로 &lt;code&gt;sizeof&lt;/code&gt; 연산자가 적용되지 않을 수 있습니다. 길이가 0 인 배열의 원래 구현의 단점으로 &lt;code&gt;sizeof&lt;/code&gt; 는 0으로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="417d40e05d0999fe399d7881ccf242563a660e4a" translate="yes" xml:space="preserve">
          <source>Flexible array members may only appear as the last member of a &lt;code&gt;struct&lt;/code&gt; that is otherwise non-empty.</source>
          <target state="translated">유연한 배열 멤버 는 그렇지 않으면 비어 있지 않은 &lt;code&gt;struct&lt;/code&gt; 의 마지막 멤버로만 나타날 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7ffa11ebef97287859a0bb0cd563e4e8b95df556" translate="yes" xml:space="preserve">
          <source>Floating point constant 0.</source>
          <target state="translated">부동 소수점 상수 0.</target>
        </trans-unit>
        <trans-unit id="4560e48bbc91965a1ad028ff4792c55d56a0a598" translate="yes" xml:space="preserve">
          <source>Floating point constant that can be loaded into a register with one instruction per word</source>
          <target state="translated">워드 당 하나의 명령으로 레지스터에로드 할 수있는 부동 소수점 상수</target>
        </trans-unit>
        <trans-unit id="c516f23fc0c0d103a2cd7b68a6433df4fc2451d6" translate="yes" xml:space="preserve">
          <source>Floating point constant that is legal for store immediate</source>
          <target state="translated">즉시 상점에 유효한 부동 소수점 상수</target>
        </trans-unit>
        <trans-unit id="32a95fa9a487a375449247a65d3193bb1004c1f0" translate="yes" xml:space="preserve">
          <source>Floating point constant that is not a 68881 constant</source>
          <target state="translated">68881 상수가 아닌 부동 소수점 상수</target>
        </trans-unit>
        <trans-unit id="79fb00b4bc62aed23a250b86e31fbd72d18840a5" translate="yes" xml:space="preserve">
          <source>Floating point constant zero</source>
          <target state="translated">부동 소수점 상수 제로</target>
        </trans-unit>
        <trans-unit id="af1bda543b578583ca4289ffad142bd3d77692c3" translate="yes" xml:space="preserve">
          <source>Floating point register</source>
          <target state="translated">부동 소수점 레지스터</target>
        </trans-unit>
        <trans-unit id="573ca6d44dc3da178f33a1539aefbe9a7a969613" translate="yes" xml:space="preserve">
          <source>Floating point register (containing 32-bit value)</source>
          <target state="translated">부동 소수점 레지스터 (32 비트 값 포함)</target>
        </trans-unit>
        <trans-unit id="b5c02f93e377f6b8a0b2a78a784d0d990452bae9" translate="yes" xml:space="preserve">
          <source>Floating point register (containing 64-bit value)</source>
          <target state="translated">부동 소수점 레지스터 (64 비트 값 포함)</target>
        </trans-unit>
        <trans-unit id="ef449f8f1e197b3fc12f9a7bbd29815185c01715" translate="yes" xml:space="preserve">
          <source>Floating point register (deprecated)</source>
          <target state="translated">부동 소수점 레지스터 (더 이상 사용되지 않음)</target>
        </trans-unit>
        <trans-unit id="f7558c1a4bb9c6d833aca45e4903e960fa15f358" translate="yes" xml:space="preserve">
          <source>Floating point register if</source>
          <target state="translated">부동 소수점 레지스터</target>
        </trans-unit>
        <trans-unit id="c165ca40457d305eb7d330afdb797521f5de1b77" translate="yes" xml:space="preserve">
          <source>Floating point register if direct moves are available, or NO_REGS.</source>
          <target state="translated">직접 이동이 가능한 경우 부동 소수점 레지스터 또는 NO_REGS</target>
        </trans-unit>
        <trans-unit id="5262899d7f774e7136ab629899288cb3977b1a82" translate="yes" xml:space="preserve">
          <source>Floating point register if the LFIWAX instruction is enabled or NO_REGS.</source>
          <target state="translated">LFIWAX 명령어가 활성화되어 있거나 NO_REGS 인 경우 부동 소수점 레지스터.</target>
        </trans-unit>
        <trans-unit id="37f6e14594705b3a931f7fb11f09da2da0b4cf9c" translate="yes" xml:space="preserve">
          <source>Floating point register if the LFIWZX instruction is enabled or NO_REGS.</source>
          <target state="translated">LFIWZX 명령어가 활성화되었거나 NO_REGS 인 경우 부동 소수점 레지스터.</target>
        </trans-unit>
        <trans-unit id="92eb4ccc2dc9e99f2247ac815df53adacfbc08da" translate="yes" xml:space="preserve">
          <source>Floating point register if the STFIWX instruction is enabled or NO_REGS.</source>
          <target state="translated">STFIWX 명령어가 활성화되거나 NO_REGS 인 경우 부동 소수점 레지스터.</target>
        </trans-unit>
        <trans-unit id="aaae0bc8bed9980f091aa46b02c6dcb5a52b76ec" translate="yes" xml:space="preserve">
          <source>Floating point register, Advanced SIMD vector register or SVE vector register</source>
          <target state="translated">부동 소수점 레지스터, 고급 SIMD 벡터 레지스터 또는 SVE 벡터 레지스터</target>
        </trans-unit>
        <trans-unit id="16c68eba878493a77d0c164e7869af76e99d9145" translate="yes" xml:space="preserve">
          <source>Floating point registers AC0 through AC3. These can be loaded from/to memory with a single instruction.</source>
          <target state="translated">부동 소수점 레지스터 AC0-AC3. 단일 명령으로 메모리에서로드하거나 메모리로로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83ce48a9f40c05895bc4e20f6bb82f032e76933d" translate="yes" xml:space="preserve">
          <source>Floating point registers AC4 and AC5. These cannot be loaded from/to memory with a single instruction.</source>
          <target state="translated">부동 소수점 레지스터 AC4 및 AC5. 단일 명령으로 메모리에서로드하거나 메모리로로드 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f58b0d70fd4d764630301aac0286ba68330e3308" translate="yes" xml:space="preserve">
          <source>Floating-point condition code register.</source>
          <target state="translated">부동 소수점 조건 코드 레지스터.</target>
        </trans-unit>
        <trans-unit id="b56c9d5aa5cba048b4016e56db5b37a9156be6f1" translate="yes" xml:space="preserve">
          <source>Floating-point constant 0.0</source>
          <target state="translated">부동 소수점 상수 0.0</target>
        </trans-unit>
        <trans-unit id="11ca0595ff5b1cee498ed130d48a9d7ef77d2ce2" translate="yes" xml:space="preserve">
          <source>Floating-point constant 0.0 or 1.0</source>
          <target state="translated">부동 소수점 상수 0.0 또는 1.0</target>
        </trans-unit>
        <trans-unit id="3af5f60b6556d63fbe7c6434e046d0c15fe3ffe1" translate="yes" xml:space="preserve">
          <source>Floating-point constant whose integral representation can be moved into an integer register using a high/lo_sum instruction sequence</source>
          <target state="translated">high / lo_sum 명령어 시퀀스를 사용하여 정수 표현으로 정수 표현을 이동할 수있는 부동 소수점 상수</target>
        </trans-unit>
        <trans-unit id="c0e1876d49ff7a36e4b65c8a5784d9cd7a8e4781" translate="yes" xml:space="preserve">
          <source>Floating-point constant whose integral representation can be moved into an integer register using a single mov instruction</source>
          <target state="translated">단일 mov 명령어를 사용하여 정수 표현으로 정수 표현을 이동할 수있는 부동 소수점 상수</target>
        </trans-unit>
        <trans-unit id="500223502156611a39a78dc4c23517d86e8a772f" translate="yes" xml:space="preserve">
          <source>Floating-point constant whose integral representation can be moved into an integer register using a single sethi instruction</source>
          <target state="translated">단일 sethi 명령어를 사용하여 정수 표현으로 정수 표현을 이동할 수있는 부동 소수점 상수</target>
        </trans-unit>
        <trans-unit id="95fef479c80cb031fff0832cf86c7d5b4d064fb7" translate="yes" xml:space="preserve">
          <source>Floating-point instructions are only generated for 32-bit floating-point values, however, so the FPU hardware is not used for doubles if the</source>
          <target state="translated">부동 소수점 명령어는 32 비트 부동 소수점 값에 대해서만 생성되므로 FPU 하드웨어는</target>
        </trans-unit>
        <trans-unit id="f213ef5758f227bd35596edf6ff5e36aed746a21" translate="yes" xml:space="preserve">
          <source>Floating-point minimum and maximum. These instructions are only generated if</source>
          <target state="translated">부동 소수점 최소 및 최대. 이 명령어는 다음과 같은 경우에만 생성됩니다</target>
        </trans-unit>
        <trans-unit id="92610c4245848bdded34c9ee994e62b738188b93" translate="yes" xml:space="preserve">
          <source>Floating-point register</source>
          <target state="translated">부동 소수점 레지스터</target>
        </trans-unit>
        <trans-unit id="e5380eea89f6db263d5d241526df6bedd0bd11ff" translate="yes" xml:space="preserve">
          <source>Floating-point register on the SPARC-V8 architecture and lower floating-point register on the SPARC-V9 architecture.</source>
          <target state="translated">SPARC-V8 아키텍처의 부동 소수점 레지스터 및 SPARC-V9 아키텍처의 낮은 부동 소수점 레지스터</target>
        </trans-unit>
        <trans-unit id="2b69cf45a938c9e06197f0424f9a02b9aa9f002d" translate="yes" xml:space="preserve">
          <source>Floating-point register. It is equivalent to &amp;lsquo;</source>
          <target state="translated">부동 소수점 레지스터 '</target>
        </trans-unit>
        <trans-unit id="8ed13acd5482c325b73e858b30874f469fb342d2" translate="yes" xml:space="preserve">
          <source>Floating-point register. It is only valid on the SPARC-V9 architecture when the Visual Instruction Set is available.</source>
          <target state="translated">부동 소수점 레지스터 비주얼 명령어 세트가 사용 가능한 경우 SPARC-V9 아키텍처에서만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="d0d6928cc5c4254d825994f1f03f5fa64bf43b02" translate="yes" xml:space="preserve">
          <source>Floating-point trigonometric and exponential functions. These instructions are only generated if</source>
          <target state="translated">부동 소수점 삼각 함수 및 지수 함수 이 명령어는 다음과 같은 경우에만 생성됩니다</target>
        </trans-unit>
        <trans-unit id="cebba3f2674f659c3ac76a05e885a881a3fcce6d" translate="yes" xml:space="preserve">
          <source>Floating-point zero</source>
          <target state="translated">부동 소수점 제로</target>
        </trans-unit>
        <trans-unit id="c245efe80db566f234058018cbe48e4698e1bcb0" translate="yes" xml:space="preserve">
          <source>Floating-point zero.</source>
          <target state="translated">부동 소수점 제로.</target>
        </trans-unit>
        <trans-unit id="bc0561e46ee46f1370ce39f7bd133e69f6b47448" translate="yes" xml:space="preserve">
          <source>Flushing registers to memory has performance implications and may be an issue for time-sensitive code. You can provide better information to GCC to avoid this, as shown in the following examples. At a minimum, aliasing rules allow GCC to know what memory &lt;em&gt;doesn&amp;rsquo;t&lt;/em&gt; need to be flushed.</source>
          <target state="translated">레지스터를 메모리로 플러시하는 것은 성능에 영향을 미치며 시간에 민감한 코드의 문제 일 수 있습니다. 다음 예와 같이 GCC에 더 나은 정보를 제공하여이를 피할 수 있습니다. 최소한 앨리어싱 규칙을 통해 GCC는 메모리 를 비울 필요 &lt;em&gt;가없는&lt;/em&gt; 것을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d035cae4646bbea859b3aa6a64d528d7a19fea6" translate="yes" xml:space="preserve">
          <source>Follow the EABI requirement of always creating a frame pointer whenever a stack frame is allocated. This option is enabled by default and can be disabled with</source>
          <target state="translated">스택 프레임이 할당 될 때마다 항상 프레임 포인터를 작성해야한다는 EABI 요구 사항을 따르십시오. 이 옵션은 기본적으로 활성화되어 있으며</target>
        </trans-unit>
        <trans-unit id="ec0c3b76630fd745381cc215a284820af75a683a" translate="yes" xml:space="preserve">
          <source>Footnotes</source>
          <target state="translated">Footnotes</target>
        </trans-unit>
        <trans-unit id="9203a30acc55d5bd89f275fd6b63f1da488b512a" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;t2&lt;/code&gt;, &lt;code&gt;bar&lt;/code&gt; is placed at offset 2, rather than offset 1. Accordingly, the size of &lt;code&gt;t2&lt;/code&gt; is 4. For &lt;code&gt;t3&lt;/code&gt;, the zero-length bit-field does not affect the alignment of &lt;code&gt;bar&lt;/code&gt; or, as a result, the size of the structure.</source>
          <target state="translated">들면 &lt;code&gt;t2&lt;/code&gt; , &lt;code&gt;bar&lt;/code&gt; 의 크기 2 오프셋 배치보다는 따라서 1 오프셋 &lt;code&gt;t2&lt;/code&gt; 4입니다 &lt;code&gt;t3&lt;/code&gt; , 길이가 0 인 비트 필드는의 배향에 영향을 미치지 않는 &lt;code&gt;bar&lt;/code&gt; , 그 결과의 크기 또는 구조.</target>
        </trans-unit>
        <trans-unit id="c0e04e76cdfed448d6c782b7f817b6eea03c0f50" translate="yes" xml:space="preserve">
          <source>For &lt;var&gt;n&lt;/var&gt; greater than zero,</source>
          <target state="translated">들면 &lt;var&gt;n&lt;/var&gt; 개의 0보다 크면,</target>
        </trans-unit>
        <trans-unit id="fda527468e7c30de6308efd890e87b3a3fff811b" translate="yes" xml:space="preserve">
          <source>For ARC, a function marked with the &lt;code&gt;long_call&lt;/code&gt; attribute is always called using register-indirect jump-and-link instructions, thereby enabling the called function to be placed anywhere within the 32-bit address space. A function marked with the &lt;code&gt;medium_call&lt;/code&gt; attribute will always be close enough to be called with an unconditional branch-and-link instruction, which has a 25-bit offset from the call site. A function marked with the &lt;code&gt;short_call&lt;/code&gt; attribute will always be close enough to be called with a conditional branch-and-link instruction, which has a 21-bit offset from the call site.</source>
          <target state="translated">ARC의 경우, &lt;code&gt;long_call&lt;/code&gt; 속성으로 표시된 함수 는 항상 레지스터 간접 점프 앤 링크 명령어를 사용하여 호출되므로 호출 된 함수를 32 비트 주소 공간 내의 어느 곳에 나 배치 할 수 있습니다. &lt;code&gt;medium_call&lt;/code&gt; 속성으로 표시된 함수 는 항상 무조건 분기 및 링크 명령어로 호출 할 수있을 정도로 가깝습니다.이 명령어는 호출 사이트에서 25 비트 오프셋을 갖습니다. &lt;code&gt;short_call&lt;/code&gt; 속성으로 표시된 함수 는 항상 조건부 분기 및 링크 명령어로 호출 할 수있을 정도로 가깝습니다.이 명령어는 호출 사이트에서 21 비트 오프셋을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="6adc57b693c8942df2cd231eba32d27dd15cba72" translate="yes" xml:space="preserve">
          <source>For C and C++ source and include files, generate corresponding Ada specs. See &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gnat_ugn/Generating-Ada-Bindings-for-C-and-C_002b_002b-headers.html#Generating-Ada-Bindings-for-C-and-C_002b_002b-headers&quot;&gt;Generating Ada Bindings for C and C++ headers&lt;/a&gt; in GNAT User&amp;rsquo;s Guide, which provides detailed documentation on this feature.</source>
          <target state="translated">C 및 C ++ 소스 및 포함 파일의 경우 해당 Ada 스펙을 생성하십시오. 이 기능에 대한 자세한 문서를 제공하는 GNAT 사용 설명서의 &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gnat_ugn/Generating-Ada-Bindings-for-C-and-C_002b_002b-headers.html#Generating-Ada-Bindings-for-C-and-C_002b_002b-headers&quot;&gt;C 및 C ++ 헤더&lt;/a&gt; 에 대한 Ada 바인딩 생성을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a54d6337d3721d977a537facc549a93425ea6c7b" translate="yes" xml:space="preserve">
          <source>For C only, warn about a &lt;code&gt;return&lt;/code&gt; statement with an expression in a function whose return type is &lt;code&gt;void&lt;/code&gt;, unless the expression type is also &lt;code&gt;void&lt;/code&gt;. As a GNU extension, the latter case is accepted without a warning unless</source>
          <target state="translated">C의 경우에만 약 경고 &lt;code&gt;return&lt;/code&gt; 반환 타입 함수의 식을 문 &lt;code&gt;void&lt;/code&gt; 표현 형식도되지 않는, &lt;code&gt;void&lt;/code&gt; . GNU 확장으로서 후자의 경우는 경고없이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="2ec28d96fea6d9177d31ee6cda12fa27a81380e2" translate="yes" xml:space="preserve">
          <source>For C++ this also warns for some cases of unnecessary parentheses in declarations, which can indicate an attempt at a function call instead of a declaration:</source>
          <target state="translated">C ++의 경우 선언에서 불필요한 괄호가있는 경우를 경고하며 선언 대신 함수 호출 시도를 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1ba0033d082d3c48e09cd4d28a77031c040292c" translate="yes" xml:space="preserve">
          <source>For C++ types with non-trivial constructors and/or destructors it is impossible for the compiler to determine whether a variable of this type is truly unused if it is not referenced. This type attribute informs the compiler that variables of this type should be warned about if they appear to be unused, just like variables of fundamental types.</source>
          <target state="translated">사소하지 않은 생성자 및 / 또는 소멸자가있는 C ++ 유형의 경우, 컴파일러가이 유형의 변수가 참조되지 않은 경우 실제로 사용되지 않는지 여부를 판별 할 수 없습니다. 이 유형 속성은 기본 유형의 변수와 같이이 유형의 변수가 사용되지 않는 것으로 나타나면 경고해야한다는 것을 컴파일러에 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="0ae259ea1be0c205a219871342f05ea5c73b071c" translate="yes" xml:space="preserve">
          <source>For C++, also warn for confusing overload resolution for user-defined conversions; and conversions that never use a type conversion operator: conversions to &lt;code&gt;void&lt;/code&gt;, the same type, a base class or a reference to them. Warnings about conversions between signed and unsigned integers are disabled by default in C++ unless</source>
          <target state="translated">C ++의 경우 사용자 정의 변환을위한 혼란스러운 과부하 해결에 대해서도 경고합니다. 유형 변환 연산자를 사용하지 않는 변환 : &lt;code&gt;void&lt;/code&gt; 로 변환 , 동일한 유형, 기본 클래스 또는 이들에 대한 참조. 부호없는 정수와 부호없는 정수 사이의 변환에 대한 경고는 C ++에서 기본적으로 비활성화되어 있습니다</target>
        </trans-unit>
        <trans-unit id="e062686eecb3f26c45c0833c30627154026b2d61" translate="yes" xml:space="preserve">
          <source>For C++11 and later standards, narrowing conversions are diagnosed by default, as required by the standard. A narrowing conversion from a constant produces an error, and a narrowing conversion from a non-constant produces a warning, but</source>
          <target state="translated">C ++ 11 이상 표준의 경우 표준에서 요구하는대로 축소 변환이 기본적으로 진단됩니다. 상수에서 좁히는 변환은 오류를 생성하고, 상수가 아닌 좁아진 변환은 경고를 생성하지만</target>
        </trans-unit>
        <trans-unit id="f97e8575f9ec69703e8c96b79759e90bcf7fbfd5" translate="yes" xml:space="preserve">
          <source>For C, overloaded functions are implemented with macros so the following does not work:</source>
          <target state="translated">C의 경우 오버로드 된 함수는 매크로로 구현되므로 다음이 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9bcf8fa5038512fc6bcb9ac1f639a794219e10dd" translate="yes" xml:space="preserve">
          <source>For Microsoft Windows targets the use of the &lt;code&gt;dllimport&lt;/code&gt; attribute on functions is not necessary, but provides a small performance benefit by eliminating a thunk in the DLL. The use of the &lt;code&gt;dllimport&lt;/code&gt; attribute on imported variables can be avoided by passing the</source>
          <target state="translated">Microsoft Windows 대상의 경우 함수 에서 &lt;code&gt;dllimport&lt;/code&gt; 속성을 사용할 필요는 없지만 DLL에서 썽크를 제거하여 약간의 성능 이점을 제공합니다. 가져온 변수 에서 &lt;code&gt;dllimport&lt;/code&gt; 속성을 사용 하면 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b439766be6cedb98071044e5f74180de17ccd28" translate="yes" xml:space="preserve">
          <source>For Microsoft Windows targets there are alternative methods for including the symbol in the DLL&amp;rsquo;s export table such as using a</source>
          <target state="translated">Microsoft Windows 대상의 경우 DLL 내보내기 테이블에 기호를 포함하는 것과 같은 대체 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0f97011eddc4db6c5d876ee996866a2e41c88d5" translate="yes" xml:space="preserve">
          <source>For Objective-C dialects, &lt;code&gt;NSString&lt;/code&gt; (or &lt;code&gt;__NSString__&lt;/code&gt;) is recognized in the same context. Declarations including these format attributes are parsed for correct syntax, however the result of checking of such format strings is not yet defined, and is not carried out by this version of the compiler.</source>
          <target state="translated">Objective-C 방언의 경우 &lt;code&gt;NSString&lt;/code&gt; (또는 &lt;code&gt;__NSString__&lt;/code&gt; )은 동일한 컨텍스트에서 인식됩니다. 이러한 형식 속성을 포함한 선언은 올바른 구문을 위해 구문 분석되지만 이러한 형식 문자열을 검사 한 결과는 아직 정의되지 않았으며이 버전의 컴파일러에서 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7b8c007aa57d34905e4e1143a8c9e0a695e59978" translate="yes" xml:space="preserve">
          <source>For Objective-C dialects, the &lt;code&gt;format-arg&lt;/code&gt; attribute may refer to an &lt;code&gt;NSString&lt;/code&gt; reference for compatibility with the &lt;code&gt;format&lt;/code&gt; attribute above.</source>
          <target state="translated">Objective-C 언어의 경우 &lt;code&gt;format-arg&lt;/code&gt; 속성은 위 의 &lt;code&gt;format&lt;/code&gt; 속성 과의 호환성을 위해 &lt;code&gt;NSString&lt;/code&gt; 참조를 참조 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="92a499e6d28c647e0ab66f857f55afedfae35b1a" translate="yes" xml:space="preserve">
          <source>For PMF constants (i.e. expressions of the form &amp;lsquo;</source>
          <target state="translated">PMF 상수 (예 : '</target>
        </trans-unit>
        <trans-unit id="da58c329594be0295cc2415f6a69d9838ef88a83" translate="yes" xml:space="preserve">
          <source>For SysV/x86-64, unions with &lt;code&gt;long double&lt;/code&gt; members are passed in memory as specified in psABI. For example:</source>
          <target state="translated">SysV / x86-64의 경우 &lt;code&gt;long double&lt;/code&gt; 구성원이있는 공용체는 psABI에 지정된대로 메모리에 전달됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1f5fce8a743c71e90680bcbdd5fc42205fc0e24c" translate="yes" xml:space="preserve">
          <source>For SysV/x86-64, unions with &lt;code&gt;long double&lt;/code&gt; members are passed in memory as specified in psABI. Prior to GCC 4.4, this was not the case. For example:</source>
          <target state="translated">SysV / x86-64의 경우 &lt;code&gt;long double&lt;/code&gt; 멤버가있는 공용체는 psABI에 지정된대로 메모리에 전달됩니다. GCC 4.4 이전에는 그렇지 않았습니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="1e5082f805fe556d28e82883360f1cc9602556d6" translate="yes" xml:space="preserve">
          <source>For a branch, if it was executed at least once, then a percentage indicating the number of times the branch was taken divided by the number of times the branch was executed will be printed. Otherwise, the message &amp;ldquo;never executed&amp;rdquo; is printed.</source>
          <target state="translated">분기의 경우 분기가 한 번 이상 실행 된 경우 분기를 수행 한 횟수를 분기가 실행 된 횟수로 나눈 백분율이 인쇄됩니다. 그렇지 않으면 &quot;never execution&quot;메시지가 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="c55de54fa0492ae593f558830d0cb1158609d3e6" translate="yes" xml:space="preserve">
          <source>For a call, if it was executed at least once, then a percentage indicating the number of times the call returned divided by the number of times the call was executed will be printed. This will usually be 100%, but may be less for functions that call &lt;code&gt;exit&lt;/code&gt; or &lt;code&gt;longjmp&lt;/code&gt;, and thus may not return every time they are called.</source>
          <target state="translated">호출의 경우, 호출이 한 번 이상 실행 된 경우, 호출 된 횟수를 호출 한 횟수로 나눈 백분율을 인쇄합니다. 일반적으로 100 %이지만 &lt;code&gt;exit&lt;/code&gt; 또는 &lt;code&gt;longjmp&lt;/code&gt; 를 호출하는 함수의 경우 더 적을 수 있으므로 호출 할 때마다 반환되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b932ff19c99d589baf49f81de1fc444d2d6fe68" translate="yes" xml:space="preserve">
          <source>For a full description of what the helpers do, the arguments they take, and the returned value, see the</source>
          <target state="translated">도우미가 수행하는 작업, 사용하는 인수 및 반환 된 값에 대한 전체 설명은</target>
        </trans-unit>
        <trans-unit id="6d3a2fcd90b12dd021860d8f2094fd5bb769b990" translate="yes" xml:space="preserve">
          <source>For all builtins, &lt;code&gt;__builtin_arc_&lt;var&gt;someinsn&lt;/var&gt;&lt;/code&gt;, the header file</source>
          <target state="translated">모든 내장 인 &lt;code&gt;__builtin_arc_&lt;var&gt;someinsn&lt;/var&gt;&lt;/code&gt; , 헤더 파일</target>
        </trans-unit>
        <trans-unit id="faea18cdbc9f914fc830faf9ab42ccd57286882b" translate="yes" xml:space="preserve">
          <source>For all of these except the last, the compiler automatically ignores the precompiled header if the conditions aren&amp;rsquo;t met. If you find an option combination that doesn&amp;rsquo;t work and doesn&amp;rsquo;t cause the precompiled header to be ignored, please consider filing a bug report, see &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Bugs.html#Bugs&quot;&gt;Bugs&lt;/a&gt;.</source>
          <target state="translated">마지막을 제외한 모든 조건에 대해 컴파일러는 조건이 충족되지 않으면 미리 컴파일 된 헤더를 자동으로 무시합니다. 작동하지 않고 미리 컴파일 된 헤더를 무시하지 않는 옵션 조합을 찾으면 버그 보고서 제출을 고려하십시오 . &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Bugs.html#Bugs&quot;&gt;버그를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2d0b11d5fd63069d7902f804e3faa32968adf01d" translate="yes" xml:space="preserve">
          <source>For all of these except the last, the compiler automatically ignores the precompiled header if the conditions aren&amp;rsquo;t met. If you find an option combination that doesn&amp;rsquo;t work and doesn&amp;rsquo;t cause the precompiled header to be ignored, please consider filing a bug report, see &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Bugs.html#Bugs&quot;&gt;Bugs&lt;/a&gt;.</source>
          <target state="translated">마지막을 제외한 모든 것의 경우 조건이 충족되지 않으면 컴파일러는 사전 컴파일 된 헤더를 자동으로 무시합니다. 작동하지 않고 사전 컴파일 된 헤더를 무시하지 않는 옵션 조합을 찾으면 버그 보고서 제출을 고려하십시오 ( &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Bugs.html#Bugs&quot;&gt;버그&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="58f02a64f2f86869e0c0753651765b098a5d48fc" translate="yes" xml:space="preserve">
          <source>For an automatic (i.e. local) variable, if there exists a path from the function entry to a use of the variable that is initialized, but there exist some other paths for which the variable is not initialized, the compiler emits a warning if it cannot prove the uninitialized paths are not executed at run time.</source>
          <target state="translated">자동 (예 : 로컬) 변수의 경우 함수 항목에서 초기화 된 변수 사용까지의 경로가 있지만 변수가 초기화되지 않은 다른 경로가 있으면 컴파일러에서 변수를 초기화 할 수없는 경우 경고를 표시합니다 초기화되지 않은 경로가 런타임에 실행되지 않음을 증명하십시오.</target>
        </trans-unit>
        <trans-unit id="66413344ffac4ff8769f77f6b83c7166f806eb53" translate="yes" xml:space="preserve">
          <source>For any declared symbols matching &lt;var&gt;name&lt;/var&gt;, this does three things to that symbol: it forces the symbol to be located at the given address (a number), it forces the symbol to be volatile, and it changes the symbol&amp;rsquo;s scope to be static. This pragma exists for compatibility with other compilers, but note that the common &lt;code&gt;1234H&lt;/code&gt; numeric syntax is not supported (use &lt;code&gt;0x1234&lt;/code&gt; instead). Example:</source>
          <target state="translated">&lt;var&gt;name&lt;/var&gt; 과 일치하는 선언 된 심볼의 경우이 심볼에 대해 세 가지 작업을 수행합니다. 심볼을 지정된 주소 (숫자)에 위치시키고 심볼을 휘발성으로 만들고 심볼의 범위를 정적으로 변경합니다. 이 pragma는 다른 컴파일러와의 호환성을 위해 존재하지만 일반적인 &lt;code&gt;1234H&lt;/code&gt; 숫자 구문은 지원되지 않습니다 ( 대신 &lt;code&gt;0x1234&lt;/code&gt; 사용). 예:</target>
        </trans-unit>
        <trans-unit id="a150049db7b708562952c9c177d8b88f32edb151" translate="yes" xml:space="preserve">
          <source>For any given input file, the file name suffix determines what kind of compilation is done:</source>
          <target state="translated">주어진 입력 파일에 대해 파일 이름 접미사가 수행되는 컴파일 종류를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="07d18512cc77ea85f9b39807bf636696e007c1f0" translate="yes" xml:space="preserve">
          <source>For any input register that is implicitly popped by an &lt;code&gt;asm&lt;/code&gt;, it is necessary to know how to adjust the stack to compensate for the pop. If any non-popped input is closer to the top of the reg-stack than the implicitly popped register, it would not be possible to know what the stack looked like&amp;mdash;it&amp;rsquo;s not clear how the rest of the stack &amp;ldquo;slides up&amp;rdquo;.</source>
          <target state="translated">암시 적으로 &lt;code&gt;asm&lt;/code&gt; 에 의해 팝되는 입력 레지스터의 경우, 팝을 보상하기 위해 스택을 조정하는 방법을 알아야합니다. 팝되지 않은 입력이 내재적으로 팝된 레지스터보다 reg-stack의 상단에 더 가까우면 스택의 모양을 알 수 없으며 나머지 스택이 어떻게 미끄러지는지 명확하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f70c821669087836df1b08a79652756521c81032" translate="yes" xml:space="preserve">
          <source>For basic &lt;code&gt;asm&lt;/code&gt; with non-empty assembler string GCC assumes the assembler block does not change any general purpose registers, but it may read or write any globally accessible variable.</source>
          <target state="translated">비어 있지 않은 어셈블러 문자열이있는 기본 &lt;code&gt;asm&lt;/code&gt; 의 경우 GCC는 어셈블러 블록이 범용 레지스터를 변경하지 않지만 전역 적으로 액세스 가능한 변수를 읽거나 쓸 수 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="5e325c0c804529598de8767ff4c99ad5a3e91e4a" translate="yes" xml:space="preserve">
          <source>For compatibility with Microsoft Windows compilers, GCC supports &amp;lsquo;</source>
          <target state="translated">Microsoft Windows 컴파일러와의 호환성을 위해 GCC는 '</target>
        </trans-unit>
        <trans-unit id="2e68646242b9dd84443ad785c99336fb66a4c416" translate="yes" xml:space="preserve">
          <source>For compatibility with Microsoft Windows compilers, GCC supports a set of &lt;code&gt;#pragma&lt;/code&gt; directives that change the maximum alignment of members of structures (other than zero-width bit-fields), unions, and classes subsequently defined. The &lt;var&gt;n&lt;/var&gt; value below always is required to be a small power of two and specifies the new alignment in bytes.</source>
          <target state="translated">Microsoft Windows 컴파일러와의 호환성을 위해 GCC는 구조의 멤버 (폭이 0 인 비트 필드 이외), 공용체 및 이후에 정의 된 클래스의 최대 정렬을 변경하는 &lt;code&gt;#pragma&lt;/code&gt; 지시문 집합을 지원합니다 . 아래 의 &lt;var&gt;n&lt;/var&gt; 값은 항상 2의 작은 제곱이어야하며 새 정렬을 바이트 단위로 지정합니다.</target>
        </trans-unit>
        <trans-unit id="2922cd58b39e0ff05824f3d77b79c0fe7423d78f" translate="yes" xml:space="preserve">
          <source>For compatibility with SVR4, GCC supports a set of &lt;code&gt;#pragma&lt;/code&gt; directives for declaring symbols to be weak, and defining weak aliases.</source>
          <target state="translated">SVR4와의 호환성을 위해 GCC는 기호를 약한 것으로 선언하고 약한 별칭을 정의하기위한 일련의 &lt;code&gt;#pragma&lt;/code&gt; 지시문을 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="47783006d3b2d24697c7b14be6b4ca265bdb02d0" translate="yes" xml:space="preserve">
          <source>For compatibility with existing code written for compiler versions that did not implement attributes on nested declarators, some laxity is allowed in the placing of attributes. If an attribute that only applies to types is applied to a declaration, it is treated as applying to the type of that declaration. If an attribute that only applies to declarations is applied to the type of a declaration, it is treated as applying to that declaration; and, for compatibility with code placing the attributes immediately before the identifier declared, such an attribute applied to a function return type is treated as applying to the function type, and such an attribute applied to an array element type is treated as applying to the array type. If an attribute that only applies to function types is applied to a pointer-to-function type, it is treated as applying to the pointer target type; if such an attribute is applied to a function return type that is not a pointer-to-function type, it is treated as applying to the function type.</source>
          <target state="translated">중첩 된 선언자에서 속성을 구현하지 않은 컴파일러 버전 용으로 작성된 기존 코드와의 호환성을 위해 속성 배치에 약간의 여유가 허용됩니다. 형식에만 적용되는 특성이 선언에 적용되면 해당 선언의 형식에 적용되는 것으로 간주됩니다. 선언에만 적용되는 속성이 선언 유형에 적용되면 해당 선언에 적용되는 것으로 간주됩니다. 그리고 선언 된 식별자 바로 앞에 속성을 배치하는 코드와의 호환성을 위해, 함수 리턴 타입에 적용된 속성은 함수 타입에 적용되는 것으로 취급되고, 배열 요소 타입에 적용된 속성은 어레이에 적용되는 것으로 취급된다 유형. 함수 유형에만 적용되는 속성이 포인터 대 함수 유형에 적용되는 경우,포인터 대상 유형에 적용되는 것으로 간주됩니다. 이러한 속성이 포인터 대 함수 유형이 아닌 함수 리턴 유형에 적용되는 경우 함수 유형에 적용되는 것으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="55c454a21201bdfc3a9a886c367d99786c9c4842" translate="yes" xml:space="preserve">
          <source>For compatibility, it&amp;rsquo;s always newlib for elf now.</source>
          <target state="translated">호환성을 위해 항상 엘프를위한 newlib입니다.</target>
        </trans-unit>
        <trans-unit id="4859bddb1e6f097bf4875ee4cd32afb8f33d13e6" translate="yes" xml:space="preserve">
          <source>For convenience, it is allowed to use a binary vector operation where one operand is a scalar. In that case the compiler transforms the scalar operand into a vector where each element is the scalar from the operation. The transformation happens only if the scalar could be safely converted to the vector-element type. Consider the following code.</source>
          <target state="translated">편의상 하나의 피연산자가 스칼라 인 이진 벡터 연산을 사용할 수 있습니다. 이 경우 컴파일러는 스칼라 피연산자를 각 요소가 연산의 스칼라 인 벡터로 변환합니다. 스칼라를 벡터 요소 유형으로 안전하게 변환 할 수있는 경우에만 변환이 발생합니다. 다음 코드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="3d923f6f173753b3c978292a218e04d22288b211" translate="yes" xml:space="preserve">
          <source>For conversion to a type of width &lt;em&gt;N&lt;/em&gt;, the value is reduced modulo &lt;em&gt;2^N&lt;/em&gt; to be within range of the type; no signal is raised.</source>
          <target state="translated">폭 &lt;em&gt;N&lt;/em&gt; 의 타입으로 변환하기 위해 , 값은 타입의 범위 내에 있도록 모듈로 &lt;em&gt;2 ^ N&lt;/em&gt; 로 감소된다 ; 신호가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c0bc316f0ef750b2316cb1b5e8278752dde4a8ca" translate="yes" xml:space="preserve">
          <source>For deciding the optimization level of body.</source>
          <target state="translated">신체의 최적화 수준을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="3216191fb385483c1e97afafeea464af935a4944" translate="yes" xml:space="preserve">
          <source>For devices not in &lt;code&gt;avrtiny&lt;/code&gt; or &lt;code&gt;avrxmega3&lt;/code&gt;, any data including read-only data is located in RAM (the generic address space) because flash memory is not visible in the RAM address space. In order to locate read-only data in flash memory &lt;em&gt;and&lt;/em&gt; to generate the right instructions to access this data without using (inline) assembler code, special address spaces are needed.</source>
          <target state="translated">&lt;code&gt;avrtiny&lt;/code&gt; 또는 &lt;code&gt;avrxmega3&lt;/code&gt; 에 있지 않은 장치의 경우 RAM 주소 공간에는 플래시 메모리가 표시되지 않으므로 읽기 전용 데이터를 포함한 모든 데이터는 RAM (일반 주소 공간)에 있습니다. 플래시 메모리에 읽기 전용 데이터를 찾을하기 위해 &lt;em&gt;및&lt;/em&gt; (인라인) 어셈블러 코드를 사용하지 않고이 데이터에 액세스 할 수있는 권한 지침을 생성하기 위해, 특수 주소 공간이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="0733ee9be6e082cc123e5464c02486573ae7f9cd" translate="yes" xml:space="preserve">
          <source>For documentation of &lt;code&gt;altivec&lt;/code&gt; attribute please see the documentation in &lt;a href=&quot;type-attributes#PowerPC-Type-Attributes&quot;&gt;PowerPC Type Attributes&lt;/a&gt;.</source>
          <target state="translated">의 문서에 대해서는, &lt;code&gt;altivec&lt;/code&gt; 속성에 문서를 참조하십시오 &lt;a href=&quot;type-attributes#PowerPC-Type-Attributes&quot;&gt;파워 유형 속성&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eb3f33ef599bbcb991ed9de189514be3fb2765a7" translate="yes" xml:space="preserve">
          <source>For each Objective-C class, check if any of its instance variables is a C++ object with a non-trivial default constructor. If so, synthesize a special &lt;code&gt;- (id) .cxx_construct&lt;/code&gt; instance method which runs non-trivial default constructors on any such instance variables, in order, and then return &lt;code&gt;self&lt;/code&gt;. Similarly, check if any instance variable is a C++ object with a non-trivial destructor, and if so, synthesize a special &lt;code&gt;- (void) .cxx_destruct&lt;/code&gt; method which runs all such default destructors, in reverse order.</source>
          <target state="translated">각 Objective-C 클래스에 대해 인스턴스 변수가 사소한 기본 생성자를 가진 C ++ 객체인지 확인하십시오. 그렇다면, 그러한 인스턴스 변수에서 사소한 기본 생성자를 순서대로 실행 하는 특수한 &lt;code&gt;- (id) .cxx_construct&lt;/code&gt; 인스턴스 메소드를 합성 한 다음 &lt;code&gt;self&lt;/code&gt; 를 리턴하십시오 . 마찬가지로, 인스턴스 변수가 사소한 소멸자가없는 C ++ 객체인지 확인하고, 존재하는 경우 모든 기본 소멸자를 역순으로 실행 하는 특수 &lt;code&gt;- (void) .cxx_destruct&lt;/code&gt; 메소드를 합성하십시오 .</target>
        </trans-unit>
        <trans-unit id="ecabcf6fb487210c3e414abe28454af79991a5a8" translate="yes" xml:space="preserve">
          <source>For each basic block, a line is printed after the last line of the basic block describing the branch or call that ends the basic block. There can be multiple branches and calls listed for a single source line if there are multiple basic blocks that end on that line. In this case, the branches and calls are each given a number. There is no simple way to map these branches and calls back to source constructs. In general, though, the lowest numbered branch or call will correspond to the leftmost construct on the source line.</source>
          <target state="translated">각 기본 블록에 대해 기본 블록을 종료하는 분기 또는 호출을 설명하는 기본 블록의 마지막 라인 뒤에 라인이 인쇄됩니다. 해당 회선에서 끝나는 기본 블록이 여러 개인 경우 단일 소스 회선에 대해 여러 개의 분기 및 호출이 나열 될 수 있습니다. 이 경우 지점과 통화에는 각각 번호가 지정됩니다. 이러한 브랜치를 맵핑하고 소스 구성을 다시 호출하는 간단한 방법은 없습니다. 그러나 일반적으로 가장 낮은 번호의 분기 또는 호출은 소스 라인에서 가장 왼쪽에있는 구성에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="7d57dddd1f25be9ff5b83775303a0d6d59fce852" translate="yes" xml:space="preserve">
          <source>For each built-in function for AVR, there is an equally named, uppercase built-in macro defined. That way users can easily query if or if not a specific built-in is implemented or not. For example, if &lt;code&gt;__builtin_avr_nop&lt;/code&gt; is available the macro &lt;code&gt;__BUILTIN_AVR_NOP&lt;/code&gt; is defined to &lt;code&gt;1&lt;/code&gt; and undefined otherwise.</source>
          <target state="translated">AVR의 각 내장 기능에 대해 동일한 이름의 대문자 내장 매크로가 정의되어 있습니다. 이를 통해 사용자는 특정 내장 기능이 구현되었는지 여부를 쉽게 쿼리 할 수 ​​있습니다. 예를 들어 &lt;code&gt;__builtin_avr_nop&lt;/code&gt; 를 사용할 수 있으면 매크로 &lt;code&gt;__BUILTIN_AVR_NOP&lt;/code&gt; 가 &lt;code&gt;1&lt;/code&gt; 로 정의되고 그렇지 않으면 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d11a6b019eb02c22d6e7924e271f0d952fce8600" translate="yes" xml:space="preserve">
          <source>For each function, a line is printed showing how many times the function is called, how many times it returns and what percentage of the function&amp;rsquo;s blocks were executed.</source>
          <target state="translated">각 함수에 대해 함수 호출 횟수, 반환 횟수 및 실행 된 함수 블록의 백분율을 나타내는 행이 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="4bcb841b4282f8986587d3e6966d3ed8c8dbe585" translate="yes" xml:space="preserve">
          <source>For each language compiled by GCC for which there is a standard, GCC attempts to follow one or more versions of that standard, possibly with some exceptions, and possibly with some extensions.</source>
          <target state="translated">표준이있는 GCC에서 컴파일 한 각 언어에 대해 GCC는 해당 표준의 하나 이상의 버전을 따르려고 시도합니다 (일부 예외 및 확장 가능).</target>
        </trans-unit>
        <trans-unit id="454897cc2fe9ad183bab2f7040fb6e5f25d9835d" translate="yes" xml:space="preserve">
          <source>For each named address space supported by avr-gcc there is an equally named but uppercase built-in macro defined. The purpose is to facilitate testing if respective address space support is available or not:</source>
          <target state="translated">avr-gcc가 지원하는 각각의 명명 된 주소 공간에 대해 동일하게 명명되었지만 대문자 내장 매크로가 정의되어 있습니다. 각 주소 공간 지원이 가능한지 여부를 테스트하기 위해 다음과 같은 목적이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3f4882138b251f321ad16e203354e1a8d314d76" translate="yes" xml:space="preserve">
          <source>For each of the other indicated dump files (</source>
          <target state="translated">표시된 다른 덤프 파일 (</target>
        </trans-unit>
        <trans-unit id="52f8ea439a283b5dc96c21715d0fefc3004bcf28" translate="yes" xml:space="preserve">
          <source>For each subprogram to be run, the compiler driver first tries the</source>
          <target state="translated">각 서브 프로그램이 실행될 때마다 컴파일러 드라이버는 먼저</target>
        </trans-unit>
        <trans-unit id="fdc4fc8f69b51e6f564843d4ff6b4102d66402dd" translate="yes" xml:space="preserve">
          <source>For even more AVR-specific built-in macros see &lt;a href=&quot;named-address-spaces#AVR-Named-Address-Spaces&quot;&gt;AVR Named Address Spaces&lt;/a&gt; and &lt;a href=&quot;avr-built_002din-functions#AVR-Built_002din-Functions&quot;&gt;AVR Built-in Functions&lt;/a&gt;.</source>
          <target state="translated">더 많은 AVR 관련 내장 매크로에 대해서는 &lt;a href=&quot;named-address-spaces#AVR-Named-Address-Spaces&quot;&gt;AVR 명명 된 주소 공간&lt;/a&gt; 및 &lt;a href=&quot;avr-built_002din-functions#AVR-Built_002din-Functions&quot;&gt;AVR 내장 기능을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1baa0cc1603bf61303a12aa930a0094973d11cab" translate="yes" xml:space="preserve">
          <source>For example in the structure below, the member array &lt;code&gt;x&lt;/code&gt; is packed so that it immediately follows &lt;code&gt;a&lt;/code&gt; with no intervening padding:</source>
          <target state="translated">아래의 구조에서 예를 들면, 부재 어레이 &lt;code&gt;x&lt;/code&gt; 즉시 따르도록 가득 &lt;code&gt;a&lt;/code&gt; 중재하는 패딩 :</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="67c7bfe6911146baef42ccf95311646fa6de1225" translate="yes" xml:space="preserve">
          <source>For example, &amp;lsquo;</source>
          <target state="translated">예를 들어 '</target>
        </trans-unit>
        <trans-unit id="f35aae572eaa511b9e1fec745e2f41aff9a397c4" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;-MT '$(objpfx)foo.o'&lt;/code&gt; might give</source>
          <target state="translated">예를 들어, &lt;code&gt;-MT '$(objpfx)foo.o'&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="687851312bf05d13456ec79c098b24da9ffe5635" translate="yes" xml:space="preserve">
          <source>For example, GCC warns about &lt;code&gt;i&lt;/code&gt; being uninitialized in the following snippet only when</source>
          <target state="translated">에 대해 예를 들어, GCC는 경고 &lt;code&gt;i&lt;/code&gt; 경우에만 다음 코드에서 초기화되지 않은되고</target>
        </trans-unit>
        <trans-unit id="481bf59d3e774632a4ae291477b6e304f7e4939c" translate="yes" xml:space="preserve">
          <source>For example, a bounded case of &lt;code&gt;alloca&lt;/code&gt; could be:</source>
          <target state="translated">예를 들어, &lt;code&gt;alloca&lt;/code&gt; 의 경계 사례는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b71521cff46dbe352ddadd34594ed3081919fa62" translate="yes" xml:space="preserve">
          <source>For example, a method with no arguments and returning &lt;code&gt;int&lt;/code&gt; would have the signature &lt;code&gt;i8@0:4&lt;/code&gt; if the size of a pointer is 4. The signature is interpreted as follows: the &lt;code&gt;i&lt;/code&gt; is the return type (an &lt;code&gt;int&lt;/code&gt;), the &lt;code&gt;8&lt;/code&gt; is the total size of the parameters in bytes (two pointers each of size 4), the &lt;code&gt;@0&lt;/code&gt; is the first parameter (an object at byte offset &lt;code&gt;0&lt;/code&gt;) and &lt;code&gt;:4&lt;/code&gt; is the second parameter (a &lt;code&gt;SEL&lt;/code&gt; at byte offset &lt;code&gt;4&lt;/code&gt;).</source>
          <target state="translated">예를 들어, 인수가없고 &lt;code&gt;int&lt;/code&gt; 를 리턴하는 메소드 는 포인터의 크기가 &lt;code&gt;i8@0:4&lt;/code&gt; 경우 서명 i8 @ 0 : 4를 갖습니다 . 서명은 다음과 같이 해석됩니다. &lt;code&gt;i&lt;/code&gt; 는 리턴 유형 ( &lt;code&gt;int&lt;/code&gt; ), &lt;code&gt;8&lt;/code&gt; 은 바이트 단위의 매개 변수의 총 크기 (각 크기 4의 포인터 2 개), &lt;code&gt;@0&lt;/code&gt; 은 첫 번째 매개 변수 (바이트 오프셋 &lt;code&gt;0&lt;/code&gt; 의 오브젝트 )이고 &lt;code&gt;:4&lt;/code&gt; 는 두 번째 매개 변수 ( 바이트 오프셋 &lt;code&gt;4&lt;/code&gt; 의 &lt;code&gt;SEL&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="68ba042328cca36e153d2c8dab7d8879565e3845" translate="yes" xml:space="preserve">
          <source>For example, a program may use a function &lt;code&gt;strfunc&lt;/code&gt; that returns &lt;code&gt;string&lt;/code&gt; objects, and another function &lt;code&gt;charfunc&lt;/code&gt; that operates on pointers to &lt;code&gt;char&lt;/code&gt;:</source>
          <target state="translated">예를 들어, 프로그램은 &lt;code&gt;string&lt;/code&gt; 객체 를 반환 하는 함수 &lt;code&gt;strfunc&lt;/code&gt; 와 &lt;code&gt;char&lt;/code&gt; 에 대한 포인터에서 작동하는 다른 함수 &lt;code&gt;charfunc&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="88bf56d21a567365b50f7c0d1260f3e77c253d14" translate="yes" xml:space="preserve">
          <source>For example, a spec string like this:</source>
          <target state="translated">예를 들어 다음과 같은 사양 문자열은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9636aa78a9470d85d5322503884f630474bbcbd8" translate="yes" xml:space="preserve">
          <source>For example, an address which is constant is offsettable; so is an address that is the sum of a register and a constant (as long as a slightly larger constant is also within the range of address-offsets supported by the machine); but an autoincrement or autodecrement address is not offsettable. More complicated indirect/indexed addresses may or may not be offsettable depending on the other addressing modes that the machine supports.</source>
          <target state="translated">예를 들어, 일정한 주소는 오프셋 가능합니다. 레지스터와 상수의 합인 주소도 있습니다 (약간 큰 상수가 기계가 지원하는 주소 오프셋 범위 내에있는 한). 그러나 자동 증가 또는 자동 감소 주소는 오프셋 가능하지 않습니다. 기계가 지원하는 다른 주소 지정 모드에 따라 더 복잡한 간접 / 색인 주소는 오프셋 가능하거나 오프셋 가능하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb39fad998b5526c7cd037c77aee5706a45b5058" translate="yes" xml:space="preserve">
          <source>For example, by default a structure containing nothing but 8 &lt;code&gt;unsigned&lt;/code&gt; bit-fields of length 1 is aligned to a 4-byte boundary and has a size of 4 bytes. By using</source>
          <target state="translated">예를 들어, 기본적 으로 길이가 1 인 8 개의 &lt;code&gt;unsigned&lt;/code&gt; 비트 필드 만 포함하는 구조 는 4 바이트 경계에 정렬되며 크기는 4 바이트입니다. 사용하여</target>
        </trans-unit>
        <trans-unit id="44c92e45a35c2e3631a1416540d7623d393688e2" translate="yes" xml:space="preserve">
          <source>For example, code using the standard ISA encoding cannot jump directly to MIPS16 or microMIPS code; it must either use a call or an indirect jump.</source>
          <target state="translated">예를 들어 표준 ISA 인코딩을 사용하는 코드는 MIPS16 또는 microMIPS 코드로 직접 이동할 수 없습니다. 호출 또는 간접 점프를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="6d3c95f985f19da9d6dbc1a830c9da53b0e26416" translate="yes" xml:space="preserve">
          <source>For example, given this C source file:</source>
          <target state="translated">예를 들어,이 C 소스 파일이 주어진 경우 :</target>
        </trans-unit>
        <trans-unit id="f0defbb763ebb18b66cf3162b2b446b84c5034e8" translate="yes" xml:space="preserve">
          <source>For example, if an x86 compiler supports two dialects (&amp;lsquo;</source>
          <target state="translated">예를 들어, x86 컴파일러가 두 개의 방언 ( '</target>
        </trans-unit>
        <trans-unit id="9b3c7e9c23ebc44c980aef19936a5699e234861d" translate="yes" xml:space="preserve">
          <source>For example, if the object file</source>
          <target state="translated">예를 들어 객체 파일이</target>
        </trans-unit>
        <trans-unit id="6277fc8469340ab02cc75749b9fdf00e3b3028a6" translate="yes" xml:space="preserve">
          <source>For example, if the target machine requires a &lt;code&gt;double&lt;/code&gt; value to be aligned on an 8-byte boundary, then &lt;code&gt;__alignof__ (double)&lt;/code&gt; is 8. This is true on many RISC machines. On more traditional machine designs, &lt;code&gt;__alignof__ (double)&lt;/code&gt; is 4 or even 2.</source>
          <target state="translated">예를 들어, 대상 시스템 에서 8 바이트 경계에 정렬하기 위해 &lt;code&gt;double&lt;/code&gt; 값이 필요한 경우 &lt;code&gt;__alignof__ (double)&lt;/code&gt; 은 8입니다. 이는 많은 RISC 시스템에서 적용됩니다. 보다 전통적인 기계 설계에서 &lt;code&gt;__alignof__ (double)&lt;/code&gt; 은 4 또는 2입니다.</target>
        </trans-unit>
        <trans-unit id="ace71a372dd9faf87968abc19f07a8c712084e3c" translate="yes" xml:space="preserve">
          <source>For example, in the following function the call to &lt;code&gt;g&lt;/code&gt; is unsafe because when &lt;code&gt;overalign&lt;/code&gt; is non-zero, the space allocated by &lt;code&gt;__builtin_alloca_with_align&lt;/code&gt; may have been released at the end of the &lt;code&gt;if&lt;/code&gt; statement in which it was called.</source>
          <target state="translated">예를 들어, 다음 함수에서 &lt;code&gt;overalign&lt;/code&gt; 이 0이 아닌 경우 &lt;code&gt;__builtin_alloca_with_align&lt;/code&gt; 에 의해 할당 된 공간 이 호출 된 &lt;code&gt;if&lt;/code&gt; 문의 끝에서 해제되었을 수 있으므로 &lt;code&gt;g&lt;/code&gt; 에 대한 호출 은 안전하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b982bcc761519bf794d14c5f76ed85a5c03967e1" translate="yes" xml:space="preserve">
          <source>For example, in the following, each call to function &lt;code&gt;foo&lt;/code&gt; will print a line similar to &lt;code&gt;&quot;file.c:123: foo: message&quot;&lt;/code&gt; with the name of the file and the line number of the &lt;code&gt;printf&lt;/code&gt; call, the name of the function &lt;code&gt;foo&lt;/code&gt;, followed by the word &lt;code&gt;message&lt;/code&gt;.</source>
          <target state="translated">예를 들어, 다음에서 &lt;code&gt;foo&lt;/code&gt; 함수를 호출 할 때마다 &lt;code&gt;&quot;file.c:123: foo: message&quot;&lt;/code&gt; 와 유사한 행을 파일 이름과 &lt;code&gt;printf&lt;/code&gt; 호출 의 행 번호 , &lt;code&gt;foo&lt;/code&gt; 함수 이름을 사용하여 인쇄합니다. &lt;code&gt;message&lt;/code&gt; 뒤에 단어 가 옵니다 .</target>
        </trans-unit>
        <trans-unit id="55f28e4d67f6e114f470b97bac400ac0e25f6328" translate="yes" xml:space="preserve">
          <source>For example, on the 68000 in a fullword instruction it is possible to use an immediate operand; but if the immediate value is between -128 and 127, better code results from loading the value into a register and using the register. This is because the load into the register can be done with a &amp;lsquo;</source>
          <target state="translated">예를 들어, 전체 단어 명령어의 68000에서 즉시 피연산자를 사용할 수 있습니다. 그러나 즉시 값이 -128과 127 사이이면 값을 레지스터에로드하고 레지스터를 사용하여 더 나은 코드를 생성합니다. 레지스터로의로드는 '</target>
        </trans-unit>
        <trans-unit id="2f76b920d411b7e136fa4f9061e5e0a37ad6c0c4" translate="yes" xml:space="preserve">
          <source>For example, since the declaration of the primary function template below makes use of both attribute &lt;code&gt;malloc&lt;/code&gt; and &lt;code&gt;alloc_size&lt;/code&gt; the declaration of the explicit specialization of the template is diagnosed because it is missing one of the attributes.</source>
          <target state="translated">예를 들어, 아래의 1 차 함수 템플리트를 선언하면 &lt;code&gt;malloc&lt;/code&gt; 및 &lt;code&gt;alloc_size&lt;/code&gt; 속성을 모두 사용 하므로 템플리트 중 하나가 누락 되었기 때문에 템플리트의 명시 적 특수화 선언이 진단됩니다.</target>
        </trans-unit>
        <trans-unit id="c1b19cb164dc1a4ab8a759ac490b8fde220e9c5e" translate="yes" xml:space="preserve">
          <source>For example, suppose &lt;code&gt;struct A&lt;/code&gt; below is defined in some third party library header to have the alignment requirement &lt;code&gt;N&lt;/code&gt; and to force a warning whenever a variable of the type is not so aligned due to attribute &lt;code&gt;packed&lt;/code&gt;. Specifying the &lt;code&gt;copy&lt;/code&gt; attribute on the definition on the unrelated &lt;code&gt;struct B&lt;/code&gt; has the effect of copying all relevant attributes from the type referenced by the pointer expression to &lt;code&gt;struct B&lt;/code&gt;.</source>
          <target state="translated">예를 들어, 아래의 &lt;code&gt;struct A&lt;/code&gt; 가 정렬 요구 사항 &lt;code&gt;N&lt;/code&gt; 을 가지며 속성의 &lt;code&gt;packed&lt;/code&gt; 로 인해 유형의 변수가 정렬되지 않을 때마다 경고를 강제 하기 위해 일부 타사 라이브러리 헤더에 정의 되었다고 가정 하십시오 . 지정] &lt;code&gt;copy&lt;/code&gt; 관련없는의 정의에 속성을 &lt;code&gt;struct B&lt;/code&gt; 포인터의 발현에 의해 참조 유형의 모든 관련 속성 복사의 효과가 &lt;code&gt;struct B&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0be048f3761817dd96f745d3c57100422574646" translate="yes" xml:space="preserve">
          <source>For example, the &lt;code&gt;sprintf&lt;/code&gt; function on SunOS 4.1.3 returns &lt;code&gt;char *&lt;/code&gt; while the C standard says that &lt;code&gt;sprintf&lt;/code&gt; returns an &lt;code&gt;int&lt;/code&gt;. The &lt;code&gt;fixincludes&lt;/code&gt; program could make the prototype for this function match the Standard, but that would be wrong, since the function will still return &lt;code&gt;char *&lt;/code&gt;.</source>
          <target state="translated">예를 들어 SunOS 4.1.3 의 &lt;code&gt;sprintf&lt;/code&gt; 함수는 &lt;code&gt;char *&lt;/code&gt; 를 반환 하지만 C 표준에서는 &lt;code&gt;sprintf&lt;/code&gt; 가 &lt;code&gt;int&lt;/code&gt; 를 반환 한다고 말합니다 . &lt;code&gt;fixincludes&lt;/code&gt; 프로그램은이 함수의 프로토 타입이 표준과 일치 할 수 있지만 기능은 여전히 반환하기 때문에 즉, 잘못된 것 &lt;code&gt;char *&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd82a792fa22143d94897d2b758fc399175bbe0e" translate="yes" xml:space="preserve">
          <source>For example, the &lt;var&gt;StrongAlias&lt;/var&gt; macro below makes use of the &lt;code&gt;alias&lt;/code&gt; and &lt;code&gt;copy&lt;/code&gt; attributes to define an alias named &lt;var&gt;alloc&lt;/var&gt; for function &lt;var&gt;allocate&lt;/var&gt; declared with attributes &lt;var&gt;alloc_size&lt;/var&gt;, &lt;var&gt;malloc&lt;/var&gt;, and &lt;var&gt;nothrow&lt;/var&gt;. Thanks to the &lt;code&gt;__typeof__&lt;/code&gt; operator the alias has the same type as the target function. As a result of the &lt;code&gt;copy&lt;/code&gt; attribute the alias also shares the same attributes as the target.</source>
          <target state="translated">예를 들어, 아래 의 &lt;var&gt;StrongAlias&lt;/var&gt; 매크로는 &lt;code&gt;alias&lt;/code&gt; 및 &lt;code&gt;copy&lt;/code&gt; 속성을 사용하여 &lt;var&gt;alloc_size&lt;/var&gt; , &lt;var&gt;malloc&lt;/var&gt; 및 &lt;var&gt;nothrow&lt;/var&gt; 속성으로 선언 &lt;var&gt;allocate&lt;/var&gt; 함수 할당에 &lt;var&gt;alloc&lt;/var&gt; 이라는 별명을 정의합니다 . &lt;code&gt;__typeof__&lt;/code&gt; 연산자 덕분에 별칭은 대상 함수와 유형이 같습니다. &lt;code&gt;copy&lt;/code&gt; 속성의 결과로 별명도 대상과 동일한 속성을 공유합니다.</target>
        </trans-unit>
        <trans-unit id="5df659eda3281e74be2356574e1b1c1a2ec73bd0" translate="yes" xml:space="preserve">
          <source>For example, the call to &lt;code&gt;memset&lt;/code&gt; below is diagnosed by the warning because the function expects a value of type &lt;code&gt;size_t&lt;/code&gt; as its argument but the type of &lt;code&gt;32&lt;/code&gt; is &lt;code&gt;int&lt;/code&gt;. With</source>
          <target state="translated">예를 들어, 아래 &lt;code&gt;memset&lt;/code&gt; 호출 은 함수가 &lt;code&gt;size_t&lt;/code&gt; 유형의 값을 인수로 예상 하지만 유형 &lt;code&gt;32&lt;/code&gt; 는 &lt;code&gt;int&lt;/code&gt; 이므로 경고로 진단됩니다 . 와</target>
        </trans-unit>
        <trans-unit id="aa585d900b6a1decabca1b2daabff17e2775d789" translate="yes" xml:space="preserve">
          <source>For example, the compiler can only unconditionally vectorize the following loop with the pragma:</source>
          <target state="translated">예를 들어, 컴파일러는 pragma를 사용하여 다음 루프를 무조건 벡터화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46fb01ed368f209c80511e7fc1fb91adc3f606e1" translate="yes" xml:space="preserve">
          <source>For example, the declaration of &lt;code&gt;struct Object&lt;/code&gt; in the argument list of &lt;code&gt;draw&lt;/code&gt; triggers the warning. To avoid it, either remove the redundant class-key &lt;code&gt;struct&lt;/code&gt; or replace it with &lt;code&gt;class&lt;/code&gt; to match its definition.</source>
          <target state="translated">예를 들어, &lt;code&gt;draw&lt;/code&gt; 의 인수 목록에서 &lt;code&gt;struct Object&lt;/code&gt; 를 선언 하면 경고가 트리거됩니다. 이를 방지하려면 중복 클래스 키 &lt;code&gt;struct&lt;/code&gt; 를 제거 하거나 정의와 일치하도록 &lt;code&gt;class&lt;/code&gt; 로 대체하십시오 .</target>
        </trans-unit>
        <trans-unit id="99f069ed5ba8ea293548f32b787eaedf45bdbd11" translate="yes" xml:space="preserve">
          <source>For example, the declaration:</source>
          <target state="translated">예를 들어, 선언 :</target>
        </trans-unit>
        <trans-unit id="40a677ec7a2740cf56a10d8e5968835578281034" translate="yes" xml:space="preserve">
          <source>For example, the first two stores in function &lt;code&gt;bad&lt;/code&gt; are diagnosed because the array elements overlap the subsequent members &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;. The third store is diagnosed by</source>
          <target state="translated">예를 들어, 배열 요소가 후속 멤버 &lt;code&gt;b&lt;/code&gt; 및 &lt;code&gt;c&lt;/code&gt; 와 겹치기 때문에 함수 &lt;code&gt;bad&lt;/code&gt; 의 처음 두 저장소 가 진단 됩니다. 세 번째 상점은</target>
        </trans-unit>
        <trans-unit id="b9ea9d42bbb55f00657375149871784a78c15592" translate="yes" xml:space="preserve">
          <source>For example, the following function allocates eight objects of &lt;code&gt;n&lt;/code&gt; bytes each on the stack, storing a pointer to each in consecutive elements of the array &lt;code&gt;a&lt;/code&gt;. It then passes the array to function &lt;code&gt;g&lt;/code&gt; which can safely use the storage pointed to by each of the array elements.</source>
          <target state="translated">예를 들어, 다음 함수 는 스택에 각각 &lt;code&gt;n&lt;/code&gt; 바이트 의 8 개 객체를 할당 하여 배열 &lt;code&gt;a&lt;/code&gt; 의 연속 요소 각각에 대한 포인터를 저장 합니다 . 그런 다음 각 배열 요소가 가리키는 스토리지를 안전하게 사용할 수있는 함수 &lt;code&gt;g&lt;/code&gt; 로 배열을 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="46ff8877e2ba5b3ad38e512c93a9f9393792e49a" translate="yes" xml:space="preserve">
          <source>For example, the following macro can be used to portably check, at compile-time, whether or not adding two constant integers will overflow, and perform the addition only when it is known to be safe and not to trigger a</source>
          <target state="translated">예를 들어, 다음 매크로를 사용하면 컴파일 타임에 두 개의 상수 정수를 추가하면 오버플로되는지 여부를 이식 가능하게 검사하고 안전하다고 알려진 경우에만 추가를 수행하고</target>
        </trans-unit>
        <trans-unit id="0a5e19a07f0f940d54dbc5e573ed269580925a99" translate="yes" xml:space="preserve">
          <source>For example, the following:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f3e3332c2d5e42f3076c20bce36d2593f9127ee9" translate="yes" xml:space="preserve">
          <source>For example, the implementation of the following function &lt;code&gt;foo&lt;/code&gt;:</source>
          <target state="translated">예를 들어 다음 함수 &lt;code&gt;foo&lt;/code&gt; 의 구현은 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="0e188aff9d720764d35dd90d13b53f0b69cd5a6e" translate="yes" xml:space="preserve">
          <source>For example, the intraprocedural example shown for</source>
          <target state="translated">예를 들어, 다음에 대해 표시된 절차 내 예제는</target>
        </trans-unit>
        <trans-unit id="da4fa7f73b59dbaab5c10c7cbf8d1067ea1077b7" translate="yes" xml:space="preserve">
          <source>For example, the same events as above might be printed as:</source>
          <target state="translated">예를 들어, 위와 동일한 이벤트가 다음과 같이 인쇄 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="71a4e8c7eb0a1fa15ef7a86f7ffb6699626c80d0" translate="yes" xml:space="preserve">
          <source>For example, this function has to be used in &lt;code&gt;ifunc&lt;/code&gt; resolvers that check for CPU type using the built-in functions &lt;code&gt;__builtin_cpu_is&lt;/code&gt; and &lt;code&gt;__builtin_cpu_supports&lt;/code&gt;, or in constructors on targets that don&amp;rsquo;t support constructor priority.</source>
          <target state="translated">예를 들어, 내장 함수 &lt;code&gt;__builtin_cpu_is&lt;/code&gt; 및 &lt;code&gt;__builtin_cpu_supports&lt;/code&gt; 를 사용하여 CPU 유형을 확인하는 &lt;code&gt;ifunc&lt;/code&gt; 리졸버 또는 생성자 우선 순위를 지원하지 않는 대상의 생성자 에서이 함수를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="1dddf36660113e27ff669ff510c160e144321d93" translate="yes" xml:space="preserve">
          <source>For example, when the compiler encounters a method invocation such as &lt;code&gt;[object init]&lt;/code&gt;, it compiles it into a call to &lt;code&gt;objc_msg_lookup (object, @selector(init))&lt;/code&gt; followed by a cast of the returned value to the appropriate function pointer type, and then it calls it.</source>
          <target state="translated">예를 들어, 컴파일러에서 &lt;code&gt;[object init]&lt;/code&gt; 와 같은 메소드 호출이 발생하면이 를 &lt;code&gt;objc_msg_lookup (object, @selector(init))&lt;/code&gt; 에 대한 호출로 컴파일 한 후 리턴 된 값을 적절한 함수 포인터 유형으로 캐스트하고 그런 다음 호출합니다.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="25bb7aced1792aec854f4198d7d0398ca1d4713d" translate="yes" xml:space="preserve">
          <source>For full documentation of the struct attributes please see the documentation in &lt;a href=&quot;variable-attributes#x86-Variable-Attributes&quot;&gt;x86 Variable Attributes&lt;/a&gt;.</source>
          <target state="translated">구조체 속성에 대한 전체 설명서는 &lt;a href=&quot;variable-attributes#x86-Variable-Attributes&quot;&gt;x86 변수 속성&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3dc81c80b4604ccbc276f437a5ccc2aaa2515f6c" translate="yes" xml:space="preserve">
          <source>For indirect calls to functions and computed goto, the linker generates &lt;em&gt;stubs&lt;/em&gt;. Stubs are jump pads sometimes also called &lt;em&gt;trampolines&lt;/em&gt;. Thus, the indirect call/jump jumps to such a stub. The stub contains a direct jump to the desired address.</source>
          <target state="translated">함수 및 계산 된 goto에 대한 간접 호출의 경우 링커는 &lt;em&gt;스텁을&lt;/em&gt; 생성 합니다. 스텁은 때때로 &lt;em&gt;트램펄린&lt;/em&gt; 이라고도하는 점프 패드 입니다. 따라서 간접 호출 / 점프는 이러한 스텁으로 이동합니다. 스텁에는 원하는 주소로 직접 점프하는 것이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="b91d6fa4ba31d00f68a512834bc7eb5f8c52df71" translate="yes" xml:space="preserve">
          <source>For information about the O64 ABI, see &lt;a href=&quot;http://gcc.gnu.org/projects/mipso64-abi.html&quot;&gt;http://gcc.gnu.org/projects/mipso64-abi.html&lt;/a&gt;.</source>
          <target state="translated">O64 ABI에 대한 자세한 내용은 &lt;a href=&quot;http://gcc.gnu.org/projects/mipso64-abi.html&quot;&gt;http://gcc.gnu.org/projects/mipso64-abi.html을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="56ee49f1a1b16838ed8d136422788b22655be9ea" translate="yes" xml:space="preserve">
          <source>For input files in any language, generate corresponding Go declarations in &lt;var&gt;file&lt;/var&gt;. This generates Go &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;type&lt;/code&gt;, &lt;code&gt;var&lt;/code&gt;, and &lt;code&gt;func&lt;/code&gt; declarations which may be a useful way to start writing a Go interface to code written in some other language.</source>
          <target state="translated">모든 언어의 입력 파일에 대해 file에서 해당 Go 선언을 생성 &lt;var&gt;file&lt;/var&gt; . 이렇게하면 Go &lt;code&gt;const&lt;/code&gt; , &lt;code&gt;type&lt;/code&gt; , &lt;code&gt;var&lt;/code&gt; 및 &lt;code&gt;func&lt;/code&gt; 선언 이 생성 되어 다른 언어로 작성된 코드에 Go 인터페이스를 작성하는 데 유용한 방법이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8ce6c094048677a9f8423fec4581d4ef1bd1e5b" translate="yes" xml:space="preserve">
          <source>For instance</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="23b7041567e33cbc564ac905e83c0e92b5fee08b" translate="yes" xml:space="preserve">
          <source>For instance,</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="a8e07e43db118dd56bbb97b1f96ccc89bac7f5fd" translate="yes" xml:space="preserve">
          <source>For instance, if the stack starts at absolute address &amp;lsquo;</source>
          <target state="translated">예를 들어, 스택이 절대 주소 '에서 시작하는 경우</target>
        </trans-unit>
        <trans-unit id="6abfd7e7f05346e1123b7bf2021cc93c61b8fbd5" translate="yes" xml:space="preserve">
          <source>For instance, if you have &lt;code&gt;#include &quot;all.h&quot;&lt;/code&gt;, and you have</source>
          <target state="translated">예를 들어 &lt;code&gt;#include &quot;all.h&quot;&lt;/code&gt; 가 있고</target>
        </trans-unit>
        <trans-unit id="5b9b6fe2256c52fcd89c847ec80034c7cbe3d49d" translate="yes" xml:space="preserve">
          <source>For instance, on an x86, you could compile a function with &lt;code&gt;target_clones(&quot;sse4.1,avx&quot;)&lt;/code&gt;. GCC creates two function clones, one compiled with</source>
          <target state="translated">예를 들어, x86에서 &lt;code&gt;target_clones(&quot;sse4.1,avx&quot;)&lt;/code&gt; 로 함수를 컴파일 할 수 있습니다. GCC는 두 개의 함수 클론을 생성합니다. 하나는</target>
        </trans-unit>
        <trans-unit id="175bbce2fc22d4ed1ec7614154a0e449231ccaf1" translate="yes" xml:space="preserve">
          <source>For instance, on an x86, you could declare one function with the &lt;code&gt;target(&quot;sse4.1,arch=core2&quot;)&lt;/code&gt; attribute and another with &lt;code&gt;target(&quot;sse4a,arch=amdfam10&quot;)&lt;/code&gt;. This is equivalent to compiling the first function with</source>
          <target state="translated">예를 들어, x86에서는 &lt;code&gt;target(&quot;sse4.1,arch=core2&quot;)&lt;/code&gt; 속성을 가진 함수 하나 와 &lt;code&gt;target(&quot;sse4a,arch=amdfam10&quot;)&lt;/code&gt; 함수를 하나 선언 할 수 있습니다. 이것은 첫 번째 함수를 사용하여 컴파일하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="60600b26a9fa03b6c3650e82a7d4514147301ef9" translate="yes" xml:space="preserve">
          <source>For instance, on the SB-1, if FP exceptions are disabled, and we are emitting 64-bit code, then we can use both FP pipes. Otherwise, we can only use one FP pipe.</source>
          <target state="translated">예를 들어 SB-1에서 FP 예외가 비활성화되고 64 비트 코드를 내보내는 경우 두 FP 파이프를 모두 사용할 수 있습니다. 그렇지 않으면 하나의 FP 파이프 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d64dcd6f25c2f8e61dbb8fbe7c56bdb2499ab6d" translate="yes" xml:space="preserve">
          <source>For instance, the following declarations</source>
          <target state="translated">예를 들어, 다음 선언</target>
        </trans-unit>
        <trans-unit id="fd17d596f35be2211443642e76ceab4e5f526b5c" translate="yes" xml:space="preserve">
          <source>For internal names, all characters are significant. For external names, the number of significant characters are defined by the linker; for almost all targets, all characters are significant.</source>
          <target state="translated">내부 이름의 경우 모든 문자가 중요합니다. 외부 이름의 경우 유효 문자 수는 링커에 의해 정의됩니다. 거의 모든 대상에 대해 모든 문자가 중요합니다.</target>
        </trans-unit>
        <trans-unit id="9f99386843936f29083f4368b21c1771def8a251" translate="yes" xml:space="preserve">
          <source>For library code, if you want the library to provide all of the template instantiations it needs, just try to link all of its object files together; the link will fail, but cause the instantiations to be generated as a side effect. Be warned, however, that this may cause conflicts if multiple libraries try to provide the same instantiations. For greater control, use explicit instantiation as described in the next option.</source>
          <target state="translated">라이브러리 코드의 경우 라이브러리에서 필요한 모든 템플릿 인스턴스를 제공하려면 모든 객체 파일을 함께 연결하십시오. 링크는 실패하지만 인스턴스화가 부작용으로 생성됩니다. 그러나 여러 라이브러리가 동일한 인스턴스를 제공하려고하면 충돌이 발생할 수 있습니다. 더 효과적으로 제어하려면 다음 옵션에 설명 된대로 명시 적 인스턴스를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="275df5c8ab338eac0891dfd5fcb7ca333c414d1c" translate="yes" xml:space="preserve">
          <source>For machines that must pop arguments after a function call, always pop the arguments as soon as each function returns. At levels</source>
          <target state="translated">함수 호출 후 인수를 팝해야하는 머신의 경우 각 함수가 리턴되는 즉시 인수를 팝하십시오. 레벨에서</target>
        </trans-unit>
        <trans-unit id="4ab62f1721d989066bd88fccf2cddf5cca6c289c" translate="yes" xml:space="preserve">
          <source>For more information concerning the history of Objective-C that is available online, see &lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;http://gcc.gnu.org/readings.html&lt;/a&gt;</source>
          <target state="translated">온라인으로 제공되는 Objective-C의 역사에 대한 자세한 내용은 &lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;http://gcc.gnu.org/readings.html을&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="af9da95259f3bd0345f2ca30bdb8d3f07bd5caf4" translate="yes" xml:space="preserve">
          <source>For more information on GCC&amp;rsquo;s support for transactional memory, See &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/libitm/Enabling-libitm.html#Enabling-libitm&quot;&gt;The GNU Transactional Memory Library&lt;/a&gt; in GNU Transactional Memory Library.</source>
          <target state="translated">트랜잭션 메모리에 대한 GCC의 지원에 대한 자세한 내용 &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/libitm/Enabling-libitm.html#Enabling-libitm&quot;&gt;은 GNU 트랜잭션 메모리 라이브러리의 GNU 트랜잭션 메모리 라이브러리&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="445882425cb6a5526123dcb90201317cd797b812" translate="yes" xml:space="preserve">
          <source>For more information on GCC&amp;rsquo;s support for transactional memory, See &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/libitm/Enabling-libitm.html#Enabling-libitm&quot;&gt;The GNU Transactional Memory Library&lt;/a&gt; in GNU Transactional Memory Library.</source>
          <target state="translated">GCC의 트랜잭션 메모리 지원에 대한 자세한 내용 &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/libitm/Enabling-libitm.html#Enabling-libitm&quot;&gt;은 GNU 트랜잭션 메모리 라이브러리의 GNU 트랜잭션 메모리 라이브러리&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="530d01e06da63e3ae60755b1d0e0664f37ce4c56" translate="yes" xml:space="preserve">
          <source>For profile-directed optimizations, compile the source files again with the same optimization and code generation options plus</source>
          <target state="translated">프로파일 지향 최적화의 경우 동일한 최적화 및 코드 생성 옵션과 함께 소스 파일을 다시 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="1552bee1f905030b453e9bc73123ec457682d5d2" translate="yes" xml:space="preserve">
          <source>For references to Technical Corrigenda, Rationale documents and information concerning the history of C that is available online, see &lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;http://gcc.gnu.org/readings.html&lt;/a&gt;</source>
          <target state="translated">Technical Corrigenda, Rationale 문서 및 온라인으로 제공되는 C의 역사에 관한 정보는 &lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;http://gcc.gnu.org/readings.html을&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="98fa91b9c573243f46d98173cb5c6bc69a14f37e" translate="yes" xml:space="preserve">
          <source>For run-time identification, the starting addresses of these areas, which correspond to their respective function entries minus &lt;var&gt;M&lt;/var&gt;, are additionally collected in the &lt;code&gt;__patchable_function_entries&lt;/code&gt; section of the resulting binary.</source>
          <target state="translated">런타임 식별을 위해, 해당 영역의 시작 주소 (각 기능 항목에서 &lt;var&gt;M&lt;/var&gt; 을 뺀 값 )는 결과 바이너리 의 &lt;code&gt;__patchable_function_entries&lt;/code&gt; 섹션에 추가로 수집됩니다 .</target>
        </trans-unit>
        <trans-unit id="ee4662af110f3d316db91e4c9bf088b26f37f6fc" translate="yes" xml:space="preserve">
          <source>For single-precision floating-point comparisons, emit an &lt;code&gt;fsub&lt;/code&gt; instruction and test the flags. This is faster than a software comparison, but can get incorrect results in the presence of NaNs, or when two different small numbers are compared such that their difference is calculated as zero. The default is</source>
          <target state="translated">단 정밀도 부동 소수점 비교의 경우 &lt;code&gt;fsub&lt;/code&gt; 명령어를 생성하고 플래그를 테스트하십시오. 이는 소프트웨어 비교보다 빠르지 만 NaN이 있거나 두 개의 서로 다른 작은 숫자를 비교하여 차이가 0으로 계산 될 때 잘못된 결과를 얻을 수 있습니다. 디폴트는</target>
        </trans-unit>
        <trans-unit id="629fb7062147649cb1707cc8cbe18549c87c4fce" translate="yes" xml:space="preserve">
          <source>For some target machines, GCC supports additional options to the format attribute (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Declaring Attributes of Functions&lt;/a&gt;).</source>
          <target state="translated">일부 대상 시스템의 경우 GCC는 형식 속성에 대한 추가 옵션을 지원합니다 ( &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;기능 속성 선언&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="8f693ccd95fd0352057c89a84d6dca28111b1d8d" translate="yes" xml:space="preserve">
          <source>For some targets, a suffix is added to the root directory specified with</source>
          <target state="translated">일부 대상의 경우 접미사가로 지정된 루트 디렉토리에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="1eef11d2e0af6679534eba00e39380a79330c652" translate="yes" xml:space="preserve">
          <source>For string operations of unknown size, use run-time checks with inline code for small blocks and a library call for large blocks.</source>
          <target state="translated">알 수없는 크기의 문자열 연산의 경우 작은 블록의 경우 인라인 코드와 큰 블록의 라이브러리 호출로 런타임 검사를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c54c726dd72dd80b773414b86e870a30d193ec02" translate="yes" xml:space="preserve">
          <source>For systems that use the GNU C Library, the default is on.</source>
          <target state="translated">GNU C 라이브러리를 사용하는 시스템의 경우 기본값이 켜져 있습니다.</target>
        </trans-unit>
        <trans-unit id="90889da6f3749d2d8e7f525edbcff60563fc34f5" translate="yes" xml:space="preserve">
          <source>For targets that do not support either COMDAT or weak symbols, most entities with vague linkage are emitted as local symbols to avoid duplicate definition errors from the linker. This does not happen for local statics in inlines, however, as having multiple copies almost certainly breaks things.</source>
          <target state="translated">COMDAT 또는 약한 기호를 지원하지 않는 대상의 경우 모호한 링크가있는 대부분의 엔티티는 로컬 기호로 생성되어 링커에서 중복 정의 오류가 발생하지 않습니다. 그러나 인라인의 로컬 정적에는 여러 사본이 있으면 거의 확실하게 문제가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="db393fbd5a98ab60023bfd22b5dbbadca9023150" translate="yes" xml:space="preserve">
          <source>For targets that normally need trampolines for nested functions, always generate them instead of using descriptors. Otherwise, for targets that do not need them, like for example HP-PA or IA-64, do nothing.</source>
          <target state="translated">중첩 함수에 일반적으로 트램폴린이 필요한 대상의 경우 설명자를 사용하지 않고 항상 생성하십시오. 그렇지 않으면 HP-PA 또는 IA-64와 같이 필요없는 대상의 경우 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3a882a0a0f801f0c1cb983c784834a8c5870b59e" translate="yes" xml:space="preserve">
          <source>For targets, like GNU/Linux, where all user-mode Xtensa code must be position-independent code (PIC), this option disables PIC for compiling kernel code.</source>
          <target state="translated">모든 사용자 모드 Xtensa 코드가 위치 독립적 코드 (PIC) 여야하는 GNU / Linux와 같은 대상의 경우이 옵션은 커널 코드 컴파일을 위해 PIC를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="8b8c7be3bb5a9384ba78f18abd2ee5fc45978a5a" translate="yes" xml:space="preserve">
          <source>For test coverage analysis, use &lt;code&gt;gcov&lt;/code&gt; to produce human readable information from the</source>
          <target state="translated">테스트 범위 분석을 위해 &lt;code&gt;gcov&lt;/code&gt; 를 사용 하여</target>
        </trans-unit>
        <trans-unit id="cdf3f70fc86ab5862691992f6df51e7ca5f5489e" translate="yes" xml:space="preserve">
          <source>For the NeXT runtime with version 2 of the ABI, check for a nil receiver in method invocations before doing the actual method call. This is the default and can be disabled using</source>
          <target state="translated">ABI 버전 2의 NeXT 런타임의 경우 실제 메소드 호출을 수행하기 전에 메소드 호출에서 nil 수신자를 확인하십시오. 이것이 기본값이며 다음을 사용하여 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96b6c6242e369e6ead381c1d4d982f9072cadf3b" translate="yes" xml:space="preserve">
          <source>For the named functions, the compiler adds code to disable interrupts for the duration of those functions. If any functions so named are not encountered in the source, a warning is emitted that the pragma is not used. Examples:</source>
          <target state="translated">명명 된 함수의 경우 컴파일러는 해당 함수가 지속되는 동안 인터럽트를 비활성화하는 코드를 추가합니다. 소스에 이름이 지정된 기능이 없으면 pragma가 사용되지 않는다는 경고가 표시됩니다. 예 :</target>
        </trans-unit>
        <trans-unit id="b4ae72d8349f09925e7db4912a4034594f70873f" translate="yes" xml:space="preserve">
          <source>For the named functions, the compiler always uses a register-indirect call model when calling the named functions. Examples:</source>
          <target state="translated">명명 된 함수의 경우 컴파일러는 명명 된 함수를 호출 할 때 항상 레지스터 간접 호출 모델을 사용합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="b9c34f2bc66483d538061a0df9fde1756b31b97d" translate="yes" xml:space="preserve">
          <source>For the purposes of branch prediction optimizations, the probability that a &lt;code&gt;__builtin_expect&lt;/code&gt; expression is &lt;code&gt;true&lt;/code&gt; is controlled by GCC&amp;rsquo;s &lt;code&gt;builtin-expect-probability&lt;/code&gt; parameter, which defaults to 90%.</source>
          <target state="translated">분기 예측 최적화를 위해 &lt;code&gt;__builtin_expect&lt;/code&gt; 표현식이 &lt;code&gt;true&lt;/code&gt; &lt;code&gt;builtin-expect-probability&lt;/code&gt; 은 기본적으로 90 %로 설정 되는 GCC의 builtin-expect-probability 매개 변수에 의해 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="0f569d15217aa1a086b40826e8ecc6305b091d9b" translate="yes" xml:space="preserve">
          <source>For the purposes of branch prediction optimizations, the probability that a &lt;code&gt;__builtin_expect&lt;/code&gt; expression is &lt;code&gt;true&lt;/code&gt; is controlled by GCC&amp;rsquo;s &lt;code&gt;builtin-expect-probability&lt;/code&gt; parameter, which defaults to 90%. You can also use &lt;code&gt;__builtin_expect_with_probability&lt;/code&gt; to explicitly assign a probability value to individual expressions.</source>
          <target state="translated">분기 예측 최적화를 위해 &lt;code&gt;__builtin_expect&lt;/code&gt; 표현식이 &lt;code&gt;true&lt;/code&gt; 확률 은 GCC의 &lt;code&gt;builtin-expect-probability&lt;/code&gt; 매개 변수에 의해 제어되며 기본값은 90 %입니다. &lt;code&gt;__builtin_expect_with_probability&lt;/code&gt; 를 사용 하여 확률 값을 개별 표현식에 명시 적으로 지정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bf219c0d4bab1b7372e20c5005cc97b0b9e1bb77" translate="yes" xml:space="preserve">
          <source>For the quote form of the include directive, the directories specified by</source>
          <target state="translated">include 지시문의 인용 양식의 경우 다음으로 지정된 디렉토리</target>
        </trans-unit>
        <trans-unit id="754ebda73d52810694ef0086a8c959916039f5fd" translate="yes" xml:space="preserve">
          <source>For the quote form of the include directive, the directory of the current file is searched first.</source>
          <target state="translated">include 지시문의 인용 양식의 경우 현재 파일의 디렉토리가 먼저 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="1d70b004544bcb6341f32cbd058f337db34bac6c" translate="yes" xml:space="preserve">
          <source>For the x86-32 compiler, you must use</source>
          <target state="translated">x86-32 컴파일러의 경우 다음을 사용해야합니다</target>
        </trans-unit>
        <trans-unit id="9e1a32426c586349d0aa1e4bc4474f828e773b55" translate="yes" xml:space="preserve">
          <source>For those adding visibility support to existing code, you may find &lt;code&gt;#pragma GCC visibility&lt;/code&gt; of use. This works by you enclosing the declarations you wish to set visibility for with (for example) &lt;code&gt;#pragma GCC visibility push(hidden)&lt;/code&gt; and &lt;code&gt;#pragma GCC visibility pop&lt;/code&gt;. Bear in mind that symbol visibility should be viewed &lt;strong&gt;as part of the API interface contract&lt;/strong&gt; and thus all new code should always specify visibility when it is not the default; i.e., declarations only for use within the local DSO should &lt;strong&gt;always&lt;/strong&gt; be marked explicitly as hidden as so to avoid PLT indirection overheads&amp;mdash;making this abundantly clear also aids readability and self-documentation of the code. Note that due to ISO C++ specification requirements, &lt;code&gt;operator new&lt;/code&gt; and &lt;code&gt;operator delete&lt;/code&gt; must always be of default visibility.</source>
          <target state="translated">기존 코드에 가시성 지원을 추가하려는 경우 &lt;code&gt;#pragma GCC visibility&lt;/code&gt; 사용을 찾을 수 있습니다. 이것은 가시성을 설정하려는 선언을 &lt;code&gt;#pragma GCC visibility push(hidden)&lt;/code&gt; 및 &lt;code&gt;#pragma GCC visibility pop&lt;/code&gt; . 심볼 가시성은 &lt;strong&gt;API 인터페이스 계약의 일부로&lt;/strong&gt; 볼 수 있으므로 모든 새 코드는 기본값이 아닌 경우 항상 가시성을 지정해야합니다. 즉, 로컬 DSO 내에서만 사용되는 선언은 PLT 간접 간접비를 피하기 위해 &lt;strong&gt;항상&lt;/strong&gt; 명시 적으로 숨겨진 것으로 표시 해야합니다. 이를 명확하게하면 코드의 가독성 및 자체 문서화에 도움이됩니다. ISO C ++ 사양 요구 사항으로 인해 &lt;code&gt;operator new&lt;/code&gt; 및 &lt;code&gt;operator delete&lt;/code&gt; 는 항상 기본 가시성이어야합니다.</target>
        </trans-unit>
        <trans-unit id="bb6de8937de1ff830849ca65a0b4291fa1ceadf7" translate="yes" xml:space="preserve">
          <source>Force (do not force) generated code to have a single exit point in each function.</source>
          <target state="translated">생성 된 코드가 각 함수마다 하나의 종료점을 갖도록 강제하십시오 (강제하지 마십시오).</target>
        </trans-unit>
        <trans-unit id="acd5ffdf657527d019579abefcb2cc6ad1c27289" translate="yes" xml:space="preserve">
          <source>Force (do not force) the use of &lt;code&gt;memcpy&lt;/code&gt; for non-trivial block moves. The default is</source>
          <target state="translated">사소한 블록 이동 에 &lt;code&gt;memcpy&lt;/code&gt; 를 사용하도록 강요하지 마십시오 . 디폴트는</target>
        </trans-unit>
        <trans-unit id="f35628fb15f3c423c03af2c93b844cb43e594383" translate="yes" xml:space="preserve">
          <source>Force &lt;code&gt;long&lt;/code&gt; types to be 64 bits wide. See</source>
          <target state="translated">포스 &lt;code&gt;long&lt;/code&gt; 종류가 다양한 64 비트 수 있습니다. 보다</target>
        </trans-unit>
        <trans-unit id="df341c9e8e9829ab23b420935fbc32e82bb7a353" translate="yes" xml:space="preserve">
          <source>Force &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, and pointer types to be 32 bits wide.</source>
          <target state="translated">강제 &lt;code&gt;long&lt;/code&gt; , &lt;code&gt;int&lt;/code&gt; , 포인터 타입은 폭 32 비트 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a65d4b81903833686ba857ca6166053cb9c8d543" translate="yes" xml:space="preserve">
          <source>Force GCC to assign view numbers internally, if</source>
          <target state="translated">GCC가 내부적으로보기 번호를 지정하도록 강제</target>
        </trans-unit>
        <trans-unit id="5c6c2109c0abfbfad2c57ae80b233af1137f54d6" translate="yes" xml:space="preserve">
          <source>Force GCC to generate DWARF2+ line number tables internally, if DWARF2+ line number tables are to be generated.</source>
          <target state="translated">DWARF2 + 라인 번호 테이블을 생성하려는 경우 GCC가 내부적으로 DWARF2 + 라인 번호 테이블을 생성하도록합니다.</target>
        </trans-unit>
        <trans-unit id="e05ff97a2114aff3fe8702e99f968b0b9b270faf" translate="yes" xml:space="preserve">
          <source>Force all calls to functions to be indirect. This is useful when using Intel Processor Trace where it generates more precise timing information for function calls.</source>
          <target state="translated">함수에 대한 모든 호출을 간접적으로 수행하십시오. 이는 함수 호출에 대한보다 정확한 타이밍 정보를 생성하는 인텔 프로세서 추적을 사용할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="c6aa1876252f253f5c49c98017976af7ef3a9f80" translate="yes" xml:space="preserve">
          <source>Force all functions to be aligned to a 4-byte boundary.</source>
          <target state="translated">모든 기능을 4 바이트 경계에 맞 춥니 다.</target>
        </trans-unit>
        <trans-unit id="5376700e1a5ed02b4facb60bd51b070a514bbd9d" translate="yes" xml:space="preserve">
          <source>Force all load and store instructions to always bypass cache by using I/O variants of the instructions. The default is not to bypass the cache.</source>
          <target state="translated">명령의 I / O 변형을 사용하여 모든로드 및 저장 명령이 항상 캐시를 무시하도록합니다. 기본값은 캐시를 무시하지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6ba14189273ea29b59425c68e227901a2b9a86ef" translate="yes" xml:space="preserve">
          <source>Force assembly output to always use hex constants. Normally such constants are signed decimals, but this option is available for testsuite and/or aesthetic purposes.</source>
          <target state="translated">어셈블리 출력이 항상 16 진 상수를 사용하도록합니다. 일반적으로 이러한 상수는 부호있는 10 진수이지만이 옵션은 테스트 슈트 및 / 또는 미적 목적으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a09ed1d5a3164af1580e37f843c9d03a7f3d9584" translate="yes" xml:space="preserve">
          <source>Force code generation in the ARM (A32) ISA.</source>
          <target state="translated">ARM (A32) ISA에서 강제 코드 생성</target>
        </trans-unit>
        <trans-unit id="8cf31b1c6efcebcf276d6ea54117f6f86a1ab3b3" translate="yes" xml:space="preserve">
          <source>Force code generation in the Thumb (T16/T32) ISA, depending on the architecture level.</source>
          <target state="translated">아키텍처 수준에 따라 Thumb (T16 / T32) ISA에서 코드를 강제로 생성합니다.</target>
        </trans-unit>
        <trans-unit id="57fc3d2f95e9a264681cfb6c086d3f11381e6d22" translate="yes" xml:space="preserve">
          <source>Force indirect call and jump via register.</source>
          <target state="translated">간접 호출을 강제하고 레지스터를 통해 이동합니다.</target>
        </trans-unit>
        <trans-unit id="c2234a2c2c6fa572bb9aaff40c528a12cc4c9fff" translate="yes" xml:space="preserve">
          <source>Force the usage of delay slots for conditional branches, which stuffs the delay slot with a &lt;code&gt;nop&lt;/code&gt; if a suitable instruction cannot be found. By default this option is disabled. It can be enabled to work around hardware bugs as found in the original SH7055.</source>
          <target state="translated">조건부 분기에 지연 슬롯을 사용하도록 하여 적절한 명령을 찾을 수없는 경우 지연 슬롯을 &lt;code&gt;nop&lt;/code&gt; 로 채 웁니다 . 기본적으로이 옵션은 비활성화되어 있습니다. 원래 SH7055에있는 하드웨어 버그를 해결하도록 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="accd79a6ab2ab26b14a5acf0e4624a9287eb4f98" translate="yes" xml:space="preserve">
          <source>Force to call a function using jli_s instruction. This option is valid only for ARCv2 architecture.</source>
          <target state="translated">jli_s 명령어를 사용하여 함수를 강제로 호출합니다. 이 옵션은 ARCv2 아키텍처에만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="bda8d8b269a45b97f862176d65bac6c1e4f4afe4" translate="yes" xml:space="preserve">
          <source>Forces a particular function to be called using &lt;code&gt;jli&lt;/code&gt; instruction. The &lt;code&gt;jli&lt;/code&gt; instruction makes use of a table stored into &lt;code&gt;.jlitab&lt;/code&gt; section, which holds the location of the functions which are addressed using this instruction.</source>
          <target state="translated">&lt;code&gt;jli&lt;/code&gt; 명령어를 사용하여 특정 함수를 강제로 호출 합니다. &lt;code&gt;jli&lt;/code&gt; 명령은 차종에 저장된 테이블의 사용 &lt;code&gt;.jlitab&lt;/code&gt; 이 명령을 사용하여 어드레스 된 기능의 위치를 보유 섹션.</target>
        </trans-unit>
        <trans-unit id="2f084ee73c513d8f966bbd0c40980e7ab5210b2e" translate="yes" xml:space="preserve">
          <source>Formal syntax for attributes.</source>
          <target state="translated">속성의 형식적 구문.</target>
        </trans-unit>
        <trans-unit id="6e97cc41857aff390c1d1352f1580ff15ac71869" translate="yes" xml:space="preserve">
          <source>Format checks specific to particular targets.</source>
          <target state="translated">특정 대상에 특정한 형식 검사.</target>
        </trans-unit>
        <trans-unit id="c4653752f8662d9cf50820b53f4f92b88244d0b2" translate="yes" xml:space="preserve">
          <source>Formerly the &lt;code&gt;hi&lt;/code&gt; register. This constraint is no longer supported.</source>
          <target state="translated">이전에는 &lt;code&gt;hi&lt;/code&gt; 레지스터입니다. 이 제약은 더 이상 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fb001b2c292ad2f619c8caf6e0ac8afd191aaa76" translate="yes" xml:space="preserve">
          <source>Framework</source>
          <target state="translated">Framework</target>
        </trans-unit>
        <trans-unit id="af39dd055c3ef8226fbe929d048cafb094dc8a51" translate="yes" xml:space="preserve">
          <source>Frameworks</source>
          <target state="translated">Frameworks</target>
        </trans-unit>
        <trans-unit id="a4a10834211c2c0fbcb7eeb4d7d706ce399ad1a9" translate="yes" xml:space="preserve">
          <source>Free form Fortran source code that must be preprocessed (with the traditional preprocessor).</source>
          <target state="translated">사전 처리해야하는 자유 형식의 포트란 소스 코드 (전통적인 전 처리기 사용).</target>
        </trans-unit>
        <trans-unit id="ab1de10d533c059aa65605ce6bb4a93b10329a51" translate="yes" xml:space="preserve">
          <source>Free form Fortran source code that should not be preprocessed.</source>
          <target state="translated">전처리해서는 안되는 자유 형식의 포트란 소스 코드.</target>
        </trans-unit>
        <trans-unit id="79c3d4c459214fa53411ede2a681be19e9178e25" translate="yes" xml:space="preserve">
          <source>Fully split wide types early, instead of very late. This option has no effect unless</source>
          <target state="translated">넓은 유형을 매우 늦게가 아니라 일찍 완전히 분할합니다. 이 옵션은</target>
        </trans-unit>
        <trans-unit id="4b3ade0ff4647a9f20d6dba70ea3a9f2cb1aec15" translate="yes" xml:space="preserve">
          <source>Function Pointer Size</source>
          <target state="translated">기능 포인터 크기</target>
        </trans-unit>
        <trans-unit id="5888490bf4ce1fb3617e200efdb6835e0c4faa44" translate="yes" xml:space="preserve">
          <source>Function attributes are introduced by the &lt;code&gt;__attribute__&lt;/code&gt; keyword in the declaration of a function, followed by an attribute specification enclosed in double parentheses. You can specify multiple attributes in a declaration by separating them by commas within the double parentheses or by immediately following one attribute specification with another. See &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;Attribute Syntax&lt;/a&gt;, for the exact rules on attribute syntax and placement. Compatible attribute specifications on distinct declarations of the same function are merged. An attribute specification that is not compatible with attributes already applied to a declaration of the same function is ignored with a warning.</source>
          <target state="translated">함수 속성은 함수 선언에서 &lt;code&gt;__attribute__&lt;/code&gt; 키워드에 의해 소개되고 그 뒤에 이중 괄호로 묶인 속성 스펙이옵니다. 이중 괄호 안에 쉼표로 구분하거나 한 속성 스펙을 다른 속성 스펙 바로 뒤에 따라 선언에 여러 속성을 지정할 수 있습니다. 참조 &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;속성 구문을&lt;/a&gt; 특성 구문 및 배치에 대한 정확한 규칙. 동일한 함수의 고유 한 선언에서 호환되는 속성 사양이 병합됩니다. 동일한 함수의 선언에 이미 적용된 속성과 호환되지 않는 속성 사양은 경고와 함께 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="f93ed46e6d86f7b87373026d5e663168479db390" translate="yes" xml:space="preserve">
          <source>Function precision. The trap handler can determine the function that caused a floating-point exception.</source>
          <target state="translated">기능 정밀도. 트랩 핸들러는 부동 소수점 예외를 발생시킨 함수를 판별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3d655b1f77fc46f162e436abc252a9dc6d8148d" translate="yes" xml:space="preserve">
          <source>Function prototype</source>
          <target state="translated">함수 프로토 타입</target>
        </trans-unit>
        <trans-unit id="9e039f9c7013d88c23a38a281ed14037c4166f2d" translate="yes" xml:space="preserve">
          <source>Function reordering based on profile instrumentation collects first time of execution of a function and orders these functions in ascending order.</source>
          <target state="translated">프로파일 인스 트루먼 테이션을 기반으로하는 함수 재정렬은 함수의 첫 실행 시간을 수집하고이 함수를 오름차순으로 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="84a74152b608e42b8dbf493e4c08ff7789383e02" translate="yes" xml:space="preserve">
          <source>Function return values larger than 64 bits are passed by using a hidden pointer as the first argument of the function. TI ABI, though, mandates that the pointer can be NULL in case the caller is not using the returned value. GNU always passes and expects a valid return value pointer.</source>
          <target state="translated">64 비트보다 큰 함수 반환 값은 숨겨진 포인터를 함수의 첫 번째 인수로 사용하여 전달됩니다. 그러나 TI ABI는 호출자가 반환 된 값을 사용하지 않는 경우 포인터가 NULL 일 수 있도록 요구합니다. GNU는 항상 유효한 반환 값 포인터를 전달하고 기대합니다.</target>
        </trans-unit>
        <trans-unit id="d33f90e4120ff23ca44b34b56f5771105ef3b24d" translate="yes" xml:space="preserve">
          <source>Functions are aligned to 16-bit boundaries.</source>
          <target state="translated">함수는 16 비트 경계에 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="34be57d225a7e4b91308288bf7b00a21a76d0703" translate="yes" xml:space="preserve">
          <source>Functions are aligned to 32-bit boundaries, unless optimizing for size.</source>
          <target state="translated">크기를 최적화하지 않는 한 함수는 32 비트 경계에 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="5a29ddf72dc39612a3206ea0dfa0993bffe35aee" translate="yes" xml:space="preserve">
          <source>Functions declared with the &lt;code&gt;naked&lt;/code&gt; attribute also require basic &lt;code&gt;asm&lt;/code&gt; (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;naked&lt;/code&gt; 속성으로 선언 된 함수 에는 기본 &lt;code&gt;asm&lt;/code&gt; 이 필요합니다 ( &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="b405d9a1c02455968daea5fb86ad7161a05b238c" translate="yes" xml:space="preserve">
          <source>Functions from different modes can be inlined in the caller&amp;rsquo;s mode.</source>
          <target state="translated">발신자 모드에서 다른 모드의 기능을 인라인 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a51173ce4592b6408dafbf5dcd763cb00409451e" translate="yes" xml:space="preserve">
          <source>Functions prologues/epilogues are expanded as calls to appropriate subroutines. Code size is smaller.</source>
          <target state="translated">프롤로그 / 에필로그 기능은 적절한 서브 루틴에 대한 호출로 확장됩니다. 코드 크기가 더 작습니다.</target>
        </trans-unit>
        <trans-unit id="958942a81a4fb21510019af4adcbaec4037ab18c" translate="yes" xml:space="preserve">
          <source>Functions that are normally built in but do not have semantics defined by ISO C (such as &lt;code&gt;alloca&lt;/code&gt; and &lt;code&gt;ffs&lt;/code&gt;) are not built-in functions when</source>
          <target state="translated">일반적으로 내장되어 있지만 ISO C에 의해 정의 된 의미가없는 함수 (예 : &lt;code&gt;alloca&lt;/code&gt; 및 &lt;code&gt;ffs&lt;/code&gt; )는 내장 함수가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="a77748cc250a919f08dac1cbb97eb54cbd2d36e9" translate="yes" xml:space="preserve">
          <source>Funding Free Software</source>
          <target state="translated">자금 조달 자유 소프트웨어</target>
        </trans-unit>
        <trans-unit id="ad51c11605482040955d96c2db6f7d9f4eca570e" translate="yes" xml:space="preserve">
          <source>Furthermore, if the &lt;em&gt;earlyclobber&lt;/em&gt; operand is also a read/write operand, then that operand is written only after it&amp;rsquo;s used.</source>
          <target state="translated">또한 &lt;em&gt;초기 클로버&lt;/em&gt; 피연산자가 읽기 / 쓰기 피연산자 인 경우 해당 피연산자는 사용한 후에 만 ​​기록됩니다.</target>
        </trans-unit>
        <trans-unit id="8c1a9865dc580dc97d71f0ac34525d7ff40826cf" translate="yes" xml:space="preserve">
          <source>Future versions of GCC may zero-extend, or use a target-defined &lt;code&gt;ptr_extend&lt;/code&gt; pattern. Do not rely on sign extension.</source>
          <target state="translated">이후 버전의 GCC는 제로 확장 또는 대상 정의 &lt;code&gt;ptr_extend&lt;/code&gt; 패턴을 사용할 수 있습니다. 부호 확장에 의존하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="a36a6718f54524d846894fb04b5b885b4e43e63b" translate="yes" xml:space="preserve">
          <source>G</source>
          <target state="translated">G</target>
        </trans-unit>
        <trans-unit id="6ed55690929b9e60aff3a9282723cba6d9ce77ea" translate="yes" xml:space="preserve">
          <source>G++ allows a virtual function returning &amp;lsquo;</source>
          <target state="translated">G ++은 가상 함수가 '</target>
        </trans-unit>
        <trans-unit id="5114ba459fc06431a44841ea4654eb2a26a6c91e" translate="yes" xml:space="preserve">
          <source>G++ allows anonymous structs and unions to have members that are not public non-static data members (i.e. fields). These extensions are deprecated.</source>
          <target state="translated">G ++을 사용하면 익명 구조체와 공용체에 정적이 아닌 공개 데이터 멤버가 아닌 멤버 (예 : 필드)를 가질 수 있습니다. 이 확장은 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="de3e575c048ce4bfb45f20c4e2302053983a6e85" translate="yes" xml:space="preserve">
          <source>G++ allows attributes to follow a parenthesized direct initializer, e.g. &amp;lsquo;</source>
          <target state="translated">G ++를 사용하면 속성이 괄호로 묶인 직접 초기화 프로그램을 따를 수 있습니다 (예 : '</target>
        </trans-unit>
        <trans-unit id="4279ad338a301cce60cdfae7e5135ebd09b1878c" translate="yes" xml:space="preserve">
          <source>G++ allows floating-point literals to appear in integral constant expressions, e.g. &amp;lsquo;</source>
          <target state="translated">G ++를 사용하면 부동 소수점 리터럴이 정수 상수 표현식에 나타날 수 있습니다 (예 : '</target>
        </trans-unit>
        <trans-unit id="c5b988dd39fdeb99ab7e438425f37e6884df0f08" translate="yes" xml:space="preserve">
          <source>G++ allows static data members of const floating-point type to be declared with an initializer in a class definition. The standard only allows initializers for static members of const integral types and const enumeration types so this extension has been deprecated and will be removed from a future version.</source>
          <target state="translated">G ++를 사용하면 const 부동 소수점 형식의 정적 데이터 멤버를 클래스 정의에서 초기화 자로 선언 할 수 있습니다. 표준은 const 정수형과 const 열거 형의 정적 멤버에 대한 이니셜 라이저 만 허용하므로이 확장은 더 이상 사용되지 않으며 향후 버전에서 제거 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="63f7f4841ad757c79aac590be15aedf6621086d6" translate="yes" xml:space="preserve">
          <source>G++ implements the &amp;ldquo;intuitive&amp;rdquo; algorithm for copy-assignment: assign all direct bases, then assign all members. In that algorithm, the virtual base subobject can be encountered more than once. In the example, copying proceeds in the following order: &amp;lsquo;</source>
          <target state="translated">G ++는 복사 할당을위한 &quot;직관적 인&quot;알고리즘을 구현합니다. 모든 직접베이스를 할당 한 다음 모든 멤버를 할당합니다. 이 알고리즘에서 가상 기본 하위 오브젝트가 두 번 이상 발생할 수 있습니다. 이 예에서 복사는 다음 순서로 진행됩니다. '</target>
        </trans-unit>
        <trans-unit id="67e3c9106f6559177c33511b2d979e92d246d3b0" translate="yes" xml:space="preserve">
          <source>G++ implements the Borland model on targets where the linker supports it, including ELF targets (such as GNU/Linux), Mac OS X and Microsoft Windows. Otherwise G++ implements neither automatic model.</source>
          <target state="translated">G ++는 ELF 대상 (GNU / Linux 등), Mac OS X 및 Microsoft Windows를 포함하여 링커에서 지원하는 대상에서 Borland 모델을 구현합니다. 그렇지 않으면 G ++는 자동 모델을 구현하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="31ff568d5d2e9d2f6743afcdc5f3a983bc913e2f" translate="yes" xml:space="preserve">
          <source>G++ implements the same behavior as GCC does when assigning to a volatile object&amp;mdash;there is no reread of the assigned-to object, the assigned rvalue is reused. Note that in C++ assignment expressions are lvalues, and if used as an lvalue, the volatile object is referred to. For instance, &lt;var&gt;vref&lt;/var&gt; refers to &lt;var&gt;vobj&lt;/var&gt;, as expected, in the following example:</source>
          <target state="translated">G ++는 휘발성 객체에 할당 할 때 GCC와 동일한 동작을 구현합니다. 할당 된 객체를 다시 읽지 않고 할당 된 rvalue가 재사용됩니다. C ++ 대입 표현식에서 lvalue는 lvalue로 사용되며 lvalue로 사용되는 경우 휘발성 객체가 참조됩니다. 예를 들어, 다음 예제에서 &lt;var&gt;vref&lt;/var&gt; 는 예상대로 &lt;var&gt;vobj&lt;/var&gt; 를 참조합니다 .</target>
        </trans-unit>
        <trans-unit id="a1650ba68fd434ff4571a3ae6e0e946daaa36507" translate="yes" xml:space="preserve">
          <source>G3</source>
          <target state="translated">G3</target>
        </trans-unit>
        <trans-unit id="57c24c56c83113e722078337cfe2d513db43c570" translate="yes" xml:space="preserve">
          <source>G4</source>
          <target state="translated">G4</target>
        </trans-unit>
        <trans-unit id="75cc572d557c39d31a9a311423998e30b6913f73" translate="yes" xml:space="preserve">
          <source>G5</source>
          <target state="translated">G5</target>
        </trans-unit>
        <trans-unit id="47bc5f06e2bc84be8cac3eeae94be31fd0bb67f8" translate="yes" xml:space="preserve">
          <source>GBR</source>
          <target state="translated">GBR</target>
        </trans-unit>
        <trans-unit id="8577b47d2b705ad56be34a1a6a9f6472d1ac1001" translate="yes" xml:space="preserve">
          <source>GCC</source>
          <target state="translated">GCC</target>
        </trans-unit>
        <trans-unit id="2128b3c47a543c2fd225378159dcf1cee572dc1a" translate="yes" xml:space="preserve">
          <source>GCC aims towards being usable as a conforming freestanding implementation, or as the compiler for a conforming hosted implementation. By default, it acts as the compiler for a hosted implementation, defining &lt;code&gt;__STDC_HOSTED__&lt;/code&gt; as &lt;code&gt;1&lt;/code&gt; and presuming that when the names of ISO C functions are used, they have the semantics defined in the standard. To make it act as a conforming freestanding implementation for a freestanding environment, use the option</source>
          <target state="translated">GCC는 적합한 독립 실행 형 구현 또는 적합한 호스팅 구현을위한 컴파일러로 사용하는 것을 목표로합니다. 기본적으로 &lt;code&gt;__STDC_HOSTED__&lt;/code&gt; 를 &lt;code&gt;1&lt;/code&gt; 로 정의 하고 ISO C 함수의 이름을 사용할 때 표준에 정의 된 의미가 있다고 가정 하여 호스팅 된 구현의 컴파일러 역할을합니다 . 독립형 환경에 적합한 독립형 구현으로 작동하게하려면 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a09efcf4281abbe557aa1d8c0037c8b8db485c71" translate="yes" xml:space="preserve">
          <source>GCC allows attributes to be set on C labels. See &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;Attribute Syntax&lt;/a&gt;, for details of the exact syntax for using attributes. Other attributes are available for functions (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;), variables (see &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;), enumerators (see &lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;Enumerator Attributes&lt;/a&gt;), statements (see &lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;Statement Attributes&lt;/a&gt;), and for types (see &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Type Attributes&lt;/a&gt;).</source>
          <target state="translated">GCC를 사용하면 C 레이블에 속성을 설정할 수 있습니다. &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;속성&lt;/a&gt; 사용에 대한 정확한 구문에 대한 자세한 내용은 속성 구문을 참조하십시오 . 함수 ( &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;함수 속성&lt;/a&gt; 참조 ), 변수 ( &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;변수 속성&lt;/a&gt; 참조 ), 열거 자 ( &lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;열거 속성&lt;/a&gt; 참조 ), 명령문 ( &lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;문 속성&lt;/a&gt; 참조 ) 및 유형 ( &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;유형 속성&lt;/a&gt; 참조)에 대해 다른 속성을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="188d2c46ce847222650ff9a197ae21b6d36834fd" translate="yes" xml:space="preserve">
          <source>GCC allows attributes to be set on enumerators. See &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;Attribute Syntax&lt;/a&gt;, for details of the exact syntax for using attributes. Other attributes are available for functions (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;), variables (see &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;), labels (see &lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;Label Attributes&lt;/a&gt;), statements (see &lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;Statement Attributes&lt;/a&gt;), and for types (see &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Type Attributes&lt;/a&gt;).</source>
          <target state="translated">GCC를 사용하면 열거 자에 속성을 설정할 수 있습니다. &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;속성&lt;/a&gt; 사용에 대한 정확한 구문에 대한 자세한 내용은 속성 구문을 참조하십시오 . 함수 ( &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;함수 속성&lt;/a&gt; 참조 ), 변수 ( &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;변수 속성&lt;/a&gt; 참조 ), 레이블 ( &lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;레이블 속성&lt;/a&gt; 참조 ), 명령문 ( &lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;문 속성&lt;/a&gt; 참조 ) 및 유형 ( &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;유형 속성&lt;/a&gt; 참조)에 대해 다른 속성을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1318f5f0c876968e4d22801744660b2a68a5dbc1" translate="yes" xml:space="preserve">
          <source>GCC allows attributes to be set on null statements. See &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;Attribute Syntax&lt;/a&gt;, for details of the exact syntax for using attributes. Other attributes are available for functions (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;), variables (see &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;), labels (see &lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;Label Attributes&lt;/a&gt;), enumerators (see &lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;Enumerator Attributes&lt;/a&gt;), and for types (see &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Type Attributes&lt;/a&gt;).</source>
          <target state="translated">GCC를 사용하면 null 문에 특성을 설정할 수 있습니다. &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;속성&lt;/a&gt; 사용에 대한 정확한 구문에 대한 자세한 내용은 속성 구문을 참조하십시오 . 함수 ( &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;함수 속성&lt;/a&gt; 참조 ), 변수 ( &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;변수 속성&lt;/a&gt; 참조 ), 레이블 ( &lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;레이블 속성&lt;/a&gt; 참조 ), 열거 자 ( &lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;열거 기 속성&lt;/a&gt; 참조 ) 및 유형 ( &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;유형 속성&lt;/a&gt; 참조)에 대해 다른 속성을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8f7518a10a612c3aa4683ccb174e0aca674b8c50" translate="yes" xml:space="preserve">
          <source>GCC allows static initialization of flexible array members. This is equivalent to defining a new structure containing the original structure followed by an array of sufficient size to contain the data. E.g. in the following, &lt;code&gt;f1&lt;/code&gt; is constructed as if it were declared like &lt;code&gt;f2&lt;/code&gt;.</source>
          <target state="translated">GCC는 유연한 배열 구성원의 정적 초기화를 허용합니다. 이는 원래 구조를 포함하는 새 구조를 정의한 다음 데이터를 포함하기에 충분한 크기의 배열을 정의하는 것과 같습니다. 예를 들어, 다음에서 &lt;code&gt;f1&lt;/code&gt; 은 마치 &lt;code&gt;f2&lt;/code&gt; 처럼 선언 된 것처럼 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="2f25be809d122cad042e0db0bcc9a75b7e95df2b" translate="yes" xml:space="preserve">
          <source>GCC allows the user to selectively enable or disable certain types of diagnostics, and change the kind of the diagnostic. For example, a project&amp;rsquo;s policy might require that all sources compile with</source>
          <target state="translated">GCC를 통해 사용자는 특정 유형의 진단을 선택적으로 활성화 또는 비활성화하고 진단 종류를 변경할 수 있습니다. 예를 들어, 프로젝트 정책에 따라 모든 소스가</target>
        </trans-unit>
        <trans-unit id="095246dfc125cf940fca19907500328219191dc3" translate="yes" xml:space="preserve">
          <source>GCC allows using a &lt;code&gt;typedef&lt;/code&gt; name as the type specifier for a vector type, but only under the following circumstances:</source>
          <target state="translated">GCC에서는 &lt;code&gt;typedef&lt;/code&gt; 이름을 벡터 유형의 유형 지정자로 사용할 수 있지만 다음 상황에서만 가능합니다.</target>
        </trans-unit>
        <trans-unit id="118ab2384628648bceb8c24d3c1faa22f9cfc67a" translate="yes" xml:space="preserve">
          <source>GCC allows using a &lt;code&gt;typedef&lt;/code&gt; name as the type specifier for a vector type.</source>
          <target state="translated">GCC에서는 &lt;code&gt;typedef&lt;/code&gt; 이름을 벡터 유형의 유형 지정자로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4dbc0782ac4d82d0f286d4feca2e87d560c81769" translate="yes" xml:space="preserve">
          <source>GCC allows you to declare &lt;em&gt;local labels&lt;/em&gt; in any nested block scope. A local label is just like an ordinary label, but you can only reference it (with a &lt;code&gt;goto&lt;/code&gt; statement, or by taking its address) within the block in which it is declared.</source>
          <target state="translated">GCC를 사용하면 중첩 된 블록 범위에서 &lt;em&gt;로컬 레이블&lt;/em&gt; 을 선언 할 수 있습니다 . 로컬 레이블은 일반 레이블과 비슷하지만 선언 된 블록 내 에서만 레이블을 참조 할 수 있습니다 ( &lt;code&gt;goto&lt;/code&gt; 문을 사용하거나 주소를 사용하여).</target>
        </trans-unit>
        <trans-unit id="11edda20db587e9081a40a5791b651f14e5edef4" translate="yes" xml:space="preserve">
          <source>GCC allows you to use</source>
          <target state="translated">GCC를 사용하면</target>
        </trans-unit>
        <trans-unit id="cb8172c4270b6a56a430a2344a1d357df8a89c7e" translate="yes" xml:space="preserve">
          <source>GCC already has an extensive list of suffixes built into it. This directive adds an entry to the end of the list of suffixes, but since the list is searched from the end backwards, it is effectively possible to override earlier entries using this technique.</source>
          <target state="translated">GCC에는 이미 광범위한 접미사 목록이 있습니다. 이 지시문은 접미사 목록 끝에 항목을 추가하지만 목록을 끝에서 뒤로 검색하므로이 기술을 사용하여 이전 항목을 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4946c9e7401c541aac6237c0b11a4f8762636048" translate="yes" xml:space="preserve">
          <source>GCC also defines the macro &lt;code&gt;__m&lt;var&gt;uarch&lt;/var&gt;__&lt;/code&gt; when tuning for ColdFire microarchitecture &lt;var&gt;uarch&lt;/var&gt;, where &lt;var&gt;uarch&lt;/var&gt; is one of the arguments given above.</source>
          <target state="translated">또한 GCC는 ColdFire 마이크로 아키텍처 &lt;var&gt;uarch&lt;/var&gt; 를 조정할 때 매크로 &lt;code&gt;__m&lt;var&gt;uarch&lt;/var&gt;__&lt;/code&gt; 정의합니다 . 여기서 &lt;var&gt;uarch&lt;/var&gt; 는 위에 제공된 인수 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="bd57161c41c158f961b92f3f1147120413b6477d" translate="yes" xml:space="preserve">
          <source>GCC also knows implicitly that arguments starting in</source>
          <target state="translated">GCC는 또한 인수가 다음에서 시작한다는 것을 암시 적으로 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="5590aa7708108855eef5df246b0491a821f68f35" translate="yes" xml:space="preserve">
          <source>GCC also offers a simple mechanism for printing messages during compilation.</source>
          <target state="translated">GCC는 컴파일 중에 메시지를 인쇄하기위한 간단한 메커니즘도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ff5eb1c7d3d1103b9c01d9df5e0e050903b1adc0" translate="yes" xml:space="preserve">
          <source>GCC also provides a target specific macro &lt;code&gt;__BIGGEST_ALIGNMENT__&lt;/code&gt;, which is the largest alignment ever used for any data type on the target machine you are compiling for. For example, you could write:</source>
          <target state="translated">GCC는 또한 대상 특정 매크로 &lt;code&gt;__BIGGEST_ALIGNMENT__&lt;/code&gt; 를 제공하는데 , 이는 컴파일중인 대상 시스템의 모든 데이터 유형에 사용 된 최대 정렬입니다. 예를 들어 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ce6a581ce58e7b0e52deb0ba48b6684312e9d7c" translate="yes" xml:space="preserve">
          <source>GCC also provides intrinsics to directly access the network registers. The intrinsics are:</source>
          <target state="translated">GCC는 또한 네트워크 레지스터에 직접 액세스 할 수있는 내장 기능을 제공합니다. 본질은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="028d66aa5e30f9984efa701c3d35086edefd3f65" translate="yes" xml:space="preserve">
          <source>GCC also supports attributes on variable declarations (see &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;), labels (see &lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;Label Attributes&lt;/a&gt;), enumerators (see &lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;Enumerator Attributes&lt;/a&gt;), statements (see &lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;Statement Attributes&lt;/a&gt;), and types (see &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Type Attributes&lt;/a&gt;).</source>
          <target state="translated">GCC는 변수 선언 ( &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;변수 속성&lt;/a&gt; 참조 ), 레이블 ( &lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;레이블 속성&lt;/a&gt; 참조 ), 열거 자 ( &lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;열거 속성&lt;/a&gt; 참조 ), 명령문 ( &lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;문 속성&lt;/a&gt; 참조 ) 및 유형 ( &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;유형 속성&lt;/a&gt; 참조 )에 대한 속성도 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="51353b73f0da65e20b68eea37e8d612e8b885954" translate="yes" xml:space="preserve">
          <source>GCC also warns about function definitions that might be candidates for &lt;code&gt;format&lt;/code&gt; attributes. Again, these are only possible candidates. GCC guesses that &lt;code&gt;format&lt;/code&gt; attributes might be appropriate for any function that calls a function like &lt;code&gt;vprintf&lt;/code&gt; or &lt;code&gt;vscanf&lt;/code&gt;, but this might not always be the case, and some functions for which &lt;code&gt;format&lt;/code&gt; attributes are appropriate may not be detected.</source>
          <target state="translated">GCC는 &lt;code&gt;format&lt;/code&gt; 속성의 후보가 될 수있는 함수 정의에 대해서도 경고 합니다. 다시, 이들은 가능한 후보자입니다. GCC는 추측 &lt;code&gt;format&lt;/code&gt; 속성이 같은 함수 호출하는 기능에 적합 할 수 있습니다 &lt;code&gt;vprintf&lt;/code&gt; 또는 &lt;code&gt;vscanf&lt;/code&gt; 을 하지만, 항상 그렇지,하고있는 일부 기능하지 않을 수 있습니다 &lt;code&gt;format&lt;/code&gt; 속성이 검색되지 않을 수 있습니다 적절한이다.</target>
        </trans-unit>
        <trans-unit id="e6346f95ac263c787786ddc66b5d9c0bcd8bac71" translate="yes" xml:space="preserve">
          <source>GCC always follows the C99 and C11 requirement that the result of division is truncated towards zero.</source>
          <target state="translated">GCC는 항상 C99 및 C11 요구 사항을 따르므로 나눗셈 결과가 0으로 잘립니다.</target>
        </trans-unit>
        <trans-unit id="71e58c529399ec16a2da4be1a53c86f1d271b88e" translate="yes" xml:space="preserve">
          <source>GCC always tries to compile your program if possible; it never gratuitously rejects a program whose meaning is clear merely because (for instance) it fails to conform to a standard. In some cases, however, the C and C++ standards specify that certain extensions are forbidden, and a diagnostic &lt;em&gt;must&lt;/em&gt; be issued by a conforming compiler. The</source>
          <target state="translated">GCC는 가능한 경우 항상 프로그램 컴파일을 시도합니다. (예를 들어) 표준을 준수하지 않기 때문에 그 의미가 분명한 프로그램을 절대 거부하지 않습니다. 그러나 어떤 경우에는 C 및 C ++ 표준에 따라 특정 확장이 금지 되어 있으며 적합한 컴파일러 에서 진단 &lt;em&gt;을&lt;/em&gt; 발행 &lt;em&gt;해야합니다&lt;/em&gt; . 그만큼</target>
        </trans-unit>
        <trans-unit id="3d850d85ff9e9c0132b4336d9517c8233fd73c22" translate="yes" xml:space="preserve">
          <source>GCC by default uses the GNU Objective-C runtime library, which is part of GCC and is not the same as the Apple/NeXT Objective-C runtime library used on Apple systems. There are a number of differences documented in this manual. The options</source>
          <target state="translated">GCC는 기본적으로 GCC의 일부이며 Apple 시스템에서 사용되는 Apple / NeXT Objective-C 런타임 라이브러리와 동일하지 않은 GNU Objective-C 런타임 라이브러리를 사용합니다. 이 설명서에는 여러 가지 차이점이 있습니다. 옵션</target>
        </trans-unit>
        <trans-unit id="1c0b38c968b6ef5ec06e42505963f829a108bef3" translate="yes" xml:space="preserve">
          <source>GCC by itself attempts to be a conforming freestanding implementation. See &lt;a href=&quot;standards#Standards&quot;&gt;Language Standards Supported by GCC&lt;/a&gt;, for details of what this means. Beyond the library facilities required of such an implementation, the rest of the C library is supplied by the vendor of the operating system. If that C library doesn&amp;rsquo;t conform to the C standards, then your programs might get warnings (especially when using</source>
          <target state="translated">GCC 자체는 적합한 독립 실행 형 구현을 시도합니다. 이것이 의미하는 바에 대한 자세한 내용은 &lt;a href=&quot;standards#Standards&quot;&gt;GCC가 지원하는 언어 표준을&lt;/a&gt; 참조하십시오 . 이러한 구현에 필요한 라이브러리 기능 외에도 나머지 C 라이브러리는 운영 체제 공급 업체에서 제공합니다. 해당 C 라이브러리가 C 표준을 준수하지 않으면 프로그램에 경고 메시지가 표시 될 수 있습니다 (특히</target>
        </trans-unit>
        <trans-unit id="a367622db7093a4cc9943cb9b928ad16a228659d" translate="yes" xml:space="preserve">
          <source>GCC can allocate complex automatic variables in a noncontiguous fashion; it&amp;rsquo;s even possible for the real part to be in a register while the imaginary part is on the stack (or vice versa). Only the DWARF debug info format can represent this, so use of DWARF is recommended. If you are using the stabs debug info format, GCC describes a noncontiguous complex variable as if it were two separate variables of noncomplex type. If the variable&amp;rsquo;s actual name is &lt;code&gt;foo&lt;/code&gt;, the two fictitious variables are named &lt;code&gt;foo$real&lt;/code&gt; and &lt;code&gt;foo$imag&lt;/code&gt;. You can examine and set these two fictitious variables with your debugger.</source>
          <target state="translated">GCC는 복잡한 자동 변수를 비 연속 방식으로 할당 할 수 있습니다. 허수 부분이 스택에있는 동안 (또는 그 반대) 실제 부분이 레지스터에있을 수도 있습니다. DWARF 디버그 정보 형식 만이를 나타낼 수 있으므로 DWARF를 사용하는 것이 좋습니다. stabs 디버그 정보 형식을 사용하는 경우 GCC는 비 연속 복합 변수를 비 복합 유형의 두 개의 개별 변수 인 것처럼 설명합니다. 변수의 실제 이름이 &lt;code&gt;foo&lt;/code&gt; 인 경우 두 가상의 변수 이름은 &lt;code&gt;foo$real&lt;/code&gt; 및 &lt;code&gt;foo$imag&lt;/code&gt; 입니다. 디버거를 사용하여이 두 가상 변수를 검사하고 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c74211307275623a7dfd79983ff1fca91bf2ce8" translate="yes" xml:space="preserve">
          <source>GCC can also be configured (via the</source>
          <target state="translated">GCC를 구성 할 수도 있습니다 (</target>
        </trans-unit>
        <trans-unit id="f1f3d3d856350fe50d86862ccf0921b96281e6bd" translate="yes" xml:space="preserve">
          <source>GCC can compile the binary representation (BRIG) of the HSAIL text format as described in HSA Programmer&amp;rsquo;s Reference Manual version 1.0.1. This capability is typically utilized to implement the HSA runtime API&amp;rsquo;s HSAIL finalization extension for a gcc supported processor. HSA standards are freely available at &lt;a href=&quot;http://www.hsafoundation.com/standards/&quot;&gt;http://www.hsafoundation.com/standards/&lt;/a&gt;.</source>
          <target state="translated">GCC는 HSA 프로그래머 참조 설명서 버전 1.0.1에 설명 된대로 HSAIL 텍스트 형식의 이진 표현 (BRIG)을 컴파일 할 수 있습니다. 이 기능은 일반적으로 gcc 지원 프로세서에 대한 HSA 런타임 API의 HSAIL 최종 확장을 구현하는 데 사용됩니다. HSA 표준은 &lt;a href=&quot;http://www.hsafoundation.com/standards/&quot;&gt;http://www.hsafoundation.com/standards/&lt;/a&gt; 에서 자유롭게 구할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="87356dae6f4ed6235c36eedc0fe148afee6229d9" translate="yes" xml:space="preserve">
          <source>GCC can generate code for both VxWorks kernels and real time processes (RTPs). This option switches from the former to the latter. It also defines the preprocessor macro &lt;code&gt;__RTP__&lt;/code&gt;.</source>
          <target state="translated">GCC는 VxWorks 커널과 실시간 프로세스 (RTP) 모두에 대한 코드를 생성 할 수 있습니다. 이 옵션은 전자에서 후자로 전환됩니다. 또한 전 처리기 매크로 &lt;code&gt;__RTP__&lt;/code&gt; 도 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="fb9f5282eec43cb95e4c422b1995ae6896ab686c" translate="yes" xml:space="preserve">
          <source>GCC can only handle one commutative pair in an asm; if you use more, the compiler may fail. Note that you need not use the modifier if the two alternatives are strictly identical; this would only waste time in the reload pass.</source>
          <target state="translated">GCC는 asm에서 하나의 교환 쌍만 처리 할 수 ​​있습니다. 더 많이 사용하면 컴파일러가 실패 할 수 있습니다. 두 대안이 완전히 동일한 경우 수정자를 사용할 필요가 없습니다. 이것은 재 장전 패스에서 시간을 낭비 할뿐입니다.</target>
        </trans-unit>
        <trans-unit id="78d74922e82c5075040c6a08c44444ac34a5ad2a" translate="yes" xml:space="preserve">
          <source>GCC comes with shell scripts to fix certain known problems in system header files. They install corrected copies of various header files in a special directory where only GCC will normally look for them. The scripts adapt to various systems by searching all the system header files for the problem cases that we know about.</source>
          <target state="translated">GCC는 시스템 헤더 파일에서 알려진 특정 문제를 해결하기위한 쉘 스크립트와 함께 제공됩니다. GCC만이 일반적으로 찾을 수있는 특수 디렉토리에 다양한 헤더 파일의 수정 사본을 설치합니다. 스크립트는 우리가 알고있는 문제 사례에 대한 모든 시스템 헤더 파일을 검색하여 다양한 시스템에 적응합니다.</target>
        </trans-unit>
        <trans-unit id="cd976cd951c888839dc15c99651c6a379e4c0cac" translate="yes" xml:space="preserve">
          <source>GCC compiled code sometimes emits warnings from the HP-UX assembler of the form:</source>
          <target state="translated">GCC 컴파일 코드는 때때로 다음 형식의 HP-UX 어셈블러에서 경고를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="81e4ed9eaf205df3f6c599be30d212f56ac91924" translate="yes" xml:space="preserve">
          <source>GCC complains about program fragments such as &amp;lsquo;</source>
          <target state="translated">GCC는 '와 같은 프로그램 조각에 대해 불평합니다.</target>
        </trans-unit>
        <trans-unit id="67982454dd3e3b7d64f34362d5f739d9716bb143" translate="yes" xml:space="preserve">
          <source>GCC complains about unterminated character constants inside of preprocessing conditionals that fail. Some programs have English comments enclosed in conditionals that are guaranteed to fail; if these comments contain apostrophes, GCC will probably report an error. For example, this code would produce an error:</source>
          <target state="translated">GCC는 전처리 조건부 내에서 종료되지 않은 문자 상수에 대해 불평합니다. 일부 프로그램에는 조건부로 영어 설명이 포함되어있어 실패 할 수 있습니다. 이러한 주석에 아포스트로피가 포함 된 경우 GCC에서 오류를보고 할 수 있습니다. 예를 들어이 코드는 오류를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="e4bb7adbf45dc4a3fb687d7313280a86480960d6" translate="yes" xml:space="preserve">
          <source>GCC complies with the OpenPOWER 64-Bit ELF V2 ABI Specification, which may be found at &lt;a href=&quot;http://openpowerfoundation.org/wp-content/uploads/resources/leabi-prd/content/index.html&quot;&gt;http://openpowerfoundation.org/wp-content/uploads/resources/leabi-prd/content/index.html&lt;/a&gt;. Appendix A of this document lists the vector API interfaces that must be provided by compliant compilers. Programmers should preferentially use the interfaces described therein. However, historically GCC has provided additional interfaces for access to vector instructions. These are briefly described below.</source>
          <target state="translated">GCC complies with the OpenPOWER 64-Bit ELF V2 ABI Specification, which may be found at &lt;a href=&quot;http://openpowerfoundation.org/wp-content/uploads/resources/leabi-prd/content/index.html&quot;&gt;http://openpowerfoundation.org/wp-content/uploads/resources/leabi-prd/content/index.html&lt;/a&gt;. Appendix A of this document lists the vector API interfaces that must be provided by compliant compilers. Programmers should preferentially use the interfaces described therein. However, historically GCC has provided additional interfaces for access to vector instructions. These are briefly described below.</target>
        </trans-unit>
        <trans-unit id="c80707819ec65b1cb82541da2d3b9e30cf2076e3" translate="yes" xml:space="preserve">
          <source>GCC complies with the OpenPOWER 64-Bit ELF V2 ABI Specification, which may be found at &lt;a href=&quot;https://openpowerfoundation.org/?resource_lib=64-bit-elf-v2-abi-specification-power-architecture&quot;&gt;https://openpowerfoundation.org/?resource_lib=64-bit-elf-v2-abi-specification-power-architecture&lt;/a&gt;. Appendix A of this document lists the vector API interfaces that must be provided by compliant compilers. Programmers should preferentially use the interfaces described therein. However, historically GCC has provided additional interfaces for access to vector instructions. These are briefly described below.</source>
          <target state="translated">GCC는 &lt;a href=&quot;https://openpowerfoundation.org/?resource_lib=64-bit-elf-v2-abi-specification-power-architecture&quot;&gt;https://openpowerfoundation.org/?resource_lib=64-bit-elf-v2-abi-specification-power-architecture&lt;/a&gt; 에서 찾을 수있는 OpenPOWER 64 비트 ELF V2 ABI 사양을 준수합니다 . 이 문서의 부록 A에는 호환 컴파일러에서 제공해야하는 벡터 API 인터페이스가 나열되어 있습니다. 프로그래머는 여기에 설명 된 인터페이스를 우선적으로 사용해야합니다. 그러나 역사적으로 GCC는 벡터 명령어에 액세스하기위한 추가 인터페이스를 제공했습니다. 이에 대해서는 아래에서 간략하게 설명합니다.</target>
        </trans-unit>
        <trans-unit id="65f9b929facca207bcc2021009f1c0587b957cbf" translate="yes" xml:space="preserve">
          <source>GCC currently emits calls to &lt;code&gt;vmldExp2&lt;/code&gt;, &lt;code&gt;vmldLn2&lt;/code&gt;, &lt;code&gt;vmldLog102&lt;/code&gt;, &lt;code&gt;vmldPow2&lt;/code&gt;, &lt;code&gt;vmldTanh2&lt;/code&gt;, &lt;code&gt;vmldTan2&lt;/code&gt;, &lt;code&gt;vmldAtan2&lt;/code&gt;, &lt;code&gt;vmldAtanh2&lt;/code&gt;, &lt;code&gt;vmldCbrt2&lt;/code&gt;, &lt;code&gt;vmldSinh2&lt;/code&gt;, &lt;code&gt;vmldSin2&lt;/code&gt;, &lt;code&gt;vmldAsinh2&lt;/code&gt;, &lt;code&gt;vmldAsin2&lt;/code&gt;, &lt;code&gt;vmldCosh2&lt;/code&gt;, &lt;code&gt;vmldCos2&lt;/code&gt;, &lt;code&gt;vmldAcosh2&lt;/code&gt;, &lt;code&gt;vmldAcos2&lt;/code&gt;, &lt;code&gt;vmlsExp4&lt;/code&gt;, &lt;code&gt;vmlsLn4&lt;/code&gt;, &lt;code&gt;vmlsLog104&lt;/code&gt;, &lt;code&gt;vmlsPow4&lt;/code&gt;, &lt;code&gt;vmlsTanh4&lt;/code&gt;, &lt;code&gt;vmlsTan4&lt;/code&gt;, &lt;code&gt;vmlsAtan4&lt;/code&gt;, &lt;code&gt;vmlsAtanh4&lt;/code&gt;, &lt;code&gt;vmlsCbrt4&lt;/code&gt;, &lt;code&gt;vmlsSinh4&lt;/code&gt;, &lt;code&gt;vmlsSin4&lt;/code&gt;, &lt;code&gt;vmlsAsinh4&lt;/code&gt;, &lt;code&gt;vmlsAsin4&lt;/code&gt;, &lt;code&gt;vmlsCosh4&lt;/code&gt;, &lt;code&gt;vmlsCos4&lt;/code&gt;, &lt;code&gt;vmlsAcosh4&lt;/code&gt; and &lt;code&gt;vmlsAcos4&lt;/code&gt; for corresponding function type when</source>
          <target state="translated">GCC는 현재 호출 방출 &lt;code&gt;vmldExp2&lt;/code&gt; , &lt;code&gt;vmldLn2&lt;/code&gt; , &lt;code&gt;vmldLog102&lt;/code&gt; , &lt;code&gt;vmldPow2&lt;/code&gt; , &lt;code&gt;vmldTanh2&lt;/code&gt; , &lt;code&gt;vmldTan2&lt;/code&gt; , &lt;code&gt;vmldAtan2&lt;/code&gt; , &lt;code&gt;vmldAtanh2&lt;/code&gt; , &lt;code&gt;vmldCbrt2&lt;/code&gt; , &lt;code&gt;vmldSinh2&lt;/code&gt; , &lt;code&gt;vmldSin2&lt;/code&gt; , &lt;code&gt;vmldAsinh2&lt;/code&gt; , &lt;code&gt;vmldAsin2&lt;/code&gt; , &lt;code&gt;vmldCosh2&lt;/code&gt; , &lt;code&gt;vmldCos2&lt;/code&gt; , &lt;code&gt;vmldAcosh2&lt;/code&gt; , &lt;code&gt;vmldAcos2&lt;/code&gt; , &lt;code&gt;vmlsExp4&lt;/code&gt; , &lt;code&gt;vmlsLn4&lt;/code&gt; , &lt;code&gt;vmlsLog104&lt;/code&gt; , &lt;code&gt;vmlsPow4&lt;/code&gt; , &lt;code&gt;vmlsTanh4&lt;/code&gt; 을 , &lt;code&gt;vmlsTan4&lt;/code&gt; , &lt;code&gt;vmlsAtan4&lt;/code&gt; , &lt;code&gt;vmlsAtanh4&lt;/code&gt; , &lt;code&gt;vmlsCbrt4&lt;/code&gt; , &lt;code&gt;vmlsSinh4&lt;/code&gt; , &lt;code&gt;vmlsSin4&lt;/code&gt; , &lt;code&gt;vmlsAsinh4&lt;/code&gt; , &lt;code&gt;vmlsAsin4&lt;/code&gt; , &lt;code&gt;vmlsCosh4&lt;/code&gt; , &lt;code&gt;vmlsCos4&lt;/code&gt; , &lt;code&gt;vmlsAcosh4&lt;/code&gt; 및 &lt;code&gt;vmlsAcos4&lt;/code&gt; 유형</target>
        </trans-unit>
        <trans-unit id="16f9d8d14967dad5157f0d4d4177e77917294c63" translate="yes" xml:space="preserve">
          <source>GCC defines a macro &lt;code&gt;__mcf&lt;var&gt;arch&lt;/var&gt;__&lt;/code&gt; whenever it is generating code for a ColdFire target. The &lt;var&gt;arch&lt;/var&gt; in this macro is one of the</source>
          <target state="translated">GCC는 ColdFire 대상에 대한 코드를 생성 할 때마다 매크로 &lt;code&gt;__mcf&lt;var&gt;arch&lt;/var&gt;__&lt;/code&gt; 정의합니다 . 이 매크로 의 &lt;var&gt;arch&lt;/var&gt; 는</target>
        </trans-unit>
        <trans-unit id="9690667ebb3c4d196426b91a67e183bca646b7c4" translate="yes" xml:space="preserve">
          <source>GCC defines a preprocessor macro for the specified &lt;var&gt;cpu&lt;/var&gt;. For the &amp;lsquo;</source>
          <target state="translated">GCC는 지정된 &lt;var&gt;cpu&lt;/var&gt; 에 대한 전 처리기 매크로를 정의합니다 . '</target>
        </trans-unit>
        <trans-unit id="1ee4979d83e119fc65d0b3ce42180431e0b52daf" translate="yes" xml:space="preserve">
          <source>GCC defines several built-in macros so that the user code can test for the presence or absence of features. Almost any of the following built-in macros are deduced from device capabilities and thus triggered by the</source>
          <target state="translated">GCC는 몇 가지 기본 제공 매크로를 정의하여 사용자 코드가 기능의 존재 여부를 테스트 할 수 있습니다. 다음의 내장 매크로 중 거의 모든 것이 장치 기능에서 추론되므로</target>
        </trans-unit>
        <trans-unit id="07c2bb68cb370eca1e6a61c97987834533dcec03" translate="yes" xml:space="preserve">
          <source>GCC defines the macro &lt;code&gt;__mcf_cpu_&lt;var&gt;cpu&lt;/var&gt;&lt;/code&gt; when ColdFire target &lt;var&gt;cpu&lt;/var&gt; is selected. It also defines &lt;code&gt;__mcf_family_&lt;var&gt;family&lt;/var&gt;&lt;/code&gt;, where the value of &lt;var&gt;family&lt;/var&gt; is given by the table above.</source>
          <target state="translated">GCC는 ColdFire 대상 &lt;var&gt;cpu&lt;/var&gt; 가 선택된 경우 매크로 &lt;code&gt;__mcf_cpu_&lt;var&gt;cpu&lt;/var&gt;&lt;/code&gt; 를 정의합니다 . 또한 정의 &lt;code&gt;__mcf_family_&lt;var&gt;family&lt;/var&gt;&lt;/code&gt; &lt;var&gt;family&lt;/var&gt; 의 값, &lt;var&gt;family&lt;/var&gt; 위 표에 의해 주어진다된다.</target>
        </trans-unit>
        <trans-unit id="57340a71d3d941522f73fea99d6d51e3e8ce6ff1" translate="yes" xml:space="preserve">
          <source>GCC defines the macro &lt;code&gt;__mcfhwdiv__&lt;/code&gt; when this option is enabled.</source>
          <target state="translated">GCC는 이 옵션이 활성화되면 매크로 &lt;code&gt;__mcfhwdiv__&lt;/code&gt; 를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="6a9b1f894460a8c96f48083896afccfe85c9be79" translate="yes" xml:space="preserve">
          <source>GCC defines the macros &lt;code&gt;__mc&lt;var&gt;arch&lt;/var&gt;&lt;/code&gt; and &lt;code&gt;__mc&lt;var&gt;arch&lt;/var&gt;__&lt;/code&gt; when tuning for 680x0 architecture &lt;var&gt;arch&lt;/var&gt;. It also defines &lt;code&gt;mc&lt;var&gt;arch&lt;/var&gt;&lt;/code&gt; unless either</source>
          <target state="translated">GCC는 680x0 아키텍처 &lt;var&gt;arch&lt;/var&gt; 조정할 때 매크로 &lt;code&gt;__mc&lt;var&gt;arch&lt;/var&gt;&lt;/code&gt; 및 &lt;code&gt;__mc&lt;var&gt;arch&lt;/var&gt;__&lt;/code&gt; 정의합니다 . 또한 &lt;code&gt;mc&lt;var&gt;arch&lt;/var&gt;&lt;/code&gt; &lt;var&gt;arch&lt;/var&gt; 를 정의 하지 않는 한</target>
        </trans-unit>
        <trans-unit id="2885698109b0288d9891eaf5f6f566e33bc93a28" translate="yes" xml:space="preserve">
          <source>GCC defines the preprocessor macro &lt;code&gt;__HAVE_BUILTIN_SPECULATION_SAFE_VALUE&lt;/code&gt; for targets that have been updated to support this builtin.</source>
          <target state="translated">GCC는 이 기본 제공을 지원하도록 업데이트 된 대상에 대한 전 처리기 매크로 &lt;code&gt;__HAVE_BUILTIN_SPECULATION_SAFE_VALUE&lt;/code&gt; 를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="9502202879d2e8497b3ab7402351c2cfb4aba65d" translate="yes" xml:space="preserve">
          <source>GCC defines two macros based on the value of this option. The first is &lt;code&gt;_MIPS_ARCH&lt;/code&gt;, which gives the name of target architecture, as a string. The second has the form &lt;code&gt;_MIPS_ARCH_&lt;var&gt;foo&lt;/var&gt;&lt;/code&gt;, where &lt;var&gt;foo&lt;/var&gt; is the capitalized value of &lt;code&gt;_MIPS_ARCH&lt;/code&gt;. For example,</source>
          <target state="translated">GCC는이 옵션의 값에 따라 두 개의 매크로를 정의합니다. 첫 번째는 &lt;code&gt;_MIPS_ARCH&lt;/code&gt; 이며 대상 아키텍처의 이름을 문자열로 제공합니다. 두 번째는 &lt;code&gt;_MIPS_ARCH_&lt;var&gt;foo&lt;/var&gt;&lt;/code&gt; 형식입니다 . 여기서 &lt;var&gt;foo&lt;/var&gt; 는 &lt;code&gt;_MIPS_ARCH&lt;/code&gt; 의 대문자 값입니다 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="a26b5e085873721291414d2146a69ef3ff2df942" translate="yes" xml:space="preserve">
          <source>GCC depresses SSEx instructions when</source>
          <target state="translated">GCC가 SSEx 명령어를 누르면</target>
        </trans-unit>
        <trans-unit id="f00d9db0f7babc17a8b2e93a16eaa154dca9484f" translate="yes" xml:space="preserve">
          <source>GCC does not inline any functions when not optimizing unless you specify the &amp;lsquo;</source>
          <target state="translated">'을 지정하지 않으면 GCC는 최적화하지 않을 때 함수를 인라인하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d979e47341cf32b9e9788a98df7db938c53659aa" translate="yes" xml:space="preserve">
          <source>GCC does not parse basic &lt;code&gt;asm&lt;/code&gt;&amp;rsquo;s &lt;var&gt;AssemblerInstructions&lt;/var&gt;, which means there is no way to communicate to the compiler what is happening inside them. GCC has no visibility of symbols in the &lt;code&gt;asm&lt;/code&gt; and may discard them as unreferenced. It also does not know about side effects of the assembler code, such as modifications to memory or registers. Unlike some compilers, GCC assumes that no changes to general purpose registers occur. This assumption may change in a future release.</source>
          <target state="translated">GCC는 기본 &lt;code&gt;asm&lt;/code&gt; 의 &lt;var&gt;AssemblerInstructions&lt;/var&gt; 를 구문 분석하지 않으므로 컴파일러 내부에서 발생하는 작업을 컴파일러와 통신 할 방법이 없습니다. GCC는 &lt;code&gt;asm&lt;/code&gt; 에서 심볼을 볼 수 없으며 참조되지 않은 것으로 버릴 수 있습니다. 또한 메모리 또는 레지스터 수정과 같은 어셈블러 코드의 부작용에 대해서도 알지 못합니다. 일부 컴파일러와 달리 GCC는 범용 레지스터가 변경되지 않는다고 가정합니다. 이 가정은 향후 릴리스에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd46297b79a48028b406a3a22f8df3c38f23ed53" translate="yes" xml:space="preserve">
          <source>GCC does not provide the C library functionality associated with</source>
          <target state="translated">GCC는 다음과 관련된 C 라이브러리 기능을 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="96d71d57d6177ab6f3fc682f6b185f4541d680d8" translate="yes" xml:space="preserve">
          <source>GCC does not provide the library facilities required only of hosted implementations, nor yet all the facilities required by C99 of freestanding implementations on all platforms. To use the facilities of a hosted environment, you need to find them elsewhere (for example, in the GNU C library). See &lt;a href=&quot;standard-libraries#Standard-Libraries&quot;&gt;Standard Libraries&lt;/a&gt;.</source>
          <target state="translated">GCC는 호스팅 된 구현에만 필요한 라이브러리 기능을 제공하지는 않지만 C99에서 모든 플랫폼에서 독립 실행 형 구현에 필요한 모든 기능을 제공하지는 않습니다. 호스팅 환경의 기능을 사용하려면 다른 곳 (예 : GNU C 라이브러리)에서 해당 기능을 찾아야합니다. &lt;a href=&quot;standard-libraries#Standard-Libraries&quot;&gt;표준 라이브러리를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="86c923d0a51125464840f7ea1874cf6ab2974fb7" translate="yes" xml:space="preserve">
          <source>GCC does not substitute macro arguments when they appear inside of string constants. For example, the following macro in GCC</source>
          <target state="translated">GCC는 문자열 상수 안에 나타날 때 매크로 인수를 대체하지 않습니다. 예를 들어 GCC의 다음 매크로</target>
        </trans-unit>
        <trans-unit id="42a91da8639ee03ec161a4bd756ad60809129b66" translate="yes" xml:space="preserve">
          <source>GCC does not support any extended integer types.</source>
          <target state="translated">GCC는 확장 정수 유형을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3ce5b628a549292da4090df5538cf2cd3541c673" translate="yes" xml:space="preserve">
          <source>GCC does not support using this feature with a non-static local variable since such variables do not have assembler names. If you are trying to put the variable in a particular register, see &lt;a href=&quot;explicit-register-variables#Explicit-Register-Variables&quot;&gt;Explicit Register Variables&lt;/a&gt;.</source>
          <target state="translated">GCC는 정적이 아닌 로컬 변수와 함께이 기능을 지원하지 않습니다. 이러한 변수에는 어셈블러 이름이 없기 때문입니다. 변수를 특정 레지스터에 넣으려는 경우 &lt;a href=&quot;explicit-register-variables#Explicit-Register-Variables&quot;&gt;명시 적 레지스터 변수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="057dd4b479d4087929d93c02eca9edfef895599b" translate="yes" xml:space="preserve">
          <source>GCC does not use such values.</source>
          <target state="translated">GCC는 이러한 값을 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6b22e4a77b39e5fcd62364faba592ec172555481" translate="yes" xml:space="preserve">
          <source>GCC emits warnings based on this attribute by default; use</source>
          <target state="translated">GCC는 기본적으로이 속성을 기반으로 경고를 보냅니다. 사용하다</target>
        </trans-unit>
        <trans-unit id="6213b35197bfb3bb104e08212f01a4cf35332f2f" translate="yes" xml:space="preserve">
          <source>GCC enables this option by default. If you want to force the compiler to check if a variable is referenced, regardless of whether or not optimization is turned on, use the</source>
          <target state="translated">GCC는 기본적으로이 옵션을 활성화합니다. 최적화가 설정되어 있는지 여부에 관계없이 컴파일러가 변수가 참조되는지 확인하도록하려면</target>
        </trans-unit>
        <trans-unit id="d7b2a859b296fb3f8914b78d7834ccf3e648a510" translate="yes" xml:space="preserve">
          <source>GCC has currently no support for non-fragile instance variables.</source>
          <target state="translated">GCC는 현재 취약하지 않은 인스턴스 변수를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9b64961814c7627599dfb66d9541dfbc1c55e8a3" translate="yes" xml:space="preserve">
          <source>GCC has long supported variadic macros, and used a different syntax that allowed you to give a name to the variable arguments just like any other argument. Here is an example:</source>
          <target state="translated">GCC는 오랫동안 가변성 매크로를 지원했으며 다른 인수와 마찬가지로 변수 인수에 이름을 지정할 수있는 다른 구문을 사용했습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e677a4ecf07d49ec983c792d6fd35d17489c7528" translate="yes" xml:space="preserve">
          <source>GCC has the following spec strings built into it. Spec files can override these strings or create their own. Note that individual targets can also add their own spec strings to this list.</source>
          <target state="translated">GCC에는 다음과 같은 사양 문자열이 내장되어 있습니다. 스펙 파일은 이러한 문자열을 대체하거나 고유 한 문자열을 작성할 수 있습니다. 개별 대상도이 목록에 고유 한 사양 문자열을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed8411601030aef9d10cc9d6209db6260f4d910d" translate="yes" xml:space="preserve">
          <source>GCC implements a limited buffer overflow protection mechanism that can prevent some buffer overflow attacks by determining the sizes of objects into which data is about to be written and preventing the writes when the size isn&amp;rsquo;t sufficient. The built-in functions described below yield the best results when used together and when optimization is enabled. For example, to detect object sizes across function boundaries or to follow pointer assignments through non-trivial control flow they rely on various optimization passes enabled with</source>
          <target state="translated">GCC는 제한된 버퍼 오버 플로우 방지 메커니즘을 구현하여 데이터를 쓰려는 객체의 크기를 결정하고 크기가 충분하지 않은 경우 쓰기를 방지함으로써 일부 버퍼 오버 플로우 공격을 방지 할 수 있습니다. 아래에 설명 된 내장 함수는 함께 사용하거나 최적화가 활성화 된 경우 최상의 결과를 제공합니다. 예를 들어, 기능 경계에서 객체 크기를 감지하거나 사소하지 않은 제어 흐름을 통해 포인터 할당을 따르려면</target>
        </trans-unit>
        <trans-unit id="c63f8d617f5fcd74378c430997fb1de4655a5a57" translate="yes" xml:space="preserve">
          <source>GCC implements extensions for C as described in the ARM C Language Extensions (ACLE) specification, which can be found at &lt;a href=&quot;http://infocenter.arm.com/help/topic/com.arm.doc.ihi0053c/IHI0053C_acle_2_0.pdf&quot;&gt;http://infocenter.arm.com/help/topic/com.arm.doc.ihi0053c/IHI0053C_acle_2_0.pdf&lt;/a&gt;.</source>
          <target state="translated">GCC는 &lt;a href=&quot;http://infocenter.arm.com/help/topic/com.arm.doc.ihi0053c/IHI0053C_acle_2_0.pdf&quot;&gt;http://infocenter.arm.com/help/topic/com.arm.doc.ihi0053c/IHI0053C_acle_2_0.pdf&lt;/a&gt; 에있는 ARM C 언어 확장 (ACLE) 사양에 설명 된대로 C 확장을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="293bbd3b2e69a9d930833e11f1b427e7997876a6" translate="yes" xml:space="preserve">
          <source>GCC implements for both C and C++ a syntactic extension to implement the &lt;code&gt;offsetof&lt;/code&gt; macro.</source>
          <target state="translated">GCC는 C 및 C ++ 모두에 &lt;code&gt;offsetof&lt;/code&gt; 매크로 를 구현하기위한 구문 확장을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="322077390825044afaea930b7263992ddcea81e8" translate="yes" xml:space="preserve">
          <source>GCC implements taking the address of a nested function using a technique called &lt;em&gt;trampolines&lt;/em&gt;. This technique was described in Lexical Closures for C++ (Thomas M. Breuel, USENIX C++ Conference Proceedings, October 17-21, 1988).</source>
          <target state="translated">GCC는 &lt;em&gt;trampolines&lt;/em&gt; 라는 기술을 사용하여 중첩 함수의 주소를 가져옵니다 . 이 기술은 C ++의 Lexical Closures (1988 년 10 월 17-21 일 USENIX C ++ Conference Proceedings의 Thomas M. Breuel)에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="239348ac99d6992297a72fcc17bd9b383a471db0" translate="yes" xml:space="preserve">
          <source>GCC implements the ARMv8-M Security Extensions as described in the ARMv8-M Security Extensions: Requirements on Development Tools Engineering Specification, which can be found at &lt;a href=&quot;http://infocenter.arm.com/help/topic/com.arm.doc.ecm0359818/ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0.pdf&quot;&gt;http://infocenter.arm.com/help/topic/com.arm.doc.ecm0359818/ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0.pdf&lt;/a&gt;.</source>
          <target state="translated">GCC는 ARMv8-M 보안 확장 : 개발 도구 엔지니어링 요구 사항 요구 사항 ( &lt;a href=&quot;http://infocenter.arm.com/help/topic/com.arm.doc.ecm0359818/ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0.pdf&quot;&gt;http://infocenter.arm.com/help/topic/com.arm.doc)에&lt;/a&gt; 설명 된대로 ARMv8-M 보안 확장을 구현합니다 . ecm0359818 / ECM0359818_armv8m_security_extensions_reqs_on_dev_tools_1_0.pdf .</target>
        </trans-unit>
        <trans-unit id="7c1d6efdb055c03457ac985aa41eeb676f9d1c1c" translate="yes" xml:space="preserve">
          <source>GCC implements three different semantics of declaring a function inline. One is available with</source>
          <target state="translated">GCC는 함수를 인라인으로 선언하는 세 가지 시맨틱을 구현합니다. 하나는</target>
        </trans-unit>
        <trans-unit id="16fab68e571685f848321494bfa65aa76fa12ecf" translate="yes" xml:space="preserve">
          <source>GCC includes built-in versions of many of the functions in the standard C library. These functions come in two forms: one whose names start with the &lt;code&gt;__builtin_&lt;/code&gt; prefix, and the other without. Both forms have the same type (including prototype), the same address (when their address is taken), and the same meaning as the C library functions even if you specify the</source>
          <target state="translated">GCC에는 표준 C 라이브러리에 여러 함수의 내장 버전이 포함되어 있습니다. 이 함수는 이름이 &lt;code&gt;__builtin_&lt;/code&gt; 접두사로 시작 하고 다른 하나는없는 두 가지 형식으로 제공됩니다 . 두 형식 모두 동일한 유형 (시제품 포함), 동일한 주소 (주소를 가져올 때) 및 C 라이브러리 함수와 동일한 의미를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="6ddb06bf023a460b3469518f6828ceb9799c46e8" translate="yes" xml:space="preserve">
          <source>GCC is incompatible with traditional C.</source>
          <target state="translated">GCC는 기존 C와 호환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d28b24326033740593178727cd1510ca18099b74" translate="yes" xml:space="preserve">
          <source>GCC is only limited by available memory.</source>
          <target state="translated">GCC는 사용 가능한 메모리에 의해서만 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="e1b7ed70d92a385236df81656270c5df961819cc" translate="yes" xml:space="preserve">
          <source>GCC needs to install corrected versions of some system header files. This is because most target systems have some header files that won&amp;rsquo;t work with GCC unless they are changed. Some have bugs, some are incompatible with ISO C, and some depend on special features of other compilers.</source>
          <target state="translated">GCC는 일부 시스템 헤더 파일의 수정 된 버전을 설치해야합니다. 대부분의 대상 시스템에는 변경하지 않는 한 GCC에서 작동하지 않는 일부 헤더 파일이 있기 때문입니다. 일부는 버그가 있고 일부는 ISO C와 호환되지 않으며 일부는 다른 컴파일러의 특수 기능에 의존합니다.</target>
        </trans-unit>
        <trans-unit id="6fec00d5e695a6ba7008f039024af2f2354b9175" translate="yes" xml:space="preserve">
          <source>GCC no longer supports DWARF Version 1, which is substantially different than Version 2 and later. For historical reasons, some other DWARF-related options such as</source>
          <target state="translated">GCC는 더 이상 DWARF 버전 1을 지원하지 않으며 이는 버전 2 이상과 실질적으로 다릅니다. 역사적 이유로 다음과 같은 다른 DWARF 관련 옵션</target>
        </trans-unit>
        <trans-unit id="9571fcf4d32ba7634429d5420351196a13337bf1" translate="yes" xml:space="preserve">
          <source>GCC normally defines &lt;code&gt;__STDC__&lt;/code&gt; to be 1, and in addition defines &lt;code&gt;__STRICT_ANSI__&lt;/code&gt; if you specify the</source>
          <target state="translated">GCC는 일반적으로 &lt;code&gt;__STDC__&lt;/code&gt; 를 1로 정의하고 추가로 &lt;code&gt;__STRICT_ANSI__&lt;/code&gt; 를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="d2a04d28db5bb4fd272285d6f2261f1af937b1aa" translate="yes" xml:space="preserve">
          <source>GCC normally generates special code to handle certain built-in functions more efficiently; for instance, calls to &lt;code&gt;alloca&lt;/code&gt; may become single instructions which adjust the stack directly, and calls to &lt;code&gt;memcpy&lt;/code&gt; may become inline copy loops. The resulting code is often both smaller and faster, but since the function calls no longer appear as such, you cannot set a breakpoint on those calls, nor can you change the behavior of the functions by linking with a different library. In addition, when a function is recognized as a built-in function, GCC may use information about that function to warn about problems with calls to that function, or to generate more efficient code, even if the resulting code still contains calls to that function. For example, warnings are given with</source>
          <target state="translated">GCC는 일반적으로 특정 내장 함수를보다 효율적으로 처리하기 위해 특수 코드를 생성합니다. 예를 들어, &lt;code&gt;alloca&lt;/code&gt; 호출 은 스택을 직접 조정하는 단일 명령이 될 수 있으며 &lt;code&gt;memcpy&lt;/code&gt; 호출 은 인라인 복사 루프가 될 수 있습니다. 결과 코드는 종종 더 작고 빠르지 만 함수 호출이 더 이상 나타나지 않으므로 해당 호출에 중단 점을 설정할 수 없으며 다른 라이브러리와 연결하여 함수의 동작을 변경할 수도 없습니다. 또한 함수가 내장 함수로 인식되면 GCC는 해당 함수에 대한 정보를 사용하여 해당 함수에 대한 호출 문제에 대해 경고하거나 결과 코드에 여전히 해당 함수에 대한 호출이 포함되어 있어도보다 효율적인 코드를 생성 할 수 있습니다 . 예를 들어, 경고는</target>
        </trans-unit>
        <trans-unit id="7e6e1ac548faaad8ae2131d82037c03b74f72b7e" translate="yes" xml:space="preserve">
          <source>GCC normally makes string constants read-only. If several identical-looking string constants are used, GCC stores only one copy of the string.</source>
          <target state="translated">GCC는 일반적으로 문자열 상수를 읽기 전용으로 만듭니다. 동일한 모양의 문자열 상수가 여러 개 사용되는 경우 GCC는 문자열의 복사본 하나만 저장합니다.</target>
        </trans-unit>
        <trans-unit id="11a713f18e4fa0802eb282a6537925d48c0259a3" translate="yes" xml:space="preserve">
          <source>GCC normally uses a single instruction to load values from the GOT. While this is relatively efficient, it only works if the GOT is smaller than about 64k. Anything larger causes the linker to report an error such as:</source>
          <target state="translated">GCC는 일반적으로 단일 명령을 사용하여 GOT에서 값을로드합니다. 이것은 비교적 효율적이지만 GOT가 약 64k보다 작은 경우에만 작동합니다. 더 큰 것은 링커가 다음과 같은 오류를보고하게합니다.</target>
        </trans-unit>
        <trans-unit id="be424d75f5ffc48b72e433597659af0ae3069a92" translate="yes" xml:space="preserve">
          <source>GCC option.</source>
          <target state="translated">GCC 옵션.</target>
        </trans-unit>
        <trans-unit id="0cb280cc3350dd85b51b4e6912bba246b1815ba4" translate="yes" xml:space="preserve">
          <source>GCC permits a C structure to have no members:</source>
          <target state="translated">GCC는 C 구조체가 멤버를 갖지 않도록 허용합니다.</target>
        </trans-unit>
        <trans-unit id="410ccd5268fc842081ec500688897d4eab9d507c" translate="yes" xml:space="preserve">
          <source>GCC provides a couple of special builtin functions to aid in the writing of interrupt handlers in C.</source>
          <target state="translated">GCC는 C에서 인터럽트 핸들러 작성을 지원하는 몇 가지 특수 내장 함수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9a84666be4b2834544f27c65de6a453c576dd60a" translate="yes" xml:space="preserve">
          <source>GCC provides a large number of built-in functions other than the ones mentioned above. Some of these are for internal use in the processing of exceptions or variable-length argument lists and are not documented here because they may change from time to time; we do not recommend general use of these functions.</source>
          <target state="translated">GCC는 위에서 언급 한 것 이외의 많은 내장 기능을 제공합니다. 이들 중 일부는 예외 또는 가변 길이 인수 목록 처리에 내부적으로 사용되며 수시로 변경 될 수 있으므로 여기에 문서화되어 있지 않습니다. 이러한 기능은 일반적으로 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="dd6c408349b302ebed79b324cb6148ad8750cb77" translate="yes" xml:space="preserve">
          <source>GCC provides an interface for the PowerPC family of processors to access the AltiVec operations described in Motorola&amp;rsquo;s AltiVec Programming Interface Manual. The interface is made available by including &lt;code&gt;&amp;lt;altivec.h&amp;gt;&lt;/code&gt; and using</source>
          <target state="translated">GCC는 PowerPC 프로세서 제품군이 Motorola의 AltiVec 프로그래밍 인터페이스 매뉴얼에 설명 된 AltiVec 작업에 액세스 할 수있는 인터페이스를 제공합니다. &lt;code&gt;&amp;lt;altivec.h&amp;gt;&lt;/code&gt; 를 포함 하고 사용하여 인터페이스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f17fd1e9e7781f60f577293ffbb0fbe50f2aa38c" translate="yes" xml:space="preserve">
          <source>GCC provides an interface to selected machine instructions from the picoChip instruction set.</source>
          <target state="translated">GCC는 picoChip 명령어 세트에서 선택된 기계 명령어에 대한 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5ddbeccb51a8011bd71cee78329676c8768e012d" translate="yes" xml:space="preserve">
          <source>GCC provides built-in versions of the ISO C99 floating-point comparison macros that avoid raising exceptions for unordered operands. They have the same names as the standard macros ( &lt;code&gt;isgreater&lt;/code&gt;, &lt;code&gt;isgreaterequal&lt;/code&gt;, &lt;code&gt;isless&lt;/code&gt;, &lt;code&gt;islessequal&lt;/code&gt;, &lt;code&gt;islessgreater&lt;/code&gt;, and &lt;code&gt;isunordered&lt;/code&gt;) , with &lt;code&gt;__builtin_&lt;/code&gt; prefixed. We intend for a library implementor to be able to simply &lt;code&gt;#define&lt;/code&gt; each standard macro to its built-in equivalent. In the same fashion, GCC provides &lt;code&gt;fpclassify&lt;/code&gt;, &lt;code&gt;isfinite&lt;/code&gt;, &lt;code&gt;isinf_sign&lt;/code&gt;, &lt;code&gt;isnormal&lt;/code&gt; and &lt;code&gt;signbit&lt;/code&gt; built-ins used with &lt;code&gt;__builtin_&lt;/code&gt; prefixed. The &lt;code&gt;isinf&lt;/code&gt; and &lt;code&gt;isnan&lt;/code&gt; built-in functions appear both with and without the &lt;code&gt;__builtin_&lt;/code&gt; prefix.</source>
          <target state="translated">GCC는 정렬되지 않은 피연산자에 대한 예외를 피하기 위해 ISO C99 부동 소수점 비교 매크로의 기본 제공 버전을 제공합니다. 그들은 표준 매크로 (같은 이름이 &lt;code&gt;isgreater&lt;/code&gt; , &lt;code&gt;isgreaterequal&lt;/code&gt; , &lt;code&gt;isless&lt;/code&gt; , &lt;code&gt;islessequal&lt;/code&gt; , &lt;code&gt;islessgreater&lt;/code&gt; 및 &lt;code&gt;isunordered&lt;/code&gt; 를 함께) &lt;code&gt;__builtin_&lt;/code&gt; 앞에 둔. 우리는 라이브러리 구현자가 각각의 표준 매크로를 내장 된 동등한 것으로 &lt;code&gt;#define&lt;/code&gt; 할 수있게하려고합니다 . 같은 방식으로 GCC는 &lt;code&gt;fpclassify&lt;/code&gt; , &lt;code&gt;isfinite&lt;/code&gt; , &lt;code&gt;isinf_sign&lt;/code&gt; , &lt;code&gt;isnormal&lt;/code&gt; 및 &lt;code&gt;signbit&lt;/code&gt; 를 제공합니다 &lt;code&gt;__builtin_&lt;/code&gt; 접두사가 붙은 내장 기능 . &lt;code&gt;isinf&lt;/code&gt; 및 &lt;code&gt;isnan&lt;/code&gt; 내장 된 기능으로하고,하지 않고 모두 표시 &lt;code&gt;__builtin_&lt;/code&gt; 접두사.</target>
        </trans-unit>
        <trans-unit id="2050dfe83adc5c7628805205b83a18bf6445e1ea" translate="yes" xml:space="preserve">
          <source>GCC provides extensions for the SPU processor as described in the Sony/Toshiba/IBM SPU Language Extensions Specification. GCC&amp;rsquo;s implementation differs in several ways.</source>
          <target state="translated">GCC는 Sony / Toshiba / IBM SPU 언어 확장 사양에 설명 된대로 SPU 프로세서에 대한 확장을 제공합니다. GCC의 구현은 몇 가지면에서 다릅니다.</target>
        </trans-unit>
        <trans-unit id="e32059373d4f323b9500c52b6c9f30c837d92c67" translate="yes" xml:space="preserve">
          <source>GCC provides intrinsics to access certain instructions of the TI C6X processors. These intrinsics, listed below, are available after inclusion of the &lt;code&gt;c6x_intrinsics.h&lt;/code&gt; header file. They map directly to C6X instructions.</source>
          <target state="translated">GCC는 TI C6X 프로세서의 특정 명령에 액세스 할 수있는 내장 기능을 제공합니다. 아래에 나열된 이러한 내장 함수는 &lt;code&gt;c6x_intrinsics.h&lt;/code&gt; 헤더 파일을 포함시킨 후에 사용할 수 있습니다 . C6X 명령어에 직접 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="4b78e24ee2fcd774983a8458d70a096c1f01f9ae" translate="yes" xml:space="preserve">
          <source>GCC provides intrinsics to access every instruction of the TILE-Gx processor. The intrinsics are of the form:</source>
          <target state="translated">GCC는 TILE-Gx 프로세서의 모든 명령에 액세스 할 수있는 내장 기능을 제공합니다. 본질은 다음과 같은 형식입니다.</target>
        </trans-unit>
        <trans-unit id="9929eef1ea9191b05967ff4d40ec8ba33acf1914" translate="yes" xml:space="preserve">
          <source>GCC provides intrinsics to access every instruction of the TILEPro processor. The intrinsics are of the form:</source>
          <target state="translated">GCC는 TILEPro 프로세서의 모든 명령에 액세스 할 수있는 내장 기능을 제공합니다. 본질은 다음과 같은 형식입니다.</target>
        </trans-unit>
        <trans-unit id="ce1f47a40b55c4bca6e7d75e5dd0559de5a981c1" translate="yes" xml:space="preserve">
          <source>GCC provides intrinsics to access the SIMD instructions provided by the MSA MIPS SIMD Architecture. The interface is made available by including &lt;code&gt;&amp;lt;msa.h&amp;gt;&lt;/code&gt; and using</source>
          <target state="translated">GCC는 MSA MIPS SIMD 아키텍처에서 제공하는 SIMD 명령어에 액세스하기위한 내장 함수를 제공합니다. &lt;code&gt;&amp;lt;msa.h&amp;gt;&lt;/code&gt; 를 포함 하고 사용하여 인터페이스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40749dfbc24dc6f5a0b131fccc39dc31c09ec61c" translate="yes" xml:space="preserve">
          <source>GCC provides intrinsics to access the SIMD instructions provided by the ST Microelectronics Loongson-2E and -2F processors. These intrinsics, available after inclusion of the &lt;code&gt;loongson.h&lt;/code&gt; header file, operate on the following 64-bit vector types:</source>
          <target state="translated">GCC는 ST Microelectronics Loongson-2E 및 -2F 프로세서에서 제공하는 SIMD 명령어에 액세스하기위한 내장 함수를 제공합니다. &lt;code&gt;loongson.h&lt;/code&gt; 헤더 파일 을 포함시킨 후 사용 가능한 이러한 내장 함수 는 다음 64 비트 벡터 유형에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="924dd6007d38ce7b6e1d6cc29626f87cdabebfe1" translate="yes" xml:space="preserve">
          <source>GCC provides many FR-V-specific built-in functions. In general, these functions are intended to be compatible with those described by FR-V Family, Softune C/C++ Compiler Manual (V6), Fujitsu Semiconductor. The two exceptions are &lt;code&gt;__MDUNPACKH&lt;/code&gt; and &lt;code&gt;__MBTOHE&lt;/code&gt;, the GCC forms of which pass 128-bit values by pointer rather than by value.</source>
          <target state="translated">GCC는 많은 FR-V 고유의 내장 기능을 제공합니다. 일반적으로 이러한 기능은 FR-V 제품군, Softune C / C ++ 컴파일러 설명서 (V6), Fujitsu Semiconductor에서 설명하는 기능과 호환되도록 설계되었습니다. 두 가지 예외는 &lt;code&gt;__MDUNPACKH&lt;/code&gt; 및 &lt;code&gt;__MBTOHE&lt;/code&gt; 이며 GCC 형식은 값이 아닌 포인터로 128 비트 값을 전달합니다.</target>
        </trans-unit>
        <trans-unit id="9e2fa02f56a7975c68bfa6e70c41727409fe7b0c" translate="yes" xml:space="preserve">
          <source>GCC provides other MIPS-specific built-in functions:</source>
          <target state="translated">GCC는 다른 MIPS 고유의 내장 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c10a95a94bae56390209bcb97b207903625a1bc4" translate="yes" xml:space="preserve">
          <source>GCC provides the built-in functions &lt;code&gt;__builtin_setjmp&lt;/code&gt; and &lt;code&gt;__builtin_longjmp&lt;/code&gt; which are similar to, but not interchangeable with, the C library functions &lt;code&gt;setjmp&lt;/code&gt; and &lt;code&gt;longjmp&lt;/code&gt;. The built-in versions are used internally by GCC&amp;rsquo;s libraries to implement exception handling on some targets. You should use the standard C library functions declared in &lt;code&gt;&amp;lt;setjmp.h&amp;gt;&lt;/code&gt; in user code instead of the builtins.</source>
          <target state="translated">GCC는 내장 함수 &lt;code&gt;__builtin_setjmp&lt;/code&gt; 및 &lt;code&gt;__builtin_longjmp&lt;/code&gt; 를 제공하지만 C 라이브러리 함수 &lt;code&gt;setjmp&lt;/code&gt; 및 &lt;code&gt;longjmp&lt;/code&gt; 와 유사하지만 상호 교환 할 수는 없습니다 . 내장 버전은 GCC 라이브러리에서 내부적으로 사용되어 일부 대상에서 예외 처리를 구현합니다. 내장 코드 대신 사용자 코드 에서 &lt;code&gt;&amp;lt;setjmp.h&amp;gt;&lt;/code&gt; 에 선언 된 표준 C 라이브러리 함수를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9735e9559d39719652bb957e983b7d2a3d2f7126" translate="yes" xml:space="preserve">
          <source>GCC provides three magic constants that hold the name of the current function as a string. In C++11 and later modes, all three are treated as constant expressions and can be used in &lt;code&gt;constexpr&lt;/code&gt; constexts. The first of these constants is &lt;code&gt;__func__&lt;/code&gt;, which is part of the C99 standard:</source>
          <target state="translated">GCC는 현재 함수의 이름을 문자열로 보유하는 세 가지 마법 상수를 제공합니다. C ++ 11 및 이후 모드에서는 세 가지 모두 상수 표현식으로 취급되며 &lt;code&gt;constexpr&lt;/code&gt; constexts 에서 사용할 수 있습니다 . 이 상수 중 첫 번째는 &lt;code&gt;__func__&lt;/code&gt; 이며 C99 표준의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="2948277f494886df96fe31449754e2666c1dabe5" translate="yes" xml:space="preserve">
          <source>GCC provides two interfaces for accessing the Hardware Transactional Memory (HTM) instructions available on some of the PowerPC family of processors (eg, POWER8). The two interfaces come in a low level interface, consisting of built-in functions specific to PowerPC and a higher level interface consisting of inline functions that are common between PowerPC and S/390.</source>
          <target state="translated">GCC는 일부 PowerPC 프로세서 제품군 (예 : POWER8)에서 사용 가능한 HTM (Hardware Transactional Memory) 명령어에 액세스하기위한 두 가지 인터페이스를 제공합니다. 이 두 인터페이스는 PowerPC 고유의 내장 기능과 PowerPC와 S / 390간에 공통적 인 인라인 기능으로 구성된 고급 인터페이스로 구성된 저수준 인터페이스로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="0504373821c4265dbbe47258f3675e81d3bda382" translate="yes" xml:space="preserve">
          <source>GCC searches for the &amp;lsquo;</source>
          <target state="translated">GCC는 '</target>
        </trans-unit>
        <trans-unit id="f29e392d59a7180cc6e4238e88b7157ffcf6417f" translate="yes" xml:space="preserve">
          <source>GCC stands for &amp;ldquo;GNU Compiler Collection&amp;rdquo;. GCC is an integrated distribution of compilers for several major programming languages. These languages currently include C, C++, Objective-C, Objective-C++, Fortran, Ada, D, Go, and BRIG (HSAIL).</source>
          <target state="translated">GCC는 &quot;GNU Compiler Collection&quot;의 약자입니다. GCC는 여러 주요 프로그래밍 언어를위한 통합 컴파일러 배포판입니다. 이러한 언어에는 현재 C, C ++, Objective-C, Objective-C ++, Fortran, Ada, D, Go 및 BRIG (HSAIL)가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="1d5a85fa7b27fa126424357ffe5ddd8aadcd2aa6" translate="yes" xml:space="preserve">
          <source>GCC support of decimal float as specified by the draft technical report is incomplete:</source>
          <target state="translated">기술 보고서 ​​초안에 지정된 10 진수 부동 소수점에 대한 GCC 지원이 불완전합니다.</target>
        </trans-unit>
        <trans-unit id="28561e4b3e7debdbfb6dbdfe238413f5b85b54ce" translate="yes" xml:space="preserve">
          <source>GCC support of fixed-point types as specified by the draft technical report is incomplete:</source>
          <target state="translated">기술 보고서 ​​초안에 지정된 고정 소수점 유형에 대한 GCC 지원이 불완전합니다.</target>
        </trans-unit>
        <trans-unit id="1fa5de60932a0f2deade437763dee9d9034d0c2f" translate="yes" xml:space="preserve">
          <source>GCC supports &amp;ldquo;traditional&amp;rdquo; Objective-C (also known as &amp;ldquo;Objective-C 1.0&amp;rdquo;) and contains support for the Objective-C exception and synchronization syntax. It has also support for a number of &amp;ldquo;Objective-C 2.0&amp;rdquo; language extensions, including properties, fast enumeration (only for Objective-C), method attributes and the @optional and @required keywords in protocols. GCC supports Objective-C++ and features available in Objective-C are also available in Objective-C++.</source>
          <target state="translated">GCC는 &quot;전통적인&quot;Objective-C ( &quot;Objective-C 1.0&quot;이라고도 함)를 지원하고 Objective-C 예외 및 동기화 구문을 지원합니다. 또한 속성, 빠른 열거 (Objective-C에만 해당), 메서드 속성 및 프로토콜의 @optional 및 @required 키워드를 포함하여 여러 &quot;Objective-C 2.0&quot;언어 확장을 지원합니다. GCC는 Objective-C ++를 지원하며 Objective-C에서 사용 가능한 기능은 Objective-C ++에서도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="830690076ebfb70e332b381ddb9fe46655004637" translate="yes" xml:space="preserve">
          <source>GCC supports MIPS DSP operations using both the generic vector extensions (see &lt;a href=&quot;vector-extensions#Vector-Extensions&quot;&gt;Vector Extensions&lt;/a&gt;) and a collection of MIPS-specific built-in functions. Both kinds of support are enabled by the</source>
          <target state="translated">GCC는 모두 일반 벡터 확장을 사용하여 MIPS DSP 작업을 지원합니다 ( &lt;a href=&quot;vector-extensions#Vector-Extensions&quot;&gt;벡터 확장&lt;/a&gt; ) 및 내장 함수 MIPS 고유의 컬렉션입니다. 두 종류의 지원은</target>
        </trans-unit>
        <trans-unit id="8d83e55eff0bd290fe83057edfb4aff0d4da11fc" translate="yes" xml:space="preserve">
          <source>GCC supports SIMD operations on the SPARC using both the generic vector extensions (see &lt;a href=&quot;vector-extensions#Vector-Extensions&quot;&gt;Vector Extensions&lt;/a&gt;) as well as built-in functions for the SPARC Visual Instruction Set (VIS). When you use the</source>
          <target state="translated">GCC는 (참조 모두 일반 벡터 확장을 사용하여 SPARC에 SIMD 연산을 지원하는 &lt;a href=&quot;vector-extensions#Vector-Extensions&quot;&gt;벡터 확장&lt;/a&gt; )뿐만 아니라 내장 함수는 SPARC 비쥬얼 명령에 대한 세트 (VIS) 등을. 사용할 때</target>
        </trans-unit>
        <trans-unit id="76e5e7f27add586f752fd2c88bf216b480271ed7" translate="yes" xml:space="preserve">
          <source>GCC supports a &lt;code&gt;#pragma&lt;/code&gt; directive that changes the name used in assembly for a given declaration. While this pragma is supported on all platforms, it is intended primarily to provide compatibility with the Solaris system headers. This effect can also be achieved using the asm labels extension (see &lt;a href=&quot;asm-labels#Asm-Labels&quot;&gt;Asm Labels&lt;/a&gt;).</source>
          <target state="translated">GCC는 주어진 선언에 대해 어셈블리에 사용되는 이름을 변경 하는 &lt;code&gt;#pragma&lt;/code&gt; 지시문을 지원합니다 . 이 pragma는 모든 플랫폼에서 지원되지만 주로 Solaris 시스템 헤더와의 호환성을 제공하기위한 것입니다. 이 효과는 asm labels 확장을 사용하여 얻을 수도 있습니다 ( &lt;a href=&quot;asm-labels#Asm-Labels&quot;&gt;Asm Labels&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="498314540c8d67676764e9f766eda8fd96a7daed" translate="yes" xml:space="preserve">
          <source>GCC supports a number of command-line options that control adding run-time instrumentation to the code it normally generates. For example, one purpose of instrumentation is collect profiling statistics for use in finding program hot spots, code coverage analysis, or profile-guided optimizations. Another class of program instrumentation is adding run-time checking to detect programming errors like invalid pointer dereferences or out-of-bounds array accesses, as well as deliberately hostile attacks such as stack smashing or C++ vtable hijacking. There is also a general hook which can be used to implement other forms of tracing or function-level instrumentation for debug or program analysis purposes.</source>
          <target state="translated">GCC는 일반적으로 생성되는 코드에 런타임 계측 추가를 제어하는 ​​여러 명령 줄 옵션을 지원합니다. 예를 들어, 계측의 한 가지 목적은 프로그램 핫스팟, 코드 범위 분석 또는 프로파일 가이드 최적화를 찾는 데 사용하기위한 프로파일 링 통계를 수집하는 것입니다. 또 다른 클래스의 프로그램 계측은 런타임 검사를 추가하여 유효하지 않은 포인터 역 참조 또는 범위를 벗어난 어레이 액세스와 같은 프로그래밍 오류를 탐지하고 스택 스매싱 또는 C ++ vtable 하이재킹과 같은 의도적으로 적대적인 공격을 감지합니다. 디버그 또는 프로그램 분석 목적으로 다른 형태의 추적 또는 함수 레벨 계측을 구현하는 데 사용할 수있는 일반 후크도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1030e6dea2c81b69bdc7270b03b39b5f569ad6fa" translate="yes" xml:space="preserve">
          <source>GCC supports a variant of the o32 ABI in which floating-point registers are 64 rather than 32 bits wide. You can select this combination with</source>
          <target state="translated">GCC는 부동 소수점 레지스터의 너비가 32 비트가 아닌 64 인 o32 ABI의 변형을 지원합니다. 이 조합을 선택할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="c3965449e7a5dc4d5ed8a9dc3199dec909c35dc5" translate="yes" xml:space="preserve">
          <source>GCC supports only two&amp;rsquo;s complement integer types, and all bit patterns are ordinary values.</source>
          <target state="translated">GCC는 2의 보수 정수 유형 만 지원하며 모든 비트 패턴은 일반 값입니다.</target>
        </trans-unit>
        <trans-unit id="83dd0c21621e0a6e0dd523c863cbfaef04449bd4" translate="yes" xml:space="preserve">
          <source>GCC supports paired-single operations using both the generic vector extensions (see &lt;a href=&quot;vector-extensions#Vector-Extensions&quot;&gt;Vector Extensions&lt;/a&gt;) and a collection of MIPS-specific built-in functions. Both kinds of support are enabled by the</source>
          <target state="translated">GCC 지원은 쌍 단일 일반 벡터 확장 (참조 모두 사용하여 작업 &lt;a href=&quot;vector-extensions#Vector-Extensions&quot;&gt;벡터 확장&lt;/a&gt; ) 및 내장 함수 MIPS 고유의 컬렉션을. 두 종류의 지원은</target>
        </trans-unit>
        <trans-unit id="b55fc398fe2655fec7265522ba909be632a50b88" translate="yes" xml:space="preserve">
          <source>GCC supports several types of pragmas, primarily in order to compile code originally written for other compilers. Note that in general we do not recommend the use of pragmas; See &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;, for further explanation.</source>
          <target state="translated">GCC는 주로 다른 컴파일러 용으로 작성된 코드를 컴파일하기 위해 여러 유형의 pragma를 지원합니다. 일반적으로 pragma를 사용하지 않는 것이 좋습니다. 자세한 설명 은 &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;기능 속성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="653525fcb8a016916ca28e1dd65b18ab8839e4b5" translate="yes" xml:space="preserve">
          <source>GCC supports some of the RX instructions which cannot be expressed in the C programming language via the use of built-in functions. The following functions are supported:</source>
          <target state="translated">GCC는 내장 함수를 사용하여 C 프로그래밍 언어로 표현할 수없는 일부 RX 명령어를 지원합니다. 다음과 같은 기능이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="4b0cba78b946248aec959caf8a965144462518ce" translate="yes" xml:space="preserve">
          <source>GCC supports the D 2.0 programming language. The D language itself is currently defined by its reference implementation and supporting language specification, described at &lt;a href=&quot;https://dlang.org/spec/spec.html&quot;&gt;https://dlang.org/spec/spec.html&lt;/a&gt;.</source>
          <target state="translated">GCC는 D 2.0 프로그래밍 언어를 지원합니다. D 언어 자체는 현재 &lt;a href=&quot;https://dlang.org/spec/spec.html&quot;&gt;https://dlang.org/spec/spec.html에&lt;/a&gt; 설명 된 참조 구현 및 지원 언어 사양으로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="359d53772696a2b7864fe27fe3565593d8a4b28c" translate="yes" xml:space="preserve">
          <source>GCC supports the following AVR devices and ISAs:</source>
          <target state="translated">GCC는 다음과 같은 AVR 장치 및 ISA를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="2ea7c76cda0c4fbb899bd829aa15b4c8a69297f6" translate="yes" xml:space="preserve">
          <source>GCC supports the original ISO C++ standard published in 1998, and the 2011 and 2014 revisions.</source>
          <target state="translated">GCC는 1998 년에 발표 된 원본 ISO C ++ 표준과 2011 및 2014 개정을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="858a69c7492112ce45741ecc79e61821fd61a803" translate="yes" xml:space="preserve">
          <source>GCC supports these options when compiling for C-SKY V2 processors.</source>
          <target state="translated">GCC는 C-SKY V2 프로세서를 컴파일 할 때 이러한 옵션을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="0dc67ad6d4b46256a65720385ae1177b91b75554" translate="yes" xml:space="preserve">
          <source>GCC supports two forms of SVE code generation: &amp;ldquo;vector-length agnostic&amp;rdquo; output that works with any size of vector register and &amp;ldquo;vector-length specific&amp;rdquo; output that allows GCC to make assumptions about the vector length when it is useful for optimization reasons. The possible values of &amp;lsquo;</source>
          <target state="translated">GCC는 두 가지 형태의 SVE 코드 생성을 지원합니다. 모든 크기의 벡터 레지스터와 함께 작동하는 &quot;벡터 길이에 구애받지 않는&quot;출력과 GCC가 최적화 이유로 유용 할 때 벡터 길이에 대해 가정 할 수있는 &quot;벡터 길이에 따른&quot;출력. '의 가능한 값</target>
        </trans-unit>
        <trans-unit id="5b3ded850043ac176423c8bd10dd3fbbab6dc5cd" translate="yes" xml:space="preserve">
          <source>GCC treats all characters of identifiers as significant. According to K&amp;amp;R-1 (2.2), &amp;ldquo;No more than the first eight characters are significant, although more may be used.&amp;rdquo;. Also according to K&amp;amp;R-1 (2.2), &amp;ldquo;An identifier is a sequence of letters and digits; the first character must be a letter. The underscore _ counts as a letter.&amp;rdquo;, but GCC also allows dollar signs in identifiers.</source>
          <target state="translated">GCC는 식별자의 모든 문자를 중요하게 취급합니다. K &amp;amp; R-1 (2.2)에 따르면,&amp;ldquo;처음 8자를 초과하면 더 많을 수 있지만 중요하지 않습니다.&amp;rdquo;. 또한 K &amp;amp; R-1 (2.2)에 따르면&amp;ldquo;식별자는 문자와 숫자의 순서입니다. 첫 번째 문자는 문자 여야합니다. 밑줄 _은 문자로 계산됩니다.&amp;rdquo;그러나 GCC는 식별자에 달러 기호도 허용합니다.</target>
        </trans-unit>
        <trans-unit id="feaee8cb866302ba1b5ec59a1ce37d673602a1f3" translate="yes" xml:space="preserve">
          <source>GCC uses &lt;var&gt;name&lt;/var&gt; to determine what kind of instructions it can emit when generating assembly code (as if by</source>
          <target state="translated">GCC는 &lt;var&gt;name&lt;/var&gt; 을 사용 하여 어셈블리 코드를 생성 할 때 어떤 종류의 명령어를 생성 할 수 있는지 결정합니다 (</target>
        </trans-unit>
        <trans-unit id="66e1ddf3758925ad2362fd6f220c229932999055" translate="yes" xml:space="preserve">
          <source>GCC uses &lt;var&gt;name&lt;/var&gt; to determine what kind of instructions it can emit when generating assembly code. If</source>
          <target state="translated">GCC는 &lt;var&gt;name&lt;/var&gt; 을 사용 하여 어셈블리 코드를 생성 할 때 어떤 종류의 명령어를 생성 할 수 있는지 결정합니다. 만약</target>
        </trans-unit>
        <trans-unit id="813ae2789d4b6769128e82ee496ab87522d87f2b" translate="yes" xml:space="preserve">
          <source>GCC uses a garbage collector to manage its own memory allocation. This parameter specifies the minimum percentage by which the garbage collector&amp;rsquo;s heap should be allowed to expand between collections. Tuning this may improve compilation speed; it has no effect on code generation.</source>
          <target state="translated">GCC는 가비지 수집기를 사용하여 자체 메모리 할당을 관리합니다. 이 매개 변수는 가비지 콜렉터의 힙이 콜렉션간에 확장 될 수있는 최소 백분율을 지정합니다. 이를 조정하면 컴파일 속도가 향상 될 수 있습니다. 코드 생성에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ae9ac11b129e57b155bc25157be869b1b76e80ad" translate="yes" xml:space="preserve">
          <source>GCC uses corrected versions of system header files. This is necessary, but doesn&amp;rsquo;t always work smoothly.</source>
          <target state="translated">GCC는 수정 된 버전의 시스템 헤더 파일을 사용합니다. 이것은 필요하지만 항상 원활하게 작동하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="819a72ed7eaf70f991d756c9fa760994a62ab526" translate="yes" xml:space="preserve">
          <source>GCC uses heuristics to guess branch probabilities if they are not provided by profiling feedback (</source>
          <target state="translated">GCC는 휴리스틱을 사용하여 프로파일 링 피드백으로 제공되지 않는 분기 확률을 추측합니다 (</target>
        </trans-unit>
        <trans-unit id="1a8376e3c4e7645e0b124141064b06d15d9df6a1" translate="yes" xml:space="preserve">
          <source>GCC uses the system C library, which might not be compliant with the ISO C standard.</source>
          <target state="translated">GCC는 ISO C 표준을 준수하지 않을 수있는 시스템 C 라이브러리를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ca6cd448f1a33799ac2da1a0d9dfa000cd6841ec" translate="yes" xml:space="preserve">
          <source>GCC will not inline any functions if the</source>
          <target state="translated">GCC는</target>
        </trans-unit>
        <trans-unit id="8a47996357771546a1d05e5991be4fe03520b6e5" translate="yes" xml:space="preserve">
          <source>GCC&amp;rsquo;s default behavior is to emit all inline functions with the &lt;code&gt;dllexport&lt;/code&gt; attribute. Since this can cause object file-size bloat, you can use</source>
          <target state="translated">GCC의 기본 동작은 &lt;code&gt;dllexport&lt;/code&gt; 속성을 사용하여 모든 인라인 함수를 내보내는 것 입니다. 이로 인해 파일 크기가 부풀려 질 수 있으므로</target>
        </trans-unit>
        <trans-unit id="af8e45be98e36024842dc1bd8893718108d0574b" translate="yes" xml:space="preserve">
          <source>GCC&amp;rsquo;s implementation of the high-level language interface available from C and C++ code differs from Motorola&amp;rsquo;s documentation in several ways.</source>
          <target state="translated">C 및 C ++ 코드에서 사용 가능한 고급 언어 인터페이스의 GCC 구현은 몇 가지면에서 Motorola의 설명서와 다릅니다.</target>
        </trans-unit>
        <trans-unit id="e78ca1e1182b55c5bde4b195b5d85015058a98d0" translate="yes" xml:space="preserve">
          <source>GCC&amp;rsquo;s optimizers do not treat this code like the non-volatile code in the earlier examples. They do not move it out of loops or omit it on the assumption that the result from a previous call is still valid.</source>
          <target state="translated">GCC의 옵티마이 저는이 코드를 이전 예제의 비 휘발성 코드처럼 취급하지 않습니다. 이전 호출의 결과가 여전히 유효하다는 가정하에 루프 밖으로 이동하거나 생략하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dbc61f28ee0b681eff97897cb82a2c8d282dc076" translate="yes" xml:space="preserve">
          <source>GCC&amp;rsquo;s optimizers sometimes discard &lt;code&gt;asm&lt;/code&gt; statements if they determine there is no need for the output variables. Also, the optimizers may move code out of loops if they believe that the code will always return the same result (i.e. none of its input values change between calls). Using the &lt;code&gt;volatile&lt;/code&gt; qualifier disables these optimizations. &lt;code&gt;asm&lt;/code&gt; statements that have no output operands, including &lt;code&gt;asm goto&lt;/code&gt; statements, are implicitly volatile.</source>
          <target state="translated">GCC의 옵티마이 저는 때때로 출력 변수가 필요하지 않다고 판단하면 &lt;code&gt;asm&lt;/code&gt; 문을 삭제 합니다. 또한 옵티마이 저는 코드가 항상 동일한 결과를 리턴한다고 생각하는 경우 (즉, 호출간에 입력 값이 변경되지 않음) 코드를 루프 밖으로 이동할 수 있습니다. 은 Using &lt;code&gt;volatile&lt;/code&gt; 규정하는 것은 이러한 최적화를 사용하지 않습니다. &lt;code&gt;asm&lt;/code&gt; &lt;code&gt;asm goto&lt;/code&gt; 문을 포함하여 출력 피연산자가없는 asm 문 은 암시 적으로 일시적입니다.</target>
        </trans-unit>
        <trans-unit id="1e750d3c829a6b818589899b42ede982312a7f98" translate="yes" xml:space="preserve">
          <source>GCOV_ERROR_FILE</source>
          <target state="translated">GCOV_ERROR_FILE</target>
        </trans-unit>
        <trans-unit id="e485aa772b73ea7b58dcf4966c0a2d3b9c745805" translate="yes" xml:space="preserve">
          <source>GCOV_EXIT_AT_ERROR</source>
          <target state="translated">GCOV_EXIT_AT_ERROR</target>
        </trans-unit>
        <trans-unit id="80aecc9b56754f32438dd132183cddc7e4df32f1" translate="yes" xml:space="preserve">
          <source>GCOV_PREFIX contains the prefix to add to the absolute paths in the object file. Prefix can be absolute, or relative. The default is no prefix.</source>
          <target state="translated">GCOV_PREFIX에는 객체 파일의 절대 경로에 추가 할 접두사가 포함되어 있습니다. 접두사는 절대적이거나 상대적 일 수 있습니다. 기본값은 접두사가 없습니다.</target>
        </trans-unit>
        <trans-unit id="891aee4538b1a332bb00b85c9e7c43d1cf40d1d1" translate="yes" xml:space="preserve">
          <source>GCOV_PREFIX=/target/run</source>
          <target state="translated">GCOV_PREFIX=/target/run</target>
        </trans-unit>
        <trans-unit id="f0bcf8de4466a3194e31ce81577ad85f4f449ccb" translate="yes" xml:space="preserve">
          <source>GCOV_PREFIX_STRIP indicates the how many initial directory names to strip off the hardwired absolute paths. Default value is 0.</source>
          <target state="translated">GCOV_PREFIX_STRIP는 고정 배선 된 절대 경로를 제거 할 초기 디렉토리 이름 수를 나타냅니다. 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="7069713a73584b12e5e1b6c6673abb78172fe103" translate="yes" xml:space="preserve">
          <source>GCOV_PREFIX_STRIP=1</source>
          <target state="translated">GCOV_PREFIX_STRIP=1</target>
        </trans-unit>
        <trans-unit id="a007084938316d2847460b0f869fd2dab151324f" translate="yes" xml:space="preserve">
          <source>GFNI instructions.</source>
          <target state="translated">GFNI 지침.</target>
        </trans-unit>
        <trans-unit id="768001d59e5da45e8ce2de4652950a5db0123cf5" translate="yes" xml:space="preserve">
          <source>GNU C allows you to associate specific hardware registers with C variables. In almost all cases, allowing the compiler to assign registers produces the best code. However under certain unusual circumstances, more precise control over the variable storage is required.</source>
          <target state="translated">GNU C를 사용하면 특정 하드웨어 레지스터를 C 변수와 연결할 수 있습니다. 거의 모든 경우에 컴파일러가 레지스터를 할당하도록 허용하면 최상의 코드가 생성됩니다. 그러나 특별한 상황에서는 가변 스토리지에 대한보다 정확한 제어가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="1282a7948680a82fce143391cee57deb8d315356" translate="yes" xml:space="preserve">
          <source>GNU C extends ISO C to allow a function prototype to override a later old-style non-prototype definition. Consider the following example:</source>
          <target state="translated">GNU C는 ISO C를 확장하여 함수 프로토 타입이 나중의 구식 비 프로토 타입 정의를 재정의 할 수 있도록합니다. 다음 예제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="e77e07d95404402b67fc9bef0aec0c9a34ecc38f" translate="yes" xml:space="preserve">
          <source>GNU C provides several language features not found in ISO standard C. (The</source>
          <target state="translated">GNU C는 ISO 표준 C에는없는 몇 가지 언어 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d45fbb49066a76f230e9020bfe458e74293358d2" translate="yes" xml:space="preserve">
          <source>GNU C++ does not support old-style function definitions, so this extension is irrelevant.</source>
          <target state="translated">GNU C ++는 구식 함수 정의를 지원하지 않으므로이 확장은 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="2ba257a10dfda1a80f343df43a5f9faccbca64b3" translate="yes" xml:space="preserve">
          <source>GNU CPP has two further variadic macro extensions, and permits them to be used with either of the above forms of macro definition.</source>
          <target state="translated">GNU CPP에는 두 가지 가변 가변 매크로 확장이 있으며 위의 매크로 정의 형식 중 하나와 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9dbaa828d6809d3452cb2a6728f3023aae5a8b22" translate="yes" xml:space="preserve">
          <source>GNU CPP permits you to completely omit the variable arguments in this way. In the above examples, the compiler would complain, though since the expansion of the macro still has the extra comma after the format string.</source>
          <target state="translated">GNU CPP에서는 이런 식으로 변수 인수를 완전히 생략 할 수 있습니다. 위의 예에서 매크로의 확장은 여전히 ​​형식 문자열 뒤에 추가 쉼표가 있기 때문에 컴파일러가 불평합니다.</target>
        </trans-unit>
        <trans-unit id="0e4ec8a54cfff9c2845fa38842cb6cd1bdea197d" translate="yes" xml:space="preserve">
          <source>GNU Free Documentation License</source>
          <target state="translated">GNU 자유 문서 라이센스</target>
        </trans-unit>
        <trans-unit id="d9cbf0740e34d88c506fb7df6e17deeabd18660c" translate="yes" xml:space="preserve">
          <source>GNU General Public License</source>
          <target state="translated">GNU 일반 공중 사용 허가서</target>
        </trans-unit>
        <trans-unit id="ea5447d52819458fc788d8fe66484dcf6f8b58c5" translate="yes" xml:space="preserve">
          <source>GNU General Public License says how you can copy and share GCC.</source>
          <target state="translated">GNU General Public License는 GCC를 복사하고 공유하는 방법을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="a21d2651a31b14abba6b9f4cc89e6d16156a2f47" translate="yes" xml:space="preserve">
          <source>GNU Objective-C provides constant string objects that are generated directly by the compiler. You declare a constant string object by prefixing a C constant string with the character &amp;lsquo;</source>
          <target state="translated">GNU Objective-C는 컴파일러가 직접 생성 한 상수 문자열 객체를 제공합니다. C 상수 문자열 앞에 ''문자를 붙여 상수 문자열 객체를 선언합니다.</target>
        </trans-unit>
        <trans-unit id="d4b0f24c5578d309a3a80bcf9db1efef7dc80491" translate="yes" xml:space="preserve">
          <source>GNU Objective-C provides exception support built into the language, as in the following example:</source>
          <target state="translated">GNU Objective-C는 다음 예제와 같이 언어에 내장 된 예외 지원을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="183b8b6fa7f0ebe7cc24b6e6b64ea37e46538bc2" translate="yes" xml:space="preserve">
          <source>GNU Objective-C provides support for synchronized blocks:</source>
          <target state="translated">GNU Objective-C는 동기화 된 블록을 지원합니다 :</target>
        </trans-unit>
        <trans-unit id="5a76f04c435b8a53e2673208f47df13d27337155" translate="yes" xml:space="preserve">
          <source>GNU Objective-C provides support for the fast enumeration syntax:</source>
          <target state="translated">GNU Objective-C는 빠른 열거 구문을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="bd8453bc7fd0b5c5a5eb0b2fb1cc7653d6106ce4" translate="yes" xml:space="preserve">
          <source>GNU Objective-C runtime features.</source>
          <target state="translated">GNU Objective-C 런타임 기능.</target>
        </trans-unit>
        <trans-unit id="dc4139cbd1ca2e4ec1fdbaf154a309856bbea2a6" translate="yes" xml:space="preserve">
          <source>GNU Objective-C supports the &lt;code&gt;@encode&lt;/code&gt; syntax that allows you to create a type encoding from a C/Objective-C type. For example, &lt;code&gt;@encode(int)&lt;/code&gt; is compiled by the compiler into &lt;code&gt;&quot;i&quot;&lt;/code&gt;.</source>
          <target state="translated">GNU Objective-C는 C / Objective-C 형식에서 형식 인코딩을 만들 수 있는 &lt;code&gt;@encode&lt;/code&gt; 구문을 지원합니다 . 예를 들어, &lt;code&gt;@encode(int)&lt;/code&gt; 는 컴파일러에서 &lt;code&gt;&quot;i&quot;&lt;/code&gt; 로 컴파일됩니다 .</target>
        </trans-unit>
        <trans-unit id="72bdab580bf81d58abe49ef7feb3d22b198aca72" translate="yes" xml:space="preserve">
          <source>GNU dialect of</source>
          <target state="translated">GNU 방언</target>
        </trans-unit>
        <trans-unit id="0cce44d2e046653755b9171f853b5aa7f7510c0f" translate="yes" xml:space="preserve">
          <source>GNU dialect of ISO C11. The name &amp;lsquo;</source>
          <target state="translated">ISO C11의 GNU 방언. 이름 '</target>
        </trans-unit>
        <trans-unit id="17c597be9d56a306b84e8b735a051e0b49bf682b" translate="yes" xml:space="preserve">
          <source>GNU dialect of ISO C17. This is the default for C code.</source>
          <target state="translated">ISO C17의 GNU 방언. 이것이 C 코드의 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="cd7ba84a6cf37a43cdd1bd215e060138c20d80ef" translate="yes" xml:space="preserve">
          <source>GNU dialect of ISO C90 (including some C99 features).</source>
          <target state="translated">ISO C90의 GNU 방언 (일부 C99 기능 포함).</target>
        </trans-unit>
        <trans-unit id="5a96bf0e0eb1648d92a5415bbf82f314f50fc95d" translate="yes" xml:space="preserve">
          <source>GNU dialect of ISO C99. The name &amp;lsquo;</source>
          <target state="translated">ISO C99의 GNU 방언 이름 '</target>
        </trans-unit>
        <trans-unit id="c7513a88e6766734c8fff0b65e9260cb06e07819" translate="yes" xml:space="preserve">
          <source>GNU extensions to the C language family.</source>
          <target state="translated">C 언어 제품군에 대한 GNU 확장.</target>
        </trans-unit>
        <trans-unit id="90b8cbfe3e7aa922a28ad77fd2468b165d25db6d" translate="yes" xml:space="preserve">
          <source>GNU extensions to the C++ language.</source>
          <target state="translated">C ++ 언어에 대한 GNU 확장.</target>
        </trans-unit>
        <trans-unit id="73a49c549f68005dbe48c29ca2788c5808080012" translate="yes" xml:space="preserve">
          <source>General purpose register if 64-bit instructions are enabled or NO_REGS.</source>
          <target state="translated">64 비트 명령어가 활성화 된 경우 범용 레지스터 또는 NO_REGS</target>
        </trans-unit>
        <trans-unit id="005c5bd36bc2dae00112330a475935d63f7703b1" translate="yes" xml:space="preserve">
          <source>General register 1</source>
          <target state="translated">일반 레지스터 1</target>
        </trans-unit>
        <trans-unit id="b09ef9c6988403ff1cf426fea1c658c5b1f6be6e" translate="yes" xml:space="preserve">
          <source>General register &lt;code&gt;r0&lt;/code&gt; to &lt;code&gt;r3&lt;/code&gt; for &lt;code&gt;addl&lt;/code&gt; instruction</source>
          <target state="translated">&lt;code&gt;addl&lt;/code&gt; 명령어를 위한 일반 레지스터 &lt;code&gt;r0&lt;/code&gt; ~ &lt;code&gt;r3&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e89cc1c76441abdf1cb24c29330f5f35d304a8e7" translate="yes" xml:space="preserve">
          <source>General register, but not &lt;code&gt;r29&lt;/code&gt;, &lt;code&gt;r30&lt;/code&gt; and &lt;code&gt;r31&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;r29&lt;/code&gt; , &lt;code&gt;r30&lt;/code&gt; 및 &lt;code&gt;r31&lt;/code&gt; 이 아닌 일반 레지스터</target>
        </trans-unit>
        <trans-unit id="10bd548f00f5df8e11316ab27529f8ec0d489ead" translate="yes" xml:space="preserve">
          <source>General-purpose 32-bit register</source>
          <target state="translated">범용 32 비트 레지스터</target>
        </trans-unit>
        <trans-unit id="d86490a439329533a7fda073910d458d177b7499" translate="yes" xml:space="preserve">
          <source>Generally there is no guarantee that a memory transaction ever succeeds and suitable fallback code always needs to be supplied.</source>
          <target state="translated">일반적으로 메모리 트랜잭션이 성공한다고 보장 할 수 없으며 항상 적절한 대체 코드를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="c220eb05478a76fade659e7f472b8e896908bfb7" translate="yes" xml:space="preserve">
          <source>Generally, functions are not inlined unless optimization is specified. For functions declared inline, this attribute inlines the function independent of any restrictions that otherwise apply to inlining. Failure to inline such a function is diagnosed as an error. Note that if such a function is called indirectly the compiler may or may not inline it depending on optimization level and a failure to inline an indirect call may or may not be diagnosed.</source>
          <target state="translated">일반적으로 최적화가 지정되지 않으면 함수가 인라인되지 않습니다. 인라인으로 선언 된 함수의 경우이 속성은 인라인에 적용되는 제한과 상관없이 함수를 인라인합니다. 이러한 기능을 인라인하지 않으면 오류로 진단됩니다. 이러한 함수가 간접적으로 호출되면 컴파일러는 최적화 수준에 따라 함수를 인라인하거나 인라인하지 않을 수 있으며 간접 호출을 인라인하지 못하면 진단되거나 진단되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84a7c319c3d7d28e18ecbf416836eecf761297c6" translate="yes" xml:space="preserve">
          <source>Generally, inlining into a function is limited. For a function marked with this attribute, every call inside this function is inlined, if possible. Functions declared with attribute &lt;code&gt;noinline&lt;/code&gt; and similar are not inlined. Whether the function itself is considered for inlining depends on its size and the current inlining parameters.</source>
          <target state="translated">일반적으로 함수에 인라인하는 것은 제한됩니다. 이 속성으로 표시된 함수의 경우이 함수 내부의 모든 호출은 가능하면 인라인됩니다. &lt;code&gt;noinline&lt;/code&gt; 속성 과 비슷한 속성으로 선언 된 함수는 인라인되지 않습니다. 함수 자체가 인라인에 고려되는지 여부는 크기와 현재 인라인 매개 변수에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="da79890df831b8b599903d6736d5d918432eda2d" translate="yes" xml:space="preserve">
          <source>Generally, options specified at link time override those specified at compile time, although in some cases GCC attempts to infer link-time options from the settings used to compile the input files.</source>
          <target state="translated">일반적으로 링크 타임에 지정된 옵션은 컴파일 타임에 지정된 옵션보다 우선하지만 GCC는 입력 파일을 컴파일하는 데 사용 된 설정에서 링크 타임 옵션을 유추하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="ba4adeb327e032d99cfca5b51d0fd4daaa9b56fc" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) ColdFire hardware divide and remainder instructions. If</source>
          <target state="translated">ColdFire 하드웨어 나누기 및 나머지 명령어를 생성 (생성하지 않음)합니다. 만약</target>
        </trans-unit>
        <trans-unit id="0fe80a59bc1a906ccb8af3fc3416cadc3264624c" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) GP-relative accesses. The following &lt;var&gt;option&lt;/var&gt; names are recognized:</source>
          <target state="translated">GP 기준 액세스를 생성 (생성하지 않음)합니다. 다음과 같은 &lt;var&gt;option&lt;/var&gt; 이름이 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="09abd950717c564f7150fc3aedac403b36224304" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) MIPS16 code. If GCC is targeting a MIPS32 or MIPS64 architecture, it makes use of the MIPS16e ASE.</source>
          <target state="translated">MIPS16 코드를 생성 (생성하지 않음)하십시오. GCC가 MIPS32 또는 MIPS64 아키텍처를 대상으로하는 경우 MIPS16e ASE를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7322f1cb41e6457edd178c659eebf99bfcbafd3c" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) addressing modes using prefixed load and store instructions when the option</source>
          <target state="translated">옵션이있을 때 접두사가 붙은로드 및 저장 명령을 사용하여 주소 지정 모드를 생성 (생성하지 않음)합니다.</target>
        </trans-unit>
        <trans-unit id="188ec1e266203e4853a13748340fc36d3e35234e" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) code that is fully position-independent, and that can therefore be linked into shared libraries. This option only affects</source>
          <target state="translated">위치에 독립적이며 공유 라이브러리에 링크 될 수있는 코드를 생성 (생성하지 않음)하십시오. 이 옵션은 다음에 만 영향을줍니다</target>
        </trans-unit>
        <trans-unit id="0a056a294949b854726ab099acb14488ae9baeac" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) code that is suitable for SVR4-style dynamic objects.</source>
          <target state="translated">SVR4 스타일 동적 객체에 적합한 코드를 생성 (생성하지 않음)합니다.</target>
        </trans-unit>
        <trans-unit id="200f92cbd3d74fb5f3e648ecaaea7b69d566f040" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) code that uses &lt;em&gt;base addresses&lt;/em&gt;. Using a base address automatically generates a request (handled by the assembler and the linker) for a constant to be set up in a global register. The register is used for one or more base address requests within the range 0 to 255 from the value held in the register. The generally leads to short and fast code, but the number of different data items that can be addressed is limited. This means that a program that uses lots of static data may require</source>
          <target state="translated">&lt;em&gt;기본 주소&lt;/em&gt; 를 사용하는 코드를 생성 (생성하지 않음)하십시오 . 기본 주소를 사용하면 전역 레지스터에 상수를 설정하기위한 요청 (어셈블러 및 링커에서 처리)이 자동으로 생성됩니다. 레지스터는 레지스터에 보유 된 값에서 0에서 255 사이의 하나 이상의 기본 주소 요청에 사용됩니다. 일반적으로 코드가 짧고 빠르지 만 처리 할 수있는 다양한 데이터 항목의 수가 제한됩니다. 이것은 많은 정적 데이터를 사용하는 프로그램이 필요할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="fc8c5a89f214acd8179a09f487fb87bbd0d7c872" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) code to load up the static chain register (&lt;code&gt;r11&lt;/code&gt;) when calling through a pointer on AIX and 64-bit Linux systems where a function pointer points to a 3-word descriptor giving the function address, TOC value to be loaded in register &lt;code&gt;r2&lt;/code&gt;, and static chain value to be loaded in register &lt;code&gt;r11&lt;/code&gt;. The</source>
          <target state="translated">함수 포인터가 함수 주소, TOC 값을 제공하는 3 워드 디스크립터를 가리키는 AIX 및 64 비트 Linux 시스템에서 포인터를 통해 호출 할 때 정적 체인 레지스터 ( &lt;code&gt;r11&lt;/code&gt; ) 를로드하는 코드를 생성 (생성하지 않음) 하십시오. 레지스터 &lt;code&gt;r2&lt;/code&gt; 에로드되고 레지스터 &lt;code&gt;r11&lt;/code&gt; 에 로드 될 정적 체인 값 . 그만큼</target>
        </trans-unit>
        <trans-unit id="813e9e6ca1642f726fee97bfddf02338960484b7" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) code to pass structure parameters with a maximum alignment of 64 bits, for compatibility with older versions of GCC.</source>
          <target state="translated">구 버전의 GCC와의 호환성을 위해 최대 64 비트 정렬로 구조 매개 변수를 전달하는 코드를 생성 (생성하지 않음)하십시오.</target>
        </trans-unit>
        <trans-unit id="55cac71e3fa8543a26a5b7f404ac565adfa17f28" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) code to save the TOC value in the reserved stack location in the function prologue if the function calls through a pointer on AIX and 64-bit Linux systems. If the TOC value is not saved in the prologue, it is saved just before the call through the pointer. The</source>
          <target state="translated">함수가 AIX 및 64 비트 Linux 시스템에서 포인터를 통해 호출하는 경우 함수 프롤로그의 예약 된 스택 위치에 TOC 값을 저장하는 코드를 생성 (생성하지 않음)하십시오. TOC 값이 프롤로그에 저장되지 않은 경우 포인터를 통해 호출 직전에 저장됩니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="492f533f0926b6f12aa3c20775f6e3689bd7771b" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) microMIPS code.</source>
          <target state="translated">microMIPS 코드를 생성 (생성하지 않음)하십시오.</target>
        </trans-unit>
        <trans-unit id="3996f10552777a166b0e49d921b421c578c5e2f7" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) pc-relative addressing when the option</source>
          <target state="translated">옵션이있을 때 pc 상대 주소 지정 생성 (생성하지 않음)</target>
        </trans-unit>
        <trans-unit id="c38ed93b70630b073ac9de0cd53b30eca713a227" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) the &lt;code&gt;friz&lt;/code&gt; instruction when the</source>
          <target state="translated">때 &lt;code&gt;friz&lt;/code&gt; 명령을 생성 (생성하지 마십시오)</target>
        </trans-unit>
        <trans-unit id="59dec4f42737e1a4ee2b102faf59b8bbec911145" translate="yes" xml:space="preserve">
          <source>Generate (do not generate) the MMA instructions when the option</source>
          <target state="translated">옵션이 다음과 같은 경우 MMA 지침 생성 (생성하지 않음)</target>
        </trans-unit>
        <trans-unit id="87be6d200ff57766f2cf75cef2026526e7116620" translate="yes" xml:space="preserve">
          <source>Generate (or do not generate) code using the &lt;code&gt;bras&lt;/code&gt; instruction to do subroutine calls. This only works reliably if the total executable size does not exceed 64k. The default is to use the &lt;code&gt;basr&lt;/code&gt; instruction instead, which does not have this limitation.</source>
          <target state="translated">서브 루틴 호출을 수행하기 위해 &lt;code&gt;bras&lt;/code&gt; 명령어를 사용하여 코드를 생성하거나 생성하지 마십시오 . 총 실행 파일 크기가 64k를 초과하지 않는 경우에만 안정적으로 작동합니다. 기본적으로 &lt;code&gt;basr&lt;/code&gt; 명령어 를 사용하는 것이지만 이 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="dac8cd11137e120330b4b9ae84e6593137818e9a" translate="yes" xml:space="preserve">
          <source>Generate (or do not generate) code using the &lt;code&gt;mvcle&lt;/code&gt; instruction to perform block moves. When</source>
          <target state="translated">&lt;code&gt;mvcle&lt;/code&gt; 명령어를 사용하여 코드를 생성 (또는 생성하지 않음)하여 블록 이동을 수행합니다. 언제</target>
        </trans-unit>
        <trans-unit id="2e0545421416cf516c0b942352accf8dc6b0a0d5" translate="yes" xml:space="preserve">
          <source>Generate (or don&amp;rsquo;t) &amp;lsquo;</source>
          <target state="translated">생성 (또는하지 않음) '</target>
        </trans-unit>
        <trans-unit id="05dd2841d03433fc0ea5db0c7e0df3c7599676c8" translate="yes" xml:space="preserve">
          <source>Generate (or don&amp;rsquo;t) a stop bit immediately before and after volatile asm statements.</source>
          <target state="translated">휘발성 asm 문 바로 앞과 뒤에 정지 비트를 생성하거나 생성하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="a0784cc5b984b19815bf9eec6e275ae1a59c3b0f" translate="yes" xml:space="preserve">
          <source>Generate (or don&amp;rsquo;t) code for the GNU assembler. This is the default.</source>
          <target state="translated">GNU 어셈블러 용 코드를 생성하거나 생성하지 않습니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="2516ed040d38a5388dd7fe01c44239d79052cf2e" translate="yes" xml:space="preserve">
          <source>Generate (or don&amp;rsquo;t) code for the GNU linker. This is the default.</source>
          <target state="translated">GNU 링커에 대한 코드를 생성하거나 생성하지 마십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="3e316b54c0eaa7bda512b60e40414c689d945ab8" translate="yes" xml:space="preserve">
          <source>Generate 16-bit instructions.</source>
          <target state="translated">16 비트 명령어를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a52620c65360885e469f926c554c75bd50dd9583" translate="yes" xml:space="preserve">
          <source>Generate 3-instruction load and store sequences as sometimes required by the HP-UX 10 linker. This is equivalent to the &amp;lsquo;</source>
          <target state="translated">HP-UX 10 링커에 필요할 때마다 3 명령로드 및 저장 시퀀스를 생성합니다. 이것은 '</target>
        </trans-unit>
        <trans-unit id="b384dbdcdcc6be12f32b73f9469c3ba6b9f1dccf" translate="yes" xml:space="preserve">
          <source>Generate 32x16-bit multiply and multiply-accumulate instructions.</source>
          <target state="translated">32x16 비트 곱하기 및 곱하기 누산 명령어를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="0ccaaa46afb8881f4f3a477c92bc05eae68e0c4a" translate="yes" xml:space="preserve">
          <source>Generate &lt;code&gt;.debug_pubnames&lt;/code&gt; and &lt;code&gt;.debug_pubtypes&lt;/code&gt; sections in a format suitable for conversion into a GDB index. This option is only useful with a linker that can produce GDB index version 7.</source>
          <target state="translated">&lt;code&gt;.debug_pubnames&lt;/code&gt; 및 &lt;code&gt;.debug_pubtypes&lt;/code&gt; 섹션을 GDB 색인으로 변환하기에 적합한 형식으로 생성하십시오 . 이 옵션은 GDB 인덱스 버전 7을 생성 할 수있는 링커에서만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="828612c6e2cc35cf1bee3972f49446cb2047aba1" translate="yes" xml:space="preserve">
          <source>Generate &lt;code&gt;mul64&lt;/code&gt; and &lt;code&gt;mulu64&lt;/code&gt; instructions. Only valid for</source>
          <target state="translated">&lt;code&gt;mul64&lt;/code&gt; 및 &lt;code&gt;mulu64&lt;/code&gt; 명령어를 생성하십시오 . 에 대해서만 유효</target>
        </trans-unit>
        <trans-unit id="f37d583fd1aea916d55ab9e91fa3002c399aaf84" translate="yes" xml:space="preserve">
          <source>Generate &lt;code&gt;norm&lt;/code&gt; instructions. This is the default if</source>
          <target state="translated">&lt;code&gt;norm&lt;/code&gt; 지침을 생성하십시오 . 이것이 기본값 인 경우</target>
        </trans-unit>
        <trans-unit id="2934019de0c741342611be8077a1571f0c44928a" translate="yes" xml:space="preserve">
          <source>Generate &lt;code&gt;swap&lt;/code&gt; instructions.</source>
          <target state="translated">&lt;code&gt;swap&lt;/code&gt; 명령어를 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="586858db58f3f2f4e0ba5be27cc76fd1d37e386f" translate="yes" xml:space="preserve">
          <source>Generate &lt;var&gt;N&lt;/var&gt; NOPs right at the beginning of each function, with the function entry point before the &lt;var&gt;M&lt;/var&gt;th NOP. If &lt;var&gt;M&lt;/var&gt; is omitted, it defaults to &lt;code&gt;0&lt;/code&gt; so the function entry points to the address just at the first NOP. The NOP instructions reserve extra space which can be used to patch in any desired instrumentation at run time, provided that the code segment is writable. The amount of space is controllable indirectly via the number of NOPs; the NOP instruction used corresponds to the instruction emitted by the internal GCC back-end interface &lt;code&gt;gen_nop&lt;/code&gt;. This behavior is target-specific and may also depend on the architecture variant and/or other compilation options.</source>
          <target state="translated">&lt;var&gt;M&lt;/var&gt; 번째 NOP 앞에 함수 진입 점이있는 각 함수의 시작 부분에서 바로 &lt;var&gt;N&lt;/var&gt; NOP를 생성하십시오 . 경우 &lt;var&gt;M&lt;/var&gt; 은 , 그것은 디폴트 생략 &lt;code&gt;0&lt;/code&gt; 단지 제 NOP의 주소 함수 엔트리 포인트 있도록. NOP 명령어는 코드 세그먼트가 쓰기 가능한 경우 런타임에 원하는 계측에서 패치하는 데 사용할 수있는 추가 공간을 예약합니다. 공간의 양은 NOP의 수를 통해 간접적으로 제어 할 수 있습니다. 사용 된 NOP 명령어는 내부 GCC 백엔드 인터페이스 &lt;code&gt;gen_nop&lt;/code&gt; 에서 생성 한 명령어에 해당합니다 . 이 동작은 대상에 따라 다르며 아키텍처 변형 및 / 또는 다른 컴파일 옵션에 따라 달라질 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b56d0340e46553074756e8938fdcc9bc10345ee9" translate="yes" xml:space="preserve">
          <source>Generate C header describing the largest structure that is passed by value, if any.</source>
          <target state="translated">값으로 전달되는 가장 큰 구조를 설명하는 C 헤더를 생성하십시오 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="497d1946c219789282a881eeb57aa9b71f210579" translate="yes" xml:space="preserve">
          <source>Generate DWARF &lt;code&gt;.debug_pubnames&lt;/code&gt; and &lt;code&gt;.debug_pubtypes&lt;/code&gt; sections.</source>
          <target state="translated">DWARF &lt;code&gt;.debug_pubnames&lt;/code&gt; 및 &lt;code&gt;.debug_pubtypes&lt;/code&gt; 섹션을 생성하십시오 .</target>
        </trans-unit>
        <trans-unit id="2f0d6b717c142d078ddbdb831a6e380bea411850" translate="yes" xml:space="preserve">
          <source>Generate GNU/Linux compatible gUSA software atomic sequences for the atomic built-in functions. The generated atomic sequences require additional support from the interrupt/exception handling code of the system and are only suitable for SH3* and SH4* single-core systems. This option is enabled by default when the target is &lt;code&gt;sh*-*-linux*&lt;/code&gt; and SH3* or SH4*. When the target is SH4A, this option also partially utilizes the hardware atomic instructions &lt;code&gt;movli.l&lt;/code&gt; and &lt;code&gt;movco.l&lt;/code&gt; to create more efficient code, unless &amp;lsquo;</source>
          <target state="translated">원자 내장 함수에 대한 GNU / Linux 호환 gUSA 소프트웨어 원자 시퀀스를 생성합니다. 생성 된 원자 시퀀스는 시스템의 인터럽트 / 예외 처리 코드에서 추가 지원이 필요하며 SH3 * 및 SH4 * 단일 코어 시스템에만 적합합니다. 이 옵션은 대상이 &lt;code&gt;sh*-*-linux*&lt;/code&gt; 및 SH3 * 또는 SH4 * 인 경우 기본적으로 사용됩니다 . 대상이 SH4A 인 경우이 옵션은 하드웨어 원자 명령어 &lt;code&gt;movli.l&lt;/code&gt; 및 &lt;code&gt;movco.l&lt;/code&gt; 을 부분적으로 사용하여 '</target>
        </trans-unit>
        <trans-unit id="bf2d938e1c1ea97f318900579ce3c50a9ae898af" translate="yes" xml:space="preserve">
          <source>Generate GP-relative accesses for all data objects in the program. If you use this option, the entire data and BSS segments of your program must fit in 64K of memory and you must use an appropriate linker script to allocate them within the addressable range of the global pointer.</source>
          <target state="translated">프로그램의 모든 데이터 개체에 대한 GP 상대 액세스를 생성하십시오. 이 옵션을 사용하면 프로그램의 전체 데이터 및 BSS 세그먼트가 64K 메모리에 맞아야하며 적절한 링커 스크립트를 사용하여 주소 지정 가능한 전역 포인터 범위 내에 할당해야합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
