<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="gcc">
    <body>
      <group id="gcc">
        <trans-unit id="f6ee8357cf66d468fce21ce87f6e1455c61c9d71" translate="yes" xml:space="preserve">
          <source>8.2. +load: Executing Code before main</source>
          <target state="translated">8.2. +로드 : 메인 전에 코드 실행</target>
        </trans-unit>
        <trans-unit id="0e37b3bc6a72bc7a45aefe525b01b3bcbc69dc62" translate="yes" xml:space="preserve">
          <source>8.2.1 What You Can and Cannot Do in +load</source>
          <target state="translated">8.2.1 +로드에서 할 수있는 것과 할 수없는 것</target>
        </trans-unit>
        <trans-unit id="7514eae887431bc2b23c9f91ceeb2b8927f90957" translate="yes" xml:space="preserve">
          <source>8.2.1 What You Can and Cannot Do in &lt;code&gt;+load&lt;/code&gt;</source>
          <target state="translated">8.2.1 &lt;code&gt;+load&lt;/code&gt; 에서 할 수있는 것과 할 수없는 것</target>
        </trans-unit>
        <trans-unit id="8bc74bfbf57cd10928d01b916e6fa71d6d37346e" translate="yes" xml:space="preserve">
          <source>8.2.1. What You Can and Cannot Do in +load</source>
          <target state="translated">8.2.1. +로드에서 할 수 있고 할 수없는 것</target>
        </trans-unit>
        <trans-unit id="ac17a28fe0400efdbbf27dc0a3aa19d768882f50" translate="yes" xml:space="preserve">
          <source>8.3 Type Encoding</source>
          <target state="translated">8.3 타입 인코딩</target>
        </trans-unit>
        <trans-unit id="0b5a28a401e5caa1731675ca56a84d444c15fa81" translate="yes" xml:space="preserve">
          <source>8.3. Type Encoding</source>
          <target state="translated">8.3. 타입 인코딩</target>
        </trans-unit>
        <trans-unit id="f6228ff4737811227a708bc22b6ff3a77b75cceb" translate="yes" xml:space="preserve">
          <source>8.3.1 Legacy Type Encoding</source>
          <target state="translated">8.3.1 레거시 유형 인코딩</target>
        </trans-unit>
        <trans-unit id="7bec6b4bee7afdb83a43730a9fe5c4d6d085e864" translate="yes" xml:space="preserve">
          <source>8.3.1. Legacy Type Encoding</source>
          <target state="translated">8.3.1. 레거시 유형 인코딩</target>
        </trans-unit>
        <trans-unit id="5527244afdb6dfb3dca3ad889987c2fef987074e" translate="yes" xml:space="preserve">
          <source>8.3.2 &lt;code&gt;@encode&lt;/code&gt;</source>
          <target state="translated">8.3.2 &lt;code&gt;@encode&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="978fa94702c6bb2aa016de617938fd819d570db4" translate="yes" xml:space="preserve">
          <source>8.3.2 @encode</source>
          <target state="translated">8.3.2 @encode</target>
        </trans-unit>
        <trans-unit id="4493f310bc1651626e01d4c07ee677385159442c" translate="yes" xml:space="preserve">
          <source>8.3.2. @encode</source>
          <target state="translated">8.3.2. @encode</target>
        </trans-unit>
        <trans-unit id="e76f8c08ebb07739970dc34b59461ba675ae7b31" translate="yes" xml:space="preserve">
          <source>8.3.3 Method Signatures</source>
          <target state="translated">8.3.3 메소드 서명</target>
        </trans-unit>
        <trans-unit id="0cd2b9090f85dc474192078b9cdd2977a7b93ce8" translate="yes" xml:space="preserve">
          <source>8.3.3. Method Signatures</source>
          <target state="translated">8.3.3. 메소드 서명</target>
        </trans-unit>
        <trans-unit id="8dc0bdb621513ef296dfe1ccb8a8e69178e55c00" translate="yes" xml:space="preserve">
          <source>8.4 Garbage Collection</source>
          <target state="translated">8.4 가비지 콜렉션</target>
        </trans-unit>
        <trans-unit id="f07f1c7fc14cbe1fbcf43d8205938600aba5fb3a" translate="yes" xml:space="preserve">
          <source>8.4. Garbage Collection</source>
          <target state="translated">8.4. 가비지 콜렉션</target>
        </trans-unit>
        <trans-unit id="7a1c9992cbe3a8eb5bac4598d41c0f55497fcfd0" translate="yes" xml:space="preserve">
          <source>8.5 Constant String Objects</source>
          <target state="translated">8.5 상수 문자열 객체</target>
        </trans-unit>
        <trans-unit id="4a2eeb0e04646c0d1d5dde7596bb4e3ab441cf85" translate="yes" xml:space="preserve">
          <source>8.5. Constant String Objects</source>
          <target state="translated">8.5. 상수 문자열 객체</target>
        </trans-unit>
        <trans-unit id="1ad03b99d44944113a02e8b2d43422e1fb50690e" translate="yes" xml:space="preserve">
          <source>8.6 &lt;code&gt;compatibility_alias&lt;/code&gt;</source>
          <target state="translated">8.6 &lt;code&gt;compatibility_alias&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="16a6371cd4eb99b88acbb876c48214d1528996b9" translate="yes" xml:space="preserve">
          <source>8.6 compatibility_alias</source>
          <target state="translated">8.6 호환성</target>
        </trans-unit>
        <trans-unit id="68169a32cc1b2c0d8e0fdd12ac28ee8a4f88ccd1" translate="yes" xml:space="preserve">
          <source>8.6. compatibility_alias</source>
          <target state="translated">8.6. 호환성 _ 별칭</target>
        </trans-unit>
        <trans-unit id="477e0b2d2877013fc309d42abd04b7a7fac95b0e" translate="yes" xml:space="preserve">
          <source>8.7 Exceptions</source>
          <target state="translated">8.7 예외</target>
        </trans-unit>
        <trans-unit id="16af8614813519947458cd70b76429228a166bf8" translate="yes" xml:space="preserve">
          <source>8.7. Exceptions</source>
          <target state="translated">8.7. 예외</target>
        </trans-unit>
        <trans-unit id="74543d3119c6680f587a9317c42b3e80f7812525" translate="yes" xml:space="preserve">
          <source>8.8 Synchronization</source>
          <target state="translated">8.8 동기화</target>
        </trans-unit>
        <trans-unit id="083f9b1455cca391952297e65a5f3c8e7fb0c091" translate="yes" xml:space="preserve">
          <source>8.8. Synchronization</source>
          <target state="translated">8.8. 동기화</target>
        </trans-unit>
        <trans-unit id="7338c2122f2c6512086917a88263a1ffa319037d" translate="yes" xml:space="preserve">
          <source>8.9 Fast Enumeration</source>
          <target state="translated">8.9 빠른 열거</target>
        </trans-unit>
        <trans-unit id="ec7154738dfa0ae117df4872a446a28e2a0711e7" translate="yes" xml:space="preserve">
          <source>8.9. Fast Enumeration</source>
          <target state="translated">8.9. 빠른 열거</target>
        </trans-unit>
        <trans-unit id="c5c48c9ddc1c6eec5370a9f3cc1d2da53b4277bc" translate="yes" xml:space="preserve">
          <source>8.9.1 Using Fast Enumeration</source>
          <target state="translated">8.9.1 빠른 열거 사용</target>
        </trans-unit>
        <trans-unit id="6ad2c7a48f39c65d867329ec2c7335528dcac484" translate="yes" xml:space="preserve">
          <source>8.9.1. Using Fast Enumeration</source>
          <target state="translated">8.9.1. 빠른 열거 사용</target>
        </trans-unit>
        <trans-unit id="d4e4b02de8979958bbc292a9013946837f1fa2de" translate="yes" xml:space="preserve">
          <source>8.9.2 C99-Like Fast Enumeration Syntax</source>
          <target state="translated">8.9.2 C99와 같은 빠른 열거 구문</target>
        </trans-unit>
        <trans-unit id="c0c8d7e4c548cb334b0077b49fb8d7954fa1bc7a" translate="yes" xml:space="preserve">
          <source>8.9.2. C99-Like Fast Enumeration Syntax</source>
          <target state="translated">8.9.2. C99와 같은 빠른 열거 구문</target>
        </trans-unit>
        <trans-unit id="fc941982a158e238821dd94fbed3bb5cab331767" translate="yes" xml:space="preserve">
          <source>8.9.3 Fast Enumeration Details</source>
          <target state="translated">8.9.3 빠른 열거 세부 사항</target>
        </trans-unit>
        <trans-unit id="1e69e987b4483c072c99556446bfbd580c89a6c7" translate="yes" xml:space="preserve">
          <source>8.9.3. Fast Enumeration Details</source>
          <target state="translated">8.9.3. 빠른 열거 세부 사항</target>
        </trans-unit>
        <trans-unit id="66afcdf52d12c5936c393d8a7d4415ca40641c8c" translate="yes" xml:space="preserve">
          <source>8.9.4 Fast Enumeration Protocol</source>
          <target state="translated">8.9.4 빠른 열거 프로토콜</target>
        </trans-unit>
        <trans-unit id="af86351ac19c6a92b0fadb75de17d30680748abf" translate="yes" xml:space="preserve">
          <source>8.9.4. Fast Enumeration Protocol</source>
          <target state="translated">8.9.4. 빠른 열거 프로토콜</target>
        </trans-unit>
        <trans-unit id="2a24cd506294a07c6a0446f8badafaf3201f2507" translate="yes" xml:space="preserve">
          <source>9 Binary Compatibility</source>
          <target state="translated">이진 호환성</target>
        </trans-unit>
        <trans-unit id="aaf34f43b56348453c9670867bbe710bc4cff1f1" translate="yes" xml:space="preserve">
          <source>9-bit signed integer constant for load and store postincrements</source>
          <target state="translated">로드 및 저장 후 증가분을위한 9 비트 부호있는 정수 상수</target>
        </trans-unit>
        <trans-unit id="f5866ff425b2380665d4757e884a24f7c0c34afd" translate="yes" xml:space="preserve">
          <source>9. Binary Compatibility</source>
          <target state="translated">이진 호환성</target>
        </trans-unit>
        <trans-unit id="05a79f06cf3f67f726dae68d18a2290f6c9a50c9" translate="yes" xml:space="preserve">
          <source>:</source>
          <target state="translated">:</target>
        </trans-unit>
        <trans-unit id="0e96f6929feaa8c7f7735055f893a7b75a845c22" translate="yes" xml:space="preserve">
          <source>: even though it may help make the global offset table smaller, it trades 1 instruction for 4. With</source>
          <target state="translated">: 전역 오프셋 테이블을 더 작게 만드는 데 도움이 될 수 있지만 4에 대해 1 명령을 교환합니다.</target>
        </trans-unit>
        <trans-unit id="63347315fe8e655bf95e9a504d6fcbb0f9ecd9f0" translate="yes" xml:space="preserve">
          <source>: this header declares a public runtime API threading layer that is only provided by the GNU Objective-C runtime. It declares functions such as &lt;code&gt;objc_mutex_lock()&lt;/code&gt;, which provide a platform-independent set of threading functions.</source>
          <target state="translated">:이 헤더는 GNU Objective-C 런타임에서만 제공되는 공개 런타임 API 스레딩 계층을 선언합니다. 플랫폼 독립적 인 스레딩 함수 세트를 제공하는 &lt;code&gt;objc_mutex_lock()&lt;/code&gt; 과 같은 함수를 선언 합니다.</target>
        </trans-unit>
        <trans-unit id="30dd56b7640731d14fa9ecac2bbbbb504e1a5176" translate="yes" xml:space="preserve">
          <source>: this header declares most of the public runtime API functions allowing you to inspect and manipulate the Objective-C runtime data structures. These functions are fairly standardized across Objective-C runtimes and are almost identical to the Apple/NeXT Objective-C runtime ones. It does not declare functions in some specialized areas (constructing and forwarding message invocations, threading) which are in the other headers below. You have to include</source>
          <target state="translated">:이 헤더는 Objective-C 런타임 데이터 구조를 검사하고 조작 할 수있는 대부분의 공용 런타임 API 함수를 선언합니다. 이러한 기능은 Objective-C 런타임에서 상당히 표준화되어 있으며 Apple / NeXT Objective-C 런타임과 거의 동일합니다. 아래의 다른 헤더에있는 일부 특수 영역 (메시지 호출 구성 및 전달, 스레딩)에서는 함수를 선언하지 않습니다. 당신은 포함해야합니다</target>
        </trans-unit>
        <trans-unit id="26a235338902d41d3db5491024b9576d18742880" translate="yes" xml:space="preserve">
          <source>: this header declares public functions used to construct, deconstruct and forward message invocations. Because messaging is done in quite a different way on different runtimes, functions in this header are specific to the GNU Objective-C runtime implementation.</source>
          <target state="translated">:이 헤더는 메시지 호출을 구성, 해체 및 전달하는 데 사용되는 공용 함수를 선언합니다. 메시징은 서로 다른 런타임에서 상당히 다른 방식으로 수행되므로이 ​​헤더의 기능은 GNU Objective-C 런타임 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="5a3c29505625144ba68750995731439e9906fdd5" translate="yes" xml:space="preserve">
          <source>: this header declares some public functions related to Objective-C exceptions. For example functions in this header allow you to throw an Objective-C exception from plain C/C++ code.</source>
          <target state="translated">:이 헤더는 Objective-C 예외와 관련된 일부 공용 함수를 선언합니다. 예를 들어이 헤더의 함수를 사용하면 일반 C / C ++ 코드에서 Objective-C 예외를 throw 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e5ef08f873716700e594dd3a36d7d64d5272d49" translate="yes" xml:space="preserve">
          <source>: this header declares some public functions related to the Objective-C &lt;code&gt;@synchronized()&lt;/code&gt; syntax, allowing you to emulate an Objective-C &lt;code&gt;@synchronized()&lt;/code&gt; block in plain C/C++ code.</source>
          <target state="translated">:이 헤더는 Objective-C &lt;code&gt;@synchronized()&lt;/code&gt; 구문 과 관련된 일부 공용 함수를 선언 하여 일반 C / C ++ 코드에서 Objective-C &lt;code&gt;@synchronized()&lt;/code&gt; 블록 을 에뮬레이션 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7cc9c1a09bf135868f452e4dc5bbf2907bfed13f" translate="yes" xml:space="preserve">
          <source>: this is the basic Objective-C header file, defining the basic Objective-C types such as &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;Class&lt;/code&gt; and &lt;code&gt;BOOL&lt;/code&gt;. You have to include this header to do almost anything with Objective-C.</source>
          <target state="translated">: 이것은 기본 Objective-C 헤더 파일이며 &lt;code&gt;id&lt;/code&gt; , &lt;code&gt;Class&lt;/code&gt; 및 &lt;code&gt;BOOL&lt;/code&gt; 과 같은 기본 Objective-C 유형을 정의합니다 . Objective-C로 거의 모든 작업을 수행하려면이 헤더를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="e8c89b6d4332bd3369abe0522644501e5013a432" translate="yes" xml:space="preserve">
          <source>; higher levels are not, and must be explicitly requested.</source>
          <target state="translated">; 높은 수준은 아니므로 명시 적으로 요청해야합니다.</target>
        </trans-unit>
        <trans-unit id="a66283a15e09823e79a5c6a663cf680f2ab5e710" translate="yes" xml:space="preserve">
          <source>; however, use of the backchain for debugging purposes usually requires that the whole binary is built with</source>
          <target state="translated">; 그러나 디버깅 목적으로 백 체인을 사용하려면 일반적으로 전체 바이너리가 다음과 같이 빌드되어야합니다.</target>
        </trans-unit>
        <trans-unit id="2e840d8b6d6867941a2eee8b46c7d917829de2b1" translate="yes" xml:space="preserve">
          <source>; it causes the preprocessor to treat comments as tokens in their own right. For example, comments appearing at the start of what would be a directive line have the effect of turning that line into an ordinary source line, since the first token on the line is no longer a &amp;lsquo;</source>
          <target state="translated">; 전처리 기가 주석을 토큰으로 취급하도록합니다. 예를 들어, 지시문 줄의 시작 부분에 나타나는 주석은 해당 줄을 첫 번째 토큰이 더 이상 '</target>
        </trans-unit>
        <trans-unit id="fe9de4759d0dc5597c891d37b107703d1930a026" translate="yes" xml:space="preserve">
          <source>; it then defines &lt;code&gt;__STDC_HOSTED__&lt;/code&gt; to &lt;code&gt;0&lt;/code&gt; and does not make assumptions about the meanings of function names from the standard library, with exceptions noted below. To build an OS kernel, you may well still need to make your own arrangements for linking and startup. See &lt;a href=&quot;c-dialect-options#C-Dialect-Options&quot;&gt;Options Controlling C Dialect&lt;/a&gt;.</source>
          <target state="translated">; 그런 다음 &lt;code&gt;__STDC_HOSTED__&lt;/code&gt; 를 &lt;code&gt;0&lt;/code&gt; 으로 정의 하고 아래에 언급 된 예외를 제외하고 표준 라이브러리에서 함수 이름의 의미에 대해 가정하지 않습니다. OS 커널을 빌드하려면 연결 및 시작을위한 고유 한 배열을 만들어야 할 수도 있습니다. &lt;a href=&quot;c-dialect-options#C-Dialect-Options&quot;&gt;C 방언 제어 옵션을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0bd28d9793fcd7e9f0549371e16a97a1f053629f" translate="yes" xml:space="preserve">
          <source>; see &lt;a href=&quot;c_002b_002b-dialect-options#C_002b_002b-Dialect-Options&quot;&gt;Options Controlling C++ Dialect&lt;/a&gt;.</source>
          <target state="translated">; &lt;a href=&quot;c_002b_002b-dialect-options#C_002b_002b-Dialect-Options&quot;&gt;C ++ Dialect 제어 옵션을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="50016dac566b707582c4b1fc771e52069b7a937b" translate="yes" xml:space="preserve">
          <source>; the corrections are also applied with</source>
          <target state="translated">; 수정 사항도 함께 적용됩니다</target>
        </trans-unit>
        <trans-unit id="3eb04dcb759dd8c0995915b2a5ccb10d6a327b33" translate="yes" xml:space="preserve">
          <source>; the same rule applies to macros defined this way.</source>
          <target state="translated">; 이 방법으로 정의 된 매크로에도 동일한 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="00b878f7746de72103ac67a35f0e1d78575bcec7" translate="yes" xml:space="preserve">
          <source>; they do not have this problem.</source>
          <target state="translated">; 그들은이 문제가 없습니다.</target>
        </trans-unit>
        <trans-unit id="39de10441f5a92f5c2ca38349b7c2fdec8841dcf" translate="yes" xml:space="preserve">
          <source>; this option implies</source>
          <target state="translated">; 이 옵션은</target>
        </trans-unit>
        <trans-unit id="1989c55c1ff2b01f4215828caa4538ad66beba83" translate="yes" xml:space="preserve">
          <source>; to obtain all the diagnostics required by the standard, you should also specify</source>
          <target state="translated">; 표준에 필요한 모든 진단을 받으려면 다음을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="a73b42f7298a4e09fb1e0072c5f63bdced6b9b8c" translate="yes" xml:space="preserve">
          <source>; when linking, it links in a special thread helper library</source>
          <target state="translated">; 링크 할 때 특수 스레드 도우미 라이브러리에서 링크됩니다</target>
        </trans-unit>
        <trans-unit id="06561510744788a1609ec5f60662cc5908d39e15" translate="yes" xml:space="preserve">
          <source>; you should not need to use it for anything else.</source>
          <target state="translated">; 다른 용도로는 사용할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="431058a2491fcbde34064009eece9653a8f5b829" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Example&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Example&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="01d7c1c3eb993c58806b746668090c8a26bb75db" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Limitations and caveats&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;한계와 경고&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0424675c89789c8478a359447a9eeb880c777989" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;[basic.start.init]&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;[basic.start.init]&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e3b972f187fc77684d7b4caf8cb567979becf9f7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;[basic.start.main]&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;[basic.start.main]&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b883af22766032bc16303da205cb38fbd19479e1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;[basic.start.term]&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;[basic.start.term]&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b18fcd33e6f11059c9a572ef77f16711d1475704" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;[basic.stc.static]&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;[basic.stc.static]&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0fc91ea62596ffaa9b88e5f5653a875441113bac" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;[basic.stc.thread]&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;[basic.stc.thread]&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="13e2f1e5179d31ce813b6d9c962af8d8f15a52b2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;[basic.stc]&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;[basic.stc]&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="082e6d5681614613f1cf46008d31795e30341ce2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;[class.mem]&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;[class.mem]&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="20a71e88049b10a9036fc51e894c28860a33cdaf" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;[dcl.stc]&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;[dcl.stc]&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="51818883b235ce777320b575e0bf8025965510ba" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;[intro.execution]&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;[intro.execution]&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1a31fbd2e2b9c5c3bb615b7491f612d5a707c3ac" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;[lex.key]&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;[lex.key]&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5cc4701ea1dbc7c0ae0a60db0f72537871372ebf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;![16,16i]&lt;/code&gt; (alignment depends on the machine)</source>
          <target state="translated">&lt;code&gt;![16,16i]&lt;/code&gt; (정렬은 기계에 따라 다릅니다)</target>
        </trans-unit>
        <trans-unit id="cffc58ac2d212878e6c4d3afeb9026603af158fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#pragma interface&lt;/code&gt; and &lt;code&gt;#pragma implementation&lt;/code&gt; provide the user with a way of explicitly directing the compiler to emit entities with vague linkage (and debugging information) in a particular translation unit.</source>
          <target state="translated">&lt;code&gt;#pragma interface&lt;/code&gt; 및 &lt;code&gt;#pragma implementation&lt;/code&gt; 은 특정 변환 단위에서 모호한 링크 (및 디버깅 정보)가있는 엔티티를 생성하도록 컴파일러에 명시 적으로 지시하는 방법을 사용자에게 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2569b071a9af441d9b6296aa268b56f40df7cca9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#pragma ms_struct off&lt;/code&gt; turns off the Microsoft layout.</source>
          <target state="translated">&lt;code&gt;#pragma ms_struct off&lt;/code&gt; 는 Microsoft 레이아웃을 끕니다.</target>
        </trans-unit>
        <trans-unit id="5e363473f488b7983412e972ce0eac0f09b14174" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#pragma ms_struct on&lt;/code&gt; turns on the Microsoft layout.</source>
          <target state="translated">&lt;code&gt;#pragma ms_struct on&lt;/code&gt; 은 Microsoft 레이아웃 을 켭니다.</target>
        </trans-unit>
        <trans-unit id="107cfa70f66f6e21716326b44d8c2543bd277a0b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#pragma ms_struct reset&lt;/code&gt; goes back to the default layout.</source>
          <target state="translated">&lt;code&gt;#pragma ms_struct reset&lt;/code&gt; 은 기본 레이아웃으로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="359f3157fca41c8df8f6c827d78d1920672257ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#pragma pack()&lt;/code&gt; sets the alignment to the one that was in effect when compilation started (see also command-line option</source>
          <target state="translated">&lt;code&gt;#pragma pack()&lt;/code&gt; 은 컴파일을 시작할 때 적용되었던 정렬을 정렬합니다 (명령 줄 옵션 참조).</target>
        </trans-unit>
        <trans-unit id="2da8592b5f1ca4f7c8ec146ce07922d1be68b588" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#pragma pack(&lt;var&gt;n&lt;/var&gt;)&lt;/code&gt; simply sets the new alignment.</source>
          <target state="translated">&lt;code&gt;#pragma pack(&lt;var&gt;n&lt;/var&gt;)&lt;/code&gt; 단순히 새로운 정렬을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="09cd1961f6ec088315967f82b215657a1847a8f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#pragma pack(pop)&lt;/code&gt; restores the alignment setting to the one saved at the top of the internal stack (and removes that stack entry). Note that &lt;code&gt;#pragma pack([&lt;var&gt;n&lt;/var&gt;])&lt;/code&gt; does not influence this internal stack; thus it is possible to have &lt;code&gt;#pragma pack(push)&lt;/code&gt; followed by multiple &lt;code&gt;#pragma pack(&lt;var&gt;n&lt;/var&gt;)&lt;/code&gt; instances and finalized by a single &lt;code&gt;#pragma pack(pop)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;#pragma pack(pop)&lt;/code&gt; 은 정렬 설정을 내부 스택 맨 위에 저장된 항목으로 복원하고 해당 스택 항목을 제거합니다. 주의 &lt;code&gt;#pragma pack([&lt;var&gt;n&lt;/var&gt;])&lt;/code&gt; 이 내부 스택에 영향을주지 않는다; 따라서 &lt;code&gt;#pragma pack(push)&lt;/code&gt; 다음에 여러 개의 &lt;code&gt;#pragma pack(&lt;var&gt;n&lt;/var&gt;)&lt;/code&gt; 인스턴스가 있고 단일 &lt;code&gt;#pragma pack(pop)&lt;/code&gt; 마무리 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1f4e8456ee450b615ff464f6ff9615991f7f956" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#pragma pack(push[,&lt;var&gt;n&lt;/var&gt;])&lt;/code&gt; pushes the current alignment setting on an internal stack and then optionally sets the new alignment.</source>
          <target state="translated">&lt;code&gt;#pragma pack(push[,&lt;var&gt;n&lt;/var&gt;])&lt;/code&gt; 은 내부 정렬에서 현재 정렬 설정을 푸시 한 다음 선택적으로 새 정렬을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="8d404d78e391f3edc2a1e7fe1018546d3f145abe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#pragma scalar_storage_order big-endian&lt;/code&gt; sets the storage order of the scalar fields to big-endian.</source>
          <target state="translated">&lt;code&gt;#pragma scalar_storage_order big-endian&lt;/code&gt; 은 스칼라 필드의 저장 순서를 big-endian으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="791d1af4df580d4926f6784307622e913fe6169f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#pragma scalar_storage_order default&lt;/code&gt; goes back to the endianness that was in effect when compilation started (see also command-line option</source>
          <target state="translated">&lt;code&gt;#pragma scalar_storage_order default&lt;/code&gt; 은 컴파일을 시작할 때 적용되었던 엔디안으로 돌아갑니다 (명령 줄 옵션 참조).</target>
        </trans-unit>
        <trans-unit id="9e92ce5f2b8e8dd2da4f3a23c57c175f27849093" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#pragma scalar_storage_order little-endian&lt;/code&gt; sets the storage order of the scalar fields to little-endian.</source>
          <target state="translated">&lt;code&gt;#pragma scalar_storage_order little-endian&lt;/code&gt; 은 스칼라 필드의 저장 순서를 little-endian으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="d7b3947b00665c0273f8ee03de6b46c48b82e923" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;+load&lt;/code&gt; is to be used only as a last resort. Because it is executed very early, most of the Objective-C runtime machinery will not be ready when &lt;code&gt;+load&lt;/code&gt; is executed; hence &lt;code&gt;+load&lt;/code&gt; works best for executing C code that is independent on the Objective-C runtime.</source>
          <target state="translated">&lt;code&gt;+load&lt;/code&gt; 는 최후의 수단으로 만 사용됩니다. 매우 일찍 실행되므로 &lt;code&gt;+load&lt;/code&gt; 가 실행될 때 대부분의 Objective-C 런타임 기계는 준비되지 않습니다 . 따라서 &lt;code&gt;+load&lt;/code&gt; 는 Objective-C 런타임과 독립적 인 C 코드를 실행하는 데 가장 적합합니다.</target>
        </trans-unit>
        <trans-unit id="2a3b66c50c6331da3456637374283bba0d9341b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-2147483648&lt;/code&gt; is positive.</source>
          <target state="translated">&lt;code&gt;-2147483648&lt;/code&gt; 이 긍정적입니다.</target>
        </trans-unit>
        <trans-unit id="ff73f3bc9136cfe683f6e1000d6ea1e5f0b6d324" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;0xFF&lt;/code&gt; or &lt;code&gt;0xFFFF&lt;/code&gt;, for andsi as a zero-extending move.</source>
          <target state="translated">&lt;code&gt;0xFF&lt;/code&gt; 0x 확장 이동으로 andsi의 경우 0xFF 또는 &lt;code&gt;0xFFFF&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="69970b695b65687a239461624104cc1d44b36e13" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;100&lt;/code&gt;, &lt;code&gt;102&lt;/code&gt;, &lt;code&gt;103&lt;/code&gt;, &lt;code&gt;104&lt;/code&gt;, &lt;code&gt;105&lt;/code&gt;, &lt;code&gt;106&lt;/code&gt;, &lt;code&gt;107&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;100&lt;/code&gt; , &lt;code&gt;102&lt;/code&gt; , &lt;code&gt;103&lt;/code&gt; , &lt;code&gt;104&lt;/code&gt; , &lt;code&gt;105&lt;/code&gt; , &lt;code&gt;106&lt;/code&gt; , &lt;code&gt;107&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f94cae98ac3d64f04d19f0b2e99e2c0a60564f25" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;2&lt;/code&gt;, &lt;code&gt;25&lt;/code&gt;, &lt;code&gt;3&lt;/code&gt;, &lt;code&gt;31&lt;/code&gt;, &lt;code&gt;35&lt;/code&gt;, &lt;code&gt;4&lt;/code&gt;, &lt;code&gt;5&lt;/code&gt;, &lt;code&gt;51&lt;/code&gt;, &lt;code&gt;6&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;2&lt;/code&gt; , &lt;code&gt;25&lt;/code&gt; , &lt;code&gt;3&lt;/code&gt; , &lt;code&gt;31&lt;/code&gt; , &lt;code&gt;35&lt;/code&gt; , &lt;code&gt;4&lt;/code&gt; , &lt;code&gt;5&lt;/code&gt; , &lt;code&gt;51&lt;/code&gt; , &lt;code&gt;6&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1bd49a42c06dc5b5614602b595d1eb861097847b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;var&gt;collection expression&lt;/var&gt;&lt;/code&gt; is evaluated exactly once and the result is used as the collection object to iterate over. This means it is safe to write code such as &lt;code&gt;for (object in [NSDictionary
keyEnumerator]) &amp;hellip;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;collection expression&lt;/var&gt;&lt;/code&gt; 은 정확히 한 번 평가되며 결과는 반복 할 콜렉션 오브젝트로 사용됩니다. 이 의미는 같은 코드를 작성하는 것이 안전 &lt;code&gt;for (object in [NSDictionary keyEnumerator]) &amp;hellip;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3eba358d191709438321ae5dbb3501eb47389e2e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;var&gt;statements&lt;/var&gt;&lt;/code&gt; can contain &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; commands, which will abort the iteration or skip to the next loop iteration as expected.</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;statements&lt;/var&gt;&lt;/code&gt; 은 &lt;code&gt;break&lt;/code&gt; 및 &lt;code&gt;continue&lt;/code&gt; 명령을포함 할 수 있으며,이 명령은 반복을 중단하거나 다음 루프 반복으로 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="61531b33eb2db1449ceab15f5f279c4b2f1791b6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;var&gt;statements&lt;/var&gt;&lt;/code&gt; must not make any changes to the collection object; if they do, it is a hard error and the fast enumeration terminates by invoking &lt;code&gt;objc_enumerationMutation&lt;/code&gt;, a runtime function that normally aborts the program but which can be customized by Foundation libraries via &lt;code&gt;objc_set_mutation_handler&lt;/code&gt; to do something different, such as raising an exception.</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;statements&lt;/var&gt;&lt;/code&gt; 은 콜렉션 오브젝트를 변경해서는 안됩니다. 만약 그렇다면, 그것은 하드 오류이고 빠른 열거는 일반적으로 프로그램을 중단하지만 &lt;code&gt;objc_set_mutation_handler&lt;/code&gt; 를통해 Foundation 라이브러리가 사용자 정의하여 예외 발생과 같은 다른 작업을 수행할 수있는 런타임 함수 인 &lt;code&gt;objc_enumerationMutation&lt;/code&gt; 을 호출하여 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="9d58742173ee42448629f6db4422e3203e474e70" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@encode&lt;/code&gt; does not support type qualifiers other than &lt;code&gt;const&lt;/code&gt;. For example, &lt;code&gt;@encode(const char*)&lt;/code&gt; is valid and is compiled into &lt;code&gt;&quot;r*&quot;&lt;/code&gt;, while &lt;code&gt;@encode(bycopy char *)&lt;/code&gt; is invalid and will cause a compilation error.</source>
          <target state="translated">&lt;code&gt;@encode&lt;/code&gt; 는 &lt;code&gt;const&lt;/code&gt; 이외의 형식 한정자를 지원하지 않습니다 . 예를 들어 &lt;code&gt;@encode(const char*)&lt;/code&gt; 는 유효하고 &lt;code&gt;&quot;r*&quot;&lt;/code&gt; 로 컴파일되는 반면 &lt;code&gt;@encode(bycopy char *)&lt;/code&gt; 는 유효하지 않으며 컴파일 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="06f7d071955d8af36c31b170590dbc2a8f025b17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;A&lt;/code&gt; through &lt;code&gt;L&lt;/code&gt; registers.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 부터 &lt;code&gt;L&lt;/code&gt; 까지 레지스터.</target>
        </trans-unit>
        <trans-unit id="80d0c9344feef2e94b4f1747dfadf5bbe5585ef0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CPATH&lt;/code&gt; specifies a list of directories to be searched as if specified with</source>
          <target state="translated">&lt;code&gt;CPATH&lt;/code&gt; 는 다음과 같이 지정된 것처럼 검색 할 디렉토리 목록을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="789e53d1b037b549885585694fb4b6c06a41dc94" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;GSWApplication&lt;/code&gt; (the real class) must be an existing class.</source>
          <target state="translated">&lt;code&gt;GSWApplication&lt;/code&gt; (실제 클래스)은 기존 클래스 여야합니다.</target>
        </trans-unit>
        <trans-unit id="372485e67dabbb2f6f7563c915c0d05a5bb7796c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NXConstantString&lt;/code&gt; inherits from &lt;code&gt;Object&lt;/code&gt;; user class libraries may choose to inherit the customized constant string class from a different class than &lt;code&gt;Object&lt;/code&gt;. There is no requirement in the methods the constant string class has to implement, but the final ivar layout of the class must be the compatible with the given structure.</source>
          <target state="translated">&lt;code&gt;NXConstantString&lt;/code&gt; 은 &lt;code&gt;Object&lt;/code&gt; 에서 상속합니다 . 사용자 클래스 라이브러리는 &lt;code&gt;Object&lt;/code&gt; 와 다른 클래스에서 사용자 정의 된 상수 문자열 클래스를 상속하도록 선택할 수 있습니다 . 상수 문자열 클래스가 구현해야하는 메소드에는 요구 사항이 없지만 클래스의 최종 ivar 레이아웃은 주어진 구조와 호환 가능해야합니다.</target>
        </trans-unit>
        <trans-unit id="b73742c69a964b14887fe5c58b748cbc6ead8dbc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;V&lt;/code&gt; is a special modifier which prints the name of the full integer register without &lt;code&gt;%&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;V&lt;/code&gt; 는 &lt;code&gt;%&lt;/code&gt; 없이 전체 정수 레지스터의 이름을 인쇄하는 특수 수정 자입니다 .</target>
        </trans-unit>
        <trans-unit id="e9680743302272f4d21a0ca0fcf6f7d2fc4b4f89" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WOApplication&lt;/code&gt; (the alias) must not be an existing class;</source>
          <target state="translated">&lt;code&gt;WOApplication&lt;/code&gt; (별명)은 기존 클래스가 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="ee6195175737171e4b0021bc7dc79c772162ab99" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__FUNCTION__&lt;/code&gt; is another name for &lt;code&gt;__func__&lt;/code&gt;, provided for backward compatibility with old versions of GCC.</source>
          <target state="translated">&lt;code&gt;__FUNCTION__&lt;/code&gt; 은 &lt;code&gt;__func__&lt;/code&gt; 의 다른 이름으로 , 이전 버전의 GCC와 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="f2c1ea03a8f41c269c203f97859a30953067ac6d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__attribute ((const))&lt;/code&gt; and &lt;code&gt;noreturn&lt;/code&gt; were mangled as type qualifiers, and &lt;code&gt;decltype&lt;/code&gt; of a plain declaration was folded away.</source>
          <target state="translated">&lt;code&gt;__attribute ((const))&lt;/code&gt; 와 &lt;code&gt;noreturn&lt;/code&gt; 은 형식 한정자로 맹 글링되었고 일반 선언의 설명은 &lt;code&gt;decltype&lt;/code&gt; 되었습니다.</target>
        </trans-unit>
        <trans-unit id="31d52aa69bfef9deeeff9d7920e4c48f0f233481" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__builtin_mips_set_fcsr&lt;/code&gt; can be used to change any bit of the register except the condition codes, which GCC assumes are preserved.</source>
          <target state="translated">&lt;code&gt;__builtin_mips_set_fcsr&lt;/code&gt; 은 GCC가 보존한다고 가정하는 조건 코드를 제외하고 레지스터의 비트를 변경하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd0179ef987e379ce17d15225812657b396c054c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__const__&lt;/code&gt;, &lt;code&gt;__asm__&lt;/code&gt;, etc., for header files.</source>
          <target state="translated">&lt;code&gt;__const__&lt;/code&gt; 헤더 파일의 경우 __const__ , &lt;code&gt;__asm__&lt;/code&gt; 등</target>
        </trans-unit>
        <trans-unit id="7473df93d6fe52ceeeb6718adea22f662c95bc6a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__float128&lt;/code&gt; is available on i386, x86_64, IA-64, and hppa HP-UX, as well as on PowerPC GNU/Linux targets that enable the vector scalar (VSX) instruction set. &lt;code&gt;__float128&lt;/code&gt; supports the 128-bit floating type. On i386, x86_64, PowerPC, and IA-64 other than HP-UX, &lt;code&gt;__float128&lt;/code&gt; is an alias for &lt;code&gt;_Float128&lt;/code&gt;. On hppa and IA-64 HP-UX, &lt;code&gt;__float128&lt;/code&gt; is an alias for &lt;code&gt;long
double&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;__float128&lt;/code&gt; 은 i386, x86_64, IA-64 및 hppa HP-UX와 벡터 스칼라 (VSX) 명령어 세트를 활성화하는 PowerPC GNU / Linux 대상에서 사용할 수 있습니다. &lt;code&gt;__float128&lt;/code&gt; 은 128 비트 부동 유형을 지원합니다. I386에서 x86_64에는 HP-UX 이외의 파워 및 IA-64, &lt;code&gt;__float128&lt;/code&gt; 의 별칭입니다 &lt;code&gt;_Float128&lt;/code&gt; . hppa 및 IA-64 HP-UX에서 &lt;code&gt;__float128&lt;/code&gt; 은 &lt;code&gt;long double&lt;/code&gt; 의 별칭입니다 .</target>
        </trans-unit>
        <trans-unit id="ffb2bf9a670bef293cfa77a116c8f843376e5401" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__float80&lt;/code&gt; is available on the i386, x86_64, and IA-64 targets, and supports the 80-bit (&lt;code&gt;XFmode&lt;/code&gt;) floating type. It is an alias for the type name &lt;code&gt;_Float64x&lt;/code&gt; on these targets.</source>
          <target state="translated">&lt;code&gt;__float80&lt;/code&gt; 은 i386, x86_64 및 IA-64 대상에서 사용 가능하며 80 비트 ( &lt;code&gt;XFmode&lt;/code&gt; ) 부동 유형을 지원합니다. 이 대상 에서 유형 이름 &lt;code&gt;_Float64x&lt;/code&gt; 의 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="7ec6ed15db3de1e0e785dbadf3953c59dadef3f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__ibm128&lt;/code&gt; is available on PowerPC targets, and provides access to the IBM extended double format which is the current format used for &lt;code&gt;long double&lt;/code&gt;. When &lt;code&gt;long double&lt;/code&gt; transitions to &lt;code&gt;__float128&lt;/code&gt; on PowerPC in the future, &lt;code&gt;__ibm128&lt;/code&gt; will remain for use in conversions between the two types.</source>
          <target state="translated">&lt;code&gt;__ibm128&lt;/code&gt; 은 PowerPC 대상에서 사용 가능하며 &lt;code&gt;long double&lt;/code&gt; 에 사용되는 현재 형식 인 IBM 확장 이중 형식에 대한 액세스를 제공합니다 . 때 &lt;code&gt;long double&lt;/code&gt; 로 전환 &lt;code&gt;__float128&lt;/code&gt; 미래의 파워에이 &lt;code&gt;__ibm128&lt;/code&gt; 는 두 가지 유형 사이의 변환에 사용하기 위해 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="9e3a9ed7baa3bf65df3ff05f513613983a9587ab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;acc&lt;/code&gt; arguments are evaluated at compile time and specify the number of an accumulator register. For example, an &lt;code&gt;acc&lt;/code&gt; argument of 2 selects the ACC2 register.</source>
          <target state="translated">&lt;code&gt;acc&lt;/code&gt; 인수는 컴파일 타임에 평가되며 누산기 레지스터의 수를 지정합니다. 예를 들어, &lt;code&gt;acc&lt;/code&gt; 인수가 2이면 ACC2 레지스터가 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="15fdbd93cf947c8849cb1d5a35f4090a626ff637" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;array&lt;/code&gt; needs to be an Objective-C object (usually a collection object, for example an array, a dictionary or a set) which implements the &amp;ldquo;Fast Enumeration Protocol&amp;rdquo; (see below). If you are using a Foundation library such as GNUstep Base or Apple Cocoa Foundation, all collection objects in the library implement this protocol and can be used in this way.</source>
          <target state="translated">&lt;code&gt;array&lt;/code&gt; 는 &quot;Fast Enumeration Protocol&quot;(아래 참조)을 구현하는 Objective-C 객체 (일반적으로 컬렉션 객체, 예를 들어 어레이, 사전 또는 세트) 여야합니다. GNUstep Base 또는 Apple Cocoa Foundation과 같은 Foundation 라이브러리를 사용하는 경우 라이브러리의 모든 컬렉션 객체가이 프로토콜을 구현하므로 이러한 방식으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="426e3d34f5d2b8cc641dc2d655c2412b3ba31507" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;asm goto&lt;/code&gt; allows assembly code to jump to one or more C labels. The &lt;var&gt;GotoLabels&lt;/var&gt; section in an &lt;code&gt;asm goto&lt;/code&gt; statement contains a comma-separated list of all C labels to which the assembler code may jump. GCC assumes that &lt;code&gt;asm&lt;/code&gt; execution falls through to the next statement (if this is not the case, consider using the &lt;code&gt;__builtin_unreachable&lt;/code&gt; intrinsic after the &lt;code&gt;asm&lt;/code&gt; statement). Optimization of &lt;code&gt;asm goto&lt;/code&gt; may be improved by using the &lt;code&gt;hot&lt;/code&gt; and &lt;code&gt;cold&lt;/code&gt; label attributes (see &lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;Label Attributes&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;asm goto&lt;/code&gt; 를 사용하면 어셈블리 코드가 하나 이상의 C 레이블로 이동할 수 있습니다. &lt;var&gt;GotoLabels&lt;/var&gt; 의 섹션 &lt;code&gt;asm goto&lt;/code&gt; 문은 어셈블러 코드가 점프 할 수있는 모든 C 라벨의 쉼표로 구분 된 목록이 포함되어 있습니다. GCC는 &lt;code&gt;asm&lt;/code&gt; 실행이 다음 명령문으로 넘어 간다고 가정합니다 (이 경우가 아니면 &lt;code&gt;asm&lt;/code&gt; 명령문 뒤에 &lt;code&gt;__builtin_unreachable&lt;/code&gt; 내장 함수 사용을 고려하십시오 ). 최적화 &lt;code&gt;asm goto&lt;/code&gt; 사용하여 개선 될 수있다 &lt;code&gt;hot&lt;/code&gt; 및 &lt;code&gt;cold&lt;/code&gt; 라벨 속성 (참조 &lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;레이블 속성&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="c9823fe22f97e1ec190b250dc2a2fdf94a1ee857" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;asm&lt;/code&gt; statements may not perform jumps into other &lt;code&gt;asm&lt;/code&gt; statements, only to the listed &lt;var&gt;GotoLabels&lt;/var&gt;. GCC&amp;rsquo;s optimizers do not know about other jumps; therefore they cannot take account of them when deciding how to optimize.</source>
          <target state="translated">&lt;code&gt;asm&lt;/code&gt; 문은 다른 &lt;code&gt;asm&lt;/code&gt; 문 으로 점프하지 않고 나열된 &lt;var&gt;GotoLabels&lt;/var&gt; 로만 점프 할 수 있습니다 . GCC의 옵티마이 저는 다른 점프에 대해 모른다. 따라서 최적화 방법을 결정할 때이를 고려할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="62977bb50d3c5a19ea5904a3a299ffd7ea5dbd29" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;asm&lt;/code&gt; statements may not perform jumps into other &lt;code&gt;asm&lt;/code&gt; statements. GCC does not know about these jumps, and therefore cannot take account of them when deciding how to optimize. Jumps from &lt;code&gt;asm&lt;/code&gt; to C labels are only supported in extended &lt;code&gt;asm&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;asm&lt;/code&gt; 문은 다른 &lt;code&gt;asm&lt;/code&gt; 문 으로 점프하지 않을 수 있습니다 . GCC는 이러한 점프에 대해 알지 못하므로 최적화 방법을 결정할 때 이러한 점프를 고려할 수 없습니다. &lt;code&gt;asm&lt;/code&gt; 에서 C 레이블로의 점프 는 확장 된 &lt;code&gt;asm&lt;/code&gt; 에서만 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="c9448d646265094e46fad56b4a1ad54b2c75f890" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;asm&lt;/code&gt; supports operand modifiers on operands (for example &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;asm&lt;/code&gt; 은 피연산자에서 피연산자 수정자를 지원합니다 (예 : '</target>
        </trans-unit>
        <trans-unit id="47c475345b4b6683f86ef0bd1304fa403571227e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b&lt;/code&gt; followed by the starting position of the bit-field, the type of the bit-field and the size of the bit-field (the bit-fields encoding was changed from the NeXT&amp;rsquo;s compiler encoding, see below)</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; 다음에는 비트 필드의 시작 위치, 비트 필드의 유형 및 비트 필드의 크기가 이어집니다 (비트 필드 인코딩은 NeXT의 컴파일러 인코딩에서 변경되었습니다 (아래 참조)).</target>
        </trans-unit>
        <trans-unit id="fd931d3282f78cf10b6e109fc3d87523a40b1c70" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const int*&lt;/code&gt; is a pointer to a &lt;code&gt;const int&lt;/code&gt;, and so is encoded as &lt;code&gt;^ri&lt;/code&gt;. &lt;code&gt;int* const&lt;/code&gt;, instead, is a &lt;code&gt;const&lt;/code&gt; pointer to an &lt;code&gt;int&lt;/code&gt;, and so is encoded as &lt;code&gt;r^i&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;const int*&lt;/code&gt; (A)에 대한 포인터이다 &lt;code&gt;const int&lt;/code&gt; 등으로 인코딩되어 &lt;code&gt;^ri&lt;/code&gt; . 대신 &lt;code&gt;int* const&lt;/code&gt; 는 &lt;code&gt;int&lt;/code&gt; 에 대한 &lt;code&gt;const&lt;/code&gt; 포인터 이므로 &lt;code&gt;r^i&lt;/code&gt; 로 인코딩됩니다 .</target>
        </trans-unit>
        <trans-unit id="8cc303077f2d42536c4b3baafc5729fd35626b25" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; arguments represent immediate operands in the underlying FR-V instructions. They must be compile-time constants.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 인수는 기본 FR-V 명령어에서 즉시 피연산자를 나타냅니다. 컴파일 타임 상수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="deb6088d1e3cb9956bb32715c4b9b0433c0fb80e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;decltype(nullptr)&lt;/code&gt; incorrectly had an alignment of 1, leading to unaligned accesses. Note that this did not affect the ABI of a function with a &lt;code&gt;nullptr_t&lt;/code&gt; parameter, as parameters have a minimum alignment.</source>
          <target state="translated">&lt;code&gt;decltype(nullptr)&lt;/code&gt; 의 정렬이 1이 잘못되어 정렬되지 않은 액세스가 발생했습니다. 매개 변수가 최소 정렬을 갖기 때문에 이는 &lt;code&gt;nullptr_t&lt;/code&gt; 매개 변수 가있는 함수의 ABI에 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="13371da4b8a0998cda9c846517eca9aac42602d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enum foo;&lt;/code&gt;, with details to follow.</source>
          <target state="translated">&lt;code&gt;enum foo;&lt;/code&gt; 자세한 내용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9e91e48e9653d7d4d932a05bfbd83b09588c7939" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enum&lt;/code&gt;s are always encoded as &amp;rsquo;i&amp;rsquo; (int) even if they are actually unsigned or long.</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; 은 실제로 부호가 없거나 길더라도 항상 'i'(int)로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="9a12395e61d19efb5c294812d6196468603d44b6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extern&lt;/code&gt; declarations are not affected by</source>
          <target state="translated">&lt;code&gt;extern&lt;/code&gt; 선언은 영향을받지 않습니다</target>
        </trans-unit>
        <trans-unit id="4b6de559d80875c4a2043040ec9b3a928c196dad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;float&lt;/code&gt; for return type and parameter type</source>
          <target state="translated">&lt;code&gt;float&lt;/code&gt; 리턴 유형 및 매개 변수 유형의 경우 float</target>
        </trans-unit>
        <trans-unit id="43f52ce2765906e82519d10c80ebb890c471c9d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcc&lt;/code&gt; is a driver program. It performs its job by invoking a sequence of other programs to do the work of compiling, assembling and linking. GCC interprets its command-line parameters and uses these to deduce which programs it should invoke, and which command-line options it ought to place on their command lines. This behavior is controlled by &lt;em&gt;spec strings&lt;/em&gt;. In most cases there is one spec string for each program that GCC can invoke, but a few programs have multiple spec strings to control their behavior. The spec strings built into GCC can be overridden by using the</source>
          <target state="translated">&lt;code&gt;gcc&lt;/code&gt; 는 드라이버 프로그램입니다. 컴파일, 어셈블 및 링크 작업을 수행하기 위해 다른 프로그램 시퀀스를 호출하여 작업을 수행합니다. GCC는 명령 줄 매개 변수를 해석하고이를 사용하여 호출 할 프로그램과 명령 줄에 배치 할 명령 줄 옵션을 추론합니다. 이 동작은 &lt;em&gt;사양 문자열에&lt;/em&gt; 의해 제어됩니다 . 대부분의 경우 GCC가 호출 할 수있는 각 프로그램마다 하나의 사양 문자열이 있지만 일부 프로그램에는 동작을 제어하기위한 여러 사양 문자열이 있습니다. GCC에 내장 된 사양 문자열은</target>
        </trans-unit>
        <trans-unit id="78e0e9f2c419ee9f240f0845bc755717d55d3a97" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov-dump&lt;/code&gt; accepts the following options:</source>
          <target state="translated">&lt;code&gt;gcov-dump&lt;/code&gt; 는 다음 옵션을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="57d6fe4b10a5a2126cbfcec6595777a79798d69e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov-dump&lt;/code&gt; is a tool you can use in conjunction with GCC to dump content of gcda and gcno profile files offline.</source>
          <target state="translated">&lt;code&gt;gcov-dump&lt;/code&gt; 는 gcda 및 gcno 프로필 파일의 내용을 오프라인으로 덤프하기 위해 GCC와 함께 사용할 수있는 도구입니다.</target>
        </trans-unit>
        <trans-unit id="2878b99530b4f0ab8508c0886d2f8099475e075b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov-dump&lt;/code&gt;&amp;mdash;an offline gcda and gcno profile dump tool.</source>
          <target state="translated">&lt;code&gt;gcov-dump&lt;/code&gt; &amp;mdash; 오프라인 gcda 및 gcno 프로파일 덤프 도구입니다.</target>
        </trans-unit>
        <trans-unit id="8557e16ee11b3bb8a6161e3b196a98d4d9ef3676" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov-tool&lt;/code&gt; accepts the following options:</source>
          <target state="translated">&lt;code&gt;gcov-tool&lt;/code&gt; 은 다음 옵션을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="834e3a72a863342de668198a9b180e31689bb9fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov-tool&lt;/code&gt; is a tool you can use in conjunction with GCC to manipulate or process gcda profile files offline.</source>
          <target state="translated">&lt;code&gt;gcov-tool&lt;/code&gt; 은 GCC와 함께 gcda 프로필 파일을 오프라인으로 조작하거나 처리하는 데 사용할 수있는 도구입니다.</target>
        </trans-unit>
        <trans-unit id="8966e78c51b409536bc0ea171add9c067eaae6cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov-tool&lt;/code&gt; is an offline tool to process gcc&amp;rsquo;s gcda profile files.</source>
          <target state="translated">&lt;code&gt;gcov-tool&lt;/code&gt; 은 gcc의 gcda 프로파일 파일을 처리하는 오프라인 도구입니다.</target>
        </trans-unit>
        <trans-unit id="70183d08ebe3785a624a3a0d2f54f5da4fcf92c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov-tool&lt;/code&gt;&amp;mdash;an offline gcda profile processing program.</source>
          <target state="translated">&lt;code&gt;gcov-tool&lt;/code&gt; &amp;mdash; 오프라인 gcda 프로파일 처리 프로그램.</target>
        </trans-unit>
        <trans-unit id="432fd55f9f3348b69e564e9e68b9ac68338b2330" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov&lt;/code&gt; accepts the following options:</source>
          <target state="translated">&lt;code&gt;gcov&lt;/code&gt; 는 다음 옵션을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="ef7fa5c92c81ba37950cfb7081e034b38df44ee1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov&lt;/code&gt; creates a logfile called</source>
          <target state="translated">&lt;code&gt;gcov&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="fa86b3b9c4851aca0143ed5eebf12b37ac982caa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov&lt;/code&gt; is a test coverage program. Use it in concert with GCC to analyze your programs to help create more efficient, faster running code and to discover untested parts of your program. You can use &lt;code&gt;gcov&lt;/code&gt; as a profiling tool to help discover where your optimization efforts will best affect your code. You can also use &lt;code&gt;gcov&lt;/code&gt; along with the other profiling tool, &lt;code&gt;gprof&lt;/code&gt;, to assess which parts of your code use the greatest amount of computing time.</source>
          <target state="translated">&lt;code&gt;gcov&lt;/code&gt; 는 테스트 범위 프로그램입니다. GCC와 함께 사용하면 프로그램을 분석하여보다 효율적이고 빠르게 실행되는 코드를 작성하고 테스트되지 않은 프로그램 부분을 발견 할 수 있습니다. &lt;code&gt;gcov&lt;/code&gt; 를 프로파일 링 도구로 사용 하여 최적화 노력이 코드에 가장 영향을 미치는 위치를 찾을 수 있습니다. 당신은 또한 사용할 수 있습니다 &lt;code&gt;gcov&lt;/code&gt; 의를 다른 프로파일 링 도구와 함께 &lt;code&gt;gprof&lt;/code&gt; 은 코드의 어느 부분이 계산 시간의 가장 많은 양을 사용하는 평가.</target>
        </trans-unit>
        <trans-unit id="ec4c7d87db361b8b7217252e79155f330d87180c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov&lt;/code&gt; is a tool you can use in conjunction with GCC to test code coverage in your programs.</source>
          <target state="translated">&lt;code&gt;gcov&lt;/code&gt; 는 GCC와 함께 사용하여 프로그램에서 코드 적용 범위를 테스트 할 수있는 도구입니다.</target>
        </trans-unit>
        <trans-unit id="74c1eaafeae6a0c3622569a9b97608b21c035122" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov&lt;/code&gt; should be run with the current directory the same as that when you invoked the compiler. Otherwise it will not be able to locate the source files. &lt;code&gt;gcov&lt;/code&gt; produces files called</source>
          <target state="translated">&lt;code&gt;gcov&lt;/code&gt; 는 컴파일러를 호출 할 때와 동일하게 현재 디렉토리에서 실행되어야합니다. 그렇지 않으면 소스 파일을 찾을 수 없습니다. &lt;code&gt;gcov&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="54f992c071dcdc4cf317b5dc2c2e8150dab3baed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov&lt;/code&gt; uses two files for profiling. The names of these files are derived from the original &lt;em&gt;object&lt;/em&gt; file by substituting the file suffix with either</source>
          <target state="translated">&lt;code&gt;gcov&lt;/code&gt; 는 프로파일 링을 위해 두 개의 파일을 사용 합니다. 이러한 파일의 이름은 파일 접미사를 다음과 같이 대체하여 원래 &lt;em&gt;객체&lt;/em&gt; 파일 에서 파생 됩니다.</target>
        </trans-unit>
        <trans-unit id="e0e281a8c455e080b9c9615f521b0af9f3afc81d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov&lt;/code&gt; works only on code compiled with GCC. It is not compatible with any other profiling or test coverage mechanism.</source>
          <target state="translated">&lt;code&gt;gcov&lt;/code&gt; 는 GCC로 컴파일 된 코드에서만 작동합니다. 다른 프로파일 링 또는 테스트 범위 메커니즘과 호환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e18b2104276bf04773cc9483f7f381c6d995630f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcov&lt;/code&gt;&amp;mdash;a test coverage program.</source>
          <target state="translated">&lt;code&gt;gcov&lt;/code&gt; &amp;mdash; 테스트 범위 프로그램.</target>
        </trans-unit>
        <trans-unit id="0adbd472f7e4a6a8700ee625ca50b5065e7189f2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;i32, i64, u32, u64, f32, f64&lt;/code&gt;, defined as follows:</source>
          <target state="translated">&lt;code&gt;i32, i64, u32, u64, f32, f64&lt;/code&gt; 는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="c651bda5c1e10d455f6b6c7f62a6f71255f9e521" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iacc&lt;/code&gt; arguments are similar to &lt;code&gt;acc&lt;/code&gt; arguments but specify the number of an IACC register. See see &lt;a href=&quot;other-built_002din-functions#Other-Built_002din-Functions&quot;&gt;Other Built-in Functions&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;iacc&lt;/code&gt; 인수는 &lt;code&gt;acc&lt;/code&gt; 인수 와 유사 하지만 IACC 레지스터의 수를 지정하십시오. 자세한 내용은 &lt;a href=&quot;other-built_002din-functions#Other-Built_002din-Functions&quot;&gt;기타 내장 기능&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bf79502e7b46209589262e2429120814cbb13c52" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;imm0_15&lt;/code&gt;, an integer literal in range 0 to 15;</source>
          <target state="translated">&lt;code&gt;imm0_15&lt;/code&gt; , 0 ~ 15 범위의 정수 리터럴;</target>
        </trans-unit>
        <trans-unit id="ccc2033cd80d019d5fd83cb192150729b7904cf6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;imm0_1&lt;/code&gt;, an integer literal in range 0 to 1;</source>
          <target state="translated">&lt;code&gt;imm0_1&lt;/code&gt; , 0에서 1 사이의 정수 리터럴;</target>
        </trans-unit>
        <trans-unit id="f624a59ec5d313a1c0a203fc5cdfd4a3666bdad5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;imm0_255&lt;/code&gt;, an integer literal in range 0 to 255;</source>
          <target state="translated">&lt;code&gt;imm0_255&lt;/code&gt; , 0 ~ 255 범위의 정수 리터럴;</target>
        </trans-unit>
        <trans-unit id="45c72131be83eef97ea9ee3eff2a0bdba7519f47" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;imm0_31&lt;/code&gt;, an integer literal in range 0 to 31;</source>
          <target state="translated">&lt;code&gt;imm0_31&lt;/code&gt; , 0 ~ 31 범위의 정수 리터럴;</target>
        </trans-unit>
        <trans-unit id="cde4836239d0583916a4b3f7436c408e99e7f181" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;imm0_3&lt;/code&gt;, an integer literal in range 0 to 3;</source>
          <target state="translated">&lt;code&gt;imm0_3&lt;/code&gt; , 0 ~ 3 범위의 정수 리터럴;</target>
        </trans-unit>
        <trans-unit id="51e823a1bbc6ba2a324f7474f9da47e3b2690272" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;imm0_63&lt;/code&gt;, an integer literal in range 0 to 63;</source>
          <target state="translated">&lt;code&gt;imm0_63&lt;/code&gt; , 0-63 범위의 정수 리터럴;</target>
        </trans-unit>
        <trans-unit id="62f6834f1b1628360d13102cd8355d1bff98dfb5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;imm0_7&lt;/code&gt;, an integer literal in range 0 to 7;</source>
          <target state="translated">&lt;code&gt;imm0_7&lt;/code&gt; , 0 ~ 7 범위의 정수 리터럴;</target>
        </trans-unit>
        <trans-unit id="06869e0d4af1794473183f20d27a91d5c322515b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;imm1_4&lt;/code&gt;, an integer literal in range 1 to 4;</source>
          <target state="translated">&lt;code&gt;imm1_4&lt;/code&gt; , 1-4 범위의 정수 리터럴;</target>
        </trans-unit>
        <trans-unit id="26b8f3ccab339df690ac564365568e69734e0e95" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;imm_n1024_1022&lt;/code&gt;, an integer literal in range -512 to 511 left shifted by 1 bit, i.e., -1024, -1022, &amp;hellip;, 1020, 1022;</source>
          <target state="translated">&lt;code&gt;imm_n1024_1022&lt;/code&gt; , -512에서 511 범위의 정수 리터럴이 1 비트 왼쪽으로 시프트되었습니다. 즉, -1024, -1022,&amp;hellip;, 1020, 1022;</target>
        </trans-unit>
        <trans-unit id="53f347dd23c9ce86f4bf63425a73319aeca2e71a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;imm_n16_15&lt;/code&gt;, an integer literal in range -16 to 15;</source>
          <target state="translated">&lt;code&gt;imm_n16_15&lt;/code&gt; , -16에서 15 사이의 정수 리터럴;</target>
        </trans-unit>
        <trans-unit id="c764a9f154679364bdd3af401c15760d950c39d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;imm_n2048_2044&lt;/code&gt;, an integer literal in range -512 to 511 left shifted by 2 bits, i.e., -2048, -2044, &amp;hellip;, 2040, 2044;</source>
          <target state="translated">&lt;code&gt;imm_n2048_2044&lt;/code&gt; , -512 내지 511 범위의 정수 리터럴이 2 비트만큼 왼쪽으로 시프트 된, 즉 -2048, -2044,&amp;hellip;, 2040, 2044;</target>
        </trans-unit>
        <trans-unit id="d8621ae125b08b357812594db312fcdb8bd2e201" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;imm_n4096_4088&lt;/code&gt;, an integer literal in range -512 to 511 left shifted by 3 bits, i.e., -4096, -4088, &amp;hellip;, 4080, 4088;</source>
          <target state="translated">&lt;code&gt;imm_n4096_4088&lt;/code&gt; , -512에서 511 사이의 정수 리터럴은 3 비트만큼 왼쪽으로 시프트됩니다. 즉 -4096, -4088,&amp;hellip;, 4080, 4088;</target>
        </trans-unit>
        <trans-unit id="43bcd7d1a4a29ac9e7f1c73f1912ac48e5ce1624" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;imm_n512_511&lt;/code&gt;, an integer literal in range -512 to 511;</source>
          <target state="translated">&lt;code&gt;imm_n512_511&lt;/code&gt; -512에서 511 사이의 정수 리터럴 인 imm_n512_511 ;</target>
        </trans-unit>
        <trans-unit id="f04c7ff5dca47e97ec5511198b36d3aa9615e32d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int16x4_t&lt;/code&gt;, a vector of four signed 16-bit integers;</source>
          <target state="translated">&lt;code&gt;int16x4_t&lt;/code&gt; 4 개의 부호있는 16 비트 정수로 구성된 벡터 int16x4_t ;</target>
        </trans-unit>
        <trans-unit id="d63e9df03ecc48a8a23928c599b1004cd533f6d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int32x2_t&lt;/code&gt;, a vector of two signed 32-bit integers.</source>
          <target state="translated">&lt;code&gt;int32x2_t&lt;/code&gt; , 부호있는 두 개의 32 비트 정수로 구성된 벡터</target>
        </trans-unit>
        <trans-unit id="91184ef12147d2f6b1bdaa56fe5d9583a6f4e83a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int8x8_t&lt;/code&gt;, a vector of eight signed 8-bit integers;</source>
          <target state="translated">&lt;code&gt;int8x8_t&lt;/code&gt; 8 개의 부호있는 8 비트 정수의 벡터 인 int8x8_t ;</target>
        </trans-unit>
        <trans-unit id="9a7265111af471ce530480c106de4c972fb277fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int&lt;/code&gt; for return type and parameter type</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; 반환 유형 및 매개 변수 유형의 경우 int</target>
        </trans-unit>
        <trans-unit id="3e0d50378937884eeb028aecd3fcc684e4a49b74" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;j&lt;/code&gt; followed by the inner type. For example &lt;code&gt;_Complex double&lt;/code&gt; is encoded as &quot;jd&quot;.</source>
          <target state="translated">&lt;code&gt;j&lt;/code&gt; 다음에 내부 유형이옵니다. 예를 들어 &lt;code&gt;_Complex double&lt;/code&gt; 은 &quot;jd&quot;로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="0871af21d28c83f64c804091ade1492e9664c30b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lto-dump&lt;/code&gt; accepts the following options:</source>
          <target state="translated">&lt;code&gt;lto-dump&lt;/code&gt; accepts the following options:</target>
        </trans-unit>
        <trans-unit id="ea8422e33957287d90215f0f4f8087a0305f1d44" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lto-dump&lt;/code&gt; is a tool you can use in conjunction with GCC to dump link time optimization object files.</source>
          <target state="translated">&lt;code&gt;lto-dump&lt;/code&gt; is a tool you can use in conjunction with GCC to dump link time optimization object files.</target>
        </trans-unit>
        <trans-unit id="a51997ac3a8fdd69732aefc35a59335c494052e0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lto-dump&lt;/code&gt;&amp;mdash;Tool for dumping LTO object files.</source>
          <target state="translated">&lt;code&gt;lto-dump&lt;/code&gt; &amp;mdash;Tool for dumping LTO object files.</target>
        </trans-unit>
        <trans-unit id="2f711a37cb98098d461731b92b78a9d7c2b5ec6f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;movn.ps&lt;/code&gt;/&lt;code&gt;movz.ps&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;movn.ps&lt;/code&gt;/&lt;code&gt;movz.ps&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bb1626a9beed4fd0495f07220bec199cc6d6bd0a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;naked&lt;/code&gt; functions do not have a return instruction whereas &lt;code&gt;OS_main&lt;/code&gt; and &lt;code&gt;OS_task&lt;/code&gt; functions have a &lt;code&gt;RET&lt;/code&gt; or &lt;code&gt;RETI&lt;/code&gt; return instruction.</source>
          <target state="translated">&lt;code&gt;naked&lt;/code&gt; 함수에는 리턴 명령어가 &lt;code&gt;OS_main&lt;/code&gt; 및 &lt;code&gt;OS_task&lt;/code&gt; 함수에는 &lt;code&gt;RET&lt;/code&gt; 또는 &lt;code&gt;RETI&lt;/code&gt; 리턴 명령어가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f91f91e06fe6fe3ed6698c6a7170097cb9c11482" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;naked&lt;/code&gt; functions do not set up a frame for local variables or a frame pointer whereas &lt;code&gt;OS_main&lt;/code&gt; and &lt;code&gt;OS_task&lt;/code&gt; do this as needed.</source>
          <target state="translated">&lt;code&gt;naked&lt;/code&gt; 함수는 로컬 변수 또는 프레임 포인터에 대한 프레임을 설정하지 않지만 &lt;code&gt;OS_main&lt;/code&gt; 및 &lt;code&gt;OS_task&lt;/code&gt; 는 필요에 따라이를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="e1ec8966dbb2d024c34ce202400922786b20bf42" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;q31&lt;/code&gt; and &lt;code&gt;i32&lt;/code&gt; are actually the same as &lt;code&gt;int&lt;/code&gt;, but we use &lt;code&gt;q31&lt;/code&gt; to indicate a Q31 fractional value and &lt;code&gt;i32&lt;/code&gt; to indicate a 32-bit integer value. Similarly, &lt;code&gt;a64&lt;/code&gt; is the same as &lt;code&gt;long long&lt;/code&gt;, but we use &lt;code&gt;a64&lt;/code&gt; to indicate values that are placed in one of the four DSP accumulators (&lt;code&gt;$ac0&lt;/code&gt;, &lt;code&gt;$ac1&lt;/code&gt;, &lt;code&gt;$ac2&lt;/code&gt; or &lt;code&gt;$ac3&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;q31&lt;/code&gt; 과 &lt;code&gt;i32&lt;/code&gt; 는 실제로 &lt;code&gt;int&lt;/code&gt; 와 동일 하지만 우리는 &lt;code&gt;q31&lt;/code&gt; 을 사용 하여 Q31 분수 값 을 나타내고 &lt;code&gt;i32&lt;/code&gt; 는 32 비트 정수 값을 나타냅니다. 마찬가지로 &lt;code&gt;a64&lt;/code&gt; 는 &lt;code&gt;long long&lt;/code&gt; 과 동일 하지만 &lt;code&gt;a64&lt;/code&gt; 를 사용 하여 4 개의 DSP 누산기 중 하나 ( &lt;code&gt;$ac0&lt;/code&gt; , &lt;code&gt;$ac1&lt;/code&gt; , &lt;code&gt;$ac2&lt;/code&gt; 또는 &lt;code&gt;$ac3&lt;/code&gt; ) 에있는 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="ea0054c5fec474c155dbd98ae3adc8592ccc0ad9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;strict-align&lt;/code&gt; indicates that the compiler should not assume that unaligned memory references are handled by the system. To allow the compiler to assume that aligned memory references are handled by the system, the inverse attribute &lt;code&gt;no-strict-align&lt;/code&gt; can be specified. The behavior is same as for the command-line option</source>
          <target state="translated">&lt;code&gt;strict-align&lt;/code&gt; 은 컴파일러가 정렬되지 않은 메모리 참조가 시스템에 의해 처리된다고 가정해서는 안됨을 나타냅니다. 컴파일러가 정렬 된 메모리 참조를 시스템에서 처리한다고 가정 할 수 있도록 반대 속성 &lt;code&gt;no-strict-align&lt;/code&gt; 을 지정할 수 있습니다. 동작은 명령 행 옵션과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="0ce41d50092061190708b7c5fd578471925d484e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tbegin&lt;/code&gt; has been executed as part of normal processing. The transaction body is supposed to be executed.</source>
          <target state="translated">&lt;code&gt;tbegin&lt;/code&gt; 은 정상 처리의 일부로 실행되었습니다. 트랜잭션 본문이 실행되어야합니다.</target>
        </trans-unit>
        <trans-unit id="90a2359fdefeabe506da21e5ceeb1ec6dfb149dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type_info&lt;/code&gt; objects</source>
          <target state="translated">&lt;code&gt;type_info&lt;/code&gt; 객체</target>
        </trans-unit>
        <trans-unit id="972569711d57266ec65a8196096540c87f973793" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;typeof&lt;/code&gt; is often useful in conjunction with statement expressions (see &lt;a href=&quot;statement-exprs#Statement-Exprs&quot;&gt;Statement Exprs&lt;/a&gt;). Here is how the two together can be used to define a safe &amp;ldquo;maximum&amp;rdquo; macro which operates on any arithmetic type and evaluates each of its arguments exactly once:</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; 문장 표현과 함께 종종 유용하다 (참조 &lt;a href=&quot;statement-exprs#Statement-Exprs&quot;&gt;문 Exprs을&lt;/a&gt; ). 다음은 두 가지를 함께 사용하여 모든 산술 유형에서 작동하고 각 인수를 정확히 한 번만 평가하는 안전한 &quot;최대&quot;매크로를 정의하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="01dc66305ee017274a8f90b9afb7de83e8f46c89" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;typeof&lt;/code&gt;: referring to the type of an expression.</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; : 표현식의 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8c7b90f2794ef9994bb660999c0f322a942bf8f4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;uint16x4_t&lt;/code&gt;, a vector of four unsigned 16-bit integers;</source>
          <target state="translated">&lt;code&gt;uint16x4_t&lt;/code&gt; , 4 개의 부호없는 16 비트 정수로 구성된 벡터;</target>
        </trans-unit>
        <trans-unit id="b0558ac59824429cd7d9d4b1f36c21a2ee0fe3e7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;uint32x2_t&lt;/code&gt;, a vector of two unsigned 32-bit integers;</source>
          <target state="translated">&lt;code&gt;uint32x2_t&lt;/code&gt; , 부호없는 두 개의 32 비트 정수로 구성된 벡터.</target>
        </trans-unit>
        <trans-unit id="2d69c68962c47d62e79bf31389c4415c2f200ee4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;uint8x8_t&lt;/code&gt;, a vector of eight unsigned 8-bit integers;</source>
          <target state="translated">&lt;code&gt;uint8x8_t&lt;/code&gt; 8 개의 부호없는 8 비트 정수로 구성된 벡터 인 uint8x8_t ;</target>
        </trans-unit>
        <trans-unit id="dbb644e8ba42f8f623407a24fa989ae31fed8572" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;union U&lt;/code&gt; is always passed in memory.</source>
          <target state="translated">&lt;code&gt;union U&lt;/code&gt; 는 항상 메모리에 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="1db4672f93c338ff587750e17356ae256986573e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;union U&lt;/code&gt; is now always passed in memory.</source>
          <target state="translated">&lt;code&gt;union U&lt;/code&gt; is now always passed in memory.</target>
        </trans-unit>
        <trans-unit id="fadc8e6d5e8d31b3a291f79221d6f051c12b8821" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;v16i8&lt;/code&gt;, a vector of sixteen signed 8-bit integers;</source>
          <target state="translated">&lt;code&gt;v16i8&lt;/code&gt; 16 개의 부호있는 8 비트 정수로 구성된 벡터 v16i8 ;</target>
        </trans-unit>
        <trans-unit id="131a161af4f7e0b4ea5ae1747e0ea7514b0c83b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;v16u8&lt;/code&gt;, a vector of sixteen unsigned 8-bit integers;</source>
          <target state="translated">&lt;code&gt;v16u8&lt;/code&gt; 16 개의 부호없는 8 비트 정수로 구성된 벡터 v16u8 ;</target>
        </trans-unit>
        <trans-unit id="1b29406a43f217bd305e13cb54ba71e651d5bba2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;v2f64&lt;/code&gt;, a vector of two 64-bit doubles.</source>
          <target state="translated">&lt;code&gt;v2f64&lt;/code&gt; 두 개의 64 비트 복소수 로 구성된 벡터 인 v2f64</target>
        </trans-unit>
        <trans-unit id="7512973093e5491713fd6ebd5358156e9bc4a1dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;v2i64&lt;/code&gt;, a vector of two signed 64-bit integers;</source>
          <target state="translated">&lt;code&gt;v2i64&lt;/code&gt; 2 개의 부호있는 64 비트 정수로 구성된 벡터 인 v2i64 ;</target>
        </trans-unit>
        <trans-unit id="9db6b88b33ec3aa8ad125c2d46beb5f476bec0d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;v2sf&lt;/code&gt; values are initialized in the same way as aggregates. For example:</source>
          <target state="translated">&lt;code&gt;v2sf&lt;/code&gt; 값은 집계와 동일한 방식으로 초기화됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c3855d3df800b3ae2c45c123aa6cb8ce5e785ead" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;v2u64&lt;/code&gt;, a vector of two unsigned 64-bit integers;</source>
          <target state="translated">&lt;code&gt;v2u64&lt;/code&gt; - 부호없는 두 개의 64 비트 정수로 구성된 벡터입니다.</target>
        </trans-unit>
        <trans-unit id="6ad31881d9c216547f22d1f2a2db29238b4dc646" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;v4f32&lt;/code&gt;, a vector of four 32-bit floats;</source>
          <target state="translated">&lt;code&gt;v4f32&lt;/code&gt; 4 개의 32 비트 부동 소수점 벡터 인 v4f32 ;</target>
        </trans-unit>
        <trans-unit id="31c7877922fb039b6c0292daf271e4981078508f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;v4i32&lt;/code&gt;, a vector of four signed 32-bit integers;</source>
          <target state="translated">&lt;code&gt;v4i32&lt;/code&gt; 4 개의 부호있는 32 비트 정수로 구성된 벡터 인 v4i32 ;</target>
        </trans-unit>
        <trans-unit id="17a0ec2f60a3d3e13fba7b775b40060a5c47ab58" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;v4i8&lt;/code&gt;, &lt;code&gt;v4q7&lt;/code&gt;, &lt;code&gt;v2i16&lt;/code&gt; and &lt;code&gt;v2q15&lt;/code&gt; values are initialized in the same way as aggregates. For example:</source>
          <target state="translated">&lt;code&gt;v4i8&lt;/code&gt; , &lt;code&gt;v4q7&lt;/code&gt; , &lt;code&gt;v2i16&lt;/code&gt; 및 &lt;code&gt;v2q15&lt;/code&gt; 값은 집계와 동일한 방식으로 초기화됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6b9f0632a60f7e2199e33eae5df860d977b737c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;v4u32&lt;/code&gt;, a vector of four unsigned 32-bit integers;</source>
          <target state="translated">&lt;code&gt;v4u32&lt;/code&gt; , 4 개의 부호없는 32 비트 정수로 구성된 벡터;</target>
        </trans-unit>
        <trans-unit id="15eeca02c95cac6ccf4d38d5e71572806fbe59c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;v8i16&lt;/code&gt;, a vector of eight signed 16-bit integers;</source>
          <target state="translated">&lt;code&gt;v8i16&lt;/code&gt; 8 개의 부호있는 16 비트 정수로 구성된 벡터 인 v8i16 ;</target>
        </trans-unit>
        <trans-unit id="18c14a5e3dac281031739c8daafc626ba35c9efb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;v8u16&lt;/code&gt;, a vector of eight unsigned 16-bit integers;</source>
          <target state="translated">&lt;code&gt;v8u16&lt;/code&gt; 8 개의 부호없는 16 비트 정수로 구성된 벡터 v8u16 ;</target>
        </trans-unit>
        <trans-unit id="d6a4e5bb9ed4a03346a1e5335ca402c064f0fe3e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;void *&lt;/code&gt; for return type and parameter type</source>
          <target state="translated">&lt;code&gt;void *&lt;/code&gt; 반환 유형 및 매개 변수 유형의 경우 void *</target>
        </trans-unit>
        <trans-unit id="931138ba5a2507ee2e7e0fc42f85c661aad3ee17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;void&lt;/code&gt; for return type and no parameter for parameter types.</source>
          <target state="translated">&lt;code&gt;void&lt;/code&gt; 반환 유형에 대해서는 void 이며 매개 변수 유형에 대해서는 매개 변수가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5a5d5c4a2842d52363078341ffbf5ff1c71da9e6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;AArch64 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;AArch64 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6a14ea9b56847cb67e896fe9ed92e829c46db4c8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;AMD GCN Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;AMD GCN 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="867c24fe4dbfd5ccbf6133610e3056cd4490ebb2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;ARC Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;아크 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a804dffc1734b11346a4329fb8b712484dc062a9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;ARM Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;ARM 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="42007853e2d2e5ee57f43b159004f83209e6c120" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;AVR Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;AVR 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9aab5cdb90e0e7068aace684de244f8deb97788a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Adapteva Epiphany Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Adapteva 주현절 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ae87c6342c250828b19327bd7929eed321e39d53" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Blackfin Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;블랙 핀 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="77196484bdd6bd4585004c0d69f5afd921d39aeb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;C-SKY Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;C-SKY 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="be9ad0c2e9c89a60e3ec15f581550300b8820f0d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;C6X Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;C6X 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fd379f819a2900908cff60cb928d58f868b9db54" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;CR16 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;CR16 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cfc7c2eba72f3e5ff0469155a3c3406b2e006fe3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;CRIS Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;CRIS 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0bcedc624ee2d8bc0dc1dde9e3ffd94d702c3815" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;DEC Alpha Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;DEC 알파 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3c720ccb25061b11c148efb66e96f845b91fa6ad" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Darwin Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;다윈 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="95f44dfbf82d62481da460c42b5fb7c35274dcea" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Errors&lt;/em&gt; report problems that make it impossible to compile your program. GCC reports errors with the source file name and line number where the problem is apparent.</source>
          <target state="translated">&lt;em&gt;오류는&lt;/em&gt; 프로그램을 컴파일 할 수없는 문제를보고합니다. GCC는 문제가 명백한 소스 파일 이름과 줄 번호로 오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="089e6e509d8caabf29e30ec3bbbe964fc2afe250" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;FR30 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;FR30 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="091553d3f3e8974e90f05c57755746679c1fdd3a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;FRV Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;FRV 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="70b7d6e356f2d0708ee860d4fc3fd1c61ab2eed5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;FT32 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;FT32 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="98ffc4ee3ad54f42a4735dcc174d96d9c6c59ac5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;GNU/Linux Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;GNU / 리눅스 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0822ea35a43e7bcfdcf9fd3e546d607438735455" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;H8/300 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;H8 / 300 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fdf83e6772f30030bb2fc1476c4b6aba2fad8a80" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;HPPA Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;HPPA 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d5c413dcc96c0d8d85ccbfd5c8edb509e5cdc1c4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;IA-64 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;IA-64 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="72b634d41b068d05c153c5acbd927a150eda46f1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;LM32 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;LM32 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e939059a018e2d2ed5fcec7a81d238219702f1a6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;M32C Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;M32C 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="41423d489b98fe3519ae5cbb7b050e878b6bd6b0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;M32R/D Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;M32R / D 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3d6bc2eaf8866182e321b20849ed96413e122e84" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;M680x0 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;M680x0 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7869c6ee0bb9ef2d45291f35d9736bbbaaacc30a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;MCore Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;MCore 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f92ee1798eb5d8b5d7a11c3903d764ec6e437af6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;MIPS Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;MIPS 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6811edeb78aee90d2929700d84423144700748a5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;MMIX Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;MMIX 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1c6c421dea99cc933fb54d01b9291e1f3cc15403" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;MN10300 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;MN10300 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1ae829c80944d42f892c7e2fcafa7795e50814c5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;MSP430 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;MSP430 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="995202556b55cd172ec8bc628d585bb4f9d60357" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;MeP Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;MeP 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e6d8110270e3200546987d8ee1384e2734ad7589" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;MicroBlaze Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;MicroBlaze 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b56c00142a2adf77adfc3b717573e363224b9028" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Moxie Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;목시 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="56ac1cd6a6c4ddc7383020e1168c9487d3c77648" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;NDS32 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;NDS32 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0489603a8178bb1a03c11b5a827e58b0d976d54d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Nios II Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;니오스 II 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6a71b3dbe832df819e003067a1cc89679cd5065c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; Although the equivalent hardware instructions do not take an SIMD register as an operand, these builtins overwrite the relevant bits of the &lt;code&gt;__v8hi&lt;/code&gt; register provided as the first argument with the value loaded from the &lt;code&gt;[Ib, u8]&lt;/code&gt; location in the SDM.</source>
          <target state="translated">&lt;em&gt;참고 :&lt;/em&gt; 동등한 하드웨어 명령어는 SIMD 레지스터를 피연산자로 사용하지 않지만 이러한 내장 은 첫 번째 인수로 제공된 &lt;code&gt;__v8hi&lt;/code&gt; 레지스터 의 관련 비트를 SDM 의 &lt;code&gt;[Ib, u8]&lt;/code&gt; 위치에서 로드 된 값으로 덮어 씁니다 .</target>
        </trans-unit>
        <trans-unit id="906695ffc11fbd6c29f6a7c5fffdd87c61dd0062" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; GCC 4.4 and later implement &lt;code&gt;__sync_fetch_and_nand&lt;/code&gt; as &lt;code&gt;*ptr = ~(tmp &amp;amp; value)&lt;/code&gt; instead of &lt;code&gt;*ptr = ~tmp &amp;amp; value&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;참고 :&lt;/em&gt; GCC 4.4 &lt;code&gt;__sync_fetch_and_nand&lt;/code&gt; 에서는 __sync_fetch_and_nand 를 &lt;code&gt;*ptr = ~(tmp &amp;amp; value)&lt;/code&gt; 대신 * ptr = ~ (tmp &amp;amp; value) 로 구현 &lt;code&gt;*ptr = ~tmp &amp;amp; value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="32481d3d57648f7ac3b59915a8b343ab8f94362a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; GCC 4.4 and later implement &lt;code&gt;__sync_nand_and_fetch&lt;/code&gt; as &lt;code&gt;*ptr = ~(*ptr &amp;amp; value)&lt;/code&gt; instead of &lt;code&gt;*ptr = ~*ptr &amp;amp; value&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;참고 :&lt;/em&gt; GCC 4.4 &lt;code&gt;__sync_nand_and_fetch&lt;/code&gt; 에서는 &lt;code&gt;*ptr = ~(*ptr &amp;amp; value)&lt;/code&gt; 대신 __sync_nand_and_fetch 를 * ptr = ~ (* ptr &amp;amp; value) 로 구현 &lt;code&gt;*ptr = ~*ptr &amp;amp; value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa1f3ae46628635e862095cde321a13674e15cd0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; If GCOV_PREFIX_STRIP is set without GCOV_PREFIX is undefined, then a relative path is made out of the hardwired absolute paths.</source>
          <target state="translated">&lt;em&gt;참고 :&lt;/em&gt; GCOV_PREFIX를 정의하지 않고 GCOV_PREFIX_STRIP를 설정하면 상대 경로가 고정 배선 된 절대 경로로 만들어집니다.</target>
        </trans-unit>
        <trans-unit id="ea491177a79dc64abd09c78a1e151400a239c1ba" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; If a macro is actually used, but only used in skipped conditional blocks, then the preprocessor reports it as unused. To avoid the warning in such a case, you might improve the scope of the macro&amp;rsquo;s definition by, for example, moving it into the first skipped block. Alternatively, you could provide a dummy use with something like:</source>
          <target state="translated">&lt;em&gt;참고 :&lt;/em&gt; 매크로가 실제로 사용되지만 건너 뛴 조건부 블록에만 사용되는 경우 전처리 기는 매크로를 사용되지 않은 것으로보고합니다. 이러한 경우 경고를 피하기 위해 예를 들어 건너 뛴 첫 번째 블록으로 매크로를 이동하여 매크로 정의 범위를 향상시킬 수 있습니다. 또는 다음과 같은 더미 사용을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="513ca629c61e9f50ec1060bb038d882eda72087c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; If the chosen key method is later defined as inline, the vtable is still emitted in every translation unit that defines it. Make sure that any inline virtuals are declared inline in the class body, even if they are not defined there.</source>
          <target state="translated">&lt;em&gt;참고 :&lt;/em&gt; 선택한 키 방법이 나중에 인라인으로 정의 된 경우 vtable은이를 정의하는 모든 변환 단위로 계속 생성됩니다. 인라인 가상이 정의되지 않은 경우에도 클래스 본문에서 인라인 가상으로 선언되어야합니다.</target>
        </trans-unit>
        <trans-unit id="5909e9b7c2f203286387e1708a17c1db3ad3cfd7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; Only the &lt;code&gt;&amp;lt;altivec.h&amp;gt;&lt;/code&gt; interface is supported. Internally, GCC uses built-in functions to achieve the functionality in the aforementioned header file, but they are not supported and are subject to change without notice.</source>
          <target state="translated">&lt;em&gt;참고 :&lt;/em&gt; 만 &lt;code&gt;&amp;lt;altivec.h&amp;gt;&lt;/code&gt; 인터페이스가 지원됩니다. 내부적으로 GCC는 내장 함수를 사용하여 위에서 언급 한 헤더 파일의 기능을 수행하지만 지원되지 않으며 예고없이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e7d99f36188d0a0ae9bd36f15a8de72013df3fb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; Only the interface described in the aforementioned specification is supported. Internally, GCC uses built-in functions to implement the required functionality, but these are not supported and are subject to change without notice.</source>
          <target state="translated">&lt;em&gt;참고 :&lt;/em&gt; 위에서 언급 한 사양에 설명 된 인터페이스 만 지원됩니다. 내부적으로 GCC는 내장 기능을 사용하여 필요한 기능을 구현하지만 지원되지 않으며 예고없이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="60f5a5be3206ed7a5edc1d0306252ee653ebb15f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; Q7, Q15 and Q31 values must be initialized with their integer representation. As shown in this example, the integer representation of a Q7 value can be obtained by multiplying the fractional value by &lt;code&gt;0x1.0p7&lt;/code&gt;. The equivalent for Q15 values is to multiply by &lt;code&gt;0x1.0p15&lt;/code&gt;. The equivalent for Q31 values is to multiply by &lt;code&gt;0x1.0p31&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;참고 :&lt;/em&gt; Q7, Q15 및 Q31 값은 정수 표현으로 초기화해야합니다. 이 예에 도시 된 바와 같이, Q7 값의 정수 표현은 분수 값에 &lt;code&gt;0x1.0p7&lt;/code&gt; 을 곱함으로써 얻을 수있다 . Q15 값에 해당하는 것은 &lt;code&gt;0x1.0p15&lt;/code&gt; 를 곱하는 것 입니다 . Q31 값은 &lt;code&gt;0x1.0p31&lt;/code&gt; 을 곱하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="ecefd38e47b465f12582422275b6c1c7fc5ba3d0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; The 4.1, 4.2 and 4.3 series of GCC ignore the &lt;code&gt;packed&lt;/code&gt; attribute on bit-fields of type &lt;code&gt;char&lt;/code&gt;. This has been fixed in GCC 4.4 but the change can lead to differences in the structure layout. See the documentation of</source>
          <target state="translated">&lt;em&gt;참고 :&lt;/em&gt; 4.1, 4.2 및 4.3 시리즈 GCC는 &lt;code&gt;char&lt;/code&gt; 유형의 비트 필드 에서 &lt;code&gt;packed&lt;/code&gt; 속성을 무시합니다 . 이것은 GCC 4.4에서 수정되었지만 구조 레이아웃에 차이가 생길 수 있습니다. 의 설명서를 참조하십시오</target>
        </trans-unit>
        <trans-unit id="83a8626dc0b2f71c9d50349e2149ee36fab186fa" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; The CPU&amp;rsquo;s endianness determines the order in which values are packed. On little-endian targets, the first value is the least significant and the last value is the most significant. The opposite order applies to big-endian targets. For example, the code above sets the lowest byte of &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;1&lt;/code&gt; on little-endian targets and &lt;code&gt;4&lt;/code&gt; on big-endian targets.</source>
          <target state="translated">&lt;em&gt;참고 :&lt;/em&gt; CPU 엔디안은 값이 압축되는 순서를 결정합니다. 리틀 엔디안 대상에서 첫 번째 값이 가장 중요하지 않고 마지막 값이 가장 중요합니다. 반대 순서는 빅 엔디안 대상에 적용됩니다. 예를 들어, 위의 코드는 리틀 엔디안 대상에서 &lt;code&gt;a&lt;/code&gt; 의 가장 낮은 바이트 를 &lt;code&gt;1&lt;/code&gt; 로 설정하고 빅 엔디안 대상에서 &lt;code&gt;4&lt;/code&gt; 를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="5b93697e5f9fd5103a0a7f14fc065355825c4168" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; The CPU&amp;rsquo;s endianness determines which value is stored in the upper half of a register and which value is stored in the lower half. On little-endian targets, the first value is the lower one and the second value is the upper one. The opposite order applies to big-endian targets. For example, the code above sets the lower half of &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;1.5&lt;/code&gt; on little-endian targets and &lt;code&gt;9.1&lt;/code&gt; on big-endian targets.</source>
          <target state="translated">&lt;em&gt;참고 :&lt;/em&gt; CPU의 엔디안 (endianness)은 레지스터의 상반부에 저장되는 값과 하반부에 저장되는 값을 결정합니다. 리틀 엔디안 대상에서 첫 번째 값은 낮은 값이고 두 번째 값은 높은 값입니다. 반대 순서는 빅 엔디안 대상에 적용됩니다. 예를 들어, 위의 코드는 리틀 엔디안 대상에서 &lt;code&gt;a&lt;/code&gt; 의 하반부 를 &lt;code&gt;1.5&lt;/code&gt; 로 설정하고 빅 엔디안 대상에서 &lt;code&gt;9.1&lt;/code&gt; 을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="b6f29631325fd85cd0fed1160021c6ec9cde3b5c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; The generic GCC command-line option</source>
          <target state="translated">&lt;em&gt;참고 :&lt;/em&gt; 일반 GCC 명령 줄 옵션</target>
        </trans-unit>
        <trans-unit id="ed06dff3e4ef6bf04ce2ce52a8b9fd81cb4cb441" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; The value of the third parameter must be 0 or 4 modulo 8, otherwise the result is unpredictable. Please read the instruction description for details.</source>
          <target state="translated">&lt;em&gt;참고 :&lt;/em&gt; 세 번째 매개 변수의 값은 0 또는 4 모듈로 8이어야합니다. 그렇지 않으면 결과를 예측할 수 없습니다. 자세한 내용은 지침 설명을 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="72153d9d5813664a3177200e0649d766dc189c8b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; These &lt;code&gt;#pragma&lt;/code&gt;s have been superceded as of GCC 2.7.2 by COMDAT support and the &amp;ldquo;key method&amp;rdquo; heuristic mentioned in &lt;a href=&quot;vague-linkage#Vague-Linkage&quot;&gt;Vague Linkage&lt;/a&gt;. Using them can actually cause your program to grow due to unnecessary out-of-line copies of inline functions.</source>
          <target state="translated">&lt;em&gt;참고 :&lt;/em&gt; 이 &lt;code&gt;#pragma&lt;/code&gt; 는 COMDAT 지원 및 &lt;a href=&quot;vague-linkage#Vague-Linkage&quot;&gt;Vague Linkage에&lt;/a&gt; 언급 된 &quot;핵심 방법&quot;휴리스틱에 의해 GCC 2.7.2부터 대체되었습니다 . 그것들을 사용하면 실제로 인라인 함수의 불필요한 라인 외부 사본으로 인해 프로그램이 커질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7b139d88803f100cdd95a55602837bc153be904" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; This builtin is only available for C. This builtin can be used to call Go closures from C.</source>
          <target state="translated">&lt;em&gt;참고 :&lt;/em&gt; 이 기본 제공은 C에서만 사용할 수 있습니다.이 기본 제공은 C에서 Go 폐쇄를 호출하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d97839275dd23b736dcd3d659869aced8cae5cf" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; This construct is only available for C.</source>
          <target state="translated">&lt;em&gt;참고 :&lt;/em&gt; 이 구문은 C에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eacbc4a00a6df067f8f96e363a35fd76d48bed27" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; This construct is only available for C. Furthermore, the unused expression (&lt;var&gt;exp1&lt;/var&gt; or &lt;var&gt;exp2&lt;/var&gt; depending on the value of &lt;var&gt;const_exp&lt;/var&gt;) may still generate syntax errors. This may change in future revisions.</source>
          <target state="translated">&lt;em&gt;참고 :&lt;/em&gt; 이 구문은 C에서만 사용할 수 있습니다. 또한 사용되지 않은 표현식 ( &lt;var&gt;const_exp&lt;/var&gt; 값에 따라 &lt;var&gt;exp1&lt;/var&gt; 또는 &lt;var&gt;exp2&lt;/var&gt; )은 여전히 ​​구문 오류를 생성 할 수 있습니다. 향후 개정판에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e7e557ba1661093fe7151e1bdc289cf424df86b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; Using a built-in to generate an instruction not supported by a target may cause problems. At present the compiler is not guaranteed to detect such misuse, and as a result an internal compiler error may be generated.</source>
          <target state="translated">&lt;em&gt;참고 :&lt;/em&gt; 내장 기능을 사용하여 대상에서 지원하지 않는 명령어를 생성하면 문제가 발생할 수 있습니다. 현재 컴파일러는 이러한 오용을 감지한다고 보장하지 않으므로 내부 컴파일러 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a1eec5083716264a52a5668d0e808764085fd67" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; When compiling a program using computed gotos, a GCC extension, you may get better run-time performance if you disable the global common subexpression elimination pass by adding</source>
          <target state="translated">&lt;em&gt;참고 :&lt;/em&gt; 계산 된 gotos (GCC 확장)를 사용하여 프로그램을 컴파일 할 때 &lt;em&gt;다음&lt;/em&gt; 을 추가하여 글로벌 공통 하위 표현식 제거 패스를 사용하지 않으면 런타임 성능이 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3ceb34dafdbbccb7b3f4a9bc3198076a8bb038d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; pseudo instruction represents, in this particular context, an abstract measurement of function&amp;rsquo;s size. In no way does it represent a count of assembly instructions and as such its exact meaning might change from one release to an another.</source>
          <target state="translated">&lt;em&gt;참고 :&lt;/em&gt; 의사 명령어는이 특정 상황에서 함수 크기의 추상 측정을 나타냅니다. 어떤 방식으로도 조립 설명서의 수를 나타내지 않으므로 정확한 의미가 릴리스마다 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64cd29898900abd284b24ce0046a12f2a889805e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note:&lt;/em&gt; there may be no value to</source>
          <target state="translated">&lt;em&gt;참고 :&lt;/em&gt; 값이 없을 수 있습니다</target>
        </trans-unit>
        <trans-unit id="34f20bbbcdb20cd93bc0b28a39e05bcb36620def" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note&lt;/em&gt; If the</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; 인 경우]</target>
        </trans-unit>
        <trans-unit id="cc501835fd0037936c2300c5863d1305c99d13dc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Nvidia PTX Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Nvidia PTX 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7857f3cff032f30c80ecfb8270b8c04e4e9d6efc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;OpenRISC Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;OpenRISC 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="022f17d65bf2f852a9bf52143c3cab7582dddc12" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;PDP-11 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;PDP-11 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bc7124a8b758cba8598057dd8d025c193f4f022a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;PRU Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;PRU Options&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bc36ba8a70957c05f0128aeed8b3ffa01e74a202" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;PowerPC Options&lt;/em&gt; See RS/6000 and PowerPC Options.</source>
          <target state="translated">&lt;em&gt;PowerPC 옵션&lt;/em&gt; RS / 6000 및 &lt;em&gt;PowerPC 옵션을&lt;/em&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7d12212e9493501d271a126a834619cd825cc637" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;RISC-V Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;RISC-V 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="51deeb74b7040696523eac8e9b50aaa9f0c160b2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;RL78 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;RL78 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e0525fb0f4921d4b454f0867178cc3f2e709dd05" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;RS/6000 and PowerPC Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;RS / 6000 및 PowerPC 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="39cbc4dfd74b5b6e0fa9efd8a12d1162bb681080" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;RX Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;RX 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="736a44f00f2782082aa29882ffc21518d1f4a4e8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;S/390 and zSeries Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;S / 390 및 zSeries 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="41e4a234f5bb49cd0264fa22972792fc9da3bcbf" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;SH Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;SH 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="56bc7167620d3c71b9cb584d08f274377f44bf2a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;SPARC Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;SPARC 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dc670533970668fe64148e47e0fafdaea94cb03b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;SPU Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;SPU 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c56413d87d2da9557912d35dbc2cfbca82836384" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Score Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;점수 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="62b914fb373470c0b2ac9d74fa9f6fe2b909d5de" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Solaris 2 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;솔라리스 2 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d42fb76fd4341ca34cfd6fb2f6c0a0d677895a40" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Spec files&lt;/em&gt; are plain-text files that are used to construct spec strings. They consist of a sequence of directives separated by blank lines. The type of directive is determined by the first non-whitespace character on the line, which can be one of the following:</source>
          <target state="translated">&lt;em&gt;사양 파일&lt;/em&gt; 은 사양 문자열을 구성하는 데 사용되는 일반 텍스트 파일입니다. 빈 줄로 구분 된 일련의 지시문으로 구성됩니다. 지시문의 유형은 행의 첫 번째 공백이 아닌 문자에 의해 결정되며 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db99a02bf9325a0446b3d3660f54ae1be166577f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Spec strings&lt;/em&gt; are a list of command-line options to be passed to their corresponding program. In addition, the spec strings can contain &amp;lsquo;</source>
          <target state="translated">&lt;em&gt;스펙 문자열&lt;/em&gt; 은 해당 프로그램에 전달 될 명령 행 옵션의 목록입니다. 또한 사양 문자열에는 '</target>
        </trans-unit>
        <trans-unit id="5a15016eaf2ae61e798c9e92b569358a39e86710" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;System V Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;시스템 V 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="feb127030e9fe13464eefbb656da5c5e59f1ec48" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;TILE-Gx Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;TILE-Gx 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e6e6e9084306dd7d17aba875acb7fea1ed46ce39" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;TILEPro Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;TILEPro 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1e1e262e710aa664259e0fd18b86e9454a54d4a6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;V850 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;V850 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fc271d88c785f840f6cf51c476df618f74b1cbef" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;VAX Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;VAX 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e143e075ae3bdac97703feadb897d0df26906759" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;VMS Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;VMS 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d28ef093233a29030bf54382ba024a105f45890e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Visium Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Visium 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fe1a73e1bcb98976a3dfe16f3ba0939cee97b5b0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;VxWorks Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;VxWorks 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a7aee4d537121bb2f423daebb8bdece70ad36a69" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Warning:&lt;/em&gt; In the above example, be aware that a register (for example &lt;code&gt;r0&lt;/code&gt;) can be call-clobbered by subsequent code, including function calls and library calls for arithmetic operators on other variables (for example the initialization of &lt;code&gt;p2&lt;/code&gt;). In this case, use temporary variables for expressions between the register assignments:</source>
          <target state="translated">&lt;em&gt;경고 :&lt;/em&gt; 위의 예에서 함수 호출 및 다른 변수의 산술 연산자에 대한 라이브러리 호출 (예 : &lt;code&gt;p2&lt;/code&gt; 초기화)을 포함하여 후속 코드 로 레지스터 (예 : &lt;code&gt;r0&lt;/code&gt; )를 호출 클로버 할 수 있습니다 . 이 경우 레지스터 할당 사이의 표현식에 임시 변수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="816a932da8e0bd79bd86e31e2bb7d68625f97793" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Warnings&lt;/em&gt; report other unusual conditions in your code that &lt;em&gt;may&lt;/em&gt; indicate a problem, although compilation can (and does) proceed. Warning messages also report the source file name and line number, but include the text &amp;lsquo;</source>
          <target state="translated">&lt;em&gt;경고&lt;/em&gt; 는 컴파일 작업이 진행될 수는 있지만 문제 &lt;em&gt;가&lt;/em&gt; 있음을 나타내는 다른 비정상적인 조건을 코드에보고 합니다. 경고 메시지는 또한 소스 파일 이름과 줄 번호를보고하지만 '</target>
        </trans-unit>
        <trans-unit id="4b143c44f6aab624c938e93ad2f6b4f657e59153" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Xstormy16 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Xstormy16 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="18ac74c0cb677176c306ff128a293af591f367d3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Xtensa Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Xtensa 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="135f91287a5ce57a17a4eafa0bb5f1e2e6a72df9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;eBPF Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;eBPF Options&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="95e5f6791684d95443cdbb8fd6680f023a74362e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;picoChip Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;picoChip 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a2dbd6047aac87327270d92252817d5d79e582ce" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;x86 Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;x86 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2372ad60b474adcacc8813df7ea55f14799cf6b4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;x86 Windows Options&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;x86 Windows 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="636b6c51fd4e87f012cdd524f840607ddf80c3c5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;zSeries Options&lt;/em&gt; See S/390 and zSeries Options.</source>
          <target state="translated">&lt;em&gt;zSeries 옵션&lt;/em&gt; S / 390 및 &lt;em&gt;zSeries 옵션을&lt;/em&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="05b073d8b145e3b7b4fe9382c836fb5ca8365004" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&amp;lsquo;&lt;samp&gt;-mcpu&lt;/samp&gt;&amp;rsquo; arguments&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;'&lt;samp&gt;-mcpu&lt;/samp&gt;'인수&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0ca73c3cb15b2a6924f0a26af33432a71a16d184" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Be careful:&lt;/strong&gt; Write spaces around the &lt;code&gt;...&lt;/code&gt;, for otherwise it may be parsed wrong when you use it with integer values. For example, write this:</source>
          <target state="translated">&lt;strong&gt;주의 : &lt;/strong&gt; &lt;code&gt;...&lt;/code&gt; 주위에 공백을 쓰 &lt;strong&gt;십시오.&lt;/strong&gt; 그렇지 않으면 정수 값과 함께 사용할 때 잘못 구문 분석 될 수 있습니다. 예를 들어 다음과 같이 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="5b296bb4d7e000ba38a77aa5d36e6fe239ea357d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Family&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Family&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1ce6e314b705bb119112642204e6ae779116bafe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Do &lt;em&gt;not&lt;/em&gt; modify the contents of input-only operands (except for inputs tied to outputs). The compiler assumes that on exit from the &lt;code&gt;asm&lt;/code&gt; statement these operands contain the same values as they had before executing the statement. It is &lt;em&gt;not&lt;/em&gt; possible to use clobbers to inform the compiler that the values in these inputs are changing. One common work-around is to tie the changing input variable to an output variable that never gets used. Note, however, that if the code that follows the &lt;code&gt;asm&lt;/code&gt; statement makes no use of any of the output operands, the GCC optimizers may discard the &lt;code&gt;asm&lt;/code&gt; statement as unneeded (see &lt;a href=&quot;#Volatile&quot;&gt;Volatile&lt;/a&gt;).</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 음주 &lt;em&gt;하지&lt;/em&gt; (출력에 연결된 입력 제외) 입력 전용 피연산자의 내용을 수정합니다. 컴파일러는 &lt;code&gt;asm&lt;/code&gt; 문 을 종료 할 때 이러한 피연산자가 명령문을 실행하기 전과 동일한 값을 포함 한다고 가정합니다 . 이다 &lt;em&gt;하지&lt;/em&gt; 이러한 입력의 값을 변경하는 컴파일러에 알리는 쳤을를 사용할 수있다. 한 가지 일반적인 해결 방법은 변경 입력 변수를 절대 사용하지 않는 출력 변수에 연결하는 것입니다. 그러나 &lt;code&gt;asm&lt;/code&gt; 문 다음에 나오는 코드가 출력 피연산자를 사용하지 않으면 GCC 최적화 프로그램이 &lt;code&gt;asm&lt;/code&gt; 문을 불필요한 것으로 버릴 수 있습니다 ( &lt;a href=&quot;#Volatile&quot;&gt;Volatile&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="a41c6abd653a33317410ef0db731418bdf245365" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; If you use this switch, then you must build all modules with the same value, including any libraries. This includes the system libraries and startup modules.</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 이 스위치를 사용하는 경우 라이브러리를 포함하여 동일한 값으로 모든 모듈을 빌드해야합니다. 여기에는 시스템 라이브러리 및 시작 모듈이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="9f8a7fec506fe7c2f6084ea58dbd6ac51571b5ae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Since RAX register is used to avoid unnecessarily saving vector registers on stack when passing variable arguments, the impacts of this option are callees may waste some stack space, misbehave or jump to a random location. GCC 4.4 or newer don&amp;rsquo;t have those issues, regardless the RAX register value.</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; RAX 레지스터는 변수 인수를 전달할 때 스택에 벡터 레지스터를 불필요하게 저장하는 것을 피하기 위해 사용되므로이 옵션의 영향은 수신자가 스택 공간을 낭비하거나 오작동 또는 임의 위치로 이동할 수 있다는 것입니다. RCC 레지스터 값에 관계없이 GCC 4.4 이상에는 이러한 문제가 없습니다.</target>
        </trans-unit>
        <trans-unit id="715534c76b05f27a336cac5eca1f15bb1ba0531b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; The</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e163e3f64318185967d993e343b277921267102a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; The C standards do not specify semantics for &lt;code&gt;asm&lt;/code&gt;, making it a potential source of incompatibilities between compilers. These incompatibilities may not produce compiler warnings/errors.</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; C 표준은 &lt;code&gt;asm&lt;/code&gt; 의 의미론을 지정하지 않으므로 컴파일러 간의 비 호환성 원인이됩니다. 이러한 비 호환성으로 인해 컴파일러 경고 / 오류가 발생하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e86cc1401a696068f7f847fa2efe8d1c2b4f1d91" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; When an application does not properly join all threads (or creates an detached thread), a profile file can be still corrupted.</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 응용 프로그램이 모든 스레드를 올바르게 조인하지 않거나 분리 된 스레드를 만드는 경우에도 프로필 파일이 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="edb6152c62df55204f513a2bd268c824cd742794" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; When generating code for the x86-64 architecture with SSE extensions disabled,</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; SSE 확장이 비활성화 된 x86-64 아키텍처에 대한 코드를 생성 할 때,</target>
        </trans-unit>
        <trans-unit id="6d3e02f67e0426840cf2eab0fa386a7a0d8f3f4f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; code compiled with the</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 코드는</target>
        </trans-unit>
        <trans-unit id="81d77d1a721cb0e9d979c46fa00adb7925430d90" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; if you override the default value for your target ABI, this changes the size of structures and arrays containing &lt;code&gt;long double&lt;/code&gt; variables, as well as modifying the function calling convention for functions taking &lt;code&gt;long double&lt;/code&gt;. Hence they are not binary-compatible with code compiled without that switch.</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 당신이 당신의 목표 ABI의 기본 값을 대체하는 경우,이 포함 된 구조와 배열의 크기 변경 &lt;code&gt;long double&lt;/code&gt; 변수뿐만 아니라 촬영 기능에 대한 규칙을 호출하는 기능을 수정 &lt;code&gt;long double&lt;/code&gt; . 따라서이 스위치없이 컴파일 된 코드와 이진 호환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6aef184d39f03952d172b7102530bc7a9cb2fa3c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; if you use the</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 당신이 사용하는 경우</target>
        </trans-unit>
        <trans-unit id="b85ec1ce84c8439a9545fb2c1d7bf94b735aa0a2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; if you use this switch then you must build all modules with the same value, including any libraries. This includes the system libraries and startup modules.</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 이 스위치를 사용하는 경우 라이브러리를 포함하여 동일한 값으로 모든 모듈을 빌드해야합니다. 여기에는 시스템 라이브러리 및 시작 모듈이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="6580347fe9571154d0b4891b1664cd9202c2acd8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; if you use this switch, and &lt;var&gt;num&lt;/var&gt; is nonzero, then you must build all modules with the same value, including any libraries. This includes the system libraries and startup modules.</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 이 스위치를 사용하고 &lt;var&gt;num&lt;/var&gt; 이 0이 아닌 경우 라이브러리를 포함하여 동일한 값으로 모든 모듈을 빌드해야합니다. 여기에는 시스템 라이브러리 및 시작 모듈이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="f2fa2d1c77dc6f956448ba7d671e1de6cedbcd38" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; the</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="88c4d51d8f615f3993e3c0cef840662cb24bb857" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; the requisite libraries are not part of GCC. Normally the facilities of the machine&amp;rsquo;s usual C compiler are used, but this cannot be done directly in cross-compilation. You must make your own arrangements to provide suitable library functions for cross-compilation.</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 필수 라이브러리는 GCC의 일부가 아닙니다. 일반적으로 시스템의 일반적인 C 컴파일러 기능이 사용되지만이 작업은 크로스 컴파일에서 직접 수행 할 수 없습니다. 교차 컴파일에 적합한 라이브러리 기능을 제공하기 위해 사용자가 직접 준비해야합니다.</target>
        </trans-unit>
        <trans-unit id="776b38edee53ccd0d1e652426154a9a588a26326" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; this calling convention is incompatible with the one normally used on Unix, so you cannot use it if you need to call libraries compiled with the Unix compiler.</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 이 호출 규칙은 Unix에서 일반적으로 사용되는 것과 호환되지 않으므로 Unix 컴파일러로 컴파일 된 라이브러리를 호출해야하는 경우 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8633eef0a9b0178977134e42efd5a0068c9de00b" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;KIND&lt;/var&gt; is &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;KIND&lt;/var&gt; is &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="136834bf622d717ffa74c10318ba5a8ccd251af2" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;WHEN&lt;/var&gt; is &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;WHEN&lt;/var&gt; is &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="14be2a02710f49b8ea2b62d8e69b1cad01176b7f" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;arch&lt;/var&gt; value</source>
          <target state="translated">&lt;var&gt;arch&lt;/var&gt; value</target>
        </trans-unit>
        <trans-unit id="3c92b0834b3f6e0b0e166db87ccbdb672bb82648" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;auxname&lt;/var&gt;.gcda</source>
          <target state="translated">&lt;var&gt;auxname&lt;/var&gt;.gcda</target>
        </trans-unit>
        <trans-unit id="9e19d8b5ca485e7de26e8b332e442d8fc54664ea" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;auxname&lt;/var&gt;.gcno</source>
          <target state="translated">&lt;var&gt;auxname&lt;/var&gt;.gcno</target>
        </trans-unit>
        <trans-unit id="85165da2ca5194c5347e3eeeb486f7fe2449eb31" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;b&lt;/var&gt;fx</source>
          <target state="translated">&lt;var&gt;b&lt;/var&gt;fx</target>
        </trans-unit>
        <trans-unit id="e61d261ac414ee0ceb16d824496fad9b5acddd85" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;blocks&lt;/var&gt;: number of blocks that are in the function</source>
          <target state="translated">&lt;var&gt;blocks&lt;/var&gt; : 함수에있는 블록 수</target>
        </trans-unit>
        <trans-unit id="8ae8f4fb9cf1118a0551f86c7142bd0ff6bc1464" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;blocks_executed&lt;/var&gt;: number of executed blocks of the function</source>
          <target state="translated">&lt;var&gt;blocks_executed&lt;/var&gt; : 함수의 실행 된 블록 수</target>
        </trans-unit>
        <trans-unit id="b33636a0ba563901664b6c5f838dee23ec7b7447" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;byte-size&lt;/var&gt; works, but with variable-length arrays.</source>
          <target state="translated">&lt;var&gt;byte-size&lt;/var&gt; 는 작동하지만 가변 길이 배열로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="3908fe32fbee17ab1091dcbbbcc9d95e8c868d21" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;count&lt;/var&gt;: number of executions of the branch</source>
          <target state="translated">&lt;var&gt;count&lt;/var&gt; : 지점의 실행 횟수</target>
        </trans-unit>
        <trans-unit id="a5a5b0ddbf193f53659eab4ecc8e6518b23dc55a" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;count&lt;/var&gt;: number of executions of the line</source>
          <target state="translated">&lt;var&gt;count&lt;/var&gt; : 줄의 실행 횟수</target>
        </trans-unit>
        <trans-unit id="6dc66d5a71e8f3349f4206d52eb3738739a10355" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;current_working_directory&lt;/var&gt;: working directory where a compilation unit was compiled</source>
          <target state="translated">&lt;var&gt;current_working_directory&lt;/var&gt; : 컴파일 단위가 컴파일 된 작업 디렉토리</target>
        </trans-unit>
        <trans-unit id="f2f093923378c09906b260d4e4fef642e8bd4c9b" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;data_file&lt;/var&gt;: name of the data file (GCDA)</source>
          <target state="translated">&lt;var&gt;data_file&lt;/var&gt; : 데이터 파일 이름 (GCDA)</target>
        </trans-unit>
        <trans-unit id="82a3c99596c0803b3cd5b5dc5b7d4f7edcb29691" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;demangled_name&lt;/var&gt;: demangled name of the function</source>
          <target state="translated">&lt;var&gt;demangled_name&lt;/var&gt; : 함수의 demangled 이름</target>
        </trans-unit>
        <trans-unit id="96756339f8a07464a095163d86ae17ba49c6f2b0" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;dir&lt;/var&gt;/&lt;var&gt;suffix&lt;/var&gt;/usr/include</source>
          <target state="translated">&lt;var&gt;dir&lt;/var&gt;/&lt;var&gt;suffix&lt;/var&gt;/usr/include</target>
        </trans-unit>
        <trans-unit id="457fd18521fb5ee2775888f964e4ddd50de83968" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;dir&lt;/var&gt;/usr/include</source>
          <target state="translated">&lt;var&gt;dir&lt;/var&gt;/usr/include</target>
        </trans-unit>
        <trans-unit id="a2f5c6f857a964db0e9209dc3bc8af9204a69687" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;dir&lt;/var&gt;/usr/lib</source>
          <target state="translated">&lt;var&gt;dir&lt;/var&gt;/usr/lib</target>
        </trans-unit>
        <trans-unit id="710f2aaaa57ae08947b2914f307083f5ba6ecc46" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;end_column&lt;/var&gt;: column in the source file where the function ends</source>
          <target state="translated">&lt;var&gt;end_column&lt;/var&gt; : 함수가 끝나는 소스 파일의 열</target>
        </trans-unit>
        <trans-unit id="77d6abb0099a7849ef1e3e17b19f0755409a5b5e" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;end_line&lt;/var&gt;: line in the source file where the function ends</source>
          <target state="translated">&lt;var&gt;end_line&lt;/var&gt; : 함수가 끝나는 소스 파일의 행</target>
        </trans-unit>
        <trans-unit id="bcfb310dcf9e58743c432d6bf3a973817fa1a1e5" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;execution_count&lt;/var&gt;: number of executions of the function</source>
          <target state="translated">&lt;var&gt;execution_count&lt;/var&gt; : 함수의 실행 횟수</target>
        </trans-unit>
        <trans-unit id="07ced02e11442bdc9f19c2804e52ff736e36f64b" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;fallthrough&lt;/var&gt;: true when the branch is a fall through branch</source>
          <target state="translated">&lt;var&gt;fallthrough&lt;/var&gt; : 분기가 폴 스루 지점 인 경우 참</target>
        </trans-unit>
        <trans-unit id="cb068146736527c3f97548042cc209e45a84344b" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;fieldname&lt;/var&gt;:</source>
          <target state="translated">&lt;var&gt;fieldname&lt;/var&gt;:</target>
        </trans-unit>
        <trans-unit id="bc0ca9277beb7ce53874c5a6ea975087cabd0480" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;file&lt;/var&gt;.&lt;var&gt;passid&lt;/var&gt;.&lt;var&gt;pass&lt;/var&gt;.dot</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt;.&lt;var&gt;passid&lt;/var&gt;.&lt;var&gt;pass&lt;/var&gt;.dot</target>
        </trans-unit>
        <trans-unit id="185fc61cbdabdd77db10b2b0b60581412f88344f" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;file&lt;/var&gt;.analyzer.txt</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt;.analyzer.txt</target>
        </trans-unit>
        <trans-unit id="355dc9a2a93abc7e552de9fc5978fd259683b69a" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;file&lt;/var&gt;.callgraph.dot</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt;.callgraph.dot</target>
        </trans-unit>
        <trans-unit id="aa2d0b0a626af00705d11416adb8472a02b85335" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;file&lt;/var&gt;.eg-&lt;var&gt;id&lt;/var&gt;.txt</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt;.eg-&lt;var&gt;id&lt;/var&gt;.txt</target>
        </trans-unit>
        <trans-unit id="d51037b1808ab0ab68cf2854624577a0a2363a83" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;file&lt;/var&gt;.eg.dot</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt;.eg.dot</target>
        </trans-unit>
        <trans-unit id="e8c4ee87a95529e92014956c101d08d19626272a" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;file&lt;/var&gt;.eg.txt</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt;.eg.txt</target>
        </trans-unit>
        <trans-unit id="434eff9a292fff30f74330fc896652b1272e4265" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;file&lt;/var&gt;.state-purge.dot</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt;.state-purge.dot</target>
        </trans-unit>
        <trans-unit id="e948a9213200b3530a25cdb5e96fc8a614d0ac69" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;file&lt;/var&gt;.supergraph-eg.dot</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt;.supergraph-eg.dot</target>
        </trans-unit>
        <trans-unit id="36dd403968851ab1e3b90f91ed5b921efca47df1" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;file&lt;/var&gt;.supergraph.dot</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt;.supergraph.dot</target>
        </trans-unit>
        <trans-unit id="e36ec986d0d68718176ac505f37684283543d3d9" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;file&lt;/var&gt;&lt;var&gt;target&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt;&lt;var&gt;target&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="8ec94309621d2424e899ea1b78e55daad7870d18" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;file_name&lt;/var&gt;: name of the source file</source>
          <target state="translated">&lt;var&gt;file_name&lt;/var&gt; : 소스 파일의 이름</target>
        </trans-unit>
        <trans-unit id="cd6f65bdf191a64aaefc5c263459a6f075adc163" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;foo&lt;/var&gt; automatically implies</source>
          <target state="translated">&lt;var&gt;foo&lt;/var&gt; 는 자동으로 암시합니다</target>
        </trans-unit>
        <trans-unit id="70afe026807a5e12e476985ab37efbc5dc26d077" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;foo&lt;/var&gt; does not imply anything.</source>
          <target state="translated">&lt;var&gt;foo&lt;/var&gt; 는 아무것도 암시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="46fba837f5408f9512a6c400d555a520081bdffd" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;foo&lt;/var&gt;. However,</source>
          <target state="translated">&lt;var&gt;foo&lt;/var&gt; . 하나,</target>
        </trans-unit>
        <trans-unit id="705042d186415d378755a17325dbc0219d4372f1" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;format_version&lt;/var&gt;: semantic version of the format</source>
          <target state="translated">&lt;var&gt;format_version&lt;/var&gt; : 형식의 시맨틱 버전</target>
        </trans-unit>
        <trans-unit id="58bfbaccb373a1af2e15a00fe6b5acf8e46f5efd" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;function_name&lt;/var&gt;: a name of a function this &lt;var&gt;line&lt;/var&gt; belongs to (for a line with an inlined statements can be not set)</source>
          <target state="translated">&lt;var&gt;function_name&lt;/var&gt; :이 &lt;var&gt;line&lt;/var&gt; 속한 함수의 이름 (인라인 된 명령문이있는 행을 설정할 수 없음)</target>
        </trans-unit>
        <trans-unit id="7150cb8c780083943181393bffe3746be197596d" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;gcc_version&lt;/var&gt;: version of the GCC compiler</source>
          <target state="translated">&lt;var&gt;gcc_version&lt;/var&gt; : GCC 컴파일러 버전</target>
        </trans-unit>
        <trans-unit id="ae44b540bd27d10c4dc7e21db41478a671658ee6" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;kind&lt;/var&gt; is &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;kind&lt;/var&gt; 는 '</target>
        </trans-unit>
        <trans-unit id="8b8203cf510dcd89888a7c10446ebe87c2f89369" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;libexecdir&lt;/var&gt;/gcc/&lt;var&gt;target&lt;/var&gt;/&lt;var&gt;version&lt;/var&gt;/install-tools/</source>
          <target state="translated">&lt;var&gt;libexecdir&lt;/var&gt;/gcc/&lt;var&gt;target&lt;/var&gt;/&lt;var&gt;version&lt;/var&gt;/install-tools/</target>
        </trans-unit>
        <trans-unit id="7e28a7ea5e6f3cd24974425a7e272dd6dab22c97" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;line_number&lt;/var&gt;: line number</source>
          <target state="translated">&lt;var&gt;line_number&lt;/var&gt; : 줄 번호</target>
        </trans-unit>
        <trans-unit id="ea29079cba4e83858223a5ec28bdc6d50bd316b0" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;machine&lt;/var&gt;/&lt;var&gt;version&lt;/var&gt;/</source>
          <target state="translated">&lt;var&gt;machine&lt;/var&gt;/&lt;var&gt;version&lt;/var&gt;/</target>
        </trans-unit>
        <trans-unit id="fb87e55fd40c286be395999f14a4dc6d95b10b8e" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;mangledname&lt;/var&gt;.gcov</source>
          <target state="translated">&lt;var&gt;mangledname&lt;/var&gt;.gcov</target>
        </trans-unit>
        <trans-unit id="f0ce3ea44130cbe877829294966ed36eef7f62f7" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;mode&lt;/var&gt; can be set to one the following values:</source>
          <target state="translated">&lt;var&gt;mode&lt;/var&gt; 는 다음 값 중 하나로 설정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b1b3ce355abf1bec528e4e29cb69b648d32b2c3" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;n&lt;/var&gt;f</source>
          <target state="translated">&lt;var&gt;n&lt;/var&gt;f</target>
        </trans-unit>
        <trans-unit id="2956846802a0f3763419f1cd6721396729e2240a" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;n&lt;/var&gt;f1_1</source>
          <target state="translated">&lt;var&gt;n&lt;/var&gt;f1_1</target>
        </trans-unit>
        <trans-unit id="d0f528c5f50a3a9ca8a7f4d4becb651762709fc6" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;n&lt;/var&gt;f2_1</source>
          <target state="translated">&lt;var&gt;n&lt;/var&gt;f2_1</target>
        </trans-unit>
        <trans-unit id="a64a9113e49c525ccc4593f4075479691d2d779c" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;n&lt;/var&gt;f3_2</source>
          <target state="translated">&lt;var&gt;n&lt;/var&gt;f3_2</target>
        </trans-unit>
        <trans-unit id="0f1c1c81fa999d2f5ca3d601e651ccc54a89eb03" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;n&lt;/var&gt;x</source>
          <target state="translated">&lt;var&gt;n&lt;/var&gt;x</target>
        </trans-unit>
        <trans-unit id="8e4ffce74a745b869371f4d5e4b25a511464db80" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;name&lt;/var&gt;: name of the function</source>
          <target state="translated">&lt;var&gt;name&lt;/var&gt; : 함수 이름</target>
        </trans-unit>
        <trans-unit id="97651fa5ce5e8856932bddb384b35a32ca248309" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;number&lt;/var&gt; can only be 1 or 2. If it is 1 then branches are preferred over conditional code, if it is 2, then the opposite applies.</source>
          <target state="translated">&lt;var&gt;number&lt;/var&gt; 는 1 또는 2 만 될 수 있습니다. 1이면 조건부 코드보다 분기가 선호되고, 2이면 반대가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="50273f37f0b45fd83f80ed0fdeed8ef68524af4d" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;option&lt;/var&gt;=&lt;var&gt;value&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;option&lt;/var&gt;=&lt;var&gt;value&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="d0ce734a96f9558ae28efb50ac75200764dc9df5" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;path&lt;/var&gt; is the name of a file containing AutoFDO profile information. If omitted, it defaults to</source>
          <target state="translated">&lt;var&gt;path&lt;/var&gt; 는 AutoFDO 프로파일 정보가 포함 된 파일 이름입니다. 생략하면 기본값은</target>
        </trans-unit>
        <trans-unit id="5fc499cb4d5dfe67bd81e09d65c41f73e48f4073" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;path&lt;/var&gt; with &lt;var&gt;path&lt;/var&gt; pointing to the base directory of the build can be used to strip the irrelevant part of the path and keep all file names relative to the main build directory.</source>
          <target state="translated">&lt;var&gt;path&lt;/var&gt; with &lt;var&gt;path&lt;/var&gt; pointing to the base directory of the build can be used to strip the irrelevant part of the path and keep all file names relative to the main build directory.</target>
        </trans-unit>
        <trans-unit id="4a043823197d8a0d9d4a3dae48ce610f7a8479fd" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;prefix&lt;/var&gt;/lib/gcc/</source>
          <target state="translated">&lt;var&gt;prefix&lt;/var&gt;/lib/gcc/</target>
        </trans-unit>
        <trans-unit id="75da58a5824259553dc7e89b6ec73fadaabdf8c6" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;profile_dir&lt;/var&gt; and</source>
          <target state="translated">&lt;var&gt;profile_dir&lt;/var&gt; and</target>
        </trans-unit>
        <trans-unit id="26ed21f74315a592f7dd2bab8ba025f5ae695175" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;profile_dir&lt;/var&gt; to inform GCC where is the base directory of built source tree. By default &lt;var&gt;profile_dir&lt;/var&gt; will contain files with mangled absolute paths of all object files in the built project. This is not desirable when directory used to build the instrumented binary differs from the directory used to build the binary optimized with profile feedback because the profile data will not be found during the optimized build. In such setups</source>
          <target state="translated">&lt;var&gt;profile_dir&lt;/var&gt; to inform GCC where is the base directory of built source tree. By default &lt;var&gt;profile_dir&lt;/var&gt; will contain files with mangled absolute paths of all object files in the built project. This is not desirable when directory used to build the instrumented binary differs from the directory used to build the binary optimized with profile feedback because the profile data will not be found during the optimized build. In such setups</target>
        </trans-unit>
        <trans-unit id="575dfa2a337b4bc21315c8f8022717c452a4ae62" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;ptr&lt;/var&gt; is an optional pointer to the object that may be used to determine alignment. A value of 0 indicates typical alignment should be used. The compiler may also ignore this parameter.</source>
          <target state="translated">&lt;var&gt;ptr&lt;/var&gt; 은 정렬을 결정하는 데 사용될 수있는 객체에 대한 선택적 포인터입니다. 값이 0이면 일반적인 정렬을 사용해야 함을 나타냅니다. 컴파일러는이 매개 변수를 무시할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b3c5b36be47a0fa932bdb61b7a90e0c4902fd51" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;real&lt;/var&gt; + I * &lt;var&gt;imag&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;real&lt;/var&gt; + I * &lt;var&gt;imag&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="444cf69e0e22b51ba0c19cf554accc4728339634" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;reg&lt;/var&gt; must be the name of a register. The register names accepted are machine-specific and are defined in the &lt;code&gt;REGISTER_NAMES&lt;/code&gt; macro in the machine description macro file.</source>
          <target state="translated">&lt;var&gt;reg&lt;/var&gt; 는 레지스터의 이름이어야합니다. 허용되는 레지스터 이름은 시스템마다 &lt;code&gt;REGISTER_NAMES&lt;/code&gt; 시스템 설명 매크로 파일 의 REGISTER_NAMES 매크로에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fe1c0acef9a1d0caebcd87a22d3dc35ad3b0448" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;source-file&lt;/var&gt;##&lt;var&gt;md5&lt;/var&gt;.gcov</source>
          <target state="translated">&lt;var&gt;source-file&lt;/var&gt;##&lt;var&gt;md5&lt;/var&gt;.gcov</target>
        </trans-unit>
        <trans-unit id="b880a9e002b5a8cc6ab8e5b60ed026a3bd7b4c0f" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;source&lt;/var&gt;.&lt;var&gt;suffix&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;source&lt;/var&gt;.&lt;var&gt;suffix&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="c61509b5e229f01a21d510673ed3415523a72145" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;source&lt;/var&gt;.&lt;var&gt;suffix&lt;/var&gt;.gch</source>
          <target state="translated">&lt;var&gt;source&lt;/var&gt;.&lt;var&gt;suffix&lt;/var&gt;.gch</target>
        </trans-unit>
        <trans-unit id="70db49065f5eba9055c8c455ae0994a97a7b0ff7" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;source&lt;/var&gt;.o</source>
          <target state="translated">&lt;var&gt;source&lt;/var&gt;.o</target>
        </trans-unit>
        <trans-unit id="4b7c7cc9bc07a7bc8b59a106fc41bf34e5bc1bce" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;source&lt;/var&gt;.s</source>
          <target state="translated">&lt;var&gt;source&lt;/var&gt;.s</target>
        </trans-unit>
        <trans-unit id="a72234cee5f73a88a10f2c471d34f2876066e0e2" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;sourcefile&lt;/var&gt;.c</source>
          <target state="translated">&lt;var&gt;sourcefile&lt;/var&gt;.c</target>
        </trans-unit>
        <trans-unit id="fca90e9a21f6a50975b13af845d218e0a2f371d9" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;sourcefile&lt;/var&gt;.gcov</source>
          <target state="translated">&lt;var&gt;sourcefile&lt;/var&gt;.gcov</target>
        </trans-unit>
        <trans-unit id="d01d6365317d600e2664fe58c60f8e16adc09101" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;sourcename&lt;/var&gt;.decl</source>
          <target state="translated">&lt;var&gt;sourcename&lt;/var&gt;.decl</target>
        </trans-unit>
        <trans-unit id="273491f96586620c37b4be341e04ca0866ba515f" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;sourcename&lt;/var&gt;.gcda</source>
          <target state="translated">&lt;var&gt;sourcename&lt;/var&gt;.gcda</target>
        </trans-unit>
        <trans-unit id="b7a20df9ca0090865388e1ede1a8c313cfa2ec03" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;start_column&lt;/var&gt;: column in the source file where the function begins</source>
          <target state="translated">&lt;var&gt;start_column&lt;/var&gt; : 함수가 시작되는 소스 파일의 열</target>
        </trans-unit>
        <trans-unit id="3305d67073def22b0281ddc5b0ab6b21190df394" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;start_line&lt;/var&gt;: line in the source file where the function begins</source>
          <target state="translated">&lt;var&gt;start_line&lt;/var&gt; : 함수가 시작되는 소스 파일의 행</target>
        </trans-unit>
        <trans-unit id="cb4cfaac038ae456ad73674888cd5dee273bede8" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;startfile&lt;/var&gt; is the file name of the startfile (crt0) to use when linking. This option is only useful in conjunction with</source>
          <target state="translated">&lt;var&gt;startfile&lt;/var&gt; 은 링크 할 때 사용할 시작 파일 (crt0)의 파일 이름입니다. 이 옵션은 다음과 함께 만 유용합니다</target>
        </trans-unit>
        <trans-unit id="92e2c1df29e70248323ce9841f5738d40e347e46" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;state&lt;/var&gt; configure option.</source>
          <target state="translated">&lt;var&gt;state&lt;/var&gt; 구성 옵션.</target>
        </trans-unit>
        <trans-unit id="956c0d57ed11241cf2af6705b81cf132c79d5cf4" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;string&lt;/var&gt; may be parenthesized, and is printed with location information. For example,</source>
          <target state="translated">&lt;var&gt;string&lt;/var&gt; 은 괄호로 묶을 수 있으며 위치 정보와 함께 인쇄됩니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="9eedc4fd2f60aed10814958a1668c96d1c3d2760" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;style&lt;/var&gt; is either &lt;code&gt;c11&lt;/code&gt; or &lt;code&gt;ts-18661-3&lt;/code&gt; as appropriate.</source>
          <target state="translated">&lt;var&gt;style&lt;/var&gt; 은 &lt;code&gt;c11&lt;/code&gt; 또는 &lt;code&gt;ts-18661-3&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="756b0ec3e68649366cd0150c58c2eabc74fb8d54" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;systemlib&lt;/var&gt; is the library name of the library that provides low-level system calls required by the C library, e.g. &lt;code&gt;read&lt;/code&gt; and &lt;code&gt;write&lt;/code&gt;. This option is typically used to link with a library provided by a HAL BSP.</source>
          <target state="translated">&lt;var&gt;systemlib&lt;/var&gt; 는 C 라이브러리에 필요한 낮은 수준의 시스템 호출 (예 : &lt;code&gt;read&lt;/code&gt; and &lt;code&gt;write&lt;/code&gt; ) 을 제공하는 라이브러리의 라이브러리 이름입니다 . 이 옵션은 일반적으로 HAL BSP에서 제공하는 라이브러리와 연결하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f3b5c58dcaf93cade01b7328b68fe8d4178ba8da" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;throw&lt;/var&gt;: true when the branch is an exceptional branch</source>
          <target state="translated">&lt;var&gt;throw&lt;/var&gt; : 지점이 예외적 인 지점 인 경우 true</target>
        </trans-unit>
        <trans-unit id="745e86448be042dc8edebfc034c56ccccf38a979" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;type&lt;/var&gt; is an integer constant from 0 to 3. If the least significant bit is clear, objects are whole variables, if it is set, a closest surrounding subobject is considered the object a pointer points to. The second bit determines if maximum or minimum of remaining bytes is computed.</source>
          <target state="translated">&lt;var&gt;type&lt;/var&gt; 은 0에서 3까지의 정수 상수입니다. 최하위 비트가 명확하면 객체는 전체 변수입니다. 설정되어 있으면 가장 가까운 주변 하위 객체가 포인터가 가리키는 객체로 간주됩니다. 두 번째 비트는 나머지 바이트의 최대 값 또는 최소값이 계산되는지 여부를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="342fc24f28a056e632a0b35fb86b8d4dd73bc946" translate="yes" xml:space="preserve">
          <source>&lt;var&gt;unexecuted_block&lt;/var&gt;: flag whether the line contains an unexecuted block (not all statements on the line are executed)</source>
          <target state="translated">&lt;var&gt;unexecuted_block&lt;/var&gt; : 행에 실행되지 않은 블록이 있는지 여부를 플래그 지정합니다 (행의 모든 ​​명령문이 실행되는 것은 아님)</target>
        </trans-unit>
        <trans-unit id="6049c35e012365c54216cf4865563ff7b5c3b373" translate="yes" xml:space="preserve">
          <source>=&lt;var&gt;filename&lt;/var&gt;</source>
          <target state="translated">=&lt;var&gt;filename&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="46f10d3b2f96391f996a860a29e922307def05f4" translate="yes" xml:space="preserve">
          <source>=@cc&lt;var&gt;cond&lt;/var&gt;</source>
          <target state="translated">=@cc&lt;var&gt;cond&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="2481fc6ffc2fbe4f98d31256e625358325756148" translate="yes" xml:space="preserve">
          <source>=f</source>
          <target state="translated">=f</target>
        </trans-unit>
        <trans-unit id="900f8b38b05989605df65663e5e3869aab5eb789" translate="yes" xml:space="preserve">
          <source>? :</source>
          <target state="translated">? :</target>
        </trans-unit>
        <trans-unit id="6dcd4ce23d88e2ee9568ba546c007c63d9131c1b" translate="yes" xml:space="preserve">
          <source>A</source>
          <target state="translated">A</target>
        </trans-unit>
        <trans-unit id="7025e1843ee6104f357de4a85f21b2b545cac788" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;stable&amp;rdquo; memory operand; that is, one which does not include any automodification of the base register. This used to be useful when &amp;lsquo;</source>
          <target state="translated">&quot;안정한&quot;메모리 피연산자; 즉, 기준 레지스터의 자동 수정을 포함하지 않는 것입니다. 이것은 '</target>
        </trans-unit>
        <trans-unit id="b2a6e604c21235a8a2cf39c25b6821bfb403a2f9" translate="yes" xml:space="preserve">
          <source>A 10-bit signed constant (-512 &amp;hellip; 511)</source>
          <target state="translated">10 비트 부호있는 상수 (-512&amp;hellip; 511)</target>
        </trans-unit>
        <trans-unit id="576737d0097b50a261308a427b2851f9873b4e96" translate="yes" xml:space="preserve">
          <source>A 16 bit value with exactly one bit set.</source>
          <target state="translated">정확히 1 비트가 설정된 16 비트 값입니다.</target>
        </trans-unit>
        <trans-unit id="91a340944b7c5084f9cb17cdbbc4b3cfd1b6b8d2" translate="yes" xml:space="preserve">
          <source>A 16-bit fragment of a got, tls, or pc-relative reference.</source>
          <target state="translated">got, tls 또는 pc 기준 참조의 16 비트 조각입니다.</target>
        </trans-unit>
        <trans-unit id="9d079cc97fa73a6ab6e8c28d5a00eebc59ab7c45" translate="yes" xml:space="preserve">
          <source>A 16-bit signed constant (-32768 &amp;hellip; 32767)</source>
          <target state="translated">16 비트 부호있는 상수 (-32768&amp;hellip; 32767)</target>
        </trans-unit>
        <trans-unit id="600f9da68b2b8b3eca45f28f2690b3c739522b91" translate="yes" xml:space="preserve">
          <source>A 16-bit unsigned constant, multiple of 4 (0 &amp;hellip; 65532)</source>
          <target state="translated">16 비트 부호없는 상수, 4의 배수 (0&amp;hellip; 65532)</target>
        </trans-unit>
        <trans-unit id="626d08e653ff5fead00da4b2ae1ffdf55de25ac2" translate="yes" xml:space="preserve">
          <source>A 2-element vector constant with identical elements.</source>
          <target state="translated">요소가 같은 2 요소 벡터 상수입니다.</target>
        </trans-unit>
        <trans-unit id="199076609694aaa8dd531a498d6bd24d81a6cc20" translate="yes" xml:space="preserve">
          <source>A 20-bit signed constant (-524288 &amp;hellip; 524287)</source>
          <target state="translated">20 비트 부호있는 상수 (-524288&amp;hellip; 524287)</target>
        </trans-unit>
        <trans-unit id="739e9c986b6796272b083980b6406cba9cf05af2" translate="yes" xml:space="preserve">
          <source>A 3-bit unsigned integer constant.</source>
          <target state="translated">3 비트 부호없는 정수 상수.</target>
        </trans-unit>
        <trans-unit id="8d9d9ff6786b090797685cfe7290aeace549fb2c" translate="yes" xml:space="preserve">
          <source>A 4-element vector constant with identical elements.</source>
          <target state="translated">요소가 같은 4 요소 벡터 상수입니다.</target>
        </trans-unit>
        <trans-unit id="809cfd342c5778cebf932a5fb2090f41ac0b8050" translate="yes" xml:space="preserve">
          <source>A 5-bit unsigned immediate for CSR access instructions.</source>
          <target state="translated">CSR 액세스 명령에 대한 5 비트 부호없는 즉시.</target>
        </trans-unit>
        <trans-unit id="7a0f592094ae133e28a83db08acb3ad80aaa8c6b" translate="yes" xml:space="preserve">
          <source>A 5-bit unsigned integer constant.</source>
          <target state="translated">5 비트 부호없는 정수 상수.</target>
        </trans-unit>
        <trans-unit id="2a19359a80d0f6de7d964e539759745df3e07113" translate="yes" xml:space="preserve">
          <source>A 6-bit unsigned integer constant.</source>
          <target state="translated">6 비트 부호없는 정수 상수.</target>
        </trans-unit>
        <trans-unit id="4a1d6a6dcc128bafb39f6e3e6579f2614ede9096" translate="yes" xml:space="preserve">
          <source>A 7-bit unsigned integer constant.</source>
          <target state="translated">7 비트 부호없는 정수 상수.</target>
        </trans-unit>
        <trans-unit id="4e392016af47c374eef4f8aaf14822a0c557c367" translate="yes" xml:space="preserve">
          <source>A 8-bit unsigned integer constant.</source>
          <target state="translated">8 비트 부호없는 정수 상수.</target>
        </trans-unit>
        <trans-unit id="083fa44b7c5e44320ff4ed2ae01244ea90801a78" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;lo_sum&lt;/code&gt; data-linkage-table memory operand</source>
          <target state="translated">&lt;code&gt;lo_sum&lt;/code&gt; 데이터 링크 테이블 메모리 피연산자</target>
        </trans-unit>
        <trans-unit id="f9cd2e27d673f56cc94424aa5ac780102659b79a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;switch&lt;/code&gt; statement has an operand of type &lt;code&gt;long&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;switch&lt;/code&gt; 문은 유형의 피연산자를 가지고 &lt;code&gt;long&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0eff00ac09b6d2be5766ddb9515db21e223caed" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;typeof&lt;/code&gt; construct can be used anywhere a typedef name can be used. For example, you can use it in a declaration, in a cast, or inside of &lt;code&gt;sizeof&lt;/code&gt; or &lt;code&gt;typeof&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; 구조 어디서나 사용할 수있는 형식 정의 이름을 사용할 수 있습니다. 예를 들어 선언, 캐스트 또는 &lt;code&gt;sizeof&lt;/code&gt; 또는 &lt;code&gt;typeof&lt;/code&gt; 내부에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0fcc11ba29659026ef90972ee49fd236e8ca7461" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;nested function&lt;/em&gt; is a function defined inside another function. Nested functions are supported as an extension in GNU C, but are not supported by GNU C++.</source>
          <target state="translated">&lt;em&gt;중첩 된 함수는&lt;/em&gt; 다른 함수 내에 정의 된 함수이다. 중첩 함수는 GNU C에서 확장으로 지원되지만 GNU C ++에서는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c55a5d7e9e734b9cfd6d5b793b74655af96e5ff3" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;preprocessing token&lt;/em&gt; is a &lt;em&gt;preprocessing number&lt;/em&gt; if it begins with a digit and is followed by letters, underscores, digits, periods and &amp;lsquo;</source>
          <target state="translated">&lt;em&gt;전처리 토큰&lt;/em&gt; A는 &lt;em&gt;전처리 번호&lt;/em&gt; 가 숫자 문자로 시작하고, 밑줄 숫자와 마침표 &quot;뒤에 있다면</target>
        </trans-unit>
        <trans-unit id="226cffe8593eab9de1b46a1badbfea96e62ee6f4" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;thread&lt;/em&gt; is a flow of control within the abstract machine. It is implementation defined whether or not there may be more than one thread.</source>
          <target state="translated">&lt;em&gt;스레드는&lt;/em&gt; 추상 기계 내에서 제어의 흐름이다. 하나 이상의 스레드가 있는지 여부에 대해 정의 된 구현입니다.</target>
        </trans-unit>
        <trans-unit id="d63439749e9d375a44c13be44c44d3b25a8cbdd3" translate="yes" xml:space="preserve">
          <source>A C++ namespace declaration can also have the visibility attribute.</source>
          <target state="translated">C ++ 네임 스페이스 선언에는 가시성 속성이있을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6e3cb01289f372ad5685f7b48da04f4e60a84ec" translate="yes" xml:space="preserve">
          <source>A GNU Manual</source>
          <target state="translated">GNU 매뉴얼</target>
        </trans-unit>
        <trans-unit id="e5ae31d72b84a280dea45cc026a21e380e65748b" translate="yes" xml:space="preserve">
          <source>A VSX register (VSR), &lt;code&gt;vs0&lt;/code&gt;&amp;hellip;&lt;code&gt;vs63&lt;/code&gt;. This is either an FPR (&lt;code&gt;vs0&lt;/code&gt;&amp;hellip;&lt;code&gt;vs31&lt;/code&gt; are &lt;code&gt;f0&lt;/code&gt;&amp;hellip;&lt;code&gt;f31&lt;/code&gt;) or a VR (&lt;code&gt;vs32&lt;/code&gt;&amp;hellip;&lt;code&gt;vs63&lt;/code&gt; are &lt;code&gt;v0&lt;/code&gt;&amp;hellip;&lt;code&gt;v31&lt;/code&gt;).</source>
          <target state="translated">A VSX register (VSR), &lt;code&gt;vs0&lt;/code&gt; &amp;hellip; &lt;code&gt;vs63&lt;/code&gt; . This is either an FPR ( &lt;code&gt;vs0&lt;/code&gt; &amp;hellip; &lt;code&gt;vs31&lt;/code&gt; are &lt;code&gt;f0&lt;/code&gt; &amp;hellip; &lt;code&gt;f31&lt;/code&gt; ) or a VR ( &lt;code&gt;vs32&lt;/code&gt; &amp;hellip; &lt;code&gt;vs63&lt;/code&gt; are &lt;code&gt;v0&lt;/code&gt; &amp;hellip; &lt;code&gt;v31&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d5003442624da7a5396a336fd4ef339c3db6eb07" translate="yes" xml:space="preserve">
          <source>A base register. Like &lt;code&gt;r&lt;/code&gt;, but &lt;code&gt;r0&lt;/code&gt; is not allowed, so &lt;code&gt;r1&lt;/code&gt;&amp;hellip;&lt;code&gt;r31&lt;/code&gt;.</source>
          <target state="translated">A base register. Like &lt;code&gt;r&lt;/code&gt; , but &lt;code&gt;r0&lt;/code&gt; is not allowed, so &lt;code&gt;r1&lt;/code&gt; &amp;hellip; &lt;code&gt;r31&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd8fd98a94ad304e430ad561d03982387ab58fa2" translate="yes" xml:space="preserve">
          <source>A basic &lt;code&gt;asm&lt;/code&gt; statement has the following syntax:</source>
          <target state="translated">기본 &lt;code&gt;asm&lt;/code&gt; 문의 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6145aa4e1e7149a673e61fa6c454fd8a42cee7a8" translate="yes" xml:space="preserve">
          <source>A basic block profile count is considered hot if it contributes to the given permillage (i.e. 0...1000) of the entire profiled execution.</source>
          <target state="translated">기본 블록 프로파일 수는 전체 프로파일 된 실행의 주어진 단위 (예 : 0 ... 1000)에 기여하는 경우 핫한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="2df3f34d53b76011b7a6bb1711d67e1df403856d" translate="yes" xml:space="preserve">
          <source>A binary type trait: &lt;code&gt;true&lt;/code&gt; whenever the type arguments are the same.</source>
          <target state="translated">이진 형식 특성 : 형식 인수가 동일 할 때마다 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="61a474d3c8a798ad9f41fbc155178fa260c3cbfd" translate="yes" xml:space="preserve">
          <source>A bit mask suitable for the BFINS instruction.</source>
          <target state="translated">BFINS 명령어에 적합한 비트 마스크.</target>
        </trans-unit>
        <trans-unit id="1c197853a26bb6b9e64cfe3c20fc4b78dab065a2" translate="yes" xml:space="preserve">
          <source>A bit mask suitable for the MM instruction.</source>
          <target state="translated">MM 명령에 적합한 비트 마스크.</target>
        </trans-unit>
        <trans-unit id="fb82d601263ede6336b3a6d38f27a2db288988de" translate="yes" xml:space="preserve">
          <source>A bitfield mask suitable for bext or bins</source>
          <target state="translated">Bext 또는 Bin에 적합한 비트 필드 마스크</target>
        </trans-unit>
        <trans-unit id="95088444b66d4c9478cf588a65f1dca5aa3b6e35" translate="yes" xml:space="preserve">
          <source>A c99-like declaration syntax is also allowed:</source>
          <target state="translated">c99와 같은 선언 구문도 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="242045c1091165567c1e2bc6642eff026733baf4" translate="yes" xml:space="preserve">
          <source>A call clobbered P register.</source>
          <target state="translated">호출이 P 레지스터를 방해했습니다.</target>
        </trans-unit>
        <trans-unit id="6501e67efab2f7c858c0e0f7b446cd704c13a388" translate="yes" xml:space="preserve">
          <source>A call-used register in register file B (B0&amp;ndash;B9, B16&amp;ndash;B31).</source>
          <target state="translated">레지스터 파일 B (B0&amp;ndash;B9, B16&amp;ndash;B31)의 호출 사용 레지스터.</target>
        </trans-unit>
        <trans-unit id="5a85a53751233b51746da27b56a87b1a58dd44bc" translate="yes" xml:space="preserve">
          <source>A cast from integer to pointer discards most-significant bits if the pointer representation is smaller than the integer type, extends according to the signedness of the integer type if the pointer representation is larger than the integer type, otherwise the bits are unchanged.</source>
          <target state="translated">포인터 표현이 정수 유형보다 작 으면 정수에서 포인터로의 캐스트는 가장 중요한 비트를 버리고, 포인터 표현이 정수 유형보다 큰 경우 정수 유형의 부호에 따라 확장되고, 그렇지 않으면 비트가 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9579e92267fbbcb00a411d24c34a20ac82cffc52" translate="yes" xml:space="preserve">
          <source>A cast from pointer to integer discards most-significant bits if the pointer representation is larger than the integer type, sign-extends&lt;a href=&quot;#FOOT2&quot; id=&quot;DOCF2&quot; name=&quot;DOCF2&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; if the pointer representation is smaller than the integer type, otherwise the bits are unchanged.</source>
          <target state="translated">포인터 표현에서 정수로의 캐스트는 포인터 표현이 정수 유형보다 큰 경우 가장 중요한 비트를 버리고 포인터 표현이 정수 유형 보다 작은 경우 &lt;a href=&quot;#FOOT2&quot; id=&quot;DOCF2&quot; name=&quot;DOCF2&quot;&gt;&lt;sup&gt;2를&lt;/sup&gt;&lt;/a&gt; 확장 하고 그렇지 않으면 비트는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8d607e1d6022f86c3f2fb0150398c8747d6a9a20" translate="yes" xml:space="preserve">
          <source>A cast to a union type is a C extension not available in C++. It looks just like ordinary casts with the constraint that the type specified is a union type. You can specify the type either with the &lt;code&gt;union&lt;/code&gt; keyword or with a &lt;code&gt;typedef&lt;/code&gt; name that refers to a union. The result of a cast to a union is a temporary rvalue of the union type with a member whose type matches that of the operand initialized to the value of the operand. The effect of a cast to a union is similar to a compound literal except that it yields an rvalue like standard casts do. See &lt;a href=&quot;compound-literals#Compound-Literals&quot;&gt;Compound Literals&lt;/a&gt;.</source>
          <target state="translated">공용체 유형으로 캐스트는 C ++에서 사용할 수없는 C 확장입니다. 지정된 유형이 공용체 유형이라는 제한 조건이있는 일반 캐스트와 같습니다. &lt;code&gt;union&lt;/code&gt; 키워드 또는 공용체 를 참조 하는 &lt;code&gt;typedef&lt;/code&gt; 이름으로 형식을 지정할 수 있습니다 . 공용체로 캐스트 한 결과는 형식이 피연산자의 값으로 초기화 된 피연산자의 형식과 일치하는 멤버를 가진 공용체 유형의 임시 rvalue입니다. 조합에 대한 캐스트의 효과는 표준 캐스트와 마찬가지로 rvalue를 생성한다는 점을 제외하고 복합 리터럴과 유사합니다. &lt;a href=&quot;compound-literals#Compound-Literals&quot;&gt;복합 리터럴을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="75e1479f2ae72adba50e5d40e09a4fb8d576ce4d" translate="yes" xml:space="preserve">
          <source>A combination of</source>
          <target state="translated">의 조합</target>
        </trans-unit>
        <trans-unit id="de7ce58153dc3aa9a8a53f607567323d0809bd31" translate="yes" xml:space="preserve">
          <source>A comma-separated list of C expressions read by the instructions in the &lt;var&gt;AssemblerTemplate&lt;/var&gt;. An empty list is permitted. See &lt;a href=&quot;#InputOperands&quot;&gt;InputOperands&lt;/a&gt;.</source>
          <target state="translated">&lt;var&gt;AssemblerTemplate&lt;/var&gt; 의 지시 사항에서 읽은 쉼표로 구분 된 C 표현식 목록입니다 . 빈 목록이 허용됩니다. &lt;a href=&quot;#InputOperands&quot;&gt;InputOperands를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5b5d944665cc53cab2f2ad1f645c434c5620d068" translate="yes" xml:space="preserve">
          <source>A comma-separated list of registers or other values changed by the &lt;var&gt;AssemblerTemplate&lt;/var&gt;, beyond those listed as outputs. An empty list is permitted. See &lt;a href=&quot;#Clobbers-and-Scratch-Registers&quot;&gt;Clobbers and Scratch Registers&lt;/a&gt;.</source>
          <target state="translated">쉼표로 구분 된 레지스터 또는 기타 값 목록은 &lt;var&gt;AssemblerTemplate&lt;/var&gt; 에 의해 출력으로 나열된 값을 넘어서 변경되었습니다 . 빈 목록이 허용됩니다. &lt;a href=&quot;#Clobbers-and-Scratch-Registers&quot;&gt;클로버 및 스크래치 레지스터를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="65d21196a0c3e5a9f693ae19ae22931182555110" translate="yes" xml:space="preserve">
          <source>A comma-separated list of the C variables modified by the instructions in the &lt;var&gt;AssemblerTemplate&lt;/var&gt;. An empty list is permitted. See &lt;a href=&quot;#OutputOperands&quot;&gt;OutputOperands&lt;/a&gt;.</source>
          <target state="translated">&lt;var&gt;AssemblerTemplate&lt;/var&gt; 의 지시 사항에 의해 수정 된 C 변수의 쉼표로 구분 된 목록입니다 . 빈 목록이 허용됩니다. &lt;a href=&quot;#OutputOperands&quot;&gt;OutputOperands를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="57ff1562fe61f1f887425ce2cee86f1d3d93e844" translate="yes" xml:space="preserve">
          <source>A compiler conforms to an ABI if it generates code that follows all of the specifications enumerated by that ABI. A library conforms to an ABI if it is implemented according to that ABI. An application conforms to an ABI if it is built using tools that conform to that ABI and does not contain source code that specifically changes behavior specified by the ABI.</source>
          <target state="translated">컴파일러는 해당 ABI에서 열거 한 모든 사양을 따르는 코드를 생성하는 경우 ABI를 준수합니다. 라이브러리는 해당 ABI에 따라 구현 된 경우 ABI를 준수합니다. 응용 프로그램은 해당 ABI를 준수하는 도구를 사용하여 빌드되고 ABI에 의해 지정된 동작을 구체적으로 변경하는 소스 코드를 포함하지 않는 경우 ABI를 준수합니다.</target>
        </trans-unit>
        <trans-unit id="41c80a94e954da6243e86405854638e4aa3a6477" translate="yes" xml:space="preserve">
          <source>A compound literal looks like a cast of a brace-enclosed aggregate initializer list. Its value is an object of the type specified in the cast, containing the elements specified in the initializer. Unlike the result of a cast, a compound literal is an lvalue. ISO C99 and later support compound literals. As an extension, GCC supports compound literals also in C90 mode and in C++, although as explained below, the C++ semantics are somewhat different.</source>
          <target state="translated">복합 리터럴은 중괄호로 묶인 집계 초기화 목록의 캐스트처럼 보입니다. 이 값은 캐스트에 지정된 유형의 객체이며 초기화 프로그램에 지정된 요소를 포함합니다. 캐스트 결과와 달리 복합 리터럴은 lvalue입니다. ISO C99 이상은 복합 리터럴을 지원합니다. 확장으로서, GCC는 C90 모드와 C ++에서도 복합 리터럴을 지원하지만 아래에서 설명하는 것처럼 C ++ 의미는 약간 다릅니다.</target>
        </trans-unit>
        <trans-unit id="f6dd9a1a8f56216b2f65e6b7a8c29b8ee8f55106" translate="yes" xml:space="preserve">
          <source>A compound statement enclosed in parentheses may appear as an expression in GNU C. This allows you to use loops, switches, and local variables within an expression.</source>
          <target state="translated">괄호로 묶인 복합 명령문은 GNU C에서 표현식으로 나타날 수 있습니다.이를 통해 표현식 내에서 루프, 스위치 및 로컬 변수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a72443d4592827fe4ca85bea82301121049b91e" translate="yes" xml:space="preserve">
          <source>A conforming implementation of ISO C is required to document its choice of behavior in each of the areas that are designated &amp;ldquo;implementation defined&amp;rdquo;. The following lists all such areas, along with the section numbers from the ISO/IEC 9899:1990, ISO/IEC 9899:1999 and ISO/IEC 9899:2011 standards. Some areas are only implementation-defined in one version of the standard.</source>
          <target state="translated">&quot;구현 정의&quot;로 지정된 각 영역에서 행동 선택을 문서화하려면 ISO C의 적합한 구현이 필요합니다. 다음은 그러한 모든 영역을 ISO / IEC 9899 : 1990, ISO / IEC 9899 : 1999 및 ISO / IEC 9899 : 2011 표준의 섹션 번호와 함께 나열합니다. 일부 영역은 하나의 표준 버전에서만 구현 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="d4cb4e2bf524da1d62affddb40dfb630800239af" translate="yes" xml:space="preserve">
          <source>A conforming implementation of ISO C++ is required to document its choice of behavior in each of the areas that are designated &amp;ldquo;implementation defined&amp;rdquo;. The following lists all such areas, along with the section numbers from the ISO/IEC 14882:1998 and ISO/IEC 14882:2003 standards. Some areas are only implementation-defined in one version of the standard.</source>
          <target state="translated">&amp;ldquo;구현 정의&amp;rdquo;로 지정된 각 영역에서 선택한 행동을 문서화하려면 ISO C ++의 적합한 구현이 필요합니다. 다음은 그러한 모든 영역을 ISO / IEC 14882 : 1998 및 ISO / IEC 14882 : 2003 표준의 섹션 번호와 함께 나열한 것입니다. 일부 영역은 하나의 표준 버전에서만 구현 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="7b29cb3b319ec95ede4a30707c842823bf94b7db" translate="yes" xml:space="preserve">
          <source>A consequence of this is that &lt;code&gt;sizeof&lt;/code&gt; is also allowed on &lt;code&gt;void&lt;/code&gt; and on function types, and returns 1.</source>
          <target state="translated">결과적으로 &lt;code&gt;sizeof&lt;/code&gt; 는 &lt;code&gt;void&lt;/code&gt; 및 함수 유형 에서도 허용되며 1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7cad9a0baf039ead351d859d05c0365e63661fb9" translate="yes" xml:space="preserve">
          <source>A constant between -255 and 0 inclusive.</source>
          <target state="translated">-255와 0 사이의 상수입니다.</target>
        </trans-unit>
        <trans-unit id="4f8cd8bf499f2d6d54a71ffc2d3e21cf7ef45e36" translate="yes" xml:space="preserve">
          <source>A constant between -3 and 0 inclusive.</source>
          <target state="translated">-3과 0 사이의 상수입니다.</target>
        </trans-unit>
        <trans-unit id="19428213d0a5f62ee0574191f3ae2f2ddd996015" translate="yes" xml:space="preserve">
          <source>A constant between -4 and -1 inclusive.</source>
          <target state="translated">-4와 -1 사이의 상수입니다.</target>
        </trans-unit>
        <trans-unit id="d2fbc8414f61903ae333dcf7ac7a844a0c7b23fe" translate="yes" xml:space="preserve">
          <source>A constant between 0 and 255 inclusive.</source>
          <target state="translated">0에서 255 사이의 상수입니다.</target>
        </trans-unit>
        <trans-unit id="12f6b4cb352959b8bca5dac3da05fd53e64fa274" translate="yes" xml:space="preserve">
          <source>A constant between 0 and 3 inclusive.</source>
          <target state="translated">0에서 3 사이의 상수입니다.</target>
        </trans-unit>
        <trans-unit id="da945b1c391dff3ac6bc6d5fbd2be9149c62266c" translate="yes" xml:space="preserve">
          <source>A constant between 1 and 4 inclusive.</source>
          <target state="translated">1과 4 사이의 상수입니다.</target>
        </trans-unit>
        <trans-unit id="c0aca6087bfc1e63cba0551e38002443555e0fac" translate="yes" xml:space="preserve">
          <source>A constant for a bitfield width (1 &amp;hellip; 16)</source>
          <target state="translated">비트 필드 너비에 대한 상수 (1&amp;hellip; 16)</target>
        </trans-unit>
        <trans-unit id="6d56856d82b6a91412eed6d7df5c640079002d4d" translate="yes" xml:space="preserve">
          <source>A constant in the range -128 to 127, inclusive.</source>
          <target state="translated">-128에서 127 사이의 상수.</target>
        </trans-unit>
        <trans-unit id="17b05b4c60ac27d1e72d8030837136d5fa0be31c" translate="yes" xml:space="preserve">
          <source>A constant in the range -256 to 255, inclusive.</source>
          <target state="translated">-256에서 255 사이의 상수.</target>
        </trans-unit>
        <trans-unit id="695a694abf391bc605e989d6eb5dbacf14f628c2" translate="yes" xml:space="preserve">
          <source>A constant in the range -32768 to 32767, inclusive.</source>
          <target state="translated">-32768에서 32767 사이의 상수.</target>
        </trans-unit>
        <trans-unit id="2e51455a9b3294a37777151389f3c055d9628f83" translate="yes" xml:space="preserve">
          <source>A constant in the range -65535 to -1 (inclusive).</source>
          <target state="translated">-65535 ~ -1 범위의 상수입니다 (포함).</target>
        </trans-unit>
        <trans-unit id="a2eafd56ff7c3244c125e89f98b5047314116000" translate="yes" xml:space="preserve">
          <source>A constant in the range -8388608 to 8388607, inclusive.</source>
          <target state="translated">-8388608 ~ 8388607 범위의 상수.</target>
        </trans-unit>
        <trans-unit id="097b361ff7733f96fe3db5433e37aba686b852b1" translate="yes" xml:space="preserve">
          <source>A constant in the range 0 to 15, inclusive.</source>
          <target state="translated">0에서 15 사이의 상수.</target>
        </trans-unit>
        <trans-unit id="a36455a425b9727ae75ec8f878c7951252ab00ab" translate="yes" xml:space="preserve">
          <source>A constant in the range 1 to 65535 (inclusive).</source>
          <target state="translated">1에서 65535 사이의 상수 (포함).</target>
        </trans-unit>
        <trans-unit id="2a58c4a3cc79eb84153470348476e3f269dac278" translate="yes" xml:space="preserve">
          <source>A constant in the range [-64, 63] for shift/rotate instructions.</source>
          <target state="translated">이동 / 회전 명령에 대한 [-64, 63] 범위의 상수.</target>
        </trans-unit>
        <trans-unit id="10785db1e9d20c3cdec60f076d95570e2881e446" translate="yes" xml:space="preserve">
          <source>A constant in the range of 0 to -255.</source>
          <target state="translated">0--255 범위의 상수입니다.</target>
        </trans-unit>
        <trans-unit id="5b0495335754f2b58bcc5c273f50a0ad47fb4980" translate="yes" xml:space="preserve">
          <source>A constant in the range of 0 to 255.</source>
          <target state="translated">0에서 255 사이의 상수.</target>
        </trans-unit>
        <trans-unit id="3df560572af8da9f608ecbfa457628a58591cc1d" translate="yes" xml:space="preserve">
          <source>A constant in the range supported by &lt;code&gt;movcc&lt;/code&gt; instructions (11-bit signed immediate)</source>
          <target state="translated">&lt;code&gt;movcc&lt;/code&gt; 명령어가 지원하는 범위의 상수 (11 비트 부호있는 즉시)</target>
        </trans-unit>
        <trans-unit id="e6b217cb7e92669add738eef6823abf207c1faff" translate="yes" xml:space="preserve">
          <source>A constant in the range supported by &lt;code&gt;movrcc&lt;/code&gt; instructions (10-bit signed immediate)</source>
          <target state="translated">&lt;code&gt;movrcc&lt;/code&gt; 명령어가 지원하는 범위의 상수 (10 비트 부호있는 즉시)</target>
        </trans-unit>
        <trans-unit id="f72ba093b9d9c51600024c95028a46b05718f280" translate="yes" xml:space="preserve">
          <source>A constant that cannot be loaded using &lt;code&gt;lui&lt;/code&gt;, &lt;code&gt;addiu&lt;/code&gt; or &lt;code&gt;ori&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lui&lt;/code&gt; , &lt;code&gt;addiu&lt;/code&gt; 또는 &lt;code&gt;ori&lt;/code&gt; 를 사용하여로드 할 수없는 상수입니다 .</target>
        </trans-unit>
        <trans-unit id="7c2d44283a3acc9bdc683ea83a3f874e52a46752" translate="yes" xml:space="preserve">
          <source>A constant that has exactly one bit clear.</source>
          <target state="translated">정확히 1 비트가 명확한 상수입니다.</target>
        </trans-unit>
        <trans-unit id="cfb3a0520f6d9864d7a1976144208cbbd9174378" translate="yes" xml:space="preserve">
          <source>A constant that has exactly one bit set.</source>
          <target state="translated">정확히 1 비트 세트가있는 상수입니다.</target>
        </trans-unit>
        <trans-unit id="f067235028290b700b44d1ece783ed553e206e2b" translate="yes" xml:space="preserve">
          <source>A constant that is not between 2 and 15 inclusive.</source>
          <target state="translated">2에서 15 사이의 상수가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="dc8b34473e04adc25852b0eed10f1d174b004494" translate="yes" xml:space="preserve">
          <source>A constant which is not in the range of imm15u but ok for bclr instruction.</source>
          <target state="translated">imm15u 범위에 없지만 bclr 명령에 대해서는 상수입니다.</target>
        </trans-unit>
        <trans-unit id="c6a1b8bc59cee8c8f6571d6cc94e881414d8fd98" translate="yes" xml:space="preserve">
          <source>A constant which is not in the range of imm15u but ok for bset instruction.</source>
          <target state="translated">imm15u 범위에 없지만 bset 명령에는 괜찮은 상수입니다.</target>
        </trans-unit>
        <trans-unit id="5a081f0e675d939eda6d41b659eb1a4796698f55" translate="yes" xml:space="preserve">
          <source>A constant which is not in the range of imm15u but ok for btgl instruction.</source>
          <target state="translated">imm15u 범위에 없지만 btgl 명령에는 괜찮은 상수입니다.</target>
        </trans-unit>
        <trans-unit id="739639d0dba642847055adad6d408a8462cefd56" translate="yes" xml:space="preserve">
          <source>A constant whose compliment value is in the range of imm15u and ok for bitci instruction.</source>
          <target state="translated">칭찬 값이 imci15u 및 bitci 명령의 ok 범위에있는 상수입니다.</target>
        </trans-unit>
        <trans-unit id="772d4006b3b3b9f5dbb1eb8305ae0da40df09812" translate="yes" xml:space="preserve">
          <source>A decimal number representing clock cycles.</source>
          <target state="translated">클럭 사이클을 나타내는 10 진수입니다.</target>
        </trans-unit>
        <trans-unit id="0e4012d6617bb64507db563d81889013cebe2316" translate="yes" xml:space="preserve">
          <source>A declaration to which &lt;code&gt;weakref&lt;/code&gt; is attached and that is associated with a named &lt;code&gt;target&lt;/code&gt; must be &lt;code&gt;static&lt;/code&gt;.</source>
          <target state="translated">A declaration to which &lt;code&gt;weakref&lt;/code&gt; is attached and that is associated with a named &lt;code&gt;target&lt;/code&gt; must be &lt;code&gt;static&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="871d38c63e186ae7cd0f311fcbbf75d49f235704" translate="yes" xml:space="preserve">
          <source>A deprecated synonym for</source>
          <target state="translated">더 이상 사용되지 않는 동의어</target>
        </trans-unit>
        <trans-unit id="35b2c49fceb685c2e6ddfd9b7ccde26327c395da" translate="yes" xml:space="preserve">
          <source>A diagnostic can contain zero or more locations. Each location has up to three positions within it: a &lt;code&gt;caret&lt;/code&gt; position and optional &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;finish&lt;/code&gt; positions. A location can also have an optional &lt;code&gt;label&lt;/code&gt; string. For example, this error:</source>
          <target state="translated">진단에는 0 개 이상의 위치가 포함될 수 있습니다. 각 위치에는 최대 3 개의 위치가 있습니다 : &lt;code&gt;caret&lt;/code&gt; 위치 및 선택적인 &lt;code&gt;start&lt;/code&gt; 및 &lt;code&gt;finish&lt;/code&gt; 위치. 위치에는 선택적 &lt;code&gt;label&lt;/code&gt; 문자열 이있을 수도 있습니다 . 예를 들어이 오류는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1d3956dd1850c8ee01dd888bb0a0a3023c553d32" translate="yes" xml:space="preserve">
          <source>A diagnostic has a &lt;code&gt;kind&lt;/code&gt;. If this is &lt;code&gt;warning&lt;/code&gt;, then there is an &lt;code&gt;option&lt;/code&gt; key describing the command-line option controlling the warning.</source>
          <target state="translated">진단에는 &lt;code&gt;kind&lt;/code&gt; 있습니다. 이것이 &lt;code&gt;warning&lt;/code&gt; 인 경우 경고를 제어하는 명령 행 옵션을 설명 하는 &lt;code&gt;option&lt;/code&gt; 키가 있습니다.</target>
        </trans-unit>
        <trans-unit id="64d7123704bf7fa0f1e73d01535513a0dc7c2748" translate="yes" xml:space="preserve">
          <source>A different sort of disaster results from the use of this flag for a register in which function values may be returned.</source>
          <target state="translated">함수 값이 리턴 될 수있는 레지스터에이 플래그를 사용하면 다른 유형의 재난이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c32446d7ea192a83db5ac54835cfe4c3d265fe83" translate="yes" xml:space="preserve">
          <source>A factor for tuning the upper bound that swing modulo scheduler uses for scheduling a loop.</source>
          <target state="translated">스윙 모듈로 스케줄러가 루프 스케줄링에 사용하는 상한을 조정하는 요소.</target>
        </trans-unit>
        <trans-unit id="a7b34a84c6690fd83c05d2fa16fc0c287bb3da1b" translate="yes" xml:space="preserve">
          <source>A feature to report any failure to conform to ISO C might be useful in some instances, but would require considerable additional work and would be quite different from</source>
          <target state="translated">ISO C를 준수하지 못하는 것을보고하는 기능은 경우에 따라 유용하지만 상당한 추가 작업이 필요하며</target>
        </trans-unit>
        <trans-unit id="b2a29cc3baea0c08d4a825d0752f1c7c91b7a29c" translate="yes" xml:space="preserve">
          <source>A few standard library functions, such as &lt;code&gt;abort&lt;/code&gt; and &lt;code&gt;exit&lt;/code&gt;, cannot return. GCC knows this automatically. Some programs define their own functions that never return. You can declare them &lt;code&gt;noreturn&lt;/code&gt; to tell the compiler this fact. For example,</source>
          <target state="translated">&lt;code&gt;abort&lt;/code&gt; 및 &lt;code&gt;exit&lt;/code&gt; 와 같은 일부 표준 라이브러리 함수 는 리턴 할 수 없습니다. GCC는이를 자동으로 알고 있습니다. 일부 프로그램은 절대 반환되지 않는 자체 기능을 정의합니다. 컴파일러 에게이 사실을 알리기 위해 &lt;code&gt;noreturn&lt;/code&gt; 으로 선언 할 수 있습니다 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="cb463f377ea974dd6c90f4d5e14fe7753fa59c05" translate="yes" xml:space="preserve">
          <source>A file name that does not end in a special recognized suffix is considered to name an object file or library. (Object files are distinguished from libraries by the linker according to the file contents.) If linking is done, these object files are used as input to the linker.</source>
          <target state="translated">특수하게 인식되는 접미사로 끝나지 않는 파일 이름은 객체 파일 또는 라이브러리의 이름으로 간주됩니다. (파일 내용에 따라 링커에서 오브젝트 파일을 라이브러리와 구별합니다.) 링크가 완료되면 이러한 오브젝트 파일이 링커에 대한 입력으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="31a3ef8a1f914c346a656751b3762e1f23b6d753" translate="yes" xml:space="preserve">
          <source>A file&amp;rsquo;s &lt;em&gt;basename&lt;/em&gt; is the name stripped of all leading path information and of trailing suffixes, such as &amp;lsquo;</source>
          <target state="translated">파일의 &lt;em&gt;기본&lt;/em&gt; 이름은 모든 주요 경로 정보와 후행 접미사 (예 : '</target>
        </trans-unit>
        <trans-unit id="3cb6c35b9f770d58e9e6ae1be71711d84191b278" translate="yes" xml:space="preserve">
          <source>A floating point constant 0.0</source>
          <target state="translated">부동 소수점 상수 0.0</target>
        </trans-unit>
        <trans-unit id="ac7c31fdc5f9ddf8dfae82582cc34a55de257130" translate="yes" xml:space="preserve">
          <source>A floating point register (FPR), &lt;code&gt;f0&lt;/code&gt;&amp;hellip;&lt;code&gt;f31&lt;/code&gt;.</source>
          <target state="translated">A floating point register (FPR), &lt;code&gt;f0&lt;/code&gt; &amp;hellip; &lt;code&gt;f31&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="637820768e2434914c48d73ef03a77823d03c37c" translate="yes" xml:space="preserve">
          <source>A floating point register. This is the same as &lt;code&gt;f&lt;/code&gt; nowadays; historically &lt;code&gt;f&lt;/code&gt; was for single-precision and &lt;code&gt;d&lt;/code&gt; was for double-precision floating point.</source>
          <target state="translated">A floating point register. This is the same as &lt;code&gt;f&lt;/code&gt; nowadays; historically &lt;code&gt;f&lt;/code&gt; was for single-precision and &lt;code&gt;d&lt;/code&gt; was for double-precision floating point.</target>
        </trans-unit>
        <trans-unit id="35a05594f7fa158ed7e1a662576eede9b7714efc" translate="yes" xml:space="preserve">
          <source>A floating-point condition code register.</source>
          <target state="translated">부동 소수점 조건 코드 레지스터.</target>
        </trans-unit>
        <trans-unit id="6a5e282398dc91c4802485c8333b0a476c54fe7d" translate="yes" xml:space="preserve">
          <source>A floating-point register (if available).</source>
          <target state="translated">부동 소수점 레지스터 (사용 가능한 경우)</target>
        </trans-unit>
        <trans-unit id="f68f63f0de9f100e3091753e0a87b4bdcab324f8" translate="yes" xml:space="preserve">
          <source>A floating-point register (if availiable).</source>
          <target state="translated">부동 소수점 레지스터 (사용 가능한 경우).</target>
        </trans-unit>
        <trans-unit id="1d93f84bcb43d9808ea6d43552092e130f8e5d2b" translate="yes" xml:space="preserve">
          <source>A fourth version of the C standard, known as &lt;em&gt;C11&lt;/em&gt;, was published in 2011 as ISO/IEC 9899:2011. (While in development, drafts of this standard version were referred to as &lt;em&gt;C1X&lt;/em&gt;.) GCC has substantially complete support for this standard, enabled with</source>
          <target state="translated">&lt;em&gt;C11으로&lt;/em&gt; 알려진 C 표준의 네 번째 버전은 2011 년 ISO / IEC 9899 : 2011으로 출판되었습니다. (개발 과정에서이 표준 버전의 초안을 &lt;em&gt;C1X&lt;/em&gt; 라고했습니다 .) GCC는이 표준을 실질적으로 완벽하게 지원합니다.</target>
        </trans-unit>
        <trans-unit id="55257df904754ff4c13989bc1d064dbb261da350" translate="yes" xml:space="preserve">
          <source>A framework directory is a directory with frameworks in it. A framework is a directory with a</source>
          <target state="translated">프레임 워크 디렉토리는 프레임 워크가있는 디렉토리입니다. 프레임 워크는</target>
        </trans-unit>
        <trans-unit id="5ba28f66c2dca176d361d13d2cfcd58e64de11b1" translate="yes" xml:space="preserve">
          <source>A function declared external in one block and then used after the end of the block.</source>
          <target state="translated">한 블록에서 외부로 선언 된 다음 블록 끝 이후에 사용되는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="31442efa0c2c801bce0a5591e6aced95492894fb" translate="yes" xml:space="preserve">
          <source>A function may be given the attribute &lt;code&gt;no_instrument_function&lt;/code&gt;, in which case this instrumentation is not done. This can be used, for example, for the profiling functions listed above, high-priority interrupt routines, and any functions from which the profiling functions cannot safely be called (perhaps signal handlers, if the profiling routines generate output or allocate memory). See &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;no_instrument_function&lt;/code&gt; 속성이 함수에 제공 될 수 있으며 ,이 경우이 계측이 수행되지 않습니다. 예를 들어 위에 나열된 프로파일 링 기능, 우선 순위가 높은 인터럽트 루틴 및 프로파일 링 기능을 안전하게 호출 할 수없는 기능 (프로파일 링 루틴이 출력을 생성하거나 메모리를 할당하는 경우)에 사용할 수 있습니다. &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;공통 기능 속성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a3b5c7a586587400ee92ec622d45d7b4bfd1b3e3" translate="yes" xml:space="preserve">
          <source>A function parameter is declared without a type specifier in K&amp;amp;R-style functions:</source>
          <target state="translated">K &amp;amp; R 스타일 함수에서 유형 지정자없이 함수 매개 변수가 선언됩니다.</target>
        </trans-unit>
        <trans-unit id="4a55e26416d74770259268d8b952c442c03d140f" translate="yes" xml:space="preserve">
          <source>A function-like macro that appears without arguments.</source>
          <target state="translated">인수없이 나타나는 함수형 매크로입니다.</target>
        </trans-unit>
        <trans-unit id="debf2118f99ae7d5fcef4420f2e62948ac9db34c" translate="yes" xml:space="preserve">
          <source>A further version of the C standard, known as &lt;em&gt;C2X&lt;/em&gt;, is under development; experimental and incomplete support for this is enabled with</source>
          <target state="translated">&lt;em&gt;C2X로&lt;/em&gt; 알려진 C 표준의 추가 버전이 개발 중입니다. 이것에 대한 실험적이고 불완전한 지원은</target>
        </trans-unit>
        <trans-unit id="dd4d39a738de423b3a8f7321b1548155edc7437d" translate="yes" xml:space="preserve">
          <source>A general purpose register (GPR), &lt;code&gt;r0&lt;/code&gt;&amp;hellip;&lt;code&gt;r31&lt;/code&gt;.</source>
          <target state="translated">A general purpose register (GPR), &lt;code&gt;r0&lt;/code&gt; &amp;hellip; &lt;code&gt;r31&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a8db3cc1b660b8c40d207078f962c2f15753e61" translate="yes" xml:space="preserve">
          <source>A general register (&lt;code&gt;r0&lt;/code&gt; to &lt;code&gt;r31&lt;/code&gt;).</source>
          <target state="translated">일반 레지스터 ( &lt;code&gt;r0&lt;/code&gt; ~ &lt;code&gt;r31&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="4c9d8cf8321530b1a940502b30ac5acf72522d1e" translate="yes" xml:space="preserve">
          <source>A general-purpose register. This is equivalent to &lt;code&gt;r&lt;/code&gt; unless generating MIPS16 code, in which case the MIPS16 register set is used.</source>
          <target state="translated">범용 레지스터 MIPS16 코드를 생성하지 않는 한 &lt;code&gt;r&lt;/code&gt; 과 같습니다 .이 경우 MIPS16 레지스터 세트가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d2030f94473ff72afe09286a5000f598b54444ee" translate="yes" xml:space="preserve">
          <source>A generic CPU with 64-bit extensions.</source>
          <target state="translated">64 비트 확장명을 가진 일반 CPU.</target>
        </trans-unit>
        <trans-unit id="1e6fe121c0bf0b0f224a8bd42e66a0a587219c64" translate="yes" xml:space="preserve">
          <source>A given program is written in one or the other of these two dialects. The program stands a chance to work on most any machine if it is compiled with the proper dialect. It is unlikely to work at all if compiled with the wrong dialect.</source>
          <target state="translated">주어진 프로그램은이 두 방언 중 하나 또는 다른 방언으로 작성됩니다. 이 프로그램은 적절한 방언으로 컴파일되면 대부분의 컴퓨터에서 작동 할 수 있습니다. 잘못된 방언으로 컴파일하면 전혀 작동하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c5058629f496fbd3a9b20ab2118be652c13eb69" translate="yes" xml:space="preserve">
          <source>A good explanation of the benefits offered by ensuring ELF symbols have the correct visibility is given by &amp;ldquo;How To Write Shared Libraries&amp;rdquo; by Ulrich Drepper (which can be found at &lt;a href=&quot;https://www.akkadia.org/drepper/&quot;&gt;https://www.akkadia.org/drepper/&lt;/a&gt;)&amp;mdash;however a superior solution made possible by this option to marking things hidden when the default is public is to make the default hidden and mark things public. This is the norm with DLLs on Windows and with</source>
          <target state="translated">ELF 기호가 올바른 가시성을 갖도록함으로써 제공되는 이점에 대한 자세한 설명은 Ulrich Drepper ( &lt;a href=&quot;https://www.akkadia.org/drepper/&quot;&gt;https://www.akkadia.org/drepper/&lt;/a&gt; ) 에서&amp;ldquo;공유 라이브러리를 작성하는 방법&amp;rdquo;을 참조하십시오 . 기본 옵션이 공개 일 때 숨겨진 항목을 표시하는이 옵션으로 가능해진 우수한 솔루션은 기본 숨김을 설정하고 공개하는 것입니다. 이것은 Windows의 DLL과 함께 표준입니다.</target>
        </trans-unit>
        <trans-unit id="4b92b6d35d4ef9edd4bc988a5b041656a4bfb9c4" translate="yes" xml:space="preserve">
          <source>A local label declaration looks like this:</source>
          <target state="translated">로컬 레이블 선언은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4eae759733edfeb41cf185aaf992eb0590b9b2a1" translate="yes" xml:space="preserve">
          <source>A local variable or class data member declared both &lt;code&gt;static&lt;/code&gt; and &lt;code&gt;__thread&lt;/code&gt; gives the variable or member thread storage duration.</source>
          <target state="translated">&lt;code&gt;static&lt;/code&gt; 및 &lt;code&gt;__thread&lt;/code&gt; 로 선언 된 로컬 변수 또는 클래스 데이터 멤버는 변수 또는 멤버 스레드 저장 기간을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="cbc079ebb13b05a28fc7e6b5c8e9b7e32b012d41" translate="yes" xml:space="preserve">
          <source>A loop expected to iterate at least the selected number of iterations is aligned.</source>
          <target state="translated">선택된 반복 횟수 이상 반복 될 것으로 예상되는 루프가 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="e6e2fdd4a6e2c1dbe43d588ddf3a77eab778b7d1" translate="yes" xml:space="preserve">
          <source>A member of a union object is accessed using a member of a different type (C90 6.3.2.3).</source>
          <target state="translated">다른 유형의 멤버 (C90 6.3.2.3)를 사용하여 통합 개체의 멤버에 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="d48a8ba2b56e035d8312e0298f36fac9054a9681" translate="yes" xml:space="preserve">
          <source>A memory address based on Y or Z pointer with displacement.</source>
          <target state="translated">변위가있는 Y 또는 Z 포인터 기반 메모리 주소.</target>
        </trans-unit>
        <trans-unit id="3b84dcc8ac9137874012ebfd9eadab8bb949fee4" translate="yes" xml:space="preserve">
          <source>A memory address suitable for a load/store pair instruction in SI, DI, SF and DF modes</source>
          <target state="translated">SI, DI, SF 및 DF 모드에서로드 / 저장 쌍 명령에 적합한 메모리 주소</target>
        </trans-unit>
        <trans-unit id="0bb3634ff6bc0ca41e70f28fef8acf81311e449f" translate="yes" xml:space="preserve">
          <source>A memory address that will work with the &lt;code&gt;lq&lt;/code&gt; and &lt;code&gt;stq&lt;/code&gt; instructions.</source>
          <target state="translated">&lt;code&gt;lq&lt;/code&gt; 및 &lt;code&gt;stq&lt;/code&gt; 명령어 와 함께 작동하는 메모리 주소입니다 .</target>
        </trans-unit>
        <trans-unit id="e82efce1d813a82c9a30ae4a9287debad5d5c479" translate="yes" xml:space="preserve">
          <source>A memory address which uses a single base register with no offset</source>
          <target state="translated">오프셋없이 단일 기준 레지스터를 사용하는 메모리 주소</target>
        </trans-unit>
        <trans-unit id="f6aff7695c779a2c12c72d4158e0a44c684b7687" translate="yes" xml:space="preserve">
          <source>A memory operand accessed with indexed or indirect addressing.</source>
          <target state="translated">A memory operand accessed with indexed or indirect addressing.</target>
        </trans-unit>
        <trans-unit id="9aa32937bb87c45112562669984946bc4a880e43" translate="yes" xml:space="preserve">
          <source>A memory operand addressed by just a base register.</source>
          <target state="translated">A memory operand addressed by just a base register.</target>
        </trans-unit>
        <trans-unit id="d889b3934276ee507afa50f38217acb1e8a60ca1" translate="yes" xml:space="preserve">
          <source>A memory operand for floating-point loads and stores</source>
          <target state="translated">부동 소수점로드 및 저장을위한 메모리 피연산자</target>
        </trans-unit>
        <trans-unit id="76dff8679e9a8f7ce2eb5bb8fad71047c6747dbc" translate="yes" xml:space="preserve">
          <source>A memory operand is allowed, but only if the address is &lt;em&gt;offsettable&lt;/em&gt;. This means that adding a small integer (actually, the width in bytes of the operand, as determined by its machine mode) may be added to the address and the result is also a valid memory address.</source>
          <target state="translated">주소가 &lt;em&gt;오프셋 가능한&lt;/em&gt; 경우에만 메모리 피연산자가 허용됩니다 . 이것은 작은 정수 (실제로 기계 모드에 의해 결정된 피연산자의 바이트 단위 폭)를 추가하는 것이 주소에 추가 될 수 있고 결과도 유효한 메모리 주소임을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="388671fe2c36d60a932779a67c16d85d78ac2d17" translate="yes" xml:space="preserve">
          <source>A memory operand is allowed, with any kind of address that the machine supports in general. Note that the letter used for the general memory constraint can be re-defined by a back end using the &lt;code&gt;TARGET_MEM_CONSTRAINT&lt;/code&gt; macro.</source>
          <target state="translated">머신이 일반적으로 지원하는 모든 종류의 주소와 함께 메모리 피연산자가 허용됩니다. 일반 메모리 제한 조건에 사용 된 문자는 &lt;code&gt;TARGET_MEM_CONSTRAINT&lt;/code&gt; 매크로를 사용하여 백엔드에 의해 재정의 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e12c184fcd9f0721bc91e2359dd6f356789155c7" translate="yes" xml:space="preserve">
          <source>A memory operand suitable for Nios II R2 load/store exclusive instructions.</source>
          <target state="translated">Nios II R2로드 / 저장 전용 명령에 적합한 메모리 피연산자입니다.</target>
        </trans-unit>
        <trans-unit id="7146411d4e212e3eace6ea02064bc67368c7d22e" translate="yes" xml:space="preserve">
          <source>A memory operand suitable for load/store IO and cache instructions.</source>
          <target state="translated">로드 / 저장 IO 및 캐시 명령에 적합한 메모리 피연산자입니다.</target>
        </trans-unit>
        <trans-unit id="40ed4ba7f90bf88673d73789aca447219b51285c" translate="yes" xml:space="preserve">
          <source>A memory operand suitable for the ISA 3.0 vector d-form instructions.</source>
          <target state="translated">ISA 3.0 벡터 d-form 명령어에 적합한 메모리 피연산자.</target>
        </trans-unit>
        <trans-unit id="84bfbe27f0967bbd8165fcff340f78cb41e95ca2" translate="yes" xml:space="preserve">
          <source>A memory operand that can be used as the destination operand of an integer store instruction</source>
          <target state="translated">정수 저장 명령어의 대상 피연산자로 사용할 수있는 메모리 피연산자</target>
        </trans-unit>
        <trans-unit id="96695f63007ab0923706713901f4b85b969e2a0a" translate="yes" xml:space="preserve">
          <source>A memory operand that is not offsettable. In other words, anything that would fit the &amp;lsquo;</source>
          <target state="translated">오프셋 할 수없는 메모리 피연산자 즉, '</target>
        </trans-unit>
        <trans-unit id="1a801a13c9b53ba2ca78c13cc2cdf8d621afb8bd" translate="yes" xml:space="preserve">
          <source>A memory operand whose address is formed by a base register and offset that is suitable for use in instructions with the same addressing mode as &lt;code&gt;ll&lt;/code&gt; and &lt;code&gt;sc&lt;/code&gt;.</source>
          <target state="translated">주소가 &lt;code&gt;ll&lt;/code&gt; 및 &lt;code&gt;sc&lt;/code&gt; 와 동일한 주소 지정 모드를 가진 명령어에 사용하기에 적합한베이스 레지스터 및 오프셋에 의해 형성되는 메모리 피연산자입니다 .</target>
        </trans-unit>
        <trans-unit id="0cf579681538dd24f4c522430fbc1d9db816f237" translate="yes" xml:space="preserve">
          <source>A memory operand with autodecrement addressing (either predecrement or postdecrement) is allowed. In inline &lt;code&gt;asm&lt;/code&gt; this constraint is only allowed if the operand is used exactly once in an instruction that can handle the side effects. Not using an operand with &amp;lsquo;</source>
          <target state="translated">자동 감소 주소 지정 (사전 감소 또는 사후 감소)이있는 메모리 피연산자가 허용됩니다. 인라인 &lt;code&gt;asm&lt;/code&gt; 에서이 제약 조건은 부작용을 처리 할 수있는 명령어에서 피연산자가 정확히 한 번만 사용되는 경우에만 허용됩니다. '로 피연산자를 사용하지 않음</target>
        </trans-unit>
        <trans-unit id="cdc334ade8276d0cf5a4c832b12ab9caa48613bc" translate="yes" xml:space="preserve">
          <source>A memory operand with autoincrement addressing (either preincrement or postincrement) is allowed. In inline &lt;code&gt;asm&lt;/code&gt; the same restrictions as for &amp;lsquo;</source>
          <target state="translated">자동 증분 주소 지정 (사전 증분 또는 사후 증분)이있는 메모리 피연산자가 허용됩니다. 인라인 &lt;code&gt;asm&lt;/code&gt; 에서 '</target>
        </trans-unit>
        <trans-unit id="5ac646a0970be5dfa33196ede31cf6694433d2fe" translate="yes" xml:space="preserve">
          <source>A memory operand. Normally, &lt;code&gt;m&lt;/code&gt; does not allow addresses that update the base register. If the &lt;code&gt;&amp;lt;&lt;/code&gt; or &lt;code&gt;&amp;gt;&lt;/code&gt; constraint is also used, they are allowed and therefore on PowerPC targets in that case it is only safe to use &lt;code&gt;m&amp;lt;&amp;gt;&lt;/code&gt; in an &lt;code&gt;asm&lt;/code&gt; statement if that &lt;code&gt;asm&lt;/code&gt; statement accesses the operand exactly once. The &lt;code&gt;asm&lt;/code&gt; statement must also use &lt;code&gt;%U&lt;var&gt;&amp;lt;opno&amp;gt;&lt;/var&gt;&lt;/code&gt; as a placeholder for the &amp;ldquo;update&amp;rdquo; flag in the corresponding load or store instruction. For example:</source>
          <target state="translated">A memory operand. Normally, &lt;code&gt;m&lt;/code&gt; does not allow addresses that update the base register. If the &lt;code&gt;&amp;lt;&lt;/code&gt; or &lt;code&gt;&amp;gt;&lt;/code&gt; constraint is also used, they are allowed and therefore on PowerPC targets in that case it is only safe to use &lt;code&gt;m&amp;lt;&amp;gt;&lt;/code&gt; in an &lt;code&gt;asm&lt;/code&gt; statement if that &lt;code&gt;asm&lt;/code&gt; statement accesses the operand exactly once. The &lt;code&gt;asm&lt;/code&gt; statement must also use &lt;code&gt;%U&lt;var&gt;&amp;lt;opno&amp;gt;&lt;/var&gt;&lt;/code&gt; as a placeholder for the &amp;ldquo;update&amp;rdquo; flag in the corresponding load or store instruction. For example:</target>
        </trans-unit>
        <trans-unit id="a4c1412da74dea8e31160c68dd4c58d9ddd39d1e" translate="yes" xml:space="preserve">
          <source>A memory reference suitable for VFP load/store insns (reg+constant offset)</source>
          <target state="translated">VFP로드 / 저장 인에 적합한 메모리 참조 (reg + constant offset)</target>
        </trans-unit>
        <trans-unit id="3a8bf2f192d44bf25c5dafeee0b8eaa22bcc9154" translate="yes" xml:space="preserve">
          <source>A memory reference suitable for iWMMXt load/store instructions.</source>
          <target state="translated">iWMMXt로드 / 저장 명령어에 적합한 메모리 참조.</target>
        </trans-unit>
        <trans-unit id="4b919c81ffb39ef6f8f9eb3d7ccc854afd2048d5" translate="yes" xml:space="preserve">
          <source>A memory reference suitable for the ARMv4 ldrsb instruction.</source>
          <target state="translated">ARMv4 ldrsb 명령어에 적합한 메모리 참조입니다.</target>
        </trans-unit>
        <trans-unit id="0281e56b013121500cc01f595e9459e28872a62b" translate="yes" xml:space="preserve">
          <source>A memory reference that is a stack pop.</source>
          <target state="translated">스택 팝인 메모리 참조</target>
        </trans-unit>
        <trans-unit id="19169aa6dfaeac0eed19cdca087e18730184a143" translate="yes" xml:space="preserve">
          <source>A memory reference that is a stack push.</source>
          <target state="translated">스택 푸시 인 메모리 참조</target>
        </trans-unit>
        <trans-unit id="9f8594bf5c6cb542733511c9002f352d41b3d7e8" translate="yes" xml:space="preserve">
          <source>A memory reference that is encoded within the opcode, but not auto-increment or auto-decrement.</source>
          <target state="translated">opcode 내에서 인코딩되지만 자동 증가 또는 자동 감소가 아닌 메모리 참조입니다.</target>
        </trans-unit>
        <trans-unit id="261f1d2ca930e0206ac633c0e47452ba885dfea6" translate="yes" xml:space="preserve">
          <source>A memory reference that is encoded within the opcode.</source>
          <target state="translated">opcode 내에 인코딩 된 메모리 참조입니다.</target>
        </trans-unit>
        <trans-unit id="9cafdb6d926c7b33945a0f45773363bd841f1c97" translate="yes" xml:space="preserve">
          <source>A memory reference that refers to a constant address of known value.</source>
          <target state="translated">알려진 값의 상수 주소를 나타내는 메모리 참조입니다.</target>
        </trans-unit>
        <trans-unit id="4d28cbf28c6da1c555a93c693a0088131b65d6af" translate="yes" xml:space="preserve">
          <source>A memory reference using &lt;code&gt;AX&lt;/code&gt;, &lt;code&gt;BC&lt;/code&gt;, &lt;code&gt;DE&lt;/code&gt;, or &lt;code&gt;HL&lt;/code&gt; for the address, for calls.</source>
          <target state="translated">호출 주소에 &lt;code&gt;AX&lt;/code&gt; , &lt;code&gt;BC&lt;/code&gt; , &lt;code&gt;DE&lt;/code&gt; 또는 &lt;code&gt;HL&lt;/code&gt; 을 사용하는 메모리 참조</target>
        </trans-unit>
        <trans-unit id="ccd702a76b4ec6cf431d1b3b13c087fda1a005cc" translate="yes" xml:space="preserve">
          <source>A memory reference using &lt;code&gt;BC&lt;/code&gt; as a base register, with an optional offset.</source>
          <target state="translated">오프셋을 선택적으로 사용하여 &lt;code&gt;BC&lt;/code&gt; 를 기본 레지스터로 사용하는 메모리 참조</target>
        </trans-unit>
        <trans-unit id="1b8a2311d7274d21eb0ecc9fab5c05d859421673" translate="yes" xml:space="preserve">
          <source>A memory reference using &lt;code&gt;DE&lt;/code&gt; as a base register, with an optional offset.</source>
          <target state="translated">선택적 오프셋을 사용하여 &lt;code&gt;DE&lt;/code&gt; 를 기본 레지스터로 사용하는 메모리 참조</target>
        </trans-unit>
        <trans-unit id="70d9c96a11dbdafd4cd2e7e236553a508e4c91e1" translate="yes" xml:space="preserve">
          <source>A memory reference using &lt;code&gt;DE&lt;/code&gt; as a base register, without any offset.</source>
          <target state="translated">오프셋을 사용하지 않고 &lt;code&gt;DE&lt;/code&gt; 를 기준 레지스터로 사용하는 메모리 참조</target>
        </trans-unit>
        <trans-unit id="e072e18db9eb6bf209deec68cb4227fc0ad73751" translate="yes" xml:space="preserve">
          <source>A memory reference using &lt;code&gt;HL&lt;/code&gt; as a base register, with &lt;code&gt;B&lt;/code&gt; or &lt;code&gt;C&lt;/code&gt; as the index register.</source>
          <target state="translated">&lt;code&gt;HL&lt;/code&gt; 을 기본 레지스터로 사용하고 &lt;code&gt;B&lt;/code&gt; 또는 &lt;code&gt;C&lt;/code&gt; 를 인덱스 레지스터로 사용하는 메모리 참조</target>
        </trans-unit>
        <trans-unit id="df6dc5b742ae15cb0c4a64ea30738791b4c31ce2" translate="yes" xml:space="preserve">
          <source>A memory reference using &lt;code&gt;HL&lt;/code&gt; as a base register, with an optional one-byte offset.</source>
          <target state="translated">선택적 1 바이트 오프셋이있는 &lt;code&gt;HL&lt;/code&gt; 을 기본 레지스터로 사용하는 메모리 참조</target>
        </trans-unit>
        <trans-unit id="ddc26c1495756f4b844ddb7cea2453b5108af343" translate="yes" xml:space="preserve">
          <source>A memory reference using &lt;code&gt;HL&lt;/code&gt; as a base register, without any offset.</source>
          <target state="translated">오프셋없이 &lt;code&gt;HL&lt;/code&gt; 을 기준 레지스터로 사용하는 메모리 참조</target>
        </trans-unit>
        <trans-unit id="dd84b756a68010a9ef8c97c933ab58752c08401e" translate="yes" xml:space="preserve">
          <source>A memory reference using &lt;code&gt;SP&lt;/code&gt; as a base register, with an optional one-byte offset.</source>
          <target state="translated">선택적 1 바이트 오프셋을 사용하여 &lt;code&gt;SP&lt;/code&gt; 를 기본 레지스터로 사용하는 메모리 참조</target>
        </trans-unit>
        <trans-unit id="8838226960a63f5221b0e15609b574e60c61f473" translate="yes" xml:space="preserve">
          <source>A memory reference using any 16-bit register pair for the address, for calls.</source>
          <target state="translated">호출 주소에 16 비트 레지스터 쌍을 사용하는 메모리 참조</target>
        </trans-unit>
        <trans-unit id="4b51e9b71c2545b5652560bf7f6a9647e0035d8a" translate="yes" xml:space="preserve">
          <source>A memory reference where the exact address is in a single register (&amp;lsquo;&amp;lsquo;</source>
          <target state="translated">정확한 주소가 단일 레지스터에있는 메모리 참조 ( ''</target>
        </trans-unit>
        <trans-unit id="0139bd65b0b5d2fe4673870edd7d6641449c58e8" translate="yes" xml:space="preserve">
          <source>A memory reference which requires an additional word (address or offset) after the opcode.</source>
          <target state="translated">opcode 뒤에 추가 단어 (주소 또는 오프셋)가 필요한 메모리 참조입니다.</target>
        </trans-unit>
        <trans-unit id="9a543e86cece309b6602d80f4120038bbc4ab307" translate="yes" xml:space="preserve">
          <source>A memory reference with an absolute address.</source>
          <target state="translated">절대 주소가있는 메모리 참조</target>
        </trans-unit>
        <trans-unit id="287d82bed5f1580615ce42d8bee2ee48ebecfb48" translate="yes" xml:space="preserve">
          <source>A memory transaction commits all changes to memory in an atomic way, as visible to other threads. If the transaction fails it is rolled back and all side effects discarded.</source>
          <target state="translated">메모리 트랜잭션은 다른 스레드에서 볼 수 있듯이 원자 적 방식으로 메모리에 대한 모든 변경 사항을 커밋합니다. 트랜잭션이 실패하면 롤백되고 모든 부작용이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="d7f155128a2791cfe10b2a9e15921858bd575c02" translate="yes" xml:space="preserve">
          <source>A nested function always has no linkage. Declaring one with &lt;code&gt;extern&lt;/code&gt; or &lt;code&gt;static&lt;/code&gt; is erroneous. If you need to declare the nested function before its definition, use &lt;code&gt;auto&lt;/code&gt; (which is otherwise meaningless for function declarations).</source>
          <target state="translated">중첩 함수에는 항상 연결이 없습니다. &lt;code&gt;extern&lt;/code&gt; 또는 &lt;code&gt;static&lt;/code&gt; 으로 선언하는 것은 잘못되었습니다. 중첩 함수를 정의하기 전에 선언해야하는 경우 &lt;code&gt;auto&lt;/code&gt; 를 사용하십시오 (그렇지 않으면 함수 선언에는 의미가 없습니다).</target>
        </trans-unit>
        <trans-unit id="d26414fbc961f98329967917d426b4cbc2efe330" translate="yes" xml:space="preserve">
          <source>A nested function can jump to a label inherited from a containing function, provided the label is explicitly declared in the containing function (see &lt;a href=&quot;local-labels#Local-Labels&quot;&gt;Local Labels&lt;/a&gt;). Such a jump returns instantly to the containing function, exiting the nested function that did the &lt;code&gt;goto&lt;/code&gt; and any intermediate functions as well. Here is an example:</source>
          <target state="translated">포함 함수에서 레이블이 명시 적으로 선언 된 경우 중첩 함수는 포함 함수에서 상속 된 레이블로 이동할 수 있습니다 ( &lt;a href=&quot;local-labels#Local-Labels&quot;&gt;로컬 레이블&lt;/a&gt; 참조 ). 이러한 점프는 포함 함수로 즉시 되돌아 가서 &lt;code&gt;goto&lt;/code&gt; 와 중간 함수를 수행 한 중첩 함수를 종료합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0712d7fc676044f053a72419ea0e38ad815c6a04" translate="yes" xml:space="preserve">
          <source>A new edition of the ISO C standard was published in 1999 as ISO/IEC 9899:1999, and is commonly known as &lt;em&gt;C99&lt;/em&gt;. (While in development, drafts of this standard version were referred to as &lt;em&gt;C9X&lt;/em&gt;.) GCC has substantially complete support for this standard version; see &lt;a href=&quot;http://gcc.gnu.org/c99status.html&quot;&gt;http://gcc.gnu.org/c99status.html&lt;/a&gt; for details. To select this standard, use</source>
          <target state="translated">ISO C 표준의 새로운 버전은 1999 년에 ISO / IEC 9899 : 1999로 출판되었으며 일반적으로 &lt;em&gt;C99&lt;/em&gt; 로 알려져 있습니다 . 개발 &lt;em&gt;중에이&lt;/em&gt; 표준 버전의 초안을 &lt;em&gt;C9X&lt;/em&gt; 라고했습니다 . GCC는이 표준 버전을 실질적으로 완벽하게 지원합니다. 자세한 내용은 &lt;a href=&quot;http://gcc.gnu.org/c99status.html&quot;&gt;http://gcc.gnu.org/c99status.html&lt;/a&gt; 을 참조하십시오. 이 표준을 선택하려면</target>
        </trans-unit>
        <trans-unit id="c1d3e8da2b16b837e350778965a42d38a1727ecd" translate="yes" xml:space="preserve">
          <source>A non-&lt;code&gt;static&lt;/code&gt; function declaration follows a &lt;code&gt;static&lt;/code&gt; one. This construct is not accepted by some traditional C compilers.</source>
          <target state="translated">비 &lt;code&gt;static&lt;/code&gt; 함수 선언은 &lt;code&gt;static&lt;/code&gt; 선언을 따릅니다 . 이 구성은 일부 전통적인 C 컴파일러에서는 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a1561d49e6959fd563ec43b519d5c367906c49ac" translate="yes" xml:space="preserve">
          <source>A number of bytes.</source>
          <target state="translated">많은 바이트.</target>
        </trans-unit>
        <trans-unit id="c6e4f37a3cc64090cf8998b7f43d11b497869792" translate="yes" xml:space="preserve">
          <source>A operand which is read by the instruction can be tied to an earlyclobber operand if its only use as an input occurs before the early result is written. Adding alternatives of this form often allows GCC to produce better code when only some of the read operands can be affected by the earlyclobber. See, for example, the &amp;lsquo;</source>
          <target state="translated">명령으로 읽은 피연산자는 초기 결과가 기록되기 전에 입력으로 만 사용되는 경우 초기 클로버 피연산자에 연결될 수 있습니다. 이 형식의 대안을 추가하면 일부 읽기 피연산자 만 초기 클로버에 의해 영향을받을 수있는 경우 GCC에서 더 나은 코드를 생성 할 수 있습니다. 예를 들어 '</target>
        </trans-unit>
        <trans-unit id="33c89233be593b8efaeda5d8e73bec02c063a6ed" translate="yes" xml:space="preserve">
          <source>A parameter to control whether to use function internal id in profile database lookup. If the value is 0, the compiler uses an id that is based on function assembler name and filename, which makes old profile data more tolerant to source changes such as function reordering etc.</source>
          <target state="translated">프로파일 데이터베이스 검색에서 함수 내부 ID를 사용할지 여부를 제어하는 ​​매개 변수입니다. 값이 0 인 경우, 컴파일러는 함수 어셈블러 이름 및 파일 이름을 기반으로하는 id를 사용하므로 이전 프로파일 데이터는 함수 순서 변경 등과 같은 소스 변경에 더 견딜 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac02409b28e4665594149c1f072d2a778a5e74f5" translate="yes" xml:space="preserve">
          <source>A pointer is compared against integer zero with &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, or &lt;code&gt;&amp;gt;=&lt;/code&gt;.</source>
          <target state="translated">포인터는 정수 0과 &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;gt;=&lt;/code&gt; 과 비교 됩니다.</target>
        </trans-unit>
        <trans-unit id="5e654ce5ba59b63225116cee29f29b754f51ae4a" translate="yes" xml:space="preserve">
          <source>A possibly empty comma-separated list of expressions. For example, &lt;code&gt;format_arg&lt;/code&gt; attributes use this form with the list being a single integer constant expression, and &lt;code&gt;alias&lt;/code&gt; attributes use this form with the list being a single string constant.</source>
          <target state="translated">비어있는 쉼표로 구분 된 표현식 목록입니다. 예를 들어, &lt;code&gt;format_arg&lt;/code&gt; 속성은 목록이 단일 정수 상수 표현식 인 이 양식을 사용 하고 &lt;code&gt;alias&lt;/code&gt; 속성은 목록이 단일 문자열 상수 인이 양식을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6f94ad7a128da59e35cfef4198c05f92370ba7a7" translate="yes" xml:space="preserve">
          <source>A precompiled header cannot be used once the first C token is seen. You can have preprocessor directives before a precompiled header; you cannot include a precompiled header from inside another header.</source>
          <target state="translated">첫 번째 C 토큰을 본 후에는 미리 컴파일 된 헤더를 사용할 수 없습니다. 프리 컴파일 된 헤더 앞에 프리 프로세서 지시문을 가질 수 있습니다. 다른 헤더 안에 미리 컴파일 된 헤더를 포함 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="967ed292b7da3d9c381bae6f412c1eb711012203" translate="yes" xml:space="preserve">
          <source>A precompiled header file can be used only when these conditions apply:</source>
          <target state="translated">사전 컴파일 된 헤더 파일은 다음 조건이 적용되는 경우에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05035041744377e6b9210288a1d05f98595669e6" translate="yes" xml:space="preserve">
          <source>A precompiled header file is searched for when &lt;code&gt;#include&lt;/code&gt; is seen in the compilation. As it searches for the included file (see &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Search-Path.html#Search-Path&quot;&gt;Search Path&lt;/a&gt; in The C Preprocessor) the compiler looks for a precompiled header in each directory just before it looks for the include file in that directory. The name searched for is the name specified in the &lt;code&gt;#include&lt;/code&gt; with &amp;lsquo;</source>
          <target state="translated">컴파일에 &lt;code&gt;#include&lt;/code&gt; 가 표시 되면 미리 컴파일 된 헤더 파일이 검색됩니다 . 포함 된 파일을 검색 할 때 ( C 프리 프로세서의 &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Search-Path.html#Search-Path&quot;&gt;검색 경로&lt;/a&gt; 참조 ) 컴파일러는 해당 디렉토리에서 포함 파일을 찾기 직전에 각 디렉토리에서 사전 컴파일 된 헤더를 찾습니다. 검색된 이름은 &lt;code&gt;#include&lt;/code&gt; 에 '</target>
        </trans-unit>
        <trans-unit id="65201eadf5d675527c7f1ac85fd378b5ccbc08ee" translate="yes" xml:space="preserve">
          <source>A prefix for source file names to remove when generating the output coverage files. This option is useful when building in a separate directory, and the pathname to the source directory is not wanted when determining the output file names. Note that this prefix detection is applied before determining whether the source file is absolute.</source>
          <target state="translated">출력 적용 범위 파일을 생성 할 때 제거 할 소스 파일 이름의 접 두부입니다. 이 옵션은 별도의 디렉토리에 빌드 할 때 유용하며 출력 파일 이름을 결정할 때 소스 디렉토리의 경로 이름을 원하지 않습니다. 이 접두사 탐지는 소스 파일이 절대인지 여부를 결정하기 전에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="2f9dfd11eaa793c8913662662201289a00fcaafa" translate="yes" xml:space="preserve">
          <source>A program which performs file I/O and is destined to run on an MCM target should be linked with this option. It causes the libraries libc.a and libdebug.a to be linked. The program should be run on the target under the control of the GDB remote debugging stub.</source>
          <target state="translated">파일 I / O를 수행하고 MCM 대상에서 실행될 예정인 프로그램은이 옵션과 연결되어야합니다. libc.a 및 libdebug.a 라이브러리가 링크됩니다. 프로그램은 GDB 원격 디버깅 스텁의 제어하에 대상에서 실행되어야합니다.</target>
        </trans-unit>
        <trans-unit id="06091d7b0985c9e8feba549f19d66a548c218908" translate="yes" xml:space="preserve">
          <source>A program which performs file I/O and is destined to run on the simulator should be linked with option. This causes libraries libc.a and libsim.a to be linked.</source>
          <target state="translated">파일 I / O를 수행하고 시뮬레이터에서 실행될 예정인 프로그램은 옵션과 연결되어야합니다. 이로 인해 라이브러리 libc.a 및 libsim.a가 링크됩니다.</target>
        </trans-unit>
        <trans-unit id="03bc1b8f8194ecc4bd7cc22529202219ccc55928" translate="yes" xml:space="preserve">
          <source>A redeclaration of an entity must not add new ABI tags, since doing so would change the mangled name.</source>
          <target state="translated">개체를 다시 선언하면 맹 글링 된 이름이 변경되므로 새 ABI 태그를 추가해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="72babc8ed783b6f80b238e203c04bb32ab9b7ee7" translate="yes" xml:space="preserve">
          <source>A register indirect memory operand</source>
          <target state="translated">레지스터 간접 메모리 피연산자</target>
        </trans-unit>
        <trans-unit id="822740a74e2ad86073347ee3e0a96d4ea21793b7" translate="yes" xml:space="preserve">
          <source>A register operand is allowed provided that it is in a general register.</source>
          <target state="translated">레지스터 피연산자가 일반 레지스터에 있으면 레지스터 피연산자가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="c6b4e516f4445d7fd0eb4545cb8bd87379ffb2be" translate="yes" xml:space="preserve">
          <source>A register suitable for use in an indirect jump. This will always be &lt;code&gt;$25&lt;/code&gt; for</source>
          <target state="translated">간접 점프에 사용하기에 적합한 레지스터입니다. 이것은 항상 &lt;code&gt;$25&lt;/code&gt; 입니다</target>
        </trans-unit>
        <trans-unit id="bf74def1fd328fca34b37ccd32d0585450fe7d70" translate="yes" xml:space="preserve">
          <source>A register that can hold a 64 bit value.</source>
          <target state="translated">64 비트 값을 보유 할 수있는 레지스터입니다.</target>
        </trans-unit>
        <trans-unit id="40b15fdd982b6acc2dbd0ac15c94e31ec3b3ecb8" translate="yes" xml:space="preserve">
          <source>A revised ISO C++ standard was published in 2011 as ISO/IEC 14882:2011, and is referred to as C++11; before its publication it was commonly referred to as C++0x. C++11 contains several changes to the C++ language, all of which have been implemented in GCC. For details see &lt;a href=&quot;https://gcc.gnu.org/projects/cxx-status.html#cxx11&quot;&gt;https://gcc.gnu.org/projects/cxx-status.html#cxx11&lt;/a&gt;. To select this standard in GCC, use the option</source>
          <target state="translated">개정 된 ISO C ++ 표준은 2011 년 ISO / IEC 14882 : 2011으로 발행되었으며 C ++ 11이라고합니다. 게시 전에는 일반적으로 C ++ 0x라고했습니다. C ++ 11에는 C ++ 언어에 대한 몇 가지 변경 사항이 포함되어 있으며 모두 GCC로 구현되었습니다. 자세한 내용은 &lt;a href=&quot;https://gcc.gnu.org/projects/cxx-status.html#cxx11&quot;&gt;https://gcc.gnu.org/projects/cxx-status.html#cxx11을&lt;/a&gt; 참조 하십시오 . GCC에서이 표준을 선택하려면 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fa1cdaecb062b94545ea6452cf8e926ff17ef618" translate="yes" xml:space="preserve">
          <source>A scalar volatile object is read when it is accessed in a void context:</source>
          <target state="translated">스칼라 휘발성 객체는 void 컨텍스트에서 액세스 할 때 읽습니다.</target>
        </trans-unit>
        <trans-unit id="1be35e4d0dcffaec4e53c70345395a20bb71df65" translate="yes" xml:space="preserve">
          <source>A scaled or unscaled indexed memory operand</source>
          <target state="translated">스케일링되거나 스케일링되지 않은 인덱스 메모리 피연산자</target>
        </trans-unit>
        <trans-unit id="7561d823e8220cc1324112197c014a5470da6511" translate="yes" xml:space="preserve">
          <source>A signed 10-bit constant for most arithmetic instructions.</source>
          <target state="translated">대부분의 산술 명령어에 대한 부호있는 10 비트 상수.</target>
        </trans-unit>
        <trans-unit id="d4172f55ed8446ca35d32bcd89906fb5748ddaf8" translate="yes" xml:space="preserve">
          <source>A signed 11-bit constant added to -1. Can only match when the</source>
          <target state="translated">부호있는 11 비트 상수가 -1에 추가되었습니다. 때만 일치</target>
        </trans-unit>
        <trans-unit id="4dbec6f25e372e0d0975d4d90b4ec971a46651e9" translate="yes" xml:space="preserve">
          <source>A signed 11-bit constant.</source>
          <target state="translated">부호있는 11 비트 상수</target>
        </trans-unit>
        <trans-unit id="c5fd23196153b5c02da9d3addd039cf5332baffd" translate="yes" xml:space="preserve">
          <source>A signed 12-bit integer constant.</source>
          <target state="translated">부호있는 12 비트 정수 상수</target>
        </trans-unit>
        <trans-unit id="5d45116f20daaebe383530883ac080de0bcc23a5" translate="yes" xml:space="preserve">
          <source>A signed 15-bit constant.</source>
          <target state="translated">부호있는 15 비트 상수</target>
        </trans-unit>
        <trans-unit id="5e37ec7562e7c67e3ef533934ac18db7a4d66259" translate="yes" xml:space="preserve">
          <source>A signed 16 bit immediate for &lt;code&gt;stop&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;stop&lt;/code&gt; 위한 부호있는 16 비트 .</target>
        </trans-unit>
        <trans-unit id="5d1f2bec644b602c55ff93653291917c0bee1cb5" translate="yes" xml:space="preserve">
          <source>A signed 16-bit constant (for arithmetic instructions).</source>
          <target state="translated">부호있는 16 비트 상수 (산술 명령어 용).</target>
        </trans-unit>
        <trans-unit id="1040a418b2933ba39c0db5d1c19b995428a5db61" translate="yes" xml:space="preserve">
          <source>A signed 16-bit constant shifted left 16 bits.</source>
          <target state="translated">A signed 16-bit constant shifted left 16 bits.</target>
        </trans-unit>
        <trans-unit id="426c500fe95b660ec71d2075e660305546d46c08" translate="yes" xml:space="preserve">
          <source>A signed 16-bit constant.</source>
          <target state="translated">A signed 16-bit constant.</target>
        </trans-unit>
        <trans-unit id="6e07498a95ff964b95b70f9332548c0e101c48af" translate="yes" xml:space="preserve">
          <source>A signed 32-bit constant in which the lower 16 bits are zero. Such constants can be loaded using &lt;code&gt;lui&lt;/code&gt;.</source>
          <target state="translated">하위 16 비트가 0 인 부호있는 32 비트 상수. 이러한 상수는 &lt;code&gt;lui&lt;/code&gt; 를 사용하여로드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="536e9bf9352073c69bfd1331260c3d50c75e4c4c" translate="yes" xml:space="preserve">
          <source>A signed 34-bit integer constant if prefixed instructions are supported.</source>
          <target state="translated">A signed 34-bit integer constant if prefixed instructions are supported.</target>
        </trans-unit>
        <trans-unit id="3a13d86f9687e787e9b67a4048c3e6f6a0a655af" translate="yes" xml:space="preserve">
          <source>A single register. If &lt;var&gt;n&lt;/var&gt; is in the range 0 to 7, the corresponding D register. If it is &lt;code&gt;A&lt;/code&gt;, then the register P0.</source>
          <target state="translated">단일 레지스터. &lt;var&gt;n&lt;/var&gt; 이 0 내지 7의 범위에 있으면 , 대응하는 D 레지스터. 이 경우 , 다음 레지스터 P0. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="862eefd77275509cc300d2e8b64b0bd59d6e0627" translate="yes" xml:space="preserve">
          <source>A specification has the syntax [&amp;lsquo;</source>
          <target state="translated">스펙은 [ '</target>
        </trans-unit>
        <trans-unit id="8b75792a16ebbcbf75343206f45b552f9ca68dac" translate="yes" xml:space="preserve">
          <source>A status register (&lt;code&gt;rmsr&lt;/code&gt;, &lt;code&gt;$fcc1&lt;/code&gt; to &lt;code&gt;$fcc7&lt;/code&gt;).</source>
          <target state="translated">상태 레지스터 ( &lt;code&gt;rmsr&lt;/code&gt; , &lt;code&gt;$fcc1&lt;/code&gt; ~ &lt;code&gt;$fcc7&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="8617da8fc23fdb13a32d7e55b2af3a58c983bdf6" translate="yes" xml:space="preserve">
          <source>A string constant specifying constraints on the placement of the operand; See &lt;a href=&quot;constraints#Constraints&quot;&gt;Constraints&lt;/a&gt;, for details.</source>
          <target state="translated">피연산자의 배치에 대한 제한 조건을 지정하는 문자열 상수. 자세한 내용은 &lt;a href=&quot;constraints#Constraints&quot;&gt;제약 조건&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4bed63450bff092e0c3ca584fb2ddae5e2d82e2a" translate="yes" xml:space="preserve">
          <source>A structure containing a flexible array member, or a union containing such a structure (possibly recursively), may not be a member of a structure or an element of an array. (However, these uses are permitted by GCC as extensions.)</source>
          <target state="translated">가요 성 어레이 부재를 포함하는 구조체, 또는 이러한 구조를 포함하는 결합 (재귀 적으로)은 구조체의 멤버 또는 어레이의 요소가 아닐 수 있습니다. 그러나 이러한 사용은 GCC에서 확장으로 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="13f3f44cecb7edd4bea911bfc4063d4f75195a8c" translate="yes" xml:space="preserve">
          <source>A symbol in the text segment of the current file</source>
          <target state="translated">현재 파일의 텍스트 세그먼트에있는 기호</target>
        </trans-unit>
        <trans-unit id="55a9278d05f000d4c7a06aca9fe905b8fb5008bb" translate="yes" xml:space="preserve">
          <source>A symbol reference.</source>
          <target state="translated">기호 참조.</target>
        </trans-unit>
        <trans-unit id="ceac75b89def52cbcbd311ef92b55a54ff3eba6e" translate="yes" xml:space="preserve">
          <source>A symbolic operand, or a 16-bit fragment of a got, tls, or pc-relative reference.</source>
          <target state="translated">기호 피연산자 또는 got, tls 또는 pc 기준 참조의 16 비트 조각입니다.</target>
        </trans-unit>
        <trans-unit id="bb721a7785396c7acd1586d0fc279449394dcfd8" translate="yes" xml:space="preserve">
          <source>A template with a non-type template parameter of reference type was mangled incorrectly:</source>
          <target state="translated">참조 유형이 아닌 유형이 아닌 템플릿 매개 변수가있는 템플릿이 잘못 엉망이되었습니다.</target>
        </trans-unit>
        <trans-unit id="3af936ccb51639cb634f6ac0a1e094ce5a6bd006" translate="yes" xml:space="preserve">
          <source>A text segment (program memory) constant label.</source>
          <target state="translated">A text segment (program memory) constant label.</target>
        </trans-unit>
        <trans-unit id="2953b18cce576e52d1d65cb76238b4c46802eda8" translate="yes" xml:space="preserve">
          <source>A threshold on the average loop count considered by the swing modulo scheduler.</source>
          <target state="translated">스윙 모듈로 스케줄러가 고려한 평균 루프 수에 대한 임계 값입니다.</target>
        </trans-unit>
        <trans-unit id="7b4948261ad39b1701b8001a691f2c0f51ef54c3" translate="yes" xml:space="preserve">
          <source>A trampoline is a small piece of code that is created at run time on the stack when the address of a nested function is taken, and is used to call the nested function indirectly. Therefore, it requires the stack to be made executable in order for the program to work properly.</source>
          <target state="translated">트램폴린은 중첩 함수의 주소를 가져올 때 스택에서 런타임에 만들어지고 중첩 함수를 간접적으로 호출하는 데 사용되는 작은 코드 조각입니다. 따라서 프로그램이 제대로 작동하려면 스택을 실행 가능하게 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="78cd7e495c30fc4bf5a59f6f14ffc8c61dbbd59b" translate="yes" xml:space="preserve">
          <source>A true dependence from store to load is costly.</source>
          <target state="translated">상점마다로드에 대한 진정한 의존성은 비용이 많이 듭니다.</target>
        </trans-unit>
        <trans-unit id="5307fd85f09fc936e5444911a1b34c9fbd27e507" translate="yes" xml:space="preserve">
          <source>A typical use of this option is building a kernel that does not use, and hence need not save and restore, any floating-point registers.</source>
          <target state="translated">이 옵션의 일반적인 사용은 부동 소수점 레지스터를 사용하지 않으므로 커널을 빌드하여 저장 및 복원 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="7040b335818f1c7fc002704e20a47588f7532dc4" translate="yes" xml:space="preserve">
          <source>A valid &lt;code&gt;NULL&lt;/code&gt; in this context is defined as zero with any object pointer type. If your system defines the &lt;code&gt;NULL&lt;/code&gt; macro with an integer type then you need to add an explicit cast. During installation GCC replaces the system &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt; header with a copy that redefines NULL appropriately.</source>
          <target state="translated">이 컨텍스트에서 유효한 &lt;code&gt;NULL&lt;/code&gt; 은 객체 포인터 유형에서 0으로 정의됩니다. 시스템 이 정수 유형으로 &lt;code&gt;NULL&lt;/code&gt; 매크로를 정의하는 경우 명시 적 캐스트를 추가해야합니다. 설치하는 동안 GCC는 시스템 &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt; 헤더를 NULL을 적절히 재정의하는 사본으로 바꿉니다 .</target>
        </trans-unit>
        <trans-unit id="02bba8846c50f28733626cee0f5e6cd6eae5f547" translate="yes" xml:space="preserve">
          <source>A value for this option must be provided; possible values are</source>
          <target state="translated">이 옵션의 값을 제공해야합니다. 가능한 값은</target>
        </trans-unit>
        <trans-unit id="28bdc15a4774baf30748fb10f9a39ee9576d0acc" translate="yes" xml:space="preserve">
          <source>A value of -1 means we don&amp;rsquo;t have a threshold and therefore prefetch hints can be issued for any constant stride.</source>
          <target state="translated">값이 -1이면 임계 값이 없으므로 모든 보폭에 대해 프리 페치 힌트를 발행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77182ee8e74fbc85f274ec34ad0d067f9159c03c" translate="yes" xml:space="preserve">
          <source>A vector constant</source>
          <target state="translated">벡터 상수</target>
        </trans-unit>
        <trans-unit id="25a5a3c85e4d61bb20e699b708ea293eab97d102" translate="yes" xml:space="preserve">
          <source>A vector constant is a list of constant expressions within curly braces.</source>
          <target state="translated">벡터 상수는 중괄호 안에있는 상수 식 목록입니다.</target>
        </trans-unit>
        <trans-unit id="4903fd385e6b83744a3f7241ee469fe297e3d890" translate="yes" xml:space="preserve">
          <source>A vector initializer requires no cast if the vector constant is of the same type as the variable it is initializing.</source>
          <target state="translated">벡터 상수가 초기화하는 변수와 유형이 같으면 벡터 초기화 프로그램에 캐스트가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6ce3f2c4c36ebf953052d74dd8cf41bfa72eda5d" translate="yes" xml:space="preserve">
          <source>A weak reference is an alias that does not by itself require a definition to be given for the target symbol. If the target symbol is only referenced through weak references, then it becomes a &lt;code&gt;weak&lt;/code&gt; undefined symbol. If it is directly referenced, however, then such strong references prevail, and a definition is required for the symbol, not necessarily in the same translation unit.</source>
          <target state="translated">약한 참조는 자체적으로 대상 기호에 대한 정의가 필요하지 않은 별명입니다. 대상 기호가 약한 참조를 통해서만 참조되는 경우 &lt;code&gt;weak&lt;/code&gt; 정의되지 않은 기호가됩니다. 그러나 직접 참조하는 경우, 그러한 강력한 참조가 우선하며, 반드시 동일한 번역 단위에 해당되는 것이 아니라 기호에 대한 정의가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="74b379dc012a6dcd931f8c8cdffa0c221d2777a0" translate="yes" xml:space="preserve">
          <source>AArch64</source>
          <target state="translated">AArch64</target>
        </trans-unit>
        <trans-unit id="d83fa522cc15ecf666a6fc12658b5e4cd5fdc010" translate="yes" xml:space="preserve">
          <source>AArch64 family&amp;mdash;</source>
          <target state="translated">AArch64 제품군 &amp;mdash;</target>
        </trans-unit>
        <trans-unit id="4957a12f9c33bdb7711f6bad443bcf1b59bf30ce" translate="yes" xml:space="preserve">
          <source>ABI conformance</source>
          <target state="translated">ABI 적합성</target>
        </trans-unit>
        <trans-unit id="b14e4cc3f9a03a17ac3f6123a6226b7b7d34c952" translate="yes" xml:space="preserve">
          <source>ADDENDUM: How to use this License for your documents</source>
          <target state="translated">부록 : 문서에이 라이센스를 사용하는 방법</target>
        </trans-unit>
        <trans-unit id="1f0161097b4d6be2ad809b71f0ab06f4ccc56e03" translate="yes" xml:space="preserve">
          <source>AES instructions.</source>
          <target state="translated">AES 지침.</target>
        </trans-unit>
        <trans-unit id="bd84aa567f4fd80f10ee4bdc1fff46ff3f84291a" translate="yes" xml:space="preserve">
          <source>AIX TOC entry</source>
          <target state="translated">AIX TOC 항목</target>
        </trans-unit>
        <trans-unit id="00c79d98f4ab13b1e68350376a159f81803c3f05" translate="yes" xml:space="preserve">
          <source>AIX on the RS/6000 provides support (NLS) for environments outside of the United States. Compilers and assemblers use NLS to support locale-specific representations of various objects including floating-point numbers (&amp;lsquo;</source>
          <target state="translated">RS / 6000의 AIX는 미국 이외의 환경에 대한 지원 (NLS)을 제공합니다. 컴파일러와 어셈블러는 NLS를 사용하여 부동 소수점 숫자를 포함하여 다양한 객체의 로케일 별 표현을 지원합니다 ( '</target>
        </trans-unit>
        <trans-unit id="6b42874e3cd20771d93096ec5ce36307a1f2ba14" translate="yes" xml:space="preserve">
          <source>ALL</source>
          <target state="translated">ALL</target>
        </trans-unit>
        <trans-unit id="e38876cb454c616d20b014174318cd23549c31b5" translate="yes" xml:space="preserve">
          <source>AM33</source>
          <target state="translated">AM33</target>
        </trans-unit>
        <trans-unit id="b0f3c857fc3329c9a7706ca2852892a64907ff92" translate="yes" xml:space="preserve">
          <source>AMD Athlon CPU with MMX, 3dNOW!, enhanced 3DNow! and SSE prefetch instructions support.</source>
          <target state="translated">MMX, 3dNOW !, 향상된 3DNow!를 갖춘 AMD Athlon CPU! 및 SSE 프리 페치 명령어 지원.</target>
        </trans-unit>
        <trans-unit id="9782812fedc19dae1f691ec0b75b46ce928e9504" translate="yes" xml:space="preserve">
          <source>AMD CPU.</source>
          <target state="translated">AMD CPU.</target>
        </trans-unit>
        <trans-unit id="4b7804a001f508699c3a5d535226c1c43f89e201" translate="yes" xml:space="preserve">
          <source>AMD Family 10h Barcelona CPU.</source>
          <target state="translated">AMD Family 10h 바르셀로나 CPU.</target>
        </trans-unit>
        <trans-unit id="f2f426233bd9b4aec7ad7f0935ada0d98f23dc6d" translate="yes" xml:space="preserve">
          <source>AMD Family 10h CPU.</source>
          <target state="translated">AMD 제품군 10h CPU.</target>
        </trans-unit>
        <trans-unit id="a221df99534b6cfd9cc25151f5b88b631e6b6c74" translate="yes" xml:space="preserve">
          <source>AMD Family 10h Istanbul CPU.</source>
          <target state="translated">AMD Family 10h 이스탄불 CPU.</target>
        </trans-unit>
        <trans-unit id="3c8a317ded567872f2b86eb3a9b2b3142383086c" translate="yes" xml:space="preserve">
          <source>AMD Family 10h Shanghai CPU.</source>
          <target state="translated">AMD 패밀리 10h 상하이 CPU.</target>
        </trans-unit>
        <trans-unit id="3a481ec8025706c39f85bf8a74294ffb3a885a4c" translate="yes" xml:space="preserve">
          <source>AMD Family 14h CPU.</source>
          <target state="translated">AMD 제품군 14 시간 CPU.</target>
        </trans-unit>
        <trans-unit id="d69f21954e9736613dfdcb1541757a89581cb747" translate="yes" xml:space="preserve">
          <source>AMD Family 15h Bulldozer version 1.</source>
          <target state="translated">AMD 제품군 15h 불도저 버전 1.</target>
        </trans-unit>
        <trans-unit id="41ba99ffd8cd8d92353e0abf0591f609003e91a0" translate="yes" xml:space="preserve">
          <source>AMD Family 15h Bulldozer version 2.</source>
          <target state="translated">AMD 제품군 15h 불도저 버전 2.</target>
        </trans-unit>
        <trans-unit id="c106e6d754b124070881cb0e9b5ffaec83f58ff6" translate="yes" xml:space="preserve">
          <source>AMD Family 15h Bulldozer version 3.</source>
          <target state="translated">AMD 제품군 15h 불도저 버전 3.</target>
        </trans-unit>
        <trans-unit id="162b040bafc7dbe0fec77eb2f6b3a8372fec8cf0" translate="yes" xml:space="preserve">
          <source>AMD Family 15h Bulldozer version 4.</source>
          <target state="translated">AMD 제품군 15h 불도저 버전 4.</target>
        </trans-unit>
        <trans-unit id="8b550c62094801a9eaabc1a10c1588d01074f61b" translate="yes" xml:space="preserve">
          <source>AMD Family 15h CPU.</source>
          <target state="translated">AMD 제품군 15 시간 CPU.</target>
        </trans-unit>
        <trans-unit id="6adbeef26c0c63ee2016d0b2ac6031e70f73f984" translate="yes" xml:space="preserve">
          <source>AMD Family 15h core based CPUs with x86-64 instruction set support. (This supersets BMI, BMI2, TBM, F16C, FMA, FMA4, FSGSBASE, AVX, AVX2, XOP, LWP, AES, PCLMUL, CX16, MOVBE, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM and 64-bit instruction set extensions.)</source>
          <target state="translated">AMD Family 15h core based CPUs with x86-64 instruction set support. (This supersets BMI, BMI2, TBM, F16C, FMA, FMA4, FSGSBASE, AVX, AVX2, XOP, LWP, AES, PCLMUL, CX16, MOVBE, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM and 64-bit instruction set extensions.)</target>
        </trans-unit>
        <trans-unit id="3dc29f9ebb58544eff2350911f186ade2077e9e7" translate="yes" xml:space="preserve">
          <source>AMD Family 15h core based CPUs with x86-64 instruction set support. (This supersets BMI, BMI2, TBM, F16C, FMA, FMA4, FSGSBASE, AVX, AVX2, XOP, LWP, AES, PCL_MUL, CX16, MOVBE, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM and 64-bit instruction set extensions.</source>
          <target state="translated">x86-64 명령어 세트를 지원하는 AMD 제품군 15h 코어 기반 CPU. (이는 BMI, BMI2, TBM, F16C, FMA, FMA4, FSGSBASE, AVX, AVX2, XOP, LWP, AES, PCL_MUL, CX16, MOVBE, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4를 슈퍼 셋으로 설정합니다. .2, ABM 및 64 비트 명령어 세트 확장.</target>
        </trans-unit>
        <trans-unit id="afaafd936d606f23e0204241163cd5538d5327ed" translate="yes" xml:space="preserve">
          <source>AMD Family 15h core based CPUs with x86-64 instruction set support. (This supersets BMI, TBM, F16C, FMA, FMA4, AVX, XOP, LWP, AES, PCLMUL, CX16, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM and 64-bit instruction set extensions.)</source>
          <target state="translated">AMD Family 15h core based CPUs with x86-64 instruction set support. (This supersets BMI, TBM, F16C, FMA, FMA4, AVX, XOP, LWP, AES, PCLMUL, CX16, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM and 64-bit instruction set extensions.)</target>
        </trans-unit>
        <trans-unit id="a0473fd00ce817690842cab967b3016ac67c8acc" translate="yes" xml:space="preserve">
          <source>AMD Family 15h core based CPUs with x86-64 instruction set support. (This supersets BMI, TBM, F16C, FMA, FMA4, AVX, XOP, LWP, AES, PCL_MUL, CX16, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM and 64-bit instruction set extensions.)</source>
          <target state="translated">x86-64 명령어 세트를 지원하는 AMD 제품군 15h 코어 기반 CPU. (이것은 BMI, TBM, F16C, FMA, FMA4, AVX, XOP, LWP, AES, PCL_MUL, CX16, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM 및 64 비트를 슈퍼 셋으로 설정합니다. 명령어 세트 확장.)</target>
        </trans-unit>
        <trans-unit id="62e14a811063bd0f1e3f0931b760b915b408af1e" translate="yes" xml:space="preserve">
          <source>AMD Family 15h core based CPUs with x86-64 instruction set support. (This supersets BMI, TBM, F16C, FMA, FMA4, FSGSBASE, AVX, XOP, LWP, AES, PCLMUL, CX16, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM and 64-bit instruction set extensions.)</source>
          <target state="translated">AMD Family 15h core based CPUs with x86-64 instruction set support. (This supersets BMI, TBM, F16C, FMA, FMA4, FSGSBASE, AVX, XOP, LWP, AES, PCLMUL, CX16, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM and 64-bit instruction set extensions.)</target>
        </trans-unit>
        <trans-unit id="4f30ce336c72904fed1286b4744fb02d22539e6b" translate="yes" xml:space="preserve">
          <source>AMD Family 15h core based CPUs with x86-64 instruction set support. (This supersets BMI, TBM, F16C, FMA, FMA4, FSGSBASE, AVX, XOP, LWP, AES, PCL_MUL, CX16, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM and 64-bit instruction set extensions.</source>
          <target state="translated">x86-64 명령어 세트를 지원하는 AMD 제품군 15h 코어 기반 CPU. (이것은 BMI, TBM, F16C, FMA, FMA4, FSGSBASE, AVX, XOP, LWP, AES, PCL_MUL, CX16, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM 및 64를 수퍼 셋합니다. 비트 명령어 세트 확장.</target>
        </trans-unit>
        <trans-unit id="d1222a05e9ab4d223a98fe2b005e9a8fe6f149c1" translate="yes" xml:space="preserve">
          <source>AMD Family 16h CPU.</source>
          <target state="translated">AMD 제품군 16 시간 CPU.</target>
        </trans-unit>
        <trans-unit id="275cd046e8c73f55e5a1e1661fd4caf48dfc118a" translate="yes" xml:space="preserve">
          <source>AMD Family 17h CPU.</source>
          <target state="translated">AMD 제품군 17 시간 CPU.</target>
        </trans-unit>
        <trans-unit id="8605196ce8298328039162c5b2196f5f20eefce6" translate="yes" xml:space="preserve">
          <source>AMD Family 17h Zen version 1.</source>
          <target state="translated">AMD 제품군 17h Zen 버전 1.</target>
        </trans-unit>
        <trans-unit id="7ac5c90de82cdae73bde8fdf83f5571edc22b502" translate="yes" xml:space="preserve">
          <source>AMD Family 17h Zen version 2.</source>
          <target state="translated">AMD 제품군 17h Zen 버전 2.</target>
        </trans-unit>
        <trans-unit id="87a04068ae7b738101f64aab71cef3ecd2846768" translate="yes" xml:space="preserve">
          <source>AMD Family 17h core based CPUs with x86-64 instruction set support. (This supersets BMI, BMI2, ,CLWB, F16C, FMA, FSGSBASE, AVX, AVX2, ADCX, RDSEED, MWAITX, SHA, CLZERO, AES, PCL_MUL, CX16, MOVBE, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM, XSAVEC, XSAVES, CLFLUSHOPT, POPCNT, and 64-bit instruction set extensions.)</source>
          <target state="translated">x86-64 명령어 세트를 지원하는 AMD 제품군 17h 코어 기반 CPU. (이것은 BMI, BMI2,, CLWB, F16C, FMA, FSGSBASE, AVX, AVX2, ADCX, RDSEED, MWAITX, SHA, CLZERO, AES, PCL_MUL, CX16, MOVBE, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM, XSAVEC, XSAVES, CLFLUSHOPT, POPCNT 및 64 비트 명령어 세트 확장.)</target>
        </trans-unit>
        <trans-unit id="26b9464c770316c8957e5f0dd9332edc81fe410d" translate="yes" xml:space="preserve">
          <source>AMD Family 17h core based CPUs with x86-64 instruction set support. (This supersets BMI, BMI2, CLWB, F16C, FMA, FSGSBASE, AVX, AVX2, ADCX, RDSEED, MWAITX, SHA, CLZERO, AES, PCLMUL, CX16, MOVBE, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM, XSAVEC, XSAVES, CLFLUSHOPT, POPCNT, RDPID, WBNOINVD, and 64-bit instruction set extensions.)</source>
          <target state="translated">AMD Family 17h core based CPUs with x86-64 instruction set support. (This supersets BMI, BMI2, CLWB, F16C, FMA, FSGSBASE, AVX, AVX2, ADCX, RDSEED, MWAITX, SHA, CLZERO, AES, PCLMUL, CX16, MOVBE, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM, XSAVEC, XSAVES, CLFLUSHOPT, POPCNT, RDPID, WBNOINVD, and 64-bit instruction set extensions.)</target>
        </trans-unit>
        <trans-unit id="37e7bb5b5f5ab7650fa5577e6308f180e065ef83" translate="yes" xml:space="preserve">
          <source>AMD Family 17h core based CPUs with x86-64 instruction set support. (This supersets BMI, BMI2, F16C, FMA, FSGSBASE, AVX, AVX2, ADCX, RDSEED, MWAITX, SHA, CLZERO, AES, PCLMUL, CX16, MOVBE, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM, XSAVEC, XSAVES, CLFLUSHOPT, POPCNT, and 64-bit instruction set extensions.)</source>
          <target state="translated">AMD Family 17h core based CPUs with x86-64 instruction set support. (This supersets BMI, BMI2, F16C, FMA, FSGSBASE, AVX, AVX2, ADCX, RDSEED, MWAITX, SHA, CLZERO, AES, PCLMUL, CX16, MOVBE, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM, XSAVEC, XSAVES, CLFLUSHOPT, POPCNT, and 64-bit instruction set extensions.)</target>
        </trans-unit>
        <trans-unit id="2ae2f9839ab0c946ebf780350ccb8eeef28b2d89" translate="yes" xml:space="preserve">
          <source>AMD Family 17h core based CPUs with x86-64 instruction set support. (This supersets BMI, BMI2, F16C, FMA, FSGSBASE, AVX, AVX2, ADCX, RDSEED, MWAITX, SHA, CLZERO, AES, PCL_MUL, CX16, MOVBE, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4.1, SSE4.2, ABM, XSAVEC, XSAVES, CLFLUSHOPT, POPCNT, and 64-bit instruction set extensions.</source>
          <target state="translated">x86-64 명령어 세트를 지원하는 AMD 제품군 17h 코어 기반 CPU. (이는 BMI, BMI2, F16C, FMA, FSGSBASE, AVX, AVX2, ADCX, RDSEED, MWAITX, SHA, CLZERO, AES, PCL_MUL, CX16, MOVBE, MMX, SSE, SSE2, SSE3, SSE4A, SSSE3, SSE4를 슈퍼 셋으로 설정합니다. , SSE4.2, ABM, XSAVEC, XSAVES, CLFLUSHOPT, POPCNT 및 64 비트 명령어 세트 확장.</target>
        </trans-unit>
        <trans-unit id="eb46d89908f8744c91b1c4f45dca8a1acd1ccb27" translate="yes" xml:space="preserve">
          <source>AMD GCN &amp;mdash;</source>
          <target state="translated">AMD GCN &amp;mdash;</target>
        </trans-unit>
        <trans-unit id="db735b251e571e72d1b413e2700f9028689a9a1f" translate="yes" xml:space="preserve">
          <source>AMD Geode embedded processor with MMX and 3DNow! instruction set support.</source>
          <target state="translated">MMX 및 3DNow! 명령 세트 지원.</target>
        </trans-unit>
        <trans-unit id="3c8e48e665e983d9bc0d85fc904dca86423a0640" translate="yes" xml:space="preserve">
          <source>AMD K6 CPU with MMX instruction set support.</source>
          <target state="translated">MMX 명령어 세트를 지원하는 AMD K6 CPU.</target>
        </trans-unit>
        <trans-unit id="113a97cdab92673636cc95858168822f55ed3094" translate="yes" xml:space="preserve">
          <source>ANY</source>
          <target state="translated">ANY</target>
        </trans-unit>
        <trans-unit id="c23fd1159b1de92b9f559df33e41326ca8f7ed85" translate="yes" xml:space="preserve">
          <source>ARC &amp;mdash;</source>
          <target state="translated">아크 &amp;mdash;</target>
        </trans-unit>
        <trans-unit id="e3246acd95d4fb7aa3011b3fb00ffb954a2152c1" translate="yes" xml:space="preserve">
          <source>ARC FPX (dpfp) 64-bit registers. &lt;code&gt;D0&lt;/code&gt;, &lt;code&gt;D1&lt;/code&gt;.</source>
          <target state="translated">ARC FPX (dpfp) 64 비트 레지스터. &lt;code&gt;D0&lt;/code&gt; , &lt;code&gt;D1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ccf1f7f060d37f54120246cfa7dc75a263926f6" translate="yes" xml:space="preserve">
          <source>ARC HS SIMD support.</source>
          <target state="translated">ARC HS SIMD 지원.</target>
        </trans-unit>
        <trans-unit id="932a7f099a143287c2dab636f78bab3d7a1ac45d" translate="yes" xml:space="preserve">
          <source>ARC600</source>
          <target state="translated">ARC600</target>
        </trans-unit>
        <trans-unit id="4e11187f8fc082bb81a4560953a7d52297f319ca" translate="yes" xml:space="preserve">
          <source>ARC601</source>
          <target state="translated">ARC601</target>
        </trans-unit>
        <trans-unit id="db9b6f8ec7c62bb078c4ccd2086414ec10283d1a" translate="yes" xml:space="preserve">
          <source>ARC700</source>
          <target state="translated">ARC700</target>
        </trans-unit>
        <trans-unit id="69f32b824b4367437b84027bd88885eef21e2693" translate="yes" xml:space="preserve">
          <source>ARC700-xmac</source>
          <target state="translated">ARC700-xmac</target>
        </trans-unit>
        <trans-unit id="f05a45c9726afd143f3f3902e0d21ab2ae48650f" translate="yes" xml:space="preserve">
          <source>ARC725D</source>
          <target state="translated">ARC725D</target>
        </trans-unit>
        <trans-unit id="c4f837ba2f5ad05063a4e03989e3391dddb8bc79" translate="yes" xml:space="preserve">
          <source>ARC750D</source>
          <target state="translated">ARC750D</target>
        </trans-unit>
        <trans-unit id="29d8dec43e88b47582179de53ef2720d981e8ab1" translate="yes" xml:space="preserve">
          <source>ARM</source>
          <target state="translated">ARM</target>
        </trans-unit>
        <trans-unit id="888c2ab0ae2033359c10fd5cfdf58bbe2d0a940c" translate="yes" xml:space="preserve">
          <source>ARM family&amp;mdash;</source>
          <target state="translated">ARM 제품군</target>
        </trans-unit>
        <trans-unit id="8a9b87087c41304359e59fe26411a54c3b656947" translate="yes" xml:space="preserve">
          <source>ARM targets support two incompatible representations for half-precision floating-point values. You must choose one of the representations and use it consistently in your program.</source>
          <target state="translated">ARM 대상은 반 정밀도 부동 소수점 값에 대해 호환되지 않는 두 가지 표현을 지원합니다. 표현 중 하나를 선택하여 프로그램에서 일관되게 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="c7649225dad7c2a0e06a3df7785837ccbdcddf7e" translate="yes" xml:space="preserve">
          <source>AVR family&amp;mdash;</source>
          <target state="translated">AVR 제품군 &amp;mdash;</target>
        </trans-unit>
        <trans-unit id="b6ce34d1fb413b0acbfa365b9e4b9f6fd56b845e" translate="yes" xml:space="preserve">
          <source>AVX instructions.</source>
          <target state="translated">AVX 지침.</target>
        </trans-unit>
        <trans-unit id="5360c6483b9a9e1df7abdcb4de1b9b5a31a7db4c" translate="yes" xml:space="preserve">
          <source>AVX2 instructions.</source>
          <target state="translated">AVX2 지침.</target>
        </trans-unit>
        <trans-unit id="1d10807c0ae95d634b933c4c91561b625fdd7ee8" translate="yes" xml:space="preserve">
          <source>AVX5124FMAPS instructions.</source>
          <target state="translated">AVX5124FMAPS 지침.</target>
        </trans-unit>
        <trans-unit id="2877f163ba5f992658ca47acc8b1854f3fe91f8e" translate="yes" xml:space="preserve">
          <source>AVX5124VNNIW instructions.</source>
          <target state="translated">AVX5124VNNIW 지침.</target>
        </trans-unit>
        <trans-unit id="6aaaf18e4ab544cbae42a58b9cf1cac769995f49" translate="yes" xml:space="preserve">
          <source>AVX512BITALG instructions.</source>
          <target state="translated">AVX512BITALG 지침.</target>
        </trans-unit>
        <trans-unit id="e6c802e92787ca04a74935e0b7ab771a52b734eb" translate="yes" xml:space="preserve">
          <source>AVX512BW instructions.</source>
          <target state="translated">AVX512BW 지침.</target>
        </trans-unit>
        <trans-unit id="ed3621c799203e17dc8a8e2affcd32cfee406953" translate="yes" xml:space="preserve">
          <source>AVX512CD instructions.</source>
          <target state="translated">AVX512CD 지침.</target>
        </trans-unit>
        <trans-unit id="734e989680da5e12fff96a9678b5efdb7f080ad8" translate="yes" xml:space="preserve">
          <source>AVX512DQ instructions.</source>
          <target state="translated">AVX512DQ 지침.</target>
        </trans-unit>
        <trans-unit id="ab4d6a088fb02d341f438d1a8b690b1d06bd6a6f" translate="yes" xml:space="preserve">
          <source>AVX512ER instructions.</source>
          <target state="translated">AVX512ER 지침.</target>
        </trans-unit>
        <trans-unit id="9e79b06b712a8ed9dc7a5818dbaa8055049287e6" translate="yes" xml:space="preserve">
          <source>AVX512F instructions.</source>
          <target state="translated">AVX512F 지침.</target>
        </trans-unit>
        <trans-unit id="a774d2186ac710be1f1d2b1823b920ecc713d1ba" translate="yes" xml:space="preserve">
          <source>AVX512IFMA instructions.</source>
          <target state="translated">AVX512IFMA 지침.</target>
        </trans-unit>
        <trans-unit id="a01464cdaa2c7a778b9758cae6be675e4fe0b633" translate="yes" xml:space="preserve">
          <source>AVX512PF instructions.</source>
          <target state="translated">AVX512PF 지침.</target>
        </trans-unit>
        <trans-unit id="90f8339b23ce90729e637c7a3a364d024582dd8c" translate="yes" xml:space="preserve">
          <source>AVX512VBMI instructions.</source>
          <target state="translated">AVX512VBMI 지침.</target>
        </trans-unit>
        <trans-unit id="60db97c4b4db27b3430715d1af3a5a33414556d6" translate="yes" xml:space="preserve">
          <source>AVX512VBMI2 instructions.</source>
          <target state="translated">AVX512VBMI2 지침.</target>
        </trans-unit>
        <trans-unit id="4be842cb121c07bbfe15b74f0e979638742b0293" translate="yes" xml:space="preserve">
          <source>AVX512VL instructions.</source>
          <target state="translated">AVX512VL 지침.</target>
        </trans-unit>
        <trans-unit id="644733f8c866e0e47cbcfa44a51986c10011d89b" translate="yes" xml:space="preserve">
          <source>AVX512VNNI instructions.</source>
          <target state="translated">AVX512VNNI 지침.</target>
        </trans-unit>
        <trans-unit id="53a0313f00ad630fa2e77fff34864e43bc34cbe7" translate="yes" xml:space="preserve">
          <source>AVX512VPOPCNTDQ instructions.</source>
          <target state="translated">AVX512VPOPCNTDQ 명령.</target>
        </trans-unit>
        <trans-unit id="94e869970cd001add8f88d68dc06d771dcf6a716" translate="yes" xml:space="preserve">
          <source>Abort the current transaction. When no transaction is active this is a no-op. The &lt;var&gt;status&lt;/var&gt; is an 8-bit constant; its value is encoded in the return value from &lt;code&gt;_xbegin&lt;/code&gt;.</source>
          <target state="translated">현재 거래를 중단하십시오. 활성화 된 트랜잭션이없는 경우 이는 작동하지 않습니다. &lt;var&gt;status&lt;/var&gt; 8 비트의 정수이고; 그 값은 &lt;code&gt;_xbegin&lt;/code&gt; 의 반환 값으로 인코딩됩니다 .</target>
        </trans-unit>
        <trans-unit id="06529d24f685cb943a5ccbec8926618c923b5a20" translate="yes" xml:space="preserve">
          <source>Absolute comparison of two paired-single values (&lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt;, &lt;code&gt;bc1t&lt;/code&gt;/&lt;code&gt;bc1f&lt;/code&gt;).</source>
          <target state="translated">두 쌍의 단일 값 ( &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; , &lt;code&gt;bc1t&lt;/code&gt; / &lt;code&gt;bc1f&lt;/code&gt; )의 절대 비교 .</target>
        </trans-unit>
        <trans-unit id="df073c7d1c50e06cd4608c23a66611cf902ab538" translate="yes" xml:space="preserve">
          <source>Absolute comparison of two scalar values (&lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.&lt;var&gt;fmt&lt;/var&gt;&lt;/code&gt;, &lt;code&gt;bc1t&lt;/code&gt;/&lt;code&gt;bc1f&lt;/code&gt;).</source>
          <target state="translated">두 스칼라 값 ( &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.&lt;var&gt;fmt&lt;/var&gt;&lt;/code&gt; , &lt;code&gt;bc1t&lt;/code&gt; / &lt;code&gt;bc1f&lt;/code&gt; )의 절대 비교 .</target>
        </trans-unit>
        <trans-unit id="f722ac4229dd26c3b68dd80d6e1f64e995895dbe" translate="yes" xml:space="preserve">
          <source>Absolute value (&lt;code&gt;abs.ps&lt;/code&gt;).</source>
          <target state="translated">절대 값 ( &lt;code&gt;abs.ps&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="4daf0f1c1f813e9102db1a5994f1b9e8323b97c9" translate="yes" xml:space="preserve">
          <source>Accept &amp;lsquo;</source>
          <target state="translated">동의하기 '</target>
        </trans-unit>
        <trans-unit id="1b2da276a5f9c648bf9aca0b0668639225e93b2f" translate="yes" xml:space="preserve">
          <source>Accept imaginary, fixed-point, or machine-defined literal number suffixes as GNU extensions. When this option is turned off these suffixes are treated as C++11 user-defined literal numeric suffixes. This is on by default for all pre-C++11 dialects and all GNU dialects:</source>
          <target state="translated">허수, 고정 소수점 또는 기계 정의 리터럴 번호 접미사를 GNU 확장으로 받아들입니다. 이 옵션을 끄면 이러한 접미사는 C ++ 11 사용자 정의 리터럴 숫자 접미사로 처리됩니다. 이것은 모든 C ++ 11 이전 방언과 모든 GNU 방언에 기본적으로 켜져 있습니다 :</target>
        </trans-unit>
        <trans-unit id="a081bde4daabce186fc90fa0db98f145d7ef25aa" translate="yes" xml:space="preserve">
          <source>Accept some non-standard constructs used in Microsoft header files.</source>
          <target state="translated">Microsoft 헤더 파일에 사용 된 일부 비표준 구성을 수락하십시오.</target>
        </trans-unit>
        <trans-unit id="8ce1e6741eac355bc7dded05833655b003ffbcb7" translate="yes" xml:space="preserve">
          <source>Accept some non-standard constructs used in Plan 9 code.</source>
          <target state="translated">Plan 9 코드에 사용 된 일부 비표준 구성을 수락하십시오.</target>
        </trans-unit>
        <trans-unit id="d6ca16d1d2f90084c15b7909650d30bcccb6d876" translate="yes" xml:space="preserve">
          <source>Accept universal character names and extended characters in identifiers. This option is enabled by default for C99 (and later C standard versions) and C++.</source>
          <target state="translated">Accept universal character names and extended characters in identifiers. This option is enabled by default for C99 (and later C standard versions) and C++.</target>
        </trans-unit>
        <trans-unit id="be39a99ef887dbe2361b7a8f01c005db47949d8d" translate="yes" xml:space="preserve">
          <source>Accept universal character names in identifiers. This option is enabled by default for C99 (and later C standard versions) and C++.</source>
          <target state="translated">식별자에 범용 문자 이름을 사용하십시오. 이 옵션은 C99 (및 이후 C 표준 버전) 및 C ++에 기본적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0f43c08aeb944b0a767a69ba0fb81ec15c2500b4" translate="yes" xml:space="preserve">
          <source>Accept variadic functions without named parameters.</source>
          <target state="translated">명명 된 매개 변수없이 가변 함수를 받아들입니다.</target>
        </trans-unit>
        <trans-unit id="045e8c6e57a163b8d206267b0ad429f37b12bd4b" translate="yes" xml:space="preserve">
          <source>Accesses through pointers to types with this attribute are not subject to type-based alias analysis, but are instead assumed to be able to alias any other type of objects. In the context of section 6.5 paragraph 7 of the C99 standard, an lvalue expression dereferencing such a pointer is treated like having a character type. See</source>
          <target state="translated">이 속성을 가진 유형에 대한 포인터를 통한 액세스는 유형 기반 별명 분석의 대상이 아니라 다른 유형의 객체에 별명을 지정할 수 있다고 가정합니다. C99 표준의 섹션 6.5 단락 7의 맥락에서, 그러한 포인터를 참조하는 lvalue 표현식은 문자 유형을 갖는 것으로 취급됩니다. 보다</target>
        </trans-unit>
        <trans-unit id="0e0bf5b2a877ef7b91241baabde260a26b7a132e" translate="yes" xml:space="preserve">
          <source>Accesses to bit-fields even in volatile objects works by accessing larger objects, such as a byte or a word. You cannot rely on what size of object is accessed in order to read or write the bit-field; it may even vary for a given bit-field according to the precise usage.</source>
          <target state="translated">휘발성 객체에서도 비트 필드에 대한 액세스는 바이트 또는 단어와 같은 더 큰 객체에 액세스하여 작동합니다. 비트 필드를 읽거나 쓰기 위해 어떤 크기의 오브젝트에 액세스 할 수 있는지에 대해서는 의존 할 수 없습니다. 정확한 사용법에 따라 주어진 비트 필드마다 다를 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="853e90163908be81a9a0fb1ee291ab1b4ba5a6c2" translate="yes" xml:space="preserve">
          <source>Accesses to non-volatile objects are not ordered with respect to volatile accesses. You cannot use a volatile object as a memory barrier to order a sequence of writes to non-volatile memory. For instance:</source>
          <target state="translated">비 휘발성 개체에 대한 액세스는 휘발성 액세스와 관련하여 정렬되지 않습니다. 비 휘발성 메모리에 쓰기 순서를 지정하기 위해 휘발성 객체를 메모리 장벽으로 사용할 수 없습니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="c072e2c48755b5522f29c41ec4ff83f53ff94a3e" translate="yes" xml:space="preserve">
          <source>Accesses to the variable may be optimized as usual and the register remains available for allocation and use in any computations, provided that observable values of the variable are not affected.</source>
          <target state="translated">변수에 대한 액세스는 평소와 같이 최적화 될 수 있으며 변수의 관찰 가능한 값이 영향을받지 않는 한 레지스터는 할당 및 계산에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d925b3885b30b4085b6d48f83637a9fdd674d3f" translate="yes" xml:space="preserve">
          <source>Accessing data from C programs without using input/output operands (such as by using global symbols directly from the assembler template) may not work as expected. Similarly, calling functions directly from an assembler template requires a detailed understanding of the target assembler and ABI.</source>
          <target state="translated">입력 / 출력 피연산자를 사용하지 않고 (예 : 어셈블러 템플릿에서 직접 전역 기호 사용) C 프로그램에서 데이터에 액세스하면 예상대로 작동하지 않을 수 있습니다. 마찬가지로 어셈블러 템플릿에서 직접 함수를 호출하려면 대상 어셈블러 및 ABI에 대한 자세한 이해가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="aea1f643245ad21355d1a144988c7b86dcf2187a" translate="yes" xml:space="preserve">
          <source>According to the C standard, such an expression is an rvalue whose type is the unqualified version of its original type, i.e. &lt;code&gt;int&lt;/code&gt;. Whether GCC interprets this as a read of the volatile object being pointed to or only as a request to evaluate the expression for its side effects depends on this type.</source>
          <target state="translated">C 표준에 따르면 이러한 표현식은 유형이 원래 유형의 규정되지 않은 버전 인 rvalue입니다 (예 : &lt;code&gt;int&lt;/code&gt; ) . GCC가이를 지적하는 휘발성 개체의 읽기로 해석하는지 또는 부작용에 대한 표현식을 평가하기위한 요청으로 해석할지 여부는이 유형에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="35037aeb8678de2c00ed45aeca3de92268d726be" translate="yes" xml:space="preserve">
          <source>Accumulate an option for &amp;lsquo;</source>
          <target state="translated">'에 대한 옵션을 누적</target>
        </trans-unit>
        <trans-unit id="a3826f28e4e210d0b17ec990e0a882bb608802f9" translate="yes" xml:space="preserve">
          <source>Accumulate outgoing function arguments and acquire/release the needed stack space for outgoing function arguments once in function prologue/epilogue. Without this option, outgoing arguments are pushed before calling a function and popped afterwards.</source>
          <target state="translated">발신 함수 인수를 누적하고 함수 프롤로그 / 에필로그에서 발신 함수 인수에 필요한 스택 공간을 한 번 확보 / 해제합니다. 이 옵션이 없으면, 나가는 인수는 함수를 호출하기 전에 푸시되고 이후에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="dc171ad6354a6828c71d9648018df6749febe991" translate="yes" xml:space="preserve">
          <source>Accumulator register.</source>
          <target state="translated">누산기 레지스터.</target>
        </trans-unit>
        <trans-unit id="554b8869b285c571ad11f29cd87ecd2c94a39e50" translate="yes" xml:space="preserve">
          <source>Ada source code file containing a library unit body (a subprogram or package body). Such files are also called &lt;em&gt;bodies&lt;/em&gt;.</source>
          <target state="translated">라이브러리 단위 본문 (하위 프로그램 또는 패키지 본문)을 포함하는 Ada 소스 코드 파일. 이러한 파일은 &lt;em&gt;body&lt;/em&gt; 라고도 합니다.</target>
        </trans-unit>
        <trans-unit id="4b2989ddb4c2391d408222a27d0f7e97c4843dda" translate="yes" xml:space="preserve">
          <source>Ada source code file that contains a library unit declaration (a declaration of a package, subprogram, or generic, or a generic instantiation), or a library unit renaming declaration (a package, generic, or subprogram renaming declaration). Such files are also called &lt;em&gt;specs&lt;/em&gt;.</source>
          <target state="translated">라이브러리 단위 선언 (패키지, 서브 프로그램 또는 일반 또는 일반 인스턴스화 선언) 또는 라이브러리 단위 이름 바꾸기 선언 (패키지, 일반 또는 서브 프로그램 이름 바꾸기 선언)을 포함하는 Ada 소스 코드 파일. 이러한 파일을 &lt;em&gt;specs&lt;/em&gt; 라고도 합니다.</target>
        </trans-unit>
        <trans-unit id="885d4a696efd6405b314fabe588d5e90299b2183" translate="yes" xml:space="preserve">
          <source>Add &amp;ldquo;thread storage duration&amp;rdquo; to the list in paragraph 1.</source>
          <target state="translated">단락 1의 목록에 &quot;스레드 저장 기간&quot;을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="b86ee756f777d093031a2ef7598a20edf7c225e4" translate="yes" xml:space="preserve">
          <source>Add 8 bytes to an offsettable memory reference. Useful when accessing the high 8 bytes of SSE values. For a memref in (%rax), it generates</source>
          <target state="translated">오프셋 가능한 메모리 참조에 8 바이트를 추가하십시오. 높은 8 바이트의 SSE 값에 액세스 할 때 유용합니다. (% rax)의 memref의 경우</target>
        </trans-unit>
        <trans-unit id="4790fd26dc16d553ca9f40c8e3122f144c79668c" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;__thread&lt;/code&gt; to the list in paragraph 1.</source>
          <target state="translated">단락 1의 목록에 &lt;code&gt;__thread&lt;/code&gt; 를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="a776e64e6b39926909868acf47332b1f06fea4a3" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;__thread&lt;/code&gt; to the list of specifiers in paragraph 3.</source>
          <target state="translated">단락 3의 지정자 목록에 &lt;code&gt;__thread&lt;/code&gt; 를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="7ae62118c00710deaec9ef5e1ca04437d3f24b0d" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;__thread&lt;/code&gt; to the list of storage class specifiers in paragraph 1.</source>
          <target state="translated">단락 1의 스토리지 클래스 지정자 목록에 &lt;code&gt;__thread&lt;/code&gt; 를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="ca9035627ef94891bbb5d203d19159bca7ef3d20" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;__thread&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;__thread&lt;/code&gt; 를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="8d24fa0d264612fefce413cb080bc55058598cb7" translate="yes" xml:space="preserve">
          <source>Add after paragraph 3</source>
          <target state="translated">단락 3 이후에 추가</target>
        </trans-unit>
        <trans-unit id="69d6be3cf4356a47a61429765c19c67c73985946" translate="yes" xml:space="preserve">
          <source>Add after paragraph 4</source>
          <target state="translated">단락 4 이후에 추가</target>
        </trans-unit>
        <trans-unit id="6c93420cec677cdd1b461d1d94e40f0e5ce17fec" translate="yes" xml:space="preserve">
          <source>Add after paragraph 5</source>
          <target state="translated">단락 5 이후에 추가</target>
        </trans-unit>
        <trans-unit id="cf5cebdb7710016b6f480e1dcf7594bfb0735ab9" translate="yes" xml:space="preserve">
          <source>Add after paragraph 6</source>
          <target state="translated">단락 6 이후에 추가</target>
        </trans-unit>
        <trans-unit id="e6ee990db3ecfcd2015326c23234c180361bb454" translate="yes" xml:space="preserve">
          <source>Add code so that program flow &lt;em&gt;arcs&lt;/em&gt; are instrumented. During execution the program records how many times each branch and call is executed and how many times it is taken or returns. On targets that support constructors with priority support, profiling properly handles constructors, destructors and C++ constructors (and destructors) of classes which are used as a type of a global variable.</source>
          <target state="translated">프로그램 흐름 &lt;em&gt;아크&lt;/em&gt; 가 계측 되도록 코드를 추가하십시오 . 실행하는 동안 프로그램은 각 분기 및 호출이 몇 번 실행되었는지와 몇 번이나 가져 오거나 리턴했는지 기록합니다. 우선 순위가 지원되는 생성자를 지원하는 대상에서 프로파일 링은 전역 변수의 유형으로 사용되는 클래스의 생성자, 소멸자 및 C ++ 생성자 (및 소멸자)를 올바르게 처리합니다.</target>
        </trans-unit>
        <trans-unit id="79f504a568cb02675dcb4fa7f761de4ec8eef873" translate="yes" xml:space="preserve">
          <source>Add description attributes to some DWARF DIEs that have no name attribute, such as artificial variables, external references and call site parameter DIEs.</source>
          <target state="translated">인공 변수, 외부 참조 및 호출 사이트 매개 변수 DIE와 같이 이름 속성이없는 일부 DWARF DIE에 설명 속성을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="71433ea39bacba1c32fb50a6079568ad524eb46d" translate="yes" xml:space="preserve">
          <source>Add directory &lt;var&gt;dir&lt;/var&gt; to the list of directories to be searched for</source>
          <target state="translated">디렉토리 추가 &lt;var&gt;dir&lt;/var&gt; 검색 할 디렉토리 목록에</target>
        </trans-unit>
        <trans-unit id="548bf62a1540dcbb0f428d7f5c59cbf2987dcf8a" translate="yes" xml:space="preserve">
          <source>Add new text after paragraph 1</source>
          <target state="translated">단락 1 뒤에 새 텍스트 추가</target>
        </trans-unit>
        <trans-unit id="13e160272edc000ac3b59f7e3c239601278b19a4" translate="yes" xml:space="preserve">
          <source>Add new text after paragraph 6</source>
          <target state="translated">6 항 뒤에 새 텍스트 추가</target>
        </trans-unit>
        <trans-unit id="b0ab0cd8ae6eaeee09a517ab6e0fab22009af14c" translate="yes" xml:space="preserve">
          <source>Add new text before paragraph 3</source>
          <target state="translated">단락 3 이전에 새 텍스트 추가</target>
        </trans-unit>
        <trans-unit id="09310e0a5ba6730b457158c35b8623195000a4a3" translate="yes" xml:space="preserve">
          <source>Add support for multithreading with the &lt;em&gt;dce thread&lt;/em&gt; library under HP-UX. This option sets flags for both the preprocessor and linker.</source>
          <target state="translated">HP-UX 에서 &lt;em&gt;dce 스레드&lt;/em&gt; 라이브러리를 사용하여 멀티 스레딩 지원을 추가하십시오 . 이 옵션은 전처리 기와 링커 모두에 플래그를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="2df2581a5423cd3eaf9365ee07a19f72370b3fc1" translate="yes" xml:space="preserve">
          <source>Add the directory &lt;var&gt;dir&lt;/var&gt; to the list of directories to be searched for header files during preprocessing. If &lt;var&gt;dir&lt;/var&gt; begins with &amp;lsquo;</source>
          <target state="translated">디렉토리 추가 &lt;var&gt;dir&lt;/var&gt; 디렉토리의 목록은 전처리시 헤더 파일을 검색합니다. &lt;var&gt;dir&lt;/var&gt; 이 '로 시작 하면</target>
        </trans-unit>
        <trans-unit id="73c333940f1537361f906bee03e2343442706250" translate="yes" xml:space="preserve">
          <source>Add the framework directory &lt;var&gt;dir&lt;/var&gt; to the head of the list of directories to be searched for header files. These directories are interleaved with those specified by</source>
          <target state="translated">헤더 파일을 검색 할 디렉토리 목록의 헤드에 프레임 워크 디렉토리 &lt;var&gt;dir&lt;/var&gt; 를 추가하십시오 . 이 디렉토리는 다음에 의해 지정된 디렉토리와 인터리브됩니다</target>
        </trans-unit>
        <trans-unit id="6e8c5a8e482b4eb45d5df440bbd4aa57581a1379" translate="yes" xml:space="preserve">
          <source>Additional Floating Types.</source>
          <target state="translated">추가 부동 유형.</target>
        </trans-unit>
        <trans-unit id="fbfd7f5a311b0863e336e4d5dd611078e4f5f005" translate="yes" xml:space="preserve">
          <source>Additional block information may succeed each line, when requested by command line option. The &lt;var&gt;execution_count&lt;/var&gt; is &amp;lsquo;</source>
          <target state="translated">명령 행 옵션으로 요청하면 추가 블록 정보가 각 행에 성공할 수 있습니다. &lt;var&gt;execution_count&lt;/var&gt; 은 '입니다</target>
        </trans-unit>
        <trans-unit id="3a265ea53c72053fec1245e548879142e841e602" translate="yes" xml:space="preserve">
          <source>Additional built-in functions are available for the 64-bit PowerPC family of processors, for efficient use of 128-bit floating point (&lt;code&gt;__float128&lt;/code&gt;) values.</source>
          <target state="translated">128 비트 부동 소수점 ( &lt;code&gt;__float128&lt;/code&gt; ) 값 을 효율적으로 사용하기 위해 64 비트 PowerPC 프로세서 제품군에 추가 내장 기능을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4e400fc31f2b8160db0d8588871c49194b1a49e9" translate="yes" xml:space="preserve">
          <source>Additional floating-point exceptions, rounding modes, environments, and classifications, and their macro names (C99 and C11 7.6, C99 and C11 7.12).</source>
          <target state="translated">추가 부동 소수점 예외, 반올림 모드, 환경 및 분류 및 매크로 이름 (C99 및 C11 7.6, C99 및 C11 7.12).</target>
        </trans-unit>
        <trans-unit id="9b88de1196308385f5d14de9c11ffbabcd4f7f0a" translate="yes" xml:space="preserve">
          <source>Additional post-processing of the returned value may be needed, see &lt;code&gt;__builtin_extract_return_addr&lt;/code&gt;.</source>
          <target state="translated">반환 된 값에 대한 추가 사후 처리가 필요할 수 있습니다 ( &lt;code&gt;__builtin_extract_return_addr&lt;/code&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="7b6fd1bd03704b21e269c633949f84ccf5e8856f" translate="yes" xml:space="preserve">
          <source>Additional registers typically used only in prologues and epilogues: RETS, RETN, RETI, RETX, RETE, ASTAT, SEQSTAT and USP.</source>
          <target state="translated">추가 레지스터는 일반적으로 프롤로그 및 에필로그에만 사용됩니다 : RETS, RETN, RETI, RETX, RETE, ASTAT, SEQSTAT 및 USP.</target>
        </trans-unit>
        <trans-unit id="880c2173ff65c5e972a9e4536af68b63da90141d" translate="yes" xml:space="preserve">
          <source>Additional restrictions are enforced for types with the reverse scalar storage order with regard to the scalar storage order of the target:</source>
          <target state="translated">대상의 스칼라 저장 순서와 관련하여 리버스 스칼라 저장 순서가있는 유형에 대해서는 추가 제한이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="09bc67c6276506971828d824b07903a4f5f9de7b" translate="yes" xml:space="preserve">
          <source>Additionally inlining a function compiled with</source>
          <target state="translated">추가로 컴파일 된 함수 인라인</target>
        </trans-unit>
        <trans-unit id="bf8b67741ce8fd715c05645cbb36737b371211d3" translate="yes" xml:space="preserve">
          <source>Additionally on native AArch64 GNU/Linux systems the value &amp;lsquo;</source>
          <target state="translated">또한 기본 AArch64 GNU / Linux 시스템에서 '</target>
        </trans-unit>
        <trans-unit id="c9983bdb073bd2da3d6b02f0173dccb4761318ac" translate="yes" xml:space="preserve">
          <source>Additionally the &amp;lsquo;</source>
          <target state="translated">또한 '</target>
        </trans-unit>
        <trans-unit id="c32c6fe01da4320e1de2565ba6da0578715fa9c4" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;code&gt;CFStringRefs&lt;/code&gt; (defined by the &lt;code&gt;CoreFoundation&lt;/code&gt; headers) may also be used as format arguments. Note that the relevant headers are only likely to be available on Darwin (OSX) installations. On such installations, the XCode and system documentation provide descriptions of &lt;code&gt;CFString&lt;/code&gt;, &lt;code&gt;CFStringRefs&lt;/code&gt; and associated functions.</source>
          <target state="translated">또한 &lt;code&gt;CFStringRefs&lt;/code&gt; ( &lt;code&gt;CoreFoundation&lt;/code&gt; 헤더로 정의 )를 형식 인수로 사용할 수도 있습니다. 관련 헤더는 Darwin (OSX) 설치에서만 사용할 수 있습니다. 이러한 설치에서 XCode 및 시스템 문서는 &lt;code&gt;CFString&lt;/code&gt; , &lt;code&gt;CFStringRefs&lt;/code&gt; 및 관련 함수에 대한 설명을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="06f45ee380b9da22c173cf9d9231907ee68fe13b" translate="yes" xml:space="preserve">
          <source>Additionally, some messages are logically nested within other messages, reflecting implementation details of the optimization passes.</source>
          <target state="translated">또한 일부 메시지는 최적화 단계의 구현 세부 정보를 반영하여 다른 메시지 내에 논리적으로 중첩됩니다.</target>
        </trans-unit>
        <trans-unit id="0c630e5527eda313a2b833dd18abd8307a6cfdbd" translate="yes" xml:space="preserve">
          <source>Additionally, the architectural extension string may be specified on its own. This can be used to turn on and off particular architectural extensions without having to specify a particular architecture version or core. Example:</source>
          <target state="translated">또한 아키텍처 확장 문자열은 자체적으로 지정할 수 있습니다. 특정 아키텍처 버전 또는 코어를 지정하지 않고도 특정 아키텍처 확장을 켜거나 끄는 데 사용할 수 있습니다. 예:</target>
        </trans-unit>
        <trans-unit id="e68df41b1d7fdc52b01b88eeb29e9ccd6bf7ed5e" translate="yes" xml:space="preserve">
          <source>Additionally, the following architectures, which lack support for the Thumb execution state, are recognized but support is deprecated: &amp;lsquo;</source>
          <target state="translated">또한 Thumb 실행 상태에 대한 지원이없는 다음 아키텍처는 인식되지만 지원은 사용되지 않습니다. '</target>
        </trans-unit>
        <trans-unit id="a870075e1e81be429acf073e584f3d7c7e76cfdf" translate="yes" xml:space="preserve">
          <source>Additionally, the options</source>
          <target state="translated">또한 옵션</target>
        </trans-unit>
        <trans-unit id="62846127f56afc07ef1c01a4fc578e26bdf7e831" translate="yes" xml:space="preserve">
          <source>Additionally, this option can specify that GCC should tune the performance of the code for a big.LITTLE system. Permissible names are: &amp;lsquo;</source>
          <target state="translated">또한이 옵션은 GCC가 big.LITTLE 시스템의 코드 성능을 조정하도록 지정할 수 있습니다. 허용되는 이름은 '</target>
        </trans-unit>
        <trans-unit id="c9b7ac484445343c898ee0befeb5554f44a64e88" translate="yes" xml:space="preserve">
          <source>Additionally, warn when a user-defined literal operator is declared with a literal suffix identifier that doesn&amp;rsquo;t begin with an underscore. Literal suffix identifiers that don&amp;rsquo;t begin with an underscore are reserved for future standardization.</source>
          <target state="translated">또한 사용자 정의 리터럴 연산자가 밑줄로 시작하지 않는 리터럴 접미사 식별자로 선언되면 경고합니다. 밑줄로 시작하지 않는 리터럴 접미어 식별자는 향후 표준화를 위해 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="facde292bf415fbdf09a1828e9e0908e4c617e00" translate="yes" xml:space="preserve">
          <source>Address base register</source>
          <target state="translated">주소베이스 레지스터</target>
        </trans-unit>
        <trans-unit id="ac7731150d1c92cf663f9e708bf71a25213854ca" translate="yes" xml:space="preserve">
          <source>Address base register if 64-bit instructions are enabled or NO_REGS.</source>
          <target state="translated">64 비트 명령어가 활성화되어 있거나 NO_REGS 인 경우 주소베이스 레지스터.</target>
        </trans-unit>
        <trans-unit id="e3421b8898caa7357be908d1653e3653974d758f" translate="yes" xml:space="preserve">
          <source>Address operand that is an indexed or indirect from a register (&amp;lsquo;</source>
          <target state="translated">레지스터에서 색인화되거나 간접적 인 주소 피연산자 ( '</target>
        </trans-unit>
        <trans-unit id="a7b7013cab33d0bd7c179b9b5712968750a0b395" translate="yes" xml:space="preserve">
          <source>Address operand without segment register.</source>
          <target state="translated">세그먼트 레지스터가없는 주소 피연산자</target>
        </trans-unit>
        <trans-unit id="e849277f25d3c4f30a01955b54c92b602f3ff3ef" translate="yes" xml:space="preserve">
          <source>Address register</source>
          <target state="translated">주소 레지스터</target>
        </trans-unit>
        <trans-unit id="a60bc1681a9f62ef4591ab15398d5eb38a430789" translate="yes" xml:space="preserve">
          <source>Address register (general purpose register except r0)</source>
          <target state="translated">주소 레지스터 (r0을 제외한 일반 목적 레지스터)</target>
        </trans-unit>
        <trans-unit id="91d4fb05cb0843e13759b8b72edb33693debf000" translate="yes" xml:space="preserve">
          <source>Address register indirect addressing mode</source>
          <target state="translated">주소 레지스터 간접 어드레싱 모드</target>
        </trans-unit>
        <trans-unit id="3a077484bf2c4ff84f71e4199f510082fe999bf3" translate="yes" xml:space="preserve">
          <source>Address registers</source>
          <target state="translated">주소 레지스터</target>
        </trans-unit>
        <trans-unit id="5759236ebd061a0e0392b44c51e565f6ce6fcc43" translate="yes" xml:space="preserve">
          <source>Address registers when they&amp;rsquo;re 16 bits wide.</source>
          <target state="translated">16 비트 폭의 주소 레지스터.</target>
        </trans-unit>
        <trans-unit id="fdd0e10bf3a4572e30fda31a40f35542043406cf" translate="yes" xml:space="preserve">
          <source>Address registers when they&amp;rsquo;re 24 bits wide.</source>
          <target state="translated">24 비트 폭의 주소 레지스터.</target>
        </trans-unit>
        <trans-unit id="325382a51fa4bc25157b99f44454696d95890fcb" translate="yes" xml:space="preserve">
          <source>Address space identifiers may be used exactly like any other C type qualifier (e.g., &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;volatile&lt;/code&gt;). See the N1275 document for more details.</source>
          <target state="translated">주소 공간 식별자는 다른 C 유형 한정자 (예 : &lt;code&gt;const&lt;/code&gt; 또는 &lt;code&gt;volatile&lt;/code&gt; ) 와 똑같이 사용될 수 있습니다 . 자세한 내용은 N1275 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b5e65d5c203f07ad3d2623301ca2022f82e6bcd0" translate="yes" xml:space="preserve">
          <source>Address space layout randomization (ASLR) can lead to not binary identical PCH files. If you rely on stable PCH file contents disable ASLR when generating PCH files.</source>
          <target state="translated">Address space layout randomization (ASLR) can lead to not binary identical PCH files. If you rely on stable PCH file contents disable ASLR when generating PCH files.</target>
        </trans-unit>
        <trans-unit id="5f0d1ee78feebd358e9ac4716831efeab01368b7" translate="yes" xml:space="preserve">
          <source>Adjacent bit-fields are packed into the same 1-, 2-, or 4-byte allocation unit if the integral types are the same size and if the next bit-field fits into the current allocation unit without crossing the boundary imposed by the common alignment requirements of the bit-fields.</source>
          <target state="translated">정수 유형의 크기가 동일하고 다음 비트 필드가 공통에 의해 부과 된 경계를 넘지 않고 현재 할당 단위에 맞는 경우 인접한 비트 필드는 동일한 1, 2 또는 4 바이트 할당 단위로 압축됩니다. 비트 필드의 정렬 요구 사항.</target>
        </trans-unit>
        <trans-unit id="94636fe0e41073552acb8d30375f7c2b9b7fa2c2" translate="yes" xml:space="preserve">
          <source>After defining a global register variable, for the current compilation unit:</source>
          <target state="translated">현재 컴파일 단위에 대해 글로벌 레지스터 변수를 정의한 후 :</target>
        </trans-unit>
        <trans-unit id="a160b9211c156fcb59476123ceefb14233c30de0" translate="yes" xml:space="preserve">
          <source>After register allocation and post-register allocation instruction splitting, identify arithmetic instructions that compute processor flags similar to a comparison operation based on that arithmetic. If possible, eliminate the explicit comparison operation.</source>
          <target state="translated">레지스터 할당 및 사후 레지스터 할당 명령어 분할 후, 해당 연산에 기초한 비교 연산과 유사한 프로세서 플래그를 계산하는 연산 명령어를 식별합니다. 가능하면 명시 적 비교 작업을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="9cd493414e0c8a63ccc996f89446d267fe9e1e5f" translate="yes" xml:space="preserve">
          <source>After register allocation and post-register allocation instruction splitting, perform a copy-propagation pass to try to reduce scheduling dependencies and occasionally eliminate the copy.</source>
          <target state="translated">레지스터 할당 및 포스트 레지스터 할당 명령 분할 후 카피 전파 패스를 수행하여 스케줄링 종속성을 줄이고 때로는 카피를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="a0c15aec2fc1e009f616402ab13a6a8f9c982cca" translate="yes" xml:space="preserve">
          <source>After running a program compiled with</source>
          <target state="translated">로 컴파일 된 프로그램을 실행 한 후</target>
        </trans-unit>
        <trans-unit id="1454e9ea83225a76df4ee5fd8a44b04ac91ebb88" translate="yes" xml:space="preserve">
          <source>After the prefix, there must be one or more additional constraints (see &lt;a href=&quot;constraints#Constraints&quot;&gt;Constraints&lt;/a&gt;) that describe where the value resides. Common constraints include &amp;lsquo;</source>
          <target state="translated">접두사 후, 하나 개 이상의 추가 제약 (참조가 있어야 &lt;a href=&quot;constraints#Constraints&quot;&gt;제약을&lt;/a&gt; 경우 값이 상주을 설명). 공통 제약 조건에는 '</target>
        </trans-unit>
        <trans-unit id="87d629b413e62d8e858ca1323306d594503312be" translate="yes" xml:space="preserve">
          <source>Again, the call to &lt;code&gt;f()&lt;/code&gt; is not dependent on template arguments (there are no arguments that depend on the type &lt;code&gt;T&lt;/code&gt;, and it is also not otherwise specified that the call should be in a dependent context). Thus a global declaration of such a function must be available, since the one in the base class is not visible until instantiation time. The compiler will consequently produce the following error message:</source>
          <target state="translated">다시 &lt;code&gt;f()&lt;/code&gt; 대한 호출 은 템플릿 인수에 의존하지 않습니다 ( &lt;code&gt;T&lt;/code&gt; 형에 의존하는 인수가 없으며 호출이 종속 컨텍스트에 있어야한다고 지정되지 않음). 따라서 기본 클래스의 선언은 인스턴스화 시간까지 보이지 않기 때문에 이러한 함수의 전역 선언을 사용할 수 있어야합니다. 결과적으로 컴파일러는 다음과 같은 오류 메시지를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="e15a8d239570fd7618da66d01432b0ca503636ad" translate="yes" xml:space="preserve">
          <source>Aggregates with this attribute are invalid, even if they are of the same size as a corresponding scalar. For example, the declaration:</source>
          <target state="translated">이 속성을 가진 집계는 해당 스칼라와 크기가 같더라도 유효하지 않습니다. 예를 들어, 선언 :</target>
        </trans-unit>
        <trans-unit id="9ffe001744d57fb7d843a75b3de19edfb4a4cd40" translate="yes" xml:space="preserve">
          <source>Aliases of</source>
          <target state="translated">의 별칭</target>
        </trans-unit>
        <trans-unit id="2f7b5a2fcf03ab39f29a64817524ffd647a4fc18" translate="yes" xml:space="preserve">
          <source>Align all branch targets to a power-of-two boundary.</source>
          <target state="translated">모든 분기 대상을 2의 제곱 경계에 맞 춥니 다.</target>
        </trans-unit>
        <trans-unit id="784e20f54ecda5213d66bcc1bc3f5f199a64e7ea" translate="yes" xml:space="preserve">
          <source>Align all loops to a 32-byte boundary.</source>
          <target state="translated">모든 루프를 32 바이트 경계에 맞 춥니 다.</target>
        </trans-unit>
        <trans-unit id="a2e1e4cb8c2ddc659aedc1c3a6dfffeb002bdbe7" translate="yes" xml:space="preserve">
          <source>Align branch targets to a power-of-two boundary, for branch targets where the targets can only be reached by jumping. In this case, no dummy operations need be executed.</source>
          <target state="translated">점프만으로 목표에 도달 할 수있는 분기 목표에 대해 분기 목표를 2의 제곱 경계에 맞 춥니 다. 이 경우 더미 작업을 실행할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="2e8345e97e639fae1caa53fafd777f32b2148811" translate="yes" xml:space="preserve">
          <source>Align doubles at 64-bit boundaries. Note that this changes the calling conventions, and thus some functions from the standard C library do not work unless you recompile it first with</source>
          <target state="translated">64 비트 경계에서 배가 정렬 이것은 호출 규칙을 변경하므로 표준 C 라이브러리의 일부 함수는 먼저 다시 컴파일하지 않으면 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="36a2b427b91139b8587d4cbfe16eb7a63f8affad" translate="yes" xml:space="preserve">
          <source>Align loops to a power-of-two boundary. If the loops are executed many times, this makes up for any execution of the dummy padding instructions.</source>
          <target state="translated">루프를 2의 제곱 경계에 맞 춥니 다. 루프가 여러 번 실행되면 더미 패딩 명령어를 실행할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fb4c088e2c0ec9d07a3a585878097d5ea3d18362" translate="yes" xml:space="preserve">
          <source>Align the start of functions to the next power-of-two greater than &lt;var&gt;n&lt;/var&gt;, skipping up to &lt;var&gt;m&lt;/var&gt;-1 bytes. This ensures that at least the first &lt;var&gt;m&lt;/var&gt; bytes of the function can be fetched by the CPU without crossing an &lt;var&gt;n&lt;/var&gt;-byte alignment boundary.</source>
          <target state="translated">최대 &lt;var&gt;m&lt;/var&gt; -1 바이트 를 건너 뛰면서 &lt;var&gt;n&lt;/var&gt; 보다 큰 다음 2의 제곱에 함수의 시작을 정렬하십시오 . 이는 &lt;var&gt;n&lt;/var&gt; 바이트 정렬 경계를 넘지 않고 CPU에서 함수 의 첫 번째 &lt;var&gt;m&lt;/var&gt; 바이트 이상을 페치 할 수 있도록 합니다.</target>
        </trans-unit>
        <trans-unit id="c4d41afbffbc15906243cd5ff7feb6499dec3822" translate="yes" xml:space="preserve">
          <source>Align the start of functions to the next power-of-two greater than or equal to &lt;var&gt;n&lt;/var&gt;, skipping up to &lt;var&gt;m&lt;/var&gt;-1 bytes. This ensures that at least the first &lt;var&gt;m&lt;/var&gt; bytes of the function can be fetched by the CPU without crossing an &lt;var&gt;n&lt;/var&gt;-byte alignment boundary.</source>
          <target state="translated">Align the start of functions to the next power-of-two greater than or equal to &lt;var&gt;n&lt;/var&gt; , skipping up to &lt;var&gt;m&lt;/var&gt; -1 bytes. This ensures that at least the first &lt;var&gt;m&lt;/var&gt; bytes of the function can be fetched by the CPU without crossing an &lt;var&gt;n&lt;/var&gt; -byte alignment boundary.</target>
        </trans-unit>
        <trans-unit id="790e74268060e0e6ade88cfb9c482c2bc048f9d0" translate="yes" xml:space="preserve">
          <source>Align variable (&lt;code&gt;alnv.ps&lt;/code&gt;).</source>
          <target state="translated">변수를 정렬합니다 ( &lt;code&gt;alnv.ps&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6a72085653e4c5be8c7640c868ef787cbcf063d1" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">All</target>
        </trans-unit>
        <trans-unit id="19bd4f0f0123a61d6b94fd1f26c48a5b466015b1" translate="yes" xml:space="preserve">
          <source>All condition registers: SCC, VCCZ, EXECZ</source>
          <target state="translated">모든 조건 레지스터 : SCC, VCCZ, EXECZ</target>
        </trans-unit>
        <trans-unit id="0ebe806ad92438745f4bad14dde213851c8a70c2" translate="yes" xml:space="preserve">
          <source>All dependences are costly.</source>
          <target state="translated">모든 의존은 비싸다.</target>
        </trans-unit>
        <trans-unit id="0cca1530229b7b9e550b891f9a9b113625c13de2" translate="yes" xml:space="preserve">
          <source>All files specified by</source>
          <target state="translated">에 의해 지정된 모든 파일</target>
        </trans-unit>
        <trans-unit id="0eaba1cfa9a00eb4bd0b12d5b7310a8e6e1fa4c5" translate="yes" xml:space="preserve">
          <source>All implicitly popped input registers must be closer to the top of the reg-stack than any input that is not implicitly popped.</source>
          <target state="translated">내재적으로 팝된 모든 입력 레지스터는 내재적으로 팝되지 않은 입력보다 reg-stack의 상단에 더 가깝습니다.</target>
        </trans-unit>
        <trans-unit id="3b1c013be47e44ec0e7b3eeaa220c1f24b9203e3" translate="yes" xml:space="preserve">
          <source>All memory orders are valid.</source>
          <target state="translated">모든 메모리 주문이 유효합니다.</target>
        </trans-unit>
        <trans-unit id="71ff0e08a090942eb8e784cba6de91a4fd99fb49" translate="yes" xml:space="preserve">
          <source>All modules should be compiled with the same</source>
          <target state="translated">모든 모듈은 동일하게 컴파일되어야합니다</target>
        </trans-unit>
        <trans-unit id="f0bcaa344128e72d0d5e1b94c3b2fa0090b0e882" translate="yes" xml:space="preserve">
          <source>All objects that have neither thread storage duration, dynamic storage duration nor are local [&amp;hellip;].</source>
          <target state="translated">스레드 스토리지 기간, 동적 스토리지 기간이 없거나 로컬 [&amp;hellip;]이 아닌 모든 오브젝트.</target>
        </trans-unit>
        <trans-unit id="ec2545f5d42fce7e86616e30c2d782de4749997a" translate="yes" xml:space="preserve">
          <source>All of the routines are described in the Intel documentation to take &amp;ldquo;an optional list of variables protected by the memory barrier&amp;rdquo;. It&amp;rsquo;s not clear what is meant by that; it could mean that &lt;em&gt;only&lt;/em&gt; the listed variables are protected, or it could mean a list of additional variables to be protected. The list is ignored by GCC which treats it as empty. GCC interprets an empty list as meaning that all globally accessible variables should be protected.</source>
          <target state="translated">모든 루틴은&amp;ldquo;메모리 장벽에 의해 보호되는 변수의 선택적 목록&amp;rdquo;을 취하기 위해 인텔 설명서에 설명되어 있습니다. 그 의미가 무엇인지는 확실하지 않습니다. 그것은 수도 있다는 뜻 &lt;em&gt;에만&lt;/em&gt; 나열된 변수가 보호되고, 또는 추가적인 변수의 목록은 보호되어야 의미 할 수 있었다. 이 목록은 GCC에 의해 무시되며이를 빈 것으로 취급합니다. GCC는 빈 목록을 전역 적으로 액세스 가능한 모든 변수를 보호해야한다는 의미로 해석합니다.</target>
        </trans-unit>
        <trans-unit id="2dc38cb28fe09de761809c6899ec0dfab5c95980" translate="yes" xml:space="preserve">
          <source>All other attributes</source>
          <target state="translated">다른 모든 속성</target>
        </trans-unit>
        <trans-unit id="4e1fe3c41d4a92f980feaffab352908a5ae600b4" translate="yes" xml:space="preserve">
          <source>All the above</source>
          <target state="translated">모든것 위에</target>
        </trans-unit>
        <trans-unit id="72ca116b6b2d46153e83f38824f95e8a5d694cf5" translate="yes" xml:space="preserve">
          <source>All the basic integer types can be used as base types, both as signed and as unsigned: &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;long long&lt;/code&gt;. In addition, &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;double&lt;/code&gt; can be used to build floating-point vector types.</source>
          <target state="translated">모든 기본 정수 유형은 부호있는 유형과 부호없는 유형 인 &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;short&lt;/code&gt; , &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;long&lt;/code&gt; , &lt;code&gt;long long&lt;/code&gt; 으로 기본 유형으로 사용할 수 있습니다 . 또한 &lt;code&gt;float&lt;/code&gt; 및 &lt;code&gt;double&lt;/code&gt; 을 사용하여 부동 소수점 벡터 유형을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8115dc4041976655c63e593fd53f619ce3ca975" translate="yes" xml:space="preserve">
          <source>All the data and read-only data segments must be within 512KB addressing space. The text segment must be within 16MB addressing space.</source>
          <target state="translated">모든 데이터 및 읽기 전용 데이터 세그먼트는 512KB 주소 공간 내에 있어야합니다. 텍스트 세그먼트는 16MB 주소 공간 내에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="a642a04a04ca54e997a623213186ae992d1e6e8c" translate="yes" xml:space="preserve">
          <source>All the text and data segments can be within 4GB addressing space.</source>
          <target state="translated">모든 텍스트 및 데이터 세그먼트는 4GB 주소 공간 내에있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd8b82ccf3682d163d774079a9dc8ccb0aa660ee" translate="yes" xml:space="preserve">
          <source>All visibilities are supported on many, but not all, ELF targets (supported when the assembler supports the &amp;lsquo;</source>
          <target state="translated">모든 가시성은 모든 ELF 대상에서 지원되지만 모든 ELF 대상에서 지원되지는 않습니다 (어셈블러에서 '</target>
        </trans-unit>
        <trans-unit id="622f4dc5287fcd41d6f3a24869b2a0df614a0723" translate="yes" xml:space="preserve">
          <source>Allocate to an &lt;code&gt;enum&lt;/code&gt; type only as many bytes as it needs for the declared range of possible values. Specifically, the &lt;code&gt;enum&lt;/code&gt; type is equivalent to the smallest integer type that has enough room.</source>
          <target state="translated">선언 된 가능한 값의 범위에 필요한만큼의 바이트 만 &lt;code&gt;enum&lt;/code&gt; 형에 할당하십시오 . 특히 &lt;code&gt;enum&lt;/code&gt; 형은 충분한 공간이있는 가장 작은 정수 유형과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1b577848b6e6ae4af92719e79079d9951a50047f" translate="yes" xml:space="preserve">
          <source>Allocate variables to the read-only data section first if possible, then next in the small data section if possible, otherwise in data. This gives slightly slower code than the default, but reduces the amount of RAM required when executing, and thus may be preferred for some embedded systems.</source>
          <target state="translated">가능하면 먼저 읽기 전용 데이터 섹션에 변수를 할당 한 다음 가능하면 작은 데이터 섹션에서 다음에, 그렇지 않으면 데이터에서 변수를 할당하십시오. 이것은 기본값보다 약간 느린 코드를 제공하지만 실행시 필요한 RAM의 양을 줄이므로 일부 임베디드 시스템에서 선호 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="482b6f74ff2eb85ead91bf4d63cb82360d5be63f" translate="yes" xml:space="preserve">
          <source>Allow (or do not allow) GCC to use the LOOP instruction.</source>
          <target state="translated">Allow (or do not allow) GCC to use the LOOP instruction.</target>
        </trans-unit>
        <trans-unit id="12f3f43a7ca9147ffe2ba31d63c2ea8ec201486c" translate="yes" xml:space="preserve">
          <source>Allow arbitrary-sized immediates in bit operations.</source>
          <target state="translated">비트 연산에서 임의 크기의 즉각적인 허용.</target>
        </trans-unit>
        <trans-unit id="ac2c75532a2e292a21a77540eaedf29f5c432d5a" translate="yes" xml:space="preserve">
          <source>Allow conditional expressions with mismatched types in the second and third arguments. The value of such an expression is void. This option is not supported for C++.</source>
          <target state="translated">두 번째 및 세 번째 인수에서 유형이 일치하지 않는 조건식을 허용하십시오. 그러한 표현의 가치는 무효입니다. 이 옵션은 C ++에서 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8d58e8c4bb0f63ea94500caf667ca947fcaa1a82" translate="yes" xml:space="preserve">
          <source>Allow fast jumps to the message dispatcher. On Darwin this is accomplished via the comm page.</source>
          <target state="translated">메시지 디스패처로 빠르게 점프 할 수 있습니다. 다윈에서 이것은 통신 페이지를 통해 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="c73dadda8d4b49fb004b5103de76106d4f0b8557" translate="yes" xml:space="preserve">
          <source>Allow implicit conversions between vectors with differing numbers of elements and/or incompatible element types. This option should not be used for new code.</source>
          <target state="translated">다른 수의 요소 및 / 또는 호환되지 않는 요소 유형을 가진 벡터 간의 암시 적 변환을 허용합니다. 이 옵션은 새 코드에 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="d0dbb659ed768befd508acb2601c588f49ddaa57" translate="yes" xml:space="preserve">
          <source>Allow optimizations for floating-point arithmetic that (a) assume that arguments and results are valid and (b) may violate IEEE or ANSI standards. When used at link time, it may include libraries or startup files that change the default FPU control word or other similar optimizations.</source>
          <target state="translated">(a) 인수와 결과가 유효하다고 가정하고 (b) IEEE 또는 ANSI 표준을 위반할 수있는 부동 소수점 산술에 대한 최적화를 허용합니다. 링크 타임에 사용될 때 기본 FPU 제어 단어 또는 기타 유사한 최적화를 변경하는 라이브러리 또는 시작 파일이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="773a6288517f96a4a7283887bb99a6fba71c957c" translate="yes" xml:space="preserve">
          <source>Allow optimizations for floating-point arithmetic that assume that arguments and results are not NaNs or +-Infs.</source>
          <target state="translated">인수와 결과가 NaN 또는 + -Infs가 아니라고 가정하는 부동 소수점 산술에 대한 최적화를 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="1e06113b53f739fa9c85ec94358e3f373eb320f8" translate="yes" xml:space="preserve">
          <source>Allow optimizations for floating-point arithmetic that ignore the signedness of zero. IEEE arithmetic specifies the behavior of distinct +0.0 and -0.0 values, which then prohibits simplification of expressions such as x+0.0 or 0.0*x (even with</source>
          <target state="translated">부호없는 0을 무시하는 부동 소수점 산술에 대한 최적화를 허용합니다. IEEE 산술은 고유 한 +0.0 및 -0.0 값의 동작을 지정하여 x + 0.0 또는 0.0 * x와 같은 식의 단순화를 금지합니다.</target>
        </trans-unit>
        <trans-unit id="0eea9d2d0ec6a801c6ef5293eae12c7fbb21b59c" translate="yes" xml:space="preserve">
          <source>Allow optimizers to introduce new data races on stores. Set to 1 to allow, otherwise to 0.</source>
          <target state="translated">옵티마이 저가 상점에서 새로운 데이터 레이스를 도입 할 수 있습니다. 허용하려면 1로 설정하고 그렇지 않으면 0으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="c60cf758a077c6f503981387a6b0345419874bea" translate="yes" xml:space="preserve">
          <source>Allow or disallow the compiler to emit the &lt;code&gt;fsca&lt;/code&gt; instruction for sine and cosine approximations. The option</source>
          <target state="translated">컴파일러가 사인 및 코사인 근사값에 대해 &lt;code&gt;fsca&lt;/code&gt; 명령어를 생성하도록 허용하거나 허용하지 않습니다 . 옵션</target>
        </trans-unit>
        <trans-unit id="70331cead1dc233186888055e035642315d5054e" translate="yes" xml:space="preserve">
          <source>Allow or disallow the compiler to emit the &lt;code&gt;fsrra&lt;/code&gt; instruction for reciprocal square root approximations. The option</source>
          <target state="translated">컴파일러가 역 제곱근 근사에 대한 &lt;code&gt;fsrra&lt;/code&gt; 명령어를 생성하도록 허용하거나 허용하지 않습니다 . 옵션</target>
        </trans-unit>
        <trans-unit id="57cbe965449910b6f59559b0a1874d0d198b696a" translate="yes" xml:space="preserve">
          <source>Allow re-association of operands in series of floating-point operations. This violates the ISO C and C++ language standard by possibly changing computation result. NOTE: re-ordering may change the sign of zero as well as ignore NaNs and inhibit or create underflow or overflow (and thus cannot be used on code that relies on rounding behavior like &lt;code&gt;(x + 2**52) - 2**52&lt;/code&gt;. May also reorder floating-point comparisons and thus may not be used when ordered comparisons are required. This option requires that both</source>
          <target state="translated">일련의 부동 소수점 연산에서 피연산자를 다시 연결할 수 있습니다. 이는 계산 결과를 변경하여 ISO C 및 C ++ 언어 표준을 위반합니다. 참고 : 재정렬은 0의 부호를 변경하고 NaN을 무시하고 언더 플로 또는 오버플로를 금지하거나 만들 수 있으므로 &lt;code&gt;(x + 2**52) - 2**52&lt;/code&gt; 와 같은 반올림 동작에 의존하는 코드에는 사용할 수 없습니다. 부동 소수점 비교를 재정렬 할 수도 있으므로 순서 비교가 필요할 때는 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="54ce20d4ec16fad4cd32f197249fdc3fb1dac290" translate="yes" xml:space="preserve">
          <source>Allow speculative motion of more load instructions. This only makes sense when scheduling before register allocation, i.e. with</source>
          <target state="translated">더 많은로드 명령의 추론 적 움직임을 허용합니다. 이는 레지스터 할당 전에 스케줄링 할 때만 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b47c26e732fcedac3b1858953b01853eb8422ec" translate="yes" xml:space="preserve">
          <source>Allow speculative motion of some load instructions. This only makes sense when scheduling before register allocation, i.e. with</source>
          <target state="translated">일부로드 명령의 추측 동작을 허용합니다. 이는 레지스터 할당 전에 스케줄링 할 때만 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f926321cb4f3fc49097c6857a3e7d152a19de395" translate="yes" xml:space="preserve">
          <source>Allow stop bits to be placed earlier than immediately preceding the instruction that triggered the stop bit. This can improve instruction scheduling, but does not always do so.</source>
          <target state="translated">정지 비트를 트리거 한 명령 바로 앞에 정지 비트를 배치 할 수 있습니다. 이렇게하면 명령 예약이 향상 될 수 있지만 항상 그렇게하는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="7905fb7386b21750ad5a1d1722446a6fdeb43598" translate="yes" xml:space="preserve">
          <source>Allow the compiler to assume the strictest aliasing rules applicable to the language being compiled. For C (and C++), this activates optimizations based on the type of expressions. In particular, an object of one type is assumed never to reside at the same address as an object of a different type, unless the types are almost the same. For example, an &lt;code&gt;unsigned int&lt;/code&gt; can alias an &lt;code&gt;int&lt;/code&gt;, but not a &lt;code&gt;void*&lt;/code&gt; or a &lt;code&gt;double&lt;/code&gt;. A character type may alias any other type.</source>
          <target state="translated">컴파일러가 컴파일되는 언어에 적용 할 수있는 가장 엄격한 앨리어싱 규칙을 가정하도록 허용하십시오. C (및 C ++)의 경우 표현식 유형에 따라 최적화가 활성화됩니다. 특히, 유형이 거의 동일하지 않으면 한 유형의 객체가 다른 유형의 객체와 동일한 주소에 존재하지 않는 것으로 가정합니다. 예를 들어, &lt;code&gt;unsigned int&lt;/code&gt; 별칭 수 &lt;code&gt;int&lt;/code&gt; , 아니지만 &lt;code&gt;void*&lt;/code&gt; 또는 &lt;code&gt;double&lt;/code&gt; . 문자 유형은 다른 유형의 별명을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc2aa80da8f5ff65f45ae97b354110390c96c42f" translate="yes" xml:space="preserve">
          <source>Allow the compiler to generate &lt;em&gt;Long Instruction Word&lt;/em&gt; instructions if the target is the &amp;lsquo;</source>
          <target state="translated">대상이 '인 경우 컴파일러가 &lt;em&gt;Long Instruction Word&lt;/em&gt; 명령어 를 생성하도록 허용</target>
        </trans-unit>
        <trans-unit id="f39db7389fdae7630a67f4845ba2f639259c8a4a" translate="yes" xml:space="preserve">
          <source>Allow the compiler to generate the &lt;em&gt;SETLB&lt;/em&gt; and &lt;em&gt;Lcc&lt;/em&gt; instructions if the target is the &amp;lsquo;</source>
          <target state="translated">대상이 '인 경우 컴파일러가 &lt;em&gt;SETLB&lt;/em&gt; 및 &lt;em&gt;Lcc&lt;/em&gt; 명령어 를 생성하도록 허용</target>
        </trans-unit>
        <trans-unit id="57b9d18f30c753317a363448d4ac2396bae27e7d" translate="yes" xml:space="preserve">
          <source>Allow the compiler to introduce new data races on stores.</source>
          <target state="translated">Allow the compiler to introduce new data races on stores.</target>
        </trans-unit>
        <trans-unit id="fa7a919d8fa035f96c5d1af049879f0dd62e1421" translate="yes" xml:space="preserve">
          <source>Allow the compiler to optimize using the assumption that a value of enumerated type can only be one of the values of the enumeration (as defined in the C++ standard; basically, a value that can be represented in the minimum number of bits needed to represent all the enumerators). This assumption may not be valid if the program uses a cast to convert an arbitrary integer value to the enumerated type.</source>
          <target state="translated">열거 유형의 값이 열거의 값 중 하나 일 수 있다는 가정을 사용하여 컴파일러가 최적화하도록 허용합니다 (C ++ 표준에 정의 된대로 기본적으로 모두를 나타내는 데 필요한 최소 비트 수로 표현할 수있는 값). 열거 자). 프로그램이 캐스트를 사용하여 임의의 정수 값을 열거 유형으로 변환하는 경우이 가정이 유효하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33fc8a715b12ca22462902ef833240995e04a5d4" translate="yes" xml:space="preserve">
          <source>Allow the compiler to use all of the available registers. By default registers &lt;code&gt;r24..r31&lt;/code&gt; are reserved for use in interrupt handlers. With this option enabled these registers can be used in ordinary functions as well.</source>
          <target state="translated">컴파일러가 사용 가능한 모든 레지스터를 사용하도록 허용하십시오. 기본적으로 레지스터 &lt;code&gt;r24..r31&lt;/code&gt; 은 인터럽트 핸들러에서 사용하도록 예약되어 있습니다. 이 옵션을 활성화하면 이러한 레지스터를 일반 기능에서도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6303c2c94b5f256a55d06aa2be50e19fcb0df737" translate="yes" xml:space="preserve">
          <source>Allow the reciprocal of a value to be used instead of dividing by the value if this enables optimizations. For example &lt;code&gt;x / y&lt;/code&gt; can be replaced with &lt;code&gt;x * (1/y)&lt;/code&gt;, which is useful if &lt;code&gt;(1/y)&lt;/code&gt; is subject to common subexpression elimination. Note that this loses precision and increases the number of flops operating on the value.</source>
          <target state="translated">최적화를 가능하게하는 경우 값을 나누는 대신 값의 역수가 사용되도록합니다. 예를 들어 &lt;code&gt;x / y&lt;/code&gt; 는 &lt;code&gt;x * (1/y)&lt;/code&gt; 로 대체 될 수 있습니다 . 이는 &lt;code&gt;(1/y)&lt;/code&gt; 에 공통 하위 표현식 제거가 적용되는 경우에 유용합니다 . 이로 인해 정밀도가 떨어지고 값에서 작동하는 플롭 수가 증가합니다.</target>
        </trans-unit>
        <trans-unit id="5cbc7a77a073ec8e91de85701bbe563110739962" translate="yes" xml:space="preserve">
          <source>Allow the store merging pass to introduce unaligned stores if it is legal to do so.</source>
          <target state="translated">합법적 인 경우, 상점 병합 단계에서 정렬되지 않은 상점을 소개하십시오.</target>
        </trans-unit>
        <trans-unit id="b8c16f16485e58470d06579755ecbd0f929ac7fa" translate="yes" xml:space="preserve">
          <source>Allow to use truncation instead of rounding towards zero for fractional fixed-point types.</source>
          <target state="translated">분수 고정 소수점 유형의 경우 0으로 반올림하는 대신 잘림을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8834a22ee0acee1821ccfc8e148c6cbb34655847" translate="yes" xml:space="preserve">
          <source>Allow using extensions of later DWARF standard version than selected with</source>
          <target state="translated">로 선택한 DWARF 표준 버전 이후의 확장자 사용 허용</target>
        </trans-unit>
        <trans-unit id="98ea6e4c4f75e6a8f8033c8b750f3d749cc09003" translate="yes" xml:space="preserve">
          <source>Allow/disallow treating the &lt;code&gt;__ea&lt;/code&gt; address space as superset of the generic address space. This enables explicit type casts between &lt;code&gt;__ea&lt;/code&gt; and generic pointer as well as implicit conversions of generic pointers to &lt;code&gt;__ea&lt;/code&gt; pointers. The default is to allow address space pointer conversions.</source>
          <target state="translated">&lt;code&gt;__ea&lt;/code&gt; 주소 공간을 일반 주소 공간의 상위 집합으로 취급하도록 허용 / 금지 합니다. 이를 통해 &lt;code&gt;__ea&lt;/code&gt; 와 일반 포인터 간의 명시 적 유형 캐스트 뿐만 아니라 일반 포인터를 &lt;code&gt;__ea&lt;/code&gt; 포인터 로 암시 적으로 변환 할 수 있습니다. 기본적으로 주소 공간 포인터 변환이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="74a5bb83513cc4e38a6504a7eaa0f1d977ac61b9" translate="yes" xml:space="preserve">
          <source>Allowable bit-field types other than &lt;code&gt;_Bool&lt;/code&gt;, &lt;code&gt;signed int&lt;/code&gt;, and &lt;code&gt;unsigned int&lt;/code&gt; (C99 and C11 6.7.2.1).</source>
          <target state="translated">&lt;code&gt;_Bool&lt;/code&gt; , &lt;code&gt;signed int&lt;/code&gt; 및 &lt;code&gt;unsigned int&lt;/code&gt; 이외의 허용 가능한 비트 필드 유형 (C99 및 C11 6.7.2.1).</target>
        </trans-unit>
        <trans-unit id="9672aa21a92b454bca4334e1b73511ba859e3019" translate="yes" xml:space="preserve">
          <source>Allows calls via function pointers (including virtual functions) to execute correctly regardless of whether the target code has been compiled for interworking or not. There is a small overhead in the cost of executing a function pointer if this option is enabled. This option is not valid in AAPCS configurations because interworking is enabled by default.</source>
          <target state="translated">대상 코드가 인터 워킹을 위해 컴파일되었는지 여부에 관계없이 함수 포인터 (가상 함수 포함)를 통한 호출이 올바르게 실행되도록합니다. 이 옵션이 활성화 된 경우 함수 포인터를 실행하는 비용에는 약간의 오버 헤드가 있습니다. 인터 워킹은 기본적으로 활성화되어 있으므로 AAPCS 구성에서는이 옵션이 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9fab16002619dc077a62263507de1c970a51b300" translate="yes" xml:space="preserve">
          <source>Also note that GCC emits the above sequence with additional Newton-Raphson step for vectorized single-float division and vectorized &lt;code&gt;sqrtf(&lt;var&gt;x&lt;/var&gt;)&lt;/code&gt; already with</source>
          <target state="translated">또한 GCC 벡터화 단일 유동 부문 추가 뉴턴 - 랩슨 벡터화 공정과 함께 상기 열 방출 유의 &lt;code&gt;sqrtf(&lt;var&gt;x&lt;/var&gt;)&lt;/code&gt; 과 이미</target>
        </trans-unit>
        <trans-unit id="1a461c1e71dd5c0a03740ad367bc2a7b24233082" translate="yes" xml:space="preserve">
          <source>Also note that an &lt;code&gt;asm goto&lt;/code&gt; statement is always implicitly considered volatile.</source>
          <target state="translated">또한 &lt;code&gt;asm goto&lt;/code&gt; 문은 항상 암시 적으로 휘발성으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="767bf94dfe72662ddbd8e20120050c8f90e9046e" translate="yes" xml:space="preserve">
          <source>Also warn about cases where the compiler reduces the magnitude of a constant involved in a comparison. For example: &lt;code&gt;x + 2 &amp;gt; y&lt;/code&gt; is simplified to &lt;code&gt;x + 1 &amp;gt;= y&lt;/code&gt;. This is reported only at the highest warning level because this simplification applies to many comparisons, so this warning level gives a very large number of false positives.</source>
          <target state="translated">또한 컴파일러가 비교와 관련된 상수의 크기를 줄이는 경우에 대해서도 경고합니다. 예를 들어, &lt;code&gt;x + 2 &amp;gt; y&lt;/code&gt; 는 &lt;code&gt;x + 1 &amp;gt;= y&lt;/code&gt; 단순화됩니다 . 이 단순화는 많은 비교에 적용되므로이 경고 수준은 가장 높은 경고 수준에서만보고되므로이 경고 수준은 매우 많은 오 탐지를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c15f6772b26643b0ff617a164130fae2096f2324" translate="yes" xml:space="preserve">
          <source>Also warn about other cases where a comparison is simplified to a constant. For example: &lt;code&gt;abs (x) &amp;gt;= 0&lt;/code&gt;. This can only be simplified when signed integer overflow is undefined, because &lt;code&gt;abs (INT_MIN)&lt;/code&gt; overflows to &lt;code&gt;INT_MIN&lt;/code&gt;, which is less than zero.</source>
          <target state="translated">또한 비교가 상수로 단순화되는 다른 경우에 대해서도 경고합니다. 예를 들어 : &lt;code&gt;abs (x) &amp;gt;= 0&lt;/code&gt; 입니다. &lt;code&gt;abs (INT_MIN)&lt;/code&gt; 가 0보다 작은 &lt;code&gt;INT_MIN&lt;/code&gt; 으로 오버 플로우 되므로 부호있는 정수 오버 플로우가 정의되지 않은 경우에만 단순화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e8e800b6cdd36533f8ba6ba58f938d89e7317e5b" translate="yes" xml:space="preserve">
          <source>Also warn about other cases where a comparison is simplified. For example: &lt;code&gt;x + 1 &amp;gt; 1&lt;/code&gt; is simplified to &lt;code&gt;x &amp;gt; 0&lt;/code&gt;.</source>
          <target state="translated">또한 비교가 단순화 된 다른 경우에 대해서도 경고합니다. 예를 들어, &lt;code&gt;x + 1 &amp;gt; 1&lt;/code&gt; 은 &lt;code&gt;x &amp;gt; 0&lt;/code&gt; 단순화됩니다 .</target>
        </trans-unit>
        <trans-unit id="f2eccf451b029841db2d4f52cb1371fa4ffd7cc2" translate="yes" xml:space="preserve">
          <source>Also warn about other simplifications not covered by the above cases. For example: &lt;code&gt;(x * 10) / 5&lt;/code&gt; is simplified to &lt;code&gt;x * 2&lt;/code&gt;.</source>
          <target state="translated">위의 경우에서 다루지 않은 다른 단순화에 대해서도 경고하십시오. 예를 들어 : &lt;code&gt;(x * 10) / 5&lt;/code&gt; 는 &lt;code&gt;x * 2&lt;/code&gt; 단순화되었습니다 .</target>
        </trans-unit>
        <trans-unit id="aaf71652d194ffb84805956fe1b5940083ae517e" translate="yes" xml:space="preserve">
          <source>Also warn for dangerous uses of the GNU extension to &lt;code&gt;?:&lt;/code&gt; with omitted middle operand. When the condition in the &lt;code&gt;?&lt;/code&gt;: operator is a boolean expression, the omitted value is always 1. Often programmers expect it to be a value computed inside the conditional expression instead.</source>
          <target state="translated">또한에 GNU 확장의 위험 용도에 경고 &lt;code&gt;?:&lt;/code&gt; 생략 중간 피연산자. 언제 상태가 &lt;code&gt;?&lt;/code&gt; : operator는 부울 표현식이며, 생략 된 값은 항상 1입니다. 프로그래머는 종종 조건 표현식 내에서 계산 된 값이라고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="0777d5422fc8bc8f5bababa57c28335fb0cdc795" translate="yes" xml:space="preserve">
          <source>Also warn if a comparison like &lt;code&gt;x&amp;lt;=y&amp;lt;=z&lt;/code&gt; appears; this is equivalent to &lt;code&gt;(x&amp;lt;=y ? 1 : 0) &amp;lt;= z&lt;/code&gt;, which is a different interpretation from that of ordinary mathematical notation.</source>
          <target state="translated">&lt;code&gt;x&amp;lt;=y&amp;lt;=z&lt;/code&gt; 와 같은 비교 가 나타나는 경우에도 경고합니다 . 이것은 &lt;code&gt;(x&amp;lt;=y ? 1 : 0) &amp;lt;= z&lt;/code&gt; 와 동일하며 이는 일반적인 수학 표기법과는 다른 해석입니다.</target>
        </trans-unit>
        <trans-unit id="4e45248057e2324494ad069a7abd8071c0384ad1" translate="yes" xml:space="preserve">
          <source>Also warn when making a cast that introduces a type qualifier in an unsafe way. For example, casting &lt;code&gt;char **&lt;/code&gt; to &lt;code&gt;const char **&lt;/code&gt; is unsafe, as in this example:</source>
          <target state="translated">형식 한정자를 안전하지 않은 방식으로 소개하는 캐스트를 만들 때도 경고합니다. 예를 들어, 다음 예제와 같이 &lt;code&gt;char **&lt;/code&gt; 를 &lt;code&gt;const char **&lt;/code&gt; char ** 로 캐스팅하는 것은 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ebdf7f49c076ed9ff3a97d65da78f8767a5691c7" translate="yes" xml:space="preserve">
          <source>Also, some built-in functions prefer or require immediate numbers as parameters, because the corresponding DSP instructions accept both immediate numbers and register operands, or accept immediate numbers only. The immediate parameters are listed as follows.</source>
          <target state="translated">또한 일부 내장 함수는 해당 DSP 명령어가 즉시 숫자와 레지스터 피연산자를 모두 허용하거나 즉시 숫자 만 허용하므로 매개 변수로 즉시 숫자를 선호하거나 요구합니다. 즉각적인 매개 변수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f5b2a9f079522dadbd70f5a362997b267591505d" translate="yes" xml:space="preserve">
          <source>Also, the ABI changed the mangling of template argument packs, &lt;code&gt;const_cast&lt;/code&gt;, &lt;code&gt;static_cast&lt;/code&gt;, prefix increment/decrement, and a class scope function used as a template argument.</source>
          <target state="translated">또한 ABI는 템플릿 인수 팩, &lt;code&gt;const_cast&lt;/code&gt; , &lt;code&gt;static_cast&lt;/code&gt; , 접두사 증가 / 감소 및 템플릿 인수로 사용되는 클래스 범위 함수의 조작을 변경했습니다.</target>
        </trans-unit>
        <trans-unit id="bedbe72286a46ec20159c0af50884180a15a3619" translate="yes" xml:space="preserve">
          <source>Also, there are two special clobber arguments:</source>
          <target state="translated">또한 두 가지 특별한 clobber 인수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1793f4a326dd636d187c7ec419e47dec37d6305e" translate="yes" xml:space="preserve">
          <source>Also, you must provide function prototypes for all functions that take variable numbers of arguments (including &lt;code&gt;printf&lt;/code&gt;); otherwise incorrect code is generated for calls to those functions.</source>
          <target state="translated">또한 다양한 수의 인수 ( &lt;code&gt;printf&lt;/code&gt; 포함 ) 를 취하는 모든 함수에 대해 함수 프로토 타입을 제공해야합니다 . 그렇지 않으면 해당 함수를 호출 할 때 잘못된 코드가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="b85df36ab018e13c039dd34eb2302708663f4af2" translate="yes" xml:space="preserve">
          <source>Alter the cost model used for vectorization of loops marked with the OpenMP simd directive. The &lt;var&gt;model&lt;/var&gt; argument should be one of &amp;lsquo;</source>
          <target state="translated">OpenMP simd 지시문으로 표시된 루프의 벡터화에 사용되는 비용 모델을 변경하십시오. &lt;var&gt;model&lt;/var&gt; 인수는 '중 하나 여야합니다</target>
        </trans-unit>
        <trans-unit id="f431f1054230ce8fcc7bc5eae8ec9ced8a86a188" translate="yes" xml:space="preserve">
          <source>Alter the cost model used for vectorization. The &lt;var&gt;model&lt;/var&gt; argument should be one of &amp;lsquo;</source>
          <target state="translated">벡터화에 사용되는 비용 모델을 변경하십시오. &lt;var&gt;model&lt;/var&gt; 인수는 '중 하나 여야합니다</target>
        </trans-unit>
        <trans-unit id="9fc71ca35ab8d8d40760c8ef39bc71ee861a4bcc" translate="yes" xml:space="preserve">
          <source>Alter the thread-local storage model to be used (see &lt;a href=&quot;thread_002dlocal#Thread_002dLocal&quot;&gt;Thread-Local&lt;/a&gt;). The &lt;var&gt;model&lt;/var&gt; argument should be one of &amp;lsquo;</source>
          <target state="translated">사용할 스레드 로컬 스토리지 모델을 변경하십시오 ( &lt;a href=&quot;thread_002dlocal#Thread_002dLocal&quot;&gt;Thread-Local&lt;/a&gt; 참조 ). &lt;var&gt;model&lt;/var&gt; 인수는 '중 하나 여야합니다</target>
        </trans-unit>
        <trans-unit id="2d63c6f25ef5c2c6707d16e831a6091cc8c50e17" translate="yes" xml:space="preserve">
          <source>Alter the update method for an application instrumented for profile feedback based optimization. The &lt;var&gt;method&lt;/var&gt; argument should be one of &amp;lsquo;</source>
          <target state="translated">프로파일 피드백 기반 최적화를 위해 계측 된 응용 프로그램의 업데이트 방법을 변경하십시오. &lt;var&gt;method&lt;/var&gt; 인수는 '중 하나 여야합니다</target>
        </trans-unit>
        <trans-unit id="a7ba2917cba97115bf3adee00dd20256ca8bef51" translate="yes" xml:space="preserve">
          <source>Alternately, you can reference labels using the actual C label name enclosed in brackets. For example, to reference a label named &lt;code&gt;carry&lt;/code&gt;, you can use &amp;lsquo;</source>
          <target state="translated">또는 괄호로 묶은 실제 C 레이블 이름을 사용하여 레이블을 참조 할 수 있습니다. 예를 들어 &lt;code&gt;carry&lt;/code&gt; 라는 라벨을 참조 하려면 '</target>
        </trans-unit>
        <trans-unit id="c04a618f555219675642e22c54d794ab28d7300f" translate="yes" xml:space="preserve">
          <source>Alternatively you can discover which binary optimizations are enabled by</source>
          <target state="translated">또는 어떤 바이너리 최적화가 활성화되어 있는지 확인할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="1b2db455af7c311c86d9a9e68fe99ec219f1fdb6" translate="yes" xml:space="preserve">
          <source>Alternatively, the function attribute &lt;code&gt;noplt&lt;/code&gt; can be used to avoid calls through the PLT for specific external functions.</source>
          <target state="translated">또는 함수 속성 &lt;code&gt;noplt&lt;/code&gt; 를 사용하여 특정 외부 함수에 대한 PLT를 통한 호출을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="724d746f6afeb6dcb4048f896627e2174930b360" translate="yes" xml:space="preserve">
          <source>Alternatively, you might decide to put the precompiled header file in a directory and use</source>
          <target state="translated">또는 사전 컴파일 된 헤더 파일을 디렉토리에 넣고 사용하기로 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95f269cf4efa79d9433eb0cf9a5bd7a136f8f62d" translate="yes" xml:space="preserve">
          <source>Although IRA uses a sophisticated algorithm to compress the conflict table, the table can still require excessive amounts of memory for huge functions. If the conflict table for a function could be more than the size in MB given by this parameter, the register allocator instead uses a faster, simpler, and lower-quality algorithm that does not require building a pseudo-register conflict table.</source>
          <target state="translated">IRA는 충돌 알고리즘 테이블을 압축하기 위해 정교한 알고리즘을 사용하지만, 테이블이 여전히 큰 기능을 수행하려면 과도한 양의 메모리가 필요할 수 있습니다. 함수의 충돌 테이블이이 매개 변수가 제공 한 크기 (MB)보다 클 수있는 경우 레지스터 할당자는 대신 의사 레지스터 충돌 테이블을 작성할 필요가없는 더 빠르고 단순하며 품질이 낮은 알고리즘을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9b0be486c711e5de323bb610f3f803e2869a722a" translate="yes" xml:space="preserve">
          <source>Although an effort has been made to warn about all such cases, there are probably some cases that are not warned about, even though G++ is generating incompatible code. There may also be cases where warnings are emitted even though the code that is generated is compatible.</source>
          <target state="translated">이러한 모든 경우에 대해 경고하기 위해 노력했지만 G ++이 호환되지 않는 코드를 생성하더라도 경고되지 않은 경우가 있습니다. 생성 된 코드가 호환 되더라도 경고가 발생하는 경우도 있습니다.</target>
        </trans-unit>
        <trans-unit id="91a8f5762db94ffdfef370246b2c12c4c385d73d" translate="yes" xml:space="preserve">
          <source>Although it is possible to define such a function, this is not very useful as it is not possible to read the arguments. This is only supported for C as this construct is allowed by C++.</source>
          <target state="translated">이러한 함수를 정의 할 수는 있지만 인수를 읽을 수 없으므로 유용하지 않습니다. 이 구조는 C ++에서 허용되므로 C에만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="3aea130ff16faac0f0a72d4c21d30b19934fa1e8" translate="yes" xml:space="preserve">
          <source>Although the behavior is similar to the Gold Linker&amp;rsquo;s ICF optimization, GCC ICF works on different levels and thus the optimizations are not same - there are equivalences that are found only by GCC and equivalences found only by Gold.</source>
          <target state="translated">동작은 Gold Linker의 ICF 최적화와 유사하지만 GCC ICF는 다른 수준에서 작동하므로 최적화는 동일하지 않습니다. GCC에서만 발견되는 동등성과 Gold에서만 발견되는 동등성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf2ebe14b431087c27c2301bbb04cfe4eb87ea4a" translate="yes" xml:space="preserve">
          <source>Although the primary usage of this attribute is for POD types, the attribute can also be applied to global C++ objects that are initialized by a constructor. In this case, the static initialization and destruction code for the object is emitted in each translation defining the object, but the calls to the constructor and destructor are protected by a link-once guard variable.</source>
          <target state="translated">이 속성의 기본 사용법은 POD 유형에 대한 것이지만 생성자에 의해 초기화 된 전역 C ++ 객체에도 속성을 적용 할 수 있습니다. 이 경우 객체를 정의하는 각 변환에서 객체의 정적 초기화 및 소멸 코드가 생성되지만 생성자와 소멸자에 대한 호출은 link-once guard 변수로 보호됩니다.</target>
        </trans-unit>
        <trans-unit id="419e2ab79b9a72e513efa7d620ba40673796ae3c" translate="yes" xml:space="preserve">
          <source>Although the size of a zero-length array is zero, an array member of this kind may increase the size of the enclosing type as a result of tail padding. The offset of a zero-length array member from the beginning of the enclosing structure is the same as the offset of an array with one or more elements of the same type. The alignment of a zero-length array is the same as the alignment of its elements.</source>
          <target state="translated">길이가 0 인 배열의 크기는 0이지만 이러한 종류의 배열 구성원은 테일 패딩의 결과로 둘러싸는 유형의 크기를 늘릴 수 있습니다. 엔 클로징 구조의 시작 부분에서 길이가 0 인 배열 멤버의 오프셋은 동일한 유형의 하나 이상의 요소가있는 배열의 오프셋과 동일합니다. 길이가 0 인 배열의 정렬은 요소의 정렬과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="48a0b2e6239d57c9c30535eae8caf6619e4d8826" translate="yes" xml:space="preserve">
          <source>Altivec register if</source>
          <target state="translated">Altivec 레지스터</target>
        </trans-unit>
        <trans-unit id="43210ad7cdf91a35ea9e54b8ca8e28c22c6e9fd2" translate="yes" xml:space="preserve">
          <source>Altivec register to use for double loads/stores or NO_REGS.</source>
          <target state="translated">이중로드 / 저장 또는 NO_REGS에 사용할 Altivec 레지스터.</target>
        </trans-unit>
        <trans-unit id="1e72319ddb65cddc1596b72314174c11a529e4e9" translate="yes" xml:space="preserve">
          <source>Altivec register to use for float/32-bit int loads/stores or NO_REGS.</source>
          <target state="translated">float / 32 비트 int로드 / 저장소 또는 NO_REGS에 사용할 Altivec 레지스터.</target>
        </trans-unit>
        <trans-unit id="27667baa779021dc30ceb24d0b6298a36d1ae73c" translate="yes" xml:space="preserve">
          <source>Altivec vector register</source>
          <target state="translated">Altivec 벡터 레지스터</target>
        </trans-unit>
        <trans-unit id="7213a39022a1a221aa305b421707bb55dfa13ff8" translate="yes" xml:space="preserve">
          <source>Always treat bit-fields as &lt;code&gt;int&lt;/code&gt;-sized.</source>
          <target state="translated">비트 필드는 항상 &lt;code&gt;int&lt;/code&gt; 크기 로 취급하십시오 .</target>
        </trans-unit>
        <trans-unit id="549d944304e895a2c1d4531ead649e8cbf5063ad" translate="yes" xml:space="preserve">
          <source>Always use a library call.</source>
          <target state="translated">항상 도서관 전화를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0b4062f8987d50153e0838000ddb5e4f41ad4e24" translate="yes" xml:space="preserve">
          <source>Among the consequences of these changes are that static data members of the same type with the same name but defined in different shared objects are different, so changing one does not change the other; and that pointers to function members defined in different shared objects may not compare equal. When this flag is given, it is a violation of the ODR to define types with the same name differently.</source>
          <target state="translated">이러한 변경의 결과 중에는 이름은 동일하지만 다른 공유 객체에 정의 된 동일한 유형의 정적 데이터 멤버가 다르므로 하나를 변경해도 다른 하나는 변경되지 않습니다. 다른 공유 객체에 정의 된 함수 멤버에 대한 포인터는 동일하지 않을 수 있습니다. 이 플래그가 지정되면 이름이 다른 유형을 다르게 정의하는 것은 ODR을 위반하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="99690d58d4abd10cd0938a7adcb56ded08ef66ad" translate="yes" xml:space="preserve">
          <source>An</source>
          <target state="translated">An</target>
        </trans-unit>
        <trans-unit id="c5009a6f1efb8810f35df0d2766e52237ed673ad" translate="yes" xml:space="preserve">
          <source>An 8 bit value with exactly one bit set.</source>
          <target state="translated">정확히 1 비트가 설정된 8 비트 값입니다.</target>
        </trans-unit>
        <trans-unit id="73fdb3be2e0086894a1e44f055f6c3c5fe05581e" translate="yes" xml:space="preserve">
          <source>An 8-element vector constant with identical elements.</source>
          <target state="translated">요소가 같은 8 요소 벡터 상수입니다.</target>
        </trans-unit>
        <trans-unit id="42e73ea7df5141021212bafc4bcfa0e59c8e090d" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;asm goto&lt;/code&gt; statement cannot have outputs. This is due to an internal restriction of the compiler: control transfer instructions cannot have outputs. If the assembler code does modify anything, use the &lt;code&gt;&quot;memory&quot;&lt;/code&gt; clobber to force the optimizers to flush all register values to memory and reload them if necessary after the &lt;code&gt;asm&lt;/code&gt; statement.</source>
          <target state="translated">&lt;code&gt;asm goto&lt;/code&gt; 문을 출력 할 수 없습니다. 이것은 컴파일러의 내부 제한 때문입니다. 제어 전송 명령어는 출력을 가질 수 없습니다. 어셈블러 코드가 아무것도 수정하지 않으면 &lt;code&gt;&quot;memory&quot;&lt;/code&gt; 클로버를 사용하여 옵티마이 저가 모든 레지스터 값을 메모리로 플러시하고 필요한 경우 &lt;code&gt;asm&lt;/code&gt; 문 다음에 다시로드하십시오 .</target>
        </trans-unit>
        <trans-unit id="04db20c14b6b3a82ba6832f795aabb1d2758d6a2" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;asm&lt;/code&gt; statement has zero or more output operands indicating the names of C variables modified by the assembler code.</source>
          <target state="translated">&lt;code&gt;asm&lt;/code&gt; 문은 어셈블러 코드에 의해 수정 C 변수의 이름을 나타내는 0 개 이상의 출력 피연산자를 갖는다.</target>
        </trans-unit>
        <trans-unit id="c3ecf57ab1f86499d0414e65689faa519df6b817" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;enum&lt;/code&gt; type is not considered to be compatible with another &lt;code&gt;enum&lt;/code&gt; type even if both are compatible with the same integer type; this is what the C standard specifies. For example, &lt;code&gt;enum {foo, bar}&lt;/code&gt; is not similar to &lt;code&gt;enum {hot, dog}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; 유형은 서로 호환으로 간주되지 않습니다 &lt;code&gt;enum&lt;/code&gt; 모두 동일한 정수 유형과 호환 경우에도 유형; 이것이 C 표준이 지정한 것입니다. 예를 들어 &lt;code&gt;enum {foo, bar}&lt;/code&gt; 는 &lt;code&gt;enum {hot, dog}&lt;/code&gt; 와 유사하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="197244fadb4ff328f7464f8fb593d34255a64886" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;attribute specifier list&lt;/em&gt; is a sequence of one or more attribute specifiers, not separated by any other tokens.</source>
          <target state="translated">&lt;em&gt;특성 지정자 목록이&lt;/em&gt; 하나 개 이상의 속성 지정자들의 시퀀스이며, 기타 다른 토큰으로 분리된다.</target>
        </trans-unit>
        <trans-unit id="4db760995f077b22b4a4d97b7a5f59e2f43ffc2f" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;attribute specifier&lt;/em&gt; is of the form &lt;code&gt;__attribute__ ((&lt;var&gt;attribute-list&lt;/var&gt;))&lt;/code&gt;. An &lt;em&gt;attribute list&lt;/em&gt; is a possibly empty comma-separated sequence of &lt;em&gt;attributes&lt;/em&gt;, where each attribute is one of the following:</source>
          <target state="translated">&lt;em&gt;특성 지정자&lt;/em&gt; 양식이다 &lt;code&gt;__attribute__ ((&lt;var&gt;attribute-list&lt;/var&gt;))&lt;/code&gt; . &lt;em&gt;속성 목록&lt;/em&gt; 의 비어 쉼표로 구분 시퀀스 인 &lt;em&gt;속성&lt;/em&gt; 각 속성은 다음 중 하나 :</target>
        </trans-unit>
        <trans-unit id="7298880ccde6d5d2f135cff890ce9dd813a48a5a" translate="yes" xml:space="preserve">
          <source>An Altivec vector register (VR), &lt;code&gt;v0&lt;/code&gt;&amp;hellip;&lt;code&gt;v31&lt;/code&gt;.</source>
          <target state="translated">An Altivec vector register (VR), &lt;code&gt;v0&lt;/code&gt; &amp;hellip; &lt;code&gt;v31&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="caef8d867ec8d279c62d15ef41539390101b886c" translate="yes" xml:space="preserve">
          <source>An I-type 12-bit signed immediate.</source>
          <target state="translated">I 형 12 비트 서명 즉시.</target>
        </trans-unit>
        <trans-unit id="06327d0e0884e8359c3aeb898ee10e76eb6687a6" translate="yes" xml:space="preserve">
          <source>An absolute address</source>
          <target state="translated">절대 주소</target>
        </trans-unit>
        <trans-unit id="78c6a7cdfe8551206974bd67b2a089dc6fe26252" translate="yes" xml:space="preserve">
          <source>An absolute symbolic address or a label reference</source>
          <target state="translated">절대 기호 주소 또는 레이블 참조</target>
        </trans-unit>
        <trans-unit id="986b6a4e37803f27663b870d347fe309ea3ea740" translate="yes" xml:space="preserve">
          <source>An address suitable for a &lt;code&gt;prefetch&lt;/code&gt; instruction, or for any other instruction with the same addressing mode as &lt;code&gt;prefetch&lt;/code&gt;.</source>
          <target state="translated">A에 대한 적절한 어드레스 &lt;code&gt;prefetch&lt;/code&gt; 지시 또는 동일한 어드레싱 모드와 임의의 다른 명령의 &lt;code&gt;prefetch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="892155354f6089e8dd5e479a72ea4a1751091291" translate="yes" xml:space="preserve">
          <source>An address that can be used in a non-macro load or store.</source>
          <target state="translated">비 매크로로드 또는 저장소에서 사용할 수있는 주소입니다.</target>
        </trans-unit>
        <trans-unit id="ff106250bd6a1ea035dee107e3b2d2773c2aecc2" translate="yes" xml:space="preserve">
          <source>An address that is held in a general-purpose register.</source>
          <target state="translated">범용 레지스터에 보유 된 주소입니다.</target>
        </trans-unit>
        <trans-unit id="ebfbf78a988fb6bc16aa1ac07630bba74056e531" translate="yes" xml:space="preserve">
          <source>An address which does not involve register indirect addressing or pre/post increment/decrement addressing.</source>
          <target state="translated">등록 간접 주소 지정 또는 사전 / 사후 증분 / 감소 주소 지정을 포함하지 않는 주소입니다.</target>
        </trans-unit>
        <trans-unit id="e3211e293506f09ee6205a6286105b13b8dd093c" translate="yes" xml:space="preserve">
          <source>An alternate way to write the above example is</source>
          <target state="translated">위 예제를 작성하는 다른 방법은</target>
        </trans-unit>
        <trans-unit id="7ed98e3e9e5fb257c8559031222af1c4e1303971" translate="yes" xml:space="preserve">
          <source>An alternative syntax for this that has been obsolete since GCC 2.5 but GCC still accepts is to write &amp;lsquo;</source>
          <target state="translated">GCC 2.5 이후로 사용되지 않았지만 GCC에서 여전히 수용하는 대체 구문은 '</target>
        </trans-unit>
        <trans-unit id="0ba051ca8ecdb334d29fa5a48a0711170d4503f7" translate="yes" xml:space="preserve">
          <source>An alternative to increasing the size of the destination buffer is to constrain the range of formatted values. The maximum length of string arguments can be bounded by specifying the precision in the format directive. When numeric arguments of format directives can be assumed to be bounded by less than the precision of their type, choosing an appropriate length modifier to the format specifier will reduce the required buffer size. For example, if &lt;var&gt;a&lt;/var&gt; and &lt;var&gt;b&lt;/var&gt; in the example above can be assumed to be within the precision of the &lt;code&gt;short int&lt;/code&gt; type then using either the &lt;code&gt;%hi&lt;/code&gt; format directive or casting the argument to &lt;code&gt;short&lt;/code&gt; reduces the maximum required size of the buffer to 24 bytes.</source>
          <target state="translated">대상 버퍼의 크기를 늘리는 대안은 서식이 지정된 값의 범위를 제한하는 것입니다. format 지시문에서 정밀도를 지정하여 문자열 인수의 최대 길이를 제한 할 수 있습니다. 형식 지시문의 숫자 인수가 해당 유형의 정밀도보다 작은 것으로 제한 될 수있는 경우 형식 지정자에 적절한 길이 수정자를 선택하면 필요한 버퍼 크기가 줄어 듭니다. 예를 들어, 위의 예에서 &lt;var&gt;a&lt;/var&gt; 와 &lt;var&gt;b&lt;/var&gt; 가 &lt;code&gt;short int&lt;/code&gt; 유형 의 정밀도 내에 있다고 가정 할 수있는 경우 &lt;code&gt;%hi&lt;/code&gt; 형식 지시문 을 사용하거나 인수를 &lt;code&gt;short&lt;/code&gt; 로 캐스팅 하면 버퍼의 최대 필수 크기가 24 바이트로 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="90ac40bd537abd77f944ca782b1d8e24e3e93586" translate="yes" xml:space="preserve">
          <source>An amendment to the 1990 standard was published in 1995. This amendment added digraphs and &lt;code&gt;__STDC_VERSION__&lt;/code&gt; to the language, but otherwise concerned the library. This amendment is commonly known as &lt;em&gt;AMD1&lt;/em&gt;; the amended standard is sometimes known as &lt;em&gt;C94&lt;/em&gt; or &lt;em&gt;C95&lt;/em&gt;. To select this standard in GCC, use the option</source>
          <target state="translated">1990 년 표준에 대한 개정안은 1995 년에 출판되었습니다.이 개정안 은 언어 에 digraphs와 &lt;code&gt;__STDC_VERSION__&lt;/code&gt; 을 추가 했지만 라이브러리와 관련이있었습니다. 이 개정안은 일반적으로 &lt;em&gt;AMD1&lt;/em&gt; 로 알려져 있습니다 . 수정 된 표준은 때때로 &lt;em&gt;C94&lt;/em&gt; 또는 &lt;em&gt;C95&lt;/em&gt; 로 알려져 있습니다. GCC에서이 표준을 선택하려면 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5ec9ea45e6f6d2866eabdf39502663d30e59ccdc" translate="yes" xml:space="preserve">
          <source>An application can interpose its own definition of functions for functions invoked by</source>
          <target state="translated">응용 프로그램은</target>
        </trans-unit>
        <trans-unit id="79eafbcf2b7c5c25e774d3009d7ad66460a67d81" translate="yes" xml:space="preserve">
          <source>An area where the difference is most apparent is name mangling. The use of different name mangling is intentional, to protect you from more subtle problems. Compilers differ as to many internal details of C++ implementation, including: how class instances are laid out, how multiple inheritance is implemented, and how virtual function calls are handled. If the name encoding were made the same, your programs would link against libraries provided from other compilers&amp;mdash;but the programs would then crash when run. Incompatible libraries are then detected at link time, rather than at run time.</source>
          <target state="translated">차이점이 가장 분명한 영역은 이름 맹 글링입니다. 다른 이름 맹 글링을 사용하는 것은 의도적으로 더 미묘한 문제로부터 보호하기위한 것입니다. 컴파일러는 클래스 인스턴스 배치 방법, 다중 상속 구현 방법 및 가상 함수 호출 처리 방법 등 C ++ 구현에 대한 많은 내부 세부 사항이 다릅니다. 이름 인코딩이 동일하게 설정되면 프로그램은 다른 컴파일러에서 제공 한 라이브러리와 연결되지만 실행시 프로그램이 중단됩니다. 호환되지 않는 라이브러리는 런타임이 아닌 링크 타임에 감지됩니다.</target>
        </trans-unit>
        <trans-unit id="a97545d568f0ddabc50a6a6e190b9c96c3da5965" translate="yes" xml:space="preserve">
          <source>An assembler template is a literal string containing assembler instructions. The compiler replaces tokens in the template that refer to inputs, outputs, and goto labels, and then outputs the resulting string to the assembler. The string can contain any instructions recognized by the assembler, including directives. GCC does not parse the assembler instructions themselves and does not know what they mean or even whether they are valid assembler input. However, it does count the statements (see &lt;a href=&quot;size-of-an-asm#Size-of-an-asm&quot;&gt;Size of an asm&lt;/a&gt;).</source>
          <target state="translated">어셈블러 템플릿은 어셈블러 명령어가 포함 된 리터럴 문자열입니다. 컴파일러는 입력, 출력 및 이동 레이블을 참조하는 템플릿의 토큰을 대체 한 다음 결과 문자열을 어셈블러에 출력합니다. 문자열은 지시문을 포함하여 어셈블러가 인식하는 모든 명령을 포함 할 수 있습니다. GCC는 어셈블러 명령어 자체를 구문 분석하지 않으며, 의미가 무엇인지, 또는 이들이 어셈블러 입력이 유효한지 여부를 모릅니다. 그러나 명령문을 계산합니다 ( &lt;a href=&quot;size-of-an-asm#Size-of-an-asm&quot;&gt;asm의 크기&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="cf8ae718bdcb577716b49e495b23a5d728121d19" translate="yes" xml:space="preserve">
          <source>An atomic operation can both constrain code motion and be mapped to hardware instructions for synchronization between threads (e.g., a fence). To which extent this happens is controlled by the memory orders, which are listed here in approximately ascending order of strength. The description of each memory order is only meant to roughly illustrate the effects and is not a specification; see the C++11 memory model for precise semantics.</source>
          <target state="translated">원자 연산은 코드 모션을 제한하고 스레드 (예 : 펜스) 간의 동기화를 위해 하드웨어 명령어에 매핑 될 수 있습니다. 이것이 발생하는 정도는 메모리 오더에 의해 제어되며,이 오더는 대략 오름차순으로 나열됩니다. 각 메모리 순서에 대한 설명은 효과를 대략적으로 설명하기위한 것이며 사양이 아닙니다. 정확한 의미론은 C ++ 11 메모리 모델을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4d88b31282dc4372978d47c4d528de2e00c16901" translate="yes" xml:space="preserve">
          <source>An attribute name (which may be an identifier such as &lt;code&gt;unused&lt;/code&gt;, or a reserved word such as &lt;code&gt;const&lt;/code&gt;).</source>
          <target state="translated">속성 이름 ( &lt;code&gt;unused&lt;/code&gt; 것과 같은 식별자 또는 &lt;code&gt;const&lt;/code&gt; 와 같은 예약어 일 수 있음 )</target>
        </trans-unit>
        <trans-unit id="f65131f3242824d199035927efcf93043285cd45" translate="yes" xml:space="preserve">
          <source>An attribute name followed by a parenthesized list of parameters for the attribute. These parameters take one of the following forms:</source>
          <target state="translated">속성 이름 다음에 속성의 괄호로 묶은 매개 변수 목록이 표시됩니다. 이 매개 변수는 다음 형식 중 하나를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7d755f91a373e17fad5f0c5626bbbba251cf643a" translate="yes" xml:space="preserve">
          <source>An attribute specifier list may appear as part of a &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt; or &lt;code&gt;enum&lt;/code&gt; specifier. It may go either immediately after the &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt; or &lt;code&gt;enum&lt;/code&gt; keyword, or after the closing brace. The former syntax is preferred. Where attribute specifiers follow the closing brace, they are considered to relate to the structure, union or enumerated type defined, not to any enclosing declaration the type specifier appears in, and the type defined is not complete until after the attribute specifiers.</source>
          <target state="translated">속성 지정자 목록은 &lt;code&gt;struct&lt;/code&gt; , &lt;code&gt;union&lt;/code&gt; 또는 &lt;code&gt;enum&lt;/code&gt; 지정자의 일부로 나타날 수 있습니다 . &lt;code&gt;struct&lt;/code&gt; , &lt;code&gt;union&lt;/code&gt; 또는 &lt;code&gt;enum&lt;/code&gt; 키워드 바로 뒤에 또는 닫는 중괄호 뒤에 올 수 있습니다. 전자의 구문이 선호됩니다. 속성 지정자가 닫는 중괄호를 따르는 경우, 형식 지정자가 나타나는 엔 클로징 선언이 아니라 정의 된 구조, 공용체 또는 열거 된 형식과 관련된 것으로 간주되며 정의 된 형식은 속성 지정자 이후까지 완료되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9e5e73e14616e06a74db1d5feee8111efc621957" translate="yes" xml:space="preserve">
          <source>An attribute specifier list may appear at the start of a nested declarator. At present, there are some limitations in this usage: the attributes correctly apply to the declarator, but for most individual attributes the semantics this implies are not implemented. When attribute specifiers follow the &lt;code&gt;*&lt;/code&gt; of a pointer declarator, they may be mixed with any type qualifiers present. The following describes the formal semantics of this syntax. It makes the most sense if you are familiar with the formal specification of declarators in the ISO C standard.</source>
          <target state="translated">중첩 된 선언자의 시작 부분에 속성 지정자 목록이 나타날 수 있습니다. 현재이 사용법에는 몇 가지 제한 사항이 있습니다. 속성은 선언자에 올바르게 적용되지만 대부분의 개별 속성에 대해서는 의미가 구현되지 않습니다. 속성 지정 자가 포인터 선언자 의 &lt;code&gt;*&lt;/code&gt; 뒤에 오면 존재하는 모든 형식 한정자와 혼합 될 수 있습니다. 다음은이 구문의 형식적 의미를 설명합니다. ISO C 표준의 선언자 공식 사양에 익숙하다면 가장 적합합니다.</target>
        </trans-unit>
        <trans-unit id="90c786fbc073ea725818acf8d9cbe4bc390cf984" translate="yes" xml:space="preserve">
          <source>An attribute specifier list may appear immediately before a declarator (other than the first) in a comma-separated list of declarators in a declaration of more than one identifier using a single list of specifiers and qualifiers. Such attribute specifiers apply only to the identifier before whose declarator they appear. For example, in</source>
          <target state="translated">속성 지정자 목록은 단일 지정자 및 규정 자 목록을 사용하여 둘 이상의 식별자를 선언 할 때 쉼표로 구분 된 선언자 목록에서 선언자 바로 앞에 (첫 번째가 아닌) 나타날 수 있습니다. 이러한 속성 지정자는 선언자가 표시되기 전에 식별자에만 적용됩니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="be5978cee71999e28113db755252c2c229b75be6" translate="yes" xml:space="preserve">
          <source>An attribute specifier list may appear immediately before the comma, &lt;code&gt;=&lt;/code&gt; or semicolon terminating the declaration of an identifier other than a function definition. Such attribute specifiers apply to the declared object or function. Where an assembler name for an object or function is specified (see &lt;a href=&quot;asm-labels#Asm-Labels&quot;&gt;Asm Labels&lt;/a&gt;), the attribute must follow the &lt;code&gt;asm&lt;/code&gt; specification.</source>
          <target state="translated">속성 지정자 목록은 함수 정의 이외의 식별자 선언을 쉼표, &lt;code&gt;=&lt;/code&gt; 또는 세미콜론 바로 앞에 나타날 수 있습니다 . 이러한 속성 지정자는 선언 된 객체 또는 함수에 적용됩니다. 객체 또는 함수의 어셈블러 이름이 지정된 경우 ( &lt;a href=&quot;asm-labels#Asm-Labels&quot;&gt;Asm 레이블&lt;/a&gt; 참조 ) 속성은 &lt;code&gt;asm&lt;/code&gt; 사양을 따라야합니다 .</target>
        </trans-unit>
        <trans-unit id="06c400bc0897dcce315e482021ea5ac2d0b133c9" translate="yes" xml:space="preserve">
          <source>An attribute specifier list may, in future, be permitted to appear after the declarator in a function definition (before any old-style parameter declarations or the function body).</source>
          <target state="translated">나중에 속성 지정자 목록은 함수 정의에서 선언자 다음에 표시 될 수 있습니다 (이전 스타일 매개 변수 선언 또는 함수 본문 이전).</target>
        </trans-unit>
        <trans-unit id="a74a1d3ff08634b1a7446e5738ed8abb53ee53ac" translate="yes" xml:space="preserve">
          <source>An empty replacement string indicates that the given range is to be removed. An empty range (e.g. &amp;ldquo;45:3-45:3&amp;rdquo;) indicates that the string is to be inserted at the given position.</source>
          <target state="translated">비어있는 대체 문자열은 주어진 범위가 제거됨을 나타냅니다. 빈 범위 (예 : &quot;45 : 3-45 : 3&quot;)는 문자열이 주어진 위치에 삽입 될 것임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0ae58fb99fa1b71a549f28d943d2b614039f2208" translate="yes" xml:space="preserve">
          <source>An identifier followed by a comma and a non-empty comma-separated list of expressions. For example, &lt;code&gt;format&lt;/code&gt; attributes use this form.</source>
          <target state="translated">식별자 뒤에 쉼표와 쉼표로 구분되지 않은 표현식 목록이옵니다. 예를 들어, &lt;code&gt;format&lt;/code&gt; 속성은이 양식을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="68d7bc1885869717ff785880a55a84832370a8cc" translate="yes" xml:space="preserve">
          <source>An identifier. For example, &lt;code&gt;mode&lt;/code&gt; attributes use this form.</source>
          <target state="translated">식별자. 예를 들어, &lt;code&gt;mode&lt;/code&gt; 속성은이 양식을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1ec5ac33481525fe53d426cd6db6a12a229bec4c" translate="yes" xml:space="preserve">
          <source>An immediate floating operand (expression code &lt;code&gt;const_double&lt;/code&gt; or &lt;code&gt;const_vector&lt;/code&gt;) is allowed.</source>
          <target state="translated">즉시 부동 피연산자 (표현 코드 &lt;code&gt;const_double&lt;/code&gt; 또는 &lt;code&gt;const_vector&lt;/code&gt; )가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="594d6eba8a97b362385ec37bc0e852d2a80c0ac2" translate="yes" xml:space="preserve">
          <source>An immediate floating operand (expression code &lt;code&gt;const_double&lt;/code&gt;) is allowed, but only if the target floating point format is the same as that of the host machine (on which the compiler is running).</source>
          <target state="translated">즉시 부동 피연산자 (식 코드 &lt;code&gt;const_double&lt;/code&gt; )는 허용되지만 대상 부동 소수점 형식이 호스트 컴퓨터 (컴파일러가 실행중인)의 형식과 동일한 경우에만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="0c315fd75b55a96544e61998f54c1ece5842737a" translate="yes" xml:space="preserve">
          <source>An immediate for and/xor/or instructions. const_int is sign extended as a 128 bit.</source>
          <target state="translated">즉시 및 / 또는 명령. const_int는 128 비트로 확장 된 부호입니다.</target>
        </trans-unit>
        <trans-unit id="5ccfcfe71dbbefbcc7083b3111e73c588704efb6" translate="yes" xml:space="preserve">
          <source>An immediate for and/xor/or instructions. const_int is treated as a 32 bit value.</source>
          <target state="translated">즉시 및 / 또는 명령. const_int는 32 비트 값으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="37a74b5a5b038401ba585b82ac648a38ee34ae7d" translate="yes" xml:space="preserve">
          <source>An immediate for and/xor/or instructions. const_int is treated as a 64 bit value.</source>
          <target state="translated">즉시 및 / 또는 명령. const_int는 64 비트 값으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="724f31235beec2d91358f29c81609301ddfe064d" translate="yes" xml:space="preserve">
          <source>An immediate for most arithmetic instructions. const_int is treated as a 32 bit value.</source>
          <target state="translated">대부분의 산술 명령어를 즉시 제공합니다. const_int는 32 비트 값으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="ba5952eb86810c12a13a67307b761f420789e80d" translate="yes" xml:space="preserve">
          <source>An immediate for shift and rotate instructions. const_int is treated as a 32 bit value.</source>
          <target state="translated">시프트 및 회전 명령을 즉시 수행 할 수 있습니다. const_int는 32 비트 값으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="4f576fc6545e2a7ed32b49891eee7158495619f8" translate="yes" xml:space="preserve">
          <source>An immediate for the &lt;code&gt;iohl&lt;/code&gt; instruction. const_int is sign extended to 128 bit.</source>
          <target state="translated">&lt;code&gt;iohl&lt;/code&gt; 명령 의 즉각적인 . const_int는 128 비트로 확장 된 부호입니다.</target>
        </trans-unit>
        <trans-unit id="fa46e8c9174bfc14d1e6484c608422836253b5fc" translate="yes" xml:space="preserve">
          <source>An immediate for the &lt;code&gt;iohl&lt;/code&gt; instruction. const_int is treated as a 32 bit value.</source>
          <target state="translated">&lt;code&gt;iohl&lt;/code&gt; 명령 의 즉각적인 . const_int는 32 비트 값으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="a4ad2e9f47c35dba5c3a654586cfbfd37c2d1074" translate="yes" xml:space="preserve">
          <source>An immediate for the &lt;code&gt;iohl&lt;/code&gt; instruction. const_int is treated as a 64 bit value.</source>
          <target state="translated">&lt;code&gt;iohl&lt;/code&gt; 명령 의 즉각적인 . const_int는 64 비트 값으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="fb6b5c59189bcd298a8c54b0d5b72012198931a3" translate="yes" xml:space="preserve">
          <source>An immediate integer operand (one with constant value) is allowed. This includes symbolic constants whose values will be known only at assembly time or later.</source>
          <target state="translated">즉시 정수 피연산자 (상수 값이있는 피연산자)가 허용됩니다. 여기에는 조립시 또는 이후에 값을 알 수있는 기호 상수가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="e84f183cbd16bd54d89a362096c570a83e737d81" translate="yes" xml:space="preserve">
          <source>An immediate integer operand whose value is not an explicit integer is allowed.</source>
          <target state="translated">값이 명시 적 정수가 아닌 즉시 정수 피연산자가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="3dcd4c571d6303522812fd66511c9efeae10aff4" translate="yes" xml:space="preserve">
          <source>An immediate integer operand with a known numeric value is allowed. Many systems cannot support assembly-time constants for operands less than a word wide. Constraints for these operands should use &amp;lsquo;</source>
          <target state="translated">알려진 숫자 값을 가진 즉시 정수 피연산자가 허용됩니다. 많은 시스템은 단어 너비보다 작은 피연산자에 대해 어셈블리 시간 상수를 지원할 수 없습니다. 이 피연산자에 대한 제약 조건은 '</target>
        </trans-unit>
        <trans-unit id="fead0cb9bc3652a20a6803e3e14fb097bc244e18" translate="yes" xml:space="preserve">
          <source>An immediate operand for R2 andchi/andci instructions.</source>
          <target state="translated">R2 andchi / andci 명령어에 대한 즉각적인 피연산자입니다.</target>
        </trans-unit>
        <trans-unit id="ac68e335d064a71570d610173f680ac5fbe05513" translate="yes" xml:space="preserve">
          <source>An immediate which can be loaded with &lt;code&gt;fsmbi&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fsmbi&lt;/code&gt; 로로드 할 수있는 즉시 .</target>
        </trans-unit>
        <trans-unit id="ea450ed2fe096f001d0fa25412cdd9e4110db1ae" translate="yes" xml:space="preserve">
          <source>An immediate which can be loaded with the il/ila/ilh/ilhu instructions. const_int is sign extended to 128 bit.</source>
          <target state="translated">il / ila / ilh / ilhu 지침과 함께 즉시로드 할 수 있습니다. const_int는 128 비트로 확장 된 부호입니다.</target>
        </trans-unit>
        <trans-unit id="7c728956eab601b71ea1ef8510f9ed46b01e9678" translate="yes" xml:space="preserve">
          <source>An immediate which can be loaded with the il/ila/ilh/ilhu instructions. const_int is treated as a 32 bit value.</source>
          <target state="translated">il / ila / ilh / ilhu 지침과 함께 즉시로드 할 수 있습니다. const_int는 32 비트 값으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="8b91f62ddf90eb3045924f61638e2ed286dc7c16" translate="yes" xml:space="preserve">
          <source>An immediate which can be loaded with the il/ila/ilh/ilhu instructions. const_int is treated as a 64 bit value.</source>
          <target state="translated">il / ila / ilh / ilhu 지침과 함께 즉시로드 할 수 있습니다. const_int는 64 비트 값으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="d6e53dc412a13c67bb00bedf4c0eac4f87ba77c1" translate="yes" xml:space="preserve">
          <source>An important caveat is that GCC arranges to save and restore only those registers known to the specific architecture variant being compiled for. This can make &lt;code&gt;__builtin_setjmp&lt;/code&gt; and &lt;code&gt;__builtin_longjmp&lt;/code&gt; more efficient than their library counterparts in some cases, but it can also cause incorrect and mysterious behavior when mixing with code that uses the full register set.</source>
          <target state="translated">중요한주의 사항은 GCC가 컴파일 할 특정 아키텍처 변형에 알려진 레지스터 만 저장하고 복원한다는 것입니다. 이 경우 &lt;code&gt;__builtin_setjmp&lt;/code&gt; 및 &lt;code&gt;__builtin_longjmp&lt;/code&gt; 가 라이브러리에 비해 효율적일 수 있지만 전체 레지스터 세트를 사용하는 코드와 혼합 할 때 부정확하고 신비한 동작이 발생할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4bb50275db5ef990a5c71386c85806595b867df5" translate="yes" xml:space="preserve">
          <source>An indexed or indirect address.</source>
          <target state="translated">An indexed or indirect address.</target>
        </trans-unit>
        <trans-unit id="e86c0eceb044416401abb04a6e463d5b6094cd25" translate="yes" xml:space="preserve">
          <source>An input register that is implicitly popped by the &lt;code&gt;asm&lt;/code&gt; must be explicitly clobbered, unless it is constrained to match an output operand.</source>
          <target state="translated">출력 피연산자와 일치하도록 제한되지 않는 한 &lt;code&gt;asm&lt;/code&gt; 에 의해 암시 적으로 팝되는 입력 레지스터는 명시 적으로 클로버되어야합니다.</target>
        </trans-unit>
        <trans-unit id="7c249498e8a7c24a4e363a078596ccff4c5734ab" translate="yes" xml:space="preserve">
          <source>An integer constant in the range -255 &amp;hellip; 0</source>
          <target state="translated">-255&amp;hellip; 0 범위의 정수 상수</target>
        </trans-unit>
        <trans-unit id="9dc7773cc8d9e6deceeb329e43d478d46251dfd7" translate="yes" xml:space="preserve">
          <source>An integer constant in the range 0 &amp;hellip; 255.</source>
          <target state="translated">0&amp;hellip; 255 범위의 정수 상수.</target>
        </trans-unit>
        <trans-unit id="5b08127ba5b721033e68de80fdaced9cd1b46db8" translate="yes" xml:space="preserve">
          <source>An integer constant in the range 1 &amp;hellip; 15.</source>
          <target state="translated">1&amp;hellip; 15 범위의 정수 상수.</target>
        </trans-unit>
        <trans-unit id="e28d87e9d901db2966f212d84f0e7048b61d9b95" translate="yes" xml:space="preserve">
          <source>An integer constant in the range 1 &amp;hellip; 7.</source>
          <target state="translated">1&amp;hellip; 7 범위의 정수 상수.</target>
        </trans-unit>
        <trans-unit id="bcc6027cc8de73ec51a063277dae667199da440f" translate="yes" xml:space="preserve">
          <source>An integer constant that does not meet the constraints for codes &amp;lsquo;</source>
          <target state="translated">코드 제약 조건을 충족하지 않는 정수 상수</target>
        </trans-unit>
        <trans-unit id="c84f7429b210360fa5c85dafb3a76127af085fed" translate="yes" xml:space="preserve">
          <source>An integer constant that fits in 16 bits.</source>
          <target state="translated">16 비트에 맞는 정수 상수입니다.</target>
        </trans-unit>
        <trans-unit id="7ea8f3048d5d170816523d297bd8775793dabcbf" translate="yes" xml:space="preserve">
          <source>An integer constant whose low order 16 bits are zero.</source>
          <target state="translated">하위 16 비트가 0 인 정수 상수입니다.</target>
        </trans-unit>
        <trans-unit id="91669a0b9c65d1cc6722fd1ac4e811cb3b9462cf" translate="yes" xml:space="preserve">
          <source>An integer constant with all bits set except exactly one.</source>
          <target state="translated">정확히 1을 제외한 모든 비트가 설정된 정수 상수.</target>
        </trans-unit>
        <trans-unit id="21493d2e6936d92d54e34c6a9c53ba6429a374d6" translate="yes" xml:space="preserve">
          <source>An integer constant with exactly a single bit set.</source>
          <target state="translated">정확히 단일 비트 세트를 갖는 정수 상수.</target>
        </trans-unit>
        <trans-unit id="148e29efc3e25eee684ae13925c5fb8932f17d90" translate="yes" xml:space="preserve">
          <source>An integer equal to one of the MACFLAG_XXX constants that is suitable for use only with accumulator A1.</source>
          <target state="translated">누산기 A1에만 사용하기에 적합한 MACFLAG_XXX 상수 중 하나와 동일한 정수입니다.</target>
        </trans-unit>
        <trans-unit id="f4afba48092a6cec863cdd332d5c5c0ad22e2831" translate="yes" xml:space="preserve">
          <source>An integer equal to one of the MACFLAG_XXX constants that is suitable for use with either accumulator.</source>
          <target state="translated">하나의 누산기와 함께 사용하기에 적합한 MACFLAG_XXX 상수 중 하나와 동일한 정수.</target>
        </trans-unit>
        <trans-unit id="ff1c35a13fe5ef99c7a9d9e7d6ae5125aea6469c" translate="yes" xml:space="preserve">
          <source>An interrupt handler must be declared with a mandatory pointer argument:</source>
          <target state="translated">인터럽트 핸들러는 필수 포인터 인수로 선언해야합니다.</target>
        </trans-unit>
        <trans-unit id="d371e86b4fb307c14a25adf02422873dfe31a1a2" translate="yes" xml:space="preserve">
          <source>An inverted bitfield mask suitable for bext or bins</source>
          <target state="translated">Bext 또는 Bin에 적합한 반전 비트 필드 마스크</target>
        </trans-unit>
        <trans-unit id="d009fe9b76c291a5aa0c7f6c1e8d1138fabbeb43" translate="yes" xml:space="preserve">
          <source>An item in the constant pool</source>
          <target state="translated">상수 풀의 항목</target>
        </trans-unit>
        <trans-unit id="4793f292bc93fcd62120f48245f5e44fb822389b" translate="yes" xml:space="preserve">
          <source>An object file to be fed straight into linking. Any file name with no recognized suffix is treated this way.</source>
          <target state="translated">링크에 직접 공급할 오브젝트 파일. 인식되는 접미사가없는 파일 이름은이 방식으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="bf8b9f9703de2f2ca710a30d52808d7dca0bcb72" translate="yes" xml:space="preserve">
          <source>An object whose identifier is declared with the storage-class specifier &lt;code&gt;__thread&lt;/code&gt; has &lt;em&gt;thread storage duration&lt;/em&gt;. Its lifetime is the entire execution of the thread, and its stored value is initialized only once, prior to thread startup.</source>
          <target state="translated">스토리지 클래스 지정자 &lt;code&gt;__thread&lt;/code&gt; 로 식별자가 선언 된 오브젝트 에는 &lt;em&gt;스레드 스토리지 기간이&lt;/em&gt; 있습니다. 수명은 전체 스레드 실행이며 저장된 값은 스레드 시작 전에 한 번만 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="52a7967fec1a33e4d839edd6eff5a38decb9b59d" translate="yes" xml:space="preserve">
          <source>An offset address</source>
          <target state="translated">오프셋 주소</target>
        </trans-unit>
        <trans-unit id="89feeff33c633de750f5bb644b0891d21925addb" translate="yes" xml:space="preserve">
          <source>An offset address.</source>
          <target state="translated">오프셋 주소.</target>
        </trans-unit>
        <trans-unit id="aa367c1ec44c9cba3102e666432b6606342ed893" translate="yes" xml:space="preserve">
          <source>An operand that is a valid memory address is allowed. This is for &amp;ldquo;load address&amp;rdquo; and &amp;ldquo;push address&amp;rdquo; instructions.</source>
          <target state="translated">유효한 메모리 주소 인 피연산자가 허용됩니다. 이것은 &quot;로드 주소&quot;및 &quot;푸시 주소&quot;지침입니다.</target>
        </trans-unit>
        <trans-unit id="44a3bc3b1208cdb1273c2b09519bfd9e1cfc45ea" translate="yes" xml:space="preserve">
          <source>An operand that matches the specified operand number is allowed. If a digit is used together with letters within the same alternative, the digit should come last.</source>
          <target state="translated">지정된 피연산자 번호와 일치하는 피연산자가 허용됩니다. 같은 대안 내에서 숫자를 문자와 함께 사용하면 숫자가 마지막에옵니다.</target>
        </trans-unit>
        <trans-unit id="d0d03643cf5743c896341a88665563cee4e7f14b" translate="yes" xml:space="preserve">
          <source>An optimization that assumes that signed overflow does not occur is perfectly safe if the values of the variables involved are such that overflow never does, in fact, occur. Therefore this warning can easily give a false positive: a warning about code that is not actually a problem. To help focus on important issues, several warning levels are defined. No warnings are issued for the use of undefined signed overflow when estimating how many iterations a loop requires, in particular when determining whether a loop will be executed at all.</source>
          <target state="translated">관련된 변수의 값이 실제로 오버플로가 발생하지 않는 값인 경우 부호있는 오버플로가 발생하지 않는다고 가정하는 최적화는 완벽하게 안전합니다. 따라서이 경고는 실제로 문제가 아닌 코드에 대한 경고 인 오 탐지를 쉽게 제공 할 수 있습니다. 중요한 문제에 집중할 수 있도록 몇 가지 경고 수준이 정의되어 있습니다. 루프에 필요한 반복 횟수를 예측할 때, 특히 루프의 실행 여부를 결정할 때 정의되지 않은 부호있는 오버플로 사용에 대한 경고는 없습니다.</target>
        </trans-unit>
        <trans-unit id="b187d1cbe2c1e6182a8dd178f33fdc1911f0fd4c" translate="yes" xml:space="preserve">
          <source>An overview of these techniques, their benefits and how to use them is at &lt;a href=&quot;http://gcc.gnu.org/wiki/Visibility&quot;&gt;http://gcc.gnu.org/wiki/Visibility&lt;/a&gt;.</source>
          <target state="translated">이러한 기술에 대한 개요, 장점 및 사용 방법은 &lt;a href=&quot;http://gcc.gnu.org/wiki/Visibility&quot;&gt;http://gcc.gnu.org/wiki/Visibility에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="78963be09ff63d4ade4602b745f27f40ed01fe1b" translate="yes" xml:space="preserve">
          <source>An unsigned 16-bit constant (for logic instructions).</source>
          <target state="translated">부호없는 16 비트 상수 (논리 명령어 용).</target>
        </trans-unit>
        <trans-unit id="5b34b8bcf92baede87b31604702d88f2552f8622" translate="yes" xml:space="preserve">
          <source>An unsigned 16-bit constant for &lt;code&gt;iohl&lt;/code&gt; and &lt;code&gt;fsmbi&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;iohl&lt;/code&gt; 및 &lt;code&gt;fsmbi&lt;/code&gt; 에 대한 부호없는 16 비트 상수입니다 .</target>
        </trans-unit>
        <trans-unit id="c10f415d71c7e7066c4b909d3f1393b2cce4e125" translate="yes" xml:space="preserve">
          <source>An unsigned 16-bit constant shifted left 16 bits (use &lt;code&gt;L&lt;/code&gt; instead for &lt;code&gt;SImode&lt;/code&gt; constants).</source>
          <target state="translated">An unsigned 16-bit constant shifted left 16 bits (use &lt;code&gt;L&lt;/code&gt; instead for &lt;code&gt;SImode&lt;/code&gt; constants).</target>
        </trans-unit>
        <trans-unit id="8cb9a0ccfe5c932918592859dcea72edc71b9826" translate="yes" xml:space="preserve">
          <source>An unsigned 16-bit constant.</source>
          <target state="translated">부호없는 16 비트 상수</target>
        </trans-unit>
        <trans-unit id="bb28e9e819d64e02267cdf40ed8e86dabcf29201" translate="yes" xml:space="preserve">
          <source>An unsigned 16-bit integer constant.</source>
          <target state="translated">An unsigned 16-bit integer constant.</target>
        </trans-unit>
        <trans-unit id="40ef4bae4950c14cd2a335ebce3f24b00931f1ee" translate="yes" xml:space="preserve">
          <source>An unsigned 3-bit constant for 16-byte rotates and shifts</source>
          <target state="translated">16 바이트 회전 및 시프트를위한 ​​부호없는 3 비트 상수</target>
        </trans-unit>
        <trans-unit id="95ddaf18fc4d2ab678603464648f03bb8de98a4d" translate="yes" xml:space="preserve">
          <source>An unsigned 5-bit constant.</source>
          <target state="translated">부호없는 5 비트 상수</target>
        </trans-unit>
        <trans-unit id="7983abc6cf90ba7d41ddff4f3b8b3d5f6d999d50" translate="yes" xml:space="preserve">
          <source>An unsigned 5-bit integer constant (for shift counts).</source>
          <target state="translated">An unsigned 5-bit integer constant (for shift counts).</target>
        </trans-unit>
        <trans-unit id="b6a00eda1fa05aab415bb11f10e795bf964e4785" translate="yes" xml:space="preserve">
          <source>An unsigned 7-bit constant for conversion/nop/channel instructions.</source>
          <target state="translated">변환 / 노프 / 채널 명령어를위한 부호없는 7 비트 상수.</target>
        </trans-unit>
        <trans-unit id="5b0bf2d7544790a0320ec8391816f55aa165f088" translate="yes" xml:space="preserve">
          <source>An unsigned 7-bit constant whose 3 least significant bits are 0.</source>
          <target state="translated">3 개의 최하위 비트가 0 인 부호없는 7 비트 상수.</target>
        </trans-unit>
        <trans-unit id="d8264da1da251da38e16c7abcf0200adc7f6c27d" translate="yes" xml:space="preserve">
          <source>An unsigned 8-bit integer constant.</source>
          <target state="translated">An unsigned 8-bit integer constant.</target>
        </trans-unit>
        <trans-unit id="8e8a3cd83ae17cf2c173ff325905d55cd210117b" translate="yes" xml:space="preserve">
          <source>An x86 example where the string memory argument is of unknown length.</source>
          <target state="translated">문자열 메모리 인수의 길이를 알 수없는 x86 예제</target>
        </trans-unit>
        <trans-unit id="8157a3070b0a23e585bb72291a5f64fac3066253" translate="yes" xml:space="preserve">
          <source>And the function names are:</source>
          <target state="translated">함수 이름은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cce6aeb578cc150b67e8e4f1acfc181fb9996f38" translate="yes" xml:space="preserve">
          <source>Annotate assembler instructions with estimated addresses.</source>
          <target state="translated">추정 된 주소로 어셈블러 명령어에 주석을 답니다.</target>
        </trans-unit>
        <trans-unit id="295ae69532c434798f968812e2201e5c3fd052fa" translate="yes" xml:space="preserve">
          <source>Annotate assignments to user variables early in the compilation and attempt to carry the annotations over throughout the compilation all the way to the end, in an attempt to improve debug information while optimizing. Use of</source>
          <target state="translated">컴파일 초기에 사용자 변수에 할당에 주석을 달고 최적화하는 동안 디버그 정보를 개선하기 위해 컴파일 전체에서 주석을 끝까지 전달합니다. 사용</target>
        </trans-unit>
        <trans-unit id="71fb5f4abaa1eaa677691ec6945ce018c8d3cc8a" translate="yes" xml:space="preserve">
          <source>Annotate the assembler output with a comment indicating which pattern and alternative is used. The length and cost of each instruction are also printed.</source>
          <target state="translated">어떤 패턴과 대안이 사용되는지를 나타내는 주석으로 어셈블러 출력에 주석을 답니다. 각 명령의 길이와 비용도 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="93a92e7968152fb0b277671cc51df48b140f38ff" translate="yes" xml:space="preserve">
          <source>Annotate the assembler output with miscellaneous debugging information.</source>
          <target state="translated">기타 디버깅 정보로 어셈블러 출력에 주석을 답니다.</target>
        </trans-unit>
        <trans-unit id="989a73be7d945cbd818654da9eb44b704400138e" translate="yes" xml:space="preserve">
          <source>Another (simpler) way to enable link-time optimization is:</source>
          <target state="translated">링크 타임 최적화를 가능하게하는 또 다른 (간단한) 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="68f160715f630ab62644e4593ac2d81e2aac8d1b" translate="yes" xml:space="preserve">
          <source>Another consequence is that &lt;code&gt;sscanf&lt;/code&gt; does not work on some very old systems when passed a string constant as its format control string or input. This is because &lt;code&gt;sscanf&lt;/code&gt; incorrectly tries to write into the string constant. Likewise &lt;code&gt;fscanf&lt;/code&gt; and &lt;code&gt;scanf&lt;/code&gt;.</source>
          <target state="translated">또 다른 결과는 &lt;code&gt;sscanf&lt;/code&gt; 가 형식 제어 문자열 또는 입력으로 문자열 상수를 전달할 때 아주 오래된 일부 시스템에서 작동하지 않는다는 것입니다. &lt;code&gt;sscanf&lt;/code&gt; 가 문자열 상수에 잘못 쓰려고 하기 때문 입니다. 마찬가지로 &lt;code&gt;fscanf&lt;/code&gt; 및 &lt;code&gt;scanf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dedf5ccdeb6bf446ef7cfb01d8db4c4b042b2078" translate="yes" xml:space="preserve">
          <source>Another example:</source>
          <target state="translated">다른 예시:</target>
        </trans-unit>
        <trans-unit id="3114d5262ea0b2a7df098211946bd465d7ca75ca" translate="yes" xml:space="preserve">
          <source>Another feature of LTO is that it is possible to apply interprocedural optimizations on files written in different languages:</source>
          <target state="translated">LTO의 또 다른 기능은 다른 언어로 작성된 파일에 절차 간 최적화를 적용 할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="800bcf1831a315ef5fa60f82c87dd864fc821d9c" translate="yes" xml:space="preserve">
          <source>Another restriction is that the clobber list should not contain the stack pointer register. This is because the compiler requires the value of the stack pointer to be the same after an &lt;code&gt;asm&lt;/code&gt; statement as it was on entry to the statement. However, previous versions of GCC did not enforce this rule and allowed the stack pointer to appear in the list, with unclear semantics. This behavior is deprecated and listing the stack pointer may become an error in future versions of GCC.</source>
          <target state="translated">또 다른 제한 사항은 클로버 목록에 스택 포인터 레지스터가 포함되지 않아야한다는 것입니다. 컴파일러는 스택 포인터의 값이 명령문에 진입 할 때와 &lt;code&gt;asm&lt;/code&gt; 명령문 이후에 같아야하기 때문 입니다. 그러나 이전 버전의 GCC에서는이 규칙을 적용하지 않았으며 의미가 명확하지 않은 스택 포인터가 목록에 표시되도록 허용했습니다. 이 동작은 더 이상 사용되지 않으며 향후 GCC 버전에서 스택 포인터를 나열하면 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06cec1a74ddd904f5065125e6e0eba36e86de4da" translate="yes" xml:space="preserve">
          <source>Another revised ISO C++ standard was published in 2014 as ISO/IEC 14882:2014, and is referred to as C++14; before its publication it was sometimes referred to as C++1y. C++14 contains several further changes to the C++ language, all of which have been implemented in GCC. For details see &lt;a href=&quot;https://gcc.gnu.org/projects/cxx-status.html#cxx14&quot;&gt;https://gcc.gnu.org/projects/cxx-status.html#cxx14&lt;/a&gt;. To select this standard in GCC, use the option</source>
          <target state="translated">또 다른 개정 된 ISO C ++ 표준은 2014 년에 ISO / IEC 14882 : 2014로 출판되었으며 C ++ 14라고합니다. 출판 전에는 때때로 C ++ 1y라고 불렸다. C ++ 14에는 C ++ 언어에 대한 몇 가지 추가 변경 사항이 포함되어 있으며 모두 GCC로 구현되었습니다. 자세한 내용은 &lt;a href=&quot;https://gcc.gnu.org/projects/cxx-status.html#cxx14&quot;&gt;https://gcc.gnu.org/projects/cxx-status.html#cxx14를&lt;/a&gt; 참조 하십시오 . GCC에서이 표준을 선택하려면 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="100b9161d8847e18a3c098c1597e4c27bddc1e4a" translate="yes" xml:space="preserve">
          <source>Another syntax that has the same meaning, obsolete since GCC 2.5, is &amp;lsquo;</source>
          <target state="translated">GCC 2.5 이후로 더 이상 사용되지 않는 동일한 의미를 가진 또 다른 구문은 '</target>
        </trans-unit>
        <trans-unit id="8d4503c0d7b11d51381b2775fa2f1d0bc68346b0" translate="yes" xml:space="preserve">
          <source>Another use for &lt;code&gt;__builtin_unreachable&lt;/code&gt; is following a call a function that never returns but that is not declared &lt;code&gt;__attribute__((noreturn))&lt;/code&gt;, as in this example:</source>
          <target state="translated">&lt;code&gt;__builtin_unreachable&lt;/code&gt; 의 또 다른 용도 는이 예제에서와 같이 반환되지 않지만 &lt;code&gt;__attribute__((noreturn))&lt;/code&gt; 선언되지 않은 함수 호출을 따르는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="b5c0df1874478fedada2f09d07323584aaf952db" translate="yes" xml:space="preserve">
          <source>Another use of label values is in an interpreter for threaded code. The labels within the interpreter function can be stored in the threaded code for super-fast dispatching.</source>
          <target state="translated">레이블 값의 또 다른 사용은 스레드 코드의 인터프리터입니다. 인터프리터 기능 내의 레이블은 초고속 디스패치를 ​​위해 스레드 코드에 저장 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="054bb42dabc9a19f68ad68065d19f8cf04a8d0cf" translate="yes" xml:space="preserve">
          <source>Another way to refer to the type of an expression is with &lt;code&gt;typeof&lt;/code&gt;. The syntax of using of this keyword looks like &lt;code&gt;sizeof&lt;/code&gt;, but the construct acts semantically like a type name defined with &lt;code&gt;typedef&lt;/code&gt;.</source>
          <target state="translated">식의 형식을 참조하는 또 다른 방법은 &lt;code&gt;typeof&lt;/code&gt; 입니다. 이 키워드를 사용하는 구문은 &lt;code&gt;sizeof&lt;/code&gt; 와 비슷하지만 구문은 &lt;code&gt;typedef&lt;/code&gt; 로 정의 된 형식 이름처럼 의미 적으로 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="a721e97bbca8eab5f82eabfccb957a729c8f492f" translate="yes" xml:space="preserve">
          <source>Another way to specify a prefix much like the</source>
          <target state="translated">접두사를 지정하는 다른 방법은</target>
        </trans-unit>
        <trans-unit id="96409c8e4594c5ca23408453d9c7d3939d189e53" translate="yes" xml:space="preserve">
          <source>Another, similar example involves calling member functions of a base class:</source>
          <target state="translated">또 다른 유사한 예는 기본 클래스의 멤버 함수 호출과 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="53491a8e8187c94a2d02f53706e5a4e898389bcf" translate="yes" xml:space="preserve">
          <source>Any 80387 floating-point (stack) register.</source>
          <target state="translated">80387 부동 소수점 (스택) 레지스터</target>
        </trans-unit>
        <trans-unit id="b3758814c17061e556dad37977ffba674151e160" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;symbol_ref&lt;/code&gt; or &lt;code&gt;label_ref&lt;/code&gt;</source>
          <target state="translated">모든 &lt;code&gt;symbol_ref&lt;/code&gt; 또는 &lt;code&gt;label_ref&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b2f752342a0bbfde2ec460c7e0098752d0a9c8ba" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;unspec&lt;/code&gt;</source>
          <target state="translated">모든 &lt;code&gt;unspec&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="08321582787b969fc3f46ec2caec6f021be74d45" translate="yes" xml:space="preserve">
          <source>Any D, P, B, M, I or L register.</source>
          <target state="translated">모든 D, P, B, M, I 또는 L 레지스터.</target>
        </trans-unit>
        <trans-unit id="a4d7faf7c72e44e81295ee83f9349235dc1598af" translate="yes" xml:space="preserve">
          <source>Any EVEX encodable SSE register (&lt;code&gt;%xmm0-%xmm31&lt;/code&gt;).</source>
          <target state="translated">EVEX 인코딩 가능한 SSE 레지스터 ( &lt;code&gt;%xmm0-%xmm31&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="162a9ef967e5306147bc46c88126767e87c35020" translate="yes" xml:space="preserve">
          <source>Any MMX register.</source>
          <target state="translated">모든 MMX 레지스터.</target>
        </trans-unit>
        <trans-unit id="6c6a18dc34784ab21c4ba11b353b499414254204" translate="yes" xml:space="preserve">
          <source>Any SSE register.</source>
          <target state="translated">모든 SSE 레지스터.</target>
        </trans-unit>
        <trans-unit id="6050748b38d243b476a4baca6c16743585fafbd7" translate="yes" xml:space="preserve">
          <source>Any SYMBOL_REF.</source>
          <target state="translated">모든 SYMBOL_REF</target>
        </trans-unit>
        <trans-unit id="458f2948a2c464f5746c7ffc43449a651a2011cd" translate="yes" xml:space="preserve">
          <source>Any VSX register if the</source>
          <target state="translated">모든 VSX 레지스터</target>
        </trans-unit>
        <trans-unit id="d8389ba5b054471dbefb65e013349dc9adfee3c7" translate="yes" xml:space="preserve">
          <source>Any array can be subscripted, even if not an lvalue.</source>
          <target state="translated">lvalue가 아닌 경우에도 모든 배열을 첨자화할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b906590ae8882826b85c1f14c38d4cf1bfbb5d1f" translate="yes" xml:space="preserve">
          <source>Any condition register field, &lt;code&gt;cr0&lt;/code&gt;&amp;hellip;&lt;code&gt;cr7&lt;/code&gt;.</source>
          <target state="translated">Any condition register field, &lt;code&gt;cr0&lt;/code&gt; &amp;hellip; &lt;code&gt;cr7&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="14b564784ad63437bf2bebc716f7f298f61a5028" translate="yes" xml:space="preserve">
          <source>Any const_double value.</source>
          <target state="translated">const_double 값입니다.</target>
        </trans-unit>
        <trans-unit id="1e9dc0d4d4d3fa3953a7b89d1659a04266824dc2" translate="yes" xml:space="preserve">
          <source>Any control register, when they&amp;rsquo;re 16 bits wide (nothing if control registers are 24 bits wide)</source>
          <target state="translated">16 비트 너비의 제어 레지스터 (제어 레지스터의 너비가 24 비트 인 경우 아무것도 없음)</target>
        </trans-unit>
        <trans-unit id="dcdd92208f9952a1f355fdf3b7526b8f7a44d2c0" translate="yes" xml:space="preserve">
          <source>Any control register, when they&amp;rsquo;re 24 bits wide.</source>
          <target state="translated">폭이 24 비트 인 모든 제어 레지스터.</target>
        </trans-unit>
        <trans-unit id="7e9a960c7b57410e9d4ca5df2e5f2e42c59f7d8b" translate="yes" xml:space="preserve">
          <source>Any data or pointers to the non-generic address spaces must be qualified as &lt;code&gt;const&lt;/code&gt;, i.e. as read-only data. This still applies if the data in one of these address spaces like software version number or calibration lookup table are intended to be changed after load time by, say, a boot loader. In this case the right qualification is &lt;code&gt;const&lt;/code&gt;&lt;code&gt;volatile&lt;/code&gt; so that the compiler must not optimize away known values or insert them as immediates into operands of instructions.</source>
          <target state="translated">비 일반 주소 공간에 대한 모든 데이터 또는 포인터는 &lt;code&gt;const&lt;/code&gt; 즉, 읽기 전용 데이터로 규정되어야합니다 . 소프트웨어 버전 번호 또는 캘리브레이션 룩업 테이블과 같은 주소 공간 중 하나의 데이터가로드 로더, 예를 들어 부트 로더에 의해 변경되도록 의도 된 경우에도 여전히 적용됩니다. 이 경우 올바른 자격은 &lt;code&gt;const&lt;/code&gt; 를 &lt;code&gt;volatile&lt;/code&gt; 컴파일러가 최적화 멀리 값을 알려진 또는 명령의 피연산자로 immediate 만로 삽입하지 않아야 정도로는.</target>
        </trans-unit>
        <trans-unit id="05a587b8fa898666a201d21b98455df1bf047bae" translate="yes" xml:space="preserve">
          <source>Any data with the &lt;code&gt;noinit&lt;/code&gt; attribute will not be initialised by the C runtime startup code, or the program loader. Not initialising data in this way can reduce program startup times.</source>
          <target state="translated">&lt;code&gt;noinit&lt;/code&gt; 속성을 가진 데이터 는 C 런타임 시작 코드 또는 프로그램 로더에 의해 초기화되지 않습니다. 이런 방식으로 데이터를 초기화하지 않으면 프로그램 시작 시간이 단축 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b31ade70b5b6adb7eda689c140579a407cbd5f8e" translate="yes" xml:space="preserve">
          <source>Any data with the &lt;code&gt;noinit&lt;/code&gt; attribute will not be initialized by the C runtime startup code, or the program loader. Not initializing data in this way can reduce program startup times. This attribute is specific to ELF targets and relies on the linker to place such data in the right location</source>
          <target state="translated">Any data with the &lt;code&gt;noinit&lt;/code&gt; attribute will not be initialized by the C runtime startup code, or the program loader. Not initializing data in this way can reduce program startup times. This attribute is specific to ELF targets and relies on the linker to place such data in the right location</target>
        </trans-unit>
        <trans-unit id="1647cf01ffb6c880e2cc9ddc546cf116110a80e6" translate="yes" xml:space="preserve">
          <source>Any dependence for which the latency is greater than or equal to &lt;var&gt;number&lt;/var&gt; is costly.</source>
          <target state="translated">레이턴시가 &lt;var&gt;number&lt;/var&gt; 보다 크거나 같은 의존성 은 비용이 많이 든다.</target>
        </trans-unit>
        <trans-unit id="54d255d43091079c6ba1e5343929cbd0d4605f04" translate="yes" xml:space="preserve">
          <source>Any dependence from store to load is costly.</source>
          <target state="translated">상점에서로드까지의 종속성은 비용이 많이 듭니다.</target>
        </trans-unit>
        <trans-unit id="32b989b6176274d8479bf98d4817d8a49a56f0e0" translate="yes" xml:space="preserve">
          <source>Any directories specified with</source>
          <target state="translated">로 지정된 모든 디렉토리</target>
        </trans-unit>
        <trans-unit id="1d356594a5d83b50830291445eb406f59dd05afc" translate="yes" xml:space="preserve">
          <source>Any expression of type &lt;code&gt;void *&lt;/code&gt; is allowed.</source>
          <target state="translated">&lt;code&gt;void *&lt;/code&gt; 유형의 모든 표현식 이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="68030c2dfbf4d205419f4c53b98009b37766c0cb" translate="yes" xml:space="preserve">
          <source>Any extended integer types that exist in the implementation (C99 and C11 6.2.5).</source>
          <target state="translated">구현에 존재하는 확장 정수 유형 (C99 및 C11 6.2.5).</target>
        </trans-unit>
        <trans-unit id="6f1de0dfba46a4460bfe571dd6ce87a521e49944" translate="yes" xml:space="preserve">
          <source>Any interruptible-without-stack-switch code must be compiled with</source>
          <target state="translated">스택 스위치가없는 인터럽트 가능 코드는</target>
        </trans-unit>
        <trans-unit id="d0a99fee73d1a0400c42d60b6ea95667d276cf8e" translate="yes" xml:space="preserve">
          <source>Any list of specifiers and qualifiers at the start of a declaration may contain attribute specifiers, whether or not such a list may in that context contain storage class specifiers. (Some attributes, however, are essentially in the nature of storage class specifiers, and only make sense where storage class specifiers may be used; for example, &lt;code&gt;section&lt;/code&gt;.) There is one necessary limitation to this syntax: the first old-style parameter declaration in a function definition cannot begin with an attribute specifier, because such an attribute applies to the function instead by syntax described below (which, however, is not yet implemented in this case). In some other cases, attribute specifiers are permitted by this grammar but not yet supported by the compiler. All attribute specifiers in this place relate to the declaration as a whole. In the obsolescent usage where a type of &lt;code&gt;int&lt;/code&gt; is implied by the absence of type specifiers, such a list of specifiers and qualifiers may be an attribute specifier list with no other specifiers or qualifiers.</source>
          <target state="translated">선언의 시작 부분에있는 지정자 및 한정자 목록에는 해당 목록에 스토리지 클래스 지정자가 포함되어 있는지 여부에 관계없이 속성 지정자가 포함될 수 있습니다. 그러나 일부 속성은 본질적으로 스토리지 클래스 지정자의 특성에 따라 스토리지 클래스 지정자가 사용될 수있는 위치에만 적용됩니다 (예 : &lt;code&gt;section&lt;/code&gt; .)이 구문에는 한 가지 필수 제한 사항이 있습니다. 함수 정의의 첫 번째 이전 스타일 매개 변수 선언은 속성 지정자로 시작할 수 없습니다. 이러한 속성은 아래 설명 된 구문 대신 함수에 적용되기 때문입니다. 이 경우 구현). 다른 경우에는이 문법에서 속성 지정자를 허용하지만 아직 컴파일러에서 지원하지는 않습니다. 이 장소의 모든 속성 지정자는 선언 전체와 관련이 있습니다. 형식 지정자가 없기 때문에 &lt;code&gt;int&lt;/code&gt; 유형 이 암시되는 노후화 사용에서 이러한 지정자 및 규정 자 목록은 다른 지정자 또는 규정자가없는 속성 지정자 목록 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6c0071eb01b7f92c396e6d09604df6a2e8de02f" translate="yes" xml:space="preserve">
          <source>Any macros defined before the precompiled header is included must either be defined in the same way as when the precompiled header was generated, or must not affect the precompiled header, which usually means that they don&amp;rsquo;t appear in the precompiled header at all.</source>
          <target state="translated">사전 컴파일 된 헤더가 포함되기 전에 정의 된 모든 매크로는 사전 컴파일 된 헤더가 생성 될 때와 같은 방식으로 정의되거나 사전 컴파일 된 헤더에 영향을 미치지 않아야합니다. 이는 일반적으로 사전 컴파일 된 헤더에 전혀 표시되지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0b92c247ae43e16cb2206e363e27a0e1ea146660" translate="yes" xml:space="preserve">
          <source>Any memory reference to an address in the far address space.</source>
          <target state="translated">원거리 주소 공간의 주소에 대한 모든 메모리 참조</target>
        </trans-unit>
        <trans-unit id="e16a334f229304e5f8dc7cc1bd4372e8b13392d9" translate="yes" xml:space="preserve">
          <source>Any memory reference to an address in the near address space.</source>
          <target state="translated">가까운 주소 공간의 주소에 대한 모든 메모리 참조</target>
        </trans-unit>
        <trans-unit id="fd3f2043c21601ac2916c25995530fdcaff3e36d" translate="yes" xml:space="preserve">
          <source>Any mode at function entry is valid, and retained or restored when the function returns, and when it calls other functions. This mode is useful for compiling libraries or other compilation units you might want to incorporate into different programs with different prevailing FPU modes, and the convenience of being able to use a single object file outweighs the size and speed overhead for any extra mode switching that might be needed, compared with what would be needed with a more specific choice of prevailing FPU mode.</source>
          <target state="translated">함수 입력시 모든 모드가 유효하며 함수가 리턴 될 때와 다른 함수를 호출 할 때 유지되거나 복원됩니다. 이 모드는 다른 FPU 모드를 가진 다른 프로그램에 포함시키려는 라이브러리 또는 다른 컴파일 단위를 컴파일하는 데 유용하며 단일 오브젝트 파일을 사용할 수있는 편리함은 추가 모드 전환에 대한 크기 및 속도 오버 헤드보다 중요합니다. 일반적인 FPU 모드의보다 구체적인 선택에 필요한 것과 비교할 필요가 있습니다.</target>
        </trans-unit>
        <trans-unit id="22db441873bce8bb93866379f320414a736631d8" translate="yes" xml:space="preserve">
          <source>Any of the SVE predicate registers (&lt;code&gt;P0&lt;/code&gt; to &lt;code&gt;P15&lt;/code&gt;)</source>
          <target state="translated">SVE 술어 레지스터 중 하나 ( &lt;code&gt;P0&lt;/code&gt; ~ &lt;code&gt;P15&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="adb9f4f59a4cdd5c36fdb71fd2855542ab27a73f" translate="yes" xml:space="preserve">
          <source>Any of the floating point registers (AC0 through AC5).</source>
          <target state="translated">부동 소수점 레지스터 (AC0-AC5)</target>
        </trans-unit>
        <trans-unit id="9b07ecf518f850aa2d367035bbfbe9f027595c80" translate="yes" xml:space="preserve">
          <source>Any operand whatsoever is allowed.</source>
          <target state="translated">모든 피연산자가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="f68eb98cf68489e1273e0a62b2ba59241c457e20" translate="yes" xml:space="preserve">
          <source>Any register</source>
          <target state="translated">모든 레지스터</target>
        </trans-unit>
        <trans-unit id="3553311a1c2384ac5d5327beb00f7dd79264da05" translate="yes" xml:space="preserve">
          <source>Any register accessible as &lt;code&gt;&lt;var&gt;r&lt;/var&gt;h&lt;/code&gt;: &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, and &lt;code&gt;d&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;r&lt;/var&gt;h&lt;/code&gt; 로 액세스 할 수있는 모든 레지스터 : &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;c&lt;/code&gt; 및 &lt;code&gt;d&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0809f627bf7826a77322582ca3922a14c79d5ea4" translate="yes" xml:space="preserve">
          <source>Any register accessible as &lt;code&gt;&lt;var&gt;r&lt;/var&gt;l&lt;/code&gt;. In 32-bit mode, &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, and &lt;code&gt;d&lt;/code&gt;; in 64-bit mode, any integer register.</source>
          <target state="translated">모든는 접근 등록 &lt;code&gt;&lt;var&gt;r&lt;/var&gt;l&lt;/code&gt; . 32 비트 모드에서 &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;c&lt;/code&gt; 및 &lt;code&gt;d&lt;/code&gt; ; 64 비트 모드에서 모든 정수 레지스터</target>
        </trans-unit>
        <trans-unit id="c586b6a4345439cd7c8437d618d713fde64e21d5" translate="yes" xml:space="preserve">
          <source>Any register except accumulators or CC.</source>
          <target state="translated">누산기 또는 CC를 제외한 모든 레지스터.</target>
        </trans-unit>
        <trans-unit id="6f5e5f5ddbf2830c0d8f5e8f65ca789f3fd09903" translate="yes" xml:space="preserve">
          <source>Any register, memory or immediate integer operand is allowed, except for registers that are not general registers.</source>
          <target state="translated">일반 레지스터가 아닌 레지스터를 제외한 모든 레지스터, 메모리 또는 즉시 정수 피연산자가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="7d047e8a746fffe93cd425189ec60df3684116e7" translate="yes" xml:space="preserve">
          <source>Any variable with the &lt;code&gt;based&lt;/code&gt; attribute is assigned to the &lt;code&gt;.based&lt;/code&gt; section, and is accessed with relative to the &lt;code&gt;$tp&lt;/code&gt; register.</source>
          <target state="translated">&lt;code&gt;based&lt;/code&gt; 속성을 가진 변수 는 &lt;code&gt;.based&lt;/code&gt; 섹션에 할당되며 &lt;code&gt;$tp&lt;/code&gt; 레지스터 를 기준으로 액세스됩니다 .</target>
        </trans-unit>
        <trans-unit id="8e967d4316910c49c908407ba08671d2b2599c34" translate="yes" xml:space="preserve">
          <source>Any variable with the &lt;code&gt;persistent&lt;/code&gt; attribute will not be initialised by the C runtime startup code. Instead its value will be set once, when the application is loaded, and then never initialised again, even if the processor is reset or the program restarts. Persistent data is intended to be placed into FLASH RAM, where its value will be retained across resets. The linker script being used to create the application should ensure that persistent data is correctly placed.</source>
          <target state="translated">&lt;code&gt;persistent&lt;/code&gt; 속성을 가진 변수 는 C 런타임 시작 코드에 의해 초기화되지 않습니다. 대신 응용 프로그램이로드 될 때 해당 값이 한 번 설정되고 프로세서가 재설정되거나 프로그램이 다시 시작 되더라도 다시 초기화되지 않습니다. 영구 데이터는 FLASH RAM에 저장되도록되어 있으며,이 값은 재설정 동안 유지됩니다. 응용 프로그램을 만드는 데 사용되는 링커 스크립트는 영구 데이터가 올바르게 배치되도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="6814c1eba0c0bb145d77465185a812135711db30" translate="yes" xml:space="preserve">
          <source>Append &lt;var&gt;dir&lt;/var&gt; to the prefix specified previously with</source>
          <target state="translated">이전에 지정한 접두사에 &lt;var&gt;dir&lt;/var&gt; 을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="812a14ffbe77d828291132cdec93d807373c47c5" translate="yes" xml:space="preserve">
          <source>Application register residing in I-unit</source>
          <target state="translated">I- 유닛에 상주하는 애플리케이션 레지스터</target>
        </trans-unit>
        <trans-unit id="1236d15ff73551e90456786e45b32e0be147101a" translate="yes" xml:space="preserve">
          <source>Application register residing in M-unit</source>
          <target state="translated">M 유닛에 상주하는 애플리케이션 레지스터</target>
        </trans-unit>
        <trans-unit id="157c651a499c80b5c8fd2d703d99af67d3154b57" translate="yes" xml:space="preserve">
          <source>Apply partitioned execution optimizations. This is the default when any level of optimization is selected.</source>
          <target state="translated">파티션 된 실행 최적화를 적용하십시오. 최적화 수준을 선택한 경우 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="1782ef9fd22ce5aa8daf22e12703623a7b69b3eb" translate="yes" xml:space="preserve">
          <source>Apply the &lt;code&gt;longcall&lt;/code&gt; attribute to all subsequent function declarations.</source>
          <target state="translated">&lt;code&gt;longcall&lt;/code&gt; 속성을 모든 후속 함수 선언에 적용하십시오 .</target>
        </trans-unit>
        <trans-unit id="282eae08ca98891b7edf1b6d8797fd6b87a9eaef" translate="yes" xml:space="preserve">
          <source>Apply unroll and jam transformations on feasible loops. In a loop nest this unrolls the outer loop by some factor and fuses the resulting multiple inner loops. This flag is enabled by default at</source>
          <target state="translated">실행 가능한 루프에 언롤 및 잼 변형을 적용합니다. 루프 네스트에서 이것은 외부 루프를 어떤 요인으로 풀고 그 결과로 발생하는 여러 내부 루프를 융합시킵니다. 이 플래그는 기본적으로</target>
        </trans-unit>
        <trans-unit id="b040b4179b8b00702858fdb4c1afec3d6d284509" translate="yes" xml:space="preserve">
          <source>Architecture</source>
          <target state="translated">Architecture</target>
        </trans-unit>
        <trans-unit id="5180e6ec8c8c3a9e7de475a7424e90e67f44108f" translate="yes" xml:space="preserve">
          <source>Arguments of type &lt;code&gt;uh&lt;/code&gt;, &lt;code&gt;uw1&lt;/code&gt;, &lt;code&gt;sw1&lt;/code&gt;, &lt;code&gt;uw2&lt;/code&gt; and &lt;code&gt;sw2&lt;/code&gt; are evaluated at run time. They correspond to register operands in the underlying FR-V instructions.</source>
          <target state="translated">&lt;code&gt;uh&lt;/code&gt; , &lt;code&gt;uw1&lt;/code&gt; , &lt;code&gt;sw1&lt;/code&gt; , &lt;code&gt;uw2&lt;/code&gt; 및 &lt;code&gt;sw2&lt;/code&gt; 유형의 인수는 런타임에 평가됩니다. 기본 FR-V 명령어의 레지스터 피연산자에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="27b636e6a8cfc32ea746d5e97119c5c9f0abb374" translate="yes" xml:space="preserve">
          <source>Arguments that are documented as &lt;code&gt;const int&lt;/code&gt; require literal integral values within the range required for that operation.</source>
          <target state="translated">&lt;code&gt;const int&lt;/code&gt; 로 문서화 된 인수 에는 해당 연산에 필요한 범위 내의 리터럴 정수 값이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="56dc33ad93362bc115e17a1a1f9e847be1eea766" translate="yes" xml:space="preserve">
          <source>Arithmetic on &lt;code&gt;void&lt;/code&gt;-pointers and function pointers.</source>
          <target state="translated">&lt;code&gt;void&lt;/code&gt; 포인터와 함수 포인터에 대한 산술 .</target>
        </trans-unit>
        <trans-unit id="69bbb6fc13a2914af3927b07e93cd7741bc9feb7" translate="yes" xml:space="preserve">
          <source>Armv8-A</source>
          <target state="translated">Armv8-A</target>
        </trans-unit>
        <trans-unit id="660e1e41a2fb561d4417587f9d3cb0a826807dab" translate="yes" xml:space="preserve">
          <source>Armv8.1-A</source>
          <target state="translated">Armv8.1-A</target>
        </trans-unit>
        <trans-unit id="068702f6b509e3ebf3a7362a3b6109bad1bc317c" translate="yes" xml:space="preserve">
          <source>Armv8.2-A</source>
          <target state="translated">Armv8.2-A</target>
        </trans-unit>
        <trans-unit id="9fe2d2038a9bf766f6b65dbcea4a2090d8403b7b" translate="yes" xml:space="preserve">
          <source>Armv8.3-A</source>
          <target state="translated">Armv8.3-A</target>
        </trans-unit>
        <trans-unit id="0c3f33729a39f559eae20d5545e995ad551dd902" translate="yes" xml:space="preserve">
          <source>Armv8.4-A</source>
          <target state="translated">Armv8.4-A</target>
        </trans-unit>
        <trans-unit id="255ee3b7801398dad2fbbd56f35d7d60c8e0a39d" translate="yes" xml:space="preserve">
          <source>Armv8.5-A</source>
          <target state="translated">Armv8.5-A</target>
        </trans-unit>
        <trans-unit id="4b5d9fa165aea4d969d0093fec00424d91bb68a1" translate="yes" xml:space="preserve">
          <source>Armv8.6-A</source>
          <target state="translated">Armv8.6-A</target>
        </trans-unit>
        <trans-unit id="b47ecbfd9e2fe292a564bf4865f526df3c8781c7" translate="yes" xml:space="preserve">
          <source>Arrays whose length is computed at run time.</source>
          <target state="translated">런타임시 길이가 계산되는 배열입니다.</target>
        </trans-unit>
        <trans-unit id="62bbe9126770d1f883012b542af60463a81fc16c" translate="yes" xml:space="preserve">
          <source>As a GNU extension, GCC allows initialization of objects with static storage duration by compound literals (which is not possible in ISO C99 because the initializer is not a constant). It is handled as if the object were initialized only with the brace-enclosed list if the types of the compound literal and the object match. The elements of the compound literal must be constant. If the object being initialized has array type of unknown size, the size is determined by the size of the compound literal.</source>
          <target state="translated">GNU 확장으로서 GCC는 복합 리터럴에 의해 정적 저장 시간을 가진 객체의 초기화를 허용합니다 (초기화자가 상수가 아니기 때문에 ISO C99에서는 불가능합니다). 복합 리터럴 및 오브젝트의 유형이 일치하는 경우 오브젝트가 중괄호로 묶인 목록으로 만 초기화 된 것처럼 처리됩니다. 복합 리터럴의 요소는 일정해야합니다. 초기화되는 객체의 크기가 알 수없는 배열 유형 인 경우 크기는 복합 리터럴의 크기에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="f0b14342b73dd91f2d28adcdc3851266c0e2adc9" translate="yes" xml:space="preserve">
          <source>As a part of ACLE, GCC implements extensions for Advanced SIMD as described in the ARM C Language Extensions Specification. The complete list of Advanced SIMD intrinsics can be found at &lt;a href=&quot;http://infocenter.arm.com/help/topic/com.arm.doc.ihi0073a/IHI0073A_arm_neon_intrinsics_ref.pdf&quot;&gt;http://infocenter.arm.com/help/topic/com.arm.doc.ihi0073a/IHI0073A_arm_neon_intrinsics_ref.pdf&lt;/a&gt;. The built-in intrinsics for the Advanced SIMD extension are available when NEON is enabled.</source>
          <target state="translated">GCC는 ACLE의 일부로 ARM C 언어 확장 사양에 설명 된대로 고급 SIMD 용 확장을 구현합니다. 고급 SIMD 내장 함수의 전체 목록은 &lt;a href=&quot;http://infocenter.arm.com/help/topic/com.arm.doc.ihi0073a/IHI0073A_arm_neon_intrinsics_ref.pdf&quot;&gt;http://infocenter.arm.com/help/topic/com.arm.doc.ihi0073a/IHI0073A_arm_neon_intrinsics_ref.pdf&lt;/a&gt; 에서 찾을 수 있습니다 . NEON이 활성화되면 Advanced SIMD 확장을위한 내장 내장 함수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3bf025a6b55c5b2b4d36feb2983875ada48832c0" translate="yes" xml:space="preserve">
          <source>As a result, if a function compiled with Sun CC takes the address of an argument of type &lt;code&gt;double&lt;/code&gt; and passes this pointer of type &lt;code&gt;double *&lt;/code&gt; to a function compiled with GCC, dereferencing the pointer may cause a fatal signal.</source>
          <target state="translated">결과적으로 Sun CC로 컴파일 된 함수가 &lt;code&gt;double&lt;/code&gt; 유형의 인수 주소를 가져 와서 &lt;code&gt;double *&lt;/code&gt; 유형의이 포인터 를 GCC로 컴파일 된 함수에 전달하면 포인터를 역 참조하면 치명적인 신호가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70fe12b60268d72ed32d2dad542457f63b7450a6" translate="yes" xml:space="preserve">
          <source>As a result, when a file is compiled with the</source>
          <target state="translated">결과적으로 파일이</target>
        </trans-unit>
        <trans-unit id="de76cec1a0ee40014e9d6de2336c465c8c2b9403" translate="yes" xml:space="preserve">
          <source>As a special kludge, if the path provided by</source>
          <target state="translated">경로가 제공하는 경우 특별한 kludge로</target>
        </trans-unit>
        <trans-unit id="b70ccdaa2f1d44ed8f039d89a64ebf9722e0436b" translate="yes" xml:space="preserve">
          <source>As an alternative to providing a spec string, the text following a suffix directive can be one of the following:</source>
          <target state="translated">스펙 문자열을 제공하는 대신 접미어 지시문 뒤에 나오는 텍스트는 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dddf73cd98dcce7c884fe24956533693e61e8e3f" translate="yes" xml:space="preserve">
          <source>As an example:</source>
          <target state="translated">예로서:</target>
        </trans-unit>
        <trans-unit id="733120310e3f16a7d9b6ceb479247f71058a2dab" translate="yes" xml:space="preserve">
          <source>As an extension the integer scalar type &lt;code&gt;__int128&lt;/code&gt; is supported for targets which have an integer mode wide enough to hold 128 bits. Simply write &lt;code&gt;__int128&lt;/code&gt; for a signed 128-bit integer, or &lt;code&gt;unsigned __int128&lt;/code&gt; for an unsigned 128-bit integer. There is no support in GCC for expressing an integer constant of type &lt;code&gt;__int128&lt;/code&gt; for targets with &lt;code&gt;long long&lt;/code&gt; integer less than 128 bits wide.</source>
          <target state="translated">확장으로 정수 스칼라 유형 &lt;code&gt;__int128&lt;/code&gt; 은 128 비트를 보유하기에 충분한 정수 모드의 대상에 대해 지원됩니다. 간단하게 쓰기 &lt;code&gt;__int128&lt;/code&gt; 서명 된 128 비트 정수, 또는에 대한 &lt;code&gt;unsigned __int128&lt;/code&gt; 부호 128 비트 정수. 너비가 128 비트 미만인 &lt;code&gt;long long&lt;/code&gt; 정수가있는 대상에 &lt;code&gt;__int128&lt;/code&gt; 유형의 정수 상수를 표현하기 위해 GCC에서 지원되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a3f87270bea18e65d71a654a8f0baf39b38c480a" translate="yes" xml:space="preserve">
          <source>As an extension to the C language, GCC does not use the latitude given in C99 and C11 only to treat certain aspects of signed &amp;lsquo;</source>
          <target state="translated">C 언어의 확장으로 GCC는 C99 및 C11에 제공된 위도를 사용하여 서명 된 '</target>
        </trans-unit>
        <trans-unit id="4513679ee7e9cc2a019ac56fe5e24f303a414ac9" translate="yes" xml:space="preserve">
          <source>As an extension, GCC accepts variable-length arrays as a member of a structure or a union. For example:</source>
          <target state="translated">확장으로서 GCC는 가변 길이 배열을 구조체 또는 공용체의 멤버로 허용합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="27e4f48620a93a562285a400297cd393c63d1803" translate="yes" xml:space="preserve">
          <source>As an extension, GNU C and GNU C++ support additional floating types, which are not supported by all targets.</source>
          <target state="translated">확장으로 GNU C 및 GNU C ++는 추가 부동 유형을 지원하며 모든 대상에서 지원하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="697b66e118a429cde99672cf767b29bbf7517cb2" translate="yes" xml:space="preserve">
          <source>As an extension, GNU C supports decimal floating types as defined in the N1312 draft of ISO/IEC WDTR24732. Support for decimal floating types in GCC will evolve as the draft technical report changes. Calling conventions for any target might also change. Not all targets support decimal floating types.</source>
          <target state="translated">확장으로 GNU C는 ISO / IEC WDTR24732의 N1312 초안에 정의 된 십진 부동 유형을 지원합니다. GCC에서 10 진수 부동 유형에 대한 지원은 기술 보고서 ​​초안이 변경됨에 따라 발전합니다. 대상에 대한 호출 규칙도 변경 될 수 있습니다. 모든 대상이 10 진수 부동 유형을 지원하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="1e14a45ce2c917a5c2a3b3b95aa86553c2d0d4a7" translate="yes" xml:space="preserve">
          <source>As an extension, GNU C supports fixed-point types as defined in the N1169 draft of ISO/IEC DTR 18037. Support for fixed-point types in GCC will evolve as the draft technical report changes. Calling conventions for any target might also change. Not all targets support fixed-point types.</source>
          <target state="translated">확장으로 GNU C는 ISO / IEC DTR 18037의 N1169 초안에 정의 된대로 고정 소수점 유형을 지원합니다. GCC에서 고정 소수점 유형에 대한 지원은 기술 보고서 ​​초안이 변경됨에 따라 발전 할 것입니다. 대상에 대한 호출 규칙도 변경 될 수 있습니다. 모든 대상이 고정 소수점 유형을 지원하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="6505eef47254e959e5dceda5b17ed5092c6fdad3" translate="yes" xml:space="preserve">
          <source>As an extension, GNU C supports named address spaces as defined in the N1275 draft of ISO/IEC DTR 18037. Support for named address spaces in GCC will evolve as the draft technical report changes. Calling conventions for any target might also change. At present, only the AVR, M32C, RL78, and x86 targets support address spaces other than the generic address space.</source>
          <target state="translated">As an extension, GNU C supports named address spaces as defined in the N1275 draft of ISO/IEC DTR 18037. Support for named address spaces in GCC will evolve as the draft technical report changes. Calling conventions for any target might also change. At present, only the AVR, M32C, RL78, and x86 targets support address spaces other than the generic address space.</target>
        </trans-unit>
        <trans-unit id="7086d776842151d1d2c42c2e5523eaf5840573e5" translate="yes" xml:space="preserve">
          <source>As an extension, GNU C supports named address spaces as defined in the N1275 draft of ISO/IEC DTR 18037. Support for named address spaces in GCC will evolve as the draft technical report changes. Calling conventions for any target might also change. At present, only the AVR, SPU, M32C, RL78, and x86 targets support address spaces other than the generic address space.</source>
          <target state="translated">확장으로 GNU C는 ISO / IEC DTR 18037의 N1275 초안에 정의 된대로 명명 된 주소 공간을 지원합니다. GCC에서 명명 된 주소 공간에 대한 지원은 기술 보고서 ​​초안이 변경됨에 따라 발전 할 것입니다. 대상에 대한 호출 규칙도 변경 될 수 있습니다. 현재 AVR, SPU, M32C, RL78 및 x86 대상 만 일반 주소 공간 이외의 주소 공간을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="adca7822f575134857a5ee57f78ae4fe66d4c44f" translate="yes" xml:space="preserve">
          <source>As an optimization, G++ sometimes gives array compound literals longer lifetimes: when the array either appears outside a function or has a &lt;code&gt;const&lt;/code&gt;-qualified type. If &lt;code&gt;foo&lt;/code&gt; and its initializer had elements of type &lt;code&gt;char *const&lt;/code&gt; rather than &lt;code&gt;char *&lt;/code&gt;, or if &lt;code&gt;foo&lt;/code&gt; were a global variable, the array would have static storage duration. But it is probably safest just to avoid the use of array compound literals in C++ code.</source>
          <target state="translated">최적화로서, G ++는 때때로 배열 복합 리터럴을 더 긴 수명을 제공합니다 : 배열이 함수 외부에 나타나거나 &lt;code&gt;const&lt;/code&gt; 한정 유형을 가질 때 . 경우 &lt;code&gt;foo&lt;/code&gt; 는 그 이니셜 라이저 타입의 요소를 가지고 &lt;code&gt;char *const&lt;/code&gt; 하기보다는 &lt;code&gt;char *&lt;/code&gt; 경우, 또는 &lt;code&gt;foo&lt;/code&gt; 전역 변수했다, 배열은 정적 저장 기간을 가질 것이다. 그러나 C ++ 코드에서 배열 복합 리터럴을 사용하지 않는 것이 가장 안전합니다.</target>
        </trans-unit>
        <trans-unit id="4440512ea926e0e3e9623211be65c0fe001b769e" translate="yes" xml:space="preserve">
          <source>As another example,</source>
          <target state="translated">다른 예로서,</target>
        </trans-unit>
        <trans-unit id="c2d7d2d398b725a8ff7f6339f33b58fb71e37c73" translate="yes" xml:space="preserve">
          <source>As another example, the following call to &lt;code&gt;strncpy&lt;/code&gt; results in copying to &lt;code&gt;d&lt;/code&gt; just the characters preceding the terminating NUL, without appending the NUL to the end. Assuming the result of &lt;code&gt;strncpy&lt;/code&gt; is necessarily a NUL-terminated string is a common mistake, and so the call is diagnosed. To avoid the warning when the result is not expected to be NUL-terminated, call &lt;code&gt;memcpy&lt;/code&gt; instead.</source>
          <target state="translated">또 다른 예로서, &lt;code&gt;strncpy&lt;/code&gt; 에 대한 다음 호출 은 종료 NUL을 끝에 추가하지 않고 종료 NUL 앞에 오는 문자 만 &lt;code&gt;d&lt;/code&gt; 에 복사합니다 . &lt;code&gt;strncpy&lt;/code&gt; 의 결과 가 반드시 NUL 종료 문자열 이라고 가정하는 것은 일반적인 실수이므로 호출이 진단됩니다. 결과가 NUL로 종료 될 것으로 예상되지 않을 때 경고를 피하려면 대신 &lt;code&gt;memcpy&lt;/code&gt; 를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="f22e08722bb8e7ce646a0894d86b714e1a18ddc2" translate="yes" xml:space="preserve">
          <source>As bit-fields are not individually addressable, volatile bit-fields may be implicitly read when written to, or when adjacent bit-fields are accessed. Bit-field operations may be optimized such that adjacent bit-fields are only partially accessed, if they straddle a storage unit boundary. For these reasons it is unwise to use volatile bit-fields to access hardware.</source>
          <target state="translated">비트 필드는 개별적으로 어드레스 가능하지 않기 때문에, 휘발성 비트 필드는 기록 될 때 또는 인접한 비트 필드가 액세스 될 때 암시 적으로 판독 될 수있다. 비트 필드 동작은 인접한 비트 필드가 저장 장치 경계에 걸쳐있는 경우 부분적으로 만 액세스되도록 최적화 될 수있다. 이러한 이유로 휘발성 비트 필드를 사용하여 하드웨어에 액세스하는 것은 현명하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="54cb09a605966e1ec9e0e0780e8355b83cacd9f7" translate="yes" xml:space="preserve">
          <source>As discussed in &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;, this attribute allows specification of target-specific compilation options.</source>
          <target state="translated">&lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;공통 기능 속성&lt;/a&gt; 에서 논의한 바와 같이이 속성을 사용하면 대상별 컴파일 옵션을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c47f4f2d2c816a9b7574ec5c08de30912daa2a80" translate="yes" xml:space="preserve">
          <source>As for &amp;lsquo;</source>
          <target state="translated">'에 관해서는</target>
        </trans-unit>
        <trans-unit id="71478357402c28a54c8c6fca58d451aad7e53ab5" translate="yes" xml:space="preserve">
          <source>As in standard C++ and ISO C99, the elements of an aggregate initializer for an automatic variable are not required to be constant expressions in GNU C. Here is an example of an initializer with run-time varying elements:</source>
          <target state="translated">표준 C ++ 및 ISO C99에서와 같이 자동 변수에 대한 집계 이니셜 라이저 요소는 GNU C에서 상수 표현식 일 필요는 없습니다. 다음은 런타임 가변 요소가있는 초기화 프로그램의 예입니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
