<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="gcc">
    <body>
      <group id="gcc">
        <trans-unit id="64755c0a10d7b896808172cc7335112d4911d239" translate="yes" xml:space="preserve">
          <source>The maximum number of insns in a region to be considered for pipelining in the selective scheduler.</source>
          <target state="translated">선택적 스케줄러에서 파이프 라이닝을 고려할 영역의 최대 인스 턴 수입니다.</target>
        </trans-unit>
        <trans-unit id="7549b9d59e547801a424f6394451c0c5eb284456" translate="yes" xml:space="preserve">
          <source>The maximum number of insns in loop header duplicated by the copy loop headers pass.</source>
          <target state="translated">복사 루프 헤더가 복제 한 루프 헤더의 최대 insns 수입니다.</target>
        </trans-unit>
        <trans-unit id="557a1591041c896c87813c7c44591df470e1d549" translate="yes" xml:space="preserve">
          <source>The maximum number of insns of a completely peeled loop.</source>
          <target state="translated">완전히 벗겨진 루프의 최대 인스 턴 수입니다.</target>
        </trans-unit>
        <trans-unit id="6e77354bbeeb82418d9ce51f0cd208bdb1bdb528" translate="yes" xml:space="preserve">
          <source>The maximum number of insns of a peeled loop that rolls only once.</source>
          <target state="translated">한 번만 롤링되는 벗겨진 루프의 최대 인스 턴 수입니다.</target>
        </trans-unit>
        <trans-unit id="e1366f0a190b8fba2e81ce94bc72ef8becba23f7" translate="yes" xml:space="preserve">
          <source>The maximum number of insns of an unswitched loop.</source>
          <target state="translated">전환되지 않은 루프의 최대 인스 턴 수입니다.</target>
        </trans-unit>
        <trans-unit id="cf7612b99e9ada1082074daa96e9458c5473af04" translate="yes" xml:space="preserve">
          <source>The maximum number of instruction reload should look backward for equivalent register. Increasing values mean more aggressive optimization, making the compilation time increase with probably slightly better performance.</source>
          <target state="translated">최대 명령 재로드 수는 등가 레지스터를 뒤로 찾습니다. 값이 증가하면보다 적극적인 최적화가 수행되므로 성능이 약간 향상되어 컴파일 시간이 늘어납니다.</target>
        </trans-unit>
        <trans-unit id="9005923e6a32b4692818d139c898763d96182dda" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions CSE processes before flushing.</source>
          <target state="translated">플러시하기 전에 CSE가 처리하는 최대 명령 수입니다.</target>
        </trans-unit>
        <trans-unit id="c9f4ccd7bf5ad2020d3e593506c55f6c162a5002" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions biased by probabilities of their execution that a loop may have to be unrolled. If a loop is unrolled, this parameter also determines how many times the loop code is unrolled.</source>
          <target state="translated">루프를 풀어야 할 수도있는 실행 가능성에 의해 바이어스되는 최대 명령 수입니다. 루프가 언 롤링되면이 매개 변수는 루프 코드가 언 롤링되는 횟수도 결정합니다.</target>
        </trans-unit>
        <trans-unit id="6459fa6f8aa47f72deca9d3c9064156b11b3b7ad" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions non-inline function can grow to via recursive inlining.</source>
          <target state="translated">인라인이 아닌 함수의 최대 명령어 수는 재귀적인 인라인을 통해 증가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f088738722ed99797643c1cd7fd24995b8cb099a" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions ready to be issued the scheduler should consider at any given time during the first scheduling pass. Increasing values mean more thorough searches, making the compilation time increase with probably little benefit.</source>
          <target state="translated">스케줄러가 발행 할 준비가 된 최대 명령 수는 첫 번째 스케줄 단계 동안 주어진 시간에 고려해야합니다. 값이 증가하면보다 철저한 검색이 가능하므로 컴파일 시간이 거의 걸리지 않으며 이점이 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="751361661372b9f65beccbd7de6c9e13c4fb111d" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions that a loop may have to be peeled. If a loop is peeled, this parameter also determines how many times the loop code is peeled.</source>
          <target state="translated">루프를 벗겨야 할 수있는 최대 명령 수입니다. 루프가 벗겨지면이 매개 변수는 루프 코드가 벗겨지는 횟수도 결정합니다.</target>
        </trans-unit>
        <trans-unit id="7edf4c141bc3a24bbf2d50e04de689b5700fa130" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions that a loop may have to be unrolled. If a loop is unrolled, this parameter also determines how many times the loop code is unrolled.</source>
          <target state="translated">루프가 풀릴 수있는 최대 명령 수입니다. 루프가 언 롤링되면이 매개 변수는 루프 코드가 언 롤링되는 횟수도 결정합니다.</target>
        </trans-unit>
        <trans-unit id="b5c3a913df725fc3842845c874668062bf683170" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions that an inner loop can have before the loop versioning pass considers it too big to copy.</source>
          <target state="translated">루프 버전 관리 단계 이전에 내부 루프가 가질 수있는 최대 명령 수는 복사하기에 너무 큰 것으로 간주합니다.</target>
        </trans-unit>
        <trans-unit id="0347a5207a00a0a94142de3b1cb1207696bb8750" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions that an outer loop can have before the loop versioning pass considers it too big to copy, discounting any instructions in inner loops that directly benefit from versioning.</source>
          <target state="translated">루프 버전 관리 단계 전에 외부 루프가 가질 수있는 최대 명령 수는 복사하기에 너무 큰 것으로 간주하여 버전 관리의 직접적인 혜택을받는 내부 루프의 명령을 할인합니다.</target>
        </trans-unit>
        <trans-unit id="cd3296c189a6eb29be66f9d755ea47f2387ef49d" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions the RTL combiner tries to combine.</source>
          <target state="translated">RTL 컴 바이 너가 결합하려고하는 최대 명령 수입니다.</target>
        </trans-unit>
        <trans-unit id="cf3b05a5fc34087d71a21bfbdc9daebc782fc835" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions to consider when looking for an instruction to fill a delay slot. If more than this arbitrary number of instructions are searched, the time savings from filling the delay slot are minimal, so stop searching. Increasing values mean more aggressive optimization, making the compilation time increase with probably small improvement in execution time.</source>
          <target state="translated">지연 슬롯을 채우는 명령을 찾을 때 고려해야 할 최대 명령 수입니다. 이 임의의 수의 명령보다 많은 수를 검색하면 지연 슬롯을 채우는 시간이 최소화되므로 검색을 중지하십시오. 값이 증가하면보다 적극적인 최적화가 수행되므로 실행 시간이 약간 개선되어 컴파일 시간이 늘어납니다.</target>
        </trans-unit>
        <trans-unit id="f5be3b82586aa080f1846e1d109f72232bc815fe" translate="yes" xml:space="preserve">
          <source>The maximum number of instructions to duplicate to a block that jumps to a computed goto. To avoid &lt;em&gt;O(N^2)&lt;/em&gt; behavior in a number of passes, GCC factors computed gotos early in the compilation process, and unfactors them as late as possible. Only computed jumps at the end of a basic blocks with no more than max-goto-duplication-insns are unfactored.</source>
          <target state="translated">계산 된 goto로 이동하는 블록에 복제 할 최대 명령 수입니다. 여러 패스에서 &lt;em&gt;O (N ^ 2)&lt;/em&gt; 동작 을 피하기 위해 GCC는 컴파일 프로세스 초기에 고 토스를 계산하고 가능한 한 늦게 팩토링을 해제합니다. max-goto-duplication-insns 이하의 기본 블록 끝에서 계산 된 점프 만 팩토링되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f826bd5a9f2e555af6e39cc55fa38f4c63598849" translate="yes" xml:space="preserve">
          <source>The maximum number of iterations of a loop the brute-force algorithm for analysis of the number of iterations of the loop tries to evaluate.</source>
          <target state="translated">루프의 최대 반복 횟수 루프의 반복 횟수를 분석하기위한 무차별 대입 알고리즘이 평가를 시도합니다.</target>
        </trans-unit>
        <trans-unit id="827bc9985068a19acb40103212322373c4817b20" translate="yes" xml:space="preserve">
          <source>The maximum number of iterations of a loop to be suitable for complete peeling.</source>
          <target state="translated">완전한 박리에 적합한 루프의 최대 반복 횟수입니다.</target>
        </trans-unit>
        <trans-unit id="6ed380824467ca338cf023f1dcb3f2de07822555" translate="yes" xml:space="preserve">
          <source>The maximum number of iterations through CFG to extend regions. A value of 0 disables region extensions.</source>
          <target state="translated">영역을 확장하기 위해 CFG를 통한 최대 반복 횟수입니다. 값이 0이면 리전 확장이 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="3a4fe5f590fb9f1538c537c1032bfe7e933f8b30" translate="yes" xml:space="preserve">
          <source>The maximum number of loop iterations we predict statically. This is useful in cases where a function contains a single loop with known bound and another loop with unknown bound. The known number of iterations is predicted correctly, while the unknown number of iterations average to roughly 10. This means that the loop without bounds appears artificially cold relative to the other one.</source>
          <target state="translated">정적으로 예측되는 최대 루프 반복 횟수입니다. 이것은 함수에 알려진 바운드가있는 단일 루프와 알 수없는 바운드가있는 다른 루프가 포함 된 경우에 유용합니다. 알려진 반복 횟수는 올바르게 예측되지만 알 수없는 반복 횟수는 평균 약 10입니다. 이는 경계가없는 루프는 다른 루프에 비해 인위적으로 차갑게 나타납니다.</target>
        </trans-unit>
        <trans-unit id="6c4f0955c671eedabc4872cd4110ae5643c1e035" translate="yes" xml:space="preserve">
          <source>The maximum number of loop peels to enhance access alignment for vectorizer. Value -1 means no limit.</source>
          <target state="translated">벡터 라이저의 액세스 정렬을 향상시키기위한 최대 루프 필 수입니다. 값 -1은 제한이 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="15a4d50649a3963909b22c32025925dae63b4133" translate="yes" xml:space="preserve">
          <source>The maximum number of may-defs we analyze when looking for a must-def specifying the dynamic type of an object that invokes a virtual call we may be able to devirtualize speculatively.</source>
          <target state="translated">가상 호출을 호출하는 객체의 동적 유형을 지정하는 must-def를 찾을 때 분석 할 수있는 최대 may-def 수는 추론 적으로 가상화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a35d2bdd1c57297696d12360403e48281b63730" translate="yes" xml:space="preserve">
          <source>The maximum number of memory locations cselib should take into account. Increasing values mean more aggressive optimization, making the compilation time increase with probably slightly better performance.</source>
          <target state="translated">cselib가 고려해야 할 최대 메모리 위치 수. 값이 증가하면보다 적극적인 최적화가 수행되므로 성능이 약간 향상되어 컴파일 시간이 늘어납니다.</target>
        </trans-unit>
        <trans-unit id="d6a0df289b9860c6b27b724bd89cb2e25afbef7b" translate="yes" xml:space="preserve">
          <source>The maximum number of namespaces to consult for suggestions when C++ name lookup fails for an identifier.</source>
          <target state="translated">C ++ 이름 조회가 식별자에 대해 실패 할 때 제안 사항을 참조 할 최대 네임 스페이스 수입니다.</target>
        </trans-unit>
        <trans-unit id="511118b67bad71c8756d22dc67344a5b3d5a2116" translate="yes" xml:space="preserve">
          <source>The maximum number of peelings of a single loop.</source>
          <target state="translated">단일 루프의 최대 필링 수입니다.</target>
        </trans-unit>
        <trans-unit id="e8f1f05653238e3a565a30b9f73246f26306aaea" translate="yes" xml:space="preserve">
          <source>The maximum number of pending dependencies scheduling allows before flushing the current state and starting over. Large functions with few branches or calls can create excessively large lists which needlessly consume memory and resources.</source>
          <target state="translated">현재 상태를 플러시하고 다시 시작하기 전에 대기중인 최대 종속성 예약 수를 허용합니다. 분기 또는 호출이 적은 큰 기능은 메모리와 리소스를 불필요하게 소비하는 지나치게 큰 목록을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0e89b0526dda27a2d7f3e6b7314e208af696219" translate="yes" xml:space="preserve">
          <source>The maximum number of run-time checks that can be performed when doing loop versioning for alias in the vectorizer.</source>
          <target state="translated">벡터 라이저에서 별칭에 대한 루프 버전 관리를 수행 할 때 수행 할 수있는 최대 런타임 검사 수입니다.</target>
        </trans-unit>
        <trans-unit id="db0f184d4982d10802b0494be89c63889d9e1ea5" translate="yes" xml:space="preserve">
          <source>The maximum number of run-time checks that can be performed when doing loop versioning for alignment in the vectorizer.</source>
          <target state="translated">벡터 라이저에서 정렬을 위해 루프 버전 관리를 수행 할 때 수행 할 수있는 최대 런타임 검사 수입니다.</target>
        </trans-unit>
        <trans-unit id="50ff624d5ca7c27e89395fa51bbbe5ce28d3f9f1" translate="yes" xml:space="preserve">
          <source>The maximum number of stmts in a loop to be interchanged.</source>
          <target state="translated">루프에서 교환 할 최대 stmt 수입니다.</target>
        </trans-unit>
        <trans-unit id="2862b2a5dc2c56cf5f469134e2bd6bad6e5964e7" translate="yes" xml:space="preserve">
          <source>The maximum number of stores to attempt to merge into wider stores in the store merging pass.</source>
          <target state="translated">상점 병합 패스에서 더 넓은 상점으로 병합을 시도 할 최대 상점 수입니다.</target>
        </trans-unit>
        <trans-unit id="ae1a00d3b58c9f16d33b3348661fd11eee89c1d8" translate="yes" xml:space="preserve">
          <source>The maximum number of times a callsite can appear in a call stack within the analyzer, before terminating analysis of a call that would recurse deeper.</source>
          <target state="translated">더 깊이 반복되는 호출의 분석을 종료하기 전에 호출 사이트가 분석기 내의 호출 스택에 나타날 수있는 최대 횟수입니다.</target>
        </trans-unit>
        <trans-unit id="6caef17bd294964937582b8b58bab7601c99e27b" translate="yes" xml:space="preserve">
          <source>The maximum number of times that an instruction is scheduled during selective scheduling. This is the limit on the number of iterations through which the instruction may be pipelined.</source>
          <target state="translated">선택적 예약 중에 명령이 예약 된 최대 횟수입니다. 이는 명령이 파이프 라인 될 수있는 반복 횟수의 한계입니다.</target>
        </trans-unit>
        <trans-unit id="ddefe1cfc3442fba935b71446bc04ed2a446b364" translate="yes" xml:space="preserve">
          <source>The maximum number of times the outer loop should be unrolled by the unroll-and-jam transformation.</source>
          <target state="translated">언롤 앤 잼 변환으로 외부 루프를 언롤해야하는 최대 횟수입니다.</target>
        </trans-unit>
        <trans-unit id="1df2840a57590d0c992c35b1f7cd4db504ccf715" translate="yes" xml:space="preserve">
          <source>The maximum number of unrollings of a single loop.</source>
          <target state="translated">단일 루프의 최대 언 롤링 횟수입니다.</target>
        </trans-unit>
        <trans-unit id="06e4b31a55ed6d6ed41d2b2d48b6006b46bfa532" translate="yes" xml:space="preserve">
          <source>The maximum relative execution frequency (in percents) of the target block relative to a statement&amp;rsquo;s original block to allow statement sinking of a statement. Larger numbers result in more aggressive statement sinking. A small positive adjustment is applied for statements with memory operands as those are even more profitable so sink.</source>
          <target state="translated">명령문의 명령문 싱크를 허용하는 명령문의 원래 블록에 대한 대상 블록의 최대 상대 실행 빈도 (백분율)입니다. 숫자가 클수록 성명서가 더 침몰합니다. 메모리 피연산자가있는 명령문에는 더 긍정적이므로 작은 양의 조정이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="c4e2688875615cab366f32942394edf8b4b91705" translate="yes" xml:space="preserve">
          <source>The maximum size measured as number of RTLs that can be recorded in an expression in combiner for a pseudo register as last known value of that register.</source>
          <target state="translated">최대 크기는 해당 레지스터의 마지막 알려진 값으로 의사 레지스터에 대한 결합기의 표현식에 기록 될 수있는 RTL 수로 측정됩니다.</target>
        </trans-unit>
        <trans-unit id="159ffd5e6070239f87afd549cbfcfd8ded2b299d" translate="yes" xml:space="preserve">
          <source>The maximum size of the lookahead window of selective scheduling. It is a depth of search for available instructions.</source>
          <target state="translated">선택적 스케줄링의 미리보기 창의 최대 크기입니다. 사용 가능한 지침에 대한 깊이있는 검색입니다.</target>
        </trans-unit>
        <trans-unit id="f3da3af33190929d9965056fd52af9e74099ff3d" translate="yes" xml:space="preserve">
          <source>The memory order parameter is a signed int, but only the lower 16 bits are reserved for the memory order. The remainder of the signed int is reserved for target use and should be 0. Use of the predefined atomic values ensures proper usage.</source>
          <target state="translated">메모리 순서 매개 변수는 부호있는 int이지만 하위 16 비트 만 메모리 순서로 예약됩니다. 부호있는 int의 나머지는 대상 용으로 예약되어 있으며 0이어야합니다. 사전 정의 된 원자 값을 사용하면 올바른 사용법이 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="9c9000c0e6476a4bcab6775fb476be520bb235b5" translate="yes" xml:space="preserve">
          <source>The memory-based pseudo-registers $mem0 through $mem15.</source>
          <target state="translated">메모리 기반 의사 레지스터는 $ mem0 ~ $ mem15입니다.</target>
        </trans-unit>
        <trans-unit id="5f9aeac04a443a9f208cd4c4e6f4207cbf2bb24b" translate="yes" xml:space="preserve">
          <source>The message attached to the attribute is affected by the setting of the</source>
          <target state="translated">속성에 첨부 된 메시지는</target>
        </trans-unit>
        <trans-unit id="535f4a6df8d49970089b47a9552616a59f08c505" translate="yes" xml:space="preserve">
          <source>The message is in keeping with the output of</source>
          <target state="translated">메시지는</target>
        </trans-unit>
        <trans-unit id="22d9ad2ced8af2273cacd0833b5a4654b153618b" translate="yes" xml:space="preserve">
          <source>The method by which preprocessing tokens (possibly resulting from macro expansion) in a &lt;code&gt;#include&lt;/code&gt; directive are combined into a header name (C90 6.8.2, C99 and C11 6.10.2).</source>
          <target state="translated">&lt;code&gt;#include&lt;/code&gt; 지시문 에서 전처리 토큰 (매크로 확장으로 인한 것) 이 헤더 이름 (C90 6.8.2, C99 및 C11 6.10.2)으로 결합되는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="64dacbdf1cd80117047022b9711381d6ea5221d3" translate="yes" xml:space="preserve">
          <source>The method is called repeatedly during a fast enumeration to retrieve batches of objects. Each invocation of the method should retrieve the next batch of objects.</source>
          <target state="translated">이 방법은 빠른 열거 중에 반복적으로 호출되어 일련의 객체를 검색합니다. 메소드를 호출 할 때마다 다음 배치 개체를 검색해야합니다.</target>
        </trans-unit>
        <trans-unit id="c7fa0fb8f65f5da5a26a900516ca2af75a19d924" translate="yes" xml:space="preserve">
          <source>The method used by GCC is as follows: a structure or union which is 1, 2, 4 or 8 bytes long is returned like a scalar. A structure or union with any other size is stored into an address supplied by the caller (usually in a special, fixed register, but on some machines it is passed on the stack). The target hook &lt;code&gt;TARGET_STRUCT_VALUE_RTX&lt;/code&gt; tells GCC where to pass this address.</source>
          <target state="translated">GCC에서 사용하는 방법은 다음과 같습니다. 1, 2, 4 또는 8 바이트 길이의 구조 또는 공용체는 스칼라처럼 반환됩니다. 다른 크기의 구조 또는 공용체는 호출자가 제공 한 주소에 저장됩니다 (보통 특수한 고정 레지스터에 있지만 일부 컴퓨터에서는 스택에 전달됨). 대상 후크 &lt;code&gt;TARGET_STRUCT_VALUE_RTX&lt;/code&gt; 는 GCC에이 주소를 전달할 위치를 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="cea71b7dec6652fd1c586605bdaf1afaabd9e0d7" translate="yes" xml:space="preserve">
          <source>The middle operand in a conditional expression may be omitted. Then if the first operand is nonzero, its value is the value of the conditional expression.</source>
          <target state="translated">조건식에서 중간 피연산자는 생략 될 수 있습니다. 그런 다음 첫 번째 피연산자가 0이 아닌 경우 해당 값은 조건식 값입니다.</target>
        </trans-unit>
        <trans-unit id="6b9ca9444f11bb1174b6690d0f150eb398c757b0" translate="yes" xml:space="preserve">
          <source>The mini registers r0 - r7.</source>
          <target state="translated">미니 레지스터 r0-r7.</target>
        </trans-unit>
        <trans-unit id="e080de9f963115473e6c7f8a5387551ad83e48b0" translate="yes" xml:space="preserve">
          <source>The minimal probability of speculation success (in percents), so that speculative insns are scheduled.</source>
          <target state="translated">투기 적 여론이 계획되도록 투기 성공 확률 (퍼센트)입니다.</target>
        </trans-unit>
        <trans-unit id="aaffaaa968786a2da6ad4d8b8e0d5b378cb65a74" translate="yes" xml:space="preserve">
          <source>The minimum cost of an expensive expression in the loop invariant motion.</source>
          <target state="translated">루프 불변 동작에서 비싼 표현의 최소 비용.</target>
        </trans-unit>
        <trans-unit id="efe3bb81fc851386e4b7cee22649ff792c38641a" translate="yes" xml:space="preserve">
          <source>The minimum fraction of profile runs a given basic block execution count must be not to be considered unlikely.</source>
          <target state="translated">주어진 기본 블록 실행 횟수에 대한 프로파일 실행의 최소 비율은 거의 고려되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="92f1b567f7a83d5184bace5014aac03377eeb221" translate="yes" xml:space="preserve">
          <source>The minimum number of instructions that must be matched at the end of two blocks before cross-jumping is performed on them. This value is ignored in the case where all instructions in the block being cross-jumped from are matched.</source>
          <target state="translated">교차 점프를 수행하기 전에 두 블록의 끝에서 일치해야하는 최소 명령 수입니다. 교차 점프되는 블록의 모든 명령어가 일치하는 경우이 값은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="02c154dc267dae6541e650ecc75738b7fc1946c1" translate="yes" xml:space="preserve">
          <source>The minimum number of iterations per thread of an innermost parallelized loop for which the parallelized variant is preferred over the single threaded one. Note that for a parallelized loop nest the minimum number of iterations of the outermost loop per thread is two.</source>
          <target state="translated">병렬화 된 변형이 단일 스레드 변형보다 선호되는 가장 안쪽의 병렬화 된 루프의 스레드 당 최소 반복 횟수입니다. 병렬 루프 중첩의 경우 스레드 당 가장 바깥 쪽 루프의 최소 반복 횟수는 2입니다.</target>
        </trans-unit>
        <trans-unit id="2647f0a952db726e7e97cf159b9a0ce4dc6514c9" translate="yes" xml:space="preserve">
          <source>The minimum number of iterations under which loops are not vectorized when</source>
          <target state="translated">루프가 벡터화되지 않는 최소 반복 횟수</target>
        </trans-unit>
        <trans-unit id="a016de6d4b3751317d101162f7adccf0bba87a22" translate="yes" xml:space="preserve">
          <source>The minimum number of supernodes within a function for the analyzer to consider summarizing its effects at call sites.</source>
          <target state="translated">분석기가 호출 사이트에서의 효과 요약을 고려할 수있는 함수 내의 최소 수퍼 노드 수입니다.</target>
        </trans-unit>
        <trans-unit id="44ff09fc2cb3e08a9eb4ff0c94daf816032e979a" translate="yes" xml:space="preserve">
          <source>The minimum percentage of memory references that must be optimized away for the unroll-and-jam transformation to be considered profitable.</source>
          <target state="translated">언롤 앤 잼 변환이 수익성있는 것으로 간주되도록 최적화해야하는 메모리 참조의 최소 백분율입니다.</target>
        </trans-unit>
        <trans-unit id="129a020d6e4e2d22eefb43a7999c4dc2402a1a50" translate="yes" xml:space="preserve">
          <source>The minimum probability (in percents) of reaching a source block for interblock speculative scheduling.</source>
          <target state="translated">인터 블록 추론 적 스케줄링을 위해 소스 블록에 도달 할 수있는 최소 확률 (백분율).</target>
        </trans-unit>
        <trans-unit id="dc4b50e8ed53d44237971958e2e83e18524eb941" translate="yes" xml:space="preserve">
          <source>The minimum probability an edge must have for the scheduler to save its state across it.</source>
          <target state="translated">스케줄러가 상태를 저장하기 위해 에지가 가져야하는 최소 확률.</target>
        </trans-unit>
        <trans-unit id="61926ef9181910c24fa1d9136e2e7aa3bdc9bb32" translate="yes" xml:space="preserve">
          <source>The minimum ratio between stride of two loops for interchange to be profitable.</source>
          <target state="translated">교환이 수익성을 유지하기 위해 두 루프의 보폭 사이의 최소 비율.</target>
        </trans-unit>
        <trans-unit id="8e01e027a6a504c434a5c40600808d2984b71737" translate="yes" xml:space="preserve">
          <source>The minimum ratio between the number of instructions and the number of memory references to enable prefetching in a loop.</source>
          <target state="translated">루프에서 프리 페치를 사용할 수 있도록 명령어 수와 메모리 참조 수 사이의 최소 비율입니다.</target>
        </trans-unit>
        <trans-unit id="0c8448923459ab38ab3cc0b8bb13a936b3627b06" translate="yes" xml:space="preserve">
          <source>The minimum ratio between the number of instructions and the number of prefetches to enable prefetching in a loop.</source>
          <target state="translated">루프에서 프리 페치를 사용할 수 있도록 명령어 수와 프리 페치 수 사이의 최소 비율입니다.</target>
        </trans-unit>
        <trans-unit id="8220c9492a5b7435fa642b1e05152b364a262db5" translate="yes" xml:space="preserve">
          <source>The minimum size of buffers (i.e. arrays) that receive stack smashing protection when</source>
          <target state="translated">스택 스매싱 보호를받는 버퍼 (예 : 배열)의 최소 크기</target>
        </trans-unit>
        <trans-unit id="13054edb9e1ab6c7cefbb0f40ba19b0915f9beae" translate="yes" xml:space="preserve">
          <source>The minimum size of variables taking part in stack slot sharing when not optimizing.</source>
          <target state="translated">최적화하지 않을 때 스택 슬롯 공유에 참여하는 변수의 최소 크기입니다.</target>
        </trans-unit>
        <trans-unit id="2c2de50582a702ec4d7ad2fc7c8e60438b0f0aa8" translate="yes" xml:space="preserve">
          <source>The minimum value of stage count that swing modulo scheduler generates.</source>
          <target state="translated">스윙 모듈로 스케줄러가 생성하는 스테이지 카운트의 최소값입니다.</target>
        </trans-unit>
        <trans-unit id="e61665509912f06aa6c9cfa2083ef8e16d79724c" translate="yes" xml:space="preserve">
          <source>The most straightforward way to link a program to use a particular C++ library is to use a C++ driver that specifies that C++ library by default. The &lt;code&gt;g++&lt;/code&gt; driver, for example, tells the linker where to find GCC&amp;rsquo;s C++ library (</source>
          <target state="translated">특정 C ++ 라이브러리를 사용하도록 프로그램을 연결하는 가장 간단한 방법은 기본적으로 해당 C ++ 라이브러리를 지정하는 C ++ 드라이버를 사용하는 것입니다. &lt;code&gt;g++&lt;/code&gt; 드라이버는, 예를 들어, 경우 (GCC의 C ++ 라이브러리를 찾을 수 링커를 알려줍니다</target>
        </trans-unit>
        <trans-unit id="df6349c8ef5b50987899abffe38003acbe800a64" translate="yes" xml:space="preserve">
          <source>The multiprocessing extension.</source>
          <target state="translated">멀티 프로세싱 확장</target>
        </trans-unit>
        <trans-unit id="8d24347b639fc5c1199b8f3590bff6a146e13c82" translate="yes" xml:space="preserve">
          <source>The name of the function.</source>
          <target state="translated">함수의 이름</target>
        </trans-unit>
        <trans-unit id="62e8e383964ec0763f310d8e73ac1d3feb12f8de" translate="yes" xml:space="preserve">
          <source>The names of specific parameters, and the meaning of the values, are tied to the internals of the compiler, and are subject to change without notice in future releases.</source>
          <target state="translated">특정 매개 변수의 이름과 값의 의미는 컴파일러의 내부와 연결되어 있으며 향후 릴리스에서 예고없이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="329fe73400bc50b68cb243f0ab550043e7c95935" translate="yes" xml:space="preserve">
          <source>The native Linux/GNU toolchain also supports the value &amp;lsquo;</source>
          <target state="translated">기본 Linux / GNU 툴체인은 '</target>
        </trans-unit>
        <trans-unit id="04c44aa6fff9d063f62cf98bb0599d7c6a3d3bb6" translate="yes" xml:space="preserve">
          <source>The nested function can access all the variables of the containing function that are visible at the point of its definition. This is called &lt;em&gt;lexical scoping&lt;/em&gt;. For example, here we show a nested function which uses an inherited variable named &lt;code&gt;offset&lt;/code&gt;:</source>
          <target state="translated">중첩 함수는 정의 시점에서 볼 수있는 포함 함수의 모든 변수에 액세스 할 수 있습니다. 이것을 &lt;em&gt;어휘 범위 지정&lt;/em&gt; 이라고 합니다. 예를 들어, 여기에 &lt;code&gt;offset&lt;/code&gt; 이라는 상속 된 변수를 사용하는 중첩 함수가 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="d50cb616ffb2082a3e3b7e7c2d21914b6c5a5b8a" translate="yes" xml:space="preserve">
          <source>The nested function&amp;rsquo;s name is local to the block where it is defined. For example, here we define a nested function named &lt;code&gt;square&lt;/code&gt;, and call it twice:</source>
          <target state="translated">중첩 함수의 이름은 정의 된 블록에 대해 로컬입니다. 예를 들어, 여기서 &lt;code&gt;square&lt;/code&gt; 라는 중첩 함수를 정의하고 두 번 호출합니다.</target>
        </trans-unit>
        <trans-unit id="2a845c4dca5c001e6d102157bfd313918d6f8a24" translate="yes" xml:space="preserve">
          <source>The nesting limit for &lt;code&gt;#include&lt;/code&gt; processing (C90 6.8.2, C99 and C11 6.10.2).</source>
          <target state="translated">&lt;code&gt;#include&lt;/code&gt; 처리 의 중첩 한계 (C90 6.8.2, C99 및 C11 6.10.2).</target>
        </trans-unit>
        <trans-unit id="1446b5bc47ae4093c3d59b0d15fb2e41a888d931" translate="yes" xml:space="preserve">
          <source>The next example shows a case where the optimizers can recognize that the input (&lt;code&gt;dwSomeValue&lt;/code&gt;) never changes during the execution of the function and can therefore move the &lt;code&gt;asm&lt;/code&gt; outside the loop to produce more efficient code. Again, using the &lt;code&gt;volatile&lt;/code&gt; qualifier disables this type of optimization.</source>
          <target state="translated">다음 예제는 옵티마이 &lt;code&gt;dwSomeValue&lt;/code&gt; 함수 실행 중에 입력 ( dwSomeValue )이 절대 변경되지 않음을 인식 하여보다 효율적인 코드를 생성하기 위해 &lt;code&gt;asm&lt;/code&gt; 을 루프 밖으로 이동시킬 수 있는 경우를 보여줍니다 . 다시, 사용하여 &lt;code&gt;volatile&lt;/code&gt; 규정하는 것은 최적화의이 유형을 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="90026784c98f629fb36fb07ae9132c36ffa32047" translate="yes" xml:space="preserve">
          <source>The next revision of the ISO C++ standard, planned for 2020. Support is highly experimental, and will almost certainly change in incompatible ways in future releases.</source>
          <target state="translated">2020 년에 계획된 ISO C ++ 표준의 다음 개정판입니다. 지원은 매우 실험적이며 향후 릴리스에서 호환되지 않는 방식으로 거의 변경 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="1737091e750836f7db5ac991c2404cb583f13f75" translate="yes" xml:space="preserve">
          <source>The next revision of the ISO C++ standard, tentatively planned for 2020. Support is highly experimental, and will almost certainly change in incompatible ways in future releases.</source>
          <target state="translated">잠정적으로 2020 년에 계획된 ISO C ++ 표준의 다음 개정판. 지원은 매우 실험적이며, 향후 릴리스에서는 호환되지 않는 방식으로 변경 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="07fa07f1abd567516650f6c81218681c600c92af" translate="yes" xml:space="preserve">
          <source>The next version of the ISO C standard, still under development, plus GNU extensions. The support for this version is experimental and incomplete.</source>
          <target state="translated">아직 개발중인 ISO C 표준의 다음 버전과 GNU 확장. 이 버전에 대한 지원은 실험적이고 불완전합니다.</target>
        </trans-unit>
        <trans-unit id="2b02aa6b6d3d78493fbc1dc480d37a214f73df64" translate="yes" xml:space="preserve">
          <source>The next version of the ISO C standard, still under development. The support for this version is experimental and incomplete.</source>
          <target state="translated">여전히 개발중인 ISO C 표준의 다음 버전. 이 버전에 대한 지원은 실험적이고 불완전합니다.</target>
        </trans-unit>
        <trans-unit id="2f0fbf82a063b2707d9377f7fa702f1fc2dca6a1" translate="yes" xml:space="preserve">
          <source>The nine trigraphs and their replacements are</source>
          <target state="translated">아홉 개의 그래프와 그 대체품은</target>
        </trans-unit>
        <trans-unit id="d3e272d2493136e9ddd803eb8bb6b214c461ac69" translate="yes" xml:space="preserve">
          <source>The nineteen 32-bit registers comprising general register R0 to R14, control register GBR, and system registers MACH, MACL, and PR and the vector table address offset are saved into a register bank. Register banks are stacked in first-in last-out (FILO) sequence. Restoration from the bank is executed by issuing a RESBANK instruction.</source>
          <target state="translated">일반 레지스터 R0 ~ R14, 제어 레지스터 GBR, 시스템 레지스터 MACH, MACL 및 PR을 포함하는 19 개의 32 비트 레지스터와 벡터 테이블 주소 오프셋이 레지스터 뱅크에 저장됩니다. 레지스터 뱅크는 선입 선출 (FILO) 순서로 쌓입니다. 뱅크로부터의 복원은 RESBANK 명령을 발행하여 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="3ee0e8fe4a16194f52480c8cf2068fc9bdcd0c7f" translate="yes" xml:space="preserve">
          <source>The non-atomic types are encoded as follows:</source>
          <target state="translated">비 원자 유형은 다음과 같이 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="7bfaebfb4258608ad40629ce440aac9193290911" translate="yes" xml:space="preserve">
          <source>The normal vector extract, and set operations work on &lt;var&gt;vector __int128&lt;/var&gt; and &lt;var&gt;vector __uint128&lt;/var&gt; types, but the index value must be 0.</source>
          <target state="translated">법선 벡터 추출 및 설정 작업은 &lt;var&gt;vector __int128&lt;/var&gt; 및 &lt;var&gt;vector __uint128&lt;/var&gt; 유형에서 작동하지만 인덱스 값은 0이어야합니다.</target>
        </trans-unit>
        <trans-unit id="ec51f6eb264a163ff7656783d752463b0cf474e2" translate="yes" xml:space="preserve">
          <source>The null pointer constant to which the macro &lt;code&gt;NULL&lt;/code&gt; expands (C90 7.1.6, C99 7.17, C11 7.19).</source>
          <target state="translated">매크로 &lt;code&gt;NULL&lt;/code&gt; 이 확장 되는 널 포인터 상수 (C90 7.1.6, C99 7.17, C11 7.19).</target>
        </trans-unit>
        <trans-unit id="28be55da2d33dfd035a16c7e12609f9fde68fbf1" translate="yes" xml:space="preserve">
          <source>The number of Newton iterations for calculating the reciprocal for double type. The precision of division is propotional to this param when division approximation is enabled. The default value is 2.</source>
          <target state="translated">double 유형에 대한 역수를 계산하기위한 뉴턴 반복 횟수입니다. 나눗셈 근사가 활성화 된 경우 나눗셈 정밀도는이 매개 변수에 비례합니다. 기본값은 2입니다.</target>
        </trans-unit>
        <trans-unit id="6669979f69801134fe5425b263914957ab4a88a7" translate="yes" xml:space="preserve">
          <source>The number of Newton iterations for calculating the reciprocal for float type. The precision of division is proportional to this param when division approximation is enabled. The default value is 1.</source>
          <target state="translated">float 유형의 역수를 계산하기위한 Newton 반복 횟수입니다. 나누기의 정밀도는 나누기 근사가 활성화 된 경우이 매개 변수에 비례합니다. 기본값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="38d03781cbc2651157f17e0c5fbab40ff5879c62" translate="yes" xml:space="preserve">
          <source>The number of bits in a byte (C90 3.4, C99 and C11 3.6).</source>
          <target state="translated">바이트의 비트 수 (C90 3.4, C99 및 C11 3.6).</target>
        </trans-unit>
        <trans-unit id="5116832175ad50d3f8b15e3495e553905314a198" translate="yes" xml:space="preserve">
          <source>The number of cycles the swing modulo scheduler considers when checking conflicts using DFA.</source>
          <target state="translated">DFA를 사용하여 충돌을 확인할 때 스윙 모듈로 스케줄러가 고려하는주기 수입니다.</target>
        </trans-unit>
        <trans-unit id="4fb7b94d708168700c159e251d0f9d5fce1fc8c3" translate="yes" xml:space="preserve">
          <source>The number of elements for which hash table verification is done for each searched element.</source>
          <target state="translated">검색된 각 요소에 대해 해시 테이블 확인이 수행되는 요소의 수입니다.</target>
        </trans-unit>
        <trans-unit id="0a72ad254c79a1eea72a19a4968bbd0e5a7dddcb" translate="yes" xml:space="preserve">
          <source>The number of executions of a basic block which is considered hot. The parameter is used only in GIMPLE FE.</source>
          <target state="translated">핫으로 간주되는 기본 블록의 실행 횟수입니다. 이 매개 변수는 GIMPLE FE에서만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ce1f697b40b6aa8756d941d13116c5069d63cf0d" translate="yes" xml:space="preserve">
          <source>The number of most executed permilles, ranging from 0 to 1000, of the profiled execution of the entire program to which the execution count of a basic block must be part of in order to be considered hot. The default is 990, which means that a basic block is considered hot if its execution count contributes to the upper 990 permilles, or 99.0%, of the profiled execution of the entire program. 0 means that it is never considered hot. Used in LTO mode.</source>
          <target state="translated">핫한 것으로 간주하기 위해 기본 블록의 실행 횟수가 일부가되어야하는 전체 프로그램의 프로파일 링 된 실행 중 0에서 1000까지 가장 많이 실행 된 permill의 수입니다. 기본값은 990입니다. 즉, 실행 횟수가 전체 프로그램의 프로파일 링 된 실행의 상위 990 permilles 또는 99.0 %에 기여하는 경우 기본 블록이 hot으로 간주됩니다. 0은 뜨거운 것으로 간주되지 않음을 의미합니다. LTO 모드에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1520c1ee154295eb07c627660dca8d1a6b6092fb" translate="yes" xml:space="preserve">
          <source>The number of significant initial characters in an identifier (C90 6.1.2, C90, C99 and C11 5.2.4.1, C99 and C11 6.4.2).</source>
          <target state="translated">식별자의 중요한 초기 문자 수 (C90 6.1.2, C90, C99 및 C11 5.2.4.1, C99 및 C11 6.4.2)</target>
        </trans-unit>
        <trans-unit id="070362ab17f17b33a3ae34d59055a18a1e302bf9" translate="yes" xml:space="preserve">
          <source>The number, order, and encoding of bytes in any object (when not explicitly specified in this International Standard) (C99 and C11 6.2.6.1).</source>
          <target state="translated">객체에있는 바이트의 수, 순서 및 인코딩 (이 국제 표준에 명시 적으로 지정되지 않은 경우) (C99 및 C11 6.2.6.1).</target>
        </trans-unit>
        <trans-unit id="b604e74e2e851789383571b70ad652997e4e66f6" translate="yes" xml:space="preserve">
          <source>The object is accessed with the respective segment override prefix.</source>
          <target state="translated">개체는 해당 세그먼트 재정의 접두사로 액세스됩니다.</target>
        </trans-unit>
        <trans-unit id="3a5091aabdc201178dc68e9213e404a14e73a3fa" translate="yes" xml:space="preserve">
          <source>The object pointed to by the first argument must be of integer or pointer type. It must not be a boolean type.</source>
          <target state="translated">첫 번째 인수가 가리키는 객체는 정수 또는 포인터 유형이어야합니다. 부울 유형이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="a4db2564696e493fee1ef7423f76307823d51b1d" translate="yes" xml:space="preserve">
          <source>The object pointed to by the first argument must be of integer or pointer type. It must not be a boolean type. All memory orders are valid.</source>
          <target state="translated">첫 번째 인수가 가리키는 객체는 정수 또는 포인터 유형이어야합니다. 부울 유형이 아니어야합니다. 모든 메모리 주문이 유효합니다.</target>
        </trans-unit>
        <trans-unit id="13e4eecfa7c007179ae8943f279500072d8d783d" translate="yes" xml:space="preserve">
          <source>The only difference between &amp;lsquo;</source>
          <target state="translated">'의 유일한 차이점</target>
        </trans-unit>
        <trans-unit id="e3de508e233b8d2680fdf435e3d6c8313768a8db" translate="yes" xml:space="preserve">
          <source>The only supported use for this feature is to specify registers for input and output operands when calling Extended &lt;code&gt;asm&lt;/code&gt; (see &lt;a href=&quot;extended-asm#Extended-Asm&quot;&gt;Extended Asm&lt;/a&gt;). This may be necessary if the constraints for a particular machine don&amp;rsquo;t provide sufficient control to select the desired register. To force an operand into a register, create a local variable and specify the register name after the variable&amp;rsquo;s declaration. Then use the local variable for the &lt;code&gt;asm&lt;/code&gt; operand and specify any constraint letter that matches the register:</source>
          <target state="translated">이 기능에 지원되는 유일한 용도는 Extended &lt;code&gt;asm&lt;/code&gt; 을 호출 할 때 입력 및 출력 피연산자에 대한 레지스터를 지정하는 것입니다 ( &lt;a href=&quot;extended-asm#Extended-Asm&quot;&gt;Extended Asm&lt;/a&gt; 참조 ). 특정 기계에 대한 제약 조건이 원하는 레지스터를 선택하기에 충분한 제어를 제공하지 않는 경우에 필요할 수 있습니다. 피연산자를 레지스터로 강제 적용하려면 로컬 변수를 작성하고 변수 선언 후 레지스터 이름을 지정하십시오. 그런 다음 &lt;code&gt;asm&lt;/code&gt; 피연산자에 로컬 변수를 사용 하고 레지스터와 일치하는 제한 조건 문자를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="80fd38457618adab2fab3528f71d1285f53dd5df" translate="yes" xml:space="preserve">
          <source>The operand is the number of a register to be read. Generates:</source>
          <target state="translated">피연산자는 읽을 레지스터의 번호입니다. 생성합니다 :</target>
        </trans-unit>
        <trans-unit id="164925c793e36006eed2abf2f19f4ef48755a0ed" translate="yes" xml:space="preserve">
          <source>The operand of &lt;code&gt;typeof&lt;/code&gt; is evaluated for its side effects if and only if it is an expression of variably modified type or the name of such a type.</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; 의 피연산자는 변수 가 변형 된 유형의 표현식이거나 해당 유형의 이름 인 경우에만 부작용에 대해 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="6d2a4c2f3546ef01bb01773e4920ca0359e67ac5" translate="yes" xml:space="preserve">
          <source>The operand, &lt;var&gt;auxv&lt;/var&gt;, is the address of an auxiliary register and must be a compile time constant. Generates:</source>
          <target state="translated">피연산자 &lt;var&gt;auxv&lt;/var&gt; 는 보조 레지스터의 주소이며 컴파일 시간 상수 여야합니다. 생성합니다 :</target>
        </trans-unit>
        <trans-unit id="3479099f68d087cc74ace860bc00a95f5b731c1f" translate="yes" xml:space="preserve">
          <source>The operations behave like C++ &lt;code&gt;valarrays&lt;/code&gt;. Addition is defined as the addition of the corresponding elements of the operands. For example, in the code below, each of the 4 elements in &lt;var&gt;a&lt;/var&gt; is added to the corresponding 4 elements in &lt;var&gt;b&lt;/var&gt; and the resulting vector is stored in &lt;var&gt;c&lt;/var&gt;.</source>
          <target state="translated">작업은 C ++ &lt;code&gt;valarrays&lt;/code&gt; 처럼 동작합니다 . 추가는 피연산자의 해당 요소를 추가하는 것으로 정의됩니다. 예를 들어, 아래 코드에서 &lt;var&gt;a&lt;/var&gt; 의 4 개 요소 각각이 &lt;var&gt;b&lt;/var&gt; 의 해당 4 개 요소에 추가되고 결과 벡터가 &lt;var&gt;c&lt;/var&gt; 에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="fde6238c26830fa82a53914b9244e589ab1e426d" translate="yes" xml:space="preserve">
          <source>The operator &amp;lsquo;</source>
          <target state="translated">연산자 '</target>
        </trans-unit>
        <trans-unit id="e6c35a6661bd8051bda6c84d11bcf3693039836f" translate="yes" xml:space="preserve">
          <source>The opposite</source>
          <target state="translated">반대</target>
        </trans-unit>
        <trans-unit id="8d9594a87362ce1971b7a9efe4bfc116ba95e426" translate="yes" xml:space="preserve">
          <source>The option</source>
          <target state="translated">옵션</target>
        </trans-unit>
        <trans-unit id="ae1ce068a17e5dbe0ea035d1beb9f2b11368df02" translate="yes" xml:space="preserve">
          <source>The option also sets the ISA to use. If the MCU name is one that is known to only support the 430 ISA then that is selected, otherwise the 430X ISA is selected. A generic MCU name of &amp;lsquo;</source>
          <target state="translated">이 옵션은 또한 ISA가 사용하도록 설정합니다. MCU 이름이 430 ISA 만 지원하는 것으로 알려진 경우 해당 이름이 선택되고, 그렇지 않으면 430X ISA가 선택됩니다. '의 일반적인 MCU 이름</target>
        </trans-unit>
        <trans-unit id="bace175215f4c9a9a5086a4520e874099d58bc7b" translate="yes" xml:space="preserve">
          <source>The option cannot be combined with</source>
          <target state="translated">이 옵션은</target>
        </trans-unit>
        <trans-unit id="c9e6b8f7b2e1e4a87728188dd3bdb8e34222fb03" translate="yes" xml:space="preserve">
          <source>The option has three forms:</source>
          <target state="translated">이 옵션에는 세 가지 형태가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f57372a8b45a9a651870f464f28239ea0a9400c1" translate="yes" xml:space="preserve">
          <source>The option is equivalent to</source>
          <target state="translated">이 옵션은</target>
        </trans-unit>
        <trans-unit id="25431ae1de44b7a0042861eaf001a15d12b77c5c" translate="yes" xml:space="preserve">
          <source>The option is similar to</source>
          <target state="translated">이 옵션은</target>
        </trans-unit>
        <trans-unit id="3f0b2b21730ed2a5e07ab579f0c874433e03d81f" translate="yes" xml:space="preserve">
          <source>The option&amp;rsquo;s behavior depends on the</source>
          <target state="translated">옵션의 동작은</target>
        </trans-unit>
        <trans-unit id="7003d8dcf16f832eac06c03046c9a171fa807708" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;volatile&lt;/code&gt; qualifier has no effect. All basic &lt;code&gt;asm&lt;/code&gt; blocks are implicitly volatile.</source>
          <target state="translated">선택적 &lt;code&gt;volatile&lt;/code&gt; 한정자는 효과가 없습니다. 모든 기본 &lt;code&gt;asm&lt;/code&gt; 블록은 암시 적으로 휘발성입니다.</target>
        </trans-unit>
        <trans-unit id="74a01a1e7aeded7ac16f376b31f6e97656f61592" translate="yes" xml:space="preserve">
          <source>The optional &lt;var&gt;sirevision&lt;/var&gt; specifies the silicon revision of the target Blackfin processor. Any workarounds available for the targeted silicon revision are enabled. If &lt;var&gt;sirevision&lt;/var&gt; is &amp;lsquo;</source>
          <target state="translated">선택적 &lt;var&gt;sirevision&lt;/var&gt; 은 대상 Blackfin 프로세서의 실리콘 개정을 지정합니다. 대상 실리콘 개정판에 사용 가능한 모든 대안이 활성화되었습니다. 만약 &lt;var&gt;sirevision&lt;/var&gt; 가 '있다</target>
        </trans-unit>
        <trans-unit id="875be52030ba25094435899fd42d910088a7a954" translate="yes" xml:space="preserve">
          <source>The optional &lt;var&gt;size-index&lt;/var&gt; positional argument denotes a function argument of integer type that specifies the maximum size of the access. The size is the number of elements of the type referenced by &lt;var&gt;ref-index&lt;/var&gt;, or the number of bytes when the pointer type is &lt;code&gt;void*&lt;/code&gt;. When no &lt;var&gt;size-index&lt;/var&gt; argument is specified, the pointer argument must be either null or point to a space that is suitably aligned and large for at least one object of the referenced type (this implies that a past-the-end pointer is not a valid argument). The actual size of the access may be less but it must not be more.</source>
          <target state="translated">선택적 &lt;var&gt;size-index&lt;/var&gt; 위치 인수는 액세스의 최대 크기를 지정하는 정수 유형의 함수 인수를 나타냅니다. 크기는 &lt;var&gt;ref-index&lt;/var&gt; 가 참조하는 유형의 요소 수 또는 포인터 유형이 &lt;code&gt;void*&lt;/code&gt; 인 경우 바이트 수입니다 . &lt;var&gt;size-index&lt;/var&gt; 인수가 지정 되지 않은 경우 포인터 인수는 null이거나 참조 된 형식의 하나 이상의 개체에 대해 적절하게 정렬되고 큰 공간을 가리켜 야합니다 (이것은 끝을 지나는 포인터가 유효한 인수). 액세스의 실제 크기는 더 작을 수 있지만 더 많으면 안됩니다.</target>
        </trans-unit>
        <trans-unit id="f72849bef73954b968c2b10753acfe7d2de97d61" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;var&gt;mask&lt;/var&gt; may have the value &lt;code&gt;notinbranch&lt;/code&gt; or &lt;code&gt;inbranch&lt;/code&gt;, and instructs the compiler to generate non-masked or masked clones correspondingly. By default, all clones are generated.</source>
          <target state="translated">선택적 인수 &lt;var&gt;mask&lt;/var&gt; 는 &lt;code&gt;notinbranch&lt;/code&gt; 또는 &lt;code&gt;inbranch&lt;/code&gt; 값을 가질 수 있으며, 컴파일러에게 마스크되지 않거나 마스크 된 클론을 생성하도록 지시합니다. 기본적으로 모든 클론이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="bf601c68a359b3325301de84f8214ec6cb3bee0d" translate="yes" xml:space="preserve">
          <source>The optional extension of specifying vector constants in parentheses is not supported.</source>
          <target state="translated">괄호 안에 벡터 상수를 지정하는 선택적 확장은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8e1def618310843db3ebed1e3d40c1b748262844" translate="yes" xml:space="preserve">
          <source>The optional first word limits the specification to structs that are used directly (&amp;lsquo;</source>
          <target state="translated">선택적 첫 단어는 사양을 직접 사용하는 구조체로 제한합니다 ( '</target>
        </trans-unit>
        <trans-unit id="a9fe5708942d28978cc841b9258dd8862934e265" translate="yes" xml:space="preserve">
          <source>The optional second word limits the specification to ordinary structs (&amp;lsquo;</source>
          <target state="translated">선택적 두 번째 단어는 사양을 일반 구조체로 제한합니다 ( '</target>
        </trans-unit>
        <trans-unit id="01a150b476753c90be937c4eb85655e5b29ceeef" translate="yes" xml:space="preserve">
          <source>The options</source>
          <target state="translated">옵션</target>
        </trans-unit>
        <trans-unit id="ac4a8e159eb45db26e41d6b181749d12e91d13f3" translate="yes" xml:space="preserve">
          <source>The options from each group can be freely mixed as they are non-overlapping. However, in case of any conflicts, the later options override the earlier options on the command line.</source>
          <target state="translated">각 그룹의 옵션은 겹치지 않으므로 자유롭게 혼합 할 수 있습니다. 그러나 충돌이 발생할 경우 이후 옵션은 명령 줄의 이전 옵션보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="03370c70b8d685b972b4178e392c07f67da021e0" translate="yes" xml:space="preserve">
          <source>The options in this section are defined for all VxWorks targets. Options specific to the target hardware are listed with the other options for that target.</source>
          <target state="translated">이 섹션의 옵션은 모든 VxWorks 대상에 대해 정의됩니다. 대상 하드웨어에 특정한 옵션은 해당 대상에 대한 다른 옵션과 함께 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="ee4645ad9aafdb886f64431f817492a531da45bb" translate="yes" xml:space="preserve">
          <source>The options supported are specific to each target; refer to &lt;a href=&quot;x86-function-attributes#x86-Function-Attributes&quot;&gt;x86 Function Attributes&lt;/a&gt;, &lt;a href=&quot;powerpc-function-attributes#PowerPC-Function-Attributes&quot;&gt;PowerPC Function Attributes&lt;/a&gt;, &lt;a href=&quot;arm-function-attributes#ARM-Function-Attributes&quot;&gt;ARM Function Attributes&lt;/a&gt;, &lt;a href=&quot;aarch64-function-attributes#AArch64-Function-Attributes&quot;&gt;AArch64 Function Attributes&lt;/a&gt;, &lt;a href=&quot;nios-ii-function-attributes#Nios-II-Function-Attributes&quot;&gt;Nios II Function Attributes&lt;/a&gt;, and &lt;a href=&quot;s_002f390-function-attributes#S_002f390-Function-Attributes&quot;&gt;S/390 Function Attributes&lt;/a&gt; for details.</source>
          <target state="translated">지원되는 옵션은 각 대상에 따라 다릅니다. 자세한 내용은 &lt;a href=&quot;x86-function-attributes#x86-Function-Attributes&quot;&gt;x86 기능 속성&lt;/a&gt; , &lt;a href=&quot;powerpc-function-attributes#PowerPC-Function-Attributes&quot;&gt;PowerPC 기능 속성&lt;/a&gt; , &lt;a href=&quot;arm-function-attributes#ARM-Function-Attributes&quot;&gt;ARM 기능 속성&lt;/a&gt; , &lt;a href=&quot;aarch64-function-attributes#AArch64-Function-Attributes&quot;&gt;AArch64 기능 속성&lt;/a&gt; , &lt;a href=&quot;nios-ii-function-attributes#Nios-II-Function-Attributes&quot;&gt;Nios II 기능 속성&lt;/a&gt; 및 &lt;a href=&quot;s_002f390-function-attributes#S_002f390-Function-Attributes&quot;&gt;S / 390 기능 속성&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="91a395788ed90836d2997bb1c84003ea7ffde770" translate="yes" xml:space="preserve">
          <source>The options work exactly like the S/390 specific command line options (without the prefix</source>
          <target state="translated">옵션은 S / 390 특정 명령 행 옵션과 동일하게 작동합니다 (접두사 제외)</target>
        </trans-unit>
        <trans-unit id="e9e8fa6c8ae05f8e2a34557e6036eae0a9b76ff8" translate="yes" xml:space="preserve">
          <source>The order in which &lt;code&gt;+load&lt;/code&gt; and &lt;code&gt;+initialize&lt;/code&gt; are called could be problematic if this matters. If you don&amp;rsquo;t allocate objects inside &lt;code&gt;+load&lt;/code&gt;, it is guaranteed that &lt;code&gt;+load&lt;/code&gt; is called before &lt;code&gt;+initialize&lt;/code&gt;. If you create an object inside &lt;code&gt;+load&lt;/code&gt; the &lt;code&gt;+initialize&lt;/code&gt; method of object&amp;rsquo;s class is invoked even if &lt;code&gt;+load&lt;/code&gt; was not invoked. Note if you explicitly call &lt;code&gt;+load&lt;/code&gt; on a class, &lt;code&gt;+initialize&lt;/code&gt; will be called first. To avoid possible problems try to implement only one of these methods.</source>
          <target state="translated">이것이 중요하다면 &lt;code&gt;+load&lt;/code&gt; 와 &lt;code&gt;+initialize&lt;/code&gt; 가 호출 되는 순서는 문제가 될 수 있습니다. 당신이 내부에 객체를 할당하지 않으면 &lt;code&gt;+load&lt;/code&gt; , 것을 보장 &lt;code&gt;+load&lt;/code&gt; 전에 호출됩니다 &lt;code&gt;+initialize&lt;/code&gt; . &lt;code&gt;+load&lt;/code&gt; 내에 객체를 생성 하면 &lt;code&gt;+load&lt;/code&gt; 가 호출되지 않아도 객체 클래스 의 &lt;code&gt;+initialize&lt;/code&gt; 메소드가 호출 됩니다. 클래스에서 &lt;code&gt;+initialize&lt;/code&gt; &lt;code&gt;+load&lt;/code&gt; 를 명시 적으로 호출하면 + initialize 가 먼저 호출됩니다. 가능한 문제를 피하려면 이러한 방법 중 하나만 구현하십시오.</target>
        </trans-unit>
        <trans-unit id="d72c8cfa2bf4559a476794fbcac9230458dd1acf" translate="yes" xml:space="preserve">
          <source>The order of allocation of bit-fields within a unit (C90 6.5.2.1, C99 and C11 6.7.2.1).</source>
          <target state="translated">장치 내 비트 필드 할당 순서 (C90 6.5.2.1, C99 및 C11 6.7.2.1).</target>
        </trans-unit>
        <trans-unit id="13bf99243d90e9f90c583730aacfa820007d4c7a" translate="yes" xml:space="preserve">
          <source>The ordering and number of these preamble lines will be augmented as &lt;code&gt;gcov&lt;/code&gt; development progresses &amp;mdash; do not rely on them remaining unchanged. Use &lt;var&gt;tag&lt;/var&gt; to locate a particular preamble line.</source>
          <target state="translated">이 프리앰블 라인의 순서와 수는 &lt;code&gt;gcov&lt;/code&gt; 개발이 진행됨에 따라 확장됩니다 . &lt;var&gt;tag&lt;/var&gt; 를 사용 하여 특정 프리앰블 라인을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="f78a9eb6841c341650bf4b7b23dd41a17afa341e" translate="yes" xml:space="preserve">
          <source>The original ANSI C standard (X3.159-1989) was ratified in 1989 and published in 1990. This standard was ratified as an ISO standard (ISO/IEC 9899:1990) later in 1990. There were no technical differences between these publications, although the sections of the ANSI standard were renumbered and became clauses in the ISO standard. The ANSI standard, but not the ISO standard, also came with a Rationale document. This standard, in both its forms, is commonly known as &lt;em&gt;C89&lt;/em&gt;, or occasionally as &lt;em&gt;C90&lt;/em&gt;, from the dates of ratification. To select this standard in GCC, use one of the options</source>
          <target state="translated">원래 ANSI C 표준 (X3.159-1989)은 1989 년에 비준되어 1990 년에 출판되었습니다.이 표준은 1990 년 후반에 ISO 표준 (ISO / IEC 9899 : 1990)으로 비준되었습니다. 비록 ANSI 표준의 섹션은 번호가 다시 매겨져 ISO 표준의 조항이되었습니다. ISO 표준이 아닌 ANSI 표준도 근거 문서와 함께 제공됩니다. 이 표준은 두 가지 형식 모두 에서 비준 일자로부터 일반적으로 &lt;em&gt;C89&lt;/em&gt; 또는 &lt;em&gt;C90&lt;/em&gt; 으로 알려져 있습니다. GCC에서이 표준을 선택하려면 옵션 중 하나를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="21c496279e266f5ecd75f883afecb2192cd2a917" translate="yes" xml:space="preserve">
          <source>The original ISO C++ standard was published as the ISO standard (ISO/IEC 14882:1998) and amended by a Technical Corrigenda published in 2003 (ISO/IEC 14882:2003). These standards are referred to as C++98 and C++03, respectively. GCC implements the majority of C++98 (&lt;code&gt;export&lt;/code&gt; is a notable exception) and most of the changes in C++03. To select this standard in GCC, use one of the options</source>
          <target state="translated">원래 ISO C ++ 표준은 ISO 표준 (ISO / IEC 14882 : 1998)으로 발행되었으며 2003 년에 발행 된 Technical Corrigenda (ISO / IEC 14882 : 2003)에 의해 개정되었습니다. 이러한 표준을 각각 C ++ 98 및 C ++ 03이라고합니다. GCC는 대부분의 C ++ 98 ( &lt;code&gt;export&lt;/code&gt; 는 예외입니다)과 C ++ 03의 대부분의 변경 사항을 구현합니다. GCC에서이 표준을 선택하려면 옵션 중 하나를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d55c2d645aa0f80881178d7412aa07a062ca969b" translate="yes" xml:space="preserve">
          <source>The other options specify a specific processor. Code generated under those options runs best on that processor, and may not run at all on others.</source>
          <target state="translated">다른 옵션은 특정 프로세서를 지정합니다. 이러한 옵션으로 생성 된 코드는 해당 프로세서에서 가장 잘 실행되며 다른 프로세서에서는 전혀 실행되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b5fefa619d556bce9b8629c20698a9fbaa045b6" translate="yes" xml:space="preserve">
          <source>The output is sensitive to the effects of previous command-line options, so for example it is possible to find out which optimizations are enabled at</source>
          <target state="translated">출력은 이전 명령 줄 옵션의 영향에 민감하므로 예를 들어 어떤 최적화가 활성화되어 있는지 확인할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="ee1f8d32c864542b44f4a83fd30d75feed01b2e0" translate="yes" xml:space="preserve">
          <source>The output shows that this block of code, combined by optimization, executed 100 times. In one sense this result is correct, because there was only one instruction representing all four of these lines. However, the output does not indicate how many times the result was 0 and how many times the result was 1.</source>
          <target state="translated">결과는 최적화와 결합 된이 코드 블록이 100 번 실행되었음을 보여줍니다. 어떤 의미에서이 결과는 정확합니다.이 네 줄을 모두 나타내는 하나의 명령어 만 있었기 때문입니다. 그러나 결과는 결과가 0 번 몇 번이고 결과가 1 번 몇 번인지 나타내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="25cd388eab46b62953cbdcb13acb11f5a206e81f" translate="yes" xml:space="preserve">
          <source>The parameter &lt;var&gt;archetype&lt;/var&gt; determines how the format string is interpreted, and should be &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;scanf&lt;/code&gt;, &lt;code&gt;strftime&lt;/code&gt;, &lt;code&gt;gnu_printf&lt;/code&gt;, &lt;code&gt;gnu_scanf&lt;/code&gt;, &lt;code&gt;gnu_strftime&lt;/code&gt; or &lt;code&gt;strfmon&lt;/code&gt;. (You can also use &lt;code&gt;__printf__&lt;/code&gt;, &lt;code&gt;__scanf__&lt;/code&gt;, &lt;code&gt;__strftime__&lt;/code&gt; or &lt;code&gt;__strfmon__&lt;/code&gt;.) On MinGW targets, &lt;code&gt;ms_printf&lt;/code&gt;, &lt;code&gt;ms_scanf&lt;/code&gt;, and &lt;code&gt;ms_strftime&lt;/code&gt; are also present. &lt;var&gt;archetype&lt;/var&gt; values such as &lt;code&gt;printf&lt;/code&gt; refer to the formats accepted by the system&amp;rsquo;s C runtime library, while values prefixed with &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;archetype&lt;/var&gt; 매개 변수 는 형식 문자열이 해석되는 방식을 결정하며 &lt;code&gt;printf&lt;/code&gt; , &lt;code&gt;scanf&lt;/code&gt; , &lt;code&gt;strftime&lt;/code&gt; , &lt;code&gt;gnu_printf&lt;/code&gt; , &lt;code&gt;gnu_scanf&lt;/code&gt; , &lt;code&gt;gnu_strftime&lt;/code&gt; 또는 &lt;code&gt;strfmon&lt;/code&gt; 이어야 합니다. &lt;code&gt;__printf__&lt;/code&gt; , &lt;code&gt;__scanf__&lt;/code&gt; , &lt;code&gt;__strftime__&lt;/code&gt; 또는 &lt;code&gt;__strfmon__&lt;/code&gt; 을 사용할 수도 있습니다 . MinGW 대상에는 &lt;code&gt;ms_printf&lt;/code&gt; , &lt;code&gt;ms_scanf&lt;/code&gt; 및 &lt;code&gt;ms_strftime&lt;/code&gt; 도 있습니다. &lt;code&gt;printf&lt;/code&gt; 와 같은 &lt;var&gt;archetype&lt;/var&gt; 값 시스템의 C 런타임 라이브러리에서 허용되는 형식을 참조하고 값 앞에 접두사 '</target>
        </trans-unit>
        <trans-unit id="a3f3b990be6aa69326bd74ae4681ebc09216102d" translate="yes" xml:space="preserve">
          <source>The parameter &lt;var&gt;string-index&lt;/var&gt; specifies which argument is the format string argument (starting from one). Since non-static C++ methods have an implicit &lt;code&gt;this&lt;/code&gt; argument, the arguments of such methods should be counted from two.</source>
          <target state="translated">&lt;var&gt;string-index&lt;/var&gt; 매개 변수 는 형식 인수 인 인수를 지정합니다 (1부터 시작). 정적이 아닌 C ++ 메소드에는 &lt;code&gt;this&lt;/code&gt; 인수 가 내재되어 있으므로 이러한 메소드의 인수는 2부터 계산되어야합니다.</target>
        </trans-unit>
        <trans-unit id="0bb73878f5340c14052a29fb8e00d23ff62b384d" translate="yes" xml:space="preserve">
          <source>The part of a compiler that is specific to a particular language is called the &amp;ldquo;front end&amp;rdquo;. In addition to the front ends that are integrated components of GCC, there are several other front ends that are maintained separately. These support languages such as Mercury, and COBOL. To use these, they must be built together with GCC proper.</source>
          <target state="translated">특정 언어에 특정한 컴파일러 부분을 &quot;프론트 엔드&quot;라고합니다. GCC의 통합 구성 요소 인 프런트 엔드 외에도 별도로 유지되는 여러 다른 프런트 엔드가 있습니다. 이들은 Mercury 및 COBOL과 같은 언어를 지원합니다. 이를 사용하려면 GCC와 함께 구축해야합니다.</target>
        </trans-unit>
        <trans-unit id="27b45d0ebc931e1e733ecb9fb1c3f4c5240b8194" translate="yes" xml:space="preserve">
          <source>The particular options set for any particular CPU varies between compiler versions, depending on what setting seems to produce optimal code for that CPU; it doesn&amp;rsquo;t necessarily reflect the actual hardware&amp;rsquo;s capabilities. If you wish to set an individual option to a particular value, you may specify it after the</source>
          <target state="translated">특정 CPU에 대해 설정된 특정 옵션은 해당 CPU에 대한 최적의 코드를 생성하는 설정에 따라 컴파일러 버전에 따라 다릅니다. 반드시 실제 하드웨어 기능을 반영하지는 않습니다. 개별 옵션을 특정 값으로 설정하려면</target>
        </trans-unit>
        <trans-unit id="452dc4aa50f4dd1fa4974069451a474c59e40f9c" translate="yes" xml:space="preserve">
          <source>The parts that differ are highlighted with color (&amp;ldquo;double&amp;rdquo; and &amp;ldquo;float&amp;rdquo; in this case).</source>
          <target state="translated">다른 부분은 색상으로 강조 표시됩니다 (이 경우 &quot;double&quot;및 &quot;float&quot;).</target>
        </trans-unit>
        <trans-unit id="9af1a3f7e74758af6362de95fe293ce9aa19535b" translate="yes" xml:space="preserve">
          <source>The percentage of function, weighted by execution frequency, that must be covered by trace formation. Used when profile feedback is available.</source>
          <target state="translated">실행 빈도에 따라 가중치가 부여되고 추적 구성으로 포함되어야하는 기능의 백분율입니다. 프로파일 피드백이 사용 가능한 경우에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2679379ebc643273c71ff53ef41c24d477972525" translate="yes" xml:space="preserve">
          <source>The permissible values for &lt;var&gt;arch&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">&lt;var&gt;arch&lt;/var&gt; 에 허용되는 값 은 '</target>
        </trans-unit>
        <trans-unit id="f2d47f57e4f2874c39d4b9abd17b4e23013a44ad" translate="yes" xml:space="preserve">
          <source>The permissible values for &lt;var&gt;feature&lt;/var&gt; are listed in the sub-section on &lt;a href=&quot;#aarch64_002dfeature_002dmodifiers&quot;&gt;&lt;samp&gt;-march&lt;/samp&gt; and &lt;samp&gt;-mcpu&lt;/samp&gt; Feature Modifiers&lt;/a&gt;. Where conflicting feature modifiers are specified, the right-most feature is used.</source>
          <target state="translated">&lt;var&gt;feature&lt;/var&gt; 허용되는 값 은 아래의 하위 섹션에 나열되어 있습니다.&lt;a href=&quot;#aarch64_002dfeature_002dmodifiers&quot;&gt;&lt;samp&gt;-행진&lt;/samp&gt; 과 &lt;samp&gt;-mcpu&lt;/samp&gt;기능 수정 자&lt;/a&gt; . 충돌하는 기능 수정자가 지정된 경우 가장 오른쪽의 기능이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c7e86233015dde5cd1c78847180c34b2f1e2bf2b" translate="yes" xml:space="preserve">
          <source>The places that are searched for an included &amp;lsquo;</source>
          <target state="translated">포함 된 검색된 장소 '</target>
        </trans-unit>
        <trans-unit id="dd8b187fae5590414120f103d445af72242d5c3b" translate="yes" xml:space="preserve">
          <source>The position in the bit-field is the position, counting in bits, of the bit closest to the beginning of the structure.</source>
          <target state="translated">비트 필드에서의 위치는 구조의 시작에 가장 가까운 비트의 위치 (비트 단위)입니다.</target>
        </trans-unit>
        <trans-unit id="c4b546e403df1ecde52f18e1df9da4aeb8d7bc41" translate="yes" xml:space="preserve">
          <source>The possible values of &lt;var&gt;visibility_type&lt;/var&gt; correspond to the visibility settings in the ELF gABI.</source>
          <target state="translated">가능한 값 &lt;var&gt;visibility_type&lt;/var&gt; 의 엘프 가비의 표시 설정에 대응한다.</target>
        </trans-unit>
        <trans-unit id="f6264d8e91343ef3a61a9b344f8646bf4aba8cc7" translate="yes" xml:space="preserve">
          <source>The practice of reading from a different union member than the one most recently written to (called &amp;ldquo;type-punning&amp;rdquo;) is common. Even with</source>
          <target state="translated">가장 최근에 쓰여진 것과 다른 조합원 (&amp;ldquo;타입 정리&amp;rdquo;라고 함)과 다른 방식으로 읽는 것은 일반적입니다. 와도</target>
        </trans-unit>
        <trans-unit id="3fcfc9f88180eb2f1134228de5ee485783fb7bf2" translate="yes" xml:space="preserve">
          <source>The pragmas defined by the AArch64 target correspond to the AArch64 target function attributes. They can be specified as below:</source>
          <target state="translated">AArch64 대상에 의해 정의 된 pragma는 AArch64 대상 함수 속성에 해당합니다. 다음과 같이 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="645dbf1ac450b591d9e4ddc2872516c2fa74709d" translate="yes" xml:space="preserve">
          <source>The pragmas defined by the S/390 target correspond to the S/390 target function attributes and some the additional options:</source>
          <target state="translated">S / 390 대상에 의해 정의 된 pragma는 S / 390 대상 기능 속성 및 일부 추가 옵션에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="2c0f7aae6dce4abe2e06c56745ef40bd52aa8844" translate="yes" xml:space="preserve">
          <source>The precise convention for returning structures in memory depends on the target configuration macros.</source>
          <target state="translated">메모리에서 구조를 반환하는 정확한 규칙은 대상 구성 매크로에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="91248f1a5a5155ccc98999905b33b441a4c0b382" translate="yes" xml:space="preserve">
          <source>The precompiled header file must be produced for the same language as the current compilation. You cannot use a C precompiled header for a C++ compilation.</source>
          <target state="translated">사전 컴파일 된 헤더 파일은 현재 컴파일과 동일한 언어로 생성되어야합니다. C ++ 컴파일에는 C 사전 컴파일 된 헤더를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a7364d3dac14debc46aa1590555ff15d8a2c5504" translate="yes" xml:space="preserve">
          <source>The precompiled header file must have been produced by the same compiler binary as the current compilation is using.</source>
          <target state="translated">사전 컴파일 된 헤더 파일은 현재 컴파일에서 사용하는 것과 동일한 컴파일러 바이너리에 의해 생성되어야합니다.</target>
        </trans-unit>
        <trans-unit id="fa601548ca48cf3a1634bdb3b2571be6608e559a" translate="yes" xml:space="preserve">
          <source>The preferred mechanism to declare variable-length types like &lt;code&gt;struct line&lt;/code&gt; above is the ISO C99 &lt;em&gt;flexible array member&lt;/em&gt;, with slightly different syntax and semantics:</source>
          <target state="translated">위의 &lt;code&gt;struct line&lt;/code&gt; 과 같은 가변 길이 유형을 선언하는 선호되는 메커니즘 은 구문과 의미가 약간 다른 ISO C99 &lt;em&gt;가변 배열 멤버입니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="781223d90b25e173d9a1c191f04f39b92b12674b" translate="yes" xml:space="preserve">
          <source>The preprocessor constants &lt;code&gt;__v850&lt;/code&gt; and &lt;code&gt;__v851__&lt;/code&gt; are always defined, regardless of which processor variant is the target.</source>
          <target state="translated">전 처리기 상수 &lt;code&gt;__v850&lt;/code&gt; 및 &lt;code&gt;__v851__&lt;/code&gt; 은 어떤 프로세서 변형이 대상인지에 관계없이 항상 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="516a25c40cc84aaf870728160964e02be2e34941" translate="yes" xml:space="preserve">
          <source>The preprocessor macro &lt;code&gt;__nios2_arch__&lt;/code&gt; is available to programs, with value 1 or 2, indicating the targeted ISA level.</source>
          <target state="translated">프리 프로세서 매크로 &lt;code&gt;__nios2_arch__&lt;/code&gt; 는 대상 ISA 레벨을 나타내는 값 1 또는 2와 함께 프로그램에 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="e7e3cb02afe1efb7ea595142066c8a4b5aee7508" translate="yes" xml:space="preserve">
          <source>The preprocessor macros &lt;code&gt;__GNUC_GNU_INLINE__&lt;/code&gt; and &lt;code&gt;__GNUC_STDC_INLINE__&lt;/code&gt; may be used to check which semantics are in effect for &lt;code&gt;inline&lt;/code&gt; functions. See &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html#Common-Predefined-Macros&quot;&gt;Common Predefined Macros&lt;/a&gt; in The C Preprocessor.</source>
          <target state="translated">전 처리기 매크로 &lt;code&gt;__GNUC_GNU_INLINE__&lt;/code&gt; 및 &lt;code&gt;__GNUC_STDC_INLINE__&lt;/code&gt; 을 사용하여 &lt;code&gt;inline&lt;/code&gt; 함수 에 유효한 의미론을 확인할 수 있습니다 . C 프리 프로세서의 &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html#Common-Predefined-Macros&quot;&gt;공통 사전 정의 된 매크로&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e144b8574fca5ee84d650870787998db8cc0a6cc" translate="yes" xml:space="preserve">
          <source>The preprocessor symbols &lt;code&gt;__SEG_FS&lt;/code&gt; and &lt;code&gt;__SEG_GS&lt;/code&gt; are defined when these address spaces are supported.</source>
          <target state="translated">전 처리기 기호 &lt;code&gt;__SEG_FS&lt;/code&gt; 및 &lt;code&gt;__SEG_GS&lt;/code&gt; 는 이러한 주소 공간이 지원 될 때 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="59cc56242765d93d1139cc69346a113ae66f0437" translate="yes" xml:space="preserve">
          <source>The preprocessor treatment of escaped newlines is more relaxed than that specified by the C90 standard, which requires the newline to immediately follow a backslash. GCC&amp;rsquo;s implementation allows whitespace in the form of spaces, horizontal and vertical tabs, and form feeds between the backslash and the subsequent newline. The preprocessor issues a warning, but treats it as a valid escaped newline and combines the two lines to form a single logical line. This works within comments and tokens, as well as between tokens. Comments are &lt;em&gt;not&lt;/em&gt; treated as whitespace for the purposes of this relaxation, since they have not yet been replaced with spaces.</source>
          <target state="translated">이스케이프 된 줄 바꿈의 전 처리기 처리는 C90 표준에 의해 지정된 것보다 느슨해 지므로 줄 바꿈을 즉시 따라야합니다. GCC의 구현은 공백, 가로 및 세로 탭의 형태로 공백을 허용하고 백 슬래시와 후속 줄 바꿈 사이에 양식 피드를 허용합니다. 전처리 기는 경고를 발행하지만 경고를 유효한 이스케이프 개행으로 취급하고 두 행을 결합하여 단일 논리 행을 형성합니다. 이것은 주석과 토큰뿐만 아니라 토큰 사이에서도 작동합니다. 댓글이되어 &lt;em&gt;있지&lt;/em&gt; 가 아직 공백으로 대체되어 있지 않기 때문에,이 휴식의 목적 공백으로 처리.</target>
        </trans-unit>
        <trans-unit id="a2282938cc4db5b60fc722ea3f4e0b1558cfa2dc" translate="yes" xml:space="preserve">
          <source>The program counter (PC) is 2 bytes wide. This is the case for devices with up to 128 KiB of program memory.</source>
          <target state="translated">프로그램 카운터 (PC)의 폭은 2 바이트입니다. 최대 128KiB의 프로그램 메모리가있는 장치의 경우입니다.</target>
        </trans-unit>
        <trans-unit id="bdec771ba3fce1f14ccbe2f783eeba3b5eb697cc" translate="yes" xml:space="preserve">
          <source>The programs that fix the header files do not understand this special way of using symbolic links; therefore, the directory of fixed header files is good only for the machine model used to build it.</source>
          <target state="translated">헤더 파일을 수정하는 프로그램은 심볼릭 링크를 사용하는이 특별한 방법을 이해하지 못합니다. 따라서 고정 헤더 파일의 디렉토리는이를 빌드하는 데 사용 된 머신 모델에만 적합합니다.</target>
        </trans-unit>
        <trans-unit id="09f7403716543aa22328bdac3e1ded4dc52aedb3" translate="yes" xml:space="preserve">
          <source>The qualifier &lt;code&gt;dynamic&lt;/code&gt; means that the function manipulates the stack dynamically: in addition to the static allocation described above, stack adjustments are made in the body of the function, for example to push/pop arguments around function calls. If the qualifier &lt;code&gt;bounded&lt;/code&gt; is also present, the amount of these adjustments is bounded at compile time and the second field is an upper bound of the total amount of stack used by the function. If it is not present, the amount of these adjustments is not bounded at compile time and the second field only represents the bounded part.</source>
          <target state="translated">한정자 &lt;code&gt;dynamic&lt;/code&gt; 은 함수가 스택을 동적으로 조작 함을 의미합니다. 위에서 설명한 정적 할당 외에도 스택 조정은 함수 본문에서 수행됩니다 (예 : 함수 호출 주위에 인수 푸시 / 팝). 한정된 &lt;code&gt;bounded&lt;/code&gt; 자가 있는 경우 이러한 조정의 양은 컴파일 타임에 제한되며 두 번째 필드는 함수가 사용하는 총 스택 양의 상한입니다. 존재하지 않는 경우, 이러한 조정 량은 컴파일 타임에 제한되지 않으며 두 번째 필드는 한정된 부분 만 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="16b6ee8f6057a92bf82347dbc31b9360f115d43a" translate="yes" xml:space="preserve">
          <source>The qualifier &lt;code&gt;static&lt;/code&gt; means that the function manipulates the stack statically: a fixed number of bytes are allocated for the frame on function entry and released on function exit; no stack adjustments are otherwise made in the function. The second field is this fixed number of bytes.</source>
          <target state="translated">한정자 &lt;code&gt;static&lt;/code&gt; 은 함수가 스택을 정적으로 조작 함을 의미합니다. 고정 된 수의 바이트가 함수 입력시 프레임에 할당되고 함수 종료시 해제됩니다. 그렇지 않으면 기능에서 스택 조정이 수행되지 않습니다. 두 번째 필드는이 고정 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="d99c785e19e25b0fcfa2c0d8dc79cf7ec34db9e9" translate="yes" xml:space="preserve">
          <source>The rank of any extended integer type relative to another extended integer type with the same precision (C99 and C11 6.3.1.1).</source>
          <target state="translated">동일한 정밀도 (C99 및 C11 6.3.1.1)를 가진 다른 확장 정수 유형에 대한 확장 정수 유형의 순위입니다.</target>
        </trans-unit>
        <trans-unit id="cf6573d176933b5e09eb83df2d5615b45a3bb76e" translate="yes" xml:space="preserve">
          <source>The reason for using names that start with underscores for the local variables is to avoid conflicts with variable names that occur within the expressions that are substituted for &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. Eventually we hope to design a new form of declaration syntax that allows you to declare variables whose scopes start only after their initializers; this will be a more reliable way to prevent such conflicts.</source>
          <target state="translated">지역 변수에 밑줄로 시작하는 이름을 사용하는 이유는 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 로 대체되는 표현식에서 발생하는 변수 이름과의 충돌을 피하기 위해서 입니다. 결국 우리는 범위가 초기화 이후에만 시작되는 변수를 선언 할 수있는 새로운 형태의 선언 구문을 설계하려고합니다. 이는 이러한 충돌을 방지하는보다 안정적인 방법입니다.</target>
        </trans-unit>
        <trans-unit id="17b5e6eec29945ad1cdc98a53fb0e13f400b8a4b" translate="yes" xml:space="preserve">
          <source>The register assignments for arguments and return values remain the same, but each scalar value is passed in a single 64-bit register rather than a pair of 32-bit registers. For example, scalar floating-point values are returned in &amp;lsquo;</source>
          <target state="translated">인수 및 리턴 값에 대한 레지스터 지정은 동일하게 유지되지만 각 스칼라 값은 한 쌍의 32 비트 레지스터가 아닌 단일 64 비트 레지스터로 전달됩니다. 예를 들어 스칼라 부동 소수점 값은 '</target>
        </trans-unit>
        <trans-unit id="df089519561a6aaf6b0d5462a2d12a16f51ac16a" translate="yes" xml:space="preserve">
          <source>The register class usable in short insns. This is a register class constraint, and can thus drive register allocation. This constraint won&amp;rsquo;t match unless</source>
          <target state="translated">짧은 클래스에서 사용할 수있는 레지스터 클래스입니다. 이것은 레지스터 클래스 제약 조건이므로 레지스터 할당을 유도 할 수 있습니다. 이 제약 조건은 일치하지 않는 한</target>
        </trans-unit>
        <trans-unit id="ce5827517313f66ee35c67440ea785808e96b2d8" translate="yes" xml:space="preserve">
          <source>The register group usable in short insns. This constraint does not use a register class, so that it only passively matches suitable registers, and doesn&amp;rsquo;t drive register allocation.</source>
          <target state="translated">짧은 기능으로 사용할 수있는 레지스터 그룹입니다. 이 제약 조건은 레지스터 클래스를 사용하지 않으므로 적합한 레지스터 만 수동으로 일치하고 레지스터 할당을 유도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="72d3acac63bf69f2e9cbe4802b6dfb23c1a3dc0a" translate="yes" xml:space="preserve">
          <source>The register indicated by Rx (not implemented yet).</source>
          <target state="translated">Rx로 표시되는 레지스터 (아직 구현되지 않음).</target>
        </trans-unit>
        <trans-unit id="b14ae46b310b2d10e38a2d9126edc47d0a1b7438" translate="yes" xml:space="preserve">
          <source>The registers reserved for interrupts (&lt;code&gt;R24&lt;/code&gt; to &lt;code&gt;R31&lt;/code&gt;).</source>
          <target state="translated">인터럽트 용으로 예약 된 레지스터 ( &lt;code&gt;R24&lt;/code&gt; ~ &lt;code&gt;R31&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5b9c9dc3621d339e8f64077eedb5da8839ab6a60" translate="yes" xml:space="preserve">
          <source>The relevant bytes of the representation of the object are treated as an object of the type used for the access. See &lt;a href=&quot;optimize-options#Type_002dpunning&quot;&gt;Type-punning&lt;/a&gt;. This may be a trap representation.</source>
          <target state="translated">객체 표현의 관련 바이트는 액세스에 사용되는 유형의 객체로 취급됩니다. &lt;a href=&quot;optimize-options#Type_002dpunning&quot;&gt;유형 제거를&lt;/a&gt; 참조하십시오 . 이것은 트랩 표현 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f41e3aebc6e71662ecec887032e93bdb3882f388" translate="yes" xml:space="preserve">
          <source>The remainder of this section is specific to GNU C90 inlining.</source>
          <target state="translated">이 섹션의 나머지 부분은 GNU C90 인라이닝에만 해당됩니다.</target>
        </trans-unit>
        <trans-unit id="558c61b7cf4311ca70d848b51262ab1898c102b3" translate="yes" xml:space="preserve">
          <source>The remaining environment variables apply only when preprocessing the particular language indicated. Each specifies a list of directories to be searched as if specified with</source>
          <target state="translated">나머지 환경 변수는 표시된 특정 언어를 전처리 할 때만 적용됩니다. 각각은 다음과 같이 지정된 것처럼 검색 할 디렉토리 목록을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="c96b85add00a5f322d58fcbd72ee7befb1dea21f" translate="yes" xml:space="preserve">
          <source>The remaining functions are provided for optimization purposes.</source>
          <target state="translated">나머지 기능은 최적화 목적으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="1f81fad037120bbd5cb1f32f0f1474309573caa7" translate="yes" xml:space="preserve">
          <source>The required &lt;var&gt;ref-index&lt;/var&gt; positional argument denotes a function argument of pointer (or in C++, reference) type that is subject to the access. The same pointer argument can be referenced by at most one distinct &lt;code&gt;access&lt;/code&gt; attribute.</source>
          <target state="translated">필수 &lt;var&gt;ref-index&lt;/var&gt; 위치 인수는 액세스 대상인 포인터 (또는 C ++에서는 참조) 유형의 함수 인수를 나타냅니다. 동일한 포인터 인수는 최대 하나의 고유 &lt;code&gt;access&lt;/code&gt; 속성에 의해 참조 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4420491dd7bf1c05e945f7d72f0a1731089f6301" translate="yes" xml:space="preserve">
          <source>The respective segment base must be set via some method specific to the operating system. Rather than require an expensive system call to retrieve the segment base, these address spaces are not considered to be subspaces of the generic (flat) address space. This means that explicit casts are required to convert pointers between these address spaces and the generic address space. In practice the application should cast to &lt;code&gt;uintptr_t&lt;/code&gt; and apply the segment base offset that it installed previously.</source>
          <target state="translated">각 세그먼트베이스는 운영 체제에 특정한 방법을 통해 설정해야합니다. 세그먼트베이스를 검색하기 위해 값 비싼 시스템 호출이 필요하지 않고, 이러한 주소 공간은 일반 (플랫) 주소 공간의 서브 공간으로 간주되지 않습니다. 즉, 이러한 주소 공간과 일반 주소 공간 사이에서 포인터를 변환하려면 명시 적 캐스트가 필요합니다. 실제로 애플리케이션은 &lt;code&gt;uintptr_t&lt;/code&gt; 로 캐스트하고 이전에 설치 한 세그먼트 기본 오프셋을 적용해야합니다.</target>
        </trans-unit>
        <trans-unit id="9b4574d542eb42ca2e1f7130ac8122d2979c3b76" translate="yes" xml:space="preserve">
          <source>The rest of this discussion uses the following code for illustrative purposes.</source>
          <target state="translated">이 토론의 나머지 부분에서는 설명을 위해 다음 코드를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6771696cde55a31392f32b7d1552e2429667db0a" translate="yes" xml:space="preserve">
          <source>The restrictions on &lt;code&gt;offsetof&lt;/code&gt; may be relaxed in a future version of the C++ standard.</source>
          <target state="translated">C ++ 표준의 향후 버전에서는 &lt;code&gt;offsetof&lt;/code&gt; 에 대한 제한 이 완화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd1a1a42d6420a3422e966b9e8baa0847229727c" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;vec_rlmi&lt;/code&gt; is obtained by rotating each element of the first argument vector left and inserting it under mask into the second argument vector. The third argument vector contains the mask beginning in bits 11:15, the mask end in bits 19:23, and the shift count in bits 27:31, of each element.</source>
          <target state="translated">&lt;code&gt;vec_rlmi&lt;/code&gt; 의 결과는 첫 번째 인수 벡터의 각 요소를 왼쪽으로 회전하고 마스크 아래에서 두 번째 인수 벡터에 삽입하여 얻습니다. 세 번째 인수 벡터는 각 요소의 비트 11:15로 시작하는 마스크, 비트 19:23으로의 마스크 끝 및 비트 27:31의 이동 횟수를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="b9a3f0d57a834ed4eba9054b925159bf84ea4a8e" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;vec_rlnm&lt;/code&gt; is obtained by rotating each element of the first argument vector left and ANDing it with a mask specified by the second and third argument vectors. The second argument vector contains the shift count for each element in the low-order byte. The third argument vector contains the mask end for each element in the low-order byte, with the mask begin in the next higher byte.</source>
          <target state="translated">&lt;code&gt;vec_rlnm&lt;/code&gt; 의 결과는 첫 번째 인수 벡터의 각 요소를 왼쪽으로 회전하고 두 번째 및 세 번째 인수 벡터로 지정된 마스크를 사용하여 AND를 지정하여 얻습니다. 두 번째 인수 벡터에는 하위 바이트의 각 요소에 대한 시프트 수가 포함됩니다. 세 번째 인수 벡터에는 하위 바이트의 각 요소에 대한 마스크 끝이 포함되며 마스크는 다음 상위 바이트에서 시작합니다.</target>
        </trans-unit>
        <trans-unit id="8ac79b53c282a3e1bdc553acd00140fe5cdb87cf" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;vec_vrlnm&lt;/code&gt; is obtained by rotating each element of the first argument vector left and ANDing it with a mask. The second argument vector contains the mask beginning in bits 11:15, the mask end in bits 19:23, and the shift count in bits 27:31, of each element.</source>
          <target state="translated">&lt;code&gt;vec_vrlnm&lt;/code&gt; 의 결과는 첫 번째 인수 벡터의 각 요소를 왼쪽으로 회전하고 마스크를 사용하여 AND 처리하여 얻습니다. 두 번째 인수 벡터는 각 요소의 비트 11:15로 시작하는 마스크, 비트 19:23으로의 마스크 끝 및 비트 27:31의 이동 횟수를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="9316b131e727e77ff29281dc2e9a7402d2bc6522" translate="yes" xml:space="preserve">
          <source>The result of attempting to indirectly access an object with automatic or thread storage duration from a thread other than the one with which it is associated (C11 6.2.4).</source>
          <target state="translated">연관된 스레드 이외의 스레드에서 자동 또는 스레드 스토리지 기간으로 오브젝트에 간접적으로 액세스하려고 시도한 결과 (C11 6.2.4).</target>
        </trans-unit>
        <trans-unit id="293312cb8a66343c5e00cc15dc2d11a748b78cdb" translate="yes" xml:space="preserve">
          <source>The result of converting a pointer to an integer or vice versa (C90 6.3.4, C99 and C11 6.3.2.3).</source>
          <target state="translated">포인터를 정수로 또는 그 반대로 변환 한 결과 (C90 6.3.4, C99 및 C11 6.3.2.3)</target>
        </trans-unit>
        <trans-unit id="d8adce6949d651dd3877dd8fc89775a368e6c5a5" translate="yes" xml:space="preserve">
          <source>The result of, or the signal raised by, converting an integer to a signed integer type when the value cannot be represented in an object of that type (C90 6.2.1.2, C99 and C11 6.3.1.3).</source>
          <target state="translated">해당 유형의 오브젝트에 값을 표시 할 수없는 경우 정수를 부호있는 정수 유형으로 변환 한 결과 또는 발생 된 신호 (C90 6.2.1.2, C99 및 C11 6.3.1.3).</target>
        </trans-unit>
        <trans-unit id="6372dea778f1e54932d501af42dec0c2c6cb7a32" translate="yes" xml:space="preserve">
          <source>The resulting code should be considerably faster in the majority of cases and avoid the numerical instability problems of 387 code, but may break some existing code that expects temporaries to be 80 bits.</source>
          <target state="translated">결과 코드는 대부분의 경우에 훨씬 빠르며 387 코드의 수치 적 불안정성 문제를 피해야하지만 임시 코드가 80 비트 일 것으로 예상되는 기존 코드를 손상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="602584d89b66e12499de96c6abd45f1820a6ab70" translate="yes" xml:space="preserve">
          <source>The results of some bitwise operations on signed integers (C90 6.3, C99 and C11 6.5).</source>
          <target state="translated">부호있는 정수 (C90 6.3, C99 및 C11 6.5)에 대한 비트 단위 연산의 결과.</target>
        </trans-unit>
        <trans-unit id="08e0446d619f737b8b3d1bfcead4987221134fe0" translate="yes" xml:space="preserve">
          <source>The return type, including type qualifiers. For example, a method returning &lt;code&gt;int&lt;/code&gt; would have &lt;code&gt;i&lt;/code&gt; here.</source>
          <target state="translated">타입 한정자를 포함한 리턴 타입. 예를 들어, &lt;code&gt;int&lt;/code&gt; 를 반환하는 메소드 에는 &lt;code&gt;i&lt;/code&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d722a3f7a5a03ca6f3a20b50840f8dad2ad4a0a2" translate="yes" xml:space="preserve">
          <source>The return value is the value of &lt;var&gt;exp&lt;/var&gt;, which should be an integral expression. The semantics of the built-in are that it is expected that &lt;var&gt;exp&lt;/var&gt; == &lt;var&gt;c&lt;/var&gt;. For example:</source>
          <target state="translated">반환 값은 &lt;var&gt;exp&lt;/var&gt; 의 값으로 , 정수식이어야합니다. 내장의 의미는 &lt;var&gt;exp&lt;/var&gt; == &lt;var&gt;c&lt;/var&gt; 일 것으로 예상 됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="66b2899a0dec22c6c49cc318d7875f38a40fbcdb" translate="yes" xml:space="preserve">
          <source>The return value of the method is the number of objects in the current batch; this should not exceed &lt;code&gt;len&lt;/code&gt;, which is the maximum size of a batch as requested by the caller. The batch itself is returned in the &lt;code&gt;itemsPtr&lt;/code&gt; field of the &lt;code&gt;NSFastEnumerationState&lt;/code&gt; struct.</source>
          <target state="translated">메소드의 리턴 값은 현재 배치의 오브젝트 수입니다. 이것은 호출자가 요청한 배치의 최대 크기 인 &lt;code&gt;len&lt;/code&gt; 을 초과하지 않아야 합니다. 배치 자체는 &lt;code&gt;NSFastEnumerationState&lt;/code&gt; 구조체 의 &lt;code&gt;itemsPtr&lt;/code&gt; 필드에 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="bd39f3563e6cdbea884ac0f3b2596eb7ac3835c0" translate="yes" xml:space="preserve">
          <source>The rounding behaviors characterized by non-standard values of &lt;code&gt;FLT_ROUNDS&lt;/code&gt; (C90, C99 and C11 5.2.4.2.2).</source>
          <target state="translated">반올림 동작은 비표준 값 &lt;code&gt;FLT_ROUNDS&lt;/code&gt; (C90, C99 및 C11 5.2.4.2.2)를 특징으로합니다.</target>
        </trans-unit>
        <trans-unit id="ca0bfeda9cecd5551824a4a4e37d54810853db32" translate="yes" xml:space="preserve">
          <source>The runtime support file</source>
          <target state="translated">런타임 지원 파일</target>
        </trans-unit>
        <trans-unit id="b4c4c0226af27718cbd914b43f7be4de41a152cd" translate="yes" xml:space="preserve">
          <source>The safe way to write such code is to give the temporary a name, which forces it to remain until the end of the scope of the name. For example:</source>
          <target state="translated">이러한 코드를 작성하는 안전한 방법은 임시 이름을 지정하여 이름 범위가 끝날 때까지 이름을 유지하는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ba4b69f3a9e8d7ca80206177b8876cf920e6f11b" translate="yes" xml:space="preserve">
          <source>The same</source>
          <target state="translated">똑같다</target>
        </trans-unit>
        <trans-unit id="e53e3a35319895514d679977563fa8e554b518de" translate="yes" xml:space="preserve">
          <source>The same constraints on arguments apply as for the corresponding &lt;code&gt;__atomic_op_fetch&lt;/code&gt; built-in functions. All memory orders are valid.</source>
          <target state="translated">대응하는 &lt;code&gt;__atomic_op_fetch&lt;/code&gt; 내장 함수 와 동일한 인수 제한이 적용됩니다 . 모든 메모리 주문이 유효합니다.</target>
        </trans-unit>
        <trans-unit id="1d3bb42125b4caec8cf7a192592fcd99a8477b57" translate="yes" xml:space="preserve">
          <source>The same constraints on arguments apply as for the corresponding &lt;code&gt;__sync_op_and_fetch&lt;/code&gt; built-in functions.</source>
          <target state="translated">해당 &lt;code&gt;__sync_op_and_fetch&lt;/code&gt; 내장 함수 와 동일한 인수 제약 조건이 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e9ffb18b7d09b9daf66ff3c77ffe4ceee695ef40" translate="yes" xml:space="preserve">
          <source>The same problem can occur if one output parameter (&lt;var&gt;a&lt;/var&gt;) allows a register constraint and another output parameter (&lt;var&gt;b&lt;/var&gt;) allows a memory constraint. The code generated by GCC to access the memory address in &lt;var&gt;b&lt;/var&gt; can contain registers which &lt;em&gt;might&lt;/em&gt; be shared by &lt;var&gt;a&lt;/var&gt;, and GCC considers those registers to be inputs to the asm. As above, GCC assumes that such input registers are consumed before any outputs are written. This assumption may result in incorrect behavior if the &lt;code&gt;asm&lt;/code&gt; statement writes to &lt;var&gt;a&lt;/var&gt; before using &lt;var&gt;b&lt;/var&gt;. Combining the &amp;lsquo;</source>
          <target state="translated">하나의 출력 매개 변수 ( &lt;var&gt;a&lt;/var&gt; )가 레지스터 제한 조건을 허용하고 다른 출력 매개 변수 ( &lt;var&gt;b&lt;/var&gt; )가 메모리 제한 조건을 허용하는 경우에도 동일한 문제점이 발생할 수 있습니다 . GCC에 의해 생성 된 코드의 메모리 어드레스에 액세스하는 &lt;var&gt;b&lt;/var&gt; 레지스터를 포함 할 &lt;em&gt;수있는&lt;/em&gt; 공유 할 &lt;var&gt;a&lt;/var&gt; 하고 GCC는 ASM의 입력으로 그 레지스터를 고려한다. 위와 같이 GCC는 출력을 쓰기 전에 이러한 입력 레지스터가 소비된다고 가정합니다. 경우이 가정은 잘못된 동작이 발생할 수 있습니다 &lt;code&gt;asm&lt;/code&gt; 문에 기록 사용하기 전에 &lt;var&gt;b&lt;/var&gt; . '결합 &lt;var&gt;a&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="84eb297a7c7adafda6643fbbc1a64827529d36ab" translate="yes" xml:space="preserve">
          <source>The same values for</source>
          <target state="translated">에 대한 동일한 값</target>
        </trans-unit>
        <trans-unit id="10b4b93db032b4ab2baad7ea49ce309b241f5e8b" translate="yes" xml:space="preserve">
          <source>The scale (in percents) applied to</source>
          <target state="translated">적용되는 척도 (퍼센트)</target>
        </trans-unit>
        <trans-unit id="5ee0deba9d1e7e31914904f7de96ff06cf02541a" translate="yes" xml:space="preserve">
          <source>The second and third &lt;code&gt;FOO&lt;/code&gt; should be in comments. This warning is on by default.</source>
          <target state="translated">두 번째 및 세 번째 &lt;code&gt;FOO&lt;/code&gt; 는 의견에 있어야합니다. 이 경고는 기본적으로 켜져 있습니다.</target>
        </trans-unit>
        <trans-unit id="498b43ab0ba23ca5cccab7efec7dc706e6795ec7" translate="yes" xml:space="preserve">
          <source>The second argument to &lt;var&gt;__builtin_crypto_vshasigmad&lt;/var&gt; and &lt;var&gt;__builtin_crypto_vshasigmaw&lt;/var&gt; must be a constant integer that is 0 or 1. The third argument to these built-in functions must be a constant integer in the range of 0 to 15.</source>
          <target state="translated">&lt;var&gt;__builtin_crypto_vshasigmad&lt;/var&gt; 및 &lt;var&gt;__builtin_crypto_vshasigmaw&lt;/var&gt; 에 대한 두 번째 인수 는 0 또는 1의 상수 정수 여야합니다. 이러한 내장 함수에 대한 세 번째 인수는 0-15 범위의 상수 정수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="a7455b53d8f1101ab3b5613a9bfe23cea1588051" translate="yes" xml:space="preserve">
          <source>The second argument, &lt;var&gt;failval&lt;/var&gt;, is optional and defaults to zero if omitted.</source>
          <target state="translated">두 번째 인수 &lt;var&gt;failval&lt;/var&gt; 은 선택 사항이며 생략하면 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="e5696540b2cb16b0a24c5184cde684653dcb48a5" translate="yes" xml:space="preserve">
          <source>The second form of this directive is useful for the case where you have multiple headers with the same name in different directories. If you use this form, you must specify the same string to &amp;lsquo;</source>
          <target state="translated">이 지시문의 두 번째 형식은 다른 디렉토리에 동일한 이름을 가진 여러 헤더가있는 경우에 유용합니다. 이 양식을 사용하는 경우 동일한 문자열을 '</target>
        </trans-unit>
        <trans-unit id="f7af4ae65c75a113a136191463890951e0da2e45" translate="yes" xml:space="preserve">
          <source>The second pair of &lt;var&gt;n2&lt;/var&gt;:&lt;var&gt;m2&lt;/var&gt; values allows you to specify a secondary alignment:</source>
          <target state="translated">&lt;var&gt;n2&lt;/var&gt; : &lt;var&gt;m2&lt;/var&gt; 값 의 두 번째 쌍 을 사용하면 보조 정렬을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ab6989d4c1c4f47e25307deb785d43e56803a5f" translate="yes" xml:space="preserve">
          <source>The security extension.</source>
          <target state="translated">보안 확장.</target>
        </trans-unit>
        <trans-unit id="227e1ad96cf49ba3c90eaa74176faf5e4ae6abc9" translate="yes" xml:space="preserve">
          <source>The sense of a qualifier can be inverted by prefixing it with the &amp;lsquo;</source>
          <target state="translated">한정자의 의미는 앞에 '를 붙여서 반전시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="555ceee2bb9cf5f8f3e29c4052854238c7fb191f" translate="yes" xml:space="preserve">
          <source>The set of runtime conventions followed by all of the tools that deal with binary representations of a program, including compilers, assemblers, linkers, and language runtime support. Some ABIs are formal with a written specification, possibly designed by multiple interested parties. Others are simply the way things are actually done by a particular set of tools.</source>
          <target state="translated">컴파일러, 어셈블러, 링커 및 언어 런타임 지원을 포함하여 프로그램의 이진 표현을 처리하는 모든 도구가 따르는 런타임 규칙 집합입니다. 일부 ABI는 여러 이해 당사자가 설계 한 서면 사양으로 공식화되어 있습니다. 다른 것은 단순히 특정 도구 세트에 의해 실제로 수행되는 방식입니다.</target>
        </trans-unit>
        <trans-unit id="3a0b9082dbf784ec48751abb46feb9a84f16889b" translate="yes" xml:space="preserve">
          <source>The setting &amp;lsquo;</source>
          <target state="translated">설정 '</target>
        </trans-unit>
        <trans-unit id="be945ed951ef5a61f5eae361b911de27ce4736fe" translate="yes" xml:space="preserve">
          <source>The shadow stack unwind code looks like:</source>
          <target state="translated">섀도 스택 해제 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5e51279e9e910972feb51c0c337d5562d0a6bae6" translate="yes" xml:space="preserve">
          <source>The sign of the remainder on integer division (C90 6.3.5).</source>
          <target state="translated">정수 나누기의 나머지 부호 (C90 6.3.5).</target>
        </trans-unit>
        <trans-unit id="3873ede6c61e304d381b113f1c8a01eb501fad5a" translate="yes" xml:space="preserve">
          <source>The simplest kind of constraint is a string full of letters, each of which describes one kind of operand that is permitted. Here are the letters that are allowed:</source>
          <target state="translated">가장 간단한 종류의 제약 조건은 문자로 가득 찬 문자열이며, 각각은 허용되는 한 종류의 피연산자를 설명합니다. 허용되는 글자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f57db1d7a87e06c8af2c5a7b6a9b449af372d773" translate="yes" xml:space="preserve">
          <source>The single- and double-precision FPv5 floating-point instructions.</source>
          <target state="translated">단 정밀도 및 배정도 FPv5 부동 소수점 명령어.</target>
        </trans-unit>
        <trans-unit id="8bf5f529e48bebb5ac22844826b001e3be0c3afe" translate="yes" xml:space="preserve">
          <source>The single- and double-precision floating-point instructions.</source>
          <target state="translated">단 정밀도 및 배정 밀도 부동 소수점 명령어</target>
        </trans-unit>
        <trans-unit id="8ac5488ac14854117c1393d98f83c5a93f21526b" translate="yes" xml:space="preserve">
          <source>The single-precision FPv5 floating-point instructions.</source>
          <target state="translated">단정도 FPv5 부동 소수점 명령어</target>
        </trans-unit>
        <trans-unit id="1ebaf382d5bdec22e2b7379aab4b7c48ea9e912b" translate="yes" xml:space="preserve">
          <source>The single-precision VFPv3 floating-point instructions with 16 double-precision registers and the half-precision floating-point conversion operations.</source>
          <target state="translated">16 개의 배정 밀도 레지스터와 반 정밀도 부동 소수점 변환 연산이있는 단 정밀도 VFPv3 부동 소수점 명령어.</target>
        </trans-unit>
        <trans-unit id="e7ad435877ea887d34b1b37f15d7368e56cc4675" translate="yes" xml:space="preserve">
          <source>The single-precision VFPv3 floating-point instructions. The extension &amp;lsquo;</source>
          <target state="translated">단 정밀도 VFPv3 부동 소수점 명령어. 확장 '</target>
        </trans-unit>
        <trans-unit id="3e79bc7e04e01647f6facb0d53f8d2ca1a7bc417" translate="yes" xml:space="preserve">
          <source>The single-precision VFPv4 floating-point instructions.</source>
          <target state="translated">단 정밀도 VFPv4 부동 소수점 명령어.</target>
        </trans-unit>
        <trans-unit id="d793936d7de82c8ba0aab481f238e4822e465c4a" translate="yes" xml:space="preserve">
          <source>The single-precision floating-point instructions.</source>
          <target state="translated">단 정밀도 부동 소수점 명령어</target>
        </trans-unit>
        <trans-unit id="2d2a7508c4cb1900d0918961e8e0427152b72902" translate="yes" xml:space="preserve">
          <source>The size in bits of &lt;code&gt;double&lt;/code&gt; if</source>
          <target state="translated">비트 크기의 &lt;code&gt;double&lt;/code&gt; 경우</target>
        </trans-unit>
        <trans-unit id="7ecbdd892eade8e6d4362e90240ff9047e6b2c01" translate="yes" xml:space="preserve">
          <source>The size of &lt;code&gt;t1&lt;/code&gt; is 8 bytes with the zero-length bit-field. If the zero-length bit-field were removed, &lt;code&gt;t1&lt;/code&gt;&amp;rsquo;s size would be 4 bytes.</source>
          <target state="translated">&lt;code&gt;t1&lt;/code&gt; 의 크기는 길이가 0 인 비트 필드의 8 바이트입니다. 길이가 0 인 비트 필드가 제거 된 경우 &lt;code&gt;t1&lt;/code&gt; 크기는 4 바이트입니다.</target>
        </trans-unit>
        <trans-unit id="d897dab500e785baf0afcdb6330501b34e2fb781" translate="yes" xml:space="preserve">
          <source>The size of L1 data cache, in kilobytes.</source>
          <target state="translated">L1 데이터 캐시의 크기 (KB)입니다.</target>
        </trans-unit>
        <trans-unit id="ff6dd15bf08b6f82cff4329c9e979dcd9c6cbe07" translate="yes" xml:space="preserve">
          <source>The size of L2 data cache, in kilobytes.</source>
          <target state="translated">L2 데이터 캐시의 크기 (KB)입니다.</target>
        </trans-unit>
        <trans-unit id="71e800ceb09e88f57e9df529fb883fbfe1a95ef2" translate="yes" xml:space="preserve">
          <source>The size of cache line in L1 data cache, in bytes.</source>
          <target state="translated">L1 데이터 캐시의 캐시 라인 크기 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="3f610b8af116509d824f7fee0527a19292abfbc2" translate="yes" xml:space="preserve">
          <source>The size of the result of subtracting two pointers to elements of the same array (C90 6.3.6, C99 and C11 6.5.6).</source>
          <target state="translated">동일한 배열의 요소에 대한 두 개의 포인터를 뺀 결과 크기 (C90 6.3.6, C99 및 C11 6.5.6).</target>
        </trans-unit>
        <trans-unit id="bcebc70f5d364873d98786d882fbb6e891304f9b" translate="yes" xml:space="preserve">
          <source>The sizes of all structures and unions are rounded up to a multiple of the number of bits set by this option. Permissible values are 8, 32 and 64. The default value varies for different toolchains. For the COFF targeted toolchain the default value is 8. A value of 64 is only allowed if the underlying ABI supports it.</source>
          <target state="translated">모든 구조와 공용체의 크기는이 옵션으로 설정 한 비트 수의 배수로 올림됩니다. 허용되는 값은 8, 32 및 64입니다. 기본값은 툴체인마다 다릅니다. COFF 대상 툴체인의 경우 기본값은 8입니다. 기본 ABI가 지원하는 경우에만 64 값이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="90ff87dc2c61fa6c28fc00209d8623b3de0f7131" translate="yes" xml:space="preserve">
          <source>The small data area consists of sections &lt;code&gt;.sdata&lt;/code&gt; and &lt;code&gt;.sbss&lt;/code&gt;. Objects may be explicitly put in the small data area with the &lt;code&gt;section&lt;/code&gt; attribute using one of these sections.</source>
          <target state="translated">작은 데이터 영역은 &lt;code&gt;.sdata&lt;/code&gt; 및 &lt;code&gt;.sbss&lt;/code&gt; 섹션으로 구성됩니다 . 이러한 섹션 중 하나를 사용하여 &lt;code&gt;section&lt;/code&gt; 속성을 사용하여 작은 데이터 영역에 개체를 명시 적으로 넣을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1c7aae5531671a570fbd2d9e15330b629b257be9" translate="yes" xml:space="preserve">
          <source>The smallest number of different values for which it is best to use a jump-table instead of a tree of conditional branches. If the value is 0, use the default for the machine.</source>
          <target state="translated">조건부 분기 트리 대신 점프 테이블을 사용하는 것이 가장 좋은 다른 값의 최소 개수입니다. 값이 0이면 머신의 기본값을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="792c114efc46a607cc045f1ab679489dd4452c8d" translate="yes" xml:space="preserve">
          <source>The solution is to change your program to use appropriate system headers (&lt;code&gt;&amp;lt;time.h&amp;gt;&lt;/code&gt; on systems with ISO C headers) and not to declare &lt;code&gt;time&lt;/code&gt; if the system header files declare it, or failing that to use &lt;code&gt;time_t&lt;/code&gt; as the return type of &lt;code&gt;time&lt;/code&gt;.</source>
          <target state="translated">해결책은 적절한 시스템 헤더 ( ISO C 헤더 가있는 시스템의 경우 &lt;code&gt;&amp;lt;time.h&amp;gt;&lt;/code&gt; ) 를 사용하도록 프로그램을 변경 하고 시스템 헤더 파일이 선언 한 경우 &lt;code&gt;time&lt;/code&gt; 을 선언하지 않거나 &lt;code&gt;time_t&lt;/code&gt; 를 &lt;code&gt;time&lt;/code&gt; 유형으로 반환 하지 않는 것입니다. .</target>
        </trans-unit>
        <trans-unit id="7081cb8d8850184ab64a42d1afab009a2529d69a" translate="yes" xml:space="preserve">
          <source>The solution is to not use the</source>
          <target state="translated">해결책은</target>
        </trans-unit>
        <trans-unit id="3f3e873518a99bceb250e9bd12263d250fd2ddde" translate="yes" xml:space="preserve">
          <source>The solution to these problems is to change the program to use &lt;code&gt;char&lt;/code&gt;-array variables with initialization strings for these purposes instead of string constants.</source>
          <target state="translated">이러한 문제점에 대한 해결책 은 문자열 상수 대신 이러한 목적으로 초기화 문자열과 함께 &lt;code&gt;char&lt;/code&gt; 배열 변수 를 사용하도록 프로그램을 변경하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="65b067ba968d3fec2486b7d081b6185964ff8af7" translate="yes" xml:space="preserve">
          <source>The stack is not unwound before std::terminate is called.</source>
          <target state="translated">std :: terminate가 호출되기 전에 스택이 풀리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2ac8658551fc80e0b476a0a64406cc85ed6f059b" translate="yes" xml:space="preserve">
          <source>The stack pointer (SP) register is treated as 8-bit respectively 16-bit register by the compiler. The definition of these macros is affected by</source>
          <target state="translated">스택 포인터 (SP) 레지스터는 컴파일러에 의해 각각 8 비트 16 비트 레지스터로 처리됩니다. 이 매크로의 정의는 다음의 영향을받습니다.</target>
        </trans-unit>
        <trans-unit id="ba04d525c72586baf4467ca71d2abc7ef4aa1e82" translate="yes" xml:space="preserve">
          <source>The stack pointer register (&lt;code&gt;SP&lt;/code&gt;)</source>
          <target state="translated">스택 포인터 레지스터 ( &lt;code&gt;SP&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="0015c9e48f6bee73194b21376b4a1e1666cb6b7a" translate="yes" xml:space="preserve">
          <source>The stack pointer register.</source>
          <target state="translated">스택 포인터 레지스터.</target>
        </trans-unit>
        <trans-unit id="7d93215dea1d74a35177f108c830b25b0a828601" translate="yes" xml:space="preserve">
          <source>The standard also defines two environments for programs, a &lt;em&gt;freestanding environment&lt;/em&gt;, required of all implementations and which may not have library facilities beyond those required of freestanding implementations, where the handling of program startup and termination are implementation-defined; and a &lt;em&gt;hosted environment&lt;/em&gt;, which is not required, in which all the library facilities are provided and startup is through a function &lt;code&gt;int
main (void)&lt;/code&gt; or &lt;code&gt;int main (int, char *[])&lt;/code&gt;. An OS kernel is an example of a program running in a freestanding environment; a program using the facilities of an operating system is an example of a program running in a hosted environment.</source>
          <target state="translated">이 표준은 또한 모든 구현에 필요한 &lt;em&gt;독립형 환경&lt;/em&gt; 과 프로그램 시작 및 종료 처리가 구현 정의 된 독립형 구현에 필요한 것 이상의 라이브러리 기능이없는 두 개의 프로그램 환경을 정의합니다. 모든 라이브러리 기능이 제공되고 시작이 &lt;code&gt;int main (void)&lt;/code&gt; 또는 &lt;code&gt;int main (int, char *[])&lt;/code&gt; 함수를 통해 시작 되는 &lt;em&gt;호스팅 환경&lt;/em&gt; . OS 커널은 독립 환경에서 실행되는 프로그램의 예입니다. 운영 체제 기능을 사용하는 프로그램은 호스팅 된 환경에서 실행되는 프로그램의 예입니다.</target>
        </trans-unit>
        <trans-unit id="aa6db7352466c6267511c0ba5dc350845fe3cad9" translate="yes" xml:space="preserve">
          <source>The standard is worded confusingly, therefore there is some debate over the precise meaning of the sequence point rules in subtle cases. Links to discussions of the problem, including proposed formal definitions, may be found on the GCC readings page, at &lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;http://gcc.gnu.org/readings.html&lt;/a&gt;.</source>
          <target state="translated">이 표준은 혼동스럽게 표현되므로 미묘한 경우 시퀀스 포인트 규칙의 정확한 의미에 대한 논쟁이 있습니다. 제안 된 공식적인 정의를 포함하여 문제에 대한 토론 링크는 GCC 읽기 페이지 ( &lt;a href=&quot;http://gcc.gnu.org/readings.html&quot;&gt;http://gcc.gnu.org/readings.html&lt;/a&gt; )에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="69cda6ddbf344279c641ca143790b176ad293ac4" translate="yes" xml:space="preserve">
          <source>The standard rules for &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt; macros are used to find a common type &lt;var&gt;u&lt;/var&gt; from the types of the arguments for parameters whose types vary between the functions; complex integer types (a GNU extension) are treated like &lt;code&gt;_Complex double&lt;/code&gt; for this purpose (or &lt;code&gt;_Complex _Float64&lt;/code&gt; if all the function return types are the same &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; or &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; type). If the function return types vary, or are all the same integer type, the function called is the one for which &lt;var&gt;t&lt;/var&gt; is &lt;var&gt;u&lt;/var&gt;, and it is an error if there is no such function. If the function return types are all the same floating-point type, the type-generic macro is taken to be one of those from TS 18661 that rounds the result to a narrower type; if there is a function for which &lt;var&gt;t&lt;/var&gt; is &lt;var&gt;u&lt;/var&gt;, it is called, and otherwise the first function, if any, for which &lt;var&gt;t&lt;/var&gt; has at least the range and precision of &lt;var&gt;u&lt;/var&gt; is called, and it is an error if there is no such function.</source>
          <target state="translated">&lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt; 매크로 의 표준 규칙 은 함수마다 유형이 다른 매개 변수의 인수 유형에서 공통 유형 &lt;var&gt;u&lt;/var&gt; 를 찾는 데 사용됩니다 . 복잡한 정수형 (a GNU 확장)처럼 취급되고 &lt;code&gt;_Complex double&lt;/code&gt; 이 목적 (또는 &lt;code&gt;_Complex _Float64&lt;/code&gt; 은 모든 함수 반환 유형이 동일한 경우 &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; 또는 &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; 형). 함수 리턴 유형이 다양하거나 모두 동일한 정수 유형 인 경우 호출 된 함수는 &lt;var&gt;t&lt;/var&gt; 가 &lt;var&gt;u&lt;/var&gt; 인 함수 입니다.해당 기능이 없으면 오류입니다. 함수 리턴 유형이 모두 동일한 부동 소수점 유형 인 경우 유형 일반 매크로는 결과를 더 좁은 유형으로 반올림하는 TS 18661의 매크로 중 하나로 간주됩니다. 해당하는 기능이 있으면 &lt;var&gt;t&lt;/var&gt; 가 있다 &lt;var&gt;u&lt;/var&gt; , 그것은 호출하고, 그렇지 않으면 제 기능 (있는 경우)하는되어 &lt;var&gt;t&lt;/var&gt; 는 적어도 상기 범위의 정밀도 갖는 &lt;var&gt;u&lt;/var&gt; 이러한 기능이없는 경우라고하며 오류라고 .</target>
        </trans-unit>
        <trans-unit id="806ce7f42e8deb00dbd822deaceb91e1417e5da0" translate="yes" xml:space="preserve">
          <source>The startup code from libgcc never sets &lt;code&gt;EIND&lt;/code&gt;. Notice that startup code is a blend of code from libgcc and AVR-LibC. For the impact of AVR-LibC on &lt;code&gt;EIND&lt;/code&gt;, see the &lt;a href=&quot;http://nongnu.org/avr-libc/user-manual/&quot;&gt;AVR-LibC user manual&lt;/a&gt;.</source>
          <target state="translated">libgcc의 시작 코드는 &lt;code&gt;EIND&lt;/code&gt; 를 설정하지 않습니다 . 시작 코드는 libgcc와 AVR-LibC의 코드가 혼합되어 있습니다. &lt;code&gt;EIND&lt;/code&gt; 에 대한 AVR-LibC의 영향에 대해서는 &lt;a href=&quot;http://nongnu.org/avr-libc/user-manual/&quot;&gt;AVR-LibC 사용자 매뉴얼을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f98c1752aa45287d5195f68be596da96d8fbbbe6" translate="yes" xml:space="preserve">
          <source>The startup code initializes the &lt;code&gt;RAMP&lt;/code&gt; special function registers with zero.</source>
          <target state="translated">시작 코드는 &lt;code&gt;RAMP&lt;/code&gt; 특수 기능 레지스터를 0으로 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="e0593142bdd3bdb84b9aebea225043f72be034cf" translate="yes" xml:space="preserve">
          <source>The storage for an object of thread storage duration shall be statically initialized before the first statement of the thread startup function. An object of thread storage duration shall not require dynamic initialization.</source>
          <target state="translated">스레드 저장 기간의 객체에 대한 저장은 스레드 시작 기능의 첫 번째 진술 전에 정적으로 초기화되어야한다. 스레드 저장 기간의 객체는 동적 초기화가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="641e9d242dbf689a8dfa4b2d4275700a77a5107c" translate="yes" xml:space="preserve">
          <source>The stored representation of the return address in memory may be different from the address returned by &lt;code&gt;__builtin_return_address&lt;/code&gt;. For example, on AArch64 the stored address may be mangled with return address signing whereas the address returned by &lt;code&gt;__builtin_return_address&lt;/code&gt; is not.</source>
          <target state="translated">메모리에 저장된 반환 주소 표현은 &lt;code&gt;__builtin_return_address&lt;/code&gt; 에서 반환 된 주소와 다를 수 있습니다 . 예를 들어 AArch64에서 저장된 주소는 반환 주소 서명으로 엉망이 될 수 있지만 &lt;code&gt;__builtin_return_address&lt;/code&gt; 에서 반환 된 주소 는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2f4b780083ada416a6c378ae8867cc1c7fb0b433" translate="yes" xml:space="preserve">
          <source>The structure has size zero. In C++, empty structures are part of the language. G++ treats empty structures as if they had a single member of type &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">구조의 크기는 0입니다. C ++에서 빈 구조는 언어의 일부입니다. G ++는 빈 구조체를 &lt;code&gt;char&lt;/code&gt; 유형의 단일 멤버가있는 것처럼 처리합니다 .</target>
        </trans-unit>
        <trans-unit id="3c2ecce652896fa952e1019513fab67001397b36" translate="yes" xml:space="preserve">
          <source>The subtype of the file created (like &amp;lsquo;</source>
          <target state="translated">생성 된 파일의 하위 유형 (예 : '</target>
        </trans-unit>
        <trans-unit id="ca6a165fe3653c2eaa19af3a9cacad8cee1b0aa0" translate="yes" xml:space="preserve">
          <source>The switch matching text &lt;code&gt;S&lt;/code&gt; in a &amp;lsquo;</source>
          <target state="translated">스위치 정합 텍스트 &lt;code&gt;S&lt;/code&gt; 'A의</target>
        </trans-unit>
        <trans-unit id="2591c1475ef50f2d7871f5727f318ca9819d88ef" translate="yes" xml:space="preserve">
          <source>The syntax for this extension is</source>
          <target state="translated">이 확장의 구문은</target>
        </trans-unit>
        <trans-unit id="c37c4e36af6f9d7c15727a683845a9a4d1ae812e" translate="yes" xml:space="preserve">
          <source>The synthetic compare types&amp;ndash;gt, lt, ge, and le.</source>
          <target state="translated">합성 비교 유형 &amp;ndash;gt, lt, ge 및 le.</target>
        </trans-unit>
        <trans-unit id="de0ec84c43a433725bea4939d7d6aa41982b5bb6" translate="yes" xml:space="preserve">
          <source>The system will help save all registers into stack before entering interrupt handler.</source>
          <target state="translated">이 시스템은 인터럽트 핸들러에 들어가기 전에 모든 레지스터를 스택에 저장하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="0b39e2e7f8f008a32869aef147d2dc6314988d7d" translate="yes" xml:space="preserve">
          <source>The system will help save caller registers into stack before entering interrupt handler.</source>
          <target state="translated">이 시스템은 인터럽트 핸들러에 들어가기 전에 호출자 레지스터를 스택에 저장하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="ebaa5c15171a87ae7a332bb49a3f32f19a3aad26" translate="yes" xml:space="preserve">
          <source>The table below lists the &lt;code&gt;v2i16&lt;/code&gt; operation for which hardware support exists for the DSP ASE REV 2. &lt;code&gt;e&lt;/code&gt; and &lt;code&gt;f&lt;/code&gt; are &lt;code&gt;v2i16&lt;/code&gt; values.</source>
          <target state="translated">아래 표에는 DSP ASE REV 2에 대한 하드웨어 지원이 존재 하는 &lt;code&gt;v2i16&lt;/code&gt; 작업이 나열되어 있습니다. &lt;code&gt;e&lt;/code&gt; 및 &lt;code&gt;f&lt;/code&gt; 는 &lt;code&gt;v2i16&lt;/code&gt; 값입니다.</target>
        </trans-unit>
        <trans-unit id="896165ef2a0dc9f91cdad7ea07b67fa41d120e44" translate="yes" xml:space="preserve">
          <source>The table below lists the &lt;code&gt;v2sf&lt;/code&gt; operations for which hardware support exists. &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; are &lt;code&gt;v2sf&lt;/code&gt; values and &lt;code&gt;x&lt;/code&gt; is an integral value.</source>
          <target state="translated">아래 표에는 하드웨어 지원이 존재 하는 &lt;code&gt;v2sf&lt;/code&gt; 작업이 나열되어 있습니다. &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; 및 &lt;code&gt;c&lt;/code&gt; 는 &lt;code&gt;v2sf&lt;/code&gt; 값이고 &lt;code&gt;x&lt;/code&gt; 는 정수 값입니다.</target>
        </trans-unit>
        <trans-unit id="9b038d441c31fe7fb35f36ddaf2d9c7ea6b680b8" translate="yes" xml:space="preserve">
          <source>The table below lists the &lt;code&gt;v4i8&lt;/code&gt; and &lt;code&gt;v2q15&lt;/code&gt; operations for which hardware support exists. &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are &lt;code&gt;v4i8&lt;/code&gt; values, and &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;d&lt;/code&gt; are &lt;code&gt;v2q15&lt;/code&gt; values.</source>
          <target state="translated">아래 표에는 하드웨어 지원이 존재 하는 &lt;code&gt;v4i8&lt;/code&gt; 및 &lt;code&gt;v2q15&lt;/code&gt; 작업이 나열되어 있습니다. &lt;code&gt;a&lt;/code&gt; 및 &lt;code&gt;b&lt;/code&gt; 는 &lt;code&gt;v4i8&lt;/code&gt; 값이고 &lt;code&gt;c&lt;/code&gt; 및 &lt;code&gt;d&lt;/code&gt; 는 &lt;code&gt;v2q15&lt;/code&gt; 값입니다.</target>
        </trans-unit>
        <trans-unit id="3f249ccb08815c6079cbd323b97a2c4ac2204382" translate="yes" xml:space="preserve">
          <source>The table below lists the supported extensions for each architecture. Architectures not mentioned do not support any extensions.</source>
          <target state="translated">아래 표에는 각 아키텍처에서 지원되는 확장이 나와 있습니다. 언급되지 않은 아키텍처는 확장을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e73d22c03412d342b6a999932c3fa6fbeb3a35b8" translate="yes" xml:space="preserve">
          <source>The table below shows the list of supported modifiers and their effects.</source>
          <target state="translated">아래 표는 지원되는 수정 자 및 그 효과 목록을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="52323f293e0d860891a87bc29f48cbde573c5856" translate="yes" xml:space="preserve">
          <source>The table below summarizes the permissible values for &lt;var&gt;arch&lt;/var&gt; and the features that they enable by default:</source>
          <target state="translated">아래 표에는 &lt;var&gt;arch&lt;/var&gt; 허용되는 값 과 기본적으로 활성화되는 기능이 요약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="15aee3d23ffff41850eb55f63ba2913dcc2593de" translate="yes" xml:space="preserve">
          <source>The target may also allow additional types in &lt;code&gt;format-arg&lt;/code&gt; attributes. See &lt;a href=&quot;target-format-checks#Target-Format-Checks&quot;&gt;Format Checks Specific to Particular Target Machines&lt;/a&gt;.</source>
          <target state="translated">대상은 &lt;code&gt;format-arg&lt;/code&gt; 속성 에서 추가 유형을 허용 할 수도 있습니다 . &lt;a href=&quot;target-format-checks#Target-Format-Checks&quot;&gt;특정 대상 시스템에 특정한 형식 검사를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2e1eb5143cb3645d3e56fe87871163fa73c09f83" translate="yes" xml:space="preserve">
          <source>The target may also provide additional types of format checks. See &lt;a href=&quot;target-format-checks#Target-Format-Checks&quot;&gt;Format Checks Specific to Particular Target Machines&lt;/a&gt;.</source>
          <target state="translated">대상은 추가 형식 검사를 제공 할 수도 있습니다. &lt;a href=&quot;target-format-checks#Target-Format-Checks&quot;&gt;특정 대상 시스템에 특정한 형식 검사를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0b814fff953e9628f2b901dd62490d599d61582c" translate="yes" xml:space="preserve">
          <source>The the register class of registers that can be used to hold a sibcall call address. I.e., a caller-saved register.</source>
          <target state="translated">sibcall 호출 주소를 보유하는 데 사용할 수있는 레지스터의 레지스터 클래스입니다. 즉, 발신자 저장 레지스터입니다.</target>
        </trans-unit>
        <trans-unit id="e9067dbfe61d5583898a4c222466eaecdc743a7f" translate="yes" xml:space="preserve">
          <source>The third word specifies the source files for those structs for which the compiler should emit debug information. The values &amp;lsquo;</source>
          <target state="translated">세 번째 단어는 컴파일러가 디버그 정보를 생성해야하는 구조체의 소스 파일을 지정합니다. '</target>
        </trans-unit>
        <trans-unit id="3c2caf56b0822fe7bc0594ac85f716ffb2f0188f" translate="yes" xml:space="preserve">
          <source>The thread that begins execution at the &lt;code&gt;main&lt;/code&gt; function is called the &lt;em&gt;main thread&lt;/em&gt;. It is implementation defined how functions beginning threads other than the main thread are designated or typed. A function so designated, as well as the &lt;code&gt;main&lt;/code&gt; function, is called a &lt;em&gt;thread startup function&lt;/em&gt;. It is implementation defined what happens if a thread startup function returns. It is implementation defined what happens to other threads when any thread calls &lt;code&gt;exit&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 함수 에서 실행을 시작하는 스레드를 &lt;em&gt;메인 스레드&lt;/em&gt; 라고합니다 . 메인 스레드 이외의 스레드를 시작하는 함수를 지정하거나 유형을 지정하는 방법이 정의되어 있습니다. 이와 같이 지정된 기능과 &lt;code&gt;main&lt;/code&gt; 기능을 &lt;em&gt;스레드 시작 기능&lt;/em&gt; 이라고 &lt;em&gt;합니다&lt;/em&gt; . 스레드 시작 함수가 리턴 될 때 발생하는 상황을 정의한 구현입니다. 스레드 호출이 &lt;code&gt;exit&lt;/code&gt; 를 호출 할 때 다른 스레드에 발생하는 상황을 구현으로 정의한 것 입니다.</target>
        </trans-unit>
        <trans-unit id="b44a5b130a3ceb5fe8f03b1aaa3178d1eeebc449" translate="yes" xml:space="preserve">
          <source>The three types of inlining behave similarly in two important cases: when the &lt;code&gt;inline&lt;/code&gt; keyword is used on a &lt;code&gt;static&lt;/code&gt; function, like the example above, and when a function is first declared without using the &lt;code&gt;inline&lt;/code&gt; keyword and then is defined with &lt;code&gt;inline&lt;/code&gt;, like this:</source>
          <target state="translated">세 가지 유형의 인라이닝은 두 가지 중요한 경우에 유사하게 작동합니다. 위의 예와 같이 &lt;code&gt;inline&lt;/code&gt; 키워드가 &lt;code&gt;static&lt;/code&gt; 함수에서 사용되는 경우와 함수가 처음으로 &lt;code&gt;inline&lt;/code&gt; 키워드 를 사용하지 않고 선언 된 후 다음 과 같이 &lt;code&gt;inline&lt;/code&gt; 으로 정의 된 경우 :</target>
        </trans-unit>
        <trans-unit id="603ab7e85053589e42da345836681d51d569791a" translate="yes" xml:space="preserve">
          <source>The threshold ratio for performing partial redundancy elimination after reload.</source>
          <target state="translated">재로드 후 부분 중복 제거를 수행하기위한 임계 값 비율입니다.</target>
        </trans-unit>
        <trans-unit id="423954d242ed49c029dc872280561e1e359efe72" translate="yes" xml:space="preserve">
          <source>The threshold ratio of critical edges execution count that permit performing redundancy elimination after reload.</source>
          <target state="translated">재로드 후 중복 제거를 수행 할 수있는 임계 에지 실행 수의 임계 값 비율입니다.</target>
        </trans-unit>
        <trans-unit id="a881665cedd4653a3bb7d98fcef7595547272bb0" translate="yes" xml:space="preserve">
          <source>The total number of input + output + goto operands is limited to 30.</source>
          <target state="translated">입력 + 출력 + goto 피연산자의 총 수는 30으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="b51a43aea88607f1a48139a383f2efbea483ea5b" translate="yes" xml:space="preserve">
          <source>The total size (in bytes) required to pass all the parameters. This includes the two hidden parameters (the object &lt;code&gt;self&lt;/code&gt; and the method selector &lt;code&gt;_cmd&lt;/code&gt;).</source>
          <target state="translated">모든 매개 변수를 전달하는 데 필요한 총 크기 (바이트) 여기에는 두 개의 숨겨진 매개 변수 (객체 &lt;code&gt;self&lt;/code&gt; 및 메소드 선택기 &lt;code&gt;_cmd&lt;/code&gt; )가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d0dea0413ee420eebb0c3352fcc9737b26d047ac" translate="yes" xml:space="preserve">
          <source>The transaction aborted due to a persistent failure. Re-execution under same circumstances will not be productive.</source>
          <target state="translated">지속적인 실패로 인해 트랜잭션이 중단되었습니다. 같은 상황에서 재실행하면 생산적이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7970397dce5e9b8e0cc50cc8d7046872a5452379" translate="yes" xml:space="preserve">
          <source>The transaction aborted due to a transient failure. The transaction should be re-executed in that case.</source>
          <target state="translated">일시적인 오류로 인해 트랜잭션이 중단되었습니다. 이 경우 트랜잭션을 다시 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="885e4cc2a7b2481bfb38880d5bc544bde78ed78c" translate="yes" xml:space="preserve">
          <source>The transaction was aborted due to an indeterminate condition which might be persistent.</source>
          <target state="translated">불확실한 조건으로 인해 트랜잭션이 중단되었습니다.</target>
        </trans-unit>
        <trans-unit id="eed635303d722768beed9ca9a2d786f5922ad4e3" translate="yes" xml:space="preserve">
          <source>The two Scalar Reduction of Aggregates passes (SRA and IPA-SRA) aim to replace scalar parts of aggregates with uses of independent scalar variables. These parameters control the maximum size, in storage units, of aggregate which is considered for replacement when compiling for speed (</source>
          <target state="translated">집계 패스의 두 스칼라 감소 (SRA 및 IPA-SRA)는 집계의 스칼라 부분을 독립 스칼라 변수의 사용으로 대체하는 것을 목표로합니다. 이 매개 변수는 속도를 컴파일 할 때 대체로 고려되는 집계의 최대 크기를 저장 단위로 제어합니다 (</target>
        </trans-unit>
        <trans-unit id="d922516e422c7b0576d05743cb3430b4c8056971" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;char&lt;/code&gt; is always a distinct type from each of &lt;code&gt;signed char&lt;/code&gt; or &lt;code&gt;unsigned char&lt;/code&gt;, even though its behavior is always just like one of those two.</source>
          <target state="translated">유형의 &lt;code&gt;char&lt;/code&gt; 항상 각에서 구별 유형 &lt;code&gt;signed char&lt;/code&gt; 또는 &lt;code&gt;unsigned char&lt;/code&gt; 의 행동은 단지 그 두 중 하나처럼 항상하더라도.</target>
        </trans-unit>
        <trans-unit id="7f1531d2ff0ef2100fb6dbf78b0a6f5c969ddbe3" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;int[]&lt;/code&gt; and &lt;code&gt;int[5]&lt;/code&gt; are compatible. On the other hand, &lt;code&gt;int&lt;/code&gt; and &lt;code&gt;char *&lt;/code&gt; are not compatible, even if the size of their types, on the particular architecture are the same. Also, the amount of pointer indirection is taken into account when determining similarity. Consequently, &lt;code&gt;short *&lt;/code&gt; is not similar to &lt;code&gt;short **&lt;/code&gt;. Furthermore, two types that are typedefed are considered compatible if their underlying types are compatible.</source>
          <target state="translated">타입 &lt;code&gt;int[]&lt;/code&gt; 및 &lt;code&gt;int[5]&lt;/code&gt; 호환된다. 반면에, &lt;code&gt;int&lt;/code&gt; 와 &lt;code&gt;char *&lt;/code&gt; 는 유형이 다르더라도 특정 아키텍처에서 호환되지 않습니다. 또한, 유사성을 결정할 때 포인터 간접의 양이 고려됩니다. 결과적으로 &lt;code&gt;short *&lt;/code&gt; 는 &lt;code&gt;short **&lt;/code&gt; 와 유사하지 않습니다 . 또한 기본 형식이 호환되는 경우 형식 정의 된 두 가지 형식이 호환 가능한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="8f524b48e32ad47b9a83509e089c5a5e1558b871" translate="yes" xml:space="preserve">
          <source>The type of an object with thread storage duration shall not have a non-trivial destructor, nor shall it be an array type whose elements (directly or indirectly) have non-trivial destructors.</source>
          <target state="translated">쓰레드 저장 시간을 갖는 객체의 유형은 사소한 소멸자를 가져서는 안되며, 요소가 (직접 또는 간접적으로) 사소한 소멸자를 갖는 배열 유형이 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c90fc1cb110409689f90a0be940bc7d5911aa3a0" translate="yes" xml:space="preserve">
          <source>The type of these constants follows the same rules as for octal or hexadecimal integer constants, so suffixes like &amp;lsquo;</source>
          <target state="translated">이 상수의 유형은 8 진 또는 16 진 정수 상수와 동일한 규칙을 따르므로 '</target>
        </trans-unit>
        <trans-unit id="3e1c0747061b6e04e40c5232315c9ae3b95fbcea" translate="yes" xml:space="preserve">
          <source>The type specifiers are encoded just before the type. Unlike types however, the type specifiers are only encoded when they appear in method argument types.</source>
          <target state="translated">타입 지정자는 타입 직전에 인코딩됩니다. 그러나 형식과 달리 형식 지정자는 메서드 인수 형식에 나타날 때만 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="235cfb0079f1cae5d7bcfb5a4109668420b1ba20" translate="yes" xml:space="preserve">
          <source>The types are encoded in the following way:</source>
          <target state="translated">유형은 다음과 같은 방식으로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="a29416c27e6f97b9abc061da191be4a6083d70bc" translate="yes" xml:space="preserve">
          <source>The types defined in this manner can be used with a subset of normal C operations. Currently, GCC allows using the following operators on these types: &lt;code&gt;+, -, *, /, unary minus, ^, |, &amp;amp;, ~, %&lt;/code&gt;.</source>
          <target state="translated">이러한 방식으로 정의 된 유형은 정상적인 C 작업의 하위 집합과 함께 사용할 수 있습니다. 현재 GCC에서는 &lt;code&gt;+, -, *, /, unary minus, ^, |, &amp;amp;, ~, %&lt;/code&gt; 유형에서 다음 연산자를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e3fa8117933503d7edf67d6eb175e6d2d580176b" translate="yes" xml:space="preserve">
          <source>The types of long calls used depends on the capabilities of the assembler and linker, and the type of code being generated. The impact on systems that support long absolute calls, and long pic symbol-difference or pc-relative calls should be relatively small. However, an indirect call is used on 32-bit ELF systems in pic code and it is quite long.</source>
          <target state="translated">사용되는 긴 호출 유형은 어셈블러 및 링커의 기능 및 생성되는 코드 유형에 따라 다릅니다. 긴 절대 통화와 긴 그림 기호 차이 또는 PC 기준 통화를 지원하는 시스템에 미치는 영향은 상대적으로 적어야합니다. 그러나 간접 호출은 32 비트 ELF 시스템에서 그림 코드로 사용되며 상당히 길다.</target>
        </trans-unit>
        <trans-unit id="ec5bc88005ecf61d67656c8a050fcb6e58f804f9" translate="yes" xml:space="preserve">
          <source>The types of the specified functions must all be different, but related to each other in the same way as a set of functions that may be selected between by a macro in &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt;. This means that the functions are parameterized by a floating-point type &lt;var&gt;t&lt;/var&gt;, different for each such function. The function return types may all be the same type, or they may be &lt;var&gt;t&lt;/var&gt; for each function, or they may be the real type corresponding to &lt;var&gt;t&lt;/var&gt; for each function (if some of the types &lt;var&gt;t&lt;/var&gt; are complex). Likewise, for each parameter position, the type of the parameter in that position may always be the same type, or may be &lt;var&gt;t&lt;/var&gt; for each function (this case must apply for at least one parameter position), or may be the real type corresponding to &lt;var&gt;t&lt;/var&gt; for each function.</source>
          <target state="translated">지정된 함수의 유형은 모두 달라야하지만 &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt; 의 매크로에 의해 선택 될 수있는 함수 세트와 동일한 방식으로 서로 관련되어야합니다 . 이것은 함수가 각각의 함수마다 다른 부동 소수점 유형 &lt;var&gt;t&lt;/var&gt; 로 매개 변수화됨을 의미합니다 . 함수 반환 형식은 모두 같은 형식이거나 각 함수에 대해 &lt;var&gt;t&lt;/var&gt; 이거나 각 함수에 대해 &lt;var&gt;t&lt;/var&gt; 에 해당하는 실제 형식 일 수 있습니다 (일부 형식 &lt;var&gt;t&lt;/var&gt; 가 복잡한 경우). 마찬가지로 각 매개 변수 위치에 대해 해당 위치의 매개 변수 유형은 항상 동일한 유형이거나 &lt;var&gt;t&lt;/var&gt; 일 수 있습니다.각 함수마다 (이 경우 하나 이상의 매개 변수 위치에 적용되어야 함) 또는 각 함수의 &lt;var&gt;t&lt;/var&gt; 에 해당하는 실제 유형일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="562884deec4ebf19cace230c1d8314c9d6fd11a3" translate="yes" xml:space="preserve">
          <source>The typical use of extended &lt;code&gt;asm&lt;/code&gt; statements is to manipulate input values to produce output values. However, your &lt;code&gt;asm&lt;/code&gt; statements may also produce side effects. If so, you may need to use the &lt;code&gt;volatile&lt;/code&gt; qualifier to disable certain optimizations. See &lt;a href=&quot;#Volatile&quot;&gt;Volatile&lt;/a&gt;.</source>
          <target state="translated">확장 된 &lt;code&gt;asm&lt;/code&gt; 문의 일반적인 사용은 입력 값을 조작하여 출력 값을 생성하는 것입니다. 그러나 &lt;code&gt;asm&lt;/code&gt; 문은 부작용을 일으킬 수도 있습니다. 그렇다면 특정 최적화를 비활성화 하기 위해 &lt;code&gt;volatile&lt;/code&gt; 한정자를 사용해야 할 수도 있습니다 . &lt;a href=&quot;#Volatile&quot;&gt;휘발성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="45e652bb27a2083165bac75933fd850a0641a946" translate="yes" xml:space="preserve">
          <source>The unary plus operator.</source>
          <target state="translated">단항 더하기 연산자.</target>
        </trans-unit>
        <trans-unit id="5b7b641512751385c6d2814d121dfa7956a428c3" translate="yes" xml:space="preserve">
          <source>The underlying type of &lt;code&gt;type&lt;/code&gt;. Requires: &lt;code&gt;type&lt;/code&gt; shall be an enumeration type ([dcl.enum]).</source>
          <target state="translated">기본 유형의 &lt;code&gt;type&lt;/code&gt; 입니다. 필수 : &lt;code&gt;type&lt;/code&gt; 은 열거 형 이어야합니다 ([dcl.enum]).</target>
        </trans-unit>
        <trans-unit id="4c9e93062c090121b29c563680d663f3d3e33b8a" translate="yes" xml:space="preserve">
          <source>The unique value of the member of the execution character set produced for each of the standard alphabetic escape sequences (C90, C99 and C11 5.2.2).</source>
          <target state="translated">각 표준 알파벳 이스케이프 시퀀스 (C90, C99 및 C11 5.2.2)에 대해 생성 된 실행 문자 세트 멤버의 고유 값입니다.</target>
        </trans-unit>
        <trans-unit id="6e9148f286cc806482521d7ebb582ea948e1076d" translate="yes" xml:space="preserve">
          <source>The use of default arguments in function pointers, function typedefs and other places where they are not permitted by the standard is deprecated and will be removed from a future version of G++.</source>
          <target state="translated">함수 포인터, 함수 typedef 및 표준에서 허용하지 않는 다른 위치에서 기본 인수를 사용하는 것은 더 이상 사용되지 않으며 향후 버전의 G ++에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="cb0aac07569b8c035da4f2196d548847237b0a9f" translate="yes" xml:space="preserve">
          <source>The usual calling convention has functions return values of types &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;double&lt;/code&gt; in an FPU register, even if there is no FPU. The idea is that the operating system should emulate an FPU.</source>
          <target state="translated">일반적인 호출 규칙에는 FPU가없는 경우에도 FPU 레지스터에서 &lt;code&gt;float&lt;/code&gt; 및 &lt;code&gt;double&lt;/code&gt; 유형의 값을 반환하는 함수가 있습니다 . 아이디어는 운영 체제가 FPU를 에뮬레이트해야한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ad7784f3ecb2fcf462bcebb606253d24e3e9713b" translate="yes" xml:space="preserve">
          <source>The usual way to run GCC is to run the executable called &lt;code&gt;gcc&lt;/code&gt;, or &lt;code&gt;&lt;var&gt;machine&lt;/var&gt;-gcc&lt;/code&gt; when cross-compiling, or &lt;code&gt;&lt;var&gt;machine&lt;/var&gt;-gcc-&lt;var&gt;version&lt;/var&gt;&lt;/code&gt; to run a specific version of GCC. When you compile C++ programs, you should invoke GCC as &lt;code&gt;g++&lt;/code&gt; instead. See &lt;a href=&quot;invoking-g_002b_002b#Invoking-G_002b_002b&quot;&gt;Compiling C++ Programs&lt;/a&gt;, for information about the differences in behavior between &lt;code&gt;gcc&lt;/code&gt; and &lt;code&gt;g++&lt;/code&gt; when compiling C++ programs.</source>
          <target state="translated">GCC를 실행하는 일반적인 방법은 실행이라는 실행하는 것입니다 &lt;code&gt;gcc&lt;/code&gt; , 또는 &lt;code&gt;&lt;var&gt;machine&lt;/var&gt;-gcc&lt;/code&gt; 크로스 컴파일, 또는 &lt;code&gt;&lt;var&gt;machine&lt;/var&gt;-gcc-&lt;var&gt;version&lt;/var&gt;&lt;/code&gt; GCC의 특정 버전을 실행합니다. C ++ 프로그램을 컴파일 할 때는 대신 GCC를 &lt;code&gt;g++&lt;/code&gt; 로 호출해야 합니다. &lt;a href=&quot;invoking-g_002b_002b#Invoking-G_002b_002b&quot;&gt;C ++ 프로그램을&lt;/a&gt; 컴파일 할 때 &lt;code&gt;gcc&lt;/code&gt; 와 &lt;code&gt;g++&lt;/code&gt; 동작 차이에 대한 정보는 C ++ 프로그램 컴파일을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b063501b645eb4fe8a716599b0b7b68ac7473998" translate="yes" xml:space="preserve">
          <source>The valid memory order variants are &lt;code&gt;__ATOMIC_RELAXED&lt;/code&gt;, &lt;code&gt;__ATOMIC_SEQ_CST&lt;/code&gt;, &lt;code&gt;__ATOMIC_ACQUIRE&lt;/code&gt;, &lt;code&gt;__ATOMIC_RELEASE&lt;/code&gt;, and &lt;code&gt;__ATOMIC_ACQ_REL&lt;/code&gt;.</source>
          <target state="translated">유효한 메모리 순서 변형은 &lt;code&gt;__ATOMIC_RELAXED&lt;/code&gt; , &lt;code&gt;__ATOMIC_SEQ_CST&lt;/code&gt; , &lt;code&gt;__ATOMIC_ACQUIRE&lt;/code&gt; , &lt;code&gt;__ATOMIC_RELEASE&lt;/code&gt; 및 &lt;code&gt;__ATOMIC_ACQ_REL&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6cc836f5cd3d793de6c86ebfa23594977254dab4" translate="yes" xml:space="preserve">
          <source>The valid memory order variants are &lt;code&gt;__ATOMIC_RELAXED&lt;/code&gt;, &lt;code&gt;__ATOMIC_SEQ_CST&lt;/code&gt;, &lt;code&gt;__ATOMIC_ACQUIRE&lt;/code&gt;, and &lt;code&gt;__ATOMIC_CONSUME&lt;/code&gt;.</source>
          <target state="translated">유효한 메모리 순서 변형은 &lt;code&gt;__ATOMIC_RELAXED&lt;/code&gt; , &lt;code&gt;__ATOMIC_SEQ_CST&lt;/code&gt; , &lt;code&gt;__ATOMIC_ACQUIRE&lt;/code&gt; 및 &lt;code&gt;__ATOMIC_CONSUME&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1b387c15b8d7905431f6ee70a72792d2b995cec6" translate="yes" xml:space="preserve">
          <source>The valid memory order variants are &lt;code&gt;__ATOMIC_RELAXED&lt;/code&gt;, &lt;code&gt;__ATOMIC_SEQ_CST&lt;/code&gt;, and &lt;code&gt;__ATOMIC_RELEASE&lt;/code&gt;.</source>
          <target state="translated">유효한 메모리 순서 변형은 &lt;code&gt;__ATOMIC_RELAXED&lt;/code&gt; , &lt;code&gt;__ATOMIC_SEQ_CST&lt;/code&gt; 및 &lt;code&gt;__ATOMIC_RELEASE&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b6608eaa83f451be81718292f24c656e5976df89" translate="yes" xml:space="preserve">
          <source>The value &amp;lsquo;</source>
          <target state="translated">가치 '</target>
        </trans-unit>
        <trans-unit id="9b81b1fa621fe4401621371ef2fb0416c4e7ec83" translate="yes" xml:space="preserve">
          <source>The value &lt;code&gt;branch&lt;/code&gt; tells the compiler to implement checking of validity of control-flow transfer at the point of indirect branch instructions, i.e. call/jmp instructions. The value &lt;code&gt;return&lt;/code&gt; implements checking of validity at the point of returning from a function. The value &lt;code&gt;full&lt;/code&gt; is an alias for specifying both &lt;code&gt;branch&lt;/code&gt; and &lt;code&gt;return&lt;/code&gt;. The value &lt;code&gt;none&lt;/code&gt; turns off instrumentation.</source>
          <target state="translated">값 &lt;code&gt;branch&lt;/code&gt; 는 컴파일러에게 간접 분기 명령어, 즉 호출 / jmp 명령어의 시점에서 제어 흐름 전송의 유효성 검사를 구현하도록 지시합니다. 값 &lt;code&gt;return&lt;/code&gt; 은 함수에서 반환 할 때 유효성 검사를 구현합니다. &lt;code&gt;full&lt;/code&gt; 값 은 &lt;code&gt;branch&lt;/code&gt; 와 &lt;code&gt;return&lt;/code&gt; 을 모두 지정하기위한 별명입니다 . &lt;code&gt;none&lt;/code&gt; 값 은 계측을 끕니다.</target>
        </trans-unit>
        <trans-unit id="cec00d8fc6d0d865baf91db330b98c794be36fbd" translate="yes" xml:space="preserve">
          <source>The value &lt;var&gt;N&lt;/var&gt; can be between 0 and 4. A value of 0 (the default) or 4 means that constants of any size are allowed.</source>
          <target state="translated">값 &lt;var&gt;N&lt;/var&gt; 은 0과 4 사이 일 수 있습니다. 값 0 (기본값) 또는 4는 모든 크기의 상수가 허용됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="bb7289e160f23adf91cfa58505c60106049d9e55" translate="yes" xml:space="preserve">
          <source>The value is as specified in the standard and the type is determined by the ABI.</source>
          <target state="translated">값은 표준에 지정되어 있으며 유형은 ABI에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="da848852806dcfc33f52696b5619522d23c88e8e" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;COMPILER_PATH&lt;/code&gt; is a colon-separated list of directories, much like &lt;code&gt;PATH&lt;/code&gt;. GCC tries the directories thus specified when searching for subprograms, if it cannot find the subprograms using &lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;COMPILER_PATH&lt;/code&gt; 의 값은 &lt;code&gt;PATH&lt;/code&gt; 와 매우 유사하며 콜론으로 구분 된 디렉토리 목록입니다 . &lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt; 를 사용하여 서브 프로그램을 찾을 수없는 경우 GCC는 서브 프로그램을 검색 할 때 지정된 디렉토리를 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="d72005aff0d80d4d1734d968cb3fab8a6e254f4d" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;DEPENDENCIES_OUTPUT&lt;/code&gt; can be just a file name, in which case the Make rules are written to that file, guessing the target name from the source file name. Or the value can have the form &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;DEPENDENCIES_OUTPUT&lt;/code&gt; 의 값은 파일 이름 일 수 있습니다.이 경우 Make 규칙이 해당 파일에 작성되고 소스 파일 이름에서 대상 이름을 추측합니다. 또는 값은 '</target>
        </trans-unit>
        <trans-unit id="edab9250e0babd1761a6140212faa3d4e9be6f54" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;LIBRARY_PATH&lt;/code&gt; is a colon-separated list of directories, much like &lt;code&gt;PATH&lt;/code&gt;. When configured as a native compiler, GCC tries the directories thus specified when searching for special linker files, if it cannot find them using &lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt;. Linking using GCC also uses these directories when searching for ordinary libraries for the</source>
          <target state="translated">&lt;code&gt;LIBRARY_PATH&lt;/code&gt; 의 값은 &lt;code&gt;PATH&lt;/code&gt; 와 매우 유사하며 콜론으로 구분 된 디렉토리 목록입니다 . 네이티브 컴파일러로 구성된 경우 GCC는 &lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt; 를 사용하여 찾을 수없는 경우 특수 링커 파일을 검색 할 때 지정된 디렉토리를 시도합니다 . GCC를 사용하여 연결하면 일반 라이브러리를 검색 할 때이 디렉토리도 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="43d97475c2600c7120869f306bf4b7bed4d2e9bd" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;SOURCE_DATE_EPOCH&lt;/code&gt; must be a UNIX timestamp, defined as the number of seconds (excluding leap seconds) since 01 Jan 1970 00:00:00 represented in ASCII; identical to the output of &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;SOURCE_DATE_EPOCH&lt;/code&gt; 값은 1970 년 1 월 1 일 00:00:00 (ASCII로 표시됨) 이후의 초 수 (윤초 제외)로 정의 된 UNIX 시간 소인이어야합니다. '의 출력과 동일</target>
        </trans-unit>
        <trans-unit id="66e4ba46bd46984b6c4ee052416293525cc2110b" translate="yes" xml:space="preserve">
          <source>The value of &lt;var&gt;addr&lt;/var&gt; is the address of the memory to prefetch. There are two optional arguments, &lt;var&gt;rw&lt;/var&gt; and &lt;var&gt;locality&lt;/var&gt;. The value of &lt;var&gt;rw&lt;/var&gt; is a compile-time constant one or zero; one means that the prefetch is preparing for a write to the memory address and zero, the default, means that the prefetch is preparing for a read. The value &lt;var&gt;locality&lt;/var&gt; must be a compile-time constant integer between zero and three. A value of zero means that the data has no temporal locality, so it need not be left in the cache after the access. A value of three means that the data has a high degree of temporal locality and should be left in all levels of cache possible. Values of one and two mean, respectively, a low or moderate degree of temporal locality. The default is three.</source>
          <target state="translated">&lt;var&gt;addr&lt;/var&gt; 의 값은 프리 페치 할 메모리의 주소입니다. 선택적 인수 인 &lt;var&gt;rw&lt;/var&gt; 및 &lt;var&gt;locality&lt;/var&gt; 가 있습니다 . &lt;var&gt;rw&lt;/var&gt; 의 값은 컴파일 타임 상수 1 또는 0입니다. 하나는 프리 페치가 메모리 주소에 대한 쓰기를 준비 중임을 의미하고, 기본값 인 0은 프리 페치가 읽기를 준비 중임을 의미합니다. 가치 &lt;var&gt;locality&lt;/var&gt; 0에서 3 사이의 컴파일 타임 상수 정수 여야합니다. 값이 0이면 데이터에 시간적 지역성이 없으므로 액세스 후 캐시에 남아있을 필요가 없습니다. 값이 3이면 데이터에 높은 시간적 지역성이 있으며 가능한 모든 수준의 캐시에 남아 있어야합니다. 1과 2의 값은 각각 낮은 또는 중간 정도의 시간적 국소성을 의미합니다. 기본값은 3입니다.</target>
        </trans-unit>
        <trans-unit id="70e11268aef227bb1a15172e67ca65858facec52" translate="yes" xml:space="preserve">
          <source>The value of &lt;var&gt;arguments&lt;/var&gt; should be the value returned by &lt;code&gt;__builtin_apply_args&lt;/code&gt;. The argument &lt;var&gt;size&lt;/var&gt; specifies the size of the stack argument data, in bytes.</source>
          <target state="translated">&lt;var&gt;arguments&lt;/var&gt; 의 값은 &lt;code&gt;__builtin_apply_args&lt;/code&gt; 가 반환 한 값이어야합니다 . 인수 &lt;var&gt;size&lt;/var&gt; 는 스택 인수 데이터의 크기를 바이트 단위로 지정합니다.</target>
        </trans-unit>
        <trans-unit id="e97b2ef46aa7ac364dbf54d200c4936fb0a11aa0" translate="yes" xml:space="preserve">
          <source>The value of a &lt;code&gt;char&lt;/code&gt; object into which has been stored any character other than a member of the basic execution character set (C90 6.1.2.5, C99 and C11 6.2.5).</source>
          <target state="translated">기본 실행 문자 세트 (C90 6.1.2.5, C99 및 C11 6.2.5) 이외의 다른 문자가 저장된 &lt;code&gt;char&lt;/code&gt; 객체 의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="c90677fad3803708fba68301854948c65ad2e0dc" translate="yes" xml:space="preserve">
          <source>The value of a string literal containing a multibyte character or escape sequence not represented in the execution character set (C90 6.1.4, C99 and C11 6.4.5).</source>
          <target state="translated">실행 문자 세트에 표시되지 않은 멀티 바이트 문자 또는 이스케이프 시퀀스를 포함하는 문자열 리터럴 값 (C90 6.1.4, C99 및 C11 6.4.5).</target>
        </trans-unit>
        <trans-unit id="0799bf13992e78d42dd3b2499d660140de9cd663" translate="yes" xml:space="preserve">
          <source>The value of a wide character constant containing more than one multibyte character or a single multibyte character that maps to multiple members of the extended execution character set, or containing a multibyte character or escape sequence not represented in the extended execution character set (C90 6.1.3.4, C99 and C11 6.4.4.4).</source>
          <target state="translated">확장 실행 문자 세트의 여러 멤버에 맵핑되거나 확장 실행 문자 세트에 표시되지 않은 멀티 바이트 문자 또는 이스케이프 시퀀스를 포함하는 둘 이상의 멀티 바이트 문자 또는 단일 멀티 바이트 문자를 포함하는 와이드 문자 상수의 값입니다 (C90 6.1. 3.4, C99 및 C11 6.4.4.4).</target>
        </trans-unit>
        <trans-unit id="2de23bcdd7f53de07c13a72f7ab5e75f0f064b9a" translate="yes" xml:space="preserve">
          <source>The value of an integer character constant containing more than one character or containing a character or escape sequence that does not map to a single-byte execution character (C90 6.1.3.4, C99 and C11 6.4.4.4).</source>
          <target state="translated">둘 이상의 문자를 포함하거나 단일 바이트 실행 문자 (C90 6.1.3.4, C99 및 C11 6.4.4.4)에 맵핑되지 않는 문자 또는 이스케이프 시퀀스를 포함하는 정수 문자 상수의 값입니다.</target>
        </trans-unit>
        <trans-unit id="bddf51b03e8582ac60e5e332485e2f5dfdaadff5" translate="yes" xml:space="preserve">
          <source>The value of the result of the &lt;code&gt;sizeof&lt;/code&gt; and &lt;code&gt;_Alignof&lt;/code&gt; operators (C90 6.3.3.4, C99 and C11 6.5.3.4).</source>
          <target state="translated">&lt;code&gt;sizeof&lt;/code&gt; 및 &lt;code&gt;_Alignof&lt;/code&gt; 연산자 의 결과 값 (C90 6.3.3.4, C99 및 C11 6.5.3.4).</target>
        </trans-unit>
        <trans-unit id="c0b2873e2d72ded9fcc9fee52452da75fb562815" translate="yes" xml:space="preserve">
          <source>The value should be a known timestamp such as the last modification time of the source or package and it should be set by the build process.</source>
          <target state="translated">값은 소스 또는 패키지의 마지막 수정 시간과 같은 알려진 타임 스탬프 여야하며 빌드 프로세스에서 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="e30741bdd1a5b46b18e6720866027b16cbef67a9" translate="yes" xml:space="preserve">
          <source>The values &amp;lsquo;</source>
          <target state="translated">'</target>
        </trans-unit>
        <trans-unit id="0725ef659b65323c744f64d2a18ca8ec4185c000" translate="yes" xml:space="preserve">
          <source>The values of the members of the execution character set (C90, C99 and C11 5.2.1).</source>
          <target state="translated">실행 문자 세트의 멤버 값 (C90, C99 및 C11 5.2.1).</target>
        </trans-unit>
        <trans-unit id="c50dd57103792a97d47d46235c3239eae04dabde" translate="yes" xml:space="preserve">
          <source>The values or expressions assigned to the macros specified in the headers &lt;code&gt;&amp;lt;float.h&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;limits.h&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;stdint.h&amp;gt;&lt;/code&gt; (C90, C99 and C11 5.2.4.2, C99 7.18.2, C99 7.18.3, C11 7.20.2, C11 7.20.3).</source>
          <target state="translated">헤더 &lt;code&gt;&amp;lt;float.h&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;limits.h&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;stdint.h&amp;gt;&lt;/code&gt; (C90, C99 및 C11 5.2.4.2, C99 7.18.2, C99 7.18.3, 헤더에 지정된 매크로에 지정된 값 또는 표현식 C11 7.20.2, C11 7.20.3).</target>
        </trans-unit>
        <trans-unit id="c24e1e6a031d69e73f1ce7f443d81ca980894830" translate="yes" xml:space="preserve">
          <source>The vector type associated with paired-single values is usually called &lt;code&gt;v2sf&lt;/code&gt;. It can be defined in C as follows:</source>
          <target state="translated">단일 쌍의 값과 관련된 벡터 유형을 일반적으로 &lt;code&gt;v2sf&lt;/code&gt; 라고 합니다 . C에서 다음과 같이 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37fd6ea52bde5e4eca142e1cb75092f72771ffd7" translate="yes" xml:space="preserve">
          <source>The virtual registers.</source>
          <target state="translated">가상 레지스터.</target>
        </trans-unit>
        <trans-unit id="72d4e21a353ad4b2c91fcbc017d8cd072d1cc8a4" translate="yes" xml:space="preserve">
          <source>The visibility attribute should be applied only to declarations that would otherwise have external linkage. The attribute should be applied consistently, so that the same entity should not be declared with different settings of the attribute.</source>
          <target state="translated">가시성 속성은 외부 연결이있는 선언에만 적용해야합니다. 동일한 엔티티가 다른 속성 설정으로 선언되지 않도록 속성을 일관되게 적용해야합니다.</target>
        </trans-unit>
        <trans-unit id="dcdff986b782b656015cb9e4191209d1fd6e3439" translate="yes" xml:space="preserve">
          <source>The warning is not issued after a &lt;code&gt;#line&lt;/code&gt; directive, since this typically indicates autogenerated code, and no assumptions can be made about the layout of the file that the directive references.</source>
          <target state="translated">&lt;code&gt;#line&lt;/code&gt; 지시문 뒤에 경고가 표시되지 않습니다. 이는 일반적으로 자동 생성 된 코드를 나타내며 지시문이 참조하는 파일의 레이아웃에 대한 가정은 없습니다.</target>
        </trans-unit>
        <trans-unit id="c1d163df4c56e51212f1f69dc140213a05352c42" translate="yes" xml:space="preserve">
          <source>The warning is not issued for code involving multiline preprocessor logic such as the following example.</source>
          <target state="translated">다음 예와 같은 여러 줄 전 처리기 논리와 관련된 코드에는 경고가 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dcb7b8cd90065f04f3725df949fc5d9c95db8632" translate="yes" xml:space="preserve">
          <source>The warning message for each controllable warning includes the option that controls the warning. That option can then be used with</source>
          <target state="translated">제어 가능한 각 경고에 대한 경고 메시지에는 경고를 제어하는 ​​옵션이 포함됩니다. 그런 다음 해당 옵션을</target>
        </trans-unit>
        <trans-unit id="f1f31ebd493031aa0be9fb191d41eda3a3e18dd4" translate="yes" xml:space="preserve">
          <source>The warnings for missing or incorrect sentinels are enabled with</source>
          <target state="translated">누락되거나 잘못된 센티넬에 대한 경고는</target>
        </trans-unit>
        <trans-unit id="6fb1f41a4e1e0161c8bf4c849af0ffb5ebafd481" translate="yes" xml:space="preserve">
          <source>The way to solve these problems is to put &amp;lsquo;</source>
          <target state="translated">이러한 문제를 해결하는 방법은 '</target>
        </trans-unit>
        <trans-unit id="206a81db22964ace6231b75566fe4c7da1707abe" translate="yes" xml:space="preserve">
          <source>The workarounds for the division errata rely on special functions in</source>
          <target state="translated">분할 정오표의 해결 방법은 다음과 같은 특수 기능에 의존합니다.</target>
        </trans-unit>
        <trans-unit id="3ecc69e9abd77cc6ec0f76d76bb1dccaddb7e950" translate="yes" xml:space="preserve">
          <source>The x86 architecture supports additional memory ordering flags to mark critical sections for hardware lock elision. These must be specified in addition to an existing memory order to atomic intrinsics.</source>
          <target state="translated">x86 아키텍처는 추가 메모리 순서 플래그를 지원하여 하드웨어 잠금 제거를위한 중요 섹션을 표시합니다. 원자 내장 함수에 대한 기존 메모리 순서 외에 이들을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="f94474d9a2fee2945e274919425bc2dedd2ef21c" translate="yes" xml:space="preserve">
          <source>The x86-32 and x86-64 family of processors use additional built-in functions for efficient use of &lt;code&gt;TF&lt;/code&gt; (&lt;code&gt;__float128&lt;/code&gt;) 128-bit floating point and &lt;code&gt;TC&lt;/code&gt; 128-bit complex floating-point values.</source>
          <target state="translated">x86-32 및 x86-64 프로세서 제품군은 추가 내장 함수를 사용하여 &lt;code&gt;TF&lt;/code&gt; ( &lt;code&gt;__float128&lt;/code&gt; ) 128 비트 부동 소수점 및 &lt;code&gt;TC&lt;/code&gt; 128 비트 복합 부동 소수점 값 을 효율적으로 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="d02b4be795b4b009422772986429301880a6ca1d" translate="yes" xml:space="preserve">
          <source>Then use the &lt;code&gt;create_gcov&lt;/code&gt; tool to convert the raw profile data to a format that can be used by GCC. You must also supply the unstripped binary for your program to this tool. See &lt;a href=&quot;https://github.com/google/autofdo&quot;&gt;https://github.com/google/autofdo&lt;/a&gt;.</source>
          <target state="translated">그런 다음 &lt;code&gt;create_gcov&lt;/code&gt; 도구를 사용하여 원시 프로파일 데이터를 GCC에서 사용할 수있는 형식으로 변환하십시오. 또한이 도구에 프로그램의 언 스트라이프 바이너리를 제공해야합니다. &lt;a href=&quot;https://github.com/google/autofdo&quot;&gt;https://github.com/google/autofdo를&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="926b284ef06d8680215f804da3458309f6cd9668" translate="yes" xml:space="preserve">
          <source>Then you can select a label with indexing, like this:</source>
          <target state="translated">그런 다음 색인이있는 레이블을 다음과 같이 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cea728bf3b20beeae36b33c3b1a8dc7982befc50" translate="yes" xml:space="preserve">
          <source>There are 6 different memory orders that can be specified. These map to the C++11 memory orders with the same names, see the C++11 standard or the &lt;a href=&quot;http://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync&quot;&gt;GCC wiki on atomic synchronization&lt;/a&gt; for detailed definitions. Individual targets may also support additional memory orders for use on specific architectures. Refer to the target documentation for details of these.</source>
          <target state="translated">지정할 수있는 6 가지 메모리 순서가 있습니다. 이들은 동일한 이름을 가진 C ++ 11 메모리 순서에 매핑됩니다 . 자세한 정의 &lt;a href=&quot;http://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync&quot;&gt;는 원자 동기화&lt;/a&gt; 에 대한 C ++ 11 표준 또는 GCC 위키를 참조하십시오 . 개별 대상은 특정 아키텍처에서 사용하기 위해 추가 메모리 순서를 지원할 수도 있습니다. 이에 대한 자세한 내용은 대상 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="02f6ba3037fb7689eee8ed8968fd8f0d8ac13840" translate="yes" xml:space="preserve">
          <source>There are also GNU extension functions &lt;code&gt;clog10&lt;/code&gt;, &lt;code&gt;clog10f&lt;/code&gt; and &lt;code&gt;clog10l&lt;/code&gt; which names are reserved by ISO C99 for future use. All these functions have versions prefixed with &lt;code&gt;__builtin_&lt;/code&gt;.</source>
          <target state="translated">GNU 확장 함수 &lt;code&gt;clog10&lt;/code&gt; , &lt;code&gt;clog10f&lt;/code&gt; 및 &lt;code&gt;clog10l&lt;/code&gt; 도 있으며 , 나중에 사용할 수 있도록 ISO C99에서 이름을 예약합니다. 이 모든 함수에는 &lt;code&gt;__builtin_&lt;/code&gt; 접두사가 붙습니다 .</target>
        </trans-unit>
        <trans-unit id="875ce1195c45f2b46d9a99c39e44fd3ec9b5e9cf" translate="yes" xml:space="preserve">
          <source>There are also built-in functions &lt;code&gt;__builtin_fabsf&lt;var&gt;n&lt;/var&gt;&lt;/code&gt;, &lt;code&gt;__builtin_fabsf&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt;, &lt;code&gt;__builtin_copysignf&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; and &lt;code&gt;__builtin_copysignf&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt;, corresponding to the TS 18661-3 functions &lt;code&gt;fabsf&lt;var&gt;n&lt;/var&gt;&lt;/code&gt;, &lt;code&gt;fabsf&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt;, &lt;code&gt;copysignf&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; and &lt;code&gt;copysignf&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt;, for supported types &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; and &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt;.</source>
          <target state="translated">또한 내장되는 기능 &lt;code&gt;__builtin_fabsf&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; , &lt;code&gt;__builtin_fabsf&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; , &lt;code&gt;__builtin_copysignf&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; 및 &lt;code&gt;__builtin_copysignf&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; 는 TS 18661-3 기능에 대응 &lt;code&gt;fabsf&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; , &lt;code&gt;fabsf&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; , &lt;code&gt;copysignf&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; 및 &lt;code&gt;copysignf&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; 지원하는 유형의 &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; 및 &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10087f06f9970243ffcf86e55d1829b3627290b7" translate="yes" xml:space="preserve">
          <source>There are also built-in versions of the ISO C99 functions &lt;code&gt;acosf&lt;/code&gt;, &lt;code&gt;acosl&lt;/code&gt;, &lt;code&gt;asinf&lt;/code&gt;, &lt;code&gt;asinl&lt;/code&gt;, &lt;code&gt;atan2f&lt;/code&gt;, &lt;code&gt;atan2l&lt;/code&gt;, &lt;code&gt;atanf&lt;/code&gt;, &lt;code&gt;atanl&lt;/code&gt;, &lt;code&gt;ceilf&lt;/code&gt;, &lt;code&gt;ceill&lt;/code&gt;, &lt;code&gt;cosf&lt;/code&gt;, &lt;code&gt;coshf&lt;/code&gt;, &lt;code&gt;coshl&lt;/code&gt;, &lt;code&gt;cosl&lt;/code&gt;, &lt;code&gt;expf&lt;/code&gt;, &lt;code&gt;expl&lt;/code&gt;, &lt;code&gt;fabsf&lt;/code&gt;, &lt;code&gt;fabsl&lt;/code&gt;, &lt;code&gt;floorf&lt;/code&gt;, &lt;code&gt;floorl&lt;/code&gt;, &lt;code&gt;fmodf&lt;/code&gt;, &lt;code&gt;fmodl&lt;/code&gt;, &lt;code&gt;frexpf&lt;/code&gt;, &lt;code&gt;frexpl&lt;/code&gt;, &lt;code&gt;ldexpf&lt;/code&gt;, &lt;code&gt;ldexpl&lt;/code&gt;, &lt;code&gt;log10f&lt;/code&gt;, &lt;code&gt;log10l&lt;/code&gt;, &lt;code&gt;logf&lt;/code&gt;, &lt;code&gt;logl&lt;/code&gt;, &lt;code&gt;modfl&lt;/code&gt;, &lt;code&gt;modf&lt;/code&gt;, &lt;code&gt;powf&lt;/code&gt;, &lt;code&gt;powl&lt;/code&gt;, &lt;code&gt;sinf&lt;/code&gt;, &lt;code&gt;sinhf&lt;/code&gt;, &lt;code&gt;sinhl&lt;/code&gt;, &lt;code&gt;sinl&lt;/code&gt;, &lt;code&gt;sqrtf&lt;/code&gt;, &lt;code&gt;sqrtl&lt;/code&gt;, &lt;code&gt;tanf&lt;/code&gt;, &lt;code&gt;tanhf&lt;/code&gt;, &lt;code&gt;tanhl&lt;/code&gt; and &lt;code&gt;tanl&lt;/code&gt; that are recognized in any mode since ISO C90 reserves these names for the purpose to which ISO C99 puts them. All these functions have corresponding versions prefixed with &lt;code&gt;__builtin_&lt;/code&gt;.</source>
          <target state="translated">또한 내장 된 ISO C99 함수의 버전 &lt;code&gt;acosf&lt;/code&gt; , &lt;code&gt;acosl&lt;/code&gt; , &lt;code&gt;asinf&lt;/code&gt; , &lt;code&gt;asinl&lt;/code&gt; , &lt;code&gt;atan2f&lt;/code&gt; , &lt;code&gt;atan2l&lt;/code&gt; , &lt;code&gt;atanf&lt;/code&gt; , &lt;code&gt;atanl&lt;/code&gt; , &lt;code&gt;ceilf&lt;/code&gt; , &lt;code&gt;ceill&lt;/code&gt; , &lt;code&gt;cosf&lt;/code&gt; , &lt;code&gt;coshf&lt;/code&gt; , &lt;code&gt;coshl&lt;/code&gt; , &lt;code&gt;cosl&lt;/code&gt; , &lt;code&gt;expf&lt;/code&gt; , &lt;code&gt;expl&lt;/code&gt; , &lt;code&gt;fabsf&lt;/code&gt; , &lt;code&gt;fabsl&lt;/code&gt; , &lt;code&gt;floorf&lt;/code&gt; , &lt;code&gt;floorl&lt;/code&gt; , &lt;code&gt;fmodf&lt;/code&gt; , &lt;code&gt;fmodl&lt;/code&gt; , &lt;code&gt;frexpf&lt;/code&gt; , &lt;code&gt;frexpl&lt;/code&gt; , &lt;code&gt;ldexpf&lt;/code&gt; , &lt;code&gt;ldexpl&lt;/code&gt; , &lt;code&gt;log10f&lt;/code&gt; , &lt;code&gt;log10l&lt;/code&gt; , &lt;code&gt;logf&lt;/code&gt; , &lt;code&gt;logl&lt;/code&gt; , &lt;code&gt;modfl&lt;/code&gt; , &lt;code&gt;modf&lt;/code&gt; 는 , &lt;code&gt;powf&lt;/code&gt; , &lt;code&gt;powl&lt;/code&gt; , &lt;code&gt;sinf&lt;/code&gt; , &lt;code&gt;sinhf&lt;/code&gt; , &lt;code&gt;sinhl&lt;/code&gt; , &lt;code&gt;sinl&lt;/code&gt; , &lt;code&gt;sqrtf&lt;/code&gt; , &lt;code&gt;sqrtl&lt;/code&gt; , &lt;code&gt;tanf&lt;/code&gt; , &lt;code&gt;tanhf&lt;/code&gt; , &lt;code&gt;tanhl&lt;/code&gt; 및 &lt;code&gt;tanl&lt;/code&gt; ISO C90 예비 보낸 모든 모드에서 인식되는 이러한 이름은 ISO C99에서 사용하기위한 것입니다. 이 모든 기능에는 접두사가 해당하는 버전이 있습니다. &lt;code&gt;__builtin_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e32bac703972f0098c171900bd4cc85df014dde5" translate="yes" xml:space="preserve">
          <source>There are also checking built-in functions for formatted output functions.</source>
          <target state="translated">형식화 된 출력 기능에 대한 내장 기능도 점검합니다.</target>
        </trans-unit>
        <trans-unit id="4f8ad06fe6014524cc57bfacf331d94eea076d2f" translate="yes" xml:space="preserve">
          <source>There are built-in functions added for many common string operation functions, e.g., for &lt;code&gt;memcpy&lt;/code&gt;&lt;code&gt;__builtin___memcpy_chk&lt;/code&gt; built-in is provided. This built-in has an additional last argument, which is the number of bytes remaining in the object the &lt;var&gt;dest&lt;/var&gt; argument points to or &lt;code&gt;(size_t) -1&lt;/code&gt; if the size is not known.</source>
          <target state="translated">예를 들어 &lt;code&gt;memcpy&lt;/code&gt; &lt;code&gt;__builtin___memcpy_chk&lt;/code&gt; 와 같은 많은 일반 문자열 연산 함수에 대해 내장 함수가 추가되었습니다 . 이 내장에는 마지막 인수가 추가되는데,이 인수 는 &lt;var&gt;dest&lt;/var&gt; 인수가 가리키는 객체에 남아있는 바이트 수 또는 크기를 알 수없는 경우 &lt;code&gt;(size_t) -1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e8ecb3f393a336df7fd790409c78fca65366bb71" translate="yes" xml:space="preserve">
          <source>There are four levels of warning supported by GCC. The default is</source>
          <target state="translated">GCC는 4 가지 수준의 경고를 지원합니다. 디폴트는</target>
        </trans-unit>
        <trans-unit id="c5c6335a792caea07ef43ebcfd0dbedc3bba84b4" translate="yes" xml:space="preserve">
          <source>There are four supported &lt;var&gt;visibility_type&lt;/var&gt; values: default, hidden, protected or internal visibility.</source>
          <target state="translated">지원되는 &lt;var&gt;visibility_type&lt;/var&gt; 값은 기본, 숨김, 보호 또는 내부 가시성의 네 가지 입니다.</target>
        </trans-unit>
        <trans-unit id="ce8ba713c06a7d9c57fd70b516918aacdd01bbce" translate="yes" xml:space="preserve">
          <source>There are many more AVR-specific built-in functions that are used to implement the ISO/IEC TR 18037 &amp;ldquo;Embedded C&amp;rdquo; fixed-point functions of section 7.18a.6. You don&amp;rsquo;t need to use these built-ins directly. Instead, use the declarations as supplied by the &lt;code&gt;stdfix.h&lt;/code&gt; header with GNU-C99:</source>
          <target state="translated">7.18a.6 절의 ISO / IEC TR 18037&amp;ldquo;Embedded C&amp;rdquo;고정 소수점 기능을 구현하는 데 사용되는 더 많은 AVR 고유의 내장 기능이 있습니다. 이러한 내장 기능을 직접 사용할 필요는 없습니다. 대신 GNU-C99와 함께 &lt;code&gt;stdfix.h&lt;/code&gt; 헤더에서 제공 한 선언을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="82e7d52ba0a431ff758889d5327a13ddffa9df26" translate="yes" xml:space="preserve">
          <source>There are many other possibilities, limited only by your imagination, good sense, and the constraints of your build system.</source>
          <target state="translated">상상력, 좋은 감각 및 빌드 시스템의 제약 조건에 의해서만 제한되는 다른 많은 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="15ef48c0fb35d807a55378bf489805cb806add15" translate="yes" xml:space="preserve">
          <source>There are other differences between these two methods. Space allocated with &lt;code&gt;alloca&lt;/code&gt; exists until the containing &lt;em&gt;function&lt;/em&gt; returns. The space for a variable-length array is deallocated as soon as the array name&amp;rsquo;s scope ends, unless you also use &lt;code&gt;alloca&lt;/code&gt; in this scope.</source>
          <target state="translated">이 두 방법 사이에는 다른 차이점이 있습니다. &lt;code&gt;alloca&lt;/code&gt; 로 할당 된 공간 은 포함 &lt;em&gt;함수가&lt;/em&gt; 리턴 될 때까지 존재 합니다. 이 범위에서 &lt;code&gt;alloca&lt;/code&gt; 를 사용하지 않는 한 가변 길이 배열의 공간은 배열 이름의 범위가 끝나 자마자 할당이 해제됩니다 .</target>
        </trans-unit>
        <trans-unit id="ec4c204c6335b8fb2d87ba86456a428609cad26b" translate="yes" xml:space="preserve">
          <source>There are several caveats to using the new exception mechanism:</source>
          <target state="translated">새로운 예외 메커니즘을 사용하는 데는 몇 가지주의 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c35ba4e6fe38d832f24909aadf0cb677e0066a30" translate="yes" xml:space="preserve">
          <source>There are several constructs in C++ that require space in the object file but are not clearly tied to a single translation unit. We say that these constructs have &amp;ldquo;vague linkage&amp;rdquo;. Typically such constructs are emitted wherever they are needed, though sometimes we can be more clever.</source>
          <target state="translated">C ++에는 객체 파일에 공간이 필요하지만 단일 번역 단위에 명확하게 묶여 있지 않은 몇 가지 구문이 있습니다. 우리는 이러한 구성이 &quot;모호한 연결&quot;을 가지고 있다고 말합니다. 일반적으로 그러한 구조는 필요할 때마다 방출되지만 때로는 더 영리 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="973e35674df499ab71700555edbe1a93e1641ce5" translate="yes" xml:space="preserve">
          <source>There are several noteworthy incompatibilities between GNU C and K&amp;amp;R (non-ISO) versions of C.</source>
          <target state="translated">GNU C와 K &amp;amp; R (비 ISO) 버전 C 사이에는 주목할만한 비 호환성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f04da83ffcbe77658a4a2fadeea31bbf52a4d35" translate="yes" xml:space="preserve">
          <source>There are several situations in which an application should use the shared</source>
          <target state="translated">응용 프로그램이 공유를 사용해야하는 몇 가지 상황이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7959f13cb983e884f2106a8d8e6aa988bd66a9f9" translate="yes" xml:space="preserve">
          <source>There are some arguments for making bit-fields unsigned by default on all machines. If, for example, this becomes a universal de facto standard, it would make sense for GCC to go along with it. This is something to be considered in the future.</source>
          <target state="translated">모든 컴퓨터에서 기본적으로 비트 필드를 부호없는 것으로 만드는 몇 가지 인수가 있습니다. 예를 들어, 이것이 사실상 사실상의 표준이된다면 GCC가이를 따르는 것이 합리적입니다. 이것은 앞으로 고려해야 할 사항입니다.</target>
        </trans-unit>
        <trans-unit id="451c9c37af0f9094bf98f147452ec7b2c1e8a8be" translate="yes" xml:space="preserve">
          <source>There are some code generation flags preserved by GCC when generating bytecodes, as they need to be used during the final link. Currently, the following options and their settings are taken from the first object file that explicitly specifies them:</source>
          <target state="translated">바이트 코드를 생성 할 때 최종 링크 중에 사용해야하므로 GCC가 유지하는 일부 코드 생성 플래그가 있습니다. 현재 다음 옵션과 해당 설정은 명시 적으로 지정하는 첫 번째 객체 파일에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="d537bfaa9f6c3001fc1a88f5b799ca08bd61a582" translate="yes" xml:space="preserve">
          <source>There are some constraints on how this can be used&amp;mdash;</source>
          <target state="translated">이것을 사용하는 방법에는 몇 가지 제약이 있습니다.</target>
        </trans-unit>
        <trans-unit id="136389e963628b14cbedd792ceed996572d52240" translate="yes" xml:space="preserve">
          <source>There are some problems with the semantics of attributes in C++. For example, there are no manglings for attributes, although they may affect code generation, so problems may arise when attributed types are used in conjunction with templates or overloading. Similarly, &lt;code&gt;typeid&lt;/code&gt; does not distinguish between types with different attributes. Support for attributes in C++ may be restricted in future to attributes on declarations only, but not on nested declarators.</source>
          <target state="translated">C ++의 속성 의미론에는 몇 가지 문제점이 있습니다. 예를 들어, 코드 생성에 영향을 줄 수 있지만 속성에 대한 맹 글링은 없으므로 속성 유형이 템플릿 또는 오버로드와 함께 사용될 때 문제가 발생할 수 있습니다. 마찬가지로 &lt;code&gt;typeid&lt;/code&gt; 는 속성이 다른 유형을 구별하지 않습니다. C ++에서 속성에 대한 지원은 나중에 선언의 속성으로 만 제한 될 수 있지만 중첩 된 선언자에서는 제한되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0a43a1a2abc532264a4772bfd3acfd532a1ab60" translate="yes" xml:space="preserve">
          <source>There are two ways of writing the argument to &lt;code&gt;typeof&lt;/code&gt;: with an expression or with a type. Here is an example with an expression:</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; 에 인수를 작성하는 두 가지 방법이 있습니다 : 표현식 또는 유형. 다음은 표현식이 포함 된 예입니다.</target>
        </trans-unit>
        <trans-unit id="bc25dda9b9f38426b4a5c6b4195fea59e37ab096" translate="yes" xml:space="preserve">
          <source>There is a new runtime function &lt;code&gt;class_ivar_set_gcinvisible()&lt;/code&gt; which can be used to declare a so-called &lt;em&gt;weak pointer&lt;/em&gt; reference. Such a pointer is basically hidden for the garbage collector; this can be useful in certain situations, especially when you want to keep track of the allocated objects, yet allow them to be collected. This kind of pointers can only be members of objects, you cannot declare a global pointer as a weak reference. Every type which is a pointer type can be declared a weak pointer, including &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;Class&lt;/code&gt; and &lt;code&gt;SEL&lt;/code&gt;.</source>
          <target state="translated">소위 &lt;em&gt;약한 포인터&lt;/em&gt; 참조 를 선언하는 데 사용할 수 있는 새로운 런타임 함수 &lt;code&gt;class_ivar_set_gcinvisible()&lt;/code&gt; 이 있습니다 . 이러한 포인터는 기본적으로 가비지 수집기에 숨겨져 있습니다. 이는 특정 상황, 특히 할당 된 객체를 추적하면서 수집 할 수있는 경우에 유용 할 수 있습니다. 이러한 종류의 포인터는 객체의 멤버 만 될 수 있으며 전역 포인터를 약한 참조로 선언 할 수 없습니다. 포인터 유형 인 모든 유형은 &lt;code&gt;id&lt;/code&gt; , &lt;code&gt;Class&lt;/code&gt; 및 &lt;code&gt;SEL&lt;/code&gt; 을 포함하여 약한 포인터로 선언 될 수 있습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6782eab9d50f7c071e99f8fc866abd4eb5cd6fa7" translate="yes" xml:space="preserve">
          <source>There is a proposed representation for view numbers that is not backward compatible with the location list format introduced in DWARF 5, that can be enabled with</source>
          <target state="translated">DWARF 5에 도입 된 위치리스트 형식과 호환되지 않는 뷰 번호에 대한 제안 된 표현이 있습니다.</target>
        </trans-unit>
        <trans-unit id="923e1f4510dc236d985b28a823797fd535b1836b" translate="yes" xml:space="preserve">
          <source>There is no</source>
          <target state="translated">없습니다</target>
        </trans-unit>
        <trans-unit id="29b7356a3e71c6ac7b87a32d1d5d861dca74d15e" translate="yes" xml:space="preserve">
          <source>There is no formal written standard for Objective-C or Objective-C++. The authoritative manual on traditional Objective-C (1.0) is &amp;ldquo;Object-Oriented Programming and the Objective-C Language&amp;rdquo;: &lt;a href=&quot;http://www.gnustep.org/resources/documentation/ObjectivCBook.pdf&quot;&gt;http://www.gnustep.org/resources/documentation/ObjectivCBook.pdf&lt;/a&gt; is the original NeXTstep document.</source>
          <target state="translated">Objective-C 또는 Objective-C ++에 대한 공식적인 서면 표준은 없습니다. 전통적인 Objective-C (1.0)에 대한 권위있는 매뉴얼은&amp;ldquo;객체 지향 프로그래밍과 Objective-C 언어&amp;rdquo;입니다. &lt;a href=&quot;http://www.gnustep.org/resources/documentation/ObjectivCBook.pdf&quot;&gt;http://www.gnustep.org/resources/documentation/ObjectivCBook.pdf&lt;/a&gt; 는 NeXTstep 문서의 원본입니다.</target>
        </trans-unit>
        <trans-unit id="533538e5f5aef48cf028f3ce488b08d6002276fb" translate="yes" xml:space="preserve">
          <source>There is no guarantee (in either the C or the C++ standard language definitions) that the increments will be evaluated in any particular order. Either increment might happen first. &lt;code&gt;func&lt;/code&gt; might get the arguments &amp;lsquo;</source>
          <target state="translated">증분이 특정 순서로 평가 될 것이라는 보장은 없습니다 (C 또는 C ++ 표준 언어 정의). 먼저 증분이 발생할 수 있습니다. &lt;code&gt;func&lt;/code&gt; 은 '</target>
        </trans-unit>
        <trans-unit id="734d8f3426c5c4d551e49ff2012c542f74ef1c08" translate="yes" xml:space="preserve">
          <source>There is no guarantee any transaction ever succeeds, so there always needs to be a valid fallback path.</source>
          <target state="translated">어떤 트랜잭션도 성공한다고 보장 할 수 없으므로 항상 유효한 대체 경로가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="df09188c09c71974483614543b07ff3dea71c626" translate="yes" xml:space="preserve">
          <source>There is no support for nesting dialect alternatives.</source>
          <target state="translated">대체 방언 대체를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7415b415266f5ddf918da08e3399f543c97fb7d5" translate="yes" xml:space="preserve">
          <source>There is no way to split up the contents of a single header file into multiple implementation files.</source>
          <target state="translated">단일 헤더 파일의 내용을 여러 구현 파일로 분할 할 수있는 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="b35fa3005d504f47c5b76912e05a2d94970ddd97" translate="yes" xml:space="preserve">
          <source>There is no way within the template to determine which alternative was chosen. However you may be able to wrap your &lt;code&gt;asm&lt;/code&gt; statements with builtins such as &lt;code&gt;__builtin_constant_p&lt;/code&gt; to achieve the desired results.</source>
          <target state="translated">템플릿 내에서 어떤 대안을 선택했는지 결정할 방법이 없습니다. 그러나 원하는 결과를 얻기 위해 &lt;code&gt;asm&lt;/code&gt; 문을 &lt;code&gt;__builtin_constant_p&lt;/code&gt; 와 같은 내장 으로 래핑 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ae8b54db3c2d81811451aec9ad4c249cf9c17c8b" translate="yes" xml:space="preserve">
          <source>There is some overlap between the purposes of attributes and pragmas (see &lt;a href=&quot;pragmas#Pragmas&quot;&gt;Pragmas Accepted by GCC&lt;/a&gt;). It has been found convenient to use &lt;code&gt;__attribute__&lt;/code&gt; to achieve a natural attachment of attributes to their corresponding declarations, whereas &lt;code&gt;#pragma&lt;/code&gt; is of use for compatibility with other compilers or constructs that do not naturally form part of the grammar.</source>
          <target state="translated">속성과 pragma의 목적이 약간 겹칩니다 ( &lt;a href=&quot;pragmas#Pragmas&quot;&gt;GCC에서 허용되는&lt;/a&gt; pragma 참조 ). &lt;code&gt;__attribute__&lt;/code&gt; 를 사용 하여 해당 선언에 속성을 자연스럽게 첨부하는 것이 편리한 반면, &lt;code&gt;#pragma&lt;/code&gt; 는 문법의 일부를 구성하지 않는 다른 컴파일러 또는 구문과의 호환성에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="07be20761a89905e90146c4650de03345401fe54" translate="yes" xml:space="preserve">
          <source>There may be pitfalls when you use &lt;code&gt;long long&lt;/code&gt; types for function arguments without function prototypes. If a function expects type &lt;code&gt;int&lt;/code&gt; for its argument, and you pass a value of type &lt;code&gt;long long int&lt;/code&gt;, confusion results because the caller and the subroutine disagree about the number of bytes for the argument. Likewise, if the function expects &lt;code&gt;long long int&lt;/code&gt; and you pass &lt;code&gt;int&lt;/code&gt;. The best way to avoid such problems is to use prototypes.</source>
          <target state="translated">함수 프로토 타입이없는 함수 인수에 &lt;code&gt;long long&lt;/code&gt; 유형을 사용하면 함정이있을 수 있습니다 . 함수 가 인수에 대해 &lt;code&gt;int&lt;/code&gt; 유형을 예상하고 &lt;code&gt;long long int&lt;/code&gt; 유형의 값을 전달 하면 호출자와 서브 루틴이 인수의 바이트 수에 대해 동의하지 않기 때문에 혼동이 발생합니다. 함수가 기대하는 경우 마찬가지로, &lt;code&gt;long long int&lt;/code&gt; 하고 통과 &lt;code&gt;int&lt;/code&gt; . 이러한 문제를 피하는 가장 좋은 방법은 프로토 타입을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="4d9628a707838f509cf0a37ebb92916da132e1d6" translate="yes" xml:space="preserve">
          <source>Therefore, the G++ driver automatically adds</source>
          <target state="translated">따라서 G ++ 드라이버는 자동으로 추가합니다</target>
        </trans-unit>
        <trans-unit id="47997e2980ed03d4553af1541dc131cfa6cb91bc" translate="yes" xml:space="preserve">
          <source>Therefore, the expression</source>
          <target state="translated">따라서 표현</target>
        </trans-unit>
        <trans-unit id="6ea5dc6096c9bd173073ecde828a55eabd5d76e4" translate="yes" xml:space="preserve">
          <source>These</source>
          <target state="translated">These</target>
        </trans-unit>
        <trans-unit id="322fe3b4715f9524d383adeb084e8533651edeb7" translate="yes" xml:space="preserve">
          <source>These &amp;lsquo;</source>
          <target state="translated">이 '</target>
        </trans-unit>
        <trans-unit id="cdc6fb4722bc714d5fae1673f7398b196f782701" translate="yes" xml:space="preserve">
          <source>These additional &amp;lsquo;</source>
          <target state="translated">이 추가 '</target>
        </trans-unit>
        <trans-unit id="2dea8e42e0ac78d81c1030a34ffa5859fb43e5e8" translate="yes" xml:space="preserve">
          <source>These additional options are available for Microsoft Windows targets:</source>
          <target state="translated">이러한 추가 옵션은 Microsoft Windows 대상에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="429200a04514f92caf3b4499a491ca222d5caed0" translate="yes" xml:space="preserve">
          <source>These additional options are available on System V Release 4 for compatibility with other compilers on those systems:</source>
          <target state="translated">이러한 추가 옵션은 해당 시스템의 다른 컴파일러와의 호환성을 위해 System V 릴리스 4에서 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="aee4beda520b02d216d51ad833fd44f1904ba2f8" translate="yes" xml:space="preserve">
          <source>These are 16-bit address spaces locating data in section &lt;code&gt;.progmem&lt;var&gt;N&lt;/var&gt;.data&lt;/code&gt; where &lt;var&gt;N&lt;/var&gt; refers to address space &lt;code&gt;__flash&lt;var&gt;N&lt;/var&gt;&lt;/code&gt;. The compiler sets the &lt;code&gt;RAMPZ&lt;/code&gt; segment register appropriately before reading data by means of the &lt;code&gt;ELPM&lt;/code&gt; instruction.</source>
          <target state="translated">이들은 &lt;code&gt;.progmem&lt;var&gt;N&lt;/var&gt;.data&lt;/code&gt; 섹션에서 데이터를 찾는 16 비트 주소 공간입니다. 여기서 &lt;var&gt;N&lt;/var&gt; 은 주소 공간 &lt;code&gt;__flash&lt;var&gt;N&lt;/var&gt;&lt;/code&gt; 나타냅니다 . 컴파일러는 &lt;code&gt;ELPM&lt;/code&gt; 명령어를 사용 하여 데이터를 읽기 전에 &lt;code&gt;RAMPZ&lt;/code&gt; 세그먼트 레지스터를 적절하게 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="9bc1925e612ca94ca27a8264a7444be5df20595d" translate="yes" xml:space="preserve">
          <source>These are aliases for the corresponding</source>
          <target state="translated">이들은 해당 별칭입니다</target>
        </trans-unit>
        <trans-unit id="779c6f17661e07ac4152f7dc676778ae7628f8f4" translate="yes" xml:space="preserve">
          <source>These are listed under See &lt;a href=&quot;rs_002f6000-and-powerpc-options#RS_002f6000-and-PowerPC-Options&quot;&gt;RS/6000 and PowerPC Options&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;rs_002f6000-and-powerpc-options#RS_002f6000-and-PowerPC-Options&quot;&gt;RS / 6000 및 PowerPC 옵션을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ae931926b0b87957b809699bfe98630faaab5aad" translate="yes" xml:space="preserve">
          <source>These are listed under See &lt;a href=&quot;s_002f390-and-zseries-options#S_002f390-and-zSeries-Options&quot;&gt;S/390 and zSeries Options&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;s_002f390-and-zseries-options#S_002f390-and-zSeries-Options&quot;&gt;S / 390 및 zSeries 옵션을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="40acc5623309fbea5623f2aba009e341f97fe7cb" translate="yes" xml:space="preserve">
          <source>These are the &amp;lsquo;</source>
          <target state="translated">이들은 '</target>
        </trans-unit>
        <trans-unit id="25a9625ab38cfd983e37ec2df20ad8c1cd341393" translate="yes" xml:space="preserve">
          <source>These are the options defined for the Altera Nios II processor.</source>
          <target state="translated">Altera Nios II 프로세서에 대해 정의 된 옵션입니다.</target>
        </trans-unit>
        <trans-unit id="ddfdc15ea502fdc771fd53ee7ee413d91e5a491a" translate="yes" xml:space="preserve">
          <source>These are the supported qualifiers:</source>
          <target state="translated">다음은 지원되는 한정자입니다.</target>
        </trans-unit>
        <trans-unit id="3f0f74a8692c7935b66e165ba67cb1a501ff0206" translate="yes" xml:space="preserve">
          <source>These attributes are the same as the MSP430 function attributes of the same name (see &lt;a href=&quot;msp430-function-attributes#MSP430-Function-Attributes&quot;&gt;MSP430 Function Attributes&lt;/a&gt;).</source>
          <target state="translated">이러한 속성은 동일한 이름의 MSP430 기능 속성과 동일합니다 ( &lt;a href=&quot;msp430-function-attributes#MSP430-Function-Attributes&quot;&gt;MSP430 기능 속성&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="ea04fd9aefe63e6f009323195856f23e96723b58" translate="yes" xml:space="preserve">
          <source>These attributes are the same as the MSP430 function attributes of the same name (see &lt;a href=&quot;msp430-function-attributes#MSP430-Function-Attributes&quot;&gt;MSP430 Function Attributes&lt;/a&gt;). These attributes can be applied to both functions and variables.</source>
          <target state="translated">이러한 속성은 동일한 이름의 MSP430 기능 속성과 동일합니다 ( &lt;a href=&quot;msp430-function-attributes#MSP430-Function-Attributes&quot;&gt;MSP430 기능 속성&lt;/a&gt; 참조 ). 이러한 속성은 함수와 변수 모두에 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc9f0c12140351e3fedd51dae4c1164e0be835e5" translate="yes" xml:space="preserve">
          <source>These attributes indicate that the specified function is an interrupt handler. The compiler generates function entry and exit sequences suitable for use in an interrupt handler when this attribute is present.</source>
          <target state="translated">이러한 속성은 지정된 함수가 인터럽트 핸들러임을 나타냅니다. 컴파일러는이 속성이 존재하는 경우 인터럽트 핸들러에 사용하기에 적합한 함수 입력 및 종료 시퀀스를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="90cae17a8377f793b8674b8db0decc44a0b2b0db" translate="yes" xml:space="preserve">
          <source>These attributes indicate that the specified function is an interrupt handler. Use the &lt;code&gt;fast_interrupt&lt;/code&gt; attribute to indicate handlers used in low-latency interrupt mode, and &lt;code&gt;interrupt_handler&lt;/code&gt; for interrupts that do not use low-latency handlers. In both cases, GCC emits appropriate prologue code and generates a return from the handler using &lt;code&gt;rtid&lt;/code&gt; instead of &lt;code&gt;rtsd&lt;/code&gt;.</source>
          <target state="translated">이러한 속성은 지정된 함수가 인터럽트 핸들러임을 나타냅니다. 대기 시간이 짧은 인터럽트 모드에서 사용되는 핸들러를 표시하고 대기 시간이 짧은 핸들러를 사용하지 않는 &lt;code&gt;interrupt_handler&lt;/code&gt; 대해서는 interrupt_handler 를 표시 하려면 &lt;code&gt;fast_interrupt&lt;/code&gt; 속성을 사용하십시오 . 두 경우 모두, 적절한 머리말 GCC 코드를 방출하고 사용 처리기로부터 복귀 생성 &lt;code&gt;rtid&lt;/code&gt; 를 대신 &lt;code&gt;rtsd&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="0f83b1fb8a50c976a446dd169ccf0caf9284a311" translate="yes" xml:space="preserve">
          <source>These attributes override the default chosen by the</source>
          <target state="translated">이러한 속성은</target>
        </trans-unit>
        <trans-unit id="af47925da5d7dad5e220bfdf28a73cd1e09ade04" translate="yes" xml:space="preserve">
          <source>These attributes specify how a particular function is called on MIPS. The attributes override the</source>
          <target state="translated">이러한 속성은 MIPS에서 특정 함수가 호출되는 방식을 지정합니다. 속성은</target>
        </trans-unit>
        <trans-unit id="c245dc24a2c3a655d76f63a05d461d62dfaa1098" translate="yes" xml:space="preserve">
          <source>These attributes specify how a particular function is called. These attributes override the</source>
          <target state="translated">이러한 속성은 특정 함수가 호출되는 방법을 지정합니다. 이러한 속성은</target>
        </trans-unit>
        <trans-unit id="3aa2c83f10183032d2c290e0fbfc5503038ef4f2" translate="yes" xml:space="preserve">
          <source>These built-in functions are available for calling kernel helpers, and they are available depending on the kernel version selected as the CPU.</source>
          <target state="translated">이러한 내장 함수는 커널 도우미 호출에 사용할 수 있으며 CPU로 선택한 커널 버전에 따라 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d2db2e0a6cd3c160ce892077b566038f69a5d12" translate="yes" xml:space="preserve">
          <source>These built-in functions are available for the AArch64 family of processors.</source>
          <target state="translated">이러한 내장 기능은 AArch64 프로세서 제품군에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99ee134b7e3302b89897afcdd306492cac3af896" translate="yes" xml:space="preserve">
          <source>These built-in functions are available for the ARM family of processors when the</source>
          <target state="translated">이러한 내장 함수는 ARM 프로세서 제품군에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2c021905865fa6d163412cd97d22f339e716b63" translate="yes" xml:space="preserve">
          <source>These built-in functions are available for the ARM family of processors with floating-point unit.</source>
          <target state="translated">이러한 내장 함수는 부동 소수점 단위가있는 ARM 프로세서 제품군에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48306035fd811f8d35a44f11213546ba486a0570" translate="yes" xml:space="preserve">
          <source>These built-in functions are available for the Alpha family of processors, depending on the command-line switches used.</source>
          <target state="translated">이러한 내장 기능은 사용 된 명령 행 스위치에 따라 Alpha 계열 프로세서에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b3ba21ab5439a452d301344eaf50af645d462ac" translate="yes" xml:space="preserve">
          <source>These built-in functions are available for the Altera Nios II family of processors.</source>
          <target state="translated">이러한 내장 기능은 Altera Nios II 프로세서 제품군에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89f6765d03c89956e564760cefe25b8258f2acc4" translate="yes" xml:space="preserve">
          <source>These built-in functions are available for the NDS32 target:</source>
          <target state="translated">이러한 내장 기능은 NDS32 대상에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2fccae182b2f224cc802c582d293665235932f6e" translate="yes" xml:space="preserve">
          <source>These built-in functions are available for the x86-32 and x86-64 family of computers, depending on the command-line switches used.</source>
          <target state="translated">이러한 내장 기능은 사용 된 명령 줄 스위치에 따라 x86-32 및 x86-64 컴퓨터 제품군에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74fa1603a77cd22b8b03844382316cb7fce3f487" translate="yes" xml:space="preserve">
          <source>These built-in functions are similar to &lt;code&gt;__builtin_add_overflow&lt;/code&gt;, &lt;code&gt;__builtin_sub_overflow&lt;/code&gt;, or &lt;code&gt;__builtin_mul_overflow&lt;/code&gt;, except that they don&amp;rsquo;t store the result of the arithmetic operation anywhere and the last argument is not a pointer, but some expression with integral type other than enumerated or boolean type.</source>
          <target state="translated">이러한 내장 함수는 &lt;code&gt;__builtin_add_overflow&lt;/code&gt; , &lt;code&gt;__builtin_sub_overflow&lt;/code&gt; 또는 &lt;code&gt;__builtin_mul_overflow&lt;/code&gt; 와 비슷하지만 , 산술 연산의 결과를 어디에나 저장하지 않고 마지막 인수가 포인터가 아니라 열거 형 또는 부울 유형 이외의 정수 유형을 갖는 일부 표현식 .</target>
        </trans-unit>
        <trans-unit id="49cc0a5435c96c360dc8a007e08ab18d83b226a2" translate="yes" xml:space="preserve">
          <source>These built-in functions are similar to the add overflow checking built-in functions above, except they perform multiplication, instead of addition.</source>
          <target state="translated">이러한 내장 함수는 추가 대신 곱셈을 수행한다는 점을 제외하고 위의 추가 오버 플로우 검사 내장 함수와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="60566210b0678cb1c3591a4a16d4062b4b5565ab" translate="yes" xml:space="preserve">
          <source>These built-in functions are similar to the add overflow checking built-in functions above, except they perform subtraction, subtract the second argument from the first one, instead of addition.</source>
          <target state="translated">이 내장 함수는 뺄셈을 수행하고 추가하는 대신 첫 번째 인수에서 두 번째 인수를 빼는 것을 제외하고는 위의 오버 플로우 검사 내장 함수와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="f2854f4ac5cfaad00730f8aa21e163c5b047dff2" translate="yes" xml:space="preserve">
          <source>These built-in functions map to the respective machine instruction, i.e. &lt;code&gt;nop&lt;/code&gt;, &lt;code&gt;sei&lt;/code&gt;, &lt;code&gt;cli&lt;/code&gt;, &lt;code&gt;sleep&lt;/code&gt;, &lt;code&gt;wdr&lt;/code&gt;, &lt;code&gt;swap&lt;/code&gt;, &lt;code&gt;fmul&lt;/code&gt;, &lt;code&gt;fmuls&lt;/code&gt; resp. &lt;code&gt;fmulsu&lt;/code&gt;. The three &lt;code&gt;fmul*&lt;/code&gt; built-ins are implemented as library call if no hardware multiplier is available.</source>
          <target state="translated">이러한 내장 함수는 각각의 기계 명령어, 즉 &lt;code&gt;nop&lt;/code&gt; , &lt;code&gt;sei&lt;/code&gt; , &lt;code&gt;cli&lt;/code&gt; , &lt;code&gt;sleep&lt;/code&gt; , &lt;code&gt;wdr&lt;/code&gt; , &lt;code&gt;swap&lt;/code&gt; , &lt;code&gt;fmul&lt;/code&gt; , &lt;code&gt;fmuls&lt;/code&gt; resp 에 매핑 됩니다. &lt;code&gt;fmulsu&lt;/code&gt; . 사용 가능한 하드웨어 승수가없는 경우 3 개의 &lt;code&gt;fmul*&lt;/code&gt; 내장 기능이 라이브러리 호출로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="b498367f60152015d5067b4b4501b71daee8b167" translate="yes" xml:space="preserve">
          <source>These built-in functions perform an atomic compare and swap. That is, if the current value of &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; is &lt;var&gt;oldval&lt;/var&gt;, then write &lt;var&gt;newval&lt;/var&gt; into &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">이러한 내장 함수는 원자 비교 및 ​​스왑을 수행합니다. 즉, &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; 의 현재 값 이 &lt;var&gt;oldval&lt;/var&gt; 이면 &lt;var&gt;newval&lt;/var&gt; 을 &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; 에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="457d48795ac8a304362adc0940095ddd5561f409" translate="yes" xml:space="preserve">
          <source>These built-in functions perform the operation suggested by the name, and return the new value. That is, operations on integer operands have the following semantics. Operations on pointer operands are performed as if the operand&amp;rsquo;s type were &lt;code&gt;uintptr_t&lt;/code&gt;.</source>
          <target state="translated">이러한 내장 함수는 이름에서 제안한 작업을 수행하고 새 값을 반환합니다. 즉, 정수 피연산자에 대한 연산에는 다음과 같은 의미가 있습니다. 포인터 피연산자에 대한 연산은 피연산자의 유형이 &lt;code&gt;uintptr_t&lt;/code&gt; 인 것처럼 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="c4af2a3302ed8abb6fe6e394796ceea4bd21df1d" translate="yes" xml:space="preserve">
          <source>These built-in functions perform the operation suggested by the name, and return the result of the operation. Operations on pointer arguments are performed as if the operands were of the &lt;code&gt;uintptr_t&lt;/code&gt; type. That is, they are not scaled by the size of the type to which the pointer points.</source>
          <target state="translated">이러한 내장 함수는 이름으로 제안 된 작업을 수행하고 작업 결과를 반환합니다. 피연산자가 &lt;code&gt;uintptr_t&lt;/code&gt; 유형 인 것처럼 포인터 인수에 대한 조작이 수행됩니다 . 즉, 포인터가 가리키는 유형의 크기에 따라 크기가 조정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="79ddce6ba857523eabbfd2cdfa6462c8733df6a0" translate="yes" xml:space="preserve">
          <source>These built-in functions perform the operation suggested by the name, and return the value that had previously been in &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;. Operations on pointer arguments are performed as if the operands were of the &lt;code&gt;uintptr_t&lt;/code&gt; type. That is, they are not scaled by the size of the type to which the pointer points.</source>
          <target state="translated">이 내장 함수는 이름에서 제안한 작업을 수행하고 이전에 &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; 에 있었던 값을 반환합니다 . 피연산자가 &lt;code&gt;uintptr_t&lt;/code&gt; 유형 인 것처럼 포인터 인수에 대한 조작이 수행됩니다 . 즉, 포인터가 가리키는 유형의 크기에 따라 크기가 조정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9d9da03d00f1fd8e4ece7f58ac8080d895ff5310" translate="yes" xml:space="preserve">
          <source>These built-in functions perform the operation suggested by the name, and returns the value that had previously been in memory. That is, operations on integer operands have the following semantics. Operations on pointer arguments are performed as if the operands were of the &lt;code&gt;uintptr_t&lt;/code&gt; type. That is, they are not scaled by the size of the type to which the pointer points.</source>
          <target state="translated">이러한 내장 함수는 이름에서 제안한 작업을 수행하고 이전에 메모리에 있던 값을 반환합니다. 즉, 정수 피연산자에 대한 연산에는 다음과 같은 의미가 있습니다. 피연산자가 &lt;code&gt;uintptr_t&lt;/code&gt; 유형 인 것처럼 포인터 인수에 대한 조작이 수행됩니다 . 즉, 포인터가 가리키는 유형의 크기에 따라 크기가 조정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="55de8240dbd3fc7547da89964b220023f7b63ac6" translate="yes" xml:space="preserve">
          <source>These built-in functions promote the first two operands into infinite precision signed type and perform addition on those promoted operands. The result is then cast to the type the third pointer argument points to and stored there. If the stored result is equal to the infinite precision result, the built-in functions return &lt;code&gt;false&lt;/code&gt;, otherwise they return &lt;code&gt;true&lt;/code&gt;. As the addition is performed in infinite signed precision, these built-in functions have fully defined behavior for all argument values.</source>
          <target state="translated">이 내장 함수는 처음 두 피연산자를 무한 정밀도 부호 유형으로 승격시키고 승격 된 피연산자에 대한 추가를 수행합니다. 그런 다음 결과는 세 번째 포인터 인수가 가리키는 유형으로 캐스트됩니다. 저장된 결과가 무한 정밀도 결과와 같으면 내장 함수가 &lt;code&gt;false&lt;/code&gt; 를 리턴하고 그렇지 않으면 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 덧셈이 무한 부호 정밀도로 수행되므로 이러한 내장 함수는 모든 인수 값에 대해 동작을 완전히 정의했습니다.</target>
        </trans-unit>
        <trans-unit id="889254cac4522dec29d7418673ff86e35bc69fa4" translate="yes" xml:space="preserve">
          <source>These command-line options are defined for PRU target:</source>
          <target state="translated">다음 명령 줄 옵션은 PRU 대상에 대해 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="272a12ae7cc5710c521265d94a65c2d1952b524a" translate="yes" xml:space="preserve">
          <source>These command-line options are defined for RISC-V targets:</source>
          <target state="translated">다음 명령 줄 옵션은 RISC-V 대상에 대해 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="cde559b30a769153d7e8ca70dcc17ecf58e436b4" translate="yes" xml:space="preserve">
          <source>These command-line options are defined for RX targets:</source>
          <target state="translated">이 명령 행 옵션은 RX 대상에 대해 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="51a802ea6adfbbd5a44e165efe9f9442f0fe2c45" translate="yes" xml:space="preserve">
          <source>These considerations mean that it is probably a bad idea to use statement expressions of this form in header files that are designed to work with C++. (Note that some versions of the GNU C Library contained header files using statement expressions that lead to precisely this bug.)</source>
          <target state="translated">이러한 고려 사항은 C ++에서 작동하도록 설계된 헤더 파일에서이 양식의 명령문 표현식을 사용하는 것이 좋지 않다는 것을 의미합니다. (GNU C 라이브러리의 일부 버전에는 정확하게이 버그로 연결되는 명령문 표현식을 사용하는 헤더 파일이 포함되어 있습니다.)</target>
        </trans-unit>
        <trans-unit id="8bb762532560d78d44fe7f3daaea45c8583b0854" translate="yes" xml:space="preserve">
          <source>These constraints are represented as multiple alternatives. An alternative can be described by a series of letters for each operand. The overall constraint for an operand is made from the letters for this operand from the first alternative, a comma, the letters for this operand from the second alternative, a comma, and so on until the last alternative. All operands for a single instruction must have the same number of alternatives.</source>
          <target state="translated">이러한 제약은 여러 대안으로 표현됩니다. 대안은 각 피연산자에 대한 일련의 문자로 설명 할 수 있습니다. 피연산자의 전반적인 제약 조건은 첫 번째 대안의이 피연산자 문자, 쉼표, 두 번째 대안의이 피연산자 문자, 쉼표 등으로 이루어집니다. 단일 명령어에 대한 모든 피연산자에는 동일한 수의 대안이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="38cef76099a34e5010638d4a8b6cdd6e8c967f30" translate="yes" xml:space="preserve">
          <source>These dumps are defined but always produce empty files.</source>
          <target state="translated">이 덤프는 정의되어 있지만 항상 빈 파일을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="dee9b2ccc9b3a342087894f7b0b9e01286328c92" translate="yes" xml:space="preserve">
          <source>These environment variables control the way that GCC uses localization information which allows GCC to work with different national conventions. GCC inspects the locale categories &lt;code&gt;LC_CTYPE&lt;/code&gt; and &lt;code&gt;LC_MESSAGES&lt;/code&gt; if it has been configured to do so. These locale categories can be set to any value supported by your installation. A typical value is &amp;lsquo;</source>
          <target state="translated">이러한 환경 변수는 GCC가 현지화 정보를 사용하는 방식을 제어하여 GCC가 다른 국가 별 규칙을 사용할 수 있도록합니다. GCC는 로케일 범주 &lt;code&gt;LC_CTYPE&lt;/code&gt; 및 &lt;code&gt;LC_MESSAGES&lt;/code&gt; 가 그렇게 구성되어 있는지 검사합니다 . 이 로케일 범주는 설치에서 지원하는 모든 값으로 설정할 수 있습니다. 일반적인 값은 '</target>
        </trans-unit>
        <trans-unit id="a489f50971ce1280d886918f48a3bb50c7a159d8" translate="yes" xml:space="preserve">
          <source>These extensions are also available as built-in functions: see &lt;a href=&quot;x86-built_002din-functions#x86-Built_002din-Functions&quot;&gt;x86 Built-in Functions&lt;/a&gt;, for details of the functions enabled and disabled by these switches.</source>
          <target state="translated">이 확장은 내장 기능으로도 제공됩니다 .이 스위치로 활성화 및 비활성화하는 &lt;a href=&quot;x86-built_002din-functions#x86-Built_002din-Functions&quot;&gt;기능&lt;/a&gt; 에 대한 자세한 내용 은 x86 내장 기능을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8d27c12c180a98e05723ed39f8b22c27ed9edb1c" translate="yes" xml:space="preserve">
          <source>These extensions are available in C and Objective-C. Most of them are also available in C++. See &lt;a href=&quot;c_002b_002b-extensions#C_002b_002b-Extensions&quot;&gt;Extensions to the C++ Language&lt;/a&gt;, for extensions that apply &lt;em&gt;only&lt;/em&gt; to C++.</source>
          <target state="translated">이러한 확장은 C 및 Objective-C로 제공됩니다. 대부분은 C ++로도 제공됩니다. &lt;a href=&quot;c_002b_002b-extensions#C_002b_002b-Extensions&quot;&gt;C ++ &lt;/a&gt;&lt;em&gt;에만&lt;/em&gt; 적용되는 확장에 대해서는 C ++ 언어 확장을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="543b06dcdf13923e1595eba210fefb04ac8d69e6" translate="yes" xml:space="preserve">
          <source>These function attributes are available for H8/300 targets:</source>
          <target state="translated">이 기능 속성은 H8 / 300 대상에 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="bfd06787a8c3016d0f2f433589a9910af31152c9" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the AMD GCN back end:</source>
          <target state="translated">이러한 기능 속성은 AMD GCN 백엔드에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="31d4d22755862f6885158e789fb6bd235507e320" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the ARC back end:</source>
          <target state="translated">이러한 기능 속성은 ARC 백엔드에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="55c618a070b2ba6452534765be65dfbcbd06c924" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the AVR back end:</source>
          <target state="translated">이러한 기능 속성은 AVR 백엔드에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="4000ac271516da07336a51da8c25e0b8f6d448c0" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the Blackfin back end:</source>
          <target state="translated">이 함수 속성은 Blackfin 백엔드에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="4afa11f7ee30e42598bbee2d62763ae6434a6f20" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the C-SKY back end:</source>
          <target state="translated">이러한 기능 속성은 C-SKY 백엔드에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="0b39cd5a4dc8327b896c51c9d022f5933b3f9958" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the CR16 back end:</source>
          <target state="translated">이러한 기능 속성은 CR16 백엔드에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="eec1909818ce8c44d18b66d9f611b39270c8c989" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the Epiphany back end:</source>
          <target state="translated">이 함수 속성은 Epiphany 백엔드에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="ff8d3405ae11a67438cd3ed6cb92d4bcf36611d0" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the M32C back end:</source>
          <target state="translated">이러한 기능 속성은 M32C 백엔드에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="d47de44c955eeba7615b17fd0bd7f27454a04ff3" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the M32R/D back end:</source>
          <target state="translated">이러한 기능 속성은 M32R / D 백엔드에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="ed7b01cf6c9218a3fa99b80d586881bd94ea12ed" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the MCORE back end:</source>
          <target state="translated">이러한 기능 속성은 MCORE 백엔드에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="226e80259699476cba4da72f29c0d2be0439d85d" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the MIPS back end:</source>
          <target state="translated">이러한 기능 속성은 MIPS 백엔드에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="7edfb198d558bea136b268d07a4ee17096f4b111" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the MSP430 back end:</source>
          <target state="translated">이러한 기능 속성은 MSP430 백엔드에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="7afb37f2786a0500cde5b0e77a1405ec0aa689e9" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the MeP back end:</source>
          <target state="translated">이러한 기능 속성은 MeP 백엔드에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="823340689a226c514215ae7cf6199d5c7033ae04" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the NDS32 back end:</source>
          <target state="translated">이러한 기능 속성은 NDS32 백엔드에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="7264e105fd00f62eb30200660903a8276158683f" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the Nios II back end:</source>
          <target state="translated">이러한 함수 속성은 Nios II 백엔드에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="d367738aef5894acaadafa553c801d1b43d3e9d3" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the Nvidia PTX back end:</source>
          <target state="translated">이러한 기능 속성은 Nvidia PTX 백엔드에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="8128fd2ec01bae5154b0679102e4367fb3f53fc5" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the PowerPC back end:</source>
          <target state="translated">이러한 기능 속성은 PowerPC 백엔드에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="923f5bd26a54897b08d5acdad9b09a52e975ce30" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the RISC-V back end:</source>
          <target state="translated">이러한 기능 속성은 RISC-V 백엔드에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="47e5203aed5d0b18481b945b5507d949e4d7c31f" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the RL78 back end:</source>
          <target state="translated">이러한 기능 속성은 RL78 백엔드에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="8f4c53e48bbca37bc1541d4a60d57426dc8a00e7" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the RX back end:</source>
          <target state="translated">이러한 기능 속성은 RX 백엔드에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="d7ce9850ed4dcd80e265a07962ae081b178c8abb" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the SPU back end:</source>
          <target state="translated">이러한 기능 속성은 SPU 백엔드에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="c4ade06aab9acf44e5ce57399ee7881faa6de0a6" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the Visium back end:</source>
          <target state="translated">이러한 기능 속성은 Visium 백엔드에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="ae2ef0b2bdfca9b1c67e94cbe7badc64e01b063f" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the Xstormy16 back end:</source>
          <target state="translated">이러한 기능 속성은 Xstormy16 백엔드에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="e7b7833e42af4f0fe80d613be09a87490ccd7b43" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the m68k back end:</source>
          <target state="translated">이 함수 속성은 m68k 백엔드에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="fe7ac1f444547a0c0a07d6dfab0c75fe5199553c" translate="yes" xml:space="preserve">
          <source>These function attributes are supported by the x86 back end:</source>
          <target state="translated">이 함수 속성은 x86 백엔드에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="5189be0ccd445175d7b77e932fb4808ff6d615fa" translate="yes" xml:space="preserve">
          <source>These function attributes are supported for ARM targets:</source>
          <target state="translated">이러한 함수 속성은 ARM 대상에 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="bbd6ef1a2308a92983d4f92536fdde005890291f" translate="yes" xml:space="preserve">
          <source>These function attributes are supported on IA-64 targets:</source>
          <target state="translated">이러한 기능 속성은 IA-64 대상에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="f64b227810fa6c9b50983f03140d568f7d9fed74" translate="yes" xml:space="preserve">
          <source>These function attributes are supported on MicroBlaze targets:</source>
          <target state="translated">이러한 기능 속성은 MicroBlaze 대상에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="9585f4effc5a2f8970b020be9771782ca105dbb1" translate="yes" xml:space="preserve">
          <source>These function attributes are supported on the S/390:</source>
          <target state="translated">이 기능 속성은 S / 390에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="18888f95dfd62b9fe90e4d6af61fe2ecdcb6ad4f" translate="yes" xml:space="preserve">
          <source>These function attributes are supported on the SH family of processors:</source>
          <target state="translated">이 기능 속성은 SH 계열 프로세서에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="98428d8e4eba9c792163f590881b9a318e73170e" translate="yes" xml:space="preserve">
          <source>These functions are implemented in terms of the &amp;lsquo;</source>
          <target state="translated">이러한 기능은 '</target>
        </trans-unit>
        <trans-unit id="8d57779f821090bd738e90d984c08a5bc5b3499b" translate="yes" xml:space="preserve">
          <source>These functions are intended to replace the legacy &amp;lsquo;</source>
          <target state="translated">이러한 기능은 기존의 '</target>
        </trans-unit>
        <trans-unit id="ad90f9504c295e2f97ffc9946ebca4f6b5d5ccf1" translate="yes" xml:space="preserve">
          <source>These functions compare &lt;var&gt;a&lt;/var&gt; and &lt;var&gt;b&lt;/var&gt; using &lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; and return either the upper or lower half of the result. For example:</source>
          <target state="translated">이 함수 &lt;var&gt;a&lt;/var&gt; &lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; 사용하여 a 와 &lt;var&gt;b&lt;/var&gt; 를 비교 합니다 . &lt;var&gt;cond&lt;/var&gt; .ps를 입력 하고 결과의 상한 또는 하반부를 반환합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="03c7a748fe1ee1ae1b17cfc9b1186d6994642291" translate="yes" xml:space="preserve">
          <source>These functions compare &lt;var&gt;a&lt;/var&gt; and &lt;var&gt;b&lt;/var&gt; using &lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; or &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt;. The &lt;code&gt;any&lt;/code&gt; forms return &lt;code&gt;true&lt;/code&gt; if either result is &lt;code&gt;true&lt;/code&gt; and the &lt;code&gt;all&lt;/code&gt; forms return &lt;code&gt;true&lt;/code&gt; if both results are &lt;code&gt;true&lt;/code&gt;. For example:</source>
          <target state="translated">이 함수 &lt;var&gt;a&lt;/var&gt; &lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; 사용하여 a 와 &lt;var&gt;b&lt;/var&gt; 를 비교 합니다 . &lt;var&gt;cond&lt;/var&gt; .ps 또는 &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; . &lt;code&gt;any&lt;/code&gt; 형태의 반환 &lt;code&gt;true&lt;/code&gt; 중 하나 결과가있는 경우 &lt;code&gt;true&lt;/code&gt; 과 &lt;code&gt;all&lt;/code&gt; 형태의 반환 &lt;code&gt;true&lt;/code&gt; 모두 결과가있는 경우 &lt;code&gt;true&lt;/code&gt; . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c195ff99103a21f524d4637aac5069ea8a395ea9" translate="yes" xml:space="preserve">
          <source>These functions compare &lt;var&gt;a&lt;/var&gt; and &lt;var&gt;b&lt;/var&gt; using &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; and return either the upper or lower half of the result. For example:</source>
          <target state="translated">이 기능은 &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; 사용하여 &lt;var&gt;a&lt;/var&gt; 와 &lt;var&gt;b&lt;/var&gt; 를 비교 합니다 . &lt;var&gt;cond&lt;/var&gt; .ps를 입력 하고 결과의 상한 또는 하반부를 반환합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="46c037085992dbec65501906e5e93cf40d6de82a" translate="yes" xml:space="preserve">
          <source>These functions compare &lt;var&gt;a&lt;/var&gt; and &lt;var&gt;b&lt;/var&gt; using &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.s&lt;/code&gt; or &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.d&lt;/code&gt; and return the result as a boolean value. For example:</source>
          <target state="translated">이 기능은 &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.s&lt;/code&gt; 사용하여 &lt;var&gt;a&lt;/var&gt; 와 &lt;var&gt;b&lt;/var&gt; 를 비교 합니다 . &lt;var&gt;cond&lt;/var&gt; .S 또는 &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.d&lt;/code&gt; 이고 결과를 부울 값으로 반환합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e664732594a1533360445b60577eaf62e517fa5e" translate="yes" xml:space="preserve">
          <source>These functions may be used to get information about the callers of a function.</source>
          <target state="translated">이 함수는 함수 호출자에 대한 정보를 얻는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1dfc3d7d206adff68ce67f88a57319430a6ab850" translate="yes" xml:space="preserve">
          <source>These functions use &lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; or &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; to compare &lt;var&gt;a&lt;/var&gt; with &lt;var&gt;b&lt;/var&gt; and to compare &lt;var&gt;c&lt;/var&gt; with &lt;var&gt;d&lt;/var&gt;. The &lt;code&gt;any&lt;/code&gt; forms return &lt;code&gt;true&lt;/code&gt; if any of the four results are &lt;code&gt;true&lt;/code&gt; and the &lt;code&gt;all&lt;/code&gt; forms return &lt;code&gt;true&lt;/code&gt; if all four results are &lt;code&gt;true&lt;/code&gt;. For example:</source>
          <target state="translated">이 함수는 &lt;code&gt;c.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; 사용 합니다. cond .ps 또는 &lt;code&gt;cabs.&lt;var&gt;cond&lt;/var&gt;.ps&lt;/code&gt; 비교 &lt;var&gt;a&lt;/var&gt; 가진 &lt;var&gt;b&lt;/var&gt; 와 비교하기 위해 &lt;var&gt;c&lt;/var&gt; 가진 &lt;var&gt;d&lt;/var&gt; . &lt;code&gt;any&lt;/code&gt; 형태의 반환 &lt;code&gt;true&lt;/code&gt; 네 개의 결과 중 하나가있는 경우 &lt;code&gt;true&lt;/code&gt; 과 &lt;code&gt;all&lt;/code&gt; 형태의 반환 &lt;code&gt;true&lt;/code&gt; 네 개의 결과가있는 경우 &lt;code&gt;true&lt;/code&gt; . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="93f3cb76d903b1b5ffde931b05d3fa75fc2f5327" translate="yes" xml:space="preserve">
          <source>These hardware transactional memory intrinsics for x86 allow you to use memory transactions with RTM (Restricted Transactional Memory). This support is enabled with the</source>
          <target state="translated">x86 용 하드웨어 트랜잭션 메모리 내장 함수를 사용하면 RTM (제한된 트랜잭션 메모리)과 함께 메모리 트랜잭션을 사용할 수 있습니다. 이 지원은</target>
        </trans-unit>
        <trans-unit id="3b8547b042f5482e49423b8a94ba89797760897f" translate="yes" xml:space="preserve">
          <source>These identifiers are variables, not preprocessor macros, and may not be used to initialize &lt;code&gt;char&lt;/code&gt; arrays or be concatenated with string literals.</source>
          <target state="translated">이러한 식별자는 전 처리기 매크로가 아닌 변수이며 &lt;code&gt;char&lt;/code&gt; 배열 을 초기화 하거나 문자열 리터럴과 연결하는 데 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="d7ada7b6e3845c0a5e68e19752115e91ad7e714e" translate="yes" xml:space="preserve">
          <source>These issues were corrected in</source>
          <target state="translated">이 문제는 다음에서 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="9b9701e15c9d94aa04294acbc1a1a03ddc6872e2" translate="yes" xml:space="preserve">
          <source>These machine-independent options control the interface conventions used in code generation.</source>
          <target state="translated">이러한 머신 독립적 옵션은 코드 생성에 사용되는 인터페이스 규칙을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="1408af6170149b7254d4dd6bcdcfd495ec7436ce" translate="yes" xml:space="preserve">
          <source>These mangling issues were fixed in</source>
          <target state="translated">이 맹 글링 문제는</target>
        </trans-unit>
        <trans-unit id="07b49ceeb21cede5a3a2711e37a7de019bfde35f" translate="yes" xml:space="preserve">
          <source>These memory models are formally defined in Appendix D of the SPARC-V9 architecture manual, as set in the processor&amp;rsquo;s &lt;code&gt;PSTATE.MM&lt;/code&gt; field.</source>
          <target state="translated">이러한 메모리 모델은 프로세서의 &lt;code&gt;PSTATE.MM&lt;/code&gt; 필드에 설정된 SPARC-V9 아키텍처 설명서의 부록 D에 공식적으로 정의되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b1c28027a49e0f9f937405f5f5d9848e5c4e1880" translate="yes" xml:space="preserve">
          <source>These modifiers generate this assembler code:</source>
          <target state="translated">이 수정자는이 어셈블러 코드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="743e02542ccafa4975400ec872a7ad2395932b78" translate="yes" xml:space="preserve">
          <source>These options (&amp;lsquo;</source>
          <target state="translated">이러한 옵션 ( '</target>
        </trans-unit>
        <trans-unit id="4958c6c5d677addc8f58eab0c0d2cf3562ddc1ad" translate="yes" xml:space="preserve">
          <source>These options are defined for AArch64 implementations:</source>
          <target state="translated">이 옵션은 AArch64 구현에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="48d92fc742af2bfa615c74329a584a34db9bd186" translate="yes" xml:space="preserve">
          <source>These options are defined for AVR implementations:</source>
          <target state="translated">이 옵션은 AVR 구현을 위해 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="b2e06ccfcce04ef8518c59faf9fdd99422ee95ce" translate="yes" xml:space="preserve">
          <source>These options are defined for NDS32 implementations:</source>
          <target state="translated">이러한 옵션은 NDS32 구현을 위해 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="5d910c773d7a92c5968f91520cb1c96e846ae694" translate="yes" xml:space="preserve">
          <source>These options are defined for Nvidia PTX:</source>
          <target state="translated">이러한 옵션은 Nvidia PTX에 대해 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="70a11512edb73659010487af7574c61b869ed8dd" translate="yes" xml:space="preserve">
          <source>These options are defined for OpenRISC:</source>
          <target state="translated">이러한 옵션은 OpenRISC에 대해 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="c280d854c3b143f60be7e0eaa4e7170900086fe5" translate="yes" xml:space="preserve">
          <source>These options are defined for Score implementations:</source>
          <target state="translated">이러한 옵션은 점수 구현을 위해 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="3fb4c45c0c5f292728f019e5710497a0ec8817f3" translate="yes" xml:space="preserve">
          <source>These options are defined for Xstormy16:</source>
          <target state="translated">이 옵션은 Xstormy16에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b09b81649730921d2e9ab3de0a2c88ec62a4975" translate="yes" xml:space="preserve">
          <source>These options are defined for all architectures running the Darwin operating system.</source>
          <target state="translated">이 옵션은 Darwin 운영 체제를 실행하는 모든 아키텍처에 대해 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="7cb3b867f983940ea2e4ebd67efa329a40f483ce" translate="yes" xml:space="preserve">
          <source>These options are defined for the MMIX:</source>
          <target state="translated">이 옵션은 MMIX에 대해 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="385fe3117f02cef23e8d723690c0cfc308b93e2c" translate="yes" xml:space="preserve">
          <source>These options are defined for the MSP430:</source>
          <target state="translated">이 옵션은 MSP430에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="adcca40803ff77f8885d53e3bb9902253e5f5f3e" translate="yes" xml:space="preserve">
          <source>These options are defined for the PDP-11:</source>
          <target state="translated">이 옵션은 PDP-11에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9bfa23d8fe1cfc039288a92db83209397de4a2aa" translate="yes" xml:space="preserve">
          <source>These options are defined specifically for the AMD GCN port.</source>
          <target state="translated">이 옵션은 AMD GCN 포트를 위해 특별히 정의되었습니다.</target>
        </trans-unit>
        <trans-unit id="08c86a5f185d6c276d710a46803063b57baac6b5" translate="yes" xml:space="preserve">
          <source>These options are defined specifically for the CR16 ports.</source>
          <target state="translated">이 옵션은 CR16 포트를 위해 특별히 정의되었습니다.</target>
        </trans-unit>
        <trans-unit id="bbab2a1744111610f4ef1fc49ca09af76e7d1a32" translate="yes" xml:space="preserve">
          <source>These options are defined specifically for the CRIS ports.</source>
          <target state="translated">이 옵션은 CRIS 포트를 위해 특별히 정의되었습니다.</target>
        </trans-unit>
        <trans-unit id="9926932fa2a7f92eb437e1b2ac02cd6adfeca6d5" translate="yes" xml:space="preserve">
          <source>These options are defined specifically for the FR30 port.</source>
          <target state="translated">이 옵션은 FR30 포트를 위해 특별히 정의되었습니다.</target>
        </trans-unit>
        <trans-unit id="3dab4ff68a4f656f1c031b134a3ea5a7f3fcf21b" translate="yes" xml:space="preserve">
          <source>These options are defined specifically for the FT32 port.</source>
          <target state="translated">이 옵션은 FT32 포트를 위해 특별히 정의되었습니다.</target>
        </trans-unit>
        <trans-unit id="75c959329e4528f6f7066c03da92ac9a3ae209b8" translate="yes" xml:space="preserve">
          <source>These options are passed down to the linker. They are defined for compatibility with Diab.</source>
          <target state="translated">이러한 옵션은 링커로 전달됩니다. Diab와의 호환성을 위해 정의되었습니다.</target>
        </trans-unit>
        <trans-unit id="514cb6ef588bccc0cfd12c2a6ee53c62e3980343" translate="yes" xml:space="preserve">
          <source>These options are passed to the Darwin linker. The Darwin linker man page describes them in detail.</source>
          <target state="translated">이 옵션은 다윈 링커로 전달됩니다. 다윈 링커 매뉴얼 페이지에서 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="921e998e0a7514666b6cd58d10b556dced0e17ae" translate="yes" xml:space="preserve">
          <source>These options are similar to</source>
          <target state="translated">이 옵션은</target>
        </trans-unit>
        <trans-unit id="c15cb110a025cb053a49b0cc23a8ae49630d084e" translate="yes" xml:space="preserve">
          <source>These options are supported for Xtensa targets:</source>
          <target state="translated">이 옵션은 Xtensa 대상에 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="024672ba12f6533c6267ee5ffbe7b18b0036fae5" translate="yes" xml:space="preserve">
          <source>These options come into play when the compiler links object files into an executable output file. They are meaningless if the compiler is not doing a link step.</source>
          <target state="translated">이 옵션은 컴파일러가 객체 파일을 실행 가능한 출력 파일에 연결할 때 사용됩니다. 컴파일러가 링크 단계를 수행하지 않으면 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="4133c0873f5f47fa3d2f753863bb9a83e1789d05" translate="yes" xml:space="preserve">
          <source>These options control the C preprocessor, which is run on each C source file before actual compilation.</source>
          <target state="translated">이 옵션은 실제 컴파일 전에 각 C 소스 파일에서 실행되는 C 프리 프로세서를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="5ef76ab842e5d74de09c81a688676470bc03ede7" translate="yes" xml:space="preserve">
          <source>These options control the encoding of the special not-a-number (NaN) IEEE 754 floating-point data.</source>
          <target state="translated">이 옵션은 특수 비 숫자 (NaN) IEEE 754 부동 소수점 데이터의 인코딩을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="b6d05ca58952f18a481361248697cafe54bd4e24" translate="yes" xml:space="preserve">
          <source>These options control the treatment of literal pools. The default is</source>
          <target state="translated">이 옵션은 리터럴 풀 처리를 제어합니다. 디폴트는</target>
        </trans-unit>
        <trans-unit id="63f8686ec125e23f83695f3f62c70b1f7e4905ad" translate="yes" xml:space="preserve">
          <source>These options control the treatment of the special not-a-number (NaN) IEEE 754 floating-point data with the &lt;code&gt;abs.&lt;i&gt;fmt&lt;/i&gt;&lt;/code&gt; and &lt;code&gt;neg.&lt;i&gt;fmt&lt;/i&gt;&lt;/code&gt; machine instructions.</source>
          <target state="translated">이 옵션은 &lt;code&gt;abs.&lt;i&gt;fmt&lt;/i&gt;&lt;/code&gt; 를 사용하여 특수 비 숫자 (NaN) IEEE 754 부동 소수점 데이터의 처리를 제어합니다 . &lt;i&gt;fmt&lt;/i&gt; 와 &lt;code&gt;neg.&lt;i&gt;fmt&lt;/i&gt;&lt;/code&gt; 기계 지침.</target>
        </trans-unit>
        <trans-unit id="fe30970c8506c0b34e204983d37e0e48b0b22605" translate="yes" xml:space="preserve">
          <source>These options control various sorts of optimizations.</source>
          <target state="translated">이 옵션은 다양한 종류의 최적화를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="ca73d9226e349bbe9ceb8794e7b1f792d3ed7055" translate="yes" xml:space="preserve">
          <source>These options control warnings about left shift overflows.</source>
          <target state="translated">이 옵션은 왼쪽 시프트 오버플로에 대한 경고를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="8077ddc9c44325d74d2e32e67e952882010bc964" translate="yes" xml:space="preserve">
          <source>These options control whether a bit-field is signed or unsigned, when the declaration does not use either &lt;code&gt;signed&lt;/code&gt; or &lt;code&gt;unsigned&lt;/code&gt;. By default, such a bit-field is signed, because this is consistent: the basic integer types such as &lt;code&gt;int&lt;/code&gt; are signed types.</source>
          <target state="translated">이러한 옵션은 선언에서 &lt;code&gt;signed&lt;/code&gt; 또는 &lt;code&gt;unsigned&lt;/code&gt; 를 사용하지 않을 때 비트 필드에 서명 또는 서명되지 않은지를 제어합니다 . 이러한 비트 필드는 기본적으로 일관성이 있기 때문에 기본적 으로 서명됩니다. &lt;code&gt;int&lt;/code&gt; 와 같은 기본 정수 유형 은 부호가있는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="04984b17ce3993112173c90b978bdade9a561d21" translate="yes" xml:space="preserve">
          <source>These options control which form of branches will be generated. The default is</source>
          <target state="translated">이 옵션들은 생성 될 브랜치 형태를 제어합니다. 디폴트는</target>
        </trans-unit>
        <trans-unit id="75acf55e945580c3df0ebbfbfe506d046bc6e85c" translate="yes" xml:space="preserve">
          <source>These options enable GCC to use these extended instructions in generated code, even without</source>
          <target state="translated">이 옵션을 사용하면 GCC가 생성 된 코드에서 이러한 확장 명령어를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7fd9ac7bed816cccc6942a8d8998c84e682fcba" translate="yes" xml:space="preserve">
          <source>These options enable dumping after five rounds of instruction splitting.</source>
          <target state="translated">이 옵션을 사용하면 5 라운드의 명령 분할 후 덤프가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="b5b2a58223d63058f35e9cfc3fe268fbe52e4e8c" translate="yes" xml:space="preserve">
          <source>These options have no effect unless GCC is generating position independent code.</source>
          <target state="translated">이 옵션은 GCC가 위치 독립적 코드를 생성하지 않는 한 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="0d11fb15204ab5a9c7be14b9ed2aaeffe527ddd6" translate="yes" xml:space="preserve">
          <source>These options have no effect unless GCC is generating position-independent code.</source>
          <target state="translated">GCC가 위치 독립적 인 코드를 생성하지 않는 한 이러한 옵션은 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="32e82c10f4ef0470986d8f101c75c3deb8c3bb8b" translate="yes" xml:space="preserve">
          <source>These options specify directories to search for header files, for libraries and for parts of the compiler:</source>
          <target state="translated">이 옵션은 헤더 파일, 라이브러리 및 컴파일러의 일부를 검색 할 디렉토리를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="e76a02704dc0e3839f8323b052aabfba6ae282f0" translate="yes" xml:space="preserve">
          <source>These options tell the compiler where to place functions and data that do not have one of the &lt;code&gt;lower&lt;/code&gt;, &lt;code&gt;upper&lt;/code&gt;, &lt;code&gt;either&lt;/code&gt; or &lt;code&gt;section&lt;/code&gt; attributes. Possible values are &lt;code&gt;lower&lt;/code&gt;, &lt;code&gt;upper&lt;/code&gt;, &lt;code&gt;either&lt;/code&gt; or &lt;code&gt;any&lt;/code&gt;. The first three behave like the corresponding attribute. The fourth possible value - &lt;code&gt;any&lt;/code&gt; - is the default. It leaves placement entirely up to the linker script and how it assigns the standard sections (&lt;code&gt;.text&lt;/code&gt;, &lt;code&gt;.data&lt;/code&gt;, etc) to the memory regions.</source>
          <target state="translated">이러한 옵션은 컴파일러에 &lt;code&gt;lower&lt;/code&gt; , &lt;code&gt;upper&lt;/code&gt; , 또는 &lt;code&gt;section&lt;/code&gt; 속성 &lt;code&gt;either&lt;/code&gt; 하나가없는 함수 및 데이터를 배치 할 위치를 알려줍니다 . 가능한 값은 &lt;code&gt;lower&lt;/code&gt; , &lt;code&gt;upper&lt;/code&gt; , &lt;code&gt;either&lt;/code&gt; 또는 &lt;code&gt;any&lt;/code&gt; . 처음 세 개는 해당 속성처럼 동작합니다. 네 번째 가능한 값인 &lt;code&gt;any&lt;/code&gt; 가 기본값입니다. 그것은 링커 스크립트에 전적으로 배치하고 표준 섹션 ( &lt;code&gt;.text&lt;/code&gt; , &lt;code&gt;.data&lt;/code&gt; 등)을 메모리 영역에 할당하는 방법을 남깁니다 .</target>
        </trans-unit>
        <trans-unit id="e0b73ff2eada76f8ac9ebd9981af9354d96c99aa" translate="yes" xml:space="preserve">
          <source>These pragmas maintain a stack of the current target and optimization options. It is intended for include files where you temporarily want to switch to using a different &amp;lsquo;</source>
          <target state="translated">이 pragma는 현재 대상 및 최적화 옵션의 스택을 유지합니다. 일시적으로 다른 '</target>
        </trans-unit>
        <trans-unit id="603f3636cf78ad4d753498b11957f65672ebe2cb" translate="yes" xml:space="preserve">
          <source>These problems are perhaps regrettable, but we don&amp;rsquo;t know any practical way around them.</source>
          <target state="translated">이러한 문제는 후회할 수 있지만 실제 문제는 없습니다.</target>
        </trans-unit>
        <trans-unit id="65b9fcf5c8f8750409b0be6384fa9bc28cb10f52" translate="yes" xml:space="preserve">
          <source>These programs work properly with GNU C++ if &lt;code&gt;__STDC__&lt;/code&gt; is defined. They would not work otherwise.</source>
          <target state="translated">&lt;code&gt;__STDC__&lt;/code&gt; 가 정의 된 경우 이러한 프로그램은 GNU C ++에서 올바르게 작동 합니다. 그렇지 않으면 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8668b2099e0b980048c9ff0d8e19c4e25e485197" translate="yes" xml:space="preserve">
          <source>These pseudo types are not defined by GCC, they are simply a notational convenience used in this manual.</source>
          <target state="translated">이러한 의사 유형은 GCC에 의해 정의되지 않으며이 매뉴얼에서 사용 된 표기법의 편의성입니다.</target>
        </trans-unit>
        <trans-unit id="f405633d47d5e6bb41585f2bd9ddbfca800a1d10" translate="yes" xml:space="preserve">
          <source>These restrictions exist because the storage order attribute is lost when the address of a scalar or the address of an array with scalar component is taken, so storing indirectly through this address generally does not work. The second case is nevertheless allowed to be able to perform a block copy from or to the array.</source>
          <target state="translated">스칼라의 주소 또는 스칼라 구성 요소가있는 배열의 주소를 가져올 때 스토리지 순서 속성이 유실되므로 이러한 제한 사항이 존재하므로이 주소를 통해 간접적으로 저장하는 것은 일반적으로 작동하지 않습니다. 그럼에도 불구하고 두 번째 경우는 어레이로부터 또는 어레이로 블록 복사를 수행 할 수있다.</target>
        </trans-unit>
        <trans-unit id="617ec4855cb2c9a651bfd784a1ec34d6b14a3c49" translate="yes" xml:space="preserve">
          <source>These switches are supported in addition to the above on Solaris 2:</source>
          <target state="translated">이러한 스위치는 Solaris 2에서 위의 기능 외에도 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="bc8a75785b95174e69ab84ca725881f92373e1de" translate="yes" xml:space="preserve">
          <source>These switches control the size of &lt;code&gt;long double&lt;/code&gt; type. A size of 64 bits makes the &lt;code&gt;long double&lt;/code&gt; type equivalent to the &lt;code&gt;double&lt;/code&gt; type. This is the default for 32-bit Bionic C library. A size of 128 bits makes the &lt;code&gt;long double&lt;/code&gt; type equivalent to the &lt;code&gt;__float128&lt;/code&gt; type. This is the default for 64-bit Bionic C library.</source>
          <target state="translated">이 스위치는 &lt;code&gt;long double&lt;/code&gt; 유형 의 크기를 제어합니다 . 64 비트의 크기는하게 &lt;code&gt;long double&lt;/code&gt; 받는 형 등가 &lt;code&gt;double&lt;/code&gt; 종류. 32 비트 Bionic C 라이브러리의 기본값입니다. 128 비트의 크기는 &lt;code&gt;long double&lt;/code&gt; 유형을 &lt;code&gt;__float128&lt;/code&gt; 유형 과 동일 하게 만듭니다 . 64 비트 Bionic C 라이브러리의 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="ee4c72bd4a51cef29e53fde4cebb62a0cdc42ecb" translate="yes" xml:space="preserve">
          <source>These switches control the size of &lt;code&gt;long double&lt;/code&gt; type. A size of 64 bits makes the &lt;code&gt;long double&lt;/code&gt; type equivalent to the &lt;code&gt;double&lt;/code&gt; type. This is the default.</source>
          <target state="translated">이 스위치는 &lt;code&gt;long double&lt;/code&gt; 유형 의 크기를 제어합니다 . 64 비트의 크기는하게 &lt;code&gt;long double&lt;/code&gt; 받는 형 등가 &lt;code&gt;double&lt;/code&gt; 종류. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="cfe1fb390a0357110cca04fd8837b1f7aac6050f" translate="yes" xml:space="preserve">
          <source>These switches control the size of &lt;code&gt;long double&lt;/code&gt; type. The x86-32 application binary interface specifies the size to be 96 bits, so</source>
          <target state="translated">이 스위치는 &lt;code&gt;long double&lt;/code&gt; 유형 의 크기를 제어합니다 . x86-32 응용 프로그램 이진 인터페이스는 크기를 96 비트로 지정하므로</target>
        </trans-unit>
        <trans-unit id="10e0a73d40a50d884864ada5af6042c707554338" translate="yes" xml:space="preserve">
          <source>These switches enable the use of instructions in the MMX, SSE, SSE2, SSE3, SSSE3, SSE4, SSE4A, SSE4.1, SSE4.2, AVX, AVX2, AVX512F, AVX512PF, AVX512ER, AVX512CD, AVX512VL, AVX512BW, AVX512DQ, AVX512IFMA, AVX512VBMI, SHA, AES, PCLMUL, CLFLUSHOPT, CLWB, FSGSBASE, PTWRITE, RDRND, F16C, FMA, PCONFIG, WBNOINVD, FMA4, PREFETCHW, RDPID, PREFETCHWT1, RDSEED, SGX, XOP, LWP, 3DNow!, enhanced 3DNow!, POPCNT, ABM, ADX, BMI, BMI2, LZCNT, FXSR, XSAVE, XSAVEOPT, XSAVEC, XSAVES, RTM, HLE, TBM, MWAITX, CLZERO, PKU, AVX512VBMI2, GFNI, VAES, WAITPKG, VPCLMULQDQ, AVX512BITALG, MOVDIRI, MOVDIR64B, AVX512BF16, ENQCMD, AVX512VPOPCNTDQ, AVX5124FMAPS, AVX512VNNI, AVX5124VNNIW, or CLDEMOTE extended instruction sets. Each has a corresponding</source>
          <target state="translated">이러한 스위치를 사용하면 MMX, SSE, SSE2, SSE3, SSSE3, SSE4, SSE4A, SSE4.1, SSE4.2, AVX, AVX2, AVX512F, AVX512PF, AVX512ER, AVX512CD, AVX512VL, AVX512BW, AVX512DQ, AVX512IFMA에서 명령어를 사용할 수 있습니다. , AVX512VBMI, SHA, AES, PCLMUL, CLFLUSHOPT, CLWB, FSGSBASE, PTWRITE, RDRND, F16C, FMA, PCONFIG, WBNOINVD, FMA4, PREFETCHW, RDPID, PREFETCHWT1, RDSEED, SGX, XOP, LWP, 3DNow !, 향상된 3DNow !, XOP, LWP, 3DNow! POPCNT, ABM, ADX, BMI, BMI2, LZCNT, FXSR, XSAVE, XSAVEOPT, XSAVEC, XSAVES, RTM, HLE, TBM, MWAITX, CLZERO, PKU, AVX512VBMI2, GFNI, VAES, WAITPKG, VPCLMDIRQDQ, AVX512BITALG, MOVDIRI AVX512BF16, ENQCMD, AVX512VPOPCNTDQ, AVX5124FMAPS, AVX512VNNI, AVX5124VNNIW 또는 CLDEMOTE 확장 명령어 세트. 각각 해당</target>
        </trans-unit>
        <trans-unit id="c7348ef4aa27c2888870c0a37711f33df4fe6ef4" translate="yes" xml:space="preserve">
          <source>These switches enable the use of instructions in the MMX, SSE, SSE2, SSE3, SSSE3, SSE4, SSE4A, SSE4.1, SSE4.2, AVX, AVX2, AVX512F, AVX512PF, AVX512ER, AVX512CD, AVX512VL, AVX512BW, AVX512DQ, AVX512IFMA, AVX512VBMI, SHA, AES, PCLMUL, CLFLUSHOPT, CLWB, FSGSBASE, PTWRITE, RDRND, F16C, FMA, PCONFIG, WBNOINVD, FMA4, PREFETCHW, RDPID, PREFETCHWT1, RDSEED, SGX, XOP, LWP, 3DNow!, enhanced 3DNow!, POPCNT, ABM, ADX, BMI, BMI2, LZCNT, FXSR, XSAVE, XSAVEOPT, XSAVEC, XSAVES, RTM, HLE, TBM, MWAITX, CLZERO, PKU, AVX512VBMI2, GFNI, VAES, WAITPKG, VPCLMULQDQ, AVX512BITALG, MOVDIRI, MOVDIR64B, AVX512VPOPCNTDQ, AVX5124FMAPS, AVX512VNNI, AVX5124VNNIW, or CLDEMOTE extended instruction sets. Each has a corresponding</source>
          <target state="translated">이 스위치를 사용하면 MMX, SSE, SSE2, SSE3, SSSE3, SSE4, SSE4A, SSE4.1, SSE4.2, AVX, AVX2, AVX512F, AVX512PF, AVX512ER, AVX512CD, AVX512VL, AVX512BW, AVX512DQ, AVX512DQ, AVX512DQ, AVX512DQ, AVX512DQ, AVX512DQ, AVX512DQ, AVX512DQ, AVX512DQ, AVX512DQ, 명령 , AVX512VBMI, SHA, AES, PCLMUL, CLFLUSHOPT, CLWB, FSGSBASE, PTWRITE, RDRND, F16C, FMA, PCONFIG, WBNOINVD, FMA4, PREFETCHW, RDPID, PREFETCHWT1, RDSEED, SGX, XOP, LWP, 3DNow! POPCNT, ABM, ADX, BMI, BMI2, LZCNT, FXSR, XSAVE, XSAVEOPT, XSAVEC, XSAVES, RTM, HLE, TBM, MWAITX, CLZERO, PKU, AVX512VBMI2, GFNI, VAES, WAITPKG, VPCLMULQDQ, AVX512BITALDIR AVX512VPOPCNTDQ, AVX5124FMAPS, AVX512VNNI, AVX5124VNNIW 또는 CLDEMOTE 확장 명령어 세트. 각각 해당하는</target>
        </trans-unit>
        <trans-unit id="cf9495d6f00684499ee4c826615f4071694dd898" translate="yes" xml:space="preserve">
          <source>These types can be used to define 128-bit variables. The built-in functions listed in the following section can be used on these variables to generate the vector operations.</source>
          <target state="translated">이 유형은 128 비트 변수를 정의하는 데 사용할 수 있습니다. 다음 섹션에 나열된 내장 함수를 사용하여 벡터 연산을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e668693b38e6c57f5102ee95a3e05249f7244a77" translate="yes" xml:space="preserve">
          <source>These usages are only permitted when they are not ambiguous.</source>
          <target state="translated">이러한 사용법은 모호하지 않은 경우에만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="5f38a05c071c60c51e986980de83378738afc905" translate="yes" xml:space="preserve">
          <source>These variable attributes are available for H8/300 targets:</source>
          <target state="translated">이 변수 속성은 H8 / 300 대상에 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="241d1accd4905e80f5a34fe3dc64f1b3deee21e2" translate="yes" xml:space="preserve">
          <source>These variable attributes are supported by the Nvidia PTX back end:</source>
          <target state="translated">이러한 변수 속성은 Nvidia PTX 백엔드에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="f806a524d1696f92091d57f9cf53c9146e9a15bf" translate="yes" xml:space="preserve">
          <source>These variable attributes are supported by the V850 back end:</source>
          <target state="translated">이 변수 속성은 V850 백엔드에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="e1ed20f7dd8c240bdd89fa6c4be557443a983d56" translate="yes" xml:space="preserve">
          <source>These warnings are enabled by default.</source>
          <target state="translated">이러한 경고는 기본적으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="b949d9fe4918e4b913002b1484d0c6602fa25eb3" translate="yes" xml:space="preserve">
          <source>These warnings are harmless and can be safely ignored.</source>
          <target state="translated">이 경고는 무해하며 무시해도됩니다.</target>
        </trans-unit>
        <trans-unit id="e451fc6c4b4d61a1351149a72dc14d1a6505cb95" translate="yes" xml:space="preserve">
          <source>These warnings are made optional because GCC may not be able to determine when the code is correct in spite of appearing to have an error. Here is one example of how this can happen:</source>
          <target state="translated">이러한 경고는 GCC가 오류가있는 것처럼 보이지만 코드가 정확한시기를 판단하지 못할 수 있으므로 선택 사항입니다. 이러한 일이 발생할 수있는 방법의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="94e18fe51f3f4e2e5c1a093907e436f1a7eab080" translate="yes" xml:space="preserve">
          <source>These warnings are only possible in optimizing compilation, because otherwise GCC does not keep track of the state of variables.</source>
          <target state="translated">이러한 경고는 컴파일 최적화에서만 가능합니다. 그렇지 않으면 GCC가 변수 상태를 추적하지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="e68200a8afffeb4dc68ba2a9ef927363c09a49e9" translate="yes" xml:space="preserve">
          <source>These warnings occur for individual uninitialized elements of structure, union or array variables as well as for variables that are uninitialized as a whole. They do not occur for variables or elements declared &lt;code&gt;volatile&lt;/code&gt;. Because these warnings depend on optimization, the exact variables or elements for which there are warnings depend on the precise optimization options and version of GCC used.</source>
          <target state="translated">이러한 경고는 구조, 공용체 또는 배열 변수의 초기화되지 않은 개별 요소뿐만 아니라 전체적으로 초기화되지 않은 변수에 대해 발생합니다. &lt;code&gt;volatile&lt;/code&gt; 로 선언 된 변수 또는 요소에는 발생하지 않습니다 . 이러한 경고는 최적화에 따라 다르기 때문에 경고가있는 정확한 변수 또는 요소는 사용 된 GCC의 정확한 최적화 옵션 및 버전에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="e773c8b72ecdbdff1f92adf539e992bd54211f66" translate="yes" xml:space="preserve">
          <source>These warnings occur for individual uninitialized or clobbered elements of structure, union or array variables as well as for variables that are uninitialized or clobbered as a whole. They do not occur for variables or elements declared &lt;code&gt;volatile&lt;/code&gt;. Because these warnings depend on optimization, the exact variables or elements for which there are warnings depends on the precise optimization options and version of GCC used.</source>
          <target state="translated">이러한 경고는 초기화되지 않았거나 전체적으로 초기화되지 않은 변수뿐만 아니라 구조, 공용체 또는 배열 변수의 개별 초기화되지 않거나 클로버 된 요소에 대해 발생합니다. &lt;code&gt;volatile&lt;/code&gt; 선언 된 변수 또는 요소에는 발생하지 않습니다 . 이러한 경고는 최적화에 따라 다르므로 경고가있는 정확한 변수 또는 요소는 정확한 최적화 옵션 및 사용 된 GCC 버전에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="54f2498a22474b067e488cbcf73df92835b4dcbc" translate="yes" xml:space="preserve">
          <source>Things we think are right, but some others disagree.</source>
          <target state="translated">우리가 옳다고 생각하지만 다른 사람들은 동의하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1997b0ca2cbaa31341990ddcffc48330394de3bf" translate="yes" xml:space="preserve">
          <source>Things will disappear from G++.</source>
          <target state="translated">G ++에서 상황이 사라집니다.</target>
        </trans-unit>
        <trans-unit id="c779d1bd661026f38150c16245e1a66cae977330" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;asm&lt;/code&gt; takes one input, which is internally popped, and produces two outputs.</source>
          <target state="translated">이 &lt;code&gt;asm&lt;/code&gt; 은 하나의 입력을 가져 와서 내부적으로 팝되며 두 개의 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="7ea744591db59b72a57a82ebc78f06c0a9beaefd" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;asm&lt;/code&gt; takes two inputs, which are popped by the &lt;code&gt;fyl2xp1&lt;/code&gt; opcode, and replaces them with one output. The &lt;code&gt;st(1)&lt;/code&gt; clobber is necessary for the compiler to know that &lt;code&gt;fyl2xp1&lt;/code&gt; pops both inputs.</source>
          <target state="translated">이 &lt;code&gt;asm&lt;/code&gt; 은 &lt;code&gt;fyl2xp1&lt;/code&gt; opcode에 의해 두 개의 입력을 가져 와서 하나의 출력으로 대체합니다. &lt;code&gt;st(1)&lt;/code&gt; 컴파일러가 알고에 대한 소지품이 필요 &lt;code&gt;fyl2xp1&lt;/code&gt; 는 두 입력을 나타납니다.</target>
        </trans-unit>
        <trans-unit id="49059cf2744a33f2c89b82b703d94b0c5663c6e8" translate="yes" xml:space="preserve">
          <source>This IA-64 HP-UX attribute, attached to a global variable or function, renames a symbol to contain a version string, thus allowing for function level versioning. HP-UX system header files may use function level versioning for some system calls.</source>
          <target state="translated">글로벌 변수 또는 함수에 첨부 된이 IA-64 HP-UX 속성은 심볼의 이름을 변경하여 버전 문자열을 포함하므로 함수 레벨 버전 관리가 가능합니다. HP-UX 시스템 헤더 파일은 일부 시스템 호출에 대해 기능 수준 버전 관리를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="241afcfcf7826d27f6d46a14ffc5e97907ebd792" translate="yes" xml:space="preserve">
          <source>This ISA is implemented by the minimal AVR core and supported for assembler only. &lt;var&gt;mcu&lt;/var&gt; = &lt;code&gt;attiny11&lt;/code&gt;, &lt;code&gt;attiny12&lt;/code&gt;, &lt;code&gt;attiny15&lt;/code&gt;, &lt;code&gt;attiny28&lt;/code&gt;, &lt;code&gt;at90s1200&lt;/code&gt;.</source>
          <target state="translated">이 ISA는 최소 AVR 코어로 구현되며 어셈블러에서만 지원됩니다. &lt;var&gt;mcu&lt;/var&gt; = &lt;code&gt;attiny11&lt;/code&gt; , &lt;code&gt;attiny12&lt;/code&gt; , &lt;code&gt;attiny15&lt;/code&gt; , &lt;code&gt;attiny28&lt;/code&gt; , &lt;code&gt;at90s1200&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7707ff43d31f77dd6414b616a64487e73ac2f610" translate="yes" xml:space="preserve">
          <source>This RX attribute is similar to the &lt;code&gt;interrupt&lt;/code&gt; attribute, including its parameters, but does not make the function an interrupt-handler type function (i.e. it retains the normal C function calling ABI). See the &lt;code&gt;interrupt&lt;/code&gt; attribute for a description of its arguments.</source>
          <target state="translated">이 RX 속성은 매개 변수를 포함 하여 &lt;code&gt;interrupt&lt;/code&gt; 속성 과 유사 하지만 함수를 인터럽트 핸들러 유형 함수로 만들지 않습니다 (즉, ABI를 호출하는 일반 C 함수를 유지함). 인수에 대한 설명은 &lt;code&gt;interrupt&lt;/code&gt; 속성을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5e3ace91b836f39e130a69b032cbc00b174ef7e1" translate="yes" xml:space="preserve">
          <source>This allows classes to dynamically register methods (by adding them to the class using &lt;code&gt;class_addMethod&lt;/code&gt;) when they are first called. To do so, a class should implement &lt;code&gt;+resolveInstanceMethod:&lt;/code&gt; (or, depending on the case, &lt;code&gt;+resolveClassMethod:&lt;/code&gt;) and have it recognize the selectors of methods that can be registered dynamically at runtime, register them, and return &lt;code&gt;YES&lt;/code&gt;. It should return &lt;code&gt;NO&lt;/code&gt; for methods that it does not dynamically registered at runtime.</source>
          <target state="translated">이를 통해 클래스 는 처음 호출 될 때 메소드를 동적으로 등록 할 수 있습니다 ( &lt;code&gt;class_addMethod&lt;/code&gt; 를 사용하여 클래스에 추가 ). 그렇게하려면 클래스는 &lt;code&gt;+resolveInstanceMethod:&lt;/code&gt; 또는 경우에 따라 &lt;code&gt;+resolveClassMethod:&lt;/code&gt; :)를 구현 하고 런타임에 동적으로 등록 할 수있는 메소드의 선택자를 인식하고 등록한 다음 &lt;code&gt;YES&lt;/code&gt; 를 반환해야합니다 . 런타임에 동적으로 등록되지 않은 메소드의 경우 &lt;code&gt;NO&lt;/code&gt; 를 리턴해야 합니다.</target>
        </trans-unit>
        <trans-unit id="08bbed031d0bdc80dfc8c12fb03bbad77feeb085" translate="yes" xml:space="preserve">
          <source>This also works with</source>
          <target state="translated">이것은 또한 작동</target>
        </trans-unit>
        <trans-unit id="ebf24102acffe4ee7e0e4cb4b714de13fd9ab15c" translate="yes" xml:space="preserve">
          <source>This analysis is much more expensive than other GCC warnings.</source>
          <target state="translated">이 분석은 다른 GCC 경고보다 훨씬 비쌉니다.</target>
        </trans-unit>
        <trans-unit id="70958ab1135f4d3b760976f6ea18b5ad5e6cd4ca" translate="yes" xml:space="preserve">
          <source>This assumes that &lt;code&gt;x&lt;/code&gt; is an array of pointers to functions; the type described is that of the values of the functions.</source>
          <target state="translated">이것은 &lt;code&gt;x&lt;/code&gt; 가 함수에 대한 포인터의 배열 이라고 가정합니다 . 설명 된 유형은 함수 값의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="0e587899e8439ab096a171178bf777e82d34203e" translate="yes" xml:space="preserve">
          <source>This attribute adds stack protection code to the function if flags</source>
          <target state="translated">이 속성은 플래그 인 경우 스택 보호 코드를 함수에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="ffa1a8a02f8237f39f16f9e3141f209d4e6ecc0a" translate="yes" xml:space="preserve">
          <source>This attribute affects the linkage of the declaration to which it is attached. It can be applied to variables (see &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Common Variable Attributes&lt;/a&gt;) and types (see &lt;a href=&quot;common-type-attributes#Common-Type-Attributes&quot;&gt;Common Type Attributes&lt;/a&gt;) as well as functions.</source>
          <target state="translated">이 속성은 첨부 된 선언의 링크에 영향을줍니다. 변수 ( &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;공통 변수 속성&lt;/a&gt; 참조 ) 및 유형 ( &lt;a href=&quot;common-type-attributes#Common-Type-Attributes&quot;&gt;공통 유형 속성&lt;/a&gt; 참조) 및 함수에 적용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b70510133f65523747a3309a22314ce44be57270" translate="yes" xml:space="preserve">
          <source>This attribute affects the linkage of the declaration to which it is attached. The &lt;code&gt;visibility&lt;/code&gt; attribute is described in &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;Common Function Attributes&lt;/a&gt;.</source>
          <target state="translated">이 속성은 첨부 된 선언의 링크에 영향을줍니다. &lt;code&gt;visibility&lt;/code&gt; 속성에 설명되어있는 &lt;a href=&quot;common-function-attributes#Common-Function-Attributes&quot;&gt;일반적인 기능 속성&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2662beeb7225f89f9b3b830e684251c6d287e4ea" translate="yes" xml:space="preserve">
          <source>This attribute allows one to mark secure-code functions that are callable from normal mode. The location of the secure call function into the &lt;code&gt;sjli&lt;/code&gt; table needs to be passed as argument.</source>
          <target state="translated">이 속성을 사용하면 일반 모드에서 호출 가능한 보안 코드 기능을 표시 할 수 있습니다. &lt;code&gt;sjli&lt;/code&gt; 테이블 에 대한 보안 호출 기능의 위치는 인수로 전달되어야합니다.</target>
        </trans-unit>
        <trans-unit id="f72283dc6a14cbd57d6d6c7ceadcc8425ca927f4" translate="yes" xml:space="preserve">
          <source>This attribute allows the compiler to construct the requisite function declaration, while allowing the body of the function to be assembly code. The specified function will not have prologue/epilogue sequences generated by the compiler. Only basic &lt;code&gt;asm&lt;/code&gt; statements can safely be included in naked functions (see &lt;a href=&quot;basic-asm#Basic-Asm&quot;&gt;Basic Asm&lt;/a&gt;). While using extended &lt;code&gt;asm&lt;/code&gt; or a mixture of basic &lt;code&gt;asm&lt;/code&gt; and C code may appear to work, they cannot be depended upon to work reliably and are not supported.</source>
          <target state="translated">이 속성을 통해 컴파일러는 필수 함수 선언을 구성하는 동시에 함수 본문을 어셈블리 코드로 만들 수 있습니다. 지정된 함수에는 컴파일러가 생성 한 프롤로그 / 에필로그 시퀀스가 ​​없습니다. 기본 &lt;code&gt;asm&lt;/code&gt; 문만 나체 함수에 안전하게 포함시킬 수 있습니다 ( &lt;a href=&quot;basic-asm#Basic-Asm&quot;&gt;Basic Asm&lt;/a&gt; 참조 ). 확장 &lt;code&gt;asm&lt;/code&gt; 을 사용 하거나 기본 &lt;code&gt;asm&lt;/code&gt; 과 C 코드를 함께 사용하면 작동하는 것처럼 보일 수 있지만, 안정적으로 작동 할 수 없으며 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2da8d71f1e17b2c08ea57936e512e0f37aa70a9f" translate="yes" xml:space="preserve">
          <source>This attribute applies only to the particular namespace body, not to other definitions of the same namespace; it is equivalent to using &amp;lsquo;</source>
          <target state="translated">이 속성은 동일한 네임 스페이스의 다른 정의가 아닌 특정 네임 스페이스 본문에만 적용됩니다. '를 사용하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1a6b9ade066129340d2b93cc21dd28696f004a1b" translate="yes" xml:space="preserve">
          <source>This attribute causes the compiler to assume the called function is close enough to use the normal calling convention, overriding the</source>
          <target state="translated">이 속성은 컴파일러가 호출 된 함수가 정상적인 호출 규칙을 사용하기에 충분히 가깝다고 가정하여</target>
        </trans-unit>
        <trans-unit id="02e0a7b8749b1724d33369b4ea037bd0b071529e" translate="yes" xml:space="preserve">
          <source>This attribute causes the compiler to emit instructions to disable interrupts for the duration of the given function.</source>
          <target state="translated">이 속성은 컴파일러가 주어진 함수 동안 인터럽트를 비활성화하는 명령어를 내도록합니다.</target>
        </trans-unit>
        <trans-unit id="b8e219dd9b57732e157d707be34c1c904f638a7d" translate="yes" xml:space="preserve">
          <source>This attribute corresponds to the</source>
          <target state="translated">이 속성은</target>
        </trans-unit>
        <trans-unit id="0da402fe02e024fb03bb5a3ac4167c5cbafc19db" translate="yes" xml:space="preserve">
          <source>This attribute enables creation of one or more function versions that can process multiple arguments using SIMD instructions from a single invocation. Specifying this attribute allows compiler to assume that such versions are available at link time (provided in the same or another translation unit). Generated versions are target-dependent and described in the corresponding Vector ABI document. For x86_64 target this document can be found &lt;a href=&quot;https://sourceware.org/glibc/wiki/libmvec?action=AttachFile&amp;amp;do=view&amp;amp;target=VectorABI.txt&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">이 속성을 사용하면 단일 호출에서 SIMD 명령을 사용하여 여러 인수를 처리 할 수있는 하나 이상의 함수 버전을 작성할 수 있습니다. 이 속성을 지정하면 컴파일러는 이러한 버전이 링크 타임에 동일하거나 다른 변환 단위로 제공 될 수 있다고 가정 할 수 있습니다. 생성 된 버전은 대상에 따라 다르며 해당하는 벡터 ABI 문서에 설명되어 있습니다. x86_64 대상의 경우이 문서는 &lt;a href=&quot;https://sourceware.org/glibc/wiki/libmvec?action=AttachFile&amp;amp;do=view&amp;amp;target=VectorABI.txt&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="660859d290d769bde079f1e74652268ebbc1b062" translate="yes" xml:space="preserve">
          <source>This attribute indicates that the corresponding function should be compiled as a kernel function, that is an entry point that can be invoked from the host via the HSA runtime library. By default functions are only callable only from other GCN functions.</source>
          <target state="translated">이 속성은 해당 함수가 커널 함수, 즉 HSA 런타임 라이브러리를 통해 호스트에서 호출 할 수있는 진입 점으로 컴파일되어야 함을 나타냅니다. 기본적으로 함수는 다른 GCN 함수에서만 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2fad3c190739d8e505c7ea63fef5f7267f258de" translate="yes" xml:space="preserve">
          <source>This attribute indicates that the corresponding function should be compiled as a kernel function, which can be invoked from the host via the CUDA RT library. By default functions are only callable only from other PTX functions.</source>
          <target state="translated">이 속성은 해당 함수가 CUDA RT 라이브러리를 통해 호스트에서 호출 될 수있는 커널 함수로 컴파일되어야 함을 나타냅니다. 기본적으로 기능은 다른 PTX 기능에서만 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57e17cc8aacf2250a0265d50a2b47adfbfe456c6" translate="yes" xml:space="preserve">
          <source>This attribute is also accepted in C, but it is unnecessary because C does not have constructors or destructors.</source>
          <target state="translated">이 속성은 C에서도 허용되지만 C에는 생성 자나 소멸자가 없으므로 불필요합니다.</target>
        </trans-unit>
        <trans-unit id="503a85109e1de0e8ce0564d361fa1038358344dc" translate="yes" xml:space="preserve">
          <source>This attribute is appropriate for types which just represent a value, such as &lt;code&gt;std::string&lt;/code&gt;; it is not appropriate for types which control a resource, such as &lt;code&gt;std::lock_guard&lt;/code&gt;.</source>
          <target state="translated">이 속성은 &lt;code&gt;std::string&lt;/code&gt; 과 같이 값을 나타내는 유형에 적합 합니다 . 자원을 제어하는 ​​유형 (예 : &lt;code&gt;std::lock_guard&lt;/code&gt; )에는 적합하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ba2d583dcd0ca68ace008c0dc9fbd8ec6f90be8f" translate="yes" xml:space="preserve">
          <source>This attribute is ignored for R8C target.</source>
          <target state="translated">이 속성은 R8C 대상에 대해 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="34e03794349850af7bdeb66f9a9d6ef490386eec" translate="yes" xml:space="preserve">
          <source>This attribute is implicitly applied to any function named &lt;code&gt;main&lt;/code&gt;, using default parameters.</source>
          <target state="translated">이 속성은 기본 매개 변수를 사용하여 &lt;code&gt;main&lt;/code&gt; 이라는 모든 함수에 내재적으로 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="d9346f70ea23c21af36c756ae2b79002b57ffa81" translate="yes" xml:space="preserve">
          <source>This attribute is only applicable to integral and floating scalar types. In function declarations the attribute applies to the function return type.</source>
          <target state="translated">이 속성은 정수 및 부동 스칼라 유형에만 적용 할 수 있습니다. 함수 선언에서 속성은 함수 반환 유형에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="4d7f394253f35fa8db5ca6f449a44ff4b56ba334" translate="yes" xml:space="preserve">
          <source>This attribute is only applicable to integral and floating scalars, although arrays, pointers, and function return values are allowed in conjunction with this construct.</source>
          <target state="translated">이 속성은 배열, 포인터 및 함수 반환 값이이 구성과 함께 허용되지만 정수 및 부동 스칼라에만 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e555249b47de74e90649b8eebd9bb76b767b366" translate="yes" xml:space="preserve">
          <source>This attribute is supported only for targets that use a uniform default scalar storage order (fortunately, most of them), i.e. targets that store the scalars either all in big-endian or all in little-endian.</source>
          <target state="translated">이 속성은 균일 한 기본 스칼라 스토리지 순서를 사용하는 대상 (다행히 대부분의 스칼라), 즉 스칼라를 모두 빅 엔디안 또는 리틀 엔디안으로 저장하는 대상에 대해서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="0c3dbf2eda48cb59aebda306917b7f78672e9f61" translate="yes" xml:space="preserve">
          <source>This attribute is used to modify the IA-64 calling convention by marking all input registers as live at all function exits. This makes it possible to restart a system call after an interrupt without having to save/restore the input registers. This also prevents kernel data from leaking into application code.</source>
          <target state="translated">이 속성은 모든 기능 레지스터에서 모든 입력 레지스터를 라이브로 표시하여 IA-64 호출 규칙을 수정하는 데 사용됩니다. 따라서 입력 레지스터를 저장 / 복원 할 필요없이 인터럽트 후 시스템 호출을 다시 시작할 수 있습니다. 또한 커널 데이터가 응용 프로그램 코드로 유출되는 것을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="b29e16cc249effe80d848bb9db8d32ddaa499113" translate="yes" xml:space="preserve">
          <source>This attribute is useful for small inline wrappers that if possible should appear during debugging as a unit. Depending on the debug info format it either means marking the function as artificial or using the caller location for all instructions within the inlined body.</source>
          <target state="translated">이 속성은 가능한 경우 단위로 디버깅하는 동안 작은 인라인 랩퍼에 유용합니다. 디버그 정보 형식에 따라 함수를 인위적으로 표시하거나 인라인 본문 내 모든 명령에 대한 호출자 위치를 사용하는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="eebce69b5ee57e7d9f9e53b8f77d9b2143a8f71f" translate="yes" xml:space="preserve">
          <source>This attribute locally overrides the</source>
          <target state="translated">이 속성은 로컬에서</target>
        </trans-unit>
        <trans-unit id="b079e0e5e6910cff82e9ecf2f5a99d46287bccb2" translate="yes" xml:space="preserve">
          <source>This attribute may only be applied to structure types. It indicates that any initialization of an object of this type must use designated initializers rather than positional initializers. The intent of this attribute is to allow the programmer to indicate that a structure&amp;rsquo;s layout may change, and that therefore relying on positional initialization will result in future breakage.</source>
          <target state="translated">이 속성은 구조 유형에만 적용될 수 있습니다. 이 유형의 객체를 초기화 할 때는 위치 이니셜 라이저가 아닌 지정된 이니셜 라이저를 사용해야합니다. 이 속성의 목적은 프로그래머가 구조의 레이아웃이 변경 될 수 있음을 나타내도록하고, 따라서 위치 초기화에 의존하면 나중에 파손될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5c62ef86997f4e170b106b5387843679fbba8d0" translate="yes" xml:space="preserve">
          <source>This attribute modifies the behavior of an interrupt handler. The interrupt handler may be in external memory which cannot be reached by a branch instruction, so generate a local memory trampoline to transfer control. The single parameter identifies the section where the trampoline is placed.</source>
          <target state="translated">이 속성은 인터럽트 핸들러의 동작을 수정합니다. 인터럽트 핸들러는 분기 명령으로 도달 할 수없는 외부 메모리에있을 수 있으므로 제어를 전송하기 위해 로컬 메모리 트램폴린을 생성하십시오. 단일 매개 변수는 트램펄린이 배치 된 섹션을 식별합니다.</target>
        </trans-unit>
        <trans-unit id="effaae1a1a3c582ea4cc6ec90afe0b02dd3b515f" translate="yes" xml:space="preserve">
          <source>This attribute only applies to interrupt functions. It is silently ignored if applied to a non-interrupt function. A wakeup interrupt function will rouse the processor from any low-power state that it might be in when the function exits.</source>
          <target state="translated">이 속성은 인터럽트 함수에만 적용됩니다. 비 인터럽트 기능에 적용되면 자동으로 무시됩니다. 웨이크 업 인터럽트 기능은 프로세서가 기능을 종료 할 때있을 수있는 저전력 상태에서 프로세서를 중지시킵니다.</target>
        </trans-unit>
        <trans-unit id="b26152314a60738ffd8a5e7f3727dd841bf2cfd9" translate="yes" xml:space="preserve">
          <source>This attribute requires assembler and object file support, and may not be available on all targets.</source>
          <target state="translated">이 속성은 어셈블러 및 오브젝트 파일 지원이 필요하며 모든 대상에서 사용 가능한 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="91b2af80c8a3a275efbd609425500eed5fe647aa" translate="yes" xml:space="preserve">
          <source>This attribute should be used with a function that is also declared with the &lt;code&gt;inline&lt;/code&gt; keyword. It directs GCC to treat the function as if it were defined in gnu90 mode even when compiling in C99 or gnu99 mode.</source>
          <target state="translated">이 속성은 &lt;code&gt;inline&lt;/code&gt; 키워드로 선언 된 함수와 함께 사용해야합니다 . C99 또는 gnu99 모드에서 컴파일 할 때에도 gnu90 모드에서 정의 된 것처럼 함수를 처리하도록 GCC에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="673dc92ba9f751f0e2d252934e26bb46b7e48dac" translate="yes" xml:space="preserve">
          <source>This attribute specifies a function to be placed into L1 Instruction SRAM. The function is put into a specific section named &lt;code&gt;.l1.text&lt;/code&gt;. With</source>
          <target state="translated">이 속성은 L1 명령어 SRAM에 배치 할 기능을 지정합니다. 이 함수는 &lt;code&gt;.l1.text&lt;/code&gt; 라는 특정 섹션에 배치됩니다 . 와</target>
        </trans-unit>
        <trans-unit id="87042e05584213c1ab77c9f22219578def878d66" translate="yes" xml:space="preserve">
          <source>This attribute specifies a function to be placed into L2 SRAM. The function is put into a specific section named &lt;code&gt;.l2.text&lt;/code&gt;. With</source>
          <target state="translated">이 속성은 L2 SRAM에 배치 할 기능을 지정합니다. 이 함수는 &lt;code&gt;.l2.text&lt;/code&gt; 라는 특정 섹션에 배치됩니다 . 와</target>
        </trans-unit>
        <trans-unit id="79629b6015ecde4f64aa5edeebdeed4ca22350b1" translate="yes" xml:space="preserve">
          <source>This attribute specifies a threshold for the structure field, measured in bytes. If the structure field is aligned below the threshold, a warning will be issued. For example, the declaration:</source>
          <target state="translated">이 속성은 바이트 단위로 측정 된 구조 필드의 임계 값을 지정합니다. 구조 필드가 임계 값 아래에 정렬되면 경고가 발행됩니다. 예를 들어, 선언 :</target>
        </trans-unit>
        <trans-unit id="304795dd4f7d1f35b54a689f0ca428f75b402b8c" translate="yes" xml:space="preserve">
          <source>This attribute specifies the data type for the declaration&amp;mdash;whichever type corresponds to the mode &lt;var&gt;mode&lt;/var&gt;. This in effect lets you request an integer or floating-point type according to its width.</source>
          <target state="translated">이 속성은 선언의 데이터 유형을 지정합니다 (유형은 mode &lt;var&gt;mode&lt;/var&gt; 에 해당) . 이를 통해 너비에 따라 정수 또는 부동 소수점 유형을 요청할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c9083d141dfccd0e26e0504dbf2c594ddf0afc0" translate="yes" xml:space="preserve">
          <source>This attribute specifies the vector size for the type of the declared variable, measured in bytes. The type to which it applies is known as the &lt;em&gt;base type&lt;/em&gt;. The &lt;var&gt;bytes&lt;/var&gt; argument must be a positive power-of-two multiple of the base type size. For example, the declaration:</source>
          <target state="translated">이 속성은 선언 된 변수 유형의 벡터 크기를 바이트 단위로 지정합니다. 적용되는 유형을 &lt;em&gt;기본 유형이라고&lt;/em&gt; 합니다. &lt;var&gt;bytes&lt;/var&gt; 인수는 기본 유형 크기의 긍정적 인 전력의-두 배수 여야합니다. 예를 들어, 선언 :</target>
        </trans-unit>
        <trans-unit id="4812a74afb4965dd971b67251a8e1a47c47bf670" translate="yes" xml:space="preserve">
          <source>This attribute specifies the vector size for the type, measured in bytes. The type to which it applies is known as the &lt;em&gt;base type&lt;/em&gt;. The &lt;var&gt;bytes&lt;/var&gt; argument must be a positive power-of-two multiple of the base type size. For example, the following declarations:</source>
          <target state="translated">이 속성은 유형의 벡터 크기를 바이트 단위로 지정합니다. 적용되는 유형을 &lt;em&gt;기본 유형이라고&lt;/em&gt; 합니다. &lt;var&gt;bytes&lt;/var&gt; 인수는 기본 유형 크기의 긍정적 인 전력의-두 배수 여야합니다. 예를 들어 다음과 같은 선언입니다.</target>
        </trans-unit>
        <trans-unit id="721933cb3a33d0b7e6bbaf2079ece1bfb6d52c2e" translate="yes" xml:space="preserve">
          <source>This attribute, attached to a &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt;, or C++ &lt;code&gt;class&lt;/code&gt; type definition, specifies that each of its members (other than zero-width bit-fields) is placed to minimize the memory required. This is equivalent to specifying the &lt;code&gt;packed&lt;/code&gt; attribute on each of the members.</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt; , &lt;code&gt;union&lt;/code&gt; 또는 C ++ &lt;code&gt;class&lt;/code&gt; 유형 정의에 첨부 된이 속성 은 필요한 메모리를 최소화하기 위해 각 멤버 (폭이 0 인 비트 필드 이외)가 배치되도록 지정합니다. 이는 각 멤버 에서 &lt;code&gt;packed&lt;/code&gt; 속성 을 지정하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="f26328ece7307f514a47cc876ff83560893a099c" translate="yes" xml:space="preserve">
          <source>This attribute, attached to a &lt;code&gt;union&lt;/code&gt; type definition, indicates that any function parameter having that union type causes calls to that function to be treated in a special way.</source>
          <target state="translated">&lt;code&gt;union&lt;/code&gt; 유형 정의에 첨부 된이 속성 은 해당 공용체 유형을 가진 함수 매개 변수로 인해 해당 함수에 대한 호출이 특별한 방식으로 처리됨을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="dea2c8428220fbb29ff9bb397fcc0cd8bc82fcc8" translate="yes" xml:space="preserve">
          <source>This attribute, attached to a function, means that code must be emitted for the function even if it appears that the function is not referenced. This is useful, for example, when the function is referenced only in inline assembly.</source>
          <target state="translated">함수에 첨부 된이 속성은 함수가 참조되지 않은 것처럼 보이더라도 함수에 대한 코드가 생성되어야 함을 의미합니다. 예를 들어 함수가 인라인 어셈블리에서만 참조되는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="f26a8e83a7c29f151aef9f7d69a0073e42ed7b63" translate="yes" xml:space="preserve">
          <source>This attribute, attached to a function, means that the function is meant to be possibly unused. GCC does not produce a warning for this function.</source>
          <target state="translated">함수에 첨부 된이 속성은 함수가 사용되지 않을 수 있음을 의미합니다. GCC는이 기능에 대한 경고를 생성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0cda8d2a406df80f5c3c1e70abd61657e961b09d" translate="yes" xml:space="preserve">
          <source>This attribute, attached to a global variable or function, nullifies the effect of the</source>
          <target state="translated">전역 변수 또는 함수에 첨부 된이 속성은</target>
        </trans-unit>
        <trans-unit id="b693f4e1b31df32d21cd97a87984062ca5cf0e7b" translate="yes" xml:space="preserve">
          <source>This attribute, attached to a variable with static storage, means that the variable must be emitted even if it appears that the variable is not referenced.</source>
          <target state="translated">정적 스토리지가있는 변수에 첨부 된이 속성은 변수가 참조되지 않은 것처럼 보이더라도 변수가 생성되어야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="09cf2bdd650a42affb72357abc94b2d76134170c" translate="yes" xml:space="preserve">
          <source>This attribute, attached to a variable, means that the variable is meant to be possibly unused. GCC does not produce a warning for this variable.</source>
          <target state="translated">변수에 첨부 된이 속성은 변수를 사용하지 않을 수 있음을 의미합니다. GCC는이 변수에 대한 경고를 생성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f6a9f3d41b5e82d7b9c83b17f60c49a3dab84962" translate="yes" xml:space="preserve">
          <source>This behavior may seem silly, but it&amp;rsquo;s what the ISO standard specifies. It is easy enough for you to make your code work by moving the definition of &lt;code&gt;struct mumble&lt;/code&gt; above the prototype. It&amp;rsquo;s not worth being incompatible with ISO C just to avoid an error for the example shown above.</source>
          <target state="translated">이 동작은 어리석은 것처럼 보일 수 있지만 ISO 표준이 지정하는 것입니다. &lt;code&gt;struct mumble&lt;/code&gt; 의 정의를 프로토 타입 위로 옮기면 코드가 작동하기 쉽습니다 . 위에 표시된 예제의 오류를 피하기 위해 ISO C와 호환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8818c6d89ffa44c89646c897a4e574f7b71484ee" translate="yes" xml:space="preserve">
          <source>This built-in can be used to determine the current transaction state using the following code example:</source>
          <target state="translated">이 내장은 다음 코드 예제를 사용하여 현재 트랜잭션 상태를 판별하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92883b24f84fe55e50f3d20ded0b1b0331344202" translate="yes" xml:space="preserve">
          <source>This built-in function acts as a synchronization fence between a thread and signal handlers based in the same thread.</source>
          <target state="translated">이 내장 함수는 동일한 스레드를 기반으로하는 스레드와 신호 처리기 간의 동기화 펜스 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="5a20473e8d5898eb62d474e73fb635a7caf013c9" translate="yes" xml:space="preserve">
          <source>This built-in function acts as a synchronization fence between threads based on the specified memory order.</source>
          <target state="translated">이 내장 함수는 지정된 메모리 순서에 따라 스레드 간의 동기화 차단 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="8c179d50784fac3eee427384f1e34f1d0ea28d01" translate="yes" xml:space="preserve">
          <source>This built-in function can be used to help mitigate against unsafe speculative execution. &lt;var&gt;type&lt;/var&gt; may be any integral type or any pointer type.</source>
          <target state="translated">이 내장 함수는 안전하지 않은 추측 실행을 완화하는 데 도움이됩니다. &lt;var&gt;type&lt;/var&gt; 은 일체형 또는 포인터 유형일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdfcca8b913445e45652ce81bc13dc531eb31f5a" translate="yes" xml:space="preserve">
          <source>This built-in function can return an lvalue if the chosen argument is an lvalue.</source>
          <target state="translated">이 내장 함수는 선택한 인수가 lvalue 인 경우 lvalue를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42b10a642d35506bdb301b36c3b2dbb7b1a29af0" translate="yes" xml:space="preserve">
          <source>This built-in function ignores top level qualifiers (e.g., &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;volatile&lt;/code&gt;). For example, &lt;code&gt;int&lt;/code&gt; is equivalent to &lt;code&gt;const
int&lt;/code&gt;.</source>
          <target state="translated">이 내장 함수는 최상위 한정자를 무시합니다 (예 : &lt;code&gt;const&lt;/code&gt; , &lt;code&gt;volatile&lt;/code&gt; ). 예를 들어, &lt;code&gt;int&lt;/code&gt; 는 &lt;code&gt;const int&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="de3196f175db1b7bf9e191bc879315daa8c8ea4f" translate="yes" xml:space="preserve">
          <source>This built-in function implements an atomic compare and exchange operation. This compares the contents of &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; with the contents of &lt;code&gt;*&lt;var&gt;expected&lt;/var&gt;&lt;/code&gt;. If equal, the operation is a &lt;em&gt;read-modify-write&lt;/em&gt; operation that writes &lt;var&gt;desired&lt;/var&gt; into &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;. If they are not equal, the operation is a &lt;em&gt;read&lt;/em&gt; and the current contents of &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; are written into &lt;code&gt;*&lt;var&gt;expected&lt;/var&gt;&lt;/code&gt;. &lt;var&gt;weak&lt;/var&gt; is &lt;code&gt;true&lt;/code&gt; for weak compare_exchange, which may fail spuriously, and &lt;code&gt;false&lt;/code&gt; for the strong variation, which never fails spuriously. Many targets only offer the strong variation and ignore the parameter. When in doubt, use the strong variation.</source>
          <target state="translated">이 내장 함수는 원자 비교 및 ​​교환 작업을 구현합니다. 이것은 &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; 의 내용과 &lt;code&gt;*&lt;var&gt;expected&lt;/var&gt;&lt;/code&gt; 의 내용을 비교합니다 . 동일한 경우, 동작은 인 &lt;em&gt;읽기 - 수정 - 쓰기&lt;/em&gt; 쓴다 동작 &lt;var&gt;desired&lt;/var&gt; 으로 &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; . 동일하지 않은 경우, 조작은 &lt;em&gt;읽기&lt;/em&gt; 이며 &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; 의 현재 내용은 &lt;code&gt;*&lt;var&gt;expected&lt;/var&gt;&lt;/code&gt; 에 기록됩니다 . &lt;var&gt;weak&lt;/var&gt; 하게 실패 할 수있는 약한 compare_exchange의 &lt;code&gt;true&lt;/code&gt; weak 가 true 이고 &lt;code&gt;false&lt;/code&gt; 절대로 실패하지 않는 강력한 변형에 대해 많은 대상이 강력한 변형 만 제공하고 매개 변수를 무시합니다. 확실하지 않은 경우에는 강한 변형을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="56f42bd96c55f1e604c896fe2e73d0e93c4e17e7" translate="yes" xml:space="preserve">
          <source>This built-in function implements an atomic exchange operation. It writes &lt;var&gt;val&lt;/var&gt; into &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;, and returns the previous contents of &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">이 내장 함수는 원자 교환 조작을 구현합니다. 이 글을 &lt;var&gt;val&lt;/var&gt; 에 &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; , 그리고 이전 내용 반환 &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e39a26f774d21850134f1ad4ec8601fd024a4508" translate="yes" xml:space="preserve">
          <source>This built-in function implements an atomic load operation. It returns the contents of &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">이 내장 함수는 원자로드 조작을 구현합니다. &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; 의 내용을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="6b2685600611aa3929789e72b13593b02a524004" translate="yes" xml:space="preserve">
          <source>This built-in function implements an atomic store operation. It writes &lt;code&gt;&lt;var&gt;val&lt;/var&gt;&lt;/code&gt; into &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">이 내장 함수는 원자 저장소 작업을 구현합니다. &lt;code&gt;&lt;var&gt;val&lt;/var&gt;&lt;/code&gt; 을 &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; 에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="ea16c3e951ac6e4e93bda6af660c19a372791953" translate="yes" xml:space="preserve">
          <source>This built-in function implements the generic version of &lt;code&gt;__atomic_compare_exchange&lt;/code&gt;. The function is virtually identical to &lt;code&gt;__atomic_compare_exchange_n&lt;/code&gt;, except the desired value is also a pointer.</source>
          <target state="translated">이 내장 함수는 일반 버전의 &lt;code&gt;__atomic_compare_exchange&lt;/code&gt; 를 구현합니다 . 이 함수는 원하는 값이 포인터라는 점을 제외하고 &lt;code&gt;__atomic_compare_exchange_n&lt;/code&gt; 과 사실상 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="8296c6507414677ec38273521ab8df96daa500be" translate="yes" xml:space="preserve">
          <source>This built-in function invokes &lt;var&gt;function&lt;/var&gt; with a copy of the parameters described by &lt;var&gt;arguments&lt;/var&gt; and &lt;var&gt;size&lt;/var&gt;.</source>
          <target state="translated">이 내장 함수는 &lt;var&gt;arguments&lt;/var&gt; 및 &lt;var&gt;size&lt;/var&gt; 로 설명 된 매개 변수의 사본으로 함수를 호출 &lt;var&gt;function&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="8f5c4780f25bedcea7655683b3a1f0ac5e0f5ed0" translate="yes" xml:space="preserve">
          <source>This built-in function is analogous to the &amp;lsquo;</source>
          <target state="translated">이 내장 기능은 '</target>
        </trans-unit>
        <trans-unit id="6e1bff7892551ba3b77dbb599f93fb2a84f960cc" translate="yes" xml:space="preserve">
          <source>This built-in function is not a full barrier, but rather a &lt;em&gt;release barrier&lt;/em&gt;. This means that all previous memory stores are globally visible, and all previous memory loads have been satisfied, but following memory reads are not prevented from being speculated to before the barrier.</source>
          <target state="translated">이 내장 기능은 완전한 장벽이 아니라 &lt;em&gt;릴리스 장벽&lt;/em&gt; 입니다. 이는 모든 이전 메모리 저장소가 전체적으로 표시되고 모든 이전 메모리로드가 충족되었지만 다음 메모리 읽기가 장벽 이전에 추측되는 것을 막지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d70719484366a8b3c252ddc3ff84790bc06cc3ad" translate="yes" xml:space="preserve">
          <source>This built-in function is not a full barrier, but rather an &lt;em&gt;acquire barrier&lt;/em&gt;. This means that references after the operation cannot move to (or be speculated to) before the operation, but previous memory stores may not be globally visible yet, and previous memory loads may not yet be satisfied.</source>
          <target state="translated">이 내장 함수는 전체 장벽이 아니라 &lt;em&gt;획득 장벽&lt;/em&gt; 입니다. 즉, 작업 후의 참조는 작업 이전으로 이동하거나 추측 할 수 없지만 이전 메모리 저장소는 아직 전체적으로 표시되지 않으며 이전 메모리로드는 아직 충족되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="073757ac658ed7f6a9f1d03295b93f00125aefcc" translate="yes" xml:space="preserve">
          <source>This built-in function issues a full memory barrier.</source>
          <target state="translated">이 내장 기능은 전체 메모리 장벽을 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="7e033b3b4f9c857696bc2244ed32f0a7d140cd57" translate="yes" xml:space="preserve">
          <source>This built-in function performs an atomic clear operation on &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;. After the operation, &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; contains 0. It should be only used for operands of type &lt;code&gt;bool&lt;/code&gt; or &lt;code&gt;char&lt;/code&gt; and in conjunction with &lt;code&gt;__atomic_test_and_set&lt;/code&gt;. For other types it may only clear partially. If the type is not &lt;code&gt;bool&lt;/code&gt; prefer using &lt;code&gt;__atomic_store&lt;/code&gt;.</source>
          <target state="translated">이 내장 함수는 &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; 에서 원자 지우기 작업을 수행합니다 . 연산 후 &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; 에는 0이 포함됩니다. &lt;code&gt;bool&lt;/code&gt; 또는 &lt;code&gt;char&lt;/code&gt; 유형의 피연산자 및 &lt;code&gt;__atomic_test_and_set&lt;/code&gt; 과 함께 사용해야 합니다. 다른 유형의 경우 부분적으로 만 지워질 수 있습니다. 유형이 &lt;code&gt;bool&lt;/code&gt; 이 아닌 경우 &lt;code&gt;__atomic_store&lt;/code&gt; 사용을 선호 하십시오 .</target>
        </trans-unit>
        <trans-unit id="b9c97edabae382ebead73a4652d8d69259efed11" translate="yes" xml:space="preserve">
          <source>This built-in function performs an atomic test-and-set operation on the byte at &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;. The byte is set to some implementation defined nonzero &amp;ldquo;set&amp;rdquo; value and the return value is &lt;code&gt;true&lt;/code&gt; if and only if the previous contents were &amp;ldquo;set&amp;rdquo;. It should be only used for operands of type &lt;code&gt;bool&lt;/code&gt; or &lt;code&gt;char&lt;/code&gt;. For other types only part of the value may be set.</source>
          <target state="translated">이 내장 함수는 &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; 의 바이트에 대해 원자 테스트 및 설정 작업을 수행합니다 . 바이트는 구현이 정의하지 않은 0이 아닌 &quot;set&quot;값으로 설정 되며, 이전 내용이 &quot;set&quot;인 경우에만 반환 값이 &lt;code&gt;true&lt;/code&gt; 입니다. &lt;code&gt;bool&lt;/code&gt; 또는 &lt;code&gt;char&lt;/code&gt; 유형의 피연산자에만 사용해야합니다 . 다른 유형의 경우 값의 일부만 설정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b288561de8012f0a5e9cadf66cc0631f6c354855" translate="yes" xml:space="preserve">
          <source>This built-in function releases the lock acquired by &lt;code&gt;__sync_lock_test_and_set&lt;/code&gt;. Normally this means writing the constant 0 to &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">이 내장 함수는 &lt;code&gt;__sync_lock_test_and_set&lt;/code&gt; 에 의해 획득 된 잠금을 해제합니다 . 일반적으로 상수 0을 &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; 로 쓰는 것을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="6fbd055aee266ab03001d14151e03de46793e79e" translate="yes" xml:space="preserve">
          <source>This built-in function represents all anonymous arguments of an inline function. It can be used only in inline functions that are always inlined, never compiled as a separate function, such as those using &lt;code&gt;__attribute__ ((__always_inline__))&lt;/code&gt; or &lt;code&gt;__attribute__ ((__gnu_inline__))&lt;/code&gt; extern inline functions. It must be only passed as last argument to some other function with variable arguments. This is useful for writing small wrapper inlines for variable argument functions, when using preprocessor macros is undesirable. For example:</source>
          <target state="translated">이 내장 함수는 인라인 함수의 모든 익명 인수를 나타냅니다. &lt;code&gt;__attribute__ ((__always_inline__))&lt;/code&gt; 또는 &lt;code&gt;__attribute__ ((__gnu_inline__))&lt;/code&gt; extern 인라인 함수를 사용하는 함수와 같이 항상 인라인 된 인라인 함수에서만 사용할 수 있으며 별도의 함수로 컴파일되지 않습니다 . 변수 인수를 가진 다른 함수에는 마지막 인수로만 전달되어야합니다. 이것은 전 처리기 매크로를 사용하는 것이 바람직하지 않을 때 가변 인수 함수에 작은 래퍼 인라인을 작성하는 데 유용합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a645e8bd97d4c4a4974b86fe42f50e43f5945898" translate="yes" xml:space="preserve">
          <source>This built-in function returns 1 if the unqualified versions of the types &lt;var&gt;type1&lt;/var&gt; and &lt;var&gt;type2&lt;/var&gt; (which are types, not expressions) are compatible, 0 otherwise. The result of this built-in function can be used in integer constant expressions.</source>
          <target state="translated">이 내장 함수는 &lt;var&gt;type1&lt;/var&gt; 및 &lt;var&gt;type2&lt;/var&gt; 유형 (표현식이 아닌 유형) 의 규정되지 않은 버전 이 호환 가능한 경우 1을 리턴 하고 그렇지 않으면 0을 리턴합니다 . 이 내장 함수의 결과는 정수 상수 표현식에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="adfe1d809ee98496092f61c8ed5ff01343455bef" translate="yes" xml:space="preserve">
          <source>This built-in function returns &lt;code&gt;true&lt;/code&gt; if objects of &lt;var&gt;size&lt;/var&gt; bytes always generate lock-free atomic instructions for the target architecture. &lt;var&gt;size&lt;/var&gt; must resolve to a compile-time constant and the result also resolves to a compile-time constant.</source>
          <target state="translated">이 내장 함수는 &lt;var&gt;size&lt;/var&gt; 바이트의 오브젝트가 항상 대상 아키텍처에 대해 잠금없는 원자 명령어를 생성하는 경우 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . &lt;var&gt;size&lt;/var&gt; 는 컴파일 타임 상수로 해석되어야하며 결과는 컴파일 타임 상수로도 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="81bd1267444e0c22cd6d3d40974c7c8c9aa88d05" translate="yes" xml:space="preserve">
          <source>This built-in function returns &lt;code&gt;true&lt;/code&gt; if objects of &lt;var&gt;size&lt;/var&gt; bytes always generate lock-free atomic instructions for the target architecture. If the built-in function is not known to be lock-free, a call is made to a runtime routine named &lt;code&gt;__atomic_is_lock_free&lt;/code&gt;.</source>
          <target state="translated">이 내장 함수는 &lt;var&gt;size&lt;/var&gt; 바이트의 오브젝트가 항상 대상 아키텍처에 대해 잠금없는 원자 명령어를 생성하는 경우 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 내장 함수에 잠금이없는 것으로 알려진 경우 &lt;code&gt;__atomic_is_lock_free&lt;/code&gt; 라는 런타임 루틴이 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="7c6d5e134400518a60b0f022ce70bc3a88ebfc9d" translate="yes" xml:space="preserve">
          <source>This built-in function returns a pointer to data describing how to perform a call with the same arguments as are passed to the current function.</source>
          <target state="translated">이 내장 함수는 현재 함수에 전달 된 것과 동일한 인수로 호출을 수행하는 방법을 설명하는 데이터에 대한 포인터를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="a965c005ba35ec687e9a6eef5b255a00ddffc5d3" translate="yes" xml:space="preserve">
          <source>This built-in function returns the number of anonymous arguments of an inline function. It can be used only in inline functions that are always inlined, never compiled as a separate function, such as those using &lt;code&gt;__attribute__ ((__always_inline__))&lt;/code&gt; or &lt;code&gt;__attribute__ ((__gnu_inline__))&lt;/code&gt; extern inline functions. For example following does link- or run-time checking of open arguments for optimized code:</source>
          <target state="translated">이 내장 함수는 인라인 함수의 익명 인수 수를 리턴합니다. &lt;code&gt;__attribute__ ((__always_inline__))&lt;/code&gt; 또는 &lt;code&gt;__attribute__ ((__gnu_inline__))&lt;/code&gt; extern 인라인 함수를 사용하는 함수와 같이 항상 인라인 함수로만 사용되며 별도의 함수로 컴파일되지 않습니다 . 예를 들어 다음은 최적화 된 코드에 대한 열린 인수의 링크 또는 런타임 검사를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="23a152f3eb0d609efeaccc0dfd600b3f1ca33a36" translate="yes" xml:space="preserve">
          <source>This built-in function returns the value described by &lt;var&gt;result&lt;/var&gt; from the containing function. You should specify, for &lt;var&gt;result&lt;/var&gt;, a value returned by &lt;code&gt;__builtin_apply&lt;/code&gt;.</source>
          <target state="translated">이 내장 함수는 포함 함수의 &lt;var&gt;result&lt;/var&gt; 로 설명 된 값을 리턴합니다 . &lt;var&gt;result&lt;/var&gt; 의 경우 &lt;code&gt;__builtin_apply&lt;/code&gt; 에서 반환 한 값 을 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="93f8e4f9c5ee35c6668a2b80b5a01f58cf7b3cac" translate="yes" xml:space="preserve">
          <source>This built-in function, as described by Intel, is not a traditional test-and-set operation, but rather an atomic exchange operation. It writes &lt;var&gt;value&lt;/var&gt; into &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;, and returns the previous contents of &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">인텔에서 설명한이 내장 기능은 일반적인 테스트 및 설정 작업이 아니라 원자 교환 작업입니다. 이 글을 &lt;var&gt;value&lt;/var&gt; 로 &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; , 그리고 이전 내용 반환 &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="568a9d62c8cf52e8d6dd28fe3fede9225dfafd5c" translate="yes" xml:space="preserve">
          <source>This built-in implements the C99 fpclassify functionality. The first five int arguments should be the target library&amp;rsquo;s notion of the possible FP classes and are used for return values. They must be constant values and they must appear in this order: &lt;code&gt;FP_NAN&lt;/code&gt;, &lt;code&gt;FP_INFINITE&lt;/code&gt;, &lt;code&gt;FP_NORMAL&lt;/code&gt;, &lt;code&gt;FP_SUBNORMAL&lt;/code&gt; and &lt;code&gt;FP_ZERO&lt;/code&gt;. The ellipsis is for exactly one floating-point value to classify. GCC treats the last argument as type-generic, which means it does not do default promotion from float to double.</source>
          <target state="translated">이 내장 기능은 C99 fpclassify 기능을 구현합니다. 처음 5 개의 int 인수는 대상 라이브러리의 가능한 FP 클래스 개념이어야하며 리턴 값에 사용됩니다. 상수 값이어야하며 &lt;code&gt;FP_NAN&lt;/code&gt; , &lt;code&gt;FP_INFINITE&lt;/code&gt; , &lt;code&gt;FP_NORMAL&lt;/code&gt; , &lt;code&gt;FP_SUBNORMAL&lt;/code&gt; 및 &lt;code&gt;FP_ZERO&lt;/code&gt; 순서로 나타나야 합니다. 줄임표는 정확히 하나의 부동 소수점 값으로 분류됩니다. GCC는 마지막 인수를 유형 제네릭으로 처리하므로 float에서 double로 기본 승격을 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="de56bb64bcd269982e143b48fca7664ac4ccd934" translate="yes" xml:space="preserve">
          <source>This built-in takes a byte address to the 24-bit &lt;a href=&quot;named-address-spaces#AVR-Named-Address-Spaces&quot;&gt;address space&lt;/a&gt;&lt;code&gt;__memx&lt;/code&gt; and returns the number of the flash segment (the 64 KiB chunk) where the address points to. Counting starts at &lt;code&gt;0&lt;/code&gt;. If the address does not point to flash memory, return &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">이 내장은 바이트 주소를 24 비트 &lt;a href=&quot;named-address-spaces#AVR-Named-Address-Spaces&quot;&gt;주소 공간 &lt;/a&gt; &lt;code&gt;__memx&lt;/code&gt; 로 가져와주소가 가리키는 플래시 세그먼트의 수 (64 KiB 청크)를 반환합니다. 계수는 &lt;code&gt;0&lt;/code&gt; 에서 시작합니다 . 주소가 플래시 메모리를 가리 키지 않으면 &lt;code&gt;-1&lt;/code&gt; 을 반환하십시오 .</target>
        </trans-unit>
        <trans-unit id="12afcfe5b0cb2421e366cb4bf6d262a7225b43e1" translate="yes" xml:space="preserve">
          <source>This calling convention is incompatible with the one normally used on Unix, so you cannot use it if you need to call libraries compiled with the Unix compiler.</source>
          <target state="translated">이 호출 규칙은 Unix에서 일반적으로 사용되는 것과 호환되지 않으므로 Unix 컴파일러로 컴파일 된 라이브러리를 호출해야하는 경우이를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c59930047a3dbe1a0da0d3c55b5832603831020b" translate="yes" xml:space="preserve">
          <source>This can be a suitable option for application code written for the Borland model, as it usually just works. Code written for the Cfront model needs to be modified so that the template definitions are available at one or more points of instantiation; usually this is as simple as adding &lt;code&gt;#include &amp;lt;tmethods.cc&amp;gt;&lt;/code&gt; to the end of each template header.</source>
          <target state="translated">이것은 일반적으로 작동하기 때문에 Borland 모델 용으로 작성된 응용 프로그램 코드에 적합한 옵션이 될 수 있습니다. 템플릿 정의가 하나 이상의 인스턴스화 지점에서 사용 가능하도록 Cfront 모델 용으로 작성된 코드를 수정해야합니다. 일반적으로 이는 각 템플릿 헤더 끝에 &lt;code&gt;#include &amp;lt;tmethods.cc&amp;gt;&lt;/code&gt; 를 추가하는 것만 큼 간단 합니다.</target>
        </trans-unit>
        <trans-unit id="8138fe5070f142675bd6f047c11ca6604b5e4b89" translate="yes" xml:space="preserve">
          <source>This causes GCC&amp;rsquo;s output file to have the &amp;lsquo;</source>
          <target state="translated">이로 인해 GCC의 출력 파일에 '</target>
        </trans-unit>
        <trans-unit id="0b096441ddb3f545a4e7491763e07ff42aa42c7a" translate="yes" xml:space="preserve">
          <source>This causes an error messages saying:</source>
          <target state="translated">다음과 같은 오류 메시지가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="37b13c019e57e81567c1e4f0f77d055f628a1482" translate="yes" xml:space="preserve">
          <source>This clears the indicated bits in the saved copy of the status register currently residing on the stack. This only works inside interrupt handlers and the changes to the status register will only take affect once the handler returns.</source>
          <target state="translated">이렇게하면 현재 스택에 상주하는 상태 레지스터의 저장된 사본에서 표시된 비트가 지워집니다. 이것은 인터럽트 처리기에서만 작동하며 상태 레지스터의 변경 사항은 처리기가 반환 된 후에 만 ​​적용됩니다.</target>
        </trans-unit>
        <trans-unit id="52348806f9132146a3d5c83435b59d49467218d2" translate="yes" xml:space="preserve">
          <source>This code copies &lt;code&gt;src&lt;/code&gt; to &lt;code&gt;dst&lt;/code&gt; and add 1 to &lt;code&gt;dst&lt;/code&gt;.</source>
          <target state="translated">이 코드는 &lt;code&gt;src&lt;/code&gt; 를 &lt;code&gt;dst&lt;/code&gt; 에 복사 하고 1을 &lt;code&gt;dst&lt;/code&gt; 에 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="5a1cd197f5f5bea21b21e4898acbd5a40235dc12" translate="yes" xml:space="preserve">
          <source>This code makes no use of the optional &lt;var&gt;asmSymbolicName&lt;/var&gt;. Therefore it references the first output operand as &lt;code&gt;%0&lt;/code&gt; (were there a second, it would be &lt;code&gt;%1&lt;/code&gt;, etc). The number of the first input operand is one greater than that of the last output operand. In this i386 example, that makes &lt;code&gt;Mask&lt;/code&gt; referenced as &lt;code&gt;%1&lt;/code&gt;:</source>
          <target state="translated">이 코드는 선택적 &lt;var&gt;asmSymbolicName&lt;/var&gt; 을 사용하지 않습니다 . 따라서 첫 번째 출력 피연산자를 &lt;code&gt;%0&lt;/code&gt; 으로 참조합니다 (두 번째가 있으면 &lt;code&gt;%1&lt;/code&gt; 등). 첫 번째 입력 피연산자의 수는 마지막 출력 피연산자의 수보다 하나 더 큽니다. 이 i386 예제에서는 &lt;code&gt;Mask&lt;/code&gt; 를 &lt;code&gt;%1&lt;/code&gt; 로 참조합니다 .</target>
        </trans-unit>
        <trans-unit id="f9f2247acfc64bac06fade1fb9f20f85e4652f3a" translate="yes" xml:space="preserve">
          <source>This code really is erroneous, because the scope of &lt;code&gt;struct
mumble&lt;/code&gt; in the prototype is limited to the argument list containing it. It does not refer to the &lt;code&gt;struct mumble&lt;/code&gt; defined with file scope immediately below&amp;mdash;they are two unrelated types with similar names in different scopes.</source>
          <target state="translated">프로토 타입에서 &lt;code&gt;struct mumble&lt;/code&gt; 의 범위 가 그것을 포함하는 인수 목록으로 제한 되기 때문에이 코드는 실제로 잘못 되었습니다. 바로 아래의 파일 범위로 정의 된 &lt;code&gt;struct mumble&lt;/code&gt; 을 나타내지 않습니다 . 서로 다른 범위에서 비슷한 이름을 가진 두 개의 관련되지 않은 유형입니다.</target>
        </trans-unit>
        <trans-unit id="337163816650f5c7db30e6d4ef7d7194c7c7dcdf" translate="yes" xml:space="preserve">
          <source>This code runs unconditionally on all 64-bit processors. For 32-bit processors the code runs on those that support multi-byte NOP instructions.</source>
          <target state="translated">이 코드는 모든 64 비트 프로세서에서 무조건 실행됩니다. 32 비트 프로세서의 경우 코드는 멀티 바이트 NOP 명령어를 지원하는 프로세서에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="5f60ecfa36c1d209e897848d1465d421ffe66fd4" translate="yes" xml:space="preserve">
          <source>This code says that input &lt;code&gt;b&lt;/code&gt; is not popped by the &lt;code&gt;asm&lt;/code&gt;, and that the &lt;code&gt;asm&lt;/code&gt; pushes a result onto the reg-stack, i.e., the stack is one deeper after the &lt;code&gt;asm&lt;/code&gt; than it was before. But, it is possible that reload may think that it can use the same register for both the input and the output.</source>
          <target state="translated">이 코드는 입력 &lt;code&gt;b&lt;/code&gt; 가 &lt;code&gt;asm&lt;/code&gt; 에 의해 팝되지 않고 &lt;code&gt;asm&lt;/code&gt; 이 결과를 reg-stack으로 푸시 한다고 말합니다. 즉, 스택은 &lt;code&gt;asm&lt;/code&gt; 이후보다 깊 습니다. 그러나 reload는 입력과 출력 모두에 동일한 레지스터를 사용할 수 있다고 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5158b0e232baa68e812ae0b3c5ff1e7b6dd2495a" translate="yes" xml:space="preserve">
          <source>This combination of &lt;code&gt;inline&lt;/code&gt; and &lt;code&gt;extern&lt;/code&gt; has almost the effect of a macro. The way to use it is to put a function definition in a header file with these keywords, and put another copy of the definition (lacking &lt;code&gt;inline&lt;/code&gt; and &lt;code&gt;extern&lt;/code&gt;) in a library file. The definition in the header file causes most calls to the function to be inlined. If any uses of the function remain, they refer to the single copy in the library.</source>
          <target state="translated">&lt;code&gt;inline&lt;/code&gt; 과 &lt;code&gt;extern&lt;/code&gt; 의 조합은 매크로의 영향을 거의받습니다. 이를 사용하는 방법은 이러한 키워드를 사용하여 함수 정의를 헤더 파일에 넣고 라이브러리 파일에 정의의 다른 사본 ( &lt;code&gt;inline&lt;/code&gt; 및 &lt;code&gt;extern&lt;/code&gt; 부족)을 넣는 것 입니다. 헤더 파일의 정의는 함수에 대한 대부분의 호출이 인라인되도록합니다. 함수 사용이 남아 있으면 라이브러리의 단일 사본을 참조합니다.</target>
        </trans-unit>
        <trans-unit id="b81343c69409df406d64f943e849b1b69e1c3338" translate="yes" xml:space="preserve">
          <source>This construct outputs &lt;code&gt;dialect0&lt;/code&gt; when using dialect #0 to compile the code, &lt;code&gt;dialect1&lt;/code&gt; for dialect #1, etc. If there are fewer alternatives within the braces than the number of dialects the compiler supports, the construct outputs nothing.</source>
          <target state="translated">이 구성은 dialect # 0을 사용하여 코드를 컴파일 할 때 &lt;code&gt;dialect0&lt;/code&gt; 을 출력 하고, dialect # 1에 대한 &lt;code&gt;dialect1&lt;/code&gt; 등을 작성합니다. 중괄호 내에 컴파일러가 지원하는 방언의 수보다 적은 대안이 있으면 구성은 아무것도 출력하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4418d19029db54262a2982d0fc11517ca360b079" translate="yes" xml:space="preserve">
          <source>This could also be written using a statement expression:</source>
          <target state="translated">명령문 표현식을 사용하여 작성할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3561933d5b27303ad0b1eed1db35f7bce90fa0b" translate="yes" xml:space="preserve">
          <source>This declaration only establishes that the class &lt;code&gt;Foo&lt;/code&gt; has an &lt;code&gt;int&lt;/code&gt; named &lt;code&gt;Foo::bar&lt;/code&gt;, and a member function named &lt;code&gt;Foo::method&lt;/code&gt;. But you still need to define &lt;em&gt;both&lt;/em&gt;&lt;code&gt;method&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; elsewhere. According to the ISO standard, you must supply an initializer in one (and only one) source file, such as:</source>
          <target state="translated">이 선언 은 &lt;code&gt;Foo&lt;/code&gt; 클래스에 Foo &lt;code&gt;Foo::bar&lt;/code&gt; 라는 &lt;code&gt;int&lt;/code&gt; 와 &lt;code&gt;Foo::method&lt;/code&gt; 라는 멤버 함수 가 있음을 확립합니다 . 그러나 당신은 여전히 정의해야 &lt;em&gt;두 &lt;/em&gt; &lt;code&gt;method&lt;/code&gt; 및 &lt;code&gt;bar&lt;/code&gt; 곳. ISO 표준에 따라 다음과 같은 하나의 소스 파일에 이니셜 라이저를 제공해야합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="aa5d48aae2a8d70a04aa98c11ed292ce987fe6e4" translate="yes" xml:space="preserve">
          <source>This declares &lt;code&gt;y&lt;/code&gt; as an array of pointers to characters:</source>
          <target state="translated">이것은 &lt;code&gt;y&lt;/code&gt; 를 문자에 대한 포인터의 배열로 선언 합니다.</target>
        </trans-unit>
        <trans-unit id="d5984e00c4ab800b89abb234fbcf6672036013a3" translate="yes" xml:space="preserve">
          <source>This declares &lt;code&gt;y&lt;/code&gt; as an array of such values.</source>
          <target state="translated">이것은 &lt;code&gt;y&lt;/code&gt; 를 그러한 값의 배열로 선언 합니다.</target>
        </trans-unit>
        <trans-unit id="1cddb3ab7751ac13216d638e5a732f674e3c8eeb" translate="yes" xml:space="preserve">
          <source>This declares &lt;code&gt;y&lt;/code&gt; with the type of what &lt;code&gt;x&lt;/code&gt; points to.</source>
          <target state="translated">이것은 &lt;code&gt;x&lt;/code&gt; 가 가리키는 유형으로 &lt;code&gt;y&lt;/code&gt; 를 선언 합니다.</target>
        </trans-unit>
        <trans-unit id="faab4d37a48d574a707b33549eb07bcf03d70747" translate="yes" xml:space="preserve">
          <source>This deduction was implemented as a possible extension to the originally proposed semantics for the C++11 standard, but was not part of the final standard, so it is disabled by default. This option is deprecated, and may be removed in a future version of G++.</source>
          <target state="translated">이 추론은 원래 제안 된 C ++ 11 표준 시맨틱에 대한 가능한 확장으로 구현되었지만 최종 표준의 일부는 아니므로 기본적으로 비활성화되어 있습니다. 이 옵션은 더 이상 사용되지 않으며 향후 버전의 G ++에서 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c879d3e8cb77a4fc10b608d3eb2285203202e61b" translate="yes" xml:space="preserve">
          <source>This defaults to &amp;lsquo;</source>
          <target state="translated">기본값은 '</target>
        </trans-unit>
        <trans-unit id="951c7938f85853a27d5c7d2c75acbe672c4155a1" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which &lt;code&gt;free&lt;/code&gt; is called on a non-heap pointer (e.g. an on-stack buffer, or a global).</source>
          <target state="translated">이 진단은 힙이 아닌 포인터 (예 : 스택 버퍼 또는 전역) 에서 &lt;code&gt;free&lt;/code&gt; 가 호출 되는 코드를 통한 경로에 대해 경고합니다 .</target>
        </trans-unit>
        <trans-unit id="6a1c5da5f3c1afd18968f173e07657e7302351a3" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which &lt;code&gt;longjmp&lt;/code&gt; is called to rewind to a &lt;code&gt;jmp_buf&lt;/code&gt; relating to a &lt;code&gt;setjmp&lt;/code&gt; call in a function that has returned.</source>
          <target state="translated">이 진단 은 반환 된 함수 의 &lt;code&gt;setjmp&lt;/code&gt; 호출 과 관련된 &lt;code&gt;jmp_buf&lt;/code&gt; 로 되감기 위해 &lt;code&gt;longjmp&lt;/code&gt; 가 호출 되는 코드를 통한 경로에 대해 경고합니다 .</target>
        </trans-unit>
        <trans-unit id="ac21f5dcf2d09b0cae014f784d56a15b158edf70" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which a &lt;code&gt;&amp;lt;stdio.h&amp;gt;&lt;/code&gt;&lt;code&gt;FILE *&lt;/code&gt; stream object is leaked.</source>
          <target state="translated">이 진단은 &lt;code&gt;&amp;lt;stdio.h&amp;gt;&lt;/code&gt; &lt;code&gt;FILE *&lt;/code&gt; 스트림 객체가 유출 된 코드를 통한 경로에 대해 경고합니다 .</target>
        </trans-unit>
        <trans-unit id="0839228138ef335cef6fd42894f9d1b11c2d55f0" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which a &lt;code&gt;FILE *&lt;/code&gt; can have &lt;code&gt;fclose&lt;/code&gt; called on it more than once.</source>
          <target state="translated">이 진단은 &lt;code&gt;FILE *&lt;/code&gt; 이 &lt;code&gt;fclose&lt;/code&gt; 를 두 번 이상 호출 할 수 있는 코드를 통한 경로에 대해 경고합니다 .</target>
        </trans-unit>
        <trans-unit id="69065a1147c573eab2950f6087ec4e566a67c9a6" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which a function known to be async-signal-unsafe (such as &lt;code&gt;fprintf&lt;/code&gt;) is called from a signal handler.</source>
          <target state="translated">이 진단은 신호 처리기에서 async-signal-unsafe로 알려진 함수 (예 : &lt;code&gt;fprintf&lt;/code&gt; )가 호출되는 코드를 통한 경로에 대해 경고 합니다.</target>
        </trans-unit>
        <trans-unit id="21154539e36b0472f9191b1b593654ca89275a98" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which a pointer allocated via &lt;code&gt;malloc&lt;/code&gt; is leaked.</source>
          <target state="translated">이 진단은 &lt;code&gt;malloc&lt;/code&gt; 을 통해 할당 된 포인터 가 유출 된 코드를 통한 경로에 대해 경고합니다 .</target>
        </trans-unit>
        <trans-unit id="11378cc6703dc8c65838b338e0ff6edde259a680" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which a pointer can have &lt;code&gt;free&lt;/code&gt; called on it more than once.</source>
          <target state="translated">이 진단은 포인터가 가질 수있는 코드를 통해 경로에 대한 경고 &lt;code&gt;free&lt;/code&gt; 번 이상 불려.</target>
        </trans-unit>
        <trans-unit id="8f9dc818bd4f109cde1dcf9e6dc005ab06fd45c6" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which a pointer is dereferenced that points to a variable in a stale stack frame.</source>
          <target state="translated">이 진단은 부실 스택 프레임의 변수를 가리키는 포인터가 역 참조되는 코드를 통한 경로에 대해 경고합니다.</target>
        </trans-unit>
        <trans-unit id="4ec5073148ee9d8b883f3325ddcb7fb0c4d813dc" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which a pointer is used after &lt;code&gt;free&lt;/code&gt; is called on it.</source>
          <target state="translated">이 진단은 &lt;code&gt;free&lt;/code&gt; 가 호출 된 후 포인터가 사용되는 코드를 통한 경로에 대해 경고 합니다.</target>
        </trans-unit>
        <trans-unit id="fad14ca24b0d656f13db98b7bf5a30df3b6adb8e" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which a possibly-NULL value is dereferenced.</source>
          <target state="translated">이 진단은 NULL 가능성이있는 값이 역 참조되는 코드를 통한 경로에 대해 경고합니다.</target>
        </trans-unit>
        <trans-unit id="f2a9ffda1fede774b63029feba567cccbb607842" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which a possibly-NULL value is passed to a function argument marked with &lt;code&gt;__attribute__((nonnull))&lt;/code&gt; as requiring a non-NULL value.</source>
          <target state="translated">이 진단은 NULL이 &lt;code&gt;__attribute__((nonnull))&lt;/code&gt; 값이 필요하므로 __attribute __ ((nonnull)) 로 표시된 함수 인수에 NULL 가능성이있는 값이 전달되는 코드를 통한 경로에 대해 경고 합니다.</target>
        </trans-unit>
        <trans-unit id="e828b08ddbeb8b76319f7c2f75bb782a082fba40" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which a security-sensitive value is written to an output file (such as writing a password to a log file).</source>
          <target state="translated">이 진단은 보안에 민감한 값이 출력 파일에 기록되는 코드를 통한 경로에 대해 경고합니다 (예 : 로그 파일에 암호 쓰기).</target>
        </trans-unit>
        <trans-unit id="3e36f8c84c0a1d9f61a3991f2dd1bc00f7fd261b" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which a value known to be NULL is dereferenced.</source>
          <target state="translated">이 진단은 NULL로 알려진 값이 역 참조되는 코드를 통한 경로에 대해 경고합니다.</target>
        </trans-unit>
        <trans-unit id="409bd5dd675e6fd0250a68f96b1c476f5f6aaaac" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which a value known to be NULL is passed to a function argument marked with &lt;code&gt;__attribute__((nonnull))&lt;/code&gt; as requiring a non-NULL value.</source>
          <target state="translated">이 진단은 NULL로 알려진 값이 NULL이 &lt;code&gt;__attribute__((nonnull))&lt;/code&gt; 값을 요구하므로 __attribute __ ((nonnull)) 로 표시된 함수 인수에 전달되는 코드를 통한 경로에 대해 경고 합니다.</target>
        </trans-unit>
        <trans-unit id="3abf773f1e1f311cc5692173d305b2448d2aae95" translate="yes" xml:space="preserve">
          <source>This diagnostic warns for paths through the code in which a value that could be under an attacker&amp;rsquo;s control is used as the index of an array access without being sanitized.</source>
          <target state="translated">이 진단은 공격자가 제어 할 수있는 값이 삭제되지 않고 배열 액세스의 인덱스로 사용되는 코드를 통한 경로에 대해 경고합니다.</target>
        </trans-unit>
        <trans-unit id="f436df92076512b77fe92317bd65f3d39a6a1f34" translate="yes" xml:space="preserve">
          <source>This distinction between lookup of dependent and non-dependent names is called two-stage (or dependent) name lookup. G++ implements it since version 3.4.</source>
          <target state="translated">종속 이름과 비 종속 이름 조회를 구분하는 것을 2 단계 (또는 종속) 이름 조회라고합니다. G ++는 3.4 버전부터 구현합니다.</target>
        </trans-unit>
        <trans-unit id="995cd6d9a17d418485ea5c0854d97ede3bab24ec" translate="yes" xml:space="preserve">
          <source>This document is meant to describe some of the GNU Objective-C features. It is not intended to teach you Objective-C. There are several resources on the Internet that present the language.</source>
          <target state="translated">이 문서는 GNU Objective-C 기능 중 일부를 설명합니다. Objective-C를 가르치기위한 것이 아닙니다. 인터넷에는 언어를 나타내는 몇 가지 자료가 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdd119f74d4b60b69c880f2448f8e713a89672c3" translate="yes" xml:space="preserve">
          <source>This enables</source>
          <target state="translated">이것은 가능</target>
        </trans-unit>
        <trans-unit id="0e09a1e0e5fd69eecab75ac51a34aa77d0b56b77" translate="yes" xml:space="preserve">
          <source>This enables all the warnings about constructions that some users consider questionable, and that are easy to avoid (or modify to prevent the warning), even in conjunction with macros. This also enables some language-specific warnings described in &lt;a href=&quot;c_002b_002b-dialect-options#C_002b_002b-Dialect-Options&quot;&gt;C++ Dialect Options&lt;/a&gt; and &lt;a href=&quot;objective_002dc-and-objective_002dc_002b_002b-dialect-options#Objective_002dC-and-Objective_002dC_002b_002b-Dialect-Options&quot;&gt;Objective-C and Objective-C++ Dialect Options&lt;/a&gt;.</source>
          <target state="translated">이를 통해 일부 사용자가 의심스럽고 매크로와 관련하여 피하기 쉬운 (또는 경고를 방지하도록 수정) 구성에 대한 모든 경고를 수행 할 수 있습니다. 또한 &lt;a href=&quot;c_002b_002b-dialect-options#C_002b_002b-Dialect-Options&quot;&gt;C ++ Dialect Options&lt;/a&gt; 및 &lt;a href=&quot;objective_002dc-and-objective_002dc_002b_002b-dialect-options#Objective_002dC-and-Objective_002dC_002b_002b-Dialect-Options&quot;&gt;Objective-C 및 Objective-C ++ Dialect Options에&lt;/a&gt; 설명 된 일부 언어 별 경고를 활성화 합니다.</target>
        </trans-unit>
        <trans-unit id="10c0c908290715ca8a4902d77d9d099c7818ae8f" translate="yes" xml:space="preserve">
          <source>This enables some extra warning flags that are not enabled by</source>
          <target state="translated">이로 인해 활성화되지 않은 추가 경고 플래그가 활성화됩니다</target>
        </trans-unit>
        <trans-unit id="b7f682e7e0e71202769284a5f29ad044bc452f34" translate="yes" xml:space="preserve">
          <source>This enables use of the locked load/store conditional extension to implement atomic memory built-in functions. Not available for ARC 6xx or ARC EM cores.</source>
          <target state="translated">이를 통해 고정 된로드 / 저장 조건부 확장을 사용하여 원자 메모리 내장 기능을 구현할 수 있습니다. ARC 6xx 또는 ARC EM 코어에는 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c5419693b2d5b267f6af681a001ebef359580125" translate="yes" xml:space="preserve">
          <source>This example assigns a function to two slots in the default table (using preprocessor macros defined elsewhere) and makes it the default for the &lt;code&gt;dct&lt;/code&gt; table:</source>
          <target state="translated">이 예제는 기본 테이블의 두 슬롯에 함수를 할당하고 (다른 곳에 정의 된 전 처리기 매크로 사용) &lt;code&gt;dct&lt;/code&gt; 테이블 의 기본값으로 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="1f3b599da5422ada6f5dd38b7f237af6695d9dff" translate="yes" xml:space="preserve">
          <source>This example creates an alias of &lt;code&gt;foo_v1&lt;/code&gt; with symbol name &lt;code&gt;symver_foo_v1&lt;/code&gt; which will be version &lt;code&gt;VERS_2&lt;/code&gt; of &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">이 예제 는 &lt;code&gt;foo&lt;/code&gt; 의 버전 &lt;code&gt;VERS_2&lt;/code&gt; 가 될 심볼 이름 &lt;code&gt;symver_foo_v1&lt;/code&gt; 을 사용 하여 &lt;code&gt;foo_v1&lt;/code&gt; 의 별칭을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="c93813cffc93eab710482b42f488b7bb9eff10b0" translate="yes" xml:space="preserve">
          <source>This example is perfectly equivalent to</source>
          <target state="translated">이 예는</target>
        </trans-unit>
        <trans-unit id="d3e949e9ca160ba7c9c4c48936e0ebb9e6567bec" translate="yes" xml:space="preserve">
          <source>This example renames the spec called &amp;lsquo;</source>
          <target state="translated">이 예제는 '스펙을'</target>
        </trans-unit>
        <trans-unit id="17efc27880dcdd0f4c6216f48227b6a6d20fb6a4" translate="yes" xml:space="preserve">
          <source>This example shows a simple assignment of a function to one vector in the default table (note that preprocessor macros may be used for chip-specific symbolic vector names):</source>
          <target state="translated">이 예제는 기본 테이블에서 하나의 벡터에 간단한 함수 할당을 보여줍니다 (전 처리기 매크로는 칩별 기호 벡터 이름에 사용될 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="f26530d0d01a4039c695b96fdd00747a2bd4aaea" translate="yes" xml:space="preserve">
          <source>This example uses the &lt;code&gt;cold&lt;/code&gt; label attribute to indicate the &lt;code&gt;ErrorHandling&lt;/code&gt; branch is unlikely to be taken and that the &lt;code&gt;ErrorHandling&lt;/code&gt; label is unused:</source>
          <target state="translated">이 예에서는 &lt;code&gt;cold&lt;/code&gt; 레이블 속성을 사용하여 &lt;code&gt;ErrorHandling&lt;/code&gt; 분기를 수행 할 가능성이없고 &lt;code&gt;ErrorHandling&lt;/code&gt; 레이블을 사용하지 않음 을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="0d3998b5540160156094948f334d5843b7f7f046" translate="yes" xml:space="preserve">
          <source>This example uses the &lt;code&gt;deprecated&lt;/code&gt; enumerator attribute to indicate the &lt;code&gt;oldval&lt;/code&gt; enumerator is deprecated:</source>
          <target state="translated">이 예제는 &lt;code&gt;deprecated&lt;/code&gt; 열거 자 속성을 사용하여 &lt;code&gt;oldval&lt;/code&gt; 열거자가 더 이상 사용되지 않음 을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="215cf5b89400516fe24140191ed923d2f09bd20b" translate="yes" xml:space="preserve">
          <source>This example uses the &lt;code&gt;fallthrough&lt;/code&gt; statement attribute to indicate that the</source>
          <target state="translated">이 예제는 &lt;code&gt;fallthrough&lt;/code&gt; 문 속성을 사용 하여</target>
        </trans-unit>
        <trans-unit id="7f112db8072d753fab06651e1a77010d4e9ebe45" translate="yes" xml:space="preserve">
          <source>This example:</source>
          <target state="translated">이 예는 :</target>
        </trans-unit>
        <trans-unit id="101c080fa9daf91a22a5c3746a65d406ce7eb831" translate="yes" xml:space="preserve">
          <source>This extension is not supported by GNU C++.</source>
          <target state="translated">이 확장은 GNU C ++에서 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f68ab67a136425be8901f00690401dbac036957d" translate="yes" xml:space="preserve">
          <source>This extension is sufficient such that</source>
          <target state="translated">이 확장은 충분합니다</target>
        </trans-unit>
        <trans-unit id="73b411a471e59249b2c99728d68299ae469991d2" translate="yes" xml:space="preserve">
          <source>This extension may not be very useful, but it makes the handling of &lt;code&gt;enum&lt;/code&gt; more consistent with the way &lt;code&gt;struct&lt;/code&gt; and &lt;code&gt;union&lt;/code&gt; are handled.</source>
          <target state="translated">이 확장은 그다지 유용하지는 않지만 &lt;code&gt;struct&lt;/code&gt; 와 &lt;code&gt;union&lt;/code&gt; 가 처리 되는 방식과 일치하게 &lt;code&gt;enum&lt;/code&gt; 를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="5605d8fdd1bc286fd5dac21c8bc67cef9a0ffdd5" translate="yes" xml:space="preserve">
          <source>This extra alignment does consume extra stack space, and generally increases code size. Code that is sensitive to stack space usage, such as embedded systems and operating system kernels, may want to reduce the preferred alignment to</source>
          <target state="translated">이 추가 정렬은 추가 스택 공간을 소비하며 일반적으로 코드 크기를 증가시킵니다. 임베디드 시스템 및 운영 체제 커널과 같이 스택 공간 사용에 민감한 코드는 우선 순위를</target>
        </trans-unit>
        <trans-unit id="e786b1c4f43cf240524b9e361ead5cdf6cfb070b" translate="yes" xml:space="preserve">
          <source>This facility is very useful if you want to initialize global variables which can be accessed by the program directly, without sending a message to the class first. The usual way to initialize global variables, in the &lt;code&gt;+initialize&lt;/code&gt; method, might not be useful because &lt;code&gt;+initialize&lt;/code&gt; is only called when the first message is sent to a class object, which in some cases could be too late.</source>
          <target state="translated">이 기능은 클래스에 메시지를 먼저 보내지 않고 프로그램에서 직접 액세스 할 수있는 전역 변수를 초기화하려는 경우에 매우 유용합니다. &lt;code&gt;+initialize&lt;/code&gt; 메서드 에서 전역 변수를 초기화하는 일반적인 방법 은 첫 번째 메시지가 클래스 객체로 전송 될 때만 &lt;code&gt;+initialize&lt;/code&gt; 가 호출 되기 때문에 유용하지 않을 수 있으며 , 경우에 따라 너무 늦을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5301c866b6ac40f65d4bd67792ec94bc126ba1c2" translate="yes" xml:space="preserve">
          <source>This feature is especially useful for ranges of ASCII character codes:</source>
          <target state="translated">이 기능은 특히 ASCII 문자 코드 범위에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="4b7eade7c951c9b37c2e852a014cd189c7b49192" translate="yes" xml:space="preserve">
          <source>This feature is especially useful in making macro definitions &amp;ldquo;safe&amp;rdquo; (so that they evaluate each operand exactly once). For example, the &amp;ldquo;maximum&amp;rdquo; function is commonly defined as a macro in standard C as follows:</source>
          <target state="translated">이 기능은 매크로 정의를 &quot;안전&quot;하게 만드는 데 특히 유용합니다 (따라서 각 피연산자를 정확히 한 번 평가합니다). 예를 들어, &quot;최대&quot;기능은 일반적으로 다음과 같이 표준 C에서 매크로로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="cf86da6582486ace0550eafa0f42f9a96d5c2a2b" translate="yes" xml:space="preserve">
          <source>This feature is intended for program-generated code that may contain unused labels, but which is compiled with</source>
          <target state="translated">이 기능은 사용하지 않는 레이블이 포함되어 있지만 다음과 같이 컴파일 된 프로그램 생성 코드를위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="0c1076e2c167a24356587893b7b6c8a8375aa3a4" translate="yes" xml:space="preserve">
          <source>This feature is not enabled by default. Specifying</source>
          <target state="translated">이 기능은 기본적으로 활성화되어 있지 않습니다. 지정</target>
        </trans-unit>
        <trans-unit id="9420f79a451b4efac8e962af58f495ad7ac181c7" translate="yes" xml:space="preserve">
          <source>This feature is used in automatic updating of makefiles.</source>
          <target state="translated">이 기능은 makefile의 자동 업데이트에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a8f11fa97afc8a9f70ed0e1fb16cbd9bede804da" translate="yes" xml:space="preserve">
          <source>This file documents the use of the GNU compilers.</source>
          <target state="translated">이 파일은 GNU 컴파일러의 사용법을 문서화합니다.</target>
        </trans-unit>
        <trans-unit id="6c21848b1d55804d72743a6693d101b63cd47544" translate="yes" xml:space="preserve">
          <source>This flag attempts to use visibility settings to make GCC&amp;rsquo;s C++ linkage model compatible with that of Microsoft Visual Studio.</source>
          <target state="translated">이 플래그는 가시성 설정을 사용하여 GCC의 C ++ 연결 모델을 Microsoft Visual Studio의 C ++ 연결 모델과 호환되도록합니다.</target>
        </trans-unit>
        <trans-unit id="2db7dd43d8e02c47fc0a85c5c3e38b591f0a3877" translate="yes" xml:space="preserve">
          <source>This flag does not have a negative form, because it specifies a three-way choice.</source>
          <target state="translated">이 플래그는 3 방향 선택을 지정하므로 음수 형식이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="c1b1af85f2a6f09c7615fb9953621e2594fc2498" translate="yes" xml:space="preserve">
          <source>This flag is disabled by default.</source>
          <target state="translated">이 플래그는 기본적으로 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef23e3f8b62106f744c396a536baec3f85486f03" translate="yes" xml:space="preserve">
          <source>This flag is enabled by default at</source>
          <target state="translated">이 플래그는 기본적으로</target>
        </trans-unit>
        <trans-unit id="7fb1ed0a0aaf28dac933fdc7dd7aadf9b8292636" translate="yes" xml:space="preserve">
          <source>This flag is enabled by default for</source>
          <target state="translated">이 플래그는 기본적으로 활성화되어 있습니다</target>
        </trans-unit>
        <trans-unit id="c025ee0fe2aca271d6bc8b1c3c04c156ee4d07a6" translate="yes" xml:space="preserve">
          <source>This flag is included in</source>
          <target state="translated">이 깃발은</target>
        </trans-unit>
        <trans-unit id="03d3b3aedc1d8ba8a1241588ebdb03f76fc4bd8e" translate="yes" xml:space="preserve">
          <source>This function attribute indicates that an argument in a call to the function is expected to be an explicit &lt;code&gt;NULL&lt;/code&gt;. The attribute is only valid on variadic functions. By default, the sentinel is expected to be the last argument of the function call. If the optional &lt;var&gt;position&lt;/var&gt; argument is specified to the attribute, the sentinel must be located at &lt;var&gt;position&lt;/var&gt; counting backwards from the end of the argument list.</source>
          <target state="translated">이 함수 속성은 함수 호출의 인수가 명시적인 &lt;code&gt;NULL&lt;/code&gt; 이어야 함을 나타냅니다 . 이 속성은 가변 함수에서만 유효합니다. 기본적으로 센티넬은 함수 호출의 마지막 인수 일 것으로 예상됩니다. 선택적 &lt;var&gt;position&lt;/var&gt; 인수가 속성에 지정된 경우, 센티넬은 인수 목록의 끝에서부터 거꾸로 세는 &lt;var&gt;position&lt;/var&gt; 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="3eace8a8897f53986baecdd557c9bed95be5eb95" translate="yes" xml:space="preserve">
          <source>This function attribute prevents a function from being considered for cloning&amp;mdash;a mechanism that produces specialized copies of functions and which is (currently) performed by interprocedural constant propagation.</source>
          <target state="translated">이 함수 속성은 함수가 복제를 위해 고려되는 것을 방지합니다.이 함수는 특수한 함수 사본을 생성하고 (현재) 프로 시저 간 상수 전파에 의해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="0185a8637e8440da0db0d53dd62eb7167b8eb84c" translate="yes" xml:space="preserve">
          <source>This function attribute prevents a function from being considered for inlining. If the function does not have side effects, there are optimizations other than inlining that cause function calls to be optimized away, although the function call is live. To keep such calls from being optimized away, put</source>
          <target state="translated">이 함수 속성은 함수가 인라인으로 간주되지 않도록합니다. 함수에 부작용이없는 경우 함수 호출이 활성화되어 있지만 인라인 이외의 최적화를 통해 함수 호출을 최적화 할 수 있습니다. 이러한 통화가 최적화되지 않도록하려면</target>
        </trans-unit>
        <trans-unit id="c2eae0ac690e115a386b22c2c033e3d207f73749" translate="yes" xml:space="preserve">
          <source>This function attribute prevents a functions from being merged with another semantically equivalent function.</source>
          <target state="translated">이 함수 속성은 함수가 의미 적으로 동등한 다른 함수와 병합되지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="cfa0a9aeda6626f962564eda6d7bc9ae77a9f9e7" translate="yes" xml:space="preserve">
          <source>This function causes the program to exit abnormally. GCC implements this function by using a target-dependent mechanism (such as intentionally executing an illegal instruction) or by calling &lt;code&gt;abort&lt;/code&gt;. The mechanism used may vary from release to release so you should not rely on any particular implementation.</source>
          <target state="translated">이 기능은 프로그램을 비정상적으로 종료시킵니다. GCC는 의도적으로 잘못된 명령을 실행하는 것과 같은 대상 종속 메커니즘을 사용하거나 &lt;code&gt;abort&lt;/code&gt; 를 호출하여이 기능을 구현합니다 . 사용되는 메커니즘은 릴리스마다 다를 수 있으므로 특정 구현에 의존해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="e524eeb8ecfc131aac67b7d8a458ea88f19f0eed" translate="yes" xml:space="preserve">
          <source>This function does the reverse of &lt;code&gt;__builtin_extract_return_addr&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;__builtin_extract_return_addr&lt;/code&gt; 과 반대입니다 .</target>
        </trans-unit>
        <trans-unit id="95420bd588ca997857f34739b8ed2c2d2dc9b407" translate="yes" xml:space="preserve">
          <source>This function has the same semantics as &lt;code&gt;__builtin_expect&lt;/code&gt;, but the caller provides the expected probability that &lt;var&gt;exp&lt;/var&gt; == &lt;var&gt;c&lt;/var&gt;. The last argument, &lt;var&gt;probability&lt;/var&gt;, is a floating-point value in the range 0.0 to 1.0, inclusive. The &lt;var&gt;probability&lt;/var&gt; argument must be constant floating-point expression.</source>
          <target state="translated">이 함수는 &lt;code&gt;__builtin_expect&lt;/code&gt; 와 동일한 의미를 갖지만 호출자는 &lt;var&gt;exp&lt;/var&gt; == &lt;var&gt;c&lt;/var&gt; 인 예상 확률을 제공합니다 . 마지막 인수 인 &lt;var&gt;probability&lt;/var&gt; 은 0.0에서 1.0 사이의 부동 소수점 값입니다. &lt;var&gt;probability&lt;/var&gt; 인수는 상수 부동 소수점 표현해야합니다.</target>
        </trans-unit>
        <trans-unit id="dad1828780de0ec7cb4d2651f782e659f7669888" translate="yes" xml:space="preserve">
          <source>This function is a &lt;code&gt;nop&lt;/code&gt; on the PowerPC platform and is included solely to maintain API compatibility with the x86 builtins.</source>
          <target state="translated">이 기능은 PowerPC 플랫폼 의 &lt;code&gt;nop&lt;/code&gt; 이며 x86 내장과의 API 호환성을 유지하기 위해 포함되었습니다.</target>
        </trans-unit>
        <trans-unit id="cc1de5cdd4f293c4a48810df067ace8dfe7d6d91" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;code&gt;__builtin_return_address&lt;/code&gt;, but it returns the address of the function frame rather than the return address of the function. Calling &lt;code&gt;__builtin_frame_address&lt;/code&gt; with a value of &lt;code&gt;0&lt;/code&gt; yields the frame address of the current function, a value of &lt;code&gt;1&lt;/code&gt; yields the frame address of the caller of the current function, and so forth.</source>
          <target state="translated">이 함수는 &lt;code&gt;__builtin_return_address&lt;/code&gt; 와 비슷 하지만 함수의 반환 주소가 아니라 함수 프레임의 주소를 반환합니다. 값이 &lt;code&gt;0&lt;/code&gt; 인 &lt;code&gt;__builtin_frame_address&lt;/code&gt; 를 호출 하면 현재 함수 의 프레임 주소가 생성되고 값이 &lt;code&gt;1&lt;/code&gt; 이면 현재 함수 호출자의 프레임 주소가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="a0b7342f9f274d12e577265101ded1a69579dafe" translate="yes" xml:space="preserve">
          <source>This function is the equivalent of the &lt;code&gt;__FUNCTION__&lt;/code&gt; symbol and returns an address constant pointing to the name of the function from which the built-in was invoked, or the empty string if the invocation is not at function scope. When used as a C++ default argument for a function &lt;var&gt;F&lt;/var&gt;, it returns the name of &lt;var&gt;F&lt;/var&gt;&amp;rsquo;s caller or the empty string if the call was not made at function scope.</source>
          <target state="translated">이 함수는 &lt;code&gt;__FUNCTION__&lt;/code&gt; 기호와 동일 하며 내장 함수가 호출 된 함수의 이름을 가리키는 주소 상수 또는 함수 범위에 있지 않은 경우 빈 문자열을 반환합니다. 함수 &lt;var&gt;F&lt;/var&gt; 에 대한 C ++ 기본 인수로 사용되면 함수 범위에서 호출되지 않은 경우 &lt;var&gt;F&lt;/var&gt; 의 호출자 이름 또는 빈 문자열을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="86e1f1b709cdf3bbdf962d668f4ccf9699d7ee2e" translate="yes" xml:space="preserve">
          <source>This function is the equivalent of the preprocessor &lt;code&gt;__FILE__&lt;/code&gt; macro and returns an address constant pointing to the file name containing the invocation of the built-in, or the empty string if the invocation is not at function scope. When used as a C++ default argument for a function &lt;var&gt;F&lt;/var&gt;, it returns the file name of the call to &lt;var&gt;F&lt;/var&gt; or the empty string if the call was not made at function scope.</source>
          <target state="translated">이 함수는 전 처리기 &lt;code&gt;__FILE__&lt;/code&gt; 매크로와 동일 하며 내장 함수의 호출을 포함하는 파일 이름을 가리키는 주소 상수 또는 호출이 함수 범위에 있지 않은 경우 빈 문자열을 리턴합니다. 함수 &lt;var&gt;F&lt;/var&gt; 에 대한 C ++ 기본 인수로 사용되면 함수 범위에서 호출되지 않은 경우 호출의 파일 이름을 &lt;var&gt;F&lt;/var&gt; 또는 빈 문자열로 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="bc294999db99ded1854e8f5e1e4b8ef679553e0d" translate="yes" xml:space="preserve">
          <source>This function is the equivalent of the preprocessor &lt;code&gt;__LINE__&lt;/code&gt; macro and returns a constant integer expression that evaluates to the line number of the invocation of the built-in. When used as a C++ default argument for a function &lt;var&gt;F&lt;/var&gt;, it returns the line number of the call to &lt;var&gt;F&lt;/var&gt;.</source>
          <target state="translated">이 함수는 전 처리기 &lt;code&gt;__LINE__&lt;/code&gt; 매크로와 동일 하며 내장 호출의 행 번호로 평가되는 상수 정수 표현식을 리턴합니다. 함수에 대한 C ++ 기본 인수로 사용하는 경우 &lt;var&gt;F&lt;/var&gt; ,이 호출의 행 번호를 반환 &lt;var&gt;F&lt;/var&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="b4965b81131ff05edb23e4ac2cd86ee54e42a982" translate="yes" xml:space="preserve">
          <source>This function is used to flush the processor&amp;rsquo;s instruction cache for the region of memory between &lt;var&gt;begin&lt;/var&gt; inclusive and &lt;var&gt;end&lt;/var&gt; exclusive. Some targets require that the instruction cache be flushed, after modifying memory containing code, in order to obtain deterministic behavior.</source>
          <target state="translated">이 기능은 &lt;var&gt;begin&lt;/var&gt; 포함과 &lt;var&gt;end&lt;/var&gt; 독점 사이의 메모리 영역에 대한 프로세서의 명령 캐시를 플러시하는 데 사용됩니다 . 일부 대상에서는 결정적 동작을 얻기 위해 코드가 포함 된 메모리를 수정 한 후 명령 캐시를 플러시해야합니다.</target>
        </trans-unit>
        <trans-unit id="a3fe2b1a97278967d04d0a166eb411721a963d62" translate="yes" xml:space="preserve">
          <source>This function is used to minimize cache-miss latency by moving data into a cache before it is accessed. You can insert calls to &lt;code&gt;__builtin_prefetch&lt;/code&gt; into code for which you know addresses of data in memory that is likely to be accessed soon. If the target supports them, data prefetch instructions are generated. If the prefetch is done early enough before the access then the data will be in the cache by the time it is accessed.</source>
          <target state="translated">이 기능은 액세스하기 전에 데이터를 캐시로 이동하여 캐시 누락 대기 시간을 최소화하는 데 사용됩니다. &lt;code&gt;__builtin_prefetch&lt;/code&gt; 호출을 코드에 삽입 하면 곧 액세스 할 수있는 메모리의 데이터 주소를 알 수 있습니다. 대상이 지원하는 경우 데이터 프리 페치 명령어가 생성됩니다. 프리 페치가 액세스 전에 충분히 일찍 수행되면 데이터는 액세스 될 때까지 캐시에있게됩니다.</target>
        </trans-unit>
        <trans-unit id="8919a966ee8dd6af4dbf0f92a03208a705be1969" translate="yes" xml:space="preserve">
          <source>This function restores the stack context in &lt;var&gt;buf&lt;/var&gt;, saved by a previous call to &lt;code&gt;__builtin_setjmp&lt;/code&gt;. After &lt;code&gt;__builtin_longjmp&lt;/code&gt; is finished, the program resumes execution as if the matching &lt;code&gt;__builtin_setjmp&lt;/code&gt; returns the value &lt;var&gt;val&lt;/var&gt;, which must be 1.</source>
          <target state="translated">이 함수는 &lt;code&gt;__builtin_setjmp&lt;/code&gt; 에 대한 이전 호출로 저장된 스택 컨텍스트를 &lt;var&gt;buf&lt;/var&gt; 로 복원합니다 . &lt;code&gt;__builtin_longjmp&lt;/code&gt; 가 완료된 후 일치하는 &lt;code&gt;__builtin_setjmp&lt;/code&gt; 가 값 &lt;var&gt;val&lt;/var&gt; 을 반환 하는 것처럼 프로그램은 실행을 재개 합니다 (1이어야 함).</target>
        </trans-unit>
        <trans-unit id="d321f2ee318af6c2dd764431e17a984bfaa18ec1" translate="yes" xml:space="preserve">
          <source>This function returns a pointer to data describing how to return whatever value is returned by &lt;var&gt;function&lt;/var&gt;. The data is saved in a block of memory allocated on the stack.</source>
          <target state="translated">이 함수는 function에서 반환 한 값을 반환하는 방법을 설명하는 데이터에 대한 포인터를 반환 &lt;var&gt;function&lt;/var&gt; . 데이터는 스택에 할당 된 메모리 블록에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="b71039af8a1d11c8d83124bcb2f420630a5a1ce8" translate="yes" xml:space="preserve">
          <source>This function returns a positive integer if the run-time CPU is of type &lt;var&gt;cpuname&lt;/var&gt; and returns &lt;code&gt;0&lt;/code&gt; otherwise. The following CPU names can be detected:</source>
          <target state="translated">이 함수는 런타임 CPU가 &lt;var&gt;cpuname&lt;/var&gt; 유형 인 경우 양의 정수를 리턴하고 그렇지 않으면 &lt;code&gt;0&lt;/code&gt; 을 리턴합니다 . 다음과 같은 CPU 이름을 감지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dfdc7462f357d955c59d1a21b41e74d15ee8d83b" translate="yes" xml:space="preserve">
          <source>This function returns a positive integer if the run-time CPU supports &lt;var&gt;feature&lt;/var&gt; and returns &lt;code&gt;0&lt;/code&gt; otherwise. The following features can be detected:</source>
          <target state="translated">이 기능은 실행 시간 CPU가 지원하는 경우 양의 정수를 반환 &lt;var&gt;feature&lt;/var&gt; 및 반환 &lt;code&gt;0&lt;/code&gt; 을 , 그렇지. 다음과 같은 기능을 감지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5bf6bbb0ff1bf6eb1b3c656f4cca7e925e10e2a5" translate="yes" xml:space="preserve">
          <source>This function returns a value of &lt;code&gt;1&lt;/code&gt; if the run-time CPU is of type &lt;var&gt;cpuname&lt;/var&gt; and returns &lt;code&gt;0&lt;/code&gt; otherwise</source>
          <target state="translated">이 함수는 런타임 CPU가 &lt;var&gt;cpuname&lt;/var&gt; 유형 인 경우 값 &lt;code&gt;1&lt;/code&gt; 을 리턴하고 그렇지 않으면 &lt;code&gt;0&lt;/code&gt; 을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="27852be90385733f670b1f53118c6fb5c9f99598" translate="yes" xml:space="preserve">
          <source>This function returns a value of &lt;code&gt;1&lt;/code&gt; if the run-time CPU supports the HWCAP feature &lt;var&gt;feature&lt;/var&gt; and returns &lt;code&gt;0&lt;/code&gt; otherwise.</source>
          <target state="translated">이 기능은 값 반환 &lt;code&gt;1&lt;/code&gt; 런타임 CPU가 HWCAP 기능을 지원하는 경우 &lt;var&gt;feature&lt;/var&gt; 반환 &lt;code&gt;0&lt;/code&gt; , 그렇지.</target>
        </trans-unit>
        <trans-unit id="213b2aa2268e34e2f3e902cc0c4fc9d3fae623d8" translate="yes" xml:space="preserve">
          <source>This function returns its first argument, and allows the compiler to assume that the returned pointer is at least &lt;var&gt;align&lt;/var&gt; bytes aligned. This built-in can have either two or three arguments, if it has three, the third argument should have integer type, and if it is nonzero means misalignment offset. For example:</source>
          <target state="translated">이 함수는 첫 번째 인수를 반환하고 컴파일러가 반환 된 포인터가 적어도 &lt;var&gt;align&lt;/var&gt; 바이트 정렬 이라고 가정 할 수 있도록합니다 . 이 내장은 두 개 또는 세 개의 인수를 가질 수 있으며, 세 개가있는 경우 세 번째 인수는 정수 유형이어야하며, 0이 아닌 경우 정렬 불량 오프셋을 의미합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0dc83a066fc8a8ed7ae8cb097e4deaf1084d4a2b" translate="yes" xml:space="preserve">
          <source>This function returns the return address of the current function, or of one of its callers. The &lt;var&gt;level&lt;/var&gt; argument is number of frames to scan up the call stack. A value of &lt;code&gt;0&lt;/code&gt; yields the return address of the current function, a value of &lt;code&gt;1&lt;/code&gt; yields the return address of the caller of the current function, and so forth. When inlining the expected behavior is that the function returns the address of the function that is returned to. To work around this behavior use the &lt;code&gt;noinline&lt;/code&gt; function attribute.</source>
          <target state="translated">이 함수는 현재 함수 또는 호출자 중 하나의 반환 주소를 반환합니다. &lt;var&gt;level&lt;/var&gt; 인수는 호출 스택을 검사 할 프레임 수입니다. 값이 &lt;code&gt;0&lt;/code&gt; 이면 현재 함수 의 반환 주소가 생성되고 값이 &lt;code&gt;1&lt;/code&gt; 이면 현재 함수 호출자의 반환 주소가 생성됩니다. 예상되는 동작을 인라인 할 때 함수는 반환 된 함수의 주소를 반환합니다. 이 문제를 해결하려면 &lt;code&gt;noinline&lt;/code&gt; 함수 속성을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="a8c68121ab03a5059f1b4257b6c2b3c7234cacf3" translate="yes" xml:space="preserve">
          <source>This function runs the CPU detection code to check the type of CPU and the features supported. This built-in function needs to be invoked along with the built-in functions to check CPU type and features, &lt;code&gt;__builtin_cpu_is&lt;/code&gt; and &lt;code&gt;__builtin_cpu_supports&lt;/code&gt;, only when used in a function that is executed before any constructors are called. The CPU detection code is automatically executed in a very high priority constructor.</source>
          <target state="translated">이 기능은 CPU 감지 코드를 실행하여 CPU 유형 및 지원되는 기능을 확인합니다. 이 내장 함수는 내장 함수와 함께 호출하여 CPU 유형 및 기능 ( &lt;code&gt;__builtin_cpu_is&lt;/code&gt; 및 &lt;code&gt;__builtin_cpu_supports&lt;/code&gt; ) 을 확인 해야합니다. 이는 생성자가 호출되기 전에 실행되는 함수에 사용될 때만 가능합니다. CPU 감지 코드는 우선 순위가 높은 생성자에서 자동으로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="0f58a4af763a22a01173db535b0e84cbf679fc29" translate="yes" xml:space="preserve">
          <source>This function saves the current stack context in &lt;var&gt;buf&lt;/var&gt;. &lt;code&gt;__builtin_setjmp&lt;/code&gt; returns 0 when returning directly, and 1 when returning from &lt;code&gt;__builtin_longjmp&lt;/code&gt; using the same &lt;var&gt;buf&lt;/var&gt;.</source>
          <target state="translated">이 함수는 현재 스택 컨텍스트를 &lt;var&gt;buf&lt;/var&gt; 에 저장합니다 . &lt;code&gt;__builtin_setjmp&lt;/code&gt; 는 직접 반환하면 0을 반환 하고 동일한 &lt;var&gt;buf&lt;/var&gt; 를 사용하여 &lt;code&gt;__builtin_longjmp&lt;/code&gt; 에서 반환하면 1을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="69e7849ff4cbe4d496d1ff31f3b20212a375c758" translate="yes" xml:space="preserve">
          <source>This function, if given a string literal all of which would have been consumed by &lt;code&gt;strtol&lt;/code&gt;, is evaluated early enough that it is considered a compile-time constant.</source>
          <target state="translated">이 함수는 문자열 리터럴이 &lt;code&gt;strtol&lt;/code&gt; 에 의해 소비되었을 경우 컴파일 타임 상수로 간주 될 수있을 정도로 일찍 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="1b248fa09ed8681d529d9f22aaa2c70eb149364a" translate="yes" xml:space="preserve">
          <source>This has symmetry with normal static arrays, in that an array of unknown size is also written with &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">알 수없는 크기의 배열도 &lt;code&gt;[]&lt;/code&gt; 로 작성되므로 일반 정적 배열과 대칭이 됩니다.</target>
        </trans-unit>
        <trans-unit id="8646e863ba587311636afd56af70cd4124b64132" translate="yes" xml:space="preserve">
          <source>This has the same effect as the proper number of individual &lt;code&gt;case&lt;/code&gt; labels, one for each integer value from &lt;var&gt;low&lt;/var&gt; to &lt;var&gt;high&lt;/var&gt;, inclusive.</source>
          <target state="translated">이는 개별의 적절한 개수와 동일한 효과를 갖는 &lt;code&gt;case&lt;/code&gt; 라벨의 각각의 정수 값에 대해 하나의 &lt;var&gt;low&lt;/var&gt; 에 &lt;var&gt;high&lt;/var&gt; , 포함한다.</target>
        </trans-unit>
        <trans-unit id="83169887a69a2b08bab1ebc54a9588ce551d545e" translate="yes" xml:space="preserve">
          <source>This hook is generally reserved for &amp;ldquo;Foundation&amp;rdquo; libraries such as GNUstep Base, which use it to implement their high-level method forwarding API, typically based around the &lt;code&gt;forwardInvocation:&lt;/code&gt; method. So, unless you are implementing your own &amp;ldquo;Foundation&amp;rdquo; library, you should not set this hook.</source>
          <target state="translated">이 후크는 일반적으로 GNUStep Base와 같은 &quot;Foundation&quot;라이브러리 용으로 예약되어 있으며,이를 사용하여 일반적으로 &lt;code&gt;forwardInvocation:&lt;/code&gt; 메소드를 기반으로하는 상위 레벨 메소드 전달 API를 구현합니다 . 따라서 자체 &quot;Foundation&quot;라이브러리를 구현하지 않는 한이 후크를 설정하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="968e5049fab7f4bdf3b3205d394535ad648ef39e" translate="yes" xml:space="preserve">
          <source>This i386 code demonstrates a case that does not use (or require) the &lt;code&gt;volatile&lt;/code&gt; qualifier. If it is performing assertion checking, this code uses &lt;code&gt;asm&lt;/code&gt; to perform the validation. Otherwise, &lt;code&gt;dwRes&lt;/code&gt; is unreferenced by any code. As a result, the optimizers can discard the &lt;code&gt;asm&lt;/code&gt; statement, which in turn removes the need for the entire &lt;code&gt;DoCheck&lt;/code&gt; routine. By omitting the &lt;code&gt;volatile&lt;/code&gt; qualifier when it isn&amp;rsquo;t needed you allow the optimizers to produce the most efficient code possible.</source>
          <target state="translated">이 i386 코드는 &lt;code&gt;volatile&lt;/code&gt; 한정자를 사용하지 않거나 필요로하는 경우를 보여줍니다 . 어설 션 검사 를 수행하는 경우이 코드는 &lt;code&gt;asm&lt;/code&gt; 을 사용하여 유효성 검사를 수행합니다. 그렇지 않으면 모든 코드 에서 &lt;code&gt;dwRes&lt;/code&gt; 를 참조하지 않습니다. 결과적으로 옵티마이 저는 &lt;code&gt;asm&lt;/code&gt; 문을 폐기 할 수 있으므로 전체 &lt;code&gt;DoCheck&lt;/code&gt; 루틴 이 필요하지 않습니다 . 필요하지 않은 경우 &lt;code&gt;volatile&lt;/code&gt; 한정자 를 생략하면 옵티마이 저가 가능한 가장 효율적인 코드를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="808f6f4a24d0e37061696da154166d6ac70ac880" translate="yes" xml:space="preserve">
          <source>This implies that the choice of angle brackets or double quotes in an &amp;lsquo;</source>
          <target state="translated">이것은 꺾쇠 괄호 또는 큰 따옴표를 '</target>
        </trans-unit>
        <trans-unit id="e1db8a962787e8ba6275999130017fe253b89359" translate="yes" xml:space="preserve">
          <source>This inserts an instruction sequence that takes exactly &lt;var&gt;cycles&lt;/var&gt; cycles (between 0 and about 17E9) to complete. The inserted sequence may use jumps, loops, or no-ops, and does not interfere with any other instructions. Note that &lt;var&gt;cycles&lt;/var&gt; must be a compile-time constant integer - that is, you must pass a number, not a variable that may be optimized to a constant later. The number of cycles delayed by this builtin is exact.</source>
          <target state="translated">이것은 정확히 &lt;var&gt;cycles&lt;/var&gt; 사이클 (0에서 약 17E9 사이) 이 걸리는 명령 시퀀스를 삽입합니다 . 삽입 된 시퀀스는 점프, 루프 또는 no-ops를 사용할 수 있으며 다른 명령어를 방해하지 않습니다. 참고 &lt;var&gt;cycles&lt;/var&gt; 컴파일 타임 상수의 정수 여야합니다 -, 당신은 숫자가 아니라 나중에 일정을 최적화 할 수있는 변수를 전달해야합니다. 이 내장에 의해 지연된 사이클 수는 정확합니다.</target>
        </trans-unit>
        <trans-unit id="8e5d39ccb505b20a7de4368cf8c74cd0bd9b0602" translate="yes" xml:space="preserve">
          <source>This instrumentation is also done for functions expanded inline in other functions. The profiling calls indicate where, conceptually, the inline function is entered and exited. This means that addressable versions of such functions must be available. If all your uses of a function are expanded inline, this may mean an additional expansion of code size. If you use &lt;code&gt;extern inline&lt;/code&gt; in your C code, an addressable version of such functions must be provided. (This is normally the case anyway, but if you get lucky and the optimizer always expands the functions inline, you might have gotten away without providing static copies.)</source>
          <target state="translated">이 계측은 다른 기능에서 인라인으로 확장 된 기능에 대해서도 수행됩니다. 프로파일 링 호출은 개념적으로 인라인 함수가 입력 및 종료되는 위치를 나타냅니다. 즉, 해당 기능의 주소 지정 가능 버전을 사용할 수 있어야합니다. 함수의 모든 사용이 인라인으로 확장되면 코드 크기가 추가로 확장 될 수 있습니다. C 코드에서 &lt;code&gt;extern inline&lt;/code&gt; 을 사용하는 경우 이러한 함수의 주소 지정 가능 버전을 제공해야합니다. (이것은 일반적으로 어쨌든 사실이지만, 운이 좋으면 옵티마이 저가 항상 함수를 인라인으로 확장하면 정적 사본을 제공하지 않고 사라질 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="c5f757d83923a2f4750aa24fef819d39fd7c764d" translate="yes" xml:space="preserve">
          <source>This interface allows either &lt;code&gt;int *&lt;/code&gt; or &lt;code&gt;union wait *&lt;/code&gt; arguments to be passed, using the &lt;code&gt;int *&lt;/code&gt; calling convention. The program can call &lt;code&gt;wait&lt;/code&gt; with arguments of either type:</source>
          <target state="translated">이 인터페이스는 &lt;code&gt;int *&lt;/code&gt; 호출 규칙을 사용하여 &lt;code&gt;int *&lt;/code&gt; 또는 &lt;code&gt;union wait *&lt;/code&gt; 인수를 전달할 수 있습니다 . 프로그램은 다음 유형의 인수로 &lt;code&gt;wait&lt;/code&gt; 를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7fa6e20d0ad9607fec20c7fa93797725b39e7225" translate="yes" xml:space="preserve">
          <source>This interrupt service routine is interruptible after &lt;code&gt;PSW.GIE&lt;/code&gt; (global interrupt enable) is set. This allows interrupt service routine to finish some short critical code before enabling interrupts.</source>
          <target state="translated">이 인터럽트 서비스 루틴은 &lt;code&gt;PSW.GIE&lt;/code&gt; (글로벌 인터럽트 활성화)가 설정된 후에 인터럽트 가능합니다. 이를 통해 인터럽트를 활성화하기 전에 인터럽트 서비스 루틴이 짧은 중요 코드를 완료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f39211b611ed78b8a4cda99c2d1b9f90b52f7b8c" translate="yes" xml:space="preserve">
          <source>This interrupt service routine is interruptible.</source>
          <target state="translated">이 인터럽트 서비스 루틴은 인터럽트 가능합니다.</target>
        </trans-unit>
        <trans-unit id="8cc90603ecbdd7ae47dd33c675b43de2d13b14cf" translate="yes" xml:space="preserve">
          <source>This interrupt service routine is not interruptible.</source>
          <target state="translated">이 인터럽트 서비스 루틴은 인터럽트 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="98ed58186125da377f3558ec8512de6f6dbbf8ae" translate="yes" xml:space="preserve">
          <source>This invokes all subprograms of &lt;code&gt;gcc&lt;/code&gt; under &amp;lsquo;</source>
          <target state="translated">이것은 '아래 에 &lt;code&gt;gcc&lt;/code&gt; 의 모든 서브 프로그램을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="36c68f63258bf418514a8d6d7b59387b054a571e" translate="yes" xml:space="preserve">
          <source>This is a 24-bit address space that linearizes flash and RAM: If the high bit of the address is set, data is read from RAM using the lower two bytes as RAM address. If the high bit of the address is clear, data is read from flash with &lt;code&gt;RAMPZ&lt;/code&gt; set according to the high byte of the address. See &lt;a href=&quot;avr-built_002din-functions#AVR-Built_002din-Functions&quot;&gt;&lt;code&gt;__builtin_avr_flash_segment&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">플래시와 RAM을 선형화하는 24 비트 주소 공간입니다. 주소의 높은 비트가 설정되면 하위 2 바이트를 RAM 주소로 사용하여 RAM에서 데이터를 읽습니다. 주소의 높은 비트가 &lt;code&gt;RAMPZ&lt;/code&gt; , 주소의 높은 바이트에 따라 RAMPZ가 설정된 상태 에서 플래시에서 데이터를 읽습니다 . &lt;a href=&quot;avr-built_002din-functions#AVR-Built_002din-Functions&quot;&gt; &lt;code&gt;__builtin_avr_flash_segment&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c3eadc5a720e67193fff3510f3b6d516e5846adb" translate="yes" xml:space="preserve">
          <source>This is a debugging flag. When used in conjunction with</source>
          <target state="translated">이것은 디버깅 플래그입니다. 와 함께 사용될 때</target>
        </trans-unit>
        <trans-unit id="c173adebd0002ff9b3abf598cd2d9f90729d1e99" translate="yes" xml:space="preserve">
          <source>This is a literal string that is the template for the assembler code. It is a combination of fixed text and tokens that refer to the input, output, and goto parameters. See &lt;a href=&quot;#AssemblerTemplate&quot;&gt;AssemblerTemplate&lt;/a&gt;.</source>
          <target state="translated">이것은 어셈블러 코드의 템플릿 인 리터럴 문자열입니다. 입력, 출력 및 이동 매개 변수를 참조하는 고정 텍스트와 토큰의 조합입니다. &lt;a href=&quot;#AssemblerTemplate&quot;&gt;AssemblerTemplate을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0266778a01da6e94c7dbdd70401e030bc44b9214" translate="yes" xml:space="preserve">
          <source>This is a literal string that specifies the assembler code. The string can contain any instructions recognized by the assembler, including directives. GCC does not parse the assembler instructions themselves and does not know what they mean or even whether they are valid assembler input.</source>
          <target state="translated">이것은 어셈블러 코드를 지정하는 리터럴 문자열입니다. 문자열은 지시문을 포함하여 어셈블러가 인식하는 모든 명령을 포함 할 수 있습니다. GCC는 어셈블러 명령어 자체를 구문 분석하지 않으며, 의미가 무엇인지, 또는 이들이 어셈블러 입력이 유효한지 여부를 모릅니다.</target>
        </trans-unit>
        <trans-unit id="b220cd2425897f657363d80f6f8c621c9e9dc4d4" translate="yes" xml:space="preserve">
          <source>This is a more fine-grained version of</source>
          <target state="translated">이보다 세밀한 버전입니다</target>
        </trans-unit>
        <trans-unit id="210265ec50f329c0444d753e710536de44906855" translate="yes" xml:space="preserve">
          <source>This is a property of the linker. C99 and C11 require that case distinctions are always significant in identifiers with external linkage and systems without this property are not supported by GCC.</source>
          <target state="translated">이것은 링커의 속성입니다. C99 및 C11에서는 외부 연결이있는 식별자에서 대소 문자 구분이 항상 중요하며이 속성이없는 시스템은 GCC에서 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="efc75a30c66eb95f41ba11f1badfcb67f0cc09c0" translate="yes" xml:space="preserve">
          <source>This is a set of options that are used to explicitly disable/enable optimization passes. These options are intended for use for debugging GCC. Compiler users should use regular options for enabling/disabling passes instead.</source>
          <target state="translated">최적화 패스를 명시 적으로 비활성화 / 활성화하는 데 사용되는 옵션 세트입니다. 이 옵션은 GCC 디버깅에 사용됩니다. 컴파일러 사용자는 패스를 활성화 / 비활성화하기 위해 일반 옵션을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="c7a5bbf22b220bbd15b9398c9ef72c66a3e9df59" translate="yes" xml:space="preserve">
          <source>This is a synonym for</source>
          <target state="translated">이것은의 동의어입니다</target>
        </trans-unit>
        <trans-unit id="fe3ee5c4bc9712f6bcac0ed8f03115711a2bebe4" translate="yes" xml:space="preserve">
          <source>This is an acceptable initializer even if &lt;var&gt;EXPRESSION&lt;/var&gt; is not a constant expression, including the case where &lt;code&gt;__builtin_constant_p&lt;/code&gt; returns 1 because &lt;var&gt;EXPRESSION&lt;/var&gt; can be folded to a constant but &lt;var&gt;EXPRESSION&lt;/var&gt; contains operands that are not otherwise permitted in a static initializer (for example, &lt;code&gt;0 &amp;amp;&amp;amp; foo ()&lt;/code&gt;). GCC must be more conservative about evaluating the built-in in this case, because it has no opportunity to perform optimization.</source>
          <target state="translated">이 경우에도 허용 이니셜 인 &lt;var&gt;EXPRESSION&lt;/var&gt; 경우를 포함 일정한 발현 아니다 &lt;code&gt;__builtin_constant_p&lt;/code&gt; 이 때문에 1을 반환 &lt;var&gt;EXPRESSION&lt;/var&gt; 상수로 절첩 될 수 있지만 &lt;var&gt;EXPRESSION&lt;/var&gt; 다르게 (예를 들어, 이니셜 정적 허용되지 피연산자 포함 &lt;code&gt;0 &amp;amp;&amp;amp; foo ()&lt;/code&gt; ). GCC는 최적화를 수행 할 기회가 없기 때문에이 경우 기본 제공 평가에 대해보다 보수적이어야합니다.</target>
        </trans-unit>
        <trans-unit id="e0aaa7cf6754c8cbdc72fa557e1be8935391e808" translate="yes" xml:space="preserve">
          <source>This is an advanced section. Type encodings are used extensively by the compiler and by the runtime, but you generally do not need to know about them to use Objective-C.</source>
          <target state="translated">이것은 고급 섹션입니다. 유형 인코딩은 컴파일러와 런타임에서 광범위하게 사용되지만 일반적으로 Objective-C를 사용하기 위해 알 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="7f363131e14be21e154381e2dda1e3e5a071a820" translate="yes" xml:space="preserve">
          <source>This is an alternative to creating a union with a &lt;code&gt;double&lt;/code&gt; member, which forces the union to be double-word aligned.</source>
          <target state="translated">이것은 &lt;code&gt;double&lt;/code&gt; 멤버 로 유니온을 작성하는 대안으로 , 유니온을 더블 워드로 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="07d312a53d8e7c9544d42f284a8fb92ee207ce56" translate="yes" xml:space="preserve">
          <source>This is an implementation of the ISO C99 function &lt;code&gt;nan&lt;/code&gt;.</source>
          <target state="translated">이것은 ISO C99 함수 &lt;code&gt;nan&lt;/code&gt; 의 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="6bb58cdaec11ea8785a298afd036692620cb8a71" translate="yes" xml:space="preserve">
          <source>This is because 2147483648 cannot fit in the type &lt;code&gt;int&lt;/code&gt;, so (following the ISO C rules) its data type is &lt;code&gt;unsigned long int&lt;/code&gt;. Negating this value yields 2147483648 again.</source>
          <target state="translated">이는 2147483648이 &lt;code&gt;int&lt;/code&gt; 유형에 맞지 않기 때문에 (ISO C 규칙에 따름) 데이터 유형이 &lt;code&gt;unsigned long int&lt;/code&gt; 이기 때문 입니다. 이 값을 부정하면 2147483648이 다시 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="cbcf60838e5c265166bf0d438d003168c4b74356" translate="yes" xml:space="preserve">
          <source>This is bound applied to calls which are considered relevant with</source>
          <target state="translated">이것은 관련성이 있다고 간주되는 통화에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="5195f538541a2304ddd489646469dec48a8ccb37" translate="yes" xml:space="preserve">
          <source>This is bound applied to calls which are optimized for size. Small growth may be desirable to anticipate optimization oppurtunities exposed by inlining.</source>
          <target state="translated">크기에 최적화 된 통화에 적용됩니다. 인라인에 의해 노출되는 최적화 기회를 예상하기 위해 작은 성장이 바람직 할 수있다.</target>
        </trans-unit>
        <trans-unit id="6762670483f9855e0a3aefbae371bb5703501c2b" translate="yes" xml:space="preserve">
          <source>This is called a &lt;em&gt;matching constraint&lt;/em&gt; and what it really means is that the assembler has only a single operand that fills two roles which &lt;code&gt;asm&lt;/code&gt; distinguishes. For example, an add instruction uses two input operands and an output operand, but on most CISC machines an add instruction really has only two operands, one of them an input-output operand:</source>
          <target state="translated">이를 &lt;em&gt;매칭 제약 조건&lt;/em&gt; 이라고하며 실제로 의미하는 것은 어셈블러에는 &lt;code&gt;asm&lt;/code&gt; 이 구분 하는 두 가지 역할을 채우는 단일 피연산자 만 있다는 것 입니다. 예를 들어, add 명령어는 두 개의 입력 피연산자와 출력 피연산자를 사용하지만 대부분의 CISC 시스템에서 add 명령어에는 실제로 두 개의 피연산자 만 있으며 그 중 하나는 입력-출력 피연산자입니다.</target>
        </trans-unit>
        <trans-unit id="c074cd27c3a79447115b4b73b7a639c3b4fa2a8e" translate="yes" xml:space="preserve">
          <source>This is currently implemented using the stronger &lt;code&gt;__ATOMIC_ACQUIRE&lt;/code&gt; memory order because of a deficiency in C++11&amp;rsquo;s semantics for &lt;code&gt;memory_order_consume&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;memory_order_consume&lt;/code&gt; 에 대한 C ++ 11 시맨틱의 결함으로 인해 더 강력한 &lt;code&gt;__ATOMIC_ACQUIRE&lt;/code&gt; 메모리 순서를 사용하여 현재 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="2b3d9a8a2627972c9a778aee53c0d0ec3f855978" translate="yes" xml:space="preserve">
          <source>This is dependent on the implementation of the C library, and is not defined by GCC itself.</source>
          <target state="translated">이것은 C 라이브러리의 구현에 의존하며 GCC 자체에 의해 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9b7b67a920492c1fed38bbae2d29e3b5c143fedc" translate="yes" xml:space="preserve">
          <source>This is enabled by default when outputting DWARF 2 debug information at the normal level, as long as there is assembler support,</source>
          <target state="translated">이는 어셈블러 지원이있는 한 DWARF 2 디버그 정보를 일반 레벨로 출력 할 때 기본적으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="99ef91485a4d9927171b8579ed4d91ac7ed3d923" translate="yes" xml:space="preserve">
          <source>This is equivalent to writing the following:</source>
          <target state="translated">이것은 다음을 쓰는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="aebe9f9ed1ec955a9599f55edc4af825e40a4ee7" translate="yes" xml:space="preserve">
          <source>This is generally desirable, because assembler-generated line-number tables are a lot more compact than those the compiler can generate itself.</source>
          <target state="translated">어셈블러에서 생성 된 행 번호 테이블은 컴파일러가 생성 할 수있는 것보다 훨씬 작기 때문에 일반적으로 바람직합니다.</target>
        </trans-unit>
        <trans-unit id="bfbcbb929b36a00d46e328a1a9742a8d812ee911" translate="yes" xml:space="preserve">
          <source>This is how GCC traditionally handled functions declared &lt;code&gt;inline&lt;/code&gt;. Since ISO C99 specifies a different semantics for &lt;code&gt;inline&lt;/code&gt;, this function attribute is provided as a transition measure and as a useful feature in its own right. This attribute is available in GCC 4.1.3 and later. It is available if either of the preprocessor macros &lt;code&gt;__GNUC_GNU_INLINE__&lt;/code&gt; or &lt;code&gt;__GNUC_STDC_INLINE__&lt;/code&gt; are defined. See &lt;a href=&quot;inline#Inline&quot;&gt;An Inline Function is As Fast As a Macro&lt;/a&gt;.</source>
          <target state="translated">이것이 GCC가 전통적으로 &lt;code&gt;inline&lt;/code&gt; 선언 된 함수를 처리하는 방법 입니다. ISO C99는 &lt;code&gt;inline&lt;/code&gt; 에 다른 시맨틱을 지정하므로이 함수 속성은 전이 측정 및 유용한 기능으로 제공됩니다. 이 속성은 GCC 4.1.3 이상에서 사용할 수 있습니다. 전 처리기 매크로 &lt;code&gt;__GNUC_GNU_INLINE__&lt;/code&gt; 또는 &lt;code&gt;__GNUC_STDC_INLINE__&lt;/code&gt; 중 하나 가 정의 된 경우 사용할 수 있습니다 . &lt;a href=&quot;inline#Inline&quot;&gt;인라인 함수가 매크로만큼 빠름을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3659f6c91bb02b5cd8a55719f9462825417fbf7f" translate="yes" xml:space="preserve">
          <source>This is in all ways equivalent to the ISO C example above, but arguably more readable and descriptive.</source>
          <target state="translated">이것은 모든면에서 위의 ISO C 예제와 동일하지만 더 읽기 쉽고 설명하기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="1eaa9666a3a5435e04f459b069a65e1a2259a5c1" translate="yes" xml:space="preserve">
          <source>This is intended for use by GCC developers and plugin developers when debugging diagnostics that report interprocedural control flow.</source>
          <target state="translated">이는 절차 간 제어 흐름을보고하는 진단을 디버깅 할 때 GCC 개발자 및 플러그인 개발자가 사용하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="e833378dc7330796a80aef851e1b40fc5a1e0901" translate="yes" xml:space="preserve">
          <source>This is just like &amp;lsquo;</source>
          <target state="translated">이것은 단지 '</target>
        </trans-unit>
        <trans-unit id="87943af8f7660938d198a190217b23c8ea1f6e48" translate="yes" xml:space="preserve">
          <source>This is like</source>
          <target state="translated">이것은 같다</target>
        </trans-unit>
        <trans-unit id="37d0e0a31c79678362e2daef4bb85a617b64f850" translate="yes" xml:space="preserve">
          <source>This is more friendly to code living in shared libraries, as it reduces the number of dynamic relocations that are needed, and by consequence, allows the data to be read-only. This alternative with label differences is not supported for the AVR target, please use the first approach for AVR programs.</source>
          <target state="translated">공유 라이브러리에있는 코드에 더 친숙합니다. 필요한 동적 재배치 횟수를 줄이고 결과적으로 데이터를 읽기 전용으로 허용하기 때문입니다. 레이블 차이가있는이 대안은 AVR 대상에 지원되지 않습니다. AVR 프로그램의 첫 번째 방법을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="52f8a99adebca7a079e1f334d570e3be716912f1" translate="yes" xml:space="preserve">
          <source>This is not correct on x86-64 as it would allocate tick in either &lt;code&gt;ax&lt;/code&gt; or &lt;code&gt;dx&lt;/code&gt;. You have to use the following variant instead:</source>
          <target state="translated">x86-64에서는 &lt;code&gt;ax&lt;/code&gt; 또는 &lt;code&gt;dx&lt;/code&gt; 에서 틱을 할당하므로 올바르지 않습니다 . 대신 다음 변형을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="73c90434e16b0f55c0b872ec23da22fc830bc9a4" translate="yes" xml:space="preserve">
          <source>This is particularly useful for assumed-shape arrays in Fortran where (for example) it allows better vectorization assuming contiguous accesses. This flag is enabled by default at</source>
          <target state="translated">이 기능은 포트란에서 가정 된 형태의 배열에 특히 유용합니다. 이 플래그는 기본적으로</target>
        </trans-unit>
        <trans-unit id="031672016e4d502c018309428e47661800aac1a9" translate="yes" xml:space="preserve">
          <source>This is similar to</source>
          <target state="translated">이것은 비슷합니다</target>
        </trans-unit>
        <trans-unit id="b5bdec22d274cc0ce57cbe3e424189dc32fd8d9a" translate="yes" xml:space="preserve">
          <source>This is the C variable or expression being passed to the &lt;code&gt;asm&lt;/code&gt; statement as input. The enclosing parentheses are a required part of the syntax.</source>
          <target state="translated">이것은 입력으로 &lt;code&gt;asm&lt;/code&gt; 문 에 전달되는 C 변수 또는 표현식 입니다. 괄호는 구문의 필수 부분입니다.</target>
        </trans-unit>
        <trans-unit id="08fb1a095794b3c3899440175335ee88759da275" translate="yes" xml:space="preserve">
          <source>This is the default (normal) setting. The only traps that are enabled are the ones that cannot be disabled in software (e.g., division by zero trap).</source>
          <target state="translated">이것이 기본 (일반) 설정입니다. 활성화 된 유일한 트랩은 소프트웨어에서 비활성화 할 수없는 트랩입니다 (예 : 0으로 나누기).</target>
        </trans-unit>
        <trans-unit id="1a4c45120ca7a63ffc2a2ee3465224f90ffe09ce" translate="yes" xml:space="preserve">
          <source>This is the default choice for non-Darwin x86-32 targets.</source>
          <target state="translated">이것은 다윈 x86-32가 아닌 대상의 기본 선택입니다.</target>
        </trans-unit>
        <trans-unit id="59c124a9358a8d1126f10890f1eb504cdd7df946" translate="yes" xml:space="preserve">
          <source>This is the default choice for the x86-64 compiler, Darwin x86-32 targets, and the default choice for x86-32 targets with the SSE2 instruction set when</source>
          <target state="translated">이는 x86-64 컴파일러, Darwin x86-32 대상 및 SSE2 명령이 설정된 x86-32 대상의 기본 선택입니다.</target>
        </trans-unit>
        <trans-unit id="b74e8d3240c6f67db12f1d7fa81a7aa2edb28fb1" translate="yes" xml:space="preserve">
          <source>This is the default on some targets.</source>
          <target state="translated">이것은 일부 대상의 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="a72e96be7931cf0f817380bd16aa70bcfafbbfe8" translate="yes" xml:space="preserve">
          <source>This is the default warning level of</source>
          <target state="translated">이것이 기본 경고 수준입니다</target>
        </trans-unit>
        <trans-unit id="2cf92c2da398ed082aa03bcf05470475390ec8ef" translate="yes" xml:space="preserve">
          <source>This is the generic version of an atomic exchange. It stores the contents of &lt;code&gt;*&lt;var&gt;val&lt;/var&gt;&lt;/code&gt; into &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;. The original value of &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; is copied into &lt;code&gt;*&lt;var&gt;ret&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">이것은 원자 교환의 일반 버전입니다. &lt;code&gt;*&lt;var&gt;val&lt;/var&gt;&lt;/code&gt; 의 내용 을 &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; 에 저장합니다 . &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; 의 원래 값은 &lt;code&gt;*&lt;var&gt;ret&lt;/var&gt;&lt;/code&gt; 에 복사됩니다 .</target>
        </trans-unit>
        <trans-unit id="544eb750f0727dd454c0757327b302d011f9d8e4" translate="yes" xml:space="preserve">
          <source>This is the generic version of an atomic load. It returns the contents of &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; in &lt;code&gt;*&lt;var&gt;ret&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">이것은 원자로드의 일반 버전입니다. 그것은의 내용을 반환 &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; 에 &lt;code&gt;*&lt;var&gt;ret&lt;/var&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="21175b474269d19f2c711f8904d430397eb7f000" translate="yes" xml:space="preserve">
          <source>This is the generic version of an atomic store. It stores the value of &lt;code&gt;*&lt;var&gt;val&lt;/var&gt;&lt;/code&gt; into &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">이것은 원자 저장소의 일반 버전입니다. &lt;code&gt;*&lt;var&gt;val&lt;/var&gt;&lt;/code&gt; 의 값 을 &lt;code&gt;*&lt;var&gt;ptr&lt;/var&gt;&lt;/code&gt; 에 저장합니다 .</target>
        </trans-unit>
        <trans-unit id="38581f9b32f6622e3fe0d5bb58e5ec8a4bb25cbf" translate="yes" xml:space="preserve">
          <source>This is the mode used for floating-point calculations with round-to-nearest-or-even rounding mode.</source>
          <target state="translated">가장 가까운 반올림 또는 반올림 모드를 사용한 부동 소수점 계산에 사용되는 모드입니다.</target>
        </trans-unit>
        <trans-unit id="2425d7e7a37939aa94f7a4685eaf2c7dc785155a" translate="yes" xml:space="preserve">
          <source>This is the mode used for floating-point calculations with truncating (i.e. round towards zero) rounding mode. That includes conversion from floating point to integer.</source>
          <target state="translated">이것은 반올림 모드 (예 : 0으로 반올림)를 사용한 부동 소수점 계산에 사용되는 모드입니다. 여기에는 부동 소수점에서 정수로의 변환이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="35b95ca7a0555a082526c5eeface6f56baa751e7" translate="yes" xml:space="preserve">
          <source>This is the mode used to perform integer calculations in the FPU, e.g. integer multiply, or integer multiply-and-accumulate.</source>
          <target state="translated">FPU에서 정수 계산을 수행하는 데 사용되는 모드입니다 (예 : 정수 곱하기 또는 정수 곱하기 및 누산).</target>
        </trans-unit>
        <trans-unit id="4098e33c6565f575396e0bc34dbbf7c96adebca6" translate="yes" xml:space="preserve">
          <source>This is the same as &amp;lsquo;</source>
          <target state="translated">이것은 '</target>
        </trans-unit>
        <trans-unit id="63f530e06bab16bd703cfd6e987a5d2afe910c22" translate="yes" xml:space="preserve">
          <source>This is the simplest option, but also offers flexibility and fine-grained control when necessary. It is also the most portable alternative and programs using this approach will work with most modern compilers.</source>
          <target state="translated">가장 간단한 옵션이지만 필요한 경우 유연성과 세밀한 제어 기능을 제공합니다. 또한 가장 이식성이 좋은 대안이며이 방법을 사용하는 프로그램은 대부분의 최신 컴파일러에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="92ad0261cb0958c1d426eccb32a1c93544a5dc43" translate="yes" xml:space="preserve">
          <source>This is the warning level of</source>
          <target state="translated">이것은 경고 수준입니다</target>
        </trans-unit>
        <trans-unit id="77e89dce84a517cc123ca42eb8de81a6643ce569" translate="yes" xml:space="preserve">
          <source>This is the warning level that is enabled by</source>
          <target state="translated">이것은 다음에 의해 활성화되는 경고 수준입니다</target>
        </trans-unit>
        <trans-unit id="760cf4bac038578756206c93dae00fb9cba073c6" translate="yes" xml:space="preserve">
          <source>This is typical output:</source>
          <target state="translated">이것은 일반적인 출력입니다.</target>
        </trans-unit>
        <trans-unit id="da7f2d31c6f9672e3ba4ae5efbb305bb596a464e" translate="yes" xml:space="preserve">
          <source>This is useful when &lt;code&gt;gcc&lt;/code&gt; prints the error message &amp;lsquo;</source>
          <target state="translated">이는 &lt;code&gt;gcc&lt;/code&gt; 가 오류 메시지를 인쇄 할 때 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="61900c28d4f89d472663c0fb34d75c4a85cd7c53" translate="yes" xml:space="preserve">
          <source>This is useful when you use</source>
          <target state="translated">이것은 사용할 때 유용합니다</target>
        </trans-unit>
        <trans-unit id="f021b4a2b4ebd3ad97c6de7e5e1dd3f9efc1450f" translate="yes" xml:space="preserve">
          <source>This is why GCC does and will treat plain bit-fields in the same fashion on all types of machines (by default).</source>
          <target state="translated">이것이 바로 GCC가 모든 유형의 머신에서 기본 비트 필드를 동일한 방식으로 처리하고 처리하는 이유입니다.</target>
        </trans-unit>
        <trans-unit id="4b959d24ea2462316c67c3712ca90973257d6c02" translate="yes" xml:space="preserve">
          <source>This level is intended for analyzer developers; it adds various other events intended for debugging the analyzer.</source>
          <target state="translated">이 레벨은 분석기 개발자를위한 것입니다. 분석기 디버깅을위한 다양한 기타 이벤트를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="7c1b93195f2512278e6a6fff2538323d8e57d38c" translate="yes" xml:space="preserve">
          <source>This level is the default.</source>
          <target state="translated">이 수준이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="700e39a7f2669dafee2d84e8e1e01bff08feb798" translate="yes" xml:space="preserve">
          <source>This macro reflects the</source>
          <target state="translated">이 매크로는</target>
        </trans-unit>
        <trans-unit id="7d487e0152f8e873aae65c9ae3d1ffd07da68324" translate="yes" xml:space="preserve">
          <source>This manual documents how to use the GNU compilers, as well as their features and incompatibilities, and how to report bugs. It corresponds to the compilers (GCC) version 10.2.0. The internals of the GNU compilers, including how to port them to new targets and some information about how to write front ends for new languages, are documented in a separate manual. See &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gccint/index.html#Top&quot;&gt;Introduction&lt;/a&gt; in GNU Compiler Collection (GCC) Internals.</source>
          <target state="translated">이 매뉴얼은 GNU 컴파일러 사용 방법, 기능 및 비 호환성, 버그보고 방법을 문서화합니다. 컴파일러 (GCC) 버전 10.2.0에 해당합니다. 새로운 타겟으로 포팅하는 방법과 새로운 언어의 프런트 엔드를 작성하는 방법에 대한 정보를 포함하여 GNU 컴파일러의 내부는 별도의 매뉴얼에 문서화되어 있습니다. GCC (GNU Compiler Collection) 내부 &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gccint/index.html#Top&quot;&gt;소개&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1653245bf51b1f0c3c2fa674b4064d9aab7d9670" translate="yes" xml:space="preserve">
          <source>This manual documents how to use the GNU compilers, as well as their features and incompatibilities, and how to report bugs. It corresponds to the compilers (GCC) version 9.2.0. The internals of the GNU compilers, including how to port them to new targets and some information about how to write front ends for new languages, are documented in a separate manual. See &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gccint/index.html#Top&quot;&gt;Introduction&lt;/a&gt; in GNU Compiler Collection (GCC) Internals.</source>
          <target state="translated">이 매뉴얼은 GNU 컴파일러 사용법, 기능 및 비 호환성, 버그보고 방법을 설명합니다. 컴파일러 (GCC) 버전 9.2.0에 해당합니다. 새로운 컴파일러로 포팅하는 방법과 새로운 언어를위한 프론트 엔드를 작성하는 방법에 대한 정보를 포함하여 GNU 컴파일러의 내부는 별도의 매뉴얼에 문서화되어 있습니다. GNU 컴파일러 모음 (GCC) 내부 &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gccint/index.html#Top&quot;&gt;소개&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d1e0ea996271f7db110a1aacecb995078842dd10" translate="yes" xml:space="preserve">
          <source>This mechanism is not intended to be a replacement for &lt;code&gt;+initialize&lt;/code&gt;. You should be aware of its limitations when you decide to use it instead of &lt;code&gt;+initialize&lt;/code&gt;.</source>
          <target state="translated">이 메커니즘은 &lt;code&gt;+initialize&lt;/code&gt; 를 대체하기위한 것이 아닙니다 . &lt;code&gt;+initialize&lt;/code&gt; 대신 사용하기로 결정할 때 제한 사항을 알고 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="0b86e98dae575f25e7dd277f55069259f5a76e0f" translate="yes" xml:space="preserve">
          <source>This might appear strange; if an insn allows a constant operand with a value not known at compile time, it certainly must allow any known value. So why use &amp;lsquo;</source>
          <target state="translated">이것은 이상하게 보일 수 있습니다. insn이 컴파일 타임에 알려지지 않은 값을 가진 상수 피연산자를 허용하는 경우 알려진 값을 반드시 허용해야합니다. 왜 '</target>
        </trans-unit>
        <trans-unit id="93b2398d0b07a68172b830b044a2e5af1fdcea09" translate="yes" xml:space="preserve">
          <source>This number is allowed to be more than a single digit. If multiple digits are encountered consecutively, they are interpreted as a single decimal integer. There is scant chance for ambiguity, since to-date it has never been desirable that &amp;lsquo;</source>
          <target state="translated">이 숫자는 한 자리 이상이 될 수 있습니다. 여러 자릿수가 연속적으로 발생하면 하나의 십진 정수로 해석됩니다. 애매 모호한 가능성은 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="22e75e50204b22e1eb4e9e0ef88e476b337f8735" translate="yes" xml:space="preserve">
          <source>This occurs because sometimes GCC optimizes the variable out of existence. There is no way to tell the debugger how to compute the value such a variable &amp;ldquo;would have had&amp;rdquo;, and it is not clear that would be desirable anyway. So GCC simply does not mention the eliminated variable when it writes debugging information.</source>
          <target state="translated">때때로 GCC가 변수가 존재하지 않도록 최적화하기 때문에 발생합니다. 디버거에 이러한 변수가 &quot;있었을 것&quot;과 같은 값을 계산하는 방법을 알려주는 방법은 없으며, 어쨌든 바람직한 지 분명하지 않습니다. 따라서 GCC는 디버깅 정보를 작성할 때 제거 된 변수를 언급하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5ce0fa0b0cabdd9e15b52efa7f6d71eba5c1f802" translate="yes" xml:space="preserve">
          <source>This only makes sense when scheduling after register allocation, i.e. with</source>
          <target state="translated">이것은 레지스터 할당 후 스케줄링 할 때만 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="db13c5371ec3d6856069cde7f84c42a79ba4d667" translate="yes" xml:space="preserve">
          <source>This optimization is automatically turned off in the presence of exception handling or unwind tables (on targets using setjump/longjump or target specific scheme), for linkonce sections, for functions with a user-defined section attribute and on any architecture that does not support named sections. When</source>
          <target state="translated">이 최적화는 예외 처리 또는 해제 테이블 (setjump / longjump 또는 대상 특정 체계를 사용하는 대상), linkonce 섹션, 사용자 정의 섹션 속성이있는 함수 및 명명되지 않은 아키텍처에 대해 자동으로 해제됩니다. 섹션. 언제</target>
        </trans-unit>
        <trans-unit id="96a50b9ceb3aa5aae8cfa612292d0e06f418fdee" translate="yes" xml:space="preserve">
          <source>This optimization is enabled by default for PowerPC targets, but disabled by default otherwise.</source>
          <target state="translated">이 최적화는 PowerPC 대상에 대해 기본적으로 활성화되지만 그렇지 않으면 기본적으로 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="03a904b6f6255ac7a46cba1abdfa2fc80dcd97c1" translate="yes" xml:space="preserve">
          <source>This optimization is enabled by default.</source>
          <target state="translated">이 최적화는 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd622740636a8f6bc187abc5bbcb4be9fb8826dc" translate="yes" xml:space="preserve">
          <source>This optimization is off by default at all optimization levels.</source>
          <target state="translated">이 최적화는 모든 최적화 수준에서 기본적으로 해제되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="96c9c932cfd47ab32407f6161d42f932d1499bb6" translate="yes" xml:space="preserve">
          <source>This option allows further control over excess precision on machines where floating-point operations occur in a format with more precision or range than the IEEE standard and interchange floating-point types. By default,</source>
          <target state="translated">이 옵션을 사용하면 IEEE 표준 및 교환 부동 소수점 유형보다 정밀도 또는 범위가 높은 형식으로 부동 소수점 연산이 발생하는 시스템에서 정밀도를 추가로 제어 할 수 있습니다. 기본적으로,</target>
        </trans-unit>
        <trans-unit id="0cd275b48533fab7a99c41cb026721abbe83dfbd" translate="yes" xml:space="preserve">
          <source>This option allows use of a precompiled header (see &lt;a href=&quot;precompiled-headers#Precompiled-Headers&quot;&gt;Precompiled Headers&lt;/a&gt;) together with</source>
          <target state="translated">이 옵션을 사용하면 사전 컴파일 된 헤더 ( &lt;a href=&quot;precompiled-headers#Precompiled-Headers&quot;&gt;사전 컴파일 된 헤더&lt;/a&gt; 참조 )를</target>
        </trans-unit>
        <trans-unit id="bc138a12e44acf9ec0d9c17239119bb46de565b8" translate="yes" xml:space="preserve">
          <source>This option also controls warnings when a user-defined literal operator is declared with a literal suffix identifier that doesn&amp;rsquo;t begin with an underscore. Literal suffix identifiers that don&amp;rsquo;t begin with an underscore are reserved for future standardization.</source>
          <target state="translated">이 옵션은 또한 사용자 정의 리터럴 연산자가 밑줄로 시작하지 않는 리터럴 접미사 식별자로 선언 될 때 경고를 제어합니다. 밑줄로 시작하지 않는 리터럴 접미사 식별자는 향후 표준화를 위해 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="176e6d10a5020dcedfe440b551f5e25423a91471" translate="yes" xml:space="preserve">
          <source>This option also enables</source>
          <target state="translated">이 옵션은 또한</target>
        </trans-unit>
        <trans-unit id="f64cb852c815528bec1c35d19339c840b9bc9852" translate="yes" xml:space="preserve">
          <source>This option also enables warnings about psABI-related changes. The known psABI changes at this point include:</source>
          <target state="translated">이 옵션은 또한 psABI 관련 변경에 대한 경고를 활성화합니다. 이 시점에서 알려진 psABI 변경 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="44de7a78056937b7baedfa3be44429b20f8420b9" translate="yes" xml:space="preserve">
          <source>This option also warns when &lt;code&gt;alloca&lt;/code&gt; is used in a loop.</source>
          <target state="translated">이 옵션은 또한 &lt;code&gt;alloca&lt;/code&gt; 가 루프에서 사용될 때 경고 합니다.</target>
        </trans-unit>
        <trans-unit id="8dcb0d8b589589b99a6d5de3a4fa4b5fc06db20b" translate="yes" xml:space="preserve">
          <source>This option also warns when a non-volatile automatic variable might be changed by a call to &lt;code&gt;longjmp&lt;/code&gt;. The compiler sees only the calls to &lt;code&gt;setjmp&lt;/code&gt;. It cannot know where &lt;code&gt;longjmp&lt;/code&gt; will be called; in fact, a signal handler could call it at any point in the code. As a result, you may get a warning even when there is in fact no problem because &lt;code&gt;longjmp&lt;/code&gt; cannot in fact be called at the place that would cause a problem.</source>
          <target state="translated">이 옵션은 &lt;code&gt;longjmp&lt;/code&gt; 호출로 비 휘발성 자동 변수가 변경 될 때 경고합니다 . 컴파일러는 &lt;code&gt;setjmp&lt;/code&gt; 호출 만 볼 수 있습니다. &lt;code&gt;longjmp&lt;/code&gt; 가 어디에서 호출 되는지 알 수 없습니다 . 실제로 신호 처리기는 코드의 어느 시점에서나 호출 할 수 있습니다. 결과적으로 실제로 문제가 발생 하지 않는 장소에서 &lt;code&gt;longjmp&lt;/code&gt; 를 호출 할 수 없으므로 실제로 문제가없는 경우에도 경고가 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="647a82f2f84be9cba875128f0dca433a10d57f59" translate="yes" xml:space="preserve">
          <source>This option and its counterpart,</source>
          <target state="translated">이 옵션과 해당 옵션</target>
        </trans-unit>
        <trans-unit id="5138f290e3826f8790e3e713269029e9ccdb5e45" translate="yes" xml:space="preserve">
          <source>This option behaves mostly the same as the MSP430 function attribute of the same name (see &lt;a href=&quot;msp430-function-attributes#MSP430-Function-Attributes&quot;&gt;MSP430 Function Attributes&lt;/a&gt;), but it has some additional functionality.</source>
          <target state="translated">이 옵션은 동일한 이름의 MSP430 기능 속성과 거의 동일하게 작동 하지만 ( &lt;a href=&quot;msp430-function-attributes#MSP430-Function-Attributes&quot;&gt;MSP430 기능 속성&lt;/a&gt; 참조 ) 몇 가지 추가 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7bf60baf10d559ca0b1b6d693e3ba93b5e1f2d3" translate="yes" xml:space="preserve">
          <source>This option can also serve as a replacement for the older way of specifying custom device-specs files that needed</source>
          <target state="translated">이 옵션은 필요한 사용자 지정 장치 사양 파일을 지정하는 이전 방법을 대체 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="51f89764d458f9e6ce2a9e5debf60911dcf32abd" translate="yes" xml:space="preserve">
          <source>This option can be overridden for individual functions with the &lt;code&gt;hotpatch&lt;/code&gt; attribute.</source>
          <target state="translated">이 옵션은 &lt;code&gt;hotpatch&lt;/code&gt; 속성을 사용하여 개별 기능에 대해 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b9d6d68f8663846b608b68015e96e5892b5536f8" translate="yes" xml:space="preserve">
          <source>This option can be used in combination with</source>
          <target state="translated">This option can be used in combination with</target>
        </trans-unit>
        <trans-unit id="6031ab076087301a6d0abbb423cf52dcdfaad6ad" translate="yes" xml:space="preserve">
          <source>This option can be used with</source>
          <target state="translated">이 옵션은</target>
        </trans-unit>
        <trans-unit id="ffe3df6bb53541974a1831b4cc4d1b56a60baa8e" translate="yes" xml:space="preserve">
          <source>This option can lead to reduced code size for functions that perform several calls to functions that get their arguments on the stack like calls to printf-like functions.</source>
          <target state="translated">이 옵션을 사용하면 printf와 같은 함수에 대한 호출과 같이 스택에서 인수를 얻는 함수에 대한 여러 호출을 수행하는 함수의 코드 크기가 줄어들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="659720e1c331361819e1f19306618a073823d1ae" translate="yes" xml:space="preserve">
          <source>This option can only be used if the target architecture supports branch-likely instructions.</source>
          <target state="translated">이 옵션은 대상 아키텍처가 분기 형 명령어를 지원하는 경우에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc3a9caac6f7198e302fb437322053279f7c71d0" translate="yes" xml:space="preserve">
          <source>This option cannot be suffixed by feature modifiers.</source>
          <target state="translated">이 옵션은 기능 수정 자로 접미사를 붙일 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c576211fac72dc023de0044164971c10d96f526d" translate="yes" xml:space="preserve">
          <source>This option causes GCC to create markers in the internal representation at the beginning of statements, and to keep them roughly in place throughout compilation, using them to guide the output of &lt;code&gt;is_stmt&lt;/code&gt; markers in the line number table. This is enabled by default when compiling with optimization (</source>
          <target state="translated">이 옵션을 사용하면 GCC는 명령문 시작시 내부 표현에 마커를 작성 하고 행 번호 테이블에서 &lt;code&gt;is_stmt&lt;/code&gt; 마커 의 출력을 안내하는 데이 를 사용하여 컴파일하는 동안 대략 제자리에 유지 합니다. 최적화로 컴파일 할 때 기본적으로 사용됩니다 (</target>
        </trans-unit>
        <trans-unit id="95c8757dd3d3337f46ca394f8f8769868a644ecd" translate="yes" xml:space="preserve">
          <source>This option causes r2 and r5 to be treated as fixed registers.</source>
          <target state="translated">이 옵션을 사용하면 r2 및 r5가 고정 레지스터로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="b5e090b60ad88e1f4ec2772be778990575505b68" translate="yes" xml:space="preserve">
          <source>This option causes r2 and r5 to be used in the code generated by the compiler. This setting is the default.</source>
          <target state="translated">이 옵션을 사용하면 r2 및 r5가 컴파일러에서 생성 된 코드에 사용됩니다. 이 설정이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="d3d04b742fdf172a830cc81fd460a113af18fcfc" translate="yes" xml:space="preserve">
          <source>This option causes run-time data structures to be built at program startup, which are used for verifying the vtable pointers. The options &amp;lsquo;</source>
          <target state="translated">이 옵션을 사용하면 프로그램 시작시 런타임 데이터 구조가 빌드되어 vtable 포인터를 확인하는 데 사용됩니다. 옵션 '</target>
        </trans-unit>
        <trans-unit id="a26b4242bc022197a5b469c4333379231dcfd91c" translate="yes" xml:space="preserve">
          <source>This option causes the compiler to abort compilation on the first error occurred rather than trying to keep going and printing further error messages.</source>
          <target state="translated">이 옵션을 사용하면 컴파일러는 계속 진행하여 추가 오류 메시지를 인쇄하지 않고 발생한 첫 번째 오류에서 컴파일을 중단합니다.</target>
        </trans-unit>
        <trans-unit id="5e90ed4f8d16ef658451b5bbc4a698c1ccbdaac4" translate="yes" xml:space="preserve">
          <source>This option causes the preprocessor macro &lt;code&gt;__FAST_MATH__&lt;/code&gt; to be defined.</source>
          <target state="translated">이 옵션은 전 처리기 매크로 &lt;code&gt;__FAST_MATH__&lt;/code&gt; 가 정의되도록합니다.</target>
        </trans-unit>
        <trans-unit id="59f74610163bdce44c421694716dba7eea2f36f3" translate="yes" xml:space="preserve">
          <source>This option causes the preprocessor macro &lt;code&gt;__SUPPORT_SNAN__&lt;/code&gt; to be defined.</source>
          <target state="translated">이 옵션은 전 처리기 매크로 &lt;code&gt;__SUPPORT_SNAN__&lt;/code&gt; 이 정의되도록합니다.</target>
        </trans-unit>
        <trans-unit id="c130859b377ff82df01657d63e921773dd0c4fe8" translate="yes" xml:space="preserve">
          <source>This option controls code generation of the link-time optimizer. By default the linker output is automatically determined by the linker plugin. For debugging the compiler and if incremental linking with a non-LTO object file is desired, it may be useful to control the type manually.</source>
          <target state="translated">This option controls code generation of the link-time optimizer. By default the linker output is automatically determined by the linker plugin. For debugging the compiler and if incremental linking with a non-LTO object file is desired, it may be useful to control the type manually.</target>
        </trans-unit>
        <trans-unit id="dc144b835e4ef20a9b868419ab10431eef1dc3bb" translate="yes" xml:space="preserve">
          <source>This option controls stack space reuse for user declared local/auto variables and compiler generated temporaries. &lt;var&gt;reuse_level&lt;/var&gt; can be &amp;lsquo;</source>
          <target state="translated">이 옵션은 사용자 선언 로컬 / 자동 변수 및 컴파일러 생성 임시에 대한 스택 공간 재사용을 제어합니다. &lt;var&gt;reuse_level&lt;/var&gt; 은 '</target>
        </trans-unit>
        <trans-unit id="68a88d1554ed1aa2b217aa4277399c9f56f7ad9c" translate="yes" xml:space="preserve">
          <source>This option controls the code generation of the link time optimizer. By default the linker output is determined by the linker plugin automatically. For debugging the compiler and in the case of incremental linking to non-lto object file is desired, it may be useful to control the type manually.</source>
          <target state="translated">이 옵션은 링크 시간 최적화 프로그램의 코드 생성을 제어합니다. 기본적으로 링커 출력은 링커 플러그인에 의해 자동으로 결정됩니다. 컴파일러를 디버깅하고 lto가 아닌 오브젝트 파일에 증분 링크하는 경우 유형을 수동으로 제어하는 ​​것이 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a86853e0ed7deb868803dd87757662761aedfd9" translate="yes" xml:space="preserve">
          <source>This option controls the complexity of the control flow paths that are emitted for analyzer diagnostics.</source>
          <target state="translated">This option controls the complexity of the control flow paths that are emitted for analyzer diagnostics.</target>
        </trans-unit>
        <trans-unit id="5d9b7ff3f71ba23e9705b0d93e8591071e6bba1a" translate="yes" xml:space="preserve">
          <source>This option controls the default setting of the ISO C99 &lt;code&gt;CX_LIMITED_RANGE&lt;/code&gt; pragma. Nevertheless, the option applies to all languages.</source>
          <target state="translated">이 옵션은 ISO C99 &lt;code&gt;CX_LIMITED_RANGE&lt;/code&gt; pragma 의 기본 설정을 제어합니다 . 그럼에도 불구하고이 옵션은 모든 언어에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="149f5a9a7f4ee5991089ef9512f0da137f76588e" translate="yes" xml:space="preserve">
          <source>This option controls the minimum width of the left margin printed by</source>
          <target state="translated">이 옵션은 왼쪽 여백의 최소 너비를</target>
        </trans-unit>
        <trans-unit id="37de330d3f523306c4e20d85e9fac76a8d0f7abf" translate="yes" xml:space="preserve">
          <source>This option controls the priority that is assigned to dispatch-slot restricted instructions during the second scheduling pass. The argument &lt;var&gt;priority&lt;/var&gt; takes the value &amp;lsquo;</source>
          <target state="translated">이 옵션은 두 번째 스케줄링 단계 동안 디스패치 슬롯 제한 명령에 지정된 우선 순위를 제어합니다. 인수 &lt;var&gt;priority&lt;/var&gt; 는 '</target>
        </trans-unit>
        <trans-unit id="00ce7609ded1a0ff2fbbb9740f9f2209c0f8ef1e" translate="yes" xml:space="preserve">
          <source>This option controls the version of libgcc that the compiler links to an executable and selects a software-managed cache for accessing variables in the &lt;code&gt;__ea&lt;/code&gt; address space with a particular cache size. Possible options for &lt;var&gt;cache-size&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">이 옵션은 컴파일러가 실행 파일에 링크하는 libgcc 버전을 제어하고 특정 캐시 크기 의 &lt;code&gt;__ea&lt;/code&gt; 주소 공간 에있는 변수에 액세스하기 위해 소프트웨어 관리 캐시를 선택합니다 . &lt;var&gt;cache-size&lt;/var&gt; 가능한 옵션 은 '</target>
        </trans-unit>
        <trans-unit id="9caa6f342fbdbf76f119015b6337636546395e60" translate="yes" xml:space="preserve">
          <source>This option controls the version of libgcc that the compiler links to an executable and selects whether atomic updates to the software-managed cache of PPU-side variables are used. If you use atomic updates, changes to a PPU variable from SPU code using the &lt;code&gt;__ea&lt;/code&gt; named address space qualifier do not interfere with changes to other PPU variables residing in the same cache line from PPU code. If you do not use atomic updates, such interference may occur; however, writing back cache lines is more efficient. The default behavior is to use atomic updates.</source>
          <target state="translated">이 옵션은 컴파일러가 실행 파일에 연결하는 libgcc 버전을 제어하고 소프트웨어 관리 PPU 측 변수 캐시에 대한 원자 업데이트를 사용할지 여부를 선택합니다. 원자 업데이트를 사용하는 경우 &lt;code&gt;__ea&lt;/code&gt; 명명 된 주소 공간 한정자를 사용하여 SPU 코드에서 PPU 변수를 변경해도 PPU 코드와 동일한 캐시 라인에있는 다른 PPU 변수의 변경을 방해하지 않습니다. 원자 업데이트를 사용하지 않으면 이러한 간섭이 발생할 수 있습니다. 그러나 캐시 라인을 다시 쓰는 것이 더 효율적입니다. 기본 동작은 자동 업데이트를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f61295df1d57ff262d461369dde8c3f32294d711" translate="yes" xml:space="preserve">
          <source>This option controls warnings for invocations of &lt;a href=&quot;_005f_005fatomic-builtins#g_t_005f_005fatomic-Builtins&quot;&gt;__atomic Builtins&lt;/a&gt;, &lt;a href=&quot;_005f_005fsync-builtins#g_t_005f_005fsync-Builtins&quot;&gt;__sync Builtins&lt;/a&gt;, and the C11 atomic generic functions with a memory consistency argument that is either invalid for the operation or outside the range of values of the &lt;code&gt;memory_order&lt;/code&gt; enumeration. For example, since the &lt;code&gt;__atomic_store&lt;/code&gt; and &lt;code&gt;__atomic_store_n&lt;/code&gt; built-ins are only defined for the relaxed, release, and sequentially consistent memory orders the following code is diagnosed:</source>
          <target state="translated">This option controls warnings for invocations of &lt;a href=&quot;_005f_005fatomic-builtins#g_t_005f_005fatomic-Builtins&quot;&gt;__atomic Builtins&lt;/a&gt;, &lt;a href=&quot;_005f_005fsync-builtins#g_t_005f_005fsync-Builtins&quot;&gt;__sync Builtins&lt;/a&gt;, and the C11 atomic generic functions with a memory consistency argument that is either invalid for the operation or outside the range of values of the &lt;code&gt;memory_order&lt;/code&gt; enumeration. For example, since the &lt;code&gt;__atomic_store&lt;/code&gt; and &lt;code&gt;__atomic_store_n&lt;/code&gt; built-ins are only defined for the relaxed, release, and sequentially consistent memory orders the following code is diagnosed:</target>
        </trans-unit>
        <trans-unit id="d64a7975973f5229e105c9130aabc92aaaa20581" translate="yes" xml:space="preserve">
          <source>This option controls warnings if feedback profiles are missing when using the</source>
          <target state="translated">This option controls warnings if feedback profiles are missing when using the</target>
        </trans-unit>
        <trans-unit id="db5b3a6e625e42c517fab36eef17aa077a6434f1" translate="yes" xml:space="preserve">
          <source>This option controls warnings when a &lt;code&gt;switch&lt;/code&gt; case has a value that is outside of its respective type range. This warning is enabled by default for C and C++ programs.</source>
          <target state="translated">This option controls warnings when a &lt;code&gt;switch&lt;/code&gt; case has a value that is outside of its respective type range. This warning is enabled by default for C and C++ programs.</target>
        </trans-unit>
        <trans-unit id="d647e87ba0a1edc0a3d0d54b53d61b0d1016c986" translate="yes" xml:space="preserve">
          <source>This option controls warnings when a base class is inaccessible in a class derived from it due to ambiguity. The warning is enabled by default. Note that the warning for ambiguous virtual bases is enabled by the</source>
          <target state="translated">This option controls warnings when a base class is inaccessible in a class derived from it due to ambiguity. The warning is enabled by default. Note that the warning for ambiguous virtual bases is enabled by the</target>
        </trans-unit>
        <trans-unit id="6199fdb67a75703bc6938c6426b3cd53c0cf499e" translate="yes" xml:space="preserve">
          <source>This option controls warnings when a declaration does not specify a type. This warning is enabled by default in C99 and later dialects of C, and also by</source>
          <target state="translated">This option controls warnings when a declaration does not specify a type. This warning is enabled by default in C99 and later dialects of C, and also by</target>
        </trans-unit>
        <trans-unit id="925a6115338780b00aeb738e9eb85ce67e1d1212" translate="yes" xml:space="preserve">
          <source>This option controls warnings when a function is used before being declared. This warning is enabled by default in C99 and later dialects of C, and also by</source>
          <target state="translated">This option controls warnings when a function is used before being declared. This warning is enabled by default in C99 and later dialects of C, and also by</target>
        </trans-unit>
        <trans-unit id="e630e657c926dcb14e35c4ecbe7b78750ea05b99" translate="yes" xml:space="preserve">
          <source>This option controls warnings when an attribute is ignored. This is different from the</source>
          <target state="translated">This option controls warnings when an attribute is ignored. This is different from the</target>
        </trans-unit>
        <trans-unit id="23e0eea7f94b4ed1e828e2932547c5127c9ba599" translate="yes" xml:space="preserve">
          <source>This option controls what floating-point related traps are enabled. Other Alpha compilers call this option</source>
          <target state="translated">이 옵션은 사용 가능한 부동 소수점 관련 트랩을 제어합니다. 다른 알파 컴파일러는이 옵션을 호출</target>
        </trans-unit>
        <trans-unit id="f1154974a88b020f8daf5bb4dc20170e8131c728" translate="yes" xml:space="preserve">
          <source>This option controls whether any out-of-line instance of the &lt;code&gt;__sync&lt;/code&gt; family of functions may be used to implement the C++11 &lt;code&gt;__atomic&lt;/code&gt; family of functions.</source>
          <target state="translated">이 옵션은 &lt;code&gt;__sync&lt;/code&gt; 함수 함수 의 라인 외부 인스턴스가 C ++ 11 &lt;code&gt;__atomic&lt;/code&gt; 함수 함수 를 구현하는 데 사용될 수 있는지 여부를 제어합니다 .</target>
        </trans-unit>
        <trans-unit id="a4a02927707c45d100e334cb80281cfb05688e67" translate="yes" xml:space="preserve">
          <source>This option controls which NOP insertion scheme is used during the second scheduling pass. The argument &lt;var&gt;scheme&lt;/var&gt; takes one of the following values:</source>
          <target state="translated">이 옵션은 두 번째 예약 단계에서 어떤 NOP 삽입 체계가 사용되는지 제어합니다. 인수 &lt;var&gt;scheme&lt;/var&gt; 는 다음 값 중 하나를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c08ef18f138d574270868ecf3d1af53b2152507f" translate="yes" xml:space="preserve">
          <source>This option controls which dependences are considered costly by the target during instruction scheduling. The argument &lt;var&gt;dependence_type&lt;/var&gt; takes one of the following values:</source>
          <target state="translated">이 옵션은 명령 스케줄링 중에 대상이 비용이 많이 드는 것으로 간주되는 종속성을 제어합니다. &lt;var&gt;dependence_type&lt;/var&gt; 인수 는 다음 값 중 하나를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="eabb06a775f104526b72d8801ca8d34d938d08ee" translate="yes" xml:space="preserve">
          <source>This option controls which reciprocal estimate instructions may be used. &lt;var&gt;opt&lt;/var&gt; is a comma-separated list of options, which may be preceded by a &amp;lsquo;</source>
          <target state="translated">이 옵션은 사용될 상호 추정 명령을 제어합니다. &lt;var&gt;opt&lt;/var&gt; 는 쉼표로 구분 된 옵션 목록이며 앞에 '</target>
        </trans-unit>
        <trans-unit id="c61955646b487d462957b5ea4ab670cca58e8127" translate="yes" xml:space="preserve">
          <source>This option controls which reciprocal estimate instructions may be used. &lt;var&gt;opt&lt;/var&gt; is a comma-separated list of options, which may be preceded by a &lt;code&gt;!&lt;/code&gt; to invert the option:</source>
          <target state="translated">이 옵션은 사용될 상호 추정 명령을 제어합니다. &lt;var&gt;opt&lt;/var&gt; 는 쉼표로 구분 된 옵션 목록이며 앞에 &lt;code&gt;!&lt;/code&gt; 가 올 수 있습니다 . 옵션을 반전 시키려면 :</target>
        </trans-unit>
        <trans-unit id="a2ecce718b608dfca621af1742e2244436537a5c" translate="yes" xml:space="preserve">
          <source>This option currently only works for RTL dumps, and the RTL is always dumped in slim form.</source>
          <target state="translated">이 옵션은 현재 RTL 덤프에서만 작동하며 RTL은 항상 슬림 형태로 덤프됩니다.</target>
        </trans-unit>
        <trans-unit id="a0efcaa928c1eb50d04d69e5ea5969a7461e4235" translate="yes" xml:space="preserve">
          <source>This option defaults to</source>
          <target state="translated">이 옵션의 기본값은</target>
        </trans-unit>
        <trans-unit id="9fc2236cfdc032c6f548639c70136cdca6a33540" translate="yes" xml:space="preserve">
          <source>This option disables a target-specific pass in</source>
          <target state="translated">이 옵션은 대상별 패스를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="c70b4cbddab92e21116da323b06dd29142551856" translate="yes" xml:space="preserve">
          <source>This option disables all previously enabled sanitizers.</source>
          <target state="translated">이 옵션은 이전에 활성화 된 모든 소독제를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="331b4b3e9a10408d9fe49b419ac451d5b43afbf6" translate="yes" xml:space="preserve">
          <source>This option does not affect the behavior of the</source>
          <target state="translated">이 옵션은 동작에 영향을 미치지 않습니다</target>
        </trans-unit>
        <trans-unit id="654b3209c6de0a321e02002e434d9a9983c5a1bb" translate="yes" xml:space="preserve">
          <source>This option does not suppress the preprocessor&amp;rsquo;s debug output, such as</source>
          <target state="translated">이 옵션은 다음과 같은 전 처리기의 디버그 출력을 억제하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="90399aa992409c6c8444d2b7bc23fef6bd0b23f1" translate="yes" xml:space="preserve">
          <source>This option does not warn about designated initializers, so the following modification does not trigger a warning:</source>
          <target state="translated">이 옵션은 지정된 이니셜 라이저에 대해 경고하지 않으므로 다음 수정은 경고를 트리거하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="637d485d36be088d5dc6290430edcc3559942fb2" translate="yes" xml:space="preserve">
          <source>This option does not work in the presence of shared libraries or nested functions.</source>
          <target state="translated">이 옵션은 공유 라이브러리 또는 중첩 함수가있는 경우 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b6cfd2996b7bd042cf9971ccd157a3b5ed5d4172" translate="yes" xml:space="preserve">
          <source>This option enable the compiler to emit &lt;code&gt;enter&lt;/code&gt; and &lt;code&gt;leave&lt;/code&gt; instructions. These instructions are only valid for CPUs with code-density feature.</source>
          <target state="translated">이 옵션을 사용하면 컴파일러가 &lt;code&gt;enter&lt;/code&gt; 및 &lt;code&gt;leave&lt;/code&gt; 명령 을 내릴 수 있습니다 . 이 명령어는 코드 밀도 기능이있는 CPU에만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="f36e3ffcf2c8e8b04ebd85e66df66aa0c1508360" translate="yes" xml:space="preserve">
          <source>This option enables GCC to generate &lt;code&gt;CMPXCHG16B&lt;/code&gt; instructions in 64-bit code to implement compare-and-exchange operations on 16-byte aligned 128-bit objects. This is useful for atomic updates of data structures exceeding one machine word in size. The compiler uses this instruction to implement &lt;a href=&quot;_005f_005fsync-builtins#g_t_005f_005fsync-Builtins&quot;&gt;__sync Builtins&lt;/a&gt;. However, for &lt;a href=&quot;_005f_005fatomic-builtins#g_t_005f_005fatomic-Builtins&quot;&gt;__atomic Builtins&lt;/a&gt; operating on 128-bit integers, a library call is always used.</source>
          <target state="translated">이 옵션을 사용하면 GCC가 64 비트 코드로 &lt;code&gt;CMPXCHG16B&lt;/code&gt; 명령어 를 생성 하여 16 바이트로 정렬 된 128 비트 객체에서 비교 및 ​​교환 작업을 구현할 수 있습니다. 이것은 하나의 기계어 크기를 초과하는 데이터 구조의 원자 업데이트에 유용합니다. 컴파일러는이 명령어를 사용하여 &lt;a href=&quot;_005f_005fsync-builtins#g_t_005f_005fsync-Builtins&quot;&gt;__sync Builtins&lt;/a&gt; 을 구현 합니다. 그러나 128 비트 정수에서 작동하는 &lt;a href=&quot;_005f_005fatomic-builtins#g_t_005f_005fatomic-Builtins&quot;&gt;__atomic Builtins의&lt;/a&gt; 경우 항상 라이브러리 호출이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="111a14f183c415ed55eeae4c39a6e2dbf86ced81" translate="yes" xml:space="preserve">
          <source>This option enables a predefined, named set of custom instruction encodings (see</source>
          <target state="translated">이 옵션은 사전 정의 된 명명 된 사용자 정의 명령어 인코딩 세트를 활성화합니다 (참조</target>
        </trans-unit>
        <trans-unit id="ba4e36ba668d3f1644121ffdad98a65c14adabae" translate="yes" xml:space="preserve">
          <source>This option enables an static analysis of program flow which looks for &amp;ldquo;interesting&amp;rdquo; interprocedural paths through the code, and issues warnings for problems found on them.</source>
          <target state="translated">This option enables an static analysis of program flow which looks for &amp;ldquo;interesting&amp;rdquo; interprocedural paths through the code, and issues warnings for problems found on them.</target>
        </trans-unit>
        <trans-unit id="d1bfbfd499b3c5f5bc13445a47161400b4906077" translate="yes" xml:space="preserve">
          <source>This option enables built-in functions &lt;code&gt;__builtin_ia32_crc32qi&lt;/code&gt;, &lt;code&gt;__builtin_ia32_crc32hi&lt;/code&gt;, &lt;code&gt;__builtin_ia32_crc32si&lt;/code&gt; and &lt;code&gt;__builtin_ia32_crc32di&lt;/code&gt; to generate the &lt;code&gt;crc32&lt;/code&gt; machine instruction.</source>
          <target state="translated">이 옵션을 사용하면 내장 함수 &lt;code&gt;__builtin_ia32_crc32qi&lt;/code&gt; , &lt;code&gt;__builtin_ia32_crc32hi&lt;/code&gt; , &lt;code&gt;__builtin_ia32_crc32si&lt;/code&gt; 및 &lt;code&gt;__builtin_ia32_crc32di&lt;/code&gt; 가 &lt;code&gt;crc32&lt;/code&gt; 기계 명령어 를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2cd918ec8f0e039c766cf7fe1d48f22e6df60ce4" translate="yes" xml:space="preserve">
          <source>This option enables checking of alignment of pointers when they are dereferenced, or when a reference is bound to insufficiently aligned target, or when a method or constructor is invoked on insufficiently aligned object.</source>
          <target state="translated">이 옵션을 사용하면 포인터가 역 참조되거나 참조가 불완전하게 정렬 된 대상에 바인딩되거나 불완전하게 정렬 된 객체에서 메서드 나 생성자가 호출 될 때 포인터의 정렬을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50199f80fe90cda9539f52ff8308973833026d26" translate="yes" xml:space="preserve">
          <source>This option enables checking that the result of a shift operation is not undefined. Note that what exactly is considered undefined differs slightly between C and C++, as well as between ISO C90 and C99, etc. This option has two suboptions,</source>
          <target state="translated">이 옵션을 사용하면 시프트 작업의 결과가 정의되지 않았는지 확인할 수 있습니다. 정확히 정의되지 않은 것으로 간주되는 것은 C와 C ++ 및 ISO C90과 C99 등에서 약간 다릅니다.이 옵션에는 두 가지 하위 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="85b4168b985dbcf1d69994ce5cb2c45b6d1daccb" translate="yes" xml:space="preserve">
          <source>This option enables checking that the second argument of a shift operation is not negative and is smaller than the precision of the promoted first argument.</source>
          <target state="translated">이 옵션을 사용하면 시프트 연산의 두 번째 인수가 음수가 아니고 승격 된 첫 번째 인수의 정밀도보다 작은 지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="938ba4d02fa2f3fd34289d2d8d2d36eb752b42e2" translate="yes" xml:space="preserve">
          <source>This option enables floating-point type to integer conversion checking. We check that the result of the conversion does not overflow. Unlike other similar options,</source>
          <target state="translated">이 옵션을 사용하면 부동 소수점 유형을 정수로 변환 할 수 있습니다. 변환 결과가 오버플로되지 않는지 확인합니다. 다른 유사한 옵션과 달리</target>
        </trans-unit>
        <trans-unit id="2be71ee2359ef67de5a090bb541bf4acc1394953" translate="yes" xml:space="preserve">
          <source>This option enables functions to be overloaded for ordinary and UTF-8 strings:</source>
          <target state="translated">이 옵션을 사용하면 일반 및 UTF-8 문자열에 대해 함수를 오버로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2c29fc89d033f54fcdc9384885989225fe300ca" translate="yes" xml:space="preserve">
          <source>This option enables generation of &lt;code&gt;SAHF&lt;/code&gt; instructions in 64-bit code. Early Intel Pentium 4 CPUs with Intel 64 support, prior to the introduction of Pentium 4 G1 step in December 2005, lacked the &lt;code&gt;LAHF&lt;/code&gt; and &lt;code&gt;SAHF&lt;/code&gt; instructions which are supported by AMD64. These are load and store instructions, respectively, for certain status flags. In 64-bit mode, the &lt;code&gt;SAHF&lt;/code&gt; instruction is used to optimize &lt;code&gt;fmod&lt;/code&gt;, &lt;code&gt;drem&lt;/code&gt;, and &lt;code&gt;remainder&lt;/code&gt; built-in functions; see &lt;a href=&quot;other-builtins#Other-Builtins&quot;&gt;Other Builtins&lt;/a&gt; for details.</source>
          <target state="translated">이 옵션을 사용하면 64 비트 코드 로 &lt;code&gt;SAHF&lt;/code&gt; 명령어를 생성 할 수 있습니다. 2005 년 12 월 Pentium 4 G1 단계를 도입하기 전에 Intel 64를 지원하는 초기 Intel Pentium 4 CPU에는 AMD64에서 지원 하는 &lt;code&gt;LAHF&lt;/code&gt; 및 &lt;code&gt;SAHF&lt;/code&gt; 명령 이 없었습니다 . 이들은 특정 상태 플래그에 대한로드 및 저장 명령어입니다. 64 비트 모드에서 &lt;code&gt;SAHF&lt;/code&gt; 명령어는 &lt;code&gt;fmod&lt;/code&gt; , &lt;code&gt;drem&lt;/code&gt; 및 &lt;code&gt;remainder&lt;/code&gt; 내장 기능 을 최적화하는 데 사용됩니다 . 자세한 내용은 &lt;a href=&quot;other-builtins#Other-Builtins&quot;&gt;Other Builtins&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bf9eedf73e4d0015fa244bb4f5c3569d74469415" translate="yes" xml:space="preserve">
          <source>This option enables instrumentation of C++ member function calls, member accesses and some conversions between pointers to base and derived classes, to verify the referenced object has the correct dynamic type.</source>
          <target state="translated">이 옵션을 사용하면 참조 된 객체에 올바른 동적 유형이 있는지 확인하기 위해 C ++ 멤버 함수 호출, 멤버 액세스 및 기본 및 파생 클래스에 대한 포인터 간의 일부 변환을 계측 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7dd18b0f972bb3a966564c3387d23513ed8f1114" translate="yes" xml:space="preserve">
          <source>This option enables instrumentation of arguments to selected builtin functions. If an invalid value is passed to such arguments, a run-time error is issued. E.g. passing 0 as the argument to &lt;code&gt;__builtin_ctz&lt;/code&gt; or &lt;code&gt;__builtin_clz&lt;/code&gt; invokes undefined behavior and is diagnosed by this option.</source>
          <target state="translated">이 옵션을 사용하면 선택된 내장 함수에 대한 인수를 계측 할 수 있습니다. 이러한 인수에 유효하지 않은 값이 전달되면 런타임 오류가 발생합니다. 예를 들어 &lt;code&gt;__builtin_ctz&lt;/code&gt; 또는 &lt;code&gt;__builtin_clz&lt;/code&gt; 에 인수로 0을 전달 하면 정의되지 않은 동작이 호출 되고이 옵션으로 진단됩니다.</target>
        </trans-unit>
        <trans-unit id="4707da904f3b017d856d15dd2d0965e19870e1d8" translate="yes" xml:space="preserve">
          <source>This option enables instrumentation of array bounds. Various out of bounds accesses are detected. Flexible array members, flexible array member-like arrays, and initializers of variables with static storage are not instrumented.</source>
          <target state="translated">이 옵션을 사용하면 배열 범위를 계측 할 수 있습니다. 다양한 범위를 벗어난 액세스가 감지됩니다. 유연한 스토리지 멤버, 유연한 스토리지 멤버 유사 어레이 및 정적 스토리지를 사용하는 변수의 초기화는 인스트루먼트되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2e349da95c57c4503e630d88b725ecb09ef50689" translate="yes" xml:space="preserve">
          <source>This option enables instrumentation of calls, checking whether null values are not passed to arguments marked as requiring a non-null value by the &lt;code&gt;nonnull&lt;/code&gt; function attribute.</source>
          <target state="translated">이 옵션은 널 (null)이 &lt;code&gt;nonnull&lt;/code&gt; 함수 속성에 의해 널 이 아닌 값을 요구하는 것으로 표시된 인수에 널 (NULL) 값이 전달되지 않는지 여부를 확인하여 호출을 계측 할 수있게 합니다.</target>
        </trans-unit>
        <trans-unit id="8d56bee13b4f38d072afa312adba62366dd96324" translate="yes" xml:space="preserve">
          <source>This option enables instrumentation of loads from an enum type. If a value outside the range of values for the enum type is loaded, a run-time error is issued.</source>
          <target state="translated">이 옵션을 사용하면 열거 형 유형의로드를 계측 할 수 있습니다. 열거 형 유형의 값 범위를 벗어난 값이로드되면 런타임 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8bae34f78ab33cc208a29bdcebb31b30f37fdfdb" translate="yes" xml:space="preserve">
          <source>This option enables instrumentation of loads from bool. If a value other than 0/1 is loaded, a run-time error is issued.</source>
          <target state="translated">이 옵션을 사용하면 부울에서 하중을 계측 할 수 있습니다. 0/1 이외의 값이로드되면 런타임 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="46c1b7dde6bdde5a1a374986dc5119119957fbe3" translate="yes" xml:space="preserve">
          <source>This option enables instrumentation of memory references using the &lt;code&gt;__builtin_object_size&lt;/code&gt; function. Various out of bounds pointer accesses are detected.</source>
          <target state="translated">이 옵션은 &lt;code&gt;__builtin_object_size&lt;/code&gt; 함수를 사용하여 메모리 참조를 계측 할 수 있습니다. 다양한 범위를 벗어난 포인터 액세스가 감지됩니다.</target>
        </trans-unit>
        <trans-unit id="0292138149978c95eacc8642af7ff43cfe7b2264" translate="yes" xml:space="preserve">
          <source>This option enables instrumentation of pointer arithmetics. If the pointer arithmetics overflows, a run-time error is issued.</source>
          <target state="translated">이 옵션을 사용하면 포인터 산술을 계측 할 수 있습니다. 포인터 산술 오버플로가 발생하면 런타임 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="430110abdd161cbe658a0d2f529325e1208cd453" translate="yes" xml:space="preserve">
          <source>This option enables instrumentation of return statements in functions marked with &lt;code&gt;returns_nonnull&lt;/code&gt; function attribute, to detect returning of null values from such functions.</source>
          <target state="translated">이 옵션을 사용하면 &lt;code&gt;returns_nonnull&lt;/code&gt; 함수 속성으로 표시된 함수에서 return 문을 계측하여 해당 함수에서 null 값의 반환을 감지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb16ef94b917da96c006db5cf05527388bed65b9" translate="yes" xml:space="preserve">
          <source>This option enables or disables warnings about conflicts between the MCU name specified by the</source>
          <target state="translated">이 옵션은 지정된 MCU 이름 간의 충돌에 대한 경고를 활성화 또는 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="f864b078493b6651bb86e363b143af67066fe079" translate="yes" xml:space="preserve">
          <source>This option enables pointer checking. Particularly, the application built with this option turned on will issue an error message when it tries to dereference a NULL pointer, or if a reference (possibly an rvalue reference) is bound to a NULL pointer, or if a method is invoked on an object pointed by a NULL pointer.</source>
          <target state="translated">이 옵션은 포인터 검사를 활성화합니다. 특히,이 옵션이 켜져있는 응용 프로그램은 NULL 포인터를 역 참조하려고하거나 참조 (rvalue 참조)가 NULL 포인터에 바인딩되어 있거나 객체에서 메서드가 호출 된 경우 오류 메시지를 표시합니다. NULL 포인터로 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="9390f84ab3c6840aa43bf14f385886239ff26f9c" translate="yes" xml:space="preserve">
          <source>This option enables return statement checking. Programs built with this option turned on will issue an error message when the end of a non-void function is reached without actually returning a value. This option works in C++ only.</source>
          <target state="translated">이 옵션은 return 문 검사를 활성화합니다. 이 옵션을 설정하여 빌드 한 프로그램은 실제로 값을 반환하지 않고 비 공백 기능의 끝에 도달하면 오류 메시지를 표시합니다. 이 옵션은 C ++에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="c5e06b2ed5aaf18ef55b254444b859dc73b64e5e" translate="yes" xml:space="preserve">
          <source>This option enables signed integer overflow checking. We check that the result of &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, and both unary and binary &lt;code&gt;-&lt;/code&gt; does not overflow in the signed arithmetics. Note, integer promotion rules must be taken into account. That is, the following is not an overflow:</source>
          <target state="translated">이 옵션은 부호있는 정수 오버 플로우 검사를 활성화합니다. 우리는 확인 결과 그 &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , 모두 단항 및 이진 &lt;code&gt;-&lt;/code&gt; 서명를 arithmetics에없는 오버 플로우 않습니다. 정수 승격 규칙을 고려해야합니다. 즉, 다음은 오버플로가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="5aa6ebd08f1df0b8312082dee55c79f646e3aa80" translate="yes" xml:space="preserve">
          <source>This option enables strict instrumentation of array bounds. Most out of bounds accesses are detected, including flexible array members and flexible array member-like arrays. Initializers of variables with static storage are not instrumented.</source>
          <target state="translated">이 옵션을 사용하면 배열 범위를 엄격하게 계측 할 수 있습니다. 유연한 배열 구성원 및 유연한 배열 구성원 유사 배열을 포함하여 대부분 범위를 벗어난 액세스가 감지됩니다. 정적 스토리지가있는 변수의 초기자는 계측되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="35547d9fdeedd115e10a5da6add0bd1af02febf6" translate="yes" xml:space="preserve">
          <source>This option enables the extraction of object files with GIMPLE bytecode out of library archives. This improves the quality of optimization by exposing more code to the link-time optimizer. This information specifies what symbols can be accessed externally (by non-LTO object or during dynamic linking). Resulting code quality improvements on binaries (and shared libraries that use hidden visibility) are similar to</source>
          <target state="translated">이 옵션을 사용하면 라이브러리 아카이브에서 GIMPLE 바이트 코드가있는 오브젝트 파일을 추출 할 수 있습니다. 이는 링크 타임 옵티 마이저에 더 많은 코드를 노출시켜 최적화 품질을 향상시킵니다. 이 정보는 외부 (LTO 이외 오브젝트 또는 동적 링크 중)에 액세스 할 수있는 기호를 지정합니다. 바이너리 (및 숨겨진 가시성을 사용하는 공유 라이브러리)의 결과 코드 품질 개선은 다음과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="aff42a7c223b12e8af263b78f8decfd79d138482" translate="yes" xml:space="preserve">
          <source>This option enables transitivity of constraints within the analyzer.</source>
          <target state="translated">This option enables transitivity of constraints within the analyzer.</target>
        </trans-unit>
        <trans-unit id="e139de52e12e355ab2f4aceaceda024599afb6f0" translate="yes" xml:space="preserve">
          <source>This option enables use of &lt;code&gt;RCPSS&lt;/code&gt; and &lt;code&gt;RSQRTSS&lt;/code&gt; instructions (and their vectorized variants &lt;code&gt;RCPPS&lt;/code&gt; and &lt;code&gt;RSQRTPS&lt;/code&gt;) with an additional Newton-Raphson step to increase precision instead of &lt;code&gt;DIVSS&lt;/code&gt; and &lt;code&gt;SQRTSS&lt;/code&gt; (and their vectorized variants) for single-precision floating-point arguments. These instructions are generated only when</source>
          <target state="translated">이 옵션을 사용하면 단 정밀도 부동 소수점 인수에 대해 &lt;code&gt;DIVSS&lt;/code&gt; 및 &lt;code&gt;SQRTSS&lt;/code&gt; (및 벡터화 된 변형) 대신 정밀도를 높이기 위해 추가 Newton-Raphson 단계와 함께 &lt;code&gt;RCPSS&lt;/code&gt; 및 &lt;code&gt;RSQRTSS&lt;/code&gt; 명령어 (및 벡터화 된 변형 &lt;code&gt;RCPPS&lt;/code&gt; 및 &lt;code&gt;RSQRTPS&lt;/code&gt; )를 사용할 수 있습니다. 이 명령어는 다음과 같은 경우에만 생성됩니다</target>
        </trans-unit>
        <trans-unit id="060df32e86c55ba7cad1df047f45c9f196518594" translate="yes" xml:space="preserve">
          <source>This option enables use of the &lt;code&gt;movbe&lt;/code&gt; instruction to implement &lt;code&gt;__builtin_bswap32&lt;/code&gt; and &lt;code&gt;__builtin_bswap64&lt;/code&gt;.</source>
          <target state="translated">이 옵션을 사용하면 &lt;code&gt;movbe&lt;/code&gt; 명령어를 사용하여 &lt;code&gt;__builtin_bswap32&lt;/code&gt; 및 &lt;code&gt;__builtin_bswap64&lt;/code&gt; 를 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3be41468437cbd33ddbb5938cf95baa409134252" translate="yes" xml:space="preserve">
          <source>This option enables use of the reciprocal estimate and reciprocal square root estimate instructions with additional Newton-Raphson steps to increase precision instead of doing a divide or square root and divide for floating-point arguments. You should use the</source>
          <target state="translated">이 옵션을 사용하면 부동 소수점 인수에 대해 나누기 또는 제곱근을 나누는 대신 정밀도를 높이기 위해 추가 Newton-Raphson 단계와 함께 역 추정 및 역 근근 추정 명령을 사용할 수 있습니다. 당신은 사용해야합니다</target>
        </trans-unit>
        <trans-unit id="b8b0cc8f7ad08d6547ab80b77c947a16db351cd7" translate="yes" xml:space="preserve">
          <source>This option forces GCC to use custom shadow offset in AddressSanitizer checks. It is useful for experimenting with different shadow memory layouts in Kernel AddressSanitizer.</source>
          <target state="translated">이 옵션은 GCC가 AddressSanitizer 검사에서 커스텀 섀도우 오프셋을 사용하도록합니다. Kernel AddressSanitizer에서 다른 섀도 메모리 레이아웃을 실험하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="3233daa383d4066b02b1657216dd534dd8974913" translate="yes" xml:space="preserve">
          <source>This option generates traps for signed overflow on addition, subtraction, multiplication operations. The options</source>
          <target state="translated">이 옵션은 더하기, 빼기, 곱하기 연산에서 부호있는 오버플로에 대한 트랩을 생성합니다. 옵션</target>
        </trans-unit>
        <trans-unit id="bc361006809087722b4665eda3af889c660cf7bb" translate="yes" xml:space="preserve">
          <source>This option has no effect on abicalls code. The default is</source>
          <target state="translated">이 옵션은 abicalls 코드에는 영향을 미치지 않습니다. 디폴트는</target>
        </trans-unit>
        <trans-unit id="ce202009f104c41c762f668a2d6d18c3bbd55f2a" translate="yes" xml:space="preserve">
          <source>This option ignored; it is provided for compatibility purposes only. Software floating-point code is emitted by default, and this default can overridden by FPX options;</source>
          <target state="translated">이 옵션은 무시되었습니다. 호환성 목적으로 만 제공됩니다. 소프트웨어 부동 소수점 코드는 기본적으로 생성되며이 기본값은 FPX 옵션으로 대체 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d295e879be9d8d469fabe64723a6a09c1d8dadcc" translate="yes" xml:space="preserve">
          <source>This option implies</source>
          <target state="translated">이 옵션은</target>
        </trans-unit>
        <trans-unit id="8ef84b2b0112928af774bc0bf4f11244d39995fa" translate="yes" xml:space="preserve">
          <source>This option inhibits the use of 68020 and 68881/68882 instructions that have to be emulated by software on the 68060. Use this option if your 68060 does not have code to emulate those instructions.</source>
          <target state="translated">이 옵션은 68060에서 소프트웨어로 에뮬레이션해야하는 68020 및 68881/68882 명령의 사용을 금지합니다. 68060에 해당 명령을 에뮬레이트하는 코드가없는 경우이 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="efb405ef4149f232764b47255e26eb73c1775fc9" translate="yes" xml:space="preserve">
          <source>This option inhibits the use of 68881/68882 instructions that have to be emulated by software on the 68040. Use this option if your 68040 does not have code to emulate those instructions.</source>
          <target state="translated">이 옵션은 68040에서 소프트웨어로 에뮬레이션해야하는 68881/68882 명령의 사용을 금지합니다. 68040에 해당 명령을 에뮬레이트하는 코드가없는 경우이 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e0c66bcd77c8bed54eff907c145c1ea37c3f6555" translate="yes" xml:space="preserve">
          <source>This option instructs CPP to add a phony target for each dependency other than the main file, causing each to depend on nothing. These dummy rules work around errors &lt;code&gt;make&lt;/code&gt; gives if you remove header files without updating the</source>
          <target state="translated">이 옵션은 CPP가 기본 파일 이외의 각 종속성에 대한 가짜 대상을 추가하여 각 항목이 아무 것도 의존하지 않도록 지시합니다. 이러한 더미 규칙은 업데이트하지 않고 헤더 파일을 제거하면 오류 &lt;code&gt;make&lt;/code&gt; 해결합니다 .</target>
        </trans-unit>
        <trans-unit id="3c687d2d1d2116a0ccc32795fd0f0f68e88ed641" translate="yes" xml:space="preserve">
          <source>This option instructs GCC to dump the names of the x86 performance tuning features and default settings. The names can be used in</source>
          <target state="translated">이 옵션은 GCC에 x86 성능 조정 기능의 이름과 기본 설정을 덤프하도록 지시합니다. 이름을 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="38a021cb20751050e831beceef3d4668ce4cf298" translate="yes" xml:space="preserve">
          <source>This option instructs GCC to emit a &lt;code&gt;cld&lt;/code&gt; instruction in the prologue of functions that use string instructions. String instructions depend on the DF flag to select between autoincrement or autodecrement mode. While the ABI specifies the DF flag to be cleared on function entry, some operating systems violate this specification by not clearing the DF flag in their exception dispatchers. The exception handler can be invoked with the DF flag set, which leads to wrong direction mode when string instructions are used. This option can be enabled by default on 32-bit x86 targets by configuring GCC with the</source>
          <target state="translated">이 옵션은 GCC가 문자열 명령어를 사용하는 프롤로그 기능에서 &lt;code&gt;cld&lt;/code&gt; 명령어 를 내도록 지시합니다. 문자열 명령어는 DF 플래그에 따라 자동 증가 또는 자동 감소 모드 중에서 선택합니다. ABI는 함수 입력시 DF 플래그를 지우도록 지정하지만 일부 운영 체제는 예외 디스패처에서 DF 플래그를 지우지 않아이 사양을 위반합니다. DF 플래그 세트로 예외 핸들러를 호출 할 수 있으며, 이는 문자열 명령이 사용될 때 잘못된 방향 모드로 이어집니다. 이 옵션은 기본적으로 32 비트 x86 대상에서 GCC를 구성하여 활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="657b508727e487887f711193a95e39499f48960e" translate="yes" xml:space="preserve">
          <source>This option instructs GCC to emit a &lt;code&gt;vzeroupper&lt;/code&gt; instruction before a transfer of control flow out of the function to minimize the AVX to SSE transition penalty as well as remove unnecessary &lt;code&gt;zeroupper&lt;/code&gt; intrinsics.</source>
          <target state="translated">이 옵션 은 제어 흐름을 함수 밖으로 전송하기 전에 GCC가 &lt;code&gt;vzeroupper&lt;/code&gt; 명령을 내보내 도록 지시하여 AVX에서 SSE 로의 전환 페널티를 최소화하고 불필요한 &lt;code&gt;zeroupper&lt;/code&gt; 내장 함수 를 제거 합니다.</target>
        </trans-unit>
        <trans-unit id="3c78872fcf66a452b582423621f5fae766269c85" translate="yes" xml:space="preserve">
          <source>This option instructs GCC to turn off all tunable features. See also</source>
          <target state="translated">이 옵션은 GCC가 모든 조정 가능한 기능을 끄도록 지시합니다. 또한보십시오</target>
        </trans-unit>
        <trans-unit id="3d9dd501c30e561cb69d40cbc9373ad471302725" translate="yes" xml:space="preserve">
          <source>This option instructs GCC to use 128-bit AVX instructions instead of 256-bit AVX instructions in the auto-vectorizer.</source>
          <target state="translated">이 옵션은 GCC가 자동 벡터 화기에서 256 비트 AVX 명령어 대신 128 비트 AVX 명령어를 사용하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="e6945bdd3deb13214c6bf659bc52045e04a70f0e" translate="yes" xml:space="preserve">
          <source>This option instructs GCC to use &lt;var&gt;opt&lt;/var&gt;-bit vector width in instructions instead of default on the selected platform.</source>
          <target state="translated">이 옵션 은 선택한 플랫폼에서 기본값 대신 &lt;var&gt;opt&lt;/var&gt; -bit 벡터 너비를 명령어 에 사용 하도록 GCC 에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="dbda0a70a5f352dad89f90d04caa28e3bd6d0703" translate="yes" xml:space="preserve">
          <source>This option instructs the compiler to assume that pointer arithmetic overflow on addition and subtraction wraps around using twos-complement representation. This flag disables some optimizations which assume pointer overflow is invalid.</source>
          <target state="translated">이 옵션은 덧셈과 뺄셈에서 포인터 산술 오버플로가 2의 보수 표현을 사용하여 랩핑한다고 가정하도록 컴파일러에 지시합니다. 이 플래그는 포인터 오버 플로우가 유효하지 않다고 가정하는 일부 최적화를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="f816312ce41ee12df0f414176d9a5763b90df530" translate="yes" xml:space="preserve">
          <source>This option instructs the compiler to assume that signed arithmetic overflow of addition, subtraction and multiplication wraps around using twos-complement representation. This flag enables some optimizations and disables others. The options</source>
          <target state="translated">이 옵션은 덧셈, 뺄셈 및 곱셈의 부호있는 산술 오버플로가 2의 보수 표현을 사용한다고 가정하도록 컴파일러에 지시합니다. 이 플래그는 일부 최적화를 활성화하고 다른 최적화를 비활성화합니다. 옵션</target>
        </trans-unit>
        <trans-unit id="c431c0c08a8246794b17639d38f5f9732adef200" translate="yes" xml:space="preserve">
          <source>This option instructs the compiler to check that the size of a variable length array is positive.</source>
          <target state="translated">이 옵션은 가변 길이 배열의 크기가 양수인지 확인하도록 컴파일러에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="0d3ab8d594e88fea27629172c62534cedd7e9ccd" translate="yes" xml:space="preserve">
          <source>This option instructs the compiler to generate code for a 16-entry register file. This option defines the &lt;code&gt;__ARC_RF16__&lt;/code&gt; preprocessor macro.</source>
          <target state="translated">이 옵션은 16 개 엔트리 레지스터 파일에 대한 코드를 생성하도록 컴파일러에 지시합니다. 이 옵션은 &lt;code&gt;__ARC_RF16__&lt;/code&gt; 전 처리기 매크로를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="b138f51e639bc0b32ca1dc63d0195b9a7cfb2e6c" translate="yes" xml:space="preserve">
          <source>This option is a detailed version of</source>
          <target state="translated">이 옵션은 자세한 버전입니다</target>
        </trans-unit>
        <trans-unit id="0777795174f336ed7d700a302e0b548f3225ecd3" translate="yes" xml:space="preserve">
          <source>This option is also passed on to the assembler.</source>
          <target state="translated">이 옵션은 또한 어셈블러로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="0a8a587d88750f4b64f0573d837060922995e692" translate="yes" xml:space="preserve">
          <source>This option is always enabled by default on certain machines, usually those which have no call-preserved registers to use instead.</source>
          <target state="translated">이 옵션은 특정 시스템에서 항상 기본적으로 활성화되어 있습니다. 일반적으로 대신 통화 보존 레지스터가없는 시스템입니다.</target>
        </trans-unit>
        <trans-unit id="87c9194e0e60c9d507f16257e56fa4da6140cc2a" translate="yes" xml:space="preserve">
          <source>This option is available for Cygwin and MinGW targets. It specifies that a DLL&amp;mdash;a dynamic link library&amp;mdash;is to be generated, enabling the selection of the required runtime startup object and entry point.</source>
          <target state="translated">이 옵션은 Cygwin 및 MinGW 대상에 사용할 수 있습니다. DLL (동적 링크 라이브러리)이 생성되도록 지정하여 필요한 런타임 시작 개체 및 진입 점을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34974b8a3ddccb37978e6f7f3ab9b870fb775b53" translate="yes" xml:space="preserve">
          <source>This option is available for Cygwin and MinGW targets. It specifies that a GUI application is to be generated by instructing the linker to set the PE header subsystem type appropriately.</source>
          <target state="translated">이 옵션은 Cygwin 및 MinGW 대상에 사용할 수 있습니다. PE 헤더 하위 시스템 유형을 적절하게 설정하도록 링커에 지시하여 GUI 응용 프로그램을 생성하도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="f9c956bb65a4ef29b2924781000ede172dfe35c9" translate="yes" xml:space="preserve">
          <source>This option is available for Cygwin and MinGW targets. It specifies that the &lt;code&gt;dllimport&lt;/code&gt; attribute should be ignored.</source>
          <target state="translated">이 옵션은 Cygwin 및 MinGW 대상에 사용할 수 있습니다. &lt;code&gt;dllimport&lt;/code&gt; 속성을 무시 하도록 지정 합니다.</target>
        </trans-unit>
        <trans-unit id="7e0dc3ae21d5985659301b368b4c95c1db9366f7" translate="yes" xml:space="preserve">
          <source>This option is available for Cygwin and MinGW targets. It specifies that the GNU extension to the PE file format that permits the correct alignment of COMMON variables should be used when generating code. It is enabled by default if GCC detects that the target assembler found during configuration supports the feature.</source>
          <target state="translated">이 옵션은 Cygwin 및 MinGW 대상에 사용할 수 있습니다. 코드를 생성 할 때 COMMON 변수의 올바른 정렬을 허용하는 PE 파일 형식의 GNU 확장이 사용되도록 지정합니다. GCC가 구성 중에 찾은 대상 어셈블러가 기능을 지원함을 감지하면 기본적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9161324109587b09b1694f29c23c72102885dbb9" translate="yes" xml:space="preserve">
          <source>This option is available for Cygwin and MinGW targets. It specifies that the typical Microsoft Windows predefined macros are to be set in the pre-processor, but does not influence the choice of runtime library/startup code.</source>
          <target state="translated">이 옵션은 Cygwin 및 MinGW 대상에 사용할 수 있습니다. 일반적인 Microsoft Windows 사전 정의 매크로가 전 처리기에서 설정되도록 지정하지만 런타임 라이브러리 / 스타트 업 코드 선택에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9e0a3afbd291f88cb3c95726f31687bd36f164b7" translate="yes" xml:space="preserve">
          <source>This option is available for MinGW and Cygwin targets. It specifies that relocated-data in read-only section is put into the &lt;code&gt;.data&lt;/code&gt; section. This is a necessary for older runtimes not supporting modification of &lt;code&gt;.rdata&lt;/code&gt; sections for pseudo-relocation.</source>
          <target state="translated">이 옵션은 MinGW 및 Cygwin 대상에 사용할 수 있습니다. 읽기 전용 섹션의 재배치 된 데이터가 &lt;code&gt;.data&lt;/code&gt; 섹션 에 포함되도록 지정합니다 . 의사 재배치에 대한 &lt;code&gt;.rdata&lt;/code&gt; 섹션의 수정을 지원하지 않는 이전 런타임에 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="acdd2b492fbf0ebaa317f2c48f132b3b62ecde92" translate="yes" xml:space="preserve">
          <source>This option is available for MinGW targets. It specifies that MinGW-specific thread support is to be used.</source>
          <target state="translated">이 옵션은 MinGW 대상에 사용할 수 있습니다. MinGW 관련 스레드 지원을 사용하도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="faee952b0f4c06ee910b880bfbdf149d4685f355" translate="yes" xml:space="preserve">
          <source>This option is available for MinGW targets. It specifies that the executable flag for the stack used by nested functions isn&amp;rsquo;t set. This is necessary for binaries running in kernel mode of Microsoft Windows, as there the User32 API, which is used to set executable privileges, isn&amp;rsquo;t available.</source>
          <target state="translated">이 옵션은 MinGW 대상에 사용할 수 있습니다. 중첩 함수에서 사용하는 스택의 실행 가능 플래그가 설정되지 않도록 지정합니다. 실행 권한을 설정하는 데 사용되는 User32 API를 사용할 수 없으므로 Microsoft Windows의 커널 모드에서 실행중인 바이너리에 필요합니다.</target>
        </trans-unit>
        <trans-unit id="e934759656573ab06e7b01542f8d07b3197cbe74" translate="yes" xml:space="preserve">
          <source>This option is available for MinGW-w64 targets. It causes the &lt;code&gt;UNICODE&lt;/code&gt; preprocessor macro to be predefined, and chooses Unicode-capable runtime startup code.</source>
          <target state="translated">이 옵션은 MinGW-w64 대상에 사용할 수 있습니다. 이 원인 &lt;code&gt;UNICODE&lt;/code&gt; 의 미리 정의 될 처리기 매크로 및 유니 가능한 런타임 시작 코드를 선택한다.</target>
        </trans-unit>
        <trans-unit id="d398f6bbd65088d4b5a66179b5d137a011940d08" translate="yes" xml:space="preserve">
          <source>This option is deprecated and has no effect.</source>
          <target state="translated">This option is deprecated and has no effect.</target>
        </trans-unit>
        <trans-unit id="2059e693abf7ce7ec777bf5e7cc1b18ffae32137" translate="yes" xml:space="preserve">
          <source>This option is deprecated.</source>
          <target state="translated">이 옵션은 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aabeb9acbf850798bff5dd7ad77029ce8ab9ac73" translate="yes" xml:space="preserve">
          <source>This option is deprecated. It pads structures to multiple of 4 bytes, which is incompatible with the SH ABI.</source>
          <target state="translated">이 옵션은 더 이상 사용되지 않습니다. SH ABI와 호환되지 않는 구조를 4 바이트의 배수로 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="9d29c4b41311afb57bb108b16e155cb489ec134b" translate="yes" xml:space="preserve">
          <source>This option is deprecated. Use</source>
          <target state="translated">이 옵션은 더 이상 사용되지 않습니다. 사용하다</target>
        </trans-unit>
        <trans-unit id="4053a3fd19d3968881e6f8e01595ecadbdd30069" translate="yes" xml:space="preserve">
          <source>This option is enabled at level</source>
          <target state="translated">이 옵션은 레벨에서 사용 가능합니다</target>
        </trans-unit>
        <trans-unit id="bf488b640ab82c12aa83d2d5d585a8acb0774751" translate="yes" xml:space="preserve">
          <source>This option is enabled by</source>
          <target state="translated">이 옵션은</target>
        </trans-unit>
        <trans-unit id="1157d5cea597fdcb95a42f4efe9767ae5da67d67" translate="yes" xml:space="preserve">
          <source>This option is enabled by default at</source>
          <target state="translated">This option is enabled by default at</target>
        </trans-unit>
        <trans-unit id="1a1ed53d314baadd464fa2b14f3800bf95fa8ca0" translate="yes" xml:space="preserve">
          <source>This option is enabled by default at optimization levels</source>
          <target state="translated">이 옵션은 최적화 수준에서 기본적으로 활성화됩니다</target>
        </trans-unit>
        <trans-unit id="d247bcb1695bed692a8726f3533be3d2fb1fee0b" translate="yes" xml:space="preserve">
          <source>This option is enabled by default for Microsoft Windows targets. This behavior can also be controlled locally by use of variable or type attributes. For more information, see &lt;a href=&quot;variable-attributes#x86-Variable-Attributes&quot;&gt;x86 Variable Attributes&lt;/a&gt; and &lt;a href=&quot;type-attributes#x86-Type-Attributes&quot;&gt;x86 Type Attributes&lt;/a&gt;.</source>
          <target state="translated">이 옵션은 Microsoft Windows 대상에 기본적으로 사용됩니다. 변수 또는 유형 속성을 사용하여이 동작을 로컬로 제어 할 수도 있습니다. 자세한 내용은 &lt;a href=&quot;variable-attributes#x86-Variable-Attributes&quot;&gt;x86 변수 속성&lt;/a&gt; 및 &lt;a href=&quot;type-attributes#x86-Type-Attributes&quot;&gt;x86 유형 속성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2652d68534c6f88541191086fa1485e27def7fc6" translate="yes" xml:space="preserve">
          <source>This option is enabled by default on most targets. On Nios II ELF, it defaults to off. On AVR, CR16, and MSP430, this option is completely disabled.</source>
          <target state="translated">이 옵션은 대부분의 대상에서 기본적으로 사용됩니다. Nios II ELF에서는 기본적으로 꺼져 있습니다. AVR, CR16 및 MSP430에서는이 옵션이 완전히 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d8c17f97f0a71b6e6913867ec6d9569fa353e80" translate="yes" xml:space="preserve">
          <source>This option is enabled by default when LTO support in GCC is enabled and GCC was configured for use with a linker supporting plugins (GNU ld 2.21 or newer or gold).</source>
          <target state="translated">이 옵션은 GCC에서 LTO 지원이 활성화되어 있고 GCC가 플러그인을 지원하는 링커 (GNU ld 2.21 이상 또는 금)와 함께 사용되도록 구성된 경우 기본적으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="7d53846e4ad58929426e4a8a561e1ca04e4dae26" translate="yes" xml:space="preserve">
          <source>This option is enabled by default when the RH850 ABI is in use (see</source>
          <target state="translated">이 옵션은 RH850 ABI가 사용 중일 때 기본적으로 활성화됩니다 (참조</target>
        </trans-unit>
        <trans-unit id="e8f3025aa92d2d4f667e2309b49f93dcbd8a2cc1" translate="yes" xml:space="preserve">
          <source>This option is experimental and does not currently guarantee to disable all GCC optimizations that affect signaling NaN behavior.</source>
          <target state="translated">이 옵션은 실험용이며 현재 NaN 동작 신호에 영향을주는 모든 GCC 최적화를 사용 중지 할 것을 보장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6bf7bb3d6ca95f65181405f388dc4f38acb33184" translate="yes" xml:space="preserve">
          <source>This option is experimental and does not currently guarantee to disable all GCC optimizations that are affected by rounding mode. Future versions of GCC may provide finer control of this setting using C99&amp;rsquo;s &lt;code&gt;FENV_ACCESS&lt;/code&gt; pragma. This command-line option will be used to specify the default state for &lt;code&gt;FENV_ACCESS&lt;/code&gt;.</source>
          <target state="translated">이 옵션은 실험용이며 현재 반올림 모드의 영향을받는 모든 GCC 최적화를 비활성화하지는 않습니다. 이후 버전의 GCC는 C99의 &lt;code&gt;FENV_ACCESS&lt;/code&gt; pragma를 사용하여이 설정을보다 세밀하게 제어 할 수 있습니다 . 이 명령 행 옵션은 &lt;code&gt;FENV_ACCESS&lt;/code&gt; 의 기본 상태를 지정하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="41c5b1ff9a4b2c16f0283cc8b3e6a1c1ee4e99a0" translate="yes" xml:space="preserve">
          <source>This option is experimental and the format of the data within the compressed JSON file is subject to change.</source>
          <target state="translated">이 옵션은 실험용이며 압축 된 JSON 파일 내의 데이터 형식은 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77c067b7272c8dfb1940d673f7549a9c970673d8" translate="yes" xml:space="preserve">
          <source>This option is ignored and provided for compatibility purposes only.</source>
          <target state="translated">이 옵션은 무시되며 호환성을 위해서만 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="988bc726815f60352325aa80e3adb73dc59e56eb" translate="yes" xml:space="preserve">
          <source>This option is ignored; it is for compatibility purposes only. This used to select linker and preprocessor options for use with newlib.</source>
          <target state="translated">This option is ignored; it is for compatibility purposes only. This used to select linker and preprocessor options for use with newlib.</target>
        </trans-unit>
        <trans-unit id="39bc415cf1072ef041b852cccab7caeb03cebbe9" translate="yes" xml:space="preserve">
          <source>This option is implicitly passed to the compiler for the second compilation requested by</source>
          <target state="translated">이 옵션은 요청한 두 번째 컴파일을 위해 암시 적으로 컴파일러에 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="223090f1188ac1bc38c64fe292f4f4b2503fac75" translate="yes" xml:space="preserve">
          <source>This option is implied by</source>
          <target state="translated">이 옵션은</target>
        </trans-unit>
        <trans-unit id="d3193c2234bb7da293261732a9d8d77268c8fc1c" translate="yes" xml:space="preserve">
          <source>This option is intended for analyzer developers.</source>
          <target state="translated">This option is intended for analyzer developers.</target>
        </trans-unit>
        <trans-unit id="a6f2c53d2e68d97cb3dfd3ec9c7aa21718a8745f" translate="yes" xml:space="preserve">
          <source>This option is intended for analyzer developers. It enables more verbose, lower-level detail in the descriptions of control flow within diagnostic paths.</source>
          <target state="translated">This option is intended for analyzer developers. It enables more verbose, lower-level detail in the descriptions of control flow within diagnostic paths.</target>
        </trans-unit>
        <trans-unit id="d656b9a9c9fb5f6bcdc2b59dc196d049700bd1b2" translate="yes" xml:space="preserve">
          <source>This option is intended for analyzer developers. It enables more verbose, lower-level detail in the descriptions of events relating to state machines within diagnostic paths.</source>
          <target state="translated">This option is intended for analyzer developers. It enables more verbose, lower-level detail in the descriptions of events relating to state machines within diagnostic paths.</target>
        </trans-unit>
        <trans-unit id="4f67300ba0c3c74acfb2d8150e18a2987b0d6f05" translate="yes" xml:space="preserve">
          <source>This option is intended for analyzer developers: if multiple diagnostics have been detected as being duplicates of each other, it emits a note when reporting the best diagnostic, giving the number of additional diagnostics that were suppressed by the deduplication logic.</source>
          <target state="translated">This option is intended for analyzer developers: if multiple diagnostics have been detected as being duplicates of each other, it emits a note when reporting the best diagnostic, giving the number of additional diagnostics that were suppressed by the deduplication logic.</target>
        </trans-unit>
        <trans-unit id="9711864ac531d244797123498f9a9fe143b47ace" translate="yes" xml:space="preserve">
          <source>This option is left for compatibility reasons.</source>
          <target state="translated">이 옵션은 호환성을 위해 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="705dd214fcbbda555d2c25430996631d43106884" translate="yes" xml:space="preserve">
          <source>This option is like the</source>
          <target state="translated">이 옵션은</target>
        </trans-unit>
        <trans-unit id="7ea37451ed423d9b4f565d2cd48781668a2b5f65" translate="yes" xml:space="preserve">
          <source>This option is not turned on by any</source>
          <target state="translated">이 옵션은 어떤 사람도 켜지지 않습니다</target>
        </trans-unit>
        <trans-unit id="9abb00a56e1a1d91dc73fdc3ecd2a22dd97e1ddc" translate="yes" xml:space="preserve">
          <source>This option is off by default, because the resulting preprocessed output is only really suitable as input to GCC. It is switched on by</source>
          <target state="translated">사전 처리 된 결과 출력이 실제로 GCC에 대한 입력으로 만 적합하기 때문에이 옵션은 기본적으로 해제되어 있습니다. 에 의해 켜집니다</target>
        </trans-unit>
        <trans-unit id="4f3ef2c8071d14f453caa189ada503a69384e247" translate="yes" xml:space="preserve">
          <source>This option is only active when</source>
          <target state="translated">이 옵션은 다음과 같은 경우에만 활성화됩니다</target>
        </trans-unit>
        <trans-unit id="a6188b363cf7403f6936d8ff4d2c56a28d236e61" translate="yes" xml:space="preserve">
          <source>This option is only active when signed overflow is undefined. It warns about cases where the compiler optimizes based on the assumption that signed overflow does not occur. Note that it does not warn about all cases where the code might overflow: it only warns about cases where the compiler implements some optimization. Thus this warning depends on the optimization level.</source>
          <target state="translated">이 옵션은 서명 된 오버플로가 정의되지 않은 경우에만 활성화됩니다. 부호있는 오버플로가 발생하지 않는다는 가정에 따라 컴파일러가 최적화되는 경우에 대해 경고합니다. 코드가 오버플로 될 수있는 모든 경우에 대해 경고하는 것은 아니며 컴파일러가 최적화를 구현하는 경우에만 경고합니다. 따라서이 경고는 최적화 수준에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="84e9b00e2175bed56ae8768cc7c1a2405f67103d" translate="yes" xml:space="preserve">
          <source>This option is only applicable when compiling for the base ARMv8.0 instruction set. If using a later revision, e.g.</source>
          <target state="translated">This option is only applicable when compiling for the base ARMv8.0 instruction set. If using a later revision, e.g.</target>
        </trans-unit>
        <trans-unit id="9d25fc758589cd4be71db515ac5f7ca7241f83be" translate="yes" xml:space="preserve">
          <source>This option is only available for ARCv2 cores.</source>
          <target state="translated">이 옵션은 ARCv2 코어에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb2b96b2a317107a5bbb2f1d27d819613a30b1f8" translate="yes" xml:space="preserve">
          <source>This option is only available if GCC was configured with analyzer support enabled.</source>
          <target state="translated">This option is only available if GCC was configured with analyzer support enabled.</target>
        </trans-unit>
        <trans-unit id="47efc2541291ec81a8db6b59aeed231c895bc9c4" translate="yes" xml:space="preserve">
          <source>This option is only available when compiling C++ code. It turns on (or off, if using</source>
          <target state="translated">이 옵션은 C ++ 코드를 컴파일 할 때만 사용할 수 있습니다. 사용하는 경우 켜거나 끕니다.</target>
        </trans-unit>
        <trans-unit id="f33ea172ac2795eac5ebb478ce17a5afc41091f3" translate="yes" xml:space="preserve">
          <source>This option is only intended to be useful when developing GCC.</source>
          <target state="translated">이 옵션은 GCC를 개발할 때만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="034517546050c1e22d79385d031d17520c531cb2" translate="yes" xml:space="preserve">
          <source>This option is only useful for debugging GCC. When used from CPP or with</source>
          <target state="translated">이 옵션은 GCC 디버깅에만 유용합니다. CPP에서 사용하거나</target>
        </trans-unit>
        <trans-unit id="05b6c3c24d858a91f50ac46c4cd92ae8eecb3f01" translate="yes" xml:space="preserve">
          <source>This option is passed to the assembler and linker, and allows the linker to perform certain optimizations that cannot be done until the final link.</source>
          <target state="translated">이 옵션은 어셈블러 및 링커로 전달되며 링커에서 최종 링크까지 수행 할 수없는 특정 최적화를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b562e6b75c17a9e319c7220a396dd42baef9b10e" translate="yes" xml:space="preserve">
          <source>This option is supported from MIPS Release 6 onwards.</source>
          <target state="translated">이 옵션은 MIPS 릴리스 6부터 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="69521eee9b087ee047a6dc4f213a5e965016b754" translate="yes" xml:space="preserve">
          <source>This option is the default for optimized compilation if the assembler and linker support it. Use</source>
          <target state="translated">이 옵션은 어셈블러 및 링커에서 지원하는 경우 최적화 된 컴파일의 기본값입니다. 사용하다</target>
        </trans-unit>
        <trans-unit id="a6be6b9afb7bd451d149acef44e3204c0799fa3d" translate="yes" xml:space="preserve">
          <source>This option is used internally by the compiler to select and build multilibs for architectures &lt;code&gt;avr2&lt;/code&gt; and &lt;code&gt;avr25&lt;/code&gt;. These architectures mix devices with and without &lt;code&gt;SPH&lt;/code&gt;. For any setting other than</source>
          <target state="translated">이 옵션은 컴파일러에서 내부적으로 &lt;code&gt;avr2&lt;/code&gt; 및 &lt;code&gt;avr25&lt;/code&gt; 아키텍처의 multilib 를 선택하고 빌드하는 데 사용됩니다 . 이러한 아키텍처는 &lt;code&gt;SPH&lt;/code&gt; 가 있거나 없는 장치를 혼합합니다 . 이외의 설정</target>
        </trans-unit>
        <trans-unit id="929f4574a14bae8a52d6ca406bb8cbc25e260697" translate="yes" xml:space="preserve">
          <source>This option is used internally for multilib selection. It is not an optimization option, and you don&amp;rsquo;t need to set it by hand.</source>
          <target state="translated">이 옵션은 다중 라이브러리 선택에 내부적으로 사용됩니다. 최적화 옵션이 아니므로 직접 설정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="7cc2eb8f428f100756f402b24615715e373e0e44" translate="yes" xml:space="preserve">
          <source>This option is used to compile and link code instrumented for coverage analysis. The option is a synonym for</source>
          <target state="translated">이 옵션은 적용 범위 분석을 위해 계측 된 코드를 컴파일하고 링크하는 데 사용됩니다. 옵션은의 동의어입니다</target>
        </trans-unit>
        <trans-unit id="48d0c19a39e93a3e805a541c3dbbe3e7dee413d8" translate="yes" xml:space="preserve">
          <source>This option is used to do fine grain control of x86 code generation features. &lt;var&gt;feature-list&lt;/var&gt; is a comma separated list of &lt;var&gt;feature&lt;/var&gt; names. See also</source>
          <target state="translated">이 옵션은 x86 코드 생성 기능을 세밀하게 제어하는 ​​데 사용됩니다. &lt;var&gt;feature-list&lt;/var&gt; 는 쉼표로 구분 된 &lt;var&gt;feature&lt;/var&gt; 이름 목록입니다 . 또한보십시오</target>
        </trans-unit>
        <trans-unit id="d9b5652a39108319ff242af91d4906cb16765dd8" translate="yes" xml:space="preserve">
          <source>This option isn&amp;rsquo;t effective unless you either provide profile feedback (see</source>
          <target state="translated">이 옵션은 프로필 피드백을 제공하지 않으면 유효하지 않습니다 (참조</target>
        </trans-unit>
        <trans-unit id="fad34c4a13c209b4406d2d95140526d0990b695b" translate="yes" xml:space="preserve">
          <source>This option makes symbolic debugging impossible.</source>
          <target state="translated">이 옵션은 기호 디버깅을 불가능하게합니다.</target>
        </trans-unit>
        <trans-unit id="f70581e1a11d2a9335f77e119a8e847340333cc1" translate="yes" xml:space="preserve">
          <source>This option marks the generated code as IEEE conformant. You must not use this option unless you also specify</source>
          <target state="translated">이 옵션은 생성 된 코드를 IEEE 준수로 표시합니다. 지정하지 않는 한이 옵션을 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="15ded195f72714a7729c2ba3f65b232ddd1df723" translate="yes" xml:space="preserve">
          <source>This option may generate better or worse code; results are highly dependent on the structure of loops within the source code.</source>
          <target state="translated">이 옵션은 더 좋거나 더 나쁜 코드를 생성 할 수 있습니다. 결과는 소스 코드 내의 루프 구조에 따라 크게 달라집니다.</target>
        </trans-unit>
        <trans-unit id="aaf0c177eee46432379774f3339106e6fdf38879" translate="yes" xml:space="preserve">
          <source>This option only has an effect when optimizing for the VR4130. It normally makes code faster, but at the expense of making it bigger. It is enabled by default at optimization level</source>
          <target state="translated">이 옵션은 VR4130을 최적화 할 때만 효과가 있습니다. 일반적으로 코드 속도는 빨라지지만 코드 크기가 커집니다. 최적화 수준에서 기본적으로 활성화됩니다</target>
        </trans-unit>
        <trans-unit id="ab6cda42cf644e48c433b85f306f3dac6f8ee9b8" translate="yes" xml:space="preserve">
          <source>This option passes on a request to assembler to enable the fixes for the named silicon errata.</source>
          <target state="translated">이 옵션은 명명 된 실리콘 에라타에 대한 수정을 활성화하기 위해 어셈블러에 요청을 전달합니다.</target>
        </trans-unit>
        <trans-unit id="845f7cfd869d00c4405522a461f9c235cb5eee1d" translate="yes" xml:space="preserve">
          <source>This option passes on a request to the assembler to enable warning messages when a silicon errata might need to be applied.</source>
          <target state="translated">이 옵션은 실리콘 에라타를 적용해야 할 때 경고 메시지를 활성화하기 위해 요청을 어셈블러에 전달합니다.</target>
        </trans-unit>
        <trans-unit id="c17f45a4bb601880d3a1ed4ec74cc989340e16f4" translate="yes" xml:space="preserve">
          <source>This option prevents undesirable excess precision on machines such as the 68000 where the floating registers (of the 68881) keep more precision than a &lt;code&gt;double&lt;/code&gt; is supposed to have. Similarly for the x86 architecture. For most programs, the excess precision does only good, but a few programs rely on the precise definition of IEEE floating point. Use</source>
          <target state="translated">이 옵션은 68881의 부동 레지스터가 &lt;code&gt;double&lt;/code&gt; 보다 더 정밀한 68000과 같은 기계에서 바람직하지 않은 초과 정밀도를 방지 합니다. x86 아키텍처와 유사합니다. 대부분의 프로그램에서 초과 정밀도는 양호하지만 일부 프로그램은 IEEE 부동 소수점의 정확한 정의에 의존합니다. 사용하다</target>
        </trans-unit>
        <trans-unit id="85c0b69978ecc16b1bd0d2e9088bf661716f775e" translate="yes" xml:space="preserve">
          <source>This option provides a seed that GCC uses in place of random numbers in generating certain symbol names that have to be different in every compiled file. It is also used to place unique stamps in coverage data files and the object files that produce them. You can use the</source>
          <target state="translated">이 옵션은 컴파일 된 모든 파일에서 달라야하는 특정 심볼 이름을 생성 할 때 GCC가 난수 대신 사용하는 시드를 제공합니다. 또한 적용 범위 데이터 파일과이를 생성하는 오브젝트 파일에 고유 한 스탬프를 배치하는 데 사용됩니다. 당신은 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="5d13842ae6ab4ca478a1a5e72b6a9207042790a6" translate="yes" xml:space="preserve">
          <source>This option provides additional information when printing control-flow paths associated with a diagnostic.</source>
          <target state="translated">This option provides additional information when printing control-flow paths associated with a diagnostic.</target>
        </trans-unit>
        <trans-unit id="4fc311cf74252b7ed7aa80360e3b9606e9388cce" translate="yes" xml:space="preserve">
          <source>This option requires Newlib Nano IO, so GCC must be configured with &amp;lsquo;</source>
          <target state="translated">This option requires Newlib Nano IO, so GCC must be configured with &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="c9dc1b607f48375a6d4f6012661eaa5b1b5ed1be" translate="yes" xml:space="preserve">
          <source>This option results in less efficient code, but some strange hacks that alter the assembler output may be confused by the optimizations performed when this option is not used.</source>
          <target state="translated">이 옵션을 사용하면 코드의 효율성이 떨어지지 만이 옵션을 사용하지 않을 때 수행되는 최적화로 인해 어셈블러 출력을 변경하는 일부 이상한 해킹이 혼동 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c631110b4d2abceaccb1bae4ccf22e852178fc73" translate="yes" xml:space="preserve">
          <source>This option runs the standard link-time optimizer. When invoked with source code, it generates GIMPLE (one of GCC&amp;rsquo;s internal representations) and writes it to special ELF sections in the object file. When the object files are linked together, all the function bodies are read from these ELF sections and instantiated as if they had been part of the same translation unit.</source>
          <target state="translated">이 옵션은 표준 링크 시간 최적화 프로그램을 실행합니다. 소스 코드로 호출되면 GIMPLE (GCC 내부 표현 중 하나)을 생성하여 오브젝트 파일의 특수 ELF 섹션에 씁니다. 오브젝트 파일이 서로 링크 될 때 모든 함수 본문은이 ELF 섹션에서 읽히고 마치 동일한 변환 단위의 일부인 것처럼 인스턴스화됩니다.</target>
        </trans-unit>
        <trans-unit id="42349550220727ae2e299d4a2015499909d245e5" translate="yes" xml:space="preserve">
          <source>This option should be used if accesses to volatile bit-fields (or other structure fields, although the compiler usually honors those types anyway) should use a single access of the width of the field&amp;rsquo;s type, aligned to a natural alignment if possible. For example, targets with memory-mapped peripheral registers might require all such accesses to be 16 bits wide; with this flag you can declare all peripheral bit-fields as &lt;code&gt;unsigned short&lt;/code&gt; (assuming short is 16 bits on these targets) to force GCC to use 16-bit accesses instead of, perhaps, a more efficient 32-bit access.</source>
          <target state="translated">휘발성 비트 필드 (또는 다른 구조 필드 (컴파일러는 일반적으로 컴파일러에서 일반적으로 이러한 유형을 준수하지만)에 액세스 할 때 가능하면 자연 정렬에 맞춰 필드 유형의 너비에 대한 단일 액세스를 사용해야하는 경우이 옵션을 사용해야합니다. 예를 들어, 메모리 매핑 된 주변 장치 레지스터가있는 대상은 그러한 모든 액세스의 너비가 16 비트 여야합니다. 이 플래그 를 사용하면 GCC가보다 효율적인 32 비트 액세스 대신 16 비트 액세스를 사용 하도록 모든 주변 장치 비트 필드를 &lt;code&gt;unsigned short&lt;/code&gt; (이러한 대상에서 16 비트라고 가정) 로 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a6ef28258c0d1484a7407799fe40321a370f499" translate="yes" xml:space="preserve">
          <source>This option should never be turned on by any</source>
          <target state="translated">이 옵션을 절대로 켜서는 안됩니다</target>
        </trans-unit>
        <trans-unit id="701b657607612b9b9057df52c63d10c751e2ef8a" translate="yes" xml:space="preserve">
          <source>This option should not be used in combination with</source>
          <target state="translated">이 옵션은 다음과 함께 사용해서는 안됩니다</target>
        </trans-unit>
        <trans-unit id="c0219c53e7274021b5f6207f588b3446cadfa388" translate="yes" xml:space="preserve">
          <source>This option significantly reduces the size of debugging information, with some potential loss in type information to the debugger. See</source>
          <target state="translated">이 옵션은 디버거에 대한 유형 정보가 약간 손실 될 수있는 디버깅 정보의 크기를 크게 줄입니다. 보다</target>
        </trans-unit>
        <trans-unit id="3ed6d18a71b1db6dc14656f8dda97ef522ec526e" translate="yes" xml:space="preserve">
          <source>This option specifies additional section names that can be accessed via GP-relative addressing. It is most useful in conjunction with &lt;code&gt;section&lt;/code&gt; attributes on variable declarations (see &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Common Variable Attributes&lt;/a&gt;) and a custom linker script. The &lt;var&gt;regexp&lt;/var&gt; is a POSIX Extended Regular Expression.</source>
          <target state="translated">이 옵션은 GP 기준 주소 지정을 통해 액세스 할 수있는 추가 섹션 이름을 지정합니다. 변수 선언의 &lt;code&gt;section&lt;/code&gt; 속성 ( &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;공통 변수 속성&lt;/a&gt; 참조 ) 및 사용자 지정 링커 스크립트 와 함께 사용하면 가장 유용합니다 . &lt;var&gt;regexp&lt;/var&gt; POSIX의 확장 정규 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="66f5529b3cbbe7b599cd5d6be9976188f77dac0f" translate="yes" xml:space="preserve">
          <source>This option specifies names of sections that can be accessed via a 16-bit offset from &lt;code&gt;r0&lt;/code&gt;; that is, in the low 32K or high 32K of the 32-bit address space. It is most useful in conjunction with &lt;code&gt;section&lt;/code&gt; attributes on variable declarations (see &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;Common Variable Attributes&lt;/a&gt;) and a custom linker script. The &lt;var&gt;regexp&lt;/var&gt; is a POSIX Extended Regular Expression.</source>
          <target state="translated">이 옵션은 &lt;code&gt;r0&lt;/code&gt; 에서 16 비트 오프셋을 통해 액세스 할 수있는 섹션 이름을 지정합니다 . 즉, 32 비트 주소 공간의 낮은 32K 또는 높은 32K에서. 변수 선언의 &lt;code&gt;section&lt;/code&gt; 속성 ( &lt;a href=&quot;common-variable-attributes#Common-Variable-Attributes&quot;&gt;공통 변수 속성&lt;/a&gt; 참조 ) 및 사용자 지정 링커 스크립트 와 함께 사용하면 가장 유용합니다 . &lt;var&gt;regexp&lt;/var&gt; POSIX의 확장 정규 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="4f2c2ce6a978cb353a59c6932941834cbab3c970" translate="yes" xml:space="preserve">
          <source>This option specifies that a console application is to be generated, by instructing the linker to set the PE header subsystem type required for console applications. This option is available for Cygwin and MinGW targets and is enabled by default on those targets.</source>
          <target state="translated">이 옵션은 콘솔 응용 프로그램에 필요한 PE 헤더 하위 시스템 유형을 설정하도록 링커에 지시하여 콘솔 응용 프로그램을 생성하도록 지정합니다. 이 옵션은 Cygwin 및 MinGW 대상에 사용 가능하며 해당 대상에서 기본적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="21795b6b968aeddf2d8b82bab0643ab8d796f517" translate="yes" xml:space="preserve">
          <source>This option specifies the &lt;var&gt;executable&lt;/var&gt; that will load the build output file being linked. See man ld(1) for more information.</source>
          <target state="translated">이 옵션 은 링크 된 빌드 출력 파일을로드 할 &lt;var&gt;executable&lt;/var&gt; 을 지정합니다 . 자세한 내용은 man ld (1)를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="699a780e6b546e7cd31621b332df13065645e8b9" translate="yes" xml:space="preserve">
          <source>This option specifies the level of compression used for intermediate language written to LTO object files, and is only meaningful in conjunction with LTO mode (</source>
          <target state="translated">이 옵션은 LTO 객체 파일에 기록 된 중간 언어에 사용되는 압축 수준을 지정하며 LTO 모드 (</target>
        </trans-unit>
        <trans-unit id="a52135fd3bb8dd77ca2f36e74d648a4fe294ca69" translate="yes" xml:space="preserve">
          <source>This option specifies the name of the target ARM processor for which GCC should tune the performance of the code. For some ARM implementations better performance can be obtained by using this option. Permissible names are: &amp;lsquo;</source>
          <target state="translated">이 옵션은 GCC가 코드 성능을 조정해야하는 대상 ARM 프로세서의 이름을 지정합니다. 일부 ARM 구현의 경우이 옵션을 사용하면 더 나은 성능을 얻을 수 있습니다. 허용되는 이름은 '</target>
        </trans-unit>
        <trans-unit id="0092bbb4f5a1fce13bf85587ba520d02478db7fa" translate="yes" xml:space="preserve">
          <source>This option specifies where to find the executables, libraries, include files, and data files of the compiler itself.</source>
          <target state="translated">이 옵션은 컴파일러 자체의 실행 파일, 라이브러리, 포함 파일 및 데이터 파일을 찾을 위치를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="34fcd55b8224119aadeadea926ce6d80328cc8e5" translate="yes" xml:space="preserve">
          <source>This option substantially reduces the size of debugging information, but at significant potential loss in type information to the debugger. See</source>
          <target state="translated">이 옵션은 디버깅 정보의 크기를 크게 줄이지 만 디버거에서 형식 정보가 크게 손실 될 수 있습니다. 보다</target>
        </trans-unit>
        <trans-unit id="12955e4ea22dbc03ccc95585111e9bd2b3cf0146" translate="yes" xml:space="preserve">
          <source>This option suppresses generation of the &lt;code&gt;CALLT&lt;/code&gt; instruction for the v850e, v850e1, v850e2, v850e2v3 and v850e3v5 flavors of the v850 architecture.</source>
          <target state="translated">이 옵션 은 v850 아키텍처의 v850e, v850e1, v850e2, v850e2v3 및 v850e3v5 플레이버에 대한 &lt;code&gt;CALLT&lt;/code&gt; 명령어 생성을 억제 합니다.</target>
        </trans-unit>
        <trans-unit id="f8fc982c11de8dc3374f1f50078380019a3e1f62" translate="yes" xml:space="preserve">
          <source>This option suppresses the printing of these labels (in the example above, the vertical bars and the &amp;ldquo;char *&amp;rdquo; and &amp;ldquo;long int&amp;rdquo; text).</source>
          <target state="translated">이 옵션은 이러한 레이블 (위의 예에서 세로 막대 및 &quot;char *&quot;및 &quot;long int&quot;텍스트)의 인쇄를 억제합니다.</target>
        </trans-unit>
        <trans-unit id="06538fd1399a51a29e2046a8c18ed4e9d2f3a0ec" translate="yes" xml:space="preserve">
          <source>This option tells the compiler that variables declared in common blocks (e.g. Fortran) may later be overridden with longer trailing arrays. This prevents certain optimizations that depend on knowing the array bounds.</source>
          <target state="translated">이 옵션은 컴파일러에 공통 블록 (예 : Fortran)으로 선언 된 변수가 나중에 더 긴 후행 배열로 대체 될 수 있음을 알려줍니다. 이것은 배열 경계를 아는 것에 의존하는 특정 최적화를 방지합니다.</target>
        </trans-unit>
        <trans-unit id="2d836f8c7fd152c1f4c1e229195acd7d1d9aa958" translate="yes" xml:space="preserve">
          <source>This option tells the loop optimizer to use language constraints to derive bounds for the number of iterations of a loop. This assumes that loop code does not invoke undefined behavior by for example causing signed integer overflows or out-of-bound array accesses. The bounds for the number of iterations of a loop are used to guide loop unrolling and peeling and loop exit test optimizations. This option is enabled by default.</source>
          <target state="translated">이 옵션은 루프 최적화 프로그램이 언어 제한 조건을 사용하여 루프 반복 횟수에 대한 경계를 도출하도록 지시합니다. 이는 루프 코드가 예를 들어 부호있는 정수 오버플로 또는 범위를 벗어난 배열 액세스를 유발하여 정의되지 않은 동작을 호출하지 않는다고 가정합니다. 루프 반복 횟수에 대한 경계는 루프 언 롤링 및 필링 및 루프 종료 테스트 최적화를 안내하는 데 사용됩니다. 이 옵션은 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4eb8a2fe595c9e8241e6ef6590e0c3c77e876a48" translate="yes" xml:space="preserve">
          <source>This option turns off this behavior because some programs explicitly rely on variables going to the data section&amp;mdash;e.g., so that the resulting executable can find the beginning of that section and/or make assumptions based on that.</source>
          <target state="translated">이 옵션은 일부 프로그램이 명시 적으로 데이터 섹션으로 이동하는 변수에 의존하므로 결과 실행 파일이 해당 섹션의 시작을 찾거나이를 기반으로 가정 할 수 있기 때문에이 동작을 해제합니다.</target>
        </trans-unit>
        <trans-unit id="a03fa036158e8a2d0e9cc5e169d9035da63e693f" translate="yes" xml:space="preserve">
          <source>This option warns on all uses of &lt;code&gt;alloca&lt;/code&gt; in the source.</source>
          <target state="translated">이 옵션은 소스에서 &lt;code&gt;alloca&lt;/code&gt; 의 모든 사용에 대해 경고 합니다.</target>
        </trans-unit>
        <trans-unit id="620c263a82fa884ae16095490ed1aafd4abf9e58" translate="yes" xml:space="preserve">
          <source>This option warns on calls to &lt;code&gt;alloca&lt;/code&gt; with an integer argument whose value is either zero, or that is not bounded by a controlling predicate that limits its value to at most &lt;var&gt;byte-size&lt;/var&gt;. It also warns for calls to &lt;code&gt;alloca&lt;/code&gt; where the bound value is unknown. Arguments of non-integer types are considered unbounded even if they appear to be constrained to the expected range.</source>
          <target state="translated">이 옵션은 값이 0이거나 정수 값을 최대 &lt;var&gt;byte-size&lt;/var&gt; 로 제한하는 제어 술어에 의해 제한되지 않는 정수 인수 로 &lt;code&gt;alloca&lt;/code&gt; 호출에 대해 경고 합니다 . 또한 바운드 값을 알 수없는 &lt;code&gt;alloca&lt;/code&gt; 호출에 대해 경고합니다 . 정수가 아닌 유형의 인수는 예상 범위로 제한되어있는 경우에도 제한되지 않은 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="61e70b725867d5de470ac626de798dde99007b65" translate="yes" xml:space="preserve">
          <source>This option will be enabled by default if, at GCC configure time, the assembler was found to support such directives.</source>
          <target state="translated">이 옵션은 GCC 구성 시간에 어셈블러가 이러한 지시문을 지원하는 것으로 밝혀지면 기본적으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="a7e38bb2c3d97b5a7df94e2d4b17a0b93c48b4a5" translate="yes" xml:space="preserve">
          <source>This option will be enabled by default if, at GCC configure time, the assembler was found to support them.</source>
          <target state="translated">이 옵션은 GCC 구성 시간에 어셈블러에서 지원할 경우 기본적으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="1c545350367038810cd2987773d5c2915271f3c6" translate="yes" xml:space="preserve">
          <source>This option works only with DWARF debug output.</source>
          <target state="translated">이 옵션은 DWARF 디버그 출력에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="bbaec7f2023839aa97132788cd132448147454c0" translate="yes" xml:space="preserve">
          <source>This option, recognized for the cris-axis-elf, arranges to link with input-output functions from a simulator library. Code, initialized data and zero-initialized data are allocated consecutively.</source>
          <target state="translated">Cris-Axis-El로 인식되는이 옵션은 시뮬레이터 라이브러리의 입력-출력 기능과 연결됩니다. 코드, 초기화 된 데이터 및 0으로 초기화 된 데이터가 연속적으로 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="f3e5914b613a32a5cb2f8fca3e63e01d9cf519e2" translate="yes" xml:space="preserve">
          <source>This parameter prevents mixed usage of multiple atomic models, even if they are compatible, and makes the compiler generate atomic sequences of the specified model only.</source>
          <target state="translated">이 매개 변수는 호환 가능하더라도 다중 원자 모델의 혼합 사용을 방지하고 컴파일러가 지정된 모델의 원자 시퀀스 만 생성하도록합니다.</target>
        </trans-unit>
        <trans-unit id="a5d669f5cfd64a65baaa023d25d50f1d31d908f7" translate="yes" xml:space="preserve">
          <source>This parameter specifies the offset in bytes of the variable in the thread control block structure that should be used by the generated atomic sequences when the &amp;lsquo;</source>
          <target state="translated">이 매개 변수는 스레드 제어 블록 구조에서 변수의 오프셋을 바이트 단위로 지정합니다.</target>
        </trans-unit>
        <trans-unit id="a089b6884ff458754998285328ae2911c61445c4" translate="yes" xml:space="preserve">
          <source>This pass distributes the initialization loops and generates a call to memset zero. For example, the loop</source>
          <target state="translated">이 패스는 초기화 루프를 분배하고 memset 0에 대한 호출을 생성합니다. 예를 들어 루프</target>
        </trans-unit>
        <trans-unit id="f9c1c873e049f9ba7fb7727e6d4eeb92324da6de" translate="yes" xml:space="preserve">
          <source>This pass only applies to certain targets that cannot explicitly represent the comparison operation before register allocation is complete.</source>
          <target state="translated">이 패스는 레지스터 할당이 완료되기 전에 비교 작업을 명시 적으로 나타낼 수없는 특정 대상에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="461faf3624a4165b061a68a094b7ad69f3e94c46" translate="yes" xml:space="preserve">
          <source>This pragma allows the user to set the visibility for multiple declarations without having to give each a visibility attribute (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;).</source>
          <target state="translated">이 pragma를 사용하면 사용자에게 각각의 가시성 속성을 제공하지 않고도 여러 선언에 대한 가시성을 설정할 수 있습니다 ( &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;함수 속성&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="e202730c1bfc48c0778f7ea2bd0c6eb45186cc47" translate="yes" xml:space="preserve">
          <source>This pragma allows you to set global optimization options for functions defined later in the source file. One or more strings can be specified. Each function that is defined after this point is treated as if it had been declared with one &lt;code&gt;optimize(&lt;/code&gt;&lt;var&gt;string&lt;/var&gt;&lt;code&gt;)&lt;/code&gt; attribute for each &lt;var&gt;string&lt;/var&gt; argument. The parentheses around the strings in the pragma are optional. See &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;, for more information about the &lt;code&gt;optimize&lt;/code&gt; attribute and the attribute syntax.</source>
          <target state="translated">이 pragma를 사용하면 나중에 소스 파일에서 정의 된 함수에 대한 전역 최적화 옵션을 설정할 수 있습니다. 하나 이상의 문자열을 지정할 수 있습니다. 이 시점 이후에 정의 된 각 함수는 각 &lt;var&gt;string&lt;/var&gt; 인수 에 대해 하나의 &lt;code&gt;optimize(&lt;/code&gt; &lt;var&gt;string&lt;/var&gt; &lt;code&gt;)&lt;/code&gt; 속성 으로 선언 된 것처럼 처리됩니다 . pragma에서 문자열 주위의 괄호는 선택 사항입니다. &lt;code&gt;optimize&lt;/code&gt; 속성 및 속성 구문 에 대한 자세한 정보는 &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;함수 속성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1c9f09620296c49e0c152a1252d539d7a1599030" translate="yes" xml:space="preserve">
          <source>This pragma allows you to set target-specific options for functions defined later in the source file. One or more strings can be specified. Each function that is defined after this point is treated as if it had been declared with one &lt;code&gt;target(&lt;/code&gt;&lt;var&gt;string&lt;/var&gt;&lt;code&gt;)&lt;/code&gt; attribute for each &lt;var&gt;string&lt;/var&gt; argument. The parentheses around the strings in the pragma are optional. See &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;, for more information about the &lt;code&gt;target&lt;/code&gt; attribute and the attribute syntax.</source>
          <target state="translated">이 pragma를 사용하면 나중에 소스 파일에서 정의 된 함수에 대한 대상별 옵션을 설정할 수 있습니다. 하나 이상의 문자열을 지정할 수 있습니다. 이 시점 이후에 정의 된 각 함수는 각 &lt;var&gt;string&lt;/var&gt; 인수 에 대해 하나의 &lt;code&gt;target(&lt;/code&gt; &lt;var&gt;string&lt;/var&gt; &lt;code&gt;)&lt;/code&gt; 속성 으로 선언 된 것처럼 처리됩니다 . pragma에서 문자열 주위의 괄호는 선택 사항입니다. &lt;code&gt;target&lt;/code&gt; 속성 및 속성 구문 에 대한 자세한 내용은 &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;함수 속성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e5bdf333d1a9b5e255036222cc92af1884c97c92" translate="yes" xml:space="preserve">
          <source>This pragma and the &lt;code&gt;asm&lt;/code&gt; labels extension interact in a complicated manner. Here are some corner cases you may want to be aware of:</source>
          <target state="translated">이 pragma 및 &lt;code&gt;asm&lt;/code&gt; 레이블 확장은 복잡한 방식으로 상호 작용합니다. 다음은 알고 싶은 코너 사례입니다.</target>
        </trans-unit>
        <trans-unit id="df6ea502dad4ed3727dbc5aab1f84068b260e566" translate="yes" xml:space="preserve">
          <source>This pragma causes each listed &lt;var&gt;function&lt;/var&gt; to be called after main, or during shared module unloading, by adding a call to the &lt;code&gt;.fini&lt;/code&gt; section.</source>
          <target state="translated">이 pragma 는 &lt;code&gt;.fini&lt;/code&gt; 섹션에 호출을 추가하여 main 또는 이후 공유 모듈 언로드 중에 나열된 각 &lt;var&gt;function&lt;/var&gt; 가 호출되도록합니다 .</target>
        </trans-unit>
        <trans-unit id="7ef98ac7a5a65ac560b0183a0711ed56313ca3a4" translate="yes" xml:space="preserve">
          <source>This pragma causes each listed &lt;var&gt;function&lt;/var&gt; to be called during initialization (before &lt;code&gt;main&lt;/code&gt;) or during shared module loading, by adding a call to the &lt;code&gt;.init&lt;/code&gt; section.</source>
          <target state="translated">이 pragma 는 &lt;code&gt;.init&lt;/code&gt; 섹션에 호출을 추가하여 초기화 중 ( &lt;code&gt;main&lt;/code&gt; 이전 ) 또는 공유 모듈로드 중에 나열된 각 &lt;var&gt;function&lt;/var&gt; 가 호출되도록합니다 .</target>
        </trans-unit>
        <trans-unit id="4305b5e7eee9369ab0724af50f66a74eaee06881" translate="yes" xml:space="preserve">
          <source>This pragma clears the current &lt;code&gt;#pragma GCC target&lt;/code&gt; and &lt;code&gt;#pragma GCC optimize&lt;/code&gt; to use the default switches as specified on the command line.</source>
          <target state="translated">이 pragma는 현재 &lt;code&gt;#pragma GCC target&lt;/code&gt; 및 &lt;code&gt;#pragma GCC optimize&lt;/code&gt; 를 해제하여 명령 줄에 지정된 기본 스위치를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c86f808ebf265d2793b4414b964c355b2c508a5f" translate="yes" xml:space="preserve">
          <source>This pragma declares &lt;var&gt;symbol1&lt;/var&gt; to be a weak alias of &lt;var&gt;symbol2&lt;/var&gt;. It is an error if &lt;var&gt;symbol2&lt;/var&gt; is not defined in the current translation unit.</source>
          <target state="translated">이 pragma는 &lt;var&gt;symbol1&lt;/var&gt; 을 symbol2 의 약한 별칭으로 &lt;var&gt;symbol2&lt;/var&gt; 합니다. 현재 변환 단위에 &lt;var&gt;symbol2&lt;/var&gt; 가 정의되어 있지 않으면 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="2e41ab6e510f688ee4c0ac9d61fab50b654b5c94" translate="yes" xml:space="preserve">
          <source>This pragma declares &lt;var&gt;symbol&lt;/var&gt; to be weak, as if the declaration had the attribute of the same name. The pragma may appear before or after the declaration of &lt;var&gt;symbol&lt;/var&gt;. It is not an error for &lt;var&gt;symbol&lt;/var&gt; to never be defined at all.</source>
          <target state="translated">이 pragma는 선언 에 동일한 이름의 속성이있는 것처럼 &lt;var&gt;symbol&lt;/var&gt; 를 약한 것으로 선언합니다. pragma는 &lt;var&gt;symbol&lt;/var&gt; 선언 전후에 나타날 수 있습니다 . &lt;var&gt;symbol&lt;/var&gt; 이 전혀 정의 되지 않는 것은 오류가 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="6d680236fdbf196915aaf992aecdb77c6a8b587b" translate="yes" xml:space="preserve">
          <source>This pragma declares variables to be possibly unused. GCC does not produce warnings for the listed variables. The effect is similar to that of the &lt;code&gt;unused&lt;/code&gt; attribute, except that this pragma may appear anywhere within the variables&amp;rsquo; scopes.</source>
          <target state="translated">이 pragma는 변수를 사용하지 않도록 선언합니다. GCC는 나열된 변수에 대해 경고를 생성하지 않습니다. 이 pragma가 변수 범위 내의 어느 곳에 나 나타날 수 있다는 점을 제외하고 는 효과는 &lt;code&gt;unused&lt;/code&gt; 속성 의 효과와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="297d6f917f11b7d696df277d2ac80b8a527dc0e9" translate="yes" xml:space="preserve">
          <source>This pragma gives the C function &lt;var&gt;oldname&lt;/var&gt; the assembly symbol &lt;var&gt;newname&lt;/var&gt;. The preprocessor macro &lt;code&gt;__PRAGMA_REDEFINE_EXTNAME&lt;/code&gt; is defined if this pragma is available (currently on all platforms).</source>
          <target state="translated">이 pragma는 C 함수 &lt;var&gt;oldname&lt;/var&gt; 에 어셈블리 기호 &lt;var&gt;newname&lt;/var&gt; 을 제공 합니다. 이 pragma가 사용 가능한 경우 (현재 모든 플랫폼에서) 전 처리기 매크로 &lt;code&gt;__PRAGMA_REDEFINE_EXTNAME&lt;/code&gt; 이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="1d47f09719c8273483bc0daaf5859bab9562dec9" translate="yes" xml:space="preserve">
          <source>This pragma is accepted, but has no effect.</source>
          <target state="translated">이 pragma는 허용되지만 효과는 없습니다.</target>
        </trans-unit>
        <trans-unit id="d1d3fa1a452de5b39a96a52139032ce525a57ad0" translate="yes" xml:space="preserve">
          <source>This pragma is not implemented, but the default is to &amp;ldquo;off&amp;rdquo; unless</source>
          <target state="translated">이 pragma는 구현되지 않지만 기본값은 &quot;off&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="df0d00bf5dd61e1e80f9e58129099c35fef14b94" translate="yes" xml:space="preserve">
          <source>This pragma is not implemented. Expressions are currently only contracted if</source>
          <target state="translated">이 pragma는 구현되지 않았습니다. 표현식은 현재 다음과 같은 경우에만 계약됩니다.</target>
        </trans-unit>
        <trans-unit id="42570b540208a522195f34bdcb31e38a4d6b0221" translate="yes" xml:space="preserve">
          <source>This pragma saves the value of the macro named as &lt;var&gt;macro_name&lt;/var&gt; to the top of the stack for this macro.</source>
          <target state="translated">이 pragma는 &lt;var&gt;macro_name&lt;/var&gt; 이라는 매크로의 값 을이 매크로의 스택 맨 위에 저장합니다 .</target>
        </trans-unit>
        <trans-unit id="0d99cb35c6101970038eaf301a0c3beb6107bf5a" translate="yes" xml:space="preserve">
          <source>This pragma sets the alignment of fields in structures. The values of &lt;var&gt;alignment&lt;/var&gt; may be &lt;code&gt;mac68k&lt;/code&gt;, to emulate m68k alignment, or &lt;code&gt;power&lt;/code&gt;, to emulate PowerPC alignment. Uses of this pragma nest properly; to restore the previous setting, use &lt;code&gt;reset&lt;/code&gt; for the &lt;var&gt;alignment&lt;/var&gt;.</source>
          <target state="translated">이 pragma는 구조에서 필드의 정렬을 설정합니다. 의 값이 &lt;var&gt;alignment&lt;/var&gt; 될 수 &lt;code&gt;mac68k&lt;/code&gt; 에뮬레이션하는 m68k 정렬하거나, &lt;code&gt;power&lt;/code&gt; 파워 배향을 에뮬레이트. 이 pragma 둥지의 올바른 사용; 이전 설정을 복원하려면 &lt;var&gt;alignment&lt;/var&gt; 대해 &lt;code&gt;reset&lt;/code&gt; 을 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="6e23a1d175eeaabf52f59f12be4c55b597b0251f" translate="yes" xml:space="preserve">
          <source>This pragma sets the value of the macro named as &lt;var&gt;macro_name&lt;/var&gt; to the value on top of the stack for this macro. If the stack for &lt;var&gt;macro_name&lt;/var&gt; is empty, the value of the macro remains unchanged.</source>
          <target state="translated">이 pragma는 &lt;var&gt;macro_name&lt;/var&gt; 이라는 매크로 의 값을이 매크로의 스택 맨 위에있는 값으로 설정합니다 . &lt;var&gt;macro_name&lt;/var&gt; 의 스택 이 비어 있으면 매크로 값은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="03b17cd16d3c44521375b42df7bda966fe331c0e" translate="yes" xml:space="preserve">
          <source>This pragma silently applies only to declarations with external linkage. The &lt;code&gt;asm&lt;/code&gt; label feature does not have this restriction.</source>
          <target state="translated">이 pragma는 외부 연결이있는 선언에만 자동으로 적용됩니다. &lt;code&gt;asm&lt;/code&gt; 라벨 기능은 이러한 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="263438c853ee982ccc7a3904487e0cd3d115c742" translate="yes" xml:space="preserve">
          <source>This prefix is also used for finding files such as</source>
          <target state="translated">이 접두사는 다음과 같은 파일을 찾는 데에도 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="853d289c160cc93497a02e37abb2f9f0217d9d34" translate="yes" xml:space="preserve">
          <source>This problem may for instance occur when we use this pattern recursively, like so:</source>
          <target state="translated">이 문제는 예를 들어 다음과 같이이 패턴을 재귀 적으로 사용할 때 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92bb145abdc75a03d83add48a654c73cbe5bd131" translate="yes" xml:space="preserve">
          <source>This problem only affects kernel stores and, depending on the system, kernel loads. As an example, a speculatively-executed store may load the target memory into cache and mark the cache line as dirty, even if the store itself is later aborted. If a DMA operation writes to the same area of memory before the &amp;ldquo;dirty&amp;rdquo; line is flushed, the cached data overwrites the DMA-ed data. See the R10K processor manual for a full description, including other potential problems.</source>
          <target state="translated">이 문제는 커널 저장소 및 시스템에 따라 커널로드에만 영향을줍니다. 예를 들어, 추측 적으로 실행되는 저장소는 대상 메모리를 캐시에로드하고 나중에 저장소 자체가 중단 된 경우에도 캐시 라인을 더티로 표시 할 수 있습니다. &quot;더티 (dirty)&quot;라인을 플러시하기 전에 DMA 작업이 동일한 메모리 영역에 쓰면 캐시 된 데이터가 DMA 데이터를 덮어 씁니다. 다른 잠재적 인 문제를 포함한 전체 설명은 R10K 프로세서 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6bba2aa8d001273821fc7a22f52c80ae052e1b79" translate="yes" xml:space="preserve">
          <source>This qualifier informs the compiler that the &lt;code&gt;asm&lt;/code&gt; statement may perform a jump to one of the labels listed in the &lt;var&gt;GotoLabels&lt;/var&gt;. See &lt;a href=&quot;#GotoLabels&quot;&gt;GotoLabels&lt;/a&gt;.</source>
          <target state="translated">이 한정자는 &lt;code&gt;asm&lt;/code&gt; 문이 &lt;var&gt;GotoLabels&lt;/var&gt; 에 나열된 레이블 중 하나로 점프 할 수 있음을 컴파일러에 알립니다 . &lt;a href=&quot;#GotoLabels&quot;&gt;GotoLabels를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4093c1766b06cd06224229c5ab31374f32640737" translate="yes" xml:space="preserve">
          <source>This restriction of ISO C makes it hard to write code that is portable to traditional C compilers, because the programmer does not know whether the &lt;code&gt;uid_t&lt;/code&gt; type is &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, or &lt;code&gt;long&lt;/code&gt;. Therefore, in cases like these GNU C allows a prototype to override a later old-style definition. More precisely, in GNU C, a function prototype argument type overrides the argument type specified by a later old-style definition if the former type is the same as the latter type before promotion. Thus in GNU C the above example is equivalent to the following:</source>
          <target state="translated">이 ISO C 제한으로 인해 프로그래머는 &lt;code&gt;uid_t&lt;/code&gt; 유형이 &lt;code&gt;short&lt;/code&gt; , &lt;code&gt;int&lt;/code&gt; 또는 &lt;code&gt;long&lt;/code&gt; 인지 알 수 없기 때문에 기존 C 컴파일러에 이식 가능한 코드를 작성하기가 어렵습니다 . 따라서 이러한 GNU C와 같은 경우 프로토 타입이 이후의 이전 스타일 정의를 대체 할 수 있습니다. 좀 더 정확하게 말하면, GNU C에서 함수 프로토 타입 인수 유형은 이전 유형이 승격 이전의 유형과 동일한 경우 이후의 이전 스타일 정의에 지정된 인수 유형을 대체합니다. 따라서 GNU C에서 위의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b4ab6e646b44f4632464748755730b2c272ad5f1" translate="yes" xml:space="preserve">
          <source>This sample shows how to specify the assembler name for data:</source>
          <target state="translated">이 샘플은 데이터의 어셈블러 이름을 지정하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="e5b05b60d6f2ee21a98f997beb1f9023f6a4e7bc" translate="yes" xml:space="preserve">
          <source>This says that any input file whose name ends in &amp;lsquo;</source>
          <target state="translated">이것은 이름이 '</target>
        </trans-unit>
        <trans-unit id="8bc7756ea229cad62f19381d0aec545c10cece4c" translate="yes" xml:space="preserve">
          <source>This says that the suffix is an alias for a known &lt;var&gt;language&lt;/var&gt;. This is similar to using the</source>
          <target state="translated">이것은 접미사가 알려진 &lt;var&gt;language&lt;/var&gt; 의 별명이라고 말합니다 . 이것은</target>
        </trans-unit>
        <trans-unit id="77e07f2febdffcd9c896323de91d75db17316bb7" translate="yes" xml:space="preserve">
          <source>This section describes PowerPC built-in functions that do not require the inclusion of any special header files to declare prototypes or provide macro definitions. The sections that follow describe additional PowerPC built-in functions.</source>
          <target state="translated">이 섹션에서는 프로토 타입을 선언하거나 매크로 정의를 제공하기 위해 특수 헤더 파일을 포함하지 않아도되는 PowerPC 내장 기능에 대해 설명합니다. 다음 섹션에서는 추가 PowerPC 내장 기능에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="4b61f221f0794b55701031d13518070c0255286e" translate="yes" xml:space="preserve">
          <source>This section describes built-in functions that are not named after a specific FR-V instruction.</source>
          <target state="translated">이 절에서는 특정 FR-V 명령에 따라 이름이 지정되지 않은 내장 기능에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="d7abf825d737ed6aeedbed114bb5b1fa96d1d588" translate="yes" xml:space="preserve">
          <source>This section describes command-line options that are primarily of interest to GCC developers, including options to support compiler testing and investigation of compiler bugs and compile-time performance problems. This includes options that produce debug dumps at various points in the compilation; that print statistics such as memory use and execution time; and that print information about GCC&amp;rsquo;s configuration, such as where it searches for libraries. You should rarely need to use any of these options for ordinary compilation and linking tasks.</source>
          <target state="translated">이 섹션에서는 컴파일러 테스트 및 컴파일러 버그 조사 및 컴파일 타임 성능 문제를 지원하는 옵션을 포함하여 GCC 개발자가 주로 관심을 갖는 명령 줄 옵션에 대해 설명합니다. 여기에는 컴파일의 다양한 지점에서 디버그 덤프를 생성하는 옵션이 포함됩니다. 메모리 사용 및 실행 시간과 같은 통계를 인쇄합니다. 라이브러리를 검색하는 위치와 같은 GCC 구성에 대한 정보를 인쇄합니다. 일반적인 컴파일 및 링크 작업에 이러한 옵션을 사용할 필요는 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="2bedaec624c9942033ae97b423071f6ba2ad1456" translate="yes" xml:space="preserve">
          <source>This section describes known problems that affect users of GCC. Most of these are not GCC bugs per se&amp;mdash;if they were, we would fix them. But the result for a user may be like the result of a bug.</source>
          <target state="translated">이 섹션에서는 GCC 사용자에게 영향을 미치는 알려진 문제점에 대해 설명합니다. 이들 중 대부분은 GCC 버그 자체가 아닙니다. 버그가 있다면 수정합니다. 그러나 사용자의 결과는 버그의 결과와 유사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b43873b1eac185b9fa8755ff87aff197f92a2f8" translate="yes" xml:space="preserve">
          <source>This section describes several environment variables that affect how GCC operates. Some of them work by specifying directories or prefixes to use when searching for various kinds of files. Some are used to specify other aspects of the compilation environment.</source>
          <target state="translated">이 섹션에서는 GCC 작동 방식에 영향을주는 여러 환경 변수에 대해 설명합니다. 이들 중 일부는 다양한 종류의 파일을 검색 할 때 사용할 디렉토리 또는 접 두부를 지정하여 작동합니다. 일부는 컴파일 환경의 다른 측면을 지정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9055e1a522ff74558948ff04f5b4f164a424da3a" translate="yes" xml:space="preserve">
          <source>This section describes the command-line options that are only meaningful for C++ programs. You can also use most of the GNU compiler options regardless of what language your program is in. For example, you might compile a file</source>
          <target state="translated">이 섹션에서는 C ++ 프로그램에만 의미가있는 명령 줄 옵션에 대해 설명합니다. 프로그램의 언어에 관계없이 대부분의 GNU 컴파일러 옵션을 사용할 수도 있습니다. 예를 들어 파일을 컴파일 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="378b3683f59604e4695371da6c2fddfaacd92ba1" translate="yes" xml:space="preserve">
          <source>This section describes the command-line options that are only meaningful for Objective-C and Objective-C++ programs. You can also use most of the language-independent GNU compiler options. For example, you might compile a file</source>
          <target state="translated">이 절에서는 Objective-C 및 Objective-C ++ 프로그램에만 의미가있는 명령 행 옵션에 대해 설명합니다. 언어 독립적 인 GNU 컴파일러 옵션 대부분을 사용할 수도 있습니다. 예를 들어 파일을 컴파일 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="382e6f59f6c971fab95547a05668a5918cd72126" translate="yes" xml:space="preserve">
          <source>This section describes the syntax with which &lt;code&gt;__attribute__&lt;/code&gt; may be used, and the constructs to which attribute specifiers bind, for the C language. Some details may vary for C++ and Objective-C. Because of infelicities in the grammar for attributes, some forms described here may not be successfully parsed in all cases.</source>
          <target state="translated">이 절에서는 C 언어에 대해 &lt;code&gt;__attribute__&lt;/code&gt; 를 사용할 수 있는 구문과 속성 지정자가 바인드되는 구문에 대해 설명합니다 . 일부 세부 사항은 C ++ 및 Objective-C에 따라 다를 수 있습니다. 속성에 대한 문법에는 부적절하기 때문에 여기에 설명 된 일부 형식은 모든 경우에 성공적으로 구문 분석되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd8e6c5371362aa092aae0b0592e55198f1c8b9c" translate="yes" xml:space="preserve">
          <source>This section documents the encoding of method types, which is rarely needed to use Objective-C. You should skip it at a first reading; the runtime provides functions that will work on methods and can walk through the list of parameters and interpret them for you. These functions are part of the public &amp;ldquo;API&amp;rdquo; and are the preferred way to interact with method signatures from user code.</source>
          <target state="translated">이 섹션에서는 Objective-C를 사용하는 경우가 거의없는 메소드 유형의 인코딩에 대해 설명합니다. 처음 읽을 때는 건너 뛰어야합니다. 런타임은 메소드에서 작동하고 매개 변수 목록을 살펴보고이를 해석 할 수있는 기능을 제공합니다. 이 함수는 공개&amp;ldquo;API&amp;rdquo;의 일부이며 사용자 코드의 메소드 서명과 상호 작용하는 기본 방법입니다.</target>
        </trans-unit>
        <trans-unit id="92bc19fae671586234add4d5e1d253df22100b8a" translate="yes" xml:space="preserve">
          <source>This section intentionally empty.</source>
          <target state="translated">이 섹션은 의도적으로 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9dcc691a02a9391b7e0c30aab063927ea00a125c" translate="yes" xml:space="preserve">
          <source>This section is specific for the GNU Objective-C runtime. If you are using a different runtime, you can skip it.</source>
          <target state="translated">이 섹션은 GNU Objective-C 런타임에만 해당됩니다. 다른 런타임을 사용중인 경우 건너 뛸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d2663a3da2126761e59e5b901038db322ae02e2" translate="yes" xml:space="preserve">
          <source>This section lists changes that people frequently request, but which we do not make because we think GCC is better without them.</source>
          <target state="translated">이 섹션에는 사람들이 자주 요청하는 변경 사항이 있지만 GCC가 없으면 더 나은 것으로 생각하기 때문에 변경하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6be9fd8a27bd882ee2957a5506f02578eed902d6" translate="yes" xml:space="preserve">
          <source>This section lists various difficulties encountered in using GCC together with other compilers or with the assemblers, linkers, libraries and debuggers on certain systems.</source>
          <target state="translated">이 섹션에는 다른 컴파일러 또는 특정 시스템의 어셈블러, 링커, 라이브러리 및 디버거와 함께 GCC를 사용할 때 발생하는 다양한 어려움이 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc5c464b4c99442f66523b49fbd84dd32d4a9f33" translate="yes" xml:space="preserve">
          <source>This sections describes built-in functions related to read and write instructions to access memory. These functions generate &lt;code&gt;membar&lt;/code&gt; instructions to flush the I/O load and stores where appropriate, as described in Fujitsu&amp;rsquo;s manual described above.</source>
          <target state="translated">이 섹션에서는 메모리 액세스를위한 읽기 및 쓰기 명령어와 관련된 내장 기능에 대해 설명합니다. 이러한 기능은 생성 &lt;code&gt;membar&lt;/code&gt; 에 설명 된대로 적절한는, 후지쯔의 매뉴얼은 위에서 설명한 I / O로드 및 저장을 플러시하는 지침을.</target>
        </trans-unit>
        <trans-unit id="657a9d90f9f4dd0b4af1725dd023d864364a9a6d" translate="yes" xml:space="preserve">
          <source>This selects the CPU to generate code for at compilation time by determining the processor type of the compiling machine. Using</source>
          <target state="translated">컴파일 머신의 프로세서 유형을 결정하여 컴파일 타임에 코드를 생성 할 CPU를 선택합니다. 사용</target>
        </trans-unit>
        <trans-unit id="52fbcd0192529b61aa6e52c7943fcf31e0d69f81" translate="yes" xml:space="preserve">
          <source>This sets the indicated bits in the saved copy of the status register currently residing on the stack. This only works inside interrupt handlers and the changes to the status register will only take affect once the handler returns.</source>
          <target state="translated">이것은 현재 스택에 상주하는 상태 레지스터의 저장된 사본에 표시된 비트를 설정합니다. 이것은 인터럽트 처리기에서만 작동하며 상태 레지스터의 변경 사항은 처리기가 반환 된 후에 만 ​​적용됩니다.</target>
        </trans-unit>
        <trans-unit id="c8206cbbb17dc4eed11021be8e812bfcaf18d27d" translate="yes" xml:space="preserve">
          <source>This setting is only useful for strides that are known and constant.</source>
          <target state="translated">이 설정은 알려져 있고 일정한 보폭에만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="efe46d223c613fd1d939a40a5c5d5b8742ce8085" translate="yes" xml:space="preserve">
          <source>This setting is useful for processors that have hardware prefetchers, in which case there may be conflicts between the hardware prefetchers and the software prefetchers. If the hardware prefetchers have a maximum stride they can handle, it should be used here to improve the use of software prefetchers.</source>
          <target state="translated">이 설정은 하드웨어 프리 페 처가있는 프로세서에 유용합니다.이 경우 하드웨어 프리 페처와 소프트웨어 프리 페처간에 충돌이있을 수 있습니다. 하드웨어 프리 페 처가 처리 할 수있는 최대 단계를 가진 경우 여기에서 소프트웨어 프리 페처의 사용을 개선하기 위해 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="23f9a68d34fdcbac9802d87e4691f1d481ccdb61" translate="yes" xml:space="preserve">
          <source>This size is also used for inlining decisions. If you use &lt;code&gt;asm inline&lt;/code&gt; instead of just &lt;code&gt;asm&lt;/code&gt;, then for inlining purposes the size of the asm is taken as the minimum size, ignoring how many instructions GCC thinks it is.</source>
          <target state="translated">이 크기는 의사 결정을 인라인하는 데에도 사용됩니다. 당신이 사용하는 경우 &lt;code&gt;asm inline&lt;/code&gt; 대신 단지 &lt;code&gt;asm&lt;/code&gt; , 다음 인라인 목적으로 ASM의 크기는 GCC가이 생각하는 얼마나 많은 지침을 무시하고, 최소 크기로한다.</target>
        </trans-unit>
        <trans-unit id="6436ee6603a6a283bb34edc1a40e3b3faa54b98d" translate="yes" xml:space="preserve">
          <source>This specifies that the name to be used for the function &lt;code&gt;func&lt;/code&gt; in the assembler code should be &lt;code&gt;MYFUNC&lt;/code&gt;.</source>
          <target state="translated">이는 어셈블러 코드에서 함수 &lt;code&gt;func&lt;/code&gt; 에 사용될 이름 이 &lt;code&gt;MYFUNC&lt;/code&gt; 이어야 함을 지정 합니다.</target>
        </trans-unit>
        <trans-unit id="232e23ab36d2ae531cc928cda4ab49d45def08c5" translate="yes" xml:space="preserve">
          <source>This specifies that the name to be used for the variable &lt;code&gt;foo&lt;/code&gt; in the assembler code should be &amp;lsquo;</source>
          <target state="translated">이것은 어셈블러 코드에서 변수 &lt;code&gt;foo&lt;/code&gt; 에 사용될 이름 이 '</target>
        </trans-unit>
        <trans-unit id="a3c554fdfb8d610626cac613dfe8c644012d6c11" translate="yes" xml:space="preserve">
          <source>This specifies the hard limit for frame sizes, in bytes. Currently, the value that can be specified should be less than or equal to &amp;lsquo;</source>
          <target state="translated">This specifies the hard limit for frame sizes, in bytes. Currently, the value that can be specified should be less than or equal to &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="157c3a5d700741dba8b972ce366b3872db0f98d9" translate="yes" xml:space="preserve">
          <source>This specifies the minimum version of the kernel that will run the compiled program. GCC uses this version to determine which instructions to use, what kernel helpers to allow, etc. Currently, &lt;var&gt;version&lt;/var&gt; can be one of &amp;lsquo;</source>
          <target state="translated">This specifies the minimum version of the kernel that will run the compiled program. GCC uses this version to determine which instructions to use, what kernel helpers to allow, etc. Currently, &lt;var&gt;version&lt;/var&gt; can be one of &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="d2e7d4d12b96a2f9b08b67a67b6c05ae9677d81f" translate="yes" xml:space="preserve">
          <source>This specifies the name of the target ARM architecture. GCC uses this name to determine what kind of instructions it can emit when generating assembly code. This option can be used in conjunction with or instead of the</source>
          <target state="translated">타겟 ARM 아키텍처의 이름을 지정합니다. GCC는이 이름을 사용하여 어셈블리 코드를 생성 할 때 어떤 종류의 명령어를 생성 할 수 있는지 결정합니다. 이 옵션은</target>
        </trans-unit>
        <trans-unit id="5f5ffdf441cdde0f8b6e9e4c7fe02c1f21c8c411" translate="yes" xml:space="preserve">
          <source>This specifies the name of the target ARM processor. GCC uses this name to derive the name of the target ARM architecture (as if specified by</source>
          <target state="translated">타겟 ARM 프로세서의 이름을 지정합니다. GCC는이 이름을 사용하여 대상 ARM 아키텍처의 이름을 파생시킵니다 (</target>
        </trans-unit>
        <trans-unit id="8e151a0bdb560628cb5ddbb4913dc14cfb482f53" translate="yes" xml:space="preserve">
          <source>This specifies the name of the target Nios II architecture. GCC uses this name to determine what kind of instructions it can emit when generating assembly code. Permissible names are: &amp;lsquo;</source>
          <target state="translated">타겟 Nios II 아키텍처의 이름을 지정합니다. GCC는이 이름을 사용하여 어셈블리 코드를 생성 할 때 어떤 종류의 명령어를 생성 할 수 있는지 결정합니다. 허용되는 이름은 '</target>
        </trans-unit>
        <trans-unit id="085bdfa0f8d1afe6178b912d6185b5a3f9cb191a" translate="yes" xml:space="preserve">
          <source>This specifies the name of the target architecture. GCC uses this name to determine what kind of instructions it can emit when generating assembly code. Permissible names are: &amp;lsquo;</source>
          <target state="translated">대상 아키텍처의 이름을 지정합니다. GCC는이 이름을 사용하여 어셈블리 코드를 생성 할 때 어떤 종류의 명령어를 생성 할 수 있는지 결정합니다. 허용되는 이름은 '</target>
        </trans-unit>
        <trans-unit id="64aaf23d10b975a481227888a0c489eb1e3c16c0" translate="yes" xml:space="preserve">
          <source>This specifies what floating-point hardware (or hardware emulation) is available on the target. Permissible names are: &amp;lsquo;</source>
          <target state="translated">대상에서 사용할 수있는 부동 소수점 하드웨어 (또는 하드웨어 에뮬레이션)를 지정합니다. 허용되는 이름은 '</target>
        </trans-unit>
        <trans-unit id="345d1833d12c5392425b9eb5b3c8d3be49244d38" translate="yes" xml:space="preserve">
          <source>This switch causes the command line used to invoke the compiler to be recorded into the object file that is being created. This switch is only implemented on some targets and the exact format of the recording is target and binary file format dependent, but it usually takes the form of a section containing ASCII text. This switch is related to the</source>
          <target state="translated">이 스위치는 컴파일러를 호출하는 데 사용 된 명령 행이 작성중인 오브젝트 파일에 기록되도록합니다. 이 스위치는 일부 대상에서만 구현되며 기록의 정확한 형식은 대상 및 이진 파일 형식에 따라 다르지만 일반적으로 ASCII 텍스트를 포함하는 섹션의 형태를 취합니다. 이 스위치는</target>
        </trans-unit>
        <trans-unit id="fcef4a45435978f94ac21ce5b4ddc80a97324665" translate="yes" xml:space="preserve">
          <source>This switch causes the command-line options used to invoke the compiler that may affect code generation to be appended to the DW_AT_producer attribute in DWARF debugging information. The options are concatenated with spaces separating them from each other and from the compiler version. It is enabled by default. See also</source>
          <target state="translated">이 스위치를 사용하면 코드 생성에 영향을 줄 수있는 컴파일러를 호출하는 데 사용되는 명령 행 옵션이 DWARF 디버깅 정보의 DW_AT_producer 속성에 추가됩니다. 옵션은 서로 분리되고 컴파일러 버전과 분리되는 공백으로 연결됩니다. 기본적으로 활성화되어 있습니다. 또한보십시오</target>
        </trans-unit>
        <trans-unit id="a3ef7cfaa3693eda0200855e73487a3931ad86b9" translate="yes" xml:space="preserve">
          <source>This switch declares that the user does not attempt to compare pointers to inline functions or methods where the addresses of the two functions are taken in different shared objects.</source>
          <target state="translated">이 스위치는 사용자가 포인터를 인라인 함수 또는 두 함수의 주소가 다른 공유 객체에서 사용되는 메소드와 비교하려고 시도하지 않음을 선언합니다.</target>
        </trans-unit>
        <trans-unit id="9d12a205f2d4388bb6e6b2aa9be08da33c955f0c" translate="yes" xml:space="preserve">
          <source>This switch disables the automatic removal of redundant &lt;code&gt;membar&lt;/code&gt; instructions from the generated code.</source>
          <target state="translated">이 스위치 는 생성 된 코드에서 여분의 &lt;code&gt;membar&lt;/code&gt; 명령어를 자동으로 제거하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="fb214efcf15f2eebcb5c8359308da41aee1bb7a5" translate="yes" xml:space="preserve">
          <source>This switch enables or disables the generation of ISEL instructions.</source>
          <target state="translated">이 스위치는 ISEL 명령어 생성을 활성화 또는 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="121380ba5bbee8a3b6396891291392c7f45ab990" translate="yes" xml:space="preserve">
          <source>This switch is mainly for debugging the compiler and will likely be removed in a future version.</source>
          <target state="translated">이 스위치는 주로 컴파일러 디버깅을위한 것으로 향후 버전에서 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83b61792d6d517f0567ee609808598af69f30e65" translate="yes" xml:space="preserve">
          <source>This switch removes redundant &lt;code&gt;membar&lt;/code&gt; instructions from the compiler-generated code. It is enabled by default.</source>
          <target state="translated">이 스위치는 컴파일러에서 생성 한 코드에서 중복 된 &lt;code&gt;membar&lt;/code&gt; 명령어를 제거합니다 . 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2700c0c5f6842561acacd13d2b72a8353682aa23" translate="yes" xml:space="preserve">
          <source>This syntax is defined in the C++ 2011 standard, but has been supported by G++ and other compilers since well before 2011.</source>
          <target state="translated">이 구문은 C ++ 2011 표준에 정의되어 있지만 2011 년 이전부터 G ++ 및 기타 컴파일러에서 지원되었습니다.</target>
        </trans-unit>
        <trans-unit id="82fcb60fefcb3dd52763982ecf7c2e7bdfe84505" translate="yes" xml:space="preserve">
          <source>This tells the compiler that a function is &lt;code&gt;malloc&lt;/code&gt;-like, i.e., that the pointer &lt;var&gt;P&lt;/var&gt; returned by the function cannot alias any other pointer valid when the function returns, and moreover no pointers to valid objects occur in any storage addressed by &lt;var&gt;P&lt;/var&gt;.</source>
          <target state="translated">이것은 컴파일러에게 함수가 &lt;code&gt;malloc&lt;/code&gt; 과 유사 함 을 알려줍니다. 즉 함수에 의해 리턴 된 포인터 &lt;var&gt;P&lt;/var&gt; 는 함수가 리턴 될 때 유효한 다른 포인터의 별명을 지정할 수 없으며, 유효한 오브젝트에 대한 포인터는 &lt;var&gt;P&lt;/var&gt; 로 지정된 스토리지에서 발생하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="57ca8b09b0bd70a0af88532cce8b6c0a57af5ea7" translate="yes" xml:space="preserve">
          <source>This tells the compiler to create, override or delete the named spec string. All lines after this directive up to the next directive or blank line are considered to be the text for the spec string. If this results in an empty string then the spec is deleted. (Or, if the spec did not exist, then nothing happens.) Otherwise, if the spec does not currently exist a new spec is created. If the spec does exist then its contents are overridden by the text of this directive, unless the first character of that text is the &amp;lsquo;</source>
          <target state="translated">이것은 컴파일러에게 명명 된 스펙 문자열을 작성, 대체 또는 삭제하도록 지시합니다. 이 지시문 다음의 다음 지시문까지의 모든 행 또는 빈 행은 스펙 문자열의 텍스트로 간주됩니다. 이 결과 빈 문자열이 발생하면 스펙이 삭제됩니다. (또는 스펙이 존재하지 않으면 아무 일도 일어나지 않습니다.) 그렇지 않으면 스펙이 현재 존재하지 않으면 새 스펙이 작성됩니다. 스펙이 존재하는 경우 해당 텍스트의 첫 문자가 '가 아닌 한이 지시문의 텍스트가 해당 컨텐츠를 대체합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
