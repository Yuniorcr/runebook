<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="gcc">
    <body>
      <group id="gcc">
        <trans-unit id="31ab20eab881b18de841e0f744838f8d79533911" translate="yes" xml:space="preserve">
          <source>On System V.4 and embedded PowerPC systems, specify that you are compiling for a VxWorks system.</source>
          <target state="translated">System V.4 및 내장 PowerPC 시스템에서 VxWorks 시스템 용으로 컴파일하도록 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="3b7c9e8fe9be90e5b1711df0aa43109dbeeee519" translate="yes" xml:space="preserve">
          <source>On a PowerPC, you can compile a function with &lt;code&gt;target_clones(&quot;cpu=power9,default&quot;)&lt;/code&gt;. GCC will create two function clones, one compiled with</source>
          <target state="translated">PowerPC에서 &lt;code&gt;target_clones(&quot;cpu=power9,default&quot;)&lt;/code&gt; 로 함수를 컴파일 할 수 있습니다 . GCC는 두 개의 함수 클론을 생성합니다. 하나는</target>
        </trans-unit>
        <trans-unit id="2b6207218221cf5a21cb4ce70228ebd866adf3c7" translate="yes" xml:space="preserve">
          <source>On a SPARC, GCC aligns all values of type &lt;code&gt;double&lt;/code&gt; on an 8-byte boundary, and it expects every &lt;code&gt;double&lt;/code&gt; to be so aligned. The Sun compiler usually gives &lt;code&gt;double&lt;/code&gt; values 8-byte alignment, with one exception: function arguments of type &lt;code&gt;double&lt;/code&gt; may not be aligned.</source>
          <target state="translated">SPARC에서 GCC는 &lt;code&gt;double&lt;/code&gt; 유형의 모든 값을 8 바이트 경계에 정렬하며 모든 &lt;code&gt;double&lt;/code&gt; 이 정렬 될 것으로 예상합니다 . Sun 컴파일러는 일반적으로 &lt;code&gt;double&lt;/code&gt; 값 8 바이트 정렬을 제공하지만 한 가지 예외가 있습니다. &lt;code&gt;double&lt;/code&gt; 유형의 함수 인수는 정렬되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c54d5e9842efa1190de832e68ceeddd07e1b57ec" translate="yes" xml:space="preserve">
          <source>On embedded PowerPC systems, assume that the startup module is called</source>
          <target state="translated">내장 PowerPC 시스템에서 시작 모듈이 호출되었다고 가정</target>
        </trans-unit>
        <trans-unit id="8b133920834ad968fd5e3ad90be374421844ec08" translate="yes" xml:space="preserve">
          <source>On embedded PowerPC systems, put all initialized global and static data in the &lt;code&gt;.data&lt;/code&gt; section, and all uninitialized data in the &lt;code&gt;.bss&lt;/code&gt; section.</source>
          <target state="translated">내장 PowerPC 시스템의 경우 초기화 된 모든 전역 및 정적 데이터를 &lt;code&gt;.data&lt;/code&gt; 섹션에, 초기화되지 않은 모든 데이터를 &lt;code&gt;.bss&lt;/code&gt; 섹션에 넣습니다 .</target>
        </trans-unit>
        <trans-unit id="956164ada36cee4efdb76678bae728426fa21ad6" translate="yes" xml:space="preserve">
          <source>On embedded PowerPC systems, put global and static items less than or equal to &lt;var&gt;num&lt;/var&gt; bytes into the small data or BSS sections instead of the normal data or BSS section. By default, &lt;var&gt;num&lt;/var&gt; is 8. The</source>
          <target state="translated">내장 PowerPC 시스템 에서 일반 데이터 또는 BSS 섹션 대신 작은 데이터 또는 BSS 섹션 에 &lt;var&gt;num&lt;/var&gt; 바이트 이하의 전역 및 정적 항목을 넣습니다. 기본적으로 &lt;var&gt;num&lt;/var&gt; 은 8입니다.</target>
        </trans-unit>
        <trans-unit id="12a413b7674df08ad1aab1d7a97049457f7c4105" translate="yes" xml:space="preserve">
          <source>On embedded PowerPC systems, set the &lt;code&gt;PPC_EMB&lt;/code&gt; bit in the ELF flags header to indicate that &amp;lsquo;</source>
          <target state="translated">내장 PowerPC 시스템의 경우 ELF 플래그 헤더에서 &lt;code&gt;PPC_EMB&lt;/code&gt; 비트를 설정하여 '</target>
        </trans-unit>
        <trans-unit id="276196a98c13434d4d4c303d9ed47e653a63a0a3" translate="yes" xml:space="preserve">
          <source>On machines where a function returns floating-point results in the 80387 register stack, some floating-point opcodes may be emitted even if</source>
          <target state="translated">함수가 80387 레지스터 스택에서 부동 소수점 결과를 반환하는 시스템에서 일부 부동 소수점 연산 코드는</target>
        </trans-unit>
        <trans-unit id="765fd445f5f79a3b6c1bf65d331a2ab62d7c09c3" translate="yes" xml:space="preserve">
          <source>On machines with register windows, be sure to choose a global register that is not affected magically by the function call mechanism.</source>
          <target state="translated">레지스터 창이있는 머신에서는 함수 호출 메커니즘의 영향을받지 않는 글로벌 레지스터를 선택해야합니다.</target>
        </trans-unit>
        <trans-unit id="baf0367d5874a0c5c72bd2d02e6ad6a8602da5fb" translate="yes" xml:space="preserve">
          <source>On many platforms, GCC supports a different ABI for C++ than do other compilers, so the object files compiled by GCC cannot be used with object files generated by another C++ compiler.</source>
          <target state="translated">많은 플랫폼에서 GCC는 다른 컴파일러와 다른 C ++ 용 ABI를 지원하므로 GCC로 컴파일 된 객체 파일을 다른 C ++ 컴파일러에서 생성 한 객체 파일과 함께 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4d7c2fb9e12e897dbce329dee3a106daf06850a0" translate="yes" xml:space="preserve">
          <source>On most machines, &lt;code&gt;longjmp&lt;/code&gt; restores to each global register variable the value it had at the time of the &lt;code&gt;setjmp&lt;/code&gt;. On some machines, however, &lt;code&gt;longjmp&lt;/code&gt; does not change the value of global register variables. To be portable, the function that called &lt;code&gt;setjmp&lt;/code&gt; should make other arrangements to save the values of the global register variables, and to restore them in a &lt;code&gt;longjmp&lt;/code&gt;. This way, the same thing happens regardless of what &lt;code&gt;longjmp&lt;/code&gt; does.</source>
          <target state="translated">대부분의 머신에서 &lt;code&gt;longjmp&lt;/code&gt; 는 &lt;code&gt;setjmp&lt;/code&gt; 당시의 값을 각 글로벌 레지스터 변수에 복원합니다 . 그러나 일부 시스템에서는 &lt;code&gt;longjmp&lt;/code&gt; 가 전역 레지스터 변수의 값을 변경하지 않습니다. 이식성을 &lt;code&gt;setjmp&lt;/code&gt; 위해 setjmp 라는 함수 는 전역 레지스터 변수의 값을 저장하고 &lt;code&gt;longjmp&lt;/code&gt; 로 복원하기 위해 다른 배열을 만들어야합니다 . 이런 식으로 &lt;code&gt;longjmp&lt;/code&gt; 의 기능에 관계없이 동일한 작업 이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="61f4155d039689baf9c247b710861ebab661061d" translate="yes" xml:space="preserve">
          <source>On most systems that use stabs format,</source>
          <target state="translated">stab 형식을 사용하는 대부분의 시스템에서</target>
        </trans-unit>
        <trans-unit id="164e2d1cdab76253173fd67017576978f44922c1" translate="yes" xml:space="preserve">
          <source>On some BSD systems, including some versions of Ultrix, use of profiling causes static variable destructors (currently used only in C++) not to be run.</source>
          <target state="translated">일부 Ultrix 버전을 포함한 일부 BSD 시스템에서 프로파일 링을 사용하면 정적 변수 소멸자 (현재 C ++에서만 사용됨)가 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="63572090afdc3d5b19c4bea28a32908c6254289e" translate="yes" xml:space="preserve">
          <source>On some machines it may be impossible to determine the frame address of any function other than the current one; in such cases, or when the top of the stack has been reached, this function returns &lt;code&gt;0&lt;/code&gt; if the first frame pointer is properly initialized by the startup code.</source>
          <target state="translated">일부 기계에서는 현재 기능 이외의 다른 기능의 프레임 주소를 결정하는 것이 불가능할 수 있습니다. 이러한 경우 또는 스택의 맨 위에 도달 하면 시작 코드에 의해 첫 번째 프레임 포인터가 올바르게 초기화 된 경우이 함수는 &lt;code&gt;0&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="c1c8ec9b26e1e50270902a24206b23748281f80a" translate="yes" xml:space="preserve">
          <source>On some machines it may be impossible to determine the return address of any function other than the current one; in such cases, or when the top of the stack has been reached, this function returns &lt;code&gt;0&lt;/code&gt; or a random value. In addition, &lt;code&gt;__builtin_frame_address&lt;/code&gt; may be used to determine if the top of the stack has been reached.</source>
          <target state="translated">일부 기계에서는 현재 기능 이외의 다른 기능의 복귀 주소를 결정하는 것이 불가능할 수 있습니다. 이러한 경우 또는 스택의 상단에 도달하면이 함수는 &lt;code&gt;0&lt;/code&gt; 또는 임의의 값을 반환 합니다. 또한 &lt;code&gt;__builtin_frame_address&lt;/code&gt; 를 사용하여 스택의 상단에 도달했는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ef53bfa27577d13d6b983892ac610f1cbdddec9" translate="yes" xml:space="preserve">
          <source>On some machines it may be impossible to determine the return address of any function other than the current one; in such cases, or when the top of the stack has been reached, this function returns an unspecified value. In addition, &lt;code&gt;__builtin_frame_address&lt;/code&gt; may be used to determine if the top of the stack has been reached.</source>
          <target state="translated">일부 시스템에서는 현재 기능이 아닌 다른 기능의 반환 주소를 결정하는 것이 불가능할 수 있습니다. 이러한 경우 또는 스택 맨 위에 도달하면이 함수는 지정되지 않은 값을 반환합니다. 또한 &lt;code&gt;__builtin_frame_address&lt;/code&gt; 를 사용하여 스택 상단에 도달했는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9459429806b19bedbc3812fd4e4235d2169468c6" translate="yes" xml:space="preserve">
          <source>On some newer machines, PCC uses a reentrant convention for all structure and union returning. GCC on most of these machines uses a compatible convention when returning structures and unions in memory, but still returns small structures and unions in registers.</source>
          <target state="translated">일부 최신 컴퓨터에서는 PCC가 모든 구조 및 조합 반환에 재진입 규칙을 사용합니다. 이러한 대부분의 머신에서 GCC는 메모리에서 구조 및 공용체를 리턴 할 때 호환되는 규칙을 사용하지만 레지스터에서 작은 구조 및 공용체를 계속 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="e7a00be8ad71da46c5174d313f9a640c4604077b" translate="yes" xml:space="preserve">
          <source>On some processors, like Intel Atom, 8-bit unsigned integer divide is much faster than 32-bit/64-bit integer divide. This option generates a run-time check. If both dividend and divisor are within range of 0 to 255, 8-bit unsigned integer divide is used instead of 32-bit/64-bit integer divide.</source>
          <target state="translated">Intel Atom과 같은 일부 프로세서에서 8 비트 부호없는 정수 나누기는 32 비트 / 64 비트 정수 나누기보다 훨씬 빠릅니다. 이 옵션은 런타임 검사를 생성합니다. 피제수와 제수가 0에서 255 사이의 범위에 있으면 32 비트 / 64 비트 정수 나누기 대신 8 비트 부호없는 정수 나누기가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="962c05222fdb4b91f96523bd87b84e3ad46c65d1" translate="yes" xml:space="preserve">
          <source>On some rare x86 targets, &lt;code&gt;setjmp&lt;/code&gt; doesn&amp;rsquo;t save the registers in all circumstances. In those cases, GCC doesn&amp;rsquo;t allocate any variables in registers unless they are marked &lt;code&gt;register&lt;/code&gt;.</source>
          <target state="translated">일부 희귀 한 x86 대상에서 &lt;code&gt;setjmp&lt;/code&gt; 는 모든 상황에서 레지스터를 저장하지 않습니다. 가 표시되지 않는 한 이러한 경우, GCC는 레지스터에 어떤 변수를 할당하지 않습니다 &lt;code&gt;register&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50b8a98a7845b95d4eb0c4bf2a96f13e10a0e926" translate="yes" xml:space="preserve">
          <source>On some systems, &amp;lsquo;</source>
          <target state="translated">일부 시스템에서는 '</target>
        </trans-unit>
        <trans-unit id="18b57ea0d71c60c160b6870aa792c110927a6a2b" translate="yes" xml:space="preserve">
          <source>On some systems, header file directories contain machine-specific symbolic links in certain places. This makes it possible to share most of the header files among hosts running the same version of the system on different machine models.</source>
          <target state="translated">일부 시스템에서 헤더 파일 디렉토리는 특정 위치에 기계 별 기호 링크를 포함합니다. 이를 통해 서로 다른 시스템 모델에서 동일한 버전의 시스템을 실행하는 호스트간에 대부분의 헤더 파일을 공유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5afa05ee4c2834411c301dd21c9dd367b2afc2a4" translate="yes" xml:space="preserve">
          <source>On some target machines, GCC supports many built-in functions specific to those machines. Generally these generate calls to specific machine instructions, but allow the compiler to schedule those calls.</source>
          <target state="translated">일부 대상 시스템에서 GCC는 해당 시스템에 고유 한 많은 내장 기능을 지원합니다. 일반적으로 특정 기계 명령어에 대한 호출을 생성하지만 컴파일러가 해당 호출을 예약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98a0b32bda81ede1cd6faa721c95ce64fb072f42" translate="yes" xml:space="preserve">
          <source>On some targets the attributes also accept an integer argument to specify a priority to control the order in which constructor and destructor functions are run. A constructor with a smaller priority number runs before a constructor with a larger priority number; the opposite relationship holds for destructors. So, if you have a constructor that allocates a resource and a destructor that deallocates the same resource, both functions typically have the same priority. The priorities for constructor and destructor functions are the same as those specified for namespace-scope C++ objects (see &lt;a href=&quot;c_002b_002b-attributes#C_002b_002b-Attributes&quot;&gt;C++ Attributes&lt;/a&gt;). However, at present, the order in which constructors for C++ objects with static storage duration and functions decorated with attribute &lt;code&gt;constructor&lt;/code&gt; are invoked is unspecified. In mixed declarations, attribute &lt;code&gt;init_priority&lt;/code&gt; can be used to impose a specific ordering.</source>
          <target state="translated">일부 대상에서 속성은 정수 인수를 허용하여 생성자 및 소멸자 함수가 실행되는 순서를 제어하기위한 우선 순위를 지정합니다. 우선 순위 번호가 작은 생성자가 우선 순위 번호가 큰 생성자보다 먼저 실행됩니다. 소멸자는 반대 관계를 유지합니다. 따라서 리소스를 할당하는 생성자와 동일한 리소스를 할당 해제하는 소멸자가있는 경우 일반적으로 두 함수의 우선 순위가 동일합니다. 생성자 및 소멸자 함수의 우선 순위는 네임 스페이스 범위 C ++ 객체에 지정된 것과 동일합니다 ( &lt;a href=&quot;c_002b_002b-attributes#C_002b_002b-Attributes&quot;&gt;C ++ 속성&lt;/a&gt; 참조 ). 그러나 현재 정적 저장 시간을 갖는 C ++ 객체의 &lt;code&gt;constructor&lt;/code&gt; 와 속성 생성자로 장식 된 함수의 순서지정되지 않은 호출입니다. 혼합 선언에서 속성 &lt;code&gt;init_priority&lt;/code&gt; 를 사용하여 특정 순서를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="788803b9b10d0e01cda4976ecfb5c895ad7a5b3a" translate="yes" xml:space="preserve">
          <source>On some targets this flag has no effect because the standard calling sequence always uses a frame pointer, so it cannot be omitted.</source>
          <target state="translated">표준 호출 순서는 항상 프레임 포인터를 사용하므로 일부 대상에서는이 플래그가 적용되지 않으므로 생략 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c64fcda505cd363eeb7c02acd97bfcddc4bbd34d" translate="yes" xml:space="preserve">
          <source>On some targets,</source>
          <target state="translated">일부 대상에서</target>
        </trans-unit>
        <trans-unit id="69a2029b429c1edce694be8a2285d9fe96168834" translate="yes" xml:space="preserve">
          <source>On some targets, a special form of output operand exists by which conditions in the flags register may be outputs of the asm. The set of conditions supported are target specific, but the general rule is that the output variable must be a scalar integer, and the value is boolean. When supported, the target defines the preprocessor symbol &lt;code&gt;__GCC_ASM_FLAG_OUTPUTS__&lt;/code&gt;.</source>
          <target state="translated">일부 대상에서는 플래그 레지스터의 조건이 asm의 출력이 될 수있는 특수한 형태의 출력 피연산자가 존재합니다. 지원되는 조건 세트는 대상에 따라 다르지만 일반적으로 출력 변수는 스칼라 정수 여야하며 값은 부울이어야합니다. 지원되는 경우 대상은 전 처리기 기호 &lt;code&gt;__GCC_ASM_FLAG_OUTPUTS__&lt;/code&gt; 를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="15856f8aeb189d03f7962b7a088a8da27e3b7698" translate="yes" xml:space="preserve">
          <source>On some targets, the instruction set contains SIMD vector instructions which operate on multiple values contained in one large register at the same time. For example, on the x86 the MMX, 3DNow! and SSE extensions can be used this way.</source>
          <target state="translated">일부 대상에서 명령어 세트에는 하나의 큰 레지스터에 포함 된 여러 값에서 동시에 작동하는 SIMD 벡터 명령어가 포함되어 있습니다. 예를 들어 x86에서 MMX, 3DNow! 이 방법으로 SSE 확장을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f61759f6ed3890f04c249dd91cb9dd263d93f566" translate="yes" xml:space="preserve">
          <source>On systems that provide</source>
          <target state="translated">다음을 제공하는 시스템에서</target>
        </trans-unit>
        <trans-unit id="3224a581ef3e35f60ddcaea7c51bc1eb2a15bb26" translate="yes" xml:space="preserve">
          <source>On systems that support dynamic linking, this overrides</source>
          <target state="translated">동적 연결을 지원하는 시스템에서 이는 재정의</target>
        </trans-unit>
        <trans-unit id="40c0cbf9ca562d8813acfb29f55f0f2638a9538b" translate="yes" xml:space="preserve">
          <source>On systems that support the &lt;code&gt;visibility&lt;/code&gt; attribute, this attribute also implies &amp;ldquo;default&amp;rdquo; visibility. It is an error to explicitly specify any other visibility.</source>
          <target state="translated">&lt;code&gt;visibility&lt;/code&gt; 속성 을 지원하는 시스템 에서이 속성은 &quot;기본&quot;가시성을 의미합니다. 다른 가시성을 명시 적으로 지정하는 것은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="0b5a32b9b4c00b5336f23962d28d21f5785c04c6" translate="yes" xml:space="preserve">
          <source>On systems where an underscore is normally prepended to the name of a C variable, this feature allows you to define names for the linker that do not start with an underscore.</source>
          <target state="translated">밑줄이 일반적으로 C 변수 이름 앞에 붙는 시스템에서이 기능을 사용하면 밑줄로 시작하지 않는 링커의 이름을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="212542d3f9bd9c37cf41fc83c6e569604a10e8a0" translate="yes" xml:space="preserve">
          <source>On systems with recent GNU assembler and C library, the C++ compiler uses the &lt;code&gt;STB_GNU_UNIQUE&lt;/code&gt; binding to make sure that definitions of template static data members and static local variables in inline functions are unique even in the presence of &lt;code&gt;RTLD_LOCAL&lt;/code&gt;; this is necessary to avoid problems with a library used by two different &lt;code&gt;RTLD_LOCAL&lt;/code&gt; plugins depending on a definition in one of them and therefore disagreeing with the other one about the binding of the symbol. But this causes &lt;code&gt;dlclose&lt;/code&gt; to be ignored for affected DSOs; if your program relies on reinitialization of a DSO via &lt;code&gt;dlclose&lt;/code&gt; and &lt;code&gt;dlopen&lt;/code&gt;, you can use</source>
          <target state="translated">최근 GNU 어셈블러 및 C 라이브러리가있는 시스템에서 C ++ 컴파일러는 &lt;code&gt;STB_GNU_UNIQUE&lt;/code&gt; 바인딩을 사용하여 인라인 함수의 템플리트 정적 데이터 멤버 및 정적 로컬 변수의 정의가 &lt;code&gt;RTLD_LOCAL&lt;/code&gt; 이 있는 경우에도 고유 한지 확인합니다 . 이것은 하나의 정의에 따라 두 개의 다른 &lt;code&gt;RTLD_LOCAL&lt;/code&gt; 플러그인이 사용하는 라이브러리의 문제를 피하기 위해 필요 하며 따라서 다른 하나는 심볼의 바인딩에 대해 동의하지 않습니다. 그러나 이로 인해 영향을받는 DSO에 대해 &lt;code&gt;dlclose&lt;/code&gt; 가 무시됩니다. 프로그램이 &lt;code&gt;dlclose&lt;/code&gt; 및 &lt;code&gt;dlopen&lt;/code&gt; 을 통해 DSO의 다시 초기화에 의존하는 경우 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="425eb623da59637995768118b04879b74012b572" translate="yes" xml:space="preserve">
          <source>On targets such as x86 that support multiple assembler dialects, all basic &lt;code&gt;asm&lt;/code&gt; blocks use the assembler dialect specified by the</source>
          <target state="translated">여러 어셈블러 방언을 지원하는 x86과 같은 대상에서 모든 기본 &lt;code&gt;asm&lt;/code&gt; 블록은</target>
        </trans-unit>
        <trans-unit id="d61cb2550f8a937ac6fdb2426039ef34d8bd79ab" translate="yes" xml:space="preserve">
          <source>On targets such as x86, GCC supports multiple assembler dialects. The</source>
          <target state="translated">x86과 같은 대상에서 GCC는 여러 어셈블러 언어를 지원합니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="58cd0cfdbd27bd5c1c85588e8db09d5e47fe7abd" translate="yes" xml:space="preserve">
          <source>On targets that don&amp;rsquo;t support COMDAT, but do support weak symbols, GCC uses them. This way one copy overrides all the others, but the unused copies still take up space in the executable.</source>
          <target state="translated">COMDAT는 지원하지 않지만 약한 기호는 지원하는 대상에서는 GCC가이를 사용합니다. 이렇게하면 한 복사본이 다른 복사본보다 우선하지만 사용되지 않은 복사본은 여전히 ​​실행 파일의 공간을 차지합니다.</target>
        </trans-unit>
        <trans-unit id="db6b506cf934f95ab486d96d507e199e74530808" translate="yes" xml:space="preserve">
          <source>On targets that support strong aliases, G++ works around mangling changes by creating an alias with the correct mangled name when defining a symbol with an incorrect mangled name. This switch specifies which ABI version to use for the alias.</source>
          <target state="translated">강력한 별칭을 지원하는 대상에서 G ++는 잘못된 맹 글링 된 이름을 가진 기호를 정의 할 때 올바른 맹 글링 된 이름을 가진 별칭을 만들어 변경 사항을 해결하는 데 도움이됩니다. 이 스위치는 별칭에 사용할 ABI 버전을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="ad2005f135085bd91be5baac596d98423c81523a" translate="yes" xml:space="preserve">
          <source>On targets that support symbol aliases, the default is</source>
          <target state="translated">심볼 별칭을 지원하는 대상에서 기본값은</target>
        </trans-unit>
        <trans-unit id="08070a532da1172ea25375415fe645b0da79ac62" translate="yes" xml:space="preserve">
          <source>On targets that use instruction scheduling, this option controls the amount of debugging output the scheduler prints to the dump files.</source>
          <target state="translated">명령어 스케줄링을 사용하는 대상에서이 옵션은 스케줄러가 덤프 파일에 인쇄하는 디버깅 출력량을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="092af2f5d49550882da513d26e921a4d8d4fe252" translate="yes" xml:space="preserve">
          <source>On targets where code addresses are representable as &lt;code&gt;void *&lt;/code&gt;,</source>
          <target state="translated">코드 주소가 &lt;code&gt;void *&lt;/code&gt; 로 표현 될 수있는 대상에서 ,</target>
        </trans-unit>
        <trans-unit id="0357809f36796934ee518b4f582ea0c9e04da24c" translate="yes" xml:space="preserve">
          <source>On targets where the user visible pointer size is smaller than the size of an actual hardware address this function returns the extended user pointer. Targets where this is true included ILP32 mode on x86_64 or Aarch64. This function is mainly useful when writing inline assembly code.</source>
          <target state="translated">사용자가 볼 수있는 포인터 크기가 실제 하드웨어 주소보다 작은 대상에서이 함수는 확장 된 사용자 포인터를 반환합니다. 이것이 맞는 대상은 x86_64 또는 Aarch64의 ILP32 모드를 포함합니다. 이 함수는 주로 인라인 어셈블리 코드를 작성할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="c74599677d84a97b951cd701c929b270ae2a8f43" translate="yes" xml:space="preserve">
          <source>On the ARC, you must specify the kind of interrupt to be handled in a parameter to the interrupt attribute like this:</source>
          <target state="translated">ARC에서 다음과 같이 인터럽트 속성에 대한 매개 변수에서 처리 할 인터럽트 종류를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="8f1b9d0583dcf355892e7a5808d90a73184b57e9" translate="yes" xml:space="preserve">
          <source>On the AVR target, there are several address spaces that can be used in order to put read-only data into the flash memory and access that data by means of the special instructions &lt;code&gt;LPM&lt;/code&gt; or &lt;code&gt;ELPM&lt;/code&gt; needed to read from flash.</source>
          <target state="translated">AVR 대상에는 읽기 전용 데이터를 플래시 메모리에 저장하고 플래시 에서 읽는 데 필요한 특수 명령 &lt;code&gt;LPM&lt;/code&gt; 또는 &lt;code&gt;ELPM&lt;/code&gt; 을 통해 해당 데이터에 액세스하기 위해 사용할 수있는 여러 주소 공간이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fa1a3a8be337624014eab65a011ba0cd4944578f" translate="yes" xml:space="preserve">
          <source>On the AVR, the hardware globally disables interrupts when an interrupt is executed. The first instruction of an interrupt handler declared with this attribute is a &lt;code&gt;SEI&lt;/code&gt; instruction to re-enable interrupts. See also the &lt;code&gt;signal&lt;/code&gt; function attribute that does not insert a &lt;code&gt;SEI&lt;/code&gt; instruction. If both &lt;code&gt;signal&lt;/code&gt; and &lt;code&gt;interrupt&lt;/code&gt; are specified for the same function, &lt;code&gt;signal&lt;/code&gt; is silently ignored.</source>
          <target state="translated">AVR에서 인터럽트가 실행될 때 하드웨어는 전체적으로 인터럽트를 비활성화합니다. 이 속성으로 선언 된 인터럽트 핸들러의 첫 번째 명령어는 인터럽트 를 다시 활성화 하는 &lt;code&gt;SEI&lt;/code&gt; 명령어입니다. &lt;code&gt;SEI&lt;/code&gt; 명령어를 삽입하지 않는 &lt;code&gt;signal&lt;/code&gt; 기능 속성 도 참조하십시오 . 두 경우에 &lt;code&gt;signal&lt;/code&gt; 및 &lt;code&gt;interrupt&lt;/code&gt; 와 같은 기능을 위해 지정되는, &lt;code&gt;signal&lt;/code&gt; 조용히 무시된다.</target>
        </trans-unit>
        <trans-unit id="5cd37ff9ade8fdf6a273265986e56386f3b6bf8a" translate="yes" xml:space="preserve">
          <source>On the H8/300H and H8S, use the same alignment rules as for the H8/300. The default for the H8/300H and H8S is to align longs and floats on 4-byte boundaries.</source>
          <target state="translated">H8 / 300H 및 H8S에서 H8 / 300과 동일한 정렬 규칙을 사용하십시오. H8 / 300H 및 H8S의 기본값은 4 바이트 경계에서 long과 float를 정렬하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="11e9b1c71b01253bfa1fdd5df13310266b613077" translate="yes" xml:space="preserve">
          <source>On the HP PA machine, ADB sometimes fails to work on functions compiled with GCC. Specifically, it fails to work on functions that use &lt;code&gt;alloca&lt;/code&gt; or variable-size arrays. This is because GCC doesn&amp;rsquo;t generate HP-UX unwind descriptors for such functions. It may even be impossible to generate them.</source>
          <target state="translated">HP PA 시스템에서 ADB가 GCC로 컴파일 된 기능에서 작동하지 않는 경우가 있습니다. 특히, &lt;code&gt;alloca&lt;/code&gt; 또는 가변 크기 배열 을 사용하는 함수에서는 작동하지 않습니다 . GCC는 이러한 기능에 대해 HP-UX 언 와인드 디스크립터를 생성하지 않기 때문입니다. 그것들을 생성하는 것이 불가능할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6f0c85db03b4e781c3473176ab2b4c1d6c0940b" translate="yes" xml:space="preserve">
          <source>On the M32C target, with the R8C and M16C CPU variants, variables qualified with &lt;code&gt;__far&lt;/code&gt; are accessed using 32-bit addresses in order to access memory beyond the first 64 Ki bytes. If &lt;code&gt;__far&lt;/code&gt; is used with the M32CM or M32C CPU variants, it has no effect.</source>
          <target state="translated">R8C 및 M16C CPU 변형이있는 M32C 대상에서 &lt;code&gt;__far&lt;/code&gt; 로 정규화 된 변수 는 32 비트 주소를 사용하여 액세스하여 처음 64Ki 바이트를 초과하는 메모리에 액세스합니다. &lt;code&gt;__far&lt;/code&gt; 를 M32CM 또는 M32C CPU 변형과 함께 사용 하면 아무런 영향이 없습니다.</target>
        </trans-unit>
        <trans-unit id="8646819484a9f2352804185ed962b1134d1b1e37" translate="yes" xml:space="preserve">
          <source>On the M32R/D, use this attribute to set the addressability of an object, and of the code generated for a function. The identifier &lt;var&gt;model-name&lt;/var&gt; is one of &lt;code&gt;small&lt;/code&gt;, &lt;code&gt;medium&lt;/code&gt;, or &lt;code&gt;large&lt;/code&gt;, representing each of the code models.</source>
          <target state="translated">M32R / D에서이 속성을 사용하여 객체 및 함수에 대해 생성 된 코드의 주소 지정 가능성을 설정하십시오. 식별자 &lt;var&gt;model-name&lt;/var&gt; 은 각 코드 모델을 나타내는 &lt;code&gt;small&lt;/code&gt; , &lt;code&gt;medium&lt;/code&gt; 또는 &lt;code&gt;large&lt;/code&gt; 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="9e52ddbba667c27e2e0b8a95a8956a520ea2f402" translate="yes" xml:space="preserve">
          <source>On the MIPS platform, there is related use for local register variables with slightly different characteristics (see &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gccint/MIPS-Coprocessors.html#MIPS-Coprocessors&quot;&gt;Defining coprocessor specifics for MIPS targets&lt;/a&gt; in GNU Compiler Collection (GCC) Internals).</source>
          <target state="translated">MIPS 플랫폼에서는 특성이 약간 다른 로컬 레지스터 변수에 관련하여 사용됩니다 (GCC (GNU Compiler Collection) 내부의 &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gccint/MIPS-Coprocessors.html#MIPS-Coprocessors&quot;&gt;MIPS 대상&lt;/a&gt; 에 대한 보조 프로세서 특정 정의 참조 ).</target>
        </trans-unit>
        <trans-unit id="fbec944e2c4c4a91315d423364fb336ceebd34f7" translate="yes" xml:space="preserve">
          <source>On the MSP430 target these attributes can be used to specify whether the function or variable should be placed into low memory, high memory, or the placement should be left to the linker to decide. The attributes are only significant if compiling for the MSP430X architecture in the large memory model.</source>
          <target state="translated">MSP430 대상에서 이러한 특성을 사용하여 함수 또는 변수를 낮은 메모리, 높은 메모리에 배치해야하는지 또는 위치를 링커에 맡겨서 결정해야하는지 여부를 지정할 수 있습니다. 속성은 대용량 메모리 모델에서 MSP430X 아키텍처 용으로 컴파일하는 경우에만 중요합니다.</target>
        </trans-unit>
        <trans-unit id="7d84cba170c40b006fde2258af21b87e67ebfb09" translate="yes" xml:space="preserve">
          <source>On the MSP430 target these attributes can be used to specify whether the function or variable should be placed into low memory, high memory, or the placement should be left to the linker to decide. The attributes are only significant if compiling for the MSP430X architecture.</source>
          <target state="translated">MSP430 대상에서 이러한 속성을 사용하여 함수 또는 변수를 메모리 부족, 고용량 메모리에 배치해야하는지 또는 배치를 결정하기 위해 링커에 남겨야하는지 여부를 지정할 수 있습니다. MSP430X 아키텍처를 위해 컴파일 할 경우에만 속성이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="d95670eabb89227c4ff1a457e8d12df37bee42fd" translate="yes" xml:space="preserve">
          <source>On the PowerPC Linux VSX targets, you can declare complex types using the corresponding internal complex type, &lt;code&gt;KCmode&lt;/code&gt; for &lt;code&gt;__float128&lt;/code&gt; type and &lt;code&gt;ICmode&lt;/code&gt; for &lt;code&gt;__ibm128&lt;/code&gt; type:</source>
          <target state="translated">파워 PC 리눅스 VSX 목표에, 당신은 해당 내장 복합 형식, 사용하여 복잡한 유형을 선언 할 수 있습니다 &lt;code&gt;KCmode&lt;/code&gt; 을 위한 &lt;code&gt;__float128&lt;/code&gt; 유형과 &lt;code&gt;ICmode&lt;/code&gt; 에 대한 &lt;code&gt;__ibm128&lt;/code&gt; 유형 :</target>
        </trans-unit>
        <trans-unit id="f6000ef0ce4e92f4ee54acf70fa8700653c71a5b" translate="yes" xml:space="preserve">
          <source>On the PowerPC, the following options are allowed:</source>
          <target state="translated">PowerPC에서는 다음 옵션이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="86940e5138753858b6a6f91addcad4105a370c7f" translate="yes" xml:space="preserve">
          <source>On the PowerPC, the inliner does not inline a function that has different target options than the caller, unless the callee has a subset of the target options of the caller.</source>
          <target state="translated">PowerPC에서 인라이너는 호출자가 호출자의 대상 옵션의 서브 세트를 갖지 않는 한 호출자와 다른 대상 옵션을 가진 함수를 인라인하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="45c4a00032a0dce389cc7f9c888e279c99fc2d6e" translate="yes" xml:space="preserve">
          <source>On the R8000 CPU when multiply-accumulate instructions are used, the intermediate product is calculated to infinite precision and is not subject to the FCSR Flush to Zero bit. This may be undesirable in some circumstances. On other processors the result is numerically identical to the equivalent computation using separate multiply, add, subtract and negate instructions.</source>
          <target state="translated">곱하기 누산 명령어가 사용될 때 R8000 CPU에서 중간 제품은 무한 정밀도로 계산되며 FCSR Flush to Zero 비트의 영향을받지 않습니다. 일부 상황에서는 바람직하지 않을 수 있습니다. 다른 프로세서에서 결과는 별도의 곱하기, 더하기, 빼기 및 부정 명령을 사용하는 등가 계산과 수치 적으로 동일합니다.</target>
        </trans-unit>
        <trans-unit id="0c2723395c05076575d0edc1ba09dc0cbf5cf2e2" translate="yes" xml:space="preserve">
          <source>On the RL78 target, variables qualified with &lt;code&gt;__far&lt;/code&gt; are accessed with 32-bit pointers (20-bit addresses) rather than the default 16-bit addresses. Non-far variables are assumed to appear in the topmost 64 KiB of the address space.</source>
          <target state="translated">RL78 대상에서 &lt;code&gt;__far&lt;/code&gt; 로 규정 된 변수 는 기본 16 비트 주소가 아닌 32 비트 포인터 (20 비트 주소)로 액세스됩니다. 원거리 변수는 주소 공간의 최상위 64 KiB에 나타나는 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="fd6f38b7027d1749320d26f46d1a28168c174ead" translate="yes" xml:space="preserve">
          <source>On the SH Symbian OS target the &lt;code&gt;dllimport&lt;/code&gt; attribute also has another affect&amp;mdash;it can cause the vtable and run-time type information for a class to be exported. This happens when the class has a dllimported constructor or a non-inline, non-pure virtual function and, for either of those two conditions, the class also has an inline constructor or destructor and has a key function that is defined in the current translation unit.</source>
          <target state="translated">SH Symbian OS 대상에서 &lt;code&gt;dllimport&lt;/code&gt; 속성도 다른 영향을 미칩니다. 클래스의 vtable 및 런타임 유형 정보가 내 보내질 수 있습니다. 클래스에 dllimported 생성자 또는 인라인이 아닌 순수한 가상 함수가 있고이 두 조건 중 하나에 대해 클래스에 인라인 생성자 또는 소멸자가 있으며 현재 번역에 정의 된 주요 함수가있는 경우 단위.</target>
        </trans-unit>
        <trans-unit id="cd5e8bc41b24a03848da023d0c42ed2a7835fd49" translate="yes" xml:space="preserve">
          <source>On the SH2A target, this attribute enables the high-speed register saving and restoration using a register bank for &lt;code&gt;interrupt_handler&lt;/code&gt; routines. Saving to the bank is performed automatically after the CPU accepts an interrupt that uses a register bank.</source>
          <target state="translated">SH2A 대상에서이 속성은 &lt;code&gt;interrupt_handler&lt;/code&gt; 뱅크 핸들러 루틴에 레지스터 뱅크를 사용하여 고속 레지스터 저장 및 복원을 가능하게 합니다. 뱅크에 저장은 CPU가 레지스터 뱅크를 사용하는 인터럽트를 수락 한 후에 자동으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="f2adbfacdc8481145065b808452ffcbbe789d6e7" translate="yes" xml:space="preserve">
          <source>On the SPU target variables may be declared as belonging to another address space by qualifying the type with the &lt;code&gt;__ea&lt;/code&gt; address space identifier:</source>
          <target state="translated">SPU에서 대상 변수는 &lt;code&gt;__ea&lt;/code&gt; 주소 공간 식별자로 유형을 한정하여 다른 주소 공간에 속하는 것으로 선언 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="583c1957eff9fd54fc7ba9d8a8ce5bd6cbbb0dbc" translate="yes" xml:space="preserve">
          <source>On the i386, x86_64, IA-64, and HP-UX targets, you can declare complex types using the corresponding internal complex type, &lt;code&gt;XCmode&lt;/code&gt; for &lt;code&gt;__float80&lt;/code&gt; type and &lt;code&gt;TCmode&lt;/code&gt; for &lt;code&gt;__float128&lt;/code&gt; type:</source>
          <target state="translated">는 i386, x86_64에에, IA-64 및 HP-UX의 목표, 당신은 해당 내장 복합 형식, 사용하여 복잡한 유형을 선언 할 수 있습니다 &lt;code&gt;XCmode&lt;/code&gt; 을 위한 &lt;code&gt;__float80&lt;/code&gt; 유형과 &lt;code&gt;TCmode&lt;/code&gt; 에 대한 &lt;code&gt;__float128&lt;/code&gt; 유형 :</target>
        </trans-unit>
        <trans-unit id="dcf75663e59f753533fd49143ad9b22b45ca5dee" translate="yes" xml:space="preserve">
          <source>On the other hand, in this example there is no warning:</source>
          <target state="translated">반면에이 예에서는 경고가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c654fceb0b13e0812db2eebf6209fb23d2a4245f" translate="yes" xml:space="preserve">
          <source>On the reduced Tiny devices like ATtiny40, no address spaces are supported. Just use vanilla C / C++ code without overhead as outlined above. Attribute &lt;code&gt;progmem&lt;/code&gt; is supported but works differently, see &lt;a href=&quot;variable-attributes#AVR-Variable-Attributes&quot;&gt;AVR Variable Attributes&lt;/a&gt;.</source>
          <target state="translated">ATtiny40과 같은 축소 된 Tiny 장치에서는 주소 공간이 지원되지 않습니다. 위에서 설명한대로 오버 헤드없이 바닐라 C / C ++ 코드를 사용하십시오. 속성 &lt;code&gt;progmem&lt;/code&gt; 은 지원되지만 다르게 작동합니다 ( &lt;a href=&quot;variable-attributes#AVR-Variable-Attributes&quot;&gt;AVR 변수 속성&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="4951a4be95b4833eb07239f4a372cdd8f2448825" translate="yes" xml:space="preserve">
          <source>On the x86 target, variables may be declared as being relative to the &lt;code&gt;%fs&lt;/code&gt; or &lt;code&gt;%gs&lt;/code&gt; segments.</source>
          <target state="translated">x86 대상에서 변수는 &lt;code&gt;%fs&lt;/code&gt; 또는 &lt;code&gt;%gs&lt;/code&gt; 세그먼트 에 상대적인 것으로 선언 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="147636575199bc4c1463a6a96921cb3caf526a23" translate="yes" xml:space="preserve">
          <source>On the x86, the following options are allowed:</source>
          <target state="translated">x86에서는 다음 옵션이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="04f0f8c579cd5c70473d51704cbf41abb08c9dc8" translate="yes" xml:space="preserve">
          <source>On the x86, the inliner does not inline a function that has different target options than the caller, unless the callee has a subset of the target options of the caller. For example a function declared with &lt;code&gt;target(&quot;sse3&quot;)&lt;/code&gt; can inline a function with &lt;code&gt;target(&quot;sse2&quot;)&lt;/code&gt;, since &lt;code&gt;-msse3&lt;/code&gt; implies &lt;code&gt;-msse2&lt;/code&gt;.</source>
          <target state="translated">x86에서 인라이너는 호출자가 호출자의 대상 옵션의 하위 집합을 가지고 있지 않으면 호출자와 다른 대상 옵션을 가진 함수를 인라인하지 않습니다. 예를 들어, 함수는 선언 된 &lt;code&gt;target(&quot;sse3&quot;)&lt;/code&gt; 과 함께 기능 할 수 인라인 &lt;code&gt;target(&quot;sse2&quot;)&lt;/code&gt; 하기 때문에, &lt;code&gt;-msse3&lt;/code&gt; 가 의미 &lt;code&gt;-msse2&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="0c4f5a0b052b2a8060d4fded035d077e00490366" translate="yes" xml:space="preserve">
          <source>On the x86-32 targets, the &lt;code&gt;cdecl&lt;/code&gt; attribute causes the compiler to assume that the calling function pops off the stack space used to pass arguments. This is useful to override the effects of the</source>
          <target state="translated">x86-32 대상에서 &lt;code&gt;cdecl&lt;/code&gt; 속성을 사용하면 컴파일러는 호출 함수가 인수를 전달하는 데 사용 된 스택 공간에서 튀어 나온다고 가정합니다. 이것은 효과를 무시하는 데 유용합니다</target>
        </trans-unit>
        <trans-unit id="ef036c2436b70e56f5d89ed3a4bd592468b97a24" translate="yes" xml:space="preserve">
          <source>On those ARM targets that support &lt;code&gt;dllimport&lt;/code&gt; (such as Symbian OS), you can use the &lt;code&gt;notshared&lt;/code&gt; attribute to indicate that the virtual table and other similar data for a class should not be exported from a DLL. For example:</source>
          <target state="translated">&lt;code&gt;dllimport&lt;/code&gt; 를 지원하는 ARM 대상 (예 : Symbian OS)에서 &lt;code&gt;notshared&lt;/code&gt; 속성을 사용하여 클래스에 대한 가상 테이블 및 기타 유사한 데이터를 DLL에서 내 보내지 않아야 함을 나타낼 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="70eb4df699149cfe34494e2a2d4a3053eec54b36" translate="yes" xml:space="preserve">
          <source>On x86 targets, the &lt;code&gt;fentry_name&lt;/code&gt; attribute sets the function to call on function entry when function instrumentation is enabled with</source>
          <target state="translated">x86 대상에서 &lt;code&gt;fentry_name&lt;/code&gt; 속성은 함수 계측을 사용하여 함수 계측을 사용할 때 함수 항목을 호출하도록 함수를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="3c3e4dc55159d733bc6d8174d6c0b4b44576b30b" translate="yes" xml:space="preserve">
          <source>On x86 targets, the &lt;code&gt;fentry_section&lt;/code&gt; attribute sets the name of the section to record function entry instrumentation calls in when enabled with</source>
          <target state="translated">x86 대상에서 &lt;code&gt;fentry_section&lt;/code&gt; 속성은 다음을 사용하여 기능 항목 계측 호출을 기록 할 섹션의 이름을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="13bdaf45293e8c14caaa41c024215d1502f9dedd" translate="yes" xml:space="preserve">
          <source>On x86 targets, the &lt;code&gt;force_align_arg_pointer&lt;/code&gt; attribute may be applied to individual function definitions, generating an alternate prologue and epilogue that realigns the run-time stack if necessary. This supports mixing legacy codes that run with a 4-byte aligned stack with modern codes that keep a 16-byte stack for SSE compatibility.</source>
          <target state="translated">x86 대상에서 &lt;code&gt;force_align_arg_pointer&lt;/code&gt; 속성을 개별 함수 정의에 적용하여 필요한 경우 런타임 스택을 다시 정렬하는 대체 프롤로그 및 에필로그를 생성 할 수 있습니다. 이는 4 바이트 정렬 스택으로 실행되는 레거시 코드와 SSE 호환성을 위해 16 바이트 스택을 유지하는 최신 코드와의 혼합을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="4b9b1df237cb48ab5b390c563b9173f28432ce30" translate="yes" xml:space="preserve">
          <source>On x86 targets, the &lt;code&gt;function_return&lt;/code&gt; attribute causes the compiler to convert function return with &lt;var&gt;choice&lt;/var&gt;. &amp;lsquo;</source>
          <target state="translated">x86 대상에서 &lt;code&gt;function_return&lt;/code&gt; 속성으로 인해 컴파일러는 function return을 &lt;var&gt;choice&lt;/var&gt; 로 변환합니다 . '</target>
        </trans-unit>
        <trans-unit id="e98109b32d764a6aa78e38267f8fd0b80deffe59" translate="yes" xml:space="preserve">
          <source>On x86 targets, the &lt;code&gt;indirect_branch&lt;/code&gt; attribute causes the compiler to convert indirect call and jump with &lt;var&gt;choice&lt;/var&gt;. &amp;lsquo;</source>
          <target state="translated">x86 대상에서 &lt;code&gt;indirect_branch&lt;/code&gt; 속성은 컴파일러가 간접 호출을 변환하고 &lt;var&gt;choice&lt;/var&gt; 와 함께 점프하도록 합니다 . '</target>
        </trans-unit>
        <trans-unit id="6debaf7293c72e5d4ef579b9583d9c54220aa952" translate="yes" xml:space="preserve">
          <source>On x86 targets, there are several rules on the usage of stack-like registers in the operands of an &lt;code&gt;asm&lt;/code&gt;. These rules apply only to the operands that are stack-like registers:</source>
          <target state="translated">x86 대상에는 &lt;code&gt;asm&lt;/code&gt; 의 피연산자에서 스택 유사 레지스터 사용에 대한 몇 가지 규칙이 있습니다 . 이 규칙은 스택 형 레지스터 인 피연산자에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="0a9ad2d6b1a6892ed184c51d63255bdbba6feecb" translate="yes" xml:space="preserve">
          <source>On x86-32 targets with SSE support, the &lt;code&gt;sseregparm&lt;/code&gt; attribute causes the compiler to pass up to 3 floating-point arguments in SSE registers instead of on the stack. Functions that take a variable number of arguments continue to pass all of their floating-point arguments on the stack.</source>
          <target state="translated">SSE를 지원하는 x86-32 대상에서 &lt;code&gt;sseregparm&lt;/code&gt; 속성은 컴파일러가 스택 대신 SSE 레지스터에서 최대 3 개의 부동 소수점 인수를 전달하도록합니다. 가변 개수의 인수를받는 함수는 스택에서 모든 부동 소수점 인수를 계속 전달합니다.</target>
        </trans-unit>
        <trans-unit id="b5b62a62d6592728c9f30e63c3f3d4654c7cba4c" translate="yes" xml:space="preserve">
          <source>On x86-32 targets, the &lt;code&gt;fastcall&lt;/code&gt; attribute causes the compiler to pass the first argument (if of integral type) in the register ECX and the second argument (if of integral type) in the register EDX. Subsequent and other typed arguments are passed on the stack. The called function pops the arguments off the stack. If the number of arguments is variable all arguments are pushed on the stack.</source>
          <target state="translated">x86-32 대상에서 &lt;code&gt;fastcall&lt;/code&gt; 속성을 사용하면 컴파일러는 레지스터 ECX의 첫 번째 인수 (정수 유형 인 경우)와 레지스터 EDX의 두 번째 인수 (정수 유형 인 경우)를 전달합니다. 후속 및 기타 유형의 인수가 스택에 전달됩니다. 호출 된 함수는 스택에서 인수를 팝합니다. 인수의 수가 가변적이면 모든 인수가 스택에서 푸시됩니다.</target>
        </trans-unit>
        <trans-unit id="cbd1fa07b20b0b27ba6acba6bf923a6e60833164" translate="yes" xml:space="preserve">
          <source>On x86-32 targets, the &lt;code&gt;regparm&lt;/code&gt; attribute causes the compiler to pass arguments number one to &lt;var&gt;number&lt;/var&gt; if they are of integral type in registers EAX, EDX, and ECX instead of on the stack. Functions that take a variable number of arguments continue to be passed all of their arguments on the stack.</source>
          <target state="translated">x86-32 대상에서 &lt;code&gt;regparm&lt;/code&gt; 속성을 사용하면 레지스터 대신 레지스터 EAX, EDX 및 ECX에서 정수 유형 인 경우 컴파일러가 인수 번호 1을 &lt;var&gt;number&lt;/var&gt; 로 전달 합니다. 가변 개수의 인수를 취하는 함수는 스택의 모든 인수를 계속 전달합니다.</target>
        </trans-unit>
        <trans-unit id="3ff7dde95e04753c9aa0506316b6827d1c04e392" translate="yes" xml:space="preserve">
          <source>On x86-32 targets, the &lt;code&gt;stdcall&lt;/code&gt; attribute causes the compiler to assume that the called function pops off the stack space used to pass arguments, unless it takes a variable number of arguments.</source>
          <target state="translated">x86-32 대상에서 &lt;code&gt;stdcall&lt;/code&gt; 속성을 사용하면 변수 수의 인수를 사용하지 않는 한 호출 된 함수가 인수를 전달하는 데 사용 된 스택 공간에서 튀어 나오 도록 컴파일러가 가정합니다.</target>
        </trans-unit>
        <trans-unit id="7e68005038eba79aa520fa3e9f1d5a1f549a6854" translate="yes" xml:space="preserve">
          <source>On x86-32 targets, the &lt;code&gt;thiscall&lt;/code&gt; attribute causes the compiler to pass the first argument (if of integral type) in the register ECX. Subsequent and other typed arguments are passed on the stack. The called function pops the arguments off the stack. If the number of arguments is variable all arguments are pushed on the stack. The &lt;code&gt;thiscall&lt;/code&gt; attribute is intended for C++ non-static member functions. As a GCC extension, this calling convention can be used for C functions and for static member methods.</source>
          <target state="translated">x86-32 대상에서 &lt;code&gt;thiscall&lt;/code&gt; 속성은 컴파일러가 레지스터 ECX의 첫 번째 인수 (정수 유형 인 경우)를 전달합니다. 후속 및 기타 유형의 인수가 스택에 전달됩니다. 호출 된 함수는 스택에서 인수를 팝합니다. 인수의 수가 가변적이면 모든 인수가 스택에서 푸시됩니다. &lt;code&gt;thiscall&lt;/code&gt; 특성은 C ++ 비 정적 멤버 함수위한 것이다. GCC 확장으로서이 호출 규칙은 C 함수 및 정적 멤버 메소드에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c75d4c9c1f7232a6ff5a36eb71f949d09c252de" translate="yes" xml:space="preserve">
          <source>On x86-32 targets, you can use this attribute to control how aggregates are returned in memory. If the caller is responsible for popping the hidden pointer together with the rest of the arguments, specify &lt;var&gt;number&lt;/var&gt; equal to zero. If callee is responsible for popping the hidden pointer, specify &lt;var&gt;number&lt;/var&gt; equal to one.</source>
          <target state="translated">x86-32 대상에서이 속성을 사용하여 메모리에서 집계가 리턴되는 방법을 제어 할 수 있습니다. 호출자가 숨겨진 인수를 나머지 인수와 함께 표시해야하는 경우 &lt;var&gt;number&lt;/var&gt; 를 0으로 지정하십시오 . 수신자가 숨겨진 포인터를 터뜨릴 책임이있는 경우 &lt;var&gt;number&lt;/var&gt; 를 1로 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="4fecb03395dc1395498320fbdf3198613b4b8a60" translate="yes" xml:space="preserve">
          <source>On x86-64,</source>
          <target state="translated">x86-64에서</target>
        </trans-unit>
        <trans-unit id="42dd75ddf8dffa70aaf71424d90322dc968acd07" translate="yes" xml:space="preserve">
          <source>Once you know these things about how your code works when compiled, you can look at each module to see which modules should be optimized. &lt;code&gt;gcov&lt;/code&gt; helps you determine where to work on optimization.</source>
          <target state="translated">컴파일 할 때 코드 작동 방식에 대해 다음 사항을 알게되면 각 모듈을보고 어떤 모듈을 최적화해야하는지 확인할 수 있습니다. &lt;code&gt;gcov&lt;/code&gt; 는 최적화 작업 위치를 결정하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="7b43238f6f78aaf633ee23a498072b63cc24feec" translate="yes" xml:space="preserve">
          <source>One 16x16 multiplier, blocking, sequential. The following instructions are additionally enabled: &lt;code&gt;mpy&lt;/code&gt;, &lt;code&gt;mpyu&lt;/code&gt;, &lt;code&gt;mpym&lt;/code&gt;, &lt;code&gt;mpymu&lt;/code&gt;, and &lt;code&gt;mpy_s&lt;/code&gt;.</source>
          <target state="translated">하나의 16x16 승수, 차단, 순차적. &lt;code&gt;mpy&lt;/code&gt; , &lt;code&gt;mpyu&lt;/code&gt; , &lt;code&gt;mpym&lt;/code&gt; , &lt;code&gt;mpymu&lt;/code&gt; 및 &lt;code&gt;mpy_s&lt;/code&gt; 명령이 추가로 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="21c409760c2daeb8e7cc4e16b05141d45f49a9c8" translate="yes" xml:space="preserve">
          <source>One 32x4 multiplier, blocking, sequential. The following instructions are additionally enabled: &lt;code&gt;mpy&lt;/code&gt;, &lt;code&gt;mpyu&lt;/code&gt;, &lt;code&gt;mpym&lt;/code&gt;, &lt;code&gt;mpymu&lt;/code&gt;, and &lt;code&gt;mpy_s&lt;/code&gt;.</source>
          <target state="translated">하나의 32x4 승수, 차단, 순차적. &lt;code&gt;mpy&lt;/code&gt; , &lt;code&gt;mpyu&lt;/code&gt; , &lt;code&gt;mpym&lt;/code&gt; , &lt;code&gt;mpymu&lt;/code&gt; 및 &lt;code&gt;mpy_s&lt;/code&gt; 명령이 추가로 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="849f208cf290b5367e3408ce32e8d353040bdae1" translate="yes" xml:space="preserve">
          <source>One attribute is currently defined for the M32R/D.</source>
          <target state="translated">M32R / D에 대해 하나의 속성이 현재 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="40fe184b70220276317c0b61fedbed3c3b9cb8e1" translate="yes" xml:space="preserve">
          <source>One attribute is currently defined for xstormy16 configurations: &lt;code&gt;below100&lt;/code&gt;.</source>
          <target state="translated">xstormy16 구성에 대해 하나의 속성이 현재 정의되어 있습니다 : &lt;code&gt;below100&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1dd2f15e1e49aa3a60aafa7cc37a3dcdf9c0a48d" translate="yes" xml:space="preserve">
          <source>One consequence is that you cannot call &lt;code&gt;mktemp&lt;/code&gt; with a string constant argument. The function &lt;code&gt;mktemp&lt;/code&gt; always alters the string its argument points to.</source>
          <target state="translated">결과적 으로 문자열 상수 인수로 &lt;code&gt;mktemp&lt;/code&gt; 를 호출 할 수 없습니다 . 함수 &lt;code&gt;mktemp&lt;/code&gt; 는은 항상 변경합니다 인수가 가리키는 문자열.</target>
        </trans-unit>
        <trans-unit id="44bd2c18671505607165541a387b3b6df0ee2e30" translate="yes" xml:space="preserve">
          <source>One drawback to using this attribute is that a pointer to a &lt;em&gt;variable&lt;/em&gt; marked as &lt;code&gt;dllimport&lt;/code&gt; cannot be used as a constant address. However, a pointer to a &lt;em&gt;function&lt;/em&gt; with the &lt;code&gt;dllimport&lt;/code&gt; attribute can be used as a constant initializer; in this case, the address of a stub function in the import lib is referenced. On Microsoft Windows targets, the attribute can be disabled for functions by setting the</source>
          <target state="translated">이 속성을 사용하는 한 가지 단점 은 &lt;code&gt;dllimport&lt;/code&gt; 로 표시된 &lt;em&gt;변수에&lt;/em&gt; 대한 포인터를 상수 주소로 사용할 수 없다는 것입니다. 그러나, 포인터 &lt;em&gt;기능&lt;/em&gt; 와 &lt;code&gt;dllimport&lt;/code&gt; 특성은 일정한 이니셜로서 사용될 수있다; 이 경우 가져 오기 라이브러리의 스텁 함수 주소가 참조됩니다. Microsoft Windows 대상에서 기능을 설정하여 속성을 비활성화 할 수 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="eec865ab9ca221fb872ddd30d1cd51ca9cd6aa48" translate="yes" xml:space="preserve">
          <source>One final built-in function has been added that returns the value of the 2-bit Transaction State field of the Machine Status Register (MSR) as stored in &lt;code&gt;CR0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CR0&lt;/code&gt; 에 저장된대로 MSR (Machine Status Register)의 2 비트 트랜잭션 상태 필드 값을 리턴하는 하나의 최종 내장 기능이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="c1bb56d3e41b8821842eef1d720c3d75aea46a37" translate="yes" xml:space="preserve">
          <source>One of the low eight SVE predicate registers (&lt;code&gt;P0&lt;/code&gt; to &lt;code&gt;P7&lt;/code&gt;)</source>
          <target state="translated">하위 8 개의 SVE 술어 레지스터 중 하나 ( &lt;code&gt;P0&lt;/code&gt; ~ &lt;code&gt;P7&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="64b686b9cc394ce49f58ad2185501cf7ed15c7d0" translate="yes" xml:space="preserve">
          <source>One of the standard libraries bypassed by</source>
          <target state="translated">우회 한 표준 라이브러리 중 하나</target>
        </trans-unit>
        <trans-unit id="02b57e3d25b1b84de7aa1ea5322739942677791f" translate="yes" xml:space="preserve">
          <source>One or more of the following option keywords can be used to describe a group of optimizations:</source>
          <target state="translated">다음 옵션 키워드 중 하나 이상을 사용하여 최적화 그룹을 설명 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55a0fb6dad6e34221933361d3e31d20be49bd376" translate="yes" xml:space="preserve">
          <source>One or more qualifiers: &lt;code&gt;static&lt;/code&gt;, &lt;code&gt;dynamic&lt;/code&gt;, &lt;code&gt;bounded&lt;/code&gt;.</source>
          <target state="translated">하나 이상의 한정자 : &lt;code&gt;static&lt;/code&gt; , &lt;code&gt;dynamic&lt;/code&gt; , &lt;code&gt;bounded&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="56bb919cccd4e254306e243c0906992cea6d6640" translate="yes" xml:space="preserve">
          <source>One such case is immediately following an &lt;code&gt;asm&lt;/code&gt; statement that either never terminates, or one that transfers control elsewhere and never returns. In this example, without the &lt;code&gt;__builtin_unreachable&lt;/code&gt;, GCC issues a warning that control reaches the end of a non-void function. It also generates code to return after the &lt;code&gt;asm&lt;/code&gt;.</source>
          <target state="translated">그러한 사례 중 하나는 종료되지 않거나 다른 곳에서 제어를 이전하고 절대 반환하지 않는 &lt;code&gt;asm&lt;/code&gt; 문을 즉시 따릅니다 . 이 예제에서 &lt;code&gt;__builtin_unreachable&lt;/code&gt; 이 없으면 GCC는 제어가 무효가 아닌 함수의 끝에 도달한다는 경고를 발행합니다. 또한 &lt;code&gt;asm&lt;/code&gt; 뒤에 리턴 할 코드를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="cfb62f38764ce598607e81e73ef5564abcafbf10" translate="yes" xml:space="preserve">
          <source>One typical use case for this built-in is adjusting input and output values to non-contiguous port layouts. Some examples:</source>
          <target state="translated">이 내장의 일반적인 사용 사례는 입력 및 출력 값을 비 연속 포트 레이아웃으로 조정하는 것입니다. 몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="cdc3d4316f37caecddf4da207a8a333a1f06f1e6" translate="yes" xml:space="preserve">
          <source>One way of using these constants is in initializing a static array that serves as a jump table:</source>
          <target state="translated">이러한 상수를 사용하는 한 가지 방법은 점프 테이블 역할을하는 정적 배열을 초기화하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="4abf320685928f7114b2a671b0c8e5d78f023c66" translate="yes" xml:space="preserve">
          <source>One way to solve this problem is to compile your entire program with GCC. Another solution is to modify the function that is compiled with Sun CC to copy the argument into a local variable; local variables are always properly aligned. A third solution is to modify the function that uses the pointer to dereference it via the following function &lt;code&gt;access_double&lt;/code&gt; instead of directly with &amp;lsquo;</source>
          <target state="translated">이 문제를 해결하는 한 가지 방법은 전체 프로그램을 GCC로 컴파일하는 것입니다. 또 다른 해결책은 Sun CC로 컴파일 된 함수를 수정하여 인수를 로컬 변수에 복사하는 것입니다. 지역 변수는 항상 올바르게 정렬됩니다. 세 번째 해결책은 포인터를 사용하여 '를 직접 사용하는 대신 다음 함수 &lt;code&gt;access_double&lt;/code&gt; 을 통해 역 참조하는 함수를 수정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="11c60f443d3a43430190f5782a8be8122d41c489" translate="yes" xml:space="preserve">
          <source>One workaround is to insert cache barrier instructions before every memory access that might be speculatively executed and that might have side effects even if aborted.</source>
          <target state="translated">한 가지 해결 방법은 추론 적으로 실행될 수 있고 중단 된 경우에도 부작용이있을 수있는 모든 메모리 액세스 전에 캐시 장벽 명령어를 삽입하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="46fd9a138136ce012f77c2ad875a236ea7641073" translate="yes" xml:space="preserve">
          <source>One&amp;rsquo;s complement of a 6-bit unsigned integer constant.</source>
          <target state="translated">6 비트 부호없는 정수 상수를 보완합니다.</target>
        </trans-unit>
        <trans-unit id="09ff598dbd1dd52bba3a7ce58edc2ab65caf114c" translate="yes" xml:space="preserve">
          <source>One-bit boolean register</source>
          <target state="translated">1 비트 부울 레지스터</target>
        </trans-unit>
        <trans-unit id="b86152f3b7cb1fd57d0957c837b7a02e1c1edec1" translate="yes" xml:space="preserve">
          <source>Only available if either</source>
          <target state="translated">다음 중 하나에 만 사용 가능</target>
        </trans-unit>
        <trans-unit id="fa0e52cdfb683b064ba9081fec281277ab21b369" translate="yes" xml:space="preserve">
          <source>Only available with</source>
          <target state="translated">다음에서만 사용 가능</target>
        </trans-unit>
        <trans-unit id="d8174cb5b4a5090a1c9f6528e9032514840b01a2" translate="yes" xml:space="preserve">
          <source>Only change the lower 8 bits of the stack pointer.</source>
          <target state="translated">스택 포인터의 하위 8 비트 만 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="fa1093075a5bab803d61da780f973e8e456e21b9" translate="yes" xml:space="preserve">
          <source>Only enable inlining and cloning optimizations, which includes inlining, cloning, interprocedural scalar replacement of aggregates and partial inlining. As a result, when patching a function, all its callers and its clones&amp;rsquo; callers are impacted, therefore need to be patched as well.</source>
          <target state="translated">인라인, 클로닝, 집계의 스칼라 교체 및 부분 인라인을 포함하는 인라인 및 클로닝 최적화 만 활성화하십시오. 결과적으로 함수를 패치 할 때 모든 호출자와 해당 클론의 호출자가 영향을 받으므로 패치해야합니다.</target>
        </trans-unit>
        <trans-unit id="98cdd885ed933d2b0d71761a5e0e3218cffb4c2b" translate="yes" xml:space="preserve">
          <source>Only enable inlining of static functions. As a result, when patching a static function, all its callers are impacted and so need to be patched as well.</source>
          <target state="translated">정적 함수 인라인 만 활성화하십시오. 결과적으로 정적 함수를 패치 할 때 모든 호출자가 영향을 받으므로 패치해야합니다.</target>
        </trans-unit>
        <trans-unit id="a790c727dbde2c9153b76b5c8a491055c1c24680" translate="yes" xml:space="preserve">
          <source>Only generate absolute relocations on word-sized values (i.e. R_ARM_ABS32). This is enabled by default on targets (uClinux, SymbianOS) where the runtime loader imposes this restriction, and when</source>
          <target state="translated">단어 크기 값 (예 : R_ARM_ABS32)에서만 절대 재배치를 생성합니다. 런타임 로더가이 제한을 부과하는 대상 (uClinux, SymbianOS) 및 기본 설정에서 기본적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="69487605cf89b2b25fc2b6052bd8701c5c25ea67" translate="yes" xml:space="preserve">
          <source>Only meaningful in line-wrapping mode. Instructs the diagnostic messages reporter to emit source location information &lt;em&gt;once&lt;/em&gt;; that is, in case the message is too long to fit on a single physical line and has to be wrapped, the source location won&amp;rsquo;t be emitted (as prefix) again, over and over, in subsequent continuation lines. This is the default behavior.</source>
          <target state="translated">줄 바꿈 모드에서만 의미가 있습니다. 진단 메시지 리포터에게 소스 위치 정보를 &lt;em&gt;한 번&lt;/em&gt; 방출하도록 지시합니다 . 즉, 메시지가 단일 실제 회선에 맞추기에는 너무 길어서 랩핑되어야하는 경우, 후속 연속 회선에서 소스 위치가 계속해서 접두사로 방출되지 않습니다. 이것이 기본 동작입니다.</target>
        </trans-unit>
        <trans-unit id="ebd505efc7bd99f753105955cdf89673e5640a71" translate="yes" xml:space="preserve">
          <source>Only meaningful in line-wrapping mode. Instructs the diagnostic messages reporter to emit the same source location information (as prefix) for physical lines that result from the process of breaking a message which is too long to fit on a single line.</source>
          <target state="translated">줄 바꿈 모드에서만 의미가 있습니다. 진단 메시지보고자가 단일 회선에 맞추기에는 너무 긴 메시지를 끊는 프로세스에서 발생하는 실제 회선에 대해 동일한 소스 위치 정보 (접 두부)를 내보내도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="330993f6286aa72148d14226b91455d3ac494a8c" translate="yes" xml:space="preserve">
          <source>Only one precompiled header can be used in a particular compilation.</source>
          <target state="translated">특정 컴파일에는 하나의 사전 컴파일 된 헤더 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c89e84df5b584e830b8d2d2e716a4ce60df935f" translate="yes" xml:space="preserve">
          <source>Only output information about source files with a relative pathname (after source prefix elision). Absolute paths are usually system header files and coverage of any inline functions therein is normally uninteresting.</source>
          <target state="translated">소스 접두어 제거 후 상대 경로 이름을 가진 소스 파일에 대한 정보 만 출력하십시오. 절대 경로는 일반적으로 시스템 헤더 파일이며 그 안에있는 인라인 함수의 범위는 일반적으로 흥미롭지 않습니다.</target>
        </trans-unit>
        <trans-unit id="72274ff34b747c56a57940685e3ffdf10da20513" translate="yes" xml:space="preserve">
          <source>Only print info for hot objects/functions.</source>
          <target state="translated">뜨거운 물체 / 기능에 대한 정보 만 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="8b24ee9bfdf40f46680f47de16c5081b87003895" translate="yes" xml:space="preserve">
          <source>Only use the first 32 general-purpose registers.</source>
          <target state="translated">처음 32 개의 범용 레지스터 만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="338aae9daa260c2c83f7e418040b21c679f46883" translate="yes" xml:space="preserve">
          <source>Only use these options when there are significant benefits from doing so. When you specify these options, the assembler and linker create larger object and executable files and are also slower. These options affect code generation. They prevent optimizations by the compiler and assembler using relative locations inside a translation unit since the locations are unknown until link time. An example of such an optimization is relaxing calls to short call instructions.</source>
          <target state="translated">그렇게하면 상당한 이점이있는 경우에만이 옵션을 사용하십시오. 이러한 옵션을 지정하면 어셈블러 및 링커에서 더 큰 객체 및 실행 파일을 생성하며 속도도 느려집니다. 이 옵션은 코드 생성에 영향을줍니다. 링크 타임까지 위치를 알 수 없기 때문에 변환 단위 내의 상대 위치를 사용하여 컴파일러와 어셈블러에서 최적화를 방지합니다. 이러한 최적화의 예는 짧은 통화 지시에 대한 통화를 완화하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7b26ac27e9054975e1b8c28c749dd8e60046db26" translate="yes" xml:space="preserve">
          <source>Only valid if the &amp;lsquo;</source>
          <target state="translated">'</target>
        </trans-unit>
        <trans-unit id="a24c971c70af3e6d67c9922de68be68fd14aa925" translate="yes" xml:space="preserve">
          <source>Only valid with</source>
          <target state="translated">로만 유효</target>
        </trans-unit>
        <trans-unit id="4f3ef120810b89335683d19761269a1b29d439b1" translate="yes" xml:space="preserve">
          <source>OpenRISC&amp;mdash;</source>
          <target state="translated">OpenRISC&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="ff04060b9cdf50d21da510eb2aee82a293b79942" translate="yes" xml:space="preserve">
          <source>Operand</source>
          <target state="translated">Operand</target>
        </trans-unit>
        <trans-unit id="96c8142487d93ded6eed966e1c94866edb7f6ce0" translate="yes" xml:space="preserve">
          <source>Operands are separated by commas. Each operand has this format:</source>
          <target state="translated">피연산자는 쉼표로 구분됩니다. 각 피연산자는 다음 형식을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="67c4124aaeb7fa5b37a4c13183fee8472dbd34a2" translate="yes" xml:space="preserve">
          <source>Operands that satisfy &amp;rsquo;m&amp;rsquo; when -mpcrel is in effect</source>
          <target state="translated">-mpcrel이 적용될 때 'm'을 만족시키는 피연산자</target>
        </trans-unit>
        <trans-unit id="f223672699f4c0fd304046c8f55c3a8a822eafba" translate="yes" xml:space="preserve">
          <source>Operands that satisfy &amp;rsquo;s&amp;rsquo; when -mpcrel is not in effect</source>
          <target state="translated">-mpcrel이 유효하지 않은 경우 's'를 만족시키는 피연산자</target>
        </trans-unit>
        <trans-unit id="a6a1e6ee77f32bbfca88fdb0ed00cdafe059d583" translate="yes" xml:space="preserve">
          <source>Operands using the &amp;lsquo;</source>
          <target state="translated">'를 사용하여 피연산자</target>
        </trans-unit>
        <trans-unit id="dd2427f9810f7d01de4920a5fbaf944c75db0f9b" translate="yes" xml:space="preserve">
          <source>Optimization Options</source>
          <target state="translated">최적화 옵션</target>
        </trans-unit>
        <trans-unit id="cab9c4fb94627ad4002c4f07a4e254f1d83181e5" translate="yes" xml:space="preserve">
          <source>Optimize debugging experience.</source>
          <target state="translated">디버깅 경험을 최적화하십시오.</target>
        </trans-unit>
        <trans-unit id="f6711b309c1e96e21f6e3fd3f0f4cca8b00ad887" translate="yes" xml:space="preserve">
          <source>Optimize even more. GCC performs nearly all supported optimizations that do not involve a space-speed tradeoff. As compared to</source>
          <target state="translated">훨씬 더 최적화하십시오. GCC는 시공간 절충이 필요없는 거의 모든 지원되는 최적화를 수행합니다. 비교하자면</target>
        </trans-unit>
        <trans-unit id="115cffa4f350df63881ca8bb33b21ff035557045" translate="yes" xml:space="preserve">
          <source>Optimize for &lt;var&gt;arch&lt;/var&gt;. Among other things, this option controls the way instructions are scheduled, and the perceived cost of arithmetic operations. The list of &lt;var&gt;arch&lt;/var&gt; values is the same as for</source>
          <target state="translated">&lt;var&gt;arch&lt;/var&gt; 위해 최적화하십시오 . 무엇보다도이 옵션은 명령이 예약되는 방식과 인식 된 산술 연산 비용을 제어합니다. &lt;var&gt;arch&lt;/var&gt; 값 목록 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="00bcbcf49330fd5cd07800c1cc402ad50059a9a8" translate="yes" xml:space="preserve">
          <source>Optimize for size.</source>
          <target state="translated">크기를 최적화하십시오.</target>
        </trans-unit>
        <trans-unit id="b1f0ff5d58183a1211bf6345ec617611e6079a6c" translate="yes" xml:space="preserve">
          <source>Optimize sibling and tail recursive calls.</source>
          <target state="translated">형제 및 테일 재귀 호출을 최적화하십시오.</target>
        </trans-unit>
        <trans-unit id="82acb86d67d8f7c979237a3f9d5995187b58bb34" translate="yes" xml:space="preserve">
          <source>Optimize the output for the given processor, specified by microarchitecture name. Permissible values for this option are: &amp;lsquo;</source>
          <target state="translated">마이크로 아키텍처 이름으로 지정된 주어진 프로세서에 대한 출력을 최적화하십시오. 이 옵션에 허용되는 값은 '</target>
        </trans-unit>
        <trans-unit id="beede52c02c3ccdc57d067263b0592c5c5870f64" translate="yes" xml:space="preserve">
          <source>Optimize the prologue of variadic argument functions with respect to usage of those arguments.</source>
          <target state="translated">이러한 인수의 사용과 관련하여 가변성 인수 함수의 프롤로그를 최적화하십시오.</target>
        </trans-unit>
        <trans-unit id="8091cf8a7f45d51dd71bbe1a181b77efee3b92fa" translate="yes" xml:space="preserve">
          <source>Optimize various standard C string functions (e.g. &lt;code&gt;strlen&lt;/code&gt;, &lt;code&gt;strchr&lt;/code&gt; or &lt;code&gt;strcpy&lt;/code&gt;) and their &lt;code&gt;_FORTIFY_SOURCE&lt;/code&gt; counterparts into faster alternatives.</source>
          <target state="translated">다양한 표준 C 문자열 함수 (예 : &lt;code&gt;strlen&lt;/code&gt; , &lt;code&gt;strchr&lt;/code&gt; 또는 &lt;code&gt;strcpy&lt;/code&gt; )를 최적화 하고 &lt;code&gt;_FORTIFY_SOURCE&lt;/code&gt; 대응 기능을 더 빠른 대안으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="313c197a1bf79c8cb464f9108769008bb606d983" translate="yes" xml:space="preserve">
          <source>Optimize yet more.</source>
          <target state="translated">더 최적화하십시오.</target>
        </trans-unit>
        <trans-unit id="913d9fd2399cdf6e86c3e975d0cc5dad07465ec2" translate="yes" xml:space="preserve">
          <source>Optimize. Optimizing compilation takes somewhat more time, and a lot more memory for a large function.</source>
          <target state="translated">최적화하십시오. 컴파일 최적화에는 시간이 좀 더 걸리고 큰 기능을 위해서는 더 많은 메모리가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="e31d972229de381b461860014dd710856361917a" translate="yes" xml:space="preserve">
          <source>Option</source>
          <target state="translated">Option</target>
        </trans-unit>
        <trans-unit id="2c7ca22e5600046b144f3d24624f25c564332dee" translate="yes" xml:space="preserve">
          <source>Option Index</source>
          <target state="translated">옵션 인덱스</target>
        </trans-unit>
        <trans-unit id="30d4712df73ef1c0d4db51f2dbb5607ea375fe4b" translate="yes" xml:space="preserve">
          <source>Optional Return Value Pointer</source>
          <target state="translated">선택적 반환 값 포인터</target>
        </trans-unit>
        <trans-unit id="c12455d26a0da53c0d68029c9bf0819232e1f305" translate="yes" xml:space="preserve">
          <source>Options in &lt;var&gt;file&lt;/var&gt; are separated by whitespace. A whitespace character may be included in an option by surrounding the entire option in either single or double quotes. Any character (including a backslash) may be included by prefixing the character to be included with a backslash. The &lt;var&gt;file&lt;/var&gt; may itself contain additional @&lt;var&gt;file&lt;/var&gt; options; any such options will be processed recursively.</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt; 옵션은 공백으로 구분됩니다. 전체 옵션을 작은 따옴표 나 큰 따옴표로 묶어 공백 문자를 옵션에 포함시킬 수 있습니다. 백 슬래시를 포함 할 문자를 접두어로 붙여서 모든 문자 (백 슬래시 포함)를 포함 할 수 있습니다. &lt;var&gt;file&lt;/var&gt; 자체가 추가 @를 포함 할 수 있습니다 &lt;var&gt;file&lt;/var&gt; 옵션을; 이러한 옵션은 재귀 적으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="4660151a0ebf47062b565d717689e53cf9ce9103" translate="yes" xml:space="preserve">
          <source>Options of the form</source>
          <target state="translated">양식 옵션</target>
        </trans-unit>
        <trans-unit id="23bd069950c6d99802ae19186b5b3c8a35033589" translate="yes" xml:space="preserve">
          <source>Original Intel i386 CPU.</source>
          <target state="translated">원래 Intel i386 CPU.</target>
        </trans-unit>
        <trans-unit id="1a9a54bb04ec8317f6fd027b56dada4bf5eca84f" translate="yes" xml:space="preserve">
          <source>Os</source>
          <target state="translated">Os</target>
        </trans-unit>
        <trans-unit id="18bee9973a249c2e29e697cfeb7c675bf6ae3fa7" translate="yes" xml:space="preserve">
          <source>Other Alpha compilers provide the equivalent options called</source>
          <target state="translated">다른 알파 컴파일러는</target>
        </trans-unit>
        <trans-unit id="cd2bf473aa5d5250266aacf77c308456d1faabee" translate="yes" xml:space="preserve">
          <source>Other C compilers won&amp;rsquo;t accept these alternative keywords; if you want to compile with another compiler, you can define the alternate keywords as macros to replace them with the customary keywords. It looks like this:</source>
          <target state="translated">다른 C 컴파일러는 이러한 대체 키워드를 허용하지 않습니다. 다른 컴파일러로 컴파일하려면 대체 키워드를 매크로로 정의하여 일반 키워드로 대체 할 수 있습니다. 다음과 같이 보입니다 :</target>
        </trans-unit>
        <trans-unit id="0ffe248f8b25bb61e4c3f0c71863b1ea1b623bad" translate="yes" xml:space="preserve">
          <source>Other C++ compilers may not correctly implement the standard behavior. As a result, when you switch to &lt;code&gt;g++&lt;/code&gt; from one of these compilers, you may discover that a program that appeared to work correctly in fact does not conform to the standard: &lt;code&gt;g++&lt;/code&gt; reports as undefined symbols any static data members that lack definitions.</source>
          <target state="translated">다른 C ++ 컴파일러는 표준 동작을 올바르게 구현하지 않을 수 있습니다. 결과적 으로 이러한 컴파일러 중 하나에서 &lt;code&gt;g++&lt;/code&gt; 로 전환하면 실제로 올바르게 작동하는 것으로 보이는 프로그램이 표준을 따르지 않는 것을 발견 할 수 있습니다. &lt;code&gt;g++&lt;/code&gt; 는 정의가없는 정적 데이터 멤버를 정의되지 않은 기호로보고합니다.</target>
        </trans-unit>
        <trans-unit id="f7754320d0468c70e98bda0da0fe360c850f2c18" translate="yes" xml:space="preserve">
          <source>Other VR4120 errata require a NOP to be inserted between certain pairs of instructions. These errata are handled by the assembler, not by GCC itself.</source>
          <target state="translated">다른 VR4120 정오표에는 특정 명령 쌍 사이에 NOP를 삽입해야합니다. 이 정오표는 GCC 자체가 아니라 어셈블러에서 처리합니다.</target>
        </trans-unit>
        <trans-unit id="8c84374a07e7982abd1eda236f79d01355c7610a" translate="yes" xml:space="preserve">
          <source>Other attributes are defined for functions (see &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;), labels (see &lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;Label Attributes&lt;/a&gt;), enumerators (see &lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;Enumerator Attributes&lt;/a&gt;), statements (see &lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;Statement Attributes&lt;/a&gt;), and for variables (see &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;).</source>
          <target state="translated">다른 속성은 함수 ( &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;함수 속성&lt;/a&gt; 참조 ), 레이블 ( &lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;레이블 속성&lt;/a&gt; 참조 ), 열거 자 ( &lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;열거 속성&lt;/a&gt; 참조 ), 명령문 ( &lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;문 속성&lt;/a&gt; 참조 ) 및 변수 ( &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;변수 속성&lt;/a&gt; 참조 )에 대해 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="c2a10075dec0d365de937669196a9657d9df8590" translate="yes" xml:space="preserve">
          <source>Other built-in functions.</source>
          <target state="translated">기타 내장 기능</target>
        </trans-unit>
        <trans-unit id="ece657a55e4e8a32408fa84921a8230117870046" translate="yes" xml:space="preserve">
          <source>Other helpers:</source>
          <target state="translated">기타 도우미 :</target>
        </trans-unit>
        <trans-unit id="71f741ac380c3a470196d38432e10beb772eddbf" translate="yes" xml:space="preserve">
          <source>Other integer types, such as &lt;code&gt;long int&lt;/code&gt;, and enumerated types are permitted even in strictly conforming mode.</source>
          <target state="translated">&lt;code&gt;long int&lt;/code&gt; 및 열거 유형과 같은 다른 정수 유형 은 엄격하게 준수하는 모드에서도 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="9b6d809c6085c6515fee8105cda39c6f0c8299d6" translate="yes" xml:space="preserve">
          <source>Other letters can be defined in machine-dependent fashion to stand for particular classes of registers or other arbitrary operand types. &amp;lsquo;</source>
          <target state="translated">다른 문자는 특정 클래스의 레지스터 또는 기타 임의의 피연산자 유형을 나타 내기 위해 기계 종속 방식으로 정의 될 수 있습니다. '</target>
        </trans-unit>
        <trans-unit id="31e826484120507f81d7b01e00ba111ce50563d4" translate="yes" xml:space="preserve">
          <source>Other letters in the range &amp;lsquo;</source>
          <target state="translated">'범위 내의 다른 문자</target>
        </trans-unit>
        <trans-unit id="79d2df03f3d88bfc6b34208de56c0d8f69fae24c" translate="yes" xml:space="preserve">
          <source>Other options are passed on to one or more stages of processing. Some options control the preprocessor and others the compiler itself. Yet other options control the assembler and linker; most of these are not documented here, since you rarely need to use any of them.</source>
          <target state="translated">다른 옵션은 하나 이상의 처리 단계로 넘어갑니다. 일부 옵션은 전처리기를 제어하고 다른 옵션은 컴파일러 자체를 제어합니다. 또 다른 옵션은 어셈블러와 링커를 제어합니다. 거의 사용하지 않아도되므로 대부분 여기에 설명되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="58690e93570c04719b58436037bbfe7e9e889794" translate="yes" xml:space="preserve">
          <source>Other options such as</source>
          <target state="translated">같은 다른 옵션</target>
        </trans-unit>
        <trans-unit id="b54d8cbfcf04d8c6ef55524abdd897e953dd52de" translate="yes" xml:space="preserve">
          <source>Other prefixes specified with</source>
          <target state="translated">로 지정된 다른 접두사</target>
        </trans-unit>
        <trans-unit id="12651a5c2964110c993acc911324809845963ccd" translate="yes" xml:space="preserve">
          <source>Otherwise, &lt;code&gt;false&lt;/code&gt; is returned and memory is affected according to &lt;var&gt;failure_memorder&lt;/var&gt;. This memory order cannot be &lt;code&gt;__ATOMIC_RELEASE&lt;/code&gt; nor &lt;code&gt;__ATOMIC_ACQ_REL&lt;/code&gt;. It also cannot be a stronger order than that specified by &lt;var&gt;success_memorder&lt;/var&gt;.</source>
          <target state="translated">그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 가 반환되고 &lt;var&gt;failure_memorder&lt;/var&gt; 에 따라 메모리에 영향을 줍니다 . 이 메모리 순서는 &lt;code&gt;__ATOMIC_RELEASE&lt;/code&gt; 또는 &lt;code&gt;__ATOMIC_ACQ_REL&lt;/code&gt; 일 수 없습니다 . &lt;var&gt;success_memorder&lt;/var&gt; 로 지정된 것보다 강한 순서 일 수도 없습니다 .</target>
        </trans-unit>
        <trans-unit id="0163f25dca25dd9eb232ac96989846b2be8a2890" translate="yes" xml:space="preserve">
          <source>Otherwise, an attribute specifier appears as part of a declaration, counting declarations of unnamed parameters and type names, and relates to that declaration (which may be nested in another declaration, for example in the case of a parameter declaration), or to a particular declarator within a declaration. Where an attribute specifier is applied to a parameter declared as a function or an array, it should apply to the function or array rather than the pointer to which the parameter is implicitly converted, but this is not yet correctly implemented.</source>
          <target state="translated">그렇지 않으면, 속성 지정자는 선언되지 않은 매개 변수 및 유형 이름의 선언을 세는 선언의 일부로 나타나며 해당 선언 (예 : 매개 변수 선언의 경우 다른 선언에 중첩 될 수 있음) 또는 특정 선언 내의 선언자. 속성 지정자가 함수 또는 배열로 선언 된 매개 변수에 적용되는 경우 매개 변수가 암시 적으로 변환되는 포인터가 아니라 함수 또는 배열에 적용되어야하지만 아직 제대로 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="9c5c46d604645721e578d5c70ebb88f027aaf128" translate="yes" xml:space="preserve">
          <source>Output &amp;lsquo;</source>
          <target state="translated">출력 '</target>
        </trans-unit>
        <trans-unit id="647dcf3ef174bc80ea2e9689a611bd97a6a704cd" translate="yes" xml:space="preserve">
          <source>Output assembly instructions using selected &lt;var&gt;dialect&lt;/var&gt;. Also affects which dialect is used for basic &lt;code&gt;asm&lt;/code&gt; (see &lt;a href=&quot;basic-asm#Basic-Asm&quot;&gt;Basic Asm&lt;/a&gt;) and extended &lt;code&gt;asm&lt;/code&gt; (see &lt;a href=&quot;extended-asm#Extended-Asm&quot;&gt;Extended Asm&lt;/a&gt;). Supported choices (in dialect order) are &amp;lsquo;</source>
          <target state="translated">선택한 &lt;var&gt;dialect&lt;/var&gt; 사용하여 출력 조립 지침 . 또한 기본 &lt;code&gt;asm&lt;/code&gt; ( &lt;a href=&quot;basic-asm#Basic-Asm&quot;&gt;기본 Asm&lt;/a&gt; 참조 ) 및 확장 &lt;code&gt;asm&lt;/code&gt; ( &lt;a href=&quot;extended-asm#Extended-Asm&quot;&gt;확장 Asm&lt;/a&gt; 참조 )에 사용되는 방언에 영향을줍니다 . 지원되는 선택 (방언 순서)은 '</target>
        </trans-unit>
        <trans-unit id="f8b5c88cee0a083c4b1b7974adc28656d2681e85" translate="yes" xml:space="preserve">
          <source>Output code for G-format floating-point numbers instead of D-format.</source>
          <target state="translated">D 형식 대신 G 형식 부동 소수점 숫자의 출력 코드입니다.</target>
        </trans-unit>
        <trans-unit id="e560ad077bfca12ce7d694879e9c015007ae41a0" translate="yes" xml:space="preserve">
          <source>Output constraints must begin with either &amp;lsquo;</source>
          <target state="translated">출력 제한 조건은 '</target>
        </trans-unit>
        <trans-unit id="180883c60047df12608a1941cecf8662e8d97968" translate="yes" xml:space="preserve">
          <source>Output gcov file in an easy-to-parse JSON intermediate format which does not require source code for generation. The JSON file is compressed with gzip compression algorithm and the files have</source>
          <target state="translated">생성하기 위해 소스 코드가 필요하지 않은 구문 분석하기 쉬운 JSON 중간 형식으로 gcov 파일을 출력하십시오. JSON 파일은 gzip 압축 알고리즘으로 압축되며 파일은</target>
        </trans-unit>
        <trans-unit id="9b6fcda59898207a429e1ef091692b9398444b1f" translate="yes" xml:space="preserve">
          <source>Output operand expressions must be lvalues. The compiler cannot check whether the operands have data types that are reasonable for the instruction being executed. For output expressions that are not directly addressable (for example a bit-field), the constraint must allow a register. In that case, GCC uses the register as the output of the &lt;code&gt;asm&lt;/code&gt;, and then stores that register into the output.</source>
          <target state="translated">출력 피연산자 표현식은 lvalue 여야합니다. 컴파일러는 피연산자에 실행중인 명령에 적합한 데이터 유형이 있는지 확인할 수 없습니다. 직접 주소 지정이 불가능한 출력 표현식 (예 : 비트 필드)의 경우 제한 조건이 레지스터를 허용해야합니다. 이 경우 GCC는 레지스터를 &lt;code&gt;asm&lt;/code&gt; 의 출력으로 사용하고 해당 레지스터를 출력에 저장합니다.</target>
        </trans-unit>
        <trans-unit id="316859616622aa738df7e68ec92a5bb090fb360c" translate="yes" xml:space="preserve">
          <source>Output operands may not be &amp;ldquo;inserted&amp;rdquo; between existing stack registers. Since no 387 opcode uses a read/write operand, all output operands are dead before the &lt;code&gt;asm&lt;/code&gt;, and are pushed by the &lt;code&gt;asm&lt;/code&gt;. It makes no sense to push anywhere but the top of the reg-stack.</source>
          <target state="translated">기존 스택 레지스터간에 출력 피연산자가 &quot;삽입&quot;되지 않을 수 있습니다. 더 387는 오피 코드 읽기 / 쓰기 연산을 사용하지 않고 있으므로, 모든 출력은 피연산자 전에 죽은 &lt;code&gt;asm&lt;/code&gt; 및 의해 밀려 &lt;code&gt;asm&lt;/code&gt; . reg-stack의 상단을 제외한 다른 곳으로 밀어 넣는 것은 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="43f24935d9221797dfcb78b34d6cf08d867d6284" translate="yes" xml:space="preserve">
          <source>Output operands must specifically indicate which register an output appears in after an &lt;code&gt;asm&lt;/code&gt;. &amp;lsquo;</source>
          <target state="translated">출력 피연산자는 출력이 &lt;code&gt;asm&lt;/code&gt; 뒤에 나타나는 레지스터를 구체적으로 나타내야합니다 . '</target>
        </trans-unit>
        <trans-unit id="faed737fa40fe25af4473d1b6bcfd0d0b292b68b" translate="yes" xml:space="preserve">
          <source>Output operands must start at the top of the reg-stack: output operands may not &amp;ldquo;skip&amp;rdquo; a register.</source>
          <target state="translated">출력 피연산자는 reg-stack의 맨 위에서 시작해야합니다. 출력 피연산자는 레지스터를 &quot;건너 뛰지&quot;않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8b51102b411c12b6e0f93eb391fa91ba24693de" translate="yes" xml:space="preserve">
          <source>Output summaries for each function in addition to the file level summary.</source>
          <target state="translated">파일 레벨 요약 외에 각 기능에 대한 출력 요약.</target>
        </trans-unit>
        <trans-unit id="2f6f31ff885b55e9edb44a9bbaf83bcf540cfa80" translate="yes" xml:space="preserve">
          <source>Output the accumulated assembler options specified by</source>
          <target state="translated">에 의해 지정된 누적 어셈블러 옵션을 출력</target>
        </trans-unit>
        <trans-unit id="bca339912e193031f5941578cba2e8013cdc4fbe" translate="yes" xml:space="preserve">
          <source>Output the accumulated linker options specified by</source>
          <target state="translated">에 의해 지정된 누적 링커 옵션을 출력</target>
        </trans-unit>
        <trans-unit id="abd07145d91464d8949250e737d08ee71cd3be75" translate="yes" xml:space="preserve">
          <source>Output the accumulated preprocessor options specified by</source>
          <target state="translated">에 의해 지정된 누적 전 처리기 옵션을 출력합니다.</target>
        </trans-unit>
        <trans-unit id="b0560621f7532768e8148f5f9549c378f9566ea1" translate="yes" xml:space="preserve">
          <source>Output to standard output instead of output files.</source>
          <target state="translated">출력 파일 대신 표준 출력으로 출력합니다.</target>
        </trans-unit>
        <trans-unit id="0ec497bb07e2cf136e8af2890004bae91d0a14be" translate="yes" xml:space="preserve">
          <source>Output to the given filename prototyped declarations for all functions declared and/or defined in a translation unit, including those in header files. This option is silently ignored in any language other than C.</source>
          <target state="translated">헤더 파일의 함수를 포함하여 변환 단위로 선언 및 / 또는 정의 된 모든 함수에 대해 지정된 파일 이름의 프로토 타입 선언으로 출력합니다. 이 옵션은 C 이외의 다른 언어에서는 자동으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="62fca7a249d9dca7d004d8f4915abc2b5e965646" translate="yes" xml:space="preserve">
          <source>Outputs &amp;lsquo;</source>
          <target state="translated">출력 '</target>
        </trans-unit>
        <trans-unit id="13d5c086d06fc973e45c927d40c8e059a1643032" translate="yes" xml:space="preserve">
          <source>Outputs a number that is unique to each instance of the &lt;code&gt;asm&lt;/code&gt; statement in the entire compilation. This option is useful when creating local labels and referring to them multiple times in a single template that generates multiple assembler instructions.</source>
          <target state="translated">전체 컴파일에서 &lt;code&gt;asm&lt;/code&gt; 문의 각 인스턴스에 고유 한 숫자를 출력합니다 . 이 옵션은 로컬 레이블을 만들고 여러 어셈블러 명령어를 생성하는 단일 템플릿에서 여러 번 참조 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b7054dde1d20d86e88a5b1e9f1914cd2a35614b4" translate="yes" xml:space="preserve">
          <source>Outputs a single &amp;lsquo;</source>
          <target state="translated">하나의 '</target>
        </trans-unit>
        <trans-unit id="0dee1166c5edc6ac11a34fc79bdb2cb27916d9db" translate="yes" xml:space="preserve">
          <source>Outside strict ISO C mode (</source>
          <target state="translated">엄격한 ISO C 모드 외부 (</target>
        </trans-unit>
        <trans-unit id="dd7bd1ab4e4204054540331b82bdd3051fd1f8f8" translate="yes" xml:space="preserve">
          <source>Overall Options</source>
          <target state="translated">전체 옵션</target>
        </trans-unit>
        <trans-unit id="b4cd9a287c6914a99205f05078ac2e480bd2c7a2" translate="yes" xml:space="preserve">
          <source>Override the defaults for &lt;code&gt;bool&lt;/code&gt; so that &lt;code&gt;sizeof(bool)==1&lt;/code&gt;. By default &lt;code&gt;sizeof(bool)&lt;/code&gt; is &lt;code&gt;4&lt;/code&gt; when compiling for Darwin/PowerPC and &lt;code&gt;1&lt;/code&gt; when compiling for Darwin/x86, so this option has no effect on x86.</source>
          <target state="translated">&lt;code&gt;sizeof(bool)==1&lt;/code&gt; 되도록 &lt;code&gt;bool&lt;/code&gt; 의 기본값을 대체하십시오 . 기본적으로 &lt;code&gt;sizeof(bool)&lt;/code&gt; 은 Darwin / PowerPC를 컴파일 할 때는 &lt;code&gt;4&lt;/code&gt; 이고 Darwin / x86을 컴파일 할 때는 &lt;code&gt;1&lt;/code&gt; 이므로 x86에는 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a199208b37cd1f5b9a0a8191fd588411de91c2f1" translate="yes" xml:space="preserve">
          <source>Override the internal decision heuristic for the particular algorithm to use for inlining string operations. The allowed values for &lt;var&gt;alg&lt;/var&gt; are:</source>
          <target state="translated">문자열 연산을 인라인하는 데 사용할 특정 알고리즘에 대한 내부 결정 휴리스틱을 재정의합니다. &lt;var&gt;alg&lt;/var&gt; 에 허용되는 값은 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="725dd7b59f06dae5a8f87fd7ac1c6ed71f821187" translate="yes" xml:space="preserve">
          <source>Override the internal decision heuristic to decide if &lt;code&gt;__builtin_memcpy&lt;/code&gt; should be inlined and what inline algorithm to use when the expected size of the copy operation is known. &lt;var&gt;strategy&lt;/var&gt; is a comma-separated list of &lt;var&gt;alg&lt;/var&gt;:&lt;var&gt;max_size&lt;/var&gt;:&lt;var&gt;dest_align&lt;/var&gt; triplets. &lt;var&gt;alg&lt;/var&gt; is specified in</source>
          <target state="translated">&lt;code&gt;__builtin_memcpy&lt;/code&gt; 를 인라인 해야하는지 여부 와 예상되는 복사 작업 크기를 알 때 사용할 인라인 알고리즘 을 결정하기 위해 내부 결정 휴리스틱을 재정의합니다 . &lt;var&gt;strategy&lt;/var&gt; 은 쉼표로 구분 된 &lt;var&gt;alg&lt;/var&gt; : &lt;var&gt;max_size&lt;/var&gt; : &lt;var&gt;dest_align&lt;/var&gt; triplets의 목록입니다 . &lt;var&gt;alg&lt;/var&gt; 는</target>
        </trans-unit>
        <trans-unit id="9b46c3db03a238d3f5a14ace1b604afe4e45f0cd" translate="yes" xml:space="preserve">
          <source>Override the underlying type for &lt;code&gt;wchar_t&lt;/code&gt; to be &lt;code&gt;short
unsigned int&lt;/code&gt; instead of the default for the target. This option is useful for building programs to run under WINE.</source>
          <target state="translated">에 대한 기본 유형을 재정 &lt;code&gt;wchar_t&lt;/code&gt; 로 &lt;code&gt;short unsigned int&lt;/code&gt; 대신 대상의 기본. 이 옵션은 WINE에서 실행할 프로그램을 빌드하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="48df9e72f6c8bb00c7da9fa106f8a794bf0ae66b" translate="yes" xml:space="preserve">
          <source>Override tuning decisions made by the back-end in response to a</source>
          <target state="translated">백엔드가 수행 한 튜닝 결정을</target>
        </trans-unit>
        <trans-unit id="e7b14d3050ddec57bd832691acdae4f4799a4d96" translate="yes" xml:space="preserve">
          <source>Overrides the command-line option &lt;code&gt;-memregs=&lt;/code&gt; for the current file. Use with care! This pragma must be before any function in the file, and mixing different memregs values in different objects may make them incompatible. This pragma is useful when a performance-critical function uses a memreg for temporary values, as it may allow you to reduce the number of memregs used.</source>
          <target state="translated">현재 파일에 대한 명령 행 옵션 &lt;code&gt;-memregs=&lt;/code&gt; 를 대체 합니다. 조심해서 사용하십시오! 이 pragma는 파일에서 기능을 수행하기 전에 이루어져야하며 다른 memregs 값을 다른 객체에 혼합하면 호환되지 않을 수 있습니다. 이 pragma는 성능에 중요한 함수가 임시 값으로 memreg를 사용하는 경우 유용합니다. 사용되는 memreg 수를 줄일 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="55a8f7943bb312b706050a92052877ddd19cd1fc" translate="yes" xml:space="preserve">
          <source>Overrides the command-line option &lt;code&gt;-mio-volatile&lt;/code&gt; for the current file. Note that for compatibility with future GCC releases, this option should only be used once before any &lt;code&gt;io&lt;/code&gt; variables in each file.</source>
          <target state="translated">현재 파일에 대한 명령 행 옵션 &lt;code&gt;-mio-volatile&lt;/code&gt; 을 대체 합니다. 향후 GCC 릴리스와의 호환성을 위해이 옵션은 각 파일의 &lt;code&gt;io&lt;/code&gt; 변수 전에 한 번만 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="511993d3c99719e38a6779073019dacd7178ddb9" translate="yes" xml:space="preserve">
          <source>P</source>
          <target state="translated">P</target>
        </trans-unit>
        <trans-unit id="80fce3cd5d10f70e9287dc65ad351b4cf54cdde0" translate="yes" xml:space="preserve">
          <source>P register</source>
          <target state="translated">P 레지스터</target>
        </trans-unit>
        <trans-unit id="a1fd3d9945606c835489fdf8c9492b256385656d" translate="yes" xml:space="preserve">
          <source>P+</source>
          <target state="translated">P+</target>
        </trans-unit>
        <trans-unit id="76803f0adcbaf98d2e1e19d699c318fa770240a3" translate="yes" xml:space="preserve">
          <source>P-</source>
          <target state="translated">P-</target>
        </trans-unit>
        <trans-unit id="2b16716bc26fa1b19f59589aec2ebef33f5db5d7" translate="yes" xml:space="preserve">
          <source>PCC allows typedef names to be used as function parameters.</source>
          <target state="translated">PCC에서는 typedef 이름을 함수 매개 변수로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c246c3028d26fbb81d1a1f15dafa0622e6684f4e" translate="yes" xml:space="preserve">
          <source>PCC allows whitespace in the middle of compound assignment operators such as &amp;lsquo;</source>
          <target state="translated">PCC는 '와 같은 복합 할당 연산자 중간에 공백을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="0a6e19866b6bb2535a3f2c2dd0776aefd4accf5d" translate="yes" xml:space="preserve">
          <source>PCLMUL instructions.</source>
          <target state="translated">PCLMUL 지침.</target>
        </trans-unit>
        <trans-unit id="6f863e0fedbf92ef4aea9ea322ccc2a547325ef5" translate="yes" xml:space="preserve">
          <source>PDP-11&amp;mdash;</source>
          <target state="translated">PDP-11&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="8c50d8866e4321b0ad859637afa10d6ead05148c" translate="yes" xml:space="preserve">
          <source>POPCNT instruction.</source>
          <target state="translated">POPCNT 명령.</target>
        </trans-unit>
        <trans-unit id="3ebc8ebc50e3a46fda8970768cc6e859e914444f" translate="yes" xml:space="preserve">
          <source>PRU&amp;mdash;</source>
          <target state="translated">PRU&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="e2d341dab357c92fea1cc61d3e72cb6281d41c97" translate="yes" xml:space="preserve">
          <source>PTRDIFF_MAX</source>
          <target state="translated">PTRDIFF_MAX</target>
        </trans-unit>
        <trans-unit id="7ec74130044a66b80c889b01a82126dc008750ff" translate="yes" xml:space="preserve">
          <source>Pack VLIW instructions.</source>
          <target state="translated">VLIW 지침을 포장하십시오.</target>
        </trans-unit>
        <trans-unit id="dd44725ed2025ff2e1a97e1f2348c9d1ca8f2c1f" translate="yes" xml:space="preserve">
          <source>Pad with NOPs any dispatch group that has vacant issue slots, according to the scheduler&amp;rsquo;s grouping.</source>
          <target state="translated">스케줄러의 그룹화에 따라 빈 문제 슬롯이있는 모든 디스패치 그룹에 NOP를 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="2372cf312ccb9c8b03aea17e3c79e0a1982f2394" translate="yes" xml:space="preserve">
          <source>Pair lower lower (&lt;code&gt;pll.ps&lt;/code&gt;).</source>
          <target state="translated">더 낮은 쌍 ( &lt;code&gt;pll.ps&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f740b666193926024898bc0d930212a406bee8c8" translate="yes" xml:space="preserve">
          <source>Pair lower upper (&lt;code&gt;plu.ps&lt;/code&gt;).</source>
          <target state="translated">하단 상단 쌍 ( &lt;code&gt;plu.ps&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9eedbb6f660ceda1616660d44dce629298a3b655" translate="yes" xml:space="preserve">
          <source>Pair upper lower (&lt;code&gt;pul.ps&lt;/code&gt;).</source>
          <target state="translated">페어 상하 ( &lt;code&gt;pul.ps&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5e0770dcfd7cae26e45306dd9f097f8dbb0edbc8" translate="yes" xml:space="preserve">
          <source>Pair upper upper (&lt;code&gt;puu.ps&lt;/code&gt;).</source>
          <target state="translated">상단 상단 쌍 ( &lt;code&gt;puu.ps&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ac1dfe5c81f3c8f3e57c17faae475d9260a62249" translate="yes" xml:space="preserve">
          <source>Parallelize loops, i.e., split their iteration space to run in n threads. This is only possible for loops whose iterations are independent and can be arbitrarily reordered. The optimization is only profitable on multiprocessor machines, for loops that are CPU-intensive, rather than constrained e.g. by memory bandwidth. This option implies</source>
          <target state="translated">루프를 병렬화합니다. 즉, n 개의 스레드에서 실행되도록 반복 공간을 분할합니다. 이것은 반복이 독립적이고 임의로 재정렬 될 수있는 루프에만 가능합니다. 최적화는 예를 들어 메모리 대역폭에 의해 제한되지 않고 CPU를 많이 사용하는 루프에 대해 다중 프로세서 시스템에서만 수익성이 있습니다. 이 옵션은</target>
        </trans-unit>
        <trans-unit id="a975eea30db9fa05003e3b5097688bd49ec7e01b" translate="yes" xml:space="preserve">
          <source>Parameters</source>
          <target state="translated">Parameters</target>
        </trans-unit>
        <trans-unit id="00310a3d64efc1d0ab28741454559ddf52284d4c" translate="yes" xml:space="preserve">
          <source>Parameters of this option are analogous to the</source>
          <target state="translated">이 옵션의 매개 변수는</target>
        </trans-unit>
        <trans-unit id="ed89c3a81f547cc64d254621a2e80d0b09920687" translate="yes" xml:space="preserve">
          <source>Partial Store Order</source>
          <target state="translated">부분 상점 주문</target>
        </trans-unit>
        <trans-unit id="26760520407ec598057e0350ad5e24f9ca068704" translate="yes" xml:space="preserve">
          <source>Pass &lt;var&gt;option&lt;/var&gt; as an option to the assembler. If &lt;var&gt;option&lt;/var&gt; contains commas, it is split into multiple options at the commas.</source>
          <target state="translated">패스 &lt;var&gt;option&lt;/var&gt; 어셈블러에 옵션으로. &lt;var&gt;option&lt;/var&gt; 에 쉼표가 포함되어 있으면 쉼표에서 여러 옵션으로 분할됩니다.</target>
        </trans-unit>
        <trans-unit id="2d87e9abac2f57600cdd7d5c2efaf0f6e66f628c" translate="yes" xml:space="preserve">
          <source>Pass &lt;var&gt;option&lt;/var&gt; as an option to the assembler. You can use this to supply system-specific assembler options that GCC does not recognize.</source>
          <target state="translated">패스 &lt;var&gt;option&lt;/var&gt; 어셈블러에 옵션으로. 이를 사용하여 GCC가 인식하지 못하는 시스템 별 어셈블러 옵션을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea3ae9b22cd6a0097fe66cc5d0b0c7c77b1e7361" translate="yes" xml:space="preserve">
          <source>Pass &lt;var&gt;option&lt;/var&gt; as an option to the linker. If &lt;var&gt;option&lt;/var&gt; contains commas, it is split into multiple options at the commas. You can use this syntax to pass an argument to the option. For example,</source>
          <target state="translated">패스 &lt;var&gt;option&lt;/var&gt; 링커에 옵션으로. &lt;var&gt;option&lt;/var&gt; 에 쉼표가 포함되어 있으면 쉼표에서 여러 옵션으로 분할됩니다. 이 구문을 사용하여 옵션에 인수를 전달할 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="3b76a14ce88deda8b639a199af148cdc191f52bb" translate="yes" xml:space="preserve">
          <source>Pass &lt;var&gt;option&lt;/var&gt; as an option to the linker. You can use this to supply system-specific linker options that GCC does not recognize.</source>
          <target state="translated">패스 &lt;var&gt;option&lt;/var&gt; 링커에 옵션으로. 이를 사용하여 GCC가 인식하지 못하는 시스템 별 링커 옵션을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d7525a4e6f37e298e13e376428f81521ebcf0ad" translate="yes" xml:space="preserve">
          <source>Pass &lt;var&gt;option&lt;/var&gt; as an option to the preprocessor. You can use this to supply system-specific preprocessor options that GCC does not recognize.</source>
          <target state="translated">전처리 기에 &lt;var&gt;option&lt;/var&gt; 으로 옵션을 전달하십시오. 이를 사용하여 GCC가 인식하지 못하는 시스템 별 전 처리기 옵션을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d4c02ac25f95e4b321bd7c365e291db31eb2591" translate="yes" xml:space="preserve">
          <source>Pass on (or do not pass on) the</source>
          <target state="translated">통과 (또는 전달하지 않음)</target>
        </trans-unit>
        <trans-unit id="ebcca6f4e1a3875b263182927c19bae27d56304e" translate="yes" xml:space="preserve">
          <source>Pass the flag</source>
          <target state="translated">깃발을 전달</target>
        </trans-unit>
        <trans-unit id="edb98a025d28cabbd69e003e051e7e9e248d058f" translate="yes" xml:space="preserve">
          <source>Passed down to the assembler to enable dual- and single-operand instructions for telephony. Also sets the preprocessor symbol &lt;code&gt;__Xtelephony&lt;/code&gt;. This option is deprecated.</source>
          <target state="translated">전화 통신을위한 이중 및 단일 피연산자 명령어를 활성화하기 위해 어셈블러로 전달됩니다. 전 처리기 기호 &lt;code&gt;__Xtelephony&lt;/code&gt; 도 설정합니다 . 이 옵션은 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f90bde4ab81702f82c3a14c8f169a594acac87bc" translate="yes" xml:space="preserve">
          <source>Passed down to the assembler to enable the 64-bit time-stamp counter extension instruction. Also sets the preprocessor symbol &lt;code&gt;__Xrtsc&lt;/code&gt;. This option is deprecated.</source>
          <target state="translated">64 비트 타임 스탬프 카운터 확장 명령어를 활성화하기 위해 어셈블러로 전달됩니다. 전 처리기 기호 &lt;code&gt;__Xrtsc&lt;/code&gt; 도 설정합니다 . 이 옵션은 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4f8b46d31a4a12bcb7d5a9b4c4bc5f82313d8a46" translate="yes" xml:space="preserve">
          <source>Passed down to the assembler to enable the DSP Pack A extensions. Also sets the preprocessor symbol &lt;code&gt;__Xdsp_packa&lt;/code&gt;. This option is deprecated.</source>
          <target state="translated">DSP Pack A 확장을 활성화하기 위해 어셈블러로 전달됩니다. 전 처리기 기호 &lt;code&gt;__Xdsp_packa&lt;/code&gt; 도 설정합니다 . 이 옵션은 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="437ce81938361281bc7bdc1ba1109fae98afde5d" translate="yes" xml:space="preserve">
          <source>Passed down to the assembler to enable the XY memory extension. Also sets the preprocessor symbol &lt;code&gt;__Xxy&lt;/code&gt;.</source>
          <target state="translated">XY 메모리 확장을 활성화하기 위해 어셈블러로 전달됩니다. 전 처리기 기호 &lt;code&gt;__Xxy&lt;/code&gt; 도 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="192f1963f648220379d598033602fa765954e9e1" translate="yes" xml:space="preserve">
          <source>Passed down to the assembler to enable the dual Viterbi butterfly extension. Also sets the preprocessor symbol &lt;code&gt;__Xdvbf&lt;/code&gt;. This option is deprecated.</source>
          <target state="translated">이중 Viterbi 버터 플라이 확장을 활성화하기 위해 어셈블러로 전달되었습니다. 전 처리기 기호 &lt;code&gt;__Xdvbf&lt;/code&gt; 도 설정합니다 . 이 옵션은 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e120edac277c94aa8119101f86b7c6a0712b9fcc" translate="yes" xml:space="preserve">
          <source>Passed down to the assembler to enable the locked load/store conditional extension. Also sets the preprocessor symbol &lt;code&gt;__Xlock&lt;/code&gt;.</source>
          <target state="translated">잠긴로드 / 저장 조건부 확장을 활성화하기 위해 어셈블러로 전달됩니다. 전 처리기 기호 &lt;code&gt;__Xlock&lt;/code&gt; 도 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="2ba98472aa75cacca4b08108732162c8ba249643" translate="yes" xml:space="preserve">
          <source>Passed down to the assembler to enable the swap byte ordering extension instruction. Also sets the preprocessor symbol &lt;code&gt;__Xswape&lt;/code&gt;.</source>
          <target state="translated">스왑 바이트 순서 확장 명령을 활성화하기 위해 어셈블러로 전달됩니다. 전 처리기 기호 &lt;code&gt;__Xswape&lt;/code&gt; 도 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="6ad82551672605333a9c6ede433a1e6a6d571936" translate="yes" xml:space="preserve">
          <source>Passed down to the assembler. Also sets the preprocessor symbol &lt;code&gt;__Xxmac_24&lt;/code&gt;. This option is deprecated.</source>
          <target state="translated">어셈블러로 전달되었습니다. 전 처리기 기호 &lt;code&gt;__Xxmac_24&lt;/code&gt; 도 설정합니다 . 이 옵션은 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b5b5c4c5c6dc85e300e5d3da99c217798b87ef15" translate="yes" xml:space="preserve">
          <source>Passed down to the assembler. Also sets the preprocessor symbol &lt;code&gt;__Xxmac_d16&lt;/code&gt;. This option is deprecated.</source>
          <target state="translated">어셈블러로 전달되었습니다. 전 처리기 기호 &lt;code&gt;__Xxmac_d16&lt;/code&gt; 도 설정합니다 . 이 옵션은 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8e378b2ec7874c891a1160d052f02fb0e9162569" translate="yes" xml:space="preserve">
          <source>Passed through to the linker, to specify use of the &lt;code&gt;arclinux&lt;/code&gt; emulation. This option is enabled by default in tool chains built for &lt;code&gt;arc-linux-uclibc&lt;/code&gt; and &lt;code&gt;arceb-linux-uclibc&lt;/code&gt; targets when profiling is not requested.</source>
          <target state="translated">&lt;code&gt;arclinux&lt;/code&gt; 에뮬레이션의 사용을 지정하기 위해 링커로 전달됩니다 . 이 옵션은 프로파일 링이 요청되지 않을 때 &lt;code&gt;arc-linux-uclibc&lt;/code&gt; 및 &lt;code&gt;arceb-linux-uclibc&lt;/code&gt; 대상 용으로 빌드 된 툴 체인에서 기본적으로 활성화됩니다 .</target>
        </trans-unit>
        <trans-unit id="a028490f082637af1740d556712c0ce06eb5a830" translate="yes" xml:space="preserve">
          <source>Passed through to the linker, to specify use of the &lt;code&gt;arclinux_prof&lt;/code&gt; emulation. This option is enabled by default in tool chains built for &lt;code&gt;arc-linux-uclibc&lt;/code&gt; and &lt;code&gt;arceb-linux-uclibc&lt;/code&gt; targets when profiling is requested.</source>
          <target state="translated">&lt;code&gt;arclinux_prof&lt;/code&gt; 에뮬레이션 사용을 지정하기 위해 링커로 전달됩니다 . 이 옵션은 프로파일 링이 요청 될 때 &lt;code&gt;arc-linux-uclibc&lt;/code&gt; 및 &lt;code&gt;arceb-linux-uclibc&lt;/code&gt; 대상 용으로 빌드 된 툴 체인에서 기본적으로 활성화됩니다 .</target>
        </trans-unit>
        <trans-unit id="fd42d8d9c3b5bd99cdf57029443caa7831c5b611" translate="yes" xml:space="preserve">
          <source>Passes that use the dataflow information are enabled independently at different optimization levels.</source>
          <target state="translated">데이터 흐름 정보를 사용하는 패스는 다른 최적화 수준에서 독립적으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="df4603bbe9d05798f6607572b723fee8e9240d5c" translate="yes" xml:space="preserve">
          <source>Passing</source>
          <target state="translated">Passing</target>
        </trans-unit>
        <trans-unit id="ca1bab93bc155d4bc9f92ddda956825855fee474" translate="yes" xml:space="preserve">
          <source>Passing options to the assembler.</source>
          <target state="translated">옵션을 어셈블러에 전달합니다.</target>
        </trans-unit>
        <trans-unit id="a82f31d7c90d96412082c64503f9dcd5d50cd894" translate="yes" xml:space="preserve">
          <source>Passing parameters to or from Basic &lt;code&gt;asm&lt;/code&gt;</source>
          <target state="translated">기본 &lt;code&gt;asm&lt;/code&gt; 으로 또는 기본 asm 에서 매개 변수 전달</target>
        </trans-unit>
        <trans-unit id="a7301fd43d902ef4b0d5fbb8c15e6456832236d7" translate="yes" xml:space="preserve">
          <source>Passing parameters to or from Extended &lt;code&gt;asm&lt;/code&gt; without using input or output operands.</source>
          <target state="translated">입력 또는 출력 피연산자를 사용하지 않고 확장 &lt;code&gt;asm&lt;/code&gt; 으로 또는 확장 asm 에서 매개 변수 전달</target>
        </trans-unit>
        <trans-unit id="f36b9a29c6322b4f073965f6981e3c605c717562" translate="yes" xml:space="preserve">
          <source>Passing parameters to or from routines written in assembler (or other languages) using non-standard calling conventions.</source>
          <target state="translated">비표준 호출 규칙을 사용하여 어셈블러 (또는 다른 언어)로 작성된 루틴에 매개 변수 전달</target>
        </trans-unit>
        <trans-unit id="8340576084abc7513cb9511dd3a179bdd58bea84" translate="yes" xml:space="preserve">
          <source>Path specified by the environment variable &amp;lsquo;</source>
          <target state="translated">환경 변수 '로 지정된 경로</target>
        </trans-unit>
        <trans-unit id="2b8053a12982c8b5e19f801216dbc51afcd39aab" translate="yes" xml:space="preserve">
          <source>Pay special attention to code like this:</source>
          <target state="translated">다음과 같은 코드에 특별한주의를 기울이십시오.</target>
        </trans-unit>
        <trans-unit id="ce53b63c4327f47412072347ed7949c1656ab556" translate="yes" xml:space="preserve">
          <source>Peels loops for which there is enough information that they do not roll much (from profile feedback or static analysis). It also turns on complete loop peeling (i.e. complete removal of loops with small constant number of iterations).</source>
          <target state="translated">프로파일 피드백 또는 정적 분석에서 롤링하지 않는 충분한 정보가있는 루프 루프. 또한 완전한 루프 필링 (예 : 일정한 반복 횟수로 루프를 완전히 제거)을 켭니다.</target>
        </trans-unit>
        <trans-unit id="10555cda3fcf7df8cd08616e7d5db51df194941b" translate="yes" xml:space="preserve">
          <source>People who have contributed to GCC.</source>
          <target state="translated">GCC에 기여한 사람들.</target>
        </trans-unit>
        <trans-unit id="f13a48860e36bb0177b534cc2a15b3b114032ea9" translate="yes" xml:space="preserve">
          <source>Per-thread variables.</source>
          <target state="translated">스레드 당 변수</target>
        </trans-unit>
        <trans-unit id="73545218d23922d3a876b5c815bc65525793f423" translate="yes" xml:space="preserve">
          <source>Percentage penalty functions containing a single call to another function will receive when they are evaluated for cloning.</source>
          <target state="translated">다른 기능에 대한 단일 호출을 포함하는 백분율 패널티 기능은 복제를 평가할 때받습니다.</target>
        </trans-unit>
        <trans-unit id="dcfc68277a1e2c4d9091b21b46740ae70e4d5a9c" translate="yes" xml:space="preserve">
          <source>Percentage penalty the recursive functions will receive when they are evaluated for cloning.</source>
          <target state="translated">재귀 함수가 복제에 대해 평가 될 때받는 백분율 패널티.</target>
        </trans-unit>
        <trans-unit id="b1bfacd8c51fd20af1a996d2b1c9005f74a8a0d2" translate="yes" xml:space="preserve">
          <source>Perform Identical Code Folding for functions and read-only variables. The optimization reduces code size and may disturb unwind stacks by replacing a function by equivalent one with a different name. The optimization works more effectively with link-time optimization enabled.</source>
          <target state="translated">함수 및 읽기 전용 변수에 대해 동일한 코드 접기를 수행하십시오. 최적화는 코드 크기를 줄이고 함수를 다른 이름의 동등한 함수로 대체하여 언 와드 스택을 방해 할 수 있습니다. 링크 시간 최적화를 사용하면 최적화가보다 효과적으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="a6a8c1431d58909bfaffe9050c8733ea996d20bc" translate="yes" xml:space="preserve">
          <source>Perform Value Range Propagation on trees. This is similar to the constant propagation pass, but instead of values, ranges of values are propagated. This allows the optimizers to remove unnecessary range checks like array bound checks and null pointer checks. This is enabled by default at</source>
          <target state="translated">트리에서 값 범위 전파를 수행하십시오. 이는 상수 전파 패스와 비슷하지만 값 대신 값 범위가 전파됩니다. 이를 통해 옵티마이 저는 배열 바운드 검사 및 널 포인터 검사와 같은 불필요한 범위 검사를 제거 할 수 있습니다. 이것은 기본적으로 활성화되어 있습니다</target>
        </trans-unit>
        <trans-unit id="f11a18844b7820edfc7cfe8256d4e394a5329f58" translate="yes" xml:space="preserve">
          <source>Perform a 128-bit IEEE floating point add using round to odd as the rounding mode.</source>
          <target state="translated">반올림 모드를 반올림하여 홀수로 사용하여 128 비트 IEEE 부동 소수점 추가를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="ad630415b45adc0f11ff88c9ad397123e4ccfb1f" translate="yes" xml:space="preserve">
          <source>Perform a 128-bit IEEE floating point divide using round to odd as the rounding mode.</source>
          <target state="translated">반올림 모드로 반올림을 사용하여 128 비트 IEEE 부동 소수점 나누기를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="21b7a42855f16a63bf420afa4550fc9d4fc080ac" translate="yes" xml:space="preserve">
          <source>Perform a 128-bit IEEE floating point fused multiply and add operation using round to odd as the rounding mode.</source>
          <target state="translated">128 비트 IEEE 부동 소수점 융합 곱셈을 수행하고 반올림을 반올림 모드로 사용하여 연산을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="37ed36e9d63104743cea777f5e55fc078dfd943b" translate="yes" xml:space="preserve">
          <source>Perform a 128-bit IEEE floating point multiply using round to odd as the rounding mode.</source>
          <target state="translated">반올림 모드로 반올림을 사용하여 128 비트 IEEE 부동 소수점 곱셈을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="737a589634f68c1da9ecbd09594b87b83ec0aa7c" translate="yes" xml:space="preserve">
          <source>Perform a 128-bit IEEE floating point square root using round to odd as the rounding mode.</source>
          <target state="translated">반올림 모드로 반올림을 사용하여 128 비트 IEEE 부동 소수점 제곱근을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="ead0f18b8a1f24823972492647bc71a9e31e2c4a" translate="yes" xml:space="preserve">
          <source>Perform a 128-bit IEEE floating point subtract using round to odd as the rounding mode.</source>
          <target state="translated">반올림 모드로 반올림을 사용하여 128 비트 IEEE 부동 소수점 빼기를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="68de9811e50d3937c1ad606957f9ce3a651afee7" translate="yes" xml:space="preserve">
          <source>Perform a forward propagation pass on RTL. The pass tries to combine two instructions and checks if the result can be simplified. If loop unrolling is active, two passes are performed and the second is scheduled after loop unrolling.</source>
          <target state="translated">RTL에서 전달 전파를 수행하십시오. 패스는 두 개의 명령어를 결합하려고 시도하고 결과가 단순화 될 수 있는지 확인합니다. 루프 언 롤링이 활성화 된 경우 두 번의 패스가 수행되고 두 번째 패스는 루프 언 롤링 후에 예약됩니다.</target>
        </trans-unit>
        <trans-unit id="6dba988e88741e74ba501068678e1ab16f88bb77" translate="yes" xml:space="preserve">
          <source>Perform a global common subexpression elimination pass. This pass also performs global constant and copy propagation.</source>
          <target state="translated">글로벌 공통 하위 표현식 제거 패스를 수행하십시오. 이 패스는 전역 상수 및 복사 전파도 수행합니다.</target>
        </trans-unit>
        <trans-unit id="d64787311f720e83d55ee7c16d5127e619d4c2d5" translate="yes" xml:space="preserve">
          <source>Perform a number of minor optimizations that are relatively expensive.</source>
          <target state="translated">비교적 비싼 여러 가지 사소한 최적화를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="e4ef7411a4a596cce036263deed71704a6a4403d" translate="yes" xml:space="preserve">
          <source>Perform a variety of simple scalar cleanups (constant/copy propagation, redundancy elimination, range propagation and expression simplification) based on a dominator tree traversal. This also performs jump threading (to reduce jumps to jumps). This flag is enabled by default at</source>
          <target state="translated">지배자 트리 탐색을 기반으로 다양한 단순 스칼라 정리 (일정 / 복사 전파, 중복 제거, 범위 전파 및 표현 단순화)를 수행합니다. 또한 점프 스레딩을 수행하여 점프 점프를 줄입니다. 이 플래그는 기본적으로</target>
        </trans-unit>
        <trans-unit id="c690704255c1ecf4d6857e6000f1190b108f7ea6" translate="yes" xml:space="preserve">
          <source>Perform basic block vectorization on trees. This flag is enabled by default at</source>
          <target state="translated">트리에서 기본 블록 벡터화를 수행하십시오. 이 플래그는 기본적으로</target>
        </trans-unit>
        <trans-unit id="eeac5885ee87ab9527e79d1e7e4c5d0a5ab9cfee" translate="yes" xml:space="preserve">
          <source>Perform branch target register load optimization after prologue / epilogue threading.</source>
          <target state="translated">프롤로그 / 에필로그 스레딩 후 분기 대상 레지스터로드 최적화를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="f22ee925531c470bf10c56d8ec49b3ad79443d58" translate="yes" xml:space="preserve">
          <source>Perform branch target register load optimization before prologue / epilogue threading. The use of target registers can typically be exposed only during reload, thus hoisting loads out of loops and doing inter-block scheduling needs a separate optimization pass.</source>
          <target state="translated">프롤로그 / 에필로그 스레딩 전에 분기 대상 레지스터로드 최적화를 수행하십시오. 대상 레지스터의 사용은 일반적으로 재로드 중에 만 노출 될 수 있으므로 루프에서로드를 게양하고 블록 간 스케줄링을 수행하려면 별도의 최적화 단계가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="78ecf7dff1475297797e70aa8e37b17a7fe0ba23" translate="yes" xml:space="preserve">
          <source>Perform code hoisting. Code hoisting tries to move the evaluation of expressions executed on all paths to the function exit as early as possible. This is especially useful as a code size optimization, but it often helps for code speed as well. This flag is enabled by default at</source>
          <target state="translated">코드 게양을 수행하십시오. 코드 호이 스팅은 모든 경로에서 실행 된 표현식의 평가를 가능한 빨리 함수 엑시트로 이동하려고합니다. 이것은 코드 크기 최적화에 특히 유용하지만 종종 코드 속도에 도움이됩니다. 이 플래그는 기본적으로</target>
        </trans-unit>
        <trans-unit id="d42beff05151efc426a83c25d60382c077faa4d8" translate="yes" xml:space="preserve">
          <source>Perform conditional dead code elimination (DCE) for calls to built-in functions that may set &lt;code&gt;errno&lt;/code&gt; but are otherwise free of side effects. This flag is enabled by default at</source>
          <target state="translated">&lt;code&gt;errno&lt;/code&gt; 를 설정할 수 있지만 부작용이없는 내장 함수 호출에 대해 조건부 데드 코드 제거 (DCE)를 수행하십시오 . 이 플래그는 기본적으로</target>
        </trans-unit>
        <trans-unit id="3acf0b56088845895309ffb7ff3f62580c187452" translate="yes" xml:space="preserve">
          <source>Perform conversion of simple initializations in a switch to initializations from a scalar array. This flag is enabled by default at</source>
          <target state="translated">스위치에서 간단한 초기화를 스칼라 배열에서 초기화로 변환합니다. 이 플래그는 기본적으로</target>
        </trans-unit>
        <trans-unit id="76903ec0550edaa382bc63ed2ba99b071ffdb752" translate="yes" xml:space="preserve">
          <source>Perform copy propagation on trees. This pass eliminates unnecessary copy operations. This flag is enabled by default at</source>
          <target state="translated">트리에서 복사 전파를 수행하십시오. 이 패스는 불필요한 복사 작업을 제거합니다. 이 플래그는 기본적으로</target>
        </trans-unit>
        <trans-unit id="6d7ec7c39be13500a07e954c10fb63594d459307" translate="yes" xml:space="preserve">
          <source>Perform cross-jumping transformation. This transformation unifies equivalent code and saves code size. The resulting code may or may not perform better than without cross-jumping.</source>
          <target state="translated">교차 점프 변환을 수행하십시오. 이 변환은 동등한 코드를 통합하고 코드 크기를 저장합니다. 결과 코드는 교차 점프가없는 것보다 더 잘 수행되거나 수행되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f21edf0cd1996b67db995a9d0465125524c66c2d" translate="yes" xml:space="preserve">
          <source>Perform dead code elimination (DCE) on RTL. Enabled by default at</source>
          <target state="translated">RTL에서 데드 코드 제거 (DCE)를 수행하십시오. 에서 기본적으로 활성화</target>
        </trans-unit>
        <trans-unit id="3dbd69c046baefc1f0428ff45ebf37c050ee9b35" translate="yes" xml:space="preserve">
          <source>Perform dead code elimination (DCE) on trees. This flag is enabled by default at</source>
          <target state="translated">트리에서 데드 코드 제거 (DCE)를 수행하십시오. 이 플래그는 기본적으로</target>
        </trans-unit>
        <trans-unit id="1fac6b62e0201c67a765b9639bb451910616441d" translate="yes" xml:space="preserve">
          <source>Perform dead store elimination (DSE) on RTL. Enabled by default at</source>
          <target state="translated">RTL에서 DSE (Dead Store Elimination)를 수행하십시오. 에서 기본적으로 활성화</target>
        </trans-unit>
        <trans-unit id="9c91758280f32089239ead4d20b5ec849be15a87" translate="yes" xml:space="preserve">
          <source>Perform dead store elimination (DSE) on trees. A dead store is a store into a memory location that is later overwritten by another store without any intervening loads. In this case the earlier store can be deleted. This flag is enabled by default at</source>
          <target state="translated">나무에서 죽은 상점 제거 (DSE)를 수행하십시오. 사용 불능 저장소는 메모리 위치에 저장되는 저장소로 나중에 중간에로드하지 않고 다른 저장소에서 덮어 씁니다. 이 경우 이전 저장소를 삭제할 수 있습니다. 이 플래그는 기본적으로</target>
        </trans-unit>
        <trans-unit id="753e71f3a5ff6388d6a57662208a4d8d6dc2cf2a" translate="yes" xml:space="preserve">
          <source>Perform final value replacement. If a variable is modified in a loop in such a way that its value when exiting the loop can be determined using only its initial value and the number of loop iterations, replace uses of the final value by such a computation, provided it is sufficiently cheap. This reduces data dependencies and may allow further simplifications. Enabled by default at</source>
          <target state="translated">최종 값 교체를 수행하십시오. 루프를 빠져 나올 때의 값이 초기 값과 루프 반복 횟수 만 사용하여 결정될 수있는 방식으로 루프에서 변수가 수정 된 경우, 값이 충분히 싼 경우 최종 값의 사용을 이러한 계산으로 대체하십시오. . 이는 데이터 종속성을 줄이고 추가 단순화를 허용 할 수 있습니다. 에서 기본적으로 활성화</target>
        </trans-unit>
        <trans-unit id="70b6a364a52abbfd9ee8ac29b5164966fafd5f6e" translate="yes" xml:space="preserve">
          <source>Perform forward propagation on trees. This flag is enabled by default at</source>
          <target state="translated">트리에서 앞으로 전파를 수행하십시오. 이 플래그는 기본적으로</target>
        </trans-unit>
        <trans-unit id="673d903cfc5f5e6d5fb3bb1eee0f4c9f6c48077e" translate="yes" xml:space="preserve">
          <source>Perform forward store motion on trees. This flag is enabled by default at</source>
          <target state="translated">나무에서 앞으로 상점 이동을 수행하십시오. 이 플래그는 기본적으로</target>
        </trans-unit>
        <trans-unit id="d36329f87f0281004169238a916fdfdf7420040e" translate="yes" xml:space="preserve">
          <source>Perform full redundancy elimination (FRE) on trees. The difference between FRE and PRE is that FRE only considers expressions that are computed on all paths leading to the redundant computation. This analysis is faster than PRE, though it exposes fewer redundancies. This flag is enabled by default at</source>
          <target state="translated">나무에서 완전 중복 제거 (FRE)를 수행하십시오. FRE와 PRE의 차이점은 FRE는 중복 계산으로 이어지는 모든 경로에서 계산되는 표현식 만 고려한다는 것입니다. 이 분석은 중복성이 적지 만 PRE보다 빠릅니다. 이 플래그는 기본적으로</target>
        </trans-unit>
        <trans-unit id="3f354c46e4dde1d877eb683cb0a6100f2cbc4bca" translate="yes" xml:space="preserve">
          <source>Perform function cloning to make interprocedural constant propagation stronger. When enabled, interprocedural constant propagation performs function cloning when externally visible function can be called with constant arguments. Because this optimization can create multiple copies of functions, it may significantly increase code size (see</source>
          <target state="translated">절차 간 상수 전파를 강화하려면 함수 복제를 수행하십시오. 사용 가능한 경우, 프로 시저 상수 전파는 외부 인수로 상수 외부 함수를 호출 할 수있는 경우 함수 복제를 수행합니다. 이 최적화는 여러 개의 함수 사본을 작성할 수 있으므로 코드 크기가 크게 증가 할 수 있습니다 (참조</target>
        </trans-unit>
        <trans-unit id="154c76319b0c62d9b2e90e2513183f271e8cf0cd" translate="yes" xml:space="preserve">
          <source>Perform function-local points-to analysis on trees. This flag is enabled by default at</source>
          <target state="translated">트리에서 함수 로컬 지점 간 분석을 수행합니다. 이 플래그는 기본적으로</target>
        </trans-unit>
        <trans-unit id="56af57ea7e8c24ebc43912154747d0770817c691" translate="yes" xml:space="preserve">
          <source>Perform hoisting of loads from conditional pointers on trees. This pass is enabled by default at</source>
          <target state="translated">나무의 조건부 포인터에서 하중을 들어 올리십시오. 이 패스는 기본적으로</target>
        </trans-unit>
        <trans-unit id="4ab70db777954340ed7abb290ec401d3cad6d79c" translate="yes" xml:space="preserve">
          <source>Perform induction variable optimizations (strength reduction, induction variable merging and induction variable elimination) on trees.</source>
          <target state="translated">나무에서 유도 변수 최적화 (강도 감소, 유도 변수 병합 및 유도 변수 제거)를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="1073eeaaee6148009c2caccc4b4d6c7d341bbb2f" translate="yes" xml:space="preserve">
          <source>Perform interprocedural constant propagation. This optimization analyzes the program to determine when values passed to functions are constants and then optimizes accordingly. This optimization can substantially increase performance if the application has constants passed to functions. This flag is enabled by default at</source>
          <target state="translated">절차 간 상수 전파를 수행하십시오. 이 최적화는 프로그램에 분석하여 함수에 전달 된 값이 상수 인시기를 결정한 다음 그에 따라 최적화합니다. 이 최적화는 응용 프로그램에 상수가 전달 된 경우 성능을 크게 향상시킬 수 있습니다. 이 플래그는 기본적으로</target>
        </trans-unit>
        <trans-unit id="20c997fc23010523f8221d0a92c5b9e6c4050935" translate="yes" xml:space="preserve">
          <source>Perform interprocedural pointer analysis and interprocedural modification and reference analysis. This option can cause excessive memory and compile-time usage on large compilation units. It is not enabled by default at any optimization level.</source>
          <target state="translated">절차 간 포인터 분석 및 절차 간 수정 및 참조 분석을 수행하십시오. 이 옵션은 큰 컴파일 단위에서 과도한 메모리 및 컴파일 타임 사용을 유발할 수 있습니다. 최적화 수준에서는 기본적으로 활성화되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4921214a12f7612e4410a372e1807efabe260fc7" translate="yes" xml:space="preserve">
          <source>Perform interprocedural profile propagation. The functions called only from cold functions are marked as cold. Also functions executed once (such as &lt;code&gt;cold&lt;/code&gt;, &lt;code&gt;noreturn&lt;/code&gt;, static constructors or destructors) are identified. Cold functions and loop less parts of functions executed once are then optimized for size. Enabled by default at</source>
          <target state="translated">절차 간 프로파일 전파를 수행하십시오. 콜드 기능에서만 호출 된 기능은 콜드로 표시됩니다. 한 번 실행 된 함수 (예 : &lt;code&gt;cold&lt;/code&gt; , &lt;code&gt;noreturn&lt;/code&gt; , 정적 생성자 또는 소멸자)도 식별됩니다. 콜드 함수와 한 번 실행 된 함수의 적은 부분을 루프하면 크기에 맞게 최적화됩니다. 에서 기본적으로 활성화</target>
        </trans-unit>
        <trans-unit id="fb68f0d0ee8b6c41ae81d56a47219400b71ee1b8" translate="yes" xml:space="preserve">
          <source>Perform interprocedural scalar replacement of aggregates, removal of unused parameters and replacement of parameters passed by reference by parameters passed by value.</source>
          <target state="translated">집계의 스칼라 교체, 사용되지 않은 매개 변수 제거 및 참조로 전달 된 매개 변수를 값으로 전달 된 매개 변수로 대체하십시오.</target>
        </trans-unit>
        <trans-unit id="f5a5996d13689478fbbcfefaf187644cb0bd68f3" translate="yes" xml:space="preserve">
          <source>Perform loop distribution of patterns that can be code generated with calls to a library. This flag is enabled by default at</source>
          <target state="translated">라이브러리를 호출하여 코드를 생성 할 수있는 패턴의 루프 분배를 수행하십시오. 이 플래그는 기본적으로</target>
        </trans-unit>
        <trans-unit id="b51b13ca91f32e55112e18c7be23871252a6a72b" translate="yes" xml:space="preserve">
          <source>Perform loop distribution. This flag can improve cache performance on big loop bodies and allow further loop optimizations, like parallelization or vectorization, to take place. For example, the loop</source>
          <target state="translated">루프 분배를 수행하십시오. 이 플래그는 큰 루프 본문에서 캐시 성능을 향상시키고 병렬화 또는 벡터화와 같은 추가 루프 최적화가 수행되도록합니다. 예를 들어 루프</target>
        </trans-unit>
        <trans-unit id="00772bc8e86a7b4ab6c55ba37b514b8f5f461b5a" translate="yes" xml:space="preserve">
          <source>Perform loop header copying on trees. This is beneficial since it increases effectiveness of code motion optimizations. It also saves one jump. This flag is enabled by default at</source>
          <target state="translated">트리에서 루프 헤더 복사를 수행하십시오. 코드 모션 최적화의 효율성을 높이기 때문에 유리합니다. 또한 한 번의 점프를 저장합니다. 이 플래그는 기본적으로</target>
        </trans-unit>
        <trans-unit id="6482eb095ab0106534173067ba63a63b4e772180" translate="yes" xml:space="preserve">
          <source>Perform loop interchange outside of graphite. This flag can improve cache performance on loop nest and allow further loop optimizations, like vectorization, to take place. For example, the loop</source>
          <target state="translated">흑연 외부에서 루프 교환을 수행하십시오. 이 플래그는 루프 네스트에서 캐시 성능을 향상시키고 벡터화와 같은 추가 루프 최적화를 수행 할 수 있습니다. 예를 들어 루프</target>
        </trans-unit>
        <trans-unit id="babeb9c2acdfb002d90adf1ca5e9065ac71e5cf8" translate="yes" xml:space="preserve">
          <source>Perform loop invariant motion on trees. This pass moves only invariants that are hard to handle at RTL level (function calls, operations that expand to nontrivial sequences of insns). With</source>
          <target state="translated">트리에서 루프 불변 동작을 수행합니다. 이 패스는 RTL 수준에서 처리하기 어려운 변형 (기능 호출, 사소한 일련의 insns로 확장되는 연산) 만 이동합니다. 와</target>
        </trans-unit>
        <trans-unit id="3759039cae2d11146e7c0dfe601eacde292dd1d1" translate="yes" xml:space="preserve">
          <source>Perform loop nest optimizations. Same as</source>
          <target state="translated">루프 네스트 최적화를 수행하십시오. 와 동일</target>
        </trans-unit>
        <trans-unit id="6a64dbc5caecc19bd9b50ef676cc69a1b212fa95" translate="yes" xml:space="preserve">
          <source>Perform loop optimizations on trees. This flag is enabled by default at</source>
          <target state="translated">트리에서 루프 최적화를 수행하십시오. 이 플래그는 기본적으로</target>
        </trans-unit>
        <trans-unit id="121a475df0390f719f03e11127e3dd161d431728" translate="yes" xml:space="preserve">
          <source>Perform loop vectorization on trees. This flag is enabled by default at</source>
          <target state="translated">트리에서 루프 벡터화를 수행하십시오. 이 플래그는 기본적으로</target>
        </trans-unit>
        <trans-unit id="f7516a23fd7e60004d67be66a314a10a37b3fdbd" translate="yes" xml:space="preserve">
          <source>Perform merging of narrow stores to consecutive memory addresses. This pass merges contiguous stores of immediate values narrower than a word into fewer wider stores to reduce the number of instructions. This is enabled by default at</source>
          <target state="translated">좁은 저장소를 연속 메모리 주소에 병합합니다. 이 단계는 단어 수보다 인접한 값이 인접한 연속적인 저장소를 더 적은 수의 더 넓은 저장소로 병합하여 명령어 수를 줄입니다. 이것은 기본적으로 활성화되어 있습니다</target>
        </trans-unit>
        <trans-unit id="1807eb51aa29cd70afd6f6f94c9e10f8d8e2a87a" translate="yes" xml:space="preserve">
          <source>Perform more aggressive SMS-based modulo scheduling with register moves allowed. By setting this flag certain anti-dependences edges are deleted, which triggers the generation of reg-moves based on the life-range analysis. This option is effective only with</source>
          <target state="translated">레지스터 이동이 허용 된보다 적극적인 SMS 기반 모듈로 스케줄링을 수행하십시오. 이 플래그를 설정하면 특정 반 의존성 가장자리가 삭제되어 수명 범위 분석을 기반으로 reg-moves 생성이 트리거됩니다. 이 옵션은 다음과 같은 경우에만 유효합니다</target>
        </trans-unit>
        <trans-unit id="ebc09c6b12bc75f0257526fb06df9feb9bf5a73f" translate="yes" xml:space="preserve">
          <source>Perform optimizations that check to see if a jump branches to a location where another comparison subsumed by the first is found. If so, the first branch is redirected to either the destination of the second branch or a point immediately following it, depending on whether the condition is known to be true or false.</source>
          <target state="translated">점프가 첫 번째로 가정 된 다른 비교가있는 위치로 분기되는지 확인하는 최적화를 수행하십시오. 그렇다면 첫 번째 분기는 조건이 참인지 거짓인지에 따라 두 번째 분기의 대상 또는 바로 다음 지점으로 리디렉션됩니다.</target>
        </trans-unit>
        <trans-unit id="8bd151314b28d93fbbbfc848886d1f59ee15eb4c" translate="yes" xml:space="preserve">
          <source>Perform partial redundancy elimination (PRE) on trees. This flag is enabled by default at</source>
          <target state="translated">트리에서 부분 중복 제거 (PRE)를 수행하십시오. 이 플래그는 기본적으로</target>
        </trans-unit>
        <trans-unit id="5a687acdfae667c8ef7b171f66546043ce33e5d1" translate="yes" xml:space="preserve">
          <source>Perform pattern matching on SSA PHI nodes to optimize conditional code. This pass is enabled by default at</source>
          <target state="translated">SSA PHI 노드에서 패턴 일치를 수행하여 조건부 코드를 최적화하십시오. 이 패스는 기본적으로</target>
        </trans-unit>
        <trans-unit id="d2e68d673229fe5ee8d59afbd3fa0d22ff809b67" translate="yes" xml:space="preserve">
          <source>Perform predictive commoning optimization, i.e., reusing computations (especially memory loads and stores) performed in previous iterations of loops.</source>
          <target state="translated">예측 반복 최적화를 수행합니다. 즉, 이전 루프 반복에서 수행 된 계산 (특히 메모리로드 및 저장)을 재사용합니다.</target>
        </trans-unit>
        <trans-unit id="26325618e11578248e60d5c5ff4d5018d8830e39" translate="yes" xml:space="preserve">
          <source>Perform preprocessing as a separate pass before compilation. By default, GCC performs preprocessing as an integrated part of input tokenization and parsing. If this option is provided, the appropriate language front end (&lt;code&gt;cc1&lt;/code&gt;, &lt;code&gt;cc1plus&lt;/code&gt;, or &lt;code&gt;cc1obj&lt;/code&gt; for C, C++, and Objective-C, respectively) is instead invoked twice, once for preprocessing only and once for actual compilation of the preprocessed input. This option may be useful in conjunction with the</source>
          <target state="translated">컴파일하기 전에 별도의 패스로 전처리를 수행하십시오. 기본적으로 GCC는 입력 토큰 화 및 구문 분석의 통합 부분으로 사전 처리를 수행합니다. 이 옵션이 제공 되면, 사전 처리를 위해 한 번, 사전 처리 된 입력을 실제로 컴파일하기 위해 한 번, 적절한 언어 프론트 엔드 ( 각각 C, C ++ 및 Objective-C에 대해 &lt;code&gt;cc1&lt;/code&gt; , &lt;code&gt;cc1plus&lt;/code&gt; 또는 &lt;code&gt;cc1obj&lt;/code&gt; )가 두 번 호출됩니다. 이 옵션은</target>
        </trans-unit>
        <trans-unit id="62b772c98eeb18277e47f6941de481fe39743b88" translate="yes" xml:space="preserve">
          <source>Perform reassociation on trees. This flag is enabled by default at</source>
          <target state="translated">나무에서 재 연관을 수행하십시오. 이 플래그는 기본적으로</target>
        </trans-unit>
        <trans-unit id="813a6aee318424bad47fc31e7a836620510b882c" translate="yes" xml:space="preserve">
          <source>Perform scalar replacement of aggregates. This pass replaces structure references with scalars to prevent committing structures to memory too early. This flag is enabled by default at</source>
          <target state="translated">집계의 스칼라 교체를 수행하십시오. 이 패스는 구조 참조를 스칼라로 대체하여 구조를 메모리에 너무 일찍 커밋하는 것을 방지합니다. 이 플래그는 기본적으로</target>
        </trans-unit>
        <trans-unit id="b26f36abadc06bc5e7c208db61bbe3c358c44821" translate="yes" xml:space="preserve">
          <source>Perform sparse conditional bit constant propagation on trees and propagate pointer alignment information. This pass only operates on local scalar variables and is enabled by default at</source>
          <target state="translated">트리에서 스파 스 조건부 비트 상수 전파를 수행하고 포인터 정렬 정보를 전파합니다. 이 패스는 로컬 스칼라 변수에서만 작동하며 기본적으로</target>
        </trans-unit>
        <trans-unit id="98694aae92ae0c01003bcd09f650c827470ff6ab" translate="yes" xml:space="preserve">
          <source>Perform sparse conditional constant propagation (CCP) on trees. This pass only operates on local scalar variables and is enabled by default at</source>
          <target state="translated">트리에서 스파 스 조건부 상수 전파 (CCP)를 수행합니다. 이 패스는 로컬 스칼라 변수에서만 작동하며 기본적으로</target>
        </trans-unit>
        <trans-unit id="8f21fbfa919feaca891f89e479b5cefd818de1a6" translate="yes" xml:space="preserve">
          <source>Perform straight-line strength reduction on trees. This recognizes related expressions involving multiplications and replaces them by less expensive calculations when possible. This is enabled by default at</source>
          <target state="translated">나무에서 직선 강도 감소를 수행합니다. 이것은 곱셈과 관련된 표현을 인식하고 가능하면 덜 비싼 계산으로 대체합니다. 이것은 기본적으로 활성화되어 있습니다</target>
        </trans-unit>
        <trans-unit id="fc1747c25395001b1247e16471c4481c44d67bd9" translate="yes" xml:space="preserve">
          <source>Perform swing modulo scheduling immediately before the first scheduling pass. This pass looks at innermost loops and reorders their instructions by overlapping different iterations.</source>
          <target state="translated">첫 번째 스케줄링 통과 직전에 스윙 모듈로 스케줄링을 수행하십시오. 이 패스는 가장 안쪽의 루프를보고 서로 다른 반복을 겹쳐서 명령어를 재정렬합니다.</target>
        </trans-unit>
        <trans-unit id="a919828d7b7d52d94d6f24adec36ae549e8a769d" translate="yes" xml:space="preserve">
          <source>Perform tail duplication to enlarge superblock size. This transformation simplifies the control flow of the function allowing other optimizations to do a better job.</source>
          <target state="translated">수퍼 블록 크기를 확대하려면 꼬리 복제를 수행하십시오. 이 변환은 다른 최적화가 더 나은 작업을 수행 할 수 있도록 함수의 제어 흐름을 단순화합니다.</target>
        </trans-unit>
        <trans-unit id="8a7a4b7c3b7e1bdf82389ca95d6d1678d6326545" translate="yes" xml:space="preserve">
          <source>Perform temporary expression replacement during the SSA-&amp;gt;normal phase. Single use/single def temporaries are replaced at their use location with their defining expression. This results in non-GIMPLE code, but gives the expanders much more complex trees to work on resulting in better RTL generation. This is enabled by default at</source>
          <target state="translated">SSA-&amp;gt; 정상 단계에서 임시 표현식 대체를 수행하십시오. 단일 사용 / 단일 def 임시는 사용 위치에서 정의 된 표현으로 대체됩니다. 결과적으로 비 GIMPLE 코드가 생성되지만 확장기에는 훨씬 더 복잡한 트리가 작동하여 RTL 생성이 향상됩니다. 이것은 기본적으로 활성화되어 있습니다</target>
        </trans-unit>
        <trans-unit id="04e4b2d91846b5259c4027f98674900fe1e5e1ea" translate="yes" xml:space="preserve">
          <source>Perform vectorization on trees. This flag enables</source>
          <target state="translated">나무에서 벡터화를 수행합니다. 이 플래그는</target>
        </trans-unit>
        <trans-unit id="bf3de408c364e89ef2141957569f6e056a16d34e" translate="yes" xml:space="preserve">
          <source>Performs a target dependent pass over the instruction stream to schedule instructions of same type together because target machine can execute them more efficiently if they are adjacent to each other in the instruction flow.</source>
          <target state="translated">동일한 유형의 명령어를 함께 스케쥴하기 위해 명령어 스트림을 통해 타깃 종속 패스를 수행하여 타깃 머신이 명령어 흐름에서 서로 인접 해있는 경우 더 효율적으로 실행할 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="0cf20e92e0ce42954a3e029ad821a60784d2e15d" translate="yes" xml:space="preserve">
          <source>Permissible names are: &amp;lsquo;</source>
          <target state="translated">허용되는 이름은 '</target>
        </trans-unit>
        <trans-unit id="af0a0da269eb7e218ba55c95eef7829d862234bb" translate="yes" xml:space="preserve">
          <source>Permissible names for this option are the same as those for</source>
          <target state="translated">이 옵션에 허용되는 이름은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="35baeb043fe816dcaf36ed0df9f003c63e8e45b3" translate="yes" xml:space="preserve">
          <source>Permissible values for these parameters are: &lt;code&gt;reset&lt;/code&gt;, &lt;code&gt;software_exception&lt;/code&gt;, &lt;code&gt;page_miss&lt;/code&gt;, &lt;code&gt;timer0&lt;/code&gt;, &lt;code&gt;timer1&lt;/code&gt;, &lt;code&gt;message&lt;/code&gt;, &lt;code&gt;dma0&lt;/code&gt;, &lt;code&gt;dma1&lt;/code&gt;, &lt;code&gt;wand&lt;/code&gt; and &lt;code&gt;swi&lt;/code&gt;. Multiple parameters indicate that multiple entries in the interrupt vector table should be initialized for this function, i.e. for each parameter &lt;var&gt;name&lt;/var&gt;, a jump to the function is emitted in the section ivt_entry_&lt;var&gt;name&lt;/var&gt;. The parameter(s) may be omitted entirely, in which case no interrupt vector table entry is provided.</source>
          <target state="translated">이러한 매개 변수에 허용되는 값은 &lt;code&gt;reset&lt;/code&gt; , &lt;code&gt;software_exception&lt;/code&gt; , &lt;code&gt;page_miss&lt;/code&gt; , &lt;code&gt;timer0&lt;/code&gt; , &lt;code&gt;timer1&lt;/code&gt; , &lt;code&gt;message&lt;/code&gt; , &lt;code&gt;dma0&lt;/code&gt; , &lt;code&gt;dma1&lt;/code&gt; , &lt;code&gt;wand&lt;/code&gt; 및 &lt;code&gt;swi&lt;/code&gt; 입니다. 다중 매개 변수는이 함수에 대해 인터럽트 벡터 테이블의 다중 항목을 초기화해야 함을 나타냅니다. 즉, 각 매개 변수 &lt;var&gt;name&lt;/var&gt; 에 대해 함수에 대한 점프는 ivt_entry_ &lt;var&gt;name&lt;/var&gt; 섹션에서 생성 됩니다. 파라미터 (들)는 완전히 생략 될 수 있으며,이 경우 인터럽트 벡터 테이블 엔트리가 제공되지 않는다.</target>
        </trans-unit>
        <trans-unit id="b9723fc078a6d12e16c3d4a9c0abd787a24129b7" translate="yes" xml:space="preserve">
          <source>Permissible values for this parameter are &lt;code&gt;user&lt;/code&gt;, &lt;code&gt;supervisor&lt;/code&gt;, and &lt;code&gt;machine&lt;/code&gt;. If there is no parameter, then it defaults to &lt;code&gt;machine&lt;/code&gt;.</source>
          <target state="translated">이 매개 변수에 허용되는 값은 &lt;code&gt;user&lt;/code&gt; , &lt;code&gt;supervisor&lt;/code&gt; 및 &lt;code&gt;machine&lt;/code&gt; 입니다 . 매개 변수가없는 경우 기본값은 &lt;code&gt;machine&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="3cc7aed9a0397bf927110c664bfb64b86eeabb19" translate="yes" xml:space="preserve">
          <source>Permissible values for this parameter are: &lt;code&gt;IRQ&lt;/code&gt;, &lt;code&gt;FIQ&lt;/code&gt;, &lt;code&gt;SWI&lt;/code&gt;, &lt;code&gt;ABORT&lt;/code&gt; and &lt;code&gt;UNDEF&lt;/code&gt;.</source>
          <target state="translated">이 매개 변수에 허용되는 값은 &lt;code&gt;IRQ&lt;/code&gt; , &lt;code&gt;FIQ&lt;/code&gt; , &lt;code&gt;SWI&lt;/code&gt; , &lt;code&gt;ABORT&lt;/code&gt; 및 &lt;code&gt;UNDEF&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3b9d9d84efd3990ebcb9f633346ed4f086d6a8d9" translate="yes" xml:space="preserve">
          <source>Permissible values for this parameter are: &lt;code&gt;ilink1&lt;/code&gt; and &lt;code&gt;ilink2&lt;/code&gt; for ARCv1 architecture, and &lt;code&gt;ilink&lt;/code&gt; and &lt;code&gt;firq&lt;/code&gt; for ARCv2 architecture.</source>
          <target state="translated">이 매개 변수에 허용되는 값은 ARCv1 아키텍처의 경우 &lt;code&gt;ilink1&lt;/code&gt; 및 &lt;code&gt;ilink2&lt;/code&gt; , ARCv2 아키텍처의 경우 &lt;code&gt;ilink&lt;/code&gt; 및 &lt;code&gt;firq&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="57d5e1c32f10448459df52f2af315ff5a35b20a7" translate="yes" xml:space="preserve">
          <source>Permissible values for this parameter are: &lt;code&gt;ilink1&lt;/code&gt; and &lt;code&gt;ilink2&lt;/code&gt;.</source>
          <target state="translated">이 매개 변수에 허용되는 값은 &lt;code&gt;ilink1&lt;/code&gt; 및 &lt;code&gt;ilink2&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4f3f12e5bf476c3ff221016dda60f3c7460d0647" translate="yes" xml:space="preserve">
          <source>Permission is granted to copy, distribute and/or modify this document under the terms of the GNU Free Documentation License, Version 1.3 or any later version published by the Free Software Foundation; with the Invariant Sections being &amp;ldquo;Funding Free Software&amp;rdquo;, the Front-Cover Texts being (a) (see below), and with the Back-Cover Texts being (b) (see below). A copy of the license is included in the section entitled &amp;ldquo;GNU Free Documentation License&amp;rdquo;.</source>
          <target state="translated">GNU Free Documentation License, 버전 1.3 또는 Free Software Foundation에서 게시 한 이후 버전의 조항에 따라이 문서를 복사, 배포 및 / 또는 수정할 수있는 권한이 부여됩니다. 변하지 않는 섹션은&amp;ldquo;Funding Free Software&amp;rdquo;, Front-Cover Text는 (a) (아래 참조), Back-Cover Text는 (b) (아래 참조)로 표시됩니다. 라이센스 사본은&amp;ldquo;GNU Free Documentation License&amp;rdquo;섹션에 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb303e16e1de5b240406d59f6d4950a031fdb18c" translate="yes" xml:space="preserve">
          <source>Permit scheduling of function prologue and epilogue sequences. Using this option can result in code that is not compliant with the C-SKY V2 ABI prologue requirements and that cannot be debugged or backtraced. It is disabled by default.</source>
          <target state="translated">함수 프롤로그 및 에필로그 시퀀스의 스케줄링을 허용합니다. 이 옵션을 사용하면 C-SKY V2 ABI 프롤로그 요구 사항을 준수하지 않고 디버깅하거나 역 추적 할 수없는 코드가 생성 될 수 있습니다. 기본적으로 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="258db086a140738c3e68e86e4185fee98a52b02b" translate="yes" xml:space="preserve">
          <source>Pertinent parameters for controlling the exploration are:</source>
          <target state="translated">탐색을 제어하기위한 관련 매개 변수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="efb7f323fa4189969e284506cb84cfc7c5590b36" translate="yes" xml:space="preserve">
          <source>Place a stop bit after every cycle when scheduling. This option is on by default.</source>
          <target state="translated">스케줄링 할 때마다 사이클마다 정지 비트를 배치하십시오. 이 옵션은 기본적으로 켜져 있습니다.</target>
        </trans-unit>
        <trans-unit id="f322bfc998e9190a4bf5a7767d3d6625d8974da3" translate="yes" xml:space="preserve">
          <source>Place each function or data item into its own section in the output file if the target supports arbitrary sections. The name of the function or the name of the data item determines the section&amp;rsquo;s name in the output file.</source>
          <target state="translated">대상이 임의의 섹션을 지원하는 경우 각 함수 또는 데이터 항목을 출력 파일의 자체 섹션에 배치하십시오. 함수 이름 또는 데이터 항목 이름에 따라 출력 파일의 섹션 이름이 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="d5dd2f33d892c7609324f2984b75dba44e198b60" translate="yes" xml:space="preserve">
          <source>Place output in file &lt;var&gt;file&lt;/var&gt;. This applies to whatever sort of output is being produced, whether it be an executable file, an object file, an assembler file or preprocessed C code.</source>
          <target state="translated">파일 &lt;var&gt;file&lt;/var&gt; 에 출력을 배치 하십시오 . 이는 실행 파일, 객체 파일, 어셈블러 파일 또는 사전 처리 된 C 코드 등 출력에 상관없이 모든 종류의 출력에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="6702fed7fed6176a523c58b5ddd51a1d929453f7" translate="yes" xml:space="preserve">
          <source>Please note the warning under</source>
          <target state="translated">아래의 경고에 유의하십시오</target>
        </trans-unit>
        <trans-unit id="fa1c5292c2aed3e9e6527fac2de8fd113fa58e19" translate="yes" xml:space="preserve">
          <source>Pointer arguments to variadic functions.</source>
          <target state="translated">가변성 함수에 대한 포인터 인수.</target>
        </trans-unit>
        <trans-unit id="c72a43085fa8bb37fba01322fd21a237f32d0882" translate="yes" xml:space="preserve">
          <source>Pointer register (r26&amp;ndash;r31)</source>
          <target state="translated">포인터 레지스터 (r26&amp;ndash;r31)</target>
        </trans-unit>
        <trans-unit id="548e8a6d360621f369a6ac68a9d06d3b535c4226" translate="yes" xml:space="preserve">
          <source>Pointer with long displacement.</source>
          <target state="translated">변위가 긴 포인터.</target>
        </trans-unit>
        <trans-unit id="f829df7980df5422cdac2c36bfd4a6a0924d2a9d" translate="yes" xml:space="preserve">
          <source>Pointer with short displacement.</source>
          <target state="translated">변위가 짧은 포인터.</target>
        </trans-unit>
        <trans-unit id="221a34492903a7d75d1476fa80d265dd838ae397" translate="yes" xml:space="preserve">
          <source>Pointers in the implementation are 16 bits wide. The address of a function or label is represented as word address so that indirect jumps and calls can target any code address in the range of 64 Ki words.</source>
          <target state="translated">구현의 포인터는 16 비트 폭입니다. 함수 또는 레이블의 주소는 워드 주소로 표시되므로 간접 점프 및 호출은 64 Ki 단어 범위의 모든 코드 주소를 대상으로 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b71846dbdd6d5df077c8d26dc154bb35c68e7752" translate="yes" xml:space="preserve">
          <source>Pointers to arrays with qualifiers work as expected.</source>
          <target state="translated">한정자가있는 배열의 포인터는 예상대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="da127d1a6d3dff99efb435318078508cb04231bb" translate="yes" xml:space="preserve">
          <source>Popping the arguments after the function call can be expensive on AVR so that accumulating the stack space might lead to smaller executables because arguments need not be removed from the stack after such a function call.</source>
          <target state="translated">AVR에서 함수 호출 후 인수를 제거하면 스택 공간을 누적하면 그러한 함수 호출 후 스택에서 인수를 제거 할 필요가 없기 때문에 실행 파일이 더 작아 질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ec131a13f5ccb0f8a6fa30408faa2bccded3261" translate="yes" xml:space="preserve">
          <source>Position-independent code requires special support, and therefore works only on certain machines.</source>
          <target state="translated">위치 독립적 인 코드는 특별한 지원이 필요하므로 특정 머신에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="ff1fde2f659bcd7d20cf19e7e6dbdfb1735e0055" translate="yes" xml:space="preserve">
          <source>Position-independent code requires special support, and therefore works only on certain machines. For the x86, GCC supports PIC for System V but not for the Sun 386i. Code generated for the IBM RS/6000 is always position-independent.</source>
          <target state="translated">위치 독립적 인 코드는 특별한 지원이 필요하므로 특정 머신에서만 작동합니다. x86의 경우 GCC는 시스템 V의 PIC를 지원하지만 Sun 386i는 지원하지 않습니다. IBM RS / 6000 용으로 생성 된 코드는 항상 위치 독립적입니다.</target>
        </trans-unit>
        <trans-unit id="d29deccf36aae92e4a7875b6f993d6712f4c48c0" translate="yes" xml:space="preserve">
          <source>PowerPC 405 32-bit Embedded CPU.</source>
          <target state="translated">PowerPC 405 32 비트 내장 CPU.</target>
        </trans-unit>
        <trans-unit id="b1d2fd0956b324f2b71d45c79701e634006f0998" translate="yes" xml:space="preserve">
          <source>PowerPC 440 32-bit Embedded CPU.</source>
          <target state="translated">PowerPC 440 32 비트 내장 CPU.</target>
        </trans-unit>
        <trans-unit id="8c88a5ec0bad9b2ec3a6e912ad1b84fe1cb0e913" translate="yes" xml:space="preserve">
          <source>PowerPC and IBM RS6000&amp;mdash;</source>
          <target state="translated">PowerPC 및 IBM RS6000&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="bcb9720231f4eefcc2911c6644e67562366e664a" translate="yes" xml:space="preserve">
          <source>Pragmas accepted by GCC.</source>
          <target state="translated">GCC는 Pragma를 수락했습니다.</target>
        </trans-unit>
        <trans-unit id="ae3be2297868a8755878b8140bb470b2659e5173" translate="yes" xml:space="preserve">
          <source>Pragmas to control overflow and rounding behaviors are not implemented.</source>
          <target state="translated">오버플로 및 반올림 동작을 제어하는 ​​실습은 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8e93065e97687afdb6c2cb1807aa95de831b3446" translate="yes" xml:space="preserve">
          <source>Predefine &lt;var&gt;name&lt;/var&gt; as a macro, with definition &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">정의가 &lt;code&gt;1&lt;/code&gt; 인 매크로로 사전 정의 된 &lt;var&gt;name&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="e38583cb5384743db9afcc426cedec4f148c0b26" translate="yes" xml:space="preserve">
          <source>Predicate register (&amp;lsquo;</source>
          <target state="translated">술어 레지스터 ( '</target>
        </trans-unit>
        <trans-unit id="f6c24206b3789713e962d5bee080397fea9809bf" translate="yes" xml:space="preserve">
          <source>Predicate registers in register file A (A0&amp;ndash;A2 on C64X and higher, A1 and A2 otherwise).</source>
          <target state="translated">레지스터 파일 A의 레지스터를 선언합니다 (C64X 이상의 경우 A0&amp;ndash;A2, 그렇지 않은 경우 A1 및 A2).</target>
        </trans-unit>
        <trans-unit id="fec436f1165c01f7b8c12f56c12ec41ae48daa7c" translate="yes" xml:space="preserve">
          <source>Predicate registers in register file B (B0&amp;ndash;B2).</source>
          <target state="translated">레지스터 파일 B (B0&amp;ndash;B2)의 레지스터를 선언합니다.</target>
        </trans-unit>
        <trans-unit id="d010b8de73801ea6c16e7a693f380cb435e67997" translate="yes" xml:space="preserve">
          <source>Prefer 128-bit vector width for instructions.</source>
          <target state="translated">지침은 128 비트 벡터 너비를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c72722357c9f06e0451f0baf6353c7d5bd987c68" translate="yes" xml:space="preserve">
          <source>Prefer 256-bit vector width for instructions.</source>
          <target state="translated">명령에는 256 비트 벡터 너비를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3d1a90957e39dc52fe3e0a5dff721af2c1533ae9" translate="yes" xml:space="preserve">
          <source>Prefer 512-bit vector width for instructions.</source>
          <target state="translated">명령에는 512 비트 벡터 너비를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="55b3d6f2f24c6bd41aa8d455a302118a96706fdb" translate="yes" xml:space="preserve">
          <source>Prefer initialization to assignment in constructors.</source>
          <target state="translated">생성자의 할당보다 초기화를 선호하십시오.</target>
        </trans-unit>
        <trans-unit id="e5fe97372ea4c44c05ad1e9f80e485c5b8d2b708" translate="yes" xml:space="preserve">
          <source>Prefer word access when reading byte quantities.</source>
          <target state="translated">바이트 수량을 읽을 때 워드 액세스를 선호하십시오.</target>
        </trans-unit>
        <trans-unit id="751bcd963c78ac89d226c347c0db73a5eb17519e" translate="yes" xml:space="preserve">
          <source>Prefer zero-displacement conditional branches for conditional move instruction patterns. This can result in faster code on the SH4 processor.</source>
          <target state="translated">조건부 이동 명령 패턴에는 제로 변위 조건부 분기를 선호하십시오. 이로 인해 SH4 프로세서의 코드가 더 빨라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62927f12aebe8245ca7ccbec4d045c60284016e4" translate="yes" xml:space="preserve">
          <source>Preferentially allocate registers that allow short instruction generation. This can result in increased instruction count, so this may either reduce or increase overall code size.</source>
          <target state="translated">짧은 명령어 생성을 허용하는 레지스터를 우선적으로 할당하십시오. 이로 인해 명령어 수가 증가 할 수 있으므로 전체 코드 크기를 줄이거 나 늘릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1fdf593aa54fe21b57f9608b9af0f175a51f5bf" translate="yes" xml:space="preserve">
          <source>Prepend (do not prepend) a &amp;lsquo;</source>
          <target state="translated">앞에 '를 추가 (추가하지 마십시오)'</target>
        </trans-unit>
        <trans-unit id="7b1baabda5f4c155086c1133972437c2a11a8717" translate="yes" xml:space="preserve">
          <source>Preprocessor Options</source>
          <target state="translated">전 처리기 옵션</target>
        </trans-unit>
        <trans-unit id="c52cfab87f1f18bc931d7a53ed6f0f346f5be727" translate="yes" xml:space="preserve">
          <source>Preserve complete path information in the names of generated</source>
          <target state="translated">생성 된 이름으로 완전한 경로 정보 유지</target>
        </trans-unit>
        <trans-unit id="133f0b62da14d995af8aaf975f0c4e6493e01234" translate="yes" xml:space="preserve">
          <source>Pretend the symbol &lt;var&gt;symbol&lt;/var&gt; is undefined, to force linking of library modules to define it. You can use</source>
          <target state="translated">라이브러리 모듈을 강제로 연결하여 &lt;var&gt;symbol&lt;/var&gt; 을 정의 하려면 심볼 심볼 이 정의되지 않은 것으로 가정하십시오. 당신이 사용할 수있는</target>
        </trans-unit>
        <trans-unit id="93b748cdea3b771906f02431b0afee34e97035a0" translate="yes" xml:space="preserve">
          <source>Prevent floating-point registers from being used in any manner. This is necessary for compiling kernels that perform lazy context switching of floating-point registers. If you use this option and attempt to perform floating-point operations, the compiler aborts.</source>
          <target state="translated">부동 소수점 레지스터가 어떤 방식으로도 사용되지 않도록합니다. 부동 소수점 레지스터의 지연 컨텍스트 전환을 수행하는 커널을 컴파일하는 데 필요합니다. 이 옵션을 사용하고 부동 소수점 연산을 수행하려고하면 컴파일러가 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="bb7e629d281cc1130ee30ba469e70f725c11a1a9" translate="yes" xml:space="preserve">
          <source>Prevent the compiler from using indexing address modes. This avoids some rather obscure problems when compiling MIG generated code under MACH.</source>
          <target state="translated">컴파일러가 인덱싱 주소 모드를 사용하지 못하게합니다. 이렇게하면 MACH에서 MIG 생성 코드를 컴파일 할 때 다소 모호한 문제가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a884d00641db1ef92c5861d9f7679506da26ff4e" translate="yes" xml:space="preserve">
          <source>Prevent the reordering of instructions in the function prologue, or the merging of those instruction with the instructions in the function&amp;rsquo;s body. This means that all functions start with a recognizable set of instructions (or in fact one of a choice from a small set of different function prologues), and this information can be used to locate the start of functions inside an executable piece of code. The default is</source>
          <target state="translated">함수 프롤로그에서 명령어를 다시 정렬하거나 해당 명령어와 함수 본문의 명령어를 병합하는 것을 방지하십시오. 즉, 모든 기능은 인식 가능한 일련의 명령으로 시작합니다 (또는 실제로는 여러 다른 기능 프롤로그 중 하나 선택).이 정보는 실행 가능한 코드 조각 내에서 기능의 시작을 찾는 데 사용될 수 있습니다. 디폴트는</target>
        </trans-unit>
        <trans-unit id="8bee5f1a685fff3e9255748fa0a591a79f24269b" translate="yes" xml:space="preserve">
          <source>Prevents GCC from issuing a warning message if it finds more than one fast interrupt handler when it is compiling a file. The default is to issue a warning for each extra fast interrupt handler found, as the RX only supports one such interrupt.</source>
          <target state="translated">파일을 컴파일 할 때 둘 이상의 빠른 인터럽트 핸들러를 발견하면 GCC가 경고 메시지를 발행하지 못하게합니다. RX는 하나의 인터럽트 만 지원하므로 기본값은 발견 된 각 빠른 인터럽트 핸들러마다 경고를 발행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e537c0dc3e8d81002fc1ef4c91ba84299819e72d" translate="yes" xml:space="preserve">
          <source>Previous: &lt;a href=&quot;_0040encode#g_t_0040encode&quot;&gt;@encode&lt;/a&gt;, Up: &lt;a href=&quot;type-encoding#Type-encoding&quot;&gt;Type encoding&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="translated">이전 : &lt;a href=&quot;_0040encode#g_t_0040encode&quot;&gt;@encode&lt;/a&gt; , Up : &lt;a href=&quot;type-encoding#Type-encoding&quot;&gt;인코딩 유형&lt;/a&gt; [ &lt;a href=&quot;index#SEC_Contents&quot;&gt;목차&lt;/a&gt; ] [ &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;색인&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="0c298d2156eb911587b91d6784586e592c266917" translate="yes" xml:space="preserve">
          <source>Previous: &lt;a href=&quot;_0040encode#g_t_0040encode&quot;&gt;@encode&lt;/a&gt;, Up: &lt;a href=&quot;type-encoding#Type-encoding&quot;&gt;Type encoding&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="translated">Previous : &lt;a href=&quot;_0040encode#g_t_0040encode&quot;&gt;@encode&lt;/a&gt; , Up : &lt;a href=&quot;type-encoding#Type-encoding&quot;&gt;형식 인코딩&lt;/a&gt; [ &lt;a href=&quot;index#SEC_Contents&quot;&gt;목차&lt;/a&gt; ] [ &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;색인&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="c46b9f654c99730d96df95c0b87bec0a17545c4a" translate="yes" xml:space="preserve">
          <source>Previous: &lt;a href=&quot;basic-powerpc-built_002din-functions-available-on-isa-2_002e07#Basic-PowerPC-Built_002din-Functions-Available-on-ISA-2_002e07&quot;&gt;Basic PowerPC Built-in Functions Available on ISA 2.07&lt;/a&gt;, Up: &lt;a href=&quot;basic-powerpc-built_002din-functions#Basic-PowerPC-Built_002din-Functions&quot;&gt;Basic PowerPC Built-in Functions&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="translated">Previous : &lt;a href=&quot;basic-powerpc-built_002din-functions-available-on-isa-2_002e07#Basic-PowerPC-Built_002din-Functions-Available-on-ISA-2_002e07&quot;&gt;ISA 2.07&lt;/a&gt; 에서 사용 가능한 기본 PowerPC 내장 기능 , Up : &lt;a href=&quot;basic-powerpc-built_002din-functions#Basic-PowerPC-Built_002din-Functions&quot;&gt;기본 PowerPC 내장 기능&lt;/a&gt; [ &lt;a href=&quot;index#SEC_Contents&quot;&gt;목차&lt;/a&gt; ] [ &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;색인&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="45ae7dc171d8dbf2c108f57d090926498ec01d52" translate="yes" xml:space="preserve">
          <source>Previous: &lt;a href=&quot;basic-powerpc-built_002din-functions-available-on-isa-2_002e07#Basic-PowerPC-Built_002din-Functions-Available-on-ISA-2_002e07&quot;&gt;Basic PowerPC Built-in Functions Available on ISA 2.07&lt;/a&gt;, Up: &lt;a href=&quot;basic-powerpc-built_002din-functions#Basic-PowerPC-Built_002din-Functions&quot;&gt;Basic PowerPC Built-in Functions&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="translated">Previous : &lt;a href=&quot;basic-powerpc-built_002din-functions-available-on-isa-2_002e07#Basic-PowerPC-Built_002din-Functions-Available-on-ISA-2_002e07&quot;&gt;ISA 2.07&lt;/a&gt; 에서 사용 가능한 기본 PowerPC 내장 함수 , 위로 : &lt;a href=&quot;basic-powerpc-built_002din-functions#Basic-PowerPC-Built_002din-Functions&quot;&gt;기본 PowerPC 내장 함수&lt;/a&gt; [ &lt;a href=&quot;index#SEC_Contents&quot;&gt;목차&lt;/a&gt; ] [ &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;색인&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="9f033bea3c19731300ef9c88817c0cbd24e4a4db" translate="yes" xml:space="preserve">
          <source>Previous: &lt;a href=&quot;c99-thread_002dlocal-edits#C99-Thread_002dLocal-Edits&quot;&gt;C99 Thread-Local Edits&lt;/a&gt;, Up: &lt;a href=&quot;thread_002dlocal#Thread_002dLocal&quot;&gt;Thread-Local&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="translated">Previous : &lt;a href=&quot;c99-thread_002dlocal-edits#C99-Thread_002dLocal-Edits&quot;&gt;C99 스레드-로컬 편집&lt;/a&gt; , 위로 : &lt;a href=&quot;thread_002dlocal#Thread_002dLocal&quot;&gt;스레드-로컬&lt;/a&gt; [ &lt;a href=&quot;index#SEC_Contents&quot;&gt;목차&lt;/a&gt; ] [ &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;색인&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="92416ecc83e7012e1b2389fd283cb8d6c4bca85a" translate="yes" xml:space="preserve">
          <source>Previous: &lt;a href=&quot;c99-thread_002dlocal-edits#C99-Thread_002dLocal-Edits&quot;&gt;C99 Thread-Local Edits&lt;/a&gt;, Up: &lt;a href=&quot;thread_002dlocal#Thread_002dLocal&quot;&gt;Thread-Local&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="translated">Previous : &lt;a href=&quot;c99-thread_002dlocal-edits#C99-Thread_002dLocal-Edits&quot;&gt;C99 스레드 로컬 편집&lt;/a&gt; , 위로 : &lt;a href=&quot;thread_002dlocal#Thread_002dLocal&quot;&gt;스레드 로컬&lt;/a&gt; [ &lt;a href=&quot;index#SEC_Contents&quot;&gt;목차&lt;/a&gt; ] [ &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;색인&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="9f3249c5747ff73558c59477858dab2add894b11" translate="yes" xml:space="preserve">
          <source>Previous: &lt;a href=&quot;dynamically-registering-methods#Dynamically-registering-methods&quot;&gt;Dynamically registering methods&lt;/a&gt;, Up: &lt;a href=&quot;messaging-with-the-gnu-objective_002dc-runtime#Messaging-with-the-GNU-Objective_002dC-runtime&quot;&gt;Messaging with the GNU Objective-C runtime&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="translated">Previous : &lt;a href=&quot;dynamically-registering-methods#Dynamically-registering-methods&quot;&gt;동적으로 메서드 등록&lt;/a&gt; , Up : &lt;a href=&quot;messaging-with-the-gnu-objective_002dc-runtime#Messaging-with-the-GNU-Objective_002dC-runtime&quot;&gt;GNU Objective-C 런타임을 사용한 메시징&lt;/a&gt; [ &lt;a href=&quot;index#SEC_Contents&quot;&gt;목차&lt;/a&gt; ] [ &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;색인&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="095b2c8cec2a9ee9cd6a1fc1d2c2268ef5e58bb5" translate="yes" xml:space="preserve">
          <source>Previous: &lt;a href=&quot;dynamically-registering-methods#Dynamically-registering-methods&quot;&gt;Dynamically registering methods&lt;/a&gt;, Up: &lt;a href=&quot;messaging-with-the-gnu-objective_002dc-runtime#Messaging-with-the-GNU-Objective_002dC-runtime&quot;&gt;Messaging with the GNU Objective-C runtime&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="translated">Previous : &lt;a href=&quot;dynamically-registering-methods#Dynamically-registering-methods&quot;&gt;동적으로 메소드 등록&lt;/a&gt; , Up : &lt;a href=&quot;messaging-with-the-gnu-objective_002dc-runtime#Messaging-with-the-GNU-Objective_002dC-runtime&quot;&gt;GNU Objective-C 런타임으로 메시징&lt;/a&gt; [ &lt;a href=&quot;index#SEC_Contents&quot;&gt;목차&lt;/a&gt; ] [ &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;색인&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="597300060534fa0401e363904c20fc0185b2beaa" translate="yes" xml:space="preserve">
          <source>Previous: &lt;a href=&quot;environment-variables#Environment-Variables&quot;&gt;Environment Variables&lt;/a&gt;, Up: &lt;a href=&quot;invoking-gcc#Invoking-GCC&quot;&gt;Invoking GCC&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="translated">Previous : &lt;a href=&quot;environment-variables#Environment-Variables&quot;&gt;환경 변수&lt;/a&gt; , Up : &lt;a href=&quot;invoking-gcc#Invoking-GCC&quot;&gt;GCC 호출&lt;/a&gt; [ &lt;a href=&quot;index#SEC_Contents&quot;&gt;목차&lt;/a&gt; ] [ &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;색인&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="8f89899827d8a560e31e2ca14d0a8300f657be83" translate="yes" xml:space="preserve">
          <source>Previous: &lt;a href=&quot;environment-variables#Environment-Variables&quot;&gt;Environment Variables&lt;/a&gt;, Up: &lt;a href=&quot;invoking-gcc#Invoking-GCC&quot;&gt;Invoking GCC&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="translated">Previous : &lt;a href=&quot;environment-variables#Environment-Variables&quot;&gt;환경 변수&lt;/a&gt; , Up : &lt;a href=&quot;invoking-gcc#Invoking-GCC&quot;&gt;GCC 호출&lt;/a&gt; [ &lt;a href=&quot;index#SEC_Contents&quot;&gt;목차&lt;/a&gt; ] [ &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;색인&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="f2998325d9fc9a4736bf01e439e1fca60b9b2e42" translate="yes" xml:space="preserve">
          <source>Previous: &lt;a href=&quot;fast-enumeration-details#Fast-enumeration-details&quot;&gt;Fast enumeration details&lt;/a&gt;, Up: &lt;a href=&quot;fast-enumeration#Fast-enumeration&quot;&gt;Fast enumeration&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="translated">Previous : &lt;a href=&quot;fast-enumeration-details#Fast-enumeration-details&quot;&gt;빠른 열거 세부 사항&lt;/a&gt; , Up : &lt;a href=&quot;fast-enumeration#Fast-enumeration&quot;&gt;빠른 열거&lt;/a&gt; [ &lt;a href=&quot;index#SEC_Contents&quot;&gt;목차&lt;/a&gt; ] [ &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;색인&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="3abd0fcac2246de54cbf842bcf5c2d572e95cf49" translate="yes" xml:space="preserve">
          <source>Previous: &lt;a href=&quot;fast-enumeration-details#Fast-enumeration-details&quot;&gt;Fast enumeration details&lt;/a&gt;, Up: &lt;a href=&quot;fast-enumeration#Fast-enumeration&quot;&gt;Fast enumeration&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="translated">Previous : &lt;a href=&quot;fast-enumeration-details#Fast-enumeration-details&quot;&gt;빠른 열거 세부 사항&lt;/a&gt; , Up : &lt;a href=&quot;fast-enumeration#Fast-enumeration&quot;&gt;빠른 열거&lt;/a&gt; [ &lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt; ] [ &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="01b241e71cd4dc628aefbb9fd607bdcfacb287a1" translate="yes" xml:space="preserve">
          <source>Previous: &lt;a href=&quot;gcov_002dtool-intro#Gcov_002dtool-Intro&quot;&gt;Gcov-tool Intro&lt;/a&gt;, Up: &lt;a href=&quot;gcov_002dtool#Gcov_002dtool&quot;&gt;Gcov-tool&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="translated">이전 : &lt;a href=&quot;gcov_002dtool-intro#Gcov_002dtool-Intro&quot;&gt;Gcov-tool 소개&lt;/a&gt; , 위로 : &lt;a href=&quot;gcov_002dtool#Gcov_002dtool&quot;&gt;Gcov-tool&lt;/a&gt; [ &lt;a href=&quot;index#SEC_Contents&quot;&gt;목차&lt;/a&gt; ] [ &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;색인&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="0cd478c56630e085181033925575eebae41d495c" translate="yes" xml:space="preserve">
          <source>Previous: &lt;a href=&quot;gcov_002dtool-intro#Gcov_002dtool-Intro&quot;&gt;Gcov-tool Intro&lt;/a&gt;, Up: &lt;a href=&quot;gcov_002dtool#Gcov_002dtool&quot;&gt;Gcov-tool&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="translated">이전 : &lt;a href=&quot;gcov_002dtool-intro#Gcov_002dtool-Intro&quot;&gt;Gcov 도구 소개&lt;/a&gt; , 위로 : &lt;a href=&quot;gcov_002dtool#Gcov_002dtool&quot;&gt;Gcov 도구&lt;/a&gt; [ &lt;a href=&quot;index#SEC_Contents&quot;&gt;목차&lt;/a&gt; ] [ &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;색인&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="4a9566099b54e5c67ad5605d031fa9346aeb2bbe" translate="yes" xml:space="preserve">
          <source>Previous: &lt;a href=&quot;global-register-variables#Global-Register-Variables&quot;&gt;Global Register Variables&lt;/a&gt;, Up: &lt;a href=&quot;explicit-register-variables#Explicit-Register-Variables&quot;&gt;Explicit Register Variables&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="translated">Previous : &lt;a href=&quot;global-register-variables#Global-Register-Variables&quot;&gt;글로벌 레지스터 변수&lt;/a&gt; , Up : &lt;a href=&quot;explicit-register-variables#Explicit-Register-Variables&quot;&gt;명시 적 레지스터 변수&lt;/a&gt; [ &lt;a href=&quot;index#SEC_Contents&quot;&gt;목차&lt;/a&gt; ] [ &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;색인&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="2e40d48fc32253bef8628625302a0abbcde80f82" translate="yes" xml:space="preserve">
          <source>Previous: &lt;a href=&quot;global-register-variables#Global-Register-Variables&quot;&gt;Global Register Variables&lt;/a&gt;, Up: &lt;a href=&quot;explicit-register-variables#Explicit-Register-Variables&quot;&gt;Explicit Register Variables&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="translated">Previous : &lt;a href=&quot;global-register-variables#Global-Register-Variables&quot;&gt;글로벌 레지스터 변수&lt;/a&gt; , Up : &lt;a href=&quot;explicit-register-variables#Explicit-Register-Variables&quot;&gt;명시 적 레지스터 변수&lt;/a&gt; [ &lt;a href=&quot;index#SEC_Contents&quot;&gt;목차&lt;/a&gt; ] [ &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;색인&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="e78f20be2ed14e47d0193eab14570be8658e8dcd" translate="yes" xml:space="preserve">
          <source>Previous: &lt;a href=&quot;modifiers#Modifiers&quot;&gt;Modifiers&lt;/a&gt;, Up: &lt;a href=&quot;constraints#Constraints&quot;&gt;Constraints&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="translated">Previous : &lt;a href=&quot;modifiers#Modifiers&quot;&gt;수정 자&lt;/a&gt; , Up : &lt;a href=&quot;constraints#Constraints&quot;&gt;제약&lt;/a&gt; [ &lt;a href=&quot;index#SEC_Contents&quot;&gt;목차&lt;/a&gt; ] [ &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;색인&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="180c60ac0f109d44e10ade3943d2c55400d71f8d" translate="yes" xml:space="preserve">
          <source>Previous: &lt;a href=&quot;modifiers#Modifiers&quot;&gt;Modifiers&lt;/a&gt;, Up: &lt;a href=&quot;constraints#Constraints&quot;&gt;Constraints&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="translated">Previous : &lt;a href=&quot;modifiers#Modifiers&quot;&gt;수정 자&lt;/a&gt; , 위로 : &lt;a href=&quot;constraints#Constraints&quot;&gt;제약 조건&lt;/a&gt; [ &lt;a href=&quot;index#SEC_Contents&quot;&gt;목차&lt;/a&gt; ] [ &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;색인&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="71dcd5c672b6e4a395348302781c78ca4d6c6269" translate="yes" xml:space="preserve">
          <source>Previous: &lt;a href=&quot;non_002dbugs#Non_002dbugs&quot;&gt;Non-bugs&lt;/a&gt;, Up: &lt;a href=&quot;trouble#Trouble&quot;&gt;Trouble&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="translated">Previous : &lt;a href=&quot;non_002dbugs#Non_002dbugs&quot;&gt;비 버그&lt;/a&gt; , Up : &lt;a href=&quot;trouble#Trouble&quot;&gt;문제&lt;/a&gt; [ &lt;a href=&quot;index#SEC_Contents&quot;&gt;목차&lt;/a&gt; ] [ &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;색인&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="2690cc6bd85085d1a20978cb1ff148ed57eeb42a" translate="yes" xml:space="preserve">
          <source>Previous: &lt;a href=&quot;non_002dbugs#Non_002dbugs&quot;&gt;Non-bugs&lt;/a&gt;, Up: &lt;a href=&quot;trouble#Trouble&quot;&gt;Trouble&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="translated">Previous : &lt;a href=&quot;non_002dbugs#Non_002dbugs&quot;&gt;비 버그&lt;/a&gt; , 위 : &lt;a href=&quot;trouble#Trouble&quot;&gt;문제&lt;/a&gt; [ &lt;a href=&quot;index#SEC_Contents&quot;&gt;목차&lt;/a&gt; ] [ &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;색인&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="486364a1dc0ac59682deece8e5ab665d6c4c2b74" translate="yes" xml:space="preserve">
          <source>Previous: &lt;a href=&quot;paired_002dsingle-built_002din-functions#Paired_002dSingle-Built_002din-Functions&quot;&gt;Paired-Single Built-in Functions&lt;/a&gt;, Up: &lt;a href=&quot;mips-loongson-built_002din-functions#MIPS-Loongson-Built_002din-Functions&quot;&gt;MIPS Loongson Built-in Functions&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="translated">Previous : &lt;a href=&quot;paired_002dsingle-built_002din-functions#Paired_002dSingle-Built_002din-Functions&quot;&gt;페어링 된 단일 내장 기능&lt;/a&gt; , Up : &lt;a href=&quot;mips-loongson-built_002din-functions#MIPS-Loongson-Built_002din-Functions&quot;&gt;MIPS Loongson 내장 기능&lt;/a&gt; [ &lt;a href=&quot;index#SEC_Contents&quot;&gt;목차&lt;/a&gt; ] [ &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;색인&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="518a1b2a1a9d78ecacf627dac6376da5b9566530" translate="yes" xml:space="preserve">
          <source>Previous: &lt;a href=&quot;paired_002dsingle-built_002din-functions#Paired_002dSingle-Built_002din-Functions&quot;&gt;Paired-Single Built-in Functions&lt;/a&gt;, Up: &lt;a href=&quot;mips-loongson-built_002din-functions#MIPS-Loongson-Built_002din-Functions&quot;&gt;MIPS Loongson Built-in Functions&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="translated">Previous : 한 &lt;a href=&quot;paired_002dsingle-built_002din-functions#Paired_002dSingle-Built_002din-Functions&quot;&gt;쌍의 내장 함수&lt;/a&gt; , 위로 : &lt;a href=&quot;mips-loongson-built_002din-functions#MIPS-Loongson-Built_002din-Functions&quot;&gt;MIPS Loongson 내장 함수&lt;/a&gt; [ &lt;a href=&quot;index#SEC_Contents&quot;&gt;목차&lt;/a&gt; ] [ &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;색인&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="5a3c60991462b709bc1ab9bb096c67236fb69620" translate="yes" xml:space="preserve">
          <source>Previous: &lt;a href=&quot;powerpc-altivec-built_002din-functions-available-on-isa-2_002e07#PowerPC-AltiVec-Built_002din-Functions-Available-on-ISA-2_002e07&quot;&gt;PowerPC AltiVec Built-in Functions Available on ISA 2.07&lt;/a&gt;, Up: &lt;a href=&quot;powerpc-altivec_002fvsx-built_002din-functions#PowerPC-AltiVec_002fVSX-Built_002din-Functions&quot;&gt;PowerPC AltiVec/VSX Built-in Functions&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="translated">Previous : &lt;a href=&quot;powerpc-altivec-built_002din-functions-available-on-isa-2_002e07#PowerPC-AltiVec-Built_002din-Functions-Available-on-ISA-2_002e07&quot;&gt;ISA 2.07&lt;/a&gt; 에서 사용 가능한 PowerPC AltiVec 내장 기능 , Up : &lt;a href=&quot;powerpc-altivec_002fvsx-built_002din-functions#PowerPC-AltiVec_002fVSX-Built_002din-Functions&quot;&gt;PowerPC AltiVec / VSX 내장 기능&lt;/a&gt; [ &lt;a href=&quot;index#SEC_Contents&quot;&gt;목차&lt;/a&gt; ] [ &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;색인&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="8a6424fd89847064955d1584a816d8d119f016ca" translate="yes" xml:space="preserve">
          <source>Previous: &lt;a href=&quot;powerpc-altivec-built_002din-functions-available-on-isa-2_002e07#PowerPC-AltiVec-Built_002din-Functions-Available-on-ISA-2_002e07&quot;&gt;PowerPC AltiVec Built-in Functions Available on ISA 2.07&lt;/a&gt;, Up: &lt;a href=&quot;powerpc-altivec_002fvsx-built_002din-functions#PowerPC-AltiVec_002fVSX-Built_002din-Functions&quot;&gt;PowerPC AltiVec/VSX Built-in Functions&lt;/a&gt; [&lt;a href=&quot;index#SEC_Contents&quot;&gt;Contents&lt;/a&gt;][&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Index&lt;/a&gt;]</source>
          <target state="translated">Previous : &lt;a href=&quot;powerpc-altivec-built_002din-functions-available-on-isa-2_002e07#PowerPC-AltiVec-Built_002din-Functions-Available-on-ISA-2_002e07&quot;&gt;ISA 2.07&lt;/a&gt; 에서 사용할 수있는 PowerPC AltiVec 내장 함수 , Up : &lt;a href=&quot;powerpc-altivec_002fvsx-built_002din-functions#PowerPC-AltiVec_002fVSX-Built_002din-Functions&quot;&gt;PowerPC AltiVec / VSX 내장 함수&lt;/a&gt; [ &lt;a href=&quot;index#SEC_Contents&quot;&gt;목차&lt;/a&gt; ] [ &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;색인&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="5070ca712488a6295aeb93bb4b823f413e03dde1" translate="yes" xml:space="preserve">
          <source>Print (on standard error output) the commands executed to run the stages of compilation. Also print the version number of the compiler driver program and of the preprocessor and the compiler proper.</source>
          <target state="translated">컴파일 단계를 실행하기 위해 실행 된 명령을 인쇄합니다 (표준 오류 출력시). 또한 컴파일러 드라이버 프로그램과 전 처리기 및 컴파일러의 버전 번호를 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="f0802ef33bb80e0daadac78e85825604f940dbf7" translate="yes" xml:space="preserve">
          <source>Print (on the standard output) a description of target-specific command-line options for each tool. For some targets extra target-specific information may also be printed.</source>
          <target state="translated">각 도구에 대한 대상별 명령 행 옵션에 대한 설명을 표준 출력으로 인쇄하십시오. 일부 대상의 경우 추가 대상별 정보도 인쇄 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da44c4f450112c4e0f6f8b3b80edf560950a6ee6" translate="yes" xml:space="preserve">
          <source>Print (on the standard output) a description of the command-line options understood by &lt;code&gt;gcc&lt;/code&gt;. If the</source>
          <target state="translated">&lt;code&gt;gcc&lt;/code&gt; 가 이해하는 명령 행 옵션에 대한 설명을 표준 출력으로 인쇄하십시오 . 만약</target>
        </trans-unit>
        <trans-unit id="e18b1edf66bd2215edee93ad1bfe2475848c1c40" translate="yes" xml:space="preserve">
          <source>Print (on the standard output) a description of the command-line options understood by the compiler that fit into all specified classes and qualifiers. These are the supported classes:</source>
          <target state="translated">지정된 모든 클래스와 한정자에 맞는 컴파일러가 이해하는 명령 줄 옵션에 대한 설명을 표준 출력에 인쇄하십시오. 지원되는 클래스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="36e2db25cdaf136a1b1871f7bddede044a014af0" translate="yes" xml:space="preserve">
          <source>Print (or do not print) additional debug information when compiling. The default is to not print debug information.</source>
          <target state="translated">컴파일 할 때 추가 디버그 정보를 인쇄합니다 (또는 인쇄하지 않습니다). 디폴트는 디버그 정보를 인쇄하지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="042a1c2bccf30839985d02fecb0aaa588016c586" translate="yes" xml:space="preserve">
          <source>Print &lt;var&gt;str&lt;/var&gt; as an error message. &lt;var&gt;str&lt;/var&gt; is terminated by a newline. Use this when inconsistent options are detected.</source>
          <target state="translated">&lt;var&gt;str&lt;/var&gt; 을 오류 메시지로 인쇄하십시오 . &lt;var&gt;str&lt;/var&gt; 은 개행으로 종료됩니다. 일치하지 않는 옵션이 감지 될 때 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="646c20558d20e2f30241cc9574d344b39d2a71e9" translate="yes" xml:space="preserve">
          <source>Print CPU tuning information as comment in assembler file. This is an option used only for regression testing of the compiler and not intended for ordinary use in compiling code. This option is disabled by default.</source>
          <target state="translated">CPU 튜닝 정보를 어셈블러 파일에 주석으로 인쇄하십시오. 이 옵션은 컴파일러의 회귀 테스트에만 사용되며 컴파일 코드에서 일반적인 용도로는 사용되지 않습니다. 이 옵션은 기본적으로 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c02ead981dc46c74eca673ebbadeb5775102eb4" translate="yes" xml:space="preserve">
          <source>Print a raw representation of the tree. By default, trees are pretty-printed into a C-like representation.</source>
          <target state="translated">원시 트리 표현을 인쇄하십시오. 기본적으로 트리는 C와 같은 모양으로 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="bee9976317d77665142eb597fb744cf4a5bc63c3" translate="yes" xml:space="preserve">
          <source>Print an absolute memory reference.</source>
          <target state="translated">절대 메모리 참조를 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="c1b62ec38c8c02ce83661de096266f4e8ad36d5d" translate="yes" xml:space="preserve">
          <source>Print detailed optimization information. This includes &amp;lsquo;</source>
          <target state="translated">자세한 최적화 정보를 인쇄하십시오. 여기에는 '</target>
        </trans-unit>
        <trans-unit id="747925ea13ebc5265845c242e39f7d5de361cc9c" translate="yes" xml:space="preserve">
          <source>Print fix-it hints to stderr in unified diff format, after any diagnostics are printed. For example:</source>
          <target state="translated">진단이 인쇄 된 후 통합 diff 형식으로 stderr에 수정 사항 힌트를 인쇄하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="27e48e9709e199f67d90728d88acda8122e690ad" translate="yes" xml:space="preserve">
          <source>Print full gcda filename.</source>
          <target state="translated">전체 gcda 파일 이름을 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="b3444c534ef235bd7cfb2bb1457050c5df19fa98" translate="yes" xml:space="preserve">
          <source>Print function level overlap score.</source>
          <target state="translated">기능 레벨 오버랩 점수를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="2259612d90015512d8565367d9b66e6d1907b7e3" translate="yes" xml:space="preserve">
          <source>Print information about missed optimizations. Individual passes control which information to include in the output.</source>
          <target state="translated">누락 된 최적화에 대한 정보를 인쇄하십시오. 개별 패스는 출력에 포함 할 정보를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="0e737c134e058a6b5be3c38b4d61e9060cbe2d6f" translate="yes" xml:space="preserve">
          <source>Print information when an optimization is successfully applied. It is up to a pass to decide which information is relevant. For example, the vectorizer passes print the source location of loops which are successfully vectorized.</source>
          <target state="translated">최적화가 성공적으로 적용되면 정보를 인쇄하십시오. 어떤 정보가 관련이 있는지를 결정하는 것은 통과에 달려 있습니다. 예를 들어, 벡터 라이저는 성공적으로 벡터화 된 루프의 소스 ​​위치를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="49e8d2891f1bb00bf2fce45c40fe769f980367c0" translate="yes" xml:space="preserve">
          <source>Print object level overlap score.</source>
          <target state="translated">객체 레벨 오버랩 점수를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="3a95fbc869807d22e5b89ec0f92871dcddcd83ac" translate="yes" xml:space="preserve">
          <source>Print on</source>
          <target state="translated">인쇄</target>
        </trans-unit>
        <trans-unit id="fdc5672b8cdd0196a1822504903f9194000cffdc" translate="yes" xml:space="preserve">
          <source>Print raw symbol name (without syntax-specific prefixes).</source>
          <target state="translated">원시 기호 이름을 인쇄하십시오 (구문 별 접두어 없음).</target>
        </trans-unit>
        <trans-unit id="8b3eb16e33ebf816827fd23a1d5134fcb39c5577" translate="yes" xml:space="preserve">
          <source>Print the DImode name of the register.</source>
          <target state="translated">레지스터의 DI 모드 이름을 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="8cbb39fe370973258d3221791eb533a79143c1a4" translate="yes" xml:space="preserve">
          <source>Print the HImode name of the register.</source>
          <target state="translated">레지스터의 HI 모드 이름을 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="5f0523fe616c1a4ec29efecc044a8b533dbfc088" translate="yes" xml:space="preserve">
          <source>Print the QImode name for a &amp;ldquo;high&amp;rdquo; register.</source>
          <target state="translated">&quot;high&quot;레지스터의 QImode 이름을 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="cba0544fdad24e8c71fa2998d0fc17006f470a5d" translate="yes" xml:space="preserve">
          <source>Print the QImode name of the register.</source>
          <target state="translated">레지스터의 QImode 이름을 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="415fe8734ed5c7ca7d367010aad83e19c898fcd9" translate="yes" xml:space="preserve">
          <source>Print the SImode name of the register.</source>
          <target state="translated">레지스터의 SImode 이름을 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="7bde1647cee4db781bd592bee36a2a9579dff9ad" translate="yes" xml:space="preserve">
          <source>Print the address in Double Integer (DImode) mode (8 bytes) when the target is 64-bit. Otherwise mode is unspecified (VOIDmode).</source>
          <target state="translated">대상이 64 비트 인 경우 이중 정수 (DImode) 모드 (8 바이트)로 주소를 인쇄하십시오. 그렇지 않으면 모드가 지정되지 않습니다 (VOIDmode).</target>
        </trans-unit>
        <trans-unit id="0a2a748643cbf5bccb4c8b64fbb809daa63616ff" translate="yes" xml:space="preserve">
          <source>Print the address of each node. Usually this is not meaningful as it changes according to the environment and source file. Its primary use is for tying up a dump file with a debug environment.</source>
          <target state="translated">각 노드의 주소를 인쇄하십시오. 일반적으로 환경 및 소스 파일에 따라 변경되므로 의미가 없습니다. 기본 용도는 덤프 파일을 디버그 환경과 묶는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c30bf938013bc01150cd4223148df68eeb709db3" translate="yes" xml:space="preserve">
          <source>Print the compiler version (for example, &lt;code&gt;3.0&lt;/code&gt;, &lt;code&gt;6.3.0&lt;/code&gt; or &lt;code&gt;7&lt;/code&gt;)&amp;mdash;and don&amp;rsquo;t do anything else. This is the compiler version used in filesystem paths and specs. Depending on how the compiler has been configured it can be just a single number (major version), two numbers separated by a dot (major and minor version) or three numbers separated by dots (major, minor and patchlevel version).</source>
          <target state="translated">컴파일러 버전 (예 : &lt;code&gt;3.0&lt;/code&gt; , &lt;code&gt;6.3.0&lt;/code&gt; 또는 &lt;code&gt;7&lt;/code&gt; )을 인쇄하고 다른 작업은 수행하지 마십시오. 파일 시스템 경로 및 사양에 사용되는 컴파일러 버전입니다. 컴파일러가 구성된 방식에 따라 단일 숫자 (주 버전), 점으로 구분 된 두 숫자 (주 버전 및 부 버전) 또는 점으로 구분 된 세 가지 숫자 (주, 부 버전 및 패치 수준 버전) 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39f02afa5381880ed9364aabcf135637b524d215" translate="yes" xml:space="preserve">
          <source>Print the compiler&amp;rsquo;s built-in specs&amp;mdash;and don&amp;rsquo;t do anything else. (This is used when GCC itself is being built.) See &lt;a href=&quot;spec-files#Spec-Files&quot;&gt;Spec Files&lt;/a&gt;.</source>
          <target state="translated">컴파일러의 내장 사양을 인쇄하고 다른 작업을 수행하지 마십시오. GCC 자체를 빌드 할 때 사용됩니다. &lt;a href=&quot;spec-files#Spec-Files&quot;&gt;스펙 파일을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="653f7adb65f1f84d8d88241f8ddf357af1eec6c5" translate="yes" xml:space="preserve">
          <source>Print the compiler&amp;rsquo;s target machine (for example, &amp;lsquo;</source>
          <target state="translated">컴파일러의 대상 기계를 인쇄하십시오 (예 : '</target>
        </trans-unit>
        <trans-unit id="2ea813d3d56acd15b7aece5721398087dd287686" translate="yes" xml:space="preserve">
          <source>Print the directory name corresponding to the multilib selected by any other switches present in the command line. This directory is supposed to exist in &lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt;.</source>
          <target state="translated">명령 행에있는 다른 스위치가 선택한 multilib에 해당하는 디렉토리 이름을 인쇄하십시오. 이 디렉토리는 &lt;code&gt;GCC_EXEC_PREFIX&lt;/code&gt; 에 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="ce50f8d87d282115171e0d700a3119dab66c3b68" translate="yes" xml:space="preserve">
          <source>Print the full absolute name of the library file &lt;var&gt;library&lt;/var&gt; that would be used when linking&amp;mdash;and don&amp;rsquo;t do anything else. With this option, GCC does not compile or link anything; it just prints the file name.</source>
          <target state="translated">링크 할 때 사용될 라이브러리 파일 &lt;var&gt;library&lt;/var&gt; 의 전체 절대 이름을 인쇄하고 다른 작업은 수행하지 마십시오. 이 옵션을 사용하면 GCC는 아무것도 컴파일하거나 링크하지 않습니다. 파일 이름 만 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="2d08bb037870c1271f6d358ce7e39175cb5c6846" translate="yes" xml:space="preserve">
          <source>Print the full compiler version&amp;mdash;and don&amp;rsquo;t do anything else. The output is always three numbers separated by dots, major, minor and patchlevel version.</source>
          <target state="translated">전체 컴파일러 버전을 인쇄하고 다른 작업을 수행하지 마십시오. 출력은 항상 점, 주 버전, 부 버전 및 패치 수준 버전으로 구분 된 세 개의 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="1ca2b71a9e603f4ac7cb5b1a49646b6058026d67" translate="yes" xml:space="preserve">
          <source>Print the label name with no punctuation.</source>
          <target state="translated">문장 부호없이 레이블 이름을 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="ed777f4d8158d9a13715e5d83bcf213db1f9294b" translate="yes" xml:space="preserve">
          <source>Print the mapping from multilib directory names to compiler switches that enable them. The directory name is separated from the switches by &amp;lsquo;</source>
          <target state="translated">multilib 디렉토리 이름에서이를 가능하게하는 컴파일러 스위치로의 맵핑을 인쇄하십시오. 디렉토리 이름은 스위치와 '</target>
        </trans-unit>
        <trans-unit id="b73d8c440e7cc936048904194d2e85dfdb15e4ef" translate="yes" xml:space="preserve">
          <source>Print the name and the counter upper bound for all debug counters.</source>
          <target state="translated">모든 디버그 카운터의 이름과 카운터 상한을 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="c0f3c0f3c07600ebb279734d69613c90e09b8dbd" translate="yes" xml:space="preserve">
          <source>Print the name of each header file used, in addition to other normal activities. Each name is indented to show how deep in the &amp;lsquo;</source>
          <target state="translated">다른 일반적인 활동 외에 사용 된 각 헤더 파일의 이름을 인쇄하십시오. 각 이름은 '</target>
        </trans-unit>
        <trans-unit id="6ed5656674995024e55926271a786ceb4ef7c456" translate="yes" xml:space="preserve">
          <source>Print the name of the configured installation directory and a list of program and library directories &lt;code&gt;gcc&lt;/code&gt; searches&amp;mdash;and don&amp;rsquo;t do anything else.</source>
          <target state="translated">구성된 설치 디렉토리의 이름과 &lt;code&gt;gcc&lt;/code&gt; 가 검색 하는 프로그램 및 라이브러리 디렉토리의 목록을 인쇄하고 다른 작업을 수행하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="f46fbec7a98d95993ab6d7180f46da35309a305c" translate="yes" xml:space="preserve">
          <source>Print the opcode suffix for the size of the current integer operand (one of &lt;code&gt;b&lt;/code&gt;/&lt;code&gt;w&lt;/code&gt;/&lt;code&gt;l&lt;/code&gt;/&lt;code&gt;q&lt;/code&gt;).</source>
          <target state="translated">현재 정수 피연산자 크기 ( &lt;code&gt;b&lt;/code&gt; / &lt;code&gt;w&lt;/code&gt; / &lt;code&gt;l&lt;/code&gt; / &lt;code&gt;q&lt;/code&gt; 중 하나)의 크기에 대한 opcode 접미 부를 인쇄하십시오 .</target>
        </trans-unit>
        <trans-unit id="908b57b33b152b029092573720dba6a435ce6981" translate="yes" xml:space="preserve">
          <source>Print the path to OS libraries for the selected multiarch, relative to some</source>
          <target state="translated">선택한 멀티 아키텍처에 대한 OS 라이브러리의 경로를</target>
        </trans-unit>
        <trans-unit id="5d7b39edfb2bb437d185c29750569c1585d1f048" translate="yes" xml:space="preserve">
          <source>Print the path to OS libraries for the selected multilib, relative to some</source>
          <target state="translated">선택된 multilib에 대한 OS 라이브러리의 경로를</target>
        </trans-unit>
        <trans-unit id="b628c9460b668c00eb8e6efa459a4b3817bd622d" translate="yes" xml:space="preserve">
          <source>Print the suffix added to the target sysroot when searching for headers, or give an error if the compiler is not configured with such a suffix&amp;mdash;and don&amp;rsquo;t do anything else.</source>
          <target state="translated">헤더를 검색 할 때 대상 sysroot에 추가 된 접미사를 인쇄하거나 컴파일러에 이러한 접미사를 구성하지 않은 경우 오류를 표시하고 다른 작업을 수행하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="08d61da80381f2354abfcc2dc79c82da27bcfcde" translate="yes" xml:space="preserve">
          <source>Print the target sysroot directory that is used during compilation. This is the target sysroot specified either at configure time or using the</source>
          <target state="translated">컴파일 중에 사용되는 대상 sysroot 디렉토리를 인쇄하십시오. 이것은 구성 시간에 또는</target>
        </trans-unit>
        <trans-unit id="38b6abf4c9502a0a96a0b149ec935db21970d271" translate="yes" xml:space="preserve">
          <source>Print verbose information about optimizations, such as certain transformations, more detailed messages about decisions etc.</source>
          <target state="translated">특정 변환, 의사 결정에 대한 자세한 메시지 등과 같은 최적화에 대한 자세한 정보를 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="a2dcd67e0df70361f07cda6c2139ad5ffd3e3acd" translate="yes" xml:space="preserve">
          <source>Print verbose informations related to basic blocks and arcs.</source>
          <target state="translated">기본 블록 및 호와 관련된 자세한 정보를 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="14433cdcc593ba724150c5d3b1d1053f1e28730c" translate="yes" xml:space="preserve">
          <source>Print warning messages for constructs found in system header files. Warnings from system headers are normally suppressed, on the assumption that they usually do not indicate real problems and would only make the compiler output harder to read. Using this command-line option tells GCC to emit warnings from system headers as if they occurred in user code. However, note that using</source>
          <target state="translated">시스템 헤더 파일에서 찾은 구문에 대한 경고 메시지를 인쇄합니다. 시스템 헤더의 경고는 일반적으로 실제 문제를 나타내지 않으며 컴파일러 출력을 읽기 어렵게 만든다는 가정하에 억제됩니다. 이 명령 줄 옵션을 사용하면 GCC가 마치 사용자 코드에서 발생한 것처럼 시스템 헤더에서 경고를 보내도록 지시합니다. 그러나</target>
        </trans-unit>
        <trans-unit id="483c1121bee3466e31656e5ccaa4978d23e0bae2" translate="yes" xml:space="preserve">
          <source>Printable strings which are the name of the current function.</source>
          <target state="translated">현재 함수의 이름 인 인쇄 가능한 문자열</target>
        </trans-unit>
        <trans-unit id="b65afc72a52b24c7e17f59c175dc14fa999357ad" translate="yes" xml:space="preserve">
          <source>Printing GCC configuration info, statistics, and debugging dumps.</source>
          <target state="translated">GCC 구성 정보, 통계 및 디버깅 덤프 인쇄</target>
        </trans-unit>
        <trans-unit id="223d9059a8851156459124a029c324e8d582a617" translate="yes" xml:space="preserve">
          <source>Prints &lt;var&gt;string&lt;/var&gt; as a compiler message on compilation. The message is informational only, and is neither a compilation warning nor an error. Newlines can be included in the string by using the &amp;lsquo;</source>
          <target state="translated">컴파일시 &lt;var&gt;string&lt;/var&gt; 을 컴파일러 메시지로 인쇄 합니다 . 메시지는 정보 제공 용이며 컴파일 경고 나 오류가 아닙니다. '를 사용하여 줄 바꿈을 문자열에 포함시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba052fde4908541fb5507b0c0b8fa5890f691843" translate="yes" xml:space="preserve">
          <source>Prints a report with internal details on the workings of the link-time optimizer. The contents of this report vary from version to version. It is meant to be useful to GCC developers when processing object files in LTO mode (via</source>
          <target state="translated">링크 타임 옵티마이 저의 작동에 대한 내부 세부 사항이 포함 된 보고서를 인쇄합니다. 이 보고서의 내용은 버전마다 다릅니다. LTO 모드에서 객체 파일을 처리 할 때 GCC 개발자에게 유용합니다.</target>
        </trans-unit>
        <trans-unit id="356b649f8a5b2eeac75d52d3fde25687e1baf75a" translate="yes" xml:space="preserve">
          <source>PrivateHeaders</source>
          <target state="translated">PrivateHeaders</target>
        </trans-unit>
        <trans-unit id="2ad988ff4da432b2bd8d59157204ad932c4a0a31" translate="yes" xml:space="preserve">
          <source>Probability (in percent) that C++ inline function with comdat visibility are shared across multiple compilation units.</source>
          <target state="translated">comdat 가시성을 가진 C ++ 인라인 함수는 여러 컴파일 단위에서 공유 될 확률 (%)입니다.</target>
        </trans-unit>
        <trans-unit id="850fe6834f667b77b7e2ae19ee297ae3dd8470cf" translate="yes" xml:space="preserve">
          <source>Problems using GCC with other compilers, and with certain linkers, assemblers and debuggers.</source>
          <target state="translated">다른 컴파일러 및 특정 링커, 어셈블러 및 디버거에서 GCC 사용시 문제가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9c6060b3674c249414e5152b2230ab7030cef431" translate="yes" xml:space="preserve">
          <source>Process &lt;var&gt;file&lt;/var&gt; after the compiler reads in the standard</source>
          <target state="translated">컴파일러가 표준을 읽은 후 프로세스 &lt;var&gt;file&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="191842ffa605d8dc7494dd7b68d3c292602796ee" translate="yes" xml:space="preserve">
          <source>Process &lt;var&gt;file&lt;/var&gt; as if &lt;code&gt;#include &quot;file&quot;&lt;/code&gt; appeared as the first line of the primary source file. However, the first directory searched for &lt;var&gt;file&lt;/var&gt; is the preprocessor&amp;rsquo;s working directory &lt;em&gt;instead of&lt;/em&gt; the directory containing the main source file. If not found there, it is searched for in the remainder of the &lt;code&gt;#include &quot;&amp;hellip;&quot;&lt;/code&gt; search chain as normal.</source>
          <target state="translated">프로세스 &lt;var&gt;file&lt;/var&gt; 경우와 같은 &lt;code&gt;#include &quot;file&quot;&lt;/code&gt; 기본 소스 파일의 첫 번째 행으로 나타났다. 그러나 &lt;var&gt;file&lt;/var&gt; 검색 한 첫 번째 디렉토리 는 기본 소스 파일을 포함하는 디렉토리 &lt;em&gt;대신&lt;/em&gt; 전 처리기의 작업 디렉토리 입니다. 찾을 수없는 경우 나머지 &lt;code&gt;#include &quot;&amp;hellip;&quot;&lt;/code&gt; 검색 체인에서 정상적으로 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="6734f891a855dd7a87c6c0bfe8fa052810c7d184" translate="yes" xml:space="preserve">
          <source>Process the &lt;code&gt;asm&lt;/code&gt; spec. This is used to compute the switches to be passed to the assembler.</source>
          <target state="translated">&lt;code&gt;asm&lt;/code&gt; 사양을 처리하십시오 . 이는 어셈블러에 전달할 스위치를 계산하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="38573e03d0821a17e48df49ff92134f08123d891" translate="yes" xml:space="preserve">
          <source>Process the &lt;code&gt;asm_final&lt;/code&gt; spec. This is a spec string for passing switches to an assembler post-processor, if such a program is needed.</source>
          <target state="translated">&lt;code&gt;asm_final&lt;/code&gt; 스펙을 처리하십시오 . 이러한 프로그램이 필요한 경우 스위치를 어셈블러 포스트 프로세서로 전달하기위한 사양 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="c24b1fe466497f7be4ea4b8ebfb1c796e853db45" translate="yes" xml:space="preserve">
          <source>Process the &lt;code&gt;cc1&lt;/code&gt; spec. This is used to construct the options to be passed to the actual C compiler (&lt;code&gt;cc1&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;cc1&lt;/code&gt; 사양을 처리하십시오 . 이것은 실제 C 컴파일러 ( &lt;code&gt;cc1&lt;/code&gt; ) 로 전달 될 옵션을 구성하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="d6f17bdc842d5e5f40364c825949e630921d84fa" translate="yes" xml:space="preserve">
          <source>Process the &lt;code&gt;cc1plus&lt;/code&gt; spec. This is used to construct the options to be passed to the actual C++ compiler (&lt;code&gt;cc1plus&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;cc1plus&lt;/code&gt; 사양을 처리하십시오 . 실제 C ++ 컴파일러 ( &lt;code&gt;cc1plus&lt;/code&gt; )에 전달할 옵션을 구성하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="d5396bf6c9ae0325ba2157fe3770f71223e19ef3" translate="yes" xml:space="preserve">
          <source>Process the &lt;code&gt;cpp&lt;/code&gt; spec. This is used to construct the arguments to be passed to the C preprocessor.</source>
          <target state="translated">&lt;code&gt;cpp&lt;/code&gt; 스펙을 처리하십시오 . 이것은 C 프리 프로세서에 전달 될 인수를 구성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8c1edb26c6deccdbec0712ee2d8d11b418fd33df" translate="yes" xml:space="preserve">
          <source>Process the &lt;code&gt;endfile&lt;/code&gt; spec. This is a spec string that specifies the last object files that are passed to the linker.</source>
          <target state="translated">&lt;code&gt;endfile&lt;/code&gt; 스펙을 처리하십시오 . 링커에 전달되는 마지막 오브젝트 파일을 지정하는 스펙 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="a2255c514c878d9f84e377c0c64a134c8dce070b" translate="yes" xml:space="preserve">
          <source>Process the &lt;code&gt;lib&lt;/code&gt; spec. This is a spec string for deciding which libraries are included on the command line to the linker.</source>
          <target state="translated">&lt;code&gt;lib&lt;/code&gt; 스펙을 처리하십시오 . 이것은 링커에 대한 명령 행에 포함 할 라이브러리를 결정하기위한 스펙 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="21eaf027956ca118a365869c3f14adfd31ded482" translate="yes" xml:space="preserve">
          <source>Process the &lt;code&gt;libgcc&lt;/code&gt; spec. This is a spec string for deciding which GCC support library is included on the command line to the linker.</source>
          <target state="translated">&lt;code&gt;libgcc&lt;/code&gt; 스펙을 처리하십시오 . 이것은 링커에 대한 명령 행에 어떤 GCC 지원 라이브러리가 포함되는지 결정하기위한 스펙 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="4bace10c4995ad6f02604a1283502179576e6980" translate="yes" xml:space="preserve">
          <source>Process the &lt;code&gt;link&lt;/code&gt; spec. This is the spec for computing the command line passed to the linker. Typically it makes use of the &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;link&lt;/code&gt; 사양을 처리하십시오 . 링커에 전달 된 명령 줄을 계산하기위한 사양입니다. 일반적으로 '</target>
        </trans-unit>
        <trans-unit id="fb8c4d2ece6f487a7a0a494e47ae351215a61c64" translate="yes" xml:space="preserve">
          <source>Process the &lt;code&gt;startfile&lt;/code&gt; spec. This is a spec for deciding which object files are the first ones passed to the linker. Typically this might be a file named</source>
          <target state="translated">시작 &lt;code&gt;startfile&lt;/code&gt; 스펙을 처리하십시오 . 링커에 가장 먼저 전달되는 오브젝트 파일을 결정하기위한 스펙입니다. 일반적으로 이것은 파일 이름이 될 수 있습니다</target>
        </trans-unit>
        <trans-unit id="ec518e4b3e80564c09131d1ae87879a3f6d17ed9" translate="yes" xml:space="preserve">
          <source>Processors based on the AMD K8 core with x86-64 instruction set support, including the AMD Opteron, Athlon 64, and Athlon 64 FX processors. (This supersets MMX, SSE, SSE2, 3DNow!, enhanced 3DNow! and 64-bit instruction set extensions.)</source>
          <target state="translated">x86-64 명령어 세트를 지원하는 AMD K8 코어 기반 프로세서 (AMD Opteron, Athlon 64 및 Athlon 64 FX 프로세서 포함). (이것은 MMX, SSE, SSE2, 3DNow !, 향상된 3DNow! 및 64 비트 명령어 세트 확장을 수퍼 셋합니다.)</target>
        </trans-unit>
        <trans-unit id="62590afcaa5b3d90840b2e3dacaeab111c2a8e70" translate="yes" xml:space="preserve">
          <source>Produce a Mach-o bundle format file. See man ld(1) for more information.</source>
          <target state="translated">Mach-o 번들 형식 파일을 생성하십시오. 자세한 내용은 man ld (1)를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9cedce134ad1d6e39e6ac28f5ea367bb4ac3cf33" translate="yes" xml:space="preserve">
          <source>Produce a core dump whenever an error occurs.</source>
          <target state="translated">오류가 발생할 때마다 코어 덤프를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="ba338fc5c81c60c18e5763d1fadce97ad1e61e6a" translate="yes" xml:space="preserve">
          <source>Produce a dynamically linked position independent executable on targets that support it. For predictable results, you must also specify the same set of options used for compilation (</source>
          <target state="translated">이를 지원하는 대상에서 동적으로 링크 된 위치 독립적 실행 파일을 생성하십시오. 예측 가능한 결과를 얻으려면 컴파일에 사용 된 것과 동일한 옵션 세트를 지정해야합니다 (</target>
        </trans-unit>
        <trans-unit id="6cb3358c313e561510d03d4f43da46e9f117e2c5" translate="yes" xml:space="preserve">
          <source>Produce a notes file that the &lt;code&gt;gcov&lt;/code&gt; code-coverage utility (see &lt;a href=&quot;gcov#Gcov&quot;&gt;&lt;code&gt;gcov&lt;/code&gt;&amp;mdash;a Test Coverage Program&lt;/a&gt;) can use to show program coverage. Each source file&amp;rsquo;s note file is called</source>
          <target state="translated">&lt;code&gt;gcov&lt;/code&gt; 코드 커버리지 유틸리티 ( &lt;a href=&quot;gcov#Gcov&quot;&gt; &lt;code&gt;gcov&lt;/code&gt; &amp;mdash; 테스트 범위 프로그램 참조&lt;/a&gt; )가 프로그램 범위를 표시하는 데 사용할 수 있는 메모 파일을 생성 하십시오 . 각 소스 파일의 노트 파일을</target>
        </trans-unit>
        <trans-unit id="8b280710ae96a8b8d8e74aa28a812b327df111b1" translate="yes" xml:space="preserve">
          <source>Produce a relocatable object as output. This is also known as partial linking.</source>
          <target state="translated">재배치 가능한 객체를 출력으로 생성합니다. 이것은 부분 링크라고도합니다.</target>
        </trans-unit>
        <trans-unit id="26aa77097b9a063e69af15c39e1ef1623a1a0dab" translate="yes" xml:space="preserve">
          <source>Produce a shared object which can then be linked with other objects to form an executable. Not all systems support this option. For predictable results, you must also specify the same set of options used for compilation (</source>
          <target state="translated">공유 객체를 생성 한 다음 다른 객체와 연결하여 실행 파일을 형성 할 수 있습니다. 모든 시스템이이 옵션을 지원하지는 않습니다. 예측 가능한 결과를 얻으려면 컴파일에 사용 된 것과 동일한 옵션 세트를 지정해야합니다 (</target>
        </trans-unit>
        <trans-unit id="82a6e20338c2d2cb9f44077a8123f0423ba29a56" translate="yes" xml:space="preserve">
          <source>Produce a static position independent executable on targets that support it. A static position independent executable is similar to a static executable, but can be loaded at any address without a dynamic linker. For predictable results, you must also specify the same set of options used for compilation (</source>
          <target state="translated">이를 지원하는 대상에서 정적 위치 독립적 실행 파일을 생성하십시오. 정적 위치 독립적 실행 파일은 정적 실행 파일과 비슷하지만 동적 링커없이 모든 주소에로드 할 수 있습니다. 예측 가능한 결과를 얻으려면 컴파일에 사용 된 것과 동일한 옵션 세트를 지정해야합니다 (</target>
        </trans-unit>
        <trans-unit id="229bc991f84912dbb707cad7f57cc3c00958246f" translate="yes" xml:space="preserve">
          <source>Produce all the dumps listed above.</source>
          <target state="translated">위에 나열된 모든 덤프를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="c830b4e289b1d603d4b29ad3603ac7fe06258efc" translate="yes" xml:space="preserve">
          <source>Produce code optimized for the most common IA32/AMD64/EM64T processors. If you know the CPU on which your code will run, then you should use the corresponding</source>
          <target state="translated">가장 일반적인 IA32 / AMD64 / EM64T 프로세서에 최적화 된 코드를 생성하십시오. 코드가 실행될 CPU를 알고 있다면 해당 CPU를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="874624fe120d74004c74672b177571000bb8d675" translate="yes" xml:space="preserve">
          <source>Produce code optimized for the most current Intel processors, which are Haswell and Silvermont for this version of GCC. If you know the CPU on which your code will run, then you should use the corresponding</source>
          <target state="translated">이 버전의 GCC에 대해 Haswell 및 Silvermont 인 최신 Intel 프로세서에 최적화 된 코드를 생성하십시오. 코드가 실행될 CPU를 알고 있다면 해당 CPU를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="59d6dfa4b2545178e43d697c719e6e2891444e31" translate="yes" xml:space="preserve">
          <source>Produce code that conforms more closely to IBM XL compiler semantics when using AIX-compatible ABI. Pass floating-point arguments to prototyped functions beyond the register save area (RSA) on the stack in addition to argument FPRs. Do not assume that most significant double in 128-bit long double value is properly rounded when comparing values and converting to double. Use XL symbol names for long double support routines.</source>
          <target state="translated">AIX 호환 ABI를 사용할 때 IBM XL 컴파일러 시맨틱에보다 부합하는 코드를 생성하십시오. 인수 FPR 외에도 스택의 레지스터 저장 영역 (RSA) 이외의 프로토 타입 함수에 부동 소수점 인수를 전달합니다. 값을 비교하고 double로 변환 할 때 128 비트 long double 값에서 최상위 double이 올림된다고 가정하지 마십시오. 긴 이중 지원 루틴에는 XL 기호 이름을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="70aa8e6a5aa6f95946582de4d3eebc24892a15cb" translate="yes" xml:space="preserve">
          <source>Produce compressed debug sections in DWARF format, if that is supported. If &lt;var&gt;type&lt;/var&gt; is not given, the default type depends on the capabilities of the assembler and linker used. &lt;var&gt;type&lt;/var&gt; may be one of &amp;lsquo;</source>
          <target state="translated">지원되는 경우 DWARF 형식의 압축 디버그 섹션을 생성하십시오. &lt;var&gt;type&lt;/var&gt; 이 지정되지 않은 경우 기본 유형은 사용 된 어셈블러 및 링커의 기능에 따라 다릅니다. &lt;var&gt;type&lt;/var&gt; 은 '중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d785038635c115caba3a3a72ca445989fe650fad" translate="yes" xml:space="preserve">
          <source>Produce debugging information for use by GDB. This means to use the most expressive format available (DWARF, stabs, or the native format if neither of those are supported), including GDB extensions if at all possible.</source>
          <target state="translated">GDB에서 사용할 디버깅 정보를 생성하십시오. 즉, 가능한 경우 GDB 확장을 포함하여 사용 가능한 가장 표현적인 형식 (DWARF, 스 태브 또는 둘 중 어느 것도 지원하지 않는 경우 기본 형식)을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="6e76e1882b03d7c105da1aec1b4b65497ef05063" translate="yes" xml:space="preserve">
          <source>Produce debugging information in Alpha/VMS debug format (if that is supported). This is the format used by DEBUG on Alpha/VMS systems.</source>
          <target state="translated">Alpha / VMS 디버그 형식 (지원되는 경우)으로 디버깅 정보를 생성합니다. Alpha / VMS 시스템에서 DEBUG가 사용하는 형식입니다.</target>
        </trans-unit>
        <trans-unit id="1c89bdfbe7ff24838a86019c90957a16af275605" translate="yes" xml:space="preserve">
          <source>Produce debugging information in DWARF format (if that is supported). The value of &lt;var&gt;version&lt;/var&gt; may be either 2, 3, 4 or 5; the default version for most targets is 4. DWARF Version 5 is only experimental.</source>
          <target state="translated">지원되는 경우 DWARF 형식으로 디버깅 정보를 생성합니다. &lt;var&gt;version&lt;/var&gt; 의 값은 2, 3, 4 또는 5 일 수 있습니다. 대부분의 대상의 기본 버전은 4입니다. DWARF 버전 5는 실험용입니다.</target>
        </trans-unit>
        <trans-unit id="21dc1c45a8426cfd7ea86f0ff5efd716fb463aa3" translate="yes" xml:space="preserve">
          <source>Produce debugging information in XCOFF format (if that is supported), using GNU extensions understood only by the GNU debugger (GDB). The use of these extensions is likely to make other debuggers crash or refuse to read the program, and may cause assemblers other than the GNU assembler (GAS) to fail with an error.</source>
          <target state="translated">GNU 디버거 (GDB)에서만 이해할 수있는 GNU 확장을 사용하여 XCOFF 형식 (지원되는 경우)으로 디버깅 정보를 생성합니다. 이러한 확장을 사용하면 다른 디버거가 충돌하거나 프로그램 읽기를 거부 할 수 있으며, GAS (GNU 어셈블러) 이외의 어셈블러가 오류와 함께 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c31c10a8554b29470b180047c3e117a364d7374" translate="yes" xml:space="preserve">
          <source>Produce debugging information in XCOFF format (if that is supported). This is the format used by the DBX debugger on IBM RS/6000 systems.</source>
          <target state="translated">XCOFF 형식으로 디버깅 정보를 생성합니다 (지원되는 경우). IBM RS / 6000 시스템에서 DBX 디버거가 사용하는 형식입니다.</target>
        </trans-unit>
        <trans-unit id="a8732936178c413fac329a93443e75c2a16089d0" translate="yes" xml:space="preserve">
          <source>Produce debugging information in stabs format (if that is supported), for only symbols that are actually used.</source>
          <target state="translated">실제로 사용되는 심볼에 대해서만 스테 이브 형식 (지원되는 경우)으로 디버깅 정보를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="798e83cefb7f6ea7ef9a535cd3ace3be5a753318" translate="yes" xml:space="preserve">
          <source>Produce debugging information in stabs format (if that is supported), using GNU extensions understood only by the GNU debugger (GDB). The use of these extensions is likely to make other debuggers crash or refuse to read the program.</source>
          <target state="translated">GNU 디버거 (GDB)에서만 이해하는 GNU 확장을 사용하여 스테 이브 형식 (지원되는 경우)으로 디버깅 정보를 생성합니다. 이러한 확장을 사용하면 다른 디버거가 충돌하거나 프로그램 읽기를 거부 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e675746f0878092c9d5ac57cb51767441496530c" translate="yes" xml:space="preserve">
          <source>Produce debugging information in stabs format (if that is supported), without GDB extensions. This is the format used by DBX on most BSD systems. On MIPS, Alpha and System V Release 4 systems this option produces stabs debugging output that is not understood by DBX. On System V Release 4 systems this option requires the GNU assembler.</source>
          <target state="translated">GDB 확장없이 스테 이브 형식 (지원되는 경우)으로 디버깅 정보를 생성합니다. 대부분의 BSD 시스템에서 DBX가 사용하는 형식입니다. MIPS, Alpha 및 System V 릴리스 4 시스템에서이 옵션은 DBX가 이해할 수없는 스테 이브 디버깅 출력을 생성합니다. System V 릴리스 4 시스템에서이 옵션에는 GNU 어셈블러가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="2effb462b688a145487a6f229d8da95bd056d019" translate="yes" xml:space="preserve">
          <source>Produce debugging information in the operating system&amp;rsquo;s native format (stabs, COFF, XCOFF, or DWARF). GDB can work with this debugging information.</source>
          <target state="translated">운영 체제의 기본 형식 (stabs, COFF, XCOFF 또는 DWARF)으로 디버깅 정보를 생성하십시오. GDB는이 디버깅 정보로 작업 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c30c7a4385f1b1870365ef3b00c760d3c2db0e3" translate="yes" xml:space="preserve">
          <source>Producing an AutoFDO profile data file requires running your program with the &lt;code&gt;perf&lt;/code&gt; utility on a supported GNU/Linux target system. For more information, see &lt;a href=&quot;https://perf.wiki.kernel.org/&quot;&gt;https://perf.wiki.kernel.org/&lt;/a&gt;.</source>
          <target state="translated">AutoFDO 프로파일 데이터 파일을 생성하려면 지원되는 GNU / Linux 대상 시스템 에서 &lt;code&gt;perf&lt;/code&gt; 유틸리티를 사용하여 프로그램을 실행해야 합니다. 자세한 내용은 &lt;a href=&quot;https://perf.wiki.kernel.org/&quot;&gt;https://perf.wiki.kernel.org/를&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="3d16847b11987e862bb0226a6dbf93a65cab5ec8" translate="yes" xml:space="preserve">
          <source>Producing debuggable code.</source>
          <target state="translated">디버깅 가능한 코드 생성</target>
        </trans-unit>
        <trans-unit id="66065140c4bd69f9a929457e5e1f5ddcadca4b33" translate="yes" xml:space="preserve">
          <source>Profiles collected using an instrumented binary for multi-threaded programs may be inconsistent due to missed counter updates. When this option is specified, GCC uses heuristics to correct or smooth out such inconsistencies. By default, GCC emits an error message when an inconsistent profile is detected.</source>
          <target state="translated">다중 스레드 프로그램에 대해 계측 된 이진 파일을 사용하여 수집 한 프로필은 카운터 업데이트가 누락되어 일치하지 않을 수 있습니다. 이 옵션을 지정하면 GCC는 휴리스틱을 사용하여 이러한 불일치를 수정하거나 제거합니다. 기본적으로 GCC는 일치하지 않는 프로필이 감지되면 오류 메시지를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="215364611f5d742bb3cf5b6bc5f45d76aedfc488" translate="yes" xml:space="preserve">
          <source>Profiling run-time library reports various errors related to profile manipulation and profile saving. Errors are printed into standard error output or &amp;lsquo;</source>
          <target state="translated">프로파일 링 런타임 라이브러리는 프로파일 조작 및 프로파일 저장과 관련된 다양한 오류를보고합니다. 오류는 표준 오류 출력 또는 '</target>
        </trans-unit>
        <trans-unit id="6d0967a146a9cd54e7f2cfdefd92dad89185e247" translate="yes" xml:space="preserve">
          <source>Profiling tools help you analyze your code&amp;rsquo;s performance. Using a profiler such as &lt;code&gt;gcov&lt;/code&gt; or &lt;code&gt;gprof&lt;/code&gt;, you can find out some basic performance statistics, such as:</source>
          <target state="translated">프로파일 링 도구는 코드 성능을 분석하는 데 도움이됩니다. &lt;code&gt;gcov&lt;/code&gt; 또는 &lt;code&gt;gprof&lt;/code&gt; 와 같은 프로파일 러를 사용하면 다음과 같은 몇 가지 기본 성능 통계를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="299845fbcd8fc09058a26974d7a1694c0d922e8b" translate="yes" xml:space="preserve">
          <source>Program Instrumentation Options</source>
          <target state="translated">프로그램 계측 옵션</target>
        </trans-unit>
        <trans-unit id="bce0913595ade4c39c8c03d2dbf27980dd7aa2d2" translate="yes" xml:space="preserve">
          <source>Program precision. This option is the default and means a trap handler can only identify which program caused a floating-point exception.</source>
          <target state="translated">프로그램 정밀도. 이 옵션은 기본값이며 트랩 핸들러가 부동 소수점 예외를 발생시킨 프로그램 만 식별 할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="2e30a8e13f6fe61be9a133d07d1e5fc7f1ccd080" translate="yes" xml:space="preserve">
          <source>Programmers normally use conditionals on &lt;code&gt;__STDC__&lt;/code&gt; to ask whether it is safe to use certain features of ISO C, such as function prototypes or ISO token concatenation. Since plain &lt;code&gt;gcc&lt;/code&gt; supports all the features of ISO C, the correct answer to these questions is &amp;ldquo;yes&amp;rdquo;.</source>
          <target state="translated">프로그래머는 일반적으로 &lt;code&gt;__STDC__&lt;/code&gt; 에서 조건 을 사용하여 함수 프로토 타입 또는 ISO 토큰 연결과 같은 ISO C의 특정 기능을 사용하는 것이 안전한지 묻습니다. 일반 &lt;code&gt;gcc&lt;/code&gt; 는 ISO C의 모든 기능을 지원하므로 이러한 질문에 대한 정답은&amp;ldquo;예&amp;rdquo;입니다.</target>
        </trans-unit>
        <trans-unit id="a0bd705cf04e9357c2ea73ca926ccbac6b893041" translate="yes" xml:space="preserve">
          <source>Programs that use preprocessing directives in the middle of macro arguments do not work with GCC. For example, a program like this will not work:</source>
          <target state="translated">매크로 인수 중간에 전처리 지시문을 사용하는 프로그램은 GCC에서 작동하지 않습니다. 예를 들어 다음과 같은 프로그램은 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f2ac6418060115eaba540e4ea02f9d2bc08e06a3" translate="yes" xml:space="preserve">
          <source>Programs written to compile with C++-to-C translators get the value of &lt;code&gt;__STDC__&lt;/code&gt; that goes with the C compiler that is subsequently used. These programs must test &lt;code&gt;__STDC__&lt;/code&gt; to determine what kind of C preprocessor that compiler uses: whether they should concatenate tokens in the ISO C fashion or in the traditional fashion.</source>
          <target state="translated">C ++에서 C 로의 변환기로 컴파일하기 위해 작성된 프로그램 은 이후에 사용되는 C 컴파일러와 함께 제공되는 &lt;code&gt;__STDC__&lt;/code&gt; 의 값을 얻습니다 . 이러한 프로그램은 &lt;code&gt;__STDC__&lt;/code&gt; 를 테스트 하여 컴파일러가 어떤 종류의 C 프리 프로세서를 사용하는지 결정해야합니다. 토큰을 ISO C 방식으로 또는 전통적인 방식으로 연결해야하는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="5a9cb5a82aeec8a68235c0ced346ccbfb76bb12a" translate="yes" xml:space="preserve">
          <source>Propagate information about uses of a value up the definition chain in order to simplify the definitions. For example, this pass strips sign operations if the sign of a value never matters. The flag is enabled by default at</source>
          <target state="translated">정의를 단순화하기 위해 정의 체인의 값 사용에 대한 정보를 전파하십시오. 예를 들어,이 패스는 값의 부호가 중요하지 않은 경우 부호 연산을 제거합니다. 이 플래그는 기본적으로 활성화되어 있습니다</target>
        </trans-unit>
        <trans-unit id="fa7dd81f88cb5c4139f9dbe0c73fbba733aa4a44" translate="yes" xml:space="preserve">
          <source>Protected visibility is like default visibility except that it indicates that references within the defining module bind to the definition in that module. That is, the declared entity cannot be overridden by another module.</source>
          <target state="translated">보호 가시성은 정의 모듈 내의 참조가 해당 모듈의 정의에 바인딩된다는 것을 제외하고는 기본 가시성과 같습니다. 즉, 선언 된 엔터티는 다른 모듈로 재정의 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="af2b8481cf932700a1d1fe584409316090685bcd" translate="yes" xml:space="preserve">
          <source>Prototype declarations and old-style definitions.</source>
          <target state="translated">프로토 타입 선언과 구식 정의.</target>
        </trans-unit>
        <trans-unit id="281df885a6152b0fc99de98c97f687a7bacdb5ad" translate="yes" xml:space="preserve">
          <source>Provide a user-defined function to handle NMI exception.</source>
          <target state="translated">NMI 예외를 처리하기위한 사용자 정의 함수를 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="a507043f2b5ce9798e6d052565a1ba8fcc61bd09" translate="yes" xml:space="preserve">
          <source>Provide a user-defined function to handle warm reset exception.</source>
          <target state="translated">웜 리셋 예외를 처리하기 위해 사용자 정의 함수를 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="ba0e24e32262e9027ddf344b0bbb6826b30533e8" translate="yes" xml:space="preserve">
          <source>Providing multiple strings as arguments separated by commas to specify multiple options is equivalent to separating the option suffixes with a comma (&amp;lsquo;</source>
          <target state="translated">여러 문자열을 쉼표로 구분하여 여러 옵션을 지정하는 인수로 제공하는 것은 옵션 접미어를 쉼표 ( '</target>
        </trans-unit>
        <trans-unit id="c6e467f9fef2c6ec37e713ef7ce97be04a79d3ee" translate="yes" xml:space="preserve">
          <source>Pseudo type</source>
          <target state="translated">의사 유형</target>
        </trans-unit>
        <trans-unit id="2ec15755e92f7ec74b89a276482fe0679fe6a677" translate="yes" xml:space="preserve">
          <source>Put all data, not just small objects, into the sections reserved for small data, and use addressing relative to the &lt;code&gt;B14&lt;/code&gt; register to access them.</source>
          <target state="translated">작은 개체뿐만 아니라 모든 데이터를 작은 데이터 용으로 예약 된 섹션에 넣고 &lt;code&gt;B14&lt;/code&gt; 레지스터에 상대적인 주소 지정을 사용 하여 액세스하십시오.</target>
        </trans-unit>
        <trans-unit id="14d82a1bb301488807b0804cf1d8b4aed130dcd1" translate="yes" xml:space="preserve">
          <source>Put definitions of externally-visible data in a small data section if that data is no bigger than &lt;var&gt;num&lt;/var&gt; bytes. GCC can then generate more efficient accesses to the data; see</source>
          <target state="translated">데이터가 &lt;var&gt;num&lt;/var&gt; 바이트 보다 크지 않은 경우 외부에서 볼 수있는 데이터의 정의를 작은 데이터 섹션에 넣으십시오 . 그런 다음 GCC는 데이터에 대한보다 효율적인 액세스를 생성 할 수 있습니다. 보다</target>
        </trans-unit>
        <trans-unit id="ee1f4e4ed1983ff05857b16e6d5463e63d52f87d" translate="yes" xml:space="preserve">
          <source>Put definitions of externally-visible data in a small data section if that data is no bigger than &lt;var&gt;num&lt;/var&gt; bytes. The default value of &lt;var&gt;num&lt;/var&gt; is 4 for any ARC configuration, or 8 when we have double load/store operations.</source>
          <target state="translated">데이터가 &lt;var&gt;num&lt;/var&gt; 바이트 보다 크지 않은 경우 외부에서 볼 수있는 데이터의 정의를 작은 데이터 섹션에 넣으십시오 . 기본값 인 &lt;var&gt;num&lt;/var&gt; 은 ARC 구성의 경우 4이거나 이중로드 / 저장 작업이있는 경우 8입니다.</target>
        </trans-unit>
        <trans-unit id="dd10aa9229d46223067d4529eb087ca1d5b4bb37" translate="yes" xml:space="preserve">
          <source>Put extra commentary information in the generated assembly code to make it more readable. This option is generally only of use to those who actually need to read the generated assembly code (perhaps while debugging the compiler itself).</source>
          <target state="translated">생성 된 어셈블리 코드에 주석을 추가로 추가하여 더 읽기 쉽게 만듭니다. 이 옵션은 일반적으로 생성 된 어셈블리 코드를 실제로 읽어야하는 사람들에게만 사용됩니다 (아마도 컴파일러 자체를 디버깅하는 동안).</target>
        </trans-unit>
        <trans-unit id="4efa75b425ee3379e46be03951b8fed10951f423" translate="yes" xml:space="preserve">
          <source>Put global and static data smaller than &lt;var&gt;n&lt;/var&gt; bytes into a special section (on some targets).</source>
          <target state="translated">전역 및 정적 데이터를 &lt;var&gt;n&lt;/var&gt; 바이트 보다 작은 특수 섹션 (일부 대상)에 넣습니다.</target>
        </trans-unit>
        <trans-unit id="803e4d47363b74310533dbbacf9cf5e406c33858" translate="yes" xml:space="preserve">
          <source>Put global and static objects less than or equal to &lt;var&gt;num&lt;/var&gt; bytes into the small data or BSS sections instead of the normal data or BSS sections. The default value of &lt;var&gt;num&lt;/var&gt; is 8.</source>
          <target state="translated">일반 데이터 또는 BSS 섹션 대신 작은 데이터 또는 BSS 섹션 에 &lt;var&gt;num&lt;/var&gt; 바이트 이하의 전역 및 정적 객체를 넣습니다 . &lt;var&gt;num&lt;/var&gt; 의 기본값 은 8입니다.</target>
        </trans-unit>
        <trans-unit id="325fbb1dff6b2bc48b832b2c0837a0d4aa50c625" translate="yes" xml:space="preserve">
          <source>Put global and static objects less than or equal to &lt;var&gt;num&lt;/var&gt; bytes into the small data or BSS sections instead of the normal data or BSS sections. The default value of &lt;var&gt;num&lt;/var&gt; is 8. The</source>
          <target state="translated">일반 데이터 또는 BSS 섹션 대신 작은 데이터 또는 BSS 섹션 에 &lt;var&gt;num&lt;/var&gt; 바이트 이하의 전역 및 정적 객체를 넣습니다 . &lt;var&gt;num&lt;/var&gt; 의 기본값 은 8입니다.</target>
        </trans-unit>
        <trans-unit id="2845f96bd365594a3cd3c2c2ff97b86e1f179d72" translate="yes" xml:space="preserve">
          <source>Put read-only objects in the &lt;code&gt;.sdata&lt;/code&gt; section as well. This is the default.</source>
          <target state="translated">&lt;code&gt;.sdata&lt;/code&gt; 섹션에도 읽기 전용 개체를 넣습니다 . 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="aaee271d332c564c26a565ff260fd11119341a45" translate="yes" xml:space="preserve">
          <source>Put small global and static data in the &lt;code&gt;.neardata&lt;/code&gt; section, which is pointed to by register &lt;code&gt;B14&lt;/code&gt;. Put small uninitialized global and static data in the &lt;code&gt;.bss&lt;/code&gt; section, which is adjacent to the &lt;code&gt;.neardata&lt;/code&gt; section. Put small read-only data into the &lt;code&gt;.rodata&lt;/code&gt; section. The corresponding sections used for large pieces of data are &lt;code&gt;.fardata&lt;/code&gt;, &lt;code&gt;.far&lt;/code&gt; and &lt;code&gt;.const&lt;/code&gt;.</source>
          <target state="translated">레지스터 &lt;code&gt;B14&lt;/code&gt; 가 가리키는 &lt;code&gt;.neardata&lt;/code&gt; 섹션 에 작은 전역 및 정적 데이터를 넣습니다 . &lt;code&gt;.neardata&lt;/code&gt; 섹션에 인접한 &lt;code&gt;.bss&lt;/code&gt; 섹션 에 초기화되지 않은 작은 전역 및 정적 데이터를 넣습니다 . 작은 읽기 전용 데이터를 &lt;code&gt;.rodata&lt;/code&gt; 섹션에 넣습니다 . 큰 데이터 조각에 사용되는 해당 섹션은 &lt;code&gt;.fardata&lt;/code&gt; , &lt;code&gt;.far&lt;/code&gt; 및 &lt;code&gt;.const&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f2399d291f04f4ceb6a5d4d94e2129947be998a8" translate="yes" xml:space="preserve">
          <source>Put small global and static data in the small data area, and generate special instructions to reference them.</source>
          <target state="translated">작은 전역 및 정적 데이터를 작은 데이터 영역에 넣고이를 참조하기위한 특수 명령을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="d62b1c870b332795e163f0098650ca88ceaf5c00" translate="yes" xml:space="preserve">
          <source>Put small global and static data in the small data area, but do not generate special code to reference them.</source>
          <target state="translated">작은 전역 및 정적 데이터를 작은 데이터 영역에 넣지 만 참조 할 특수 코드를 생성하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="f427abf1ae046d699cd5f6fec41113c62676ed1b" translate="yes" xml:space="preserve">
          <source>Put static or global variables whose size is &lt;var&gt;n&lt;/var&gt; bytes or less into the first 32 kilobytes of memory.</source>
          <target state="translated">크기가 &lt;var&gt;n&lt;/var&gt; 바이트 이하인 정적 또는 전역 변수를 첫 32KB 메모리에 넣습니다.</target>
        </trans-unit>
        <trans-unit id="c3a89106111c4929799b74f87481c16b67c9438e" translate="yes" xml:space="preserve">
          <source>Put static or global variables whose size is &lt;var&gt;n&lt;/var&gt; bytes or less into the small data area that register &lt;code&gt;gp&lt;/code&gt; points to. The small data area can hold up to 64 kilobytes.</source>
          <target state="translated">크기가 &lt;var&gt;n&lt;/var&gt; 바이트 이하인 정적 또는 전역 변수를 &lt;code&gt;gp&lt;/code&gt; 포인트를 등록하는 작은 데이터 영역에 넣습니다 . 작은 데이터 영역은 최대 64KB를 보유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90b5e26c9c08b39bd895b34bb6ae576000e2eb1e" translate="yes" xml:space="preserve">
          <source>Put static or global variables whose size is &lt;var&gt;n&lt;/var&gt; bytes or less into the tiny data area that register &lt;code&gt;ep&lt;/code&gt; points to. The tiny data area can hold up to 256 bytes in total (128 bytes for byte references).</source>
          <target state="translated">크기가 &lt;var&gt;n&lt;/var&gt; 바이트 이하인 정적 또는 전역 변수를 &lt;code&gt;ep&lt;/code&gt; 포인트를 등록하는 작은 데이터 영역에 넣습니다 . 작은 데이터 영역은 총 256 바이트 (바이트 참조의 경우 128 바이트)를 보유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb78a5b9af064b32c202bfb144d8f6d597bc15ce" translate="yes" xml:space="preserve">
          <source>Put uninitialized &lt;code&gt;const&lt;/code&gt; variables in the read-only data section. This option is only meaningful in conjunction with</source>
          <target state="translated">초기화되지 않은 &lt;code&gt;const&lt;/code&gt; 변수를 읽기 전용 데이터 섹션에 넣 습니다. 이 옵션은 다음과 함께 만 의미가 있습니다</target>
        </trans-unit>
        <trans-unit id="15266f7e96e613e475613699a09898779a9cf785" translate="yes" xml:space="preserve">
          <source>Putting statements and declarations inside expressions.</source>
          <target state="translated">식 안에 문장과 선언을 넣습니다.</target>
        </trans-unit>
        <trans-unit id="c3156e00d3c2588c639e0d3cf6821258b05761c7" translate="yes" xml:space="preserve">
          <source>Q</source>
          <target state="translated">Q</target>
        </trans-unit>
        <trans-unit id="2fb1858154779be9095d34bc86481decea9864b5" translate="yes" xml:space="preserve">
          <source>Qualifiers</source>
          <target state="translated">Qualifiers</target>
        </trans-unit>
        <trans-unit id="06576556d1ad802f247cad11ae748be47b70cd9c" translate="yes" xml:space="preserve">
          <source>R</source>
          <target state="translated">R</target>
        </trans-unit>
        <trans-unit id="51d0c108a00931316d1d9196895d716cd8591259" translate="yes" xml:space="preserve">
          <source>R10</source>
          <target state="translated">R10</target>
        </trans-unit>
        <trans-unit id="a8c8c0f94567fb54e5baecfbbe7a22ad9ffe90a8" translate="yes" xml:space="preserve">
          <source>R9</source>
          <target state="translated">R9</target>
        </trans-unit>
        <trans-unit id="4ed9df973cbf299009483fc686300ba83d456ff4" translate="yes" xml:space="preserve">
          <source>RAM larger than 64 KiB is not supported by GCC for AVR targets. If you use inline assembler to read from locations outside the 16-bit address range and change one of the &lt;code&gt;RAMP&lt;/code&gt; registers, you must reset it to zero after the access.</source>
          <target state="translated">64 KiB보다 큰 RAM은 AVR 대상에 대한 GCC에서 지원되지 않습니다. 인라인 어셈블러를 사용하여 16 비트 주소 범위 밖의 위치에서 읽고 &lt;code&gt;RAMP&lt;/code&gt; 레지스터 중 하나를 변경 하는 경우 액세스 후 0으로 재설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="cdc0f19760327ced87ad8aee74afab31fe72c4fe" translate="yes" xml:space="preserve">
          <source>REG_BR_PROB</source>
          <target state="translated">REG_BR_PROB</target>
        </trans-unit>
        <trans-unit id="f440f2eda03ec65b7157428e14ccfd6f3d0babc7" translate="yes" xml:space="preserve">
          <source>RISC-V&amp;mdash;</source>
          <target state="translated">RISC-V&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="647dca504e5b45f643aed4172949afe845cda414" translate="yes" xml:space="preserve">
          <source>RL78&amp;mdash;</source>
          <target state="translated">RL78&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="575f4784d61d9c2b0ea79d87650e89f3ea480cc7" translate="yes" xml:space="preserve">
          <source>RTL if-conversion tries to remove conditional branches around a block and replace them with conditionally executed instructions. This parameter gives the maximum number of instructions in a block which should be considered for if-conversion. The compiler will also use other heuristics to decide whether if-conversion is likely to be profitable.</source>
          <target state="translated">RTL if-conversion은 블록 주위의 조건부 분기를 제거하고 조건부로 실행되는 명령어로 대체합니다. 이 매개 변수는 if-conversion에 대해 고려해야하는 최대 명령 수를 블록에 제공합니다. 컴파일러는 다른 휴리스틱을 사용하여 if-conversion이 수익성이 있는지 여부를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="8ffe843fed02ef77ab2e92d415d12da14c23bcab" translate="yes" xml:space="preserve">
          <source>RTL if-conversion will try to remove conditional branches around a block and replace them with conditionally executed instructions. These parameters give the maximum permissible cost for the sequence that would be generated by if-conversion depending on whether the branch is statically determined to be predictable or not. The units for this parameter are the same as those for the GCC internal seq_cost metric. The compiler will try to provide a reasonable default for this parameter using the BRANCH_COST target macro.</source>
          <target state="translated">RTL if-conversion은 블록 주변의 조건부 분기를 제거하고 조건부로 실행되는 명령어로 대체하려고 시도합니다. 이 매개 변수는 분기가 정적으로 예측 가능한지 여부에 따라 if 변환에 의해 생성되는 시퀀스에 대해 최대 허용 비용을 제공합니다. 이 매개 변수의 단위는 GCC 내부 seq_cost 지표의 단위와 동일합니다. 컴파일러는 BRANCH_COST 대상 매크로를 사용하여이 매개 변수에 적절한 기본값을 제공하려고합니다.</target>
        </trans-unit>
        <trans-unit id="b61bd2259b081aeab3036fb11de5495fed60c76b" translate="yes" xml:space="preserve">
          <source>RTM Function: int &lt;strong id=&quot;index-_005fxtest&quot;&gt;_xtest&lt;/strong&gt; ()</source>
          <target state="translated">RTM 기능 : int &lt;strong id=&quot;index-_005fxtest&quot;&gt;_xtest&lt;/strong&gt; ()</target>
        </trans-unit>
        <trans-unit id="ee01945fd30707cfbb63a1376c78162c28d86d32" translate="yes" xml:space="preserve">
          <source>RTM Function: unsigned &lt;strong id=&quot;index-_005fxbegin&quot;&gt;_xbegin&lt;/strong&gt; ()</source>
          <target state="translated">RTM 기능 : 부호없는 &lt;strong id=&quot;index-_005fxbegin&quot;&gt;_xbegin&lt;/strong&gt; ()</target>
        </trans-unit>
        <trans-unit id="e8ff66f739eabb13f3e3a702095e9beb4ceb7801" translate="yes" xml:space="preserve">
          <source>RTM Function: void &lt;strong id=&quot;index-_005fxabort&quot;&gt;_xabort&lt;/strong&gt; (status)</source>
          <target state="translated">RTM 기능 : void &lt;strong id=&quot;index-_005fxabort&quot;&gt;_xabort&lt;/strong&gt; (상태)</target>
        </trans-unit>
        <trans-unit id="9b706c796609ffc332644946cbe8681890d7242e" translate="yes" xml:space="preserve">
          <source>RTM Function: void &lt;strong id=&quot;index-_005fxend&quot;&gt;_xend&lt;/strong&gt; ()</source>
          <target state="translated">RTM 기능 : void &lt;strong id=&quot;index-_005fxend&quot;&gt;_xend&lt;/strong&gt; ()</target>
        </trans-unit>
        <trans-unit id="828c78a41071d9949c1d88a38a7d2dcd59e5c5f3" translate="yes" xml:space="preserve">
          <source>RX&amp;mdash;</source>
          <target state="translated">RX&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="d7b79d74a6226f5fa551619ad3ed2cd4c064e1e4" translate="yes" xml:space="preserve">
          <source>RX200</source>
          <target state="translated">RX200</target>
        </trans-unit>
        <trans-unit id="6b0bdb50e97b5f7896cc50adf9568df594becf5a" translate="yes" xml:space="preserve">
          <source>RX600</source>
          <target state="translated">RX600</target>
        </trans-unit>
        <trans-unit id="e9b5640a7d2c4fd0e5ab9dc9d14a004b2b5bb4b9" translate="yes" xml:space="preserve">
          <source>RX610</source>
          <target state="translated">RX610</target>
        </trans-unit>
        <trans-unit id="75a59f2d35f8f89735f1550d0fb20ce1794b174c" translate="yes" xml:space="preserve">
          <source>Range 24 to 31, rotatert:SI 8 to 1 expressed as rotate</source>
          <target state="translated">범위 24 ~ 31, 회전식 : SI 8 ~ 1 회전으로 표시</target>
        </trans-unit>
        <trans-unit id="03a9b8383aae047c9acd6c38cefaa42394133afe" translate="yes" xml:space="preserve">
          <source>Range 8 to 15, rotatert:HI 8 to 1 expressed as rotate</source>
          <target state="translated">범위 8 ~ 15, 회전식 : HI 8 ~ 1 회전으로 표시</target>
        </trans-unit>
        <trans-unit id="b09e126e8976753eddde68fb3b2daae37eaf29a0" translate="yes" xml:space="preserve">
          <source>Range of signed numbers that don&amp;rsquo;t fit in 16 bits</source>
          <target state="translated">16 비트에 맞지 않는 부호있는 숫자의 범위</target>
        </trans-unit>
        <trans-unit id="3f3d7a48648a100cea8d8857ee93983cdfde6d2e" translate="yes" xml:space="preserve">
          <source>Rather than allocating fixed registers via clobbers to provide scratch registers for an &lt;code&gt;asm&lt;/code&gt; statement, an alternative is to define a variable and make it an early-clobber output as with &lt;code&gt;a2&lt;/code&gt; and &lt;code&gt;a3&lt;/code&gt; in the example below. This gives the compiler register allocator more freedom. You can also define a variable and make it an output tied to an input as with &lt;code&gt;a0&lt;/code&gt; and &lt;code&gt;a1&lt;/code&gt;, tied respectively to &lt;code&gt;ap&lt;/code&gt; and &lt;code&gt;lda&lt;/code&gt;. Of course, with tied outputs your &lt;code&gt;asm&lt;/code&gt; can&amp;rsquo;t use the input value after modifying the output register since they are one and the same register. What&amp;rsquo;s more, if you omit the early-clobber on the output, it is possible that GCC might allocate the same register to another of the inputs if GCC could prove they had the same value on entry to the &lt;code&gt;asm&lt;/code&gt;. This is why &lt;code&gt;a1&lt;/code&gt; has an early-clobber. Its tied input, &lt;code&gt;lda&lt;/code&gt; might conceivably be known to have the value 16 and without an early-clobber share the same register as &lt;code&gt;%11&lt;/code&gt;. On the other hand, &lt;code&gt;ap&lt;/code&gt; can&amp;rsquo;t be the same as any of the other inputs, so an early-clobber on &lt;code&gt;a0&lt;/code&gt; is not needed. It is also not desirable in this case. An early-clobber on &lt;code&gt;a0&lt;/code&gt; would cause GCC to allocate a separate register for the &lt;code&gt;&quot;m&quot; (*(const double (*)[]) ap)&lt;/code&gt; input. Note that tying an input to an output is the way to set up an initialized temporary register modified by an &lt;code&gt;asm&lt;/code&gt; statement. An input not tied to an output is assumed by GCC to be unchanged, for example &lt;code&gt;&quot;b&quot; (16)&lt;/code&gt; below sets up &lt;code&gt;%11&lt;/code&gt; to 16, and GCC might use that register in following code if the value 16 happened to be needed. You can even use a normal &lt;code&gt;asm&lt;/code&gt; output for a scratch if all inputs that might share the same register are consumed before the scratch is used. The VSX registers clobbered by the &lt;code&gt;asm&lt;/code&gt; statement could have used this technique except for GCC&amp;rsquo;s limit on the number of &lt;code&gt;asm&lt;/code&gt; parameters.</source>
          <target state="translated">대안은 &lt;code&gt;asm&lt;/code&gt; 문에 스크래치 레지스터를 제공하기 위해 클로버를 통해 고정 레지스터를 할당 하는 대신 변수를 정의하고 아래 예의 &lt;code&gt;a2&lt;/code&gt; 및 &lt;code&gt;a3&lt;/code&gt; 에서 와 같이 초기 클로버 출력으로 만드는 것 입니다. 이것은 컴파일러 레지스터 할당 자에게 더 많은 자유를줍니다. 변수를 정의하고 &lt;code&gt;ap&lt;/code&gt; 및 &lt;code&gt;lda&lt;/code&gt; 에 각각 연결된 &lt;code&gt;a0&lt;/code&gt; 및 &lt;code&gt;a1&lt;/code&gt; 과 같이 입력에 연결된 출력으로 만들 수도 있습니다. 물론, 묶인 출력으로 당신의 &lt;code&gt;asm&lt;/code&gt; 하나의 동일한 레지스터이므로 출력 레지스터를 수정 한 후 입력 값을 사용할 수 없습니다. 또한 출력에서 ​​초기 클로버를 생략하면 GCC가 &lt;code&gt;asm&lt;/code&gt; 에 입력 할 때 동일한 값을 가지고 있음을 GCC가 확인할 수있는 경우 GCC가 다른 레지스터에 동일한 레지스터를 할당 할 수 있습니다. 이것이 &lt;code&gt;a1&lt;/code&gt; 이 초기 클로버를 갖는 이유 입니다. 그것의 묶인 입력, &lt;code&gt;lda&lt;/code&gt; 는 값 16을 가지고 있으며 초기 클로버가 없으면 &lt;code&gt;%11&lt;/code&gt; 과 동일한 레지스터를 공유하는 것으로 알려져 있습니다 . 반면에 &lt;code&gt;ap&lt;/code&gt; 는 다른 입력과 같을 수 없으므로 &lt;code&gt;a0&lt;/code&gt; 의 초기 클로버 는 필요하지 않습니다. 이 경우에도 바람직하지 않습니다. &lt;code&gt;a0&lt;/code&gt; 의 초기 클로버GCC가 &lt;code&gt;&quot;m&quot; (*(const double (*)[]) ap)&lt;/code&gt; 입력에 대해 별도의 레지스터를 할당하게합니다 . 입력에 출력을 연결하는 것은 &lt;code&gt;asm&lt;/code&gt; 문으로 수정 된 초기화 된 임시 레지스터를 설정하는 방법 입니다. 출력에 연결되지 않은 입력은 GCC에 의해 변경되지 않은 것으로 가정합니다. 예를 들어 아래의 &lt;code&gt;&quot;b&quot; (16)&lt;/code&gt; 는 &lt;code&gt;%11&lt;/code&gt; ~ 16을 설정 하고 값 16이 필요한 경우 다음 코드에서 해당 레지스터를 사용할 수 있습니다. 스크래치를 사용하기 전에 동일한 레지스터를 공유 할 수있는 모든 입력을 사용하는 경우 스크래치를 위해 일반 &lt;code&gt;asm&lt;/code&gt; 출력을 사용할 수도 있습니다. &lt;code&gt;asm&lt;/code&gt; 문으로 클로버 된 VSX 레지스터 는 GCC의 개수 제한을 제외하고이 기술을 사용할 수 있습니다. &lt;code&gt;asm&lt;/code&gt; 매개 변수.</target>
        </trans-unit>
        <trans-unit id="131238f337a82403a435f04af76b710a1a825a6e" translate="yes" xml:space="preserve">
          <source>Rather than using the built-ins directly, it is preferred for programs to include</source>
          <target state="translated">내장 기능을 직접 사용하는 것보다 프로그램이 다음을 포함하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3d48db591bff1043a0d8039e8ccf5e783e97e6a2" translate="yes" xml:space="preserve">
          <source>Rcq</source>
          <target state="translated">Rcq</target>
        </trans-unit>
        <trans-unit id="521f78e80ba6f8863e858ff98f48391a0330829a" translate="yes" xml:space="preserve">
          <source>Rcw</source>
          <target state="translated">Rcw</target>
        </trans-unit>
        <trans-unit id="8b8331348b2521f417469192e2b07ba6bae059df" translate="yes" xml:space="preserve">
          <source>Re-run common subexpression elimination after loop optimizations are performed.</source>
          <target state="translated">루프 최적화가 수행 된 후 공통 하위 표현식 제거를 다시 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="47e55523da5572635c20ab856b76afcfa5225486" translate="yes" xml:space="preserve">
          <source>Read command-line options from &lt;var&gt;file&lt;/var&gt;. The options read are inserted in place of the original @&lt;var&gt;file&lt;/var&gt; option. If &lt;var&gt;file&lt;/var&gt; does not exist, or cannot be read, then the option will be treated literally, and not removed.</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt; 에서 명령 행 옵션을 읽으십시오 . 읽은 옵션은 원본 @ &lt;var&gt;file&lt;/var&gt; 옵션 대신 삽입됩니다 . 경우 &lt;var&gt;file&lt;/var&gt; 존재하지 않거나 읽을 수 없습니다, 다음 옵션은 말 그대로 처리, 제거되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ee0598dcd3bf6f16e79ad5d502ed56654313a31d" translate="yes" xml:space="preserve">
          <source>Read the most or least (respectively) significant half of X and store it in &lt;var&gt;dest&lt;/var&gt;.</source>
          <target state="translated">X의 최대 또는 최소 (각각) 중요 부분을 읽고 &lt;var&gt;dest&lt;/var&gt; 에 저장하십시오 .</target>
        </trans-unit>
        <trans-unit id="7a126a185b0d0082578e19ef3a5daeade792a6f6" translate="yes" xml:space="preserve">
          <source>Read the specified profile directory and rewrite to a new directory.</source>
          <target state="translated">지정된 프로파일 디렉토리를 읽고 새 디렉토리에 다시 쓰십시오.</target>
        </trans-unit>
        <trans-unit id="1324c749c5caee9deabe2d1d46a7919f7a43e96a" translate="yes" xml:space="preserve">
          <source>Read the value of Y and store it into &lt;var&gt;dest&lt;/var&gt;.</source>
          <target state="translated">Y 값을 읽고 &lt;var&gt;dest&lt;/var&gt; 에 저장하십시오 .</target>
        </trans-unit>
        <trans-unit id="2e0e1585c9e916aa0dcd09633e5b74f9bffa47f5" translate="yes" xml:space="preserve">
          <source>Reading across the 64 KiB section boundary of the &lt;code&gt;__flash&lt;/code&gt; or &lt;code&gt;__flash&lt;var&gt;N&lt;/var&gt;&lt;/code&gt; address spaces shows undefined behavior. The only address space that supports reading across the 64 KiB flash segment boundaries is &lt;code&gt;__memx&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;__flash&lt;/code&gt; 또는 &lt;code&gt;__flash&lt;var&gt;N&lt;/var&gt;&lt;/code&gt; 주소 공간 의 64 KiB 섹션 경계를 읽은 경우 정의되지 않은 동작이 나타납니다. 64 KiB 플래시 세그먼트 경계에서 읽기를 지원하는 유일한 주소 공간은 &lt;code&gt;__memx&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cc9977fd47f39524c5c4335bb2cc07440e340402" translate="yes" xml:space="preserve">
          <source>Real C type</source>
          <target state="translated">실제 C 타입</target>
        </trans-unit>
        <trans-unit id="b01207b1c7506846e0bfacee12ec2af4714dfc01" translate="yes" xml:space="preserve">
          <source>Realign the stack at entry. On the x86, the</source>
          <target state="translated">입구에 용지를 다시 맞 춥니 다. x86에서</target>
        </trans-unit>
        <trans-unit id="f8d3df1ed60f0155cff1c249d5d8c961d1ce5254" translate="yes" xml:space="preserve">
          <source>Recall that a compound statement is a sequence of statements surrounded by braces; in this construct, parentheses go around the braces. For example:</source>
          <target state="translated">복합 명령문은 중괄호로 묶인 일련의 명령문입니다. 이 구문에서 괄호는 괄호를 둘러 쌉니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f625feb6c1f19cc48c16f0f10876aa7bd3ff669d" translate="yes" xml:space="preserve">
          <source>Recognize EUCJP characters.</source>
          <target state="translated">EUCJP 문자를 인식하십시오.</target>
        </trans-unit>
        <trans-unit id="7c01853b77bfeb03d9b038e23e661cf8dc08fff1" translate="yes" xml:space="preserve">
          <source>Recognize JIS characters.</source>
          <target state="translated">JIS 문자를 인식합니다.</target>
        </trans-unit>
        <trans-unit id="794f97acfad850c064b040b0a84cf0cc856becc0" translate="yes" xml:space="preserve">
          <source>Recognize SJIS characters.</source>
          <target state="translated">SJIS 문자를 인식합니다.</target>
        </trans-unit>
        <trans-unit id="27cc26e0565438fda7c152cefdfd1b3f962fba55" translate="yes" xml:space="preserve">
          <source>Record the time consumed by infrastructure parts separately for each pass.</source>
          <target state="translated">각 패스마다 인프라 부품이 소비하는 시간을 별도로 기록하십시오.</target>
        </trans-unit>
        <trans-unit id="fe2bbb8aea21cc382d288c61a66ab949bdc88ab3" translate="yes" xml:space="preserve">
          <source>Recursive cloning only when the probability of call being executed exceeds the parameter.</source>
          <target state="translated">호출이 실행될 확률이 매개 변수를 초과하는 경우에만 반복 복제.</target>
        </trans-unit>
        <trans-unit id="ecb4684dd74316d7840b5ce3326149ec45004d04" translate="yes" xml:space="preserve">
          <source>Recursive inlining is profitable only for function having deep recursion in average and can hurt for function having little recursion depth by increasing the prologue size or complexity of function body to other optimizers.</source>
          <target state="translated">재귀 적 인라이닝은 평균적으로 깊은 재귀를 갖는 함수에 대해서만 수익성이 있으며, 다른 옵티 마이저에 대한 프롤로그 크기 또는 함수 본체의 복잡성을 증가시켜 재귀 깊이가 적은 함수에 해를 끼칠 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d1dad90db7b45d2f00d2160233fcf301ebfc624" translate="yes" xml:space="preserve">
          <source>Reduce compilation time and make debugging produce the expected results. This is the default.</source>
          <target state="translated">컴파일 시간을 줄이고 디버깅으로 예상 결과를 얻습니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="6aec65068eeb8842d5e5c7061649e6408aeb8661" translate="yes" xml:space="preserve">
          <source>Reduce stack alignment on call sites if possible. Enabled by default.</source>
          <target state="translated">가능하면 호출 사이트에서 스택 정렬을 줄입니다. 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ae7930fe556a2ec3059d5f1104e863261afd8f6" translate="yes" xml:space="preserve">
          <source>Reduce target register priority for r0..r3 / r12..r15.</source>
          <target state="translated">r0..r3 / r12..r15의 대상 레지스터 우선 순위를 줄입니다.</target>
        </trans-unit>
        <trans-unit id="1cb5fa5caf504f40df07a2cdb9428651f086d6df" translate="yes" xml:space="preserve">
          <source>Reduced-precision reciprocal (sequence step 1) (&lt;code&gt;recip1.&lt;var&gt;fmt&lt;/var&gt;&lt;/code&gt;).</source>
          <target state="translated">정밀 감소 역수 (시퀀스 단계 1) ( &lt;code&gt;recip1.&lt;var&gt;fmt&lt;/var&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6b50a97d7c07e8e5ac702942c6a7c44137ba2c8f" translate="yes" xml:space="preserve">
          <source>Reduced-precision reciprocal (sequence step 2) (&lt;code&gt;recip2.&lt;var&gt;fmt&lt;/var&gt;&lt;/code&gt;).</source>
          <target state="translated">감소 된 정밀도의 역수 (시퀀스 2 단계) ( &lt;code&gt;recip2.&lt;var&gt;fmt&lt;/var&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="311a85e245f0ddc53f02f904b2b964a9654bf632" translate="yes" xml:space="preserve">
          <source>Reduced-precision reciprocal square root (sequence step 1) (&lt;code&gt;rsqrt1.&lt;var&gt;fmt&lt;/var&gt;&lt;/code&gt;).</source>
          <target state="translated">감소 된 정밀도 역수 제곱근 (시퀀스 단계 1) ( &lt;code&gt;rsqrt1.&lt;var&gt;fmt&lt;/var&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c3ac4a799c5d637561c73e206b8150513e28619c" translate="yes" xml:space="preserve">
          <source>Reduced-precision reciprocal square root (sequence step 2) (&lt;code&gt;rsqrt2.&lt;var&gt;fmt&lt;/var&gt;&lt;/code&gt;).</source>
          <target state="translated">감소 된 정밀도 역수 제곱근 (시퀀스 2 단계) ( &lt;code&gt;rsqrt2.&lt;var&gt;fmt&lt;/var&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="12e0462f32071ff4845c302840bb4153c2588c2c" translate="yes" xml:space="preserve">
          <source>Reduction add (&lt;code&gt;addr.ps&lt;/code&gt;).</source>
          <target state="translated">감소 추가 ( &lt;code&gt;addr.ps&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e0d244d016314e418eaa174fb12395086f569f16" translate="yes" xml:space="preserve">
          <source>Reduction multiply (&lt;code&gt;mulr.ps&lt;/code&gt;).</source>
          <target state="translated">감소 곱하기 ( &lt;code&gt;mulr.ps&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0bb3aef854538033314f9b9054c89b202a7a46e1" translate="yes" xml:space="preserve">
          <source>Reentrant functions disable interrupts upon entry and enable them upon exit. Reentrant functions cannot also have the &lt;code&gt;naked&lt;/code&gt; or &lt;code&gt;critical&lt;/code&gt; attributes. They can have the &lt;code&gt;interrupt&lt;/code&gt; attribute.</source>
          <target state="translated">재진입 기능은 진입시 인터럽트를 비활성화하고 종료시 활성화합니다. 재진입 함수는 &lt;code&gt;naked&lt;/code&gt; 또는 &lt;code&gt;critical&lt;/code&gt; 속성을 가질 수 없습니다 . &lt;code&gt;interrupt&lt;/code&gt; 속성을 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="572b0899e79b2675d4a7828ac0598f6989f2d4b9" translate="yes" xml:space="preserve">
          <source>References to input, output, and goto operands in the assembler template of extended &lt;code&gt;asm&lt;/code&gt; statements can use modifiers to affect the way the operands are formatted in the code output to the assembler. For example, the following code uses the &amp;lsquo;</source>
          <target state="translated">확장 &lt;code&gt;asm&lt;/code&gt; 문의 어셈블러 템플릿에서 입력, 출력 및 goto 피연산자에 대한 참조 는 수정자를 사용하여 피연산자가 코드 출력에서 ​​어셈블러로 형식화되는 방식에 영향을 줄 수 있습니다. 예를 들어 다음 코드는 '</target>
        </trans-unit>
        <trans-unit id="37a430ef72ccbdfa3fd42aeebadb3c338dd54892" translate="yes" xml:space="preserve">
          <source>Reflects the &lt;code&gt;--with-double-comparison={tristate|bool|libf7}&lt;/code&gt;&lt;a href=&quot;https://gcc.gnu.org/install/configure.html#avr&quot;&gt;configure option&lt;/a&gt; and is defined to &lt;code&gt;2&lt;/code&gt; or &lt;code&gt;3&lt;/code&gt;.</source>
          <target state="translated">반영하며 &lt;code&gt;--with-double-comparison={tristate|bool|libf7}&lt;/code&gt; &lt;a href=&quot;https://gcc.gnu.org/install/configure.html#avr&quot;&gt;구성 옵션을&lt;/a&gt; 과에 정의 된 &lt;code&gt;2&lt;/code&gt; 또는 &lt;code&gt;3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4818801906599006df93661a53c0144ebcb2cff5" translate="yes" xml:space="preserve">
          <source>Reflects the &lt;code&gt;--with-libf7={libgcc|math|math-symbols}&lt;/code&gt;&lt;a href=&quot;https://gcc.gnu.org/install/configure.html#avr&quot;&gt;configure option&lt;/a&gt;.</source>
          <target state="translated">반영하며 &lt;code&gt;--with-libf7={libgcc|math|math-symbols}&lt;/code&gt; &lt;a href=&quot;https://gcc.gnu.org/install/configure.html#avr&quot;&gt;구성 옵션을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b1fccad55d1cd1e1deefbf2127cfdfd61810f2dd" translate="yes" xml:space="preserve">
          <source>Refrain from adding &lt;code&gt;.ident&lt;/code&gt; directives to the output file (this is the default).</source>
          <target state="translated">출력 파일에 &lt;code&gt;.ident&lt;/code&gt; 지시문을 추가하지 마십시오 (기본값).</target>
        </trans-unit>
        <trans-unit id="3001d626a710b17789a0092c43744394347ea069" translate="yes" xml:space="preserve">
          <source>Register &lt;code&gt;$3&lt;/code&gt;. Do not use this constraint in new code; it is retained only for compatibility with glibc.</source>
          <target state="translated">등록 &lt;code&gt;$3&lt;/code&gt; . 새 코드에서는이 제약 조건을 사용하지 마십시오. glibc와의 호환성을 위해서만 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="3567485f11d416ff7283001d94e2df1c5725db16" translate="yes" xml:space="preserve">
          <source>Register &lt;code&gt;r1&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;r1&lt;/code&gt; 등록</target>
        </trans-unit>
        <trans-unit id="9eb9c84600134957bc0bafd88d9264e6fe1a9153" translate="yes" xml:space="preserve">
          <source>Register &lt;code&gt;r2&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;r2&lt;/code&gt; 등록</target>
        </trans-unit>
        <trans-unit id="09b82e9bbfda6d5a540f8220132caa45617cfba9" translate="yes" xml:space="preserve">
          <source>Register &lt;code&gt;r3&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;r3&lt;/code&gt; 등록</target>
        </trans-unit>
        <trans-unit id="f6bc4e57659e02dd40d1f5e77c49bbd03b18fc44" translate="yes" xml:space="preserve">
          <source>Register B14 (aka DP).</source>
          <target state="translated">B14 (일명 DP)를 등록하십시오.</target>
        </trans-unit>
        <trans-unit id="533a97d446a8a5b93bc162a4324dc4171fb8ddfe" translate="yes" xml:space="preserve">
          <source>Register R12.</source>
          <target state="translated">R12를 등록하십시오.</target>
        </trans-unit>
        <trans-unit id="f1c1d776b68a0b27c9825edf576eb52eaa0cc6ec" translate="yes" xml:space="preserve">
          <source>Register R13.</source>
          <target state="translated">R13을 등록하십시오.</target>
        </trans-unit>
        <trans-unit id="1052cf107720625d376ff935f6870b8efc3827a7" translate="yes" xml:space="preserve">
          <source>Register destructors for objects with static storage duration with the &lt;code&gt;__cxa_atexit&lt;/code&gt; function rather than the &lt;code&gt;atexit&lt;/code&gt; function. This option is required for fully standards-compliant handling of static destructors, but only works if your C library supports &lt;code&gt;__cxa_atexit&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;atexit&lt;/code&gt; 함수가 아닌 &lt;code&gt;__cxa_atexit&lt;/code&gt; 함수를 사용하여 정적 저장 시간이있는 오브젝트의 소멸자를 등록 하십시오 . 이 옵션은 표준을 준수하는 정적 소멸자를 처리하는 데 필요하지만 C 라이브러리가 &lt;code&gt;__cxa_atexit&lt;/code&gt; 를 지원하는 경우에만 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="7c42270e4a24dd0bfbae7acb6e659ccc0acf3f22" translate="yes" xml:space="preserve">
          <source>Register file A (A0&amp;ndash;A31).</source>
          <target state="translated">파일 A를 등록하십시오 (A0&amp;ndash;A31).</target>
        </trans-unit>
        <trans-unit id="bdb218bd85a72cf91961a4baf75015f2c537debf" translate="yes" xml:space="preserve">
          <source>Register file A, excluding predicate registers (A3&amp;ndash;A31, plus A0 if not C64X or higher).</source>
          <target state="translated">술어 레지스터를 제외한 레지스터 파일 A (A3&amp;ndash;A31 및 C64X 이상이 아닌 경우 A0).</target>
        </trans-unit>
        <trans-unit id="1742f2e75d608f80fedddd8e77336383043c25ae" translate="yes" xml:space="preserve">
          <source>Register file B (B0&amp;ndash;B31).</source>
          <target state="translated">파일 B를 등록하십시오 (B0&amp;ndash;B31).</target>
        </trans-unit>
        <trans-unit id="1444488f53becce76ff486bdb18d0cd8356cea74" translate="yes" xml:space="preserve">
          <source>Register file B, excluding predicate registers (B3&amp;ndash;B31).</source>
          <target state="translated">술어 레지스터를 제외한 레지스터 파일 B (B3-B31).</target>
        </trans-unit>
        <trans-unit id="a59bf4be334c96a8db1601f16454148488cc2943" translate="yes" xml:space="preserve">
          <source>Register from r0 to r11 (all 16-bit registers)</source>
          <target state="translated">r0에서 r11까지 등록 (모든 16 비트 레지스터)</target>
        </trans-unit>
        <trans-unit id="480c1a3005b1f1617a3032a48dc7e43063c42c0c" translate="yes" xml:space="preserve">
          <source>Register from r12 to r15 (all 32-bit registers)</source>
          <target state="translated">r12에서 r15까지 등록 (모든 32 비트 레지스터)</target>
        </trans-unit>
        <trans-unit id="2b3c2b112d10d3044f325ab4493e523def957e04" translate="yes" xml:space="preserve">
          <source>Register in the class &lt;code&gt;ACCG_REGS&lt;/code&gt; (&lt;code&gt;accg0&lt;/code&gt; to &lt;code&gt;accg7&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;ACCG_REGS&lt;/code&gt; 클래스에 등록하십시오 ( &lt;code&gt;accg0&lt;/code&gt; ~ &lt;code&gt;accg7&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7da0fdc2c3630cb8c657242c1c4ac92c07fc0b4b" translate="yes" xml:space="preserve">
          <source>Register in the class &lt;code&gt;ACC_REGS&lt;/code&gt; (&lt;code&gt;acc0&lt;/code&gt; to &lt;code&gt;acc7&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;ACC_REGS&lt;/code&gt; 클래스에 등록하십시오 ( &lt;code&gt;acc0&lt;/code&gt; ~ &lt;code&gt;acc7&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="8d01bcabe56f9176a78fd1c7f42ce5bc52571e38" translate="yes" xml:space="preserve">
          <source>Register in the class &lt;code&gt;CC_REGS&lt;/code&gt; (&lt;code&gt;fcc0&lt;/code&gt; to &lt;code&gt;fcc3&lt;/code&gt; and &lt;code&gt;icc0&lt;/code&gt; to &lt;code&gt;icc3&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;CC_REGS&lt;/code&gt; 클래스에 등록하십시오 ( &lt;code&gt;fcc0&lt;/code&gt; ~ &lt;code&gt;fcc3&lt;/code&gt; 및 &lt;code&gt;icc0&lt;/code&gt; ~ &lt;code&gt;icc3&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="60401b0367db40fb60a9cde0e01a905072f4adce" translate="yes" xml:space="preserve">
          <source>Register in the class &lt;code&gt;CR_REGS&lt;/code&gt; (&lt;code&gt;cc0&lt;/code&gt; to &lt;code&gt;cc7&lt;/code&gt;).</source>
          <target state="translated">클래스에 등록 &lt;code&gt;CR_REGS&lt;/code&gt; ( &lt;code&gt;cc0&lt;/code&gt; 에 &lt;code&gt;cc7&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="59a99c246bcf173869c670543e28aefb7eaef202" translate="yes" xml:space="preserve">
          <source>Register in the class &lt;code&gt;EVEN_ACC_REGS&lt;/code&gt; (&lt;code&gt;acc0&lt;/code&gt; to &lt;code&gt;acc7&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;EVEN_ACC_REGS&lt;/code&gt; 클래스에 등록하십시오 ( &lt;code&gt;acc0&lt;/code&gt; ~ &lt;code&gt;acc7&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="dd4f2434b1ee5dd0a73e566a4353d3b841b3be02" translate="yes" xml:space="preserve">
          <source>Register in the class &lt;code&gt;EVEN_REGS&lt;/code&gt; (&lt;code&gt;gr0&lt;/code&gt; to &lt;code&gt;gr63&lt;/code&gt;). Odd registers are excluded not in the class but through the use of a machine mode larger than 4 bytes.</source>
          <target state="translated">&lt;code&gt;EVEN_REGS&lt;/code&gt; 클래스에 등록하십시오 ( &lt;code&gt;gr0&lt;/code&gt; ~ &lt;code&gt;gr63&lt;/code&gt; ). 홀수 레지스터는 클래스가 아니라 4 바이트보다 큰 머신 모드를 사용하여 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="7684a3097ebf46a01e56e039fccba7728030eae8" translate="yes" xml:space="preserve">
          <source>Register in the class &lt;code&gt;FCC_REGS&lt;/code&gt; (&lt;code&gt;fcc0&lt;/code&gt; to &lt;code&gt;fcc3&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;FCC_REGS&lt;/code&gt; 클래스 ( &lt;code&gt;fcc0&lt;/code&gt; ~ &lt;code&gt;fcc3&lt;/code&gt; )에 등록하십시오.</target>
        </trans-unit>
        <trans-unit id="5924427c40695e1f7e3fa17f28b85c901bb780f0" translate="yes" xml:space="preserve">
          <source>Register in the class &lt;code&gt;FCR_REGS&lt;/code&gt; (&lt;code&gt;cc0&lt;/code&gt; to &lt;code&gt;cc3&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;FCR_REGS&lt;/code&gt; 클래스 ( &lt;code&gt;cc0&lt;/code&gt; ~ &lt;code&gt;cc3&lt;/code&gt; )에 등록하십시오.</target>
        </trans-unit>
        <trans-unit id="65d5a8ed496d976776f700862d585c95cb234cc1" translate="yes" xml:space="preserve">
          <source>Register in the class &lt;code&gt;FEVEN_REGS&lt;/code&gt; (&lt;code&gt;fr0&lt;/code&gt; to &lt;code&gt;fr63&lt;/code&gt;). Odd registers are excluded not in the class but through the use of a machine mode larger than 4 bytes.</source>
          <target state="translated">&lt;code&gt;FEVEN_REGS&lt;/code&gt; 클래스에 등록하십시오 ( &lt;code&gt;fr0&lt;/code&gt; ~ &lt;code&gt;fr63&lt;/code&gt; ). 홀수 레지스터는 클래스가 아니라 4 바이트보다 큰 머신 모드를 사용하여 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="253b27d108e605b64087cadbee528e59c1f7a79f" translate="yes" xml:space="preserve">
          <source>Register in the class &lt;code&gt;FPR_REGS&lt;/code&gt; (&lt;code&gt;fr0&lt;/code&gt; to &lt;code&gt;fr63&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;FPR_REGS&lt;/code&gt; 클래스에 등록하십시오 ( &lt;code&gt;fr0&lt;/code&gt; ~ &lt;code&gt;fr63&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1a9a5917a9352a9b774047a78e988238f033f90b" translate="yes" xml:space="preserve">
          <source>Register in the class &lt;code&gt;GPR_REGS&lt;/code&gt; (&lt;code&gt;gr0&lt;/code&gt; to &lt;code&gt;gr63&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;GPR_REGS&lt;/code&gt; 클래스 ( &lt;code&gt;gr0&lt;/code&gt; ~ &lt;code&gt;gr63&lt;/code&gt; )에 등록하십시오.</target>
        </trans-unit>
        <trans-unit id="de6724c19d1c6001733a2c683050c56b6b1affbc" translate="yes" xml:space="preserve">
          <source>Register in the class &lt;code&gt;ICC_REGS&lt;/code&gt; (&lt;code&gt;icc0&lt;/code&gt; to &lt;code&gt;icc3&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;ICC_REGS&lt;/code&gt; 클래스 ( &lt;code&gt;icc0&lt;/code&gt; ~ &lt;code&gt;icc3&lt;/code&gt; )에 등록하십시오.</target>
        </trans-unit>
        <trans-unit id="0ca423076130e7e6489d4f896160ff5e22f77c62" translate="yes" xml:space="preserve">
          <source>Register in the class &lt;code&gt;ICR_REGS&lt;/code&gt; (&lt;code&gt;cc4&lt;/code&gt; to &lt;code&gt;cc7&lt;/code&gt;).</source>
          <target state="translated">클래스에 등록 &lt;code&gt;ICR_REGS&lt;/code&gt; ( &lt;code&gt;cc4&lt;/code&gt; 에 &lt;code&gt;cc7&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="148c41bd7ab7376f2591378add35d9d26efd9177" translate="yes" xml:space="preserve">
          <source>Register in the class &lt;code&gt;LR_REG&lt;/code&gt; (the &lt;code&gt;lr&lt;/code&gt; register).</source>
          <target state="translated">&lt;code&gt;LR_REG&lt;/code&gt; 클래스 ( &lt;code&gt;lr&lt;/code&gt; 레지스터)에 등록하십시오.</target>
        </trans-unit>
        <trans-unit id="a34d537ea831c75f947b48a3453e17d88afefaf4" translate="yes" xml:space="preserve">
          <source>Register in the class &lt;code&gt;QUAD_ACC_REGS&lt;/code&gt; (&lt;code&gt;acc0&lt;/code&gt; to &lt;code&gt;acc7&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;QUAD_ACC_REGS&lt;/code&gt; 클래스에 등록하십시오 ( &lt;code&gt;acc0&lt;/code&gt; ~ &lt;code&gt;acc7&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="510647219824fa78b9f755cf92ce845481e8c212" translate="yes" xml:space="preserve">
          <source>Register in the class &lt;code&gt;QUAD_FPR_REGS&lt;/code&gt; (&lt;code&gt;fr0&lt;/code&gt; to &lt;code&gt;fr63&lt;/code&gt;). Register numbers not divisible by 4 are excluded not in the class but through the use of a machine mode larger than 8 bytes.</source>
          <target state="translated">&lt;code&gt;QUAD_FPR_REGS&lt;/code&gt; 클래스에 등록하십시오 ( &lt;code&gt;fr0&lt;/code&gt; ~ &lt;code&gt;fr63&lt;/code&gt; ). 4로 나눌 수없는 레지스터 번호는 클래스가 아니라 8 바이트보다 큰 기계 모드를 사용하여 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="b2a1adf092bc540d607f8adfe316ebd0e23d6e5f" translate="yes" xml:space="preserve">
          <source>Register in the class &lt;code&gt;QUAD_REGS&lt;/code&gt; (&lt;code&gt;gr2&lt;/code&gt; to &lt;code&gt;gr63&lt;/code&gt;). Register numbers not divisible by 4 are excluded not in the class but through the use of a machine mode larger than 8 bytes.</source>
          <target state="translated">&lt;code&gt;QUAD_REGS&lt;/code&gt; 클래스에 등록하십시오 ( &lt;code&gt;gr2&lt;/code&gt; ~ &lt;code&gt;gr63&lt;/code&gt; ). 4로 나눌 수없는 레지스터 번호는 클래스가 아니라 8 바이트보다 큰 기계 모드를 사용하여 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="a9cbfc355864e59c43680683d72198de7278ba3e" translate="yes" xml:space="preserve">
          <source>Register in the class &lt;code&gt;SPR_REGS&lt;/code&gt; (&lt;code&gt;lcr&lt;/code&gt; and &lt;code&gt;lr&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;SPR_REGS&lt;/code&gt; 클래스 ( &lt;code&gt;lcr&lt;/code&gt; 및 &lt;code&gt;lr&lt;/code&gt; )에 등록하십시오.</target>
        </trans-unit>
        <trans-unit id="769f1e93ba84a3021586676ebf74ba9a35bdb862" translate="yes" xml:space="preserve">
          <source>Register offset addressing</source>
          <target state="translated">오프셋 주소 지정 레지스터</target>
        </trans-unit>
        <trans-unit id="c5f75dbc07c39bcb48abaeacbb855b7e10bf33e2" translate="yes" xml:space="preserve">
          <source>Register pair X (r27:r26)</source>
          <target state="translated">레지스터 쌍 X (r27 : r26)</target>
        </trans-unit>
        <trans-unit id="3b43e753bc9f5bc9b63c0e261a0e69e87d9b370f" translate="yes" xml:space="preserve">
          <source>Register pair Y (r29:r28)</source>
          <target state="translated">레지스터 쌍 Y (r29 : r28)</target>
        </trans-unit>
        <trans-unit id="8e0fa3a292eb7a9cffe0fac8e87c12161eb6cf21" translate="yes" xml:space="preserve">
          <source>Register pair Z (r31:r30)</source>
          <target state="translated">레지스터 쌍 Z (r31 : r30)</target>
        </trans-unit>
        <trans-unit id="025dbba0464975dfda3cfdcc9c21e3f5a63bca74" translate="yes" xml:space="preserve">
          <source>Register r0.</source>
          <target state="translated">r0을 등록하십시오.</target>
        </trans-unit>
        <trans-unit id="2559f54d5a47f8d70d102e65a5685a865132ce80" translate="yes" xml:space="preserve">
          <source>Register r1.</source>
          <target state="translated">r1을 등록하십시오.</target>
        </trans-unit>
        <trans-unit id="c9b7b7b870bca848747bbe900b4af27c68299883" translate="yes" xml:space="preserve">
          <source>Register r2.</source>
          <target state="translated">r2를 등록하십시오.</target>
        </trans-unit>
        <trans-unit id="c7b019e71df945fd75260cb8b739e27afabcb89d" translate="yes" xml:space="preserve">
          <source>Register r8.</source>
          <target state="translated">r8을 등록하십시오.</target>
        </trans-unit>
        <trans-unit id="cfa7fdd3bd0b34e806122b121b229661568a7a14" translate="yes" xml:space="preserve">
          <source>Registers are a scarce resource on most systems and allowing the compiler to manage their usage usually results in the best code. However, under special circumstances it can make sense to reserve some globally. For example this may be useful in programs such as programming language interpreters that have a couple of global variables that are accessed very often.</source>
          <target state="translated">레지스터는 대부분의 시스템에서 희소 한 리소스이며 컴파일러가 사용량을 관리하도록 허용하면 일반적으로 최상의 코드가 생성됩니다. 그러나 특별한 상황에서는 전 세계적으로 일부를 예약하는 것이 합리적입니다. 예를 들어 이것은 매우 자주 액세스되는 두 개의 전역 변수가있는 프로그래밍 언어 인터프리터와 같은 프로그램에서 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9258e74b890dc26f006130edaeedc1c986bbea52" translate="yes" xml:space="preserve">
          <source>Registers chat can hold 16 bit values, including all control registers.</source>
          <target state="translated">레지스터 채팅은 모든 제어 레지스터를 포함하여 16 비트 값을 보유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="756cb0ca2dcd3e9a9e7bd75807e28976eb525101" translate="yes" xml:space="preserve">
          <source>Registers from r0 to r14 (registers without stack pointer)</source>
          <target state="translated">r0 ~ r14의 레지스터 (스택 포인터가없는 레지스터)</target>
        </trans-unit>
        <trans-unit id="02e3921f37f882ea8d9c75adce25fafdbe8692d7" translate="yes" xml:space="preserve">
          <source>Registers from r0 to r15</source>
          <target state="translated">r0에서 r15까지 등록</target>
        </trans-unit>
        <trans-unit id="f9f658d92ebc98d15c63ce46e1732d5659102ede" translate="yes" xml:space="preserve">
          <source>Registers from r16 to r23</source>
          <target state="translated">r16에서 r23까지의 레지스터</target>
        </trans-unit>
        <trans-unit id="079d6f1b242baa1c7f0618d4f05a489251d1825b" translate="yes" xml:space="preserve">
          <source>Registers from r16 to r31</source>
          <target state="translated">r16에서 r31까지 등록</target>
        </trans-unit>
        <trans-unit id="489ac96c6b638b89a7b8ba2debb3353857a6eef8" translate="yes" xml:space="preserve">
          <source>Registers from r24 to r31. These registers can be used in &amp;lsquo;</source>
          <target state="translated">r24에서 r31까지 등록합니다. 이 레지스터는 '</target>
        </trans-unit>
        <trans-unit id="eeebb5d987a8e9e62e6d397774e01593c964d34f" translate="yes" xml:space="preserve">
          <source>Registers r0 and r1.</source>
          <target state="translated">r0 및 r1을 등록합니다.</target>
        </trans-unit>
        <trans-unit id="8300b61d2af50cc4dabd9f53915430a576a4f4a2" translate="yes" xml:space="preserve">
          <source>Registers r0 through r7.</source>
          <target state="translated">r0 ~ r7을 등록합니다.</target>
        </trans-unit>
        <trans-unit id="1bdabc9e342c28d99561b12e0784162f57cd5ff1" translate="yes" xml:space="preserve">
          <source>Registers r8 and r9.</source>
          <target state="translated">r8 및 r9를 등록합니다.</target>
        </trans-unit>
        <trans-unit id="46b53a197a4a621fbf89bc41aa1be3ce75327950" translate="yes" xml:space="preserve">
          <source>Registers that can be used with displacements ($a0, $a1, $sb).</source>
          <target state="translated">변위와 함께 사용할 수있는 레지스터 ($ a0, $ a1, $ sb).</target>
        </trans-unit>
        <trans-unit id="d44cddb1d6b35d0af8eee84e19b037c303c54a0d" translate="yes" xml:space="preserve">
          <source>Registers that can hold 16 bit values.</source>
          <target state="translated">16 비트 값을 보유 할 수있는 레지스터입니다.</target>
        </trans-unit>
        <trans-unit id="10c61cbba1cb11bc1f9e9cef337e27161929a237" translate="yes" xml:space="preserve">
          <source>Registers that can hold 32 bit values.</source>
          <target state="translated">32 비트 값을 보유 할 수있는 레지스터</target>
        </trans-unit>
        <trans-unit id="55f1a6e3e272896d0899d9ea18b33ee00c7e2940" translate="yes" xml:space="preserve">
          <source>Registers that can hold QI values.</source>
          <target state="translated">QI 값을 보유 할 수있는 레지스터입니다.</target>
        </trans-unit>
        <trans-unit id="cf58d717e47b85a4f429025faf79666cce971c58" translate="yes" xml:space="preserve">
          <source>Registers that can hold pointers (16 bit registers for r8c, m16c; 24 bit registers for m32cm, m32c).</source>
          <target state="translated">포인터를 보유 할 수있는 레지스터 (r8c, m16c의 경우 16 비트 레지스터, m32cm, m32c의 경우 24 비트 레지스터)</target>
        </trans-unit>
        <trans-unit id="caf84b9bb95c9665246bc340b9cdec9d8e62178c" translate="yes" xml:space="preserve">
          <source>Registers usable as base-regs of memory addresses in ARCompact 16-bit memory instructions: &lt;code&gt;r0&lt;/code&gt;-&lt;code&gt;r3&lt;/code&gt;, &lt;code&gt;r12&lt;/code&gt;-&lt;code&gt;r15&lt;/code&gt;, &lt;code&gt;sp&lt;/code&gt;. This constraint can only match when the</source>
          <target state="translated">ARCompact 16 비트 메모리 명령어 ( &lt;code&gt;r0&lt;/code&gt; - &lt;code&gt;r3&lt;/code&gt; , &lt;code&gt;r12&lt;/code&gt; - &lt;code&gt;r15&lt;/code&gt; , &lt;code&gt;sp&lt;/code&gt; ) 에서 메모리 주소의 기본 레지스터로 사용할 수 있도록 등록 합니다 . 이 제약 조건은</target>
        </trans-unit>
        <trans-unit id="a35caf683ee22a98f2498aca90a5baa9b5082d4e" translate="yes" xml:space="preserve">
          <source>Registers usable in ARCompact 16-bit instructions: &lt;code&gt;r0&lt;/code&gt;-&lt;code&gt;r3&lt;/code&gt;, &lt;code&gt;r12&lt;/code&gt;-&lt;code&gt;r15&lt;/code&gt;. This constraint can only match when the</source>
          <target state="translated">: 레지스터는 ARCompact 16 비트 명령어에서 사용할 수 &lt;code&gt;r0&lt;/code&gt; - &lt;code&gt;r3&lt;/code&gt; , &lt;code&gt;r12&lt;/code&gt; - &lt;code&gt;r15&lt;/code&gt; . 이 제약 조건은</target>
        </trans-unit>
        <trans-unit id="19e1e0518e942309076618fad593fdad104075c6" translate="yes" xml:space="preserve">
          <source>Registers used for circular buffering, i.e. I, B, or L registers.</source>
          <target state="translated">순환 버퍼링에 사용되는 레지스터, 즉 I, B 또는 L 레지스터</target>
        </trans-unit>
        <trans-unit id="77ea1d61c29764c1f5fd6dc887e5e48e1ad31364" translate="yes" xml:space="preserve">
          <source>Regrettable things we cannot change, but not quite bugs.</source>
          <target state="translated">유감스럽게도 변경할 수는 없지만 버그는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="32092d009780b34590134ea6fce964ac071704f4" translate="yes" xml:space="preserve">
          <source>Relaxation is a GNU feature and for safety reasons is disabled when using</source>
          <target state="translated">Relaxation은 GNU 기능이며 안전상의 이유로 사용할 때 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="d425b70c81109fac404a0fdbe25847f8affed9e1" translate="yes" xml:space="preserve">
          <source>Relaxed Memory Order</source>
          <target state="translated">편안한 메모리 순서</target>
        </trans-unit>
        <trans-unit id="dcf0a37891b53a0ada46be28abcde8419a66138e" translate="yes" xml:space="preserve">
          <source>Relaxing must be turned on if linker stubs are needed, see the section on &lt;code&gt;EIND&lt;/code&gt; and linker stubs below.</source>
          <target state="translated">링커 스텁이 필요한 경우 휴식을 켜야합니다 . 아래의 &lt;code&gt;EIND&lt;/code&gt; 및 링커 스텁 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d7020f448aaf8aacc8b4d63537e375e865fff9d8" translate="yes" xml:space="preserve">
          <source>Remarks</source>
          <target state="translated">Remarks</target>
        </trans-unit>
        <trans-unit id="bd65f12268c9cd14645e3d325d57c4b3512607f7" translate="yes" xml:space="preserve">
          <source>Remove all occurrences of &lt;code&gt;-S&lt;/code&gt; from the command line. Note&amp;mdash;this command is position dependent. &amp;lsquo;</source>
          <target state="translated">명령 행에서 모든 &lt;code&gt;-S&lt;/code&gt; 를 제거하십시오 . 참고 &amp;mdash;이 명령은 위치에 따라 다릅니다. '</target>
        </trans-unit>
        <trans-unit id="5b528b4646554331e8a3d8f764cb6e6d2423c0b0" translate="yes" xml:space="preserve">
          <source>Remove all symbol table and relocation information from the executable.</source>
          <target state="translated">실행 파일에서 모든 심볼 테이블과 재배치 정보를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="9042eb2108ad4333137f668f9d20f239e0364cbc" translate="yes" xml:space="preserve">
          <source>Rename the spec string &lt;var&gt;old_name&lt;/var&gt; to &lt;var&gt;new_name&lt;/var&gt;.</source>
          <target state="translated">스펙 문자열 &lt;var&gt;old_name&lt;/var&gt; 을 &lt;var&gt;new_name&lt;/var&gt; 으로 바꾸십시오 .</target>
        </trans-unit>
        <trans-unit id="a57f3dbe9a8b794ea15e657f613c3dee256ad6e3" translate="yes" xml:space="preserve">
          <source>Reorder basic blocks in the compiled function in order to reduce number of taken branches and improve code locality.</source>
          <target state="translated">가져온 분기 수를 줄이고 코드 위치를 개선하기 위해 컴파일 된 함수에서 기본 블록을 재정렬하십시오.</target>
        </trans-unit>
        <trans-unit id="868b5a2b9f40116ce6cc017884431ba3599c4f2c" translate="yes" xml:space="preserve">
          <source>Reorder functions in the object file in order to improve code locality. This is implemented by using special subsections &lt;code&gt;.text.hot&lt;/code&gt; for most frequently executed functions and &lt;code&gt;.text.unlikely&lt;/code&gt; for unlikely executed functions. Reordering is done by the linker so object file format must support named sections and linker must place them in a reasonable way.</source>
          <target state="translated">코드 지역성을 향상시키기 위해 객체 파일의 함수를 재정렬합니다. 이 특별한 하위 사용하여 구현됩니다 &lt;code&gt;.text.hot&lt;/code&gt; 가장 자주 실행되는 기능 및 &lt;code&gt;.text.unlikely&lt;/code&gt; 가능성 실행 기능을. 재 배열은 링커에 의해 수행되므로 객체 파일 형식은 명명 된 섹션을 지원해야하며 링커는 적절한 방법으로 섹션을 배치해야합니다.</target>
        </trans-unit>
        <trans-unit id="4db98af9e39320a953bbea6bb998fe7493c40e5e" translate="yes" xml:space="preserve">
          <source>Replaced by</source>
          <target state="translated">로 교체되다</target>
        </trans-unit>
        <trans-unit id="66ec31a6cc491021c387eb4e55e0ad4c5a4f7424" translate="yes" xml:space="preserve">
          <source>Report the CPU time taken by each subprocess in the compilation sequence. For C source files, this is the compiler proper and assembler (plus the linker if linking is done).</source>
          <target state="translated">각 서브 프로세스가 수행 한 CPU 시간을 컴파일 순서로보고하십시오. C 소스 파일의 경우, 이는 컴파일러가 적절하고 어셈블러입니다 (링크가 완료된 경우 링커 포함).</target>
        </trans-unit>
        <trans-unit id="886e8af128447aeefef31c794358ef6bddcacd1c" translate="yes" xml:space="preserve">
          <source>Request debugging information and also use &lt;var&gt;level&lt;/var&gt; to specify how much information. The default level is 2.</source>
          <target state="translated">디버깅 정보를 요청하고 &lt;var&gt;level&lt;/var&gt; 을 사용 하여 정보의 양을 지정하십시오. 기본 수준은 2입니다.</target>
        </trans-unit>
        <trans-unit id="50792516332342d0d1eda395f8cfbb177e04fe78" translate="yes" xml:space="preserve">
          <source>Require (do not require) that code using the standard (uncompressed) MIPS ISA be link-compatible with MIPS16 and microMIPS code, and vice versa.</source>
          <target state="translated">표준 (압축되지 않은) MIPS ISA를 사용하는 코드는 MIPS16 및 microMIPS 코드와 링크 호환이되어야하며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="af5306e882621ffa9b4f415a4290811d77c026c0" translate="yes" xml:space="preserve">
          <source>Require a constant operand and print the constant expression with no punctuation.</source>
          <target state="translated">상수 피연산자가 필요하고 구두점없이 상수 표현식을 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="75dfdca44a05f21975d7bfe493dd698fbb1af400" translate="yes" xml:space="preserve">
          <source>Reserve space once for outgoing arguments in the function prologue rather than around each call. Generally beneficial for performance and size. Also needed for unwinding to avoid changing the stack frame around conditional code.</source>
          <target state="translated">각 호출이 아닌 함수 프롤로그에서 나가는 인수를 위해 한 번 공간을 확보하십시오. 일반적으로 성능과 크기에 유리합니다. 조건부 코드 주위의 스택 프레임을 변경하지 않으려면 풀기에도 필요합니다.</target>
        </trans-unit>
        <trans-unit id="94629eea0f8e1b90e19e833a19ccac13e4d420e3" translate="yes" xml:space="preserve">
          <source>Restrict the analyzer to run just the named checker, and enable it.</source>
          <target state="translated">명명 된 검사기 만 실행하도록 분석기를 제한하고 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="7fdab2693d6cbb613b61178d94663186d04bbeb3" translate="yes" xml:space="preserve">
          <source>Restricts generation of IT blocks to conform to the rules of ARMv8-A. IT blocks can only contain a single 16-bit instruction from a select set of instructions. This option is on by default for ARMv8-A Thumb mode.</source>
          <target state="translated">ARMv8-A 규칙을 준수하도록 IT 블록 생성을 제한합니다. IT 블록은 선택된 일련의 명령어 중 하나의 16 비트 명령어 만 포함 할 수 있습니다. 이 옵션은 ARMv8-A Thumb 모드에서 기본적으로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5415cb36e8b15e5a43bee566eb1a298ee341943" translate="yes" xml:space="preserve">
          <source>Return &amp;ldquo;short&amp;rdquo; &lt;code&gt;struct&lt;/code&gt; and &lt;code&gt;union&lt;/code&gt; values in memory like longer ones, rather than in registers. This convention is less efficient, but it has the advantage of allowing intercallability between GCC-compiled files and files compiled with other compilers, particularly the Portable C Compiler (pcc).</source>
          <target state="translated">레지스터가 아닌 더 긴 메모리처럼 &quot;짧은&quot; &lt;code&gt;struct&lt;/code&gt; 와 &lt;code&gt;union&lt;/code&gt; 값을 반환 합니다. 이 규칙은 비효율적이지만 GCC 컴파일 파일과 다른 컴파일러, 특히 Portable C Compiler (pcc)로 컴파일 된 파일 간의 상호 호환성을 허용한다는 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a50ab20cde7d366a67815b583ce3fa9e992f502c" translate="yes" xml:space="preserve">
          <source>Return 1 if &lt;var&gt;val&lt;/var&gt; is known to have the byte alignment given by &lt;var&gt;alignval&lt;/var&gt;, otherwise return 0. Note that this is different from</source>
          <target state="translated">&lt;var&gt;val&lt;/var&gt; 이 &lt;var&gt;alignval&lt;/var&gt; 에 의해 주어진 바이트 정렬을 갖는 것으로 알려진 경우 1을 리턴 하고 , 그렇지 않으면 0을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="f0dd2a1246825d5d496ccaf1b983d6b8565185f3" translate="yes" xml:space="preserve">
          <source>Return 8-byte vectors in memory instead of MMX registers. This is the default on Solaris 8 and 9 and VxWorks to match the ABI of the Sun Studio compilers until version 12. Later compiler versions (starting with Studio 12 Update 1) follow the ABI used by other x86 targets, which is the default on Solaris 10 and later. &lt;em&gt;Only&lt;/em&gt; use this option if you need to remain compatible with existing code produced by those previous compiler versions or older versions of GCC.</source>
          <target state="translated">MMX 레지스터 대신 메모리에 8 바이트 벡터를 반환합니다. 이것은 버전 12까지 Sun Studio 컴파일러의 ABI와 일치하는 Solaris 8 및 9 및 VxWorks의 기본값입니다. 이후의 컴파일러 버전 (Studio 12 업데이트 1부터 시작)은 다른 x86 대상 (Solaris의 기본값)에서 사용하는 ABI를 따릅니다. 10 이상. 이전 컴파일러 버전 또는 이전 버전의 GCC에서 생성 된 기존 코드와 호환 가능해야하는 경우 &lt;em&gt;에만&lt;/em&gt; 이 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7cd08f506bbc481490a4eaa7c9f2a0ea64c20349" translate="yes" xml:space="preserve">
          <source>Return 8-byte vectors in memory instead of MMX registers. This is the default on VxWorks to match the ABI of the Sun Studio compilers until version 12. &lt;em&gt;Only&lt;/em&gt; use this option if you need to remain compatible with existing code produced by those previous compiler versions or older versions of GCC.</source>
          <target state="translated">MMX 레지스터 대신 메모리에 8 바이트 벡터를 반환합니다. 이것은 버전 12까지 Sun Studio 컴파일러의 ABI와 일치하는 VxWorks의 기본값입니다. 이전 컴파일러 버전 또는 이전 버전의 GCC에서 생성 된 기존 코드와의 호환성을 유지해야하는 경우 &lt;em&gt;에만&lt;/em&gt; 이 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c21aa754cb318c04fb0ee764bc873d27cf0f356a" translate="yes" xml:space="preserve">
          <source>Return &lt;code&gt;struct&lt;/code&gt; and &lt;code&gt;union&lt;/code&gt; values in registers when possible. This is more efficient for small structures than</source>
          <target state="translated">가능하면 레지스터에서 &lt;code&gt;struct&lt;/code&gt; 및 &lt;code&gt;union&lt;/code&gt; 값을 반환 하십시오. 이것은 작은 구조물보다 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="36902af805238b98afe6ec42c8fc287d8ef121a4" translate="yes" xml:space="preserve">
          <source>Return VMS condition codes from &lt;code&gt;main&lt;/code&gt;. The default is to return POSIX-style condition (e.g. error) codes.</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 에서 VMS 조건 코드를 반환합니다 . 기본값은 POSIX 스타일 조건 (예 : 오류) 코드를 반환하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="4a959557662cc82b19295040cf9540ea2756207a" translate="yes" xml:space="preserve">
          <source>Return a nonzero value if a transaction is currently active, otherwise 0.</source>
          <target state="translated">트랜잭션이 현재 활성화되어 있으면 0이 아닌 값을 반환하고, 그렇지 않으면 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e2b1c139ef70f0354479708d23d7002bd34b77b0" translate="yes" xml:space="preserve">
          <source>Return all structures in memory (as specified by the AIX ABI).</source>
          <target state="translated">모든 구조를 메모리에 리턴하십시오 (AIX ABI에서 지정한대로).</target>
        </trans-unit>
        <trans-unit id="30d548f2a666f3d2dacef41428651a854ac9ec7e" translate="yes" xml:space="preserve">
          <source>Return floating-point results in ac0 (fr0 in Unix assembler syntax).</source>
          <target state="translated">부동 소수점 결과를 ac0으로 반환합니다 (Unix 어셈블러 구문에서 fr0).</target>
        </trans-unit>
        <trans-unit id="18c78c8de7fda3409221e2eb382dd5b60425f50a" translate="yes" xml:space="preserve">
          <source>Return floating-point results in memory. This is the default.</source>
          <target state="translated">부동 소수점 결과를 메모리에 반환합니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="b755295260a7fdcf5823a2b1f0e58a7da66e2993" translate="yes" xml:space="preserve">
          <source>Return structures smaller than 8 bytes in registers (as specified by the SVR4 ABI).</source>
          <target state="translated">레지스터에서 8 바이트보다 작은 구조를 반환합니다 (SVR4 ABI에서 지정한대로).</target>
        </trans-unit>
        <trans-unit id="3d89b1dbd918009a622c075a1068bdd32199587c" translate="yes" xml:space="preserve">
          <source>Return the content of a system register which is mapped by &lt;var&gt;sr&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;sr&lt;/var&gt; 로 매핑 된 시스템 레지스터의 내용을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4c8c8de6a7d4547a06d2be7861947f5101a14fa7" translate="yes" xml:space="preserve">
          <source>Return the content of a user space register which is mapped by &lt;var&gt;usr&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;usr&lt;/var&gt; 에 의해 매핑 된 사용자 공간 레지스터의 내용을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b6ef9796498d3cf9c9b3db66db0d93d9f477244a" translate="yes" xml:space="preserve">
          <source>Return the full 64-bit value of IACC0. The &lt;var&gt;reg&lt;/var&gt; argument is reserved for future expansion and must be 0.</source>
          <target state="translated">IACC0의 전체 64 비트 값을 반환합니다. &lt;var&gt;reg&lt;/var&gt; 인수는 미래의 확장을 위해 예약되어 있으며 0이어야합니다.</target>
        </trans-unit>
        <trans-unit id="d91fca12a5b708d6ecc723a264ae13bbf294ac10" translate="yes" xml:space="preserve">
          <source>Return the value of IACC0H if &lt;var&gt;reg&lt;/var&gt; is 0 and IACC0L if &lt;var&gt;reg&lt;/var&gt; is 1. Other values of &lt;var&gt;reg&lt;/var&gt; are rejected as invalid.</source>
          <target state="translated">경우 IACC0H의 값을 반환 &lt;var&gt;reg&lt;/var&gt; 있는 경우 0이고 IACC0L &lt;var&gt;reg&lt;/var&gt; 1. 다른 값입니다 &lt;var&gt;reg&lt;/var&gt; 무효로 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="7c3c1904eaf1f7ff88cdff376d592fd0116b430c" translate="yes" xml:space="preserve">
          <source>Return using the &lt;code&gt;deret&lt;/code&gt; instruction. Interrupt handlers that don&amp;rsquo;t have this attribute return using &lt;code&gt;eret&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;deret&lt;/code&gt; 명령을 사용하여 반환하십시오 . 이 속성이없는 인터럽트 처리기는 대신 &lt;code&gt;eret&lt;/code&gt; 을 사용하여 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="491a48cde73679c4ca1d8a8c89727d674aeaaaf5" translate="yes" xml:space="preserve">
          <source>Returning the new address in register &lt;code&gt;$31&lt;/code&gt;.</source>
          <target state="translated">레지스터 &lt;code&gt;$31&lt;/code&gt; 에 새 주소를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="74c0a885f7ba9097f37e8734157c3ad725a829d5" translate="yes" xml:space="preserve">
          <source>Returns &lt;var&gt;x&lt;/var&gt; with the order of the bytes reversed; for example, &lt;code&gt;0xaabb&lt;/code&gt; becomes &lt;code&gt;0xbbaa&lt;/code&gt;. Byte here always means exactly 8 bits.</source>
          <target state="translated">바이트 순서를 반대로하여 &lt;var&gt;x&lt;/var&gt; 를 반환합니다 . 예를 들어, &lt;code&gt;0xaabb&lt;/code&gt; 는 &lt;code&gt;0xbbaa&lt;/code&gt; 가 됩니다 . 여기서 바이트는 항상 정확히 8 비트를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0b996dc11180c5ec0a219a9ff967979bab82ce06" translate="yes" xml:space="preserve">
          <source>Returns a positive infinity, if supported by the floating-point format, else &lt;code&gt;DBL_MAX&lt;/code&gt;. This function is suitable for implementing the ISO C macro &lt;code&gt;HUGE_VAL&lt;/code&gt;.</source>
          <target state="translated">부동 소수점 형식이 지원하는 경우 양의 무한대를 리턴하고 그렇지 않으면 &lt;code&gt;DBL_MAX&lt;/code&gt; 를 리턴 합니다. 이 함수는 ISO C 매크로 &lt;code&gt;HUGE_VAL&lt;/code&gt; 을 구현하는 데 적합합니다 .</target>
        </trans-unit>
        <trans-unit id="444af2bf8634b26ae9a1f1a7ad3d817e427a36b4" translate="yes" xml:space="preserve">
          <source>Returns one plus the index of the least significant 1-bit of &lt;var&gt;x&lt;/var&gt;, or if &lt;var&gt;x&lt;/var&gt; is zero, returns zero.</source>
          <target state="translated">&lt;var&gt;x&lt;/var&gt; 의 최하위 1 비트 색인에 1을 더한 값을 반환 하거나 &lt;var&gt;x&lt;/var&gt; 가 0이면 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dd145587033c252d0c6c626afd75667794945e4a" translate="yes" xml:space="preserve">
          <source>Returns the first argument raised to the power of the second. Unlike the &lt;code&gt;pow&lt;/code&gt; function no guarantees about precision and rounding are made.</source>
          <target state="translated">두 번째 거듭 제곱으로 올린 첫 번째 인수를 반환합니다. &lt;code&gt;pow&lt;/code&gt; 함수 와 달리 정밀도와 반올림에 대한 보장은 없습니다.</target>
        </trans-unit>
        <trans-unit id="4894d6f1b8e22494899330d0555ad8ffa8201099" translate="yes" xml:space="preserve">
          <source>Returns the number of 1-bits in &lt;var&gt;x&lt;/var&gt;.</source>
          <target state="translated">1- 비트 수를 돌려 &lt;var&gt;x&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="ce29b9b6bb07f313a52a112df90327683c6c87b7" translate="yes" xml:space="preserve">
          <source>Returns the number of leading 0-bits in &lt;var&gt;x&lt;/var&gt;, starting at the most significant bit position. If &lt;var&gt;x&lt;/var&gt; is 0, the result is undefined.</source>
          <target state="translated">최상위 비트 위치에서 시작하여 &lt;var&gt;x&lt;/var&gt; 의 선행 0 비트 수를 반환합니다 . 경우에 &lt;var&gt;x&lt;/var&gt; 는 0이고, 결과는 정의되지 않는다.</target>
        </trans-unit>
        <trans-unit id="bafa0131b220bae62b75cbabaa4716f183d3539a" translate="yes" xml:space="preserve">
          <source>Returns the number of leading redundant sign bits in &lt;var&gt;x&lt;/var&gt;, i.e. the number of bits following the most significant bit that are identical to it. There are no special cases for 0 or other values.</source>
          <target state="translated">반환에 중복 부호 비트를 선도의 수를 &lt;var&gt;x&lt;/var&gt; , 즉 그것과 동일 최상위 비트 다음 비트의 수. 0 또는 다른 값에는 특별한 경우가 없습니다.</target>
        </trans-unit>
        <trans-unit id="8891f7de90b5ed2a6bcf46eb0d0dd183cbf8e095" translate="yes" xml:space="preserve">
          <source>Returns the number of trailing 0-bits in &lt;var&gt;x&lt;/var&gt;, starting at the least significant bit position. If &lt;var&gt;x&lt;/var&gt; is 0, the result is undefined.</source>
          <target state="translated">최하위 비트 위치에서 시작하여 &lt;var&gt;x&lt;/var&gt; 의 후행 0 비트 수를 반환합니다 . 경우에 &lt;var&gt;x&lt;/var&gt; 는 0이고, 결과는 정의되지 않는다.</target>
        </trans-unit>
        <trans-unit id="683aba47e0d0f99bd0b4e45d3206d9722f1a751a" translate="yes" xml:space="preserve">
          <source>Returns the openacc gang, worker or vector id depending on whether &lt;var&gt;x&lt;/var&gt; is 0, 1 or 2.</source>
          <target state="translated">&lt;var&gt;x&lt;/var&gt; 가 0, 1 또는 2 인지에 따라 openacc 갱, 워커 또는 벡터 ID를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b954a6b3f64ab16c6a6435467af5731684d67694" translate="yes" xml:space="preserve">
          <source>Returns the openacc gang, worker or vector size depending on whether &lt;var&gt;x&lt;/var&gt; is 0, 1 or 2.</source>
          <target state="translated">&lt;var&gt;x&lt;/var&gt; 가 0, 1 또는 2 인지에 따라 openacc 갱, 작업자 또는 벡터 크기를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="ce96cb4941a37e756412838ec82f95aa7bf28c53" translate="yes" xml:space="preserve">
          <source>Returns the parity of &lt;var&gt;x&lt;/var&gt;, i.e. the number of 1-bits in &lt;var&gt;x&lt;/var&gt; modulo 2.</source>
          <target state="translated">&lt;var&gt;x&lt;/var&gt; 의 패리티 , 즉 &lt;var&gt;x&lt;/var&gt; 모듈로 2 의 1 비트 수를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="db0ab2a04434d84e5f96198ad75f2283577abc26" translate="yes" xml:space="preserve">
          <source>Returns the size of an object pointed to by &lt;var&gt;ptr&lt;/var&gt;. See &lt;a href=&quot;object-size-checking#Object-Size-Checking&quot;&gt;Object Size Checking&lt;/a&gt;, for a detailed description of the function.</source>
          <target state="translated">&lt;var&gt;ptr&lt;/var&gt; 이 가리키는 객체의 크기를 반환합니다 . 기능에 대한 자세한 설명은 &lt;a href=&quot;object-size-checking#Object-Size-Checking&quot;&gt;객체 크기 확인을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="68a547fa5de03ac85628195326b7b381d300173e" translate="yes" xml:space="preserve">
          <source>Returns the value that is currently set in the &amp;lsquo;</source>
          <target state="translated">현재 '에 설정된 값을 반환합니다</target>
        </trans-unit>
        <trans-unit id="662ea5f2d376e017455cb3f3b25cf7d3dcc098a2" translate="yes" xml:space="preserve">
          <source>Revision 2 of the ASE was introduced in the second half of 2006. This revision adds extra instructions to the original ASE, but is otherwise backwards-compatible with it. You can select revision 2 using the command-line option</source>
          <target state="translated">ASE 개정판 2는 2006 년 하반기에 도입되었습니다.이 개정판은 원래 ASE에 추가 ​​지침을 추가하지만 이전 버전과 호환됩니다. 명령 행 옵션을 사용하여 개정 2를 선택할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="0f30b33f89f9ca36be8f698bd38e6d3998be756f" translate="yes" xml:space="preserve">
          <source>Rewrite the profile after removing a subset of the gcda files, while maintaining the consistency of the summary and the histogram.</source>
          <target state="translated">요약 및 히스토그램의 일관성을 유지하면서 gcda 파일의 서브 세트를 제거한 후 프로파일을 다시 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="2fe16a196b9fb96bcf22656d266c0859479e525c" translate="yes" xml:space="preserve">
          <source>Right-shift of -1, i.e., a bit mask with a trailing block of ones, the rest being zeroes. Or to put it another way, one less than a power of two. Can only match when the</source>
          <target state="translated">-1의 오른쪽 이동, 즉 후행 블록이 1 인 비트 마스크, 나머지는 0입니다. 또는 2의 거듭 제곱보다 하나 더 적은 다른 방법으로 표현하십시오. 때만 일치</target>
        </trans-unit>
        <trans-unit id="e687f82379bd394253bac71b24072104b029d942" translate="yes" xml:space="preserve">
          <source>Round towards minus infinity.</source>
          <target state="translated">빼기 무한대로 반올림합니다.</target>
        </trans-unit>
        <trans-unit id="1c3cd028b5f1e6b0edc653ec95977523018f750c" translate="yes" xml:space="preserve">
          <source>Run a pass to pack branches into VLIW instructions (default).</source>
          <target state="translated">분기를 VLIW 명령어로 포장하는 패스를 실행하십시오 (기본값).</target>
        </trans-unit>
        <trans-unit id="9411013c77a06e01966ed1ee47bcab5ff91c1389" translate="yes" xml:space="preserve">
          <source>Run the program on a representative workload to generate the arc profile information. This may be repeated any number of times. You can run concurrent instances of your program, and provided that the file system supports locking, the data files will be correctly updated. Unless a strict ISO C dialect option is in effect, &lt;code&gt;fork&lt;/code&gt; calls are detected and correctly handled without double counting.</source>
          <target state="translated">대표적인 워크로드에서 프로그램을 실행하여 아크 프로파일 정보를 생성하십시오. 이것은 여러 번 반복 될 수 있습니다. 프로그램의 동시 인스턴스를 실행할 수 있으며 파일 시스템이 잠금을 지원하면 데이터 파일이 올바르게 업데이트됩니다. 엄격한 ISO C 언어 옵션이 적용되지 않는 한 이중 통화없이 &lt;code&gt;fork&lt;/code&gt; 호출이 감지되고 올바르게 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="750febd8962214edbdb1e987e070e09b26bed006" translate="yes" xml:space="preserve">
          <source>Run variable tracking pass. It computes where variables are stored at each position in code. Better debugging information is then generated (if the debugging information format supports this information).</source>
          <target state="translated">변수 추적 패스를 실행하십시오. 코드의 각 위치에서 변수가 저장된 위치를 계산합니다. 그런 다음 더 나은 디버깅 정보가 생성됩니다 (디버깅 정보 형식이이 정보를 지원하는 경우).</target>
        </trans-unit>
        <trans-unit id="02a6d5433704778d27c91a559d1a246126ca2b03" translate="yes" xml:space="preserve">
          <source>Running &lt;code&gt;gcov&lt;/code&gt; with your program&amp;rsquo;s source file names as arguments will now produce a listing of the code along with frequency of execution for each line. For example, if your program is called</source>
          <target state="translated">실행 &lt;code&gt;gcov&lt;/code&gt; 의 인수로 프로그램의 소스 파일 이름은 각각의 라인이 실행 된 빈도와 함께 코드의 목록을 생성합니다. 예를 들어, 프로그램이 호출 된 경우</target>
        </trans-unit>
        <trans-unit id="6f72aac6d9b0821f24cd11653e9e1ea61d3b8eda" translate="yes" xml:space="preserve">
          <source>Running the program will cause profile output to be generated. For each source file compiled with</source>
          <target state="translated">프로그램을 실행하면 프로파일 출력이 생성됩니다. 로 컴파일 된 각 소스 파일에 대해</target>
        </trans-unit>
        <trans-unit id="c8eb0737c3e070d91c82da44ad778a26941751ad" translate="yes" xml:space="preserve">
          <source>S/390 and zSeries&amp;mdash;</source>
          <target state="translated">S / 390 및 zSeries&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="0a939f740002d6325878635a4ecb4eff29305501" translate="yes" xml:space="preserve">
          <source>SGPR register</source>
          <target state="translated">SGPR 레지스터</target>
        </trans-unit>
        <trans-unit id="52fb4091ed310353e09517862a36800ca2c86150" translate="yes" xml:space="preserve">
          <source>SGPR registers valid as a source for scalar memory instructions (excludes M0 and EXEC)</source>
          <target state="translated">SGPR 레지스터는 스칼라 메모리 명령어의 소스로 유효합니다 (M0 및 EXEC 제외).</target>
        </trans-unit>
        <trans-unit id="650aa12551cfc9241e1cd5e644660f68d55f375f" translate="yes" xml:space="preserve">
          <source>SGPR registers valid as a source or destination for vector instructions (excludes EXEC)</source>
          <target state="translated">SGPR 레지스터는 벡터 명령어의 소스 또는 대상으로 유효합니다 (EXEC 제외).</target>
        </trans-unit>
        <trans-unit id="e7dc62b437b8a1360c1151acc32ef2d34c838e11" translate="yes" xml:space="preserve">
          <source>SGPR registers valid for instruction destinations, including VCC, M0 and EXEC</source>
          <target state="translated">VCC, M0 및 EXEC를 포함한 명령어 대상에 유효한 SGPR 레지스터</target>
        </trans-unit>
        <trans-unit id="06d98e22c3590a0e22d3bfe590a8875bfcf62f6b" translate="yes" xml:space="preserve">
          <source>SGPR registers valid for instruction sources, including VCC, M0, EXEC and SCC</source>
          <target state="translated">VCC, M0, EXEC 및 SCC를 포함한 명령어 소스에 유효한 SGPR 레지스터</target>
        </trans-unit>
        <trans-unit id="f2bee3c133454cc4ba540d21be2c00a748ada303" translate="yes" xml:space="preserve">
          <source>SGR substring for colorizing paths of control-flow events as printed via</source>
          <target state="translated">를 통해 인쇄 된대로 제어 흐름 이벤트의 경로를 색상 화하기위한 SGR 하위 문자열</target>
        </trans-unit>
        <trans-unit id="c6b62b4cc9ebcf08c9d4f483e4f102a627e7a387" translate="yes" xml:space="preserve">
          <source>SGR substring for deleted lines within generated patches.</source>
          <target state="translated">생성 된 패치 내에서 삭제 된 행에 대한 SGR 하위 문자열</target>
        </trans-unit>
        <trans-unit id="4233963b1da8186d90f6982e524e354494399405" translate="yes" xml:space="preserve">
          <source>SGR substring for error: markers.</source>
          <target state="translated">오류의 SGR 부분 문자열 : 마커.</target>
        </trans-unit>
        <trans-unit id="f0f2ece3f5afef3a96618fb40d9e516c0938cd83" translate="yes" xml:space="preserve">
          <source>SGR substring for filename headers within generated patches.</source>
          <target state="translated">생성 된 패치 내의 파일 이름 헤더에 대한 SGR 하위 문자열</target>
        </trans-unit>
        <trans-unit id="ef3de6666e18bb1d0075a653fd3207878cc7a23b" translate="yes" xml:space="preserve">
          <source>SGR substring for first additional range.</source>
          <target state="translated">첫 번째 추가 범위에 대한 SGR 하위 문자열</target>
        </trans-unit>
        <trans-unit id="4047e51ab31499ea74aa0557270ff12e007c7adc" translate="yes" xml:space="preserve">
          <source>SGR substring for fix-it hints suggesting text to be deleted.</source>
          <target state="translated">텍스트 삭제를 제안하는 수정 사항 힌트의 SGR 서브 스트링.</target>
        </trans-unit>
        <trans-unit id="26c66a34977746cd4a9a18d107d2484d6baf05b6" translate="yes" xml:space="preserve">
          <source>SGR substring for fix-it hints suggesting text to be inserted or replaced.</source>
          <target state="translated">텍스트 삽입 또는 교체를 제안하는 수정 사항 힌트에 대한 SGR 서브 스트링.</target>
        </trans-unit>
        <trans-unit id="a9e49a359d82dca9087414389ea6203f7d97c096" translate="yes" xml:space="preserve">
          <source>SGR substring for highlighting mismatching types within template arguments in the C++ frontend.</source>
          <target state="translated">C ++ 프론트 엔드의 템플리트 인수에서 일치하지 않는 유형을 강조 표시하기위한 SGR 서브 스트링.</target>
        </trans-unit>
        <trans-unit id="c2c54171666812e81afa463446e8b8c7bf07a44f" translate="yes" xml:space="preserve">
          <source>SGR substring for information printed within quotes.</source>
          <target state="translated">따옴표 안에 인쇄 된 정보의 SGR 부분 문자열.</target>
        </trans-unit>
        <trans-unit id="21ec7b29e8556fe0733397c42965d397a384f312" translate="yes" xml:space="preserve">
          <source>SGR substring for inserted lines within generated patches.</source>
          <target state="translated">생성 된 패치 내에 삽입 된 라인의 SGR 서브 스트링.</target>
        </trans-unit>
        <trans-unit id="631ff44ce6295a577998e0d45d27d8697542d130" translate="yes" xml:space="preserve">
          <source>SGR substring for location information, &amp;lsquo;</source>
          <target state="translated">위치 정보에 대한 SGR 하위 문자열 '</target>
        </trans-unit>
        <trans-unit id="13b8b196547b7c911a6008681f44695559ee3d8a" translate="yes" xml:space="preserve">
          <source>SGR substring for note: markers.</source>
          <target state="translated">참고를위한 SGR 부분 문자열 : 마커.</target>
        </trans-unit>
        <trans-unit id="3c69ac2294e9dd81357177aa53e734578849f1b7" translate="yes" xml:space="preserve">
          <source>SGR substring for second additional range.</source>
          <target state="translated">두 번째 추가 범위에 대한 SGR 하위 문자열</target>
        </trans-unit>
        <trans-unit id="0836e70b794378ba99fbdf640887a055c2507059" translate="yes" xml:space="preserve">
          <source>SGR substring for the starts of hunks within generated patches.</source>
          <target state="translated">생성 된 패치 내에서 덩어리 시작을위한 SGR 서브 스트링.</target>
        </trans-unit>
        <trans-unit id="2ce0ddcf3a9872af855e6e18893f63c26237ec2f" translate="yes" xml:space="preserve">
          <source>SGR substring for warning: markers.</source>
          <target state="translated">경고 용 SGR 부분 문자열 : 마커.</target>
        </trans-unit>
        <trans-unit id="4ef460c02c4bda0400a9d02a2e56bc8688eea615" translate="yes" xml:space="preserve">
          <source>SIMD builtins provided by the compiler can be used to generate the vector instructions. This section describes the available builtins and their usage in programs. With the</source>
          <target state="translated">컴파일러가 제공하는 SIMD 내장을 사용하여 벡터 명령어를 생성 할 수 있습니다. 이 섹션에서는 사용 가능한 내장 및 프로그램에서의 사용법에 대해 설명합니다. 이랑</target>
        </trans-unit>
        <trans-unit id="ae4985ac14b1eabd45a1c1fcc429ea9f7090e85d" translate="yes" xml:space="preserve">
          <source>SIMD vector types declared using &lt;code&gt;__attribute ((vector_size))&lt;/code&gt; were mangled in a non-standard way that does not allow for overloading of functions taking vectors of different sizes.</source>
          <target state="translated">&lt;code&gt;__attribute ((vector_size))&lt;/code&gt; 를 사용하여 선언 된 SIMD 벡터 유형 은 다른 크기의 벡터를 사용하는 함수의 오버로드를 허용하지 않는 비표준 방식으로 맹 글링되었습니다.</target>
        </trans-unit>
        <trans-unit id="256c9f9a067e633db18da0ec81de7b585e074898" translate="yes" xml:space="preserve">
          <source>SIZE_MAX</source>
          <target state="translated">SIZE_MAX</target>
        </trans-unit>
        <trans-unit id="0c1688b370e73b8fab30795615287ddf0ee92cde" translate="yes" xml:space="preserve">
          <source>SPARC&amp;mdash;</source>
          <target state="translated">SPARC&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="4c33d2e33886a24479b8c7ca85ded7473e3a114a" translate="yes" xml:space="preserve">
          <source>SPU&amp;mdash;</source>
          <target state="translated">SPU&amp;mdash;</target>
        </trans-unit>
        <trans-unit id="d5ef57a9b4e24298fd79d6a4c241fc751bc397dc" translate="yes" xml:space="preserve">
          <source>SSE constant zero operand.</source>
          <target state="translated">SSE 상수 제로 피연산자.</target>
        </trans-unit>
        <trans-unit id="6b6185655c0d6d39e8477b7cf295bc855e8520de" translate="yes" xml:space="preserve">
          <source>SSE instructions.</source>
          <target state="translated">SSE 지침.</target>
        </trans-unit>
        <trans-unit id="ad670c94b7871773b33360abf956fb366993570e" translate="yes" xml:space="preserve">
          <source>SSE2 instructions.</source>
          <target state="translated">SSE2 지침.</target>
        </trans-unit>
        <trans-unit id="2369317c8b51e3b18170998e24ffa71aa0b8a0d0" translate="yes" xml:space="preserve">
          <source>SSE3 instructions.</source>
          <target state="translated">SSE3 지침.</target>
        </trans-unit>
        <trans-unit id="52027268fb40ad079dd27f174909bf61fa52b68f" translate="yes" xml:space="preserve">
          <source>SSE4.1 instructions.</source>
          <target state="translated">SSE4.1 지침.</target>
        </trans-unit>
        <trans-unit id="1220ef87db9d2afe63d2dbbebe7cc117f311cd6d" translate="yes" xml:space="preserve">
          <source>SSE4.2 instructions.</source>
          <target state="translated">SSE4.2 지침.</target>
        </trans-unit>
        <trans-unit id="14c8a208e6acf4297b13ae5c14762fb6cb87c9a5" translate="yes" xml:space="preserve">
          <source>SSE4A instructions.</source>
          <target state="translated">SSE4A 지침.</target>
        </trans-unit>
        <trans-unit id="a824cf2031e7a9f24844581ed281a20b09b219a7" translate="yes" xml:space="preserve">
          <source>SSSE3 instructions.</source>
          <target state="translated">SSSE3 지침.</target>
        </trans-unit>
        <trans-unit id="75f02b7e3264b6af278eeb7499231b0a15daefdb" translate="yes" xml:space="preserve">
          <source>STVX</source>
          <target state="translated">STVX</target>
        </trans-unit>
        <trans-unit id="f54d3d8da212d77cf012ec70b98f091e4df6592b" translate="yes" xml:space="preserve">
          <source>STXVD2X</source>
          <target state="translated">STXVD2X</target>
        </trans-unit>
        <trans-unit id="464ed831ffed8bdfd8130295a2edb2d9e9578400" translate="yes" xml:space="preserve">
          <source>STXVW4X</source>
          <target state="translated">STXVW4X</target>
        </trans-unit>
        <trans-unit id="b0dabbf327525cacc4497069188029fd059e7389" translate="yes" xml:space="preserve">
          <source>Safely accessing C data and calling functions from basic &lt;code&gt;asm&lt;/code&gt; is more complex than it may appear. To access C data, it is better to use extended &lt;code&gt;asm&lt;/code&gt;.</source>
          <target state="translated">C 데이터에 안전하게 액세스하고 기본 &lt;code&gt;asm&lt;/code&gt; 에서 함수를 호출하는 것은 보이는 것보다 더 복잡합니다. C 데이터에 액세스하려면 extended &lt;code&gt;asm&lt;/code&gt; 을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="4e1a6674d38590faffffeb4695d9d452b5339baa" translate="yes" xml:space="preserve">
          <source>Same as</source>
          <target state="translated">와 동일</target>
        </trans-unit>
        <trans-unit id="69d40738c15585e5ece8390b1d9dcc4417cde63d" translate="yes" xml:space="preserve">
          <source>Same as &amp;lsquo;</source>
          <target state="translated">'와 동일</target>
        </trans-unit>
        <trans-unit id="a79ab980d305db447bee9c479d0843b84bd7f8c7" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;__builtin_tbegin&lt;/code&gt; but without FPR saves and restores. Using this variant in code making use of FPRs will leave the FPRs in undefined state when entering the transaction abort handler code.</source>
          <target state="translated">&lt;code&gt;__builtin_tbegin&lt;/code&gt; 과 동일 하지만 FPR이 저장 및 복원되지 않습니다. FPR을 사용하는 코드에서이 변형을 사용하면 트랜잭션 중단 처리기 코드를 시작할 때 FPR이 정의되지 않은 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="4de3c96aaa50bbcebfe6c154f9425492819e4fda" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;__builtin_tbegin_retry&lt;/code&gt; but without FPR saves and restores. Using this variant in code making use of FPRs will leave the FPRs in undefined state when entering the transaction abort handler code.</source>
          <target state="translated">&lt;code&gt;__builtin_tbegin_retry&lt;/code&gt; 와 동일 하지만 FPR 저장 및 복원이 없습니다. FPR을 사용하는 코드에서이 변형을 사용하면 트랜잭션 중단 처리기 코드를 시작할 때 FPR이 정의되지 않은 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="d0f31e0230de2939ed9a4a3bfde6705e7873175b" translate="yes" xml:space="preserve">
          <source>Same as above, but for &lt;code&gt;long double&lt;/code&gt; instead of &lt;code&gt;double&lt;/code&gt;.</source>
          <target state="translated">위와 동일하지만 &lt;code&gt;long double&lt;/code&gt; 대신 long &lt;code&gt;double&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aac99bb488266e0b7b7ade351899535fdea6eef8" translate="yes" xml:space="preserve">
          <source>Sanitize global variables in selected user-defined sections. &lt;var&gt;si&lt;/var&gt; may contain wildcards.</source>
          <target state="translated">선택된 사용자 정의 섹션에서 전역 변수를 삭제합니다. &lt;var&gt;si&lt;/var&gt; 에는 와일드 카드가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9384413dcf3a99a56f6d5fb6ddd74fec9e18520d" translate="yes" xml:space="preserve">
          <source>Saturating addition. Return the result of adding &lt;var&gt;x&lt;/var&gt; and &lt;var&gt;y&lt;/var&gt;, storing the value 32767 if the result overflows.</source>
          <target state="translated">포화 첨가. &lt;var&gt;x&lt;/var&gt; 와 &lt;var&gt;y&lt;/var&gt; 를 더한 결과를 반환하고 결과가 오버플로되면 값 32767을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="504215725299cdd825dda25f0c85b38e0bd4d51e" translate="yes" xml:space="preserve">
          <source>Saturating subtraction. Return the result of subtracting &lt;var&gt;y&lt;/var&gt; from &lt;var&gt;x&lt;/var&gt;, storing the value -32768 if the result overflows.</source>
          <target state="translated">포화 빼기. &lt;var&gt;x&lt;/var&gt; 에서 &lt;var&gt;y&lt;/var&gt; 를 뺀 결과를 반환하고 결과가 오버플로 된 경우 -32768 값을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="20ad33acfaabe4d68a4482f6776dcaa2a9be1f91" translate="yes" xml:space="preserve">
          <source>Says that .ZZ files are, in fact, C++ source files.</source>
          <target state="translated">.ZZ 파일은 실제로 C ++ 소스 파일이라고합니다.</target>
        </trans-unit>
        <trans-unit id="b29493698792fa428aa92855b6cf7ad4a0f77c71" translate="yes" xml:space="preserve">
          <source>Says to make debugging dumps during compilation as specified by &lt;var&gt;letters&lt;/var&gt;. The flags documented here are those relevant to the preprocessor. Other &lt;var&gt;letters&lt;/var&gt; are interpreted by the compiler proper, or reserved for future versions of GCC, and so are silently ignored. If you specify &lt;var&gt;letters&lt;/var&gt; whose behavior conflicts, the result is undefined. See &lt;a href=&quot;developer-options#Developer-Options&quot;&gt;Developer Options&lt;/a&gt;, for more information.</source>
          <target state="translated">&lt;var&gt;letters&lt;/var&gt; 로 지정된대로 컴파일하는 동안 디버깅 덤프를 작성하도록합니다 . 여기에 문서화 된 플래그는 전처리 기와 관련된 플래그입니다. 다른 &lt;var&gt;letters&lt;/var&gt; 는 컴파일러에서 적절하게 해석되거나 이후 버전의 GCC 용으로 예약되므로 자동 무시됩니다. 동작이 충돌 하는 &lt;var&gt;letters&lt;/var&gt; 를 지정 하면 결과가 정의되지 않습니다. 자세한 정보는 &lt;a href=&quot;developer-options#Developer-Options&quot;&gt;개발자 옵션&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4060536ee75ab5287f71dfb97d864d7f22d2ca94" translate="yes" xml:space="preserve">
          <source>Says to make debugging dumps during compilation at times specified by &lt;var&gt;letters&lt;/var&gt;. This is used for debugging the RTL-based passes of the compiler.</source>
          <target state="translated">&lt;var&gt;letters&lt;/var&gt; 지정된 시간에 컴파일하는 동안 디버깅 덤프를 작성하도록합니다 . 컴파일러의 RTL 기반 패스를 디버깅하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d4f20ee224e1157c9c2cb4923edd8e603ca68078" translate="yes" xml:space="preserve">
          <source>Scalar condition register: SCC</source>
          <target state="translated">스칼라 조건 레지스터 : SCC</target>
        </trans-unit>
        <trans-unit id="112620d6eb072a0c362e896824493987aba20f3a" translate="yes" xml:space="preserve">
          <source>Scale factor to apply to the number of blocks in a threading path when comparing to the number of (scaled) statements.</source>
          <target state="translated">(스케일 된) 명령문 수와 비교할 때 스레딩 경로의 블록 수에 적용 할 스케일 팩터.</target>
        </trans-unit>
        <trans-unit id="95dbc5e98d074c513e988faebfbccb22e09ae395" translate="yes" xml:space="preserve">
          <source>Scale factor to apply to the number of statements in a threading path when comparing to the number of (scaled) blocks.</source>
          <target state="translated">(스케일링 된) 블록 수와 비교할 때 스레딩 경로의 명령문 수에 적용 할 스케일 팩터입니다.</target>
        </trans-unit>
        <trans-unit id="86cf479673ca3b066e5d67cd80cb00f46a9ad376" translate="yes" xml:space="preserve">
          <source>Scale the profile counters. The specified value can be in floating point value, or simple fraction value form, such 1, 2, 2/3, and 5/3.</source>
          <target state="translated">프로필 카운터를 조정하십시오. 지정된 값은 부동 소수점 값이거나 1, 2, 2/3 및 5/3와 같은 간단한 분수 값 형식 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff4952674116ca1ef68e6dc524bc6fd65b2aa9ad" translate="yes" xml:space="preserve">
          <source>Scaling factor in calculation of maximum distance an expression can be moved by GCSE optimizations. This is currently supported only in the code hoisting pass. The bigger the ratio, the more aggressive code hoisting is with simple expressions, i.e., the expressions that have cost less than</source>
          <target state="translated">GCSE 최적화를 통해 식의 최대 거리 계산시 배율을 조정할 수 있습니다. 이것은 현재 코드 호이 스팅 패스에서만 지원됩니다. 비율이 클수록 간단한 표현, 즉보다 적은 비용의 표현으로 더 적극적인 코드 게양</target>
        </trans-unit>
        <trans-unit id="532227f59708576e594e220bb0a8588203d0536c" translate="yes" xml:space="preserve">
          <source>Schedule code according to the constraints for the machine type &lt;var&gt;cpu-type&lt;/var&gt;. The choices for &lt;var&gt;cpu-type&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">머신 유형 &lt;var&gt;cpu-type&lt;/var&gt; 의 제한 조건에 따른 스케줄 코드 . &lt;var&gt;cpu-type&lt;/var&gt; 의 선택 은 '</target>
        </trans-unit>
        <trans-unit id="512110c2a7a87680ea125d2d5070dd617326491f" translate="yes" xml:space="preserve">
          <source>Schedule instructions using selective scheduling algorithm. Selective scheduling runs instead of the first scheduler pass.</source>
          <target state="translated">선택적 스케줄링 알고리즘을 사용하여 명령어를 예약합니다. 첫 번째 스케줄러 패스 대신 선택적 스케줄링이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="a8bc58f0865e7ffaa1277982a9a30e1e6328ca0f" translate="yes" xml:space="preserve">
          <source>Schedule instructions using selective scheduling algorithm. Selective scheduling runs instead of the second scheduler pass.</source>
          <target state="translated">선택적 스케줄링 알고리즘을 사용하여 명령어를 예약합니다. 두 번째 스케줄러 패스 대신 선택적 스케줄링이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="b5c9dbe52234ab7adfb9709d744b3335541af679" translate="yes" xml:space="preserve">
          <source>Schedule type of omp schedule for loops parallelized by parloops (static, dynamic, guided, auto, runtime).</source>
          <target state="translated">parloops (정적, 동적, 안내, 자동, 런타임)에 의해 병렬화 된 루프에 대한 일정 스케줄 유형입니다.</target>
        </trans-unit>
        <trans-unit id="090706d50c1a9631674ea954b72f473248174f5c" translate="yes" xml:space="preserve">
          <source>Schedules as an EV4 and has no instruction set extensions.</source>
          <target state="translated">EV4로 예약되며 명령어 세트 확장이 없습니다.</target>
        </trans-unit>
        <trans-unit id="e3bebf86216646d883305006d7a92a77b0a80860" translate="yes" xml:space="preserve">
          <source>Schedules as an EV5 and has no instruction set extensions.</source>
          <target state="translated">EV5로 예약되며 명령어 세트 확장이 없습니다.</target>
        </trans-unit>
        <trans-unit id="01ff3c69f7080eed625112079f8743f5f048b2bc" translate="yes" xml:space="preserve">
          <source>Schedules as an EV5 and supports the BWX and MAX extensions.</source>
          <target state="translated">EV5로 예약하고 BWX 및 MAX 확장을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="b44df77a439d014c7e3b18a60c36ae6be23b8bed" translate="yes" xml:space="preserve">
          <source>Schedules as an EV5 and supports the BWX extension.</source>
          <target state="translated">EV5로 예약하고 BWX 확장을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="d98e18423f9732958ffea0c6bd4bd7f9f1294627" translate="yes" xml:space="preserve">
          <source>Schedules as an EV6 and supports the BWX, CIX, FIX, and MAX extensions.</source>
          <target state="translated">EV6으로 예약하고 BWX, CIX, FIX 및 MAX 확장을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="bbf50f85903256e541bbf3311b99e71d3918fbbc" translate="yes" xml:space="preserve">
          <source>Schedules as an EV6 and supports the BWX, FIX, and MAX extensions.</source>
          <target state="translated">EV6으로 예약하고 BWX, FIX 및 MAX 확장을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="2933ec5911ccb0e4b7c1d0f9419a5e7a7d360e81" translate="yes" xml:space="preserve">
          <source>Scoped enumerators passed as arguments to a variadic function are promoted like unscoped enumerators, causing &lt;code&gt;va_arg&lt;/code&gt; to complain. On most targets this does not actually affect the parameter passing ABI, as there is no way to pass an argument smaller than &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">variadic 함수에 인수로 전달 된 범위가 지정된 열거자는 범위가 지정되지 않은 열거 자처럼 승격되어 &lt;code&gt;va_arg&lt;/code&gt; 가 불평하게합니다. 대부분의 대상에서 &lt;code&gt;int&lt;/code&gt; 보다 작은 인수를 전달할 방법이 없으므로 ABI를 전달하는 매개 변수에 실제로 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="178b5f6bb9943f6de74ed00010972a24a7bb5622" translate="yes" xml:space="preserve">
          <source>Search for &lt;var&gt;file&lt;/var&gt; and insert its text at the current point in the specs file.</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt; 검색 하고 스펙 파일의 현재 지점에 해당 텍스트를 삽입하십시오.</target>
        </trans-unit>
        <trans-unit id="ba898c1a0a41a81bab594f983313300f956e596d" translate="yes" xml:space="preserve">
          <source>Search the directories &lt;var&gt;dirs&lt;/var&gt;, and no others, for libraries specified with</source>
          <target state="translated">디렉토리 &lt;var&gt;dirs&lt;/var&gt; 를 검색하고 다른 디렉토리는 지정하지 않은 라이브러리를 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="240544ba3059ddd6fa51173abfa71bc79edad6e6" translate="yes" xml:space="preserve">
          <source>Search the library named &lt;var&gt;library&lt;/var&gt; when linking. (The second alternative with the library as a separate argument is only for POSIX compliance and is not recommended.)</source>
          <target state="translated">링크 할 때 library라는 &lt;var&gt;library&lt;/var&gt; 검색하십시오 . (라이브러리를 별도의 인수로 사용하는 두 번째 대안은 POSIX 준수 전용이며 권장되지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="2f6637081eaeba40dac20edac8983d65e9c687dd" translate="yes" xml:space="preserve">
          <source>Second from top of 80387 floating-point stack (&lt;code&gt;%st(1)&lt;/code&gt;).</source>
          <target state="translated">80387 부동 소수점 스택 ( &lt;code&gt;%st(1)&lt;/code&gt; )의 맨 위에서 두 번째입니다 .</target>
        </trans-unit>
        <trans-unit id="f2a9e9979a3fe235f6129e47257fa2f36d503ac5" translate="yes" xml:space="preserve">
          <source>Second, the argument is passed to the function using the calling conventions of the first member of the transparent union, not the calling conventions of the union itself. All members of the union must have the same machine representation; this is necessary for this argument passing to work properly.</source>
          <target state="translated">둘째, 인수는 공용체 자체의 호출 규칙이 아니라 투명한 공용체의 첫 번째 멤버의 호출 규칙을 사용하여 함수에 전달됩니다. 공용체의 모든 멤버는 동일한 머신 표현을 가져야합니다. 이 인수가 제대로 작동하려면이 과정이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ea3456e6bd81cdabf3c368be0bfbf5a7261e636e" translate="yes" xml:space="preserve">
          <source>Second, when the type of an anonymous field is a &lt;code&gt;typedef&lt;/code&gt; for a &lt;code&gt;struct&lt;/code&gt; or &lt;code&gt;union&lt;/code&gt;, code may refer to the field using the name of the &lt;code&gt;typedef&lt;/code&gt;.</source>
          <target state="translated">두 번째로, 익명 필드의 유형이 &lt;code&gt;struct&lt;/code&gt; 또는 &lt;code&gt;union&lt;/code&gt; 대한 &lt;code&gt;typedef&lt;/code&gt; 인 경우 코드는 &lt;code&gt;typedef&lt;/code&gt; 의 이름을 사용하여 필드를 참조 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f4677b56029d2d5a1454e15af8e873ba7843c108" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;arm-options#ARM-Options&quot;&gt;ARM Options&lt;/a&gt; and &lt;a href=&quot;aarch64-options#AArch64-Options&quot;&gt;AArch64 Options&lt;/a&gt; for more information on the availability of extensions.</source>
          <target state="translated">확장 가용성에 대한 자세한 내용 은 &lt;a href=&quot;arm-options#ARM-Options&quot;&gt;ARM 옵션&lt;/a&gt; 및 &lt;a href=&quot;aarch64-options#AArch64-Options&quot;&gt;AArch64 옵션&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a3ed7b770e23a9147c81b72b94f04738551cd044" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;assembler-options#Assembler-Options&quot;&gt;Passing Options to the Assembler&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;assembler-options#Assembler-Options&quot;&gt;어셈블러에 옵션 전달을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5fa624e4b9bdd50f27ab9969ddbd05fadec90527" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;Attribute Syntax&lt;/a&gt;, for details of the exact syntax for using attributes.</source>
          <target state="translated">&lt;a href=&quot;attribute-syntax#Attribute-Syntax&quot;&gt;속성&lt;/a&gt; 사용에 대한 정확한 구문에 대한 자세한 내용은 속성 구문을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e7798844f22a2c2e6d35571a21bc9b88a41e9976" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;c-dialect-options#C-Dialect-Options&quot;&gt;Options Controlling C Dialect&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c-dialect-options#C-Dialect-Options&quot;&gt;C 방언 제어 옵션을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b629b8d91d57fd123b970633646d0ea0d91cd217" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;c_002b_002b-dialect-options#C_002b_002b-Dialect-Options&quot;&gt;Options Controlling C++ Dialect&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c_002b_002b-dialect-options#C_002b_002b-Dialect-Options&quot;&gt;C ++ 방언 제어 옵션을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7a9f7ae4d625bd6f1865541dd19d916bd7384014" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;c_002b_002b-interface#C_002b_002b-Interface&quot;&gt;Declarations and Definitions in One Header&lt;/a&gt;, for another way to control placement of these constructs.</source>
          <target state="translated">이러한 구문의 배치를 제어하는 ​​다른 방법 &lt;a href=&quot;c_002b_002b-interface#C_002b_002b-Interface&quot;&gt;은 한 헤더의 선언 및 정의를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f65573cc9b99e9cba7846f00d5e0e8a7a8e51df7" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;code-gen-options#Code-Gen-Options&quot;&gt;Options for Code Generation Conventions&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;code-gen-options#Code-Gen-Options&quot;&gt;코드 생성 규칙 옵션을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f2c2c26650fff8c74769de012a123d508e5fd307" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;debugging-options#Debugging-Options&quot;&gt;Options for Debugging Your Program&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;debugging-options#Debugging-Options&quot;&gt;프로그램 디버깅 옵션을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ed60c5c11a89d5b8997565970e20adef9aae6e73" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;developer-options#Developer-Options&quot;&gt;GCC Developer Options&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;developer-options#Developer-Options&quot;&gt;GCC 개발자 옵션을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="068f02a10a991b8dd4c9c4d4f1176aa1f6736565" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;diagnostic-message-formatting-options#Diagnostic-Message-Formatting-Options&quot;&gt;Options to Control Diagnostic Messages Formatting&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;diagnostic-message-formatting-options#Diagnostic-Message-Formatting-Options&quot;&gt;진단 메시지 형식을 제어하는 ​​옵션을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="980f2aedfa176760da97d08ae0c35c00555524bc" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;directory-options#Directory-Options&quot;&gt;Options for Directory Search&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;directory-options#Directory-Options&quot;&gt;디렉토리 검색 옵션을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b7df942c5c9bf184f3f2a89ce21ae90ce25b87ab" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;Function Attributes&lt;/a&gt;, for details of the semantics of attributes applying to functions. See &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;Variable Attributes&lt;/a&gt;, for details of the semantics of attributes applying to variables. See &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;Type Attributes&lt;/a&gt;, for details of the semantics of attributes applying to structure, union and enumerated types. See &lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;Label Attributes&lt;/a&gt;, for details of the semantics of attributes applying to labels. See &lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;Enumerator Attributes&lt;/a&gt;, for details of the semantics of attributes applying to enumerators. See &lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;Statement Attributes&lt;/a&gt;, for details of the semantics of attributes applying to statements.</source>
          <target state="translated">&lt;a href=&quot;function-attributes#Function-Attributes&quot;&gt;함수에&lt;/a&gt; 적용되는 속성의 의미에 대한 자세한 내용은 함수 속성을 참조하십시오 . &lt;a href=&quot;variable-attributes#Variable-Attributes&quot;&gt;변수에&lt;/a&gt; 적용되는 속성의 의미에 대한 자세한 내용은 변수 속성을 참조하십시오 . 구조, 공용체 및 열거 형에 적용되는 속성의 의미에 대한 자세한 내용은 &lt;a href=&quot;type-attributes#Type-Attributes&quot;&gt;유형 속성을&lt;/a&gt; 참조하십시오 . &lt;a href=&quot;label-attributes#Label-Attributes&quot;&gt;레이블에&lt;/a&gt; 적용되는 속성의 의미에 대한 자세한 내용은 레이블 속성을 참조하십시오 . &lt;a href=&quot;enumerator-attributes#Enumerator-Attributes&quot;&gt;열거 자에&lt;/a&gt; 적용되는 특성의 의미에 대한 자세한 내용은 열거 자 특성을 참조하십시오 . &lt;a href=&quot;statement-attributes#Statement-Attributes&quot;&gt;명령문에&lt;/a&gt; 적용되는 속성의 의미에 대한 자세한 내용은 명령문 속성을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="01ea811dd42662016230f114720fe01339ff4419" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;function-multiversioning#Function-Multiversioning&quot;&gt;Function Multiversioning&lt;/a&gt;, where it is used to specify the default function version.</source>
          <target state="translated">기본 기능 버전을 지정하는 데 사용되는 &lt;a href=&quot;function-multiversioning#Function-Multiversioning&quot;&gt;Function Multiversioning을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="148b71982b9647e6d6ecafa6882d1190f5b5569f" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Implementation_002ddefined-behavior.html#Implementation_002ddefined-behavior&quot;&gt;Implementation-defined behavior&lt;/a&gt; in The C Preprocessor, for details of these aspects of implementation-defined behavior.</source>
          <target state="translated">&lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Implementation_002ddefined-behavior.html#Implementation_002ddefined-behavior&quot;&gt;구현 정의 동작&lt;/a&gt; 의 이러한 측면에 대한 자세한 내용은 C 전 처리기에서 구현 정의 동작 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="18443493189256836930c6a050f4842f9c78519f" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Implementation_002ddefined-behavior.html#Implementation_002ddefined-behavior&quot;&gt;Implementation-defined behavior&lt;/a&gt; in The C Preprocessor.</source>
          <target state="translated">C 프리 프로세서의 &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Implementation_002ddefined-behavior.html#Implementation_002ddefined-behavior&quot;&gt;구현 정의 동작&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c7d31e8396ed3e8775b3882f9a8562adac8992e6" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Implementation_002ddefined-behavior.html#Implementation_002ddefined-behavior&quot;&gt;Implementation-defined behavior&lt;/a&gt; in The C Preprocessor. &lt;code&gt;char16_t&lt;/code&gt; and &lt;code&gt;char32_t&lt;/code&gt; literals are always encoded in UTF-16 and UTF-32 respectively.</source>
          <target state="translated">C 프리 프로세서의 &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Implementation_002ddefined-behavior.html#Implementation_002ddefined-behavior&quot;&gt;구현 정의 동작&lt;/a&gt; 을 참조하십시오 . &lt;code&gt;char16_t&lt;/code&gt; 및 &lt;code&gt;char32_t&lt;/code&gt; 리터럴은 항상 각각 UTF-16 및 UTF-32로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="658fbadcbe7e3cfa27592bb7cc8aab369c0db247" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Pragmas.html#Pragmas&quot;&gt;Pragmas&lt;/a&gt; in The C Preprocessor, for details of pragmas accepted by GCC on all targets. See &lt;a href=&quot;pragmas#Pragmas&quot;&gt;Pragmas Accepted by GCC&lt;/a&gt;, for details of target-specific pragmas.</source>
          <target state="translated">모든 대상에서 GCC가 허용하는 pragma에 대한 자세한 내용은 C 전 처리기의 &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/cpp/Pragmas.html#Pragmas&quot;&gt;Pragma&lt;/a&gt; 를 참조하십시오 . 대상별 pragma에 대한 자세한 내용은 &lt;a href=&quot;pragmas#Pragmas&quot;&gt;GCC&lt;/a&gt; 에서 허용되는 pragma를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="21007d084137c7d2ec1671d76187750384f6f2e0" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gccint/Machine-Modes.html#Machine-Modes&quot;&gt;Machine Modes&lt;/a&gt; in GNU Compiler Collection (GCC) Internals, for a list of the possible keywords for &lt;var&gt;mode&lt;/var&gt;. You may also specify a mode of &lt;code&gt;byte&lt;/code&gt; or &lt;code&gt;__byte__&lt;/code&gt; to indicate the mode corresponding to a one-byte integer, &lt;code&gt;word&lt;/code&gt; or &lt;code&gt;__word__&lt;/code&gt; for the mode of a one-word integer, and &lt;code&gt;pointer&lt;/code&gt; or &lt;code&gt;__pointer__&lt;/code&gt; for the mode used to represent pointers.</source>
          <target state="translated">&lt;var&gt;mode&lt;/var&gt; 의 가능한 키워드 목록은 GNU 컴파일러 모음 (GCC) 내부의 &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gccint/Machine-Modes.html#Machine-Modes&quot;&gt;기계 모드&lt;/a&gt; 를 참조하십시오 . 당신은 또한의 모드를 지정할 수 있습니다 &lt;code&gt;byte&lt;/code&gt; 또는 &lt;code&gt;__byte__&lt;/code&gt; 를 1 바이트 정수에 해당하는 모드를 표시하는 &lt;code&gt;word&lt;/code&gt; 또는 &lt;code&gt;__word__&lt;/code&gt; 는 A 한 단어 정수 모드, 대한 &lt;code&gt;pointer&lt;/code&gt; 또는 &lt;code&gt;__pointer__&lt;/code&gt; 포인터를 나타 내기 위해 사용되는 모드입니다.</target>
        </trans-unit>
        <trans-unit id="2b73e4c61d6aa3ba91f4f3757ed312f0dea34e9a" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gfortran/Standards.html#Standards&quot;&gt;Standards&lt;/a&gt; in The GNU Fortran Compiler, for details of standards supported by GNU Fortran.</source>
          <target state="translated">참조 &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gfortran/Standards.html#Standards&quot;&gt;표준&lt;/a&gt; GNU 포트란 지원 기준의 자세한 내용은 GNU 포트란 컴파일러에 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4544c625c9250deeb4d1b2109535476e6a41bc9" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gnat_rm/index.html#Top&quot;&gt;About This Guide&lt;/a&gt; in GNAT Reference Manual, for information on standard conformance and compatibility of the Ada compiler.</source>
          <target state="translated">Ada 컴파일러의 표준 적합성 및 호환성에 대한 정보는 GNAT 참조 매뉴얼 &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gnat_rm/index.html#Top&quot;&gt;의이 안내서 정보를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="55b4d78ded59c60738ad7dd10ccaf7dcedeb36a8" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Option Index&lt;/a&gt;, for an index to GCC&amp;rsquo;s options.</source>
          <target state="translated">GCC 옵션에 대한 &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-10.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;색인&lt;/a&gt; 은 옵션 색인을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="02206115a18ef138f866a5377cf36d2dcdf3f39c" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;Option Index&lt;/a&gt;, for an index to GCC&amp;rsquo;s options.</source>
          <target state="translated">GCC 옵션에 대한 &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Option-Index.html#Option-Index&quot;&gt;색인&lt;/a&gt; 은 옵션 색인을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f92b372afeb33fdcb2e400c22586894ceb4a8913" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://www.akkadia.org/drepper/tls.pdf&quot;&gt;ELF Handling For Thread-Local Storage&lt;/a&gt; for a detailed explanation of the four thread-local storage addressing models, and how the runtime is expected to function.</source>
          <target state="translated">4 개의 스레드 로컬 저장소 주소 지정 모델과 런타임 작동 방식에 대한 자세한 설명은 &lt;a href=&quot;https://www.akkadia.org/drepper/tls.pdf&quot;&gt;스레드 로컬 저장소&lt;/a&gt; 에 대한 ELF 처리를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8e13ff5ec63319e8432be9ffc09617dcfec5efa5" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;instrumentation-options#Instrumentation-Options&quot;&gt;Program Instrumentation Options&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;instrumentation-options#Instrumentation-Options&quot;&gt;프로그램 계측 옵션을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7c45509f6f79a8b5d9dfd4c1f3557aba0312fefe" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;link-options#Link-Options&quot;&gt;Options for Linking&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;link-options#Link-Options&quot;&gt;연결 옵션을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e1d926ae4839442bf4ca475259e4691d6d87ea8e" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;microsoft-windows-function-attributes#Microsoft-Windows-Function-Attributes&quot;&gt;Microsoft Windows Function Attributes&lt;/a&gt;, for discussion of the &lt;code&gt;dllexport&lt;/code&gt; and &lt;code&gt;dllimport&lt;/code&gt; attributes.</source>
          <target state="translated">&lt;code&gt;dllexport&lt;/code&gt; 및 &lt;code&gt;dllimport&lt;/code&gt; 속성에 대한 설명은 &lt;a href=&quot;microsoft-windows-function-attributes#Microsoft-Windows-Function-Attributes&quot;&gt;Microsoft Windows 함수 속성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b9f06eae06e3de3e9542d05510637a475fc262bd" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;objective_002dc-and-objective_002dc_002b_002b-dialect-options#Objective_002dC-and-Objective_002dC_002b_002b-Dialect-Options&quot;&gt;Options Controlling Objective-C and Objective-C++ Dialects&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;objective_002dc-and-objective_002dc_002b_002b-dialect-options#Objective_002dC-and-Objective_002dC_002b_002b-Dialect-Options&quot;&gt;Objective-C 및 Objective-C ++ 방언 제어 옵션을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2c63c6c8e460a8cf682e66ddf66e9aa0d0e42598" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;optimize-options#Optimize-Options&quot;&gt;Options that Control Optimization&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;optimize-options#Optimize-Options&quot;&gt;최적화를 제어하는 ​​옵션을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="85e23a477ff3ed397006f7d7b24f8677346f373f" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;overall-options#Overall-Options&quot;&gt;Options Controlling the Kind of Output&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;overall-options#Overall-Options&quot;&gt;출력 종류 제어 옵션을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e8f74f8e18121481259f5157b4129afe2078cfe1" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;preprocessor-options#Preprocessor-Options&quot;&gt;Options Controlling the Preprocessor&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;preprocessor-options#Preprocessor-Options&quot;&gt;전 처리기 제어 옵션을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7419f71237f51267399c64c7786cdedb41924e54" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;rs_002f6000-and-powerpc-options#RS_002f6000-and-PowerPC-Options&quot;&gt;RS/6000 and PowerPC Options&lt;/a&gt;, for more information on whether long calls are necessary.</source>
          <target state="translated">긴 통화가 필요한지 여부에 대한 자세한 내용 은 &lt;a href=&quot;rs_002f6000-and-powerpc-options#RS_002f6000-and-PowerPC-Options&quot;&gt;RS / 6000 및 PowerPC 옵션&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="be6a4b97c04d8e12e6e473deb1c9a9e10689a66e" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;standards#Standards&quot;&gt;Language Standards Supported by GCC&lt;/a&gt;, for details of freestanding and hosted environments.</source>
          <target state="translated">독립형 및 호스팅 환경에 대한 자세한 내용은 &lt;a href=&quot;standards#Standards&quot;&gt;GCC&lt;/a&gt; 에서 지원하는 언어 표준을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ba9a6e9c7aff941ff05b9acae516bf8bb6d040a5" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;submodel-options#Submodel-Options&quot;&gt;Machine-Dependent Options&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;submodel-options#Submodel-Options&quot;&gt;시스템 종속 옵션을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b2ef31c8cf0906842f80898060f3a9631a0e782b" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;warning-options#Warning-Options&quot;&gt;Options to Request or Suppress Warnings&lt;/a&gt;, for more detail on these and related command-line options.</source>
          <target state="translated">이러한 명령 및 관련 명령 행 옵션에 대한 자세한 내용은 &lt;a href=&quot;warning-options#Warning-Options&quot;&gt;경고를 요청하거나 표시하지 않는 옵션을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="434c807b2e25d15f5d415ef83533343f55fbfad1" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;warning-options#Warning-Options&quot;&gt;Options to Request or Suppress Warnings&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;warning-options#Warning-Options&quot;&gt;경고를 요청하거나 억제하는 옵션을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2d8243a2c0e464492c9d563c4f92c56ae3421bcc" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">또한보십시오</target>
        </trans-unit>
        <trans-unit id="bda50b9f3b2060976d692aee1d5a5eba1e23d6ef" translate="yes" xml:space="preserve">
          <source>See also the &lt;code&gt;interrupt&lt;/code&gt; function attribute.</source>
          <target state="translated">&lt;code&gt;interrupt&lt;/code&gt; 기능 속성 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="eeb6c38f7196a47f72f632cd6967a92ae3e51f69" translate="yes" xml:space="preserve">
          <source>See also under &lt;a href=&quot;x86-options#x86-Options&quot;&gt;x86 Options&lt;/a&gt; for standard options.</source>
          <target state="translated">표준 &lt;a href=&quot;x86-options#x86-Options&quot;&gt;옵션에&lt;/a&gt; 대해서는 x86 옵션 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0ac2d935c64bc2be469f96342d1ea704cfe35909" translate="yes" xml:space="preserve">
          <source>See below for a documentation of the individual parameters controlling inlining and for the defaults of these parameters.</source>
          <target state="translated">인라인을 제어하는 ​​개별 매개 변수 및 이러한 매개 변수의 기본값에 대한 문서는 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2ccea17a61232afe4c2d489d47c0c9f6ac6d3602" translate="yes" xml:space="preserve">
          <source>Select a different format for printing diagnostics. &lt;var&gt;FORMAT&lt;/var&gt; is &amp;lsquo;</source>
          <target state="translated">진단 인쇄를 위해 다른 형식을 선택하십시오. &lt;var&gt;FORMAT&lt;/var&gt; 은 '</target>
        </trans-unit>
        <trans-unit id="1ce47ca4d6aa3221bdc1ff64eaa11ecfaa3bd85d" translate="yes" xml:space="preserve">
          <source>Select application model &lt;var&gt;app-model&lt;/var&gt;. Valid models are</source>
          <target state="translated">애플리케이션 모델 &lt;var&gt;app-model&lt;/var&gt; 을 선택하십시오 . 유효한 모델은</target>
        </trans-unit>
        <trans-unit id="d1e50956bbd1c0ef350e09e3963ba2a16dd200cb" translate="yes" xml:space="preserve">
          <source>Select between generating code that executes in ARM and Thumb states. The default for most configurations is to generate code that executes in ARM state, but the default can be changed by configuring GCC with the</source>
          <target state="translated">ARM 및 Thumb 상태에서 실행되는 코드 생성 중에서 선택하십시오. 대부분의 구성의 기본값은 ARM 상태에서 실행되는 코드를 생성하는 것이지만 GCC를 구성하여 기본값을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fbbf6e0767f80e0a0e9d40cacab1bf157a107962" translate="yes" xml:space="preserve">
          <source>Select big- or little-endian code. The default is little-endian.</source>
          <target state="translated">빅 엔디안 또는 리틀 엔디안 코드를 선택하십시오. 기본은 리틀 엔디안입니다.</target>
        </trans-unit>
        <trans-unit id="b9e930cb008c241b5c815eaa75c8616049a76f3c" translate="yes" xml:space="preserve">
          <source>Select fraction of the entry block frequency of executions of basic block in function given basic block needs to have to be considered hot.</source>
          <target state="translated">기본 블록이 주어진 기능에서 기본 블록 실행의 엔트리 블록 빈도의 일부를 선택해야합니다.</target>
        </trans-unit>
        <trans-unit id="5d7f15e7b6cef89c571f030f1f45d8b85b80d1bd" translate="yes" xml:space="preserve">
          <source>Select fraction of the maximal count of repetitions of basic block in program given basic block needs to have to be considered hot (used in non-LTO mode)</source>
          <target state="translated">기본 블록이 주어진 경우 프로그램에서 기본 블록의 최대 반복 횟수의 일부를 선택해야합니다 (비 LTO 모드에서 사용됨).</target>
        </trans-unit>
        <trans-unit id="36c07223da795b37e11fd68e818cf3c38a43554f" translate="yes" xml:space="preserve">
          <source>Select fraction of the maximal frequency of executions of a basic block in a function to align the basic block.</source>
          <target state="translated">기본 블록을 정렬하는 함수에서 기본 블록의 최대 실행 빈도의 일부를 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="9dc9d80b086954c572282f72064b77416ea46446" translate="yes" xml:space="preserve">
          <source>Select hardware or software floating-point implementations. The default is soft float.</source>
          <target state="translated">하드웨어 또는 소프트웨어 부동 소수점 구현을 선택하십시오. 기본값은 소프트 플로트입니다.</target>
        </trans-unit>
        <trans-unit id="c7bd7daa13fd958a4357701d8054beaa2dee311b" translate="yes" xml:space="preserve">
          <source>Select software or hardware divide (&lt;code&gt;l.div&lt;/code&gt;, &lt;code&gt;l.divu&lt;/code&gt;) instructions. This default is hardware divide.</source>
          <target state="translated">소프트웨어 또는 하드웨어 분할 ( &lt;code&gt;l.div&lt;/code&gt; , &lt;code&gt;l.divu&lt;/code&gt; ) 명령어를 선택합니다. 이 기본값은 하드웨어 분할입니다.</target>
        </trans-unit>
        <trans-unit id="eee7b4722a1d3c17eb5906a36d02871593b94d36" translate="yes" xml:space="preserve">
          <source>Select software or hardware for floating point operations. The default is software.</source>
          <target state="translated">부동 소수점 연산을위한 소프트웨어 또는 하드웨어를 선택합니다. 기본값은 소프트웨어입니다.</target>
        </trans-unit>
        <trans-unit id="3d76e8a947fb86d59dfbb84b64c271c44cbe3e1d" translate="yes" xml:space="preserve">
          <source>Select software or hardware multiply (&lt;code&gt;l.mul&lt;/code&gt;, &lt;code&gt;l.muli&lt;/code&gt;) instructions. This default is hardware multiply.</source>
          <target state="translated">소프트웨어 또는 하드웨어 곱하기 ( &lt;code&gt;l.mul&lt;/code&gt; , &lt;code&gt;l.muli&lt;/code&gt; ) 명령어를 선택합니다. 이 기본값은 하드웨어 곱하기입니다.</target>
        </trans-unit>
        <trans-unit id="4805085c7cdeea70b47df74e1f45155c6818e56a" translate="yes" xml:space="preserve">
          <source>Select the CPU for which code is generated. &lt;var&gt;name&lt;/var&gt; may be one of &amp;lsquo;</source>
          <target state="translated">코드가 생성되는 CPU를 선택하십시오. &lt;var&gt;name&lt;/var&gt; 은 '중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf37beb2b67c6c34b54f4a1faba9ff153bb95a67" translate="yes" xml:space="preserve">
          <source>Select the FDPIC ABI, which uses 64-bit function descriptors to represent pointers to functions. When the compiler is configured for &lt;code&gt;arm-*-uclinuxfdpiceabi&lt;/code&gt; targets, this option is on by default and implies</source>
          <target state="translated">64 비트 함수 설명자를 사용하여 함수에 대한 포인터를 나타내는 FDPIC ABI를 선택합니다. 컴파일러가 &lt;code&gt;arm-*-uclinuxfdpiceabi&lt;/code&gt; 대상에 대해 구성된 경우이 옵션은 기본적으로 켜져 있으며 다음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="5298db8756dae785af6835a7d749dc6e4b0e83e6" translate="yes" xml:space="preserve">
          <source>Select the FDPIC ABI, which uses function descriptors to represent pointers to functions. Without any PIC/PIE-related options, it implies</source>
          <target state="translated">함수 설명자를 사용하여 함수에 대한 포인터를 나타내는 FDPIC ABI를 선택하십시오. PIC / PIE 관련 옵션이 없으면</target>
        </trans-unit>
        <trans-unit id="b96987a051865812581f43da2e6b76b38be2e5d6" translate="yes" xml:space="preserve">
          <source>Select the MCU to target. This is used to create a C preprocessor symbol based upon the MCU name, converted to upper case and pre- and post-fixed with &amp;lsquo;</source>
          <target state="translated">타겟팅 할 MCU를 선택하십시오. 이는 MCU 이름을 기반으로 C 전 처리기 기호를 작성하고 대문자로 변환 한 후 '</target>
        </trans-unit>
        <trans-unit id="34d05e3013dad1f7bde8dbed8f375c5a52258615" translate="yes" xml:space="preserve">
          <source>Select the branch protection features to use. &amp;lsquo;</source>
          <target state="translated">사용할 분기 보호 기능을 선택하십시오. '</target>
        </trans-unit>
        <trans-unit id="2bf2cc4264a1022ff36bdedefe29b59b658dcdb3" translate="yes" xml:space="preserve">
          <source>Select the floating-point processor. This option can only be used with</source>
          <target state="translated">부동 소수점 프로세서를 선택하십시오. 이 옵션은 다음과 함께 만 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="980188b0321fba68ce5bd61028cfbc3eaef9c423" translate="yes" xml:space="preserve">
          <source>Select the function scope on which branch protection will be applied. The behavior and permissible arguments are the same as for the command-line option</source>
          <target state="translated">분기 보호를 적용 할 기능 범위를 선택하십시오. 동작 및 허용 가능한 인수는 명령 행 옵션과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="d7cbd726a83eac18e26570056a1fab4af001c14c" translate="yes" xml:space="preserve">
          <source>Select the function scope on which return address signing will be applied. Permissible values are &amp;lsquo;</source>
          <target state="translated">반송 주소 서명을 적용 할 기능 범위를 선택하십시오. 허용되는 값은 '</target>
        </trans-unit>
        <trans-unit id="429411e25d795ae5c5e83a75cda8f5a21a98ceca" translate="yes" xml:space="preserve">
          <source>Select the function scope on which return address signing will be applied. The behavior and permissible arguments are the same as for the command-line option</source>
          <target state="translated">반송 주소 서명을 적용 할 기능 범위를 선택하십시오. 동작 및 허용 가능한 인수는 명령 행 옵션과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="cad7dc1efa3eac596691110965725da6620b1019" translate="yes" xml:space="preserve">
          <source>Select the processor type for which to generate code. Possible values are &amp;lsquo;</source>
          <target state="translated">코드를 생성 할 프로세서 유형을 선택하십시오. 가능한 값은 '</target>
        </trans-unit>
        <trans-unit id="8f2f44369855722542be7f026c33d280a03e5883" translate="yes" xml:space="preserve">
          <source>Select the type of traceback table. Valid values for &lt;var&gt;traceback_type&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">역 추적 테이블 유형을 선택하십시오. &lt;var&gt;traceback_type&lt;/var&gt; 의 유효한 값 은 '</target>
        </trans-unit>
        <trans-unit id="7e33cf27814e6b940d30b3e1737b7c77cdf2dd07" translate="yes" xml:space="preserve">
          <source>Selects one of the built-in core configurations. Each MeP chip has one or more modules in it; each module has a core CPU and a variety of coprocessors, optional instructions, and peripherals. The &lt;code&gt;MeP-Integrator&lt;/code&gt; tool, not part of GCC, provides these configurations through this option; using this option is the same as using all the corresponding command-line options. The default configuration is &amp;lsquo;</source>
          <target state="translated">내장 코어 구성 중 하나를 선택합니다. 각 MeP 칩에는 하나 이상의 모듈이 있습니다. 각 모듈에는 코어 CPU와 다양한 보조 프로세서, 옵션 명령 및 주변 장치가 있습니다. &lt;code&gt;MeP-Integrator&lt;/code&gt; 도구, GCC의 일부는,이 옵션을 통해 이러한 구성을 제공합니다; 이 옵션을 사용하는 것은 해당하는 모든 명령 줄 옵션을 사용하는 것과 같습니다. 기본 구성은 '</target>
        </trans-unit>
        <trans-unit id="365acdbdf4035eefca1a110d44e0b136c3ce634c" translate="yes" xml:space="preserve">
          <source>Selects the IEEE rounding mode. Other Alpha compilers call this option</source>
          <target state="translated">IEEE 반올림 모드를 선택합니다. 다른 알파 컴파일러는이 옵션을 호출</target>
        </trans-unit>
        <trans-unit id="994fea32157f20c5fab4acc82606581a7793a57c" translate="yes" xml:space="preserve">
          <source>Selects the type of CPU to be targeted. Currently the only supported type is &amp;lsquo;</source>
          <target state="translated">대상이 될 CPU 유형을 선택합니다. 현재 유일하게 지원되는 유형은 '</target>
        </trans-unit>
        <trans-unit id="c91d8046baa6bef1bf16fff71b19c1547c4000e2" translate="yes" xml:space="preserve">
          <source>Selects the type of RX CPU to be targeted. Currently three types are supported, the generic &amp;lsquo;</source>
          <target state="translated">대상으로 할 RX CPU 유형을 선택합니다. 현재 세 가지 유형 인 일반 '</target>
        </trans-unit>
        <trans-unit id="aaf8d2e6bd32db4a0d11443d63ebb0f809925ed1" translate="yes" xml:space="preserve">
          <source>Selects which section constant data is placed in. &lt;var&gt;name&lt;/var&gt; may be &amp;lsquo;</source>
          <target state="translated">섹션 상수 데이터를 배치 할 섹션을 선택합니다. &lt;var&gt;name&lt;/var&gt; 은 '</target>
        </trans-unit>
        <trans-unit id="a326f0729df90ca61ebaebd51aa74199758de422" translate="yes" xml:space="preserve">
          <source>Sending a message in the GNU Objective-C runtime is composed of two separate steps. First, there is a call to the lookup function, &lt;code&gt;objc_msg_lookup ()&lt;/code&gt; (or, in the case of messages to super, &lt;code&gt;objc_msg_lookup_super ()&lt;/code&gt;). This runtime function takes as argument the receiver and the selector of the method to be called; it returns the &lt;code&gt;IMP&lt;/code&gt;, that is a pointer to the function implementing the method. The second step of method invocation consists of casting this pointer function to the appropriate function pointer type, and calling the function pointed to it with the right arguments.</source>
          <target state="translated">GNU Objective-C 런타임에서 메시지를 보내는 것은 두 가지 단계로 구성됩니다. 먼저, 조회 기능 &lt;code&gt;objc_msg_lookup ()&lt;/code&gt; 에 대한 호출이 있습니다 (또는 super에 대한 메시지의 경우 &lt;code&gt;objc_msg_lookup_super ()&lt;/code&gt; ). 이 런타임 함수는 수신자와 호출 할 메소드의 선택자를 인수로 사용합니다. 메소드를 구현하는 함수에 대한 포인터 인 &lt;code&gt;IMP&lt;/code&gt; 를 리턴합니다 . 메소드 호출의 두 번째 단계는이 포인터 함수를 적절한 함수 포인터 유형으로 캐스트하고 올바른 인수로 지정된 함수를 호출하는 것으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="b72ffc8386ea0ea78c13552225aab02558985774" translate="yes" xml:space="preserve">
          <source>Separate as much DWARF debugging information as possible into a separate output file with the extension</source>
          <target state="translated">가능한 많은 DWARF 디버깅 정보를 확장자가있는 별도의 출력 파일로 분리하십시오.</target>
        </trans-unit>
        <trans-unit id="a0c8baa5021f22a8ce8d11940201cb0f1ef70ad0" translate="yes" xml:space="preserve">
          <source>Sequential Consistency</source>
          <target state="translated">순차적 일관성</target>
        </trans-unit>
        <trans-unit id="db8c4e6b85438b041d4b954b044c9acc5ea86188" translate="yes" xml:space="preserve">
          <source>Set 80387 floating-point precision to 32, 64 or 80 bits. When</source>
          <target state="translated">80387 부동 소수점 정밀도를 32, 64 또는 80 비트로 설정하십시오. 언제</target>
        </trans-unit>
        <trans-unit id="6f094549c4101d290a41a69929786b1083499073" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;enable_sgpr_dispatch_id&lt;/code&gt; flag.</source>
          <target state="translated">&lt;code&gt;enable_sgpr_dispatch_id&lt;/code&gt; 플래그를 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="e063a374a4f9b63d6fbc54a457afb454bf3dc60b" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;enable_sgpr_dispatch_ptr&lt;/code&gt; flag. Always on (required to locate the launch dimensions).</source>
          <target state="translated">&lt;code&gt;enable_sgpr_dispatch_ptr&lt;/code&gt; 플래그를 설정하십시오 . 항상 켜짐 (실행 치수를 찾는 데 필요)</target>
        </trans-unit>
        <trans-unit id="4bf6767f6db51278dce4ba489ee759bfe27ca860" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;enable_sgpr_flat_scratch_init&lt;/code&gt; flag.</source>
          <target state="translated">&lt;code&gt;enable_sgpr_flat_scratch_init&lt;/code&gt; 플래그를 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="e018c4a2413ef8651cec5e018baeed25a64535ef" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;enable_sgpr_grid_workgroup_count_x&lt;/code&gt; flag. Always on (required to use OpenACC/OpenMP).</source>
          <target state="translated">&lt;code&gt;enable_sgpr_grid_workgroup_count_x&lt;/code&gt; 플래그를 설정하십시오 . 항상 켜져 있습니다 (OpenACC / OpenMP를 사용해야 함).</target>
        </trans-unit>
        <trans-unit id="8a3463fca2684949d657154ef95e5116320e933b" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;enable_sgpr_grid_workgroup_count_y&lt;/code&gt; flag.</source>
          <target state="translated">&lt;code&gt;enable_sgpr_grid_workgroup_count_y&lt;/code&gt; 플래그를 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="9121d61d52bfdfdb7d41c445246f7a36b8486d92" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;enable_sgpr_grid_workgroup_count_z&lt;/code&gt; flag.</source>
          <target state="translated">&lt;code&gt;enable_sgpr_grid_workgroup_count_z&lt;/code&gt; 플래그를 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="47dd861ea509bc2bed29c0b97e6909d4e6ec3ffa" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;enable_sgpr_kernarg_segment_ptr&lt;/code&gt; flag. Always on (required to locate the kernel arguments, &quot;kernargs&quot;).</source>
          <target state="translated">&lt;code&gt;enable_sgpr_kernarg_segment_ptr&lt;/code&gt; 플래그를 설정하십시오 . 항상 켜져 있습니다 (커널 인수 &quot;kernargs&quot;를 찾아야 함).</target>
        </trans-unit>
        <trans-unit id="cd7c041f21c0b317df592ef375a2d79306809a19" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;enable_sgpr_private_segment_buffer&lt;/code&gt; flag. Always on (required to locate the stack).</source>
          <target state="translated">&lt;code&gt;enable_sgpr_private_segment_buffer&lt;/code&gt; 플래그를 설정하십시오 . 항상 켜져 있습니다 (스택을 찾아야 함).</target>
        </trans-unit>
        <trans-unit id="6cb3983fd9748551d692e967fc5d0571ccaac036" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;enable_sgpr_private_segment_size&lt;/code&gt; flag.</source>
          <target state="translated">&lt;code&gt;enable_sgpr_private_segment_size&lt;/code&gt; 플래그를 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="e321e30fee9a76386f96bea4dafdd22df3c58297" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;enable_sgpr_private_segment_wave_byte_offset&lt;/code&gt; flag. Always on (required to locate the stack).</source>
          <target state="translated">&lt;code&gt;enable_sgpr_private_segment_wave_byte_offset&lt;/code&gt; 플래그를 설정하십시오 . 항상 켜져 있습니다 (스택을 찾아야 함).</target>
        </trans-unit>
        <trans-unit id="318a046da8f702fe1ef7095bb61e01886dd9a552" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;enable_sgpr_queue_ptr&lt;/code&gt; flag. Always on (required to convert address spaces).</source>
          <target state="translated">&lt;code&gt;enable_sgpr_queue_ptr&lt;/code&gt; 플래그를 설정하십시오 . 항상 켜져 있습니다 (주소 공간을 변환해야합니다).</target>
        </trans-unit>
        <trans-unit id="f2dea393dcbc34f57c9589ed5c20be98ac3c0bd2" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;enable_sgpr_workgroup_id_x&lt;/code&gt; flag.</source>
          <target state="translated">&lt;code&gt;enable_sgpr_workgroup_id_x&lt;/code&gt; 플래그를 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="922f6db77c2bc32594aaaea2ec14d4d827c574c4" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;enable_sgpr_workgroup_id_y&lt;/code&gt; flag.</source>
          <target state="translated">&lt;code&gt;enable_sgpr_workgroup_id_y&lt;/code&gt; 플래그를 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="14e0b73f99741e4ae34f7adcad5960d6204fcfd0" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;enable_sgpr_workgroup_id_z&lt;/code&gt; flag.</source>
          <target state="translated">&lt;code&gt;enable_sgpr_workgroup_id_z&lt;/code&gt; 플래그를 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="31293ecfe585105b73e60e083df6e0122cc62953" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;enable_sgpr_workgroup_info&lt;/code&gt; flag.</source>
          <target state="translated">&lt;code&gt;enable_sgpr_workgroup_info&lt;/code&gt; 플래그를 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="380057a6f93584a7133cb8fb90b07c8a8cc27fc3" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;enable_vgpr_workitem_id&lt;/code&gt; parameter. Always on (can&amp;rsquo;t be disabled).</source>
          <target state="translated">&lt;code&gt;enable_vgpr_workitem_id&lt;/code&gt; 매개 변수를 설정하십시오 . 항상 켜져 있습니다 (비활성화 할 수 없음).</target>
        </trans-unit>
        <trans-unit id="2399bb34bb60e0afafdf365068c0d7d3cf7ce8fd" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;enable_vgpr_workitem_id&lt;/code&gt; parameter. Always on (required to enable vectorization.)</source>
          <target state="translated">&lt;code&gt;enable_vgpr_workitem_id&lt;/code&gt; 매개 변수를 설정하십시오 . 항상 켜짐 (벡터화를 활성화하는 데 필요)</target>
        </trans-unit>
        <trans-unit id="82aa777ac54dda2b6c22bad4293654db9c8f37c4" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;enable_vgpr_workitem_id&lt;/code&gt; parameter. Always on (required to use OpenACC/OpenMP).</source>
          <target state="translated">&lt;code&gt;enable_vgpr_workitem_id&lt;/code&gt; 매개 변수를 설정하십시오 . 항상 켜져 있습니다 (OpenACC / OpenMP를 사용해야 함).</target>
        </trans-unit>
        <trans-unit id="1105231c54783be6055a3890df5dbc54a64a890f" translate="yes" xml:space="preserve">
          <source>Set IACC0H to &lt;var&gt;x&lt;/var&gt; if &lt;var&gt;reg&lt;/var&gt; is 0 and IACC0L to &lt;var&gt;x&lt;/var&gt; if &lt;var&gt;reg&lt;/var&gt; is 1. Other values of &lt;var&gt;reg&lt;/var&gt; are rejected as invalid.</source>
          <target state="translated">로 설정 IACC0H &lt;var&gt;x&lt;/var&gt; 경우 &lt;var&gt;reg&lt;/var&gt; 0이고 IACC0L &lt;var&gt;x&lt;/var&gt; 경우 &lt;var&gt;reg&lt;/var&gt; 1. 다른 값입니다 &lt;var&gt;reg&lt;/var&gt; 무효로 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="ee53a79e935585433b8493e61ec418d3cf4dbe69" translate="yes" xml:space="preserve">
          <source>Set all subsequent functions to have the &lt;code&gt;long_call&lt;/code&gt; attribute.</source>
          <target state="translated">모든 후속 함수가 &lt;code&gt;long_call&lt;/code&gt; 속성 을 갖도록 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="d60d9bf9dcc9adc753b1eb2a43c3660a75d81801" translate="yes" xml:space="preserve">
          <source>Set all subsequent functions to have the &lt;code&gt;short_call&lt;/code&gt; attribute.</source>
          <target state="translated">모든 후속 함수가 &lt;code&gt;short_call&lt;/code&gt; 속성 을 갖도록 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="97836a72f6504940ee575ca631515c1b5c65d1b7" translate="yes" xml:space="preserve">
          <source>Set architecture type or tuning for &lt;var&gt;gpu&lt;/var&gt;. Supported values for &lt;var&gt;gpu&lt;/var&gt; are</source>
          <target state="translated">&lt;var&gt;gpu&lt;/var&gt; 에 대한 아키텍처 유형 또는 조정을 설정하십시오 . &lt;var&gt;gpu&lt;/var&gt; 지원되는 값 은</target>
        </trans-unit>
        <trans-unit id="0c9ead2e0e9ad50453ecaadabc1a54be0e28b16c" translate="yes" xml:space="preserve">
          <source>Set architecture type, register usage, and instruction scheduling parameters for &lt;var&gt;cpu&lt;/var&gt;. There are also shortcut alias options available for backward compatibility and convenience. Supported values for &lt;var&gt;cpu&lt;/var&gt; are</source>
          <target state="translated">&lt;var&gt;cpu&lt;/var&gt; 의 아키텍처 유형, 레지스터 사용법 및 명령어 스케줄링 매개 변수를 설정하십시오 . 이전 버전과의 호환성 및 편의를 위해 사용 가능한 바로 가기 별칭 옵션도 있습니다. &lt;var&gt;cpu&lt;/var&gt; 지원되는 값 은</target>
        </trans-unit>
        <trans-unit id="64a7071b5e71b31be5eb05dbe2fa3aa85d88985c" translate="yes" xml:space="preserve">
          <source>Set architecture type, register usage, and instruction scheduling parameters for machine type &lt;var&gt;cpu_type&lt;/var&gt;. Supported values for &lt;var&gt;cpu_type&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">머신 유형 &lt;var&gt;cpu_type&lt;/var&gt; 의 아키텍처 유형, 레지스터 사용법 및 명령어 스케줄링 매개 변수를 설정하십시오 . &lt;var&gt;cpu_type&lt;/var&gt; 에 지원되는 값 은 '</target>
        </trans-unit>
        <trans-unit id="2d8d13e552ebd3846286db451c6c5b431512dad9" translate="yes" xml:space="preserve">
          <source>Set instruction scheduling parameters for &lt;var&gt;cpu&lt;/var&gt;, overriding any implied by</source>
          <target state="translated">&lt;var&gt;cpu&lt;/var&gt; 에 대한 명령 스케줄링 매개 변수를 설정 하여</target>
        </trans-unit>
        <trans-unit id="2715a46db2794f249b7a95e35f8fbd08b56ac85b" translate="yes" xml:space="preserve">
          <source>Set name of __fentry__ symbol called at function entry for -pg -mfentry functions.</source>
          <target state="translated">-pg -mfentry 함수의 함수 입력시 호출되는 __fentry__ 기호의 이름을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="516912ad28df352c9af39b170d45bd0f779026e3" translate="yes" xml:space="preserve">
          <source>Set name of section to record -mrecord-mcount calls (default __mcount_loc).</source>
          <target state="translated">-mrecord-mcount 호출을 기록하도록 섹션 이름을 설정하십시오 (기본값 __mcount_loc).</target>
        </trans-unit>
        <trans-unit id="5b5c27a6d88589e59ef75449f5dd3ac676e7651f" translate="yes" xml:space="preserve">
          <source>Set only the instruction scheduling parameters for machine type &lt;var&gt;cpu_type&lt;/var&gt;. The instruction set is not changed.</source>
          <target state="translated">머신 유형 &lt;var&gt;cpu_type&lt;/var&gt; 에 대한 명령어 스케줄링 매개 변수 만 설정하십시오 . 명령어 세트는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="96d85595444fd17f8fc2c443c3589b270f0ca169" translate="yes" xml:space="preserve">
          <source>Set probability threshold for unaligning branches. When tuning for &amp;lsquo;</source>
          <target state="translated">정렬되지 않은 분기에 대한 확률 임계 값을 설정하십시오. '를 조정할 때</target>
        </trans-unit>
        <trans-unit id="0ea21e9156c401cfb3bdea0993d6be3967bad591" translate="yes" xml:space="preserve">
          <source>Set the branch costs for conditional branch instructions to &lt;var&gt;cost&lt;/var&gt;. Reasonable values for &lt;var&gt;cost&lt;/var&gt; are small, non-negative integers. The default branch cost is 0.</source>
          <target state="translated">조건부 분기 명령어에 대한 분기 비용 설정 &lt;var&gt;cost&lt;/var&gt; . &lt;var&gt;cost&lt;/var&gt; 에 대한 합리적인 값은 음이 아닌 작은 정수입니다. 기본 지점 비용은 0입니다.</target>
        </trans-unit>
        <trans-unit id="0f86bf8c6795fb942b4cb5cea169bd8c5df0318b" translate="yes" xml:space="preserve">
          <source>Set the branch costs to roughly &lt;code&gt;n&lt;/code&gt; instructions. The default is 1.</source>
          <target state="translated">지점 비용을 대략 &lt;code&gt;n&lt;/code&gt; 개의 명령 으로 설정하십시오 . 기본값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="ff18182da94c7d99a8b4c2f28568b2d883024732" translate="yes" xml:space="preserve">
          <source>Set the code model to one of</source>
          <target state="translated">코드 모델을 다음 중 하나로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="78eeaac8789a3827df0a0d0ed12693670bedcea6" translate="yes" xml:space="preserve">
          <source>Set the cost of branches to roughly &lt;var&gt;n&lt;/var&gt; instructions.</source>
          <target state="translated">분기 비용을 대략 &lt;var&gt;n&lt;/var&gt; 개의 명령어 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="d6c018249bccc05c5ac1fc5bfd4c0431b5934b35" translate="yes" xml:space="preserve">
          <source>Set the cost of branches to roughly &lt;var&gt;num&lt;/var&gt; &amp;ldquo;simple&amp;rdquo; instructions. This cost is only a heuristic and is not guaranteed to produce consistent results across releases.</source>
          <target state="translated">약에 가지 비용을 설정 &lt;var&gt;num&lt;/var&gt; &quot;간단한&quot;지시. 이 비용은 휴리스틱 일 뿐이며 릴리스 전체에서 일관된 결과를 보장하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="52c26e276ceb37a9e0ef6641f16eb200d20fd608" translate="yes" xml:space="preserve">
          <source>Set the cost of branches to roughly &lt;var&gt;num&lt;/var&gt; &amp;ldquo;simple&amp;rdquo; instructions. This cost is only a heuristic and is not guaranteed to produce consistent results across releases. A zero cost redundantly selects the default, which is based on the</source>
          <target state="translated">약에 가지 비용을 설정 &lt;var&gt;num&lt;/var&gt; &quot;간단한&quot;지시. 이 비용은 휴리스틱 일 뿐이며 릴리스 전체에서 일관된 결과를 보장하지는 않습니다. 비용이 0이면 기본값을 중복 선택합니다.</target>
        </trans-unit>
        <trans-unit id="5a0841b373cdd65fccf05bdefa98b9359151f994" translate="yes" xml:space="preserve">
          <source>Set the cost to assume for a multiply insn.</source>
          <target state="translated">곱하기 기능에 대한 비용을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="9b5cc228ada7a61f910769476607cbb994fb6862" translate="yes" xml:space="preserve">
          <source>Set the default ELF image symbol visibility to the specified option&amp;mdash;all symbols are marked with this unless overridden within the code. Using this feature can very substantially improve linking and load times of shared object libraries, produce more optimized code, provide near-perfect API export and prevent symbol clashes. It is &lt;strong&gt;strongly&lt;/strong&gt; recommended that you use this in any shared objects you distribute.</source>
          <target state="translated">기본 ELF 이미지 심볼 가시성을 지정된 옵션으로 설정합니다. 코드 내에서 재정의되지 않는 한 모든 심볼에이 마크가 표시됩니다. 이 기능을 사용하면 공유 객체 라이브러리의 링크 및로드 시간이 크게 향상되고,보다 최적화 된 코드가 생성되며, 거의 완벽한 API 내보내기가 제공되고 심볼 충돌이 방지됩니다. 되어 &lt;strong&gt;강력하게&lt;/strong&gt; 당신이 배포하는 모든 공유 객체에서 이것을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="ea1605288d268d2678207ef0c71d1f4525e63f8a" translate="yes" xml:space="preserve">
          <source>Set the default instance variable visibility to the specified option so that instance variables declared outside the scope of any access modifier directives default to the specified visibility.</source>
          <target state="translated">액세스 수정 자 지시문의 범위 밖에서 선언 된 인스턴스 변수가 지정된 가시성으로 기본 설정되도록 기본 인스턴스 변수 가시성을 지정된 옵션으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="2a86ab7ec489c5eb483da27838bf7e2eb9274102" translate="yes" xml:space="preserve">
          <source>Set the default scalar storage order of structures and unions to the specified endianness. The accepted values are &amp;lsquo;</source>
          <target state="translated">구조 및 공용체의 기본 스칼라 스토리지 순서를 지정된 엔디안으로 설정하십시오. 허용되는 값은 '</target>
        </trans-unit>
        <trans-unit id="f3dbc51abbb4a58e848b6c7fade12f6fc892b4eb" translate="yes" xml:space="preserve">
          <source>Set the default size of pointers. Possible options for &lt;var&gt;size&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">포인터의 기본 크기를 설정하십시오. 가능한 &lt;var&gt;size&lt;/var&gt; 옵션 은 '</target>
        </trans-unit>
        <trans-unit id="62f2e2f7b01631d9a6515e5e155db801fef2b550" translate="yes" xml:space="preserve">
          <source>Set the directory to search for plugins that are passed by</source>
          <target state="translated">전달 된 플러그인을 검색하도록 디렉토리를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="344c767b23b4250954654e45ee61197856443517" translate="yes" xml:space="preserve">
          <source>Set the directory to search for the profile data files in to &lt;var&gt;path&lt;/var&gt;. This option affects only the profile data generated by</source>
          <target state="translated">프로파일 데이터 파일을 검색 할 디렉토리를 &lt;var&gt;path&lt;/var&gt; 로 설정하십시오 . 이 옵션은 다음에 의해 생성 된 프로파일 데이터에만 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="c88a9680382a42696b15d1fef7d2ae2621b8c420" translate="yes" xml:space="preserve">
          <source>Set the distance between tab stops. This helps the preprocessor report correct column numbers in warnings or errors, even if tabs appear on the line. If the value is less than 1 or greater than 100, the option is ignored. The default is 8.</source>
          <target state="translated">탭 정지 사이의 거리를 설정하십시오. 이렇게하면 행에 탭이 표시 되더라도 전처리 기가 경고 또는 오류에서 올바른 열 번호를보고하는 데 도움이됩니다. 값이 1보다 작거나 100보다 크면 옵션이 무시됩니다. 기본값은 8입니다.</target>
        </trans-unit>
        <trans-unit id="1d08f91e70e865b37a7c6408c62bba8aaf4795be" translate="yes" xml:space="preserve">
          <source>Set the division strategy to be used for integer division operations. &lt;var&gt;strategy&lt;/var&gt; can be one of:</source>
          <target state="translated">정수 나누기 연산에 사용할 나누기 전략을 설정하십시오. &lt;var&gt;strategy&lt;/var&gt; 은 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39cb7b5430317218ec8ac64bf16cfa98e3b257be" translate="yes" xml:space="preserve">
          <source>Set the execution character set, used for string and character constants. The default is UTF-8. &lt;var&gt;charset&lt;/var&gt; can be any encoding supported by the system&amp;rsquo;s &lt;code&gt;iconv&lt;/code&gt; library routine.</source>
          <target state="translated">문자열 및 문자 상수에 사용되는 실행 문자 세트를 설정하십시오. 기본값은 UTF-8입니다. &lt;var&gt;charset&lt;/var&gt; 은 시스템의 &lt;code&gt;iconv&lt;/code&gt; 라이브러리 루틴이 지원하는 모든 인코딩 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="51202b29bb6ce9f52c2e1294c6b529a40bcf359f" translate="yes" xml:space="preserve">
          <source>Set the full 64-bit value of IACC0 to &lt;var&gt;x&lt;/var&gt;. The &lt;var&gt;reg&lt;/var&gt; argument is reserved for future expansion and must be 0.</source>
          <target state="translated">IACC0의 전체 64 비트 값을 &lt;var&gt;x&lt;/var&gt; 로 설정하십시오 . &lt;var&gt;reg&lt;/var&gt; 인수는 미래의 확장을 위해 예약되어 있으며 0이어야합니다.</target>
        </trans-unit>
        <trans-unit id="b310b7c6a38563bb5ac12d36d2b4fae1244b8499" translate="yes" xml:space="preserve">
          <source>Set the input character set, used for translation from the character set of the input file to the source character set used by GCC. If the locale does not specify, or GCC cannot get this information from the locale, the default is UTF-8. This can be overridden by either the locale or this command-line option. Currently the command-line option takes precedence if there&amp;rsquo;s a conflict. &lt;var&gt;charset&lt;/var&gt; can be any encoding supported by the system&amp;rsquo;s &lt;code&gt;iconv&lt;/code&gt; library routine.</source>
          <target state="translated">입력 파일의 문자 세트에서 GCC가 사용하는 소스 문자 세트로 변환하는 데 사용되는 입력 문자 세트를 설정하십시오. 로케일을 지정하지 않거나 GCC가 로케일에서이 정보를 가져올 수없는 경우 기본값은 UTF-8입니다. 로케일 또는이 명령 행 옵션으로이를 대체 할 수 있습니다. 충돌이있는 경우 현재 명령 행 옵션이 우선합니다. &lt;var&gt;charset&lt;/var&gt; 은 시스템의 &lt;code&gt;iconv&lt;/code&gt; 라이브러리 루틴이 지원하는 모든 인코딩 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="652927b7d54857ab31904ba55c5609207b150484" translate="yes" xml:space="preserve">
          <source>Set the instruction scheduling parameters for machine type &lt;var&gt;cpu_type&lt;/var&gt;, but do not set the architecture type or register usage, as</source>
          <target state="translated">머신 유형 &lt;var&gt;cpu_type&lt;/var&gt; 에 대한 명령어 스케줄링 매개 변수를 설정하지만 아키텍처 유형을 설정하거나 사용법을 등록하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="11f00614fec90c6021e141511f6f276e35bf0cb8" translate="yes" xml:space="preserve">
          <source>Set the instruction scheduling parameters for machine type &lt;var&gt;cpu_type&lt;/var&gt;, but do not set the instruction set or register set that the option</source>
          <target state="translated">머신 유형 &lt;var&gt;cpu_type&lt;/var&gt; 에 대한 명령어 스케줄링 매개 변수를 설정하지만, 명령어 세트 또는 레지스터 세트를 옵션으로 설정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="50be1da58f5d233c63ebfa9b37341f9609727916" translate="yes" xml:space="preserve">
          <source>Set the instruction set and instruction scheduling parameters for machine type &lt;var&gt;cpu_type&lt;/var&gt;. You can specify either the &amp;lsquo;</source>
          <target state="translated">머신 유형 &lt;var&gt;cpu_type&lt;/var&gt; 에 대한 명령어 세트 및 명령어 스케줄링 매개 변수를 설정하십시오 . '</target>
        </trans-unit>
        <trans-unit id="3637c6b1faf044bd713cef9c135202d8f375fec1" translate="yes" xml:space="preserve">
          <source>Set the instruction set, register set, and instruction scheduling parameters for array element type &lt;var&gt;ae_type&lt;/var&gt;. Supported values for &lt;var&gt;ae_type&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">배열 요소 유형 &lt;var&gt;ae_type&lt;/var&gt; 에 대한 명령어 세트, 레지스터 세트 및 명령어 스케줄링 매개 변수를 설정 하십시오 . &lt;var&gt;ae_type&lt;/var&gt; 에 지원되는 값 은 '</target>
        </trans-unit>
        <trans-unit id="2130c0c09cc91a0c33f4d19aae8686d805e90ec1" translate="yes" xml:space="preserve">
          <source>Set the instruction set, register set, and instruction scheduling parameters for machine type &lt;var&gt;cpu_type&lt;/var&gt;. Supported values for &lt;var&gt;cpu_type&lt;/var&gt; are &amp;lsquo;</source>
          <target state="translated">머신 유형 &lt;var&gt;cpu_type&lt;/var&gt; 에 대한 명령어 세트, 레지스터 세트 및 명령어 스케줄링 매개 변수를 설정하십시오 . &lt;var&gt;cpu_type&lt;/var&gt; 에 지원되는 값 은 '</target>
        </trans-unit>
        <trans-unit id="500d192eb62847936b3fcadaa2c3190ec61e5693" translate="yes" xml:space="preserve">
          <source>Set the internal debug counter lower and upper bound. &lt;var&gt;counter-value-list&lt;/var&gt; is a comma-separated list of &lt;var&gt;name&lt;/var&gt;:&lt;var&gt;lower_bound1&lt;/var&gt;-&lt;var&gt;upper_bound1&lt;/var&gt; [:&lt;var&gt;lower_bound2&lt;/var&gt;-&lt;var&gt;upper_bound2&lt;/var&gt;...] tuples which sets the name of the counter and list of closed intervals. The &lt;var&gt;lower_bound&lt;/var&gt; is optional and is zero initialized if not set. For example, with</source>
          <target state="translated">내부 디버그 카운터 하한 및 상한을 설정합니다. &lt;var&gt;counter-value-list&lt;/var&gt; 는 쉼표로 구분 된 &lt;var&gt;name&lt;/var&gt; 목록입니다 . &lt;var&gt;lower_bound1&lt;/var&gt; - &lt;var&gt;upper_bound1&lt;/var&gt; [: &lt;var&gt;lower_bound2&lt;/var&gt; - &lt;var&gt;upper_bound2&lt;/var&gt; ...] 튜플은 카운터 이름과 닫힌 간격 목록을 설정합니다. &lt;var&gt;lower_bound&lt;/var&gt; 선택 사항이며 설정되어 있지 않은 경우는 제로가 초기화됩니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="4c79cc68a1f91929b96557468c86dfcad2cce72f" translate="yes" xml:space="preserve">
          <source>Set the internal debug counter lower and upper bound. &lt;var&gt;counter-value-list&lt;/var&gt; is a comma-separated list of &lt;var&gt;name&lt;/var&gt;:&lt;var&gt;lower_bound&lt;/var&gt;:&lt;var&gt;upper_bound&lt;/var&gt; tuples which sets the lower and the upper bound of each debug counter &lt;var&gt;name&lt;/var&gt;. The &lt;var&gt;lower_bound&lt;/var&gt; is optional and is zero initialized if not set. All debug counters have the initial upper bound of &lt;code&gt;UINT_MAX&lt;/code&gt;; thus &lt;code&gt;dbg_cnt&lt;/code&gt; returns true always unless the upper bound is set by this option. For example, with</source>
          <target state="translated">내부 디버그 카운터를 상한 및 하한으로 설정하십시오. &lt;var&gt;counter-value-list&lt;/var&gt; 는 각 디버그 카운터 &lt;var&gt;name&lt;/var&gt; 의 하한과 상한을 설정 하는 쉼표로 구분 된 &lt;var&gt;name&lt;/var&gt; : &lt;var&gt;lower_bound&lt;/var&gt; : &lt;var&gt;upper_bound&lt;/var&gt; 튜플 목록입니다 . &lt;var&gt;lower_bound&lt;/var&gt; 선택 사항이며 설정되어 있지 않은 경우는 제로가 초기화됩니다. 모든 디버그 카운터의 초기 상한은 &lt;code&gt;UINT_MAX&lt;/code&gt; 입니다 . 따라서이 옵션으로 상한을 설정하지 않으면 &lt;code&gt;dbg_cnt&lt;/code&gt; 는 항상 true를 반환합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="6a2e63898a05f461ab31f6f83dad590dc851ec3a" translate="yes" xml:space="preserve">
          <source>Set the list of functions that are excluded from instrumentation (see the description of</source>
          <target state="translated">계측에서 제외 된 기능 목록을 설정합니다 (설명 참조).</target>
        </trans-unit>
        <trans-unit id="42e134132bf53619895cfe9c4d4c0a63e9ff7d7c" translate="yes" xml:space="preserve">
          <source>Set the maximum amount for a single stack increment operation. Large values can increase the speed of programs that contain functions that need a large amount of stack space, but they can also trigger a segmentation fault if the stack is extended too much. The default value is 0x1000.</source>
          <target state="translated">단일 스택 증분 작업의 최대량을 설정하십시오. 값이 크면 많은 양의 스택 공간이 필요한 기능이 포함 된 프로그램의 속도가 빨라지지만 스택이 너무 확장되면 세그먼트 오류가 발생할 수도 있습니다. 기본값은 0x1000입니다.</target>
        </trans-unit>
        <trans-unit id="c1ec8e089c1ac627e7990475e62c40b0d43e58d3" translate="yes" xml:space="preserve">
          <source>Set the maximum depth of the nested #include. The default is 200.</source>
          <target state="translated">중첩 된 #include의 최대 깊이를 설정합니다. 기본값은 200입니다.</target>
        </trans-unit>
        <trans-unit id="d4f670c7bd6ab86529aad1732ecfea40af410c2b" translate="yes" xml:space="preserve">
          <source>Set the maximum instantiation depth for template classes to &lt;var&gt;n&lt;/var&gt;. A limit on the template instantiation depth is needed to detect endless recursions during template class instantiation. ANSI/ISO C++ conforming programs must not rely on a maximum depth greater than 17 (changed to 1024 in C++11). The default value is 900, as the compiler can run out of stack space before hitting 1024 in some situations.</source>
          <target state="translated">템플릿 클래스의 최대 인스턴스화 깊이를 &lt;var&gt;n&lt;/var&gt; 으로 설정하십시오 . 템플릿 클래스 인스턴스화 중에 끝없는 재귀를 감지하려면 템플릿 인스턴스화 깊이에 대한 제한이 필요합니다. ANSI / ISO C ++ 준수 프로그램은 17보다 큰 최대 깊이 (C ++ 11에서 1024로 변경)에 의존해서는 안됩니다. 컴파일러는 일부 상황에서 1024에 도달하기 전에 스택 공간이 부족할 수 있으므로 기본값은 900입니다.</target>
        </trans-unit>
        <trans-unit id="9f75c9fef6ead4d480bb957cf3712c8ad825156f" translate="yes" xml:space="preserve">
          <source>Set the maximum level of nested evaluation depth for C++11 constexpr functions that will be cached to &lt;var&gt;n&lt;/var&gt;. This is a heuristic that trades off compilation speed (when the cache avoids repeated calculations) against memory consumption (when the cache grows very large from highly recursive evaluations). The default is 8. Very few users are likely to want to adjust it, but if your code does heavy constexpr calculations you might want to experiment to find which value works best for you.</source>
          <target state="translated">캐시 될 C ++ 11 constexpr 함수에 대한 중첩 된 평가 깊이의 최대 수준을 &lt;var&gt;n&lt;/var&gt; 으로 설정 합니다. 이것은 컴파일 속도 (캐시가 반복적 인 계산을 피할 때)와 메모리 소비 (매우 반복적 인 평가로 인해 캐시가 매우 커질 때)를 절충하는 휴리스틱입니다. 기본값은 8입니다. 조정하려는 사용자는 거의 없지만 코드가 많은 constexpr 계산을 수행하는 경우 어떤 값이 가장 적합한 지 실험 해 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0c34cb3bf3e4cbb7843f5530d7dab6ff427a4a8" translate="yes" xml:space="preserve">
          <source>Set the maximum nested evaluation depth for C++11 constexpr functions to &lt;var&gt;n&lt;/var&gt;. A limit is needed to detect endless recursion during constant expression evaluation. The minimum specified by the standard is 512.</source>
          <target state="translated">C ++ 11 constexpr 함수의 최대 중첩 평가 깊이를 &lt;var&gt;n&lt;/var&gt; 으로 설정하십시오 . 상수 식 평가 동안 끝없는 재귀를 감지하려면 제한이 필요합니다. 표준에 의해 지정된 최소값은 512입니다.</target>
        </trans-unit>
        <trans-unit id="b1da5be9c3391cd736caa92a61985889a98f2b05" translate="yes" xml:space="preserve">
          <source>Set the maximum number of existing candidates that are considered when seeking a basis for a new straight-line strength reduction candidate.</source>
          <target state="translated">새로운 직선 강도 감소 후보의 기초를 찾을 때 고려되는 기존 후보의 최대 수를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="cfe13945b74f8afda07bf3e9441d08f927ed94f9" translate="yes" xml:space="preserve">
          <source>Set the maximum number of instructions executed in parallel in reassociated tree. This parameter overrides target dependent heuristics used by default if has non zero value.</source>
          <target state="translated">관련 트리에서 병렬로 실행되는 최대 명령 수를 설정하십시오. 이 매개 변수는 값이 0이 아닌 경우 기본적으로 사용되는 대상 종속 휴리스틱을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="ad1d48dcf4aec833ed476a8c06e702825b1456b2" translate="yes" xml:space="preserve">
          <source>Set the maximum number of iterations for a loop in C++14 constexpr functions to &lt;var&gt;n&lt;/var&gt;. A limit is needed to detect infinite loops during constant expression evaluation. The default is 262144 (1&amp;lt;&amp;lt;18).</source>
          <target state="translated">C ++ 14 constexpr 함수에서 루프의 최대 반복 횟수를 &lt;var&gt;n&lt;/var&gt; 으로 설정하십시오 . 상수 식 평가 중에 무한 루프를 감지하려면 제한이 필요합니다. 기본값은 262144입니다 (1 &amp;lt;&amp;lt; 18).</target>
        </trans-unit>
        <trans-unit id="b10b01f3627d31eea1b8ecfa0a7d6381d1c99dfd" translate="yes" xml:space="preserve">
          <source>Set the maximum number of operations during a single constexpr evaluation. Even when number of iterations of a single loop is limited with the above limit, if there are several nested loops and each of them has many iterations but still smaller than the above limit, or if in a body of some loop or even outside of a loop too many expressions need to be evaluated, the resulting constexpr evaluation might take too long. The default is 33554432 (1&amp;lt;&amp;lt;25).</source>
          <target state="translated">단일 constexpr 평가 중 최대 작업 수를 설정하십시오. 단일 루프의 반복 횟수가 위의 한계로 제한되는 경우에도 중첩 루프가 여러 개 있고 각 루프의 반복 횟수는 많지만 여전히 위의 한계보다 작거나 일부 루프 본문 또는 외부에있는 경우 루프가 너무 많은 표현식을 평가해야하므로 결과 constexpr 평가가 너무 오래 걸릴 수 있습니다. 기본값은 33554432 (1 &amp;lt;&amp;lt; 25)입니다.</target>
        </trans-unit>
        <trans-unit id="2d5dabb85d70dc403cca1e25a382c4592a347c35" translate="yes" xml:space="preserve">
          <source>Set the maximum number of template instantiation notes for a single warning or error to &lt;var&gt;n&lt;/var&gt;. The default value is 10.</source>
          <target state="translated">단일 경고 또는 오류에 대한 최대 템플릿 인스턴스화 메모 수를 &lt;var&gt;n&lt;/var&gt; 으로 설정하십시오 . 기본값은 10입니다.</target>
        </trans-unit>
        <trans-unit id="47ea880c254638d27a922dbb4046bb1a923dc25e" translate="yes" xml:space="preserve">
          <source>Set the memory model in force on the processor to one of</source>
          <target state="translated">프로세서에서 실행중인 메모리 모델을 다음 중 하나로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="d8ff5750579f8eb1fad99e9d99cd9274a1f87812" translate="yes" xml:space="preserve">
          <source>Set the merge weights of the &lt;var&gt;directory1&lt;/var&gt; and &lt;var&gt;directory2&lt;/var&gt;, respectively. The default weights are 1 for both.</source>
          <target state="translated">&lt;var&gt;directory1&lt;/var&gt; 과 &lt;var&gt;directory2&lt;/var&gt; 의 병합 가중치를 각각 설정하십시오. 기본 가중치는 모두 1입니다.</target>
        </trans-unit>
        <trans-unit id="e2cd2322187a5ecdca2024a2990e890bcbbf394b" translate="yes" xml:space="preserve">
          <source>Set the name of the library function used for 32-bit signed division to &lt;var&gt;name&lt;/var&gt;. This only affects the name used in the &amp;lsquo;</source>
          <target state="translated">32 비트 부호 분할에 사용되는 라이브러리 함수의 이름 설정 &lt;var&gt;name&lt;/var&gt; . 이는 '</target>
        </trans-unit>
        <trans-unit id="eaddd89d6c99265ee29e5fc045d536ee700140e2" translate="yes" xml:space="preserve">
          <source>Set the offset between the top of the stack and the stack pointer. E.g., a value of 8 means that the eight bytes in the range &lt;code&gt;sp+0&amp;hellip;sp+7&lt;/code&gt; can be used by leaf functions without stack allocation. Values other than &amp;lsquo;</source>
          <target state="translated">스택 상단과 스택 포인터 사이의 간격 띄우기를 설정하십시오. 예를 들어, 값 8은 스택 할당없이 리프 함수에서 &lt;code&gt;sp+0&amp;hellip;sp+7&lt;/code&gt; 범위의 8 바이트를 사용할 수 있음을 의미합니다. '이외의 값</target>
        </trans-unit>
        <trans-unit id="adf223dfbaa5deae634aec76651716f604f84bf4" translate="yes" xml:space="preserve">
          <source>Set the output profile directory. Default output directory name is &lt;var&gt;merged_profile&lt;/var&gt;.</source>
          <target state="translated">출력 프로파일 디렉토리를 설정하십시오. 기본 출력 디렉토리 이름은 &lt;var&gt;merged_profile&lt;/var&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6e4acbb536ee226dd76cd7df2c462f1fe127b3f4" translate="yes" xml:space="preserve">
          <source>Set the output profile directory. Default output name is &lt;var&gt;rewrite_profile&lt;/var&gt;.</source>
          <target state="translated">출력 프로파일 디렉토리를 설정하십시오. 기본 출력 이름은 &lt;var&gt;rewrite_profile&lt;/var&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7c0d7893ab57d9f01b9082ae29d8d0f77891bc37" translate="yes" xml:space="preserve">
          <source>Set the prevailing mode of the floating-point unit. This determines the floating-point mode that is provided and expected at function call and return time. Making this mode match the mode you predominantly need at function start can make your programs smaller and faster by avoiding unnecessary mode switches.</source>
          <target state="translated">부동 소수점 단위의 우선 모드를 설정하십시오. 함수 호출 및 리턴 시간에 제공되고 예상되는 부동 소수점 모드를 결정합니다. 이 모드를 기능 시작시 주로 필요한 모드와 일치 시키면 불필요한 모드 스위치를 피하여 프로그램을 더 작고 빠르게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="861bf514a61a077f62ab519a80b71ce1b519743f" translate="yes" xml:space="preserve">
          <source>Set the size (in bits) of the &lt;code&gt;double&lt;/code&gt; or &lt;code&gt;long double&lt;/code&gt; type, respectively. Possible values for &lt;var&gt;bits&lt;/var&gt; are 32 and 64. Whether or not a specific value for &lt;var&gt;bits&lt;/var&gt; is allowed depends on the &lt;code&gt;--with-double=&lt;/code&gt; and &lt;code&gt;--with-long-double=&lt;/code&gt;&lt;a href=&quot;https://gcc.gnu.org/install/configure.html#avr&quot;&gt;configure options&lt;/a&gt;, and the same applies for the default values of the options.</source>
          <target state="translated">&lt;code&gt;double&lt;/code&gt; 또는 &lt;code&gt;long double&lt;/code&gt; 유형 의 크기 (비트)를 각각 설정합니다. &lt;var&gt;bits&lt;/var&gt; 에 대해 가능한 값 은 32 및 64입니다. &lt;var&gt;bits&lt;/var&gt; 대한 특정 값의 허용 여부는 &lt;code&gt;--with-double=&lt;/code&gt; 및 &lt;code&gt;--with-long-double=&lt;/code&gt; &lt;a href=&quot;https://gcc.gnu.org/install/configure.html#avr&quot;&gt;구성 옵션&lt;/a&gt; 에 따라 달라지며 , 옵션.</target>
        </trans-unit>
        <trans-unit id="762a949ea014b3f016344afca377c6c1fd120d31" translate="yes" xml:space="preserve">
          <source>Set the threshold for hot counter value.</source>
          <target state="translated">핫 카운터 값의 임계 값을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="d1910b7ca1cbad135b71510c6caa598c927aef30" translate="yes" xml:space="preserve">
          <source>Set the verbose mode.</source>
          <target state="translated">상세 모드를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="44eafd221897534f159d32b54a0983fafc5fa037" translate="yes" xml:space="preserve">
          <source>Set the wide execution character set, used for wide string and character constants. The default is UTF-32 or UTF-16, whichever corresponds to the width of &lt;code&gt;wchar_t&lt;/code&gt;. As with</source>
          <target state="translated">넓은 문자열 및 문자 상수에 사용되는 넓은 실행 문자 세트를 설정하십시오. 디폴트는 UTF-32 또는 UTF-16이며, &lt;code&gt;wchar_t&lt;/code&gt; 의 너비에 해당합니다 . 와 같은</target>
        </trans-unit>
        <trans-unit id="bd789ae89e298186acebd68ef9887011219d47fa" translate="yes" xml:space="preserve">
          <source>Set to 1 if the prefetch hints should be issued for non-constant strides. Set to 0 if prefetch hints should be issued only for strides that are known to be constant and below</source>
          <target state="translated">일정하지 않은 보폭에 대해 프리 페치 힌트를 발행해야하는 경우 1로 설정하십시오. 상수와 그 이하로 알려진 보폭에 대해서만 프리 페치 힌트를 발행해야하는 경우 0으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="dd1bb2779bea0f760b1f72945047e7f54094a87c" translate="yes" xml:space="preserve">
          <source>Sets a maximum number of hash table slots to use during variable tracking dataflow analysis of any function. If this limit is exceeded with variable tracking at assignments enabled, analysis for that function is retried without it, after removing all debug insns from the function. If the limit is exceeded even without debug insns, var tracking analysis is completely disabled for the function. Setting the parameter to zero makes it unlimited.</source>
          <target state="translated">함수의 변수 추적 데이터 흐름 분석 중에 사용할 최대 해시 테이블 슬롯 수를 설정합니다. 할당에서 변수 추적을 사용하여이 한계를 초과하면 함수에서 모든 디버그 함수를 제거한 후 해당 함수에 대한 분석이 재 시도됩니다. 디버그 insns 없이도 한계를 초과하면 var 추적 분석이 기능에 대해 완전히 비활성화됩니다. 매개 변수를 0으로 설정하면 무제한이됩니다.</target>
        </trans-unit>
        <trans-unit id="f4f7877852a522804eb61c6aaaac182eccebc50d" translate="yes" xml:space="preserve">
          <source>Sets a maximum number of recursion levels when attempting to map variable names or debug temporaries to value expressions. This trades compilation time for more complete debug information. If this is set too low, value expressions that are available and could be represented in debug information may end up not being used; setting this higher may enable the compiler to find more complex debug expressions, but compile time and memory use may grow.</source>
          <target state="translated">변수 이름을 매핑하거나 임시 값을 값 표현식에 맵핑하려고 시도 할 때 최대 재귀 레벨 수를 설정합니다. 보다 완전한 디버그 정보를 위해 컴파일 시간을 교환합니다. 이것이 너무 낮게 설정되면 사용 가능하고 디버그 정보로 표시 될 수있는 값 표현식이 사용되지 않을 수 있습니다. 이 값을 높게 설정하면 컴파일러가 더 복잡한 디버그 식을 찾을 수 있지만 컴파일 시간과 메모리 사용이 늘어날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08565d52b6000f5a1a238ccd0e999b10428d5194" translate="yes" xml:space="preserve">
          <source>Sets a threshold on the number of debug markers (e.g. begin stmt markers) to avoid complexity explosion at inlining or expanding to RTL. If a function has more such gimple stmts than the set limit, such stmts will be dropped from the inlined copy of a function, and from its RTL expansion.</source>
          <target state="translated">RTL로 인라인하거나 확장 할 때 복잡한 폭발을 피하기 위해 디버그 마커 수 (예 : stmt 마커 시작)에 임계 값을 설정합니다. 함수에 설정된 한계보다 더 많은 gimple stmt가있는 경우 해당 stmt는 함수의 인라인 사본 및 RTL 확장에서 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="adcadd51c3ed80675dda04731a772d76952914d2" translate="yes" xml:space="preserve">
          <source>Sets the &amp;lsquo;</source>
          <target state="translated">'</target>
        </trans-unit>
        <trans-unit id="a6ae8e4718c6afa26e8b518098d3712cd253890c" translate="yes" xml:space="preserve">
          <source>Sets the latency the scheduler should assume for typical memory references as seen by the application. This number is highly dependent on the memory access patterns used by the application and the size of the external cache on the machine.</source>
          <target state="translated">응용 프로그램에서 볼 수있는 일반적인 메모리 참조에 대해 스케줄러가 가정해야하는 대기 시간을 설정합니다. 이 수는 응용 프로그램에서 사용하는 메모리 액세스 패턴과 컴퓨터의 외부 캐시 크기에 따라 크게 달라집니다.</target>
        </trans-unit>
        <trans-unit id="0fa1baca9f030dc5a8c265ad0c68afe11b1a04b0" translate="yes" xml:space="preserve">
          <source>Sets the model of atomic operations and additional parameters as a comma separated list. For details on the atomic built-in functions see &lt;a href=&quot;_005f_005fatomic-builtins#g_t_005f_005fatomic-Builtins&quot;&gt;__atomic Builtins&lt;/a&gt;. The following models and parameters are supported:</source>
          <target state="translated">원자 연산 모델과 추가 매개 변수를 쉼표로 구분 된 목록으로 설정합니다. 원자 내장 함수에 대한 자세한 내용은 &lt;a href=&quot;_005f_005fatomic-builtins#g_t_005f_005fatomic-Builtins&quot;&gt;__atomic Builtins를&lt;/a&gt; 참조하십시오 . 다음과 같은 모델 및 매개 변수가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="7b750af233a34aa4bcb53aaa3706d626453eaabe" translate="yes" xml:space="preserve">
          <source>Sets the options</source>
          <target state="translated">옵션을 설정합니다</target>
        </trans-unit>
        <trans-unit id="fb449f71834cd30ec14d00c9d50ba85c232186d3" translate="yes" xml:space="preserve">
          <source>Setting</source>
          <target state="translated">Setting</target>
        </trans-unit>
        <trans-unit id="d6ea280156ba317ca69c3a8a9a76acf1203369c2" translate="yes" xml:space="preserve">
          <source>Setting &lt;code&gt;GCC_COMPARE_DEBUG&lt;/code&gt; is nearly equivalent to passing</source>
          <target state="translated">&lt;code&gt;GCC_COMPARE_DEBUG&lt;/code&gt; 설정 은 전달하는 것과 거의 같습니다.</target>
        </trans-unit>
        <trans-unit id="4baf79749a36e87ddec4441787603ea1ca97f46a" translate="yes" xml:space="preserve">
          <source>Setting the rounding of floating-point operations to less than the default 80 bits can speed some programs by 2% or more. Note that some mathematical libraries assume that extended-precision (80-bit) floating-point operations are enabled by default; routines in such libraries could suffer significant loss of accuracy, typically through so-called &amp;ldquo;catastrophic cancellation&amp;rdquo;, when this option is used to set the precision to less than extended precision.</source>
          <target state="translated">부동 소수점 연산의 반올림을 기본 80 비트 미만으로 설정하면 일부 프로그램의 속도가 2 % 이상 증가 할 수 있습니다. 일부 수학적 라이브러리는 기본적으로 확장 정밀도 (80 비트) 부동 소수점 연산이 활성화되어 있다고 가정합니다. 이러한 라이브러리의 루틴은이 옵션을 사용하여 정밀도를 확장 정밀도보다 낮게 설정하는 경우 일반적으로 소위 &quot;치명적 취소&quot;를 통해 상당한 정확도 손실을 겪을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="159856f2826a4750f12fa9fc42e4ec6a3bb1171a" translate="yes" xml:space="preserve">
          <source>Several parameters control the tree inliner used in GCC. This number sets the maximum number of instructions (counted in GCC&amp;rsquo;s internal representation) in a single function that the tree inliner considers for inlining. This only affects functions declared inline and methods implemented in a class declaration (C++).</source>
          <target state="translated">GCC에서 사용되는 트리 인라이너를 제어하는 ​​몇 가지 파라미터가 있습니다. 이 숫자는 트리 인라이너가 인라인을 고려하는 단일 함수에서 최대 명령 수 (GCC 내부 표현으로 계산)를 설정합니다. 이것은 인라인으로 선언 된 함수와 클래스 선언 (C ++)으로 구현 된 메소드에만 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="c8709090fc808377d68cf694b1141ced48d2601f" translate="yes" xml:space="preserve">
          <source>Shift amount register</source>
          <target state="translated">시프트 량 레지스터</target>
        </trans-unit>
        <trans-unit id="7fc448ecaaa6700b369be5c5a12e31cfde0d7dab" translate="yes" xml:space="preserve">
          <source>Shift count operand.</source>
          <target state="translated">시프트 수 피연산자</target>
        </trans-unit>
        <trans-unit id="42345631131c9de97e00bb02984b6911be9a2bc4" translate="yes" xml:space="preserve">
          <source>Shift count operands are probably signed more often than unsigned. Warning about this would cause far more annoyance than good.</source>
          <target state="translated">시프트 카운트 피연산자는 부호없는 것보다 자주 부호가있을 수 있습니다. 이것에 대한 경고는 좋은 것보다 훨씬 더 성가신 일을 일으킬 것입니다.</target>
        </trans-unit>
        <trans-unit id="dfe491f4c15e6a3a57cef7ef5658d06a18ca9681" translate="yes" xml:space="preserve">
          <source>Short Table of Contents</source>
          <target state="translated">짧은 목차</target>
        </trans-unit>
        <trans-unit id="a3534d8b3591be1366a119ae1eea2780cd912060" translate="yes" xml:space="preserve">
          <source>Short instructions are used opportunistically.</source>
          <target state="translated">간단한 지침이 기회 적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4826dabecb65371171f46aae0549ce70f11c795f" translate="yes" xml:space="preserve">
          <source>Short structures and unions are those whose size and alignment match that of some integer type.</source>
          <target state="translated">짧은 구조와 결합은 크기와 정렬이 일부 정수 유형과 일치하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="daad79e8ea5157946382f52ca69c7ec66d0706c4" translate="yes" xml:space="preserve">
          <source>Shorten some address references at link time, when possible; uses the linker option</source>
          <target state="translated">가능하면 링크 타임에 일부 주소 참조를 줄이십시오. 링커 옵션을 사용합니다</target>
        </trans-unit>
        <trans-unit id="bf389fd92901d9498a4ee5b421310db154ba5af7" translate="yes" xml:space="preserve">
          <source>Shrink-wrap separate parts of the prologue and epilogue separately, so that those parts are only executed when needed. This option is on by default, but has no effect unless</source>
          <target state="translated">프롤로그와 에필로그의 개별 부분을 개별적으로 수축 랩핑하여 해당 부분이 필요할 때만 실행되도록합니다. 이 옵션은 기본적으로 켜져 있지만 그렇지 않으면 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3f90a5630eb62603c02b0eff8ce0d082b77006ba" translate="yes" xml:space="preserve">
          <source>Sign bit count. Return the number of consecutive bits in &lt;var&gt;value&lt;/var&gt; that have the same value as the sign bit. The result is the number of leading sign bits minus one, giving the number of redundant sign bits in &lt;var&gt;value&lt;/var&gt;.</source>
          <target state="translated">부호 비트 수 부호 비트와 동일한 값을 갖는 &lt;var&gt;value&lt;/var&gt; 의 연속 비트 수를 반환합니다 . 결과는 선행 부호 비트 수에서 1을 뺀 &lt;var&gt;value&lt;/var&gt; 으로 중복 부호 비트 수를 나타 냅니다.</target>
        </trans-unit>
        <trans-unit id="e061183cc39dbc6eb9f3804e7d82ef6aa01d7857" translate="yes" xml:space="preserve">
          <source>Signed 11-bit integer constant</source>
          <target state="translated">부호있는 11 비트 정수 상수</target>
        </trans-unit>
        <trans-unit id="17824e219e7e79f7144971183788b809379ad314" translate="yes" xml:space="preserve">
          <source>Signed 12-bit integer constant, for use in MOVI instructions</source>
          <target state="translated">MOVI 명령어에 사용되는 부호있는 12 비트 정수 상수</target>
        </trans-unit>
        <trans-unit id="2e366745a62f714ade88d7c0bd1a8931142b604e" translate="yes" xml:space="preserve">
          <source>Signed 13-bit constant</source>
          <target state="translated">부호있는 13 비트 상수</target>
        </trans-unit>
        <trans-unit id="4994a9f7bbfde0f98689a94230ffb2b0e3e5762e" translate="yes" xml:space="preserve">
          <source>Signed 13-bit constant, sign-extended to 32 or 64 bits</source>
          <target state="translated">부호있는 13 비트 상수, 부호가 32 또는 64 비트로 확장 됨</target>
        </trans-unit>
        <trans-unit id="7551ab4b6a7325d726d85dd8a288a32c7ad688ad" translate="yes" xml:space="preserve">
          <source>Signed 14-bit integer constant</source>
          <target state="translated">부호있는 14 비트 정수 상수</target>
        </trans-unit>
        <trans-unit id="db68d6aa5c4dcc27204f228e4dfa27c519354e21" translate="yes" xml:space="preserve">
          <source>Signed 16 bit integer (in the range -32768 to 32767)</source>
          <target state="translated">부호있는 16 비트 정수 (-32768-32767 범위)</target>
        </trans-unit>
        <trans-unit id="d6ec7293b64cddf6362ece0a6f483e55c61b7cd4" translate="yes" xml:space="preserve">
          <source>Signed 16-bit constant</source>
          <target state="translated">부호있는 16 비트 상수</target>
        </trans-unit>
        <trans-unit id="d5fed732c6b8716304eae31b104725b0d08b2445" translate="yes" xml:space="preserve">
          <source>Signed 16-bit constant (-32768&amp;ndash;32767)</source>
          <target state="translated">부호있는 16 비트 상수 (-32768&amp;ndash;32767)</target>
        </trans-unit>
        <trans-unit id="404101bb3dac0d3736cddd146de5ec8c922d9a53" translate="yes" xml:space="preserve">
          <source>Signed 16-bit constant shifted left 16 bits</source>
          <target state="translated">부호있는 16 비트 상수 왼쪽으로 16 비트 이동</target>
        </trans-unit>
        <trans-unit id="98375bb355d2181393a2db0e74a7f1e184e3c272" translate="yes" xml:space="preserve">
          <source>Signed 16-bit constant shifted left 16 bits. (Used with &lt;code&gt;l.movhi&lt;/code&gt;)</source>
          <target state="translated">부호있는 16 비트 상수가 왼쪽 16 비트로 시프트되었습니다. ( &lt;code&gt;l.movhi&lt;/code&gt; 와 함께 사용 )</target>
        </trans-unit>
        <trans-unit id="fdfaee517f78cd79192cde0e2bb40ec8bf507d88" translate="yes" xml:space="preserve">
          <source>Signed 16-bit integer constant.</source>
          <target state="translated">부호있는 16 비트 정수 상수.</target>
        </trans-unit>
        <trans-unit id="8577a9d2f5d95e6a261403245526b07f6b430127" translate="yes" xml:space="preserve">
          <source>Signed 3 bit integer (in the range -3 to 4)</source>
          <target state="translated">부호있는 3 비트 정수 (-3-4 범위)</target>
        </trans-unit>
        <trans-unit id="258aee98ee71baaef5cdc776f36eef32bd26c55b" translate="yes" xml:space="preserve">
          <source>Signed 4 bit integer (in the range -8 to 7)</source>
          <target state="translated">부호있는 4 비트 정수 (-8-7 범위)</target>
        </trans-unit>
        <trans-unit id="7a883110530359bda18df559e5a279936aa50db5" translate="yes" xml:space="preserve">
          <source>Signed 5-bit constant</source>
          <target state="translated">부호있는 5 비트 상수</target>
        </trans-unit>
        <trans-unit id="2e5e45d0ac38a40e675de10e051b4dbe8bc4276a" translate="yes" xml:space="preserve">
          <source>Signed 5-bit constant integer that can be loaded into an altivec register.</source>
          <target state="translated">altivec 레지스터에로드 할 수있는 부호있는 5 비트 상수 정수</target>
        </trans-unit>
        <trans-unit id="5f652f0cc47ab3c928aefe77d9c5b400f8c289d3" translate="yes" xml:space="preserve">
          <source>Signed 5-bit integer constant</source>
          <target state="translated">부호있는 5 비트 정수 상수</target>
        </trans-unit>
        <trans-unit id="c9e48c645aa0b87a95100fbbeff86623f971b222" translate="yes" xml:space="preserve">
          <source>Signed 7 bit integer (in the range -64 to 63)</source>
          <target state="translated">부호있는 7 비트 정수 (-64-63 범위)</target>
        </trans-unit>
        <trans-unit id="a86e1174fb545f9d4ebd6f20bf01348603efafe4" translate="yes" xml:space="preserve">
          <source>Signed 8-bit integer constant, for use in ADDI instructions</source>
          <target state="translated">ADDI 명령어에 사용하기위한 부호있는 8 비트 정수 상수</target>
        </trans-unit>
        <trans-unit id="4c94edb4279f10dbe5d95209fe71d0f96db252dc" translate="yes" xml:space="preserve">
          <source>Signed 8-bit integer constant.</source>
          <target state="translated">부호있는 8 비트 정수 상수.</target>
        </trans-unit>
        <trans-unit id="d272c273c51624f1dfdb18228a674026c85385e3" translate="yes" xml:space="preserve">
          <source>Signed constant that fits in 32 bits</source>
          <target state="translated">32 비트에 맞는 부호있는 상수</target>
        </trans-unit>
        <trans-unit id="f1265b4b3d2e744579f9692016435bbe3b254213" translate="yes" xml:space="preserve">
          <source>Signed constant that fits in 4 bits</source>
          <target state="translated">4 비트에 맞는 부호있는 상수</target>
        </trans-unit>
        <trans-unit id="5fe2facf8fa221348236eecc0c22b38ad313e882" translate="yes" xml:space="preserve">
          <source>Signed constant that fits in 5 bits</source>
          <target state="translated">5 비트에 맞는 부호있는 상수</target>
        </trans-unit>
        <trans-unit id="545b5582447a4f3516b54b2967e68fc278ea9ad8" translate="yes" xml:space="preserve">
          <source>Signed constant that fits in 6 bits</source>
          <target state="translated">6 비트에 맞는 부호있는 상수</target>
        </trans-unit>
        <trans-unit id="fd73c4e772cdc0f6e26ab1480292e828319d76b5" translate="yes" xml:space="preserve">
          <source>Signed immediate 10-bit value.</source>
          <target state="translated">즉시 10 비트 값을 서명했습니다.</target>
        </trans-unit>
        <trans-unit id="c5a8dbe6ead600b15b992c7b4bcf2efdb71ef681" translate="yes" xml:space="preserve">
          <source>Signed immediate 11-bit value.</source>
          <target state="translated">즉시 11 비트 값을 서명했습니다.</target>
        </trans-unit>
        <trans-unit id="a9356a59861e3c3eddcf1709eba030136286aebc" translate="yes" xml:space="preserve">
          <source>Signed immediate 15-bit value.</source>
          <target state="translated">즉시 15 비트 값을 서명했습니다.</target>
        </trans-unit>
        <trans-unit id="bd0cffbf0853e1a9f6e67fd93c760a34d836c070" translate="yes" xml:space="preserve">
          <source>Signed immediate 16-bit value.</source>
          <target state="translated">즉시 16 비트 값을 서명했습니다.</target>
        </trans-unit>
        <trans-unit id="a37369d99fd2a342362e9005528625a1180d725a" translate="yes" xml:space="preserve">
          <source>Signed immediate 17-bit value.</source>
          <target state="translated">즉시 17 비트 값을 서명했습니다.</target>
        </trans-unit>
        <trans-unit id="58ba7a0e897855d208deefd5f1aafdaebb7cbcad" translate="yes" xml:space="preserve">
          <source>Signed immediate 19-bit value.</source>
          <target state="translated">즉시 19 비트 값에 서명했습니다.</target>
        </trans-unit>
        <trans-unit id="d83875e20f0c4256559e6ad41957f6681f0f9fa4" translate="yes" xml:space="preserve">
          <source>Signed immediate 20-bit value.</source>
          <target state="translated">즉시 20 비트 값을 서명했습니다.</target>
        </trans-unit>
        <trans-unit id="772df3ebaa8079e1347500ef9b5a7974d1afc6fb" translate="yes" xml:space="preserve">
          <source>Signed immediate 5-bit value.</source>
          <target state="translated">즉시 5 비트 값을 서명했습니다.</target>
        </trans-unit>
        <trans-unit id="bed3d07e5abfe469789a6ad8fe518ca8c515cc56" translate="yes" xml:space="preserve">
          <source>Signed number whose magnitude is greater than 0x100</source>
          <target state="translated">크기가 0x100보다 큰 부호있는 숫자</target>
        </trans-unit>
        <trans-unit id="7dd7717c5fdb2f197d7bb925e85ce43ecfb76df1" translate="yes" xml:space="preserve">
          <source>Signed number whose magnitude is greater than 0x80</source>
          <target state="translated">크기가 0x80보다 큰 부호있는 숫자</target>
        </trans-unit>
        <trans-unit id="0939c3fe5c0d5d2bff40d1b5db20a06321bba976" translate="yes" xml:space="preserve">
          <source>Similar to</source>
          <target state="translated">비슷하다</target>
        </trans-unit>
        <trans-unit id="d539a06616b59e9c0b7a9e23630c3741a65d5d1c" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_alloca_with_align&lt;/code&gt; but takes an extra argument specifying an upper bound for &lt;var&gt;size&lt;/var&gt; in case its value cannot be computed at compile time, for use by</source>
          <target state="translated">&lt;code&gt;__builtin_alloca_with_align&lt;/code&gt; 과 유사 하지만 컴파일 타임에 값을 계산할 수없는 경우 &lt;var&gt;size&lt;/var&gt; 에 대한 상한을 지정하는 추가 인수 를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ea1f6fc78d2de9307f7b88ab0282a15257495c59" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_bswap16&lt;/code&gt;, except the argument and return types are 32 bit.</source>
          <target state="translated">인수 및 반환 유형이 32 비트라는 점을 제외하고 &lt;code&gt;__builtin_bswap16&lt;/code&gt; 과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="287de43f15b38812ca35a70d4d7f3e0bbc21298b" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_bswap32&lt;/code&gt;, except the argument and return types are 64 bit.</source>
          <target state="translated">인수 및 반환 유형이 64 비트라는 점을 제외하고 &lt;code&gt;__builtin_bswap32&lt;/code&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="103307679937d9d214ea5a77118584bb62226212" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_clrsb&lt;/code&gt;, except the argument type is &lt;code&gt;long long&lt;/code&gt;.</source>
          <target state="translated">인수 유형이 &lt;code&gt;long long&lt;/code&gt; 을 제외하고 &lt;code&gt;__builtin_clrsb&lt;/code&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="d9811f01cbffd069bcc5462448b89027d4f2ec50" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_clrsb&lt;/code&gt;, except the argument type is &lt;code&gt;long&lt;/code&gt;.</source>
          <target state="translated">인수 유형이 &lt;code&gt;long&lt;/code&gt; 인 경우를 제외하고 &lt;code&gt;__builtin_clrsb&lt;/code&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="df68abde10040a09c09e6b0b67f91ab09e952842" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_clz&lt;/code&gt;, except the argument type is &lt;code&gt;unsigned long long&lt;/code&gt;.</source>
          <target state="translated">인수 유형이 &lt;code&gt;unsigned long long&lt;/code&gt; 것을 제외하고 &lt;code&gt;__builtin_clz&lt;/code&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="f59576794aa7ba8bdf20faea4b1656733f7cd810" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_clz&lt;/code&gt;, except the argument type is &lt;code&gt;unsigned long&lt;/code&gt;.</source>
          <target state="translated">인수 유형이 &lt;code&gt;unsigned long&lt;/code&gt; 인 경우를 제외하고 &lt;code&gt;__builtin_clz&lt;/code&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="ba918034130e18befe466fce358d135c77bcf300" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_ctz&lt;/code&gt;, except the argument type is &lt;code&gt;unsigned long long&lt;/code&gt;.</source>
          <target state="translated">인수 유형이 &lt;code&gt;unsigned long long&lt;/code&gt; 것을 제외하고 &lt;code&gt;__builtin_ctz&lt;/code&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="18c0fbde15c08851968dc27a9a4c9c3e731fb512" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_ctz&lt;/code&gt;, except the argument type is &lt;code&gt;unsigned long&lt;/code&gt;.</source>
          <target state="translated">인수 유형이 &lt;code&gt;unsigned long&lt;/code&gt; 인 경우를 제외하고 &lt;code&gt;__builtin_ctz&lt;/code&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="c02104ee06367b8a197baa2a19b2abc09a1e31d1" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_ffs&lt;/code&gt;, except the argument type is &lt;code&gt;long long&lt;/code&gt;.</source>
          <target state="translated">인수 유형이 &lt;code&gt;long long&lt;/code&gt; 는 것을 제외하고 &lt;code&gt;__builtin_ffs&lt;/code&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="d1d6beb2a9ac335ca9f6e943f00f7fb214000908" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_ffs&lt;/code&gt;, except the argument type is &lt;code&gt;long&lt;/code&gt;.</source>
          <target state="translated">인수 유형이 &lt;code&gt;long&lt;/code&gt; 인 경우를 제외하고 &lt;code&gt;__builtin_ffs&lt;/code&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="41c22622d956d1ffb73b5455c532f810279add42" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_huge_val&lt;/code&gt;, except a warning is generated if the target floating-point format does not support infinities.</source>
          <target state="translated">대상 부동 소수점 형식이 무한대를 지원하지 않는 경우 경고가 생성되는 것을 제외하고 &lt;code&gt;__builtin_huge_val&lt;/code&gt; 과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="a3824e629002ce80fc504751d9f1603b9da7d561" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_huge_val&lt;/code&gt;, except the return type is &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">반환 유형이 &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; &lt;var&gt;n&lt;/var&gt; 인 것을 제외하고 &lt;code&gt;__builtin_huge_val&lt;/code&gt; 과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="008da3964b6f0002d0e9671a9ad995b6c420ce79" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_huge_val&lt;/code&gt;, except the return type is &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt;.</source>
          <target state="translated">반환 유형이 &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; &lt;var&gt;n&lt;/var&gt; x 인 것을 제외하고 &lt;code&gt;__builtin_huge_val&lt;/code&gt; 과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="e3a7adf1a6224d5bf5cb7c613e9a778b88a8c44b" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_huge_val&lt;/code&gt;, except the return type is &lt;code&gt;__float128&lt;/code&gt;.</source>
          <target state="translated">반환 유형이 &lt;code&gt;__float128&lt;/code&gt; 인 것을 제외하고 &lt;code&gt;__builtin_huge_val&lt;/code&gt; 과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="c1ffbe411a36969832b5f38087ea616365eec591" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_huge_val&lt;/code&gt;, except the return type is &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="translated">반환 유형이 &lt;code&gt;float&lt;/code&gt; 인 경우를 제외하고 &lt;code&gt;__builtin_huge_val&lt;/code&gt; 과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="186ce490303bc44a81961f86210149a388cbfd93" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_huge_val&lt;/code&gt;, except the return type is &lt;code&gt;long double&lt;/code&gt;.</source>
          <target state="translated">반환 유형이 &lt;code&gt;long double&lt;/code&gt; 인 경우를 제외하고 &lt;code&gt;__builtin_huge_val&lt;/code&gt; 과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="4256a1779131be828664fbc4607bd86235fc8f63" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_inf&lt;/code&gt;, except the return type is &lt;code&gt;_Decimal128&lt;/code&gt;.</source>
          <target state="translated">반환 유형이 &lt;code&gt;_Decimal128&lt;/code&gt; 인 것을 제외하고 &lt;code&gt;__builtin_inf&lt;/code&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="a3fc9b57c65d245ef2ebac66b67318e250147f5d" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_inf&lt;/code&gt;, except the return type is &lt;code&gt;_Decimal32&lt;/code&gt;.</source>
          <target state="translated">반환 유형이 &lt;code&gt;_Decimal32&lt;/code&gt; 인 것을 제외하고 &lt;code&gt;__builtin_inf&lt;/code&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="ec19c1b8f5bd592906a07150f56b4d809cec3b3a" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_inf&lt;/code&gt;, except the return type is &lt;code&gt;_Decimal64&lt;/code&gt;.</source>
          <target state="translated">반환 유형이 &lt;code&gt;_Decimal64&lt;/code&gt; 인 것을 제외하고 &lt;code&gt;__builtin_inf&lt;/code&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="57f4cede60e9110addaf6366460fd28f55f54667" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_inf&lt;/code&gt;, except the return type is &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">반환 유형이 &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; &lt;var&gt;n&lt;/var&gt; 인 것을 제외하고 &lt;code&gt;__builtin_inf&lt;/code&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="59d4025e2d73946d427adb0f6d32cc098e01d334" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_inf&lt;/code&gt;, except the return type is &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt;.</source>
          <target state="translated">반환 유형이 &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; &lt;var&gt;n&lt;/var&gt; x 인 것을 제외하고 &lt;code&gt;__builtin_inf&lt;/code&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="c1d67c7c6c9f71b26da8ec675376459c0921c713" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_inf&lt;/code&gt;, except the return type is &lt;code&gt;__float128&lt;/code&gt;.</source>
          <target state="translated">반환 유형이 &lt;code&gt;__float128&lt;/code&gt; 인 것을 제외하고 &lt;code&gt;__builtin_inf&lt;/code&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="896466811c11f3c4ee9e850f02d545950afb9b4d" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_inf&lt;/code&gt;, except the return type is &lt;code&gt;float&lt;/code&gt;. This function is suitable for implementing the ISO C99 macro &lt;code&gt;INFINITY&lt;/code&gt;.</source>
          <target state="translated">반환 유형이 &lt;code&gt;float&lt;/code&gt; 인 경우를 제외하고 &lt;code&gt;__builtin_inf&lt;/code&gt; 와 유사합니다 . 이 기능은 ISO C99 매크로 &lt;code&gt;INFINITY&lt;/code&gt; 를 구현하는 데 적합합니다 .</target>
        </trans-unit>
        <trans-unit id="76bb498c29da1b35254a143c1ace9763a1b7c3a7" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_inf&lt;/code&gt;, except the return type is &lt;code&gt;long double&lt;/code&gt;.</source>
          <target state="translated">반환 유형이 &lt;code&gt;long double&lt;/code&gt; 인 경우를 제외하고 &lt;code&gt;__builtin_inf&lt;/code&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="1d97d51092a352913796ed842ffe0791359432b2" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_nan&lt;/code&gt;, except the return type is &lt;code&gt;_Decimal128&lt;/code&gt;.</source>
          <target state="translated">반환 유형이 &lt;code&gt;_Decimal128&lt;/code&gt; 인 것을 제외하고 &lt;code&gt;__builtin_nan&lt;/code&gt; 과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="53d0a1658ae40e15391cc06844539577593fad36" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_nan&lt;/code&gt;, except the return type is &lt;code&gt;_Decimal32&lt;/code&gt;.</source>
          <target state="translated">반환 유형이 &lt;code&gt;_Decimal32&lt;/code&gt; 인 것을 제외하고 &lt;code&gt;__builtin_nan&lt;/code&gt; 과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="d0fb2196b87a982f142cbeace7c2dfa53a9a5586" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_nan&lt;/code&gt;, except the return type is &lt;code&gt;_Decimal64&lt;/code&gt;.</source>
          <target state="translated">반환 유형이 &lt;code&gt;_Decimal64&lt;/code&gt; 인 것을 제외하고 &lt;code&gt;__builtin_nan&lt;/code&gt; 과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="972fe72faee34d4a1bafa2164a917e9478d32f29" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_nan&lt;/code&gt;, except the return type is &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">반환 유형이 &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; &lt;var&gt;n&lt;/var&gt; 인 것을 제외하고 &lt;code&gt;__builtin_nan&lt;/code&gt; 과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="517865e97371f1de64149fe1cc44de8533e7d916" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_nan&lt;/code&gt;, except the return type is &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt;.</source>
          <target state="translated">반환 유형이 &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; &lt;var&gt;n&lt;/var&gt; x 인 것을 제외하고 &lt;code&gt;__builtin_nan&lt;/code&gt; 과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="80a4f0bb5594bf8db6aa07b69d98290c7b0cb4d2" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_nan&lt;/code&gt;, except the return type is &lt;code&gt;__float128&lt;/code&gt;.</source>
          <target state="translated">반환 유형이 &lt;code&gt;__float128&lt;/code&gt; 인 것을 제외하고 &lt;code&gt;__builtin_nan&lt;/code&gt; 과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="ee7af1fac130e9139e3597fcacf0ac51e23ffa68" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_nan&lt;/code&gt;, except the return type is &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="translated">반환 유형이 &lt;code&gt;float&lt;/code&gt; 인 경우를 제외하고 &lt;code&gt;__builtin_nan&lt;/code&gt; 과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="7f02308aa234b8f5dba187e0535ecce86dade187" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_nan&lt;/code&gt;, except the return type is &lt;code&gt;long double&lt;/code&gt;.</source>
          <target state="translated">반환 유형이 &lt;code&gt;long double&lt;/code&gt; 인 경우를 제외하고 &lt;code&gt;__builtin_nan&lt;/code&gt; 과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="7c9ad9b208b6e73ec53236ae7ef08d2a9f0beabb" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_nan&lt;/code&gt;, except the significand is forced to be a signaling NaN. The &lt;code&gt;nans&lt;/code&gt; function is proposed by &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n965.htm&quot;&gt;WG14 N965&lt;/a&gt;.</source>
          <target state="translated">significand가 신호 NaN이되도록 강제한다는 점을 제외하고 &lt;code&gt;__builtin_nan&lt;/code&gt; 과 유사합니다 . &lt;code&gt;nans&lt;/code&gt; 기능에 의해 제안 &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n965.htm&quot;&gt;WG14 N965&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="25d07b665f89fcc40387d17242580a6c52085352" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_nans&lt;/code&gt;, except the return type is &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">반환 유형이 &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; &lt;var&gt;n&lt;/var&gt; 인 것을 제외하고 &lt;code&gt;__builtin_nans&lt;/code&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="125a42543c42a9a4c876178d1cd519e3e1ac3337" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_nans&lt;/code&gt;, except the return type is &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt;.</source>
          <target state="translated">반환 유형이 &lt;code&gt;_Float&lt;var&gt;n&lt;/var&gt;x&lt;/code&gt; &lt;var&gt;n&lt;/var&gt; x 인 것을 제외하고 &lt;code&gt;__builtin_nans&lt;/code&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="c928fffe5233a8745a6b29699edadd2bd3d1840c" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_nans&lt;/code&gt;, except the return type is &lt;code&gt;__float128&lt;/code&gt;.</source>
          <target state="translated">반환 유형이 &lt;code&gt;__float128&lt;/code&gt; 인 것을 제외하고 &lt;code&gt;__builtin_nans&lt;/code&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="c71386ef3f149c7961c5dd435e803b5b814adc62" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_nans&lt;/code&gt;, except the return type is &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="translated">반환 유형이 &lt;code&gt;float&lt;/code&gt; 인 경우를 제외하고 &lt;code&gt;__builtin_nans&lt;/code&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="d3b4d3c3ce7578550309b9e1b7c63b2aeae76345" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_nans&lt;/code&gt;, except the return type is &lt;code&gt;long double&lt;/code&gt;.</source>
          <target state="translated">반환 유형이 &lt;code&gt;long double&lt;/code&gt; 인 경우를 제외하고 &lt;code&gt;__builtin_nans&lt;/code&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="88f8bef8cb3e9f1b7034b6cd67d536931b56ab97" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_parity&lt;/code&gt;, except the argument type is &lt;code&gt;unsigned long long&lt;/code&gt;.</source>
          <target state="translated">인수 유형이 &lt;code&gt;unsigned long long&lt;/code&gt; 것을 제외하고 &lt;code&gt;__builtin_parity&lt;/code&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="7b8444edd220546f2658052bf55756594cf3d7e6" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_parity&lt;/code&gt;, except the argument type is &lt;code&gt;unsigned long&lt;/code&gt;.</source>
          <target state="translated">인수 유형이 &lt;code&gt;unsigned long&lt;/code&gt; 제외하고 &lt;code&gt;__builtin_parity&lt;/code&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="e6da5b45f1e360ae211b94e56690a0b8fa88ee21" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_popcount&lt;/code&gt;, except the argument type is &lt;code&gt;unsigned long long&lt;/code&gt;.</source>
          <target state="translated">인수 유형이 &lt;code&gt;unsigned long long&lt;/code&gt; 것을 제외하고 &lt;code&gt;__builtin_popcount&lt;/code&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="ff3e55487db84f15ffa29a16f3d14063de2220f3" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_popcount&lt;/code&gt;, except the argument type is &lt;code&gt;unsigned long&lt;/code&gt;.</source>
          <target state="translated">인수 유형이 &lt;code&gt;unsigned long&lt;/code&gt; 인 경우를 제외하고 &lt;code&gt;__builtin_popcount&lt;/code&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="f6bdffa702ce1bb4acc9747edb48016c4599e76d" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_powi&lt;/code&gt;, except the argument and return types are &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="translated">인수 및 반환 유형이 &lt;code&gt;float&lt;/code&gt; 인 경우를 제외하고 &lt;code&gt;__builtin_powi&lt;/code&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="c49d8fe4e2b5fa5d1e76762b1beb13a3295e5948" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;__builtin_powi&lt;/code&gt;, except the argument and return types are &lt;code&gt;long double&lt;/code&gt;.</source>
          <target state="translated">인수 및 반환 유형이 &lt;code&gt;long double&lt;/code&gt; 인 경우를 제외하고 &lt;code&gt;__builtin_powi&lt;/code&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="2c1e3e4bbd07650298754513f3e3a44bed8e82b1" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;isinf&lt;/code&gt;, except the return value is -1 for an argument of &lt;code&gt;-Inf&lt;/code&gt; and 1 for an argument of &lt;code&gt;+Inf&lt;/code&gt;. Note while the parameter list is an ellipsis, this function only accepts exactly one floating-point argument. GCC treats this parameter as type-generic, which means it does not do default promotion from float to double.</source>
          <target state="translated">반환 값이 &lt;code&gt;-Inf&lt;/code&gt; 인수에 대해 -1 이고 &lt;code&gt;+Inf&lt;/code&gt; 인수에 대해 1 이라는 점을 제외하고 &lt;code&gt;isinf&lt;/code&gt; 와 유사합니다 . 매개 변수 목록은 줄임표이지만이 함수는 정확히 하나의 부동 소수점 인수 만 허용합니다. GCC는이 매개 변수를 유형 제네릭으로 취급합니다. 즉, float에서 double로 기본 승격을 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f30b0c19d239509bdc4a9dccfa54aa40be3c10c1" translate="yes" xml:space="preserve">
          <source>Similar to the stack- data- and const-align options above, these options arrange for stack frame, writable data and constants to all be 32-bit, 16-bit or 8-bit aligned. The default is 32-bit alignment.</source>
          <target state="translated">위의 스택 데이터 및 const 정렬 옵션과 유사하게,이 옵션은 스택 프레임, 쓰기 가능 데이터 및 상수가 모두 32 비트, 16 비트 또는 8 비트로 정렬되도록 정렬합니다. 기본값은 32 비트 정렬입니다.</target>
        </trans-unit>
        <trans-unit id="b4b6e8c3d6c60e969147af3a81dfe25b7338a216" translate="yes" xml:space="preserve">
          <source>Similarly to</source>
          <target state="translated">비슷하게</target>
        </trans-unit>
        <trans-unit id="8599edec7c2ed57ef8914ff45d22cb4fe06042cc" translate="yes" xml:space="preserve">
          <source>Similarly, access by taking the address, casting the resulting pointer and dereferencing the result has undefined behavior, even if the cast uses a union type, e.g.:</source>
          <target state="translated">마찬가지로, 캐스트가 공용체 유형을 사용하는 경우에도 주소를 가져와 결과 포인터를 캐스팅하고 결과를 역 참조함으로써 액세스가 정의되지 않은 동작을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="41ba9557152bce164799d0130f0eb9f9280e308f" translate="yes" xml:space="preserve">
          <source>Similarly, compiling code with G++ that must use a C++ library other than the GNU C++ library requires specifying the location of the header files for that other library.</source>
          <target state="translated">마찬가지로 GNU C ++ 라이브러리 이외의 C ++ 라이브러리를 사용해야하는 G ++로 코드를 컴파일하려면 해당 다른 라이브러리의 헤더 파일 위치를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="638ae03227c9ec9c0ea2e3c27a8de52a23a69e64" translate="yes" xml:space="preserve">
          <source>Similarly, it is not safe to access the global register variables from signal handlers or from more than one thread of control. Unless you recompile them specially for the task at hand, the system library routines may temporarily use the register for other things. Furthermore, since the register is not reserved exclusively for the variable, accessing it from handlers of asynchronous signals may observe unrelated temporary values residing in the register.</source>
          <target state="translated">마찬가지로, 신호 처리기 또는 둘 이상의 제어 스레드에서 전역 레지스터 변수에 액세스하는 것은 안전하지 않습니다. 현재 작업을 위해 특별히 다시 컴파일하지 않는 한 시스템 라이브러리 루틴은 일시적으로 다른 용도로 레지스터를 사용할 수 있습니다. 또한 레지스터는 변수 전용으로 예약되어 있지 않기 때문에 비동기 신호 핸들러에서 액세스하면 레지스터에 상주하는 관련없는 임시 값이 관찰 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b5c7c9387d15f3c833c95ff75e1127cc7558092" translate="yes" xml:space="preserve">
          <source>Simplify interprocedural analysis by computing the effect of certain calls, rather than exploring all paths through the function from callsite to each possible return.</source>
          <target state="translated">호출 사이트에서 가능한 각 반환까지 함수를 통해 모든 경로를 탐색하는 대신 특정 호출의 효과를 계산하여 절차 간 분석을 단순화합니다.</target>
        </trans-unit>
        <trans-unit id="22a4ed66c623d273a571652cc9ae1a89577a837f" translate="yes" xml:space="preserve">
          <source>Since</source>
          <target state="translated">Since</target>
        </trans-unit>
        <trans-unit id="33c848578be7e9d6967258af62c4197dfe644969" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;spu_add&lt;/code&gt; is a macro, the vector constant in the example is treated as four separate arguments. Wrap the entire argument in parentheses for this to work.</source>
          <target state="translated">&lt;code&gt;spu_add&lt;/code&gt; 는 매크로 이므로 예제 의 벡터 상수는 4 개의 개별 인수로 처리됩니다. 이것이 작동하려면 전체 인수를 괄호로 묶으십시오.</target>
        </trans-unit>
        <trans-unit id="59c049b9dd5a46fabeed926b81db03e50fbbf544" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;vec_add&lt;/code&gt; is a macro, the vector constant in the example is treated as four separate arguments. Wrap the entire argument in parentheses for this to work.</source>
          <target state="translated">이후 &lt;code&gt;vec_add&lt;/code&gt; 는 매크로이다 예에서 벡터 상수는 네 개의 개별 인자로 처리된다. 이것이 작동하려면 전체 인수를 괄호로 묶으십시오.</target>
        </trans-unit>
        <trans-unit id="21c7fe9d52d84289272bf156d75da1baf041f576" translate="yes" xml:space="preserve">
          <source>Since G++ now defaults to updating the ABI with each major release, normally</source>
          <target state="translated">G ++는 이제 기본적으로 각 주요 릴리스로 ABI를 업데이트하므로 일반적으로</target>
        </trans-unit>
        <trans-unit id="f22660df453a96c806164b9cde945b16ac8135b9" translate="yes" xml:space="preserve">
          <source>Since GCC does not parse the assembler template, it has no visibility of any symbols it references. This may result in GCC discarding those symbols as unreferenced unless they are also listed as input, output, or goto operands.</source>
          <target state="translated">GCC는 어셈블러 템플릿을 구문 분석하지 않으므로 참조하는 심볼을 볼 수 없습니다. 따라서 입력, 출력 또는 이동 피연산자로 나열되지 않으면 GCC에서 해당 심볼을 참조되지 않은 것으로 버릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b000a8b411ebdceb551939a35ee69b160bbe25b6" translate="yes" xml:space="preserve">
          <source>Since ISO C99 defines this function in terms of &lt;code&gt;strtod&lt;/code&gt;, which we do not implement, a description of the parsing is in order. The string is parsed as by &lt;code&gt;strtol&lt;/code&gt;; that is, the base is recognized by leading &amp;lsquo;</source>
          <target state="translated">ISO C99는이 기능 을 우리가 구현하지 않은 &lt;code&gt;strtod&lt;/code&gt; 로 정의하므로 구문 분석에 대한 설명이 순서대로 이루어집니다. 문자열은 &lt;code&gt;strtol&lt;/code&gt; 에 의해 구문 분석됩니다 . 즉, 기본은 '</target>
        </trans-unit>
        <trans-unit id="892917377ab8c3ffb653fb42e72d9ed1bdd00343" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;__builtin_alloca&lt;/code&gt; function doesn&amp;rsquo;t validate its argument it is the responsibility of its caller to make sure the argument doesn&amp;rsquo;t cause it to exceed the stack size limit. The &lt;code&gt;__builtin_alloca&lt;/code&gt; function is provided to make it possible to allocate on the stack arrays of bytes with an upper bound that may be computed at run time. Since C99 Variable Length Arrays offer similar functionality under a portable, more convenient, and safer interface they are recommended instead, in both C99 and C++ programs where GCC provides them as an extension. See &lt;a href=&quot;variable-length#Variable-Length&quot;&gt;Variable Length&lt;/a&gt;, for details.</source>
          <target state="translated">이후 &lt;code&gt;__builtin_alloca&lt;/code&gt; 의 기능은 인수를 확인하지 않습니다이 만드는 호출자의 책임입니다 확인 인수는 스택의 크기 제한을 초과 할 수 없습니다. &lt;code&gt;__builtin_alloca&lt;/code&gt; 의 기능이 가능 상부가 런타임에 계산 될 수 있다는 결합하여 바이트 스택 어레이에 할당 할 수 있도록 제공된다. C99 가변 길이 어레이는 이식 가능하고 더 편리하며 안전한 인터페이스 하에서 유사한 기능을 제공하므로 GCC가 확장으로 제공하는 C99 및 C ++ 프로그램 모두에서 대신 권장됩니다. 자세한 내용은 &lt;a href=&quot;variable-length#Variable-Length&quot;&gt;가변 길이&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4baf9c380b14381cf54e66f25724ec841c6dbbc1" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;__builtin_alloca_with_align&lt;/code&gt; function doesn&amp;rsquo;t validate its &lt;var&gt;size&lt;/var&gt; argument it is the responsibility of its caller to make sure the argument doesn&amp;rsquo;t cause it to exceed the stack size limit. The &lt;code&gt;__builtin_alloca_with_align&lt;/code&gt; function is provided to make it possible to allocate on the stack overaligned arrays of bytes with an upper bound that may be computed at run time. Since C99 Variable Length Arrays offer the same functionality under a portable, more convenient, and safer interface they are recommended instead, in both C99 and C++ programs where GCC provides them as an extension. See &lt;a href=&quot;variable-length#Variable-Length&quot;&gt;Variable Length&lt;/a&gt;, for details.</source>
          <target state="translated">이후 &lt;code&gt;__builtin_alloca_with_align&lt;/code&gt; 기능의 유효성을 검사하지 않는 &lt;var&gt;size&lt;/var&gt; 인수를가 만드는 호출자의 책임입니다 확인 인수는 스택의 크기 제한을 초과 할 수 없습니다. &lt;code&gt;__builtin_alloca_with_align&lt;/code&gt; 기능 가능 상부가 런타임에 계산 될 수 있다는 결합하여 바이트 overaligned 스택 어레이에 할당 할 수 있도록 제공된다. C99 가변 길이 어레이는 이식 가능하고 편리하며 안전한 인터페이스 하에서 동일한 기능을 제공하므로 GCC가 확장으로 제공하는 C99 및 C ++ 프로그램 모두에서 대신 권장됩니다. 자세한 내용은 &lt;a href=&quot;variable-length#Variable-Length&quot;&gt;가변 길이&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0258c9861f729a6d6a1e77969495b52ec885eef9" translate="yes" xml:space="preserve">
          <source>Since the two variable &lt;code&gt;i&lt;/code&gt; in the example above have incompatible types, enabling only</source>
          <target state="translated">위의 예제에서 두 변수 &lt;code&gt;i&lt;/code&gt; 는 호환되지 않는 유형을 가지고 있기 때문에</target>
        </trans-unit>
        <trans-unit id="d388c0730bf40209b77631102dd7aa30902cc328" translate="yes" xml:space="preserve">
          <source>Since there are occasions where a switch case fall through is desirable, GCC provides an attribute, &lt;code&gt;__attribute__ ((fallthrough))&lt;/code&gt;, that is to be used along with a null statement to suppress this warning that would normally occur:</source>
          <target state="translated">전환 사례가 필요한 경우가 있으므로 GCC는 &lt;code&gt;__attribute__ ((fallthrough))&lt;/code&gt; 속성을 제공합니다.이 속성 은 일반적으로 발생하는이 경고를 억제하기 위해 null 문과 함께 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9d33bdb0c97347197e4dad14823945cd2f7cbcbd" translate="yes" xml:space="preserve">
          <source>Single functions can be exempted from inlining by marking them with the &lt;code&gt;noinline&lt;/code&gt; attribute.</source>
          <target state="translated">&lt;code&gt;noinline&lt;/code&gt; 속성을 사용하여 단일 함수를 인라인에서 제외 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e677e33f125717883b72d6689c2a09bd6ab65171" translate="yes" xml:space="preserve">
          <source>Single-precision floating point:</source>
          <target state="translated">단 정밀도 부동 소수점 :</target>
        </trans-unit>
        <trans-unit id="76bd493ed8bb81652313a482dd8f8e1005d241c8" translate="yes" xml:space="preserve">
          <source>Size of max partition for WHOPR (in estimated instructions). to provide an upper bound for individual size of partition. Meant to be used only with balanced partitioning.</source>
          <target state="translated">WHOPR의 최대 파티션 크기 (예상 지침). 개별 파티션 크기에 대한 상한을 제공합니다. 균형 잡힌 파티셔닝과 함께 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="e240bffdb5210e2a9fb3c1ceaef0728216aabbc4" translate="yes" xml:space="preserve">
          <source>Size of minimal partition for WHOPR (in estimated instructions). This prevents expenses of splitting very small programs into too many partitions.</source>
          <target state="translated">WHOPR의 최소 파티션 크기 (예상 지침). 이것은 아주 작은 프로그램을 너무 많은 파티션으로 나누는 비용을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="feac389ca59136d24edc664765fb58951d1a7cbe" translate="yes" xml:space="preserve">
          <source>Slightly looser rules for escaped newlines.</source>
          <target state="translated">탈출 줄 바꿈에 대한 규칙이 약간 느슨합니다.</target>
        </trans-unit>
        <trans-unit id="6ae97113b3cf739a346d55e68c010f462fdbf99d" translate="yes" xml:space="preserve">
          <source>Small integer constants can use a shared data structure, reducing the compiler&amp;rsquo;s memory usage and increasing its speed. This sets the maximum value of a shared integer constant.</source>
          <target state="translated">작은 정수 상수는 공유 데이터 구조를 사용하여 컴파일러의 메모리 사용량을 줄이고 속도를 높일 수 있습니다. 공유 정수 상수의 최대 값을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="3c352006f28e617e3092550875bb98a37c3e499d" translate="yes" xml:space="preserve">
          <source>Small model objects live in the lower 16MB of memory (so that their addresses can be loaded with the &lt;code&gt;ld24&lt;/code&gt; instruction), and are callable with the &lt;code&gt;bl&lt;/code&gt; instruction.</source>
          <target state="translated">작은 모델 객체는 16MB 이하의 메모리에 &lt;code&gt;ld24&lt;/code&gt; 하며 ( ld24 명령어로 주소를로드 할 수 있음 ) &lt;code&gt;bl&lt;/code&gt; 명령어 로 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a3714fde637fe384ead8d5eb02c1a4c25f02d146" translate="yes" xml:space="preserve">
          <source>Small model objects live in the lower 16MB of memory (so that their addresses can be loaded with the &lt;code&gt;ld24&lt;/code&gt; instruction).</source>
          <target state="translated">작은 모델 객체는 16MB 이하의 메모리에 저장되므로 해당 주소를 &lt;code&gt;ld24&lt;/code&gt; 명령어 로로드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="87cc781515efd4b579bb2ce6bb66d4b4e6b7b78a" translate="yes" xml:space="preserve">
          <source>So the first alternative for the 68000&amp;rsquo;s logical-or could be written as &lt;code&gt;&quot;+m&quot; (output) : &quot;ir&quot; (input)&lt;/code&gt;. The second could be &lt;code&gt;&quot;+r&quot; 
(output): &quot;irm&quot; (input)&lt;/code&gt;. However, the fact that two memory locations cannot be used in a single instruction prevents simply using &lt;code&gt;&quot;+rm&quot; 
(output) : &quot;irm&quot; (input)&lt;/code&gt;. Using multi-alternatives, this might be written as &lt;code&gt;&quot;+m,r&quot; (output) : &quot;ir,irm&quot; (input)&lt;/code&gt;. This describes all the available alternatives to the compiler, allowing it to choose the most efficient one for the current conditions.</source>
          <target state="translated">따라서 68000 논리 또는 논리에 대한 첫 번째 대안은 &lt;code&gt;&quot;+m&quot; (output) : &quot;ir&quot; (input)&lt;/code&gt; 로 쓸 수 있습니다 . 두 번째는 &lt;code&gt;&quot;+r&quot; (output): &quot;irm&quot; (input)&lt;/code&gt; 있습니다. 그러나 단일 명령어에서 두 개의 메모리 위치를 사용할 수 없다는 사실은 단순히 &lt;code&gt;&quot;+rm&quot; (output) : &quot;irm&quot; (input)&lt;/code&gt; 사용하지 못하게 합니다. 다중 대체를 사용하면 &lt;code&gt;&quot;+m,r&quot; (output) : &quot;ir,irm&quot; (input)&lt;/code&gt; 으로 쓸 수 있습니다 . 여기에는 컴파일러에 대해 사용 가능한 모든 대안이 설명되어있어 현재 조건에 가장 효율적인 대안을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3274a855ec94ec43ea5e4111fdadde792b5b93db" translate="yes" xml:space="preserve">
          <source>So, for example,</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="059987d18facbbac8112608278433db26ec67739" translate="yes" xml:space="preserve">
          <source>Software developers also use coverage testing in concert with testsuites, to make sure software is actually good enough for a release. Testsuites can verify that a program works as expected; a coverage program tests to see how much of the program is exercised by the testsuite. Developers can then determine what kinds of test cases need to be added to the testsuites to create both better testing and a better final product.</source>
          <target state="translated">소프트웨어 개발자는 테스트 슈트와 함께 커버리지 테스트를 사용하여 소프트웨어가 실제로 릴리스에 충분한 지 확인합니다. 응시자는 프로그램이 예상대로 작동하는지 확인할 수 있습니다. 커버리지 프로그램은 테스트 스위트가 얼마나 많은 프로그램을 실행하는지 확인합니다. 그런 다음 개발자는 테스트 슈트에 어떤 종류의 테스트 사례를 추가하여 더 나은 테스트와 더 나은 최종 제품을 만들지 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fb15357d03c25c5a9704aae9669697852ee9b79" translate="yes" xml:space="preserve">
          <source>Solaris targets support the &lt;code&gt;cmn_err&lt;/code&gt; (or &lt;code&gt;__cmn_err__&lt;/code&gt;) format check. &lt;code&gt;cmn_err&lt;/code&gt; accepts a subset of the standard &lt;code&gt;printf&lt;/code&gt; conversions, and the two-argument &lt;code&gt;%b&lt;/code&gt; conversion for displaying bit-fields. See the Solaris man page for &lt;code&gt;cmn_err&lt;/code&gt; for more information.</source>
          <target state="translated">Solaris 대상은 &lt;code&gt;cmn_err&lt;/code&gt; (또는 &lt;code&gt;__cmn_err__&lt;/code&gt; ) 형식 확인을 지원합니다 . &lt;code&gt;cmn_err&lt;/code&gt; 는 표준 &lt;code&gt;printf&lt;/code&gt; 변환 의 서브 세트 와 비트 필드를 표시하기위한 두 개의 인수 &lt;code&gt;%b&lt;/code&gt; 변환을 허용합니다. 자세한 내용은 &lt;code&gt;cmn_err&lt;/code&gt; 에 대한 Solaris 매뉴얼 페이지 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="00b2aad45d07b70e1b7eefea74316913901b6e42" translate="yes" xml:space="preserve">
          <source>Some</source>
          <target state="translated">Some</target>
        </trans-unit>
        <trans-unit id="50992012bdba46e4be18c1991255dee68fa34161" translate="yes" xml:space="preserve">
          <source>Some 387 emulators do not support the &lt;code&gt;sin&lt;/code&gt;, &lt;code&gt;cos&lt;/code&gt; and &lt;code&gt;sqrt&lt;/code&gt; instructions for the 387. Specify this option to avoid generating those instructions. This option is overridden when</source>
          <target state="translated">일부 387 에뮬레이터는 387에 대한 &lt;code&gt;sin&lt;/code&gt; , &lt;code&gt;cos&lt;/code&gt; 및 &lt;code&gt;sqrt&lt;/code&gt; 명령어를 지원하지 않습니다 . 이러한 명령어가 생성되지 않도록하려면이 옵션을 지정하십시오. 이 옵션은 다음과 같은 경우 재정의됩니다.</target>
        </trans-unit>
        <trans-unit id="e8e19b82266af7db1443a3fea1acad2ebf9ad814" translate="yes" xml:space="preserve">
          <source>Some &lt;code&gt;asm&lt;/code&gt; statements may need extra stack space for internal calculations. This can be guaranteed by clobbering stack registers unrelated to the inputs and outputs.</source>
          <target state="translated">일부 &lt;code&gt;asm&lt;/code&gt; 문은 내부 계산을 위해 추가 스택 공간이 필요할 수 있습니다. 이는 입력 및 출력과 관련이없는 스택 레지스터를 클로버 링하여 보장 할 수 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
