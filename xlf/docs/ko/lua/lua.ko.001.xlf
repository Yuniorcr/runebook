<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="lua">
    <body>
      <group id="lua">
        <trans-unit id="962252ddf2da6f341f061e8a04594ebb79b0e228" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;L&lt;/code&gt;&quot;:  reads the next line keeping the end-of-line character (if present), returning &lt;b&gt;fail&lt;/b&gt; on end of file.</source>
          <target state="translated">&quot; &lt;code&gt;L&lt;/code&gt; &quot;: 줄 끝 문자 (있는 경우)를 유지하는 다음 줄을 읽고 파일 끝에서 &lt;b&gt;실패&lt;/b&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="85ee1dce4e7f426747bd89aef5bd47aa20d38aad" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;L&lt;/code&gt;&quot;:  reads the next line keeping the end-of-line character (if present), returning &lt;b&gt;nil&lt;/b&gt; on end of file.</source>
          <target state="translated">&quot; &lt;code&gt;L&lt;/code&gt; &quot;: 줄 끝 문자 (있는 경우)를 유지하고 다음 줄을 읽고 파일 끝에서 &lt;b&gt;nil&lt;/b&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="e0c82711681d3851f13f59346546cd0a034bb77a" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;a+&lt;/code&gt;&quot;:  append update mode, previous data is preserved, writing is only allowed at the end of file.</source>
          <target state="translated">&quot; &lt;code&gt;a+&lt;/code&gt; &quot;: 업데이트 모드 추가, 이전 데이터 유지, 쓰기는 파일 끝에서만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="68f6a1b79e4ab4f973b74b712a8ec0055442f0ec" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;a&lt;/code&gt;&quot;:  append mode;</source>
          <target state="translated">&quot; &lt;code&gt;a&lt;/code&gt; &quot;: 추가 모드;</target>
        </trans-unit>
        <trans-unit id="da2c3d0b3051b286b1d0b50590784dedf845e53c" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;a&lt;/code&gt;&quot;:  reads the whole file, starting at the current position. On end of file, it returns the empty string.</source>
          <target state="translated">&quot; &lt;code&gt;a&lt;/code&gt; &quot;: 현재 위치에서 시작하여 전체 파일을 읽습니다. 파일 끝에서 빈 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="afa896669590f5a6fa8647e9bdc254423566d75e" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;a&lt;/code&gt;&quot;:  reads the whole file, starting at the current position. On end of file, it returns the empty string; this format never fails.</source>
          <target state="translated">&quot; &lt;code&gt;a&lt;/code&gt; &quot;: 현재 위치에서 시작하여 전체 파일을 읽습니다. 파일 끝에서 빈 문자열을 반환합니다. 이 형식은 실패하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e057ca0bba66f85f9ffafede8baeccd9363b90a0" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;collect&lt;/code&gt;&quot;:  Performs a full garbage-collection cycle. This is the default option.</source>
          <target state="translated">&quot; &lt;code&gt;collect&lt;/code&gt; &quot;: 전체 가비지 수집주기를 수행합니다. 이것이 기본 옵션입니다.</target>
        </trans-unit>
        <trans-unit id="7fa0969179f03d1f39ed55770cfc19ab243badc2" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;collect&lt;/code&gt;&quot;:  performs a full garbage-collection cycle. This is the default option.</source>
          <target state="translated">&quot; &lt;code&gt;collect&lt;/code&gt; &quot;: 전체 가비지 수집주기를 수행합니다. 이것이 기본 옵션입니다.</target>
        </trans-unit>
        <trans-unit id="be11cc3d76417207ed08705e3fec7858f2adec01" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;count&lt;/code&gt;&quot;:  Returns the total memory in use by Lua in Kbytes. The value has a fractional part, so that it multiplied by 1024 gives the exact number of bytes in use by Lua.</source>
          <target state="translated">&quot; &lt;code&gt;count&lt;/code&gt; &quot;: Lua에서 사용중인 총 메모리 (KB)를 반환합니다. 값에는 소수 부분이 있으므로 1024를 곱하면 Lua에서 사용중인 정확한 바이트 수가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="4d2df6eb922319bf606a86a89e2fc83230795af9" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;count&lt;/code&gt;&quot;:  returns the total memory in use by Lua in Kbytes. The value has a fractional part, so that it multiplied by 1024 gives the exact number of bytes in use by Lua (except for overflows).</source>
          <target state="translated">&quot; &lt;code&gt;count&lt;/code&gt; &quot;: Lua에서 사용중인 총 메모리를 KB 단위로 반환합니다. 이 값에는 소수 부분이 있으므로 1024를 곱하면 Lua에서 사용중인 정확한 바이트 수가 제공됩니다 (오버플로 제외).</target>
        </trans-unit>
        <trans-unit id="ef21751d9473020b9e5da0603526fbc16553da86" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;cur&lt;/code&gt;&quot;:  base is current position;</source>
          <target state="translated">&quot; &lt;code&gt;cur&lt;/code&gt; &quot;: 기본은 현재 위치입니다.</target>
        </trans-unit>
        <trans-unit id="45f4427c05fe67a6aadc962320833307f03356f2" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;end&lt;/code&gt;&quot;:  base is end of file;</source>
          <target state="translated">&quot; &lt;code&gt;end&lt;/code&gt; &quot;: base는 파일의 끝입니다.</target>
        </trans-unit>
        <trans-unit id="b6883b7ef8179370d3a9ce57af44e1806db3b5d3" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;exit&lt;/code&gt;&quot;:  the command terminated normally; the following number is the exit status of the command.</source>
          <target state="translated">&quot; &lt;code&gt;exit&lt;/code&gt; &quot;: 명령이 정상적으로 종료되었습니다. 다음 번호는 명령의 종료 상태입니다.</target>
        </trans-unit>
        <trans-unit id="2f1aeda330bb1f1509a0be53bac132c6ce713fe2" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;full&lt;/code&gt;&quot;:  full buffering.</source>
          <target state="translated">&quot; &lt;code&gt;full&lt;/code&gt; &quot;: 전체 버퍼링.</target>
        </trans-unit>
        <trans-unit id="f86582b43c224b125fce8af4c1bd39d83c959584" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;full&lt;/code&gt;&quot;:  full buffering; output operation is performed only when the buffer is full or when you explicitly &lt;code&gt;flush&lt;/code&gt; the file (see &lt;a href=&quot;#pdf-io.flush&quot;&gt;&lt;code&gt;io.flush&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">&quot; &lt;code&gt;full&lt;/code&gt; &quot;: 전체 버퍼링; 출력 작업은 버퍼가 가득 찼거나 파일 을 명시 적으로 &lt;code&gt;flush&lt;/code&gt; 할 때만 수행됩니다 ( &lt;a href=&quot;#pdf-io.flush&quot;&gt; &lt;code&gt;io.flush&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="9dcb26eb8ae721950ef23e61c194fec0b65ee51e" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;generational&lt;/code&gt;&quot;:  Change the collector mode to generational. This option can be followed by two numbers: the garbage-collector minor multiplier and the major multiplier (see &lt;a href=&quot;#2.5.2&quot;&gt;&amp;sect;2.5.2&lt;/a&gt;). A zero means to not change that value.</source>
          <target state="translated">&quot; &lt;code&gt;generational&lt;/code&gt; &quot;: 수집기 모드를 세대별로 변경합니다. 이 옵션 뒤에는 가비지 컬렉터 부 승수와 주 승수 ( &lt;a href=&quot;#2.5.2&quot;&gt;&amp;sect;2.5.2&lt;/a&gt; 참조 )의 두 숫자가 올 수 있습니다 . 0은 해당 값을 변경하지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="5c0312cfc47027ea4cfae9f3ba8f855264d8be0b" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;incremental&lt;/code&gt;&quot;:  Change the collector mode to incremental. This option can be followed by three numbers: the garbage-collector pause, the step multiplier, and the step size (see &lt;a href=&quot;#2.5.1&quot;&gt;&amp;sect;2.5.1&lt;/a&gt;). A zero means to not change that value.</source>
          <target state="translated">&quot; &lt;code&gt;incremental&lt;/code&gt; &quot;: 콜렉터 모드를 증가로 변경하십시오. 이 옵션 뒤에는 가비지 수집기 일시 중지, 단계 승수 및 단계 크기 ( &lt;a href=&quot;#2.5.1&quot;&gt;&amp;sect;2.5.1&lt;/a&gt; 참조 )의 세 가지 숫자가 올 수 있습니다 . 0은 해당 값을 변경하지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d49828278a7296be12d3b4c9fa911cd509b08185" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;isrunning&lt;/code&gt;&quot;:  Returns a boolean that tells whether the collector is running (i.e., not stopped).</source>
          <target state="translated">&quot; &lt;code&gt;isrunning&lt;/code&gt; &quot;: 수집기가 실행 중인지 (즉, 중지되지 않았는지) 알려주는 부울을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8b36390a21d74199c7097e386abdc8966f9f3141" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;isrunning&lt;/code&gt;&quot;:  returns a boolean that tells whether the collector is running (i.e., not stopped).</source>
          <target state="translated">&quot; &lt;code&gt;isrunning&lt;/code&gt; &quot;: 콜렉터가 실행 중인지 (즉, 중지되지 않았는지) 알려주는 부울을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="fba0cc8d18a812c71b4d8efd3450dc54e903de11" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;l&lt;/code&gt;&quot;:  reads the next line skipping the end of line, returning &lt;b&gt;fail&lt;/b&gt; on end of file. This is the default format.</source>
          <target state="translated">&quot; &lt;code&gt;l&lt;/code&gt; &quot;: 줄 끝을 건너 뛰고 파일 끝에서 &lt;b&gt;실패&lt;/b&gt; 를 반환하는 다음 줄을 읽습니다 . 이것이 기본 형식입니다.</target>
        </trans-unit>
        <trans-unit id="35126f6ad470130461b610dc64352ebf2d5ba8ac" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;l&lt;/code&gt;&quot;:  reads the next line skipping the end of line, returning &lt;b&gt;nil&lt;/b&gt; on end of file. This is the default format.</source>
          <target state="translated">&quot; &lt;code&gt;l&lt;/code&gt; &quot;: 줄 끝을 건너 뛰고 다음 줄을 읽고 파일 끝에서 &lt;b&gt;nil&lt;/b&gt; 을 반환 합니다. 이것이 기본 형식입니다.</target>
        </trans-unit>
        <trans-unit id="adbd07304874d87caf7dacbe33921a0377b7f1f2" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;line&lt;/code&gt;&quot;:  line buffering.</source>
          <target state="translated">&quot; &lt;code&gt;line&lt;/code&gt; &quot;: 라인 버퍼링.</target>
        </trans-unit>
        <trans-unit id="0bf7bc41709a6ccf5aa6eae67b8f346e5001d8b6" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;line&lt;/code&gt;&quot;:  line buffering; output is buffered until a newline is output or there is any input from some special files (such as a terminal device).</source>
          <target state="translated">&quot; &lt;code&gt;line&lt;/code&gt; &quot;: 라인 버퍼링; 줄 바꿈이 출력되거나 일부 특수 파일 (예 : 터미널 장치)에서 입력이있을 때까지 출력이 버퍼됩니다.</target>
        </trans-unit>
        <trans-unit id="e4a59afc3c3aee61c303a6c6f2b2a762d2ad3d81" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;n&lt;/code&gt;&quot;:  reads a numeral and returns it as a float or an integer, following the lexical conventions of Lua. (The numeral may have leading spaces and a sign.) This format always reads the longest input sequence that is a valid prefix for a numeral; if that prefix does not form a valid numeral (e.g., an empty string, &quot;&lt;code&gt;0x&lt;/code&gt;&quot;, or &quot;&lt;code&gt;3.4e-&lt;/code&gt;&quot;), it is discarded and the function returns &lt;b&gt;nil&lt;/b&gt;.</source>
          <target state="translated">&quot; &lt;code&gt;n&lt;/code&gt; &quot;: Lua의 어휘 규칙에 따라 숫자를 읽고이를 부동 소수점 또는 정수로 리턴합니다. (숫자 앞에 공백과 부호가있을 수 있습니다.)이 형식은 항상 숫자의 유효한 접두사 인 가장 긴 입력 시퀀스를 읽습니다. 해당 접두사가 유효한 숫자 (예 : 빈 문자열, &quot; &lt;code&gt;0x&lt;/code&gt; &quot;또는 &quot; &lt;code&gt;3.4e-&lt;/code&gt; &quot;)를 형성하지 않으면 버리고 해당 함수는 &lt;b&gt;nil을&lt;/b&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="480c73a0e8b85d3021bbb23368c9f75c21639058" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;n&lt;/code&gt;&quot;:  reads a numeral and returns it as a float or an integer, following the lexical conventions of Lua. (The numeral may have leading whitespaces and a sign.) This format always reads the longest input sequence that is a valid prefix for a numeral; if that prefix does not form a valid numeral (e.g., an empty string, &quot;&lt;code&gt;0x&lt;/code&gt;&quot;, or &quot;&lt;code&gt;3.4e-&lt;/code&gt;&quot;) or it is too long (more than 200 characters), it is discarded and the format returns &lt;b&gt;fail&lt;/b&gt;.</source>
          <target state="translated">&quot; &lt;code&gt;n&lt;/code&gt; &quot;: Lua의 어휘 규칙에 따라 숫자를 읽고 부동 소수점 또는 정수로 반환합니다. (숫자는 선행 공백과 부호를 가질 수 있습니다.)이 형식은 항상 숫자에 대한 유효한 접두사 인 가장 긴 입력 시퀀스를 읽습니다. 해당 접두사가 유효한 숫자 (예 : 빈 문자열, &quot; &lt;code&gt;0x&lt;/code&gt; &quot;또는 &quot; &lt;code&gt;3.4e-&lt;/code&gt; &quot;)를 형성하지 않거나 너무 길면 (200 자 이상) 폐기되고 형식은 &lt;b&gt;fail을&lt;/b&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="d64536f065dc9a0f02fa4493ade76a3fe03ebe56" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;no&lt;/code&gt;&quot;:  no buffering.</source>
          <target state="translated">&quot; &lt;code&gt;no&lt;/code&gt; &quot;: 버퍼링이 없습니다.</target>
        </trans-unit>
        <trans-unit id="1a4495ab81e55566441b9ba9cd4267c1f76a8e00" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;no&lt;/code&gt;&quot;:  no buffering; the result of any output operation appears immediately.</source>
          <target state="translated">&quot; &lt;code&gt;no&lt;/code&gt; &quot;: 버퍼링 없음; 출력 작업 결과가 즉시 나타납니다.</target>
        </trans-unit>
        <trans-unit id="6aff03076b0cbaa7624920aed996ee3d088508ee" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;r+&lt;/code&gt;&quot;:  update mode, all previous data is preserved;</source>
          <target state="translated">&quot; &lt;code&gt;r+&lt;/code&gt; &quot;: 업데이트 모드, 모든 이전 데이터가 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="482f32bfc1639381f140a1f788e0fb798f9e8562" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;r&lt;/code&gt;&quot;:  read mode (the default);</source>
          <target state="translated">&quot; &lt;code&gt;r&lt;/code&gt; &quot;: 읽기 모드 (기본값);</target>
        </trans-unit>
        <trans-unit id="c5193d068fb02b2d565b221ff67347bc03380489" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;restart&lt;/code&gt;&quot;:  Restarts automatic execution of the garbage collector.</source>
          <target state="translated">&quot; &lt;code&gt;restart&lt;/code&gt; &quot;: 가비지 수집기의 자동 실행을 다시 시작합니다.</target>
        </trans-unit>
        <trans-unit id="1f0ba614002bce35b460ade5c8343fbd966c8766" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;restart&lt;/code&gt;&quot;:  restarts automatic execution of the garbage collector.</source>
          <target state="translated">&quot; &lt;code&gt;restart&lt;/code&gt; &quot;: 가비지 수집기의 자동 실행을 다시 시작합니다.</target>
        </trans-unit>
        <trans-unit id="da9e4c23feee0a79d4abaaf5c61375cea61ef16e" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;set&lt;/code&gt;&quot;:  base is position 0 (beginning of the file);</source>
          <target state="translated">&quot; &lt;code&gt;set&lt;/code&gt; &quot;: base는 위치 0 (파일의 시작)입니다.</target>
        </trans-unit>
        <trans-unit id="3ec56036cdf5df6fcc52e9cfbd8e2a8921f7aeb1" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;setpause&lt;/code&gt;&quot;:  sets &lt;code&gt;arg&lt;/code&gt; as the new value for the &lt;em&gt;pause&lt;/em&gt; of the collector (see &lt;a href=&quot;#2.5&quot;&gt;&amp;sect;2.5&lt;/a&gt;). Returns the previous value for &lt;em&gt;pause&lt;/em&gt;.</source>
          <target state="translated">&quot; &lt;code&gt;setpause&lt;/code&gt; &quot;: 수집기 &lt;em&gt;일시 정지&lt;/em&gt; 에 대한 새로운 값으로 &lt;code&gt;arg&lt;/code&gt; 를 설정합니다 ( &lt;a href=&quot;#2.5&quot;&gt;&amp;sect;2.5&lt;/a&gt; 참조 ). &lt;em&gt;pause&lt;/em&gt; 의 이전 값을 반환합니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d1dc91f2ee994f6c3a3be7368d48037cc9c1b59c" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;setstepmul&lt;/code&gt;&quot;:  sets &lt;code&gt;arg&lt;/code&gt; as the new value for the &lt;em&gt;step multiplier&lt;/em&gt; of the collector (see &lt;a href=&quot;#2.5&quot;&gt;&amp;sect;2.5&lt;/a&gt;). Returns the previous value for &lt;em&gt;step&lt;/em&gt;.</source>
          <target state="translated">&quot; &lt;code&gt;setstepmul&lt;/code&gt; &quot;: 수집기 의 &lt;em&gt;단계 승수&lt;/em&gt; 에 대한 새 값으로 &lt;code&gt;arg&lt;/code&gt; 를 설정합니다 ( &lt;a href=&quot;#2.5&quot;&gt;&amp;sect;2.5&lt;/a&gt; 참조 ). &lt;em&gt;step&lt;/em&gt; 의 이전 값을 반환합니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c115c4696628bd2659c03d76315d495492249e40" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;signal&lt;/code&gt;&quot;:  the command was terminated by a signal; the following number is the signal that terminated the command.</source>
          <target state="translated">&quot; &lt;code&gt;signal&lt;/code&gt; &quot;: 명령이 신호에 의해 종료되었습니다. 다음 번호는 명령을 종료 한 신호입니다.</target>
        </trans-unit>
        <trans-unit id="a35dc9f04c419056daea27ec0748582a0c9f6379" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;step&lt;/code&gt;&quot;:  Performs a garbage-collection step. The step &quot;size&quot; is controlled by &lt;code&gt;arg&lt;/code&gt;. With a zero value, the collector will perform one basic (indivisible) step. For non-zero values, the collector will perform as if that amount of memory (in Kbytes) had been allocated by Lua. Returns &lt;b&gt;true&lt;/b&gt; if the step finished a collection cycle.</source>
          <target state="translated">&quot; &lt;code&gt;step&lt;/code&gt; &quot;: 가비지 수집 단계를 수행합니다. 단계 &quot;크기&quot;는 &lt;code&gt;arg&lt;/code&gt; 에 의해 제어됩니다 . 값이 0이면 수집기는 하나의 기본 (보이지 않는) 단계를 수행합니다. 0이 아닌 값의 경우 수집기는 해당 메모리 양 (KB)이 Lua에 의해 할당 된 것처럼 수행합니다. 단계가 수집주기를 완료 한 경우 &lt;b&gt;true를&lt;/b&gt; 반환 &lt;b&gt;합니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="c28a219da2e678f08b09e43596cbee1a80cf4c50" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;step&lt;/code&gt;&quot;:  performs a garbage-collection step. The step &quot;size&quot; is controlled by &lt;code&gt;arg&lt;/code&gt;. With a zero value, the collector will perform one basic (indivisible) step. For non-zero values, the collector will perform as if that amount of memory (in KBytes) had been allocated by Lua. Returns &lt;b&gt;true&lt;/b&gt; if the step finished a collection cycle.</source>
          <target state="translated">&quot; &lt;code&gt;step&lt;/code&gt; &quot;: 가비지 수집 단계를 수행합니다. &quot;size&quot;단계는 &lt;code&gt;arg&lt;/code&gt; 에 의해 제어됩니다 . 값이 0이면 수집기는 하나의 기본 (보이지 않는) 단계를 수행합니다. 0이 아닌 값의 경우 콜렉터는 해당 메모리 양 (KB)이 Lua에 의해 할당 된 것처럼 수행합니다. 단계가 수집주기를 완료 한 경우 &lt;b&gt;true를&lt;/b&gt; 리턴 &lt;b&gt;합니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="75ecb2938319892eec67595c46d5dcd1f322568e" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;stop&lt;/code&gt;&quot;:  Stops automatic execution of the garbage collector. The collector will run only when explicitly invoked, until a call to restart it.</source>
          <target state="translated">&quot; &lt;code&gt;stop&lt;/code&gt; &quot;: 가비지 수집기의 자동 실행을 중지합니다. 콜렉터는 다시 시작하라는 호출이있을 때까지 명시 적으로 호출 된 경우에만 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="93ae23d840374f0e5fdda6d2e1995e17e2530e29" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;stop&lt;/code&gt;&quot;:  stops automatic execution of the garbage collector. The collector will run only when explicitly invoked, until a call to restart it.</source>
          <target state="translated">&quot; &lt;code&gt;stop&lt;/code&gt; &quot;: 가비지 수집기의 자동 실행을 중지합니다. 콜렉터는 명시 적으로 호출 된 경우에만 다시 호출 할 때까지 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="630c88288eece276817c37c452c13aad30aeeac6" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;w+&lt;/code&gt;&quot;:  update mode, all previous data is erased;</source>
          <target state="translated">&quot; &lt;code&gt;w+&lt;/code&gt; &quot;: 업데이트 모드, 모든 이전 데이터가 지워집니다.</target>
        </trans-unit>
        <trans-unit id="4c032e7180fccc925387c5e5d8ef02f876f66a43" translate="yes" xml:space="preserve">
          <source>&quot;&lt;code&gt;w&lt;/code&gt;&quot;:  write mode;</source>
          <target state="translated">&quot; &lt;code&gt;w&lt;/code&gt; &quot;: 쓰기 모드;</target>
        </trans-unit>
        <trans-unit id="f33634dd2aed7619f53f32286917ce87f67cf9f3" translate="yes" xml:space="preserve">
          <source>&amp;copy; 1994&amp;ndash;2017 Lua.org, PUC-Rio.</source>
          <target state="translated">&amp;copy; 1994&amp;ndash;2017 Lua.org, PUC-Rio.</target>
        </trans-unit>
        <trans-unit id="d144761db2915b51c7b3617d755d730533ec0cbe" translate="yes" xml:space="preserve">
          <source>&amp;copy; 1994&amp;ndash;2020 Lua.org, PUC-Rio.</source>
          <target state="translated">&amp;copy; 1994&amp;ndash;2020 Lua.org, PUC-Rio.</target>
        </trans-unit>
        <trans-unit id="726a699c479b955107f38c46bbe964c5bb86c9c1" translate="yes" xml:space="preserve">
          <source>'': (empty space) ignored</source>
          <target state="translated">'': (빈 공간) 무시</target>
        </trans-unit>
        <trans-unit id="56889bd563c8faf4c3a42e886a563582cffec219" translate="yes" xml:space="preserve">
          <source>'': (space) ignored</source>
          <target state="translated">'': (공백) 무시</target>
        </trans-unit>
        <trans-unit id="f90841632f7dd28deac05f9104f8757d4d938ddf" translate="yes" xml:space="preserve">
          <source>'&lt;code&gt;L&lt;/code&gt;':  pushes onto the stack a table whose indices are the numbers of the lines that are valid on the function. (A &lt;em&gt;valid line&lt;/em&gt; is a line with some associated code, that is, a line where you can put a break point. Non-valid lines include empty lines and comments.)</source>
          <target state="translated">' &lt;code&gt;L&lt;/code&gt; ': 함수에 유효한 행 번호를 나타내는 테이블을 스택에 푸시합니다. (A &lt;em&gt;유효한 라인은&lt;/em&gt; 일부 관련 코드, 당신은 브레이크 포인트를 넣을 수 있습니다 라인과 라인입니다. 비 유효 라인이 빈 줄과 주석을 포함.)</target>
        </trans-unit>
        <trans-unit id="16fe771c19d862613ab04d78a26fbb806a4f2023" translate="yes" xml:space="preserve">
          <source>'&lt;code&gt;S&lt;/code&gt;':  fills in the fields &lt;code&gt;source&lt;/code&gt;, &lt;code&gt;short_src&lt;/code&gt;, &lt;code&gt;linedefined&lt;/code&gt;, &lt;code&gt;lastlinedefined&lt;/code&gt;, and &lt;code&gt;what&lt;/code&gt;;</source>
          <target state="translated">' &lt;code&gt;S&lt;/code&gt; ': 필드 &lt;code&gt;source&lt;/code&gt; , &lt;code&gt;short_src&lt;/code&gt; , &lt;code&gt;linedefined&lt;/code&gt; , &lt;code&gt;lastlinedefined&lt;/code&gt; 및 &lt;code&gt;what&lt;/code&gt; 채 웁니다 .</target>
        </trans-unit>
        <trans-unit id="11a8d7eb3de20bf4074efa8302fa3ebc068c92db" translate="yes" xml:space="preserve">
          <source>'&lt;code&gt;c&lt;/code&gt;':  the hook is called every time Lua calls a function;</source>
          <target state="translated">' &lt;code&gt;c&lt;/code&gt; ': 루아가 함수를 호출 할 때마다 후크가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="5dcde03cc29cac4fbee975fd5c6324c0eb2f762a" translate="yes" xml:space="preserve">
          <source>'&lt;code&gt;f&lt;/code&gt;':  pushes onto the stack the function that is running at the given level;</source>
          <target state="translated">' &lt;code&gt;f&lt;/code&gt; ': 주어진 레벨에서 실행중인 기능을 스택에 푸시합니다.</target>
        </trans-unit>
        <trans-unit id="d52c4536e0d633bd2dc95275436338ca66e5b0e0" translate="yes" xml:space="preserve">
          <source>'&lt;code&gt;l&lt;/code&gt;':  fills in the field &lt;code&gt;currentline&lt;/code&gt;;</source>
          <target state="translated">' &lt;code&gt;l&lt;/code&gt; ': 필드 &lt;code&gt;currentline&lt;/code&gt; 을 채 웁니다 .</target>
        </trans-unit>
        <trans-unit id="06eefa71811d3d77eadfb569caf992bf00533260" translate="yes" xml:space="preserve">
          <source>'&lt;code&gt;l&lt;/code&gt;':  the hook is called every time Lua enters a new line of code.</source>
          <target state="translated">' &lt;code&gt;l&lt;/code&gt; ': Lua가 새로운 코드 줄을 입력 할 때마다 후크가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="19b3d6db914e545df7410bf6ead714c645f9d90c" translate="yes" xml:space="preserve">
          <source>'&lt;code&gt;n&lt;/code&gt;':  fills in the field &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;namewhat&lt;/code&gt;;</source>
          <target state="translated">' &lt;code&gt;n&lt;/code&gt; ': 필드 &lt;code&gt;name&lt;/code&gt; 과 &lt;code&gt;namewhat&lt;/code&gt; 을 채 웁니다 .</target>
        </trans-unit>
        <trans-unit id="0af9c5fa72fd0ae40f86d69a634de5abaff185ba" translate="yes" xml:space="preserve">
          <source>'&lt;code&gt;r&lt;/code&gt;':  the hook is called every time Lua returns from a function;</source>
          <target state="translated">' &lt;code&gt;r&lt;/code&gt; ': 루아가 함수에서 리턴 할 때마다 후크가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="5aab32dc44a04b46cf39fd9dca7828f4e75632c3" translate="yes" xml:space="preserve">
          <source>'&lt;code&gt;t&lt;/code&gt;':  fills in the field &lt;code&gt;istailcall&lt;/code&gt;;</source>
          <target state="translated">' &lt;code&gt;t&lt;/code&gt; ': &lt;code&gt;istailcall&lt;/code&gt; 필드를 채 웁니다 .</target>
        </trans-unit>
        <trans-unit id="2995d9a5b2edfc5c4090bb5aeac40be286f51c1c" translate="yes" xml:space="preserve">
          <source>'&lt;code&gt;u&lt;/code&gt;':  fills in the fields &lt;code&gt;nups&lt;/code&gt;, &lt;code&gt;nparams&lt;/code&gt;, and &lt;code&gt;isvararg&lt;/code&gt;;</source>
          <target state="translated">' &lt;code&gt;u&lt;/code&gt; '필드 채우고 &lt;code&gt;nups&lt;/code&gt; , &lt;code&gt;nparams&lt;/code&gt; 및 &lt;code&gt;isvararg&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="3ba9ac7e76f439728000e96df248ad5393e0be09" translate="yes" xml:space="preserve">
          <source>(A &quot;&lt;code&gt;[&lt;em&gt;n&lt;/em&gt;]&lt;/code&gt;&quot; means an optional integral numeral.) Except for padding, spaces, and configurations (options &quot;&lt;code&gt;xX &amp;lt;=&amp;gt;!&lt;/code&gt;&quot;), each option corresponds to an argument (in &lt;a href=&quot;#pdf-string.pack&quot;&gt;&lt;code&gt;string.pack&lt;/code&gt;&lt;/a&gt;) or a result (in &lt;a href=&quot;#pdf-string.unpack&quot;&gt;&lt;code&gt;string.unpack&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">( &quot; &lt;code&gt;[&lt;em&gt;n&lt;/em&gt;]&lt;/code&gt; &quot;는 선택적인 정수를 의미합니다.) 패딩, 공백 및 구성 (옵션 &quot; &lt;code&gt;xX &amp;lt;=&amp;gt;!&lt;/code&gt; &quot;)을 제외하고 각 옵션은 인수 ( &lt;a href=&quot;#pdf-string.pack&quot;&gt; &lt;code&gt;string.pack&lt;/code&gt; &lt;/a&gt; ) 또는 결과 ( &lt;a href=&quot;#pdf-string.unpack&quot;&gt; &lt;code&gt;string.unpack&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="93c9ef50a3ebe3dd10bce375075c3a8ce7976bbf" translate="yes" xml:space="preserve">
          <source>(A &quot;&lt;code&gt;[&lt;em&gt;n&lt;/em&gt;]&lt;/code&gt;&quot; means an optional integral numeral.) Except for padding, spaces, and configurations (options &quot;&lt;code&gt;xX &amp;lt;=&amp;gt;!&lt;/code&gt;&quot;), each option corresponds to an argument in &lt;a href=&quot;#pdf-string.pack&quot;&gt;&lt;code&gt;string.pack&lt;/code&gt;&lt;/a&gt; or a result in &lt;a href=&quot;#pdf-string.unpack&quot;&gt;&lt;code&gt;string.unpack&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">( &quot; &lt;code&gt;[&lt;em&gt;n&lt;/em&gt;]&lt;/code&gt; &quot;은 선택적 정수를 의미합니다.) 패딩, 공백 및 구성 (옵션 &quot; &lt;code&gt;xX &amp;lt;=&amp;gt;!&lt;/code&gt; &quot;)을 제외하고 각 옵션은 &lt;a href=&quot;#pdf-string.pack&quot;&gt; &lt;code&gt;string.pack&lt;/code&gt; &lt;/a&gt; 의 인수 또는 string.unpack 의 결과에 &lt;a href=&quot;#pdf-string.unpack&quot;&gt; &lt;code&gt;string.unpack&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f77a9f254e99c74357020a933128fef2049e3240" translate="yes" xml:space="preserve">
          <source>(For Lua functions, upvalues are the external local variables that the function uses, and that are consequently included in its closure.)</source>
          <target state="translated">(Lua 함수의 경우 upvalue는 함수가 사용하는 외부 지역 변수이며 결과적으로 클로저에 포함됩니다.)</target>
        </trans-unit>
        <trans-unit id="47739e8fdeffa5f4b3709743500dd5823ab5e80f" translate="yes" xml:space="preserve">
          <source>(For historical reasons, this function returns an &lt;code&gt;int&lt;/code&gt;, which now is always 1.)</source>
          <target state="translated">(역사적인 이유로이 함수는 현재 항상 1 인 &lt;code&gt;int&lt;/code&gt; 를 반환합니다 .)</target>
        </trans-unit>
        <trans-unit id="ff34abdb860538263e1592eaf5de0e2697e490fe" translate="yes" xml:space="preserve">
          <source>(Formally this is not an incompatibility, because Lua does not specify how numbers are formatted as strings, but some programs assumed a specific format.)</source>
          <target state="translated">Lua는 숫자가 문자열로 형식화되는 방식을 지정하지 않지만 일부 프로그램은 특정 형식을 가정하기 때문에 공식적으로 이것은 비 호환성이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="83e737da7c8003cef965fa66244b7d4f0e811971" translate="yes" xml:space="preserve">
          <source>(In this manual, &lt;code&gt;--&amp;gt;&lt;/code&gt; indicates the result of the preceding expression.)</source>
          <target state="translated">(이 설명서에서 &lt;code&gt;--&amp;gt;&lt;/code&gt; 는 이전 식의 결과를 나타냅니다.)</target>
        </trans-unit>
        <trans-unit id="bf94fa4119b73b349cb3a869be243c96bbbd716b" translate="yes" xml:space="preserve">
          <source>(Note that it is very easy to exhaust the memory of your machine with a single call to this function.)</source>
          <target state="translated">(이 기능을 한 번만 호출하면 기기의 메모리를 쉽게 소모 할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="15e67d53040898eb1d72848e8bf16a113fbe8148" translate="yes" xml:space="preserve">
          <source>(Of course, the location of the Lua interpreter may be different in your machine. If &lt;code&gt;lua&lt;/code&gt; is in your &lt;code&gt;PATH&lt;/code&gt;, then</source>
          <target state="translated">(물론, 루아 인터프리터의 위치를 컴퓨터에 다를 수 있습니다. 경우 &lt;code&gt;lua&lt;/code&gt; 당신에 &lt;code&gt;PATH&lt;/code&gt; , 다음</target>
        </trans-unit>
        <trans-unit id="81e3e714f7f80485e58bd929a17d4b2437cf6658" translate="yes" xml:space="preserve">
          <source>(This only makes a difference when the body of the function contains references to &lt;code&gt;f&lt;/code&gt;.)</source>
          <target state="translated">(이것은 함수의 본문에 &lt;code&gt;f&lt;/code&gt; 에 대한 참조가 포함 된 경우에만 차이를 만듭니다 .)</target>
        </trans-unit>
        <trans-unit id="cc7121f94b54a95b8b969917eaaadf1818bfdd84" translate="yes" xml:space="preserve">
          <source>1 &amp;ndash; Introduction</source>
          <target state="translated">1. 소개</target>
        </trans-unit>
        <trans-unit id="8f2807c1adb4cb8317971da9ae6f8750a47585a8" translate="yes" xml:space="preserve">
          <source>2 &amp;ndash; Basic Concepts</source>
          <target state="translated">2 &amp;ndash; 기본 개념</target>
        </trans-unit>
        <trans-unit id="addc53e794c80e9178d488e577f3a4dea23392c9" translate="yes" xml:space="preserve">
          <source>2.1 &amp;ndash; Values and Types</source>
          <target state="translated">2.1 &amp;ndash; 가치와 유형</target>
        </trans-unit>
        <trans-unit id="3a2d12c82ff6ae933fc4f58e1c29dac173475282" translate="yes" xml:space="preserve">
          <source>2.2 &amp;ndash; Environments and the Global Environment</source>
          <target state="translated">2.2 &amp;ndash; 환경과 지구 환경</target>
        </trans-unit>
        <trans-unit id="9ffa2c3b3aefb8ca31249b42217d40b45a53d14c" translate="yes" xml:space="preserve">
          <source>2.3 &amp;ndash; Error Handling</source>
          <target state="translated">2.3 &amp;ndash; 오류 처리</target>
        </trans-unit>
        <trans-unit id="5c74738bb551c5852eee4f0c5bc1c1ba329666da" translate="yes" xml:space="preserve">
          <source>2.4 &amp;ndash; Metatables and Metamethods</source>
          <target state="translated">2.4 &amp;ndash; 메타 테이블과 메타 메서드</target>
        </trans-unit>
        <trans-unit id="33aac5b72dac431d0193e5a027944729e242300d" translate="yes" xml:space="preserve">
          <source>2.5 &amp;ndash; Garbage Collection</source>
          <target state="translated">2.5 &amp;ndash; 쓰레기 수거</target>
        </trans-unit>
        <trans-unit id="0f9506705cc9aac3384b718f0231b4eeaf53f83b" translate="yes" xml:space="preserve">
          <source>2.5.1 &amp;ndash; Garbage-Collection Metamethods</source>
          <target state="translated">2.5.1 &amp;ndash; 가비지 콜렉션 메타 메소드</target>
        </trans-unit>
        <trans-unit id="e32b78c5e50a1f090eee84e8782e491a63c87474" translate="yes" xml:space="preserve">
          <source>2.5.1 &amp;ndash; Incremental Garbage Collection</source>
          <target state="translated">2.5.1 &amp;ndash; 증분 가비지 수집</target>
        </trans-unit>
        <trans-unit id="43af5305d3d2bab0f47bc71974c0c5f7e41eb765" translate="yes" xml:space="preserve">
          <source>2.5.2 &amp;ndash; Generational Garbage Collection</source>
          <target state="translated">2.5.2 &amp;ndash; 세대 별 가비지 수집</target>
        </trans-unit>
        <trans-unit id="360b1c24eeac1e48dfe95fc741100e73b36bcc2b" translate="yes" xml:space="preserve">
          <source>2.5.2 &amp;ndash; Weak Tables</source>
          <target state="translated">2.5.2 &amp;ndash; 약한 테이블</target>
        </trans-unit>
        <trans-unit id="8e167c46990c9b5a8a8cb584e6e98fba1cedd41a" translate="yes" xml:space="preserve">
          <source>2.5.3 &amp;ndash; Garbage-Collection Metamethods</source>
          <target state="translated">2.5.3 &amp;ndash; 가비지 컬렉션 메타 메서드</target>
        </trans-unit>
        <trans-unit id="214d3a585538532f8988b9596464a09d392edfe6" translate="yes" xml:space="preserve">
          <source>2.5.4 &amp;ndash; Weak Tables</source>
          <target state="translated">2.5.4 &amp;ndash; 약한 테이블</target>
        </trans-unit>
        <trans-unit id="49622640c10cc5518dfa4cbdd39ec33d28b234e2" translate="yes" xml:space="preserve">
          <source>2.6 &amp;ndash; Coroutines</source>
          <target state="translated">2.6 &amp;ndash; 코 루틴</target>
        </trans-unit>
        <trans-unit id="44e5a7dffeb9301dcfea49c570d9242c8df4de45" translate="yes" xml:space="preserve">
          <source>3 &amp;ndash; The Language</source>
          <target state="translated">3 &amp;ndash; 언어</target>
        </trans-unit>
        <trans-unit id="2e41c7c97446c4f1020d50a68126a5a0606e6e8f" translate="yes" xml:space="preserve">
          <source>3.1 &amp;ndash; Lexical Conventions</source>
          <target state="translated">3.1 &amp;ndash; 어휘 규칙</target>
        </trans-unit>
        <trans-unit id="0612a6e0f7da40e6c864f4e6e097977a5b51bcbe" translate="yes" xml:space="preserve">
          <source>3.2 &amp;ndash; Variables</source>
          <target state="translated">3.2 &amp;ndash; 변수</target>
        </trans-unit>
        <trans-unit id="831eca58ed9634bf35d286b0652dd764c6225329" translate="yes" xml:space="preserve">
          <source>3.3 &amp;ndash; Statements</source>
          <target state="translated">3.3 &amp;ndash; 진술</target>
        </trans-unit>
        <trans-unit id="b9b8530dd3439338077cae5d9a81b0f8388246f9" translate="yes" xml:space="preserve">
          <source>3.3.1 &amp;ndash; Blocks</source>
          <target state="translated">3.3.1 &amp;ndash; 블록</target>
        </trans-unit>
        <trans-unit id="249018398e87db611b2f382c32e3c2029e7a3362" translate="yes" xml:space="preserve">
          <source>3.3.2 &amp;ndash; Chunks</source>
          <target state="translated">3.3.2 &amp;ndash; 청크</target>
        </trans-unit>
        <trans-unit id="93fdc1a5227f5f767eda4b33118ca26d4d3ec98f" translate="yes" xml:space="preserve">
          <source>3.3.3 &amp;ndash; Assignment</source>
          <target state="translated">3.3.3 &amp;ndash; 할당</target>
        </trans-unit>
        <trans-unit id="60ea5bc043174dd66add3628579020e9fd6149ea" translate="yes" xml:space="preserve">
          <source>3.3.4 &amp;ndash; Control Structures</source>
          <target state="translated">3.3.4 &amp;ndash; 제어 구조</target>
        </trans-unit>
        <trans-unit id="b4e38214a26cbc13913d45fcdc42571b93281b8f" translate="yes" xml:space="preserve">
          <source>3.3.5 &amp;ndash; For Statement</source>
          <target state="translated">3.3.5 &amp;ndash; 명세서</target>
        </trans-unit>
        <trans-unit id="1f046a545135d5e9e1e65842299b34f6b36157ac" translate="yes" xml:space="preserve">
          <source>3.3.6 &amp;ndash; Function Calls as Statements</source>
          <target state="translated">3.3.6 &amp;ndash; 명령문으로서의 함수 호출</target>
        </trans-unit>
        <trans-unit id="19a6d2647263682fe5a7621ae89477d702d33727" translate="yes" xml:space="preserve">
          <source>3.3.7 &amp;ndash; Local Declarations</source>
          <target state="translated">3.3.7 &amp;ndash; 지역 선언</target>
        </trans-unit>
        <trans-unit id="af418c66e1cf132089f35fa7b4a14dba17e186f8" translate="yes" xml:space="preserve">
          <source>3.3.8 &amp;ndash; To-be-closed Variables</source>
          <target state="translated">3.3.8 &amp;ndash; 마감 될 변수</target>
        </trans-unit>
        <trans-unit id="ac56f78d28bb6bfafede4821e374042b6d5ded3c" translate="yes" xml:space="preserve">
          <source>3.4 &amp;ndash; Expressions</source>
          <target state="translated">3.4 &amp;ndash; 표현</target>
        </trans-unit>
        <trans-unit id="11859fef39e3ab01288c6dd79b5e2b11fdad4c8d" translate="yes" xml:space="preserve">
          <source>3.4.1 &amp;ndash; Arithmetic Operators</source>
          <target state="translated">3.4.1 &amp;ndash; 산술 연산자</target>
        </trans-unit>
        <trans-unit id="5ba9603d3900196b96bc99dd68bef5ea214ec46d" translate="yes" xml:space="preserve">
          <source>3.4.10 &amp;ndash; Function Calls</source>
          <target state="translated">3.4.10 &amp;ndash; 함수 호출</target>
        </trans-unit>
        <trans-unit id="d521e09f296fb652ca685e9986c89365b3a3a60e" translate="yes" xml:space="preserve">
          <source>3.4.11 &amp;ndash; Function Definitions</source>
          <target state="translated">3.4.11 &amp;ndash; 기능 정의</target>
        </trans-unit>
        <trans-unit id="0767b1e410d6366522683c5dea029dba330f750e" translate="yes" xml:space="preserve">
          <source>3.4.2 &amp;ndash; Bitwise Operators</source>
          <target state="translated">3.4.2 &amp;ndash; 비트 연산자</target>
        </trans-unit>
        <trans-unit id="7fcc429ce74b3bad7b171ca68ce6278ebc43bae9" translate="yes" xml:space="preserve">
          <source>3.4.3 &amp;ndash; Coercions and Conversions</source>
          <target state="translated">3.4.3 &amp;ndash; 강압과 변환</target>
        </trans-unit>
        <trans-unit id="a5cfc763ebbbdbc2d383f04e2795f848e29252e2" translate="yes" xml:space="preserve">
          <source>3.4.4 &amp;ndash; Relational Operators</source>
          <target state="translated">3.4.4 &amp;ndash; 관계 연산자</target>
        </trans-unit>
        <trans-unit id="0813780c5158e7059551f2d8bd071c10fcd64a1e" translate="yes" xml:space="preserve">
          <source>3.4.5 &amp;ndash; Logical Operators</source>
          <target state="translated">3.4.5 &amp;ndash; 논리 연산자</target>
        </trans-unit>
        <trans-unit id="053f15c92c03eee025a09cbef6910c4913cf9628" translate="yes" xml:space="preserve">
          <source>3.4.6 &amp;ndash; Concatenation</source>
          <target state="translated">3.4.6 &amp;ndash; 연결</target>
        </trans-unit>
        <trans-unit id="48ea8196506d47e56086f0bd779ad133e81d539a" translate="yes" xml:space="preserve">
          <source>3.4.7 &amp;ndash; The Length Operator</source>
          <target state="translated">3.4.7 &amp;ndash; 길이 연산자</target>
        </trans-unit>
        <trans-unit id="b77361dfb2f580a09634468b4a92c293c9a90987" translate="yes" xml:space="preserve">
          <source>3.4.8 &amp;ndash; Precedence</source>
          <target state="translated">3.4.8 &amp;ndash; 우선 순위</target>
        </trans-unit>
        <trans-unit id="1716010a5bdaeeaa519496e7998b4394c6b17b0d" translate="yes" xml:space="preserve">
          <source>3.4.9 &amp;ndash; Table Constructors</source>
          <target state="translated">3.4.9 &amp;ndash; 테이블 생성자</target>
        </trans-unit>
        <trans-unit id="c20fcbea7777ae7db816c4f7863db3c7e76c4be7" translate="yes" xml:space="preserve">
          <source>3.5 &amp;ndash; Visibility Rules</source>
          <target state="translated">3.5 &amp;ndash; 가시성 규칙</target>
        </trans-unit>
        <trans-unit id="dd63ac66a4ed838d368dd76236f0026ba6aee449" translate="yes" xml:space="preserve">
          <source>4 &amp;ndash; The Application Program Interface</source>
          <target state="translated">4 &amp;ndash; 응용 프로그램 인터페이스</target>
        </trans-unit>
        <trans-unit id="f79922b6ade2d7cb13fd986a703b2a74313e769b" translate="yes" xml:space="preserve">
          <source>4.1 &amp;ndash; The Stack</source>
          <target state="translated">4.1 &amp;ndash; 스택</target>
        </trans-unit>
        <trans-unit id="d9f9eb941346401ba1b1d6e7aa99b140b60d3df8" translate="yes" xml:space="preserve">
          <source>4.1.1 &amp;ndash; Stack Size</source>
          <target state="translated">4.1.1 &amp;ndash; 스택 크기</target>
        </trans-unit>
        <trans-unit id="8b53b631b67c084454b799b08efc2b764260fa3a" translate="yes" xml:space="preserve">
          <source>4.1.2 &amp;ndash; Valid and Acceptable Indices</source>
          <target state="translated">4.1.2 &amp;ndash; 유효하고 허용 가능한 지수</target>
        </trans-unit>
        <trans-unit id="4f1e3768345e4af898dfc41e7e10c658434cc264" translate="yes" xml:space="preserve">
          <source>4.1.3 &amp;ndash; Pointers to strings</source>
          <target state="translated">4.1.3 &amp;ndash; 문자열에 대한 포인터</target>
        </trans-unit>
        <trans-unit id="1f948f17a2d03bb70942c6d60e9c6dd9718a6ab6" translate="yes" xml:space="preserve">
          <source>4.2 &amp;ndash; C Closures</source>
          <target state="translated">4.2 &amp;ndash; C 클로저</target>
        </trans-unit>
        <trans-unit id="5b51906b5985deb44043d8f246cfc18dd2ae60aa" translate="yes" xml:space="preserve">
          <source>4.2 &amp;ndash; Stack Size</source>
          <target state="translated">4.2 &amp;ndash; 스택 크기</target>
        </trans-unit>
        <trans-unit id="b9e0c047d51ad36674867b47be7d8064f6cc1198" translate="yes" xml:space="preserve">
          <source>4.3 &amp;ndash; Registry</source>
          <target state="translated">4.3 &amp;ndash; 레지스트리</target>
        </trans-unit>
        <trans-unit id="31b2949d1c9fcdf122a9e531b559332da4485f80" translate="yes" xml:space="preserve">
          <source>4.3 &amp;ndash; Valid and Acceptable Indices</source>
          <target state="translated">4.3 &amp;ndash; 유효하고 허용 가능한 지수</target>
        </trans-unit>
        <trans-unit id="74f0c5c5ee47538264fae29f7657133d0d699462" translate="yes" xml:space="preserve">
          <source>4.4 &amp;ndash; C Closures</source>
          <target state="translated">4.4 &amp;ndash; C 폐쇄</target>
        </trans-unit>
        <trans-unit id="0dbd1a3e805d6fec4ca12f8d780c75e4a904e874" translate="yes" xml:space="preserve">
          <source>4.4 &amp;ndash; Error Handling in C</source>
          <target state="translated">4.4 &amp;ndash; C에서 오류 처리</target>
        </trans-unit>
        <trans-unit id="7f9e6c48a793a67b066e784105577fb0aa683bea" translate="yes" xml:space="preserve">
          <source>4.4.1 &amp;ndash; Status Codes</source>
          <target state="translated">4.4.1 &amp;ndash; 상태 코드</target>
        </trans-unit>
        <trans-unit id="377aa610f8c8d69e259aec326a2c725db1573141" translate="yes" xml:space="preserve">
          <source>4.5 &amp;ndash; Handling Yields in C</source>
          <target state="translated">4.5 &amp;ndash; C에서 수율 처리</target>
        </trans-unit>
        <trans-unit id="dc6aa4af1e5cbd9bad1a034dc03de85dd86ad779" translate="yes" xml:space="preserve">
          <source>4.5 &amp;ndash; Registry</source>
          <target state="translated">4.5 &amp;ndash; 레지스트리</target>
        </trans-unit>
        <trans-unit id="d8452600dbf3930156ccc218b4b4ddb69035a3ec" translate="yes" xml:space="preserve">
          <source>4.6 &amp;ndash; Error Handling in C</source>
          <target state="translated">4.6 &amp;ndash; C에서의 오류 처리</target>
        </trans-unit>
        <trans-unit id="f7a50c0b6783f529c6ca7b0482b1c7c7c2bb7fdf" translate="yes" xml:space="preserve">
          <source>4.6 &amp;ndash; Functions and Types[-o, +p, &lt;em&gt;x&lt;/em&gt;]</source>
          <target state="translated">4.6 &amp;ndash; 기능 및 유형 [-o, + p, &lt;em&gt;x&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="275ecb37e4e88aebd92acb558147bf849a62c9bb" translate="yes" xml:space="preserve">
          <source>4.7 &amp;ndash; Handling Yields in C</source>
          <target state="translated">4.7 &amp;ndash; C의 수확량 처리</target>
        </trans-unit>
        <trans-unit id="4e14e0c386ac14d12f3f1850ac004fb05166fe20" translate="yes" xml:space="preserve">
          <source>4.7 &amp;ndash; The Debug Interface</source>
          <target state="translated">4.7 &amp;ndash; 디버그 인터페이스</target>
        </trans-unit>
        <trans-unit id="bd1985494a7c3d7d1062380e781037ccb1f14dbf" translate="yes" xml:space="preserve">
          <source>4.8 &amp;ndash; Functions and Types[-o, +p, &lt;em&gt;x&lt;/em&gt;]</source>
          <target state="translated">4.8 &amp;ndash; 함수와 타입 [-o, + p, &lt;em&gt;x&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="fd295b2094f1a31a0f8f4e3c5ef5c7874f795c82" translate="yes" xml:space="preserve">
          <source>4.9 &amp;ndash; The Debug Interface</source>
          <target state="translated">4.9 &amp;ndash; 디버그 인터페이스</target>
        </trans-unit>
        <trans-unit id="7ad85d079aa056f3c063c288f0c0093ca0f6c73d" translate="yes" xml:space="preserve">
          <source>5 &amp;ndash; The Auxiliary Library</source>
          <target state="translated">5 &amp;ndash; 보조 도서관</target>
        </trans-unit>
        <trans-unit id="71d57e32825e907432cc4adf35e23a77ed97c0a2" translate="yes" xml:space="preserve">
          <source>5.1 &amp;ndash; Functions and Types</source>
          <target state="translated">5.1 &amp;ndash; 기능 및 유형</target>
        </trans-unit>
        <trans-unit id="92cc3da65a13c96c43af92f1e98bfede2f153c83" translate="yes" xml:space="preserve">
          <source>6 &amp;ndash; Standard Libraries</source>
          <target state="translated">6 &amp;ndash; 표준 라이브러리</target>
        </trans-unit>
        <trans-unit id="cdc1f8312506691b983394a13630259db22af735" translate="yes" xml:space="preserve">
          <source>6 &amp;ndash; The Standard Libraries</source>
          <target state="translated">6 &amp;ndash; 표준 라이브러리</target>
        </trans-unit>
        <trans-unit id="c1cf8fe5aceb71994bc78f0adf755277b6681f00" translate="yes" xml:space="preserve">
          <source>6.1 &amp;ndash; Basic Functions</source>
          <target state="translated">6.1 &amp;ndash; 기본 기능</target>
        </trans-unit>
        <trans-unit id="6e24ce31a4d8a8b2c4bf3eaf4c953e980b335967" translate="yes" xml:space="preserve">
          <source>6.10 &amp;ndash; The Debug Library</source>
          <target state="translated">6.10 &amp;ndash; 디버그 라이브러리</target>
        </trans-unit>
        <trans-unit id="03d2065bb3d3315a8c459cb76f8c692d4aabb3b3" translate="yes" xml:space="preserve">
          <source>6.2 &amp;ndash; Coroutine Manipulation</source>
          <target state="translated">6.2 &amp;ndash; 코 루틴 조작</target>
        </trans-unit>
        <trans-unit id="7ab3ec70bbfde06cb8aacd9d27858f73840ca3e6" translate="yes" xml:space="preserve">
          <source>6.3 &amp;ndash; Modules</source>
          <target state="translated">6.3 &amp;ndash; 모듈</target>
        </trans-unit>
        <trans-unit id="1a9e8fe3268257be8690631f66b150e7b529fa25" translate="yes" xml:space="preserve">
          <source>6.4 &amp;ndash; String Manipulation</source>
          <target state="translated">6.4 &amp;ndash; 문자열 조작</target>
        </trans-unit>
        <trans-unit id="c32244a851c4ca4fbd524d465d9ac63a62295558" translate="yes" xml:space="preserve">
          <source>6.4.1 &amp;ndash; Patterns</source>
          <target state="translated">6.4.1 &amp;ndash; 패턴</target>
        </trans-unit>
        <trans-unit id="117f4fd92a6a3918b099c684ab382f396d5eb6a0" translate="yes" xml:space="preserve">
          <source>6.4.2 &amp;ndash; Format Strings for Pack and Unpack</source>
          <target state="translated">6.4.2 &amp;ndash; 팩 및 언팩의 형식 문자열</target>
        </trans-unit>
        <trans-unit id="2c69cea016f7e6620297e4c1a14aee86bca54a5d" translate="yes" xml:space="preserve">
          <source>6.5 &amp;ndash; UTF-8 Support</source>
          <target state="translated">6.5 &amp;ndash; UTF-8 지원</target>
        </trans-unit>
        <trans-unit id="63cc5647192e9aeb780e978b92120a1f45dd2739" translate="yes" xml:space="preserve">
          <source>6.6 &amp;ndash; Table Manipulation</source>
          <target state="translated">6.6 &amp;ndash; 테이블 조작</target>
        </trans-unit>
        <trans-unit id="c32e233273be58074db0281b90ff78f133dadaa9" translate="yes" xml:space="preserve">
          <source>6.7 &amp;ndash; Mathematical Functions</source>
          <target state="translated">6.7 &amp;ndash; 수학 함수</target>
        </trans-unit>
        <trans-unit id="832907e7e19406cf81191180275a0cb50dea430b" translate="yes" xml:space="preserve">
          <source>6.8 &amp;ndash; Input and Output Facilities</source>
          <target state="translated">6.8 &amp;ndash; 입력 및 출력 기능</target>
        </trans-unit>
        <trans-unit id="cb34b15416a677114058591f5dd2c4ae7287d44b" translate="yes" xml:space="preserve">
          <source>6.9 &amp;ndash; Operating System Facilities</source>
          <target state="translated">6.9 &amp;ndash; 운영 체제 기능</target>
        </trans-unit>
        <trans-unit id="392af5f262337c8a47dea77fc574c5980a74525f" translate="yes" xml:space="preserve">
          <source>7 &amp;ndash; Lua Standalone</source>
          <target state="translated">7 &amp;ndash; 루아 독립형</target>
        </trans-unit>
        <trans-unit id="8f903b288c9e6ac2b63f9c5ac1ae4e51b0452d1a" translate="yes" xml:space="preserve">
          <source>8 &amp;ndash; Incompatibilities with the Previous Version</source>
          <target state="translated">8 &amp;ndash; 이전 버전과의 비 호환성</target>
        </trans-unit>
        <trans-unit id="3f8999c0013347303415ee512a5929d88176001f" translate="yes" xml:space="preserve">
          <source>8.1 &amp;ndash; Changes in the Language</source>
          <target state="translated">8.1 &amp;ndash; 언어 변경</target>
        </trans-unit>
        <trans-unit id="06621f3918bf601ab4ad6ab96566b71dfebeffb3" translate="yes" xml:space="preserve">
          <source>8.1 &amp;ndash; Incompatibilities in the Language</source>
          <target state="translated">8.1 &amp;ndash; 언어의 비 호환성</target>
        </trans-unit>
        <trans-unit id="9e15fa697b4f86446516c25786580893e59e6a10" translate="yes" xml:space="preserve">
          <source>8.2 &amp;ndash; Changes in the Libraries</source>
          <target state="translated">8.2 &amp;ndash; 라이브러리의 변경</target>
        </trans-unit>
        <trans-unit id="23f51416a51cac5ed2d636a8149b6e8015550499" translate="yes" xml:space="preserve">
          <source>8.2 &amp;ndash; Incompatibilities in the Libraries</source>
          <target state="translated">8.2 &amp;ndash; 라이브러리의 비 호환성</target>
        </trans-unit>
        <trans-unit id="d089e3545870977ceda5c673010988a582c7e893" translate="yes" xml:space="preserve">
          <source>8.3 &amp;ndash; Changes in the API</source>
          <target state="translated">8.3 &amp;ndash; API 변경</target>
        </trans-unit>
        <trans-unit id="f39f679da171dc7301920de76daf97ecf11156be" translate="yes" xml:space="preserve">
          <source>8.3 &amp;ndash; Incompatibilities in the API</source>
          <target state="translated">8.3 &amp;ndash; API의 비 호환성</target>
        </trans-unit>
        <trans-unit id="d31e9eb94987aca4e6da693733376a5662dabd38" translate="yes" xml:space="preserve">
          <source>9 &amp;ndash; The Complete Syntax of Lua</source>
          <target state="translated">9 &amp;ndash; 루아의 완전한 문법</target>
        </trans-unit>
        <trans-unit id="81d3ce176f56748de5e1f64f56afa6b88a0919fc" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#lua_getlocal&quot;&gt;&lt;code&gt;lua_getlocal&lt;/code&gt;&lt;/a&gt; pushes the variable's value onto the stack and returns its name.</source>
          <target state="translated">&lt;a href=&quot;#lua_getlocal&quot;&gt; &lt;code&gt;lua_getlocal&lt;/code&gt; &lt;/a&gt; 은 변수의 값을 스택으로 푸시하고 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="997a4ac3078b35c85f1fb0a338e5857990690995" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;#pdf-LUA_ERRGCMM&quot;&gt;&lt;code&gt;LUA_ERRGCMM&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; error while running a &lt;code&gt;__gc&lt;/code&gt; metamethod. (This error has no relation with the chunk being loaded. It is generated by the garbage collector.)</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;#pdf-LUA_ERRGCMM&quot;&gt; &lt;code&gt;LUA_ERRGCMM&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt; &lt;code&gt;__gc&lt;/code&gt; 메타 메소드를 실행하는 동안 오류가 발생했습니다. (이 오류는로드중인 청크와 관련이 없습니다. 가비지 수집기에서 생성됩니다.)</target>
        </trans-unit>
        <trans-unit id="0a62e7bf056e6b28156f4c231057917eae3f721a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;#pdf-LUA_ERRMEM&quot;&gt;&lt;code&gt;LUA_ERRMEM&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; memory allocation (out-of-memory) error;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;#pdf-LUA_ERRMEM&quot;&gt; &lt;code&gt;LUA_ERRMEM&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;메모리 할당 (메모리 부족) 오류;</target>
        </trans-unit>
        <trans-unit id="bb87b0a3626f8ed024c6ec50e4a5a62da84f1ba0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;#pdf-LUA_OK&quot;&gt;&lt;code&gt;LUA_OK&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; no errors;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;#pdf-LUA_OK&quot;&gt; &lt;code&gt;LUA_OK&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;오류가 없습니다.</target>
        </trans-unit>
        <trans-unit id="39a5a19fe9e5d2de47a8c090156531e8d630b23d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_ERRERR&quot;&gt;&lt;code&gt;LUA_ERRERR&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; error while running the message handler.</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_ERRERR&quot;&gt; &lt;code&gt;LUA_ERRERR&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;메시지 핸들러를 실행하는 중 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="2e1a636b6f8349496df60024fcc170dc0d04074e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_ERRFILE&quot;&gt;&lt;code&gt;LUA_ERRFILE&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; a file-related error; e.g., it cannot open or read the file.</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_ERRFILE&quot;&gt; &lt;code&gt;LUA_ERRFILE&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;파일 관련 오류; 예를 들어, 파일을 열거 나 읽을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="58785899340ce91e0de9aca15120aa7cff3c9758" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_ERRGCMM&quot;&gt;&lt;code&gt;LUA_ERRGCMM&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; error while running a &lt;code&gt;__gc&lt;/code&gt; metamethod. For such errors, Lua does not call the message handler (as this kind of error typically has no relation with the function being called).</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_ERRGCMM&quot;&gt; &lt;code&gt;LUA_ERRGCMM&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt; &lt;code&gt;__gc&lt;/code&gt; 메타 메소드를 실행하는 동안 오류가 발생했습니다. 이러한 오류의 경우 Lua는 메시지 핸들러를 호출하지 않습니다 (이러한 종류의 오류는 일반적으로 호출되는 함수와 관련이 없으므로).</target>
        </trans-unit>
        <trans-unit id="0513936f3247fabebe04e7758e5c7c600069b199" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_ERRMEM&quot;&gt;&lt;code&gt;LUA_ERRMEM&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; memory allocation error. For such errors, Lua does not call the message handler.</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_ERRMEM&quot;&gt; &lt;code&gt;LUA_ERRMEM&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;메모리 할당 에러. 이러한 오류의 경우 Lua는 메시지 핸들러를 호출하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6d5a47c8aea539962fb70e275409743f8d4b5c7d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_ERRRUN&quot;&gt;&lt;code&gt;LUA_ERRRUN&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; a runtime error.</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_ERRRUN&quot;&gt; &lt;code&gt;LUA_ERRRUN&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;런타임 오류.</target>
        </trans-unit>
        <trans-unit id="58a8a6fac9b491348f1457d76858314d9b3fa87d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_ERRSYNTAX&quot;&gt;&lt;code&gt;LUA_ERRSYNTAX&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; syntax error during precompilation.</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_ERRSYNTAX&quot;&gt; &lt;code&gt;LUA_ERRSYNTAX&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;사전 컴파일 중에 구문 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="d3a51e900c7e297ae9668bf44b0828218aa58bb0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_ERRSYNTAX&quot;&gt;&lt;code&gt;LUA_ERRSYNTAX&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; syntax error during precompilation;</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_ERRSYNTAX&quot;&gt; &lt;code&gt;LUA_ERRSYNTAX&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;사전 컴파일 중 구문 오류;</target>
        </trans-unit>
        <trans-unit id="e602ebe4fcc62dd82a2561a804720e795fd118fe" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_OK&quot;&gt;&lt;code&gt;LUA_OK&lt;/code&gt;&lt;/a&gt; (0): &lt;/b&gt; no errors.</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_OK&quot;&gt; &lt;code&gt;LUA_OK&lt;/code&gt; &lt;/a&gt; (0) :&lt;/b&gt;오류가 없습니다.</target>
        </trans-unit>
        <trans-unit id="069ddb6d3068bf3edc5b7f77df2372cab0d8f9ef" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_OK&quot;&gt;&lt;code&gt;LUA_OK&lt;/code&gt;&lt;/a&gt; (0): &lt;/b&gt; success.</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_OK&quot;&gt; &lt;code&gt;LUA_OK&lt;/code&gt; &lt;/a&gt; (0) :&lt;/b&gt;성공.</target>
        </trans-unit>
        <trans-unit id="3ec3be0613ea3827ce544ed885c9f84ec41464e1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPADD&quot;&gt;&lt;code&gt;LUA_OPADD&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; performs addition (&lt;code&gt;+&lt;/code&gt;)</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPADD&quot;&gt; &lt;code&gt;LUA_OPADD&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;더하기 ( &lt;code&gt;+&lt;/code&gt; )를수행합니다</target>
        </trans-unit>
        <trans-unit id="6c814447a9527d908c1ce86da63fcae3cd57025f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPBAND&quot;&gt;&lt;code&gt;LUA_OPBAND&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; performs bitwise AND (&lt;code&gt;&amp;amp;&lt;/code&gt;)</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPBAND&quot;&gt; &lt;code&gt;LUA_OPBAND&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;비트 AND ( &lt;code&gt;&amp;amp;&lt;/code&gt; )수행</target>
        </trans-unit>
        <trans-unit id="b84c3f3596e3f23015f094f8174ece0ce3d795e1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPBNOT&quot;&gt;&lt;code&gt;LUA_OPBNOT&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; performs bitwise NOT (&lt;code&gt;~&lt;/code&gt;)</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPBNOT&quot;&gt; &lt;code&gt;LUA_OPBNOT&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;비트 NOT 수행 ( &lt;code&gt;~&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="aa756b6d2d7eef20df16036a246330397dc748b4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPBOR&quot;&gt;&lt;code&gt;LUA_OPBOR&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; performs bitwise OR (&lt;code&gt;|&lt;/code&gt;)</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPBOR&quot;&gt; &lt;code&gt;LUA_OPBOR&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;비트 OR ( &lt;code&gt;|&lt;/code&gt; )을수행</target>
        </trans-unit>
        <trans-unit id="cadd32314c831b1dd6807904ee89f82906c6a5d7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPBXOR&quot;&gt;&lt;code&gt;LUA_OPBXOR&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; performs bitwise exclusive OR (&lt;code&gt;~&lt;/code&gt;)</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPBXOR&quot;&gt; &lt;code&gt;LUA_OPBXOR&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;비트 배타적 OR 수행 ( &lt;code&gt;~&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="0120c4dc4899ecd53a28bb0567448d1dfc295a55" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPDIV&quot;&gt;&lt;code&gt;LUA_OPDIV&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; performs float division (&lt;code&gt;/&lt;/code&gt;)</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPDIV&quot;&gt; &lt;code&gt;LUA_OPDIV&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;float 나누기 수행 ( &lt;code&gt;/&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="297add48d11993decc4e07fa953033476d1943cc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPEQ&quot;&gt;&lt;code&gt;LUA_OPEQ&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; compares for equality (&lt;code&gt;==&lt;/code&gt;)</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPEQ&quot;&gt; &lt;code&gt;LUA_OPEQ&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;평등을 비교합니다 ( &lt;code&gt;==&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="6ad36382d905550ab53f7c8b67e61d620b311419" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPIDIV&quot;&gt;&lt;code&gt;LUA_OPIDIV&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; performs floor division (&lt;code&gt;//&lt;/code&gt;)</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPIDIV&quot;&gt; &lt;code&gt;LUA_OPIDIV&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;층 나누기 수행 ( &lt;code&gt;//&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="65b04a9f94a548d3eb547be608241aacea9320cb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPLE&quot;&gt;&lt;code&gt;LUA_OPLE&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; compares for less or equal (&lt;code&gt;&amp;lt;=&lt;/code&gt;)</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPLE&quot;&gt; &lt;code&gt;LUA_OPLE&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;작거나 같음 비교 ( &lt;code&gt;&amp;lt;=&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="475bd49677a764ed78bc57bf43886acf09d7bdab" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPLT&quot;&gt;&lt;code&gt;LUA_OPLT&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; compares for less than (&lt;code&gt;&amp;lt;&lt;/code&gt;)</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPLT&quot;&gt; &lt;code&gt;LUA_OPLT&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;보다 작은 ( &lt;code&gt;&amp;lt;&lt;/code&gt; )비교</target>
        </trans-unit>
        <trans-unit id="d59eb3b1ef4b950e8399516c5f783e0f11e809c4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPMOD&quot;&gt;&lt;code&gt;LUA_OPMOD&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; performs modulo (&lt;code&gt;%&lt;/code&gt;)</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPMOD&quot;&gt; &lt;code&gt;LUA_OPMOD&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;모듈로 수행 ( &lt;code&gt;%&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="3be2f129960c9b22d8bed03fc870c9ddeb0d44a1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPMUL&quot;&gt;&lt;code&gt;LUA_OPMUL&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; performs multiplication (&lt;code&gt;*&lt;/code&gt;)</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPMUL&quot;&gt; &lt;code&gt;LUA_OPMUL&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;곱셈을 수행합니다 ( &lt;code&gt;*&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="0df86847b8617d3071f5659dea048400514522e5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPPOW&quot;&gt;&lt;code&gt;LUA_OPPOW&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; performs exponentiation (&lt;code&gt;^&lt;/code&gt;)</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPPOW&quot;&gt; &lt;code&gt;LUA_OPPOW&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;지수화를 수행합니다 ( &lt;code&gt;^&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="5d397dbd765f0534ad52cb6ff558ee4e7202a360" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPSHL&quot;&gt;&lt;code&gt;LUA_OPSHL&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; performs left shift (&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;)</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPSHL&quot;&gt; &lt;code&gt;LUA_OPSHL&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;왼쪽 이동 ( &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; )을수행합니다</target>
        </trans-unit>
        <trans-unit id="a57f78cb55bc79c59850850886b07440785fc250" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPSHR&quot;&gt;&lt;code&gt;LUA_OPSHR&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; performs right shift (&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;)</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPSHR&quot;&gt; &lt;code&gt;LUA_OPSHR&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;오른쪽 이동을 수행합니다 ( &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5a256a2902d1801dfd4b235ec7de48d549ccf5af" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPSUB&quot;&gt;&lt;code&gt;LUA_OPSUB&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; performs subtraction (&lt;code&gt;-&lt;/code&gt;)</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPSUB&quot;&gt; &lt;code&gt;LUA_OPSUB&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;빼기 수행 ( &lt;code&gt;-&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="0079ed2e4b11f9492f31692fe85400731bec09ed" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPUNM&quot;&gt;&lt;code&gt;LUA_OPUNM&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; performs mathematical negation (unary &lt;code&gt;-&lt;/code&gt;)</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_OPUNM&quot;&gt; &lt;code&gt;LUA_OPUNM&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;수학 부정을 수행합니다 (단항 &lt;code&gt;-&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="490be7142f1b450637c62dce5134a58b5b7cd4c9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_RIDX_GLOBALS&quot;&gt;&lt;code&gt;LUA_RIDX_GLOBALS&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; At this index the registry has the global environment.</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_RIDX_GLOBALS&quot;&gt; &lt;code&gt;LUA_RIDX_GLOBALS&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;이 인덱스에서 레지스트리는 글로벌 환경을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="67692b9acd7ece42dccee1c401f83f0322c87845" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_RIDX_MAINTHREAD&quot;&gt;&lt;code&gt;LUA_RIDX_MAINTHREAD&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; At this index the registry has the main thread of the state. (The main thread is the one created together with the state.)</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_RIDX_MAINTHREAD&quot;&gt; &lt;code&gt;LUA_RIDX_MAINTHREAD&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;이 인덱스에서 레지스트리의 상태는 주 스레드입니다. (주 스레드는 상태와 함께 생성 된 스레드입니다.)</target>
        </trans-unit>
        <trans-unit id="ac448ccff5635b14399d2d3bc060876d6ff12d0e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a id=&quot;pdf-LUA_YIELD&quot;&gt;&lt;code&gt;LUA_YIELD&lt;/code&gt;&lt;/a&gt;: &lt;/b&gt; the thread (coroutine) yields.</source>
          <target state="translated">&lt;b&gt;&lt;a id=&quot;pdf-LUA_YIELD&quot;&gt; &lt;code&gt;LUA_YIELD&lt;/code&gt; &lt;/a&gt; :&lt;/b&gt;스레드 (코 루틴)가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="a2feee941513a97c61affb953f6826a6da14e6b5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;em&gt;number&lt;/em&gt;: &lt;/b&gt; reads a string with up to this number of bytes, returning &lt;b&gt;fail&lt;/b&gt; on end of file. If &lt;code&gt;number&lt;/code&gt; is zero, it reads nothing and returns an empty string, or &lt;b&gt;fail&lt;/b&gt; on end of file.</source>
          <target state="translated">&lt;b&gt;&lt;em&gt;number&lt;/em&gt; :&lt;/b&gt; 최대이 바이트 수의 문자열을 읽고파일 끝에서&lt;b&gt; 실패&lt;/b&gt; 를반환합니다. 경우 &lt;code&gt;number&lt;/code&gt; 제로, 그것은 아무것도 읽지 않습니다 및 빈 문자열을 반환하거나&lt;b&gt; 실패 할&lt;/b&gt; 파일의 끝에.</target>
        </trans-unit>
        <trans-unit id="3ad03bfffa23a0e90024b5cb186d8482335efd71" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;em&gt;number&lt;/em&gt;: &lt;/b&gt; reads a string with up to this number of bytes, returning &lt;b&gt;nil&lt;/b&gt; on end of file. If &lt;code&gt;number&lt;/code&gt; is zero, it reads nothing and returns an empty string, or &lt;b&gt;nil&lt;/b&gt; on end of file.</source>
          <target state="translated">&lt;b&gt;&lt;em&gt;number&lt;/em&gt; :&lt;/b&gt; 이 바이트 수까지의 문자열을 읽고파일 끝에서&lt;b&gt; nil&lt;/b&gt; 을반환합니다. 경우 &lt;code&gt;number&lt;/code&gt; 제로, 그것은 아무것도 반환 빈 문자열, 또는 읽지 않습니다&lt;b&gt; 전무&lt;/b&gt; 파일의 끝을.</target>
        </trans-unit>
        <trans-unit id="2a0c3c0bea2d7e7832082339aece729a1babeddb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;em&gt;x&lt;/em&gt;: &lt;/b&gt; (where &lt;em&gt;x&lt;/em&gt; is not one of the &lt;em&gt;magic characters&lt;/em&gt;&lt;code&gt;^$()%.[]*+-?&lt;/code&gt;) represents the character &lt;em&gt;x&lt;/em&gt; itself.</source>
          <target state="translated">&lt;b&gt;&lt;em&gt;x&lt;/em&gt; :&lt;/b&gt; (여기서&lt;em&gt; x&lt;/em&gt; 는&lt;em&gt; 마법 문자 &lt;/em&gt; &lt;code&gt;^$()%.[]*+-?&lt;/code&gt; )중 하나가 아닙니다 . 문자&lt;em&gt; x&lt;/em&gt; 자체를나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3d2c4186a84e56cd4d03c088b58a9fb64d00944f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;The call hook: &lt;/b&gt; is called when the interpreter calls a function. The hook is called just after Lua enters the new function, before the function gets its arguments.</source>
          <target state="translated">&lt;b&gt;호출 후크 :&lt;/b&gt; 는 인터프리터가 함수를 호출 할 때 호출됩니다. 후크는 함수가 인수를 얻기 전에 Lua가 새 함수를 시작한 직후에 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="4c319abdad8a73bd491f05a87214f3722450c090" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;The call hook: &lt;/b&gt; is called when the interpreter calls a function. The hook is called just after Lua enters the new function.</source>
          <target state="translated">&lt;b&gt;호출 후크 :&lt;/b&gt; 인터프리터가 함수를 호출 할 때 호출됩니다. 후크는 Lua가 새 함수에 들어간 직후에 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="3586bc19f491f63ef8c6fbe8267e796599c9d56a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;The count hook: &lt;/b&gt; is called after the interpreter executes every &lt;code&gt;count&lt;/code&gt; instructions. (This event only happens while Lua is executing a Lua function.)</source>
          <target state="translated">&lt;b&gt;카운트 훅 :&lt;/b&gt; 인터프리터가 모든 &lt;code&gt;count&lt;/code&gt; 명령을 실행 한 후에 호출 됩니다. (이 이벤트는 Lua가 Lua 기능을 실행하는 동안에 만 발생합니다.)</target>
        </trans-unit>
        <trans-unit id="e9aa0abd3e3bccd6db88de7e1964c72d9f0dd91f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;The count hook: &lt;/b&gt; is called after the interpreter executes every &lt;code&gt;count&lt;/code&gt; instructions. This event only happens while Lua is executing a Lua function.</source>
          <target state="translated">&lt;b&gt;카운트 후크 :&lt;/b&gt; 인터프리터가 모든 &lt;code&gt;count&lt;/code&gt; 명령을 실행 한 후에 호출 됩니다. 이 이벤트는 Lua가 Lua 함수를 실행하는 동안에 만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="dc132bdb212730eeb73d3b168b816f3020c8283b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;The line hook: &lt;/b&gt; is called when the interpreter is about to start the execution of a new line of code, or when it jumps back in the code (even to the same line). (This event only happens while Lua is executing a Lua function.)</source>
          <target state="translated">&lt;b&gt;line hook :&lt;/b&gt; 은 인터프리터가 새로운 코드 라인의 실행을 시작하려고 할 때 또는 코드에서 같은 라인으로 되돌아 갈 때 호출됩니다. (이 이벤트는 Lua가 Lua 기능을 실행하는 동안에 만 발생합니다.)</target>
        </trans-unit>
        <trans-unit id="a2cc484b73c504ec047ff5fbcd11d9342d2ef6ba" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;The line hook: &lt;/b&gt; is called when the interpreter is about to start the execution of a new line of code, or when it jumps back in the code (even to the same line). This event only happens while Lua is executing a Lua function.</source>
          <target state="translated">&lt;b&gt;줄 후크 :&lt;/b&gt; 인터프리터가 새 코드 줄의 실행을 시작하려고 할 때 또는 코드에서 다시 점프 할 때 (동일한 줄로도) 호출됩니다. 이 이벤트는 Lua가 Lua 함수를 실행하는 동안에 만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e8d7e12d9066d079bc460e5455e6a25ab434678d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;The return hook: &lt;/b&gt; is called when the interpreter returns from a function. The hook is called just before Lua leaves the function.</source>
          <target state="translated">&lt;b&gt;리턴 후크 :&lt;/b&gt; 인터프리터가 함수에서 리턴 할 때 호출됩니다. 후크는 Lua가 함수를 떠나기 직전에 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="b0512dd920d52edfa2ad49b9db0251dfbc206479" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;The return hook: &lt;/b&gt; is called when the interpreter returns from a function. The hook is called just before Lua leaves the function. There is no standard way to access the values to be returned by the function.</source>
          <target state="translated">&lt;b&gt;리턴 후크 :&lt;/b&gt; 는 인터프리터가 함수에서 리턴 할 때 호출됩니다. 루아가 함수를 떠나기 직전에 후크가 호출됩니다. 함수가 리턴 할 값에 액세스하는 표준 방법은 없습니다.</target>
        </trans-unit>
        <trans-unit id="8805e2bcd652fa518016fd2d76cf56a7869fb8f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;![&lt;em&gt;n&lt;/em&gt;]&lt;/code&gt;: sets maximum alignment to &lt;code&gt;n&lt;/code&gt; (default is native alignment)</source>
          <target state="translated">&lt;code&gt;![&lt;em&gt;n&lt;/em&gt;]&lt;/code&gt; : 최대 정렬을 &lt;code&gt;n&lt;/code&gt; 으로 설정합니다 (기본값은 기본 정렬).</target>
        </trans-unit>
        <trans-unit id="3acec99eacd1af7f2ca649aaae893e3003aadfa5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%&lt;/code&gt;: modulo</source>
          <target state="translated">&lt;code&gt;%&lt;/code&gt; : 모듈로</target>
        </trans-unit>
        <trans-unit id="6309f6de64785e493ad21fb0175b5bdc8f6ad525" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%&lt;em&gt;n&lt;/em&gt;&lt;/code&gt;, for &lt;em&gt;n&lt;/em&gt; between 1 and 9; such item matches a substring equal to the &lt;em&gt;n&lt;/em&gt;-th captured string (see below);</source>
          <target state="translated">&lt;code&gt;%&lt;em&gt;n&lt;/em&gt;&lt;/code&gt; 에 대한 &lt;em&gt;N&lt;/em&gt; 1과 9 사이; 이러한 항목은 &lt;em&gt;n&lt;/em&gt; 번째 캡처 문자열 과 동일한 하위 문자열과 일치 합니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="3290eeaf448255438e96d55704c2f0da23661d04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%&lt;em&gt;x&lt;/em&gt;&lt;/code&gt;:  (where &lt;em&gt;x&lt;/em&gt; is any non-alphanumeric character) represents the character &lt;em&gt;x&lt;/em&gt;. This is the standard way to escape the magic characters. Any non-alphanumeric character (including all punctuation characters, even the non-magical) can be preceded by a '&lt;code&gt;%&lt;/code&gt;' to represent itself in a pattern.</source>
          <target state="translated">&lt;code&gt;%&lt;em&gt;x&lt;/em&gt;&lt;/code&gt; : ( &lt;em&gt;x&lt;/em&gt; 는 영숫자가 아닌 문자) 문자 &lt;em&gt;x를&lt;/em&gt; 나타냅니다 . 이것은 마법 캐릭터를 탈출하는 표준 방법입니다. 영숫자가 아닌 문자 (모든 구두점 문자 포함, 마법이 아닌 문자 포함) 앞에는 ' &lt;code&gt;%&lt;/code&gt; '를 붙여 패턴에서 자신을 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f20e837008e6cbff5b2ce584f8dd66b1ebff0267" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%&lt;em&gt;x&lt;/em&gt;&lt;/code&gt;:  (where &lt;em&gt;x&lt;/em&gt; is any non-alphanumeric character) represents the character &lt;em&gt;x&lt;/em&gt;. This is the standard way to escape the magic characters. Any non-alphanumeric character (including all punctuation characters, even the non-magical) can be preceded by a '&lt;code&gt;%&lt;/code&gt;' when used to represent itself in a pattern.</source>
          <target state="translated">&lt;code&gt;%&lt;em&gt;x&lt;/em&gt;&lt;/code&gt; : (여기서 &lt;em&gt;x&lt;/em&gt; 는 영숫자가 아닌 문자 임)는 문자 &lt;em&gt;x를&lt;/em&gt; 나타냅니다 . 마법 캐릭터를 탈출하는 표준 방법입니다. 영숫자가 아닌 문자 (모든 문장 부호 문자, 마법이 아닌 문자 포함) 앞에는 패턴에서 자신을 나타내는 데 사용될 때 ' &lt;code&gt;%&lt;/code&gt; '가 올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e54e56bd80af5958ec4c201065fe5778f27f86df" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%a&lt;/code&gt;:  represents all letters.</source>
          <target state="translated">&lt;code&gt;%a&lt;/code&gt; : 모든 문자를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="cbfe0af04bd3d02f8310cc2561a3ed583449532b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%b&lt;em&gt;xy&lt;/em&gt;&lt;/code&gt;, where &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;y&lt;/em&gt; are two distinct characters; such item matches strings that start with &lt;em&gt;x&lt;/em&gt;, end with &lt;em&gt;y&lt;/em&gt;, and where the &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;y&lt;/em&gt; are &lt;em&gt;balanced&lt;/em&gt;. This means that, if one reads the string from left to right, counting &lt;em&gt;+1&lt;/em&gt; for an &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;-1&lt;/em&gt; for a &lt;em&gt;y&lt;/em&gt;, the ending &lt;em&gt;y&lt;/em&gt; is the first &lt;em&gt;y&lt;/em&gt; where the count reaches 0. For instance, the item &lt;code&gt;%b()&lt;/code&gt; matches expressions with balanced parentheses.</source>
          <target state="translated">&lt;code&gt;%b&lt;em&gt;xy&lt;/em&gt;&lt;/code&gt; . 여기서 &lt;em&gt;x&lt;/em&gt; 와 &lt;em&gt;y&lt;/em&gt; 는 두 개의 고유 한 문자입니다. 이러한 항목은 문자열로 시작 일치 &lt;em&gt;X&lt;/em&gt; 와 단부 &lt;em&gt;Y&lt;/em&gt; 및 여기서 &lt;em&gt;X를&lt;/em&gt; 및 &lt;em&gt;Y가&lt;/em&gt; 되어 &lt;em&gt;균형&lt;/em&gt; . 카운팅, 왼쪽에서 오른쪽으로 한 문자열을 판독하는 경우,이 방법 &lt;em&gt;+1&lt;/em&gt; 대한 &lt;em&gt;X&lt;/em&gt; 및 &lt;em&gt;-1&lt;/em&gt; A에 대한 &lt;em&gt;Y&lt;/em&gt; , 종료 &lt;em&gt;Y가&lt;/em&gt; 최초로 &lt;em&gt;Y&lt;/em&gt; 카운트가 예를 들어 0에 도달 항목 &lt;code&gt;%b()&lt;/code&gt; 일치 괄호가있는 표현.</target>
        </trans-unit>
        <trans-unit id="3de9b6ffd559dcc163f65726d138b7349ce95ff4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%c&lt;/code&gt;:  represents all control characters.</source>
          <target state="translated">&lt;code&gt;%c&lt;/code&gt; : 모든 제어 문자를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b8ad684e3be8e7587d3c8ce155f426f377443ed6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%d&lt;/code&gt;:  represents all digits.</source>
          <target state="translated">&lt;code&gt;%d&lt;/code&gt; : 모든 숫자를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a6f3e3f52646f53a60bfe00b2ff656a09e89a4a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%f[&lt;em&gt;set&lt;/em&gt;]&lt;/code&gt;, a &lt;em&gt;frontier pattern&lt;/em&gt;; such item matches an empty string at any position such that the next character belongs to &lt;em&gt;set&lt;/em&gt; and the previous character does not belong to &lt;em&gt;set&lt;/em&gt;. The set &lt;em&gt;set&lt;/em&gt; is interpreted as previously described. The beginning and the end of the subject are handled as if they were the character '&lt;code&gt;\0&lt;/code&gt;'.</source>
          <target state="translated">&lt;code&gt;%f[&lt;em&gt;set&lt;/em&gt;]&lt;/code&gt; 하는 &lt;em&gt;프런티어 패턴&lt;/em&gt; ; 이러한 항목은 다음 문자가 &lt;em&gt;set에&lt;/em&gt; 속 하고 이전 문자가 &lt;em&gt;set에&lt;/em&gt; 속하지 않는 임의의 위치에서 빈 문자열과 일치합니다 . 세트 &lt;em&gt;세트&lt;/em&gt; 는 전술 한 바와 같이 해석된다. 제목의 시작과 끝은 마치 문자 ' &lt;code&gt;\0&lt;/code&gt; '인 것처럼 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="d1068a849784cb8f30e250147da15aaa395b0729" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%g&lt;/code&gt;:  represents all printable characters except space.</source>
          <target state="translated">&lt;code&gt;%g&lt;/code&gt; : 공백을 제외한 모든 인쇄 가능한 문자를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b46f710e58e77aaa525ff9403405ff161c474587" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%l&lt;/code&gt;:  represents all lowercase letters.</source>
          <target state="translated">&lt;code&gt;%l&lt;/code&gt; : 모든 소문자를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="00faa1ce628bd5bbd5ebfc1430bf64ce8032b2e9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%p&lt;/code&gt;:  represents all punctuation characters.</source>
          <target state="translated">&lt;code&gt;%p&lt;/code&gt; : 모든 문장 부호 문자를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="409154041b5a8377f4c4a43f5e7a2daca1efae16" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%s&lt;/code&gt;:  represents all space characters.</source>
          <target state="translated">&lt;code&gt;%s&lt;/code&gt; : 모든 공백 문자를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1d077077eba594eeb532db5bbbb344383bb9dc30" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%u&lt;/code&gt;:  represents all uppercase letters.</source>
          <target state="translated">&lt;code&gt;%u&lt;/code&gt; : 모든 대문자를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c778e1666515254950019edcc8b53bc7994b2c06" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%w&lt;/code&gt;:  represents all alphanumeric characters.</source>
          <target state="translated">&lt;code&gt;%w&lt;/code&gt; : 모든 영숫자를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9d32033a43bf5e4d6d3a33f3c31f104d598f06a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;%x&lt;/code&gt;:  represents all hexadecimal digits.</source>
          <target state="translated">&lt;code&gt;%x&lt;/code&gt; : 모든 16 진수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="321eb4eafd66d05c141a030945ca6e42e18477a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;amp;&lt;/code&gt;: bitwise AND</source>
          <target state="translated">&lt;code&gt;&amp;amp;&lt;/code&gt; : 비트 AND</target>
        </trans-unit>
        <trans-unit id="8997dce827f9650de2681505f986bfe4f56868cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;: right shift</source>
          <target state="translated">&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; : 오른쪽 교대</target>
        </trans-unit>
        <trans-unit id="09075062c64c86a8670a7f150b47a6e95e038431" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;&lt;/code&gt;: greater than</source>
          <target state="translated">&lt;code&gt;&amp;gt;&lt;/code&gt; :보다 큼</target>
        </trans-unit>
        <trans-unit id="4cf6b41db6ebd22069687677e294b12324a1aa22" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;&lt;/code&gt;: sets big endian</source>
          <target state="translated">&lt;code&gt;&amp;gt;&lt;/code&gt; : 빅 엔디안 설정</target>
        </trans-unit>
        <trans-unit id="84aa2a09e22da5344a9e8eb1d63a625c2e6ab9d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;=&lt;/code&gt;: greater or equal</source>
          <target state="translated">&lt;code&gt;&amp;gt;=&lt;/code&gt; : 크거나 같음</target>
        </trans-unit>
        <trans-unit id="e1e0a0e88d4b268783cec444b7830a1c8a905396" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;: left shift</source>
          <target state="translated">&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; : 왼쪽 시프트</target>
        </trans-unit>
        <trans-unit id="64760ee63a8e109d429eec539c3225463668a5c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;&lt;/code&gt;: less than</source>
          <target state="translated">&lt;code&gt;&amp;lt;&lt;/code&gt; :보다 작음</target>
        </trans-unit>
        <trans-unit id="0dc1199995acf8e834d1133c3d0ffe757a0c8c59" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;&lt;/code&gt;: sets little endian</source>
          <target state="translated">&lt;code&gt;&amp;lt;&lt;/code&gt; : 리틀 엔디안 설정</target>
        </trans-unit>
        <trans-unit id="539e9a1a68d56527181e6fda1757b93c7bb90872" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;=&lt;/code&gt;: less or equal</source>
          <target state="translated">&lt;code&gt;&amp;lt;=&lt;/code&gt; : 작거나 같음</target>
        </trans-unit>
        <trans-unit id="d93e49b81b005f7b70f3e457112527bfdf5d8afa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;*&lt;/code&gt;: multiplication</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; : 곱셈</target>
        </trans-unit>
        <trans-unit id="5a896065ff143b8d4e4525f134563235b2836309" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;+&lt;/code&gt;: addition</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; : 추가</target>
        </trans-unit>
        <trans-unit id="3f2de6df8bf3e61510642c60648fc03fbc37107e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--&lt;/code&gt;:  stop handling options;</source>
          <target state="translated">&lt;code&gt;--&lt;/code&gt; : 옵션 처리를 중지합니다.</target>
        </trans-unit>
        <trans-unit id="6e690d325ab205c7e3e2edc33dded7238d1e95e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--&lt;/code&gt;:  stops handling options;</source>
          <target state="translated">&lt;code&gt;--&lt;/code&gt; : 옵션 처리를 중지합니다.</target>
        </trans-unit>
        <trans-unit id="3269a145a2cff5a46a814b390d0a3843be9fde31" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-&lt;/code&gt;:  execute &lt;code&gt;stdin&lt;/code&gt; as a file and stop handling options.</source>
          <target state="translated">&lt;code&gt;-&lt;/code&gt; : &lt;code&gt;stdin&lt;/code&gt; 을 파일로 실행 하고 옵션 처리를 중지합니다.</target>
        </trans-unit>
        <trans-unit id="7e30ca421360d9668078533affe3127fefa56922" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-&lt;/code&gt;:  executes &lt;code&gt;stdin&lt;/code&gt; as a file and stops handling options.</source>
          <target state="translated">&lt;code&gt;-&lt;/code&gt; : &lt;code&gt;stdin&lt;/code&gt; 을 파일로 실행 하고 옵션 처리를 중지합니다.</target>
        </trans-unit>
        <trans-unit id="fe732ff63697204d0a3854b3dd684f5776ef0028" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-&lt;/code&gt;: subtraction</source>
          <target state="translated">&lt;code&gt;-&lt;/code&gt; : 빼기</target>
        </trans-unit>
        <trans-unit id="769def5a060686cf3ed3fab103466f33fde9d1c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-&lt;/code&gt;: unary minus</source>
          <target state="translated">&lt;code&gt;-&lt;/code&gt; : 단항 빼기</target>
        </trans-unit>
        <trans-unit id="ce0e53259664648662edb9f1503737097f0dfb02" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-E&lt;/code&gt;:  ignore environment variables;</source>
          <target state="translated">&lt;code&gt;-E&lt;/code&gt; : 환경 변수 무시;</target>
        </trans-unit>
        <trans-unit id="a62c9dea412713fabd70b0572ce384a36c8975a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-E&lt;/code&gt;:  ignores environment variables;</source>
          <target state="translated">&lt;code&gt;-E&lt;/code&gt; : 환경 변수를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="34e7ee380cf18b6c041283d1ffc613935362b02d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-W&lt;/code&gt;:  turn warnings on;</source>
          <target state="translated">&lt;code&gt;-W&lt;/code&gt; : 경고를 켭니다.</target>
        </trans-unit>
        <trans-unit id="e83992f9bd2f910ee3bb40d66f1b26532dbf5cb2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-e &lt;em&gt;stat&lt;/em&gt;&lt;/code&gt;:  execute string &lt;em&gt;stat&lt;/em&gt;;</source>
          <target state="translated">&lt;code&gt;-e &lt;em&gt;stat&lt;/em&gt;&lt;/code&gt; : 문자열 &lt;em&gt;stat&lt;/em&gt; 실행 ;</target>
        </trans-unit>
        <trans-unit id="666a8ef269cc241ff9e08c8b6b13c312ec6e0985" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-e &lt;em&gt;stat&lt;/em&gt;&lt;/code&gt;:  executes string &lt;em&gt;stat&lt;/em&gt;;</source>
          <target state="translated">&lt;code&gt;-e &lt;em&gt;stat&lt;/em&gt;&lt;/code&gt; : 문자열 &lt;em&gt;stat를&lt;/em&gt; 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="c0281012017d3ee240063454fe0e41787c693d52" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-i&lt;/code&gt;:  enter interactive mode after running &lt;em&gt;script&lt;/em&gt;;</source>
          <target state="translated">&lt;code&gt;-i&lt;/code&gt; : &lt;em&gt;스크립트&lt;/em&gt; 실행 후 대화 형 모드로 들어갑니다 .</target>
        </trans-unit>
        <trans-unit id="c08ce0d22173d753a71a183348f5899d3deb6286" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-i&lt;/code&gt;:  enters interactive mode after running &lt;em&gt;script&lt;/em&gt;;</source>
          <target state="translated">&lt;code&gt;-i&lt;/code&gt; : &lt;em&gt;스크립트&lt;/em&gt; 를 실행 한 후 대화식 모드로 들어갑니다 .</target>
        </trans-unit>
        <trans-unit id="974e83278ec05c54db4037ab148d266ad1e44ab2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-l &lt;em&gt;mod&lt;/em&gt;&lt;/code&gt;:  &quot;require&quot; &lt;em&gt;mod&lt;/em&gt; and assign the result to global &lt;em&gt;mod&lt;/em&gt;;</source>
          <target state="translated">&lt;code&gt;-l &lt;em&gt;mod&lt;/em&gt;&lt;/code&gt; : &quot;require&quot; &lt;em&gt;mod&lt;/em&gt; 및 결과를 전역 &lt;em&gt;mod에&lt;/em&gt; 할당합니다 .</target>
        </trans-unit>
        <trans-unit id="dacf10d39c10471335c9d03c807dc8f228a1a26f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-l &lt;em&gt;mod&lt;/em&gt;&lt;/code&gt;:  &quot;requires&quot; &lt;em&gt;mod&lt;/em&gt;;</source>
          <target state="translated">&lt;code&gt;-l &lt;em&gt;mod&lt;/em&gt;&lt;/code&gt; : &quot;필수&quot; &lt;em&gt;mod&lt;/em&gt; ;</target>
        </trans-unit>
        <trans-unit id="48c58ee4c46816c1dbd48ba7285a214760ff3555" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-v&lt;/code&gt;:  print version information;</source>
          <target state="translated">&lt;code&gt;-v&lt;/code&gt; : 버전 정보를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="0bb7b2827bd9676bf04daa9b6241bf4c4b937a87" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-v&lt;/code&gt;:  prints version information;</source>
          <target state="translated">&lt;code&gt;-v&lt;/code&gt; : 버전 정보를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="380d1b565924cf193969bb6016e909adf7faad53" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.&lt;/code&gt;:  (a dot) represents all characters.</source>
          <target state="translated">&lt;code&gt;.&lt;/code&gt; : (점)은 모든 문자를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="29471d9e07752a02a646c75289cc2200ed687ca9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;//&lt;/code&gt;: floor division</source>
          <target state="translated">&lt;code&gt;//&lt;/code&gt; : 층 구분</target>
        </trans-unit>
        <trans-unit id="e74818859a32b3c68f9a537da22031801f01b845" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/&lt;/code&gt;: float division</source>
          <target state="translated">&lt;code&gt;/&lt;/code&gt; : 플로트 나누기</target>
        </trans-unit>
        <trans-unit id="61efe208b861a62c6b51bce3253be1558c21c997" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;em&gt;explist&lt;/em&gt;&lt;/code&gt; is evaluated only once. Its results are an &lt;em&gt;iterator&lt;/em&gt; function, a &lt;em&gt;state&lt;/em&gt;, and an initial value for the first &lt;em&gt;iterator variable&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;em&gt;explist&lt;/em&gt;&lt;/code&gt; 는 한 번만 평가됩니다. 결과는&lt;em&gt; 반복자&lt;/em&gt; 함수,&lt;em&gt; 상태&lt;/em&gt; 및 첫 번째&lt;em&gt; 반복자 변수&lt;/em&gt; 의 초기 값입니다.</target>
        </trans-unit>
        <trans-unit id="02c81725154593faf7b3b3f43b31b6aa30161b7f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;em&gt;f&lt;/em&gt;&lt;/code&gt;, &lt;code&gt;&lt;em&gt;s&lt;/em&gt;&lt;/code&gt;, and &lt;code&gt;&lt;em&gt;var&lt;/em&gt;&lt;/code&gt; are invisible variables. The names are here for explanatory purposes only.</source>
          <target state="translated">&lt;code&gt;&lt;em&gt;f&lt;/em&gt;&lt;/code&gt; , &lt;code&gt;&lt;em&gt;s&lt;/em&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;em&gt;var&lt;/em&gt;&lt;/code&gt; 는 보이지 않는 변수입니다. 이름은 설명 목적으로 만 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="562c795de59069a6c76dd75325349c2fc11e4bf2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&lt;em&gt;var&lt;/em&gt;&lt;/code&gt;, &lt;code&gt;&lt;em&gt;limit&lt;/em&gt;&lt;/code&gt;, and &lt;code&gt;&lt;em&gt;step&lt;/em&gt;&lt;/code&gt; are invisible variables. The names shown here are for explanatory purposes only.</source>
          <target state="translated">&lt;code&gt;&lt;em&gt;var&lt;/em&gt;&lt;/code&gt; , &lt;code&gt;&lt;em&gt;limit&lt;/em&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;em&gt;step&lt;/em&gt;&lt;/code&gt; 은 보이지 않는 변수입니다. 여기에 표시된 이름은 설명을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="2f71e0d38e440115b80b8062b2667073a2b99d24" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;=&lt;/code&gt;: sets native endian</source>
          <target state="translated">&lt;code&gt;=&lt;/code&gt; : 네이티브 엔디안을 설정합니다</target>
        </trans-unit>
        <trans-unit id="0a197dcb32b592a6117175ac588ba58ade78518a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;==&lt;/code&gt;: equality</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; : 평등</target>
        </trans-unit>
        <trans-unit id="751cff1d44a9460c79c1d8247a3762226d5dc596" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;B&lt;/code&gt;: an unsigned byte (&lt;code&gt;char&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;B&lt;/code&gt; : 부호없는 바이트 ( &lt;code&gt;char&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="78939819671012d7b27e3304caefff90a2896e05" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;H&lt;/code&gt;: an unsigned &lt;code&gt;short&lt;/code&gt; (native size)</source>
          <target state="translated">&lt;code&gt;H&lt;/code&gt; : 부호없는 &lt;code&gt;short&lt;/code&gt; (기본 크기)</target>
        </trans-unit>
        <trans-unit id="7b789f63dd50ed7c3fda6b86e141977ab88fef74" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;I[&lt;em&gt;n&lt;/em&gt;]&lt;/code&gt;: an unsigned &lt;code&gt;int&lt;/code&gt; with &lt;code&gt;n&lt;/code&gt; bytes (default is native size)</source>
          <target state="translated">&lt;code&gt;I[&lt;em&gt;n&lt;/em&gt;]&lt;/code&gt; : 부호없는 &lt;code&gt;int&lt;/code&gt; 와 &lt;code&gt;n&lt;/code&gt; 바이트 (기본값은 기본 크기)</target>
        </trans-unit>
        <trans-unit id="fb9847bb7bda0dddeaa7102eb5ff82fef56363b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;J&lt;/code&gt;: a &lt;code&gt;lua_Unsigned&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;J&lt;/code&gt; : &lt;code&gt;lua_Unsigned&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="684450a0b3b1fdd57e3aba433e9b9488eff7d191" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;L&lt;/code&gt;: an unsigned &lt;code&gt;long&lt;/code&gt; (native size)</source>
          <target state="translated">&lt;code&gt;L&lt;/code&gt; : 부호없는 &lt;code&gt;long&lt;/code&gt; (기본 크기)</target>
        </trans-unit>
        <trans-unit id="27f93600b14adf35d6677fbf15d23ba38ce5ba29" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LUA_GCCOLLECT&lt;/code&gt;:  Performs a full garbage-collection cycle.</source>
          <target state="translated">&lt;code&gt;LUA_GCCOLLECT&lt;/code&gt; : 전체 가비지 수집주기를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="25c78f460ce68a552941c0b856d21bb1212d5c60" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LUA_GCCOLLECT&lt;/code&gt;:  performs a full garbage-collection cycle.</source>
          <target state="translated">&lt;code&gt;LUA_GCCOLLECT&lt;/code&gt; : 전체 가비지 수집주기를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="747500395594c67b24aa557bc180a4e3fe06553d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LUA_GCCOUNT&lt;/code&gt;:  Returns the current amount of memory (in Kbytes) in use by Lua.</source>
          <target state="translated">&lt;code&gt;LUA_GCCOUNT&lt;/code&gt; : Lua에서 사용중인 현재 메모리 양 (KB)을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="feb5e716d218ca16ede442156a2c17fc22562d67" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LUA_GCCOUNT&lt;/code&gt;:  returns the current amount of memory (in Kbytes) in use by Lua.</source>
          <target state="translated">&lt;code&gt;LUA_GCCOUNT&lt;/code&gt; : Lua에서 사용중인 현재 메모리 양 (KB)을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="78a3fcdfc44777c4235848891f60367d73a7240d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LUA_GCCOUNTB&lt;/code&gt;:  Returns the remainder of dividing the current amount of bytes of memory in use by Lua by 1024.</source>
          <target state="translated">&lt;code&gt;LUA_GCCOUNTB&lt;/code&gt; : Lua가 현재 사용중인 메모리 바이트를 1024로 나눈 나머지를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5a68d642e09792078a82b22bae5351cbaac81a3b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LUA_GCCOUNTB&lt;/code&gt;:  returns the remainder of dividing the current amount of bytes of memory in use by Lua by 1024.</source>
          <target state="translated">&lt;code&gt;LUA_GCCOUNTB&lt;/code&gt; : Lua에서 사용중인 현재 메모리 양을 1024로 나눈 나머지를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1371f443b62c18860c20abf0482a2e79e8fde9c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LUA_GCGEN&lt;/code&gt; (int minormul, int majormul):  Changes the collector to generational mode with the given parameters (see &lt;a href=&quot;#2.5.2&quot;&gt;&amp;sect;2.5.2&lt;/a&gt;). Returns the previous mode (&lt;code&gt;LUA_GCGEN&lt;/code&gt; or &lt;code&gt;LUA_GCINC&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;LUA_GCGEN&lt;/code&gt; (int minormul, int majormul) : 지정된 매개 변수를 사용하여 수집기를 생성 모드로 변경합니다 ( &lt;a href=&quot;#2.5.2&quot;&gt;&amp;sect;2.5.2&lt;/a&gt; 참조 ). 이전 모드 ( &lt;code&gt;LUA_GCGEN&lt;/code&gt; 또는 &lt;code&gt;LUA_GCINC&lt;/code&gt; )를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="60be1736f6e7d1a38750674de1bbd08ea5476e7c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LUA_GCINC&lt;/code&gt; (int pause, int stepmul, stepsize):  Changes the collector to incremental mode with the given parameters (see &lt;a href=&quot;#2.5.1&quot;&gt;&amp;sect;2.5.1&lt;/a&gt;). Returns the previous mode (&lt;code&gt;LUA_GCGEN&lt;/code&gt; or &lt;code&gt;LUA_GCINC&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;LUA_GCINC&lt;/code&gt; (int pause, int stepmul, stepsize) : 지정된 매개 변수를 사용하여 수집기를 증분 모드로 변경합니다 ( &lt;a href=&quot;#2.5.1&quot;&gt;&amp;sect;2.5.1&lt;/a&gt; 참조 ). 이전 모드 ( &lt;code&gt;LUA_GCGEN&lt;/code&gt; 또는 &lt;code&gt;LUA_GCINC&lt;/code&gt; )를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c950962077592b2b869b6743823b54de0fe765e5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LUA_GCISRUNNING&lt;/code&gt;:  Returns a boolean that tells whether the collector is running (i.e., not stopped).</source>
          <target state="translated">&lt;code&gt;LUA_GCISRUNNING&lt;/code&gt; : 수집기가 실행 중인지 (즉, 중지되지 않았는지) 알려주는 부울을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="98c1ec01d66de8e0320c4d93348ae60d493d3e9b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LUA_GCISRUNNING&lt;/code&gt;:  returns a boolean that tells whether the collector is running (i.e., not stopped).</source>
          <target state="translated">&lt;code&gt;LUA_GCISRUNNING&lt;/code&gt; : 콜렉터가 실행 중인지 (즉, 중지되지 않았는지) 알려주는 부울을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="435724d252fc7b81107a6fac3397b96d3c576bc0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LUA_GCRESTART&lt;/code&gt;:  Restarts the garbage collector.</source>
          <target state="translated">&lt;code&gt;LUA_GCRESTART&lt;/code&gt; : 가비지 수집기를 다시 시작합니다.</target>
        </trans-unit>
        <trans-unit id="b2278ee01aaa7877800006c384258d197cbdf9bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LUA_GCRESTART&lt;/code&gt;:  restarts the garbage collector.</source>
          <target state="translated">&lt;code&gt;LUA_GCRESTART&lt;/code&gt; : 가비지 수집기를 다시 시작합니다.</target>
        </trans-unit>
        <trans-unit id="fa1ba56a5a60dabda23e38f6db79d5515a2addfb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LUA_GCSETPAUSE&lt;/code&gt;:  sets &lt;code&gt;data&lt;/code&gt; as the new value for the &lt;em&gt;pause&lt;/em&gt; of the collector (see &lt;a href=&quot;#2.5&quot;&gt;&amp;sect;2.5&lt;/a&gt;) and returns the previous value of the pause.</source>
          <target state="translated">&lt;code&gt;LUA_GCSETPAUSE&lt;/code&gt; : 수집기 &lt;em&gt;일시 정지&lt;/em&gt; 에 대한 새 값으로 &lt;code&gt;data&lt;/code&gt; 를 설정 하고 ( &lt;a href=&quot;#2.5&quot;&gt;&amp;sect;2.5&lt;/a&gt; 참조 ) 일시 정지의 이전 값을 리턴합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3b218eaca4b6e9893a3e16aea485fd11554bfd2c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LUA_GCSETSTEPMUL&lt;/code&gt;:  sets &lt;code&gt;data&lt;/code&gt; as the new value for the &lt;em&gt;step multiplier&lt;/em&gt; of the collector (see &lt;a href=&quot;#2.5&quot;&gt;&amp;sect;2.5&lt;/a&gt;) and returns the previous value of the step multiplier.</source>
          <target state="translated">&lt;code&gt;LUA_GCSETSTEPMUL&lt;/code&gt; : 수집기 의 &lt;em&gt;단계 승수&lt;/em&gt; 에 대한 새 값으로 &lt;code&gt;data&lt;/code&gt; 를 설정 하고 ( &lt;a href=&quot;#2.5&quot;&gt;&amp;sect;2.5&lt;/a&gt; 참조 ) 단계 승수의 이전 값을 반환합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1d7e799ac56c4ff839b3019633b438fb825a18fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LUA_GCSTEP&lt;/code&gt;:  performs an incremental step of garbage collection.</source>
          <target state="translated">&lt;code&gt;LUA_GCSTEP&lt;/code&gt; : 가비지 수집의 증분 단계를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="716d69e68a4c7b5d099f467b4dafa98467721c4d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LUA_GCSTEP&lt;/code&gt;&lt;code&gt;(int stepsize)&lt;/code&gt;:  Performs an incremental step of garbage collection, corresponding to the allocation of &lt;code&gt;stepsize&lt;/code&gt; Kbytes.</source>
          <target state="translated">&lt;code&gt;LUA_GCSTEP&lt;/code&gt; &lt;code&gt;(int stepsize)&lt;/code&gt; : 수행합니다 할당에 대응하는 가비지 컬렉션의 증분 단계, &lt;code&gt;stepsize&lt;/code&gt; 킬로바이트.</target>
        </trans-unit>
        <trans-unit id="d3c6ec8067737770140406c5af8d2b5aa1652ec1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LUA_GCSTOP&lt;/code&gt;:  Stops the garbage collector.</source>
          <target state="translated">&lt;code&gt;LUA_GCSTOP&lt;/code&gt; : 가비지 수집기를 중지합니다.</target>
        </trans-unit>
        <trans-unit id="450adac195733dc26043ca23487ff56033910e41" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;LUA_GCSTOP&lt;/code&gt;:  stops the garbage collector.</source>
          <target state="translated">&lt;code&gt;LUA_GCSTOP&lt;/code&gt; : 가비지 수집기를 중지합니다.</target>
        </trans-unit>
        <trans-unit id="03ae56412dd5cb45458646b97dd071be591e5e04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;T&lt;/code&gt;: a &lt;code&gt;size_t&lt;/code&gt; (native size)</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; : &lt;code&gt;size_t&lt;/code&gt; (기본 크기)</target>
        </trans-unit>
        <trans-unit id="0a8a0f3d7f67d7fd79f7990d2b94e59b8a7b4375" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;X&lt;em&gt;op&lt;/em&gt;&lt;/code&gt;: an empty item that aligns according to option &lt;code&gt;op&lt;/code&gt; (which is otherwise ignored)</source>
          <target state="translated">&lt;code&gt;X&lt;em&gt;op&lt;/em&gt;&lt;/code&gt; : 옵션 &lt;code&gt;op&lt;/code&gt; 에 따라 정렬되는 빈 항목 (그렇지 않으면 무시 됨)</target>
        </trans-unit>
        <trans-unit id="6bce72d0d5e32b91f85c07cd8060a5d09dda59ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[&lt;em&gt;set&lt;/em&gt;]&lt;/code&gt;:  represents the class which is the union of all characters in &lt;em&gt;set&lt;/em&gt;. A range of characters can be specified by separating the end characters of the range, in ascending order, with a '&lt;code&gt;-&lt;/code&gt;'. All classes &lt;code&gt;%&lt;/code&gt;&lt;em&gt;x&lt;/em&gt; described above can also be used as components in &lt;em&gt;set&lt;/em&gt;. All other characters in &lt;em&gt;set&lt;/em&gt; represent themselves. For example, &lt;code&gt;[%w_]&lt;/code&gt; (or &lt;code&gt;[_%w]&lt;/code&gt;) represents all alphanumeric characters plus the underscore, &lt;code&gt;[0-7]&lt;/code&gt; represents the octal digits, and &lt;code&gt;[0-7%l%-]&lt;/code&gt; represents the octal digits plus the lowercase letters plus the '&lt;code&gt;-&lt;/code&gt;' character.</source>
          <target state="translated">&lt;code&gt;[&lt;em&gt;set&lt;/em&gt;]&lt;/code&gt; : 모든 문자의 조합이다 클래스 나타냅니다 &lt;em&gt;세트를&lt;/em&gt; . 범위의 끝 문자를 오름차순으로 ' &lt;code&gt;-&lt;/code&gt; ' 로 구분하여 문자 범위를 지정할 수 있습니다 . 위에서 설명한 모든 클래스 &lt;code&gt;%&lt;/code&gt; &lt;em&gt;x&lt;/em&gt; 도 &lt;em&gt;set의&lt;/em&gt; 구성 요소로 사용할 수 있습니다 . &lt;em&gt;세트의&lt;/em&gt; 다른 모든 문자 는 자신을 나타냅니다. 예를 들어 &lt;code&gt;[%w_]&lt;/code&gt; (또는 &lt;code&gt;[_%w]&lt;/code&gt; )는 모든 영숫자 문자와 밑줄, &lt;code&gt;[0-7]&lt;/code&gt; 은 8 진수, &lt;code&gt;[0-7%l%-]&lt;/code&gt; 는 8 진수와 소문자를 나타냅니다. 문자와 ' &lt;code&gt;-&lt;/code&gt; '문자.</target>
        </trans-unit>
        <trans-unit id="2bfa8d127c2e8935e2fff05f79f71c951f40cbb1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[^&lt;em&gt;set&lt;/em&gt;]&lt;/code&gt;:  represents the complement of &lt;em&gt;set&lt;/em&gt;, where &lt;em&gt;set&lt;/em&gt; is interpreted as above.</source>
          <target state="translated">&lt;code&gt;[^&lt;em&gt;set&lt;/em&gt;]&lt;/code&gt; : 보수의 대표 &lt;em&gt;세트&lt;/em&gt; , &lt;em&gt;세트는&lt;/em&gt; 상기와 같이 해석된다.</target>
        </trans-unit>
        <trans-unit id="f38e7d51801e02a7747b20500a8b2e632836efe3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;^&lt;/code&gt;: exponentiation</source>
          <target state="translated">&lt;code&gt;^&lt;/code&gt; : 지수화</target>
        </trans-unit>
        <trans-unit id="f5b98943f5025fa1cf7612c16dfff443caedc2b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__add&lt;/code&gt;:  the addition (&lt;code&gt;+&lt;/code&gt;) operation. If any operand for an addition is not a number (nor a string coercible to a number), Lua will try to call a metamethod. First, Lua will check the first operand (even if it is valid). If that operand does not define a metamethod for &lt;code&gt;__add&lt;/code&gt;, then Lua will check the second operand. If Lua can find a metamethod, it calls the metamethod with the two operands as arguments, and the result of the call (adjusted to one value) is the result of the operation. Otherwise, it raises an error.</source>
          <target state="translated">&lt;code&gt;__add&lt;/code&gt; : 더하기 ( &lt;code&gt;+&lt;/code&gt; ) 연산. 더하기에 대한 피연산자가 숫자가 아닌 경우 (문자열이 숫자로 변환되지 않음) Lua는 메타 메소드를 호출하려고 시도합니다. 먼저 Lua는 첫 번째 피연산자를 확인합니다 (유효한 경우에도). 해당 피연산자가 &lt;code&gt;__add&lt;/code&gt; 의 메타 메소드를 정의하지 않으면 Lua는 두 번째 피연산자를 확인합니다. Lua가 메타 메소드를 찾을 수 있으면 두 피연산자를 인수로 사용하여 메타 메소드를 호출하고 호출 결과 (한 값으로 조정)가 연산의 결과입니다. 그렇지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1b6202fc2a36ce090174d453bc1dc37d30445ac3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__add&lt;/code&gt;:  the addition (&lt;code&gt;+&lt;/code&gt;) operation. If any operand for an addition is not a number, Lua will try to call a metamethod. It starts by checking the first operand (even if it is a number); if that operand does not define a metamethod for &lt;code&gt;__add&lt;/code&gt;, then Lua will check the second operand. If Lua can find a metamethod, it calls the metamethod with the two operands as arguments, and the result of the call (adjusted to one value) is the result of the operation. Otherwise, if no metamethod is found, Lua raises an error.</source>
          <target state="translated">&lt;code&gt;__add&lt;/code&gt; : 더하기 ( &lt;code&gt;+&lt;/code&gt; ) 연산. 덧셈에 대한 피연산자가 숫자가 아닌 경우 Lua는 메타 메서드를 호출하려고합니다. 첫 번째 피연산자를 확인하여 시작합니다 (숫자 인 경우에도). 해당 피연산자가 &lt;code&gt;__add&lt;/code&gt; 에 대한 메타 메서드를 정의하지 않으면 Lua는 두 번째 피연산자를 확인합니다. Lua가 메타 메소드를 찾을 수 있으면 두 피연산자를 인수로 사용하여 메타 메소드를 호출하고 호출 결과 (한 값으로 조정 됨)가 연산의 결과입니다. 그렇지 않고 메타 메서드가 없으면 Lua는 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="18498456a66957bd192a02e96a430d684b766b36" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__band&lt;/code&gt;:  the bitwise AND (&lt;code&gt;&amp;amp;&lt;/code&gt;) operation. Behavior similar to the addition operation, except that Lua will try a metamethod if any operand is neither an integer nor a float coercible to an integer (see &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;__band&lt;/code&gt; : 비트 AND ( &lt;code&gt;&amp;amp;&lt;/code&gt; ) 연산. 피연산자가 정수도 아니고 정수로 강제 변환 할 수없는 경우 Lua가 메타 메소드를 시도한다는 점을 제외하면 더하기 연산과 유사한 동작입니다 ( &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="bda95a3552fcf7eb5fbbb735dac806d610f70311" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__band&lt;/code&gt;:  the bitwise AND (&lt;code&gt;&amp;amp;&lt;/code&gt;) operation. Behavior similar to the addition operation, except that Lua will try a metamethod if any operand is neither an integer nor a value coercible to an integer (see &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;__band&lt;/code&gt; : 비트 AND ( &lt;code&gt;&amp;amp;&lt;/code&gt; ) 연산 피연산자가 정수이거나 정수로 변환 가능한 값이 아닌 경우 루아가 메타 메소드를 시도한다는 점을 제외하고는 덧셈 연산과 유사합니다 ( &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="c8271d8f21a0a60ed616ec9f38e97d661ff31836" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__bnot&lt;/code&gt;:  the bitwise NOT (unary &lt;code&gt;~&lt;/code&gt;) operation. Behavior similar to the bitwise AND operation.</source>
          <target state="translated">&lt;code&gt;__bnot&lt;/code&gt; : 비트 NOT (단항 &lt;code&gt;~&lt;/code&gt; ) 연산. 비트 AND 연산과 유사한 동작입니다.</target>
        </trans-unit>
        <trans-unit id="9e9026d2ac8c089b351feccecbb25019aa6cc74f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__bor&lt;/code&gt;:  the bitwise OR (&lt;code&gt;|&lt;/code&gt;) operation. Behavior similar to the bitwise AND operation.</source>
          <target state="translated">&lt;code&gt;__bor&lt;/code&gt; : 비트 OR ( &lt;code&gt;|&lt;/code&gt; ) 연산 비트 AND 연산과 유사한 동작입니다.</target>
        </trans-unit>
        <trans-unit id="3984b6f7c6542cb91c472a68f850228f86078c2f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__bxor&lt;/code&gt;:  the bitwise exclusive OR (binary &lt;code&gt;~&lt;/code&gt;) operation. Behavior similar to the bitwise AND operation.</source>
          <target state="translated">&lt;code&gt;__bxor&lt;/code&gt; : 비트 배타적 OR (이진 &lt;code&gt;~&lt;/code&gt; ) 연산. 비트 AND 연산과 유사한 동작입니다.</target>
        </trans-unit>
        <trans-unit id="47f84fd28e5003b12c1cddb7e1213ad73677ce7b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__call&lt;/code&gt;:  The call operation &lt;code&gt;func(args)&lt;/code&gt;. This event happens when Lua tries to call a non-function value (that is, &lt;code&gt;func&lt;/code&gt; is not a function). The metamethod is looked up in &lt;code&gt;func&lt;/code&gt;. If present, the metamethod is called with &lt;code&gt;func&lt;/code&gt; as its first argument, followed by the arguments of the original call (&lt;code&gt;args&lt;/code&gt;). All results of the call are the result of the operation. (This is the only metamethod that allows multiple results.)</source>
          <target state="translated">&lt;code&gt;__call&lt;/code&gt; : 호출 작업 &lt;code&gt;func(args)&lt;/code&gt; . 이 이벤트는 Lua가 함수가 아닌 값을 호출하려고 할 때 발생합니다 (즉, &lt;code&gt;func&lt;/code&gt; 는 함수 가 아닙니다). metamethod는 &lt;code&gt;func&lt;/code&gt; 에서 조회됩니다 . 존재하는 경우 metamethod는 &lt;code&gt;func&lt;/code&gt; 를 첫 번째 인수로 호출 한 다음 원래 호출의 인수 ( &lt;code&gt;args&lt;/code&gt; )를 호출 합니다. 호출의 모든 결과는 작업의 결과입니다. (여러 결과를 허용하는 유일한 메타 메소드입니다.)</target>
        </trans-unit>
        <trans-unit id="cc5ab9ce81ff33275f7c4ff325d4c8b1c70cd0ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__call&lt;/code&gt;:  The call operation &lt;code&gt;func(args)&lt;/code&gt;. This event happens when Lua tries to call a non-function value (that is, &lt;code&gt;func&lt;/code&gt; is not a function). The metamethod is looked up in &lt;code&gt;func&lt;/code&gt;. If present, the metamethod is called with &lt;code&gt;func&lt;/code&gt; as its first argument, followed by the arguments of the original call (&lt;code&gt;args&lt;/code&gt;). All results of the call are the results of the operation. This is the only metamethod that allows multiple results.</source>
          <target state="translated">&lt;code&gt;__call&lt;/code&gt; : 호출 연산 &lt;code&gt;func(args)&lt;/code&gt; . 이 이벤트는 Lua가 함수가 아닌 값을 호출하려고 할 때 발생합니다 (즉, &lt;code&gt;func&lt;/code&gt; 가 함수 가 아님). metamethod는 &lt;code&gt;func&lt;/code&gt; 에서 조회됩니다 . 존재하는 경우 메타 메서드는 첫 번째 인수 로 &lt;code&gt;func&lt;/code&gt; 를 사용하여 호출 되고 그 뒤에 원래 호출의 인수 ( &lt;code&gt;args&lt;/code&gt; )가 이어집니다. 호출의 모든 결과는 작업의 결과입니다. 이것은 여러 결과를 허용하는 유일한 메타 메서드입니다.</target>
        </trans-unit>
        <trans-unit id="790454d48e53027f216e2bf64f3530d0774dee89" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__concat&lt;/code&gt;:  the concatenation (&lt;code&gt;..&lt;/code&gt;) operation. Behavior similar to the addition operation, except that Lua will try a metamethod if any operand is neither a string nor a number (which is always coercible to a string).</source>
          <target state="translated">&lt;code&gt;__concat&lt;/code&gt; : 연결 ( &lt;code&gt;..&lt;/code&gt; ) 작업 피연산자가 문자열이나 숫자 (항상 문자열에 강제적 임)가 아닌 경우 루아가 메타 메소드를 시도한다는 점을 제외하고는 덧셈 연산과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="ad91de859a0158bed21ee979ae23cedc031843c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__div&lt;/code&gt;:  the division (&lt;code&gt;/&lt;/code&gt;) operation. Behavior similar to the addition operation.</source>
          <target state="translated">&lt;code&gt;__div&lt;/code&gt; : 나누기 ( &lt;code&gt;/&lt;/code&gt; ) 작업입니다. 덧셈 연산과 유사한 동작.</target>
        </trans-unit>
        <trans-unit id="7344afb47ab39dbb1dcc686092dbb2c33112ca27" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__eq&lt;/code&gt;:  the equal (&lt;code&gt;==&lt;/code&gt;) operation. Behavior similar to the addition operation, except that Lua will try a metamethod only when the values being compared are either both tables or both full userdata and they are not primitively equal. The result of the call is always converted to a boolean.</source>
          <target state="translated">&lt;code&gt;__eq&lt;/code&gt; : 같음 ( &lt;code&gt;==&lt;/code&gt; ) 연산 루아가 비교할 값이 테이블이거나 전체 사용자 데이터이고 기본적으로 동일하지 않은 경우에만 메타 메소드를 시도한다는 점을 제외하고는 덧셈 연산과 유사합니다. 호출 결과는 항상 부울로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="e98db71bbf36f23352f716c30f1f7a8ecfbe62c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__idiv&lt;/code&gt;:  the floor division (&lt;code&gt;//&lt;/code&gt;) operation. Behavior similar to the addition operation.</source>
          <target state="translated">&lt;code&gt;__idiv&lt;/code&gt; : 바닥 구분 ( &lt;code&gt;//&lt;/code&gt; ) 작업입니다. 덧셈 연산과 유사한 동작.</target>
        </trans-unit>
        <trans-unit id="decd7b7eb1b7416a469f2fca59f8e4ddd7f2a85d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__index&lt;/code&gt;:  The indexing access &lt;code&gt;table[key]&lt;/code&gt;. This event happens when &lt;code&gt;table&lt;/code&gt; is not a table or when &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;table&lt;/code&gt;. The metamethod is looked up in &lt;code&gt;table&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;__index&lt;/code&gt; : 인덱싱 액세스 &lt;code&gt;table[key]&lt;/code&gt; . 이 이벤트 는 &lt;code&gt;table&lt;/code&gt; 이 테이블 이 아니거나 &lt;code&gt;key&lt;/code&gt; 가 테이블 에 없을 때 발생 &lt;code&gt;table&lt;/code&gt; . metamethod가 &lt;code&gt;table&lt;/code&gt; 에서 조회됩니다 .</target>
        </trans-unit>
        <trans-unit id="59d5cdb5e9bebf293df5f5c2dd03e9513439b94b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__index&lt;/code&gt;:  The indexing access operation &lt;code&gt;table[key]&lt;/code&gt;. This event happens when &lt;code&gt;table&lt;/code&gt; is not a table or when &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;table&lt;/code&gt;. The metavalue is looked up in the metatable of &lt;code&gt;table&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;__index&lt;/code&gt; : 인덱싱 액세스 작업 &lt;code&gt;table[key]&lt;/code&gt; . 이 이벤트 는 &lt;code&gt;table&lt;/code&gt; 이 테이블 이 아니거나 테이블에 &lt;code&gt;key&lt;/code&gt; 가 없을 때 발생 &lt;code&gt;table&lt;/code&gt; . 메타 값은 &lt;code&gt;table&lt;/code&gt; 의 메타 테이블에서 조회됩니다 .</target>
        </trans-unit>
        <trans-unit id="d0aff1ea5b89de9eaeaf8c0b5dcd3b5677be316c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__le&lt;/code&gt;:  the less equal (&lt;code&gt;&amp;lt;=&lt;/code&gt;) operation. Behavior similar to the less than operation.</source>
          <target state="translated">&lt;code&gt;__le&lt;/code&gt; : 덜 같음 ( &lt;code&gt;&amp;lt;=&lt;/code&gt; ) 연산. 보다 작음 작업과 유사한 동작입니다.</target>
        </trans-unit>
        <trans-unit id="f475d84a338693db6fd2862596f21c01f8175167" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__le&lt;/code&gt;:  the less equal (&lt;code&gt;&amp;lt;=&lt;/code&gt;) operation. Unlike other operations, the less-equal operation can use two different events. First, Lua looks for the &lt;code&gt;__le&lt;/code&gt; metamethod in both operands, like in the less than operation. If it cannot find such a metamethod, then it will try the &lt;code&gt;__lt&lt;/code&gt; metamethod, assuming that &lt;code&gt;a &amp;lt;= b&lt;/code&gt; is equivalent to &lt;code&gt;not (b &amp;lt; a)&lt;/code&gt;. As with the other comparison operators, the result is always a boolean. (This use of the &lt;code&gt;__lt&lt;/code&gt; event can be removed in future versions; it is also slower than a real &lt;code&gt;__le&lt;/code&gt; metamethod.)</source>
          <target state="translated">&lt;code&gt;__le&lt;/code&gt; : 덜 동등한 ( &lt;code&gt;&amp;lt;=&lt;/code&gt; ) 연산입니다. 다른 작업과 달리 같지 않은 작업은 서로 다른 두 가지 이벤트를 사용할 수 있습니다. 먼저, Lua는 less than 연산과 같이 두 피연산자에서 &lt;code&gt;__le&lt;/code&gt; 메타 메소드를 찾습니다 . 그러한 메타 메소드를 찾을 수 없으면 &lt;code&gt;a &amp;lt;= b&lt;/code&gt; 가 &lt;code&gt;not (b &amp;lt; a)&lt;/code&gt; 와 같다고 가정 하여 &lt;code&gt;__lt&lt;/code&gt; 메타 메소드 를 시도합니다 . 다른 비교 연산자와 마찬가지로 결과는 항상 부울입니다. (이 버전 의 &lt;code&gt;__lt&lt;/code&gt; 이벤트 사용은 향후 버전에서 제거 될 수 있으며 실제 &lt;code&gt;__le&lt;/code&gt; 메타 메소드 보다 느립니다 .)</target>
        </trans-unit>
        <trans-unit id="c61fb722a1eddfcc88f7846f65e68ff08a2c65a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__len&lt;/code&gt;:  the length (&lt;code&gt;#&lt;/code&gt;) operation. If the object is not a string, Lua will try its metamethod. If there is a metamethod, Lua calls it with the object as argument, and the result of the call (always adjusted to one value) is the result of the operation. If there is no metamethod but the object is a table, then Lua uses the table length operation (see &lt;a href=&quot;#3.4.7&quot;&gt;&amp;sect;3.4.7&lt;/a&gt;). Otherwise, Lua raises an error.</source>
          <target state="translated">&lt;code&gt;__len&lt;/code&gt; : 길이 ( &lt;code&gt;#&lt;/code&gt; ) 연산 객체가 문자열이 아닌 경우 Lua는 메타 메소드를 시도합니다. 메타 메서드가있는 경우 Lua는 객체를 인수로 사용하여 메타 메서드를 호출하며 호출 결과 (항상 하나의 값으로 조정 됨)는 작업의 결과입니다. 메타 메소드가 없지만 객체가 테이블 인 경우 Lua는 테이블 길이 연산을 사용합니다 ( &lt;a href=&quot;#3.4.7&quot;&gt;&amp;sect;3.4.7&lt;/a&gt; 참조 ). 그렇지 않으면 Lua에서 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a3f09e158abb0f75d49c8c192f65fc3df9096218" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__lt&lt;/code&gt;:  the less than (&lt;code&gt;&amp;lt;&lt;/code&gt;) operation. Behavior similar to the addition operation, except that Lua will try a metamethod only when the values being compared are neither both numbers nor both strings. Moreover, the result of the call is always converted to a boolean.</source>
          <target state="translated">&lt;code&gt;__lt&lt;/code&gt; :보다 작음 ( &lt;code&gt;&amp;lt;&lt;/code&gt; ) 연산. 더하기 연산과 유사한 동작이지만 비교되는 값이 숫자도 아니고 문자열도 아닌 경우에만 Lua가 메타 메서드를 시도한다는 점이 다릅니다. 또한 호출 결과는 항상 부울로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="6902b36544db7b8d689de0371d69c1173727d394" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__lt&lt;/code&gt;:  the less than (&lt;code&gt;&amp;lt;&lt;/code&gt;) operation. Behavior similar to the addition operation, except that Lua will try a metamethod only when the values being compared are neither both numbers nor both strings. The result of the call is always converted to a boolean.</source>
          <target state="translated">&lt;code&gt;__lt&lt;/code&gt; : 미만 ( &lt;code&gt;&amp;lt;&lt;/code&gt; ) 연산 루아가 비교할 값이 숫자 나 문자열이 아닌 경우에만 메타 메소드를 시도한다는 점을 제외하고는 덧셈 연산과 유사합니다. 호출 결과는 항상 부울로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="a925135fe1afbe74d4fe523a8c1e22003b5c4f3e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__mod&lt;/code&gt;:  the modulo (&lt;code&gt;%&lt;/code&gt;) operation. Behavior similar to the addition operation.</source>
          <target state="translated">&lt;code&gt;__mod&lt;/code&gt; : 모듈로 ( &lt;code&gt;%&lt;/code&gt; ) 연산. 덧셈 연산과 유사한 동작.</target>
        </trans-unit>
        <trans-unit id="1ff94de42579b732d623fc7c57cf9f6691cc124d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__mul&lt;/code&gt;:  the multiplication (&lt;code&gt;*&lt;/code&gt;) operation. Behavior similar to the addition operation.</source>
          <target state="translated">&lt;code&gt;__mul&lt;/code&gt; : 곱셈 ( &lt;code&gt;*&lt;/code&gt; ) 연산입니다. 덧셈 연산과 유사한 동작.</target>
        </trans-unit>
        <trans-unit id="bae10caba1f39db8a0508384a96106120784c41c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__newindex&lt;/code&gt;:  The indexing assignment &lt;code&gt;table[key] = value&lt;/code&gt;. Like the index event, this event happens when &lt;code&gt;table&lt;/code&gt; is not a table or when &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;table&lt;/code&gt;. The metamethod is looked up in &lt;code&gt;table&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;__newindex&lt;/code&gt; : 인덱싱 할당 &lt;code&gt;table[key] = value&lt;/code&gt; . 인덱스 이벤트와 마찬가지로이 이벤트 는 &lt;code&gt;table&lt;/code&gt; 이 테이블 이 아니거나 &lt;code&gt;key&lt;/code&gt; 가 table 에없는 경우에 발생 &lt;code&gt;table&lt;/code&gt; . metamethod가 &lt;code&gt;table&lt;/code&gt; 에서 조회됩니다 .</target>
        </trans-unit>
        <trans-unit id="37937b6c573bf13ae1a75afc6ee8004d166493cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__newindex&lt;/code&gt;:  The indexing assignment &lt;code&gt;table[key] = value&lt;/code&gt;. Like the index event, this event happens when &lt;code&gt;table&lt;/code&gt; is not a table or when &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;table&lt;/code&gt;. The metavalue is looked up in the metatable of &lt;code&gt;table&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;__newindex&lt;/code&gt; : 인덱싱 할당 &lt;code&gt;table[key] = value&lt;/code&gt; . 인덱스 이벤트와 마찬가지로이 이벤트 는 &lt;code&gt;table&lt;/code&gt; 이 테이블 이 아니거나 테이블에 &lt;code&gt;key&lt;/code&gt; 가 없을 때 발생 &lt;code&gt;table&lt;/code&gt; . 메타 값은 &lt;code&gt;table&lt;/code&gt; 의 메타 테이블에서 조회됩니다 .</target>
        </trans-unit>
        <trans-unit id="7488b0be1bc57b10dfdfc405a5e990f26a432a65" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__pow&lt;/code&gt;:  the exponentiation (&lt;code&gt;^&lt;/code&gt;) operation. Behavior similar to the addition operation.</source>
          <target state="translated">&lt;code&gt;__pow&lt;/code&gt; : 지수화 ( &lt;code&gt;^&lt;/code&gt; ) 연산. 덧셈 연산과 유사한 동작.</target>
        </trans-unit>
        <trans-unit id="fc7215a1c4f0ddfcac8bc0abef79b38818065a05" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__shl&lt;/code&gt;:  the bitwise left shift (&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;) operation. Behavior similar to the bitwise AND operation.</source>
          <target state="translated">&lt;code&gt;__shl&lt;/code&gt; : 비트 단위 왼쪽 시프트 ( &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; ) 연산 비트 AND 연산과 유사한 동작입니다.</target>
        </trans-unit>
        <trans-unit id="8da8f661ba59d8ea368c0a166410be846f25ed51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__shr&lt;/code&gt;:  the bitwise right shift (&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;) operation. Behavior similar to the bitwise AND operation.</source>
          <target state="translated">&lt;code&gt;__shr&lt;/code&gt; : 비트 오른쪽 시프트 ( &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; ) 연산 비트 AND 연산과 유사한 동작입니다.</target>
        </trans-unit>
        <trans-unit id="0839e6023e2c19b90e41d7d692715ae3bb15dd52" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__sub&lt;/code&gt;:  the subtraction (&lt;code&gt;-&lt;/code&gt;) operation. Behavior similar to the addition operation.</source>
          <target state="translated">&lt;code&gt;__sub&lt;/code&gt; : 빼기 ( &lt;code&gt;-&lt;/code&gt; ) 연산입니다. 덧셈 연산과 유사한 동작.</target>
        </trans-unit>
        <trans-unit id="a0a7b7005a2b1ce8342934d9e28b702f6591bbad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__unm&lt;/code&gt;:  the negation (unary &lt;code&gt;-&lt;/code&gt;) operation. Behavior similar to the addition operation.</source>
          <target state="translated">&lt;code&gt;__unm&lt;/code&gt; : 부정 (단항 &lt;code&gt;-&lt;/code&gt; ) 연산입니다. 덧셈 연산과 유사한 동작.</target>
        </trans-unit>
        <trans-unit id="2034132fb0cda57893ded314ea78d570a3b8a1a8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b&lt;/code&gt;: a signed byte (&lt;code&gt;char&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; : 부호있는 바이트 ( &lt;code&gt;char&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="1f9d27a224e5a678dfac01895e2774339ad358a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c&lt;em&gt;n&lt;/em&gt;&lt;/code&gt;: a fixed-sized string with &lt;code&gt;n&lt;/code&gt; bytes</source>
          <target state="translated">&lt;code&gt;c&lt;em&gt;n&lt;/em&gt;&lt;/code&gt; : &lt;code&gt;n&lt;/code&gt; 바이트 의 고정 크기 문자열</target>
        </trans-unit>
        <trans-unit id="8a348caeedd88744c534e1a1de7a7057020a92eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;chunkname&lt;/code&gt; is used as the name of the chunk for error messages and debug information (see &lt;a href=&quot;#4.7&quot;&gt;&amp;sect;4.7&lt;/a&gt;). When absent, it defaults to &lt;code&gt;chunk&lt;/code&gt;, if &lt;code&gt;chunk&lt;/code&gt; is a string, or to &quot;&lt;code&gt;=(load)&lt;/code&gt;&quot; otherwise.</source>
          <target state="translated">&lt;code&gt;chunkname&lt;/code&gt; 은 오류 메시지 및 디버그 정보의 청크 이름으로 사용됩니다 ( &lt;a href=&quot;#4.7&quot;&gt;&amp;sect;4.7&lt;/a&gt; 참조 ). 경우에 결석, 기본값 &lt;code&gt;chunk&lt;/code&gt; , 경우 &lt;code&gt;chunk&lt;/code&gt; 문자열, 또는 &quot;이다 &lt;code&gt;=(load)&lt;/code&gt; &quot;그렇지.</target>
        </trans-unit>
        <trans-unit id="007ab16ec0f7187cc23f5c4f0e1b0b9ee75de945" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;chunkname&lt;/code&gt; is used as the name of the chunk for error messages and debug information (see &lt;a href=&quot;#4.9&quot;&gt;&amp;sect;4.9&lt;/a&gt;). When absent, it defaults to &lt;code&gt;chunk&lt;/code&gt;, if &lt;code&gt;chunk&lt;/code&gt; is a string, or to &quot;&lt;code&gt;=(load)&lt;/code&gt;&quot; otherwise.</source>
          <target state="translated">&lt;code&gt;chunkname&lt;/code&gt; 은 오류 메시지 및 디버그 정보의 청크 이름으로 사용됩니다 ( &lt;a href=&quot;#4.9&quot;&gt;&amp;sect;4.9&lt;/a&gt; 참조 ). 없는 경우, &lt;code&gt;chunk&lt;/code&gt; 가 문자열 이면 기본값은 &lt;code&gt;chunk&lt;/code&gt; 이고, 그렇지 않으면 &quot; &lt;code&gt;=(load)&lt;/code&gt; &quot;입니다.</target>
        </trans-unit>
        <trans-unit id="d532eddb006ab7874f0dc6fb8cbdceb76c478728" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;currentline&lt;/code&gt;:  the current line where the given function is executing. When no line information is available, &lt;code&gt;currentline&lt;/code&gt; is set to -1.</source>
          <target state="translated">&lt;code&gt;currentline&lt;/code&gt; : 주어진 함수가 실행되는 현재 줄. 사용 가능한 회선 정보가 없으면 &lt;code&gt;currentline&lt;/code&gt; 은 -1로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="166b1d8e53dd83b1f49810b36d2120d5fb8cf928" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;d&lt;/code&gt;: a &lt;code&gt;double&lt;/code&gt; (native size)</source>
          <target state="translated">&lt;code&gt;d&lt;/code&gt; : &lt;code&gt;double&lt;/code&gt; (기본 크기)</target>
        </trans-unit>
        <trans-unit id="0e1028744aa421b0605c6b88904012494c91f125" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f&lt;/code&gt;: a &lt;code&gt;float&lt;/code&gt; (native size)</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; : &lt;code&gt;float&lt;/code&gt; (기본 크기)</target>
        </trans-unit>
        <trans-unit id="74c283dd60f0873bd6aa5ca9d2cc894957dbcba9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ftransfer&lt;/code&gt;:  the index in the stack of the first value being &quot;transferred&quot;, that is, parameters in a call or return values in a return. (The other values are in consecutive indices.) Using this index, you can access and modify these values through &lt;a href=&quot;#lua_getlocal&quot;&gt;&lt;code&gt;lua_getlocal&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#lua_setlocal&quot;&gt;&lt;code&gt;lua_setlocal&lt;/code&gt;&lt;/a&gt;. This field is only meaningful during a call hook, denoting the first parameter, or a return hook, denoting the first value being returned. (For call hooks, this value is always 1.)</source>
          <target state="translated">&lt;code&gt;ftransfer&lt;/code&gt; : &quot;전송&quot;되는 첫 번째 값의 스택에있는 인덱스, 즉 호출의 매개 변수 또는 반환 값의 반환. (다른 값은 연속 인덱스에 있습니다.)이 인덱스를 사용하면 &lt;a href=&quot;#lua_getlocal&quot;&gt; &lt;code&gt;lua_getlocal&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#lua_setlocal&quot;&gt; &lt;code&gt;lua_setlocal&lt;/code&gt; 을&lt;/a&gt; 통해 이러한 값에 액세스하고 수정할 수 있습니다 . 이 필드는 첫 번째 매개 변수를 나타내는 호출 후크 또는 리턴되는 첫 번째 값을 나타내는 리턴 후크 중에 만 의미가 있습니다. (콜 후크의 경우이 값은 항상 1입니다.)</target>
        </trans-unit>
        <trans-unit id="c592f8c4c1d4f47249d70ff1f5e192a26d8afe2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;h&lt;/code&gt;: a signed &lt;code&gt;short&lt;/code&gt; (native size)</source>
          <target state="translated">&lt;code&gt;h&lt;/code&gt; : 부호가있는 &lt;code&gt;short&lt;/code&gt; (기본 크기)</target>
        </trans-unit>
        <trans-unit id="f5282762e143fb0df1d1386e42490a8eef06c695" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;i[&lt;em&gt;n&lt;/em&gt;]&lt;/code&gt;: a signed &lt;code&gt;int&lt;/code&gt; with &lt;code&gt;n&lt;/code&gt; bytes (default is native size)</source>
          <target state="translated">&lt;code&gt;i[&lt;em&gt;n&lt;/em&gt;]&lt;/code&gt; : 서명 &lt;code&gt;int&lt;/code&gt; 와 &lt;code&gt;n&lt;/code&gt; 바이트 (기본값은 기본 크기)</target>
        </trans-unit>
        <trans-unit id="77b05e59859fe1e74f32e61593a0eca919f3206e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;istailcall&lt;/code&gt;:  true if this function invocation was called by a tail call. In this case, the caller of this level is not in the stack.</source>
          <target state="translated">&lt;code&gt;istailcall&lt;/code&gt; :이 함수 호출이 tail 호출에 의해 호출 된 경우 true입니다. 이 경우이 레벨의 호출자는 스택에 없습니다.</target>
        </trans-unit>
        <trans-unit id="d69e22a542b48170e894be5d97f55fd47a232538" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isvararg&lt;/code&gt;:  true if the function is a vararg function (always true for C functions).</source>
          <target state="translated">&lt;code&gt;isvararg&lt;/code&gt; : 함수가 vararg 함수 인 경우 true입니다 (C 함수의 경우 항상 true).</target>
        </trans-unit>
        <trans-unit id="580dc9d1e4e90c03d788258153e5988096093196" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;j&lt;/code&gt;: a &lt;code&gt;lua_Integer&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;j&lt;/code&gt; : &lt;code&gt;lua_Integer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6e758d0de7cc3d0f062a6819b73437ee9ec2a2b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;l&lt;/code&gt;: a signed &lt;code&gt;long&lt;/code&gt; (native size)</source>
          <target state="translated">&lt;code&gt;l&lt;/code&gt; : 부호가있는 &lt;code&gt;long&lt;/code&gt; (기본 크기)</target>
        </trans-unit>
        <trans-unit id="f04a40c17b42b18f44495a16f52bfd52196ef418" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lastlinedefined&lt;/code&gt;:  the line number where the definition of the function ends.</source>
          <target state="translated">&lt;code&gt;lastlinedefined&lt;/code&gt; : 함수 정의가 끝나는 줄 번호입니다.</target>
        </trans-unit>
        <trans-unit id="6ac83d3c96d2336c0ded704acb6714bea3c3ee52" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;limit&lt;/code&gt; cannot be less than the amount of C stack in use.</source>
          <target state="translated">&lt;code&gt;limit&lt;/code&gt; 은 사용중인 C 스택의 양보다 작을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4b070ad7d6ea6422e9596856316726e2174909f2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;limit&lt;/code&gt; must be less than 40000;</source>
          <target state="translated">&lt;code&gt;limit&lt;/code&gt; 는 40000 미만이어야합니다.</target>
        </trans-unit>
        <trans-unit id="c558e7acb9233839c3055af52ec8d17bbbf36292" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;linedefined&lt;/code&gt;:  the line number where the definition of the function starts.</source>
          <target state="translated">&lt;code&gt;linedefined&lt;/code&gt; : 함수 정의가 시작되는 줄 번호입니다.</target>
        </trans-unit>
        <trans-unit id="1814936b717a437d1f1941926869384106ce1392" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_addchar&lt;/code&gt;[-?, +?, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_addchar&lt;/code&gt; [-?, + ?, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="b1e57ff274ef17e50c46ffbd715233aaa7df55ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_addgsub&lt;/code&gt;[-0, +0, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_addgsub&lt;/code&gt; [-0, +0, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="575546c5b83ac45ad492ca8e44de50943cdf9d36" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_addlstring&lt;/code&gt;[-?, +?, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_addlstring&lt;/code&gt; [-?, + ?, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="ab2404026db427b81b929835fcc07320d0975966" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_addsize&lt;/code&gt;[-?, +?, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;luaL_addsize&lt;/code&gt; [-?, + ?, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="6af536d80928bc10905ab3dce78e92ea76d54e77" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_addstring&lt;/code&gt;[-?, +?, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_addstring&lt;/code&gt; [-?, + ?, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="f62f4ab7ab22c41889b8409e3b36723d81cabada" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_addvalue&lt;/code&gt;[-1, +?, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_addvalue&lt;/code&gt; [-1, + ?, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="32a97bb778b383afdcf82dbf302e1156a6cc0b2e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_argcheck&lt;/code&gt;[-0, +0, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_argcheck&lt;/code&gt; [-0, +0, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="d807e00e947d759f9dcb553ac98ec1f1193a93e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_argerror&lt;/code&gt;[-0, +0, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_argerror&lt;/code&gt; [-0, +0, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="e9d8a6e29589fc9f48f67f5632ab60dddf31d961" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_argexpected&lt;/code&gt;[-0, +0, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_argexpected&lt;/code&gt; [-0, +0, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="0420a8349297f3b02777896ea75e70b714d30a97" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_buffaddr&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;luaL_buffaddr&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="4db817fce2c3b28619d23198a312e17e8c0b41fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_buffinit&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;luaL_buffinit&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="76b56ecab1b6154600ac285b1b29eb963a213f07" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_buffinitsize&lt;/code&gt;[-?, +?, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_buffinitsize&lt;/code&gt; [-?, + ?, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="9012e6948fc3b64a531d97cabf645c5589aeecce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_bufflen&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;luaL_bufflen&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="4194d04d8f4c00f06cf19700bff56f0807a46c6d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_buffsub&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;luaL_buffsub&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="15797d76578ab05f141375478dbdaccf46d64197" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_callmeta&lt;/code&gt;[-0, +(0|1), &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_callmeta&lt;/code&gt; [-0, + (0 | 1), &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="85267089380208d1670ba57aca773cbfd01c3852" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_checkany&lt;/code&gt;[-0, +0, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_checkany&lt;/code&gt; [-0, +0, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="60a4f7f116afbde74193d5e8eb007754d432edfa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_checkinteger&lt;/code&gt;[-0, +0, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_checkinteger&lt;/code&gt; [-0, +0, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="caad9f257f912ca30f4e0c4103ba996c9420a91b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_checklstring&lt;/code&gt;[-0, +0, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_checklstring&lt;/code&gt; [-0, +0, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="fb3b4e49519cf5dbd32c138191f993b8dc2a1534" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_checknumber&lt;/code&gt;[-0, +0, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_checknumber&lt;/code&gt; [-0, +0, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="38dfb40ea1a004fd0d2b69fead480d9a49d8202a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_checkoption&lt;/code&gt;[-0, +0, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_checkoption&lt;/code&gt; [-0, +0, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="322257f7e30d47626338ffdee9062b057e90cd8e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_checkstack&lt;/code&gt;[-0, +0, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_checkstack&lt;/code&gt; [-0, +0, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="817bb0029ff7aff6991eab710b919497a5dbc912" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_checkstring&lt;/code&gt;[-0, +0, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_checkstring&lt;/code&gt; [-0, +0, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="341111dc53b49f417dcd96b3fc29b039a26ba056" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_checktype&lt;/code&gt;[-0, +0, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_checktype&lt;/code&gt; [-0, +0, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="12123157de5a720309f6a7c63a2cfa0c299903b3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_checkudata&lt;/code&gt;[-0, +0, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_checkudata&lt;/code&gt; [-0, +0, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="dffa7856bb9be8c95d07d1f17dadf607bf429ad1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_checkversion&lt;/code&gt;[-0, +0, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_checkversion&lt;/code&gt; [-0, +0, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="3374658d775d8aa7fb8fe52da4e6fc7cfd927d02" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_dofile&lt;/code&gt;[-0, +?, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_dofile&lt;/code&gt; [-0, + ?, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="200e70cd43edc635af7b5f245c095858f2496ed5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_dofile&lt;/code&gt;[-0, +?, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_dofile&lt;/code&gt; [-0, + ?, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="a582cca705f2cb3830ac7257f0eb21203b6e929b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_dostring&lt;/code&gt;[-0, +?, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;luaL_dostring&lt;/code&gt; [-0, + ?, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="a5a15bfcee6d520f8c55a01f53ed494d8d316be5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_error&lt;/code&gt;[-0, +0, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_error&lt;/code&gt; [-0, +0, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="6faffe57f68b2e507d46bda2d67142fcf1bd3eda" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_execresult&lt;/code&gt;[-0, +3, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_execresult&lt;/code&gt; [-0, +3, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="689d9709c543e39ba4b14f659761c6fbee59fb20" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_fileresult&lt;/code&gt;[-0, +(1|3), &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_fileresult&lt;/code&gt; [-0, + (1 | 3), &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="26ad671f853e795fc32c1842c210c309e5737a70" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_getmetafield&lt;/code&gt;[-0, +(0|1), &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_getmetafield&lt;/code&gt; [-0, + (0 | 1), &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="86627657b2139b0ee31a53c83ad51ed9c63ee4f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_getmetatable&lt;/code&gt;[-0, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_getmetatable&lt;/code&gt; [-0, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="f0429bf39eeee8b432bf2c4ac915eb9bd9c58fe4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_getsubtable&lt;/code&gt;[-0, +1, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_getsubtable&lt;/code&gt; [-0, +1, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="dcbde4eb043fd7a6a88005560668c86e718f4d64" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_gsub&lt;/code&gt;[-0, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_gsub&lt;/code&gt; [-0, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="6aa13480ee4b2afee4725e8c33c17ccef37dacb0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_len&lt;/code&gt;[-0, +0, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_len&lt;/code&gt; [-0, +0, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="1ff1186e40e0c45fe6b82e0cd030ddaab25d3514" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_loadbuffer&lt;/code&gt;[-0, +1, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;luaL_loadbuffer&lt;/code&gt; [-0, +1, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="5c9c6205f5ab035f8481cc23adec6d68a927c21e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_loadbufferx&lt;/code&gt;[-0, +1, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;luaL_loadbufferx&lt;/code&gt; [-0, +1, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="3efa8a062aa5c6fd99fa30d9a6b615805d5f6633" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_loadfile&lt;/code&gt;[-0, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_loadfile&lt;/code&gt; [-0, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="bed752688a8097a24d7fe06f2d44fb3b8104d51d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_loadfilex&lt;/code&gt;[-0, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_loadfilex&lt;/code&gt; [-0, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="a1117ad9189ec1e73f1b81cc6ca7a6ca13b4d08a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_loadstring&lt;/code&gt;[-0, +1, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;luaL_loadstring&lt;/code&gt; [-0, +1, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="7006cdeb7d6e0f06f8bd85a3e8e67991899f625c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_newlib&lt;/code&gt;[-0, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_newlib&lt;/code&gt; [-0, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="4bb6d574631ce0eb10e53ee60cc236afb57494d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_newlibtable&lt;/code&gt;[-0, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_newlibtable&lt;/code&gt; [-0, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="1597a9788daec91a227c519bb2f818e05f9f4c08" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_newmetatable&lt;/code&gt;[-0, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_newmetatable&lt;/code&gt; [-0, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="ce4b485fbcd4cc791900d08f23c6cdfdec7f1520" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_newstate&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;luaL_newstate&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="49f8165e8132fcb469103de8892f176c1f0def64" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_openlibs&lt;/code&gt;[-0, +0, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_openlibs&lt;/code&gt; [-0, +0, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="db3705a693651e2352b4cd9e06f038a5145d3eed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_opt&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;luaL_opt&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="83750c461dfda8dcc3cadb263ef7f900676721c9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_opt&lt;/code&gt;[-0, +0, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_opt&lt;/code&gt; [-0, +0, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="7ddba39b66f773750f9ae187c2d2d76d0f89ac96" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_optinteger&lt;/code&gt;[-0, +0, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_optinteger&lt;/code&gt; [-0, +0, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="2fcf8ecf5a60e1bef873c06be25a18130a4d742f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_optlstring&lt;/code&gt;[-0, +0, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_optlstring&lt;/code&gt; [-0, +0, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="9f89308fc4e4595c99a38d039175c1137359ac54" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_optnumber&lt;/code&gt;[-0, +0, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_optnumber&lt;/code&gt; [-0, +0, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="274c9ca5ceedb91c17aae3f6a7353a8fe5343712" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_optstring&lt;/code&gt;[-0, +0, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_optstring&lt;/code&gt; [-0, +0, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="7a41c18601fede06cd92afc10561621476415195" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_prepbuffer&lt;/code&gt;[-?, +?, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_prepbuffer&lt;/code&gt; [-?, + ?, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="6dd4e822d50779a6e2f55486d474e3cf4dc9a3a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_prepbuffsize&lt;/code&gt;[-?, +?, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_prepbuffsize&lt;/code&gt; [-?, + ?, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="0d062e1490417f3389611ce549b989dea09db184" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_pushfail&lt;/code&gt;[-0, +1, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;luaL_pushfail&lt;/code&gt; [-0, +1, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="f4c1792dcbf5df89608d53cfa3c381e725d7c8dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_pushresult&lt;/code&gt;[-?, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_pushresult&lt;/code&gt; [-?, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="56aef86b4910793d510e049e250c4ba15d08651b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_pushresultsize&lt;/code&gt;[-?, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_pushresultsize&lt;/code&gt; [-?, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="cf9ba081e7beac774ea13e9e5e96e368f77f91b6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_ref&lt;/code&gt;[-1, +0, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_ref&lt;/code&gt; [-1, +0, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="964377d76c6003fa09c52e382c6f30d89d8e7733" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_requiref&lt;/code&gt;[-0, +1, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_requiref&lt;/code&gt; [-0, +1, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="0fa64c78fb075f6bccbf9d15ca226451decea5ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_setfuncs&lt;/code&gt;[-nup, +0, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_setfuncs&lt;/code&gt; [-nup, +0, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="2e5d3d14dd1ede554838763a71c2eb2b30f00e10" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_setmetatable&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;luaL_setmetatable&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="b4785fa0b78405754bdd9e6816e0505e89bb2ed6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_testudata&lt;/code&gt;[-0, +0, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_testudata&lt;/code&gt; [-0, +0, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="87fa79dd9413aed4e20cd6a034ba315882e2e0de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_tolstring&lt;/code&gt;[-0, +1, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_tolstring&lt;/code&gt; [-0, +1, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="306b764f016817d71c097f8443a6177598555795" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_traceback&lt;/code&gt;[-0, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_traceback&lt;/code&gt; [-0, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="1681fbfd259c145321f77c918190a06410715131" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_typeerror&lt;/code&gt;[-0, +0, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_typeerror&lt;/code&gt; [-0, +0, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="ca032fc0be8f16a7dbcab71e66bfe7be88723983" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_typename&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;luaL_typename&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="f49e88ae95e2c08d4f66fb932d9bcde472eca71a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_unref&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;luaL_unref&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="e61c1eb9f0ad1ce243ab6024b692ea269b6a3ddc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;luaL_where&lt;/code&gt;[-0, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;luaL_where&lt;/code&gt; [-0, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="990854d58117af3aa9e8e4765776b83ce30f5cb0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_absindex&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_absindex&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="b1819f228761942b7921d51557a46ebabdfda1ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_arith&lt;/code&gt;[-(2|1), +1, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_arith&lt;/code&gt; [-(2 | 1), +1, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="f24f91865ac7127a8413e2ae152416f6c2ed006b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_atpanic&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_atpanic&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="e7479fe5b0585be43d2a995bebe0c8255ad26bbb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_call&lt;/code&gt;[-(nargs+1), +nresults, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_call&lt;/code&gt; [-(nargs + 1), + nresults, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="c65d2f6c1099ba05a81459947c26df8cf58a8ea8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_callk&lt;/code&gt;[-(nargs + 1), +nresults, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_callk&lt;/code&gt; [-(nargs + 1), + nresults, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="acf13cf1bfb7ad750c4fa45422c658708c5d250e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_checkstack&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_checkstack&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="ce69674693f57931d2d994412ec490a58883fe0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_close&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_close&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="9f95f6e80bc09c2b612082485467d037fdabd286" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_compare&lt;/code&gt;[-0, +0, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_compare&lt;/code&gt; [-0, +0, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="a04bab7507101355ee6351af1abfc06a7108a08a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_concat&lt;/code&gt;[-n, +1, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_concat&lt;/code&gt; [-n, +1, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="814bbfd9c45c7f18a87781bf3ee57bb270d7c603" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_copy&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_copy&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="79ee61bf6bf5fa92650008381392b1a21cbabf69" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_createtable&lt;/code&gt;[-0, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_createtable&lt;/code&gt; [-0, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="e7551097f181c02c15fea59139836b798d27fd76" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_dump&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_dump&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="d1d8b7fcdc2438a4309209f0e66816aa345e3ea0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_error&lt;/code&gt;[-1, +0, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_error&lt;/code&gt; [-1, +0, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="175321925aafb53c52dcfff8bf70c2d4f9b5df52" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_gc&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_gc&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="a66371d02bb2a5294ddc7ff965f4078200f059e7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_gc&lt;/code&gt;[-0, +0, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_gc&lt;/code&gt; [-0, +0, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="9956d0bc82cc5409c737543da96a541d83bfbf7c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_getallocf&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_getallocf&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="59632bab17bc189c3148482bc4080f9bd4b84547" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_getextraspace&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_getextraspace&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="60f37f158845e124eace06ea63e2280a95012974" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_getfield&lt;/code&gt;[-0, +1, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_getfield&lt;/code&gt; [-0, +1, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="c94c6fd2b7c14b3e3b6ad04d5fe36bf6add888c9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_getglobal&lt;/code&gt;[-0, +1, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_getglobal&lt;/code&gt; [-0, +1, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="ff4cee0e3a4e1d63522125ff34c46aca37313caf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_gethook&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_gethook&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="ec0eadfb615abc82aff0c7990a50162481f09f63" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_gethookcount&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_gethookcount&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="d7f8a674ccfd65eff1082ce412eb29972a57b18c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_gethookmask&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_gethookmask&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="f71c31c54898e128df0441cf376c9e767064382d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_geti&lt;/code&gt;[-0, +1, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_geti&lt;/code&gt; [-0, +1, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="ea4a9e14acd3cb3bbf7462b6fb68c3ad28de14f4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_getinfo&lt;/code&gt;[-(0|1), +(0|1|2), &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_getinfo&lt;/code&gt; [-(0 | 1), + (0 | 1 | 2), &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="0bed39a4374d24b0f719b1d6d6c9c9072489529c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_getinfo&lt;/code&gt;[-(0|1), +(0|1|2), &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_getinfo&lt;/code&gt; [-(0 | 1), + (0 | 1 | 2), &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="2144ffaa8fe826cac915c3c99e27c9ab5db89e04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_getiuservalue&lt;/code&gt;[-0, +1, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_getiuservalue&lt;/code&gt; [-0, +1, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="273e8c6ec216c7c83ca38a878d93b95631b13f24" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_getlocal&lt;/code&gt;[-0, +(0|1), &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_getlocal&lt;/code&gt; [-0, + (0 | 1), &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="e2eca7f4a92d49d560aa8d947a3a1e0961d07be4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_getmetatable&lt;/code&gt;[-0, +(0|1), &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_getmetatable&lt;/code&gt; [-0, + (0 | 1), &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="7e3ce20be5f0c5d99b7e25b37999cb8bb5fd91e0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_getstack&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_getstack&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="e01aa99ca62e5ceb24fa39ed4a6f4d31e572fa50" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_gettable&lt;/code&gt;[-1, +1, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_gettable&lt;/code&gt; [-1, +1, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="8e15475f1fb39e9839166b70e212b31d2521646e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_gettop&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_gettop&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="75cc1327823f758a6a97b78b712f93d5c639d881" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_getupvalue&lt;/code&gt;[-0, +(0|1), &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_getupvalue&lt;/code&gt; [-0, + (0 | 1), &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="06a9850be6a3681bd25c5c7e797cd88c22cc51e3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_getuservalue&lt;/code&gt;[-0, +1, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_getuservalue&lt;/code&gt; [-0, +1, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="97ccd9464bf8253b4595901de1c28a281d630bca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_insert&lt;/code&gt;[-1, +1, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_insert&lt;/code&gt; [-1, +1, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="ccf0205da2145136a72004529c69ef0d97389a74" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_isboolean&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_isboolean&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="d8f9274340043a6fe5b4a6502b209dfbcbc8102f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_iscfunction&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_iscfunction&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="344ac0a298f2d260c0cf30e7563213a6456c1391" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_isfunction&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_isfunction&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="95a6448d21c638bda4c1f328498fa19c59e41122" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_isinteger&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_isinteger&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="906431d15e81d16a20736c110a889aa904f850f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_islightuserdata&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_islightuserdata&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="c331f628d45e17d9badc04decdc73b3dfba9aa43" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_isnil&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_isnil&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="b6f54dbbadf1568e10c49c9c8d51351826575cc2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_isnone&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_isnone&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="6141fdc1edd3191ed965eb184782c4bcc77ab662" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_isnoneornil&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_isnoneornil&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="244c0aa7d5c38d7aff3d8a120df5d0ff4dedd191" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_isnumber&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_isnumber&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="9c5842c76ba56cc7b434b470a13d5db9a2ae746b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_isstring&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_isstring&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="9e4d02a146e4faff57845d1d808d69e94d4d5760" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_istable&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_istable&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="fca695e4d6ae492d953e231c04e6456779c318ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_isthread&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_isthread&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="9054b192261af4e3df167d43972cc92d8f12c922" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_isuserdata&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_isuserdata&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="6558ec7a9edae7a2472cab5d36feb4a25937b33a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_isyieldable&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_isyieldable&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="84ed319e4f41b15e379b0c80b8d751fb0a3350ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_len&lt;/code&gt;[-0, +1, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_len&lt;/code&gt; [-0, +1, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="7a22e4332e1d809d6600680001552784b09874aa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_load&lt;/code&gt; automatically detects whether the chunk is text or binary and loads it accordingly (see program &lt;code&gt;luac&lt;/code&gt;). The string &lt;code&gt;mode&lt;/code&gt; works as in function &lt;a href=&quot;#pdf-load&quot;&gt;&lt;code&gt;load&lt;/code&gt;&lt;/a&gt;, with the addition that a &lt;code&gt;NULL&lt;/code&gt; value is equivalent to the string &quot;&lt;code&gt;bt&lt;/code&gt;&quot;.</source>
          <target state="translated">&lt;code&gt;lua_load&lt;/code&gt; 는 청크가 텍스트인지 바이너리인지 자동으로 감지하여 그에 따라로드합니다 (프로그램 &lt;code&gt;luac&lt;/code&gt; 참조 ). 문자열 &lt;code&gt;mode&lt;/code&gt; 는 함수 &lt;a href=&quot;#pdf-load&quot;&gt; &lt;code&gt;load&lt;/code&gt; &lt;/a&gt; 에서와 같이 작동 하며 &lt;code&gt;NULL&lt;/code&gt; 값은 문자열 &quot; &lt;code&gt;bt&lt;/code&gt; &quot; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="205ec7f08fa763f310046a4629ec375e374f3151" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_load&lt;/code&gt; can return &lt;a href=&quot;#pdf-LUA_OK&quot;&gt;&lt;code&gt;LUA_OK&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pdf-LUA_ERRSYNTAX&quot;&gt;&lt;code&gt;LUA_ERRSYNTAX&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#pdf-LUA_ERRMEM&quot;&gt;&lt;code&gt;LUA_ERRMEM&lt;/code&gt;&lt;/a&gt;. The function may also return other values corresponding to errors raised by the read function (see &lt;a href=&quot;#4.4.1&quot;&gt;&amp;sect;4.4.1&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;lua_load&lt;/code&gt; 는 반환 할 수 &lt;a href=&quot;#pdf-LUA_OK&quot;&gt; &lt;code&gt;LUA_OK&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#pdf-LUA_ERRSYNTAX&quot;&gt; &lt;code&gt;LUA_ERRSYNTAX&lt;/code&gt; &lt;/a&gt; , 또는 &lt;a href=&quot;#pdf-LUA_ERRMEM&quot;&gt; &lt;code&gt;LUA_ERRMEM&lt;/code&gt; 을&lt;/a&gt; . 이 함수는 읽기 함수에서 발생한 오류에 해당하는 다른 값도 반환 할 수 있습니다 ( &lt;a href=&quot;#4.4.1&quot;&gt;&amp;sect;4.4.1&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="ccb7a1a988cb848b3d6f32fc68386067014fdd3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_load&lt;/code&gt; uses the stack internally, so the reader function must always leave the stack unmodified when returning.</source>
          <target state="translated">&lt;code&gt;lua_load&lt;/code&gt; 는 내부적으로 스택을 사용하므로 리더 함수는 반환 할 때 항상 스택을 수정하지 않은 상태로 두어야합니다.</target>
        </trans-unit>
        <trans-unit id="c9ad4cdb5afe054e2d52630b341bddcd5318dcbb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_load&lt;/code&gt;[-0, +1, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_load&lt;/code&gt; [-0, +1, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="7374aef019136058240eb91bf9d7d1be64edc6b3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_newstate&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_newstate&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="1a38a1e48176080fdd830cbfa8d2959e31ce81e5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_newtable&lt;/code&gt;[-0, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_newtable&lt;/code&gt; [-0, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="0a032a953b6701cd3d3ac0a4241cf5e3af19ca63" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_newthread&lt;/code&gt;[-0, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_newthread&lt;/code&gt; [-0, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="aa090c22b67b6e811e3f6576dbb546c21227c3b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_newuserdata&lt;/code&gt;[-0, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_newuserdata&lt;/code&gt; [-0, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="18ba0a88db2e9be2ede36cb5e2777c3cf13f59bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_newuserdatauv&lt;/code&gt;[-0, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_newuserdatauv&lt;/code&gt; [-0, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="a2e6cbd4372d1f48086bd4ed0d56df437b0da92b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_next&lt;/code&gt;[-1, +(2|0), &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_next&lt;/code&gt; [-1, + (2 | 0), &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="e97b757ec2b0dba68687708df9fcc7d28f8bcdae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_next&lt;/code&gt;[-1, +(2|0), &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_next&lt;/code&gt; [-1, + (2 | 0), &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="e26fc6d5a88b15e99cc4567b71c159df4ba7279c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_pcall&lt;/code&gt;[-(nargs + 1), +(nresults|1), &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_pcall&lt;/code&gt; [-(nargs + 1), + (nresults | 1), &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="850c75458d454fa1e854b2a9dc95240fca9f635c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_pcallk&lt;/code&gt;[-(nargs + 1), +(nresults|1), &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_pcallk&lt;/code&gt; [-(nargs + 1), + (nresults | 1), &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="88661d7b63266eddc349ccd0237a4a2fc79f215f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_pop&lt;/code&gt;[-n, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_pop&lt;/code&gt; [-n, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="666e2142d3e457306d33378f3369679386a5b561" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_pushboolean&lt;/code&gt;[-0, +1, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_pushboolean&lt;/code&gt; [-0, +1, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="65a5e45fe5816a098fad98e557109633e97a1de8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_pushcclosure&lt;/code&gt;[-n, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_pushcclosure&lt;/code&gt; [-n, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="73447e0e4c9e92da86686da3e2f378b5e95bb556" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_pushcfunction&lt;/code&gt;[-0, +1, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_pushcfunction&lt;/code&gt; [-0, +1, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="6d9930915fc5c9a7d6f3b1983934256b1782cdce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_pushfstring&lt;/code&gt;[-0, +1, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_pushfstring&lt;/code&gt; [-0, +1, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="742728222fd6b05fea9d1313511dc12b79d321da" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_pushfstring&lt;/code&gt;[-0, +1, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_pushfstring&lt;/code&gt; [-0, +1, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="6ca7a523e75628341dcb660957104bd730722b5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_pushglobaltable&lt;/code&gt;[-0, +1, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_pushglobaltable&lt;/code&gt; [-0, +1, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="a664d85fd673d8e5f2c1f86f70023732e187465e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_pushinteger&lt;/code&gt;[-0, +1, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_pushinteger&lt;/code&gt; [-0, +1, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="a766edeb81578b9f6c5186a1ef1e02ddf5cb9453" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_pushlightuserdata&lt;/code&gt;[-0, +1, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_pushlightuserdata&lt;/code&gt; [-0, +1, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="78d98a728cf4ae7cccb9296c51e6350cb444a216" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_pushliteral&lt;/code&gt;[-0, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_pushliteral&lt;/code&gt; [-0, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="52c39aa3679bdd694c82d8b6920a76e7887f4f65" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_pushlstring&lt;/code&gt;[-0, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_pushlstring&lt;/code&gt; [-0, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="f18e9b33f026fcc7f0bb37b6518778960e0be147" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_pushnil&lt;/code&gt;[-0, +1, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_pushnil&lt;/code&gt; [-0, +1, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="5b61a28ad71dd0c16bf5685880526849b74d1b22" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_pushnumber&lt;/code&gt;[-0, +1, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_pushnumber&lt;/code&gt; [-0, +1, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="48093510761a8d9599932440e922c82a70bff0b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_pushstring&lt;/code&gt;[-0, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_pushstring&lt;/code&gt; [-0, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="8941a8b85742686999473929b77ca66b0c29786c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_pushthread&lt;/code&gt;[-0, +1, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_pushthread&lt;/code&gt; [-0, +1, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="a01e6c270aa1f8c90cd63c088fc55f395501c232" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_pushvalue&lt;/code&gt;[-0, +1, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_pushvalue&lt;/code&gt; [-0, +1, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="c4891a46279c1165ab6f6829b04d0f80e80af46f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_pushvfstring&lt;/code&gt;[-0, +1, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_pushvfstring&lt;/code&gt; [-0, +1, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="c47750b302979b454e9930cbacc8c1efe4377ef6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_pushvfstring&lt;/code&gt;[-0, +1, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_pushvfstring&lt;/code&gt; [-0, +1, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="5301ff5e4db06f4a902ea6e4f46a536016dec115" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_rawequal&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_rawequal&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="e7190a64e66cfdbfaa05e771b86b2428ce0f0c4f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_rawget&lt;/code&gt;[-1, +1, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_rawget&lt;/code&gt; [-1, +1, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="d8f63e8c899fc2163ea12e1929521f16195b8027" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_rawgeti&lt;/code&gt;[-0, +1, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_rawgeti&lt;/code&gt; [-0, +1, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="fd2f5fea0059c2e1a9ec9f806dd9bc92085001d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_rawgetp&lt;/code&gt;[-0, +1, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_rawgetp&lt;/code&gt; [-0, +1, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="32af4b6d514d73f35935bd7c665974260bb2d400" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_rawlen&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_rawlen&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="1d4cc3e1e56562010c53810d955212d9e94456ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_rawset&lt;/code&gt;[-2, +0, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_rawset&lt;/code&gt; [-2, +0, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="6ebc570fbad1c557a9df049aab4ab6766494d940" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_rawseti&lt;/code&gt;[-1, +0, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_rawseti&lt;/code&gt; [-1, +0, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="7c35ae056b934f9d827a204944f9eb45d6eac2c2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_rawsetp&lt;/code&gt;[-1, +0, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_rawsetp&lt;/code&gt; [-1, +0, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="13a48b8091c79dfb748c242e690a7dfb0126ad0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_register&lt;/code&gt;[-0, +0, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_register&lt;/code&gt; [-0, +0, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="a0f12f7525f2b835c43c2bbb5726d22e75a7ad66" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_remove&lt;/code&gt;[-1, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_remove&lt;/code&gt; [-1, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="e3aac1a6f4d80e971df8eaa5fd21798ce934e9c2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_replace&lt;/code&gt;[-1, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_replace&lt;/code&gt; [-1, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="b1f830de2effb08c4ecef3246ffae5912534c901" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_resetthread&lt;/code&gt;[-0, +?, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_resetthread&lt;/code&gt; [-0, + ?, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="3a14b7df302fab9d83a4283a02b409867a164c3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_resume&lt;/code&gt;[-?, +?, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_resume&lt;/code&gt; [-?, + ?, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="64b664566bc1133823238a94df36387e91cc4ce7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_rotate&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_rotate&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="01005f76c6b7629878b4c890f865d738f3e13645" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_setallocf&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_setallocf&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="b0dc382a93758dd44d7aff42b2386a61c087aa9a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_setcstacklimit&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_setcstacklimit&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="69d7c876f5849763d0227a670cfb4cab56753235" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_setfield&lt;/code&gt;[-1, +0, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_setfield&lt;/code&gt; [-1, +0, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="0afc85df066219abbaa2ee335f767a7b6896a049" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_setglobal&lt;/code&gt;[-1, +0, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_setglobal&lt;/code&gt; [-1, +0, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="1b87726690c26be63f2ac34a4ef8702546d30a9c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_sethook&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_sethook&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="f0d0da820dadc58bad264baff1243876ee500108" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_seti&lt;/code&gt;[-1, +0, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_seti&lt;/code&gt; [-1, +0, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="004a5c6164d1e4a0656eb999c1264f21fa274fcf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_setiuservalue&lt;/code&gt;[-1, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_setiuservalue&lt;/code&gt; [-1, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="5673fc21d54441e768e98b5369226b29b8a4d4e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_setlocal&lt;/code&gt;[-(0|1), +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_setlocal&lt;/code&gt; [-(0 | 1), +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="411f7433e89a45adb3e7009dbdd17fd585bc8560" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_setmetatable&lt;/code&gt;[-1, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_setmetatable&lt;/code&gt; [-1, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="20dcd39a78d5bdc5aa9f802eb25a1dd6a435cab5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_settable&lt;/code&gt;[-2, +0, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_settable&lt;/code&gt; [-2, +0, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="8259b61e77e47265f15b0e9934536650ba6717ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_settop&lt;/code&gt;[-?, +?, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_settop&lt;/code&gt; [-?, + ?, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="fd6996e775cf476c1f493f52a1afccf6f6c1f4c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_setupvalue&lt;/code&gt;[-(0|1), +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_setupvalue&lt;/code&gt; [-(0 | 1), +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="962bd088aac144ff787da78a548da45dbaa42a60" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_setuservalue&lt;/code&gt;[-1, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_setuservalue&lt;/code&gt; [-1, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="7eae365e3fdcddc5bea18be3c82bca53270c4d98" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_setwarnf&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_setwarnf&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="cc614bc467cfc52c396d5f4863abfb818cf5cd26" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_status&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_status&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="2ccbee67de9eb87f0444d554fe5e403f4ee12142" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_stringtonumber&lt;/code&gt;[-0, +1, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_stringtonumber&lt;/code&gt; [-0, +1, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="3c297ec1e5647fff579f5d361ceaa2a83c13bc96" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_toboolean&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_toboolean&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="2f40e6bccafddc0d0eb0d56fd2ebb507f4a741b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_tocfunction&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_tocfunction&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="8c671d19d258d8dce1480fe0181a4b47d99286d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_toclose&lt;/code&gt;[-0, +0, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_toclose&lt;/code&gt; [-0, +0, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="772105fa735d3f8e52e4dcf1f374a906313801c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_tointeger&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_tointeger&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="087ba9ee74385ce56dc7afa2421e9fe18d49cdf9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_tointegerx&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_tointegerx&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="281abec9d8adcad8af78e123cc30469524cc8691" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_tolstring&lt;/code&gt; returns a pointer to a string inside the Lua state (see &lt;a href=&quot;#4.1.3&quot;&gt;&amp;sect;4.1.3&lt;/a&gt;). This string always has a zero ('&lt;code&gt;\0&lt;/code&gt;') after its last character (as in C), but can contain other zeros in its body.</source>
          <target state="translated">&lt;code&gt;lua_tolstring&lt;/code&gt; 은 Lua 상태 내의 문자열에 대한 포인터를 반환합니다 ( &lt;a href=&quot;#4.1.3&quot;&gt;&amp;sect;4.1.3&lt;/a&gt; 참조 ). 이 문자열 은 C에서와 같이 마지막 문자 뒤에 항상 0 ( ' &lt;code&gt;\0&lt;/code&gt; ')이 있지만 본문에 다른 0을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d547274b13aa55e1f5b1a1ead3114fadb93ca9e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_tolstring&lt;/code&gt; returns a pointer to a string inside the Lua state. This string always has a zero ('&lt;code&gt;\0&lt;/code&gt;') after its last character (as in C), but can contain other zeros in its body.</source>
          <target state="translated">&lt;code&gt;lua_tolstring&lt;/code&gt; 은 Lua 상태 내의 문자열에 대한 포인터를 반환합니다. 이 문자열 은 마지막 문자 (C에서와 같이) 뒤에 항상 0 ( ' &lt;code&gt;\0&lt;/code&gt; ')을 갖지만 본문에 다른 0을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="784eecca5b67aab549cd43e3189c0b5977217c92" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_tolstring&lt;/code&gt;[-0, +0, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_tolstring&lt;/code&gt; [-0, +0, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="7687cab7b8801ef5abea1aaa0693b3341c3eb2a1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_tonumber&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_tonumber&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="99cab8a87a9cde1e6e3d9aaa6081962667424cb2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_tonumberx&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_tonumberx&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="d77c2f1d7b9ab8de85633a1ac860cb38ef23ca1f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_topointer&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_topointer&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="d7d11d995d3d1465098bd08f248711e428607f48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_tostring&lt;/code&gt;[-0, +0, &lt;em&gt;m&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_tostring&lt;/code&gt; [-0, +0, &lt;em&gt;m&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="e8d8a7c874870b0198c1a9b7c8f6d3c505824583" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_tothread&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_tothread&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="2d3423346c67cf164db6ad8970bd4f2222cb7fb8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_touserdata&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_touserdata&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="c0476212a8a15366d6ce4f81f04d030827e0066d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_type&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_type&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="f96cc4b0e1232bc22121e6810d74b42c2b1d3e06" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_typename&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_typename&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="91a931321e8502b23d51c1a0a5c98f0c4165be7a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_upvalueid&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_upvalueid&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="0ac955e136a22fb0a5cd4db3550046e858514163" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_upvalueindex&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_upvalueindex&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="27e8b4001de191561a219319ddfcf067f1e183b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_upvaluejoin&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_upvaluejoin&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="457f873509336f31072e0a6dc8f411b538781818" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_version&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_version&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="265bc6c117d9a588aff02b367a9614e5bd73dc11" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_warning&lt;/code&gt;[-0, +0, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_warning&lt;/code&gt; [-0, +0, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="bcb44f56e283569bb547217712306f8852f22cc2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_xmove&lt;/code&gt;[-?, +?, &amp;ndash;]</source>
          <target state="translated">&lt;code&gt;lua_xmove&lt;/code&gt; [-?, + ?, &amp;ndash;]</target>
        </trans-unit>
        <trans-unit id="76eecec65311fcc388227c521b10b1a314479323" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_yield&lt;/code&gt;[-?, +?, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_yield&lt;/code&gt; [-?, + ?, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="7310616b3bd3a7e949a6af634a8d1956eb6636ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_yield&lt;/code&gt;[-?, +?, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_yield&lt;/code&gt; [-?, + ?, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="81c6c643ec495e4991ca6c7475dab89f182c2cfa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_yieldk&lt;/code&gt;[-?, +?, &lt;em&gt;e&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_yieldk&lt;/code&gt; [-?, + ?, &lt;em&gt;e&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="c88bfed3d8a26d6ced5ab607211598d3a7aa8c93" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua_yieldk&lt;/code&gt;[-?, +?, &lt;em&gt;v&lt;/em&gt;]</source>
          <target state="translated">&lt;code&gt;lua_yieldk&lt;/code&gt; [-?, + ?, &lt;em&gt;v&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="96b82c4509109433cf6af1e0be37d96a7fd94922" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n&lt;/code&gt;: a &lt;code&gt;lua_Number&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; : &lt;code&gt;lua_Number&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7b29a4583bd00c0104cbe887c8111b95b42c3a09" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&lt;/code&gt;:  a reasonable name for the given function. Because functions in Lua are first-class values, they do not have a fixed name: some functions can be the value of multiple global variables, while others can be stored only in a table field. The &lt;code&gt;lua_getinfo&lt;/code&gt; function checks how the function was called to find a suitable name. If it cannot find a name, then &lt;code&gt;name&lt;/code&gt; is set to &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; : 주어진 함수에 대한 합리적인 이름. Lua의 함수는 일류 값이므로 고정 된 이름이 없습니다. 일부 함수는 여러 전역 변수의 값이 될 수있는 반면 다른 함수는 테이블 필드에만 저장할 수 있습니다. &lt;code&gt;lua_getinfo&lt;/code&gt; 를의 기능 점검 기능은 적당한 이름을 찾기 위해 호출 된 방법에 대해 설명합니다. 이름을 찾을 수 없으면 &lt;code&gt;name&lt;/code&gt; 은 &lt;code&gt;NULL&lt;/code&gt; 로 설정 됩니다 .</target>
        </trans-unit>
        <trans-unit id="18c79c193a99a81d7281723cef6c12912cbf6433" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;namewhat&lt;/code&gt;:  explains the &lt;code&gt;name&lt;/code&gt; field. The value of &lt;code&gt;namewhat&lt;/code&gt; can be &lt;code&gt;&quot;global&quot;&lt;/code&gt;, &lt;code&gt;&quot;local&quot;&lt;/code&gt;, &lt;code&gt;&quot;method&quot;&lt;/code&gt;, &lt;code&gt;&quot;field&quot;&lt;/code&gt;, &lt;code&gt;&quot;upvalue&quot;&lt;/code&gt;, or &lt;code&gt;&quot;&quot;&lt;/code&gt; (the empty string), according to how the function was called. (Lua uses the empty string when no other option seems to apply.)</source>
          <target state="translated">&lt;code&gt;namewhat&lt;/code&gt; : &lt;code&gt;name&lt;/code&gt; 필드를 설명합니다 . 값 &lt;code&gt;namewhat&lt;/code&gt; 가 될 수있다 &lt;code&gt;&quot;global&quot;&lt;/code&gt; , &lt;code&gt;&quot;local&quot;&lt;/code&gt; , &lt;code&gt;&quot;method&quot;&lt;/code&gt; , &lt;code&gt;&quot;field&quot;&lt;/code&gt; , &lt;code&gt;&quot;upvalue&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;&quot;&lt;/code&gt; 함수가 호출 방법에있어서, (빈 문자열). (Lua는 다른 옵션이 적용되지 않는 경우 빈 문자열을 사용합니다.)</target>
        </trans-unit>
        <trans-unit id="1fa95e55dd4784388ede4cc0ae537a28a3080930" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nparams&lt;/code&gt;:  the number of fixed parameters of the function (always 0 for C functions).</source>
          <target state="translated">&lt;code&gt;nparams&lt;/code&gt; : 함수의 고정 매개 변수 수입니다 (C 함수의 경우 항상 0).</target>
        </trans-unit>
        <trans-unit id="b89c13db828677a2e0156fd78311a0569af50363" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nparams&lt;/code&gt;:  the number of parameters of the function (always 0 for C functions).</source>
          <target state="translated">&lt;code&gt;nparams&lt;/code&gt; : 함수의 매개 변수 수 (C 함수의 경우 항상 0).</target>
        </trans-unit>
        <trans-unit id="a8154c866352ae7aa98001049b8f3d7bacc109ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ntransfer&lt;/code&gt;:  The number of values being transferred (see previous item). (For calls of Lua functions, this value is always equal to &lt;code&gt;nparams&lt;/code&gt;.)</source>
          <target state="translated">&lt;code&gt;ntransfer&lt;/code&gt; : 전송중인 값의 수 (이전 항목 참조). (Lua 함수 호출의 경우이 값은 항상 &lt;code&gt;nparams&lt;/code&gt; 와 같습니다 .)</target>
        </trans-unit>
        <trans-unit id="f379a6299ba3a449833511efbfb031b2dee8fac9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nups&lt;/code&gt;:  the number of upvalues of the function.</source>
          <target state="translated">&lt;code&gt;nups&lt;/code&gt; : 함수의 상한값 수입니다.</target>
        </trans-unit>
        <trans-unit id="3afc1431e3aae979f726ea70b785e9f045e81a13" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;s[&lt;em&gt;n&lt;/em&gt;]&lt;/code&gt;: a string preceded by its length coded as an unsigned integer with &lt;code&gt;n&lt;/code&gt; bytes (default is a &lt;code&gt;size_t&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;s[&lt;em&gt;n&lt;/em&gt;]&lt;/code&gt; : &lt;code&gt;n&lt;/code&gt; 바이트 의 부호없는 정수로 코딩 된 길이 앞에 오는 문자열 (기본값은 &lt;code&gt;size_t&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="41b71842909a6cbea5231fb02ae01a15bb5d7485" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;short_src&lt;/code&gt;:  a &quot;printable&quot; version of &lt;code&gt;source&lt;/code&gt;, to be used in error messages.</source>
          <target state="translated">&lt;code&gt;short_src&lt;/code&gt; : 오류 메시지에 사용되는 &quot;인쇄 가능한&quot; &lt;code&gt;source&lt;/code&gt; 버전 .</target>
        </trans-unit>
        <trans-unit id="8c0e50b9fe2c50cd274f54eaadc1fbca633a98ef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;source&lt;/code&gt;:  the name of the chunk that created the function. If &lt;code&gt;source&lt;/code&gt; starts with a '&lt;code&gt;@&lt;/code&gt;', it means that the function was defined in a file where the file name follows the '&lt;code&gt;@&lt;/code&gt;'. If &lt;code&gt;source&lt;/code&gt; starts with a '&lt;code&gt;=&lt;/code&gt;', the remainder of its contents describe the source in a user-dependent manner. Otherwise, the function was defined in a string where &lt;code&gt;source&lt;/code&gt; is that string.</source>
          <target state="translated">&lt;code&gt;source&lt;/code&gt; : 함수를 생성 한 청크 이름. 경우 &lt;code&gt;source&lt;/code&gt; 로 시작 ' &lt;code&gt;@&lt;/code&gt; ', 파일 이름은 다음 경우 함수가 파일에 정의되어 있음을 의미 '를 &lt;code&gt;@&lt;/code&gt; '. 경우 &lt;code&gt;source&lt;/code&gt; 에 '로 시작 &lt;code&gt;=&lt;/code&gt; ', 그 내용의 나머지 부분은 사용자 의존적으로 소스를 설명합니다. 그렇지 않으면, &lt;code&gt;source&lt;/code&gt; 가 해당 문자열 인 문자열에 함수가 정의되었습니다 .</target>
        </trans-unit>
        <trans-unit id="c1690813c08276efafb611b9118e1d8d238f1ab6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;source&lt;/code&gt;:  the source of the chunk that created the function. If &lt;code&gt;source&lt;/code&gt; starts with a '&lt;code&gt;@&lt;/code&gt;', it means that the function was defined in a file where the file name follows the '&lt;code&gt;@&lt;/code&gt;'. If &lt;code&gt;source&lt;/code&gt; starts with a '&lt;code&gt;=&lt;/code&gt;', the remainder of its contents describes the source in a user-dependent manner. Otherwise, the function was defined in a string where &lt;code&gt;source&lt;/code&gt; is that string.</source>
          <target state="translated">&lt;code&gt;source&lt;/code&gt; : 함수를 생성 한 청크의 소스. 경우 &lt;code&gt;source&lt;/code&gt; 로 시작 ' &lt;code&gt;@&lt;/code&gt; ', 파일 이름은 다음 경우 함수가 파일에 정의되어 있음을 의미 '를 &lt;code&gt;@&lt;/code&gt; '. 경우 &lt;code&gt;source&lt;/code&gt; 에 '로 시작 &lt;code&gt;=&lt;/code&gt; ', 그 내용의 나머지 부분은 사용자 의존적으로 소스를 설명합니다. 그렇지 않으면 함수가 &lt;code&gt;source&lt;/code&gt; 가 해당 문자열 인 문자열에 정의되었습니다 .</target>
        </trans-unit>
        <trans-unit id="866cb1591907e949f3206b7a8c507833d9980050" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;srclen&lt;/code&gt;:  The length of the string &lt;code&gt;source&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;srclen&lt;/code&gt; : 문자열 &lt;code&gt;source&lt;/code&gt; 의 길이 .</target>
        </trans-unit>
        <trans-unit id="d2ee7088a398a6c05a7c0875bb94a590aab08cfe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;what&lt;/code&gt;:  the string &lt;code&gt;&quot;Lua&quot;&lt;/code&gt; if the function is a Lua function, &lt;code&gt;&quot;C&quot;&lt;/code&gt; if it is a C function, &lt;code&gt;&quot;main&quot;&lt;/code&gt; if it is the main part of a chunk.</source>
          <target state="translated">&lt;code&gt;what&lt;/code&gt; : 함수가 루아 함수 인 경우 문자열 &lt;code&gt;&quot;Lua&quot;&lt;/code&gt; , C 함수 인 경우 &lt;code&gt;&quot;C&quot;&lt;/code&gt; , 청크의 주요 부분 인 경우 &lt;code&gt;&quot;main&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="87cd3c11f99f314ecc367ad79ade7d620b0027d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt;: one byte of padding</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; : 1 바이트의 패딩</target>
        </trans-unit>
        <trans-unit id="001502b0ce7e783ed32ff78090d4ed094c235365" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;z&lt;/code&gt;: a zero-terminated string</source>
          <target state="translated">&lt;code&gt;z&lt;/code&gt; : 0으로 끝나는 문자열</target>
        </trans-unit>
        <trans-unit id="35770f2a3e697f3d7fc1b9f9a92ee552d22bf261" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;|&lt;/code&gt;: bitwise OR</source>
          <target state="translated">&lt;code&gt;|&lt;/code&gt; 비트 OR</target>
        </trans-unit>
        <trans-unit id="7d6fd4ec60e16166466f316ad472a99346ef7ce9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;~&lt;/code&gt;: bitwise exclusive OR</source>
          <target state="translated">&lt;code&gt;~&lt;/code&gt; : 비트 배타적 OR</target>
        </trans-unit>
        <trans-unit id="96b4aa7e1aec2aa10ad8536c6f27c6c544521708" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;~&lt;/code&gt;: unary bitwise NOT</source>
          <target state="translated">&lt;code&gt;~&lt;/code&gt; : 단항 비트 NOT</target>
        </trans-unit>
        <trans-unit id="acd6d8cce51a342c5b90bb1907903a7f4dbad3e9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;~=&lt;/code&gt;: inequality</source>
          <target state="translated">&lt;code&gt;~=&lt;/code&gt; : 불평등</target>
        </trans-unit>
        <trans-unit id="238467efd8a53a80c3098a6aa184ff8c3f711e2f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Names&lt;/em&gt; (also called &lt;em&gt;identifiers&lt;/em&gt;) in Lua can be any string of Latin letters, Arabic-Indic digits, and underscores, not beginning with a digit and not being a reserved word. Identifiers are used to name variables, table fields, and labels.</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;Lua에서 &lt;em&gt;이름&lt;/em&gt; ( &lt;em&gt;식별자&lt;/em&gt; 라고도 함 )은 숫자로 시작하지 않고 예약어가 아닌 라틴 문자, 아랍어-인도 숫자 및 밑줄로 구성된 문자열 일 수 있습니다. 식별자는 변수, 테이블 필드 및 레이블의 이름을 지정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="aa7f065407772e44a51b8ffb896bf3e031ec8b94" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Names&lt;/em&gt; (also called &lt;em&gt;identifiers&lt;/em&gt;) in Lua can be any string of letters, digits, and underscores, not beginning with a digit and not being a reserved word. Identifiers are used to name variables, table fields, and labels.</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;Lua의 &lt;em&gt;이름&lt;/em&gt; ( &lt;em&gt;식별자&lt;/em&gt; 라고도 함 )은 숫자로 시작하지 않고 예약어가 아닌 문자, 숫자 및 밑줄 문자열 일 수 있습니다. 식별자는 변수, 테이블 필드 및 레이블의 이름을 지정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4aadb70307c23ca740f6eccdee86415794b36e75" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;break&lt;/b&gt; ends the innermost enclosing loop.</source>
          <target state="translated">&lt;b&gt;휴식은&lt;/b&gt; 가장 안쪽 둘러싸는 루프를 종료합니다.</target>
        </trans-unit>
        <trans-unit id="144235cbc1ccef915119f45152ac47c5119d150b" translate="yes" xml:space="preserve">
          <source>A &lt;b&gt;for&lt;/b&gt; statement like</source>
          <target state="translated">&lt;b&gt;에 대한&lt;/b&gt; 같은 문</target>
        </trans-unit>
        <trans-unit id="8da2571ab7c7e060c4976d340da392d89313fdab" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;character class&lt;/em&gt; is used to represent a set of characters. The following combinations are allowed in describing a character class:</source>
          <target state="translated">&lt;em&gt;문자 클래스는&lt;/em&gt; 문자 집합을 나타내는 데 사용됩니다. 문자 클래스를 설명 할 때 다음 조합이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="6521449c4ee4c82942f2111c4b00036b21741299" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;comment&lt;/em&gt; starts with a double hyphen (&lt;code&gt;--&lt;/code&gt;) anywhere outside a string. If the text immediately after &lt;code&gt;--&lt;/code&gt; is not an opening long bracket, the comment is a &lt;em&gt;short comment&lt;/em&gt;, which runs until the end of the line. Otherwise, it is a &lt;em&gt;long comment&lt;/em&gt;, which runs until the corresponding closing long bracket.</source>
          <target state="translated">&lt;em&gt;코멘트&lt;/em&gt; (이중 하이픈으로 시작 &lt;code&gt;--&lt;/code&gt; 어디서든 외부 문자열). &lt;code&gt;--&lt;/code&gt; 바로 뒤의 텍스트 가 여는 긴 대괄호가 아닌 경우 &lt;em&gt;주석은&lt;/em&gt; 줄 끝까지 실행 되는 &lt;em&gt;짧은 주석&lt;/em&gt; 입니다. 그렇지 않으면 &lt;em&gt;긴 주석&lt;/em&gt; 이며 해당 닫는 긴 괄호까지 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="11942e741b80827f49b57cea2ee7a3083c5c5105" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;comment&lt;/em&gt; starts with a double hyphen (&lt;code&gt;--&lt;/code&gt;) anywhere outside a string. If the text immediately after &lt;code&gt;--&lt;/code&gt; is not an opening long bracket, the comment is a &lt;em&gt;short comment&lt;/em&gt;, which runs until the end of the line. Otherwise, it is a &lt;em&gt;long comment&lt;/em&gt;, which runs until the corresponding closing long bracket. Long comments are frequently used to disable code temporarily.</source>
          <target state="translated">&lt;em&gt;코멘트&lt;/em&gt; (이중 하이픈으로 시작 &lt;code&gt;--&lt;/code&gt; 어디서든 외부 문자열). 텍스트 직후가있는 경우 &lt;code&gt;--&lt;/code&gt; 오프닝 긴 브래킷 아닌, 코멘트는 것입니다 &lt;em&gt;짧은 코멘트&lt;/em&gt; 라인이 끝날 때까지 실행됩니다. 그렇지 않으면 &lt;em&gt;긴 주석&lt;/em&gt; 이며 해당하는 긴 긴 브래킷까지 실행됩니다. 긴 주석은 코드를 일시적으로 비활성화하는 데 자주 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9c0d21ff2fd9949d24c6794532468cb40838f88b" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;numeric constant&lt;/em&gt; (or &lt;em&gt;numeral&lt;/em&gt;) can be written with an optional fractional part and an optional decimal exponent, marked by a letter '&lt;code&gt;e&lt;/code&gt;' or '&lt;code&gt;E&lt;/code&gt;'. Lua also accepts hexadecimal constants, which start with &lt;code&gt;0x&lt;/code&gt; or &lt;code&gt;0X&lt;/code&gt;. Hexadecimal constants also accept an optional fractional part plus an optional binary exponent, marked by a letter '&lt;code&gt;p&lt;/code&gt;' or '&lt;code&gt;P&lt;/code&gt;'.</source>
          <target state="translated">&lt;em&gt;숫자 상수&lt;/em&gt; (또는 &lt;em&gt;번호&lt;/em&gt; ) 선택적 소수부와 함께 기록 할 수있는 문자 '로 표시 선택적 소수점 지수, &lt;code&gt;e&lt;/code&gt; '또는 ' &lt;code&gt;E&lt;/code&gt; '. Lua는 또한 &lt;code&gt;0x&lt;/code&gt; 또는 &lt;code&gt;0X&lt;/code&gt; 로 시작하는 16 진수 상수를 허용 합니다. 16 진 상수는 또한 문자 ' &lt;code&gt;p&lt;/code&gt; '또는 ' &lt;code&gt;P&lt;/code&gt; ' 로 표시된 선택적 소수 부분과 선택적 이진 지수를 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="45246a537ee28cdd862e9e3b659c6215f07e13a0" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;numeric constant&lt;/em&gt; (or &lt;em&gt;numeral&lt;/em&gt;) can be written with an optional fractional part and an optional decimal exponent, marked by a letter '&lt;code&gt;e&lt;/code&gt;' or '&lt;code&gt;E&lt;/code&gt;'. Lua also accepts hexadecimal constants, which start with &lt;code&gt;0x&lt;/code&gt; or &lt;code&gt;0X&lt;/code&gt;. Hexadecimal constants also accept an optional fractional part plus an optional binary exponent, marked by a letter '&lt;code&gt;p&lt;/code&gt;' or '&lt;code&gt;P&lt;/code&gt;'. A numeric constant with a radix point or an exponent denotes a float; otherwise, if its value fits in an integer, it denotes an integer. Examples of valid integer constants are</source>
          <target state="translated">&lt;em&gt;숫자 상수&lt;/em&gt; (또는 &lt;em&gt;번호&lt;/em&gt; ) 선택적 소수부와 함께 기록 할 수있는 문자 '로 표시 선택적 소수점 지수, &lt;code&gt;e&lt;/code&gt; '또는 ' &lt;code&gt;E&lt;/code&gt; '. Lua는 16 진수 상수를 허용하며, &lt;code&gt;0x&lt;/code&gt; 또는 &lt;code&gt;0X&lt;/code&gt; 로 시작 합니다. 16 진 상수는 선택적인 분수 부분과 ' &lt;code&gt;p&lt;/code&gt; '또는 ' &lt;code&gt;P&lt;/code&gt; ' 문자로 표시된 선택적 2 진 지수를 허용합니다 . 기수 또는 지수가있는 숫자 상수는 부동 소수점을 나타냅니다. 그렇지 않으면 값이 정수에 맞는 경우 정수를 나타냅니다. 유효한 정수 상수의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="43c4164c55abb7933faf258648b8253172e7ddaf" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;pattern item&lt;/em&gt; can be</source>
          <target state="translated">&lt;em&gt;패턴 항목이&lt;/em&gt; 될 수 있습니다</target>
        </trans-unit>
        <trans-unit id="9b3f67e64fdd3547c2b4af7f1362a66a7279295d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;pattern&lt;/em&gt; is a sequence of pattern items. A caret '&lt;code&gt;^&lt;/code&gt;' at the beginning of a pattern anchors the match at the beginning of the subject string. A '&lt;code&gt;$&lt;/code&gt;' at the end of a pattern anchors the match at the end of the subject string. At other positions, '&lt;code&gt;^&lt;/code&gt;' and '&lt;code&gt;$&lt;/code&gt;' have no special meaning and represent themselves.</source>
          <target state="translated">&lt;em&gt;무늬&lt;/em&gt; 패턴 항목의 시퀀스이다. 패턴의 시작 부분에있는 캐럿 ' &lt;code&gt;^&lt;/code&gt; '은 제목 문자열의 시작 부분에 일치 항목을 고정시킵니다. 패턴의 끝에서 ' &lt;code&gt;$&lt;/code&gt; '는 제목 문자열의 끝에서 일치를 고정시킵니다. 다른 위치에서 ' &lt;code&gt;^&lt;/code&gt; '및 ' &lt;code&gt;$&lt;/code&gt; '는 특별한 의미가 없으며 자신을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c9d93dadd47fb17d5c1f30a2f6969069891cffbe" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;short literal string&lt;/em&gt; can be delimited by matching single or double quotes, and can contain the following C-like escape sequences: '&lt;code&gt;\a&lt;/code&gt;' (bell), '&lt;code&gt;\b&lt;/code&gt;' (backspace), '&lt;code&gt;\f&lt;/code&gt;' (form feed), '&lt;code&gt;\n&lt;/code&gt;' (newline), '&lt;code&gt;\r&lt;/code&gt;' (carriage return), '&lt;code&gt;\t&lt;/code&gt;' (horizontal tab), '&lt;code&gt;\v&lt;/code&gt;' (vertical tab), '&lt;code&gt;\\&lt;/code&gt;' (backslash), '&lt;code&gt;\&quot;&lt;/code&gt;' (quotation mark [double quote]), and '&lt;code&gt;\'&lt;/code&gt;' (apostrophe [single quote]). A backslash followed by a line break results in a newline in the string. The escape sequence '&lt;code&gt;\z&lt;/code&gt;' skips the following span of white-space characters, including line breaks; it is particularly useful to break and indent a long literal string into multiple lines without adding the newlines and spaces into the string contents. A short literal string cannot contain unescaped line breaks nor escapes not forming a valid escape sequence.</source>
          <target state="translated">&lt;em&gt;짧은 문자 스트링은&lt;/em&gt; 하나 또는 따옴표 일치로 구분 될 수 있으며, 다음의 C 형 이스케이프 시퀀스를 포함 할 수있다 : ' &lt;code&gt;\a&lt;/code&gt; '(종), ' &lt;code&gt;\b&lt;/code&gt; '(백 스페이스), ' &lt;code&gt;\f&lt;/code&gt; '(용지 공급) ' &lt;code&gt;\n&lt;/code&gt; '(줄 바꿈), ' &lt;code&gt;\r&lt;/code&gt; '(캐리지 리턴), ' &lt;code&gt;\t&lt;/code&gt; '(가로 탭), ' &lt;code&gt;\v&lt;/code&gt; '(세로 탭), ' &lt;code&gt;\\&lt;/code&gt; '(백 슬래시), ' &lt;code&gt;\&quot;&lt;/code&gt; '(따옴표 [큰 따옴표]) 및 ' &lt;code&gt;\'&lt;/code&gt; '(아포스트로피 [단일 따옴표]) 백 슬래시와 줄 바꿈은 문자열에 줄 바꿈이됩니다. 이스케이프 시퀀스' &lt;code&gt;\z&lt;/code&gt; '는 줄 바꿈을 포함하여 다음 공백 문자 범위를 건너 뜁니다. 줄 바꿈과 공백을 문자열 내용에 추가하지 않고 긴 리터럴 문자열을 여러 줄로 나누고 들여 쓰는 것이 특히 유용합니다. 짧은 리터럴 문자열에는 이스케이프 처리되지 않은 줄 바꿈이나 이스케이프 처리가 올바른 이스케이프 시퀀스를 포함 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1e7ea716b5530b0c3020375c0eec5ca84501ca10" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;short literal string&lt;/em&gt; can be delimited by matching single or double quotes, and can contain the following C-like escape sequences: '&lt;code&gt;\a&lt;/code&gt;' (bell), '&lt;code&gt;\b&lt;/code&gt;' (backspace), '&lt;code&gt;\f&lt;/code&gt;' (form feed), '&lt;code&gt;\n&lt;/code&gt;' (newline), '&lt;code&gt;\r&lt;/code&gt;' (carriage return), '&lt;code&gt;\t&lt;/code&gt;' (horizontal tab), '&lt;code&gt;\v&lt;/code&gt;' (vertical tab), '&lt;code&gt;\\&lt;/code&gt;' (backslash), '&lt;code&gt;\&quot;&lt;/code&gt;' (quotation mark [double quote]), and '&lt;code&gt;\'&lt;/code&gt;' (apostrophe [single quote]). A backslash followed by a line break results in a newline in the string. The escape sequence '&lt;code&gt;\z&lt;/code&gt;' skips the following span of whitespace characters, including line breaks; it is particularly useful to break and indent a long literal string into multiple lines without adding the newlines and spaces into the string contents. A short literal string cannot contain unescaped line breaks nor escapes not forming a valid escape sequence.</source>
          <target state="translated">&lt;em&gt;짧은 문자 스트링은&lt;/em&gt; 하나 또는 따옴표 일치로 구분 될 수 있으며, 다음의 C 형 이스케이프 시퀀스를 포함 할 수있다 : ' &lt;code&gt;\a&lt;/code&gt; '(종), ' &lt;code&gt;\b&lt;/code&gt; '(백 스페이스), ' &lt;code&gt;\f&lt;/code&gt; '(용지 공급) ' &lt;code&gt;\n&lt;/code&gt; '(줄 바꿈), ' &lt;code&gt;\r&lt;/code&gt; '(캐리지 리턴), ' &lt;code&gt;\t&lt;/code&gt; '(가로 탭), ' &lt;code&gt;\v&lt;/code&gt; '(세로 탭), ' &lt;code&gt;\\&lt;/code&gt; '(백 슬래시), ' &lt;code&gt;\&quot;&lt;/code&gt; '(따옴표 [큰 따옴표]) 및 ' &lt;code&gt;\'&lt;/code&gt; '(아포스트로피 [작은 따옴표]). 백 슬래시 뒤에 줄 바꿈이 있으면 문자열에서 줄 바꿈이됩니다. 이스케이프 시퀀스' &lt;code&gt;\z&lt;/code&gt; '는 줄 바꿈을 포함하여 다음 공백 문자 범위를 건너 뜁니다. 문자열 내용에 줄 바꿈과 공백을 추가하지 않고 긴 리터럴 문자열을 여러 줄로 나누고 들여 쓰는 것이 특히 유용합니다. 짧은 리터럴 문자열에는 이스케이프 처리되지 않은 줄 바꿈이나 유효한 이스케이프 시퀀스를 형성하지 않는 이스케이프가 포함될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="703f78edc26aa73fc795a76d8b68cf8ffb10eeab" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;valid index&lt;/em&gt; is an index that refers to a position that stores a modifiable Lua value. It comprises stack indices between 1 and the stack top (&lt;code&gt;1 &amp;le; abs(index) &amp;le; top&lt;/code&gt;) plus &lt;em&gt;pseudo-indices&lt;/em&gt;, which represent some positions that are accessible to C code but that are not in the stack. Pseudo-indices are used to access the registry (see &lt;a href=&quot;#4.3&quot;&gt;&amp;sect;4.3&lt;/a&gt;) and the upvalues of a C function (see &lt;a href=&quot;#4.2&quot;&gt;&amp;sect;4.2&lt;/a&gt;).</source>
          <target state="translated">&lt;em&gt;유효 인덱스&lt;/em&gt; 위치에 저장하는 수정 가능한 루아 값을 참조하는 인덱스이다. 1과 스택 상단 ( &lt;code&gt;1 &amp;le; abs(index) &amp;le; top&lt;/code&gt; ) 사이의 스택 인덱스와 C 코드에 액세스 할 수 있지만 스택에없는 일부 위치를 나타내는 &lt;em&gt;의사 인덱스&lt;/em&gt; 로 구성됩니다. 의사 - 지수는 레지스트리 (참조에 액세스하는 데 사용되는 &lt;a href=&quot;#4.3&quot;&gt;&amp;sect;4.3&lt;/a&gt; ) 및 C 함수를 upvalues (참조 &lt;a href=&quot;#4.2&quot;&gt;&amp;sect;4.2&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="28b71986dee98cd86a5bb65ac2e321dbab699546" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;valid index&lt;/em&gt; is an index that refers to a position that stores a modifiable Lua value. It comprises stack indices between 1 and the stack top (&lt;code&gt;1 &amp;le; abs(index) &amp;le; top&lt;/code&gt;) plus &lt;em&gt;pseudo-indices&lt;/em&gt;, which represent some positions that are accessible to C code but that are not in the stack. Pseudo-indices are used to access the registry (see &lt;a href=&quot;#4.5&quot;&gt;&amp;sect;4.5&lt;/a&gt;) and the upvalues of a C function (see &lt;a href=&quot;#4.4&quot;&gt;&amp;sect;4.4&lt;/a&gt;).</source>
          <target state="translated">&lt;em&gt;유효 인덱스&lt;/em&gt; 위치에 저장하는 수정 가능한 루아 값을 참조하는 인덱스이다. 1과 스택 상단 ( &lt;code&gt;1 &amp;le; abs(index) &amp;le; top&lt;/code&gt; )과 &lt;em&gt;의사&lt;/em&gt; 표시를 포함하는 스택 인덱스로 구성 되며 C 코드에는 액세스 할 수 있지만 스택에는없는 일부 위치를 나타냅니다. 의사 표시는 레지스트리에 액세스하는 데 사용되고 ( &lt;a href=&quot;#4.5&quot;&gt;&amp;sect;4.5&lt;/a&gt; 참조 ) C 함수의 최대 값 ( &lt;a href=&quot;#4.4&quot;&gt;&amp;sect;4.4&lt;/a&gt; 참조 )을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="cc2ccfd57dd2ee13db0881ad932f1a878faf0c64" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;weak table&lt;/em&gt; is a table whose elements are &lt;em&gt;weak references&lt;/em&gt;. A weak reference is ignored by the garbage collector. In other words, if the only references to an object are weak references, then the garbage collector will collect that object.</source>
          <target state="translated">&lt;em&gt;약한 테이블&lt;/em&gt; 요소가 테이블이다 &lt;em&gt;약한 참조&lt;/em&gt; . 약한 참조는 가비지 수집기에서 무시됩니다. 즉, 객체에 대한 유일한 참조가 약한 참조 인 경우 가비지 수집기는 해당 객체를 수집합니다.</target>
        </trans-unit>
        <trans-unit id="838899562d596fefd844e484608aa6e4c2922871" translate="yes" xml:space="preserve">
          <source>A C closure can also change the values of its corresponding upvalues.</source>
          <target state="translated">AC 클로저는 또한 해당 upvalue의 값을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fa55e8031d6eb3c6d20f33859dde00134235bf3" translate="yes" xml:space="preserve">
          <source>A block can be explicitly delimited to produce a single statement:</source>
          <target state="translated">단일 명령문을 생성하기 위해 블록을 명시 적으로 구분할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec51a298084d5b31d4dab8833e20239393ee6e1e" translate="yes" xml:space="preserve">
          <source>A block is a list of statements, which are executed sequentially:</source>
          <target state="translated">블록은 명령문의 목록으로, 순차적으로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="1a46bdc4d8fc003e74bbca9567f9845260ef3e19" translate="yes" xml:space="preserve">
          <source>A call of the form &lt;code&gt;return &lt;em&gt;functioncall&lt;/em&gt;&lt;/code&gt; is called a &lt;em&gt;tail call&lt;/em&gt;. Lua implements &lt;em&gt;proper tail calls&lt;/em&gt; (or &lt;em&gt;proper tail recursion&lt;/em&gt;): in a tail call, the called function reuses the stack entry of the calling function. Therefore, there is no limit on the number of nested tail calls that a program can execute. However, a tail call erases any debug information about the calling function. Note that a tail call only happens with a particular syntax, where the &lt;b&gt;return&lt;/b&gt; has one single function call as argument; this syntax makes the calling function return exactly the returns of the called function. So, none of the following examples are tail calls:</source>
          <target state="translated">&lt;code&gt;return &lt;em&gt;functioncall&lt;/em&gt;&lt;/code&gt; 호출 양식의 호출을 &lt;em&gt;테일 호출&lt;/em&gt; 이라고합니다 . Lua는 &lt;em&gt;적절한 꼬리 호출&lt;/em&gt; (또는 &lt;em&gt;적절한 꼬리 재귀&lt;/em&gt; )을 구현 &lt;em&gt;합니다. 꼬리 호출&lt;/em&gt; 에서 호출 된 함수는 호출 함수의 스택 항목을 재사용합니다. 따라서 프로그램이 실행할 수있는 중첩 테일 호출 수에는 제한이 없습니다. 그러나 테일 호출은 호출 기능에 대한 디버그 정보를 지 웁니다. 테일 호출은 특정 구문에서만 발생하며 &lt;b&gt;반환 값&lt;/b&gt; 에는 인수로 단일 함수 호출이 하나 있습니다. 이 구문은 호출 함수가 호출 된 함수의 리턴을 정확하게 리턴하도록합니다. 따라서 다음 예는 꼬리 호출이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="6a544d7768ac7a0cdc7058530f1bcb86b6f1bcbf" translate="yes" xml:space="preserve">
          <source>A call of the form &lt;code&gt;return &lt;em&gt;functioncall&lt;/em&gt;&lt;/code&gt; not in the scope of a to-be-closed variable is called a &lt;em&gt;tail call&lt;/em&gt;. Lua implements &lt;em&gt;proper tail calls&lt;/em&gt; (or &lt;em&gt;proper tail recursion&lt;/em&gt;): in a tail call, the called function reuses the stack entry of the calling function. Therefore, there is no limit on the number of nested tail calls that a program can execute. However, a tail call erases any debug information about the calling function. Note that a tail call only happens with a particular syntax, where the &lt;b&gt;return&lt;/b&gt; has one single function call as argument, and it is outside the scope of any to-be-closed variable. This syntax makes the calling function return exactly the returns of the called function, without any intervening action. So, none of the following examples are tail calls:</source>
          <target state="translated">닫힐 변수의 범위에 있지 않은 &lt;code&gt;return &lt;em&gt;functioncall&lt;/em&gt;&lt;/code&gt; 형식의 호출을 &lt;em&gt;마무리 호출&lt;/em&gt; 이라고합니다 . Lua는 &lt;em&gt;적절한 마무리 호출&lt;/em&gt; (또는 &lt;em&gt;적절한 마무리 재귀&lt;/em&gt; )을 구현 &lt;em&gt;합니다. 마무리 호출&lt;/em&gt; 에서 호출 된 함수는 호출 함수의 스택 항목을 재사용합니다. 따라서 프로그램이 실행할 수있는 중첩 된 마무리 호출의 수에는 제한이 없습니다. 그러나 마무리 호출은 호출 함수에 대한 모든 디버그 정보를 지 웁니다. 꼬리 호출은 특정 구문은 함께 발생합니다 &lt;b&gt;반환&lt;/b&gt;인수로 하나의 단일 함수 호출이 있으며 닫을 변수의 범위를 벗어납니다. 이 구문은 호출 함수가 개입 작업없이 호출 된 함수의 반환 값을 정확하게 반환하도록합니다. 따라서 다음 예제는 꼬리 호출이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="d2afda0df1ca02ec9a60e9c8cfd19f5d2f5a92aa" translate="yes" xml:space="preserve">
          <source>A chunk can be stored in a file or in a string inside the host program. To execute a chunk, Lua first &lt;em&gt;loads&lt;/em&gt; it, precompiling the chunk's code into instructions for a virtual machine, and then Lua executes the compiled code with an interpreter for the virtual machine.</source>
          <target state="translated">청크는 파일이나 호스트 프로그램 내부의 문자열에 저장 될 수 있습니다. 청크를 실행하기 위해 Lua는 먼저 청크의 코드를 가상 머신에 대한 명령어로 사전 컴파일 한 후이를 &lt;em&gt;로드&lt;/em&gt; 한 다음 가상 머신에 대한 인터프리터로 컴파일 된 코드를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="c4ee67ff442e191f14dbdcdb9233561f4dc58f7c" translate="yes" xml:space="preserve">
          <source>A chunk is also a block (see &lt;a href=&quot;#3.3.2&quot;&gt;&amp;sect;3.3.2&lt;/a&gt;), and so local variables can be declared in a chunk outside any explicit block.</source>
          <target state="translated">청크도 블록 이므로 ( &lt;a href=&quot;#3.3.2&quot;&gt;&amp;sect;3.3.2&lt;/a&gt; 참조 ) 로컬 변수는 명시 적 블록 외부의 청크로 선언 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89f058cf87035dfffc923b06bddc388bf582fef2" translate="yes" xml:space="preserve">
          <source>A coroutine can terminate its execution in two ways: normally, when its main function returns (explicitly or implicitly, after the last instruction); and abnormally, if there is an unprotected error. In case of normal termination, &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt;&lt;code&gt;coroutine.resume&lt;/code&gt;&lt;/a&gt; returns &lt;b&gt;true&lt;/b&gt;, plus any values returned by the coroutine main function. In case of errors, &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt;&lt;code&gt;coroutine.resume&lt;/code&gt;&lt;/a&gt; returns &lt;b&gt;false&lt;/b&gt; plus an error object.</source>
          <target state="translated">코 루틴은 두 가지 방식으로 실행을 종료 할 수 있습니다. 일반적으로 주 함수가 반환 될 때 (명시 적으로 또는 암시 적으로, 마지막 명령 이후); 보호되지 않은 오류가있는 경우 비정상적으로 발생합니다. 정상 종료의 경우 &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt; &lt;code&gt;coroutine.resume&lt;/code&gt; &lt;/a&gt; 은 &lt;b&gt;true&lt;/b&gt; 를 포함하고 coroutine 기본 함수가 반환 한 값을 반환합니다. 에러가 발생하면 &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt; &lt;code&gt;coroutine.resume&lt;/code&gt; &lt;/a&gt; 은 &lt;b&gt;false&lt;/b&gt; 와 에러 객체를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="7fccab4c3a920129e8bc11d7ed566cc0bc58f02e" translate="yes" xml:space="preserve">
          <source>A coroutine can terminate its execution in two ways: normally, when its main function returns (explicitly or implicitly, after the last instruction); and abnormally, if there is an unprotected error. In case of normal termination, &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt;&lt;code&gt;coroutine.resume&lt;/code&gt;&lt;/a&gt; returns &lt;b&gt;true&lt;/b&gt;, plus any values returned by the coroutine main function. In case of errors, &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt;&lt;code&gt;coroutine.resume&lt;/code&gt;&lt;/a&gt; returns &lt;b&gt;false&lt;/b&gt; plus the error object. In this case, the coroutine does not unwind its stack, so that it is possible to inspect it after the error with the debug API.</source>
          <target state="translated">코 루틴은 두 가지 방법으로 실행을 종료 할 수 있습니다. 일반적으로 주 함수가 반환 될 때 (마지막 명령 이후에 명시 적으로 또는 암시 적으로); 비정상적으로 보호되지 않은 오류가있는 경우. 정상적인 종료의 경우 &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt; &lt;code&gt;coroutine.resume&lt;/code&gt; &lt;/a&gt; 은 &lt;b&gt;true&lt;/b&gt; 와 코 루틴 주 함수가 반환 한 모든 값을 반환합니다. 오류가 발생한 경우 &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt; &lt;code&gt;coroutine.resume&lt;/code&gt; &lt;/a&gt; 은 &lt;b&gt;false&lt;/b&gt; 와 오류 객체를 반환 합니다. 이 경우 코 루틴은 스택을 해제하지 않으므로 디버그 API로 오류가 발생한 후 검사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6847f15c1d2bb7a7eacf0b01a540f63bd1869ba2" translate="yes" xml:space="preserve">
          <source>A coroutine is yieldable if it is not the main thread and it is not inside a non-yieldable C function.</source>
          <target state="translated">코 루틴은 주 스레드가 아니고 양보 할 수없는 C 함수 내부에 있지 않으면 양보 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="27ee02330bdc9c7efb921e9fa622f05fad377bb4" translate="yes" xml:space="preserve">
          <source>A coroutine yields by calling &lt;a href=&quot;#pdf-coroutine.yield&quot;&gt;&lt;code&gt;coroutine.yield&lt;/code&gt;&lt;/a&gt;. When a coroutine yields, the corresponding &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt;&lt;code&gt;coroutine.resume&lt;/code&gt;&lt;/a&gt; returns immediately, even if the yield happens inside nested function calls (that is, not in the main function, but in a function directly or indirectly called by the main function). In the case of a yield, &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt;&lt;code&gt;coroutine.resume&lt;/code&gt;&lt;/a&gt; also returns &lt;b&gt;true&lt;/b&gt;, plus any values passed to &lt;a href=&quot;#pdf-coroutine.yield&quot;&gt;&lt;code&gt;coroutine.yield&lt;/code&gt;&lt;/a&gt;. The next time you resume the same coroutine, it continues its execution from the point where it yielded, with the call to &lt;a href=&quot;#pdf-coroutine.yield&quot;&gt;&lt;code&gt;coroutine.yield&lt;/code&gt;&lt;/a&gt; returning any extra arguments passed to &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt;&lt;code&gt;coroutine.resume&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">호출하여 코 루틴 수익률 &lt;a href=&quot;#pdf-coroutine.yield&quot;&gt; &lt;code&gt;coroutine.yield&lt;/code&gt; 을&lt;/a&gt; . 코 루틴이 생성되면 중첩 된 함수 호출 내에서 (즉, 주 함수가 아니라 주 함수에 의해 직접 또는 간접적으로 호출되는 함수) 생성이 발생하더라도 해당 &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt; &lt;code&gt;coroutine.resume&lt;/code&gt; &lt;/a&gt; 이 즉시 반환됩니다. 수확량의 경우 &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt; &lt;code&gt;coroutine.resume&lt;/code&gt; &lt;/a&gt; 은 &lt;b&gt;true&lt;/b&gt; 와 함께 &lt;a href=&quot;#pdf-coroutine.yield&quot;&gt; &lt;code&gt;coroutine.yield&lt;/code&gt; 에&lt;/a&gt; 전달 된 모든 값을 반환 &lt;b&gt;합니다&lt;/b&gt; . 같은 코 루틴을 다시 다음 번에, 그것은 호출로, 산출 시점에서의 실행을 계속 &lt;a href=&quot;#pdf-coroutine.yield&quot;&gt; &lt;code&gt;coroutine.yield&lt;/code&gt; &lt;/a&gt; 에 전달 된 추가 인수를 반환 &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt; &lt;code&gt;coroutine.resume&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eb3088438d805eed5e3fbd8b4df355ce4b0938eb" translate="yes" xml:space="preserve">
          <source>A detailed list of events controlled by metatables is given next. Each operation is identified by its corresponding key.</source>
          <target state="translated">메타 테이블로 제어되는 자세한 이벤트 목록이 다음에 제공됩니다. 각 작업은 해당 키로 식별됩니다.</target>
        </trans-unit>
        <trans-unit id="0a2cccdac31c8e35779223d73ad3e331960f13dd" translate="yes" xml:space="preserve">
          <source>A detailed list of operations controlled by metatables is given next. Each event is identified by its corresponding key. By convention, all metatable keys used by Lua are composed by two underscores followed by lowercase Latin letters.</source>
          <target state="translated">메타 테이블이 제어하는 ​​작업의 자세한 목록은 다음과 같습니다. 각 이벤트는 해당 키로 식별됩니다. 규칙에 따라 Lua에서 사용하는 모든 메타 테이블 키는 두 개의 밑줄과 소문자 라틴 문자로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="11ece8c655dc36e8d6319d68c95bcaac2d49dfe7" translate="yes" xml:space="preserve">
          <source>A file handle is implemented as a full userdata, with a metatable called &lt;code&gt;LUA_FILEHANDLE&lt;/code&gt; (where &lt;code&gt;LUA_FILEHANDLE&lt;/code&gt; is a macro with the actual metatable's name). The metatable is created by the I/O library (see &lt;a href=&quot;#luaL_newmetatable&quot;&gt;&lt;code&gt;luaL_newmetatable&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">파일 핸들은 &lt;code&gt;LUA_FILEHANDLE&lt;/code&gt; 이라는 메타 테이블과 함께 전체 사용자 데이터로 구현됩니다 (여기서 &lt;code&gt;LUA_FILEHANDLE&lt;/code&gt; 은 실제 메타 테이블 이름을 가진 매크로입니다). 메타 테이블은 I / O 라이브러리에 의해 작성됩니다 ( &lt;a href=&quot;#luaL_newmetatable&quot;&gt; &lt;code&gt;luaL_newmetatable&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="bd31b6026ec306c9598314c7a4fb9720392f25d4" translate="yes" xml:space="preserve">
          <source>A format string is a sequence of conversion options. The conversion options are as follows:</source>
          <target state="translated">형식 문자열은 일련의 변환 옵션입니다. 변환 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bbe12450770ac90f140b941579b60535c8af83cf" translate="yes" xml:space="preserve">
          <source>A function call in Lua has the following syntax:</source>
          <target state="translated">Lua의 함수 호출에는 다음과 같은 구문이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7922d23ba8fff84e8a26ef3f217d4b75923835cc" translate="yes" xml:space="preserve">
          <source>A function definition is an executable expression, whose value has type &lt;em&gt;function&lt;/em&gt;. When Lua precompiles a chunk, all its function bodies are precompiled too, but they are not created yet. Then, whenever Lua executes the function definition, the function is &lt;em&gt;instantiated&lt;/em&gt; (or &lt;em&gt;closed&lt;/em&gt;). This function instance, or &lt;em&gt;closure&lt;/em&gt;, is the final value of the expression.</source>
          <target state="translated">함수 정의는 값이 &lt;em&gt;function&lt;/em&gt; 유형 인 실행 가능한 표현식 입니다. Lua가 청크를 미리 컴파일 할 때 모든 함수 본문도 미리 컴파일되지만 아직 생성되지는 않습니다. 그런 다음 Lua가 함수 정의를 실행할 때마다 함수가 &lt;em&gt;인스턴스화&lt;/em&gt; (또는 &lt;em&gt;닫힘&lt;/em&gt; )됩니다. 이 함수 인스턴스 또는 &lt;em&gt;클로저&lt;/em&gt; 는 표현식의 최종 값입니다.</target>
        </trans-unit>
        <trans-unit id="0cb80c7bdf41b4df631b1f8aa57077bfb622b3ca" translate="yes" xml:space="preserve">
          <source>A function definition is an executable expression, whose value has type &lt;em&gt;function&lt;/em&gt;. When Lua precompiles a chunk, all its function bodies are precompiled too. Then, whenever Lua executes the function definition, the function is &lt;em&gt;instantiated&lt;/em&gt; (or &lt;em&gt;closed&lt;/em&gt;). This function instance (or &lt;em&gt;closure&lt;/em&gt;) is the final value of the expression.</source>
          <target state="translated">함수 정의는 실행 가능한 표현식이며 값은 type &lt;em&gt;함수&lt;/em&gt; 입니다. Lua가 청크를 사전 컴파일하면 모든 해당 기능 본문도 사전 컴파일됩니다. 그런 다음 Lua가 함수 정의를 실행할 때마다 함수가 &lt;em&gt;인스턴스화됩니다&lt;/em&gt; (또는 &lt;em&gt;닫힙니다&lt;/em&gt; ). 이 함수 인스턴스 (또는 &lt;em&gt;클로저&lt;/em&gt; )는 표현식의 최종 값입니다.</target>
        </trans-unit>
        <trans-unit id="def5b5d3fc526d80ec07c94970f2e05b00532d11" translate="yes" xml:space="preserve">
          <source>A global variable (not a function) that holds a string containing the running Lua version. The current value of this variable is &quot;&lt;code&gt;Lua 5.3&lt;/code&gt;&quot;.</source>
          <target state="translated">실행중인 Lua 버전이 포함 된 문자열을 보유하는 전역 변수 (함수가 아님). 이 변수의 현재 값은 &quot; &lt;code&gt;Lua 5.3&lt;/code&gt; &quot;입니다.</target>
        </trans-unit>
        <trans-unit id="cf9aec3d455800c4f1fa314bf548b9b77afeadfa" translate="yes" xml:space="preserve">
          <source>A global variable (not a function) that holds a string containing the running Lua version. The current value of this variable is &quot;&lt;code&gt;Lua 5.4&lt;/code&gt;&quot;.</source>
          <target state="translated">실행중인 Lua 버전을 포함하는 문자열을 보유하는 전역 변수 (함수 아님). 이 변수의 현재 값은 &quot; &lt;code&gt;Lua 5.4&lt;/code&gt; &quot;입니다.</target>
        </trans-unit>
        <trans-unit id="353c97fb2432c2d977afa942e47185d3456b4910" translate="yes" xml:space="preserve">
          <source>A global variable (not a function) that holds the global environment (see &lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt;). Lua itself does not use this variable; changing its value does not affect any environment, nor vice versa.</source>
          <target state="translated">전역 환경을 유지하는 전역 변수 (함수가 &lt;a href=&quot;#2.2&quot;&gt;아님&lt;/a&gt; ) ( &amp;sect;2.2 참조 ). 루아 자체는이 변수를 사용하지 않습니다. 값을 변경해도 환경에 영향을 미치지 않으며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="bb9da1771a20805caac7264030f37560221e3663" translate="yes" xml:space="preserve">
          <source>A hook is disabled by setting &lt;code&gt;mask&lt;/code&gt; to zero.</source>
          <target state="translated">&lt;code&gt;mask&lt;/code&gt; 를 0 으로 설정하면 후크가 비활성화됩니다 .</target>
        </trans-unit>
        <trans-unit id="193fc3ddd618485a261dd773adce3a84dd96a30d" translate="yes" xml:space="preserve">
          <source>A label for a &lt;b&gt;goto&lt;/b&gt; cannot be declared where a label with the same name is visible, even if this other label is declared in an enclosing block.</source>
          <target state="translated">같은 이름의 레이블이 보이는 곳에 &lt;b&gt;goto에&lt;/b&gt; 대한 레이블을 선언 할 수 없습니다.이 다른 레이블이 둘러싸는 블록에서 선언 된 경우에도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="22f3c7023ea10aed55497eb7b7366ee3b6a6cb22" translate="yes" xml:space="preserve">
          <source>A label is visible in the entire block where it is defined, except inside nested blocks where a label with the same name is defined and inside nested functions. A goto may jump to any visible label as long as it does not enter into the scope of a local variable.</source>
          <target state="translated">동일한 이름의 레이블이 정의 된 중첩 된 블록 내부와 중첩 된 함수를 제외하고 레이블은 정의 된 전체 블록에서 볼 수 있습니다. goto는 지역 변수의 범위에 들어 가지 않는 한 보이는 레이블로 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5cd99119e45659506f3ea872a322036815d49dcb" translate="yes" xml:space="preserve">
          <source>A label is visible in the entire block where it is defined, except inside nested functions. A goto may jump to any visible label as long as it does not enter into the scope of a local variable. A label should not be declared where a label with the same name is visible, even if this other label has been declared in an enclosing block.</source>
          <target state="translated">레이블은 중첩 된 함수 내부를 제외하고 정의 된 전체 블록에서 볼 수 있습니다. goto는 지역 변수의 범위에 들어 가지 않는 한 보이는 레이블로 이동할 수 있습니다. 이 다른 레이블이 둘러싸는 블록에서 선언 되었더라도 동일한 이름의 레이블이 보이는 곳에 레이블을 선언해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="933dd832c6b0be5ada1dd95c6bacc46f4be4f532" translate="yes" xml:space="preserve">
          <source>A metatable controls how an object behaves in arithmetic operations, bitwise operations, order comparisons, concatenation, length operation, calls, and indexing. A metatable also can define a function to be called when a userdata or a table is garbage collected (&lt;a href=&quot;#2.5&quot;&gt;&amp;sect;2.5&lt;/a&gt;).</source>
          <target state="translated">메타 테이블은 산술 연산, 비트 연산, 순서 비교, 연결, 길이 연산, 호출 및 인덱싱에서 객체의 동작을 제어합니다. 메타 테이블은 또한 사용자 데이터 또는 테이블이 가비지 수집 될 때 호출되는 함수를 정의 할 수 있습니다 ( &lt;a href=&quot;#2.5&quot;&gt;&amp;sect;2.5&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="713404884061ce0193a5d3c2ff7f9252eb287b76" translate="yes" xml:space="preserve">
          <source>A numeric constant with a radix point or an exponent denotes a float; otherwise, if its value fits in an integer or it is a hexadecimal constant, it denotes an integer; otherwise (that is, a decimal integer numeral that overflows), it denotes a float. Hexadecimal numerals with neither a radix point nor an exponent always denote an integer value; if the value overflows, it &lt;em&gt;wraps around&lt;/em&gt; to fit into a valid integer.</source>
          <target state="translated">기수 포인트 또는 지수가있는 숫자 상수는 부동 소수점을 나타냅니다. 그렇지 않으면 값이 정수에 맞거나 16 진 상수이면 정수를 표시합니다. 그렇지 않으면 (즉, 오버플로되는 10 진수 정수) 부동 소수점을 나타냅니다. 기수 점이나 지수가없는 16 진수는 항상 정수 값을 나타냅니다. 값이 오버플 로되면 유효한 정수에 맞도록 &lt;em&gt;줄 바꿈됩니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3fbf280f4f9e4cb8aa41cf93549ddcd00b0d6b38" translate="yes" xml:space="preserve">
          <source>A path is a string containing a sequence of &lt;em&gt;templates&lt;/em&gt; separated by semicolons. For each template, the function replaces each interrogation mark (if any) in the template with a copy of &lt;code&gt;name&lt;/code&gt; wherein all occurrences of &lt;code&gt;sep&lt;/code&gt; (a dot, by default) were replaced by &lt;code&gt;rep&lt;/code&gt; (the system's directory separator, by default), and then tries to open the resulting file name.</source>
          <target state="translated">경로는 세미콜론으로 구분 된 일련의 &lt;em&gt;템플릿을&lt;/em&gt; 포함하는 문자열 입니다. 각 템플릿에 대해이 함수는 템플릿의 각 심문 마크 (있는 경우)를 &lt;code&gt;name&lt;/code&gt; 의 사본으로 바꿉니다. 여기서 &lt;code&gt;sep&lt;/code&gt; (기본적으로 점)는 &lt;code&gt;rep&lt;/code&gt; (기본적으로 시스템의 디렉토리 구분자 )로 바뀐 다음 결과 파일 이름을 열려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="3592c30e99bab5898e5564c352fa7c9c589dc5de" translate="yes" xml:space="preserve">
          <source>A pattern can contain sub-patterns enclosed in parentheses; they describe &lt;em&gt;captures&lt;/em&gt;. When a match succeeds, the substrings of the subject string that match captures are stored (&lt;em&gt;captured&lt;/em&gt;) for future use. Captures are numbered according to their left parentheses. For instance, in the pattern &lt;code&gt;&quot;(a*(.)%w(%s*))&quot;&lt;/code&gt;, the part of the string matching &lt;code&gt;&quot;a*(.)%w(%s*)&quot;&lt;/code&gt; is stored as the first capture (and therefore has number 1); the character matching &quot;&lt;code&gt;.&lt;/code&gt;&quot; is captured with number 2, and the part matching &quot;&lt;code&gt;%s*&lt;/code&gt;&quot; has number 3.</source>
          <target state="translated">패턴은 괄호로 묶인 하위 패턴을 포함 할 수 있습니다. 그들은 &lt;em&gt;캡처&lt;/em&gt; 를 설명 &lt;em&gt;합니다&lt;/em&gt; . 일치가 성공하면 캡처와 일치하는 주제 문자열의 하위 문자열이 나중에 사용하기 위해 저장 ( &lt;em&gt;캡처&lt;/em&gt; )됩니다. 캡처는 왼쪽 괄호에 따라 번호가 매겨집니다. 예를 들어, 패턴 &lt;code&gt;&quot;(a*(.)%w(%s*))&quot;&lt;/code&gt; , 문자열 매칭의 일부분 &lt;code&gt;&quot;a*(.)%w(%s*)&quot;&lt;/code&gt; 최초 포착으로 저장된다 ( 따라서 숫자 1); 문자 &quot; &lt;code&gt;.&lt;/code&gt; &quot;는 숫자 2로 캡처되며 &quot; &lt;code&gt;%s*&lt;/code&gt; &quot; 와 일치하는 부분 은 숫자 3입니다.</target>
        </trans-unit>
        <trans-unit id="f56c34aac3249901bd4e798153c3758f32451a9c" translate="yes" xml:space="preserve">
          <source>A pattern can contain sub-patterns enclosed in parentheses; they describe &lt;em&gt;captures&lt;/em&gt;. When a match succeeds, the substrings of the subject string that match captures are stored (&lt;em&gt;captured&lt;/em&gt;) for future use. Captures are numbered according to their left parentheses. For instance, in the pattern &lt;code&gt;&quot;(a*(.)%w(%s*))&quot;&lt;/code&gt;, the part of the string matching &lt;code&gt;&quot;a*(.)%w(%s*)&quot;&lt;/code&gt; is stored as the first capture, and therefore has number 1; the character matching &quot;&lt;code&gt;.&lt;/code&gt;&quot; is captured with number 2, and the part matching &quot;&lt;code&gt;%s*&lt;/code&gt;&quot; has number 3.</source>
          <target state="translated">패턴은 괄호로 묶인 하위 패턴을 포함 할 수 있습니다. 그들은 &lt;em&gt;캡처&lt;/em&gt; 를 설명 &lt;em&gt;합니다&lt;/em&gt; . 일치가 성공하면 캡처와 일치하는 제목 문자열의 하위 문자열이 나중에 사용하기 위해 저장 ( &lt;em&gt;capture&lt;/em&gt; )됩니다. 캡처는 왼쪽 괄호에 따라 번호가 매겨집니다. 예를 들어, 패턴 &lt;code&gt;&quot;(a*(.)%w(%s*))&quot;&lt;/code&gt; , 문자열 매칭의 일부분 &lt;code&gt;&quot;a*(.)%w(%s*)&quot;&lt;/code&gt; 제 캡쳐로 저장, 따라서 숫자 1을 갖습니다. &quot; &lt;code&gt;.&lt;/code&gt; &quot;과 일치하는 문자 는 숫자 2로 캡처되고 &quot; &lt;code&gt;%s*&lt;/code&gt; &quot; 와 일치하는 부분 은 숫자 3을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="38cf749bb9ad3579d6b255d66e52681d302f2ddf" translate="yes" xml:space="preserve">
          <source>A pointer to a thread must be passed as the first argument to every function in the library, except to &lt;a href=&quot;#lua_newstate&quot;&gt;&lt;code&gt;lua_newstate&lt;/code&gt;&lt;/a&gt;, which creates a Lua state from scratch and returns a pointer to the &lt;em&gt;main thread&lt;/em&gt; in the new state.</source>
          <target state="translated">스레드에 대한 포인터는 &lt;a href=&quot;#lua_newstate&quot;&gt; &lt;code&gt;lua_newstate&lt;/code&gt; 를&lt;/a&gt; 제외하고 라이브러리의 모든 함수에 대한 첫 번째 인수로 전달되어야합니다. lua_newstate 는 처음부터 Lua 상태를 작성하고 새 상태 의 &lt;em&gt;기본 스레드&lt;/em&gt; 에 대한 포인터를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="9f720f6817ac0c98d606b9b7538ff16874a21500" translate="yes" xml:space="preserve">
          <source>A pointer to this structure must be passed as the first argument to every function in the library, except to &lt;a href=&quot;#lua_newstate&quot;&gt;&lt;code&gt;lua_newstate&lt;/code&gt;&lt;/a&gt;, which creates a Lua state from scratch.</source>
          <target state="translated">이 구조에 대한 포인터는 &lt;a href=&quot;#lua_newstate&quot;&gt; &lt;code&gt;lua_newstate&lt;/code&gt; 를&lt;/a&gt; 제외하고 라이브러리의 모든 함수에 대한 첫 번째 인수로 전달되어야합니다. lua_newstate 는 처음부터 Lua 상태를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="85de206f279ceaa430602580da3ee35a9d16cd8a" translate="yes" xml:space="preserve">
          <source>A program can modify the behavior of the length operator for any value but strings through the &lt;code&gt;__len&lt;/code&gt; metamethod (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;).</source>
          <target state="translated">프로그램은 &lt;code&gt;__len&lt;/code&gt; 메타 메소드 ( &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt; 참조 )를 통해 문자열 이외의 값에 대한 길이 연산자의 동작을 수정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bd8bd19d7a0da2968b0e0676ae5bf0fd9c2f4e0b" translate="yes" xml:space="preserve">
          <source>A reference is a unique integer key. As long as you do not manually add integer keys into table &lt;code&gt;t&lt;/code&gt;, &lt;a href=&quot;#luaL_ref&quot;&gt;&lt;code&gt;luaL_ref&lt;/code&gt;&lt;/a&gt; ensures the uniqueness of the key it returns. You can retrieve an object referred by reference &lt;code&gt;r&lt;/code&gt; by calling &lt;code&gt;lua_rawgeti(L, t, r)&lt;/code&gt;. Function &lt;a href=&quot;#luaL_unref&quot;&gt;&lt;code&gt;luaL_unref&lt;/code&gt;&lt;/a&gt; frees a reference and its associated object.</source>
          <target state="translated">참조는 고유 한 정수 키입니다. 만큼 당신이 수동으로 테이블에 키를 정수 추가하지 않는 한 &lt;code&gt;t&lt;/code&gt; , &lt;a href=&quot;#luaL_ref&quot;&gt; &lt;code&gt;luaL_ref&lt;/code&gt; 는&lt;/a&gt; 그것을 반환하는 키의 고유성을 보장합니다. &lt;code&gt;lua_rawgeti(L, t, r)&lt;/code&gt; 를 호출 하여 참조 &lt;code&gt;r&lt;/code&gt; 에 의해 참조되는 객체를 검색 할 수 있습니다 . &lt;a href=&quot;#luaL_unref&quot;&gt; &lt;code&gt;luaL_unref&lt;/code&gt; &lt;/a&gt; 함수 는 참조 및 관련 객체를 해제합니다.</target>
        </trans-unit>
        <trans-unit id="3b65f579bb9fc7a51aa1518e80e26143edddac9f" translate="yes" xml:space="preserve">
          <source>A reference is a unique integer key. As long as you do not manually add integer keys into the table &lt;code&gt;t&lt;/code&gt;, &lt;a href=&quot;#luaL_ref&quot;&gt;&lt;code&gt;luaL_ref&lt;/code&gt;&lt;/a&gt; ensures the uniqueness of the key it returns. You can retrieve an object referred by the reference &lt;code&gt;r&lt;/code&gt; by calling &lt;code&gt;lua_rawgeti(L, t, r)&lt;/code&gt;. The function &lt;a href=&quot;#luaL_unref&quot;&gt;&lt;code&gt;luaL_unref&lt;/code&gt;&lt;/a&gt; frees a reference.</source>
          <target state="translated">참조는 고유 한 정수 키입니다. 만큼 당신이 수동으로 테이블에 키를 정수 추가하지 않는 한 &lt;code&gt;t&lt;/code&gt; , &lt;a href=&quot;#luaL_ref&quot;&gt; &lt;code&gt;luaL_ref&lt;/code&gt; 는&lt;/a&gt; 그것을 반환하는 키의 고유성을 보장합니다. &lt;code&gt;lua_rawgeti(L, t, r)&lt;/code&gt; 을 호출 하여 참조 &lt;code&gt;r&lt;/code&gt; 이 참조하는 객체를 검색 할 수 있습니다 . &lt;a href=&quot;#luaL_unref&quot;&gt; &lt;code&gt;luaL_unref&lt;/code&gt; &lt;/a&gt; 함수 는 참조를 해제합니다.</target>
        </trans-unit>
        <trans-unit id="5886b914eeefc6fe9c97cf73899590f4453edb42" translate="yes" xml:space="preserve">
          <source>A running coroutine is yieldable if it is not the main thread and it is not inside a non-yieldable C function.</source>
          <target state="translated">메인 스레드가 아니고 양보 할 수없는 C 함수 안에 있지 않으면 실행중인 코 루틴을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02104a4bea2c474acf11ad8559dae77d59bc940e" translate="yes" xml:space="preserve">
          <source>A single name can denote a global variable or a local variable (or a function's formal parameter, which is a particular kind of local variable):</source>
          <target state="translated">단일 이름은 전역 변수 또는 지역 변수 (또는 특정 종류의 지역 변수 인 함수의 공식 매개 변수)를 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4794c70aa8c69ef2ec8802a8dbbec4cdd33e83e8" translate="yes" xml:space="preserve">
          <source>A string buffer allows C code to build Lua strings piecemeal. Its pattern of use is as follows:</source>
          <target state="translated">문자열 버퍼는 C 코드가 Lua 문자열을 단편적으로 만들 수 있도록합니다. 사용 패턴은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f87ecc6b4255bdd2af412051775ae09429630fe0" translate="yes" xml:space="preserve">
          <source>A string describing some compile-time configurations for packages. This string is a sequence of lines:</source>
          <target state="translated">패키지의 컴파일 타임 구성을 설명하는 문자열입니다. 이 문자열은 일련의 줄입니다.</target>
        </trans-unit>
        <trans-unit id="667756bbe7670acfae5aeea4b4d1a1a336746c54" translate="yes" xml:space="preserve">
          <source>A string is converted to an integer or a float following its syntax and the rules of the Lua lexer. The string may have also leading and trailing whitespaces and a sign. All conversions from strings to numbers accept both a dot and the current locale mark as the radix character. (The Lua lexer, however, accepts only a dot.) If the string is not a valid numeral, the conversion fails. If necessary, the result of this first step is then converted to a specific number subtype following the previous rules for conversions between floats and integers.</source>
          <target state="translated">문자열은 구문과 Lua 렉서의 규칙에 따라 정수 또는 부동 소수점으로 변환됩니다. 문자열에는 선행 및 후행 공백과 부호가있을 수도 있습니다. 문자열에서 숫자로의 모든 변환은 점과 현재 로케일 표시를 모두 기수 문자로 허용합니다. (그러나 Lua 렉서는 점만 허용합니다.) 문자열이 유효한 숫자가 아니면 변환이 실패합니다. 필요한 경우이 첫 번째 단계의 결과는 부동 소수점과 정수 간의 변환에 대한 이전 규칙에 따라 특정 숫자 하위 유형으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="abda2a67131cc4c6e97b6f92e4934b679bf8a21b" translate="yes" xml:space="preserve">
          <source>A string with the path used by &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; to search for a C loader.</source>
          <target state="translated">C 로더를 검색하기 위해 &lt;a href=&quot;#pdf-require&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt; 에서 사용하는 경로가있는 문자열입니다 .</target>
        </trans-unit>
        <trans-unit id="c23bdad6197a85560a746feae91d149db8518e26" translate="yes" xml:space="preserve">
          <source>A string with the path used by &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; to search for a Lua loader.</source>
          <target state="translated">루아 로더를 검색하기 위해 &lt;a href=&quot;#pdf-require&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt; 에서 사용하는 경로가있는 문자열입니다 .</target>
        </trans-unit>
        <trans-unit id="fec6a000811b19de6807d9f5d778634007385bd8" translate="yes" xml:space="preserve">
          <source>A structure used to carry different pieces of information about a function or an activation record. &lt;a href=&quot;#lua_getstack&quot;&gt;&lt;code&gt;lua_getstack&lt;/code&gt;&lt;/a&gt; fills only the private part of this structure, for later use. To fill the other fields of &lt;a href=&quot;#lua_Debug&quot;&gt;&lt;code&gt;lua_Debug&lt;/code&gt;&lt;/a&gt; with useful information, call &lt;a href=&quot;#lua_getinfo&quot;&gt;&lt;code&gt;lua_getinfo&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">함수 또는 활성화 레코드에 대한 다양한 정보를 전달하는 데 사용되는 구조입니다. &lt;a href=&quot;#lua_getstack&quot;&gt; &lt;code&gt;lua_getstack&lt;/code&gt; &lt;/a&gt; 은 나중에 사용하기 위해이 구조의 전용 부분 만 채 웁니다. 유용한 정보 로 &lt;a href=&quot;#lua_Debug&quot;&gt; &lt;code&gt;lua_Debug&lt;/code&gt; &lt;/a&gt; 의 다른 필드를 채우려면 &lt;a href=&quot;#lua_getinfo&quot;&gt; &lt;code&gt;lua_getinfo&lt;/code&gt; 를&lt;/a&gt; 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="e2e6cc803896921b54b6c0c6d1372e559fbc21d7" translate="yes" xml:space="preserve">
          <source>A structure used to carry different pieces of information about a function or an activation record. &lt;a href=&quot;#lua_getstack&quot;&gt;&lt;code&gt;lua_getstack&lt;/code&gt;&lt;/a&gt; fills only the private part of this structure, for later use. To fill the other fields of &lt;a href=&quot;#lua_Debug&quot;&gt;&lt;code&gt;lua_Debug&lt;/code&gt;&lt;/a&gt; with useful information, you must call &lt;a href=&quot;#lua_getinfo&quot;&gt;&lt;code&gt;lua_getinfo&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">함수 또는 활성화 레코드에 대한 다양한 정보를 전달하는 데 사용되는 구조입니다. &lt;a href=&quot;#lua_getstack&quot;&gt; &lt;code&gt;lua_getstack&lt;/code&gt; &lt;/a&gt; 은 나중에 사용하기 위해이 구조의 private 부분 만 채 웁니다. &lt;a href=&quot;#lua_Debug&quot;&gt; &lt;code&gt;lua_Debug&lt;/code&gt; &lt;/a&gt; 의 다른 필드 를 유용한 정보로 채우려면 &lt;a href=&quot;#lua_getinfo&quot;&gt; &lt;code&gt;lua_getinfo&lt;/code&gt; &lt;/a&gt; 를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3f70841dbcffb4668b72f4ee9f5d20362ac22ade" translate="yes" xml:space="preserve">
          <source>A table to store loaders for specific modules (see &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">특정 모듈의 로더를 저장하기위한 테이블입니다 ( &lt;a href=&quot;#pdf-require&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="c7b924969ceba2c59eef4a850d350c4cfb8d1b7b" translate="yes" xml:space="preserve">
          <source>A table used by &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; to control how to find modules.</source>
          <target state="translated">모듈을 찾는 방법을 제어하기 위해 &lt;a href=&quot;#pdf-require&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt; 에서 사용하는 테이블 입니다.</target>
        </trans-unit>
        <trans-unit id="04907543b8fecfeecd0da3b12b889da3eb87f79e" translate="yes" xml:space="preserve">
          <source>A table used by &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; to control how to load modules.</source>
          <target state="translated">모듈로드 방법을 제어하기 위해 &lt;a href=&quot;#pdf-require&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt; 로 하는 테이블 입니다.</target>
        </trans-unit>
        <trans-unit id="236d800446c3c980d88f62e84b598b19165287ba" translate="yes" xml:space="preserve">
          <source>A table used by &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; to control which modules are already loaded. When you require a module &lt;code&gt;modname&lt;/code&gt; and &lt;code&gt;package.loaded[modname]&lt;/code&gt; is not false, &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; simply returns the value stored there.</source>
          <target state="translated">에서 사용하는 테이블은 &lt;a href=&quot;#pdf-require&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt; 모듈이 이미로드 제어 할 수 있습니다. 모듈 &lt;code&gt;modname&lt;/code&gt; 이 필요 하고 &lt;code&gt;package.loaded[modname]&lt;/code&gt; 이 false가 아닌 경우 &lt;a href=&quot;#pdf-require&quot;&gt; &lt;code&gt;require&lt;/code&gt; 는&lt;/a&gt; 단순히 저장된 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b29d9ef1e9f7cc0edb2ef63bd4e9310e7273fbcc" translate="yes" xml:space="preserve">
          <source>A table with exactly one border is called a &lt;em&gt;sequence&lt;/em&gt;. For instance, the table &lt;code&gt;{10, 20, 30, 40, 50}&lt;/code&gt; is a sequence, as it has only one border (5). The table &lt;code&gt;{10, 20, 30, nil, 50}&lt;/code&gt; has two borders (3 and 5), and therefore it is not a sequence. (The &lt;b&gt;nil&lt;/b&gt; at index 4 is called a &lt;em&gt;hole&lt;/em&gt;.) The table &lt;code&gt;{nil, 20, 30, nil, nil, 60, nil}&lt;/code&gt; has three borders (0, 3, and 6) and three holes (at indices 1, 4, and 5), so it is not a sequence, too. The table &lt;code&gt;{}&lt;/code&gt; is a sequence with border 0. Note that non-natural keys do not interfere with whether a table is a sequence.</source>
          <target state="translated">정확히 하나의 테두리가있는 테이블을 &lt;em&gt;시퀀스&lt;/em&gt; 라고합니다 . 예를 들어, 테이블 &lt;code&gt;{10, 20, 30, 40, 50}&lt;/code&gt; 은 하나의 테두리 (5) 만 있기 때문에 시퀀스입니다. 테이블 &lt;code&gt;{10, 20, 30, nil, 50}&lt;/code&gt; 에는 두 개의 테두리 (3 및 5)가 있으므로 시퀀스가 ​​아닙니다. ( 인덱스 4 의 &lt;b&gt;nil&lt;/b&gt; 을 &lt;em&gt;홀&lt;/em&gt; 이라고합니다 .) 테이블 &lt;code&gt;{nil, 20, 30, nil, nil, 60, nil}&lt;/code&gt; 에는 세 개의 테두리 (0, 3, 6)와 세 개의 홀 (인덱스 1, 4, 5), 그래서 그것은 시퀀스도 아닙니다. 테이블 &lt;code&gt;{}&lt;/code&gt; 은 테두리 0이있는 시퀀스입니다. 비 자연 키는 테이블이 시퀀스인지 여부를 방해하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3862e82890432c457763712f15a7fd6f5e4a1a62" translate="yes" xml:space="preserve">
          <source>A table with exactly one border is called a &lt;em&gt;sequence&lt;/em&gt;. For instance, the table &lt;code&gt;{10, 20, 30, 40, 50}&lt;/code&gt; is a sequence, as it has only one border (5). The table &lt;code&gt;{10, 20, 30, nil, 50}&lt;/code&gt; has two borders (3 and 5), and therefore it is not a sequence. The table &lt;code&gt;{nil, 20, 30, nil, nil, 60, nil}&lt;/code&gt; has three borders (0, 3, and 6), so it is not a sequence, too. The table &lt;code&gt;{}&lt;/code&gt; is a sequence with border 0. Note that non-natural keys do not interfere with whether a table is a sequence.</source>
          <target state="translated">정확히 하나의 테두리가있는 테이블을 &lt;em&gt;시퀀스&lt;/em&gt; 라고합니다 . 예를 들어, 테이블 &lt;code&gt;{10, 20, 30, 40, 50}&lt;/code&gt; 은 하나의 경계 (5) 만 있으므로 시퀀스입니다. 테이블 &lt;code&gt;{10, 20, 30, nil, 50}&lt;/code&gt; 에는 두 개의 경계 (3 및 5)가 있으므로 순서가 아닙니다. 표 &lt;code&gt;{nil, 20, 30, nil, nil, 60, nil}&lt;/code&gt; 너무 아닌 서열 그래서, 세 테두리 (0, 3, 6)를 갖는다. &lt;code&gt;{}&lt;/code&gt; 테이블 은 경계가 0 인 시퀀스입니다. 자연 키가 아닌 키는 테이블이 시퀀스인지 여부를 방해하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0d3f40da2d8f70f83b27ea28adbba3891980e807" translate="yes" xml:space="preserve">
          <source>A table with weak keys and strong values is also called an &lt;em&gt;ephemeron table&lt;/em&gt;. In an ephemeron table, a value is considered reachable only if its key is reachable. In particular, if the only reference to a key comes through its value, the pair is removed.</source>
          <target state="translated">키가 약하고 값이 강한 &lt;em&gt;테이블을 임시표&lt;/em&gt; 라고도 &lt;em&gt;합니다&lt;/em&gt; . 임시 테이블에서 키에 도달 할 수있는 경우에만 값에 도달 할 수있는 것으로 간주됩니다. 특히 키에 대한 유일한 참조가 해당 값을 통해 오는 경우 쌍이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="c314cbbbabf225b3a951c9dc3ade2abfd472e6d5" translate="yes" xml:space="preserve">
          <source>A to-be-closed variable behaves like a constant local variable, except that its value is &lt;em&gt;closed&lt;/em&gt; whenever the variable goes out of scope, including normal block termination, exiting its block by &lt;b&gt;break&lt;/b&gt;/&lt;b&gt;goto&lt;/b&gt;/&lt;b&gt;return&lt;/b&gt;, or exiting by an error.</source>
          <target state="translated">&lt;em&gt;종료&lt;/em&gt; 될 변수는 정상적인 블록 종료, &lt;b&gt;break&lt;/b&gt; / &lt;b&gt;goto&lt;/b&gt; / &lt;b&gt;return에&lt;/b&gt; 의한 블록 종료 또는 오류에 의한 종료를 포함하여 변수가 범위를 벗어날 때마다 값이 &lt;em&gt;닫히는&lt;/em&gt; 것을 제외하고는 상수 지역 변수처럼 동작 합니다.</target>
        </trans-unit>
        <trans-unit id="a4e936e6f28db7848cd749bfcf6bd58b1a46b052" translate="yes" xml:space="preserve">
          <source>A typical table traversal looks like this:</source>
          <target state="translated">일반적인 테이블 순회는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4654fe97bf7d302a9567895699edd89cbcd9e791" translate="yes" xml:space="preserve">
          <source>A typical traversal looks like this:</source>
          <target state="translated">일반적인 순회는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="56d6e1795249533ab7eb0411e5a66433e31c3e9e" translate="yes" xml:space="preserve">
          <source>A weak table can have weak keys, weak values, or both. A table with weak values allows the collection of its values, but prevents the collection of its keys. A table with both weak keys and weak values allows the collection of both keys and values. In any case, if either the key or the value is collected, the whole pair is removed from the table. The weakness of a table is controlled by the &lt;code&gt;__mode&lt;/code&gt; field of its metatable. If the &lt;code&gt;__mode&lt;/code&gt; field is a string containing the character '&lt;code&gt;k&lt;/code&gt;', the keys in the table are weak. If &lt;code&gt;__mode&lt;/code&gt; contains '&lt;code&gt;v&lt;/code&gt;', the values in the table are weak.</source>
          <target state="translated">약한 테이블에는 약한 키, 약한 값 또는 둘 다가있을 수 있습니다. 값이 약한 테이블은 값을 수집 할 수 있지만 키는 수집하지 않습니다. 약한 키와 약한 값이 모두있는 테이블을 사용하면 키와 값을 모두 수집 할 수 있습니다. 어쨌든 키 또는 값이 수집되면 전체 쌍이 테이블에서 제거됩니다. 테이블의 약점은 메타 테이블 의 &lt;code&gt;__mode&lt;/code&gt; 필드에 의해 제어됩니다 . 경우] &lt;code&gt;__mode&lt;/code&gt; 의 필드에 문자 '포함 된 문자열 &lt;code&gt;k&lt;/code&gt; 는 ', 테이블 내의 키는 약하다. &lt;code&gt;__mode&lt;/code&gt; 에 ' &lt;code&gt;v&lt;/code&gt; ' 가 포함되어 있으면 테이블의 값이 약합니다.</target>
        </trans-unit>
        <trans-unit id="05441c96afe91d476bca9fda9e9b499237ab33b1" translate="yes" xml:space="preserve">
          <source>A weak table can have weak keys, weak values, or both. A table with weak values allows the collection of its values, but prevents the collection of its keys. A table with both weak keys and weak values allows the collection of both keys and values. In any case, if either the key or the value is collected, the whole pair is removed from the table. The weakness of a table is controlled by the &lt;code&gt;__mode&lt;/code&gt; field of its metatable. This metavalue, if present, must be one of the following strings: &quot;&lt;code&gt;k&lt;/code&gt;&quot;, for a table with weak keys; &quot;&lt;code&gt;v&lt;/code&gt;&quot;, for a table with weak values; or &quot;&lt;code&gt;kv&lt;/code&gt;&quot;, for a table with both weak keys and values.</source>
          <target state="translated">약한 테이블은 약한 키, 약한 값 또는 둘 다를 가질 수 있습니다. 약한 값이있는 테이블은 값 수집을 허용하지만 키 수집은 금지합니다. 약한 키와 약한 값이 모두있는 테이블을 사용하면 키와 값을 모두 수집 할 수 있습니다. 어쨌든 키 또는 값이 수집되면 전체 쌍이 테이블에서 제거됩니다. 테이블의 약점은 메타 테이블 의 &lt;code&gt;__mode&lt;/code&gt; 필드에 의해 제어됩니다 . 이 메타 값이 있으면 다음 문자열 중 하나 여야합니다. &quot; &lt;code&gt;k&lt;/code&gt; &quot;, 약한 키가있는 테이블의 경우; &quot; &lt;code&gt;v&lt;/code&gt; &quot;, 약한 값을 가진 테이블의 경우; 약한 키와 값이 모두있는 테이블의 경우 &quot; &lt;code&gt;kv&lt;/code&gt; &quot;입니다.</target>
        </trans-unit>
        <trans-unit id="d93d10ff0fbef1b4aa0ddc24e10e907746d3c85a" translate="yes" xml:space="preserve">
          <source>API</source>
          <target state="translated">API</target>
        </trans-unit>
        <trans-unit id="318d4efd331848e3807a2165e170def930a474b2" translate="yes" xml:space="preserve">
          <source>Acceptable indices serve to avoid extra tests against the stack top when querying the stack. For instance, a C function can query its third argument without the need to check whether there is a third argument, that is, without the need to check whether 3 is a valid index.</source>
          <target state="translated">허용 가능한 인덱스는 스택을 쿼리 할 때 스택 상단에 대한 추가 테스트를 방지하는 데 사용됩니다. 예를 들어, C 함수는 세 번째 인수가 있는지 확인하지 않아도, 즉 3이 유효한 인덱스인지 확인할 필요없이 세 번째 인수를 쿼리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="be7df36d7d8ed1468bab871c0aefed53b43ba4c0" translate="yes" xml:space="preserve">
          <source>Acceptable indices serve to avoid extra tests against the stack top when querying the stack. For instance, a C function can query its third argument without the need to first check whether there is a third argument, that is, without the need to check whether 3 is a valid index.</source>
          <target state="translated">허용 가능한 인덱스는 스택을 쿼리 할 때 스택 상단에 대한 추가 테스트를 피하는 역할을합니다. 예를 들어, C 함수는 먼저 세 번째 인수가 있는지, 즉 3이 유효한 인덱스인지 여부를 확인할 필요없이 세 번째 인수를 쿼리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="51c17633ca2c048cb9e8c69ecfd444fc1aeb9bb6" translate="yes" xml:space="preserve">
          <source>Accepts any index, or 0, and sets the stack top to this index. If the new top is greater than the old one, then the new elements are filled with &lt;b&gt;nil&lt;/b&gt;. If &lt;code&gt;index&lt;/code&gt; is 0, then all stack elements are removed.</source>
          <target state="translated">임의의 인덱스 또는 0을 허용하고 스택 상단을이 인덱스로 설정합니다. 새 상단이 이전 항목보다 크면 새 요소가 &lt;b&gt;nil&lt;/b&gt; 로 채워집니다 . 경우 &lt;code&gt;index&lt;/code&gt; 0이고, 모든 스택 요소는 제거된다.</target>
        </trans-unit>
        <trans-unit id="f9bead715d3aed55f00ef8b226e3b3d6b628f98c" translate="yes" xml:space="preserve">
          <source>Accepts any index, or 0, and sets the stack top to this index. If the new top is larger than the old one, then the new elements are filled with &lt;b&gt;nil&lt;/b&gt;. If &lt;code&gt;index&lt;/code&gt; is 0, then all stack elements are removed.</source>
          <target state="translated">인덱스 또는 0을 허용하고 스택 맨을이 인덱스로 설정합니다. 새 상단이 이전 상단보다 크면 새 요소는 &lt;b&gt;nil&lt;/b&gt; 로 채워집니다 . 경우 &lt;code&gt;index&lt;/code&gt; 0이고, 모든 스택 요소는 제거된다.</target>
        </trans-unit>
        <trans-unit id="b86c2f6147e79a1b4297baac1948764dddd622d9" translate="yes" xml:space="preserve">
          <source>Adds a copy of the string &lt;code&gt;s&lt;/code&gt; to the buffer &lt;code&gt;B&lt;/code&gt; (see &lt;a href=&quot;#luaL_Buffer&quot;&gt;&lt;code&gt;luaL_Buffer&lt;/code&gt;&lt;/a&gt;), replacing any occurrence of the string &lt;code&gt;p&lt;/code&gt; with the string &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">문자열 &lt;code&gt;s&lt;/code&gt; 의 복사본을 버퍼 &lt;code&gt;B&lt;/code&gt; 에 추가합니다 ( &lt;a href=&quot;#luaL_Buffer&quot;&gt; &lt;code&gt;luaL_Buffer&lt;/code&gt; &lt;/a&gt; 참조 ). 문자열 &lt;code&gt;p&lt;/code&gt; 의 발생을 문자열 &lt;code&gt;r&lt;/code&gt; 로 바꿉니다 .</target>
        </trans-unit>
        <trans-unit id="fa67d1b55b60391424ed0215f797f8cda588620a" translate="yes" xml:space="preserve">
          <source>Adds the byte &lt;code&gt;c&lt;/code&gt; to the buffer &lt;code&gt;B&lt;/code&gt; (see &lt;a href=&quot;#luaL_Buffer&quot;&gt;&lt;code&gt;luaL_Buffer&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">바이트 &lt;code&gt;c&lt;/code&gt; 를 버퍼 &lt;code&gt;B&lt;/code&gt; 에 추가합니다 ( &lt;a href=&quot;#luaL_Buffer&quot;&gt; &lt;code&gt;luaL_Buffer&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="e90d8fb3354b196fdab7ad34fbe37926f7654b63" translate="yes" xml:space="preserve">
          <source>Adds the string pointed to by &lt;code&gt;s&lt;/code&gt; with length &lt;code&gt;l&lt;/code&gt; to the buffer &lt;code&gt;B&lt;/code&gt; (see &lt;a href=&quot;#luaL_Buffer&quot;&gt;&lt;code&gt;luaL_Buffer&lt;/code&gt;&lt;/a&gt;). The string can contain embedded zeros.</source>
          <target state="translated">길이가 &lt;code&gt;l&lt;/code&gt; 인 &lt;code&gt;s&lt;/code&gt; 가 가리키는 문자열을 버퍼 &lt;code&gt;B&lt;/code&gt; 에 추가합니다 ( &lt;a href=&quot;#luaL_Buffer&quot;&gt; &lt;code&gt;luaL_Buffer&lt;/code&gt; &lt;/a&gt; 참조 ). 문자열은 0을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1554fdc1fb0aa862c71bc7fc397a26d3a4ef58d" translate="yes" xml:space="preserve">
          <source>Adds the value at the top of the stack to the buffer &lt;code&gt;B&lt;/code&gt; (see &lt;a href=&quot;#luaL_Buffer&quot;&gt;&lt;code&gt;luaL_Buffer&lt;/code&gt;&lt;/a&gt;). Pops the value.</source>
          <target state="translated">스택의 맨 위에있는 값을 버퍼 &lt;code&gt;B&lt;/code&gt; 에 추가합니다 ( &lt;a href=&quot;#luaL_Buffer&quot;&gt; &lt;code&gt;luaL_Buffer&lt;/code&gt; &lt;/a&gt; 참조 ). 값을 팝합니다.</target>
        </trans-unit>
        <trans-unit id="a5515574738d5addfdb921d2d442909f86caa02c" translate="yes" xml:space="preserve">
          <source>Adds the value on the top of the stack to the buffer &lt;code&gt;B&lt;/code&gt; (see &lt;a href=&quot;#luaL_Buffer&quot;&gt;&lt;code&gt;luaL_Buffer&lt;/code&gt;&lt;/a&gt;). Pops the value.</source>
          <target state="translated">스택 맨 위에있는 값을 버퍼 &lt;code&gt;B&lt;/code&gt; 에 추가합니다 ( &lt;a href=&quot;#luaL_Buffer&quot;&gt; &lt;code&gt;luaL_Buffer&lt;/code&gt; &lt;/a&gt; 참조 ). 값을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="805463d8104725860e0a53e77554865962b221ce" translate="yes" xml:space="preserve">
          <source>Adds the zero-terminated string pointed to by &lt;code&gt;s&lt;/code&gt; to the buffer &lt;code&gt;B&lt;/code&gt; (see &lt;a href=&quot;#luaL_Buffer&quot;&gt;&lt;code&gt;luaL_Buffer&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 가 가리키는 0으로 끝나는 문자열 을 버퍼 &lt;code&gt;B&lt;/code&gt; 에 추가합니다 ( &lt;a href=&quot;#luaL_Buffer&quot;&gt; &lt;code&gt;luaL_Buffer&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="71ca21350559a88942a584e333d8d2fdeaeb2968" translate="yes" xml:space="preserve">
          <source>Adds to the buffer &lt;code&gt;B&lt;/code&gt; (see &lt;a href=&quot;#luaL_Buffer&quot;&gt;&lt;code&gt;luaL_Buffer&lt;/code&gt;&lt;/a&gt;) a string of length &lt;code&gt;n&lt;/code&gt; previously copied to the buffer area (see &lt;a href=&quot;#luaL_prepbuffer&quot;&gt;&lt;code&gt;luaL_prepbuffer&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">버퍼에 추가 &lt;code&gt;B&lt;/code&gt; (참조 &lt;a href=&quot;#luaL_Buffer&quot;&gt; &lt;code&gt;luaL_Buffer&lt;/code&gt; 를&lt;/a&gt; ) 길이의 문자열 &lt;code&gt;n&lt;/code&gt; 이전 버퍼 영역 (참조 복사 &lt;a href=&quot;#luaL_prepbuffer&quot;&gt; &lt;code&gt;luaL_prepbuffer&lt;/code&gt; 을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="43ddd8457c1f8e3ac7b12299c1894d4afcf69996" translate="yes" xml:space="preserve">
          <source>Adds to the buffer &lt;code&gt;B&lt;/code&gt; a string of length &lt;code&gt;n&lt;/code&gt; previously copied to the buffer area (see &lt;a href=&quot;#luaL_prepbuffer&quot;&gt;&lt;code&gt;luaL_prepbuffer&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">이전에 버퍼 영역에 복사 된 길이 &lt;code&gt;n&lt;/code&gt; 의 문자열을 버퍼 &lt;code&gt;B&lt;/code&gt; 에 추가합니다 ( &lt;a href=&quot;#luaL_prepbuffer&quot;&gt; &lt;code&gt;luaL_prepbuffer&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="9ca9092d4638ba4ef06c7f156a5034ca7a383dc2" translate="yes" xml:space="preserve">
          <source>After an error, the other pending closing methods will still be called. Errors in these methods interrupt the respective method and generate a warning, but are otherwise ignored; the error reported is only the original one.</source>
          <target state="translated">오류가 발생한 후에도 보류중인 다른 닫기 메서드가 계속 호출됩니다. 이러한 메서드의 오류는 각 메서드를 중단하고 경고를 생성하지만 그렇지 않으면 무시됩니다. 보고 된 오류는 원래 오류입니다.</target>
        </trans-unit>
        <trans-unit id="a9bf8213e7ff3700b5b856d615911be85fad5679" translate="yes" xml:space="preserve">
          <source>After handling its options, &lt;code&gt;lua&lt;/code&gt; runs the given &lt;em&gt;script&lt;/em&gt;. When called without arguments, &lt;code&gt;lua&lt;/code&gt; behaves as &lt;code&gt;lua -v -i&lt;/code&gt; when the standard input (&lt;code&gt;stdin&lt;/code&gt;) is a terminal, and as &lt;code&gt;lua -&lt;/code&gt; otherwise.</source>
          <target state="translated">옵션을 처리 한 후 &lt;code&gt;lua&lt;/code&gt; 는 지정된 &lt;em&gt;스크립트를&lt;/em&gt; 실행합니다 . 인수없이 호출시 &lt;code&gt;lua&lt;/code&gt; 로 동작 &lt;code&gt;lua -v -i&lt;/code&gt; 표준 입력 (시 &lt;code&gt;stdin&lt;/code&gt; ) 단자이고, 그리고 &lt;code&gt;lua -&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="cd5095c5631224575daa0d2a16efe769846a0a84" translate="yes" xml:space="preserve">
          <source>After that initialization, the loop body is repeated with the value of the control variable going through an arithmetic progression, starting at the initial value, with a common difference given by the step. A negative step makes a decreasing sequence; a step equal to zero raises an error. The loop continues while the value is less than or equal to the limit (greater than or equal to for a negative step). If the initial value is already greater than the limit (or less than, if the step is negative), the body is not executed.</source>
          <target state="translated">그 초기화 후, 루프 본문은 단계에 의해 주어진 공통 차이를 가지고 초기 값에서 시작하여 산술 진행을 거치는 제어 변수의 값으로 반복됩니다. 음의 단계는 감소하는 시퀀스를 만듭니다. 0과 같은 단계는 오류를 발생시킵니다. 값이 한계보다 작거나 같은 동안 루프가 계속됩니다 (음수 단계의 경우보다 크거나 같음). 초기 값이 이미 한계보다 크면 (또는 단계가 음수이면보다 작 으면) 본문이 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="15063350c6a79260afaac68065c69671ef9eeded" translate="yes" xml:space="preserve">
          <source>Alignment works as follows: For each option, the format gets extra padding until the data starts at an offset that is a multiple of the minimum between the option size and the maximum alignment; this minimum must be a power of 2. Options &quot;&lt;code&gt;c&lt;/code&gt;&quot; and &quot;&lt;code&gt;z&lt;/code&gt;&quot; are not aligned; option &quot;&lt;code&gt;s&lt;/code&gt;&quot; follows the alignment of its starting integer.</source>
          <target state="translated">정렬은 다음과 같이 작동합니다. 각 옵션에 대해 데이터는 옵션 크기와 최대 정렬 사이의 최소값의 배수 인 오프셋에서 데이터가 시작될 때까지 추가 패딩을 얻습니다. 이 최소값은 2의 거듭 제곱이어야합니다. 옵션 &quot; &lt;code&gt;c&lt;/code&gt; &quot;및 &quot; &lt;code&gt;z&lt;/code&gt; &quot;는 정렬되지 않습니다. 옵션 &quot; &lt;code&gt;s&lt;/code&gt; &quot;는 시작 정수의 정렬을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="3f5b4e7445d1ae596693345d80aebb59b269536b" translate="yes" xml:space="preserve">
          <source>All argument expressions are evaluated before the call. A call of the form &lt;code&gt;f{&lt;em&gt;fields&lt;/em&gt;}&lt;/code&gt; is syntactic sugar for &lt;code&gt;f({&lt;em&gt;fields&lt;/em&gt;})&lt;/code&gt;; that is, the argument list is a single new table. A call of the form &lt;code&gt;f'&lt;em&gt;string&lt;/em&gt;'&lt;/code&gt; (or &lt;code&gt;f&quot;&lt;em&gt;string&lt;/em&gt;&quot;&lt;/code&gt; or &lt;code&gt;f[[&lt;em&gt;string&lt;/em&gt;]]&lt;/code&gt;) is syntactic sugar for &lt;code&gt;f('&lt;em&gt;string&lt;/em&gt;')&lt;/code&gt;; that is, the argument list is a single literal string.</source>
          <target state="translated">모든 인수 표현식은 호출 전에 평가됩니다. &lt;code&gt;f{&lt;em&gt;fields&lt;/em&gt;}&lt;/code&gt; 형식의 호출은 &lt;code&gt;f({&lt;em&gt;fields&lt;/em&gt;})&lt;/code&gt; 대한 구문 설탕입니다 . 즉, 인수 목록은 단일 새 테이블입니다. &lt;code&gt;f'&lt;em&gt;string&lt;/em&gt;'&lt;/code&gt; (또는 &lt;code&gt;f&quot;&lt;em&gt;string&lt;/em&gt;&quot;&lt;/code&gt; 또는 &lt;code&gt;f[[&lt;em&gt;string&lt;/em&gt;]]&lt;/code&gt; ) 형식의 호출은 &lt;code&gt;f('&lt;em&gt;string&lt;/em&gt;')&lt;/code&gt; 구문 설탕입니다 . 즉, 인수 목록은 단일 리터럴 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="acc9b360c0f165382f26927b4e5133003a413b44" translate="yes" xml:space="preserve">
          <source>All bitwise operations convert its operands to integers (see &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3&lt;/a&gt;), operate on all bits of those integers, and result in an integer.</source>
          <target state="translated">모든 비트 단위 연산은 피연산자를 정수로 변환하고 ( &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3&lt;/a&gt; 참조 ) 해당 정수의 모든 비트에서 작동하며 정수가됩니다.</target>
        </trans-unit>
        <trans-unit id="f305da96ae003ba3953ef2d24d1bf9f7d1a7db44" translate="yes" xml:space="preserve">
          <source>All conversions from strings to numbers accept both a dot and the current locale mark as the radix character. (The Lua lexer, however, accepts only a dot.)</source>
          <target state="translated">문자열에서 숫자로의 모든 변환은 점과 현재 로케일 마크를 기수 문자로 허용합니다. 그러나 Lua lexer는 점만 허용합니다.</target>
        </trans-unit>
        <trans-unit id="e8fc76868f788278527229cf8ae331ac5e9af057" translate="yes" xml:space="preserve">
          <source>All functions and types from the auxiliary library are defined in header file &lt;code&gt;lauxlib.h&lt;/code&gt; and have a prefix &lt;code&gt;luaL_&lt;/code&gt;.</source>
          <target state="translated">보조 라이브러리의 모든 함수와 유형은 헤더 파일 &lt;code&gt;lauxlib.h&lt;/code&gt; 에 정의되며 접두사 &lt;code&gt;luaL_&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5b5a80d9354e5e4fed6af6805ce75ff37321a509" translate="yes" xml:space="preserve">
          <source>All functions in the auxiliary library are built on top of the basic API, and so they provide nothing that cannot be done with that API. Nevertheless, the use of the auxiliary library ensures more consistency to your code.</source>
          <target state="translated">보조 라이브러리의 모든 기능은 기본 API 위에 구축되므로 해당 API로 수행 할 수없는 기능은 제공하지 않습니다. 그럼에도 불구하고 보조 라이브러리를 사용하면 코드 일관성이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="f6848b784c95c8339b84a72671e794bafd5c29ba" translate="yes" xml:space="preserve">
          <source>All functions in this library are provided inside the &lt;a id=&quot;pdf-debug&quot;&gt;&lt;code&gt;debug&lt;/code&gt;&lt;/a&gt; table. All functions that operate over a thread have an optional first argument which is the thread to operate over. The default is always the current thread.</source>
          <target state="translated">이 라이브러리의 모든 함수는 &lt;a id=&quot;pdf-debug&quot;&gt; &lt;code&gt;debug&lt;/code&gt; &lt;/a&gt; 테이블 내에 제공됩니다 . 스레드를 통해 작동하는 모든 함수에는 작동 할 스레드 인 선택적 첫 번째 인수가 있습니다. 기본값은 항상 현재 스레드입니다.</target>
        </trans-unit>
        <trans-unit id="8b98fc2da2d38e4cd78c4bb220a6cf5b66fcdbf5" translate="yes" xml:space="preserve">
          <source>All libraries are implemented through the official C API and are provided as separate C modules. Currently, Lua has the following standard libraries:</source>
          <target state="translated">모든 라이브러리는 공식 C API를 통해 구현되며 별도의 C 모듈로 제공됩니다. 현재 Lua에는 다음과 같은 표준 라이브러리가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ddf3fcb87cb7aa36a3e9257adc61c9538941609" translate="yes" xml:space="preserve">
          <source>All libraries are implemented through the official C API and are provided as separate C modules. Unless otherwise noted, these library functions do not adjust its number of arguments to its expected parameters. For instance, a function documented as &lt;code&gt;foo(arg)&lt;/code&gt; should not be called without an argument.</source>
          <target state="translated">모든 라이브러리는 공식 C API를 통해 구현되며 별도의 C 모듈로 제공됩니다. 달리 언급하지 않는 한 이러한 라이브러리 함수는 인수 수를 예상 매개 변수로 조정하지 않습니다. 예를 들어, &lt;code&gt;foo(arg)&lt;/code&gt; 로 문서화 된 함수 는 인수없이 호출되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="10be42d50eaafb61e391ebcac5db4409c7956116" translate="yes" xml:space="preserve">
          <source>All options are handled in order, except &lt;code&gt;-i&lt;/code&gt; and &lt;code&gt;-E&lt;/code&gt;. For instance, an invocation like</source>
          <target state="translated">&lt;code&gt;-i&lt;/code&gt; 및 &lt;code&gt;-E&lt;/code&gt; 를 제외한 모든 옵션이 순서대로 처리됩니다 . 예를 들어 다음과 같은 호출</target>
        </trans-unit>
        <trans-unit id="1b7b7722940601955048fe77c6f31cf2d41c7761" translate="yes" xml:space="preserve">
          <source>All padding is filled with zeros by &lt;a href=&quot;#pdf-string.pack&quot;&gt;&lt;code&gt;string.pack&lt;/code&gt;&lt;/a&gt; (and ignored by &lt;a href=&quot;#pdf-string.unpack&quot;&gt;&lt;code&gt;string.unpack&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">모든 패딩은 &lt;a href=&quot;#pdf-string.pack&quot;&gt; &lt;code&gt;string.pack&lt;/code&gt; 에&lt;/a&gt; 의해 0으로 채워 지고 &lt;a href=&quot;#pdf-string.unpack&quot;&gt; &lt;code&gt;string.unpack&lt;/code&gt; 에&lt;/a&gt; 의해 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="9b755abe9d75601691ed05f64e03dc198bf8b4ec" translate="yes" xml:space="preserve">
          <source>All padding is filled with zeros by &lt;a href=&quot;#pdf-string.pack&quot;&gt;&lt;code&gt;string.pack&lt;/code&gt;&lt;/a&gt; and ignored by &lt;a href=&quot;#pdf-string.unpack&quot;&gt;&lt;code&gt;string.unpack&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">모든 패딩은 &lt;a href=&quot;#pdf-string.pack&quot;&gt; &lt;code&gt;string.pack&lt;/code&gt; 에&lt;/a&gt; 의해 0으로 채워 지고 &lt;a href=&quot;#pdf-string.unpack&quot;&gt; &lt;code&gt;string.unpack&lt;/code&gt; 에&lt;/a&gt; 의해 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="c35badbdc9570c80976734173cdf4107df29b353" translate="yes" xml:space="preserve">
          <source>All searchers except the first one (preload) return as the extra value the file name where the module was found, as returned by &lt;a href=&quot;#pdf-package.searchpath&quot;&gt;&lt;code&gt;package.searchpath&lt;/code&gt;&lt;/a&gt;. The first searcher returns no extra value.</source>
          <target state="translated">첫 번째 검색 (사전로드)을 제외한 모든 검색자는 &lt;a href=&quot;#pdf-package.searchpath&quot;&gt; &lt;code&gt;package.searchpath&lt;/code&gt; 에&lt;/a&gt; 의해 리턴 된대로 모듈이 발견 된 파일 이름의 추가 값으로 리턴 합니다 . 첫 번째 검색자는 추가 값을 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b6765aac3d8b1ff358b93ffd4bc398b44e25b71d" translate="yes" xml:space="preserve">
          <source>All searchers except the first one (preload) return as the extra value the file path where the module was found, as returned by &lt;a href=&quot;#pdf-package.searchpath&quot;&gt;&lt;code&gt;package.searchpath&lt;/code&gt;&lt;/a&gt;. The first searcher always returns the string &quot;&lt;code&gt;:preload:&lt;/code&gt;&quot;.</source>
          <target state="translated">첫 번째 검색 자 (사전로드)를 제외한 모든 검색자는 &lt;a href=&quot;#pdf-package.searchpath&quot;&gt; &lt;code&gt;package.searchpath&lt;/code&gt; 에서&lt;/a&gt; 반환 한대로 모듈이 발견 된 파일 경로를 추가 값으로 반환 합니다 . 첫 번째 검색자는 항상 &quot; &lt;code&gt;:preload:&lt;/code&gt; &quot; 문자열을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="99fdaa228f269a7cd440d59ce3942091cbc2215f" translate="yes" xml:space="preserve">
          <source>All three control expressions are evaluated only once, before the loop starts. They must all result in numbers.</source>
          <target state="translated">세 가지 제어 표현식은 모두 루프가 시작되기 전에 한 번만 평가됩니다. 그들은 모두 숫자가되어야합니다.</target>
        </trans-unit>
        <trans-unit id="08a75b1f27277905293829400b5db953b7bb2d39" translate="yes" xml:space="preserve">
          <source>All values in Lua are &lt;em&gt;first-class values&lt;/em&gt;. This means that all values can be stored in variables, passed as arguments to other functions, and returned as results.</source>
          <target state="translated">루아의 모든 값은 &lt;em&gt;일류 값&lt;/em&gt; 입니다. 즉, 모든 값을 변수에 저장하고 다른 함수에 인수로 전달한 다음 결과로 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="071aee471e8d140c1bd1a97470ea43f75e0a45ed" translate="yes" xml:space="preserve">
          <source>All values in Lua are first-class values. This means that all values can be stored in variables, passed as arguments to other functions, and returned as results.</source>
          <target state="translated">Lua의 모든 값은 일류 값입니다. 이는 모든 값이 변수에 저장되고 다른 함수에 인수로 전달되고 결과로 반환 될 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="2bd0e37afd18d9af3189d6b1b6cc7f9956125931" translate="yes" xml:space="preserve">
          <source>Allows a program to traverse all fields of a table. Its first argument is a table and its second argument is an index in this table. &lt;code&gt;next&lt;/code&gt; returns the next index of the table and its associated value. When called with &lt;b&gt;nil&lt;/b&gt; as its second argument, &lt;code&gt;next&lt;/code&gt; returns an initial index and its associated value. When called with the last index, or with &lt;b&gt;nil&lt;/b&gt; in an empty table, &lt;code&gt;next&lt;/code&gt; returns &lt;b&gt;nil&lt;/b&gt;. If the second argument is absent, then it is interpreted as &lt;b&gt;nil&lt;/b&gt;. In particular, you can use &lt;code&gt;next(t)&lt;/code&gt; to check whether a table is empty.</source>
          <target state="translated">프로그램이 테이블의 모든 필드를 순회 할 수 있도록합니다. 첫 번째 인수는 테이블이고 두 ​​번째 인수는이 테이블의 색인입니다. &lt;code&gt;next&lt;/code&gt; 는 테이블의 다음 인덱스 및 관련 값을 반환합니다. 두 번째 인수 로 &lt;b&gt;nil&lt;/b&gt; 을 사용하여 호출하면 &lt;code&gt;next&lt;/code&gt; 는 초기 색인과 관련 값을 반환합니다. 마지막 인덱스, 또는 호출하면 &lt;b&gt;전무&lt;/b&gt; 빈 테이블에서, &lt;code&gt;next&lt;/code&gt; 반환 &lt;b&gt;nil을&lt;/b&gt; . 두 번째 인수가 없으면 &lt;b&gt;nil&lt;/b&gt; 로 해석됩니다 . 특히 &lt;code&gt;next(t)&lt;/code&gt; 를 사용 하여 테이블이 비어 있는지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ebc03e7cf3ee58a99f08412145950a59fa5fffde" translate="yes" xml:space="preserve">
          <source>Allows a program to traverse all fields of a table. Its first argument is a table and its second argument is an index in this table. A call to &lt;code&gt;next&lt;/code&gt; returns the next index of the table and its associated value. When called with &lt;b&gt;nil&lt;/b&gt; as its second argument, &lt;code&gt;next&lt;/code&gt; returns an initial index and its associated value. When called with the last index, or with &lt;b&gt;nil&lt;/b&gt; in an empty table, &lt;code&gt;next&lt;/code&gt; returns &lt;b&gt;nil&lt;/b&gt;. If the second argument is absent, then it is interpreted as &lt;b&gt;nil&lt;/b&gt;. In particular, you can use &lt;code&gt;next(t)&lt;/code&gt; to check whether a table is empty.</source>
          <target state="translated">프로그램이 테이블의 모든 필드를 순회 할 수 있도록합니다. 첫 번째 인수는 테이블이고 두 ​​번째 인수는이 테이블의 인덱스입니다. &lt;code&gt;next&lt;/code&gt; 를 호출 하면 테이블의 다음 인덱스와 관련 값이 반환됩니다. 두 번째 인수 로 &lt;b&gt;nil&lt;/b&gt; 을 사용하여 호출하면 &lt;code&gt;next&lt;/code&gt; 는 초기 인덱스와 관련 값을 반환합니다. 마지막 인덱스로 호출하거나 빈 테이블에서 &lt;b&gt;nil&lt;/b&gt; 로 호출하면 &lt;code&gt;next&lt;/code&gt; 는 &lt;b&gt;nil을&lt;/b&gt; 반환합니다 . 두 번째 인수가 없으면 &lt;b&gt;nil&lt;/b&gt; 로 해석됩니다 . 특히 &lt;code&gt;next(t)&lt;/code&gt; 를 사용 하여 테이블이 비어 있는지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1e2a17f106d80620dc6b184a036cc43c0d0d20e9" translate="yes" xml:space="preserve">
          <source>Also as &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt;, this function only loads the chunk; it does not run it.</source>
          <target state="translated">또한 &lt;a href=&quot;#lua_load&quot;&gt; &lt;code&gt;lua_load&lt;/code&gt; &lt;/a&gt; 로이 함수는 청크 만로드합니다. 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="333012935d43c77111be49619f3626aed605f1f6" translate="yes" xml:space="preserve">
          <source>Although Lua has been designed as an extension language, to be embedded in a host C program, it is also frequently used as a standalone language. An interpreter for Lua as a standalone language, called simply &lt;code&gt;lua&lt;/code&gt;, is provided with the standard distribution. The standalone interpreter includes all standard libraries, including the debug library. Its usage is:</source>
          <target state="translated">Lua는 확장 언어로 설계되었지만 호스트 C 프로그램에 내장되기도하지만 독립형 언어로 자주 사용됩니다. 표준 배포판 에는 단순히 &lt;code&gt;lua&lt;/code&gt; 라고하는 독립형 언어 인 Lua의 인터프리터 가 제공됩니다. 독립형 인터프리터에는 디버그 라이브러리를 포함한 모든 표준 라이브러리가 포함됩니다. 사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3fa4ca9bca77aa7261f50ff3ad594e9a7f5b676b" translate="yes" xml:space="preserve">
          <source>Although Lua has been designed as an extension language, to be embedded in a host C program, it is also frequently used as a standalone language. An interpreter for Lua as a standalone language, called simply &lt;code&gt;lua&lt;/code&gt;, is provided with the standard distribution. The standalone interpreter includes all standard libraries. Its usage is:</source>
          <target state="translated">Lua는 확장 언어로 설계되었지만 호스트 C 프로그램에 포함되도록 설계되었지만 독립형 언어로도 자주 사용됩니다. Lua를 독립형 언어로 간단히 &lt;code&gt;lua&lt;/code&gt; 라고하는 인터프리터 가 표준 배포판과 함께 제공됩니다. 독립형 인터프리터에는 모든 표준 라이브러리가 포함됩니다. 사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f591bdff24ecb3f0d81234f57e546b0357fc181a" translate="yes" xml:space="preserve">
          <source>An access to a global variable &lt;code&gt;x&lt;/code&gt; is equivalent to &lt;code&gt;_ENV.x&lt;/code&gt;. Due to the way that chunks are compiled, &lt;code&gt;_ENV&lt;/code&gt; is never a global name (see &lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt;).</source>
          <target state="translated">전역 변수 &lt;code&gt;x&lt;/code&gt; 에 대한 액세스 는 &lt;code&gt;_ENV.x&lt;/code&gt; 와 같습니다 . 청크가 컴파일되는 방식으로 인해 &lt;code&gt;_ENV&lt;/code&gt; 는 절대 전역 이름이 아닙니다 ( &lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="f6c1adca5ebb817b22e7535a132b307a72e116a1" translate="yes" xml:space="preserve">
          <source>An access to a global variable &lt;code&gt;x&lt;/code&gt; is equivalent to &lt;code&gt;_ENV.x&lt;/code&gt;. Due to the way that chunks are compiled, the variable &lt;code&gt;_ENV&lt;/code&gt; itself is never global (see &lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt;).</source>
          <target state="translated">전역 변수 &lt;code&gt;x&lt;/code&gt; 에 대한 액세스 는 &lt;code&gt;_ENV.x&lt;/code&gt; 와 동일합니다 . 청크가 컴파일되는 방식으로 인해 변수 &lt;code&gt;_ENV&lt;/code&gt; 자체는 전역 적이 지 않습니다 ( &lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="3489bcbcdb764986900a0e61314738b50570455a" translate="yes" xml:space="preserve">
          <source>An assignment to a global name &lt;code&gt;x = val&lt;/code&gt; is equivalent to the assignment &lt;code&gt;_ENV.x = val&lt;/code&gt; (see &lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt;).</source>
          <target state="translated">글로벌 이름 할당 &lt;code&gt;x = val&lt;/code&gt; 할당에 해당 &lt;code&gt;_ENV.x = val&lt;/code&gt; (참조 &lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="faeac64cb85287d304252a69d85edf0374894817" translate="yes" xml:space="preserve">
          <source>An integer with the maximum value for an integer.</source>
          <target state="translated">정수의 최대 값을 가진 정수입니다.</target>
        </trans-unit>
        <trans-unit id="7043af6943c0de40fedd4cee1164e62e2ee3cd11" translate="yes" xml:space="preserve">
          <source>An integer with the minimum value for an integer.</source>
          <target state="translated">정수의 최소값을 가진 정수입니다.</target>
        </trans-unit>
        <trans-unit id="89500035571ec2dd822bb6945adc5a8f4bd38006" translate="yes" xml:space="preserve">
          <source>An object is considered &lt;em&gt;dead&lt;/em&gt; as soon as the collector can be sure the object will not be accessed again in the normal execution of the program. (&quot;Normal execution&quot; here excludes finalizers, which can resurrect dead objects (see &lt;a href=&quot;#2.5.3&quot;&gt;&amp;sect;2.5.3&lt;/a&gt;), and excludes also operations using the debug library.) Note that the time when the collector can be sure that an object is dead may not coincide with the programmer's expectations. The only guarantees are that Lua will not collect an object that may still be accessed in the normal execution of the program, and it will eventually collect an object that is inaccessible from Lua. (Here, &lt;em&gt;inaccessible from Lua&lt;/em&gt; means that neither a variable nor another live object refer to the object.) Because Lua has no knowledge about C code, it never collects objects accessible through the registry (see &lt;a href=&quot;#4.3&quot;&gt;&amp;sect;4.3&lt;/a&gt;), which includes the global environment (see &lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt;).</source>
          <target state="translated">수집기가 프로그램의 정상적인 실행에서 개체에 다시 액세스 할 수 없음을 확인하는 즉시 개체는 &lt;em&gt;죽은&lt;/em&gt; 것으로 간주됩니다 . (여기서 &quot;정상 실행&quot;은 죽은 개체를 부활시킬 수있는 종료자를 제외하고 ( &lt;a href=&quot;#2.5.3&quot;&gt;&amp;sect;2.5.3&lt;/a&gt; 참조 )) 디버그 라이브러리를 사용하는 작업도 제외합니다.) 수집기가 개체가 죽었 음을 확인할 수있는 시간이 일치하지 않을 수 있습니다. 프로그래머의 기대에 따라. 유일한 보장은 Lua가 프로그램의 정상적인 실행에서 여전히 액세스 할 수있는 객체를 수집하지 않고 결국 Lua에서 액세스 할 수없는 객체를 수집한다는 것입니다. (여기에서는 &lt;em&gt;Lua&lt;/em&gt; 에서 &lt;em&gt;액세스 할 수 없습니다.&lt;/em&gt;수단은 변수 나 다른 라이브 객체도 객체를 참조하는 것이.) 루아는 C 코드에 대한 지식이 없기 때문에, 그것은 레지스트리 (참조를 통해 액세스 할 개체를 수집하지 &lt;a href=&quot;#4.3&quot;&gt;&amp;sect;4.3&lt;/a&gt; 지구 환경 (참조 포함), &lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="29302dcac6eba15dcddc4542a902b42251fa77ed" translate="yes" xml:space="preserve">
          <source>An opaque structure that points to a thread and indirectly (through the thread) to the whole state of a Lua interpreter. The Lua library is fully reentrant: it has no global variables. All information about a state is accessible through this structure.</source>
          <target state="translated">스레드를 가리키고 간접적으로 (스레드를 통해) Lua 인터프리터의 전체 상태를 나타내는 불투명 한 구조입니다. Lua 라이브러리는 완전히 재진입됩니다. 전역 변수가 없습니다. 상태에 대한 모든 정보는이 구조를 통해 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b2afdee2bff80f7fa27a65f139ce4ca79afecee" translate="yes" xml:space="preserve">
          <source>Any byte in a literal string not explicitly affected by the previous rules represents itself. However, Lua opens files for parsing in text mode, and the system file functions may have problems with some control characters. So, it is safer to represent non-text data as a quoted literal with explicit escape sequences for the non-text characters.</source>
          <target state="translated">리터럴 문자열의 모든 바이트는 이전 규칙의 영향을받지 않습니다. 그러나 Lua는 텍스트 모드에서 구문 분석 할 파일을 열고 시스템 파일 기능에 일부 제어 문자에 문제가있을 수 있습니다. 따라서 텍스트가 아닌 데이터를 텍스트가 아닌 문자에 대한 명시 적 이스케이프 시퀀스가있는 인용 된 리터럴로 나타내는 것이 더 안전합니다.</target>
        </trans-unit>
        <trans-unit id="d8ae7634037aa2de99f261a6927bf456c142bf84" translate="yes" xml:space="preserve">
          <source>Any byte in a literal string not explicitly affected by the previous rules represents itself. However, Lua opens files for parsing in text mode, and the system's file functions may have problems with some control characters. So, it is safer to represent binary data as a quoted literal with explicit escape sequences for the non-text characters.</source>
          <target state="translated">이전 규칙의 영향을받지 않은 리터럴 문자열의 모든 바이트는 자신을 나타냅니다. 그러나 Lua는 텍스트 모드에서 구문 분석을 위해 파일을 열고 시스템의 파일 기능에 일부 제어 문자에 문제가있을 수 있습니다. 따라서 텍스트가 아닌 문자에 대한 명시 적 이스케이프 시퀀스를 사용하여 이진 데이터를 인용 된 리터럴로 나타내는 것이 더 안전합니다.</target>
        </trans-unit>
        <trans-unit id="0060ede52bc0952daad17758c1e09ebce620eaf5" translate="yes" xml:space="preserve">
          <source>Any change in the weakness of a table may take effect only at the next collect cycle. In particular, if you change the weakness to a stronger mode, Lua may still collect some items from that table before the change takes effect.</source>
          <target state="translated">테이블의 약점 변경은 다음 수집 주기에 만 적용됩니다. 특히, 약점을 더 강한 모드로 변경하면 변경 사항이 적용되기 전에 Lua가 해당 테이블에서 일부 항목을 수집 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f738315de077ed686d71d19c5f4cc3874696c9c" translate="yes" xml:space="preserve">
          <source>Any error inside the called function is propagated upwards (with a &lt;code&gt;longjmp&lt;/code&gt;).</source>
          <target state="translated">호출 된 함수 내부의 모든 오류는 위쪽으로 전파됩니다 ( &lt;code&gt;longjmp&lt;/code&gt; 사용 ).</target>
        </trans-unit>
        <trans-unit id="1c05361fbe6d9fff1fca4506d17a5414301a0c77" translate="yes" xml:space="preserve">
          <source>Any error while calling and running the function is propagated upwards (with a &lt;code&gt;longjmp&lt;/code&gt;).</source>
          <target state="translated">함수를 호출하고 실행하는 동안 발생하는 오류는 위쪽으로 전파됩니다 ( &lt;code&gt;longjmp&lt;/code&gt; 사용 ).</target>
        </trans-unit>
        <trans-unit id="be7b70704b4f056a67191dc249a6f48adae84426" translate="yes" xml:space="preserve">
          <source>Any error while running a finalizer generates a warning; the error is not propagated.</source>
          <target state="translated">종료자를 실행하는 동안 오류가 발생하면 경고가 생성됩니다. 오류가 전파되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7b037f464e01b904a69f5673d5e1aeced352fda1" translate="yes" xml:space="preserve">
          <source>Any expression enclosed in parentheses always results in only one value. Thus, &lt;code&gt;(f(x,y,z))&lt;/code&gt; is always a single value, even if &lt;code&gt;f&lt;/code&gt; returns several values. (The value of &lt;code&gt;(f(x,y,z))&lt;/code&gt; is the first value returned by &lt;code&gt;f&lt;/code&gt; or &lt;b&gt;nil&lt;/b&gt; if &lt;code&gt;f&lt;/code&gt; does not return any values.)</source>
          <target state="translated">괄호로 묶인 표현식은 항상 하나의 값만 발생합니다. 따라서 &lt;code&gt;f&lt;/code&gt; 가 여러 값을 반환 하더라도 &lt;code&gt;(f(x,y,z))&lt;/code&gt; 는 항상 단일 값입니다. (값 &lt;code&gt;(f(x,y,z))&lt;/code&gt; 에 의해 반환되는 첫 번째 값 &lt;code&gt;f&lt;/code&gt; 또는 &lt;b&gt;전무&lt;/b&gt; 경우 &lt;code&gt;f&lt;/code&gt; 는 임의의 값을 리턴하지 않는다.)&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7a4d95ffedc5bbaa1adc38079189908a5033db52" translate="yes" xml:space="preserve">
          <source>Any format string starts as if prefixed by &quot;&lt;code&gt;!1=&lt;/code&gt;&quot;, that is, with maximum alignment of 1 (no alignment) and native endianness.</source>
          <target state="translated">모든 형식 문자열은 &quot; &lt;code&gt;!1=&lt;/code&gt; &quot; 로 시작하는 것처럼 시작합니다 . 즉, 최대 정렬 1 (정렬 없음) 및 고유 엔디안입니다.</target>
        </trans-unit>
        <trans-unit id="646e2060904f262b44a42847531c18e9dbcd493e" translate="yes" xml:space="preserve">
          <source>Any function in the API that receives stack indices works only with &lt;em&gt;valid indices&lt;/em&gt; or &lt;em&gt;acceptable indices&lt;/em&gt;.</source>
          <target state="translated">스택 인덱스를받는 API의 모든 함수는 &lt;em&gt;유효한 인덱스&lt;/em&gt; 또는 &lt;em&gt;허용 가능한 인덱스&lt;/em&gt; 에서만 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="1687626599a587d25400fc4ce2fc6e934da6f356" translate="yes" xml:space="preserve">
          <source>Any function to be callable by Lua must follow the correct protocol to receive its parameters and return its results (see &lt;a href=&quot;#lua_CFunction&quot;&gt;&lt;code&gt;lua_CFunction&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Lua가 호출 할 수있는 모든 함수는 올바른 프로토콜을 따라 매개 변수를 수신하고 결과를 리턴해야합니다 ( &lt;a href=&quot;#lua_CFunction&quot;&gt; &lt;code&gt;lua_CFunction&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="185d7a33eb3655abd764787ebf509971ea6392f6" translate="yes" xml:space="preserve">
          <source>Any table used as the value of &lt;code&gt;_ENV&lt;/code&gt; is called an &lt;em&gt;environment&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;_ENV&lt;/code&gt; 값으로 사용 된 모든 테이블을 &lt;em&gt;환경&lt;/em&gt; 이라고 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c0c786e87f6aa7c682c7c682888f5d96ee64056b" translate="yes" xml:space="preserve">
          <source>Any variable name is assumed to be global unless explicitly declared as a local (see &lt;a href=&quot;#3.3.7&quot;&gt;&amp;sect;3.3.7&lt;/a&gt;). Local variables are &lt;em&gt;lexically scoped&lt;/em&gt;: local variables can be freely accessed by functions defined inside their scope (see &lt;a href=&quot;#3.5&quot;&gt;&amp;sect;3.5&lt;/a&gt;).</source>
          <target state="translated">지역 변수로 명시 적으로 선언되지 않은 한 모든 변수 이름은 전역 이름으로 간주됩니다 ( &lt;a href=&quot;#3.3.7&quot;&gt;&amp;sect;3.3.7&lt;/a&gt; 참조 ). 지역 변수는 &lt;em&gt;어휘 범위입니다&lt;/em&gt; . 지역 변수는 해당 범위 내에 정의 된 함수를 통해 자유롭게 액세스 할 수 있습니다 ( &lt;a href=&quot;#3.5&quot;&gt;&amp;sect;3.5 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="a78246fd7dee1462777916bec1d99382a25c060e" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;f&lt;/code&gt; is the hook function. &lt;code&gt;mask&lt;/code&gt; specifies on which events the hook will be called: it is formed by a bitwise OR of the constants &lt;a id=&quot;pdf-LUA_MASKCALL&quot;&gt;&lt;code&gt;LUA_MASKCALL&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_MASKRET&quot;&gt;&lt;code&gt;LUA_MASKRET&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_MASKLINE&quot;&gt;&lt;code&gt;LUA_MASKLINE&lt;/code&gt;&lt;/a&gt;, and &lt;a id=&quot;pdf-LUA_MASKCOUNT&quot;&gt;&lt;code&gt;LUA_MASKCOUNT&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;count&lt;/code&gt; argument is only meaningful when the mask includes &lt;code&gt;LUA_MASKCOUNT&lt;/code&gt;. For each event, the hook is called as explained below:</source>
          <target state="translated">인수 &lt;code&gt;f&lt;/code&gt; 는 후크 기능입니다. &lt;code&gt;mask&lt;/code&gt; 는 후크가 호출 될 이벤트를 지정합니다. 상수 &lt;a id=&quot;pdf-LUA_MASKCALL&quot;&gt; &lt;code&gt;LUA_MASKCALL&lt;/code&gt; &lt;/a&gt; , &lt;a id=&quot;pdf-LUA_MASKRET&quot;&gt; &lt;code&gt;LUA_MASKRET&lt;/code&gt; &lt;/a&gt; , &lt;a id=&quot;pdf-LUA_MASKLINE&quot;&gt; &lt;code&gt;LUA_MASKLINE&lt;/code&gt; &lt;/a&gt; 및 &lt;a id=&quot;pdf-LUA_MASKCOUNT&quot;&gt; &lt;code&gt;LUA_MASKCOUNT&lt;/code&gt; &lt;/a&gt; 의 비트 단위 OR에 의해 형성됩니다 . &lt;code&gt;count&lt;/code&gt; 인수는 마스크가 포함 된 경우에만 의미가 &lt;code&gt;LUA_MASKCOUNT&lt;/code&gt; 을 . 각 이벤트에 대해 후크는 아래 설명 된대로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="fef66cc0524e2056cb5b4bfefd4a25591b35ea85" translate="yes" xml:space="preserve">
          <source>Arguments have the following syntax:</source>
          <target state="translated">인수의 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6104f39ed22a2cd32e98536a3447a01c4b9f4781" translate="yes" xml:space="preserve">
          <source>Arithmetic Operators</source>
          <target state="translated">산술 연산자</target>
        </trans-unit>
        <trans-unit id="9c834ef6f4ffe0319762efe06a63f2041cc46cbe" translate="yes" xml:space="preserve">
          <source>As &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt;, this function only loads the chunk; it does not run it.</source>
          <target state="translated">로 &lt;a href=&quot;#lua_load&quot;&gt; &lt;code&gt;lua_load&lt;/code&gt; &lt;/a&gt; ,이 기능은 청크를로드; 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="75c1c75adc6b7338308d99ea7e69e602ff6179f0" translate="yes" xml:space="preserve">
          <source>As a special case, the capture &lt;code&gt;()&lt;/code&gt; captures the current string position (a number). For instance, if we apply the pattern &lt;code&gt;&quot;()aa()&quot;&lt;/code&gt; on the string &lt;code&gt;&quot;flaaap&quot;&lt;/code&gt;, there will be two captures: 3 and 5.</source>
          <target state="translated">특수한 경우 캡처 &lt;code&gt;()&lt;/code&gt; 는 현재 문자열 위치 (숫자)를 캡처합니다. 예를 들어 &lt;code&gt;&quot;flaaap&quot;&lt;/code&gt; 문자열에 &lt;code&gt;&quot;()aa()&quot;&lt;/code&gt; 패턴을 적용하면 3과 5의 두 가지 캡처가 있습니다.</target>
        </trans-unit>
        <trans-unit id="88fec743575b609e2abb343864ded003e7d1df35" translate="yes" xml:space="preserve">
          <source>As a special case, the empty capture &lt;code&gt;()&lt;/code&gt; captures the current string position (a number). For instance, if we apply the pattern &lt;code&gt;&quot;()aa()&quot;&lt;/code&gt; on the string &lt;code&gt;&quot;flaaap&quot;&lt;/code&gt;, there will be two captures: 3 and 5.</source>
          <target state="translated">특별한 경우 빈 캡처 &lt;code&gt;()&lt;/code&gt; 는 현재 문자열 위치 (숫자)를 캡처합니다. 예를 들어 &lt;code&gt;&quot;flaaap&quot;&lt;/code&gt; 문자열에 &lt;code&gt;&quot;()aa()&quot;&lt;/code&gt; 패턴을 적용하면 3과 5의 두 가지 캡처가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="608b10320a24077d4060bee1b1e8e54c6bf52c0d" translate="yes" xml:space="preserve">
          <source>As a special case, when &lt;code&gt;n&lt;/code&gt; is 0 the function returns the start of the encoding of the character that contains the &lt;code&gt;i&lt;/code&gt;-th byte of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">특별한 경우로, &lt;code&gt;n&lt;/code&gt; 이 0이면이 함수는 &lt;code&gt;s&lt;/code&gt; 의 &lt;code&gt;i&lt;/code&gt; 번째 바이트 를 포함하는 문자의 인코딩 시작을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="43f16f56abca8a29fd824d5c58c8606029f22356" translate="yes" xml:space="preserve">
          <source>As an example of how coroutines work, consider the following code:</source>
          <target state="translated">코 루틴이 작동하는 방법의 예로 다음 코드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="55fd3c324f7088b1e4e4ef9627852502a3224e79" translate="yes" xml:space="preserve">
          <source>As an example, consider the following definitions:</source>
          <target state="translated">예를 들어 다음 정의를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="7cd41136af5368119d5e9b9681dc2f5307b6d39b" translate="yes" xml:space="preserve">
          <source>As an example, in a system using ASCII (in which '&lt;code&gt;a&lt;/code&gt;' is coded as 97, newline is coded as 10, and '&lt;code&gt;1&lt;/code&gt;' is coded as 49), the five literal strings below denote the same string:</source>
          <target state="translated">예를 들어, ASCII를 사용하는 시스템 ( ' &lt;code&gt;a&lt;/code&gt; '는 97로 코딩되고 개행은 10으로 코딩되고 ' &lt;code&gt;1&lt;/code&gt; '은 49로 코딩 됨)에서 아래의 5 개 리터럴 문자열은 동일한 문자열을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="74222d71219a9516ef23c72ea9fe93b833f10fca" translate="yes" xml:space="preserve">
          <source>As an example, the following function receives a variable number of numeric arguments and returns their average and their sum:</source>
          <target state="translated">예를 들어 다음 함수는 가변 개수의 숫자 인수를 받고 평균과 합계를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e53c537a917ff61bdeaf745cd25b581253b587b4" translate="yes" xml:space="preserve">
          <source>As an example, the following loop will iterate over all the words from string &lt;code&gt;s&lt;/code&gt;, printing one per line:</source>
          <target state="translated">예를 들어, 다음 루프는 string &lt;code&gt;s&lt;/code&gt; 의 모든 단어를 반복하여 한 줄에 하나씩 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="10342e6eb6b2fd67fdff1919f85d366e227d7fc9" translate="yes" xml:space="preserve">
          <source>As an extension language, Lua has no notion of a &quot;main&quot; program: it works &lt;em&gt;embedded&lt;/em&gt; in a host client, called the &lt;em&gt;embedding program&lt;/em&gt; or simply the &lt;em&gt;host&lt;/em&gt;. (Frequently, this host is the stand-alone &lt;code&gt;lua&lt;/code&gt; program.) The host program can invoke functions to execute a piece of Lua code, can write and read Lua variables, and can register C functions to be called by Lua code. Through the use of C functions, Lua can be augmented to cope with a wide range of different domains, thus creating customized programming languages sharing a syntactical framework.</source>
          <target state="translated">확장 언어로서 Lua는 &quot;메인&quot;프로그램에 대한 개념을 가지고 있지 않습니다.이 &lt;em&gt;프로그램&lt;/em&gt; 은 &lt;em&gt;내장 프로그램&lt;/em&gt; 또는 간단히 &lt;em&gt;호스트&lt;/em&gt; 라는 호스트 클라이언트에 &lt;em&gt;내장&lt;/em&gt; 되어 작동 &lt;em&gt;합니다&lt;/em&gt; . (이 호스트는 독립형 &lt;code&gt;lua&lt;/code&gt; 프로그램입니다.) 호스트 프로그램은 함수를 호출하여 Lua 코드를 실행하고 Lua 변수를 읽고 읽을 수 있으며 Lua 코드에서 호출 할 C 함수를 등록 할 수 있습니다. C 함수의 사용을 통해 Lua는 광범위한 다른 도메인에 대처할 수 있도록 확장되어 구문 구조를 공유하는 맞춤형 프로그래밍 언어를 만들 수 있습니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="18e8b25f2432d6d4994bc8412127c9c6a9fd835a" translate="yes" xml:space="preserve">
          <source>As an illustration, consider the following function:</source>
          <target state="translated">예를 들어 다음 기능을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="f3e9897f2d1040dc7274b7624604db4d8b6ac14f" translate="yes" xml:space="preserve">
          <source>As in most C libraries, the Lua API functions do not check their arguments for validity or consistency. However, you can change this behavior by compiling Lua with the macro &lt;a id=&quot;pdf-LUA_USE_APICHECK&quot;&gt;&lt;code&gt;LUA_USE_APICHECK&lt;/code&gt;&lt;/a&gt; defined.</source>
          <target state="translated">대부분의 C 라이브러리에서와 같이 Lua API 함수는 인수의 유효성 또는 일관성을 검사하지 않습니다. 그러나 &lt;a id=&quot;pdf-LUA_USE_APICHECK&quot;&gt; &lt;code&gt;LUA_USE_APICHECK&lt;/code&gt; &lt;/a&gt; 매크로를 정의 하여 Lua를 컴파일하면이 동작을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="24c57582c72da098884fa076ca9862645c6e1334" translate="yes" xml:space="preserve">
          <source>As usual, you can use parentheses to change the precedences of an expression. The concatenation ('&lt;code&gt;..&lt;/code&gt;') and exponentiation ('&lt;code&gt;^&lt;/code&gt;') operators are right associative. All other binary operators are left associative.</source>
          <target state="translated">평소처럼 괄호를 사용하여 식의 우선 순위를 변경할 수 있습니다. 연결 ( ' &lt;code&gt;..&lt;/code&gt; ') 및 지수 ( ' &lt;code&gt;^&lt;/code&gt; ') 연산자는 올바른 연관입니다. 다른 모든 이진 연산자는 연관되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c494ccaeb3182bcdc157f35c0dfa7624c73ca058" translate="yes" xml:space="preserve">
          <source>As we will discuss further in &lt;a href=&quot;#3.2&quot;&gt;&amp;sect;3.2&lt;/a&gt; and &lt;a href=&quot;#3.3.3&quot;&gt;&amp;sect;3.3.3&lt;/a&gt;, any reference to a free name (that is, a name not bound to any declaration) &lt;code&gt;var&lt;/code&gt; is syntactically translated to &lt;code&gt;_ENV.var&lt;/code&gt;. Moreover, every chunk is compiled in the scope of an external local variable named &lt;code&gt;_ENV&lt;/code&gt; (see &lt;a href=&quot;#3.3.2&quot;&gt;&amp;sect;3.3.2&lt;/a&gt;), so &lt;code&gt;_ENV&lt;/code&gt; itself is never a free name in a chunk.</source>
          <target state="translated">우리가 더 논의 할 예정으로 &lt;a href=&quot;#3.2&quot;&gt;&amp;sect;3.2&lt;/a&gt; 및 &lt;a href=&quot;#3.3.3&quot;&gt;&amp;sect;3.3.3&lt;/a&gt; , 무료 이름에 대한 참조는 (즉, 이름은 임의의 선언에 구속되지 않음) &lt;code&gt;var&lt;/code&gt; 구문 적으로 변환됩니다 &lt;code&gt;_ENV.var&lt;/code&gt; . 또한 모든 청크는 &lt;code&gt;_ENV&lt;/code&gt; ( &lt;a href=&quot;#3.3.2&quot;&gt;&amp;sect;3.3.2&lt;/a&gt; 참조 ) 라는 외부 지역 변수의 범위에서 컴파일 되므로 &lt;code&gt;_ENV&lt;/code&gt; 자체는 청크에서 자유 이름이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="90c78100181d409a60710e1b3cf4f61c8d6e6ff7" translate="yes" xml:space="preserve">
          <source>As will be discussed in &lt;a href=&quot;#3.2&quot;&gt;&amp;sect;3.2&lt;/a&gt; and &lt;a href=&quot;#3.3.3&quot;&gt;&amp;sect;3.3.3&lt;/a&gt;, any reference to a free name (that is, a name not bound to any declaration) &lt;code&gt;var&lt;/code&gt; is syntactically translated to &lt;code&gt;_ENV.var&lt;/code&gt;. Moreover, every chunk is compiled in the scope of an external local variable named &lt;code&gt;_ENV&lt;/code&gt; (see &lt;a href=&quot;#3.3.2&quot;&gt;&amp;sect;3.3.2&lt;/a&gt;), so &lt;code&gt;_ENV&lt;/code&gt; itself is never a free name in a chunk.</source>
          <target state="translated">로 논의 될 것이다 &lt;a href=&quot;#3.2&quot;&gt;&amp;sect;3.2&lt;/a&gt; 및 &lt;a href=&quot;#3.3.3&quot;&gt;&amp;sect;3.3.3&lt;/a&gt; , 무료 이름에 대한 참조는 (즉, 어떤 선언에 바인딩되지 이름) &lt;code&gt;var&lt;/code&gt; 구문 적으로 변환됩니다 &lt;code&gt;_ENV.var&lt;/code&gt; . 또한 모든 청크는 &lt;code&gt;_ENV&lt;/code&gt; 라는 외부 로컬 변수 범위에서 컴파일되므로 ( &lt;a href=&quot;#3.3.2&quot;&gt;&amp;sect;3.3.2&lt;/a&gt; 참조 ) &lt;code&gt;_ENV&lt;/code&gt; 자체는 절대로 청크에서 사용 가능한 이름이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e55df441e8955746182110c3946288f381520e83" translate="yes" xml:space="preserve">
          <source>Assignment</source>
          <target state="translated">Assignment</target>
        </trans-unit>
        <trans-unit id="3b37b5372cc754e07c5399ff64d83d0917ca19d3" translate="yes" xml:space="preserve">
          <source>At start-up, Lua initializes this variable with the value of the environment variable &lt;a id=&quot;pdf-LUA_PATH_5_3&quot;&gt;&lt;code&gt;LUA_PATH_5_3&lt;/code&gt;&lt;/a&gt; or the environment variable &lt;a id=&quot;pdf-LUA_PATH&quot;&gt;&lt;code&gt;LUA_PATH&lt;/code&gt;&lt;/a&gt; or with a default path defined in &lt;code&gt;luaconf.h&lt;/code&gt;, if those environment variables are not defined. Any &quot;&lt;code&gt;;;&lt;/code&gt;&quot; in the value of the environment variable is replaced by the default path.</source>
          <target state="translated">시동시, Lua는 환경 변수의 값에,이 변수를 초기화 &lt;a id=&quot;pdf-LUA_PATH_5_3&quot;&gt; &lt;code&gt;LUA_PATH_5_3&lt;/code&gt; &lt;/a&gt; 또는 환경 변수 &lt;a id=&quot;pdf-LUA_PATH&quot;&gt; &lt;code&gt;LUA_PATH&lt;/code&gt; &lt;/a&gt; 또는 정의 기본 경로 &lt;code&gt;luaconf.h&lt;/code&gt; 이러한 환경 변수가 정의되지 않은 경우. 환경 변수 값의 &quot; &lt;code&gt;;;&lt;/code&gt; &quot;은 기본 경로로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="965a8cf37e38c2b411498c9c98d14641fb5a6675" translate="yes" xml:space="preserve">
          <source>At start-up, Lua initializes this variable with the value of the environment variable &lt;a id=&quot;pdf-LUA_PATH_5_4&quot;&gt;&lt;code&gt;LUA_PATH_5_4&lt;/code&gt;&lt;/a&gt; or the environment variable &lt;a id=&quot;pdf-LUA_PATH&quot;&gt;&lt;code&gt;LUA_PATH&lt;/code&gt;&lt;/a&gt; or with a default path defined in &lt;code&gt;luaconf.h&lt;/code&gt;, if those environment variables are not defined. A &quot;&lt;code&gt;;;&lt;/code&gt;&quot; in the value of the environment variable is replaced by the default path.</source>
          <target state="translated">시동시, Lua는 환경 변수의 값에,이 변수를 초기화 &lt;a id=&quot;pdf-LUA_PATH_5_4&quot;&gt; &lt;code&gt;LUA_PATH_5_4&lt;/code&gt; &lt;/a&gt; 또는 환경 변수 &lt;a id=&quot;pdf-LUA_PATH&quot;&gt; &lt;code&gt;LUA_PATH&lt;/code&gt; &lt;/a&gt; 또는 정의 기본 경로 &lt;code&gt;luaconf.h&lt;/code&gt; 이러한 환경 변수가 정의되지 않은 경우. 환경 변수 값의 &quot; &lt;code&gt;;;&lt;/code&gt; &quot;은 기본 경로로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="c2035e1ea09cb7bf6e711b474366484c8cc2dadf" translate="yes" xml:space="preserve">
          <source>At the end of each garbage-collection cycle, the finalizers are called in the reverse order that the objects were marked for finalization, among those collected in that cycle; that is, the first finalizer to be called is the one associated with the object marked last in the program. The execution of each finalizer may occur at any point during the execution of the regular code.</source>
          <target state="translated">각 가비지 수집주기가 끝날 때 종료자는 해당주기에서 수집 된 개체 중에서 개체가 종료되도록 표시된 역순으로 호출됩니다. 즉, 호출 될 첫 번째 종료자는 프로그램에서 마지막으로 표시된 개체와 관련된 것입니다. 각 종료 자의 실행은 일반 코드를 실행하는 동안 언제든지 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c846064774d3fc9a0c20918821eeca9ef19288b" translate="yes" xml:space="preserve">
          <source>At the end of each garbage-collection cycle, the finalizers for objects are called in the reverse order that the objects were marked for finalization, among those collected in that cycle; that is, the first finalizer to be called is the one associated with the object marked last in the program. The execution of each finalizer may occur at any point during the execution of the regular code.</source>
          <target state="translated">가비지 수집주기가 끝날 때마다 해당주기에서 수집 된 객체 중에서 객체에 대한 최종 자 (finalizer)가 객체가 최종 표시 대상인 역순으로 호출됩니다. 즉, 첫 번째로 호출되는 종료자는 프로그램에서 마지막으로 표시된 오브젝트와 연관된 것입니다. 각 종료 자의 실행은 일반 코드 실행 중 언제라도 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b97861ba9e02b6857fb91f3d5b2a8013e6bffda" translate="yes" xml:space="preserve">
          <source>Auxiliary Library</source>
          <target state="translated">보조 도서관</target>
        </trans-unit>
        <trans-unit id="5eab8fc3ffa32aa796174a77104a420884806a36" translate="yes" xml:space="preserve">
          <source>Basic Concepts</source>
          <target state="translated">기본 개념</target>
        </trans-unit>
        <trans-unit id="8f4cb4f0510bd523b95aae50ed7278eb36070fa4" translate="yes" xml:space="preserve">
          <source>Because Lua has garbage collection, there is no guarantee that the pointer returned by &lt;code&gt;lua_tolstring&lt;/code&gt; will be valid after the corresponding Lua value is removed from the stack.</source>
          <target state="translated">Lua에 가비지 콜렉션 이 있으므로 &lt;code&gt;lua_tolstring&lt;/code&gt; 이 리턴 한 포인터 가 스택에서 해당 Lua 값을 제거한 후에 유효 하다는 보장은 없습니다 .</target>
        </trans-unit>
        <trans-unit id="9867425ec7caa9ffe56a90d8c50150cf1121dd68" translate="yes" xml:space="preserve">
          <source>Because Lua is an embedded extension language, Lua code starts running by a call from C code in the host program. (When you use Lua standalone, the &lt;code&gt;lua&lt;/code&gt; application is the host program.) Usually, this call is protected; so, when an otherwise unprotected error occurs during the compilation or execution of a Lua chunk, control returns to the host, which can take appropriate measures, such as printing an error message.</source>
          <target state="translated">Lua는 임베디드 확장 언어이기 때문에 Lua 코드는 호스트 프로그램의 C 코드에서 호출하여 실행됩니다. (Lua 독립형을 사용하는 경우 &lt;code&gt;lua&lt;/code&gt; 응용 프로그램은 호스트 프로그램입니다.) 일반적으로이 호출은 보호됩니다. 따라서 Lua 청크를 컴파일하거나 실행하는 동안 보호되지 않은 오류가 발생하면 제어가 호스트로 돌아와 오류 메시지 인쇄와 같은 적절한 조치를 취할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e550731f0f7f512357918c5d533714fe0133257" translate="yes" xml:space="preserve">
          <source>Because Lua is an embedded extension language, all Lua actions start from C code in the host program calling a function from the Lua library. (When you use Lua standalone, the &lt;code&gt;lua&lt;/code&gt; application is the host program.) Whenever an error occurs during the compilation or execution of a Lua chunk, control returns to the host, which can take appropriate measures (such as printing an error message).</source>
          <target state="translated">Lua는 임베디드 확장 언어이므로 모든 Lua 작업은 호스트 프로그램의 C 코드에서 시작하여 Lua 라이브러리에서 함수를 호출합니다. Lua 독립 실행 형을 사용하는 경우 &lt;code&gt;lua&lt;/code&gt; 응용 프로그램은 호스트 프로그램입니다. Lua 청크를 컴파일하거나 실행하는 동안 오류가 발생할 때마다 제어가 호스트로 돌아가며 적절한 조치를 취할 수 있습니다 (예 : 오류 메시지 인쇄).</target>
        </trans-unit>
        <trans-unit id="0fad2c0ffc739d9f59d3ff44590e127f2bd7b785" translate="yes" xml:space="preserve">
          <source>Because metatables are regular tables, they can contain arbitrary fields, not only the event names defined above. Some functions in the standard library (e.g., &lt;a href=&quot;#pdf-tostring&quot;&gt;&lt;code&gt;tostring&lt;/code&gt;&lt;/a&gt;) use other fields in metatables for their own purposes.</source>
          <target state="translated">메타 테이블은 일반 테이블이므로 위에서 정의한 이벤트 이름뿐만 아니라 임의의 필드를 포함 할 수 있습니다. 표준 라이브러리의 일부 함수 (예 : &lt;a href=&quot;#pdf-tostring&quot;&gt; &lt;code&gt;tostring&lt;/code&gt; &lt;/a&gt; )는 메타 테이블의 다른 필드를 자체 목적으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="495988fc34ba4e9a5d09e95cf0bb4b8cc2aa52f9" translate="yes" xml:space="preserve">
          <source>Because of the lexical scoping rules, local variables can be freely accessed by functions defined inside their scope. A local variable used by an inner function is called an &lt;em&gt;upvalue&lt;/em&gt; (or &lt;em&gt;external local variable&lt;/em&gt;, or simply &lt;em&gt;external variable&lt;/em&gt;) inside the inner function.</source>
          <target state="translated">어휘 범위 지정 규칙으로 인해 지역 변수는 범위 내에 정의 된 함수에서 자유롭게 액세스 할 수 있습니다. 내부 함수에서 사용하는 지역 변수를 내부 함수 내부에서 &lt;em&gt;upvalue&lt;/em&gt; (또는 &lt;em&gt;외부 지역 변수&lt;/em&gt; 또는 간단히 &lt;em&gt;외부 변수&lt;/em&gt; ) 라고 합니다.</target>
        </trans-unit>
        <trans-unit id="ceef25556ecac12093ede647b1814c0461f552fa" translate="yes" xml:space="preserve">
          <source>Because of the lexical scoping rules, local variables can be freely accessed by functions defined inside their scope. A local variable used by an inner function is called an &lt;em&gt;upvalue&lt;/em&gt;, or &lt;em&gt;external local variable&lt;/em&gt;, inside the inner function.</source>
          <target state="translated">어휘 범위 규칙으로 인해 해당 범위 내에 정의 된 함수를 통해 로컬 변수에 자유롭게 액세스 할 수 있습니다. 내부 함수가 사용하는 로컬 변수를 내부 함수 내부의 &lt;em&gt;upvalue&lt;/em&gt; 또는 &lt;em&gt;외부 로컬 변수&lt;/em&gt; 라고 합니다.</target>
        </trans-unit>
        <trans-unit id="91c78c2bb9d15ae1e5ff63f172baeb9a3a177d44" translate="yes" xml:space="preserve">
          <source>Because the object being collected must still be used by the finalizer, that object (and other objects accessible only through it) must be &lt;em&gt;resurrected&lt;/em&gt; by Lua. Usually, this resurrection is transient, and the object memory is freed in the next garbage-collection cycle. However, if the finalizer stores the object in some global place (e.g., a global variable), then the resurrection is permanent. Moreover, if the finalizer marks a finalizing object for finalization again, its finalizer will be called again in the next cycle where the object is dead. In any case, the object memory is freed only in a GC cycle where the object is dead and not marked for finalization.</source>
          <target state="translated">수집되는 개체는 종료 자에서 계속 사용해야하므로 해당 개체 (및이를 통해서만 액세스 할 수있는 다른 개체)는 Lua에 의해 &lt;em&gt;부활&lt;/em&gt; 되어야합니다 . 일반적으로이 부활은 일시적이며 다음 가비지 수집주기에서 개체 메모리가 해제됩니다. 그러나 종료자가 객체를 전역 위치 (예 : 전역 변수)에 저장하면 부활은 영구적입니다. 또한 종료자가 종료를 위해 종료 객체를 다시 표시하면 객체가 죽은 다음주기에서 종료자가 다시 호출됩니다. 어쨌든 객체 메모리는 객체가 죽고 종료 표시가없는 GC주기에서만 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="100abb5c579b396b2c34374efb4ff5f9d32a765e" translate="yes" xml:space="preserve">
          <source>Because the object being collected must still be used by the finalizer, that object (and other objects accessible only through it) must be &lt;em&gt;resurrected&lt;/em&gt; by Lua. Usually, this resurrection is transient, and the object memory is freed in the next garbage-collection cycle. However, if the finalizer stores the object in some global place (e.g., a global variable), then the resurrection is permanent. Moreover, if the finalizer marks a finalizing object for finalization again, its finalizer will be called again in the next cycle where the object is unreachable. In any case, the object memory is freed only in a GC cycle where the object is unreachable and not marked for finalization.</source>
          <target state="translated">수집중인 객체는 여전히 종료 프로그램에서 사용해야하므로 해당 객체 (및 객체를 통해서만 액세스 할 수있는 다른 객체)는 Lua에서 &lt;em&gt;부활&lt;/em&gt; 해야합니다 . 일반적으로이 부활은 일시적이며 다음 가비지 수집주기에서 개체 메모리가 해제됩니다. 그러나 파이널 라이저가 객체를 전역 위치 (예 : 전역 변수)에 저장하면 부활은 영구적입니다. 또한 종료자가 종료를 위해 종료 오브젝트를 다시 표시하면 오브젝트에 도달 할 수없는 다음주기에서 종료자가 다시 호출됩니다. 어쨌든, 오브젝트 메모리는 오브젝트에 도달 할 수없고 종료 표시가없는 GC주기에서만 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="6d5b47e3e1cfd97e4c1094c7771191d76ffbf4e8" translate="yes" xml:space="preserve">
          <source>Before running any code, &lt;code&gt;lua&lt;/code&gt; collects all command-line arguments in a global table called &lt;code&gt;arg&lt;/code&gt;. The script name goes to index 0, the first argument after the script name goes to index 1, and so on. Any arguments before the script name (that is, the interpreter name plus its options) go to negative indices. For instance, in the call</source>
          <target state="translated">코드를 실행하기 전에 &lt;code&gt;lua&lt;/code&gt; 는 모든 명령 줄 인수를 &lt;code&gt;arg&lt;/code&gt; 라는 전역 테이블에 수집합니다 . 스크립트 이름은 인덱스 0으로 이동하고 스크립트 이름 다음의 첫 번째 인수는 인덱스 1로 이동합니다. 스크립트 이름 앞의 인수 (인터프리터 이름과 해당 옵션)는 음수로 이동합니다. 예를 들어, 전화</target>
        </trans-unit>
        <trans-unit id="509f3eacc4f43f22f296d1f65ef40407b2f61bf0" translate="yes" xml:space="preserve">
          <source>Before the assignment, the list of values is &lt;em&gt;adjusted&lt;/em&gt; to the length of the list of variables. If there are more values than needed, the excess values are thrown away. If there are fewer values than needed, the list is extended with &lt;b&gt;nil&lt;/b&gt;'s. If the list of expressions ends with a function call, then all values returned by that call enter the list of values, before the adjustment (except when the call is enclosed in parentheses; see &lt;a href=&quot;#3.4&quot;&gt;&amp;sect;3.4&lt;/a&gt;).</source>
          <target state="translated">할당 전에 값 목록은 변수 목록의 길이에 &lt;em&gt;맞게 조정&lt;/em&gt; 됩니다. 필요한 것보다 더 많은 값이있는 경우 초과 값은 버려집니다. 필요한 것보다 적은 값이 있으면 목록이 &lt;b&gt;nil&lt;/b&gt; 로 확장됩니다 . 표현식 목록이 함수 호출로 끝나는 경우 해당 호출에서 반환 된 모든 값은 조정 전에 값 목록을 입력합니다 (호출이 괄호로 묶인 경우 제외, &lt;a href=&quot;#3.4&quot;&gt;&amp;sect;3.4&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="41d09b228ef66be3a22078c99e4ef2dcb3df78d1" translate="yes" xml:space="preserve">
          <source>Before the assignment, the list of values is &lt;em&gt;adjusted&lt;/em&gt; to the length of the list of variables. If there are more values than needed, the excess values are thrown away. If there are fewer values than needed, the list is extended with as many &lt;b&gt;nil&lt;/b&gt;'s as needed. If the list of expressions ends with a function call, then all values returned by that call enter the list of values, before the adjustment (except when the call is enclosed in parentheses; see &lt;a href=&quot;#3.4&quot;&gt;&amp;sect;3.4&lt;/a&gt;).</source>
          <target state="translated">대입하기 전에 값 목록이 변수 목록의 길이에 &lt;em&gt;맞게 조정&lt;/em&gt; 됩니다. 필요한 것보다 많은 값이 있으면 초과 된 값은 버립니다. 필요한 것보다 적은 값이 있으면 목록은 필요한만큼 &lt;b&gt;nil&lt;/b&gt; 로 확장됩니다 . 표현식 목록이 함수 호출로 끝나는 경우 해당 호출에서 반환 된 모든 값은 조정 전에 값 목록을 입력합니다 (호가 괄호로 묶인 경우 제외; &lt;a href=&quot;#3.4&quot;&gt;&amp;sect;3.4&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="746907c57e653b279bf39358594d492bc0bfe3b2" translate="yes" xml:space="preserve">
          <source>Before the first assignment to a variable, its value is &lt;b&gt;nil&lt;/b&gt;.</source>
          <target state="translated">변수에 처음으로 할당하기 전에 값은 &lt;b&gt;nil&lt;/b&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="787ed290e954603b60a8b2b5f8c704754b79f560" translate="yes" xml:space="preserve">
          <source>Besides the Lua state, the continuation function has two other parameters: the final status of the call and the context value (&lt;code&gt;ctx&lt;/code&gt;) that was passed originally to &lt;a href=&quot;#lua_pcallk&quot;&gt;&lt;code&gt;lua_pcallk&lt;/code&gt;&lt;/a&gt;. Lua does not use this context value; it only passes this value from the original function to the continuation function. For &lt;a href=&quot;#lua_pcallk&quot;&gt;&lt;code&gt;lua_pcallk&lt;/code&gt;&lt;/a&gt;, the status is the same value that would be returned by &lt;a href=&quot;#lua_pcallk&quot;&gt;&lt;code&gt;lua_pcallk&lt;/code&gt;&lt;/a&gt;, except that it is &lt;a href=&quot;#pdf-LUA_YIELD&quot;&gt;&lt;code&gt;LUA_YIELD&lt;/code&gt;&lt;/a&gt; when being executed after a yield (instead of &lt;a href=&quot;#pdf-LUA_OK&quot;&gt;&lt;code&gt;LUA_OK&lt;/code&gt;&lt;/a&gt;). For &lt;a href=&quot;#lua_yieldk&quot;&gt;&lt;code&gt;lua_yieldk&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#lua_callk&quot;&gt;&lt;code&gt;lua_callk&lt;/code&gt;&lt;/a&gt;, the status is always &lt;a href=&quot;#pdf-LUA_YIELD&quot;&gt;&lt;code&gt;LUA_YIELD&lt;/code&gt;&lt;/a&gt; when Lua calls the continuation. (For these two functions, Lua will not call the continuation in case of errors, because they do not handle errors.) Similarly, when using &lt;a href=&quot;#lua_callk&quot;&gt;&lt;code&gt;lua_callk&lt;/code&gt;&lt;/a&gt;, you should call the continuation function with &lt;a href=&quot;#pdf-LUA_OK&quot;&gt;&lt;code&gt;LUA_OK&lt;/code&gt;&lt;/a&gt; as the status. (For &lt;a href=&quot;#lua_yieldk&quot;&gt;&lt;code&gt;lua_yieldk&lt;/code&gt;&lt;/a&gt;, there is not much point in calling directly the continuation function, because &lt;a href=&quot;#lua_yieldk&quot;&gt;&lt;code&gt;lua_yieldk&lt;/code&gt;&lt;/a&gt; usually does not return.)</source>
          <target state="translated">Lua 상태 외에도 연속 함수에는 호출의 최종 상태와 원래 &lt;a href=&quot;#lua_pcallk&quot;&gt; &lt;code&gt;lua_pcallk&lt;/code&gt; &lt;/a&gt; 에 전달 된 컨텍스트 값 ( &lt;code&gt;ctx&lt;/code&gt; )의 두 가지 다른 매개 변수 가 있습니다. Lua는이 컨텍스트 값을 사용하지 않습니다. 원래 함수에서 계속 함수로이 값만 전달합니다. 들면 &lt;a href=&quot;#lua_pcallk&quot;&gt; &lt;code&gt;lua_pcallk&lt;/code&gt; &lt;/a&gt; 상태에 의해 반환되는 값과 동일 &lt;a href=&quot;#lua_pcallk&quot;&gt; &lt;code&gt;lua_pcallk&lt;/code&gt; 는&lt;/a&gt; 그것이 것을 제외 &lt;a href=&quot;#pdf-LUA_YIELD&quot;&gt; &lt;code&gt;LUA_YIELD&lt;/code&gt; &lt;/a&gt; (대신 수율 후에 실행될 때 &lt;a href=&quot;#pdf-LUA_OK&quot;&gt; &lt;code&gt;LUA_OK&lt;/code&gt; &lt;/a&gt; ). 들어 &lt;a href=&quot;#lua_yieldk&quot;&gt; &lt;code&gt;lua_yieldk&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#lua_callk&quot;&gt; &lt;code&gt;lua_callk&lt;/code&gt; &lt;/a&gt; 상태는 항상 &lt;a href=&quot;#pdf-LUA_YIELD&quot;&gt; &lt;code&gt;LUA_YIELD&lt;/code&gt; &lt;/a&gt;루아가 계속을 부를 때. (이 두 함수의 경우 Lua는 오류를 처리하지 않으므로 오류 발생시 연속을 호출하지 않습니다.) 마찬가지로 &lt;a href=&quot;#lua_callk&quot;&gt; &lt;code&gt;lua_callk&lt;/code&gt; 를&lt;/a&gt; 사용할 때 &lt;a href=&quot;#pdf-LUA_OK&quot;&gt; &lt;code&gt;LUA_OK&lt;/code&gt; &lt;/a&gt; 를 상태로 사용하여 연속 함수를 호출해야 합니다. ( &lt;a href=&quot;#lua_yieldk&quot;&gt; &lt;code&gt;lua_yieldk&lt;/code&gt; 의 경우&lt;/a&gt; , &lt;a href=&quot;#lua_yieldk&quot;&gt; &lt;code&gt;lua_yieldk&lt;/code&gt; 는&lt;/a&gt; 일반적으로 반환하지 않기 때문에 연속 함수를 직접 호출하는 데 별 의미 가 없습니다.)</target>
        </trans-unit>
        <trans-unit id="eceec5af294d53441f5ac4ad61816149f7f14e22" translate="yes" xml:space="preserve">
          <source>Besides the Lua state, the continuation function has two other parameters: the final status of the call plus the context value (&lt;code&gt;ctx&lt;/code&gt;) that was passed originally to &lt;a href=&quot;#lua_pcallk&quot;&gt;&lt;code&gt;lua_pcallk&lt;/code&gt;&lt;/a&gt;. (Lua does not use this context value; it only passes this value from the original function to the continuation function.) For &lt;a href=&quot;#lua_pcallk&quot;&gt;&lt;code&gt;lua_pcallk&lt;/code&gt;&lt;/a&gt;, the status is the same value that would be returned by &lt;a href=&quot;#lua_pcallk&quot;&gt;&lt;code&gt;lua_pcallk&lt;/code&gt;&lt;/a&gt;, except that it is &lt;a href=&quot;#pdf-LUA_YIELD&quot;&gt;&lt;code&gt;LUA_YIELD&lt;/code&gt;&lt;/a&gt; when being executed after a yield (instead of &lt;a href=&quot;#pdf-LUA_OK&quot;&gt;&lt;code&gt;LUA_OK&lt;/code&gt;&lt;/a&gt;). For &lt;a href=&quot;#lua_yieldk&quot;&gt;&lt;code&gt;lua_yieldk&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#lua_callk&quot;&gt;&lt;code&gt;lua_callk&lt;/code&gt;&lt;/a&gt;, the status is always &lt;a href=&quot;#pdf-LUA_YIELD&quot;&gt;&lt;code&gt;LUA_YIELD&lt;/code&gt;&lt;/a&gt; when Lua calls the continuation. (For these two functions, Lua will not call the continuation in case of errors, because they do not handle errors.) Similarly, when using &lt;a href=&quot;#lua_callk&quot;&gt;&lt;code&gt;lua_callk&lt;/code&gt;&lt;/a&gt;, you should call the continuation function with &lt;a href=&quot;#pdf-LUA_OK&quot;&gt;&lt;code&gt;LUA_OK&lt;/code&gt;&lt;/a&gt; as the status. (For &lt;a href=&quot;#lua_yieldk&quot;&gt;&lt;code&gt;lua_yieldk&lt;/code&gt;&lt;/a&gt;, there is not much point in calling directly the continuation function, because &lt;a href=&quot;#lua_yieldk&quot;&gt;&lt;code&gt;lua_yieldk&lt;/code&gt;&lt;/a&gt; usually does not return.)</source>
          <target state="translated">Lua 상태 외에도 연속 함수에는 두 가지 다른 매개 변수가 있습니다. 호출의 최종 상태와 원래 &lt;a href=&quot;#lua_pcallk&quot;&gt; &lt;code&gt;lua_pcallk&lt;/code&gt; &lt;/a&gt; 로 전달 된 컨텍스트 값 ( &lt;code&gt;ctx&lt;/code&gt; ) . (Lua는이 컨텍스트 값을 사용하지 않습니다.이 값은 원래 함수에서 연속 함수로만 전달됩니다.) &lt;a href=&quot;#lua_pcallk&quot;&gt; &lt;code&gt;lua_pcallk&lt;/code&gt; 의&lt;/a&gt; 경우, 상태는 &lt;a href=&quot;#lua_pcallk&quot;&gt; &lt;code&gt;lua_pcallk&lt;/code&gt; &lt;/a&gt; 에 의해 리턴되는 값과 동일합니다. 단,이 값 은 &lt;a href=&quot;#pdf-LUA_YIELD&quot;&gt; &lt;code&gt;LUA_YIELD&lt;/code&gt; 입니다&lt;/a&gt; . &lt;a href=&quot;#pdf-LUA_OK&quot;&gt; &lt;code&gt;LUA_OK&lt;/code&gt; &lt;/a&gt; 대신 수율 . 들어 &lt;a href=&quot;#lua_yieldk&quot;&gt; &lt;code&gt;lua_yieldk&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#lua_callk&quot;&gt; &lt;code&gt;lua_callk&lt;/code&gt; &lt;/a&gt; 상태는 항상 &lt;a href=&quot;#pdf-LUA_YIELD&quot;&gt; &lt;code&gt;LUA_YIELD&lt;/code&gt; &lt;/a&gt;루아가 연속을 부를 때. (그들은 오류를 처리하지 않기 때문에이 두 기능의 경우, 루아, 오류의 경우에는 계속 전화를하지 않습니다.) 사용하는 경우 마찬가지로, &lt;a href=&quot;#lua_callk&quot;&gt; &lt;code&gt;lua_callk&lt;/code&gt; 을&lt;/a&gt; , 당신과 함께 연속 함수를 호출해야 &lt;a href=&quot;#pdf-LUA_OK&quot;&gt; &lt;code&gt;LUA_OK&lt;/code&gt; &lt;/a&gt; 상태로. ( &lt;a href=&quot;#lua_yieldk&quot;&gt; &lt;code&gt;lua_yieldk&lt;/code&gt; 의 경우&lt;/a&gt; , 일반적으로 &lt;a href=&quot;#lua_yieldk&quot;&gt; &lt;code&gt;lua_yieldk&lt;/code&gt; &lt;/a&gt; 가 반환되지 않기 때문에 연속 함수를 직접 호출 할 필요가 없습니다.)</target>
        </trans-unit>
        <trans-unit id="178d0c1a22b01e10ab0fe06b4a5afb972b2a24e2" translate="yes" xml:space="preserve">
          <source>Binary operators comprise arithmetic operators (see &lt;a href=&quot;#3.4.1&quot;&gt;&amp;sect;3.4.1&lt;/a&gt;), bitwise operators (see &lt;a href=&quot;#3.4.2&quot;&gt;&amp;sect;3.4.2&lt;/a&gt;), relational operators (see &lt;a href=&quot;#3.4.4&quot;&gt;&amp;sect;3.4.4&lt;/a&gt;), logical operators (see &lt;a href=&quot;#3.4.5&quot;&gt;&amp;sect;3.4.5&lt;/a&gt;), and the concatenation operator (see &lt;a href=&quot;#3.4.6&quot;&gt;&amp;sect;3.4.6&lt;/a&gt;). Unary operators comprise the unary minus (see &lt;a href=&quot;#3.4.1&quot;&gt;&amp;sect;3.4.1&lt;/a&gt;), the unary bitwise NOT (see &lt;a href=&quot;#3.4.2&quot;&gt;&amp;sect;3.4.2&lt;/a&gt;), the unary logical &lt;b&gt;not&lt;/b&gt; (see &lt;a href=&quot;#3.4.5&quot;&gt;&amp;sect;3.4.5&lt;/a&gt;), and the unary &lt;em&gt;length operator&lt;/em&gt; (see &lt;a href=&quot;#3.4.7&quot;&gt;&amp;sect;3.4.7&lt;/a&gt;).</source>
          <target state="translated">이항 연산자는 산술 연산자 ( &lt;a href=&quot;#3.4.1&quot;&gt;&amp;sect;3.4.1&lt;/a&gt; 참조 ), 비트 연산자 ( &lt;a href=&quot;#3.4.2&quot;&gt;&amp;sect;3.4.2&lt;/a&gt; 참조 ), 관계 연산자 ( &lt;a href=&quot;#3.4.4&quot;&gt;&amp;sect;3.4.4&lt;/a&gt; 참조 ), 논리 연산자 ( &lt;a href=&quot;#3.4.5&quot;&gt;&amp;sect;3.4.5&lt;/a&gt; 참조 ) 및 연결 연산자 ( &lt;a href=&quot;#3.4.6&quot;&gt;&amp;sect;&lt;/a&gt; 참조)로 구성됩니다. 3.4.6 ). 단항 연산자 (참조 단항를 포함 &lt;a href=&quot;#3.4.1&quot;&gt;&amp;sect;3.4.1&lt;/a&gt; ) 단항 비트 NOT (참조 &lt;a href=&quot;#3.4.2&quot;&gt;&amp;sect;3.4.2&lt;/a&gt; ), 논리 단항 &lt;b&gt;없다&lt;/b&gt; (참조 : &lt;a href=&quot;#3.4.5&quot;&gt;&amp;sect;3.4.5&lt;/a&gt; ) 및 단항 &lt;em&gt;길이 연산자&lt;/em&gt; (참조 &lt;a href=&quot;#3.4.7&quot;&gt;&amp;sect;3.4.7&lt;/a&gt; ) .</target>
        </trans-unit>
        <trans-unit id="f06f824cef5caab026aebdaccc85d665d4b620db" translate="yes" xml:space="preserve">
          <source>Bitwise Operators</source>
          <target state="translated">비트 연산자</target>
        </trans-unit>
        <trans-unit id="54c45c033f5eb914fae27a646cbd9e23d3750d19" translate="yes" xml:space="preserve">
          <source>Blocks</source>
          <target state="translated">Blocks</target>
        </trans-unit>
        <trans-unit id="b864e3b0c9b0957e85741aadf6674e44cf5c2496" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;nargs&lt;/code&gt; and &lt;code&gt;nresults&lt;/code&gt; have the same meaning as in &lt;a href=&quot;#lua_call&quot;&gt;&lt;code&gt;lua_call&lt;/code&gt;&lt;/a&gt;. If there are no errors during the call, &lt;a href=&quot;#lua_pcall&quot;&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt; behaves exactly like &lt;a href=&quot;#lua_call&quot;&gt;&lt;code&gt;lua_call&lt;/code&gt;&lt;/a&gt;. However, if there is any error, &lt;a href=&quot;#lua_pcall&quot;&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt; catches it, pushes a single value on the stack (the error object), and returns an error code. Like &lt;a href=&quot;#lua_call&quot;&gt;&lt;code&gt;lua_call&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#lua_pcall&quot;&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt; always removes the function and its arguments from the stack.</source>
          <target state="translated">두 &lt;code&gt;nargs&lt;/code&gt; 와 &lt;code&gt;nresults&lt;/code&gt; 는 에서와 동일한 의미를 갖는다 &lt;a href=&quot;#lua_call&quot;&gt; &lt;code&gt;lua_call&lt;/code&gt; &lt;/a&gt; . 호출 중에 오류가 없으면 &lt;a href=&quot;#lua_pcall&quot;&gt; &lt;code&gt;lua_pcall&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;#lua_call&quot;&gt; &lt;code&gt;lua_call&lt;/code&gt; &lt;/a&gt; 과 똑같이 동작합니다 . 그러나 오류가 있으면 &lt;a href=&quot;#lua_pcall&quot;&gt; &lt;code&gt;lua_pcall&lt;/code&gt; 이&lt;/a&gt; 오류를 잡아 스택 (오류 객체)에 단일 값을 푸시 한 다음 오류 코드를 반환합니다. 마찬가지로 &lt;a href=&quot;#lua_call&quot;&gt; &lt;code&gt;lua_call&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#lua_pcall&quot;&gt; &lt;code&gt;lua_pcall&lt;/code&gt; &lt;/a&gt; 항상 기능과 스택에서 인수를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="749baad9cb11596eefaae710a32b14bec750ce16" translate="yes" xml:space="preserve">
          <source>Both function calls and assignments can start with an open parenthesis. This possibility leads to an ambiguity in Lua's grammar. Consider the following fragment:</source>
          <target state="translated">함수 호출과 할당은 모두 여는 괄호로 시작할 수 있습니다. 이 가능성은 Lua의 문법에 모호함을 가져옵니다. 다음 조각을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="3328c9c8f16b59988d2720e58557b3f6a8cdbbb5" translate="yes" xml:space="preserve">
          <source>Both function calls and vararg expressions can result in multiple values. If a function call is used as a statement (see &lt;a href=&quot;#3.3.6&quot;&gt;&amp;sect;3.3.6&lt;/a&gt;), then its return list is adjusted to zero elements, thus discarding all returned values. If an expression is used as the last (or the only) element of a list of expressions, then no adjustment is made (unless the expression is enclosed in parentheses). In all other contexts, Lua adjusts the result list to one element, either discarding all values except the first one or adding a single &lt;b&gt;nil&lt;/b&gt; if there are no values.</source>
          <target state="translated">함수 호출과 vararg 표현식 모두 여러 값을 초래할 수 있습니다. 함수 호출이 명령문으로 사용되면 ( &lt;a href=&quot;#3.3.6&quot;&gt;&amp;sect;3.3.6&lt;/a&gt; 참조 ) 리턴 목록이 0 요소로 조정되므로 모든 리턴 값이 삭제됩니다. 표현식이 표현식 목록의 마지막 (또는 유일한) 요소로 사용되는 경우 표현식이 괄호로 묶여 있지 않은 한 조정되지 않습니다. 다른 모든 상황에서 Lua는 결과 목록을 하나의 요소로 조정하여 첫 번째 요소를 제외한 모든 값을 삭제하거나 값이없는 경우 단일 &lt;b&gt;nil을&lt;/b&gt; 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="ef0d7df25b511d8e1f840431681fc99b96959ea0" translate="yes" xml:space="preserve">
          <source>Both right and left shifts fill the vacant bits with zeros. Negative displacements shift to the other direction; displacements with absolute values equal to or higher than the number of bits in an integer result in zero (as all bits are shifted out).</source>
          <target state="translated">오른쪽 및 왼쪽 시프트는 빈 비트를 0으로 채 웁니다. 음의 변위는 다른 방향으로 이동합니다. 정수의 비트 수 이상의 절대 값을 가진 변위는 0이됩니다 (모든 비트가 시프트 됨).</target>
        </trans-unit>
        <trans-unit id="da6f79f89e4655f35de3f93f152ce488dacf9aed" translate="yes" xml:space="preserve">
          <source>By convention, a one-piece message starting with '&lt;code&gt;@&lt;/code&gt;' is intended to be a &lt;em&gt;control message&lt;/em&gt;, which is a message to the warning system itself. In particular, the standard warning function in Lua recognizes the control messages &quot;&lt;code&gt;@off&lt;/code&gt;&quot;, to stop the emission of warnings, and &quot;&lt;code&gt;@on&lt;/code&gt;&quot;, to (re)start the emission; it ignores unknown control messages.</source>
          <target state="translated">관례 상 ' &lt;code&gt;@&lt;/code&gt; '로 시작하는 일체형 메시지 는 경고 시스템 자체에 대한 메시지 인 &lt;em&gt;제어 메시지&lt;/em&gt; 가됩니다. 특히 루아 표준 경고 기능은 제어 메시지 &quot;인식 &lt;code&gt;@off&lt;/code&gt; &quot;중지 경고의 발광 및 &quot; &lt;code&gt;@on&lt;/code&gt; (재)가 발광을 시작하는&quot;을; 알 수없는 제어 메시지를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="606a21a2a41de7578fb85238576a85c01cff0d09" translate="yes" xml:space="preserve">
          <source>By default this type is &lt;code&gt;long long&lt;/code&gt;, (usually a 64-bit two-complement integer), but that can be changed to &lt;code&gt;long&lt;/code&gt; or &lt;code&gt;int&lt;/code&gt; (usually a 32-bit two-complement integer). (See &lt;code&gt;LUA_INT_TYPE&lt;/code&gt; in &lt;code&gt;luaconf.h&lt;/code&gt;.)</source>
          <target state="translated">기본적으로이 유형은 &lt;code&gt;long long&lt;/code&gt; (보통 64 비트 2 보수 정수)이지만 &lt;code&gt;long&lt;/code&gt; 또는 &lt;code&gt;int&lt;/code&gt; (보통 32 비트 2 보수 정수) 로 변경할 수 있습니다 . &lt;code&gt;LUA_INT_TYPE&lt;/code&gt; 의 &lt;code&gt;luaconf.h&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8d4b756a61274079d48c6b43e4f7a164ad5525c5" translate="yes" xml:space="preserve">
          <source>By default this type is double, but that can be changed to a single float or a long double. (See &lt;code&gt;LUA_FLOAT_TYPE&lt;/code&gt; in &lt;code&gt;luaconf.h&lt;/code&gt;.)</source>
          <target state="translated">기본적으로이 유형은 double이지만 단일 float 또는 long double로 변경할 수 있습니다. &lt;code&gt;LUA_FLOAT_TYPE&lt;/code&gt; 의 &lt;code&gt;luaconf.h&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="29af92c8be46565be89222f77a2f4fb50aaf902e" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;i&lt;/code&gt; is 1 and &lt;code&gt;j&lt;/code&gt; is &lt;code&gt;#list&lt;/code&gt;.</source>
          <target state="translated">기본적으로 &lt;code&gt;i&lt;/code&gt; 는 1이고 &lt;code&gt;j&lt;/code&gt; 는 &lt;code&gt;#list&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0faf3672da025664de4e899fe4c851e162d72458" translate="yes" xml:space="preserve">
          <source>By default, the decoding functions in the &lt;a href=&quot;#pdf-utf8&quot;&gt;&lt;code&gt;utf8&lt;/code&gt;&lt;/a&gt; library do not accept surrogates as valid code points. An extra parameter in these functions makes them more permissive.</source>
          <target state="translated">기본적으로 &lt;a href=&quot;#pdf-utf8&quot;&gt; &lt;code&gt;utf8&lt;/code&gt; &lt;/a&gt; 라이브러리 의 디코딩 함수는 서로 게이트를 유효한 코드 포인트로 허용하지 않습니다. 이러한 함수의 추가 매개 변수는 더 관대하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="4b94595a9de392a583ea21fcbca5ff4996bbeb4c" translate="yes" xml:space="preserve">
          <source>By default, this area has the size of a pointer to void, but you can recompile Lua with a different size for this area. (See &lt;code&gt;LUA_EXTRASPACE&lt;/code&gt; in &lt;code&gt;luaconf.h&lt;/code&gt;.)</source>
          <target state="translated">기본적으로이 영역에는 void에 대한 포인터 크기가 있지만이 영역에 대해 다른 크기로 Lua를 다시 컴파일 할 수 있습니다. &lt;code&gt;LUA_EXTRASPACE&lt;/code&gt; 의 &lt;code&gt;luaconf.h&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="03114feec4c78056b8ef7cfc58a14ecddceef3d8" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;#pdf-error&quot;&gt;&lt;code&gt;error&lt;/code&gt;&lt;/a&gt; if the value of its argument &lt;code&gt;v&lt;/code&gt; is false (i.e., &lt;b&gt;nil&lt;/b&gt; or &lt;b&gt;false&lt;/b&gt;); otherwise, returns all its arguments. In case of error, &lt;code&gt;message&lt;/code&gt; is the error object; when absent, it defaults to &quot;&lt;code&gt;assertion failed!&lt;/code&gt;&quot;</source>
          <target state="translated">인수 &lt;code&gt;v&lt;/code&gt; 의 값 이 false (예 : &lt;b&gt;nil&lt;/b&gt; 또는 &lt;b&gt;false&lt;/b&gt; ) 이면 &lt;a href=&quot;#pdf-error&quot;&gt; &lt;code&gt;error&lt;/code&gt; 를&lt;/a&gt; 호출 합니다 . 그렇지 않으면 모든 인수를 반환합니다. 오류가 발생하면 &lt;code&gt;message&lt;/code&gt; 는 오류 개체입니다. 부재시 기본값은 &quot; &lt;code&gt;assertion failed!&lt;/code&gt; &quot;입니다.&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7dd7336a942c0830e724f83d659a39ec8e4cedbd" translate="yes" xml:space="preserve">
          <source>Calls a function (or a callable object) in protected mode.</source>
          <target state="translated">보호 모드에서 함수 (또는 호출 가능한 개체)를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="1c9a6f6c22d821f1d190cf7b504945ad9b4cbdf3" translate="yes" xml:space="preserve">
          <source>Calls a function in protected mode.</source>
          <target state="translated">보호 모드에서 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="b098c5a2357f0f1bcda94addf0cd58b14d7f56d4" translate="yes" xml:space="preserve">
          <source>Calls a function.</source>
          <target state="translated">함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="de41e844283c868632ab60b6dc9990f6e31b48dc" translate="yes" xml:space="preserve">
          <source>Calls a function. Like regular Lua calls, &lt;code&gt;lua_call&lt;/code&gt; respects the &lt;code&gt;__call&lt;/code&gt; metamethod. So, here the word &quot;function&quot; means any callable value.</source>
          <target state="translated">함수를 호출합니다. 일반 Lua 호출과 마찬가지로 &lt;code&gt;lua_call&lt;/code&gt; 은 &lt;code&gt;__call&lt;/code&gt; 메타 메소드를 존중합니다 . 따라서 여기서 &quot;함수&quot;라는 단어는 호출 가능한 값을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="a92585404dfb5c102735b49e368c931de0bcf925" translate="yes" xml:space="preserve">
          <source>Calls a metamethod.</source>
          <target state="translated">메타 메소드를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="afb856a058891b728039960270f34dcfa7886cb5" translate="yes" xml:space="preserve">
          <source>Calls function &lt;code&gt;f&lt;/code&gt; with the given arguments in &lt;em&gt;protected mode&lt;/em&gt;. This means that any error inside &lt;code&gt;f&lt;/code&gt; is not propagated; instead, &lt;code&gt;pcall&lt;/code&gt; catches the error and returns a status code. Its first result is the status code (a boolean), which is true if the call succeeds without errors. In such case, &lt;code&gt;pcall&lt;/code&gt; also returns all results from the call, after this first result. In case of any error, &lt;code&gt;pcall&lt;/code&gt; returns &lt;b&gt;false&lt;/b&gt; plus the error message.</source>
          <target state="translated">&lt;em&gt;보호 모드&lt;/em&gt; 에서 지정된 인수로 함수 &lt;code&gt;f&lt;/code&gt; 를 호출 &lt;em&gt;합니다&lt;/em&gt; . 이는 &lt;code&gt;f&lt;/code&gt; 내부의 오류 가 전파되지 않음을 의미합니다 . 대신 &lt;code&gt;pcall&lt;/code&gt; 은 오류를 포착하고 상태 코드를 반환합니다. 첫 번째 결과는 상태 코드 (부울)이며, 오류없이 호출이 성공하면 참입니다. 이 경우 &lt;code&gt;pcall&lt;/code&gt; 은이 첫 번째 결과 이후 호출의 모든 결과도 반환합니다. 오류가 발생하면 &lt;code&gt;pcall&lt;/code&gt; 은 오류 메시지와 함께 &lt;b&gt;false를&lt;/b&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="d13e849aa5160d3c27d99ea69deec271ee71dd22" translate="yes" xml:space="preserve">
          <source>Calls the ISO C function &lt;code&gt;exit&lt;/code&gt; to terminate the host program. If &lt;code&gt;code&lt;/code&gt; is &lt;b&gt;true&lt;/b&gt;, the returned status is &lt;code&gt;EXIT_SUCCESS&lt;/code&gt;; if &lt;code&gt;code&lt;/code&gt; is &lt;b&gt;false&lt;/b&gt;, the returned status is &lt;code&gt;EXIT_FAILURE&lt;/code&gt;; if &lt;code&gt;code&lt;/code&gt; is a number, the returned status is this number. The default value for &lt;code&gt;code&lt;/code&gt; is &lt;b&gt;true&lt;/b&gt;.</source>
          <target state="translated">호스트 프로그램을 종료하기 위해 ISO C 기능 &lt;code&gt;exit&lt;/code&gt; 를 호출합니다 . 경우 &lt;code&gt;code&lt;/code&gt; 입니다 &lt;b&gt;사실&lt;/b&gt; , 반환 된 상태는 &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; ; 경우 &lt;code&gt;code&lt;/code&gt; 입니다 &lt;b&gt;거짓&lt;/b&gt; , 반환 된 상태는 &lt;code&gt;EXIT_FAILURE&lt;/code&gt; ; 경우에 &lt;code&gt;code&lt;/code&gt; 번호가 반환 된 상태는이 숫자입니다. &lt;code&gt;code&lt;/code&gt; 의 기본값 은 &lt;b&gt;true&lt;/b&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e92d3f3f9465503d00e813dd953f01a23f54c8bf" translate="yes" xml:space="preserve">
          <source>Calls the function &lt;code&gt;f&lt;/code&gt; with the given arguments in &lt;em&gt;protected mode&lt;/em&gt;. This means that any error inside &lt;code&gt;f&lt;/code&gt; is not propagated; instead, &lt;code&gt;pcall&lt;/code&gt; catches the error and returns a status code. Its first result is the status code (a boolean), which is true if the call succeeds without errors. In such case, &lt;code&gt;pcall&lt;/code&gt; also returns all results from the call, after this first result. In case of any error, &lt;code&gt;pcall&lt;/code&gt; returns &lt;b&gt;false&lt;/b&gt; plus the error object. Note that errors caught by &lt;code&gt;pcall&lt;/code&gt; do not call a message handler.</source>
          <target state="translated">&lt;em&gt;보호 모드&lt;/em&gt; 에서 지정된 인수를 사용 하여 함수 &lt;code&gt;f&lt;/code&gt; 를 호출 &lt;em&gt;합니다&lt;/em&gt; . 이는 &lt;code&gt;f&lt;/code&gt; 내부의 오류 가 전파되지 않음을 의미합니다 . 대신 &lt;code&gt;pcall&lt;/code&gt; 은 오류를 포착하고 상태 코드를 반환합니다. 첫 번째 결과는 상태 코드 (부울)이며 호출이 오류없이 성공하면 참입니다. 이 경우 &lt;code&gt;pcall&lt;/code&gt; 은이 첫 번째 결과 이후 호출의 모든 결과도 반환합니다. 오류가있는 경우 &lt;code&gt;pcall&lt;/code&gt; 은 오류 개체와 함께 &lt;b&gt;false를&lt;/b&gt; 반환 합니다. &lt;code&gt;pcall&lt;/code&gt; 에 의해 포착 된 오류 는 메시지 핸들러를 호출하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ce944ae1c348eb980d3cfe553b3502d5679075a6" translate="yes" xml:space="preserve">
          <source>Captures:</source>
          <target state="translated">Captures:</target>
        </trans-unit>
        <trans-unit id="07ae3990eabe4f174acb75467a4a336ef037a4a0" translate="yes" xml:space="preserve">
          <source>Changes the allocator function of a given state to &lt;code&gt;f&lt;/code&gt; with user data &lt;code&gt;ud&lt;/code&gt;.</source>
          <target state="translated">사용자 데이터 &lt;code&gt;ud&lt;/code&gt; 를 사용 하여 지정된 상태의 할당 자 함수를 &lt;code&gt;f&lt;/code&gt; 로 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="6e6cb5ea0746fe0ad7fa97751f92f6157ed314b2" translate="yes" xml:space="preserve">
          <source>Character Class:</source>
          <target state="translated">캐릭터 클래스 :</target>
        </trans-unit>
        <trans-unit id="c7770ae0113235aa718b727fe472f222898a4cd8" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;cond&lt;/code&gt; is true. If it is not, raises an error about the type of the argument &lt;code&gt;arg&lt;/code&gt; with a standard message (see &lt;a href=&quot;#luaL_typeerror&quot;&gt;&lt;code&gt;luaL_typeerror&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;cond&lt;/code&gt; 가 참 인지 확인합니다 . 그렇지 않은 경우 표준 메시지와 함께 인수 &lt;code&gt;arg&lt;/code&gt; 의 유형에 대한 오류를 발생 &lt;a href=&quot;#luaL_typeerror&quot;&gt; &lt;code&gt;luaL_typeerror&lt;/code&gt; &lt;/a&gt; ( luaL_typeerror 참조 ).</target>
        </trans-unit>
        <trans-unit id="0a2e61548b9d88afb89262b803b6de8bd1e2b486" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;cond&lt;/code&gt; is true. If it is not, raises an error with a standard message (see &lt;a href=&quot;#luaL_argerror&quot;&gt;&lt;code&gt;luaL_argerror&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;cond&lt;/code&gt; 가 true 인지 확인합니다 . 그렇지 않은 경우 표준 메시지와 함께 오류가 발생합니다 ( &lt;a href=&quot;#luaL_argerror&quot;&gt; &lt;code&gt;luaL_argerror&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="c8de5cdad4b6448665c01e91b06f6e30f6937a4c" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;obj&lt;/code&gt; is a valid file handle. Returns the string &lt;code&gt;&quot;file&quot;&lt;/code&gt; if &lt;code&gt;obj&lt;/code&gt; is an open file handle, &lt;code&gt;&quot;closed file&quot;&lt;/code&gt; if &lt;code&gt;obj&lt;/code&gt; is a closed file handle, or &lt;b&gt;fail&lt;/b&gt; if &lt;code&gt;obj&lt;/code&gt; is not a file handle.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; 가 유효한 파일 핸들 인지 확인합니다 . 반환 문자열 &lt;code&gt;&quot;file&quot;&lt;/code&gt; 경우 &lt;code&gt;obj&lt;/code&gt; 가 열린 파일 핸들입니다 &lt;code&gt;&quot;closed file&quot;&lt;/code&gt; 경우 &lt;code&gt;obj&lt;/code&gt; 가 닫힌 파일 핸들, 또는 &lt;b&gt;실패 할&lt;/b&gt; 경우 &lt;code&gt;obj&lt;/code&gt; 가 파일 핸들이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e06a04dbdce44628706ea99a276e73819504d5ac" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;obj&lt;/code&gt; is a valid file handle. Returns the string &lt;code&gt;&quot;file&quot;&lt;/code&gt; if &lt;code&gt;obj&lt;/code&gt; is an open file handle, &lt;code&gt;&quot;closed file&quot;&lt;/code&gt; if &lt;code&gt;obj&lt;/code&gt; is a closed file handle, or &lt;b&gt;nil&lt;/b&gt; if &lt;code&gt;obj&lt;/code&gt; is not a file handle.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; 가 유효한 파일 핸들 인지 확인합니다 . 반환 문자열 &lt;code&gt;&quot;file&quot;&lt;/code&gt; 경우 &lt;code&gt;obj&lt;/code&gt; 가 열린 파일 핸들은, &lt;code&gt;&quot;closed file&quot;&lt;/code&gt; 경우 &lt;code&gt;obj&lt;/code&gt; 가 닫힌 파일 핸들, 또는이다 &lt;b&gt;전무&lt;/b&gt; 경우 &lt;code&gt;obj&lt;/code&gt; 가 파일 핸들이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="c496e326cea24bf25262cd1109c5d86ac743d694" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;v1&lt;/code&gt; is equal to &lt;code&gt;v2&lt;/code&gt;, without invoking the &lt;code&gt;__eq&lt;/code&gt; metamethod. Returns a boolean.</source>
          <target state="translated">&lt;code&gt;__eq&lt;/code&gt; 메타 메소드 를 호출하지 않고 &lt;code&gt;v1&lt;/code&gt; 이 &lt;code&gt;v2&lt;/code&gt; 와 같은지 확인합니다 . 부울을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e7a1a2b67c524de176bf4a3fb93211ffc3fb80e2" translate="yes" xml:space="preserve">
          <source>Checks whether the code making the call and the Lua library being called are using the same version of Lua and the same numeric types.</source>
          <target state="translated">호출하는 코드와 호출되는 Lua 라이브러리가 동일한 버전의 Lua와 동일한 숫자 유형을 사용하고 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="71f0115e5d4ddbb6ea3de5ce5156cd7d330a1e43" translate="yes" xml:space="preserve">
          <source>Checks whether the core running the call, the core that created the Lua state, and the code making the call are all using the same version of Lua. Also checks whether the core running the call and the core that created the Lua state are using the same address space.</source>
          <target state="translated">호출을 실행하는 코어, Lua 상태를 생성 한 코어 및 호출하는 코드가 모두 동일한 버전의 Lua를 사용하는지 확인합니다. 또한 통화를 실행하는 코어와 Lua 상태를 생성 한 코어가 동일한 주소 공간을 사용하고 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="c7e0b23ddda5a7e9cb9a184dd2fb56f91b2baeb4" translate="yes" xml:space="preserve">
          <source>Checks whether the function argument &lt;code&gt;arg&lt;/code&gt; has type &lt;code&gt;t&lt;/code&gt;. See &lt;a href=&quot;#lua_type&quot;&gt;&lt;code&gt;lua_type&lt;/code&gt;&lt;/a&gt; for the encoding of types for &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">함수 인수 &lt;code&gt;arg&lt;/code&gt; 의 유형이 &lt;code&gt;t&lt;/code&gt; 인지 확인합니다 . &lt;code&gt;t&lt;/code&gt; 타입의 인코딩에 대해서는 &lt;a href=&quot;#lua_type&quot;&gt; &lt;code&gt;lua_type&lt;/code&gt; &lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b16eca39d17a0b9497d463be5d8e1222fd6c33fd" translate="yes" xml:space="preserve">
          <source>Checks whether the function argument &lt;code&gt;arg&lt;/code&gt; is a number and returns this number converted to a &lt;code&gt;lua_Number&lt;/code&gt;.</source>
          <target state="translated">함수 인수 &lt;code&gt;arg&lt;/code&gt; 가 숫자 인지 확인 하고이 숫자를 &lt;code&gt;lua_Number&lt;/code&gt; 로 변환하여 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="34efff80aa99092adc3395e3a3c3cec54e5e3ae4" translate="yes" xml:space="preserve">
          <source>Checks whether the function argument &lt;code&gt;arg&lt;/code&gt; is a number and returns this number.</source>
          <target state="translated">함수 인수 &lt;code&gt;arg&lt;/code&gt; 가 숫자 인지 확인 하고이 숫자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="acb38043b3ab1b3ca9ad57148867e32ff48f49a4" translate="yes" xml:space="preserve">
          <source>Checks whether the function argument &lt;code&gt;arg&lt;/code&gt; is a string and returns this string.</source>
          <target state="translated">함수 인수 &lt;code&gt;arg&lt;/code&gt; 가 문자열 인지 확인 하고이 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fd80c52685065a298a4083d4f4ae27709571e837" translate="yes" xml:space="preserve">
          <source>Checks whether the function argument &lt;code&gt;arg&lt;/code&gt; is a string and returns this string; if &lt;code&gt;l&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt; fills &lt;code&gt;*l&lt;/code&gt; with the string's length.</source>
          <target state="translated">함수 인수 &lt;code&gt;arg&lt;/code&gt; 가 문자열 인지 확인 하고이 문자열을 반환합니다. &lt;code&gt;l&lt;/code&gt; 이 &lt;code&gt;NULL&lt;/code&gt; 이 아닌 경우 &lt;code&gt;*l&lt;/code&gt; 을 문자열 길이로 채 웁니다 .</target>
        </trans-unit>
        <trans-unit id="5842d397b39cf79e605ee014fa9f083d17de207a" translate="yes" xml:space="preserve">
          <source>Checks whether the function argument &lt;code&gt;arg&lt;/code&gt; is a string and returns this string; if &lt;code&gt;l&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt; fills its referent with the string's length.</source>
          <target state="translated">함수 인수 &lt;code&gt;arg&lt;/code&gt; 가 문자열 인지 확인 하고이 문자열을 반환합니다. 경우 &lt;code&gt;l&lt;/code&gt; 아닌 &lt;code&gt;NULL&lt;/code&gt; 은 문자열의 길이와 그 지시 대상을 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="6bda7fb8ccffc0321708f10ba7b5f9fa4d8f642f" translate="yes" xml:space="preserve">
          <source>Checks whether the function argument &lt;code&gt;arg&lt;/code&gt; is a string and searches for this string in the array &lt;code&gt;lst&lt;/code&gt; (which must be NULL-terminated). Returns the index in the array where the string was found. Raises an error if the argument is not a string or if the string cannot be found.</source>
          <target state="translated">함수 인수 &lt;code&gt;arg&lt;/code&gt; 가 문자열 인지 확인 하고 배열 &lt;code&gt;lst&lt;/code&gt; 에서이 문자열을 검색 합니다 (NULL로 끝나야 함). 문자열이있는 배열의 색인을 반환합니다. 인수가 문자열이 아니거나 문자열을 찾을 수없는 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bfaae18ec316bac0d06a7d8b2f1269f7452bb73f" translate="yes" xml:space="preserve">
          <source>Checks whether the function argument &lt;code&gt;arg&lt;/code&gt; is a userdata of the type &lt;code&gt;tname&lt;/code&gt; (see &lt;a href=&quot;#luaL_newmetatable&quot;&gt;&lt;code&gt;luaL_newmetatable&lt;/code&gt;&lt;/a&gt;) and returns the userdata address (see &lt;a href=&quot;#lua_touserdata&quot;&gt;&lt;code&gt;lua_touserdata&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">함수 인수 &lt;code&gt;arg&lt;/code&gt; 가 &lt;code&gt;tname&lt;/code&gt; 유형의 사용자 데이터 인지 ( &lt;a href=&quot;#luaL_newmetatable&quot;&gt; &lt;code&gt;luaL_newmetatable&lt;/code&gt; &lt;/a&gt; 참조 ) 여부를 확인 하고 사용자 데이터 주소를 리턴합니다 ( &lt;a href=&quot;#lua_touserdata&quot;&gt; &lt;code&gt;lua_touserdata&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="f674b5558104cb7ee3833fe2715ff7a7d7c623af" translate="yes" xml:space="preserve">
          <source>Checks whether the function argument &lt;code&gt;arg&lt;/code&gt; is a userdata of the type &lt;code&gt;tname&lt;/code&gt; (see &lt;a href=&quot;#luaL_newmetatable&quot;&gt;&lt;code&gt;luaL_newmetatable&lt;/code&gt;&lt;/a&gt;) and returns the userdata's memory-block address (see &lt;a href=&quot;#lua_touserdata&quot;&gt;&lt;code&gt;lua_touserdata&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">함수 인수 &lt;code&gt;arg&lt;/code&gt; 가 &lt;code&gt;tname&lt;/code&gt; 유형의 사용자 데이터 인지 확인하고 ( &lt;a href=&quot;#luaL_newmetatable&quot;&gt; &lt;code&gt;luaL_newmetatable&lt;/code&gt; &lt;/a&gt; 참조 ) 사용자 데이터의 메모리 블록 주소를 반환합니다 ( &lt;a href=&quot;#lua_touserdata&quot;&gt; &lt;code&gt;lua_touserdata&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="21c6e89e09e8362727785a70d17dbd46aac6e5d8" translate="yes" xml:space="preserve">
          <source>Checks whether the function argument &lt;code&gt;arg&lt;/code&gt; is an integer (or can be converted to an integer) and returns this integer cast to a &lt;a href=&quot;#lua_Integer&quot;&gt;&lt;code&gt;lua_Integer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">함수 인수 &lt;code&gt;arg&lt;/code&gt; 가 정수인지 (또는 정수로 변환 할 수 있는지) 확인 하고이 정수 캐스트를 &lt;a href=&quot;#lua_Integer&quot;&gt; &lt;code&gt;lua_Integer&lt;/code&gt; 로&lt;/a&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="783fecf056e15a65f58fa6b7270185e8e643cd1c" translate="yes" xml:space="preserve">
          <source>Checks whether the function argument &lt;code&gt;arg&lt;/code&gt; is an integer (or can be converted to an integer) and returns this integer.</source>
          <target state="translated">함수 인수 &lt;code&gt;arg&lt;/code&gt; 가 정수인지 (또는 정수로 변환 할 수 있는지) 확인 하고이 정수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ec6102b1e83850fda1240175c176c9a4d38d5de9" translate="yes" xml:space="preserve">
          <source>Checks whether the function has an argument of any type (including &lt;b&gt;nil&lt;/b&gt;) at position &lt;code&gt;arg&lt;/code&gt;.</source>
          <target state="translated">함수 &lt;code&gt;arg&lt;/code&gt; 위치에 함수의 유형 ( &lt;b&gt;nil&lt;/b&gt; 포함 ) 이 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="4a527377dfdcd1435bbaa177dc63f2a6bb39b269" translate="yes" xml:space="preserve">
          <source>Chunks</source>
          <target state="translated">Chunks</target>
        </trans-unit>
        <trans-unit id="b103f8207401db3956a89008862d6396af66ca00" translate="yes" xml:space="preserve">
          <source>Chunks can also be precompiled into binary form; see program &lt;code&gt;luac&lt;/code&gt; and function &lt;a href=&quot;#pdf-string.dump&quot;&gt;&lt;code&gt;string.dump&lt;/code&gt;&lt;/a&gt; for details. Programs in source and compiled forms are interchangeable; Lua automatically detects the file type and acts accordingly (see &lt;a href=&quot;#pdf-load&quot;&gt;&lt;code&gt;load&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">청크는 이진 형식으로 사전 컴파일 될 수도 있습니다. 자세한 내용은 프로그램 &lt;code&gt;luac&lt;/code&gt; 및 함수 &lt;a href=&quot;#pdf-string.dump&quot;&gt; &lt;code&gt;string.dump&lt;/code&gt; &lt;/a&gt; 를 참조하십시오. 소스와 컴파일 된 형태의 프로그램은 서로 호환됩니다. Lua는 파일 형식을 자동으로 감지하고 그에 따라 작동합니다 ( &lt;a href=&quot;#pdf-load&quot;&gt; &lt;code&gt;load&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="fd0bb028508d5391ee85c23dff25b23b7541487b" translate="yes" xml:space="preserve">
          <source>Chunks can also be precompiled into binary form; see the program &lt;code&gt;luac&lt;/code&gt; and the function &lt;a href=&quot;#pdf-string.dump&quot;&gt;&lt;code&gt;string.dump&lt;/code&gt;&lt;/a&gt; for details. Programs in source and compiled forms are interchangeable; Lua automatically detects the file type and acts accordingly (see &lt;a href=&quot;#pdf-load&quot;&gt;&lt;code&gt;load&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">청크는 바이너리 형식으로 미리 컴파일 할 수도 있습니다. 자세한 내용은 &lt;code&gt;luac&lt;/code&gt; 프로그램 과 &lt;a href=&quot;#pdf-string.dump&quot;&gt; &lt;code&gt;string.dump&lt;/code&gt; &lt;/a&gt; 함수 를 참조하십시오. 소스 및 컴파일 된 형식의 프로그램은 서로 바꿔 사용할 수 있습니다. Lua는 자동으로 파일 유형을 감지하고 그에 따라 작동합니다 ( &lt;a href=&quot;#pdf-load&quot;&gt; &lt;code&gt;load&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="ab3eaf45d0b3c8a3178b4208172178403c6ec43b" translate="yes" xml:space="preserve">
          <source>Close all active to-be-closed variables in the main thread, release all objects in the given Lua state (calling the corresponding garbage-collection metamethods, if any), and frees all dynamic memory used by this state.</source>
          <target state="translated">주 스레드에서 모든 활성 종료 될 변수를 닫고 지정된 Lua 상태 (해당되는 가비지 수집 메타 메서드 호출)의 모든 개체를 해제하고이 상태에서 사용하는 모든 동적 메모리를 해제합니다.</target>
        </trans-unit>
        <trans-unit id="52566db36dfcd9f2bf9c74284a4bfdd56dc85476" translate="yes" xml:space="preserve">
          <source>Closes &lt;code&gt;file&lt;/code&gt;. Note that files are automatically closed when their handles are garbage collected, but that takes an unpredictable amount of time to happen.</source>
          <target state="translated">&lt;code&gt;file&lt;/code&gt; 닫습니다 . 핸들이 가비지 수집 될 때 파일이 자동으로 닫히지 만 예상치 못한 시간이 걸립니다.</target>
        </trans-unit>
        <trans-unit id="c33ada8169beda98f995719f265c2b9b12d94172" translate="yes" xml:space="preserve">
          <source>Closes coroutine &lt;code&gt;co&lt;/code&gt;, that is, closes all its pending to-be-closed variables and puts the coroutine in a dead state. The given coroutine must be dead or suspended. In case of error closing some variable, returns &lt;b&gt;false&lt;/b&gt; plus the error object; otherwise returns &lt;b&gt;true&lt;/b&gt;.</source>
          <target state="translated">코 루틴 &lt;code&gt;co&lt;/code&gt; 를 닫습니다 . 즉, 보류중인 모든 닫힐 변수를 닫고 코 루틴을 데드 상태에 둡니다. 주어진 코 루틴은 죽거나 일시 중단되어야합니다. 일부 변수를 닫는 동안 오류가 발생하면 &lt;b&gt;false&lt;/b&gt; 와 오류 개체를 반환 합니다. 그렇지 않으면 &lt;b&gt;true를&lt;/b&gt; 반환 &lt;b&gt;합니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="85fc3e790a7e917db028a531acd7642ab374f383" translate="yes" xml:space="preserve">
          <source>Coercions and Conversions</source>
          <target state="translated">강제와 전환</target>
        </trans-unit>
        <trans-unit id="226470405b7e44d61ec64752eddb0da20100aa01" translate="yes" xml:space="preserve">
          <source>Compares two Lua values. Returns 1 if the value at index &lt;code&gt;index1&lt;/code&gt; satisfies &lt;code&gt;op&lt;/code&gt; when compared with the value at index &lt;code&gt;index2&lt;/code&gt;, following the semantics of the corresponding Lua operator (that is, it may call metamethods). Otherwise returns 0. Also returns 0 if any of the indices is not valid.</source>
          <target state="translated">두 개의 Lua 값을 비교합니다. 해당 Lua 연산자의 의미에 따라 인덱스 &lt;code&gt;index1&lt;/code&gt; 의 값과 인덱스 &lt;code&gt;index2&lt;/code&gt; 의 값을 비교할 때 &lt;code&gt;op&lt;/code&gt; 를 만족하는 경우 (즉, 메타 메서드를 호출 할 수 있음) 1을 반환 합니다. 그렇지 않으면 0을 반환합니다. 인덱스가 유효하지 않은 경우 0도 반환합니다.</target>
        </trans-unit>
        <trans-unit id="372bb0dd29dd69cdea95231ec5f25f17cfbc3df5" translate="yes" xml:space="preserve">
          <source>Concatenates the &lt;code&gt;n&lt;/code&gt; values at the top of the stack, pops them, and leaves the result at the top. If &lt;code&gt;n&lt;/code&gt; is 1, the result is the single value on the stack (that is, the function does nothing); if &lt;code&gt;n&lt;/code&gt; is 0, the result is the empty string. Concatenation is performed following the usual semantics of Lua (see &lt;a href=&quot;#3.4.6&quot;&gt;&amp;sect;3.4.6&lt;/a&gt;).</source>
          <target state="translated">스택의 맨 위에 &lt;code&gt;n&lt;/code&gt; 값을 연결하고 팝한 다음 결과를 맨 위에 둡니다. 경우 &lt;code&gt;n&lt;/code&gt; 은 1이고, 그 결과 (즉, 함수는 아무것도하지 않는다) 스택에 하나의 값이고; 경우 &lt;code&gt;n&lt;/code&gt; 은 0, 결과는 빈 문자열입니다. 연결은 Lua의 일반적인 의미에 따라 수행됩니다 ( &lt;a href=&quot;#3.4.6&quot;&gt;&amp;sect;3.4.6&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="f844149a29a3be3af394cb4f1bac67af1c62acdd" translate="yes" xml:space="preserve">
          <source>Concatenates the &lt;code&gt;n&lt;/code&gt; values at the top of the stack, pops them, and leaves the result on the top. If &lt;code&gt;n&lt;/code&gt; is 1, the result is the single value on the stack (that is, the function does nothing); if &lt;code&gt;n&lt;/code&gt; is 0, the result is the empty string. Concatenation is performed following the usual semantics of Lua (see &lt;a href=&quot;#3.4.6&quot;&gt;&amp;sect;3.4.6&lt;/a&gt;).</source>
          <target state="translated">스택 맨 위에 있는 &lt;code&gt;n&lt;/code&gt; 개의 값을 연결하고 팝한 다음 결과를 맨 위에 둡니다. 경우 &lt;code&gt;n&lt;/code&gt; 은 1이고, 그 결과 (즉, 함수는 아무것도하지 않는다) 스택에 하나의 값이고; 경우 &lt;code&gt;n&lt;/code&gt; 은 0, 결과는 빈 문자열입니다. 연결은 Lua의 일반적인 의미를 따라 수행됩니다 ( &lt;a href=&quot;#3.4.6&quot;&gt;&amp;sect;3.4.6&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="eec037fd21cdbe752cf956ee1da877b809e27461" translate="yes" xml:space="preserve">
          <source>Concatenation</source>
          <target state="translated">Concatenation</target>
        </trans-unit>
        <trans-unit id="398713ac023b450e8c4b5b95b390a7f9a7cf2b57" translate="yes" xml:space="preserve">
          <source>Continuation functions now receive as parameters what they needed to get through &lt;code&gt;lua_getctx&lt;/code&gt;, so &lt;code&gt;lua_getctx&lt;/code&gt; has been removed. Adapt your code accordingly.</source>
          <target state="translated">연속 함수는 이제 &lt;code&gt;lua_getctx&lt;/code&gt; 를 통과하는 데 필요한 것을 매개 변수로 수신 하므로 &lt;code&gt;lua_getctx&lt;/code&gt; 가 제거되었습니다. 이에 따라 코드를 조정하십시오.</target>
        </trans-unit>
        <trans-unit id="49551177d73377982310b6a218929215d8146939" translate="yes" xml:space="preserve">
          <source>Control Structures</source>
          <target state="translated">제어 구조</target>
        </trans-unit>
        <trans-unit id="5ee818a21f2b1465f364481c4e0134cff5f18467" translate="yes" xml:space="preserve">
          <source>Controls the garbage collector.</source>
          <target state="translated">가비지 수집기를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="7837da47cfdd57111dc0e4c0e5a4d9267fcf8abb" translate="yes" xml:space="preserve">
          <source>Converts a Lua float to a Lua integer. This macro assumes that &lt;code&gt;n&lt;/code&gt; has an integral value. If that value is within the range of Lua integers, it is converted to an integer and assigned to &lt;code&gt;*p&lt;/code&gt;. The macro results in a boolean indicating whether the conversion was successful. (Note that this range test can be tricky to do correctly without this macro, due to roundings.)</source>
          <target state="translated">Lua 부동 소수점을 Lua 정수로 변환합니다. 이 매크로는 &lt;code&gt;n&lt;/code&gt; 에 정수 값이 있다고 가정합니다 . 해당 값이 Lua 정수 범위 내에 있으면 정수로 변환되어 &lt;code&gt;*p&lt;/code&gt; 에 지정됩니다 . 매크로는 변환이 성공했는지 여부를 나타내는 부울 값을 생성합니다. (이 범위 테스트는 반올림으로 인해이 매크로없이 올바르게 수행하기 까다로울 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="5e3aa93bc10e31bb44d33a41364e25a0f08ad8ca" translate="yes" xml:space="preserve">
          <source>Converts a value at the given index to a C function. That value must be a C function; otherwise, returns &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">주어진 인덱스의 값을 C 함수로 변환합니다. 이 값은 C 함수 여야합니다. 그렇지 않으면 &lt;code&gt;NULL&lt;/code&gt; 을 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="d84bb361f91b5e3df288f36388a7c2ecfd791972" translate="yes" xml:space="preserve">
          <source>Converts any Lua value at the given index to a C string in a reasonable format. The resulting string is pushed onto the stack and also returned by the function (see &lt;a href=&quot;#4.1.3&quot;&gt;&amp;sect;4.1.3&lt;/a&gt;). If &lt;code&gt;len&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, the function also sets &lt;code&gt;*len&lt;/code&gt; with the string length.</source>
          <target state="translated">주어진 인덱스의 모든 Lua 값을 적절한 형식의 C 문자열로 변환합니다. 결과 문자열은 스택에 푸시되고 함수에 의해 반환됩니다 ( &lt;a href=&quot;#4.1.3&quot;&gt;&amp;sect;4.1.3&lt;/a&gt; 참조 ). 경우 &lt;code&gt;len&lt;/code&gt; 아닌 &lt;code&gt;NULL&lt;/code&gt; , 기능은 세트 &lt;code&gt;*len&lt;/code&gt; 문자열 길이.</target>
        </trans-unit>
        <trans-unit id="d00d889b1b22745925c2a76fb0e196b525544aa3" translate="yes" xml:space="preserve">
          <source>Converts any Lua value at the given index to a C string in a reasonable format. The resulting string is pushed onto the stack and also returned by the function. If &lt;code&gt;len&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, the function also sets &lt;code&gt;*len&lt;/code&gt; with the string length.</source>
          <target state="translated">주어진 인덱스의 Lua 값을 적절한 형식의 C 문자열로 변환합니다. 결과 문자열은 스택으로 푸시되고 함수에 의해 반환됩니다. &lt;code&gt;len&lt;/code&gt; 이 &lt;code&gt;NULL&lt;/code&gt; 이 아닌 경우 함수는 문자열 길이와 함께 &lt;code&gt;*len&lt;/code&gt; 을 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="116e857e2ca9e12d4b94e18f89755a1be1b5803e" translate="yes" xml:space="preserve">
          <source>Converts the Lua value at the given index to a C boolean value (0 or 1). Like all tests in Lua, &lt;a href=&quot;#lua_toboolean&quot;&gt;&lt;code&gt;lua_toboolean&lt;/code&gt;&lt;/a&gt; returns true for any Lua value different from &lt;b&gt;false&lt;/b&gt; and &lt;b&gt;nil&lt;/b&gt;; otherwise it returns false. (If you want to accept only actual boolean values, use &lt;a href=&quot;#lua_isboolean&quot;&gt;&lt;code&gt;lua_isboolean&lt;/code&gt;&lt;/a&gt; to test the value's type.)</source>
          <target state="translated">지정된 인덱스의 Lua 값을 C 부울 값 (0 또는 1)으로 변환합니다. Lua의 모든 테스트와 마찬가지로 &lt;a href=&quot;#lua_toboolean&quot;&gt; &lt;code&gt;lua_toboolean&lt;/code&gt; &lt;/a&gt; 은 &lt;b&gt;false&lt;/b&gt; 및 &lt;b&gt;nil&lt;/b&gt; 과 다른 Lua 값에 대해 true를 반환합니다 . 그렇지 않으면 false를 반환합니다. 실제 부울 값만 허용하려면 &lt;a href=&quot;#lua_isboolean&quot;&gt; &lt;code&gt;lua_isboolean&lt;/code&gt; &lt;/a&gt; 을 사용하여 값 유형을 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="d683bc445abde80f362551e45b28ac54bcdd2673" translate="yes" xml:space="preserve">
          <source>Converts the Lua value at the given index to a C string. If &lt;code&gt;len&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, it sets &lt;code&gt;*len&lt;/code&gt; with the string length. The Lua value must be a string or a number; otherwise, the function returns &lt;code&gt;NULL&lt;/code&gt;. If the value is a number, then &lt;code&gt;lua_tolstring&lt;/code&gt; also &lt;em&gt;changes the actual value in the stack to a string&lt;/em&gt;. (This change confuses &lt;a href=&quot;#lua_next&quot;&gt;&lt;code&gt;lua_next&lt;/code&gt;&lt;/a&gt; when &lt;code&gt;lua_tolstring&lt;/code&gt; is applied to keys during a table traversal.)</source>
          <target state="translated">지정된 인덱스의 Lua 값을 C 문자열로 변환합니다. &lt;code&gt;len&lt;/code&gt; 이 &lt;code&gt;NULL&lt;/code&gt; 이 아닌 경우 문자열 길이와 함께 &lt;code&gt;*len&lt;/code&gt; 을 설정합니다 . Lua 값은 문자열 또는 숫자 여야합니다. 그렇지 않으면 함수는 &lt;code&gt;NULL&lt;/code&gt; 을 반환 합니다 . 값이 숫자이면 &lt;code&gt;lua_tolstring&lt;/code&gt; &lt;em&gt;은 스택의 실제 값&lt;/em&gt; 도 &lt;em&gt;string으로 변경합니다&lt;/em&gt; . (이 변경은 &lt;code&gt;lua_tolstring&lt;/code&gt; 이 테이블 순회 중 키에 적용될 때 &lt;a href=&quot;#lua_next&quot;&gt; &lt;code&gt;lua_next&lt;/code&gt; 를&lt;/a&gt; 혼동 합니다.)</target>
        </trans-unit>
        <trans-unit id="b70c1818d1a487a028f6acabf5e97860ef23c14b" translate="yes" xml:space="preserve">
          <source>Converts the Lua value at the given index to the C type &lt;a href=&quot;#lua_Number&quot;&gt;&lt;code&gt;lua_Number&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;#lua_Number&quot;&gt;&lt;code&gt;lua_Number&lt;/code&gt;&lt;/a&gt;). The Lua value must be a number or a string convertible to a number (see &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3&lt;/a&gt;); otherwise, &lt;a href=&quot;#lua_tonumberx&quot;&gt;&lt;code&gt;lua_tonumberx&lt;/code&gt;&lt;/a&gt; returns 0.</source>
          <target state="translated">지정된 색인의 Lua 값을 C 유형 &lt;a href=&quot;#lua_Number&quot;&gt; &lt;code&gt;lua_Number&lt;/code&gt; 로&lt;/a&gt; 변환합니다 ( &lt;a href=&quot;#lua_Number&quot;&gt; &lt;code&gt;lua_Number&lt;/code&gt; &lt;/a&gt; 참조 ). Lua 값은 숫자 또는 숫자로 변환 가능한 문자열이어야합니다 ( &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3&lt;/a&gt; 참조 ). 그렇지 않으면 &lt;a href=&quot;#lua_tonumberx&quot;&gt; &lt;code&gt;lua_tonumberx&lt;/code&gt; &lt;/a&gt; 는 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="15f299b2d961c145de7c7f6e078e5bce8ef3ebc3" translate="yes" xml:space="preserve">
          <source>Converts the Lua value at the given index to the signed integral type &lt;a href=&quot;#lua_Integer&quot;&gt;&lt;code&gt;lua_Integer&lt;/code&gt;&lt;/a&gt;. The Lua value must be an integer, or a number or string convertible to an integer (see &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3&lt;/a&gt;); otherwise, &lt;code&gt;lua_tointegerx&lt;/code&gt; returns 0.</source>
          <target state="translated">지정된 인덱스의 Lua 값을 부호있는 정수형 &lt;a href=&quot;#lua_Integer&quot;&gt; &lt;code&gt;lua_Integer&lt;/code&gt; 로 변환&lt;/a&gt; 합니다. Lua 값은 정수이거나 정수로 변환 가능한 숫자 또는 문자열이어야합니다 ( &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3&lt;/a&gt; 참조 ). 그렇지 않으면 &lt;code&gt;lua_tointegerx&lt;/code&gt; 는 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="56b8fd88e6e0c138775b719f7a5a3ba451055b5f" translate="yes" xml:space="preserve">
          <source>Converts the acceptable index &lt;code&gt;idx&lt;/code&gt; into an equivalent absolute index (that is, one that does not depend on the stack top).</source>
          <target state="translated">허용 가능한 인덱스 &lt;code&gt;idx&lt;/code&gt; 를 동등한 절대 인덱스 (즉, 스택 상단에 의존하지 않는 인덱스)로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="e6fb8705a562a080e28f0029fd5720bc4900e0ba" translate="yes" xml:space="preserve">
          <source>Converts the angle &lt;code&gt;x&lt;/code&gt; from degrees to radians.</source>
          <target state="translated">각도 &lt;code&gt;x&lt;/code&gt; 를도에서 라디안으로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="a9e18c902b7ca6a770ce37f4b1286eab04eed85b" translate="yes" xml:space="preserve">
          <source>Converts the angle &lt;code&gt;x&lt;/code&gt; from radians to degrees.</source>
          <target state="translated">각도 &lt;code&gt;x&lt;/code&gt; 를 라디안 에서 각도로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="f0f8e779d171995ba326ae0853150d5a8e164de0" translate="yes" xml:space="preserve">
          <source>Converts the value at the given index to a Lua thread (represented as &lt;code&gt;lua_State*&lt;/code&gt;). This value must be a thread; otherwise, the function returns &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">지정된 인덱스의 값을 Lua 스레드 ( &lt;code&gt;lua_State*&lt;/code&gt; 로 표시)로 변환합니다 . 이 값은 스레드 여야합니다. 그렇지 않으면 함수는 &lt;code&gt;NULL&lt;/code&gt; 을 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="4765ce3c61b7fb38e87d3739e274dc0e2ee52ed7" translate="yes" xml:space="preserve">
          <source>Converts the value at the given index to a generic C pointer (&lt;code&gt;void*&lt;/code&gt;). The value can be a userdata, a table, a thread, a string, or a function; otherwise, &lt;code&gt;lua_topointer&lt;/code&gt; returns &lt;code&gt;NULL&lt;/code&gt;. Different objects will give different pointers. There is no way to convert the pointer back to its original value.</source>
          <target state="translated">주어진 인덱스의 값을 일반 C 포인터 ( &lt;code&gt;void*&lt;/code&gt; )로 변환합니다. 값은 사용자 데이터, 테이블, 스레드, 문자열 또는 함수일 수 있습니다. 그렇지 않으면 &lt;code&gt;lua_topointer&lt;/code&gt; 가 &lt;code&gt;NULL&lt;/code&gt; 을 반환 합니다 . 다른 개체는 다른 포인터를 제공합니다. 포인터를 원래 값으로 다시 변환하는 방법은 없습니다.</target>
        </trans-unit>
        <trans-unit id="fa669b19e261e97a900695fc2754e811aa721912" translate="yes" xml:space="preserve">
          <source>Converts the value at the given index to a generic C pointer (&lt;code&gt;void*&lt;/code&gt;). The value can be a userdata, a table, a thread, or a function; otherwise, &lt;code&gt;lua_topointer&lt;/code&gt; returns &lt;code&gt;NULL&lt;/code&gt;. Different objects will give different pointers. There is no way to convert the pointer back to its original value.</source>
          <target state="translated">지정된 색인의 값을 일반 C 포인터 ( &lt;code&gt;void*&lt;/code&gt; )로 변환합니다. 값은 사용자 데이터, 테이블, 스레드 또는 함수일 수 있습니다. 그렇지 않으면 &lt;code&gt;lua_topointer&lt;/code&gt; 는 &lt;code&gt;NULL&lt;/code&gt; 을 반환 합니다 . 다른 객체는 다른 포인터를 제공합니다. 포인터를 원래 값으로 다시 변환 할 수있는 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="e5b98b4c46b3b3b87df50590e233197fb42ee19f" translate="yes" xml:space="preserve">
          <source>Converts the zero-terminated string &lt;code&gt;s&lt;/code&gt; to a number, pushes that number into the stack, and returns the total size of the string, that is, its length plus one. The conversion can result in an integer or a float, according to the lexical conventions of Lua (see &lt;a href=&quot;#3.1&quot;&gt;&amp;sect;3.1&lt;/a&gt;). The string may have leading and trailing spaces and a sign. If the string is not a valid numeral, returns 0 and pushes nothing. (Note that the result can be used as a boolean, true if the conversion succeeds.)</source>
          <target state="translated">변환 제로 종료 문자열 &lt;code&gt;s&lt;/code&gt; 숫자로는, 그 스택에 번호, 반환, 길이 더하기 하나 인 문자열의 전체 크기를 푸시합니다. Lua의 어휘 규칙에 따라 변환 결과에 정수 또는 부동 소수점이 발생할 수 있습니다 ( &lt;a href=&quot;#3.1&quot;&gt;&amp;sect;3.1&lt;/a&gt; 참조 ). 문자열에는 앞뒤 공백과 부호가있을 수 있습니다. 문자열이 유효한 숫자가 아닌 경우 0을 반환하고 아무 것도 푸시하지 않습니다. (결과는 부울로 사용될 수 있으며 변환이 성공하면 true입니다.)</target>
        </trans-unit>
        <trans-unit id="a07ce76e129eba5face8c2a20345f32b8dbfed46" translate="yes" xml:space="preserve">
          <source>Converts the zero-terminated string &lt;code&gt;s&lt;/code&gt; to a number, pushes that number into the stack, and returns the total size of the string, that is, its length plus one. The conversion can result in an integer or a float, according to the lexical conventions of Lua (see &lt;a href=&quot;#3.1&quot;&gt;&amp;sect;3.1&lt;/a&gt;). The string may have leading and trailing whitespaces and a sign. If the string is not a valid numeral, returns 0 and pushes nothing. (Note that the result can be used as a boolean, true if the conversion succeeds.)</source>
          <target state="translated">0으로 끝나는 문자열 &lt;code&gt;s&lt;/code&gt; 를 숫자로 변환하고 해당 숫자를 스택에 푸시 한 다음 문자열의 총 크기, 즉 길이에 1을 더한 값을 반환합니다. 변환은 Lua의 어휘 규칙에 따라 정수 또는 부동 소수점이 될 수 있습니다 ( &lt;a href=&quot;#3.1&quot;&gt;&amp;sect;3.1&lt;/a&gt; 참조 ). 문자열에는 선행 및 후행 공백과 부호가있을 수 있습니다. 문자열이 유효한 숫자가 아니면 0을 반환하고 아무것도 푸시하지 않습니다. (결과는 부울로 사용될 수 있으며 변환이 성공하면 참입니다.)</target>
        </trans-unit>
        <trans-unit id="afda351611f229d2ffdcdc3ced1f84f41bb44f33" translate="yes" xml:space="preserve">
          <source>Copies the element at index &lt;code&gt;fromidx&lt;/code&gt; into the valid index &lt;code&gt;toidx&lt;/code&gt;, replacing the value at that position. Values at other positions are not affected.</source>
          <target state="translated">사본 인덱스의 요소 &lt;code&gt;fromidx&lt;/code&gt; 유효 인덱스에 &lt;code&gt;toidx&lt;/code&gt; 해당 위치의 값을 대체. 다른 위치의 값은 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="038697113018f4400bc94f1be4aebad0829b635a" translate="yes" xml:space="preserve">
          <source>Coroutines</source>
          <target state="translated">Coroutines</target>
        </trans-unit>
        <trans-unit id="725136a9add10a0a9d7033c2e6eefd6766658f99" translate="yes" xml:space="preserve">
          <source>Creates a copy of string &lt;code&gt;s&lt;/code&gt; by replacing any occurrence of the string &lt;code&gt;p&lt;/code&gt; with the string &lt;code&gt;r&lt;/code&gt;. Pushes the resulting string on the stack and returns it.</source>
          <target state="translated">문자열 &lt;code&gt;p&lt;/code&gt; 를 문자열 &lt;code&gt;r&lt;/code&gt; 로 바꾸어 문자열 &lt;code&gt;s&lt;/code&gt; 복사본을 만듭니다 . 결과 문자열을 스택에 푸시하고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5baad47488e2efeffe466611b840cdf047cbb4cc" translate="yes" xml:space="preserve">
          <source>Creates a copy of string &lt;code&gt;s&lt;/code&gt;, replacing any occurrence of the string &lt;code&gt;p&lt;/code&gt; with the string &lt;code&gt;r&lt;/code&gt;. Pushes the resulting string on the stack and returns it.</source>
          <target state="translated">문자열 &lt;code&gt;s&lt;/code&gt; 의 복사본을 만들고 &lt;code&gt;p&lt;/code&gt; 문자열을 &lt;code&gt;r&lt;/code&gt; 문자열로 바꿉니다 . 결과 문자열을 스택에 푸시하고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="409211348501f0fceae087d0a64eb7812f2900e2" translate="yes" xml:space="preserve">
          <source>Creates a new Lua state. It calls &lt;a href=&quot;#lua_newstate&quot;&gt;&lt;code&gt;lua_newstate&lt;/code&gt;&lt;/a&gt; with an allocator based on the standard C &lt;code&gt;realloc&lt;/code&gt; function and then sets a panic function (see &lt;a href=&quot;#4.6&quot;&gt;&amp;sect;4.6&lt;/a&gt;) that prints an error message to the standard error output in case of fatal errors.</source>
          <target state="translated">새로운 루아 상태를 만듭니다. 표준 C &lt;code&gt;realloc&lt;/code&gt; 함수를 기반으로 할당자를 사용하여 &lt;a href=&quot;#lua_newstate&quot;&gt; &lt;code&gt;lua_newstate&lt;/code&gt; &lt;/a&gt; 를 호출 한 다음 치명적 오류의 경우 표준 오류 출력에 오류 메시지를 인쇄하는 패닉 함수 ( &lt;a href=&quot;#4.6&quot;&gt;&amp;sect;4.6&lt;/a&gt; 참조 )를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="5f7935c892ad0010ffd499bdb61eaf24ac62873c" translate="yes" xml:space="preserve">
          <source>Creates a new Lua state. It calls &lt;a href=&quot;#lua_newstate&quot;&gt;&lt;code&gt;lua_newstate&lt;/code&gt;&lt;/a&gt; with an allocator based on the standard C allocation functions and then sets a warning function and a panic function (see &lt;a href=&quot;#4.4&quot;&gt;&amp;sect;4.4&lt;/a&gt;) that print messages to the standard error output.</source>
          <target state="translated">새로운 Lua 상태를 만듭니다. 표준 C 할당 함수를 기반으로하는 할당 &lt;a href=&quot;#lua_newstate&quot;&gt; &lt;code&gt;lua_newstate&lt;/code&gt; &lt;/a&gt; 를 호출 한 다음 표준 오류 출력에 메시지를 인쇄 하는 경고 함수와 패닉 함수 ( &lt;a href=&quot;#4.4&quot;&gt;&amp;sect;4.4&lt;/a&gt; 참조 )를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="e2e14753be2923d3727ec4c0b2962317308b7a78" translate="yes" xml:space="preserve">
          <source>Creates a new coroutine, with body &lt;code&gt;f&lt;/code&gt;. &lt;code&gt;f&lt;/code&gt; must be a function. Returns a function that resumes the coroutine each time it is called. Any arguments passed to the function behave as the extra arguments to &lt;code&gt;resume&lt;/code&gt;. Returns the same values returned by &lt;code&gt;resume&lt;/code&gt;, except the first boolean. In case of error, propagates the error.</source>
          <target state="translated">body &lt;code&gt;f&lt;/code&gt; 로 새로운 코 루틴을 만듭니다 . &lt;code&gt;f&lt;/code&gt; 는 함수 여야합니다. 코 루틴을 호출 할 때마다 다시 시작하는 함수를 반환합니다. 함수에 전달 된 모든 인수는 &lt;code&gt;resume&lt;/code&gt; 할 추가 인수로 작동합니다 . 첫 번째 부울을 제외하고 &lt;code&gt;resume&lt;/code&gt; 으로 반환 된 것과 동일한 값을 반환합니다 . 오류가 발생하면 오류가 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="05bb83a7ae7bf5c690003996483410c7c3b04c7a" translate="yes" xml:space="preserve">
          <source>Creates a new coroutine, with body &lt;code&gt;f&lt;/code&gt;. &lt;code&gt;f&lt;/code&gt; must be a function. Returns this new coroutine, an object with type &lt;code&gt;&quot;thread&quot;&lt;/code&gt;.</source>
          <target state="translated">body &lt;code&gt;f&lt;/code&gt; 로 새로운 코 루틴을 만듭니다 . &lt;code&gt;f&lt;/code&gt; 는 함수 여야합니다. &lt;code&gt;&quot;thread&quot;&lt;/code&gt; 유형의 객체 인이 새로운 코 루틴을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="34e792658e08ad25182b4ae588e7bb882e49e2e5" translate="yes" xml:space="preserve">
          <source>Creates a new coroutine, with body &lt;code&gt;f&lt;/code&gt;; &lt;code&gt;f&lt;/code&gt; must be a function. Returns a function that resumes the coroutine each time it is called. Any arguments passed to this function behave as the extra arguments to &lt;code&gt;resume&lt;/code&gt;. The function returns the same values returned by &lt;code&gt;resume&lt;/code&gt;, except the first boolean. In case of error, the function closes the coroutine and propagates the error.</source>
          <target state="translated">body &lt;code&gt;f&lt;/code&gt; 로 새로운 코 루틴을 생성합니다 . &lt;code&gt;f&lt;/code&gt; 는 함수 여야합니다. 코 루틴이 호출 될 때마다 다시 시작하는 함수를 반환합니다. 이 함수에 전달 된 모든 인수는 &lt;code&gt;resume&lt;/code&gt; 할 추가 인수로 작동합니다 . 이 함수는 첫 번째 부울을 제외하고 &lt;code&gt;resume&lt;/code&gt; 에 의해 반환 된 동일한 값을 반환합니다 . 오류가 발생한 경우 함수는 코 루틴을 닫고 오류를 전파합니다.</target>
        </trans-unit>
        <trans-unit id="2a50f66b26d5dc5b8cc4ba979a4ea976308b32d2" translate="yes" xml:space="preserve">
          <source>Creates a new empty table and pushes it onto the stack. It is equivalent to &lt;code&gt;lua_createtable(L, 0, 0)&lt;/code&gt;.</source>
          <target state="translated">빈 테이블을 새로 만들어 스택에 넣습니다. 또한 동등 &lt;code&gt;lua_createtable(L, 0, 0)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96db399082b6917880b7df2255e1672897dcd9fd" translate="yes" xml:space="preserve">
          <source>Creates a new empty table and pushes it onto the stack. Parameter &lt;code&gt;narr&lt;/code&gt; is a hint for how many elements the table will have as a sequence; parameter &lt;code&gt;nrec&lt;/code&gt; is a hint for how many other elements the table will have. Lua may use these hints to preallocate memory for the new table. This preallocation is useful for performance when you know in advance how many elements the table will have. Otherwise you can use the function &lt;a href=&quot;#lua_newtable&quot;&gt;&lt;code&gt;lua_newtable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">빈 테이블을 새로 만들어 스택에 넣습니다. 매개 변수 &lt;code&gt;narr&lt;/code&gt; 은 테이블이 시퀀스로 가질 요소 수에 대한 힌트입니다. 매개 변수 &lt;code&gt;nrec&lt;/code&gt; 는 테이블에 몇 개의 다른 요소가 있는지에 대한 힌트입니다. Lua는이 힌트를 사용하여 새 테이블의 메모리를 미리 할당 할 수 있습니다. 이 사전 할당은 테이블의 요소 수를 미리 알고있을 때 성능에 유용합니다. 그렇지 않으면 &lt;a href=&quot;#lua_newtable&quot;&gt; &lt;code&gt;lua_newtable&lt;/code&gt; &lt;/a&gt; 함수를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5012a48dd57af0841e13fac54cae3a40c700e59a" translate="yes" xml:space="preserve">
          <source>Creates a new empty table and pushes it onto the stack. Parameter &lt;code&gt;narr&lt;/code&gt; is a hint for how many elements the table will have as a sequence; parameter &lt;code&gt;nrec&lt;/code&gt; is a hint for how many other elements the table will have. Lua may use these hints to preallocate memory for the new table. This preallocation may help performance when you know in advance how many elements the table will have. Otherwise you can use the function &lt;a href=&quot;#lua_newtable&quot;&gt;&lt;code&gt;lua_newtable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">빈 테이블을 새로 만들고 스택에 푸시합니다. 매개 변수 &lt;code&gt;narr&lt;/code&gt; 은 테이블이 시퀀스로 가질 요소 수에 대한 힌트입니다. &lt;code&gt;nrec&lt;/code&gt; 매개 변수 는 테이블에 몇 개의 다른 요소가 있는지에 대한 힌트입니다. Lua는 이러한 힌트를 사용하여 새 테이블에 대한 메모리를 미리 할당 할 수 있습니다. 이 사전 할당은 테이블에 포함될 요소 수를 미리 알고있을 때 성능에 도움이 될 수 있습니다. 그렇지 않으면 &lt;a href=&quot;#lua_newtable&quot;&gt; &lt;code&gt;lua_newtable&lt;/code&gt; &lt;/a&gt; 함수를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="31f96efce2ac04d437d79b84748bce9570451a0d" translate="yes" xml:space="preserve">
          <source>Creates a new independent state and returns its main thread. Returns &lt;code&gt;NULL&lt;/code&gt; if it cannot create the state (due to lack of memory). The argument &lt;code&gt;f&lt;/code&gt; is the allocator function; Lua will do all memory allocation for this state through this function (see &lt;a href=&quot;#lua_Alloc&quot;&gt;&lt;code&gt;lua_Alloc&lt;/code&gt;&lt;/a&gt;). The second argument, &lt;code&gt;ud&lt;/code&gt;, is an opaque pointer that Lua passes to the allocator in every call.</source>
          <target state="translated">새로운 독립 상태를 만들고 기본 스레드를 반환합니다. 메모리 부족으로 인해 상태를 만들 수없는 경우 &lt;code&gt;NULL&lt;/code&gt; 을 반환 합니다 . 인수 &lt;code&gt;f&lt;/code&gt; 는 할당 자 함수입니다. Lua는이 함수를 통해이 상태에 대한 모든 메모리 할당을 수행합니다 ( &lt;a href=&quot;#lua_Alloc&quot;&gt; &lt;code&gt;lua_Alloc&lt;/code&gt; &lt;/a&gt; 참조 ). 두 번째 인수 &lt;code&gt;ud&lt;/code&gt; 는 Lua가 모든 호출에서 할당 자에게 전달하는 불투명 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="cc85f5dc1d8e4aacd51d81be148d528a2a237f3a" translate="yes" xml:space="preserve">
          <source>Creates a new table and registers there the functions in list &lt;code&gt;l&lt;/code&gt;.</source>
          <target state="translated">새로운 테이블을 생성하고리스트 &lt;code&gt;l&lt;/code&gt; 에 함수를 등록합니다 .</target>
        </trans-unit>
        <trans-unit id="c341a15f1d3c228a7286e34a264438cedaa0d0e8" translate="yes" xml:space="preserve">
          <source>Creates a new table and registers there the functions in the list &lt;code&gt;l&lt;/code&gt;.</source>
          <target state="translated">새 테이블을 만들고 목록 &lt;code&gt;l&lt;/code&gt; 에있는 함수를 등록합니다 .</target>
        </trans-unit>
        <trans-unit id="5e609328dccbccc7603668252d3543d1885dfb3e" translate="yes" xml:space="preserve">
          <source>Creates a new table with a size optimized to store all entries in the array &lt;code&gt;l&lt;/code&gt; (but does not actually store them). It is intended to be used in conjunction with &lt;a href=&quot;#luaL_setfuncs&quot;&gt;&lt;code&gt;luaL_setfuncs&lt;/code&gt;&lt;/a&gt; (see &lt;a href=&quot;#luaL_newlib&quot;&gt;&lt;code&gt;luaL_newlib&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">모든 항목을 배열 &lt;code&gt;l&lt;/code&gt; 에 저장하도록 최적화 된 크기로 새 테이블을 작성 하지만 실제로 저장하지는 않습니다. &lt;a href=&quot;#luaL_setfuncs&quot;&gt; &lt;code&gt;luaL_setfuncs&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;#luaL_newlib&quot;&gt; &lt;code&gt;luaL_newlib&lt;/code&gt; &lt;/a&gt; 참조 ) 와 함께 사용하도록 고안되었습니다 .</target>
        </trans-unit>
        <trans-unit id="9c2dc3a7ed086d8ba5b98b47e50da72e0597ad2f" translate="yes" xml:space="preserve">
          <source>Creates a new thread running in a new, independent state. Returns &lt;code&gt;NULL&lt;/code&gt; if it cannot create the thread or the state (due to lack of memory). The argument &lt;code&gt;f&lt;/code&gt; is the allocator function; Lua does all memory allocation for this state through this function (see &lt;a href=&quot;#lua_Alloc&quot;&gt;&lt;code&gt;lua_Alloc&lt;/code&gt;&lt;/a&gt;). The second argument, &lt;code&gt;ud&lt;/code&gt;, is an opaque pointer that Lua passes to the allocator in every call.</source>
          <target state="translated">새로운 독립 상태에서 실행중인 새 스레드를 작성합니다. 스레드 나 상태를 만들 수 없으면 (메모리 부족으로 인해) &lt;code&gt;NULL&lt;/code&gt; 을 반환 합니다 . 인수 &lt;code&gt;f&lt;/code&gt; 는 할당 자 함수입니다. Lua는이 함수를 통해이 상태에 대한 모든 메모리 할당을 수행합니다 ( &lt;a href=&quot;#lua_Alloc&quot;&gt; &lt;code&gt;lua_Alloc&lt;/code&gt; &lt;/a&gt; 참조 ). 두 번째 인수 인 &lt;code&gt;ud&lt;/code&gt; 는 루아가 모든 호출에서 할당 자에게 전달하는 불투명 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="fd9ec8c11d7ac5415a760ccd09c2fad1db9839cf" translate="yes" xml:space="preserve">
          <source>Creates a new thread, pushes it on the stack, and returns a pointer to a &lt;a href=&quot;#lua_State&quot;&gt;&lt;code&gt;lua_State&lt;/code&gt;&lt;/a&gt; that represents this new thread. The new thread returned by this function shares with the original thread its global environment, but has an independent execution stack.</source>
          <target state="translated">새 스레드를 작성하여 스택에 푸시 한 다음 이 새 스레드를 나타내는 &lt;a href=&quot;#lua_State&quot;&gt; &lt;code&gt;lua_State&lt;/code&gt; 에&lt;/a&gt; 대한 포인터를 리턴합니다 . 이 함수가 반환 한 새 스레드는 글로벌 환경의 원래 스레드와 공유하지만 독립적 인 실행 스택이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e0ca6aea862016d29b1b85fa495b05b651392c7" translate="yes" xml:space="preserve">
          <source>Creates and pushes a traceback of the stack &lt;code&gt;L1&lt;/code&gt;. If &lt;code&gt;msg&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt; it is appended at the beginning of the traceback. The &lt;code&gt;level&lt;/code&gt; parameter tells at which level to start the traceback.</source>
          <target state="translated">스택 &lt;code&gt;L1&lt;/code&gt; 의 역 추적을 작성하고 푸시합니다 . &lt;code&gt;msg&lt;/code&gt; 가 &lt;code&gt;NULL&lt;/code&gt; 이 아닌 경우 , 역 추적의 시작 부분에 추가됩니다. &lt;code&gt;level&lt;/code&gt; 매개 변수는 역 추적을 시작하는 단계에서 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="15bfd10f645b4386c20f64772098c6ffce3ebad6" translate="yes" xml:space="preserve">
          <source>Creates and pushes a traceback of the stack &lt;code&gt;L1&lt;/code&gt;. If &lt;code&gt;msg&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, it is appended at the beginning of the traceback. The &lt;code&gt;level&lt;/code&gt; parameter tells at which level to start the traceback.</source>
          <target state="translated">스택 &lt;code&gt;L1&lt;/code&gt; 의 트레이스 백을 생성하고 푸시합니다 . 경우 &lt;code&gt;msg&lt;/code&gt; 아닌 &lt;code&gt;NULL&lt;/code&gt; , 그것은 역 추적의 시작 부분에 추가됩니다. &lt;code&gt;level&lt;/code&gt; 매개 변수는 역 추적을 시작하는 단계에서 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="15fe05dc16322e6d58cea2513fabb05e8a458e73" translate="yes" xml:space="preserve">
          <source>Creates and returns a &lt;em&gt;reference&lt;/em&gt;, in the table at index &lt;code&gt;t&lt;/code&gt;, for the object at the top of the stack (and pops the object).</source>
          <target state="translated">스택의 맨 위에있는 객체에 대한 인덱스 &lt;code&gt;t&lt;/code&gt; 의 테이블에 대한 &lt;em&gt;참조를&lt;/em&gt; 만들고 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="ab88cefb740e57d0abb3b9da6bbb94af440a19a0" translate="yes" xml:space="preserve">
          <source>Creates and returns a &lt;em&gt;reference&lt;/em&gt;, in the table at index &lt;code&gt;t&lt;/code&gt;, for the object on the top of the stack (and pops the object).</source>
          <target state="translated">인덱스 &lt;code&gt;t&lt;/code&gt; 의 테이블에서 스택 맨 위에있는 객체에 대한 &lt;em&gt;참조를&lt;/em&gt; 만들고 반환합니다 (그리고 객체를 팝합니다).</target>
        </trans-unit>
        <trans-unit id="d1819b6bacdff250db0276b77bedb508731402da" translate="yes" xml:space="preserve">
          <source>Currently, Lua has the following standard libraries:</source>
          <target state="translated">현재 Lua에는 다음과 같은 표준 라이브러리가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6bb0e66f778837dd13f606426508f8246862247" translate="yes" xml:space="preserve">
          <source>Deletes the file (or empty directory, on POSIX systems) with the given name. If this function fails, it returns &lt;b&gt;fail&lt;/b&gt; plus a string describing the error and the error code. Otherwise, it returns true.</source>
          <target state="translated">주어진 이름을 가진 파일 (또는 POSIX 시스템의 경우 빈 디렉토리)을 삭제합니다. 이 함수가 실패하면 &lt;b&gt;fail&lt;/b&gt; 과 함께 오류 및 오류 코드를 설명하는 문자열을 반환 합니다. 그렇지 않으면 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9a1d518693f03f77a887add36287621e0ff6c775" translate="yes" xml:space="preserve">
          <source>Deletes the file (or empty directory, on POSIX systems) with the given name. If this function fails, it returns &lt;b&gt;nil&lt;/b&gt;, plus a string describing the error and the error code. Otherwise, it returns true.</source>
          <target state="translated">지정된 이름의 파일 (또는 POSIX 시스템의 빈 디렉토리)을 삭제합니다. 이 함수가 실패하면 &lt;b&gt;nil&lt;/b&gt; 을 리턴합니다.&lt;b&gt;&lt;/b&gt; 과 함께 오류 및 오류 코드를 설명하는 문자열 됩니다. 그렇지 않으면 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7e2e965899d00dbeb421cf187b25cd3fbb127acb" translate="yes" xml:space="preserve">
          <source>Despite the existence of this external &lt;code&gt;_ENV&lt;/code&gt; variable and the translation of free names, &lt;code&gt;_ENV&lt;/code&gt; is a completely regular name. In particular, you can define new variables and parameters with that name. Each reference to a free name uses the &lt;code&gt;_ENV&lt;/code&gt; that is visible at that point in the program, following the usual visibility rules of Lua (see &lt;a href=&quot;#3.5&quot;&gt;&amp;sect;3.5&lt;/a&gt;).</source>
          <target state="translated">이 외부 &lt;code&gt;_ENV&lt;/code&gt; 변수가 있고 자유 이름의 번역 에도 불구하고 &lt;code&gt;_ENV&lt;/code&gt; 는 완전히 정규적인 이름입니다. 특히 해당 이름으로 새 변수 및 매개 변수를 정의 할 수 있습니다. 자유 이름에 대한 각 참조 는 Lua의 일반적인 가시성 규칙에 따라 프로그램의 해당 지점에서 볼 수 있는 &lt;code&gt;_ENV&lt;/code&gt; 를 사용합니다 ( &lt;a href=&quot;#3.5&quot;&gt;&amp;sect;3.5&lt;/a&gt; 참조 ). ).</target>
        </trans-unit>
        <trans-unit id="12de5a5770780d211823aca1736624c0440ac4a1" translate="yes" xml:space="preserve">
          <source>Despite the name, the metamethod for this event can be either a function or a table. If it is a function, it is called with &lt;code&gt;table&lt;/code&gt; and &lt;code&gt;key&lt;/code&gt; as arguments, and the result of the call (adjusted to one value) is the result of the operation. If it is a table, the final result is the result of indexing this table with &lt;code&gt;key&lt;/code&gt;. (This indexing is regular, not raw, and therefore can trigger another metamethod.)</source>
          <target state="translated">이름에도 불구하고이 이벤트의 메타 메소드는 함수 또는 테이블 일 수 있습니다. 함수 인 경우 &lt;code&gt;table&lt;/code&gt; 및 &lt;code&gt;key&lt;/code&gt; 를 인수로 사용하여 호출되며 호출 결과 (한 값으로 조정 됨)가 작업의 결과입니다. 테이블 인 경우 최종 결과는 &lt;code&gt;key&lt;/code&gt; 로이 테이블을 색인화 한 결과입니다 . (이 색인은 기본이 아닌 원시이므로 다른 메타 메소드를 유발할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="e2dd868cc18f6f74b6780c7bcc3d9948c1df04c3" translate="yes" xml:space="preserve">
          <source>Destroys all objects in the given Lua state (calling the corresponding garbage-collection metamethods, if any) and frees all dynamic memory used by this state. On several platforms, you may not need to call this function, because all resources are naturally released when the host program ends. On the other hand, long-running programs that create multiple states, such as daemons or web servers, will probably need to close states as soon as they are not needed.</source>
          <target state="translated">주어진 Lua 상태 (해당되는 가비지 수집 메타 메서드가있는 경우)를 호출하여이 객체가 사용하는 모든 동적 메모리를 해제합니다. 일부 플랫폼에서는 호스트 프로그램이 종료 될 때 모든 자원이 자연스럽게 해제되므로이 함수를 호출 할 필요가 없습니다. 반면, 데몬이나 웹 서버와 같이 여러 상태를 생성하는 장기 실행 프로그램은 필요하지 않은 즉시 상태를 닫아야합니다.</target>
        </trans-unit>
        <trans-unit id="d6c256480b3e40e037a15bde7dbddae426d6a7cf" translate="yes" xml:space="preserve">
          <source>Does the equivalent of &lt;code&gt;t[i] = v&lt;/code&gt;, where &lt;code&gt;t&lt;/code&gt; is the table at the given index and &lt;code&gt;v&lt;/code&gt; is the value at the top of the stack.</source>
          <target state="translated">상당 하는가 &lt;code&gt;t[i] = v&lt;/code&gt; , &lt;code&gt;t&lt;/code&gt; 가 주어진 인덱스에서 테이블 &lt;code&gt;v&lt;/code&gt; 스택의 상부에서의 값이다.</target>
        </trans-unit>
        <trans-unit id="f50cba5754e004689e56ef62b61d400bb02211d6" translate="yes" xml:space="preserve">
          <source>Does the equivalent of &lt;code&gt;t[i] = v&lt;/code&gt;, where &lt;code&gt;t&lt;/code&gt; is the table at the given index and &lt;code&gt;v&lt;/code&gt; is the value on the top of the stack.</source>
          <target state="translated">상당 하는가 &lt;code&gt;t[i] = v&lt;/code&gt; , &lt;code&gt;t&lt;/code&gt; 가 주어진 인덱스에서 테이블 &lt;code&gt;v&lt;/code&gt; 스택의 꼭대기 값이다.</target>
        </trans-unit>
        <trans-unit id="83102ba0627ee415bcdafad8e821cc410f6ca4e8" translate="yes" xml:space="preserve">
          <source>Does the equivalent of &lt;code&gt;t[p] = v&lt;/code&gt;, where &lt;code&gt;t&lt;/code&gt; is the table at the given index, &lt;code&gt;p&lt;/code&gt; is encoded as a light userdata, and &lt;code&gt;v&lt;/code&gt; is the value at the top of the stack.</source>
          <target state="translated">상당 하는가 &lt;code&gt;t[p] = v&lt;/code&gt; , &lt;code&gt;t&lt;/code&gt; 는 테이블 지정된 인덱스되고, &lt;code&gt;p&lt;/code&gt; 광 유저 데이터와 같은 인코딩 된 &lt;code&gt;v&lt;/code&gt; 스택의 상단에있는 값이다.</target>
        </trans-unit>
        <trans-unit id="e1dce27792ce14fbdc9c700a06d947b4b3c9e572" translate="yes" xml:space="preserve">
          <source>Does the equivalent of &lt;code&gt;t[p] = v&lt;/code&gt;, where &lt;code&gt;t&lt;/code&gt; is the table at the given index, &lt;code&gt;p&lt;/code&gt; is encoded as a light userdata, and &lt;code&gt;v&lt;/code&gt; is the value on the top of the stack.</source>
          <target state="translated">상당 하는가 &lt;code&gt;t[p] = v&lt;/code&gt; , &lt;code&gt;t&lt;/code&gt; 는 테이블 지정된 인덱스이다, &lt;code&gt;p&lt;/code&gt; 광 유저 데이터로서 부호화되고, &lt;code&gt;v&lt;/code&gt; 스택의 위쪽에있는 값이다.</target>
        </trans-unit>
        <trans-unit id="e5e1d7b2dfe0e4b65f51a80784409021aefed2c4" translate="yes" xml:space="preserve">
          <source>Does the equivalent to &lt;code&gt;t[k] = v&lt;/code&gt;, where &lt;code&gt;t&lt;/code&gt; is the value at the given index and &lt;code&gt;v&lt;/code&gt; is the value at the top of the stack.</source>
          <target state="translated">&lt;code&gt;t[k] = v&lt;/code&gt; 와 동일합니다 . 여기서 &lt;code&gt;t&lt;/code&gt; 는 지정된 인덱스 의 값 이고 &lt;code&gt;v&lt;/code&gt; 는 스택의 맨 위에있는 값입니다.</target>
        </trans-unit>
        <trans-unit id="726cb88662f8c5ab515b5a42d04ffa849062af21" translate="yes" xml:space="preserve">
          <source>Does the equivalent to &lt;code&gt;t[k] = v&lt;/code&gt;, where &lt;code&gt;t&lt;/code&gt; is the value at the given index and &lt;code&gt;v&lt;/code&gt; is the value on the top of the stack.</source>
          <target state="translated">&lt;code&gt;t[k] = v&lt;/code&gt; 와 동일합니다 . 여기서 &lt;code&gt;t&lt;/code&gt; 는 주어진 인덱스 의 값 이고 &lt;code&gt;v&lt;/code&gt; 는 스택의 맨 위에있는 값입니다.</target>
        </trans-unit>
        <trans-unit id="8b79cf1f60fca53d0de89a3a12255d00973edf92" translate="yes" xml:space="preserve">
          <source>Does the equivalent to &lt;code&gt;t[k] = v&lt;/code&gt;, where &lt;code&gt;t&lt;/code&gt; is the value at the given index, &lt;code&gt;v&lt;/code&gt; is the value at the top of the stack, and &lt;code&gt;k&lt;/code&gt; is the value just below the top.</source>
          <target state="translated">&lt;code&gt;t[k] = v&lt;/code&gt; 와 동일합니다 . 여기서 &lt;code&gt;t&lt;/code&gt; 는 지정된 인덱스 의 값 이고, &lt;code&gt;v&lt;/code&gt; 는 스택의 맨 위에있는 값이고, &lt;code&gt;k&lt;/code&gt; 는 맨 위에있는 값입니다.</target>
        </trans-unit>
        <trans-unit id="18da5e882f06adc234eb1a0b52d52ca16968a459" translate="yes" xml:space="preserve">
          <source>Does the equivalent to &lt;code&gt;t[k] = v&lt;/code&gt;, where &lt;code&gt;t&lt;/code&gt; is the value at the given index, &lt;code&gt;v&lt;/code&gt; is the value on the top of the stack, and &lt;code&gt;k&lt;/code&gt; is the value just below the top.</source>
          <target state="translated">&lt;code&gt;t[k] = v&lt;/code&gt; 와 동일합니다 . 여기서 &lt;code&gt;t&lt;/code&gt; 는 주어진 인덱스 의 값 , &lt;code&gt;v&lt;/code&gt; 는 스택 상단의 값 , &lt;code&gt;k&lt;/code&gt; 는 상단 바로 아래의 값입니다.</target>
        </trans-unit>
        <trans-unit id="cc3b7a2b7b1afec72c53764dcaa4a8915523e72b" translate="yes" xml:space="preserve">
          <source>Does the equivalent to &lt;code&gt;t[n] = v&lt;/code&gt;, where &lt;code&gt;t&lt;/code&gt; is the value at the given index and &lt;code&gt;v&lt;/code&gt; is the value at the top of the stack.</source>
          <target state="translated">&lt;code&gt;t[n] = v&lt;/code&gt; 와 동일합니다 . 여기서 &lt;code&gt;t&lt;/code&gt; 는 지정된 인덱스 의 값 이고 &lt;code&gt;v&lt;/code&gt; 는 스택의 맨 위에있는 값입니다.</target>
        </trans-unit>
        <trans-unit id="211bb7a17fd232fd8888d171735fcbac259859ce" translate="yes" xml:space="preserve">
          <source>Does the equivalent to &lt;code&gt;t[n] = v&lt;/code&gt;, where &lt;code&gt;t&lt;/code&gt; is the value at the given index and &lt;code&gt;v&lt;/code&gt; is the value on the top of the stack.</source>
          <target state="translated">&lt;code&gt;t[n] = v&lt;/code&gt; 와 동일합니다 . 여기서 &lt;code&gt;t&lt;/code&gt; 는 주어진 인덱스 의 값 이고 &lt;code&gt;v&lt;/code&gt; 는 스택의 맨 위에있는 값입니다.</target>
        </trans-unit>
        <trans-unit id="054070872d4195e45bf298511993c73d44db5c6e" translate="yes" xml:space="preserve">
          <source>Dumps a function as a binary chunk. Receives a Lua function on the top of the stack and produces a binary chunk that, if loaded again, results in a function equivalent to the one dumped. As it produces parts of the chunk, &lt;a href=&quot;#lua_dump&quot;&gt;&lt;code&gt;lua_dump&lt;/code&gt;&lt;/a&gt; calls function &lt;code&gt;writer&lt;/code&gt; (see &lt;a href=&quot;#lua_Writer&quot;&gt;&lt;code&gt;lua_Writer&lt;/code&gt;&lt;/a&gt;) with the given &lt;code&gt;data&lt;/code&gt; to write them.</source>
          <target state="translated">함수를 이진 청크로 덤프합니다. 스택 맨 위에서 Lua 함수를 수신하고 다시로드 할 경우 덤프 된 것과 동일한 함수를 생성하는 이진 청크를 생성합니다. 이 청크의 부품을 생산으로 &lt;a href=&quot;#lua_dump&quot;&gt; &lt;code&gt;lua_dump&lt;/code&gt; 의&lt;/a&gt; 전화가 작동 &lt;code&gt;writer&lt;/code&gt; (참조 &lt;a href=&quot;#lua_Writer&quot;&gt; &lt;code&gt;lua_Writer&lt;/code&gt; 를&lt;/a&gt; 주어진과) &lt;code&gt;data&lt;/code&gt; 를 작성.</target>
        </trans-unit>
        <trans-unit id="c90c7bb6d9829fd16d0afd908f93d4e6040aff4e" translate="yes" xml:space="preserve">
          <source>During its normal operation, a string buffer uses a variable number of stack slots. So, while using a buffer, you cannot assume that you know where the top of the stack is. You can use the stack between successive calls to buffer operations as long as that use is balanced; that is, when you call a buffer operation, the stack is at the same level it was immediately after the previous buffer operation. (The only exception to this rule is &lt;a href=&quot;#luaL_addvalue&quot;&gt;&lt;code&gt;luaL_addvalue&lt;/code&gt;&lt;/a&gt;.) After calling &lt;a href=&quot;#luaL_pushresult&quot;&gt;&lt;code&gt;luaL_pushresult&lt;/code&gt;&lt;/a&gt; the stack is back to its level when the buffer was initialized, plus the final string on its top.</source>
          <target state="translated">정상 작동 중에 문자열 버퍼는 가변 개수의 스택 슬롯을 사용합니다. 따라서 버퍼를 사용하는 동안 스택의 상단이 어디에 있는지 알 수 없습니다. 사용이 균형을 유지하는 한 연속적인 버퍼 호출 호출간에 스택을 사용할 수 있습니다. 즉, 버퍼 작업을 호출하면 스택은 이전 버퍼 작업 직후의 수준과 동일합니다. (이 규칙에 대한 유일한 예외는 &lt;a href=&quot;#luaL_addvalue&quot;&gt; &lt;code&gt;luaL_addvalue&lt;/code&gt; &lt;/a&gt; 입니다.) &lt;a href=&quot;#luaL_pushresult&quot;&gt; &lt;code&gt;luaL_pushresult&lt;/code&gt; 를&lt;/a&gt; 호출 한 후 스택이 버퍼가 초기화 될 때 스택의 레벨로 돌아가고 맨 위에있는 최종 문자열이 다시 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="806c211c6a1d685f5e0426f1a70520457c62882e" translate="yes" xml:space="preserve">
          <source>During its normal operation, a string buffer uses a variable number of stack slots. So, while using a buffer, you cannot assume that you know where the top of the stack is. You can use the stack between successive calls to buffer operations as long as that use is balanced; that is, when you call a buffer operation, the stack is at the same level it was immediately after the previous buffer operation. (The only exception to this rule is &lt;a href=&quot;#luaL_addvalue&quot;&gt;&lt;code&gt;luaL_addvalue&lt;/code&gt;&lt;/a&gt;.) After calling &lt;a href=&quot;#luaL_pushresult&quot;&gt;&lt;code&gt;luaL_pushresult&lt;/code&gt;&lt;/a&gt;, the stack is back to its level when the buffer was initialized, plus the final string on its top.</source>
          <target state="translated">정상 작동 중에 문자열 버퍼는 다양한 수의 스택 슬롯을 사용합니다. 따라서 버퍼를 사용하는 동안 스택의 최상위 위치를 알고 있다고 가정 할 수 없습니다. 사용이 균형을 이루는 한 버퍼 작업에 대한 연속 호출간에 스택을 사용할 수 있습니다. 즉, 버퍼 작업을 호출 할 때 스택은 이전 버퍼 작업 직후와 동일한 수준에 있습니다. (이 규칙에 대한 유일한 예외는 &lt;a href=&quot;#luaL_addvalue&quot;&gt; &lt;code&gt;luaL_addvalue&lt;/code&gt; &lt;/a&gt; 입니다.) &lt;a href=&quot;#luaL_pushresult&quot;&gt; &lt;code&gt;luaL_pushresult&lt;/code&gt; 를&lt;/a&gt; 호출 한 후 스택은 버퍼가 초기화 될 때의 수준으로 돌아오고 그 위에 마지막 문자열이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="b76fabdeb134cd6b1444f21660aa818a7b0d8c8f" translate="yes" xml:space="preserve">
          <source>Dynamically links the host program with the C library &lt;code&gt;libname&lt;/code&gt;.</source>
          <target state="translated">호스트 프로그램을 C 라이브러리 &lt;code&gt;libname&lt;/code&gt; 과 동적으로 링크합니다 .</target>
        </trans-unit>
        <trans-unit id="a0f3fe6a9590293b6274b20698d15691bfb7be9e" translate="yes" xml:space="preserve">
          <source>Each Lua state has one or more threads, which correspond to independent, cooperative lines of execution. The type &lt;a href=&quot;#lua_State&quot;&gt;&lt;code&gt;lua_State&lt;/code&gt;&lt;/a&gt; (despite its name) refers to a thread. (Indirectly, through the thread, it also refers to the Lua state associated to the thread.)</source>
          <target state="translated">각 Lua 상태에는 독립적이고 협력적인 실행 라인에 해당하는 하나 이상의 스레드가 있습니다. &lt;a href=&quot;#lua_State&quot;&gt; &lt;code&gt;lua_State&lt;/code&gt; &lt;/a&gt; 유형 (이름에도 불구하고)은 스레드를 나타냅니다. 스레드를 통해 간접적으로 스레드와 관련된 Lua 상태를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c5aba24ed5a01dfc4d7e064e0144db7d74d4c725" translate="yes" xml:space="preserve">
          <source>Each call made from Lua code counts one unit. Other operations (e.g., calls made from C to Lua or resuming a coroutine) may have a higher cost.</source>
          <target state="translated">Lua 코드에서 이루어진 각 호출은 하나의 단위를 계산합니다. 다른 작업 (예 : C에서 Lua 로의 호출 또는 코 루틴 재개)은 비용이 더 많이들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="271d158703dde3ea70b23b6f13cd8c963bd8f8f2" translate="yes" xml:space="preserve">
          <source>Each character in the string &lt;code&gt;what&lt;/code&gt; selects some fields of the structure &lt;code&gt;ar&lt;/code&gt; to be filled or a value to be pushed on the stack:</source>
          <target state="translated">문자열의 각 문자를 &lt;code&gt;what&lt;/code&gt; 구조의 일부 필드 선택 &lt;code&gt;ar&lt;/code&gt; 채워지거나 값은 스택에 푸시한다 :</target>
        </trans-unit>
        <trans-unit id="ecc99d29acc89d3df821079ad381b56b5089631f" translate="yes" xml:space="preserve">
          <source>Each entry in this table is a &lt;em&gt;searcher function&lt;/em&gt;. When looking for a module, &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; calls each of these searchers in ascending order, with the module name (the argument given to &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt;) as its sole argument. If the searcher finds the module, it returns another function, the module &lt;em&gt;loader&lt;/em&gt;, plus an extra value, a &lt;em&gt;loader data&lt;/em&gt;, that will be passed to that loader and returned as a second result by &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt;. If it cannot find the module, it returns a string explaining why (or &lt;b&gt;nil&lt;/b&gt; if it has nothing to say).</source>
          <target state="translated">이 테이블의 각 항목은 &lt;em&gt;검색 자 기능&lt;/em&gt; 입니다. 모듈을 찾을 때 &lt;a href=&quot;#pdf-require&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt; 는 모듈 이름 ( &lt;a href=&quot;#pdf-require&quot;&gt; &lt;code&gt;require&lt;/code&gt; 에&lt;/a&gt; 지정된 인수 )을 유일한 인수로 사용하여 이러한 각 검색 자를 오름차순으로 호출합니다 . 검색자가 모듈을 찾으면 다른 함수 인 module &lt;em&gt;loader&lt;/em&gt; 와 추가 값인 &lt;em&gt;loader data를&lt;/em&gt; 반환하며 이는 해당 로더에 전달되고 &lt;a href=&quot;#pdf-require&quot;&gt; &lt;code&gt;require&lt;/code&gt; 에&lt;/a&gt; 의해 두 번째 결과로 반환됩니다 . 모듈을 찾을 수 없으면 이유를 설명하는 문자열을 반환합니다 (또는 할 말이 없으면 &lt;b&gt;nil&lt;/b&gt; ).</target>
        </trans-unit>
        <trans-unit id="34ea340a21718b1d5eb33af7ac68465d8a3a932c" translate="yes" xml:space="preserve">
          <source>Each entry in this table is a &lt;em&gt;searcher function&lt;/em&gt;. When looking for a module, &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; calls each of these searchers in ascending order, with the module name (the argument given to &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt;) as its sole parameter. The function can return another function (the module &lt;em&gt;loader&lt;/em&gt;) plus an extra value that will be passed to that loader, or a string explaining why it did not find that module (or &lt;b&gt;nil&lt;/b&gt; if it has nothing to say).</source>
          <target state="translated">이 테이블의 각 항목은 &lt;em&gt;검색 기능&lt;/em&gt; 입니다. 모듈을 찾을 때 &lt;a href=&quot;#pdf-require&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt; 는 각 매개 변수 를 오름차순으로 호출하고 모듈 이름 ( &lt;a href=&quot;#pdf-require&quot;&gt; &lt;code&gt;require&lt;/code&gt; 에&lt;/a&gt; 지정된 인수 )을 유일한 매개 변수로 사용하십시오. 이 함수는 다른 함수 (모듈 &lt;em&gt;로더&lt;/em&gt; )와 해당 로더에 전달 될 추가 값 또는 해당 모듈을 찾지 못한 이유를 설명하는 문자열 (또는 아무 말도 &lt;b&gt;하지&lt;/b&gt; 않으면 &lt;b&gt;nil)을&lt;/b&gt; 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d34e2e6727edc3edc80604ce079f860a50da5e4e" translate="yes" xml:space="preserve">
          <source>Each field of the form &lt;code&gt;[exp1] = exp2&lt;/code&gt; adds to the new table an entry with key &lt;code&gt;exp1&lt;/code&gt; and value &lt;code&gt;exp2&lt;/code&gt;. A field of the form &lt;code&gt;name = exp&lt;/code&gt; is equivalent to &lt;code&gt;[&quot;name&quot;] = exp&lt;/code&gt;. Fields of the form &lt;code&gt;exp&lt;/code&gt; are equivalent to &lt;code&gt;[i] = exp&lt;/code&gt;, where &lt;code&gt;i&lt;/code&gt; are consecutive integers starting with 1; fields in the other formats do not affect this counting. For example,</source>
          <target state="translated">폼의 각 필드는 &lt;code&gt;[exp1] = exp2&lt;/code&gt; 새로운 키 테이블 엔트리 추가 &lt;code&gt;exp1&lt;/code&gt; 및 값 &lt;code&gt;exp2&lt;/code&gt; . &lt;code&gt;name = exp&lt;/code&gt; 형식의 필드는 &lt;code&gt;[&quot;name&quot;] = exp&lt;/code&gt; 와 동일합니다 . &lt;code&gt;exp&lt;/code&gt; 형식의 필드는 &lt;code&gt;[i] = exp&lt;/code&gt; 와 동일합니다 . 여기서 &lt;code&gt;i&lt;/code&gt; 는 1로 시작하는 연속 정수입니다. 다른 형식의 필드는이 계산에 영향을주지 않습니다. 예를 들면</target>
        </trans-unit>
        <trans-unit id="315546f1f8c7df68b4e7271febe7523458c848c7" translate="yes" xml:space="preserve">
          <source>Each field of the form &lt;code&gt;[exp1] = exp2&lt;/code&gt; adds to the new table an entry with key &lt;code&gt;exp1&lt;/code&gt; and value &lt;code&gt;exp2&lt;/code&gt;. A field of the form &lt;code&gt;name = exp&lt;/code&gt; is equivalent to &lt;code&gt;[&quot;name&quot;] = exp&lt;/code&gt;. Finally, fields of the form &lt;code&gt;exp&lt;/code&gt; are equivalent to &lt;code&gt;[i] = exp&lt;/code&gt;, where &lt;code&gt;i&lt;/code&gt; are consecutive integers starting with 1. Fields in the other formats do not affect this counting. For example,</source>
          <target state="translated">&lt;code&gt;[exp1] = exp2&lt;/code&gt; 형식의 각 필드는 키 &lt;code&gt;exp1&lt;/code&gt; 및 값 &lt;code&gt;exp2&lt;/code&gt; 를 가진 항목을 새 테이블에 추가합니다 . 폼의 필드 &lt;code&gt;name = exp&lt;/code&gt; 동일하다 &lt;code&gt;[&quot;name&quot;] = exp&lt;/code&gt; . 마지막으로, 폼의 필드 &lt;code&gt;exp&lt;/code&gt; 동등 &lt;code&gt;[i] = exp&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; 이 계산에 영향을 미치지 않는 다른 형식의 1 필드로 시작하는 연속적인 정수이다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="5ded60221fcd42af87598bfa3998cbd1f3094a3c" translate="yes" xml:space="preserve">
          <source>Each new thread has this area initialized with a copy of the area of the main thread.</source>
          <target state="translated">각각의 새로운 쓰레드는이 영역이 메인 쓰레드 영역의 복사본으로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="e9d9039bee56c9dff367db5db3ac501d7692cf55" translate="yes" xml:space="preserve">
          <source>Each variable name may be postfixed by an attribute (a name between angle brackets):</source>
          <target state="translated">각 변수 이름은 속성 (꺾쇠 괄호 사이의 이름)으로 뒤에 붙을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0667e652664cd1df4e1207278c25e646648c5640" translate="yes" xml:space="preserve">
          <source>Emits a warning with a message composed by the concatenation of all its arguments (which should be strings).</source>
          <target state="translated">모든 인수 (문자열이어야 함)를 연결하여 구성된 메시지로 경고를 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="f33e48b8cc5703ec215b544663c0ef8acefbf248" translate="yes" xml:space="preserve">
          <source>Emits a warning with the given message. A message in a call with &lt;code&gt;tocont&lt;/code&gt; true should be continued in another call to this function.</source>
          <target state="translated">주어진 메시지와 함께 경고를 내 보냅니다. &lt;code&gt;tocont&lt;/code&gt; true 를 사용한 호출의 메시지는 이 함수에 대한 다른 호출에서 계속되어야합니다.</target>
        </trans-unit>
        <trans-unit id="3be0ef9871b5f19e17f15ac19ff4343a0cff10de" translate="yes" xml:space="preserve">
          <source>Ensures that the stack has space for at least &lt;code&gt;n&lt;/code&gt; extra elements, that is, that you can safely push up to &lt;code&gt;n&lt;/code&gt; values into it. It returns false if it cannot fulfill the request, either because it would cause the stack to be greater than a fixed maximum size (typically at least several thousand elements) or because it cannot allocate memory for the extra space. This function never shrinks the stack; if the stack already has space for the extra elements, it is left unchanged.</source>
          <target state="translated">스택에 최소 &lt;code&gt;n&lt;/code&gt; 개의 추가 요소를 위한 공간 이 있는지 확인합니다. 즉, &lt;code&gt;n&lt;/code&gt; 개의 값을 안전하게 푸시 할 수 있습니다 . 스택이 고정 된 최대 크기 (일반적으로 최소 수천 개의 요소)보다 커지거나 추가 공간에 메모리를 할당 할 수 없기 때문에 요청을 수행 할 수없는 경우 false를 반환합니다. 이 함수는 스택을 축소하지 않습니다. 스택에 추가 요소를위한 공간이 이미있는 경우 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="724adec43f3df4f9471590e57b3efefd102497cf" translate="yes" xml:space="preserve">
          <source>Ensures that the stack has space for at least &lt;code&gt;n&lt;/code&gt; extra slots (that is, that you can safely push up to &lt;code&gt;n&lt;/code&gt; values into it). It returns false if it cannot fulfill the request, either because it would cause the stack to be larger than a fixed maximum size (typically at least several thousand elements) or because it cannot allocate memory for the extra space. This function never shrinks the stack; if the stack already has space for the extra slots, it is left unchanged.</source>
          <target state="translated">스택에 최소 &lt;code&gt;n&lt;/code&gt; 개의 추가 슬롯을 위한 공간이 있는지 확인 합니다 (즉, &lt;code&gt;n&lt;/code&gt; 개의 값 까지 안전하게 푸시 할 수 있음). 스택이 고정 된 최대 크기보다 크거나 (일반적으로 수천 개 이상의 요소) 추가 공간에 메모리를 할당 할 수 없기 때문에 요청을 이행 할 수 없으면 false를 리턴합니다. 이 함수는 스택을 축소하지 않습니다. 스택에 이미 추가 슬롯을위한 공간이 있으면 변경되지 않은 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="94cdd3c18c2b4719474c53fa6f1b9fb02152a15d" translate="yes" xml:space="preserve">
          <source>Ensures that the value &lt;code&gt;t[fname]&lt;/code&gt;, where &lt;code&gt;t&lt;/code&gt; is the value at index &lt;code&gt;idx&lt;/code&gt;, is a table, and pushes that table onto the stack. Returns true if it finds a previous table there and false if it creates a new table.</source>
          <target state="translated">&lt;code&gt;t[fname]&lt;/code&gt; 값 ( 여기서 &lt;code&gt;t&lt;/code&gt; 는 index &lt;code&gt;idx&lt;/code&gt; 의 값임 )이 테이블인지 확인하고 해당 테이블을 스택으로 푸시합니다. 이전 테이블을 찾으면 true를, 새 테이블을 만들면 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d2187e2e8c84822845af903355cda0cd820011ab" translate="yes" xml:space="preserve">
          <source>Enters an interactive mode with the user, running each string that the user enters. Using simple commands and other debug facilities, the user can inspect global and local variables, change their values, evaluate expressions, and so on. A line containing only the word &lt;code&gt;cont&lt;/code&gt; finishes this function, so that the caller continues its execution.</source>
          <target state="translated">사용자가 입력 한 각 문자열을 실행하여 사용자와 대화식 모드를 시작합니다. 간단한 명령 및 기타 디버그 기능을 사용하여 전역 및 로컬 변수를 검사하고 값을 변경하고 표현식을 평가하는 등의 작업을 수행 할 수 있습니다. &lt;code&gt;cont&lt;/code&gt; 단어 만 포함 된 행은 이 기능을 완료하므로 호출자가 계속 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="4bc7c25b89d339e7967419718f888c8e7706661a" translate="yes" xml:space="preserve">
          <source>Environments and the Global Environment</source>
          <target state="translated">환경과 지구 환경</target>
        </trans-unit>
        <trans-unit id="911d3f66ebade1de45eca3fa1b80cbca2b45963a" translate="yes" xml:space="preserve">
          <source>Equality (&lt;code&gt;==&lt;/code&gt;) first compares the type of its operands. If the types are different, then the result is &lt;b&gt;false&lt;/b&gt;. Otherwise, the values of the operands are compared. Strings are compared in the obvious way. Numbers are equal if they denote the same mathematical value.</source>
          <target state="translated">같음 ( &lt;code&gt;==&lt;/code&gt; )은 먼저 피연산자의 유형을 비교합니다. 유형이 다르면 결과는 &lt;b&gt;false&lt;/b&gt; 입니다. 그렇지 않으면 피연산자의 값이 비교됩니다. 문자열은 명백한 방식으로 비교됩니다. 동일한 수학적 값을 나타내면 숫자가 동일합니다.</target>
        </trans-unit>
        <trans-unit id="7ce354bf488d1a0add3dbce3df2fdb2d17bd01c3" translate="yes" xml:space="preserve">
          <source>Equality (&lt;code&gt;==&lt;/code&gt;) first compares the type of its operands. If the types are different, then the result is &lt;b&gt;false&lt;/b&gt;. Otherwise, the values of the operands are compared. Strings are equal if they have the same byte content. Numbers are equal if they denote the same mathematical value.</source>
          <target state="translated">Equality ( &lt;code&gt;==&lt;/code&gt; )는 먼저 피연산자의 유형을 비교합니다. 유형이 다르면 결과는 &lt;b&gt;false&lt;/b&gt; 입니다. 그렇지 않으면 피연산자의 값이 비교됩니다. 동일한 바이트 내용이있는 문자열은 동일합니다. 동일한 수학적 값을 나타내는 숫자는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="8bba7708d9cd62b79eff18edb05f15a66e6e4fc3" translate="yes" xml:space="preserve">
          <source>Equality comparisons do not convert strings to numbers or vice versa. Thus, &lt;code&gt;&quot;0&quot;==0&lt;/code&gt; evaluates to &lt;b&gt;false&lt;/b&gt;, and &lt;code&gt;t[0]&lt;/code&gt; and &lt;code&gt;t[&quot;0&quot;]&lt;/code&gt; denote different entries in a table.</source>
          <target state="translated">평등 비교는 문자열을 숫자로 또는 그 반대로 변환하지 않습니다. 따라서 &lt;code&gt;&quot;0&quot;==0&lt;/code&gt; 은 &lt;b&gt;false로&lt;/b&gt; 평가 되고 &lt;code&gt;t[0]&lt;/code&gt; 및 &lt;code&gt;t[&quot;0&quot;]&lt;/code&gt; 은 테이블에서 다른 항목을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="eeb6206afe341a7d07c673213b74b2763b8aad8a" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;#luaL_loadbufferx&quot;&gt;&lt;code&gt;luaL_loadbufferx&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;mode&lt;/code&gt; equal to &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">동등 &lt;a href=&quot;#luaL_loadbufferx&quot;&gt; &lt;code&gt;luaL_loadbufferx&lt;/code&gt; &lt;/a&gt; 과 &lt;code&gt;mode&lt;/code&gt; 동일 &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c5ac0bf4ab4157c76c5229bc6b001f02e1bbdbe" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;#luaL_loadfilex&quot;&gt;&lt;code&gt;luaL_loadfilex&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;mode&lt;/code&gt; equal to &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">동등 &lt;a href=&quot;#luaL_loadfilex&quot;&gt; &lt;code&gt;luaL_loadfilex&lt;/code&gt; &lt;/a&gt; 과 &lt;code&gt;mode&lt;/code&gt; 동일 &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="417f3cabd0ae3b21c9200dade7625b6b803e2a8a" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;#luaL_prepbuffsize&quot;&gt;&lt;code&gt;luaL_prepbuffsize&lt;/code&gt;&lt;/a&gt; with the predefined size &lt;a id=&quot;pdf-LUAL_BUFFERSIZE&quot;&gt;&lt;code&gt;LUAL_BUFFERSIZE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">상당 &lt;a href=&quot;#luaL_prepbuffsize&quot;&gt; &lt;code&gt;luaL_prepbuffsize&lt;/code&gt; &lt;/a&gt; 사전 정의 된 크기와 &lt;a id=&quot;pdf-LUAL_BUFFERSIZE&quot;&gt; &lt;code&gt;LUAL_BUFFERSIZE&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3bdbca26c05283a107728b580733fbf5005aa002" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;#lua_pushfstring&quot;&gt;&lt;code&gt;lua_pushfstring&lt;/code&gt;&lt;/a&gt;, except that it receives a &lt;code&gt;va_list&lt;/code&gt; instead of a variable number of arguments.</source>
          <target state="translated">동등 &lt;a href=&quot;#lua_pushfstring&quot;&gt; &lt;code&gt;lua_pushfstring&lt;/code&gt; &lt;/a&gt; , 그것이 수신하는 것을 제외하고 &lt;code&gt;va_list&lt;/code&gt; 대신 가변 인자 참조.</target>
        </trans-unit>
        <trans-unit id="048179e8ca8eda05fb0bd3fd434b84a3be42d2f7" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;#lua_tointegerx&quot;&gt;&lt;code&gt;lua_tointegerx&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;isnum&lt;/code&gt; equal to &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">등가 &lt;a href=&quot;#lua_tointegerx&quot;&gt; &lt;code&gt;lua_tointegerx&lt;/code&gt; &lt;/a&gt; 으로 &lt;code&gt;isnum&lt;/code&gt; 는 동일 &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3eea1358153e9600e250e3541353b60210297af9" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;#lua_tolstring&quot;&gt;&lt;code&gt;lua_tolstring&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;len&lt;/code&gt; equal to &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">동등 &lt;a href=&quot;#lua_tolstring&quot;&gt; &lt;code&gt;lua_tolstring&lt;/code&gt; &lt;/a&gt; 와 &lt;code&gt;len&lt;/code&gt; 동일 &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="859cc0dd8a506649ee3ce18e480ee774adf2690e" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;#lua_tonumberx&quot;&gt;&lt;code&gt;lua_tonumberx&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;isnum&lt;/code&gt; equal to &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">등가 &lt;a href=&quot;#lua_tonumberx&quot;&gt; &lt;code&gt;lua_tonumberx&lt;/code&gt; &lt;/a&gt; 으로 &lt;code&gt;isnum&lt;/code&gt; 는 동일 &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f10e3538e7d3cff0cc3010f6eafa5510d5b4eabf" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;file:close()&lt;/code&gt;. Without a &lt;code&gt;file&lt;/code&gt;, closes the default output file.</source>
          <target state="translated">&lt;code&gt;file:close()&lt;/code&gt; 와 같습니다 . &lt;code&gt;file&lt;/code&gt; 없으면 기본 출력 파일을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="47bb85f8430ddf2501d6a1df9b4dd575ae0b94f6" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;io.input():read(&amp;middot;&amp;middot;&amp;middot;)&lt;/code&gt;.</source>
          <target state="translated">등가 &lt;code&gt;io.input():read(&amp;middot;&amp;middot;&amp;middot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b236c5a9b8def03419e72a62b54cf06568e7ac12" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;io.output():flush()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;io.output():flush()&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="f4a16ee993787daf20f8abfd04e25a53a52555ae" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;io.output():write(&amp;middot;&amp;middot;&amp;middot;)&lt;/code&gt;.</source>
          <target state="translated">등가 &lt;code&gt;io.output():write(&amp;middot;&amp;middot;&amp;middot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="95841ee72cef3e69b1415de06e904a02c3a22ad7" translate="yes" xml:space="preserve">
          <source>Equivalent to the sequence &lt;a href=&quot;#luaL_addsize&quot;&gt;&lt;code&gt;luaL_addsize&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#luaL_pushresult&quot;&gt;&lt;code&gt;luaL_pushresult&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#luaL_addsize&quot;&gt; &lt;code&gt;luaL_addsize&lt;/code&gt; &lt;/a&gt; 시퀀스 luaL_pushresult 와 &lt;a href=&quot;#luaL_pushresult&quot;&gt; &lt;code&gt;luaL_pushresult&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9a9197bd8cc7210e1d081737ce79a0004c900ea5" translate="yes" xml:space="preserve">
          <source>Equivalent to the sequence &lt;a href=&quot;#luaL_buffinit&quot;&gt;&lt;code&gt;luaL_buffinit&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#luaL_prepbuffsize&quot;&gt;&lt;code&gt;luaL_prepbuffsize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">시퀀스 &lt;a href=&quot;#luaL_buffinit&quot;&gt; &lt;code&gt;luaL_buffinit&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#luaL_prepbuffsize&quot;&gt; &lt;code&gt;luaL_prepbuffsize&lt;/code&gt; &lt;/a&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="5fff1f56919b006049c274c6c76fbbe56470ee4c" translate="yes" xml:space="preserve">
          <source>Error Handling</source>
          <target state="translated">오류 처리</target>
        </trans-unit>
        <trans-unit id="efce06d9e3b29a083012c673a0d05df2af20d9a0" translate="yes" xml:space="preserve">
          <source>Even when we use the term &quot;function&quot;, any facility in the API may be provided as a macro instead. Except where stated otherwise, all such macros use each of their arguments exactly once (except for the first argument, which is always a Lua state), and so do not generate any hidden side-effects.</source>
          <target state="translated">&quot;함수&quot;라는 용어를 사용하더라도 API의 모든 기능은 매크로로 제공 될 수 있습니다. 달리 언급 된 경우를 제외하고, 이러한 모든 매크로는 각 인수를 정확히 한 번만 사용하므로 (항상 루아 상태 인 첫 번째 인수는 제외) 숨겨진 부작용을 발생시키지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8b0fc04bd9046928072da89380d0ae2b41ea04f1" translate="yes" xml:space="preserve">
          <source>Every value in Lua can have a &lt;em&gt;metatable&lt;/em&gt;. This &lt;em&gt;metatable&lt;/em&gt; is an ordinary Lua table that defines the behavior of the original value under certain events. You can change several aspects of the behavior of a value by setting specific fields in its metatable. For instance, when a non-numeric value is the operand of an addition, Lua checks for a function in the field &quot;&lt;code&gt;__add&lt;/code&gt;&quot; of the value's metatable. If it finds one, Lua calls this function to perform the addition.</source>
          <target state="translated">Lua의 모든 값은 &lt;em&gt;메타 테이블을&lt;/em&gt; 가질 수 있습니다 . 이 &lt;em&gt;메타 테이블&lt;/em&gt; 은 특정 이벤트에서 원래 값의 동작을 정의하는 일반 Lua 테이블입니다. 메타 테이블에서 특정 필드를 설정하여 값 동작의 여러 측면을 변경할 수 있습니다. 예를 들어 숫자가 아닌 값이 더하기의 피연산자 일 때 Lua는 값의 메타 테이블의 &quot; &lt;code&gt;__add&lt;/code&gt; &quot; 필드에서 함수를 확인합니다 . 하나를 찾으면 Lua는이 함수를 호출하여 추가를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="876b22e6469bec417ede0947f746abdd3c61cdc3" translate="yes" xml:space="preserve">
          <source>Every value in Lua can have a &lt;em&gt;metatable&lt;/em&gt;. This &lt;em&gt;metatable&lt;/em&gt; is an ordinary Lua table that defines the behavior of the original value under certain special operations. You can change several aspects of the behavior of operations over a value by setting specific fields in its metatable. For instance, when a non-numeric value is the operand of an addition, Lua checks for a function in the field &quot;&lt;code&gt;__add&lt;/code&gt;&quot; of the value's metatable. If it finds one, Lua calls this function to perform the addition.</source>
          <target state="translated">Lua의 모든 값은 &lt;em&gt;메타 테이블을&lt;/em&gt; 가질 수 있습니다 . 이 &lt;em&gt;메타 테이블&lt;/em&gt; 은 특정 특수 작업에서 원래 값의 동작을 정의하는 일반 Lua 테이블입니다. 메타 테이블에서 특정 필드를 설정하여 값에 대한 조작 동작의 여러 측면을 변경할 수 있습니다. 예를 들어, 숫자가 아닌 값이 덧셈의 피연산자 인 경우 Lua는 값의 메타 테이블 &quot; &lt;code&gt;__add&lt;/code&gt; &quot; 필드에서 함수를 확인합니다 . 하나를 찾으면 Lua는이 함수를 호출하여 추가를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="34fb3456225dbfac064754a0c940e7ab97d70dab" translate="yes" xml:space="preserve">
          <source>Examples of valid float constants are</source>
          <target state="translated">유효한 float 상수의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bbe7dddfbe009d74560c9fb2bc36df0adb3cf044" translate="yes" xml:space="preserve">
          <source>Examples of valid integer constants are</source>
          <target state="translated">유효한 정수 상수의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dc9054ac99639aca0dedbf9ce85be2d8cb078353" translate="yes" xml:space="preserve">
          <source>Except for the basic and the package libraries, each library provides all its functions as fields of a global table or as methods of its objects.</source>
          <target state="translated">기본 및 패키지 라이브러리를 제외하고 각 라이브러리는 모든 기능을 글로벌 테이블의 필드 또는 객체의 메소드로 제공합니다.</target>
        </trans-unit>
        <trans-unit id="36df5e76b9e2376e585d0d88a013dd481aa092f2" translate="yes" xml:space="preserve">
          <source>Except for these guarantees, the garbage collector is free to invalidate any pointer to internal strings.</source>
          <target state="translated">이러한 보장을 제외하고 가비지 수집기는 내부 문자열에 대한 포인터를 자유롭게 무효화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a454333e5ab07af66349fc9dcc89eefc63ffc046" translate="yes" xml:space="preserve">
          <source>Exchange values between different threads of the same state.</source>
          <target state="translated">동일한 상태의 다른 스레드간에 값을 교환하십시오.</target>
        </trans-unit>
        <trans-unit id="8a70a348295e730e4d487448d5bdfd5d0a1f52d4" translate="yes" xml:space="preserve">
          <source>Explicit blocks are useful to control the scope of variable declarations. Explicit blocks are also sometimes used to add a &lt;b&gt;return&lt;/b&gt; statement in the middle of another block (see &lt;a href=&quot;#3.3.4&quot;&gt;&amp;sect;3.3.4&lt;/a&gt;).</source>
          <target state="translated">명시 적 블록은 변수 선언의 범위를 제어하는 ​​데 유용합니다. 명시 적 블록은 다른 블록의 중간에 &lt;b&gt;return&lt;/b&gt; 문 을 추가하는 데 사용되기도합니다 ( &lt;a href=&quot;#3.3.4&quot;&gt;&amp;sect;3.3.4&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="6068d6a6087004b84e19a26f762381a6d306ebf7" translate="yes" xml:space="preserve">
          <source>Exponentiation and float division (&lt;code&gt;/&lt;/code&gt;) always convert their operands to floats and the result is always a float. Exponentiation uses the ISO C function &lt;code&gt;pow&lt;/code&gt;, so that it works for non-integer exponents too.</source>
          <target state="translated">지수와 부동 소수점 나누기 ( &lt;code&gt;/&lt;/code&gt; )는 항상 피연산자를 부동 소수점으로 변환하며 결과는 항상 부동 소수점입니다. 지수화는 ISO C 함수 &lt;code&gt;pow&lt;/code&gt; 를 사용하므로 정수가 아닌 지수에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="ae5fccd8dcd8fc317f8edfc8259af86cd2967a29" translate="yes" xml:space="preserve">
          <source>Expressions</source>
          <target state="translated">Expressions</target>
        </trans-unit>
        <trans-unit id="3403002da8268dbb07086fbb61ed468d09402d3c" translate="yes" xml:space="preserve">
          <source>Expressions are discussed in &lt;a href=&quot;#3.4&quot;&gt;&amp;sect;3.4&lt;/a&gt;.</source>
          <target state="translated">표현은 &lt;a href=&quot;#3.4&quot;&gt;&amp;sect;3.4&lt;/a&gt; 에서 논의된다 .</target>
        </trans-unit>
        <trans-unit id="b900d18f3b16f1700e6e2ba6ff4f8eb135f2fffe" translate="yes" xml:space="preserve">
          <source>Finalizers cannot yield. Except for that, they can do anything, such as raise errors, create new objects, or even run the garbage collector. However, because they can run in unpredictable times, it is good practice to restrict each finalizer to the minimum necessary to properly release its associated resource.</source>
          <target state="translated">종료자는 양보 할 수 없습니다. 그 외에는 오류 발생, 새 개체 생성, 가비지 수집기 실행 등 모든 작업을 수행 할 수 있습니다. 그러나 예측할 수없는 시간에 실행될 수 있으므로 관련 리소스를 적절하게 해제하는 데 필요한 최소 수준으로 각 종료자를 제한하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="952220342168dc20bbaf6ee3888975552b5929df" translate="yes" xml:space="preserve">
          <source>Finish by calling &lt;code&gt;luaL_pushresult(&amp;amp;b)&lt;/code&gt;. This call leaves the final string on the top of the stack.</source>
          <target state="translated">&lt;code&gt;luaL_pushresult(&amp;amp;b)&lt;/code&gt; 를 호출하여 완료하십시오 . 이 호출은 스택 맨 위에 최종 문자열을 남깁니다.</target>
        </trans-unit>
        <trans-unit id="670400b569fd752b91bcbce8ea30c99ca0c5d950" translate="yes" xml:space="preserve">
          <source>Finish by calling &lt;code&gt;luaL_pushresultsize(&amp;amp;b, sz)&lt;/code&gt;, where &lt;code&gt;sz&lt;/code&gt; is the total size of the resulting string copied into that space (which may be less than or equal to the preallocated size).</source>
          <target state="translated">&lt;code&gt;luaL_pushresultsize(&amp;amp;b, sz)&lt;/code&gt; 를 호출하여 완료합니다 . 여기서 &lt;code&gt;sz&lt;/code&gt; 는 해당 공간에 복사 된 결과 문자열의 총 크기입니다 (사전 할당 된 크기보다 작거나 같을 수 있음).</target>
        </trans-unit>
        <trans-unit id="e24c3abeab89141035172a8f0844d2e645ae86bc" translate="yes" xml:space="preserve">
          <source>Finish by calling &lt;code&gt;luaL_pushresultsize(&amp;amp;b, sz)&lt;/code&gt;, where &lt;code&gt;sz&lt;/code&gt; is the total size of the resulting string copied into that space.</source>
          <target state="translated">&lt;code&gt;luaL_pushresultsize(&amp;amp;b, sz)&lt;/code&gt; 를 호출하여 완료 . 여기서 &lt;code&gt;sz&lt;/code&gt; 는 해당 공간에 복사 된 결과 문자열의 전체 크기입니다.</target>
        </trans-unit>
        <trans-unit id="fa1b0bd32568564210439e9f8bbb29579af4e8f6" translate="yes" xml:space="preserve">
          <source>Finishes the use of buffer &lt;code&gt;B&lt;/code&gt; leaving the final string on the top of the stack.</source>
          <target state="translated">버퍼 사용 완료 &lt;code&gt;B&lt;/code&gt; 최종 문자열을 스택 맨 위에 둡니다.</target>
        </trans-unit>
        <trans-unit id="9581cd1476458beea36edaaa1aab1a70ddd9b799" translate="yes" xml:space="preserve">
          <source>First &lt;code&gt;require&lt;/code&gt; queries &lt;code&gt;package.preload[modname]&lt;/code&gt;. If it has a value, this value (which must be a function) is the loader. Otherwise &lt;code&gt;require&lt;/code&gt; searches for a Lua loader using the path stored in &lt;a href=&quot;#pdf-package.path&quot;&gt;&lt;code&gt;package.path&lt;/code&gt;&lt;/a&gt;. If that also fails, it searches for a C loader using the path stored in &lt;a href=&quot;#pdf-package.cpath&quot;&gt;&lt;code&gt;package.cpath&lt;/code&gt;&lt;/a&gt;. If that also fails, it tries an &lt;em&gt;all-in-one&lt;/em&gt; loader (see &lt;a href=&quot;#pdf-package.searchers&quot;&gt;&lt;code&gt;package.searchers&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">먼저 &lt;code&gt;package.preload[modname]&lt;/code&gt; 쿼리가 &lt;code&gt;require&lt;/code&gt; 합니다 . 값이 있으면이 값 (함수 여야 함)이 로더입니다. 그렇지 않으면 &lt;a href=&quot;#pdf-package.path&quot;&gt; &lt;code&gt;package.path&lt;/code&gt; 에&lt;/a&gt; 저장된 경로를 사용하여 Lua 로더를 검색 &lt;code&gt;require&lt;/code&gt; 합니다 . 이것도 실패하면 &lt;a href=&quot;#pdf-package.cpath&quot;&gt; &lt;code&gt;package.cpath&lt;/code&gt; 에&lt;/a&gt; 저장된 경로를 사용하여 C 로더를 검색 합니다 . 그래도 실패하면 &lt;em&gt;복합기&lt;/em&gt; 로더를 시도합니다 (참조&lt;em&gt;&lt;/em&gt;&lt;a href=&quot;#pdf-package.searchers&quot;&gt; &lt;code&gt;package.searchers&lt;/code&gt; &lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="cf6993356b76fa41b8a9a12311a4583412cacf12" translate="yes" xml:space="preserve">
          <source>First declare a variable &lt;code&gt;b&lt;/code&gt; of type &lt;a href=&quot;#luaL_Buffer&quot;&gt;&lt;code&gt;luaL_Buffer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">먼저 유형 &lt;code&gt;b&lt;/code&gt; 의 변수 b 를 선언하십시오.&lt;a href=&quot;#luaL_Buffer&quot;&gt; &lt;code&gt;luaL_Buffer&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="b612f7a5723bf19c46b295718acbab9a0f0352e8" translate="yes" xml:space="preserve">
          <source>Floor division (&lt;code&gt;//&lt;/code&gt;) is a division that rounds the quotient towards minus infinity, resulting in the floor of the division of its operands.</source>
          <target state="translated">바닥 나누기 ( &lt;code&gt;//&lt;/code&gt; )는 몫을 마이너스 무한대로 반올림하여 피연산자 나누기의 바닥이되는 나누기입니다.</target>
        </trans-unit>
        <trans-unit id="b2d47a74b914f2999fca9d267f869c38ca08b9e6" translate="yes" xml:space="preserve">
          <source>Floor division (&lt;code&gt;//&lt;/code&gt;) is a division that rounds the quotient towards minus infinity, that is, the floor of the division of its operands.</source>
          <target state="translated">층 구분 ( &lt;code&gt;//&lt;/code&gt; )는 몫을 빼기 무한대, 즉 피연산자의 나누기 바닥으로 반올림하는 나눗셈입니다.</target>
        </trans-unit>
        <trans-unit id="9578580e96abd6dc66d3f4a9ec50cb8852f521d3" translate="yes" xml:space="preserve">
          <source>Following the IEEE 754 standard, NaN is considered neither smaller than, nor equal to, nor greater than any value (including itself).</source>
          <target state="translated">IEEE 754 표준에 따라 NaN은 임의의 값 (자체 포함)보다 작거나 같거나 크지 않은 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="d39e6b7dbac19bdb82dc3bde1e716ea23dd45ecc" translate="yes" xml:space="preserve">
          <source>Following the IEEE 754 standard, the special value NaN is considered neither less than, nor equal to, nor greater than any value, including itself.</source>
          <target state="translated">IEEE 754 표준에 따라 특수 값 NaN은 자신을 포함하여 어떤 값보다 작거나 같거나 크지 않은 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="43e9fd5a8e55921ad3d74bebecaa1afe7054a8ef" translate="yes" xml:space="preserve">
          <source>For C functions, this function uses the empty string &lt;code&gt;&quot;&quot;&lt;/code&gt; as a name for all upvalues.</source>
          <target state="translated">C 함수의 경우이 함수는 모든 upvalue의 이름으로 빈 문자열 &lt;code&gt;&quot;&quot;&lt;/code&gt; 을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="7968a691f0ed611daf368a38173ca221f41fe6c2" translate="yes" xml:space="preserve">
          <source>For C functions, this function uses the empty string &lt;code&gt;&quot;&quot;&lt;/code&gt; as a name for all upvalues. (For Lua functions, upvalues are the external local variables that the function uses, and that are consequently included in its closure.)</source>
          <target state="translated">C 함수의 경우이 함수는 빈 문자열을 사용합니다. &lt;code&gt;&quot;&quot;&lt;/code&gt; 을 모든 상위 값의 이름으로 사용합니다. (루아 함수의 경우, 상향 값은 함수가 사용하고 결과적으로 폐쇄에 포함되는 외부 로컬 변수입니다.)</target>
        </trans-unit>
        <trans-unit id="826bad097a9af03241478f133b816c28a093c4ff" translate="yes" xml:space="preserve">
          <source>For Statement</source>
          <target state="translated">성명</target>
        </trans-unit>
        <trans-unit id="232d13ae76c1a448a0dbe30fce0093b7011c947c" translate="yes" xml:space="preserve">
          <source>For all classes represented by single letters (&lt;code&gt;%a&lt;/code&gt;, &lt;code&gt;%c&lt;/code&gt;, etc.), the corresponding uppercase letter represents the complement of the class. For instance, &lt;code&gt;%S&lt;/code&gt; represents all non-space characters.</source>
          <target state="translated">단일 문자 ( &lt;code&gt;%a&lt;/code&gt; , &lt;code&gt;%c&lt;/code&gt; 등)로 표시되는 모든 클래스의 경우 해당 대문자는 클래스의 보수를 나타냅니다. 예를 들어 &lt;code&gt;%S&lt;/code&gt; 는 공백이 아닌 모든 문자를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b277899f2ddc10d7e3dad8301744987f188c3222" translate="yes" xml:space="preserve">
          <source>For an object (table or userdata) to be finalized when collected, you must &lt;em&gt;mark&lt;/em&gt; it for finalization. You mark an object for finalization when you set its metatable and the metatable has a field indexed by the string &quot;&lt;code&gt;__gc&lt;/code&gt;&quot;. Note that if you set a metatable without a &lt;code&gt;__gc&lt;/code&gt; field and later create that field in the metatable, the object will not be marked for finalization.</source>
          <target state="translated">개체 (테이블 또는 사용자 데이터)를 수집 할 때 마무리하려면 마무리로 &lt;em&gt;표시&lt;/em&gt; 해야합니다 . 메타 테이블을 설정하고 메타 테이블에 문자열 &quot; &lt;code&gt;__gc&lt;/code&gt; &quot;로 색인 된 필드가있는 경우 오브젝트를 완료로 표시합니다 . &lt;code&gt;__gc&lt;/code&gt; 없이 메타 테이블을 설정하면 필드 후 나중에 메타 테이블에서 해당 필드를 만들면 개체가 마무리 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="21127f5444f9175d599260124aacb43b3cb15bde" translate="yes" xml:space="preserve">
          <source>For call events, &lt;code&gt;event&lt;/code&gt; can be &lt;code&gt;LUA_HOOKCALL&lt;/code&gt;, the normal value, or &lt;code&gt;LUA_HOOKTAILCALL&lt;/code&gt;, for a tail call; in this case, there will be no corresponding return event.</source>
          <target state="translated">통화 이벤트의 경우 &lt;code&gt;event&lt;/code&gt; 는 &lt;code&gt;LUA_HOOKCALL&lt;/code&gt; , 일반 값 또는 &lt;code&gt;LUA_HOOKTAILCALL&lt;/code&gt; 일 수 있습니다. 꼬리 호출; 이 경우 해당 리턴 이벤트가 없습니다.</target>
        </trans-unit>
        <trans-unit id="8a923a874466c00de43a4442ce2de3d1c4f3b26b" translate="yes" xml:space="preserve">
          <source>For compatibility, the old names still work as macros assuming one single user value. Note, however, that userdata with zero user values are more efficient memory-wise.</source>
          <target state="translated">호환성을 위해 이전 이름은 단일 사용자 값을 가정하는 매크로로 계속 작동합니다. 그러나 사용자 값이 0 인 사용자 데이터는 메모리 측면에서 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="2a7148362f69bffc94f20dd8e3caacb347b05e34" translate="yes" xml:space="preserve">
          <source>For complete control of how numbers are converted, use &lt;a href=&quot;#pdf-string.format&quot;&gt;&lt;code&gt;string.format&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">숫자 변환 방법을 완전히 제어하려면 &lt;a href=&quot;#pdf-string.format&quot;&gt; &lt;code&gt;string.format&lt;/code&gt; 을&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="ef19782c3b513548f8d3e4e46e68c607de619e6c" translate="yes" xml:space="preserve">
          <source>For convenience, most query operations in the API do not follow a strict stack discipline. Instead, they can refer to any element in the stack by using an &lt;em&gt;index&lt;/em&gt;: A positive index represents an absolute stack position (starting at 1); a negative index represents an offset relative to the top of the stack. More specifically, if the stack has &lt;em&gt;n&lt;/em&gt; elements, then index 1 represents the first element (that is, the element that was pushed onto the stack first) and index &lt;em&gt;n&lt;/em&gt; represents the last element; index -1 also represents the last element (that is, the element at the top) and index &lt;em&gt;-n&lt;/em&gt; represents the first element.</source>
          <target state="translated">편의상 API의 대부분의 쿼리 작업은 엄격한 스택 규칙을 따르지 않습니다. 대신 &lt;em&gt;인덱스&lt;/em&gt; 를 사용하여 스택의 모든 요소를 ​​참조 할 수 있습니다 . 양의 인덱스는 절대 스택 위치 (1부터 시작)를 나타냅니다. 음수 인덱스는 스택 맨 위의 오프셋을 나타냅니다. 보다 구체적으로, 스택이 &lt;em&gt;n 개의&lt;/em&gt; 요소를 갖는 경우, 인덱스 1은 첫 번째 요소 (즉, 스택으로 먼저 푸시 된 요소)를 나타내고 인덱스 &lt;em&gt;n&lt;/em&gt; 은 마지막 요소를 나타내고; 인덱스 -1은 또한 마지막 요소 (즉, 맨 위에있는 요소)와 인덱스 &lt;em&gt;-n을&lt;/em&gt; 나타냅니다.&lt;em&gt;&lt;/em&gt; 나타내고 은 첫 번째 요소를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7045093cbdc1f5ddefba6dd2df77ec7c61d8c223" translate="yes" xml:space="preserve">
          <source>For convenience, most query operations in the API do not follow a strict stack discipline. Instead, they can refer to any element in the stack by using an &lt;em&gt;index&lt;/em&gt;: A positive index represents an absolute stack position, starting at 1 as the bottom of the stack; a negative index represents an offset relative to the top of the stack. More specifically, if the stack has &lt;em&gt;n&lt;/em&gt; elements, then index 1 represents the first element (that is, the element that was pushed onto the stack first) and index &lt;em&gt;n&lt;/em&gt; represents the last element; index -1 also represents the last element (that is, the element at the top) and index &lt;em&gt;-n&lt;/em&gt; represents the first element.</source>
          <target state="translated">편의를 위해 API의 대부분의 쿼리 작업은 엄격한 스택 규칙을 따르지 않습니다. 대신 &lt;em&gt;인덱스&lt;/em&gt; 를 사용하여 스택의 모든 요소를 ​​참조 할 수 있습니다 . 양수 인덱스는 스택의 맨 아래로 1에서 시작하는 절대 스택 위치를 나타냅니다. 음수 인덱스는 스택 상단에 상대적인 오프셋을 나타냅니다. 보다 구체적으로, 스택에 &lt;em&gt;n 개의&lt;/em&gt; 요소가있는 경우 인덱스 1은 첫 번째 요소 (즉, 스택에 먼저 푸시 된 요소)를 나타내고 인덱스 &lt;em&gt;n&lt;/em&gt; 은 마지막 요소를 나타냅니다. index -1은 또한 마지막 요소 (즉, 맨 위의 요소)를 나타내고 index &lt;em&gt;-n&lt;/em&gt; 은 첫 번째 요소를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e8e7817ee2d33410b37da66bff2f4abc60fd9f19" translate="yes" xml:space="preserve">
          <source>For convenience, when the opening long bracket is immediately followed by a newline, the newline is not included in the string. As an example, in a system using ASCII (in which '&lt;code&gt;a&lt;/code&gt;' is coded as 97, newline is coded as 10, and '&lt;code&gt;1&lt;/code&gt;' is coded as 49), the five literal strings below denote the same string:</source>
          <target state="translated">편의상 여는 긴 괄호 바로 뒤에 개행 문자가 있으면 개행 문자가 문자열에 포함되지 않습니다. 예를 들어 ASCII를 사용하는 시스템 ( ' &lt;code&gt;a&lt;/code&gt; '가 97로 코딩되고 줄 바꿈이 10으로 코딩되고 ' &lt;code&gt;1&lt;/code&gt; '이 49로 코딩 됨)을 사용하는 시스템에서 아래 5 개의 리터럴 문자열은 동일한 문자열을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c75b8f31dba0d91bae695aa013d0381fc16c8094" translate="yes" xml:space="preserve">
          <source>For functions that can be called with acceptable indices, any non-valid index is treated as if it contains a value of a virtual type &lt;a id=&quot;pdf-LUA_TNONE&quot;&gt;&lt;code&gt;LUA_TNONE&lt;/code&gt;&lt;/a&gt;, which behaves like a nil value.</source>
          <target state="translated">허용 가능한 인덱스로 호출 할 수있는 함수의 경우, 유효하지 않은 인덱스는 가상 유형 &lt;a id=&quot;pdf-LUA_TNONE&quot;&gt; &lt;code&gt;LUA_TNONE&lt;/code&gt; &lt;/a&gt; 의 값을 포함하는 것처럼 취급되며 이는 nil 값처럼 동작합니다.</target>
        </trans-unit>
        <trans-unit id="a31447203fafe5a4da4338521a4a4fb721154e10" translate="yes" xml:space="preserve">
          <source>For instance, if the path is the string</source>
          <target state="translated">예를 들어 경로가 문자열 인 경우</target>
        </trans-unit>
        <trans-unit id="ea7d77d2e3991db06f939eac321dd577052affc3" translate="yes" xml:space="preserve">
          <source>For instance, the expression &lt;code&gt;debug.getinfo(1,&quot;n&quot;).name&lt;/code&gt; returns a name for the current function, if a reasonable name can be found, and the expression &lt;code&gt;debug.getinfo(print)&lt;/code&gt; returns a table with all available information about the &lt;a href=&quot;#pdf-print&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">예를 들어, 식 &lt;code&gt;debug.getinfo(1,&quot;n&quot;).name&lt;/code&gt; 은 합리적인 이름을 찾을 수있는 경우 현재 함수의 이름을 리턴하고 식 &lt;code&gt;debug.getinfo(print)&lt;/code&gt; 는 사용 가능한 모든 정보가있는 테이블을 리턴합니다. 그만큼&lt;a href=&quot;#pdf-print&quot;&gt; &lt;code&gt;print&lt;/code&gt; &lt;/a&gt; 기능.</target>
        </trans-unit>
        <trans-unit id="9d773bc0c304ccd5d231dc0560bc0e8adc234c3e" translate="yes" xml:space="preserve">
          <source>For integer loops, the control variable never wraps around; instead, the loop ends in case of an overflow.</source>
          <target state="translated">정수 루프의 경우 제어 변수는 절대로 래핑되지 않습니다. 대신 오버플로가 발생하면 루프가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="f325475ad152d3908d4847a20ea6df37fed2cc91" translate="yes" xml:space="preserve">
          <source>For more details about these options, see &lt;a href=&quot;#pdf-collectgarbage&quot;&gt;&lt;code&gt;collectgarbage&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이러한 옵션에 대한 자세한 내용은 &lt;a href=&quot;#pdf-collectgarbage&quot;&gt; &lt;code&gt;collectgarbage&lt;/code&gt; 를&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="34c0c487495b8d4cfa8ec08b6a774ef30e784f4f" translate="yes" xml:space="preserve">
          <source>For options &quot;&lt;code&gt;!&lt;em&gt;n&lt;/em&gt;&lt;/code&gt;&quot;, &quot;&lt;code&gt;s&lt;em&gt;n&lt;/em&gt;&lt;/code&gt;&quot;, &quot;&lt;code&gt;i&lt;em&gt;n&lt;/em&gt;&lt;/code&gt;&quot;, and &quot;&lt;code&gt;I&lt;em&gt;n&lt;/em&gt;&lt;/code&gt;&quot;, &lt;code&gt;n&lt;/code&gt; can be any integer between 1 and 16. All integral options check overflows; &lt;a href=&quot;#pdf-string.pack&quot;&gt;&lt;code&gt;string.pack&lt;/code&gt;&lt;/a&gt; checks whether the given value fits in the given size; &lt;a href=&quot;#pdf-string.unpack&quot;&gt;&lt;code&gt;string.unpack&lt;/code&gt;&lt;/a&gt; checks whether the read value fits in a Lua integer.</source>
          <target state="translated">&quot; &lt;code&gt;!&lt;em&gt;n&lt;/em&gt;&lt;/code&gt; &quot;, &quot; &lt;code&gt;s&lt;em&gt;n&lt;/em&gt;&lt;/code&gt; &quot;, &quot; &lt;code&gt;i&lt;em&gt;n&lt;/em&gt;&lt;/code&gt; &quot;및 &quot; &lt;code&gt;I&lt;em&gt;n&lt;/em&gt;&lt;/code&gt; &quot;옵션의 경우, &lt;code&gt;n&lt;/code&gt; 은 1과 16 사이의 정수일 수 있습니다. 모든 정수 옵션 점검 오버 플로우; &lt;a href=&quot;#pdf-string.pack&quot;&gt; &lt;code&gt;string.pack&lt;/code&gt; &lt;/a&gt; 은 주어진 값이 주어진 크기에 맞는지 확인합니다. &lt;a href=&quot;#pdf-string.unpack&quot;&gt; &lt;code&gt;string.unpack&lt;/code&gt; &lt;/a&gt; 은 읽은 값이 Lua 정수에 맞는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="16f59a41653df80c51829c1441745313f8b7cbbb" translate="yes" xml:space="preserve">
          <source>For options &quot;&lt;code&gt;!&lt;em&gt;n&lt;/em&gt;&lt;/code&gt;&quot;, &quot;&lt;code&gt;s&lt;em&gt;n&lt;/em&gt;&lt;/code&gt;&quot;, &quot;&lt;code&gt;i&lt;em&gt;n&lt;/em&gt;&lt;/code&gt;&quot;, and &quot;&lt;code&gt;I&lt;em&gt;n&lt;/em&gt;&lt;/code&gt;&quot;, &lt;code&gt;n&lt;/code&gt; can be any integer between 1 and 16. All integral options check overflows; &lt;a href=&quot;#pdf-string.pack&quot;&gt;&lt;code&gt;string.pack&lt;/code&gt;&lt;/a&gt; checks whether the given value fits in the given size; &lt;a href=&quot;#pdf-string.unpack&quot;&gt;&lt;code&gt;string.unpack&lt;/code&gt;&lt;/a&gt; checks whether the read value fits in a Lua integer. For the unsigned options, Lua integers are treated as unsigned values too.</source>
          <target state="translated">옵션 &quot; &lt;code&gt;!&lt;em&gt;n&lt;/em&gt;&lt;/code&gt; &quot;, &quot; &lt;code&gt;s&lt;em&gt;n&lt;/em&gt;&lt;/code&gt; &quot;, &quot; &lt;code&gt;i&lt;em&gt;n&lt;/em&gt;&lt;/code&gt; &quot;및 &quot; &lt;code&gt;I&lt;em&gt;n&lt;/em&gt;&lt;/code&gt; &quot;의 경우 &lt;code&gt;n&lt;/code&gt; 은 1에서 16 사이의 정수일 수 있습니다. 모든 정수 옵션 검사 오버플로; &lt;a href=&quot;#pdf-string.pack&quot;&gt; &lt;code&gt;string.pack&lt;/code&gt; &lt;/a&gt; 은 주어진 값이 주어진 크기에 맞는지 확인합니다. &lt;a href=&quot;#pdf-string.unpack&quot;&gt; &lt;code&gt;string.unpack&lt;/code&gt; &lt;/a&gt; 은 읽은 값이 Lua 정수에 맞는지 확인합니다. 부호없는 옵션의 경우 Lua 정수도 부호없는 값으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="ad544ef0a62b91c4a51eea38e40c1547b59eca51" translate="yes" xml:space="preserve">
          <source>For the last two cases, &lt;code&gt;size&lt;/code&gt; is a hint for the size of the buffer, in bytes. The default is an appropriate size.</source>
          <target state="translated">마지막 두 경우에서 &lt;code&gt;size&lt;/code&gt; 는 버퍼 크기 (바이트)에 대한 힌트입니다. 기본값은 적절한 크기입니다.</target>
        </trans-unit>
        <trans-unit id="f81592a23f0c3cfdc23fb61def4f995f00f7e4be" translate="yes" xml:space="preserve">
          <source>For the last two cases, &lt;code&gt;size&lt;/code&gt; specifies the size of the buffer, in bytes. The default is an appropriate size.</source>
          <target state="translated">마지막 두 경우에, &lt;code&gt;size&lt;/code&gt; 바이트 단위의 버퍼의 크기를 지정한다. 기본값은 적절한 크기입니다.</target>
        </trans-unit>
        <trans-unit id="f0c4dd09d2da4ac2d83e7333654eda3bf03b94aa" translate="yes" xml:space="preserve">
          <source>For the unary operators (negation, length, and bitwise NOT), the metamethod is computed and called with a dummy second operand, equal to the first one. This extra operand is only to simplify Lua's internals (by making these operators behave like a binary operation) and may be removed in future versions. (For most uses this extra operand is irrelevant.)</source>
          <target state="translated">단항 연산자 (음수, 길이 및 비트 NOT)의 경우 메타 메소드는 첫 번째와 동일한 더미 두 번째 피연산자로 계산되고 호출됩니다. 이 추가 피연산자는 Lua의 내부를 단순화하기위한 것이며 (이 연산자를 이진 연산처럼 동작하게함으로써) 향후 버전에서 제거 될 수 있습니다. (대부분의 경우이 추가 피연산자는 관련이 없습니다.)</target>
        </trans-unit>
        <trans-unit id="aacfef94d4b7963c7011b036882763ad9f51ddc6" translate="yes" xml:space="preserve">
          <source>For the unary operators (negation, length, and bitwise NOT), the metamethod is computed and called with a dummy second operand, equal to the first one. This extra operand is only to simplify Lua's internals (by making these operators behave like a binary operation) and may be removed in future versions. For most uses this extra operand is irrelevant.</source>
          <target state="translated">단항 연산자 (부정, 길이 및 비트 NOT)의 경우 메타 메서드가 계산되고 첫 번째 피연산자와 같은 더미 두 번째 피연산자로 호출됩니다. 이 추가 피연산자는 Lua의 내부를 단순화하기위한 것이며 (이러한 연산자가 이진 연산처럼 작동하도록하여) 향후 버전에서 제거 될 수 있습니다. 대부분의 경우이 추가 피연산자는 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="9bee60d752066315e8c5d61073cf8553d9376cba" translate="yes" xml:space="preserve">
          <source>For this function, a caret '&lt;code&gt;^&lt;/code&gt;' at the start of a pattern does not work as an anchor, as this would prevent the iteration.</source>
          <target state="translated">이 함수의 경우, 패턴 시작 부분의 캐럿 ' &lt;code&gt;^&lt;/code&gt; '는 반복을 방해하므로 앵커로 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="399be06d89bf8fe00ffb06cec99c776653b07ce7" translate="yes" xml:space="preserve">
          <source>Format Strings for Pack and Unpack</source>
          <target state="translated">Pack 및 Unpack의 형식 문자열</target>
        </trans-unit>
        <trans-unit id="5811b125cf5b52aaade18ffd4cbe777aa740f3a9" translate="yes" xml:space="preserve">
          <source>Full userdata now has an arbitrary number of associated user values. Therefore, the functions &lt;code&gt;lua_newuserdata&lt;/code&gt;, &lt;code&gt;lua_setuservalue&lt;/code&gt;, and &lt;code&gt;lua_getuservalue&lt;/code&gt; were replaced by &lt;a href=&quot;#lua_newuserdatauv&quot;&gt;&lt;code&gt;lua_newuserdatauv&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#lua_setiuservalue&quot;&gt;&lt;code&gt;lua_setiuservalue&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#lua_getiuservalue&quot;&gt;&lt;code&gt;lua_getiuservalue&lt;/code&gt;&lt;/a&gt;, which have an extra argument.</source>
          <target state="translated">이제 전체 사용자 데이터에는 임의의 수의 연관된 사용자 값이 있습니다. 따라서 기능 &lt;code&gt;lua_newuserdata&lt;/code&gt; , &lt;code&gt;lua_setuservalue&lt;/code&gt; 및 &lt;code&gt;lua_getuservalue&lt;/code&gt; 는 대체되었다 &lt;a href=&quot;#lua_newuserdatauv&quot;&gt; &lt;code&gt;lua_newuserdatauv&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#lua_setiuservalue&quot;&gt; &lt;code&gt;lua_setiuservalue&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#lua_getiuservalue&quot;&gt; &lt;code&gt;lua_getiuservalue&lt;/code&gt; &lt;/a&gt; 추가 인수를 가지고.</target>
        </trans-unit>
        <trans-unit id="530d75eed648d882414a993d7c2be06a4295791d" translate="yes" xml:space="preserve">
          <source>Function &lt;a href=&quot;#lua_dump&quot;&gt;&lt;code&gt;lua_dump&lt;/code&gt;&lt;/a&gt; has an extra parameter, &lt;code&gt;strip&lt;/code&gt;. Use 0 as the value of this parameter to get the old behavior.</source>
          <target state="translated">&lt;a href=&quot;#lua_dump&quot;&gt; &lt;code&gt;lua_dump&lt;/code&gt; &lt;/a&gt; 함수 에는 추가 매개 변수 &lt;code&gt;strip&lt;/code&gt; 이 있습니다. 이 매개 변수의 값으로 0을 사용하여 이전 동작을 가져 오십시오.</target>
        </trans-unit>
        <trans-unit id="d8cdf10face49f05a0d7bce562c1cbcff9eeec04" translate="yes" xml:space="preserve">
          <source>Function Calls</source>
          <target state="translated">함수 호출</target>
        </trans-unit>
        <trans-unit id="4b57ecf18e5d2f870512efd9673b84b72878ac94" translate="yes" xml:space="preserve">
          <source>Function Calls as Statements</source>
          <target state="translated">명령문으로서의 함수 호출</target>
        </trans-unit>
        <trans-unit id="92923ba91494ddefbc1f5287cf60c97558518359" translate="yes" xml:space="preserve">
          <source>Function Definitions</source>
          <target state="translated">기능 정의</target>
        </trans-unit>
        <trans-unit id="a8675a73106b372729db5f272e24a7c2891c266a" translate="yes" xml:space="preserve">
          <source>Function calls and assignments can start with an open parenthesis. This possibility leads to an ambiguity in Lua's grammar. Consider the following fragment:</source>
          <target state="translated">함수 호출 및 할당은 열린 괄호로 시작할 수 있습니다. 이 가능성은 루아의 문법에 모호함을 초래합니다. 다음 조각을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="723bc3c839b5efbdcf6d6d540aec9e08e9a27818" translate="yes" xml:space="preserve">
          <source>Functions called &lt;code&gt;luaL_check*&lt;/code&gt; always raise an error if the check is not satisfied.</source>
          <target state="translated">점검이 충족되지 않으면 &lt;code&gt;luaL_check*&lt;/code&gt; 라는 함수는 항상 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="2d65cedef6534edb90967211162bdffe8c828103" translate="yes" xml:space="preserve">
          <source>Functions that create byte sequences accept all values up to &lt;code&gt;0x7FFFFFFF&lt;/code&gt;, as defined in the original UTF-8 specification; that implies byte sequences of up to six bytes.</source>
          <target state="translated">바이트 시퀀스를 생성하는 함수 는 원래 UTF-8 사양에 정의 된대로 최대 &lt;code&gt;0x7FFFFFFF&lt;/code&gt; 까지의 모든 값을 허용합니다 . 이는 최대 6 바이트의 바이트 시퀀스를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="5c702d0533cf7bf413cae345667e4f93afbda238" translate="yes" xml:space="preserve">
          <source>Functions that do not need a specific mutable position, but only a value (e.g., query functions), can be called with acceptable indices. An &lt;em&gt;acceptable index&lt;/em&gt; can be any valid index, but it also can be any positive index after the stack top within the space allocated for the stack, that is, indices up to the stack size. (Note that 0 is never an acceptable index.) Except when noted otherwise, functions in the API work with acceptable indices.</source>
          <target state="translated">특정 가변 위치가 필요하지 않지만 값 (예 : 쿼리 함수) 만 허용되는 인덱스로 호출 할 수 있습니다. &lt;em&gt;허용 가능한 인덱스가&lt;/em&gt; 유효한 지표가 될 수 있지만, 그것은 또한 스택, 할당 된 공간 내의 스택 최상부 후 양의 지표가 될 수 있으며, 스택 사이즈까지와 indices. (0은 허용되는 인덱스가 아닙니다.) 달리 명시되지 않는 한 API의 함수는 허용 가능한 인덱스로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="71ee2fc0b246259543c3707b31174809b1446b0a" translate="yes" xml:space="preserve">
          <source>Functions that do not need a specific mutable position, but only a value (e.g., query functions), can be called with acceptable indices. An &lt;em&gt;acceptable index&lt;/em&gt; can be any valid index, but it also can be any positive index after the stack top within the space allocated for the stack, that is, indices up to the stack size. (Note that 0 is never an acceptable index.) Indices to upvalues (see &lt;a href=&quot;#4.2&quot;&gt;&amp;sect;4.2&lt;/a&gt;) greater than the real number of upvalues in the current C function are also acceptable (but invalid). Except when noted otherwise, functions in the API work with acceptable indices.</source>
          <target state="translated">특정 가변 위치가 필요하지 않고 값 (예 : 쿼리 함수) 만 필요한 함수는 허용 가능한 인덱스로 호출 할 수 있습니다. &lt;em&gt;허용 가능한 인덱스가&lt;/em&gt; 유효한 지표가 될 수 있지만, 그것은 또한 스택, 할당 된 공간 내의 스택 최상부 후 양의 지표가 될 수 있으며, 스택 사이즈까지와 indices. (0은 절대 허용되는 색인이 아닙니다.) 현재 C 함수의 실제 upvalue 수보다 큰 upvalue ( &lt;a href=&quot;#4.2&quot;&gt;&amp;sect;4.2&lt;/a&gt; 참조)에 대한 색인 도 허용되지만 유효하지 않습니다. 달리 명시되지 않는 한 API의 함수는 허용 가능한 인덱스로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="65eec0deb30fe9df087749c912f9fa2e221445a8" translate="yes" xml:space="preserve">
          <source>Functions that interpret byte sequences only accept valid sequences (well formed and not overlong). By default, they only accept byte sequences that result in valid Unicode code points, rejecting values greater than &lt;code&gt;10FFFF&lt;/code&gt; and surrogates. A boolean argument &lt;code&gt;lax&lt;/code&gt;, when available, lifts these checks, so that all values up to &lt;code&gt;0x7FFFFFFF&lt;/code&gt; are accepted. (Not well formed and overlong sequences are still rejected.)</source>
          <target state="translated">바이트 시퀀스를 해석하는 함수는 유효한 시퀀스 만 허용합니다 (잘 형성되고 너무 길지 않음). 기본적으로 유효한 유니 코드 코드 포인트를 생성하는 바이트 시퀀스 만 허용 하고 &lt;code&gt;10FFFF&lt;/code&gt; 보다 큰 값 과 서로 게이트 는 거부합니다 . 부울 인수 &lt;code&gt;lax&lt;/code&gt; 는 사용 가능한 경우 이러한 검사를 해제하므로 최대 &lt;code&gt;0x7FFFFFFF&lt;/code&gt; 까지의 모든 값 이 허용됩니다. (잘 형성되지 않고 지나치게 긴 시퀀스는 여전히 거부됩니다.)</target>
        </trans-unit>
        <trans-unit id="a1a5aae46bd7798a00126da19dd14418bb7e3eb8" translate="yes" xml:space="preserve">
          <source>Functions to inject/project unsigned integers (&lt;code&gt;lua_pushunsigned&lt;/code&gt;, &lt;code&gt;lua_tounsigned&lt;/code&gt;, &lt;code&gt;lua_tounsignedx&lt;/code&gt;, &lt;code&gt;luaL_checkunsigned&lt;/code&gt;, &lt;code&gt;luaL_optunsigned&lt;/code&gt;) were deprecated. Use their signed equivalents with a type cast.</source>
          <target state="translated">부호없는 정수를 주입 / 투영하는 함수 ( &lt;code&gt;lua_pushunsigned&lt;/code&gt; , &lt;code&gt;lua_tounsigned&lt;/code&gt; , &lt;code&gt;lua_tounsignedx&lt;/code&gt; , &lt;code&gt;luaL_checkunsigned&lt;/code&gt; , &lt;code&gt;luaL_optunsigned&lt;/code&gt; ) 는 사용되지 않습니다. 캐스트와 함께 서명 된 동등 물을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="399c67992893454b594db8a5c3ddb1835002a32d" translate="yes" xml:space="preserve">
          <source>Functions with upvalues have only their number of upvalues saved. When (re)loaded, those upvalues receive fresh instances containing &lt;b&gt;nil&lt;/b&gt;. (You can use the debug library to serialize and reload the upvalues of a function in a way adequate to your needs.)</source>
          <target state="translated">업 밸류가있는 함수에는 업 밸류 스 수가 저장됩니다. (재)로드되면, 그 업 값은 다음을 포함하는 새로운 인스턴스를받습니다.&lt;b&gt; nil을&lt;/b&gt; . 디버그 라이브러리를 사용하여 필요에 따라 적절한 방식으로 함수의 값을 직렬화하고 다시로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b638ca7daccce15b49244cde0902229230009dc" translate="yes" xml:space="preserve">
          <source>Functions with upvalues have only their number of upvalues saved. When (re)loaded, those upvalues receive fresh instances. (See the &lt;a href=&quot;#pdf-load&quot;&gt;&lt;code&gt;load&lt;/code&gt;&lt;/a&gt; function for details about how these upvalues are initialized. You can use the debug library to serialize and reload the upvalues of a function in a way adequate to your needs.)</source>
          <target state="translated">상승 값이있는 함수에는 상승 값 수만 저장됩니다. (재)로드되면 이러한 upvalue는 새로운 인스턴스를받습니다. ( 이러한 upvalue가 초기화되는 방법에 대한 자세한 내용은 &lt;a href=&quot;#pdf-load&quot;&gt; &lt;code&gt;load&lt;/code&gt; &lt;/a&gt; 함수를 참조하십시오 . 디버그 라이브러리를 사용하여 필요에 적합한 방식으로 함수의 upvalue를 직렬화하고 다시로드 할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="5b32b8542e4c8854b05455c0b114c2bdced713ad" translate="yes" xml:space="preserve">
          <source>Garbage Collection</source>
          <target state="translated">가비지 콜렉션</target>
        </trans-unit>
        <trans-unit id="f6855bbf563c59c18fc37154e4af975ae952d5a4" translate="yes" xml:space="preserve">
          <source>Garbage-Collection Metamethods</source>
          <target state="translated">가비지 콜렉션 메타 메소드</target>
        </trans-unit>
        <trans-unit id="313100c75a8533ab565e1eb0ac9c81f85a7c5073" translate="yes" xml:space="preserve">
          <source>Generates a Lua error, using the value at the top of the stack as the error object. This function does a long jump, and therefore never returns (see &lt;a href=&quot;#luaL_error&quot;&gt;&lt;code&gt;luaL_error&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">스택 맨 위에있는 값을 오류 객체로 사용하여 Lua 오류를 생성합니다. 이 함수는 멀리뛰기하므로 절대 반환하지 않습니다 ( &lt;a href=&quot;#luaL_error&quot;&gt; &lt;code&gt;luaL_error&lt;/code&gt; &lt;/a&gt; 참조) . ).</target>
        </trans-unit>
        <trans-unit id="50c098c65024d0b52b85fb9aca6369ae9372e358" translate="yes" xml:space="preserve">
          <source>Generational Garbage Collection</source>
          <target state="translated">세대 별 가비지 수집</target>
        </trans-unit>
        <trans-unit id="c0be169e33a9a31268a5328272fe2fa469b1c7ec" translate="yes" xml:space="preserve">
          <source>Gets information about a local variable of a given activation record or a given function.</source>
          <target state="translated">지정된 활성화 레코드 또는 지정된 함수의 로컬 변수에 대한 정보를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="a91634dbb2a1cbd99fd7a796a6dde64168923d2e" translate="yes" xml:space="preserve">
          <source>Gets information about a local variable or a temporary value of a given activation record or a given function.</source>
          <target state="translated">지정된 활성화 레코드 또는 지정된 함수의 로컬 변수 또는 임시 값에 대한 정보를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="5cf3ef7371f5378d8e58a5b0757ef77be8111cff" translate="yes" xml:space="preserve">
          <source>Gets information about a specific function or function invocation.</source>
          <target state="translated">특정 함수 또는 함수 호출에 대한 정보를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="5d07f6c25730366d5782ddf2124f63eacbe7a041" translate="yes" xml:space="preserve">
          <source>Gets information about the &lt;code&gt;n&lt;/code&gt;-th upvalue of the closure at index &lt;code&gt;funcindex&lt;/code&gt;. It pushes the upvalue's value onto the stack and returns its name. Returns &lt;code&gt;NULL&lt;/code&gt; (and pushes nothing) when the index &lt;code&gt;n&lt;/code&gt; is greater than the number of upvalues.</source>
          <target state="translated">index &lt;code&gt;funcindex&lt;/code&gt; 에서 클로저 의 &lt;code&gt;n&lt;/code&gt; 번째 값에 대한 정보를 가져 옵니다 . 업 값의 값을 스택으로 푸시하고 이름을 반환합니다. &lt;code&gt;NULL&lt;/code&gt; 을 반환인덱스 &lt;code&gt;n&lt;/code&gt; 이 업 값 수보다 크면 하고 아무것도 푸시하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="62c6dfe4bd33a93e8e74cb65c4ff32424b3ecf7b" translate="yes" xml:space="preserve">
          <source>Gets information about the interpreter runtime stack.</source>
          <target state="translated">인터프리터 런타임 스택에 대한 정보를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="0b201abab8551378dd82fcd0d47c8bebaab95fa2" translate="yes" xml:space="preserve">
          <source>Gets the real value of &lt;code&gt;table[index]&lt;/code&gt;, without invoking the &lt;code&gt;__index&lt;/code&gt; metamethod. &lt;code&gt;table&lt;/code&gt; must be a table; &lt;code&gt;index&lt;/code&gt; may be any value.</source>
          <target state="translated">&lt;code&gt;__index&lt;/code&gt; 메타 메소드 를 호출하지 않고 &lt;code&gt;table[index]&lt;/code&gt; 의 실제 값을 가져옵니다 . &lt;code&gt;table&lt;/code&gt; 은 테이블 이어야합니다. &lt;code&gt;index&lt;/code&gt; 는 임의의 값일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2eb65b9436b0e69a1305aac536012a51200d6c8e" translate="yes" xml:space="preserve">
          <source>Gets the real value of &lt;code&gt;table[index]&lt;/code&gt;, without using the &lt;code&gt;__index&lt;/code&gt; metavalue. &lt;code&gt;table&lt;/code&gt; must be a table; &lt;code&gt;index&lt;/code&gt; may be any value.</source>
          <target state="translated">&lt;code&gt;__index&lt;/code&gt; 메타 값을 사용하지 않고 &lt;code&gt;table[index]&lt;/code&gt; 의 실제 값을 가져 옵니다. &lt;code&gt;table&lt;/code&gt; 은 테이블 이어야합니다. &lt;code&gt;index&lt;/code&gt; 는 모든 값이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91020a88f59d9c8fbc1c662bdb6eda5896f6dbfe" translate="yes" xml:space="preserve">
          <source>Given a list where all elements are strings or numbers, returns the string &lt;code&gt;list[i]..sep..list[i+1] &amp;middot;&amp;middot;&amp;middot; sep..list[j]&lt;/code&gt;. The default value for &lt;code&gt;sep&lt;/code&gt; is the empty string, the default for &lt;code&gt;i&lt;/code&gt; is 1, and the default for &lt;code&gt;j&lt;/code&gt; is &lt;code&gt;#list&lt;/code&gt;. If &lt;code&gt;i&lt;/code&gt; is greater than &lt;code&gt;j&lt;/code&gt;, returns the empty string.</source>
          <target state="translated">모든 요소가 문자열 또는 숫자 인 &lt;code&gt;list[i]..sep..list[i+1] &amp;middot;&amp;middot;&amp;middot; sep..list[j]&lt;/code&gt; 문자열 목록 [i] .. sep..list [i + 1] &amp;middot;&amp;middot;&amp;middot; sep..list [j]를 반환합니다 . &lt;code&gt;sep&lt;/code&gt; 의 기본값 은 빈 문자열이고 &lt;code&gt;i&lt;/code&gt; 의 기본값 은 1이며 &lt;code&gt;j&lt;/code&gt; 의 기본값 은 &lt;code&gt;#list&lt;/code&gt; 입니다. 경우에 &lt;code&gt;i&lt;/code&gt; 보다 큰 &lt;code&gt;j&lt;/code&gt; , 빈 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b57745f04b18114e4271e54461167a450eab4e48" translate="yes" xml:space="preserve">
          <source>Grows the stack size to &lt;code&gt;top + sz&lt;/code&gt; elements, raising an error if the stack cannot grow to that size. &lt;code&gt;msg&lt;/code&gt; is an additional text to go into the error message (or &lt;code&gt;NULL&lt;/code&gt; for no additional text).</source>
          <target state="translated">스택 크기를 &lt;code&gt;top + sz&lt;/code&gt; 요소 로 확장하여 스택 이 해당 크기로 커지지 않으면 오류가 발생합니다. &lt;code&gt;msg&lt;/code&gt; 는 오류 메시지로 이동하는 추가 텍스트입니다 (또는 추가 텍스트가없는 경우 &lt;code&gt;NULL&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0931022beea83b3afc095873234631b7243eeca4" translate="yes" xml:space="preserve">
          <source>Here are some examples:</source>
          <target state="translated">여기 몇 가지 예가 있어요.</target>
        </trans-unit>
        <trans-unit id="4b1c6bd65c741e8ff2d3bbd3ff2fc22c3d2a47ba" translate="yes" xml:space="preserve">
          <source>Here is a simple implementation for the allocator function. It is used in the auxiliary library by &lt;a href=&quot;#luaL_newstate&quot;&gt;&lt;code&gt;luaL_newstate&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">할당 자 함수에 대한 간단한 구현은 다음과 같습니다. 보조 라이브러리에서 &lt;a href=&quot;#luaL_newstate&quot;&gt; &lt;code&gt;luaL_newstate&lt;/code&gt; 에&lt;/a&gt; 의해 사용 됩니다 .</target>
        </trans-unit>
        <trans-unit id="d1dab51e6891f4e284fffd166a6bd35c869f4cc2" translate="yes" xml:space="preserve">
          <source>Here is the complete syntax of Lua in extended BNF. As usual in extended BNF, {A} means 0 or more As, and [A] means an optional A. (For operator precedences, see &lt;a href=&quot;#3.4.8&quot;&gt;&amp;sect;3.4.8&lt;/a&gt;; for a description of the terminals Name, Numeral, and LiteralString, see &lt;a href=&quot;#3.1&quot;&gt;&amp;sect;3.1&lt;/a&gt;.)</source>
          <target state="translated">확장 BNF에서 Lua의 전체 구문은 다음과 같습니다. 확장 된 BNF에서 일반적으로 {A}는 0 이상의 As를 의미하고 [A]는 선택적인 A를 의미합니다 (연산자 우선 순위는 &lt;a href=&quot;#3.4.8&quot;&gt;&amp;sect;3.4.8&lt;/a&gt; 참조) . 상기 단말 설명 이름 부호 및 LiteralString을 참조&lt;a href=&quot;#3.1&quot;&gt; &amp;sect; 3.1&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="ded763c4029757dddf3f7027714a4cf075c2d5bd" translate="yes" xml:space="preserve">
          <source>Here it is in C:</source>
          <target state="translated">여기 C에 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f274b8694db69b484f40f23944a016b4fffa6f3" translate="yes" xml:space="preserve">
          <source>Here we list all functions and types from the C API in alphabetical order. Each function has an indicator like this:</source>
          <target state="translated">여기에서는 C API의 모든 함수와 유형을 알파벳 순서로 나열합니다. 각 기능에는 다음과 같은 표시기가 있습니다.</target>
        </trans-unit>
        <trans-unit id="759a7b44d9cbdbdff0c6256556529057e71e4bfc" translate="yes" xml:space="preserve">
          <source>Here we list all functions and types from the auxiliary library in alphabetical order.</source>
          <target state="translated">여기에는 보조 라이브러리의 모든 기능과 유형이 알파벳 순서로 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ef4637da05a815223e812a542adefe907813773" translate="yes" xml:space="preserve">
          <source>Here we list the incompatibilities that you may find when moving a program from Lua 5.2 to Lua 5.3. You can avoid some incompatibilities by compiling Lua with appropriate options (see file &lt;code&gt;luaconf.h&lt;/code&gt;). However, all these compatibility options will be removed in the future.</source>
          <target state="translated">다음은 프로그램을 Lua 5.2에서 Lua 5.3으로 이동할 때 찾을 수있는 비 호환성을 나열합니다. 적절한 옵션으로 Lua를 컴파일하면 일부 비 호환성을 피할 수 있습니다 ( &lt;code&gt;luaconf.h&lt;/code&gt; 파일 참조 ). 그러나 이러한 호환성 옵션은 모두 향후에 제거 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="baa813e9ef48afa17599283672646b10b398c71d" translate="yes" xml:space="preserve">
          <source>Here we list the incompatibilities that you may find when moving a program from Lua 5.3 to Lua 5.4.</source>
          <target state="translated">여기에 Lua 5.3에서 Lua 5.4로 프로그램을 이동할 때 발견 할 수있는 비 호환성 목록이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1634499670e7d73f48fc27f8298b086983ef130f" translate="yes" xml:space="preserve">
          <source>Here, to &lt;em&gt;close&lt;/em&gt; a value means to call its &lt;code&gt;__close&lt;/code&gt; metamethod. When calling the metamethod, the value itself is passed as the first argument and the error object that caused the exit (if any) is passed as a second argument; if there was no error, the second argument is &lt;b&gt;nil&lt;/b&gt;.</source>
          <target state="translated">여기서 값 을 &lt;em&gt;닫는다&lt;/em&gt; 는 것은 &lt;code&gt;__close&lt;/code&gt; 메타 메서드 를 호출하는 것을 의미합니다 . 메타 메서드를 호출 할 때 값 자체가 첫 번째 인수로 전달되고 종료를 유발 한 오류 개체 (있는 경우)가 두 번째 인수로 전달됩니다. 오류가없는 경우 두 번째 인수는 &lt;b&gt;nil&lt;/b&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6e8633ec37fd0a545b50c273991305c0a0ccd6af" translate="yes" xml:space="preserve">
          <source>Hook functions can yield under the following conditions: Only count and line events can yield; to yield, a hook function must finish its execution calling &lt;a href=&quot;#lua_yield&quot;&gt;&lt;code&gt;lua_yield&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;nresults&lt;/code&gt; equal to zero (that is, with no values).</source>
          <target state="translated">후크 함수는 다음과 같은 조건에서 생성 할 수 있습니다. 카운트 및 라인 이벤트 만 생성 할 수 있습니다. 후크 함수는 &lt;a href=&quot;#lua_yield&quot;&gt; &lt;code&gt;lua_yield&lt;/code&gt; &lt;/a&gt; 를 호출하여 실행을 완료해야합니다. &lt;code&gt;nresults&lt;/code&gt; 가 0 (즉, 값이 없음) 인 .</target>
        </trans-unit>
        <trans-unit id="57503e65706288b8ec579f8045e20e5c7fc42803" translate="yes" xml:space="preserve">
          <source>Hook functions cannot have continuations, that is, they cannot call &lt;a href=&quot;#lua_yieldk&quot;&gt;&lt;code&gt;lua_yieldk&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#lua_pcallk&quot;&gt;&lt;code&gt;lua_pcallk&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#lua_callk&quot;&gt;&lt;code&gt;lua_callk&lt;/code&gt;&lt;/a&gt; with a non-null &lt;code&gt;k&lt;/code&gt;.</source>
          <target state="translated">후크 함수는 연속성을 가질 수 없습니다. 즉, 널이 아닌 &lt;code&gt;k&lt;/code&gt; 로&lt;a href=&quot;#lua_yieldk&quot;&gt; &lt;code&gt;lua_yieldk&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#lua_pcallk&quot;&gt; &lt;code&gt;lua_pcallk&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#lua_callk&quot;&gt; &lt;code&gt;lua_callk&lt;/code&gt; &lt;/a&gt; 를 호출 할 수 없습니다. .</target>
        </trans-unit>
        <trans-unit id="8e26681d60fc0627c647c42d14db1c8969032f43" translate="yes" xml:space="preserve">
          <source>Hooks are disabled by setting &lt;code&gt;mask&lt;/code&gt; to zero.</source>
          <target state="translated">&lt;code&gt;mask&lt;/code&gt; 를 0 으로 설정하면 후크가 비활성화됩니다 .</target>
        </trans-unit>
        <trans-unit id="c0c8d828197edf926fd895a22fd233a53985fe4e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;chunk&lt;/code&gt; is a string, the chunk is this string. If &lt;code&gt;chunk&lt;/code&gt; is a function, &lt;code&gt;load&lt;/code&gt; calls it repeatedly to get the chunk pieces. Each call to &lt;code&gt;chunk&lt;/code&gt; must return a string that concatenates with previous results. A return of an empty string, &lt;b&gt;nil&lt;/b&gt;, or no value signals the end of the chunk.</source>
          <target state="translated">경우 &lt;code&gt;chunk&lt;/code&gt; 문자열 인, 청크는이 문자열입니다. 경우 &lt;code&gt;chunk&lt;/code&gt; 기능은, &lt;code&gt;load&lt;/code&gt; 청크의 조각을 얻기 위해 반복적으로 호출합니다. &lt;code&gt;chunk&lt;/code&gt; 를 호출 할 때마다 이전 결과와 연결된 문자열을 반환해야합니다. 빈 문자열, &lt;b&gt;nil을&lt;/b&gt; 반환 하거나 값이 없으면 청크의 끝을 알립니다.</target>
        </trans-unit>
        <trans-unit id="56626a6306a0218f5ebc2bc99df5b09f8b5d3616" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;def&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, the function uses &lt;code&gt;def&lt;/code&gt; as a default value when there is no argument &lt;code&gt;arg&lt;/code&gt; or when this argument is &lt;b&gt;nil&lt;/b&gt;.</source>
          <target state="translated">경우 &lt;code&gt;def&lt;/code&gt; 아닌 &lt;code&gt;NULL&lt;/code&gt; , 함수는 사용 &lt;code&gt;def&lt;/code&gt; 에는 인수가없는 경우 디폴트 값으로 &lt;code&gt;arg&lt;/code&gt; 하거나이 인수가 &lt;b&gt;전무&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="ce3a21a7279c845347c98d6941a31e57eb8f0480" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;format&lt;/code&gt; is absent, it defaults to &quot;&lt;code&gt;%c&lt;/code&gt;&quot;, which gives a human-readable date and time representation using the current locale.</source>
          <target state="translated">경우에 &lt;code&gt;format&lt;/code&gt; 없는, 그것은 &quot;기본값 &lt;code&gt;%c&lt;/code&gt; 현재 로케일을 사용하여 사람이 읽을 수있는 날짜와 시간 표현을 제공합니다&quot;.</target>
        </trans-unit>
        <trans-unit id="d7b55b3722d0d97704dcddb34cbf9bcdade76ec4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;format&lt;/code&gt; is not &quot;&lt;code&gt;*t&lt;/code&gt;&quot;, then &lt;code&gt;date&lt;/code&gt; returns the date as a string, formatted according to the same rules as the ISO C function &lt;code&gt;strftime&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;format&lt;/code&gt; 이 &quot; &lt;code&gt;*t&lt;/code&gt; &quot; 가 아닌 경우 &lt;code&gt;date&lt;/code&gt; 는 ISO C 함수 &lt;code&gt;strftime&lt;/code&gt; 과 동일한 규칙에 따라 형식화 된 날짜를 문자열로 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="506e40ff0a74eaa2a16ebe55cc542c656b7d6688" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;format&lt;/code&gt; starts with '&lt;code&gt;!&lt;/code&gt;', then the date is formatted in Coordinated Universal Time. After this optional character, if &lt;code&gt;format&lt;/code&gt; is the string &quot;&lt;code&gt;*t&lt;/code&gt;&quot;, then &lt;code&gt;date&lt;/code&gt; returns a table with the following fields: &lt;code&gt;year&lt;/code&gt;, &lt;code&gt;month&lt;/code&gt; (1&amp;ndash;12), &lt;code&gt;day&lt;/code&gt; (1&amp;ndash;31), &lt;code&gt;hour&lt;/code&gt; (0&amp;ndash;23), &lt;code&gt;min&lt;/code&gt; (0&amp;ndash;59), &lt;code&gt;sec&lt;/code&gt; (0&amp;ndash;61), &lt;code&gt;wday&lt;/code&gt; (weekday, 1&amp;ndash;7, Sunday is 1), &lt;code&gt;yday&lt;/code&gt; (day of the year, 1&amp;ndash;366), and &lt;code&gt;isdst&lt;/code&gt; (daylight saving flag, a boolean). This last field may be absent if the information is not available.</source>
          <target state="translated">만약 &lt;code&gt;format&lt;/code&gt; '로 시작 &lt;code&gt;!&lt;/code&gt; '라고 표시되면 날짜는 협정 세계시로 표시됩니다. 이 선택적 문자 다음에 &lt;code&gt;format&lt;/code&gt; 이 문자열 &quot; &lt;code&gt;*t&lt;/code&gt; &quot;인 경우 &lt;code&gt;date&lt;/code&gt; 는 &lt;code&gt;year&lt;/code&gt; , &lt;code&gt;month&lt;/code&gt; (1&amp;ndash;12), &lt;code&gt;day&lt;/code&gt; (1&amp;ndash;31), &lt;code&gt;hour&lt;/code&gt; (0-23), &lt;code&gt;min&lt;/code&gt; ( 0&amp;ndash;59), &lt;code&gt;sec&lt;/code&gt; (0&amp;ndash;61), &lt;code&gt;wday&lt;/code&gt; (주중, 1&amp;ndash;7, 일요일은 1), &lt;code&gt;yday&lt;/code&gt; ( 1 년 중 1&amp;ndash;366) 및 &lt;code&gt;isdst&lt;/code&gt; (일광 절약 플래그, 부울)입니다. 정보가없는 경우이 마지막 필드가 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fabd7f39d8301559d47d11e33fa3e76d67812f0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;format&lt;/code&gt; starts with '&lt;code&gt;!&lt;/code&gt;', then the date is formatted in Coordinated Universal Time. After this optional character, if &lt;code&gt;format&lt;/code&gt; is the string &quot;&lt;code&gt;*t&lt;/code&gt;&quot;, then &lt;code&gt;date&lt;/code&gt; returns a table with the following fields: &lt;code&gt;year&lt;/code&gt;, &lt;code&gt;month&lt;/code&gt; (1&amp;ndash;12), &lt;code&gt;day&lt;/code&gt; (1&amp;ndash;31), &lt;code&gt;hour&lt;/code&gt; (0&amp;ndash;23), &lt;code&gt;min&lt;/code&gt; (0&amp;ndash;59), &lt;code&gt;sec&lt;/code&gt; (0&amp;ndash;61, due to leap seconds), &lt;code&gt;wday&lt;/code&gt; (weekday, 1&amp;ndash;7, Sunday is 1), &lt;code&gt;yday&lt;/code&gt; (day of the year, 1&amp;ndash;366), and &lt;code&gt;isdst&lt;/code&gt; (daylight saving flag, a boolean). This last field may be absent if the information is not available.</source>
          <target state="translated">만약 &lt;code&gt;format&lt;/code&gt; '로 시작 &lt;code&gt;!&lt;/code&gt; ', 날짜는 협정 세계시로 형식화됩니다. 이 선택적 문자 뒤에 &lt;code&gt;format&lt;/code&gt; 이 문자열 &quot; &lt;code&gt;*t&lt;/code&gt; &quot;인 경우 &lt;code&gt;date&lt;/code&gt; 는 &lt;code&gt;year&lt;/code&gt; , &lt;code&gt;month&lt;/code&gt; (1-12), &lt;code&gt;day&lt;/code&gt; (1&amp;ndash;31), &lt;code&gt;hour&lt;/code&gt; (0&amp;ndash;23), &lt;code&gt;min&lt;/code&gt; ( 0&amp;ndash;59), &lt;code&gt;sec&lt;/code&gt; (0&amp;ndash;61, 윤초로 인해), &lt;code&gt;wday&lt;/code&gt; (평일, 1&amp;ndash;7, 일요일은 1), &lt;code&gt;yday&lt;/code&gt; (1&amp;ndash;366) 및 &lt;code&gt;isdst&lt;/code&gt; (일광 절약 플래그, a 부울). 정보를 사용할 수없는 경우이 마지막 필드가 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8190672d8b6e5a23cf38bf7fd250cf0fc81f9304" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;funcname&lt;/code&gt; is &quot;&lt;code&gt;*&lt;/code&gt;&quot;, then it only links with the library, making the symbols exported by the library available to other dynamically linked libraries. Otherwise, it looks for a function &lt;code&gt;funcname&lt;/code&gt; inside the library and returns this function as a C function. So, &lt;code&gt;funcname&lt;/code&gt; must follow the &lt;a href=&quot;#lua_CFunction&quot;&gt;&lt;code&gt;lua_CFunction&lt;/code&gt;&lt;/a&gt; prototype (see &lt;a href=&quot;#lua_CFunction&quot;&gt;&lt;code&gt;lua_CFunction&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">경우 &lt;code&gt;funcname&lt;/code&gt; 에가 있다 &quot; &lt;code&gt;*&lt;/code&gt; &quot;다음은 다른 동적 링크 라이브러리 라이브러리 사용할 수 보낸 심볼을 라이브러리로 연결합니다. 그렇지 않으면 라이브러리 에서 함수 &lt;code&gt;funcname&lt;/code&gt; 을 찾고이 함수를 C 함수로 리턴합니다. 그래서, &lt;code&gt;funcname&lt;/code&gt; 에는 추적한다 &lt;a href=&quot;#lua_CFunction&quot;&gt; &lt;code&gt;lua_CFunction&lt;/code&gt; 의&lt;/a&gt; (참조 프로토 타입을 &lt;a href=&quot;#lua_CFunction&quot;&gt; &lt;code&gt;lua_CFunction&lt;/code&gt; 을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="3843661cd0d22957a2df1b74e3cc0eae40b47007" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;glb&lt;/code&gt; is true, also stores the module into global &lt;code&gt;modname&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;glb&lt;/code&gt; 사실, 또한 세계에 모듈을 저장하는 &lt;code&gt;modname&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99af05450ff1a222db083914ea7a113dd84ad562" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;glb&lt;/code&gt; is true, also stores the module into the global &lt;code&gt;modname&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;glb&lt;/code&gt; 사실, 또한 세계에 모듈을 저장하는 &lt;code&gt;modname&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1dfd113b7f3930f57215faca9229d63e5a7444d8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;index&lt;/code&gt; is a number, returns all arguments after argument number &lt;code&gt;index&lt;/code&gt;; a negative number indexes from the end (-1 is the last argument). Otherwise, &lt;code&gt;index&lt;/code&gt; must be the string &lt;code&gt;&quot;#&quot;&lt;/code&gt;, and &lt;code&gt;select&lt;/code&gt; returns the total number of extra arguments it received.</source>
          <target state="translated">&lt;code&gt;index&lt;/code&gt; 가 숫자 인 경우 인수 번호 &lt;code&gt;index&lt;/code&gt; 뒤의 모든 인수를 리턴합니다 . 음수는 끝에서 색인합니다 (-1은 마지막 인수입니다). 그렇지 않으면 &lt;code&gt;index&lt;/code&gt; 문자열이어야합니다 &lt;code&gt;&quot;#&quot;&lt;/code&gt; , 및 &lt;code&gt;select&lt;/code&gt; 되돌가 수신 여분의 인수의 총 수를.</target>
        </trans-unit>
        <trans-unit id="9a792f6a10658dfe428995a06ea53ae4d673e447" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;isnum&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, its referent is assigned a boolean value that indicates whether the operation succeeded.</source>
          <target state="translated">&lt;code&gt;isnum&lt;/code&gt; 이 &lt;code&gt;NULL&lt;/code&gt; 이 아닌 경우 , 참조에 작업 성공 여부를 나타내는 부울 값이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="5b55802773aaefd409c45001fa5f1235e3bd43a4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;l&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, fills its referent with the result's length. If the result is &lt;code&gt;NULL&lt;/code&gt; (only possible when returning &lt;code&gt;d&lt;/code&gt; and &lt;code&gt;d == NULL&lt;/code&gt;), its length is considered zero.</source>
          <target state="translated">경우 &lt;code&gt;l&lt;/code&gt; 아닌 &lt;code&gt;NULL&lt;/code&gt; , 결과의 길이는 지시 대상을 채 웁니다. 결과가 &lt;code&gt;NULL&lt;/code&gt; 이면 ( &lt;code&gt;d&lt;/code&gt; 및 &lt;code&gt;d == NULL&lt;/code&gt; 반환 할 때만 가능 ) 길이는 0으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="e15877b81cb8f4644f0e73a139f0b786972779bc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;l&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, fills the position &lt;code&gt;*l&lt;/code&gt; with the result's length. If the result is &lt;code&gt;NULL&lt;/code&gt; (only possible when returning &lt;code&gt;d&lt;/code&gt; and &lt;code&gt;d == NULL&lt;/code&gt;), its length is considered zero.</source>
          <target state="translated">&lt;code&gt;l&lt;/code&gt; 이 &lt;code&gt;NULL&lt;/code&gt; 이 아닌 경우 , 위치 &lt;code&gt;*l&lt;/code&gt; 을 결과 길이로 채 웁니다 . 결과가 &lt;code&gt;NULL&lt;/code&gt; 인 경우 ( &lt;code&gt;d&lt;/code&gt; 및 &lt;code&gt;d == NULL&lt;/code&gt; 반환 할 때만 가능 ) 길이는 0으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="73f0cbaf64ffcc698ebe789e3bf72282c151d928" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;locale&lt;/code&gt; is the empty string, the current locale is set to an implementation-defined native locale. If &lt;code&gt;locale&lt;/code&gt; is the string &quot;&lt;code&gt;C&lt;/code&gt;&quot;, the current locale is set to the standard C locale.</source>
          <target state="translated">경우 &lt;code&gt;locale&lt;/code&gt; 빈 문자열, 현재의 로케일은 구현 정의 기본 로케일로 설정되어 있습니다. 경우 &lt;code&gt;locale&lt;/code&gt; 문자열 &quot;입니다 &lt;code&gt;C&lt;/code&gt; 는 &quot;현재 로케일은 표준 C 로케일로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="acb78160a1f280ce628830b7a5b6f03f442478bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;message&lt;/code&gt; is present but is neither a string nor &lt;b&gt;nil&lt;/b&gt;, this function returns &lt;code&gt;message&lt;/code&gt; without further processing. Otherwise, it returns a string with a traceback of the call stack. The optional &lt;code&gt;message&lt;/code&gt; string is appended at the beginning of the traceback. An optional &lt;code&gt;level&lt;/code&gt; number tells at which level to start the traceback (default is 1, the function calling &lt;code&gt;traceback&lt;/code&gt;).</source>
          <target state="translated">경우 &lt;code&gt;message&lt;/code&gt; 존재하지만, 문자열이나하지도 &lt;b&gt;닐&lt;/b&gt; 이 함수 리턴 &lt;code&gt;message&lt;/code&gt; 추가 처리없이. 그렇지 않으면 호출 스택의 역 추적과 함께 문자열을 반환합니다. 선택적 &lt;code&gt;message&lt;/code&gt; 문자열은 역 추적 시작 부분에 추가됩니다. 선택적 &lt;code&gt;level&lt;/code&gt; 번호는 어느 레벨에서 추적을 시작할지 알려줍니다 (기본값은 1, &lt;code&gt;traceback&lt;/code&gt; 을 호출하는 함수 임).</target>
        </trans-unit>
        <trans-unit id="842cd5b591dfca5b2f8676469b17faefa0a0959f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;modname&lt;/code&gt; is not already present in &lt;a href=&quot;#pdf-package.loaded&quot;&gt;&lt;code&gt;package.loaded&lt;/code&gt;&lt;/a&gt;, calls function &lt;code&gt;openf&lt;/code&gt; with string &lt;code&gt;modname&lt;/code&gt; as an argument and sets the call result in &lt;code&gt;package.loaded[modname]&lt;/code&gt;, as if that function has been called through &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;modname&lt;/code&gt; 이 &lt;a href=&quot;#pdf-package.loaded&quot;&gt; &lt;code&gt;package.loaded&lt;/code&gt; 에&lt;/a&gt; 아직없는 경우 문자열 &lt;code&gt;modname&lt;/code&gt; 을 인수로 사용하여 &lt;code&gt;openf&lt;/code&gt; 함수를 호출 하고 해당 함수가 &lt;a href=&quot;#pdf-require&quot;&gt; &lt;code&gt;require&lt;/code&gt; 를&lt;/a&gt; 통해 호출 된 것처럼 &lt;code&gt;package.loaded[modname]&lt;/code&gt; 에 호출 결과를 설정 합니다 .</target>
        </trans-unit>
        <trans-unit id="c31adda24a7d148cbbeb4abd1c9efc9a5e0f6cc8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;msgh&lt;/code&gt; is 0, then the error object returned on the stack is exactly the original error object. Otherwise, &lt;code&gt;msgh&lt;/code&gt; is the stack index of a &lt;em&gt;message handler&lt;/em&gt;. (This index cannot be a pseudo-index.) In case of runtime errors, this function will be called with the error object and its return value will be the object returned on the stack by &lt;a href=&quot;#lua_pcall&quot;&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;msgh&lt;/code&gt; 는 0, 다음 스택에 반환되는 오류 객체는 정확히 원래 오류 개체입니다. 그렇지 않은 경우 &lt;code&gt;msgh&lt;/code&gt; 는 &lt;em&gt;메시지 핸들러&lt;/em&gt; 의 스택 색인입니다 . (이 인덱스는 의사 인덱스 일 수 없습니다.) 런타임 오류의 경우이 함수는 오류 객체와 함께 호출되며 반환 값은 &lt;a href=&quot;#lua_pcall&quot;&gt; &lt;code&gt;lua_pcall&lt;/code&gt; &lt;/a&gt; 에 의해 스택에서 반환 된 객체 입니다.</target>
        </trans-unit>
        <trans-unit id="51f00954e85aa7f6bdec96453ea0264b6dcaf354" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;msgh&lt;/code&gt; is 0, then the error object returned on the stack is exactly the original error object. Otherwise, &lt;code&gt;msgh&lt;/code&gt; is the stack index of a &lt;em&gt;message handler&lt;/em&gt;. (This index cannot be a pseudo-index.) In case of runtime errors, this handler will be called with the error object and its return value will be the object returned on the stack by &lt;a href=&quot;#lua_pcall&quot;&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;msgh&lt;/code&gt; 는 0, 다음 스택에 반환되는 오류 객체는 정확히 원래 오류 개체입니다. 그렇지 않으면 &lt;code&gt;msgh&lt;/code&gt; 는 &lt;em&gt;메시지 처리기&lt;/em&gt; 의 스택 인덱스입니다 . (이 인덱스는 의사 인덱스가 될 수 없습니다.) 런타임 오류의 경우이 핸들러는 오류 객체와 함께 호출되며 반환 값은 &lt;a href=&quot;#lua_pcall&quot;&gt; &lt;code&gt;lua_pcall&lt;/code&gt; &lt;/a&gt; 에 의해 스택에서 반환 된 객체가됩니다 .</target>
        </trans-unit>
        <trans-unit id="1820013984578d01f9005b716812fa4d2f636236" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;object&lt;/code&gt; does not have a metatable, returns &lt;b&gt;nil&lt;/b&gt;. Otherwise, if the object's metatable has a &lt;code&gt;__metatable&lt;/code&gt; field, returns the associated value. Otherwise, returns the metatable of the given object.</source>
          <target state="translated">경우 &lt;code&gt;object&lt;/code&gt; 메타 테이블이없는, 반환 &lt;b&gt;nil을&lt;/b&gt; . 그렇지 않으면 객체의 메타 테이블에 &lt;code&gt;__metatable&lt;/code&gt; 필드 가 있으면 관련 값을 반환합니다. 그렇지 않으면 주어진 객체의 메타 테이블을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="32f4a130048c4d1f47c68966ce8a1eedff4ff989" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;package.loaded[modname]&lt;/code&gt; is not true, calls the function &lt;code&gt;openf&lt;/code&gt; with the string &lt;code&gt;modname&lt;/code&gt; as an argument and sets the call result to &lt;code&gt;package.loaded[modname]&lt;/code&gt;, as if that function has been called through &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;package.loaded[modname]&lt;/code&gt; 사실이 아니다, 함수 호출 &lt;code&gt;openf&lt;/code&gt; 문자열에 &lt;code&gt;modname&lt;/code&gt; 인수로와에 호출 결과를 설정 &lt;code&gt;package.loaded[modname]&lt;/code&gt; ,이 기능을 통해 호출 된 경우 등 &lt;a href=&quot;#pdf-require&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8540353902febf7d816e3357366d699709e0ebfd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ref&lt;/code&gt; is &lt;a href=&quot;#pdf-LUA_NOREF&quot;&gt;&lt;code&gt;LUA_NOREF&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#pdf-LUA_REFNIL&quot;&gt;&lt;code&gt;LUA_REFNIL&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#luaL_unref&quot;&gt;&lt;code&gt;luaL_unref&lt;/code&gt;&lt;/a&gt; does nothing.</source>
          <target state="translated">경우 &lt;code&gt;ref&lt;/code&gt; 입니다 &lt;a href=&quot;#pdf-LUA_NOREF&quot;&gt; &lt;code&gt;LUA_NOREF&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#pdf-LUA_REFNIL&quot;&gt; &lt;code&gt;LUA_REFNIL&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#luaL_unref&quot;&gt; &lt;code&gt;luaL_unref&lt;/code&gt; 는&lt;/a&gt; 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0ef9686e0e91a6b272fed24ea40a04743ba642b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;repl&lt;/code&gt; is a function, then this function is called every time a match occurs, with all captured substrings passed as arguments, in order.</source>
          <target state="translated">경우 &lt;code&gt;repl&lt;/code&gt; 함수 캡처 된 모든 문자열이 순서대로 인수로 전달과 함께,이 기능은 일치가 발생할 때마다 호출된다.</target>
        </trans-unit>
        <trans-unit id="acbcb36c3a66c6e9e703f8cba5f8b02711833af9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;repl&lt;/code&gt; is a string, then its value is used for replacement. The character &lt;code&gt;%&lt;/code&gt; works as an escape character: any sequence in &lt;code&gt;repl&lt;/code&gt; of the form &lt;code&gt;%&lt;em&gt;d&lt;/em&gt;&lt;/code&gt;, with &lt;em&gt;d&lt;/em&gt; between 1 and 9, stands for the value of the &lt;em&gt;d&lt;/em&gt;-th captured substring. The sequence &lt;code&gt;%0&lt;/code&gt; stands for the whole match. The sequence &lt;code&gt;%%&lt;/code&gt; stands for a single &lt;code&gt;%&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;repl&lt;/code&gt; 문자열이며, 그 값을 대체하는 데 사용됩니다. 문자 &lt;code&gt;%&lt;/code&gt; 의 제어 문자로 작동 : 어떤 시퀀스 &lt;code&gt;repl&lt;/code&gt; 양식의 &lt;code&gt;%&lt;em&gt;d&lt;/em&gt;&lt;/code&gt; 와 &lt;em&gt;D&lt;/em&gt; 1과 9 사이는 상기의 값을 나타내며, &lt;em&gt;D&lt;/em&gt; 부분 문자열 캡처 번째. 시퀀스 &lt;code&gt;%0&lt;/code&gt; 은 전체 일치를 나타냅니다. 시퀀스 &lt;code&gt;%%&lt;/code&gt; 는 단일 &lt;code&gt;%&lt;/code&gt; 를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="ff6ab223165de6902e09a1476a0be29b9ea3f5ce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;repl&lt;/code&gt; is a string, then its value is used for replacement. The character &lt;code&gt;%&lt;/code&gt; works as an escape character: any sequence in &lt;code&gt;repl&lt;/code&gt; of the form &lt;code&gt;%&lt;em&gt;d&lt;/em&gt;&lt;/code&gt;, with &lt;em&gt;d&lt;/em&gt; between 1 and 9, stands for the value of the &lt;em&gt;d&lt;/em&gt;-th captured substring; the sequence &lt;code&gt;%0&lt;/code&gt; stands for the whole match; the sequence &lt;code&gt;%%&lt;/code&gt; stands for a single &lt;code&gt;%&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;repl&lt;/code&gt; 문자열이며, 그 값을 대체하는 데 사용됩니다. 문자 &lt;code&gt;%&lt;/code&gt; 는 제어 문자로 작동 : 어떤 시퀀스 &lt;code&gt;repl&lt;/code&gt; 양식의 &lt;code&gt;%&lt;em&gt;d&lt;/em&gt;&lt;/code&gt; 와 &lt;em&gt;D&lt;/em&gt; 1과 9 사이의 값을 나타내며, &lt;em&gt;D&lt;/em&gt; 부분 문자열 캡처 번째; 시퀀스 &lt;code&gt;%0&lt;/code&gt; 은 전체 일치를 나타냅니다. 시퀀스 &lt;code&gt;%%&lt;/code&gt; 는 단일 &lt;code&gt;%&lt;/code&gt; 를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="e3b705ba3b278873bc97aa05e3303e0da7b4c996" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;repl&lt;/code&gt; is a table, then the table is queried for every match, using the first capture as the key.</source>
          <target state="translated">경우 &lt;code&gt;repl&lt;/code&gt; 테이블이며, 다음 표는 키와 첫 번째 캡처를 사용하여 모든 일치하는 쿼리됩니다.</target>
        </trans-unit>
        <trans-unit id="904a3adc32b5b8e5036d0de4893c822c32415c1c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is &lt;code&gt;NULL&lt;/code&gt;, pushes &lt;b&gt;nil&lt;/b&gt; and returns &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;s&lt;/code&gt; 입니다 &lt;code&gt;NULL&lt;/code&gt; , 푸시는 &lt;b&gt;nil을&lt;/b&gt; 반환에 &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c0fc40539b156bda0a027e224a170becb69976c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;strip&lt;/code&gt; is true, the binary representation may not include all debug information about the function, to save space.</source>
          <target state="translated">&lt;code&gt;strip&lt;/code&gt; 이 true 인 경우 공간을 절약하기 위해 이진 표현에 함수에 대한 모든 디버그 정보가 포함되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d87b247b5a3a2f34515ba0454eae0564f8d8461" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;t&lt;/code&gt; has a metamethod &lt;code&gt;__pairs&lt;/code&gt;, calls it with &lt;code&gt;t&lt;/code&gt; as argument and returns the first three results from the call.</source>
          <target state="translated">경우 &lt;code&gt;t&lt;/code&gt; 는 메타 메소드를 가지고 &lt;code&gt;__pairs&lt;/code&gt; 을 , 그것을 호출 &lt;code&gt;t&lt;/code&gt; 인수로하고 통화에서 처음 세 개의 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6a36ae900eb1d0b16388ad9e7be56d13d79c7b23" translate="yes" xml:space="preserve">
          <source>If a call does not respect some restriction, it returns a false value. Otherwise, the call returns the old limit.</source>
          <target state="translated">호출이 일부 제한을 준수하지 않으면 false 값을 반환합니다. 그렇지 않으면 호출이 이전 제한을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6e5e3c24123e04d1065dc068ae3601efba71ee43" translate="yes" xml:space="preserve">
          <source>If a coroutine yields and is never resumed again, some variables may never go out of scope, and therefore they will never be closed. (These variables are the ones created inside the coroutine and in scope at the point where the coroutine yielded.) Similarly, if a coroutine ends with an error, it does not unwind its stack, so it does not close any variable. In both cases, you can either use finalizers or call &lt;a href=&quot;#pdf-coroutine.close&quot;&gt;&lt;code&gt;coroutine.close&lt;/code&gt;&lt;/a&gt; to close the variables. However, if the coroutine was created through &lt;a href=&quot;#pdf-coroutine.wrap&quot;&gt;&lt;code&gt;coroutine.wrap&lt;/code&gt;&lt;/a&gt;, then its corresponding function will close the coroutine in case of errors.</source>
          <target state="translated">코 루틴이 양보하고 다시 재개되지 않으면 일부 변수는 범위를 벗어나지 않으므로 닫히지 않습니다. (이러한 변수는 코 루틴 내부 및 코 루틴이 생성 된 지점의 범위에서 생성 된 변수입니다.) 마찬가지로 코 루틴이 오류로 종료되면 스택을 해제하지 않으므로 변수를 닫지 않습니다. 두 경우 모두 종료자를 사용하거나 &lt;a href=&quot;#pdf-coroutine.close&quot;&gt; &lt;code&gt;coroutine.close&lt;/code&gt; &lt;/a&gt; 를 호출 하여 변수를 닫을 수 있습니다. 코 루틴을 통해 생성 된 경우에는 &lt;a href=&quot;#pdf-coroutine.wrap&quot;&gt; &lt;code&gt;coroutine.wrap&lt;/code&gt; &lt;/a&gt; , 그 후 해당 함수는 에러의 경우에는 코 루틴을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="aa2adbca5a2a771576b0ebf6701fe853d554fc4c" translate="yes" xml:space="preserve">
          <source>If a weak table is among the resurrected objects in a collection cycle, it may not be properly cleared until the next cycle.</source>
          <target state="translated">수집주기에서 약한 테이블이 부활 된 개체에 속하는 경우 다음주기까지 제대로 지워지지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="976c050d10a007d84f504f71e351c1274cb11c09" translate="yes" xml:space="preserve">
          <source>If an error happens outside any protected environment, Lua calls a &lt;em&gt;panic function&lt;/em&gt; (see &lt;a href=&quot;#lua_atpanic&quot;&gt;&lt;code&gt;lua_atpanic&lt;/code&gt;&lt;/a&gt;) and then calls &lt;code&gt;abort&lt;/code&gt;, thus exiting the host application. Your panic function can avoid this exit by never returning (e.g., doing a long jump to your own recovery point outside Lua).</source>
          <target state="translated">보호 된 환경 외부에서 오류가 발생하면 Lua는 &lt;em&gt;패닉 함수&lt;/em&gt; ( &lt;a href=&quot;#lua_atpanic&quot;&gt; &lt;code&gt;lua_atpanic&lt;/code&gt; &lt;/a&gt; 참조 )를 호출 한 다음 &lt;code&gt;abort&lt;/code&gt; 를 호출 하여 호스트 응용 프로그램을 종료합니다. 패닉 기능은 절대로 돌아 오지 않음으로써 (예 : Lua 외부의 자신의 복구 지점으로 멀리뛰기)이 종료를 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e107b713ef11ceff440f1d9e5663846987c63f66" translate="yes" xml:space="preserve">
          <source>If both the initial value and the step are integers, the loop is done with integers; note that the limit may not be an integer. Otherwise, the three values are converted to floats and the loop is done with floats. Beware of floating-point accuracy in this case.</source>
          <target state="translated">초기 값과 단계가 모두 정수이면 루프는 정수로 수행됩니다. 제한은 정수가 아닐 수 있습니다. 그렇지 않으면 세 값이 부동 소수점으로 변환되고 루프가 부동 소수점으로 수행됩니다. 이 경우 부동 소수점 정확도에주의하십시오.</target>
        </trans-unit>
        <trans-unit id="6a7b831a74ddf1c4c96bf3f5226d336731f2c355" translate="yes" xml:space="preserve">
          <source>If present, an initial assignment has the same semantics of a multiple assignment (see &lt;a href=&quot;#3.3.3&quot;&gt;&amp;sect;3.3.3&lt;/a&gt;). Otherwise, all variables are initialized with &lt;b&gt;nil&lt;/b&gt;.</source>
          <target state="translated">존재하는 경우, 초기 할당은 다중 할당과 동일한 의미를 갖습니다 ( &lt;a href=&quot;#3.3.3&quot;&gt;&amp;sect;3.3.3&lt;/a&gt; 참조 ). 그렇지 않으면 모든 변수가 &lt;b&gt;nil&lt;/b&gt; 로 초기화됩니다 .</target>
        </trans-unit>
        <trans-unit id="55db45ca89124ba7a270035150611f949eb9d322" translate="yes" xml:space="preserve">
          <source>If several to-be-closed variables go out of scope at the same event, they are closed in the reverse order that they were declared.</source>
          <target state="translated">닫힐 예정인 여러 변수가 동일한 이벤트에서 범위를 벗어나면 선언 된 역순으로 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="d10ce6dce1cf5ed21ab267244f3f1b4e5f1c53a0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;time&lt;/code&gt; argument is present, this is the time to be formatted (see the &lt;a href=&quot;#pdf-os.time&quot;&gt;&lt;code&gt;os.time&lt;/code&gt;&lt;/a&gt; function for a description of this value). Otherwise, &lt;code&gt;date&lt;/code&gt; formats the current time.</source>
          <target state="translated">상기 중간 &lt;code&gt;time&lt;/code&gt; 인자가 존재하고,이 포맷되는 시간 (투시이다 &lt;a href=&quot;#pdf-os.time&quot;&gt; &lt;code&gt;os.time&lt;/code&gt; 의&lt;/a&gt; 이 값에 대한 설명 기능). 그렇지 않으면 &lt;code&gt;date&lt;/code&gt; 는 현재 시간을 형식화합니다.</target>
        </trans-unit>
        <trans-unit id="445b1cd7605edb6c9a09a49501ea3688f7a25284" translate="yes" xml:space="preserve">
          <source>If the coroutine runs without any errors, &lt;code&gt;resume&lt;/code&gt; returns &lt;b&gt;true&lt;/b&gt; plus any values passed to &lt;code&gt;yield&lt;/code&gt; (when the coroutine yields) or any values returned by the body function (when the coroutine terminates). If there is any error, &lt;code&gt;resume&lt;/code&gt; returns &lt;b&gt;false&lt;/b&gt; plus the error message.</source>
          <target state="translated">코 루틴이 오류없이 실행되면 &lt;code&gt;resume&lt;/code&gt; 은 &lt;b&gt;true를&lt;/b&gt; 반환 하고 &lt;code&gt;yield&lt;/code&gt; 전달 된 값 (코 루틴이 생성 될 때) 또는 body 함수가 반환 한 값 (코 루틴이 종료 될 때)을 반환합니다. 오류가 있으면 &lt;code&gt;resume&lt;/code&gt; 은 &lt;b&gt;false&lt;/b&gt; 와 오류 메시지를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="7b6f2b834df4a30b4ac80f0070150d4a65977018" translate="yes" xml:space="preserve">
          <source>If the function argument &lt;code&gt;arg&lt;/code&gt; is a number, returns this number as a &lt;code&gt;lua_Number&lt;/code&gt;. If this argument is absent or is &lt;b&gt;nil&lt;/b&gt;, returns &lt;code&gt;d&lt;/code&gt;. Otherwise, raises an error.</source>
          <target state="translated">함수 인수 &lt;code&gt;arg&lt;/code&gt; 가 숫자이면이 숫자를 &lt;code&gt;lua_Number&lt;/code&gt; 로 반환합니다 . 이 인수가 없거나 &lt;b&gt;nil&lt;/b&gt; 이면 &lt;code&gt;d&lt;/code&gt; 를 반환합니다 . 그렇지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d55f1311c7ac9c86cbdbbe5af34159b56481c975" translate="yes" xml:space="preserve">
          <source>If the function argument &lt;code&gt;arg&lt;/code&gt; is a number, returns this number. If this argument is absent or is &lt;b&gt;nil&lt;/b&gt;, returns &lt;code&gt;d&lt;/code&gt;. Otherwise, raises an error.</source>
          <target state="translated">함수 인수 &lt;code&gt;arg&lt;/code&gt; 가 숫자이면이 숫자를 반환합니다. 이 인수가 없거나 &lt;b&gt;nil&lt;/b&gt; 이면 &lt;code&gt;d&lt;/code&gt; 를 반환합니다 . 그렇지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1d6a415374d2508756a64e53d2de95963256a6b5" translate="yes" xml:space="preserve">
          <source>If the function argument &lt;code&gt;arg&lt;/code&gt; is a string, returns this string. If this argument is absent or is &lt;b&gt;nil&lt;/b&gt;, returns &lt;code&gt;d&lt;/code&gt;. Otherwise, raises an error.</source>
          <target state="translated">함수 인수 &lt;code&gt;arg&lt;/code&gt; 가 문자열이면이 문자열을 반환합니다. 이 인수가 없거나 &lt;b&gt;nil&lt;/b&gt; 이면 &lt;code&gt;d&lt;/code&gt; 를 반환합니다 . 그렇지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6e17c7a9a9f53d843ebe48aadc33c874ae824510" translate="yes" xml:space="preserve">
          <source>If the function argument &lt;code&gt;arg&lt;/code&gt; is an integer (or convertible to an integer), returns this integer. If this argument is absent or is &lt;b&gt;nil&lt;/b&gt;, returns &lt;code&gt;d&lt;/code&gt;. Otherwise, raises an error.</source>
          <target state="translated">함수 인수 &lt;code&gt;arg&lt;/code&gt; 가 정수 (또는 정수로 변환 가능) 인 경우이 정수를 리턴합니다. 이 인수가 없거나 &lt;b&gt;nil&lt;/b&gt; 이면 &lt;code&gt;d&lt;/code&gt; 를 반환합니다 . 그렇지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6955dc842a401e17e5808166f841d89d4b08032c" translate="yes" xml:space="preserve">
          <source>If the function argument &lt;code&gt;arg&lt;/code&gt; is an integer (or it is convertible to an integer), returns this integer. If this argument is absent or is &lt;b&gt;nil&lt;/b&gt;, returns &lt;code&gt;d&lt;/code&gt;. Otherwise, raises an error.</source>
          <target state="translated">함수 인수 &lt;code&gt;arg&lt;/code&gt; 가 정수 (또는 정수로 변환 가능)이면이 정수를 반환합니다. 이 인수가 없거나 &lt;b&gt;nil&lt;/b&gt; 이면 &lt;code&gt;d&lt;/code&gt; 를 반환합니다 . 그렇지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f1e13f8872ac6f0a738c6612fcccd3954091bb67" translate="yes" xml:space="preserve">
          <source>If the global variable &lt;a id=&quot;pdf-_PROMPT&quot;&gt;&lt;code&gt;_PROMPT&lt;/code&gt;&lt;/a&gt; contains a string, then its value is used as the prompt. Similarly, if the global variable &lt;a id=&quot;pdf-_PROMPT2&quot;&gt;&lt;code&gt;_PROMPT2&lt;/code&gt;&lt;/a&gt; contains a string, its value is used as the secondary prompt (issued during incomplete statements).</source>
          <target state="translated">글로벌 변수 &lt;a id=&quot;pdf-_PROMPT&quot;&gt; &lt;code&gt;_PROMPT&lt;/code&gt; &lt;/a&gt; 에 문자열이 포함 된 경우 해당 값이 프롬프트로 사용됩니다. 마찬가지로 전역 변수 &lt;a id=&quot;pdf-_PROMPT2&quot;&gt; &lt;code&gt;_PROMPT2&lt;/code&gt; &lt;/a&gt; 에 문자열이 포함되어 있으면 해당 값이 2 차 프롬프트 (불완전한 명령문 중에 발행 됨)로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="69dd50d5154f10c839f6adf50538404208ab3819" translate="yes" xml:space="preserve">
          <source>If the last field in the list has the form &lt;code&gt;exp&lt;/code&gt; and the expression is a function call or a vararg expression, then all values returned by this expression enter the list consecutively (see &lt;a href=&quot;#3.4.10&quot;&gt;&amp;sect;3.4.10&lt;/a&gt;).</source>
          <target state="translated">목록의 마지막 필드가 &lt;code&gt;exp&lt;/code&gt; 형식 이고 표현식이 함수 호출 또는 vararg 표현식 인 경우이 표현식에서 리턴 된 모든 값이 목록을 연속적으로 입력합니다 ( &lt;a href=&quot;#3.4.10&quot;&gt;&amp;sect;3.4.10&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="c2c41a18b7f1f35462130fbee68e6deb46c899ae" translate="yes" xml:space="preserve">
          <source>If the metatable of &lt;code&gt;v&lt;/code&gt; has a &lt;code&gt;__tostring&lt;/code&gt; field, then &lt;code&gt;tostring&lt;/code&gt; calls the corresponding value with &lt;code&gt;v&lt;/code&gt; as argument, and uses the result of the call as its result.</source>
          <target state="translated">&lt;code&gt;v&lt;/code&gt; 의 메타 테이블에 &lt;code&gt;__tostring&lt;/code&gt; 필드 가 있으면 &lt;code&gt;tostring&lt;/code&gt; 은 &lt;code&gt;v&lt;/code&gt; 를 인수로 사용하여 해당 값을 호출하고 호출 결과를 결과로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e667a50bd3d336c5fd3f6afdae1b6efc47c42fa7" translate="yes" xml:space="preserve">
          <source>If the metatable of &lt;code&gt;v&lt;/code&gt; has a &lt;code&gt;__tostring&lt;/code&gt; field, then &lt;code&gt;tostring&lt;/code&gt; calls the corresponding value with &lt;code&gt;v&lt;/code&gt; as argument, and uses the result of the call as its result. Otherwise, if the metatable of &lt;code&gt;v&lt;/code&gt; has a &lt;code&gt;__name&lt;/code&gt; field with a string value, &lt;code&gt;tostring&lt;/code&gt; may use that string in its final result.</source>
          <target state="translated">&lt;code&gt;v&lt;/code&gt; 의 메타 테이블에 &lt;code&gt;__tostring&lt;/code&gt; 필드 가있는 경우 &lt;code&gt;tostring&lt;/code&gt; 은 &lt;code&gt;v&lt;/code&gt; 를 인수로 사용하여 해당 값을 호출하고 호출 결과를 결과로 사용합니다. 그렇지 않고 &lt;code&gt;v&lt;/code&gt; 의 메타 테이블에 문자열 값 이있는 &lt;code&gt;__name&lt;/code&gt; 필드가있는 경우 &lt;code&gt;tostring&lt;/code&gt; 은 최종 결과에서 해당 문자열을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03e2a2337d10f7a7f932c47ab9c9e3292e20a274" translate="yes" xml:space="preserve">
          <source>If the object at index &lt;code&gt;obj&lt;/code&gt; has a metatable and this metatable has a field &lt;code&gt;e&lt;/code&gt;, this function calls this field passing the object as its only argument. In this case this function returns true and pushes onto the stack the value returned by the call. If there is no metatable or no metamethod, this function returns false (without pushing any value on the stack).</source>
          <target state="translated">인덱스 &lt;code&gt;obj&lt;/code&gt; 의 객체에 메타 테이블이 있고이 메타 테이블에 필드 &lt;code&gt;e&lt;/code&gt; 가있는 경우이 함수는이 필드를 호출하여 객체를 유일한 인수로 전달합니다. 이 경우이 함수는 true를 반환하고 호출에 의해 반환 된 값을 스택으로 푸시합니다. 메타 테이블이 없거나 메타 메소드가없는 경우이 함수는 스택의 값을 누르지 않고 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4b1b45d6011ef45970bc5881245d1e395b5b10f6" translate="yes" xml:space="preserve">
          <source>If the object at index &lt;code&gt;obj&lt;/code&gt; has a metatable and this metatable has a field &lt;code&gt;e&lt;/code&gt;, this function calls this field passing the object as its only argument. In this case this function returns true and pushes onto the stack the value returned by the call. If there is no metatable or no metamethod, this function returns false without pushing any value on the stack.</source>
          <target state="translated">인덱스 &lt;code&gt;obj&lt;/code&gt; 의 객체에 메타 테이블이 있고이 메타 테이블에 &lt;code&gt;e&lt;/code&gt; 필드가있는 경우이 함수는 객체를 유일한 인수로 전달하는이 필드를 호출합니다. 이 경우이 함수는 true를 반환하고 호출에서 반환 된 값을 스택에 푸시합니다. 메타 테이블이 없거나 메타 메서드가없는 경우이 함수는 스택에 값을 입력하지 않고 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5290383f51a42a73a3f52ae1f2cee8c56a74c3fd" translate="yes" xml:space="preserve">
          <source>If the object at the top of the stack is &lt;b&gt;nil&lt;/b&gt;, &lt;a href=&quot;#luaL_ref&quot;&gt;&lt;code&gt;luaL_ref&lt;/code&gt;&lt;/a&gt; returns the constant &lt;a id=&quot;pdf-LUA_REFNIL&quot;&gt;&lt;code&gt;LUA_REFNIL&lt;/code&gt;&lt;/a&gt;. The constant &lt;a id=&quot;pdf-LUA_NOREF&quot;&gt;&lt;code&gt;LUA_NOREF&lt;/code&gt;&lt;/a&gt; is guaranteed to be different from any reference returned by &lt;a href=&quot;#luaL_ref&quot;&gt;&lt;code&gt;luaL_ref&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">스택 맨 위의 객체가 &lt;b&gt;nil&lt;/b&gt; 이면 &lt;a href=&quot;#luaL_ref&quot;&gt; &lt;code&gt;luaL_ref&lt;/code&gt; &lt;/a&gt; 는 상수 &lt;a id=&quot;pdf-LUA_REFNIL&quot;&gt; &lt;code&gt;LUA_REFNIL&lt;/code&gt; 을&lt;/a&gt; 반환합니다 . 상수 &lt;a id=&quot;pdf-LUA_NOREF&quot;&gt; &lt;code&gt;LUA_NOREF&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;#luaL_ref&quot;&gt; &lt;code&gt;luaL_ref&lt;/code&gt; 에&lt;/a&gt; 의해 리턴 된 참조와 다른 것이 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="ad1fb87f39a8d1517edf25e3706b1bb571e2c0af" translate="yes" xml:space="preserve">
          <source>If the object on the top of the stack is &lt;b&gt;nil&lt;/b&gt;, &lt;a href=&quot;#luaL_ref&quot;&gt;&lt;code&gt;luaL_ref&lt;/code&gt;&lt;/a&gt; returns the constant &lt;a id=&quot;pdf-LUA_REFNIL&quot;&gt;&lt;code&gt;LUA_REFNIL&lt;/code&gt;&lt;/a&gt;. The constant &lt;a id=&quot;pdf-LUA_NOREF&quot;&gt;&lt;code&gt;LUA_NOREF&lt;/code&gt;&lt;/a&gt; is guaranteed to be different from any reference returned by &lt;a href=&quot;#luaL_ref&quot;&gt;&lt;code&gt;luaL_ref&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">스택 맨 위에있는 객체가 &lt;b&gt;nil&lt;/b&gt; 이면 &lt;a href=&quot;#luaL_ref&quot;&gt; &lt;code&gt;luaL_ref&lt;/code&gt; &lt;/a&gt; 는 상수 &lt;a id=&quot;pdf-LUA_REFNIL&quot;&gt; &lt;code&gt;LUA_REFNIL&lt;/code&gt; 을&lt;/a&gt; 반환합니다 . 상수 &lt;a id=&quot;pdf-LUA_NOREF&quot;&gt; &lt;code&gt;LUA_NOREF&lt;/code&gt; 는&lt;/a&gt; 에 의해 반환 된 참조 다르게 보장 &lt;a href=&quot;#luaL_ref&quot;&gt; &lt;code&gt;luaL_ref&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="acec67c576442c0c5a9f70f70aebd00845c9de45" translate="yes" xml:space="preserve">
          <source>If the optional second argument &lt;code&gt;close&lt;/code&gt; is true, closes the Lua state before exiting.</source>
          <target state="translated">선택적 두 번째 인수 &lt;code&gt;close&lt;/code&gt; 가 true이면 종료하기 전에 Lua 상태를 닫습니다.</target>
        </trans-unit>
        <trans-unit id="3b0396e6bb027f8d7ab0995f60b457d88ddf9d43" translate="yes" xml:space="preserve">
          <source>If the pattern has captures, then in a successful match the captured values are also returned, after the two indices.</source>
          <target state="translated">패턴에 캡처가 있으면 성공적인 일치에서 두 개의 인덱스 뒤에 캡처 된 값도 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="c6c1efa56f5f1f5e27073806e14cba57116db8fa" translate="yes" xml:space="preserve">
          <source>If the registry already has the key &lt;code&gt;tname&lt;/code&gt;, returns 0. Otherwise, creates a new table to be used as a metatable for userdata, adds to this new table the pair &lt;code&gt;__name = tname&lt;/code&gt;, adds to the registry the pair &lt;code&gt;[tname] = new table&lt;/code&gt;, and returns 1.</source>
          <target state="translated">레지스트리에 이미 &lt;code&gt;tname&lt;/code&gt; 키가 있으면 0을 반환합니다. 그렇지 않으면 사용자 데이터에 대한 메타 테이블로 사용할 새 테이블을 &lt;code&gt;__name = tname&lt;/code&gt; 새 테이블에 __name = tname 쌍을 추가하고 레지스트리에 &lt;code&gt;[tname] = new table&lt;/code&gt; 쌍을 추가 합니다. , 1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="55dfb22871228c3e2bce9a6e070cde79a0f26198" translate="yes" xml:space="preserve">
          <source>If the registry already has the key &lt;code&gt;tname&lt;/code&gt;, returns 0. Otherwise, creates a new table to be used as a metatable for userdata, adds to this new table the pair &lt;code&gt;__name = tname&lt;/code&gt;, adds to the registry the pair &lt;code&gt;[tname] = new table&lt;/code&gt;, and returns 1. (The entry &lt;code&gt;__name&lt;/code&gt; is used by some error-reporting functions.)</source>
          <target state="translated">레지스트리에 키 &lt;code&gt;tname&lt;/code&gt; 이 이미 있으면 0을 리턴합니다. 그렇지 않으면 userdata의 메타 테이블로 사용할 새 테이블을 작성하고이 새 테이블에 쌍 &lt;code&gt;__name = tname&lt;/code&gt; 을 추가하고 레지스트리에 &lt;code&gt;[tname] = new table&lt;/code&gt; 쌍을 추가 하십시오. 를 반환하고 1을 반환합니다. &lt;code&gt;__name&lt;/code&gt; 항목 은 일부 오류보고 기능에서 사용됩니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
