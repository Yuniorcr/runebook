<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="lua">
    <body>
      <group id="lua">
        <trans-unit id="aa39944ec03b1ec2d3455e9418607f7822bf72a3" translate="yes" xml:space="preserve">
          <source>If the resulting function has upvalues, its first upvalue is set to the value of the global environment stored at index &lt;code&gt;LUA_RIDX_GLOBALS&lt;/code&gt; in the registry (see &lt;a href=&quot;#4.3&quot;&gt;&amp;sect;4.3&lt;/a&gt;). When loading main chunks, this upvalue will be the &lt;code&gt;_ENV&lt;/code&gt; variable (see &lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt;). Other upvalues are initialized with &lt;b&gt;nil&lt;/b&gt;.</source>
          <target state="translated">얻어진 함수 upvalues있는 경우, 그 제 upvalue가 인덱스 저장 지구 환경의 값으로 설정된다 &lt;code&gt;LUA_RIDX_GLOBALS&lt;/code&gt; 레지스트리 (참조 &lt;a href=&quot;#4.3&quot;&gt;&amp;sect;4.3&lt;/a&gt; ). 메인 청크를로드 할 때이 upvalue는 &lt;code&gt;_ENV&lt;/code&gt; 변수가됩니다 ( &lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt; 참조 ). 다른 upvalue는 &lt;b&gt;nil&lt;/b&gt; 로 초기화됩니다 .</target>
        </trans-unit>
        <trans-unit id="afde979ca5fc178b1fdd97cd1a0eb2a3d73cbc9c" translate="yes" xml:space="preserve">
          <source>If the resulting function has upvalues, its first upvalue is set to the value of the global environment stored at index &lt;code&gt;LUA_RIDX_GLOBALS&lt;/code&gt; in the registry (see &lt;a href=&quot;#4.5&quot;&gt;&amp;sect;4.5&lt;/a&gt;). When loading main chunks, this upvalue will be the &lt;code&gt;_ENV&lt;/code&gt; variable (see &lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt;). Other upvalues are initialized with &lt;b&gt;nil&lt;/b&gt;.</source>
          <target state="translated">결과 함수에 업 값이 있으면 첫 번째 업 값은 레지스트리의 인덱스 &lt;code&gt;LUA_RIDX_GLOBALS&lt;/code&gt; 에 저장된 글로벌 환경의 값으로 설정됩니다 ( &lt;a href=&quot;#4.5&quot;&gt;&amp;sect;4.5&lt;/a&gt; 참조 ). 주요 청크를로드 할 때이 업값은 &lt;code&gt;_ENV&lt;/code&gt; 변수가됩니다 ( &lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt; 참조 ). 다른 상한값은 &lt;b&gt;nil&lt;/b&gt; 로 초기화됩니다 .</target>
        </trans-unit>
        <trans-unit id="275e9e5485299a94935ea18cd6064e91a7392a15" translate="yes" xml:space="preserve">
          <source>If the resulting function has upvalues, the first upvalue is set to the value of &lt;code&gt;env&lt;/code&gt;, if that parameter is given, or to the value of the global environment. Other upvalues are initialized with &lt;b&gt;nil&lt;/b&gt;. (When you load a main chunk, the resulting function will always have exactly one upvalue, the &lt;code&gt;_ENV&lt;/code&gt; variable (see &lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt;). However, when you load a binary chunk created from a function (see &lt;a href=&quot;#pdf-string.dump&quot;&gt;&lt;code&gt;string.dump&lt;/code&gt;&lt;/a&gt;), the resulting function can have an arbitrary number of upvalues.) All upvalues are fresh, that is, they are not shared with any other function.</source>
          <target state="translated">결과 함수에 upvalue가있는 경우 첫 번째 upvalue는 &lt;code&gt;env&lt;/code&gt; 값 , 해당 매개 변수가 제공되는 경우 또는 글로벌 환경의 값으로 설정됩니다. 다른 상한값은 &lt;b&gt;nil&lt;/b&gt; 로 초기화됩니다 . (메인 청크를로드 할 때 결과 함수에는 항상 &lt;code&gt;_ENV&lt;/code&gt; 변수 ( &lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt; 참조 )의 단 하나의 상위 값이 있습니다. 그러나 함수에서 작성된 이진 청크를로드하면 ( &lt;a href=&quot;#pdf-string.dump&quot;&gt; &lt;code&gt;string.dump&lt;/code&gt; &lt;/a&gt; 참조 ) 결과 함수는 모든 업 밸류는 신선합니다. 즉, 다른 함수와 공유되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2440107420c56013ca178ce5e9d33aaab09429e6" translate="yes" xml:space="preserve">
          <source>If the third expression (the step) is absent, then a step of 1 is used.</source>
          <target state="translated">세 번째 표현식 (단계)이 없으면 1 단계가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b6867da3d50ebe1ffe1a4f6e7b8d21bdab6c2e11" translate="yes" xml:space="preserve">
          <source>If the userdata does not have that value, pushes &lt;b&gt;nil&lt;/b&gt; and returns &lt;a href=&quot;#pdf-LUA_TNONE&quot;&gt;&lt;code&gt;LUA_TNONE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">사용자 데이터에 해당 값이 없으면 &lt;b&gt;nil을&lt;/b&gt; 푸시 하고 &lt;a href=&quot;#pdf-LUA_TNONE&quot;&gt; &lt;code&gt;LUA_TNONE&lt;/code&gt; 을&lt;/a&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="30fdcf02dde9756f746a6d73d9bf8f5049261a0f" translate="yes" xml:space="preserve">
          <source>If the value &lt;code&gt;x&lt;/code&gt; is convertible to an integer, returns that integer. Otherwise, returns &lt;b&gt;fail&lt;/b&gt;.</source>
          <target state="translated">값 &lt;code&gt;x&lt;/code&gt; 를 정수로 변환 할 수있는 경우 해당 정수를 반환합니다. 그렇지 않으면 &lt;b&gt;fail을&lt;/b&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="876e4bd473070df65d9eb13c67cd61272830f8dd" translate="yes" xml:space="preserve">
          <source>If the value &lt;code&gt;x&lt;/code&gt; is convertible to an integer, returns that integer. Otherwise, returns &lt;b&gt;nil&lt;/b&gt;.</source>
          <target state="translated">값 &lt;code&gt;x&lt;/code&gt; 를 정수로 변환 할 수 있으면 해당 정수를 반환합니다. 그렇지 않으면 &lt;b&gt;nil을&lt;/b&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="94b7f8b2fd53356736681842c541a85531d3f0c6" translate="yes" xml:space="preserve">
          <source>If the value at the given index has a metatable, the function pushes that metatable onto the stack and returns 1. Otherwise, the function returns 0 and pushes nothing on the stack.</source>
          <target state="translated">주어진 인덱스의 값에 메타 테이블이있는 경우 함수는 해당 메타 테이블을 스택으로 푸시하고 1을 리턴합니다. 그렇지 않으면 0을 리턴하고 스택에서 아무것도 푸시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9441049c218d493b700b38a8bccd81b0ab58775b" translate="yes" xml:space="preserve">
          <source>If the value at the given index is a full userdata, returns its block address. If the value is a light userdata, returns its pointer. Otherwise, returns &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">주어진 인덱스의 값이 전체 사용자 데이터 인 경우 해당 블록 주소를 반환합니다. 값이 일반 사용자 데이터 인 경우 포인터를 리턴합니다. 그렇지 않으면 &lt;code&gt;NULL&lt;/code&gt; 을 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="9c5badf0b625046b21174cf23ead77965326f8cc" translate="yes" xml:space="preserve">
          <source>If the value at the given index is a full userdata, returns its memory-block address. If the value is a light userdata, returns its value (a pointer). Otherwise, returns &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">지정된 인덱스의 값이 전체 사용자 데이터이면 해당 메모리 블록 주소를 반환합니다. 값이 가벼운 사용자 데이터이면 해당 값 (포인터)을 반환합니다. 그렇지 않으면 &lt;code&gt;NULL&lt;/code&gt; 을 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="4632120bcb257e680797b7d6b495d6ae5165f498" translate="yes" xml:space="preserve">
          <source>If the value has a metatable with a &lt;code&gt;__tostring&lt;/code&gt; field, then &lt;code&gt;luaL_tolstring&lt;/code&gt; calls the corresponding metamethod with the value as argument, and uses the result of the call as its result.</source>
          <target state="translated">값이 함께 메타 테이블이 있으면 &lt;code&gt;__tostring&lt;/code&gt; 필드 다음 &lt;code&gt;luaL_tolstring&lt;/code&gt; 는 인수 값에 대응하는 메타 메소드를 호출하고, 그 결과로서 호출의 결과를 사용한다.</target>
        </trans-unit>
        <trans-unit id="d98fc2205300b7d347d732dbb4a9c377f9f7a2f3" translate="yes" xml:space="preserve">
          <source>If the value returned by the table query or by the function call is a string or a number, then it is used as the replacement string; otherwise, if it is &lt;b&gt;false&lt;/b&gt; or &lt;b&gt;nil&lt;/b&gt;, then there is no replacement (that is, the original match is kept in the string).</source>
          <target state="translated">테이블 조회 또는 함수 호출이 리턴 한 값이 문자열 또는 숫자 인 경우 대체 문자열로 사용됩니다. 그렇지 않으면 &lt;b&gt;false&lt;/b&gt; 또는 &lt;b&gt;nil&lt;/b&gt; 인 경우 대체가 없습니다 (즉, 원래 일치 항목이 문자열에 유지됨).</target>
        </trans-unit>
        <trans-unit id="ff3df837749e4825f721110ceca71ee53b60c2f6" translate="yes" xml:space="preserve">
          <source>If there are no syntactic errors, &lt;code&gt;load&lt;/code&gt; returns the compiled chunk as a function; otherwise, it returns &lt;b&gt;fail&lt;/b&gt; plus the error message.</source>
          <target state="translated">구문 오류가없는 경우 &lt;code&gt;load&lt;/code&gt; 는 컴파일 된 청크를 함수로 반환합니다. 그렇지 않으면 &lt;b&gt;실패&lt;/b&gt; 와 오류 메시지를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="ed5b55c4ebb32433c98e6d7ba29a004a9265213b" translate="yes" xml:space="preserve">
          <source>If there are no syntactic errors, returns the compiled chunk as a function; otherwise, returns &lt;b&gt;nil&lt;/b&gt; plus the error message.</source>
          <target state="translated">구문 오류가 없으면 컴파일 된 청크를 함수로 리턴합니다. 그렇지 않으면, &lt;b&gt;nil&lt;/b&gt; 과 오류 메시지를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="94d76ea95ae9d04310650a4926fa6e03a91eead5" translate="yes" xml:space="preserve">
          <source>If there is any error loading or running the module, or if it cannot find any loader for the module, then &lt;code&gt;require&lt;/code&gt; raises an error.</source>
          <target state="translated">이 오류를로드하거나 실행중인 모듈, 또는 모듈에 대한 로더를 찾을 수없는 경우, 다음 경우 &lt;code&gt;require&lt;/code&gt; 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="ce92cea2e328d0390d4ad8b2857051594fc6df6d" translate="yes" xml:space="preserve">
          <source>If there is any error while running a closing method, that error is handled like an error in the regular code where the variable was defined. However, Lua may call the method one more time.</source>
          <target state="translated">클로징 메소드를 실행하는 동안 오류가 발생하면 해당 오류는 변수가 정의 된 일반 코드의 오류처럼 처리됩니다. 그러나 Lua는 메서드를 한 번 더 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a6dbd64b84e48ca7300b890ff312675543ee0f6" translate="yes" xml:space="preserve">
          <source>If there is no script in the call, the interpreter name goes to index 0, followed by the other arguments. For instance, the call</source>
          <target state="translated">호출에 스크립트가 없으면 인터프리터 이름이 색인 0으로 이동 한 다음 다른 인수가옵니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="2f77907008466a9df684a2c79024f9604e714a0c" translate="yes" xml:space="preserve">
          <source>If this option is given together with option '&lt;code&gt;f&lt;/code&gt;', its table is pushed after the function.</source>
          <target state="translated">이 옵션이 옵션 ' &lt;code&gt;f&lt;/code&gt; ' 와 함께 제공 되면 해당 테이블은 기능 후에 푸시됩니다.</target>
        </trans-unit>
        <trans-unit id="232d4cb58dd3dc6d647132e58f5ddab6d89f9ef6" translate="yes" xml:space="preserve">
          <source>If you know beforehand the maximum size of the resulting string, you can use the buffer like this:</source>
          <target state="translated">결과 문자열의 최대 크기를 미리 알고 있다면 다음과 같이 버퍼를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eda48319758ff6bba8bcf8cb507f6d311265837c" translate="yes" xml:space="preserve">
          <source>If you know beforehand the total size of the resulting string, you can use the buffer like this:</source>
          <target state="translated">결과 문자열의 총 크기를 미리 알고 있다면 다음과 같이 버퍼를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e57af394dbc6d5a626668daa30c3f8e2018059e" translate="yes" xml:space="preserve">
          <source>If you set the step multiplier to a very large number (larger than 10% of the maximum number of bytes that the program may use), the collector behaves like a stop-the-world collector. If you then set the pause to 200, the collector behaves as in old Lua versions, doing a complete collection every time Lua doubles its memory usage.</source>
          <target state="translated">단계 승수를 매우 큰 수 (프로그램이 사용할 수있는 최대 바이트 수의 10 %보다 큰)로 설정하면 콜렉터는 세계 정지 콜렉터처럼 작동합니다. 일시 중지를 200으로 설정하면 수집기는 이전 Lua 버전에서와 같이 동작하며 Lua가 메모리 사용량을 두 배로 늘릴 때마다 전체 수집을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="29af696fcc1cdd39d14ec551ccbd633c6f06b895" translate="yes" xml:space="preserve">
          <source>If, after the translation of negative indices, &lt;code&gt;i&lt;/code&gt; is less than 1, it is corrected to 1. If &lt;code&gt;j&lt;/code&gt; is greater than the string length, it is corrected to that length. If, after these corrections, &lt;code&gt;i&lt;/code&gt; is greater than &lt;code&gt;j&lt;/code&gt;, the function returns the empty string.</source>
          <target state="translated">음수 색인을 변환 한 후 &lt;code&gt;i&lt;/code&gt; 가 1보다 작 으면 1로 수정됩니다. &lt;code&gt;j&lt;/code&gt; 가 문자열 길이보다 크면 해당 길이로 수정됩니다. 이러한 수정 후 &lt;code&gt;i&lt;/code&gt; 가 &lt;code&gt;j&lt;/code&gt; 보다 큰 경우 함수는 빈 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a9f42e3411c1cd363cce85bb39824046e38afc0c" translate="yes" xml:space="preserve">
          <source>In POSIX systems, this function also creates a file with that name, to avoid security risks. (Someone else might create the file with wrong permissions in the time between getting the name and creating the file.) You still have to open the file to use it and to remove it (even if you do not use it).</source>
          <target state="translated">POSIX 시스템에서이 기능은 보안 위험을 피하기 위해 해당 이름으로 파일을 생성합니다. (다른 사람이 이름을 가져 와서 파일을 만드는 사이에 잘못된 권한으로 파일을 만들 수 있습니다.) 파일을 사용하고 제거하려면 파일을 열어야합니다 (사용하지 않더라도).</target>
        </trans-unit>
        <trans-unit id="6e188c4467182589f4f24a348f7b82d5dc4eb843" translate="yes" xml:space="preserve">
          <source>In a conversion from integer to float, if the integer value has an exact representation as a float, that is the result. Otherwise, the conversion gets the nearest higher or the nearest lower representable value. This kind of conversion never fails.</source>
          <target state="translated">정수에서 부동 소수점으로의 변환에서 정수 값이 부동 소수점으로 정확하게 표현되면 결과입니다. 그렇지 않으면 변환이 가장 근접한 가장 높거나 가장 낮은 표현 가능한 값을 얻습니다. 이런 종류의 전환은 결코 실패하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ea37a32b7be8a539051904217ddd263915df9e9c" translate="yes" xml:space="preserve">
          <source>In a function call, first prefixexp and args are evaluated. If the value of prefixexp has type &lt;em&gt;function&lt;/em&gt;, then this function is called with the given arguments. Otherwise, if present, the prefixexp &lt;code&gt;__call&lt;/code&gt; metamethod is called: its first argument is the value of prefixexp, followed by the original call arguments (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;).</source>
          <target state="translated">함수 호출에서 첫 번째 prefixexp 및 args가 평가됩니다. prefixexp의 값에 &lt;em&gt;function&lt;/em&gt; 유형 이 있으면이 함수는 주어진 인수와 함께 호출됩니다. 그렇지 않으면, 존재하는 경우 prefixexp &lt;code&gt;__call&lt;/code&gt; 메타 메서드가 호출됩니다. 첫 번째 인수는 prefixexp의 값이고 그 뒤에 원래 호출 인수가 이어집니다 ( &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="97b9aa4de4630491dcb4d24142294547e0b16cc1" translate="yes" xml:space="preserve">
          <source>In a function call, first prefixexp and args are evaluated. If the value of prefixexp has type &lt;em&gt;function&lt;/em&gt;, then this function is called with the given arguments. Otherwise, the prefixexp &quot;call&quot; metamethod is called, having as first parameter the value of prefixexp, followed by the original call arguments (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;).</source>
          <target state="translated">함수 호출에서 첫 번째 prefixexp 및 args가 평가됩니다. prefixexp의 값에 &lt;em&gt;function&lt;/em&gt; 유형 이있는 경우이 함수는 제공된 인수와 함께 호출됩니다. 그렇지 않으면 prefixexp &quot;call&quot;메타 메소드가 호출되며 prefixexp의 값을 첫 번째 매개 변수로 사용하고 그 뒤에 원래 호출 인수가 &lt;a href=&quot;#2.4&quot;&gt;옵니다&lt;/a&gt; ( &amp;sect;2.4 참조 ).</target>
        </trans-unit>
        <trans-unit id="49949926795e2c68295a80e05d4c59850e0ba7a4" translate="yes" xml:space="preserve">
          <source>In addition to the previous list, the interpreter also respects the following keys in metatables: &lt;code&gt;__gc&lt;/code&gt; (see &lt;a href=&quot;#2.5.3&quot;&gt;&amp;sect;2.5.3&lt;/a&gt;), &lt;code&gt;__close&lt;/code&gt; (see &lt;a href=&quot;#3.3.8&quot;&gt;&amp;sect;3.3.8&lt;/a&gt;), &lt;code&gt;__mode&lt;/code&gt; (see &lt;a href=&quot;#2.5.4&quot;&gt;&amp;sect;2.5.4&lt;/a&gt;), and &lt;code&gt;__name&lt;/code&gt;. (The entry &lt;code&gt;__name&lt;/code&gt;, when it contains a string, may be used by &lt;a href=&quot;#pdf-tostring&quot;&gt;&lt;code&gt;tostring&lt;/code&gt;&lt;/a&gt; and in error messages.)</source>
          <target state="translated">: 이전 목록에 추가하여, 인터프리터는 또한 다음과 같은 메타 테이블의 키를 존중 &lt;code&gt;__gc&lt;/code&gt; (참조 &lt;a href=&quot;#2.5.3&quot;&gt;&amp;sect;2.5.3&lt;/a&gt; ), &lt;code&gt;__close&lt;/code&gt; (참조 &lt;a href=&quot;#3.3.8&quot;&gt;&amp;sect;3.3.8&lt;/a&gt; ), &lt;code&gt;__mode&lt;/code&gt; (참조 &lt;a href=&quot;#2.5.4&quot;&gt;&amp;sect;2.5.4&lt;/a&gt; ), 및 &lt;code&gt;__name&lt;/code&gt; 을 . ( 문자열이 포함 된 경우 &lt;code&gt;__name&lt;/code&gt; 항목 은 &lt;a href=&quot;#pdf-tostring&quot;&gt; &lt;code&gt;tostring&lt;/code&gt; &lt;/a&gt; 및 오류 메시지에서 사용할 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="62eebdc1879c0b1be4e46a0d6b0e9bcf316566f7" translate="yes" xml:space="preserve">
          <source>In any case, if the pattern specifies no captures, then it behaves as if the whole pattern was inside a capture.</source>
          <target state="translated">어쨌든 패턴이 캡처를 지정하지 않으면 전체 패턴이 캡처 내부에있는 것처럼 동작합니다.</target>
        </trans-unit>
        <trans-unit id="2bb9e40f7423d9d013509578590213e990081254" translate="yes" xml:space="preserve">
          <source>In both cases pushes onto the stack the final value associated with &lt;code&gt;tname&lt;/code&gt; in the registry.</source>
          <target state="translated">두 경우 모두 레지스트리의 &lt;code&gt;tname&lt;/code&gt; 과 관련된 최종 값을 스택으로 푸시합니다 .</target>
        </trans-unit>
        <trans-unit id="2fdfe218bfd306e46380cb987820b12f4c22a7cd" translate="yes" xml:space="preserve">
          <source>In both cases, the function pushes onto the stack the final value associated with &lt;code&gt;tname&lt;/code&gt; in the registry.</source>
          <target state="translated">두 경우 모두 함수는 레지스트리의 &lt;code&gt;tname&lt;/code&gt; 과 관련된 최종 값을 스택에 푸시합니다 .</target>
        </trans-unit>
        <trans-unit id="745fa42e653c44e85ff99efe0906a4b1ecb00bd0" translate="yes" xml:space="preserve">
          <source>In case of errors opening the file, this function raises the error, instead of returning an error code.</source>
          <target state="translated">파일을 여는 동안 오류가 발생하면이 함수는 오류 코드를 반환하는 대신 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="529481951babb324dab477372f5c6d52890e6006" translate="yes" xml:space="preserve">
          <source>In case of errors this function raises the error, instead of returning an error code.</source>
          <target state="translated">오류가 발생하면이 함수는 오류 코드를 반환하는 대신 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="f30334a63968b6ddb7bb2b4604dd500f34422267" translate="yes" xml:space="preserve">
          <source>In case of errors, the stack is not unwound, so you can use the debug API over it. The error object is on the top of the stack.</source>
          <target state="translated">오류가 발생하면 스택이 풀리지 않으므로 디버그 API를 사용할 수 있습니다. 오류 개체는 스택 맨 위에 있습니다.</target>
        </trans-unit>
        <trans-unit id="467db70feecc1c4f6d135a7d76a384db5dda44c8" translate="yes" xml:space="preserve">
          <source>In case of overflows in integer arithmetic, all operations &lt;em&gt;wrap around&lt;/em&gt;, according to the usual rules of two-complement arithmetic. (In other words, they return the unique representable integer that is equal modulo &lt;em&gt;2&lt;sup&gt;64&lt;/sup&gt;&lt;/em&gt; to the mathematical result.)</source>
          <target state="translated">정수 산술 오버플로가 발생하는 경우 모든 2 개의 보수 산술 규칙에 따라 모든 연산이 &lt;em&gt;래핑됩니다&lt;/em&gt; . 즉, 수학 결과와 동일한 모듈로 &lt;em&gt;2 &lt;sup&gt;64 인&lt;/sup&gt;&lt;/em&gt; 고유 한 표현 가능한 정수를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="e042bc5ef9c39f04e2c4f57f3960a9657ca9b2b3" translate="yes" xml:space="preserve">
          <source>In case of overflows in integer arithmetic, all operations &lt;em&gt;wrap around&lt;/em&gt;.</source>
          <target state="translated">정수 산술에서 오버플로가 발생하면 모든 연산 &lt;em&gt;이&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="4404e49caab8b46532d3c1ccdfde90bff4f9337a" translate="yes" xml:space="preserve">
          <source>In case of success, &lt;code&gt;seek&lt;/code&gt; returns the final file position, measured in bytes from the beginning of the file. If &lt;code&gt;seek&lt;/code&gt; fails, it returns &lt;b&gt;fail&lt;/b&gt;, plus a string describing the error.</source>
          <target state="translated">성공한 경우 &lt;code&gt;seek&lt;/code&gt; 는 파일 시작 부분에서 바이트 단위로 측정 된 최종 파일 위치를 반환합니다. 경우 &lt;code&gt;seek&lt;/code&gt; 실패, 그것은 반환 &lt;b&gt;실패&lt;/b&gt; , 플러스 문자열은 오류를 설명.</target>
        </trans-unit>
        <trans-unit id="af2e9f70152b7436cb1235e5607b1026adf8b4df" translate="yes" xml:space="preserve">
          <source>In case of success, &lt;code&gt;seek&lt;/code&gt; returns the final file position, measured in bytes from the beginning of the file. If &lt;code&gt;seek&lt;/code&gt; fails, it returns &lt;b&gt;nil&lt;/b&gt;, plus a string describing the error.</source>
          <target state="translated">성공한 경우 &lt;code&gt;seek&lt;/code&gt; 는 파일의 시작 부분부터 바이트 단위로 측정 된 최종 파일 위치를 반환합니다. 경우 &lt;code&gt;seek&lt;/code&gt; 실패, 그것은 반환 &lt;b&gt;전무&lt;/b&gt; , 플러스 문자열은 오류를 설명.</target>
        </trans-unit>
        <trans-unit id="8ce8027efe413a45818ec783d9d3bd6228742c83" translate="yes" xml:space="preserve">
          <source>In case of success, returns a handle for a temporary file. This file is opened in update mode and it is automatically removed when the program ends.</source>
          <target state="translated">성공하면 임시 파일에 대한 핸들을 반환합니다. 이 파일은 업데이트 모드로 열리고 프로그램이 종료되면 자동으로 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="6be35cfe80694e8f2a500c5ffa60712ba072cc6f" translate="yes" xml:space="preserve">
          <source>In case of success, this function returns &lt;code&gt;file&lt;/code&gt;.</source>
          <target state="translated">성공한 경우이 함수는 &lt;code&gt;file&lt;/code&gt; 을 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="b6a86eee5d971d25767843d4dbdef34e84774cef" translate="yes" xml:space="preserve">
          <source>In case of success, this function returns &lt;code&gt;file&lt;/code&gt;. Otherwise it returns &lt;b&gt;nil&lt;/b&gt; plus a string describing the error.</source>
          <target state="translated">성공하면이 함수는 &lt;code&gt;file&lt;/code&gt; 을 반환 합니다 . 그렇지 않으면 &lt;b&gt;nil&lt;/b&gt; 과 오류를 설명하는 문자열을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="8c632a9fad5564d87f459215e17e926cda31f0ee" translate="yes" xml:space="preserve">
          <source>In case of unprotected errors in the script, the interpreter reports the error to the standard error stream. If the error object is not a string but has a metamethod &lt;code&gt;__tostring&lt;/code&gt;, the interpreter calls this metamethod to produce the final message. Otherwise, the interpreter converts the error object to a string and adds a stack traceback to it.</source>
          <target state="translated">스크립트에 보호되지 않은 오류가있는 경우 인터프리터는 오류를 표준 오류 스트림에보고합니다. 에러 객체가 문자열은 아니지만 메타 메소드 &lt;code&gt;__tostring&lt;/code&gt; 을 가지고있는 경우 인터프리터는이 메타 메소드를 호출하여 최종 메시지를 생성합니다. 그렇지 않으면 인터프리터는 오류 객체를 문자열로 변환하고 스택 추적을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="bea04697f039ec14dc1ee8265502eaa4d56df50c" translate="yes" xml:space="preserve">
          <source>In case of unprotected errors in the script, the interpreter reports the error to the standard error stream. If the error object is not a string but has a metamethod &lt;code&gt;__tostring&lt;/code&gt;, the interpreter calls this metamethod to produce the final message. Otherwise, the interpreter converts the error object to a string and adds a stack traceback to it. When warnings are on, they are simply printed in the standard error output.</source>
          <target state="translated">스크립트에 보호되지 않은 오류가있는 경우 인터프리터는 오류를 표준 오류 스트림에보고합니다. 오류 객체가 문자열이 아니지만 메타 메서드 &lt;code&gt;__tostring&lt;/code&gt; 이있는 경우 인터프리터는이 메타 메서드를 호출하여 최종 메시지를 생성합니다. 그렇지 않으면 인터프리터는 오류 객체를 문자열로 변환하고 스택 트레이스 백을 추가합니다. 경고가 켜지면 단순히 표준 오류 출력에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="07f47d88fa41a69cbb5505a94710be0b6ddd4668" translate="yes" xml:space="preserve">
          <source>In general, Lua's garbage collection can free or move internal memory and then invalidate pointers to internal strings. To allow a safe use of these pointers, The API guarantees that any pointer to a string in a stack index is valid while the value at that index is neither modified nor popped. When the index is a pseudo-index (referring to an upvalue), the pointer is valid while the corresponding call is active and the corresponding upvalue is not modified.</source>
          <target state="translated">일반적으로 Lua의 가비지 컬렉션은 내부 메모리를 해제하거나 이동 한 다음 내부 문자열에 대한 포인터를 무효화 할 수 있습니다. 이러한 포인터를 안전하게 사용할 수 있도록 API는 스택 인덱스의 문자열에 대한 포인터가 유효하고 해당 인덱스의 값이 수정되거나 팝되지 않음을 보장합니다. 인덱스가 의사 인덱스 (upvalue 참조)이면 해당 호출이 활성화되고 해당 upvalue가 수정되지 않는 동안 포인터가 유효합니다.</target>
        </trans-unit>
        <trans-unit id="ea95e591f583f4a7ef86223f97f4160fc20ef3bf" translate="yes" xml:space="preserve">
          <source>In generational mode, the collector does frequent &lt;em&gt;minor&lt;/em&gt; collections, which traverses only objects recently created. If after a minor collection the use of memory is still above a limit, the collector does a stop-the-world &lt;em&gt;major&lt;/em&gt; collection, which traverses all objects. The generational mode uses two parameters: the &lt;em&gt;minor multiplier&lt;/em&gt; and the &lt;em&gt;the major multiplier&lt;/em&gt;.</source>
          <target state="translated">생성 모드에서 수집기는 최근에 만든 개체 만 탐색 하는 &lt;em&gt;부&lt;/em&gt; 수집을 자주 수행 합니다. 부 수집 후에도 메모리 사용이 여전히 제한을 초과하면 수집기는 모든 개체를 순회 하는 stop-the-world &lt;em&gt;주&lt;/em&gt; 수집을 수행합니다. 생성 모드는 &lt;em&gt;마이너 승수&lt;/em&gt; 와 &lt;em&gt;메이저 승수&lt;/em&gt; 라는 두 가지 매개 변수를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="dd00f2668545ca027b5cc5fd8421e849fff38797" translate="yes" xml:space="preserve">
          <source>In incremental mode, each GC cycle performs a mark-and-sweep collection in small steps interleaved with the program's execution. In this mode, the collector uses three numbers to control its garbage-collection cycles: the &lt;em&gt;garbage-collector pause&lt;/em&gt;, the &lt;em&gt;garbage-collector step multiplier&lt;/em&gt;, and the &lt;em&gt;garbage-collector step size&lt;/em&gt;.</source>
          <target state="translated">증분 모드에서 각 GC주기는 프로그램 실행과 인터리브 된 작은 단계에서 마크 앤 스윕 수집을 수행합니다. 이 모드에서 수집기는 &lt;em&gt;가비지 수집기 일시 중지&lt;/em&gt; , &lt;em&gt;가비지 수집기 단계 승수&lt;/em&gt; 및 &lt;em&gt;가비지 수집기 단계 크기의&lt;/em&gt; 세 가지 숫자를 사용하여 가비지 수집주기를 제어합니다 .</target>
        </trans-unit>
        <trans-unit id="bae459100d0f219cfd74a53f2eb34f96a6176512" translate="yes" xml:space="preserve">
          <source>In interactive mode, Lua repeatedly prompts and waits for a line. After reading a line, Lua first try to interpret the line as an expression. If it succeeds, it prints its value. Otherwise, it interprets the line as a statement. If you write an incomplete statement, the interpreter waits for its completion by issuing a different prompt.</source>
          <target state="translated">대화식 모드에서 Lua는 반복적으로 프롬프트를 표시하고 회선을 기다립니다. 줄을 읽은 후 Lua는 먼저 줄을 표현식으로 해석하려고 시도합니다. 성공하면 값을 인쇄합니다. 그렇지 않으면, 행을 명령문으로 해석합니다. 불완전한 명령문을 작성하면 인터프리터는 다른 프롬프트를 발행하여 완료를 기다립니다.</target>
        </trans-unit>
        <trans-unit id="63d381d8ee2b95ac5052d39e95b78fbc9ea8d9fb" translate="yes" xml:space="preserve">
          <source>In order to communicate properly with Lua, a C function must use the following protocol, which defines the way parameters and results are passed: a C function receives its arguments from Lua in its stack in direct order (the first argument is pushed first). So, when the function starts, &lt;code&gt;lua_gettop(L)&lt;/code&gt; returns the number of arguments received by the function. The first argument (if any) is at index 1 and its last argument is at index &lt;code&gt;lua_gettop(L)&lt;/code&gt;. To return values to Lua, a C function just pushes them onto the stack, in direct order (the first result is pushed first), and returns in C the number of results. Any other value in the stack below the results will be properly discarded by Lua. Like a Lua function, a C function called by Lua can also return many results.</source>
          <target state="translated">Lua와 제대로 통신하기 위해 C 함수는 매개 변수와 결과가 전달되는 방식을 정의하는 다음 프로토콜을 사용해야합니다. C 함수는 스택에서 Lua로부터 인수를 직접 순서대로받습니다 (첫 번째 인수가 먼저 푸시 됨). 따라서 함수가 시작되면 &lt;code&gt;lua_gettop(L)&lt;/code&gt; 은 함수가 수신 한 인수의 수를 반환합니다. 첫 번째 인수 (있는 경우)는 인덱스 1에 있고 마지막 인수는 인덱스 &lt;code&gt;lua_gettop(L)&lt;/code&gt; 있습니다. Lua에 값을 반환하기 위해 C 함수는 값을 직접 순서대로 스택에 푸시하고 (첫 번째 결과가 먼저 푸시 됨) 결과 수를 C로 반환합니다. 결과 아래의 스택에있는 다른 값은 Lua에 의해 적절히 폐기됩니다. Lua 함수와 마찬가지로 Lua가 호출 한 C 함수도 많은 결과를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08b57c85f9e4681ef2b296b47dfe58462b42111a" translate="yes" xml:space="preserve">
          <source>In order to communicate properly with Lua, a C function must use the following protocol, which defines the way parameters and results are passed: a C function receives its arguments from Lua in its stack in direct order (the first argument is pushed first). So, when the function starts, &lt;code&gt;lua_gettop(L)&lt;/code&gt; returns the number of arguments received by the function. The first argument (if any) is at index 1 and its last argument is at index &lt;code&gt;lua_gettop(L)&lt;/code&gt;. To return values to Lua, a C function just pushes them onto the stack, in direct order (the first result is pushed first), and returns the number of results. Any other value in the stack below the results will be properly discarded by Lua. Like a Lua function, a C function called by Lua can also return many results.</source>
          <target state="translated">Lua와 올바르게 통신하려면 C 함수는 매개 변수 및 결과가 전달되는 방식을 정의하는 다음 프로토콜을 사용해야합니다. C 함수는 스택에서 Lua의 인수를 직접 순서대로받습니다 (첫 번째 인수가 먼저 푸시 됨). 따라서 함수가 시작되면 &lt;code&gt;lua_gettop(L)&lt;/code&gt; 은 함수가 수신 한 인수 수를 반환합니다. 첫 번째 인수 (있는 경우)는 인덱스 1에 있고 마지막 인수는 &lt;code&gt;lua_gettop(L)&lt;/code&gt; 인덱스에 있습니다. 값을 Lua로 반환하기 위해 C 함수는 값을 직접 순서대로 스택에 푸시하고 (첫 번째 결과가 먼저 푸시 됨) 결과 수를 반환합니다. 결과 아래 스택의 다른 값은 Lua에 의해 올바르게 삭제됩니다. Lua 함수와 마찬가지로 Lua가 호출 한 C 함수도 많은 결과를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1509d2ba42008705f892c900bc91b5bc201ddc1e" translate="yes" xml:space="preserve">
          <source>In the &lt;b&gt;repeat&lt;/b&gt;&amp;ndash;&lt;b&gt;until&lt;/b&gt; loop, the inner block does not end at the &lt;b&gt;until&lt;/b&gt; keyword, but only after the condition. So, the condition can refer to local variables declared inside the loop block.</source>
          <target state="translated">에서 &lt;b&gt;반복&lt;/b&gt; - &lt;b&gt;때까지&lt;/b&gt; 루프, 내부 블록은에서 끝나지 않습니다 &lt;b&gt;때까지&lt;/b&gt; 만 상태 후, 키워드. 따라서 조건은 루프 블록 내에 선언 된 로컬 변수를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82f098174293e606c23ea050f8d7e73e0153453e" translate="yes" xml:space="preserve">
          <source>In the above code, the new function &lt;code&gt;k&lt;/code&gt; is a &lt;em&gt;continuation function&lt;/em&gt; (with type &lt;a href=&quot;#lua_KFunction&quot;&gt;&lt;code&gt;lua_KFunction&lt;/code&gt;&lt;/a&gt;), which should do all the work that the original function was doing after calling &lt;a href=&quot;#lua_pcall&quot;&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt;. Now, we must inform Lua that it must call &lt;code&gt;k&lt;/code&gt; if the Lua code being executed by &lt;a href=&quot;#lua_pcall&quot;&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt; gets interrupted in some way (errors or yielding), so we rewrite the code as here, replacing &lt;a href=&quot;#lua_pcall&quot;&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt; by &lt;a href=&quot;#lua_pcallk&quot;&gt;&lt;code&gt;lua_pcallk&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">위 코드에서 새 함수 &lt;code&gt;k&lt;/code&gt; 는 &lt;em&gt;연속 함수&lt;/em&gt; ( &lt;a href=&quot;#lua_KFunction&quot;&gt; &lt;code&gt;lua_KFunction&lt;/code&gt; &lt;/a&gt; 유형 )이며 &lt;a href=&quot;#lua_pcall&quot;&gt; &lt;code&gt;lua_pcall&lt;/code&gt; &lt;/a&gt; 을 호출 한 후 원래 함수가 수행 한 모든 작업을 수행해야합니다 . 이제 &lt;a href=&quot;#lua_pcall&quot;&gt; &lt;code&gt;lua_pcall&lt;/code&gt; 에&lt;/a&gt; 의해 실행되는 Lua 코드가 어떤 식 으로든 중단되거나 오류가 발생 하면 Lua에 &lt;code&gt;k&lt;/code&gt; 를 호출해야한다고 Lua에 알려야합니다 . 따라서 &lt;a href=&quot;#lua_pcall&quot;&gt; &lt;code&gt;lua_pcall&lt;/code&gt; &lt;/a&gt; 을 &lt;a href=&quot;#lua_pcallk&quot;&gt; &lt;code&gt;lua_pcallk&lt;/code&gt; 로&lt;/a&gt; 대체하여 다음과 같이 코드를 다시 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="1a9834b08661ce8efa680d14f8d2efb7c60bfccf" translate="yes" xml:space="preserve">
          <source>In the case of an out-of-memory error, the value in the given index is immediately closed, as if it was already marked.</source>
          <target state="translated">메모리 부족 오류의 경우 지정된 인덱스의 값은 마치 이미 표시된 것처럼 즉시 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="06f49d50825ba7a2c55ba6aba66f792c4da727cd" translate="yes" xml:space="preserve">
          <source>In the first case, the parameter &lt;code&gt;ar&lt;/code&gt; must be a valid activation record that was filled by a previous call to &lt;a href=&quot;#lua_getstack&quot;&gt;&lt;code&gt;lua_getstack&lt;/code&gt;&lt;/a&gt; or given as argument to a hook (see &lt;a href=&quot;#lua_Hook&quot;&gt;&lt;code&gt;lua_Hook&lt;/code&gt;&lt;/a&gt;). The index &lt;code&gt;n&lt;/code&gt; selects which local variable to inspect; see &lt;a href=&quot;#pdf-debug.getlocal&quot;&gt;&lt;code&gt;debug.getlocal&lt;/code&gt;&lt;/a&gt; for details about variable indices and names.</source>
          <target state="translated">첫 번째 경우, &lt;code&gt;ar&lt;/code&gt; 매개 변수 는 &lt;a href=&quot;#lua_getstack&quot;&gt; &lt;code&gt;lua_getstack&lt;/code&gt; &lt;/a&gt; 에 대한 이전 호출로 채워지 거나 후크에 대한 인수로 제공된 유효한 활성화 레코드 여야합니다 ( &lt;a href=&quot;#lua_Hook&quot;&gt; &lt;code&gt;lua_Hook&lt;/code&gt; &lt;/a&gt; 참조 ). 인덱스 &lt;code&gt;n&lt;/code&gt; 은 검사 할 로컬 변수를 선택합니다. 변수 인덱스 및 이름에 대한 자세한 내용 은 &lt;a href=&quot;#pdf-debug.getlocal&quot;&gt; &lt;code&gt;debug.getlocal&lt;/code&gt; &lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="41a440753f8786d13a87f3b118280fbe98ed6aa7" translate="yes" xml:space="preserve">
          <source>In the second case, &lt;code&gt;ar&lt;/code&gt; must be &lt;code&gt;NULL&lt;/code&gt; and the function to be inspected must be at the top of the stack. In this case, only parameters of Lua functions are visible (as there is no information about what variables are active) and no values are pushed onto the stack.</source>
          <target state="translated">두 번째 경우 &lt;code&gt;ar&lt;/code&gt; 은 &lt;code&gt;NULL&lt;/code&gt; 이어야 하고 검사 할 함수는 스택 맨 위에 있어야합니다. 이 경우 Lua 함수의 매개 변수 만 표시되며 (활성 상태 인 변수에 대한 정보가 없으므로) 스택에 값이 푸시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5b74c4ab2ab9491434583e802b1853e197a9999c" translate="yes" xml:space="preserve">
          <source>In the second case, &lt;code&gt;ar&lt;/code&gt; must be &lt;code&gt;NULL&lt;/code&gt; and the function to be inspected must be on the top of the stack. In this case, only parameters of Lua functions are visible (as there is no information about what variables are active) and no values are pushed onto the stack.</source>
          <target state="translated">두 번째 경우에는 &lt;code&gt;ar&lt;/code&gt; 이 &lt;code&gt;NULL&lt;/code&gt; 이어야 하고 검사 할 함수가 스택의 맨 위에 있어야합니다. 이 경우 Lua 함수의 매개 변수 만 표시되고 (활성 변수에 대한 정보가 없기 때문에) 스택에 값이 푸시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="431335cf2ea122b520413c8e75c042e2443dd934" translate="yes" xml:space="preserve">
          <source>In this case, all returned values are thrown away. Function calls are explained in &lt;a href=&quot;#3.4.10&quot;&gt;&amp;sect;3.4.10&lt;/a&gt;.</source>
          <target state="translated">이 경우 반환 된 모든 값이 삭제됩니다. 함수 호출은 &lt;a href=&quot;#3.4.10&quot;&gt;&amp;sect;3.4.10&lt;/a&gt; 에 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="789e39d8c294634d33eb6b9c165293b5343c70b0" translate="yes" xml:space="preserve">
          <source>In words, a border is any (natural) index in a table where a non-nil value is followed by a nil value (or zero, when index 1 is nil).</source>
          <target state="translated">다시 말해, 경계는 테이블에서 0이 아닌 값 뒤에 nil 값 (또는 인덱스 1이 nil 인 경우 0)이 오는 임의의 자연 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="46873fd5ff052b8cbb9d6a8125368950d99d54a9" translate="yes" xml:space="preserve">
          <source>In words, a border is any (natural) index present in the table that is followed by an absent index (or zero, when index 1 is absent).</source>
          <target state="translated">즉, 경계는 테이블에 존재하는 모든 (자연) 인덱스이며 그 뒤에없는 인덱스 (또는 인덱스 1이없는 경우 0)입니다.</target>
        </trans-unit>
        <trans-unit id="da8e5fd662c079ec4e558198c08627aa99e4ddde" translate="yes" xml:space="preserve">
          <source>In words, if the argument &lt;code&gt;arg&lt;/code&gt; is nil or absent, the macro results in the default &lt;code&gt;dflt&lt;/code&gt;. Otherwise, it results in the result of calling &lt;code&gt;func&lt;/code&gt; with the state &lt;code&gt;L&lt;/code&gt; and the argument index &lt;code&gt;arg&lt;/code&gt; as arguments. Note that it evaluates the expression &lt;code&gt;dflt&lt;/code&gt; only if needed.</source>
          <target state="translated">즉, 인수 &lt;code&gt;arg&lt;/code&gt; 가 nil이거나 없으면 매크로는 기본 &lt;code&gt;dflt&lt;/code&gt; 가 됩니다. 그렇지 않으면 상태 &lt;code&gt;L&lt;/code&gt; 및 인수 인덱스 &lt;code&gt;arg&lt;/code&gt; 를 인수로 사용하여 &lt;code&gt;func&lt;/code&gt; 를 호출 한 결과가 됩니다. 필요한 경우에만 &lt;code&gt;dflt&lt;/code&gt; 표현식을 평가 합니다.</target>
        </trans-unit>
        <trans-unit id="1d61c65c4df032dfd4680710a9c5e29989e4f8c3" translate="yes" xml:space="preserve">
          <source>In words, if the argument &lt;code&gt;arg&lt;/code&gt; is nil or absent, the macro results in the default &lt;code&gt;dflt&lt;/code&gt;. Otherwise, it results in the result of calling &lt;code&gt;func&lt;/code&gt; with the state &lt;code&gt;L&lt;/code&gt; and the argument index &lt;code&gt;arg&lt;/code&gt; as parameters. Note that it evaluates the expression &lt;code&gt;dflt&lt;/code&gt; only if needed.</source>
          <target state="translated">즉, 인수 &lt;code&gt;arg&lt;/code&gt; 가 nil이거나없는 경우, 매크로는 기본 &lt;code&gt;dflt&lt;/code&gt; 가 됩니다. 그렇지 않으면 상태 &lt;code&gt;L&lt;/code&gt; 및 인수 인덱스 &lt;code&gt;arg&lt;/code&gt; 를 매개 변수로 사용하여 &lt;code&gt;func&lt;/code&gt; 를 호출 한 결과가 됩니다. 필요한 경우에만 &lt;code&gt;dflt&lt;/code&gt; 표현식을 평가 합니다.</target>
        </trans-unit>
        <trans-unit id="01a07bfb5ef11a02986679665264fe04ed7927b3" translate="yes" xml:space="preserve">
          <source>Incremental Garbage Collection</source>
          <target state="translated">증분 가비지 수집</target>
        </trans-unit>
        <trans-unit id="bea01033355ce358e0c79f805090383ef4dadccc" translate="yes" xml:space="preserve">
          <source>Initializes a buffer &lt;code&gt;B&lt;/code&gt; (see &lt;a href=&quot;#luaL_Buffer&quot;&gt;&lt;code&gt;luaL_Buffer&lt;/code&gt;&lt;/a&gt;). This function does not allocate any space; the buffer must be declared as a variable.</source>
          <target state="translated">버퍼 &lt;code&gt;B&lt;/code&gt; 를 초기화합니다 ( &lt;a href=&quot;#luaL_Buffer&quot;&gt; &lt;code&gt;luaL_Buffer&lt;/code&gt; &lt;/a&gt; 참조 ). 이 함수는 공간을 할당하지 않습니다. 버퍼는 변수로 선언되어야합니다.</target>
        </trans-unit>
        <trans-unit id="67c7955edf181aeadc7e61f0904d3690ad3a91fb" translate="yes" xml:space="preserve">
          <source>Initializes a buffer &lt;code&gt;B&lt;/code&gt;. This function does not allocate any space; the buffer must be declared as a variable (see &lt;a href=&quot;#luaL_Buffer&quot;&gt;&lt;code&gt;luaL_Buffer&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">버퍼 &lt;code&gt;B&lt;/code&gt; 를 초기화합니다 . 이 함수는 공간을 할당하지 않습니다. 버퍼는 변수로 선언되어야합니다 ( &lt;a href=&quot;#luaL_Buffer&quot;&gt; &lt;code&gt;luaL_Buffer&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="0abea9e11cfbbca6718360dab7feca24a7e28d57" translate="yes" xml:space="preserve">
          <source>Inserts element &lt;code&gt;value&lt;/code&gt; at position &lt;code&gt;pos&lt;/code&gt; in &lt;code&gt;list&lt;/code&gt;, shifting up the elements &lt;code&gt;list[pos], list[pos+1], &amp;middot;&amp;middot;&amp;middot;, list[#list]&lt;/code&gt;. The default value for &lt;code&gt;pos&lt;/code&gt; is &lt;code&gt;#list+1&lt;/code&gt;, so that a call &lt;code&gt;table.insert(t,x)&lt;/code&gt; inserts &lt;code&gt;x&lt;/code&gt; at the end of list &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;list&lt;/code&gt; 의 위치 &lt;code&gt;pos&lt;/code&gt; 에 요소 &lt;code&gt;value&lt;/code&gt; 을 삽입 하고 요소 &lt;code&gt;list[pos], list[pos+1], &amp;middot;&amp;middot;&amp;middot;, list[#list]&lt;/code&gt; 합니다. &lt;code&gt;pos&lt;/code&gt; 의 기본값 은 &lt;code&gt;#list+1&lt;/code&gt; 이므로 호출 &lt;code&gt;table.insert(t,x)&lt;/code&gt; 는 list &lt;code&gt;t&lt;/code&gt; 의 끝에 &lt;code&gt;x&lt;/code&gt; 를 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="97337f3db6c1f37e6b68c3a033b725e785a46913" translate="yes" xml:space="preserve">
          <source>Inserts element &lt;code&gt;value&lt;/code&gt; at position &lt;code&gt;pos&lt;/code&gt; in &lt;code&gt;list&lt;/code&gt;, shifting up the elements &lt;code&gt;list[pos], list[pos+1], &amp;middot;&amp;middot;&amp;middot;, list[#list]&lt;/code&gt;. The default value for &lt;code&gt;pos&lt;/code&gt; is &lt;code&gt;#list+1&lt;/code&gt;, so that a call &lt;code&gt;table.insert(t,x)&lt;/code&gt; inserts &lt;code&gt;x&lt;/code&gt; at the end of the list &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;list&lt;/code&gt; 의 &lt;code&gt;pos&lt;/code&gt; 위치 에 요소 &lt;code&gt;value&lt;/code&gt; 을 삽입 하고 &lt;code&gt;list[pos], list[pos+1], &amp;middot;&amp;middot;&amp;middot;, list[#list]&lt;/code&gt; 요소를 위로 이동합니다 . &lt;code&gt;pos&lt;/code&gt; 의 기본값 은 &lt;code&gt;#list+1&lt;/code&gt; 이므로 &lt;code&gt;table.insert(t,x)&lt;/code&gt; 호출 은 목록 &lt;code&gt;t&lt;/code&gt; 의 끝에 &lt;code&gt;x&lt;/code&gt; 를 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="3151191ed07199be567c359ddf6e784a4e531a23" translate="yes" xml:space="preserve">
          <source>Inside a C function you can raise an error by calling &lt;a href=&quot;#lua_error&quot;&gt;&lt;code&gt;lua_error&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">C 함수 내에서 &lt;a href=&quot;#lua_error&quot;&gt; &lt;code&gt;lua_error&lt;/code&gt; &lt;/a&gt; 를 호출하여 오류를 일으킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f7de63f7ebba7b4f1b63972998e3589e858efeb5" translate="yes" xml:space="preserve">
          <source>Inside a C function you can raise an error explicitly by calling &lt;a href=&quot;#lua_error&quot;&gt;&lt;code&gt;lua_error&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">C 함수 내에서 &lt;a href=&quot;#lua_error&quot;&gt; &lt;code&gt;lua_error&lt;/code&gt; &lt;/a&gt; 를 호출하여 명시 적으로 오류를 발생시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="85b166ec01ff2a0e99bcb49337529aa50cdf9ed8" translate="yes" xml:space="preserve">
          <source>Internally, Lua uses the C &lt;code&gt;longjmp&lt;/code&gt; facility to handle errors. (Lua will use exceptions if you compile it as C++; search for &lt;code&gt;LUAI_THROW&lt;/code&gt; in the source code for details.) When Lua faces any error (such as a memory allocation error or a type error) it &lt;em&gt;raises&lt;/em&gt; an error; that is, it does a long jump. A &lt;em&gt;protected environment&lt;/em&gt; uses &lt;code&gt;setjmp&lt;/code&gt; to set a recovery point; any error jumps to the most recent active recovery point.</source>
          <target state="translated">내부적으로 Lua는 C &lt;code&gt;longjmp&lt;/code&gt; 기능을 사용하여 오류를 처리합니다. (당신이 C ++로 컴파일하는 경우 루아는 예외를 사용, 검색 &lt;code&gt;LUAI_THROW&lt;/code&gt; 자세한 내용은 소스 코드 인치) 루아 (예 : 메모리 할당 오류 또는 입력 오류 등) 오류에 직면하는 경우가 &lt;em&gt;발생합니다&lt;/em&gt; 오류; 즉, 멀리뛰기합니다. &lt;em&gt;보호 환경&lt;/em&gt; 용도 &lt;code&gt;setjmp&lt;/code&gt; 의 복구 지점을 설정하는 단계; 모든 오류는 가장 최근의 활성 복구 지점으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="5b482879524a2f9c14e638942f5681b2d3a687a1" translate="yes" xml:space="preserve">
          <source>Internally, Lua uses the C &lt;code&gt;longjmp&lt;/code&gt; facility to handle errors. (Lua will use exceptions if you compile it as C++; search for &lt;code&gt;LUAI_THROW&lt;/code&gt; in the source code for details.) When Lua faces any error, such as a memory allocation error or a type error, it &lt;em&gt;raises&lt;/em&gt; an error; that is, it does a long jump. A &lt;em&gt;protected environment&lt;/em&gt; uses &lt;code&gt;setjmp&lt;/code&gt; to set a recovery point; any error jumps to the most recent active recovery point.</source>
          <target state="translated">내부적으로 Lua는 C &lt;code&gt;longjmp&lt;/code&gt; 기능을 사용하여 오류를 처리합니다. (당신이 C ++로 컴파일하는 경우 루아는 예외를 사용, 검색 &lt;code&gt;LUAI_THROW&lt;/code&gt; . 자세한 내용은 소스 코드에서) 루아는 메모리 할당 오류 또는 입력 오류와 같은 오류에 직면 할 때 &lt;em&gt;발생합니다&lt;/em&gt; 오류; 즉, 긴 점프를합니다. &lt;em&gt;보호 환경&lt;/em&gt; 용도 &lt;code&gt;setjmp&lt;/code&gt; 의 복구 지점을 설정하는 단계; 오류는 가장 최근의 활성 복구 지점으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="8519c30b2fe0a1d5b4b757f31a04911a4641884f" translate="yes" xml:space="preserve">
          <source>Internally, Lua uses the C &lt;code&gt;longjmp&lt;/code&gt; facility to yield a coroutine. Therefore, if a C function &lt;code&gt;foo&lt;/code&gt; calls an API function and this API function yields (directly or indirectly by calling another function that yields), Lua cannot return to &lt;code&gt;foo&lt;/code&gt; any more, because the &lt;code&gt;longjmp&lt;/code&gt; removes its frame from the C stack.</source>
          <target state="translated">내부적으로 Lua는 C &lt;code&gt;longjmp&lt;/code&gt; 기능을 사용하여 코 루틴을 생성합니다. 따라서 C 함수 &lt;code&gt;foo&lt;/code&gt; 가 API 함수를 호출하고이 API 함수가 (직접 또는 간접적으로 생성되는 다른 함수를 호출하여) 생성 하면 &lt;code&gt;longjmp&lt;/code&gt; 는 longjmp 가 C 스택에서 프레임을 제거 하므로 더 이상 &lt;code&gt;foo&lt;/code&gt; 로 돌아올 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="7b4e8ed077aa1747843eb727cc8f6e4bfe8b0b8a" translate="yes" xml:space="preserve">
          <source>It can only be called from the main coroutine (thread);</source>
          <target state="translated">메인 코 루틴 (스레드)에서만 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad02c3ff1e54045c9f87d15faf0f433734a4ee16" translate="yes" xml:space="preserve">
          <source>It cannot be called while handling a stack-overflow error;</source>
          <target state="translated">스택 오버플로 오류를 처리하는 동안에는 호출 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ffa29374aa14b1802d3041c63b03777bfa3568ee" translate="yes" xml:space="preserve">
          <source>It is a good practice to add all needed metamethods to a table before setting it as a metatable of some object. In particular, the &lt;code&gt;__gc&lt;/code&gt; metamethod works only when this order is followed (see &lt;a href=&quot;#2.5.1&quot;&gt;&amp;sect;2.5.1&lt;/a&gt;).</source>
          <target state="translated">일부 객체의 메타 테이블로 설정하기 전에 필요한 모든 메타 메소드를 테이블에 추가하는 것이 좋습니다. 특히 &lt;code&gt;__gc&lt;/code&gt; 메타 메소드는이 순서를 따르는 경우에만 작동합니다 ( &lt;a href=&quot;#2.5.1&quot;&gt;&amp;sect;2.5.1&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="2ea190191ffd1383568cdfab371917a78dd082eb" translate="yes" xml:space="preserve">
          <source>It is a good practice to add all needed metamethods to a table before setting it as a metatable of some object. In particular, the &lt;code&gt;__gc&lt;/code&gt; metamethod works only when this order is followed (see &lt;a href=&quot;#2.5.3&quot;&gt;&amp;sect;2.5.3&lt;/a&gt;). It is also a good practice to set the metatable of an object right after its creation.</source>
          <target state="translated">테이블을 일부 개체의 메타 테이블로 설정하기 전에 필요한 모든 메타 메서드를 테이블에 추가하는 것이 좋습니다. 특히 &lt;code&gt;__gc&lt;/code&gt; 메타 메서드는이 순서를 따를 때만 작동합니다 ( &lt;a href=&quot;#2.5.3&quot;&gt;&amp;sect;2.5.3&lt;/a&gt; 참조 ). 객체 생성 직후에 객체의 메타 테이블을 설정하는 것도 좋은 방법입니다.</target>
        </trans-unit>
        <trans-unit id="1db3cf420aeec740d5b98f3c2218fb5a839f1cb0" translate="yes" xml:space="preserve">
          <source>It is implemented as a macro. The array &lt;code&gt;l&lt;/code&gt; must be the actual array, not a pointer to it.</source>
          <target state="translated">매크로로 구현됩니다. 배열 &lt;code&gt;l&lt;/code&gt; 은 포인터가 아닌 실제 배열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="c9afa0ea65ace9886d214c45b938bb7c94f5de0d" translate="yes" xml:space="preserve">
          <source>It is implemented as the following macro:</source>
          <target state="translated">다음 매크로로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="783b6db8dfbf8f740fac86413ecee3fd449cddff" translate="yes" xml:space="preserve">
          <source>It is safe to load malformed binary chunks; &lt;code&gt;load&lt;/code&gt; signals an appropriate error. However, Lua does not check the consistency of the code inside binary chunks; running maliciously crafted bytecode can crash the interpreter.</source>
          <target state="translated">형식이 잘못된 바이너리 청크를로드하는 것이 안전합니다. &lt;code&gt;load&lt;/code&gt; 는 적절한 오류를 나타냅니다. 그러나 Lua는 바이너리 청크 내부의 코드 일관성을 확인하지 않습니다. 악의적으로 제작 된 바이트 코드를 실행하면 인터프리터가 충돌 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="190f1a01da6183ca61829ab46d875cc8475bbf31" translate="yes" xml:space="preserve">
          <source>It returns &lt;a href=&quot;#pdf-LUA_OK&quot;&gt;&lt;code&gt;LUA_OK&lt;/code&gt;&lt;/a&gt; if there are no errors, or an error code in case of errors (see &lt;a href=&quot;#4.4.1&quot;&gt;&amp;sect;4.4.1&lt;/a&gt;).</source>
          <target state="translated">오류가 없으면 &lt;a href=&quot;#pdf-LUA_OK&quot;&gt; &lt;code&gt;LUA_OK&lt;/code&gt; 를&lt;/a&gt; 반환 하고 오류가 발생하면 오류 코드를 반환 합니다 ( &lt;a href=&quot;#4.4.1&quot;&gt;&amp;sect;4.4.1&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="2562ec974531de3f4ff5f92b1e35fb5384a96e25" translate="yes" xml:space="preserve">
          <source>It returns false if there are no errors or true in case of errors.</source>
          <target state="translated">오류가 없으면 false를 반환하고 오류가 발생하면 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="53569202de7b24893f55608fc3a251509d5c5ed1" translate="yes" xml:space="preserve">
          <source>Labels and empty statements are called &lt;em&gt;void statements&lt;/em&gt;, as they perform no actions.</source>
          <target state="translated">레이블과 빈 명령문은 조치를 수행하지 않으므로 &lt;em&gt;void statement&lt;/em&gt; 라고 합니다.</target>
        </trans-unit>
        <trans-unit id="89b86ab0e66f527166d98df92ddbcf5416ed58f6" translate="yes" xml:space="preserve">
          <source>Language</source>
          <target state="translated">Language</target>
        </trans-unit>
        <trans-unit id="34328aff9c833379f4f7362578f7f6f3c35f336b" translate="yes" xml:space="preserve">
          <source>Language constructs will be explained using the usual extended BNF notation, in which {&lt;em&gt;a&lt;/em&gt;} means 0 or more &lt;em&gt;a&lt;/em&gt;'s, and [&lt;em&gt;a&lt;/em&gt;] means an optional &lt;em&gt;a&lt;/em&gt;. Non-terminals are shown like non-terminal, keywords are shown like &lt;b&gt;kword&lt;/b&gt;, and other terminal symbols are shown like &amp;lsquo;&lt;b&gt;=&lt;/b&gt;&amp;rsquo;. The complete syntax of Lua can be found in &lt;a href=&quot;#9&quot;&gt;&amp;sect;9&lt;/a&gt; at the end of this manual.</source>
          <target state="translated">언어 구문이되는 {일반적인 확장 BNF 표기법을 사용하여 설명한다 &lt;em&gt;a는&lt;/em&gt; 0~3 개 이상의 수단 [ '들과 ]는 선택 수단 &lt;em&gt;를&lt;/em&gt; . 비 터미널은 비 터미널처럼 표시되고 키워드는 &lt;b&gt;kword&lt;/b&gt; 와 같이 표시 되며 다른 터미널 기호는 ' &lt;b&gt;=&lt;/b&gt; ' 와 같이 표시 됩니다. Lua의 완전한 구문 은이 매뉴얼 끝의 &lt;a href=&quot;#9&quot;&gt;&amp;sect;9&lt;/a&gt; 에서 찾을 수 있습니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b15777583b377cc227a5505487783a1d631969a6" translate="yes" xml:space="preserve">
          <source>Leaves a copy of the module on the stack.</source>
          <target state="translated">스택에 모듈 사본을 남깁니다.</target>
        </trans-unit>
        <trans-unit id="c282589ab5afc326acf6f1bd9d84cafcef993944" translate="yes" xml:space="preserve">
          <source>Level 0 is the running function, level 1 is the function that called the running function, etc.</source>
          <target state="translated">레벨 0은 실행 기능이고, 레벨 1은 실행 기능이라고하는 기능입니다.</target>
        </trans-unit>
        <trans-unit id="bd2f93f70d8b01be186bad25b37a58b9b3ce91ea" translate="yes" xml:space="preserve">
          <source>Lexical Conventions</source>
          <target state="translated">어휘 규칙</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">MIT 라이센스에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="63d6bf8afb548c458acc9de58d99159419a5b08e" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#pdf-coroutine.create&quot;&gt;&lt;code&gt;coroutine.create&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;#pdf-coroutine.wrap&quot;&gt;&lt;code&gt;coroutine.wrap&lt;/code&gt;&lt;/a&gt; function also creates a coroutine, but instead of returning the coroutine itself, it returns a function that, when called, resumes the coroutine. Any arguments passed to this function go as extra arguments to &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt;&lt;code&gt;coroutine.resume&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#pdf-coroutine.wrap&quot;&gt;&lt;code&gt;coroutine.wrap&lt;/code&gt;&lt;/a&gt; returns all the values returned by &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt;&lt;code&gt;coroutine.resume&lt;/code&gt;&lt;/a&gt;, except the first one (the boolean error code). Unlike &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt;&lt;code&gt;coroutine.resume&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pdf-coroutine.wrap&quot;&gt;&lt;code&gt;coroutine.wrap&lt;/code&gt;&lt;/a&gt; does not catch errors; any error is propagated to the caller.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;#pdf-coroutine.create&quot;&gt; &lt;code&gt;coroutine.create&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;#pdf-coroutine.wrap&quot;&gt; &lt;code&gt;coroutine.wrap&lt;/code&gt; &lt;/a&gt; 기능은 코 루틴을 생성하지만 대신에 코 루틴 자체를 반환하는, 그것은 호출시로 코 루틴을 다시 시작하는 함수를 반환합니다. 이 함수에 전달 된 인수는 &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt; &lt;code&gt;coroutine.resume&lt;/code&gt; 에 대한&lt;/a&gt; 추가 인수로 사용됩니다 . &lt;a href=&quot;#pdf-coroutine.wrap&quot;&gt; &lt;code&gt;coroutine.wrap&lt;/code&gt; &lt;/a&gt; 반환 모든 값에 의해 반환 &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt; &lt;code&gt;coroutine.resume&lt;/code&gt; &lt;/a&gt; 첫 번째 (부울 오류 코드)를 제외하고. 달리 &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt; &lt;code&gt;coroutine.resume&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#pdf-coroutine.wrap&quot;&gt; &lt;code&gt;coroutine.wrap&lt;/code&gt; 는&lt;/a&gt; 오류를 포착하지 않는다; 모든 오류는 호출자에게 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="9f39f04881560be91c1cf898317730aebddff532" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#pdf-coroutine.create&quot;&gt;&lt;code&gt;coroutine.create&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;#pdf-coroutine.wrap&quot;&gt;&lt;code&gt;coroutine.wrap&lt;/code&gt;&lt;/a&gt; function also creates a coroutine, but instead of returning the coroutine itself, it returns a function that, when called, resumes the coroutine. Any arguments passed to this function go as extra arguments to &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt;&lt;code&gt;coroutine.resume&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#pdf-coroutine.wrap&quot;&gt;&lt;code&gt;coroutine.wrap&lt;/code&gt;&lt;/a&gt; returns all the values returned by &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt;&lt;code&gt;coroutine.resume&lt;/code&gt;&lt;/a&gt;, except the first one (the boolean error code). Unlike &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt;&lt;code&gt;coroutine.resume&lt;/code&gt;&lt;/a&gt;, the function created by &lt;a href=&quot;#pdf-coroutine.wrap&quot;&gt;&lt;code&gt;coroutine.wrap&lt;/code&gt;&lt;/a&gt; propagates any error to the caller. In this case, the function also closes the coroutine (see &lt;a href=&quot;#pdf-coroutine.close&quot;&gt;&lt;code&gt;coroutine.close&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;#pdf-coroutine.create&quot;&gt; &lt;code&gt;coroutine.create&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;#pdf-coroutine.wrap&quot;&gt; &lt;code&gt;coroutine.wrap&lt;/code&gt; &lt;/a&gt; 기능은 코 루틴을 생성하지만 대신에 코 루틴 자체를 반환하는, 그것은 호출시로 코 루틴을 다시 시작하는 함수를 반환합니다. 이 함수에 전달 된 모든 인수는 &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt; &lt;code&gt;coroutine.resume&lt;/code&gt; 에 대한&lt;/a&gt; 추가 인수로 이동 합니다. &lt;a href=&quot;#pdf-coroutine.wrap&quot;&gt; &lt;code&gt;coroutine.wrap&lt;/code&gt; &lt;/a&gt; 반환 모든 값에 의해 반환 &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt; &lt;code&gt;coroutine.resume&lt;/code&gt; &lt;/a&gt; 첫 번째 (부울 오류 코드)를 제외하고. 달리 &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt; &lt;code&gt;coroutine.resume&lt;/code&gt; &lt;/a&gt; 에 의해 생성 된 함수 &lt;a href=&quot;#pdf-coroutine.wrap&quot;&gt; &lt;code&gt;coroutine.wrap&lt;/code&gt; 는&lt;/a&gt; 호출자에게 오류 전파. 이 경우, 함수는 코 루틴을 (참조 폐쇄 &lt;a href=&quot;#pdf-coroutine.close&quot;&gt; &lt;code&gt;coroutine.close&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="589bb9a9b2f8417c5c99beaf7b463ed9bff7b7a8" translate="yes" xml:space="preserve">
          <source>Like any other reference manual, this document is dry in places. For a discussion of the decisions behind the design of Lua, see the technical papers available at Lua's web site. For a detailed introduction to programming in Lua, see Roberto's book, &lt;em&gt;Programming in Lua&lt;/em&gt;.</source>
          <target state="translated">다른 참조 설명서와 마찬가지로이 문서는 건조한 상태입니다. Lua 디자인의 결정에 대한 논의는 Lua 웹 사이트에서 제공되는 기술 문서를 참조하십시오. Lua 프로그래밍에 대한 자세한 소개는 Roberto의 책, &lt;em&gt;Programming in Lua를&lt;/em&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0685b0afda8aac522f92e3eb98e6860f9fdecb1c" translate="yes" xml:space="preserve">
          <source>Like indices, the values of table fields can be of any type. In particular, because functions are first-class values, table fields can contain functions. Thus tables can also carry &lt;em&gt;methods&lt;/em&gt; (see &lt;a href=&quot;#3.4.11&quot;&gt;&amp;sect;3.4.11&lt;/a&gt;).</source>
          <target state="translated">인덱스와 마찬가지로 테이블 필드의 값은 모든 유형이 될 수 있습니다. 특히 함수는 일류 값이므로 테이블 필드에는 함수가 포함될 수 있습니다. 따라서 테이블은 &lt;em&gt;메소드&lt;/em&gt; 를 전달할 수도 있습니다 ( &lt;a href=&quot;#3.4.11&quot;&gt;&amp;sect;3.4.11&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="8afe6c1d451218575629deb4965cb995c2e958ea" translate="yes" xml:space="preserve">
          <source>Like with indexing, the metamethod for this event can be either a function or a table. If it is a function, it is called with &lt;code&gt;table&lt;/code&gt;, &lt;code&gt;key&lt;/code&gt;, and &lt;code&gt;value&lt;/code&gt; as arguments. If it is a table, Lua does an indexing assignment to this table with the same key and value. (This assignment is regular, not raw, and therefore can trigger another metamethod.)</source>
          <target state="translated">인덱싱과 마찬가지로이 이벤트의 메타 메소드는 함수 또는 테이블 일 수 있습니다. 함수 인 경우 &lt;code&gt;table&lt;/code&gt; , &lt;code&gt;key&lt;/code&gt; 및 &lt;code&gt;value&lt;/code&gt; 를 인수로 사용하여 호출됩니다. 테이블 인 경우 Lua는 동일한 키와 값으로이 테이블에 인덱싱 할당을 수행합니다. (이 할당은 기본이 아닌 원시이므로 다른 메타 메소드를 트리거 할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="b37120a70be7b7e2fa099662ff64ecef444b9310" translate="yes" xml:space="preserve">
          <source>Like with indexing, the metavalue for this event can be either a function, a table, or any value with an &lt;code&gt;__newindex&lt;/code&gt; metavalue. If it is a function, it is called with &lt;code&gt;table&lt;/code&gt;, &lt;code&gt;key&lt;/code&gt;, and &lt;code&gt;value&lt;/code&gt; as arguments. Otherwise, Lua repeats the indexing assignment over this metavalue with the same key and value. This assignment is regular, not raw, and therefore can trigger another &lt;code&gt;__newindex&lt;/code&gt; metavalue.</source>
          <target state="translated">인덱싱과 마찬가지로이 이벤트의 &lt;code&gt;__newindex&lt;/code&gt; 값은 함수, 테이블 또는 __newindex 메타 값이있는 모든 값이 될 수 있습니다 . 함수이면 &lt;code&gt;table&lt;/code&gt; , &lt;code&gt;key&lt;/code&gt; , &lt;code&gt;value&lt;/code&gt; 를 인수로 사용하여 호출됩니다. 그렇지 않으면 Lua는 동일한 키와 값을 사용하여이 메타 값에 대해 인덱싱 할당을 반복합니다. 이 할당은 원시가 아닌 규칙적이므로 다른 &lt;code&gt;__newindex&lt;/code&gt; 메타 값을 트리거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="86fb0e6b085882445de9a7a2409c78eb9059df37" translate="yes" xml:space="preserve">
          <source>Literal decimal integer constants that overflow are read as floats, instead of wrapping around. You can use hexadecimal notation for such constants if you want the old behavior (reading them as integers with wrap around).</source>
          <target state="translated">오버플로되는 리터럴 십진 정수 상수는 래핑 대신 부동 소수점으로 읽습니다. 이전 동작을 원할 경우 이러한 상수에 16 진수 표기법을 사용할 수 있습니다 (둘러싸는 정수로 읽음).</target>
        </trans-unit>
        <trans-unit id="5cf4bcbf4e9a4c997d9f25e1a4ebd39ad823de69" translate="yes" xml:space="preserve">
          <source>Literal strings can also be defined using a long format enclosed by &lt;em&gt;long brackets&lt;/em&gt;. We define an &lt;em&gt;opening long bracket of level &lt;em&gt;n&lt;/em&gt;&lt;/em&gt; as an opening square bracket followed by &lt;em&gt;n&lt;/em&gt; equal signs followed by another opening square bracket. So, an opening long bracket of level 0 is written as &lt;code&gt;[[&lt;/code&gt;, an opening long bracket of level 1 is written as &lt;code&gt;[=[&lt;/code&gt;, and so on. A &lt;em&gt;closing long bracket&lt;/em&gt; is defined similarly; for instance, a closing long bracket of level 4 is written as &lt;code&gt;]====]&lt;/code&gt;. A &lt;em&gt;long literal&lt;/em&gt; starts with an opening long bracket of any level and ends at the first closing long bracket of the same level. It can contain any text except a closing bracket of the same level. Literals in this bracketed form can run for several lines, do not interpret any escape sequences, and ignore long brackets of any other level. Any kind of end-of-line sequence (carriage return, newline, carriage return followed by newline, or newline followed by carriage return) is converted to a simple newline.</source>
          <target state="translated">리터럴 문자열은 &lt;em&gt;긴 대괄호로&lt;/em&gt; 묶인 긴 형식을 사용하여 정의 할 수도 있습니다 . 우리는 &lt;em&gt;&lt;em&gt;n&lt;/em&gt;&lt;/em&gt;&lt;em&gt; 레벨&lt;em&gt;&lt;/em&gt;&lt;/em&gt; 의 &lt;em&gt;여는 긴 괄호를&lt;/em&gt; 여는 사각형 괄호, &lt;em&gt;n 개의&lt;/em&gt; 등호, 다른 여는 사각형 괄호로 정의합니다. 따라서 레벨 0의 여는 긴 괄호는 &lt;code&gt;[[&lt;/code&gt; 로 , 레벨 1의 여는 긴 괄호는 &lt;code&gt;[=[&lt;/code&gt; 등) 로 쓰여 집니다. &lt;em&gt;닫는 긴 브래킷&lt;/em&gt; 유사하게 정의된다; 예를 들어, 레벨 4의 닫는 긴 대괄호는 &lt;code&gt;]====]&lt;/code&gt; 로 작성됩니다 . &lt;em&gt;긴 문자&lt;/em&gt;모든 레벨의 오프닝 롱 브래킷으로 시작하여 동일한 레벨의 첫 번째 클로징 롱 브래킷에서 끝납니다. 동일한 레벨의 닫는 대괄호를 제외한 모든 텍스트를 포함 할 수 있습니다. 이 대괄호 형식의 리터럴은 여러 줄에 걸쳐 실행될 수 있으며 이스케이프 시퀀스를 해석하지 않으며 다른 레벨의 긴 대괄호는 무시합니다. 모든 종류의 줄 끝 시퀀스 (캐리지 리턴, 줄 바꿈, 캐리지 리턴 뒤에 줄 바꿈 또는 줄 바꿈 뒤에 오는 줄 바꿈)는 간단한 줄 바꿈으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="7806930c3347438897b185e0ff1d0adc3021f8d3" translate="yes" xml:space="preserve">
          <source>Literal strings can also be defined using a long format enclosed by &lt;em&gt;long brackets&lt;/em&gt;. We define an &lt;em&gt;opening long bracket of level &lt;em&gt;n&lt;/em&gt;&lt;/em&gt; as an opening square bracket followed by &lt;em&gt;n&lt;/em&gt; equal signs followed by another opening square bracket. So, an opening long bracket of level 0 is written as &lt;code&gt;[[&lt;/code&gt;, an opening long bracket of level 1 is written as &lt;code&gt;[=[&lt;/code&gt;, and so on. A &lt;em&gt;closing long bracket&lt;/em&gt; is defined similarly; for instance, a closing long bracket of level 4 is written as &lt;code&gt;]====]&lt;/code&gt;. A &lt;em&gt;long literal&lt;/em&gt; starts with an opening long bracket of any level and ends at the first closing long bracket of the same level. It can contain any text except a closing bracket of the same level. Literals in this bracketed form can run for several lines, do not interpret any escape sequences, and ignore long brackets of any other level. Any kind of end-of-line sequence (carriage return, newline, carriage return followed by newline, or newline followed by carriage return) is converted to a simple newline. When the opening long bracket is immediately followed by a newline, the newline is not included in the string.</source>
          <target state="translated">리터럴 문자열은 &lt;em&gt;긴 대괄호로&lt;/em&gt; 묶인 긴 형식을 사용하여 정의 할 수도 있습니다 . &lt;em&gt;레벨 &lt;em&gt;n&lt;/em&gt;&lt;/em&gt; 의 &lt;em&gt;여는 긴 대괄호를&lt;/em&gt; 여는 대괄호, &lt;em&gt;n 개의&lt;/em&gt; 등호 다음에 또 다른 여는 대괄호로 정의합니다. 따라서 레벨 0의 여는 긴 대괄호는 &lt;code&gt;[[&lt;/code&gt; 으로 작성되고 레벨 1의 여는 긴 대괄호는 &lt;code&gt;[=[&lt;/code&gt; 등 으로 작성됩니다 . &lt;em&gt;닫는 긴 브래킷&lt;/em&gt; 유사하게 정의된다; 예를 들어, 레벨 4의 닫는 긴 괄호는 &lt;code&gt;]====]&lt;/code&gt; 로 작성됩니다 . &lt;em&gt;긴 문자&lt;/em&gt;모든 수준의 여는 긴 대괄호로 시작하여 같은 수준의 첫 번째 닫는 긴 대괄호에서 끝납니다. 동일한 수준의 닫는 대괄호를 제외한 모든 텍스트를 포함 할 수 있습니다. 이 대괄호 형식의 리터럴은 여러 줄에 대해 실행될 수 있으며 이스케이프 시퀀스를 해석하지 않으며 다른 수준의 긴 대괄호를 무시합니다. 모든 종류의 줄 끝 시퀀스 (캐리지 리턴, 개행, 캐리지 리턴 뒤에 개행 또는 개행 뒤에 캐리지 리턴)는 단순 개행으로 변환됩니다. 여는 긴 괄호 바로 뒤에 개행 문자가 오면 개행 문자가 문자열에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e1021ae8c4b84ca4a4e3486abedfb8d10587c094" translate="yes" xml:space="preserve">
          <source>Loads a Lua chunk without running it. If there are no errors, &lt;code&gt;lua_load&lt;/code&gt; pushes the compiled chunk as a Lua function on top of the stack. Otherwise, it pushes an error message.</source>
          <target state="translated">Lua 청크를 실행하지 않고로드합니다. 오류가 없으면 &lt;code&gt;lua_load&lt;/code&gt; 는 컴파일 된 청크를 스택의 Lua 함수로 푸시합니다. 그렇지 않으면 오류 메시지가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="d5d5fd2502388f4bdbfdc40480095cb9940c91fb" translate="yes" xml:space="preserve">
          <source>Loads a buffer as a Lua chunk. This function uses &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt; to load the chunk in the buffer pointed to by &lt;code&gt;buff&lt;/code&gt; with size &lt;code&gt;sz&lt;/code&gt;.</source>
          <target state="translated">버퍼를 Lua 청크로로드합니다. 이 함수는 &lt;a href=&quot;#lua_load&quot;&gt; &lt;code&gt;lua_load&lt;/code&gt; &lt;/a&gt; 를 사용하여 &lt;code&gt;sz&lt;/code&gt; 크기의 &lt;code&gt;buff&lt;/code&gt; 가 가리키는 버퍼에 청크를로드합니다 .</target>
        </trans-unit>
        <trans-unit id="014ceb5ba979a3f7460e80adaf03760442d4492f" translate="yes" xml:space="preserve">
          <source>Loads a chunk.</source>
          <target state="translated">청크를로드합니다.</target>
        </trans-unit>
        <trans-unit id="8dd06506aefef93d24f715ed25819bedec96323c" translate="yes" xml:space="preserve">
          <source>Loads a file as a Lua chunk. This function uses &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt; to load the chunk in the file named &lt;code&gt;filename&lt;/code&gt;. If &lt;code&gt;filename&lt;/code&gt; is &lt;code&gt;NULL&lt;/code&gt;, then it loads from the standard input. The first line in the file is ignored if it starts with a &lt;code&gt;#&lt;/code&gt;.</source>
          <target state="translated">파일을 Lua 청크로로드합니다. 이 함수는 &lt;a href=&quot;#lua_load&quot;&gt; &lt;code&gt;lua_load&lt;/code&gt; &lt;/a&gt; 를 사용하여 &lt;code&gt;filename&lt;/code&gt; 이라는 파일에 청크를로드합니다 . &lt;code&gt;filename&lt;/code&gt; 이 &lt;code&gt;NULL&lt;/code&gt; 인 경우 표준 입력에서로드됩니다. 파일의 첫 줄은 &lt;code&gt;#&lt;/code&gt; 로 시작하면 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="f640ebe64a89ecb5b9bd56467fcc7e3fb5298535" translate="yes" xml:space="preserve">
          <source>Loads a string as a Lua chunk. This function uses &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt; to load the chunk in the zero-terminated string &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">문자열을 루아 청크로로드합니다. 이 함수는 &lt;a href=&quot;#lua_load&quot;&gt; &lt;code&gt;lua_load&lt;/code&gt; &lt;/a&gt; 를 사용 하여 0으로 끝나는 문자열 &lt;code&gt;s&lt;/code&gt; 에 청크를로드합니다 .</target>
        </trans-unit>
        <trans-unit id="601f4f126ff0dc3c88078602ece1575bc60b38da" translate="yes" xml:space="preserve">
          <source>Loads and runs the given file. It is defined as the following macro:</source>
          <target state="translated">주어진 파일을로드하고 실행합니다. 다음 매크로로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="41daddb6c30d8daa7aa997ef002e9682aa252572" translate="yes" xml:space="preserve">
          <source>Loads and runs the given string. It is defined as the following macro:</source>
          <target state="translated">주어진 문자열을로드하고 실행합니다. 다음 매크로로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="07953018574342518cc4ef6ce0bb634e54cd3232" translate="yes" xml:space="preserve">
          <source>Loads the given module. The function starts by looking into the &lt;a href=&quot;#pdf-package.loaded&quot;&gt;&lt;code&gt;package.loaded&lt;/code&gt;&lt;/a&gt; table to determine whether &lt;code&gt;modname&lt;/code&gt; is already loaded. If it is, then &lt;code&gt;require&lt;/code&gt; returns the value stored at &lt;code&gt;package.loaded[modname]&lt;/code&gt;. (The absence of a second result in this case signals that this call did not have to load the module.) Otherwise, it tries to find a &lt;em&gt;loader&lt;/em&gt; for the module.</source>
          <target state="translated">주어진 모듈을로드합니다. 이 함수는 &lt;code&gt;modname&lt;/code&gt; 이 이미로드 되었는지 확인하기 위해 &lt;a href=&quot;#pdf-package.loaded&quot;&gt; &lt;code&gt;package.loaded&lt;/code&gt; &lt;/a&gt; 테이블을 조사하는 것으로 시작됩니다 . 그렇다면 &lt;code&gt;require&lt;/code&gt; 는 &lt;code&gt;package.loaded[modname]&lt;/code&gt; 저장된 값을 반환합니다 . (이 경우 두 번째 결과가 없으면이 호출이 모듈을로드 할 필요가 없음을 나타냅니다.) 그렇지 않으면 모듈의 &lt;em&gt;로더&lt;/em&gt; 를 찾으려고 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5754e2c7cbb7348e49d26f5b052dec66fe41474e" translate="yes" xml:space="preserve">
          <source>Loads the given module. The function starts by looking into the &lt;a href=&quot;#pdf-package.loaded&quot;&gt;&lt;code&gt;package.loaded&lt;/code&gt;&lt;/a&gt; table to determine whether &lt;code&gt;modname&lt;/code&gt; is already loaded. If it is, then &lt;code&gt;require&lt;/code&gt; returns the value stored at &lt;code&gt;package.loaded[modname]&lt;/code&gt;. Otherwise, it tries to find a &lt;em&gt;loader&lt;/em&gt; for the module.</source>
          <target state="translated">주어진 모듈을로드합니다. 이 함수는 &lt;a href=&quot;#pdf-package.loaded&quot;&gt; &lt;code&gt;package.loaded&lt;/code&gt; &lt;/a&gt; 테이블을 보고 &lt;code&gt;modname&lt;/code&gt; 이 이미로드되어 있는지 확인 하여 시작 합니다 . 이 경우 &lt;code&gt;require&lt;/code&gt; 는 &lt;code&gt;package.loaded[modname]&lt;/code&gt; 저장된 값을 반환합니다 . 그렇지 않으면 모듈 의 &lt;em&gt;로더&lt;/em&gt; 를 찾으려고 합니다.</target>
        </trans-unit>
        <trans-unit id="675ad816883ad3050b77c4af165af0c382872da3" translate="yes" xml:space="preserve">
          <source>Local Declarations</source>
          <target state="translated">현지 선언</target>
        </trans-unit>
        <trans-unit id="e74ccb9aead3e3f9b1bc796bf321e14c551c0f2e" translate="yes" xml:space="preserve">
          <source>Local variables can be declared anywhere inside a block. The declaration can include an initial assignment:</source>
          <target state="translated">지역 변수는 블록 내부 어디에서나 선언 될 수 있습니다. 선언에는 초기 과제가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c10d9e4965c7bd64f801ff5a335aa4dea4e1bdf4" translate="yes" xml:space="preserve">
          <source>Local variables can be declared anywhere inside a block. The declaration can include an initialization:</source>
          <target state="translated">지역 변수는 블록 내 어디에서나 선언 할 수 있습니다. 선언에는 초기화가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65eac6118ebdd55aa38b41f70efdf532e567ffd8" translate="yes" xml:space="preserve">
          <source>Logical Operators</source>
          <target state="translated">논리 연산자</target>
        </trans-unit>
        <trans-unit id="f3c2c12151d04fbe64aef12442234645ff418818" translate="yes" xml:space="preserve">
          <source>Looks for the first &lt;em&gt;match&lt;/em&gt; of &lt;code&gt;pattern&lt;/code&gt; (see &lt;a href=&quot;#6.4.1&quot;&gt;&amp;sect;6.4.1&lt;/a&gt;) in the string &lt;code&gt;s&lt;/code&gt;. If it finds one, then &lt;code&gt;match&lt;/code&gt; returns the captures from the pattern; otherwise it returns &lt;b&gt;nil&lt;/b&gt;. If &lt;code&gt;pattern&lt;/code&gt; specifies no captures, then the whole match is returned. A third, optional numeric argument &lt;code&gt;init&lt;/code&gt; specifies where to start the search; its default value is 1 and can be negative.</source>
          <target state="translated">첫 번째 찾습니다 &lt;em&gt;경기&lt;/em&gt; 의 &lt;code&gt;pattern&lt;/code&gt; (참조 &lt;a href=&quot;#6.4.1&quot;&gt;&amp;sect;6.4.1&lt;/a&gt; 문자열에서) &lt;code&gt;s&lt;/code&gt; . 하나를 찾으면 &lt;code&gt;match&lt;/code&gt; 는 패턴에서 캡처를 리턴합니다. 그렇지 않으면 &lt;b&gt;nil&lt;/b&gt; 을 반환합니다 . &lt;code&gt;pattern&lt;/code&gt; 이 캡처를 지정하지 않으면 전체 일치가 리턴됩니다. 세 번째 선택적 숫자 인수 &lt;code&gt;init&lt;/code&gt; 는 검색을 시작할 위치를 지정합니다. 기본값은 1이며 음수 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c9988ddc14961cb0c52bb6cea07ce6c02324d47" translate="yes" xml:space="preserve">
          <source>Looks for the first &lt;em&gt;match&lt;/em&gt; of the &lt;code&gt;pattern&lt;/code&gt; (see &lt;a href=&quot;#6.4.1&quot;&gt;&amp;sect;6.4.1&lt;/a&gt;) in the string &lt;code&gt;s&lt;/code&gt;. If it finds one, then &lt;code&gt;match&lt;/code&gt; returns the captures from the pattern; otherwise it returns &lt;b&gt;fail&lt;/b&gt;. If &lt;code&gt;pattern&lt;/code&gt; specifies no captures, then the whole match is returned. A third, optional numeric argument &lt;code&gt;init&lt;/code&gt; specifies where to start the search; its default value is 1 and can be negative.</source>
          <target state="translated">첫 번째 찾습니다 &lt;em&gt;경기&lt;/em&gt; 의 &lt;code&gt;pattern&lt;/code&gt; (참조 &lt;a href=&quot;#6.4.1&quot;&gt;&amp;sect;6.4.1&lt;/a&gt; 문자열에서) &lt;code&gt;s&lt;/code&gt; . 하나를 찾으면 &lt;code&gt;match&lt;/code&gt; 는 패턴에서 캡처를 반환합니다. 그렇지 않으면 &lt;b&gt;실패를&lt;/b&gt; 반환합니다 . &lt;code&gt;pattern&lt;/code&gt; 이 캡처를 지정하지 않으면 전체 일치가 반환됩니다. 세 번째, 선택적 숫자 인수 &lt;code&gt;init&lt;/code&gt; 는 검색을 시작할 위치를 지정합니다. 기본값은 1이며 음수 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac72aba64827a6df2b943b8e5302e4719c3c812b" translate="yes" xml:space="preserve">
          <source>Looks for the first match of &lt;code&gt;pattern&lt;/code&gt; (see &lt;a href=&quot;#6.4.1&quot;&gt;&amp;sect;6.4.1&lt;/a&gt;) in the string &lt;code&gt;s&lt;/code&gt;. If it finds a match, then &lt;code&gt;find&lt;/code&gt; returns the indices of &lt;code&gt;s&lt;/code&gt; where this occurrence starts and ends; otherwise, it returns &lt;b&gt;fail&lt;/b&gt;. A third, optional numeric argument &lt;code&gt;init&lt;/code&gt; specifies where to start the search; its default value is 1 and can be negative. A value of &lt;b&gt;true&lt;/b&gt; as a fourth, optional argument &lt;code&gt;plain&lt;/code&gt; turns off the pattern matching facilities, so the function does a plain &quot;find substring&quot; operation, with no characters in &lt;code&gt;pattern&lt;/code&gt; being considered magic.</source>
          <target state="translated">문자열 &lt;code&gt;s&lt;/code&gt; 에서 첫 번째 &lt;code&gt;pattern&lt;/code&gt; 일치 ( &lt;a href=&quot;#6.4.1&quot;&gt;&amp;sect;6.4.1&lt;/a&gt; 참조 )를 찾습니다 . 일치하는 항목을 &lt;code&gt;find&lt;/code&gt; 는 이 발생이 시작되고 끝나는 &lt;code&gt;s&lt;/code&gt; 의 인덱스를 반환합니다 . 그렇지 않으면 &lt;b&gt;fail&lt;/b&gt; 을 반환합니다 . 세 번째, 선택적 숫자 인수 &lt;code&gt;init&lt;/code&gt; 는 검색을 시작할 위치를 지정합니다. 기본값은 1이며 음수 일 수 있습니다. 네 번째 선택적 인수 &lt;code&gt;plain&lt;/code&gt; 인 &lt;b&gt;true&lt;/b&gt; 값은 패턴 일치 기능을 해제 하므로이 함수는 &lt;code&gt;pattern&lt;/code&gt; 문자가 마법으로 간주 되지 않고 일반 &quot;부분 문자열 찾기&quot;작업을 수행 합니다.&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0531dd8559629f728382a45e8fa0141160f819b2" translate="yes" xml:space="preserve">
          <source>Looks for the first match of &lt;code&gt;pattern&lt;/code&gt; (see &lt;a href=&quot;#6.4.1&quot;&gt;&amp;sect;6.4.1&lt;/a&gt;) in the string &lt;code&gt;s&lt;/code&gt;. If it finds a match, then &lt;code&gt;find&lt;/code&gt; returns the indices of &lt;code&gt;s&lt;/code&gt; where this occurrence starts and ends; otherwise, it returns &lt;b&gt;nil&lt;/b&gt;. A third, optional numeric argument &lt;code&gt;init&lt;/code&gt; specifies where to start the search; its default value is 1 and can be negative. A value of &lt;b&gt;true&lt;/b&gt; as a fourth, optional argument &lt;code&gt;plain&lt;/code&gt; turns off the pattern matching facilities, so the function does a plain &quot;find substring&quot; operation, with no characters in &lt;code&gt;pattern&lt;/code&gt; being considered magic. Note that if &lt;code&gt;plain&lt;/code&gt; is given, then &lt;code&gt;init&lt;/code&gt; must be given as well.</source>
          <target state="translated">문자열 &lt;code&gt;s&lt;/code&gt; 에서 &lt;code&gt;pattern&lt;/code&gt; 의 첫 번째 일치 ( &lt;a href=&quot;#6.4.1&quot;&gt;&amp;sect;6.4.1&lt;/a&gt; 참조 )를 찾습니다 . 일치하는 것을 찾으면 &lt;code&gt;find&lt;/code&gt; 는 이 발생이 시작되고 끝나는 &lt;code&gt;s&lt;/code&gt; 의 색인을 리턴합니다 . 그렇지 않으면 &lt;b&gt;nil&lt;/b&gt; 을 반환합니다 . 세 번째 선택적 숫자 인수 &lt;code&gt;init&lt;/code&gt; 는 검색을 시작할 위치를 지정합니다. 기본값은 1이며 음수 일 수 있습니다. 네 번째, 선택적 인수 &lt;code&gt;plain&lt;/code&gt; 으로 &lt;b&gt;true&lt;/b&gt; 값을 지정 하면 패턴 일치 기능이 꺼 지므로이 함수는 &lt;code&gt;pattern&lt;/code&gt; 문자를 마술로 간주 하지 않고 일반 &quot;find substring&quot;작업을 수행 합니다. 참고 경우 &lt;code&gt;plain&lt;/code&gt; 다음 주어진다&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt; &lt;code&gt;init&lt;/code&gt; 도 주어져야합니다.</target>
        </trans-unit>
        <trans-unit id="b0832074630eb731d7fbe8074de48a90cd9bb220" translate="yes" xml:space="preserve">
          <source>Lua</source>
          <target state="translated">Lua</target>
        </trans-unit>
        <trans-unit id="74935e355c6d4299b6901e869daba41fae3ae4f2" translate="yes" xml:space="preserve">
          <source>Lua 5.3 Reference Manual</source>
          <target state="translated">Lua 5.3 참조 매뉴얼</target>
        </trans-unit>
        <trans-unit id="1c9ec46a65315e465f99f9adf0e3977cea4a15cf" translate="yes" xml:space="preserve">
          <source>Lua 5.4 Reference Manual</source>
          <target state="translated">Lua 5.4 참조 매뉴얼</target>
        </trans-unit>
        <trans-unit id="e8957a41e15b0eb53aad63ef201700fe8063f094" translate="yes" xml:space="preserve">
          <source>Lua allows multiple assignments. Therefore, the syntax for assignment defines a list of variables on the left side and a list of expressions on the right side. The elements in both lists are separated by commas:</source>
          <target state="translated">루아는 여러 할당을 허용합니다. 따라서 할당 구문은 왼쪽에있는 변수 목록과 오른쪽에있는 표현식 목록을 정의합니다. 두 목록의 요소는 쉼표로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="1e02808cd690aaf7df864db5c4c452af196be013" translate="yes" xml:space="preserve">
          <source>Lua also converts strings to numbers, whenever a number is expected.</source>
          <target state="translated">Lua는 또한 숫자가 필요할 때마다 문자열을 숫자로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="93377de262ae6c56472bd1d07591e21435ec1e52" translate="yes" xml:space="preserve">
          <source>Lua also defines the constants &lt;a id=&quot;pdf-LUA_MININTEGER&quot;&gt;&lt;code&gt;LUA_MININTEGER&lt;/code&gt;&lt;/a&gt; and &lt;a id=&quot;pdf-LUA_MAXINTEGER&quot;&gt;&lt;code&gt;LUA_MAXINTEGER&lt;/code&gt;&lt;/a&gt;, with the minimum and the maximum values that fit in this type.</source>
          <target state="translated">Lua는 또한 &lt;a id=&quot;pdf-LUA_MININTEGER&quot;&gt; &lt;code&gt;LUA_MININTEGER&lt;/code&gt; &lt;/a&gt; 및 &lt;a id=&quot;pdf-LUA_MAXINTEGER&quot;&gt; &lt;code&gt;LUA_MAXINTEGER&lt;/code&gt; &lt;/a&gt; 상수 를이 유형에 맞는 최소값과 최대 값으로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="801090e92a322f968636387436cbfb91aa33b154" translate="yes" xml:space="preserve">
          <source>Lua also has a &lt;b&gt;for&lt;/b&gt; statement, in two flavors (see &lt;a href=&quot;#3.3.5&quot;&gt;&amp;sect;3.3.5&lt;/a&gt;).</source>
          <target state="translated">루아는 또한 두 가지 맛 으로 &lt;b&gt;for&lt;/b&gt; 문을 가지고있다 ( &lt;a href=&quot;#3.3.5&quot;&gt;&amp;sect;3.3.5&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="b8bd17007ccbbeb2e48374787c45da4db96657dd" translate="yes" xml:space="preserve">
          <source>Lua also offers a system of &lt;em&gt;warnings&lt;/em&gt; (see &lt;a href=&quot;#pdf-warn&quot;&gt;&lt;code&gt;warn&lt;/code&gt;&lt;/a&gt;). Unlike errors, warnings do not interfere in any way with program execution. They typically only generate a message to the user, although this behavior can be adapted from C (see &lt;a href=&quot;#lua_setwarnf&quot;&gt;&lt;code&gt;lua_setwarnf&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Lua는 &lt;em&gt;경고&lt;/em&gt; 시스템도 제공합니다 ( &lt;a href=&quot;#pdf-warn&quot;&gt; &lt;code&gt;warn&lt;/code&gt; &lt;/a&gt; 참조 ). 오류와 달리 경고는 프로그램 실행을 방해하지 않습니다. 이 동작은 C에서 조정할 수 있지만 일반적으로 사용자에게 메시지 만 생성합니다 ( &lt;a href=&quot;#lua_setwarnf&quot;&gt; &lt;code&gt;lua_setwarnf&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="3da908593ea7c1cd8a16b5d87a2733072f9be916" translate="yes" xml:space="preserve">
          <source>Lua assumes the following behavior from the allocator function:</source>
          <target state="translated">Lua는 할당 자 함수에서 다음과 같은 동작을 가정합니다.</target>
        </trans-unit>
        <trans-unit id="ebffede5db745b98cdaa093a245240704c9e96b1" translate="yes" xml:space="preserve">
          <source>Lua can call (and manipulate) functions written in Lua and functions written in C (see &lt;a href=&quot;#3.4.10&quot;&gt;&amp;sect;3.4.10&lt;/a&gt;). Both are represented by the type &lt;em&gt;function&lt;/em&gt;.</source>
          <target state="translated">Lua는 Lua로 작성된 함수와 C로 작성된 함수를 호출 (및 조작) 할 수 있습니다 ( &lt;a href=&quot;#3.4.10&quot;&gt;&amp;sect;3.4.10&lt;/a&gt; 참조 ). 둘 다 유형 &lt;em&gt;함수&lt;/em&gt; 로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="95c6862384367c489829b9fcf5d130d494969aa1" translate="yes" xml:space="preserve">
          <source>Lua code can explicitly generate an error by calling the &lt;a href=&quot;#pdf-error&quot;&gt;&lt;code&gt;error&lt;/code&gt;&lt;/a&gt; function. If you need to catch errors in Lua, you can use &lt;a href=&quot;#pdf-pcall&quot;&gt;&lt;code&gt;pcall&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#pdf-xpcall&quot;&gt;&lt;code&gt;xpcall&lt;/code&gt;&lt;/a&gt; to call a given function in &lt;em&gt;protected mode&lt;/em&gt;.</source>
          <target state="translated">루아 코드는 &lt;a href=&quot;#pdf-error&quot;&gt; &lt;code&gt;error&lt;/code&gt; &lt;/a&gt; 함수 를 호출하여 명시 적으로 오류를 생성 할 수 있습니다 . Lua에서 오류를 잡아야하는 경우 &lt;a href=&quot;#pdf-pcall&quot;&gt; &lt;code&gt;pcall&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#pdf-xpcall&quot;&gt; &lt;code&gt;xpcall&lt;/code&gt; &lt;/a&gt; 을 사용 하여 &lt;em&gt;보호 모드&lt;/em&gt; 에서 지정된 함수를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1dc01b0813afb0e9f0eaf4570d6c6a76184553b6" translate="yes" xml:space="preserve">
          <source>Lua code can explicitly raise an error by calling the &lt;a href=&quot;#pdf-error&quot;&gt;&lt;code&gt;error&lt;/code&gt;&lt;/a&gt; function. (This function never returns.)</source>
          <target state="translated">Lua 코드는 &lt;a href=&quot;#pdf-error&quot;&gt; &lt;code&gt;error&lt;/code&gt; &lt;/a&gt; 함수 를 호출하여 명시 적으로 오류를 발생시킬 수 있습니다 . (이 함수는 반환되지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="1864a075a2790c597421da62110c2e5ddf9a0670" translate="yes" xml:space="preserve">
          <source>Lua combines simple procedural syntax with powerful data description constructs based on associative arrays and extensible semantics. Lua is dynamically typed, runs by interpreting bytecode with a register-based virtual machine, and has automatic memory management with a generational garbage collection, making it ideal for configuration, scripting, and rapid prototyping.</source>
          <target state="translated">Lua는 간단한 절차 적 구문과 연관 배열 및 확장 가능한 의미 체계를 기반으로하는 강력한 데이터 설명 구조를 결합합니다. Lua는 동적으로 입력되고 레지스터 기반 가상 머신으로 바이트 코드를 해석하여 실행되며 세대 별 가비지 수집을 통한 자동 메모리 관리 기능이있어 구성, 스크립팅 및 신속한 프로토 타이핑에 이상적입니다.</target>
        </trans-unit>
        <trans-unit id="55000944726bac35e3a7a8c2c659ce8ea827ae88" translate="yes" xml:space="preserve">
          <source>Lua combines simple procedural syntax with powerful data description constructs based on associative arrays and extensible semantics. Lua is dynamically typed, runs by interpreting bytecode with a register-based virtual machine, and has automatic memory management with incremental garbage collection, making it ideal for configuration, scripting, and rapid prototyping.</source>
          <target state="translated">Lua는 간단한 절차 적 구문과 연관 배열 및 확장 가능한 의미론을 기반으로하는 강력한 데이터 설명 구성을 결합합니다. Lua는 동적으로 유형이 지정되고 레지스터 기반 가상 머신으로 바이트 코드를 해석하여 실행되며 증분 가비지 콜렉션을 통해 자동 메모리 관리 기능을 갖추고있어 구성, 스크립팅 및 신속한 프로토 타이핑에 이상적입니다.</target>
        </trans-unit>
        <trans-unit id="8c26f824cf75010655e9550b8fde705425a3784c" translate="yes" xml:space="preserve">
          <source>Lua does not check the consistency of binary chunks. Maliciously crafted binary chunks can crash the interpreter.</source>
          <target state="translated">루아는 이진 청크의 일관성을 검사하지 않습니다. 악의적으로 제작 된 이진 덩어리가 인터프리터를 손상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a5e8dc647ce5f791a0e6cc5be4cbed5172328da" translate="yes" xml:space="preserve">
          <source>Lua handles a chunk as the body of an anonymous function with a variable number of arguments (see &lt;a href=&quot;#3.4.11&quot;&gt;&amp;sect;3.4.11&lt;/a&gt;). As such, chunks can define local variables, receive arguments, and return values. Moreover, such anonymous function is compiled as in the scope of an external local variable called &lt;code&gt;_ENV&lt;/code&gt; (see &lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt;). The resulting function always has &lt;code&gt;_ENV&lt;/code&gt; as its only external variable, even if it does not use that variable.</source>
          <target state="translated">Lua는 가변 개수의 인수를 가진 익명 함수의 본문으로 청크를 처리합니다 ( &lt;a href=&quot;#3.4.11&quot;&gt;&amp;sect;3.4.11&lt;/a&gt; 참조 ). 따라서 청크는 지역 변수를 정의하고 인수를 받고 값을 반환 할 수 있습니다. 또한 이러한 익명 함수는 &lt;code&gt;_ENV&lt;/code&gt; 라는 외부 지역 변수의 범위 에서처럼 컴파일됩니다 ( &lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt; 참조 ). 결과 함수는 해당 변수를 사용하지 않더라도 항상 &lt;code&gt;_ENV&lt;/code&gt; 를 유일한 외부 변수로 갖 습니다.</target>
        </trans-unit>
        <trans-unit id="35b65ab36f2f47f5954bb270f0f9be36cfe1a6ba" translate="yes" xml:space="preserve">
          <source>Lua handles a chunk as the body of an anonymous function with a variable number of arguments (see &lt;a href=&quot;#3.4.11&quot;&gt;&amp;sect;3.4.11&lt;/a&gt;). As such, chunks can define local variables, receive arguments, and return values. Moreover, such anonymous function is compiled as in the scope of an external local variable called &lt;code&gt;_ENV&lt;/code&gt; (see &lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt;). The resulting function always has &lt;code&gt;_ENV&lt;/code&gt; as its only upvalue, even if it does not use that variable.</source>
          <target state="translated">Lua는 다양한 수의 인수를 사용하여 익명 함수 본문으로 청크를 처리합니다 ( &lt;a href=&quot;#3.4.11&quot;&gt;&amp;sect;3.4.11&lt;/a&gt; 참조 ). 따라서 청크는 지역 변수를 정의하고 인수를 받고 값을 반환 할 수 있습니다. 또한 이러한 익명 함수는 &lt;code&gt;_ENV&lt;/code&gt; 라는 외부 로컬 변수의 범위에서와 같이 컴파일됩니다 ( &lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt; 참조 ). 결과 함수는 해당 변수를 사용하지 않더라도 항상 &lt;code&gt;_ENV&lt;/code&gt; 를 유일한 업값으로 갖습니다.</target>
        </trans-unit>
        <trans-unit id="7bb5694782dd5240f5a360755736e520cb7caddd" translate="yes" xml:space="preserve">
          <source>Lua has &lt;em&gt;empty statements&lt;/em&gt; that allow you to separate statements with semicolons, start a block with a semicolon or write two semicolons in sequence:</source>
          <target state="translated">Lua에는 세미콜론으로 명령문을 구분하거나 세미콜론으로 블록을 시작하거나 두 개의 세미콜론을 순서대로 작성할 수 &lt;em&gt;있는 빈 명령문&lt;/em&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e19bed5c0654df07eeefc8d0dbcff0cc7fb976e" translate="yes" xml:space="preserve">
          <source>Lua has explicit rules about when each subtype is used, but it also converts between them automatically as needed (see &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3&lt;/a&gt;). Therefore, the programmer may choose to mostly ignore the difference between integers and floats or to assume complete control over the representation of each number.</source>
          <target state="translated">Lua에는 각 하위 유형이 사용되는시기에 대한 명시적인 규칙이 있지만 필요에 따라 자동으로 변환하기도합니다 ( &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3&lt;/a&gt; 참조 ). 따라서 프로그래머는 대부분 정수와 부동 소수점의 차이를 무시하거나 각 숫자의 표현을 완전히 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08b67a26f91c4bb6ecbeaabc79499925202576c4" translate="yes" xml:space="preserve">
          <source>Lua has no built-in debugging facilities. Instead, it offers a special interface by means of functions and &lt;em&gt;hooks&lt;/em&gt;. This interface allows the construction of different kinds of debuggers, profilers, and other tools that need &quot;inside information&quot; from the interpreter.</source>
          <target state="translated">Lua에는 내장 된 디버깅 기능이 없습니다. 대신, 함수와 &lt;em&gt;후크를&lt;/em&gt; 통해 특별한 인터페이스를 제공합니다 . 이 인터페이스를 통해 다양한 종류의 디버거, 프로파일 러 및 인터프리터의 &quot;내부 정보&quot;가 필요한 기타 도구를 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab53ba5d8b707a086c1f55306a5e491b7ca0c834" translate="yes" xml:space="preserve">
          <source>Lua implements an incremental mark-and-sweep collector. It uses two numbers to control its garbage-collection cycles: the &lt;em&gt;garbage-collector pause&lt;/em&gt; and the &lt;em&gt;garbage-collector step multiplier&lt;/em&gt;. Both use percentage points as units (e.g., a value of 100 means an internal value of 1).</source>
          <target state="translated">Lua는 증분 표시 및 스윕 수집기를 구현합니다. &lt;em&gt;가비지 수집기 일시 정지&lt;/em&gt; 및 &lt;em&gt;가비지 수집기 단계 승수의&lt;/em&gt; 두 가지 숫자를 사용하여 가비지 수집주기를 제어합니다 . 둘 다 백분율 포인트를 단위로 사용합니다 (예 : 값 100은 내부 값 1을 의미 함).</target>
        </trans-unit>
        <trans-unit id="ad855bd45416f0333645541d1257309374015262" translate="yes" xml:space="preserve">
          <source>Lua initializes its pseudo-random generator with the equivalent of a call to &lt;a href=&quot;#pdf-math.randomseed&quot;&gt;&lt;code&gt;math.randomseed&lt;/code&gt;&lt;/a&gt; with no arguments, so that &lt;code&gt;math.random&lt;/code&gt; should generate different sequences of results each time the program runs.</source>
          <target state="translated">Lua 는 인수없이 &lt;a href=&quot;#pdf-math.randomseed&quot;&gt; &lt;code&gt;math.randomseed&lt;/code&gt; &lt;/a&gt; 에 대한 호출에 해당하는 의사 난수 생성기를 초기화 하므로 &lt;code&gt;math.random&lt;/code&gt; 은 프로그램이 실행될 때마다 다른 결과 시퀀스를 생성해야합니다.</target>
        </trans-unit>
        <trans-unit id="4be60237bd80620e268374029f3211e510b05c17" translate="yes" xml:space="preserve">
          <source>Lua initializes the C path &lt;a href=&quot;#pdf-package.cpath&quot;&gt;&lt;code&gt;package.cpath&lt;/code&gt;&lt;/a&gt; in the same way it initializes the Lua path &lt;a href=&quot;#pdf-package.path&quot;&gt;&lt;code&gt;package.path&lt;/code&gt;&lt;/a&gt;, using the environment variable &lt;a id=&quot;pdf-LUA_CPATH_5_3&quot;&gt;&lt;code&gt;LUA_CPATH_5_3&lt;/code&gt;&lt;/a&gt;, or the environment variable &lt;a id=&quot;pdf-LUA_CPATH&quot;&gt;&lt;code&gt;LUA_CPATH&lt;/code&gt;&lt;/a&gt;, or a default path defined in &lt;code&gt;luaconf.h&lt;/code&gt;.</source>
          <target state="translated">루아가 C 경로 초기화 &lt;a href=&quot;#pdf-package.cpath&quot;&gt; &lt;code&gt;package.cpath&lt;/code&gt; &lt;/a&gt; 같은 방법은 루아 경로 초기화의 &lt;a href=&quot;#pdf-package.path&quot;&gt; &lt;code&gt;package.path&lt;/code&gt; 를&lt;/a&gt; 환경 변수 사용 &lt;a id=&quot;pdf-LUA_CPATH_5_3&quot;&gt; &lt;code&gt;LUA_CPATH_5_3&lt;/code&gt; &lt;/a&gt; 또는 환경 변수 &lt;a id=&quot;pdf-LUA_CPATH&quot;&gt; &lt;code&gt;LUA_CPATH&lt;/code&gt; &lt;/a&gt; 또는에 정의 된 기본 경로 &lt;code&gt;luaconf.h&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="9dd87e2bc11c5d748dd2ecd3b8a3e7dcc5b9ccfa" translate="yes" xml:space="preserve">
          <source>Lua initializes the C path &lt;a href=&quot;#pdf-package.cpath&quot;&gt;&lt;code&gt;package.cpath&lt;/code&gt;&lt;/a&gt; in the same way it initializes the Lua path &lt;a href=&quot;#pdf-package.path&quot;&gt;&lt;code&gt;package.path&lt;/code&gt;&lt;/a&gt;, using the environment variable &lt;a id=&quot;pdf-LUA_CPATH_5_4&quot;&gt;&lt;code&gt;LUA_CPATH_5_4&lt;/code&gt;&lt;/a&gt;, or the environment variable &lt;a id=&quot;pdf-LUA_CPATH&quot;&gt;&lt;code&gt;LUA_CPATH&lt;/code&gt;&lt;/a&gt;, or a default path defined in &lt;code&gt;luaconf.h&lt;/code&gt;.</source>
          <target state="translated">루아가 C 경로 초기화 &lt;a href=&quot;#pdf-package.cpath&quot;&gt; &lt;code&gt;package.cpath&lt;/code&gt; &lt;/a&gt; 같은 방법은 루아 경로 초기화의 &lt;a href=&quot;#pdf-package.path&quot;&gt; &lt;code&gt;package.path&lt;/code&gt; 를&lt;/a&gt; 환경 변수 사용 &lt;a id=&quot;pdf-LUA_CPATH_5_4&quot;&gt; &lt;code&gt;LUA_CPATH_5_4&lt;/code&gt; &lt;/a&gt; 또는 환경 변수 &lt;a id=&quot;pdf-LUA_CPATH&quot;&gt; &lt;code&gt;LUA_CPATH&lt;/code&gt; &lt;/a&gt; 또는에 정의 된 기본 경로 &lt;code&gt;luaconf.h&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="4714009f33265bf1fc4688da888d62c97c45d7b7" translate="yes" xml:space="preserve">
          <source>Lua initializes this table with four searcher functions.</source>
          <target state="translated">Lua는이 테이블을 4 가지 검색 기능으로 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="ef9edf704545b26dfa394b151700f2e58198d961" translate="yes" xml:space="preserve">
          <source>Lua is a &lt;em&gt;dynamically typed language&lt;/em&gt;. This means that variables do not have types; only values do. There are no type definitions in the language. All values carry their own type.</source>
          <target state="translated">루아는 &lt;em&gt;동적으로 입력되는 언어&lt;/em&gt; 입니다. 이는 변수에 유형이 없음을 의미합니다. 값만 있습니다. 언어에는 유형 정의가 없습니다. 모든 값에는 고유 한 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="768b1dfa86b0332cedc5bdb9fcc8e17166f9ef47" translate="yes" xml:space="preserve">
          <source>Lua is a case-sensitive language: &lt;code&gt;and&lt;/code&gt; is a reserved word, but &lt;code&gt;And&lt;/code&gt; and &lt;code&gt;AND&lt;/code&gt; are two different, valid names. As a convention, programs should avoid creating names that start with an underscore followed by one or more uppercase letters (such as &lt;a href=&quot;#pdf-_VERSION&quot;&gt;&lt;code&gt;_VERSION&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Lua는 대소 문자를 구분하는 언어 &lt;code&gt;and&lt;/code&gt; 예약어이지만 &lt;code&gt;And&lt;/code&gt; 와 &lt;code&gt;AND&lt;/code&gt; 는 서로 다른 유효한 이름입니다. 일반적으로 프로그램은 밑줄로 시작하고 하나 이상의 대문자 (예 : &lt;a href=&quot;#pdf-_VERSION&quot;&gt; &lt;code&gt;_VERSION&lt;/code&gt; &lt;/a&gt; ) 로 이름을 작성하지 않아야합니다 .</target>
        </trans-unit>
        <trans-unit id="14462b481cdd16dd35942cf7ea65c476fc81dc92" translate="yes" xml:space="preserve">
          <source>Lua is a dynamically typed language. This means that variables do not have types; only values do. There are no type definitions in the language. All values carry their own type.</source>
          <target state="translated">Lua는 동적으로 입력되는 언어입니다. 이것은 변수에 유형이 없음을 의미합니다. 값만합니다. 언어에 유형 정의가 없습니다. 모든 값에는 고유 한 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5747aeb4d5eff65fa7549c62e63b2802c05d28fa" translate="yes" xml:space="preserve">
          <source>Lua is a free-form language. It ignores spaces (including new lines) and comments between lexical elements (tokens), except as delimiters between names and keywords.</source>
          <target state="translated">루아는 자유 형식의 언어입니다. 이름과 키워드 사이의 구분 기호를 제외하고 공백 (새 줄 포함)과 어휘 요소 (토큰) 사이의 주석은 무시합니다.</target>
        </trans-unit>
        <trans-unit id="d6fc1e0827574e83666a7aeb884cd5cd48ccb329" translate="yes" xml:space="preserve">
          <source>Lua is a free-form language. It ignores spaces and comments between lexical elements (tokens), except as delimiters between two tokens. In source code, Lua recognizes as spaces the standard ASCII whitespace characters space, form feed, newline, carriage return, horizontal tab, and vertical tab.</source>
          <target state="translated">Lua는 자유 형식 언어입니다. 두 토큰 사이의 구분자를 제외하고 어휘 요소 (토큰) 사이의 공백과 주석을 무시합니다. 소스 코드에서 Lua는 표준 ASCII 공백 문자 공간, 양식 공급, 줄 바꿈, 캐리지 리턴, 가로 탭 및 세로 탭을 공백으로 인식합니다.</target>
        </trans-unit>
        <trans-unit id="10cf3931978ad3da8f2a0c2e42a3bc57db1befcb" translate="yes" xml:space="preserve">
          <source>Lua is a lexically scoped language. The scope of a local variable begins at the first statement after its declaration and lasts until the last non-void statement of the innermost block that includes the declaration. Consider the following example:</source>
          <target state="translated">루아는 어휘 범위 언어입니다. 지역 변수의 범위는 선언 후 첫 번째 명령문에서 시작하여 선언을 포함하는 가장 안쪽 블록의 무효가 아닌 마지막 명령문까지 지속됩니다. 다음 예제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="64997c71b569a923ad45e14df6ef4a0a98b01aef" translate="yes" xml:space="preserve">
          <source>Lua is a powerful, efficient, lightweight, embeddable scripting language. It supports procedural programming, object-oriented programming, functional programming, data-driven programming, and data description.</source>
          <target state="translated">Lua는 강력하고 효율적이며 가볍고 내장 가능한 스크립팅 언어입니다. 절차 적 프로그래밍, 객체 지향 프로그래밍, 기능적 프로그래밍, 데이터 기반 프로그래밍 및 데이터 설명을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="6525b86788861e011c88cf07f7294dd56f02830d" translate="yes" xml:space="preserve">
          <source>Lua is free software, and is provided as usual with no guarantees, as stated in its license. The implementation described in this manual is available at Lua's official web site, &lt;code&gt;www.lua.org&lt;/code&gt;.</source>
          <target state="translated">Lua는 무료 소프트웨어이며 라이센스에 명시된 바와 같이 보증없이 평소와 같이 제공됩니다. 이 매뉴얼에 설명 된 구현은 Lua의 공식 웹 사이트 &lt;code&gt;www.lua.org&lt;/code&gt; 에서 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bf89f8ce15263309be1a18939b1bc8b312081d0b" translate="yes" xml:space="preserve">
          <source>Lua is implemented as a library, written in &lt;em&gt;clean C&lt;/em&gt;, the common subset of Standard C and C++. The Lua distribution includes a host program called &lt;code&gt;lua&lt;/code&gt;, which uses the Lua library to offer a complete, standalone Lua interpreter, for interactive or batch use. Lua is intended to be used both as a powerful, lightweight, embeddable scripting language for any program that needs one, and as a powerful but lightweight and efficient stand-alone language.</source>
          <target state="translated">Lua는 표준 C 및 C ++의 공통 부분 집합 인 &lt;em&gt;clean C로&lt;/em&gt; 작성된 라이브러리로 구현됩니다 . Lua 배포판에는 &lt;code&gt;lua&lt;/code&gt; 라는 호스트 프로그램이 포함되어 있습니다.이 프로그램 은 Lua 라이브러리를 사용하여 대화식 또는 배치 용으로 완전한 독립형 Lua 인터프리터를 제공합니다. Lua는 필요한 프로그램을위한 강력하고 가벼우 며 내장 가능한 스크립트 언어와 강력하지만 가볍고 효율적인 독립형 언어로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d706bcd1ff8f8bec50ed4b63b5fce0e2915787d3" translate="yes" xml:space="preserve">
          <source>Lua keeps a distinguished environment called the &lt;em&gt;global environment&lt;/em&gt;. This value is kept at a special index in the C registry (see &lt;a href=&quot;#4.3&quot;&gt;&amp;sect;4.3&lt;/a&gt;). In Lua, the global variable &lt;a href=&quot;#pdf-_G&quot;&gt;&lt;code&gt;_G&lt;/code&gt;&lt;/a&gt; is initialized with this same value. (&lt;a href=&quot;#pdf-_G&quot;&gt;&lt;code&gt;_G&lt;/code&gt;&lt;/a&gt; is never used internally, so changing its value will affect only your own code.)</source>
          <target state="translated">Lua는 &lt;em&gt;글로벌 환경&lt;/em&gt; 이라는 차별화 된 환경을 유지 &lt;em&gt;합니다&lt;/em&gt; . 이 값은 C 레지스트리의 특수 색인에 보관됩니다 ( &lt;a href=&quot;#4.3&quot;&gt;&amp;sect;4.3&lt;/a&gt; 참조 ). Lua에서 전역 변수 &lt;a href=&quot;#pdf-_G&quot;&gt; &lt;code&gt;_G&lt;/code&gt; &lt;/a&gt; 는 동일한 값으로 초기화됩니다. ( &lt;a href=&quot;#pdf-_G&quot;&gt; &lt;code&gt;_G&lt;/code&gt; &lt;/a&gt; 는 내부적으로 사용되지 않으므로 값을 변경하면 자신의 코드에만 영향을줍니다.)</target>
        </trans-unit>
        <trans-unit id="766bf2f3607b0c894574e1db0930518cd452197d" translate="yes" xml:space="preserve">
          <source>Lua keeps a distinguished environment called the &lt;em&gt;global environment&lt;/em&gt;. This value is kept at a special index in the C registry (see &lt;a href=&quot;#4.5&quot;&gt;&amp;sect;4.5&lt;/a&gt;). In Lua, the global variable &lt;a href=&quot;#pdf-_G&quot;&gt;&lt;code&gt;_G&lt;/code&gt;&lt;/a&gt; is initialized with this same value. (&lt;a href=&quot;#pdf-_G&quot;&gt;&lt;code&gt;_G&lt;/code&gt;&lt;/a&gt; is never used internally.)</source>
          <target state="translated">Lua는 &lt;em&gt;글로벌 환경&lt;/em&gt; 이라는 고유 한 환경을 유지 &lt;em&gt;합니다&lt;/em&gt; . 이 값은 C 레지스트리의 특수 색인에 유지됩니다 ( &lt;a href=&quot;#4.5&quot;&gt;&amp;sect;4.5&lt;/a&gt; 참조 ). Lua에서 전역 변수 &lt;a href=&quot;#pdf-_G&quot;&gt; &lt;code&gt;_G&lt;/code&gt; &lt;/a&gt; 는 이와 동일한 값으로 초기화됩니다. ( &lt;a href=&quot;#pdf-_G&quot;&gt; &lt;code&gt;_G&lt;/code&gt; &lt;/a&gt; 는 내부적으로 사용되지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="50a6344d2469ab6de8e8a3709a57a990d508f2b9" translate="yes" xml:space="preserve">
          <source>Lua performs automatic memory management. This means that you do not have to worry about allocating memory for new objects or freeing it when the objects are no longer needed. Lua manages memory automatically by running a &lt;em&gt;garbage collector&lt;/em&gt; to collect all &lt;em&gt;dead objects&lt;/em&gt; (that is, objects that are no longer accessible from Lua). All memory used by Lua is subject to automatic management: strings, tables, userdata, functions, threads, internal structures, etc.</source>
          <target state="translated">Lua는 자동 메모리 관리를 수행합니다. 즉, 새 객체에 메모리를 할당하거나 객체가 더 이상 필요하지 않을 때 메모리를 해제 할 필요가 없습니다. Lua는 &lt;em&gt;가비지 수집기&lt;/em&gt; 를 실행하여 모든 &lt;em&gt;죽은 개체&lt;/em&gt; (즉, Lua에서 더 이상 액세스 할 수없는 개체) 를 수집 하여 메모리를 자동으로 관리합니다 . Lua가 사용하는 모든 메모리는 문자열, 테이블, 사용자 데이터, 함수, 스레드, 내부 구조 등 자동 관리 대상이됩니다.</target>
        </trans-unit>
        <trans-unit id="a37183d7def474e8ad0a40034770f88144395901" translate="yes" xml:space="preserve">
          <source>Lua performs automatic memory management. This means that you do not have to worry about allocating memory for new objects or freeing it when the objects are no longer needed. Lua manages memory automatically by running a &lt;em&gt;garbage collector&lt;/em&gt; to collect all &lt;em&gt;dead&lt;/em&gt; objects. All memory used by Lua is subject to automatic management: strings, tables, userdata, functions, threads, internal structures, etc.</source>
          <target state="translated">Lua는 자동 메모리 관리를 수행합니다. 즉, 새 개체에 메모리를 할당하거나 개체가 더 이상 필요하지 않을 때 메모리를 해제하는 것에 대해 걱정할 필요가 없습니다. Lua는 모든 &lt;em&gt;죽은&lt;/em&gt; 개체 를 수집하기 위해 &lt;em&gt;가비지 수집기&lt;/em&gt; 를 실행하여 메모리를 자동으로 관리 합니다. Lua에서 사용하는 모든 메모리는 문자열, 테이블, 사용자 데이터, 함수, 스레드, 내부 구조 등 자동 관리 대상입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="304c36d43ad643a3a401b38816464fd6feff69ef" translate="yes" xml:space="preserve">
          <source>Lua provides a &lt;em&gt;registry&lt;/em&gt;, a predefined table that can be used by any C code to store whatever Lua values it needs to store. The registry table is always accessible at pseudo-index &lt;a id=&quot;pdf-LUA_REGISTRYINDEX&quot;&gt;&lt;code&gt;LUA_REGISTRYINDEX&lt;/code&gt;&lt;/a&gt;. Any C library can store data into this table, but it must take care to choose keys that are different from those used by other libraries, to avoid collisions. Typically, you should use as key a string containing your library name, or a light userdata with the address of a C object in your code, or any Lua object created by your code. As with variable names, string keys starting with an underscore followed by uppercase letters are reserved for Lua.</source>
          <target state="translated">Lua는 모든 C 코드에서 저장해야하는 Lua 값을 저장하는 데 사용할 수있는 미리 정의 된 테이블 인 &lt;em&gt;레지스트리를&lt;/em&gt; 제공합니다 . 레지스트리 테이블은 항상 의사 인덱스 &lt;a id=&quot;pdf-LUA_REGISTRYINDEX&quot;&gt; &lt;code&gt;LUA_REGISTRYINDEX&lt;/code&gt; &lt;/a&gt; 에서 액세스 할 수 있습니다 . 모든 C 라이브러리는이 테이블에 데이터를 저장할 수 있지만 충돌을 피하기 위해 다른 라이브러리에서 사용하는 것과 다른 키를 선택해야합니다. 일반적으로 라이브러리 이름이 포함 된 문자열이나 코드에서 C 객체의 주소가 포함 된 가벼운 사용자 데이터 또는 코드로 생성 된 Lua 객체를 키로 사용해야합니다. 변수 이름과 마찬가지로 밑줄로 시작하고 대문자가 뒤 따르는 문자열 키는 Lua 용으로 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff53c69b14f5a971156b01cea314fe8462f1fb40" translate="yes" xml:space="preserve">
          <source>Lua provides a &lt;em&gt;registry&lt;/em&gt;, a predefined table that can be used by any C code to store whatever Lua values it needs to store. The registry table is always located at pseudo-index &lt;a id=&quot;pdf-LUA_REGISTRYINDEX&quot;&gt;&lt;code&gt;LUA_REGISTRYINDEX&lt;/code&gt;&lt;/a&gt;. Any C library can store data into this table, but it must take care to choose keys that are different from those used by other libraries, to avoid collisions. Typically, you should use as key a string containing your library name, or a light userdata with the address of a C object in your code, or any Lua object created by your code. As with variable names, string keys starting with an underscore followed by uppercase letters are reserved for Lua.</source>
          <target state="translated">Lua는 모든 C 코드에서 저장해야하는 Lua 값을 저장하는 데 사용할 수있는 사전 정의 된 테이블 인 &lt;em&gt;registry를&lt;/em&gt; 제공합니다 . 레지스트리 테이블은 항상 의사 인덱스 &lt;a id=&quot;pdf-LUA_REGISTRYINDEX&quot;&gt; &lt;code&gt;LUA_REGISTRYINDEX&lt;/code&gt; 에&lt;/a&gt; 있습니다. 모든 C 라이브러리는이 테이블에 데이터를 저장할 수 있지만 충돌을 피하려면 다른 라이브러리에서 사용하는 것과 다른 키를 선택해야합니다. 일반적으로 라이브러리 이름이 포함 된 문자열 또는 코드에 C 객체의 주소가있는 간단한 사용자 데이터 또는 코드로 생성 된 Lua 객체를 키로 사용해야합니다. 변수 이름과 마찬가지로 밑줄로 시작하고 대문자가 오는 문자열 키는 Lua에 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7ec27426739f62c59f6fb19adc0cf4fd8e79bdf" translate="yes" xml:space="preserve">
          <source>Lua provides some automatic conversions between some types and representations at run time. Bitwise operators always convert float operands to integers. Exponentiation and float division always convert integer operands to floats. All other arithmetic operations applied to mixed numbers (integers and floats) convert the integer operand to a float. The C API also converts both integers to floats and floats to integers, as needed. Moreover, string concatenation accepts numbers as arguments, besides strings.</source>
          <target state="translated">Lua는 런타임에 일부 유형과 표현 간의 일부 자동 변환을 제공합니다. 비트 연산자는 항상 부동 피연산자를 정수로 변환합니다. 지수 및 부동 소수점 나누기는 항상 정수 피연산자를 부동 소수점으로 변환합니다. 혼합 수 (정수 및 부동 소수점)에 적용되는 다른 모든 산술 연산은 정수 피연산자를 부동 소수점으로 변환합니다. C API는 또한 필요에 따라 정수를 부동 소수점으로, 부동 소수점을 정수로 변환합니다. 또한 문자열 연결은 문자열 외에도 숫자를 인수로 허용합니다.</target>
        </trans-unit>
        <trans-unit id="8aebea72c222a51d9f5c90460286acb8ff7bd836" translate="yes" xml:space="preserve">
          <source>Lua provides some automatic conversions between some types and representations at run time. Bitwise operators always convert float operands to integers. Exponentiation and float division always convert integer operands to floats. All other arithmetic operations applied to mixed numbers (integers and floats) convert the integer operand to a float; this is called the &lt;em&gt;usual rule&lt;/em&gt;. The C API also converts both integers to floats and floats to integers, as needed. Moreover, string concatenation accepts numbers as arguments, besides strings.</source>
          <target state="translated">Lua는 런타임에 일부 유형과 표현간에 자동 변환을 제공합니다. 비트 연산자는 항상 부동 피연산자를 정수로 변환합니다. 지수와 부동 소수점 나누기는 항상 정수 피연산자를 부동 소수점으로 변환합니다. 대분수 (정수와 실수)에 적용된 다른 모든 산술 연산은 정수 피연산자를 부동 소수점으로 변환합니다. 이것을 &lt;em&gt;일반적인 규칙&lt;/em&gt; 이라고합니다 . C API는 필요에 따라 두 정수를 부동 소수점으로 변환하고 부동 소수점을 정수로 변환합니다. 또한 문자열 연결은 문자열 외에도 숫자를 인수로 허용합니다.</target>
        </trans-unit>
        <trans-unit id="fc88527d32d4eef52fab883602cc5a04e027d076" translate="yes" xml:space="preserve">
          <source>Lua supports an almost conventional set of statements, similar to those in Pascal or C. This set includes assignments, control structures, function calls, and variable declarations.</source>
          <target state="translated">Lua는 Pascal 또는 C의 문장과 유사한 거의 일반적인 문장 세트를 지원합니다.이 세트에는 할당, 제어 구조, 함수 호출 및 변수 선언이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="91dafa2daf60652dca7a18b91e3e12584dce5ecb" translate="yes" xml:space="preserve">
          <source>Lua supports an almost conventional set of statements, similar to those in other conventional languages. This set includes blocks, assignments, control structures, function calls, and variable declarations.</source>
          <target state="translated">Lua는 다른 일반적인 언어와 유사한 거의 일반적인 문 집합을 지원합니다. 이 세트에는 블록, 할당, 제어 구조, 함수 호출 및 변수 선언이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d24c360e7097470e8a9eb4284ea5f5a81791560b" translate="yes" xml:space="preserve">
          <source>Lua supports coroutines, also called &lt;em&gt;collaborative multithreading&lt;/em&gt;. A coroutine in Lua represents an independent thread of execution. Unlike threads in multithread systems, however, a coroutine only suspends its execution by explicitly calling a yield function.</source>
          <target state="translated">Lua는 &lt;em&gt;협업 멀티 스레딩&lt;/em&gt; 이라고도하는 코 루틴을 지원합니다 . 루아의 코 루틴은 독립적 인 실행 스레드를 나타냅니다. 그러나 멀티 스레드 시스템의 스레드와 달리 코 루틴은 yield 함수를 명시 적으로 호출하여 실행을 일시 중단합니다.</target>
        </trans-unit>
        <trans-unit id="3591c85e3de8f7bdc4a45d500a8261a9e6ec09be" translate="yes" xml:space="preserve">
          <source>Lua supports the following arithmetic operators:</source>
          <target state="translated">Lua는 다음과 같은 산술 연산자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="f0e5bf2dcec5e267f3660839f8aee19d34a65569" translate="yes" xml:space="preserve">
          <source>Lua supports the following bitwise operators:</source>
          <target state="translated">Lua는 다음과 같은 비트 연산자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="681beb7c86ad47856fd70c3b7329189c44c67f13" translate="yes" xml:space="preserve">
          <source>Lua supports the following relational operators:</source>
          <target state="translated">Lua는 다음 관계 연산자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="ea7647f42e558dda5334904038fac1e7ced0aeee" translate="yes" xml:space="preserve">
          <source>Lua treats the continuation function as if it were the original function. The continuation function receives the same Lua stack from the original function, in the same state it would be if the callee function had returned. (For instance, after a &lt;a href=&quot;#lua_callk&quot;&gt;&lt;code&gt;lua_callk&lt;/code&gt;&lt;/a&gt; the function and its arguments are removed from the stack and replaced by the results from the call.) It also has the same upvalues. Whatever it returns is handled by Lua as if it were the return of the original function.</source>
          <target state="translated">Lua는 연속 함수를 원래 함수 인 것처럼 취급합니다. 연속 함수는 원래 함수에서 동일한 Lua 스택을 수신합니다. 동일한 상태에서 수신자 함수가 반환 된 것과 같습니다. (예를 들어, &lt;a href=&quot;#lua_callk&quot;&gt; &lt;code&gt;lua_callk&lt;/code&gt; &lt;/a&gt; 이후에 함수와 해당 인수는 스택에서 제거되고 호출 결과로 대체됩니다.) 또한 동일한 상한값을 갖습니다. 그것이 반환하는 것은 원래 함수의 반환 인 것처럼 Lua에 의해 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="8d18554a7115d65153a0cecb32181cd5cd13b803" translate="yes" xml:space="preserve">
          <source>Lua uses a &lt;em&gt;virtual stack&lt;/em&gt; to pass values to and from C. Each element in this stack represents a Lua value (&lt;b&gt;nil&lt;/b&gt;, number, string, etc.). Functions in the API can access this stack through the Lua state parameter that they receive.</source>
          <target state="translated">Lua는 &lt;em&gt;가상 스택&lt;/em&gt; 을 사용하여 C와의 값을 전달합니다.이 스택의 각 요소는 Lua 값 ( &lt;b&gt;nil&lt;/b&gt; , 숫자, 문자열 등)을 나타냅니다. API의 함수는 수신 한 Lua 상태 매개 변수를 통해이 스택에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ab5b312f28e26ecbcf6e086d97bd76369eeeb34" translate="yes" xml:space="preserve">
          <source>Lua versions can always change the C API in ways that do not imply source-code changes in a program, such as the numeric values for constants or the implementation of functions as macros. Therefore, you should never assume that binaries are compatible between different Lua versions. Always recompile clients of the Lua API when using a new version.</source>
          <target state="translated">Lua 버전은 상수에 대한 숫자 값 또는 매크로로 함수 구현과 같이 프로그램의 소스 코드 변경을 암시하지 않는 방식으로 항상 C API를 변경할 수 있습니다. 따라서 바이너리가 서로 다른 Lua 버전간에 호환된다고 가정해서는 안됩니다. 새 버전을 사용할 때는 항상 Lua API의 클라이언트를 다시 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="225017af8d199117d297936391565191b16afd75" translate="yes" xml:space="preserve">
          <source>Lua versions can always change the C API in ways that do not imply source-code changes in a program, such as the numeric values for constants or the implementation of functions as macros. Therefore, you should not assume that binaries are compatible between different Lua versions. Always recompile clients of the Lua API when using a new version.</source>
          <target state="translated">Lua 버전은 상수의 숫자 값이나 매크로의 함수 구현과 같이 프로그램에서 소스 코드 변경을 암시하지 않는 방식으로 항상 C API를 변경할 수 있습니다. 따라서 바이너리가 다른 Lua 버전간에 호환된다고 가정해서는 안됩니다. 새 버전을 사용할 때는 항상 Lua API의 클라이언트를 다시 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="d9819702e70f7dce9f1483706cfae2f70bcb9e32" translate="yes" xml:space="preserve">
          <source>Macros to project non-default integer types (&lt;code&gt;luaL_checkint&lt;/code&gt;, &lt;code&gt;luaL_optint&lt;/code&gt;, &lt;code&gt;luaL_checklong&lt;/code&gt;, &lt;code&gt;luaL_optlong&lt;/code&gt;) were deprecated. Use their equivalent over &lt;a href=&quot;#lua_Integer&quot;&gt;&lt;code&gt;lua_Integer&lt;/code&gt;&lt;/a&gt; with a type cast (or, when possible, use &lt;a href=&quot;#lua_Integer&quot;&gt;&lt;code&gt;lua_Integer&lt;/code&gt;&lt;/a&gt; in your code).</source>
          <target state="translated">기본이 아닌 정수 유형 ( &lt;code&gt;luaL_checkint&lt;/code&gt; , &lt;code&gt;luaL_optint&lt;/code&gt; , &lt;code&gt;luaL_checklong&lt;/code&gt; , &lt;code&gt;luaL_optlong&lt;/code&gt; ) 을 투사하는 매크로 는 더 이상 사용되지 않습니다. 유형 캐스트와 함께 &lt;a href=&quot;#lua_Integer&quot;&gt; &lt;code&gt;lua_Integer&lt;/code&gt; &lt;/a&gt; 와 동등한 것을 사용하십시오 (또는 가능하면 코드에서 &lt;a href=&quot;#lua_Integer&quot;&gt; &lt;code&gt;lua_Integer&lt;/code&gt; &lt;/a&gt; 를 사용 하십시오).</target>
        </trans-unit>
        <trans-unit id="b77ee37c1b7bd6807618cb75d302c1c6fbf5df15" translate="yes" xml:space="preserve">
          <source>Make the &lt;code&gt;n1&lt;/code&gt;-th upvalue of the Lua closure &lt;code&gt;f1&lt;/code&gt; refer to the &lt;code&gt;n2&lt;/code&gt;-th upvalue of the Lua closure &lt;code&gt;f2&lt;/code&gt;.</source>
          <target state="translated">만들기 기능 &lt;code&gt;n1&lt;/code&gt; 번째 upvalue 루아 폐쇄의 &lt;code&gt;f1&lt;/code&gt; 받는 참조 &lt;code&gt;n2&lt;/code&gt; 번째 upvalue 루아 폐색의 &lt;code&gt;f2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="62787e3133e3f8c1540f23ea948a696e338e2fa1" translate="yes" xml:space="preserve">
          <source>Make the &lt;code&gt;n1&lt;/code&gt;-th upvalue of the Lua closure at index &lt;code&gt;funcindex1&lt;/code&gt; refer to the &lt;code&gt;n2&lt;/code&gt;-th upvalue of the Lua closure at index &lt;code&gt;funcindex2&lt;/code&gt;.</source>
          <target state="translated">만들기 기능 &lt;code&gt;n1&lt;/code&gt; 번째 upvalue 인덱스에있는 루아 폐쇄 &lt;code&gt;funcindex1&lt;/code&gt; 을 참고하여주십시오 &lt;code&gt;n2&lt;/code&gt; 인덱스에 번째 upvalue 루아 폐쇄 &lt;code&gt;funcindex2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f45634619c3458c08eba16dfa423d4f5456e189b" translate="yes" xml:space="preserve">
          <source>Marks the given index in the stack as a to-be-closed &quot;variable&quot; (see &lt;a href=&quot;#3.3.8&quot;&gt;&amp;sect;3.3.8&lt;/a&gt;). Like a to-be-closed variable in Lua, the value at that index in the stack will be closed when it goes out of scope. Here, in the context of a C function, to go out of scope means that the running function returns to Lua, there is an error, or the index is removed from the stack through &lt;a href=&quot;#lua_settop&quot;&gt;&lt;code&gt;lua_settop&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#lua_pop&quot;&gt;&lt;code&gt;lua_pop&lt;/code&gt;&lt;/a&gt;. An index marked as to-be-closed should not be removed from the stack by any other function in the API except &lt;a href=&quot;#lua_settop&quot;&gt;&lt;code&gt;lua_settop&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#lua_pop&quot;&gt;&lt;code&gt;lua_pop&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">스택의 지정된 인덱스를 닫을 &quot;변수&quot;로 표시합니다 ( &lt;a href=&quot;#3.3.8&quot;&gt;&amp;sect;3.3.8&lt;/a&gt; 참조 ). Lua에서 닫힐 예정인 변수와 마찬가지로 스택의 해당 인덱스에있는 값은 범위를 벗어날 때 닫힙니다. 여기서 C 함수의 컨텍스트에서 범위를 벗어난다는 것은 실행중인 함수가 Lua로 반환되거나 오류가 있거나 &lt;a href=&quot;#lua_settop&quot;&gt; &lt;code&gt;lua_settop&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#lua_pop&quot;&gt; &lt;code&gt;lua_pop&lt;/code&gt; 을&lt;/a&gt; 통해 스택에서 인덱스가 제거됨을 의미합니다 . 닫힐 것으로 표시된 인덱스는 &lt;a href=&quot;#lua_settop&quot;&gt; &lt;code&gt;lua_settop&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#lua_pop&quot;&gt; &lt;code&gt;lua_pop&lt;/code&gt; 을&lt;/a&gt; 제외한 API의 다른 함수에 의해 스택에서 제거되어서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="e0580c95da4f3ceb84abf5c18ee164021809ea4c" translate="yes" xml:space="preserve">
          <source>Metatables and Metamethods</source>
          <target state="translated">메타 테이블 및 메타 메소드</target>
        </trans-unit>
        <trans-unit id="4feff686bfbdf59cf154d1294db67c187b9f7489" translate="yes" xml:space="preserve">
          <source>Modulo is defined as the remainder of a division that rounds the quotient towards minus infinity (floor division).</source>
          <target state="translated">모듈로는 몫을 마이너스 무한대로 반올림하는 나눗셈의 나머지로 정의됩니다 (플로어 나누기).</target>
        </trans-unit>
        <trans-unit id="71e2b3ce8af16f1677267e51894cb5b57ee61429" translate="yes" xml:space="preserve">
          <source>Moreover, with a &lt;code&gt;count&lt;/code&gt; different from zero, the hook is called also after every &lt;code&gt;count&lt;/code&gt; instructions.</source>
          <target state="translated">또한, &lt;code&gt;count&lt;/code&gt; 가 0과 다른 경우, 모든 &lt;code&gt;count&lt;/code&gt; 명령 후에 후크가 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="68a5432576b0a8367df52ec04ef603f754149162" translate="yes" xml:space="preserve">
          <source>Most functions in the API can raise an error, for instance due to a memory allocation error. The documentation for each function indicates whether it can raise errors.</source>
          <target state="translated">예를 들어 메모리 할당 오류로 인해 API의 대부분의 함수에서 오류가 발생할 수 있습니다. 각 기능에 대한 설명서는 오류를 일으킬 수 있는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="211349efeacad71bfc6580d063e630f7c7ac8b51" translate="yes" xml:space="preserve">
          <source>Moves elements from table &lt;code&gt;a1&lt;/code&gt; to table &lt;code&gt;a2&lt;/code&gt;, performing the equivalent to the following multiple assignment: &lt;code&gt;a2[t],&amp;middot;&amp;middot;&amp;middot; = a1[f],&amp;middot;&amp;middot;&amp;middot;,a1[e]&lt;/code&gt;. The default for &lt;code&gt;a2&lt;/code&gt; is &lt;code&gt;a1&lt;/code&gt;. The destination range can overlap with the source range. The number of elements to be moved must fit in a Lua integer.</source>
          <target state="translated">&lt;code&gt;a2[t],&amp;middot;&amp;middot;&amp;middot; = a1[f],&amp;middot;&amp;middot;&amp;middot;,a1[e]&lt;/code&gt; 와 같이 다중 할당을 수행하여 테이블 &lt;code&gt;a1&lt;/code&gt; 에서 테이블 &lt;code&gt;a2&lt;/code&gt; 로 요소를 이동합니다 . &lt;code&gt;a2&lt;/code&gt; 의 기본값 은 &lt;code&gt;a1&lt;/code&gt; 입니다. 대상 범위가 소스 범위와 겹칠 수 있습니다. 이동할 요소의 수는 Lua 정수에 맞아야합니다.</target>
        </trans-unit>
        <trans-unit id="510e5879338c47950130f12189e321dcf4ce36c2" translate="yes" xml:space="preserve">
          <source>Moves elements from the table &lt;code&gt;a1&lt;/code&gt; to the table &lt;code&gt;a2&lt;/code&gt;, performing the equivalent to the following multiple assignment: &lt;code&gt;a2[t],&amp;middot;&amp;middot;&amp;middot; = a1[f],&amp;middot;&amp;middot;&amp;middot;,a1[e]&lt;/code&gt;. The default for &lt;code&gt;a2&lt;/code&gt; is &lt;code&gt;a1&lt;/code&gt;. The destination range can overlap with the source range. The number of elements to be moved must fit in a Lua integer.</source>
          <target state="translated">테이블에서 이동 소자 &lt;code&gt;a1&lt;/code&gt; 테이블에 &lt;code&gt;a2&lt;/code&gt; 다음 다중 할당에 상응 수행 : &lt;code&gt;a2[t],&amp;middot;&amp;middot;&amp;middot; = a1[f],&amp;middot;&amp;middot;&amp;middot;,a1[e]&lt;/code&gt; . &lt;code&gt;a2&lt;/code&gt; 의 기본값 은 &lt;code&gt;a1&lt;/code&gt; 입니다. 대상 범위는 원본 범위와 겹칠 수 있습니다. 이동할 요소의 수는 Lua 정수에 맞아야합니다.</target>
        </trans-unit>
        <trans-unit id="7f2bdd0bd3d59fce772f98ee9eb7eb0b3b6d4a93" translate="yes" xml:space="preserve">
          <source>Moves the top element into the given valid index without shifting any element (therefore replacing the value at that given index), and then pops the top element.</source>
          <target state="translated">요소를 이동하지 않고 (따라서 주어진 색인의 값을 바꾸지 않고) 상단 요소를 지정된 유효한 색인으로 이동 한 다음 상단 요소를 팝합니다.</target>
        </trans-unit>
        <trans-unit id="4e0c82df95dd4d912151141c645e29919783b9cd" translate="yes" xml:space="preserve">
          <source>Moves the top element into the given valid index, shifting up the elements above this index to open space. This function cannot be called with a pseudo-index, because a pseudo-index is not an actual stack position.</source>
          <target state="translated">맨 위 요소를 주어진 유효한 인덱스로 이동하고이 인덱스 위의 요소를 열어 공간을 확보하십시오. 의사 인덱스는 실제 스택 위치가 아니기 때문에 의사 인덱스로이 함수를 호출 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="391a0967919882d8d7da074ecd835868b9ad0813" translate="yes" xml:space="preserve">
          <source>Multiple matches:</source>
          <target state="translated">여러 경기 :</target>
        </trans-unit>
        <trans-unit id="f3ebf3f60d00dc82250b0b628b803e44dd494422" translate="yes" xml:space="preserve">
          <source>Name denotes identifiers (see &lt;a href=&quot;#3.1&quot;&gt;&amp;sect;3.1&lt;/a&gt;).</source>
          <target state="translated">이름은 식별자를 나타냅니다 ( &lt;a href=&quot;#3.1&quot;&gt;&amp;sect;3.1&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="53b225abd3f0033a18a8e56044eee89e7ebbd191" translate="yes" xml:space="preserve">
          <source>Name denotes identifiers, as defined in &lt;a href=&quot;#3.1&quot;&gt;&amp;sect;3.1&lt;/a&gt;.</source>
          <target state="translated">이름은 &lt;a href=&quot;#3.1&quot;&gt;&amp;sect;3.1에&lt;/a&gt; 정의 된 식별자를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="132dfdc791b8ee51cdbc214b5f4f4d7ac599cf90" translate="yes" xml:space="preserve">
          <source>Native endianness assumes that the whole system is either big or little endian. The packing functions will not emulate correctly the behavior of mixed-endian formats.</source>
          <target state="translated">네이티브 엔디안은 전체 시스템이 빅 엔디안이거나 리틀 엔디안이라고 가정합니다. 패킹 함수는 혼합 엔디안 형식의 동작을 올바르게 에뮬레이트하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0ff07f80cb3da5ffaa1ac22e6dac9b937f6ab24f" translate="yes" xml:space="preserve">
          <source>Nonetheless, it is always a good practice not to rely on these implicit coercions, as they are not always applied; in particular, &lt;code&gt;&quot;1&quot;==1&lt;/code&gt; is false and &lt;code&gt;&quot;1&quot;&amp;lt;1&lt;/code&gt; raises an error (see &lt;a href=&quot;#3.4.4&quot;&gt;&amp;sect;3.4.4&lt;/a&gt;). These coercions exist mainly for compatibility and may be removed in future versions of the language.</source>
          <target state="translated">그럼에도 불구하고 항상 적용되는 것은 아니므로 이러한 암시 적 강제에 의존하지 않는 것이 항상 좋은 습관입니다. 특히 &lt;code&gt;&quot;1&quot;==1&lt;/code&gt; 은 거짓이고 &lt;code&gt;&quot;1&quot;&amp;lt;1&lt;/code&gt; 은 오류를 발생시킵니다 ( &lt;a href=&quot;#3.4.4&quot;&gt;&amp;sect;3.4.4&lt;/a&gt; 참조 ). 이러한 강제는 주로 호환성을 위해 존재하며 향후 버전의 언어에서 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14931c9658b2e9143b168a9666b173cd80e49603" translate="yes" xml:space="preserve">
          <source>Note that Standard C ensures that &lt;code&gt;free(NULL)&lt;/code&gt; has no effect and that &lt;code&gt;realloc(NULL,size)&lt;/code&gt; is equivalent to &lt;code&gt;malloc(size)&lt;/code&gt;.</source>
          <target state="translated">표준 C는 &lt;code&gt;free(NULL)&lt;/code&gt; 이 효과가 없으며 &lt;code&gt;realloc(NULL,size)&lt;/code&gt; 가 &lt;code&gt;malloc(size)&lt;/code&gt; 와 동일하다는 것을 확인 합니다.</target>
        </trans-unit>
        <trans-unit id="1fb92775055c34d37036245800bd4e66793f8802" translate="yes" xml:space="preserve">
          <source>Note that Standard C ensures that &lt;code&gt;free(NULL)&lt;/code&gt; has no effect and that &lt;code&gt;realloc(NULL,size)&lt;/code&gt; is equivalent to &lt;code&gt;malloc(size)&lt;/code&gt;. This code assumes that &lt;code&gt;realloc&lt;/code&gt; does not fail when shrinking a block. (Although Standard C does not ensure this behavior, it seems to be a safe assumption.)</source>
          <target state="translated">표준 C는 &lt;code&gt;free(NULL)&lt;/code&gt; 가 영향을 미치지 않으며 &lt;code&gt;realloc(NULL,size)&lt;/code&gt; 가 &lt;code&gt;malloc(size)&lt;/code&gt; 와 동일 하다는 것을 보장합니다 . 이 코드는 블록을 축소 할 때 &lt;code&gt;realloc&lt;/code&gt; 이 실패하지 않는다고 가정합니다 . 표준 C가이 동작을 보장하지는 않지만 안전한 가정 인 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="7a567518fb3007e639daf24d7ac35ede7aba1d84" translate="yes" xml:space="preserve">
          <source>Note that commands for &lt;code&gt;debug.debug&lt;/code&gt; are not lexically nested within any function and so have no direct access to local variables.</source>
          <target state="translated">&lt;code&gt;debug.debug&lt;/code&gt; 에 대한 명령은 함수 내에 사 전적으로 중첩되지 않으므로 로컬 변수에 직접 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a3819f26854d326b0f73d55f7e4a2133dc45716a" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;comp&lt;/code&gt; function must define a strict partial order over the elements in the list; that is, it must be asymmetric and transitive. Otherwise, no valid sort may be possible.</source>
          <target state="translated">점을 유의 &lt;code&gt;comp&lt;/code&gt; 기능리스트 내의 요소 부분 엄격한 순서를 정의한다; 즉, 비대칭적이고 전 이적이어야합니다. 그렇지 않으면 유효한 정렬이 불가능할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1dab5c0bc6e3b7d33e45552977787711c9e9cd82" translate="yes" xml:space="preserve">
          <source>Note that the code above is &lt;em&gt;balanced&lt;/em&gt;: at its end, the stack is back to its original configuration. This is considered good programming practice.</source>
          <target state="translated">위의 코드는 &lt;em&gt;균형&lt;/em&gt; 이 &lt;em&gt;잡혀 있습니다&lt;/em&gt; . 마지막에 스택은 원래 구성으로 돌아갑니다. 이것은 좋은 프로그래밍 관행으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="27456ef634a2ef274b5d4e632f792b2f499755a1" translate="yes" xml:space="preserve">
          <source>Note that, both in case of errors and of a regular return, by the time the &lt;code&gt;__close&lt;/code&gt; metamethod runs, the C stack was already unwound, so that any automatic C variable declared in the calling function will be out of scope.</source>
          <target state="translated">오류가 발생하거나 정기적으로 반환되는 경우 모두 &lt;code&gt;__close&lt;/code&gt; 메타 메서드가 실행될 때 C 스택이 이미 풀렸 으므로 호출 함수에서 선언 된 자동 C 변수가 범위를 벗어납니다.</target>
        </trans-unit>
        <trans-unit id="f095d9ef1108e5d2ebeb20830f7a9cdf31641d73" translate="yes" xml:space="preserve">
          <source>Note the external, explicit call to the continuation: Lua will call the continuation only if needed, that is, in case of errors or resuming after a yield. If the called function returns normally without ever yielding, &lt;a href=&quot;#lua_pcallk&quot;&gt;&lt;code&gt;lua_pcallk&lt;/code&gt;&lt;/a&gt; (and &lt;a href=&quot;#lua_callk&quot;&gt;&lt;code&gt;lua_callk&lt;/code&gt;&lt;/a&gt;) will also return normally. (Of course, instead of calling the continuation in that case, you can do the equivalent work directly inside the original function.)</source>
          <target state="translated">연속에 대한 외부의 명시 적 호출에 주목하십시오. Lua는 필요한 경우, 즉 오류가 있거나 수율 후에 다시 시작하는 경우에만 연속을 호출합니다. 호출 된 함수가 양보하지 않고 정상적으로 반환되면 &lt;a href=&quot;#lua_pcallk&quot;&gt; &lt;code&gt;lua_pcallk&lt;/code&gt; &lt;/a&gt; (및 &lt;a href=&quot;#lua_callk&quot;&gt; &lt;code&gt;lua_callk&lt;/code&gt; &lt;/a&gt; )도 정상적으로 반환됩니다. (물론,이 경우 연속을 호출하는 대신 원래 함수 내에서 직접 동일한 작업을 수행 할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="20d78a8e421517dfc8501178399cb2a435e63306" translate="yes" xml:space="preserve">
          <source>Note the following:</source>
          <target state="translated">다음에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="143069908049a001ca51a83cef0a8d3fcbe11397" translate="yes" xml:space="preserve">
          <source>Notice that each execution of a &lt;b&gt;local&lt;/b&gt; statement defines new local variables. Consider the following example:</source>
          <target state="translated">&lt;b&gt;로컬&lt;/b&gt; 명령문을 실행할 때마다 새 로컬 변수가 정의됩니다. 다음 예제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="fcc164423a09d2953e5486a056f1e10293de0711" translate="yes" xml:space="preserve">
          <source>Notice that, in a declaration like &lt;code&gt;local x = x&lt;/code&gt;, the new &lt;code&gt;x&lt;/code&gt; being declared is not in scope yet, and so the second &lt;code&gt;x&lt;/code&gt; refers to the outside variable.</source>
          <target state="translated">&lt;code&gt;local x = x&lt;/code&gt; 와 같은 선언에서 선언 되는 새로운 &lt;code&gt;x&lt;/code&gt; 는 아직 범위 내에 있지 않으므로 두 번째 &lt;code&gt;x&lt;/code&gt; 는 외부 변수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d213f09117ec25cd2306bbea812a90e0c2b8aabb" translate="yes" xml:space="preserve">
          <source>Now we want to allow the Lua code being run by &lt;a href=&quot;#lua_pcall&quot;&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt; to yield. First, we can rewrite our function like here:</source>
          <target state="translated">이제 &lt;a href=&quot;#lua_pcall&quot;&gt; &lt;code&gt;lua_pcall&lt;/code&gt; &lt;/a&gt; 로 Lua 코드가 실행되도록하고 싶습니다 . 먼저 다음과 같이 함수를 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="754d929d0f6f3e09a813d3e11d5cb6448eada594" translate="yes" xml:space="preserve">
          <source>Numerals and literal strings are explained in &lt;a href=&quot;#3.1&quot;&gt;&amp;sect;3.1&lt;/a&gt;; variables are explained in &lt;a href=&quot;#3.2&quot;&gt;&amp;sect;3.2&lt;/a&gt;; function definitions are explained in &lt;a href=&quot;#3.4.11&quot;&gt;&amp;sect;3.4.11&lt;/a&gt;; function calls are explained in &lt;a href=&quot;#3.4.10&quot;&gt;&amp;sect;3.4.10&lt;/a&gt;; table constructors are explained in &lt;a href=&quot;#3.4.9&quot;&gt;&amp;sect;3.4.9&lt;/a&gt;. Vararg expressions, denoted by three dots ('&lt;code&gt;...&lt;/code&gt;'), can only be used when directly inside a vararg function; they are explained in &lt;a href=&quot;#3.4.11&quot;&gt;&amp;sect;3.4.11&lt;/a&gt;.</source>
          <target state="translated">숫자와 리터럴 문자열은 &lt;a href=&quot;#3.1&quot;&gt;&amp;sect;3.1에&lt;/a&gt; 설명되어 있습니다 . 변수는 &lt;a href=&quot;#3.2&quot;&gt;&amp;sect;3.2&lt;/a&gt; 에 설명되어 있습니다 . 기능 정의는 &lt;a href=&quot;#3.4.11&quot;&gt;&amp;sect;3.4.11&lt;/a&gt; 에 설명되어 있습니다 . 함수 호출은 &lt;a href=&quot;#3.4.10&quot;&gt;&amp;sect;3.4.10&lt;/a&gt; 에 설명되어 있습니다 . 테이블 생성자는 &lt;a href=&quot;#3.4.9&quot;&gt;&amp;sect;3.4.9&lt;/a&gt; 에 설명되어 있습니다 . 3 개의 점 ( ' &lt;code&gt;...&lt;/code&gt; ')으로 표시되는 Vararg 표현식 은 vararg 함수 내에서 직접 사용할 때만 사용할 수 있습니다. 그것들은 &lt;a href=&quot;#3.4.11&quot;&gt;&amp;sect;3.4.11&lt;/a&gt; 에 설명되어 있다 .</target>
        </trans-unit>
        <trans-unit id="4ef3b305c58fad6f6199b8fc85c384f4f0aec1bf" translate="yes" xml:space="preserve">
          <source>Numeric codes are not necessarily portable across platforms.</source>
          <target state="translated">숫자 코드는 모든 플랫폼에서 이식 가능해야하는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="b0a0e9260ed5a6d09f75bd0cd4a96d473084f65f" translate="yes" xml:space="preserve">
          <source>Of course, the location of the Lua interpreter may be different in your machine. If &lt;code&gt;lua&lt;/code&gt; is in your &lt;code&gt;PATH&lt;/code&gt;, then</source>
          <target state="translated">물론 Lua 인터프리터의 위치는 컴퓨터에서 다를 수 있습니다. 경우 &lt;code&gt;lua&lt;/code&gt; 당신에 &lt;code&gt;PATH&lt;/code&gt; 다음,</target>
        </trans-unit>
        <trans-unit id="b1e9a773eef8de621ab2c2acf9814098928b38f7" translate="yes" xml:space="preserve">
          <source>On POSIX systems, this function also creates a file with that name, to avoid security risks. (Someone else might create the file with wrong permissions in the time between getting the name and creating the file.) You still have to open the file to use it and to remove it (even if you do not use it).</source>
          <target state="translated">POSIX 시스템에서이 기능은 보안 위험을 피하기 위해 해당 이름의 파일을 작성합니다. (누군가는 이름을 얻는 것과 파일을 만드는 사이에 잘못된 권한을 가진 파일을 만들 수 있습니다.) 파일을 사용하고 제거하려면 파일을 열어야합니다 (사용하지 않더라도).</target>
        </trans-unit>
        <trans-unit id="b4eb9b31d3cdaa19214342b44ace3c1948a9b1c8" translate="yes" xml:space="preserve">
          <source>On non-POSIX systems, this function may be not thread safe because of its reliance on C function &lt;code&gt;gmtime&lt;/code&gt; and C function &lt;code&gt;localtime&lt;/code&gt;.</source>
          <target state="translated">비 POSIX 시스템에서이 함수는 C 함수 &lt;code&gt;gmtime&lt;/code&gt; 및 C 함수 &lt;code&gt;localtime&lt;/code&gt; 에 의존하므로 스레드 안전하지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="327d9d40cc45661d18c144b659d732ccb083e105" translate="yes" xml:space="preserve">
          <source>On several platforms, you may not need to call this function, because all resources are naturally released when the host program ends. On the other hand, long-running programs that create multiple states, such as daemons or web servers, will probably need to close states as soon as they are not needed.</source>
          <target state="translated">여러 플랫폼에서는 호스트 프로그램이 종료 될 때 모든 리소스가 자연스럽게 해제되기 때문에이 함수를 호출 할 필요가 없습니다. 반면에 데몬이나 웹 서버와 같이 여러 상태를 생성하는 장기 실행 프로그램은 필요하지 않은 즉시 상태를 닫아야합니다.</target>
        </trans-unit>
        <trans-unit id="087e8ef073a71f75716b2985ce5b0a8533e700f2" translate="yes" xml:space="preserve">
          <source>Once a loader is found, &lt;code&gt;require&lt;/code&gt; calls the loader with two arguments: &lt;code&gt;modname&lt;/code&gt; and an extra value dependent on how it got the loader. (If the loader came from a file, this extra value is the file name.) If the loader returns any non-nil value, &lt;code&gt;require&lt;/code&gt; assigns the returned value to &lt;code&gt;package.loaded[modname]&lt;/code&gt;. If the loader does not return a non-nil value and has not assigned any value to &lt;code&gt;package.loaded[modname]&lt;/code&gt;, then &lt;code&gt;require&lt;/code&gt; assigns &lt;b&gt;true&lt;/b&gt; to this entry. In any case, &lt;code&gt;require&lt;/code&gt; returns the final value of &lt;code&gt;package.loaded[modname]&lt;/code&gt;.</source>
          <target state="translated">로더가 발견되면 &lt;code&gt;require&lt;/code&gt; 는 두 가지 인수로 로더를 호출합니다. &lt;code&gt;modname&lt;/code&gt; 과 로더를 얻는 방법에 따른 추가 값. 로더가 파일에서 온 경우이 추가 값은 파일 이름입니다. 로더가 0이 아닌 값을 리턴하면 리턴 값을 &lt;code&gt;package.loaded[modname]&lt;/code&gt; 지정 &lt;code&gt;require&lt;/code&gt; 합니다 . 로더가 nil이 아닌 값을 반환하지 않고 어떤 값이 할당되지 않은 경우 &lt;code&gt;package.loaded[modname]&lt;/code&gt; , 다음 &lt;code&gt;require&lt;/code&gt; 양수인 &lt;b&gt;사실&lt;/b&gt; 이 항목을. 어쨌든 &lt;code&gt;require&lt;/code&gt; 는 &lt;code&gt;package.loaded[modname]&lt;/code&gt; 의 최종 값을 반환합니다 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="cf51682813139c6b06902191dce5e737d2d9c9a1" translate="yes" xml:space="preserve">
          <source>Once a loader is found, &lt;code&gt;require&lt;/code&gt; calls the loader with two arguments: &lt;code&gt;modname&lt;/code&gt; and an extra value, a &lt;em&gt;loader data&lt;/em&gt;, also returned by the searcher. The loader data can be any value useful to the module; for the default searchers, it indicates where the loader was found. (For instance, if the loader came from a file, this extra value is the file path.) If the loader returns any non-nil value, &lt;code&gt;require&lt;/code&gt; assigns the returned value to &lt;code&gt;package.loaded[modname]&lt;/code&gt;. If the loader does not return a non-nil value and has not assigned any value to &lt;code&gt;package.loaded[modname]&lt;/code&gt;, then &lt;code&gt;require&lt;/code&gt; assigns &lt;b&gt;true&lt;/b&gt; to this entry. In any case, &lt;code&gt;require&lt;/code&gt; returns the final value of &lt;code&gt;package.loaded[modname]&lt;/code&gt;. Besides that value, &lt;code&gt;require&lt;/code&gt; also returns as a second result the loader data returned by the searcher, which indicates how &lt;code&gt;require&lt;/code&gt; found the module.</source>
          <target state="translated">로더가 발견되면 &lt;code&gt;require&lt;/code&gt; 는 두 개의 인수 ( &lt;code&gt;modname&lt;/code&gt; 및 추가 값인 &lt;em&gt;로더 데이터&lt;/em&gt; )를 사용 하여 로더를 호출합니다 . 또한 검색자가 반환합니다. 로더 데이터는 모듈에 유용한 모든 값이 될 수 있습니다. 기본 검색 자의 경우 로더가 발견 된 위치를 나타냅니다. (예를 들어, 로더가 파일에서 온 경우이 추가 값은 파일 경로입니다.) 로더가 nil이 아닌 값을 반환 하면 &lt;code&gt;require&lt;/code&gt; 는 반환 된 값을 &lt;code&gt;package.loaded[modname]&lt;/code&gt; 할당합니다 . 로더가 nil이 아닌 값을 반환하지 않고 어떤 값이 할당되지 않은 경우 &lt;code&gt;package.loaded[modname]&lt;/code&gt; , 다음 &lt;code&gt;require&lt;/code&gt; 양수인 &lt;b&gt;사실&lt;/b&gt; 이 항목을. 어쨌든, &lt;code&gt;require&lt;/code&gt; &lt;code&gt;package.loaded[modname]&lt;/code&gt; 의 최종 값을 반환합니다 . 이 값 외에도 &lt;code&gt;require&lt;/code&gt; 는 검색자가 반환 한 로더 데이터를 두 번째 결과로 반환하여 &lt;code&gt;require&lt;/code&gt; 가 모듈을 찾은 방법을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="c0f13732846387f19dd5d62a467bb6af8a9e77c4" translate="yes" xml:space="preserve">
          <source>Only objects that have an explicit construction are removed from weak tables. Values, such as numbers and light C functions, are not subject to garbage collection, and therefore are not removed from weak tables (unless their associated values are collected). Although strings are subject to garbage collection, they do not have an explicit construction and their equality is by value; they behave more like values than like objects. Therefore, they are not removed from weak tables.</source>
          <target state="translated">명시 적 구성이있는 개체 만 약한 테이블에서 제거됩니다. 숫자 및 라이트 C 함수와 같은 값은 가비지 콜렉션의 대상이 아니므로 약한 테이블에서 제거되지 않습니다 (관련 값이 수집되지 않는 한). 문자열은 가비지 수집의 대상이되지만 명시적인 구성이 없으며 동등성은 값에 따라 결정됩니다. 객체보다는 값처럼 행동합니다. 따라서 약한 테이블에서 제거되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dd79eaea9e398294fa6609bcc37919375540b811" translate="yes" xml:space="preserve">
          <source>Only objects that have an explicit construction are removed from weak tables. Values, such as numbers and light C functions, are not subject to garbage collection, and therefore are not removed from weak tables (unless their associated values are collected). Although strings are subject to garbage collection, they do not have an explicit construction, and therefore are not removed from weak tables.</source>
          <target state="translated">명시 적 구성을 가진 개체 만 약한 테이블에서 제거됩니다. 숫자 및 C 함수와 같은 값은 가비지 콜렉션의 대상이 아니므로 관련 값이 수집되지 않는 한 약한 테이블에서 제거되지 않습니다. 문자열은 가비지 수집 대상이지만 명시적인 구성이 없으므로 약한 테이블에서 제거되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b08de619674921c221a144a642faade8131401ce" translate="yes" xml:space="preserve">
          <source>Opens all standard Lua libraries into the given state.</source>
          <target state="translated">모든 표준 Lua 라이브러리를 주어진 상태로 엽니 다.</target>
        </trans-unit>
        <trans-unit id="fed8115b8cb0d575a6d2ddd5024ea0f4b7c2651d" translate="yes" xml:space="preserve">
          <source>Opens the given file name in read mode and returns an iterator function that works like &lt;code&gt;file:lines(&amp;middot;&amp;middot;&amp;middot;)&lt;/code&gt; over the opened file. When the iterator function detects the end of file, it returns no values (to finish the loop) and automatically closes the file.</source>
          <target state="translated">주어진 파일 이름을 읽기 모드로 열고 열린 파일에서 &lt;code&gt;file:lines(&amp;middot;&amp;middot;&amp;middot;)&lt;/code&gt; 처럼 작동하는 반복자 함수를 반환 합니다. 반복자 함수가 파일의 끝을 감지하면 값을 리턴하지 않고 (루프를 완료하기 위해) 파일을 자동으로 닫습니다.</target>
        </trans-unit>
        <trans-unit id="94b0d085d949942fdb3fb646a2df4ce4d0e5c72f" translate="yes" xml:space="preserve">
          <source>Opens the given file name in read mode and returns an iterator function that works like &lt;code&gt;file:lines(&amp;middot;&amp;middot;&amp;middot;)&lt;/code&gt; over the opened file. When the iterator function fails to read any value, it automatically closes the file. Besides the iterator function, &lt;code&gt;io.lines&lt;/code&gt; returns three other values: two &lt;b&gt;nil&lt;/b&gt; values as placeholders, plus the created file handle. Therefore, when used in a generic &lt;b&gt;for&lt;/b&gt; loop, the file is closed also if the loop is interrupted by an error or a &lt;b&gt;break&lt;/b&gt;.</source>
          <target state="translated">읽기 모드에서 주어진 파일 이름을 열고 열린 파일에 대해 &lt;code&gt;file:lines(&amp;middot;&amp;middot;&amp;middot;)&lt;/code&gt; 처럼 작동하는 반복기 함수를 반환 합니다. 반복자 함수가 값을 읽지 못하면 자동으로 파일을 닫습니다. 반복자 함수 외에도 &lt;code&gt;io.lines&lt;/code&gt; 는 3 개의 다른 값을 반환합니다. 두 개의 &lt;b&gt;nil&lt;/b&gt; 값을 자리 표시 자로 추가하고 생성 된 파일 핸들을 추가합니다. 따라서 일반 &lt;b&gt;for&lt;/b&gt; 루프 에서 사용 하면 루프가 오류 또는 &lt;b&gt;break로&lt;/b&gt; 인해 중단 된 경우에도 파일이 닫힙니다 .</target>
        </trans-unit>
        <trans-unit id="6c9790a0effb3e0767d24700689fb5bce0eb0f23" translate="yes" xml:space="preserve">
          <source>Opens the named file and executes its content as a Lua chunk. When called without arguments, &lt;code&gt;dofile&lt;/code&gt; executes the content of the standard input (&lt;code&gt;stdin&lt;/code&gt;). Returns all values returned by the chunk. In case of errors, &lt;code&gt;dofile&lt;/code&gt; propagates the error to its caller. (That is, &lt;code&gt;dofile&lt;/code&gt; does not run in protected mode.)</source>
          <target state="translated">명명 된 파일을 열고 내용을 Lua 청크로 실행합니다. 인수없이 호출되면 &lt;code&gt;dofile&lt;/code&gt; 은 표준 입력 ( &lt;code&gt;stdin&lt;/code&gt; ) 의 내용을 실행합니다 . 청크에서 반환 한 모든 값을 반환합니다. 오류가 &lt;code&gt;dofile&lt;/code&gt; 경우 dofile 은 오류를 호출자에게 전파합니다. (즉, &lt;code&gt;dofile&lt;/code&gt; 은 보호 모드에서 실행되지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="4996bd3a029769976e9b98ed2378b1547c48ce7d" translate="yes" xml:space="preserve">
          <source>Opens the named file and executes its contents as a Lua chunk. When called without arguments, &lt;code&gt;dofile&lt;/code&gt; executes the contents of the standard input (&lt;code&gt;stdin&lt;/code&gt;). Returns all values returned by the chunk. In case of errors, &lt;code&gt;dofile&lt;/code&gt; propagates the error to its caller (that is, &lt;code&gt;dofile&lt;/code&gt; does not run in protected mode).</source>
          <target state="translated">명명 된 파일을 열고 그 내용을 Lua 청크로 실행합니다. 인수없이 호출되면 &lt;code&gt;dofile&lt;/code&gt; 은 표준 입력 ( &lt;code&gt;stdin&lt;/code&gt; ) 의 내용을 실행합니다 . 청크가 반환 한 모든 값을 반환합니다. 오류가 발생하면 &lt;code&gt;dofile&lt;/code&gt; 은 오류를 호출자에게 전파합니다 (즉, &lt;code&gt;dofile&lt;/code&gt; 은 보호 모드에서 실행되지 않습니다).</target>
        </trans-unit>
        <trans-unit id="1b77184a8e40f826198903ec77c88ff94fba7356" translate="yes" xml:space="preserve">
          <source>Operator precedence in Lua follows the table below, from lower to higher priority:</source>
          <target state="translated">Lua의 운영자 우선 순위는 낮은 우선 순위에서 높은 우선 순위로 아래 표를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="5d68118be76331913c2ce7bb079ac0bdce1e02a7" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;s&lt;/code&gt; expects a string; if its argument is not a string, it is converted to one following the same rules of &lt;a href=&quot;#pdf-tostring&quot;&gt;&lt;code&gt;tostring&lt;/code&gt;&lt;/a&gt;. If the option has any modifier (flags, width, length), the string argument should not contain embedded zeros.</source>
          <target state="translated">옵션 &lt;code&gt;s&lt;/code&gt; 문자열을 기대; 인수가 문자열이 아닌 경우 동일한 &lt;a href=&quot;#pdf-tostring&quot;&gt; &lt;code&gt;tostring&lt;/code&gt; &lt;/a&gt; 규칙에 따라 변환됩니다 . 옵션에 수정 자 (플래그, 너비, 길이)가 있으면 문자열 인수에 포함 된 0이 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="87ca1fbe6a8feba28ed3fc6964e861a77643303f" translate="yes" xml:space="preserve">
          <source>Option names in &lt;a href=&quot;#pdf-io.read&quot;&gt;&lt;code&gt;io.read&lt;/code&gt;&lt;/a&gt; do not have a starting '&lt;code&gt;*&lt;/code&gt;' anymore. For compatibility, Lua will continue to accept (and ignore) this character.</source>
          <target state="translated">&lt;a href=&quot;#pdf-io.read&quot;&gt; &lt;code&gt;io.read&lt;/code&gt; 의&lt;/a&gt; 옵션 이름은 더 이상 시작 ' &lt;code&gt;*&lt;/code&gt; '를 갖지 않습니다. 호환성을 위해 Lua는이 문자를 계속 받아들이고 무시합니다.</target>
        </trans-unit>
        <trans-unit id="b8e36de59136b88fc2be5c019f1c1af0d901d853" translate="yes" xml:space="preserve">
          <source>Options &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;E&lt;/code&gt;, &lt;code&gt;e&lt;/code&gt;, &lt;code&gt;f&lt;/code&gt;, &lt;code&gt;G&lt;/code&gt;, and &lt;code&gt;g&lt;/code&gt; all expect a number as argument. Options &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;d&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;o&lt;/code&gt;, &lt;code&gt;u&lt;/code&gt;, &lt;code&gt;X&lt;/code&gt;, and &lt;code&gt;x&lt;/code&gt; expect an integer. When Lua is compiled with a C89 compiler, options &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; (hexadecimal floats) do not support any modifier (flags, width, length).</source>
          <target state="translated">옵션 &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;E&lt;/code&gt; , &lt;code&gt;e&lt;/code&gt; , &lt;code&gt;f&lt;/code&gt; , &lt;code&gt;G&lt;/code&gt; 및 &lt;code&gt;g&lt;/code&gt; 는 모두 숫자를 인수로 예상합니다. 옵션 &lt;code&gt;c&lt;/code&gt; , &lt;code&gt;d&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;o&lt;/code&gt; , &lt;code&gt;u&lt;/code&gt; , &lt;code&gt;X&lt;/code&gt; 및 &lt;code&gt;x&lt;/code&gt; 는 정수를 예상합니다. 루아는 C89 컴파일러로 컴파일 할 때, 옵션 및 (16 진수 수레) 어떤 수정 (플래그, 폭, 길이)를 지원하지 않습니다. &lt;code&gt;A&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8a1abeaa4ebe74d5340ad5d927126ab129362a92" translate="yes" xml:space="preserve">
          <source>Otherwise, returns three values: the &lt;a href=&quot;#pdf-next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; function, the table &lt;code&gt;t&lt;/code&gt;, and &lt;b&gt;nil&lt;/b&gt;, so that the construction</source>
          <target state="translated">그렇지 않으면 &lt;a href=&quot;#pdf-next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; 함수, 테이블 &lt;code&gt;t&lt;/code&gt; 및 &lt;b&gt;nil의&lt;/b&gt; 세 가지 값을 반환 하여 구성합니다.</target>
        </trans-unit>
        <trans-unit id="178c0a8da555da3fb52bb9fe10047627cb505e75" translate="yes" xml:space="preserve">
          <source>Parameters &lt;code&gt;ar&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; are as in function &lt;a href=&quot;#lua_getlocal&quot;&gt;&lt;code&gt;lua_getlocal&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">매개 변수 &lt;code&gt;ar&lt;/code&gt; 및 &lt;code&gt;n&lt;/code&gt; 은 &lt;a href=&quot;#lua_getlocal&quot;&gt; &lt;code&gt;lua_getlocal&lt;/code&gt; &lt;/a&gt; 함수와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="8dc64fc2f4cd99c0ced65561a7ce6e7af2b4bf51" translate="yes" xml:space="preserve">
          <source>Parameters &lt;code&gt;ar&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; are as in the function &lt;a href=&quot;#lua_getlocal&quot;&gt;&lt;code&gt;lua_getlocal&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">매개 변수 &lt;code&gt;ar&lt;/code&gt; 및 &lt;code&gt;n&lt;/code&gt; 은 &lt;a href=&quot;#lua_getlocal&quot;&gt; &lt;code&gt;lua_getlocal&lt;/code&gt; &lt;/a&gt; 함수와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="6ea29796519b03e49b8f299281d87fde989109ec" translate="yes" xml:space="preserve">
          <source>Parameters &lt;code&gt;funcindex&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; are as in function &lt;a href=&quot;#lua_getupvalue&quot;&gt;&lt;code&gt;lua_getupvalue&lt;/code&gt;&lt;/a&gt;, but &lt;code&gt;n&lt;/code&gt; cannot be greater than the number of upvalues.</source>
          <target state="translated">&lt;code&gt;funcindex&lt;/code&gt; 및 &lt;code&gt;n&lt;/code&gt; 매개 변수는 lua_getupvalue 함수에서 와 같지만 &lt;code&gt;n&lt;/code&gt; 은 &lt;a href=&quot;#lua_getupvalue&quot;&gt; &lt;code&gt;lua_getupvalue&lt;/code&gt; &lt;/a&gt; 수보다 클 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="430e32c1c643e4f1d035c6b28b1a7ed4bf4a0eac" translate="yes" xml:space="preserve">
          <source>Parameters &lt;code&gt;funcindex&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; are as in function &lt;a href=&quot;#lua_getupvalue&quot;&gt;&lt;code&gt;lua_getupvalue&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;funcindex&lt;/code&gt; 및 &lt;code&gt;n&lt;/code&gt; 매개 변수는 lua_getupvalue 함수와 &lt;a href=&quot;#lua_getupvalue&quot;&gt; &lt;code&gt;lua_getupvalue&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bc00bbb5ef17f161e882643cc3eb1de5624c1761" translate="yes" xml:space="preserve">
          <source>Parameters &lt;code&gt;funcindex&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; are as in the function &lt;a href=&quot;#lua_getupvalue&quot;&gt;&lt;code&gt;lua_getupvalue&lt;/code&gt;&lt;/a&gt;, but &lt;code&gt;n&lt;/code&gt; cannot be greater than the number of upvalues.</source>
          <target state="translated">&lt;code&gt;funcindex&lt;/code&gt; 및 &lt;code&gt;n&lt;/code&gt; 매개 변수는 lua_getupvalue 함수 &lt;a href=&quot;#lua_getupvalue&quot;&gt; &lt;code&gt;lua_getupvalue&lt;/code&gt; &lt;/a&gt; 와 같지만 &lt;code&gt;n&lt;/code&gt; 은 upvalue의 수보다 클 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d4fbfbc25528bfc37258607c935be76b6d23f936" translate="yes" xml:space="preserve">
          <source>Parameters &lt;code&gt;funcindex&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; are as in the function &lt;a href=&quot;#lua_getupvalue&quot;&gt;&lt;code&gt;lua_getupvalue&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">매개 변수 &lt;code&gt;funcindex&lt;/code&gt; 및 &lt;code&gt;n&lt;/code&gt; 은 &lt;a href=&quot;#lua_getupvalue&quot;&gt; &lt;code&gt;lua_getupvalue&lt;/code&gt; &lt;/a&gt; 함수와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="ed5ec09aef437013e06ea8a8354f4fd26022ed2a" translate="yes" xml:space="preserve">
          <source>Parameters act as local variables that are initialized with the argument values:</source>
          <target state="translated">매개 변수는 인수 값으로 초기화되는 로컬 변수로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="448ecaf1d946410d7f3122c5e30729943106812b" translate="yes" xml:space="preserve">
          <source>Pattern Item:</source>
          <target state="translated">패턴 아이템 :</target>
        </trans-unit>
        <trans-unit id="5da899e9024f2b8d94cc4514fe33d4ff85310e83" translate="yes" xml:space="preserve">
          <source>Pattern:</source>
          <target state="translated">Pattern:</target>
        </trans-unit>
        <trans-unit id="4d34f7a2b0b3b6df62a051917d7e7ac2de8a38df" translate="yes" xml:space="preserve">
          <source>Patterns</source>
          <target state="translated">Patterns</target>
        </trans-unit>
        <trans-unit id="8d2dcea1a0ef2ec1d9376ec9b8afe27c3f59c3e3" translate="yes" xml:space="preserve">
          <source>Patterns in Lua are described by regular strings, which are interpreted as patterns by the pattern-matching functions &lt;a href=&quot;#pdf-string.find&quot;&gt;&lt;code&gt;string.find&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pdf-string.gmatch&quot;&gt;&lt;code&gt;string.gmatch&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pdf-string.gsub&quot;&gt;&lt;code&gt;string.gsub&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#pdf-string.match&quot;&gt;&lt;code&gt;string.match&lt;/code&gt;&lt;/a&gt;. This section describes the syntax and the meaning (that is, what they match) of these strings.</source>
          <target state="translated">Lua의 패턴은 일반 문자열로 설명되며 패턴 일치 함수 &lt;a href=&quot;#pdf-string.find&quot;&gt; &lt;code&gt;string.find&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#pdf-string.gmatch&quot;&gt; &lt;code&gt;string.gmatch&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#pdf-string.gsub&quot;&gt; &lt;code&gt;string.gsub&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#pdf-string.match&quot;&gt; &lt;code&gt;string.match&lt;/code&gt; 에&lt;/a&gt; 의해 패턴으로 해석됩니다 . 이 절에서는 이러한 문자열의 구문과 의미 (즉, 일치하는 내용)에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="dc7394297e26f026260d375d7cd96592fbd9339e" translate="yes" xml:space="preserve">
          <source>Performs an arithmetic or bitwise operation over the two values (or one, in the case of negations) at the top of the stack, with the value at the top being the second operand, pops these values, and pushes the result of the operation. The function follows the semantics of the corresponding Lua operator (that is, it may call metamethods).</source>
          <target state="translated">스택 맨 위의 두 값 (또는 부정의 경우 하나)에 대해 산술 또는 비트 단위 연산을 수행하고 맨 위의 값은 두 번째 피연산자이며이 값을 팝하여 연산 결과를 푸시합니다. 이 함수는 해당 Lua 연산자의 의미를 따릅니다 (즉, 메타 메소드를 호출 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="1fd5e0033b4343c024b4c61550d5dda42703ec57" translate="yes" xml:space="preserve">
          <source>Performs an arithmetic or bitwise operation over the two values (or one, in the case of negations) at the top of the stack, with the value on the top being the second operand, pops these values, and pushes the result of the operation. The function follows the semantics of the corresponding Lua operator (that is, it may call metamethods).</source>
          <target state="translated">스택의 맨 위에있는 두 값 (또는 부정의 경우 하나)에 대해 산술 또는 비트 연산을 수행합니다. 맨 위에있는 값이 두 번째 피연산자가되어 이러한 값을 팝하고 연산 결과를 푸시합니다. 함수는 해당 Lua 연산자의 의미를 따릅니다 (즉, 메타 메서드를 호출 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="ee7dc30bd933bbb4baaecee808c6149d39035466" translate="yes" xml:space="preserve">
          <source>Pointers to strings</source>
          <target state="translated">문자열에 대한 포인터</target>
        </trans-unit>
        <trans-unit id="1299b0bc498833db75f9cf0fffff3c4bae0facff" translate="yes" xml:space="preserve">
          <source>Pops &lt;code&gt;n&lt;/code&gt; elements from the stack.</source>
          <target state="translated">스택에서 &lt;code&gt;n&lt;/code&gt; 개의 요소를 팝 합니다.</target>
        </trans-unit>
        <trans-unit id="fcc747279637a2d8a447881433d9aea7cb9cb559" translate="yes" xml:space="preserve">
          <source>Pops a key from the stack, and pushes a key&amp;ndash;value pair from the table at the given index (the &quot;next&quot; pair after the given key). If there are no more elements in the table, then &lt;a href=&quot;#lua_next&quot;&gt;&lt;code&gt;lua_next&lt;/code&gt;&lt;/a&gt; returns 0 (and pushes nothing).</source>
          <target state="translated">스택에서 키를 꺼내고 지정된 인덱스 (주어진 키 다음의 &quot;다음&quot;쌍)의 테이블에서 키-값 쌍을 푸시합니다. 테이블에 더 이상 요소가 없으면 &lt;a href=&quot;#lua_next&quot;&gt; &lt;code&gt;lua_next&lt;/code&gt; &lt;/a&gt; 는 0을 반환하고 아무 것도 푸시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d60cca5dd50e4b83932b42fd8d8d9fbffe7a1bc8" translate="yes" xml:space="preserve">
          <source>Pops a key from the stack, and pushes a key&amp;ndash;value pair from the table at the given index, the &quot;next&quot; pair after the given key. If there are no more elements in the table, then &lt;a href=&quot;#lua_next&quot;&gt;&lt;code&gt;lua_next&lt;/code&gt;&lt;/a&gt; returns 0 and pushes nothing.</source>
          <target state="translated">스택에서 키를 꺼내고 주어진 인덱스에있는 테이블에서 키-값 쌍, 주어진 키 뒤의 &quot;다음&quot;쌍을 푸시합니다. 테이블에 더 이상 요소가 없으면 &lt;a href=&quot;#lua_next&quot;&gt; &lt;code&gt;lua_next&lt;/code&gt; &lt;/a&gt; 는 0을 반환하고 아무것도 푸시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="38ce2b2d648784be385652bd2405ecdc4f5fbdbc" translate="yes" xml:space="preserve">
          <source>Pops a table from the stack and sets it as the new metatable for the value at the given index.</source>
          <target state="translated">스택에서 테이블을 팝하고 주어진 인덱스의 값에 대한 새로운 메타 테이블로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="3748a23e8606e10be9753871f0543fd3b3c035b8" translate="yes" xml:space="preserve">
          <source>Pops a table or &lt;b&gt;nil&lt;/b&gt; from the stack and sets that value as the new metatable for the value at the given index. (&lt;b&gt;nil&lt;/b&gt; means no metatable.)</source>
          <target state="translated">스택에서 테이블 또는 &lt;b&gt;nil&lt;/b&gt; 을 팝하고 해당 값을 지정된 인덱스의 값에 대한 새 메타 테이블로 설정합니다. ( &lt;b&gt;nil&lt;/b&gt; 은 메타 테이블이 &lt;b&gt;없음을&lt;/b&gt; 의미합니다.)</target>
        </trans-unit>
        <trans-unit id="02cbea7516afa5834e8becd7f7d4a828165b122a" translate="yes" xml:space="preserve">
          <source>Pops a value from the stack and sets it as the new &lt;code&gt;n&lt;/code&gt;-th user value associated to the full userdata at the given index. Returns 0 if the userdata does not have that value.</source>
          <target state="translated">스택에서 값을 가져 와서 지정된 인덱스의 전체 사용자 데이터와 관련된 새로운 &lt;code&gt;n&lt;/code&gt; 번째 사용자 값 으로 설정합니다 . 사용자 데이터에 해당 값이 없으면 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9e0a9d18a088445b817b9df7884bfcb32d185882" translate="yes" xml:space="preserve">
          <source>Pops a value from the stack and sets it as the new value associated to the full userdata at the given index.</source>
          <target state="translated">스택에서 값을 팝하고 주어진 인덱스에서 전체 사용자 데이터와 연관된 새 값으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="e2b2f785858d2ccd19fa2b3c3174e4f53334d580" translate="yes" xml:space="preserve">
          <source>Pops a value from the stack and sets it as the new value of global &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">스택에서 값을 팝하여 새 전역 &lt;code&gt;name&lt;/code&gt; 값으로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="ab86fb82a986460447b29bbb55ca5b9bf867bad6" translate="yes" xml:space="preserve">
          <source>Precedence</source>
          <target state="translated">Precedence</target>
        </trans-unit>
        <trans-unit id="38891db011f7fa7075e0b3b67c891847a651262c" translate="yes" xml:space="preserve">
          <source>Pushes a C function onto the stack. This function is equivalent to &lt;a href=&quot;#lua_pushcclosure&quot;&gt;&lt;code&gt;lua_pushcclosure&lt;/code&gt;&lt;/a&gt; with no upvalues.</source>
          <target state="translated">스택에 C 함수를 푸시합니다. 이 함수는 upvalue가없는 &lt;a href=&quot;#lua_pushcclosure&quot;&gt; &lt;code&gt;lua_pushcclosure&lt;/code&gt; &lt;/a&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="6069e3ce33f065015c2dc7cf19747d682b66d1cb" translate="yes" xml:space="preserve">
          <source>Pushes a C function onto the stack. This function receives a pointer to a C function and pushes onto the stack a Lua value of type &lt;code&gt;function&lt;/code&gt; that, when called, invokes the corresponding C function.</source>
          <target state="translated">C 함수를 스택으로 푸시합니다. 이 함수는 C 함수에 대한 포인터를 수신하고 호출 될 때 해당 C 함수를 호출하는 &lt;code&gt;function&lt;/code&gt; 유형의 Lua 값을 스택으로 푸시 합니다.</target>
        </trans-unit>
        <trans-unit id="225557cebb89115cc93c59763f61b47f6e9246c5" translate="yes" xml:space="preserve">
          <source>Pushes a boolean value with value &lt;code&gt;b&lt;/code&gt; onto the stack.</source>
          <target state="translated">값이 &lt;code&gt;b&lt;/code&gt; 인 부울 값을 스택으로 푸시합니다.</target>
        </trans-unit>
        <trans-unit id="894000f061d35d3982475e83383dc72799631571" translate="yes" xml:space="preserve">
          <source>Pushes a copy of the element at the given index onto the stack.</source>
          <target state="translated">지정된 인덱스의 요소 사본을 스택으로 푸시합니다.</target>
        </trans-unit>
        <trans-unit id="b6ff7b2e435c0e0bd4a4dbe8af13548197a7ba1c" translate="yes" xml:space="preserve">
          <source>Pushes a float with value &lt;code&gt;n&lt;/code&gt; onto the stack.</source>
          <target state="translated">값이 &lt;code&gt;n&lt;/code&gt; 인 부동 소수점을 스택으로 푸시합니다 .</target>
        </trans-unit>
        <trans-unit id="1b7c742fb6acbbb7614fff04126bb1d65108509f" translate="yes" xml:space="preserve">
          <source>Pushes a light userdata onto the stack.</source>
          <target state="translated">가벼운 사용자 데이터를 스택으로 푸시합니다.</target>
        </trans-unit>
        <trans-unit id="f9640c606650c6c3b185fb6d556165b919470195" translate="yes" xml:space="preserve">
          <source>Pushes a new C closure onto the stack.</source>
          <target state="translated">새로운 C 클로저를 스택에 밀어 넣습니다.</target>
        </trans-unit>
        <trans-unit id="783ef23f706b3af65f922bb64840e0a1f3a3b44a" translate="yes" xml:space="preserve">
          <source>Pushes a new C closure onto the stack. This function receives a pointer to a C function and pushes onto the stack a Lua value of type &lt;code&gt;function&lt;/code&gt; that, when called, invokes the corresponding C function. The parameter &lt;code&gt;n&lt;/code&gt; tells how many upvalues this function will have (see &lt;a href=&quot;#4.2&quot;&gt;&amp;sect;4.2&lt;/a&gt;).</source>
          <target state="translated">새 C 클로저를 스택에 푸시합니다. 이 함수는 C 함수에 대한 포인터를 수신하고 호출시 해당 C 함수를 호출하는 &lt;code&gt;function&lt;/code&gt; 유형의 Lua 값을 스택에 푸시 합니다. 매개 변수 &lt;code&gt;n&lt;/code&gt; 은이 함수가 가질 upvalue의 수를 알려줍니다 ( &lt;a href=&quot;#4.2&quot;&gt;&amp;sect;4.2&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="f1a59444f671b252069eb2dc564dace63fe90d50" translate="yes" xml:space="preserve">
          <source>Pushes a nil value onto the stack.</source>
          <target state="translated">스택에 nil 값을 넣습니다.</target>
        </trans-unit>
        <trans-unit id="2ac334edd538c29ffe856d049cab16b02559c4e6" translate="yes" xml:space="preserve">
          <source>Pushes an integer with value &lt;code&gt;n&lt;/code&gt; onto the stack.</source>
          <target state="translated">값이 &lt;code&gt;n&lt;/code&gt; 인 정수를 스택으로 푸시합니다 .</target>
        </trans-unit>
        <trans-unit id="f8ab0829fe517855f739ffae026b3c01efbb88ce" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack a formatted string and returns a pointer to this string (see &lt;a href=&quot;#4.1.3&quot;&gt;&amp;sect;4.1.3&lt;/a&gt;). It is similar to the ISO C function &lt;code&gt;sprintf&lt;/code&gt;, but has two important differences. First, you do not have to allocate space for the result; the result is a Lua string and Lua takes care of memory allocation (and deallocation, through garbage collection). Second, the conversion specifiers are quite restricted. There are no flags, widths, or precisions. The conversion specifiers can only be '&lt;code&gt;%%&lt;/code&gt;' (inserts the character '&lt;code&gt;%&lt;/code&gt;'), '&lt;code&gt;%s&lt;/code&gt;' (inserts a zero-terminated string, with no size restrictions), '&lt;code&gt;%f&lt;/code&gt;' (inserts a &lt;a href=&quot;#lua_Number&quot;&gt;&lt;code&gt;lua_Number&lt;/code&gt;&lt;/a&gt;), '&lt;code&gt;%I&lt;/code&gt;' (inserts a &lt;a href=&quot;#lua_Integer&quot;&gt;&lt;code&gt;lua_Integer&lt;/code&gt;&lt;/a&gt;), '&lt;code&gt;%p&lt;/code&gt;' (inserts a pointer), '&lt;code&gt;%d&lt;/code&gt;' (inserts an &lt;code&gt;int&lt;/code&gt;), '&lt;code&gt;%c&lt;/code&gt;' (inserts an &lt;code&gt;int&lt;/code&gt; as a one-byte character), and '&lt;code&gt;%U&lt;/code&gt;' (inserts a &lt;code&gt;long int&lt;/code&gt; as a UTF-8 byte sequence).</source>
          <target state="translated">형식이 지정된 문자열을 스택에 푸시하고이 문자열에 대한 포인터를 반환합니다 ( &lt;a href=&quot;#4.1.3&quot;&gt;&amp;sect;4.1.3&lt;/a&gt; 참조 ). ISO C 함수 &lt;code&gt;sprintf&lt;/code&gt; 와 유사 하지만 두 가지 중요한 차이점이 있습니다. 첫째, 결과를위한 공간을 할당 할 필요가 없습니다. 결과는 Lua 문자열이고 Lua는 메모리 할당 (및 가비지 수집을 통한 할당 해제)을 처리합니다. 둘째, 변환 지정자는 매우 제한적입니다. 플래그, 너비 또는 정밀도가 없습니다. 변환 지정자는 ' &lt;code&gt;%%&lt;/code&gt; '(문자 ' &lt;code&gt;%&lt;/code&gt; ' 삽입 ), ' &lt;code&gt;%s&lt;/code&gt; '(크기 제한없이 0으로 끝나는 문자열 삽입), ' &lt;code&gt;%f&lt;/code&gt; '( &lt;a href=&quot;#lua_Number&quot;&gt; &lt;code&gt;lua_Number&lt;/code&gt; &lt;/a&gt; 삽입 ), ' &lt;code&gt;%I&lt;/code&gt; '(삽입&lt;a href=&quot;#lua_Integer&quot;&gt; &lt;code&gt;lua_Integer&lt;/code&gt; &lt;/a&gt; ) ' &lt;code&gt;%p&lt;/code&gt; '(삽입 포인터), ' &lt;code&gt;%d&lt;/code&gt; '(삽입 &lt;code&gt;int&lt;/code&gt; ), ' &lt;code&gt;%c&lt;/code&gt; '(삽입 &lt;code&gt;int&lt;/code&gt; 1 바이트 문자 등), 및 ' &lt;code&gt;%U&lt;/code&gt; &quot;(삽입합니다 &lt;code&gt;long int&lt;/code&gt; 로서 UTF-8 바이트 시퀀스).</target>
        </trans-unit>
        <trans-unit id="ebf2182a4bd44a4ababe6986cdc0d46624511d6f" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack a formatted string and returns a pointer to this string. It is similar to the ISO C function &lt;code&gt;sprintf&lt;/code&gt;, but has some important differences:</source>
          <target state="translated">형식화 된 문자열을 스택에 푸시하고이 문자열에 대한 포인터를 반환합니다. ISO C 함수 &lt;code&gt;sprintf&lt;/code&gt; 와 비슷하지만 몇 가지 중요한 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3eb6979dbbec2441c887e7c302c341c3e2193b2" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack a string identifying the current position of the control at level &lt;code&gt;lvl&lt;/code&gt; in the call stack. Typically this string has the following format:</source>
          <target state="translated">콜 스택의 레벨 &lt;code&gt;lvl&lt;/code&gt; 에서 컨트롤의 현재 위치를 식별하는 문자열을 스택으로 푸시합니다 . 일반적으로이 문자열의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="31d25d3d93b7e126c80bd4b8ac83684541597116" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack the &lt;code&gt;n&lt;/code&gt;-th user value associated with the full userdata at the given index and returns the type of the pushed value.</source>
          <target state="translated">주어진 인덱스에서 전체 사용자 데이터와 관련된 &lt;code&gt;n&lt;/code&gt; 번째 사용자 값을 스택에 푸시 하고 푸시 된 값의 유형을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1400d6038d9c13c6266dab4b80bdcdd7fc31a04b" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack the Lua value associated with the full userdata at the given index.</source>
          <target state="translated">주어진 인덱스에서 전체 사용자 데이터와 관련된 Lua 값을 스택으로 푸시합니다.</target>
        </trans-unit>
        <trans-unit id="96d78a717bd5f3b49461732d2e8f02559185b11e" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack the field &lt;code&gt;e&lt;/code&gt; from the metatable of the object at index &lt;code&gt;obj&lt;/code&gt; and returns the type of pushed value. If the object does not have a metatable, or if the metatable does not have this field, pushes nothing and returns &lt;code&gt;LUA_TNIL&lt;/code&gt;.</source>
          <target state="translated">인덱스 &lt;code&gt;obj&lt;/code&gt; 에있는 객체의 메타 테이블에서 필드 &lt;code&gt;e&lt;/code&gt; 를 스택으로 푸시하고 푸시 된 값의 유형을 반환합니다. 객체에 메타 테이블이 없거나 메타 테이블에이 필드가없는 경우 아무것도 푸시하지 않고 &lt;code&gt;LUA_TNIL&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="d063d65f8ebdd7680c71182f22ecc37ef6878b23" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack the field &lt;code&gt;e&lt;/code&gt; from the metatable of the object at index &lt;code&gt;obj&lt;/code&gt; and returns the type of the pushed value. If the object does not have a metatable, or if the metatable does not have this field, pushes nothing and returns &lt;code&gt;LUA_TNIL&lt;/code&gt;.</source>
          <target state="translated">인덱스 &lt;code&gt;obj&lt;/code&gt; 에있는 객체의 메타 테이블에서 필드 &lt;code&gt;e&lt;/code&gt; 를 스택에 푸시 하고 푸시 된 값의 유형을 반환합니다. 객체에 메타 테이블이 없거나 메타 테이블에이 필드가 없으면 아무것도 푸시하지 않고 &lt;code&gt;LUA_TNIL&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="e6a3ae7b655cf9df13c5b9cf6975aa8b58442402" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack the metatable associated with name &lt;code&gt;tname&lt;/code&gt; in the registry (see &lt;a href=&quot;#luaL_newmetatable&quot;&gt;&lt;code&gt;luaL_newmetatable&lt;/code&gt;&lt;/a&gt;) (&lt;b&gt;nil&lt;/b&gt; if there is no metatable associated with that name). Returns the type of the pushed value.</source>
          <target state="translated">레지스트리에서 이름 &lt;code&gt;tname&lt;/code&gt; 과 연관된 메타 테이블을 스택에 푸시합니다 ( &lt;a href=&quot;#luaL_newmetatable&quot;&gt; &lt;code&gt;luaL_newmetatable&lt;/code&gt; &lt;/a&gt; 참조 ) ( 해당 이름과 연관된 메타 테이블이없는 경우 &lt;b&gt;nil&lt;/b&gt; ). 푸시 된 값의 유형을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c76c4d4c11e0c9e0d1f805bd491ba2da9880963e" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack the metatable associated with the name &lt;code&gt;tname&lt;/code&gt; in the registry (see &lt;a href=&quot;#luaL_newmetatable&quot;&gt;&lt;code&gt;luaL_newmetatable&lt;/code&gt;&lt;/a&gt;), or &lt;b&gt;nil&lt;/b&gt; if there is no metatable associated with that name. Returns the type of the pushed value.</source>
          <target state="translated">레지스트리의 &lt;code&gt;tname&lt;/code&gt; 이름과 연관된 메타 테이블을 스택에 푸시 하거나 ( &lt;a href=&quot;#luaL_newmetatable&quot;&gt; &lt;code&gt;luaL_newmetatable&lt;/code&gt; &lt;/a&gt; 참조 ) 해당 이름과 연관된 메타 테이블이 없으면 &lt;b&gt;nil을 &lt;/b&gt;푸시 합니다. 푸시 된 값의 유형을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3681d4e1cdd569fb3b2f3300755bb4d0cfb69c67" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack the value &lt;code&gt;t[i]&lt;/code&gt;, where &lt;code&gt;t&lt;/code&gt; is the value at the given index. As in Lua, this function may trigger a metamethod for the &quot;index&quot; event (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;).</source>
          <target state="translated">스택에 값 &lt;code&gt;t[i]&lt;/code&gt; 푸시합니다. 여기서 &lt;code&gt;t&lt;/code&gt; 는 지정된 인덱스의 값입니다. 루아에서와 &lt;a href=&quot;#2.4&quot;&gt;같이이&lt;/a&gt; 함수는 &quot;인덱스&quot;이벤트에 대한 메타 메소드를 트리거 할 수 있습니다 ( &amp;sect;2.4 참조 ).</target>
        </trans-unit>
        <trans-unit id="160cbb51fcadb575239ec804bbd26447a616f853" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack the value &lt;code&gt;t[k]&lt;/code&gt;, where &lt;code&gt;t&lt;/code&gt; is the table at the given index and &lt;code&gt;k&lt;/code&gt; is the pointer &lt;code&gt;p&lt;/code&gt; represented as a light userdata. The access is raw; that is, it does not invoke the &lt;code&gt;__index&lt;/code&gt; metamethod.</source>
          <target state="translated">스택에 값 &lt;code&gt;t[k]&lt;/code&gt; 푸시합니다. 여기서 &lt;code&gt;t&lt;/code&gt; 는 주어진 인덱스의 테이블이고 &lt;code&gt;k&lt;/code&gt; 는 가벼운 사용자 데이터로 표시되는 포인터 &lt;code&gt;p&lt;/code&gt; 입니다. 액세스는 원시적입니다. 즉, &lt;code&gt;__index&lt;/code&gt; 메타 메소드를 호출하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f758b684030c5bdc751c5b58b931a7f7b9972806" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack the value &lt;code&gt;t[k]&lt;/code&gt;, where &lt;code&gt;t&lt;/code&gt; is the table at the given index and &lt;code&gt;k&lt;/code&gt; is the pointer &lt;code&gt;p&lt;/code&gt; represented as a light userdata. The access is raw; that is, it does not use the &lt;code&gt;__index&lt;/code&gt; metavalue.</source>
          <target state="translated">스택에 &lt;code&gt;t[k]&lt;/code&gt; 값을 푸시합니다. 여기서 &lt;code&gt;t&lt;/code&gt; 는 주어진 인덱스의 테이블이고 &lt;code&gt;k&lt;/code&gt; 는 라이트 사용자 데이터로 표시되는 포인터 &lt;code&gt;p&lt;/code&gt; 입니다. 액세스는 원시입니다. 즉, &lt;code&gt;__index&lt;/code&gt; 메타 값을 사용하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9ba28c13e89d272d19c50f5e767726525d936e21" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack the value &lt;code&gt;t[k]&lt;/code&gt;, where &lt;code&gt;t&lt;/code&gt; is the value at the given index and &lt;code&gt;k&lt;/code&gt; is the value at the top of the stack.</source>
          <target state="translated">스택에 값 &lt;code&gt;t[k]&lt;/code&gt; 푸시합니다. 여기서 &lt;code&gt;t&lt;/code&gt; 는 지정된 인덱스 의 값 이고 &lt;code&gt;k&lt;/code&gt; 는 스택의 맨 위에있는 값입니다.</target>
        </trans-unit>
        <trans-unit id="2c9f6ce9bcbe6e782d6892ed66ce333a49c1c0f5" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack the value &lt;code&gt;t[k]&lt;/code&gt;, where &lt;code&gt;t&lt;/code&gt; is the value at the given index and &lt;code&gt;k&lt;/code&gt; is the value on the top of the stack.</source>
          <target state="translated">스택에 &lt;code&gt;t[k]&lt;/code&gt; 값을 푸시합니다. 여기서 &lt;code&gt;t&lt;/code&gt; 는 주어진 인덱스 의 값 이고 &lt;code&gt;k&lt;/code&gt; 는 스택의 맨 위에있는 값입니다.</target>
        </trans-unit>
        <trans-unit id="d433d1f4953100bc2a0c9d7a8e8e092f7c0a5c2a" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack the value &lt;code&gt;t[k]&lt;/code&gt;, where &lt;code&gt;t&lt;/code&gt; is the value at the given index. As in Lua, this function may trigger a metamethod for the &quot;index&quot; event (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;).</source>
          <target state="translated">스택에 값 &lt;code&gt;t[k]&lt;/code&gt; 푸시합니다. 여기서 &lt;code&gt;t&lt;/code&gt; 는 지정된 인덱스의 값입니다. 루아에서와 &lt;a href=&quot;#2.4&quot;&gt;같이이&lt;/a&gt; 함수는 &quot;인덱스&quot;이벤트에 대한 메타 메소드를 트리거 할 수 있습니다 ( &amp;sect;2.4 참조 ).</target>
        </trans-unit>
        <trans-unit id="27c3e32a80e22fb604cbe4557acc820d3c5231a7" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack the value &lt;code&gt;t[n]&lt;/code&gt;, where &lt;code&gt;t&lt;/code&gt; is the table at the given index. The access is raw, that is, it does not invoke the &lt;code&gt;__index&lt;/code&gt; metamethod.</source>
          <target state="translated">스택에 값 &lt;code&gt;t[n]&lt;/code&gt; 푸시합니다. 여기서 &lt;code&gt;t&lt;/code&gt; 는 지정된 인덱스의 테이블입니다. 액세스는 원시적입니다. 즉, &lt;code&gt;__index&lt;/code&gt; 메타 메소드를 호출하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="dbeb4c059af4ccf3fb9e1fdfc5784413b8117212" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack the value &lt;code&gt;t[n]&lt;/code&gt;, where &lt;code&gt;t&lt;/code&gt; is the table at the given index. The access is raw, that is, it does not use the &lt;code&gt;__index&lt;/code&gt; metavalue.</source>
          <target state="translated">스택에 &lt;code&gt;t[n]&lt;/code&gt; 값을 푸시합니다. 여기서 &lt;code&gt;t&lt;/code&gt; 는 주어진 인덱스에있는 테이블입니다. 액세스는 원시입니다. 즉, &lt;code&gt;__index&lt;/code&gt; 메타 값을 사용하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3adeb92584bb85f61e3f56627b5522106f4dd7b4" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack the value of the global &lt;code&gt;name&lt;/code&gt;. Returns the type of that value.</source>
          <target state="translated">전역 &lt;code&gt;name&lt;/code&gt; 값을 스택에 푸시합니다 . 해당 값의 유형을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d5f71bf51568746d5ff514f34182d2dde3178d9d" translate="yes" xml:space="preserve">
          <source>Pushes the &lt;b&gt;fail&lt;/b&gt; value onto the stack (see &lt;a href=&quot;#6&quot;&gt;&amp;sect;6&lt;/a&gt;).</source>
          <target state="translated">&lt;b&gt;실패&lt;/b&gt; 값을 스택에 푸시합니다 ( &lt;a href=&quot;#6&quot;&gt;&amp;sect;6&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="96bb89f8fd253dc6a3b3b23f64ce3135d6817db4" translate="yes" xml:space="preserve">
          <source>Pushes the global environment onto the stack.</source>
          <target state="translated">글로벌 환경을 스택으로 푸시합니다.</target>
        </trans-unit>
        <trans-unit id="b8b8e3282a4a6ab4f3ed7c29929c1ea38215b0e1" translate="yes" xml:space="preserve">
          <source>Pushes the string pointed to by &lt;code&gt;s&lt;/code&gt; with size &lt;code&gt;len&lt;/code&gt; onto the stack. Lua makes (or reuses) an internal copy of the given string, so the memory at &lt;code&gt;s&lt;/code&gt; can be freed or reused immediately after the function returns. The string can contain any binary data, including embedded zeros.</source>
          <target state="translated">크기가 &lt;code&gt;len&lt;/code&gt; 인 &lt;code&gt;s&lt;/code&gt; 가 가리키는 문자열을 스택에 푸시합니다. Lua는 주어진 문자열의 내부 복사본을 만들거나 재사용하므로 함수가 반환 된 직후 에 &lt;code&gt;s&lt;/code&gt; 의 메모리를 비우거나 재사용 할 수 있습니다. 문자열에는 포함 된 0을 포함한 모든 이진 데이터가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5639aa8221a13af71464ab360f3a38097209c56d" translate="yes" xml:space="preserve">
          <source>Pushes the string pointed to by &lt;code&gt;s&lt;/code&gt; with size &lt;code&gt;len&lt;/code&gt; onto the stack. Lua will make or reuse an internal copy of the given string, so the memory at &lt;code&gt;s&lt;/code&gt; can be freed or reused immediately after the function returns. The string can contain any binary data, including embedded zeros.</source>
          <target state="translated">크기가 &lt;code&gt;len&lt;/code&gt; 인 &lt;code&gt;s&lt;/code&gt; 가 가리키는 문자열을 스택으로 푸시합니다. Lua는 주어진 문자열의 내부 사본을 만들거나 재사용 할 것이므로 &lt;code&gt;s&lt;/code&gt; 의 메모리 는 함수가 반환 된 직후에 해제되거나 재사용 될 수 있습니다. 문자열은 포함 된 0을 포함하여 모든 이진 데이터를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6b66a7bc8fe80fa098dee231f5eaec5a6ccedfa" translate="yes" xml:space="preserve">
          <source>Pushes the thread represented by &lt;code&gt;L&lt;/code&gt; onto the stack. Returns 1 if this thread is the main thread of its state.</source>
          <target state="translated">&lt;code&gt;L&lt;/code&gt; 로 표시된 스레드를 스택에 밀어 넣습니다 . 이 스레드가 상태의 기본 스레드 인 경우 1을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="4854f8dce1b3efb397d0da3cc0315b1cfb867e30" translate="yes" xml:space="preserve">
          <source>Pushes the zero-terminated string pointed to by &lt;code&gt;s&lt;/code&gt; onto the stack. Lua makes (or reuses) an internal copy of the given string, so the memory at &lt;code&gt;s&lt;/code&gt; can be freed or reused immediately after the function returns.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 가 가리키는 0으로 끝나는 문자열을 스택으로 푸시합니다. Lua는 주어진 문자열의 내부 복사본을 만들거나 재사용하므로 함수가 반환 된 직후 에 &lt;code&gt;s&lt;/code&gt; 의 메모리를 비우거나 재사용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8860aa35b65cff58872a8601fb6de276a53dc538" translate="yes" xml:space="preserve">
          <source>Pushes the zero-terminated string pointed to by &lt;code&gt;s&lt;/code&gt; onto the stack. Lua will make or reuse an internal copy of the given string, so the memory at &lt;code&gt;s&lt;/code&gt; can be freed or reused immediately after the function returns.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 가 가리키는 0으로 끝나는 문자열을 스택으로 푸시합니다. Lua는 주어진 문자열의 내부 사본을 만들거나 재사용 할 것이므로 &lt;code&gt;s&lt;/code&gt; 의 메모리 는 함수가 반환 된 직후에 해제되거나 재사용 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8cfffe2498f662da17fd436630bb5c185a5f3013" translate="yes" xml:space="preserve">
          <source>Raises a Lua error, using the value on the top of the stack as the error object. This function does a long jump, and therefore never returns (see &lt;a href=&quot;#luaL_error&quot;&gt;&lt;code&gt;luaL_error&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">스택 맨 위에있는 값을 오류 개체로 사용하여 Lua 오류를 발생시킵니다. 이 함수는 멀리뛰기를 수행하므로 반환하지 않습니다 ( &lt;a href=&quot;#luaL_error&quot;&gt; &lt;code&gt;luaL_error&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="6a9d1916a4b52d4c954d6611c2265a068aa73389" translate="yes" xml:space="preserve">
          <source>Raises a type error for the argument &lt;code&gt;arg&lt;/code&gt; of the C function that called it, using a standard message; &lt;code&gt;tname&lt;/code&gt; is a &quot;name&quot; for the expected type. This function never returns.</source>
          <target state="translated">표준 메시지를 사용하여 호출 한 C 함수 의 인수 &lt;code&gt;arg&lt;/code&gt; 에 대해 유형 오류를 발생시킵니다 . &lt;code&gt;tname&lt;/code&gt; 은 예상 유형의 &quot;이름&quot;입니다. 이 함수는 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9b9354a43204b93a4330b1af0c9ff798523b53da" translate="yes" xml:space="preserve">
          <source>Raises an error (see &lt;a href=&quot;#2.3&quot;&gt;&amp;sect;2.3&lt;/a&gt;) with @{message} as the error object. This function never returns.</source>
          <target state="translated">@ {message}를 오류 개체로 사용하여 오류를 발생 시킵니다 ( &lt;a href=&quot;#2.3&quot;&gt;&amp;sect;2.3&lt;/a&gt; 참조 ). 이 함수는 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bf358ba5588da456b49a6b3b1276c902731720d9" translate="yes" xml:space="preserve">
          <source>Raises an error if the value of its argument &lt;code&gt;v&lt;/code&gt; is false (i.e., &lt;b&gt;nil&lt;/b&gt; or &lt;b&gt;false&lt;/b&gt;); otherwise, returns all its arguments. In case of error, &lt;code&gt;message&lt;/code&gt; is the error object; when absent, it defaults to &quot;&lt;code&gt;assertion failed!&lt;/code&gt;&quot;</source>
          <target state="translated">인수 &lt;code&gt;v&lt;/code&gt; 의 값 이 false (즉, &lt;b&gt;nil&lt;/b&gt; 또는 &lt;b&gt;false&lt;/b&gt; ) 이면 오류를 발생시킵니다 . 그렇지 않으면 모든 인수를 반환합니다. 오류의 경우 &lt;code&gt;message&lt;/code&gt; 는 오류 개체입니다. 없으면 기본값은 &quot; &lt;code&gt;assertion failed!&lt;/code&gt; &quot;입니다.</target>
        </trans-unit>
        <trans-unit id="fc0763820b54eedcf07407cf791911e6a4435f20" translate="yes" xml:space="preserve">
          <source>Raises an error reporting a problem with argument &lt;code&gt;arg&lt;/code&gt; of the C function that called it, using a standard message that includes &lt;code&gt;extramsg&lt;/code&gt; as a comment:</source>
          <target state="translated">&lt;code&gt;extramsg&lt;/code&gt; 를 주석으로 포함하는 표준 메시지를 사용하여 호출 한 C 함수의 인수 &lt;code&gt;arg&lt;/code&gt; 에 대한 문제점을보고하는 오류가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="2195072e1ce816af3985bb81599b653639e6d200" translate="yes" xml:space="preserve">
          <source>Raises an error. The error message format is given by &lt;code&gt;fmt&lt;/code&gt; plus any extra arguments, following the same rules of &lt;a href=&quot;#lua_pushfstring&quot;&gt;&lt;code&gt;lua_pushfstring&lt;/code&gt;&lt;/a&gt;. It also adds at the beginning of the message the file name and the line number where the error occurred, if this information is available.</source>
          <target state="translated">오류가 발생합니다. 오류 메시지 형식은 동일한 규칙 &lt;a href=&quot;#lua_pushfstring&quot;&gt; &lt;code&gt;lua_pushfstring&lt;/code&gt; 에&lt;/a&gt; 따라 &lt;code&gt;fmt&lt;/code&gt; 와 추가 인수로 제공됩니다 . 또한이 정보가 사용 가능한 경우 메시지 시작 부분에 파일 이름과 오류가 발생한 행 번호를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="e31b0fedf40d60473a1681a9f95cd0f5ccee72ff" translate="yes" xml:space="preserve">
          <source>Reads the file &lt;code&gt;file&lt;/code&gt;, according to the given formats, which specify what to read. For each format, the function returns a string or a number with the characters read, or &lt;b&gt;fail&lt;/b&gt; if it cannot read data with the specified format. (In this latter case, the function does not read subsequent formats.) When called without arguments, it uses a default format that reads the next line (see below).</source>
          <target state="translated">읽을 내용을 지정하는 주어진 형식에 따라 파일 &lt;code&gt;file&lt;/code&gt; 을 읽습니다. 각 형식에 대해 함수는 읽은 문자가있는 문자열 또는 숫자를 반환하거나 지정된 형식으로 데이터를 읽을 수없는 경우 &lt;b&gt;실패&lt;/b&gt; 합니다. (후자의 경우 함수는 후속 형식을 읽지 않습니다.) 인수없이 호출되면 다음 행을 읽는 기본 형식을 사용합니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="76a33dab1cf51144cd77abed8a485f73ea3a2319" translate="yes" xml:space="preserve">
          <source>Reads the file &lt;code&gt;file&lt;/code&gt;, according to the given formats, which specify what to read. For each format, the function returns a string or a number with the characters read, or &lt;b&gt;nil&lt;/b&gt; if it cannot read data with the specified format. (In this latter case, the function does not read subsequent formats.) When called without formats, it uses a default format that reads the next line (see below).</source>
          <target state="translated">주어진 형식에 따라 읽을 &lt;code&gt;file&lt;/code&gt; 을 지정 하는 파일 file 을 읽습니다. 각 형식에 대해이 함수는 문자를 읽은 문자열 또는 숫자를 반환하거나 지정된 형식의 데이터를 읽을 수없는 경우 &lt;b&gt;nil을&lt;/b&gt; 반환합니다. 후자의 경우 함수는 후속 형식을 읽지 않습니다. 형식없이 호출되면 다음 행을 읽는 기본 형식을 사용합니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="19c5c64f58aecd561b0cc1876786dfe7cb5a0fec" translate="yes" xml:space="preserve">
          <source>Receives a string and returns a copy of this string with all lowercase letters changed to uppercase. All other characters are left unchanged. The definition of what a lowercase letter is depends on the current locale.</source>
          <target state="translated">문자열을 받고 모든 소문자가 대문자로 변경된이 문자열의 복사본을 반환합니다. 다른 모든 문자는 변경되지 않습니다. 소문자가 무엇인지에 대한 정의는 현재 로케일에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="540aac1cb2574351ee99baa96641925cd5f56a55" translate="yes" xml:space="preserve">
          <source>Receives a string and returns a copy of this string with all uppercase letters changed to lowercase. All other characters are left unchanged. The definition of what an uppercase letter is depends on the current locale.</source>
          <target state="translated">문자열을 받고 모든 대문자가 소문자로 변경된이 문자열의 복사본을 반환합니다. 다른 모든 문자는 변경되지 않습니다. 대문자의 정의는 현재 로케일에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="b890d3f853acc49ad9cf651903e6eb6cdf33901a" translate="yes" xml:space="preserve">
          <source>Receives a string and returns its length. The empty string &lt;code&gt;&quot;&quot;&lt;/code&gt; has length 0. Embedded zeros are counted, so &lt;code&gt;&quot;a\000bc\000&quot;&lt;/code&gt; has length 5.</source>
          <target state="translated">문자열을 받아서 길이를 반환합니다. 빈 문자열 &lt;code&gt;&quot;&quot;&lt;/code&gt; 의 길이는 0입니다. 포함 된 0이 계산되므로 &lt;code&gt;&quot;a\000bc\000&quot;&lt;/code&gt; 길이는 5입니다.</target>
        </trans-unit>
        <trans-unit id="d82851b5722eeb1a4807bb839e4ddddefaeb2a1b" translate="yes" xml:space="preserve">
          <source>Receives a value of any type and converts it to a string in a human-readable format.</source>
          <target state="translated">모든 유형의 값을 받아 사람이 읽을 수있는 형식의 문자열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="525f707997f87240ceb1b2b5bdf4cfc009a704fc" translate="yes" xml:space="preserve">
          <source>Receives a value of any type and converts it to a string in a human-readable format. (For complete control of how numbers are converted, use &lt;a href=&quot;#pdf-string.format&quot;&gt;&lt;code&gt;string.format&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">모든 유형의 값을 받아서 사람이 읽을 수있는 형식의 문자열로 변환합니다. 숫자를 변환하는 방법을 완전히 제어하려면 &lt;a href=&quot;#pdf-string.format&quot;&gt; &lt;code&gt;string.format&lt;/code&gt; 을&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="f08637f98da65a6c936ab18edfd8700b8df77cb5" translate="yes" xml:space="preserve">
          <source>Receives any number of arguments and prints their values to &lt;code&gt;stdout&lt;/code&gt;, converting each argument to a string following the same rules of &lt;a href=&quot;#pdf-tostring&quot;&gt;&lt;code&gt;tostring&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">임의의 수의 인수를 수신하고 해당 값을 &lt;code&gt;stdout&lt;/code&gt; 에 인쇄하여 각 인수를 동일한 &lt;a href=&quot;#pdf-tostring&quot;&gt; &lt;code&gt;tostring&lt;/code&gt; &lt;/a&gt; 규칙에 따라 문자열로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="4a03622d8f97ccec5d5f7daa5dac73af6b7c7028" translate="yes" xml:space="preserve">
          <source>Receives any number of arguments and prints their values to &lt;code&gt;stdout&lt;/code&gt;, using the &lt;a href=&quot;#pdf-tostring&quot;&gt;&lt;code&gt;tostring&lt;/code&gt;&lt;/a&gt; function to convert each argument to a string. &lt;code&gt;print&lt;/code&gt; is not intended for formatted output, but only as a quick way to show a value, for instance for debugging. For complete control over the output, use &lt;a href=&quot;#pdf-string.format&quot;&gt;&lt;code&gt;string.format&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#pdf-io.write&quot;&gt;&lt;code&gt;io.write&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#pdf-tostring&quot;&gt; &lt;code&gt;tostring&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 각 인수를 문자열로 변환 하여 원하는 수의 인수를 수신하고 해당 값을 &lt;code&gt;stdout&lt;/code&gt; 에 인쇄 합니다. &lt;code&gt;print&lt;/code&gt; 는 형식화 된 출력을위한 것이 아니라 디버깅과 같이 값을 표시하는 빠른 방법 일뿐입니다. 출력을 완전히 제어하려면 &lt;a href=&quot;#pdf-string.format&quot;&gt; &lt;code&gt;string.format&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#pdf-io.write&quot;&gt; &lt;code&gt;io.write&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="b2cf76b7f314d7be6b1d5b068287552d8871811e" translate="yes" xml:space="preserve">
          <source>Receives zero or more integers, converts each one to its corresponding UTF-8 byte sequence and returns a string with the concatenation of all these sequences.</source>
          <target state="translated">0 개 이상의 정수를 수신하고 각 정수를 해당 UTF-8 바이트 시퀀스로 변환 한 다음이 시퀀스를 모두 연결 한 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cb0dfce9b4c27c4105f7ed0248bef997f2d2f7bb" translate="yes" xml:space="preserve">
          <source>Receives zero or more integers. Returns a string with length equal to the number of arguments, in which each character has the internal numeric code equal to its corresponding argument.</source>
          <target state="translated">0 개 이상의 정수를받습니다. 각 문자가 해당 인수와 동일한 내부 숫자 코드를 갖는 인수 수와 길이가 같은 문자열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="ac1a2088772d8a0274c1a663c003fac03a83bcc4" translate="yes" xml:space="preserve">
          <source>Regardless, if the resulting function has any upvalues, its first upvalue is set to the value of &lt;code&gt;env&lt;/code&gt;, if that parameter is given, or to the value of the global environment. Other upvalues are initialized with &lt;b&gt;nil&lt;/b&gt;. All upvalues are fresh, that is, they are not shared with any other function.</source>
          <target state="translated">어쨌든 결과 함수에 upvalue가있는 경우 첫 번째 upvalue는 해당 매개 변수가 제공되면 &lt;code&gt;env&lt;/code&gt; 값으로 설정 되거나 전역 환경 값으로 설정됩니다. 다른 upvalue는 &lt;b&gt;nil&lt;/b&gt; 로 초기화됩니다 . 모든 업 밸류는 신선합니다. 즉, 다른 기능과 공유되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ba50e88a283776123b7b75fd12714beb6542b84c" translate="yes" xml:space="preserve">
          <source>Registers all functions in the array &lt;code&gt;l&lt;/code&gt; (see &lt;a href=&quot;#luaL_Reg&quot;&gt;&lt;code&gt;luaL_Reg&lt;/code&gt;&lt;/a&gt;) into the table on the top of the stack (below optional upvalues, see next).</source>
          <target state="translated">배열 &lt;code&gt;l&lt;/code&gt; 의 모든 함수 ( &lt;a href=&quot;#luaL_Reg&quot;&gt; &lt;code&gt;luaL_Reg&lt;/code&gt; &lt;/a&gt; 참조 )를 스택 맨 위의 테이블에 등록합니다 ( 선택적 업값 아래, 다음 참조).</target>
        </trans-unit>
        <trans-unit id="354032ada697719ccb58ca87cd221831508c42b3" translate="yes" xml:space="preserve">
          <source>Relational Operators</source>
          <target state="translated">관계 연산자</target>
        </trans-unit>
        <trans-unit id="7d652aafaa213ccec3954206dc0a95e5d151cad3" translate="yes" xml:space="preserve">
          <source>Releases reference &lt;code&gt;ref&lt;/code&gt; from the table at index &lt;code&gt;t&lt;/code&gt; (see &lt;a href=&quot;#luaL_ref&quot;&gt;&lt;code&gt;luaL_ref&lt;/code&gt;&lt;/a&gt;). The entry is removed from the table, so that the referred object can be collected. The reference &lt;code&gt;ref&lt;/code&gt; is also freed to be used again.</source>
          <target state="translated">인덱스 &lt;code&gt;t&lt;/code&gt; 의 테이블에서 참조 &lt;code&gt;ref&lt;/code&gt; 를 해제합니다 ( &lt;a href=&quot;#luaL_ref&quot;&gt; &lt;code&gt;luaL_ref&lt;/code&gt; &lt;/a&gt; 참조 ). 참조 된 오브젝트를 수집 할 수 있도록 테이블에서 항목이 제거됩니다. 참조 &lt;code&gt;ref&lt;/code&gt; 도 다시 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af7c5beadc65cf6aecf24cf7287288561cb7ead7" translate="yes" xml:space="preserve">
          <source>Releases the reference &lt;code&gt;ref&lt;/code&gt; from the table at index &lt;code&gt;t&lt;/code&gt; (see &lt;a href=&quot;#luaL_ref&quot;&gt;&lt;code&gt;luaL_ref&lt;/code&gt;&lt;/a&gt;). The entry is removed from the table, so that the referred object can be collected. The reference &lt;code&gt;ref&lt;/code&gt; is also freed to be used again.</source>
          <target state="translated">인덱스 &lt;code&gt;t&lt;/code&gt; 의 테이블에서 참조 &lt;code&gt;ref&lt;/code&gt; 를 해제합니다 ( &lt;a href=&quot;#luaL_ref&quot;&gt; &lt;code&gt;luaL_ref&lt;/code&gt; &lt;/a&gt; 참조 ). 항목이 테이블에서 제거되어 참조 된 오브젝트를 수집 할 수 있습니다. 참조 &lt;code&gt;ref&lt;/code&gt; 도 다시 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f21ed8cdd38e88c74187592dabfbf9189cec444" translate="yes" xml:space="preserve">
          <source>Remember that, whenever an operation needs the length of a table, all caveats about the length operator apply (see &lt;a href=&quot;#3.4.7&quot;&gt;&amp;sect;3.4.7&lt;/a&gt;). All functions ignore non-numeric keys in the tables given as arguments.</source>
          <target state="translated">작업에 테이블 길이가 필요할 때마다 길이 연산자에 대한 모든 경고가 적용됩니다 ( &lt;a href=&quot;#3.4.7&quot;&gt;&amp;sect;3.4.7&lt;/a&gt; 참조 ). 모든 함수는 인수로 제공된 표에서 숫자가 아닌 키를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="50df2da2a4204c47a50a5f2a2a11c7eea37ba603" translate="yes" xml:space="preserve">
          <source>Removes &lt;code&gt;n&lt;/code&gt; bytes from the the buffer &lt;code&gt;B&lt;/code&gt; (see &lt;a href=&quot;#luaL_Buffer&quot;&gt;&lt;code&gt;luaL_Buffer&lt;/code&gt;&lt;/a&gt;). The buffer must have at least that many bytes.</source>
          <target state="translated">버퍼 &lt;code&gt;B&lt;/code&gt; 에서 &lt;code&gt;n&lt;/code&gt; 바이트를 제거합니다 ( &lt;a href=&quot;#luaL_Buffer&quot;&gt; &lt;code&gt;luaL_Buffer&lt;/code&gt; &lt;/a&gt; 참조 ). 버퍼에는 최소한 그만큼의 바이트가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="d0dd440324a053f93400815574d10e0db636ed3b" translate="yes" xml:space="preserve">
          <source>Removes from &lt;code&gt;list&lt;/code&gt; the element at position &lt;code&gt;pos&lt;/code&gt;, returning the value of the removed element. When &lt;code&gt;pos&lt;/code&gt; is an integer between 1 and &lt;code&gt;#list&lt;/code&gt;, it shifts down the elements &lt;code&gt;list[pos+1], list[pos+2], &amp;middot;&amp;middot;&amp;middot;, list[#list]&lt;/code&gt; and erases element &lt;code&gt;list[#list]&lt;/code&gt;; The index &lt;code&gt;pos&lt;/code&gt; can also be 0 when &lt;code&gt;#list&lt;/code&gt; is 0, or &lt;code&gt;#list + 1&lt;/code&gt;.</source>
          <target state="translated">삭제합니다 &lt;code&gt;list&lt;/code&gt; 위치에있는 요소 &lt;code&gt;pos&lt;/code&gt; 제거 된 요소의 값을 반환한다. 되면 &lt;code&gt;pos&lt;/code&gt; 1의 정수이고 &lt;code&gt;#list&lt;/code&gt; 은 , 상기 이동 요소의 아래 &lt;code&gt;list[pos+1], list[pos+2], &amp;middot;&amp;middot;&amp;middot;, list[#list]&lt;/code&gt; 소자의 소거 &lt;code&gt;list[#list]&lt;/code&gt; ; 인덱스 &lt;code&gt;pos&lt;/code&gt; 는 &lt;code&gt;#list&lt;/code&gt; 가 0 일 때 0이거나 &lt;code&gt;#list + 1&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="78486a859650e2590601f8f6a90106add4cefb81" translate="yes" xml:space="preserve">
          <source>Removes from &lt;code&gt;list&lt;/code&gt; the element at position &lt;code&gt;pos&lt;/code&gt;, returning the value of the removed element. When &lt;code&gt;pos&lt;/code&gt; is an integer between 1 and &lt;code&gt;#list&lt;/code&gt;, it shifts down the elements &lt;code&gt;list[pos+1], list[pos+2], &amp;middot;&amp;middot;&amp;middot;, list[#list]&lt;/code&gt; and erases element &lt;code&gt;list[#list]&lt;/code&gt;; The index &lt;code&gt;pos&lt;/code&gt; can also be 0 when &lt;code&gt;#list&lt;/code&gt; is 0, or &lt;code&gt;#list + 1&lt;/code&gt;; in those cases, the function erases the element &lt;code&gt;list[pos]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pos&lt;/code&gt; 위치의 요소 를 &lt;code&gt;list&lt;/code&gt; 에서 제거하여 제거 된 요소의 값을 리턴합니다. 되면 &lt;code&gt;pos&lt;/code&gt; 1의 정수이고 &lt;code&gt;#list&lt;/code&gt; 은 , 상기 이동 요소의 아래 &lt;code&gt;list[pos+1], list[pos+2], &amp;middot;&amp;middot;&amp;middot;, list[#list]&lt;/code&gt; 소자의 소거 &lt;code&gt;list[#list]&lt;/code&gt; ; &lt;code&gt;#list&lt;/code&gt; 가 0이거나 &lt;code&gt;#list + 1&lt;/code&gt; 경우 인덱스 &lt;code&gt;pos&lt;/code&gt; 는 0 일 수도 있습니다 . 이 경우 함수는 요소 &lt;code&gt;list[pos]&lt;/code&gt; 지 웁니다 .</target>
        </trans-unit>
        <trans-unit id="11e20bb227ba77f3bb86f13b7935abd6f4634200" translate="yes" xml:space="preserve">
          <source>Removes the element at the given valid index, shifting down the elements above this index to fill the gap. This function cannot be called with a pseudo-index, because a pseudo-index is not an actual stack position.</source>
          <target state="translated">주어진 유효한 인덱스에서 요소를 제거하고이 인덱스 위의 요소를 아래로 내려 간격을 채 웁니다. 의사 인덱스는 실제 스택 위치가 아니기 때문에 의사 인덱스로이 함수를 호출 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1d1ad46541c1bc833d763b9872ae152506b03c2a" translate="yes" xml:space="preserve">
          <source>Renames the file or directory named &lt;code&gt;oldname&lt;/code&gt; to &lt;code&gt;newname&lt;/code&gt;. If this function fails, it returns &lt;b&gt;fail&lt;/b&gt;, plus a string describing the error and the error code. Otherwise, it returns true.</source>
          <target state="translated">&lt;code&gt;oldname&lt;/code&gt; 이라는 파일 또는 디렉토리의 이름 을 &lt;code&gt;newname&lt;/code&gt; 으로 변경합니다 . 이 함수가 실패하면 &lt;b&gt;fail&lt;/b&gt; 과 함께 오류와 오류 코드를 설명하는 문자열을 반환 합니다. 그렇지 않으면 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="57bc261321eacee5a6b51aa33ad8b6bdff0d2216" translate="yes" xml:space="preserve">
          <source>Renames the file or directory named &lt;code&gt;oldname&lt;/code&gt; to &lt;code&gt;newname&lt;/code&gt;. If this function fails, it returns &lt;b&gt;nil&lt;/b&gt;, plus a string describing the error and the error code. Otherwise, it returns true.</source>
          <target state="translated">&lt;code&gt;oldname&lt;/code&gt; 이라는 파일 또는 디렉토리의 이름 을 &lt;code&gt;newname&lt;/code&gt; 으로 바꿉니다 . 이 함수가 실패하면 &lt;b&gt;nil&lt;/b&gt; 과 함께 오류 및 오류 코드를 설명하는 문자열 이 반환 됩니다. 그렇지 않으면 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6fa4b690dd13963596a568015e6ef34dfd9eea75" translate="yes" xml:space="preserve">
          <source>Resets a thread, cleaning its call stack and closing all pending to-be-closed variables. Returns a status code: &lt;a href=&quot;#pdf-LUA_OK&quot;&gt;&lt;code&gt;LUA_OK&lt;/code&gt;&lt;/a&gt; for no errors in closing methods, or an error status otherwise. In case of error, leaves the error object on the top of the stack,</source>
          <target state="translated">스레드를 재설정하고, 호출 스택을 정리하고, 보류중인 모든 변수를 닫습니다. 닫는 메소드에 오류가 없으면 &lt;a href=&quot;#pdf-LUA_OK&quot;&gt; &lt;code&gt;LUA_OK&lt;/code&gt; &lt;/a&gt; 상태 코드를 리턴하고 그렇지 않으면 오류 상태를 리턴합니다 . 오류가 발생한 경우 스택 맨 위에 오류 개체를 둡니다.</target>
        </trans-unit>
        <trans-unit id="0ce3bd88cc94ffb61167bb8f7b9e843c7604f13b" translate="yes" xml:space="preserve">
          <source>Results are returned using the &lt;b&gt;return&lt;/b&gt; statement (see &lt;a href=&quot;#3.3.4&quot;&gt;&amp;sect;3.3.4&lt;/a&gt;). If control reaches the end of a function without encountering a &lt;b&gt;return&lt;/b&gt; statement, then the function returns with no results.</source>
          <target state="translated">결과는 &lt;b&gt;return&lt;/b&gt; 문을 사용하여 &lt;b&gt;반환됩니다&lt;/b&gt; ( &lt;a href=&quot;#3.3.4&quot;&gt;&amp;sect;3.3.4&lt;/a&gt; 참조 ). &lt;b&gt;리턴&lt;/b&gt; 문이 발생하지 않고 제어가 함수의 끝에 도달하면 함수는 결과없이 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="244c963cdbd920ed3e3a03fe837b76f265d0a0b8" translate="yes" xml:space="preserve">
          <source>Resurrected objects (that is, objects being finalized and objects accessible only through objects being finalized) have a special behavior in weak tables. They are removed from weak values before running their finalizers, but are removed from weak keys only in the next collection after running their finalizers, when such objects are actually freed. This behavior allows the finalizer to access properties associated with the object through weak tables.</source>
          <target state="translated">부활 된 객체 (즉, 마무리되는 객체 및 마무리되는 객체를 통해서만 액세스 할 수있는 객체)는 약한 테이블에서 특별한 동작을합니다. 종료자를 실행하기 전에 약한 값에서 제거되지만 해당 오브젝트가 실제로 해제되면 종료자를 실행 한 후 다음 콜렉션에서만 약한 키에서 제거됩니다. 이 동작을 통해 종료자는 약한 테이블을 통해 개체와 관련된 속성에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0a2349b7422351122e89416a8339b7ba9df8537" translate="yes" xml:space="preserve">
          <source>Returns &quot;&lt;code&gt;integer&lt;/code&gt;&quot; if &lt;code&gt;x&lt;/code&gt; is an integer, &quot;&lt;code&gt;float&lt;/code&gt;&quot; if it is a float, or &lt;b&gt;fail&lt;/b&gt; if &lt;code&gt;x&lt;/code&gt; is not a number.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 가 &lt;code&gt;integer&lt;/code&gt; 이면 &quot; integer &quot;를 반환 하고, &lt;code&gt;float&lt;/code&gt; 이면 &quot; float &quot;를 반환하고, &lt;code&gt;x&lt;/code&gt; 가 숫자가 아니면 &lt;b&gt;실패&lt;/b&gt; 합니다 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="03118cc39c1e81c1c438cef7d116290590135b5a" translate="yes" xml:space="preserve">
          <source>Returns &quot;&lt;code&gt;integer&lt;/code&gt;&quot; if &lt;code&gt;x&lt;/code&gt; is an integer, &quot;&lt;code&gt;float&lt;/code&gt;&quot; if it is a float, or &lt;b&gt;nil&lt;/b&gt; if &lt;code&gt;x&lt;/code&gt; is not a number.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 가 &lt;code&gt;integer&lt;/code&gt; 이면 &quot; integer &quot; , &lt;code&gt;float&lt;/code&gt; 이면 &quot; float &quot;, &lt;code&gt;x&lt;/code&gt; 가 숫자가 아닌 경우 &lt;b&gt;nil을&lt;/b&gt; 반환 합니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ec136d49176b1dfa086d0b59ff735d87f5d8b25c" translate="yes" xml:space="preserve">
          <source>Returns 1 if the given coroutine can yield, and 0 otherwise.</source>
          <target state="translated">주어진 코 루틴이 산출 할 수 있으면 1을, 그렇지 않으면 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="36a260eb163a20a6982a495d8fcda57196ae377b" translate="yes" xml:space="preserve">
          <source>Returns 1 if the given index is not valid or if the value at this index is &lt;b&gt;nil&lt;/b&gt;, and 0 otherwise.</source>
          <target state="translated">주어진 인덱스가 유효하지 &lt;b&gt;않거나이&lt;/b&gt; 인덱스의 값이 &lt;b&gt;nil&lt;/b&gt; 이면 1을, 그렇지 않으면 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8a03c180e8267d605c7828397144f7c543874d2c" translate="yes" xml:space="preserve">
          <source>Returns 1 if the given index is not valid, and 0 otherwise.</source>
          <target state="translated">주어진 인덱스가 유효하지 않으면 1을, 그렇지 않으면 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8d7984f5b9d91f61d05816274d72ac1e8b987b70" translate="yes" xml:space="preserve">
          <source>Returns 1 if the two values in indices &lt;code&gt;index1&lt;/code&gt; and &lt;code&gt;index2&lt;/code&gt; are primitively equal (that is, equal without calling the &lt;code&gt;__eq&lt;/code&gt; metamethod). Otherwise returns 0. Also returns 0 if any of the indices are not valid.</source>
          <target state="translated">인덱스 &lt;code&gt;index1&lt;/code&gt; 과 &lt;code&gt;index2&lt;/code&gt; 의 두 값 이 &lt;code&gt;__eq&lt;/code&gt; 같으면 (즉, __eq 메타 메서드 를 호출하지 않고 같음) 1을 반환 합니다. 그렇지 않으면 0을 반환합니다. 인덱스가 유효하지 않은 경우에도 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4abb71a0bd2d89035111fe1406578f64ee99f1cd" translate="yes" xml:space="preserve">
          <source>Returns 1 if the two values in indices &lt;code&gt;index1&lt;/code&gt; and &lt;code&gt;index2&lt;/code&gt; are primitively equal (that is, without calling the &lt;code&gt;__eq&lt;/code&gt; metamethod). Otherwise returns 0. Also returns 0 if any of the indices are not valid.</source>
          <target state="translated">인덱스 &lt;code&gt;index1&lt;/code&gt; 과 &lt;code&gt;index2&lt;/code&gt; 의 두 값 이 &lt;code&gt;__eq&lt;/code&gt; 같으면 (즉, __eq 메타 메소드 를 호출하지 않고) 1을 반환 합니다. 그렇지 않으면 0을 반환합니다. 인덱스가 유효하지 않은 경우 0도 반환합니다.</target>
        </trans-unit>
        <trans-unit id="77b6c0faff8f019e54587bee38b27269e8ece2d8" translate="yes" xml:space="preserve">
          <source>Returns 1 if the value at the given index is &lt;b&gt;nil&lt;/b&gt;, and 0 otherwise.</source>
          <target state="translated">주어진 인덱스의 값이 &lt;b&gt;nil&lt;/b&gt; 이면 1을, 그렇지 않으면 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="acad229e61c0f7b3cf84876f85fd1aed4340fdeb" translate="yes" xml:space="preserve">
          <source>Returns 1 if the value at the given index is a C function, and 0 otherwise.</source>
          <target state="translated">주어진 인덱스의 값이 C 함수이면 1을, 그렇지 않으면 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c6d1286ca58fd2bca52facd7ccf6f424aa47dca4" translate="yes" xml:space="preserve">
          <source>Returns 1 if the value at the given index is a boolean, and 0 otherwise.</source>
          <target state="translated">지정된 인덱스의 값이 부울 인 경우 1을, 그렇지 않으면 0을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="04d4d0a8fc1e9ff9c642f37982cd6541f074eaf2" translate="yes" xml:space="preserve">
          <source>Returns 1 if the value at the given index is a function (either C or Lua), and 0 otherwise.</source>
          <target state="translated">주어진 인덱스의 값이 함수 (C 또는 Lua)이면 1을, 그렇지 않으면 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="85c97cef398c89971e6d5d95362f5833c0efeb94" translate="yes" xml:space="preserve">
          <source>Returns 1 if the value at the given index is a light userdata, and 0 otherwise.</source>
          <target state="translated">주어진 인덱스의 값이 일반 사용자 데이터이면 1을, 그렇지 않으면 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="293be583246b5c6f5755824ebef65496d84be9b9" translate="yes" xml:space="preserve">
          <source>Returns 1 if the value at the given index is a number or a string convertible to a number, and 0 otherwise.</source>
          <target state="translated">지정된 인덱스의 값이 숫자 또는 숫자로 변환 가능한 문자열이면 1을, 그렇지 않으면 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1ef629a2e4c4bd109da15d0096305f549d521e11" translate="yes" xml:space="preserve">
          <source>Returns 1 if the value at the given index is a string or a number (which is always convertible to a string), and 0 otherwise.</source>
          <target state="translated">지정된 인덱스의 값이 문자열 또는 숫자 (항상 문자열로 변환 가능)이면 1을 반환하고 그렇지 않으면 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b24b734f996f24f0d2edcb352efb5d0a8733d485" translate="yes" xml:space="preserve">
          <source>Returns 1 if the value at the given index is a table, and 0 otherwise.</source>
          <target state="translated">주어진 인덱스의 값이 테이블이면 1을, 그렇지 않으면 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6452edfae9b54954154513a55afe95f60e75b4fa" translate="yes" xml:space="preserve">
          <source>Returns 1 if the value at the given index is a thread, and 0 otherwise.</source>
          <target state="translated">주어진 인덱스의 값이 스레드이면 1을, 그렇지 않으면 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fbf8a110fe7143ca6d907ca070a5c03ffa0f2050" translate="yes" xml:space="preserve">
          <source>Returns 1 if the value at the given index is a userdata (either full or light), and 0 otherwise.</source>
          <target state="translated">지정된 인덱스의 값이 사용자 데이터 (전체 또는 라이트)이면 1을, 그렇지 않으면 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="83893644ee4437282f1a7daf1d6a53c7e83643da" translate="yes" xml:space="preserve">
          <source>Returns 1 if the value at the given index is an integer (that is, the value is a number and is represented as an integer), and 0 otherwise.</source>
          <target state="translated">주어진 인덱스의 값이 정수이면 (즉, 값은 숫자이고 정수로 표시됨) 1을, 그렇지 않으면 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="671cca4567b26fcc0ceb0e43e3d2829f1469cdbb" translate="yes" xml:space="preserve">
          <source>Returns &lt;b&gt;fail&lt;/b&gt; if there is no active hook.</source>
          <target state="translated">활성 후크가 없으면 반환이 &lt;b&gt;실패&lt;/b&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="e0d04eca2996cc50939c173c775d0d5f069d8627" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;NULL&lt;/code&gt; (and pops nothing) when the index &lt;code&gt;n&lt;/code&gt; is greater than the number of upvalues.</source>
          <target state="translated">인덱스 &lt;code&gt;n&lt;/code&gt; 이 업 값 수보다 크면 &lt;code&gt;NULL&lt;/code&gt; 을 반환 하고 아무것도 표시하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f56ddb3bc18ad7e4888cfe9050da5f11bd833971" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;NULL&lt;/code&gt; (and pops nothing) when the index is greater than the number of active local variables.</source>
          <target state="translated">색인이 활성 로컬 변수의 수보다 크면 &lt;code&gt;NULL&lt;/code&gt; 을 리턴 하고 아무것도 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="57d7205f6585ea512d11e87992ca7441e1e7627e" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;NULL&lt;/code&gt; (and pushes nothing) when the index is greater than the number of active local variables.</source>
          <target state="translated">색인이 활성 로컬 변수의 수보다 크면 &lt;code&gt;NULL&lt;/code&gt; 을 리턴 하고 아무것도 푸시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="33a341b65f8f92cdfebf70c0c2e075fb9c61bdea" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;udata&lt;/code&gt;, or &lt;b&gt;fail&lt;/b&gt; if the userdata does not have that value.</source>
          <target state="translated">&lt;code&gt;udata&lt;/code&gt; 를 반환 하거나 사용자 데이터에 해당 값이 없으면 &lt;b&gt;실패&lt;/b&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="cfcdfcdeac01eab8c7e33e91fd9027aed705b576" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;udata&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;udata&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="95b61d5c1d6df056ea18d8531706d5088a5cc2ec" translate="yes" xml:space="preserve">
          <source>Returns a binary string containing the values &lt;code&gt;v1&lt;/code&gt;, &lt;code&gt;v2&lt;/code&gt;, etc. packed (that is, serialized in binary form) according to the format string &lt;code&gt;fmt&lt;/code&gt; (see &lt;a href=&quot;#6.4.2&quot;&gt;&amp;sect;6.4.2&lt;/a&gt;).</source>
          <target state="translated">형식 문자열 &lt;code&gt;fmt&lt;/code&gt; ( &lt;a href=&quot;#6.4.2&quot;&gt;&amp;sect;6.4.2&lt;/a&gt; 참조 )에 따라 압축 된 (즉, 이진 형식으로 직렬화 된) 값 &lt;code&gt;v1&lt;/code&gt; , &lt;code&gt;v2&lt;/code&gt; 등을 포함하는 이진 문자열을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b9eaabee84b326fc38aa7a158662184bb8db15f9" translate="yes" xml:space="preserve">
          <source>Returns a binary string containing the values &lt;code&gt;v1&lt;/code&gt;, &lt;code&gt;v2&lt;/code&gt;, etc. serialized in binary form (packed) according to the format string &lt;code&gt;fmt&lt;/code&gt; (see &lt;a href=&quot;#6.4.2&quot;&gt;&amp;sect;6.4.2&lt;/a&gt;).</source>
          <target state="translated">형식 문자열 &lt;code&gt;fmt&lt;/code&gt; ( &lt;a href=&quot;#6.4.2&quot;&gt;&amp;sect;6.4.2&lt;/a&gt; 참조 )에 따라 이진 형식 (포장 됨)으로 직렬화 된 &lt;code&gt;v1&lt;/code&gt; , &lt;code&gt;v2&lt;/code&gt; 등 의 값을 포함하는 이진 문자열을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="34fa3ab9c6fcc7c0b0e41c857bf1c60b601f5344" translate="yes" xml:space="preserve">
          <source>Returns a boolean, true if and only if integer &lt;code&gt;m&lt;/code&gt; is below integer &lt;code&gt;n&lt;/code&gt; when they are compared as unsigned integers.</source>
          <target state="translated">부호없는 정수로 비교 될 때 정수 &lt;code&gt;m&lt;/code&gt; 이 정수 &lt;code&gt;n&lt;/code&gt; 미만인 경우에만 부울을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="83c4b62eb52291289917793f1a6cc1b8ea7a62cf" translate="yes" xml:space="preserve">
          <source>Returns a copy of &lt;code&gt;s&lt;/code&gt; in which all (or the first &lt;code&gt;n&lt;/code&gt;, if given) occurrences of the &lt;code&gt;pattern&lt;/code&gt; (see &lt;a href=&quot;#6.4.1&quot;&gt;&amp;sect;6.4.1&lt;/a&gt;) have been replaced by a replacement string specified by &lt;code&gt;repl&lt;/code&gt;, which can be a string, a table, or a function. &lt;code&gt;gsub&lt;/code&gt; also returns, as its second value, the total number of matches that occurred. The name &lt;code&gt;gsub&lt;/code&gt; comes from &lt;em&gt;Global SUBstitution&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;pattern&lt;/code&gt; ( &lt;a href=&quot;#6.4.1&quot;&gt;&amp;sect;6.4.1&lt;/a&gt; 참조 ) 의 모든 (또는 주어진 경우 &lt;code&gt;n&lt;/code&gt; )이 &lt;code&gt;repl&lt;/code&gt; 에 의해 지정된 대체 문자열로 대체 된 &lt;code&gt;s&lt;/code&gt; 사본을 리턴합니다 . 이는 문자열, 테이블 또는 a가 될 수 있습니다. 함수. 또한 &lt;code&gt;gsub&lt;/code&gt; 는 발생한 총 일치 수를 두 번째 값으로 반환합니다. &lt;code&gt;gsub&lt;/code&gt; 라는 이름 은 &lt;em&gt;Global SUBstitution&lt;/em&gt; 에서 유래 &lt;em&gt;했습니다&lt;/em&gt; .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2ddd8b557487a7047dc27604858d100902c9eec4" translate="yes" xml:space="preserve">
          <source>Returns a formatted version of its variable number of arguments following the description given in its first argument (which must be a string). The format string follows the same rules as the ISO C function &lt;code&gt;sprintf&lt;/code&gt;. The only differences are that the options/modifiers &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;h&lt;/code&gt;, &lt;code&gt;L&lt;/code&gt;, &lt;code&gt;l&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt;, and &lt;code&gt;p&lt;/code&gt; are not supported and that there is an extra option, &lt;code&gt;q&lt;/code&gt;.</source>
          <target state="translated">첫 번째 인수 (문자열이어야 함)에 제공된 설명에 따라 가변 개수의 인수의 형식화 된 버전을 리턴합니다. 형식 문자열은 ISO C 함수 &lt;code&gt;sprintf&lt;/code&gt; 와 동일한 규칙을 따릅니다 . 유일한 차이점은 옵션 / 수정 자 &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;h&lt;/code&gt; , &lt;code&gt;L&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , &lt;code&gt;n&lt;/code&gt; 및 &lt;code&gt;p&lt;/code&gt; 가 지원되지 않으며 추가 옵션 &lt;code&gt;q&lt;/code&gt; 가 있다는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="bf32d68131adf8c84f92b82d86f22e200e2d442a" translate="yes" xml:space="preserve">
          <source>Returns a formatted version of its variable number of arguments following the description given in its first argument, which must be a string. The format string follows the same rules as the ISO C function &lt;code&gt;sprintf&lt;/code&gt;. The only differences are that the conversion specifiers and modifiers &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;h&lt;/code&gt;, &lt;code&gt;L&lt;/code&gt;, &lt;code&gt;l&lt;/code&gt;, and &lt;code&gt;n&lt;/code&gt; are not supported and that there is an extra specifier, &lt;code&gt;q&lt;/code&gt;.</source>
          <target state="translated">문자열이어야하는 첫 번째 인수에 제공된 설명에 따라 가변 인수의 형식화 된 버전을 리턴합니다. 형식 문자열은 ISO C 함수 &lt;code&gt;sprintf&lt;/code&gt; 와 동일한 규칙을 따릅니다 . 유일한 차이점은 변환 지정자 및 수정 자 &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;h&lt;/code&gt; , &lt;code&gt;L&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; 및 &lt;code&gt;n&lt;/code&gt; 이 지원되지 않고 추가 지정자 &lt;code&gt;q&lt;/code&gt; 가 있다는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="48dde3bd411386a559edd6defab289be69c364ab" translate="yes" xml:space="preserve">
          <source>Returns a new table with all arguments stored into keys 1, 2, etc. and with a field &quot;&lt;code&gt;n&lt;/code&gt;&quot; with the total number of arguments. Note that the resulting table may not be a sequence, if some arguments are &lt;b&gt;nil&lt;/b&gt;.</source>
          <target state="translated">모든 인수가 키 1, 2 등에 저장되고 총 인수 수가있는 &quot; &lt;code&gt;n&lt;/code&gt; &quot; 필드가있는 새 테이블을 반환합니다 . 일부 인수가 &lt;b&gt;nil&lt;/b&gt; 인 경우 결과 테이블은 시퀀스가 ​​아닐 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4e8f9acfbbc61db53d975814a02f1c9aab94a23d" translate="yes" xml:space="preserve">
          <source>Returns a new table with all parameters stored into keys 1, 2, etc. and with a field &quot;&lt;code&gt;n&lt;/code&gt;&quot; with the total number of parameters. Note that the resulting table may not be a sequence.</source>
          <target state="translated">키 1, 2 등에 모든 매개 변수가 저장되고 총 매개 변수 수와 함께 &quot; &lt;code&gt;n&lt;/code&gt; &quot; 필드가있는 새 테이블을 리턴합니다 . 결과 테이블은 시퀀스가 ​​아닐 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04445fdc39272b542d188c106147fa8b6a611119" translate="yes" xml:space="preserve">
          <source>Returns a pointer to a raw memory area associated with the given Lua state. The application can use this area for any purpose; Lua does not use it for anything.</source>
          <target state="translated">주어진 Lua 상태와 관련된 원시 메모리 영역에 대한 포인터를 반환합니다. 응용 프로그램은이 영역을 모든 목적으로 사용할 수 있습니다. 루아는 아무것도 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="45395b391aa23f00e9e4439bd741094c423c0b46" translate="yes" xml:space="preserve">
          <source>Returns a pointer to the internal copy of the string (see &lt;a href=&quot;#4.1.3&quot;&gt;&amp;sect;4.1.3&lt;/a&gt;).</source>
          <target state="translated">문자열의 내부 복사본에 대한 포인터를 반환합니다 ( &lt;a href=&quot;#4.1.3&quot;&gt;&amp;sect;4.1.3&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="4f4330812b83811a6da51b5ddf77a1c753b5a3f8" translate="yes" xml:space="preserve">
          <source>Returns a pointer to the internal copy of the string.</source>
          <target state="translated">문자열의 내부 사본에 대한 포인터를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="110bc8230211fc8ab3a4f90c96eb53b6ace38d6f" translate="yes" xml:space="preserve">
          <source>Returns a string containing a binary representation (a &lt;em&gt;binary chunk&lt;/em&gt;) of the given function, so that a later &lt;a href=&quot;#pdf-load&quot;&gt;&lt;code&gt;load&lt;/code&gt;&lt;/a&gt; on this string returns a copy of the function (but with new upvalues). If &lt;code&gt;strip&lt;/code&gt; is a true value, the binary representation may not include all debug information about the function, to save space.</source>
          <target state="translated">주어진 함수 의 이진 표현 ( &lt;em&gt;이진 청크&lt;/em&gt; )을 포함하는 문자열을 반환하여이 문자열에 대한 나중에 &lt;a href=&quot;#pdf-load&quot;&gt; &lt;code&gt;load&lt;/code&gt; &lt;/a&gt; 가 함수의 복사본을 반환하지만 새로운 값은 새로 반환합니다. &lt;code&gt;strip&lt;/code&gt; 이 true 값인 경우 공간을 절약하기 위해 이진 표현에 함수에 대한 모든 디버그 정보가 포함되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7785dcf0d96ed76232f8ceff4782113f5d891ebc" translate="yes" xml:space="preserve">
          <source>Returns a string or a table containing date and time, formatted according to the given string &lt;code&gt;format&lt;/code&gt;.</source>
          <target state="translated">주어진 문자열 &lt;code&gt;format&lt;/code&gt; 에 따라 형식이 지정된 날짜와 시간이 포함 된 문자열 또는 테이블을 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="e96b629efb1e60f437ca5030afcaedd1ef526018" translate="yes" xml:space="preserve">
          <source>Returns a string that is the concatenation of &lt;code&gt;n&lt;/code&gt; copies of the string &lt;code&gt;s&lt;/code&gt; separated by the string &lt;code&gt;sep&lt;/code&gt;. The default value for &lt;code&gt;sep&lt;/code&gt; is the empty string (that is, no separator). Returns the empty string if &lt;code&gt;n&lt;/code&gt; is not positive.</source>
          <target state="translated">문자열 &lt;code&gt;sep&lt;/code&gt; 로 구분 된 문자열 &lt;code&gt;s&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; 복사본이 연결된 문자열을 반환합니다 . &lt;code&gt;sep&lt;/code&gt; 의 기본값 은 빈 문자열입니다 (즉, 구분 기호 없음). &lt;code&gt;n&lt;/code&gt; 이 양수가 아닌 경우 빈 문자열을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c23b06e9809db45e6323880c87aa7252a0bafcb4" translate="yes" xml:space="preserve">
          <source>Returns a string that is the string &lt;code&gt;s&lt;/code&gt; reversed.</source>
          <target state="translated">반환 문자열 문자열 &lt;code&gt;s&lt;/code&gt; 반전이.</target>
        </trans-unit>
        <trans-unit id="fc7ced1cf6bbd4c86f0ee87b0d833bbb93586b07" translate="yes" xml:space="preserve">
          <source>Returns a string with a file name that can be used for a temporary file. The file must be explicitly opened before its use and explicitly removed when no longer needed.</source>
          <target state="translated">임시 파일에 사용할 수있는 파일 이름을 가진 문자열을 반환합니다. 파일은 사용하기 전에 명시 적으로 열어야하고 더 이상 필요하지 않으면 명시 적으로 제거해야합니다.</target>
        </trans-unit>
        <trans-unit id="aa92524d06f459f4bfe53bf566701137d5986c99" translate="yes" xml:space="preserve">
          <source>Returns a table with information about a function. You can give the function directly or you can give a number as the value of &lt;code&gt;f&lt;/code&gt;, which means the function running at level &lt;code&gt;f&lt;/code&gt; of the call stack of the given thread: level 0 is the current function (&lt;code&gt;getinfo&lt;/code&gt; itself); level 1 is the function that called &lt;code&gt;getinfo&lt;/code&gt; (except for tail calls, which do not count in the stack); and so on. If &lt;code&gt;f&lt;/code&gt; is a number greater than the number of active functions, then &lt;code&gt;getinfo&lt;/code&gt; returns &lt;b&gt;fail&lt;/b&gt;.</source>
          <target state="translated">함수에 대한 정보가있는 테이블을 반환합니다. 함수를 직접 제공하거나 &lt;code&gt;f&lt;/code&gt; 의 값으로 숫자를 제공 할 수 있습니다 . 이는 주어진 스레드의 호출 스택의 레벨 &lt;code&gt;f&lt;/code&gt; 에서 실행되는 함수를 의미합니다 . 레벨 0은 현재 함수입니다 ( &lt;code&gt;getinfo&lt;/code&gt; 자체); 레벨 1은 &lt;code&gt;getinfo&lt;/code&gt; 를 호출 한 함수입니다 (스택에서 계산되지 않는 테일 호출 제외). 등등. 경우 &lt;code&gt;f&lt;/code&gt; 는 액티브 기능의 수보다 클 수 후 &lt;code&gt;getinfo&lt;/code&gt; 반환 &lt;b&gt;하지&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="41736de9eba1b5a23348a72c73555dbf11b75db2" translate="yes" xml:space="preserve">
          <source>Returns a table with information about a function. You can give the function directly or you can give a number as the value of &lt;code&gt;f&lt;/code&gt;, which means the function running at level &lt;code&gt;f&lt;/code&gt; of the call stack of the given thread: level 0 is the current function (&lt;code&gt;getinfo&lt;/code&gt; itself); level 1 is the function that called &lt;code&gt;getinfo&lt;/code&gt; (except for tail calls, which do not count on the stack); and so on. If &lt;code&gt;f&lt;/code&gt; is a number larger than the number of active functions, then &lt;code&gt;getinfo&lt;/code&gt; returns &lt;b&gt;nil&lt;/b&gt;.</source>
          <target state="translated">함수에 대한 정보가있는 테이블을 반환합니다. 함수를 직접 제공하거나 &lt;code&gt;f&lt;/code&gt; 값으로 숫자를 지정할 수 있습니다 . 이는 주어진 스레드의 호출 스택의 &lt;code&gt;f&lt;/code&gt; 레벨에서 실행되는 함수를 의미합니다 . level 0은 현재 함수입니다 ( &lt;code&gt;getinfo&lt;/code&gt; 자체). 레벨 1은 &lt;code&gt;getinfo&lt;/code&gt; (테일 호출을 제외하고 스택에 포함되지 않음) 라는 함수입니다 . 등등. 경우 &lt;code&gt;f&lt;/code&gt; 는 액티브 기능의 수보다 큰 수이고, 다음 &lt;code&gt;getinfo&lt;/code&gt; 반환 &lt;b&gt;nil을&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="10b30ad1ae8da522aed09e1a02ace7921e1f51a6" translate="yes" xml:space="preserve">
          <source>Returns a unique identifier (as a light userdata) for the upvalue numbered &lt;code&gt;n&lt;/code&gt; from the given function.</source>
          <target state="translated">주어진 함수에서 &lt;code&gt;n&lt;/code&gt; 으로 번호가 매겨진 upvalue에 대한 고유 식별자 (가벼운 사용자 데이터)를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="0b3fe57552c933213408135c6244c0db831931eb" translate="yes" xml:space="preserve">
          <source>Returns a unique identifier for the upvalue numbered &lt;code&gt;n&lt;/code&gt; from the closure at index &lt;code&gt;funcindex&lt;/code&gt;.</source>
          <target state="translated">인덱스 &lt;code&gt;funcindex&lt;/code&gt; 의 클로저에서 최대 값 &lt;code&gt;n&lt;/code&gt; 의 고유 식별자를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="bee587bfd0df43f919edb6f2e537b30c2fff9e47" translate="yes" xml:space="preserve">
          <source>Returns an address to a space of size &lt;code&gt;sz&lt;/code&gt; where you can copy a string to be added to buffer &lt;code&gt;B&lt;/code&gt; (see &lt;a href=&quot;#luaL_Buffer&quot;&gt;&lt;code&gt;luaL_Buffer&lt;/code&gt;&lt;/a&gt;). After copying the string into this space you must call &lt;a href=&quot;#luaL_addsize&quot;&gt;&lt;code&gt;luaL_addsize&lt;/code&gt;&lt;/a&gt; with the size of the string to actually add it to the buffer.</source>
          <target state="translated">버퍼 &lt;code&gt;B&lt;/code&gt; 에 추가 할 문자열을 복사 할 수있는 &lt;code&gt;sz&lt;/code&gt; 크기의 공간으로 주소를 리턴합니다 ( &lt;a href=&quot;#luaL_Buffer&quot;&gt; &lt;code&gt;luaL_Buffer&lt;/code&gt; &lt;/a&gt; 참조 ). 문자열을이 공간에 복사 한 후 문자열 크기로 &lt;a href=&quot;#luaL_addsize&quot;&gt; &lt;code&gt;luaL_addsize&lt;/code&gt; &lt;/a&gt; 를 호출 하여 실제로 버퍼에 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="aee809e239d975376124c38ef9a8bbd38533ebb2" translate="yes" xml:space="preserve">
          <source>Returns an approximation of the amount in seconds of CPU time used by the program, as returned by the underlying ISO C function &lt;code&gt;clock&lt;/code&gt;.</source>
          <target state="translated">기본 ISO C 함수 &lt;code&gt;clock&lt;/code&gt; 에서 반환 된대로 프로그램에서 사용하는 CPU 시간의 근사치를 초 단위로 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="791d30f65759aca9bc8c2ab0c81b3414394fb75d" translate="yes" xml:space="preserve">
          <source>Returns an approximation of the amount in seconds of CPU time used by the program.</source>
          <target state="translated">프로그램에서 사용한 CPU 시간 (초)의 근사값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="ed3bd9acca66b3345ff64ecf82770701deaf6e39" translate="yes" xml:space="preserve">
          <source>Returns an iterator function that, each time it is called, reads the file according to the given formats. When no format is given, uses &quot;&lt;code&gt;l&lt;/code&gt;&quot; as a default. As an example, the construction</source>
          <target state="translated">호출 될 때마다 주어진 형식에 따라 파일을 읽는 반복자 함수를 리턴합니다. 형식이 지정되지 않으면 &quot; &lt;code&gt;l&lt;/code&gt; &quot;을 기본값으로 사용하십시오. 예를 들어, 건설</target>
        </trans-unit>
        <trans-unit id="9502ef377c9031927e39c05f93ef446921a0becd" translate="yes" xml:space="preserve">
          <source>Returns an iterator function that, each time it is called, returns the next captures from &lt;code&gt;pattern&lt;/code&gt; (see &lt;a href=&quot;#6.4.1&quot;&gt;&amp;sect;6.4.1&lt;/a&gt;) over the string &lt;code&gt;s&lt;/code&gt;. If &lt;code&gt;pattern&lt;/code&gt; specifies no captures, then the whole match is produced in each call.</source>
          <target state="translated">호출 될 때마다 문자열 &lt;code&gt;s&lt;/code&gt; 에 대해 &lt;code&gt;pattern&lt;/code&gt; ( &lt;a href=&quot;#6.4.1&quot;&gt;&amp;sect;6.4.1&lt;/a&gt; 참조 ) 에서 다음 캡처를 리턴하는 반복자 함수를 리턴합니다 . &lt;code&gt;pattern&lt;/code&gt; 이 캡처를 지정하지 않으면 각 호출에서 전체 일치가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="45001f49f50b2b70b2e8422ff32e20831e96980c" translate="yes" xml:space="preserve">
          <source>Returns an iterator function that, each time it is called, returns the next captures from &lt;code&gt;pattern&lt;/code&gt; (see &lt;a href=&quot;#6.4.1&quot;&gt;&amp;sect;6.4.1&lt;/a&gt;) over the string &lt;code&gt;s&lt;/code&gt;. If &lt;code&gt;pattern&lt;/code&gt; specifies no captures, then the whole match is produced in each call. A third, optional numeric argument &lt;code&gt;init&lt;/code&gt; specifies where to start the search; its default value is 1 and can be negative.</source>
          <target state="translated">호출 될 때마다 문자열 &lt;code&gt;s&lt;/code&gt; 에 대해 &lt;code&gt;pattern&lt;/code&gt; ( &lt;a href=&quot;#6.4.1&quot;&gt;&amp;sect;6.4.1&lt;/a&gt; 참조 ) 에서 다음 캡처를 반환하는 반복기 함수를 반환합니다 . &lt;code&gt;pattern&lt;/code&gt; 이 캡처를 지정하지 않으면 각 호출에서 전체 일치가 생성됩니다. 세 번째, 선택적 숫자 인수 &lt;code&gt;init&lt;/code&gt; 는 검색을 시작할 위치를 지정합니다. 기본값은 1이며 음수 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6d0a5b7853c9d4da9293e66e82d86cf0df6305f" translate="yes" xml:space="preserve">
          <source>Returns the &quot;length&quot; of the value at the given index as a number; it is equivalent to the '&lt;code&gt;#&lt;/code&gt;' operator in Lua (see &lt;a href=&quot;#3.4.7&quot;&gt;&amp;sect;3.4.7&lt;/a&gt;). Raises an error if the result of the operation is not an integer. (This case can only happen through metamethods.)</source>
          <target state="translated">주어진 인덱스에있는 값의 &quot;길이&quot;를 숫자로 반환합니다. Lua 의 ' &lt;code&gt;#&lt;/code&gt; '연산자 와 동일합니다 ( &lt;a href=&quot;#3.4.7&quot;&gt;&amp;sect;3.4.7&lt;/a&gt; 참조 ). 연산 결과가 정수가 아닌 경우 오류를 발생시킵니다. (이 경우는 메타 메소드를 통해서만 발생할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="ea5fe629e50500647001f1530cb02685325af73a" translate="yes" xml:space="preserve">
          <source>Returns the &quot;length&quot; of the value at the given index as a number; it is equivalent to the '&lt;code&gt;#&lt;/code&gt;' operator in Lua (see &lt;a href=&quot;#3.4.7&quot;&gt;&amp;sect;3.4.7&lt;/a&gt;). Raises an error if the result of the operation is not an integer. (This case only can happen through metamethods.)</source>
          <target state="translated">주어진 인덱스에서 값의 &quot;길이&quot;를 숫자로 반환합니다. Lua 의 ' &lt;code&gt;#&lt;/code&gt; '연산자 와 같습니다 ( &lt;a href=&quot;#3.4.7&quot;&gt;&amp;sect;3.4.7&lt;/a&gt; 참조 ). 연산 결과가 정수가 아닌 경우 오류가 발생합니다. (이 경우는 메타 메소드를 통해서만 발생할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="f1e0f7037fc97a264b1135ee9cbbd443e4839b55" translate="yes" xml:space="preserve">
          <source>Returns the &lt;code&gt;n&lt;/code&gt;-th user value associated to the userdata &lt;code&gt;u&lt;/code&gt; plus a boolean, &lt;b&gt;false&lt;/b&gt; if the userdata does not have that value.</source>
          <target state="translated">사용자 데이터 &lt;code&gt;u&lt;/code&gt; 에 부울을 더한 &lt;code&gt;n&lt;/code&gt; 번째 사용자 값을 반환하고, 사용자 데이터에 해당 값이 없으면 &lt;b&gt;false를&lt;/b&gt; 반환합니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="db78771d6acbed28111d58cf748f20e4959f1e52" translate="yes" xml:space="preserve">
          <source>Returns the Lua value associated to &lt;code&gt;u&lt;/code&gt;. If &lt;code&gt;u&lt;/code&gt; is not a full userdata, returns &lt;b&gt;nil&lt;/b&gt;.</source>
          <target state="translated">&lt;code&gt;u&lt;/code&gt; 와 관련된 Lua 값을 반환합니다 . &lt;code&gt;u&lt;/code&gt; 가 전체 사용자 데이터가 아닌 경우 &lt;b&gt;nil을&lt;/b&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="d1851a04bfd13cc05cd523998c36bdc322db17e1" translate="yes" xml:space="preserve">
          <source>Returns the absolute value of &lt;code&gt;x&lt;/code&gt;. (integer/float)</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 절대 값을 반환합니다 . (정수 / 부동)</target>
        </trans-unit>
        <trans-unit id="043e0287b11b1a9c8f88357339923c8234440ef7" translate="yes" xml:space="preserve">
          <source>Returns the address of the current content of buffer &lt;code&gt;B&lt;/code&gt; (see &lt;a href=&quot;#luaL_Buffer&quot;&gt;&lt;code&gt;luaL_Buffer&lt;/code&gt;&lt;/a&gt;). Note that any addition to the buffer may invalidate this address.</source>
          <target state="translated">버퍼 &lt;code&gt;B&lt;/code&gt; 의 현재 내용 주소를 반환합니다 ( &lt;a href=&quot;#luaL_Buffer&quot;&gt; &lt;code&gt;luaL_Buffer&lt;/code&gt; &lt;/a&gt; 참조 ). 버퍼에 추가하면이 주소가 무효화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19e9a2e3f9c2da4b70e14502d18cc907361074e9" translate="yes" xml:space="preserve">
          <source>Returns the address of the version number (a C static variable) stored in the Lua core. When called with a valid &lt;a href=&quot;#lua_State&quot;&gt;&lt;code&gt;lua_State&lt;/code&gt;&lt;/a&gt;, returns the address of the version used to create that state. When called with &lt;code&gt;NULL&lt;/code&gt;, returns the address of the version running the call.</source>
          <target state="translated">Lua 코어에 저장된 버전 번호 (C 정적 변수)의 주소를 반환합니다. 유효한 &lt;a href=&quot;#lua_State&quot;&gt; &lt;code&gt;lua_State&lt;/code&gt; 로&lt;/a&gt; 호출하면 해당 상태를 만드는 데 사용 된 버전의 주소를 반환합니다. &lt;code&gt;NULL&lt;/code&gt; 로 호출하면 호출을 실행하는 버전의 주소를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d492dc5dd4aa5f92735d2073fff7474e1a6b394e" translate="yes" xml:space="preserve">
          <source>Returns the arc cosine of &lt;code&gt;x&lt;/code&gt; (in radians).</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 아크 코사인 (라디안)을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="f089a8dff08d67188de1f7c5039f149b9fa4a377" translate="yes" xml:space="preserve">
          <source>Returns the arc sine of &lt;code&gt;x&lt;/code&gt; (in radians).</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 아크 사인을 라디안 단위로 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="fa1247ba15c62e976046573c6ccc1feeee2f5b6b" translate="yes" xml:space="preserve">
          <source>Returns the arc tangent of &lt;code&gt;y/x&lt;/code&gt; (in radians), but uses the signs of both arguments to find the quadrant of the result. It also handles correctly the case of &lt;code&gt;x&lt;/code&gt; being zero.</source>
          <target state="translated">&lt;code&gt;y/x&lt;/code&gt; 의 아크 탄젠트 (라디안)를 반환 하지만 두 인수의 부호를 사용하여 결과의 ​​사분면을 찾습니다. 또한 &lt;code&gt;x&lt;/code&gt; 가 0 인 경우를 올바르게 처리합니다 .</target>
        </trans-unit>
        <trans-unit id="94a36782eb1a80f58363dabc61ceebcb41f258d2" translate="yes" xml:space="preserve">
          <source>Returns the arc tangent of &lt;code&gt;y/x&lt;/code&gt; (in radians), but uses the signs of both parameters to find the quadrant of the result. (It also handles correctly the case of &lt;code&gt;x&lt;/code&gt; being zero.)</source>
          <target state="translated">&lt;code&gt;y/x&lt;/code&gt; 의 아크 탄젠트 (라디안)를 반환 하지만 두 매개 변수의 부호를 사용하여 결과의 ​​사분면을 찾습니다. ( &lt;code&gt;x&lt;/code&gt; 가 0 인 경우도 올바르게 처리합니다 .)</target>
        </trans-unit>
        <trans-unit id="54bafb79a60778cdf93eb8dffe6dc26866068180" translate="yes" xml:space="preserve">
          <source>Returns the argument with the maximum value, according to the Lua operator &lt;code&gt;&amp;lt;&lt;/code&gt;.</source>
          <target state="translated">Lua 연산자 &lt;code&gt;&amp;lt;&lt;/code&gt; 에 따라 최대 값을 가진 인수를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="de4793305a62a7e062a99c696537172768770061" translate="yes" xml:space="preserve">
          <source>Returns the argument with the maximum value, according to the Lua operator &lt;code&gt;&amp;lt;&lt;/code&gt;. (integer/float)</source>
          <target state="translated">Lua 연산자 &lt;code&gt;&amp;lt;&lt;/code&gt; 에 따라 최대 값으로 인수를 반환합니다 . (정수 / 부동)</target>
        </trans-unit>
        <trans-unit id="d704759b0150aa7e291bb40d3b9e1aa860586ad0" translate="yes" xml:space="preserve">
          <source>Returns the argument with the minimum value, according to the Lua operator &lt;code&gt;&amp;lt;&lt;/code&gt;.</source>
          <target state="translated">Lua 연산자 &lt;code&gt;&amp;lt;&lt;/code&gt; 에 따라 최소값이있는 인수를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="23b18e62742fdde277f18684dd6adb5af258b562" translate="yes" xml:space="preserve">
          <source>Returns the argument with the minimum value, according to the Lua operator &lt;code&gt;&amp;lt;&lt;/code&gt;. (integer/float)</source>
          <target state="translated">Lua 연산자 &lt;code&gt;&amp;lt;&lt;/code&gt; 에 따라 최소값으로 인수를 반환합니다 . (정수 / 부동)</target>
        </trans-unit>
        <trans-unit id="e0191dad2cae73c27ef7de25f92860dda78cff8d" translate="yes" xml:space="preserve">
          <source>Returns the code points (as integers) from all characters in &lt;code&gt;s&lt;/code&gt; that start between byte position &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; (both included). The default for &lt;code&gt;i&lt;/code&gt; is 1 and for &lt;code&gt;j&lt;/code&gt; is &lt;code&gt;i&lt;/code&gt;. It raises an error if it meets any invalid byte sequence.</source>
          <target state="translated">바이트 위치 &lt;code&gt;i&lt;/code&gt; 와 &lt;code&gt;j&lt;/code&gt; (둘 다 포함됨) 사이 에서 시작 하는 &lt;code&gt;s&lt;/code&gt; 의 모든 문자에서 코드 포인트 (정수)를 반환합니다 . &lt;code&gt;i&lt;/code&gt; 의 기본값 은 1이고 &lt;code&gt;j&lt;/code&gt; 의 기본값 은 &lt;code&gt;i&lt;/code&gt; 입니다. 잘못된 바이트 시퀀스를 충족하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="008974cf3ea7a0e47cc66825ae9db754a6215ba2" translate="yes" xml:space="preserve">
          <source>Returns the codepoints (as integers) from all characters in &lt;code&gt;s&lt;/code&gt; that start between byte position &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; (both included). The default for &lt;code&gt;i&lt;/code&gt; is 1 and for &lt;code&gt;j&lt;/code&gt; is &lt;code&gt;i&lt;/code&gt;. It raises an error if it meets any invalid byte sequence.</source>
          <target state="translated">바이트 위치 &lt;code&gt;i&lt;/code&gt; 와 &lt;code&gt;j&lt;/code&gt; (포함) 사이 에서 시작 하는 &lt;code&gt;s&lt;/code&gt; 의 모든 문자에서 코드 포인트 (정수)를 반환합니다 . &lt;code&gt;i&lt;/code&gt; 의 기본값 은 1이고 &lt;code&gt;j&lt;/code&gt; 의 기본값 은 &lt;code&gt;i&lt;/code&gt; 입니다. 유효하지 않은 바이트 시퀀스를 만족하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4e9e95635ca72435ec1e4654b329133fcb9b67b6" translate="yes" xml:space="preserve">
          <source>Returns the cosine of &lt;code&gt;x&lt;/code&gt; (assumed to be in radians).</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 코사인을 반환합니다 (라디안으로 가정).</target>
        </trans-unit>
        <trans-unit id="d63943c503fbdbc9daf70eb8b368eb63c603cce5" translate="yes" xml:space="preserve">
          <source>Returns the current hook count.</source>
          <target state="translated">현재 후크 수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="91adc8b466cf6e5462daa3cdcd2555a890c15635" translate="yes" xml:space="preserve">
          <source>Returns the current hook function.</source>
          <target state="translated">현재 후크 함수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="77c0c811e0708693f332c243247f1f4509702b82" translate="yes" xml:space="preserve">
          <source>Returns the current hook mask.</source>
          <target state="translated">현재 후크 마스크를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dfa58fd57235ee80a6d63769d911723e3534cac8" translate="yes" xml:space="preserve">
          <source>Returns the current hook settings of the thread, as three values: the current hook function, the current hook mask, and the current hook count (as set by the &lt;a href=&quot;#pdf-debug.sethook&quot;&gt;&lt;code&gt;debug.sethook&lt;/code&gt;&lt;/a&gt; function).</source>
          <target state="translated">스레드의 현재 후크 설정을 현재 후크 함수, 현재 후크 마스크 및 현재 후크 수 ( &lt;a href=&quot;#pdf-debug.sethook&quot;&gt; &lt;code&gt;debug.sethook&lt;/code&gt; &lt;/a&gt; 함수에 의해 설정 됨)의 세 가지 값으로 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="732a0eb24511cdffe2ee8db1f2a63d0d03797e0b" translate="yes" xml:space="preserve">
          <source>Returns the current hook settings of the thread, as three values: the current hook function, the current hook mask, and the current hook count, as set by the &lt;a href=&quot;#pdf-debug.sethook&quot;&gt;&lt;code&gt;debug.sethook&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">스레드의 현재 후크 설정을 &lt;a href=&quot;#pdf-debug.sethook&quot;&gt; &lt;code&gt;debug.sethook&lt;/code&gt; &lt;/a&gt; 함수에 의해 설정된대로 현재 후크 함수, 현재 후크 마스크 및 현재 후크 수의 세 가지 값으로 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="a4984b9b007c5eee4f424cfbc9e8ac599f7bc3b2" translate="yes" xml:space="preserve">
          <source>Returns the current time when called without arguments, or a time representing the local date and time specified by the given table. This table must have fields &lt;code&gt;year&lt;/code&gt;, &lt;code&gt;month&lt;/code&gt;, and &lt;code&gt;day&lt;/code&gt;, and may have fields &lt;code&gt;hour&lt;/code&gt; (default is 12), &lt;code&gt;min&lt;/code&gt; (default is 0), &lt;code&gt;sec&lt;/code&gt; (default is 0), and &lt;code&gt;isdst&lt;/code&gt; (default is &lt;b&gt;nil&lt;/b&gt;). Other fields are ignored. For a description of these fields, see the &lt;a href=&quot;#pdf-os.date&quot;&gt;&lt;code&gt;os.date&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">인수없이 호출 된 현재 시간 또는 제공된 테이블에 지정된 현지 날짜 및 시간을 나타내는 시간을 반환합니다. 이 테이블에는 &lt;code&gt;year&lt;/code&gt; , &lt;code&gt;month&lt;/code&gt; 및 &lt;code&gt;day&lt;/code&gt; 필드가 있어야하며 &lt;code&gt;hour&lt;/code&gt; (기본값은 12), &lt;code&gt;min&lt;/code&gt; (기본값은 0), &lt;code&gt;sec&lt;/code&gt; (기본값은 0) 및 &lt;code&gt;isdst&lt;/code&gt; (기본값은 &lt;b&gt;nil&lt;/b&gt; ) 필드가있을 수 있습니다. 다른 필드는 무시됩니다. 이 필드에 대한 설명은 &lt;a href=&quot;#pdf-os.date&quot;&gt; &lt;code&gt;os.date&lt;/code&gt; &lt;/a&gt; 함수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1b56d9d3e264bf539db578bb8f6317e05525f18e" translate="yes" xml:space="preserve">
          <source>Returns the destination table &lt;code&gt;a2&lt;/code&gt;.</source>
          <target state="translated">대상 테이블 &lt;code&gt;a2&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4a89ca3dbaee05fa9562365bbb11bd2987b8b36f" translate="yes" xml:space="preserve">
          <source>Returns the difference, in seconds, from time &lt;code&gt;t1&lt;/code&gt; to time &lt;code&gt;t2&lt;/code&gt; (where the times are values returned by &lt;a href=&quot;#pdf-os.time&quot;&gt;&lt;code&gt;os.time&lt;/code&gt;&lt;/a&gt;). In POSIX, Windows, and some other systems, this value is exactly &lt;code&gt;t2&lt;/code&gt;&lt;em&gt;-&lt;/em&gt;&lt;code&gt;t1&lt;/code&gt;.</source>
          <target state="translated">시간 &lt;code&gt;t1&lt;/code&gt; 에서 시간 &lt;code&gt;t2&lt;/code&gt; 까지의 차이 (초)를 리턴합니다 (여기서 시간은 &lt;a href=&quot;#pdf-os.time&quot;&gt; &lt;code&gt;os.time&lt;/code&gt; 에서&lt;/a&gt; 리턴 한 값임 ). POSIX, Windows 및 일부 다른 시스템에서이 값은 정확히 &lt;code&gt;t2&lt;/code&gt; &lt;em&gt;- &lt;/em&gt; &lt;code&gt;t1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="74ef8f0d43907d8993cbf07845e98c64309c4c57" translate="yes" xml:space="preserve">
          <source>Returns the elements from the given list. This function is equivalent to</source>
          <target state="translated">주어진 목록에서 요소를 반환합니다. 이 기능은</target>
        </trans-unit>
        <trans-unit id="a0ecb44d1768c16defe86a7226eb7cdb677c4d76" translate="yes" xml:space="preserve">
          <source>Returns the index of the top element in the stack. Because indices start at 1, this result is equal to the number of elements in the stack; in particular, 0 means an empty stack.</source>
          <target state="translated">스택에서 최상위 요소의 인덱스를 반환합니다. 인덱스는 1에서 시작하기 때문에이 결과는 스택의 요소 수와 같습니다. 특히 0은 빈 스택을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="aae1a98a2afe7e2f6164ed56d98f2c5601c177ce" translate="yes" xml:space="preserve">
          <source>Returns the integral part of &lt;code&gt;x&lt;/code&gt; and the fractional part of &lt;code&gt;x&lt;/code&gt;. Its second result is always a float.</source>
          <target state="translated">반환의 중요한 부분 &lt;code&gt;x&lt;/code&gt; 와의 소수 부분 &lt;code&gt;x&lt;/code&gt; . 두 번째 결과는 항상 부동입니다.</target>
        </trans-unit>
        <trans-unit id="d07d66699f96edb0b840ccb7b505ca206ea713f8" translate="yes" xml:space="preserve">
          <source>Returns the internal numeric codes of the characters &lt;code&gt;s[i]&lt;/code&gt;, &lt;code&gt;s[i+1]&lt;/code&gt;, ..., &lt;code&gt;s[j]&lt;/code&gt;. The default value for &lt;code&gt;i&lt;/code&gt; is 1; the default value for &lt;code&gt;j&lt;/code&gt; is &lt;code&gt;i&lt;/code&gt;. These indices are corrected following the same rules of function &lt;a href=&quot;#pdf-string.sub&quot;&gt;&lt;code&gt;string.sub&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">문자 &lt;code&gt;s[i]&lt;/code&gt; , &lt;code&gt;s[i+1]&lt;/code&gt; , ..., &lt;code&gt;s[j]&lt;/code&gt; 의 내부 숫자 코드를 리턴합니다 . &lt;code&gt;i&lt;/code&gt; 의 기본값 은 1입니다. &lt;code&gt;j&lt;/code&gt; 의 기본값 은 &lt;code&gt;i&lt;/code&gt; 입니다. 이 색인은 &lt;a href=&quot;#pdf-string.sub&quot;&gt; &lt;code&gt;string.sub&lt;/code&gt; &lt;/a&gt; 함수의 동일한 규칙에 따라 수정 됩니다.</target>
        </trans-unit>
        <trans-unit id="b30312394bff808c7607188052990ddfc3f0af18" translate="yes" xml:space="preserve">
          <source>Returns the largest integral value less than or equal to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 보다 작거나 같은 가장 큰 정수 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="37a74944cfaba1cf96089aa04c3aab36bd768194" translate="yes" xml:space="preserve">
          <source>Returns the largest integral value smaller than or equal to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 보다 작거나 같은 가장 큰 정수 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="6b65eebb8bdbd39036e0d29924f25daa397f311e" translate="yes" xml:space="preserve">
          <source>Returns the length of the current content of buffer &lt;code&gt;B&lt;/code&gt; (see &lt;a href=&quot;#luaL_Buffer&quot;&gt;&lt;code&gt;luaL_Buffer&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">버퍼 &lt;code&gt;B&lt;/code&gt; 의 현재 내용 길이를 반환합니다 ( &lt;a href=&quot;#luaL_Buffer&quot;&gt; &lt;code&gt;luaL_Buffer&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="a82986faba63c6df7b4a7e1f2c3e8675bebec131" translate="yes" xml:space="preserve">
          <source>Returns the length of the object &lt;code&gt;v&lt;/code&gt;, which must be a table or a string, without invoking the &lt;code&gt;__len&lt;/code&gt; metamethod. Returns an integer.</source>
          <target state="translated">&lt;code&gt;__len&lt;/code&gt; 메타 메소드 를 호출하지 않고 테이블 &lt;code&gt;v&lt;/code&gt; 또는 문자열이어야 하는 오브젝트 v 의 길이를 리턴합니다 . 정수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4d195539511c55ff9d09810f9cb9cabd46d5d2c6" translate="yes" xml:space="preserve">
          <source>Returns the length of the value at the given index. It is equivalent to the '&lt;code&gt;#&lt;/code&gt;' operator in Lua (see &lt;a href=&quot;#3.4.7&quot;&gt;&amp;sect;3.4.7&lt;/a&gt;) and may trigger a metamethod for the &quot;length&quot; event (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;). The result is pushed on the stack.</source>
          <target state="translated">주어진 인덱스에서 값의 길이를 반환합니다. 이는 Lua 의 ' &lt;code&gt;#&lt;/code&gt; '연산자 와 동일하며 ( &lt;a href=&quot;#3.4.7&quot;&gt;&amp;sect;3.4.7&lt;/a&gt; 참조 ) &quot;길이&quot;이벤트에 대한 메타 메소드를 트리거 할 수 있습니다 ( &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt; 참조 ). 결과는 스택에 푸시됩니다.</target>
        </trans-unit>
        <trans-unit id="ca18490544ebe4ab9d2b88782ccfa4bfa597d5c6" translate="yes" xml:space="preserve">
          <source>Returns the logarithm of &lt;code&gt;x&lt;/code&gt; in the given base. The default for &lt;code&gt;base&lt;/code&gt; is &lt;em&gt;e&lt;/em&gt; (so that the function returns the natural logarithm of &lt;code&gt;x&lt;/code&gt;).</source>
          <target state="translated">주어진 밑에서 &lt;code&gt;x&lt;/code&gt; 의 로그를 반환합니다 . &lt;code&gt;base&lt;/code&gt; 의 기본값 은 &lt;em&gt;e입니다&lt;/em&gt; (따라서 함수는 &lt;code&gt;x&lt;/code&gt; 의 자연 로그를 리턴합니다 ).</target>
        </trans-unit>
        <trans-unit id="d77d922681562ed53526ab1cca990af72395285d" translate="yes" xml:space="preserve">
          <source>Returns the maximum value between &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;-x&lt;/code&gt;. (integer/float)</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;-x&lt;/code&gt; 사이의 최대 값을 반환합니다 . (정수 / 부동 소수점)</target>
        </trans-unit>
        <trans-unit id="d3cb57918cd0fd4016648ae402c7074bcd73a43b" translate="yes" xml:space="preserve">
          <source>Returns the memory-allocation function of a given state. If &lt;code&gt;ud&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, Lua stores in &lt;code&gt;*ud&lt;/code&gt; the opaque pointer given when the memory-allocator function was set.</source>
          <target state="translated">주어진 상태의 메모리 할당 함수를 반환합니다. &lt;code&gt;ud&lt;/code&gt; 가 &lt;code&gt;NULL&lt;/code&gt; 이 아닌 경우 , Lua는 메모리 할당 기 기능을 설정할 때 제공된 불투명 포인터 를 &lt;code&gt;*ud&lt;/code&gt; 에 저장 합니다.</target>
        </trans-unit>
        <trans-unit id="274b26f09340089c109b77fcaa34ab85c7b27be3" translate="yes" xml:space="preserve">
          <source>Returns the metatable of the given &lt;code&gt;value&lt;/code&gt; or &lt;b&gt;nil&lt;/b&gt; if it does not have a metatable.</source>
          <target state="translated">반환 주어진의 메타 테이블 &lt;code&gt;value&lt;/code&gt; 또는 &lt;b&gt;전무&lt;/b&gt; 그것은 메타 테이블이없는 경우.</target>
        </trans-unit>
        <trans-unit id="f827b993d336f39e4e067ba1cd00ca433786753f" translate="yes" xml:space="preserve">
          <source>Returns the name of the type encoded by the value &lt;code&gt;tp&lt;/code&gt;, which must be one the values returned by &lt;a href=&quot;#lua_type&quot;&gt;&lt;code&gt;lua_type&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">값 &lt;code&gt;tp&lt;/code&gt; 로 인코딩 된 유형의 이름을 리턴합니다 . 이는 &lt;a href=&quot;#lua_type&quot;&gt; &lt;code&gt;lua_type&lt;/code&gt; 이&lt;/a&gt; 리턴 한 값 중 하나 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="b5d2c5467f6b31c133d151a482f437390192631a" translate="yes" xml:space="preserve">
          <source>Returns the name of the type of the value at the given index.</source>
          <target state="translated">주어진 색인에서 값의 유형 이름을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="09f17fbeecb99d8ceed703c8e378ebf644bfa53e" translate="yes" xml:space="preserve">
          <source>Returns the new state, or &lt;code&gt;NULL&lt;/code&gt; if there is a memory allocation error.</source>
          <target state="translated">새 상태를 반환하거나 메모리 할당 오류가 있으면 &lt;code&gt;NULL&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="d43b7f45fadd64b442bc6cb030aac62b5fed9b46" translate="yes" xml:space="preserve">
          <source>Returns the number of UTF-8 characters in string &lt;code&gt;s&lt;/code&gt; that start between positions &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; (both inclusive). The default for &lt;code&gt;i&lt;/code&gt; is 1 and for &lt;code&gt;j&lt;/code&gt; is -1. If it finds any invalid byte sequence, returns &lt;b&gt;fail&lt;/b&gt; plus the position of the first invalid byte.</source>
          <target state="translated">위치 &lt;code&gt;i&lt;/code&gt; 와 &lt;code&gt;j&lt;/code&gt; (둘 다 포함) 사이에서 시작하는 string &lt;code&gt;s&lt;/code&gt; 의 UTF-8 문자 수를 반환합니다 . &lt;code&gt;i&lt;/code&gt; 의 기본값 은 1이고 &lt;code&gt;j&lt;/code&gt; 의 기본값 은 -1입니다. 유효하지 않은 바이트 시퀀스를 찾으면 &lt;b&gt;실패&lt;/b&gt; 와 첫 번째 유효하지 않은 바이트의 위치를 반환합니다 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1fac8d97901da4fcfa21c51273c8ade3e30d4960" translate="yes" xml:space="preserve">
          <source>Returns the number of UTF-8 characters in string &lt;code&gt;s&lt;/code&gt; that start between positions &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; (both inclusive). The default for &lt;code&gt;i&lt;/code&gt; is 1 and for &lt;code&gt;j&lt;/code&gt; is -1. If it finds any invalid byte sequence, returns a false value plus the position of the first invalid byte.</source>
          <target state="translated">위치 &lt;code&gt;i&lt;/code&gt; 와 &lt;code&gt;j&lt;/code&gt; 사이에서 시작하는 문자열 &lt;code&gt;s&lt;/code&gt; 의 UTF-8 문자 수 (둘 다 포함)를 리턴합니다 . &lt;code&gt;i&lt;/code&gt; 의 기본값 은 1이고 &lt;code&gt;j&lt;/code&gt; 의 경우 -1입니다. 유효하지 않은 바이트 시퀀스를 찾으면 잘못된 값과 첫 번째 유효하지 않은 바이트의 위치를 ​​더한 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="84f83acaebe526961dfec0323624b3e5b62c9fd0" translate="yes" xml:space="preserve">
          <source>Returns the position (in bytes) where the encoding of the &lt;code&gt;n&lt;/code&gt;-th character of &lt;code&gt;s&lt;/code&gt; (counting from position &lt;code&gt;i&lt;/code&gt;) starts. A negative &lt;code&gt;n&lt;/code&gt; gets characters before position &lt;code&gt;i&lt;/code&gt;. The default for &lt;code&gt;i&lt;/code&gt; is 1 when &lt;code&gt;n&lt;/code&gt; is non-negative and &lt;code&gt;#s + 1&lt;/code&gt; otherwise, so that &lt;code&gt;utf8.offset(s, -n)&lt;/code&gt; gets the offset of the &lt;code&gt;n&lt;/code&gt;-th character from the end of the string. If the specified character is neither in the subject nor right after its end, the function returns &lt;b&gt;fail&lt;/b&gt;.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 의 &lt;code&gt;n&lt;/code&gt; 번째 문자 (위치 &lt;code&gt;i&lt;/code&gt; 부터 계산 )의 인코딩이 시작되는 위치 (바이트)를 반환 합니다. 음수 &lt;code&gt;n&lt;/code&gt; 은 위치 &lt;code&gt;i&lt;/code&gt; 앞에 문자를 가져 옵니다 . &lt;code&gt;n&lt;/code&gt; 이 음수가 아닌 경우 &lt;code&gt;i&lt;/code&gt; 의 기본값 은 1 이고 그렇지 않으면 &lt;code&gt;#s + 1&lt;/code&gt; 이므로 &lt;code&gt;utf8.offset(s, -n)&lt;/code&gt; 은 문자열 끝에서 &lt;code&gt;n&lt;/code&gt; 번째 문자 의 오프셋을 가져옵니다 . 지정된 문자가 제목에 없거나 끝 바로 뒤에 없으면 함수는 &lt;b&gt;fail을&lt;/b&gt; 반환합니다 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="56c4cc904851482307ead3085d1ccd1030454da6" translate="yes" xml:space="preserve">
          <source>Returns the position (in bytes) where the encoding of the &lt;code&gt;n&lt;/code&gt;-th character of &lt;code&gt;s&lt;/code&gt; (counting from position &lt;code&gt;i&lt;/code&gt;) starts. A negative &lt;code&gt;n&lt;/code&gt; gets characters before position &lt;code&gt;i&lt;/code&gt;. The default for &lt;code&gt;i&lt;/code&gt; is 1 when &lt;code&gt;n&lt;/code&gt; is non-negative and &lt;code&gt;#s + 1&lt;/code&gt; otherwise, so that &lt;code&gt;utf8.offset(s, -n)&lt;/code&gt; gets the offset of the &lt;code&gt;n&lt;/code&gt;-th character from the end of the string. If the specified character is neither in the subject nor right after its end, the function returns &lt;b&gt;nil&lt;/b&gt;.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 의 &lt;code&gt;n&lt;/code&gt; 번째 문자 인코딩 (위치 &lt;code&gt;i&lt;/code&gt; 에서 계산 )이 시작 되는 위치 (바이트)를 리턴 합니다. 음수 &lt;code&gt;n&lt;/code&gt; 은 위치 &lt;code&gt;i&lt;/code&gt; 앞에 문자를 가져 옵니다 . &lt;code&gt;n&lt;/code&gt; 이 음이 아닌 경우 &lt;code&gt;i&lt;/code&gt; 의 기본값 은 1 이고 , 그렇지 않으면 &lt;code&gt;#s + 1&lt;/code&gt; 이므로 &lt;code&gt;utf8.offset(s, -n)&lt;/code&gt; 은 문자열 끝에서 &lt;code&gt;n&lt;/code&gt; 번째 문자 의 오프셋을 가져옵니다 . 지정된 문자가 주제에 없거나 종료 직후에 없으면 함수는 &lt;b&gt;nil을&lt;/b&gt; 리턴합니다 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1e3fa00427da0e5f4dcde3c242518db402bf818a" translate="yes" xml:space="preserve">
          <source>Returns the pseudo-index that represents the &lt;code&gt;i&lt;/code&gt;-th upvalue of the running function (see &lt;a href=&quot;#4.2&quot;&gt;&amp;sect;4.2&lt;/a&gt;). &lt;code&gt;i&lt;/code&gt; must be in the range &lt;em&gt;[1,256]&lt;/em&gt;.</source>
          <target state="translated">실행중인 함수 의 &lt;code&gt;i&lt;/code&gt; 번째 upvalue 를 나타내는 의사 인덱스를 반환합니다 ( &lt;a href=&quot;#4.2&quot;&gt;&amp;sect;4.2&lt;/a&gt; 참조 ). &lt;code&gt;i&lt;/code&gt; 는 &lt;em&gt;[1,256]&lt;/em&gt; 범위에 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="bc45c511f20e727c297897c4a412e04b9bb492de" translate="yes" xml:space="preserve">
          <source>Returns the pseudo-index that represents the &lt;code&gt;i&lt;/code&gt;-th upvalue of the running function (see &lt;a href=&quot;#4.4&quot;&gt;&amp;sect;4.4&lt;/a&gt;).</source>
          <target state="translated">실행중인 함수 의 &lt;code&gt;i&lt;/code&gt; 번째 업 값 을 나타내는 의사 인덱스를 반환합니다 ( &lt;a href=&quot;#4.4&quot;&gt;&amp;sect;4.4&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="33f56655c8e98bdcbd9254da5f1e14cc5e047720" translate="yes" xml:space="preserve">
          <source>Returns the raw &quot;length&quot; of the value at the given index: for strings, this is the string length; for tables, this is the result of the length operator ('&lt;code&gt;#&lt;/code&gt;') with no metamethods; for userdata, this is the size of the block of memory allocated for the userdata. For other values, this call returns 0.</source>
          <target state="translated">주어진 인덱스에서 값의 원시 &quot;길이&quot;를 리턴합니다. 문자열의 경우 이것은 문자열 길이입니다. 테이블의 경우 이는 메타 메서드가없는 길이 연산자 ( ' &lt;code&gt;#&lt;/code&gt; ') 의 결과입니다 . userdata의 경우 사용자 데이터에 할당 된 메모리 블록의 크기입니다. 다른 값의 경우이 호출은 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="39d8bb977f9b8a6f1742fd3f9dc45db22e1fcb68" translate="yes" xml:space="preserve">
          <source>Returns the raw &quot;length&quot; of the value at the given index: for strings, this is the string length; for tables, this is the result of the length operator ('&lt;code&gt;#&lt;/code&gt;') with no metamethods; for userdata, this is the size of the block of memory allocated for the userdata; for other values, it is 0.</source>
          <target state="translated">주어진 색인에서 값의 원시 &quot;길이&quot;를 반환합니다. 문자열의 경우 문자열 길이입니다. 테이블의 경우 이것은 메타 메소드가없는 길이 연산자 ( ' &lt;code&gt;#&lt;/code&gt; ') 의 결과입니다 . 사용자 데이터의 경우, 이는 사용자 데이터에 할당 된 메모리 블록의 크기입니다. 다른 값의 경우 0입니다.</target>
        </trans-unit>
        <trans-unit id="94fe4847ff4993fa7c4fb27d617dd7c02c05a931" translate="yes" xml:space="preserve">
          <source>Returns the registry table (see &lt;a href=&quot;#4.3&quot;&gt;&amp;sect;4.3&lt;/a&gt;).</source>
          <target state="translated">레지스트리 테이블을 반환합니다 ( &lt;a href=&quot;#4.3&quot;&gt;&amp;sect;4.3&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="a4878c08432faeac78e45f44f0026ebddb8749ef" translate="yes" xml:space="preserve">
          <source>Returns the registry table (see &lt;a href=&quot;#4.5&quot;&gt;&amp;sect;4.5&lt;/a&gt;).</source>
          <target state="translated">레지스트리 테이블을 반환합니다 ( &lt;a href=&quot;#4.5&quot;&gt;&amp;sect;4.5&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="1f182d1d0910847b92e9f446a7345b1cf7e93ffa" translate="yes" xml:space="preserve">
          <source>Returns the remainder of the division of &lt;code&gt;x&lt;/code&gt; by &lt;code&gt;y&lt;/code&gt; that rounds the quotient towards zero. (integer/float)</source>
          <target state="translated">몫을 0으로 반올림하여 &lt;code&gt;x&lt;/code&gt; 를 &lt;code&gt;y&lt;/code&gt; 로 나눈 나머지를 반환합니다 . (정수 / 부동)</target>
        </trans-unit>
        <trans-unit id="568e6f5ede477aed12d9d477add4ad442b3fde9c" translate="yes" xml:space="preserve">
          <source>Returns the resulting name of the first file that it can open in read mode (after closing the file), or &lt;b&gt;fail&lt;/b&gt; plus an error message if none succeeds. (This error message lists all file names it tried to open.)</source>
          <target state="translated">읽기 모드 (파일을 닫은 후)로 열 수있는 첫 번째 파일의 결과 이름을 반환하거나, 성공 &lt;b&gt;하지 못한&lt;/b&gt; 경우 &lt;b&gt;실패&lt;/b&gt; 와 오류 메시지를 반환합니다. (이 오류 메시지는 열려고 시도한 모든 파일 이름을 나열합니다.)</target>
        </trans-unit>
        <trans-unit id="7d00adfd429e9ecb79de1d7e05907584e1f561cc" translate="yes" xml:space="preserve">
          <source>Returns the resulting name of the first file that it can open in read mode (after closing the file), or &lt;b&gt;nil&lt;/b&gt; plus an error message if none succeeds. (This error message lists all file names it tried to open.)</source>
          <target state="translated">파일을 읽은 후 읽기 모드에서 열 수있는 첫 번째 파일의 결과 이름을 반환하거나 성공하지 못한 경우 &lt;b&gt;nil&lt;/b&gt; 과 오류 메시지를 반환합니다. 이 오류 메시지는 열려고하는 모든 파일 이름을 나열합니다.</target>
        </trans-unit>
        <trans-unit id="0cafeada936b9b3c536bfda3d7c114159746bc82" translate="yes" xml:space="preserve">
          <source>Returns the running coroutine plus a boolean, true when the running coroutine is the main one.</source>
          <target state="translated">실행중인 코 루틴과 부울 값을 반환합니다. 실행중인 코 루틴이 기본 항목 인 경우 true입니다.</target>
        </trans-unit>
        <trans-unit id="f520f4734dbc499082a5c134aebb7e5257b19210" translate="yes" xml:space="preserve">
          <source>Returns the sine of &lt;code&gt;x&lt;/code&gt; (assumed to be in radians).</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 사인을 반환합니다 (라디안으로 가정).</target>
        </trans-unit>
        <trans-unit id="da558ef5afc0fc9c0d21911a38e825ff24dcf0a2" translate="yes" xml:space="preserve">
          <source>Returns the size of a string resulting from &lt;a href=&quot;#pdf-string.pack&quot;&gt;&lt;code&gt;string.pack&lt;/code&gt;&lt;/a&gt; with the given format. The format string cannot have the variable-length options '&lt;code&gt;s&lt;/code&gt;' or '&lt;code&gt;z&lt;/code&gt;' (see &lt;a href=&quot;#6.4.2&quot;&gt;&amp;sect;6.4.2&lt;/a&gt;).</source>
          <target state="translated">주어진 형식으로 &lt;a href=&quot;#pdf-string.pack&quot;&gt; &lt;code&gt;string.pack&lt;/code&gt; &lt;/a&gt; 에서 나오는 문자열의 크기를 반환 합니다. 형식 문자열은 가변 길이 옵션 ' &lt;code&gt;s&lt;/code&gt; '또는 ' &lt;code&gt;z&lt;/code&gt; '를 가질 수 없습니다 ( &lt;a href=&quot;#6.4.2&quot;&gt;&amp;sect;6.4.2&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="8a271ccad0d5f1305d18e3f34055196791089e29" translate="yes" xml:space="preserve">
          <source>Returns the smallest integral value greater than or equal to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 보다 크거나 같은 최소 정수 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="33b392e0c4352ffea2f8586f23e071e85ca1ffec" translate="yes" xml:space="preserve">
          <source>Returns the smallest integral value larger than or equal to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 보다 크거나 같은 가장 작은 정수 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="a156517157e4cb0343c49c32e737cf3b8fa30ca3" translate="yes" xml:space="preserve">
          <source>Returns the square root of &lt;code&gt;x&lt;/code&gt;. (You can also use the expression &lt;code&gt;x^0.5&lt;/code&gt; to compute this value.)</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 제곱근을 반환합니다 . &lt;code&gt;x^0.5&lt;/code&gt; 표현식 을 사용하여이 값을 계산할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="92c7a785497146b5964e3cfcb16d7bf24c7763b5" translate="yes" xml:space="preserve">
          <source>Returns the status of coroutine &lt;code&gt;co&lt;/code&gt;, as a string: &lt;code&gt;&quot;running&quot;&lt;/code&gt;, if the coroutine is running (that is, it called &lt;code&gt;status&lt;/code&gt;); &lt;code&gt;&quot;suspended&quot;&lt;/code&gt;, if the coroutine is suspended in a call to &lt;code&gt;yield&lt;/code&gt;, or if it has not started running yet; &lt;code&gt;&quot;normal&quot;&lt;/code&gt; if the coroutine is active but not running (that is, it has resumed another coroutine); and &lt;code&gt;&quot;dead&quot;&lt;/code&gt; if the coroutine has finished its body function, or if it has stopped with an error.</source>
          <target state="translated">코 루틴 &lt;code&gt;co&lt;/code&gt; 의 상태를 문자열로 리턴합니다 . 코 루틴이 실행중인 경우 (즉, &lt;code&gt;status&lt;/code&gt; 라고 함 ) &lt;code&gt;&quot;running&quot;&lt;/code&gt; . &lt;code&gt;&quot;suspended&quot;&lt;/code&gt; ( 코 루틴이 &lt;code&gt;yield&lt;/code&gt; 호출에 일시 중단 되었거나 아직 실행을 시작하지 않은 경우) 코 루틴이 활성이지만 실행 중이 아닌 경우 (즉, 다른 코 루틴을 재개 한 경우) &lt;code&gt;&quot;normal&quot;&lt;/code&gt; ; 그리고 &lt;code&gt;&quot;dead&quot;&lt;/code&gt; 코 루틴은 신체 기능을 완료 한 경우, 또는이 오류와 함께 중지합니다.</target>
        </trans-unit>
        <trans-unit id="ae60fb59b3fcc2ee3f16755978255651eb156610" translate="yes" xml:space="preserve">
          <source>Returns the status of the coroutine &lt;code&gt;co&lt;/code&gt;, as a string: &lt;code&gt;&quot;running&quot;&lt;/code&gt;, if the coroutine is running (that is, it is the one that called &lt;code&gt;status&lt;/code&gt;); &lt;code&gt;&quot;suspended&quot;&lt;/code&gt;, if the coroutine is suspended in a call to &lt;code&gt;yield&lt;/code&gt;, or if it has not started running yet; &lt;code&gt;&quot;normal&quot;&lt;/code&gt; if the coroutine is active but not running (that is, it has resumed another coroutine); and &lt;code&gt;&quot;dead&quot;&lt;/code&gt; if the coroutine has finished its body function, or if it has stopped with an error.</source>
          <target state="translated">코 루틴 &lt;code&gt;co&lt;/code&gt; 의 상태를 문자열로 반환합니다 . &lt;code&gt;&quot;running&quot;&lt;/code&gt; , 코 루틴이 실행 중이면 (즉, &lt;code&gt;status&lt;/code&gt; 를 호출 한 것입니다 ); &lt;code&gt;&quot;suspended&quot;&lt;/code&gt; , &lt;code&gt;yield&lt;/code&gt; 호출에서 코 루틴이 일시 중단 되었거나 아직 실행을 시작하지 않은 경우; 코 루틴이 활성 상태이지만 실행 중이 아닌 경우 (즉, 다른 코 루틴을 재개 한 경우) &lt;code&gt;&quot;normal&quot;&lt;/code&gt; . 그리고 &lt;code&gt;&quot;dead&quot;&lt;/code&gt; 코 루틴은 신체 기능을 완료 한 경우, 또는이 오류와 함께 중지합니다.</target>
        </trans-unit>
        <trans-unit id="6643f34f054d2169fc15059330c9797cabe4b0f8" translate="yes" xml:space="preserve">
          <source>Returns the status of the thread &lt;code&gt;L&lt;/code&gt;.</source>
          <target state="translated">스레드 &lt;code&gt;L&lt;/code&gt; 의 상태를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="ce13df23b5d839e4a1b3c62a7a51b8e7083872ff" translate="yes" xml:space="preserve">
          <source>Returns the substring of &lt;code&gt;s&lt;/code&gt; that starts at &lt;code&gt;i&lt;/code&gt; and continues until &lt;code&gt;j&lt;/code&gt;; &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; can be negative. If &lt;code&gt;j&lt;/code&gt; is absent, then it is assumed to be equal to -1 (which is the same as the string length). In particular, the call &lt;code&gt;string.sub(s,1,j)&lt;/code&gt; returns a prefix of &lt;code&gt;s&lt;/code&gt; with length &lt;code&gt;j&lt;/code&gt;, and &lt;code&gt;string.sub(s, -i)&lt;/code&gt; (for a positive &lt;code&gt;i&lt;/code&gt;) returns a suffix of &lt;code&gt;s&lt;/code&gt; with length &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; 에서 시작하여 &lt;code&gt;j&lt;/code&gt; 까지 계속되는 &lt;code&gt;s&lt;/code&gt; 의 하위 문자열을 반환합니다 . &lt;code&gt;i&lt;/code&gt; 와 &lt;code&gt;j&lt;/code&gt; 는 음수 일 수 있습니다. 경우 &lt;code&gt;j&lt;/code&gt; 부재하고,이어서,이를 (문자열 길이와 동일 함) -1과 동일한 것으로 가정한다. 특히, &lt;code&gt;string.sub(s,1,j)&lt;/code&gt; 호출 은 길이가 &lt;code&gt;j&lt;/code&gt; 인 &lt;code&gt;s&lt;/code&gt; 의 접두사를 리턴 하고 &lt;code&gt;string.sub(s, -i)&lt;/code&gt; (양수 &lt;code&gt;i&lt;/code&gt; 의 경우 )는 길이가 &lt;code&gt;i&lt;/code&gt; 인 &lt;code&gt;s&lt;/code&gt; 의 접미 부를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="0d879230a982638cb3037d087aec816766d1bff4" translate="yes" xml:space="preserve">
          <source>Returns the tangent of &lt;code&gt;x&lt;/code&gt; (assumed to be in radians).</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 탄젠트를 반환합니다 (라디안으로 가정).</target>
        </trans-unit>
        <trans-unit id="aeb49cdc670f656ecf94cc356e8482541619f67b" translate="yes" xml:space="preserve">
          <source>Returns the type of its only argument, coded as a string. The possible results of this function are &quot;&lt;code&gt;nil&lt;/code&gt;&quot; (a string, not the value &lt;b&gt;nil&lt;/b&gt;), &quot;&lt;code&gt;number&lt;/code&gt;&quot;, &quot;&lt;code&gt;string&lt;/code&gt;&quot;, &quot;&lt;code&gt;boolean&lt;/code&gt;&quot;, &quot;&lt;code&gt;table&lt;/code&gt;&quot;, &quot;&lt;code&gt;function&lt;/code&gt;&quot;, &quot;&lt;code&gt;thread&lt;/code&gt;&quot;, and &quot;&lt;code&gt;userdata&lt;/code&gt;&quot;.</source>
          <target state="translated">문자열로 코딩 된 유일한 인수의 유형을 리턴합니다. 이 함수의 가능한 결과는 &quot; &lt;code&gt;nil&lt;/code&gt; &quot;(값이 아닌 &lt;b&gt;nil&lt;/b&gt; ), &quot; &lt;code&gt;number&lt;/code&gt; &quot;, &quot; &lt;code&gt;string&lt;/code&gt; &quot;, &quot; &lt;code&gt;boolean&lt;/code&gt; &quot;, &quot; &lt;code&gt;table&lt;/code&gt; &quot;, &quot; &lt;code&gt;function&lt;/code&gt; &quot;, &quot; &lt;code&gt;thread&lt;/code&gt; &quot;및 &quot; &lt;code&gt;userdata&lt;/code&gt; &quot;입니다.</target>
        </trans-unit>
        <trans-unit id="b7cc3af32266285b487ea68c1fc6ffc164e146f6" translate="yes" xml:space="preserve">
          <source>Returns the type of the pushed value.</source>
          <target state="translated">푸시 된 값의 유형을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="11efeaa1a0a1dad64efc60561b86e6d305ce3e58" translate="yes" xml:space="preserve">
          <source>Returns the type of the value in the given valid index, or &lt;code&gt;LUA_TNONE&lt;/code&gt; for a non-valid (but acceptable) index. The types returned by &lt;a href=&quot;#lua_type&quot;&gt;&lt;code&gt;lua_type&lt;/code&gt;&lt;/a&gt; are coded by the following constants defined in &lt;code&gt;lua.h&lt;/code&gt;: &lt;a id=&quot;pdf-LUA_TNIL&quot;&gt;&lt;code&gt;LUA_TNIL&lt;/code&gt;&lt;/a&gt; (0), &lt;a id=&quot;pdf-LUA_TNUMBER&quot;&gt;&lt;code&gt;LUA_TNUMBER&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_TBOOLEAN&quot;&gt;&lt;code&gt;LUA_TBOOLEAN&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_TSTRING&quot;&gt;&lt;code&gt;LUA_TSTRING&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_TTABLE&quot;&gt;&lt;code&gt;LUA_TTABLE&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_TFUNCTION&quot;&gt;&lt;code&gt;LUA_TFUNCTION&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_TUSERDATA&quot;&gt;&lt;code&gt;LUA_TUSERDATA&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_TTHREAD&quot;&gt;&lt;code&gt;LUA_TTHREAD&lt;/code&gt;&lt;/a&gt;, and &lt;a id=&quot;pdf-LUA_TLIGHTUSERDATA&quot;&gt;&lt;code&gt;LUA_TLIGHTUSERDATA&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">주어진 유효한 인덱스에서 값의 유형을 반환하거나 유효하지 않은 (허용 가능한) 인덱스에 대해서는 &lt;code&gt;LUA_TNONE&lt;/code&gt; 을 반환합니다 . 유형에 의해 반환 &lt;a href=&quot;#lua_type&quot;&gt; &lt;code&gt;lua_type&lt;/code&gt; 가&lt;/a&gt; 정의되고있는 정수로 부호화 &lt;code&gt;lua.h&lt;/code&gt; : &lt;a id=&quot;pdf-LUA_TNIL&quot;&gt; &lt;code&gt;LUA_TNIL&lt;/code&gt; &lt;/a&gt; (0) &lt;a id=&quot;pdf-LUA_TNUMBER&quot;&gt; &lt;code&gt;LUA_TNUMBER&lt;/code&gt; &lt;/a&gt; , &lt;a id=&quot;pdf-LUA_TBOOLEAN&quot;&gt; &lt;code&gt;LUA_TBOOLEAN&lt;/code&gt; &lt;/a&gt; , &lt;a id=&quot;pdf-LUA_TSTRING&quot;&gt; &lt;code&gt;LUA_TSTRING&lt;/code&gt; &lt;/a&gt; , &lt;a id=&quot;pdf-LUA_TTABLE&quot;&gt; &lt;code&gt;LUA_TTABLE&lt;/code&gt; &lt;/a&gt; , &lt;a id=&quot;pdf-LUA_TFUNCTION&quot;&gt; &lt;code&gt;LUA_TFUNCTION&lt;/code&gt; &lt;/a&gt; , &lt;a id=&quot;pdf-LUA_TUSERDATA&quot;&gt; &lt;code&gt;LUA_TUSERDATA&lt;/code&gt; &lt;/a&gt; , &lt;a id=&quot;pdf-LUA_TTHREAD&quot;&gt; &lt;code&gt;LUA_TTHREAD&lt;/code&gt; &lt;/a&gt; 및 &lt;a id=&quot;pdf-LUA_TLIGHTUSERDATA&quot;&gt; &lt;code&gt;LUA_TLIGHTUSERDATA&lt;/code&gt; 를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="386a1f58fe55c34012815a8391ceb7917714f28e" translate="yes" xml:space="preserve">
          <source>Returns the type of the value in the given valid index, or &lt;code&gt;LUA_TNONE&lt;/code&gt; for a non-valid but acceptable index. The types returned by &lt;a href=&quot;#lua_type&quot;&gt;&lt;code&gt;lua_type&lt;/code&gt;&lt;/a&gt; are coded by the following constants defined in &lt;code&gt;lua.h&lt;/code&gt;: &lt;a id=&quot;pdf-LUA_TNIL&quot;&gt;&lt;code&gt;LUA_TNIL&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_TNUMBER&quot;&gt;&lt;code&gt;LUA_TNUMBER&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_TBOOLEAN&quot;&gt;&lt;code&gt;LUA_TBOOLEAN&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_TSTRING&quot;&gt;&lt;code&gt;LUA_TSTRING&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_TTABLE&quot;&gt;&lt;code&gt;LUA_TTABLE&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_TFUNCTION&quot;&gt;&lt;code&gt;LUA_TFUNCTION&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_TUSERDATA&quot;&gt;&lt;code&gt;LUA_TUSERDATA&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_TTHREAD&quot;&gt;&lt;code&gt;LUA_TTHREAD&lt;/code&gt;&lt;/a&gt;, and &lt;a id=&quot;pdf-LUA_TLIGHTUSERDATA&quot;&gt;&lt;code&gt;LUA_TLIGHTUSERDATA&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">주어진 유효한 인덱스의 값 유형 또는 유효하지 않지만 허용 가능한 인덱스 인 경우 &lt;code&gt;LUA_TNONE&lt;/code&gt; 을 반환합니다 . 유형에 의해 반환 &lt;a href=&quot;#lua_type&quot;&gt; &lt;code&gt;lua_type&lt;/code&gt; 가&lt;/a&gt; 정의되고있는 정수로 부호화 &lt;code&gt;lua.h&lt;/code&gt; : &lt;a id=&quot;pdf-LUA_TNIL&quot;&gt; &lt;code&gt;LUA_TNIL&lt;/code&gt; &lt;/a&gt; , &lt;a id=&quot;pdf-LUA_TNUMBER&quot;&gt; &lt;code&gt;LUA_TNUMBER&lt;/code&gt; &lt;/a&gt; , &lt;a id=&quot;pdf-LUA_TBOOLEAN&quot;&gt; &lt;code&gt;LUA_TBOOLEAN&lt;/code&gt; &lt;/a&gt; , &lt;a id=&quot;pdf-LUA_TSTRING&quot;&gt; &lt;code&gt;LUA_TSTRING&lt;/code&gt; &lt;/a&gt; , &lt;a id=&quot;pdf-LUA_TTABLE&quot;&gt; &lt;code&gt;LUA_TTABLE&lt;/code&gt; &lt;/a&gt; , &lt;a id=&quot;pdf-LUA_TFUNCTION&quot;&gt; &lt;code&gt;LUA_TFUNCTION&lt;/code&gt; &lt;/a&gt; , &lt;a id=&quot;pdf-LUA_TUSERDATA&quot;&gt; &lt;code&gt;LUA_TUSERDATA&lt;/code&gt; &lt;/a&gt; , &lt;a id=&quot;pdf-LUA_TTHREAD&quot;&gt; &lt;code&gt;LUA_TTHREAD&lt;/code&gt; &lt;/a&gt; 및 &lt;a id=&quot;pdf-LUA_TLIGHTUSERDATA&quot;&gt; &lt;code&gt;LUA_TLIGHTUSERDATA&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c355c772b6a7cd3959fe3ff1b22ce6913ee6b493" translate="yes" xml:space="preserve">
          <source>Returns the value &lt;em&gt;e&lt;sup&gt;x&lt;/sup&gt;&lt;/em&gt; (where &lt;code&gt;e&lt;/code&gt; is the base of natural logarithms).</source>
          <target state="translated">&lt;em&gt;e &lt;sup&gt;x&lt;/sup&gt;&lt;/em&gt; 값을 리턴합니다 (여기서 &lt;code&gt;e&lt;/code&gt; 는 자연 로그의 기초입니다).</target>
        </trans-unit>
        <trans-unit id="0fb28ceb3afa0ab32151ee21709c9aa0178b4cd0" translate="yes" xml:space="preserve">
          <source>Returns the value of the process environment variable &lt;code&gt;varname&lt;/code&gt; or &lt;b&gt;fail&lt;/b&gt; if the variable is not defined.</source>
          <target state="translated">프로세스 환경 변수 &lt;code&gt;varname&lt;/code&gt; 의 값을 반환 하거나 변수가 정의되지 않은 경우 &lt;b&gt;실패&lt;/b&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="a1f640b6a2396fe00ff3c46e513b55ada5898623" translate="yes" xml:space="preserve">
          <source>Returns the value of the process environment variable &lt;code&gt;varname&lt;/code&gt;, or &lt;b&gt;nil&lt;/b&gt; if the variable is not defined.</source>
          <target state="translated">프로세스 환경 변수 &lt;code&gt;varname&lt;/code&gt; 의 값을 리턴 하거나 변수가 정의되지 않은 경우 &lt;b&gt;nil을&lt;/b&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="f3b86e22b7e07287e106fe5463ecf2e5e16d5d52" translate="yes" xml:space="preserve">
          <source>Returns the values packed in string &lt;code&gt;s&lt;/code&gt; (see &lt;a href=&quot;#pdf-string.pack&quot;&gt;&lt;code&gt;string.pack&lt;/code&gt;&lt;/a&gt;) according to the format string &lt;code&gt;fmt&lt;/code&gt; (see &lt;a href=&quot;#6.4.2&quot;&gt;&amp;sect;6.4.2&lt;/a&gt;). An optional &lt;code&gt;pos&lt;/code&gt; marks where to start reading in &lt;code&gt;s&lt;/code&gt; (default is 1). After the read values, this function also returns the index of the first unread byte in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">반환 값이 문자열에 포장 &lt;code&gt;s&lt;/code&gt; (참조 &lt;a href=&quot;#pdf-string.pack&quot;&gt; &lt;code&gt;string.pack&lt;/code&gt; 를&lt;/a&gt; ) 형식 문자열에 따라 &lt;code&gt;fmt&lt;/code&gt; (참조 &lt;a href=&quot;#6.4.2&quot;&gt;&amp;sect;6.4.2&lt;/a&gt; ). 선택 사항 인 &lt;code&gt;pos&lt;/code&gt; 는 &lt;code&gt;s&lt;/code&gt; 에서 읽기 시작 위치를 표시합니다 (기본값은 1). 읽은 값 후에이 함수는 또한 읽지 않은 첫 번째 바이트의 인덱스를 &lt;code&gt;s&lt;/code&gt; 로 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="9da6ffc3c7ea901268412d4b32b6956c0cf722ea" translate="yes" xml:space="preserve">
          <source>Returns the version number of this core.</source>
          <target state="translated">이 코어의 버전 번호를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bcc3adbac55a1cae7b7dbc056f59867a7e653730" translate="yes" xml:space="preserve">
          <source>Returns three values (an iterator function, the table &lt;code&gt;t&lt;/code&gt;, and 0) so that the construction</source>
          <target state="translated">구성을 위해 세 개의 값 (반복자 함수, 테이블 &lt;code&gt;t&lt;/code&gt; 및 0)을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="fd4f281c2403b2b4ec6dfa198827f4141e53f9ac" translate="yes" xml:space="preserve">
          <source>Returns true when the coroutine &lt;code&gt;co&lt;/code&gt; can yield. The default for &lt;code&gt;co&lt;/code&gt; is the running coroutine.</source>
          <target state="translated">코 루틴 &lt;code&gt;co&lt;/code&gt; 가 양보 할 수있는 경우 true를 반환합니다 . &lt;code&gt;co&lt;/code&gt; 의 기본값 은 실행중인 코 루틴입니다.</target>
        </trans-unit>
        <trans-unit id="7db585fd6f4edc4d15ef6261e32bad83a4e3fc94" translate="yes" xml:space="preserve">
          <source>Returns true when the running coroutine can yield.</source>
          <target state="translated">실행중인 코 루틴이 산출 할 수있는 경우 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="86872d97a4648c727afb8bd8743402fb113d9d79" translate="yes" xml:space="preserve">
          <source>Returns values so that the construction</source>
          <target state="translated">구성이되도록 값을 반환</target>
        </trans-unit>
        <trans-unit id="c0dd5c1f0b221305574b2b927c5b76675e55a510" translate="yes" xml:space="preserve">
          <source>Rotates the stack elements between the valid index &lt;code&gt;idx&lt;/code&gt; and the top of the stack. The elements are rotated &lt;code&gt;n&lt;/code&gt; positions in the direction of the top, for a positive &lt;code&gt;n&lt;/code&gt;, or &lt;code&gt;-n&lt;/code&gt; positions in the direction of the bottom, for a negative &lt;code&gt;n&lt;/code&gt;. The absolute value of &lt;code&gt;n&lt;/code&gt; must not be greater than the size of the slice being rotated. This function cannot be called with a pseudo-index, because a pseudo-index is not an actual stack position.</source>
          <target state="translated">유효한 인덱스 &lt;code&gt;idx&lt;/code&gt; 와 스택 상단 사이에서 스택 요소를 회전합니다 . 요소는 상단 방향으로 &lt;code&gt;n&lt;/code&gt; 위치, 양수 &lt;code&gt;n&lt;/code&gt; , 하단 방향으로 &lt;code&gt;-n&lt;/code&gt; 위치, 음수 &lt;code&gt;n&lt;/code&gt; 위치로 회전 합니다. &lt;code&gt;n&lt;/code&gt; 의 절대 값은 회전중인 슬라이스의 크기보다 크지 않아야합니다. 의사 인덱스는 실제 스택 위치가 아니기 때문에 의사 인덱스로이 함수를 호출 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="cb167298f69784fe48c5d2a384e7c877c8d9492d" translate="yes" xml:space="preserve">
          <source>Saves any written data to &lt;code&gt;file&lt;/code&gt;.</source>
          <target state="translated">작성된 데이터를 &lt;code&gt;file&lt;/code&gt; 저장 합니다 .</target>
        </trans-unit>
        <trans-unit id="920400471986593c15fc84e450728648c16819e7" translate="yes" xml:space="preserve">
          <source>Searchers should raise no errors and have no side effects in Lua. (They may have side effects in C, for instance by linking the application with a library.)</source>
          <target state="translated">검색자는 오류를 제기하지 않아야하며 Lua에서 부작용이 없어야합니다. (예를 들어 응용 프로그램을 라이브러리와 연결하여 C에서 부작용이있을 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="3440752ad05f6155ff5680caecbafde2dc649d9b" translate="yes" xml:space="preserve">
          <source>Searches for the given &lt;code&gt;name&lt;/code&gt; in the given &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;path&lt;/code&gt; 에서 주어진 &lt;code&gt;name&lt;/code&gt; 을 검색 합니다 .</target>
        </trans-unit>
        <trans-unit id="94692e4b88a2528c0b5e86368b0213b54dbd9884" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#2.5&quot;&gt;&amp;sect;2.5&lt;/a&gt; for more details about garbage collection and some of these options.</source>
          <target state="translated">참조 &lt;a href=&quot;#2.5&quot;&gt;&amp;sect;2.5&lt;/a&gt; 가비지 컬렉션과 이러한 옵션 중 일부에 대한 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="d2a18ffdb89ed379138be3152d18086f1d55d2a3" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#pdf-debug.getlocal&quot;&gt;&lt;code&gt;debug.getlocal&lt;/code&gt;&lt;/a&gt; for more information about variable indices and names.</source>
          <target state="translated">변수 인덱스 및 이름에 대한 자세한 내용은 &lt;a href=&quot;#pdf-debug.getlocal&quot;&gt; &lt;code&gt;debug.getlocal&lt;/code&gt; &lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c68ceaa8d812b1b10a7eea6ccb5e07ce5de30a37" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#pdf-debug.getupvalue&quot;&gt;&lt;code&gt;debug.getupvalue&lt;/code&gt;&lt;/a&gt; for more information about upvalues.</source>
          <target state="translated">upvalue에 대한 자세한 정보는 &lt;a href=&quot;#pdf-debug.getupvalue&quot;&gt; &lt;code&gt;debug.getupvalue&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8806221244780430f4dab1be1efe9e1deb956088" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#pdf-warn&quot;&gt;&lt;code&gt;warn&lt;/code&gt;&lt;/a&gt; for more details about warnings.</source>
          <target state="translated">참조 &lt;a href=&quot;#pdf-warn&quot;&gt; &lt;code&gt;warn&lt;/code&gt; &lt;/a&gt; 경고에 대한 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="c3360426ce5422bc56d751e0aa6008fce46fc70e" translate="yes" xml:space="preserve">
          <source>See function &lt;a href=&quot;#pdf-next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; for the caveats of modifying the table during its traversal.</source>
          <target state="translated">순회 중 테이블을 수정하는 경우의 경고에 대해서는 &lt;a href=&quot;#pdf-next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; 기능을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="19f37898f520273219e289bdee9a8581baa73269" translate="yes" xml:space="preserve">
          <source>Sets &lt;code&gt;x&lt;/code&gt; as the &quot;seed&quot; for the pseudo-random generator: equal seeds produce equal sequences of numbers.</source>
          <target state="translated">의사 랜덤 생성기의 &lt;code&gt;x&lt;/code&gt; 를 &quot;시드&quot;로 설정합니다 . 동일한 시드는 동일한 수의 시퀀스를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="0d4c31b081bb4e342a5c7b04bb15e6651ad21d58" translate="yes" xml:space="preserve">
          <source>Sets a new limit for the C stack. This limit controls how deeply nested calls can go in Lua, with the intent of avoiding a stack overflow. A limit too small restricts recursive calls pointlessly; a limit too large exposes the interpreter to stack-overflow crashes. Unfortunately, there is no way to know a priori the maximum safe limit for a platform.</source>
          <target state="translated">C 스택에 대한 새로운 제한을 설정합니다. 이 제한은 스택 오버플로를 방지하기 위해 Lua에서 중첩 된 호출이 얼마나 깊이 들어갈 수 있는지를 제어합니다. 제한이 너무 작 으면 재귀 호출이 무의미하게 제한됩니다. 제한이 너무 크면 인터프리터가 스택 오버플로 충돌에 노출됩니다. 안타깝게도 플랫폼의 최대 안전 한계를 사전에 알 수있는 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="7966d7ba898208a4bfff8332d8d2ce5eab98e952" translate="yes" xml:space="preserve">
          <source>Sets a new limit for the C stack. This limit controls how deeply nested calls can go in Lua, with the intent of avoiding a stack overflow. Returns the old limit in case of success, or zero in case of error. For more details about this function, see &lt;a href=&quot;#pdf-debug.setcstacklimit&quot;&gt;&lt;code&gt;debug.setcstacklimit&lt;/code&gt;&lt;/a&gt;, its equivalent in the standard library.</source>
          <target state="translated">C 스택에 대한 새로운 제한을 설정합니다. 이 제한은 스택 오버플로를 방지하기 위해 Lua에서 중첩 된 호출이 얼마나 깊이 들어갈 수 있는지를 제어합니다. 성공한 경우 이전 제한을 반환하고 오류 인 경우 0을 반환합니다. 이 함수에 대한 자세한 내용은 표준 라이브러리에 해당하는 &lt;a href=&quot;#pdf-debug.setcstacklimit&quot;&gt; &lt;code&gt;debug.setcstacklimit&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5ffaec0474c3c12ab33648528a0c531a28325cf4" translate="yes" xml:space="preserve">
          <source>Sets a new panic function and returns the old one (see &lt;a href=&quot;#4.4&quot;&gt;&amp;sect;4.4&lt;/a&gt;).</source>
          <target state="translated">새로운 패닉 기능을 설정하고 이전 기능을 반환합니다 ( &lt;a href=&quot;#4.4&quot;&gt;&amp;sect;4.4&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="0b2903d5c5e2f6aac5cee42b812f29848f11b229" translate="yes" xml:space="preserve">
          <source>Sets a new panic function and returns the old one (see &lt;a href=&quot;#4.6&quot;&gt;&amp;sect;4.6&lt;/a&gt;).</source>
          <target state="translated">새로운 패닉 함수를 설정하고 이전 패닉 함수를 반환합니다 ( &lt;a href=&quot;#4.6&quot;&gt;&amp;sect;4.6&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="10482f8b5b12a1f1db635550932f8faad32fd81b" translate="yes" xml:space="preserve">
          <source>Sets and gets the file position, measured from the beginning of the file, to the position given by &lt;code&gt;offset&lt;/code&gt; plus a base specified by the string &lt;code&gt;whence&lt;/code&gt;, as follows:</source>
          <target state="translated">다음과 같이 파일의 시작 위치에서 &lt;code&gt;offset&lt;/code&gt; 지정된 위치 와 문자열 &lt;code&gt;whence&lt;/code&gt; 에 의해 지정된 기준까지 파일 위치를 설정하고 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="c75eca40914b6c7ff395b6a435b1b2509e75386b" translate="yes" xml:space="preserve">
          <source>Sets the C function &lt;code&gt;f&lt;/code&gt; as the new value of global &lt;code&gt;name&lt;/code&gt;. It is defined as a macro:</source>
          <target state="translated">C 함수 &lt;code&gt;f&lt;/code&gt; 를 새 전역 &lt;code&gt;name&lt;/code&gt; 값으로 설정합니다 . 매크로로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="081317fb6ecee7ae4baa46c02f924ee275f76a03" translate="yes" xml:space="preserve">
          <source>Sets the buffering mode for a file. There are three available modes:</source>
          <target state="translated">파일의 버퍼링 모드를 설정합니다. 세 가지 사용 가능한 모드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="de2f1f4dd9362493d0d4861f3dfe60cc83af4578" translate="yes" xml:space="preserve">
          <source>Sets the buffering mode for an output file. There are three available modes:</source>
          <target state="translated">출력 파일의 버퍼링 모드를 설정합니다. 사용 가능한 세 가지 모드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="47362e1529f7af535b225ac5e5e41ff2aab64e46" translate="yes" xml:space="preserve">
          <source>Sets the current locale of the program. &lt;code&gt;locale&lt;/code&gt; is a system-dependent string specifying a locale; &lt;code&gt;category&lt;/code&gt; is an optional string describing which category to change: &lt;code&gt;&quot;all&quot;&lt;/code&gt;, &lt;code&gt;&quot;collate&quot;&lt;/code&gt;, &lt;code&gt;&quot;ctype&quot;&lt;/code&gt;, &lt;code&gt;&quot;monetary&quot;&lt;/code&gt;, &lt;code&gt;&quot;numeric&quot;&lt;/code&gt;, or &lt;code&gt;&quot;time&quot;&lt;/code&gt;; the default category is &lt;code&gt;&quot;all&quot;&lt;/code&gt;. The function returns the name of the new locale, or &lt;b&gt;fail&lt;/b&gt; if the request cannot be honored.</source>
          <target state="translated">프로그램의 현재 로케일을 설정합니다. &lt;code&gt;locale&lt;/code&gt; 은 로케일을 지정하는 시스템 종속 문자열입니다. &lt;code&gt;category&lt;/code&gt; 는 변경할 범주를 설명하는 선택적 문자열입니다 : &lt;code&gt;&quot;all&quot;&lt;/code&gt; , &lt;code&gt;&quot;collate&quot;&lt;/code&gt; , &lt;code&gt;&quot;ctype&quot;&lt;/code&gt; , &lt;code&gt;&quot;monetary&quot;&lt;/code&gt; , &lt;code&gt;&quot;numeric&quot;&lt;/code&gt; , &lt;code&gt;&quot;time&quot;&lt;/code&gt; ; 기본 카테고리는 &lt;code&gt;&quot;all&quot;&lt;/code&gt; 입니다. 이 함수는 새 로캘의 이름을 반환하거나 요청을 받아 들일 수없는 경우 &lt;b&gt;실패&lt;/b&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="772769933fe32ebc8452718b212f21e2ae3b3d0a" translate="yes" xml:space="preserve">
          <source>Sets the current locale of the program. &lt;code&gt;locale&lt;/code&gt; is a system-dependent string specifying a locale; &lt;code&gt;category&lt;/code&gt; is an optional string describing which category to change: &lt;code&gt;&quot;all&quot;&lt;/code&gt;, &lt;code&gt;&quot;collate&quot;&lt;/code&gt;, &lt;code&gt;&quot;ctype&quot;&lt;/code&gt;, &lt;code&gt;&quot;monetary&quot;&lt;/code&gt;, &lt;code&gt;&quot;numeric&quot;&lt;/code&gt;, or &lt;code&gt;&quot;time&quot;&lt;/code&gt;; the default category is &lt;code&gt;&quot;all&quot;&lt;/code&gt;. The function returns the name of the new locale, or &lt;b&gt;nil&lt;/b&gt; if the request cannot be honored.</source>
          <target state="translated">프로그램의 현재 로케일을 설정합니다. &lt;code&gt;locale&lt;/code&gt; 은 로케일을 지정하는 시스템 종속 문자열입니다. &lt;code&gt;category&lt;/code&gt; 는 변경할 범주를 설명하는 선택적 문자열입니다. &lt;code&gt;&quot;all&quot;&lt;/code&gt; , &lt;code&gt;&quot;collate&quot;&lt;/code&gt; , &lt;code&gt;&quot;ctype&quot;&lt;/code&gt; , &lt;code&gt;&quot;monetary&quot;&lt;/code&gt; , &lt;code&gt;&quot;numeric&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;time&quot;&lt;/code&gt; ; 기본 카테고리는 &lt;code&gt;&quot;all&quot;&lt;/code&gt; 입니다. 이 함수는 새 로캘의 이름을 반환하거나 요청을 처리 할 수없는 경우 &lt;b&gt;nil을&lt;/b&gt; 반환합니다.</target>
        </trans-unit>
        <trans-unit id="577d8bdc520c0556720156fb048d7cc9591b0b65" translate="yes" xml:space="preserve">
          <source>Sets the debugging hook function.</source>
          <target state="translated">디버깅 후크 기능을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="0e50f7de74529ef0127c0979e57072500795bcf0" translate="yes" xml:space="preserve">
          <source>Sets the given &lt;code&gt;value&lt;/code&gt; as the &lt;code&gt;n&lt;/code&gt;-th user value associated to the given &lt;code&gt;udata&lt;/code&gt;. &lt;code&gt;udata&lt;/code&gt; must be a full userdata.</source>
          <target state="translated">주어진 &lt;code&gt;value&lt;/code&gt; 을 주어진 &lt;code&gt;udata&lt;/code&gt; 와 관련된 &lt;code&gt;n&lt;/code&gt; 번째 사용자 값 으로 설정합니다 . &lt;code&gt;udata&lt;/code&gt; 는 전체 사용자 데이터 여야합니다.</target>
        </trans-unit>
        <trans-unit id="292ec4e82927af4194013aa2f75932b01e97689c" translate="yes" xml:space="preserve">
          <source>Sets the given &lt;code&gt;value&lt;/code&gt; as the Lua value associated to the given &lt;code&gt;udata&lt;/code&gt;. &lt;code&gt;udata&lt;/code&gt; must be a full userdata.</source>
          <target state="translated">주어진 &lt;code&gt;value&lt;/code&gt; 을 주어진 &lt;code&gt;udata&lt;/code&gt; 와 연관된 Lua 값 으로 설정합니다 . &lt;code&gt;udata&lt;/code&gt; 는 전체 사용자 데이터 여야합니다.</target>
        </trans-unit>
        <trans-unit id="0f680b53b706554348285320cb60fd7dd4bf3ce4" translate="yes" xml:space="preserve">
          <source>Sets the given function as a hook. The string &lt;code&gt;mask&lt;/code&gt; and the number &lt;code&gt;count&lt;/code&gt; describe when the hook will be called. The string mask may have any combination of the following characters, with the given meaning:</source>
          <target state="translated">주어진 기능을 후크로 설정합니다. 문자열 &lt;code&gt;mask&lt;/code&gt; 와 숫자 &lt;code&gt;count&lt;/code&gt; 는 후크가 호출 될시기를 나타냅니다. 문자열 마스크는 다음과 같은 문자의 조합을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfa457abdfe638a1c05389781b6cb767699e3f5e" translate="yes" xml:space="preserve">
          <source>Sets the given function as the debug hook. The string &lt;code&gt;mask&lt;/code&gt; and the number &lt;code&gt;count&lt;/code&gt; describe when the hook will be called. The string mask may have any combination of the following characters, with the given meaning:</source>
          <target state="translated">주어진 함수를 디버그 후크로 설정합니다. 문자열 &lt;code&gt;mask&lt;/code&gt; 와 숫자 &lt;code&gt;count&lt;/code&gt; 는 후크가 호출되는시기를 설명합니다. 문자열 마스크는 주어진 의미와 함께 다음 문자의 조합을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7b8a030605b64f54e56dc4eb6882692a1e86465" translate="yes" xml:space="preserve">
          <source>Sets the metatable for the given &lt;code&gt;value&lt;/code&gt; to the given &lt;code&gt;table&lt;/code&gt; (which can be &lt;b&gt;nil&lt;/b&gt;). Returns &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;value&lt;/code&gt; 에 대한 메타 테이블을 주어진 &lt;code&gt;table&lt;/code&gt; ( &lt;b&gt;nil 일&lt;/b&gt; 수 있음 )로 설정합니다. &lt;code&gt;value&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="cc55fa8aad2a6ef152d3844b1dbc7d9854df5817" translate="yes" xml:space="preserve">
          <source>Sets the metatable for the given table. (To change the metatable of other types from Lua code, you must use the debug library (&lt;a href=&quot;#6.10&quot;&gt;&amp;sect;6.10&lt;/a&gt;).) If &lt;code&gt;metatable&lt;/code&gt; is &lt;b&gt;nil&lt;/b&gt;, removes the metatable of the given table. If the original metatable has a &lt;code&gt;__metatable&lt;/code&gt; field, raises an error.</source>
          <target state="translated">주어진 테이블에 대한 메타 테이블을 설정합니다. (루아 코드에서 다른 유형의 메타 테이블을 변경하려면 디버그 라이브러리 (사용해야합니다 &lt;a href=&quot;#6.10&quot;&gt;&amp;sect;6.10을&lt;/a&gt; ).) 경우 &lt;code&gt;metatable&lt;/code&gt; 있다 &lt;b&gt;전무&lt;/b&gt; , 주어진 테이블의 메타 테이블을 제거합니다. 원래 메타 테이블에 &lt;code&gt;__metatable&lt;/code&gt; 필드가 있으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a0ebfc6ec4adb4b51d14e3fb506f43ec69d2311e" translate="yes" xml:space="preserve">
          <source>Sets the metatable for the given table. If &lt;code&gt;metatable&lt;/code&gt; is &lt;b&gt;nil&lt;/b&gt;, removes the metatable of the given table. If the original metatable has a &lt;code&gt;__metatable&lt;/code&gt; field, raises an error.</source>
          <target state="translated">주어진 테이블에 대한 메타 테이블을 설정합니다. 경우 &lt;code&gt;metatable&lt;/code&gt; 있다 &lt;b&gt;전무&lt;/b&gt; , 주어진 테이블의 메타 테이블을 제거합니다. 원본 메타 테이블에 &lt;code&gt;__metatable&lt;/code&gt; 필드가 있으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="587b6bacfd61f3dd529496795bf4b5531bf0411f" translate="yes" xml:space="preserve">
          <source>Sets the metatable of the object at the top of the stack as the metatable associated with name &lt;code&gt;tname&lt;/code&gt; in the registry (see &lt;a href=&quot;#luaL_newmetatable&quot;&gt;&lt;code&gt;luaL_newmetatable&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">스택의 맨 위에있는 객체의 메타 테이블을 레지스트리의 이름 &lt;code&gt;tname&lt;/code&gt; 과 연관된 메타 테이블로 설정합니다 ( &lt;a href=&quot;#luaL_newmetatable&quot;&gt; &lt;code&gt;luaL_newmetatable&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="d22790332cf1d45f6a8843c4ad039244e90ff99f" translate="yes" xml:space="preserve">
          <source>Sets the metatable of the object on the top of the stack as the metatable associated with name &lt;code&gt;tname&lt;/code&gt; in the registry (see &lt;a href=&quot;#luaL_newmetatable&quot;&gt;&lt;code&gt;luaL_newmetatable&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">스택의 맨 위에있는 객체의 메타 테이블을 레지스트리의 &lt;code&gt;tname&lt;/code&gt; 이름과 관련된 메타 테이블로 설정합니다 ( &lt;a href=&quot;#luaL_newmetatable&quot;&gt; &lt;code&gt;luaL_newmetatable&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="980d28e7c69235ce8818955ee39047b99459cc45" translate="yes" xml:space="preserve">
          <source>Sets the real value of &lt;code&gt;table[index]&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt;, without invoking the &lt;code&gt;__newindex&lt;/code&gt; metamethod. &lt;code&gt;table&lt;/code&gt; must be a table, &lt;code&gt;index&lt;/code&gt; any value different from &lt;b&gt;nil&lt;/b&gt; and NaN, and &lt;code&gt;value&lt;/code&gt; any Lua value.</source>
          <target state="translated">실제의 값을 설정한다 &lt;code&gt;table[index]&lt;/code&gt; 에 &lt;code&gt;value&lt;/code&gt; 호출하지 않고 &lt;code&gt;__newindex&lt;/code&gt; 의 메타 메소드. &lt;code&gt;table&lt;/code&gt; 은 테이블 이어야하며 &lt;b&gt;nil&lt;/b&gt; 및 NaN과 다른 값을 &lt;code&gt;index&lt;/code&gt; 하고 Lua 값을 &lt;code&gt;value&lt;/code&gt; 해야합니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="83fb6edb67ceac4c3bec94b60202ea6ff8ecd172" translate="yes" xml:space="preserve">
          <source>Sets the real value of &lt;code&gt;table[index]&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt;, without using the &lt;code&gt;__newindex&lt;/code&gt; metavalue. &lt;code&gt;table&lt;/code&gt; must be a table, &lt;code&gt;index&lt;/code&gt; any value different from &lt;b&gt;nil&lt;/b&gt; and NaN, and &lt;code&gt;value&lt;/code&gt; any Lua value.</source>
          <target state="translated">실제의 값을 설정한다 &lt;code&gt;table[index]&lt;/code&gt; 까지 &lt;code&gt;value&lt;/code&gt; 은 USING없이 &lt;code&gt;__newindex&lt;/code&gt; 의 metavalue한다. &lt;code&gt;table&lt;/code&gt; 은 테이블 이어야하며 &lt;b&gt;nil&lt;/b&gt; 및 NaN과 다른 값을 &lt;code&gt;index&lt;/code&gt; 하고 모든 Lua 값을 &lt;code&gt;value&lt;/code&gt; 해야합니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="64764244caf680f963cbe34576ef7f19047e51d8" translate="yes" xml:space="preserve">
          <source>Sets the value of a closure's upvalue. It assigns the value at the top of the stack to the upvalue and returns its name. It also pops the value from the stack.</source>
          <target state="translated">클로저의 상한값을 설정합니다. 스택 맨 위에있는 값을 상위 값에 할당하고 이름을 반환합니다. 또한 스택에서 값을 팝합니다.</target>
        </trans-unit>
        <trans-unit id="a4f7f3cdc50e6225c7b313befabe93f7ca2bf356" translate="yes" xml:space="preserve">
          <source>Sets the value of a closure's upvalue. It assigns the value on the top of the stack to the upvalue and returns its name. It also pops the value from the stack.</source>
          <target state="translated">클로저의 upvalue 값을 설정합니다. 스택 맨 위에있는 값을 upvalue에 할당하고 이름을 반환합니다. 또한 스택에서 값을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="ffba6d217c9340ff452d0b26d7bde601a75effed" translate="yes" xml:space="preserve">
          <source>Sets the value of a local variable of a given activation record. It assigns the value at the top of the stack to the variable and returns its name. It also pops the value from the stack.</source>
          <target state="translated">지정된 활성화 레코드의 로컬 변수 값을 설정합니다. 스택 맨 위에있는 값을 변수에 할당하고 이름을 반환합니다. 또한 스택에서 값을 팝합니다.</target>
        </trans-unit>
        <trans-unit id="7f22679a70311edfc5f50384a42d2ab7fff23fa6" translate="yes" xml:space="preserve">
          <source>Sets the value of a local variable of a given activation record. It assigns the value on the top of the stack to the variable and returns its name. It also pops the value from the stack.</source>
          <target state="translated">지정된 활성화 레코드의 지역 변수 값을 설정합니다. 스택 맨 위에있는 값을 변수에 할당하고 이름을 반환합니다. 또한 스택에서 값을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="b03940c1d1ac3a2bf1547c98b0cbe03f39d14377" translate="yes" xml:space="preserve">
          <source>Sets the warning function to be used by Lua to emit warnings (see &lt;a href=&quot;#lua_WarnFunction&quot;&gt;&lt;code&gt;lua_WarnFunction&lt;/code&gt;&lt;/a&gt;). The &lt;code&gt;ud&lt;/code&gt; parameter sets the value &lt;code&gt;ud&lt;/code&gt; passed to the warning function.</source>
          <target state="translated">경고를 &lt;a href=&quot;#lua_WarnFunction&quot;&gt; &lt;code&gt;lua_WarnFunction&lt;/code&gt; &lt;/a&gt; 위해 Lua에서 사용할 경고 함수를 설정합니다 ( lua_WarnFunction 참조 ). &lt;code&gt;ud&lt;/code&gt; 매개 변수 세트는 값은 &lt;code&gt;ud&lt;/code&gt; 경고 함수에 전달.</target>
        </trans-unit>
        <trans-unit id="e346a8f5ef11e0659f9d13d2fd20c5971760ec54" translate="yes" xml:space="preserve">
          <source>Several functions in the API return pointers (&lt;code&gt;const char*&lt;/code&gt;) to Lua strings in the stack. (See &lt;a href=&quot;#lua_pushfstring&quot;&gt;&lt;code&gt;lua_pushfstring&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#lua_pushlstring&quot;&gt;&lt;code&gt;lua_pushlstring&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#lua_pushstring&quot;&gt;&lt;code&gt;lua_pushstring&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#lua_tolstring&quot;&gt;&lt;code&gt;lua_tolstring&lt;/code&gt;&lt;/a&gt;. See also &lt;a href=&quot;#luaL_checklstring&quot;&gt;&lt;code&gt;luaL_checklstring&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#luaL_checkstring&quot;&gt;&lt;code&gt;luaL_checkstring&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#luaL_tolstring&quot;&gt;&lt;code&gt;luaL_tolstring&lt;/code&gt;&lt;/a&gt; in the auxiliary library.)</source>
          <target state="translated">API의 여러 함수 는 스택의 Lua 문자열에 대한 포인터 ( &lt;code&gt;const char*&lt;/code&gt; )를 반환 합니다. ( &lt;a href=&quot;#lua_pushfstring&quot;&gt; &lt;code&gt;lua_pushfstring&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#lua_pushlstring&quot;&gt; &lt;code&gt;lua_pushlstring&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#lua_pushstring&quot;&gt; &lt;code&gt;lua_pushstring&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#lua_tolstring&quot;&gt; &lt;code&gt;lua_tolstring&lt;/code&gt; 을&lt;/a&gt; 참조하십시오. 또한 보조 라이브러리의 &lt;a href=&quot;#luaL_checklstring&quot;&gt; &lt;code&gt;luaL_checklstring&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#luaL_checkstring&quot;&gt; &lt;code&gt;luaL_checkstring&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#luaL_tolstring&quot;&gt; &lt;code&gt;luaL_tolstring&lt;/code&gt; &lt;/a&gt; 을 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="13dfadc7fc1e60158ee478b1d01c15a1a262b8f8" translate="yes" xml:space="preserve">
          <source>Several functions in the auxiliary library are used to check C function arguments. Because the error message is formatted for arguments (e.g., &quot;&lt;code&gt;bad argument #1&lt;/code&gt;&quot;), you should not use these functions for other stack values.</source>
          <target state="translated">보조 라이브러리의 여러 함수는 C 함수 인수를 확인하는 데 사용됩니다. 오류 메시지는 인수 형식으로 지정되므로 (예 : &quot; &lt;code&gt;bad argument #1&lt;/code&gt; &quot;) 다른 스택 값에이 함수를 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="d7d26a3bd3ccc1bc11907697040007c09639a73d" translate="yes" xml:space="preserve">
          <source>Several functions in the auxiliary library use internally some extra stack slots. When a function in the auxiliary library uses less than five slots, it does not check the stack size; it simply assumes that there are enough slots.</source>
          <target state="translated">보조 라이브러리의 여러 기능은 내부적으로 일부 추가 스택 슬롯을 사용합니다. 보조 라이브러리의 기능이 5 개 미만의 슬롯을 사용하는 경우 스택 크기를 확인하지 않습니다. 슬롯이 충분하다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="1a5b014735ed16f1ba36e3785a0f441d0242e3d9" translate="yes" xml:space="preserve">
          <source>Several functions that report errors in the API use the following status codes to indicate different kinds of errors or other conditions:</source>
          <target state="translated">API에서 오류를보고하는 여러 함수는 다음 상태 코드를 사용하여 다양한 종류의 오류 또는 기타 조건을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="08d00af90d2bbbb33d085cc5ef987064ed22d642" translate="yes" xml:space="preserve">
          <source>Several operations in Lua can &lt;em&gt;raise&lt;/em&gt; an error. An error interrupts the normal flow of the program, which can continue by &lt;em&gt;catching&lt;/em&gt; the error.</source>
          <target state="translated">루아에서 여러 작업을 수행 할 수 있습니다 &lt;em&gt;인상&lt;/em&gt; 오류. 오류는 프로그램의 정상적인 흐름을 방해하며 오류를 &lt;em&gt;포착&lt;/em&gt; 하여 계속할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="db95dfa9c967586d03ebee139b1fb3b17b47718b" translate="yes" xml:space="preserve">
          <source>Several places in Lua coerce strings to numbers when necessary. In particular, the string library sets metamethods that try to coerce strings to numbers in all arithmetic operations. If the conversion fails, the library calls the metamethod of the other operand (if present) or it raises an error. Note that bitwise operators do not do this coercion.</source>
          <target state="translated">Lua의 여러 곳에서 필요한 경우 문자열을 숫자로 강제 변환합니다. 특히 문자열 라이브러리는 모든 산술 연산에서 문자열을 숫자로 강제 변환하는 메타 메서드를 설정합니다. 변환이 실패하면 라이브러리는 다른 피연산자의 메타 메서드 (있는 경우)를 호출하거나 오류를 발생시킵니다. 비트 연산자는이 강제를 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4e6f5999f6739678269276a1253783f2e33caacc" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#lua_gettable&quot;&gt;&lt;code&gt;lua_gettable&lt;/code&gt;&lt;/a&gt;, but does a raw access (i.e., without metamethods).</source>
          <target state="translated">&lt;a href=&quot;#lua_gettable&quot;&gt; &lt;code&gt;lua_gettable&lt;/code&gt; &lt;/a&gt; 과 유사 하지만 원시 액세스를 수행합니다 (예 : 메타 메소드 없음).</target>
        </trans-unit>
        <trans-unit id="98d6dc9d6d25a6a5bcf82cd4cb364da6adb19bc6" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#lua_settable&quot;&gt;&lt;code&gt;lua_settable&lt;/code&gt;&lt;/a&gt;, but does a raw assignment (i.e., without metamethods).</source>
          <target state="translated">&lt;a href=&quot;#lua_settable&quot;&gt; &lt;code&gt;lua_settable&lt;/code&gt; &lt;/a&gt; 과 유사 하지만 원시 할당을 수행합니다 (예 : 메타 메소드 없음).</target>
        </trans-unit>
        <trans-unit id="bb8fabad1f82bd899f79eae459334cf7e778fcba" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#pdf-io.input&quot;&gt;&lt;code&gt;io.input&lt;/code&gt;&lt;/a&gt;, but operates over the default output file.</source>
          <target state="translated">&lt;a href=&quot;#pdf-io.input&quot;&gt; &lt;code&gt;io.input&lt;/code&gt; &lt;/a&gt; 과 유사 하지만 기본 출력 파일에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="be9918f302436d602e28315cc5eff3fc1e73bb44" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#pdf-load&quot;&gt;&lt;code&gt;load&lt;/code&gt;&lt;/a&gt;, but gets the chunk from file &lt;code&gt;filename&lt;/code&gt; or from the standard input, if no file name is given.</source>
          <target state="translated">유사합니다 &lt;a href=&quot;#pdf-load&quot;&gt; &lt;code&gt;load&lt;/code&gt; &lt;/a&gt; 하지만, 파일에서 청크를 가져옵니다 &lt;code&gt;filename&lt;/code&gt; 파일 이름을 지정하지 않은 경우, 또는 표준 입력에서.</target>
        </trans-unit>
        <trans-unit id="26f694e9b1074e2724d2aeb68c0547978de3e666" translate="yes" xml:space="preserve">
          <source>Similarly, Lua versions can always change the internal representation of precompiled chunks; precompiled chunks are not compatible between different Lua versions.</source>
          <target state="translated">마찬가지로 Lua 버전은 항상 사전 컴파일 된 청크의 내부 표현을 변경할 수 있습니다. 사전 컴파일 된 청크는 다른 Lua 버전간에 호환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fbd85d6dbfcd7a9c4f67b15fec97031a2abeaf4f" translate="yes" xml:space="preserve">
          <source>Some functions in the debug interface also return pointers to strings, namely &lt;a href=&quot;#lua_getlocal&quot;&gt;&lt;code&gt;lua_getlocal&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#lua_getupvalue&quot;&gt;&lt;code&gt;lua_getupvalue&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#lua_setlocal&quot;&gt;&lt;code&gt;lua_setlocal&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#lua_setupvalue&quot;&gt;&lt;code&gt;lua_setupvalue&lt;/code&gt;&lt;/a&gt;. For these functions, the pointer is guaranteed to be valid while the caller function is active and the given closure (if one was given) is in the stack.</source>
          <target state="translated">디버그 인터페이스의 일부 함수는 &lt;a href=&quot;#lua_getlocal&quot;&gt; &lt;code&gt;lua_getlocal&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#lua_getupvalue&quot;&gt; &lt;code&gt;lua_getupvalue&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#lua_setlocal&quot;&gt; &lt;code&gt;lua_setlocal&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#lua_setupvalue&quot;&gt; &lt;code&gt;lua_setupvalue&lt;/code&gt; &lt;/a&gt; 와 같은 문자열에 대한 포인터도 반환 합니다. 이러한 함수의 경우 호출자 함수가 활성화되고 주어진 클로저 (주어진 경우)가 스택에있는 동안 포인터가 유효 함이 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="91f7e308fa2ec755f5b9629aa68bea063366955f" translate="yes" xml:space="preserve">
          <source>Sorts list elements in a given order, &lt;em&gt;in-place&lt;/em&gt;, from &lt;code&gt;list[1]&lt;/code&gt; to &lt;code&gt;list[#list]&lt;/code&gt;. If &lt;code&gt;comp&lt;/code&gt; is given, then it must be a function that receives two list elements and returns true when the first element must come before the second in the final order (so that, after the sort, &lt;code&gt;i &amp;lt; j&lt;/code&gt; implies &lt;code&gt;not comp(list[j],list[i])&lt;/code&gt;). If &lt;code&gt;comp&lt;/code&gt; is not given, then the standard Lua operator &lt;code&gt;&amp;lt;&lt;/code&gt; is used instead.</source>
          <target state="translated">소정의 순서로 정렬 된 목록 엘리먼트 &lt;em&gt;의 장소&lt;/em&gt; 에서, &lt;code&gt;list[1]&lt;/code&gt; 에 &lt;code&gt;list[#list]&lt;/code&gt; . 경우 &lt;code&gt;comp&lt;/code&gt; 주어진 첫 번째 요소가되도록 정렬 후 (최종 순서에서 제 앞에 와야 때, 두 개의리스트 엘리먼트하고 true 수신 기능이어야 &lt;code&gt;i &amp;lt; j&lt;/code&gt; 의미 &lt;code&gt;not comp(list[j],list[i])&lt;/code&gt; ). 경우 &lt;code&gt;comp&lt;/code&gt; 지정되어 있지 않은 경우, 표준 루아 연산자는 &lt;code&gt;&amp;lt;&lt;/code&gt; 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c0517f4c6665e2b52991a1cccc3781c492c0e6b1" translate="yes" xml:space="preserve">
          <source>Sorts the list elements in a given order, &lt;em&gt;in-place&lt;/em&gt;, from &lt;code&gt;list[1]&lt;/code&gt; to &lt;code&gt;list[#list]&lt;/code&gt;. If &lt;code&gt;comp&lt;/code&gt; is given, then it must be a function that receives two list elements and returns true when the first element must come before the second in the final order (so that, after the sort, &lt;code&gt;i &amp;lt; j&lt;/code&gt; implies &lt;code&gt;not comp(list[j],list[i])&lt;/code&gt;). If &lt;code&gt;comp&lt;/code&gt; is not given, then the standard Lua operator &lt;code&gt;&amp;lt;&lt;/code&gt; is used instead.</source>
          <target state="translated">&lt;code&gt;list[1]&lt;/code&gt; 에서 &lt;code&gt;list[#list]&lt;/code&gt; 까지 지정된 순서로 목록 요소를 &lt;em&gt;in-place&lt;/em&gt; 정렬합니다 . 경우 &lt;code&gt;comp&lt;/code&gt; 주어진 첫 번째 요소가되도록 정렬 후 (최종 순서에서 제 앞에 와야 때, 두 개의리스트 엘리먼트하고 true 수신 기능이어야 &lt;code&gt;i &amp;lt; j&lt;/code&gt; 의미 &lt;code&gt;not comp(list[j],list[i])&lt;/code&gt; ). 경우 &lt;code&gt;comp&lt;/code&gt; 지정되어 있지 않은 경우, 표준 루아 연산자는 &lt;code&gt;&amp;lt;&lt;/code&gt; 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a010f7f7cdbd4258d79a8a94cbe56bc77bf2b5e7" translate="yes" xml:space="preserve">
          <source>Square brackets are used to index a table:</source>
          <target state="translated">대괄호는 테이블을 색인하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="15f3db96858a0b179ed1ef035b7c3729debc1d46" translate="yes" xml:space="preserve">
          <source>Stack Size</source>
          <target state="translated">스택 크기</target>
        </trans-unit>
        <trans-unit id="a8857dbe9de4909ed5c2183cf91102dab19f054b" translate="yes" xml:space="preserve">
          <source>Standard Libraries</source>
          <target state="translated">표준 라이브러리</target>
        </trans-unit>
        <trans-unit id="3aa420e36a031586ffcaad7595673c265cb89fc8" translate="yes" xml:space="preserve">
          <source>Starts and resumes a coroutine in the given thread &lt;code&gt;L&lt;/code&gt;.</source>
          <target state="translated">주어진 스레드 &lt;code&gt;L&lt;/code&gt; 에서 코 루틴을 시작하고 다시 시작합니다 .</target>
        </trans-unit>
        <trans-unit id="d40756a05671d2e92d48621babd1cb1ebcde9165" translate="yes" xml:space="preserve">
          <source>Starts or continues the execution of coroutine &lt;code&gt;co&lt;/code&gt;. The first time you resume a coroutine, it starts running its body. The values &lt;code&gt;val1&lt;/code&gt;, ... are passed as the arguments to the body function. If the coroutine has yielded, &lt;code&gt;resume&lt;/code&gt; restarts it; the values &lt;code&gt;val1&lt;/code&gt;, ... are passed as the results from the yield.</source>
          <target state="translated">코 루틴 &lt;code&gt;co&lt;/code&gt; 의 실행을 시작하거나 계속합니다 . 코 루틴을 처음 재개하면 몸이 뛰기 시작합니다. &lt;code&gt;val1&lt;/code&gt; , ... 값 은 body 함수에 인수로 전달됩니다. 코 루틴이 생성되면 &lt;code&gt;resume&lt;/code&gt; 시작 하여 다시 시작합니다. &lt;code&gt;val1&lt;/code&gt; , ... 값 은 수율의 결과로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="fdcf228dfc0fc5649ba85944b97fefcca7ffe43a" translate="yes" xml:space="preserve">
          <source>Starts program &lt;code&gt;prog&lt;/code&gt; in a separated process and returns a file handle that you can use to read data from this program (if &lt;code&gt;mode&lt;/code&gt; is &lt;code&gt;&quot;r&quot;&lt;/code&gt;, the default) or to write data to this program (if &lt;code&gt;mode&lt;/code&gt; is &lt;code&gt;&quot;w&quot;&lt;/code&gt;).</source>
          <target state="translated">분리 된 프로세스에서 프로그램 &lt;code&gt;prog&lt;/code&gt; 을 시작 하고이 프로그램에서 데이터를 읽거나 ( &lt;code&gt;mode&lt;/code&gt; 가 &lt;code&gt;&quot;r&quot;&lt;/code&gt; 인 경우 기본값)이 프로그램에 데이터를 쓰는 데 ( &lt;code&gt;mode&lt;/code&gt; 가 &lt;code&gt;&quot;w&quot;&lt;/code&gt; 인 경우) 사용할 수있는 파일 핸들을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="fe31e15bdd22d691294377c44baf7ad2201f9aed" translate="yes" xml:space="preserve">
          <source>Starts the program &lt;code&gt;prog&lt;/code&gt; in a separated process and returns a file handle that you can use to read data from this program (if &lt;code&gt;mode&lt;/code&gt; is &lt;code&gt;&quot;r&quot;&lt;/code&gt;, the default) or to write data to this program (if &lt;code&gt;mode&lt;/code&gt; is &lt;code&gt;&quot;w&quot;&lt;/code&gt;).</source>
          <target state="translated">분리 된 프로세스에서 프로그램 &lt;code&gt;prog&lt;/code&gt; 를 시작 하고이 프로그램에서 데이터를 읽거나 ( &lt;code&gt;mode&lt;/code&gt; 가 &lt;code&gt;&quot;r&quot;&lt;/code&gt; 인 경우 기본값)이 프로그램에 데이터를 쓰는 데 사용할 수있는 파일 핸들을 반환합니다 ( &lt;code&gt;mode&lt;/code&gt; 가 &lt;code&gt;&quot;w&quot;&lt;/code&gt; 인 경우 ).</target>
        </trans-unit>
        <trans-unit id="5653cebc057d4791ce07031ad9286e729de6d691" translate="yes" xml:space="preserve">
          <source>Statements</source>
          <target state="translated">Statements</target>
        </trans-unit>
        <trans-unit id="7f5583f5096a76c834c0bcc4f4885ffca8fe34cd" translate="yes" xml:space="preserve">
          <source>Status Codes</source>
          <target state="translated">상태 코드</target>
        </trans-unit>
        <trans-unit id="4a3601848fbaa157ee7ad1bf17ef71628017fcdf" translate="yes" xml:space="preserve">
          <source>Suppose the running thread yields while executing the callee function. After the thread resumes, it eventually will finish running the callee function. However, the callee function cannot return to the original function, because its frame in the C stack was destroyed by the yield. Instead, Lua calls a &lt;em&gt;continuation function&lt;/em&gt;, which was given as an argument to the callee function. As the name implies, the continuation function should continue the task of the original function.</source>
          <target state="translated">호출 수신자 함수를 실행하는 동안 실행중인 스레드 수율을 가정하십시오. 스레드가 재개되면 결국 수신자 함수 실행이 완료됩니다. 그러나 C 스택의 프레임이 수율로 인해 소멸되었으므로 수신자 함수는 원래 함수로 돌아갈 수 없습니다. 대신 Lua는 호출 &lt;em&gt;함수&lt;/em&gt; 에 대한 인수로 제공된 &lt;em&gt;연속 함수&lt;/em&gt; 를 호출합니다. 이름에서 알 수 있듯이 연속 기능은 원래 기능의 작업을 계속해야합니다.</target>
        </trans-unit>
        <trans-unit id="e83b7d557c46acb05b744857e11a6cfdb7f1df00" translate="yes" xml:space="preserve">
          <source>Suspends the execution of the calling coroutine. Any arguments to &lt;code&gt;yield&lt;/code&gt; are passed as extra results to &lt;code&gt;resume&lt;/code&gt;.</source>
          <target state="translated">발신 코 루틴 실행을 일시 중단합니다. &lt;code&gt;yield&lt;/code&gt; 할 인수 는 추가 결과로 전달되어 &lt;code&gt;resume&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="cf68697aa23858afae69b1650bbb5ac00b4caade" translate="yes" xml:space="preserve">
          <source>Table Constructors</source>
          <target state="translated">테이블 생성자</target>
        </trans-unit>
        <trans-unit id="ddade22015227084f0c0a4b0fb958ac23eef35ed" translate="yes" xml:space="preserve">
          <source>Table constructors are expressions that create tables. Every time a constructor is evaluated, a new table is created. A constructor can be used to create an empty table or to create a table and initialize some of its fields. The general syntax for constructors is</source>
          <target state="translated">테이블 생성자는 테이블을 생성하는 표현식입니다. 생성자가 평가 될 때마다 새 테이블이 작성됩니다. 생성자를 사용하여 빈 테이블을 만들거나 테이블을 만들고 일부 필드를 초기화 할 수 있습니다. 생성자의 일반적인 구문은</target>
        </trans-unit>
        <trans-unit id="8eb8356b5217b3ad22882eb75be685d15131abcf" translate="yes" xml:space="preserve">
          <source>Tables and full userdata have individual metatables (although multiple tables and userdata can share their metatables). Values of all other types share one single metatable per type; that is, there is one single metatable for all numbers, one for all strings, etc. By default, a value has no metatable, but the string library sets a metatable for the string type (see &lt;a href=&quot;#6.4&quot;&gt;&amp;sect;6.4&lt;/a&gt;).</source>
          <target state="translated">테이블과 전체 사용자 데이터에는 개별 메타 테이블이 있습니다 (여러 테이블과 사용자 데이터는 메타 테이블을 공유 할 수 있음). 다른 모든 유형의 값은 유형 당 하나의 단일 메타 테이블을 공유합니다. 즉, 모든 숫자에 대해 하나의 메타 테이블이 있고 모든 문자열에 대해 하나의 메타 테이블이 있습니다. 기본적으로 값에는 메타 테이블이 없지만 문자열 라이브러리는 문자열 유형에 대한 메타 테이블을 설정합니다 ( &lt;a href=&quot;#6.4&quot;&gt;&amp;sect;6.4&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="a43eec2139292b4bea0916e6b1d5992b76b7800a" translate="yes" xml:space="preserve">
          <source>Tables and full userdata have individual metatables, although multiple tables and userdata can share their metatables. Values of all other types share one single metatable per type; that is, there is one single metatable for all numbers, one for all strings, etc. By default, a value has no metatable, but the string library sets a metatable for the string type (see &lt;a href=&quot;#6.4&quot;&gt;&amp;sect;6.4&lt;/a&gt;).</source>
          <target state="translated">여러 테이블과 사용자 데이터가 메타 테이블을 공유 할 수 있지만 테이블과 전체 사용자 데이터에는 개별 메타 테이블이 있습니다. 다른 모든 유형의 값은 유형 당 하나의 메타 테이블을 공유합니다. 즉, 모든 숫자에 대해 하나의 메타 테이블, 모든 문자열에 대해 하나 등이 있습니다. 기본적으로 값에는 메타 테이블이 없지만 문자열 라이브러리는 문자열 유형에 대한 메타 테이블을 설정합니다 ( &lt;a href=&quot;#6.4&quot;&gt;&amp;sect;6.4&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="790df16e07d28fbd0bc25fd6c6058d692af71b40" translate="yes" xml:space="preserve">
          <source>Tables are the sole data-structuring mechanism in Lua; they can be used to represent ordinary arrays, lists, symbol tables, sets, records, graphs, trees, etc. To represent records, Lua uses the field name as an index. The language supports this representation by providing &lt;code&gt;a.name&lt;/code&gt; as syntactic sugar for &lt;code&gt;a[&quot;name&quot;]&lt;/code&gt;. There are several convenient ways to create tables in Lua (see &lt;a href=&quot;#3.4.9&quot;&gt;&amp;sect;3.4.9&lt;/a&gt;).</source>
          <target state="translated">테이블은 Lua의 유일한 데이터 구조화 메커니즘입니다. 그것들은 일반적인 배열,리스트, 심볼 테이블, 세트, ​​레코드, 그래프, 트리 등을 나타내는 데 사용될 수 있습니다. 레코드를 나타 내기 위해 Lua는 필드 이름을 인덱스로 사용합니다. 이 언어는 &lt;code&gt;a.name&lt;/code&gt; 을 &lt;code&gt;a[&quot;name&quot;]&lt;/code&gt; 의 구문 설탕 으로 제공하여이 표현을 지원합니다 . Lua에서 테이블을 만드는 편리한 방법이 몇 가지 있습니다 ( &lt;a href=&quot;#3.4.9&quot;&gt;&amp;sect;3.4.9&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="e421a06df75071a6abebc4fb3581855738824adb" translate="yes" xml:space="preserve">
          <source>Tables, functions, threads, and (full) userdata values are &lt;em&gt;objects&lt;/em&gt;: variables do not actually &lt;em&gt;contain&lt;/em&gt; these values, only &lt;em&gt;references&lt;/em&gt; to them. Assignment, parameter passing, and function returns always manipulate references to such values; these operations do not imply any kind of copy.</source>
          <target state="translated">테이블, 함수, 스레드 및 (전체) userdata 값은 &lt;em&gt;객체입니다&lt;/em&gt; . 변수는 실제로 이러한 값을 &lt;em&gt;포함&lt;/em&gt; 하지 않으며 해당 값만 &lt;em&gt;참조&lt;/em&gt; 합니다. 대입, 매개 변수 전달 및 함수 리턴은 항상 이러한 값에 대한 참조를 조작합니다. 이러한 작업은 어떠한 종류의 복사도 의미하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="669e76ec887de715ba103acde30a3797fae1f331" translate="yes" xml:space="preserve">
          <source>Tables, userdata, and threads are compared by reference: two objects are considered equal only if they are the same object. Every time you create a new object (a table, a userdata, or a thread), this new object is different from any previously existing object. A function is always equal to itself. Functions with any detectable difference (different behavior, different definition) are always different. Functions created at different times but with no detectable differences may be classified as equal or not (depending on internal caching details).</source>
          <target state="translated">테이블, 사용자 데이터 및 스레드는 참조로 비교됩니다. 두 개체는 동일한 개체 인 경우에만 동일한 것으로 간주됩니다. 새 개체 (테이블, 사용자 데이터 또는 스레드)를 만들 때마다이 새 개체는 이전의 기존 개체와 다릅니다. 함수는 항상 자신과 같습니다. 감지 가능한 차이 (다른 동작, 다른 정의)가있는 함수는 항상 다릅니다. 서로 다른 시간에 생성되었지만 감지 할 수있는 차이가없는 함수는 같거나 같지 않은 것으로 분류 될 수 있습니다 (내부 캐싱 세부 정보에 따라 다름).</target>
        </trans-unit>
        <trans-unit id="99385b30015343b5b8e00056e58a762956df3e7d" translate="yes" xml:space="preserve">
          <source>Tables, userdata, and threads are compared by reference: two objects are considered equal only if they are the same object. Every time you create a new object (a table, userdata, or thread), this new object is different from any previously existing object. Closures with the same reference are always equal. Closures with any detectable difference (different behavior, different definition) are always different.</source>
          <target state="translated">테이블, 사용자 데이터 및 스레드는 참조로 비교됩니다. 두 객체는 ​​동일한 객체 인 경우에만 동일한 것으로 간주됩니다. 새 개체 (테이블, 사용자 데이터 또는 스레드)를 만들 때마다이 새 개체는 기존 개체와 다릅니다. 동일한 참조의 클로저는 항상 같습니다. 감지 가능한 차이 (다른 동작, 다른 정의)를 가진 클로저는 항상 다릅니다.</target>
        </trans-unit>
        <trans-unit id="446beb4016f56d03fb7aeada345cb1a7a86ea482" translate="yes" xml:space="preserve">
          <source>Terminates the last protected function called and returns &lt;code&gt;message&lt;/code&gt; as the error object. Function &lt;code&gt;error&lt;/code&gt; never returns.</source>
          <target state="translated">마지막으로 호출 된 보호 된 기능을 종료하고 오류 객체 로 &lt;code&gt;message&lt;/code&gt; 를 반환 합니다. 함수 &lt;code&gt;error&lt;/code&gt; 절대로 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aad621a873e57ea830369714dc4bd782c2449476" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#lua_pcall&quot;&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt; function returns one of the following constants (defined in &lt;code&gt;lua.h&lt;/code&gt;):</source>
          <target state="translated">&lt;a href=&quot;#lua_pcall&quot;&gt; &lt;code&gt;lua_pcall&lt;/code&gt; 의&lt;/a&gt; 기능은 다음 상수 중 하나 (정의 반환 &lt;code&gt;lua.h&lt;/code&gt; ) :</target>
        </trans-unit>
        <trans-unit id="c9f4dcc9b6adcf3724a0f1527ff15ababb77be1a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#lua_pcall&quot;&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt; function returns one of the following status codes: &lt;a href=&quot;#pdf-LUA_OK&quot;&gt;&lt;code&gt;LUA_OK&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pdf-LUA_ERRRUN&quot;&gt;&lt;code&gt;LUA_ERRRUN&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pdf-LUA_ERRMEM&quot;&gt;&lt;code&gt;LUA_ERRMEM&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#pdf-LUA_ERRERR&quot;&gt;&lt;code&gt;LUA_ERRERR&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#lua_pcall&quot;&gt; &lt;code&gt;lua_pcall&lt;/code&gt; 의&lt;/a&gt; 함수가 반환 다음 상태 코드 중 하나를 &lt;a href=&quot;#pdf-LUA_OK&quot;&gt; &lt;code&gt;LUA_OK&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#pdf-LUA_ERRRUN&quot;&gt; &lt;code&gt;LUA_ERRRUN&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#pdf-LUA_ERRMEM&quot;&gt; &lt;code&gt;LUA_ERRMEM&lt;/code&gt; &lt;/a&gt; , 또는 &lt;a href=&quot;#pdf-LUA_ERRERR&quot;&gt; &lt;code&gt;LUA_ERRERR&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b1d59a96e495b4ed1314e7a452acf7cf2be3dd16" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#pdf-ipairs&quot;&gt;&lt;code&gt;ipairs&lt;/code&gt;&lt;/a&gt; iterator now respects metamethods and its &lt;code&gt;__ipairs&lt;/code&gt; metamethod has been deprecated.</source>
          <target state="translated">&lt;a href=&quot;#pdf-ipairs&quot;&gt; &lt;code&gt;ipairs&lt;/code&gt; &lt;/a&gt; 반복자 이제 측면의 메타 메서드와 &lt;code&gt;__ipairs&lt;/code&gt; 사용되지 않습니다 메타 메소드.</target>
        </trans-unit>
        <trans-unit id="bc47dc2ae4b1f24c3a3899f4b1f9405cda8bd057" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;break&lt;/b&gt; statement terminates the execution of a &lt;b&gt;while&lt;/b&gt;, &lt;b&gt;repeat&lt;/b&gt;, or &lt;b&gt;for&lt;/b&gt; loop, skipping to the next statement after the loop:</source>
          <target state="translated">&lt;b&gt;휴식&lt;/b&gt; 문은 실행 종료 &lt;b&gt;하는 동안&lt;/b&gt; , &lt;b&gt;반복&lt;/b&gt; , 또는 &lt;b&gt;에 대한&lt;/b&gt; 루프 후 다음 명령문을 건너 뛰고, 루프 :</target>
        </trans-unit>
        <trans-unit id="be57b4db5d11ecd50b150a3c2c7baa57bca94b87" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;for&lt;/b&gt; statement has two forms: one numerical and one generic.</source>
          <target state="translated">&lt;b&gt;에 대한&lt;/b&gt; 하나 개의 숫자와 하나의 일반적인 : 문은 두 가지 형태가있다.</target>
        </trans-unit>
        <trans-unit id="b061702cc21366ebd955da1cbb0818c2844543b8" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;goto&lt;/b&gt; statement transfers the program control to a label. For syntactical reasons, labels in Lua are considered statements too:</source>
          <target state="translated">&lt;b&gt;고토&lt;/b&gt; 문은 레이블 프로그램 제어를 전송합니다. 구문상의 이유로 Lua의 레이블은 다음과 같은 진술로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="eeaa513ac2a2fd15596d8309fe530d856f6a61e0" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;return&lt;/b&gt; statement can only be written as the last statement of a block. If it is necessary to &lt;b&gt;return&lt;/b&gt; in the middle of a block, then an explicit inner block can be used, as in the idiom &lt;code&gt;do return end&lt;/code&gt;, because now &lt;b&gt;return&lt;/b&gt; is the last statement in its (inner) block.</source>
          <target state="translated">&lt;b&gt;리턴&lt;/b&gt; 명령문은 블록의 마지막 문장으로 쓸 수 있습니다. 이 필요한 경우 &lt;b&gt;반환&lt;/b&gt; 블록의 중간에 관용구처럼, 다음 명시적인 내부 블록은 사용할 수 &lt;code&gt;do return end&lt;/code&gt; 해주기 때문에, &lt;b&gt;반환&lt;/b&gt; 의 (내부) 블록의 마지막 문입니다.</target>
        </trans-unit>
        <trans-unit id="b8c9f54acbc996a7d79b7252d182ed631a6a317f" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;return&lt;/b&gt; statement can only be written as the last statement of a block. If it is really necessary to &lt;b&gt;return&lt;/b&gt; in the middle of a block, then an explicit inner block can be used, as in the idiom &lt;code&gt;do return end&lt;/code&gt;, because now &lt;b&gt;return&lt;/b&gt; is the last statement in its (inner) block.</source>
          <target state="translated">&lt;b&gt;리턴&lt;/b&gt; 명령문은 블록의 마지막 문장으로 쓸 수 있습니다. 정말 필요한 경우 &lt;b&gt;반환&lt;/b&gt; 블록의 중간에 관용구처럼, 다음 명시적인 내부 블록은 사용할 수 &lt;code&gt;do return end&lt;/code&gt; 해주기 때문에, &lt;b&gt;반환&lt;/b&gt; 의 (내부) 블록의 마지막 문입니다.</target>
        </trans-unit>
        <trans-unit id="c44e88f5118a01354e009d7fa35997d3c87c7c1a" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;return&lt;/b&gt; statement is used to return values from a function or a chunk (which is an anonymous function). Functions can return more than one value, so the syntax for the &lt;b&gt;return&lt;/b&gt; statement is</source>
          <target state="translated">&lt;b&gt;리턴&lt;/b&gt; 명령문 함수 또는 (익명 함수) 덩어리의 값을 반환하는 데 사용된다. 함수는 둘 이상의 값을 반환 할 수 있으므로 &lt;b&gt;return&lt;/b&gt; 문의 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="50d916d7e4fcf57b5d8ca62cda2c1b54e390dceb" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;return&lt;/b&gt; statement is used to return values from a function or a chunk (which is handled as an anonymous function). Functions can return more than one value, so the syntax for the &lt;b&gt;return&lt;/b&gt; statement is</source>
          <target state="translated">&lt;b&gt;리턴&lt;/b&gt; 명령문 함수 또는 (익명의 함수로서 처리된다) 덩어리의 값을 반환하는 데 사용된다. 함수는 둘 이상의 값을 반환 할 수 있으므로 &lt;b&gt;return&lt;/b&gt; 문의 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2b646ffbbdcd054326d494ba2f5c649f95d36297" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bit32&lt;/code&gt; library has been deprecated. It is easy to require a compatible external library or, better yet, to replace its functions with appropriate bitwise operations. (Keep in mind that &lt;code&gt;bit32&lt;/code&gt; operates on 32-bit integers, while the bitwise operators in Lua 5.3 operate on Lua integers, which by default have 64 bits.)</source>
          <target state="translated">&lt;code&gt;bit32&lt;/code&gt; 의 라이브러리는 더 이상 사용되지 않습니다. 호환되는 외부 라이브러리가 필요하거나 기능을 적절한 비트 단위 연산으로 대체하는 것이 더 쉽습니다. ( &lt;code&gt;bit32&lt;/code&gt; 는 32 비트 정수에서 작동하는 반면 Lua 5.3의 비트 연산자는 기본적으로 64 비트 인 Lua 정수에서 작동합니다.)</target>
        </trans-unit>
        <trans-unit id="768417f6f84362fdef7cb578c8c372a00d6776b3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;chunkname&lt;/code&gt; argument gives a name to the chunk, which is used for error messages and in debug information (see &lt;a href=&quot;#4.7&quot;&gt;&amp;sect;4.7&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;chunkname&lt;/code&gt; 의 인수는 오류 메시지와 디버그 정보에 사용되는 덩어리에 이름을 제공합니다 ( &lt;a href=&quot;#4.7&quot;&gt;&amp;sect;4.7을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="3c35b56166af83b28a7e0e22c5d357b538f84788" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;chunkname&lt;/code&gt; argument gives a name to the chunk, which is used for error messages and in debug information (see &lt;a href=&quot;#4.9&quot;&gt;&amp;sect;4.9&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;chunkname&lt;/code&gt; 의 인수는 오류 메시지와 디버그 정보에 사용되는 덩어리에 이름을 제공합니다 ( &lt;a href=&quot;#4.9&quot;&gt;&amp;sect;4.9을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="bae62f5a0575c4f5ff2aabe5bf99d9776f3199b2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lua_load&lt;/code&gt; function uses a user-supplied &lt;code&gt;reader&lt;/code&gt; function to read the chunk (see &lt;a href=&quot;#lua_Reader&quot;&gt;&lt;code&gt;lua_Reader&lt;/code&gt;&lt;/a&gt;). The &lt;code&gt;data&lt;/code&gt; argument is an opaque value passed to the reader function.</source>
          <target state="translated">&lt;code&gt;lua_load&lt;/code&gt; 의 기능은 사용자가 제공하는 사용 &lt;code&gt;reader&lt;/code&gt; (참조 청크를 읽는 기능 &lt;a href=&quot;#lua_Reader&quot;&gt; &lt;code&gt;lua_Reader&lt;/code&gt; 을&lt;/a&gt; ). &lt;code&gt;data&lt;/code&gt; 인자 리더 함수에 전달 된 불투명 값이다.</target>
        </trans-unit>
        <trans-unit id="85f9907ce6878c8dc7e267337764d4964c7fae3c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mode&lt;/code&gt; string can also have a '&lt;code&gt;b&lt;/code&gt;' at the end, which is needed in some systems to open the file in binary mode.</source>
          <target state="translated">&lt;code&gt;mode&lt;/code&gt; 문자열은 또한 '수 &lt;code&gt;b&lt;/code&gt; 바이너리 모드로 파일을 열려면 어떤 시스템에 필요한 끝에서'를.</target>
        </trans-unit>
        <trans-unit id="2688f69f4c7b22c66219e46ee16c2eac721dcdfd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mode&lt;/code&gt; string can be any of the following:</source>
          <target state="translated">&lt;code&gt;mode&lt;/code&gt; 문자열은 다음 중 하나가 될 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="dcce9d1975851c844f7c2f304003970e38bff938" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;q&lt;/code&gt; option formats a string between double quotes, using escape sequences when necessary to ensure that it can safely be read back by the Lua interpreter. For instance, the call</source>
          <target state="translated">&lt;code&gt;q&lt;/code&gt; 옵션은 안전하게 루아 인터프리터에 의해 읽기 돌아올 수 있도록 필요한 경우 이스케이프 시퀀스를 사용하여 따옴표 사이의 문자열을 포맷합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="ab9206bbe0932c07e692d615d61a36493a13a496" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;auxiliary library&lt;/em&gt; provides several convenient functions to interface C with Lua. While the basic API provides the primitive functions for all interactions between C and Lua, the auxiliary library provides higher-level functions for some common tasks.</source>
          <target state="translated">&lt;em&gt;보조 라이브러리는&lt;/em&gt; 루아와 C를 인터페이스에 여러 가지 편리한 기능을 제공합니다. 기본 API는 C와 Lua 사이의 모든 상호 작용에 대한 기본 기능을 제공하지만 보조 라이브러리는 일부 공통 태스크에 대한 상위 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8ab6afc13be0118f613c20671f20dcaa66bf50fe" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;block&lt;/em&gt; is repeated for &lt;em&gt;name&lt;/em&gt; starting at the value of the first &lt;em&gt;exp&lt;/em&gt;, until it passes the second &lt;em&gt;exp&lt;/em&gt; by steps of the third &lt;em&gt;exp&lt;/em&gt;. More precisely, a &lt;b&gt;for&lt;/b&gt; statement like</source>
          <target state="translated">&lt;em&gt;블록&lt;/em&gt; 에 대해 반복되는 &lt;em&gt;이름&lt;/em&gt; 제의 값에서 시작 &lt;em&gt;EXP&lt;/em&gt; 은 제 통과 할 때까지, &lt;em&gt;EXP&lt;/em&gt; 세번째 단계에 의해 &lt;em&gt;Exp를&lt;/em&gt; . 보다 정확하게 &lt;b&gt;는&lt;/b&gt; 다음과 같은 &lt;b&gt;for&lt;/b&gt; 문</target>
        </trans-unit>
        <trans-unit id="d3b254f35dcb5161307fc6d343f99ec868c9f36b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;colon&lt;/em&gt; syntax is used for defining &lt;em&gt;methods&lt;/em&gt;, that is, functions that have an implicit extra parameter &lt;code&gt;self&lt;/code&gt;. Thus, the statement</source>
          <target state="translated">&lt;em&gt;대장&lt;/em&gt; 구문 정의하기 위해 사용되는 &lt;em&gt;방법&lt;/em&gt; 인, 암시 추가 파라미터가 기능 &lt;code&gt;self&lt;/code&gt; . 따라서 진술</target>
        </trans-unit>
        <trans-unit id="f572f282cad30118a92f64a8c2a8e8b7d0ba81c2" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;colon&lt;/em&gt; syntax is used to emulate &lt;em&gt;methods&lt;/em&gt;, adding an implicit extra parameter &lt;code&gt;self&lt;/code&gt; to the function. Thus, the statement</source>
          <target state="translated">&lt;em&gt;대장&lt;/em&gt; 구문 에뮬레이트 사용 &lt;em&gt;방법&lt;/em&gt; 암시 추가 파라미터 추가 &lt;code&gt;self&lt;/code&gt; 기능을한다. 따라서 진술</target>
        </trans-unit>
        <trans-unit id="6d7a7980421d2b17bd0aed9b9a529fd71ecec0a9" translate="yes" xml:space="preserve">
          <source>The I/O library provides two different styles for file manipulation. The first one uses implicit file handles; that is, there are operations to set a default input file and a default output file, and all input/output operations are done over these default files. The second style uses explicit file handles.</source>
          <target state="translated">I / O 라이브러리는 파일 조작을위한 두 가지 스타일을 제공합니다. 첫 번째는 암시 적 파일 핸들을 사용합니다. 즉, 기본 입력 파일과 기본 출력 파일을 설정하는 작업이 있으며 모든 입력 / 출력 작업은 이러한 기본 파일을 통해 수행됩니다. 두 번째 스타일은 명시 적 파일 핸들을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="171411617a28d7de2b0226c80067f77ec30897f7" translate="yes" xml:space="preserve">
          <source>The I/O library provides two different styles for file manipulation. The first one uses implicit file handles; that is, there are operations to set a default input file and a default output file, and all input/output operations are over these default files. The second style uses explicit file handles.</source>
          <target state="translated">I / O 라이브러리는 파일 조작을 위해 서로 다른 두 가지 스타일을 제공합니다. 첫 번째는 암시 적 파일 핸들을 사용합니다. 즉, 기본 입력 파일과 기본 출력 파일을 설정하는 작업이 있으며 모든 입력 / 출력 작업이이 기본 파일을 초과합니다. 두 번째 스타일은 명시 적 파일 핸들을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="fe26bd92623ecffd0ef5b0b7681c64345000ef38" translate="yes" xml:space="preserve">
          <source>The Length Operator</source>
          <target state="translated">길이 연산자</target>
        </trans-unit>
        <trans-unit id="b46439f6fc2b5220d043e60a0c5b1b7e77db627e" translate="yes" xml:space="preserve">
          <source>The Lua library is fully reentrant: it has no global variables. It keeps all information it needs in a dynamic structure, called the &lt;em&gt;Lua state&lt;/em&gt;.</source>
          <target state="translated">Lua 라이브러리는 완전히 재진입됩니다. 전역 변수가 없습니다. 필요한 모든 정보를 &lt;em&gt;Lua state&lt;/em&gt; 라는 동적 구조로 유지합니다 .</target>
        </trans-unit>
        <trans-unit id="07b128e0f94f3f9a107ec1b9a4411b8083a41fce" translate="yes" xml:space="preserve">
          <source>The Table library now respects metamethods for setting and getting elements.</source>
          <target state="translated">테이블 라이브러리는 이제 요소를 설정하고 가져 오기위한 메타 메소드를 존중합니다.</target>
        </trans-unit>
        <trans-unit id="eb554fe048e1c8b347ad8a3da87d434c8b60f5db" translate="yes" xml:space="preserve">
          <source>The UTF-8 encoding of a Unicode character can be inserted in a literal string with the escape sequence &lt;code&gt;\u{&lt;em&gt;XXX&lt;/em&gt;}&lt;/code&gt; (note the mandatory enclosing brackets), where &lt;em&gt;XXX&lt;/em&gt; is a sequence of one or more hexadecimal digits representing the character code point.</source>
          <target state="translated">유니 코드 문자의 UTF-8 인코딩은 이스케이프 시퀀스 &lt;code&gt;\u{&lt;em&gt;XXX&lt;/em&gt;}&lt;/code&gt; (필수로 묶는 괄호) 를 사용하여 리터럴 문자열에 삽입 할 수 있습니다 . 여기서 &lt;em&gt;XXX&lt;/em&gt; 는 문자 코드 포인트를 나타내는 하나 이상의 16 진수 시퀀스입니다.</target>
        </trans-unit>
        <trans-unit id="133b64cb1acd8fa4b0993eef50a3ec5beecc6e3a" translate="yes" xml:space="preserve">
          <source>The UTF-8 encoding of a Unicode character can be inserted in a literal string with the escape sequence &lt;code&gt;\u{&lt;em&gt;XXX&lt;/em&gt;}&lt;/code&gt; (with mandatory enclosing braces), where &lt;em&gt;XXX&lt;/em&gt; is a sequence of one or more hexadecimal digits representing the character code point. This code point can be any value less than &lt;em&gt;2&lt;sup&gt;31&lt;/sup&gt;&lt;/em&gt;. (Lua uses the original UTF-8 specification here, which is not restricted to valid Unicode code points.)</source>
          <target state="translated">유니 코드 문자의 UTF-8 인코딩은 이스케이프 시퀀스 &lt;code&gt;\u{&lt;em&gt;XXX&lt;/em&gt;}&lt;/code&gt; (필수 묶음 중괄호 포함) 를 사용하여 리터럴 문자열에 삽입 할 수 있습니다 . 여기서 &lt;em&gt;XXX&lt;/em&gt; 는 문자 코드 포인트를 나타내는 하나 이상의 16 진수 시퀀스입니다. 이 코드 포인트는 &lt;em&gt;2 &lt;sup&gt;31&lt;/sup&gt;&lt;/em&gt; 보다 작은 값일 수 있습니다 . (Lua는 여기서 유효한 유니 코드 코드 포인트로 제한되지 않는 원래 UTF-8 사양을 사용합니다.)</target>
        </trans-unit>
        <trans-unit id="3e71c6008a2054b02c7458c10af8db199b93e0fc" translate="yes" xml:space="preserve">
          <source>The array &lt;code&gt;l&lt;/code&gt; must be the actual array, not a pointer to it.</source>
          <target state="translated">배열 &lt;code&gt;l&lt;/code&gt; 은 포인터가 아닌 실제 배열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="ec4ef8ac03868996fbe27096f10720a2a635fd47" translate="yes" xml:space="preserve">
          <source>The assignment statement first evaluates all its expressions and only then the assignments are performed. Thus the code</source>
          <target state="translated">대 입문은 먼저 모든 표현식을 평가 한 후에 만 ​​대입을 수행합니다. 따라서 코드</target>
        </trans-unit>
        <trans-unit id="63ea036976be25a6fccc44715a31648a894a2cd9" translate="yes" xml:space="preserve">
          <source>The available formats are</source>
          <target state="translated">사용 가능한 형식은</target>
        </trans-unit>
        <trans-unit id="1bf5ee36dda4ba103acec9799a8f08fe38658693" translate="yes" xml:space="preserve">
          <source>The basic expressions in Lua are the following:</source>
          <target state="translated">루아의 기본 표현은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a90f0e6ef32f54b398b228c2483c97e99f92d4d7" translate="yes" xml:space="preserve">
          <source>The basic library provides core functions to Lua. If you do not include this library in your application, you should check carefully whether you need to provide implementations for some of its facilities.</source>
          <target state="translated">기본 라이브러리는 Lua에 핵심 기능을 제공합니다. 응용 프로그램에이 라이브러리를 포함하지 않으면 일부 기능에 대한 구현을 제공해야하는지 신중하게 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="6a4e9c1cd28f7989f62ba005ba19f087fc3592ba" translate="yes" xml:space="preserve">
          <source>The behavior of &lt;code&gt;next&lt;/code&gt; is undefined if, during the traversal, you assign any value to a non-existent field in the table. You may however modify existing fields. In particular, you may clear existing fields.</source>
          <target state="translated">순회 중에 테이블의 존재하지 않는 필드에 값을 지정하면 &lt;code&gt;next&lt;/code&gt; 동작 이 정의되지 않습니다. 그러나 기존 필드를 수정할 수 있습니다. 특히 기존 필드를 지울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff207200b1250dc2b47ca5a7a827de1d648909f3" translate="yes" xml:space="preserve">
          <source>The behavior of &lt;code&gt;next&lt;/code&gt; is undefined if, during the traversal, you assign any value to a non-existent field in the table. You may however modify existing fields. In particular, you may set existing fields to nil.</source>
          <target state="translated">순회 중에 테이블에 존재하지 않는 필드에 값을 할당하면 &lt;code&gt;next&lt;/code&gt; 의 동작 은 정의되지 않습니다. 그러나 기존 필드를 수정할 수 있습니다. 특히 기존 필드를 nil로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0dc90ae531b088f04f67083e165dbcb68af23283" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;collectgarbage(&quot;count&quot;)&lt;/code&gt; now returns only one result. (You can compute that second result from the fractional part of the first result.)</source>
          <target state="translated">&lt;code&gt;collectgarbage(&quot;count&quot;)&lt;/code&gt; 호출은 이제 하나의 결과 만 리턴합니다. 첫 번째 결과의 소수 부분에서 두 번째 결과를 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c68441a4203b3cd2bfe34776a10e03a400a467cb" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;io.lines()&lt;/code&gt; (with no file name) is equivalent to &lt;code&gt;io.input():lines(&quot;*l&quot;)&lt;/code&gt;; that is, it iterates over the lines of the default input file. In this case it does not close the file when the loop ends.</source>
          <target state="translated">&lt;code&gt;io.lines()&lt;/code&gt; 호출 ( 파일 이름 없음)은 &lt;code&gt;io.input():lines(&quot;*l&quot;)&lt;/code&gt; 와 같습니다. 즉, 기본 입력 파일의 행을 반복합니다. 이 경우 루프가 종료 될 때 파일을 닫지 않습니다.</target>
        </trans-unit>
        <trans-unit id="56312b3ed08e17201e15d0358b34f5524a82475c" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;io.lines()&lt;/code&gt; (with no file name) is equivalent to &lt;code&gt;io.input():lines(&quot;l&quot;)&lt;/code&gt;; that is, it iterates over the lines of the default input file. In this case, the iterator does not close the file when the loop ends.</source>
          <target state="translated">&lt;code&gt;io.lines()&lt;/code&gt; 호출 ( 파일 이름 없음)은 &lt;code&gt;io.input():lines(&quot;l&quot;)&lt;/code&gt; 와 동일합니다. 즉, 기본 입력 파일의 행을 반복합니다. 이 경우 반복기는 루프가 끝날 때 파일을 닫지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3e4ad773c547ffbe50168aed20636ff53516332e" translate="yes" xml:space="preserve">
          <source>The closing value behaves like a to-be-closed variable (see &lt;a href=&quot;#3.3.8&quot;&gt;&amp;sect;3.3.8&lt;/a&gt;), which can be used to release resources when the loop ends. Otherwise, it does not interfere with the loop.</source>
          <target state="translated">닫는 값은 루프가 끝날 때 리소스를 해제하는 데 사용할 수있는 닫힐 변수 ( &lt;a href=&quot;#3.3.8&quot;&gt;&amp;sect;3.3.8&lt;/a&gt; 참조 ) 처럼 동작 합니다. 그렇지 않으면 루프를 방해하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="798511549246488486c822aec3e1cc74d4fe6a5b" translate="yes" xml:space="preserve">
          <source>The coercion of strings to numbers in arithmetic and bitwise operations has been removed from the core language. The string library does a similar job for arithmetic (but not for bitwise) operations using the string metamethods. However, unlike in previous versions, the new implementation preserves the implicit type of the numeral in the string. For instance, the result of &lt;code&gt;&quot;1&quot; + &quot;2&quot;&lt;/code&gt; now is an integer, not a float.</source>
          <target state="translated">산술 및 비트 연산에서 문자열을 숫자로 강제 변환하는 기능이 핵심 언어에서 제거되었습니다. 문자열 라이브러리는 문자열 메타 메서드를 사용하여 산술 (비트 단위 아님) 연산에 대해 유사한 작업을 수행합니다. 그러나 이전 버전과 달리 새로운 구현은 문자열에서 암시 적 숫자 유형을 유지합니다. 예를 들어 &lt;code&gt;&quot;1&quot; + &quot;2&quot;&lt;/code&gt; 의 결과는 이제 부동 소수점이 아닌 정수입니다.</target>
        </trans-unit>
        <trans-unit id="ef37fdd6b0b5e41eab32a9928b1d9217a2a5737b" translate="yes" xml:space="preserve">
          <source>The computation of the length of a table has a guaranteed worst time of &lt;em&gt;O(log n)&lt;/em&gt;, where &lt;em&gt;n&lt;/em&gt; is the largest natural key in the table.</source>
          <target state="translated">테이블 길이 계산시 최악의 &lt;em&gt;O (log n)&lt;/em&gt; 시간이 보장 되며, 여기서 &lt;em&gt;n&lt;/em&gt; 은 테이블에서 가장 큰 자연 키입니다.</target>
        </trans-unit>
        <trans-unit id="0b56d75e0be562bbdd8ce192220fca509ed349d6" translate="yes" xml:space="preserve">
          <source>The condition expression of a control structure can return any value. Both &lt;b&gt;false&lt;/b&gt; and &lt;b&gt;nil&lt;/b&gt; are considered false. All values different from &lt;b&gt;nil&lt;/b&gt; and &lt;b&gt;false&lt;/b&gt; are considered true (in particular, the number 0 and the empty string are also true).</source>
          <target state="translated">제어 구조의 조건식은 모든 값을 리턴 할 수 있습니다. &lt;b&gt;false&lt;/b&gt; 와 &lt;b&gt;nil&lt;/b&gt; 은 모두 &lt;b&gt;false&lt;/b&gt; 로 간주됩니다. &lt;b&gt;nil&lt;/b&gt; 및 &lt;b&gt;false&lt;/b&gt; 와 다른 모든 값 은 true로 간주됩니다 (특히 숫자 0 및 빈 문자열도 true).</target>
        </trans-unit>
        <trans-unit id="3b920454c4c1d2c03393d9ac78ec720b9fbaa526" translate="yes" xml:space="preserve">
          <source>The condition expression of a control structure can return any value. Both &lt;b&gt;false&lt;/b&gt; and &lt;b&gt;nil&lt;/b&gt; test false. All values different from &lt;b&gt;nil&lt;/b&gt; and &lt;b&gt;false&lt;/b&gt; test true. In particular, the number 0 and the empty string also test true.</source>
          <target state="translated">제어 구조의 조건식은 모든 값을 리턴 할 수 있습니다. &lt;b&gt;false&lt;/b&gt; 와 &lt;b&gt;nil&lt;/b&gt; 모두 &lt;b&gt;false&lt;/b&gt; 를 테스트합니다. &lt;b&gt;nil&lt;/b&gt; 및 &lt;b&gt;false&lt;/b&gt; 와 다른 모든 값은 &lt;b&gt;true를&lt;/b&gt; 테스트합니다. 특히 숫자 0과 빈 문자열도 참을 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="ec24a70490264f051fb6d0ae4a587a4f8d0e22eb" translate="yes" xml:space="preserve">
          <source>The constant &lt;code&gt;LUA_ERRGCMM&lt;/code&gt; was removed. Errors in finalizers are never propagated; instead, they generate a warning.</source>
          <target state="translated">상수 &lt;code&gt;LUA_ERRGCMM&lt;/code&gt; 이 제거되었습니다. 종료 자의 오류는 전파되지 않습니다. 대신 경고를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="c3733f14fe1543e4589c9195fb66e8ff53166d2c" translate="yes" xml:space="preserve">
          <source>The control structures &lt;b&gt;if&lt;/b&gt;, &lt;b&gt;while&lt;/b&gt;, and &lt;b&gt;repeat&lt;/b&gt; have the usual meaning and familiar syntax:</source>
          <target state="translated">제어 구조 &lt;b&gt;if&lt;/b&gt; , &lt;b&gt;while&lt;/b&gt; 및 &lt;b&gt;repeat&lt;/b&gt; 는 일반적인 의미와 익숙한 구문을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="fd0c2e7539b39e7334ffb646988e686084be276b" translate="yes" xml:space="preserve">
          <source>The conversion from float to integer checks whether the float has an exact representation as an integer (that is, the float has an integral value and it is in the range of integer representation). If it does, that representation is the result. Otherwise, the conversion fails.</source>
          <target state="translated">float에서 integer 로의 변환은 float가 정수로 정확한 표현을 가지고 있는지 (즉, float는 정수 값을 가지며 정수 표현 범위에 있는지)를 확인합니다. 그렇다면 그 표현이 결과입니다. 그렇지 않으면 변환이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="2672e5ddb4380b4a0e9162708d0ffacc1d9552f5" translate="yes" xml:space="preserve">
          <source>The conversion from numbers to strings uses a non-specified human-readable format. For complete control over how numbers are converted to strings, use the &lt;code&gt;format&lt;/code&gt; function from the string library (see &lt;a href=&quot;#pdf-string.format&quot;&gt;&lt;code&gt;string.format&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">숫자에서 문자열로의 변환은 지정되지 않은 사람이 읽을 수있는 형식을 사용합니다. 숫자를 문자열로 변환하는 방법을 완전히 제어 하려면 문자열 라이브러리에서 &lt;code&gt;format&lt;/code&gt; 함수를 사용 하십시오 ( &lt;a href=&quot;#pdf-string.format&quot;&gt; &lt;code&gt;string.format&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="d7eef57d5a172c39981c5ce7311c830825d6249b" translate="yes" xml:space="preserve">
          <source>The conversion from numbers to strings uses a non-specified human-readable format. To convert numbers to strings in any specific way, use the function &lt;a href=&quot;#pdf-string.format&quot;&gt;&lt;code&gt;string.format&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">숫자에서 문자열로의 변환은 사람이 읽을 수있는 지정되지 않은 형식을 사용합니다. 특정 방식으로 숫자를 문자열로 변환하려면 &lt;a href=&quot;#pdf-string.format&quot;&gt; &lt;code&gt;string.format&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e4fc8189f226b883ce5f116eb5b865021736d178" translate="yes" xml:space="preserve">
          <source>The conversion from strings to numbers goes as follows: First, the string is converted to an integer or a float, following its syntax and the rules of the Lua lexer. (The string may have also leading and trailing spaces and a sign.) Then, the resulting number (float or integer) is converted to the type (float or integer) required by the context (e.g., the operation that forced the conversion).</source>
          <target state="translated">문자열에서 숫자로의 변환은 다음과 같습니다. 첫째, 문자열은 구문과 Lua lexer 규칙에 따라 정수 또는 부동 소수점으로 변환됩니다. 문자열에는 선행 및 후행 공백과 부호가있을 수 있습니다. 그런 다음 결과 숫자 (부동 또는 정수)가 컨텍스트에 필요한 유형 (부동 또는 정수)으로 변환됩니다 (예 : 변환을 강제 한 연산).</target>
        </trans-unit>
        <trans-unit id="f171e574fe61e971bf96a3990d066bb469d0ea25" translate="yes" xml:space="preserve">
          <source>The conversion of a float to a string now adds a &lt;code&gt;.0&lt;/code&gt; suffix to the result if it looks like an integer. (For instance, the float 2.0 will be printed as &lt;code&gt;2.0&lt;/code&gt;, not as &lt;code&gt;2&lt;/code&gt;.) You should always use an explicit format when you need a specific format for numbers.</source>
          <target state="translated">float를 문자열로 변환 하면 정수처럼 보이는 경우 결과에 &lt;code&gt;.0&lt;/code&gt; 접미사가 추가 됩니다. 예를 들어 float 2.0은 &lt;code&gt;2&lt;/code&gt; 가 아닌 &lt;code&gt;2.0&lt;/code&gt; 으로 인쇄됩니다 . 숫자에 특정 형식이 필요할 때는 항상 명시 적 형식을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="fde25091233105fea6baa5683b61b7b5603b3cd0" translate="yes" xml:space="preserve">
          <source>The conversion of strings can result in integers or floats, according to the lexical conventions of Lua (see &lt;a href=&quot;#3.1&quot;&gt;&amp;sect;3.1&lt;/a&gt;). (The string may have leading and trailing spaces and a sign.)</source>
          <target state="translated">Lua의 어휘 규칙에 따라 문자열을 변환하면 정수 또는 부동 소수점이 발생할 수 있습니다 ( &lt;a href=&quot;#3.1&quot;&gt;&amp;sect;3.1&lt;/a&gt; 참조 ). (문자열에는 앞뒤 공백과 부호가있을 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="8a7deb37cbfaea7e8697ec963b8057a9bed112e3" translate="yes" xml:space="preserve">
          <source>The conversion of strings can result in integers or floats, according to the lexical conventions of Lua (see &lt;a href=&quot;#3.1&quot;&gt;&amp;sect;3.1&lt;/a&gt;). The string may have leading and trailing spaces and a sign.</source>
          <target state="translated">문자열 변환은 Lua의 어휘 규칙에 따라 정수 또는 부동 소수점이 될 수 있습니다 ( &lt;a href=&quot;#3.1&quot;&gt;&amp;sect;3.1&lt;/a&gt; 참조 ). 문자열에는 선행 및 후행 공백과 기호가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2779abe0bdda569ab2443dd1aeb2c757f08c9877" translate="yes" xml:space="preserve">
          <source>The conversion specifiers &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;E&lt;/code&gt;, &lt;code&gt;e&lt;/code&gt;, &lt;code&gt;f&lt;/code&gt;, &lt;code&gt;G&lt;/code&gt;, and &lt;code&gt;g&lt;/code&gt; all expect a number as argument. The specifiers &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;d&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;o&lt;/code&gt;, &lt;code&gt;u&lt;/code&gt;, &lt;code&gt;X&lt;/code&gt;, and &lt;code&gt;x&lt;/code&gt; expect an integer. When Lua is compiled with a C89 compiler, the specifiers &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; (hexadecimal floats) do not support modifiers.</source>
          <target state="translated">변환 지정자 &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;E&lt;/code&gt; , &lt;code&gt;e&lt;/code&gt; , &lt;code&gt;f&lt;/code&gt; , &lt;code&gt;G&lt;/code&gt; , &lt;code&gt;g&lt;/code&gt; 는 모두 숫자를 인수로 예상합니다. 지정자 &lt;code&gt;c&lt;/code&gt; , &lt;code&gt;d&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;o&lt;/code&gt; , &lt;code&gt;u&lt;/code&gt; , &lt;code&gt;X&lt;/code&gt; , &lt;code&gt;x&lt;/code&gt; 는 정수를 예상합니다. Lua가 C89 컴파일러로 컴파일 될 때 지정자 &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;a&lt;/code&gt; (16 진수 부동 소수점)는 수정자를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4a41a1a32246a11826a5d6e075e45733f76f3306" translate="yes" xml:space="preserve">
          <source>The conversion specifiers are quite restricted. There are no flags, widths, or precisions. The conversion specifiers can only be '&lt;code&gt;%%&lt;/code&gt;' (inserts the character '&lt;code&gt;%&lt;/code&gt;'), '&lt;code&gt;%s&lt;/code&gt;' (inserts a zero-terminated string, with no size restrictions), '&lt;code&gt;%f&lt;/code&gt;' (inserts a &lt;a href=&quot;#lua_Number&quot;&gt;&lt;code&gt;lua_Number&lt;/code&gt;&lt;/a&gt;), '&lt;code&gt;%I&lt;/code&gt;' (inserts a &lt;a href=&quot;#lua_Integer&quot;&gt;&lt;code&gt;lua_Integer&lt;/code&gt;&lt;/a&gt;), '&lt;code&gt;%p&lt;/code&gt;' (inserts a pointer as a hexadecimal numeral), '&lt;code&gt;%d&lt;/code&gt;' (inserts an &lt;code&gt;int&lt;/code&gt;), '&lt;code&gt;%c&lt;/code&gt;' (inserts an &lt;code&gt;int&lt;/code&gt; as a one-byte character), and '&lt;code&gt;%U&lt;/code&gt;' (inserts a &lt;code&gt;long int&lt;/code&gt; as a UTF-8 byte sequence).</source>
          <target state="translated">변환 지정자는 상당히 제한되어 있습니다. 플래그, 너비 또는 정밀도가 없습니다. 변환 지정자는 ' &lt;code&gt;%%&lt;/code&gt; '(문자 ' &lt;code&gt;%&lt;/code&gt; ' 삽입 ), ' &lt;code&gt;%s&lt;/code&gt; '(제한없이 0으로 끝나는 문자열 삽입), ' &lt;code&gt;%f&lt;/code&gt; '( &lt;a href=&quot;#lua_Number&quot;&gt; &lt;code&gt;lua_Number&lt;/code&gt; &lt;/a&gt; 삽입 ), ' &lt;code&gt;%I&lt;/code&gt; '( &lt;a href=&quot;#lua_Integer&quot;&gt; &lt;code&gt;lua_Integer&lt;/code&gt; &lt;/a&gt; 삽입 ),' &lt;code&gt;%p&lt;/code&gt; '(16 진수로 포인터 삽입),' &lt;code&gt;%d&lt;/code&gt; '( &lt;code&gt;int&lt;/code&gt; 입력 ),' &lt;code&gt;%c&lt;/code&gt; '( 1 바이트 문자로 &lt;code&gt;int&lt;/code&gt; 삽입 ) 및' &lt;code&gt;%U&lt;/code&gt; '( &lt;code&gt;long int&lt;/code&gt; 를 UTF-8 바이트 시퀀스로 삽입합니다 ).</target>
        </trans-unit>
        <trans-unit id="4a2b4eab7e7e8e47540c45b140f9d1c1edf8fd79" translate="yes" xml:space="preserve">
          <source>The current parser always sees such constructions in the first way, interpreting the open parenthesis as the start of the arguments to a call. To avoid this ambiguity, it is a good practice to always precede with a semicolon statements that start with a parenthesis:</source>
          <target state="translated">현재 구문 분석기는 항상 이러한 구성을 첫 번째 방식으로보고 열린 괄호를 호출에 대한 인수의 시작으로 해석합니다. 이러한 모호성을 피하려면 항상 괄호로 시작하는 세미콜론 문을 먼저 따르는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c9bf869e4f0cbfc39ea3983d219f80c93e648f82" translate="yes" xml:space="preserve">
          <source>The default GC mode with the default parameters are adequate for most uses. However, programs that waste a large proportion of their time allocating and freeing memory can benefit from other settings. Keep in mind that the GC behavior is non-portable both across platforms and across different Lua releases; therefore, optimal settings are also non-portable.</source>
          <target state="translated">기본 매개 변수가있는 기본 GC 모드는 대부분의 용도에 적합합니다. 그러나 메모리 할당 및 해제에 많은 시간을 낭비하는 프로그램은 다른 설정의 이점을 누릴 수 있습니다. GC 동작은 플랫폼과 다른 Lua 릴리스 모두에서 이식 할 수 없습니다. 따라서 최적의 설정도 휴대 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1273a024b1e39aac89ab0ab6781ebe040b7fbcc0" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;pos&lt;/code&gt; is &lt;code&gt;#list&lt;/code&gt;, so that a call &lt;code&gt;table.remove(l)&lt;/code&gt; removes the last element of list &lt;code&gt;l&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pos&lt;/code&gt; 의 기본값 은 &lt;code&gt;#list&lt;/code&gt; 이므로 call table.remove &lt;code&gt;table.remove(l)&lt;/code&gt; 은 list &lt;code&gt;l&lt;/code&gt; 의 마지막 요소를 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="29c63af20a776235dbc6fd94c8529980ff13aa8a" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;pos&lt;/code&gt; is &lt;code&gt;#list&lt;/code&gt;, so that a call &lt;code&gt;table.remove(l)&lt;/code&gt; removes the last element of the list &lt;code&gt;l&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pos&lt;/code&gt; 의 기본값 은 &lt;code&gt;#list&lt;/code&gt; 이므로 table.remove &lt;code&gt;table.remove(l)&lt;/code&gt; 호출 은 목록 &lt;code&gt;l&lt;/code&gt; 의 마지막 요소를 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="13c08370b3a28f0fd5960d5a4c5c48fa16e93a96" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;whence&lt;/code&gt; is &lt;code&gt;&quot;cur&quot;&lt;/code&gt;, and for &lt;code&gt;offset&lt;/code&gt; is 0. Therefore, the call &lt;code&gt;file:seek()&lt;/code&gt; returns the current file position, without changing it; the call &lt;code&gt;file:seek(&quot;set&quot;)&lt;/code&gt; sets the position to the beginning of the file (and returns 0); and the call &lt;code&gt;file:seek(&quot;end&quot;)&lt;/code&gt; sets the position to the end of the file, and returns its size.</source>
          <target state="translated">&lt;code&gt;whence&lt;/code&gt; 의 기본값 은 &lt;code&gt;&quot;cur&quot;&lt;/code&gt; 이고 &lt;code&gt;offset&lt;/code&gt; 의 경우 0입니다. 따라서 호출 &lt;code&gt;file:seek()&lt;/code&gt; 는 현재 파일 위치를 변경하지 않고 반환합니다. 호출 &lt;code&gt;file:seek(&quot;set&quot;)&lt;/code&gt; 는 파일의 시작 위치를 설정하고 0을 반환합니다. &lt;code&gt;file:seek(&quot;end&quot;)&lt;/code&gt; 호출 은 위치를 파일의 끝으로 설정하고 크기를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6bc56dc8d299b9d15b00a924ab6b6763132d6c6e" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;x&lt;/code&gt; is 1, so that the call &lt;code&gt;math.atan(y)&lt;/code&gt; returns the arc tangent of &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 기본값 은 1이므로 &lt;code&gt;math.atan(y)&lt;/code&gt; 호출 은 &lt;code&gt;y&lt;/code&gt; 의 아크 탄젠트를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="6c1119d71f1c451d5f2fe0db217d85e8a5bba94c" translate="yes" xml:space="preserve">
          <source>The definitions of letter, space, and other character groups depend on the current locale. In particular, the class &lt;code&gt;[a-z]&lt;/code&gt; may not be equivalent to &lt;code&gt;%l&lt;/code&gt;.</source>
          <target state="translated">문자, 공백 및 기타 문자 그룹의 정의는 현재 로케일에 따라 다릅니다. 특히, 클래스 &lt;code&gt;[a-z]&lt;/code&gt; 는 &lt;code&gt;%l&lt;/code&gt; 과 (와) 동일하지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f71cbe788ea609ab97e549ccaa27836b38cc887d" translate="yes" xml:space="preserve">
          <source>The field list can have an optional trailing separator, as a convenience for machine-generated code.</source>
          <target state="translated">필드리스트에는 기계 생성 코드의 편의를 위해 선택적인 후행 구분 기호가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2dc2a9366caaece55ab74f5902257c1d9cc63e9" translate="yes" xml:space="preserve">
          <source>The fields of &lt;a href=&quot;#lua_Debug&quot;&gt;&lt;code&gt;lua_Debug&lt;/code&gt;&lt;/a&gt; have the following meaning:</source>
          <target state="translated">&lt;a href=&quot;#lua_Debug&quot;&gt; &lt;code&gt;lua_Debug&lt;/code&gt; &lt;/a&gt; 의 필드 는 다음과 같은 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="5cf6a1464c2f6d6211946c68accd0138255e9433" translate="yes" xml:space="preserve">
          <source>The fifth line is a mark to ignore all text after it when building the &lt;code&gt;luaopen_&lt;/code&gt; function name. Default is '&lt;code&gt;-&lt;/code&gt;'.</source>
          <target state="translated">다섯 번째 줄은 &lt;code&gt;luaopen_&lt;/code&gt; 함수 이름을 빌드 할 때 모든 텍스트를 무시하는 표시 입니다. 기본값은 ' &lt;code&gt;-&lt;/code&gt; '입니다.</target>
        </trans-unit>
        <trans-unit id="d550e1bb0cbfc7b8de8aa9f3e58a6e8b1e903f3a" translate="yes" xml:space="preserve">
          <source>The first argument to &lt;a href=&quot;#pdf-string.pack&quot;&gt;&lt;code&gt;string.pack&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pdf-string.packsize&quot;&gt;&lt;code&gt;string.packsize&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#pdf-string.unpack&quot;&gt;&lt;code&gt;string.unpack&lt;/code&gt;&lt;/a&gt; is a format string, which describes the layout of the structure being created or read.</source>
          <target state="translated">&lt;a href=&quot;#pdf-string.pack&quot;&gt; &lt;code&gt;string.pack&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#pdf-string.packsize&quot;&gt; &lt;code&gt;string.packsize&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#pdf-string.unpack&quot;&gt; &lt;code&gt;string.unpack&lt;/code&gt; &lt;/a&gt; 의 첫 번째 인수 는 작성 또는 읽은 구조의 레이아웃을 설명하는 형식 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="35b2be930dbf43b40449e98f73501827b087ff5f" translate="yes" xml:space="preserve">
          <source>The first field, &lt;code&gt;o&lt;/code&gt;, is how many elements the function pops from the stack. The second field, &lt;code&gt;p&lt;/code&gt;, is how many elements the function pushes onto the stack. (Any function always pushes its results after popping its arguments.) A field in the form &lt;code&gt;x|y&lt;/code&gt; means the function can push (or pop) &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; elements, depending on the situation; an interrogation mark '&lt;code&gt;?&lt;/code&gt;' means that we cannot know how many elements the function pops/pushes by looking only at its arguments (e.g., they may depend on what is on the stack). The third field, &lt;code&gt;x&lt;/code&gt;, tells whether the function may raise errors: '&lt;code&gt;-&lt;/code&gt;' means the function never raises any error; '&lt;code&gt;m&lt;/code&gt;' means the function may raise out-of-memory errors and errors running a &lt;code&gt;__gc&lt;/code&gt; metamethod; '&lt;code&gt;e&lt;/code&gt;' means the function may raise any errors (it can run arbitrary Lua code, either directly or through metamethods); '&lt;code&gt;v&lt;/code&gt;' means the function may raise an error on purpose.</source>
          <target state="translated">첫 번째 필드 &lt;code&gt;o&lt;/code&gt; 는 스택에서 함수가 팝업하는 요소 수입니다. 두 번째 필드 &lt;code&gt;p&lt;/code&gt; 는 함수가 스택에 푸시하는 요소 수입니다. (모든 함수는 인수를 팝한 후 항상 결과를 푸시합니다.) &lt;code&gt;x|y&lt;/code&gt; 형식의 필드 는 함수가 상황에 따라 &lt;code&gt;x&lt;/code&gt; 또는 &lt;code&gt;y&lt;/code&gt; 요소를 푸시 (또는 팝) 할 수 있음을 의미합니다 . 심문 마크 &lt;code&gt;?&lt;/code&gt; '는 인수 만보고 함수가 얼마나 많은 요소를 팝 / 푸시하는지 알 수 없음을 의미합니다 (예 : 스택에있는 요소에 따라 다를 수 있음). 세 번째 필드 인 &lt;code&gt;x&lt;/code&gt; 는 함수가 오류를 발생시킬 수 있는지 여부를 알려줍니다. ' &lt;code&gt;-&lt;/code&gt; '는 함수가 오류를 발생시키지 않음을 의미합니다. ' &lt;code&gt;m&lt;/code&gt; '는 함수가 메모리 부족 오류 및 &lt;code&gt;__gc&lt;/code&gt; 메타 메소드를 실행하는 오류를 일으킬 수 있음을 의미합니다 . ' &lt;code&gt;e&lt;/code&gt; '는 함수가 오류를 일으킬 수 있음을 의미합니다 (직접 또는 메타 메소드를 통해 임의의 Lua 코드를 실행할 수 있음). ' &lt;code&gt;v&lt;/code&gt; '는 함수가 의도적으로 오류를 일으킬 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0c89478a55ea6827ef7574f90e0b65d3a882b531" translate="yes" xml:space="preserve">
          <source>The first field, &lt;code&gt;o&lt;/code&gt;, is how many elements the function pops from the stack. The second field, &lt;code&gt;p&lt;/code&gt;, is how many elements the function pushes onto the stack. (Any function always pushes its results after popping its arguments.) A field in the form &lt;code&gt;x|y&lt;/code&gt; means the function can push (or pop) &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; elements, depending on the situation; an interrogation mark '&lt;code&gt;?&lt;/code&gt;' means that we cannot know how many elements the function pops/pushes by looking only at its arguments. (For instance, they may depend on what is in the stack.) The third field, &lt;code&gt;x&lt;/code&gt;, tells whether the function may raise errors: '&lt;code&gt;-&lt;/code&gt;' means the function never raises any error; '&lt;code&gt;m&lt;/code&gt;' means the function may raise only out-of-memory errors; '&lt;code&gt;v&lt;/code&gt;' means the function may raise the errors explained in the text; '&lt;code&gt;e&lt;/code&gt;' means the function can run arbitrary Lua code, either directly or through metamethods, and therefore may raise any errors.</source>
          <target state="translated">첫 번째 필드 &lt;code&gt;o&lt;/code&gt; 는 함수가 스택에서 얼마나 많은 요소를 팝하는지입니다. 두 번째 필드 &lt;code&gt;p&lt;/code&gt; 는 함수가 스택에 푸시하는 요소 수입니다. (모든 함수는 항상 인수를 팝한 후 결과를 푸시합니다.) &lt;code&gt;x|y&lt;/code&gt; 형식의 필드 는 상황에 따라 함수가 &lt;code&gt;x&lt;/code&gt; 또는 &lt;code&gt;y&lt;/code&gt; 요소를 푸시 (또는 팝) 할 수 있음을 의미합니다 . 심문 마크 ' &lt;code&gt;?&lt;/code&gt; '는 인수 만보고 함수가 얼마나 많은 요소를 팝 / 푸시하는지 알 수 없음을 의미합니다. (예를 들어, 스택에있는 항목에 따라 달라질 수 있습니다.) 세 번째 필드 &lt;code&gt;x&lt;/code&gt; 는 함수가 오류를 발생시킬 수 있는지 여부를 알려줍니다. ' &lt;code&gt;-&lt;/code&gt; '는 함수가 오류를 발생시키지 않음을 의미합니다. ' &lt;code&gt;m&lt;/code&gt; '는 함수가 메모리 부족 오류 만 발생할 수 있음을 의미합니다. ' &lt;code&gt;v&lt;/code&gt; '는 함수가 텍스트에 설명 된 오류를 일으킬 수 있음을 의미합니다. ' &lt;code&gt;e&lt;/code&gt; '는 함수가 직접 또는 메타 메서드를 통해 임의의 Lua 코드를 실행할 수 있으므로 오류가 발생할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="080894d3f355773389e870abdc64bf22951aa7fd" translate="yes" xml:space="preserve">
          <source>The first line is the directory separator string. Default is '&lt;code&gt;\&lt;/code&gt;' for Windows and '&lt;code&gt;/&lt;/code&gt;' for all other systems.</source>
          <target state="translated">첫 번째 줄은 디렉토리 구분자 문자열입니다. Windows의 경우 기본값은 ' &lt;code&gt;\&lt;/code&gt; '이고 다른 모든 시스템의 경우 ' &lt;code&gt;/&lt;/code&gt; '입니다.</target>
        </trans-unit>
        <trans-unit id="618ae404e5e9c891f664deb6c2fb8fab741ce902" translate="yes" xml:space="preserve">
          <source>The first parameter or local variable has index 1, and so on, following the order that they are declared in the code, counting only the variables that are active in the current scope of the function. Compile-time constants may not appear in this listing, if they were optimized away by the compiler. Negative indices refer to vararg arguments; -1 is the first vararg argument. The function returns &lt;b&gt;fail&lt;/b&gt; if there is no variable with the given index, and raises an error when called with a level out of range. (You can call &lt;a href=&quot;#pdf-debug.getinfo&quot;&gt;&lt;code&gt;debug.getinfo&lt;/code&gt;&lt;/a&gt; to check whether the level is valid.)</source>
          <target state="translated">첫 번째 매개 변수 또는 지역 변수에는 인덱스 1 등이 있으며 코드에서 선언 된 순서에 따라 함수의 현재 범위에서 활성 인 변수 만 계산됩니다. 컴파일 시간 상수는 컴파일러에 의해 최적화 된 경우이 목록에 나타나지 않을 수 있습니다. 음수 인덱스는 vararg 인수를 나타냅니다. -1은 첫 번째 vararg 인수입니다. 함수는 주어진 인덱스를 가진 변수가 없으면 &lt;b&gt;fail을&lt;/b&gt; 반환 하고 범위를 벗어난 수준으로 호출하면 오류를 발생시킵니다. ( &lt;a href=&quot;#pdf-debug.getinfo&quot;&gt; &lt;code&gt;debug.getinfo&lt;/code&gt; &lt;/a&gt; 를 호출 하여 레벨이 유효한지 확인할 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="b927b10bd57d8d0d9d2adab8cf882393f87f3f97" translate="yes" xml:space="preserve">
          <source>The first parameter or local variable has index 1, and so on, following the order that they are declared in the code, counting only the variables that are active in the current scope of the function. Negative indices refer to vararg parameters; -1 is the first vararg parameter. The function returns &lt;b&gt;nil&lt;/b&gt; if there is no variable with the given index, and raises an error when called with a level out of range. (You can call &lt;a href=&quot;#pdf-debug.getinfo&quot;&gt;&lt;code&gt;debug.getinfo&lt;/code&gt;&lt;/a&gt; to check whether the level is valid.)</source>
          <target state="translated">첫 번째 매개 변수 또는 로컬 변수는 코드에서 선언 된 순서에 따라 색인 1 등을 가지며 함수의 현재 범위에서 활성 인 변수 만 계산합니다. 음의 인덱스는 vararg 매개 변수를 나타냅니다. -1은 첫 번째 vararg 매개 변수입니다. 주어진 인덱스에 변수가 없으면 함수는 &lt;b&gt;nil을&lt;/b&gt; 반환 하고, 범위를 벗어난 레벨로 호출하면 오류가 발생합니다. 레벨이 유효한지 확인하기 위해 &lt;a href=&quot;#pdf-debug.getinfo&quot;&gt; &lt;code&gt;debug.getinfo&lt;/code&gt; &lt;/a&gt; 를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ee8f303d70c303dd14cac48bd1f16c3b0dcbcc40" translate="yes" xml:space="preserve">
          <source>The first searcher simply looks for a loader in the &lt;a href=&quot;#pdf-package.preload&quot;&gt;&lt;code&gt;package.preload&lt;/code&gt;&lt;/a&gt; table.</source>
          <target state="translated">첫 번째 검색자는 단순히 &lt;a href=&quot;#pdf-package.preload&quot;&gt; &lt;code&gt;package.preload&lt;/code&gt; &lt;/a&gt; 테이블 에서 로더를 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="62aececc4ee40da1a864200ef2a0c8a1bcbfc8f7" translate="yes" xml:space="preserve">
          <source>The float value &lt;code&gt;HUGE_VAL&lt;/code&gt;, a value greater than any other numeric value.</source>
          <target state="translated">다른 숫자 값보다 큰 값인 부동 소수점 값 &lt;code&gt;HUGE_VAL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d265942ec96276d66e6ab599ec30b3a3b29815fd" translate="yes" xml:space="preserve">
          <source>The float value &lt;code&gt;HUGE_VAL&lt;/code&gt;, a value larger than any other numeric value.</source>
          <target state="translated">다른 숫자 값보다 큰 값인 float 값 &lt;code&gt;HUGE_VAL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="196211405f17ee844517a47f2e8b2cb60db3f8ce" translate="yes" xml:space="preserve">
          <source>The following &lt;em&gt;keywords&lt;/em&gt; are reserved and cannot be used as names:</source>
          <target state="translated">다음 &lt;em&gt;키워드&lt;/em&gt; 는 예약되어 있으며 이름으로 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ab8a72a62eca0d1ef8ee4d0f5f153c9b1519bd5d" translate="yes" xml:space="preserve">
          <source>The following example shows how the host program can do the equivalent to this Lua code:</source>
          <target state="translated">다음 예제는 호스트 프로그램이이 Lua 코드와 동등한 기능을 수행하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="278e2855a1845e2a26526bc29fe7fac6d57babe0" translate="yes" xml:space="preserve">
          <source>The following functions were deprecated in the mathematical library: &lt;code&gt;atan2&lt;/code&gt;, &lt;code&gt;cosh&lt;/code&gt;, &lt;code&gt;sinh&lt;/code&gt;, &lt;code&gt;tanh&lt;/code&gt;, &lt;code&gt;pow&lt;/code&gt;, &lt;code&gt;frexp&lt;/code&gt;, and &lt;code&gt;ldexp&lt;/code&gt;. You can replace &lt;code&gt;math.pow(x,y)&lt;/code&gt; with &lt;code&gt;x^y&lt;/code&gt;; you can replace &lt;code&gt;math.atan2&lt;/code&gt; with &lt;code&gt;math.atan&lt;/code&gt;, which now accepts one or two parameters; you can replace &lt;code&gt;math.ldexp(x,exp)&lt;/code&gt; with &lt;code&gt;x * 2.0^exp&lt;/code&gt;. For the other operations, you can either use an external library or implement them in Lua.</source>
          <target state="translated">수학 라이브러리에서는 &lt;code&gt;atan2&lt;/code&gt; , &lt;code&gt;cosh&lt;/code&gt; , &lt;code&gt;sinh&lt;/code&gt; , &lt;code&gt;tanh&lt;/code&gt; , &lt;code&gt;pow&lt;/code&gt; , &lt;code&gt;frexp&lt;/code&gt; 및 &lt;code&gt;ldexp&lt;/code&gt; 함수가 더 이상 사용되지 않습니다 . &lt;code&gt;math.pow(x,y)&lt;/code&gt; 를 &lt;code&gt;x^y&lt;/code&gt; 바꿀 수 있습니다 . &lt;code&gt;math.atan2&lt;/code&gt; 를 &lt;code&gt;math.atan&lt;/code&gt; 으로 바꿀 수 있으며 , 이제 하나 또는 두 개의 매개 변수를 허용합니다. &lt;code&gt;math.ldexp(x,exp)&lt;/code&gt; 를 &lt;code&gt;x * 2.0^exp&lt;/code&gt; 바꿀 수 있습니다 . 다른 작업의 경우 외부 라이브러리를 사용하거나 Lua에서 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="525a807668897271f1a9b9de59f3fdf8f64551a7" translate="yes" xml:space="preserve">
          <source>The following strings denote other tokens:</source>
          <target state="translated">다음 문자열은 다른 토큰을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ba13fb8d8389b33ab088d4fc65f5ec35b8d33e18" translate="yes" xml:space="preserve">
          <source>The following syntactic sugar simplifies function definitions:</source>
          <target state="translated">다음과 같은 구문 설탕은 함수 정의를 단순화합니다.</target>
        </trans-unit>
        <trans-unit id="af2cb037b897b34b24d5a23238cf877011ea082c" translate="yes" xml:space="preserve">
          <source>The form</source>
          <target state="translated">형태</target>
        </trans-unit>
        <trans-unit id="7a0c21abdce99c6d3820ba447237185fd89bfedf" translate="yes" xml:space="preserve">
          <source>The formats &quot;&lt;code&gt;l&lt;/code&gt;&quot; and &quot;&lt;code&gt;L&lt;/code&gt;&quot; should be used only for text files.</source>
          <target state="translated">&quot; &lt;code&gt;l&lt;/code&gt; &quot;및 &quot; &lt;code&gt;L&lt;/code&gt; &quot; 형식 은 텍스트 파일에만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="dd4c785119c8c33799dde8b20447ed83f6ee2b11" translate="yes" xml:space="preserve">
          <source>The fourth line is a string that, in a path in Windows, is replaced by the executable's directory. Default is '&lt;code&gt;!&lt;/code&gt;'.</source>
          <target state="translated">네 번째 줄은 Windows의 경로에서 실행 파일의 디렉토리로 대체되는 문자열입니다. 기본값은 ' &lt;code&gt;!&lt;/code&gt; '.</target>
        </trans-unit>
        <trans-unit id="c4934c1b60689ce3f2c3bcb8e146450b0295d47d" translate="yes" xml:space="preserve">
          <source>The fourth searcher tries an &lt;em&gt;all-in-one loader&lt;/em&gt;. It searches the C path for a library for the root name of the given module. For instance, when requiring &lt;code&gt;a.b.c&lt;/code&gt;, it will search for a C library for &lt;code&gt;a&lt;/code&gt;. If found, it looks into it for an open function for the submodule; in our example, that would be &lt;code&gt;luaopen_a_b_c&lt;/code&gt;. With this facility, a package can pack several C submodules into one single library, with each submodule keeping its original open function.</source>
          <target state="translated">네 번째 검색자는 &lt;em&gt;올인원 로더를&lt;/em&gt; 시도합니다 . 주어진 모듈의 루트 이름에 대한 라이브러리의 C 경로를 검색합니다. 이 필요한 경우 예를 들어, &lt;code&gt;a.b.c&lt;/code&gt; , 그것은을위한 C 라이브러리를 검색합니다 . 발견되면 하위 모듈에 대한 열린 기능을 찾습니다. 이 예에서는 &lt;code&gt;luaopen_a_b_c&lt;/code&gt; 입니다. 이 기능을 통해 패키지는 여러 개의 C 서브 모듈을 하나의 단일 라이브러리에 포장 할 수 있으며 각 서브 모듈은 원래의 열린 기능을 유지합니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0b073a91442e0e0571f6fed07833298243fbd91c" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;#lua_resume&quot;&gt;&lt;code&gt;lua_resume&lt;/code&gt;&lt;/a&gt; has an extra parameter. This out parameter returns the number of values on the top of the stack that were yielded or returned by the coroutine. (In previous versions, those values were the entire stack.)</source>
          <target state="translated">&lt;a href=&quot;#lua_resume&quot;&gt; &lt;code&gt;lua_resume&lt;/code&gt; &lt;/a&gt; 함수 에는 추가 매개 변수가 있습니다. 이 출력 매개 변수는 코 루틴에 의해 양보되거나 반환 된 스택 상단의 값 수를 반환합니다. (이전 버전에서는 이러한 값이 전체 스택이었습니다.)</target>
        </trans-unit>
        <trans-unit id="3c583d7e5932250cb3b5f290df0a3aa69c7e5671" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;#lua_version&quot;&gt;&lt;code&gt;lua_version&lt;/code&gt;&lt;/a&gt; returns the version number, instead of an address of the version number. The Lua core should work correctly with libraries using their own static copies of the same core, so there is no need to check whether they are using the same address space.</source>
          <target state="translated">함수 &lt;a href=&quot;#lua_version&quot;&gt; &lt;code&gt;lua_version&lt;/code&gt; 는&lt;/a&gt; 대신 버전 번호의 주소의 버전 번호를 반환합니다. Lua 코어는 동일한 코어의 자체 정적 복사본을 사용하는 라이브러리에서 올바르게 작동해야하므로 동일한 주소 공간을 사용하고 있는지 확인할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="b3e053a7fc1423644f26201e21114115843c06a5" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;#pdf-io.lines&quot;&gt;&lt;code&gt;io.lines&lt;/code&gt;&lt;/a&gt; now returns four values, instead of just one. That can be a problem when it is used as the sole argument to another function that has optional parameters, such as in &lt;code&gt;load(io.lines(filename, &quot;L&quot;))&lt;/code&gt;. To fix that issue, you can wrap the call into parentheses, to adjust its number of results to one.</source>
          <target state="translated">이제 &lt;a href=&quot;#pdf-io.lines&quot;&gt; &lt;code&gt;io.lines&lt;/code&gt; &lt;/a&gt; 함수 는 하나가 아닌 4 개의 값을 반환합니다. 이는 &lt;code&gt;load(io.lines(filename, &quot;L&quot;))&lt;/code&gt; 와 같이 선택적 매개 변수가있는 다른 함수에 대한 유일한 인수로 사용될 때 문제가 될 수 있습니다 . 이 문제를 해결하려면 호출을 괄호로 묶어 결과 수를 1로 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ecc8b5fcb7191e1242fe3f17f70a609a4340afa3" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;#pdf-print&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt; does not call &lt;a href=&quot;#pdf-tostring&quot;&gt;&lt;code&gt;tostring&lt;/code&gt;&lt;/a&gt; to format its arguments; instead, it has this functionality hardwired. You should use &lt;code&gt;__tostring&lt;/code&gt; to modify how values are printed.</source>
          <target state="translated">&lt;a href=&quot;#pdf-print&quot;&gt; &lt;code&gt;print&lt;/code&gt; &lt;/a&gt; 함수 는 인수를 형식화하기 위해 &lt;a href=&quot;#pdf-tostring&quot;&gt; &lt;code&gt;tostring&lt;/code&gt; &lt;/a&gt; 을 호출하지 않습니다 . 대신에이 기능이 고정되어 있습니다. &lt;code&gt;__tostring&lt;/code&gt; 을 사용 하여 값이 인쇄되는 방식을 수정 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0263ab6ca26086df9c4e35bef1b518910d2dc151" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;#pdf-string.gsub&quot;&gt;&lt;code&gt;string.gsub&lt;/code&gt;&lt;/a&gt; and the iterator &lt;a href=&quot;#pdf-string.gmatch&quot;&gt;&lt;code&gt;string.gmatch&lt;/code&gt;&lt;/a&gt; match multiple occurrences of the given pattern in the subject. For these functions, a new match is considered valid only if it ends at least one byte after the end of the previous match. In other words, the pattern machine never accepts the empty string as a match immediately after another match. As an example, consider the results of the following code:</source>
          <target state="translated">함수 &lt;a href=&quot;#pdf-string.gsub&quot;&gt; &lt;code&gt;string.gsub&lt;/code&gt; &lt;/a&gt; 및 반복자 &lt;a href=&quot;#pdf-string.gmatch&quot;&gt; &lt;code&gt;string.gmatch&lt;/code&gt; &lt;/a&gt; 는 주제에서 주어진 패턴의 여러 발생과 일치합니다. 이러한 함수의 경우 새 일치는 이전 일치가 끝난 후 최소 1 바이트가 지난 경우에만 유효한 것으로 간주됩니다. 즉, 패턴 머신은 다른 일치 직후에 빈 문자열을 일치로 받아들이지 않습니다. 예를 들어 다음 코드의 결과를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="14ef273b64fc52356a4906b3e7d6eabe19ee71ea" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;print&lt;/code&gt; is not intended for formatted output, but only as a quick way to show a value, for instance for debugging. For complete control over the output, use &lt;a href=&quot;#pdf-string.format&quot;&gt;&lt;code&gt;string.format&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#pdf-io.write&quot;&gt;&lt;code&gt;io.write&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;print&lt;/code&gt; 함수 는 형식화 된 출력을위한 것이 아니라 디버깅을 위해 값을 표시하는 빠른 방법 일뿐입니다. 출력을 완벽하게 제어하려면 &lt;a href=&quot;#pdf-string.format&quot;&gt; &lt;code&gt;string.format&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#pdf-io.write&quot;&gt; &lt;code&gt;io.write&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="220aaa9b01b5620d0798784b861e1408f8a717e8" translate="yes" xml:space="preserve">
          <source>The function returns the address of the block of memory. Lua ensures that this address is valid as long as the corresponding userdata is alive (see &lt;a href=&quot;#2.5&quot;&gt;&amp;sect;2.5&lt;/a&gt;). Moreover, if the userdata is marked for finalization (see &lt;a href=&quot;#2.5.3&quot;&gt;&amp;sect;2.5.3&lt;/a&gt;), its address is valid at least until the call to its finalizer.</source>
          <target state="translated">이 함수는 메모리 블록의 주소를 반환합니다. Lua는 해당 사용자 데이터가 살아있는 한이 주소가 유효한지 확인합니다 ( &lt;a href=&quot;#2.5&quot;&gt;&amp;sect;2.5&lt;/a&gt; 참조 ). 또한 사용자 데이터가 종료 표시가되어 있으면 ( &lt;a href=&quot;#2.5.3&quot;&gt;&amp;sect;2.5.3&lt;/a&gt; 참조 ) 해당 주소는 적어도 종료자를 호출 할 때까지 유효합니다.</target>
        </trans-unit>
        <trans-unit id="cc98f5bacbd5d5c9b5f87b48eedc41b8165ed273" translate="yes" xml:space="preserve">
          <source>The garbage collector (GC) in Lua can work in two modes: incremental and generational.</source>
          <target state="translated">Lua의 GC (가비지 수집기)는 증분 및 세대 모드의 두 가지 모드로 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3fbd703ec3951b9eef95d2b7d4e3956a139b1f1" translate="yes" xml:space="preserve">
          <source>The garbage-collector pause controls how long the collector waits before starting a new cycle. Larger values make the collector less aggressive. Values smaller than 100 mean the collector will not wait to start a new cycle. A value of 200 means that the collector waits for the total memory in use to double before starting a new cycle.</source>
          <target state="translated">가비지 콜렉터 일시 정지는 새주기를 시작하기 전에 콜렉터가 대기하는 시간을 제어합니다. 값이 클수록 수집기가 덜 공격적입니다. 100보다 작은 값은 수집기가 새주기를 시작하기를 기다리지 않음을 의미합니다. 값이 200이면 콜렉터는 새주기를 시작하기 전에 사용중인 총 메모리가 두 배가 될 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="9930e7ac93649b09106490695fbc0f2072543bb0" translate="yes" xml:space="preserve">
          <source>The garbage-collector pause controls how long the collector waits before starting a new cycle. The collector starts a new cycle when the use of memory hits &lt;em&gt;n%&lt;/em&gt; of the use after the previous collection. Larger values make the collector less aggressive. Values equal to or less than 100 mean the collector will not wait to start a new cycle. A value of 200 means that the collector waits for the total memory in use to double before starting a new cycle. The default value is 200; the maximum value is 1000.</source>
          <target state="translated">가비지 수집기 일시 중지는 수집기가 새주기를 시작하기 전에 대기하는 시간을 제어합니다. 수집기는 메모리 사용이 이전 수집 이후 사용의 &lt;em&gt;n %&lt;/em&gt; 에 도달하면 새주기를 시작합니다 . 값이 클수록 수집기가 덜 공격적입니다. 100 이하의 값은 수집기가 새주기 시작을 기다리지 않음을 의미합니다. 200 값은 새주기를 시작하기 전에 사용중인 총 메모리가 두 배가 될 때까지 콜렉터가 대기 함을 의미합니다. 기본값은 200입니다. 최대 값은 1000입니다.</target>
        </trans-unit>
        <trans-unit id="3da0189eddd3acd188369ff8e9890d24f44cba07" translate="yes" xml:space="preserve">
          <source>The garbage-collector step multiplier controls the relative speed of the collector relative to memory allocation. Larger values make the collector more aggressive but also increase the size of each incremental step. You should not use values smaller than 100, because they make the collector too slow and can result in the collector never finishing a cycle. The default is 200, which means that the collector runs at &quot;twice&quot; the speed of memory allocation.</source>
          <target state="translated">가비지 수집기 단계 승수는 메모리 할당에 대한 수집기의 상대 속도를 제어합니다. 값이 클수록 콜렉터가 더 공격적이지만 각 증분 단계의 크기도 증가합니다. 콜렉터를 너무 느리게하여 콜렉터가주기를 완료하지 못하게 할 수 있으므로 100보다 작은 값을 사용하면 안됩니다. 기본값은 200이며, 이는 수집기가 메모리 할당 속도를 &quot;두 배&quot;로 실행 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="edd02666b7bd31dec27098654c590c3963c3039b" translate="yes" xml:space="preserve">
          <source>The garbage-collector step multiplier controls the speed of the collector relative to memory allocation, that is, how many elements it marks or sweeps for each kilobyte of memory allocated. Larger values make the collector more aggressive but also increase the size of each incremental step. You should not use values less than 100, because they make the collector too slow and can result in the collector never finishing a cycle. The default value is 100; the maximum value is 1000.</source>
          <target state="translated">가비지 수집기 단계 승수는 메모리 할당과 관련된 수집기의 속도, 즉 할당 된 메모리의 각 킬로바이트에 대해 표시하거나 스위프하는 요소 수를 제어합니다. 값이 클수록 콜렉터가 더 공격적이지만 각 증분 단계의 크기도 증가합니다. 100보다 작은 값은 컬렉터를 너무 느리게 만들고 컬렉터가주기를 완료하지 못하게 할 수 있으므로 사용해서는 안됩니다. 기본값은 100입니다. 최대 값은 1000입니다.</target>
        </trans-unit>
        <trans-unit id="e9a660cf022dffa05c59d7259e6adabb7cdd6f67" translate="yes" xml:space="preserve">
          <source>The garbage-collector step size controls the size of each incremental step, specifically how many bytes the interpreter allocates before performing a step. This parameter is logarithmic: A value of &lt;em&gt;n&lt;/em&gt; means the interpreter will allocate &lt;em&gt;2&lt;sup&gt;n&lt;/sup&gt;&lt;/em&gt; bytes between steps and perform equivalent work during the step. A large value (e.g., 60) makes the collector a stop-the-world (non-incremental) collector. The default value is 13, which means steps of approximately 8 Kbytes.</source>
          <target state="translated">가비지 수집기 단계 크기는 각 증분 단계의 크기, 특히 인터프리터가 단계를 수행하기 전에 할당하는 바이트 수를 제어합니다. 이 매개 변수는 대수입니다. &lt;em&gt;n&lt;/em&gt; 값은 인터프리터가 단계 사이에 &lt;em&gt;2 &lt;sup&gt;n&lt;/sup&gt;&lt;/em&gt; 바이트 를 할당 하고 단계 중에 동등한 작업을 수행함을 의미합니다. 큰 값 (예 : 60)은 컬렉터를 stop-the-world (비 증분) 컬렉터로 만듭니다. 기본값은 13이며 약 8KB 단계를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="9dc362bec1b0383d76bda32165a279742df9516d" translate="yes" xml:space="preserve">
          <source>The generational mode for the garbage collector was removed. (It was an experimental feature in Lua 5.2.)</source>
          <target state="translated">가비지 수집기의 생성 모드가 제거되었습니다. (루아 5.2의 실험 기능이었습니다.)</target>
        </trans-unit>
        <trans-unit id="d89e31ab18c670e311841a5e28477ef95d2189d8" translate="yes" xml:space="preserve">
          <source>The generic &lt;b&gt;for&lt;/b&gt; loop</source>
          <target state="translated">일반적인 &lt;b&gt;for&lt;/b&gt; 루프</target>
        </trans-unit>
        <trans-unit id="3906554899c83e568ddf64f2f5b8f01161ffbe7d" translate="yes" xml:space="preserve">
          <source>The generic &lt;b&gt;for&lt;/b&gt; statement works over functions, called &lt;em&gt;iterators&lt;/em&gt;. On each iteration, the iterator function is called to produce a new value, stopping when this new value is &lt;b&gt;nil&lt;/b&gt;. The generic &lt;b&gt;for&lt;/b&gt; loop has the following syntax:</source>
          <target state="translated">generic &lt;b&gt;for&lt;/b&gt; 문은 &lt;em&gt;iterators&lt;/em&gt; 라는 함수를 통해 작동 &lt;em&gt;합니다&lt;/em&gt; . 각 반복에서 반복자 함수가 호출되어 새 값을 생성하고이 새 값이 &lt;b&gt;nil 일&lt;/b&gt; 때 중지됩니다 . 일반 &lt;b&gt;for&lt;/b&gt; 루프에는 다음과 같은 구문이 있습니다.</target>
        </trans-unit>
        <trans-unit id="856007e1c22ba68bdc34a47c09a357751a2f6c62" translate="yes" xml:space="preserve">
          <source>The given identifier (Name) defines the control variable, which is a new variable local to the loop body (&lt;em&gt;block&lt;/em&gt;).</source>
          <target state="translated">주어진 식별자 (Name)는 루프 본문 ( &lt;em&gt;block&lt;/em&gt; )에 로컬 인 새 변수 인 제어 변수를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="dd954aa3fd6697b79eaabbdef5d75d8c6c7ba3dc" translate="yes" xml:space="preserve">
          <source>The grammar could see it in two ways:</source>
          <target state="translated">문법은 두 가지 방법으로 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65c328f00080b0011f18aa3b0ed9224892f98cda" translate="yes" xml:space="preserve">
          <source>The grammar could see this fragment in two ways:</source>
          <target state="translated">문법은이 조각을 두 가지 방법으로 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a4c9ed6f872e82764d4027ec65c0b5bc05fccbd" translate="yes" xml:space="preserve">
          <source>The indexing of tables follows the definition of raw equality in the language. The expressions &lt;code&gt;a[i]&lt;/code&gt; and &lt;code&gt;a[j]&lt;/code&gt; denote the same table element if and only if &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; are raw equal (that is, equal without metamethods). In particular, floats with integral values are equal to their respective integers (e.g., &lt;code&gt;1.0 == 1&lt;/code&gt;). To avoid ambiguities, any float used as a key that is equal to an integer is converted to that integer. For instance, if you write &lt;code&gt;a[2.0] = true&lt;/code&gt;, the actual key inserted into the table will be the integer &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">테이블 인덱싱은 언어의 원시 동등성 정의를 따릅니다. &lt;code&gt;a[i]&lt;/code&gt; 및 &lt;code&gt;a[j]&lt;/code&gt; 표현식 은 &lt;code&gt;i&lt;/code&gt; 와 &lt;code&gt;j&lt;/code&gt; 가 원시 (즉, 메타 메소드없이 동일) 경우에만 동일한 테이블 요소를 나타냅니다 . 특히, 정수 값을 가진 부동 소수점은 각각의 정수와 같습니다 (예 : &lt;code&gt;1.0 == 1&lt;/code&gt; ). 모호함을 피하기 위해 정수와 같은 키로 사용되는 부동 소수점은 해당 정수로 변환됩니다. 예를 들어 &lt;code&gt;a[2.0] = true&lt;/code&gt; 라고 쓰면 테이블에 삽입되는 실제 키는 정수 &lt;code&gt;2&lt;/code&gt; 가 됩니다.</target>
        </trans-unit>
        <trans-unit id="c16256befb5f873dad0793713187bd7e83a270f1" translate="yes" xml:space="preserve">
          <source>The indexing of tables follows the definition of raw equality in the language. The expressions &lt;code&gt;a[i]&lt;/code&gt; and &lt;code&gt;a[j]&lt;/code&gt; denote the same table element if and only if &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; are raw equal (that is, equal without metamethods). In particular, floats with integral values are equal to their respective integers (e.g., &lt;code&gt;1.0 == 1&lt;/code&gt;). To avoid ambiguities, any float with integral value used as a key is converted to its respective integer. For instance, if you write &lt;code&gt;a[2.0] = true&lt;/code&gt;, the actual key inserted into the table will be the integer &lt;code&gt;2&lt;/code&gt;. (On the other hand, 2 and &quot;&lt;code&gt;2&lt;/code&gt;&quot; are different Lua values and therefore denote different table entries.)</source>
          <target state="translated">테이블 인덱싱은 언어에서 원시 평등의 정의를 따릅니다. 표현식 &lt;code&gt;a[i]&lt;/code&gt; 및 &lt;code&gt;a[j]&lt;/code&gt; 는 &lt;code&gt;i&lt;/code&gt; 와 &lt;code&gt;j&lt;/code&gt; 가 원시 동등 (즉, 메타 메소드없이 동일) 인 경우에만 동일한 테이블 요소를 나타냅니다 . 특히, 정수 값을 가진 부동 소수점은 각각의 정수와 같습니다 (예 : &lt;code&gt;1.0 == 1&lt;/code&gt; ). 모호성을 피하기 위해 키로 사용되는 정수 값이있는 모든 부동 소수점은 해당 정수로 변환됩니다. 예를 들어, &lt;code&gt;a[2.0] = true&lt;/code&gt; 를 쓰면 테이블에 삽입 된 실제 키는 정수 &lt;code&gt;2&lt;/code&gt; 가 됩니다. 반면에 2와 &quot; &lt;code&gt;2&lt;/code&gt; &quot;는 다른 Lua 값이므로 다른 테이블 항목을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="63673ee512e5ce79f47a34ae0e3f5ac37fa01bb2" translate="yes" xml:space="preserve">
          <source>The integer keys in the registry are used by the reference mechanism (see &lt;a href=&quot;#luaL_ref&quot;&gt;&lt;code&gt;luaL_ref&lt;/code&gt;&lt;/a&gt;) and by some predefined values. Therefore, integer keys in the registry must not be used for other purposes.</source>
          <target state="translated">레지스트리의 정수 키는 참조 메커니즘 ( &lt;a href=&quot;#luaL_ref&quot;&gt; &lt;code&gt;luaL_ref&lt;/code&gt; &lt;/a&gt; 참조 )과 일부 미리 정의 된 값에서 사용됩니다. 따라서 레지스트리의 정수 키를 다른 용도로 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="7b21a8105ceb5ba09152263fc96b9536c63b0161" translate="yes" xml:space="preserve">
          <source>The integer keys in the registry are used by the reference mechanism (see &lt;a href=&quot;#luaL_ref&quot;&gt;&lt;code&gt;luaL_ref&lt;/code&gt;&lt;/a&gt;) and by some predefined values. Therefore, integer keys must not be used for other purposes.</source>
          <target state="translated">레지스트리의 정수 키는 참조 메커니즘 ( &lt;a href=&quot;#luaL_ref&quot;&gt; &lt;code&gt;luaL_ref&lt;/code&gt; &lt;/a&gt; 참조 )과 일부 사전 정의 된 값에 의해 사용됩니다. 따라서 정수 키를 다른 용도로 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="9e586180c1379ce5751eba407cc18f08a9cdeaf0" translate="yes" xml:space="preserve">
          <source>The interaction between ranges and classes is not defined. Therefore, patterns like &lt;code&gt;[%a-z]&lt;/code&gt; or &lt;code&gt;[a-%%]&lt;/code&gt; have no meaning.</source>
          <target state="translated">범위와 클래스 간의 상호 작용은 정의되어 있지 않습니다. 따라서 &lt;code&gt;[%a-z]&lt;/code&gt; 또는 &lt;code&gt;[a-%%]&lt;/code&gt; 와 같은 패턴은 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6dede3b6c4c93cdc9b3511ce20065bb16da883ae" translate="yes" xml:space="preserve">
          <source>The key for each event in a metatable is a string with the event name prefixed by two underscores; the corresponding value is called a &lt;em&gt;metavalue&lt;/em&gt;. For most events, the metavalue must be a function, which is then called a &lt;em&gt;metamethod&lt;/em&gt;. In the previous example, the key is the string &quot;&lt;code&gt;__add&lt;/code&gt;&quot; and the metamethod is the function that performs the addition. Unless stated otherwise, a metamethod may in fact be any callable value, which is either a function or a value with a &lt;code&gt;__call&lt;/code&gt; metamethod.</source>
          <target state="translated">메타 테이블의 각 이벤트에 대한 키는 두 개의 밑줄로 시작하는 이벤트 이름이있는 문자열입니다. 해당 값을 &lt;em&gt;메타&lt;/em&gt; 값이라고합니다 . 대부분의 이벤트에서 &lt;em&gt;메타&lt;/em&gt; 값은 함수 여야하며이를 &lt;em&gt;metamethod&lt;/em&gt; 라고합니다 . 이전 예제에서 키는 문자열 &quot; &lt;code&gt;__add&lt;/code&gt; &quot;이고 메타 메서드는 더하기를 수행하는 함수입니다. 달리 명시되지 않는 한, 메타 메소드는 실제로 모든 호출 가능한 값일 수 있으며, 함수 또는 &lt;code&gt;__call&lt;/code&gt; 메타 메서드가 있는 값입니다 .</target>
        </trans-unit>
        <trans-unit id="f2c90b056889f7693fbb491e97825cdc7458b557" translate="yes" xml:space="preserve">
          <source>The key for each event in a metatable is a string with the event name prefixed by two underscores; the corresponding values are called &lt;em&gt;metamethods&lt;/em&gt;. In the previous example, the key is &quot;&lt;code&gt;__add&lt;/code&gt;&quot; and the metamethod is the function that performs the addition.</source>
          <target state="translated">메타 테이블에서 각 이벤트의 키는 이벤트 이름이 두 개의 밑줄로 시작하는 문자열입니다. 해당 값을 &lt;em&gt;metamethods&lt;/em&gt; 라고 합니다. 이전 예에서 키는 &quot; &lt;code&gt;__add&lt;/code&gt; &quot;이고 메타 메소드는 추가를 수행하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="a1e3c58922162233ff6ef255d5df925e8da6f663" translate="yes" xml:space="preserve">
          <source>The length of a string is its number of bytes (that is, the usual meaning of string length when each character is one byte).</source>
          <target state="translated">문자열의 길이는 바이트 수 (즉, 각 문자가 1 바이트 일 때 문자열 길이의 일반적인 의미)입니다.</target>
        </trans-unit>
        <trans-unit id="d1dc4024a9680b5759a0dab678db12d3202b04ba" translate="yes" xml:space="preserve">
          <source>The length of a string is its number of bytes. (That is the usual meaning of string length when each character is one byte.)</source>
          <target state="translated">문자열의 길이는 바이트 수입니다. (이것은 각 문자가 1 바이트 일 때 문자열 길이의 일반적인 의미입니다.)</target>
        </trans-unit>
        <trans-unit id="01dac97eea86a239bf3254b898850f4681c59248" translate="yes" xml:space="preserve">
          <source>The length operator applied on a table returns a border in that table. A &lt;em&gt;border&lt;/em&gt; in a table &lt;code&gt;t&lt;/code&gt; is any natural number that satisfies the following condition:</source>
          <target state="translated">테이블에 적용된 길이 연산자는 해당 테이블의 테두리를 반환합니다. 표 &lt;code&gt;t&lt;/code&gt; 의 &lt;em&gt;경계&lt;/em&gt; 는 다음 조건을 만족하는 자연수입니다.</target>
        </trans-unit>
        <trans-unit id="3a0004633e5acb8c29842421799433ea833432d7" translate="yes" xml:space="preserve">
          <source>The length operator is denoted by the unary prefix operator &lt;code&gt;#&lt;/code&gt;.</source>
          <target state="translated">길이 연산자는 단항 접두사 연산자 &lt;code&gt;#&lt;/code&gt; 로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="13a462f71ac26baf154dba8703e365c0df2ac20a" translate="yes" xml:space="preserve">
          <source>The library function &lt;a href=&quot;#pdf-type&quot;&gt;&lt;code&gt;type&lt;/code&gt;&lt;/a&gt; returns a string describing the type of a given value (see &lt;a href=&quot;#6.1&quot;&gt;&amp;sect;6.1&lt;/a&gt;).</source>
          <target state="translated">라이브러리 함수 &lt;a href=&quot;#pdf-type&quot;&gt; &lt;code&gt;type&lt;/code&gt; &lt;/a&gt; 은 주어진 값의 유형을 설명하는 문자열을 반환합니다 ( &lt;a href=&quot;#6.1&quot;&gt;&amp;sect;6.1&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="5fc003c63a59472e6941a3dc3f9e6ddca58cd50e" translate="yes" xml:space="preserve">
          <source>The library function &lt;a href=&quot;#pdf-type&quot;&gt;&lt;code&gt;type&lt;/code&gt;&lt;/a&gt; returns a string describing the type of a given value (see &lt;a href=&quot;#pdf-type&quot;&gt;&lt;code&gt;type&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">라이브러리 함수 &lt;a href=&quot;#pdf-type&quot;&gt; &lt;code&gt;type&lt;/code&gt; &lt;/a&gt; 은 주어진 값의 유형을 설명하는 문자열을 반환합니다 ( &lt;a href=&quot;#pdf-type&quot;&gt; &lt;code&gt;type&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="6144a62a4a0e6d0612f6eb91c540d8aa8bcf7d08" translate="yes" xml:space="preserve">
          <source>The logical operators in Lua are &lt;b&gt;and&lt;/b&gt;, &lt;b&gt;or&lt;/b&gt;, and &lt;b&gt;not&lt;/b&gt;. Like the control structures (see &lt;a href=&quot;#3.3.4&quot;&gt;&amp;sect;3.3.4&lt;/a&gt;), all logical operators consider both &lt;b&gt;false&lt;/b&gt; and &lt;b&gt;nil&lt;/b&gt; as false and anything else as true.</source>
          <target state="translated">루아에서 논리 연산자는 &lt;b&gt;와&lt;/b&gt; , &lt;b&gt;나&lt;/b&gt; , 그리고 &lt;b&gt;없습니다&lt;/b&gt; . 제어 구조 ( &lt;a href=&quot;#3.3.4&quot;&gt;&amp;sect;3.3.4&lt;/a&gt; 참조 ) 와 마찬가지로 모든 논리 연산자는 &lt;b&gt;false&lt;/b&gt; 와 &lt;b&gt;nil&lt;/b&gt; 을 모두 &lt;b&gt;false로&lt;/b&gt; 간주 하고 다른 것을 true로 간주합니다.</target>
        </trans-unit>
        <trans-unit id="50f9701ab78d887f6625cde402aefbda0aeac6cc" translate="yes" xml:space="preserve">
          <source>The loop creates ten closures (that is, ten instances of the anonymous function). Each of these closures uses a different &lt;code&gt;y&lt;/code&gt; variable, while all of them share the same &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">루프는 10 개의 클로저 (즉, 익명 함수의 10 개의 인스턴스)를 만듭니다. 이러한 클로저는 서로 다른 &lt;code&gt;y&lt;/code&gt; 변수를 사용하지만 모두 같은 &lt;code&gt;x&lt;/code&gt; 를 공유합니다 .</target>
        </trans-unit>
        <trans-unit id="f1f770e06bb0b2e653c2173ac5aacca6b0af5ebd" translate="yes" xml:space="preserve">
          <source>The loop starts by evaluating &lt;em&gt;explist&lt;/em&gt; to produce four values: an &lt;em&gt;iterator function&lt;/em&gt;, a &lt;em&gt;state&lt;/em&gt;, an initial value for the control variable, and a &lt;em&gt;closing value&lt;/em&gt;.</source>
          <target state="translated">루프는 &lt;em&gt;explist&lt;/em&gt; 를 평가 하여 &lt;em&gt;반복기 함수&lt;/em&gt; , &lt;em&gt;상태&lt;/em&gt; , 제어 변수의 초기 값 및 &lt;em&gt;닫는 값의&lt;/em&gt; 네 가지 값을 생성 하는 것으로 시작 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="6a3ff1f0aa94e8024327de7dc633ad7a75222d95" translate="yes" xml:space="preserve">
          <source>The loop starts by evaluating once the three control expressions. Their values are called respectively the &lt;em&gt;initial value&lt;/em&gt;, the &lt;em&gt;limit&lt;/em&gt;, and the &lt;em&gt;step&lt;/em&gt;. If the step is absent, it defaults to 1.</source>
          <target state="translated">루프는 세 가지 제어 표현식을 한 번 평가하는 것으로 시작됩니다. 이들 값을 각각 &lt;em&gt;초기 값&lt;/em&gt; , &lt;em&gt;한계&lt;/em&gt; 및 &lt;em&gt;단계라고&lt;/em&gt; 합니다. 단계가 없으면 기본값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="4fdc614cc4ad6f49d0283a9ba3115c9056932e8c" translate="yes" xml:space="preserve">
          <source>The loop variable &lt;code&gt;v&lt;/code&gt; is local to the loop body. If you need its value after the loop, assign it to another variable before exiting the loop.</source>
          <target state="translated">루프 변수 &lt;code&gt;v&lt;/code&gt; 는 루프 본문에 대해 로컬입니다. 루프 다음에 값이 필요한 경우 루프를 종료하기 전에 다른 변수에 값을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="939c85d0694beae03ef42c252fc95eeaad38dd40" translate="yes" xml:space="preserve">
          <source>The loop variables &lt;code&gt;&lt;em&gt;var_i&lt;/em&gt;&lt;/code&gt; are local to the loop; you cannot use their values after the &lt;b&gt;for&lt;/b&gt; ends. If you need these values, then assign them to other variables before breaking or exiting the loop.</source>
          <target state="translated">루프 변수 &lt;code&gt;&lt;em&gt;var_i&lt;/em&gt;&lt;/code&gt; 는 루프에 대해 로컬입니다. &lt;b&gt;for&lt;/b&gt; 종료 후에는 해당 값을 사용할 수 없습니다 . 이 값이 필요한 경우 루프를 끊거나 종료하기 전에 다른 변수에 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="b244dd1c7e2205379de1905e2e723510ea200bac" translate="yes" xml:space="preserve">
          <source>The main difference between Lua 5.2 and Lua 5.3 is the introduction of an integer subtype for numbers. Although this change should not affect &quot;normal&quot; computations, some computations (mainly those that involve some kind of overflow) can give different results.</source>
          <target state="translated">Lua 5.2와 Lua 5.3의 주요 차이점은 숫자에 대한 정수 하위 유형의 도입입니다. 이 변경은 &quot;정상&quot;계산에는 영향을 미치지 않지만 일부 계산 (주로 어떤 종류의 오버플로가 포함 된 계산)은 다른 결과를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3024413e5d3167e329701cbe9f0df4ab1bc0ec8a" translate="yes" xml:space="preserve">
          <source>The major multiplier controls the frequency of major collections. For a major multiplier &lt;em&gt;x&lt;/em&gt;, a new major collection will be done when memory grows &lt;em&gt;x%&lt;/em&gt; larger than the memory in use after the previous major collection. For instance, for a multiplier of 100, the collector will do a major collection when the use of memory gets larger than twice the use after the previous collection. The default value is 100; the maximum value is 1000.</source>
          <target state="translated">주요 승수는 주요 컬렉션의 빈도를 제어합니다. 메이저 승수 &lt;em&gt;x의&lt;/em&gt; 경우 메모리 가 이전 메이저 컬렉션 ​​이후 사용중인 메모리보다 &lt;em&gt;x %&lt;/em&gt; 더 커지면 새로운 메이저 컬렉션이 수행됩니다 . 예를 들어 승수가 100 인 경우 수집기는 메모리 사용량이 이전 수집 후 사용보다 두 배 이상 커지면 주요 수집을 수행합니다. 기본값은 100입니다. 최대 값은 1000입니다.</target>
        </trans-unit>
        <trans-unit id="fc3afb9da0c5e976f755e7c1da0bc9514acc6c24" translate="yes" xml:space="preserve">
          <source>The maximum value for &lt;code&gt;n&lt;/code&gt; is 255.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 의 최대 값 은 255입니다.</target>
        </trans-unit>
        <trans-unit id="ffedb8611bd2219ed1341ed93dfa610c03d14160" translate="yes" xml:space="preserve">
          <source>The meaning of accesses to table fields can be changed via metatables (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;).</source>
          <target state="translated">테이블 필드에 대한 액세스의 의미는 메타 테이블을 통해 변경할 수 있습니다 ( &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="ab795f1f93d86887860588306bf3a809576817cd" translate="yes" xml:space="preserve">
          <source>The meaning of accesses to table fields can be changed via metatables. An access to an indexed variable &lt;code&gt;t[i]&lt;/code&gt; is equivalent to a call &lt;code&gt;gettable_event(t,i)&lt;/code&gt;. (See &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt; for a complete description of the &lt;code&gt;gettable_event&lt;/code&gt; function. This function is not defined or callable in Lua. We use it here only for explanatory purposes.)</source>
          <target state="translated">테이블 필드에 대한 액세스의 의미는 메타 테이블을 통해 변경할 수 있습니다. 색인화 된 변수 &lt;code&gt;t[i]&lt;/code&gt; 대한 액세스 는 &lt;code&gt;gettable_event(t,i)&lt;/code&gt; 호출과 같습니다 . ( &lt;code&gt;gettable_event&lt;/code&gt; 함수에 대한 자세한 설명은 &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt; 를 참조하십시오 .이 함수는 Lua에서 정의하거나 호출 할 수 없습니다. 여기서는 설명 목적으로 만 사용합니다.)</target>
        </trans-unit>
        <trans-unit id="51f3fb78699ea2b9989d6abd1980c0cbe4cf6630" translate="yes" xml:space="preserve">
          <source>The meaning of assignments to global variables and table fields can be changed via metatables. An assignment to an indexed variable &lt;code&gt;t[i] = val&lt;/code&gt; is equivalent to &lt;code&gt;settable_event(t,i,val)&lt;/code&gt;. (See &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt; for a complete description of the &lt;code&gt;settable_event&lt;/code&gt; function. This function is not defined or callable in Lua. We use it here only for explanatory purposes.)</source>
          <target state="translated">전역 변수 및 테이블 필드에 대한 할당의 의미는 메타 테이블을 통해 변경할 수 있습니다. 색인화 된 변수 &lt;code&gt;t[i] = val&lt;/code&gt; 대한 지정 은 &lt;code&gt;settable_event(t,i,val)&lt;/code&gt; 과 동일합니다 . ( &lt;code&gt;settable_event&lt;/code&gt; 함수에 대한 자세한 설명은 &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt; 를 참조하십시오 .이 함수는 Lua에서 정의하거나 호출 할 수 없습니다. 여기서는 설명 목적으로 만 사용합니다.)</target>
        </trans-unit>
        <trans-unit id="9a2953cd0234cc021c9ceb35ae45458389e231cf" translate="yes" xml:space="preserve">
          <source>The meaning of assignments to table fields and global variables (which are actually table fields, too) can be changed via metatables (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;).</source>
          <target state="translated">테이블 필드 및 전역 변수 (실제로 테이블 필드이기도 함)에 대한 할당의 의미는 메타 테이블을 통해 변경할 수 있습니다 ( &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="476f7f8ec4dc606dda756c2c57f4d79d5157eb87" translate="yes" xml:space="preserve">
          <source>The metatable for file handles provides metamethods for &lt;code&gt;__gc&lt;/code&gt; and &lt;code&gt;__close&lt;/code&gt; that try to close the file when called.</source>
          <target state="translated">파일 핸들 용 메타 테이블은 호출 될 때 파일을 닫으려고하는 &lt;code&gt;__gc&lt;/code&gt; 및 &lt;code&gt;__close&lt;/code&gt; 에 대한 메타 메서드를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="a517aff7a09be0502b296b4a746e4f103b62d5ad" translate="yes" xml:space="preserve">
          <source>The metavalue for this event can be either a function, a table, or any value with an &lt;code&gt;__index&lt;/code&gt; metavalue. If it is a function, it is called with &lt;code&gt;table&lt;/code&gt; and &lt;code&gt;key&lt;/code&gt; as arguments, and the result of the call (adjusted to one value) is the result of the operation. Otherwise, the final result is the result of indexing this metavalue with &lt;code&gt;key&lt;/code&gt;. This indexing is regular, not raw, and therefore can trigger another &lt;code&gt;__index&lt;/code&gt; metavalue.</source>
          <target state="translated">이 이벤트의 메타 값은 함수, 테이블 또는 &lt;code&gt;__index&lt;/code&gt; 메타 값이있는 모든 값이 될 수 있습니다 . 함수라면 &lt;code&gt;table&lt;/code&gt; 과 &lt;code&gt;key&lt;/code&gt; 를 인자로하여 호출되며, 호출 결과 (하나의 값으로 조정)는 연산의 결과입니다. 그렇지 않으면 최종 결과는이 메타 값을 &lt;code&gt;key&lt;/code&gt; 로 인덱싱 한 결과입니다 . 이 인덱싱은 원시가 아니라 규칙적이므로 다른 &lt;code&gt;__index&lt;/code&gt; 메타 값을 트리거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8a54b38487e5e67e3c97a44903b55794c2a39219" translate="yes" xml:space="preserve">
          <source>The minor multiplier controls the frequency of minor collections. For a minor multiplier &lt;em&gt;x&lt;/em&gt;, a new minor collection will be done when memory grows &lt;em&gt;x%&lt;/em&gt; larger than the memory in use after the previous major collection. For instance, for a multiplier of 20, the collector will do a minor collection when the use of memory gets 20% larger than the use after the previous major collection. The default value is 20; the maximum value is 200.</source>
          <target state="translated">마이너 승수는 마이너 컬렉션의 빈도를 제어합니다. 마이너 승수 &lt;em&gt;x의&lt;/em&gt; 경우 메모리 가 이전 메이저 컬렉션 ​​이후 사용중인 메모리보다 &lt;em&gt;x %&lt;/em&gt; 더 커지면 새로운 마이너 컬렉션이 수행됩니다 . 예를 들어 승수가 20 인 경우 수집기는 메모리 사용량이 이전 주 수집 이후의 사용량보다 20 % 더 많을 때 부 수집을 수행합니다. 기본값은 20입니다. 최대 값은 200입니다.</target>
        </trans-unit>
        <trans-unit id="15199f2dd863423c43df4649876d6a87282f6752" translate="yes" xml:space="preserve">
          <source>The names &lt;em&gt;var_i&lt;/em&gt; declare loop variables local to the loop body. The first of these variables is the &lt;em&gt;control variable&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;var_i&lt;/em&gt; 라는 이름 은 루프 본문에 로컬 인 루프 변수를 선언합니다. 이러한 변수 중 첫 번째는 &lt;em&gt;제어 변수&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e0fe8ffeb58ed09038372ff537610ec6335cea78" translate="yes" xml:space="preserve">
          <source>The negation operator &lt;b&gt;not&lt;/b&gt; always returns &lt;b&gt;false&lt;/b&gt; or &lt;b&gt;true&lt;/b&gt;. The conjunction operator &lt;b&gt;and&lt;/b&gt; returns its first argument if this value is &lt;b&gt;false&lt;/b&gt; or &lt;b&gt;nil&lt;/b&gt;; otherwise, &lt;b&gt;and&lt;/b&gt; returns its second argument. The disjunction operator &lt;b&gt;or&lt;/b&gt; returns its first argument if this value is different from &lt;b&gt;nil&lt;/b&gt; and &lt;b&gt;false&lt;/b&gt;; otherwise, &lt;b&gt;or&lt;/b&gt; returns its second argument. Both &lt;b&gt;and&lt;/b&gt; and &lt;b&gt;or&lt;/b&gt; use short-circuit evaluation; that is, the second operand is evaluated only if necessary. Here are some examples:</source>
          <target state="translated">부정 연산자 &lt;b&gt;가&lt;/b&gt; 항상 &lt;b&gt;false&lt;/b&gt; 또는 &lt;b&gt;true를&lt;/b&gt; 반환 &lt;b&gt;하지는 않습니다&lt;/b&gt; . 연계 연산자 &lt;b&gt;하고&lt;/b&gt; 이 값이 경우 첫 번째 인자를 반환 &lt;b&gt;거짓&lt;/b&gt; 또는 &lt;b&gt;닐&lt;/b&gt; ; 그렇지 않으면 &lt;b&gt;및&lt;/b&gt; 반환의 두 번째 인수를. 이 값이 &lt;b&gt;nil&lt;/b&gt; 및 &lt;b&gt;false&lt;/b&gt; 와 다른 경우 분리 연산자 &lt;b&gt;또는&lt;/b&gt; 첫 번째 인수를 리턴합니다 . 그렇지 않은 경우, &lt;b&gt;또는&lt;/b&gt; 반환의 두 번째 인수를. 모두 &lt;b&gt;와&lt;/b&gt; 및 &lt;b&gt;또는&lt;/b&gt; 사용 단락 회로 평가; 즉, 두 번째 피연산자는 필요한 경우에만 평가됩니다. 여기 몇 가지 예가 있어요.&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="38ec12da384a6d35f4d20d38b437d28efd6741c1" translate="yes" xml:space="preserve">
          <source>The next example collects all pairs &lt;code&gt;key=value&lt;/code&gt; from the given string into a table:</source>
          <target state="translated">다음 예제는 주어진 문자열에서 모든 쌍의 &lt;code&gt;key=value&lt;/code&gt; 를 테이블로 수집 합니다.</target>
        </trans-unit>
        <trans-unit id="116b01f4d99ddb42293ee136ce9aea24e5e4cfa4" translate="yes" xml:space="preserve">
          <source>The notation &lt;b&gt;fail&lt;/b&gt; means a false value representing some kind of failure. (Currently, &lt;b&gt;fail&lt;/b&gt; is equal to &lt;b&gt;nil&lt;/b&gt;, but that may change in future versions. The recommendation is to always test the success of these functions with &lt;code&gt;(not status)&lt;/code&gt;, instead of &lt;code&gt;(status == nil)&lt;/code&gt;.)</source>
          <target state="translated">표기법 &lt;b&gt;실패&lt;/b&gt; 는 어떤 종류의 실패를 나타내는 거짓 값을 의미합니다. (현재 &lt;b&gt;fail&lt;/b&gt; 은 &lt;b&gt;nil&lt;/b&gt; 과 같지만 향후 버전에서 변경 될 수 있습니다. 권장 사항은 항상 &lt;code&gt;(status == nil)&lt;/code&gt; 대신 &lt;code&gt;(not status)&lt;/code&gt; 를 사용 하여 이러한 함수의 성공 여부를 테스트하는 것입니다 .)</target>
        </trans-unit>
        <trans-unit id="71396a651a41b41de0bb0db4aedd5e23034b53f6" translate="yes" xml:space="preserve">
          <source>The numerical &lt;b&gt;for&lt;/b&gt; loop</source>
          <target state="translated">숫자 &lt;b&gt;for&lt;/b&gt; 루프</target>
        </trans-unit>
        <trans-unit id="b8808774c2b04bca424be7db4bdcbf672bc791b6" translate="yes" xml:space="preserve">
          <source>The numerical &lt;b&gt;for&lt;/b&gt; loop repeats a block of code while a control variable goes through an arithmetic progression. It has the following syntax:</source>
          <target state="translated">숫자 &lt;b&gt;for&lt;/b&gt; 루프는 제어 변수가 산술 진행을 거치는 동안 코드 블록을 반복합니다. 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="eb025962461d05ecdc613ae74134730113e392ef" translate="yes" xml:space="preserve">
          <source>The numerical &lt;b&gt;for&lt;/b&gt; loop repeats a block of code while a control variable runs through an arithmetic progression. It has the following syntax:</source>
          <target state="translated">숫자 &lt;b&gt;for&lt;/b&gt; 루프는 제어 변수가 산술 진행을하는 동안 코드 블록을 반복합니다. 다음과 같은 구문이 있습니다.</target>
        </trans-unit>
        <trans-unit id="17ab43bf243843bc19a105d07ba039f8f3f1779b" translate="yes" xml:space="preserve">
          <source>The operator &lt;code&gt;~=&lt;/code&gt; is exactly the negation of equality (&lt;code&gt;==&lt;/code&gt;).</source>
          <target state="translated">연산자 &lt;code&gt;~=&lt;/code&gt; 는 정확히 동등의 부정입니다 ( &lt;code&gt;==&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="3db0143b2ada0fe6ef4d1b484bfc03ef679605a8" translate="yes" xml:space="preserve">
          <source>The options &quot;&lt;code&gt;setpause&lt;/code&gt;&quot; and &quot;&lt;code&gt;setstepmul&lt;/code&gt;&quot; of the function &lt;a href=&quot;#pdf-collectgarbage&quot;&gt;&lt;code&gt;collectgarbage&lt;/code&gt;&lt;/a&gt; are deprecated. You should use the new option &quot;&lt;code&gt;incremental&lt;/code&gt;&quot; to set them.</source>
          <target state="translated">&lt;a href=&quot;#pdf-collectgarbage&quot;&gt; &lt;code&gt;collectgarbage&lt;/code&gt; &lt;/a&gt; 함수의 &quot; &lt;code&gt;setpause&lt;/code&gt; &quot;및 &quot; &lt;code&gt;setstepmul&lt;/code&gt; &quot; 옵션 은 더 이상 사용되지 않습니다. 이를 설정 하려면 새 옵션 &quot; &lt;code&gt;incremental&lt;/code&gt; &quot;을 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="47866a087f6f3e0b29ca9d79b5ace30fa7e691fb" translate="yes" xml:space="preserve">
          <source>The options &lt;code&gt;-e&lt;/code&gt;, &lt;code&gt;-l&lt;/code&gt;, and &lt;code&gt;-W&lt;/code&gt; are handled in the order they appear. For instance, an invocation like</source>
          <target state="translated">&lt;code&gt;-e&lt;/code&gt; , &lt;code&gt;-l&lt;/code&gt; 및 &lt;code&gt;-W&lt;/code&gt; 옵션 은 나타나는 순서대로 처리됩니다. 예를 들어, 다음과 같은 호출</target>
        </trans-unit>
        <trans-unit id="a3cd1dd677d9388e84d76eced4474c97bac8b4fd" translate="yes" xml:space="preserve">
          <source>The options &lt;code&gt;LUA_GCSETPAUSE&lt;/code&gt; and &lt;code&gt;LUA_GCSETSTEPMUL&lt;/code&gt; of the function &lt;a href=&quot;#lua_gc&quot;&gt;&lt;code&gt;lua_gc&lt;/code&gt;&lt;/a&gt; are deprecated. You should use the new option &lt;code&gt;LUA_GCINC&lt;/code&gt; to set them.</source>
          <target state="translated">옵션 &lt;code&gt;LUA_GCSETPAUSE&lt;/code&gt; 및 &lt;code&gt;LUA_GCSETSTEPMUL&lt;/code&gt; 함수의 &lt;a href=&quot;#lua_gc&quot;&gt; &lt;code&gt;lua_gc&lt;/code&gt; 는&lt;/a&gt; 사용되지 않습니다. 새 옵션 &lt;code&gt;LUA_GCINC&lt;/code&gt; 를 사용하여 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="dbc030680dac1e5576f7a0a32beac02271b1de9f" translate="yes" xml:space="preserve">
          <source>The options are:</source>
          <target state="translated">옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c0e99c83b2c086ff1b9d5a58745baab04d9e1b8a" translate="yes" xml:space="preserve">
          <source>The order in which the indices are enumerated is not specified, &lt;em&gt;even for numeric indices&lt;/em&gt;. (To traverse a table in numerical order, use a numerical &lt;b&gt;for&lt;/b&gt;.)</source>
          <target state="translated">&lt;em&gt;숫자 인덱스의 경우에도&lt;/em&gt; 인덱스가 열거되는 순서는 지정되지 않습니다 . (숫자 사용, 번호 순서대로 테이블을 통과하려면 &lt;b&gt;를 들어&lt;/b&gt; .)</target>
        </trans-unit>
        <trans-unit id="30b30ff9b28bb0a62b9d5eaa0e7b9c185acec6fd" translate="yes" xml:space="preserve">
          <source>The order of the assignments in a constructor is undefined. (This order would be relevant only when there are repeated keys.)</source>
          <target state="translated">생성자에서 할당 순서는 정의되어 있지 않습니다. (이 순서는 반복되는 키가있는 경우에만 관련이 있습니다.)</target>
        </trans-unit>
        <trans-unit id="e03d986c8e2482e4650648398c1e744ca72bdc4f" translate="yes" xml:space="preserve">
          <source>The order operators work as follows. If both arguments are numbers, then they are compared according to their mathematical values (regardless of their subtypes). Otherwise, if both arguments are strings, then their values are compared according to the current locale. Otherwise, Lua tries to call the &quot;lt&quot; or the &quot;le&quot; metamethod (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;). A comparison &lt;code&gt;a &amp;gt; b&lt;/code&gt; is translated to &lt;code&gt;b &amp;lt; a&lt;/code&gt; and &lt;code&gt;a &amp;gt;= b&lt;/code&gt; is translated to &lt;code&gt;b &amp;lt;= a&lt;/code&gt;.</source>
          <target state="translated">주문 연산자는 다음과 같이 작동합니다. 두 인수가 모두 숫자 인 경우 하위 유형에 관계없이 수학 값에 따라 비교됩니다. 그렇지 않으면 두 인수가 모두 문자열 인 경우 현재 로케일에 따라 해당 값이 비교됩니다. 그렇지 않으면 Lua는 &quot;lt&quot;또는 &quot;le&quot;메타 메소드를 호출하려고합니다 ( &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt; 참조 ). 비교 용 &lt;code&gt;a &amp;gt; b&lt;/code&gt; 번역되는 &lt;code&gt;b &amp;lt; a&lt;/code&gt; 및 &lt;code&gt;a &amp;gt;= b&lt;/code&gt; 번역되는 &lt;code&gt;b &amp;lt;= a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16d32560c1bc7362c02c6c6224e74a5d3dda3efc" translate="yes" xml:space="preserve">
          <source>The order operators work as follows. If both arguments are numbers, then they are compared according to their mathematical values, regardless of their subtypes. Otherwise, if both arguments are strings, then their values are compared according to the current locale. Otherwise, Lua tries to call the &lt;code&gt;__lt&lt;/code&gt; or the &lt;code&gt;__le&lt;/code&gt; metamethod (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;). A comparison &lt;code&gt;a &amp;gt; b&lt;/code&gt; is translated to &lt;code&gt;b &amp;lt; a&lt;/code&gt; and &lt;code&gt;a &amp;gt;= b&lt;/code&gt; is translated to &lt;code&gt;b &amp;lt;= a&lt;/code&gt;.</source>
          <target state="translated">주문 연산자는 다음과 같이 작동합니다. 두 인수가 모두 숫자이면 하위 유형에 관계없이 수학적 값에 따라 비교됩니다. 그렇지 않고 두 인수가 모두 문자열이면 해당 값은 현재 로케일에 따라 비교됩니다. 그렇지 않으면 Lua는 &lt;code&gt;__lt&lt;/code&gt; 또는 &lt;code&gt;__le&lt;/code&gt; 메타 메서드 를 호출하려고합니다 ( &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt; 참조 ). 비교 용 &lt;code&gt;a &amp;gt; b&lt;/code&gt; 번역되는 &lt;code&gt;b &amp;lt; a&lt;/code&gt; 및 &lt;code&gt;a &amp;gt;= b&lt;/code&gt; 번역되는 &lt;code&gt;b &amp;lt;= a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8a0cda038c86954689aa106e41f099cb177ac64c" translate="yes" xml:space="preserve">
          <source>The package library provides basic facilities for loading modules in Lua. It exports one function directly in the global environment: &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt;. Everything else is exported in a table &lt;a id=&quot;pdf-package&quot;&gt;&lt;code&gt;package&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">패키지 라이브러리는 Lua에서 모듈을로드하기위한 기본 기능을 제공합니다. 전역 환경에서 하나의 함수를 직접 내 보냅니다. &lt;a href=&quot;#pdf-require&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt; . 다른 모든 것은 테이블 &lt;a id=&quot;pdf-package&quot;&gt; &lt;code&gt;package&lt;/code&gt; &lt;/a&gt; 내보내집니다 .</target>
        </trans-unit>
        <trans-unit id="fa03a4bf443ac88c87678b3c72b93c4aa7015676" translate="yes" xml:space="preserve">
          <source>The package library provides basic facilities for loading modules in Lua. It exports one function directly in the global environment: &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt;. Everything else is exported in the table &lt;a id=&quot;pdf-package&quot;&gt;&lt;code&gt;package&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">패키지 라이브러리는 Lua에서 모듈을로드하기위한 기본 기능을 제공합니다. 전역 환경에서 하나의 함수를 직접 내 보냅니다. &lt;a href=&quot;#pdf-require&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt; . 나머지는 모두 테이블 &lt;a id=&quot;pdf-package&quot;&gt; &lt;code&gt;package&lt;/code&gt; &lt;/a&gt; 내보내집니다 .</target>
        </trans-unit>
        <trans-unit id="31abba930e733e4da53e00b6f03a89251bd121d5" translate="yes" xml:space="preserve">
          <source>The panic function runs as if it were a message handler (see &lt;a href=&quot;#2.3&quot;&gt;&amp;sect;2.3&lt;/a&gt;); in particular, the error object is at the top of the stack. However, there is no guarantee about stack space. To push anything on the stack, the panic function must first check the available space (see &lt;a href=&quot;#4.2&quot;&gt;&amp;sect;4.2&lt;/a&gt;).</source>
          <target state="translated">패닉 함수는 마치 메시지 핸들러 인 것처럼 실행됩니다 ( &lt;a href=&quot;#2.3&quot;&gt;&amp;sect;2.3&lt;/a&gt; 참조 ). 특히 오류 개체는 스택의 맨 위에 있습니다. 그러나 스택 공간에 대한 보장은 없습니다. 스택에있는 것을 밀려면 패닉 기능이 먼저 사용 가능한 공간을 확인해야합니다 ( &lt;a href=&quot;#4.2&quot;&gt;&amp;sect;4.2&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="b28207f33d009ff23a6c3b0471b814b49c1801a0" translate="yes" xml:space="preserve">
          <source>The panic function runs as if it were a message handler (see &lt;a href=&quot;#2.3&quot;&gt;&amp;sect;2.3&lt;/a&gt;); in particular, the error object is on the top of the stack. However, there is no guarantee about stack space. To push anything on the stack, the panic function must first check the available space (see &lt;a href=&quot;#4.1.1&quot;&gt;&amp;sect;4.1.1&lt;/a&gt;).</source>
          <target state="translated">패닉 기능은 마치 메시지 핸들러처럼 실행됩니다 ( &lt;a href=&quot;#2.3&quot;&gt;&amp;sect;2.3&lt;/a&gt; 참조 ). 특히 오류 개체는 스택 맨 위에 있습니다. 그러나 스택 공간에 대한 보장은 없습니다. 스택에 무엇이든 푸시하려면 패닉 기능이 먼저 사용 가능한 공간을 확인해야합니다 ( &lt;a href=&quot;#4.1.1&quot;&gt;&amp;sect;4.1.1&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="248c6c24d6328dcec1eced4a5902bd1ca25c30a6" translate="yes" xml:space="preserve">
          <source>The panic function, as its name implies, is a mechanism of last resort. Programs should avoid it. As a general rule, when a C function is called by Lua with a Lua state, it can do whatever it wants on that Lua state, as it should be already protected. However, when C code operates on other Lua states (e.g., a Lua parameter to the function, a Lua state stored in the registry, or the result of &lt;a href=&quot;#lua_newthread&quot;&gt;&lt;code&gt;lua_newthread&lt;/code&gt;&lt;/a&gt;), it should use them only in API calls that cannot raise errors.</source>
          <target state="translated">이름에서 알 수 있듯이 공황 기능은 최후의 수단입니다. 프로그램은 피해야합니다. 일반적으로 Lua 상태의 Lua에서 C 함수를 호출하면 이미 보호되어 있어야하므로 해당 Lua 상태에서 원하는 모든 작업을 수행 할 수 있습니다. 그러나 C 코드가 다른 Lua 상태 (예 : 함수에 대한 Lua 매개 변수, 레지스트리에 저장된 Lua 상태 또는 &lt;a href=&quot;#lua_newthread&quot;&gt; &lt;code&gt;lua_newthread&lt;/code&gt; &lt;/a&gt; 의 결과 )에서 작동하는 경우 오류를 발생시킬 수없는 API 호출에서만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="7cd9dea0b0f86a65a80b1cdf11372d51ac94ffd8" translate="yes" xml:space="preserve">
          <source>The panic function, as its name implies, is a mechanism of last resort. Programs should avoid it. As a general rule, when a C function is called by Lua with a Lua state, it can do whatever it wants on that Lua state, as it should be already protected. However, when C code operates on other Lua states (e.g., a Lua-state argument to the function, a Lua state stored in the registry, or the result of &lt;a href=&quot;#lua_newthread&quot;&gt;&lt;code&gt;lua_newthread&lt;/code&gt;&lt;/a&gt;), it should use them only in API calls that cannot raise errors.</source>
          <target state="translated">이름에서 알 수 있듯이 공황 기능은 최후의 수단입니다. 프로그램은 그것을 피해야합니다. 일반적으로 Lua 상태로 Lua가 C 함수를 호출하면 이미 보호되어 있어야하므로 해당 Lua 상태에서 원하는 모든 작업을 수행 할 수 있습니다. 그러나 C 코드가 다른 Lua 상태 (예 : 함수에 대한 Lua 상태 인수, 레지스트리에 저장된 Lua 상태 또는 &lt;a href=&quot;#lua_newthread&quot;&gt; &lt;code&gt;lua_newthread&lt;/code&gt; &lt;/a&gt; 의 결과 )에서 작동하는 경우 오류를 발생시킬 수없는 API 호출에서만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="af1c6d6c99e2e0d628fe3fc7ee1c5062d171bd6d" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;f&lt;/code&gt; may also be a function. In that case, &lt;code&gt;getlocal&lt;/code&gt; returns only the name of function parameters.</source>
          <target state="translated">파라미터 &lt;code&gt;f&lt;/code&gt; 는 또한 함수일 수있다. 이 경우 &lt;code&gt;getlocal&lt;/code&gt; 은 함수 매개 변수 이름 만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2ee0f1d943cdb63fea614a28b80243ba707db6c6" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;from&lt;/code&gt; represents the coroutine that is resuming &lt;code&gt;L&lt;/code&gt;. If there is no such coroutine, this parameter can be &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;from&lt;/code&gt; 매개 변수 는 &lt;code&gt;L&lt;/code&gt; 을 재개하는 코 루틴을 나타냅니다 . 그러한 코 루틴이 없으면이 매개 변수는 &lt;code&gt;NULL&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="65650656d52c148c40e15fc089970d7544c3c111" translate="yes" xml:space="preserve">
          <source>The path used by &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; to search for a C loader.</source>
          <target state="translated">에서 사용하는 경로는 &lt;a href=&quot;#pdf-require&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt; 는 C 로더를 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a62c3b69148e7d0643526b28757764d931f17eab" translate="yes" xml:space="preserve">
          <source>The path used by &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; to search for a Lua loader.</source>
          <target state="translated">에서 사용하는 경로는 &lt;a href=&quot;#pdf-require&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt; 루아 로더를 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5695907c31c4cdbe5adbf65f538570d9f4bbc4f" translate="yes" xml:space="preserve">
          <source>The pattern (a string, not a function) &quot;&lt;code&gt;[\0-\x7F\xC2-\xF4][\x80-\xBF]*&lt;/code&gt;&quot; (see &lt;a href=&quot;#6.4.1&quot;&gt;&amp;sect;6.4.1&lt;/a&gt;), which matches exactly one UTF-8 byte sequence, assuming that the subject is a valid UTF-8 string.</source>
          <target state="translated">정확히 하나의 UTF-8 바이트 시퀀스와 일치 하는 패턴 (함수가 아닌 문자열) &quot; &lt;code&gt;[\0-\x7F\xC2-\xF4][\x80-\xBF]*&lt;/code&gt; &quot;( &lt;a href=&quot;#6.4.1&quot;&gt;&amp;sect;6.4.1&lt;/a&gt; 참조 ), 주제가 유효한 UTF-8 문자열이라고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="44576e42d538a0d4f15232ab1f12c35467c5f2ae" translate="yes" xml:space="preserve">
          <source>The pattern (a string, not a function) &quot;&lt;code&gt;[\0-\x7F\xC2-\xFD][\x80-\xBF]*&lt;/code&gt;&quot; (see &lt;a href=&quot;#6.4.1&quot;&gt;&amp;sect;6.4.1&lt;/a&gt;), which matches exactly one UTF-8 byte sequence, assuming that the subject is a valid UTF-8 string.</source>
          <target state="translated">정확히 하나의 UTF-8 바이트 시퀀스와 일치 하는 패턴 (함수가 아닌 문자열) &quot; &lt;code&gt;[\0-\x7F\xC2-\xFD][\x80-\xBF]*&lt;/code&gt; &quot;( &lt;a href=&quot;#6.4.1&quot;&gt;&amp;sect;6.4.1&lt;/a&gt; 참조 ) 제목이 유효한 UTF-8 문자열이라고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="87cd937e99e46145262ab909bbf52a9d51f4acf0" translate="yes" xml:space="preserve">
          <source>The pseudo-random number generator used by the function &lt;a href=&quot;#pdf-math.random&quot;&gt;&lt;code&gt;math.random&lt;/code&gt;&lt;/a&gt; now starts with a somewhat random seed. Moreover, it uses a different algorithm.</source>
          <target state="translated">&lt;a href=&quot;#pdf-math.random&quot;&gt; &lt;code&gt;math.random&lt;/code&gt; &lt;/a&gt; 함수에서 사용하는 의사 난수 생성기는 이제 다소 임의의 시드로 시작됩니다. 또한 다른 알고리즘을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4807ffe56b89f96d5345484b52e6277f351113a1" translate="yes" xml:space="preserve">
          <source>The reader function used by &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt;. Every time &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt; needs another piece of the chunk, it calls the reader, passing along its &lt;code&gt;data&lt;/code&gt; parameter. The reader must return a pointer to a block of memory with a new piece of the chunk and set &lt;code&gt;size&lt;/code&gt; to the block size. The block must exist until the reader function is called again. To signal the end of the chunk, the reader must return &lt;code&gt;NULL&lt;/code&gt; or set &lt;code&gt;size&lt;/code&gt; to zero. The reader function may return pieces of any size greater than zero.</source>
          <target state="translated">&lt;a href=&quot;#lua_load&quot;&gt; &lt;code&gt;lua_load&lt;/code&gt; 에서&lt;/a&gt; 사용하는 판독기 함수 입니다. &lt;a href=&quot;#lua_load&quot;&gt; &lt;code&gt;lua_load&lt;/code&gt; &lt;/a&gt; 가 청크의 다른 부분을 필요로 할 때마다 판독기를 호출하여 &lt;code&gt;data&lt;/code&gt; 매개 변수를 전달 합니다. 판독기는 청크의 새 조각이있는 메모리 블록에 대한 포인터를 반환하고 &lt;code&gt;size&lt;/code&gt; 를 블록 크기로 설정 해야합니다. 판독기 기능이 다시 호출 될 때까지 블록이 존재해야합니다. 청크의 끝을 알리려면 판독기가 &lt;code&gt;NULL&lt;/code&gt; 을 반환 하거나 &lt;code&gt;size&lt;/code&gt; 를 0으로 설정 해야합니다 . 판독기 함수는 0보다 큰 크기의 조각을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94196df3b0309cd7d7af8dbae4fe9b55da3dd1ee" translate="yes" xml:space="preserve">
          <source>The reader function used by &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt;. Every time it needs another piece of the chunk, &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt; calls the reader, passing along its &lt;code&gt;data&lt;/code&gt; parameter. The reader must return a pointer to a block of memory with a new piece of the chunk and set &lt;code&gt;size&lt;/code&gt; to the block size. The block must exist until the reader function is called again. To signal the end of the chunk, the reader must return &lt;code&gt;NULL&lt;/code&gt; or set &lt;code&gt;size&lt;/code&gt; to zero. The reader function may return pieces of any size greater than zero.</source>
          <target state="translated">&lt;a href=&quot;#lua_load&quot;&gt; &lt;code&gt;lua_load&lt;/code&gt; 가&lt;/a&gt; 사용하는 리더 기능 . 다른 청크 조각이 필요할 때마다 &lt;a href=&quot;#lua_load&quot;&gt; &lt;code&gt;lua_load&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;data&lt;/code&gt; 매개 변수를 전달하여 리더를 호출합니다 . 리더는 새로운 청크 조각을 가진 메모리 블록에 대한 포인터를 반환하고 &lt;code&gt;size&lt;/code&gt; 를 블록 크기로 설정 해야합니다. 리더 기능이 다시 호출 될 때까지 블록이 존재해야합니다. 청크의 끝을 알리려면 리더에서 &lt;code&gt;NULL&lt;/code&gt; 을 반환 하거나 &lt;code&gt;size&lt;/code&gt; 를 0으로 설정 해야합니다 . 리더 함수는 0보다 큰 크기의 조각을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37f620be9ce9c46f8c6dc3707673277eb2ba004c" translate="yes" xml:space="preserve">
          <source>The return values of &lt;code&gt;lua_load&lt;/code&gt; are:</source>
          <target state="translated">&lt;code&gt;lua_load&lt;/code&gt; 의 반환 값 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2b6bd9b2d65f7c99bb3fd044a11a11e501baf7b6" translate="yes" xml:space="preserve">
          <source>The returned table can contain all the fields returned by &lt;a href=&quot;#lua_getinfo&quot;&gt;&lt;code&gt;lua_getinfo&lt;/code&gt;&lt;/a&gt;, with the string &lt;code&gt;what&lt;/code&gt; describing which fields to fill in. The default for &lt;code&gt;what&lt;/code&gt; is to get all information available, except the table of valid lines. If present, the option '&lt;code&gt;f&lt;/code&gt;' adds a field named &lt;code&gt;func&lt;/code&gt; with the function itself. If present, the option '&lt;code&gt;L&lt;/code&gt;' adds a field named &lt;code&gt;activelines&lt;/code&gt; with the table of valid lines.</source>
          <target state="translated">리턴 된 테이블은 &lt;a href=&quot;#lua_getinfo&quot;&gt; &lt;code&gt;lua_getinfo&lt;/code&gt; &lt;/a&gt; 에 의해 리턴 된 모든 필드를 포함 할 수 있으며 , 어떤 필드를 채워야 &lt;code&gt;what&lt;/code&gt; 설명하는 문자열 이 있습니다. 유효한 행 테이블을 제외하고 사용 가능한 모든 정보를 얻는 &lt;code&gt;what&lt;/code&gt; 기본값 . ' &lt;code&gt;f&lt;/code&gt; ' 옵션이 있으면 함수 자체와 함께 &lt;code&gt;func&lt;/code&gt; 라는 필드가 추가 됩니다. 존재하는 경우 옵션 ' &lt;code&gt;L&lt;/code&gt; ' 은 유효한 행 테이블과 함께 &lt;code&gt;activelines&lt;/code&gt; 라는 필드를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="f55f8b6574e5379a6bf6381df42f2bd48b5ec87a" translate="yes" xml:space="preserve">
          <source>The returned value is a number, whose meaning depends on your system. In POSIX, Windows, and some other systems, this number counts the number of seconds since some given start time (the &quot;epoch&quot;). In other systems, the meaning is not specified, and the number returned by &lt;code&gt;time&lt;/code&gt; can be used only as an argument to &lt;a href=&quot;#pdf-os.date&quot;&gt;&lt;code&gt;os.date&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#pdf-os.difftime&quot;&gt;&lt;code&gt;os.difftime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반환되는 값은 숫자이며 시스템에 따라 그 의미가 다릅니다. POSIX, Windows 및 일부 다른 시스템에서이 숫자는 특정 시작 시간 ( &quot;에포크 (epoch)&quot;) 이후의 시간 (초)을 계산합니다. 다른 시스템에서는 의미가 지정되어 있지 않으며 &lt;code&gt;time&lt;/code&gt; 의해 반환되는 숫자는 &lt;a href=&quot;#pdf-os.date&quot;&gt; &lt;code&gt;os.date&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#pdf-os.difftime&quot;&gt; &lt;code&gt;os.difftime&lt;/code&gt; 에&lt;/a&gt; 대한 인수로만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cfbc7fd540fdc9556b78c0aa760e8e168374c2f5" translate="yes" xml:space="preserve">
          <source>The searcher for C loaders used by &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; changed the way it handles versioned names. Now, the version should come after the module name (as is usual in most other tools). For compatibility, that searcher still tries the old format if it cannot find an open function according to the new style. (Lua 5.2 already worked that way, but it did not document the change.)</source>
          <target state="translated">C 로더를 사용하는 검색자는 버전이 지정된 이름을 처리하는 방식을 변경 &lt;a href=&quot;#pdf-require&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt; 합니다. 이제 버전은 모듈 이름 뒤에 와야합니다 (대부분의 다른 도구에서 일반적으로 사용됨). 호환성을 위해 검색자는 새 스타일에 따라 열린 함수를 찾을 수없는 경우 여전히 이전 형식을 시도합니다. (Lua 5.2는 이미 그렇게 작동했지만 변경 내용을 문서화하지 않았습니다.)</target>
        </trans-unit>
        <trans-unit id="9d03150830b6678b3746886a32e87ec44fd83128" translate="yes" xml:space="preserve">
          <source>The second and third results come from Lua matching an empty string after '&lt;code&gt;b&lt;/code&gt;' and another one after '&lt;code&gt;c&lt;/code&gt;'. Lua does not match an empty string after '&lt;code&gt;a&lt;/code&gt;', because it would end at the same position of the previous match.</source>
          <target state="translated">두 번째와 세 번째 결과는 ' &lt;code&gt;b&lt;/code&gt; ' 뒤의 빈 문자열 과 ' &lt;code&gt;c&lt;/code&gt; ' 뒤의 다른 문자열과 일치하는 Lua에서 나옵니다 . Lua는 ' &lt;code&gt;a&lt;/code&gt; ' 뒤의 빈 문자열과 일치하지 않습니다 . 이전 일치의 동일한 위치에서 끝나기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="d15f5fb6601ee9ab09f9a53d09100cffc80fdb3d" translate="yes" xml:space="preserve">
          <source>The second line is the character that separates templates in a path. Default is '&lt;code&gt;;&lt;/code&gt;'.</source>
          <target state="translated">두 번째 줄은 경로에서 템플릿을 구분하는 문자입니다. 기본값은 ' &lt;code&gt;;&lt;/code&gt; '.</target>
        </trans-unit>
        <trans-unit id="98a2720d48fa26f6e8827171e22966063e194996" translate="yes" xml:space="preserve">
          <source>The second searcher looks for a loader as a Lua library, using the path stored at &lt;a href=&quot;#pdf-package.path&quot;&gt;&lt;code&gt;package.path&lt;/code&gt;&lt;/a&gt;. The search is done as described in function &lt;a href=&quot;#pdf-package.searchpath&quot;&gt;&lt;code&gt;package.searchpath&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">두 번째 검색자는 &lt;a href=&quot;#pdf-package.path&quot;&gt; &lt;code&gt;package.path&lt;/code&gt; 에&lt;/a&gt; 저장된 경로를 사용하여 로더를 Lua 라이브러리로 찾습니다 . &lt;a href=&quot;#pdf-package.searchpath&quot;&gt; &lt;code&gt;package.searchpath&lt;/code&gt; &lt;/a&gt; 함수에 설명 된대로 검색이 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="137238d8dbd009a149982e6efcc20bad727cfcef" translate="yes" xml:space="preserve">
          <source>The semantics of the numerical &lt;b&gt;for&lt;/b&gt; loop over integers changed in some details. In particular, the control variable never wraps around.</source>
          <target state="translated">정수 에 대한 숫자 &lt;b&gt;for&lt;/b&gt; 루프 의 의미가 몇 가지 세부 사항에서 변경되었습니다. 특히 제어 변수는 절대로 래핑되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ff10cde6ef36b0ce8ea3feff1924805fea5410a7" translate="yes" xml:space="preserve">
          <source>The sort algorithm is not stable: elements considered equal by the given order may have their relative positions changed by the sort.</source>
          <target state="translated">정렬 알고리즘이 안정적이지 않습니다. 주어진 순서에 따라 동일하다고 간주되는 요소는 정렬에 의해 상대 위치가 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f130a0a60b21f9cce2226de0fac2751f12370d42" translate="yes" xml:space="preserve">
          <source>The specific behavior of each mode is non portable; check the underlying ISO C function &lt;code&gt;setvbuf&lt;/code&gt; in your platform for more details.</source>
          <target state="translated">각 모드의 특정 동작은 이식 ​​할 수 없습니다. 자세한 내용은 플랫폼 의 기본 ISO C 함수 &lt;code&gt;setvbuf&lt;/code&gt; 를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="3a64ebff4c2ef0f4608bbc1604d0fba5b08a8c95" translate="yes" xml:space="preserve">
          <source>The specifier &lt;code&gt;p&lt;/code&gt; formats the pointer returned by &lt;a href=&quot;#lua_topointer&quot;&gt;&lt;code&gt;lua_topointer&lt;/code&gt;&lt;/a&gt;. That gives a unique string identifier for tables, userdata, threads, strings, and functions. For other values (numbers, nil, booleans), this specifier results in a string representing the pointer &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">지정자 &lt;code&gt;p&lt;/code&gt; 는 &lt;a href=&quot;#lua_topointer&quot;&gt; &lt;code&gt;lua_topointer&lt;/code&gt; 가&lt;/a&gt; 반환하는 포인터를 형식화 합니다. 이는 테이블, 사용자 데이터, 스레드, 문자열 및 함수에 대한 고유 한 문자열 식별자를 제공합니다. 다른 값 (숫자, nil, 부울)의 경우이 지정자는 포인터 &lt;code&gt;NULL&lt;/code&gt; 을 나타내는 문자열이 됩니다 .</target>
        </trans-unit>
        <trans-unit id="092e708e29157a676fc8263f0a955c36a4f68199" translate="yes" xml:space="preserve">
          <source>The specifier &lt;code&gt;q&lt;/code&gt; formats booleans, nil, numbers, and strings in a way that the result is a valid constant in Lua source code. Booleans and nil are written in the obvious way (&lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;nil&lt;/code&gt;). Floats are written in hexadecimal, to preserve full precision. A string is written between double quotes, using escape sequences when necessary to ensure that it can safely be read back by the Lua interpreter. For instance, the call</source>
          <target state="translated">지정자 &lt;code&gt;q&lt;/code&gt; 는 결과가 Lua 소스 코드에서 유효한 상수 인 방식으로 부울, nil, 숫자 및 문자열의 형식을 지정 합니다. 부울과 nil은 명백한 방식으로 작성됩니다 ( &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;nil&lt;/code&gt; ). 부동 소수점은 완전한 정밀도를 유지하기 위해 16 진수로 작성됩니다. 문자열은 Lua 인터프리터가 안전하게 다시 읽을 수 있도록 필요한 경우 이스케이프 시퀀스를 사용하여 큰 따옴표 사이에 작성됩니다. 예를 들어, 전화</target>
        </trans-unit>
        <trans-unit id="98e415d3f3923dae036c196db9c13a7408c478cc" translate="yes" xml:space="preserve">
          <source>The specifier &lt;code&gt;s&lt;/code&gt; expects a string; if its argument is not a string, it is converted to one following the same rules of &lt;a href=&quot;#pdf-tostring&quot;&gt;&lt;code&gt;tostring&lt;/code&gt;&lt;/a&gt;. If the specifier has any modifier, the corresponding string argument should not contain embedded zeros.</source>
          <target state="translated">지정자 &lt;code&gt;s&lt;/code&gt; 는 문자열을 예상합니다. 인수가 문자열이 아니면 동일한 &lt;a href=&quot;#pdf-tostring&quot;&gt; &lt;code&gt;tostring&lt;/code&gt; &lt;/a&gt; 규칙을 따르는 인수로 변환됩니다 . 지정자에 수정자가있는 경우 해당 문자열 인수에 포함 된 0이 포함되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="5106e7eaf9b7ca3b362e6dc6b36e589c34ea6d05" translate="yes" xml:space="preserve">
          <source>The standard Lua libraries provide useful functions that are implemented directly through the C API. Some of these functions provide essential services to the language (e.g., &lt;a href=&quot;#pdf-type&quot;&gt;&lt;code&gt;type&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#pdf-getmetatable&quot;&gt;&lt;code&gt;getmetatable&lt;/code&gt;&lt;/a&gt;); others provide access to &quot;outside&quot; services (e.g., I/O); and others could be implemented in Lua itself, but are quite useful or have critical performance requirements that deserve an implementation in C (e.g., &lt;a href=&quot;#pdf-table.sort&quot;&gt;&lt;code&gt;table.sort&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">표준 Lua 라이브러리는 C API를 통해 직접 구현되는 유용한 기능을 제공합니다. 이러한 기능 중 일부는 언어에 필수적인 서비스를 제공합니다 (예 : &lt;a href=&quot;#pdf-type&quot;&gt; &lt;code&gt;type&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#pdf-getmetatable&quot;&gt; &lt;code&gt;getmetatable&lt;/code&gt; &lt;/a&gt; ). 다른 사람들은 &quot;외부&quot;서비스 (예 : I / O)에 대한 액세스를 제공합니다. 다른 것들도 Lua 자체로 구현 될 수 있지만 C로 구현할 가치가있는 매우 유용하거나 중요한 성능 요구 사항이 있습니다 (예 : &lt;a href=&quot;#pdf-table.sort&quot;&gt; &lt;code&gt;table.sort&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="4f9a410557c9b2b1485364215e1b8ab3d88af66f" translate="yes" xml:space="preserve">
          <source>The standard Lua libraries provide useful functions that are implemented in C through the C API. Some of these functions provide essential services to the language (e.g., &lt;a href=&quot;#pdf-type&quot;&gt;&lt;code&gt;type&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#pdf-getmetatable&quot;&gt;&lt;code&gt;getmetatable&lt;/code&gt;&lt;/a&gt;); others provide access to outside services (e.g., I/O); and others could be implemented in Lua itself, but that for different reasons deserve an implementation in C (e.g., &lt;a href=&quot;#pdf-table.sort&quot;&gt;&lt;code&gt;table.sort&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">표준 Lua 라이브러리는 C API를 통해 C로 구현되는 유용한 기능을 제공합니다. 이러한 함수 중 일부는 언어에 필수적인 서비스를 제공합니다 (예 : &lt;a href=&quot;#pdf-type&quot;&gt; &lt;code&gt;type&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#pdf-getmetatable&quot;&gt; &lt;code&gt;getmetatable&lt;/code&gt; &lt;/a&gt; ). 다른 것들은 외부 서비스에 대한 액세스를 제공합니다 (예 : I / O). 다른 것들은 Lua 자체에서 구현 될 수 있지만 다른 이유로 C로 구현할 가치가 있습니다 (예 : &lt;a href=&quot;#pdf-table.sort&quot;&gt; &lt;code&gt;table.sort&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="f42f392bd799378902334c3d54a3414a4cf4d102" translate="yes" xml:space="preserve">
          <source>The standard paths in the official distribution may change between versions.</source>
          <target state="translated">공식 배포판의 표준 경로는 버전마다 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eaeb2de6b243d1a84e816fda80b831d0cddcf07f" translate="yes" xml:space="preserve">
          <source>The standard representation for file handles used by the standard I/O library.</source>
          <target state="translated">표준 I / O 라이브러리에서 사용하는 파일 핸들의 표준 표현입니다.</target>
        </trans-unit>
        <trans-unit id="bb7020ccdbf4af39d9ada89f1f68b18c849ca42e" translate="yes" xml:space="preserve">
          <source>The standard representation for file handles, which is used by the standard I/O library.</source>
          <target state="translated">표준 I / O 라이브러리에서 사용되는 파일 핸들의 표준 표현입니다.</target>
        </trans-unit>
        <trans-unit id="9fd3499f821fa1f3548e8129d6b35f2161cdaff1" translate="yes" xml:space="preserve">
          <source>The statement</source>
          <target state="translated">진술</target>
        </trans-unit>
        <trans-unit id="b51c68cae2ce99f1a793fe977a6ed087cdabd1ba" translate="yes" xml:space="preserve">
          <source>The status can be 0 (&lt;a href=&quot;#pdf-LUA_OK&quot;&gt;&lt;code&gt;LUA_OK&lt;/code&gt;&lt;/a&gt;) for a normal thread, an error code if the thread finished the execution of a &lt;a href=&quot;#lua_resume&quot;&gt;&lt;code&gt;lua_resume&lt;/code&gt;&lt;/a&gt; with an error, or &lt;a id=&quot;pdf-LUA_YIELD&quot;&gt;&lt;code&gt;LUA_YIELD&lt;/code&gt;&lt;/a&gt; if the thread is suspended.</source>
          <target state="translated">일반 스레드 의 경우 상태는 0 ( &lt;a href=&quot;#pdf-LUA_OK&quot;&gt; &lt;code&gt;LUA_OK&lt;/code&gt; &lt;/a&gt; ), 스레드 가 오류와 함께 &lt;a href=&quot;#lua_resume&quot;&gt; &lt;code&gt;lua_resume&lt;/code&gt; &lt;/a&gt; 의 실행을 완료 한 경우 오류 코드 또는 스레드가 일시 중단 된 경우 &lt;a id=&quot;pdf-LUA_YIELD&quot;&gt; &lt;code&gt;LUA_YIELD&lt;/code&gt; 일&lt;/a&gt; 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba591c4d2347c93e195f1809555bf57c5b0e8a4a" translate="yes" xml:space="preserve">
          <source>The status can be &lt;a href=&quot;#pdf-LUA_OK&quot;&gt;&lt;code&gt;LUA_OK&lt;/code&gt;&lt;/a&gt; for a normal thread, an error code if the thread finished the execution of a &lt;a href=&quot;#lua_resume&quot;&gt;&lt;code&gt;lua_resume&lt;/code&gt;&lt;/a&gt; with an error, or &lt;a href=&quot;#pdf-LUA_YIELD&quot;&gt;&lt;code&gt;LUA_YIELD&lt;/code&gt;&lt;/a&gt; if the thread is suspended.</source>
          <target state="translated">상태가 될 수 &lt;a href=&quot;#pdf-LUA_OK&quot;&gt; &lt;code&gt;LUA_OK&lt;/code&gt; 를&lt;/a&gt; 스레드가 실행을 완료하는 경우 통상의 스레드 에러 코드 &lt;a href=&quot;#lua_resume&quot;&gt; &lt;code&gt;lua_resume&lt;/code&gt; 를&lt;/a&gt; 오류 또는 함께 &lt;a href=&quot;#pdf-LUA_YIELD&quot;&gt; &lt;code&gt;LUA_YIELD&lt;/code&gt; &lt;/a&gt; 스레드가 정지 된 경우.</target>
        </trans-unit>
        <trans-unit id="b6107c417c0095d03331e66cca35b7fc41f404ee" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;mode&lt;/code&gt; controls whether the chunk can be text or binary (that is, a precompiled chunk). It may be the string &quot;&lt;code&gt;b&lt;/code&gt;&quot; (only binary chunks), &quot;&lt;code&gt;t&lt;/code&gt;&quot; (only text chunks), or &quot;&lt;code&gt;bt&lt;/code&gt;&quot; (both binary and text). The default is &quot;&lt;code&gt;bt&lt;/code&gt;&quot;.</source>
          <target state="translated">문자열 &lt;code&gt;mode&lt;/code&gt; 는 청크가 텍스트인지 바이너리인지 (즉, 사전 컴파일 된 청크)를 제어합니다. 문자열 &quot; &lt;code&gt;b&lt;/code&gt; &quot;(이진 청크 만), &quot; &lt;code&gt;t&lt;/code&gt; &quot;(텍스트 청크 만) 또는 &quot; &lt;code&gt;bt&lt;/code&gt; &quot;(이진 및 텍스트) 일 수 있습니다. 기본값은 &quot; &lt;code&gt;bt&lt;/code&gt; &quot;입니다.</target>
        </trans-unit>
        <trans-unit id="eb61b3491c7ef29459d2f5f3b4868e8b5f23f56b" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;mode&lt;/code&gt; works as in function &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">문자열 &lt;code&gt;mode&lt;/code&gt; 는 &lt;a href=&quot;#lua_load&quot;&gt; &lt;code&gt;lua_load&lt;/code&gt; &lt;/a&gt; 함수에서와 같이 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="beb93a28bba84bfd321ab6652fb3b4fded30346b" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;mode&lt;/code&gt; works as in the function &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">문자열 &lt;code&gt;mode&lt;/code&gt; 는 &lt;a href=&quot;#lua_load&quot;&gt; &lt;code&gt;lua_load&lt;/code&gt; &lt;/a&gt; 함수에서와 같이 작동 합니다 .</target>
        </trans-unit>
        <trans-unit id="4f5be0aef9b83b79d571f55826d5a136dfb44d41" translate="yes" xml:space="preserve">
          <source>The string concatenation operator in Lua is denoted by two dots ('&lt;code&gt;..&lt;/code&gt;'). If both operands are strings or numbers, then the numbers are converted to strings in a non-specified format (see &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3&lt;/a&gt;). Otherwise, the &lt;code&gt;__concat&lt;/code&gt; metamethod is called (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;).</source>
          <target state="translated">Lua의 문자열 연결 연산자는 두 개의 점 ( ' &lt;code&gt;..&lt;/code&gt; ')으로 표시됩니다. 두 피연산자가 모두 문자열 또는 숫자이면 숫자는 지정되지 않은 형식의 문자열로 변환됩니다 ( &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3&lt;/a&gt; 참조 ). 그렇지 않으면 &lt;code&gt;__concat&lt;/code&gt; 메타 메서드가 호출됩니다 ( &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="8627952ee0ea9e9e84752d1eff85ae25a6b8cff5" translate="yes" xml:space="preserve">
          <source>The string concatenation operator in Lua is denoted by two dots ('&lt;code&gt;..&lt;/code&gt;'). If both operands are strings or numbers, then they are converted to strings according to the rules described in &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3&lt;/a&gt;. Otherwise, the &lt;code&gt;__concat&lt;/code&gt; metamethod is called (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;).</source>
          <target state="translated">Lua의 문자열 연결 연산자는 두 개의 점 ( ' &lt;code&gt;..&lt;/code&gt; ')으로 표시됩니다. 두 피연산자가 모두 문자열이거나 숫자이면 &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3에&lt;/a&gt; 설명 된 규칙에 따라 문자열로 변환됩니다 . 그렇지 않으면 &lt;code&gt;__concat&lt;/code&gt; 메타 메소드가 호출됩니다 ( &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="9045fd903c161a4ac7a29583b9b8dcf0e5541479" translate="yes" xml:space="preserve">
          <source>The string library assumes one-byte character encodings.</source>
          <target state="translated">문자열 라이브러리는 1 바이트 문자 인코딩을 가정합니다.</target>
        </trans-unit>
        <trans-unit id="b2b7ec0f9126a815843a8b6eedc7a7a4064d3eb8" translate="yes" xml:space="preserve">
          <source>The string library provides all its functions inside the table &lt;a id=&quot;pdf-string&quot;&gt;&lt;code&gt;string&lt;/code&gt;&lt;/a&gt;. It also sets a metatable for strings where the &lt;code&gt;__index&lt;/code&gt; field points to the &lt;code&gt;string&lt;/code&gt; table. Therefore, you can use the string functions in object-oriented style. For instance, &lt;code&gt;string.byte(s,i)&lt;/code&gt; can be written as &lt;code&gt;s:byte(i)&lt;/code&gt;.</source>
          <target state="translated">문자열 라이브러리는 테이블 &lt;a id=&quot;pdf-string&quot;&gt; &lt;code&gt;string&lt;/code&gt; &lt;/a&gt; 안에 모든 기능을 제공 합니다 . 또한 &lt;code&gt;__index&lt;/code&gt; 필드가 &lt;code&gt;string&lt;/code&gt; 테이블을 가리키는 문자열에 대한 메타 테이블을 설정 합니다. 따라서 문자열 함수를 객체 지향 스타일로 사용할 수 있습니다. 예를 들어 &lt;code&gt;string.byte(s,i)&lt;/code&gt; 는 &lt;code&gt;s:byte(i)&lt;/code&gt; 로 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="10a50517543fae51ebb08fb2ec16c2bc73963b6e" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;var.Name&lt;/code&gt; is just syntactic sugar for &lt;code&gt;var[&quot;Name&quot;]&lt;/code&gt;:</source>
          <target state="translated">구문 &lt;code&gt;var.Name&lt;/code&gt; 은 &lt;code&gt;var[&quot;Name&quot;]&lt;/code&gt; 의 구문 설탕입니다 .</target>
        </trans-unit>
        <trans-unit id="050ff8b5782f01590c86d4091d6bf58f847c8377" translate="yes" xml:space="preserve">
          <source>The syntax for function definition is</source>
          <target state="translated">함수 정의 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="632eb45dbc253afb0e4d9a6d182579e0f0a1fc32" translate="yes" xml:space="preserve">
          <source>The table &lt;code&gt;io&lt;/code&gt; also provides three predefined file handles with their usual meanings from C: &lt;a id=&quot;pdf-io.stdin&quot;&gt;&lt;code&gt;io.stdin&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-io.stdout&quot;&gt;&lt;code&gt;io.stdout&lt;/code&gt;&lt;/a&gt;, and &lt;a id=&quot;pdf-io.stderr&quot;&gt;&lt;code&gt;io.stderr&lt;/code&gt;&lt;/a&gt;. The I/O library never closes these files.</source>
          <target state="translated">표 &lt;code&gt;io&lt;/code&gt; 는 C에서 일반적으로 의미하는 &lt;a id=&quot;pdf-io.stdin&quot;&gt; &lt;code&gt;io.stdin&lt;/code&gt; &lt;/a&gt; , &lt;a id=&quot;pdf-io.stdout&quot;&gt; &lt;code&gt;io.stdout&lt;/code&gt; &lt;/a&gt; 및 &lt;a id=&quot;pdf-io.stderr&quot;&gt; &lt;code&gt;io.stderr&lt;/code&gt; 의&lt;/a&gt; 세 가지 사전 정의 된 파일 핸들도 제공합니다 . I / O 라이브러리는 이러한 파일을 닫지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a5bb6863eedf039eb3411f3dbe0637455e54c4cb" translate="yes" xml:space="preserve">
          <source>The third line is the string that marks the substitution points in a template. Default is '&lt;code&gt;?&lt;/code&gt;'.</source>
          <target state="translated">세 번째 줄은 템플릿에서 대체 지점을 표시하는 문자열입니다. 기본값은 ' &lt;code&gt;?&lt;/code&gt; '.</target>
        </trans-unit>
        <trans-unit id="2123107d9c2b8fa74113fcb8969ea618ea87943f" translate="yes" xml:space="preserve">
          <source>The third searcher looks for a loader as a C library, using the path given by the variable &lt;a href=&quot;#pdf-package.cpath&quot;&gt;&lt;code&gt;package.cpath&lt;/code&gt;&lt;/a&gt;. Again, the search is done as described in function &lt;a href=&quot;#pdf-package.searchpath&quot;&gt;&lt;code&gt;package.searchpath&lt;/code&gt;&lt;/a&gt;. For instance, if the C path is the string</source>
          <target state="translated">세 번째 검색자는 변수 &lt;a href=&quot;#pdf-package.cpath&quot;&gt; &lt;code&gt;package.cpath&lt;/code&gt; 가&lt;/a&gt; 제공 한 경로를 사용하여 로더를 C 라이브러리로 찾습니다 . 다시 &lt;a href=&quot;#pdf-package.searchpath&quot;&gt; &lt;code&gt;package.searchpath&lt;/code&gt; &lt;/a&gt; 함수에 설명 된대로 검색이 수행됩니다 . 예를 들어 C 경로가 문자열 인 경우</target>
        </trans-unit>
        <trans-unit id="addd796f69c05ccc4f282e63f096edaf0f445ae8" translate="yes" xml:space="preserve">
          <source>The type &lt;em&gt;number&lt;/em&gt; represents both integer numbers and real (floating-point) numbers, using two subtypes: &lt;em&gt;integer&lt;/em&gt; and &lt;em&gt;float&lt;/em&gt;. Standard Lua uses 64-bit integers and double-precision (64-bit) floats, but you can also compile Lua so that it uses 32-bit integers and/or single-precision (32-bit) floats. The option with 32 bits for both integers and floats is particularly attractive for small machines and embedded systems. (See macro &lt;code&gt;LUA_32BITS&lt;/code&gt; in file &lt;code&gt;luaconf.h&lt;/code&gt;.)</source>
          <target state="translated">유형 &lt;em&gt;번호&lt;/em&gt; 는 &lt;em&gt;정수&lt;/em&gt; 및 &lt;em&gt;부동의&lt;/em&gt; 두 가지 하위 유형을 사용하여 정수와 실수 (부동 소수점)를 모두 나타냅니다 . 표준 Lua는 64 비트 정수와 배정 밀도 (64 비트) 부동 소수점을 사용하지만, 32 비트 정수 및 / 또는 단 정밀도 (32 비트) 부동 소수점을 사용하도록 Lua를 컴파일 할 수도 있습니다. 정수와 부동 소수점 모두에 대해 32 비트 옵션은 소형 기계 및 임베디드 시스템에 특히 매력적입니다. ( &lt;code&gt;LUA_32BITS&lt;/code&gt; 파일의 &lt;code&gt;luaconf.h&lt;/code&gt; 매크로를 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="8accc1fdc3658380909273543cc837dcd9d22775" translate="yes" xml:space="preserve">
          <source>The type &lt;em&gt;number&lt;/em&gt; uses two internal representations, or two subtypes, one called &lt;em&gt;integer&lt;/em&gt; and the other called &lt;em&gt;float&lt;/em&gt;. Lua has explicit rules about when each representation is used, but it also converts between them automatically as needed (see &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3&lt;/a&gt;). Therefore, the programmer may choose to mostly ignore the difference between integers and floats or to assume complete control over the representation of each number. Standard Lua uses 64-bit integers and double-precision (64-bit) floats, but you can also compile Lua so that it uses 32-bit integers and/or single-precision (32-bit) floats. The option with 32 bits for both integers and floats is particularly attractive for small machines and embedded systems. (See macro &lt;code&gt;LUA_32BITS&lt;/code&gt; in file &lt;code&gt;luaconf.h&lt;/code&gt;.)</source>
          <target state="translated">유형 &lt;em&gt;번호&lt;/em&gt; 는 두 개의 내부 표현 또는 두 개의 하위 유형 (하나는 &lt;em&gt;정수&lt;/em&gt; , 다른 하나는 &lt;em&gt;float)을 사용&lt;/em&gt; 합니다. Lua에는 각 표현이 사용되는시기에 대한 명시적인 규칙이 있지만 필요에 따라 자동으로 변환합니다 ( &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3&lt;/a&gt; 참조 ). 따라서 프로그래머는 정수와 부동 소수점의 차이를 대부분 무시하거나 각 숫자의 표현을 완전히 제어한다고 가정 할 수 있습니다. 표준 Lua는 64 비트 정수 및 배정 밀도 (64 비트) 부동 소수점을 사용하지만, 32 비트 정수 및 / 또는 단 정밀도 (32 비트) 부동 소수점을 사용하도록 Lua를 컴파일 할 수도 있습니다. 정수 및 부동 소수점 모두 32 비트 옵션은 특히 소형 기계 및 임베디드 시스템에 적합합니다. (매크로 참조 &lt;code&gt;LUA_32BITS&lt;/code&gt; 파일의 &lt;code&gt;luaconf.h&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="c9782558cfd51d05e29ec07247ff6f0f3156a12c" translate="yes" xml:space="preserve">
          <source>The type &lt;em&gt;string&lt;/em&gt; represents immutable sequences of bytes. Lua is 8-bit clean: strings can contain any 8-bit value, including embedded zeros ('&lt;code&gt;\0&lt;/code&gt;'). Lua is also encoding-agnostic; it makes no assumptions about the contents of a string. The length of any string in Lua must fit in a Lua integer.</source>
          <target state="translated">유형 &lt;em&gt;문자열&lt;/em&gt; 은 변경 불가능한 바이트 시퀀스를 나타냅니다. Lua는 8 비트 정리입니다. 문자열은 포함 된 0 ( ' &lt;code&gt;\0&lt;/code&gt; ')을 포함하여 8 비트 값을 포함 할 수 있습니다 . Lua는 또한 인코딩에 구애받지 않습니다. 문자열의 내용에 대해 가정하지 않습니다. Lua의 문자열 길이는 Lua 정수에 맞아야합니다.</target>
        </trans-unit>
        <trans-unit id="afb6b5b3a4f6e457499e2efa89d3127e8a5239e3" translate="yes" xml:space="preserve">
          <source>The type &lt;em&gt;table&lt;/em&gt; implements associative arrays, that is, arrays that can be indexed not only with numbers, but with any Lua value except &lt;b&gt;nil&lt;/b&gt; and NaN. (&lt;em&gt;Not a Number&lt;/em&gt; is a special value used to represent undefined or unrepresentable numerical results, such as &lt;code&gt;0/0&lt;/code&gt;.) Tables can be &lt;em&gt;heterogeneous&lt;/em&gt;; that is, they can contain values of all types (except &lt;b&gt;nil&lt;/b&gt;). Any key with value &lt;b&gt;nil&lt;/b&gt; is not considered part of the table. Conversely, any key that is not part of a table has an associated value &lt;b&gt;nil&lt;/b&gt;.</source>
          <target state="translated">유형 &lt;em&gt;테이블&lt;/em&gt; 은 연관 배열, 즉 숫자뿐 아니라 &lt;b&gt;nil&lt;/b&gt; 및 NaN을 제외한 Lua 값으로 색인을 생성 할 수있는 배열을 구현 합니다. ( &lt;em&gt;아니 번호&lt;/em&gt; 와 같은 정의하거나 표현할 수없는 수치 결과를 나타내는 데 사용되는 특수한 값 &lt;code&gt;0/0&lt;/code&gt; ). 테이블 일 수 &lt;em&gt;이종&lt;/em&gt; ; 즉, 모든 유형의 값을 포함 할 수 있습니다 ( &lt;b&gt;nil&lt;/b&gt; 제외 ). 값이 &lt;b&gt;nil 인&lt;/b&gt; 키 는 테이블의 일부로 간주되지 않습니다. 반대로, 테이블의 일부가 아닌 키는 연관된 값 &lt;b&gt;nil을&lt;/b&gt; 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="30d0477a11463f9ad22a4a02ea0328499a10323e" translate="yes" xml:space="preserve">
          <source>The type &lt;em&gt;table&lt;/em&gt; implements associative arrays, that is, arrays that can have as indices not only numbers, but any Lua value except &lt;b&gt;nil&lt;/b&gt; and NaN. (&lt;em&gt;Not a Number&lt;/em&gt; is a special floating-point value used by the IEEE 754 standard to represent undefined numerical results, such as &lt;code&gt;0/0&lt;/code&gt;.) Tables can be &lt;em&gt;heterogeneous&lt;/em&gt;; that is, they can contain values of all types (except &lt;b&gt;nil&lt;/b&gt;). Any key associated to the value &lt;b&gt;nil&lt;/b&gt; is not considered part of the table. Conversely, any key that is not part of a table has an associated value &lt;b&gt;nil&lt;/b&gt;.</source>
          <target state="translated">유형 &lt;em&gt;테이블&lt;/em&gt; 은 연관 배열, 즉 숫자뿐만 아니라 &lt;b&gt;nil&lt;/b&gt; 및 NaN을 제외한 모든 Lua 값을 인덱스로 가질 수있는 배열을 구현 합니다. ( &lt;em&gt;아니 번호&lt;/em&gt; 등 undefined 인 수치 결과를 표현하기 위해 IEEE 754 표준에 의해 사용되는 특수한 부동 소수점 값이며, &lt;code&gt;0/0&lt;/code&gt; ). 테이블 일 수 &lt;em&gt;이종&lt;/em&gt; ; 즉, 모든 유형의 값을 포함 할 수 있습니다 ( &lt;b&gt;nil&lt;/b&gt; 제외 ). &lt;b&gt;nil&lt;/b&gt; 값에 연결된 키 는 테이블의 일부로 간주되지 않습니다. 반대로 테이블의 일부가 아닌 모든 키는 연관된 값 &lt;b&gt;nil을&lt;/b&gt; 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="4d9440269930bed052fd86cfbac01a1a963271db" translate="yes" xml:space="preserve">
          <source>The type &lt;em&gt;thread&lt;/em&gt; represents independent threads of execution and it is used to implement coroutines (see &lt;a href=&quot;#2.6&quot;&gt;&amp;sect;2.6&lt;/a&gt;). Lua threads are not related to operating-system threads. Lua supports coroutines on all systems, even those that do not support threads natively.</source>
          <target state="translated">타입 &lt;em&gt;스레드&lt;/em&gt; 는 독립적 인 실행 &lt;em&gt;스레드를&lt;/em&gt; 나타내며 코 루틴을 구현하는 데 사용됩니다 ( &lt;a href=&quot;#2.6&quot;&gt;&amp;sect;2.6&lt;/a&gt; 참조 ). Lua 스레드는 운영 체제 스레드와 관련이 없습니다. Lua는 스레드를 기본적으로 지원하지 않는 시스템을 포함하여 모든 시스템에서 코 루틴을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="8121e5be3e303e17463413ad6f8abdbed524db9a" translate="yes" xml:space="preserve">
          <source>The type &lt;em&gt;userdata&lt;/em&gt; is provided to allow arbitrary C data to be stored in Lua variables. A userdata value represents a block of raw memory. There are two kinds of userdata: &lt;em&gt;full userdata&lt;/em&gt;, which is an object with a block of memory managed by Lua, and &lt;em&gt;light userdata&lt;/em&gt;, which is simply a C pointer value. Userdata has no predefined operations in Lua, except assignment and identity test. By using &lt;em&gt;metatables&lt;/em&gt;, the programmer can define operations for full userdata values (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;). Userdata values cannot be created or modified in Lua, only through the C API. This guarantees the integrity of data owned by the host program and C libraries.</source>
          <target state="translated">임의의 C 데이터를 Lua 변수에 저장할 수 있도록 &lt;em&gt;userdata&lt;/em&gt; 유형 이 제공됩니다. userdata 값은 원시 메모리 블록을 나타냅니다. 사용자 데이터에는 두 가지 종류가 있습니다. Lua가 관리하는 메모리 블록이있는 객체 인 &lt;em&gt;full userdata&lt;/em&gt; 와 단순히 C 포인터 값인 &lt;em&gt;light userdata&lt;/em&gt; 입니다. 사용자 데이터에는 할당 및 신원 테스트를 제외하고 Lua에 사전 정의 된 작업이 없습니다. &lt;em&gt;메타 테이블&lt;/em&gt; 을 사용 하여 프로그래머는 전체 사용자 데이터 값에 대한 작업을 정의 할 수 있습니다 ( &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt; 참조 ). 사용자 데이터 값은 C API를 통해서만 Lua에서 생성하거나 수정할 수 없습니다. 이것은 호스트 프로그램과 C 라이브러리가 소유 한 데이터의 무결성을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="549971961a231ddc4a1edb8a913953e6d0ac1c5d" translate="yes" xml:space="preserve">
          <source>The type &lt;em&gt;userdata&lt;/em&gt; is provided to allow arbitrary C data to be stored in Lua variables. A userdata value represents a block of raw memory. There are two kinds of userdata: &lt;em&gt;full userdata&lt;/em&gt;, which is an object with a block of memory managed by Lua, and &lt;em&gt;light userdata&lt;/em&gt;, which is simply a C pointer value. Userdata has no predefined operations in Lua, except assignment and identity test. By using &lt;em&gt;metatables&lt;/em&gt;, the programmer can define operations for full userdata values (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;). Userdata values cannot be created or modified in Lua, only through the C API. This guarantees the integrity of data owned by the host program.</source>
          <target state="translated">&lt;em&gt;userdata&lt;/em&gt; 유형 은 임의의 C 데이터를 Lua 변수에 저장할 수 있도록 제공됩니다. userdata 값은 원시 메모리 블록을 나타냅니다. : UserData를 두 종류가있다 &lt;em&gt;전체 유저 데이터&lt;/em&gt; 루아에 의해 관리되는 메모리 블록과 함께 목적, &lt;em&gt;광 UserData를&lt;/em&gt; 단순히 C 포인터 값이다. 사용자 데이터는 할당 및 신원 테스트를 제외하고 Lua에서 사전 정의 된 작업이 없습니다. &lt;em&gt;메타 테이블&lt;/em&gt; 을 사용 하여 프로그래머는 전체 사용자 데이터 값에 대한 작업을 정의 할 수 있습니다 ( &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt; 참조 ). C API를 통해서만 Lua에서 사용자 데이터 값을 만들거나 수정할 수 없습니다. 이것은 호스트 프로그램이 소유 한 데이터의 무결성을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="cb2dae663cd0b88537f77f62b52ecd0fdceb5eb7" translate="yes" xml:space="preserve">
          <source>The type for continuation-function contexts. It must be a numeric type. This type is defined as &lt;code&gt;intptr_t&lt;/code&gt; when &lt;code&gt;intptr_t&lt;/code&gt; is available, so that it can store pointers too. Otherwise, it is defined as &lt;code&gt;ptrdiff_t&lt;/code&gt;.</source>
          <target state="translated">연속 함수 컨텍스트의 유형입니다. 숫자 유형이어야합니다. 이 유형은 다음과 같이 정의된다 &lt;code&gt;intptr_t&lt;/code&gt; 때 &lt;code&gt;intptr_t&lt;/code&gt; 이 너무 포인터를 저장할 수 그래서, 사용할 수 있습니다. 그렇지 않으면 &lt;code&gt;ptrdiff_t&lt;/code&gt; 로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="b81ea3cf634f923ceea25ead913b80cfce712bbf" translate="yes" xml:space="preserve">
          <source>The type of floats in Lua.</source>
          <target state="translated">루아의 수레 유형.</target>
        </trans-unit>
        <trans-unit id="7bd0bf99561dfbd918dc1bdb99594d59c184307f" translate="yes" xml:space="preserve">
          <source>The type of integers in Lua.</source>
          <target state="translated">루아의 정수 유형.</target>
        </trans-unit>
        <trans-unit id="f3373938fcc3069867ceda08c5889260b4eb48bd" translate="yes" xml:space="preserve">
          <source>The type of the memory-allocation function used by Lua states. The allocator function must provide a functionality similar to &lt;code&gt;realloc&lt;/code&gt;, but not exactly the same. Its arguments are &lt;code&gt;ud&lt;/code&gt;, an opaque pointer passed to &lt;a href=&quot;#lua_newstate&quot;&gt;&lt;code&gt;lua_newstate&lt;/code&gt;&lt;/a&gt;; &lt;code&gt;ptr&lt;/code&gt;, a pointer to the block being allocated/reallocated/freed; &lt;code&gt;osize&lt;/code&gt;, the original size of the block or some code about what is being allocated; and &lt;code&gt;nsize&lt;/code&gt;, the new size of the block.</source>
          <target state="translated">루아 상태에서 사용하는 메모리 할당 함수의 유형입니다. 할당 자 함수는 &lt;code&gt;realloc&lt;/code&gt; 과 유사 하지만 정확히 동일하지는 않은 기능을 제공해야합니다 . 인수는 &lt;code&gt;ud&lt;/code&gt; , &lt;a href=&quot;#lua_newstate&quot;&gt; &lt;code&gt;lua_newstate&lt;/code&gt; 에&lt;/a&gt; 전달되는 불투명 포인터입니다 . &lt;code&gt;ptr&lt;/code&gt; , 할당 / 재 할당 / 해제되는 블록에 대한 포인터; &lt;code&gt;osize&lt;/code&gt; , 블록의 원래 크기 또는 할당되는 내용에 대한 일부 코드; 및 &lt;code&gt;nsize&lt;/code&gt; , 블록의 새 크기를.</target>
        </trans-unit>
        <trans-unit id="1df269fdb1511aeac5ae2230ae20c7d3efe5a527" translate="yes" xml:space="preserve">
          <source>The type of the writer function used by &lt;a href=&quot;#lua_dump&quot;&gt;&lt;code&gt;lua_dump&lt;/code&gt;&lt;/a&gt;. Every time &lt;a href=&quot;#lua_dump&quot;&gt;&lt;code&gt;lua_dump&lt;/code&gt;&lt;/a&gt; produces another piece of chunk, it calls the writer, passing along the buffer to be written (&lt;code&gt;p&lt;/code&gt;), its size (&lt;code&gt;sz&lt;/code&gt;), and the &lt;code&gt;ud&lt;/code&gt; parameter supplied to &lt;a href=&quot;#lua_dump&quot;&gt;&lt;code&gt;lua_dump&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#lua_dump&quot;&gt; &lt;code&gt;lua_dump&lt;/code&gt; 에서&lt;/a&gt; 사용하는 작성기 함수의 유형입니다 . &lt;a href=&quot;#lua_dump&quot;&gt; &lt;code&gt;lua_dump&lt;/code&gt; &lt;/a&gt; 가 또 다른 청크 조각을 생성 할 때마다 기록기를 호출하여 쓸 버퍼 ( &lt;code&gt;p&lt;/code&gt; ), 크기 ( &lt;code&gt;sz&lt;/code&gt; ) 및 &lt;a href=&quot;#lua_dump&quot;&gt; &lt;code&gt;lua_dump&lt;/code&gt; 에&lt;/a&gt; 제공된 &lt;code&gt;ud&lt;/code&gt; 매개 변수를 전달 합니다.</target>
        </trans-unit>
        <trans-unit id="ea2467b4ef42d2fed95d1a97e4a127587c63bf40" translate="yes" xml:space="preserve">
          <source>The type of the writer function used by &lt;a href=&quot;#lua_dump&quot;&gt;&lt;code&gt;lua_dump&lt;/code&gt;&lt;/a&gt;. Every time it produces another piece of chunk, &lt;a href=&quot;#lua_dump&quot;&gt;&lt;code&gt;lua_dump&lt;/code&gt;&lt;/a&gt; calls the writer, passing along the buffer to be written (&lt;code&gt;p&lt;/code&gt;), its size (&lt;code&gt;sz&lt;/code&gt;), and the &lt;code&gt;data&lt;/code&gt; parameter supplied to &lt;a href=&quot;#lua_dump&quot;&gt;&lt;code&gt;lua_dump&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#lua_dump&quot;&gt; &lt;code&gt;lua_dump&lt;/code&gt; 가&lt;/a&gt; 사용하는 라이터 함수의 유형입니다 . 또 다른 청크 조각을 생성 할 때마다 &lt;a href=&quot;#lua_dump&quot;&gt; &lt;code&gt;lua_dump&lt;/code&gt; &lt;/a&gt; 는 기록기를 버퍼 ( &lt;code&gt;p&lt;/code&gt; ), 크기 ( &lt;code&gt;sz&lt;/code&gt; ) 및 &lt;a href=&quot;#lua_dump&quot;&gt; &lt;code&gt;lua_dump&lt;/code&gt; 에&lt;/a&gt; 제공된 &lt;code&gt;data&lt;/code&gt; 매개 변수를 전달 하여 기록기 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="d018270dc227693da93d9f0a8f9276ac74a821c3" translate="yes" xml:space="preserve">
          <source>The type of warning functions, called by Lua to emit warnings. The first parameter is an opaque pointer set by &lt;a href=&quot;#lua_setwarnf&quot;&gt;&lt;code&gt;lua_setwarnf&lt;/code&gt;&lt;/a&gt;. The second parameter is the warning message. The third parameter is a boolean that indicates whether the message is to be continued by the message in the next call.</source>
          <target state="translated">경고를 내기 위해 Lua에서 호출하는 경고 함수 유형입니다. 첫 번째 매개 변수는 &lt;a href=&quot;#lua_setwarnf&quot;&gt; &lt;code&gt;lua_setwarnf&lt;/code&gt; 로&lt;/a&gt; 설정된 불투명 포인터입니다 . 두 번째 매개 변수는 경고 메시지입니다. 세 번째 매개 변수는 다음 호출에서 메시지가 메시지에 의해 계속되는지 여부를 나타내는 부울입니다.</target>
        </trans-unit>
        <trans-unit id="979b7ad2557665ac8c789bc0692eee0412bef53c" translate="yes" xml:space="preserve">
          <source>The unit of compilation of Lua is called a &lt;em&gt;chunk&lt;/em&gt;. Syntactically, a chunk is simply a block:</source>
          <target state="translated">루아의 컴파일 단위를 &lt;em&gt;청크&lt;/em&gt; 라고합니다 . 문법적으로 덩어리는 단순히 블록입니다.</target>
        </trans-unit>
        <trans-unit id="1fd90de9694cbc90328b75bdffaf97623ca0a9b7" translate="yes" xml:space="preserve">
          <source>The unsigned version of &lt;a href=&quot;#lua_Integer&quot;&gt;&lt;code&gt;lua_Integer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">서명되지 않은 &lt;a href=&quot;#lua_Integer&quot;&gt; &lt;code&gt;lua_Integer&lt;/code&gt; &lt;/a&gt; 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="5f42098ee42cafd687bbe509745646e96e9e3b55" translate="yes" xml:space="preserve">
          <source>The use of the &lt;code&gt;__lt&lt;/code&gt; metamethod to emulate &lt;code&gt;__le&lt;/code&gt; has been removed. When needed, this metamethod must be explicitly defined.</source>
          <target state="translated">&lt;code&gt;__le&lt;/code&gt; 을 에뮬레이트하기 위한 &lt;code&gt;__lt&lt;/code&gt; 메타 메서드 사용 이 제거되었습니다. 필요한 경우이 메타 메서드는 명시 적으로 정의되어야합니다.</target>
        </trans-unit>
        <trans-unit id="ee895c6fec2956941edfd9074d2ad8c6a07996da" translate="yes" xml:space="preserve">
          <source>The value assigned to a to-be-closed variable must have a &lt;code&gt;__close&lt;/code&gt; metamethod or be a false value. (&lt;b&gt;nil&lt;/b&gt; and &lt;b&gt;false&lt;/b&gt; are ignored as to-be-closed values.)</source>
          <target state="translated">종료 될 변수에 할당 된 값은 &lt;code&gt;__close&lt;/code&gt; 메타 메서드가 있거나 거짓 값이어야합니다. ( &lt;b&gt;nil&lt;/b&gt; 및 &lt;b&gt;false&lt;/b&gt; 는 닫힐 값으로 무시됩니다.)</target>
        </trans-unit>
        <trans-unit id="ea5edb4c646d2befa84cf3aa4de94da00e72b361" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;op&lt;/code&gt; must be one of the following constants:</source>
          <target state="translated">&lt;code&gt;op&lt;/code&gt; 의 값은 다음 상수 중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="afade59d4e86a697bf216612fdf19b790b49ed5e" translate="yes" xml:space="preserve">
          <source>The value of &lt;em&gt;&amp;pi;&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;&amp;pi;&lt;/em&gt; 값입니다 .</target>
        </trans-unit>
        <trans-unit id="9dc3bab908539601286c9612ae1893b48ba8219b" translate="yes" xml:space="preserve">
          <source>The value returned is the error code returned by the last call to the writer; 0 means no errors.</source>
          <target state="translated">반환 된 값은 마지막으로 기록기를 호출하여 반환 된 오류 코드입니다. 0은 오류가 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="112b2baa6655f11d826fd17791c335badbd32d34" translate="yes" xml:space="preserve">
          <source>The values in these fields do not need to be inside their valid ranges. For instance, if &lt;code&gt;sec&lt;/code&gt; is -10, it means -10 seconds from the time specified by the other fields; if &lt;code&gt;hour&lt;/code&gt; is 1000, it means +1000 hours from the time specified by the other fields.</source>
          <target state="translated">이 필드의 값은 유효한 범위 내에있을 필요는 없습니다. 예를 들어, &lt;code&gt;sec&lt;/code&gt; 가 -10이면 다른 필드에서 지정한 시간에서 -10 초를 의미합니다. 만약 &lt;code&gt;hour&lt;/code&gt; (1000)이며, 그것은 다른 필드에 의해 지정된 시간에서 1천시간을 의미한다.</target>
        </trans-unit>
        <trans-unit id="a99a66eb862f6556290fc79e5e1c7450f919252a" translate="yes" xml:space="preserve">
          <source>The visibility rules for local variables are explained in &lt;a href=&quot;#3.5&quot;&gt;&amp;sect;3.5&lt;/a&gt;.</source>
          <target state="translated">지역 변수에 대한 가시성 규칙은 &lt;a href=&quot;#3.5&quot;&gt;&amp;sect;3.5에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1638bbae2e91cad1bcbf2314b579efab5e69fee7" translate="yes" xml:space="preserve">
          <source>The writer returns an error code: 0 means no errors; any other value means an error and stops &lt;a href=&quot;#lua_dump&quot;&gt;&lt;code&gt;lua_dump&lt;/code&gt;&lt;/a&gt; from calling the writer again.</source>
          <target state="translated">기록기는 오류 코드를 반환합니다. 0은 오류가 없음을 의미합니다. 다른 값은 오류를 의미하며 &lt;a href=&quot;#lua_dump&quot;&gt; &lt;code&gt;lua_dump&lt;/code&gt; &lt;/a&gt; 가 기록기를 다시 호출하지 못하게 합니다.</target>
        </trans-unit>
        <trans-unit id="e53998e37ed2ba9b38d4b4c370361cd1f8e85f86" translate="yes" xml:space="preserve">
          <source>Then add string pieces to the buffer calling any of the &lt;code&gt;luaL_add*&lt;/code&gt; functions.</source>
          <target state="translated">그런 다음 &lt;code&gt;luaL_add*&lt;/code&gt; 함수를 호출하여 문자열 조각을 버퍼에 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="58d5ea479608da6d358fd4117e4c1650306f8953" translate="yes" xml:space="preserve">
          <source>Then copy the string into that space.</source>
          <target state="translated">그런 다음 문자열을 해당 공간에 복사하십시오.</target>
        </trans-unit>
        <trans-unit id="c38aad0ad68cbec114bc022549a75392e5ff942b" translate="yes" xml:space="preserve">
          <source>Then initialize it and preallocate a space of size &lt;code&gt;sz&lt;/code&gt; with a call &lt;code&gt;luaL_buffinitsize(L, &amp;amp;b, sz)&lt;/code&gt;.</source>
          <target state="translated">그런 다음 그것을 초기화하고 &lt;code&gt;luaL_buffinitsize(L, &amp;amp;b, sz)&lt;/code&gt; 호출로 &lt;code&gt;sz&lt;/code&gt; 크기의 공간을 미리 할당하십시오 .</target>
        </trans-unit>
        <trans-unit id="7fde5c748e0c5d875fb24467538da27e6356bfa2" translate="yes" xml:space="preserve">
          <source>Then initialize it with a call &lt;code&gt;luaL_buffinit(L, &amp;amp;b)&lt;/code&gt;.</source>
          <target state="translated">그런 다음 &lt;code&gt;luaL_buffinit(L, &amp;amp;b)&lt;/code&gt; 호출로 초기화하십시오 .</target>
        </trans-unit>
        <trans-unit id="4a6ac0ddbec77a0c5d75add2623e877e243218e1" translate="yes" xml:space="preserve">
          <source>Then produce the string into that space.</source>
          <target state="translated">그런 다음 해당 공간에 문자열을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="20602b0df785d59b7a2fc157ec725f513e02a1fe" translate="yes" xml:space="preserve">
          <source>Then, at each iteration, Lua calls the iterator function with two arguments: the state and the control variable. The results from this call are then assigned to the loop variables, following the rules of multiple assignments (see &lt;a href=&quot;#3.3.3&quot;&gt;&amp;sect;3.3.3&lt;/a&gt;). If the control variable becomes &lt;b&gt;nil&lt;/b&gt;, the loop terminates. Otherwise, the body is executed and the loop goes to the next iteration.</source>
          <target state="translated">그런 다음 각 반복에서 Lua는 상태 및 제어 변수라는 두 개의 인수를 사용하여 반복기 함수를 호출합니다. 이 호출의 결과는 다중 할당 규칙에 따라 루프 변수에 할당됩니다 ( &lt;a href=&quot;#3.3.3&quot;&gt;&amp;sect;3.3.3&lt;/a&gt; 참조 ). 제어 변수가 &lt;b&gt;nil&lt;/b&gt; 이되면 루프가 종료됩니다. 그렇지 않으면 본문이 실행되고 루프가 다음 반복으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="7c089f6502b4ba313710d9bbf20645416ed3a409" translate="yes" xml:space="preserve">
          <source>Then, we have the following mapping from arguments to parameters and to the vararg expression:</source>
          <target state="translated">그런 다음 인수에서 매개 변수 및 vararg 표현식으로 다음과 같은 맵핑이 있습니다.</target>
        </trans-unit>
        <trans-unit id="589d73d8b2db93fee46410c9d04b6ddf513bc616" translate="yes" xml:space="preserve">
          <source>There are eight basic types in Lua: &lt;em&gt;nil&lt;/em&gt;, &lt;em&gt;boolean&lt;/em&gt;, &lt;em&gt;number&lt;/em&gt;, &lt;em&gt;string&lt;/em&gt;, &lt;em&gt;function&lt;/em&gt;, &lt;em&gt;userdata&lt;/em&gt;, &lt;em&gt;thread&lt;/em&gt;, and &lt;em&gt;table&lt;/em&gt;. The type &lt;em&gt;nil&lt;/em&gt; has one single value, &lt;b&gt;nil&lt;/b&gt;, whose main property is to be different from any other value; it often represents the absence of a useful value. The type &lt;em&gt;boolean&lt;/em&gt; has two values, &lt;b&gt;false&lt;/b&gt; and &lt;b&gt;true&lt;/b&gt;. Both &lt;b&gt;nil&lt;/b&gt; and &lt;b&gt;false&lt;/b&gt; make a condition false; they are collectively called &lt;em&gt;false values&lt;/em&gt;. Any other value makes a condition true.</source>
          <target state="translated">Lua에는 &lt;em&gt;nil&lt;/em&gt; , &lt;em&gt;boolean&lt;/em&gt; , &lt;em&gt;number&lt;/em&gt; , &lt;em&gt;string&lt;/em&gt; , &lt;em&gt;function&lt;/em&gt; , &lt;em&gt;userdata&lt;/em&gt; , &lt;em&gt;thread&lt;/em&gt; , &lt;em&gt;table의&lt;/em&gt; 8 가지 기본 유형이 있습니다 . 타입 &lt;em&gt;닐은&lt;/em&gt; 하나 개의 값을 갖는다 &lt;b&gt;닐&lt;/b&gt; 그의 주요 속성 다른 값을 다르게하는 것이다; 종종 유용한 값이 없음을 나타냅니다. &lt;em&gt;부울&lt;/em&gt; 유형 에는 &lt;b&gt;false&lt;/b&gt; 및 &lt;b&gt;true의&lt;/b&gt; 두 가지 값이 &lt;b&gt;있습니다&lt;/b&gt; . &lt;b&gt;nil&lt;/b&gt; 과 &lt;b&gt;false&lt;/b&gt; 모두 조건을 거짓으로 만듭니다. 집합 적으로 &lt;em&gt;거짓 값&lt;/em&gt; 이라고 &lt;em&gt;합니다&lt;/em&gt; . 다른 값은 조건을 true로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="08f15568d44d3dd2fb189f12b0a139775af30148" translate="yes" xml:space="preserve">
          <source>There are eight basic types in Lua: &lt;em&gt;nil&lt;/em&gt;, &lt;em&gt;boolean&lt;/em&gt;, &lt;em&gt;number&lt;/em&gt;, &lt;em&gt;string&lt;/em&gt;, &lt;em&gt;function&lt;/em&gt;, &lt;em&gt;userdata&lt;/em&gt;, &lt;em&gt;thread&lt;/em&gt;, and &lt;em&gt;table&lt;/em&gt;. The type &lt;em&gt;nil&lt;/em&gt; has one single value, &lt;b&gt;nil&lt;/b&gt;, whose main property is to be different from any other value; it usually represents the absence of a useful value. The type &lt;em&gt;boolean&lt;/em&gt; has two values, &lt;b&gt;false&lt;/b&gt; and &lt;b&gt;true&lt;/b&gt;. Both &lt;b&gt;nil&lt;/b&gt; and &lt;b&gt;false&lt;/b&gt; make a condition false; any other value makes it true. The type &lt;em&gt;number&lt;/em&gt; represents both integer numbers and real (floating-point) numbers. The type &lt;em&gt;string&lt;/em&gt; represents immutable sequences of bytes. Lua is 8-bit clean: strings can contain any 8-bit value, including embedded zeros ('&lt;code&gt;\0&lt;/code&gt;'). Lua is also encoding-agnostic; it makes no assumptions about the contents of a string.</source>
          <target state="translated">Lua에는 &lt;em&gt;nil&lt;/em&gt; , &lt;em&gt;boolean&lt;/em&gt; , &lt;em&gt;number&lt;/em&gt; , &lt;em&gt;string&lt;/em&gt; , &lt;em&gt;function&lt;/em&gt; , &lt;em&gt;userdata&lt;/em&gt; , &lt;em&gt;thread&lt;/em&gt; 및 &lt;em&gt;table의&lt;/em&gt; 8 가지 기본 유형이 있습니다 . 타입 &lt;em&gt;닐은&lt;/em&gt; 하나 개의 값을 갖는다 &lt;b&gt;닐&lt;/b&gt; 그의 주요 속성 다른 값을 다르게하는 것이다; 일반적으로 유용한 값이 없음을 나타냅니다. &lt;em&gt;부울&lt;/em&gt; 유형 에는 &lt;b&gt;false&lt;/b&gt; 및 &lt;b&gt;true의&lt;/b&gt; 두 값이 &lt;b&gt;있습니다&lt;/b&gt; . &lt;b&gt;nil&lt;/b&gt; 과 &lt;b&gt;false&lt;/b&gt; 모두 조건을 거짓으로 만듭니다. 다른 값은 사실입니다. 유형&lt;em&gt; 번호&lt;/em&gt;정수와 실수 (부동 소수점)를 모두 나타냅니다. 유형 &lt;em&gt;문자열&lt;/em&gt; 은 변경할 수없는 바이트 시퀀스를 나타냅니다. Lua는 8 비트입니다. 문자열에는 포함 된 0 ( ' &lt;code&gt;\0&lt;/code&gt; ')을 포함하여 8 비트 값이 포함될 수 있습니다 . 루아는 또한 인코딩에 독립적이다. 문자열의 내용에 대한 가정은 없습니다.</target>
        </trans-unit>
        <trans-unit id="e4a1ac0a2e0cbd023852a04862ae5b37cf817438" translate="yes" xml:space="preserve">
          <source>There are two possible attributes: &lt;code&gt;const&lt;/code&gt;, which declares a constant variable, that is, a variable that cannot be assigned to after its initialization; and &lt;code&gt;close&lt;/code&gt;, which declares a to-be-closed variable (see &lt;a href=&quot;#3.3.8&quot;&gt;&amp;sect;3.3.8&lt;/a&gt;). A list of variables can contain at most one to-be-closed variable.</source>
          <target state="translated">가능한 속성은 두 가지가 있습니다. &lt;code&gt;const&lt;/code&gt; 는 상수 변수, 즉 초기화 후에 할당 할 수없는 변수를 선언합니다. 및 &lt;code&gt;close&lt;/code&gt; 는 닫을 변수를 선언합니다 ( &lt;a href=&quot;#3.3.8&quot;&gt;&amp;sect;3.3.8&lt;/a&gt; 참조 ). 변수 목록에는 최대 하나의 닫힐 변수가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96a0eb6e93ec0e9480d194fa3833ccbc401284c3" translate="yes" xml:space="preserve">
          <source>There is a system-dependent limit on the number of values that a function may return. This limit is guaranteed to be greater than 1000.</source>
          <target state="translated">함수가 반환 할 수있는 값의 수에는 시스템에 따라 제한이 있습니다. 이 제한은 1000보다 큰 것으로 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="7846fd1d69e8fc588a803bcf086d6b71c1b7e6c8" translate="yes" xml:space="preserve">
          <source>There is a system-dependent limit on the number of values that a function may return. This limit is guaranteed to be larger than 1000.</source>
          <target state="translated">함수가 반환 할 수있는 값의 수에는 시스템에 따라 제한이 있습니다. 이 제한은 1000보다 큽니다.</target>
        </trans-unit>
        <trans-unit id="190864f70f817fcefb7920da72729737abc80388" translate="yes" xml:space="preserve">
          <source>There is no explicit function to close or to destroy a thread. Threads are subject to garbage collection, like any Lua object.</source>
          <target state="translated">스레드를 닫거나 파괴하는 명시적인 기능은 없습니다. 스레드는 Lua 객체와 마찬가지로 가비지 수집 대상이됩니다.</target>
        </trans-unit>
        <trans-unit id="cda37c5365062edc06713b41ab47ba449b3019c1" translate="yes" xml:space="preserve">
          <source>These constants are defined in the header file &lt;code&gt;lua.h&lt;/code&gt;.</source>
          <target state="translated">이러한 상수는 헤더 파일 &lt;code&gt;lua.h&lt;/code&gt; 에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="33a5b691e1bbd0d76427c85690ea834884923c9e" translate="yes" xml:space="preserve">
          <source>These operators always result in &lt;b&gt;false&lt;/b&gt; or &lt;b&gt;true&lt;/b&gt;.</source>
          <target state="translated">이 연산자는 항상 &lt;b&gt;false&lt;/b&gt; 또는 &lt;b&gt;true가&lt;/b&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="23af1fc0e094c2dd4a126a0afba341a0993ddceb" translate="yes" xml:space="preserve">
          <source>These unique identifiers allow a program to check whether different closures share upvalues. Lua closures that share an upvalue (that is, that access a same external local variable) will return identical ids for those upvalue indices.</source>
          <target state="translated">이러한 고유 식별자를 통해 프로그램은 서로 다른 클로저가 업 밸류를 공유하는지 여부를 확인할 수 있습니다. 높은 값을 공유하는 (즉, 동일한 외부 로컬 변수에 액세스하는) Lua 클로저는 해당 높은 값 인덱스에 대해 동일한 ID를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fcf0ac285f24f41a8021faef38d1d581f4af95ef" translate="yes" xml:space="preserve">
          <source>This function allocates a new block of memory with the given size, pushes onto the stack a new full userdata with the block address, and returns this address. The host program can freely use this memory.</source>
          <target state="translated">이 함수는 지정된 크기의 새 메모리 블록을 할당하고 블록 주소가있는 새 전체 사용자 데이터를 스택으로 푸시 한 다음이 주소를 반환합니다. 호스트 프로그램은이 메모리를 자유롭게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80082966d6e2d690085ef70dbe523603499247be" translate="yes" xml:space="preserve">
          <source>This function assigns the value &lt;code&gt;value&lt;/code&gt; to the local variable with index &lt;code&gt;local&lt;/code&gt; of the function at level &lt;code&gt;level&lt;/code&gt; of the stack. The function returns &lt;b&gt;fail&lt;/b&gt; if there is no local variable with the given index, and raises an error when called with a &lt;code&gt;level&lt;/code&gt; out of range. (You can call &lt;code&gt;getinfo&lt;/code&gt; to check whether the level is valid.) Otherwise, it returns the name of the local variable.</source>
          <target state="translated">이 함수 는 스택의 수준 &lt;code&gt;level&lt;/code&gt; 에서 함수의 &lt;code&gt;local&lt;/code&gt; 인덱스를 사용 하여 값 &lt;code&gt;value&lt;/code&gt; 을 로컬 변수에 할당합니다 . 이 함수는 주어진 인덱스를 가진 지역 변수가 없으면 &lt;b&gt;fail을&lt;/b&gt; 반환 하고 범위를 벗어난 &lt;code&gt;level&lt;/code&gt; 호출하면 오류를 발생시킵니다 . ( &lt;code&gt;getinfo&lt;/code&gt; 를 호출 하여 레벨이 유효한지 확인할 수 있습니다 .) 그렇지 않으면 지역 변수의 이름을 반환합니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="02ee19d0f7467cfbd14cfa290c226be8222d4802" translate="yes" xml:space="preserve">
          <source>This function assigns the value &lt;code&gt;value&lt;/code&gt; to the local variable with index &lt;code&gt;local&lt;/code&gt; of the function at level &lt;code&gt;level&lt;/code&gt; of the stack. The function returns &lt;b&gt;nil&lt;/b&gt; if there is no local variable with the given index, and raises an error when called with a &lt;code&gt;level&lt;/code&gt; out of range. (You can call &lt;code&gt;getinfo&lt;/code&gt; to check whether the level is valid.) Otherwise, it returns the name of the local variable.</source>
          <target state="translated">이 함수 는 스택의 레벨 &lt;code&gt;level&lt;/code&gt; 에서 함수의 인덱스 &lt;code&gt;local&lt;/code&gt; 을 사용하여 &lt;code&gt;value&lt;/code&gt; 을 로컬 변수에 할당합니다 . 주어진 인덱스에 지역 변수가 없으면 함수는 &lt;b&gt;nil을&lt;/b&gt; 반환 하고, 범위를 벗어난 &lt;code&gt;level&lt;/code&gt; 호출하면 오류가 발생 합니다. ( &lt;code&gt;getinfo&lt;/code&gt; 를 호출 하여 레벨이 유효한지 확인할 수 있습니다 .) 그렇지 않으면 로컬 변수의 이름을 리턴합니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d4f42b7d060b48926fc5748edd544aaabb74f7f0" translate="yes" xml:space="preserve">
          <source>This function assigns the value &lt;code&gt;value&lt;/code&gt; to the upvalue with index &lt;code&gt;up&lt;/code&gt; of the function &lt;code&gt;f&lt;/code&gt;. The function returns &lt;b&gt;fail&lt;/b&gt; if there is no upvalue with the given index. Otherwise, it returns the name of the upvalue.</source>
          <target state="translated">이 함수 는 함수 &lt;code&gt;f&lt;/code&gt; 의 인덱스 &lt;code&gt;up&lt;/code&gt; 으로 upvalue에 값 &lt;code&gt;value&lt;/code&gt; 을 할당합니다 . 주어진 인덱스에 upvalue가 없으면 함수는 &lt;b&gt;실패를&lt;/b&gt; 반환합니다 . 그렇지 않으면 upvalue의 이름을 반환합니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b7496e2514cb1dfc80c2cf0b9e57db48fa2c53f8" translate="yes" xml:space="preserve">
          <source>This function assigns the value &lt;code&gt;value&lt;/code&gt; to the upvalue with index &lt;code&gt;up&lt;/code&gt; of the function &lt;code&gt;f&lt;/code&gt;. The function returns &lt;b&gt;nil&lt;/b&gt; if there is no upvalue with the given index. Otherwise, it returns the name of the upvalue.</source>
          <target state="translated">이 함수 는 함수 &lt;code&gt;f&lt;/code&gt; 의 인덱스 &lt;code&gt;up&lt;/code&gt; 을 사용 하여 값 &lt;code&gt;value&lt;/code&gt; 을 업값에 지정합니다 . 주어진 인덱스에 업 값이 없으면 함수는 &lt;b&gt;nil을&lt;/b&gt; 반환합니다 . 그렇지 않으면, 업 밸류의 이름을 반환합니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ca95f2234def804d470e8cb89141fa32f72381d2" translate="yes" xml:space="preserve">
          <source>This function assumes that &lt;code&gt;s&lt;/code&gt; is a valid UTF-8 string.</source>
          <target state="translated">이 함수는 &lt;code&gt;s&lt;/code&gt; 가 유효한 UTF-8 문자열 이라고 가정 합니다.</target>
        </trans-unit>
        <trans-unit id="9890c3cbbc40d1dddc0de99ae46a48146fcb130a" translate="yes" xml:space="preserve">
          <source>This function behaves exactly like &lt;a href=&quot;#lua_call&quot;&gt;&lt;code&gt;lua_call&lt;/code&gt;&lt;/a&gt;, but allows the called function to yield (see &lt;a href=&quot;#4.5&quot;&gt;&amp;sect;4.5&lt;/a&gt;).</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#lua_call&quot;&gt; &lt;code&gt;lua_call&lt;/code&gt; &lt;/a&gt; 과 똑같이 동작 하지만 호출 된 함수가 양보 할 수 있습니다 ( &lt;a href=&quot;#4.5&quot;&gt;&amp;sect;4.5&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="580c46d5d2b043293bd752a3640317342ee77988" translate="yes" xml:space="preserve">
          <source>This function behaves exactly like &lt;a href=&quot;#lua_call&quot;&gt;&lt;code&gt;lua_call&lt;/code&gt;&lt;/a&gt;, but allows the called function to yield (see &lt;a href=&quot;#4.7&quot;&gt;&amp;sect;4.7&lt;/a&gt;).</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#lua_call&quot;&gt; &lt;code&gt;lua_call&lt;/code&gt; &lt;/a&gt; 과 똑같이 작동 하지만 호출 된 함수가 생성되도록 허용합니다 ( &lt;a href=&quot;#4.7&quot;&gt;&amp;sect;4.7&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="228ffaca57d64d62cbfa46f275e2308925e5e66b" translate="yes" xml:space="preserve">
          <source>This function behaves exactly like &lt;a href=&quot;#lua_pcall&quot;&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt;, but allows the called function to yield (see &lt;a href=&quot;#4.7&quot;&gt;&amp;sect;4.7&lt;/a&gt;).</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#lua_pcall&quot;&gt; &lt;code&gt;lua_pcall&lt;/code&gt; &lt;/a&gt; 과 똑같이 작동 하지만 호출 된 함수가 생성되도록 허용합니다 ( &lt;a href=&quot;#4.7&quot;&gt;&amp;sect;4.7&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="6950878744f6693dff083a31e116fc5f8c212d8b" translate="yes" xml:space="preserve">
          <source>This function behaves exactly like &lt;a href=&quot;#lua_pcall&quot;&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt;, except that it allows the called function to yield (see &lt;a href=&quot;#4.5&quot;&gt;&amp;sect;4.5&lt;/a&gt;).</source>
          <target state="translated">이 함수 는 호출 된 함수가 양보 할 수 있다는 점을 제외 &lt;a href=&quot;#lua_pcall&quot;&gt; &lt;code&gt;lua_pcall&lt;/code&gt; &lt;/a&gt; 과 똑같이 작동합니다 ( &lt;a href=&quot;#4.5&quot;&gt;&amp;sect;4.5&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="ef5d902b412506777fd97b25d07c93121dc8d6e1" translate="yes" xml:space="preserve">
          <source>This function can raise an error if it is called from a thread with a pending C call with no continuation function (what is called a &lt;em&gt;C-call boundary&lt;/em&gt;), or it is called from a thread that is not running inside a resume (typically the main thread).</source>
          <target state="translated">이 함수는 연속 함수가없는 보류중인 C 호출이 있는 스레드에서 호출되거나 ( &lt;em&gt;C 호출 경계&lt;/em&gt; 라고 함) 이력서 내에서 실행되지 않는 스레드에서 호출되는 경우 (일반적으로 메인 스레드).</target>
        </trans-unit>
        <trans-unit id="1bff58bee943ec12e3d7290610d93d1b1f73d8e7" translate="yes" xml:space="preserve">
          <source>This function can raise an error if it is called from a thread with a pending C call with no continuation function, or it is called from a thread that is not running inside a resume (e.g., the main thread).</source>
          <target state="translated">이 함수는 연속 함수가없는 보류중인 C 호출이있는 스레드에서 호출되거나 이력서 내에서 실행되지 않는 스레드 (예 : 기본 스레드)에서 호출 된 경우 오류를 발생시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66854dc63d240dfdfb45adabbcf93e7e8754325d" translate="yes" xml:space="preserve">
          <source>This function creates and pushes on the stack a new full userdata, with &lt;code&gt;nuvalue&lt;/code&gt; associated Lua values, called &lt;code&gt;user values&lt;/code&gt;, plus an associated block of raw memory with &lt;code&gt;size&lt;/code&gt; bytes. (The user values can be set and read with the functions &lt;a href=&quot;#lua_setiuservalue&quot;&gt;&lt;code&gt;lua_setiuservalue&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#lua_getiuservalue&quot;&gt;&lt;code&gt;lua_getiuservalue&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">이 함수 는 &lt;code&gt;user values&lt;/code&gt; 이라고 하는 &lt;code&gt;nuvalue&lt;/code&gt; 관련 Lua 값 과 &lt;code&gt;size&lt;/code&gt; 바이트 의 관련 원시 메모리 블록을 포함하는 새로운 전체 사용자 데이터를 스택에 생성하고 푸시 합니다. (사용자 값은 &lt;a href=&quot;#lua_setiuservalue&quot;&gt; &lt;code&gt;lua_setiuservalue&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#lua_getiuservalue&quot;&gt; &lt;code&gt;lua_getiuservalue&lt;/code&gt; &lt;/a&gt; 함수로 설정하고 읽을 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="54be94a59f0bc6784fed88d3a32e726d290eea51" translate="yes" xml:space="preserve">
          <source>This function does not pop the Lua function from the stack.</source>
          <target state="translated">이 함수는 스택에서 Lua 함수를 팝하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2481d6e1ad7079fac144cbb94c27fa70e98a36a3" translate="yes" xml:space="preserve">
          <source>This function fills parts of a &lt;a href=&quot;#lua_Debug&quot;&gt;&lt;code&gt;lua_Debug&lt;/code&gt;&lt;/a&gt; structure with an identification of the &lt;em&gt;activation record&lt;/em&gt; of the function executing at a given level. Level 0 is the current running function, whereas level &lt;em&gt;n+1&lt;/em&gt; is the function that has called level &lt;em&gt;n&lt;/em&gt; (except for tail calls, which do not count in the stack). When called with a level greater than the stack depth, &lt;a href=&quot;#lua_getstack&quot;&gt;&lt;code&gt;lua_getstack&lt;/code&gt;&lt;/a&gt; returns 0; otherwise it returns 1.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#lua_Debug&quot;&gt; &lt;code&gt;lua_Debug&lt;/code&gt; &lt;/a&gt; 구조의 일부를 주어진 수준에서 실행되는 함수 의 &lt;em&gt;활성화 레코드&lt;/em&gt; 식별로 채 웁니다 . 레벨 0은 현재 실행중인 함수이고, 레벨 &lt;em&gt;n + 1&lt;/em&gt; 은 레벨 &lt;em&gt;n&lt;/em&gt; 을 호출 한 함수입니다 (스택에서 계산되지 않는 마무리 호출 제외). 스택 깊이보다 큰 레벨로 호출하면 &lt;a href=&quot;#lua_getstack&quot;&gt; &lt;code&gt;lua_getstack&lt;/code&gt; &lt;/a&gt; 은 0을 반환합니다. 그렇지 않으면 1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b380c64bb33a1e7916dc907712574229b22846ec" translate="yes" xml:space="preserve">
          <source>This function fills parts of a &lt;a href=&quot;#lua_Debug&quot;&gt;&lt;code&gt;lua_Debug&lt;/code&gt;&lt;/a&gt; structure with an identification of the &lt;em&gt;activation record&lt;/em&gt; of the function executing at a given level. Level 0 is the current running function, whereas level &lt;em&gt;n+1&lt;/em&gt; is the function that has called level &lt;em&gt;n&lt;/em&gt; (except for tail calls, which do not count on the stack). When there are no errors, &lt;a href=&quot;#lua_getstack&quot;&gt;&lt;code&gt;lua_getstack&lt;/code&gt;&lt;/a&gt; returns 1; when called with a level greater than the stack depth, it returns 0.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#lua_Debug&quot;&gt; &lt;code&gt;lua_Debug&lt;/code&gt; &lt;/a&gt; 구조의 일부를 주어진 레벨에서 실행되는 함수 의 &lt;em&gt;활성화 레코드&lt;/em&gt; 식별로 채 웁니다 . 레벨 0은 현재 실행중인 기능이고, 레벨 &lt;em&gt;n + 1&lt;/em&gt; 은 레벨 &lt;em&gt;n&lt;/em&gt; 을 호출 한 기능입니다 (스택에서 계산되지 않는 테일 호출 제외). 오류가 없으면 &lt;a href=&quot;#lua_getstack&quot;&gt; &lt;code&gt;lua_getstack&lt;/code&gt; &lt;/a&gt; 은 1을 반환합니다. 스택 깊이보다 큰 레벨로 호출하면 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="024557e7c0e16ad2ced2b25eb7a968becab0102d" translate="yes" xml:space="preserve">
          <source>This function has the following restrictions:</source>
          <target state="translated">이 기능에는 다음과 같은 제한 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="95f4de101d63040fc5211037c7343d4c56e0ad01" translate="yes" xml:space="preserve">
          <source>This function is a generic interface to the garbage collector. It performs different functions according to its first argument, &lt;code&gt;opt&lt;/code&gt;:</source>
          <target state="translated">이 함수는 가비지 수집기에 대한 일반적인 인터페이스입니다. 첫 번째 인수 인 &lt;code&gt;opt&lt;/code&gt; 에 따라 다른 기능을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="d28a53b3b111db987336d2926f880313a09864bb" translate="yes" xml:space="preserve">
          <source>This function is an interface to the underling pseudo-random generator function provided by C.</source>
          <target state="translated">이 함수는 C에서 제공하는 기본 의사 난수 생성기 함수에 대한 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="1f6bb805a39a7c15cbab2acf8a9252c04d7c39ee" translate="yes" xml:space="preserve">
          <source>This function is equivalent to &lt;a href=&quot;#lua_yieldk&quot;&gt;&lt;code&gt;lua_yieldk&lt;/code&gt;&lt;/a&gt;, but it has no continuation (see &lt;a href=&quot;#4.5&quot;&gt;&amp;sect;4.5&lt;/a&gt;). Therefore, when the thread resumes, it continues the function that called the function calling &lt;code&gt;lua_yield&lt;/code&gt;. To avoid surprises, this function should be called only in a tail call.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#lua_yieldk&quot;&gt; &lt;code&gt;lua_yieldk&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 연속성이 없습니다 ( &lt;a href=&quot;#4.5&quot;&gt;&amp;sect;4.5&lt;/a&gt; 참조 ). 따라서 스레드가 재개되면 &lt;code&gt;lua_yield&lt;/code&gt; 를 호출하는 함수를 호출 한 함수를 계속합니다 . 놀라움을 피하기 위해이 함수는 마무리 호출에서만 호출되어야합니다.</target>
        </trans-unit>
        <trans-unit id="f98115d2ab8e4d7be0cefa4bae9be552429cd8c3" translate="yes" xml:space="preserve">
          <source>This function is equivalent to &lt;a href=&quot;#lua_yieldk&quot;&gt;&lt;code&gt;lua_yieldk&lt;/code&gt;&lt;/a&gt;, but it has no continuation (see &lt;a href=&quot;#4.7&quot;&gt;&amp;sect;4.7&lt;/a&gt;). Therefore, when the thread resumes, it continues the function that called the function calling &lt;code&gt;lua_yield&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#lua_yieldk&quot;&gt; &lt;code&gt;lua_yieldk&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 연속성이 없습니다 ( &lt;a href=&quot;#4.7&quot;&gt;&amp;sect;4.7&lt;/a&gt; 참조 ). 따라서 스레드가 재개되면 &lt;code&gt;lua_yield&lt;/code&gt; 를 호출하는 함수를 호출 한 함수가 계속됩니다 .</target>
        </trans-unit>
        <trans-unit id="09df5ee7dcda106a1d20f49f414f02662778ab04" translate="yes" xml:space="preserve">
          <source>This function is equivalent to the ISO C function &lt;code&gt;system&lt;/code&gt;. It passes &lt;code&gt;command&lt;/code&gt; to be executed by an operating system shell. Its first result is &lt;b&gt;true&lt;/b&gt; if the command terminated successfully, or &lt;b&gt;fail&lt;/b&gt; otherwise. After this first result the function returns a string plus a number, as follows:</source>
          <target state="translated">이 기능은 ISO C 기능 &lt;code&gt;system&lt;/code&gt; 과 동일 합니다 . 운영 체제 셸에서 실행할 &lt;code&gt;command&lt;/code&gt; 을 전달 합니다. 명령이 성공적으로 종료되면 첫 번째 결과는 &lt;b&gt;참&lt;/b&gt; 이고 그렇지 않으면 &lt;b&gt;실패&lt;/b&gt; 합니다. 이 첫 번째 결과 이후 함수는 다음과 같이 문자열과 숫자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="670f5f1a9510a05d3452d6c53437d60b035753b4" translate="yes" xml:space="preserve">
          <source>This function is equivalent to the ISO C function &lt;code&gt;system&lt;/code&gt;. It passes &lt;code&gt;command&lt;/code&gt; to be executed by an operating system shell. Its first result is &lt;b&gt;true&lt;/b&gt; if the command terminated successfully, or &lt;b&gt;nil&lt;/b&gt; otherwise. After this first result the function returns a string plus a number, as follows:</source>
          <target state="translated">이 기능은 ISO C 기능 &lt;code&gt;system&lt;/code&gt; 과 동일 합니다 . 운영 체제 쉘에서 실행할 &lt;code&gt;command&lt;/code&gt; 을 전달 합니다. 명령이 성공적으로 종료 된 경우 첫 번째 결과는 &lt;b&gt;true&lt;/b&gt; 이고 그렇지 않으면 &lt;b&gt;nil&lt;/b&gt; 입니다. 이 첫 번째 결과 후에 함수는 다음과 같이 문자열과 숫자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d3b4b199ecaac9ea3831e4133d9a32cb7ae19470" translate="yes" xml:space="preserve">
          <source>This function is inherently insecure, as it allows Lua to call any function in any readable dynamic library in the system. (Lua calls any function assuming the function has a proper prototype and respects a proper protocol (see &lt;a href=&quot;#lua_CFunction&quot;&gt;&lt;code&gt;lua_CFunction&lt;/code&gt;&lt;/a&gt;). Therefore, calling an arbitrary function in an arbitrary dynamic library more often than not results in an access violation.)</source>
          <target state="translated">이 함수는 Lua가 시스템에서 읽을 수있는 동적 라이브러리의 모든 함수를 호출 할 수 있도록하므로 본질적으로 안전하지 않습니다. (Lua는 함수에 적절한 프로토 타입이 있고 적절한 프로토콜을 &lt;a href=&quot;#lua_CFunction&quot;&gt; &lt;code&gt;lua_CFunction&lt;/code&gt; &lt;/a&gt; 한다고 가정하고 모든 함수를 호출합니다 ( lua_CFunction 참조 ). 따라서 임의의 동적 라이브러리에서 임의의 함수를 호출하면 액세스 위반이 발생하지 않는 경우보다 더 자주 발생합니다.)</target>
        </trans-unit>
        <trans-unit id="e1a39cb0734d0402904008bd0b6e1f1f1778321f" translate="yes" xml:space="preserve">
          <source>This function is not supported by Standard C. As such, it is only available on some platforms (Windows, Linux, Mac OS X, Solaris, BSD, plus other Unix systems that support the &lt;code&gt;dlfcn&lt;/code&gt; standard).</source>
          <target state="translated">이 기능은 Standard C에서 지원되지 않습니다. 따라서 일부 플랫폼 (Windows, Linux, Mac OS X, Solaris, BSD 및 &lt;code&gt;dlfcn&lt;/code&gt; 표준 을 지원하는 기타 Unix 시스템)에서만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="09ff91542609c4270a5672d90a1b6660e19831ef" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;a href=&quot;#pdf-pcall&quot;&gt;&lt;code&gt;pcall&lt;/code&gt;&lt;/a&gt;, except that it sets a new message handler &lt;code&gt;msgh&lt;/code&gt;.</source>
          <target state="translated">이 함수는 새로운 메시지 핸들러 &lt;code&gt;msgh&lt;/code&gt; 를 설정한다는 점을 제외하고 &lt;a href=&quot;#pdf-pcall&quot;&gt; &lt;code&gt;pcall&lt;/code&gt; &lt;/a&gt; 과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="717f7af51aaada41e5e3c40f203c1a8fa9d3bad9" translate="yes" xml:space="preserve">
          <source>This function is system dependent and is not available on all platforms.</source>
          <target state="translated">이 기능은 시스템에 따라 다르며 일부 플랫폼에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11f290796c947e6dfdea50bcfa8240bdb86eb8a0" translate="yes" xml:space="preserve">
          <source>This function is used to build a prefix for error messages.</source>
          <target state="translated">이 기능은 오류 메시지의 접두사를 작성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ab9f48a6c272547f77904d32d9efdba0ecb10345" translate="yes" xml:space="preserve">
          <source>This function may be not thread safe because of its reliance on C function &lt;code&gt;setlocale&lt;/code&gt;.</source>
          <target state="translated">이 함수는 C 함수 &lt;code&gt;setlocale&lt;/code&gt; 에 의존하기 때문에 스레드로부터 안전하지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f5e00f4b8570418e20286901c0f8bb0744338ebc" translate="yes" xml:space="preserve">
          <source>This function may raise an error if the given key is neither &lt;b&gt;nil&lt;/b&gt; nor present in the table. See function &lt;a href=&quot;#pdf-next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; for the caveats of modifying the table during its traversal.</source>
          <target state="translated">이 함수는 주어진 키가 &lt;b&gt;nil&lt;/b&gt; 이 아니 거나 테이블에 존재 하지 않는 경우 오류를 발생시킬 수 있습니다 . 순회 중 테이블 수정에 대한주의 사항은 &lt;a href=&quot;#pdf-next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; 함수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e9bf98dd64c563d3dc312b225a1b47e8d89ef87d" translate="yes" xml:space="preserve">
          <source>This function may raise errors due to memory overflow or an invalid conversion specifier.</source>
          <target state="translated">이 함수는 메모리 오버플로 또는 잘못된 변환 지정자로 인해 오류를 일으킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76e84460922436ebf110cd9c953279251f6cb0bb" translate="yes" xml:space="preserve">
          <source>This function never returns, but it is an idiom to use it in C functions as &lt;code&gt;return luaL_error(&lt;em&gt;args&lt;/em&gt;)&lt;/code&gt;.</source>
          <target state="translated">이 함수는 절대 리턴하지 않지만 C 함수에서이를 &lt;code&gt;return luaL_error(&lt;em&gt;args&lt;/em&gt;)&lt;/code&gt; 으로 사용하는 관용구 입니다.</target>
        </trans-unit>
        <trans-unit id="7a6a8e72aaf1ce15e733e732a309d591ddf3339d" translate="yes" xml:space="preserve">
          <source>This function never returns.</source>
          <target state="translated">이 함수는 절대 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dbd53ac438e83a0043cb356691fb688496f31d3d" translate="yes" xml:space="preserve">
          <source>This function opens a file, in the mode specified in the string &lt;code&gt;mode&lt;/code&gt;. In case of success, it returns a new file handle.</source>
          <target state="translated">이 함수는 문자열 &lt;code&gt;mode&lt;/code&gt; 에 지정된 모드에서 파일을 엽니 다 . 성공하면 새 파일 핸들을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="48efe0efa8028e0841dad22b3bd2dd2fd225e975" translate="yes" xml:space="preserve">
          <source>This function performs several tasks, according to the value of the parameter &lt;code&gt;what&lt;/code&gt;. For options that need extra arguments, they are listed after the option.</source>
          <target state="translated">이 함수는 &lt;code&gt;what&lt;/code&gt; 매개 변수의 값에 따라 여러 작업을 수행합니다 . 추가 인수가 필요한 옵션의 경우 옵션 뒤에 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="1586e455af396a0193bb677436a0ad64943d1618" translate="yes" xml:space="preserve">
          <source>This function performs several tasks, according to the value of the parameter &lt;code&gt;what&lt;/code&gt;:</source>
          <target state="translated">이 기능은 매개 변수의 값에 따라, 여러 가지 작업을 수행 &lt;code&gt;what&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bc205d90b6658beebf2ab75bca0642c69aa0ce84" translate="yes" xml:space="preserve">
          <source>This function pops &lt;code&gt;n&lt;/code&gt; values from the stack &lt;code&gt;from&lt;/code&gt;, and pushes them onto the stack &lt;code&gt;to&lt;/code&gt;.</source>
          <target state="translated">이 함수 팝 &lt;code&gt;n&lt;/code&gt; 값 스택에서 &lt;code&gt;from&lt;/code&gt; 스택 상으로 푸시하고 그들 &lt;code&gt;to&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4693da6260e34753896c1e887316822f4ced3e1d" translate="yes" xml:space="preserve">
          <source>This function pops both the key and the value from the stack. As in Lua, this function may trigger a metamethod for the &quot;newindex&quot; event (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;).</source>
          <target state="translated">이 함수는 스택에서 키와 값을 모두 팝합니다. Lua에서와 &lt;a href=&quot;#2.4&quot;&gt;같이이&lt;/a&gt; 함수는 &quot;newindex&quot;이벤트에 대한 메타 메소드를 트리거 할 수 있습니다 ( &amp;sect;2.4 참조 ).</target>
        </trans-unit>
        <trans-unit id="02f15be23e4eaf0571f919cc7f7e66b956f4d346" translate="yes" xml:space="preserve">
          <source>This function pops the key from the stack, pushing the resulting value in its place. As in Lua, this function may trigger a metamethod for the &quot;index&quot; event (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;).</source>
          <target state="translated">이 기능은 스택에서 키를 팝하여 결과 값을 제자리에 밀어 넣습니다. 루아에서와 &lt;a href=&quot;#2.4&quot;&gt;같이이&lt;/a&gt; 함수는 &quot;인덱스&quot;이벤트에 대한 메타 메소드를 트리거 할 수 있습니다 ( &amp;sect;2.4 참조 ).</target>
        </trans-unit>
        <trans-unit id="02c44d9ce8f4d61b45f6e95f4c2615a475b30c3d" translate="yes" xml:space="preserve">
          <source>This function pops the value from the stack. As in Lua, this function may trigger a metamethod for the &quot;newindex&quot; event (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;).</source>
          <target state="translated">이 함수는 스택에서 값을 팝합니다. Lua에서와 &lt;a href=&quot;#2.4&quot;&gt;같이이&lt;/a&gt; 함수는 &quot;newindex&quot;이벤트에 대한 메타 메소드를 트리거 할 수 있습니다 ( &amp;sect;2.4 참조 ).</target>
        </trans-unit>
        <trans-unit id="d650072e7d52525aa4e9529e95f455ff101b8ac7" translate="yes" xml:space="preserve">
          <source>This function pops the value from the stack. The assignment is raw, that is, it does not invoke &lt;code&gt;__newindex&lt;/code&gt; metamethod.</source>
          <target state="translated">이 함수는 스택에서 값을 팝합니다. 할당은 미가공 즉, &lt;code&gt;__newindex&lt;/code&gt; 메타 메소드를 호출하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4dc9661dd76f18a4a7b7bac51f4e0d8886007ef1" translate="yes" xml:space="preserve">
          <source>This function pops the value from the stack. The assignment is raw, that is, it does not invoke the &lt;code&gt;__newindex&lt;/code&gt; metamethod.</source>
          <target state="translated">이 함수는 스택에서 값을 팝합니다. 할당은 원시적입니다. 즉, &lt;code&gt;__newindex&lt;/code&gt; 메타 메소드를 호출하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="819a7807b617b8fa803512c61d1ba2dc4d437101" translate="yes" xml:space="preserve">
          <source>This function pops the value from the stack. The assignment is raw, that is, it does not use the &lt;code&gt;__newindex&lt;/code&gt; metavalue.</source>
          <target state="translated">이 함수는 스택에서 값을 가져옵니다. 할당은 원시입니다. 즉, &lt;code&gt;__newindex&lt;/code&gt; 메타 값을 사용하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6ab41c2efc54cdc4ab08b428ef1fab2ac04e1717" translate="yes" xml:space="preserve">
          <source>This function produces the return values for file-related functions in the standard library (&lt;a href=&quot;#pdf-io.open&quot;&gt;&lt;code&gt;io.open&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pdf-os.rename&quot;&gt;&lt;code&gt;os.rename&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pdf-file:seek&quot;&gt;&lt;code&gt;file:seek&lt;/code&gt;&lt;/a&gt;, etc.).</source>
          <target state="translated">이 함수는 표준 라이브러리 ( &lt;a href=&quot;#pdf-io.open&quot;&gt; &lt;code&gt;io.open&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#pdf-os.rename&quot;&gt; &lt;code&gt;os.rename&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#pdf-file:seek&quot;&gt; &lt;code&gt;file:seek&lt;/code&gt; &lt;/a&gt; 등) 에서 파일 관련 함수의 반환 값을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="7ba307bd4b8d4a518ec757e560baba91e283126d" translate="yes" xml:space="preserve">
          <source>This function produces the return values for process-related functions in the standard library (&lt;a href=&quot;#pdf-os.execute&quot;&gt;&lt;code&gt;os.execute&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#pdf-io.close&quot;&gt;&lt;code&gt;io.close&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">이 함수는 표준 라이브러리 ( &lt;a href=&quot;#pdf-os.execute&quot;&gt; &lt;code&gt;os.execute&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#pdf-io.close&quot;&gt; &lt;code&gt;io.close&lt;/code&gt; &lt;/a&gt; ) 에서 프로세스 관련 함수의 리턴 값을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="b6746e2c8158506c924e3d9368f6e2be32b4e0d2" translate="yes" xml:space="preserve">
          <source>This function returns 0 on error (for instance, an invalid option in &lt;code&gt;what&lt;/code&gt;).</source>
          <target state="translated">이 함수는 오류시 0을 리턴합니다 (예 : &lt;code&gt;what&lt;/code&gt; 의 유효하지 않은 옵션 ).</target>
        </trans-unit>
        <trans-unit id="007342df8b0ff02345d55706dd45be96b5514f81" translate="yes" xml:space="preserve">
          <source>This function returns 0 to signal an invalid option in &lt;code&gt;what&lt;/code&gt;; even then the valid options are handled correctly.</source>
          <target state="translated">이 함수는 &lt;code&gt;what&lt;/code&gt; 에서 유효하지 않은 옵션을 알리기 위해 0을 반환합니다 . 그래도 유효한 옵션이 올바르게 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="9a4eda5d295976dd3059ff0cebee20501ad1d66f" translate="yes" xml:space="preserve">
          <source>This function returns &lt;code&gt;table&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;table&lt;/code&gt; 을 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="dedc3ddfbc8f8f82058b7b55965c12222160cb90" translate="yes" xml:space="preserve">
          <source>This function returns the name and the value of the local variable with index &lt;code&gt;local&lt;/code&gt; of the function at level &lt;code&gt;f&lt;/code&gt; of the stack. This function accesses not only explicit local variables, but also parameters and temporary values.</source>
          <target state="translated">이 함수는 스택의 레벨 &lt;code&gt;f&lt;/code&gt; 에서 함수의 &lt;code&gt;local&lt;/code&gt; 인덱스를 사용하여 로컬 변수의 이름과 값을 반환합니다 . 이 함수는 명시 적 지역 ​​변수뿐만 아니라 매개 변수 및 임시 값에도 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="cbb6c1599fe3ff6cd07d37a480afe2c16e49c014" translate="yes" xml:space="preserve">
          <source>This function returns the name and the value of the local variable with index &lt;code&gt;local&lt;/code&gt; of the function at level &lt;code&gt;f&lt;/code&gt; of the stack. This function accesses not only explicit local variables, but also parameters, temporaries, etc.</source>
          <target state="translated">이 함수는 스택의 레벨 &lt;code&gt;f&lt;/code&gt; 에서 함수의 인덱스 &lt;code&gt;local&lt;/code&gt; 과 함께 로컬 변수의 이름과 값을 반환합니다 . 이 함수는 명시 적 로컬 변수뿐만 아니라 매개 변수, 임시 등에도 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="6f127ef7aa5ca9413741861659f87c5d2122763a" translate="yes" xml:space="preserve">
          <source>This function returns the name and the value of the upvalue with index &lt;code&gt;up&lt;/code&gt; of the function &lt;code&gt;f&lt;/code&gt;. The function returns &lt;b&gt;fail&lt;/b&gt; if there is no upvalue with the given index.</source>
          <target state="translated">이 기능은 이름과 인덱스와 upvalue의 값 반환 &lt;code&gt;up&lt;/code&gt; 함수의 &lt;code&gt;f&lt;/code&gt; . 주어진 인덱스에 upvalue가 없으면 함수는 &lt;b&gt;실패를&lt;/b&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="11dccabc4359a103d70b6a183c7d1b9e295f7d04" translate="yes" xml:space="preserve">
          <source>This function returns the name and the value of the upvalue with index &lt;code&gt;up&lt;/code&gt; of the function &lt;code&gt;f&lt;/code&gt;. The function returns &lt;b&gt;nil&lt;/b&gt; if there is no upvalue with the given index.</source>
          <target state="translated">이 함수는 함수 &lt;code&gt;f&lt;/code&gt; 의 인덱스 업과 함께 &lt;code&gt;up&lt;/code&gt; 밸류의 이름과 값을 반환합니다 . 주어진 인덱스에 업 값이 없으면 함수는 &lt;b&gt;nil을&lt;/b&gt; 반환합니다 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="dbabb13e68eb92f970ce1720014ee57a5f7be9a6" translate="yes" xml:space="preserve">
          <source>This function returns the same results as &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#pdf-LUA_ERRFILE&quot;&gt;&lt;code&gt;LUA_ERRFILE&lt;/code&gt;&lt;/a&gt; for file-related errors.</source>
          <target state="translated">이 기능은 같은 결과를 반환 &lt;a href=&quot;#lua_load&quot;&gt; &lt;code&gt;lua_load&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#pdf-LUA_ERRFILE&quot;&gt; &lt;code&gt;LUA_ERRFILE&lt;/code&gt; &lt;/a&gt; 파일 관련 오류를.</target>
        </trans-unit>
        <trans-unit id="bebb641f92b0e70a08302c805cbf864b58b36eaf" translate="yes" xml:space="preserve">
          <source>This function returns the same results as &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt;, but it has an extra error code &lt;a id=&quot;pdf-LUA_ERRFILE&quot;&gt;&lt;code&gt;LUA_ERRFILE&lt;/code&gt;&lt;/a&gt; for file-related errors (e.g., it cannot open or read the file).</source>
          <target state="translated">이 기능은 같은 결과를 반환 &lt;a href=&quot;#lua_load&quot;&gt; &lt;code&gt;lua_load&lt;/code&gt; 를&lt;/a&gt; 하지만 추가 오류 코드가 &lt;a id=&quot;pdf-LUA_ERRFILE&quot;&gt; &lt;code&gt;LUA_ERRFILE&lt;/code&gt; &lt;/a&gt; 파일 관련 오류 (예를, 그것은 열 수 없습니다 또는 파일을 읽을).</target>
        </trans-unit>
        <trans-unit id="6596dd0254b38c840e56683db82740f29df06f33" translate="yes" xml:space="preserve">
          <source>This function returns the same results as &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#lua_load&quot;&gt; &lt;code&gt;lua_load&lt;/code&gt; &lt;/a&gt; 와 동일한 결과를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c0db593e94c92390f3357b35159d95eee2be2609" translate="yes" xml:space="preserve">
          <source>This function returns the same results as &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;name&lt;/code&gt; is the chunk name, used for debug information and error messages. The string &lt;code&gt;mode&lt;/code&gt; works as in function &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#lua_load&quot;&gt; &lt;code&gt;lua_load&lt;/code&gt; &lt;/a&gt; 와 동일한 결과를 반환합니다 . &lt;code&gt;name&lt;/code&gt; 은 청크 이름으로 디버그 정보 및 오류 메시지에 사용됩니다. 문자열 &lt;code&gt;mode&lt;/code&gt; 는 &lt;a href=&quot;#lua_load&quot;&gt; &lt;code&gt;lua_load&lt;/code&gt; &lt;/a&gt; 함수에서와 같이 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="fa91cf9c69a1d6d718bdf5a3abdd1697403c8a5e" translate="yes" xml:space="preserve">
          <source>This function returns the same results as &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;name&lt;/code&gt; is the chunk name, used for debug information and error messages. The string &lt;code&gt;mode&lt;/code&gt; works as in the function &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#lua_load&quot;&gt; &lt;code&gt;lua_load&lt;/code&gt; &lt;/a&gt; 와 동일한 결과를 반환합니다 . &lt;code&gt;name&lt;/code&gt; 은 디버그 정보 및 오류 메시지에 사용되는 청크 이름입니다. 문자열 &lt;code&gt;mode&lt;/code&gt; 는 &lt;a href=&quot;#lua_load&quot;&gt; &lt;code&gt;lua_load&lt;/code&gt; &lt;/a&gt; 함수에서와 같이 작동 합니다 .</target>
        </trans-unit>
        <trans-unit id="cf38c50a3f108c7ed76db3fdffae7549d0d9313a" translate="yes" xml:space="preserve">
          <source>This function returns the two seed components that were effectively used, so that setting them again repeats the sequence.</source>
          <target state="translated">이 함수는 효과적으로 사용 된 두 개의 시드 구성 요소를 반환하므로 다시 설정하면 시퀀스가 ​​반복됩니다.</target>
        </trans-unit>
        <trans-unit id="fbd05accb35e1396e632daa50237769ee36b8264" translate="yes" xml:space="preserve">
          <source>This function should not be called for an index that is equal to or below an active to-be-closed index.</source>
          <target state="translated">이 함수는 닫힐 활성 인덱스와 같거나 그 이하인 인덱스에 대해 호출되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="5412475350d1ee79055711d0c4350d66e69ffd6d" translate="yes" xml:space="preserve">
          <source>This function uses &lt;a href=&quot;#lua_tolstring&quot;&gt;&lt;code&gt;lua_tolstring&lt;/code&gt;&lt;/a&gt; to get its result, so all conversions and caveats of that function apply here.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#lua_tolstring&quot;&gt; &lt;code&gt;lua_tolstring&lt;/code&gt; &lt;/a&gt; 을 사용 하여 결과를 얻으므로 해당 함수의 모든 변환 및 경고가 여기에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="f440effb67a02807b5514a47b986fa3c896b974d" translate="yes" xml:space="preserve">
          <source>This function uses the &lt;code&gt;xoshiro256**&lt;/code&gt; algorithm to produce pseudo-random 64-bit integers, which are the results of calls with argument 0. Other results (ranges and floats) are unbiased extracted from these integers.</source>
          <target state="translated">이 함수는 &lt;code&gt;xoshiro256**&lt;/code&gt; 알고리즘을 사용하여 인수 0을 사용한 호출의 결과 인 의사 난수 64 비트 정수를 생성합니다. 다른 결과 (범위 및 부동 소수점)는이 정수에서 편향되지 않은 추출됩니다.</target>
        </trans-unit>
        <trans-unit id="e2d4ea61bcf0f5292e3f253adc7c53a2139d8438" translate="yes" xml:space="preserve">
          <source>This function works like &lt;a href=&quot;#luaL_checkudata&quot;&gt;&lt;code&gt;luaL_checkudata&lt;/code&gt;&lt;/a&gt;, except that, when the test fails, it returns &lt;code&gt;NULL&lt;/code&gt; instead of raising an error.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#luaL_checkudata&quot;&gt; &lt;code&gt;luaL_checkudata&lt;/code&gt; &lt;/a&gt; 와 같이 작동하지만 테스트에 실패 하면 오류를 발생시키는 대신 &lt;code&gt;NULL&lt;/code&gt; 을 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="6563d8fb9cdba4b8e66ee93d7bd36fb67b77cff7" translate="yes" xml:space="preserve">
          <source>This is a low-level function. It completely bypasses the package and module system. Unlike &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt;, it does not perform any path searching and does not automatically adds extensions. &lt;code&gt;libname&lt;/code&gt; must be the complete file name of the C library, including if necessary a path and an extension. &lt;code&gt;funcname&lt;/code&gt; must be the exact name exported by the C library (which may depend on the C compiler and linker used).</source>
          <target state="translated">이것은 저수준 기능입니다. 패키지 및 모듈 시스템을 완전히 무시합니다. &lt;a href=&quot;#pdf-require&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt; 와 달리 경로 검색을 수행하지 않으며 확장명을 자동으로 추가하지 않습니다. &lt;code&gt;libname&lt;/code&gt; 은 필요한 경우 경로와 확장자를 포함하여 C 라이브러리의 완전한 파일 이름이어야합니다. &lt;code&gt;funcname&lt;/code&gt; 은 C 라이브러리에서 내 보낸 정확한 이름이어야합니다 (사용 된 C 컴파일러 및 링커에 따라 다름).</target>
        </trans-unit>
        <trans-unit id="fd11429b923b744979c7d1f098bd69f96f85f6c0" translate="yes" xml:space="preserve">
          <source>This is a useful function for mapping strings to C enums. (The usual convention in Lua libraries is to use strings instead of numbers to select options.)</source>
          <target state="translated">문자열을 C 열거 형에 매핑하는 데 유용한 함수입니다. Lua 라이브러리의 일반적인 규칙은 숫자 대신 문자열을 사용하여 옵션을 선택하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="753037500c4fa6eda5c0c6251d0c5a1a859a582c" translate="yes" xml:space="preserve">
          <source>This is the only function on string buffers that can (and must) be called with an extra element on the stack, which is the value to be added to the buffer.</source>
          <target state="translated">이것은 스택에 추가 요소로 호출 될 수 있고 버퍼에 추가 될 값인 문자열 버퍼에 대한 유일한 함수입니다.</target>
        </trans-unit>
        <trans-unit id="fc6eb47b441fdf44e1e8bc0429e02c5da92dec89" translate="yes" xml:space="preserve">
          <source>This is the only option that can raise a memory error.</source>
          <target state="translated">이것은 메모리 오류를 일으킬 수있는 유일한 옵션입니다.</target>
        </trans-unit>
        <trans-unit id="90d6873741ea710dec0793ac5a59b32c0c418fac" translate="yes" xml:space="preserve">
          <source>This library comprises the operations to manipulate coroutines, which come inside the table &lt;a id=&quot;pdf-coroutine&quot;&gt;&lt;code&gt;coroutine&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;#2.6&quot;&gt;&amp;sect;2.6&lt;/a&gt; for a general description of coroutines.</source>
          <target state="translated">이 라이브러리는 테이블 내부에 와서 코 루틴, 조작하는 작업을 포함하는 &lt;a id=&quot;pdf-coroutine&quot;&gt; &lt;code&gt;coroutine&lt;/code&gt; &lt;/a&gt; . 코 루틴에 대한 일반적인 설명은 &lt;a href=&quot;#2.6&quot;&gt;&amp;sect;2.6&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="90c1b961ab3b38c58be563362f0802d45e85c135" translate="yes" xml:space="preserve">
          <source>This library is implemented through table &lt;a id=&quot;pdf-os&quot;&gt;&lt;code&gt;os&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 라이브러리는 테이블 &lt;a id=&quot;pdf-os&quot;&gt; &lt;code&gt;os&lt;/code&gt; 를&lt;/a&gt; 통해 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="677be47bd4a9ee27a5f7b1353939b6d0981e1e42" translate="yes" xml:space="preserve">
          <source>This library provides basic mathematical functions. It provides all its functions and constants inside the table &lt;a id=&quot;pdf-math&quot;&gt;&lt;code&gt;math&lt;/code&gt;&lt;/a&gt;. Functions with the annotation &quot;&lt;code&gt;integer/float&lt;/code&gt;&quot; give integer results for integer arguments and float results for float (or mixed) arguments. Rounding functions (&lt;a href=&quot;#pdf-math.ceil&quot;&gt;&lt;code&gt;math.ceil&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pdf-math.floor&quot;&gt;&lt;code&gt;math.floor&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#pdf-math.modf&quot;&gt;&lt;code&gt;math.modf&lt;/code&gt;&lt;/a&gt;) return an integer when the result fits in the range of an integer, or a float otherwise.</source>
          <target state="translated">이 라이브러리는 기본적인 수학 함수를 제공합니다. 테이블 &lt;a id=&quot;pdf-math&quot;&gt; &lt;code&gt;math&lt;/code&gt; &lt;/a&gt; 내부의 모든 함수와 상수를 제공합니다 . 주석이 &quot; &lt;code&gt;integer/float&lt;/code&gt; &quot;인 함수는 정수 인수에 대한 정수 결과를 제공하고 부동 (또는 혼합) 인수에 대한 부동 결과를 제공합니다. 반올림 함수 (&lt;a href=&quot;#pdf-math.ceil&quot;&gt; &lt;code&gt;math.ceil&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;#pdf-math.floor&quot;&gt; &lt;code&gt;math.floor&lt;/code&gt; &lt;/a&gt; 및&lt;a href=&quot;#pdf-math.modf&quot;&gt; &lt;code&gt;math.modf&lt;/code&gt; &lt;/a&gt; )는 결과가 정수 범위에 맞으면 정수를 반환하고, 그렇지 않으면 float을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fda34771150302c5e6235e047b8a7d6f844dd96f" translate="yes" xml:space="preserve">
          <source>This library provides basic mathematical functions. It provides all its functions and constants inside the table &lt;a id=&quot;pdf-math&quot;&gt;&lt;code&gt;math&lt;/code&gt;&lt;/a&gt;. Functions with the annotation &quot;&lt;code&gt;integer/float&lt;/code&gt;&quot; give integer results for integer arguments and float results for non-integer arguments. The rounding functions &lt;a href=&quot;#pdf-math.ceil&quot;&gt;&lt;code&gt;math.ceil&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pdf-math.floor&quot;&gt;&lt;code&gt;math.floor&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#pdf-math.modf&quot;&gt;&lt;code&gt;math.modf&lt;/code&gt;&lt;/a&gt; return an integer when the result fits in the range of an integer, or a float otherwise.</source>
          <target state="translated">이 라이브러리는 기본적인 수학 함수를 제공합니다. 그것은 모든 기능과 상수를 테이블 &lt;a id=&quot;pdf-math&quot;&gt; &lt;code&gt;math&lt;/code&gt; &lt;/a&gt; 안에 제공합니다 . &quot; &lt;code&gt;integer/float&lt;/code&gt; &quot; 주석이있는 함수 는 정수 인수에 대해 정수 결과를 제공하고 정수가 아닌 인수에 대해 부동 결과를 제공합니다. 반올림 함수 &lt;a href=&quot;#pdf-math.ceil&quot;&gt; &lt;code&gt;math.ceil&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#pdf-math.floor&quot;&gt; &lt;code&gt;math.floor&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#pdf-math.modf&quot;&gt; &lt;code&gt;math.modf&lt;/code&gt; &lt;/a&gt; 는 결과가 정수 범위에 맞으면 정수를 반환하고 그렇지 않으면 float를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="eff61c8c99df8abb4cc617e0a788ed6e1d7a8ab8" translate="yes" xml:space="preserve">
          <source>This library provides basic support for UTF-8 encoding. It provides all its functions inside the table &lt;a id=&quot;pdf-utf8&quot;&gt;&lt;code&gt;utf8&lt;/code&gt;&lt;/a&gt;. This library does not provide any support for Unicode other than the handling of the encoding. Any operation that needs the meaning of a character, such as character classification, is outside its scope.</source>
          <target state="translated">이 라이브러리는 UTF-8 인코딩에 대한 기본 지원을 제공합니다. 테이블 &lt;a id=&quot;pdf-utf8&quot;&gt; &lt;code&gt;utf8&lt;/code&gt; &lt;/a&gt; 내부의 모든 기능을 제공합니다 . 이 라이브러리는 인코딩 처리 이외의 유니 코드를 지원하지 않습니다. 문자 분류와 같이 문자의 의미가 필요한 모든 작업은 범위를 벗어납니다.</target>
        </trans-unit>
        <trans-unit id="f54156236b7b08469a0920a829130d4325d9534b" translate="yes" xml:space="preserve">
          <source>This library provides generic functions for string manipulation, such as finding and extracting substrings, and pattern matching. When indexing a string in Lua, the first character is at position 1 (not at 0, as in C). Indices are allowed to be negative and are interpreted as indexing backwards, from the end of the string. Thus, the last character is at position -1, and so on.</source>
          <target state="translated">이 라이브러리는 하위 문자열 찾기 및 추출, 패턴 일치와 같은 문자열 조작을위한 일반 기능을 제공합니다. Lua에서 문자열을 색인 할 때 첫 번째 문자는 위치 1에 있습니다 (C에서와 같이 0이 아님). 인덱스는 음수가 될 수 있으며 문자열의 끝에서 뒤로 색인으로 해석됩니다. 따라서 마지막 문자는 위치 -1에 있습니다.</target>
        </trans-unit>
        <trans-unit id="eaff80ded470719d876c589d5513c23d7a2d941b" translate="yes" xml:space="preserve">
          <source>This library provides generic functions for table manipulation. It provides all its functions inside the table &lt;a id=&quot;pdf-table&quot;&gt;&lt;code&gt;table&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 라이브러리는 테이블 조작을위한 일반 기능을 제공합니다. 테이블 내부의 모든 기능을 제공합니다.&lt;a id=&quot;pdf-table&quot;&gt; &lt;code&gt;table&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5f4d4c7789cbf6727187aa434640210ed81d6661" translate="yes" xml:space="preserve">
          <source>This library provides the functionality of the debug interface (&lt;a href=&quot;#4.7&quot;&gt;&amp;sect;4.7&lt;/a&gt;) to Lua programs. You should exert care when using this library. Several of its functions violate basic assumptions about Lua code (e.g., that variables local to a function cannot be accessed from outside; that userdata metatables cannot be changed by Lua code; that Lua programs do not crash) and therefore can compromise otherwise secure code. Moreover, some functions in this library may be slow.</source>
          <target state="translated">이 라이브러리는 Lua 프로그램에 디버그 인터페이스 ( &lt;a href=&quot;#4.7&quot;&gt;&amp;sect;4.7&lt;/a&gt; ) 기능을 제공합니다 . 이 라이브러리를 사용할 때는주의해야합니다. 일부 함수는 Lua 코드에 대한 기본 가정 (예 : 함수의 로컬 변수는 외부에서 액세스 할 수 없음, 사용자 데이터 메타 테이블은 Lua 코드로 변경할 수 없음, Lua 프로그램이 충돌하지 않음)을 위반하므로 보안 코드를 손상시킬 수 있습니다. 또한이 라이브러리의 일부 기능은 느릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d51d524a82a8aae4d9f2e0292c35c2b4f100e81" translate="yes" xml:space="preserve">
          <source>This library provides the functionality of the debug interface (&lt;a href=&quot;#4.9&quot;&gt;&amp;sect;4.9&lt;/a&gt;) to Lua programs. You should exert care when using this library. Several of its functions violate basic assumptions about Lua code (e.g., that variables local to a function cannot be accessed from outside; that userdata metatables cannot be changed by Lua code; that Lua programs do not crash) and therefore can compromise otherwise secure code. Moreover, some functions in this library may be slow.</source>
          <target state="translated">이 라이브러리는 디버그 인터페이스의 기능을 제공합니다 (&lt;a href=&quot;#4.9&quot;&gt;&lt;/a&gt; Lua 프로그램에 &amp;sect;4.9 ) . 이 라이브러리를 사용할 때는주의를 기울여야합니다. 그 기능 중 일부는 Lua 코드에 대한 기본 가정을 위반합니다 (예 : 함수의 로컬 변수에 외부에서 액세스 할 수 없음, 사용자 데이터 메타 테이블을 Lua 코드로 변경할 수 없음, Lua 프로그램이 충돌하지 않음). 그렇지 않으면 보안 코드를 손상시킬 수 있습니다. 또한이 라이브러리의 일부 기능이 느려질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa99211cd2ffc6b2b1567c3fa58975b02bdbb57d" translate="yes" xml:space="preserve">
          <source>This macro is defined as follows:</source>
          <target state="translated">이 매크로는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="c062139aee69e54bd4a269563eddaa0f4e8798af" translate="yes" xml:space="preserve">
          <source>This macro is equivalent to &lt;a href=&quot;#lua_pushstring&quot;&gt;&lt;code&gt;lua_pushstring&lt;/code&gt;&lt;/a&gt;, but should be used only when &lt;code&gt;s&lt;/code&gt; is a literal string.</source>
          <target state="translated">이 매크로는 &lt;a href=&quot;#lua_pushstring&quot;&gt; &lt;code&gt;lua_pushstring&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 다음 과 같은 경우에만 사용해야합니다. &lt;code&gt;s&lt;/code&gt; 가 리터럴 문자열 인 합니다.</target>
        </trans-unit>
        <trans-unit id="8a5828258eda09312844222f71451e9b5df31690" translate="yes" xml:space="preserve">
          <source>This macro is equivalent to &lt;a href=&quot;#lua_pushstring&quot;&gt;&lt;code&gt;lua_pushstring&lt;/code&gt;&lt;/a&gt;, but should be used only when &lt;code&gt;s&lt;/code&gt; is a literal string. (Lua may optimize this case.)</source>
          <target state="translated">이 매크로는 &lt;a href=&quot;#lua_pushstring&quot;&gt; &lt;code&gt;lua_pushstring&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 &lt;code&gt;s&lt;/code&gt; 가 리터럴 문자열 인 경우에만 사용해야 합니다. (Lua는이 경우를 최적화 할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="73fca2eb54a811850b7ad4e17b0d35bfe7cf0032" translate="yes" xml:space="preserve">
          <source>This macro may evaluate its arguments more than once.</source>
          <target state="translated">이 매크로는 인수를 두 번 이상 평가할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05f26abbbd5d35b2d22d1c051a71569b0f900ee1" translate="yes" xml:space="preserve">
          <source>This section describes the C API for Lua, that is, the set of C functions available to the host program to communicate with Lua. All API functions and related types and constants are declared in the header file &lt;a id=&quot;pdf-lua.h&quot;&gt;&lt;code&gt;lua.h&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 섹션에서는 Lua 용 C API, 즉 호스트 프로그램이 Lua와 통신하는 데 사용할 수있는 C 함수 세트에 대해 설명합니다. 모든 API 함수와 관련 유형 및 상수는 헤더 파일 &lt;a id=&quot;pdf-lua.h&quot;&gt; &lt;code&gt;lua.h&lt;/code&gt; 에&lt;/a&gt; 선언됩니다 .</target>
        </trans-unit>
        <trans-unit id="f58c3cfe49431540420c4f54cf654f80f9192fd6" translate="yes" xml:space="preserve">
          <source>This section describes the basic concepts of the language.</source>
          <target state="translated">이 섹션에서는 언어의 기본 개념에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="8fa659ee1a4beeab1fc33f883314eeb2cadc844d" translate="yes" xml:space="preserve">
          <source>This section describes the lexis, the syntax, and the semantics of Lua. In other words, this section describes which tokens are valid, how they can be combined, and what their combinations mean.</source>
          <target state="translated">이 섹션에서는 Lua의 어휘, 구문 및 의미를 설명합니다. 다시 말해서,이 섹션은 어떤 토큰이 유효한지, 어떻게 결합 할 수 있는지, 그리고 그 조합의 의미를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="db29de528ad1c90a96a681f72e450fef6b674bc0" translate="yes" xml:space="preserve">
          <source>This specifier does not support modifiers (flags, width, length).</source>
          <target state="translated">이 지정자는 수정 자 (플래그, 너비, 길이)를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="278be3240fe4a7ea3d08f92baa83623d2ac8fe27" translate="yes" xml:space="preserve">
          <source>This userdata must start with the structure &lt;code&gt;luaL_Stream&lt;/code&gt;; it can contain other data after this initial structure. Field &lt;code&gt;f&lt;/code&gt; points to the corresponding C stream (or it can be &lt;code&gt;NULL&lt;/code&gt; to indicate an incompletely created handle). Field &lt;code&gt;closef&lt;/code&gt; points to a Lua function that will be called to close the stream when the handle is closed or collected; this function receives the file handle as its sole argument and must return either &lt;b&gt;true&lt;/b&gt; (in case of success) or &lt;b&gt;nil&lt;/b&gt; plus an error message (in case of error). Once Lua calls this field, it changes the field value to &lt;code&gt;NULL&lt;/code&gt; to signal that the handle is closed.</source>
          <target state="translated">이 사용자 데이터는 &lt;code&gt;luaL_Stream&lt;/code&gt; 구조로 시작해야합니다 . 이 초기 구조 이후에 다른 데이터를 포함 할 수 있습니다. 필드 &lt;code&gt;f&lt;/code&gt; 는 해당 C 스트림을 가리 킵니다 (또는 불완전하게 생성 된 핸들을 나타 내기 위해 &lt;code&gt;NULL&lt;/code&gt; 일 수 있음). Field &lt;code&gt;closef&lt;/code&gt; 는 핸들이 닫히거나 수집 될 때 스트림을 닫도록 호출되는 Lua 함수를 가리 킵니다. 이 함수는 파일 핸들을 유일한 인수로 받고 &lt;b&gt;true&lt;/b&gt; (성공의 경우) 또는 &lt;b&gt;nil&lt;/b&gt; 과 오류 메시지 (오류의 경우)를 리턴해야합니다 . Lua가이 필드를 호출 하면 핸들이 닫 &lt;code&gt;NULL&lt;/code&gt; 을 알리기 위해 필드 값을 NULL 로 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="e34f3769ad0807b3d6dc807de51658a5229c2a2c" translate="yes" xml:space="preserve">
          <source>This userdata must start with the structure &lt;code&gt;luaL_Stream&lt;/code&gt;; it can contain other data after this initial structure. The field &lt;code&gt;f&lt;/code&gt; points to the corresponding C stream (or it can be &lt;code&gt;NULL&lt;/code&gt; to indicate an incompletely created handle). The field &lt;code&gt;closef&lt;/code&gt; points to a Lua function that will be called to close the stream when the handle is closed or collected; this function receives the file handle as its sole argument and must return either a true value, in case of success, or a false value plus an error message, in case of error. Once Lua calls this field, it changes the field value to &lt;code&gt;NULL&lt;/code&gt; to signal that the handle is closed.</source>
          <target state="translated">이 사용자 데이터는 &lt;code&gt;luaL_Stream&lt;/code&gt; 구조로 시작해야합니다 . 이 초기 구조 이후에 다른 데이터를 포함 할 수 있습니다. 필드 &lt;code&gt;f&lt;/code&gt; 는 해당 C 스트림을 가리 킵니다 (또는 불완전하게 생성 된 핸들을 나타 내기 위해 &lt;code&gt;NULL&lt;/code&gt; 일 수 있음). &lt;code&gt;closef&lt;/code&gt; 필드 는 핸들이 닫히거나 수집 될 때 스트림을 닫기 위해 호출되는 Lua 함수를 가리 킵니다. 이 함수는 파일 핸들을 유일한 인수로 받고 성공의 경우 참 값을 반환하거나 오류의 경우 거짓 값과 오류 메시지를 반환해야합니다. Lua가이 필드를 호출하면 필드 값을 &lt;code&gt;NULL&lt;/code&gt; 로 변경 하여 핸들이 닫 혔음 을 알립니다.</target>
        </trans-unit>
        <trans-unit id="a38b5444cc9ef2204e61edb4d9f6307dc07f0ac4" translate="yes" xml:space="preserve">
          <source>This variable is only a reference to the real table; assignments to this variable do not change the table used by &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 변수는 실제 테이블에 대한 참조 일뿐입니다. 이 변수에 대한 지정은 &lt;a href=&quot;#pdf-require&quot;&gt; &lt;code&gt;require&lt;/code&gt; 에서&lt;/a&gt; 사용하는 테이블을 변경하지 않습니다. .</target>
        </trans-unit>
        <trans-unit id="53329857ea4576424bb761eab97ba4d7a438b162" translate="yes" xml:space="preserve">
          <source>Threads are subject to garbage collection, like any Lua object.</source>
          <target state="translated">스레드는 Lua 객체와 마찬가지로 가비지 수집의 대상이됩니다.</target>
        </trans-unit>
        <trans-unit id="fd5b59d880561eb52ba3ed52be79a6fc246200cf" translate="yes" xml:space="preserve">
          <source>To allow possible side-effects, function calls can be executed as statements:</source>
          <target state="translated">가능한 부작용을 허용하기 위해 함수 호출을 명령문으로 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5d4f137bc9e715e9e20a727cc9650777e835e92" translate="yes" xml:space="preserve">
          <source>To allow the use of Lua as a script interpreter in Unix systems, Lua skips the first line of a file chunk if it starts with &lt;code&gt;#&lt;/code&gt;. Therefore, Lua scripts can be made into executable programs by using &lt;code&gt;chmod +x&lt;/code&gt; and the &lt;code&gt;#!&lt;/code&gt; form, as in</source>
          <target state="translated">Unix 시스템에서 스크립트 인터프리터로 Lua를 사용할 수 있도록 Lua는 &lt;code&gt;#&lt;/code&gt; 로 시작하는 파일 청크의 첫 번째 줄을 건너 뜁니다 . 따라서 Lua 스크립트는 &lt;code&gt;chmod +x&lt;/code&gt; 및 &lt;code&gt;#!&lt;/code&gt; 를 사용하여 실행 가능한 프로그램으로 만들 수 있습니다 . 에서와 같이 양식</target>
        </trans-unit>
        <trans-unit id="888be864c9c88102be3a61e9065fc124fb157083" translate="yes" xml:space="preserve">
          <source>To allow the use of Lua as a script interpreter in Unix systems, the standalone interpreter skips the first line of a chunk if it starts with &lt;code&gt;#&lt;/code&gt;. Therefore, Lua scripts can be made into executable programs by using &lt;code&gt;chmod +x&lt;/code&gt; and the &lt;code&gt;#!&lt;/code&gt; form, as in</source>
          <target state="translated">Unix 시스템에서 Lua를 스크립트 인터프리터로 사용할 수 있도록 독립형 인터프리터는 청크로가 첫 번째 행이 &lt;code&gt;#&lt;/code&gt; 으로 시작하면이를 무시합니다 . 따라서 &lt;code&gt;chmod +x&lt;/code&gt; 및 &lt;code&gt;#!&lt;/code&gt; 를 사용하여 Lua 스크립트를 실행 가능 프로그램으로 만들 수 있습니다 . 에서와 같이 형태</target>
        </trans-unit>
        <trans-unit id="1e9c9099d2aea779a3a3f78d58160c9b66011127" translate="yes" xml:space="preserve">
          <source>To avoid this kind of problem, Lua raises an error whenever it tries to yield across an API call, except for three functions: &lt;a href=&quot;#lua_yieldk&quot;&gt;&lt;code&gt;lua_yieldk&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#lua_callk&quot;&gt;&lt;code&gt;lua_callk&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#lua_pcallk&quot;&gt;&lt;code&gt;lua_pcallk&lt;/code&gt;&lt;/a&gt;. All those functions receive a &lt;em&gt;continuation function&lt;/em&gt; (as a parameter named &lt;code&gt;k&lt;/code&gt;) to continue execution after a yield.</source>
          <target state="translated">: 이러한 문제를 방지하기 위해, 루아는 세 가지 기능을 제외하고, API 호출을 통해 산출하려 할 때마다 오류가 발생합니다 &lt;a href=&quot;#lua_yieldk&quot;&gt; &lt;code&gt;lua_yieldk&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#lua_callk&quot;&gt; &lt;code&gt;lua_callk&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#lua_pcallk&quot;&gt; &lt;code&gt;lua_pcallk&lt;/code&gt; 을&lt;/a&gt; . 이러한 모든 함수는 &lt;em&gt;연속 함수&lt;/em&gt; ( &lt;code&gt;k&lt;/code&gt; 라는 매개 변수 )를 수신 하여 수율 후에 실행을 계속합니다.</target>
        </trans-unit>
        <trans-unit id="5bb0e844a26e80a97eddacec1b0d3209d0d96606" translate="yes" xml:space="preserve">
          <source>To call a function you must use the following protocol: first, the function to be called is pushed onto the stack; then, the arguments to the function are pushed in direct order; that is, the first argument is pushed first. Finally you call &lt;a href=&quot;#lua_call&quot;&gt;&lt;code&gt;lua_call&lt;/code&gt;&lt;/a&gt;; &lt;code&gt;nargs&lt;/code&gt; is the number of arguments that you pushed onto the stack. All arguments and the function value are popped from the stack when the function is called. The function results are pushed onto the stack when the function returns. The number of results is adjusted to &lt;code&gt;nresults&lt;/code&gt;, unless &lt;code&gt;nresults&lt;/code&gt; is &lt;a id=&quot;pdf-LUA_MULTRET&quot;&gt;&lt;code&gt;LUA_MULTRET&lt;/code&gt;&lt;/a&gt;. In this case, all results from the function are pushed; Lua takes care that the returned values fit into the stack space, but it does not ensure any extra space in the stack. The function results are pushed onto the stack in direct order (the first result is pushed first), so that after the call the last result is on the top of the stack.</source>
          <target state="translated">함수를 호출하려면 다음 프로토콜을 사용해야합니다. 먼저 호출 할 함수가 스택으로 푸시됩니다. 그런 다음 함수에 대한 인수는 순서대로 푸시됩니다. 즉, 첫 번째 인수가 먼저 푸시됩니다. 마지막으로 &lt;a href=&quot;#lua_call&quot;&gt; &lt;code&gt;lua_call&lt;/code&gt; &lt;/a&gt; 을 호출 합니다 . &lt;code&gt;nargs&lt;/code&gt; 는 스택에 푸시 한 인수의 수입니다. 함수가 호출되면 모든 인수와 함수 값이 스택에서 팝됩니다. 함수 결과는 함수가 반환 될 때 스택으로 푸시됩니다. 결과의 수를 조정 &lt;code&gt;nresults&lt;/code&gt; 하지 않는 한, &lt;code&gt;nresults&lt;/code&gt; 가 있다 &lt;a id=&quot;pdf-LUA_MULTRET&quot;&gt; &lt;code&gt;LUA_MULTRET&lt;/code&gt; 가&lt;/a&gt;. 이 경우 함수의 모든 결과가 푸시됩니다. Lua는 반환 된 값이 스택 공간에 맞도록주의하지만 스택에 추가 공간을 보장하지는 않습니다. 함수 결과는 직접 순서대로 스택에 푸시되며 (첫 번째 결과가 먼저 푸시 됨) 호출 후 마지막 결과가 스택의 맨 위에 오게됩니다.</target>
        </trans-unit>
        <trans-unit id="6f927865cf7be60df11e5707f3fba807a308ae47" translate="yes" xml:space="preserve">
          <source>To catch errors in Lua, you can do a &lt;em&gt;protected call&lt;/em&gt;, using &lt;a href=&quot;#pdf-pcall&quot;&gt;&lt;code&gt;pcall&lt;/code&gt;&lt;/a&gt; (or &lt;a href=&quot;#pdf-xpcall&quot;&gt;&lt;code&gt;xpcall&lt;/code&gt;&lt;/a&gt;). The function &lt;a href=&quot;#pdf-pcall&quot;&gt;&lt;code&gt;pcall&lt;/code&gt;&lt;/a&gt; calls a given function in &lt;em&gt;protected mode&lt;/em&gt;. Any error while running the function stops its execution, and control returns immediately to &lt;code&gt;pcall&lt;/code&gt;, which returns a status code.</source>
          <target state="translated">Lua에서 오류를 포착하려면 &lt;a href=&quot;#pdf-pcall&quot;&gt; &lt;code&gt;pcall&lt;/code&gt; &lt;/a&gt; (또는 &lt;a href=&quot;#pdf-xpcall&quot;&gt; &lt;code&gt;xpcall&lt;/code&gt; &lt;/a&gt; )을 사용하여 &lt;em&gt;보호 된 호출을&lt;/em&gt; 수행 할 수 있습니다 . 함수 &lt;a href=&quot;#pdf-pcall&quot;&gt; &lt;code&gt;pcall&lt;/code&gt; &lt;/a&gt; 주어진 함수를 호출 &lt;em&gt;보호 모드를&lt;/em&gt; . 함수를 실행하는 동안 오류가 발생하면 실행이 중지되고 제어가 즉시 &lt;code&gt;pcall&lt;/code&gt; 로 반환되어 상태 코드를 반환합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0ea99929cea20ed156e3c1b46c0e6d4b1e4d677a" translate="yes" xml:space="preserve">
          <source>To change the metatable of other types from Lua code, you must use the debug library (&lt;a href=&quot;#6.10&quot;&gt;&amp;sect;6.10&lt;/a&gt;).</source>
          <target state="translated">Lua 코드에서 다른 유형의 메타 테이블을 변경하려면 디버그 라이브러리 ( &lt;a href=&quot;#6.10&quot;&gt;&amp;sect;6.10&lt;/a&gt; )를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6417128dbbbaad3ecee352f08e4fffebce841718" translate="yes" xml:space="preserve">
          <source>To do a call you must use the following protocol: first, the function to be called is pushed onto the stack; then, the arguments to the call are pushed in direct order; that is, the first argument is pushed first. Finally you call &lt;a href=&quot;#lua_call&quot;&gt;&lt;code&gt;lua_call&lt;/code&gt;&lt;/a&gt;; &lt;code&gt;nargs&lt;/code&gt; is the number of arguments that you pushed onto the stack. When the function returns, all arguments and the function value are popped and the call results are pushed onto the stack. The number of results is adjusted to &lt;code&gt;nresults&lt;/code&gt;, unless &lt;code&gt;nresults&lt;/code&gt; is &lt;a id=&quot;pdf-LUA_MULTRET&quot;&gt;&lt;code&gt;LUA_MULTRET&lt;/code&gt;&lt;/a&gt;. In this case, all results from the function are pushed; Lua takes care that the returned values fit into the stack space, but it does not ensure any extra space in the stack. The function results are pushed onto the stack in direct order (the first result is pushed first), so that after the call the last result is on the top of the stack.</source>
          <target state="translated">호출을 수행하려면 다음 프로토콜을 사용해야합니다. 먼저 호출 할 함수가 스택에 푸시됩니다. 그런 다음 호출에 대한 인수가 직접 순서대로 푸시됩니다. 즉, 첫 번째 인수가 먼저 푸시됩니다. 마지막으로 &lt;a href=&quot;#lua_call&quot;&gt; &lt;code&gt;lua_call&lt;/code&gt; &lt;/a&gt; 을 호출 합니다 . &lt;code&gt;nargs&lt;/code&gt; 는 스택에 푸시 한 인수의 수입니다. 함수가 반환되면 모든 인수와 함수 값이 팝되고 호출 결과가 스택에 푸시됩니다. 결과의 수를 조정 &lt;code&gt;nresults&lt;/code&gt; 하지 않는 한, &lt;code&gt;nresults&lt;/code&gt; 가 있다 &lt;a id=&quot;pdf-LUA_MULTRET&quot;&gt; &lt;code&gt;LUA_MULTRET&lt;/code&gt; 가&lt;/a&gt;. 이 경우 함수의 모든 결과가 푸시됩니다. Lua는 반환 된 값이 스택 공간에 맞는지 확인하지만 스택에 추가 공간을 보장하지는 않습니다. 함수 결과는 직접 순서대로 스택에 푸시되므로 (첫 번째 결과가 먼저 푸시 됨) 호출 후 마지막 결과가 스택의 맨 위에 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef1fdaa7f1c7b918f16975f1ca7b0d514c6f0f3a" translate="yes" xml:space="preserve">
          <source>To ensure a required level of randomness to the initial state (or contrarily, to have a deterministic sequence, for instance when debugging a program), you should call &lt;a href=&quot;#pdf-math.randomseed&quot;&gt;&lt;code&gt;math.randomseed&lt;/code&gt;&lt;/a&gt; with explicit arguments.</source>
          <target state="translated">초기 상태에 필요한 임의 수준을 보장하려면 (또는 반대로 프로그램을 디버깅 할 때와 같이 결정적 시퀀스를 갖기 위해) 명시 적 인수를 사용하여 &lt;a href=&quot;#pdf-math.randomseed&quot;&gt; &lt;code&gt;math.randomseed&lt;/code&gt; &lt;/a&gt; 를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2e1e6304705c324bc934187373072b763f1a1066" translate="yes" xml:space="preserve">
          <source>To find a loader, &lt;code&gt;require&lt;/code&gt; is guided by the &lt;a href=&quot;#pdf-package.searchers&quot;&gt;&lt;code&gt;package.searchers&lt;/code&gt;&lt;/a&gt; sequence. By changing this sequence, we can change how &lt;code&gt;require&lt;/code&gt; looks for a module. The following explanation is based on the default configuration for &lt;a href=&quot;#pdf-package.searchers&quot;&gt;&lt;code&gt;package.searchers&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">로더를 찾으려면 &lt;a href=&quot;#pdf-package.searchers&quot;&gt; &lt;code&gt;package.searchers&lt;/code&gt; &lt;/a&gt; 순서에 따라 &lt;code&gt;require&lt;/code&gt; 가 안내됩니다 . 이 순서를 변경하여 &lt;code&gt;require&lt;/code&gt; 모듈을 찾는 방법을 변경할 수 있습니다 . 다음 설명은 &lt;a href=&quot;#pdf-package.searchers&quot;&gt; &lt;code&gt;package.searchers&lt;/code&gt; &lt;/a&gt; 의 기본 구성을 기반으로합니다 .</target>
        </trans-unit>
        <trans-unit id="5e712bd9f9ff5cb85660101fcd07ff33cf506329" translate="yes" xml:space="preserve">
          <source>To find a loader, &lt;code&gt;require&lt;/code&gt; is guided by the table &lt;a href=&quot;#pdf-package.searchers&quot;&gt;&lt;code&gt;package.searchers&lt;/code&gt;&lt;/a&gt;. Each item in this table is a search function, that searches for the module in a particular way. By changing this table, we can change how &lt;code&gt;require&lt;/code&gt; looks for a module. The following explanation is based on the default configuration for &lt;a href=&quot;#pdf-package.searchers&quot;&gt;&lt;code&gt;package.searchers&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">로더를 찾기 위해 &lt;code&gt;require&lt;/code&gt; 는 &lt;a href=&quot;#pdf-package.searchers&quot;&gt; &lt;code&gt;package.searchers&lt;/code&gt; &lt;/a&gt; 테이블에서 안내 합니다 . 이 테이블의 각 항목은 특정 방식으로 모듈을 검색하는 검색 기능입니다. 이 테이블을 변경하여 &lt;code&gt;require&lt;/code&gt; 에서 모듈을 찾는 방법을 변경할 수 있습니다 . 다음 설명은 &lt;a href=&quot;#pdf-package.searchers&quot;&gt; &lt;code&gt;package.searchers&lt;/code&gt; &lt;/a&gt; 의 기본 구성을 기반으로합니다 .</target>
        </trans-unit>
        <trans-unit id="d328425732a8a8cf219c051476f3d38be1088896" translate="yes" xml:space="preserve">
          <source>To get information about a function invocation, the parameter &lt;code&gt;ar&lt;/code&gt; must be a valid activation record that was filled by a previous call to &lt;a href=&quot;#lua_getstack&quot;&gt;&lt;code&gt;lua_getstack&lt;/code&gt;&lt;/a&gt; or given as argument to a hook (see &lt;a href=&quot;#lua_Hook&quot;&gt;&lt;code&gt;lua_Hook&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">함수 호출에 대한 정보를 얻으려면 매개 변수 &lt;code&gt;ar&lt;/code&gt; 는 &lt;a href=&quot;#lua_getstack&quot;&gt; &lt;code&gt;lua_getstack&lt;/code&gt; &lt;/a&gt; 에 대한 이전 호출로 채워지 거나 후크에 대한 인수로 제공된 유효한 활성화 레코드 여야합니다 ( &lt;a href=&quot;#lua_Hook&quot;&gt; &lt;code&gt;lua_Hook&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="259bf849c0380d37169ac9c2c5ed68eef86ed762" translate="yes" xml:space="preserve">
          <source>To get information about a function you push it onto the stack and start the &lt;code&gt;what&lt;/code&gt; string with the character '&lt;code&gt;&amp;gt;&lt;/code&gt;'. (In that case, &lt;code&gt;lua_getinfo&lt;/code&gt; pops the function from the top of the stack.) For instance, to know in which line a function &lt;code&gt;f&lt;/code&gt; was defined, you can write the following code:</source>
          <target state="translated">함수에 대한 정보를 얻으려면 함수를 스택으로 푸시 하고 문자 ' &lt;code&gt;&amp;gt;&lt;/code&gt; '로 &lt;code&gt;what&lt;/code&gt; 문자열을 시작하십시오 . (이 경우 &lt;code&gt;lua_getinfo&lt;/code&gt; 는 스택 맨 위에서 함수를 팝합니다.) 예를 들어 함수 &lt;code&gt;f&lt;/code&gt; 가 정의 된 행을 알기 위해 다음 코드를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bbdfec85d3ce9d473ff7e0ea2279d69ff617c711" translate="yes" xml:space="preserve">
          <source>To get information about a function, you push it onto the stack and start the &lt;code&gt;what&lt;/code&gt; string with the character '&lt;code&gt;&amp;gt;&lt;/code&gt;'. (In that case, &lt;code&gt;lua_getinfo&lt;/code&gt; pops the function from the top of the stack.) For instance, to know in which line a function &lt;code&gt;f&lt;/code&gt; was defined, you can write the following code:</source>
          <target state="translated">함수에 대한 정보를 얻으려면 스택에 푸시 하고 문자 ' &lt;code&gt;&amp;gt;&lt;/code&gt; '로 &lt;code&gt;what&lt;/code&gt; 문자열을 시작합니다 . (이 경우 &lt;code&gt;lua_getinfo&lt;/code&gt; 는 스택 맨 위에서 함수를 팝합니다.) 예를 들어, 함수 &lt;code&gt;f&lt;/code&gt; 가 정의 된 줄을 확인 하려면 다음 코드를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c87754131cf9f2c3e4c8c44baabf65a58d386a2" translate="yes" xml:space="preserve">
          <source>To have access to these libraries, the C host program should call the &lt;a href=&quot;#luaL_openlibs&quot;&gt;&lt;code&gt;luaL_openlibs&lt;/code&gt;&lt;/a&gt; function, which opens all standard libraries. Alternatively, the host program can open them individually by using &lt;a href=&quot;#luaL_requiref&quot;&gt;&lt;code&gt;luaL_requiref&lt;/code&gt;&lt;/a&gt; to call &lt;a id=&quot;pdf-luaopen_base&quot;&gt;&lt;code&gt;luaopen_base&lt;/code&gt;&lt;/a&gt; (for the basic library), &lt;a id=&quot;pdf-luaopen_package&quot;&gt;&lt;code&gt;luaopen_package&lt;/code&gt;&lt;/a&gt; (for the package library), &lt;a id=&quot;pdf-luaopen_coroutine&quot;&gt;&lt;code&gt;luaopen_coroutine&lt;/code&gt;&lt;/a&gt; (for the coroutine library), &lt;a id=&quot;pdf-luaopen_string&quot;&gt;&lt;code&gt;luaopen_string&lt;/code&gt;&lt;/a&gt; (for the string library), &lt;a id=&quot;pdf-luaopen_utf8&quot;&gt;&lt;code&gt;luaopen_utf8&lt;/code&gt;&lt;/a&gt; (for the UTF-8 library), &lt;a id=&quot;pdf-luaopen_table&quot;&gt;&lt;code&gt;luaopen_table&lt;/code&gt;&lt;/a&gt; (for the table library), &lt;a id=&quot;pdf-luaopen_math&quot;&gt;&lt;code&gt;luaopen_math&lt;/code&gt;&lt;/a&gt; (for the mathematical library), &lt;a id=&quot;pdf-luaopen_io&quot;&gt;&lt;code&gt;luaopen_io&lt;/code&gt;&lt;/a&gt; (for the I/O library), &lt;a id=&quot;pdf-luaopen_os&quot;&gt;&lt;code&gt;luaopen_os&lt;/code&gt;&lt;/a&gt; (for the operating system library), and &lt;a id=&quot;pdf-luaopen_debug&quot;&gt;&lt;code&gt;luaopen_debug&lt;/code&gt;&lt;/a&gt; (for the debug library). These functions are declared in &lt;a id=&quot;pdf-lualib.h&quot;&gt;&lt;code&gt;lualib.h&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이러한 라이브러리에 액세스하려면 C 호스트 프로그램 이 모든 표준 라이브러리를 여는 &lt;a href=&quot;#luaL_openlibs&quot;&gt; &lt;code&gt;luaL_openlibs&lt;/code&gt; &lt;/a&gt; 함수를 호출해야합니다 . 또한, 호스트 프로그램을 사용하여 개별적으로 열 수 있습니다 &lt;a href=&quot;#luaL_requiref&quot;&gt; &lt;code&gt;luaL_requiref&lt;/code&gt; 를&lt;/a&gt; 호출 &lt;a id=&quot;pdf-luaopen_base&quot;&gt; &lt;code&gt;luaopen_base&lt;/code&gt; &lt;/a&gt; (기본 라이브러리), &lt;a id=&quot;pdf-luaopen_package&quot;&gt; &lt;code&gt;luaopen_package&lt;/code&gt; &lt;/a&gt; (패키지 라이브러리), &lt;a id=&quot;pdf-luaopen_coroutine&quot;&gt; &lt;code&gt;luaopen_coroutine&lt;/code&gt; &lt;/a&gt; , (코 루틴 라이브러리)을 &lt;a id=&quot;pdf-luaopen_string&quot;&gt; &lt;code&gt;luaopen_string&lt;/code&gt; &lt;/a&gt; (문자열 라이브러리) &lt;a id=&quot;pdf-luaopen_utf8&quot;&gt; &lt;code&gt;luaopen_utf8&lt;/code&gt; 을&lt;/a&gt; 위해 ( UTF-8 라이브러리), &lt;a id=&quot;pdf-luaopen_table&quot;&gt; &lt;code&gt;luaopen_table&lt;/code&gt; &lt;/a&gt; (테이블 라이브러리 용), &lt;a id=&quot;pdf-luaopen_math&quot;&gt; &lt;code&gt;luaopen_math&lt;/code&gt; &lt;/a&gt; (수학적 라이브러리 용), &lt;a id=&quot;pdf-luaopen_io&quot;&gt; &lt;code&gt;luaopen_io&lt;/code&gt; &lt;/a&gt; (I / O 라이브러리 용), &lt;a id=&quot;pdf-luaopen_os&quot;&gt; &lt;code&gt;luaopen_os&lt;/code&gt; &lt;/a&gt;(운영 체제 라이브러리 용) 및 &lt;a id=&quot;pdf-luaopen_debug&quot;&gt; &lt;code&gt;luaopen_debug&lt;/code&gt; &lt;/a&gt; (디버그 라이브러리 용). 이러한 함수는 &lt;a id=&quot;pdf-lualib.h&quot;&gt; &lt;code&gt;lualib.h&lt;/code&gt; &lt;/a&gt; 에 선언되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4f65df24a4302e99c5805820ed2c9da17dcc1b4e" translate="yes" xml:space="preserve">
          <source>To have access to these libraries, the C host program should call the &lt;a href=&quot;#luaL_openlibs&quot;&gt;&lt;code&gt;luaL_openlibs&lt;/code&gt;&lt;/a&gt; function, which opens all standard libraries. Alternatively, the host program can open them individually by using &lt;a href=&quot;#luaL_requiref&quot;&gt;&lt;code&gt;luaL_requiref&lt;/code&gt;&lt;/a&gt; to call &lt;a id=&quot;pdf-luaopen_base&quot;&gt;&lt;code&gt;luaopen_base&lt;/code&gt;&lt;/a&gt; (for the basic library), &lt;a id=&quot;pdf-luaopen_package&quot;&gt;&lt;code&gt;luaopen_package&lt;/code&gt;&lt;/a&gt; (for the package library), &lt;a id=&quot;pdf-luaopen_coroutine&quot;&gt;&lt;code&gt;luaopen_coroutine&lt;/code&gt;&lt;/a&gt; (for the coroutine library), &lt;a id=&quot;pdf-luaopen_string&quot;&gt;&lt;code&gt;luaopen_string&lt;/code&gt;&lt;/a&gt; (for the string library), &lt;a id=&quot;pdf-luaopen_utf8&quot;&gt;&lt;code&gt;luaopen_utf8&lt;/code&gt;&lt;/a&gt; (for the UTF8 library), &lt;a id=&quot;pdf-luaopen_table&quot;&gt;&lt;code&gt;luaopen_table&lt;/code&gt;&lt;/a&gt; (for the table library), &lt;a id=&quot;pdf-luaopen_math&quot;&gt;&lt;code&gt;luaopen_math&lt;/code&gt;&lt;/a&gt; (for the mathematical library), &lt;a id=&quot;pdf-luaopen_io&quot;&gt;&lt;code&gt;luaopen_io&lt;/code&gt;&lt;/a&gt; (for the I/O library), &lt;a id=&quot;pdf-luaopen_os&quot;&gt;&lt;code&gt;luaopen_os&lt;/code&gt;&lt;/a&gt; (for the operating system library), and &lt;a id=&quot;pdf-luaopen_debug&quot;&gt;&lt;code&gt;luaopen_debug&lt;/code&gt;&lt;/a&gt; (for the debug library). These functions are declared in &lt;a id=&quot;pdf-lualib.h&quot;&gt;&lt;code&gt;lualib.h&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이러한 라이브러리에 액세스하려면 C 호스트 프로그램이 &lt;a href=&quot;#luaL_openlibs&quot;&gt; &lt;code&gt;luaL_openlibs&lt;/code&gt; &lt;/a&gt; 함수를 호출해야합니다.이 함수는 모든 표준 라이브러리를 엽니 다. 또한, 호스트 프로그램을 사용하여 개별적으로 열 수 있습니다 &lt;a href=&quot;#luaL_requiref&quot;&gt; &lt;code&gt;luaL_requiref&lt;/code&gt; 를&lt;/a&gt; 호출 &lt;a id=&quot;pdf-luaopen_base&quot;&gt; &lt;code&gt;luaopen_base&lt;/code&gt; &lt;/a&gt; (기본 라이브러리), &lt;a id=&quot;pdf-luaopen_package&quot;&gt; &lt;code&gt;luaopen_package&lt;/code&gt; &lt;/a&gt; (패키지 라이브러리), &lt;a id=&quot;pdf-luaopen_coroutine&quot;&gt; &lt;code&gt;luaopen_coroutine&lt;/code&gt; &lt;/a&gt; , (코 루틴 라이브러리)을 &lt;a id=&quot;pdf-luaopen_string&quot;&gt; &lt;code&gt;luaopen_string&lt;/code&gt; &lt;/a&gt; (문자열 라이브러리) &lt;a id=&quot;pdf-luaopen_utf8&quot;&gt; &lt;code&gt;luaopen_utf8&lt;/code&gt; 을&lt;/a&gt; 위해 ( UTF8 라이브러리), &lt;a id=&quot;pdf-luaopen_table&quot;&gt; &lt;code&gt;luaopen_table&lt;/code&gt; &lt;/a&gt; (테이블 라이브러리), &lt;a id=&quot;pdf-luaopen_math&quot;&gt; &lt;code&gt;luaopen_math&lt;/code&gt; &lt;/a&gt; (수학 라이브러리), &lt;a id=&quot;pdf-luaopen_io&quot;&gt; &lt;code&gt;luaopen_io&lt;/code&gt; &lt;/a&gt; (I / O 라이브러리),&lt;a id=&quot;pdf-luaopen_os&quot;&gt; &lt;code&gt;luaopen_os&lt;/code&gt; &lt;/a&gt;(운영 체제 라이브러리의 경우) 및 &lt;a id=&quot;pdf-luaopen_debug&quot;&gt; &lt;code&gt;luaopen_debug&lt;/code&gt; &lt;/a&gt; (디버그 라이브러리의 경우). 이 함수들은 &lt;a id=&quot;pdf-lualib.h&quot;&gt; &lt;code&gt;lualib.h&lt;/code&gt; &lt;/a&gt; 에 선언되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f7497be5097473a583f39ec52ec425732f31d8c7" translate="yes" xml:space="preserve">
          <source>To resume a coroutine, you remove any results from the last &lt;a href=&quot;#lua_yield&quot;&gt;&lt;code&gt;lua_yield&lt;/code&gt;&lt;/a&gt;, put on its stack only the values to be passed as results from &lt;code&gt;yield&lt;/code&gt;, and then call &lt;a href=&quot;#lua_resume&quot;&gt;&lt;code&gt;lua_resume&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">코 루틴을 재개하려면 마지막 &lt;a href=&quot;#lua_yield&quot;&gt; &lt;code&gt;lua_yield&lt;/code&gt; &lt;/a&gt; 에서 결과를 제거 하고 &lt;code&gt;yield&lt;/code&gt; 에서 결과로 전달할 값만 스택에 놓고 &lt;a href=&quot;#lua_resume&quot;&gt; &lt;code&gt;lua_resume&lt;/code&gt; &lt;/a&gt; 을 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="9a9f2afcc694b7e6e7b0ece4b95a9b31851f835d" translate="yes" xml:space="preserve">
          <source>To resume a coroutine, you remove the &lt;code&gt;*nresults&lt;/code&gt; yielded values from its stack, push the values to be passed as results from &lt;code&gt;yield&lt;/code&gt;, and then call &lt;a href=&quot;#lua_resume&quot;&gt;&lt;code&gt;lua_resume&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">코 루틴을 재개하려면 스택에서 &lt;code&gt;*nresults&lt;/code&gt; yielded 값 을 제거하고 &lt;code&gt;yield&lt;/code&gt; 에서 결과로 전달할 값을 푸시 한 다음 &lt;a href=&quot;#lua_resume&quot;&gt; &lt;code&gt;lua_resume&lt;/code&gt; &lt;/a&gt; 을 호출 합니다 .</target>
        </trans-unit>
        <trans-unit id="f5749af8d5e7fed727ed35d15b38114e430080b8" translate="yes" xml:space="preserve">
          <source>To start a coroutine, you push onto the thread stack the main function plus any arguments; then you call &lt;a href=&quot;#lua_resume&quot;&gt;&lt;code&gt;lua_resume&lt;/code&gt;&lt;/a&gt;, with &lt;code&gt;nargs&lt;/code&gt; being the number of arguments. This call returns when the coroutine suspends or finishes its execution. When it returns, the stack contains all values passed to &lt;a href=&quot;#lua_yield&quot;&gt;&lt;code&gt;lua_yield&lt;/code&gt;&lt;/a&gt;, or all values returned by the body function. &lt;a href=&quot;#lua_resume&quot;&gt;&lt;code&gt;lua_resume&lt;/code&gt;&lt;/a&gt; returns &lt;a href=&quot;#pdf-LUA_YIELD&quot;&gt;&lt;code&gt;LUA_YIELD&lt;/code&gt;&lt;/a&gt; if the coroutine yields, &lt;a href=&quot;#pdf-LUA_OK&quot;&gt;&lt;code&gt;LUA_OK&lt;/code&gt;&lt;/a&gt; if the coroutine finishes its execution without errors, or an error code in case of errors (see &lt;a href=&quot;#lua_pcall&quot;&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">코 루틴을 시작하려면 스레드 스택에 main 함수와 인수를 넣습니다. 당신은 전화 &lt;a href=&quot;#lua_resume&quot;&gt; &lt;code&gt;lua_resume&lt;/code&gt; 을&lt;/a&gt; 함께 &lt;code&gt;nargs&lt;/code&gt; 는 인수의 수있는. 코 루틴이 일시 중단되거나 실행이 끝나면이 호출이 반환됩니다. 반환되면 스택에는 &lt;a href=&quot;#lua_yield&quot;&gt; &lt;code&gt;lua_yield&lt;/code&gt; 에&lt;/a&gt; 전달 된 모든 값 또는 body 함수가 반환 한 모든 값이 포함됩니다. &lt;a href=&quot;#lua_resume&quot;&gt; &lt;code&gt;lua_resume&lt;/code&gt; &lt;/a&gt; 반환 &lt;a href=&quot;#pdf-LUA_YIELD&quot;&gt; &lt;code&gt;LUA_YIELD&lt;/code&gt; 는&lt;/a&gt; 코 루틴 수율 경우 &lt;a href=&quot;#pdf-LUA_OK&quot;&gt; &lt;code&gt;LUA_OK&lt;/code&gt; 는&lt;/a&gt; 코 루틴은 에러없이 실행 혹은 오류 (볼의 경우의 에러 코드를 완료한다면 &lt;a href=&quot;#lua_pcall&quot;&gt; &lt;code&gt;lua_pcall&lt;/code&gt; 을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="76e8f3d7e170acca1d21ee8a1e8c4351dd451abd" translate="yes" xml:space="preserve">
          <source>To start a coroutine, you push the main function plus any arguments onto the empty stack of the thread. then you call &lt;a href=&quot;#lua_resume&quot;&gt;&lt;code&gt;lua_resume&lt;/code&gt;&lt;/a&gt;, with &lt;code&gt;nargs&lt;/code&gt; being the number of arguments. This call returns when the coroutine suspends or finishes its execution. When it returns, &lt;code&gt;*nresults&lt;/code&gt; is updated and the top of the stack contains the &lt;code&gt;*nresults&lt;/code&gt; values passed to &lt;a href=&quot;#lua_yield&quot;&gt;&lt;code&gt;lua_yield&lt;/code&gt;&lt;/a&gt; or returned by the body function. &lt;a href=&quot;#lua_resume&quot;&gt;&lt;code&gt;lua_resume&lt;/code&gt;&lt;/a&gt; returns &lt;a href=&quot;#pdf-LUA_YIELD&quot;&gt;&lt;code&gt;LUA_YIELD&lt;/code&gt;&lt;/a&gt; if the coroutine yields, &lt;a href=&quot;#pdf-LUA_OK&quot;&gt;&lt;code&gt;LUA_OK&lt;/code&gt;&lt;/a&gt; if the coroutine finishes its execution without errors, or an error code in case of errors (see &lt;a href=&quot;#4.4.1&quot;&gt;&amp;sect;4.4.1&lt;/a&gt;). In case of errors, the error object is on the top of the stack.</source>
          <target state="translated">코 루틴을 시작하려면 기본 함수와 모든 인수를 스레드의 빈 스택에 푸시합니다. 그런 다음 &lt;a href=&quot;#lua_resume&quot;&gt; &lt;code&gt;lua_resume&lt;/code&gt; &lt;/a&gt; 을 호출 하고 &lt;code&gt;nargs&lt;/code&gt; 는 인수의 수입니다. 이 호출은 코 루틴이 실행을 일시 중단하거나 완료 할 때 반환됩니다. 반환되면 &lt;code&gt;*nresults&lt;/code&gt; 가 업데이트되고 스택의 맨 위에 &lt;a href=&quot;#lua_yield&quot;&gt; &lt;code&gt;lua_yield&lt;/code&gt; 로&lt;/a&gt; 전달 되거나 body 함수에서 반환 된 &lt;code&gt;*nresults&lt;/code&gt; 값이 포함 됩니다. &lt;a href=&quot;#lua_resume&quot;&gt; &lt;code&gt;lua_resume&lt;/code&gt; &lt;/a&gt; 은 코 루틴이 양보하면 &lt;a href=&quot;#pdf-LUA_YIELD&quot;&gt; &lt;code&gt;LUA_YIELD&lt;/code&gt; &lt;/a&gt; 를, 코 루틴이 오류없이 실행을 완료하면 &lt;a href=&quot;#pdf-LUA_OK&quot;&gt; &lt;code&gt;LUA_OK&lt;/code&gt; 를&lt;/a&gt; , 오류가 발생하면 오류 코드를 &lt;a href=&quot;#4.4.1&quot;&gt;반환&lt;/a&gt; 합니다 ( &amp;sect;4.4.1 참조) .). 오류가 발생하면 오류 개체가 스택 맨 위에 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a41adffb8d584e7921f8216490fc0912471c5b7" translate="yes" xml:space="preserve">
          <source>To-be-closed Variables</source>
          <target state="translated">마감 될 변수</target>
        </trans-unit>
        <trans-unit id="2cdc79b068557cc0be76c7d7fde8401dd4f7da9e" translate="yes" xml:space="preserve">
          <source>Tries to convert a Lua float to a Lua integer; the float &lt;code&gt;n&lt;/code&gt; must have an integral value. If that value is within the range of Lua integers, it is converted to an integer and assigned to &lt;code&gt;*p&lt;/code&gt;. The macro results in a boolean indicating whether the conversion was successful. (Note that this range test can be tricky to do correctly without this macro, due to rounding.)</source>
          <target state="translated">Lua float를 Lua 정수로 변환하려고합니다. float &lt;code&gt;n&lt;/code&gt; 은 정수 값을 가져야합니다. 해당 값이 Lua 정수 범위 내에 있으면 정수로 변환되어 &lt;code&gt;*p&lt;/code&gt; 에 할당됩니다 . 매크로는 변환 성공 여부를 나타내는 부울을 생성합니다. (이 범위 테스트는 반올림으로 인해이 매크로없이 올바르게 수행하기가 까다로울 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="11a3a0ec973c2479f00cc8910cb72beb238ed2cd" translate="yes" xml:space="preserve">
          <source>Type for C functions.</source>
          <target state="translated">C 함수의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="bbac79126ad582b607fa7de417480b28246073cf" translate="yes" xml:space="preserve">
          <source>Type for a &lt;em&gt;string buffer&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;문자열 버퍼를&lt;/em&gt; 입력하십시오 .</target>
        </trans-unit>
        <trans-unit id="597df46ee98db369cefa88ec65178daff885f4c9" translate="yes" xml:space="preserve">
          <source>Type for arrays of functions to be registered by &lt;a href=&quot;#luaL_setfuncs&quot;&gt;&lt;code&gt;luaL_setfuncs&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;name&lt;/code&gt; is the function name and &lt;code&gt;func&lt;/code&gt; is a pointer to the function. Any array of &lt;a href=&quot;#luaL_Reg&quot;&gt;&lt;code&gt;luaL_Reg&lt;/code&gt;&lt;/a&gt; must end with a sentinel entry in which both &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;func&lt;/code&gt; are &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#luaL_setfuncs&quot;&gt; &lt;code&gt;luaL_setfuncs&lt;/code&gt; 에&lt;/a&gt; 의해 등록 될 함수 배열의 유형입니다 . &lt;code&gt;name&lt;/code&gt; 은 함수 이름이고 &lt;code&gt;func&lt;/code&gt; 는 함수 에 대한 포인터입니다. &lt;a href=&quot;#luaL_Reg&quot;&gt; &lt;code&gt;luaL_Reg&lt;/code&gt; &lt;/a&gt; 배열은 &lt;code&gt;name&lt;/code&gt; 및 &lt;code&gt;func&lt;/code&gt; 가 모두 &lt;code&gt;NULL&lt;/code&gt; 인 센티넬 항목 으로 끝나야 합니다 .</target>
        </trans-unit>
        <trans-unit id="7262eb2a012a409a0b60efe4a99f259fc3c90346" translate="yes" xml:space="preserve">
          <source>Type for continuation functions (see &lt;a href=&quot;#4.5&quot;&gt;&amp;sect;4.5&lt;/a&gt;).</source>
          <target state="translated">연속 기능 유형 ( &lt;a href=&quot;#4.5&quot;&gt;&amp;sect;4.5&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="97624a7d15b8942c923346eb9827dfe7da1b1df0" translate="yes" xml:space="preserve">
          <source>Type for continuation functions (see &lt;a href=&quot;#4.7&quot;&gt;&amp;sect;4.7&lt;/a&gt;).</source>
          <target state="translated">연속 기능 유형 ( &lt;a href=&quot;#4.7&quot;&gt;&amp;sect;4.7&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="24445b5aafedd0f5dd84a959ce49844260c89cd8" translate="yes" xml:space="preserve">
          <source>Type for debugging hook functions.</source>
          <target state="translated">후크 기능 디버깅을위한 유형입니다.</target>
        </trans-unit>
        <trans-unit id="bd045f19fb648f6e2a8a5ad73d4fd1e6a85d7f43" translate="yes" xml:space="preserve">
          <source>Typically this function is used only for hashing and debug information.</source>
          <target state="translated">일반적으로이 함수는 해싱 및 디버그 정보에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="82aace29da601638b56c7fcfaece961d82f801a3" translate="yes" xml:space="preserve">
          <source>Typically, the message handler is used to add more debug information to the error object, such as a stack traceback. Such information cannot be gathered after the return of &lt;a href=&quot;#lua_pcall&quot;&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt;, since by then the stack has unwound.</source>
          <target state="translated">일반적으로 메시지 핸들러는 스택 추적과 같은 오류 정보에 더 많은 디버그 정보를 추가하는 데 사용됩니다. &lt;a href=&quot;#lua_pcall&quot;&gt; &lt;code&gt;lua_pcall&lt;/code&gt; &lt;/a&gt; 이 반환 된 후에는 스택이 풀 렸기 때문에 이러한 정보를 수집 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c9efe5a42434457d2c52ab4c0d1415d4bcf07916" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated, all I/O functions return &lt;b&gt;fail&lt;/b&gt; on failure, plus an error message as a second result and a system-dependent error code as a third result, and some non-false value on success. On non-POSIX systems, the computation of the error message and error code in case of errors may be not thread safe, because they rely on the global C variable &lt;code&gt;errno&lt;/code&gt;.</source>
          <target state="translated">달리 명시하지 않는 한 모든 I / O 함수는 &lt;b&gt;실패&lt;/b&gt; 시 실패를 반환 하고 두 번째 결과로 오류 메시지를, 세 번째 결과로 시스템 종속 오류 코드를 반환 하고 성공하면 일부 비 거짓 값을 반환 합니다. 비 POSIX 시스템에서 오류 메시지 및 오류 코드 계산은 전역 C 변수 &lt;code&gt;errno&lt;/code&gt; 에 의존하기 때문에 스레드로부터 안전하지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="31727baa3a70e03cfa1528c55a7acf86c6c0a582" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated, all I/O functions return &lt;b&gt;nil&lt;/b&gt; on failure (plus an error message as a second result and a system-dependent error code as a third result) and some value different from &lt;b&gt;nil&lt;/b&gt; on success. On non-POSIX systems, the computation of the error message and error code in case of errors may be not thread safe, because they rely on the global C variable &lt;code&gt;errno&lt;/code&gt;.</source>
          <target state="translated">달리 명시하지 않는 한 모든 I / O 함수 는 실패시 &lt;b&gt;nil&lt;/b&gt; (두 번째 결과로 오류 메시지 및 세 번째 결과로 시스템 종속 오류 코드)과 성공시 &lt;b&gt;nil&lt;/b&gt; 과 다른 값을 반환 합니다. POSIX 이외의 시스템에서는 에러가 발생한 경우 에러 메시지와 에러 코드의 계산이 글로벌 C 변수 &lt;code&gt;errno&lt;/code&gt; 에 의존하기 때문에 스레드 안전하지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7b52e7d27a22d0d612f9608bbf1f1eccee941606" translate="yes" xml:space="preserve">
          <source>Unless stated otherwise, all functions that expect a byte position as a parameter assume that the given position is either the start of a byte sequence or one plus the length of the subject string. As in the string library, negative indices count from the end of the string.</source>
          <target state="translated">달리 언급되지 않는 한, 바이트 위치를 매개 변수로 예상하는 모든 함수는 주어진 위치가 바이트 시퀀스의 시작이거나 주제 문자열의 길이에 1을 더한 것으로 가정합니다. 문자열 라이브러리에서와 같이 음수 인덱스는 문자열 끝에서 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="4b92e3ee7788b339628f8fb046cb8cb890dfc063" translate="yes" xml:space="preserve">
          <source>Unless stated otherwise, any overflow when manipulating integer values &lt;em&gt;wrap around&lt;/em&gt;, according to the usual rules of two-complement arithmetic. (In other words, the actual result is the unique representable integer that is equal modulo &lt;em&gt;2&lt;sup&gt;n&lt;/sup&gt;&lt;/em&gt; to the mathematical result, where &lt;em&gt;n&lt;/em&gt; is the number of bits of the integer type.)</source>
          <target state="translated">달리 명시되지 않는 한, 정수 값을 조작 오버 플로우는 &lt;em&gt;랩 어라운드&lt;/em&gt; 두 보수 산술의 일반적인 규칙에 따라. (즉, 실제 결과는 수학적 결과와 모듈로 &lt;em&gt;2 &lt;sup&gt;n 인&lt;/sup&gt;&lt;/em&gt; 고유 한 표현 가능한 정수입니다 . 여기서 &lt;em&gt;n&lt;/em&gt; 은 정수 유형의 비트 수입니다.)</target>
        </trans-unit>
        <trans-unit id="59b21f366bd62c88e740589d6190f38930d6eeac" translate="yes" xml:space="preserve">
          <source>Unlike other push functions, this function checks for the stack space it needs, including the slot for its result.</source>
          <target state="translated">다른 푸시 기능과 달리이 기능은 결과에 대한 슬롯을 포함하여 필요한 스택 공간을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="2e42ec0a938ed392af0043f9b91ccccb6b8e5563" translate="yes" xml:space="preserve">
          <source>Upvalues have no particular order, as they are active through the whole function. They are numbered in an arbitrary order.</source>
          <target state="translated">업 밸류는 전체 기능을 통해 활성화되므로 특정 순서가 없습니다. 그것들은 임의의 순서로 번호가 매겨집니다.</target>
        </trans-unit>
        <trans-unit id="76f521b6a8d60e44bede4ff94d2d23d25dcfafa8" translate="yes" xml:space="preserve">
          <source>Userdata represent C values in Lua. A &lt;em&gt;light userdata&lt;/em&gt; represents a pointer, a &lt;code&gt;void*&lt;/code&gt;. It is a value (like a number): you do not create it, it has no individual metatable, and it is not collected (as it was never created). A light userdata is equal to &quot;any&quot; light userdata with the same C address.</source>
          <target state="translated">사용자 데이터는 Lua의 C 값을 나타냅니다. &lt;em&gt;광 유저 데이터는&lt;/em&gt; 포인터하는 대표 &lt;code&gt;void*&lt;/code&gt; . 값은 숫자와 같습니다. 값을 만들지 않고 개별 메타 테이블이 없으며 수집되지 않습니다 (생성되지 않았기 때문에). 일반 사용자 데이터는 동일한 C 주소를 가진 &quot;모든&quot;일반 사용자 데이터와 같습니다.</target>
        </trans-unit>
        <trans-unit id="e39e23cf8cc12b3b818ae1cbbd67ab727cb6080a" translate="yes" xml:space="preserve">
          <source>Usually, &lt;code&gt;error&lt;/code&gt; adds some information about the error position at the beginning of the message, if the message is a string. The &lt;code&gt;level&lt;/code&gt; argument specifies how to get the error position. With level 1 (the default), the error position is where the &lt;code&gt;error&lt;/code&gt; function was called. Level 2 points the error to where the function that called &lt;code&gt;error&lt;/code&gt; was called; and so on. Passing a level 0 avoids the addition of error position information to the message.</source>
          <target state="translated">보통, &lt;code&gt;error&lt;/code&gt; 는 메시지가 문자열 인 경우 메시지 시작시 오류 위치에 대한 정보를 추가합니다. &lt;code&gt;level&lt;/code&gt; 인수를 지정하는 방법 오류 위치를 얻을 수 있습니다. 레벨 1 (기본값)에서 오류 위치는 &lt;code&gt;error&lt;/code&gt; 함수가 호출 된 위치입니다 . 레벨 2는 오류를 호출 한 함수가 호출 된 위치를 &lt;code&gt;error&lt;/code&gt; 로 지정합니다. 등등. 수준 0을 전달하면 오류 위치 정보가 메시지에 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a5ec00a8e6ea1cb6546f41d42ab21ccdd067623e" translate="yes" xml:space="preserve">
          <source>Usually, this function does not return; when the coroutine eventually resumes, it continues executing the continuation function. However, there is one special case, which is when this function is called from inside a line or a count hook (see &lt;a href=&quot;#4.7&quot;&gt;&amp;sect;4.7&lt;/a&gt;). In that case, &lt;code&gt;lua_yieldk&lt;/code&gt; should be called with no continuation (probably in the form of &lt;a href=&quot;#lua_yield&quot;&gt;&lt;code&gt;lua_yield&lt;/code&gt;&lt;/a&gt;) and no results, and the hook should return immediately after the call. Lua will yield and, when the coroutine resumes again, it will continue the normal execution of the (Lua) function that triggered the hook.</source>
          <target state="translated">일반적으로이 함수는 반환되지 않습니다. 코 루틴이 결국 다시 시작되면 계속 기능을 계속 실행합니다. 그러나 한 가지 특별한 경우가 있는데, 이것은이 함수가 라인 또는 카운트 후크 내부에서 호출되는 경우입니다 ( &lt;a href=&quot;#4.7&quot;&gt;&amp;sect;4.7&lt;/a&gt; 참조 ). 이 경우 &lt;code&gt;lua_yieldk&lt;/code&gt; 는 연속하지 않고 (아마 &lt;a href=&quot;#lua_yield&quot;&gt; &lt;code&gt;lua_yield&lt;/code&gt; &lt;/a&gt; 형식으로 ) 결과없이 호출되어야하며 후크는 호출 직후에 반환되어야합니다. Lua는 양보하고 코 루틴이 다시 재개되면 후크를 트리거 한 (Lua) 함수의 정상적인 실행을 계속합니다.</target>
        </trans-unit>
        <trans-unit id="ede0ea911a1e4e16232a1c52be2e25bf93574b23" translate="yes" xml:space="preserve">
          <source>Usually, this function does not return; when the coroutine eventually resumes, it continues executing the continuation function. However, there is one special case, which is when this function is called from inside a line or a count hook (see &lt;a href=&quot;#4.9&quot;&gt;&amp;sect;4.9&lt;/a&gt;). In that case, &lt;code&gt;lua_yieldk&lt;/code&gt; should be called with no continuation (probably in the form of &lt;a href=&quot;#lua_yield&quot;&gt;&lt;code&gt;lua_yield&lt;/code&gt;&lt;/a&gt;) and no results, and the hook should return immediately after the call. Lua will yield and, when the coroutine resumes again, it will continue the normal execution of the (Lua) function that triggered the hook.</source>
          <target state="translated">일반적으로이 함수는 반환되지 않습니다. 코 루틴이 결국 재개되면 계속 기능을 계속 실행합니다. 그러나이 함수가 라인 또는 카운트 훅 내부에서 호출 될 때 특별한 경우가 있습니다 (참조&lt;a href=&quot;#4.9&quot;&gt; &amp;sect;4.9&lt;/a&gt; ). 이 경우 &lt;code&gt;lua_yieldk&lt;/code&gt; 는 연속없이 (아마도 &lt;a href=&quot;#lua_yield&quot;&gt; &lt;code&gt;lua_yield&lt;/code&gt; &lt;/a&gt; 형식으로 ) 호출되고 결과가 없어야하며 호출 후 즉시 후크가 리턴되어야합니다. 루아는 양보하고 코 루틴이 다시 재개되면 후크를 트리거 한 (루아) 기능의 정상적인 실행을 계속합니다.</target>
        </trans-unit>
        <trans-unit id="d093e0dbaa7c773904acc28ac0d7a51be7670739" translate="yes" xml:space="preserve">
          <source>Valid and Acceptable Indices</source>
          <target state="translated">유효하고 허용 가능한 지수</target>
        </trans-unit>
        <trans-unit id="14347ed892514b4d69c3b3bf601cd9c8fb3e904b" translate="yes" xml:space="preserve">
          <source>Values and Types</source>
          <target state="translated">가치와 유형</target>
        </trans-unit>
        <trans-unit id="f5b9087c637e2bfd3e2cf26a4d45a4be30f815bf" translate="yes" xml:space="preserve">
          <source>Variable name '&lt;code&gt;?&lt;/code&gt;' (interrogation mark) represents variables with no known names (variables from chunks saved without debug information).</source>
          <target state="translated">변수 이름 ' &lt;code&gt;?&lt;/code&gt; '(질문 표시)는 알려진 이름이없는 변수 (디버그 정보없이 저장된 청크의 변수)를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="12bad2c7ac94b1eae85bb4982ce9b8d423815b52" translate="yes" xml:space="preserve">
          <source>Variable names starting with '&lt;code&gt;(&lt;/code&gt;' (open parenthesis) represent variables with no known names (internal variables such as loop control variables, and variables from chunks saved without debug information).</source>
          <target state="translated">' &lt;code&gt;(&lt;/code&gt; '(괄호 열기)로 시작하는 변수 이름 은 알려진 이름이없는 변수 (루프 제어 변수와 같은 내부 변수 및 디버그 정보없이 저장된 청크 변수)를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="91ca405a6bcded978537314760080c405ac3d0b7" translate="yes" xml:space="preserve">
          <source>Variable names starting with '&lt;code&gt;(&lt;/code&gt;' (open parenthesis) represent variables with no known names (variables from chunks saved without debug information).</source>
          <target state="translated">' &lt;code&gt;(&lt;/code&gt; '(괄호로 묶은 괄호)로 시작하는 변수 이름 은 알려진 이름이없는 변수를 나타냅니다 (디버그 정보없이 저장된 청크의 변수).</target>
        </trans-unit>
        <trans-unit id="ac018db1f7b00972061adff843d37497d8ee153c" translate="yes" xml:space="preserve">
          <source>Variables</source>
          <target state="translated">Variables</target>
        </trans-unit>
        <trans-unit id="be26bb31c1703ed9ce7e9ecf54d6a6a8c765c6e5" translate="yes" xml:space="preserve">
          <source>Variables are places that store values. There are three kinds of variables in Lua: global variables, local variables, and table fields.</source>
          <target state="translated">변수는 값을 저장하는 장소입니다. Lua에는 전역 변수, 로컬 변수 및 테이블 필드의 세 가지 변수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c95e5bb697c2902b5736feab85b400b53ef72faf" translate="yes" xml:space="preserve">
          <source>Visibility Rules</source>
          <target state="translated">가시성 규칙</target>
        </trans-unit>
        <trans-unit id="e3ca3a5141d9967c701776eca46ec10c9e635787" translate="yes" xml:space="preserve">
          <source>We can specify any byte in a short literal string by its numeric value (including embedded zeros). This can be done with the escape sequence &lt;code&gt;\x&lt;em&gt;XX&lt;/em&gt;&lt;/code&gt;, where &lt;em&gt;XX&lt;/em&gt; is a sequence of exactly two hexadecimal digits, or with the escape sequence &lt;code&gt;\&lt;em&gt;ddd&lt;/em&gt;&lt;/code&gt;, where &lt;em&gt;ddd&lt;/em&gt; is a sequence of up to three decimal digits. (Note that if a decimal escape sequence is to be followed by a digit, it must be expressed using exactly three digits.)</source>
          <target state="translated">짧은 리터럴 문자열에 숫자 값 (포함 된 0 포함)으로 바이트를 지정할 수 있습니다. 이스케이프 시퀀스 &lt;code&gt;\x&lt;em&gt;XX&lt;/em&gt;&lt;/code&gt; 로 수행 할 수 있습니다 . 여기서 &lt;em&gt;XX&lt;/em&gt; 는 정확히 두 개의 16 진 숫자 시퀀스이거나 이스케이프 시퀀스 &lt;code&gt;\&lt;em&gt;ddd&lt;/em&gt;&lt;/code&gt; . 여기서 &lt;em&gt;ddd&lt;/em&gt; 는 최대 3 자리까지의 시퀀스입니다. (십진수 이스케이프 시퀀스 뒤에 숫자가 오는 경우 정확히 3 자리 숫자로 표현해야합니다.)</target>
        </trans-unit>
        <trans-unit id="588ae2cdfea2aa5958efa441455bc701b5efa923" translate="yes" xml:space="preserve">
          <source>We can specify any byte in a short literal string, including embedded zeros, by its numeric value. This can be done with the escape sequence &lt;code&gt;\x&lt;em&gt;XX&lt;/em&gt;&lt;/code&gt;, where &lt;em&gt;XX&lt;/em&gt; is a sequence of exactly two hexadecimal digits, or with the escape sequence &lt;code&gt;\&lt;em&gt;ddd&lt;/em&gt;&lt;/code&gt;, where &lt;em&gt;ddd&lt;/em&gt; is a sequence of up to three decimal digits. (Note that if a decimal escape sequence is to be followed by a digit, it must be expressed using exactly three digits.)</source>
          <target state="translated">포함 된 0을 포함하여 짧은 리터럴 문자열의 모든 바이트를 숫자 값으로 지정할 수 있습니다. 이스케이프 시퀀스 &lt;code&gt;\x&lt;em&gt;XX&lt;/em&gt;&lt;/code&gt; 사용하여 수행 할 수 있습니다 . 여기서 &lt;em&gt;XX&lt;/em&gt; 는 정확히 2 개의 16 진수 시퀀스이거나 이스케이프 시퀀스 &lt;code&gt;\&lt;em&gt;ddd&lt;/em&gt;&lt;/code&gt; . 여기서 &lt;em&gt;ddd&lt;/em&gt; 는 최대 3 자리 10 진수 시퀀스입니다. (십진수 이스케이프 시퀀스 뒤에 숫자가 오는 경우 정확히 3 자리 숫자를 사용하여 표현해야합니다.)</target>
        </trans-unit>
        <trans-unit id="a75447b7504738d77e48aaf615cad9ff4faa5f14" translate="yes" xml:space="preserve">
          <source>We need to set some terminology to explain continuations. We have a C function called from Lua which we will call the &lt;em&gt;original function&lt;/em&gt;. This original function then calls one of those three functions in the C API, which we will call the &lt;em&gt;callee function&lt;/em&gt;, that then yields the current thread. (This can happen when the callee function is &lt;a href=&quot;#lua_yieldk&quot;&gt;&lt;code&gt;lua_yieldk&lt;/code&gt;&lt;/a&gt;, or when the callee function is either &lt;a href=&quot;#lua_callk&quot;&gt;&lt;code&gt;lua_callk&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#lua_pcallk&quot;&gt;&lt;code&gt;lua_pcallk&lt;/code&gt;&lt;/a&gt; and the function called by them yields.)</source>
          <target state="translated">계속을 설명하기 위해 몇 가지 용어를 설정해야합니다. 우리는 &lt;em&gt;원래 함수를&lt;/em&gt; 호출 할 Lua에서 호출 된 C 함수를 가지고 &lt;em&gt;있습니다&lt;/em&gt; . 그런 다음이 원래 함수는 C API에서 세 가지 함수 중 하나를 호출합니다.이 함수는 호출 &lt;em&gt;수신자 함수&lt;/em&gt; 를 호출 하여 현재 스레드를 생성합니다. (피 호출자 함수가 &lt;a href=&quot;#lua_yieldk&quot;&gt; &lt;code&gt;lua_yieldk&lt;/code&gt; &lt;/a&gt; 일 때 또는 피 호출자 함수가 &lt;a href=&quot;#lua_callk&quot;&gt; &lt;code&gt;lua_callk&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#lua_pcallk&quot;&gt; &lt;code&gt;lua_pcallk&lt;/code&gt; &lt;/a&gt; 이고 호출자 가 호출 한 함수가 생성 될 때 발생할 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="50c12071f88d71d4186a342c705d8f1079d28abd" translate="yes" xml:space="preserve">
          <source>We need to set some terminology to explain continuations. We have a C function called from Lua which we will call the &lt;em&gt;original function&lt;/em&gt;. This original function then calls one of those three functions in the C API, which we will call the &lt;em&gt;callee function&lt;/em&gt;, that then yields the current thread. This can happen when the callee function is &lt;a href=&quot;#lua_yieldk&quot;&gt;&lt;code&gt;lua_yieldk&lt;/code&gt;&lt;/a&gt;, or when the callee function is either &lt;a href=&quot;#lua_callk&quot;&gt;&lt;code&gt;lua_callk&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#lua_pcallk&quot;&gt;&lt;code&gt;lua_pcallk&lt;/code&gt;&lt;/a&gt; and the function called by them yields.</source>
          <target state="translated">연속을 설명하기 위해 몇 가지 용어를 설정해야합니다. Lua에서 호출 된 C 함수가 있는데 &lt;em&gt;원래 함수를&lt;/em&gt; 호출합니다 . 이 원래 함수는 C API에서이 세 가지 함수 중 하나를 호출합니다.이 &lt;em&gt;함수&lt;/em&gt; 는 &lt;em&gt;callee 함수&lt;/em&gt; 를 호출 하여 현재 스레드를 생성합니다. 이는 피 호출자 함수가 &lt;a href=&quot;#lua_yieldk&quot;&gt; &lt;code&gt;lua_yieldk&lt;/code&gt; &lt;/a&gt; 이거나 피 호출자 함수가 &lt;a href=&quot;#lua_callk&quot;&gt; &lt;code&gt;lua_callk&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#lua_pcallk&quot;&gt; &lt;code&gt;lua_pcallk&lt;/code&gt; &lt;/a&gt; 이고 호출 된 함수가 산출 할 때 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d41db10b358155f4f013d45b45675b34f33d9ed3" translate="yes" xml:space="preserve">
          <source>Weak Tables</source>
          <target state="translated">약한 테이블</target>
        </trans-unit>
        <trans-unit id="b484eff0d117b27e8defcec4a0326a877ca574fe" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;n&lt;/code&gt; is zero, this function creates a &lt;em&gt;light C function&lt;/em&gt;, which is just a pointer to the C function. In that case, it never raises a memory error.</source>
          <target state="translated">경우 &lt;code&gt;n&lt;/code&gt; 은 제로이며,이 함수는, 생성 &lt;em&gt;빛 C 함수&lt;/em&gt; C 함수 단지 포인터이다. 이 경우 메모리 오류가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="341c8ac217813125623e3b1667a920259b68f995" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;nsize&lt;/code&gt; is not zero, the allocator must behave like &lt;code&gt;realloc&lt;/code&gt;. In particular, the allocator returns &lt;code&gt;NULL&lt;/code&gt; if and only if it cannot fulfill the request.</source>
          <target state="translated">때 &lt;code&gt;nsize&lt;/code&gt; 0이 아닌, 할당 자처럼 행동해야한다 &lt;code&gt;realloc&lt;/code&gt; 을 . 특히 할당자는 요청을 이행 할 수없는 경우에만 &lt;code&gt;NULL&lt;/code&gt; 을 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="996f3bf8346e25b1239b5ab5057ae46c604d1002" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;nsize&lt;/code&gt; is not zero, the allocator must behave like &lt;code&gt;realloc&lt;/code&gt;. The allocator returns &lt;code&gt;NULL&lt;/code&gt; if and only if it cannot fulfill the request. Lua assumes that the allocator never fails when &lt;code&gt;osize &amp;gt;= nsize&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;nsize&lt;/code&gt; 0이 아닌, 할당 자처럼 행동해야한다 &lt;code&gt;realloc&lt;/code&gt; 을 . 할당자는 요청을 이행 할 수없는 경우에만 &lt;code&gt;NULL&lt;/code&gt; 을 리턴 합니다 . Lua는 &lt;code&gt;osize &amp;gt;= nsize&lt;/code&gt; 때 할당자가 실패하지 않는다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="be7cbd666142d4c0c3a8b1ac15f72ec90fcd56bb" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;nsize&lt;/code&gt; is zero, the allocator must behave like &lt;code&gt;free&lt;/code&gt; and return &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;nsize&lt;/code&gt; 제로, 할당 자처럼 행동해야한다 &lt;code&gt;free&lt;/code&gt; 및 반환 &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c59226f69b5bf9ddb3f25a1bd10f5e6547c8ad04" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;nsize&lt;/code&gt; is zero, the allocator must behave like &lt;code&gt;free&lt;/code&gt; and then return &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;nsize&lt;/code&gt; 제로, 할당 자처럼 행동해야한다 &lt;code&gt;free&lt;/code&gt; 다음 반환 &lt;code&gt;NULL&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="63de127a2c08c3b5f3fa7d7ca6251d5614a09288" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;nup&lt;/code&gt; is not zero, all functions are created sharing &lt;code&gt;nup&lt;/code&gt; upvalues, which must be previously pushed on the stack on top of the library table. These values are popped from the stack after the registration.</source>
          <target state="translated">때 &lt;code&gt;nup&lt;/code&gt; 0이 아닌, 모든 기능은 공유 생성 &lt;code&gt;nup&lt;/code&gt; 이전 라이브러리 테이블 위에 스택에 밀어해야 upvalues을. 이 값은 등록 후 스택에서 팝됩니다.</target>
        </trans-unit>
        <trans-unit id="954632ad2b6013e35487b453af471fab7d911066" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;nup&lt;/code&gt; is not zero, all functions are created with &lt;code&gt;nup&lt;/code&gt; upvalues, initialized with copies of the &lt;code&gt;nup&lt;/code&gt; values previously pushed on the stack on top of the library table. These values are popped from the stack after the registration.</source>
          <target state="translated">경우 &lt;code&gt;nup&lt;/code&gt; 0이 아닌 모든 기능을 사용하여 만든 &lt;code&gt;nup&lt;/code&gt; 의 카피로 초기화 upvalues, &lt;code&gt;nup&lt;/code&gt; 이전 라이브러리 테이블 위에 스택에 푸시 된 값. 이러한 값은 등록 후 스택에서 팝됩니다.</target>
        </trans-unit>
        <trans-unit id="335a5475dbcacbd9ecdd1054fd0513668a84ec31" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;ptr&lt;/code&gt; is &lt;code&gt;NULL&lt;/code&gt;, &lt;code&gt;osize&lt;/code&gt; encodes the kind of object that Lua is allocating. &lt;code&gt;osize&lt;/code&gt; is any of &lt;a href=&quot;#pdf-LUA_TSTRING&quot;&gt;&lt;code&gt;LUA_TSTRING&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pdf-LUA_TTABLE&quot;&gt;&lt;code&gt;LUA_TTABLE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pdf-LUA_TFUNCTION&quot;&gt;&lt;code&gt;LUA_TFUNCTION&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pdf-LUA_TUSERDATA&quot;&gt;&lt;code&gt;LUA_TUSERDATA&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#pdf-LUA_TTHREAD&quot;&gt;&lt;code&gt;LUA_TTHREAD&lt;/code&gt;&lt;/a&gt; when (and only when) Lua is creating a new object of that type. When &lt;code&gt;osize&lt;/code&gt; is some other value, Lua is allocating memory for something else.</source>
          <target state="translated">때 &lt;code&gt;ptr&lt;/code&gt; 입니다 &lt;code&gt;NULL&lt;/code&gt; 이 , &lt;code&gt;osize&lt;/code&gt; 는 루아가 할당되는 객체의 종류를 인코딩합니다. &lt;code&gt;osize&lt;/code&gt; 는 Lua가 해당 유형의 새 객체를 만들 때 &lt;a href=&quot;#pdf-LUA_TSTRING&quot;&gt; &lt;code&gt;LUA_TSTRING&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#pdf-LUA_TTABLE&quot;&gt; &lt;code&gt;LUA_TTABLE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#pdf-LUA_TFUNCTION&quot;&gt; &lt;code&gt;LUA_TFUNCTION&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#pdf-LUA_TUSERDATA&quot;&gt; &lt;code&gt;LUA_TUSERDATA&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#pdf-LUA_TTHREAD&quot;&gt; &lt;code&gt;LUA_TTHREAD&lt;/code&gt; &lt;/a&gt; 중 하나입니다. 때 &lt;code&gt;osize&lt;/code&gt; 가 다른 값이, 루아는 뭔가 다른 메모리를 할당한다.</target>
        </trans-unit>
        <trans-unit id="46d45ecf04d4c4d9ebff91c3f78c309dab0e87ef" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;ptr&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, &lt;code&gt;osize&lt;/code&gt; is the size of the block pointed by &lt;code&gt;ptr&lt;/code&gt;, that is, the size given when it was allocated or reallocated.</source>
          <target state="translated">때 &lt;code&gt;ptr&lt;/code&gt; 없는 &lt;code&gt;NULL&lt;/code&gt; , &lt;code&gt;osize&lt;/code&gt; 가 가리키는 블록의 크기 &lt;code&gt;ptr&lt;/code&gt; 이다, 그것은 할당 또는 재 할당 할 때 주어진 크기입니다.</target>
        </trans-unit>
        <trans-unit id="0344be77d1524703e63d720dcdc36380a6d9b380" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;t&lt;/code&gt; is a sequence, &lt;code&gt;#t&lt;/code&gt; returns its only border, which corresponds to the intuitive notion of the length of the sequence. When &lt;code&gt;t&lt;/code&gt; is not a sequence, &lt;code&gt;#t&lt;/code&gt; can return any of its borders. (The exact one depends on details of the internal representation of the table, which in turn can depend on how the table was populated and the memory addresses of its non-numeric keys.)</source>
          <target state="translated">때 &lt;code&gt;t&lt;/code&gt; 이 시퀀스는, &lt;code&gt;#t&lt;/code&gt; 시퀀스의 길이의 직관적 인 개념에 해당하는 유일한 경계를 반환합니다. 때 &lt;code&gt;t&lt;/code&gt; 은 순서가 아닌, &lt;code&gt;#t&lt;/code&gt; 국경 중 하나를 반환 할 수 있습니다. (정확한 것은 테이블의 내부 표현에 대한 세부 사항에 따라 달라지며, 이는 테이블이 채워진 방법 및 숫자가 아닌 키의 메모리 주소에 따라 달라질 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="3c915266f11381b28c8d7b3533ebdd9fec110c77" translate="yes" xml:space="preserve">
          <source>When Lua loads a chunk, the default value for its &lt;code&gt;_ENV&lt;/code&gt; upvalue is the global environment (see &lt;a href=&quot;#pdf-load&quot;&gt;&lt;code&gt;load&lt;/code&gt;&lt;/a&gt;). Therefore, by default, free names in Lua code refer to entries in the global environment (and, therefore, they are also called &lt;em&gt;global variables&lt;/em&gt;). Moreover, all standard libraries are loaded in the global environment and some functions there operate on that environment. You can use &lt;a href=&quot;#pdf-load&quot;&gt;&lt;code&gt;load&lt;/code&gt;&lt;/a&gt; (or &lt;a href=&quot;#pdf-loadfile&quot;&gt;&lt;code&gt;loadfile&lt;/code&gt;&lt;/a&gt;) to load a chunk with a different environment. (In C, you have to load the chunk and then change the value of its first upvalue.)</source>
          <target state="translated">Lua가 청크를로드 할 때 &lt;code&gt;_ENV&lt;/code&gt; 최대 값의 기본값 은 글로벌 환경입니다 ( &lt;a href=&quot;#pdf-load&quot;&gt; &lt;code&gt;load&lt;/code&gt; &lt;/a&gt; 참조 ). 따라서 기본적으로 Lua 코드에서 사용 가능한 이름은 전역 환경의 항목을 나타냅니다 (따라서 &lt;em&gt;전역 변수&lt;/em&gt; 라고도 함 ). 또한 모든 표준 라이브러리는 글로벌 환경에로드되며 일부 기능은 해당 환경에서 작동합니다. 당신이 사용할 수있는 &lt;a href=&quot;#pdf-load&quot;&gt; &lt;code&gt;load&lt;/code&gt; &lt;/a&gt; (또는 &lt;a href=&quot;#pdf-loadfile&quot;&gt; &lt;code&gt;loadfile&lt;/code&gt; &lt;/a&gt; 다른 환경 덩어리를로드). (C에서는 청크를로드 한 다음 첫 번째 상한값을 변경해야합니다.)</target>
        </trans-unit>
        <trans-unit id="22c2aab30b39695e8a73be14337c6b9195ec6401" translate="yes" xml:space="preserve">
          <source>When Lua loads a chunk, the default value for its &lt;code&gt;_ENV&lt;/code&gt; variable is the global environment (see &lt;a href=&quot;#pdf-load&quot;&gt;&lt;code&gt;load&lt;/code&gt;&lt;/a&gt;). Therefore, by default, free names in Lua code refer to entries in the global environment and, therefore, they are also called &lt;em&gt;global variables&lt;/em&gt;. Moreover, all standard libraries are loaded in the global environment and some functions there operate on that environment. You can use &lt;a href=&quot;#pdf-load&quot;&gt;&lt;code&gt;load&lt;/code&gt;&lt;/a&gt; (or &lt;a href=&quot;#pdf-loadfile&quot;&gt;&lt;code&gt;loadfile&lt;/code&gt;&lt;/a&gt;) to load a chunk with a different environment. (In C, you have to load the chunk and then change the value of its first upvalue; see &lt;a href=&quot;#lua_setupvalue&quot;&gt;&lt;code&gt;lua_setupvalue&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">Lua가 청크를로드 할 때 &lt;code&gt;_ENV&lt;/code&gt; 변수 의 기본값 은 전역 환경입니다 ( &lt;a href=&quot;#pdf-load&quot;&gt; &lt;code&gt;load&lt;/code&gt; &lt;/a&gt; 참조 ). 따라서 기본적으로 Lua 코드의 자유 이름은 전역 환경의 항목을 참조하므로 &lt;em&gt;전역 변수&lt;/em&gt; 라고도 &lt;em&gt;합니다&lt;/em&gt; . 또한 모든 표준 라이브러리는 전역 환경에로드되고 일부 기능은 해당 환경에서 작동합니다. 당신이 사용할 수있는 &lt;a href=&quot;#pdf-load&quot;&gt; &lt;code&gt;load&lt;/code&gt; &lt;/a&gt; (또는 &lt;a href=&quot;#pdf-loadfile&quot;&gt; &lt;code&gt;loadfile&lt;/code&gt; &lt;/a&gt; 다른 환경 덩어리를로드). (C에서는 청크를로드 한 다음 첫 번째 upvalue 값을 변경해야합니다 . &lt;a href=&quot;#lua_setupvalue&quot;&gt; &lt;code&gt;lua_setupvalue&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="9bf5cddf64fd956b790dcd47186d571d0648ca7d" translate="yes" xml:space="preserve">
          <source>When a C function calls &lt;a href=&quot;#lua_yieldk&quot;&gt;&lt;code&gt;lua_yieldk&lt;/code&gt;&lt;/a&gt;, the running coroutine suspends its execution, and the call to &lt;a href=&quot;#lua_resume&quot;&gt;&lt;code&gt;lua_resume&lt;/code&gt;&lt;/a&gt; that started this coroutine returns. The parameter &lt;code&gt;nresults&lt;/code&gt; is the number of values from the stack that will be passed as results to &lt;a href=&quot;#lua_resume&quot;&gt;&lt;code&gt;lua_resume&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">C 함수가 &lt;a href=&quot;#lua_yieldk&quot;&gt; &lt;code&gt;lua_yieldk&lt;/code&gt; 를&lt;/a&gt; 호출 하면 실행중인 코 루틴이 실행을 일시 중단 하고이 코 루틴을 시작한 &lt;a href=&quot;#lua_resume&quot;&gt; &lt;code&gt;lua_resume&lt;/code&gt; 에&lt;/a&gt; 대한 호출 이 반환됩니다. &lt;code&gt;nresults&lt;/code&gt; 매개 변수 는 스택에서 결과로 &lt;a href=&quot;#lua_resume&quot;&gt; &lt;code&gt;lua_resume&lt;/code&gt; 에&lt;/a&gt; 전달 될 값의 수입니다 .</target>
        </trans-unit>
        <trans-unit id="6f9fd5a034919e5ee7025d158d3271b1427b5c02" translate="yes" xml:space="preserve">
          <source>When a C function is created, it is possible to associate some values with it, the so called upvalues; these upvalues are then accessible to the function whenever it is called. This association is called a C closure (see &lt;a href=&quot;#4.2&quot;&gt;&amp;sect;4.2&lt;/a&gt;). To create a C closure, first the initial values for its upvalues must be pushed onto the stack. (When there are multiple upvalues, the first value is pushed first.) Then &lt;a href=&quot;#lua_pushcclosure&quot;&gt;&lt;code&gt;lua_pushcclosure&lt;/code&gt;&lt;/a&gt; is called to create and push the C function onto the stack, with the argument &lt;code&gt;n&lt;/code&gt; telling how many values will be associated with the function. &lt;a href=&quot;#lua_pushcclosure&quot;&gt;&lt;code&gt;lua_pushcclosure&lt;/code&gt;&lt;/a&gt; also pops these values from the stack.</source>
          <target state="translated">C 함수가 생성되면 upvalues라고하는 일부 값을 연결할 수 있습니다. 이러한 upvalue는 호출 될 때마다 함수에 액세스 할 수 있습니다. 이 연결을 C 클로저 ( &lt;a href=&quot;#4.2&quot;&gt;&amp;sect;4.2&lt;/a&gt; 참조 ) 라고합니다 . C 클로저를 생성하려면 먼저 upvalue의 초기 값을 스택에 푸시해야합니다. (여러 upvalue가있는 경우 첫 번째 값이 먼저 푸시됩니다.) 그런 다음 &lt;a href=&quot;#lua_pushcclosure&quot;&gt; &lt;code&gt;lua_pushcclosure&lt;/code&gt; &lt;/a&gt; 가 호출되어 C 함수를 생성하고 스택에 푸시합니다. 인수 &lt;code&gt;n&lt;/code&gt; 은 함수와 관련된 값의 수를 알려줍니다. &lt;a href=&quot;#lua_pushcclosure&quot;&gt; &lt;code&gt;lua_pushcclosure&lt;/code&gt; &lt;/a&gt; 는 또한 스택에서 이러한 값을 팝합니다.</target>
        </trans-unit>
        <trans-unit id="6587795ac24fa71cf1c2a7e27096b42bc7a40713" translate="yes" xml:space="preserve">
          <source>When a C function is created, it is possible to associate some values with it, thus creating a &lt;em&gt;C closure&lt;/em&gt; (see &lt;a href=&quot;#lua_pushcclosure&quot;&gt;&lt;code&gt;lua_pushcclosure&lt;/code&gt;&lt;/a&gt;); these values are called &lt;em&gt;upvalues&lt;/em&gt; and are accessible to the function whenever it is called.</source>
          <target state="translated">C 함수가 작성되면 일부 값을이 함수와 연관시켜 &lt;em&gt;C 클로저&lt;/em&gt; 를 작성할 수 있습니다 ( &lt;a href=&quot;#lua_pushcclosure&quot;&gt; &lt;code&gt;lua_pushcclosure&lt;/code&gt; &lt;/a&gt; 참조 ). 이러한 값을 &lt;em&gt;업값&lt;/em&gt; 이라고하며 호출 될 때마다 함수에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11ab54e362e4ae46fe6b07e57d87eadd11f23cbe" translate="yes" xml:space="preserve">
          <source>When a C function is created, it is possible to associate some values with it, thus creating a C closure (see &lt;a href=&quot;#4.4&quot;&gt;&amp;sect;4.4&lt;/a&gt;); these values are then accessible to the function whenever it is called. To associate values with a C function, first these values must be pushed onto the stack (when there are multiple values, the first value is pushed first). Then &lt;a href=&quot;#lua_pushcclosure&quot;&gt;&lt;code&gt;lua_pushcclosure&lt;/code&gt;&lt;/a&gt; is called to create and push the C function onto the stack, with the argument &lt;code&gt;n&lt;/code&gt; telling how many values will be associated with the function. &lt;a href=&quot;#lua_pushcclosure&quot;&gt;&lt;code&gt;lua_pushcclosure&lt;/code&gt;&lt;/a&gt; also pops these values from the stack.</source>
          <target state="translated">C 함수가 작성되면 일부 값을이 함수와 연관시켜 C 클로저를 작성할 수 있습니다 ( &lt;a href=&quot;#4.4&quot;&gt;&amp;sect;4.4&lt;/a&gt; 참조 ). 그런 다음이 값은 호출 될 때마다 함수에 액세스 할 수 있습니다. 값을 C 함수와 연관 시키려면 먼저이 값을 스택으로 푸시해야합니다 (여러 값이있는 경우 첫 번째 값이 먼저 푸시 됨). 그런 다음 &lt;a href=&quot;#lua_pushcclosure&quot;&gt; &lt;code&gt;lua_pushcclosure&lt;/code&gt; &lt;/a&gt; 가 호출되어 C 함수를 생성하고 스택에 푸시합니다. 인수 &lt;code&gt;n&lt;/code&gt; 은 함수와 연관된 값의 수를 알려줍니다. &lt;a href=&quot;#lua_pushcclosure&quot;&gt; &lt;code&gt;lua_pushcclosure&lt;/code&gt; &lt;/a&gt; 는이 값을 스택에서 팝합니다.</target>
        </trans-unit>
        <trans-unit id="f143d2ac13b52a6742b50e250fa83e180f7c76c7" translate="yes" xml:space="preserve">
          <source>When a Lua function is called, it adjusts its list of arguments to the length of its list of parameters, unless the function is a &lt;em&gt;vararg function&lt;/em&gt;, which is indicated by three dots ('&lt;code&gt;...&lt;/code&gt;') at the end of its parameter list. A vararg function does not adjust its argument list; instead, it collects all extra arguments and supplies them to the function through a &lt;em&gt;vararg expression&lt;/em&gt;, which is also written as three dots. The value of this expression is a list of all actual extra arguments, similar to a function with multiple results. If a vararg expression is used inside another expression or in the middle of a list of expressions, then its return list is adjusted to one element. If the expression is used as the last element of a list of expressions, then no adjustment is made (unless that last expression is enclosed in parentheses).</source>
          <target state="translated">Lua 함수가 호출되면 해당 함수가 매개 변수 목록 끝에 세 개의 점 ( ' &lt;code&gt;...&lt;/code&gt; ')으로 표시되는 &lt;em&gt;vararg 함수&lt;/em&gt; 가 아닌 경우 매개 변수 목록의 길이에 따라 인수 목록을 조정 합니다. . vararg 함수는 인수 목록을 조정하지 않습니다. 대신 모든 추가 인수를 수집하여 &lt;em&gt;vararg 표현식을&lt;/em&gt; 통해 함수에 제공합니다.&lt;em&gt;&lt;/em&gt;, 또한 세 개의 점으로 기록됩니다. 이 표현식의 값은 여러 결과가있는 함수와 유사한 모든 실제 추가 인수의 목록입니다. vararg 표현식이 다른 표현식 내부 또는 표현식 목록 중간에 사용되는 경우 반환 목록이 하나의 요소로 조정됩니다. 표현식이 표현식 목록의 마지막 요소로 사용되는 경우 조정이 수행되지 않습니다 (마지막 표현식이 괄호로 묶여 있지 않은 경우).</target>
        </trans-unit>
        <trans-unit id="e078eea66272045084e3f01aa8c505b53aa0ead0" translate="yes" xml:space="preserve">
          <source>When a function is called, the list of arguments is adjusted to the length of the list of parameters, unless the function is a &lt;em&gt;vararg function&lt;/em&gt;, which is indicated by three dots ('&lt;code&gt;...&lt;/code&gt;') at the end of its parameter list. A vararg function does not adjust its argument list; instead, it collects all extra arguments and supplies them to the function through a &lt;em&gt;vararg expression&lt;/em&gt;, which is also written as three dots. The value of this expression is a list of all actual extra arguments, similar to a function with multiple results. If a vararg expression is used inside another expression or in the middle of a list of expressions, then its return list is adjusted to one element. If the expression is used as the last element of a list of expressions, then no adjustment is made (unless that last expression is enclosed in parentheses).</source>
          <target state="translated">함수가 호출 될 때 함수가 &lt;em&gt;vararg 함수&lt;/em&gt; 가 아닌 한 인수 목록은 매개 변수 목록의 길이에 맞게 조정됩니다 . 매개 변수 목록 끝에 3 개의 점 ( ' &lt;code&gt;...&lt;/code&gt; ')으로 표시됩니다. vararg 함수는 인수 목록을 조정하지 않습니다. 대신 모든 추가 인수를 수집하여 &lt;em&gt;vararg 표현식을&lt;/em&gt; 통해 함수에 제공합니다.&lt;em&gt;&lt;/em&gt;또한 3 개의 점으로 작성됩니다. 이 표현식의 값은 여러 개의 결과가있는 함수와 유사한 모든 실제 추가 인수의 목록입니다. vararg 표현식이 다른 표현식 내부 또는 표현식 목록의 중간에 사용되면 리턴 목록이 한 요소로 조정됩니다. 표현식이 표현식 목록의 마지막 요소로 사용되는 경우 마지막 표현식이 괄호로 묶이지 않는 한 조정이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a989335dc83d50af6f8884cd0fdec47036abae37" translate="yes" xml:space="preserve">
          <source>When a marked object becomes dead, it is not collected immediately by the garbage collector. Instead, Lua puts it in a list. After the collection, Lua goes through that list. For each object in the list, it checks the object's &lt;code&gt;__gc&lt;/code&gt; metamethod: If it is present, Lua calls it with the object as its single argument.</source>
          <target state="translated">표시된 개체가 죽어도 가비지 수집기에서 즉시 수집되지 않습니다. 대신 Lua는 그것을 목록에 넣습니다. 수집 후 Lua는 해당 목록을 살펴 봅니다. 목록의 각 객체에 대해 객체의 &lt;code&gt;__gc&lt;/code&gt; 메타 메서드를 확인합니다 . 존재하는 경우 Lua는 객체를 단일 인수로 사용하여이를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="da6fe573488f94135e6cdc83d520dc4a94e938c8" translate="yes" xml:space="preserve">
          <source>When a marked object becomes garbage, it is not collected immediately by the garbage collector. Instead, Lua puts it in a list. After the collection, Lua goes through that list. For each object in the list, it checks the object's &lt;code&gt;__gc&lt;/code&gt; metamethod: If it is a function, Lua calls it with the object as its single argument; if the metamethod is not a function, Lua simply ignores it.</source>
          <target state="translated">표시된 객체가 가비지가되면 가비지 수집기에서 즉시 수집하지 않습니다. 대신 Lua는 목록에 넣습니다. 수집 후 Lua는 해당 목록을 살펴 봅니다. 목록의 각 객체에 대해 객체의 &lt;code&gt;__gc&lt;/code&gt; 메타 메소드를 확인합니다 . 함수 인 경우 Lua는 객체를 단일 인수로 사용하여 객체를 호출합니다. 메타 메소드가 함수가 아닌 경우 루아는 단순히이를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="80897f837555b95f2cb104a59226a4a40d8e481f" translate="yes" xml:space="preserve">
          <source>When called with &lt;b&gt;nil&lt;/b&gt; as the first argument, this function only returns the name of the current locale for the given category.</source>
          <target state="translated">첫 번째 인수 로 &lt;b&gt;nil&lt;/b&gt; 을 사용하여 호출하면 이 함수는 주어진 범주에 대한 현재 로케일의 이름 만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="12503992ba3e7b779eee88f9ab72a6febed44f13" translate="yes" xml:space="preserve">
          <source>When called with &lt;code&gt;base&lt;/code&gt;, then &lt;code&gt;e&lt;/code&gt; must be a string to be interpreted as an integer numeral in that base. The base may be any integer between 2 and 36, inclusive. In bases above 10, the letter '&lt;code&gt;A&lt;/code&gt;' (in either upper or lower case) represents 10, '&lt;code&gt;B&lt;/code&gt;' represents 11, and so forth, with '&lt;code&gt;Z&lt;/code&gt;' representing 35. If the string &lt;code&gt;e&lt;/code&gt; is not a valid numeral in the given base, the function returns &lt;b&gt;fail&lt;/b&gt;.</source>
          <target state="translated">호출 할 때 &lt;code&gt;base&lt;/code&gt; , 다음 &lt;code&gt;e&lt;/code&gt; 그 자료의 정수 숫자로 해석 될 수있는 문자열이어야합니다. 밑은 2에서 36 사이의 정수일 수 있습니다. 10을 초과하는 밑수에서 문자 ' &lt;code&gt;A&lt;/code&gt; '(대문자 또는 소문자)는 10을 나타내고, ' &lt;code&gt;B&lt;/code&gt; '는 11을 나타냅니다. ' &lt;code&gt;Z&lt;/code&gt; '는 35를 나타냅니다. 문자열 &lt;code&gt;e&lt;/code&gt; 가 주어진에서 유효한 숫자가 아닌 경우 이 함수는 &lt;b&gt;fail을&lt;/b&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="641f9e62059a652c6e39c5a7f8f27534a9246ba4" translate="yes" xml:space="preserve">
          <source>When called with &lt;code&gt;base&lt;/code&gt;, then &lt;code&gt;e&lt;/code&gt; must be a string to be interpreted as an integer numeral in that base. The base may be any integer between 2 and 36, inclusive. In bases above 10, the letter '&lt;code&gt;A&lt;/code&gt;' (in either upper or lower case) represents 10, '&lt;code&gt;B&lt;/code&gt;' represents 11, and so forth, with '&lt;code&gt;Z&lt;/code&gt;' representing 35. If the string &lt;code&gt;e&lt;/code&gt; is not a valid numeral in the given base, the function returns &lt;b&gt;nil&lt;/b&gt;.</source>
          <target state="translated">호출 할 때 &lt;code&gt;base&lt;/code&gt; , 다음 &lt;code&gt;e&lt;/code&gt; 그 자료의 정수 숫자로 해석 될 수있는 문자열이어야합니다. 밑은 2와 36 사이의 정수일 수 있습니다. 10을 초과하는 밑줄에서 문자 ' &lt;code&gt;A&lt;/code&gt; '(대문자 또는 소문자)는 10을 나타내고, ' &lt;code&gt;B&lt;/code&gt; '는 11을 나타내며, ' &lt;code&gt;Z&lt;/code&gt; '는 35를 나타냅니다. 문자열 &lt;code&gt;e&lt;/code&gt; 가 지정된 숫자가 아닌 경우 base에서 함수는 &lt;b&gt;nil을&lt;/b&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="388bcef0db67f7e381df66c3f7ee8cf9b5be28dc" translate="yes" xml:space="preserve">
          <source>When called with a file name, it opens the named file (in text mode), and sets its handle as the default input file. When called with a file handle, it simply sets this file handle as the default input file. When called without arguments, it returns the current default input file.</source>
          <target state="translated">파일 이름으로 호출되면 명명 된 파일 (텍스트 모드)을 열고 해당 핸들을 기본 입력 파일로 설정합니다. 파일 핸들로 호출하면이 파일 핸들을 기본 입력 파일로 설정하기 만하면됩니다. 인수없이 호출되면 현재 기본 입력 파일을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ae1235a6e1b0d97767a88001b252dc354fc4428a" translate="yes" xml:space="preserve">
          <source>When called with a file name, it opens the named file (in text mode), and sets its handle as the default input file. When called with a file handle, it simply sets this file handle as the default input file. When called without parameters, it returns the current default input file.</source>
          <target state="translated">파일 이름으로 호출하면 이름이 지정된 파일 (텍스트 모드)이 열리고 핸들을 기본 입력 파일로 설정합니다. 파일 핸들과 함께 호출되면이 파일 핸들을 기본 입력 파일로 설정하기 만하면됩니다. 매개 변수없이 호출되면 현재 기본 입력 파일을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="861fad074ef63ba8ca7f9ab877254b943a4b7908" translate="yes" xml:space="preserve">
          <source>When called with a table, &lt;code&gt;os.time&lt;/code&gt; also normalizes all the fields documented in the &lt;a href=&quot;#pdf-os.date&quot;&gt;&lt;code&gt;os.date&lt;/code&gt;&lt;/a&gt; function, so that they represent the same time as before the call but with values inside their valid ranges.</source>
          <target state="translated">테이블과 함께 호출 될 때 &lt;code&gt;os.time&lt;/code&gt; 은 &lt;a href=&quot;#pdf-os.date&quot;&gt; &lt;code&gt;os.date&lt;/code&gt; &lt;/a&gt; 함수에 문서화 된 모든 필드도 정규화 하여 호출 전과 동일한 시간을 나타내지 만 유효한 범위 내의 값을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="36b8d68eea93133c352fa9c0560fcd4d022359aa" translate="yes" xml:space="preserve">
          <source>When called with at least one argument, the integer parameters &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are joined into a 128-bit &lt;em&gt;seed&lt;/em&gt; that is used to reinitialize the pseudo-random generator; equal seeds produce equal sequences of numbers. The default for &lt;code&gt;y&lt;/code&gt; is zero.</source>
          <target state="translated">적어도 하나의 인수로 호출 될 때 정수 매개 변수 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 는 의사 랜덤 생성기를 다시 초기화하는 데 사용되는 128 비트 &lt;em&gt;시드&lt;/em&gt; 로 결합됩니다 . 동일한 시드는 동일한 수열을 생성합니다. &lt;code&gt;y&lt;/code&gt; 의 기본값 은 0입니다.</target>
        </trans-unit>
        <trans-unit id="cb0d3b8cfb48505757d0b30079cef91155c8b44b" translate="yes" xml:space="preserve">
          <source>When called with no &lt;code&gt;base&lt;/code&gt;, &lt;code&gt;tonumber&lt;/code&gt; tries to convert its argument to a number. If the argument is already a number or a string convertible to a number, then &lt;code&gt;tonumber&lt;/code&gt; returns this number; otherwise, it returns &lt;b&gt;fail&lt;/b&gt;.</source>
          <target state="translated">어떤 호출 할 때 &lt;code&gt;base&lt;/code&gt; , &lt;code&gt;tonumber&lt;/code&gt; 는 숫자로 인수를 변환하려고합니다. 인수가 이미 숫자이거나 숫자로 변환 가능한 문자열이면 &lt;code&gt;tonumber&lt;/code&gt; 는이 숫자를 반환합니다. 그렇지 않으면 &lt;b&gt;fail&lt;/b&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="0331839def59d1c279589644566be45521e46878" translate="yes" xml:space="preserve">
          <source>When called with no &lt;code&gt;base&lt;/code&gt;, &lt;code&gt;tonumber&lt;/code&gt; tries to convert its argument to a number. If the argument is already a number or a string convertible to a number, then &lt;code&gt;tonumber&lt;/code&gt; returns this number; otherwise, it returns &lt;b&gt;nil&lt;/b&gt;.</source>
          <target state="translated">어떤 호출 할 때 &lt;code&gt;base&lt;/code&gt; , &lt;code&gt;tonumber&lt;/code&gt; 는 숫자로 인수를 변환하려고합니다. 인수가 이미 숫자이거나 숫자로 변환 가능한 문자열 인 경우 &lt;code&gt;tonumber&lt;/code&gt; 는이 숫자를 리턴합니다. 그렇지 않으면 &lt;b&gt;nil&lt;/b&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="2cf361fe46fad3d672a6b7fc3deab505bdbf7127" translate="yes" xml:space="preserve">
          <source>When called with no arguments, Lua generates a seed with a weak attempt for randomness.</source>
          <target state="translated">인수없이 호출되면 Lua는 임의성을 약하게 시도하는 시드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="e694403948e49c3cdfc8883a69a69e59e1e2c12c" translate="yes" xml:space="preserve">
          <source>When called with option &lt;code&gt;-E&lt;/code&gt;, besides ignoring &lt;code&gt;LUA_INIT&lt;/code&gt;, Lua also ignores the values of &lt;code&gt;LUA_PATH&lt;/code&gt; and &lt;code&gt;LUA_CPATH&lt;/code&gt;, setting the values of &lt;a href=&quot;#pdf-package.path&quot;&gt;&lt;code&gt;package.path&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#pdf-package.cpath&quot;&gt;&lt;code&gt;package.cpath&lt;/code&gt;&lt;/a&gt; with the default paths defined in &lt;code&gt;luaconf.h&lt;/code&gt;.</source>
          <target state="translated">옵션을 호출 할 때 &lt;code&gt;-E&lt;/code&gt; , 무시 외에 &lt;code&gt;LUA_INIT&lt;/code&gt; 을 , 루아도의 값 무시 &lt;code&gt;LUA_PATH&lt;/code&gt; 및 &lt;code&gt;LUA_CPATH&lt;/code&gt; 을 의 값 설정, &lt;a href=&quot;#pdf-package.path&quot;&gt; &lt;code&gt;package.path&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#pdf-package.cpath&quot;&gt; &lt;code&gt;package.cpath&lt;/code&gt; 을&lt;/a&gt; 에 정의 된 기본 경로와 &lt;code&gt;luaconf.h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="595bc8625b546518b3559c5e580a4c82ef8058d6" translate="yes" xml:space="preserve">
          <source>When called with the option &lt;code&gt;-E&lt;/code&gt;, Lua does not consult any environment variables. In particular, the values of &lt;a href=&quot;#pdf-package.path&quot;&gt;&lt;code&gt;package.path&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#pdf-package.cpath&quot;&gt;&lt;code&gt;package.cpath&lt;/code&gt;&lt;/a&gt; are set with the default paths defined in &lt;code&gt;luaconf.h&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;-E&lt;/code&gt; 옵션과 함께 호출되면 Lua는 환경 변수를 참조하지 않습니다. 특히 &lt;a href=&quot;#pdf-package.path&quot;&gt; &lt;code&gt;package.path&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#pdf-package.cpath&quot;&gt; &lt;code&gt;package.cpath&lt;/code&gt; &lt;/a&gt; 의 값은 &lt;code&gt;luaconf.h&lt;/code&gt; 에 정의 된 기본 경로로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="de667989e59831a06657a1b7bb1953b9b2690bfc" translate="yes" xml:space="preserve">
          <source>When called without a &lt;code&gt;command&lt;/code&gt;, &lt;code&gt;os.execute&lt;/code&gt; returns a boolean that is true if a shell is available.</source>
          <target state="translated">없이 호출 할 때 &lt;code&gt;command&lt;/code&gt; , &lt;code&gt;os.execute&lt;/code&gt; 은 쉘을 사용할 수있는 경우 true 인 부울을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="08516ebb937ecdc973de2d47f44995af938578a2" translate="yes" xml:space="preserve">
          <source>When called without arguments, &lt;a href=&quot;#pdf-debug.sethook&quot;&gt;&lt;code&gt;debug.sethook&lt;/code&gt;&lt;/a&gt; turns off the hook.</source>
          <target state="translated">인수없이 호출되면 &lt;a href=&quot;#pdf-debug.sethook&quot;&gt; &lt;code&gt;debug.sethook&lt;/code&gt; &lt;/a&gt; 이 후크를 끕니다.</target>
        </trans-unit>
        <trans-unit id="8dfc7d66f66b8d42b0606debc6628a523caba4e4" translate="yes" xml:space="preserve">
          <source>When called without arguments, &lt;code&gt;date&lt;/code&gt; returns a reasonable date and time representation that depends on the host system and on the current locale. (More specifically, &lt;code&gt;os.date()&lt;/code&gt; is equivalent to &lt;code&gt;os.date(&quot;%c&quot;)&lt;/code&gt;.)</source>
          <target state="translated">인수없이 호출하면 &lt;code&gt;date&lt;/code&gt; 는 호스트 시스템과 현재 로케일에 따라 합리적인 날짜 및 시간 표현을 반환합니다. 보다 구체적으로 &lt;code&gt;os.date()&lt;/code&gt; 는 &lt;code&gt;os.date(&quot;%c&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c64be510d7a1b577fd35233990dcc39ace49bc5f" translate="yes" xml:space="preserve">
          <source>When called without arguments, returns a pseudo-random float with uniform distribution in the range &lt;em&gt;[0,1)&lt;/em&gt;. When called with two integers &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt;, &lt;code&gt;math.random&lt;/code&gt; returns a pseudo-random integer with uniform distribution in the range &lt;em&gt;[m, n]&lt;/em&gt;. (The value &lt;em&gt;n-m&lt;/em&gt; cannot be negative and must fit in a Lua integer.) The call &lt;code&gt;math.random(n)&lt;/code&gt; is equivalent to &lt;code&gt;math.random(1,n)&lt;/code&gt;.</source>
          <target state="translated">인수없이 호출되면 &lt;em&gt;[0,1)&lt;/em&gt; 범위의 균일 한 분포를 가진 의사 난수 부동 소수점을 반환합니다 . 두 정수로 불리는 경우 &lt;code&gt;m&lt;/code&gt; 및 &lt;code&gt;n&lt;/code&gt; , &lt;code&gt;math.random&lt;/code&gt; 반환 범위의 균일 분포 의사 랜덤 정수 &lt;em&gt;[N m,]&lt;/em&gt; . &lt;em&gt;nm&lt;/em&gt; 값 은 음수 일 수 없으며 Lua 정수에 맞아야합니다. &lt;code&gt;math.random(n)&lt;/code&gt; 호출 은 &lt;code&gt;math.random(1,n)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="960c42dc7bcd6f99e9cb92d7e9f07ec281c2bc3b" translate="yes" xml:space="preserve">
          <source>When called without arguments, returns a pseudo-random float with uniform distribution in the range &lt;em&gt;[0,1)&lt;/em&gt;. When called with two integers &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt;, &lt;code&gt;math.random&lt;/code&gt; returns a pseudo-random integer with uniform distribution in the range &lt;em&gt;[m, n]&lt;/em&gt;. The call &lt;code&gt;math.random(n)&lt;/code&gt;, for a positive &lt;code&gt;n&lt;/code&gt;, is equivalent to &lt;code&gt;math.random(1,n)&lt;/code&gt;. The call &lt;code&gt;math.random(0)&lt;/code&gt; produces an integer with all bits (pseudo)random.</source>
          <target state="translated">인수없이 호출되면 &lt;em&gt;[0,1)&lt;/em&gt; 범위에서 균일 한 분포를 갖는 의사 난수 부동 소수점을 반환합니다 . 두 정수로 불리는 경우 &lt;code&gt;m&lt;/code&gt; 및 &lt;code&gt;n&lt;/code&gt; , &lt;code&gt;math.random&lt;/code&gt; 반환 범위의 균일 분포 의사 랜덤 정수 &lt;em&gt;[N m,]&lt;/em&gt; . 양수 &lt;code&gt;n&lt;/code&gt; 에 대한 &lt;code&gt;math.random(n)&lt;/code&gt; 호출 은 &lt;code&gt;math.random(1,n)&lt;/code&gt; 과 동일합니다 . &lt;code&gt;math.random(0)&lt;/code&gt; 호출 은 모든 비트 (의사) 임의의 정수를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="29766b7237675cb97603d39839cfd67a198b7d0e" translate="yes" xml:space="preserve">
          <source>When called without option &lt;code&gt;-E&lt;/code&gt;, the interpreter checks for an environment variable &lt;a id=&quot;pdf-LUA_INIT_5_3&quot;&gt;&lt;code&gt;LUA_INIT_5_3&lt;/code&gt;&lt;/a&gt; (or &lt;a id=&quot;pdf-LUA_INIT&quot;&gt;&lt;code&gt;LUA_INIT&lt;/code&gt;&lt;/a&gt; if the versioned name is not defined) before running any argument. If the variable content has the format &lt;code&gt;@&lt;em&gt;filename&lt;/em&gt;&lt;/code&gt;, then &lt;code&gt;lua&lt;/code&gt; executes the file. Otherwise, &lt;code&gt;lua&lt;/code&gt; executes the string itself.</source>
          <target state="translated">&lt;code&gt;-E&lt;/code&gt; 옵션없이 호출되면 인터프리터는 인수를 실행하기 전에 환경 변수 &lt;a id=&quot;pdf-LUA_INIT_5_3&quot;&gt; &lt;code&gt;LUA_INIT_5_3&lt;/code&gt; &lt;/a&gt; (또는 버전 이름이 정의되지 않은 경우 &lt;a id=&quot;pdf-LUA_INIT&quot;&gt; &lt;code&gt;LUA_INIT&lt;/code&gt; )를&lt;/a&gt; 확인합니다. 변수 내용의 형식이 &lt;code&gt;@&lt;em&gt;filename&lt;/em&gt;&lt;/code&gt; 인 경우 &lt;code&gt;lua&lt;/code&gt; 는 파일을 실행합니다. 그렇지 않으면 &lt;code&gt;lua&lt;/code&gt; 는 문자열 자체를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="af35e90ee5c0251ed92b8eb4bb70c55a27767934" translate="yes" xml:space="preserve">
          <source>When called without the option &lt;code&gt;-E&lt;/code&gt;, the interpreter checks for an environment variable &lt;a id=&quot;pdf-LUA_INIT_5_4&quot;&gt;&lt;code&gt;LUA_INIT_5_4&lt;/code&gt;&lt;/a&gt; (or &lt;a id=&quot;pdf-LUA_INIT&quot;&gt;&lt;code&gt;LUA_INIT&lt;/code&gt;&lt;/a&gt; if the versioned name is not defined) before running any argument. If the variable content has the format &lt;code&gt;@&lt;em&gt;filename&lt;/em&gt;&lt;/code&gt;, then &lt;code&gt;lua&lt;/code&gt; executes the file. Otherwise, &lt;code&gt;lua&lt;/code&gt; executes the string itself.</source>
          <target state="translated">&lt;code&gt;-E&lt;/code&gt; 옵션없이 호출되면 인터프리터는 인수를 실행하기 전에 환경 변수 &lt;a id=&quot;pdf-LUA_INIT_5_4&quot;&gt; &lt;code&gt;LUA_INIT_5_4&lt;/code&gt; &lt;/a&gt; (또는 버전이 지정된 이름이 정의되지 않은 경우 &lt;a id=&quot;pdf-LUA_INIT&quot;&gt; &lt;code&gt;LUA_INIT&lt;/code&gt; )를&lt;/a&gt; 확인합니다. 변수 내용이 &lt;code&gt;@&lt;em&gt;filename&lt;/em&gt;&lt;/code&gt; 형식 이면 &lt;code&gt;lua&lt;/code&gt; 가 파일을 실행합니다. 그렇지 않으면 &lt;code&gt;lua&lt;/code&gt; 는 문자열 자체를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="30a01c66de0f50f818dc4c5eb18a31a7ce0c4e4f" translate="yes" xml:space="preserve">
          <source>When closing a file handle created with &lt;a href=&quot;#pdf-io.popen&quot;&gt;&lt;code&gt;io.popen&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pdf-file:close&quot;&gt;&lt;code&gt;file:close&lt;/code&gt;&lt;/a&gt; returns the same values returned by &lt;a href=&quot;#pdf-os.execute&quot;&gt;&lt;code&gt;os.execute&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">만든 파일 핸들을 닫을 때 &lt;a href=&quot;#pdf-io.popen&quot;&gt; &lt;code&gt;io.popen&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#pdf-file:close&quot;&gt; &lt;code&gt;file:close&lt;/code&gt; &lt;/a&gt; 수익률은 같은 값에 의해 반환 &lt;a href=&quot;#pdf-os.execute&quot;&gt; &lt;code&gt;os.execute&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d7249fe8ac6ec7cee81ebe5d27b0ade52596d313" translate="yes" xml:space="preserve">
          <source>When finalizing an object, Lua does not ignore &lt;code&gt;__gc&lt;/code&gt; metamethods that are not functions. Any value will be called, if present. (Non-callable values will generate a warning, like any other error when calling a finalizer.)</source>
          <target state="translated">객체를 마무리 할 때 Lua는 함수가 아닌 &lt;code&gt;__gc&lt;/code&gt; 메타 메서드를 무시하지 않습니다 . 존재하는 경우 모든 값이 호출됩니다. (호출 할 수없는 값은 종료자를 호출 할 때 다른 오류와 마찬가지로 경고를 생성합니다.)</target>
        </trans-unit>
        <trans-unit id="37e9db54045b382cd01f62245d15a65082274498" translate="yes" xml:space="preserve">
          <source>When finishing normally, the interpreter closes its main Lua state (see &lt;a href=&quot;#lua_close&quot;&gt;&lt;code&gt;lua_close&lt;/code&gt;&lt;/a&gt;). The script can avoid this step by calling &lt;a href=&quot;#pdf-os.exit&quot;&gt;&lt;code&gt;os.exit&lt;/code&gt;&lt;/a&gt; to terminate.</source>
          <target state="translated">정상적으로 끝나면 인터프리터는 기본 Lua 상태를 닫습니다 ( &lt;a href=&quot;#lua_close&quot;&gt; &lt;code&gt;lua_close&lt;/code&gt; &lt;/a&gt; 참조 ). 스크립트는 &lt;a href=&quot;#pdf-os.exit&quot;&gt; &lt;code&gt;os.exit&lt;/code&gt; &lt;/a&gt; 를 호출 하여 종료 함으로써이 단계를 피할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="05829140d113fda20398a82789b93e3ec1b75792" translate="yes" xml:space="preserve">
          <source>When possible, you may prefer to use &lt;a href=&quot;#pdf-io.tmpfile&quot;&gt;&lt;code&gt;io.tmpfile&lt;/code&gt;&lt;/a&gt;, which automatically removes the file when the program ends.</source>
          <target state="translated">가능한 경우 프로그램 종료시 파일을 자동으로 제거하는 &lt;a href=&quot;#pdf-io.tmpfile&quot;&gt; &lt;code&gt;io.tmpfile&lt;/code&gt; &lt;/a&gt; 을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="8f55b3bc753eda1e33e754171321ae6cdf1d0c2b" translate="yes" xml:space="preserve">
          <source>When the coroutine is resumed again, Lua calls the given continuation function &lt;code&gt;k&lt;/code&gt; to continue the execution of the C function that yielded (see &lt;a href=&quot;#4.5&quot;&gt;&amp;sect;4.5&lt;/a&gt;). This continuation function receives the same stack from the previous function, with the &lt;code&gt;n&lt;/code&gt; results removed and replaced by the arguments passed to &lt;a href=&quot;#lua_resume&quot;&gt;&lt;code&gt;lua_resume&lt;/code&gt;&lt;/a&gt;. Moreover, the continuation function receives the value &lt;code&gt;ctx&lt;/code&gt; that was passed to &lt;a href=&quot;#lua_yieldk&quot;&gt;&lt;code&gt;lua_yieldk&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">코 루틴이 다시 재개 될 때 Lua는 주어진 연속 함수 &lt;code&gt;k&lt;/code&gt; 를 호출하여 양보 한 C 함수의 실행을 계속합니다 ( &lt;a href=&quot;#4.5&quot;&gt;&amp;sect;4.5&lt;/a&gt; 참조 ). 이 연속 함수는 이전 함수에서 동일한 스택을 수신하며 &lt;code&gt;n&lt;/code&gt; 개의 결과가 제거되고 &lt;a href=&quot;#lua_resume&quot;&gt; &lt;code&gt;lua_resume&lt;/code&gt; 에&lt;/a&gt; 전달 된 인수로 대체됩니다 . 또한 연속 함수는 &lt;a href=&quot;#lua_yieldk&quot;&gt; &lt;code&gt;lua_yieldk&lt;/code&gt; &lt;/a&gt; 에 전달 된 &lt;code&gt;ctx&lt;/code&gt; 값을받습니다 .</target>
        </trans-unit>
        <trans-unit id="e0d813e63ce1dec1bf88d125498265fe1c745f04" translate="yes" xml:space="preserve">
          <source>When the coroutine is resumed again, Lua calls the given continuation function &lt;code&gt;k&lt;/code&gt; to continue the execution of the C function that yielded (see &lt;a href=&quot;#4.7&quot;&gt;&amp;sect;4.7&lt;/a&gt;). This continuation function receives the same stack from the previous function, with the &lt;code&gt;n&lt;/code&gt; results removed and replaced by the arguments passed to &lt;a href=&quot;#lua_resume&quot;&gt;&lt;code&gt;lua_resume&lt;/code&gt;&lt;/a&gt;. Moreover, the continuation function receives the value &lt;code&gt;ctx&lt;/code&gt; that was passed to &lt;a href=&quot;#lua_yieldk&quot;&gt;&lt;code&gt;lua_yieldk&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">코 루틴이 다시 재개되면 Lua는 주어진 연속 함수 &lt;code&gt;k&lt;/code&gt; 를 호출하여 생성 된 C 함수의 실행을 계속합니다 ( &lt;a href=&quot;#4.7&quot;&gt;&amp;sect;4.7&lt;/a&gt; 참조 ). 이 연속 함수는 이전 함수와 동일한 스택을 수신하고 &lt;code&gt;n&lt;/code&gt; 개의 결과가 제거되고 &lt;a href=&quot;#lua_resume&quot;&gt; &lt;code&gt;lua_resume&lt;/code&gt; 에&lt;/a&gt; 전달 된 인수로 대체됩니다 . 또한 연속 함수는 &lt;a href=&quot;#lua_yieldk&quot;&gt; &lt;code&gt;lua_yieldk&lt;/code&gt; &lt;/a&gt; 에 전달 된 &lt;code&gt;ctx&lt;/code&gt; 값을 수신합니다 .</target>
        </trans-unit>
        <trans-unit id="a75209bbb2c2e6ad290df78bf5d0eed53f0f5ef0" translate="yes" xml:space="preserve">
          <source>When the function is called, the values in these fields do not need to be inside their valid ranges. For instance, if &lt;code&gt;sec&lt;/code&gt; is -10, it means 10 seconds before the time specified by the other fields; if &lt;code&gt;hour&lt;/code&gt; is 1000, it means 1000 hours after the time specified by the other fields.</source>
          <target state="translated">함수가 호출 될 때 이러한 필드의 값은 유효한 범위 내에있을 필요가 없습니다. 예를 들어, &lt;code&gt;sec&lt;/code&gt; 가 -10이면 다른 필드에서 지정한 시간보다 10 초 전을 의미합니다. 만약 &lt;code&gt;hour&lt;/code&gt; (1000)이며, 그것은 1,000시간 다른 필드에 지정된 시간 후에 의미한다.</target>
        </trans-unit>
        <trans-unit id="4c6a10ad01c056a56db07a26afc7431181db765d" translate="yes" xml:space="preserve">
          <source>When the hook is called, its first parameter is a string describing the event that has triggered its call: &lt;code&gt;&quot;call&quot;&lt;/code&gt; (or &lt;code&gt;&quot;tail call&quot;&lt;/code&gt;), &lt;code&gt;&quot;return&quot;&lt;/code&gt;, &lt;code&gt;&quot;line&quot;&lt;/code&gt;, and &lt;code&gt;&quot;count&quot;&lt;/code&gt;. For line events, the hook also gets the new line number as its second parameter. Inside a hook, you can call &lt;code&gt;getinfo&lt;/code&gt; with level 2 to get more information about the running function (level 0 is the &lt;code&gt;getinfo&lt;/code&gt; function, and level 1 is the hook function).</source>
          <target state="translated">: 후크가 호출되면, 그 첫 번째 파라미터는 호출을 트리거 한 이벤트를 기술하는 문자열 &lt;code&gt;&quot;call&quot;&lt;/code&gt; (또는 &lt;code&gt;&quot;tail call&quot;&lt;/code&gt; ), &lt;code&gt;&quot;return&quot;&lt;/code&gt; , &lt;code&gt;&quot;line&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;count&quot;&lt;/code&gt; . 행 이벤트의 경우 후크는 새 행 번호를 두 번째 매개 변수로 가져옵니다. 후크 내에서 레벨 2로 &lt;code&gt;getinfo&lt;/code&gt; 를 호출 하여 실행중인 함수에 대한 자세한 정보를 얻을 수 있습니다 (레벨 0은 &lt;code&gt;getinfo&lt;/code&gt; 함수이고 레벨 1은 후크 함수입니다).</target>
        </trans-unit>
        <trans-unit id="8bbba941f15e3649b6735004f1fa9587fdc162c9" translate="yes" xml:space="preserve">
          <source>When the hook is called, its first parameter is a string describing the event that has triggered its call: &lt;code&gt;&quot;call&quot;&lt;/code&gt;, &lt;code&gt;&quot;tail call&quot;&lt;/code&gt;, &lt;code&gt;&quot;return&quot;&lt;/code&gt;, &lt;code&gt;&quot;line&quot;&lt;/code&gt;, and &lt;code&gt;&quot;count&quot;&lt;/code&gt;. For line events, the hook also gets the new line number as its second parameter. Inside a hook, you can call &lt;code&gt;getinfo&lt;/code&gt; with level 2 to get more information about the running function. (Level 0 is the &lt;code&gt;getinfo&lt;/code&gt; function, and level 1 is the hook function.)</source>
          <target state="translated">후크가 호출 될 때 첫 번째 매개 변수는 호출을 트리거 한 이벤트를 설명하는 문자열 인 &lt;code&gt;&quot;call&quot;&lt;/code&gt; , &lt;code&gt;&quot;tail call&quot;&lt;/code&gt; , &lt;code&gt;&quot;return&quot;&lt;/code&gt; , &lt;code&gt;&quot;line&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;count&quot;&lt;/code&gt; 입니다. 라인 이벤트의 경우 후크는 두 번째 매개 변수로 새 라인 번호도 가져옵니다. 후크 내에서 레벨 2로 &lt;code&gt;getinfo&lt;/code&gt; 를 호출 하여 실행중인 함수에 대한 자세한 정보를 얻을 수 있습니다. (레벨 0은 &lt;code&gt;getinfo&lt;/code&gt; 함수이고 레벨 1은 후크 함수입니다.)</target>
        </trans-unit>
        <trans-unit id="eaa8e9df04a952020bd076482c3d60135f7f329c" translate="yes" xml:space="preserve">
          <source>When using implicit file handles, all operations are supplied by table &lt;a id=&quot;pdf-io&quot;&gt;&lt;code&gt;io&lt;/code&gt;&lt;/a&gt;. When using explicit file handles, the operation &lt;a href=&quot;#pdf-io.open&quot;&gt;&lt;code&gt;io.open&lt;/code&gt;&lt;/a&gt; returns a file handle and then all operations are supplied as methods of the file handle.</source>
          <target state="translated">내재적 파일 핸들을 사용할 때 모든 조작은 테이블 &lt;a id=&quot;pdf-io&quot;&gt; &lt;code&gt;io&lt;/code&gt; &lt;/a&gt; 에 의해 제공됩니다 . 명시 적 파일 핸들을 사용하는 경우 &lt;a href=&quot;#pdf-io.open&quot;&gt; &lt;code&gt;io.open&lt;/code&gt; &lt;/a&gt; 작업 은 파일 핸들을 반환 한 다음 모든 작업이 파일 핸들의 메서드로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="66e7217ccc689c6dec071df236389bbeca36a0c9" translate="yes" xml:space="preserve">
          <source>When you call a Lua function without a fixed number of results (see &lt;a href=&quot;#lua_call&quot;&gt;&lt;code&gt;lua_call&lt;/code&gt;&lt;/a&gt;), Lua ensures that the stack has enough space for all results, but it does not ensure any extra space. So, before pushing anything in the stack after such a call you should use &lt;a href=&quot;#lua_checkstack&quot;&gt;&lt;code&gt;lua_checkstack&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">고정 된 수의 결과없이 Lua 함수를 호출하면 ( &lt;a href=&quot;#lua_call&quot;&gt; &lt;code&gt;lua_call&lt;/code&gt; &lt;/a&gt; 참조 ) Lua는 스택에 모든 결과를위한 충분한 공간이 있는지 확인하지만 추가 공간을 보장하지는 않습니다. 따라서 이러한 호출 후 스택의 내용을 푸시하기 전에 &lt;a href=&quot;#lua_checkstack&quot;&gt; &lt;code&gt;lua_checkstack&lt;/code&gt; &lt;/a&gt; 을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e87402f549363e6adea42f0d7521692e33eb5518" translate="yes" xml:space="preserve">
          <source>When you call a Lua function without a fixed number of results (see &lt;a href=&quot;#lua_call&quot;&gt;&lt;code&gt;lua_call&lt;/code&gt;&lt;/a&gt;), Lua ensures that the stack has enough space for all results, but it does not ensure any extra space. So, before pushing anything on the stack after such a call you should use &lt;a href=&quot;#lua_checkstack&quot;&gt;&lt;code&gt;lua_checkstack&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">고정 된 수의 결과없이 Lua 함수를 호출 할 때 ( &lt;a href=&quot;#lua_call&quot;&gt; &lt;code&gt;lua_call&lt;/code&gt; &lt;/a&gt; 참조 ) Lua는 스택에 모든 결과에 대한 충분한 공간이 있는지 확인하지만 추가 공간을 보장하지는 않습니다. 따라서 이러한 호출 후 스택에 무언가를 푸시하기 전에 &lt;a href=&quot;#lua_checkstack&quot;&gt; &lt;code&gt;lua_checkstack&lt;/code&gt; &lt;/a&gt; 을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0fac89278e16d9cfb7afed920548790f04b59edb" translate="yes" xml:space="preserve">
          <source>When you close a state (see &lt;a href=&quot;#lua_close&quot;&gt;&lt;code&gt;lua_close&lt;/code&gt;&lt;/a&gt;), Lua calls the finalizers of all objects marked for finalization, following the reverse order that they were marked. If any finalizer marks objects for collection during that phase, these marks have no effect.</source>
          <target state="translated">상태를 닫으면 ( &lt;a href=&quot;#lua_close&quot;&gt; &lt;code&gt;lua_close&lt;/code&gt; &lt;/a&gt; 참조 ) Lua는 표시된 순서의 역순에 따라 종료 대상으로 표시된 모든 개체의 종료자를 호출합니다. 해당 단계에서 종료자가 수집 할 개체를 표시하면 이러한 표시가 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bfa2a1bee37ec1b8b5edb99fbbb2457d178207e5" translate="yes" xml:space="preserve">
          <source>When you create a new Lua state, its registry comes with some predefined values. These predefined values are indexed with integer keys defined as constants in &lt;code&gt;lua.h&lt;/code&gt;. The following constants are defined:</source>
          <target state="translated">새 Lua 상태를 만들면 레지스트리에 미리 정의 된 값이 제공됩니다. 이러한 사전 정의 된 값은 &lt;code&gt;lua.h&lt;/code&gt; 에서 상수로 정의 된 정수 키로 색인화됩니다 . 다음 상수가 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="7355d5bd1b6984cb05bdf3acfb6f9c1a447b9f50" translate="yes" xml:space="preserve">
          <source>When you interact with the Lua API, you are responsible for ensuring consistency. In particular, &lt;em&gt;you are responsible for controlling stack overflow&lt;/em&gt;. You can use the function &lt;a href=&quot;#lua_checkstack&quot;&gt;&lt;code&gt;lua_checkstack&lt;/code&gt;&lt;/a&gt; to ensure that the stack has enough space for pushing new elements.</source>
          <target state="translated">Lua API와 상호 작용할 때 일관성을 유지해야합니다. 특히, &lt;em&gt;스택 오버 플로우를 제어 할 책임이 있습니다&lt;/em&gt; . &lt;a href=&quot;#lua_checkstack&quot;&gt; &lt;code&gt;lua_checkstack&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 스택에 새 요소를 푸시하기에 충분한 공간이 있는지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f3ce65bde15db7ea0ab6b60f199c33fedc361e77" translate="yes" xml:space="preserve">
          <source>When you load a main chunk, the resulting function will always have exactly one upvalue, the &lt;code&gt;_ENV&lt;/code&gt; variable (see &lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt;). However, when you load a binary chunk created from a function (see &lt;a href=&quot;#pdf-string.dump&quot;&gt;&lt;code&gt;string.dump&lt;/code&gt;&lt;/a&gt;), the resulting function can have an arbitrary number of upvalues, and there is no guarantee that its first upvalue will be the &lt;code&gt;_ENV&lt;/code&gt; variable. (A non-main function may not even have an &lt;code&gt;_ENV&lt;/code&gt; upvalue.)</source>
          <target state="translated">메인 청크를로드 할 때 결과 함수는 항상 정확히 하나의 upvalue 인 &lt;code&gt;_ENV&lt;/code&gt; 변수를 &lt;a href=&quot;#2.2&quot;&gt;갖습니다&lt;/a&gt; ( &amp;sect;2.2 참조 ). 그러나 함수에서 생성 된 이진 청크를로드 할 때 ( &lt;a href=&quot;#pdf-string.dump&quot;&gt; &lt;code&gt;string.dump&lt;/code&gt; &lt;/a&gt; 참조 ) 결과 함수는 임의 개수의 upvalue를 가질 수 있으며 첫 번째 upvalue가 &lt;code&gt;_ENV&lt;/code&gt; 변수 가 될 것이라는 보장은 없습니다 . (메인이 아닌 함수는 &lt;code&gt;_ENV&lt;/code&gt; 상향 값을 갖지 않을 수도 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="1e8b32f8352fd78bcc7ec48884a68493230c9360" translate="yes" xml:space="preserve">
          <source>When you run it, it produces the following output:</source>
          <target state="translated">실행하면 다음과 같은 출력이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="a2fe48a4ba1fe6efea7e679ea6354ce71899c865" translate="yes" xml:space="preserve">
          <source>When you use &lt;a href=&quot;#pdf-xpcall&quot;&gt;&lt;code&gt;xpcall&lt;/code&gt;&lt;/a&gt; (or &lt;a href=&quot;#lua_pcall&quot;&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt;, in C) you may give a &lt;em&gt;message handler&lt;/em&gt; to be called in case of errors. This function is called with the original error object and returns a new error object. It is called before the error unwinds the stack, so that it can gather more information about the error, for instance by inspecting the stack and creating a stack traceback. This message handler is still protected by the protected call; so, an error inside the message handler will call the message handler again. If this loop goes on for too long, Lua breaks it and returns an appropriate message. The message handler is called only for regular runtime errors. It is not called for memory-allocation errors nor for errors while running finalizers or other message handlers.</source>
          <target state="translated">&lt;a href=&quot;#pdf-xpcall&quot;&gt; &lt;code&gt;xpcall&lt;/code&gt; &lt;/a&gt; (또는 C에서 &lt;a href=&quot;#lua_pcall&quot;&gt; &lt;code&gt;lua_pcall&lt;/code&gt; )&lt;/a&gt; 을 사용할 때 오류 발생시 호출 할 &lt;em&gt;메시지 처리기&lt;/em&gt; 를 제공 할 수 있습니다. 이 함수는 원래 오류 개체와 함께 호출되고 새 오류 개체를 반환합니다. 오류가 스택을 풀기 전에 호출되므로 예를 들어 스택을 검사하고 스택 추적을 생성하여 오류에 대한 추가 정보를 수집 할 수 있습니다. 이 메시지 핸들러는 여전히 보호 된 호출에 의해 보호됩니다. 따라서 메시지 핸들러 내부의 오류는 메시지 핸들러를 다시 호출합니다. 이 루프가 너무 오래 지속되면 Lua는 루프를 끊고 적절한 메시지를 반환합니다. 메시지 핸들러는 일반 런타임 오류에 대해서만 호출됩니다. 메모리 할당 오류나 종료 자 또는 기타 메시지 처리기를 실행하는 동안 오류에 대해 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="59fc39a27b959170f68fd36bc3ff7103614c868a" translate="yes" xml:space="preserve">
          <source>When you use &lt;a href=&quot;#pdf-xpcall&quot;&gt;&lt;code&gt;xpcall&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#lua_pcall&quot;&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt;, you may give a &lt;em&gt;message handler&lt;/em&gt; to be called in case of errors. This function is called with the original error object and returns a new error object. It is called before the error unwinds the stack, so that it can gather more information about the error, for instance by inspecting the stack and creating a stack traceback. This message handler is still protected by the protected call; so, an error inside the message handler will call the message handler again. If this loop goes on for too long, Lua breaks it and returns an appropriate message. (The message handler is called only for regular runtime errors. It is not called for memory-allocation errors nor for errors while running finalizers.)</source>
          <target state="translated">&lt;a href=&quot;#pdf-xpcall&quot;&gt; &lt;code&gt;xpcall&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#lua_pcall&quot;&gt; &lt;code&gt;lua_pcall&lt;/code&gt; &lt;/a&gt; 을 사용 하는 경우 오류 발생시 호출 될 &lt;em&gt;메시지 핸들러&lt;/em&gt; 를 제공 할 수 있습니다. 이 함수는 원래 오류 개체와 함께 호출되어 새 오류 개체를 반환합니다. 스택을 풀기 전에 호출되므로 스택을 검사하고 스택 트레이스 백을 생성하여 오류에 대한 자세한 정보를 수집 할 수 있습니다. 이 메시지 핸들러는 여전히 보호 된 호출에 의해 보호됩니다. 따라서 메시지 핸들러 내부의 오류는 메시지 핸들러를 다시 호출합니다. 이 루프가 너무 오래 지속되면 Lua는 루프를 끊고 적절한 메시지를 리턴합니다. (메시지 핸들러는 일반 런타임 오류에 대해서만 호출됩니다. 메모리 할당 오류나 종료자를 실행하는 동안에는 호출되지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="3d4a440a8a54cb67f8b148f43a2a234b9432ff21" translate="yes" xml:space="preserve">
          <source>Whenever Lua calls C, it ensures that the stack has space for at least &lt;a id=&quot;pdf-LUA_MINSTACK&quot;&gt;&lt;code&gt;LUA_MINSTACK&lt;/code&gt;&lt;/a&gt; extra elements; that is, you can safely push up to &lt;code&gt;LUA_MINSTACK&lt;/code&gt; values into it. &lt;code&gt;LUA_MINSTACK&lt;/code&gt; is defined as 20, so that usually you do not have to worry about stack space unless your code has loops pushing elements onto the stack.</source>
          <target state="translated">Lua가 C를 호출 할 때마다 스택에 최소한 &lt;a id=&quot;pdf-LUA_MINSTACK&quot;&gt; &lt;code&gt;LUA_MINSTACK&lt;/code&gt; &lt;/a&gt; 추가 요소를 위한 공간이 있는지 확인합니다 . 즉, &lt;code&gt;LUA_MINSTACK&lt;/code&gt; 값 까지 안전하게 푸시 할 수 있습니다 . &lt;code&gt;LUA_MINSTACK&lt;/code&gt; 은 20 으로 정의되어 있으므로 코드에 요소를 스택으로 푸시하는 루프가없는 한 일반적으로 스택 공간에 대해 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="15a645bbcf65be028c994caf05ae49cc42785d58" translate="yes" xml:space="preserve">
          <source>Whenever Lua calls C, it ensures that the stack has space for at least &lt;a id=&quot;pdf-LUA_MINSTACK&quot;&gt;&lt;code&gt;LUA_MINSTACK&lt;/code&gt;&lt;/a&gt; extra slots. &lt;code&gt;LUA_MINSTACK&lt;/code&gt; is defined as 20, so that usually you do not have to worry about stack space unless your code has loops pushing elements onto the stack.</source>
          <target state="translated">Lua가 C를 호출 할 때마다 스택에 최소 &lt;a id=&quot;pdf-LUA_MINSTACK&quot;&gt; &lt;code&gt;LUA_MINSTACK&lt;/code&gt; &lt;/a&gt; 추가 슬롯을 위한 공간이 확보됩니다 . &lt;code&gt;LUA_MINSTACK&lt;/code&gt; 은 20 으로 정의되므로 일반적으로 코드에 루프를 사용하여 요소를 스택으로 푸시하지 않는 한 스택 공간에 대해 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="bc36795858181bb669bdb65cc9b9976ecc560ce7" translate="yes" xml:space="preserve">
          <source>Whenever Lua calls C, the called function gets a new stack, which is independent of previous stacks and of stacks of C functions that are still active. This stack initially contains any arguments to the C function and it is where the C function can store temporary Lua values and must push its results to be returned to the caller (see &lt;a href=&quot;#lua_CFunction&quot;&gt;&lt;code&gt;lua_CFunction&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Lua가 C를 호출 할 때마다 호출 된 함수는 새 스택을 가져옵니다.이 스택은 이전 스택 및 여전히 활성 상태 인 C 함수의 스택과 독립적입니다. 이 스택은 처음에 C 함수에 대한 인수를 포함하며 C 함수가 임시 Lua 값을 저장할 수있는 위치이며 결과를 호출자에게 리턴하도록해야합니다 ( &lt;a href=&quot;#lua_CFunction&quot;&gt; &lt;code&gt;lua_CFunction&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="c2b43773a36392d35ca699c4fb17769ecd2dd7c2" translate="yes" xml:space="preserve">
          <source>Whenever a &lt;code&gt;__newindex&lt;/code&gt; metavalue is invoked, Lua does not perform the primitive assignment. If needed, the metamethod itself can call &lt;a href=&quot;#pdf-rawset&quot;&gt;&lt;code&gt;rawset&lt;/code&gt;&lt;/a&gt; to do the assignment.</source>
          <target state="translated">&lt;code&gt;__newindex&lt;/code&gt; 메타 값이 호출 될 때마다 Lua는 기본 할당을 수행하지 않습니다. 필요한 경우 메타 메서드 자체가 &lt;a href=&quot;#pdf-rawset&quot;&gt; &lt;code&gt;rawset&lt;/code&gt; &lt;/a&gt; 을 호출 하여 할당을 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0194275f7fed5a9af0589750161f145316d9d8f8" translate="yes" xml:space="preserve">
          <source>Whenever a C function is called, its upvalues are located at specific pseudo-indices. These pseudo-indices are produced by the macro &lt;a href=&quot;#lua_upvalueindex&quot;&gt;&lt;code&gt;lua_upvalueindex&lt;/code&gt;&lt;/a&gt;. The first upvalue associated with a function is at index &lt;code&gt;lua_upvalueindex(1)&lt;/code&gt;, and so on. Any access to &lt;code&gt;lua_upvalueindex(&lt;em&gt;n&lt;/em&gt;)&lt;/code&gt;, where &lt;em&gt;n&lt;/em&gt; is greater than the number of upvalues of the current function (but not greater than 256, which is one plus the maximum number of upvalues in a closure), produces an acceptable but invalid index.</source>
          <target state="translated">C 함수가 호출 될 때마다 그 업 값은 특정 의사 표시에 있습니다. 이러한 의사 표시는 &lt;a href=&quot;#lua_upvalueindex&quot;&gt; &lt;code&gt;lua_upvalueindex&lt;/code&gt; &lt;/a&gt; 매크로에 의해 생성됩니다 . 함수와 관련된 첫 번째 upvalue는 index &lt;code&gt;lua_upvalueindex(1)&lt;/code&gt; 등입니다. &lt;code&gt;lua_upvalueindex(&lt;em&gt;n&lt;/em&gt;)&lt;/code&gt; 대한 모든 액세스 ( 여기서 &lt;em&gt;n&lt;/em&gt; 은 현재 함수의 최대 값 수보다 크지 만 256보다 크지 않음 (클로저의 최대 최대 값 수에 1을 더한 값))는 수용 가능하지만 유효하지 않은 색인을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="7b599885fcde567666ae50c3832fa9901f1faa95" translate="yes" xml:space="preserve">
          <source>Whenever a hook is called, its &lt;code&gt;ar&lt;/code&gt; argument has its field &lt;code&gt;event&lt;/code&gt; set to the specific event that triggered the hook. Lua identifies these events with the following constants: &lt;a id=&quot;pdf-LUA_HOOKCALL&quot;&gt;&lt;code&gt;LUA_HOOKCALL&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_HOOKRET&quot;&gt;&lt;code&gt;LUA_HOOKRET&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_HOOKTAILCALL&quot;&gt;&lt;code&gt;LUA_HOOKTAILCALL&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_HOOKLINE&quot;&gt;&lt;code&gt;LUA_HOOKLINE&lt;/code&gt;&lt;/a&gt;, and &lt;a id=&quot;pdf-LUA_HOOKCOUNT&quot;&gt;&lt;code&gt;LUA_HOOKCOUNT&lt;/code&gt;&lt;/a&gt;. Moreover, for line events, the field &lt;code&gt;currentline&lt;/code&gt; is also set. To get the value of any other field in &lt;code&gt;ar&lt;/code&gt;, the hook must call &lt;a href=&quot;#lua_getinfo&quot;&gt;&lt;code&gt;lua_getinfo&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">후크가 호출 될 때마다 &lt;code&gt;ar&lt;/code&gt; 인수의 필드 &lt;code&gt;event&lt;/code&gt; 는 후크를 트리거 한 특정 이벤트로 설정됩니다. Lua는 &lt;a id=&quot;pdf-LUA_HOOKCALL&quot;&gt; &lt;code&gt;LUA_HOOKCALL&lt;/code&gt; &lt;/a&gt; , &lt;a id=&quot;pdf-LUA_HOOKRET&quot;&gt; &lt;code&gt;LUA_HOOKRET&lt;/code&gt; &lt;/a&gt; , &lt;a id=&quot;pdf-LUA_HOOKTAILCALL&quot;&gt; &lt;code&gt;LUA_HOOKTAILCALL&lt;/code&gt; &lt;/a&gt; , &lt;a id=&quot;pdf-LUA_HOOKLINE&quot;&gt; &lt;code&gt;LUA_HOOKLINE&lt;/code&gt; &lt;/a&gt; 및 &lt;a id=&quot;pdf-LUA_HOOKCOUNT&quot;&gt; &lt;code&gt;LUA_HOOKCOUNT&lt;/code&gt; &lt;/a&gt; 상수로 이러한 이벤트를 식별합니다 . 또한 회선 이벤트의 경우 필드 &lt;code&gt;currentline&lt;/code&gt; 도 설정됩니다. &lt;code&gt;ar&lt;/code&gt; 의 다른 필드 값을 얻으려면 후크가 &lt;a href=&quot;#lua_getinfo&quot;&gt; &lt;code&gt;lua_getinfo&lt;/code&gt; &lt;/a&gt; 를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="77a4ffdfeb7ea6979c398f6e32e8da8ff060ce91" translate="yes" xml:space="preserve">
          <source>Whenever there is a &lt;code&gt;__newindex&lt;/code&gt; metamethod, Lua does not perform the primitive assignment. (If necessary, the metamethod itself can call &lt;a href=&quot;#pdf-rawset&quot;&gt;&lt;code&gt;rawset&lt;/code&gt;&lt;/a&gt; to do the assignment.)</source>
          <target state="translated">&lt;code&gt;__newindex&lt;/code&gt; 메타 메서드 가있을 때마다 Lua는 기본 할당을 수행하지 않습니다. (필요한 경우 metamethod 자체는 &lt;a href=&quot;#pdf-rawset&quot;&gt; &lt;code&gt;rawset&lt;/code&gt; &lt;/a&gt; 을 호출 하여 할당을 수행 할 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="380018403674372e84fb15d5ec3167aa3cf9c5cb" translate="yes" xml:space="preserve">
          <source>Whenever there is an error, an &lt;em&gt;error object&lt;/em&gt; (also called an &lt;em&gt;error message&lt;/em&gt;) is propagated with information about the error. Lua itself only generates errors whose error object is a string, but programs may generate errors with any value as the error object. It is up to the Lua program or its host to handle such error objects.</source>
          <target state="translated">오류가있을 때마다 &lt;em&gt;오류 개체&lt;/em&gt; ( &lt;em&gt;오류 메시지&lt;/em&gt; 라고도 함)에 &lt;em&gt;오류&lt;/em&gt; 에 대한 정보가 전파됩니다. Lua 자체는 오류 개체가 문자열 인 오류 만 생성하지만 프로그램은 오류 개체로 모든 값의 오류를 생성 할 수 있습니다. 이러한 오류 개체를 처리하는 것은 Lua 프로그램 또는 호스트의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="846e0dd3b617fa3bf7db09630f23f0393a92f6a2" translate="yes" xml:space="preserve">
          <source>Whenever there is an error, an &lt;em&gt;error object&lt;/em&gt; is propagated with information about the error. Lua itself only generates errors whose error object is a string, but programs may generate errors with any value as the error object. It is up to the Lua program or its host to handle such error objects. For historical reasons, an error object is often called an &lt;em&gt;error message&lt;/em&gt;, even though it does not have to be a string.</source>
          <target state="translated">오류가있을 때마다 오류에 대한 정보와 함께 &lt;em&gt;오류 개체&lt;/em&gt; 가 전파됩니다. Lua 자체는 오류 개체가 문자열 인 오류 만 생성하지만 프로그램은 오류 개체로 모든 값을 사용하여 오류를 생성 할 수 있습니다. 이러한 오류 개체를 처리하는 것은 Lua 프로그램이나 호스트에 달려 있습니다. 역사적 이유로 오류 객체는 문자열이 아니어도되지만 종종 &lt;em&gt;오류 메시지&lt;/em&gt; 라고 합니다.</target>
        </trans-unit>
        <trans-unit id="272f9a8e241eb8a55a33970a98b804e3cbb2993b" translate="yes" xml:space="preserve">
          <source>While Lua is running a hook, it disables other calls to hooks. Therefore, if a hook calls back Lua to execute a function or a chunk, this execution occurs without any calls to hooks.</source>
          <target state="translated">Lua는 후크를 실행하는 동안 다른 후크 호출을 비활성화합니다. 따라서 후크가 함수 또는 청크를 실행하기 위해 Lua를 콜백하는 경우 후크 실행없이이 실행이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c55926fa7030f56d817d54fc38fc120f3c9f44c9" translate="yes" xml:space="preserve">
          <source>While traversing a table, avoid calling &lt;a href=&quot;#lua_tolstring&quot;&gt;&lt;code&gt;lua_tolstring&lt;/code&gt;&lt;/a&gt; directly on a key, unless you know that the key is actually a string. Recall that &lt;a href=&quot;#lua_tolstring&quot;&gt;&lt;code&gt;lua_tolstring&lt;/code&gt;&lt;/a&gt; may change the value at the given index; this confuses the next call to &lt;a href=&quot;#lua_next&quot;&gt;&lt;code&gt;lua_next&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">테이블을 순회하는 동안 키가 실제로 문자열이라는 것을 알지 않는 한 키에서 직접 &lt;a href=&quot;#lua_tolstring&quot;&gt; &lt;code&gt;lua_tolstring&lt;/code&gt; 을&lt;/a&gt; 호출하지 마십시오 . 리콜 &lt;a href=&quot;#lua_tolstring&quot;&gt; &lt;code&gt;lua_tolstring&lt;/code&gt; 가&lt;/a&gt; 지정된 인덱스 값을 변경할 수있다; 이것은 &lt;a href=&quot;#lua_next&quot;&gt; &lt;code&gt;lua_next&lt;/code&gt; 에&lt;/a&gt; 대한 다음 호출을 혼동합니다 .</target>
        </trans-unit>
        <trans-unit id="768488e627b06a1ccd84c86d3762c984059da019" translate="yes" xml:space="preserve">
          <source>While traversing a table, do not call &lt;a href=&quot;#lua_tolstring&quot;&gt;&lt;code&gt;lua_tolstring&lt;/code&gt;&lt;/a&gt; directly on a key, unless you know that the key is actually a string. Recall that &lt;a href=&quot;#lua_tolstring&quot;&gt;&lt;code&gt;lua_tolstring&lt;/code&gt;&lt;/a&gt; may change the value at the given index; this confuses the next call to &lt;a href=&quot;#lua_next&quot;&gt;&lt;code&gt;lua_next&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">테이블을 순회하는 동안 키가 실제로 문자열이라는 것을 모르면 키에서 직접 &lt;a href=&quot;#lua_tolstring&quot;&gt; &lt;code&gt;lua_tolstring&lt;/code&gt; 을&lt;/a&gt; 호출하지 마십시오 . 리콜 &lt;a href=&quot;#lua_tolstring&quot;&gt; &lt;code&gt;lua_tolstring&lt;/code&gt; 가&lt;/a&gt; 지정된 인덱스 값을 변경할 수있다; 이것은 &lt;a href=&quot;#lua_next&quot;&gt; &lt;code&gt;lua_next&lt;/code&gt; 에&lt;/a&gt; 대한 다음 호출을 혼란스럽게합니다 .</target>
        </trans-unit>
        <trans-unit id="518506b1bd272cc87115a976ea99ba83864b9064" translate="yes" xml:space="preserve">
          <source>With the exception of exponentiation and float division, the arithmetic operators work as follows: If both operands are integers, the operation is performed over integers and the result is an integer. Otherwise, if both operands are numbers or strings that can be converted to numbers (see &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3&lt;/a&gt;), then they are converted to floats, the operation is performed following the usual rules for floating-point arithmetic (usually the IEEE 754 standard), and the result is a float.</source>
          <target state="translated">지수화와 부동 소수점 나누기를 제외하고 산술 연산자는 다음과 같이 작동합니다. 두 피연산자가 모두 정수이면 연산이 정수에 대해 수행되고 결과는 정수입니다. 그렇지 않으면 두 피연산자가 모두 숫자 또는 숫자로 변환 할 수있는 문자열 인 경우 ( &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3&lt;/a&gt; 참조 ) 부동 소수점으로 변환되면, 부동 소수점 산술에 대한 일반적인 규칙 (일반적으로 IEEE 754 표준)에 따라 작업이 수행됩니다. 결과는 float입니다.</target>
        </trans-unit>
        <trans-unit id="6d94057967a72a5d81edd6ae24d02d66cf0d57ab" translate="yes" xml:space="preserve">
          <source>With the exception of exponentiation and float division, the arithmetic operators work as follows: If both operands are integers, the operation is performed over integers and the result is an integer. Otherwise, if both operands are numbers, then they are converted to floats, the operation is performed following the machine's rules for floating-point arithmetic (usually the IEEE 754 standard), and the result is a float. (The string library coerces strings to numbers in arithmetic operations; see &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3&lt;/a&gt; for details.)</source>
          <target state="translated">지수 및 부동 나누기를 제외하고 산술 연산자는 다음과 같이 작동합니다. 두 피연산자가 정수이면 연산이 정수에 대해 수행되고 결과는 정수입니다. 그렇지 않으면 두 피연산자가 모두 숫자이면 부동 소수점으로 변환되고 부동 소수점 산술 (일반적으로 IEEE 754 표준)에 대한 기계의 규칙에 따라 연산이 수행되며 결과는 부동 소수점입니다. (문자열 라이브러리는 산술 연산에서 문자열을 숫자로 강제 변환합니다. 자세한 내용은 &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3&lt;/a&gt; 을 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="ef23cb793be6d01c5592ed37d41262accad311cc" translate="yes" xml:space="preserve">
          <source>Writes the value of each of its arguments to &lt;code&gt;file&lt;/code&gt;. The arguments must be strings or numbers.</source>
          <target state="translated">각 인수의 값을 &lt;code&gt;file&lt;/code&gt; 에 씁니다 . 인수는 문자열 또는 숫자 여야합니다.</target>
        </trans-unit>
        <trans-unit id="4b2eb6ac09b984e213b2d26d7367f553447ec91c" translate="yes" xml:space="preserve">
          <source>Yields a coroutine (thread).</source>
          <target state="translated">코 루틴 (스레드)을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="4c14ae77965a71399e48d53e02bcb286bb93f6f2" translate="yes" xml:space="preserve">
          <source>You can also create and manipulate coroutines through the C API: see functions &lt;a href=&quot;#lua_newthread&quot;&gt;&lt;code&gt;lua_newthread&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#lua_resume&quot;&gt;&lt;code&gt;lua_resume&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#lua_yield&quot;&gt;&lt;code&gt;lua_yield&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">C API를 통해 코 루틴을 생성하고 조작 할 수도 있습니다 ( &lt;a href=&quot;#lua_newthread&quot;&gt; &lt;code&gt;lua_newthread&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#lua_resume&quot;&gt; &lt;code&gt;lua_resume&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#lua_yield&quot;&gt; &lt;code&gt;lua_yield&lt;/code&gt; &lt;/a&gt; 함수 참조) .</target>
        </trans-unit>
        <trans-unit id="cf65c06d67b704766199b9121e3b29a033e4c3cc" translate="yes" xml:space="preserve">
          <source>You can avoid some incompatibilities by compiling Lua with appropriate options (see file &lt;code&gt;luaconf.h&lt;/code&gt;). However, all these compatibility options will be removed in the future. More often than not, compatibility issues arise when these compatibility options are removed. So, whenever you have the chance, you should try to test your code with a version of Lua compiled with all compatibility options turned off. That will ease transitions to newer versions of Lua.</source>
          <target state="translated">적절한 옵션으로 Lua를 컴파일하면 일부 비 호환성을 피할 수 있습니다 ( &lt;code&gt;luaconf.h&lt;/code&gt; 파일 참조 ). 그러나 이러한 모든 호환성 옵션은 향후 제거 될 예정입니다. 종종 이러한 호환성 옵션을 제거하면 호환성 문제가 발생합니다. 따라서 기회가있을 때마다 모든 호환성 옵션을 끄고 컴파일 된 Lua 버전으로 코드를 테스트해야합니다. 그러면 최신 버전의 Lua로 쉽게 전환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="88e17dda44cc7b49c20312b1b3f6c3280740896b" translate="yes" xml:space="preserve">
          <source>You can call functions only in threads with status &lt;a href=&quot;#pdf-LUA_OK&quot;&gt;&lt;code&gt;LUA_OK&lt;/code&gt;&lt;/a&gt;. You can resume threads with status &lt;a href=&quot;#pdf-LUA_OK&quot;&gt;&lt;code&gt;LUA_OK&lt;/code&gt;&lt;/a&gt; (to start a new coroutine) or &lt;a href=&quot;#pdf-LUA_YIELD&quot;&gt;&lt;code&gt;LUA_YIELD&lt;/code&gt;&lt;/a&gt; (to resume a coroutine).</source>
          <target state="translated">상태가 &lt;a href=&quot;#pdf-LUA_OK&quot;&gt; &lt;code&gt;LUA_OK&lt;/code&gt; 인&lt;/a&gt; 스레드에서만 함수를 호출 할 수 있습니다 . 상태가 &lt;a href=&quot;#pdf-LUA_OK&quot;&gt; &lt;code&gt;LUA_OK&lt;/code&gt; &lt;/a&gt; (새 코 루틴 시작) 또는 &lt;a href=&quot;#pdf-LUA_YIELD&quot;&gt; &lt;code&gt;LUA_YIELD&lt;/code&gt; &lt;/a&gt; ( 코 루틴 재개) 인 스레드를 다시 시작할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="30acf487d4f39b1b32392092243899e125648aac" translate="yes" xml:space="preserve">
          <source>You can change the GC mode and parameters by calling &lt;a href=&quot;#lua_gc&quot;&gt;&lt;code&gt;lua_gc&lt;/code&gt;&lt;/a&gt; in C or &lt;a href=&quot;#pdf-collectgarbage&quot;&gt;&lt;code&gt;collectgarbage&lt;/code&gt;&lt;/a&gt; in Lua. You can also use these functions to control the collector directly (e.g., to stop and restart it).</source>
          <target state="translated">C에서 &lt;a href=&quot;#lua_gc&quot;&gt; &lt;code&gt;lua_gc&lt;/code&gt; &lt;/a&gt; 를 호출 하거나 Lua에서 &lt;a href=&quot;#pdf-collectgarbage&quot;&gt; &lt;code&gt;collectgarbage&lt;/code&gt; &lt;/a&gt; 를 호출하여 GC 모드 및 매개 변수를 변경할 수 있습니다 . 이러한 기능을 사용하여 수집기를 직접 제어 할 수도 있습니다 (예 : 중지 및 다시 시작).</target>
        </trans-unit>
        <trans-unit id="b7319a84c3be9c603d878df474f45dfa44f88afd" translate="yes" xml:space="preserve">
          <source>You can change the way that Lua compares tables and userdata by using the &quot;eq&quot; metamethod (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;).</source>
          <target state="translated">&quot;eq&quot;메타 메소드를 사용하여 Lua가 테이블과 사용자 데이터를 비교하는 방식을 변경할 수 있습니다 ( &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="bfd38a5c874f3757df856f2f0fe3488def075bb2" translate="yes" xml:space="preserve">
          <source>You can change the way that Lua compares tables and userdata by using the &lt;code&gt;__eq&lt;/code&gt; metamethod (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;__eq&lt;/code&gt; 메타 메서드 를 사용하여 Lua가 테이블과 사용자 데이터를 비교하는 방식을 변경할 수 있습니다 ( &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="3102901d0caee19c958fcee9d58ed56ee554d4f9" translate="yes" xml:space="preserve">
          <source>You can change these numbers by calling &lt;a href=&quot;#lua_gc&quot;&gt;&lt;code&gt;lua_gc&lt;/code&gt;&lt;/a&gt; in C or &lt;a href=&quot;#pdf-collectgarbage&quot;&gt;&lt;code&gt;collectgarbage&lt;/code&gt;&lt;/a&gt; in Lua. You can also use these functions to control the collector directly (e.g., stop and restart it).</source>
          <target state="translated">C에서 &lt;a href=&quot;#lua_gc&quot;&gt; &lt;code&gt;lua_gc&lt;/code&gt; &lt;/a&gt; 를 호출 하거나 Lua에서 &lt;a href=&quot;#pdf-collectgarbage&quot;&gt; &lt;code&gt;collectgarbage&lt;/code&gt; &lt;/a&gt; 를 호출 하여이 숫자를 변경할 수 있습니다 . 이 기능을 사용하여 수집기를 직접 제어 할 수도 있습니다 (예 : 중지 및 재시작).</target>
        </trans-unit>
        <trans-unit id="1aa1c0455b97a9145781995effbd7a91d175f4dd" translate="yes" xml:space="preserve">
          <source>You can fix these differences by forcing a number to be a float (in Lua 5.2 all numbers were float), in particular writing constants with an ending &lt;code&gt;.0&lt;/code&gt; or using &lt;code&gt;x = x + 0.0&lt;/code&gt; to convert a variable. (This recommendation is only for a quick fix for an occasional incompatibility; it is not a general guideline for good programming. For good programming, use floats where you need floats and integers where you need integers.)</source>
          <target state="translated">당신은 끝으로, 특히 쓰기 상수 (루아 5.2에서 모든 숫자가 부동이었다) 부동 소수점이 될 수있는 수를 강제로 이러한 차이를 해결할 수 있습니다 &lt;code&gt;.0&lt;/code&gt; 또는 사용하여 &lt;code&gt;x = x + 0.0&lt;/code&gt; 변수를 변환 할 수 있습니다. (이 권장 사항은 가끔 호환되지 않는 문제를 신속하게 해결하기위한 것입니다. 좋은 프로그래밍을위한 일반적인 지침은 아닙니다. 좋은 프로그래밍을 위해서는 float가 필요한 곳에 float를, 정수가 필요한 곳에 integer를 사용하십시오.)</target>
        </trans-unit>
        <trans-unit id="6b9f9c8aada12f19e8959797fbd200469c989aaf" translate="yes" xml:space="preserve">
          <source>You can only call functions in threads with status &lt;a href=&quot;#pdf-LUA_OK&quot;&gt;&lt;code&gt;LUA_OK&lt;/code&gt;&lt;/a&gt;. You can resume threads with status &lt;a href=&quot;#pdf-LUA_OK&quot;&gt;&lt;code&gt;LUA_OK&lt;/code&gt;&lt;/a&gt; (to start a new coroutine) or &lt;a href=&quot;#pdf-LUA_YIELD&quot;&gt;&lt;code&gt;LUA_YIELD&lt;/code&gt;&lt;/a&gt; (to resume a coroutine).</source>
          <target state="translated">상태가 &lt;a href=&quot;#pdf-LUA_OK&quot;&gt; &lt;code&gt;LUA_OK&lt;/code&gt; 인&lt;/a&gt; 스레드에서만 함수를 호출 할 수 있습니다 . &lt;a href=&quot;#pdf-LUA_OK&quot;&gt; &lt;code&gt;LUA_OK&lt;/code&gt; &lt;/a&gt; (새 코 루틴을 시작하기 위해) 또는 &lt;a href=&quot;#pdf-LUA_YIELD&quot;&gt; &lt;code&gt;LUA_YIELD&lt;/code&gt; &lt;/a&gt; (코 루틴을 다시 시작하기 위해 ) 상태로 스레드를 재개 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="59f7d5bf15872a3901218a87816b69752280c691" translate="yes" xml:space="preserve">
          <source>You can put a closing square bracket in a set by positioning it as the first character in the set. You can put a hyphen in a set by positioning it as the first or the last character in the set. (You can also use an escape for both cases.)</source>
          <target state="translated">집합의 첫 번째 문자로 배치하여 닫는 대괄호를 집합에 넣을 수 있습니다. 하이픈을 세트의 첫 번째 또는 마지막 문자로 배치하여 세트에 넣을 수 있습니다. (두 경우 모두 이스케이프를 사용할 수도 있습니다.)</target>
        </trans-unit>
        <trans-unit id="8061a68da1d074d2f5c5e92636b71ce2c9bfb53d" translate="yes" xml:space="preserve">
          <source>You can put a closing square bracket in a set by positioning it as the first character in the set. You can put an hyphen in a set by positioning it as the first or the last character in the set. (You can also use an escape for both cases.)</source>
          <target state="translated">세트에서 첫 번째 문자로 배치하여 닫는 대괄호를 세트에 넣을 수 있습니다. 세트에서 첫 번째 또는 마지막 문자로 하이픈을 배치하여 세트에 하이픈을 넣을 수 있습니다. 두 경우 모두 이스케이프를 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="799d3c0c986643b2fb7ee878e60672115c276c33" translate="yes" xml:space="preserve">
          <source>You can query the metatable of any value using the &lt;a href=&quot;#pdf-getmetatable&quot;&gt;&lt;code&gt;getmetatable&lt;/code&gt;&lt;/a&gt; function. Lua queries metamethods in metatables using a raw access (see &lt;a href=&quot;#pdf-rawget&quot;&gt;&lt;code&gt;rawget&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;#pdf-getmetatable&quot;&gt; &lt;code&gt;getmetatable&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 모든 값의 메타 테이블을 쿼리 할 수 ​​있습니다 . Lua는 원시 액세스를 사용하여 메타 테이블의 메타 메서드를 쿼리합니다 ( &lt;a href=&quot;#pdf-rawget&quot;&gt; &lt;code&gt;rawget&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="d2781e61b519fd47b1d4f450639555b1c01907b6" translate="yes" xml:space="preserve">
          <source>You can query the metatable of any value using the &lt;a href=&quot;#pdf-getmetatable&quot;&gt;&lt;code&gt;getmetatable&lt;/code&gt;&lt;/a&gt; function. Lua queries metamethods in metatables using a raw access (see &lt;a href=&quot;#pdf-rawget&quot;&gt;&lt;code&gt;rawget&lt;/code&gt;&lt;/a&gt;). So, to retrieve the metamethod for event &lt;code&gt;ev&lt;/code&gt; in object &lt;code&gt;o&lt;/code&gt;, Lua does the equivalent to the following code:</source>
          <target state="translated">&lt;a href=&quot;#pdf-getmetatable&quot;&gt; &lt;code&gt;getmetatable&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 모든 값의 메타 테이블을 쿼리 할 수 ​​있습니다 . Lua는 원시 액세스를 사용하여 메타 테이블에서 메타 메서드를 쿼리합니다 ( &lt;a href=&quot;#pdf-rawget&quot;&gt; &lt;code&gt;rawget&lt;/code&gt; &lt;/a&gt; 참조 ). 따라서 객체 &lt;code&gt;o&lt;/code&gt; 에서 이벤트 &lt;code&gt;ev&lt;/code&gt; 에 대한 메타 메소드를 검색하기 위해 Lua는 다음 코드와 동일한 기능을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="d1dc46c8e9720bcf85f3abea3ac1cb55affdcb0d" translate="yes" xml:space="preserve">
          <source>You can replace the metatable of tables using the &lt;a href=&quot;#pdf-setmetatable&quot;&gt;&lt;code&gt;setmetatable&lt;/code&gt;&lt;/a&gt; function. You cannot change the metatable of other types from Lua code (except by using the debug library (&lt;a href=&quot;#6.10&quot;&gt;&amp;sect;6.10&lt;/a&gt;)); you should use the C API for that.</source>
          <target state="translated">&lt;a href=&quot;#pdf-setmetatable&quot;&gt; &lt;code&gt;setmetatable&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 테이블의 메타 테이블을 바꿀 수 있습니다 . Lua 코드에서 다른 유형의 메타 테이블을 변경할 수 없습니다 (디버그 라이브러리 ( &lt;a href=&quot;#6.10&quot;&gt;&amp;sect;6.10&lt;/a&gt; ) 사용 제외 ). 이를 위해 C API를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="71035c95301acc8c192b359af22e6b3657788623" translate="yes" xml:space="preserve">
          <source>You can replace the metatable of tables using the &lt;a href=&quot;#pdf-setmetatable&quot;&gt;&lt;code&gt;setmetatable&lt;/code&gt;&lt;/a&gt; function. You cannot change the metatable of other types from Lua code, except by using the debug library (&lt;a href=&quot;#6.10&quot;&gt;&amp;sect;6.10&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;#pdf-setmetatable&quot;&gt; &lt;code&gt;setmetatable&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 테이블의 메타 테이블을 바꿀 수 있습니다 . 디버그 라이브러리 ( &lt;a href=&quot;#6.10&quot;&gt;&amp;sect;6.10&lt;/a&gt; )를 사용하는 경우를 제외하고는 Lua 코드에서 다른 유형의 메타 테이블을 변경할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="7e58a48a2bbf52e5804761968441fe7ea238d5cc" translate="yes" xml:space="preserve">
          <source>You can set garbage-collector metamethods for tables and, using the C API, for full userdata (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;). These metamethods are also called &lt;em&gt;finalizers&lt;/em&gt;. Finalizers allow you to coordinate Lua's garbage collection with external resource management (such as closing files, network or database connections, or freeing your own memory).</source>
          <target state="translated">테이블 및 C API를 사용하여 전체 사용자 데이터에 대해 가비지 수집기 메타 메서드를 설정할 수 있습니다 ( &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt; 참조 ). 이러한 메타 메소드는 &lt;em&gt;파이널 라이저&lt;/em&gt; 라고도 합니다. Finalizer를 사용하면 외부 리소스 관리 (예 : 파일 닫기, 네트워크 또는 데이터베이스 연결 또는 자체 메모리 확보)와 함께 Lua의 가비지 수집을 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bda59ef5aaee54d3f7530ea5520d18e9906d209b" translate="yes" xml:space="preserve">
          <source>You can set garbage-collector metamethods for tables and, using the C API, for full userdata (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;). These metamethods, called &lt;em&gt;finalizers&lt;/em&gt;, are called when the garbage collector detects that the corresponding table or userdata is dead. Finalizers allow you to coordinate Lua's garbage collection with external resource management such as closing files, network or database connections, or freeing your own memory.</source>
          <target state="translated">테이블 및 C API를 사용하여 전체 사용자 데이터에 대해 가비지 수집기 메타 메서드를 설정할 수 있습니다 ( &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt; 참조 ). 이러한 메타 메소드가 호출 &lt;em&gt;종료 자들은&lt;/em&gt; 가비지 수집기가 대응하는 테이블 또는 유저 데이터가 죽었을 감지하면, 불린다. 파이널 라이저를 사용하면 파일 닫기, 네트워크 또는 데이터베이스 연결 또는 자체 메모리 해제와 같은 외부 리소스 관리와 함께 Lua의 가비지 수집을 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af1a4e1dd00034824534614f2bda7911ae8431cd" translate="yes" xml:space="preserve">
          <source>You can use &lt;b&gt;break&lt;/b&gt; and &lt;b&gt;goto&lt;/b&gt; to exit a &lt;b&gt;for&lt;/b&gt; loop.</source>
          <target state="translated">&lt;b&gt;break&lt;/b&gt; 및 &lt;b&gt;goto&lt;/b&gt; 를 사용 하여 &lt;b&gt;for&lt;/b&gt; 루프 를 종료 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b27cc8080576c27c1dd2a0afb3a34a7a52ff85b8" translate="yes" xml:space="preserve">
          <source>You can use &lt;b&gt;break&lt;/b&gt; to exit a &lt;b&gt;for&lt;/b&gt; loop.</source>
          <target state="translated">&lt;b&gt;break&lt;/b&gt; 를 사용 하여 &lt;b&gt;for&lt;/b&gt; 루프 를 종료 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d52df43ef083f76a03d8e01f3e9a36da3fc66f0d" translate="yes" xml:space="preserve">
          <source>You create a coroutine by calling &lt;a href=&quot;#pdf-coroutine.create&quot;&gt;&lt;code&gt;coroutine.create&lt;/code&gt;&lt;/a&gt;. Its sole argument is a function that is the main function of the coroutine. The &lt;code&gt;create&lt;/code&gt; function only creates a new coroutine and returns a handle to it (an object of type &lt;em&gt;thread&lt;/em&gt;); it does not start the coroutine.</source>
          <target state="translated">당신은 호출하여 코 루틴을 만들 &lt;a href=&quot;#pdf-coroutine.create&quot;&gt; &lt;code&gt;coroutine.create&lt;/code&gt; 을&lt;/a&gt; . 유일한 주장은 코 루틴의 주요 기능인 기능입니다. &lt;code&gt;create&lt;/code&gt; 기능은 새로운 코 루틴을 생성하고 (유형의 객체에 대한 핸들 반환 &lt;em&gt;스레드&lt;/em&gt; ); 코 루틴을 시작하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5ef445026cd0a146e81e995bc4681bfd5e57e5c5" translate="yes" xml:space="preserve">
          <source>You do not have to allocate space for the result: the result is a Lua string and Lua takes care of memory allocation (and deallocation, through garbage collection).</source>
          <target state="translated">결과를위한 공간을 할당 할 필요는 없습니다. 결과는 Lua 문자열이며 Lua는 메모리 할당 (및 가비지 수집을 통한 할당 해제)을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="76e561e2abeb8c3fca97fd50eca052b57e9c65f8" translate="yes" xml:space="preserve">
          <source>You execute a coroutine by calling &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt;&lt;code&gt;coroutine.resume&lt;/code&gt;&lt;/a&gt;. When you first call &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt;&lt;code&gt;coroutine.resume&lt;/code&gt;&lt;/a&gt;, passing as its first argument a thread returned by &lt;a href=&quot;#pdf-coroutine.create&quot;&gt;&lt;code&gt;coroutine.create&lt;/code&gt;&lt;/a&gt;, the coroutine starts its execution by calling its main function. Extra arguments passed to &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt;&lt;code&gt;coroutine.resume&lt;/code&gt;&lt;/a&gt; are passed as arguments to that function. After the coroutine starts running, it runs until it terminates or &lt;em&gt;yields&lt;/em&gt;.</source>
          <target state="translated">당신은 호출하여 코 루틴을 실행 &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt; &lt;code&gt;coroutine.resume&lt;/code&gt; 을&lt;/a&gt; . 처음 호출 할 때 &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt; &lt;code&gt;coroutine.resume&lt;/code&gt; 을&lt;/a&gt; , 첫 번째 인자에 의해 반환 된 스레드로 전달 &lt;a href=&quot;#pdf-coroutine.create&quot;&gt; &lt;code&gt;coroutine.create&lt;/code&gt; &lt;/a&gt; , 코 루틴은 메인 함수를 호출하여 실행을 시작합니다. &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt; &lt;code&gt;coroutine.resume&lt;/code&gt; &lt;/a&gt; 에 전달 된 추가 인수는 해당 함수에 대한 인수로 전달됩니다. 코 루틴이 시작이 실행 한 후에는 종료 때까지 또는, 그것은 실행 &lt;em&gt;수익률&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="9517d537bb2cc69695684dbed19e521703190b55" translate="yes" xml:space="preserve">
          <source>You should not change the value of the control variable during the loop.</source>
          <target state="translated">루프 중에 제어 변수의 값을 변경해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="beb90315d79ba8436d83c1621548dc0828a068ab" translate="yes" xml:space="preserve">
          <source>You should not change the value of the control variable during the loop. If you need its value after the loop, assign it to another variable before exiting the loop.</source>
          <target state="translated">루프 중에 제어 변수의 값을 변경해서는 안됩니다. 루프 후에 값이 필요하면 루프를 종료하기 전에 다른 변수에 할당하십시오.</target>
        </trans-unit>
        <trans-unit id="f53454c1d52c8e8625f900a3b2f28a52f9ab6262" translate="yes" xml:space="preserve">
          <source>_G</source>
          <target state="translated">_G</target>
        </trans-unit>
        <trans-unit id="2f7691c85ede2ffb322e774a60315181bf799f71" translate="yes" xml:space="preserve">
          <source>_VERSION</source>
          <target state="translated">_VERSION</target>
        </trans-unit>
        <trans-unit id="d361be99d87b0fd1757850b39df6dc818e066eec" translate="yes" xml:space="preserve">
          <source>a single character class followed by '&lt;code&gt;*&lt;/code&gt;', which matches sequences of zero or more characters in the class. These repetition items will always match the longest possible sequence;</source>
          <target state="translated">클래스 에서 0 개 이상의 문자 시퀀스와 일치 하는 ' &lt;code&gt;*&lt;/code&gt; '가 뒤에 오는 단일 문자 클래스. 이러한 반복 항목은 항상 가능한 가장 긴 시퀀스와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="88f22daca599d25013aaf6d4c6cefa12b839e072" translate="yes" xml:space="preserve">
          <source>a single character class followed by '&lt;code&gt;*&lt;/code&gt;', which matches zero or more repetitions of characters in the class. These repetition items will always match the longest possible sequence;</source>
          <target state="translated">단일 문자 클래스 다음에 ' &lt;code&gt;*&lt;/code&gt; '가옵니다. 이는 클래스에서 0 개 이상의 문자 반복과 일치합니다. 이 반복 항목은 항상 가장 긴 시퀀스와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="9f3711be8dd7bfb74572554b6c7626ae533f6527" translate="yes" xml:space="preserve">
          <source>a single character class followed by '&lt;code&gt;+&lt;/code&gt;', which matches one or more repetitions of characters in the class. These repetition items will always match the longest possible sequence;</source>
          <target state="translated">단일 문자 클래스 다음에 ' &lt;code&gt;+&lt;/code&gt; '가옵니다. 이는 클래스에서 하나 이상의 문자 반복과 일치합니다. 이 반복 항목은 항상 가장 긴 시퀀스와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="bc94c739274a89a02c004f804c812de321b43960" translate="yes" xml:space="preserve">
          <source>a single character class followed by '&lt;code&gt;+&lt;/code&gt;', which matches sequences of one or more characters in the class. These repetition items will always match the longest possible sequence;</source>
          <target state="translated">클래스 에있는 하나 이상의 문자 시퀀스와 일치 하는 ' &lt;code&gt;+&lt;/code&gt; '가 뒤에 오는 단일 문자 클래스. 이러한 반복 항목은 항상 가능한 가장 긴 시퀀스와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="bc742d84c8f95089303b3c1235798dad7894c243" translate="yes" xml:space="preserve">
          <source>a single character class followed by '&lt;code&gt;-&lt;/code&gt;', which also matches sequences of zero or more characters in the class. Unlike '&lt;code&gt;*&lt;/code&gt;', these repetition items will always match the shortest possible sequence;</source>
          <target state="translated">단일 문자 클래스 뒤에 ' &lt;code&gt;-&lt;/code&gt; '가옵니다. 이는 클래스에있는 0 개 이상의 문자 시퀀스와도 일치합니다. ' &lt;code&gt;*&lt;/code&gt; ' 와 달리 이러한 반복 항목은 항상 가능한 가장 짧은 시퀀스와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="7c2c202847f17af45741edd719e4addc76505a81" translate="yes" xml:space="preserve">
          <source>a single character class followed by '&lt;code&gt;-&lt;/code&gt;', which also matches zero or more repetitions of characters in the class. Unlike '&lt;code&gt;*&lt;/code&gt;', these repetition items will always match the shortest possible sequence;</source>
          <target state="translated">단일 문자 클래스 뒤에 ' &lt;code&gt;-&lt;/code&gt; '가 오며, 이는 클래스에서 0 개 이상의 문자 반복과도 일치합니다. ' &lt;code&gt;*&lt;/code&gt; ' 와 달리이 반복 항목은 항상 가장 짧은 시퀀스와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="237b908d85fd5486211190c63284fa599c924a55" translate="yes" xml:space="preserve">
          <source>a single character class followed by '&lt;code&gt;?&lt;/code&gt;', which matches zero or one occurrence of a character in the class. It always matches one occurrence if possible;</source>
          <target state="translated">단일 문자 클래스 다음에 ' &lt;code&gt;?&lt;/code&gt; 클래스에서 0 또는 1 개의 문자 발생과 일치합니다. 가능하면 항상 한 번만 일치합니다.</target>
        </trans-unit>
        <trans-unit id="0c5e2141926ba6afbd01b9f0df61d70a7c93f57e" translate="yes" xml:space="preserve">
          <source>a single character class, which matches any single character in the class;</source>
          <target state="translated">클래스의 단일 문자와 일치하는 단일 문자 클래스;</target>
        </trans-unit>
        <trans-unit id="63ae10d79f4a0c4781e4e9b2dacd5c9896a57556" translate="yes" xml:space="preserve">
          <source>assert()</source>
          <target state="translated">assert()</target>
        </trans-unit>
        <trans-unit id="d9b7850ae45b39d5960b24328cbe68f8d5986e4d" translate="yes" xml:space="preserve">
          <source>basic UTF-8 support (&lt;a href=&quot;#6.5&quot;&gt;&amp;sect;6.5&lt;/a&gt;);</source>
          <target state="translated">기본 UTF-8 지원 ( &lt;a href=&quot;#6.5&quot;&gt;&amp;sect;6.5&lt;/a&gt; );</target>
        </trans-unit>
        <trans-unit id="fefa5c394d291465c545b09029d833606f910bf8" translate="yes" xml:space="preserve">
          <source>basic library (&lt;a href=&quot;#6.1&quot;&gt;&amp;sect;6.1&lt;/a&gt;);</source>
          <target state="translated">기본 라이브러리 ( &lt;a href=&quot;#6.1&quot;&gt;&amp;sect;6.1&lt;/a&gt; );</target>
        </trans-unit>
        <trans-unit id="74dcaf5215a85f0f3fdfba06d8dc2140d162bce8" translate="yes" xml:space="preserve">
          <source>by Roberto Ierusalimschy, Luiz Henrique de Figueiredo, Waldemar Celes</source>
          <target state="translated">작성자 : Roberto Ierusalimschy, Luiz Henrique de Figueiredo, Waldemar Celes</target>
        </trans-unit>
        <trans-unit id="85f91b3e97f2cf4928f588f868b5b56e41f46ac7" translate="yes" xml:space="preserve">
          <source>can be used to call &quot;methods&quot;. A call &lt;code&gt;v:name(&lt;em&gt;args&lt;/em&gt;)&lt;/code&gt; is syntactic sugar for &lt;code&gt;v.name(v,&lt;em&gt;args&lt;/em&gt;)&lt;/code&gt;, except that &lt;code&gt;v&lt;/code&gt; is evaluated only once.</source>
          <target state="translated">&quot;방법&quot;을 호출하는 데 사용할 수 있습니다. &lt;code&gt;v:name(&lt;em&gt;args&lt;/em&gt;)&lt;/code&gt; 호출 은 &lt;code&gt;v&lt;/code&gt; 가 한 번만 평가 된다는 점을 제외하고 &lt;code&gt;v.name(v,&lt;em&gt;args&lt;/em&gt;)&lt;/code&gt; 구문 설탕입니다 .</target>
        </trans-unit>
        <trans-unit id="6d633e66cce93e82c599b2ed94b6975cd1983c8d" translate="yes" xml:space="preserve">
          <source>can be used to emulate methods. A call &lt;code&gt;v:name(&lt;em&gt;args&lt;/em&gt;)&lt;/code&gt; is syntactic sugar for &lt;code&gt;v.name(v,&lt;em&gt;args&lt;/em&gt;)&lt;/code&gt;, except that &lt;code&gt;v&lt;/code&gt; is evaluated only once.</source>
          <target state="translated">메서드를 에뮬레이트하는 데 사용할 수 있습니다. &lt;code&gt;v:name(&lt;em&gt;args&lt;/em&gt;)&lt;/code&gt; 호출 은 &lt;code&gt;v&lt;/code&gt; 가 한 번만 평가 된다는 점을 제외하고 &lt;code&gt;v.name(v,&lt;em&gt;args&lt;/em&gt;)&lt;/code&gt; 구문 설탕입니다 .</target>
        </trans-unit>
        <trans-unit id="db3586e1e0bcc962d7bc2f3fead617414fb7e605" translate="yes" xml:space="preserve">
          <source>collectgarbage()</source>
          <target state="translated">collectgarbage()</target>
        </trans-unit>
        <trans-unit id="2d524624e9fa583630d5fa0595340fdebfe37ef7" translate="yes" xml:space="preserve">
          <source>coroutine library (&lt;a href=&quot;#6.2&quot;&gt;&amp;sect;6.2&lt;/a&gt;);</source>
          <target state="translated">코 루틴 라이브러리 ( &lt;a href=&quot;#6.2&quot;&gt;&amp;sect;6.2&lt;/a&gt; );</target>
        </trans-unit>
        <trans-unit id="eae27926b30edc4437a198e2711147c99c5e7fbe" translate="yes" xml:space="preserve">
          <source>coroutine.close()</source>
          <target state="translated">coroutine.close()</target>
        </trans-unit>
        <trans-unit id="20cd53c84ed6149d722a861cd300131fe78d55e2" translate="yes" xml:space="preserve">
          <source>coroutine.create()</source>
          <target state="translated">coroutine.create()</target>
        </trans-unit>
        <trans-unit id="6817fb4ac877543987e9d2cf2bfa960bd73b02b0" translate="yes" xml:space="preserve">
          <source>coroutine.isyieldable()</source>
          <target state="translated">coroutine.isyieldable()</target>
        </trans-unit>
        <trans-unit id="1c13fd77eddf40ec2374814bf03a272d614ac054" translate="yes" xml:space="preserve">
          <source>coroutine.resume()</source>
          <target state="translated">coroutine.resume()</target>
        </trans-unit>
        <trans-unit id="b96ab0d2970d06f0cea57e5eaa71cf5ecdd618a8" translate="yes" xml:space="preserve">
          <source>coroutine.running()</source>
          <target state="translated">coroutine.running()</target>
        </trans-unit>
        <trans-unit id="ba662b8414ef9e3a4eaa77d2c840fa4c12339222" translate="yes" xml:space="preserve">
          <source>coroutine.status()</source>
          <target state="translated">coroutine.status()</target>
        </trans-unit>
        <trans-unit id="bf3b61ea5fdfb1c6f4aa0021505b10377c2744b9" translate="yes" xml:space="preserve">
          <source>coroutine.wrap()</source>
          <target state="translated">coroutine.wrap()</target>
        </trans-unit>
        <trans-unit id="28fa9aab8f13eb98b7d555b1121c4e2f64da5b24" translate="yes" xml:space="preserve">
          <source>coroutine.yield()</source>
          <target state="translated">coroutine.yield()</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
