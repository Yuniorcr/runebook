<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="sequelize">
    <body>
      <group id="sequelize">
        <trans-unit id="a9119455acf93ce1a9f696a83f8995a9c11c5e76" translate="yes" xml:space="preserve">
          <source>Our code example above defines a unique constraint on the &lt;code&gt;username&lt;/code&gt; field:</source>
          <target state="translated">위의 코드 예제는 &lt;code&gt;username&lt;/code&gt; 필드 에 대한 고유 한 제약 조건을 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="79eda91bb3b93164ab196b3ef5ed4437b5cbffeb" translate="yes" xml:space="preserve">
          <source>Our goal is to use environment variables for various database secrets and not accidentally check them in to source control.</source>
          <target state="translated">우리의 목표는 다양한 데이터베이스 비밀에 환경 변수를 사용하고 실수로 소스 제어에 체크인하지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="cc38f7c39eb540d71928b1f61611e839c5871bdc" translate="yes" xml:space="preserve">
          <source>Output example:</source>
          <target state="translated">출력 예 :</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="2fe96ce51692a16cb282a2ceab2dbe87dd4dadd4" translate="yes" xml:space="preserve">
          <source>Override the name of the createdAt attribute if a string is provided, or disable it if false. Timestamps must be true. Underscored field will be set with underscored setting.</source>
          <target state="translated">문자열이 제공되면 createdAt 속성의 이름을 대체하거나 false이면 비활성화하십시오. 타임 스탬프는 true 여야합니다. 밑줄 필드는 밑줄 설정으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="573d8c9affd76cce2150107ed262b77798164d37" translate="yes" xml:space="preserve">
          <source>Override the name of the deletedAt attribute if a string is provided, or disable it if false. Timestamps must be true. Underscored field will be set with underscored setting.</source>
          <target state="translated">문자열이 제공되면 deletedAt 속성의 이름을 대체하거나 false이면 비활성화하십시오. 타임 스탬프는 true 여야합니다. 밑줄 필드는 밑줄 설정으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="9f80d4c656e4b0f6cdab55224c8d4d9902552192" translate="yes" xml:space="preserve">
          <source>Override the name of the updatedAt attribute if a string is provided, or disable it if false. Timestamps must be true. Underscored field will be set with underscored setting.</source>
          <target state="translated">문자열이 제공되면 updatedAt 속성의 이름을 대체하거나 false 인 경우 비활성화하십시오. 타임 스탬프는 true 여야합니다. 밑줄 필드는 밑줄 설정으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="f94554b14ce5d5015d5ba9e9470606d7ad0f4f6f" translate="yes" xml:space="preserve">
          <source>Override:</source>
          <target state="translated">Override:</target>
        </trans-unit>
        <trans-unit id="3f7d6cc8fec865bda822e92a0370ee91c289bb82" translate="yes" xml:space="preserve">
          <source>Overriding singulars and plurals when defining aliases</source>
          <target state="translated">별칭을 정의 할 때 단수형 및 복수형 재정의</target>
        </trans-unit>
        <trans-unit id="191bd4c23022d0bfd4c0afc357cdedc311221c89" translate="yes" xml:space="preserve">
          <source>PAGLOCK</source>
          <target state="translated">PAGLOCK</target>
        </trans-unit>
        <trans-unit id="6216de0ea276035ad6c650404d1fb576170506d9" translate="yes" xml:space="preserve">
          <source>PRIMARY KEY</source>
          <target state="translated">기본 키</target>
        </trans-unit>
        <trans-unit id="a39ae88eaa033344f483111a662c38ecc2c9da40" translate="yes" xml:space="preserve">
          <source>Pagination / Limiting</source>
          <target state="translated">페이지 매김 / 제한</target>
        </trans-unit>
        <trans-unit id="23c7082125dc9cf874bbe14ba3786fba1a079619" translate="yes" xml:space="preserve">
          <source>Parameters used with the BUILT-IN validator function, if applicable</source>
          <target state="translated">적용 가능한 경우 BUILT-IN 유효성 검증기 기능과 함께 사용되는 매개 변수</target>
        </trans-unit>
        <trans-unit id="ad73fd1a2c6d31eae746e734e09a693793745bd9" translate="yes" xml:space="preserve">
          <source>Params:</source>
          <target state="translated">Params:</target>
        </trans-unit>
        <trans-unit id="0323ce5f916db1ccbbc2f229de155777a2911f7c" translate="yes" xml:space="preserve">
          <source>Paranoid</source>
          <target state="translated">Paranoid</target>
        </trans-unit>
        <trans-unit id="ca1853065cda963bd9f055b6bd7dc1d954164536" translate="yes" xml:space="preserve">
          <source>Pass CONCURRENT so other operations run while the index is created</source>
          <target state="translated">인덱스가 생성되는 동안 다른 작업이 실행되도록 CONCURRENT를 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="482ca0567201b23a9b0f90cc3e4ca6ff3ea7504f" translate="yes" xml:space="preserve">
          <source>Pass in the desired level as the first argument:</source>
          <target state="translated">첫 번째 인수로 원하는 수준으로 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="d0b6a5930843ead542631eccaa522d64b6f4c225" translate="yes" xml:space="preserve">
          <source>Pass query execution time in milliseconds as second argument to logging function (options.logging).</source>
          <target state="translated">로깅 기능 (options.logging)의 두 번째 인수로 쿼리 실행 시간을 밀리 초 단위로 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="72708499ef443e45b95abcad90f88639d4ced03b" translate="yes" xml:space="preserve">
          <source>Passing Dialect Specific Options</source>
          <target state="translated">방언 별 옵션 전달</target>
        </trans-unit>
        <trans-unit id="baba3ce14590bddb2c780823a3c2827d23a79575" translate="yes" xml:space="preserve">
          <source>Passing an array directly to the &lt;code&gt;where&lt;/code&gt; option will implicitly use the &lt;code&gt;IN&lt;/code&gt; operator:</source>
          <target state="translated">&lt;code&gt;where&lt;/code&gt; 옵션에 직접 배열을 전달하면 암시 적으로 &lt;code&gt;IN&lt;/code&gt; 연산자가 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="4f68ed21fc56c7f5b451bd1d1d2f4f3db03f183a" translate="yes" xml:space="preserve">
          <source>Passing options</source>
          <target state="translated">전달 옵션</target>
        </trans-unit>
        <trans-unit id="0427d4c2f4fb6701afcb9d1d7b13d90257f569fd" translate="yes" xml:space="preserve">
          <source>Per-attribute validations</source>
          <target state="translated">속성 별 검증</target>
        </trans-unit>
        <trans-unit id="ad41972eed6cb608026300559fabcca9c731ee78" translate="yes" xml:space="preserve">
          <source>Per-attribute validators and &lt;code&gt;allowNull&lt;/code&gt;</source>
          <target state="translated">속성 별 유효성 검사기 및 &lt;code&gt;allowNull&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9808bafa8bd1f406e228ff5597a4f9e053ba72a0" translate="yes" xml:space="preserve">
          <source>Permanent Hooks (Sequelize.addHook)</source>
          <target state="translated">영구 고리 (Sequelize.addHook)</target>
        </trans-unit>
        <trans-unit id="7dde5515fd3f65884b9e28154cbb52137090082b" translate="yes" xml:space="preserve">
          <source>Permanent Hooks (with &lt;code&gt;sequelize.addHook&lt;/code&gt;)</source>
          <target state="translated">영구 후크 ( &lt;code&gt;sequelize.addHook&lt;/code&gt; 사용 )</target>
        </trans-unit>
        <trans-unit id="323bca2fecb8aed065297c5c4721eea1b95a7140" translate="yes" xml:space="preserve">
          <source>Permanent hooks may also be defined in &lt;code&gt;Sequelize.options&lt;/code&gt;:</source>
          <target state="translated">영구 후크는 &lt;code&gt;Sequelize.options&lt;/code&gt; 에서 정의 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="92f024343d8b573bb5f602c24148c5cdcb725713" translate="yes" xml:space="preserve">
          <source>Permanent hooks may also be defined in the options passed to the Sequelize constructor:</source>
          <target state="translated">영구 후크는 Sequelize 생성자에 전달 된 옵션에서도 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="496e9438ab65557e3360c256d99d6d71460da8a3" translate="yes" xml:space="preserve">
          <source>Philosophy</source>
          <target state="translated">Philosophy</target>
        </trans-unit>
        <trans-unit id="63d6ff4863ed30fb76c61de7b9ed4a9c45048878" translate="yes" xml:space="preserve">
          <source>Please note that this function will return &lt;code&gt;false&lt;/code&gt; when a property from a nested (for example JSON) property was edited manually, you must call &lt;code&gt;changed('key', true)&lt;/code&gt; manually in these cases. Writing an entirely new object (eg. deep cloned) will be detected.</source>
          <target state="translated">중첩 된 (예 : JSON) 속성의 속성을 수동으로 편집 한 경우이 함수는 &lt;code&gt;false&lt;/code&gt; 를 반환 하므로 이러한 경우 수동으로 &lt;code&gt;changed('key', true)&lt;/code&gt; 호출해야합니다 . 완전히 새로운 객체 (예 : 딥 클론)를 작성하는 것이 감지됩니다.</target>
        </trans-unit>
        <trans-unit id="ea229a60fffb397f7382a9347e16ab4efb875578" translate="yes" xml:space="preserve">
          <source>Please see &lt;a href=&quot;transaction.js~transaction#static-get-LOCK&quot;&gt;Transaction.LOCK&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;transaction.js~transaction#static-get-LOCK&quot;&gt;거래를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a633c5c9226ef96e26ef67982c0b1fbf31148bdb" translate="yes" xml:space="preserve">
          <source>Plural name for model</source>
          <target state="translated">모델의 복수 명</target>
        </trans-unit>
        <trans-unit id="940615d7b1c2a240a0fbb7f03ce78d46e92515c9" translate="yes" xml:space="preserve">
          <source>Polymorphic Associations</source>
          <target state="translated">다형성 연관</target>
        </trans-unit>
        <trans-unit id="398862a0e98197505e10899a163763d02a40a057" translate="yes" xml:space="preserve">
          <source>Polymorphic eager loading</source>
          <target state="translated">다형성 eager 로딩</target>
        </trans-unit>
        <trans-unit id="8e5309972abd8e79bd8898c504dc5190d0da203d" translate="yes" xml:space="preserve">
          <source>Polymorphic lazy loading</source>
          <target state="translated">다형성 지연 로딩</target>
        </trans-unit>
        <trans-unit id="1d084ee18adaf1fb6a55bcdbb5ae509aaad9d8de" translate="yes" xml:space="preserve">
          <source>Polymorphism &amp;amp; Scopes</source>
          <target state="translated">다형성 및 범위</target>
        </trans-unit>
        <trans-unit id="6b41bd077261ccb7ed7f04853c7e531e9e12131b" translate="yes" xml:space="preserve">
          <source>Possible options for row locking.</source>
          <target state="translated">행 잠금에 가능한 옵션.</target>
        </trans-unit>
        <trans-unit id="16e0a7b633c76d649ce1e522d7ec681ae462f811" translate="yes" xml:space="preserve">
          <source>Possible options for row locking. Used in conjunction with &lt;code&gt;find&lt;/code&gt; calls:</source>
          <target state="translated">행 잠금에 가능한 옵션. &lt;code&gt;find&lt;/code&gt; 호출 과 함께 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="620b5af6e3139187a47774b9079769bc03158a5a" translate="yes" xml:space="preserve">
          <source>PostGIS 1.5 introduced a new spatial type called geography, which uses geodetic measurement instead of Cartesian measurement. Coordinate points in the geography type are always represented in WGS 84 lon lat degrees (SRID 4326), but measurement functions and relationships ST_Distance, ST_DWithin, ST_Length, and ST_Area always return answers in meters or assume inputs in meters.</source>
          <target state="translated">PostGIS 1.5에는 지리학이라는 새로운 공간 유형이 도입되었습니다. 지리학 적 측정 대신 측지 측정을 사용합니다. 지역 유형의 좌표 점은 항상 WGS 84 론 위도 (SRID 4326)로 표시되지만 측정 함수 및 관계 ST_Distance, ST_DWithin, ST_Length 및 ST_Area는 항상 미터 단위로 응답을 반환하거나 미터 단위로 입력을 가정합니다.</target>
        </trans-unit>
        <trans-unit id="24fd6c2d1150de6a47543209150ff4c2a2d3104f" translate="yes" xml:space="preserve">
          <source>PostgreSQL</source>
          <target state="translated">PostgreSQL</target>
        </trans-unit>
        <trans-unit id="073df06d9f717170d0ac65398d7e552d09431498" translate="yes" xml:space="preserve">
          <source>PostgreSQL - Implemented as a temporary function with exception handling: INSERT EXCEPTION WHEN unique_constraint UPDATE</source>
          <target state="translated">PostgreSQL-예외 처리와 함께 임시 함수로 구현되었습니다. unique_constraint UPDATE시 예외 삽입</target>
        </trans-unit>
        <trans-unit id="1c7d4689974faaf8c79a44ecf938576cc307a775" translate="yes" xml:space="preserve">
          <source>PostgreSQL - Implemented with ON CONFLICT DO UPDATE</source>
          <target state="translated">PostgreSQL-ON CONFLICT DO UPDATE로 구현 됨</target>
        </trans-unit>
        <trans-unit id="79391636d60c218db7234941037f7edbc1a7f6f8" translate="yes" xml:space="preserve">
          <source>PostgreSQL - Implemented with ON CONFLICT DO UPDATE. If update data contains PK field, then PK is selected as the default conflict key. Otherwise first unique constraint/index will be selected, which can satisfy conflict key requirements.</source>
          <target state="translated">PostgreSQL-ON CONFLICT DO UPDATE로 구현되었습니다. 업데이트 데이터에 PK 필드가 포함 된 경우 PK가 기본 충돌 키로 선택됩니다. 그렇지 않으면 충돌 키 요구 사항을 충족 할 수있는 첫 번째 고유 제약 조건 / 인덱스가 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="7fbb62931ba330a93c263e461bbeede166935575" translate="yes" xml:space="preserve">
          <source>PostgreSQL also supports a JSONB data type: &lt;code&gt;DataTypes.JSONB&lt;/code&gt;. It can be queried in three different ways:</source>
          <target state="translated">PostgreSQL은 또한 JSONB 데이터 유형 인 &lt;code&gt;DataTypes.JSONB&lt;/code&gt; 를 지원합니다 . 다음 세 가지 방법으로 쿼리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="1502dc34bce3e1346fc0014a7cc5ee3e3ea95fbe" translate="yes" xml:space="preserve">
          <source>Postgres 9.3+ only</source>
          <target state="translated">Postgres 9.3 이상</target>
        </trans-unit>
        <trans-unit id="b8ce2814112b89374b10c38bb5cca295a3fcd5eb" translate="yes" xml:space="preserve">
          <source>Postgres also supports specific locks while eager loading by using OF:</source>
          <target state="translated">Postgres는 OF를 사용하여 열망하는 동안 특정 잠금을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="3b51d85b8b83e568b47e86fa1de6ec1fa325824e" translate="yes" xml:space="preserve">
          <source>Postgres-only Range Operators</source>
          <target state="translated">Postgres 전용 범위 연산자</target>
        </trans-unit>
        <trans-unit id="51d44eb51088929f422bc28b75044da894ba7133" translate="yes" xml:space="preserve">
          <source>PostgresQueryInterface</source>
          <target state="translated">PostgresQueryInterface</target>
        </trans-unit>
        <trans-unit id="2a407251115e1be28c5504b5f9e9199614279ede" translate="yes" xml:space="preserve">
          <source>PostgresSQL will build the index without taking any write locks. Postgres only</source>
          <target state="translated">PostgresSQL은 쓰기 잠금을 수행하지 않고 인덱스를 빌드합니다. Postgres 만</target>
        </trans-unit>
        <trans-unit id="c998fcd404760161b18e1244391560d882806a60" translate="yes" xml:space="preserve">
          <source>Practical demonstration:</source>
          <target state="translated">실제 시연 :</target>
        </trans-unit>
        <trans-unit id="40422597c1c40514f35669101c84e0217afa95b5" translate="yes" xml:space="preserve">
          <source>Prevents any drop statements while altering a table when set to &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; 로 설정된 경우 테이블을 변경하는 동안 모든 drop 문을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="69f98f62216cced84a4a7664fbea7b244d38cc2f" translate="yes" xml:space="preserve">
          <source>Primary Key</source>
          <target state="translated">기본 키</target>
        </trans-unit>
        <trans-unit id="e517ee5fd3782b5ee136558aa5e08fab77ad1688" translate="yes" xml:space="preserve">
          <source>Primary keys</source>
          <target state="translated">기본 키</target>
        </trans-unit>
        <trans-unit id="9ab910186508b83730a0e5f6ef1718f45b1e0c1c" translate="yes" xml:space="preserve">
          <source>Production Usages</source>
          <target state="translated">생산 용도</target>
        </trans-unit>
        <trans-unit id="3eacec8f55a5e35528fbf9b2c5ac91fb95640e54" translate="yes" xml:space="preserve">
          <source>Programmatic usage</source>
          <target state="translated">프로그래밍 방식 사용</target>
        </trans-unit>
        <trans-unit id="554abf30e877116873c3de42924d6ac948059d03" translate="yes" xml:space="preserve">
          <source>Programmatic use</source>
          <target state="translated">프로그래밍 방식의 사용</target>
        </trans-unit>
        <trans-unit id="a03bd3889a77a6489aff23f934753e3e24f9872e" translate="yes" xml:space="preserve">
          <source>Project bootstrapping</source>
          <target state="translated">프로젝트 부트 스트랩</target>
        </trans-unit>
        <trans-unit id="fe5671922bc7f67cfabfa60ab97a9542ac21f39f" translate="yes" xml:space="preserve">
          <source>Promise</source>
          <target state="translated">Promise</target>
        </trans-unit>
        <trans-unit id="75f955c70fe0ea79083fa7fabe3a05900585c010" translate="yes" xml:space="preserve">
          <source>Promises and async/await</source>
          <target state="translated">약속과 비동기 / 기다리기</target>
        </trans-unit>
        <trans-unit id="351f56a6fefd5127c90506d3e91990f1d7631787" translate="yes" xml:space="preserve">
          <source>Properties:</source>
          <target state="translated">Properties:</target>
        </trans-unit>
        <trans-unit id="ee08d4050cbb6098526e1137d5e2d585350759ed" translate="yes" xml:space="preserve">
          <source>Property name of the BUILT-IN validator function that caused the validation error (e.g.</source>
          <target state="translated">유효성 검사 오류를 일으킨 BUILT-IN 유효성 검사기 기능의 속성 이름 (예 :</target>
        </trans-unit>
        <trans-unit id="21dd1ed33063eaf0fec2b627562e02d732b0d02a" translate="yes" xml:space="preserve">
          <source>Property name of the BUILT-IN validator function that caused the validation error (e.g. &quot;in&quot; or &quot;len&quot;), if applicable</source>
          <target state="translated">적용 가능한 경우 유효성 검사 오류를 일으킨 BUILT-IN 유효성 검사기 기능의 속성 이름 (예 : &quot;in&quot;또는 &quot;len&quot;)</target>
        </trans-unit>
        <trans-unit id="b39befe85559d7a7d7f870921dd09f561ee705ee" translate="yes" xml:space="preserve">
          <source>Provide a custom getter for this column. Use &lt;code&gt;this.getDataValue(String)&lt;/code&gt; to manipulate the underlying values.</source>
          <target state="translated">이 열에 대한 사용자 지정 게터를 제공하십시오. 사용 &lt;code&gt;this.getDataValue(String)&lt;/code&gt; 기본 값을 조작합니다.</target>
        </trans-unit>
        <trans-unit id="b5698adaf1c9e505751601dcfd1ade05d46fb2b2" translate="yes" xml:space="preserve">
          <source>Provide a custom setter for this column. Use &lt;code&gt;this.setDataValue(String, Value)&lt;/code&gt; to manipulate the underlying values.</source>
          <target state="translated">이 열에 대한 사용자 정의 세터를 제공하십시오. 사용 &lt;code&gt;this.setDataValue(String, Value)&lt;/code&gt; 기본 값을 조작합니다.</target>
        </trans-unit>
        <trans-unit id="8205d4835feb28ef748cb995a862982c6704475f" translate="yes" xml:space="preserve">
          <source>Providing the foreign key name directly</source>
          <target state="translated">외래 키 이름을 직접 제공</target>
        </trans-unit>
        <trans-unit id="db3e60842835b557780aed32b31d7099355014e0" translate="yes" xml:space="preserve">
          <source>Providing the table name directly</source>
          <target state="translated">테이블 이름을 직접 제공</target>
        </trans-unit>
        <trans-unit id="7806d20a5b3b834f1cf4cd79c6e14a14852dd900" translate="yes" xml:space="preserve">
          <source>Public Constructor</source>
          <target state="translated">공공 생성자</target>
        </trans-unit>
        <trans-unit id="f98f741af3e683a633762397b6b19a8a0d84038a" translate="yes" xml:space="preserve">
          <source>Public Constructors</source>
          <target state="translated">공공 생성자</target>
        </trans-unit>
        <trans-unit id="6e05889c9b4dc3e125f9019b8d38b3bb729194a7" translate="yes" xml:space="preserve">
          <source>Public Members</source>
          <target state="translated">공개 회원</target>
        </trans-unit>
        <trans-unit id="400be4997716cf3bb5a0c05bf961e2a62c95f6c8" translate="yes" xml:space="preserve">
          <source>Public Methods</source>
          <target state="translated">공개 방법</target>
        </trans-unit>
        <trans-unit id="63d5fc813429798ad09082a4ce6d7789993afa8a" translate="yes" xml:space="preserve">
          <source>Queries using OR</source>
          <target state="translated">OR을 사용한 쿼리</target>
        </trans-unit>
        <trans-unit id="23495b5214e112ada524d83f47869be27fbc912f" translate="yes" xml:space="preserve">
          <source>Queries within a &lt;code&gt;transaction&lt;/code&gt; can be performed with locks</source>
          <target state="translated">&lt;code&gt;transaction&lt;/code&gt; 내 쿼리 는 잠금으로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e08371560ae35ad331969b2ee30fbc29c4cf8383" translate="yes" xml:space="preserve">
          <source>Queries within a &lt;code&gt;transaction&lt;/code&gt; can be performed with locks:</source>
          <target state="translated">&lt;code&gt;transaction&lt;/code&gt; 내의 쿼리 는 잠금을 사용하여 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9240311f3ef167d8f58165e9bce953c0badf6a4a" translate="yes" xml:space="preserve">
          <source>Queries within a transaction can skip locked rows</source>
          <target state="translated">트랜잭션 내의 쿼리는 잠긴 행을 건너 뛸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db8b49c3a0dec670530fbe3be61b60522349a771" translate="yes" xml:space="preserve">
          <source>Queries within a transaction can skip locked rows:</source>
          <target state="translated">트랜잭션 내의 쿼리는 잠긴 행을 건너 뛸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d12354bd5e0d0c4f4a34bf8e9705cc16c24598ce" translate="yes" xml:space="preserve">
          <source>Query Interface</source>
          <target state="translated">쿼리 인터페이스</target>
        </trans-unit>
        <trans-unit id="0969ef4dddd33716783dd28b66ec0aaeafb4bd86" translate="yes" xml:space="preserve">
          <source>Query option</source>
          <target state="translated">쿼리 옵션</target>
        </trans-unit>
        <trans-unit id="720143b0891d96ea816e381d60d6c88f81a3db6f" translate="yes" xml:space="preserve">
          <source>Query options</source>
          <target state="translated">쿼리 옵션</target>
        </trans-unit>
        <trans-unit id="e078f5ce4da3bbd9092168dc7caa7d58d0c3218d" translate="yes" xml:space="preserve">
          <source>Query options.</source>
          <target state="translated">쿼리 옵션.</target>
        </trans-unit>
        <trans-unit id="aacae2c5528cab9ee4d1056bb3fe97d662b13033" translate="yes" xml:space="preserve">
          <source>Query options. See sequelize.query for full options</source>
          <target state="translated">쿼리 옵션. 전체 옵션은 sequelize.query를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1e0418715c69e9b17e7730738c56f3d4f4b9d704" translate="yes" xml:space="preserve">
          <source>QueryError</source>
          <target state="translated">QueryError</target>
        </trans-unit>
        <trans-unit id="e0905a933a3f10834e2d58cddd1bfbace4c6ce1e" translate="yes" xml:space="preserve">
          <source>QueryInterface</source>
          <target state="translated">QueryInterface</target>
        </trans-unit>
        <trans-unit id="b746e021b98742617b2fe7490d3ac34a75c2d8dd" translate="yes" xml:space="preserve">
          <source>QueryInterface#addConstraint</source>
          <target state="translated">QueryInterface#addConstraint</target>
        </trans-unit>
        <trans-unit id="643a49308cbc01e5043d378a12618e214c5fc2c9" translate="yes" xml:space="preserve">
          <source>QueryInterface#changeColumn</source>
          <target state="translated">QueryInterface#changeColumn</target>
        </trans-unit>
        <trans-unit id="6ec0042c10ee0eac832c21eca876add74ae02743" translate="yes" xml:space="preserve">
          <source>QueryInterface#describeTable</source>
          <target state="translated">QueryInterface#describeTable</target>
        </trans-unit>
        <trans-unit id="14421ac92c6098da772b065fb1bab1ecb5846759" translate="yes" xml:space="preserve">
          <source>QueryInterface#dropAllTables</source>
          <target state="translated">QueryInterface#dropAllTables</target>
        </trans-unit>
        <trans-unit id="15f06e414a008fe4f9a8ed2c166cf43bb78c8647" translate="yes" xml:space="preserve">
          <source>QueryInterface#dropTable</source>
          <target state="translated">QueryInterface#dropTable</target>
        </trans-unit>
        <trans-unit id="ab0315d75e931022da910b9021c97b0a8d5933fe" translate="yes" xml:space="preserve">
          <source>QueryInterface#getForeignKeyReferencesForTable</source>
          <target state="translated">QueryInterface#getForeignKeyReferencesForTable</target>
        </trans-unit>
        <trans-unit id="5e69331c438507ee6c5c9be1ef3f6a70c8c812bd" translate="yes" xml:space="preserve">
          <source>QueryInterface#removeColumn</source>
          <target state="translated">QueryInterface#removeColumn</target>
        </trans-unit>
        <trans-unit id="f2c5d943c75420247fd7f4e08cc8984d0996a139" translate="yes" xml:space="preserve">
          <source>QueryInterface#removeConstraint</source>
          <target state="translated">QueryInterface#removeConstraint</target>
        </trans-unit>
        <trans-unit id="1c9e66a109d0e696c561c2cac13d744edfc4cc35" translate="yes" xml:space="preserve">
          <source>QueryInterface#renameColumn</source>
          <target state="translated">QueryInterface#renameColumn</target>
        </trans-unit>
        <trans-unit id="270de98496f79ae37a3c9b120a81fbf93a9783b5" translate="yes" xml:space="preserve">
          <source>QueryInterface#upsert</source>
          <target state="translated">QueryInterface#upsert</target>
        </trans-unit>
        <trans-unit id="956e52cb6dce6420ffdbd1c53f487158ffdca0ce" translate="yes" xml:space="preserve">
          <source>QueryTypes</source>
          <target state="translated">QueryTypes</target>
        </trans-unit>
        <trans-unit id="cc6835ce045ca407e1aa42cf034a40b2dc968c7d" translate="yes" xml:space="preserve">
          <source>Querying</source>
          <target state="translated">Querying</target>
        </trans-unit>
        <trans-unit id="8f1e1ff9d000b44617e8ef8f0ce02e30146ecaef" translate="yes" xml:space="preserve">
          <source>Quick example</source>
          <target state="translated">빠른 예</target>
        </trans-unit>
        <trans-unit id="578e6dad8d99e7211a3086f6ebcd1836a6b2b2b0" translate="yes" xml:space="preserve">
          <source>RANGE</source>
          <target state="translated">RANGE</target>
        </trans-unit>
        <trans-unit id="c5db7969dcd30635e5d7867040b6cc76158dd175" translate="yes" xml:space="preserve">
          <source>RAW</source>
          <target state="translated">RAW</target>
        </trans-unit>
        <trans-unit id="85071fc9642a31aeb812a32870f392506932a628" translate="yes" xml:space="preserve">
          <source>READCOMMITTED</source>
          <target state="translated">READCOMMITTED</target>
        </trans-unit>
        <trans-unit id="c81fcd11275974e0c42fe3b69f4579fb5562a008" translate="yes" xml:space="preserve">
          <source>READPAST</source>
          <target state="translated">READPAST</target>
        </trans-unit>
        <trans-unit id="0c97d219d43b5c2d780f866829caf6659ccd95b4" translate="yes" xml:space="preserve">
          <source>READUNCOMMITTED</source>
          <target state="translated">READUNCOMMITTED</target>
        </trans-unit>
        <trans-unit id="98576b173a3704ed9c7a7b2cf51bf056c70f0d68" translate="yes" xml:space="preserve">
          <source>READ_COMMITTED</source>
          <target state="translated">READ_COMMITTED</target>
        </trans-unit>
        <trans-unit id="61855051443526ce1354c6dfbbb1385589d20c72" translate="yes" xml:space="preserve">
          <source>READ_UNCOMMITTED</source>
          <target state="translated">READ_UNCOMMITTED</target>
        </trans-unit>
        <trans-unit id="3b330731a188b19fdf61999609e5e9b932bb400b" translate="yes" xml:space="preserve">
          <source>REAL</source>
          <target state="translated">REAL</target>
        </trans-unit>
        <trans-unit id="35818f41399b7623be79d4ece6708799ff65422b" translate="yes" xml:space="preserve">
          <source>REPEATABLEREAD</source>
          <target state="translated">REPEATABLEREAD</target>
        </trans-unit>
        <trans-unit id="7933c8f4eeae479160924ccc01192513271103d0" translate="yes" xml:space="preserve">
          <source>REPEATABLE_READ</source>
          <target state="translated">REPEATABLE_READ</target>
        </trans-unit>
        <trans-unit id="d2de16710476e50096c7fcc23018a457762110cf" translate="yes" xml:space="preserve">
          <source>ROWLOCK</source>
          <target state="translated">ROWLOCK</target>
        </trans-unit>
        <trans-unit id="639e3ac9bf3c15f412dffa9f6f9c04017303eefc" translate="yes" xml:space="preserve">
          <source>Range Operators</source>
          <target state="translated">범위 연산자</target>
        </trans-unit>
        <trans-unit id="48652fff66c0aa4370d5c8fba0d573037de8ea3f" translate="yes" xml:space="preserve">
          <source>Range types</source>
          <target state="translated">범위 유형</target>
        </trans-unit>
        <trans-unit id="96c99c450dc81023477ef685e69a7671928973e9" translate="yes" xml:space="preserve">
          <source>Range types are data types representing a range of values of some element type (called the range's subtype). Only available in Postgres. See &lt;a href=&quot;http://www.postgresql.org/docs/9.4/static/rangetypes.html&quot;&gt;the Postgres documentation&lt;/a&gt; for more details</source>
          <target state="translated">범위 유형은 일부 요소 유형의 값 범위 (범위 하위 유형이라고 함)를 나타내는 데이터 유형입니다. Postgres에서만 사용할 수 있습니다. 자세한 내용 &lt;a href=&quot;http://www.postgresql.org/docs/9.4/static/rangetypes.html&quot;&gt;은 Postgres 설명서&lt;/a&gt; 를 참조하십시오</target>
        </trans-unit>
        <trans-unit id="baa0c0a539e637ea81ecd40d7d79d62762651243" translate="yes" xml:space="preserve">
          <source>Range types are data types representing a range of values of some element type (called the range's subtype). Only available in Postgres. See &lt;a href=&quot;https://www.postgresql.org/docs/9.4/static/rangetypes.html&quot;&gt;the Postgres documentation&lt;/a&gt; for more details</source>
          <target state="translated">범위 유형은 일부 요소 유형 (범위의 하위 유형이라고 함)의 값 범위를 나타내는 데이터 유형입니다. Postgres에서만 사용할 수 있습니다. 자세한 내용 &lt;a href=&quot;https://www.postgresql.org/docs/9.4/static/rangetypes.html&quot;&gt;은 Postgres 문서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5a7377dcba549345dfcab0dfa8460d8f871eb24f" translate="yes" xml:space="preserve">
          <source>Range types can be queried with all supported operators.</source>
          <target state="translated">지원되는 모든 연산자를 사용하여 범위 유형을 쿼리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="0d5fda95e3940bc09dc1ccc22666813c0b54f73d" translate="yes" xml:space="preserve">
          <source>Ranges</source>
          <target state="translated">Ranges</target>
        </trans-unit>
        <trans-unit id="4abc963c5feb4a77aec12cd6e0b283d52dc33fa8" translate="yes" xml:space="preserve">
          <source>Ranges (PostgreSQL only)</source>
          <target state="translated">범위 (PostgreSQL 만 해당)</target>
        </trans-unit>
        <trans-unit id="1d5ffd4747a468824eca3c1df9c2238d7de96915" translate="yes" xml:space="preserve">
          <source>Raw Queries</source>
          <target state="translated">원시 쿼리</target>
        </trans-unit>
        <trans-unit id="9f5ef9cd3f272e59c3c26c12902db3ba7d565d10" translate="yes" xml:space="preserve">
          <source>Raw queries</source>
          <target state="translated">원시 쿼리</target>
        </trans-unit>
        <trans-unit id="4248bae998e3d216240b6c47e05b15e9130b7194" translate="yes" xml:space="preserve">
          <source>Raw will be added verbatim without quoting</source>
          <target state="translated">Raw는 따옴표없이 그대로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="70c9b4f58c55a2765750d48e15c5353f39a95865" translate="yes" xml:space="preserve">
          <source>Read Replication</source>
          <target state="translated">복제 읽기</target>
        </trans-unit>
        <trans-unit id="9663c8f2ab80910477b1274bc8c092ea181f86b5" translate="yes" xml:space="preserve">
          <source>Read replication</source>
          <target state="translated">읽기 복제</target>
        </trans-unit>
        <trans-unit id="fc3a671a9de66ec18ca4a1c3ca9912583ee9b3ca" translate="yes" xml:space="preserve">
          <source>Recall that Sequelize uses a library called &lt;a href=&quot;https://www.npmjs.com/package/inflection&quot;&gt;inflection&lt;/a&gt; under the hood, so that irregular plurals (such as &lt;code&gt;person -&amp;gt; people&lt;/code&gt;) are computed correctly. However, if you're working in another language, you may want to define the singular and plural forms of names directly; sequelize allows you to do this with some options.</source>
          <target state="translated">Sequelize는 &lt;a href=&quot;https://www.npmjs.com/package/inflection&quot;&gt;inflection&lt;/a&gt; 이라는 라이브러리를 사용 하므로 불규칙한 복수형 (예 : person- &lt;code&gt;person -&amp;gt; people&lt;/code&gt; )이 올바르게 계산됩니다. 그러나 다른 언어로 작업하는 경우 이름의 단 복수 형식을 직접 정의 할 수 있습니다. sequelize를 사용하면 몇 가지 옵션으로이를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a367f7ca1e9c6317016a28d82c9e274d3cfcd41c" translate="yes" xml:space="preserve">
          <source>Recap: the default setup</source>
          <target state="translated">요약 : 기본 설정</target>
        </trans-unit>
        <trans-unit id="5d20d0fee3b91643dd8d272ac33d01ca95179d82" translate="yes" xml:space="preserve">
          <source>References</source>
          <target state="translated">References</target>
        </trans-unit>
        <trans-unit id="3461d3a7969c4cd108547d91c8db9fbbeb2a561d" translate="yes" xml:space="preserve">
          <source>Referring to other columns</source>
          <target state="translated">다른 열 참조</target>
        </trans-unit>
        <trans-unit id="031a37f39bcb7e10adf807d3e8cce401989e3336" translate="yes" xml:space="preserve">
          <source>Refresh the current instance in-place, i.e.</source>
          <target state="translated">현재 인스턴스를 제자리에서 새로 고칩니다.</target>
        </trans-unit>
        <trans-unit id="e3bead0d664a82f06306287d9173002e149764e1" translate="yes" xml:space="preserve">
          <source>Refresh the current instance in-place, i.e. update the object with current data from the DB and return the same object. This is different from doing a &lt;code&gt;find(Instance.id)&lt;/code&gt;, because that would create and return a new instance. With this method, all references to the Instance are updated with the new data and no new objects are created.</source>
          <target state="translated">현재 인스턴스를 제자리에서 새로 고칩니다. 즉, DB의 현재 데이터로 객체를 업데이트하고 동일한 객체를 반환합니다. &lt;code&gt;find(Instance.id)&lt;/code&gt; 를 수행하는 것과는 다릅니다 . 새 인스턴스를 생성하고 반환하기 때문입니다. 이 방법을 사용하면 인스턴스에 대한 모든 참조가 새 데이터로 업데이트되고 새 객체가 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ca5db4fe93ba98fe1b576309acf2388052f2a36a" translate="yes" xml:space="preserve">
          <source>RegExp</source>
          <target state="translated">RegExp</target>
        </trans-unit>
        <trans-unit id="1e86d1ab3e14027eebaead6774b3afb37da45758" translate="yes" xml:space="preserve">
          <source>Relations / Associations</source>
          <target state="translated">관계 / 협회</target>
        </trans-unit>
        <trans-unit id="c49f1446ca673d49ec1415e6aef62429bad05b0a" translate="yes" xml:space="preserve">
          <source>Reloading an instance</source>
          <target state="translated">인스턴스 다시로드</target>
        </trans-unit>
        <trans-unit id="bc1c1bb509a7c9eefcd8074bcef69cd86f8f19ac" translate="yes" xml:space="preserve">
          <source>Reloading instances</source>
          <target state="translated">인스턴스 재로드</target>
        </trans-unit>
        <trans-unit id="14458dc7478ac57fde39eddb8f546bb3fd24be23" translate="yes" xml:space="preserve">
          <source>Remember, that using &lt;code&gt;as&lt;/code&gt; to change the name of the association will also change the name of the foreign key. When using &lt;code&gt;as&lt;/code&gt;, it is safest to also specify the foreign key.</source>
          <target state="translated">&lt;code&gt;as&lt;/code&gt; 를 사용 하여 연결 이름을 변경하면 외래 키의 이름도 변경됩니다. 사용하는 경우 &lt;code&gt;as&lt;/code&gt; , 또한 외래 키를 지정하는 것이 가장 안전하다.</target>
        </trans-unit>
        <trans-unit id="6d92b3105e7267474045640ff596b8906e7af063" translate="yes" xml:space="preserve">
          <source>Remove a column from a table</source>
          <target state="translated">테이블에서 열 제거</target>
        </trans-unit>
        <trans-unit id="bff645f20c7a1972d6d88b3b0359efc0ee0f30bb" translate="yes" xml:space="preserve">
          <source>Remove a constraint from a table</source>
          <target state="translated">테이블에서 제약 조건 제거</target>
        </trans-unit>
        <trans-unit id="cb9d2380c9de310077c9efa21538ee05180de069" translate="yes" xml:space="preserve">
          <source>Remove an already existing index from a table</source>
          <target state="translated">테이블에서 이미 존재하는 인덱스 제거</target>
        </trans-unit>
        <trans-unit id="ab78daa0ae196a56f47e13a630c4d49dbadeaa77" translate="yes" xml:space="preserve">
          <source>Remove attribute from model definition</source>
          <target state="translated">모델 정의에서 속성 제거</target>
        </trans-unit>
        <trans-unit id="d07d3f15bc31bcd0357b211de5ddfbf88c68016f" translate="yes" xml:space="preserve">
          <source>Removing a column</source>
          <target state="translated">열 제거</target>
        </trans-unit>
        <trans-unit id="2973fb8de042ab579cc70360faec4d4d03145016" translate="yes" xml:space="preserve">
          <source>Removing hooks</source>
          <target state="translated">후크 제거</target>
        </trans-unit>
        <trans-unit id="91662afa90e2669fafb0bf327ba36d683b24d55a" translate="yes" xml:space="preserve">
          <source>Rename a column</source>
          <target state="translated">열 이름 바꾸기</target>
        </trans-unit>
        <trans-unit id="ef6f539bacc24cc94df1896ca6fcc25c1857460e" translate="yes" xml:space="preserve">
          <source>Rename a table</source>
          <target state="translated">테이블 이름 바꾸기</target>
        </trans-unit>
        <trans-unit id="5c789b825fe6ffb7af34dec8ebebc9922c5740fd" translate="yes" xml:space="preserve">
          <source>Rename an SQL function</source>
          <target state="translated">SQL 함수 이름 바꾸기</target>
        </trans-unit>
        <trans-unit id="844abd7b464a7e3dcdf7de2a8921961f223adea8" translate="yes" xml:space="preserve">
          <source>Replacements</source>
          <target state="translated">Replacements</target>
        </trans-unit>
        <trans-unit id="d70b63d60d5bb03bf369a3221e7e9fa6befeb5ae" translate="yes" xml:space="preserve">
          <source>Replacements in a query can be done in two different ways, either using named parameters (starting with &lt;code&gt;:&lt;/code&gt;), or unnamed, represented by a &lt;code&gt;?&lt;/code&gt;. Replacements are passed in the options object.</source>
          <target state="translated">쿼리에서 대체는 명명 된 매개 변수 ( &lt;code&gt;:&lt;/code&gt; 로 시작 ) 또는 &lt;code&gt;?&lt;/code&gt; 로 표시되는 명명되지 않은 두 가지 방법으로 수행 할 수 있습니다 . . 교체는 옵션 개체에 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="794dc40894f02da9292ff833a3bc074670a571ef" translate="yes" xml:space="preserve">
          <source>Required eager loading</source>
          <target state="translated">eager loading 필요</target>
        </trans-unit>
        <trans-unit id="c8dd3270a29ae39ef2c23cbc1c10e9c2f5688a7c" translate="yes" xml:space="preserve">
          <source>Resolves an array with &amp;lt;created, primaryKey&amp;gt;</source>
          <target state="translated">&amp;lt;created, primaryKey&amp;gt;로 배열을 해결합니다.</target>
        </trans-unit>
        <trans-unit id="87df60de337fb58864343e396696d74611e0d403" translate="yes" xml:space="preserve">
          <source>Resources</source>
          <target state="translated">Resources</target>
        </trans-unit>
        <trans-unit id="bc5668827c21fe1f8f36ea7324d4d8a3dcb11ecd" translate="yes" xml:space="preserve">
          <source>Restore multiple instances if &lt;code&gt;paranoid&lt;/code&gt; is enabled.</source>
          <target state="translated">&lt;code&gt;paranoid&lt;/code&gt; 이 활성화 된 경우 여러 인스턴스를 복원하십시오 .</target>
        </trans-unit>
        <trans-unit id="37be80d158033bb193c3d7ed1a4181d957c6440e" translate="yes" xml:space="preserve">
          <source>Restore the row corresponding to this instance.</source>
          <target state="translated">이 인스턴스에 해당하는 행을 복원하십시오.</target>
        </trans-unit>
        <trans-unit id="d2363df61524d7567e5af8c230d6ffbc8c9156fc" translate="yes" xml:space="preserve">
          <source>Restore the row corresponding to this instance. Only available for paranoid models.</source>
          <target state="translated">이 인스턴스에 해당하는 행을 복원하십시오. 편집증 모델에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16fca1ae86b904335623c956e24af5c06d6c9696" translate="yes" xml:space="preserve">
          <source>Restoring</source>
          <target state="translated">Restoring</target>
        </trans-unit>
        <trans-unit id="4634f89378d1924436e5804ae4532bb1debc2947" translate="yes" xml:space="preserve">
          <source>Restoring soft-deleted instances</source>
          <target state="translated">일시 삭제 된 인스턴스 복원</target>
        </trans-unit>
        <trans-unit id="bd4afc0073cac79bf136f8e1d922b83f76e969ad" translate="yes" xml:space="preserve">
          <source>Result:</source>
          <target state="translated">Result:</target>
        </trans-unit>
        <trans-unit id="f26f5c5c95a911b7185dd088fa0b3f892ac47881" translate="yes" xml:space="preserve">
          <source>Return Properties:</source>
          <target state="translated">반품 속성 :</target>
        </trans-unit>
        <trans-unit id="f664f9ed85db7232f7addc0c9bbae995ff292379" translate="yes" xml:space="preserve">
          <source>Return raw result. See sequelize.query for more information.</source>
          <target state="translated">원시 결과를 반환합니다. 자세한 내용은 sequelize.query를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9d2d96565dc06a866465216373028dc31bfc11ee" translate="yes" xml:space="preserve">
          <source>Return:</source>
          <target state="translated">Return:</target>
        </trans-unit>
        <trans-unit id="a1d9b7652dc04e48059f4b18dea69d8b483420d4" translate="yes" xml:space="preserve">
          <source>ReturnType</source>
          <target state="translated">ReturnType</target>
        </trans-unit>
        <trans-unit id="a0edde2bcffd199a764acdd89faa623b6165a09e" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;null&lt;/code&gt; when no association is present (which is good);</source>
          <target state="translated">연관성이 &lt;code&gt;null&lt;/code&gt; 경우 null을 반환합니다 (좋습니다).</target>
        </trans-unit>
        <trans-unit id="874e06fa1a11596872c8706db1cf0fdb9bca693b" translate="yes" xml:space="preserve">
          <source>Returns a Promise that resolves to the saved instance (or rejects with a &lt;code&gt;Sequelize.ValidationError&lt;/code&gt;, which will have a property for each of the fields for which the validation failed, with the error message for that field).</source>
          <target state="translated">저장된 인스턴스로 확인되는 Promise를 반환합니다 (또는 &lt;code&gt;Sequelize.ValidationError&lt;/code&gt; 를 사용하여 거부합니다. 해당 필드에 대한 오류 메시지와 함께 유효성 검사가 실패한 각 필드에 대한 속성이 있음).</target>
        </trans-unit>
        <trans-unit id="f32e3242c5f0d8fcfb58c28d4f50b845b239aea2" translate="yes" xml:space="preserve">
          <source>Returns a boolean indicating whether the row was created or updated. For MySQL/MariaDB, it returns &lt;code&gt;true&lt;/code&gt; when inserted and &lt;code&gt;false&lt;/code&gt; when updated. For Postgres/MSSQL with &lt;code&gt;options.returning&lt;/code&gt; true, it returns record and created boolean with signature &lt;code&gt;&amp;lt;Model, created&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">행이 작성 또는 업데이트되었는지 여부를 나타내는 부울을 리턴합니다. MySQL / MariaDB의 경우 삽입하면 &lt;code&gt;true&lt;/code&gt; 를 , 업데이트하면 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다 . &lt;code&gt;options.returning&lt;/code&gt; 이 true 인 Postgres / MSSQL의 경우 &lt;code&gt;&amp;lt;Model, created&amp;gt;&lt;/code&gt; 서명을 사용하여 레코드 및 작성된 부울을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="fdeabc9461ee56743e0aa89216c4114eb6dc4c55" translate="yes" xml:space="preserve">
          <source>Returns all foreign key constraints of requested tables</source>
          <target state="translated">요청 된 테이블의 모든 외래 키 제약 조건을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="92777933f98de40e5798a074519518b08312bfd8" translate="yes" xml:space="preserve">
          <source>Returns an instance of QueryInterface.</source>
          <target state="translated">QueryInterface의 인스턴스를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c322d13eab7a672964dca2772283f58dabee793f" translate="yes" xml:space="preserve">
          <source>Returns the aggregate result cast to &lt;code&gt;options.dataType&lt;/code&gt;, unless &lt;code&gt;options.plain&lt;/code&gt; is false, in which case the complete data result is returned.</source>
          <target state="translated">&lt;code&gt;options.plain&lt;/code&gt; 이 false가 아닌 경우 전체 데이터 결과가 반환 되지 않는 경우, 집계 결과를 &lt;code&gt;options.dataType&lt;/code&gt; 으로 캐스트합니다 .</target>
        </trans-unit>
        <trans-unit id="103e0065273bcd078037909cef8d4cc766b70922" translate="yes" xml:space="preserve">
          <source>Returns the database name.</source>
          <target state="translated">데이터베이스 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a10c7b621ae5ef9b30ad1471df3f082cfe770ea5" translate="yes" xml:space="preserve">
          <source>Returns the previous value for key from &lt;code&gt;_previousDataValues&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;_previousDataValues&lt;/code&gt; 에서 키의 이전 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="9099a16ce517a4d9ac59414ac4a523117d0007b1" translate="yes" xml:space="preserve">
          <source>Returns the specified dialect.</source>
          <target state="translated">지정된 방언을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4310720bd11331b7ae73d54f73813dcad1e1e28a" translate="yes" xml:space="preserve">
          <source>Returns true if model is already defined, otherwise false</source>
          <target state="translated">모델이 이미 정의되어 있으면 true를, 그렇지 않으면 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bf0e4991b938c50573d09edc06ace4eb0dbd811c" translate="yes" xml:space="preserve">
          <source>Returns true if this instance has not yet been persisted to the database</source>
          <target state="translated">이 인스턴스가 아직 데이터베이스에 유지되지 않은 경우 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="2007b5e3da27ad8963cdb311ba2a3128e7cda7e9" translate="yes" xml:space="preserve">
          <source>Rollback (abort) the transaction</source>
          <target state="translated">트랜잭션 롤백 (중단)</target>
        </trans-unit>
        <trans-unit id="8e0cccf120979b3af77ad8a694a8e18cdc3b513e" translate="yes" xml:space="preserve">
          <source>Run a describe query on the table.</source>
          <target state="translated">테이블에서 설명 쿼리를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="8169f81a04275d99535c5a4211bee013dce2d9d3" translate="yes" xml:space="preserve">
          <source>Run an aggregation method on the specified field</source>
          <target state="translated">지정된 필드에서 집계 방법을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="3439b8e48e17b209e3887f10db99898a3f33d4e1" translate="yes" xml:space="preserve">
          <source>Run before / after bulk create hooks?</source>
          <target state="translated">대량 후크 생성 전후에 실행 하시겠습니까?</target>
        </trans-unit>
        <trans-unit id="5a75a9b600e3260d17089015df07ae23e6d3703c" translate="yes" xml:space="preserve">
          <source>Run before / after bulk destroy hooks?</source>
          <target state="translated">대량 파괴 후크 전후에 실행합니까?</target>
        </trans-unit>
        <trans-unit id="e52da5177ddbb46f0bf29b8b84e6c8fb0b7bd630" translate="yes" xml:space="preserve">
          <source>Run before / after bulk restore hooks?</source>
          <target state="translated">대량 복원 후크 전후에 실행 하시겠습니까?</target>
        </trans-unit>
        <trans-unit id="58269ada070e42bd9ffb7febed75e9d2c7c689e1" translate="yes" xml:space="preserve">
          <source>Run before / after bulk update hooks?</source>
          <target state="translated">대량 업데이트 후크 전후에 실행 하시겠습니까?</target>
        </trans-unit>
        <trans-unit id="18d6ef3bc4c10e371b0cd91efbfe8df85e68a008" translate="yes" xml:space="preserve">
          <source>Run before / after create hooks for each individual Instance? BulkCreate hooks will still be run if options.hooks is true.</source>
          <target state="translated">각 개별 인스턴스에 대한 후크를 생성하기 전 / 후에 실행 하시겠습니까? options.hooks가 true이면 BulkCreate 후크가 계속 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="0b8459e34068807e1eb3c85fad215b35c650ee7e" translate="yes" xml:space="preserve">
          <source>Run before / after update hooks?. If true, this will execute a SELECT followed by individual UPDATEs. A select is needed, because the row data needs to be passed to the hooks</source>
          <target state="translated">업데이트 후크 전 / 후 실행?. true이면 SELECT와 개별 UPDATE가 차례로 실행됩니다. 행 데이터를 후크로 전달해야하므로 선택이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="e5cedd10390a9d3b239800334f224886fe370712" translate="yes" xml:space="preserve">
          <source>Run before / after upsert hooks?</source>
          <target state="translated">업 서트 후크 전 / 후에 실행 하시겠습니까?</target>
        </trans-unit>
        <trans-unit id="a944f09a5a793cb75f92d040f95fa4f35da5420c" translate="yes" xml:space="preserve">
          <source>Run before and after create / update + validate hooks</source>
          <target state="translated">생성 / 업데이트 후 + 후크 확인 후 실행</target>
        </trans-unit>
        <trans-unit id="2ae7654b4055b38aa79d971e21b65027b2ca1df7" translate="yes" xml:space="preserve">
          <source>Run before and after validate hooks</source>
          <target state="translated">유효성 검사 후크 전후에 실행</target>
        </trans-unit>
        <trans-unit id="eb7bcd25188536a53fb43bbd3bb4651b7f53eae7" translate="yes" xml:space="preserve">
          <source>Run built-in type validators on insert and update, and select with where clause, e.g. validate that arguments passed to integer fields are integer-like.</source>
          <target state="translated">삽입 및 업데이트시 내장 유형 유효성 검증기를 실행하고 where 절을 선택하십시오. 예를 들어 정수 필드에 전달 된 인수가 정수와 같은지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="b6577a96503f5049bd73f30cf24b51eebe5f6b78" translate="yes" xml:space="preserve">
          <source>Run validation for the join model</source>
          <target state="translated">조인 모델에 대한 유효성 검사 실행</target>
        </trans-unit>
        <trans-unit id="85489a3587bf76a40730b08a2f8006ba1c2c454c" translate="yes" xml:space="preserve">
          <source>Run validation for the join model.</source>
          <target state="translated">결합 모델에 대한 유효성 검증을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="8b1ee002e28b50380a23fec36c627e6248c45e67" translate="yes" xml:space="preserve">
          <source>Run validations before the row is inserted</source>
          <target state="translated">행이 삽입되기 전에 유효성 검사를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="309084555a84115c15bd76ae9ab2d30a30649897" translate="yes" xml:space="preserve">
          <source>Running Migrations</source>
          <target state="translated">마이그레이션 실행</target>
        </trans-unit>
        <trans-unit id="c58ea185833c0872e448165cd1c7703ab76a90b8" translate="yes" xml:space="preserve">
          <source>Running Seeds</source>
          <target state="translated">씨앗을 실행</target>
        </trans-unit>
        <trans-unit id="a4942c26d0735947d8a22a2fbe2735a12e381808" translate="yes" xml:space="preserve">
          <source>SELECT</source>
          <target state="translated">SELECT</target>
        </trans-unit>
        <trans-unit id="d5a57bf501dacfbda90f27fd318b8cd457a96a1b" translate="yes" xml:space="preserve">
          <source>SERIALIZABLE</source>
          <target state="translated">SERIALIZABLE</target>
        </trans-unit>
        <trans-unit id="a9b25d35e6e01edfdd65178492d182aba6d34218" translate="yes" xml:space="preserve">
          <source>SET NULL if foreignKey allows nulls, CASCADE if otherwise</source>
          <target state="translated">foreignKey가 널을 허용하면 SET NULL, 그렇지 않으면 CASCADE</target>
        </trans-unit>
        <trans-unit id="516cdbb3e5db4db95fd51e4b0171ee222656aff6" translate="yes" xml:space="preserve">
          <source>SET NULL if foreignKey allows nulls, NO ACTION if otherwise</source>
          <target state="translated">foreignKey가 널을 허용하면 NULL을, 그렇지 않으면 NO ACTION을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="4171eb087f6af62c707c7159e3b00d2346badde5" translate="yes" xml:space="preserve">
          <source>SET_DEFERRED</source>
          <target state="translated">SET_DEFERRED</target>
        </trans-unit>
        <trans-unit id="68149187501fb70315f6e8131bbf9fe48348ed17" translate="yes" xml:space="preserve">
          <source>SET_IMMEDIATE</source>
          <target state="translated">SET_IMMEDIATE</target>
        </trans-unit>
        <trans-unit id="dd19b86ae45a271261a2769df9693b7eeeac1d33" translate="yes" xml:space="preserve">
          <source>SHARE</source>
          <target state="translated">SHARE</target>
        </trans-unit>
        <trans-unit id="212e619789f81c3e0d20848be5f4e29b8020d588" translate="yes" xml:space="preserve">
          <source>SHOWCONSTRAINTS</source>
          <target state="translated">SHOWCONSTRAINTS</target>
        </trans-unit>
        <trans-unit id="f7b0cacf516079a8ab39ad0cda85a7099d7671b2" translate="yes" xml:space="preserve">
          <source>SHOWINDEXES</source>
          <target state="translated">SHOWINDEXES</target>
        </trans-unit>
        <trans-unit id="e786763f51c96fb966cfe9993f619969600fcb2d" translate="yes" xml:space="preserve">
          <source>SHOWTABLES</source>
          <target state="translated">SHOWTABLES</target>
        </trans-unit>
        <trans-unit id="9e170c7c7025a1a5f7c3857f8315cf4ac6db1d72" translate="yes" xml:space="preserve">
          <source>SMALLINT</source>
          <target state="translated">SMALLINT</target>
        </trans-unit>
        <trans-unit id="f956ed3dc3c576285c7137ae67e24c69f9266d1d" translate="yes" xml:space="preserve">
          <source>SNAPSHOT</source>
          <target state="translated">SNAPSHOT</target>
        </trans-unit>
        <trans-unit id="fb9477462cfa5f60b14431efb98e90a54887f14e" translate="yes" xml:space="preserve">
          <source>SQL type of function returned value</source>
          <target state="translated">SQL 유형의 함수 리턴 값</target>
        </trans-unit>
        <trans-unit id="9f09ccbd1cfb65aced3eb531305e671e40b95dd3" translate="yes" xml:space="preserve">
          <source>SQLite</source>
          <target state="translated">SQLite</target>
        </trans-unit>
        <trans-unit id="b751b9c16bf3667739f71a4e1c056e70944f0120" translate="yes" xml:space="preserve">
          <source>SQLite - Implemented as two queries &lt;code&gt;INSERT; UPDATE&lt;/code&gt;. This means that the update is executed regardless of whether the row already existed or not</source>
          <target state="translated">SQLite-두 개의 쿼리로 구현 &lt;code&gt;INSERT; UPDATE&lt;/code&gt; . 이것은 행이 이미 존재하는지 여부에 관계없이 업데이트가 실행됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="a8a49373e558b330f8e5de9758985b51cabb5a28" translate="yes" xml:space="preserve">
          <source>SQLite - Implemented with ON CONFLICT DO UPDATE</source>
          <target state="translated">SQLite-ON CONFLICT DO UPDATE로 구현 됨</target>
        </trans-unit>
        <trans-unit id="7414960c46b50149ed7277c81e08f989b9357681" translate="yes" xml:space="preserve">
          <source>SQLite does not support directly altering and removing columns. However, Sequelize will try to work around this by recreating the whole table with the help of a backup table, inspired by &lt;a href=&quot;https://www.sqlite.org/lang_altertable.html#otheralter&quot;&gt;these instructions&lt;/a&gt;.</source>
          <target state="translated">SQLite는 열을 직접 변경하고 제거하는 것을 지원하지 않습니다. 그러나 Sequelize는 &lt;a href=&quot;https://www.sqlite.org/lang_altertable.html#otheralter&quot;&gt;이러한 지침&lt;/a&gt; 에서 영감을 얻은 백업 테이블을 사용하여 전체 테이블을 다시 생성하여이 문제를 해결하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="bcc5ada19f228b8cede55dd41e9efd63dd987f05" translate="yes" xml:space="preserve">
          <source>SQLiteQueryInterface</source>
          <target state="translated">SQLiteQueryInterface</target>
        </trans-unit>
        <trans-unit id="adfd5586a4984b594806377be1a9f4e09a8df4c1" translate="yes" xml:space="preserve">
          <source>SRID of type</source>
          <target state="translated">유형의 SRID</target>
        </trans-unit>
        <trans-unit id="da5aba16204ebd88821d2bbf3642268c4231fb1f" translate="yes" xml:space="preserve">
          <source>STRING</source>
          <target state="translated">STRING</target>
        </trans-unit>
        <trans-unit id="1d61ec39e663f6e58702a7ad1738531fa768fb9c" translate="yes" xml:space="preserve">
          <source>STRING A variable length string</source>
          <target state="translated">STRING 가변 길이 문자열</target>
        </trans-unit>
        <trans-unit id="d41f19dfee39725e336978083f9a8c5f6b3be7a4" translate="yes" xml:space="preserve">
          <source>STRING#constructor</source>
          <target state="translated">STRING#constructor</target>
        </trans-unit>
        <trans-unit id="6603d87ef55eb6808e20bbf90a7b7b84d4c9549a" translate="yes" xml:space="preserve">
          <source>Saving only some fields</source>
          <target state="translated">일부 필드 만 저장</target>
        </trans-unit>
        <trans-unit id="0bf4823535962139cb43d7dd88554175707982d1" translate="yes" xml:space="preserve">
          <source>Schema name to create</source>
          <target state="translated">작성할 스키마 이름</target>
        </trans-unit>
        <trans-unit id="6c80a5b04edfdb2a6f83ba6280a271386f52ac29" translate="yes" xml:space="preserve">
          <source>Schema name to drop</source>
          <target state="translated">제거 할 스키마 이름</target>
        </trans-unit>
        <trans-unit id="6e28871105300b1a9e39344d8c2f862f59f05a20" translate="yes" xml:space="preserve">
          <source>Scope Error.</source>
          <target state="translated">범위 오류.</target>
        </trans-unit>
        <trans-unit id="89f9f3e1b3d3732f4f20df80017d0f8219871f92" translate="yes" xml:space="preserve">
          <source>Scope Error. Thrown when the sequelize cannot query the specified scope.</source>
          <target state="translated">범위 오류. 후행이 지정된 범위를 쿼리 할 수 ​​없을 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c23540e5fb551edff0ac95649a1d551f9736d55e" translate="yes" xml:space="preserve">
          <source>Scopes</source>
          <target state="translated">Scopes</target>
        </trans-unit>
        <trans-unit id="0da8a5956aaa3c85b91d3f215267b4fade7bdd85" translate="yes" xml:space="preserve">
          <source>Scopes apply to &lt;code&gt;.find&lt;/code&gt;, &lt;code&gt;.findAll&lt;/code&gt;, &lt;code&gt;.count&lt;/code&gt;, &lt;code&gt;.update&lt;/code&gt;, &lt;code&gt;.increment&lt;/code&gt; and &lt;code&gt;.destroy&lt;/code&gt;.</source>
          <target state="translated">스코프에 적용 &lt;code&gt;.find&lt;/code&gt; , &lt;code&gt;.findAll&lt;/code&gt; , &lt;code&gt;.count&lt;/code&gt; , &lt;code&gt;.update&lt;/code&gt; 를 , &lt;code&gt;.increment&lt;/code&gt; 및 &lt;code&gt;.destroy&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="7e8a81b0184917a8413801eb97f5c4f1a30e16de" translate="yes" xml:space="preserve">
          <source>Scopes are applied by calling &lt;code&gt;.scope&lt;/code&gt; on the model definition, passing the name of one or more scopes. &lt;code&gt;.scope&lt;/code&gt; returns a fully functional model instance with all the regular methods: &lt;code&gt;.findAll&lt;/code&gt;, &lt;code&gt;.update&lt;/code&gt;, &lt;code&gt;.count&lt;/code&gt;, &lt;code&gt;.destroy&lt;/code&gt; etc. You can save this model instance and reuse it later:</source>
          <target state="translated">범위는 모델 정의에서 &lt;code&gt;.scope&lt;/code&gt; 를 호출하여 적용되며 하나 이상의 범위 이름을 전달합니다. &lt;code&gt;.scope&lt;/code&gt; 는 &lt;code&gt;.findAll&lt;/code&gt; , &lt;code&gt;.update&lt;/code&gt; , &lt;code&gt;.count&lt;/code&gt; , .destroy 등 모든 일반 메소드가 포함 된 완전한 기능의 모델 인스턴스를 리턴 &lt;code&gt;.destroy&lt;/code&gt; .이 모델 인스턴스를 저장 한 후 나중에 다시 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="120923523c35c563d8ac081091bf3511da3a4321" translate="yes" xml:space="preserve">
          <source>Scopes are defined in the model definition and can be finder objects, or functions returning finder objects - except for the default scope, which can only be an object:</source>
          <target state="translated">범위는 모델 정의에 정의되며 파인더 오브젝트 또는 파인더 오브젝트를 리턴하는 함수일 수 있습니다 (기본 범위를 제외하고 오브젝트 만 가능).</target>
        </trans-unit>
        <trans-unit id="12dfb7ac24f373f024f55f1e302c2795557633b3" translate="yes" xml:space="preserve">
          <source>Scopes are used to help you reuse code. You can define commonly used queries, specifying options such as &lt;code&gt;where&lt;/code&gt;, &lt;code&gt;include&lt;/code&gt;, &lt;code&gt;limit&lt;/code&gt;, etc.</source>
          <target state="translated">범위는 코드를 재사용하는 데 사용됩니다. 일반적으로 사용되는 쿼리를 정의하여 &lt;code&gt;where&lt;/code&gt; , &lt;code&gt;include&lt;/code&gt; , &lt;code&gt;limit&lt;/code&gt; 등과 같은 옵션을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c3a5b1f2c5fdd9c8b47aa2b2dc6c11a18f6dd918" translate="yes" xml:space="preserve">
          <source>Scopes which are functions can be invoked in two ways. If the scope does not take any arguments it can be invoked as normally. If the scope takes arguments, pass an object:</source>
          <target state="translated">함수 인 스코프는 두 가지 방법으로 호출 할 수 있습니다. 범위가 인수를 취하지 않으면 정상적으로 호출 될 수 있습니다. 범위가 인수를 사용하는 경우 객체를 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="a39e965661725cc234f9253f0b7566cfa5aa18e4" translate="yes" xml:space="preserve">
          <source>Scoping allows you to define commonly used queries that you can easily use later. Scopes can include all the same attributes as regular finders, &lt;code&gt;where&lt;/code&gt;, &lt;code&gt;include&lt;/code&gt;, &lt;code&gt;limit&lt;/code&gt; etc.</source>
          <target state="translated">범위를 지정하면 나중에 쉽게 사용할 수있는 일반적으로 사용되는 쿼리를 정의 할 수 있습니다. 범위에는 일반 파인더와 동일한 속성이 모두 포함될 수 있습니다. &lt;code&gt;where&lt;/code&gt; , &lt;code&gt;include&lt;/code&gt; , &lt;code&gt;limit&lt;/code&gt; 등</target>
        </trans-unit>
        <trans-unit id="28a2e804b07e3185be2ca5de143ec18a821eeacf" translate="yes" xml:space="preserve">
          <source>Search for a single instance by its primary key._</source>
          <target state="translated">기본 키로 단일 인스턴스를 검색하십시오 ._</target>
        </trans-unit>
        <trans-unit id="fab27cb2bedf60f526ca0afd3fc62f8ddebfb13b" translate="yes" xml:space="preserve">
          <source>Search for a single instance.</source>
          <target state="translated">단일 인스턴스를 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="225d934ab681de3de34793dda119a3d495064782" translate="yes" xml:space="preserve">
          <source>Search for a single instance. Returns the first instance found, or null if none can be found.</source>
          <target state="translated">단일 인스턴스를 검색합니다. 찾은 첫 번째 인스턴스를 반환하거나 찾을 수없는 경우 null을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="960425bfa22ad385f9c4f8d364ce932418a965ec" translate="yes" xml:space="preserve">
          <source>Search for a single instance. This applies LIMIT 1, so the listener will always be called with a single instance.</source>
          <target state="translated">단일 인스턴스를 검색하십시오. LIMIT 1이 적용되므로 리스너는 항상 단일 인스턴스로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="069d800301b1242814d076a9ba69c25a797f1f8e" translate="yes" xml:space="preserve">
          <source>Search for multiple instances.</source>
          <target state="translated">여러 인스턴스를 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="8993db7b4561dcbe3dd7ed07347b984ed185c0d8" translate="yes" xml:space="preserve">
          <source>Second, you can define multiple fields and the value you want to add to them.</source>
          <target state="translated">둘째, 여러 필드와 추가 할 값을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae5bcb47eb49c3bd9e3772d69f596bc96790ae05" translate="yes" xml:space="preserve">
          <source>Security tip</source>
          <target state="translated">보안 팁</target>
        </trans-unit>
        <trans-unit id="ec7f6561b6ed5b2dc36973b0b6a102cca134bcc5" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://github.com/chriso/validator.js&quot;&gt;the validator.js project&lt;/a&gt; for more details on the built in validation methods.</source>
          <target state="translated">참조 &lt;a href=&quot;https://github.com/chriso/validator.js&quot;&gt;validator.js 프로젝트&lt;/a&gt; 검증 방법 내장에 대한 자세한 내용을.</target>
        </trans-unit>
        <trans-unit id="07e8786ffa4a2d3cefb67f6c2682f38e69cd4492" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://github.com/sequelize/sequelize/issues/9421&quot;&gt;Issue #9421&lt;/a&gt; for the original API proposal.</source>
          <target state="translated">원래 API 제안에 대해서는 &lt;a href=&quot;https://github.com/sequelize/sequelize/issues/9421&quot;&gt;Issue # 9421&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1351883340089e7a2bcb762253ecf4041042e52a" translate="yes" xml:space="preserve">
          <source>See &lt;code&gt;Sequelize.Transaction.ISOLATION_LEVELS&lt;/code&gt; for possible options</source>
          <target state="translated">가능한 옵션 은 &lt;code&gt;Sequelize.Transaction.ISOLATION_LEVELS&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2e4393e4d3bf760304fc86105ac68898ba048a63" translate="yes" xml:space="preserve">
          <source>See &lt;code&gt;Sequelize.Transaction.TYPES&lt;/code&gt; for possible options. Sqlite only.</source>
          <target state="translated">가능한 옵션 은 &lt;code&gt;Sequelize.Transaction.TYPES&lt;/code&gt; 를 참조하십시오 . Sqlite 만.</target>
        </trans-unit>
        <trans-unit id="3d323498fbf8da4d96a2d24a82b136e39ed2843c" translate="yes" xml:space="preserve">
          <source>See &lt;code&gt;save&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;save&lt;/code&gt; 참조</target>
        </trans-unit>
        <trans-unit id="ace885d5833656cb1c6adb455769af99c14b9057" translate="yes" xml:space="preserve">
          <source>See &lt;code&gt;set&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;set&lt;/code&gt; 참조</target>
        </trans-unit>
        <trans-unit id="024d73cf82d16e67fc37c547b52a0b71943ce794" translate="yes" xml:space="preserve">
          <source>See aggregate</source>
          <target state="translated">집계 참조</target>
        </trans-unit>
        <trans-unit id="4bd3fe9b400efeaa997586b22cc7de7636c4dc47" translate="yes" xml:space="preserve">
          <source>See findAll options</source>
          <target state="translated">찾기 모든 옵션보기</target>
        </trans-unit>
        <trans-unit id="c877fd0b0a721c9f9e045768cc3bad7950900f4d" translate="yes" xml:space="preserve">
          <source>See more options in the &lt;a href=&quot;../class/lib/sequelize.js~sequelize#instance-method-query&quot;&gt;query API reference&lt;/a&gt;. Some examples below:</source>
          <target state="translated">&lt;a href=&quot;../class/lib/sequelize.js~sequelize#instance-method-query&quot;&gt;쿼리 API 참조&lt;/a&gt; 에서 추가 옵션을 참조하십시오 . 아래 몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="08972524702175fe19fd37edd1803cbf7b0ece47" translate="yes" xml:space="preserve">
          <source>See more options in the &lt;a href=&quot;../class/lib/sequelize.js~sequelize#instance-method-query&quot;&gt;query API reference&lt;/a&gt;. Some examples:</source>
          <target state="translated">&lt;a href=&quot;../class/lib/sequelize.js~sequelize#instance-method-query&quot;&gt;쿼리 API 참조&lt;/a&gt; 에서 더 많은 옵션을 확인하세요 . 몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="497dea2253a9763272c1d3ca91776ece14a847f1" translate="yes" xml:space="preserve">
          <source>See:</source>
          <target state="translated">See:</target>
        </trans-unit>
        <trans-unit id="70fdde700db9f86cb1ddf1248d1df7f946f66ee1" translate="yes" xml:space="preserve">
          <source>Seed Storage</source>
          <target state="translated">종자 저장</target>
        </trans-unit>
        <trans-unit id="e0b6db6ffee2cbd17752e8f5ccec39fea1096673" translate="yes" xml:space="preserve">
          <source>Seeders can be undone if they are using any storage. There are two commands available for that:</source>
          <target state="translated">시더는 스토리지를 사용하는 경우 취소 할 수 있습니다. 사용할 수있는 두 가지 명령이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5746f22dcc2f068faa833d6223ba0cc62b54931a" translate="yes" xml:space="preserve">
          <source>Select all the attributes of the model, except some few. Useful for security purposes e.g. &lt;code&gt;{ attributes: { exclude: ['password'] } }&lt;/code&gt;</source>
          <target state="translated">몇 가지를 제외하고 모델의 모든 속성을 선택하십시오. 보안 목적에 유용합니다. 예 : &lt;code&gt;{ attributes: { exclude: ['password'] } }&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="41a8019f87ab381882d8e3b6b81923fda67be63c" translate="yes" xml:space="preserve">
          <source>Select all the attributes of the model, plus some additional ones. Useful for aggregations, e.g. &lt;code&gt;{ attributes: { include: [[sequelize.fn('COUNT', sequelize.col('id')), 'total']] }&lt;/code&gt;</source>
          <target state="translated">모델의 모든 속성과 추가 속성을 선택하십시오. &lt;code&gt;{ attributes: { include: [[sequelize.fn('COUNT', sequelize.col('id')), 'total']] }&lt;/code&gt; 과 같은 집계에 유용합니다 .}</target>
        </trans-unit>
        <trans-unit id="c6732c95c68478e2f790e245cf6016ea51c74c83" translate="yes" xml:space="preserve">
          <source>Self-references</source>
          <target state="translated">Self-references</target>
        </trans-unit>
        <trans-unit id="32248b4544c4dacee860f46416e5a89b6310bc5c" translate="yes" xml:space="preserve">
          <source>Sequelize</source>
          <target state="translated">Sequelize</target>
        </trans-unit>
        <trans-unit id="e2146c89a9fedc9608681248e18eec20d2a15b61" translate="yes" xml:space="preserve">
          <source>Sequelize CLI can read from both &lt;code&gt;JSON&lt;/code&gt; and &lt;code&gt;JS&lt;/code&gt; files. This can be setup with &lt;code&gt;.sequelizerc&lt;/code&gt; file. Let see how</source>
          <target state="translated">Sequelize CLI는 &lt;code&gt;JSON&lt;/code&gt; 및 &lt;code&gt;JS&lt;/code&gt; 파일 모두에서 읽을 수 있습니다. &lt;code&gt;.sequelizerc&lt;/code&gt; 파일 로 설정할 수 있습니다 . 방법을 보자</target>
        </trans-unit>
        <trans-unit id="d4e7d933f4662f9cc8cb13c8bed0106857a7e2e5" translate="yes" xml:space="preserve">
          <source>Sequelize Models are ES6 classes. You can very easily add custom instance or class level methods.</source>
          <target state="translated">Sequelize Model은 ES6 클래스입니다. 사용자 정의 인스턴스 또는 클래스 레벨 메소드를 매우 쉽게 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42cba3a975a7135ac3fdb91096b3ca70b1caed5b" translate="yes" xml:space="preserve">
          <source>Sequelize allow setting &lt;code&gt;underscored&lt;/code&gt; option for Model. When &lt;code&gt;true&lt;/code&gt; this option will set the &lt;code&gt;field&lt;/code&gt; option on all attributes to the underscored version of its name. This also applies to foreign keys generated by associations.</source>
          <target state="translated">Sequelize에서는 모델에 &lt;code&gt;underscored&lt;/code&gt; 옵션을 설정할 수 있습니다. 때 &lt;code&gt;true&lt;/code&gt; 이 옵션을 설정합니다 &lt;code&gt;field&lt;/code&gt; 이름의 밑줄 버전의 모든 속성에 대한 옵션을 선택합니다. 이는 연결에 의해 생성 된 외래 키에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="3618d92886b90e0ab93af574f3df0c6f87d7dfdb" translate="yes" xml:space="preserve">
          <source>Sequelize allows setting specific strings as aliases for operators. With v5 this will give you deprecation warning.</source>
          <target state="translated">Sequelize를 사용하면 특정 문자열을 연산자의 별칭으로 설정할 수 있습니다. v5에서는 사용 중단 경고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e67ff8f8de729991374c4de2ad1b647275010096" translate="yes" xml:space="preserve">
          <source>Sequelize allows you to define custom getters and setters for the attributes of your models.</source>
          <target state="translated">Sequelize를 사용하면 모델 속성에 대한 사용자 지정 getter 및 setter를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7fa83584a140dfdc1fd34f4ed3d5152c948a0ca" translate="yes" xml:space="preserve">
          <source>Sequelize also allows you to specify the so-called &lt;em&gt;virtual attributes&lt;/em&gt;, which are attributes on the Sequelize Model that doesn't really exist in the underlying SQL table, but instead are populated automatically by Sequelize. They are very useful for simplifying code, for example.</source>
          <target state="translated">Sequelize를 사용하면 기본 SQL 테이블에 실제로 존재하지 않지만 대신 Sequelize에 의해 자동으로 채워지는 Sequelize Model의 속성 인 소위 &lt;em&gt;가상 속성&lt;/em&gt; 을 지정할 수 있습니다 . 예를 들어 코드를 단순화하는 데 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="e1a257d276e4f1e9e9194ab2befc2ae82a6fdc63" translate="yes" xml:space="preserve">
          <source>Sequelize also defines by default the fields &lt;code&gt;id&lt;/code&gt; (primary key), &lt;code&gt;createdAt&lt;/code&gt; and &lt;code&gt;updatedAt&lt;/code&gt; to every model. This behavior can also be changed, of course (check the API Reference to learn more about the available options).</source>
          <target state="translated">Sequelize는 기본적 으로 모든 모델에 대해 &lt;code&gt;id&lt;/code&gt; 필드 (기본 키), &lt;code&gt;createdAt&lt;/code&gt; 및 &lt;code&gt;updatedAt&lt;/code&gt; 를 정의합니다. 물론이 동작은 변경 될 수 있습니다 (사용 가능한 옵션에 대한 자세한 내용은 API 참조를 확인하십시오).</target>
        </trans-unit>
        <trans-unit id="a7283a25617e814845f4a4d29db64847d713c510" translate="yes" xml:space="preserve">
          <source>Sequelize also provides a few utility methods.</source>
          <target state="translated">Sequelize는 또한 몇 가지 유틸리티 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6c2349fee8ab637ec3b4222a7f2831bb19e007b9" translate="yes" xml:space="preserve">
          <source>Sequelize also provides the &lt;code&gt;getterMethods&lt;/code&gt; and &lt;code&gt;setterMethods&lt;/code&gt; options in the model definition to specify things that look like, but aren't exactly the same as, virtual attributes. This usage is discouraged and likely to be deprecated in the future (in favor of using virtual attributes directly).</source>
          <target state="translated">Sequelize는 모델 정의에서 &lt;code&gt;getterMethods&lt;/code&gt; 및 &lt;code&gt;setterMethods&lt;/code&gt; 옵션을 제공하여 가상 속성과 완전히 동일하지는 않지만 모양을 지정합니다. 이 사용법은 권장되지 않으며 향후에는 더 이상 사용되지 않을 수 있습니다 (가상 속성을 직접 사용하는 편이 낫습니다).</target>
        </trans-unit>
        <trans-unit id="c99632ff3d81a4a53ca5d45d74382bd890a7d1d2" translate="yes" xml:space="preserve">
          <source>Sequelize also provides the &lt;code&gt;max&lt;/code&gt;, &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;sum&lt;/code&gt; convenience methods.</source>
          <target state="translated">Sequelize는 &lt;code&gt;max&lt;/code&gt; , &lt;code&gt;min&lt;/code&gt; 및 &lt;code&gt;sum&lt;/code&gt; 편의 방법 도 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="721ff79958c22990fcc428727c9a1a0b30bc8dc9" translate="yes" xml:space="preserve">
          <source>Sequelize constructor</source>
          <target state="translated">시퀀시 생성자</target>
        </trans-unit>
        <trans-unit id="24d7c694a73cdc3eeb5ec4017ce4eca12ad981e1" translate="yes" xml:space="preserve">
          <source>Sequelize does not use &lt;a href=&quot;https://en.wikipedia.org/wiki/Database_transaction&quot;&gt;transactions&lt;/a&gt; by default. However, for production-ready usage of Sequelize, you should definitely configure Sequelize to use transactions.</source>
          <target state="translated">Sequelize는 기본적으로 &lt;a href=&quot;https://en.wikipedia.org/wiki/Database_transaction&quot;&gt;트랜잭션&lt;/a&gt; 을 사용하지 않습니다 . 그러나 프로덕션 준비가 완료된 Sequelize를 사용하려면 트랜잭션을 사용하도록 Sequelize를 구성해야합니다.</target>
        </trans-unit>
        <trans-unit id="7b4a61bf7618bb5f80a735c5adcc86dc7d0d54b9" translate="yes" xml:space="preserve">
          <source>Sequelize doesn't create new datatypes in the database. This tutorial explains how to make Sequelize recognize new datatypes and assumes that those new datatypes are already created in the database.</source>
          <target state="translated">Sequelize는 데이터베이스에서 새 데이터 유형을 만들지 않습니다. 이 학습서에서는 Sequelize가 새 데이터 유형을 인식하도록하는 방법을 설명하고 해당 새 데이터 유형이 데이터베이스에 이미 작성되어 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="4d7b6d0de168876f640bde5fff3cf527c4f93ef6" translate="yes" xml:space="preserve">
          <source>Sequelize exposes symbol operators that can be used for to create more complex comparisons -</source>
          <target state="translated">Sequelize는보다 복잡한 비교를 생성하는 데 사용할 수있는 기호 연산자를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bfdf0968a46e379a3d919cbabea542fb8b4773b7" translate="yes" xml:space="preserve">
          <source>Sequelize follows &lt;a href=&quot;http://semver.org&quot;&gt;SEMVER&lt;/a&gt;. Supports Node v10 and above to use ES6 features.</source>
          <target state="translated">Sequelize는 &lt;a href=&quot;http://semver.org&quot;&gt;SEMVER를 따릅니다&lt;/a&gt; . ES6 기능을 사용하기 위해 Node v10 이상을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="9553b2e551700f9228e5e33503732bd3e890c940" translate="yes" xml:space="preserve">
          <source>Sequelize follows &lt;a href=&quot;http://semver.org&quot;&gt;Semantic Versioning&lt;/a&gt; and supports Node v10 and above.</source>
          <target state="translated">Sequelize는 &lt;a href=&quot;http://semver.org&quot;&gt;Semantic Versioning을&lt;/a&gt; 따르며 Node v10 이상을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="582d78da6df00a995534b3b583b979009f68d4d2" translate="yes" xml:space="preserve">
          <source>Sequelize has a &lt;a href=&quot;https://github.com/sequelize/umzug&quot;&gt;sister library&lt;/a&gt; for programmatically handling execution and logging of migration tasks.</source>
          <target state="translated">Sequelize에는 프로그래밍 방식으로 마이그레이션 작업의 실행 및 로깅을 처리하기위한 &lt;a href=&quot;https://github.com/sequelize/umzug&quot;&gt;자매 라이브러리&lt;/a&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f211261e93475264da544d79e18f72b323197b2" translate="yes" xml:space="preserve">
          <source>Sequelize has a lot of options for querying. You will learn more about those in the next tutorials. It is also possible to make raw SQL queries, if you really need them.</source>
          <target state="translated">Sequelize에는 많은 쿼리 옵션이 있습니다. 다음 자습서에서 이에 대해 자세히 알아볼 것입니다. 실제로 필요한 경우 원시 SQL 쿼리를 만들 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5addf9f0817496dae9091c6a5c7b6b1de25287de" translate="yes" xml:space="preserve">
          <source>Sequelize has a sister library called &lt;a href=&quot;https://github.com/sequelize/umzug&quot;&gt;umzug&lt;/a&gt; for programmatically handling execution and logging of migration tasks.</source>
          <target state="translated">Sequelize라는 자매 라이브러리가 &lt;a href=&quot;https://github.com/sequelize/umzug&quot;&gt;umzug&lt;/a&gt; 프로그램 마이그레이션 작업의 실행 및 로깅을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="108e561a9933198611f3c2e6a92b1f02917b1b75" translate="yes" xml:space="preserve">
          <source>Sequelize has built-in support for optimistic locking through a model instance version count.</source>
          <target state="translated">Sequelize는 모델 인스턴스 버전 수를 통해 낙관적 잠금을 기본적으로 지원합니다.</target>
        </trans-unit>
        <trans-unit id="7263ca838cabf21a169aeceea9b8f1d1793343c6" translate="yes" xml:space="preserve">
          <source>Sequelize has built-in support for optimistic locking through a model instance version count. Optimistic locking is disabled by default and can be enabled by setting the &lt;code&gt;version&lt;/code&gt; property to true in a specific model definition or global model configuration. See &lt;a href=&quot;models-definition#configuration&quot;&gt;model configuration&lt;/a&gt; for more details.</source>
          <target state="translated">Sequelize는 모델 인스턴스 버전 수를 통한 낙관적 잠금을 기본적으로 지원합니다. 낙관적 잠금은 기본적으로 비활성화 되어 있으며 특정 모델 정의 또는 전역 모델 구성에서 &lt;code&gt;version&lt;/code&gt; 속성을 true 로 설정하여 활성화 할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;models-definition#configuration&quot;&gt;모델 구성&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4a8d11578adeef3bffa53be612d3c8ec4ca15c7f" translate="yes" xml:space="preserve">
          <source>Sequelize has two different but related scope concepts in relation to associations. The difference is subtle but important:</source>
          <target state="translated">Sequelize에는 연관성과 관련하여 서로 다른 두 가지 범위 개념이 있습니다. 차이점은 미묘하지만 중요합니다.</target>
        </trans-unit>
        <trans-unit id="c40c938deeeea8ed24d2fdf4e8f7d338f862e48c" translate="yes" xml:space="preserve">
          <source>Sequelize is a promise-based Node.js &lt;a href=&quot;https://en.wikipedia.org/wiki/Object-relational_mapping&quot;&gt;ORM&lt;/a&gt; for &lt;a href=&quot;https://en.wikipedia.org/wiki/PostgreSQL&quot;&gt;Postgres&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/MySQL&quot;&gt;MySQL&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/MariaDB&quot;&gt;MariaDB&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/SQLite&quot;&gt;SQLite&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/Microsoft_SQL_Server&quot;&gt;Microsoft SQL Server&lt;/a&gt;. It features solid transaction support, relations, eager and lazy loading, read replication and more.</source>
          <target state="translated">Sequelize는 &lt;a href=&quot;https://en.wikipedia.org/wiki/PostgreSQL&quot;&gt;Postgres&lt;/a&gt; , &lt;a href=&quot;https://en.wikipedia.org/wiki/MySQL&quot;&gt;MySQL&lt;/a&gt; , &lt;a href=&quot;https://en.wikipedia.org/wiki/MariaDB&quot;&gt;MariaDB&lt;/a&gt; , &lt;a href=&quot;https://en.wikipedia.org/wiki/SQLite&quot;&gt;SQLite&lt;/a&gt; 및 &lt;a href=&quot;https://en.wikipedia.org/wiki/Microsoft_SQL_Server&quot;&gt;Microsoft SQL Server를&lt;/a&gt; 위한 약속 기반 Node.js &lt;a href=&quot;https://en.wikipedia.org/wiki/Object-relational_mapping&quot;&gt;ORM&lt;/a&gt; 입니다 . 견고한 트랜잭션 지원, 관계, eager 및 lazy로드, 읽기 복제 등을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4ba21fa010de136fd468609c0c7c0382ac4107cd" translate="yes" xml:space="preserve">
          <source>Sequelize is a promise-based Node.js ORM for Postgres, MySQL, MariaDB, SQLite and Microsoft SQL Server. It features solid transaction support, relations, eager and lazy loading, read replication and more.</source>
          <target state="translated">Sequelize는 Postgres, MySQL, MariaDB, SQLite 및 Microsoft SQL Server를위한 약속 기반 Node.js ORM입니다. 견고한 트랜잭션 지원, 관계, 열성 및 지연 로딩, 읽기 복제 등이 특징입니다.</target>
        </trans-unit>
        <trans-unit id="4f3657d8fd42ca903f769974a0aa3a98de7ae752" translate="yes" xml:space="preserve">
          <source>Sequelize is available via &lt;a href=&quot;https://www.npmjs.com/package/sequelize&quot;&gt;npm&lt;/a&gt; (or &lt;a href=&quot;https://yarnpkg.com/package/sequelize&quot;&gt;yarn&lt;/a&gt;).</source>
          <target state="translated">Sequelize는 &lt;a href=&quot;https://www.npmjs.com/package/sequelize&quot;&gt;npm&lt;/a&gt; (또는 &lt;a href=&quot;https://yarnpkg.com/package/sequelize&quot;&gt;원사&lt;/a&gt; )을 통해 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="18b9d1b705db8b8f2a74b7b8fef93c710c1730a2" translate="yes" xml:space="preserve">
          <source>Sequelize is independent from specific dialects. This means that you'll have to install the respective connector library to your project yourself.</source>
          <target state="translated">후유증은 특정 방언과 무관합니다. 즉, 해당 커넥터 라이브러리를 프로젝트에 직접 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="4a6b2a1acf807c379b8c8b09642b38a4ae6ec2eb" translate="yes" xml:space="preserve">
          <source>Sequelize provides a host of custom error classes, to allow you to do easier debugging.</source>
          <target state="translated">Sequelize는 더 쉽게 디버깅 할 수 있도록 다양한 사용자 정의 오류 클래스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2aa8bb1c410e7760da89fe1a39dd3cd6a3e6c8b6" translate="yes" xml:space="preserve">
          <source>Sequelize provides a host of custom error classes, to allow you to do easier debugging. All of these errors are exposed on the sequelize object and the sequelize constructor. All sequelize errors inherit from the base JS error object.</source>
          <target state="translated">Sequelize는 더 쉽게 디버깅 할 수 있도록 다양한 사용자 정의 오류 클래스를 제공합니다. 이러한 모든 오류는 sequelize 객체와 sequelize 생성자에 노출됩니다. 모든 연속 오류는 기본 JS 오류 객체에서 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="94018d006810918283a00d3d9a2d135055985f27" translate="yes" xml:space="preserve">
          <source>Sequelize provides a lot of hooks. The full list can be found in directly in the &lt;a href=&quot;https://github.com/sequelize/sequelize/blob/v6/lib/hooks.js#L7&quot;&gt;source code - lib/hooks.js&lt;/a&gt;.</source>
          <target state="translated">Sequelize는 많은 후크를 제공합니다. 전체 목록은 &lt;a href=&quot;https://github.com/sequelize/sequelize/blob/v6/lib/hooks.js#L7&quot;&gt;소스 코드 lib / hooks.js&lt;/a&gt; 에서 직접 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a36909b9f875b9c379cfbfd57865704470509efb" translate="yes" xml:space="preserve">
          <source>Sequelize provides four hooks that are executed immediately before and after a database connection is obtained or released:</source>
          <target state="translated">Sequelize는 데이터베이스 연결을 얻거나 해제하기 직전과 직후에 실행되는 네 가지 후크를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="416453c32fbb9086481adb8012b4a2a942dcd640" translate="yes" xml:space="preserve">
          <source>Sequelize provides several operators.</source>
          <target state="translated">Sequelize는 여러 연산자를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b85b1055bffb1d486111fcba76a311a6af00793d" translate="yes" xml:space="preserve">
          <source>Sequelize provides the &lt;a href=&quot;../class/lib/model.js~model#static-method-create&quot;&gt;&lt;code&gt;create&lt;/code&gt;&lt;/a&gt; method, which combines the &lt;code&gt;build&lt;/code&gt; and &lt;code&gt;save&lt;/code&gt; methods shown above into a single method:</source>
          <target state="translated">Sequelize는 위에 표시된 &lt;code&gt;build&lt;/code&gt; 및 &lt;code&gt;save&lt;/code&gt; 메서드를 단일 메서드로 결합 하는 &lt;a href=&quot;../class/lib/model.js~model#static-method-create&quot;&gt; &lt;code&gt;create&lt;/code&gt; &lt;/a&gt; 메서드를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="9c4623df5becd955bad4abf90690b10394e8952d" translate="yes" xml:space="preserve">
          <source>Sequelize provides the &lt;code&gt;Model.bulkCreate&lt;/code&gt; method to allow creating multiple records at once, with only one query.</source>
          <target state="translated">Sequelize는 단 하나의 쿼리로 한 번에 여러 레코드를 만들 수 있는 &lt;code&gt;Model.bulkCreate&lt;/code&gt; 메서드를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="2306a41d83e4d67899465fe2766041f59728387d" translate="yes" xml:space="preserve">
          <source>Sequelize provides the &lt;code&gt;order&lt;/code&gt; and &lt;code&gt;group&lt;/code&gt; options to work with &lt;code&gt;ORDER BY&lt;/code&gt; and &lt;code&gt;GROUP BY&lt;/code&gt;.</source>
          <target state="translated">Sequelize는 &lt;code&gt;ORDER BY&lt;/code&gt; 및 &lt;code&gt;GROUP BY&lt;/code&gt; 작업을 위한 &lt;code&gt;order&lt;/code&gt; 및 &lt;code&gt;group&lt;/code&gt; 옵션을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="61ec14df19ab3a0365bca0b9a0cdfed8e108486c" translate="yes" xml:space="preserve">
          <source>Sequelize provides the &lt;code&gt;underscored&lt;/code&gt; option for a model. When &lt;code&gt;true&lt;/code&gt;, this option will set the &lt;code&gt;field&lt;/code&gt; option on all attributes to the &lt;a href=&quot;https://en.wikipedia.org/wiki/Snake_case&quot;&gt;snake_case&lt;/a&gt; version of its name. This also applies to foreign keys automatically generated by associations and other automatically generated fields. Example:</source>
          <target state="translated">Sequelize는 모델에 &lt;code&gt;underscored&lt;/code&gt; 표시된 옵션을 제공합니다 . 때 &lt;code&gt;true&lt;/code&gt; ,이 옵션을 설정합니다 &lt;code&gt;field&lt;/code&gt; 받는 모든 속성에 대한 옵션 &lt;a href=&quot;https://en.wikipedia.org/wiki/Snake_case&quot;&gt;snake_case의&lt;/a&gt; 이름의 버전. 이는 연결 및 기타 자동 생성 필드에 의해 자동으로 생성 된 외래 키에도 적용됩니다. 예:</target>
        </trans-unit>
        <trans-unit id="f01badb3752cc4ad0cd0921e7e2e3c794d85c958" translate="yes" xml:space="preserve">
          <source>Sequelize provides various methods to assist querying your database for data.</source>
          <target state="translated">Sequelize는 데이터베이스에서 데이터를 쿼리하는 데 도움이되는 다양한 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5f1835de99c42c1a580a7570d515927f1601fddd" translate="yes" xml:space="preserve">
          <source>Sequelize supports &lt;a href=&quot;https://en.wikipedia.org/wiki/Replication_%28computing%29#Database_replication&quot;&gt;read replication&lt;/a&gt;, i.e. having multiple servers that you can connect to when you want to do a SELECT query. When you do read replication, you specify one or more servers to act as read replicas, and one server to act as the write master, which handles all writes and updates and propagates them to the replicas (note that the actual replication process is &lt;strong&gt;not&lt;/strong&gt; handled by Sequelize, but should be set up by database backend).</source>
          <target state="translated">Sequelize는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Replication_%28computing%29#Database_replication&quot;&gt;읽기 복제를&lt;/a&gt; 지원 합니다 . 즉, SELECT 쿼리를 수행 할 때 연결할 수있는 여러 서버가 있습니다. 읽기 복제를 수행 할 때 읽기 복제본으로 작동 할 하나 이상의 서버와 쓰기 마스터로 작동 할 하나의 서버를 지정하여 모든 쓰기 및 업데이트를 처리하고이를 복제본으로 전파합니다 (실제 복제 프로세스는 처리 &lt;strong&gt;되지 않음에&lt;/strong&gt; 유의하십시오). Sequelize에 의해, 그러나 데이터베이스 백엔드에 의해 설정되어야 함).</target>
        </trans-unit>
        <trans-unit id="e0048a920cbe256e0d63314bbc8a801ba350b416" translate="yes" xml:space="preserve">
          <source>Sequelize supports adding indexes to the model definition which will be created during &lt;code&gt;Model.sync()&lt;/code&gt; or &lt;code&gt;sequelize.sync&lt;/code&gt;.</source>
          <target state="translated">Sequelize는 &lt;code&gt;Model.sync()&lt;/code&gt; 또는 &lt;code&gt;sequelize.sync&lt;/code&gt; 중에 생성 될 모델 정의에 인덱스 추가를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="9ee4f3b132710b899c7915a1af601ecfa480a034" translate="yes" xml:space="preserve">
          <source>Sequelize supports adding indexes to the model definition which will be created on &lt;a href=&quot;../class/lib/sequelize.js~sequelize#instance-method-sync&quot;&gt;&lt;code&gt;sequelize.sync()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Sequelize는 &lt;a href=&quot;../class/lib/sequelize.js~sequelize#instance-method-sync&quot;&gt; &lt;code&gt;sequelize.sync()&lt;/code&gt; &lt;/a&gt; 에 생성 될 모델 정의에 인덱스 추가를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="e4b3b84765405016ac507be4f755d3663a4fd35c" translate="yes" xml:space="preserve">
          <source>Sequelize supports read replication, i.e. having multiple servers that you can connect to when you want to do a SELECT query. When you do read replication, you specify one or more servers to act as read replicas, and one server to act as the write master, which handles all writes and updates and propagates them to the replicas (note that the actual replication process is &lt;strong&gt;not&lt;/strong&gt; handled by Sequelize, but should be set up by database backend).</source>
          <target state="translated">Sequelize는 읽기 복제를 지원합니다. 예를 들어 SELECT 쿼리를 수행 할 때 연결할 수있는 여러 서버가 있습니다. 읽기 복제를 수행하면 읽기 복제본으로 작동 할 하나 이상의 서버와 쓰기 마스터로 작동 할 하나의 서버를 지정합니다.이 서버는 모든 쓰기 및 업데이트를 처리하고 복제본에 전파합니다 (실제 복제 프로세스는 처리 &lt;strong&gt;되지 않음에&lt;/strong&gt; 유의하십시오) Sequelize에 의해 작성되지만 데이터베이스 백엔드에 의해 설정되어야합니다).</target>
        </trans-unit>
        <trans-unit id="54ad37df872dbfd12881ca478a3c1d7bca6dc0e4" translate="yes" xml:space="preserve">
          <source>Sequelize supports self-referential Many-to-Many relationships, intuitively:</source>
          <target state="translated">Sequelize는 직관적으로 다음과 같은 자체 참조 다 대다 관계를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="05c45bb38a179346d4750c7be49347a10744b2b5" translate="yes" xml:space="preserve">
          <source>Sequelize supports the concept of &lt;em&gt;paranoid&lt;/em&gt; tables. A &lt;em&gt;paranoid&lt;/em&gt; table is one that, when told to delete a record, it will not truly delete it. Instead, a special column called &lt;code&gt;deletedAt&lt;/code&gt; will have its value set to the timestamp of that deletion request.</source>
          <target state="translated">Sequelize는 &lt;em&gt;편집증&lt;/em&gt; 테이블 의 개념을 지원합니다 . &lt;em&gt;편집증&lt;/em&gt; 테이블은 레코드를 삭제 말했을 때, 그것은 진정으로 삭제하지 않을 것입니다. 대신 &lt;code&gt;deletedAt&lt;/code&gt; 이라는 특수 열의 값이 해당 삭제 요청의 타임 스탬프로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="6487682acbc3ffca6c6ae45556cca7c4babb22c4" translate="yes" xml:space="preserve">
          <source>Sequelize supports the standard associations: &lt;a href=&quot;https://en.wikipedia.org/wiki/One-to-one_%28data_model%29&quot;&gt;One-To-One&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/One-to-many_%28data_model%29&quot;&gt;One-To-Many&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/Many-to-many_%28data_model%29&quot;&gt;Many-To-Many&lt;/a&gt;.</source>
          <target state="translated">Sequelize 지원하는 표준 협회 : &lt;a href=&quot;https://en.wikipedia.org/wiki/One-to-one_%28data_model%29&quot;&gt;일대일&lt;/a&gt; , &lt;a href=&quot;https://en.wikipedia.org/wiki/One-to-many_%28data_model%29&quot;&gt;일대 다&lt;/a&gt; 및 &lt;a href=&quot;https://en.wikipedia.org/wiki/Many-to-many_%28data_model%29&quot;&gt;다 대다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="006e3c87cc46067f193d6da3dab1bfcaffa32b0b" translate="yes" xml:space="preserve">
          <source>Sequelize supports two ways of using transactions:</source>
          <target state="translated">Sequelize는 트랜잭션을 사용하는 두 가지 방법을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="036964a4746f86bd146c4ce057424fa1c7bc9c18" translate="yes" xml:space="preserve">
          <source>Sequelize uses a pool to manage connections to your replicas. Internally Sequelize will maintain two pools created using &lt;code&gt;pool&lt;/code&gt; configuration.</source>
          <target state="translated">Sequelize는 풀을 사용하여 복제본에 대한 연결을 관리합니다. 내부적으로 Sequelize는 &lt;code&gt;pool&lt;/code&gt; 구성을 사용하여 생성 된 두 개의 풀을 유지 관리 합니다.</target>
        </trans-unit>
        <trans-unit id="f3e08a634ed03d6ae6ccb3b71d35f62d841795e4" translate="yes" xml:space="preserve">
          <source>Sequelize v6 is the next major release after v5</source>
          <target state="translated">Sequelize v6은 v5 이후의 다음 주요 릴리스입니다.</target>
        </trans-unit>
        <trans-unit id="169be66be748c88ca8ef373ecc4266505721850c" translate="yes" xml:space="preserve">
          <source>Sequelize v6 is the next major release after v5. Below is a list of breaking changes to help you upgrade.</source>
          <target state="translated">Sequelize v6는 v5 이후의 다음 주요 릴리스입니다. 다음은 업그레이드에 도움이되는 주요 변경 사항 목록입니다.</target>
        </trans-unit>
        <trans-unit id="ccdb0706a39fddeebf0c225ab4959b82d3aa0355" translate="yes" xml:space="preserve">
          <source>Sequelize v6 will only support Node 10 and up &lt;a href=&quot;https://github.com/sequelize/sequelize/issues/10821&quot;&gt;#10821&lt;/a&gt;</source>
          <target state="translated">Sequelize v6은 노드 10 이상 만 지원합니다 &lt;a href=&quot;https://github.com/sequelize/sequelize/issues/10821&quot;&gt;# 10821&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2b5b5c5c943c8ceec147e00a7ff05bf4f4e43edc" translate="yes" xml:space="preserve">
          <source>Sequelize v6 will only support Node 10 and up &lt;a href=&quot;https://github.com/sequelize/sequelize/issues/10821&quot;&gt;#10821&lt;/a&gt;.</source>
          <target state="translated">Sequelize v6는 Node 10 이상 &lt;a href=&quot;https://github.com/sequelize/sequelize/issues/10821&quot;&gt;# 10821&lt;/a&gt; 만 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="2c102a252e5d170808923d2726cbd5f00c38cafd" translate="yes" xml:space="preserve">
          <source>Sequelize will assume your table has a &lt;code&gt;id&lt;/code&gt; primary key property by default.</source>
          <target state="translated">Sequelize는 기본적으로 테이블에 &lt;code&gt;id&lt;/code&gt; 기본 키 속성 이 있다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="ef3f00eb6b16d4d38821f55c140a637459030ce0" translate="yes" xml:space="preserve">
          <source>Sequelize will automatically start a transaction and obtain a transaction object &lt;code&gt;t&lt;/code&gt;</source>
          <target state="translated">Sequelize 자동으로 트랜잭션을 시작하고 트랜잭션 개체 얻을 것이다 &lt;code&gt;t&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="6741146fb708be669cc08fc88bbcd0daae0ce352" translate="yes" xml:space="preserve">
          <source>Sequelize will keep the connection open by default, and use the same connection for all queries. If you need to close the connection, call &lt;code&gt;sequelize.close()&lt;/code&gt; (which is asynchronous and returns a Promise).</source>
          <target state="translated">Sequelize는 기본적으로 연결을 열어두고 모든 쿼리에 동일한 연결을 사용합니다. 연결을 닫아야하는 경우 &lt;code&gt;sequelize.close()&lt;/code&gt; 호출 하십시오 ( 비동기 적이며 약속을 반환 함).</target>
        </trans-unit>
        <trans-unit id="f0f2a65c79a3b28cda8874038eaaf3b576b9d09e" translate="yes" xml:space="preserve">
          <source>Sequelize will use the default connection port for each dialect (for example, for postgres, it is port 5432). If you need to specify a different port, use the &lt;code&gt;&quot;port&quot;&lt;/code&gt; field (it is not present by default in &lt;code&gt;config/config.js&lt;/code&gt; but you can simply add it).</source>
          <target state="translated">Sequelize는 각 언어에 대해 기본 연결 포트를 사용합니다 (예 : postgres의 경우 포트 5432). 다른 포트를 지정해야하는 경우 &lt;code&gt;&quot;port&quot;&lt;/code&gt; 필드를 사용하십시오 (기본적으로 &lt;code&gt;config/config.js&lt;/code&gt; 에 표시 되지 않지만 간단히 추가 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="a12449a9563abf0e30ea48fb1e83208aaaae5d36" translate="yes" xml:space="preserve">
          <source>Sequelize will warn you if you're using the default aliases and not limiting them if you want to keep using all default aliases (excluding legacy ones) without the warning you can pass the following operatorsAliases option -</source>
          <target state="translated">경고없이 모든 기본 별칭 (기존 별칭 제외)을 계속 사용하려는 경우 기본 별칭을 사용하고 제한하지 않는 경우 Sequelize에서 경고합니다. 다음 연산자를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="552ca2f07a1fa7b5f7f41ab559cdc21d42d9ce70" translate="yes" xml:space="preserve">
          <source>Sequelize#fn</source>
          <target state="translated">Sequelize#fn</target>
        </trans-unit>
        <trans-unit id="61837406268cdb0d0b12c58a96e894f36f68cffc" translate="yes" xml:space="preserve">
          <source>Sequelize#query</source>
          <target state="translated">Sequelize#query</target>
        </trans-unit>
        <trans-unit id="1c368a18a859d3c840333bb46afc6a958ccfa260" translate="yes" xml:space="preserve">
          <source>Sequelize, by default, will try to optimize your queries as much as possible. When calling cascade on delete, Sequelize will simply execute:</source>
          <target state="translated">기본적으로 Sequelize는 쿼리를 최대한 최적화하려고합니다. 삭제시 cascade를 호출하면 Sequelize는 다음을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="c1b1daf0403c51efc06b9fcce975a7758d97a2aa" translate="yes" xml:space="preserve">
          <source>Sequelize-fixture</source>
          <target state="translated">Sequelize-fixture</target>
        </trans-unit>
        <trans-unit id="eed9460d8f90f2047f6e2bc967a20ec28c21c2e5" translate="yes" xml:space="preserve">
          <source>Sequelize-fixtures</source>
          <target state="translated">Sequelize-fixtures</target>
        </trans-unit>
        <trans-unit id="1a72bb27f77c646d89aab78edf53acbb911b806d" translate="yes" xml:space="preserve">
          <source>Sequelize.col</source>
          <target state="translated">Sequelize.col</target>
        </trans-unit>
        <trans-unit id="665023dac1be695aaeba85969fe1a94f8c091b07" translate="yes" xml:space="preserve">
          <source>Sequelize.define</source>
          <target state="translated">Sequelize.define</target>
        </trans-unit>
        <trans-unit id="730bfedd2958c7bec5b31d0621a9c26c5d74f1d4" translate="yes" xml:space="preserve">
          <source>Sequelize.fn and Sequelize.col returns functions and quoted column names</source>
          <target state="translated">Sequelize.fn 및 Sequelize.col은 함수와 인용 된 열 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="78fe18b652a0073892cad047536d322fec1fca96" translate="yes" xml:space="preserve">
          <source>Sequelize.transaction</source>
          <target state="translated">Sequelize.transaction</target>
        </trans-unit>
        <trans-unit id="9dfa6b97e674513041a192d1bad9a14a9b372dd7" translate="yes" xml:space="preserve">
          <source>SequelizeScopeError</source>
          <target state="translated">SequelizeScopeError</target>
        </trans-unit>
        <trans-unit id="ae2472523ae42a6de56284d423ed256bd57c04c4" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;ON UPDATE&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ON UPDATE&lt;/code&gt; 로 설정</target>
        </trans-unit>
        <trans-unit id="13bb92f3b76236bb6144fe9938c93ab1f1cbbd61" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;true&lt;/code&gt; to count only non-deleted records. Can be used on models with &lt;code&gt;paranoid&lt;/code&gt; enabled</source>
          <target state="translated">삭제되지 않은 레코드 만 계산하려면 &lt;code&gt;true&lt;/code&gt; 로 설정하십시오 . &lt;code&gt;paranoid&lt;/code&gt; 활성화 된 모델에서 사용 가능</target>
        </trans-unit>
        <trans-unit id="7afb64c86c07a6c269b9973a9ba25a4abf859068" translate="yes" xml:space="preserve">
          <source>Set can also be used to build instances for associations, if you have values for those. When using set with associations you need to make sure the property key matches the alias of the association while also making sure that the proper include options have been set (from .build() or .findOne())</source>
          <target state="translated">Set은 또한 값이있는 경우 연관 인스턴스를 빌드하는 데 사용될 수 있습니다. 연관과 함께 세트를 사용하는 경우 특성 키가 연관의 별명과 일치하는지 확인하고 올바른 포함 옵션이 설정되어 있는지 확인해야합니다 (.build () 또는 .findOne ()).</target>
        </trans-unit>
        <trans-unit id="166866de4829b605ddb977194d8b9388922cde2a" translate="yes" xml:space="preserve">
          <source>Set is used to update values on the instance (the sequelize representation of the instance that is, remember that nothing will be persisted before you actually call &lt;code&gt;save&lt;/code&gt;).</source>
          <target state="translated">Set은 인스턴스의 값을 업데이트하는 데 사용됩니다 (인스턴스의 시퀀스 표현, 즉 실제로 &lt;code&gt;save&lt;/code&gt; 호출하기 전에 아무것도 유지되지 않음을 기억하십시오 ).</target>
        </trans-unit>
        <trans-unit id="c61e103be0166178bd44bf7b48ee8f40f2dad972" translate="yes" xml:space="preserve">
          <source>Set is used to update values on the instance (the sequelize representation of the instance that is, remember that nothing will be persisted before you actually call &lt;code&gt;save&lt;/code&gt;). In its most basic form &lt;code&gt;set&lt;/code&gt; will update a value stored in the underlying &lt;code&gt;dataValues&lt;/code&gt; object. However, if a custom setter function is defined for the key, that function will be called instead. To bypass the setter, you can pass &lt;code&gt;raw: true&lt;/code&gt; in the options object.</source>
          <target state="translated">Set은 인스턴스의 값을 업데이트하는 데 사용됩니다 (인스턴스의 시퀀스 표현, 즉 실제로 호출하기 전에 아무것도 유지되지 않음을 기억하십시오) &lt;code&gt;save&lt;/code&gt; ). 가장 기본적인 형태의에서 &lt;code&gt;set&lt;/code&gt; 기본에 저장된 값을 업데이트합니다 &lt;code&gt;dataValues&lt;/code&gt; 의 개체를. 그러나 키에 대해 사용자 정의 설정 기 함수가 정의 된 경우 해당 함수가 대신 호출됩니다. setter를 무시하기 위해 options 객체에서 &lt;code&gt;raw: true&lt;/code&gt; 를 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="63bb957bd4f2485eebebbe454a8b69e791949044" translate="yes" xml:space="preserve">
          <source>Set name of the model. By default its same as Class name.</source>
          <target state="translated">모델명을 설정합니다. 기본적으로 클래스 이름과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="fb94cec61d3a9dbb28107d775ffb15026c33626f" translate="yes" xml:space="preserve">
          <source>Set of flags that control when a query is automatically retried.</source>
          <target state="translated">쿼리가 자동으로 재 시도되는시기를 제어하는 ​​플래그 세트입니다.</target>
        </trans-unit>
        <trans-unit id="846c2bef292762af4a76118b663a843b6b19e54c" translate="yes" xml:space="preserve">
          <source>Set of flags that control when a query is automatically retried. Accepts all options for &lt;a href=&quot;https://github.com/mickhansen/retry-as-promised&quot;&gt;&lt;code&gt;retry-as-promised&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">쿼리가 자동으로 재 시도되는시기를 제어하는 ​​플래그 집합입니다. &lt;a href=&quot;https://github.com/mickhansen/retry-as-promised&quot;&gt; &lt;code&gt;retry-as-promised&lt;/code&gt; 에&lt;/a&gt; 대한 모든 옵션을 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="d3489274cb42c90bb36ad36d4038ec5bb58f7ba1" translate="yes" xml:space="preserve">
          <source>Set the associated model.</source>
          <target state="translated">연관된 모델을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="cbde947d0c7d02a7c6c0d54175f289fc8bd46ae8" translate="yes" xml:space="preserve">
          <source>Set the associated models by passing an array of instances or their primary keys.</source>
          <target state="translated">인스턴스 또는 기본 키 배열을 전달하여 연관된 모델을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="28afce742822bda7ac3a2f32d5cd41e9419a35e7" translate="yes" xml:space="preserve">
          <source>Set the associated models by passing an array of instances or their primary keys. Everything that it not in the passed array will be un-associated.</source>
          <target state="translated">인스턴스 또는 기본 키 배열을 전달하여 연관된 모델을 설정하십시오. 전달 된 배열에없는 모든 항목은 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="4659b18c90bdf2bdf8128c7828c1888d45a44b43" translate="yes" xml:space="preserve">
          <source>Set the associated models by passing an array of persisted instances or their primary keys.</source>
          <target state="translated">지속 형 인스턴스 또는 기본 키 배열을 전달하여 연관된 모델을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="068e7c3551ea386b519bbe3de0e4543eabfc2396" translate="yes" xml:space="preserve">
          <source>Set the associated models by passing an array of persisted instances or their primary keys. Everything that is not in the passed array will be un-associated</source>
          <target state="translated">지속 형 인스턴스 또는 기본 키 배열을 전달하여 연관된 모델을 설정하십시오. 전달 된 배열에없는 모든 항목은 연결되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="97d0bf148a15e487d3493ba0c0a64bd2ffe4c813" translate="yes" xml:space="preserve">
          <source>Set the constraints to not deferred. This is the default in PostgreSQL and it make it impossible to dynamically defer the constraints within a transaction.</source>
          <target state="translated">제한 조건이 지연되지 않도록 설정하십시오. 이것이 PostgreSQL의 기본값이며 트랜잭션 내에서 제약 조건을 동적으로 연기 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="107b4c048cafd6f18d89bbdc4fb5cd9bc242b490" translate="yes" xml:space="preserve">
          <source>Set the default transaction isolation level. See &lt;code&gt;Sequelize.Transaction.ISOLATION_LEVELS&lt;/code&gt; for possible options.</source>
          <target state="translated">기본 트랜잭션 격리 수준을 설정하십시오. &lt;code&gt;Sequelize.Transaction.ISOLATION_LEVELS&lt;/code&gt; 를 참조하십시오 .가능한 옵션 를 .</target>
        </trans-unit>
        <trans-unit id="8a7b3220b9496281536f2b1d365289c693c1b5dc" translate="yes" xml:space="preserve">
          <source>Set the default transaction type. See &lt;code&gt;Sequelize.Transaction.TYPES&lt;/code&gt; for possible options. Sqlite only.</source>
          <target state="translated">기본 거래 유형을 설정하십시오. &lt;code&gt;Sequelize.Transaction.TYPES&lt;/code&gt; 를 참조하십시오 .가능한 옵션 를 . Sqlite 만.</target>
        </trans-unit>
        <trans-unit id="e32c8401f834466947bfc307cba05a4f5d4d4ee8" translate="yes" xml:space="preserve">
          <source>Set the initial AUTO_INCREMENT value for the table in MySQL.</source>
          <target state="translated">MySQL에서 테이블의 초기 AUTO_INCREMENT 값을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="2142490858241f5b04e051a62de526c24ed0e592" translate="yes" xml:space="preserve">
          <source>Set to &lt;code&gt;false&lt;/code&gt; to make table names and attributes case-insensitive on Postgres and skip double quoting of them. WARNING: Setting this to false may expose vulnerabilities and is not recommended!</source>
          <target state="translated">로 설정 &lt;code&gt;false&lt;/code&gt; 테이블 이름을 확인하고 포스트 그레스에 대소 문자를 구별 특성 및 그들의 인용을 두 번 건너 뜁니다. 경고 :이 값을 false로 설정하면 취약점이 노출 될 수 있으므로 권장하지 않습니다!</target>
        </trans-unit>
        <trans-unit id="354c30cb0ad082bba494c5b29c973069e05d6c82" translate="yes" xml:space="preserve">
          <source>Set to true to run before-/afterDestroy hooks when an associated model is deleted because of a cascade. For example if &lt;code&gt;User.hasOne(Profile, {onDelete: 'cascade', hooks:true})&lt;/code&gt;, the before-/afterDestroy hooks for profile will be called when a user is deleted. Otherwise the profile will be deleted without invoking any hooks</source>
          <target state="translated">계단식으로 인해 연관된 모델이 삭제 될 때 before / afterDestroy 후크를 실행하려면 true로 설정하십시오. 예를 들어 &lt;code&gt;User.hasOne(Profile, {onDelete: 'cascade', hooks:true})&lt;/code&gt; 인 경우 사용자를 삭제하면 프로필의 before / afterDestroy 후크가 호출됩니다. 그렇지 않으면 후크를 호출하지 않고 프로파일이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="1c4f50d2829a25de027786fbdce72e5b78d07194" translate="yes" xml:space="preserve">
          <source>Sets 'ON UPDATE'</source>
          <target state="translated">'ON UPDATE'설정</target>
        </trans-unit>
        <trans-unit id="8ba2182b55b33f33f3359d2be48577029cff400f" translate="yes" xml:space="preserve">
          <source>Sets &lt;code&gt;ON UPDATE&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ON UPDATE&lt;/code&gt; 로 설정</target>
        </trans-unit>
        <trans-unit id="18972919efe0a74faf9c8fee85561d96ee6ef6d3" translate="yes" xml:space="preserve">
          <source>Sets the constraints to be deferred or immediately checked. PostgreSQL only</source>
          <target state="translated">구속 조건이 연기되거나 즉시 점검되도록 설정합니다. PostgreSQL 만</target>
        </trans-unit>
        <trans-unit id="fd789d936fbe1c06427e2b854a8677e439ab83d7" translate="yes" xml:space="preserve">
          <source>Sets the constraints to be deferred or immediately checked. See &lt;code&gt;Sequelize.Deferrable&lt;/code&gt;. PostgreSQL Only</source>
          <target state="translated">구속 조건이 연기되거나 즉시 점검되도록 설정합니다. &lt;code&gt;Sequelize.Deferrable&lt;/code&gt; 을 참조하십시오 . PostgreSQL 만</target>
        </trans-unit>
        <trans-unit id="0f49e7ccb9839aa302b4098fa4e81d7d66544064" translate="yes" xml:space="preserve">
          <source>Sets the isolation level of the transaction.</source>
          <target state="translated">트랜잭션의 격리 수준을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="bdfc96c36f0f4dfb42251486fcfd7e6409571de8" translate="yes" xml:space="preserve">
          <source>Sets the query type to &lt;code&gt;SELECT&lt;/code&gt; and return a single row</source>
          <target state="translated">쿼리 유형을 &lt;code&gt;SELECT&lt;/code&gt; 로 설정하고 단일 행을 반환</target>
        </trans-unit>
        <trans-unit id="48e50206ef8d2f4278a730b2e028d7da0eeac616" translate="yes" xml:space="preserve">
          <source>Sets the type of the transaction. Sqlite only</source>
          <target state="translated">거래 유형을 설정합니다. Sqlite 만</target>
        </trans-unit>
        <trans-unit id="2a57ff5fd34c53aa02935c137725d57e985fbf2e" translate="yes" xml:space="preserve">
          <source>Setters</source>
          <target state="translated">Setters</target>
        </trans-unit>
        <trans-unit id="3d974d0bf03a57c01c4f20dcbb4527dcbfa503e9" translate="yes" xml:space="preserve">
          <source>Setting up a connection</source>
          <target state="translated">연결 설정</target>
        </trans-unit>
        <trans-unit id="c85112ad5f3b0a5d2bbb815cd320bbff39a9d8da" translate="yes" xml:space="preserve">
          <source>Setup:</source>
          <target state="translated">Setup:</target>
        </trans-unit>
        <trans-unit id="f1f1f62ad1a95c21c649b09609e964e4f011ab41" translate="yes" xml:space="preserve">
          <source>Several other query types are available. &lt;a href=&quot;https://github.com/sequelize/sequelize/blob/master/lib/query-types.js&quot;&gt;Peek into the source for details&lt;/a&gt;</source>
          <target state="translated">몇 가지 다른 쿼리 유형을 사용할 수 있습니다. &lt;a href=&quot;https://github.com/sequelize/sequelize/blob/master/lib/query-types.js&quot;&gt;자세한 내용은 소스를 살펴보세요&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="23372433a223dce6a3921247775d88e32241e813" translate="yes" xml:space="preserve">
          <source>Several other query types are available. &lt;a href=&quot;https://github.com/sequelize/sequelize/blob/master/src/query-types.ts&quot;&gt;Peek into the source for details&lt;/a&gt;.</source>
          <target state="translated">몇 가지 다른 쿼리 유형을 사용할 수 있습니다. &lt;a href=&quot;https://github.com/sequelize/sequelize/blob/master/src/query-types.ts&quot;&gt;자세한 내용은 소스를 살펴보십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aea9a5880bd2b9832a731121a6d7390e206c1927" translate="yes" xml:space="preserve">
          <source>Several scopes can be applied simultaneously by passing an array of scopes to &lt;code&gt;.scope&lt;/code&gt;, or by passing the scopes as consecutive arguments.</source>
          <target state="translated">범위 배열을 &lt;code&gt;.scope&lt;/code&gt; 에 전달하거나 범위를 연속 인수로 전달하여 여러 범위를 동시에 적용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a929c0b5bdc1d6b8c5356573caa1d8870cfbb0f2" translate="yes" xml:space="preserve">
          <source>Shorthand syntax for &lt;code&gt;Op.in&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Op.in&lt;/code&gt; 의 속기 구문</target>
        </trans-unit>
        <trans-unit id="1cc34d5862bb6623cb8eb39094c2ba84d0c3557b" translate="yes" xml:space="preserve">
          <source>Should each row be subject to validation before it is inserted. The whole insert will fail if one row fails validation</source>
          <target state="translated">각 행을 삽입하기 전에 유효성 검사를 받아야합니다. 하나의 행이 유효성 검사에 실패하면 전체 삽입이 실패합니다</target>
        </trans-unit>
        <trans-unit id="fccc812dc5f2a57c8829818b8c7f9aa953df663f" translate="yes" xml:space="preserve">
          <source>Should on update and on delete constraints be enabled on the foreign key.</source>
          <target state="translated">외래 키에서 업데이트 및 삭제시 제약 조건을 활성화해야합니다.</target>
        </trans-unit>
        <trans-unit id="1c55603b3eb9b5b1700bdfca388933033c5267cc" translate="yes" xml:space="preserve">
          <source>Should the index by unique? Can also be triggered by setting type to &lt;code&gt;UNIQUE&lt;/code&gt;</source>
          <target state="translated">인덱스는 고유해야합니까? 유형을 &lt;code&gt;UNIQUE&lt;/code&gt; 로 설정하여 트리거 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9430fbff299935c8d01d77d60a80c20db8af97f" translate="yes" xml:space="preserve">
          <source>Should the join model have timestamps</source>
          <target state="translated">조인 모델에 타임 스탬프가 있어야합니다</target>
        </trans-unit>
        <trans-unit id="e89c05ba6758d6c1df5321149b427c4c24dc77a5" translate="yes" xml:space="preserve">
          <source>Show all defined schemas</source>
          <target state="translated">정의 된 모든 스키마 표시</target>
        </trans-unit>
        <trans-unit id="a8230afc301654f9c5847932109ae42f577ad544" translate="yes" xml:space="preserve">
          <source>Show all schemas</source>
          <target state="translated">모든 스키마 표시</target>
        </trans-unit>
        <trans-unit id="666a1f8b0fe634287a3927b7be01a45e977340a3" translate="yes" xml:space="preserve">
          <source>Signature for this method has been changed to &lt;code&gt;Promise&amp;lt;Model,boolean | null&amp;gt;&lt;/code&gt;. First index contains upserted &lt;code&gt;instance&lt;/code&gt;, second index contains a boolean (or &lt;code&gt;null&lt;/code&gt;) indicating if record was created or updated. For SQLite/Postgres, &lt;code&gt;created&lt;/code&gt; value will always be &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">이 메서드의 서명이 &lt;code&gt;Promise&amp;lt;Model,boolean | null&amp;gt;&lt;/code&gt; . 첫 번째 인덱스는 upserted &lt;code&gt;instance&lt;/code&gt; 를 포함하고 두 번째 인덱스는 레코드가 생성 또는 업데이트되었는지를 나타내는 부울 (또는 &lt;code&gt;null&lt;/code&gt; )을 포함합니다 . SQLite / Postgres의 경우 &lt;code&gt;created&lt;/code&gt; 값은 항상 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7023cf03f59070b5e75d8ceb558904686c4a3f73" translate="yes" xml:space="preserve">
          <source>Similarly to how a &lt;a href=&quot;scopes&quot;&gt;model scope&lt;/a&gt; is automatically applied on the model static calls, such as &lt;code&gt;Model.scope('foo').findAll()&lt;/code&gt;, an association scope is a rule (more precisely, a set of default attributes and options) that is automatically applied on instance calls from the model. Here, &lt;em&gt;instance calls&lt;/em&gt; mean method calls that are called from an instance (rather than from the Model itself). Mixins are the main example of instance methods (&lt;code&gt;instance.getSomething&lt;/code&gt;, &lt;code&gt;instance.setSomething&lt;/code&gt;, &lt;code&gt;instance.addSomething&lt;/code&gt; and &lt;code&gt;instance.createSomething&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;Model.scope('foo').findAll()&lt;/code&gt; 과 같은 모델 정적 호출에 &lt;a href=&quot;scopes&quot;&gt;모델 범위&lt;/a&gt; 가 자동으로 적용되는 방식과 유사하게 연관 범위는 다음과 같은 규칙 (더 정확하게는 기본 속성 및 옵션 세트)입니다. 모델의 인스턴스 호출에 자동으로 적용됩니다. 여기서 &lt;em&gt;인스턴스 호출&lt;/em&gt; 은 모델 자체가 아닌 인스턴스에서 호출되는 메서드 호출을 의미합니다. 믹스 인은 인스턴스 메서드의 주요 예입니다 ( &lt;code&gt;instance.getSomething&lt;/code&gt; , &lt;code&gt;instance.setSomething&lt;/code&gt; , &lt;code&gt;instance.addSomething&lt;/code&gt; 및 &lt;code&gt;instance.createSomething&lt;/code&gt; ).&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c6986adce272ac3166bb43689d63b54c369297fc" translate="yes" xml:space="preserve">
          <source>Similarly to the other relationships, aliases can be defined for Many-to-Many relationships.</source>
          <target state="translated">다른 관계와 마찬가지로 다 대다 관계에 대해 별칭을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="efed8b09c2af7cf317d189d17f5bc235ba012c57" translate="yes" xml:space="preserve">
          <source>Similarly, for &lt;code&gt;Foo.hasOne(Bar)&lt;/code&gt;, since &lt;code&gt;Foo&lt;/code&gt; knows about the relationship, we can perform eager loading as in &lt;code&gt;Foo.findOne({ include: Bar })&lt;/code&gt;, but we can't do &lt;code&gt;Bar.findOne({ include: Foo })&lt;/code&gt;.</source>
          <target state="translated">마찬가지로 &lt;code&gt;Foo.hasOne(Bar)&lt;/code&gt; 경우 &lt;code&gt;Foo&lt;/code&gt; 가 관계에 대해 알고 &lt;code&gt;Foo.findOne({ include: Bar })&lt;/code&gt; eager loading을 수행 할 수 있지만 &lt;code&gt;Bar.findOne({ include: Foo })&lt;/code&gt; 에서는 수행 할 수 없습니다 . ) .</target>
        </trans-unit>
        <trans-unit id="5c66f69bd4f8cb33cd2b7d50b7fe30afddb3d653" translate="yes" xml:space="preserve">
          <source>Similarly, it's also possible to remove a selected few attributes:</source>
          <target state="translated">마찬가지로 선택된 몇 가지 속성을 제거 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="26f9660bf122890dd24a48101e8f7f0554e9803f" translate="yes" xml:space="preserve">
          <source>Similarly, when fetching through a join table with custom attributes, these attributes will be available as an object with the name of the through model.</source>
          <target state="translated">마찬가지로 사용자 지정 특성이있는 조인 테이블을 통해 가져 오는 경우 이러한 특성을 통과 모델 이름을 가진 개체로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d41b24f83a9fd8772c1b8a5d6fe700483a03fed" translate="yes" xml:space="preserve">
          <source>Simple DELETE queries</source>
          <target state="translated">간단한 DELETE 쿼리</target>
        </trans-unit>
        <trans-unit id="e3517dcbca2e148cc042df2c796b46fab3bad2c4" translate="yes" xml:space="preserve">
          <source>Simple INSERT queries</source>
          <target state="translated">간단한 INSERT 쿼리</target>
        </trans-unit>
        <trans-unit id="16fbd95afaf78cf8afca13b451c2aa52d8ed586d" translate="yes" xml:space="preserve">
          <source>Simple SELECT queries</source>
          <target state="translated">간단한 SELECT 쿼리</target>
        </trans-unit>
        <trans-unit id="d27f2ffb9612d6b3425c31cc2ab961c7fe89ff1b" translate="yes" xml:space="preserve">
          <source>Simple UPDATE queries</source>
          <target state="translated">간단한 UPDATE 쿼리</target>
        </trans-unit>
        <trans-unit id="696ea9d6cd2e74a5c976cb995c1b0d7d4e1edac0" translate="yes" xml:space="preserve">
          <source>Simple search using AND and =</source>
          <target state="translated">AND와 =를 사용한 간단한 검색</target>
        </trans-unit>
        <trans-unit id="93daae424d16a8300e01790d40b21a063b13c75d" translate="yes" xml:space="preserve">
          <source>Since a string was given in the &lt;code&gt;through&lt;/code&gt; option of the &lt;code&gt;belongsToMany&lt;/code&gt; call, Sequelize will automatically create the &lt;code&gt;ActorMovies&lt;/code&gt; model which will act as the junction model. For example, in PostgreSQL:</source>
          <target state="translated">&lt;code&gt;belongsToMany&lt;/code&gt; 호출 의 &lt;code&gt;through&lt;/code&gt; 옵션에 문자열이 주어 졌기 때문에 Sequelize는 접합 모델 역할을 할 &lt;code&gt;ActorMovies&lt;/code&gt; 모델을 자동으로 생성합니다 . 예를 들어 PostgreSQL에서는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="86ca1c474f36d3bfe107fa86b6dd5acd4e90640b" translate="yes" xml:space="preserve">
          <source>Since no option was passed, Sequelize will infer what to do from the names of the models. In this case, Sequelize knows that a &lt;code&gt;fooId&lt;/code&gt; column must be added to &lt;code&gt;Bar&lt;/code&gt;.</source>
          <target state="translated">옵션이 전달되지 않았으므로 Sequelize는 모델 이름에서 수행 할 작업을 추론합니다. 이 경우 Sequelize는 &lt;code&gt;fooId&lt;/code&gt; 열이 &lt;code&gt;Bar&lt;/code&gt; 에 추가되어야 함을 알고 있습니다 .</target>
        </trans-unit>
        <trans-unit id="06afcc6284f1f9770ef6be8cabef9b13c4dde5bd" translate="yes" xml:space="preserve">
          <source>Since postgres has a special case for enums, we should drop the related enum type within the table and attribute</source>
          <target state="translated">postgres에는 enum에 대한 특별한 경우가 있으므로 테이블 및 속성 내에서 관련 enum 유형을 삭제해야합니다.</target>
        </trans-unit>
        <trans-unit id="8e0eaf977d4539a1c708998caf904e6bb9df2978" translate="yes" xml:space="preserve">
          <source>Since range types have extra information for their bound inclusion/exclusion it's not very straightforward to just use a tuple to represent them in javascript.</source>
          <target state="translated">범위 유형에는 바인딩 포함 / 제외에 대한 추가 정보가 있으므로 튜플을 사용하여 자바 스크립트로 표시하는 것은 매우 간단하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a4d97f569775fb373449274d2e41b9c873f48853" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;commentableId&lt;/code&gt; column references several tables (two in this case), we cannot add a &lt;code&gt;REFERENCES&lt;/code&gt; constraint to it. This is why the &lt;code&gt;constraints: false&lt;/code&gt; option was used.</source>
          <target state="translated">이후 &lt;code&gt;commentableId&lt;/code&gt; 의 열 참조 여러 테이블 (이 경우 2 개), 우리는 추가 할 수 없습니다 &lt;code&gt;REFERENCES&lt;/code&gt; 여기에 제약 조건을. 이것이 &lt;code&gt;constraints: false&lt;/code&gt; 옵션이 사용 된 이유 입니다.</target>
        </trans-unit>
        <trans-unit id="2b8595d0676b15816b89dc98be5b7a53648714bf" translate="yes" xml:space="preserve">
          <source>Since the above was an &lt;code&gt;OR&lt;/code&gt; involving the same field, Sequelize allows you to use a slightly different structure which is more readable and generates the same behavior:</source>
          <target state="translated">위의 내용이 동일한 필드를 포함 하는 &lt;code&gt;OR&lt;/code&gt; 이기 때문에 Sequelize를 사용하면 좀 더 읽기 쉽고 동일한 동작을 생성하는 약간 다른 구조를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b601167a7cd382d7cbe566ee42e4b7536768d3ad" translate="yes" xml:space="preserve">
          <source>Since v5, Sequelize provides its own TypeScript definitions. Please note that only TS &amp;gt;= 3.1 is supported.</source>
          <target state="translated">v5부터 Sequelize는 고유 한 TypeScript 정의를 제공합니다. TS&amp;gt; = 3.1 만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="f436c13844b216967ae563c043203b695079ce01" translate="yes" xml:space="preserve">
          <source>Since you are working with multiple models, the callbacks will not return DAO instances. BulkCreate will return an array of model instances/DAOs, they will however, unlike &lt;code&gt;create&lt;/code&gt;, not have the resulting values of autoIncrement attributes.&lt;code&gt;update&lt;/code&gt; and &lt;code&gt;destroy&lt;/code&gt; will return the number of affected rows.</source>
          <target state="translated">여러 모델로 작업하므로 콜백은 DAO 인스턴스를 반환하지 않습니다. BulkCreate는 모델 인스턴스 / DAO의 배열을 반환하지만 &lt;code&gt;create&lt;/code&gt; 와 달리 autoIncrement 특성의 결과 값을 갖지 않습니다. &lt;code&gt;update&lt;/code&gt; 및 &lt;code&gt;destroy&lt;/code&gt; 는 영향을받는 행 수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="d0a120c4b4160f315ab6b9691b248b295b04acec" translate="yes" xml:space="preserve">
          <source>Singular name for model</source>
          <target state="translated">모델의 단수 이름</target>
        </trans-unit>
        <trans-unit id="0282244f1a0bc2b43ad431d49e7a5819b2eb897f" translate="yes" xml:space="preserve">
          <source>Singular vs. Plural</source>
          <target state="translated">단수 대 복수</target>
        </trans-unit>
        <trans-unit id="b7152342a267362add3c0d7f69f720f7a9c76c9e" translate="yes" xml:space="preserve">
          <source>Size</source>
          <target state="translated">Size</target>
        </trans-unit>
        <trans-unit id="dbe291e0d821c92f6b4f3902eec2a5914db65996" translate="yes" xml:space="preserve">
          <source>Skip locked rows. Only supported in Postgres.</source>
          <target state="translated">잠긴 행을 건너 뜁니다. Postgres에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="b066e9f045fec6926b3eb8e24e878587821bf646" translate="yes" xml:space="preserve">
          <source>Skip saving this after setting the foreign key if false.</source>
          <target state="translated">false 인 경우 외래 키를 설정 한 후 저장하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="9081562512b5ff709e3b937fef72e774f6407d16" translate="yes" xml:space="preserve">
          <source>Slugification</source>
          <target state="translated">Slugification</target>
        </trans-unit>
        <trans-unit id="e5e3a2d0b71e212514381c92fbda84f40194f41d" translate="yes" xml:space="preserve">
          <source>So far we dealt with a one-way association. But we want more! Let's define it the other way around by creating a many to many association in the next section.</source>
          <target state="translated">지금까지 우리는 일방적 인 협회를 다루었습니다. 그러나 우리는 더 많은 것을 원합니다! 다음 섹션에서 다 대다 연관을 만들어서 다른 방법으로 정의 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="3bcb91b0ba8a4c00ca1c8321595ca9f8b076d9ef" translate="yes" xml:space="preserve">
          <source>So how can we achieve that with more help from Sequelize, without having to write the whole raw query by hand?</source>
          <target state="translated">그렇다면 전체 원시 쿼리를 직접 작성하지 않고도 Sequelize의 더 많은 도움을 받아 어떻게이 작업을 수행 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="4e42dc224648ef387be0eb7a267a923a15e1bc3c" translate="yes" xml:space="preserve">
          <source>So this enum name must follow this pattern &lt;code&gt;enum_&amp;lt;table_name&amp;gt;_&amp;lt;col_name&amp;gt;&lt;/code&gt;. If you are using &lt;code&gt;sync&lt;/code&gt; then correct name will automatically be generated.</source>
          <target state="translated">따라서이 열거 이름은이 패턴 &lt;code&gt;enum_&amp;lt;table_name&amp;gt;_&amp;lt;col_name&amp;gt;&lt;/code&gt; 을 따라야합니다 . &lt;code&gt;sync&lt;/code&gt; 사용하는 경우 를 올바른 이름이 자동으로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="aa67c403111223a06acfa653d4d3dea833c1986c" translate="yes" xml:space="preserve">
          <source>So this is how we can achieve a &lt;em&gt;many-to-many-to-many&lt;/em&gt; relationship between three models in Sequelize, by taking advantage of the Super Many-to-Many relationship technique!</source>
          <target state="translated">이것이 바로 Super Many-to-Many 관계 기술을 활용하여 Sequelize의 세 모델간에 다 &lt;em&gt;대다 대다&lt;/em&gt; 관계 &lt;em&gt;를&lt;/em&gt; 달성 할 수있는 방법입니다!</target>
        </trans-unit>
        <trans-unit id="722d913bc8d1ac3895e6a6c61e864943343a5217" translate="yes" xml:space="preserve">
          <source>So we start by defining the three relevant models:</source>
          <target state="translated">따라서 세 가지 관련 모델을 정의하는 것으로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="0e78ec0d8156cc0f2bf3c598c9044e39bfa2947e" translate="yes" xml:space="preserve">
          <source>Some data types have special properties that can be accessed in order to change the data type. For example, to get an unsigned integer with zerofill you can do &lt;code&gt;DataTypes.INTEGER.UNSIGNED.ZEROFILL&lt;/code&gt;. The order you access the properties in do not matter, so &lt;code&gt;DataTypes.INTEGER.ZEROFILL.UNSIGNED&lt;/code&gt; is fine as well.</source>
          <target state="translated">일부 데이터 유형에는 데이터 유형을 변경하기 위해 액세스 할 수있는 특수 특성이 있습니다. 예를 들어, 0으로 채워진 부호없는 정수를 얻으려면 &lt;code&gt;DataTypes.INTEGER.UNSIGNED.ZEROFILL&lt;/code&gt; 을 수행 할 수 있습니다 . 속성에 액세스하는 순서는 중요하지 않으므로 &lt;code&gt;DataTypes.INTEGER.ZEROFILL.UNSIGNED&lt;/code&gt; 도 좋습니다.</target>
        </trans-unit>
        <trans-unit id="47aac3e3ea46b8003010b5a72dada7a63be999b8" translate="yes" xml:space="preserve">
          <source>Some frameworks automatically parse user input into js objects and if you fail to sanitize your input it might be possible to inject an Object with string operators to Sequelize.</source>
          <target state="translated">일부 프레임 워크는 사용자 입력을 자동으로 js 객체로 구문 분석하고 입력을 위생 처리하지 않으면 문자열 연산자가 포함 된 객체를 Sequelize에 삽입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="506695fe4bca93a04e723ee3f23405d882143d94" translate="yes" xml:space="preserve">
          <source>Some scenarios where you can use it.</source>
          <target state="translated">사용할 수있는 일부 시나리오.</target>
        </trans-unit>
        <trans-unit id="0828486722d623018350014166844282cf588735" translate="yes" xml:space="preserve">
          <source>Some scenarios where you can use it:</source>
          <target state="translated">사용할 수있는 몇 가지 시나리오 :</target>
        </trans-unit>
        <trans-unit id="66c9baa847ef18befb0f4adb94cf7eff191ec811" translate="yes" xml:space="preserve">
          <source>Some special values, such as &lt;code&gt;Sequelize.NOW&lt;/code&gt;, are also accepted:</source>
          <target state="translated">&lt;code&gt;Sequelize.NOW&lt;/code&gt; 와 같은 일부 특수 값 도 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="45519e97c243c8c894e455e42e2f4ddf34c0f43c" translate="yes" xml:space="preserve">
          <source>Some tips around using CLI and migration setup in production environment.</source>
          <target state="translated">프로덕션 환경에서 CLI 및 마이그레이션 설정 사용에 대한 팁.</target>
        </trans-unit>
        <trans-unit id="cce1d48d901d42375d87783743924bc41a147483" translate="yes" xml:space="preserve">
          <source>Sometime you want to specify a dialectOption, if it's a general config you can just add it in &lt;code&gt;config/config.json&lt;/code&gt;. Sometime you want to execute some code to get dialectOptions, you should use dynamic config file for those cases.</source>
          <target state="translated">때로는 dialectOption을 지정하고 싶습니다. 일반 구성이라면 &lt;code&gt;config/config.json&lt;/code&gt; 에 추가 할 수 있습니다 . 때로는 dialectOptions를 얻기 위해 일부 코드를 실행하려는 경우 이러한 경우 동적 구성 파일을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="8e9158873a51d40de8fc8b6422e47f75fed10c82" translate="yes" xml:space="preserve">
          <source>Sometimes it may be tiresome to list all the attributes of the model if you only want to add an aggregation:</source>
          <target state="translated">집계 만 추가하려는 경우 모델의 모든 속성을 나열하는 것이 번거로울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c76c8272fccf13128629164c9a771b6e879c7bc4" translate="yes" xml:space="preserve">
          <source>Sometimes you may need to associate records on different columns, you may use &lt;code&gt;sourceKey&lt;/code&gt; option:</source>
          <target state="translated">때로는 다른 열의 레코드를 연결해야 할 수도 있습니다. &lt;code&gt;sourceKey&lt;/code&gt; 옵션을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="84420187eb6990ad41032d3ccbebefd68bfee436" translate="yes" xml:space="preserve">
          <source>Sometimes you may want to reference another table, without adding any constraints, or associations. In that case you can manually add the reference attributes to your schema definition, and mark the relations between them.</source>
          <target state="translated">제한 조건이나 연관을 추가하지 않고 다른 테이블을 참조하려는 경우가 있습니다. 이 경우 참조 속성을 스키마 정의에 수동으로 추가하고 이들 사이의 관계를 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5a4cd094326d31853e0865b4f6a87a79be6da8e" translate="yes" xml:space="preserve">
          <source>Sometimes you may want to rename your models when using them in associations. Let's define users as workers and projects as tasks by using the alias (&lt;code&gt;as&lt;/code&gt;) option. We will also manually define the foreign keys to use:</source>
          <target state="translated">때때로 연관에서 사용할 때 모델의 이름을 바꾸려고 할 수 있습니다. 별명 ( &lt;code&gt;as&lt;/code&gt; ) 옵션 을 사용하여 사용자를 작업자 및 프로젝트로 작업으로 정의합시다 . 사용할 외래 키도 수동으로 정의합니다.</target>
        </trans-unit>
        <trans-unit id="ca0f78496da4f38b504892d451c90fe377acf862" translate="yes" xml:space="preserve">
          <source>Sometimes you might be expecting a massive dataset that you just want to display, without manipulation. For each row you select, Sequelize creates an instance with functions for update, delete, get associations etc. If you have thousands of rows, this might take some time. If you only need the raw data and don't want to update anything, you can do like this to get the raw data.</source>
          <target state="translated">때로는 조작하지 않고 방금 표시하려는 방대한 데이터 세트를 기대할 수 있습니다. 선택한 각 행에 대해 Sequelize는 업데이트, 삭제, 연결 가져 오기 등의 기능이있는 인스턴스를 만듭니다. 수천 개의 행이있는 경우 시간이 다소 걸릴 수 있습니다. 원시 데이터 만 필요하고 아무것도 업데이트하지 않으려는 경우 원시 데이터를 가져 오기 위해 이와 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8619ccdb38e8bcdff93ddd49b7ef88b35965018" translate="yes" xml:space="preserve">
          <source>Sometimes you'll be editing more than one record at a time by using methods like &lt;code&gt;bulkCreate&lt;/code&gt;, &lt;code&gt;update&lt;/code&gt; and &lt;code&gt;destroy&lt;/code&gt;. The following hooks will emit whenever you're using one of those methods:</source>
          <target state="translated">때로는 &lt;code&gt;bulkCreate&lt;/code&gt; , &lt;code&gt;update&lt;/code&gt; 및 &lt;code&gt;destroy&lt;/code&gt; 와 같은 메소드를 사용하여 한 번에 둘 이상의 레코드를 편집 할 수 있습니다 . 이러한 방법 중 하나를 사용할 때마다 다음 후크가 방출됩니다.</target>
        </trans-unit>
        <trans-unit id="f6e10c8d1ee0e110a949c1dd33ee734b90e8b619" translate="yes" xml:space="preserve">
          <source>Sometimes you'll be editing more than one record at a time by utilizing the &lt;code&gt;bulkCreate, update, destroy&lt;/code&gt; methods on the model. The following will emit whenever you're using one of those methods:</source>
          <target state="translated">모델 에서 &lt;code&gt;bulkCreate, update, destroy&lt;/code&gt; 메소드를 사용하여 한 번에 두 개 이상의 레코드를 편집하는 경우 가 있습니다. 이러한 방법 중 하나를 사용할 때마다 다음이 방출됩니다.</target>
        </trans-unit>
        <trans-unit id="6da13addb000b67d42a6d66391713819e634149f" translate="yes" xml:space="preserve">
          <source>Source</source>
          <target state="translated">Source</target>
        </trans-unit>
        <trans-unit id="cec1acf567fe5032c7ccbe6f0c04bec9827cd692" translate="yes" xml:space="preserve">
          <source>Source &amp;amp; Target</source>
          <target state="translated">소스 및 대상</target>
        </trans-unit>
        <trans-unit id="7969aba3e7f08bea9e13ad506421e1ecfd565291" translate="yes" xml:space="preserve">
          <source>Source and target keys</source>
          <target state="translated">소스 및 대상 키</target>
        </trans-unit>
        <trans-unit id="d8a00d1571c48d768984321da51fe70137af999f" translate="yes" xml:space="preserve">
          <source>Source code of function</source>
          <target state="translated">기능의 소스 코드</target>
        </trans-unit>
        <trans-unit id="1499c6d6e22facebb12a10f560d4082a7ba88a6f" translate="yes" xml:space="preserve">
          <source>Source keys</source>
          <target state="translated">소스 키</target>
        </trans-unit>
        <trans-unit id="59f265692e8532f3f9f4cf8098a358d626fbb2eb" translate="yes" xml:space="preserve">
          <source>Special Cases</source>
          <target state="translated">특수한 상황들</target>
        </trans-unit>
        <trans-unit id="0888013c161842a0961dffc2b3d2186ac563579a" translate="yes" xml:space="preserve">
          <source>Special methods/mixins added to instances</source>
          <target state="translated">인스턴스에 추가 된 특수 메서드 / 믹스</target>
        </trans-unit>
        <trans-unit id="7610310be61095c09812768c8c3df51ade223444" translate="yes" xml:space="preserve">
          <source>Specified model</source>
          <target state="translated">지정된 모델</target>
        </trans-unit>
        <trans-unit id="ef957adb2faf323c7b629c9477baa8a72aec3b29" translate="yes" xml:space="preserve">
          <source>Specifies an ordering. Using an array, you can provide several columns / functions to order by. Each element can be further wrapped in a two-element array. The first element is the column / function to order by, the second is the direction. For example: &lt;code&gt;order: [['name', 'DESC']]&lt;/code&gt;. In this way the column will be escaped, but the direction will not.</source>
          <target state="translated">순서를 지정합니다. 배열을 사용하여 주문할 여러 열 / 함수를 제공 할 수 있습니다. 각 요소는 2 요소 배열로 더 래핑 될 수 있습니다. 첫 번째 요소는 정렬 할 열 / 함수이고 두 번째 요소는 방향입니다. 예를 들면 다음과 같습니다. &lt;code&gt;order: [['name', 'DESC']]&lt;/code&gt; . 이러한 방식으로 컬럼이 이스케이프되지만 방향은 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ab91a1aa22860a5be44f1c7d0e5a41f40ac0899d" translate="yes" xml:space="preserve">
          <source>Specify charset for model's table</source>
          <target state="translated">모델 테이블에 대한 문자셋 지정</target>
        </trans-unit>
        <trans-unit id="05c45a92124ec5ecf33e03c985ae55ccc15f268e" translate="yes" xml:space="preserve">
          <source>Specify collation for model's table</source>
          <target state="translated">모델 테이블의 데이터 정렬 지정</target>
        </trans-unit>
        <trans-unit id="6e7c3b352c76886bab8a11641294e51528c63905" translate="yes" xml:space="preserve">
          <source>Specify comment for model's table</source>
          <target state="translated">모델 테이블에 주석을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="6c874f64189ebc73fd18bd05f2dd405ac52c8396" translate="yes" xml:space="preserve">
          <source>Specify engine for model's table</source>
          <target state="translated">모델 테이블에 대한 엔진 지정</target>
        </trans-unit>
        <trans-unit id="93cb6f0d1b5094f7a606c75c41e39f3729456b42" translate="yes" xml:space="preserve">
          <source>Specify index operator.</source>
          <target state="translated">인덱스 연산자를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="1b468bd525de3aeadbdf80f3d9c458fbcaefa38a" translate="yes" xml:space="preserve">
          <source>Specifying Dialect Options</source>
          <target state="translated">방언 옵션 지정</target>
        </trans-unit>
        <trans-unit id="6cee1dffcb3801d8c61b0c521aafbc8a5ba7a43c" translate="yes" xml:space="preserve">
          <source>Specifying attributes for SELECT queries</source>
          <target state="translated">SELECT 쿼리에 대한 속성 지정</target>
        </trans-unit>
        <trans-unit id="798bc605e825ca1c970cfa595877f3b9a238c2da" translate="yes" xml:space="preserve">
          <source>Specifying attributes from the through table</source>
          <target state="translated">through 테이블에서 속성 지정</target>
        </trans-unit>
        <trans-unit id="61329f6e9dc4650b34f56acef60b2aec0b87611f" translate="yes" xml:space="preserve">
          <source>Specifying the appropriate &lt;a href=&quot;association-scopes&quot;&gt;association scopes&lt;/a&gt;;</source>
          <target state="translated">적절한 &lt;a href=&quot;association-scopes&quot;&gt;연관 범위&lt;/a&gt; 지정 ;</target>
        </trans-unit>
        <trans-unit id="789445bbe2e230b404b0877611cb047ff79a2a8a" translate="yes" xml:space="preserve">
          <source>Start a transaction.</source>
          <target state="translated">거래를 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="d18d875cf4fc5fcecf6b711eae14645c02d6e1f3" translate="yes" xml:space="preserve">
          <source>Start a transaction. When using transactions, you should pass the transaction in the options argument in order for the query to happen under that transaction @see &lt;a href=&quot;transaction.js~transaction&quot;&gt;Transaction&lt;/a&gt;</source>
          <target state="translated">거래를 시작하십시오. 트랜잭션을 사용하는 경우, 해당 트랜잭션 @see의에서 일어날 수있는 쿼리 위해서는 옵션 인수 거래를 통과해야 &lt;a href=&quot;transaction.js~transaction&quot;&gt;거래&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="767db5397ee3f3f1fc518ea59e55ef68e66c4e49" translate="yes" xml:space="preserve">
          <source>Start looking for any migration files which haven't run yet. This is possible by checking &lt;code&gt;SequelizeMeta&lt;/code&gt; table. In this case it will run &lt;code&gt;XXXXXXXXXXXXXX-create-user.js&lt;/code&gt; migration, which we created in last step.</source>
          <target state="translated">아직 실행되지 않은 마이그레이션 파일을 찾기 시작하십시오. &lt;code&gt;SequelizeMeta&lt;/code&gt; 테이블 을 확인하면 가능 합니다. 이 경우 마지막 단계에서 만든 &lt;code&gt;XXXXXXXXXXXXXX-create-user.js&lt;/code&gt; 마이그레이션을 실행 합니다.</target>
        </trans-unit>
        <trans-unit id="3e2ca76b869d4fc44471d269e7d021b82eb5e2e7" translate="yes" xml:space="preserve">
          <source>Static Member Summary</source>
          <target state="translated">정적 멤버 요약</target>
        </trans-unit>
        <trans-unit id="93974c74e2583ae745e2a4d05185ce35cbce3dda" translate="yes" xml:space="preserve">
          <source>Static Method Summary</source>
          <target state="translated">정적 메소드 요약</target>
        </trans-unit>
        <trans-unit id="5d93069d69d10dd364cb5869055e39be7a82df7b" translate="yes" xml:space="preserve">
          <source>Static Public</source>
          <target state="translated">정적 공개</target>
        </trans-unit>
        <trans-unit id="071f6dc8b2e654ff72e19d9c2affa12acd8cad3b" translate="yes" xml:space="preserve">
          <source>Static Public Members</source>
          <target state="translated">정적 공개 멤버</target>
        </trans-unit>
        <trans-unit id="fd87df2a091c294a3be14e721270cc5cb9005586" translate="yes" xml:space="preserve">
          <source>Static Public Methods</source>
          <target state="translated">정적 퍼블릭 메소드</target>
        </trans-unit>
        <trans-unit id="e54d0c6ac86b830fabe7f13edf805a4e9b1dee3e" translate="yes" xml:space="preserve">
          <source>Static Public Summary</source>
          <target state="translated">정적 공개 요약</target>
        </trans-unit>
        <trans-unit id="9e092dda4f0e27d0c7686ddd00272079e678b6e6" translate="yes" xml:space="preserve">
          <source>Storage</source>
          <target state="translated">Storage</target>
        </trans-unit>
        <trans-unit id="65fa5a3000720098c1dca59b70a7d76a6fd2c4c2" translate="yes" xml:space="preserve">
          <source>String - will be quoted</source>
          <target state="translated">문자열-인용됩니다</target>
        </trans-unit>
        <trans-unit id="daceb9a0562946d158de84d0526f6149910187cc" translate="yes" xml:space="preserve">
          <source>String based operator alias. Pass object to limit set of aliased operators.</source>
          <target state="translated">문자열 기반 연산자 별명. 별명 연산자 세트를 제한하기 위해 오브젝트를 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="3816c4beac471c733eed1d91c213f8c2b6a29262" translate="yes" xml:space="preserve">
          <source>Strings</source>
          <target state="translated">Strings</target>
        </trans-unit>
        <trans-unit id="b1fb22e7591b0556a7b78a9f8047fb5abb0d9df7" translate="yes" xml:space="preserve">
          <source>Sub Queries</source>
          <target state="translated">하위 쿼리</target>
        </trans-unit>
        <trans-unit id="7ce01f6381463362cf6aef2f843a59261e8f5587" translate="yes" xml:space="preserve">
          <source>Success!</source>
          <target state="translated">Success!</target>
        </trans-unit>
        <trans-unit id="6ada010a4af6877d578b83c2221b03cd216ad0ed" translate="yes" xml:space="preserve">
          <source>Such validation could have also been done with a custom validator defined on a single attribute (such as the &lt;code&gt;latitude&lt;/code&gt; attribute, by checking &lt;code&gt;(value === null) !== (this.longitude === null)&lt;/code&gt;), but the model-wide validation approach is cleaner.</source>
          <target state="translated">이러한 유효성 검사는 단일 속성 (예 : &lt;code&gt;(value === null) !== (this.longitude === null)&lt;/code&gt; ) 을 확인 하여 &lt;code&gt;latitude&lt;/code&gt; 속성 과 같은 단일 속성에 정의 된 사용자 지정 유효성 검사기로도 수행 할 수 있었지만 모델은 광범위한 검증 방법이 더 깨끗합니다.</target>
        </trans-unit>
        <trans-unit id="666e6b745c699158426c5ad099759c71dae3993c" translate="yes" xml:space="preserve">
          <source>Supply your own ON condition for the join.</source>
          <target state="translated">조인에 대한 자체 ON 조건을 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="144046b1bd7badefc4d65fecc8afd75a78d5b865" translate="yes" xml:space="preserve">
          <source>Support for Node 10 and up</source>
          <target state="translated">노드 10 이상 지원</target>
        </trans-unit>
        <trans-unit id="cd906bb957f4dba88a7d677004f6055dd11d4afc" translate="yes" xml:space="preserve">
          <source>Suppose our &lt;code&gt;Player&lt;/code&gt; model has information about its team as &lt;code&gt;teamId&lt;/code&gt; column. Information about each Team's &lt;code&gt;Coach&lt;/code&gt; is stored in the &lt;code&gt;Team&lt;/code&gt; model as &lt;code&gt;coachId&lt;/code&gt; column. These both scenarios requires different kind of 1:1 relation because foreign key relation is present on different models each time.</source>
          <target state="translated">&lt;code&gt;Player&lt;/code&gt; 모델에 &lt;code&gt;teamId&lt;/code&gt; 열로 팀에 대한 정보가 있다고 가정하십시오 . 각 팀 &lt;code&gt;Coach&lt;/code&gt; 에 대한 정보 는 &lt;code&gt;Team&lt;/code&gt; 모델에 &lt;code&gt;coachId&lt;/code&gt; 열로 저장 됩니다. 외래 키 관계는 매번 다른 모델에 존재하기 때문에이 두 시나리오에는 서로 다른 종류의 1 : 1 관계가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ef80b7fed8338d93416cd79ad36e89fa6b35d973" translate="yes" xml:space="preserve">
          <source>Suppose we have two tables to link &lt;strong&gt;Player&lt;/strong&gt; and &lt;strong&gt;Team&lt;/strong&gt;. Lets define their models.</source>
          <target state="translated">&lt;strong&gt;Player&lt;/strong&gt; 와 &lt;strong&gt;Team&lt;/strong&gt; 을 연결하는 두 개의 테이블이 있다고 가정하십시오 . 모델을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d1b98193b4347c9a63a9bbb4d39a13215749194" translate="yes" xml:space="preserve">
          <source>Suppose we want to insert some data into a few tables by default. If we follow up on previous example we can consider creating a demo user for &lt;code&gt;User&lt;/code&gt; table.</source>
          <target state="translated">기본적으로 일부 데이터를 몇 개의 테이블에 삽입하려고한다고 가정하십시오. 이전 예제를 따라 가면 &lt;code&gt;User&lt;/code&gt; 테이블에 대한 데모 사용자를 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="63f13894b7179290120a467d9f756197261eb48d" translate="yes" xml:space="preserve">
          <source>Suppose you want to find all users who have a profile attached:</source>
          <target state="translated">프로파일이 첨부 된 모든 사용자를 찾으려고한다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="3f84ef531f9db996694ad09a8fdddbca1440577e" translate="yes" xml:space="preserve">
          <source>Symbol</source>
          <target state="translated">Symbol</target>
        </trans-unit>
        <trans-unit id="1e4961c4fd4c50f3974bcbc462ffabf9d11b7e41" translate="yes" xml:space="preserve">
          <source>Sync all defined models to the DB.</source>
          <target state="translated">정의 된 모든 모델을 DB에 동기화하십시오.</target>
        </trans-unit>
        <trans-unit id="d295b7c124f450a0ae7db9e0dd4371d5a908e16c" translate="yes" xml:space="preserve">
          <source>Sync this Model to the DB, that is create the table.</source>
          <target state="translated">이 모델을 DB와 동기화하면 테이블이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="76c4c6352a6773e5662d14b2abec0b531dc49e8c" translate="yes" xml:space="preserve">
          <source>Synchronization in production</source>
          <target state="translated">프로덕션 동기화</target>
        </trans-unit>
        <trans-unit id="49b4cf438c26e221dcf5c35f1bb5388e58acc6de" translate="yes" xml:space="preserve">
          <source>Synchronizing all models at once</source>
          <target state="translated">모든 모델을 한 번에 동기화</target>
        </trans-unit>
        <trans-unit id="7754c8e786d3eca650ff1b582693fa0714a38764" translate="yes" xml:space="preserve">
          <source>Synchronizing the model with the database</source>
          <target state="translated">데이터베이스와 모델 동기화</target>
        </trans-unit>
        <trans-unit id="e834f99dcb78400f4c128fb50e4f83eea4bd65b6" translate="yes" xml:space="preserve">
          <source>TABLOCK</source>
          <target state="translated">TABLOCK</target>
        </trans-unit>
        <trans-unit id="dcb435e28d2012463d8e6def6d52b91b7d81a93f" translate="yes" xml:space="preserve">
          <source>TABLOCKX</source>
          <target state="translated">TABLOCKX</target>
        </trans-unit>
        <trans-unit id="7d4e42ef9d04a046b5679f952cb0b6b5c498c73c" translate="yes" xml:space="preserve">
          <source>TEXT</source>
          <target state="translated">TEXT</target>
        </trans-unit>
        <trans-unit id="64269f9bd268bf28815bb69e82601cd7e806a37b" translate="yes" xml:space="preserve">
          <source>TIME</source>
          <target state="translated">TIME</target>
        </trans-unit>
        <trans-unit id="4fe5a3682f8029783789ec9b3abba10f67f03ffa" translate="yes" xml:space="preserve">
          <source>TINYINT</source>
          <target state="translated">TINYINT</target>
        </trans-unit>
        <trans-unit id="521cc63843abd0f34c261968e1d32a7dc9f6c198" translate="yes" xml:space="preserve">
          <source>Table Hint</source>
          <target state="translated">테이블 힌트</target>
        </trans-unit>
        <trans-unit id="f279a6c6b0c0cf0df9bc188612d0bba963f461b9" translate="yes" xml:space="preserve">
          <source>Table Hints - MSSQL only</source>
          <target state="translated">테이블 힌트-MSSQL 전용</target>
        </trans-unit>
        <trans-unit id="af7e10b0526f08514cc53a4f19a5efcd66befeb6" translate="yes" xml:space="preserve">
          <source>Table comments - MySQL/MariaDB/PostgreSQL only</source>
          <target state="translated">테이블 주석-MySQL / MariaDB / PostgreSQL 전용</target>
        </trans-unit>
        <trans-unit id="75afea4bf7289ee18cb79df1d3bc5160644bb8b4" translate="yes" xml:space="preserve">
          <source>Table hints override the default behavior of MSSQL query optimizer by specifing certain options. They only affect the table or view referenced in that clause.</source>
          <target state="translated">테이블 힌트는 특정 옵션을 지정하여 MSSQL 쿼리 최적화 프로그램의 기본 동작을 재정의합니다. 해당 절에서 참조 된 테이블 또는 뷰에만 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="22ba75a57550188d799bd1e025b7db1fda0a2d3e" translate="yes" xml:space="preserve">
          <source>Table hints override the default behavior of mssql query optimizer by specifing certain options. They only affect the table or view referenced in that clause.</source>
          <target state="translated">테이블 힌트는 특정 옵션을 지정하여 mssql 쿼리 최적화 프로그램의 기본 동작을 재정의합니다. 해당 절에서 참조 된 테이블이나 뷰에만 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="8e6863d69ff9e1e08b172913a67e6ba8d7a9d1a7" translate="yes" xml:space="preserve">
          <source>Table name inference</source>
          <target state="translated">테이블 이름 추론</target>
        </trans-unit>
        <trans-unit id="0cb75dbc5813b569590e4ea143ce823027afbc1b" translate="yes" xml:space="preserve">
          <source>Table name to add index on, can be a object with schema</source>
          <target state="translated">인덱스를 추가 할 테이블 이름이며 스키마가있는 객체 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fab7b43bc054cab875b79b2a0d5940d09c13933" translate="yes" xml:space="preserve">
          <source>Table name to change from</source>
          <target state="translated">변경할 테이블 이름</target>
        </trans-unit>
        <trans-unit id="2cdfba3e5bff8000906d5f3be065833e214bd7be" translate="yes" xml:space="preserve">
          <source>Table name to drop</source>
          <target state="translated">제거 할 테이블 이름</target>
        </trans-unit>
        <trans-unit id="a0d7075f146f8e02ece5c3b5bc8db30590e1c72b" translate="yes" xml:space="preserve">
          <source>Table name to drop constraint from</source>
          <target state="translated">제한 조건을 제거 할 테이블 이름</target>
        </trans-unit>
        <trans-unit id="45bc0fc9921d956e87501c72f3c69e96310abf0b" translate="yes" xml:space="preserve">
          <source>Table name to drop index from</source>
          <target state="translated">인덱스를 제거 할 테이블 이름</target>
        </trans-unit>
        <trans-unit id="b0e1e1e10f09068f7cae45a1dace79b0d9a82486" translate="yes" xml:space="preserve">
          <source>Table name to insert record to</source>
          <target state="translated">레코드를 삽입 할 테이블 이름</target>
        </trans-unit>
        <trans-unit id="f255cd8680539b5bbf5bb6cf0e61d456d5c89103" translate="yes" xml:space="preserve">
          <source>Table name to update</source>
          <target state="translated">업데이트 할 테이블 이름</target>
        </trans-unit>
        <trans-unit id="dd22d9e56c5cb140764fa721de7a45f25fe6d977" translate="yes" xml:space="preserve">
          <source>Table name where you want to add a constraint</source>
          <target state="translated">제약 조건을 추가하려는 테이블 이름</target>
        </trans-unit>
        <trans-unit id="25ca34d81d29fd398bf9c4ba66b56be70861a874" translate="yes" xml:space="preserve">
          <source>Table name whose column to rename</source>
          <target state="translated">열 이름을 바꿀 테이블 이름</target>
        </trans-unit>
        <trans-unit id="dbed374b26ccca4bdab96f82c9f48630ce076773" translate="yes" xml:space="preserve">
          <source>Table name, for backward compatibility</source>
          <target state="translated">이전 버전과의 호환성을위한 테이블 이름</target>
        </trans-unit>
        <trans-unit id="d210072aac6aa90c45934daef475a90e10b81e26" translate="yes" xml:space="preserve">
          <source>Table to add column to</source>
          <target state="translated">열을 추가 할 테이블</target>
        </trans-unit>
        <trans-unit id="8ebb87b4f0d6b0bd82f500cb89d5d63fe2b3bb66" translate="yes" xml:space="preserve">
          <source>Table to remove column from</source>
          <target state="translated">열을 제거 할 테이블</target>
        </trans-unit>
        <trans-unit id="5bf88ac554232d98885b8cc704c53a61fd9b173e" translate="yes" xml:space="preserve">
          <source>Table whose enum to list</source>
          <target state="translated">나열 할 열거 형 테이블</target>
        </trans-unit>
        <trans-unit id="c30f8dfdb7e7408d778802c6ee43b43deb695358" translate="yes" xml:space="preserve">
          <source>TableHints</source>
          <target state="translated">TableHints</target>
        </trans-unit>
        <trans-unit id="193daf137ed8b89de36d47c3df5fd8f66c0e1d14" translate="yes" xml:space="preserve">
          <source>Tables</source>
          <target state="translated">Tables</target>
        </trans-unit>
        <trans-unit id="79ee69ddcfd672d3bc85bea16a439cf5bd7deffd" translate="yes" xml:space="preserve">
          <source>Take a look at the &lt;a href=&quot;sub-queries&quot;&gt;guide on sub-queries&lt;/a&gt; for an example of how to use a sub-query to assist a more complex ordering.</source>
          <target state="translated">상기 살펴보세요 &lt;a href=&quot;sub-queries&quot;&gt;하위 쿼리에 대한 가이드&lt;/a&gt; 더 복잡한 순서를 지원하기 위해 하위 쿼리를 사용하는 방법의 예를 들어.</target>
        </trans-unit>
        <trans-unit id="8dc45ca0cbf9b74394403cbf72151fe3cc9e49fe" translate="yes" xml:space="preserve">
          <source>Taking advantage of Models being classes</source>
          <target state="translated">모델을 클래스로 활용</target>
        </trans-unit>
        <trans-unit id="e396b94e25d4b0c0ef34b12c624dbfa7272476fb" translate="yes" xml:space="preserve">
          <source>Target column name</source>
          <target state="translated">대상 열 이름</target>
        </trans-unit>
        <trans-unit id="975ce3d3070b51cecd838e1da8d21e0ef5ce9336" translate="yes" xml:space="preserve">
          <source>Target keys</source>
          <target state="translated">대상 키</target>
        </trans-unit>
        <trans-unit id="5c068aa69f6d4ef42a8389abe9cd810232caae05" translate="yes" xml:space="preserve">
          <source>Target model</source>
          <target state="translated">대상 모델</target>
        </trans-unit>
        <trans-unit id="2f66e0e68c2c913dd1bf905e22855cbb450958e6" translate="yes" xml:space="preserve">
          <source>Target table name</source>
          <target state="translated">대상 테이블 이름</target>
        </trans-unit>
        <trans-unit id="9571ecbd5c615670005c040c4a66bcf7d2842e05" translate="yes" xml:space="preserve">
          <source>Terminology convention</source>
          <target state="translated">용어 규칙</target>
        </trans-unit>
        <trans-unit id="0672d7ed7ed6afdfd270b53235aa08ccc0eed98a" translate="yes" xml:space="preserve">
          <source>Test the connection by trying to authenticate.</source>
          <target state="translated">인증을 시도하여 연결을 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="20b77d389f5e8c5e987282b922a807df1f9260e2" translate="yes" xml:space="preserve">
          <source>Test the connection by trying to authenticate. It runs &lt;code&gt;SELECT 1+1 AS result&lt;/code&gt; query.</source>
          <target state="translated">인증을 시도하여 연결을 테스트하십시오. &lt;code&gt;SELECT 1+1 AS result&lt;/code&gt; 쿼리를 실행 합니다.</target>
        </trans-unit>
        <trans-unit id="e0143c072d5ac7b543f7a97b25b22cf87a465c03" translate="yes" xml:space="preserve">
          <source>Testing the connection</source>
          <target state="translated">연결 테스트</target>
        </trans-unit>
        <trans-unit id="b27367401838295e96f5e65abb3dce8cc8c20dc3" translate="yes" xml:space="preserve">
          <source>Thankfully, the Sequelize CLI can read from both &lt;code&gt;.json&lt;/code&gt; and &lt;code&gt;.js&lt;/code&gt; files. This can be setup with &lt;code&gt;.sequelizerc&lt;/code&gt; file. You just have to provide the path to your &lt;code&gt;.js&lt;/code&gt; file as the &lt;code&gt;config&lt;/code&gt; option of your exported object:</source>
          <target state="translated">고맙게도 Sequelize CLI는 &lt;code&gt;.json&lt;/code&gt; 및 &lt;code&gt;.js&lt;/code&gt; 파일 모두에서 읽을 수 있습니다. &lt;code&gt;.sequelizerc&lt;/code&gt; 파일 로 설정할 수 있습니다 . 내 보낸 개체 의 &lt;code&gt;config&lt;/code&gt; 옵션 으로 &lt;code&gt;.js&lt;/code&gt; 파일 의 경로를 제공하기 만하면 됩니다 .</target>
        </trans-unit>
        <trans-unit id="568f2e98eee27a557d9647a1ac065019cb0ca54f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../class/lib/model.js~model#static-method-create&quot;&gt;&lt;code&gt;Model.create()&lt;/code&gt;&lt;/a&gt; method is a shorthand for building an unsaved instance with &lt;a href=&quot;../class/lib/model.js~model#static-method-build&quot;&gt;&lt;code&gt;Model.build()&lt;/code&gt;&lt;/a&gt; and saving the instance with &lt;a href=&quot;../class/lib/model.js~model#instance-method-save&quot;&gt;&lt;code&gt;instance.save()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../class/lib/model.js~model#static-method-create&quot;&gt; &lt;code&gt;Model.create()&lt;/code&gt; &lt;/a&gt; 메소드에 저장되지 않은 인스턴스를 만들기위한 속기 &lt;a href=&quot;../class/lib/model.js~model#static-method-build&quot;&gt; &lt;code&gt;Model.build()&lt;/code&gt; &lt;/a&gt; 으로 인스턴스를 저장하고 &lt;a href=&quot;../class/lib/model.js~model#instance-method-save&quot;&gt; &lt;code&gt;instance.save()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="72eaf96e82866444ce5e4d262b9b4f5480574f70" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$nested.column$&lt;/code&gt; syntax also works for columns that are nested several levels deep, such as &lt;code&gt;$some.super.deeply.nested.column$&lt;/code&gt;. Therefore, you can use this to make complex filters on deeply nested columns.</source>
          <target state="translated">&lt;code&gt;$nested.column$&lt;/code&gt; 구문은 또한 깊은 여러 수준의 중첩 된 열, 작동 &lt;code&gt;$some.super.deeply.nested.column$&lt;/code&gt; . 따라서이를 사용하여 깊이 중첩 된 열에 복잡한 필터를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c363795bd7fa8fcfababae3f9976a3e94d298a31" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.sequelizerc&lt;/code&gt; File</source>
          <target state="translated">&lt;code&gt;.sequelizerc&lt;/code&gt; 의 파일</target>
        </trans-unit>
        <trans-unit id="b95b79ea2ee195c20660d13062d0525afe3cbaa1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.sequelizerc&lt;/code&gt; file</source>
          <target state="translated">&lt;code&gt;.sequelizerc&lt;/code&gt; 의 파일</target>
        </trans-unit>
        <trans-unit id="6556e00b0fd6ff35375c48dbbfce2618382539b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;A.belongsTo(B)&lt;/code&gt; association means that a One-To-One relationship exists between &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, with the foreign key being defined in the source model (&lt;code&gt;A&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;A.belongsTo(B)&lt;/code&gt; 에 일대일 관계가 존재한다는 간의 연관 수단 및 &lt;code&gt;B&lt;/code&gt; 외래 키는 소스 모델 (정의되는 ). &lt;code&gt;A&lt;/code&gt; &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d7631f9eeb6d6f5477598617b0a91cd2eeb841aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;A.belongsToMany(B, { through: 'C' })&lt;/code&gt; association means that a Many-To-Many relationship exists between &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, using table &lt;code&gt;C&lt;/code&gt; as &lt;a href=&quot;https://en.wikipedia.org/wiki/Associative_entity&quot;&gt;junction table&lt;/a&gt;, which will have the foreign keys (&lt;code&gt;aId&lt;/code&gt; and &lt;code&gt;bId&lt;/code&gt;, for example). Sequelize will automatically create this model &lt;code&gt;C&lt;/code&gt; (unless it already exists) and define the appropriate foreign keys on it.</source>
          <target state="translated">&lt;code&gt;A.belongsToMany(B, { through: 'C' })&lt;/code&gt; 대다 관계 사이 있는지 연관 수단 및 &lt;code&gt;B&lt;/code&gt; 테이블하여, &lt;code&gt;C&lt;/code&gt; 를 같이 &lt;a href=&quot;https://en.wikipedia.org/wiki/Associative_entity&quot;&gt;접합 테이블&lt;/a&gt; 외래 키 (것이다하는 &lt;code&gt;aId&lt;/code&gt; 와 &lt;code&gt;bId&lt;/code&gt; 들면, 예). Sequelize는이 모델 &lt;code&gt;C&lt;/code&gt; 를 자동으로 생성 하고 (이미 존재하지 않는 한) 적절한 외래 키를 정의합니다. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="86f12df5772aa12d8d84c39c1c7ff68527b908ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;A.hasMany(B)&lt;/code&gt; association means that a One-To-Many relationship exists between &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, with the foreign key being defined in the target model (&lt;code&gt;B&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;A.hasMany(B)&lt;/code&gt; 일대 다 관계가 존재하는지간에 연관 수단 및 &lt;code&gt;B&lt;/code&gt; 외래 키는 대상 모델 (정의되는 &lt;code&gt;B&lt;/code&gt; ). &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6c6c69626c5c01d5dcbdf9efaf04d85073dffee7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;A.hasOne(B)&lt;/code&gt; association means that a One-To-One relationship exists between &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, with the foreign key being defined in the target model (&lt;code&gt;B&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;A.hasOne(B)&lt;/code&gt; 에 일대일 관계가 존재한다는 간의 연관 수단 및 &lt;code&gt;B&lt;/code&gt; 외래 키는 대상 모델 (정의되는 &lt;code&gt;B&lt;/code&gt; ). &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1c7b6e4b5e4fc620fd15f03dd52a525e06452156" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BelongsTo&lt;/code&gt; association</source>
          <target state="translated">&lt;code&gt;BelongsTo&lt;/code&gt; 협회</target>
        </trans-unit>
        <trans-unit id="47a7f8a40baa6994a0957e349fccd2b9bd19f7f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BelongsToMany&lt;/code&gt; association</source>
          <target state="translated">&lt;code&gt;BelongsToMany&lt;/code&gt; 의 협회</target>
        </trans-unit>
        <trans-unit id="52fdd6c7b19c53e9c7650c11a173d0518be4c70c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CHAR&lt;/code&gt; and &lt;code&gt;STRING&lt;/code&gt; types expose the &lt;code&gt;BINARY&lt;/code&gt; property</source>
          <target state="translated">&lt;code&gt;CHAR&lt;/code&gt; 및 &lt;code&gt;STRING&lt;/code&gt; 유형은 노출 &lt;code&gt;BINARY&lt;/code&gt; 속성을</target>
        </trans-unit>
        <trans-unit id="7600cec6ae24a13ffe264e716d87838eb471f5e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DataTypes.JSON&lt;/code&gt; data type is only supported for SQLite, MySQL, MariaDB and PostgreSQL. However, there is a minimum support for MSSQL (see below).</source>
          <target state="translated">&lt;code&gt;DataTypes.JSON&lt;/code&gt; 의 데이터 유형은 SQLite는, MySQL은, MariaDB와 PostgreSQL을 지원한다. 그러나 MSSQL에 대한 최소한의 지원이 있습니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="88e940a613dc84bba3eb506147017fe959e3612c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HasMany&lt;/code&gt; association</source>
          <target state="translated">&lt;code&gt;HasMany&lt;/code&gt; 협회</target>
        </trans-unit>
        <trans-unit id="3a4a9eea63dca47e14277fdb92b510c65b7c6636" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HasOne&lt;/code&gt; association</source>
          <target state="translated">&lt;code&gt;HasOne&lt;/code&gt; 관계</target>
        </trans-unit>
        <trans-unit id="e62599cbbbea68972ec8f602f844dd6a54bb81a6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VIRTUAL&lt;/code&gt; field does not cause a column in the table to exist. In other words, the model above will not have a &lt;code&gt;fullName&lt;/code&gt; column. However, it will appear to have it!</source>
          <target state="translated">&lt;code&gt;VIRTUAL&lt;/code&gt; 필드는 테이블의 열이 존재하는 원인이되지 않습니다. 즉, 위의 모델에는 &lt;code&gt;fullName&lt;/code&gt; 열 이 없습니다 . 그러나 그것을 가진 것처럼 보일 것입니다!</target>
        </trans-unit>
        <trans-unit id="0058711367bd371361206d0de0cc11e1c93c7223" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;afterCommit&lt;/code&gt; hook</source>
          <target state="translated">&lt;code&gt;afterCommit&lt;/code&gt; 의 후크</target>
        </trans-unit>
        <trans-unit id="fd49fb8ea0e2805baf32374d10805d1aa41d3236" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;afterCommit&lt;/code&gt; hook does not modify the return value of the transaction (unlike most hooks)</source>
          <target state="translated">&lt;code&gt;afterCommit&lt;/code&gt; 의 후크 (대부분의 후크는 달리) 트랜잭션의 반환 값을 수정하지 않습니다</target>
        </trans-unit>
        <trans-unit id="b9da626713c9dd20acca787fe153465ec9966438" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;afterCommit&lt;/code&gt; hook is not raised if the transaction is rolled back;</source>
          <target state="translated">&lt;code&gt;afterCommit&lt;/code&gt; 의 트랜잭션이 롤백되면 훅이 발생하지 않습니다;</target>
        </trans-unit>
        <trans-unit id="570b17cc26f9313370a82adc76ad5a4521b735d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;allowNull&lt;/code&gt; check is the only check in Sequelize that is a mix of a &lt;em&gt;validation&lt;/em&gt; and a &lt;em&gt;constraint&lt;/em&gt; in the senses described at the beginning of this tutorial. This is because:</source>
          <target state="translated">&lt;code&gt;allowNull&lt;/code&gt; 의 검사는 단지의 혼합이다 Sequelize 체크 인 &lt;em&gt;검증&lt;/em&gt; 과 &lt;em&gt;제약&lt;/em&gt; 이 튜토리얼의 시작 부분에 설명 된 감각이다. 이 때문입니다:</target>
        </trans-unit>
        <trans-unit id="f85312d4d5e449e617856aefd639e43309c7fb08" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;beforeDestroy&lt;/code&gt; and &lt;code&gt;afterDestroy&lt;/code&gt; hooks will only be called on associations that have &lt;code&gt;onDelete: 'CASCADE'&lt;/code&gt; and &lt;code&gt;hooks: true&lt;/code&gt;. For example:</source>
          <target state="translated">&lt;code&gt;beforeDestroy&lt;/code&gt; 및 &lt;code&gt;afterDestroy&lt;/code&gt; 훅은이 협회에 호출됩니다 &lt;code&gt;onDelete: 'CASCADE'&lt;/code&gt; 하고 &lt;code&gt;hooks: true&lt;/code&gt; . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bfbf8f71ca457c562abf5b202d58f98aa0a1228b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;constraints: false&lt;/code&gt; option disables references constraints, as the &lt;code&gt;taggableId&lt;/code&gt; column references several tables, we cannot add a &lt;code&gt;REFERENCES&lt;/code&gt; constraint to it.</source>
          <target state="translated">&lt;code&gt;constraints: false&lt;/code&gt; 옵션이 비활성화 참조 제약은 같은 &lt;code&gt;taggableId&lt;/code&gt; 의 열 참조 여러 테이블, 우리는 추가 할 수 없습니다 &lt;code&gt;REFERENCES&lt;/code&gt; 여기에 제약 조건을.</target>
        </trans-unit>
        <trans-unit id="0fe733a598aa7e0232df3a9acff9ba20a81570c4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;count&lt;/code&gt; method simply counts the occurrences of elements in the database.</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; 메소드는 데이터베이스에있는 요소의 발생을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="24c9e16083b478a394668e549bac5173531569ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;findAll&lt;/code&gt; method is already known from the previous tutorial. It generates a standard &lt;code&gt;SELECT&lt;/code&gt; query which will retrieve all entries from the table (unless restricted by something like a &lt;code&gt;where&lt;/code&gt; clause, for example).</source>
          <target state="translated">&lt;code&gt;findAll&lt;/code&gt; 방법은 이미 이전 튜토리얼에서 알려져있다. 테이블에서 모든 항목을 검색 하는 표준 &lt;code&gt;SELECT&lt;/code&gt; 쿼리를 생성 합니다 ( 예를 들어 &lt;code&gt;where&lt;/code&gt; 절 과 같은 것에 의해 제한되지 않는 한 ).</target>
        </trans-unit>
        <trans-unit id="8aebec1ae1fefc4f0cd12ce41f442ec317dbbfde" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;findAndCountAll&lt;/code&gt; method is a convenience method that combines &lt;code&gt;findAll&lt;/code&gt; and &lt;code&gt;count&lt;/code&gt;. This is useful when dealing with queries related to pagination where you want to retrieve data with a &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt; but also need to know the total number of records that match the query.</source>
          <target state="translated">&lt;code&gt;findAndCountAll&lt;/code&gt; 에 있어서 결합하는 편리한 방법이다 &lt;code&gt;findAll&lt;/code&gt; 하고 &lt;code&gt;count&lt;/code&gt; . 이는 &lt;code&gt;limit&lt;/code&gt; 및 &lt;code&gt;offset&lt;/code&gt; 사용하여 데이터를 검색하려고 하지만 쿼리와 일치하는 총 레코드 수를 알아야하는 페이지 매김과 관련된 쿼리를 처리 할 때 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="9e0d688814852fa86a5172074f270b37c26dd610" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;findAndCountAll&lt;/code&gt; method returns an object with two properties:</source>
          <target state="translated">&lt;code&gt;findAndCountAll&lt;/code&gt; 의 방법은 두 가지 속성을 가진 객체를 반환</target>
        </trans-unit>
        <trans-unit id="67d8eb751d14b403a6227075478f695df10ef983" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;findAndCountAll&lt;/code&gt; utility function supports includes. Only the includes that are marked as &lt;code&gt;required&lt;/code&gt; will be considered in &lt;code&gt;count&lt;/code&gt;. For example, if you want to find and count all users who have a profile:</source>
          <target state="translated">&lt;code&gt;findAndCountAll&lt;/code&gt; 유틸리티 기능 지원이 포함되어 있습니다. &lt;code&gt;required&lt;/code&gt; 로 표시된 포함 만 &lt;code&gt;count&lt;/code&gt; 에 포함 됩니다. 예를 들어 프로필이있는 모든 사용자를 찾아서 계산하려면 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="dea4b54d906bb065ca0b8c270ee30153593a1104" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;findByPk&lt;/code&gt; method obtains only a single entry from the table, using the provided primary key.</source>
          <target state="translated">&lt;code&gt;findByPk&lt;/code&gt; 의 방법은 제공되는 기본 키를 이용하여 테이블에서 단일 항목을 획득한다.</target>
        </trans-unit>
        <trans-unit id="f489e6b449bef63c9416ca41952228dec1d7850e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;findOne&lt;/code&gt; method obtains the first entry it finds (that fulfills the optional query options, if provided).</source>
          <target state="translated">&lt;code&gt;findOne&lt;/code&gt; 의 (제공되는 경우, 그 충족 옵션 쿼리 옵션) 방법을 찾은 첫 번째 항목을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="96604eb0bb158befed8a640da0e7f3054be98f32" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fullName&lt;/code&gt; getter, is an example of how you can define pseudo properties on your models - attributes which are not actually part of your database schema. In fact, pseudo properties can be defined in two ways: using model getters, or by using a column with the &lt;a href=&quot;https://sequelize.org/variable/index.html#static-variable-DataTypes&quot;&gt;&lt;code&gt;VIRTUAL&lt;/code&gt; datatype&lt;/a&gt;. Virtual datatypes can have validations, while getters for virtual attributes cannot.</source>
          <target state="translated">&lt;code&gt;fullName&lt;/code&gt; 의의 실제 데이터베이스 스키마의 일부가 아닌 속성 - 게터는, 당신이 당신의 모델에 의사의 속성을 정의 할 수있는 방법의 예입니다. 실제로 의사 특성은 두 가지 방법으로 정의 될 수 있습니다. 모델 게터 사용 또는 &lt;a href=&quot;https://sequelize.org/variable/index.html#static-variable-DataTypes&quot;&gt; &lt;code&gt;VIRTUAL&lt;/code&gt; 데이터 유형&lt;/a&gt; 의 열 사용 . 가상 데이터 유형에는 유효성 검사가 가능하지만 가상 속성에 대한 Getter는 유효성 검사가 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="94772cb39d84248b9b8101ed1adddd961b6e56eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getCommentable&lt;/code&gt; instance method on &lt;code&gt;Comment&lt;/code&gt; provides an abstraction for lazy loading the associated commentable - working whether the comment belongs to an Image or a Video.</source>
          <target state="translated">&lt;code&gt;Comment&lt;/code&gt; 의 &lt;code&gt;getCommentable&lt;/code&gt; 인스턴스 메소드는 댓글 이 이미지에 속하든 동영상에 속하든 상관없이 연결된 댓글을 지연로드하기위한 추상화를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b44f8380a2468cdb72b9deb6e94e4793fc900145" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getItem&lt;/code&gt; utility function on &lt;code&gt;Comment&lt;/code&gt; completes the picture - it simply converts the &lt;code&gt;commentable&lt;/code&gt; string into a call to either &lt;code&gt;getImage&lt;/code&gt; or &lt;code&gt;getPost&lt;/code&gt;, providing an abstraction over whether a comment belongs to a post or an image. You can pass a normal options object as a parameter to &lt;code&gt;getItem(options)&lt;/code&gt; to specify any where conditions or includes.</source>
          <target state="translated">&lt;code&gt;Comment&lt;/code&gt; 의 &lt;code&gt;getItem&lt;/code&gt; 유틸리티 함수 는 그림을 완성합니다. &lt;code&gt;commentable&lt;/code&gt; 문자열을 &lt;code&gt;getImage&lt;/code&gt; 또는 &lt;code&gt;getPost&lt;/code&gt; 호출로 변환하여 주석 이 게시물 또는 이미지에 속하는지 여부에 대한 추상화를 제공합니다. 일반 옵션 오브젝트를 매개 변수로 &lt;code&gt;getItem(options)&lt;/code&gt; 하여 위치 또는 조건을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5af38db2b9d87be8fca742043ab85cd54ed8644" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;import&lt;/code&gt; method can also accept a callback as an argument.</source>
          <target state="translated">&lt;code&gt;import&lt;/code&gt; 방법은 인수로 콜백을받을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1b100c6a9dfa09d651a4fc36b203eb376021f80" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;include&lt;/code&gt; option can receive an array in order to fetch multiple associated models at once:</source>
          <target state="translated">&lt;code&gt;include&lt;/code&gt; 옵션은 한 번에 여러 관련된 모델을 인출하기 위해 배열을받을 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="284da7b0f2efef628e5e38ad92056d0d65acb654" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;indexHints&lt;/code&gt; option can be used to define index hints. The hint type must be a value from &lt;code&gt;IndexHints&lt;/code&gt; and the values should reference existing indexes.</source>
          <target state="translated">&lt;code&gt;indexHints&lt;/code&gt; 의 옵션은 인덱스 힌트를 정의 할 수 있습니다. 힌트 유형은 &lt;code&gt;IndexHints&lt;/code&gt; 의 값이어야하며 값은 기존 인덱스를 참조해야합니다.</target>
        </trans-unit>
        <trans-unit id="7c66c416ba19dd8a604d0fa8c48849d0b7770c55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;isolationLevel&lt;/code&gt; can either be set globally when initializing the Sequelize instance or locally for every transaction:</source>
          <target state="translated">&lt;code&gt;isolationLevel&lt;/code&gt; 는 모든 트랜잭션에 대한 로컬 Sequelize 인스턴스를 초기화하거나 전역으로 설정할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="34c936a4831eb1b0fc997732d2c777c7982b2aff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt; options allow you to work with limiting / pagination:</source>
          <target state="translated">&lt;code&gt;limit&lt;/code&gt; 및 &lt;code&gt;offset&lt;/code&gt; 옵션은 제한 / 매김과 함께 작업 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="aded916b2d52b83cbd3a306bbcaac58553342812" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;options&lt;/code&gt; argument of hook method would be the second argument provided to the corresponding method or its cloned and extended version.</source>
          <target state="translated">hook 메소드 의 &lt;code&gt;options&lt;/code&gt; 인수는 해당 메소드 또는 복제 및 확장 버전에 제공된 두 번째 인수입니다.</target>
        </trans-unit>
        <trans-unit id="dcfed95825cb653037f8b09d52d377599234b0d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;order&lt;/code&gt; option takes an array of items to order the query by or a sequelize method. These &lt;em&gt;items&lt;/em&gt; are themselves arrays in the form &lt;code&gt;[column, direction]&lt;/code&gt;. The column will be escaped correctly and the direction will be checked in a whitelist of valid directions (such as &lt;code&gt;ASC&lt;/code&gt;, &lt;code&gt;DESC&lt;/code&gt;, &lt;code&gt;NULLS FIRST&lt;/code&gt;, etc).</source>
          <target state="translated">&lt;code&gt;order&lt;/code&gt; 옵션하여 쿼리 또는 sequelize 방법 주문 상품의 배열 걸린다. 이러한 &lt;em&gt;항목&lt;/em&gt; 자체는 &lt;code&gt;[column, direction]&lt;/code&gt; 형식의 배열입니다 . 열이 올바르게 이스케이프되고 올바른 방향 (예 : &lt;code&gt;ASC&lt;/code&gt; , &lt;code&gt;DESC&lt;/code&gt; , &lt;code&gt;NULLS FIRST&lt;/code&gt; 등) 의 화이트리스트에서 방향이 확인됩니다 .</target>
        </trans-unit>
        <trans-unit id="7f1c72bd74a6d53ac21270c47506975ff4de74d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;save&lt;/code&gt; method is optimized internally to only update fields that really changed. This means that if you don't change anything and call &lt;code&gt;save&lt;/code&gt;, Sequelize will know that the save is superfluous and do nothing, i.e., no query will be generated (it will still return a Promise, but it will resolve immediately).</source>
          <target state="translated">&lt;code&gt;save&lt;/code&gt; 방법은 정말 변화에만 업데이트 필드에 내부적으로 최적화되어 있습니다. 즉 , 아무것도 변경하지 않고 &lt;code&gt;save&lt;/code&gt; 를 호출 하면 Sequelize는 저장이 불필요하다는 것을 알고 아무 작업도하지 않습니다. 즉, 쿼리가 생성되지 않습니다 (계속 Promise를 반환하지만 즉시 해결됨).</target>
        </trans-unit>
        <trans-unit id="0af42d8bd5b7cfd2edde2caa3dfa0fa35d2d1ea9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sequelize.transaction&lt;/code&gt; method accepts options.</source>
          <target state="translated">&lt;code&gt;sequelize.transaction&lt;/code&gt; 의 방법은 옵션을 받아들입니다.</target>
        </trans-unit>
        <trans-unit id="ee0aa7fe5449d3d4a774b664351e181a1ecfadc9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tableHint&lt;/code&gt; option can be used to define a table hint. The hint must be a value from &lt;code&gt;TableHints&lt;/code&gt; and should only be used when absolutely necessary. Only a single table hint is currently supported per query.</source>
          <target state="translated">&lt;code&gt;tableHint&lt;/code&gt; 의 옵션은 테이블 힌트를 정의 할 수 있습니다. 힌트는 &lt;code&gt;TableHints&lt;/code&gt; 의 값이어야하며 반드시 필요한 경우에만 사용해야합니다. 현재 쿼리 당 하나의 테이블 힌트 만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="2c3edf2dae93cebe8c0dd348f57f9ba4d5fbc9fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;transaction&lt;/code&gt; option goes with most other options, which are usually the first argument of a method.</source>
          <target state="translated">&lt;code&gt;transaction&lt;/code&gt; 옵션은 일반적으로 방법의 첫 번째 인수 대부분의 다른 옵션으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="6e08cedd8bd068ee0e858ac36cf905e6a6544cca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;transaction&lt;/code&gt; option goes with most other options, which are usually the first argument of a method. For methods that take values, like &lt;code&gt;.create&lt;/code&gt;, &lt;code&gt;.update()&lt;/code&gt;, etc. &lt;code&gt;transaction&lt;/code&gt; should be passed to the option in the second argument. If unsure, refer to the API documentation for the method you are using to be sure of the signature.</source>
          <target state="translated">&lt;code&gt;transaction&lt;/code&gt; 옵션은 일반적으로 방법의 첫 번째 인수 대부분의 다른 옵션으로 이동합니다. 같은 값을 메소드의 &lt;code&gt;.create&lt;/code&gt; , &lt;code&gt;.update()&lt;/code&gt; 등의 &lt;code&gt;transaction&lt;/code&gt; 두 번째 인수에 옵션을 전달해야합니다. 확실하지 않은 경우 서명을 확인하는 데 사용하는 방법에 대한 API 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="022e1cf7c93a2fd52499617385297a647f632df8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;underscored&lt;/code&gt; option</source>
          <target state="translated">&lt;code&gt;underscored&lt;/code&gt; 옵션</target>
        </trans-unit>
        <trans-unit id="1a9143d79be7a63d84ab8972f100607e8244a7c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;where&lt;/code&gt; option is considered for finding the entry, and the &lt;code&gt;defaults&lt;/code&gt; option is used to define what must be created in case nothing was found. If the &lt;code&gt;defaults&lt;/code&gt; do not contain values for every column, Sequelize will take the values given to &lt;code&gt;where&lt;/code&gt; (if present).</source>
          <target state="translated">&lt;code&gt;where&lt;/code&gt; 옵션 항목을 찾기 위해 고려하고, &lt;code&gt;defaults&lt;/code&gt; 옵션이 발견 된 어떤 경우 아무것도 만들어야합니다 정의하는 데 사용됩니다. &lt;code&gt;defaults&lt;/code&gt; 에 모든 열의 값이 포함되어 있지 않은 경우 Sequelize는 (있는 경우) &lt;code&gt;where&lt;/code&gt; 제공된 값을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="e51b4fc5e99e38c0e0729aea28789798dee39b04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;where&lt;/code&gt; option is used to filter the query. There are lots of operators to use for the &lt;code&gt;where&lt;/code&gt; clause, available as Symbols from &lt;a href=&quot;../variable/index#static-variable-Op&quot;&gt;&lt;code&gt;Op&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;where&lt;/code&gt; 옵션은 쿼리를 필터링하는 데 사용됩니다. 에 사용하는 사업자가 많이 있습니다 &lt;code&gt;where&lt;/code&gt; 사용할 수의 기호와 같은 절, &lt;a href=&quot;../variable/index#static-variable-Op&quot;&gt; &lt;code&gt;Op&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3590f222c1774921a947a6d2595c4fef72b91320" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;Image -&amp;gt; Comment&lt;/em&gt; association defined an association scope: &lt;code&gt;{ commentableType: 'image' }&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;이미지 -&amp;gt; 주석&lt;/em&gt; 연관은 연관 범위를 정의 : &lt;code&gt;{ commentableType: 'image' }&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="53ab69825a495d508248d17cc0a7172bce810d0c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;Image -&amp;gt; Tag&lt;/em&gt; association defined an association scope: &lt;code&gt;{ taggableType: 'image' }&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;이미지 -&amp;gt; 태그&lt;/em&gt; 협회는 협회 범위를 정의 : &lt;code&gt;{ taggableType: 'image' }&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="729896b8914d0fd957193b72821176d0e5c2a893" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;Video -&amp;gt; Comment&lt;/em&gt; association defined an association scope: &lt;code&gt;{ commentableType: 'video' }&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;- 비디오&amp;gt; 주석&lt;/em&gt; : 연관은 연관 범위 정의 &lt;code&gt;{ commentableType: 'video' }&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="317cc280f32843f2fa8681d1b08c1caf792501fa" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;Video -&amp;gt; Tag&lt;/em&gt; association defined an association scope: &lt;code&gt;{ taggableType: 'video' }&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;- 비디오&amp;gt; 태그&lt;/em&gt; : 협회는 협회 범위 정의 &lt;code&gt;{ taggableType: 'video' }&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4b9b49b97c6dcd275458969fdd514038c0782971" translate="yes" xml:space="preserve">
          <source>The BLOB datatype allows you to insert data both as strings and as buffers. When you do a find or findAll on a model which has a BLOB column, that data will always be returned as a buffer.</source>
          <target state="translated">BLOB 데이터 유형을 사용하면 데이터를 문자열과 버퍼로 삽입 할 수 있습니다. BLOB 열이있는 모델에서 find 또는 findAll을 수행하면 해당 데이터는 항상 버퍼로 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="0d6ca5d74c8816ae0ded15e2a7a5beeecbf88579" translate="yes" xml:space="preserve">
          <source>The CLI</source>
          <target state="translated">CLI</target>
        </trans-unit>
        <trans-unit id="7543057877a60db6d5a05a1ccb4e14c360eef266" translate="yes" xml:space="preserve">
          <source>The DAO instance that caused the validation error</source>
          <target state="translated">유효성 검사 오류를 일으킨 DAO 인스턴스</target>
        </trans-unit>
        <trans-unit id="6a6b222c2e8432df16ac7772dc83419f644e917d" translate="yes" xml:space="preserve">
          <source>The ENUM is a data type that accepts only a few values, specified as a list.</source>
          <target state="translated">ENUM은 목록으로 지정된 몇 가지 값만 허용하는 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="5c2f82b73e030655c59432ce481b35adff70c042" translate="yes" xml:space="preserve">
          <source>The INET type holds an IPv4 or IPv6 host address, and optionally its subnet. Takes 7 or 19 bytes</source>
          <target state="translated">INET 유형에는 IPv4 또는 IPv6 호스트 주소와 선택적으로 해당 서브넷이 있습니다. 7 또는 19 바이트 소요</target>
        </trans-unit>
        <trans-unit id="35c885e3e1208b7964c450f516be8caa8371b964" translate="yes" xml:space="preserve">
          <source>The JSON data type in PostgreSQL stores the value as plain text, as opposed to binary representation. If you simply want to store and retrieve a JSON representation, using JSON will take less disk space and less time to build from its input representation. However, if you want to do any operations on the JSON value, you should prefer the JSONB data type described below.</source>
          <target state="translated">PostgreSQL의 JSON 데이터 형식은 이진 표현이 아닌 일반 텍스트로 값을 저장합니다. 단순히 JSON 표현을 저장하고 검색하려는 경우 JSON을 사용하면 입력 표현에서 작성하는 데 필요한 디스크 공간과 시간이 줄어 듭니다. 그러나 JSON 값에 대한 조작을 수행하려면 아래 설명 된 JSONB 데이터 유형을 선호해야합니다.</target>
        </trans-unit>
        <trans-unit id="4f1ca89726cfb75c61b955405275bfa81fa8f0e1" translate="yes" xml:space="preserve">
          <source>The JSON data type is supported by the PostgreSQL, SQLite, MySQL and MariaDB dialects only.</source>
          <target state="translated">JSON 데이터 유형은 PostgreSQL, SQLite, MySQL 및 MariaDB 방언에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="b4c18d45f4c7b31dc5aabb26fb9a9e22f31ce7cc" translate="yes" xml:space="preserve">
          <source>The MACADDR type stores MAC addresses. Takes 6 bytes</source>
          <target state="translated">MACADDR 유형은 MAC 주소를 저장합니다. 6 바이트 소요</target>
        </trans-unit>
        <trans-unit id="6e037bc95bcf7d5b574c2d17b15f920746d615f7" translate="yes" xml:space="preserve">
          <source>The PostgreSQL &lt;code&gt;client_min_messages&lt;/code&gt; session parameter. Set to &lt;code&gt;false&lt;/code&gt; to not override the database's default.</source>
          <target state="translated">PostgreSQL &lt;code&gt;client_min_messages&lt;/code&gt; 세션 매개 변수입니다. 데이터베이스의 기본값을 무시하지 않으 려면 &lt;code&gt;false&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="92dcd073ff1557550a8981af1e6e839e5e4fae74" translate="yes" xml:space="preserve">
          <source>The PostgreSQL &lt;code&gt;standard_conforming_strings&lt;/code&gt; session parameter. Set to &lt;code&gt;false&lt;/code&gt; to not set the option. WARNING: Setting this to false may expose vulnerabilities and is not recommended!</source>
          <target state="translated">PostgreSQL &lt;code&gt;standard_conforming_strings&lt;/code&gt; 세션 매개 변수입니다. 옵션을 설정하지 않으 려면 &lt;code&gt;false&lt;/code&gt; 로 설정하십시오. 경고 :이 값을 false로 설정하면 취약점이 노출 될 수 있으므로 권장하지 않습니다!</target>
        </trans-unit>
        <trans-unit id="ea2917bca3214c2f94009ee7f7e0ef5cef7ed728" translate="yes" xml:space="preserve">
          <source>The SQL that triggered the error</source>
          <target state="translated">오류를 유발 한 SQL</target>
        </trans-unit>
        <trans-unit id="dd06cbc4597dae28da3671cb9bf462c1afbf0a9b" translate="yes" xml:space="preserve">
          <source>The Sequelize constructor accepts a lot of options. They are documented in the &lt;a href=&quot;../class/lib/sequelize.js~sequelize#instance-constructor-constructor&quot;&gt;API Reference&lt;/a&gt;.</source>
          <target state="translated">Sequelize 생성자는 많은 옵션을 허용합니다. &lt;a href=&quot;../class/lib/sequelize.js~sequelize#instance-constructor-constructor&quot;&gt;API 참조에&lt;/a&gt; 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdfcd4dec9f023d328d1c29bf2ce667d576056f9" translate="yes" xml:space="preserve">
          <source>The Sequelize constructor takes a &lt;code&gt;define&lt;/code&gt; option which will change the default options for all defined models.</source>
          <target state="translated">Sequelize 생성자는 &lt;code&gt;define&lt;/code&gt; 옵션을 사용하여 정의 된 모든 모델의 기본 옵션을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="f021a2b45ae6896b6bc054e8bd5ccd034b732703" translate="yes" xml:space="preserve">
          <source>The Sequelize constructor takes a whole slew of options that are documented in the &lt;a href=&quot;../class/lib/sequelize.js~sequelize#instance-constructor-constructor&quot;&gt;API Reference for the Sequelize constructor&lt;/a&gt;.</source>
          <target state="translated">Sequelize 생성자는 Sequelize 생성자에 대한 &lt;a href=&quot;../class/lib/sequelize.js~sequelize#instance-constructor-constructor&quot;&gt;API 참조 서에&lt;/a&gt; 설명 된 다양한 옵션을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="3cd19464fb2f97dfdb6295760a7d32b016b057fe" translate="yes" xml:space="preserve">
          <source>The Sequelize models are &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes&quot;&gt;ES6 classes&lt;/a&gt;. You can very easily add custom instance or class level methods.</source>
          <target state="translated">Sequelize 모델은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes&quot;&gt;ES6 클래스&lt;/a&gt; 입니다. 사용자 지정 인스턴스 또는 클래스 수준 메서드를 매우 쉽게 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de88c62cdccb50aa87d6fc7b0a9b3944d7a15030" translate="yes" xml:space="preserve">
          <source>The above associations achieve precisely what we want. Here is a full runnable example of this:</source>
          <target state="translated">위의 연관성은 우리가 원하는 것을 정확하게 달성합니다. 다음은 이에 대한 전체 실행 가능한 예입니다.</target>
        </trans-unit>
        <trans-unit id="c3f32fc062713c89992127673f0ff266e4a6d880" translate="yes" xml:space="preserve">
          <source>The above code tells Sequelize to expect a table named &lt;code&gt;users&lt;/code&gt; in the database with the fields &lt;code&gt;firstName&lt;/code&gt; and &lt;code&gt;lastName&lt;/code&gt;. The table name is automatically pluralized by default (a library called &lt;a href=&quot;https://www.npmjs.com/package/inflection&quot;&gt;inflection&lt;/a&gt; is used under the hood to do this). This behavior can be stopped for a specific model by using the &lt;code&gt;freezeTableName: true&lt;/code&gt; option, or for all models by using the &lt;code&gt;define&lt;/code&gt; option from the &lt;a href=&quot;../class/lib/sequelize.js~sequelize#instance-constructor-constructor&quot;&gt;Sequelize constructor&lt;/a&gt;.</source>
          <target state="translated">위의 코드는 Sequelize에게 &lt;code&gt;firstName&lt;/code&gt; 및 &lt;code&gt;lastName&lt;/code&gt; 필드를 가진 데이터베이스에서 &lt;code&gt;users&lt;/code&gt; 라는 테이블을 예상하도록 지시 합니다. 테이블 이름이 자동으로 (라이브러리라는 기본적으로 복수로되는 &lt;a href=&quot;https://www.npmjs.com/package/inflection&quot;&gt;변곡점이&lt;/a&gt; 이렇게 후드 사용된다). 이 동작은 &lt;code&gt;freezeTableName: true&lt;/code&gt; 옵션 을 사용하여 특정 모델 또는 &lt;a href=&quot;../class/lib/sequelize.js~sequelize#instance-constructor-constructor&quot;&gt;Sequelize 생성자&lt;/a&gt; 의 &lt;code&gt;define&lt;/code&gt; 옵션을 사용하여 모든 모델에 대해 중지 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="66144c7c85f62b61038b08c12717a6887b8a5bec" translate="yes" xml:space="preserve">
          <source>The above examples used the static &lt;code&gt;destroy&lt;/code&gt; method as an example (&lt;code&gt;Post.destroy&lt;/code&gt;), but everything works in the same way with the instance method:</source>
          <target state="translated">위의 예제에서는 정적 &lt;code&gt;destroy&lt;/code&gt; 메소드를 예로 사용 했지만 ( &lt;code&gt;Post.destroy&lt;/code&gt; ) 모든 것이 인스턴스 메소드와 동일한 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="491d61a801e9bf43e89739bcae20914a7039e71c" translate="yes" xml:space="preserve">
          <source>The above generates the following SQL:</source>
          <target state="translated">위는 다음 SQL을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="5241c39960fb4aa8c9233bc262e996b8edca18b1" translate="yes" xml:space="preserve">
          <source>The above gives the following output:</source>
          <target state="translated">위의 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1bab8dbae6d00df156ceecd25c8a08ae1103489e" translate="yes" xml:space="preserve">
          <source>The above has the exact same effect. Note that we didn't define any attributes on the &lt;code&gt;User_Profile&lt;/code&gt; model. The fact that we passed it into a &lt;code&gt;belongsToMany&lt;/code&gt; call tells sequelize to create the two attributes &lt;code&gt;userId&lt;/code&gt; and &lt;code&gt;profileId&lt;/code&gt; automatically, just like other associations also cause Sequelize to automatically add a column to one of the involved models.</source>
          <target state="translated">위의 효과는 똑같습니다. &lt;code&gt;User_Profile&lt;/code&gt; 모델 에 속성을 정의하지 않았습니다 . 우리는로를 통과한다는 사실 &lt;code&gt;belongsToMany&lt;/code&gt; 의 호출은 두 가지 속성을 만들 sequelize을 알려줍니다 &lt;code&gt;userId&lt;/code&gt; 를 하고 &lt;code&gt;profileId&lt;/code&gt; 자동으로 참여 모델 중 하나에 열을 추가하는 단지도 Sequelize 원인 다른 단체처럼 자동으로.</target>
        </trans-unit>
        <trans-unit id="230915fec95877c10dd9565fcce02d056836b906" translate="yes" xml:space="preserve">
          <source>The above observations show that we need a Many-to-Many relationship between Game and Team. Let's use the Super Many-to-Many relationship as explained earlier in this guide:</source>
          <target state="translated">위의 관찰은 게임과 팀간에 다 대다 관계가 필요함을 보여줍니다. 이 가이드의 앞부분에서 설명한대로 Super Many-to-Many 관계를 사용하겠습니다.</target>
        </trans-unit>
        <trans-unit id="20cbef37312bde5355305810f16034d671ac36e5" translate="yes" xml:space="preserve">
          <source>The above showed the basics on queries for fetching data involving associations. For creating, updating and deleting, you can either:</source>
          <target state="translated">위는 연관과 관련된 데이터를 가져 오는 쿼리에 대한 기본 사항을 보여줍니다. 생성, 업데이트 및 삭제를 위해 다음 중 하나를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07a60e1ad509b8e133343449d0ef91fe1e862254" translate="yes" xml:space="preserve">
          <source>The above will generate a MySQL query that looks like this:</source>
          <target state="translated">위의 내용은 다음과 같은 MySQL 쿼리를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="b9c17907c122357b86d0f15c4ae26538448ac3e0" translate="yes" xml:space="preserve">
          <source>The above will generate:</source>
          <target state="translated">위의 내용은 다음을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="e5c65a58203ca5029d990dcb3b90fff4d8a0da1c" translate="yes" xml:space="preserve">
          <source>The above will still create two columns &lt;code&gt;userId&lt;/code&gt; and &lt;code&gt;profileId&lt;/code&gt;, of course, but instead of setting up a composite unique key on them, the model will use its &lt;code&gt;id&lt;/code&gt; column as primary key. Everything else will still work just fine.</source>
          <target state="translated">물론 위의 경우 &lt;code&gt;userId&lt;/code&gt; 및 &lt;code&gt;profileId&lt;/code&gt; 열 두 개를 생성 하지만 여기에 복합 고유 키를 설정하는 대신 모델은 해당 &lt;code&gt;id&lt;/code&gt; 열을 기본 키로 사용합니다. 다른 모든 것은 여전히 ​​잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="066358f5002158d61207e8b61278a3bfd70f6107" translate="yes" xml:space="preserve">
          <source>The above yields the following SQL in PostgreSQL, which is equivalent to the one shown above:</source>
          <target state="translated">위의 결과는 위에 표시된 것과 동일한 PostgreSQL에서 다음 SQL을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="6c829098f3cbd87e53b1ee13196eb73a2253f975" translate="yes" xml:space="preserve">
          <source>The alias for the join model, in case you want to give it a different name than the default one.</source>
          <target state="translated">기본 이름과 다른 이름을 지정하려는 경우 조인 모델의 별칭입니다.</target>
        </trans-unit>
        <trans-unit id="8f72de844a359ac7b2754481a3ae1e21505a5382" translate="yes" xml:space="preserve">
          <source>The alias of the relation, in case the model you want to eagerly load is aliased. For &lt;code&gt;hasOne&lt;/code&gt; / &lt;code&gt;belongsTo&lt;/code&gt;, this should be the singular name, and for &lt;code&gt;hasMany&lt;/code&gt;, it should be the plural</source>
          <target state="translated">간절히로드하려는 모델의 별칭이 지정된 경우 관계의 별칭입니다. 들어 &lt;code&gt;hasOne&lt;/code&gt; 의 / &lt;code&gt;belongsTo&lt;/code&gt; 를 ,이 단수 이름이어야하고, 위해 &lt;code&gt;hasMany&lt;/code&gt; , 그것은 복수해야한다</target>
        </trans-unit>
        <trans-unit id="99efeea290301860aca947970c356a75d984412b" translate="yes" xml:space="preserve">
          <source>The alias of this association. If you provide a string, it should be plural, and will be singularized using node.inflection. If you want to control the singular version yourself, provide an object with &lt;code&gt;plural&lt;/code&gt; and &lt;code&gt;singular&lt;/code&gt; keys. See also the &lt;code&gt;name&lt;/code&gt; option passed to &lt;code&gt;sequelize.define&lt;/code&gt;. If you create multiple associations between the same tables, you should provide an alias to be able to distinguish between them. If you provide an alias when creating the association, you should provide the same alias when eager loading and when getting associated models. Defaults to the pluralized name of target</source>
          <target state="translated">이 연관의 별명. 문자열을 제공하면 복수 여야하며 node.inflection을 사용하여 단 수화됩니다. 단일 버전을 직접 제어하려면 객체에 &lt;code&gt;plural&lt;/code&gt; 및 &lt;code&gt;singular&lt;/code&gt; 키를 제공하십시오. &lt;code&gt;sequelize.define&lt;/code&gt; 에 전달 된 &lt;code&gt;name&lt;/code&gt; 옵션 도 참조하십시오 . 동일한 테이블간에 여러 개의 연관을 작성하는 경우이를 구별 할 수 있도록 별명을 제공해야합니다. 연관을 작성할 때 별명을 제공하는 경우,로드가 열리고 연관 모델을 가져올 때 동일한 별명을 제공해야합니다. 복수의 대상 이름이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="b8b5837eb09b93962a6de59344369c9b2dc0dea6" translate="yes" xml:space="preserve">
          <source>The alias of this model, in singular form. See also the &lt;code&gt;name&lt;/code&gt; option passed to &lt;code&gt;sequelize.define&lt;/code&gt;. If you create multiple associations between the same tables, you should provide an alias to be able to distinguish between them. If you provide an alias when creating the association, you should provide the same alias when eager loading and when getting associated models. Defaults to the singularized name of target</source>
          <target state="translated">이 모델의 별명은 단일 형식입니다. &lt;code&gt;sequelize.define&lt;/code&gt; 에 전달 된 &lt;code&gt;name&lt;/code&gt; 옵션 도 참조하십시오 . 동일한 테이블간에 여러 개의 연관을 작성하는 경우이를 구별 할 수 있도록 별명을 제공해야합니다. 연관을 작성할 때 별명을 제공하는 경우,로드가 열리고 연관 모델을 가져올 때 동일한 별명을 제공해야합니다. 단일 대상 이름으로 기본 설정</target>
        </trans-unit>
        <trans-unit id="6fcf9c630d31ebc1d75eae65eb6c73992888621e" translate="yes" xml:space="preserve">
          <source>The alias of this model. If you provide a string, it should be plural, and will be singularized using node.inflection. If you want to control the singular version yourself, provide an object with &lt;code&gt;plural&lt;/code&gt; and &lt;code&gt;singular&lt;/code&gt; keys. See also the &lt;code&gt;name&lt;/code&gt; option passed to &lt;code&gt;sequelize.define&lt;/code&gt;. If you create multiple associations between the same tables, you should provide an alias to be able to distinguish between them. If you provide an alias when creating the association, you should provide the same alias when eager loading and when getting associated models. Defaults to the pluralized name of target</source>
          <target state="translated">이 모델의 별명입니다. 문자열을 제공하면 문자열이 복수 여야하며 node.inflection을 사용하여 단일화됩니다. 단일 버전을 직접 제어하려면 객체에 &lt;code&gt;plural&lt;/code&gt; 및 &lt;code&gt;singular&lt;/code&gt; 키를 제공하십시오. &lt;code&gt;sequelize.define&lt;/code&gt; 에 전달 된 &lt;code&gt;name&lt;/code&gt; 옵션 도 참조하십시오 . 동일한 테이블간에 여러 개의 연관을 작성하는 경우이를 구별 할 수 있도록 별명을 제공해야합니다. 연관을 작성할 때 별명을 제공하는 경우,로드가 필요할 때와 연관된 모델을 가져올 때 동일한 별명을 제공해야합니다. 복수의 대상 이름이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="7d834cdb74aaf5b25711d3fd6901b52da5f8a978" translate="yes" xml:space="preserve">
          <source>The answer: by combining the &lt;code&gt;attributes&lt;/code&gt; option of the finder methods (such as &lt;code&gt;findAll&lt;/code&gt;) with the &lt;code&gt;sequelize.literal&lt;/code&gt; utility function, that allows you to directly insert arbitrary content into the query without any automatic escaping.</source>
          <target state="translated">답 : &lt;code&gt;findAll&lt;/code&gt; 같은 findAll 메소드 의 &lt;code&gt;attributes&lt;/code&gt; 옵션을 &lt;code&gt;sequelize.literal&lt;/code&gt; 유틸리티 함수 와 결합하면 자동 이스케이프없이 임의의 내용을 쿼리에 직접 삽입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6723f18b3bbf968c425605ca9dc759577bfe8738" translate="yes" xml:space="preserve">
          <source>The array or object must contain all bound values or Sequelize will throw an exception. This applies even to cases in which the database may ignore the bound parameter.</source>
          <target state="translated">배열이나 객체는 모든 바운드 값을 포함해야합니다. 그렇지 않으면 Sequelize에서 예외가 발생합니다. 이는 데이터베이스가 바운드 매개 변수를 무시할 수있는 경우에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="0ad94612989aa9f318b27d4d20664339044c9613" translate="yes" xml:space="preserve">
          <source>The association you want to eagerly load. (This can be used instead of providing a model/as pair)</source>
          <target state="translated">열심히로드하려는 연결입니다. (이것은 모델을 제공하는 대신 / 쌍으로 사용할 수 있습니다)</target>
        </trans-unit>
        <trans-unit id="eeb0e6deb9b0e80d8f8265fdbac4c078f3171b7b" translate="yes" xml:space="preserve">
          <source>The attr can either be an object taken from &lt;code&gt;Model.rawAttributes&lt;/code&gt; (for example &lt;code&gt;Model.rawAttributes.id&lt;/code&gt; or &lt;code&gt;Model.rawAttributes.name&lt;/code&gt;). The attribute should be defined in your model definition. The attribute can also be an object from one of the sequelize utility functions (&lt;code&gt;sequelize.fn&lt;/code&gt;, &lt;code&gt;sequelize.col&lt;/code&gt; etc.)</source>
          <target state="translated">attr은 &lt;code&gt;Model.rawAttributes&lt;/code&gt; 에서 가져온 객체 (예 : &lt;code&gt;Model.rawAttributes.id&lt;/code&gt; 또는 &lt;code&gt;Model.rawAttributes.name&lt;/code&gt; ) 일 수 있습니다. 속성은 모델 정의에서 정의해야합니다. 이 속성은 sequelize 유틸리티 함수 ( &lt;code&gt;sequelize.fn&lt;/code&gt; , &lt;code&gt;sequelize.col&lt;/code&gt; 등) 중 하나의 객체 일 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4f1a633ffadc1e2c2bc95e3c735fd1cf866d44c8" translate="yes" xml:space="preserve">
          <source>The attribute to aggregate over. Can be a field name or *</source>
          <target state="translated">집계 할 속성입니다. 필드 이름이거나 * 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22739ed01f959f4fdce30289f8b662f6f4a480e5" translate="yes" xml:space="preserve">
          <source>The attribute, which can be either an attribute object from &lt;code&gt;Model.rawAttributes&lt;/code&gt; or a sequelize object, for example an instance of &lt;code&gt;sequelize.fn&lt;/code&gt;. For simple string attributes, use the POJO syntax</source>
          <target state="translated">속성. &lt;code&gt;Model.rawAttributes&lt;/code&gt; 의 속성 객체 이거나 sequelize 객체 (예 : &lt;code&gt;sequelize.fn&lt;/code&gt; 인스턴스) 일 수 있습니다. 간단한 문자열 속성의 경우 POJO 구문을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="dd7a1e79deca9ce13b590c6b3440a4ec69eb8a2d" translate="yes" xml:space="preserve">
          <source>The basics</source>
          <target state="translated">기본</target>
        </trans-unit>
        <trans-unit id="4adcd69be228d56fcf3edec1f65fb88f2664ea6e" translate="yes" xml:space="preserve">
          <source>The best approach is to choose a name for the foreign key and place it explicitly in both calls. For example, if &lt;code&gt;subscription_id&lt;/code&gt; was chosen:</source>
          <target state="translated">가장 좋은 방법은 외래 키의 이름을 선택하고 두 호출 모두에 명시 적으로 배치하는 것입니다. 예를 들어 &lt;code&gt;subscription_id&lt;/code&gt; 를 선택한 경우 :</target>
        </trans-unit>
        <trans-unit id="31f5160d6229195e79e6c1274de390301eb1e065" translate="yes" xml:space="preserve">
          <source>The best of both worlds: the Super Many-to-Many relationship</source>
          <target state="translated">두 세계의 장점 : 슈퍼 다 대다 관계</target>
        </trans-unit>
        <trans-unit id="dba330eeb679cc93d816de1011efd40e4001bb62" translate="yes" xml:space="preserve">
          <source>The best way to prevent this kind of mistake is to &lt;strong&gt;avoid using the concrete accessors and mixins directly at all costs&lt;/strong&gt; (such as &lt;code&gt;.image&lt;/code&gt;, &lt;code&gt;.getVideo()&lt;/code&gt;, &lt;code&gt;.setImage()&lt;/code&gt;, etc), always preferring the abstractions we created, such as &lt;code&gt;.getCommentable()&lt;/code&gt; and &lt;code&gt;.commentable&lt;/code&gt;. If you really need to access eager-loaded &lt;code&gt;.image&lt;/code&gt; and &lt;code&gt;.video&lt;/code&gt; for some reason, make sure you wrap that in a type check such as &lt;code&gt;comment.commentableType === 'image'&lt;/code&gt;.</source>
          <target state="translated">이러한 종류의 실수를 방지하는 가장 좋은 방법 &lt;strong&gt;은 콘크리트 접근 자와 믹스 인을 모든 비용&lt;/strong&gt; (예 : &lt;code&gt;.image&lt;/code&gt; , &lt;code&gt;.getVideo()&lt;/code&gt; , &lt;code&gt;.setImage()&lt;/code&gt; 등)으로 직접 사용하지 않고 항상 다음과 같은 추상화를 선호하는 것입니다. &lt;code&gt;.getCommentable()&lt;/code&gt; 및 &lt;code&gt;.commentable&lt;/code&gt; . 어떤 이유로 든 eager-loaded &lt;code&gt;.image&lt;/code&gt; 및 &lt;code&gt;.video&lt;/code&gt; 에 액세스해야하는 경우 &lt;code&gt;comment.commentableType === 'image'&lt;/code&gt; 와 같은 유형 검사로 래핑해야합니다 .</target>
        </trans-unit>
        <trans-unit id="86f2cea5157fd9f20605ff55c5ddc6c804f123da" translate="yes" xml:space="preserve">
          <source>The blob datatype allows you to insert data both as strings and as buffers. However, when a blob is retrieved from database with Sequelize, it will always be retrieved as a buffer.</source>
          <target state="translated">Blob 데이터 유형을 사용하면 데이터를 문자열 및 버퍼로 삽입 할 수 있습니다. 그러나 Sequelize를 사용하여 데이터베이스에서 Blob을 검색하면 항상 버퍼로 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="bbcf08f5d0cc46af6869e99e66975da88a70ee1f" translate="yes" xml:space="preserve">
          <source>The callback has the form &lt;code&gt;(instances, options) =&amp;gt; /* ... */&lt;/code&gt;</source>
          <target state="translated">콜백의 형식은 &lt;code&gt;(instances, options) =&amp;gt; /* ... */&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5a2f78ef9d244f5109755aab0121644860970e34" translate="yes" xml:space="preserve">
          <source>The callback has the form &lt;code&gt;(options) =&amp;gt; /* ... */&lt;/code&gt;</source>
          <target state="translated">콜백의 형식은 &lt;code&gt;(options) =&amp;gt; /* ... */&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ebb52ea62604ee1252a133687d4b5c9f8e537d70" translate="yes" xml:space="preserve">
          <source>The callback has the form &lt;code&gt;async (config) =&amp;gt; /* ... */&lt;/code&gt;</source>
          <target state="translated">콜백의 형식은 &lt;code&gt;async (config) =&amp;gt; /* ... */&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="297ce94611fe852888df217e0c81704490bc70fa" translate="yes" xml:space="preserve">
          <source>The callback has the form &lt;code&gt;async (connection) =&amp;gt; /* ... */&lt;/code&gt;</source>
          <target state="translated">콜백의 형식은 &lt;code&gt;async (connection) =&amp;gt; /* ... */&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d964b0cee1924f1672ba378cf96bbc042498c259" translate="yes" xml:space="preserve">
          <source>The callback has the form &lt;code&gt;async (connection, config) =&amp;gt; /* ... */&lt;/code&gt;</source>
          <target state="translated">콜백의 형식은 &lt;code&gt;async (connection, config) =&amp;gt; /* ... */&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2729266f67f2a23ec11b7b4334746cfee6eef44b" translate="yes" xml:space="preserve">
          <source>The callback is called with the transaction object, and should return a promise. If the promise is resolved, the transaction commits; if the promise rejects, the transaction rolls back</source>
          <target state="translated">콜백은 트랜잭션 객체와 함께 호출되며 약속을 반환해야합니다. 약속이 해결되면 트랜잭션이 커밋됩니다. 약속이 거부되면 트랜잭션이 롤백됩니다.</target>
        </trans-unit>
        <trans-unit id="6e275f53b4e5073eab6f6e00991b66b9a04b41e8" translate="yes" xml:space="preserve">
          <source>The callback passed to &lt;code&gt;afterCommit&lt;/code&gt; can be &lt;code&gt;async&lt;/code&gt;. In this case:</source>
          <target state="translated">&lt;code&gt;afterCommit&lt;/code&gt; 에 전달 된 콜백은 &lt;code&gt;async&lt;/code&gt; 일 수 있습니다 . 이 경우 :</target>
        </trans-unit>
        <trans-unit id="89f67ef86d7f079615ec0e89c9fb9283c0562afc" translate="yes" xml:space="preserve">
          <source>The character(s) that separates the schema name from the table name</source>
          <target state="translated">스키마 이름과 테이블 이름을 구분하는 문자</target>
        </trans-unit>
        <trans-unit id="7bffb68a98cf41f92a6a5b6847d45ca564723683" translate="yes" xml:space="preserve">
          <source>The cidr type holds an IPv4 or IPv6 network specification. Takes 7 or 19 bytes.</source>
          <target state="translated">cidr 유형에는 IPv4 또는 IPv6 네트워크 사양이 있습니다. 7 또는 19 바이트를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="08288fcdafa5090ff642d3378e7c64c514abd839" translate="yes" xml:space="preserve">
          <source>The code created a new instance. So when we already have an instance ...</source>
          <target state="translated">코드는 새로운 인스턴스를 만들었습니다. 따라서 이미 인스턴스가 있으면 ...</target>
        </trans-unit>
        <trans-unit id="86c3eb751548d29886ece41261fcf102e99bb6c1" translate="yes" xml:space="preserve">
          <source>The column of the foreign table that this column references</source>
          <target state="translated">이 열이 참조하는 외부 테이블의 열</target>
        </trans-unit>
        <trans-unit id="086f5b689f580197262a5b2e07b9612e1b03fe5b" translate="yes" xml:space="preserve">
          <source>The comment option can also be used on a table, see &lt;a href=&quot;models-definition#configuration&quot;&gt;model configuration&lt;/a&gt;.</source>
          <target state="translated">주석 옵션은 테이블에서도 사용할 수 있습니다 ( &lt;a href=&quot;models-definition#configuration&quot;&gt;모델 구성&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="d27aabc8275530f07158af4ff3a280a6294be2a6" translate="yes" xml:space="preserve">
          <source>The comment will be set when calling &lt;code&gt;sync()&lt;/code&gt;.</source>
          <target state="translated">주석은 &lt;code&gt;sync()&lt;/code&gt; 호출 할 때 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="0eb1bab57a621daf9b2bb926b56b6310ae016f5f" translate="yes" xml:space="preserve">
          <source>The concepts of Eager Loading and Lazy Loading are fundamental to understand how fetching associations work in Sequelize. Lazy Loading refers to the technique of fetching the associated data only when you really want it; Eager Loading, on the other hand, refers to the technique of fetching everything at once, since the beginning, with a larger query.</source>
          <target state="translated">Eager Loading 및 Lazy Loading의 개념은 Sequelize에서 가져 오기 연결이 작동하는 방식을 이해하는 데 기본이됩니다. 지연로드는 실제로 원하는 경우에만 관련 데이터를 가져 오는 기술을 의미합니다. 반면 Eager Loading은 처음부터 더 큰 쿼리로 모든 것을 한 번에 가져 오는 기술을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="307ca9cde38886869f5fa3f4a7f13e21882c3f36" translate="yes" xml:space="preserve">
          <source>The condition. Can be both a simply type, or a further condition (&lt;code&gt;or&lt;/code&gt;, &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;.literal&lt;/code&gt; etc.)</source>
          <target state="translated">조건. 단순 유형이거나 추가 조건 ( &lt;code&gt;or&lt;/code&gt; , &lt;code&gt;and&lt;/code&gt; . &lt;code&gt;.literal&lt;/code&gt; 등) 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="643e263b3792d2735799bf65236300d2e8f0f34d" translate="yes" xml:space="preserve">
          <source>The configuration file is by default a JSON file called &lt;code&gt;config.json&lt;/code&gt;. But sometimes you need a dynamic configuration, for example to access environment variables or execute some other code to determine the configuration.</source>
          <target state="translated">구성 파일은 기본적으로 &lt;code&gt;config.json&lt;/code&gt; 이라는 JSON 파일 입니다. 그러나 때로는 환경 변수에 액세스하거나 구성을 결정하기 위해 다른 코드를 실행하기 위해 동적 구성이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="b12da706808f947908ea3c7e4a43a6c6df973b54" translate="yes" xml:space="preserve">
          <source>The connection specific error which triggered this one</source>
          <target state="translated">이 오류를 발생시킨 연결 특정 오류</target>
        </trans-unit>
        <trans-unit id="f11daf184810825d2e034f106bcdd1a52e3ca438" translate="yes" xml:space="preserve">
          <source>The constraints can be configured in a transaction like this. It will trigger a query once the transaction has been started and set the constraints to be checked at the very end of the transaction.</source>
          <target state="translated">이와 같은 트랜잭션에서 제약 조건을 구성 할 수 있습니다. 트랜잭션이 시작되면 쿼리를 트리거하고 트랜잭션이 끝날 때 제약 조건을 확인하도록 설정합니다.</target>
        </trans-unit>
        <trans-unit id="9712140b363a1de7e3ef7011ed4d015c64de986b" translate="yes" xml:space="preserve">
          <source>The content of &lt;code&gt;raw&lt;/code&gt; will be added verbatim without quoting</source>
          <target state="translated">&lt;code&gt;raw&lt;/code&gt; 의 내용은 인용없이 그대로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="a535f48c9c40323cf1d64fd09ba69dc4ba240a70" translate="yes" xml:space="preserve">
          <source>The contents of this page were moved to &lt;a href=&quot;model-basics&quot;&gt;Model Basics&lt;/a&gt;.</source>
          <target state="translated">이 페이지의 내용은 &lt;a href=&quot;model-basics&quot;&gt;Model Basics&lt;/a&gt; 로 이동되었습니다 .</target>
        </trans-unit>
        <trans-unit id="068013d2018417b76589f569a09297640de057b8" translate="yes" xml:space="preserve">
          <source>The contents of this page were moved to other specialized guides.</source>
          <target state="translated">이 페이지의 내용은 다른 전문 가이드로 이동되었습니다.</target>
        </trans-unit>
        <trans-unit id="7f82e34423c4aa983880f84a931ac15a57ef5e9c" translate="yes" xml:space="preserve">
          <source>The created target model</source>
          <target state="translated">생성 된 대상 모델</target>
        </trans-unit>
        <trans-unit id="8365a8cc325cbcee0b79e12d5dd24da474986bd1" translate="yes" xml:space="preserve">
          <source>The custom name for unique constraint.</source>
          <target state="translated">고유 제한 조건의 사용자 정의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="26d8528d64198217cd0a2792bd30ba499b76275f" translate="yes" xml:space="preserve">
          <source>The database may add further restrictions to this. Bind parameters cannot be SQL keywords, nor table or column names. They are also ignored in quoted text or data. In PostgreSQL it may also be needed to typecast them, if the type cannot be inferred from the context &lt;code&gt;$1::varchar&lt;/code&gt;.</source>
          <target state="translated">데이터베이스에 이에 대한 추가 제한 사항이 추가 될 수 있습니다. 바인드 매개 변수는 SQL 키워드 나 테이블 또는 열 이름이 될 수 없습니다. 인용 된 텍스트 나 데이터에서도 무시됩니다. PostgreSQL에서는 &lt;code&gt;$1::varchar&lt;/code&gt; 컨텍스트에서 형식을 유추 할 수없는 경우 형식을 변환해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="133c42933eb9f6bdcc738e29e1ecb28fe8f85820" translate="yes" xml:space="preserve">
          <source>The database name.</source>
          <target state="translated">데이터베이스 이름</target>
        </trans-unit>
        <trans-unit id="c7b14aedd0c4e517f0bbd0dc1afb0301b4627da0" translate="yes" xml:space="preserve">
          <source>The default casing is &lt;code&gt;camelCase&lt;/code&gt;. If the source model is configured with &lt;code&gt;underscored: true&lt;/code&gt; the foreignKey will be created with field &lt;code&gt;snake_case&lt;/code&gt;.</source>
          <target state="translated">기본 케이스는 &lt;code&gt;camelCase&lt;/code&gt; 입니다. 소스 모델이 &lt;code&gt;underscored: true&lt;/code&gt; 로 구성된 경우 : true foreignKey는 필드 &lt;code&gt;snake_case&lt;/code&gt; 로 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="6dc21b0b4d12b76a5818f880b5f80b8a22b8c421" translate="yes" xml:space="preserve">
          <source>The default engine for a model is InnoDB.</source>
          <target state="translated">모델의 기본 엔진은 InnoDB입니다.</target>
        </trans-unit>
        <trans-unit id="ab6a1cee9dd55a28134e5eb727ede271bd531534" translate="yes" xml:space="preserve">
          <source>The default scope can be removed by calling &lt;code&gt;.unscoped()&lt;/code&gt;, &lt;code&gt;.scope(null)&lt;/code&gt;, or by invoking another scope:</source>
          <target state="translated">&lt;code&gt;.unscoped()&lt;/code&gt; , &lt;code&gt;.scope(null)&lt;/code&gt; 을 호출하거나 다른 범위를 호출 하여 기본 범위를 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b7386af5698cd007ddf66e78123acc72fab2f4ea" translate="yes" xml:space="preserve">
          <source>The default scope is always applied. This means, that with the model definition above, &lt;code&gt;Project.findAll()&lt;/code&gt; will create the following query:</source>
          <target state="translated">기본 범위는 항상 적용됩니다. 즉, 위의 모델 정의를 사용하면 &lt;code&gt;Project.findAll()&lt;/code&gt; 이 다음 쿼리를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="fa546f166503aba9bbfa12ca4aef7d527586612c" translate="yes" xml:space="preserve">
          <source>The defaults for the One-To-One associations is &lt;code&gt;SET NULL&lt;/code&gt; for &lt;code&gt;ON DELETE&lt;/code&gt; and &lt;code&gt;CASCADE&lt;/code&gt; for &lt;code&gt;ON UPDATE&lt;/code&gt;.</source>
          <target state="translated">일대일 협회의 기본값은 &lt;code&gt;SET NULL&lt;/code&gt; 을 위한 &lt;code&gt;ON DELETE&lt;/code&gt; 및 &lt;code&gt;CASCADE&lt;/code&gt; 에 대한 &lt;code&gt;ON UPDATE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="665cbb172b6490eaddc986b85ff39499207a5181" translate="yes" xml:space="preserve">
          <source>The description of a database column</source>
          <target state="translated">데이터베이스 열에 대한 설명</target>
        </trans-unit>
        <trans-unit id="17c2a1a15703200447e4e3ae9246feb0762fdebb" translate="yes" xml:space="preserve">
          <source>The diagram below shows the firing order for the most common hooks.</source>
          <target state="translated">아래 다이어그램은 가장 일반적인 후크의 실행 순서를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="d84e52eb436e545fc5c78ff373642e0e5f89fc49" translate="yes" xml:space="preserve">
          <source>The dialect of the database you are connecting to. One of mysql, postgres, sqlite and mssql.</source>
          <target state="translated">연결중인 데이터베이스의 방언 mysql, postgres, sqlite 및 mssql 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="87de8d90db190f90a33e2aa732fb6ceb202799ae" translate="yes" xml:space="preserve">
          <source>The exact same idea can be applied to the &lt;code&gt;hasOne&lt;/code&gt; and &lt;code&gt;hasMany&lt;/code&gt; associations, but instead of providing a &lt;code&gt;targetKey&lt;/code&gt;, we provide a &lt;code&gt;sourceKey&lt;/code&gt; when defining the association. This is because unlike &lt;code&gt;belongsTo&lt;/code&gt;, the &lt;code&gt;hasOne&lt;/code&gt; and &lt;code&gt;hasMany&lt;/code&gt; associations keep the foreign key on the target model:</source>
          <target state="translated">동일한 아이디어는 적용 할 수 &lt;code&gt;hasOne&lt;/code&gt; 의 및 &lt;code&gt;hasMany&lt;/code&gt; 협회,하지만 대신 제공의 &lt;code&gt;targetKey&lt;/code&gt; 을 , 우리는 제공 &lt;code&gt;sourceKey&lt;/code&gt; 를 연결을 정의 할 때. 달리 때문이다 &lt;code&gt;belongsTo&lt;/code&gt; 를 의 &lt;code&gt;hasOne&lt;/code&gt; 의 및 &lt;code&gt;hasMany&lt;/code&gt; 협회는 대상 모델에 외부 키를 계속 :</target>
        </trans-unit>
        <trans-unit id="def4b818effdcbcbb341517b995603bb7fd1cfea" translate="yes" xml:space="preserve">
          <source>The example above also shows how to add custom dialect options to the configuration.</source>
          <target state="translated">위의 예는 구성에 사용자 지정 언어 옵션을 추가하는 방법도 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="45e7bc7d9f271032666c02c31e6e45fd4b760911" translate="yes" xml:space="preserve">
          <source>The example above will create a model named &lt;code&gt;User&lt;/code&gt; pointing to a table also named &lt;code&gt;User&lt;/code&gt;.</source>
          <target state="translated">위의 예는 모델 이름을 만듭니다 &lt;code&gt;User&lt;/code&gt; 테이블도 이름을 가리키는 &lt;code&gt;User&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88d26fe16e5692696255a5355d0f4f8be2e688ab" translate="yes" xml:space="preserve">
          <source>The field that triggered the validation error</source>
          <target state="translated">유효성 검사 오류를 일으킨 필드</target>
        </trans-unit>
        <trans-unit id="dc12ac79eaf881af2a210995e506e55117bb8e15" translate="yes" xml:space="preserve">
          <source>The fields to insert / update. Defaults to all changed fields</source>
          <target state="translated">삽입 / 업데이트 할 필드입니다. 변경된 모든 필드의 기본값</target>
        </trans-unit>
        <trans-unit id="5fc388d14402454846435b4ba16379dcaf2da697" translate="yes" xml:space="preserve">
          <source>The first call above will establish a foreign key called &lt;code&gt;theSubscriptionId&lt;/code&gt; on &lt;code&gt;Invoice&lt;/code&gt;. However, the second call will also establish a foreign key on &lt;code&gt;Invoice&lt;/code&gt; (since as we know, &lt;code&gt;hasMany&lt;/code&gt; calls places foreign keys in the target model) - however, it will be named &lt;code&gt;subscriptionId&lt;/code&gt;. This way you will have both &lt;code&gt;subscriptionId&lt;/code&gt; and &lt;code&gt;theSubscriptionId&lt;/code&gt; columns.</source>
          <target state="translated">위의 첫 번째 호출 은 &lt;code&gt;Invoice&lt;/code&gt; 에 &lt;code&gt;theSubscriptionId&lt;/code&gt; 라는 외래 키를 설정합니다 . 그러나 두 번째 호출은 &lt;code&gt;Invoice&lt;/code&gt; 에 대한 외래 키도 설정합니다 (우리가 알고 있듯이 &lt;code&gt;hasMany&lt;/code&gt; 호출은 대상 모델에 외래 키를 배치하므로). 그러나 이름은 &lt;code&gt;subscriptionId&lt;/code&gt; 입니다. 이렇게하면 &lt;code&gt;subscriptionId&lt;/code&gt; 및 &lt;code&gt;theSubscriptionId&lt;/code&gt; 열을 모두 갖게됩니다 .</target>
        </trans-unit>
        <trans-unit id="4a271d313ec9a5b0ba22651482b2acecb8f30ecb" translate="yes" xml:space="preserve">
          <source>The following SQL calls are generated for SQLite:</source>
          <target state="translated">SQLite에 대해 다음 SQL 호출이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="42906407901dc98dd47ff0bf1ad488ab7ff5f96b" translate="yes" xml:space="preserve">
          <source>The following example will be successful:</source>
          <target state="translated">다음 예는 성공할 것입니다.</target>
        </trans-unit>
        <trans-unit id="ecae6536ba5f664ceb5f19fb50106224ec6ccb71" translate="yes" xml:space="preserve">
          <source>The following example will throw an error:</source>
          <target state="translated">다음 예에서는 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="82b4a90983df6d340d9ebb2913376b001f99f3b5" translate="yes" xml:space="preserve">
          <source>The following example would return successful:</source>
          <target state="translated">다음 예제는 성공을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="280f1e7b08f7b7110bec1c76d91b0af4a17b5d16" translate="yes" xml:space="preserve">
          <source>The following hooks will emit whenever you're editing a single object</source>
          <target state="translated">단일 객체를 편집 할 때마다 다음 후크가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="68688b6de6f445e1cbb2bc8cd5e5582e2cceb88c" translate="yes" xml:space="preserve">
          <source>The following hooks will emit whenever you're editing a single object:</source>
          <target state="translated">단일 객체를 편집 할 때마다 다음 후크가 방출됩니다.</target>
        </trans-unit>
        <trans-unit id="0e6a1b0b86882a21b759b1ffd75f905d1a7598a6" translate="yes" xml:space="preserve">
          <source>The following is an example of a migration that performs two changes in the database, using a transaction to ensure that all instructions are successfully executed or rolled back in case of failure:</source>
          <target state="translated">다음은 트랜잭션을 사용하여 데이터베이스에서 두 가지 변경을 수행하여 실패시 모든 명령이 성공적으로 실행 또는 롤백되도록하는 마이그레이션의 예입니다.</target>
        </trans-unit>
        <trans-unit id="961c21dce82c2533bd652bce645a89a35fb0a4ec" translate="yes" xml:space="preserve">
          <source>The following is an example of a migration that performs two changes in the database, using an automatically-managed transaction to ensure that all instructions are successfully executed or rolled back in case of failure:</source>
          <target state="translated">다음은 자동으로 관리되는 트랜잭션을 사용하여 데이터베이스에서 두 가지 변경을 수행하여 모든 명령이 성공적으로 실행되거나 실패시 롤백되도록하는 마이그레이션의 예입니다.</target>
        </trans-unit>
        <trans-unit id="3dc82f0763e4ab04ff35cac14d85b168f30e6b9f" translate="yes" xml:space="preserve">
          <source>The following skeleton shows a typical migration file.</source>
          <target state="translated">다음 스켈레톤은 일반적인 마이그레이션 파일을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="e06d3e32690783120e9be16c51d4ae5794b0ed5d" translate="yes" xml:space="preserve">
          <source>The following will happen in this case:</source>
          <target state="translated">이 경우 다음이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a10c7d3ee357a66ed02d0cefd56151488e7581d5" translate="yes" xml:space="preserve">
          <source>The foreign key column in Picture will now be called &lt;code&gt;uid&lt;/code&gt; instead of the default &lt;code&gt;userId&lt;/code&gt;.</source>
          <target state="translated">Picture의 외래 키 열은 이제 기본 &lt;code&gt;userId&lt;/code&gt; 대신 &lt;code&gt;uid&lt;/code&gt; 라고 합니다.</target>
        </trans-unit>
        <trans-unit id="12c1febc044151ecd5369dd75f35ba59d7d87ddf" translate="yes" xml:space="preserve">
          <source>The foreign key name can be provided directly with an option in the association definition, as follows:</source>
          <target state="translated">외래 키 이름은 다음과 같이 연관 정의의 옵션과 함께 직접 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="529cad56c0cb70caba210ae4d8aa6458b6284149" translate="yes" xml:space="preserve">
          <source>The foreign keys can be configured like this. It will create a foreign key that will check the constraints immediately when the data was inserted.</source>
          <target state="translated">외래 키는 이와 같이 구성 할 수 있습니다. 데이터가 삽입되면 즉시 제약 조건을 검사하는 외래 키를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="2370aaaf0d68986c57d44c76392fb05980d573b2" translate="yes" xml:space="preserve">
          <source>The four association types are defined in a very similar way. Let's say we have two models, &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;. Telling Sequelize that you want an association between the two needs just a function call:</source>
          <target state="translated">네 가지 연관 유형은 매우 유사한 방식으로 정의됩니다. 두 개의 모델, &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 가 있다고 가정 해 봅시다 . Sequelize에게 둘 사이의 연관성을 원한다고 말하면 함수 호출이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="793f0633fe67cfcf9f0c69748cf2894da9604c8b" translate="yes" xml:space="preserve">
          <source>The function passed to &lt;code&gt;afterCommit&lt;/code&gt; can optionally return a promise that will resolve before the promise chain that created the transaction resolves</source>
          <target state="translated">&lt;code&gt;afterCommit&lt;/code&gt; 에 전달 된 함수 는 트랜잭션을 작성한 약속 체인이 해결되기 전에 해결할 약속을 선택적으로 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="391fd95e64f40aa9733294c80cb361252d715dc2" translate="yes" xml:space="preserve">
          <source>The function to use for aggregation, e.g. sum, max etc.</source>
          <target state="translated">집계에 사용할 함수 (예 : sum, max 등)</target>
        </trans-unit>
        <trans-unit id="000d55600122d86f1eba23f47b3d17f67612ff60" translate="yes" xml:space="preserve">
          <source>The function you want to call</source>
          <target state="translated">호출하려는 기능</target>
        </trans-unit>
        <trans-unit id="e135b99727511ce9aceb25615effb6ba854b79d1" translate="yes" xml:space="preserve">
          <source>The getter method accepts options just like the usual finder methods (such as &lt;code&gt;findAll&lt;/code&gt;):</source>
          <target state="translated">getter 메소드는 일반적인 finder 메소드 (예 : &lt;code&gt;findAll&lt;/code&gt; ) 와 같은 옵션을 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="7d2fd892b7e49a84a79c772b9c3ab82a75c144d3" translate="yes" xml:space="preserve">
          <source>The guide will start explaining how to define these four types of associations, and then will follow up to explain how to combine those to define the three standard association types (&lt;a href=&quot;https://en.wikipedia.org/wiki/One-to-one_%28data_model%29&quot;&gt;One-To-One&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/One-to-many_%28data_model%29&quot;&gt;One-To-Many&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/Many-to-many_%28data_model%29&quot;&gt;Many-To-Many&lt;/a&gt;).</source>
          <target state="translated">가이드는 이러한 4 가지 유형의 연결을 정의하는 방법을 설명하기 시작한 다음 이들을 결합하여 세 가지 표준 연결 유형 ( &lt;a href=&quot;https://en.wikipedia.org/wiki/One-to-one_%28data_model%29&quot;&gt;일대일&lt;/a&gt; , &lt;a href=&quot;https://en.wikipedia.org/wiki/One-to-many_%28data_model%29&quot;&gt;일대 다&lt;/a&gt; 및 다 &lt;a href=&quot;https://en.wikipedia.org/wiki/Many-to-many_%28data_model%29&quot;&gt;대다)&lt;/a&gt; 을 정의하는 방법을 설명합니다. ).</target>
        </trans-unit>
        <trans-unit id="90c3ebe86ec649ba3e67ec8bd89813b5825ec277" translate="yes" xml:space="preserve">
          <source>The host of the relational database.</source>
          <target state="translated">관계형 데이터베이스의 호스트.</target>
        </trans-unit>
        <trans-unit id="078148a6e892df7a20d488625d335ca2bfefddd8" translate="yes" xml:space="preserve">
          <source>The interface that Sequelize uses to talk to all databases</source>
          <target state="translated">Sequelize가 모든 데이터베이스와 통신하는 데 사용하는 인터페이스</target>
        </trans-unit>
        <trans-unit id="5d457db1431b80cf8915e31a4d70b3c3781a9c09" translate="yes" xml:space="preserve">
          <source>The interface that Sequelize uses to talk with MSSQL database</source>
          <target state="translated">Sequelize가 MSSQL 데이터베이스와 통신하는 데 사용하는 인터페이스</target>
        </trans-unit>
        <trans-unit id="6477afe06c10a818bc7d40c0f9584506b6d2b739" translate="yes" xml:space="preserve">
          <source>The interface that Sequelize uses to talk with MySQL/MariaDB database</source>
          <target state="translated">Sequelize가 MySQL / MariaDB 데이터베이스와 통신하는 데 사용하는 인터페이스</target>
        </trans-unit>
        <trans-unit id="ba12af77ac6f34eb6defcfeb5e5c54a843afa932" translate="yes" xml:space="preserve">
          <source>The interface that Sequelize uses to talk with Postgres database</source>
          <target state="translated">Sequelize가 Postgres 데이터베이스와 통신하는 데 사용하는 인터페이스</target>
        </trans-unit>
        <trans-unit id="5d8d9082ce7b5c3556c55a2a7e4170e63563d3a4" translate="yes" xml:space="preserve">
          <source>The interface that Sequelize uses to talk with SQLite database</source>
          <target state="translated">Sequelize가 SQLite 데이터베이스와 통신하는 데 사용하는 인터페이스</target>
        </trans-unit>
        <trans-unit id="0b73ca2f73dbf5fbdcb5f9c41700b408a0e80f3d" translate="yes" xml:space="preserve">
          <source>The key difference is that the managed transaction uses a callback that expects a promise to be returned to it while the unmanaged transaction returns a promise.</source>
          <target state="translated">주요 차이점은 관리 트랜잭션은 약속이 반환 될 것으로 예상되는 콜백을 사용하고 관리되지 않는 트랜잭션은 약속을 반환한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="78ad99f68c3f49de5dac894a3e535c3b22d08e81" translate="yes" xml:space="preserve">
          <source>The last option is the default in PostgreSQL and won't allow you to dynamically change the rule in a transaction. See &lt;a href=&quot;transactions#options&quot;&gt;the transaction section&lt;/a&gt; for further information.</source>
          <target state="translated">마지막 옵션은 PostgreSQL의 기본값이며 트랜잭션에서 규칙을 동적으로 변경할 수 없습니다. 자세한 내용 &lt;a href=&quot;transactions#options&quot;&gt;은 거래 섹션&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ec4984d2ddd30205a2e231be149e2871ddd539b9" translate="yes" xml:space="preserve">
          <source>The library for MSSQL is&lt;code&gt;tedious@^6.0.0&lt;/code&gt; You'll just need to define the dialect. Please note: &lt;code&gt;tedious@^6.0.0&lt;/code&gt; requires you to nest MSSQL specific options inside an additional &lt;code&gt;options&lt;/code&gt;-object inside the &lt;code&gt;dialectOptions&lt;/code&gt;-object.</source>
          <target state="translated">MSSQL의 라이브러리는 &lt;code&gt;tedious@^6.0.0&lt;/code&gt; 입니다. 방언을 정의하기 만하면됩니다. : 참고 &lt;code&gt;tedious@^6.0.0&lt;/code&gt; 은 추가 내부에 둥지 MSSQL의 특정 옵션에 당신을 필요로 &lt;code&gt;options&lt;/code&gt; 내부 -object &lt;code&gt;dialectOptions&lt;/code&gt; 가 -object.</target>
        </trans-unit>
        <trans-unit id="934a2eaf992cdd06d2aba7f0aa18a842e979db5f" translate="yes" xml:space="preserve">
          <source>The main setup to achieve the goal is as follows:</source>
          <target state="translated">목표를 달성하기위한 주요 설정은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a5443066bbb733918f3134982fc13f4d1c65e30b" translate="yes" xml:space="preserve">
          <source>The main way to do this in Sequelize is as follows:</source>
          <target state="translated">Sequelize에서이를 수행하는 주요 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c0db38bc9640103964b079b1e11325895649ec10" translate="yes" xml:space="preserve">
          <source>The main way to do this is as follows:</source>
          <target state="translated">이를 수행하는 주요 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1658788de2d8228e11cec2bccf15ee08bd03c17f" translate="yes" xml:space="preserve">
          <source>The maximum time, in milliseconds, that a connection can be idle before being released.</source>
          <target state="translated">연결이 해제되기 전에 유휴 상태가 될 수있는 최대 시간 (밀리 초)입니다.</target>
        </trans-unit>
        <trans-unit id="ba55d264e60dd5d5b5ddf45b2ce564066fb762a9" translate="yes" xml:space="preserve">
          <source>The maximum time, in milliseconds, that pool will try to get connection before throwing error</source>
          <target state="translated">해당 풀이 오류를 발생시키기 전에 연결을 시도하는 최대 시간 (밀리 초)</target>
        </trans-unit>
        <trans-unit id="5ee71bd71da0b1e5f70afac2c78ad97814aea849" translate="yes" xml:space="preserve">
          <source>The merge illustrated above works in the exact same way regardless of the order applied to the scopes. The order would only make a difference if a certain option was set by two different scopes - which is not the case of the above example, since each scope does a different thing.</source>
          <target state="translated">위에 설명 된 병합은 범위에 적용되는 순서에 관계없이 동일한 방식으로 작동합니다. 특정 옵션이 두 개의 다른 범위로 설정된 경우에만 순서가 달라집니다. 각 범위가 다른 일을하기 때문에 위의 예에서는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="768b334f10219b8ad448c59e67cb8742c9f47374" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;findOrCreate&lt;/code&gt; can be used to check if a certain element already exists in the database. If that is the case the method will result in a respective instance. If the element does not yet exist, it will be created.</source>
          <target state="translated">&lt;code&gt;findOrCreate&lt;/code&gt; 메소드를 사용하여 데이터베이스에 특정 요소가 이미 존재하는지 확인할 수 있습니다. 이 경우이 방법으로 각 인스턴스가 생성됩니다. 요소가 아직 없으면 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="485c8fc2f8c2529175828e883bb2acaaa0d0d349" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;findOrCreate&lt;/code&gt; will create an entry in the table unless it can find one fulfilling the query options. In both cases, it will return an instance (either the found instance or the created instance) and a boolean indicating whether that instance was created or already existed.</source>
          <target state="translated">&lt;code&gt;findOrCreate&lt;/code&gt; 메소드 는 쿼리 옵션을 충족하는 항목을 찾을 수없는 경우 테이블에 항목을 생성합니다. 두 경우 모두 인스턴스 (발견 된 인스턴스 또는 생성 된 인스턴스)와 해당 인스턴스가 생성되었는지 또는 이미 존재 하는지를 나타내는 부울을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="190f856cccd7855db0bd246036cd7f550762c4f2" translate="yes" xml:space="preserve">
          <source>The method call is essentially the same. The only difference is that now the extra field created in the query result uses the pluralized form (&lt;code&gt;tasks&lt;/code&gt; in this case), and its value is an array of task instances (instead of a single instance, as above).</source>
          <target state="translated">메서드 호출은 본질적으로 동일합니다. 유일한 차이점은 이제 쿼리 결과에서 생성 된 추가 필드가 복수 형식 ( 이 경우 &lt;code&gt;tasks&lt;/code&gt; )을 사용하고 해당 값이 작업 인스턴스의 배열 (위와 같이 단일 인스턴스 대신)이라는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3d86660c6baef8b679849a118c8e3209fbf8ab29" translate="yes" xml:space="preserve">
          <source>The method to create the index by (&lt;code&gt;USING&lt;/code&gt; statement in SQL). BTREE and HASH are supported by mysql and postgres, and postgres additionally supports GIST and GIN.</source>
          <target state="translated">( SQL의 &lt;code&gt;USING&lt;/code&gt; 문)으로 색인을 작성하는 방법 . BTREE 및 HASH는 mysql 및 postgres에서 지원되며 postgres는 GIST 및 GIN을 추가로 지원합니다.</target>
        </trans-unit>
        <trans-unit id="cd094238935bf66b383e816c14b414030b2e0138" translate="yes" xml:space="preserve">
          <source>The methods from the query interface are therefore lower-level methods; you should use them only if you do not find another way to do it with higher-level APIs from Sequelize. They are, of course, still higher-level than running raw queries directly (i.e., writing SQL by hand).</source>
          <target state="translated">따라서 쿼리 인터페이스의 메서드는 하위 수준 메서드입니다. Sequelize의 상위 수준 API로 수행 할 다른 방법을 찾지 못한 경우에만 사용해야합니다. 물론 그들은 원시 쿼리를 직접 실행하는 것 (즉, 손으로 SQL을 작성하는 것)보다 여전히 더 높은 수준입니다.</target>
        </trans-unit>
        <trans-unit id="c0edf99980de39ddde23bcf3f3a1f4f049bd3508" translate="yes" xml:space="preserve">
          <source>The mixins added to the user instances will use the correct forms. For example, instead of &lt;code&gt;project.addUser()&lt;/code&gt;, Sequelize will provide &lt;code&gt;project.getL&amp;iacute;der()&lt;/code&gt;. Also, instead of &lt;code&gt;project.setUsers()&lt;/code&gt;, Sequelize will provide &lt;code&gt;project.setL&amp;iacute;deres()&lt;/code&gt;.</source>
          <target state="translated">사용자 인스턴스에 추가 된 믹스 인은 올바른 형식을 사용합니다. 예를 들어, &lt;code&gt;project.addUser()&lt;/code&gt; 대신 Sequelize는 &lt;code&gt;project.getL&amp;iacute;der()&lt;/code&gt; 제공합니다 . 또한 &lt;code&gt;project.setUsers()&lt;/code&gt; 대신 Sequelize는 &lt;code&gt;project.setL&amp;iacute;deres()&lt;/code&gt; 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="abff63f50f4e22a39d39942704040b4902951cc5" translate="yes" xml:space="preserve">
          <source>The model tells Sequelize several things about the entity it represents, such as the name of the table in the database and which columns it has (and their data types).</source>
          <target state="translated">모델은 Sequelize에 데이터베이스의 테이블 이름과 포함 된 열 (및 해당 데이터 유형)과 같이 나타내는 엔터티에 대한 몇 가지 사항을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="2ba17aa0bb5f9dc7d5841a219c942e597585fcbc" translate="yes" xml:space="preserve">
          <source>The model used to join both sides of the N:M association.</source>
          <target state="translated">N : M 연관의 양쪽을 결합하는 데 사용 된 모델입니다.</target>
        </trans-unit>
        <trans-unit id="344f38a91e7d9dc5d063993463bcdaa555327fc6" translate="yes" xml:space="preserve">
          <source>The model you want to eagerly load</source>
          <target state="translated">간절히로드하려는 모델</target>
        </trans-unit>
        <trans-unit id="7958ce6ba41d78327583cdbfd8cb6017bf350a54" translate="yes" xml:space="preserve">
          <source>The name of a model defined with Sequelize.define</source>
          <target state="translated">Sequelize.define으로 정의 된 모델의 이름</target>
        </trans-unit>
        <trans-unit id="20779cb99d8b313c45bb680661f5068180a4b366" translate="yes" xml:space="preserve">
          <source>The name of the attribute to use as the key for the association in the source table. Defaults to the primary key of the source table</source>
          <target state="translated">소스 테이블에서 연관의 키로 사용할 속성의 이름입니다. 기본적으로 소스 테이블의 기본 키</target>
        </trans-unit>
        <trans-unit id="2c370d4fbb6793a135a98f2d34ffdc1efa7aa44d" translate="yes" xml:space="preserve">
          <source>The name of the attribute to use as the key for the association in the target table. Defaults to the primary key of the target table</source>
          <target state="translated">대상 테이블에서 연관의 키로 사용할 속성의 이름입니다. 대상 테이블의 기본 키가 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="93c15edec87bb8d344200119a7dc2a4a142ddf00" translate="yes" xml:space="preserve">
          <source>The name of the column</source>
          <target state="translated">열의 이름</target>
        </trans-unit>
        <trans-unit id="8c4f59698903f75b8bd6022cb4552203a39c97a3" translate="yes" xml:space="preserve">
          <source>The name of the database</source>
          <target state="translated">데이터베이스 이름</target>
        </trans-unit>
        <trans-unit id="22a68705226fe8673395221999a0d393f6c5865e" translate="yes" xml:space="preserve">
          <source>The name of the field to use as the key for the association in the source table. Defaults to the primary key of the source table</source>
          <target state="translated">소스 테이블에서 연관의 키로 사용할 필드 이름입니다. 기본적으로 소스 테이블의 기본 키</target>
        </trans-unit>
        <trans-unit id="15885ab4b151a1a790fcb10a8b5e2b0d66ba2eec" translate="yes" xml:space="preserve">
          <source>The name of the foreign key attribute in the source table or an object representing the type definition for the foreign column (see &lt;code&gt;Sequelize.define&lt;/code&gt; for syntax). When using an object, you can add a &lt;code&gt;name&lt;/code&gt; property to set the name of the column. Defaults to the name of target + primary key of target</source>
          <target state="translated">소스 테이블의 외래 키 속성 이름 또는 외래 열의 유형 정의를 나타내는 개체 입니다 (구문 은 &lt;code&gt;Sequelize.define&lt;/code&gt; 참조 ). 객체를 사용할 때 &lt;code&gt;name&lt;/code&gt; 속성을 추가 하여 열 이름을 설정할 수 있습니다 . 기본적으로 대상 이름 + 대상의 기본 키</target>
        </trans-unit>
        <trans-unit id="eb6459fe5afc725ce007c909a06d98e3db4d2d06" translate="yes" xml:space="preserve">
          <source>The name of the foreign key attribute in the target model or an object representing the type definition for the foreign column (see &lt;code&gt;Sequelize.define&lt;/code&gt; for syntax). When using an object, you can add a &lt;code&gt;name&lt;/code&gt; property to set the name of the column. Defaults to the name of source + primary key of source</source>
          <target state="translated">대상 모델의 외래 키 속성 이름 또는 외래 열의 형식 정의를 나타내는 개체 입니다 (구문 은 &lt;code&gt;Sequelize.define&lt;/code&gt; 참조 ). 객체를 사용할 때 &lt;code&gt;name&lt;/code&gt; 속성을 추가 하여 열 이름을 설정할 수 있습니다 . 기본적으로 소스 이름 + 소스의 기본 키</target>
        </trans-unit>
        <trans-unit id="42469972a87959d8071e3f01dc78f6c8d2553e4f" translate="yes" xml:space="preserve">
          <source>The name of the foreign key in the join table (representing the source model) or an object representing the type definition for the foreign column (see &lt;code&gt;Sequelize.define&lt;/code&gt; for syntax). When using an object, you can add a &lt;code&gt;name&lt;/code&gt; property to set the name of the column. Defaults to the name of source + primary key of source</source>
          <target state="translated">조인 테이블의 외부 키 이름 (소스 모델을 나타냄) 또는 외부 열에 대한 유형 정의를 나타내는 객체 ( 구문 은 &lt;code&gt;Sequelize.define&lt;/code&gt; 참조 ). 객체를 사용할 때 &lt;code&gt;name&lt;/code&gt; 속성을 추가 하여 열 이름을 설정할 수 있습니다 . 기본적으로 소스 이름 + 소스의 기본 키</target>
        </trans-unit>
        <trans-unit id="fe4d422c72187bb994f27a984373dd051447a90f" translate="yes" xml:space="preserve">
          <source>The name of the foreign key in the join table (representing the target model) or an object representing the type definition for the other column (see &lt;code&gt;Sequelize.define&lt;/code&gt; for syntax). When using an object, you can add a &lt;code&gt;name&lt;/code&gt; property to set the name of the column. Defaults to the name of target + primary key of target</source>
          <target state="translated">조인 테이블의 외래 키 이름 (대상 모델을 나타냄) 또는 다른 열의 유형 정의를 나타내는 객체 입니다 (구문 은 &lt;code&gt;Sequelize.define&lt;/code&gt; 참조 ). 객체를 사용할 때 &lt;code&gt;name&lt;/code&gt; 속성을 추가 하여 열 이름을 설정할 수 있습니다 . 기본적으로 대상 이름 + 대상의 기본 키</target>
        </trans-unit>
        <trans-unit id="38709c5641379045db5e5d83ba646ba0c902d682" translate="yes" xml:space="preserve">
          <source>The name of the foreign key in the target table or an object representing the type definition for the foreign column (see &lt;code&gt;Sequelize.define&lt;/code&gt; for syntax). When using an object, you can add a &lt;code&gt;name&lt;/code&gt; property to set the name of the column. Defaults to the name of source + primary key of source</source>
          <target state="translated">대상 테이블의 외래 키 이름 또는 외래 열의 형식 정의를 나타내는 개체 입니다 (구문 은 &lt;code&gt;Sequelize.define&lt;/code&gt; 참조 ). 객체를 사용할 때 &lt;code&gt;name&lt;/code&gt; 속성을 추가 하여 열 이름을 설정할 수 있습니다 . 기본적으로 소스 이름 + 소스의 기본 키</target>
        </trans-unit>
        <trans-unit id="7a7cf09bcd6575bf593ecb7e44a875789583a801" translate="yes" xml:space="preserve">
          <source>The name of the index. Defaults to model name + _ + fields concatenated</source>
          <target state="translated">색인의 이름입니다. 연결된 모델 이름 + _ + 필드의 기본값</target>
        </trans-unit>
        <trans-unit id="e0dee175f7513db4bb65e2da34923be2d4fb8f8d" translate="yes" xml:space="preserve">
          <source>The name of the language that the function is implemented in</source>
          <target state="translated">함수가 구현되는 언어의 이름</target>
        </trans-unit>
        <trans-unit id="901c3e2315864e0cfc881f469ee9e42e145e1941" translate="yes" xml:space="preserve">
          <source>The name of the model on which the update was attempted</source>
          <target state="translated">업데이트가 시도 된 모델의 이름</target>
        </trans-unit>
        <trans-unit id="4ea96b65632c0d275cf41855cbbc4cfc2e78bbea" translate="yes" xml:space="preserve">
          <source>The name of the model. The model will be stored in &lt;code&gt;sequelize.models&lt;/code&gt; under this name</source>
          <target state="translated">모델의 이름입니다. 모델은 이 이름 으로 &lt;code&gt;sequelize.models&lt;/code&gt; 에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="fa9b6db53f226bce8b7814cf4cd827147473b678" translate="yes" xml:space="preserve">
          <source>The name of the schema</source>
          <target state="translated">스키마의 이름</target>
        </trans-unit>
        <trans-unit id="4a337049980fb26ef87b1957b77e10b1adaa13d4" translate="yes" xml:space="preserve">
          <source>The name of the scope. Use &lt;code&gt;defaultScope&lt;/code&gt; to override the default scope</source>
          <target state="translated">범위의 이름입니다. &lt;code&gt;defaultScope&lt;/code&gt; 를 사용 하여 기본 범위를 재정의</target>
        </trans-unit>
        <trans-unit id="689b7c83b43fba0e2101546e9d74f61d1a062d93" translate="yes" xml:space="preserve">
          <source>The name of the table that is used to join source and target in n:m associations. Can also be a sequelize model if you want to define the junction table yourself and add extra attributes to it.</source>
          <target state="translated">n : m 연관에서 소스와 대상을 결합하는 데 사용되는 테이블의 이름입니다. 정션 테이블을 직접 정의하고 추가 속성을 추가하려는 경우 순차 모델 일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6408e2ecf1340ab31daec80973b0b23a6dc6fdf2" translate="yes" xml:space="preserve">
          <source>The name of the template from which to create the new database, PostgreSQL only</source>
          <target state="translated">새 데이터베이스를 생성 할 템플릿 이름 (PostgreSQL 만 해당)</target>
        </trans-unit>
        <trans-unit id="e491db23ab33dd3e30028e864986440ecc5c17fe" translate="yes" xml:space="preserve">
          <source>The new range can be used in model definitions as &lt;code&gt;DataTypes.RANGE(DataTypes.SOMETYPE)&lt;/code&gt; or &lt;code&gt;DataTypes.RANGE(DataTypes.SOMETYPE)&lt;/code&gt;.</source>
          <target state="translated">새 범위는 모델 정의에서 &lt;code&gt;DataTypes.RANGE(DataTypes.SOMETYPE)&lt;/code&gt; 또는 &lt;code&gt;DataTypes.RANGE(DataTypes.SOMETYPE)&lt;/code&gt; 로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3af644ca8cb4bd3901646f8c9686c10ad3f438f9" translate="yes" xml:space="preserve">
          <source>The new range can be used in model definitions as &lt;code&gt;Sequelize.RANGE(Sequelize.NEWTYPE)&lt;/code&gt; or &lt;code&gt;DataTypes.RANGE(DataTypes.NEWTYPE)&lt;/code&gt;.</source>
          <target state="translated">새 범위는 모델 정의에서 &lt;code&gt;Sequelize.RANGE(Sequelize.NEWTYPE)&lt;/code&gt; 또는 &lt;code&gt;DataTypes.RANGE(DataTypes.NEWTYPE)&lt;/code&gt; 로 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="efbd63110ba59eb18101daa4d72f9939a5daaca0" translate="yes" xml:space="preserve">
          <source>The next example is of a migration that creates an unique index composed of multiple fields with a condition, which allows a relation to exist multiple times but only one can satisfy the condition:</source>
          <target state="translated">다음 예는 조건이있는 여러 필드로 구성된 고유 인덱스를 생성하는 마이그레이션으로, 관계가 여러 번 존재할 수 있지만 하나만 조건을 충족 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6831c357e921f615d34e26a18dab83a426f891bb" translate="yes" xml:space="preserve">
          <source>The next example is of a migration that has a foreign key. You can use references to specify a foreign key:</source>
          <target state="translated">다음 예는 외래 키가있는 마이그레이션입니다. 참조를 사용하여 외래 키를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a22d570e2dbed2ac66aa83f59f2d5124d3ecdfc" translate="yes" xml:space="preserve">
          <source>The next example is of a migration that uses async/await where you create an unique index on a new column, with a manually-managed transaction:</source>
          <target state="translated">다음 예제는 수동으로 관리되는 트랜잭션으로 새 열에 고유 인덱스를 만드는 async / await를 사용하는 마이그레이션입니다.</target>
        </trans-unit>
        <trans-unit id="c3d7de3db43f176261838315f9462534066abc21" translate="yes" xml:space="preserve">
          <source>The next is an example of a migration that has a foreign key. You can use references to specify a foreign key:</source>
          <target state="translated">다음은 외래 키가있는 마이그레이션의 예입니다. 참조를 사용하여 외래 키를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e90d9ad1b9b3b4f1a236dc0cc182271fbe723b0e" translate="yes" xml:space="preserve">
          <source>The next is an example of a migration that has uses async/await where you create an unique index on a new column:</source>
          <target state="translated">다음은 async / await를 사용하여 새 열에 고유 인덱스를 생성하는 마이그레이션의 예입니다.</target>
        </trans-unit>
        <trans-unit id="5bfd201c5d2f64d334aaed75ca93f6250c27f3e0" translate="yes" xml:space="preserve">
          <source>The number of destroyed rows</source>
          <target state="translated">파괴 된 행의 수</target>
        </trans-unit>
        <trans-unit id="3373583000bc71ae0b35559454845902a56e4c5d" translate="yes" xml:space="preserve">
          <source>The number of times a connection can be used before discarding it for a replacement, &lt;a href=&quot;https://github.com/sequelize/sequelize-pool&quot;&gt;&lt;code&gt;used for eventual cluster rebalancing&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">교체를 위해 연결을 버리기 전에 &lt;a href=&quot;https://github.com/sequelize/sequelize-pool&quot;&gt; &lt;code&gt;used for eventual cluster rebalancing&lt;/code&gt; &lt;/a&gt; 되는 연결을 사용할 수있는 횟수입니다 .</target>
        </trans-unit>
        <trans-unit id="6081ff3872966efe1d8dfd421d4fb7860123280f" translate="yes" xml:space="preserve">
          <source>The number to decrement by</source>
          <target state="translated">감소 할 숫자</target>
        </trans-unit>
        <trans-unit id="30c2b338b0c6fb53c4b5c1dd307e605378770430" translate="yes" xml:space="preserve">
          <source>The number to increment by</source>
          <target state="translated">증가 할 숫자</target>
        </trans-unit>
        <trans-unit id="9a251a1717e23706be50c156e494217a1612517f" translate="yes" xml:space="preserve">
          <source>The only difference is when you try to perform an eager load with Sequelize.</source>
          <target state="translated">유일한 차이점은 Sequelize로 열심히 부하를 수행하려고 할 때입니다.</target>
        </trans-unit>
        <trans-unit id="de36c08060ac20ff8a2842263f532923aed2f6a2" translate="yes" xml:space="preserve">
          <source>The only exception is the guide on &lt;code&gt;sequelize.import&lt;/code&gt;, which is deprecated and was removed from the docs. However, if you really need it, it was kept here.</source>
          <target state="translated">유일한 예외는 더 이상 사용되지 않고 문서에서 제거 된 &lt;code&gt;sequelize.import&lt;/code&gt; 에 대한 가이드입니다 . 그러나 정말로 필요한 경우 여기에 보관했습니다.</target>
        </trans-unit>
        <trans-unit id="5519b26afd29019553644d95f3657c0b4ef9b9ea" translate="yes" xml:space="preserve">
          <source>The only way to call beforeDestroy/afterDestroy hooks are on associations with &lt;code&gt;onDelete: 'cascade'&lt;/code&gt; and the option &lt;code&gt;hooks: true&lt;/code&gt;. For instance:</source>
          <target state="translated">beforeDestroy / afterDestroy 후크를 호출하는 유일한 방법은 &lt;code&gt;onDelete: 'cascade'&lt;/code&gt; 및 옵션 &lt;code&gt;hooks: true&lt;/code&gt; 와의 연관에 있습니다 . 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="724c685e5b43aa161bca59f04db31535392db688" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;Op.and&lt;/code&gt;, &lt;code&gt;Op.or&lt;/code&gt; and &lt;code&gt;Op.not&lt;/code&gt; can be used to create arbitrarily complex nested logical comparisons.</source>
          <target state="translated">연산자 &lt;code&gt;Op.and&lt;/code&gt; , &lt;code&gt;Op.or&lt;/code&gt; 및 &lt;code&gt;Op.not&lt;/code&gt; 은 임의의 복잡한 중첩 논리 비교를 생성하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c69a63575e1fb55daa7f9a2dfde0c6053bf26ef6" translate="yes" xml:space="preserve">
          <source>The options object that you pass to &lt;code&gt;findAndCountAll&lt;/code&gt; is the same as for &lt;code&gt;findAll&lt;/code&gt; (described below).</source>
          <target state="translated">&lt;code&gt;findAndCountAll&lt;/code&gt; 에 전달하는 옵션 객체는 &lt;code&gt;findAll&lt;/code&gt; (아래 설명)과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="a45202cbcffdecef1bfb35227b61eaaaeef09d0e" translate="yes" xml:space="preserve">
          <source>The options passed to Model.destroy in addition to truncate</source>
          <target state="translated">자르는 것 외에도 Model.destroy에 전달 된 옵션</target>
        </trans-unit>
        <trans-unit id="3f3dcd71f3878dfff6b16011edbaab2ef1e64db1" translate="yes" xml:space="preserve">
          <source>The options passed to each call to Model.drop</source>
          <target state="translated">Model.drop에 대한 각 호출에 전달 된 옵션</target>
        </trans-unit>
        <trans-unit id="3dec20cfd23a77b69ba97c865d465d72327c175a" translate="yes" xml:space="preserve">
          <source>The options to be applied in this case are the same from the One-To-One case. For example, to change the name of the foreign key and make sure that the relationship is mandatory, we can do:</source>
          <target state="translated">이 경우 적용 할 옵션은 일대일 경우와 동일합니다. 예를 들어 외래 키의 이름을 변경하고 관계가 필수인지 확인하려면 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96ed4b15b5460f305663e5c7e52681e46c195851" translate="yes" xml:space="preserve">
          <source>The order in which the association is defined is relevant. In other words, the order matters, for the four cases. In all examples above, &lt;code&gt;A&lt;/code&gt; is called the &lt;strong&gt;source&lt;/strong&gt; model and &lt;code&gt;B&lt;/code&gt; is called the &lt;strong&gt;target&lt;/strong&gt; model. This terminology is important.</source>
          <target state="translated">연관이 정의 된 순서는 관련이 있습니다. 즉, 네 가지 경우의 순서가 중요합니다. 위의 모든 예에서 &lt;code&gt;A&lt;/code&gt; 를 &lt;strong&gt;소스&lt;/strong&gt; 모델 이라고 하고 &lt;code&gt;B&lt;/code&gt; 를 &lt;strong&gt;대상&lt;/strong&gt; 모델 이라고합니다 . 이 용어는 중요합니다.</target>
        </trans-unit>
        <trans-unit id="b843160b62331068336d27cc8d45b2412cdff08d" translate="yes" xml:space="preserve">
          <source>The parameters for the sql that triggered the error</source>
          <target state="translated">오류를 유발 한 SQL의 매개 변수</target>
        </trans-unit>
        <trans-unit id="9173a469193229c3d70ef16f8e6729295bde9416" translate="yes" xml:space="preserve">
          <source>The part about players is trickier. We note that the set of players that form a team depends not only on the team (obviously), but also on which game is being considered. Therefore, we don't want a Many-to-Many relationship between Player and Team. We also don't want a Many-to-Many relationship between Player and Game. Instead of associating a Player to any of those models, what we need is an association between a Player and something like a &lt;em&gt;&quot;team-game pair constraint&quot;&lt;/em&gt;, since it is the pair (team plus game) that defines which players belong there. So what we are looking for turns out to be precisely the junction model, GameTeam, itself! And, we note that, since a given &lt;em&gt;game-team pair&lt;/em&gt; specifies many players, and on the other hand that the same player can participate of many &lt;em&gt;game-team pairs&lt;/em&gt;, we need a Many-to-Many relationship between Player and GameTeam!</source>
          <target state="translated">플레이어에 대한 부분은 더 까다 롭습니다. 팀을 구성하는 플레이어 세트는 팀 (분명히)뿐만 아니라 고려중인 게임에 따라 다릅니다. 따라서 우리는 플레이어와 팀 간의 다 대다 관계를 원하지 않습니다. 또한 플레이어와 게임간에 다 대다 관계를 원하지 않습니다. 플레이어를 이러한 모델에 연결하는 대신 플레이어와 &lt;em&gt;&quot;팀-게임 쌍 제약&quot;&lt;/em&gt; 과 같은 것 사이의 연결이 필요합니다 . 왜냐하면 어떤 플레이어가 거기에 속하는지 정의하는 쌍 (팀 + 게임)이기 때문입니다. 그래서 우리가 찾고있는 것은 바로 접합 모델 인 GameTeam 그 자체입니다! 그리고 우리는 주어진 &lt;em&gt;게임-팀 쌍이&lt;/em&gt; 많은 플레이어를 지정하고 다른 한편으로는 같은 플레이어가 많은&lt;em&gt;게임 팀 쌍&lt;/em&gt; , 우리는 Player와 GameTeam 사이에 다 대다 관계가 필요합니다!</target>
        </trans-unit>
        <trans-unit id="b7e618cc7e765bd054110930a05bbf6f5cafdacb" translate="yes" xml:space="preserve">
          <source>The passed &lt;code&gt;queryInterface&lt;/code&gt; object can be used to modify the database. The &lt;code&gt;Sequelize&lt;/code&gt; object stores the available data types such as &lt;code&gt;STRING&lt;/code&gt; or &lt;code&gt;INTEGER&lt;/code&gt;. Function &lt;code&gt;up&lt;/code&gt; or &lt;code&gt;down&lt;/code&gt; should return a &lt;code&gt;Promise&lt;/code&gt;. Let's look at an example:</source>
          <target state="translated">전달 된 &lt;code&gt;queryInterface&lt;/code&gt; 오브젝트를 사용하여 데이터베이스를 수정할 수 있습니다. &lt;code&gt;Sequelize&lt;/code&gt; 의 같은 객체를 저장 가능한 데이터 유형 &lt;code&gt;STRING&lt;/code&gt; 또는 &lt;code&gt;INTEGER&lt;/code&gt; . &lt;code&gt;up&lt;/code&gt; 또는 &lt;code&gt;down&lt;/code&gt; 기능 은 &lt;code&gt;Promise&lt;/code&gt; 를 반환해야합니다 . 예를 보자.</target>
        </trans-unit>
        <trans-unit id="d2533745943844afbedf7eb8255a5190f883bdec" translate="yes" xml:space="preserve">
          <source>The password which is used to authenticate against the database.</source>
          <target state="translated">데이터베이스를 인증하는 데 사용되는 비밀번호입니다.</target>
        </trans-unit>
        <trans-unit id="e964b1bc1afa7e133edcfa208521202aaf1336e1" translate="yes" xml:space="preserve">
          <source>The password which is used to authenticate against the database. Supports SQLCipher encryption for SQLite.</source>
          <target state="translated">데이터베이스를 인증하는 데 사용되는 비밀번호입니다. SQLite에 대한 SQLCipher 암호화를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="d1f9da31741290e9b21dee89de285e5d49b6e9b8" translate="yes" xml:space="preserve">
          <source>The path to be checked for error items</source>
          <target state="translated">오류 항목을 확인할 경로</target>
        </trans-unit>
        <trans-unit id="e666a85eaccb1faddd6ef50cb44be68ea6f3ce05" translate="yes" xml:space="preserve">
          <source>The path to the file that holds the model you want to import. If the part is relative, it will be resolved relatively to the calling file</source>
          <target state="translated">가져올 모델이 들어있는 파일의 경로입니다. 부품이 상대적인 경우 호출 파일을 기준으로 상대적으로 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="52ec3b98cef1dcaeea55cc63084c0f82417242c6" translate="yes" xml:space="preserve">
          <source>The polymorphic association can be implemented with an &lt;em&gt;association scope&lt;/em&gt; :</source>
          <target state="translated">다형성 연관은 &lt;em&gt;연관 범위&lt;/em&gt; 로 구현 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ccdd83d9259d4f504d2c47076b673df711befe8f" translate="yes" xml:space="preserve">
          <source>The port of the relational database.</source>
          <target state="translated">관계형 데이터베이스의 포트입니다.</target>
        </trans-unit>
        <trans-unit id="c2240c834a7879a02a685d3c4f2fb6c22d8c9821" translate="yes" xml:space="preserve">
          <source>The possible choices are &lt;code&gt;RESTRICT&lt;/code&gt;, &lt;code&gt;CASCADE&lt;/code&gt;, &lt;code&gt;NO ACTION&lt;/code&gt;, &lt;code&gt;SET DEFAULT&lt;/code&gt; and &lt;code&gt;SET NULL&lt;/code&gt;.</source>
          <target state="translated">가능한 선택 사항은 &lt;code&gt;RESTRICT&lt;/code&gt; , &lt;code&gt;CASCADE&lt;/code&gt; , &lt;code&gt;NO ACTION&lt;/code&gt; , &lt;code&gt;SET DEFAULT&lt;/code&gt; 및 &lt;code&gt;SET NULL&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9a65ac5ab95179f410b68d283a2ce4caa4e100b0" translate="yes" xml:space="preserve">
          <source>The possible isolations levels to use when starting a transaction:</source>
          <target state="translated">트랜잭션을 시작할 때 사용할 수있는 격리 수준 :</target>
        </trans-unit>
        <trans-unit id="cadc5244d3fbd7d24b1c5864d52995cd667e11c7" translate="yes" xml:space="preserve">
          <source>The previous example can be extended to support an association alias.</source>
          <target state="translated">이전 예는 연관 별명을 지원하도록 확장 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e7860e1e9fe6157f068d6e05ea4c9ba937f1820" translate="yes" xml:space="preserve">
          <source>The promise fulfills if and only if validation successful; otherwise it rejects an Error instance containing { field name : [error msgs] } entries.</source>
          <target state="translated">약속은 검증이 성공한 경우에만 이행합니다. 그렇지 않으면 {field name : [error msgs]} 항목을 포함하는 Error 인스턴스를 거부합니다.</target>
        </trans-unit>
        <trans-unit id="c7345c3a97b1369d2ea2bf0cee0e1778a424ab23" translate="yes" xml:space="preserve">
          <source>The promise returns an array with one or two elements. The first element is always the number of affected rows, while the second element is the actual affected rows (only supported in postgres with &lt;code&gt;options.returning&lt;/code&gt; true).</source>
          <target state="translated">promise는 하나 또는 두 개의 요소가있는 배열을 반환합니다. 첫 번째 요소는 항상 영향을받는 행 수이고 두 번째 요소는 실제 영향을받는 행입니다 ( &lt;code&gt;options.returning&lt;/code&gt; true를 사용 하여 postgres에서만 지원됨 ).</target>
        </trans-unit>
        <trans-unit id="b66998033b01ad0f71a1f99fd1205004d74f54f7" translate="yes" xml:space="preserve">
          <source>The protocol of the relational database.</source>
          <target state="translated">관계형 데이터베이스의 프로토콜.</target>
        </trans-unit>
        <trans-unit id="9b65629117d86e6ea7f1be1d190a811c13b665fb" translate="yes" xml:space="preserve">
          <source>The query above will only count users who have an active profile, because &lt;code&gt;required&lt;/code&gt; is implicitly set to true when you add a where clause to the include.</source>
          <target state="translated">때문에 위의 질의는 단지, 활성화 된 프로필을 가진 사용자를 계산합니다 &lt;code&gt;required&lt;/code&gt; (가) 포함에 당신이 어디에 절을 추가 할 때 암시 적으로 true로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="f17651b8defa7a688a238ee9c850c88d216bbd4b" translate="yes" xml:space="preserve">
          <source>The query above will return all users, and all their instruments, but only those teachers associated with &lt;code&gt;Woodstock Music School&lt;/code&gt;.</source>
          <target state="translated">위의 쿼리는 모든 사용자와 모든 악기를 반환하지만 &lt;code&gt;Woodstock Music School&lt;/code&gt; 과 관련된 교사 만 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="882e95417cd6d361e8a21202698fdccdb38d7585" translate="yes" xml:space="preserve">
          <source>The relation between &lt;code&gt;tasks&lt;/code&gt; and &lt;code&gt;users&lt;/code&gt; model injects the &lt;code&gt;userId&lt;/code&gt; foreign key on &lt;code&gt;tasks&lt;/code&gt; table, and marks it as a reference to the &lt;code&gt;users&lt;/code&gt; table. By default &lt;code&gt;userId&lt;/code&gt; will be set to &lt;code&gt;NULL&lt;/code&gt; if the referenced user is deleted, and updated if the id of the &lt;code&gt;userId&lt;/code&gt; updated. These options can be overridden by passing &lt;code&gt;onUpdate&lt;/code&gt; and &lt;code&gt;onDelete&lt;/code&gt; options to the association calls. The validation options are &lt;code&gt;RESTRICT, CASCADE, NO ACTION, SET DEFAULT, SET NULL&lt;/code&gt;.</source>
          <target state="translated">관계 &lt;code&gt;tasks&lt;/code&gt; 및 &lt;code&gt;users&lt;/code&gt; 모델이 주입 &lt;code&gt;userId&lt;/code&gt; 를 외국 키 &lt;code&gt;tasks&lt;/code&gt; 받는 참조 표를 표시하고이를 &lt;code&gt;users&lt;/code&gt; 테이블. 기본적으로 &lt;code&gt;userId&lt;/code&gt; 를 설정됩니다 &lt;code&gt;NULL&lt;/code&gt; 참조 된 사용자가 삭제 된 경우, 그리고의 ID 경우 업데이트 &lt;code&gt;userId&lt;/code&gt; 를가 업데이트되었습니다. &lt;code&gt;onUpdate&lt;/code&gt; 및 &lt;code&gt;onDelete&lt;/code&gt; 옵션을 연관 호출 에 전달 하여이 옵션을 대체 할 수 있습니다 . 유효성 검사 옵션은 &lt;code&gt;RESTRICT, CASCADE, NO ACTION, SET DEFAULT, SET NULL&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c186d6d0cc96ba2977a2565353a1571ae5cb4b2f" translate="yes" xml:space="preserve">
          <source>The reload call generates a &lt;code&gt;SELECT&lt;/code&gt; query to get the up-to-date data from the database.</source>
          <target state="translated">다시로드 호출 은 데이터베이스에서 최신 데이터를 가져 오는 &lt;code&gt;SELECT&lt;/code&gt; 쿼리를 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="d4da4124847d2aa2a17ae9f754e707b273268937" translate="yes" xml:space="preserve">
          <source>The result is essentially the same! This is because &lt;code&gt;User.hasMany(Grant)&lt;/code&gt; and &lt;code&gt;Profile.hasMany(Grant)&lt;/code&gt; will automatically add the &lt;code&gt;userId&lt;/code&gt; and &lt;code&gt;profileId&lt;/code&gt; columns to &lt;code&gt;Grant&lt;/code&gt;, respectively.</source>
          <target state="translated">결과는 본질적으로 동일합니다! 이는 &lt;code&gt;User.hasMany(Grant)&lt;/code&gt; 및 &lt;code&gt;Profile.hasMany(Grant)&lt;/code&gt; 가 각각 &lt;code&gt;userId&lt;/code&gt; 및 &lt;code&gt;profileId&lt;/code&gt; 열을 &lt;code&gt;Grant&lt;/code&gt; 에 자동으로 추가하기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="8fae2fbc67eab57ec86460fea4616c6de11c88b0" translate="yes" xml:space="preserve">
          <source>The same idea can also be applied to &lt;code&gt;belongsToMany&lt;/code&gt; relationships. However, unlike the other situations, in which we have only one foreign key involved, the &lt;code&gt;belongsToMany&lt;/code&gt; relationship involves two foreign keys which are kept on an extra table (the junction table).</source>
          <target state="translated">같은 아이디어가 &lt;code&gt;belongsToMany&lt;/code&gt; 관계 에도 적용될 수 있습니다 . 그러나 외래 키가 하나만 관련된 다른 상황과 달리, &lt;code&gt;belongsToMany&lt;/code&gt; 관계는 추가 테이블 (junction 테이블)에 보관되는 두 개의 외래 키를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="8b9f7f5e66de32f9f00b194b0d793b58686e0548" translate="yes" xml:space="preserve">
          <source>The same merge logic applies when passing a find object directly to &lt;code&gt;findAll&lt;/code&gt; (and similar finders) on a scoped model:</source>
          <target state="translated">범위가 지정된 모델의 &lt;code&gt;findAll&lt;/code&gt; (및 유사한 파인더)에 찾기 오브젝트를 직접 전달할 때 동일한 병합 논리가 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="17776f8e98a378c253585cba5342512d2a5a5b0d" translate="yes" xml:space="preserve">
          <source>The same ones from &lt;code&gt;Foo.hasMany(Bar)&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Foo.hasMany(Bar)&lt;/code&gt; 에서 동일한 것 :</target>
        </trans-unit>
        <trans-unit id="d71483dbaaff7debf540d59eff1625fd50660647" translate="yes" xml:space="preserve">
          <source>The same ones from &lt;code&gt;Foo.hasOne(Bar)&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Foo.hasOne(Bar)&lt;/code&gt; 의 동일한 항목 :</target>
        </trans-unit>
        <trans-unit id="97ab6aa4ba7990a147bb964cdd7e87d1f62efe69" translate="yes" xml:space="preserve">
          <source>The schema that the tables should be created in. This can be overridden for each table in sequelize.define</source>
          <target state="translated">테이블을 작성해야하는 스키마. sequelize.define의 각 테이블에 대해이를 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c43a2f21b215e63de5816eae94cb4b78d64ee9df" translate="yes" xml:space="preserve">
          <source>The scope(s) to apply. Scopes can either be passed as consecutive arguments, or as an array of arguments. To apply simple scopes and scope functions with no arguments, pass them as strings. For scope function, pass an object, with a &lt;code&gt;method&lt;/code&gt; property. The value can either be a string, if the method does not take any arguments, or an array, where the first element is the name of the method, and consecutive elements are arguments to that method. Pass null to remove all scopes, including the default.</source>
          <target state="translated">적용 할 범위. 범위는 연속 인수 또는 인수 배열로 전달 될 수 있습니다. 인수없이 간단한 범위와 범위 함수를 적용하려면 문자열로 전달하십시오. 범위 함수의 경우 &lt;code&gt;method&lt;/code&gt; 특성 과 함께 오브젝트를 전달하십시오 . 메소드가 인수를 취하지 않는 경우 값은 문자열이거나 첫 번째 요소가 메소드의 이름이고 연속 요소가 해당 메소드의 인수 인 배열 일 수 있습니다. 기본값을 포함하여 모든 범위를 제거하려면 null을 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="f2d4b0658a321b27ba4fa154149f819df1aa69b7" translate="yes" xml:space="preserve">
          <source>The setup for this goes as follows:</source>
          <target state="translated">이에 대한 설정은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ff5d3a27c04e6d2799dc75afdbaf7f4959931871" translate="yes" xml:space="preserve">
          <source>The simplest way to define the Many-to-Many relationship is:</source>
          <target state="translated">다 대다 관계를 정의하는 가장 간단한 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e118bc1e681bc034058a8bda4bc03316fe86fe78" translate="yes" xml:space="preserve">
          <source>The socket path must start with &lt;code&gt;/&lt;/code&gt;.</source>
          <target state="translated">소켓 경로는 &lt;code&gt;/&lt;/code&gt; 로 시작해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9172e13521a1aa7d3a6e044b2d41f68f8949091b" translate="yes" xml:space="preserve">
          <source>The solution is to tell Sequelize to include both Images and Videos, so that our &lt;code&gt;afterFind&lt;/code&gt; hook defined above will do the work, automatically adding the &lt;code&gt;commentable&lt;/code&gt; field to the instance object, providing the abstraction we want.</source>
          <target state="translated">해결책은 Sequelize에게 이미지와 비디오를 모두 포함하도록 지시하여 위에서 정의한 &lt;code&gt;afterFind&lt;/code&gt; 후크가 작업을 수행 하여 인스턴스 객체에 &lt;code&gt;commentable&lt;/code&gt; 필드를 자동으로 추가하여 원하는 추상화를 제공하도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5a2ca207850bf8f92ef8c79ea6faebe0a9682e77" translate="yes" xml:space="preserve">
          <source>The source key is the attribute on the source model that the foreign key attribute on the target model points to. By default the source key for a &lt;code&gt;hasOne&lt;/code&gt; relation will be the source model's primary attribute. To use a custom attribute, use the &lt;code&gt;sourceKey&lt;/code&gt; option.</source>
          <target state="translated">소스 키는 대상 모델의 외래 키 속성이 가리키는 소스 모델의 속성입니다. 기본적으로 &lt;code&gt;hasOne&lt;/code&gt; 관계 의 소스 키 는 소스 모델의 기본 속성입니다. 사용자 정의 속성을 사용하려면 &lt;code&gt;sourceKey&lt;/code&gt; 옵션을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f620901a19bb7656abbdf382102fb74721c6995b" translate="yes" xml:space="preserve">
          <source>The specified dialect.</source>
          <target state="translated">지정된 방언.</target>
        </trans-unit>
        <trans-unit id="55da2b2d35bc1e7629eadbe7b1ec3caa26f12e10" translate="yes" xml:space="preserve">
          <source>The success handler is passed an array of instances, but please notice that these may not completely represent the state of the rows in the DB. This is because MySQL and SQLite do not make it easy to obtain back automatically generated IDs and other default values in a way that can be mapped to multiple records. To obtain Instances for the newly created values, you will need to query for them again.</source>
          <target state="translated">성공 처리기는 인스턴스 배열로 전달되지만, DB의 행 상태를 완전히 나타내지 않을 수도 있습니다. MySQL과 SQLite는 자동으로 생성 된 ID와 다른 기본값을 여러 레코드에 매핑 할 수있는 방식으로 쉽게 다시 얻을 수 없기 때문입니다. 새로 생성 된 값에 대한 인스턴스를 얻으려면 다시 쿼리해야합니다.</target>
        </trans-unit>
        <trans-unit id="ca8c1cb986bae7a03abb7e55f466bf12bd7f5b9d" translate="yes" xml:space="preserve">
          <source>The success handler will always receive an object with two properties:</source>
          <target state="translated">성공 처리기는 항상 두 가지 속성을 가진 개체를받습니다.</target>
        </trans-unit>
        <trans-unit id="743821f331d9ff4320288f9dfa31fda644083915" translate="yes" xml:space="preserve">
          <source>The syntax for grouping and ordering are equal, except that grouping does not accept a direction as last argument of the array (there is no &lt;code&gt;ASC&lt;/code&gt;, &lt;code&gt;DESC&lt;/code&gt;, &lt;code&gt;NULLS FIRST&lt;/code&gt;, etc).</source>
          <target state="translated">그룹화 및 순서화에 대한 구문은 동일하지만 그룹화가 배열의 마지막 인수로 방향을 허용하지 않는다는 점을 제외하고는 &lt;code&gt;ASC&lt;/code&gt; , &lt;code&gt;DESC&lt;/code&gt; , &lt;code&gt;NULLS FIRST&lt;/code&gt; 등 이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="34579639c463106f1a03eee66559cab728f1641b" translate="yes" xml:space="preserve">
          <source>The syntax for grouping and ordering are equal, so below it is only explained with a single example for group, and the rest for order. Everything you see below can also be done for group</source>
          <target state="translated">그룹화 및 순서화 구문은 동일하므로 아래에서는 그룹에 대한 단일 예제와 순서에 대한 나머지 예제 만 설명합니다. 아래에서 볼 수있는 모든 것은 그룹에 대해서도 수행 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="58b66076bf28d404e11394816918b9debbdb35f5" translate="yes" xml:space="preserve">
          <source>The table columns are defined by the hash that is given as the first argument. Each attribute of the hash represents a column.</source>
          <target state="translated">테이블 열은 첫 번째 인수로 제공되는 해시에 의해 정의됩니다. 해시의 각 속성은 열을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0333c25506d7b965b09277d6ee324cf0849f0c73" translate="yes" xml:space="preserve">
          <source>The table columns are defined by the object that is given as the second argument. Each key of the object represents a column</source>
          <target state="translated">테이블 열은 두 번째 인수로 제공되는 개체에 의해 정의됩니다. 객체의 각 키는 열을 나타냅니다</target>
        </trans-unit>
        <trans-unit id="1b918538dbc34fd935439f872ac510ed2a15c0e0" translate="yes" xml:space="preserve">
          <source>The target key is the column on the target model that the foreign key column on the source model points to. By default the target key for a belongsTo relation will be the target model's primary key. To define a custom column, use the &lt;code&gt;targetKey&lt;/code&gt; option.</source>
          <target state="translated">대상 키는 소스 모델의 외래 키 열이 가리키는 대상 모델의 열입니다. 기본적으로 belongsTo 관계의 대상 키는 대상 모델의 기본 키입니다. 사용자 정의 열을 정의하려면 &lt;code&gt;targetKey&lt;/code&gt; 옵션을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="491b59fdd8f66fe0f7f13309b9f00701386dcec7" translate="yes" xml:space="preserve">
          <source>The target model</source>
          <target state="translated">대상 모델</target>
        </trans-unit>
        <trans-unit id="c366e237ccd3fa7a5cf3767dcbd191713159c4d1" translate="yes" xml:space="preserve">
          <source>The time interval, in milliseconds, after which sequelize-pool will remove idle connections.</source>
          <target state="translated">Sequelize-pool이 유휴 연결을 제거한 후의 시간 간격 (밀리 초)입니다.</target>
        </trans-unit>
        <trans-unit id="49180f7e5b04ba9d5019142b532f40f579f312c3" translate="yes" xml:space="preserve">
          <source>The timezone used when converting a date from the database into a JavaScript date. The timezone is also used to SET TIMEZONE when connecting to the server, to ensure that the result of NOW, CURRENT_TIMESTAMP and other time related functions have in the right timezone. For best cross platform performance use the format +/-HH:MM. Will also accept string versions of timezones used by moment.js (e.g. 'America/Los_Angeles'); this is useful to capture daylight savings time changes.</source>
          <target state="translated">데이터베이스에서 날짜를 JavaScript 날짜로 변환 할 때 사용되는 시간대입니다. 시간대는 또한 서버에 연결할 때 TIMEZONE을 설정하여 NOW, CURRENT_TIMESTAMP 및 기타 시간 관련 기능의 결과가 올바른 시간대에 있는지 확인하는 데 사용됩니다. 최고의 크로스 플랫폼 성능을 위해서는 +/- HH : MM 형식을 사용하십시오. moment.js에서 사용하는 시간대의 문자열 버전도 허용합니다 (예 : 'America / Los_Angeles'). 일광 절약 시간제 변경 사항을 캡처하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="22d5c59623d5082e86fcb983d4ab3c203156259b" translate="yes" xml:space="preserve">
          <source>The transaction object is used to identify a running transaction.</source>
          <target state="translated">트랜잭션 오브젝트는 실행중인 트랜잭션을 식별하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f0edfec2d8f7bf8e0afc41f8155d0fe4c8968331" translate="yes" xml:space="preserve">
          <source>The transaction object is used to identify a running transaction. It is created by calling &lt;code&gt;Sequelize.transaction()&lt;/code&gt;. To run a query under a transaction, you should pass the transaction in the options object.</source>
          <target state="translated">트랜잭션 오브젝트는 실행중인 트랜잭션을 식별하는 데 사용됩니다. &lt;code&gt;Sequelize.transaction()&lt;/code&gt; 을 호출하여 생성됩니다 . 트랜잭션에서 쿼리를 실행하려면 옵션 개체에서 트랜잭션을 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="1beb1efd0f8f2a80414557b5c568ecb7d3c36cb7" translate="yes" xml:space="preserve">
          <source>The transaction that the query should be executed under</source>
          <target state="translated">쿼리를 실행해야하는 트랜잭션</target>
        </trans-unit>
        <trans-unit id="d41deada676c3e1626e2f4d0dfcd18112ca6f8c4" translate="yes" xml:space="preserve">
          <source>The trick to deciding between &lt;code&gt;sourceKey&lt;/code&gt; and &lt;code&gt;targetKey&lt;/code&gt; is just to remember where each relationship places its foreign key. As mentioned in the beginning of this guide:</source>
          <target state="translated">&lt;code&gt;sourceKey&lt;/code&gt; 와 &lt;code&gt;targetKey&lt;/code&gt; 사이를 결정하는 비결 은 각 관계가 외래 키를 배치하는 위치를 기억하는 것입니다. 이 가이드의 시작 부분에서 언급했듯이 :</target>
        </trans-unit>
        <trans-unit id="d7eaaa527b737eaa8f46f1460009ff30ab80523a" translate="yes" xml:space="preserve">
          <source>The type of query you are executing. The query type affects how results are formatted before they are passed back. The type is a string, but &lt;code&gt;Sequelize.QueryTypes&lt;/code&gt; is provided as convenience shortcuts.</source>
          <target state="translated">실행중인 쿼리 유형입니다. 쿼리 유형은 결과가 다시 전달되기 전에 형식이 지정되는 방식에 영향을줍니다. 형식은 문자열이지만 &lt;code&gt;Sequelize.QueryTypes&lt;/code&gt; 는 편의 단축키로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="6ac3e6aea5927228f941582e70503ef95b61da85" translate="yes" xml:space="preserve">
          <source>The type of the association.</source>
          <target state="translated">연관 유형.</target>
        </trans-unit>
        <trans-unit id="c3a22137eb7f0a4c6f818bf5181fd51cda693d63" translate="yes" xml:space="preserve">
          <source>The type of the association. One of &lt;code&gt;HasMany&lt;/code&gt;, &lt;code&gt;BelongsTo&lt;/code&gt;, &lt;code&gt;HasOne&lt;/code&gt;, &lt;code&gt;BelongsToMany&lt;/code&gt;</source>
          <target state="translated">연관 유형. &lt;code&gt;HasMany&lt;/code&gt; 중 하나 , &lt;code&gt;BelongsTo&lt;/code&gt; , &lt;code&gt;HasOne&lt;/code&gt; , &lt;code&gt;BelongsToMany&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a84720b6e6d1abe177c213ae349687b9ecbd326e" translate="yes" xml:space="preserve">
          <source>The type of the result. If &lt;code&gt;field&lt;/code&gt; is a field in this Model, the default will be the type of that field, otherwise defaults to float.</source>
          <target state="translated">결과의 유형입니다. 경우 &lt;code&gt;field&lt;/code&gt; 이 모델의 필드이며, 기본값은 해당 필드의 종류, 플로트에, 그렇지 않으면 기본값이 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="183dc3fd6b319dae15e0ede29af243c273ee8685" translate="yes" xml:space="preserve">
          <source>The type to cast it to</source>
          <target state="translated">캐스트 할 유형</target>
        </trans-unit>
        <trans-unit id="0ba8f3d4b3e41ec8a080d8bbbadbfdd6e148ee51" translate="yes" xml:space="preserve">
          <source>The type/origin of the validation error</source>
          <target state="translated">유효성 검사 오류의 유형 / 원점</target>
        </trans-unit>
        <trans-unit id="f8ec51192e9656a6fac1fb91d12062237b9f0ba6" translate="yes" xml:space="preserve">
          <source>The typings for Sequelize v5 allowed you to define models without specifying types for the attributes. This is still possible for backwards compatibility and for cases where you feel strict typing for attributes isn't worth it.</source>
          <target state="translated">Sequelize v5의 유형을 사용하면 속성 유형을 지정하지 않고도 모델을 정의 할 수 있습니다. 이는 이전 버전과의 호환성 및 속성에 대한 엄격한 입력이 가치가 없다고 생각하는 경우에도 여전히 가능합니다.</target>
        </trans-unit>
        <trans-unit id="f59151a8263819bcee18e653895495499c38cf8b" translate="yes" xml:space="preserve">
          <source>The underlying connector library used by Sequelize for MSSQL is the &lt;a href=&quot;https://www.npmjs.com/package/tedious&quot;&gt;tedious&lt;/a&gt; npm package (version 6.0.0 or above).</source>
          <target state="translated">Sequelize for MSSQL에서 사용하는 기본 커넥터 라이브러리는 &lt;a href=&quot;https://www.npmjs.com/package/tedious&quot;&gt;지루한&lt;/a&gt; npm 패키지 (버전 6.0.0 이상)입니다.</target>
        </trans-unit>
        <trans-unit id="e7207b0378afe396e6f5e35ca21157ffa224f40f" translate="yes" xml:space="preserve">
          <source>The underlying connector library used by Sequelize for MariaDB is the &lt;a href=&quot;https://www.npmjs.com/package/mariadb&quot;&gt;mariadb&lt;/a&gt; npm package.</source>
          <target state="translated">Sequelize for MariaDB에서 사용하는 기본 커넥터 라이브러리는 &lt;a href=&quot;https://www.npmjs.com/package/mariadb&quot;&gt;mariadb&lt;/a&gt; npm 패키지입니다.</target>
        </trans-unit>
        <trans-unit id="3e59f55b7e30b0277f55f16d71c8f1982e4cf5bf" translate="yes" xml:space="preserve">
          <source>The underlying connector library used by Sequelize for MySQL is the &lt;a href=&quot;https://www.npmjs.com/package/mysql2&quot;&gt;mysql2&lt;/a&gt; npm package (version 1.5.2 or higher).</source>
          <target state="translated">Sequelize for MySQL에서 사용하는 기본 커넥터 라이브러리는 &lt;a href=&quot;https://www.npmjs.com/package/mysql2&quot;&gt;mysql2&lt;/a&gt; npm 패키지 (버전 1.5.2 이상)입니다.</target>
        </trans-unit>
        <trans-unit id="c14bdccd980afd199675aec517c9b3d8aeb09fba" translate="yes" xml:space="preserve">
          <source>The underlying connector library used by Sequelize for PostgreSQL is the &lt;a href=&quot;https://www.npmjs.com/package/pg&quot;&gt;pg&lt;/a&gt; npm package (version 7.0.0 or above). The module &lt;a href=&quot;https://www.npmjs.com/package/pg-hstore&quot;&gt;pg-hstore&lt;/a&gt; is also necessary.</source>
          <target state="translated">Sequelize for PostgreSQL에서 사용하는 기본 커넥터 라이브러리는 &lt;a href=&quot;https://www.npmjs.com/package/pg&quot;&gt;pg&lt;/a&gt; npm 패키지 (버전 7.0.0 이상)입니다. &lt;a href=&quot;https://www.npmjs.com/package/pg-hstore&quot;&gt;pg-hstore&lt;/a&gt; 모듈 도 필요합니다.</target>
        </trans-unit>
        <trans-unit id="73c7fb73bb882721d7262d6fcfc253158b6dccc1" translate="yes" xml:space="preserve">
          <source>The underlying connector library used by Sequelize for SQLite is the &lt;a href=&quot;https://www.npmjs.com/package/sqlite3&quot;&gt;sqlite3&lt;/a&gt; npm package (version 4.0.0 or above).</source>
          <target state="translated">Sequelize for SQLite에서 사용하는 기본 커넥터 라이브러리는 &lt;a href=&quot;https://www.npmjs.com/package/sqlite3&quot;&gt;sqlite3&lt;/a&gt; npm 패키지 (버전 4.0.0 이상)입니다.</target>
        </trans-unit>
        <trans-unit id="09404a13c8e60b446036809cf1059fb671f5a97e" translate="yes" xml:space="preserve">
          <source>The usage of &lt;code&gt;Model.bulkCreate&lt;/code&gt; is very similar to &lt;code&gt;Model.create&lt;/code&gt;, by receiving an array of objects instead of a single object.</source>
          <target state="translated">&lt;code&gt;Model.bulkCreate&lt;/code&gt; 의 사용법은 단일 객체 대신 객체 배열을 수신함으로써 &lt;code&gt;Model.create&lt;/code&gt; 와 매우 유사 합니다.</target>
        </trans-unit>
        <trans-unit id="5888d90beb856504f26606caf21620cfa8966739" translate="yes" xml:space="preserve">
          <source>The username which is used to authenticate against the database.</source>
          <target state="translated">데이터베이스를 인증하는 데 사용되는 사용자 이름입니다.</target>
        </trans-unit>
        <trans-unit id="ef65704c728b311b6675bea469007ef92576b56c" translate="yes" xml:space="preserve">
          <source>The value for the default constraint</source>
          <target state="translated">기본 구속 조건의 값</target>
        </trans-unit>
        <trans-unit id="87fb8dc5fc6bc1f9c662d78e53814299d9b4d67e" translate="yes" xml:space="preserve">
          <source>The value of the desired instance's primary key.</source>
          <target state="translated">원하는 인스턴스의 기본 키 값입니다.</target>
        </trans-unit>
        <trans-unit id="2e4d8e128c9a5a1ffd3c715a791ace7b6e2f0e51" translate="yes" xml:space="preserve">
          <source>The value that generated the error</source>
          <target state="translated">오류를 생성 한 값</target>
        </trans-unit>
        <trans-unit id="281466e75fbe944a95c1f47673ac3a4b4a7aac99" translate="yes" xml:space="preserve">
          <source>The value to cast</source>
          <target state="translated">캐스트 할 가치</target>
        </trans-unit>
        <trans-unit id="4becd373a9abdf90daf7afd7952190cfbdb6a722" translate="yes" xml:space="preserve">
          <source>The values of the attempted update</source>
          <target state="translated">시도한 업데이트의 값</target>
        </trans-unit>
        <trans-unit id="8879fe3df52b3bfc453dc46fb7061554a846b88a" translate="yes" xml:space="preserve">
          <source>Then you can just expose file with proper environment variables.</source>
          <target state="translated">그런 다음 적절한 환경 변수로 파일을 노출시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ab3d76e9b6d1f1dba9900a24878ef166a440a83" translate="yes" xml:space="preserve">
          <source>Then, Sequelize will execute the callback you provided, passing &lt;code&gt;t&lt;/code&gt; into it</source>
          <target state="translated">그런 다음 Sequelize는 제공 한 콜백을 실행하여 &lt;code&gt;t&lt;/code&gt; 를 전달 합니다.</target>
        </trans-unit>
        <trans-unit id="43f2635dbec46649203b3c3aa4d04bf38df84e6b" translate="yes" xml:space="preserve">
          <source>There are currently three ways to programmatically add hooks:</source>
          <target state="translated">프로그래밍 방식으로 후크를 추가하는 세 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="64efa8d929a0e387fda225dc8dd14691e1dd9946" translate="yes" xml:space="preserve">
          <source>There are four cases to consider:</source>
          <target state="translated">고려해야 할 네 가지 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="851baae215836b6fa57898e6c599ad9d98cb1e76" translate="yes" xml:space="preserve">
          <source>There are other data types, covered in a &lt;a href=&quot;other-data-types&quot;&gt;separate guide&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;other-data-types&quot;&gt;별도의 가이드&lt;/a&gt; 에서 다루는 다른 데이터 유형이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6c7e03a8c32ed1f6358530c8e620ba1250325a0a" translate="yes" xml:space="preserve">
          <source>There are several ways to update and add new associations. Continuing with our example of users and pictures:</source>
          <target state="translated">새 연결을 업데이트하고 추가하는 방법에는 여러 가지가 있습니다. 사용자와 사진의 예를 계속하십시오.</target>
        </trans-unit>
        <trans-unit id="a36b1d5200c1e31ac985860d6dd0f09141f565f9" translate="yes" xml:space="preserve">
          <source>There are three types of storage that you can use: &lt;code&gt;sequelize&lt;/code&gt;, &lt;code&gt;json&lt;/code&gt;, and &lt;code&gt;none&lt;/code&gt;.</source>
          <target state="translated">사용할 수있는 세 가지 유형의 스토리지가 있습니다 : &lt;code&gt;sequelize&lt;/code&gt; , &lt;code&gt;json&lt;/code&gt; 및 &lt;code&gt;none&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7925550eb88bb7fc701946fe22cacc5eac7b4285" translate="yes" xml:space="preserve">
          <source>There are three ways to specify a different name for the foreign key:</source>
          <target state="translated">외래 키에 대해 다른 이름을 지정하는 세 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="27fdccefc377e17f5a26fc7558b9e7867964fb5d" translate="yes" xml:space="preserve">
          <source>There is also a method for counting database objects:</source>
          <target state="translated">데이터베이스 객체를 계산하는 방법도 있습니다 :</target>
        </trans-unit>
        <trans-unit id="cd8a91416dbf4cf3a9c701869ca2f37c200a92ff" translate="yes" xml:space="preserve">
          <source>There may be times when you want to generate your own UUID conforming to some other algorithm. This is accomplished using the defaultValue property as well, but instead of specifying one of the supplied UUID types, you return a value from a function.</source>
          <target state="translated">다른 알고리즘에 맞는 고유 한 UUID를 생성하려는 경우가 있습니다. defaultValue 속성도 사용하지만 제공된 UUID 유형 중 하나를 지정하는 대신 함수에서 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="55682363d7e0f2ffc9293ceaaddad46cafb5c483" translate="yes" xml:space="preserve">
          <source>Therefore, one can just follow the &lt;a href=&quot;http://geojson.org/geojson-spec.html&quot;&gt;GeoJSON spec&lt;/a&gt; for handling geometry objects. See the following examples:</source>
          <target state="translated">따라서 &lt;a href=&quot;http://geojson.org/geojson-spec.html&quot;&gt;GeoJSON 사양&lt;/a&gt; 을 따라 지오메트리 객체를 처리 할 수 있습니다 . 다음 예를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0962924cd772632d3a79d10d697dfb40d33618c5" translate="yes" xml:space="preserve">
          <source>Therefore, to bring full power to Sequelize usage, we usually setup the relationship in pairs, so that both models get to &lt;em&gt;know about it&lt;/em&gt;.</source>
          <target state="translated">따라서 Sequelize 사용에 모든 권한을 부여하기 위해 일반적으로 관계를 쌍으로 설정하여 두 모델이 이에 대해 &lt;em&gt;알&lt;/em&gt; 수 있도록 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="2657c1f39eeba3b792575763601c104e3c91a0f9" translate="yes" xml:space="preserve">
          <source>These are the main ideas involved in each type of association. However, these relationships are often used in pairs, in order to enable better usage with Sequelize. This will be seen later on.</source>
          <target state="translated">이들은 각 유형의 협회에 관련된 주요 아이디어입니다. 그러나 이러한 관계는 Sequelize에서 더 나은 사용을 가능하게하기 위해 종종 쌍으로 사용됩니다. 이것은 나중에 볼 것입니다.</target>
        </trans-unit>
        <trans-unit id="02cc698e9e580c5b08002ced8ca01c4ddd96bbfc" translate="yes" xml:space="preserve">
          <source>These four scopes can be deeply merged easily, for example by calling &lt;code&gt;Foo.scope('includeEverything', 'limitedBars', 'limitedBazs', 'excludeBazName').findAll()&lt;/code&gt;, which would be entirely equivalent to calling the following:</source>
          <target state="translated">이 네 가지 범위는 &lt;code&gt;Foo.scope('includeEverything', 'limitedBars', 'limitedBazs', 'excludeBazName').findAll()&lt;/code&gt; 을 호출하여 쉽게 병합 할 수 있습니다 . 이는 다음을 호출하는 것과 완전히 같습니다.</target>
        </trans-unit>
        <trans-unit id="af59fc7567d7e359f06c4a1e994f367061e3a2b5" translate="yes" xml:space="preserve">
          <source>These hooks can be useful if you need to asynchronously obtain database credentials, or need to directly access the low-level database connection after it has been created.</source>
          <target state="translated">이 후크는 데이터베이스 신임 정보를 비동기 적으로 확보해야하거나 저수준 데이터베이스 연결이 작성된 후 직접 액세스해야하는 경우 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c2d955f8a133fd17bc66cfb7a3733b5cd31863d" translate="yes" xml:space="preserve">
          <source>These hooks may &lt;em&gt;only&lt;/em&gt; be declared as a permanent global hook, as the connection pool is shared by all models.</source>
          <target state="translated">연결 풀은 모든 모델에서 공유 &lt;em&gt;되므로&lt;/em&gt; 이러한 후크는 영구 전역 후크 &lt;em&gt;로만&lt;/em&gt; 선언 될 &lt;em&gt;수&lt;/em&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c389d6b65a20f268408819e6a860c1a7c78109f" translate="yes" xml:space="preserve">
          <source>These options are merged with the default define options provided to the Sequelize constructor</source>
          <target state="translated">이러한 옵션은 Sequelize 생성자에 제공된 기본 정의 옵션과 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="5c4f7d575b88a1fe31445dc78190b51d6048577f" translate="yes" xml:space="preserve">
          <source>These options are merged with the default define options provided to the Sequelize constructor and passed to Model.init()</source>
          <target state="translated">이러한 옵션은 Sequelize 생성자에 제공된 기본 정의 옵션과 병합되어 Model.init ()에 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="c4e9b53fba404e3735d3402a42588fc4e405cb17" translate="yes" xml:space="preserve">
          <source>These scopes are automatically applied when using the association functions (as explained in the &lt;a href=&quot;association-scopes&quot;&gt;Association Scopes&lt;/a&gt; guide). Some examples are below, with their generated SQL statements:</source>
          <target state="translated">이러한 범위는 연결 기능을 사용할 때 자동으로 적용됩니다 ( &lt;a href=&quot;association-scopes&quot;&gt;연결 범위&lt;/a&gt; 가이드에 설명 됨 ). 다음은 생성 된 SQL 문과 함께 몇 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="ae91c6724ff8d4a935d5cec193d3468b859c4a2b" translate="yes" xml:space="preserve">
          <source>These scopes are automatically applied when using the association functions. Some examples are below, with their generated SQL statements:</source>
          <target state="translated">이러한 범위는 연관 함수를 사용할 때 자동으로 적용됩니다. 다음은 생성 된 SQL 문과 함께 몇 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="233a7442b9d2f7ba3bc0234cc5de52888d02b14b" translate="yes" xml:space="preserve">
          <source>These three calls will cause Sequelize to automatically add foreign keys to the appropriate models (unless they are already present).</source>
          <target state="translated">이 세 가지 호출로 인해 Sequelize는 적절한 모델에 외래 키를 자동으로 추가합니다 (이미 존재하지 않는 한).</target>
        </trans-unit>
        <trans-unit id="efc3f625365404331c93e5af548228569c63e68d" translate="yes" xml:space="preserve">
          <source>They all accept an options object as a second parameter (optional for the first three, mandatory for &lt;code&gt;belongsToMany&lt;/code&gt; containing at least the &lt;code&gt;through&lt;/code&gt; property):</source>
          <target state="translated">모두 옵션 객체를 두 번째 매개 변수로 허용합니다 (처음 3 개에 대해 선택 사항, 적어도 &lt;code&gt;through&lt;/code&gt; 속성을 포함하는 &lt;code&gt;belongsToMany&lt;/code&gt; 에 필수 ) :</target>
        </trans-unit>
        <trans-unit id="5072453b0e64084c89bc87592d919214af9d10e1" translate="yes" xml:space="preserve">
          <source>Third, you can define an object containing fields and its decrement values.</source>
          <target state="translated">셋째, 필드와 그 감소 값을 포함하는 개체를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bcc27019080f65da23ea2d1c9787f788f23d98f5" translate="yes" xml:space="preserve">
          <source>Third, you can define an object containing fields and its increment values.</source>
          <target state="translated">셋째, 필드와 증분 값을 포함하는 객체를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e0152b992d8dcce6cbd8bc1cda5d54dde247ffb" translate="yes" xml:space="preserve">
          <source>This adds a default hook to all models, which is run if the model does not define its own &lt;code&gt;beforeCreate&lt;/code&gt; hook:</source>
          <target state="translated">이렇게하면 모든 모델에 기본 후크가 추가됩니다. 이는 모델이 자체 &lt;code&gt;beforeCreate&lt;/code&gt; 후크를 정의하지 않은 경우 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="487b5e71bbadbf2ea46d80c788e9c588cc7bec5d" translate="yes" xml:space="preserve">
          <source>This automatically added the columns &lt;code&gt;userId&lt;/code&gt; and &lt;code&gt;profileId&lt;/code&gt; to the &lt;code&gt;Grant&lt;/code&gt; model.</source>
          <target state="translated">그러면 자동으로 &lt;code&gt;userId&lt;/code&gt; 및 &lt;code&gt;profileId&lt;/code&gt; 열 이 &lt;code&gt;Grant&lt;/code&gt; 모델에 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="f7b5d866c9de484085dd494f29a298183012d8fc" translate="yes" xml:space="preserve">
          <source>This behavior can also be defined globally for the sequelize instance, when it is created:</source>
          <target state="translated">이 동작은 생성 될 때 sequelize 인스턴스에 대해 전역 적으로 정의 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="216b7d73d757eab64d8e7ed7575c6622b9965774" translate="yes" xml:space="preserve">
          <source>This behavior can be disabled for a model with the &lt;code&gt;timestamps: false&lt;/code&gt; option:</source>
          <target state="translated">&lt;code&gt;timestamps: false&lt;/code&gt; 옵션 을 사용하여 모델에 대해이 동작을 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="727c4075b5f4eb6d72cffa60b8be8ca9040e313f" translate="yes" xml:space="preserve">
          <source>This can be simply solved by passing &lt;code&gt;{individualHooks: true}&lt;/code&gt; to the &lt;code&gt;remove&lt;/code&gt; call, resulting on each hook to be called on each removed through instance object.</source>
          <target state="translated">&lt;code&gt;{individualHooks: true}&lt;/code&gt; 를 &lt;code&gt;remove&lt;/code&gt; 호출 에 전달하여 간단하게 해결할 수 있으므로 인스턴스 객체를 통해 제거 될 때마다 각 후크가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="9621cbd1b47ad9deb220744f9dce81dd8d65111e" translate="yes" xml:space="preserve">
          <source>This can be worked around by passing in Meteor's version of &lt;code&gt;require&lt;/code&gt;:</source>
          <target state="translated">이것은 Meteor의 &lt;code&gt;require&lt;/code&gt; 버전을 전달하여 해결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="993d81e082a59058624430b6ff3db0bad0ed5e93" translate="yes" xml:space="preserve">
          <source>This cannot be represented by adding one foreign key to one of the tables, like the other relationships did. Instead, the concept of a &lt;a href=&quot;https://en.wikipedia.org/wiki/Associative_entity&quot;&gt;Junction Model&lt;/a&gt; is used. This will be an extra model (and extra table in the database) which will have two foreign key columns and will keep track of the associations. The junction table is also sometimes called &lt;em&gt;join table&lt;/em&gt; or &lt;em&gt;through table&lt;/em&gt;.</source>
          <target state="translated">이것은 다른 관계처럼 테이블 중 하나에 하나의 외래 키를 추가하여 나타낼 수 없습니다. 대신 &lt;a href=&quot;https://en.wikipedia.org/wiki/Associative_entity&quot;&gt;접합 모델&lt;/a&gt; 의 개념 이 사용됩니다. 이것은 두 개의 외래 키 열이 있고 연관을 추적하는 추가 모델 (및 데이터베이스의 추가 테이블)이됩니다. 접합 테이블은 &lt;em&gt;조인 테이블&lt;/em&gt; 또는 &lt;em&gt;스루 테이블&lt;/em&gt; 이라고도 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="ec6669863e6675ad0919f094fdb2f5f5591e0c18" translate="yes" xml:space="preserve">
          <source>This code will run &lt;code&gt;beforeDestroy&lt;/code&gt; and &lt;code&gt;afterDestroy&lt;/code&gt; hooks on the Tasks model.</source>
          <target state="translated">이 코드는 Tasks 모델에서 &lt;code&gt;beforeDestroy&lt;/code&gt; 및 &lt;code&gt;afterDestroy&lt;/code&gt; 후크를 실행 합니다.</target>
        </trans-unit>
        <trans-unit id="e7dd309e7a42d2a5b7a13fba0fcf976b9b08e4f8" translate="yes" xml:space="preserve">
          <source>This code will run beforeDestroy/afterDestroy on the Tasks table. Sequelize, by default, will try to optimize your queries as much as possible. When calling cascade on delete, Sequelize will simply execute a</source>
          <target state="translated">이 코드는 작업 테이블에서 beforeDestroy / afterDestroy를 실행합니다. Sequelize는 기본적으로 쿼리를 최대한 최적화하려고 시도합니다. 삭제시 캐스케이드를 호출하면 Sequelize는 단순히</target>
        </trans-unit>
        <trans-unit id="18c9fea6466ac62731b3270babfae248a5a4f00c" translate="yes" xml:space="preserve">
          <source>This command will create a seed file in &lt;code&gt;seeders&lt;/code&gt; folder. File name will look something like &lt;code&gt;XXXXXXXXXXXXXX-demo-user.js&lt;/code&gt;. It follows the same &lt;code&gt;up / down&lt;/code&gt; semantics as the migration files.</source>
          <target state="translated">이 명령은 &lt;code&gt;seeders&lt;/code&gt; 폴더에 seed 파일을 작성 합니다. 파일 이름은 &lt;code&gt;XXXXXXXXXXXXXX-demo-user.js&lt;/code&gt; 와 비슷 합니다. 마이그레이션 파일 과 동일한 &lt;code&gt;up / down&lt;/code&gt; 시맨틱을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="99b346a29a6d16c0ff1ed00bc189c11d20ca7b4d" translate="yes" xml:space="preserve">
          <source>This command will execute these steps:</source>
          <target state="translated">이 명령은 다음 단계를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="c63d621f524bac03f030a99ca6604e6cf1edd0b4" translate="yes" xml:space="preserve">
          <source>This example will return an error:</source>
          <target state="translated">이 예제는 오류를 반환합니다 :</target>
        </trans-unit>
        <trans-unit id="3b53b33ba4457b7ea3b90f1c2c5486da5f391e81" translate="yes" xml:space="preserve">
          <source>This extra capability is useful when, for example, &lt;code&gt;Error: Cannot find module&lt;/code&gt; is thrown even though &lt;code&gt;/path/to/models/project&lt;/code&gt; seems to be correct. Some frameworks, such as Meteor, overload &lt;code&gt;require&lt;/code&gt;, and might raise an error such as:</source>
          <target state="translated">이 추가 기능은 예를 들어 &lt;code&gt;Error: Cannot find module&lt;/code&gt; &lt;code&gt;/path/to/models/project&lt;/code&gt; 가 올바른 것처럼 보임 에도 불구하고 오류 : 모듈을 찾을 수 없음 이 발생하는 경우 에 유용합니다. Meteor와 같은 일부 프레임 워크는 오버로드가 &lt;code&gt;require&lt;/code&gt; 하며 다음과 같은 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a7c83b5a5af156c9b822efe6ff13494455e205c" translate="yes" xml:space="preserve">
          <source>This extra capability is useful when, for example, &lt;code&gt;Error: Cannot find module&lt;/code&gt; is thrown even though &lt;code&gt;/path/to/models/project&lt;/code&gt; seems to be correct. Some frameworks, such as Meteor, overload &lt;code&gt;require&lt;/code&gt;, and spit out &quot;surprise&quot; results like :</source>
          <target state="translated">예를 들어, 때, 이러한 추가 기능은 유용 &lt;code&gt;Error: Cannot find module&lt;/code&gt; 비록 발생합니다 &lt;code&gt;/path/to/models/project&lt;/code&gt; 올바른 것 같다. Meteor와 같은 일부 프레임 워크에는 과부하가 &lt;code&gt;require&lt;/code&gt; 하며 다음과 같은 &quot;놀라운&quot;결과를 내뱉습니다.</target>
        </trans-unit>
        <trans-unit id="907fa0809383b5e3d81bdbb7a5c0b6310da2999e" translate="yes" xml:space="preserve">
          <source>This getter, just like a standard JavaScript getter, is called automatically when the field value is read:</source>
          <target state="translated">이 getter는 표준 JavaScript getter와 마찬가지로 필드 값을 읽을 때 자동으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="9265e86754519dfd2a1c613c8e8e21f4bd913ce3" translate="yes" xml:space="preserve">
          <source>This guide concerns model scopes. You might also be interested in the &lt;a href=&quot;association-scopes&quot;&gt;guide for association scopes&lt;/a&gt;, which are similar but not the same thing.</source>
          <target state="translated">이 가이드는 모델 범위에 관한 것입니다. 유사하지만 같지는 않은 &lt;a href=&quot;association-scopes&quot;&gt;연관 범위 가이드에&lt;/a&gt; 관심이있을 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b7d24c35d97d5d3b68e3c54495e89f88afd8e636" translate="yes" xml:space="preserve">
          <source>This guide shows a few examples, but for the full list of what it can do, and for detailed usage of each method, check the &lt;a href=&quot;../class/lib/dialects/abstract/query-interface.js~queryinterface&quot;&gt;QueryInterface API&lt;/a&gt;.</source>
          <target state="translated">이 가이드는 몇 가지 예를 보여 주지만, 수행 할 수있는 작업의 전체 목록과 각 메서드의 자세한 사용법은 &lt;a href=&quot;../class/lib/dialects/abstract/query-interface.js~queryinterface&quot;&gt;QueryInterface API를&lt;/a&gt; 확인하세요 .</target>
        </trans-unit>
        <trans-unit id="7211d11ae325ad374896d8957148935533ed77b2" translate="yes" xml:space="preserve">
          <source>This guide will show how to make the standard &lt;a href=&quot;https://en.wikipedia.org/wiki/Create,_read,_update_and_delete&quot;&gt;CRUD&lt;/a&gt; queries.</source>
          <target state="translated">이 가이드는 표준 &lt;a href=&quot;https://en.wikipedia.org/wiki/Create,_read,_update_and_delete&quot;&gt;CRUD&lt;/a&gt; 쿼리 를 만드는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="ce7f17201e64eb37f1103f4b3786c11feb4123ee" translate="yes" xml:space="preserve">
          <source>This hook is always run before create, regardless of whether the model specifies its own &lt;code&gt;beforeCreate&lt;/code&gt; hook. Local hooks are always run before global hooks:</source>
          <target state="translated">이 후크는 모델이 고유 한 &lt;code&gt;beforeCreate&lt;/code&gt; 후크를 지정하는지 여부에 관계없이 항상 작성 전에 실행 됩니다. 로컬 후크는 항상 글로벌 후크보다 먼저 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="1ddcce083be9075cd769a5196a4450f737832ece" translate="yes" xml:space="preserve">
          <source>This hook is always run, whether or not the model specifies its own &lt;code&gt;beforeCreate&lt;/code&gt; hook. Local hooks are always run before global hooks:</source>
          <target state="translated">이 후크는 모델이 자신의 &lt;code&gt;beforeCreate&lt;/code&gt; 후크를 지정하는지 여부에 관계없이 항상 실행 됩니다. 로컬 후크는 항상 전역 후크보다 먼저 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="3cc51172f00acfbe9c8689825993faf2062e625a" translate="yes" xml:space="preserve">
          <source>This idea can be applied recursively for even more complex, &lt;em&gt;many-to-many-to-...-to-many&lt;/em&gt; relationships (although at some point queries might become slow).</source>
          <target state="translated">이 아이디어는 훨씬 더 복잡한 &lt;em&gt;다대 다대 ... 대다&lt;/em&gt; 관계에 대해 재귀 적으로 적용될 수 있습니다 (일부 쿼리가 느려질 수 있음).</target>
        </trans-unit>
        <trans-unit id="2d3f840b5f4bf63477dd8bfd4cce62416778f4f4" translate="yes" xml:space="preserve">
          <source>This idea can be used to enable complex ordering, such as ordering posts by the number of laugh reactions they have:</source>
          <target state="translated">이 아이디어는 웃음 반응의 수에 따라 게시물을 정렬하는 것과 같이 복잡한 정렬을 가능하게하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="360cb791231c2363b1194e7b256c83b51766b491" translate="yes" xml:space="preserve">
          <source>This is a convenience method that combines&lt;code&gt;findAll&lt;/code&gt; and &lt;code&gt;count&lt;/code&gt; (see below) this is useful when dealing with queries related to pagination where you want to retrieve data with a &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;offset&lt;/code&gt; but also need to know the total number of records that match the query:</source>
          <target state="translated">이것은 &lt;code&gt;findAll&lt;/code&gt; 과 &lt;code&gt;count&lt;/code&gt; (아래 참조) 를 결합한 편리한 방법 으로, &lt;code&gt;limit&lt;/code&gt; 및 &lt;code&gt;offset&lt;/code&gt; 데이터를 검색하려고 하지만 쿼리와 일치하는 총 레코드 수를 알아야하는 페이지 매김 관련 쿼리를 처리 할 때 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="0e6e7c29c6f7275c747733e61664e0b1a268e99f" translate="yes" xml:space="preserve">
          <source>This is a special configuration file. It lets you specify following options that you would usually pass as arguments to CLI:</source>
          <target state="translated">이것은 특수 구성 파일입니다. 일반적으로 CLI에 인수로 전달할 다음 옵션을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0099c6210179459209b502d4b861e1c0160333c" translate="yes" xml:space="preserve">
          <source>This is a special configuration file. It lets you specify the following options that you would usually pass as arguments to CLI:</source>
          <target state="translated">이것은 특수 구성 파일입니다. 일반적으로 CLI에 인수로 전달하는 다음 옵션을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9cfb87b363ada14a57aea2606ebe70602e596443" translate="yes" xml:space="preserve">
          <source>This is better understood with examples.</source>
          <target state="translated">이것은 예를 통해 더 잘 이해됩니다.</target>
        </trans-unit>
        <trans-unit id="55bdb2f2ecde4b760da3d764aa2f4098da22b6d1" translate="yes" xml:space="preserve">
          <source>This is solved by passing in Meteor's version of &lt;code&gt;require&lt;/code&gt;. So, while this probably fails ...</source>
          <target state="translated">이것은 Meteor의 &lt;code&gt;require&lt;/code&gt; 버전을 전달함으로써 해결됩니다 . 따라서 이것이 실패하는 동안 ...</target>
        </trans-unit>
        <trans-unit id="d228ea5a39b7651eb309d93cc8036fdcc5148f0e" translate="yes" xml:space="preserve">
          <source>This is the main class, the entry point to sequelize.</source>
          <target state="translated">이것이 주요 클래스이며, 시퀀싱 할 진입 점입니다.</target>
        </trans-unit>
        <trans-unit id="818eb257f30469f3bc2e4ca907767013465c744e" translate="yes" xml:space="preserve">
          <source>This is the same as calling &lt;code&gt;set&lt;/code&gt; and then calling &lt;code&gt;save&lt;/code&gt; but it only saves the exact values passed to it, making it more atomic and safer.</source>
          <target state="translated">이것은 &lt;code&gt;set&lt;/code&gt; 호출 후 &lt;code&gt;save&lt;/code&gt; 호출과 동일 하지만 전달 된 정확한 값만 저장하므로보다 원자적이고 안전합니다.</target>
        </trans-unit>
        <trans-unit id="d47fc8689698049d39e34b7df3673e10961e88f3" translate="yes" xml:space="preserve">
          <source>This is useful when you set attributes based on a previously defined object, for example, when you get the values of an object via a form of a web app. Furthermore, this is used internally in the &lt;code&gt;update&lt;/code&gt; implementation. This is how it looks like:</source>
          <target state="translated">이는 예를 들어 웹 앱의 양식을 통해 개체의 값을 가져올 때와 같이 이전에 정의 된 개체를 기반으로 속성을 설정할 때 유용합니다. 또한 이것은 &lt;code&gt;update&lt;/code&gt; 구현 에서 내부적으로 사용됩니다 . 다음과 같이 보입니다.</target>
        </trans-unit>
        <trans-unit id="aabf0ce799013e2b93cba8ead03220d19f1872eb" translate="yes" xml:space="preserve">
          <source>This is where model synchronization comes in. A model can be synchronized with the database by calling &lt;a href=&quot;../class/lib/model.js~model#static-method-sync&quot;&gt;&lt;code&gt;model.sync(options)&lt;/code&gt;&lt;/a&gt;, an asynchronous function (that returns a Promise). With this call, Sequelize will automatically perform an SQL query to the database. Note that this changes only the table in the database, not the model in the JavaScript side.</source>
          <target state="translated">여기서 모델 동기화가 시작됩니다. 모델은 Promise를 반환하는 비동기 함수 인 &lt;a href=&quot;../class/lib/model.js~model#static-method-sync&quot;&gt; &lt;code&gt;model.sync(options)&lt;/code&gt; &lt;/a&gt; 를 호출하여 데이터베이스와 동기화 할 수 있습니다 . 이 호출을 통해 Sequelize는 데이터베이스에 대한 SQL 쿼리를 자동으로 수행합니다. 이렇게하면 JavaScript 측의 모델이 아닌 데이터베이스의 테이블 만 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="33e9689bec63a24dc0d02c35280b1fc82652539b" translate="yes" xml:space="preserve">
          <source>This means that Sequelize will help you with the main, larger query, but you will still have to write that sub-query by yourself:</source>
          <target state="translated">즉, Sequelize는 더 큰 기본 쿼리에 도움이되지만 여전히 해당 하위 쿼리를 직접 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="60296b6b0d7e855566b012be2c4526118c0d9f5e" translate="yes" xml:space="preserve">
          <source>This means that errors can be accessed using &lt;code&gt;Sequelize.ValidationError&lt;/code&gt; The Base Error all Sequelize Errors inherit from.</source>
          <target state="translated">이는 &lt;code&gt;Sequelize.ValidationError&lt;/code&gt; 를 사용하여 오류에 액세스 할 수 있음을 의미합니다 . 모든 Sequelize 오류에서 상속 된 기본 오류입니다.</target>
        </trans-unit>
        <trans-unit id="98e90703d8694f860162b50810b21b9208a7afc7" translate="yes" xml:space="preserve">
          <source>This means that if you call &lt;code&gt;Comment.findAll({ include: Video })&lt;/code&gt; in the situation above, &lt;code&gt;Video X&lt;/code&gt; will be eager loaded into &lt;code&gt;Foo&lt;/code&gt;. Thankfully, our &lt;code&gt;afterFind&lt;/code&gt; hook will delete it automatically, to help prevent bugs, but regardless it is important that you understand what is going on.</source>
          <target state="translated">즉 , 위 상황에서 &lt;code&gt;Comment.findAll({ include: Video })&lt;/code&gt; 을 호출하면 &lt;code&gt;Video X&lt;/code&gt; 가 &lt;code&gt;Foo&lt;/code&gt; 에 즉시로드됩니다 . 고맙게도 &lt;code&gt;afterFind&lt;/code&gt; 후크는 버그를 방지하기 위해 자동으로 삭제하지만, 무슨 일이 일어나고 있는지 이해하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="9f0fce06b40f9255412fdd0b5380181fe69646f3" translate="yes" xml:space="preserve">
          <source>This means that paranoid tables perform a &lt;em&gt;soft-deletion&lt;/em&gt; of records, instead of a &lt;em&gt;hard-deletion&lt;/em&gt;.</source>
          <target state="translated">이는 편집증 테이블 이 &lt;em&gt;하드 삭제&lt;/em&gt; 대신 레코드 의 &lt;em&gt;소프트 삭제&lt;/em&gt; 를 수행함을 의미합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f42e97edd894c347aca69f1798c8fc463406eb50" translate="yes" xml:space="preserve">
          <source>This means that, for example, the &lt;code&gt;findAll&lt;/code&gt; method will not see the soft-deleted records, fetching only the ones that were not deleted.</source>
          <target state="translated">즉, 예를 들어 &lt;code&gt;findAll&lt;/code&gt; 메서드는 일시 삭제 된 레코드를 보지 않고 삭제되지 않은 레코드 만 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="2855bd0c683de474c7f6e21e91a0636e89800625" translate="yes" xml:space="preserve">
          <source>This means that, unlike the One-To-One association, in which we had to choose where the foreign key would be placed, there is only one option in One-To-Many associations. For example, if one Foo has many Bars (and this way each Bar belongs to one Foo), then the only sensible implementation is to have a &lt;code&gt;fooId&lt;/code&gt; column in the &lt;code&gt;Bar&lt;/code&gt; table. The opposite is impossible, since one Foo has many Bars.</source>
          <target state="translated">즉, 외래 키를 배치 할 위치를 선택해야하는 일대일 연결과 달리 일대 다 연결에는 하나의 옵션 만 있습니다. 예를 들어, 하나의 Foo에 많은 Bar가있는 경우 (이렇게하면 각 Bar가 하나의 Foo에 속함), 유일한 현명한 구현은 &lt;code&gt;Bar&lt;/code&gt; 테이블 에 &lt;code&gt;fooId&lt;/code&gt; 열을 갖는 것 입니다. 하나의 Foo에는 많은 막대가 있기 때문에 그 반대는 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="448935a1c8176ac36ebc22b0c9a61a4f6c534df7" translate="yes" xml:space="preserve">
          <source>This means you can, for instance, have a string field which validates its length to be between 5 and 10 characters, but which also allows &lt;code&gt;null&lt;/code&gt; (since the length validator will be skipped automatically when the value is &lt;code&gt;null&lt;/code&gt;):</source>
          <target state="translated">즉, 예를 들어 길이가 5 ~ 10 자 사이인지 유효성을 검사하지만 &lt;code&gt;null&lt;/code&gt; 을 허용하는 문자열 필드를 가질 수 있습니다 (값이 &lt;code&gt;null&lt;/code&gt; 일 때 길이 유효성 검사기가 자동으로 건너 뛰기 때문에 ).</target>
        </trans-unit>
        <trans-unit id="f467b722eea19d74de979567087d7f5e134044a3" translate="yes" xml:space="preserve">
          <source>This merge strategy also works in the exact same way with options passed to &lt;code&gt;.findAll&lt;/code&gt;, &lt;code&gt;.findOne&lt;/code&gt; and the like.</source>
          <target state="translated">이 병합 전략은 &lt;code&gt;.findAll&lt;/code&gt; , &lt;code&gt;.findOne&lt;/code&gt; 등에 전달 된 옵션과 동일한 방식으로 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="59bd238f74715c77711ae06cecfc32b0565a57cb" translate="yes" xml:space="preserve">
          <source>This method is intended for use cases where the same model is needed in multiple schemas. In such a use case it is important to call &lt;code&gt;model.schema(schema, [options]).sync()&lt;/code&gt; for each model to ensure the models are created in the correct schema.</source>
          <target state="translated">이 방법은 여러 스키마에서 동일한 모델이 필요한 사용 사례를위한 것입니다. 이러한 사용 사례 에서는 모델이 올바른 스키마로 작성되도록 각 모델에 대해 &lt;code&gt;model.schema(schema, [options]).sync()&lt;/code&gt; 를 호출하는 것이 중요합니다 .</target>
        </trans-unit>
        <trans-unit id="be1f80fe9d343d938146ba2d63357f7d78e8fc07" translate="yes" xml:space="preserve">
          <source>This method is not aware of eager loaded associations. In other words, if some other model instance (child) was eager loaded with this instance (parent), and you change something in the child, calling &lt;code&gt;save()&lt;/code&gt; will simply ignore the change that happened on the child.</source>
          <target state="translated">이 메서드는 즉시로드 된 연결을 인식하지 않습니다. 즉, 다른 모델 인스턴스 (자식)가이 인스턴스 (부모)와 함께 열심히로드되고 자식에서 무언가를 변경 한 경우 &lt;code&gt;save()&lt;/code&gt; 를 호출 하면 자식에서 발생한 변경 사항이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="c151867c187f819e3e87ed1bcb119c8d86a29723" translate="yes" xml:space="preserve">
          <source>This method is optimized to perform an UPDATE only into the fields that changed. If nothing has changed, no SQL query will be performed.</source>
          <target state="translated">이 방법은 변경된 필드에 대해서만 UPDATE를 수행하도록 최적화되어 있습니다. 변경된 사항이 없으면 SQL 쿼리가 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bbb7483536c0c6c9a13a8629a3da4e9955e25e2c" translate="yes" xml:space="preserve">
          <source>This method now only takes 2 parameters, &lt;code&gt;tableName&lt;/code&gt; and &lt;code&gt;options&lt;/code&gt;. Previously the second parameter could be a list of column names to apply the constraint to, this list must now be passed as &lt;code&gt;options.fields&lt;/code&gt; property.</source>
          <target state="translated">이 메소드는 이제 2 개의 매개 변수, &lt;code&gt;tableName&lt;/code&gt; 및 &lt;code&gt;options&lt;/code&gt; 만 사용 합니다. 이전에는 두 번째 매개 변수가 제약 조건을 적용 할 열 이름 목록이 될 수 있었지만 이제이 목록을 &lt;code&gt;options.fields&lt;/code&gt; 속성 으로 전달해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f729a85c63b02a52c94b1fda97e8d7be1a535ab0" translate="yes" xml:space="preserve">
          <source>This method now tests for equality with &lt;a href=&quot;https://lodash.com/docs/4.17.15#isEqual&quot;&gt;&lt;code&gt;_.isEqual&lt;/code&gt;&lt;/a&gt; and is now deep aware for JSON objects. Modifying a nested value for a JSON object won't mark it as changed (since it is still the same object).</source>
          <target state="translated">이 메서드 는 이제 &lt;a href=&quot;https://lodash.com/docs/4.17.15#isEqual&quot;&gt; &lt;code&gt;_.isEqual&lt;/code&gt; &lt;/a&gt; 과의 동등성을 테스트 하고 이제 JSON 개체를 심층적으로 인식합니다. JSON 개체의 중첩 된 값을 수정해도 변경된 것으로 표시되지 않습니다 (여전히 동일한 개체이므로).</target>
        </trans-unit>
        <trans-unit id="a61048d15d1fb9bb46b03055071e6483faf68341" translate="yes" xml:space="preserve">
          <source>This method now tests for equality with &lt;code&gt;_.isEqual&lt;/code&gt; and is now deep aware. Modifying nested value for JSON object won't mark them as changed, because it is still the same object.</source>
          <target state="translated">이 메소드 는 이제 &lt;code&gt;_.isEqual&lt;/code&gt; 과의 동등성을 테스트하며 이제는 깊이 인식하고 있습니다. JSON 객체의 중첩 값을 수정해도 여전히 동일한 객체이므로 변경된 것으로 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="464ce0b414d5afcf6b0aff43e9a51b07687141d9" translate="yes" xml:space="preserve">
          <source>This method now throws &lt;code&gt;Sequelize.AggregateError&lt;/code&gt; instead of &lt;code&gt;Bluebird.AggregateError&lt;/code&gt;. All errors are now exposed as &lt;code&gt;errors&lt;/code&gt; key.</source>
          <target state="translated">이 메서드는 이제 &lt;code&gt;Bluebird.AggregateError&lt;/code&gt; 대신 &lt;code&gt;Sequelize.AggregateError&lt;/code&gt; 를 발생시킵니다 . 이제 모든 오류가 &lt;code&gt;errors&lt;/code&gt; 키로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="ab79309eddccd5e656cb0c27289b25d6187e3837" translate="yes" xml:space="preserve">
          <source>This method returns an array of hashes containing information about all attributes in the table.</source>
          <target state="translated">이 메소드는 테이블의 모든 속성에 대한 정보가 포함 된 해시 배열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="65e66ab761576e0255ab452767789dbdbc633e55" translate="yes" xml:space="preserve">
          <source>This option also works on nested includes.</source>
          <target state="translated">이 옵션은 중첩 포함에서도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="cd7d5d490533d9fbbc6964ad3ca7a06ab217002b" translate="yes" xml:space="preserve">
          <source>This other field must have a unique constraint on it (otherwise, it wouldn't make sense).</source>
          <target state="translated">이 다른 필드에는 고유 한 제약 조건이 있어야합니다 (그렇지 않으면 의미가 없습니다).</target>
        </trans-unit>
        <trans-unit id="009412eb3e4926d95c68130f79ccb16709c73776" translate="yes" xml:space="preserve">
          <source>This section concerns association scopes, which are similar but not the same as &lt;a href=&quot;scopes&quot;&gt;model scopes&lt;/a&gt;.</source>
          <target state="translated">이 섹션은 &lt;a href=&quot;scopes&quot;&gt;모델 범위&lt;/a&gt; 와 유사하지만 동일하지 않은 연관 범위에 관한 것 입니다.</target>
        </trans-unit>
        <trans-unit id="d7799f45dcea4d7688e16027f4fe2c94d214d595" translate="yes" xml:space="preserve">
          <source>This section concerns association scopes. For a definition of association scopes vs. scopes on associated models, see &lt;a href=&quot;scopes&quot;&gt;Scopes&lt;/a&gt;.</source>
          <target state="translated">이 섹션은 연결 범위와 관련이 있습니다. 관련 모델 협회 범위 대 범위에 대한 정의, 참조 &lt;a href=&quot;scopes&quot;&gt;범위를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8afc09530510c13953a1c7a8aa226af2c4660e35" translate="yes" xml:space="preserve">
          <source>This section describes the various association types in sequelize. There are four types of associations available in Sequelize</source>
          <target state="translated">이 섹션에서는 다양한 연결 유형에 대해 설명합니다. Sequelize에는 4 가지 유형의 연결이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b5b1b593a3987e4e98a3ae07340e004ed7b307a" translate="yes" xml:space="preserve">
          <source>This shows that one Many-to-Many relationship isn't very different from two One-to-Many relationships. The tables in the database look the same.</source>
          <target state="translated">이것은 하나의 다 대다 관계가 두 개의 일대 다 관계와 크게 다르지 않음을 보여줍니다. 데이터베이스의 테이블은 동일하게 보입니다.</target>
        </trans-unit>
        <trans-unit id="e5db820e5273e88ea3c74abb859bd5e860f6a011" translate="yes" xml:space="preserve">
          <source>This specifies that the &lt;code&gt;uid&lt;/code&gt; column cannot be null. In most cases this will already be covered by the foreign key constraints, which sequelize creates automatically, but can be useful in case where the foreign keys are disabled, e.g. due to circular references (see &lt;code&gt;constraints: false&lt;/code&gt; below).</source>
          <target state="translated">이는 &lt;code&gt;uid&lt;/code&gt; 열이 널이 될 수 없도록 지정합니다 . 대부분의 경우이 이미 sequelize가 자동으로 생성 외래 키 제약 조건이 적용되지만, 외부 키 때문에 순환 참조로 예를 들면, 사용할 수있는 경우에 유용 할 수 있습니다 ( &lt;code&gt;constraints: false&lt;/code&gt; 아래 참조).</target>
        </trans-unit>
        <trans-unit id="9a0946bfcd13dbf21daeb65a02ff63bf523ce0c5" translate="yes" xml:space="preserve">
          <source>This was just a quick introduction to Eager Loading in Sequelize. There is a lot more to it, which you can learn at &lt;a href=&quot;eager-loading&quot;&gt;the dedicated guide on Eager Loading&lt;/a&gt;.</source>
          <target state="translated">이것은 Sequelize의 Eager Loading에 대한 간단한 소개였습니다. &lt;a href=&quot;eager-loading&quot;&gt;Eager Loading에 대한 전용 가이드에서&lt;/a&gt; 배울 수있는 더 많은 정보가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="577e6137dba84cc46407d9bc1a4765dfd3613cdc" translate="yes" xml:space="preserve">
          <source>This way your hooks will always behave correctly.</source>
          <target state="translated">이렇게하면 후크가 항상 올바르게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b3f85e151e151a349dd9016b56ab3363d40b713a" translate="yes" xml:space="preserve">
          <source>This way, all tables will use the same name as the model name.</source>
          <target state="translated">이렇게하면 모든 테이블이 모델 이름과 동일한 이름을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="243ae40eac6076baeeed9df083b7e556290eff39" translate="yes" xml:space="preserve">
          <source>This way, calling &lt;code&gt;Bar.sync()&lt;/code&gt; after the above will yield the following SQL (on PostgreSQL, for example):</source>
          <target state="translated">이런 식으로 위의 다음에 &lt;code&gt;Bar.sync()&lt;/code&gt; 호출 하면 다음 SQL이 생성됩니다 (예 : PostgreSQL에서).</target>
        </trans-unit>
        <trans-unit id="f0ebc993290aa589473ea42cd9a95506f97197b5" translate="yes" xml:space="preserve">
          <source>This way, calling &lt;code&gt;sync()&lt;/code&gt; on the above code will generate the following:</source>
          <target state="translated">이렇게 하면 위 코드에서 &lt;code&gt;sync()&lt;/code&gt; 를 호출 하면 다음이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="79587fc0df1a119b29dd68f5adfcc7e0a80ce536" translate="yes" xml:space="preserve">
          <source>This way, instead of keeping the &lt;code&gt;captainId&lt;/code&gt; on our Ships, we could keep a &lt;code&gt;captainName&lt;/code&gt; instead and use it as our association tracker. In other words, instead of referencing the &lt;code&gt;id&lt;/code&gt; from the target model (Captain), our relationship will reference another column on the target model: the &lt;code&gt;name&lt;/code&gt; column. To specify this, we have to define a &lt;em&gt;target key&lt;/em&gt;. We will also have to specify a name for the foreign key itself:</source>
          <target state="translated">이 방법 대신 유지의 &lt;code&gt;captainId&lt;/code&gt; 를 우리의 선박에, 우리는 유지할 수 &lt;code&gt;captainName&lt;/code&gt; 을 대신하고 협회 추적기로 사용합니다. 즉, 대상 모델 (Captain) 의 &lt;code&gt;id&lt;/code&gt; 를 참조하는 대신 우리의 관계는 대상 모델의 다른 열인 &lt;code&gt;name&lt;/code&gt; 열을 참조합니다. 이를 지정하려면 &lt;em&gt;대상 키&lt;/em&gt; 를 정의해야합니다 . 또한 외래 키 자체의 이름을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="abef5dda5c0307db47d8df194568bc229f0ff31c" translate="yes" xml:space="preserve">
          <source>This way, we can do all kinds of eager loading:</source>
          <target state="translated">이렇게하면 모든 종류의 eager loading을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea22924fba7e00b6342f7724d57025a38a37f1c6" translate="yes" xml:space="preserve">
          <source>This way, when calling &lt;code&gt;image.getPendingTags()&lt;/code&gt;, the following SQL query will be generated:</source>
          <target state="translated">이렇게하면 &lt;code&gt;image.getPendingTags()&lt;/code&gt; 호출 할 때 다음 SQL 쿼리가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="b0748e5edf89087179c3ffcbaa9289fdfc2bb735" translate="yes" xml:space="preserve">
          <source>This will add methods &lt;code&gt;getUsers&lt;/code&gt;, &lt;code&gt;setUsers&lt;/code&gt;, &lt;code&gt;addUser&lt;/code&gt;,&lt;code&gt;addUsers&lt;/code&gt; to &lt;code&gt;Project&lt;/code&gt;, and &lt;code&gt;getProjects&lt;/code&gt;, &lt;code&gt;setProjects&lt;/code&gt;, &lt;code&gt;addProject&lt;/code&gt;, and &lt;code&gt;addProjects&lt;/code&gt; to &lt;code&gt;User&lt;/code&gt;.</source>
          <target state="translated">이 방법의 추가합니다 &lt;code&gt;getUsers&lt;/code&gt; , &lt;code&gt;setUsers&lt;/code&gt; , &lt;code&gt;addUser&lt;/code&gt; , &lt;code&gt;addUsers&lt;/code&gt; 에 &lt;code&gt;Project&lt;/code&gt; 및 &lt;code&gt;getProjects&lt;/code&gt; , &lt;code&gt;setProjects&lt;/code&gt; , &lt;code&gt;addProject&lt;/code&gt; 및 &lt;code&gt;addProjects&lt;/code&gt; 을 에 &lt;code&gt;User&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a6e951fad358490ec5b1a5a9c3f372af691a820" translate="yes" xml:space="preserve">
          <source>This will add the attribute &lt;code&gt;projectId&lt;/code&gt; to User. Depending on your setting for underscored the column in the table will either be called &lt;code&gt;projectId&lt;/code&gt; or &lt;code&gt;project_id&lt;/code&gt;. Instances of Project will get the accessors &lt;code&gt;getWorkers&lt;/code&gt; and &lt;code&gt;setWorkers&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;projectId&lt;/code&gt; 속성 이 User에 추가됩니다 . 밑줄로 표시된 설정에 따라 테이블의 열을 &lt;code&gt;projectId&lt;/code&gt; 또는 &lt;code&gt;project_id&lt;/code&gt; 로 지정 합니다. Project 인스턴스는 접근 자 &lt;code&gt;getWorkers&lt;/code&gt; 및 &lt;code&gt;setWorkers&lt;/code&gt; 를 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="fb8b8f31c57ee6c953321682693ac70ebefd2921" translate="yes" xml:space="preserve">
          <source>This will add the functions &lt;code&gt;add/set/get Tasks&lt;/code&gt; to user instances.</source>
          <target state="translated">그러면 &lt;code&gt;add/set/get Tasks&lt;/code&gt; 기능 이 사용자 인스턴스에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="977afa400f1e6cf00ffb52ee50d6f5a961571d68" translate="yes" xml:space="preserve">
          <source>This will all be seen in detail next. The advantages of using these pairs instead of one single association will be discussed in the end of this chapter.</source>
          <target state="translated">이것은 모두 다음에 자세히 볼 것입니다. 단일 연결 대신 이러한 쌍을 사용하는 이점은이 장의 끝에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="3463bc037bb376387fd4ec78e9ecc3a0802278d7" translate="yes" xml:space="preserve">
          <source>This will create a new model called UserProject with the equivalent foreign keys &lt;code&gt;projectId&lt;/code&gt; and &lt;code&gt;userId&lt;/code&gt;. Whether the attributes are camelcase or not depends on the two models joined by the table (in this case User and Project).</source>
          <target state="translated">외래 키 &lt;code&gt;projectId&lt;/code&gt; 및 &lt;code&gt;userId&lt;/code&gt; 와 함께 UserProject라는 새 모델이 생성됩니다 . 속성이 camelcase인지 여부는 테이블에 의해 결합 된 두 모델 (이 경우 사용자 및 프로젝트)에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="9218fafa583e55dc7276e3c7c13b1abc3b031c76" translate="yes" xml:space="preserve">
          <source>This will create following folders</source>
          <target state="translated">이것은 다음 폴더를 생성합니다</target>
        </trans-unit>
        <trans-unit id="77d3388ed7356b4ccde3d30587156a82a628f725" translate="yes" xml:space="preserve">
          <source>This will do following</source>
          <target state="translated">이것은 다음을 할 것입니다</target>
        </trans-unit>
        <trans-unit id="b9cd56142426d9d64bccca3cb45bcbe0b6b31b91" translate="yes" xml:space="preserve">
          <source>This will execute that seed file and you will have a demo user inserted into &lt;code&gt;User&lt;/code&gt; table.</source>
          <target state="translated">그러면 시드 파일이 실행되고 데모 테이블이 &lt;code&gt;User&lt;/code&gt; 테이블에 삽입됩니다 .</target>
        </trans-unit>
        <trans-unit id="17023fd3d297e103adfb2cd08cb3d64972ed6758" translate="yes" xml:space="preserve">
          <source>This will produce an outer join. However, a &lt;code&gt;where&lt;/code&gt; clause on a related model will create an inner join and return only the instances that have matching sub-models. To return all parent instances, you should add &lt;code&gt;required: false&lt;/code&gt;.</source>
          <target state="translated">외부 조인이 생성됩니다. 그러나 관련 모델 의 &lt;code&gt;where&lt;/code&gt; 절은 내부 조인을 만들고 일치하는 하위 모델이있는 인스턴스 만 반환합니다. 모든 부모 인스턴스를 반환하려면 &lt;code&gt;required: false&lt;/code&gt; 추가 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a291220bace82fc699106fdc0c78b94804985569" translate="yes" xml:space="preserve">
          <source>This will:</source>
          <target state="translated">이것은 :</target>
        </trans-unit>
        <trans-unit id="587b8c9b10a65cfc3263ff9ed36c73f795eee87e" translate="yes" xml:space="preserve">
          <source>Those details contains constraintSchema, constraintName, constraintCatalog tableCatalog, tableSchema, tableName, columnName, referencedTableCatalog, referencedTableCatalog, referencedTableSchema, referencedTableName, referencedColumnName. Remind: constraint informations won't return if it's sqlite.</source>
          <target state="translated">이러한 세부 사항에는 constraintSchema, constraintName, constraintCatalog tableCatalog, tableSchema, tableName, columnName, ReferenceTableCatalog, ReferenceTableCatalog, ReferenceTableSchema, ReferenceTableName, ReferenceColumnName이 포함됩니다. 주의 : 제약 정보는 sqlite이면 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4210ffe78330b024ede5237dbfe86d9b9b93cd25" translate="yes" xml:space="preserve">
          <source>Three of the values provided here (&lt;code&gt;NOW&lt;/code&gt;, &lt;code&gt;UUIDV1&lt;/code&gt; and &lt;code&gt;UUIDV4&lt;/code&gt;) are special default values, that should not be used to define types. Instead they are used as shorthands for defining default values. For example, to get a uuid field with a default value generated following v1 of the UUID standard:</source>
          <target state="translated">여기에 제공된 세 개의 값 ( &lt;code&gt;NOW&lt;/code&gt; , &lt;code&gt;UUIDV1&lt;/code&gt; 및 &lt;code&gt;UUIDV4&lt;/code&gt; )은 특수 기본값이며 유형을 정의하는 데 사용해서는 안됩니다. 대신 기본값을 정의하기위한 속기로 사용됩니다. 예를 들어, UUID 표준 v1에 따라 생성 된 기본값으로 uuid 필드를 가져 오려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="ad3fa17f66ba2847e7bc5fa23005689a9d061fe0" translate="yes" xml:space="preserve">
          <source>Through tables versus normal tables and the &quot;Super Many-to-Many association&quot;</source>
          <target state="translated">테이블 대 일반 테이블 및 &quot;수퍼 다 대다 연관&quot;을 통해</target>
        </trans-unit>
        <trans-unit id="91f71b1ba50409fa2b7c9ba85860ac52be6266d4" translate="yes" xml:space="preserve">
          <source>Throw errors to rollback</source>
          <target state="translated">롤백 오류 발생</target>
        </trans-unit>
        <trans-unit id="aa4f8c68ebe136d0527ece013ceac731e1a278f9" translate="yes" xml:space="preserve">
          <source>Throw:</source>
          <target state="translated">Throw:</target>
        </trans-unit>
        <trans-unit id="23d750e22af391e584ca1e4a39c95bd2fb56383e" translate="yes" xml:space="preserve">
          <source>Thrown when a connection to a database has a hostname that was not found</source>
          <target state="translated">데이터베이스 연결에 찾을 수없는 호스트 이름이있는 경우 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d2625383a632bae08070641f222b8caa05d99960" translate="yes" xml:space="preserve">
          <source>Thrown when a connection to a database has a hostname that was not reachable</source>
          <target state="translated">데이터베이스에 연결할 수없는 호스트 이름이있는 경우 발생합니다.</target>
        </trans-unit>
        <trans-unit id="87034a0755bcd6f36454ca6ff35ee17a4ff4e0e8" translate="yes" xml:space="preserve">
          <source>Thrown when a connection to a database has invalid values for any of the connection parameters</source>
          <target state="translated">데이터베이스 연결에 연결 매개 변수에 대해 유효하지 않은 값이있는 경우 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c0d696a249d0db17e465aee667fa2bc2571854bb" translate="yes" xml:space="preserve">
          <source>Thrown when a connection to a database is closed while an operation is in progress</source>
          <target state="translated">작업이 진행되는 동안 데이터베이스에 대한 연결이 닫힐 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="32d6e188736023fe8847cd2d2013f87cf98d8009" translate="yes" xml:space="preserve">
          <source>Thrown when a connection to a database is refused</source>
          <target state="translated">데이터베이스 연결이 거부되면 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b9258c976382ddb24c62d8d005000b6a6fe5d6f6" translate="yes" xml:space="preserve">
          <source>Thrown when a connection to a database is refused due to insufficient privileges</source>
          <target state="translated">권한이 부족하여 데이터베이스 연결이 거부 된 경우 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2043393f9e3b9fda84e6662489c8d9c0829b258d" translate="yes" xml:space="preserve">
          <source>Thrown when a connection to a database times out</source>
          <target state="translated">데이터베이스 연결 시간이 초과되면 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7bc64491ce5ca9b21f53e4cdc887f0f85bc7a079" translate="yes" xml:space="preserve">
          <source>Thrown when a database query times out because of a deadlock</source>
          <target state="translated">교착 상태로 인해 데이터베이스 쿼리 시간이 초과되면 발생합니다.</target>
        </trans-unit>
        <trans-unit id="679f3a1755d005602bfa972024e02b80ed5161dc" translate="yes" xml:space="preserve">
          <source>Thrown when a foreign key constraint is violated in the database</source>
          <target state="translated">데이터베이스에서 외래 키 제약 조건을 위반하면 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c84afedad343819211df62f9869172701d2dd1e5" translate="yes" xml:space="preserve">
          <source>Thrown when a query is passed invalid options (see message for details)</source>
          <target state="translated">쿼리에 유효하지 않은 옵션이 전달되면 발생합니다 (자세한 내용은 메시지 참조).</target>
        </trans-unit>
        <trans-unit id="7fabff6c09f652154afe11474aa9248b265cfe1c" translate="yes" xml:space="preserve">
          <source>Thrown when a record was not found, Usually used with rejectOnEmpty mode (see message for details)</source>
          <target state="translated">레코드를 찾을 수 없을 때 발생하며 일반적으로 rejectOnEmpty 모드와 함께 사용됩니다 (자세한 내용은 메시지 참조).</target>
        </trans-unit>
        <trans-unit id="c3c1771c4a29df5e79cf3befa41cf4598a7dee58" translate="yes" xml:space="preserve">
          <source>Thrown when a some problem occurred with Instance methods (see message for details)</source>
          <target state="translated">인스턴스 메소드에 문제가 발생했을 때 발생합니다 (자세한 내용은 메시지 참조).</target>
        </trans-unit>
        <trans-unit id="95bb12467ace2eea8fc434c8b6c9df4d88b333d1" translate="yes" xml:space="preserve">
          <source>Thrown when a unique constraint is violated in the database</source>
          <target state="translated">데이터베이스에서 고유 제한 조건을 위반하면 발생합니다.</target>
        </trans-unit>
        <trans-unit id="80ae4ddebfd7c82c02a5f23fec873816cf61746c" translate="yes" xml:space="preserve">
          <source>Thrown when an association is improperly constructed (see message for details)</source>
          <target state="translated">연결이 잘못 구성되면 발생합니다 (자세한 내용은 메시지 참조).</target>
        </trans-unit>
        <trans-unit id="89746572ae55e12747db0aea1e20bddf39ed7d39" translate="yes" xml:space="preserve">
          <source>Thrown when an exclusion constraint is violated in the database</source>
          <target state="translated">데이터베이스에서 제외 제약 조건을 위반하면 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8f157735ee3bf7ab21bc6f16555acb23bc8c29f3" translate="yes" xml:space="preserve">
          <source>Thrown when an include statement is improperly constructed (see message for details)</source>
          <target state="translated">include 문이 잘못 구성되면 발생합니다 (자세한 내용은 메시지 참조).</target>
        </trans-unit>
        <trans-unit id="0fd16d932a52421ae2e328140ee63e38a615cfb3" translate="yes" xml:space="preserve">
          <source>Thrown when attempting to update a stale model instance</source>
          <target state="translated">오래된 모델 인스턴스를 업데이트하려고 할 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7bc42c3b804e8b465e46ba8bd9b5e3206dc76ac4" translate="yes" xml:space="preserve">
          <source>Thrown when bulk operation fails, it represent per record level error.</source>
          <target state="translated">대량 작업이 실패하면 발생하며 이는 레코드 수준 오류를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5eacd7b627dd64f11a5a478affed3030beea193f" translate="yes" xml:space="preserve">
          <source>Thrown when bulk operation fails, it represent per record level error. Used with AggregateError</source>
          <target state="translated">대량 작업이 실패하면 발생하며 레코드 수준 오류를 나타냅니다. AggregateError와 함께 사용</target>
        </trans-unit>
        <trans-unit id="ae1229aaedb2ae0a2feaf4bc910bd5a9a676762a" translate="yes" xml:space="preserve">
          <source>Thrown when bulk operation fails, it represent per record level error. Used with Promise.AggregateError</source>
          <target state="translated">대량 작업이 실패하면 발생하며 이는 레코드 수준 오류를 나타냅니다. Promise.AggregateError와 함께 사용</target>
        </trans-unit>
        <trans-unit id="f9edfc205cf5a5c20603f1d3b7c72767c3a4d4b9" translate="yes" xml:space="preserve">
          <source>Thrown when connection is not acquired due to timeout</source>
          <target state="translated">시간 초과로 인해 연결을 얻지 못한 경우 발생</target>
        </trans-unit>
        <trans-unit id="7fceaebd6f438961290420060fe3b510c240b8f3" translate="yes" xml:space="preserve">
          <source>Thrown when constraint name is not found in the database</source>
          <target state="translated">데이터베이스에서 제약 조건 이름을 찾을 수 없을 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c1175bafb21b858838d4ed47ad6843f2f62f711c" translate="yes" xml:space="preserve">
          <source>Throws an error when no records found</source>
          <target state="translated">레코드를 찾지 못하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="22a4ad2c60d9b1a4a4ab47810c732e12faec00b0" translate="yes" xml:space="preserve">
          <source>TimeoutError</source>
          <target state="translated">TimeoutError</target>
        </trans-unit>
        <trans-unit id="c04ed1238a14de2b02d7fd14a7e9605bb1b10b96" translate="yes" xml:space="preserve">
          <source>Timestamps</source>
          <target state="translated">Timestamps</target>
        </trans-unit>
        <trans-unit id="461a3d5a1ad09fb08896c9d1bdedfed52f33ed17" translate="yes" xml:space="preserve">
          <source>Tip for reading the docs</source>
          <target state="translated">문서 읽기를위한 팁</target>
        </trans-unit>
        <trans-unit id="852d13828c37fb9d96ffea0f8ba5d4177325009c" translate="yes" xml:space="preserve">
          <source>To add a new project to a user and set its status, you pass extra &lt;code&gt;options.through&lt;/code&gt; to the setter, which contains the attributes for the join table</source>
          <target state="translated">사용자에게 새 프로젝트를 추가하고 상태를 설정하려면 추가 &lt;code&gt;options.through&lt;/code&gt; 을 통해 결합 테이블에 대한 속성이 포함 된 setter로 전달 하십시오.</target>
        </trans-unit>
        <trans-unit id="12de51033402849bf5bb53f0699f9d00f263ee2f" translate="yes" xml:space="preserve">
          <source>To begin, let's create the &lt;code&gt;.sequelizerc&lt;/code&gt; file in the root directory of your project, with the following content:</source>
          <target state="translated">시작하려면 프로젝트의 루트 디렉터리에 다음 내용으로 &lt;code&gt;.sequelizerc&lt;/code&gt; 파일을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="ac8fd1770455d2404985a693194adf77d45c1bff" translate="yes" xml:space="preserve">
          <source>To connect over a unix domain socket, specify the path to the socket directory in the &lt;code&gt;host&lt;/code&gt; option.</source>
          <target state="translated">유닉스 도메인 소켓을 통해 연결하려면 &lt;code&gt;host&lt;/code&gt; 옵션 에서 소켓 디렉토리의 경로를 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="2b5a17ba667cc9d0b9a70fe2db691a0c7e5bc5bd" translate="yes" xml:space="preserve">
          <source>To connect over a unix domain socket, specify the path to the socket directory in the &lt;code&gt;host&lt;/code&gt; option. The socket path must start with &lt;code&gt;/&lt;/code&gt;.</source>
          <target state="translated">유닉스 도메인 소켓을 통해 연결하려면 &lt;code&gt;host&lt;/code&gt; 옵션 에 소켓 디렉토리 경로를 지정하십시오 . 소켓 경로는 &lt;code&gt;/&lt;/code&gt; 로 시작해야합니다 .</target>
        </trans-unit>
        <trans-unit id="062d1b4f01aa30692a7d36958d9c8a163ef0fa87" translate="yes" xml:space="preserve">
          <source>To connect to the database, you must create a Sequelize instance. This can be done by either passing the connection parameters separately to the Sequelize constructor or by passing a single connection URI:</source>
          <target state="translated">데이터베이스에 연결하려면 Sequelize 인스턴스를 작성해야합니다. 연결 매개 변수를 Sequelize 생성자에 개별적으로 전달하거나 단일 연결 URI를 전달하여 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f48df892093e4004cfb053a43d4c85a85f815be" translate="yes" xml:space="preserve">
          <source>To create a &lt;strong&gt;Many-To-Many&lt;/strong&gt; relationship, two &lt;code&gt;belongsToMany&lt;/code&gt; calls are used together.</source>
          <target state="translated">만들려면 &lt;strong&gt;다 대다&lt;/strong&gt; 관계를 두 &lt;code&gt;belongsToMany&lt;/code&gt; 의 호출이 함께 사용된다.</target>
        </trans-unit>
        <trans-unit id="9e537071d3840cd3f2f52d76d2f26c344c4e5fd6" translate="yes" xml:space="preserve">
          <source>To create a &lt;strong&gt;One-To-Many&lt;/strong&gt; relationship, the &lt;code&gt;hasMany&lt;/code&gt; and &lt;code&gt;belongsTo&lt;/code&gt; associations are used together;</source>
          <target state="translated">&lt;strong&gt;일대 다&lt;/strong&gt; 관계 를 작성하기 위해 &lt;code&gt;hasMany&lt;/code&gt; 및 &lt;code&gt;belongsTo&lt;/code&gt; 연관이 함께 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8bc8fdcd71becc3e7559091f9c2d2ac9f459a285" translate="yes" xml:space="preserve">
          <source>To create a &lt;strong&gt;One-To-One&lt;/strong&gt; relationship, the &lt;code&gt;hasOne&lt;/code&gt; and &lt;code&gt;belongsTo&lt;/code&gt; associations are used together;</source>
          <target state="translated">&lt;strong&gt;일대일&lt;/strong&gt; 관계 를 작성하기 위해 &lt;code&gt;hasOne&lt;/code&gt; 및 &lt;code&gt;belongsTo&lt;/code&gt; 연관이 함께 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="da44e1aec269feef0bce9b3580109c553da536c7" translate="yes" xml:space="preserve">
          <source>To create an empty project you will need to execute &lt;code&gt;init&lt;/code&gt; command</source>
          <target state="translated">빈 프로젝트를 만들려면 &lt;code&gt;init&lt;/code&gt; 명령 을 실행해야합니다</target>
        </trans-unit>
        <trans-unit id="71fb99144f8e1ab035cde5271b9fd31e7e57bd68" translate="yes" xml:space="preserve">
          <source>To define mappings between a model and a table, use the &lt;code&gt;define&lt;/code&gt; method. Each column must have a datatype, see more about &lt;a href=&quot;data-types&quot;&gt;datatypes&lt;/a&gt;.</source>
          <target state="translated">모델과 테이블 사이의 매핑을 정의하기 위해 사용하는 &lt;code&gt;define&lt;/code&gt; 방법을. 각 열은 데이터 형식이에 대한 자세한보고해야 &lt;a href=&quot;data-types&quot;&gt;데이터 유형&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dda2146b56aea2f43e17df568053cae2211defe9" translate="yes" xml:space="preserve">
          <source>To define your own primary key:</source>
          <target state="translated">자신의 기본 키를 정의하려면</target>
        </trans-unit>
        <trans-unit id="0c3f2415d9121211436c6b961e20ccac56e2a8ac" translate="yes" xml:space="preserve">
          <source>To destroy everything the &lt;code&gt;TRUNCATE&lt;/code&gt; SQL can be used:</source>
          <target state="translated">모든 것을 파괴하려면 &lt;code&gt;TRUNCATE&lt;/code&gt; SQL을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0c9aa566dd042ca2109aefb26d5db9701348ed9" translate="yes" xml:space="preserve">
          <source>To disable the default scope, pass &lt;code&gt;scope: null&lt;/code&gt; to the getter: &lt;code&gt;User.getPosts({ scope: null })&lt;/code&gt;. Similarly, if you want to apply other scopes, pass an array like you would to &lt;code&gt;.scope&lt;/code&gt;:</source>
          <target state="translated">기본 범위를 비활성화하려면 &lt;code&gt;scope: null&lt;/code&gt; 을 getter : &lt;code&gt;User.getPosts({ scope: null })&lt;/code&gt; . 마찬가지로 다른 범위를 적용하려면 &lt;code&gt;.scope&lt;/code&gt; 와 같이 배열을 전달 하십시오 .</target>
        </trans-unit>
        <trans-unit id="2a925d0e769f5d48b8c6e0cdd9a0825bd325d509" translate="yes" xml:space="preserve">
          <source>To do this, Sequelize provides &lt;strong&gt;four&lt;/strong&gt; types of associations that should be combined to create them:</source>
          <target state="translated">이를 위해 Sequelize는 결합하여 생성해야하는 &lt;strong&gt;네&lt;/strong&gt; 가지 유형의 연결을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="dd05bbbc5e1376c7bf19c55a811408445260045f" translate="yes" xml:space="preserve">
          <source>To drop all tables:</source>
          <target state="translated">모든 테이블을 삭제하려면 :</target>
        </trans-unit>
        <trans-unit id="19d9cd3541a1b546a5fbf1c646fe9f62fe1a7bc9" translate="yes" xml:space="preserve">
          <source>To drop the table related to a model:</source>
          <target state="translated">모델과 관련된 테이블을 삭제하려면 :</target>
        </trans-unit>
        <trans-unit id="6463d8d9d72d8a88eca88bfd39719af73a2f3fb1" translate="yes" xml:space="preserve">
          <source>To enable CLS you must tell sequelize which namespace to use by using a static method of the sequelize constructor:</source>
          <target state="translated">CLS를 사용하려면 sequelize 생성자의 정적 메서드를 사용하여 sequelize에 사용할 네임 스페이스를 알려야합니다.</target>
        </trans-unit>
        <trans-unit id="87f6d681b01751ff8331a911939a0019959ee185" translate="yes" xml:space="preserve">
          <source>To enable CLS, add it do your project, create a namespace and set it on the sequelize constructor:</source>
          <target state="translated">CLS를 사용 가능하게하려면 프로젝트에 추가하고 네임 스페이스를 작성한 후 시퀀스 생성자에서 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="ec5b30047df227f1db838872824f7665a870a2c4" translate="yes" xml:space="preserve">
          <source>To enable more modern constructions in your migrations and seeders, you can simply install &lt;code&gt;babel-register&lt;/code&gt; and require it at the beginning of &lt;code&gt;.sequelizerc&lt;/code&gt;:</source>
          <target state="translated">마이그레이션 및 시더에서보다 현대적인 구성을 사용하려면 간단히 &lt;code&gt;babel-register&lt;/code&gt; 를 설치 하고 &lt;code&gt;.sequelizerc&lt;/code&gt; 시작시이를 요구할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="57ed3d1d0dadbaed6034cd1ee752e3e23f094504" translate="yes" xml:space="preserve">
          <source>To experiment with the other dialects, which are harder to setup locally, you can use the &lt;a href=&quot;https://github.com/papb/sequelize-sscce&quot;&gt;Sequelize SSCCE&lt;/a&gt; GitHub repository, which allows you to run code on all supported dialects directly from GitHub, for free, without any setup!</source>
          <target state="translated">로컬로 설정하기가 더 어려운 다른 언어를 실험하려면 &lt;a href=&quot;https://github.com/papb/sequelize-sscce&quot;&gt;Sequelize SSCCE&lt;/a&gt; GitHub 저장소를 사용하면 GitHub에서 지원되는 모든 언어에서 직접 설정없이 무료로 코드를 실행할 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="3265b58fa7e73178a31ecb9fa41fc44d85d54437" translate="yes" xml:space="preserve">
          <source>To extend Sequelize datatypes, do it before any Sequelize instance is created.</source>
          <target state="translated">Sequelize 데이터 유형을 확장하려면 Sequelize 인스턴스가 생성되기 전에 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="6e021f11d5b93d2d56eff3f6527dc41d1add80d2" translate="yes" xml:space="preserve">
          <source>To extend Sequelize datatypes, do it before any instance is created. This example creates a dummy &lt;code&gt;NEWTYPE&lt;/code&gt; that replicates the built-in datatype &lt;code&gt;Sequelize.INTEGER(11).ZEROFILL.UNSIGNED&lt;/code&gt;.</source>
          <target state="translated">Sequelize 데이터 유형을 확장하려면 인스턴스를 작성하기 전에 수행하십시오. 이 예제 는 내장 데이터 유형 &lt;code&gt;Sequelize.INTEGER(11).ZEROFILL.UNSIGNED&lt;/code&gt; 를 복제 하는 더미 &lt;code&gt;NEWTYPE&lt;/code&gt; 을 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="08fd9370c478abbfbe5b9098d6a2c2698f6d2737" translate="yes" xml:space="preserve">
          <source>To get full control over the foreign key column added by sequelize, you can use the &lt;code&gt;foreignKey&lt;/code&gt; option. It can either be a string, that specifies the name, or and object type definition, equivalent to those passed to &lt;code&gt;sequelize.define&lt;/code&gt;.</source>
          <target state="translated">sequelize로 추가 된 외래 키 열을 완전히 제어하려면 &lt;code&gt;foreignKey&lt;/code&gt; 옵션을 사용할 수 있습니다 . 이름을 지정하는 문자열이거나 &lt;code&gt;sequelize.define&lt;/code&gt; 에 전달 된 것과 동등한 오브젝트 유형 정의 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8b302c9710f47440c1d0dbf353af407bf35573b5" translate="yes" xml:space="preserve">
          <source>To get it stored in the database, use the &lt;code&gt;save&lt;/code&gt;-method and catch the events ... if needed:</source>
          <target state="translated">데이터베이스에 저장하려면 &lt;code&gt;save&lt;/code&gt; -method를 사용하고 필요한 경우 이벤트를 포착하십시오.</target>
        </trans-unit>
        <trans-unit id="81359c1e15ebff6b36cb1d90106dde4b80bd06a7" translate="yes" xml:space="preserve">
          <source>To get more relevant data, you can use limit, offset, order and grouping:</source>
          <target state="translated">보다 관련성이 높은 데이터를 얻으려면 한계, 오프셋, 순서 및 그룹화를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f03016401c3c47d133caf798279872a3ac0649b8" translate="yes" xml:space="preserve">
          <source>To illustrate this, consider an extension of the above example between tags and taggables, where each tag has a status. This way, to get all pending tags of an image, we could establish another &lt;code&gt;belognsToMany&lt;/code&gt; relationship between &lt;code&gt;Image&lt;/code&gt; and &lt;code&gt;Tag&lt;/code&gt;, this time applying a scope on the through model and another scope on the target model:</source>
          <target state="translated">이를 설명하기 위해 각 태그에 상태가있는 태그와 태그 지정 가능 항목 사이의 위 예제 확장을 고려하십시오. 이런 식으로 이미지의 모든 보류중인 태그를 가져 오기 위해 &lt;code&gt;Image&lt;/code&gt; 와 &lt;code&gt;Tag&lt;/code&gt; 간에 또 다른 &lt;code&gt;belognsToMany&lt;/code&gt; 관계를 설정할 수 있습니다. 이번에는 through 모델에 범위를 적용하고 대상 모델에 다른 범위를 적용합니다.</target>
        </trans-unit>
        <trans-unit id="61899d2894cb37b186c8fc4d77f78a44068071a9" translate="yes" xml:space="preserve">
          <source>To include all associated models, you can use the &lt;code&gt;all&lt;/code&gt; and &lt;code&gt;nested&lt;/code&gt; options:</source>
          <target state="translated">모든 관련 모델을 포함하려면 &lt;code&gt;all&lt;/code&gt; 및 &lt;code&gt;nested&lt;/code&gt; 옵션을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fb9a241f10c959268058c116425f0667f1b4bdc" translate="yes" xml:space="preserve">
          <source>To include all attributes, you can pass a single object with &lt;code&gt;all: true&lt;/code&gt;:</source>
          <target state="translated">모든 속성을 포함시키기 위해 모두 단일 객체를 전달할 수 있습니다 &lt;code&gt;all: true&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="528fc7532d53e4279a65d35bb35a1e677d7afa90" translate="yes" xml:space="preserve">
          <source>To install the Sequelize CLI:</source>
          <target state="translated">Sequelize CLI를 설치하려면 :</target>
        </trans-unit>
        <trans-unit id="41a7882efafea18d939a044b5476e2e2db5db42b" translate="yes" xml:space="preserve">
          <source>To invoke scope functions you can do</source>
          <target state="translated">범위 함수를 호출하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="6ff66a578ca5331ff221d03e2780d2b820c5ce62" translate="yes" xml:space="preserve">
          <source>To learn more about how to use Sequelize, read the tutorials available in the left menu. Begin with &lt;a href=&quot;manual/getting-started&quot;&gt;Getting Started&lt;/a&gt;.</source>
          <target state="translated">Sequelize 사용 방법에 대한 자세한 내용은 왼쪽 메뉴에서 제공되는 자습서를 읽으십시오. 시작 &lt;a href=&quot;manual/getting-started&quot;&gt;하기로 시작하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9f9df9f9807e6504b1a32309f67f3799ae9e6e29" translate="yes" xml:space="preserve">
          <source>To learn with an example, we will consider that we want to create a model to represent users, which have a &lt;code&gt;firstName&lt;/code&gt; and a &lt;code&gt;lastName&lt;/code&gt;. We want our model to be called &lt;code&gt;User&lt;/code&gt;, and the table it represents is called &lt;code&gt;Users&lt;/code&gt; in the database.</source>
          <target state="translated">예를 들어 배우기 위해 &lt;code&gt;firstName&lt;/code&gt; 과 &lt;code&gt;lastName&lt;/code&gt; 을 가진 사용자를 나타내는 모델을 만들고 싶다고 생각합니다 . 우리는 모델을 &lt;code&gt;User&lt;/code&gt; 라고 하고 그것이 나타내는 테이블을 데이터베이스에서 &lt;code&gt;Users&lt;/code&gt; 라고 합니다.</target>
        </trans-unit>
        <trans-unit id="c32038d2efc4add7b5a133b650a02f500d6b748e" translate="yes" xml:space="preserve">
          <source>To make a model paranoid, you must pass the &lt;code&gt;paranoid: true&lt;/code&gt; option to the model definition. Paranoid requires timestamps to work (i.e. it won't work if you also pass &lt;code&gt;timestamps: false&lt;/code&gt;).</source>
          <target state="translated">모델 편집증을 만들려면 &lt;code&gt;paranoid: true&lt;/code&gt; 옵션을 모델 정의에 전달해야합니다 . 편집증이 작동하려면 타임 스탬프가 필요합니다 (즉, &lt;code&gt;timestamps: false&lt;/code&gt; 도 전달하면 작동하지 않습니다 : false ).</target>
        </trans-unit>
        <trans-unit id="b771a71e24e6d53587993635747d1787fb98e7c6" translate="yes" xml:space="preserve">
          <source>To make things easier to follow, let's rename our &lt;code&gt;User_Profile&lt;/code&gt; model to &lt;code&gt;grant&lt;/code&gt;. Note that everything works in the same way as before. Our models are:</source>
          <target state="translated">따라 할 일을 쉽게하기 위해, 우리의 이름을 바꿀 수 있도록 &lt;code&gt;User_Profile&lt;/code&gt; 에 모델 &lt;code&gt;grant&lt;/code&gt; . 모든 것이 이전과 동일한 방식으로 작동합니다. 우리의 모델은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="82a28ba40b57129812c63ec44c7e5de69d719c98" translate="yes" xml:space="preserve">
          <source>To manage all data migrations you can use seeders. Seed files are some change in data that can be used to populate database table with sample data or test data.</source>
          <target state="translated">모든 데이터 마이그레이션을 관리하기 위해 파종기를 사용할 수 있습니다. 시드 파일은 데이터베이스 테이블을 샘플 데이터 또는 테스트 데이터로 채우는 데 사용할 수있는 일부 데이터 변경입니다.</target>
        </trans-unit>
        <trans-unit id="d41c172a89209d5b09fd5ea5fc82930a6a93002c" translate="yes" xml:space="preserve">
          <source>To move the where conditions from an included model from the &lt;code&gt;ON&lt;/code&gt; condition to the top level &lt;code&gt;WHERE&lt;/code&gt; you can use the &lt;code&gt;'$nested.column$'&lt;/code&gt; syntax:</source>
          <target state="translated">로부터는 포함 된 모델에서 어디 조건을 이동하려면 &lt;code&gt;ON&lt;/code&gt; 의 최고 수준의 조건 당신이 사용할 수있는 &lt;code&gt;'$nested.column$'&lt;/code&gt; 구문 : &lt;code&gt;WHERE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8735961a68722df89e488bc681dfe9fc27b073d4" translate="yes" xml:space="preserve">
          <source>To obtain top-level &lt;code&gt;WHERE&lt;/code&gt; clauses that involve nested columns, Sequelize provides a way to reference nested columns: the &lt;code&gt;'$nested.column$'&lt;/code&gt; syntax.</source>
          <target state="translated">중첩 열을 포함하는 최상위 &lt;code&gt;WHERE&lt;/code&gt; 절 을 얻기 위해 Sequelize는 중첩 열을 참조하는 방법 인 &lt;code&gt;'$nested.column$'&lt;/code&gt; 구문을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="67bd991991ae739c27032fc7de9da72a98f6858a" translate="yes" xml:space="preserve">
          <source>To prevent bugs/mistakes in eager loading, you can also delete the concrete fields &lt;code&gt;image&lt;/code&gt; and &lt;code&gt;video&lt;/code&gt; from Comment instances in the same &lt;code&gt;afterFind&lt;/code&gt; hook, leaving only the abstract &lt;code&gt;commentable&lt;/code&gt; field available.</source>
          <target state="translated">&lt;code&gt;afterFind&lt;/code&gt; 로드시 버그 / 실수를 방지하기 위해 동일한 afterFind 후크 의 Comment 인스턴스에서 구체적인 필드 &lt;code&gt;image&lt;/code&gt; 및 &lt;code&gt;video&lt;/code&gt; 를 삭제하여 &lt;code&gt;commentable&lt;/code&gt; 가능한 추상 필드 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="29316f2b493d1cad3856f19f0665c3eab5ef37a7" translate="yes" xml:space="preserve">
          <source>To properly support eager loading, define an &lt;code&gt;afterFind&lt;/code&gt; hook on the &lt;code&gt;Comment&lt;/code&gt; model that automatically populates the &lt;code&gt;commentable&lt;/code&gt; field in every instance;</source>
          <target state="translated">&lt;code&gt;afterFind&lt;/code&gt; 로드를 제대로 지원하려면 모든 인스턴스에서 &lt;code&gt;commentable&lt;/code&gt; 필드 를 자동으로 채우는 &lt;code&gt;Comment&lt;/code&gt; 모델 에 afterFind 후크를 정의하십시오 .</target>
        </trans-unit>
        <trans-unit id="d5d9d633e149298da30c5fd8a7b67d1289508e34" translate="yes" xml:space="preserve">
          <source>To properly support lazy loading, define a new instance method on the &lt;code&gt;Comment&lt;/code&gt; model called &lt;code&gt;getCommentable&lt;/code&gt; which calls, under the hood, the correct mixin to fetch the appropriate commentable;</source>
          <target state="translated">지연로드를 제대로 지원하려면 적절한 주석을 가져 오기 위해 올바른 믹스 인을 호출하는 &lt;code&gt;getCommentable&lt;/code&gt; 이라는 &lt;code&gt;Comment&lt;/code&gt; 모델 에 새 인스턴스 메서드를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="43c3e345f72eba5c3efd1485f74d109a6eedabc7" translate="yes" xml:space="preserve">
          <source>To provide a length for the data type, you can invoke it like a function: &lt;code&gt;INTEGER(2)&lt;/code&gt;</source>
          <target state="translated">데이터 유형의 길이를 제공하기 위해 함수처럼 호출 할 수 있습니다. &lt;code&gt;INTEGER(2)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5050fb0b7d3d66acd71af6d5a24c4a5a3f72eac5" translate="yes" xml:space="preserve">
          <source>To provide the greatest flexibility, let's use the Super Many-to-Many relationship construction here again:</source>
          <target state="translated">최고의 유연성을 제공하기 위해 여기서 다시 Super Many-to-Many 관계 구성을 사용하겠습니다.</target>
        </trans-unit>
        <trans-unit id="ce25ce8e4a379e9be823fd5c0f11c2eb1a8a5d28" translate="yes" xml:space="preserve">
          <source>To recap, the elements of the order array can be the following:</source>
          <target state="translated">요약하자면 순서 배열의 요소는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3c3ee3dbbd358f5ea3a5375e13ef5d5f193d5514" translate="yes" xml:space="preserve">
          <source>To recap, the elements of the order/group array can be the following:</source>
          <target state="translated">요약하면 주문 / 그룹 배열의 요소는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9f0557f6152bcc28fed2088bbb5968f3d7399eb3" translate="yes" xml:space="preserve">
          <source>To remove created associations you can just call the set method without a specific id:</source>
          <target state="translated">생성 된 연결을 제거하려면 특정 ID없이 set 메소드를 호출하면됩니다.</target>
        </trans-unit>
        <trans-unit id="23a5eb404fbeb5a976e8bf4a1b0685037db00b1d" translate="yes" xml:space="preserve">
          <source>To restore soft-deleted records, you can use the &lt;code&gt;restore&lt;/code&gt; method, which comes both in the static version as well as in the instance version:</source>
          <target state="translated">일시 삭제 된 레코드를 복원하려면 정적 버전과 인스턴스 버전 모두에서 제공되는 &lt;code&gt;restore&lt;/code&gt; 방법을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e6ed480fdfa306848b35b4f98b434fd446ccbad0" translate="yes" xml:space="preserve">
          <source>To select only some attributes, you can use the &lt;code&gt;attributes&lt;/code&gt; option. Most often, you pass an array:</source>
          <target state="translated">일부 속성 만 선택하려면 &lt;code&gt;attributes&lt;/code&gt; 옵션을 사용할 수 있습니다 . 대부분 배열을 전달합니다.</target>
        </trans-unit>
        <trans-unit id="7c9ab3faae14e43fe0c5833558b35d5caac3b197" translate="yes" xml:space="preserve">
          <source>To select only some attributes, you can use the &lt;code&gt;attributes&lt;/code&gt; option:</source>
          <target state="translated">일부 속성 만 선택하려면 &lt;code&gt;attributes&lt;/code&gt; 옵션을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c59110957af613b7041023bf22fdbfbf6454fb60" translate="yes" xml:space="preserve">
          <source>To setup the polymorphic association for the example above (which is an example of One-to-Many polymorphic association), we have the following steps:</source>
          <target state="translated">위의 예 (일대 다 다형성 연관의 예)에 대한 다형성 연관을 설정하려면 다음 단계를 따르십시오.</target>
        </trans-unit>
        <trans-unit id="9c0b1f31729f10174367599cf32209d59219dfc3" translate="yes" xml:space="preserve">
          <source>To update several rows at once:</source>
          <target state="translated">한 번에 여러 행을 업데이트하려면</target>
        </trans-unit>
        <trans-unit id="22b7aa8cde8674fa4a729793b1a6cd316bfb540d" translate="yes" xml:space="preserve">
          <source>To use a custom error message instead of that provided by &lt;a href=&quot;https://github.com/chriso/validator.js&quot;&gt;validator.js&lt;/a&gt;, use an object instead of the plain value or array of arguments, for example a validator which needs no argument can be given a custom message with</source>
          <target state="translated">&lt;a href=&quot;https://github.com/chriso/validator.js&quot;&gt;validator.js&lt;/a&gt; 가 제공하는 오류 메시지 대신 사용자 정의 오류 메시지를 사용하려면 일반 값 또는 인수 배열 대신 객체를 사용하십시오 (예 : 인수가 필요없는 유효성 검사기)</target>
        </trans-unit>
        <trans-unit id="75c5403dcfb5bf72f31f2a3c2d7f2fe263d46ed4" translate="yes" xml:space="preserve">
          <source>To use the wildcard operator %, append it to your replacement. The following query matches users with names that start with 'ben'.</source>
          <target state="translated">와일드 카드 연산자 %를 사용하려면이를 대체 문자에 추가하십시오. 다음 쿼리는 이름이 'ben'으로 시작하는 사용자를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="230fae1010b12a3dcbce66ac805e0cf889792eab" translate="yes" xml:space="preserve">
          <source>To use the wildcard operator &lt;code&gt;%&lt;/code&gt;, append it to your replacement. The following query matches users with names that start with 'ben'.</source>
          <target state="translated">와일드 카드 연산자 &lt;code&gt;%&lt;/code&gt; 를 사용하려면 대체 항목에 추가하십시오. 다음 쿼리는 이름이 'ben'으로 시작하는 사용자를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="c38c6c1f3a2743f8626703abb302e403d20ff81c" translate="yes" xml:space="preserve">
          <source>Tokens</source>
          <target state="translated">Tokens</target>
        </trans-unit>
        <trans-unit id="603270749de0b8c5d657407d142a68e2bd894051" translate="yes" xml:space="preserve">
          <source>Top level where with eagerly loaded models</source>
          <target state="translated">열심히로드 된 모델의 최상위</target>
        </trans-unit>
        <trans-unit id="1a7b7c1b33d161f45804730c70b75175dccd9883" translate="yes" xml:space="preserve">
          <source>Transaction</source>
          <target state="translated">Transaction</target>
        </trans-unit>
        <trans-unit id="4560532617032eba3499944208e1c914b037e0c9" translate="yes" xml:space="preserve">
          <source>Transaction options</source>
          <target state="translated">거래 옵션</target>
        </trans-unit>
        <trans-unit id="9c5a9f64903010dca00f0ffdf25ae4dd43e00a52" translate="yes" xml:space="preserve">
          <source>Transaction to run query under</source>
          <target state="translated">아래에서 쿼리를 실행할 트랜잭션</target>
        </trans-unit>
        <trans-unit id="1e3281a962e6db2e54e787f796eb7d2b1582389a" translate="yes" xml:space="preserve">
          <source>Transactions</source>
          <target state="translated">Transactions</target>
        </trans-unit>
        <trans-unit id="af4419640cc9b72a684777bff88307c334556deb" translate="yes" xml:space="preserve">
          <source>Trigger the constraint checks immediately</source>
          <target state="translated">구속 조건 검사를 즉시 트리거</target>
        </trans-unit>
        <trans-unit id="fbfa67ef4fc863ae5513f819aa79809b0312945b" translate="yes" xml:space="preserve">
          <source>Truncate all instances of the model.</source>
          <target state="translated">모델의 모든 인스턴스를 자릅니다.</target>
        </trans-unit>
        <trans-unit id="41ba9fe559f96b6c33ced14f4f229126b6f945ea" translate="yes" xml:space="preserve">
          <source>Truncate all instances of the model. This is a convenient method for Model.destroy({ truncate: true }).</source>
          <target state="translated">모델의 모든 인스턴스를 자릅니다. 이것은 Model.destroy ({truncate : true})에 편리한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="db65c7ad58c51cfb9b81db0635cd9fbad284458d" translate="yes" xml:space="preserve">
          <source>Truncate all tables defined through the sequelize models.</source>
          <target state="translated">순서 모델을 통해 정의 된 모든 테이블을 자릅니다.</target>
        </trans-unit>
        <trans-unit id="bebb9195a206168efd2a5b7fe2975178574e742a" translate="yes" xml:space="preserve">
          <source>Truncate all tables defined through the sequelize models. This is done by calling &lt;code&gt;Model.truncate()&lt;/code&gt; on each model.</source>
          <target state="translated">순서 모델을 통해 정의 된 모든 테이블을 자릅니다. 각 모델에서 &lt;code&gt;Model.truncate()&lt;/code&gt; 를 호출 하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="548046a99a144543148a41922751851ef4f108e1" translate="yes" xml:space="preserve">
          <source>Truncates all tables that have foreign-key references to the named table, or to any tables added to the group due to CASCADE.</source>
          <target state="translated">명명 된 테이블 또는 CASCADE로 인해 그룹에 추가 된 테이블에 대한 외래 키 참조가있는 모든 테이블을 자릅니다.</target>
        </trans-unit>
        <trans-unit id="876c1de91d7e89edd2ceeaa4ea1c723e2c94ba71" translate="yes" xml:space="preserve">
          <source>Trying to log a model instance directly to &lt;code&gt;console.log&lt;/code&gt; will produce a lot of clutter, since Sequelize instances have a lot of things attached to them. Instead, you can use the &lt;code&gt;.toJSON()&lt;/code&gt; method (which, by the way, automatically guarantees the instances to be &lt;code&gt;JSON.stringify&lt;/code&gt;-ed well).</source>
          <target state="translated">모델 인스턴스를 &lt;code&gt;console.log&lt;/code&gt; 에 직접 기록하려고하면 Sequelize 인스턴스에 많은 항목이 연결되어 있기 때문에 많은 혼란이 발생합니다. 대신 &lt;code&gt;.toJSON()&lt;/code&gt; 메서드를 사용할 수 있습니다 ( 그런데 인스턴스가 &lt;code&gt;JSON.stringify&lt;/code&gt; -ed well 이되도록 자동으로 보장합니다 ).</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="2b125b0e14258280c33525f42d8874d816aafa25" translate="yes" xml:space="preserve">
          <source>Type of constraint. One of the values in available constraints(case insensitive)</source>
          <target state="translated">구속 조건의 유형. 사용 가능한 제약 조건 중 하나 (대소 문자 구분)</target>
        </trans-unit>
        <trans-unit id="02466358e536c7941ae60bb0d80b0e5f61e9ca27" translate="yes" xml:space="preserve">
          <source>Type of geography data</source>
          <target state="translated">지리 데이터의 유형</target>
        </trans-unit>
        <trans-unit id="80639b7816c71c1eb7b8fd0ef7324c7ca20ec91d" translate="yes" xml:space="preserve">
          <source>Type of geometry data</source>
          <target state="translated">지오메트리 데이터의 유형</target>
        </trans-unit>
        <trans-unit id="657bf8cc823055c20626d868fa847d4cfc53f2f0" translate="yes" xml:space="preserve">
          <source>Type of index, available options are UNIQUE|FULLTEXT|SPATIAL</source>
          <target state="translated">인덱스 유형, 사용 가능한 옵션은 UNIQUE | FULLTEXT | SPATIAL입니다.</target>
        </trans-unit>
        <trans-unit id="d4a86cb946d4af4766f6a695502b64f3ea0cd58b" translate="yes" xml:space="preserve">
          <source>TypeScript</source>
          <target state="translated">TypeScript</target>
        </trans-unit>
        <trans-unit id="37dd88d1763196449c23edd76686c9e9f0cfc42d" translate="yes" xml:space="preserve">
          <source>TypeScript doesn't know how to generate a &lt;code&gt;class&lt;/code&gt; definition when we use the &lt;code&gt;sequelize.define&lt;/code&gt; method to define a Model. Therefore, we need to do some manual work and declare an interface and a type, and eventually cast the result of &lt;code&gt;.define&lt;/code&gt; to the &lt;em&gt;static&lt;/em&gt; type.</source>
          <target state="translated">TypeScript는 &lt;code&gt;sequelize.define&lt;/code&gt; 메서드를 사용하여 모델을 정의 할 때 &lt;code&gt;class&lt;/code&gt; 정의 를 생성하는 방법을 모릅니다 . 따라서, 우리는 몇 가지 수동 작업을 수행하고, 인터페이스 및 유형을 선언 할 필요가, 결국의 결과를 캐스팅 &lt;code&gt;.define&lt;/code&gt; 받는 &lt;em&gt;정적의&lt;/em&gt; 유형입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e49081c4bde9e1cfe58939ea3a16f1c972606e9a" translate="yes" xml:space="preserve">
          <source>Types can be set per-transaction by passing &lt;code&gt;options.type&lt;/code&gt; to &lt;code&gt;sequelize.transaction&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;options.type&lt;/code&gt; 을 &lt;code&gt;sequelize.transaction&lt;/code&gt; 로 전달 하여 트랜잭션별로 유형을 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7fca1a6b4d9232a993c3b6f49aea5cd588f941b2" translate="yes" xml:space="preserve">
          <source>Types can be set per-transaction by passing &lt;code&gt;options.type&lt;/code&gt; to &lt;code&gt;sequelize.transaction&lt;/code&gt;. Default to &lt;code&gt;DEFERRED&lt;/code&gt; but you can override the default type by passing &lt;code&gt;options.transactionType&lt;/code&gt; in &lt;code&gt;new Sequelize&lt;/code&gt;. Sqlite only.</source>
          <target state="translated">&lt;code&gt;options.type&lt;/code&gt; 을 &lt;code&gt;sequelize.transaction&lt;/code&gt; 로 전달 하여 트랜잭션별로 유형을 설정할 수 있습니다 . 에 기본 &lt;code&gt;DEFERRED&lt;/code&gt; 하지만 당신은 전달하여 기본 유형을 재정의 할 수 있습니다 &lt;code&gt;options.transactionType&lt;/code&gt; 을 에 &lt;code&gt;new Sequelize&lt;/code&gt; . Sqlite 만.</target>
        </trans-unit>
        <trans-unit id="c9e6a29d14f3f27cd2ee75b65407552ad50a3078" translate="yes" xml:space="preserve">
          <source>UNIQUE</source>
          <target state="translated">UNIQUE</target>
        </trans-unit>
        <trans-unit id="52c6c1812015585dc1092393a1f244f60d68c60a" translate="yes" xml:space="preserve">
          <source>UPDATE</source>
          <target state="translated">UPDATE</target>
        </trans-unit>
        <trans-unit id="b7cd97d59a40524239e87fabd06f9d91d1c4567e" translate="yes" xml:space="preserve">
          <source>UPDLOCK</source>
          <target state="translated">UPDLOCK</target>
        </trans-unit>
        <trans-unit id="c55112b254b71dd5f11927b24c53d183f3ed4118" translate="yes" xml:space="preserve">
          <source>UPSERT</source>
          <target state="translated">UPSERT</target>
        </trans-unit>
        <trans-unit id="7dcf46a0ef085488eccc18f6be6eae2377ef02e3" translate="yes" xml:space="preserve">
          <source>USE</source>
          <target state="translated">USE</target>
        </trans-unit>
        <trans-unit id="21bf75a5255af008f6315cb6aca4bb3bdccee521" translate="yes" xml:space="preserve">
          <source>UUID</source>
          <target state="translated">UUID</target>
        </trans-unit>
        <trans-unit id="e01890c85a119d4b8670c8a5c86e229b1b055141" translate="yes" xml:space="preserve">
          <source>UUIDV1</source>
          <target state="translated">UUIDV1</target>
        </trans-unit>
        <trans-unit id="53b28d9b4c5b16a8f70fad0c7b6d4111e7d812c5" translate="yes" xml:space="preserve">
          <source>UUIDV4</source>
          <target state="translated">UUIDV4</target>
        </trans-unit>
        <trans-unit id="d49513ad46116d9c43b4e1bdee7f589e92c24e31" translate="yes" xml:space="preserve">
          <source>UUIDs</source>
          <target state="translated">UUIDs</target>
        </trans-unit>
        <trans-unit id="c3791538e2a2ddac1dc84bc380034021e2418223" translate="yes" xml:space="preserve">
          <source>Un-associate one or more instance(s).</source>
          <target state="translated">하나 이상의 인스턴스 연결을 해제하십시오.</target>
        </trans-unit>
        <trans-unit id="c51b2acce8f2440b890216a65555b75575c13832" translate="yes" xml:space="preserve">
          <source>Un-associate one or several target rows.</source>
          <target state="translated">하나 또는 여러 개의 대상 행을 연결 해제하십시오.</target>
        </trans-unit>
        <trans-unit id="a5e8c5a43110ed2a66219f7247d3b101a56c48b7" translate="yes" xml:space="preserve">
          <source>Underlying Connector Libraries</source>
          <target state="translated">기본 커넥터 라이브러리</target>
        </trans-unit>
        <trans-unit id="4b46959a2e6eb284a6ae4735989048b9e793a87a" translate="yes" xml:space="preserve">
          <source>Undoing Migrations</source>
          <target state="translated">마이그레이션 취소</target>
        </trans-unit>
        <trans-unit id="af088c91d8cf21447c866835d2fe8341b7459730" translate="yes" xml:space="preserve">
          <source>Undoing Seeds</source>
          <target state="translated">씨앗 취소</target>
        </trans-unit>
        <trans-unit id="5931222b773be923fec652eaedbb8a66dc784380" translate="yes" xml:space="preserve">
          <source>Unique Constraint</source>
          <target state="translated">고유 한 제약</target>
        </trans-unit>
        <trans-unit id="518bb40fbaa8c36f7745b3742df67ba891a06fab" translate="yes" xml:space="preserve">
          <source>UniqueConstraintError</source>
          <target state="translated">UniqueConstraintError</target>
        </trans-unit>
        <trans-unit id="800eb81f2a2bf21a90e68b676ef9debfd6b8250e" translate="yes" xml:space="preserve">
          <source>UnknownConstraintError</source>
          <target state="translated">UnknownConstraintError</target>
        </trans-unit>
        <trans-unit id="bc5db458c7c36e7b25c7945029e0987d16c1427e" translate="yes" xml:space="preserve">
          <source>Unlike One-To-One and One-To-Many relationships, the defaults for both &lt;code&gt;ON UPDATE&lt;/code&gt; and &lt;code&gt;ON DELETE&lt;/code&gt; are &lt;code&gt;CASCADE&lt;/code&gt; for Many-To-Many relationships.</source>
          <target state="translated">일대일 및 일대 다 관계와 달리 &lt;code&gt;ON UPDATE&lt;/code&gt; 및 &lt;code&gt;ON DELETE&lt;/code&gt; 의 기본값은 다 &lt;code&gt;CASCADE&lt;/code&gt; 관계의 경우 CASCADE 입니다.</target>
        </trans-unit>
        <trans-unit id="4ffe5ab2779bb34cc0bfb9cf5eaf5ee797a64b24" translate="yes" xml:space="preserve">
          <source>Unlimited length TEXT column</source>
          <target state="translated">무제한 길이 TEXT 열</target>
        </trans-unit>
        <trans-unit id="8af0da98ed87540aaa0dbdb43e9a7c640c6b959f" translate="yes" xml:space="preserve">
          <source>Unmanaged transaction (then-callback)</source>
          <target state="translated">관리되지 않는 트랜잭션 (콜백)</target>
        </trans-unit>
        <trans-unit id="c45cf6088e2c1253666157ad780b1311f1452f62" translate="yes" xml:space="preserve">
          <source>Unmanaged transactions</source>
          <target state="translated">관리되지 않는 거래</target>
        </trans-unit>
        <trans-unit id="cd577906d7a1a1b1385cb8a984b7d3856e2f12b2" translate="yes" xml:space="preserve">
          <source>Unmanaged transactions force you to manually rollback or commit the transaction. If you don't do that, the transaction will hang until it times out. To start an unmanaged transaction, call &lt;code&gt;sequelize.transaction()&lt;/code&gt; without a callback (you can still pass an options object) and call &lt;code&gt;then&lt;/code&gt; on the returned promise. Notice that &lt;code&gt;commit()&lt;/code&gt; and &lt;code&gt;rollback()&lt;/code&gt; returns a promise.</source>
          <target state="translated">관리되지 않는 트랜잭션을 사용하면 트랜잭션을 수동으로 롤백하거나 커밋해야합니다. 그렇게하지 않으면 트랜잭션이 시간 초과 될 때까지 중단됩니다. 관리되지 않는 거래, 통화 시작하려면 &lt;code&gt;sequelize.transaction()&lt;/code&gt; 콜백없이 (당신은 여전히 옵션 개체를 전달할 수 있습니다) 및 통화 &lt;code&gt;then&lt;/code&gt; 반환 약속. 공지 사항이 &lt;code&gt;commit()&lt;/code&gt; 과 &lt;code&gt;rollback()&lt;/code&gt; 약속을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f1d79994c9809aebe7a9b8930b18b18450d91cf8" translate="yes" xml:space="preserve">
          <source>Unsigned &amp;amp; Zerofill integers - MySQL/MariaDB only</source>
          <target state="translated">부호없는 정수 및 Zerofill 정수-MySQL / MariaDB 전용</target>
        </trans-unit>
        <trans-unit id="7ba0e0f0a8ebd86853d71c3017b27a061df207ac" translate="yes" xml:space="preserve">
          <source>Until this step, we haven't inserted anything into the database. We have just created required model and migration files for our first model &lt;code&gt;User&lt;/code&gt;. Now to actually create that table in database you need to run &lt;code&gt;db:migrate&lt;/code&gt; command.</source>
          <target state="translated">이 단계까지는 데이터베이스에 아무것도 삽입하지 않았습니다. 방금 첫 번째 모델 &lt;code&gt;User&lt;/code&gt; 에 필요한 모델 및 마이그레이션 파일을 작성했습니다 . 이제 데이터베이스에서 해당 테이블을 실제로 만들려면 &lt;code&gt;db:migrate&lt;/code&gt; 명령 을 실행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="cc4ede8d78ca2ecaf76d56b490662d4a770a09dc" translate="yes" xml:space="preserve">
          <source>Update multiple instances that match the where options.</source>
          <target state="translated">where 옵션과 일치하는 여러 인스턴스를 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="6558917397e29e04756c7dcd6e3c7c75805acdf9" translate="yes" xml:space="preserve">
          <source>Update multiple records of a table</source>
          <target state="translated">테이블의 여러 레코드 업데이트</target>
        </trans-unit>
        <trans-unit id="95ad496c8b237465fa16d87da4c3c299bb24272d" translate="yes" xml:space="preserve">
          <source>Update queries also accept the &lt;code&gt;where&lt;/code&gt; option, just like the read queries shown above.</source>
          <target state="translated">업데이트 쿼리는 위에 표시된 읽기 쿼리와 마찬가지로 &lt;code&gt;where&lt;/code&gt; 옵션 도 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="23a42b6bdad20ed91567ad7e4f8b2f7d0f730d51" translate="yes" xml:space="preserve">
          <source>Update the underlying data value</source>
          <target state="translated">기본 데이터 값 업데이트</target>
        </trans-unit>
        <trans-unit id="f2f8570ddd7b1e7b571311bbf9159efb02571e07" translate="yes" xml:space="preserve">
          <source>Updated</source>
          <target state="translated">Updated</target>
        </trans-unit>
        <trans-unit id="62d1f25d7f288d21c737766fd3baebe82d4acf4e" translate="yes" xml:space="preserve">
          <source>Updating / Saving / Persisting an instance</source>
          <target state="translated">인스턴스 업데이트 / 저장 / 지속</target>
        </trans-unit>
        <trans-unit id="b99732d8df1c3f14f3a83f1582ed1ba8bead2c5c" translate="yes" xml:space="preserve">
          <source>Updating an instance</source>
          <target state="translated">인스턴스 업데이트</target>
        </trans-unit>
        <trans-unit id="1b4783ecbea2fdec8ac4829611952364749fb71b" translate="yes" xml:space="preserve">
          <source>Upgrade to v6</source>
          <target state="translated">v6으로 업그레이드</target>
        </trans-unit>
        <trans-unit id="e66a0fdf4e2a31a438f6baff851b7d51cf94baad" translate="yes" xml:space="preserve">
          <source>Upsert</source>
          <target state="translated">Upsert</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="ca4a8392ae80ccbc1c2a9df8a31290eaa680f49b" translate="yes" xml:space="preserve">
          <source>Usage in object notation:</source>
          <target state="translated">객체 표기법에서의 사용법 :</target>
        </trans-unit>
        <trans-unit id="e3a0f3f0d9aada934a03129fc160d898585273a1" translate="yes" xml:space="preserve">
          <source>Usage of &lt;code&gt;sequelize.define&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;sequelize.define&lt;/code&gt; 의 사용법</target>
        </trans-unit>
        <trans-unit id="025acb8f72c5cc278df18bc4024236c7eb9d9e6b" translate="yes" xml:space="preserve">
          <source>Usage with other sequelize methods</source>
          <target state="translated">다른 시퀀싱 방법과 함께 사용</target>
        </trans-unit>
        <trans-unit id="dc3abaf0d98cc1a8a9571a4f6a436825a1cbf035" translate="yes" xml:space="preserve">
          <source>Usage without strict types for attributes</source>
          <target state="translated">속성에 대해 엄격한 유형이없는 사용법</target>
        </trans-unit>
        <trans-unit id="ac325364009ce01b716bd91e61ac5855e8ae3c1e" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;config/database.json&lt;/code&gt; file for config settings</source>
          <target state="translated">&lt;code&gt;config/database.json&lt;/code&gt; 파일 사용</target>
        </trans-unit>
        <trans-unit id="ecca640bbfaddded09956877a59b853201e17053" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;config/database.json&lt;/code&gt; file for config settings;</source>
          <target state="translated">&lt;code&gt;config/database.json&lt;/code&gt; 파일을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="64466839065b9175b11a3b0579d4dcec4b8f57b5" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;db/migrations&lt;/code&gt; as migrations folder</source>
          <target state="translated">사용 &lt;code&gt;db/migrations&lt;/code&gt; 마이그레이션 폴더로</target>
        </trans-unit>
        <trans-unit id="0f3f806910fa916c898209abed73b6fc38cab6d3" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;db/migrations&lt;/code&gt; as migrations folder.</source>
          <target state="translated">&lt;code&gt;db/migrations&lt;/code&gt; 를 마이그레이션 폴더로 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="9ea90baccac616c216388e0c570f733074393330" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;db/models&lt;/code&gt; as models folder</source>
          <target state="translated">사용 &lt;code&gt;db/models&lt;/code&gt; 모델 폴더로</target>
        </trans-unit>
        <trans-unit id="c03d68b783dc0b56890950edb72de68913012b8d" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;db/models&lt;/code&gt; as models folder;</source>
          <target state="translated">&lt;code&gt;db/models&lt;/code&gt; 를 모델 폴더로 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="4adebc7fa9a0bb6eac2ce9575762392298075792" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;db/seeders&lt;/code&gt; as seeders folder</source>
          <target state="translated">사용 &lt;code&gt;db/seeders&lt;/code&gt; 파종기 폴더로</target>
        </trans-unit>
        <trans-unit id="60ae030e30cd3830fa0c13b433930301749d03d7" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;db/seeders&lt;/code&gt; as seeders folder;</source>
          <target state="translated">&lt;code&gt;db/seeders&lt;/code&gt; 를 seeders 폴더로 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="65116e42dcba94d836cc59896aaf1892dd9a99db" translate="yes" xml:space="preserve">
          <source>Use CLS with Sequelize.</source>
          <target state="translated">Sequelize와 함께 CLS를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="527fd74c4e6ef10c6a8aa5b4d7c0c382077bee70" translate="yes" xml:space="preserve">
          <source>Use CLS with Sequelize. CLS namespace provided is stored as &lt;code&gt;Sequelize._cls&lt;/code&gt;</source>
          <target state="translated">Sequelize와 함께 CLS를 사용합니다. 제공된 CLS 네임 스페이스는 &lt;code&gt;Sequelize._cls&lt;/code&gt; 로 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="b5022af106308022a9aa28b0bc2507901fcd6639" translate="yes" xml:space="preserve">
          <source>Use CLS with Sequelize. CLS namespace provided is stored as &lt;code&gt;Sequelize._cls&lt;/code&gt; and bluebird Promise is patched to use the namespace, using &lt;code&gt;cls-bluebird&lt;/code&gt; module.</source>
          <target state="translated">Sequelize와 함께 CLS를 사용하십시오. 제공된 CLS 네임 스페이스는 &lt;code&gt;Sequelize._cls&lt;/code&gt; 로 저장되며 bluebird Promise는 &lt;code&gt;cls-bluebird&lt;/code&gt; 모듈 을 사용하여 네임 스페이스를 사용하도록 패치됩니다 .</target>
        </trans-unit>
        <trans-unit id="991cc0765855434ec9a8f2314dfff9493e54a1a7" translate="yes" xml:space="preserve">
          <source>Use environment variables for config settings. This is because secrets such as passwords should never be part of the source code (and especially not committed to version control).</source>
          <target state="translated">구성 설정에 환경 변수를 사용하십시오. 이는 암호와 같은 비밀이 소스 코드의 일부가되어서는 안되기 때문입니다 (특히 버전 제어에 적용되지 않아야 함).</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
