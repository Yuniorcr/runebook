<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="sequelize">
    <body>
      <group id="sequelize">
        <trans-unit id="becd6dae52b2df153aa08d2d6f44756bb498c1b3" translate="yes" xml:space="preserve">
          <source>Column name</source>
          <target state="translated">열 이름</target>
        </trans-unit>
        <trans-unit id="c5d567c34c1265b1ead009da4afd96d277739a5e" translate="yes" xml:space="preserve">
          <source>Column name to remove</source>
          <target state="translated">제거 할 열 이름</target>
        </trans-unit>
        <trans-unit id="62a7611cf3ef3c6da72c643e3290dc1aa76d72a1" translate="yes" xml:space="preserve">
          <source>Column on which COUNT() should be applied</source>
          <target state="translated">COUNT ()를 적용해야하는 열</target>
        </trans-unit>
        <trans-unit id="8f7f21fd7a3abe8fec6502d8c488d6889457b13d" translate="yes" xml:space="preserve">
          <source>Combinations</source>
          <target state="translated">Combinations</target>
        </trans-unit>
        <trans-unit id="e04d03c32b7e4d785b35d28fb5a1bc66c34d8834" translate="yes" xml:space="preserve">
          <source>Combining getters and setters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c43c326ba531af8989310bee529e2456bbca867f" translate="yes" xml:space="preserve">
          <source>Comment for this column</source>
          <target state="translated">이 칼럼에 대한 설명</target>
        </trans-unit>
        <trans-unit id="c380604c38a888e7ca2dfa7caabf62f3c38be34d" translate="yes" xml:space="preserve">
          <source>Commit the transaction</source>
          <target state="translated">거래 커밋</target>
        </trans-unit>
        <trans-unit id="82cbd9f28b6e73dc5b2eb3f3f5ea8ad929b246d0" translate="yes" xml:space="preserve">
          <source>Common useful values for &lt;code&gt;options.logging&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8106773f052ee9ae49f2206b16988a2229233a00" translate="yes" xml:space="preserve">
          <source>Complex filtering / OR / NOT queries</source>
          <target state="translated">복잡한 필터링 / OR / NOT 쿼리</target>
        </trans-unit>
        <trans-unit id="e409f2f341dbf30646ad912983a01811dd9971c0" translate="yes" xml:space="preserve">
          <source>Complex ordering involving sub-queries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62455764071b6e8dcbedb8de8585e524d2539d45" translate="yes" xml:space="preserve">
          <source>Complex where clauses at the top-level</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c05bafdb56031bb64da1f1d1861f60118932c605" translate="yes" xml:space="preserve">
          <source>Concept</source>
          <target state="translated">Concept</target>
        </trans-unit>
        <trans-unit id="1c266f3a917d2c18a19ca7ec428bb01eb610216c" translate="yes" xml:space="preserve">
          <source>Concurrent/Partial transactions</source>
          <target state="translated">동시 / 부분 거래</target>
        </trans-unit>
        <trans-unit id="754164850f38c1ecdaf6b8ed894cb192bc36c5f4" translate="yes" xml:space="preserve">
          <source>Configuration</source>
          <target state="translated">Configuration</target>
        </trans-unit>
        <trans-unit id="6e7b90869f394206b5f3ab5eab0eeb92c62fea14" translate="yes" xml:space="preserve">
          <source>Configuration Connection String</source>
          <target state="translated">구성 연결 문자열</target>
        </trans-unit>
        <trans-unit id="ac7068df65770d41e1c1be02a2987c9d9b99bd10" translate="yes" xml:space="preserve">
          <source>Configuration file is by default a JSON file called &lt;code&gt;config.json&lt;/code&gt;. But sometimes you want to execute some code or access environment variables which is not possible in JSON files.</source>
          <target state="translated">구성 파일은 기본적으로 &lt;code&gt;config.json&lt;/code&gt; 이라는 JSON 파일 입니다. 그러나 때로는 JSON 파일에서는 불가능한 일부 코드를 실행하거나 환경 변수에 액세스하려고합니다.</target>
        </trans-unit>
        <trans-unit id="fee588358df2f846638bf1ca63ee279f4d14ff08" translate="yes" xml:space="preserve">
          <source>Configuring a Many-to-Many polymorphic association</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d13377a4905b9505e4686ca51f32514d15076ca1" translate="yes" xml:space="preserve">
          <source>Configuring a One-to-Many polymorphic association</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="494adab5bcf0f1438e56ef80e560621c33a0af84" translate="yes" xml:space="preserve">
          <source>Connecting to a database</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4733a8400eab2bdda8721610017ea165deacc02f" translate="yes" xml:space="preserve">
          <source>Connection Hooks</source>
          <target state="translated">연결 고리</target>
        </trans-unit>
        <trans-unit id="7f9c4306f84d429259837709a99d4b419088037c" translate="yes" xml:space="preserve">
          <source>Connection Pool</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f348ad399aba3329bb32334b281fb10590cd7a00" translate="yes" xml:space="preserve">
          <source>ConnectionAcquireTimeoutError</source>
          <target state="translated">ConnectionAcquireTimeoutError</target>
        </trans-unit>
        <trans-unit id="54c5f681f77ec4523760ad989f74ae402f08fb1c" translate="yes" xml:space="preserve">
          <source>ConnectionError</source>
          <target state="translated">ConnectionError</target>
        </trans-unit>
        <trans-unit id="346d0cb89df3354c71056beb8315f1fd603881a7" translate="yes" xml:space="preserve">
          <source>ConnectionRefusedError</source>
          <target state="translated">ConnectionRefusedError</target>
        </trans-unit>
        <trans-unit id="e3dc1982d3ea5e3f79a133ef369a5b444b9b3b22" translate="yes" xml:space="preserve">
          <source>ConnectionTimedOutError</source>
          <target state="translated">ConnectionTimedOutError</target>
        </trans-unit>
        <trans-unit id="f720ddc83f6c781e782e7ca3e485c29ee89c1014" translate="yes" xml:space="preserve">
          <source>Consider a comment &lt;code&gt;Foo&lt;/code&gt; whose &lt;code&gt;commentableId&lt;/code&gt; is 2 and &lt;code&gt;commentableType&lt;/code&gt; is &lt;code&gt;image&lt;/code&gt;. Consider also that &lt;code&gt;Image A&lt;/code&gt; and &lt;code&gt;Video X&lt;/code&gt; both happen to have an id equal to 2. Conceptually, it is clear that &lt;code&gt;Video X&lt;/code&gt; is not associated to &lt;code&gt;Foo&lt;/code&gt;, because even though its id is 2, the &lt;code&gt;commentableType&lt;/code&gt; of &lt;code&gt;Foo&lt;/code&gt; is &lt;code&gt;image&lt;/code&gt;, not &lt;code&gt;video&lt;/code&gt;. However, this distinction is made by Sequelize only at the level of the abstractions performed by &lt;code&gt;getCommentable&lt;/code&gt; and the hook we created above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa2bbd2a354ce9e7972eb878b3a1ee4c75fb8a7d" translate="yes" xml:space="preserve">
          <source>Consider four models: Foo, Bar, Baz and Qux, with has-many associations as follows:</source>
          <target state="translated">Foo, Bar, Baz 및 Qux의 네 가지 모델을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="8c3a3ab334659340d513bf749ecacb50b2a63e71" translate="yes" xml:space="preserve">
          <source>Consider the following models:</source>
          <target state="translated">다음 모델을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="ff00b81c3559dc0b9e1135401780b330c7a957d9" translate="yes" xml:space="preserve">
          <source>Consider the following setup:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b33329e240af621019008f86344b0be64b14f48" translate="yes" xml:space="preserve">
          <source>Consider the models &lt;code&gt;Foo&lt;/code&gt;, &lt;code&gt;Bar&lt;/code&gt;, &lt;code&gt;Baz&lt;/code&gt; and &lt;code&gt;Qux&lt;/code&gt;, with One-to-Many associations as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="756bf2141d4d3adc3f2eb59e60aba90481c63543" translate="yes" xml:space="preserve">
          <source>Consider then, that Post has a default scope which only shows active posts: &lt;code&gt;where: { active: true }&lt;/code&gt;. This scope lives on the associated model (Post), and not on the association like the &lt;code&gt;commentable&lt;/code&gt; scope did. Just like the default scope is applied when calling &lt;code&gt;Post.findAll()&lt;/code&gt;, it is also applied when calling &lt;code&gt;User.getPosts()&lt;/code&gt; - this will only return the active posts for that user.</source>
          <target state="translated">그런 다음 Post에 기본 범위가 있으며 활성 범위 만 표시합니다. &lt;code&gt;where: { active: true }&lt;/code&gt; . 이 범위는 관련 모델 (포스트)에 있으며 &lt;code&gt;commentable&lt;/code&gt; 범위 와 같은 연결에는 없습니다 . &lt;code&gt;Post.findAll()&lt;/code&gt; 호출 할 때 기본 범위가 적용되는 것과 마찬가지로 &lt;code&gt;User.getPosts()&lt;/code&gt; 호출 할 때도 적용됩니다. 그러면 해당 사용자에 대한 활성 게시물 만 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6a4dea536e29daa1c05405382d46014c98e615a5" translate="yes" xml:space="preserve">
          <source>Consider you are trying to model a game championship. There are players and teams. Teams play games. However, players can change teams in the middle of the championship (but not in the middle of a game). So, given one specific game, there are certain teams participating in that game, and each of these teams has a set of players (for that game).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60af5d54bdc5016ac2a43310e8832aa5e063fc6a" translate="yes" xml:space="preserve">
          <source>Consider you have two models, &lt;code&gt;Post&lt;/code&gt; and &lt;code&gt;Reaction&lt;/code&gt;, with a One-to-Many relationship set up, so that one post has many reactions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7856a8e8c39cd680655ba92f560ace09370be10d" translate="yes" xml:space="preserve">
          <source>Constraint name</source>
          <target state="translated">구속 조건 이름</target>
        </trans-unit>
        <trans-unit id="1e9b6f1184d92e432aaf1a869f53a5985359da7b" translate="yes" xml:space="preserve">
          <source>Constraints &amp;amp; Circularities</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60b63939905f7f97033aaa23260215ac8a754e10" translate="yes" xml:space="preserve">
          <source>Constructor Summary</source>
          <target state="translated">생성자 요약</target>
        </trans-unit>
        <trans-unit id="4378934eb83df73dbc84b219479fa9e29d94690f" translate="yes" xml:space="preserve">
          <source>Containment</source>
          <target state="translated">Containment</target>
        </trans-unit>
        <trans-unit id="bbc85e007bcf3a63e687ce28c7b580d4ca82c66d" translate="yes" xml:space="preserve">
          <source>Continuing with the idea of a polymorphic model, consider a tag table - an item can have multiple tags, and a tag can be related to several items.</source>
          <target state="translated">다형성 모델의 아이디어를 계속하면서 태그 테이블을 고려하십시오. 항목에는 여러 개의 태그가있을 수 있으며 태그는 여러 개의 항목과 관련 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11d1abaf886a63a3fd8a522a0742e78e659703ae" translate="yes" xml:space="preserve">
          <source>Convert a user's username to upper case</source>
          <target state="translated">사용자의 사용자 이름을 대문자로 변환</target>
        </trans-unit>
        <trans-unit id="20e575de41b5214352c5143062f3a7e7e02e945b" translate="yes" xml:space="preserve">
          <source>Convert the instance to a JSON representation.</source>
          <target state="translated">인스턴스를 JSON 표현으로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="ac4971b8f81e75f5a4f00b92b69be1f460649c65" translate="yes" xml:space="preserve">
          <source>Convert the instance to a JSON representation. Proxies to calling &lt;code&gt;get&lt;/code&gt; with no keys. This means get all values gotten from the DB, and apply all custom getters.</source>
          <target state="translated">인스턴스를 JSON 표현으로 변환하십시오. 호출에 &lt;code&gt;get&lt;/code&gt; 프록시 는 키없이 얻 습니다. 즉, DB에서 얻은 모든 값을 가져오고 모든 사용자 지정 게터를 적용해야합니다.</target>
        </trans-unit>
        <trans-unit id="8304bb8920c7e2b2a0e4d69fea55b5b362278cd9" translate="yes" xml:space="preserve">
          <source>Copyright &amp;copy; 2014&amp;ndash;present Sequelize contributors</source>
          <target state="translated">저작권 &amp;copy; 2014 &amp;ndash; 현재 Sequelize 기고자</target>
        </trans-unit>
        <trans-unit id="e19828935677052b69324fbd367b0ad39bf3f188" translate="yes" xml:space="preserve">
          <source>Count everything currently associated with this, using an optional where clause.</source>
          <target state="translated">선택적 where 절을 사용하여 현재 이와 관련된 모든 것을 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="ef71fb390593b0b29733c9c1039b3befc6ba5d9e" translate="yes" xml:space="preserve">
          <source>Count the number of records matching the provided where clause.</source>
          <target state="translated">제공된 where 절과 일치하는 레코드 수를 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="fd79e3727765aac8ff8fffd929e06662ab2d9e3b" translate="yes" xml:space="preserve">
          <source>Create a database</source>
          <target state="translated">데이터베이스 생성</target>
        </trans-unit>
        <trans-unit id="de5a7b79ddceb719d6200b84240e41ec77c637e2" translate="yes" xml:space="preserve">
          <source>Create a migration file with name like &lt;code&gt;XXXXXXXXXXXXXX-create-user.js&lt;/code&gt; in &lt;code&gt;migrations&lt;/code&gt; folder</source>
          <target state="translated">&lt;code&gt;migrations&lt;/code&gt; 폴더 에 &lt;code&gt;XXXXXXXXXXXXXX-create-user.js&lt;/code&gt; 와 같은 이름으로 마이그레이션 파일을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="07446a34596749390dc2bd1cac1891ffb6351a36" translate="yes" xml:space="preserve">
          <source>Create a migration file with name like &lt;code&gt;XXXXXXXXXXXXXX-create-user.js&lt;/code&gt; in &lt;code&gt;migrations&lt;/code&gt; folder.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99323ec55c6e204f16f2bb5ffbb975127493e762" translate="yes" xml:space="preserve">
          <source>Create a model file &lt;code&gt;user&lt;/code&gt; in &lt;code&gt;models&lt;/code&gt; folder</source>
          <target state="translated">&lt;code&gt;models&lt;/code&gt; 폴더 에 모델 파일 &lt;code&gt;user&lt;/code&gt; 생성</target>
        </trans-unit>
        <trans-unit id="2ce3a2c5dfbc6062b42c1675414616386c84f16c" translate="yes" xml:space="preserve">
          <source>Create a model file &lt;code&gt;user&lt;/code&gt; in &lt;code&gt;models&lt;/code&gt; folder;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7797bc29d4bd0332ce03664a292c536536e180a1" translate="yes" xml:space="preserve">
          <source>Create a new database schema.</source>
          <target state="translated">새 데이터베이스 스키마를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="9453930cbc091a75a646affa7dab856f7e45dec4" translate="yes" xml:space="preserve">
          <source>Create a new instance of the associated model and associate it with this.</source>
          <target state="translated">연관된 모델의 새 인스턴스를 작성하고이를 연관 시키십시오.</target>
        </trans-unit>
        <trans-unit id="3a6aaf38e60ca2cc55478161e7b4a836605b6fa7" translate="yes" xml:space="preserve">
          <source>Create a new linestring</source>
          <target state="translated">새로운 라인 스트링 만들기</target>
        </trans-unit>
        <trans-unit id="12570ffcd72c603ae6aeee594175ad61fc097f4f" translate="yes" xml:space="preserve">
          <source>Create a new point</source>
          <target state="translated">새로운 포인트를 만듭니다</target>
        </trans-unit>
        <trans-unit id="82dfd34e745e530b3fcc28f4186f64266ebe877f" translate="yes" xml:space="preserve">
          <source>Create a new point with a custom SRID</source>
          <target state="translated">사용자 지정 SRID를 사용하여 새 지점을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="6b61beea019117c97920f1cc2bb6487a9fdec829" translate="yes" xml:space="preserve">
          <source>Create a new polygon</source>
          <target state="translated">새로운 다각형 만들기</target>
        </trans-unit>
        <trans-unit id="5fcf1f19c726fb76f01b4726442f28df05d6330a" translate="yes" xml:space="preserve">
          <source>Create a schema</source>
          <target state="translated">스키마 만들기</target>
        </trans-unit>
        <trans-unit id="bec1c414ba9217919b8cef5ddabbc69d4cb16d58" translate="yes" xml:space="preserve">
          <source>Create a table with given set of attributes</source>
          <target state="translated">주어진 속성 세트로 테이블을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c806431924f95a4671285986e8923d75dc94de19" translate="yes" xml:space="preserve">
          <source>Create a unique index</source>
          <target state="translated">고유 인덱스 생성</target>
        </trans-unit>
        <trans-unit id="aaef67db78379914630a8533d2f4994117a0a106" translate="yes" xml:space="preserve">
          <source>Create an N:M association with a join table.</source>
          <target state="translated">조인 테이블과 N : M 연결을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="dafc97e8fbbfb663e5c7e7a02f93f9f5fc43213b" translate="yes" xml:space="preserve">
          <source>Create an N:M association with a join table. Defining &lt;code&gt;through&lt;/code&gt; is required.</source>
          <target state="translated">조인 테이블과 N : M 연결을 만듭니다. 정의 &lt;code&gt;through&lt;/code&gt; 필요합니다.</target>
        </trans-unit>
        <trans-unit id="d3a9f18191b0d692a90416a89fd7001f6489ff74" translate="yes" xml:space="preserve">
          <source>Create an SQL function</source>
          <target state="translated">SQL 함수 생성</target>
        </trans-unit>
        <trans-unit id="b40240dca19b3537530cd051448f217b757e0deb" translate="yes" xml:space="preserve">
          <source>Create and insert multiple instances in bulk.</source>
          <target state="translated">여러 인스턴스를 대량으로 작성하고 삽입하십시오.</target>
        </trans-unit>
        <trans-unit id="37d9838324affaf03f8c636744fea0e83694f29f" translate="yes" xml:space="preserve">
          <source>Creates a 1:m association between this (the source) and the provided target.</source>
          <target state="translated">이 (소스)와 제공된 대상간에 1 : m 연관을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="1613f18a42dec9eb987d0bb139eea7fabac56df8" translate="yes" xml:space="preserve">
          <source>Creates a 1:m association between this (the source) and the provided target. The foreign key is added on the target.</source>
          <target state="translated">이 (소스)와 제공된 대상간에 1 : m 연관을 작성합니다. 외래 키가 대상에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="5f206fe551edb446e2ca35e949d8cdd3e2dd278c" translate="yes" xml:space="preserve">
          <source>Creates a new transaction instance</source>
          <target state="translated">새 트랜잭션 인스턴스를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="66c0c5557018e9d480a9c78aa567937c436233a2" translate="yes" xml:space="preserve">
          <source>Creates a table called &lt;code&gt;Users&lt;/code&gt; with all columns as specified in its migration file.</source>
          <target state="translated">마이그레이션 파일에 지정된대로 모든 열이있는 &lt;code&gt;Users&lt;/code&gt; 라는 테이블을 작성 합니다.</target>
        </trans-unit>
        <trans-unit id="fdfd171f497df28f7ee38fce7628d79ee63f6507" translate="yes" xml:space="preserve">
          <source>Creates an association between this (the source) and the provided target.</source>
          <target state="translated">이 (소스)와 제공된 대상간에 연관을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="6f74c907e9756e800049b593ef6b274752344ba3" translate="yes" xml:space="preserve">
          <source>Creates an association between this (the source) and the provided target. The foreign key is added on the source.</source>
          <target state="translated">이 (소스)와 제공된 대상간에 연관을 작성합니다. 외래 키가 소스에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="004b91a2322793619b65b3c81414e80df0ebf671" translate="yes" xml:space="preserve">
          <source>Creates an association between this (the source) and the provided target. The foreign key is added on the target.</source>
          <target state="translated">이 (소스)와 제공된 대상간에 연관을 작성합니다. 외래 키가 대상에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="fbfab4a6c96f1f410afcb33106ef3c738c414173" translate="yes" xml:space="preserve">
          <source>Creates an object representing a call to the cast function.</source>
          <target state="translated">캐스트 함수에 대한 호출을 나타내는 객체를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="7c78f7a45c7ef1a333f7fdaf346ca3634e2e4737" translate="yes" xml:space="preserve">
          <source>Creates an object representing a database function.</source>
          <target state="translated">데이터베이스 함수를 나타내는 객체를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="4b53fc20f9a1060c0591933ba958616ffd2a1bcf" translate="yes" xml:space="preserve">
          <source>Creates an object representing a database function. This can be used in search queries, both in where and order parts, and as default values in column definitions. If you want to refer to columns in your function, you should use &lt;code&gt;sequelize.col&lt;/code&gt;, so that the columns are properly interpreted as columns and not a strings.</source>
          <target state="translated">데이터베이스 함수를 나타내는 객체를 만듭니다. 위치 및 주문 부분과 열 정의의 기본값으로 검색 쿼리에 사용할 수 있습니다. 함수에서 열을 참조하려면 &lt;code&gt;sequelize.col&lt;/code&gt; 을 사용 하여 열이 문자열이 아닌 열로 올바르게 해석되도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="0f2fa3193c2f10b70f87c639d7850bccb1764b19" translate="yes" xml:space="preserve">
          <source>Creates an object representing a literal, i.e.</source>
          <target state="translated">리터럴을 나타내는 객체를 만듭니다. 즉</target>
        </trans-unit>
        <trans-unit id="1b65d5d95dba6c3c38bd5b50fd82102e6eaef45e" translate="yes" xml:space="preserve">
          <source>Creates an object representing a literal, i.e. something that will not be escaped.</source>
          <target state="translated">이스케이프되지 않는 리터럴을 나타내는 객체를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="118fd0d0a0112e0fe426478ed3a4dfbcb76dbd62" translate="yes" xml:space="preserve">
          <source>Creates an object representing nested where conditions for postgres/sqlite/mysql json data-type.</source>
          <target state="translated">postgres / sqlite / mysql json 데이터 유형에 대한 중첩 위치 조건을 나타내는 객체를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="f1fb4d4fc9e715c0f15076c4f63e7ef753a6e351" translate="yes" xml:space="preserve">
          <source>Creates an object which represents a column in the DB, this allows referencing another column in your query.</source>
          <target state="translated">DB에서 열을 나타내는 개체를 생성하면 쿼리에서 다른 열을 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aaa2ff3dcc66fe0290d99e1f82ae9f8d3fb0e137" translate="yes" xml:space="preserve">
          <source>Creates an object which represents a column in the DB, this allows referencing another column in your query. This is often useful in conjunction with &lt;code&gt;sequelize.fn&lt;/code&gt;, since raw string arguments to fn will be escaped.</source>
          <target state="translated">DB에서 열을 나타내는 개체를 생성하면 쿼리에서 다른 열을 참조 할 수 있습니다. fn에 대한 원시 문자열 인수가 이스케이프되므로 &lt;code&gt;sequelize.fn&lt;/code&gt; 과 함께 사용 하면 종종 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="d049de031fac4a1d122cc0f8ddee0a3dc0e6664c" translate="yes" xml:space="preserve">
          <source>Creates new validation error item</source>
          <target state="translated">새로운 유효성 검사 오류 항목을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="3aa728453c208f42daeb32a0a15f64a2a1fc7d8e" translate="yes" xml:space="preserve">
          <source>Creating First Seed</source>
          <target state="translated">첫 씨앗 만들기</target>
        </trans-unit>
        <trans-unit id="caa32e4e8e79e2c3c02dca0de8e30c735ffb9e02" translate="yes" xml:space="preserve">
          <source>Creating a table</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dc74922e055dcd620d8e26b521f5669cd570096" translate="yes" xml:space="preserve">
          <source>Creating an association will add a foreign key constraint to the attributes. All associations use &lt;code&gt;CASCADE&lt;/code&gt; on update and &lt;code&gt;SET NULL&lt;/code&gt; on delete, except for n:m, which also uses &lt;code&gt;CASCADE&lt;/code&gt; on delete.</source>
          <target state="translated">연결을 만들면 외래 키 제약 조건이 속성에 추가됩니다. 모든 연결 은 삭제시 &lt;code&gt;CASCADE&lt;/code&gt; 를 사용하는 n : m을 제외하고 업데이트시 &lt;code&gt;CASCADE&lt;/code&gt; 를 사용하고 삭제시 &lt;code&gt;SET NULL&lt;/code&gt; 을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="3086da36f77bee52dcfe1664393977bd52cec77b" translate="yes" xml:space="preserve">
          <source>Creating an instance</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b3d5849847aa768f7f083714361ed65cbcf480b" translate="yes" xml:space="preserve">
          <source>Creating associations in sequelize is done by calling one of the belongsTo / hasOne / hasMany / belongsToMany functions on a model (the source), and providing another model as the first argument to the function (the target).</source>
          <target state="translated">sequelize에서 연관 작성은 모델 (소스)에서 belongsTo / hasOne / hasMany / belongsToMany 함수 중 하나를 호출하고 함수 (대상)에 대한 첫 번째 인수로 다른 모델을 제공하여 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="64c897965ef5b8a5f324e2bab7ce95b0dc43659b" translate="yes" xml:space="preserve">
          <source>Creating associations referencing a field which is not the primary key</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aad3e4efd94560e1bc4495b635681eae60ad2d51" translate="yes" xml:space="preserve">
          <source>Creating first Model (and Migration)</source>
          <target state="translated">첫 번째 모델 (및 마이그레이션) 작성</target>
        </trans-unit>
        <trans-unit id="f08dfddc9c37b5535ffc44f2c90aeea7e390127f" translate="yes" xml:space="preserve">
          <source>Creating in bulk</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac5b66de6104cc5ff1e50e727c226274bbec0715" translate="yes" xml:space="preserve">
          <source>Creating persistent instances</source>
          <target state="translated">영구 인스턴스 생성</target>
        </trans-unit>
        <trans-unit id="b4d618c3adec150bb5b7f92035f77ae3a872e661" translate="yes" xml:space="preserve">
          <source>Creating the first Model (and Migration)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="543e903ce50fec3a23c4d48cc7b8a277550fdac5" translate="yes" xml:space="preserve">
          <source>Creating the first Seed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c1dc2f546ca537d27b49705ba79bc5ec885fc56" translate="yes" xml:space="preserve">
          <source>Creating the standard relationships</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbeaf5bb2295a0ad55bf0d5a18c884864de3f9cc" translate="yes" xml:space="preserve">
          <source>Creating with Associations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c28e71f7de26b1295c660b682b873ce3319dc459" translate="yes" xml:space="preserve">
          <source>Creating with associations</source>
          <target state="translated">연관으로 작성</target>
        </trans-unit>
        <trans-unit id="c6d419641c4bf5d88e2cad8d761a6a7082d6c6d1" translate="yes" xml:space="preserve">
          <source>Creating, updating and deleting</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3110c1f3e73c788e86e5d4512cf410c3dc1c1690" translate="yes" xml:space="preserve">
          <source>Currenly, SQLite does not support &lt;a href=&quot;https://www.sqlite.org/omitted.html&quot;&gt;right joins&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a30d10fd754280e661548db197d38eed9b8ed2b" translate="yes" xml:space="preserve">
          <source>Current column name</source>
          <target state="translated">현재 열 이름</target>
        </trans-unit>
        <trans-unit id="aeb8251d8beeaa384177f46738068526c66c50c8" translate="yes" xml:space="preserve">
          <source>Current name of function</source>
          <target state="translated">기능의 현재 이름</target>
        </trans-unit>
        <trans-unit id="636981c9acb94bb09350975b62614e7b5d0d708c" translate="yes" xml:space="preserve">
          <source>Current name of table</source>
          <target state="translated">테이블의 현재 이름</target>
        </trans-unit>
        <trans-unit id="db756f94c9070eedd019aa02b12998ab497e3ccb" translate="yes" xml:space="preserve">
          <source>Customizing the foreign key</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3718a764361fcf0cb3afe936701f3e0f34a0552" translate="yes" xml:space="preserve">
          <source>Cyclic dependencies &amp;amp; Disabling constraints</source>
          <target state="translated">순환 종속성 및 비활성화 제약 조건</target>
        </trans-unit>
        <trans-unit id="8c76abdec41a7652375d00f4bf05256b82c68494" translate="yes" xml:space="preserve">
          <source>DATE</source>
          <target state="translated">DATE</target>
        </trans-unit>
        <trans-unit id="1b6e0231710c4347c4a9adaa78a001d3be5f1953" translate="yes" xml:space="preserve">
          <source>DATEONLY</source>
          <target state="translated">DATEONLY</target>
        </trans-unit>
        <trans-unit id="0cdc67ab1e0e2c1a616bd7f5b265aa1ac042f629" translate="yes" xml:space="preserve">
          <source>DECIMAL</source>
          <target state="translated">DECIMAL</target>
        </trans-unit>
        <trans-unit id="1473660f8ec2c1cd5ec200a9312979ae92af62e2" translate="yes" xml:space="preserve">
          <source>DEFAULT (MSSQL only)</source>
          <target state="translated">기본 (MSSQL 만 해당)</target>
        </trans-unit>
        <trans-unit id="10f984f7d502771d13c63406af087a7b917fd1aa" translate="yes" xml:space="preserve">
          <source>DEFERRED</source>
          <target state="translated">DEFERRED</target>
        </trans-unit>
        <trans-unit id="d6f5636098cd458ce9d22939f8e3e8deab0e9bd0" translate="yes" xml:space="preserve">
          <source>DELETE</source>
          <target state="translated">DELETE</target>
        </trans-unit>
        <trans-unit id="188157101620ef8e467f19e0555258980540195c" translate="yes" xml:space="preserve">
          <source>DESCRIBE</source>
          <target state="translated">DESCRIBE</target>
        </trans-unit>
        <trans-unit id="097274c5c7abaa172853282efd2062239c4afe9d" translate="yes" xml:space="preserve">
          <source>DOUBLE</source>
          <target state="translated">DOUBLE</target>
        </trans-unit>
        <trans-unit id="c18842877f84be9bb3ae10673c4e60242f22c160" translate="yes" xml:space="preserve">
          <source>Data Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16b6d1302e113952c2e74d59e21f98e7c034b4ca" translate="yes" xml:space="preserve">
          <source>Data retrieval / Finders</source>
          <target state="translated">데이터 검색 / 파인더</target>
        </trans-unit>
        <trans-unit id="5cf77b3e7be996116602805a95309307cedd99bb" translate="yes" xml:space="preserve">
          <source>Data type: ARRAY(ENUM) - PostgreSQL only</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51c6c861435ac739298311001d9adf19ab20e376" translate="yes" xml:space="preserve">
          <source>Data type: TIMESTAMP WITHOUT TIME ZONE - PostgreSQL only</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="452dae9d92ae82969a792e2c32fbd27f5b783894" translate="yes" xml:space="preserve">
          <source>DataTypes</source>
          <target state="translated">DataTypes</target>
        </trans-unit>
        <trans-unit id="e55983deb404c0934789dc39ba2d5c698868a848" translate="yes" xml:space="preserve">
          <source>DataTypes.GEOGRAPHY</source>
          <target state="translated">DataTypes.GEOGRAPHY</target>
        </trans-unit>
        <trans-unit id="39c278c49d95904686600a297ae838fcdcf5ad1e" translate="yes" xml:space="preserve">
          <source>Database Engine Support</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92ea1f457717f68645fb46cf1c8284c96865e310" translate="yes" xml:space="preserve">
          <source>Database character classification, PostgreSQL only</source>
          <target state="translated">데이터베이스 문자 분류, PostgreSQL 만</target>
        </trans-unit>
        <trans-unit id="b85ae159464679d594a0b15732ce1cc5fef9ffd2" translate="yes" xml:space="preserve">
          <source>Database default character set, MYSQL only</source>
          <target state="translated">데이터베이스 기본 문자 세트, MYSQL 만</target>
        </trans-unit>
        <trans-unit id="b9185d523dfbfceff505f8308320e46ff84b45ea" translate="yes" xml:space="preserve">
          <source>Database default character set, PostgreSQL only</source>
          <target state="translated">데이터베이스 기본 문자 세트, PostgreSQL 만</target>
        </trans-unit>
        <trans-unit id="57715d7d4ad61f3f1d3cdcc16b2a51ad6d81bc27" translate="yes" xml:space="preserve">
          <source>Database default collation</source>
          <target state="translated">데이터베이스 기본 데이터 정렬</target>
        </trans-unit>
        <trans-unit id="7ed3cf2f6786b03f145894f684242a6f47c80ccf" translate="yes" xml:space="preserve">
          <source>Database name to create</source>
          <target state="translated">작성할 데이터베이스 이름</target>
        </trans-unit>
        <trans-unit id="1e1475d0d52ad61d289472a24505e8cdf27dcb54" translate="yes" xml:space="preserve">
          <source>Database name to drop</source>
          <target state="translated">제거 할 데이터베이스 이름</target>
        </trans-unit>
        <trans-unit id="6440a03a5b1c2049664d2238af4b2afbe339c003" translate="yes" xml:space="preserve">
          <source>Database safety check</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe855d9eb6616607500e1663ab7e41c3404361e0" translate="yes" xml:space="preserve">
          <source>Database synchronization</source>
          <target state="translated">데이터베이스 동기화</target>
        </trans-unit>
        <trans-unit id="f3035ba3f23d1737dbf5d8db4bcd70058e5e68f8" translate="yes" xml:space="preserve">
          <source>DatabaseError</source>
          <target state="translated">DatabaseError</target>
        </trans-unit>
        <trans-unit id="8562930b64d8c57b6dc3907022c61a4e6a5ac83f" translate="yes" xml:space="preserve">
          <source>Datatypes</source>
          <target state="translated">Datatypes</target>
        </trans-unit>
        <trans-unit id="87ee1c987881d06cbf1ff8b715a82cae5934ee96" translate="yes" xml:space="preserve">
          <source>Date column with timezone, default is UTC</source>
          <target state="translated">시간대가있는 날짜 열 (기본값은 UTC)</target>
        </trans-unit>
        <trans-unit id="842b7b5d71896a41ecd92997ec80b1df5243c81e" translate="yes" xml:space="preserve">
          <source>Dates</source>
          <target state="translated">Dates</target>
        </trans-unit>
        <trans-unit id="6e1a74ef484369499fb26648565c6c22d4089da5" translate="yes" xml:space="preserve">
          <source>Decimal type, variable precision, take length as specified by user</source>
          <target state="translated">십진법, 가변 정밀도, 사용자가 지정한 길이</target>
        </trans-unit>
        <trans-unit id="d5d3294a4f7b017bc5ac427c1cc5667cf41327a6" translate="yes" xml:space="preserve">
          <source>Declaring Hooks</source>
          <target state="translated">후크 선언</target>
        </trans-unit>
        <trans-unit id="639f5e24d627d5a69fe35788701863daccd9a1ba" translate="yes" xml:space="preserve">
          <source>Decrement the value of one or more columns.</source>
          <target state="translated">하나 이상의 열 값을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="611219592e750f90a29ad21a5eea84c21c768cf6" translate="yes" xml:space="preserve">
          <source>Decrement the value of one or more columns. This is done in the database, which means it does not use the values currently stored on the Instance. The decrement is done using a</source>
          <target state="translated">하나 이상의 열 값을 줄입니다. 이는 데이터베이스에서 수행되므로 현재 인스턴스에 저장된 값을 사용하지 않습니다. 감소는</target>
        </trans-unit>
        <trans-unit id="f4b629840b1479afda3a588f435bd1786d5df9a9" translate="yes" xml:space="preserve">
          <source>Decrement the value of one or more columns. This is done in the database, which means it does not use the values currently stored on the Instance. The decrement is done using a &lt;code&gt;sql SET column = column - X WHERE foo = 'bar'&lt;/code&gt; query. To get the correct value after a decrement into the Instance you should do a reload.</source>
          <target state="translated">하나 이상의 열 값을 줄입니다. 이는 데이터베이스에서 수행되므로 현재 인스턴스에 저장된 값을 사용하지 않습니다. 감소는 &lt;code&gt;sql SET column = column - X WHERE foo = 'bar'&lt;/code&gt; 쿼리를 사용하여 수행됩니다 . 인스턴스 감소 후 올바른 값을 얻으려면 다시로드해야합니다.</target>
        </trans-unit>
        <trans-unit id="82b93adf8abc4a2c439c2caba7da91ec4da03ccd" translate="yes" xml:space="preserve">
          <source>Decrementing</source>
          <target state="translated">Decrementing</target>
        </trans-unit>
        <trans-unit id="9a3add6ccd892dadee1d219b35616d2f38e2779d" translate="yes" xml:space="preserve">
          <source>Decrementing works in the exact same way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc0c0d02ed365707f66785c5c11f4efe2a9f8b17" translate="yes" xml:space="preserve">
          <source>Default - MSSQL only</source>
          <target state="translated">기본-MSSQL 만</target>
        </trans-unit>
        <trans-unit id="ce5dc4c4981e0079ab6d262f8a2560c04386013e" translate="yes" xml:space="preserve">
          <source>Default Hooks (Sequelize.options.define)</source>
          <target state="translated">기본 후크 (Sequelize.options.define)</target>
        </trans-unit>
        <trans-unit id="bf322e63e4129512a8e82c0cf2816cb488ddb28f" translate="yes" xml:space="preserve">
          <source>Default Hooks (on Sequelize constructor options)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54e853e380fbb256af90f1b6701ddb337a923884" translate="yes" xml:space="preserve">
          <source>Default Values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8b0078307212ac99d70aed14cde95cfd0e8edab" translate="yes" xml:space="preserve">
          <source>Default options for model definitions. See &lt;a href=&quot;model.js~model#static-method-init&quot;&gt;Model.init&lt;/a&gt;.</source>
          <target state="translated">모델 정의의 기본 옵션. &lt;a href=&quot;model.js~model#static-method-init&quot;&gt;Model.init를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="138ea2bc5fd2d8230ea890634a179578fd0a3280" translate="yes" xml:space="preserve">
          <source>Default options for sequelize.query</source>
          <target state="translated">sequelize.query의 기본 옵션</target>
        </trans-unit>
        <trans-unit id="3282ec791792bf75df8dc4184c3cfa1bf4129358" translate="yes" xml:space="preserve">
          <source>Default options for sequelize.set</source>
          <target state="translated">sequelize.set의 기본 옵션</target>
        </trans-unit>
        <trans-unit id="148d18b0afcd38983917272029338aa34abe2546" translate="yes" xml:space="preserve">
          <source>Default options for sequelize.sync</source>
          <target state="translated">sequelize.sync의 기본 옵션</target>
        </trans-unit>
        <trans-unit id="e034cbbe2b8762f796d4892d08bbfed1145d3ef8" translate="yes" xml:space="preserve">
          <source>Default values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cf31c3996a9575ac98fa259e4f15d6814eb7d75" translate="yes" xml:space="preserve">
          <source>Default values to use if building a new instance</source>
          <target state="translated">새 인스턴스를 빌드 할 때 사용할 기본값</target>
        </trans-unit>
        <trans-unit id="c3644ae30a48d92e1c5317f11e352c68c4a1a5e7" translate="yes" xml:space="preserve">
          <source>Default values to use if creating a new instance</source>
          <target state="translated">새 인스턴스를 생성 할 때 사용할 기본값</target>
        </trans-unit>
        <trans-unit id="1b6417ab627b74c6bc6da989846304f37ee7f50e" translate="yes" xml:space="preserve">
          <source>Defaults to pluralized model name, unless freezeTableName is true, in which case it uses model name verbatim</source>
          <target state="translated">freezeTableName이 true가 아닌 경우 모델 이름을 그대로 사용하는 경우를 제외하고 기본값은 복수형 모델 이름입니다.</target>
        </trans-unit>
        <trans-unit id="417d326a6c611f33a5dbe90a166a7f6da3456bc0" translate="yes" xml:space="preserve">
          <source>Defer constraints checks to the end of transactions.</source>
          <target state="translated">트랜잭션 종료시 제한 조건 점검을 연기하십시오.</target>
        </trans-unit>
        <trans-unit id="4dee511653d844d8c7e6bb9a625536c8afb8a6b7" translate="yes" xml:space="preserve">
          <source>Deferrable</source>
          <target state="translated">Deferrable</target>
        </trans-unit>
        <trans-unit id="e2c8beb421bc96d4598ad75cd6bcaf8cc3c04d09" translate="yes" xml:space="preserve">
          <source>Define a new instance method on the &lt;code&gt;Tag&lt;/code&gt; model called &lt;code&gt;getTaggables&lt;/code&gt; which calls, under the hood, the correct mixin to fetch the appropriate taggables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a18f0956a766ec1d65be95892143c8ccfd248050" translate="yes" xml:space="preserve">
          <source>Define a new model, representing a table in the database.</source>
          <target state="translated">데이터베이스의 테이블을 나타내는 새 모델을 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="6950a6e98fe5e1257a8d847336aa8883c50fab57" translate="yes" xml:space="preserve">
          <source>Define a string field called &lt;code&gt;commentableType&lt;/code&gt; in the &lt;code&gt;Comment&lt;/code&gt; model;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="479dd6fd4b78f2302aaee932b13d364f2a4c5a33" translate="yes" xml:space="preserve">
          <source>Define a string field called &lt;code&gt;taggableType&lt;/code&gt; in the junction model;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e326f2112166494f0b6c9952a9561efbd4ff9aae" translate="yes" xml:space="preserve">
          <source>Define the &lt;code&gt;belongsToMany&lt;/code&gt; associations between the two models and &lt;code&gt;Tag&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6e58a5c8da437f1060b865a4c7978851f1bc80c" translate="yes" xml:space="preserve">
          <source>Define the &lt;code&gt;hasMany&lt;/code&gt; and &lt;code&gt;belongsTo&lt;/code&gt; association between &lt;code&gt;Image&lt;/code&gt;/&lt;code&gt;Video&lt;/code&gt; and &lt;code&gt;Comment&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc447867338cc4fa8513dafb96f2dbf47262250d" translate="yes" xml:space="preserve">
          <source>Define the default search scope to use for this model. Scopes have the same form as the options passed to find / findAll</source>
          <target state="translated">이 모델에 사용할 기본 검색 범위를 정의하십시오. 범위는 find / findAll에 전달 된 옵션과 동일한 형식입니다.</target>
        </trans-unit>
        <trans-unit id="fa07cd438d840d41fd6930c33e885db6ea7bc5db" translate="yes" xml:space="preserve">
          <source>Define the juncion model explicitly, specifying the two foreign keys as &lt;code&gt;tagId&lt;/code&gt; and &lt;code&gt;taggableId&lt;/code&gt; (this way it is a junction model for a Many-to-Many relationship between &lt;code&gt;Tag&lt;/code&gt; and the abstract concept of &lt;em&gt;taggable&lt;/em&gt;);</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc4248d08beab2357993fa80f9f88dc8d366770f" translate="yes" xml:space="preserve">
          <source>Define the sequelize instance to attach to the new Model. Throw error if none is provided.</source>
          <target state="translated">새 모델에 첨부 할 시퀀스 인스턴스를 정의하십시오. 제공되지 않은 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6f7c68eadb6a94a86fb7ac811b331392abec3504" translate="yes" xml:space="preserve">
          <source>Defining &lt;code&gt;through&lt;/code&gt; is &lt;strong&gt;required&lt;/strong&gt;. Sequelize would previously attempt to autogenerate names but that would not always lead to the most logical setups.</source>
          <target state="translated">정의 &lt;code&gt;through&lt;/code&gt; 됩니다 &lt;strong&gt;필요&lt;/strong&gt; . Sequelize는 이전에 이름을 자동 생성하려고 시도했지만 항상 가장 논리적으로 설정되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="3d69043479905b749aa977824179767f7ffeaa7c" translate="yes" xml:space="preserve">
          <source>Defining a Geography type attribute</source>
          <target state="translated">지리 유형 속성 정의</target>
        </trans-unit>
        <trans-unit id="722136870c63dcf938b34b0d787aa1361792ee6f" translate="yes" xml:space="preserve">
          <source>Defining a Geometry type attribute</source>
          <target state="translated">지오메트리 유형 속성 정의</target>
        </trans-unit>
        <trans-unit id="0bebaea2e6e58b3029ddffbe4dded1019d9a2927" translate="yes" xml:space="preserve">
          <source>Defining a model as paranoid</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26e26e600d5af3e30989258622a1bdcb5b8d2d19" translate="yes" xml:space="preserve">
          <source>Defining an Alias</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ae922b49beac040a2d64dd8047c9f7a2592360e" translate="yes" xml:space="preserve">
          <source>Defining an Alias is more powerful than simply specifying a custom name for the foreign key. This is better understood with an example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c2f0ca4f53353261b29b3b36cb51bb641043be2" translate="yes" xml:space="preserve">
          <source>Defining an alias for a &lt;code&gt;belongsToMany&lt;/code&gt; association also impacts the way includes are performed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec8934836699eb58af226e164faa6976aaeadebe" translate="yes" xml:space="preserve">
          <source>Defining as part of a property</source>
          <target state="translated">속성의 일부로 정의</target>
        </trans-unit>
        <trans-unit id="6ca0aae705049c1cde57c354dc3e656c9775db27" translate="yes" xml:space="preserve">
          <source>Defining as part of the model options</source>
          <target state="translated">모델 옵션의 일부로 정의</target>
        </trans-unit>
        <trans-unit id="6beb64bd8e9f32456ed8404f04359888b293c09f" translate="yes" xml:space="preserve">
          <source>Defining the Sequelize associations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf1be2b7ad07bae2fe92475d10173eb638774def" translate="yes" xml:space="preserve">
          <source>Definition</source>
          <target state="translated">Definition</target>
        </trans-unit>
        <trans-unit id="7b355055101652c13fbb4a0407b5baa90351f05c" translate="yes" xml:space="preserve">
          <source>Delete instead of setting deletedAt to current timestamp (only applicable if &lt;code&gt;paranoid&lt;/code&gt; is enabled)</source>
          <target state="translated">deletedAt를 현재 타임 스탬프로 설정하는 대신 삭제 ( &lt;code&gt;paranoid&lt;/code&gt; 가 활성화 된 경우에만 해당 )</target>
        </trans-unit>
        <trans-unit id="6ca8cb72940d4ee2942def3d3422e73a34a4d0ad" translate="yes" xml:space="preserve">
          <source>Delete multiple instances, or set their deletedAt timestamp to the current time if &lt;code&gt;paranoid&lt;/code&gt; is enabled.</source>
          <target state="translated">&lt;code&gt;paranoid&lt;/code&gt; 이 활성화 된 경우 여러 인스턴스를 삭제하거나 deletedAt 타임 스탬프를 현재 시간 으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="918f8bfa458557d9f7a7062a6a388c0f8c5d41b1" translate="yes" xml:space="preserve">
          <source>Delete multiple records from a table</source>
          <target state="translated">테이블에서 여러 레코드 삭제</target>
        </trans-unit>
        <trans-unit id="2ca33980535f175f034ff949b301b2d6e2967fd4" translate="yes" xml:space="preserve">
          <source>Delete queries also accept the &lt;code&gt;where&lt;/code&gt; option, just like the read queries shown above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cda36c95c093ae4cd6d399186e93976d1bcca02" translate="yes" xml:space="preserve">
          <source>Deleting</source>
          <target state="translated">Deleting</target>
        </trans-unit>
        <trans-unit id="4eba1c4e233cd4f035a51130c50d726a17d83bb1" translate="yes" xml:space="preserve">
          <source>Deleting an instance</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a66aadbfd8ac653ab54cd294931e8c04b2e90ef" translate="yes" xml:space="preserve">
          <source>Deprecated: &lt;code&gt;sequelize.import&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac2dd9e550f14e75a7e1372fd0a96b971d90c102" translate="yes" xml:space="preserve">
          <source>Deprecated: Operator Aliases</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="704a9772bc74638722ad09f4eff3c22fc1f31ca9" translate="yes" xml:space="preserve">
          <source>Describe a table structure</source>
          <target state="translated">테이블 구조 설명</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="a5888710dff7b58370cc3187d0c54b8b1462c852" translate="yes" xml:space="preserve">
          <source>Destroy the row corresponding to this instance.</source>
          <target state="translated">이 인스턴스에 해당하는 행을 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="3016ef950b0c07e28f3a688d79e8ac567daaeabc" translate="yes" xml:space="preserve">
          <source>Destroy the row corresponding to this instance. Depending on your setting for paranoid, the row will either be completely deleted, or have its deletedAt timestamp set to the current time.</source>
          <target state="translated">이 인스턴스에 해당하는 행을 삭제하십시오. 편집증에 대한 설정에 따라 행이 완전히 삭제되거나 deletedAt 타임 스탬프가 현재 시간으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="ddc29095a9fdf37911daa81999d86249d7a919a5" translate="yes" xml:space="preserve">
          <source>Destroying / Deleting persistent instances</source>
          <target state="translated">영구 인스턴스 삭제 / 삭제</target>
        </trans-unit>
        <trans-unit id="209d2430bedcc4a2d947ae78704ba91c9dec679e" translate="yes" xml:space="preserve">
          <source>Dialect-Specific Things</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3c71164c6732aa2815690d848fc5e3dc0309a6e" translate="yes" xml:space="preserve">
          <source>Dialects</source>
          <target state="translated">Dialects</target>
        </trans-unit>
        <trans-unit id="ecf655b86917e76c2cefb3aafa360c4b73b6caeb" translate="yes" xml:space="preserve">
          <source>Difference between HasOne and BelongsTo</source>
          <target state="translated">HasOne과 BelongsTo의 차이점</target>
        </trans-unit>
        <trans-unit id="de4ade1039dd218ba31ee544525b597b50e7c6ac" translate="yes" xml:space="preserve">
          <source>Difference between Validations and Constraints</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee0894f4da97be7c2b2d7842e892b6820058cd59" translate="yes" xml:space="preserve">
          <source>Direct Subclass:</source>
          <target state="translated">직접 서브 클래스 :</target>
        </trans-unit>
        <trans-unit id="1029544ae8b46287a52a74595462c217cf60a5a9" translate="yes" xml:space="preserve">
          <source>Directories</source>
          <target state="translated">Directories</target>
        </trans-unit>
        <trans-unit id="40783af09b3161aa9f78059481ba68494121fbd9" translate="yes" xml:space="preserve">
          <source>Disabling constraints (i.e. using &lt;code&gt;{ constraints: false }&lt;/code&gt;), since the same foreign key is referencing multiple tables;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e214b8a29923056887b7edf6635d90dcbb2abe88" translate="yes" xml:space="preserve">
          <source>Document</source>
          <target state="translated">Document</target>
        </trans-unit>
        <trans-unit id="9231c89cb4b996a3523d0655172a51ddb9432e20" translate="yes" xml:space="preserve">
          <source>Doing both things</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7a3976561a537ed64807ce91c39598b4ea5be13" translate="yes" xml:space="preserve">
          <source>Don't forget that the field referenced in the association must have a unique constraint placed on it. Otherwise, an error will be thrown (and sometimes with a mysterious error message - such as &lt;code&gt;SequelizeDatabaseError: SQLITE_ERROR: foreign key mismatch - &quot;ships&quot; referencing &quot;captains&quot;&lt;/code&gt; for SQLite).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="045a42e3d77964443cb4a715021f498d78eb3a87" translate="yes" xml:space="preserve">
          <source>Don't persist null values. This means that all columns with null values will not be saved</source>
          <target state="translated">null 값을 유지하지 마십시오. 이것은 null 값을 가진 모든 열이 저장되지 않음을 의미합니다</target>
        </trans-unit>
        <trans-unit id="e867a88f9e61b1ff73ce33bede301baf6bc1bec2" translate="yes" xml:space="preserve">
          <source>Drop a database</source>
          <target state="translated">데이터베이스 삭제</target>
        </trans-unit>
        <trans-unit id="51a731fe93dbec2124eb4572b00521e4d18deb78" translate="yes" xml:space="preserve">
          <source>Drop a schema</source>
          <target state="translated">스키마 삭제</target>
        </trans-unit>
        <trans-unit id="3e681d45842a1eedfd3f17a772dd0df3ea64a792" translate="yes" xml:space="preserve">
          <source>Drop a single schema</source>
          <target state="translated">단일 스키마 삭제</target>
        </trans-unit>
        <trans-unit id="c6285ba1646b4f6c3f7c7ae6df1edc6b758762c3" translate="yes" xml:space="preserve">
          <source>Drop a table from database</source>
          <target state="translated">데이터베이스에서 테이블 삭제</target>
        </trans-unit>
        <trans-unit id="c6e8e4f6389b865ed79529a8c94177f04852e0c5" translate="yes" xml:space="preserve">
          <source>Drop all enums from database (Postgres only)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71834bb059b7bfe1e00cb32ece9f92a7a2d6864e" translate="yes" xml:space="preserve">
          <source>Drop all schemas</source>
          <target state="translated">모든 스키마 삭제</target>
        </trans-unit>
        <trans-unit id="4ec4d18ea59b44900db2aee531543d9d0c7bde38" translate="yes" xml:space="preserve">
          <source>Drop all schemas.</source>
          <target state="translated">모든 스키마를 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="3c9401f0ed6d8ea9f8cfbd099d568a33700aa2fc" translate="yes" xml:space="preserve">
          <source>Drop all tables defined through this sequelize instance.</source>
          <target state="translated">이 시퀀스 인스턴스를 통해 정의 된 모든 테이블을 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="0003d1781c25c006028bf3fe4d8def7b340e045c" translate="yes" xml:space="preserve">
          <source>Drop all tables defined through this sequelize instance. This is done by calling Model.drop on each model.</source>
          <target state="translated">이 시퀀스 인스턴스를 통해 정의 된 모든 테이블을 삭제하십시오. 각 모델에서 Model.drop을 호출하면됩니다.</target>
        </trans-unit>
        <trans-unit id="be5be0af3c0ffa1f406647d9bf5b9aa1a5ab8605" translate="yes" xml:space="preserve">
          <source>Drop all tables from database</source>
          <target state="translated">데이터베이스에서 모든 테이블을 삭제</target>
        </trans-unit>
        <trans-unit id="39f143b5e8b4911ef525b400f53591d655ba04ad" translate="yes" xml:space="preserve">
          <source>Drop an SQL function</source>
          <target state="translated">SQL 함수 삭제</target>
        </trans-unit>
        <trans-unit id="c3b90df544139ef8dcf1fff4a49dd1a2c0eea688" translate="yes" xml:space="preserve">
          <source>Drop specified enum from database (Postgres only)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a43aea21fa1ae00928a7e8b8f2fd5d0ffd712f96" translate="yes" xml:space="preserve">
          <source>Drop the table represented by this Model</source>
          <target state="translated">이 모델이 나타내는 테이블을 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="796f1eac263f012ff07de56e7e9791b5447b9208" translate="yes" xml:space="preserve">
          <source>Dropping tables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="096c9809fdc0538b50d5a68da39154922316935a" translate="yes" xml:space="preserve">
          <source>Dynamic Configuration</source>
          <target state="translated">동적 구성</target>
        </trans-unit>
        <trans-unit id="3ca7327a7bd2f5353024f65ee68945fbf10eccf7" translate="yes" xml:space="preserve">
          <source>Dynamic configuration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="507ccbdaf83ab03c2929498330b7d2836e4c06b2" translate="yes" xml:space="preserve">
          <source>ENUM</source>
          <target state="translated">ENUM</target>
        </trans-unit>
        <trans-unit id="38c42767076a41529fd4110de20e3a2bd31c59aa" translate="yes" xml:space="preserve">
          <source>ENUMs</source>
          <target state="translated">ENUMs</target>
        </trans-unit>
        <trans-unit id="4f904a90891673e8467ae5439c5fad8bc4413ccd" translate="yes" xml:space="preserve">
          <source>ENUMs can also be specified with the &lt;code&gt;values&lt;/code&gt; field of the column definition, as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a142f6999680571fa05b1a87552e101c1e3b874" translate="yes" xml:space="preserve">
          <source>EXCLUSIVE</source>
          <target state="translated">EXCLUSIVE</target>
        </trans-unit>
        <trans-unit id="cd6fe9d09ea45ac95915d4ba7dcca7c401cc3254" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;write&lt;/code&gt; or &lt;code&gt;useMaster: true&lt;/code&gt; query will use write pool. For &lt;code&gt;SELECT&lt;/code&gt; read pool will be used. Read replica are switched using a basic round robin scheduling.</source>
          <target state="translated">각 &lt;code&gt;write&lt;/code&gt; 또는 &lt;code&gt;useMaster: true&lt;/code&gt; 쿼리는 쓰기 풀을 사용합니다. 들어 &lt;code&gt;SELECT&lt;/code&gt; 의 읽기 풀 사용됩니다. 읽기 전용 복제본은 기본 라운드 로빈 일정을 사용하여 전환됩니다.</target>
        </trans-unit>
        <trans-unit id="9084acde7fe83981db445a5a63fa3f407800b2b0" translate="yes" xml:space="preserve">
          <source>Each argument will be joined by AND</source>
          <target state="translated">각 인수는 AND로 결합됩니다</target>
        </trans-unit>
        <trans-unit id="959d2abea6938ee0a35e2a625351c03924a8c888" translate="yes" xml:space="preserve">
          <source>Each argument will be joined by OR</source>
          <target state="translated">각 인수는 OR로 연결됩니다</target>
        </trans-unit>
        <trans-unit id="fae80e446045ebe7e57d9510b77e77012bb01de8" translate="yes" xml:space="preserve">
          <source>Eager Loading</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="649bb3fa54f741a195405e15046bb061ba0b7495" translate="yes" xml:space="preserve">
          <source>Eager Loading Example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d3fbbcd2b7be5f32cd21068f876888b53dc6019" translate="yes" xml:space="preserve">
          <source>Eager loading</source>
          <target state="translated">열망 적 인 로딩</target>
        </trans-unit>
        <trans-unit id="e53f14a0716535073a65a5a1de6522af0bc92f55" translate="yes" xml:space="preserve">
          <source>Eager loading filtered at the associated model level</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="364e8c5f90f24bc981383745a7fd6ec338243574" translate="yes" xml:space="preserve">
          <source>Eager loading with Many-to-Many relationships</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1067a816e9c89b7d14b7d4c7bdcd1275cee9f3b" translate="yes" xml:space="preserve">
          <source>EagerLoadingError</source>
          <target state="translated">EagerLoadingError</target>
        </trans-unit>
        <trans-unit id="4c16ac9ae3d8d30c03296049af23af41a4fa561e" translate="yes" xml:space="preserve">
          <source>Either an object of named bind parameter in the format &lt;code&gt;_param&lt;/code&gt; or an array of unnamed bind parameter to replace &lt;code&gt;$1, $2, ...&lt;/code&gt; in your SQL.</source>
          <target state="translated">&lt;code&gt;_param&lt;/code&gt; 형식의 이름 지정된 바인드 매개 변수 오브젝트 또는 이름 지정되지 않은 바인드 매개 변수 배열은 SQL에서 &lt;code&gt;$1, $2, ...&lt;/code&gt; 를 대체 합니다.</target>
        </trans-unit>
        <trans-unit id="5f6cd42178e8d806c67223411a96ef4333d916f7" translate="yes" xml:space="preserve">
          <source>Either an object of named parameter replacements in the format &lt;code&gt;:param&lt;/code&gt; or an array of unnamed replacements to replace &lt;code&gt;?&lt;/code&gt; in your SQL.</source>
          <target state="translated">&lt;code&gt;:param&lt;/code&gt; 형식의 명명 된 매개 변수 대체 개체 또는 대체 할 명명되지 않은 대체 배열 &lt;code&gt;?&lt;/code&gt; 당신의 SQL에서.</target>
        </trans-unit>
        <trans-unit id="6716cbfae8ed41a517686fff379f0ea8884874cb" translate="yes" xml:space="preserve">
          <source>Either resolving with the resolution of your callback</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19bc5da7c3f7cf592be581309fafc0c762c3482c" translate="yes" xml:space="preserve">
          <source>EmptyResultError</source>
          <target state="translated">EmptyResultError</target>
        </trans-unit>
        <trans-unit id="afd06d8a0cebf38e46f8259e0708cdd2d8ce746b" translate="yes" xml:space="preserve">
          <source>Enforcing a foreign key reference without constraints</source>
          <target state="translated">제약없이 외래 키 참조 적용</target>
        </trans-unit>
        <trans-unit id="842967ef82c682a245e4d24b8751810c9fe848b3" translate="yes" xml:space="preserve">
          <source>Enforcing the table name to be equal to the model name</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8072ec300478b25ddbcab8a4027b6c464f0ce97" translate="yes" xml:space="preserve">
          <source>Engines - MySQL/MariaDB only</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="761c3fe9c273bc96d11e7783dae3b61f1c7cf28d" translate="yes" xml:space="preserve">
          <source>Enum name to drop</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac4d135647bbefc1f4f8fc228a6cc5bd8fb32d65" translate="yes" xml:space="preserve">
          <source>Escape value.</source>
          <target state="translated">탈출 가치.</target>
        </trans-unit>
        <trans-unit id="0cacace9bdafc6b8db500eb4594c331013ced5da" translate="yes" xml:space="preserve">
          <source>Even if you simply call &lt;code&gt;findByPk&lt;/code&gt; providing the primary key of a soft-deleted record, the result will be &lt;code&gt;null&lt;/code&gt; as if that record didn't exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91ac124a5f6c5daa96e75bbd9c84acfa46132f87" translate="yes" xml:space="preserve">
          <source>Even though it is called a HasOne association, for most 1:1 relations you usually want the BelongsTo association since BelongsTo will add the foreignKey on the source where hasOne will add on the target.</source>
          <target state="translated">HasOne 연관이라고하더라도, 대부분의 1 : 1 관계에서는 일반적으로 belongssTo가 소스에 foreignKey를 추가 할 것이기 때문에 belongssTo 연관을 원합니다. hasOne은 대상에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="689de9464c9604ac55af546a692d5b35c30aed44" translate="yes" xml:space="preserve">
          <source>Every column you define in your model must have a data type. Sequelize provides &lt;a href=&quot;https://github.com/sequelize/sequelize/blob/master/lib/data-types.js&quot;&gt;a lot of built-in data types&lt;/a&gt;. To access a built-in data type, you must import &lt;code&gt;DataTypes&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30293e7b7fe57cafdfa69e8f2bb2c893ba2c741a" translate="yes" xml:space="preserve">
          <source>Every query performed by Sequelize will automatically ignore soft-deleted records (except raw queries, of course).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2a5b0ea1ccf863bfa97a8763382a273db3ca14f" translate="yes" xml:space="preserve">
          <source>Everything else is ignored, and if raw is not set, the query will fail</source>
          <target state="translated">다른 모든 것은 무시되고 raw가 설정되지 않으면 쿼리가 실패합니다</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="1fabb1683d22d0469c9e9cac437dfd3fa193ab75" translate="yes" xml:space="preserve">
          <source>Example code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13825fbbe0e6a04ddd4cc33768ddf9b985e737bb" translate="yes" xml:space="preserve">
          <source>Example of a minimal TypeScript project with strict type-checking for attributes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5b7e6318c218c5d388eb7bcf998f3060d64fb90" translate="yes" xml:space="preserve">
          <source>Example of a minimal TypeScript project:</source>
          <target state="translated">최소 TypeScript 프로젝트의 예 :</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="aec767b3ae4b216fc03e8adcc7582fa085418561" translate="yes" xml:space="preserve">
          <source>Examples with &lt;code&gt;Op.and&lt;/code&gt; and &lt;code&gt;Op.or&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db8dfa89274dbc41394b75d4fec3ab9092279b3e" translate="yes" xml:space="preserve">
          <source>Examples with &lt;code&gt;Op.not&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="58d18114e1738a1e0f6bfe569a75a8f60da8421d" translate="yes" xml:space="preserve">
          <source>ExclusionConstraintError</source>
          <target state="translated">ExclusionConstraintError</target>
        </trans-unit>
        <trans-unit id="533a4e4878244d5f688d35104f28db89f9340e32" translate="yes" xml:space="preserve">
          <source>Execute a query on the DB, optionally bypassing all the Sequelize goodness.</source>
          <target state="translated">선택적으로 모든 Sequelize goodness를 무시하고 DB에서 쿼리를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="aa91c9cca4f6493ac714adff353030085a6edafc" translate="yes" xml:space="preserve">
          <source>Execute a query which would set an environment or user variable.</source>
          <target state="translated">환경 또는 사용자 변수를 설정하는 쿼리를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="4e26bfe1c237fbd1223d10b2b27a4781c0002328" translate="yes" xml:space="preserve">
          <source>Execute a query which would set an environment or user variable. The variables are set per connection, so this function needs a transaction. Only works for MySQL.</source>
          <target state="translated">환경 또는 사용자 변수를 설정하는 쿼리를 실행하십시오. 변수는 연결마다 설정되므로이 기능에는 트랜잭션이 필요합니다. MySQL에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="3213e8faecb3d1137ce38a40c396141714bf3dd0" translate="yes" xml:space="preserve">
          <source>Expansion of models</source>
          <target state="translated">모델 확장</target>
        </trans-unit>
        <trans-unit id="4e2991b460fcf70aaefc7f3fc188ddf2588e1620" translate="yes" xml:space="preserve">
          <source>Extending &lt;a href=&quot;../class/lib/model.js~model&quot;&gt;Model&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8932ac693ed88dde63039fa07540cae01c6e8948" translate="yes" xml:space="preserve">
          <source>Extending &lt;a href=&quot;../class/lib/model.js~model&quot;&gt;Model&lt;/a&gt; and calling &lt;a href=&quot;../class/lib/model.js~model#static-method-init&quot;&gt;&lt;code&gt;init(attributes, options)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5593b0456ba26bd844491ca0b003653a8c80940a" translate="yes" xml:space="preserve">
          <source>Extending Data Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8bae6c2f3f966ce80f423eec549a45399974a21" translate="yes" xml:space="preserve">
          <source>Extending datatypes</source>
          <target state="translated">데이터 유형 확장</target>
        </trans-unit>
        <trans-unit id="ddf3071dc94d26c323c107229af8795c491bd816" translate="yes" xml:space="preserve">
          <source>Extends:</source>
          <target state="translated">Extends:</target>
        </trans-unit>
        <trans-unit id="3415fc8a568de218ad7dba688ff3ef7fbcf8579c" translate="yes" xml:space="preserve">
          <source>Extra-options for creation</source>
          <target state="translated">제작을위한 추가 옵션</target>
        </trans-unit>
        <trans-unit id="cd98ae36981ee80a267c314ec60000c7f9d30870" translate="yes" xml:space="preserve">
          <source>FLOAT</source>
          <target state="translated">FLOAT</target>
        </trans-unit>
        <trans-unit id="cc069309a71a6b082f46a01f71efc1df948b1806" translate="yes" xml:space="preserve">
          <source>FORCE</source>
          <target state="translated">FORCE</target>
        </trans-unit>
        <trans-unit id="314d411c2ac127d528e70955d9b8441f2a15fed9" translate="yes" xml:space="preserve">
          <source>FOREIGN KEY</source>
          <target state="translated">외래 키</target>
        </trans-unit>
        <trans-unit id="757a3b8b4ae4f48c692d91a87cc6208288a0a4a6" translate="yes" xml:space="preserve">
          <source>FOREIGNKEYS</source>
          <target state="translated">FOREIGNKEYS</target>
        </trans-unit>
        <trans-unit id="ee0d6b9ce405baeef49e77e5019757177ed1b69d" translate="yes" xml:space="preserve">
          <source>Fetch a Model which is already defined</source>
          <target state="translated">이미 정의 된 모델을 가져옵니다</target>
        </trans-unit>
        <trans-unit id="65398fb0dd2fcf1ce40900a5da8dce359368d457" translate="yes" xml:space="preserve">
          <source>Fetching a single associated element</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d7703328bfc5f3cff64f382e9d46db5014769f3" translate="yes" xml:space="preserve">
          <source>Fetching all associated elements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5ee3df20f5820aae8a0ed53419df5498ce4b0e8" translate="yes" xml:space="preserve">
          <source>Fetching an Aliased association</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2100fdf8c33fb8e1ebc4e40351da2abba466d896" translate="yes" xml:space="preserve">
          <source>Fetching associations - Eager Loading vs Lazy Loading</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c52b97116b81c0e32f959af4bd49aa15d069dd75" translate="yes" xml:space="preserve">
          <source>Fetching with &lt;code&gt;RIGHT OUTER JOIN&lt;/code&gt; (MySQL, MariaDB, PostgreSQL and MSSQL only)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8b685271238adf161cffed3c91f54d97023262b" translate="yes" xml:space="preserve">
          <source>Fields</source>
          <target state="translated">Fields</target>
        </trans-unit>
        <trans-unit id="992be6307b48dd72700480b89fd61a9fefdf7604" translate="yes" xml:space="preserve">
          <source>Fields to insert (defaults to all fields)</source>
          <target state="translated">삽입 할 필드 (기본값은 모든 필드)</target>
        </trans-unit>
        <trans-unit id="a218aeefeca1a6f49c3dfa1531a34d49d3fe7b77" translate="yes" xml:space="preserve">
          <source>Fields to update (defaults to all fields)</source>
          <target state="translated">업데이트 할 필드 (기본값은 모든 필드)</target>
        </trans-unit>
        <trans-unit id="b091566d89ffbcd813c47d6a123565260424f5b8" translate="yes" xml:space="preserve">
          <source>Fields to update if row key already exists (on duplicate key update)? (only supported by MySQL, MariaDB, SQLite &amp;gt;= 3.24.0 &amp;amp; Postgres &amp;gt;= 9.5). By default, all fields are updated.</source>
          <target state="translated">행 키가 이미 존재하는 경우 업데이트 할 필드 (중복 키 업데이트시)? (MySQL, MariaDB, SQLite&amp;gt; = 3.24.0 및 Postgres&amp;gt; = 9.5에서만 지원됨). 기본적으로 모든 필드가 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="2c3cafa4db3f3e1e51b3dff4303502dbe42b7a89" translate="yes" xml:space="preserve">
          <source>File</source>
          <target state="translated">File</target>
        </trans-unit>
        <trans-unit id="5c762281bad63293636bf5b69b9e20d4a164180b" translate="yes" xml:space="preserve">
          <source>Filter on the join model for belongsToMany relations</source>
          <target state="translated">belongsToMany 관계에 대한 조인 모델 필터링</target>
        </trans-unit>
        <trans-unit id="5ec9d27d20d87b6665bb72533c95b8633e4a2f14" translate="yes" xml:space="preserve">
          <source>Filter the destroy</source>
          <target state="translated">파괴를 필터링</target>
        </trans-unit>
        <trans-unit id="2c680ca846d2b1f9941c4a7e463ffdd91bad00da" translate="yes" xml:space="preserve">
          <source>Filter the restore</source>
          <target state="translated">복원 필터링</target>
        </trans-unit>
        <trans-unit id="96e578211aa295317cf257310712fa28ccd8f6c6" translate="yes" xml:space="preserve">
          <source>Filters</source>
          <target state="translated">Filters</target>
        </trans-unit>
        <trans-unit id="399c9c1fc08e2080bf0584c0bb87a998c58302ec" translate="yes" xml:space="preserve">
          <source>Finally you can specify a comment for the table in MySQL and PG</source>
          <target state="translated">마지막으로 MySQL 및 PG에서 테이블에 주석을 지정할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="4fdbfcfb42bceb07d23d06c8e44932b031c62ab5" translate="yes" xml:space="preserve">
          <source>Find a row that matches the query, or build (but don't save) the row if none is found. The successful result of the promise will be (instance, built)</source>
          <target state="translated">쿼리와 일치하는 행을 찾거나 행이 없으면 빌드하지는 않지만 저장하지는 마십시오. 약속의 성공적인 결과는 (인스턴스, 구축)</target>
        </trans-unit>
        <trans-unit id="787ebbba15c03ea377a68ba449b2d1b30838400a" translate="yes" xml:space="preserve">
          <source>Find a row that matches the query, or build and save the row if none is found The successful result of the promise will be (instance, created)</source>
          <target state="translated">쿼리와 일치하는 행을 찾거나없는 경우 행을 빌드하고 저장합니다. 약속의 성공적인 결과는 다음과 같습니다 (인스턴스, 작성).</target>
        </trans-unit>
        <trans-unit id="950d0b08b16231e46a1ceb42c488b82439475a87" translate="yes" xml:space="preserve">
          <source>Find all the rows matching your query, within a specified offset / limit, and get the total number of rows matching your query.</source>
          <target state="translated">지정된 오프셋 / 한계 내에서 쿼리와 일치하는 모든 행을 찾고 쿼리와 일치하는 총 행 수를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="657f4ed3571c830a929c71c2d55286283a27633f" translate="yes" xml:space="preserve">
          <source>Find all the rows matching your query, within a specified offset / limit, and get the total number of rows matching your query. This is very useful for paging</source>
          <target state="translated">지정된 오프셋 / 한계 내에서 쿼리와 일치하는 모든 행을 찾고 쿼리와 일치하는 총 행 수를 가져옵니다. 이것은 페이징에 매우 유용합니다</target>
        </trans-unit>
        <trans-unit id="921caff04811268180ac8aab2329507d3f93c78c" translate="yes" xml:space="preserve">
          <source>Find the maximum value of field</source>
          <target state="translated">필드의 최대 값 찾기</target>
        </trans-unit>
        <trans-unit id="39c1c73d728a68b1db9304ae8005152f31adb33c" translate="yes" xml:space="preserve">
          <source>Find the minimum value of field</source>
          <target state="translated">필드의 최소값 찾기</target>
        </trans-unit>
        <trans-unit id="130ffb115c68fb414d7e62375abe569bf8d4b9e2" translate="yes" xml:space="preserve">
          <source>Find the sum of field</source>
          <target state="translated">필드의 합을 구합니다</target>
        </trans-unit>
        <trans-unit id="1bd3192591ee5fdc21d4c042f9968ef0194ffbf6" translate="yes" xml:space="preserve">
          <source>Finder methods are intended to query data from the database. They do &lt;em&gt;not&lt;/em&gt; return plain objects but instead return model instances. Because finder methods return model instances you can call any model instance member on the result as described in the documentation for &lt;a href=&quot;instances&quot;&gt;&lt;em&gt;instances&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">파인더 메소드는 데이터베이스에서 데이터를 조회하기위한 것입니다. 일반 객체를 반환 하지 &lt;em&gt;않고&lt;/em&gt; 대신 모델 인스턴스를 반환합니다. 파인더 메소드는 모델 인스턴스를 리턴하므로 &lt;a href=&quot;instances&quot;&gt;&lt;em&gt;인스턴스&lt;/em&gt;&lt;/a&gt; 문서에 설명 된대로 결과에서 모델 인스턴스 멤버를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4e45b45f1d2c65530e3cc8c120534ceeb76375af" translate="yes" xml:space="preserve">
          <source>Finder methods are the ones that generate &lt;code&gt;SELECT&lt;/code&gt; queries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65c69533dcf5fc1b993572a47469370650252afa" translate="yes" xml:space="preserve">
          <source>First install &lt;code&gt;babel-register&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;babel-register&lt;/code&gt; 를 먼저 설치하십시오</target>
        </trans-unit>
        <trans-unit id="ff8bf30d704806b32d8f14071f06c356dd294231" translate="yes" xml:space="preserve">
          <source>First lets look at bulkCreate</source>
          <target state="translated">먼저 bulkCreate를 봅시다.</target>
        </trans-unit>
        <trans-unit id="3691c9e6e1f00c55d7d4476af7872c4024703674" translate="yes" xml:space="preserve">
          <source>First of all you can define a field and the value you want to add to it.</source>
          <target state="translated">먼저 필드와 추가 할 값을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9df15eba93973048357ed997639f3bef94575508" translate="yes" xml:space="preserve">
          <source>First you need to create a &lt;code&gt;.sequelizerc&lt;/code&gt; file in the root folder of your project. This file should override config path to a &lt;code&gt;JS&lt;/code&gt; file. Like this</source>
          <target state="translated">먼저 프로젝트의 루트 폴더에 &lt;code&gt;.sequelizerc&lt;/code&gt; 파일 을 만들어야합니다 . 이 파일은 &lt;code&gt;JS&lt;/code&gt; 파일의 구성 경로를 대체해야 합니다. 이렇게</target>
        </trans-unit>
        <trans-unit id="e73fc561d3cd75f464e29dcb9f3d3539e21bdf74" translate="yes" xml:space="preserve">
          <source>First, a simple example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb684fdaf4419e4483a38c7d5835018e360799cd" translate="yes" xml:space="preserve">
          <source>First, recall that the &lt;code&gt;A.belongsTo(B)&lt;/code&gt; association places the foreign key in the &lt;em&gt;source model&lt;/em&gt; (i.e., in &lt;code&gt;A&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46f08b9e0ac6ef5cd97661c9841bf33a8056fe1c" translate="yes" xml:space="preserve">
          <source>First, we note that:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7397423e15d2a454aac8c89d302ffd28fd522591" translate="yes" xml:space="preserve">
          <source>Fixer</source>
          <target state="translated">Fixer</target>
        </trans-unit>
        <trans-unit id="c50b9d4dbd2a8f882b28d3409c986e48b6b738ed" translate="yes" xml:space="preserve">
          <source>Fixtures / mock data</source>
          <target state="translated">비품 / 모의 데이터</target>
        </trans-unit>
        <trans-unit id="c31adb45dba809469678acd004ba95f1e373a97f" translate="yes" xml:space="preserve">
          <source>Floating point number (4-byte precision).</source>
          <target state="translated">부동 소수점 숫자 (4 바이트 정밀도).</target>
        </trans-unit>
        <trans-unit id="1cb6ae00fe9f4d1a554c2b9de7bbb8ed766592e8" translate="yes" xml:space="preserve">
          <source>Floating point number (8-byte precision).</source>
          <target state="translated">부동 소수점 숫자 (8 바이트 정밀도).</target>
        </trans-unit>
        <trans-unit id="f9e7ea792fcd904b739bd21e0ab1c77d56b2db44" translate="yes" xml:space="preserve">
          <source>For 1:1 and 1:m associations the default option is &lt;code&gt;SET NULL&lt;/code&gt; for deletion, and &lt;code&gt;CASCADE&lt;/code&gt; for updates. For n:m, the default for both is &lt;code&gt;CASCADE&lt;/code&gt;. This means, that if you delete or update a row from one side of an n:m association, all the rows in the join table referencing that row will also be deleted or updated.</source>
          <target state="translated">1 : 1 및 1 : m 연결의 경우 기본 옵션은 삭제의 경우 &lt;code&gt;SET NULL&lt;/code&gt; 이고 업데이트의 경우 &lt;code&gt;CASCADE&lt;/code&gt; 입니다. n : m의 경우 둘 다의 기본값은 &lt;code&gt;CASCADE&lt;/code&gt; 입니다. 즉, n : m 연결의 한 쪽에서 행을 삭제하거나 업데이트하면 해당 행을 참조하는 조인 테이블의 모든 행도 삭제되거나 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="b4ce924ceb57cb52e072969a141cd7fa53753068" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;belongsTo&lt;/code&gt; relationships</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4aa04d2f1256558446c461dbe54ae69e0e4f384" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;belongsToMany&lt;/code&gt; relationships</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcdd0af6d51c7d26e47d150496102565721d5679" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;hasOne&lt;/code&gt; and &lt;code&gt;hasMany&lt;/code&gt; relationships</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="166cef3a04f5801fa60f50c3992929ce02d69679" translate="yes" xml:space="preserve">
          <source>For PostgreSQL, two libraries are needed, &lt;code&gt;pg@^7.0.0&lt;/code&gt; and &lt;code&gt;pg-hstore&lt;/code&gt;. You'll just need to define the dialect:</source>
          <target state="translated">PostgreSQL의 경우 &lt;code&gt;pg@^7.0.0&lt;/code&gt; 및 &lt;code&gt;pg-hstore&lt;/code&gt; 의 두 라이브러리가 필요합니다 . 방언을 정의하기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="c52bbddae40d76ae399f0d2e8c2c0cce4b5472d1" translate="yes" xml:space="preserve">
          <source>For SQLite compatibility you'll need&lt;code&gt;sqlite3@^4.0.0&lt;/code&gt;. Configure Sequelize like this:</source>
          <target state="translated">SQLite 호환성을 위해서는 &lt;code&gt;sqlite3@^4.0.0&lt;/code&gt; 이 필요 합니다 . 다음과 같이 Sequelize를 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="d88898c19f358f3b7b0317837e9a40cbcb901542" translate="yes" xml:space="preserve">
          <source>For UUIDs, use &lt;code&gt;DataTypes.UUID&lt;/code&gt;. It becomes the &lt;code&gt;UUID&lt;/code&gt; data type for PostgreSQL and SQLite, and &lt;code&gt;CHAR(36)&lt;/code&gt; for MySQL. Sequelize can generate UUIDs automatically for these fields, simply use &lt;code&gt;Sequelize.UUIDV1&lt;/code&gt; or &lt;code&gt;Sequelize.UUIDV4&lt;/code&gt; as the default value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0316acf2d6bd2d9fbcb4f39ded69d32d41777734" translate="yes" xml:space="preserve">
          <source>For a better understanding of all differences between the inner &lt;code&gt;where&lt;/code&gt; option (used inside an &lt;code&gt;include&lt;/code&gt;), with and without the &lt;code&gt;required&lt;/code&gt; option, and a top-level &lt;code&gt;where&lt;/code&gt; using the &lt;code&gt;$nested.column$&lt;/code&gt; syntax, below we have four examples for you:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89b17a6578e9841e72d6cf1b5bf0dcc1985648f7" translate="yes" xml:space="preserve">
          <source>For a full list of hooks, see &lt;a href=&quot;https://github.com/sequelize/sequelize/blob/master/lib/hooks.js#L7&quot;&gt;Hooks file&lt;/a&gt;.</source>
          <target state="translated">후크의 전체 목록은 &lt;a href=&quot;https://github.com/sequelize/sequelize/blob/master/lib/hooks.js#L7&quot;&gt;후크 파일을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f863120d43b144b6a90ad2ff72b5b590dcb39aa6" translate="yes" xml:space="preserve">
          <source>For a managed transaction: the &lt;code&gt;sequelize.transaction&lt;/code&gt; call will wait for it before settling;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5334e3b0517de87f752ed7b20bdac5c27125cfe" translate="yes" xml:space="preserve">
          <source>For an unmanaged transaction: the &lt;code&gt;t.commit&lt;/code&gt; call will wait for it before settling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68128f148837e106dfab09a5ab8ecead3a265ea4" translate="yes" xml:space="preserve">
          <source>For better security it is highly advised to use symbol operators from &lt;code&gt;Sequelize.Op&lt;/code&gt; like &lt;code&gt;Op.and&lt;/code&gt; / &lt;code&gt;Op.or&lt;/code&gt; in your code and not depend on any string based operators like &lt;code&gt;$and&lt;/code&gt; / &lt;code&gt;$or&lt;/code&gt; at all. You can limit alias your application will need by setting &lt;code&gt;operatorsAliases&lt;/code&gt; option, remember to sanitize user input especially when you are directly passing them to Sequelize methods.</source>
          <target state="translated">더 나은 보안을 위해 그것은 매우에서 사용하는 기호 사업자에게 좋습니다 &lt;code&gt;Sequelize.Op&lt;/code&gt; 같은 &lt;code&gt;Op.and&lt;/code&gt; / &lt;code&gt;Op.or&lt;/code&gt; 코드에서와 같이 임의의 문자열 기반 사업자에 의존하지 &lt;code&gt;$and&lt;/code&gt; / &lt;code&gt;$or&lt;/code&gt; 전혀. &lt;code&gt;operatorsAliases&lt;/code&gt; 옵션 을 설정하여 응용 프로그램에 필요한 별칭을 제한 할 수 있습니다. 특히 사용자 입력을 Sequelize 메서드에 직접 전달할 때 사용자 입력을 삭제해야합니다.</target>
        </trans-unit>
        <trans-unit id="f16eb1304ddba8f79d3ea2768d2e785579e4c490" translate="yes" xml:space="preserve">
          <source>For brevity, the example only shows a Post model, but in reality Tag would be related to several other models.</source>
          <target state="translated">간결하게하기 위해이 예에서는 Post 모델 만 표시하지만 실제로 Tag는 다른 여러 모델과 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="32403961f9e9492bfe929e9baa09c74ec79b6df4" translate="yes" xml:space="preserve">
          <source>For creating complex counts. Will return multiple rows as needed.</source>
          <target state="translated">복잡한 카운트를 생성합니다. 필요에 따라 여러 행을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a8793c15ddf5531e9c1c30f2ebb28ddbc00e860d" translate="yes" xml:space="preserve">
          <source>For details see the &lt;a href=&quot;https://github.com/sequelize/cli&quot;&gt;CLI GitHub repository&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="441826693df3e8a3748c8d2e6c8dba411b9548c3" translate="yes" xml:space="preserve">
          <source>For example, consider the models &lt;code&gt;Image&lt;/code&gt;, &lt;code&gt;Video&lt;/code&gt; and &lt;code&gt;Comment&lt;/code&gt;. The first two represent something that a user might post. We want to allow comments to be placed in both of them. This way, we immediately think of establishing the following associations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4fb05ef47083533e499e4b461e2d05438aee39e" translate="yes" xml:space="preserve">
          <source>For example, if we have two models, &lt;code&gt;Foo&lt;/code&gt; and &lt;code&gt;Bar&lt;/code&gt;, and they are associated, their instances will have the following methods/mixins available, depending on the association type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86e4459ee22878d56ce74dfd9d778af78d95dcab" translate="yes" xml:space="preserve">
          <source>For example, in PostgreSQL, the above setup will yield the following SQL upon &lt;code&gt;sync()&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ad237277212dade5ad18401931779e6e7044d4e" translate="yes" xml:space="preserve">
          <source>For example, let's say we have the &lt;code&gt;firstName&lt;/code&gt; and &lt;code&gt;lastName&lt;/code&gt; attributes for a User.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abad332654ea013c8f3d31b41a60315bf5595a0a" translate="yes" xml:space="preserve">
          <source>For example, to configure the &lt;code&gt;ON DELETE&lt;/code&gt; and &lt;code&gt;ON UPDATE&lt;/code&gt; behaviors, you can do:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8568084c5ddc0ae1aa670ce522722f4f796bb953" translate="yes" xml:space="preserve">
          <source>For example, to use &lt;code&gt;UUID&lt;/code&gt; as the foreign key data type instead of the default (&lt;code&gt;INTEGER&lt;/code&gt;), you can simply do:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f68fce02aced8e6459f61328bbbaacdf1db3f592" translate="yes" xml:space="preserve">
          <source>For example, we can asynchronously obtain a database password from a rotating token store, and mutate Sequelize's configuration object with the new credentials:</source>
          <target state="translated">예를 들어, 회전하는 토큰 저장소에서 데이터베이스 비밀번호를 비동기 적으로 확보하고 새 신임 정보로 Sequelize의 구성 오브젝트를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa6c7a73ad90d75d4b39a6f5cf78e6adc6923282" translate="yes" xml:space="preserve">
          <source>For hasOne/belongsTo it's basically the same:</source>
          <target state="translated">hasOne / belongsTo의 경우 기본적으로 동일합니다.</target>
        </trans-unit>
        <trans-unit id="d4ded29545acf7b9b521d83a705d06d10cd604b1" translate="yes" xml:space="preserve">
          <source>For managed transactions, use &lt;code&gt;sequelize.transaction(options, callback)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cab93a06a66637337f33f00e08b1e0a8c44314d" translate="yes" xml:space="preserve">
          <source>For methods that take values, like &lt;code&gt;.create&lt;/code&gt;, &lt;code&gt;.update()&lt;/code&gt;, etc. &lt;code&gt;transaction&lt;/code&gt; should be passed to the option in the second argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31bbe0ca24420147043099fd299663084c1b6bdf" translate="yes" xml:space="preserve">
          <source>For more about &lt;a href=&quot;https://sequelize.org/manual/tutorial/models-definition.html#validations&quot;&gt;Validations&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://sequelize.org/manual/tutorial/models-definition.html#validations&quot;&gt;유효성 검사에&lt;/a&gt; 대한 자세한 내용</target>
        </trans-unit>
        <trans-unit id="04db5e8a3c35ba73b4b781f923b1f3cb89bda5c2" translate="yes" xml:space="preserve">
          <source>For starters, let's create an empty file in the root directory of your project.</source>
          <target state="translated">우선, 프로젝트의 루트 디렉토리에 빈 파일을 만들어 봅시다.</target>
        </trans-unit>
        <trans-unit id="8869607afba1c497f7ebf21fbf6107636e23412f" translate="yes" xml:space="preserve">
          <source>For string attributes, use the regular &lt;code&gt;{ where: { attr: something }}&lt;/code&gt; syntax. If you don't want your string to be escaped, use &lt;code&gt;sequelize.literal&lt;/code&gt;.</source>
          <target state="translated">문자열 속성의 경우 일반 &lt;code&gt;{ where: { attr: something }}&lt;/code&gt; 구문을 사용하십시오. 문자열을 이스케이프하지 않으려면 &lt;code&gt;sequelize.literal&lt;/code&gt; 을 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="7fdeeb519ef1b18d9836595c51d8d66189bf2e6e" translate="yes" xml:space="preserve">
          <source>For the most part hooks will work the same for instances when being associated except a few things</source>
          <target state="translated">대부분의 경우 후크는 몇 가지 사항을 제외하고 연관된 인스턴스에 대해 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="79e50b2785e58d0d5a8108830c47a800c341a17e" translate="yes" xml:space="preserve">
          <source>For the most part hooks will work the same for instances when being associated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="919452e5c8036321e81f5c9b59a22946dabf84b1" translate="yes" xml:space="preserve">
          <source>For the rest of this example, let's assume that we have two models, &lt;code&gt;Foo&lt;/code&gt; and &lt;code&gt;Bar&lt;/code&gt;. We want to setup a One-To-One relationship between them such that &lt;code&gt;Bar&lt;/code&gt; gets a &lt;code&gt;fooId&lt;/code&gt; column.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14286767c7f0bf38401870d4ff77ad551e5ec000" translate="yes" xml:space="preserve">
          <source>For the sake of an example, let's say we are modeling a &lt;code&gt;Post&lt;/code&gt;, whose &lt;code&gt;content&lt;/code&gt; is a text of unlimited length. To improve memory usage, let's say we want to store a gzipped version of the content.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34429e7d26d5ca90a7dab21b6fa3d746ca222431" translate="yes" xml:space="preserve">
          <source>For this example, we will consider the models &lt;code&gt;Movie&lt;/code&gt; and &lt;code&gt;Actor&lt;/code&gt;. One actor may have participated in many movies, and one movie had many actors involved with its production. The junction table that will keep track of the associations will be called &lt;code&gt;ActorMovies&lt;/code&gt;, which will contain the foreign keys &lt;code&gt;movieId&lt;/code&gt; and &lt;code&gt;actorId&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6c8a437c823fae4129407f81b8e5d25e7b9dcc0" translate="yes" xml:space="preserve">
          <source>For this guide, the following setup will be assumed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54dd5ce5f0fd79fc38c68155b6bbf4389753112c" translate="yes" xml:space="preserve">
          <source>For this tutorial, the following setup will be assumed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4e6735666cff2a8506e46637e28b3671fcee3e8" translate="yes" xml:space="preserve">
          <source>For unmanaged transactions, just use &lt;code&gt;sequelize.transaction(options)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="211df75dd2f625308400095e0aa85c4a6e7a1c65" translate="yes" xml:space="preserve">
          <source>Force the query to use the write pool, regardless of the query type.</source>
          <target state="translated">쿼리 유형에 관계없이 쿼리가 쓰기 풀을 사용하도록합니다.</target>
        </trans-unit>
        <trans-unit id="529eee92fed5ed996f9dea4b7c1c951261cb8d07" translate="yes" xml:space="preserve">
          <source>Foreign Key</source>
          <target state="translated">외래 키</target>
        </trans-unit>
        <trans-unit id="2ee372205e15d8140654b1f5e4b497dd3fb87773" translate="yes" xml:space="preserve">
          <source>Foreign Keys</source>
          <target state="translated">외래 키</target>
        </trans-unit>
        <trans-unit id="59ede0e2e22f66178ef87fc65a758931fe2077cc" translate="yes" xml:space="preserve">
          <source>Foreign keys</source>
          <target state="translated">외래 키</target>
        </trans-unit>
        <trans-unit id="69a3add3c0f82c03a04b218b0511f0e66c3405c8" translate="yes" xml:space="preserve">
          <source>ForeignKeyConstraintError</source>
          <target state="translated">ForeignKeyConstraintError</target>
        </trans-unit>
        <trans-unit id="6f778a422d44fa6b44b00f5f10a262af846a058d" translate="yes" xml:space="preserve">
          <source>From class &lt;a href=&quot;../abstract/query-interface.js~queryinterface&quot;&gt;QueryInterface&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adf462e2a6ba9ff36e0e6811820bfbb9431fdd79" translate="yes" xml:space="preserve">
          <source>From class &lt;a href=&quot;base.js~association&quot;&gt;Association&lt;/a&gt;</source>
          <target state="translated">수업 &lt;a href=&quot;base.js~association&quot;&gt;협회에서&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="06ac84914781f4af68d5a72575d216973b6acc03" translate="yes" xml:space="preserve">
          <source>From now on, we will call &lt;code&gt;queryInterface&lt;/code&gt; the singleton instance of the &lt;a href=&quot;../class/lib/dialects/abstract/query-interface.js~queryinterface&quot;&gt;QueryInterface&lt;/a&gt; class, which is available on your Sequelize instance:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1e410ad1472b42cb42cc98962428637290b6706" translate="yes" xml:space="preserve">
          <source>Function</source>
          <target state="translated">Function</target>
        </trans-unit>
        <trans-unit id="250f82c65e6facf5fd4fc074ab87a259cffa3f4b" translate="yes" xml:space="preserve">
          <source>GEOGRAPHY</source>
          <target state="translated">GEOGRAPHY</target>
        </trans-unit>
        <trans-unit id="27efcce7f2dcd678e80237d0773a89dad445555a" translate="yes" xml:space="preserve">
          <source>GEOMETRY</source>
          <target state="translated">GEOMETRY</target>
        </trans-unit>
        <trans-unit id="45c94c6df17fcba36c6473c4cdbbece07a403b16" translate="yes" xml:space="preserve">
          <source>Generated SQL (using MySQL):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0268be2213733a8c67f7756e7b3c5a710c2eb0e" translate="yes" xml:space="preserve">
          <source>Generated SQL (using PostgreSQL):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6cca81b0eb9876cd4909e0d9b57556fc54a4f46" translate="yes" xml:space="preserve">
          <source>Generated SQL (using SQLite):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd6234b0fcc953f32ce9e302a8b83f88ef78358f" translate="yes" xml:space="preserve">
          <source>Generated SQL:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7978d028f6cb8150ba230587b87118b98486f723" translate="yes" xml:space="preserve">
          <source>Generated SQLs, in order:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="663ae8086b179bf6bacd13c1aa3a3d3e1ff4390c" translate="yes" xml:space="preserve">
          <source>Generated where clause:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e10289922ac926833e39eea42788ac374af6580" translate="yes" xml:space="preserve">
          <source>GeoJSON is accepted as input and returned as output.</source>
          <target state="translated">GeoJSON은 입력으로 받아 들여지고 출력으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="72bcf5e76e57548caa290e36d582dfae4d6090a9" translate="yes" xml:space="preserve">
          <source>Get an object representing the query for this instance, use with &lt;code&gt;options.where&lt;/code&gt;</source>
          <target state="translated">이 인스턴스에 대한 쿼리를 나타내는 객체를 가져옵니다. &lt;code&gt;options.where&lt;/code&gt; 와 함께 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d2fea989c8ec7c43b1340650323a0178a28c6a89" translate="yes" xml:space="preserve">
          <source>Get everything currently associated with this, using an optional where clause.</source>
          <target state="translated">선택적 where 절을 사용하여 현재 이와 관련된 모든 것을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="886fde2920a5e02bf2bfd8bcc2bdd26cdd5a5735" translate="yes" xml:space="preserve">
          <source>Get foreign key references details for the table</source>
          <target state="translated">테이블에 대한 외래 키 참조 세부 사항 가져 오기</target>
        </trans-unit>
        <trans-unit id="549f6341c48bcf68c253346fa28ed00691fed576" translate="yes" xml:space="preserve">
          <source>Get the associated instance.</source>
          <target state="translated">연결된 인스턴스를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="7127a78c21cd3d8c20ee4fb5a952f17c883be460" translate="yes" xml:space="preserve">
          <source>Get the fn for random based on the dialect</source>
          <target state="translated">방언에 따라 무작위로 fn을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="cb52d521a2eae3bd73157d7eff418568485f2f89" translate="yes" xml:space="preserve">
          <source>Get the table name of the model, taking schema into account.</source>
          <target state="translated">스키마를 고려하여 모델의 테이블 이름을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="d6d9a3a0737e1c044f7f5194ac931cd09c81eeee" translate="yes" xml:space="preserve">
          <source>Get the table name of the model, taking schema into account. The method will return The name as a string if the model has no schema, or an object with &lt;code&gt;tableName&lt;/code&gt;, &lt;code&gt;schema&lt;/code&gt; and &lt;code&gt;delimiter&lt;/code&gt; properties.</source>
          <target state="translated">스키마를 고려하여 모델의 테이블 이름을 가져옵니다. 모델에 스키마가 없거나 &lt;code&gt;tableName&lt;/code&gt; , &lt;code&gt;schema&lt;/code&gt; 및 &lt;code&gt;delimiter&lt;/code&gt; 속성을 가진 객체가있는 경우이 메서드는 이름을 문자열로 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="d4ba2d5d8b010b8e362629cdbb02df41c96a1f90" translate="yes" xml:space="preserve">
          <source>Get the value of the underlying data value</source>
          <target state="translated">기본 데이터 값을 가져옵니다</target>
        </trans-unit>
        <trans-unit id="5063f7dc2abd60e0acc5cda5827c0c6e7683db14" translate="yes" xml:space="preserve">
          <source>Get un-scoped model</source>
          <target state="translated">범위가 지정되지 않은 모델 얻기</target>
        </trans-unit>
        <trans-unit id="9cadae030cb7ca06efe702854aaad1856364fe09" translate="yes" xml:space="preserve">
          <source>Gets all validation error items for the path / field specified.</source>
          <target state="translated">지정된 경로 / 필드에 대한 모든 유효성 검사 오류 항목을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="3bbbe89e1bf4029f9a507d85d668e0d1d5478d40" translate="yes" xml:space="preserve">
          <source>Getters</source>
          <target state="translated">Getters</target>
        </trans-unit>
        <trans-unit id="29b2ed1e86e469631197a2a7932bdfc23e808578" translate="yes" xml:space="preserve">
          <source>Getters &amp;amp; setters</source>
          <target state="translated">게터와 세터</target>
        </trans-unit>
        <trans-unit id="d4d0ee826886f86ab524da8084a390f851f7a730" translate="yes" xml:space="preserve">
          <source>Getters and Setters can be defined in 2 ways (you can mix and match these 2 approaches):</source>
          <target state="translated">게터와 세터는 두 가지 방법으로 정의 할 수 있습니다 (이 두 가지 접근 방식을 혼합하여 일치시킬 수 있음).</target>
        </trans-unit>
        <trans-unit id="4769d31ded30b746f20e3a883096015f17c54108" translate="yes" xml:space="preserve">
          <source>Getters and setters can be both defined in the same field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e3d68aebc663dc5df0a1d21122f5bf91cffb0ba" translate="yes" xml:space="preserve">
          <source>Getters, Setters &amp;amp; Virtuals</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="010b85ad56b34c34c7c2a3b2436c740e30428ed5" translate="yes" xml:space="preserve">
          <source>Getting Started</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76e7a3a3f9c225fe820ba7e9cff10ea2a73b79a1" translate="yes" xml:space="preserve">
          <source>Getting started</source>
          <target state="translated">시작하기</target>
        </trans-unit>
        <trans-unit id="8d7da2f2108339b82ee618f582152ef74b008a8f" translate="yes" xml:space="preserve">
          <source>Global / universal hooks</source>
          <target state="translated">글로벌 / 범용 후크</target>
        </trans-unit>
        <trans-unit id="98967f63d7b035a44fd97cab8f26d31e767df876" translate="yes" xml:space="preserve">
          <source>Global hooks are hooks which are run for all models. They can define behaviours that you want for all your models, and are especially useful for plugins. They can be defined in two ways, which have slightly different semantics:</source>
          <target state="translated">글로벌 후크는 모든 모델에 대해 실행되는 후크입니다. 모든 모델에 대해 원하는 동작을 정의 할 수 있으며 특히 플러그인에 유용합니다. 시맨틱이 약간 다른 두 가지 방법으로 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fe00acebc106e4dba1611cdd1d7dc308a244991" translate="yes" xml:space="preserve">
          <source>Goal</source>
          <target state="translated">Goal</target>
        </trans-unit>
        <trans-unit id="2ae6967b07a45b63c8543a6c5e34052414ba32af" translate="yes" xml:space="preserve">
          <source>Grouping</source>
          <target state="translated">Grouping</target>
        </trans-unit>
        <trans-unit id="713a22cbd20899d6556f6445e17e0b0df441a8e4" translate="yes" xml:space="preserve">
          <source>HSTORE</source>
          <target state="translated">HSTORE</target>
        </trans-unit>
        <trans-unit id="a145d9919b1826c52ff91b695b21fed544ff5d43" translate="yes" xml:space="preserve">
          <source>Had we tried to use &lt;code&gt;this.username&lt;/code&gt; in the getter instead, we would have gotten an infinite loop! This is why Sequelize provides the &lt;code&gt;getDataValue&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92789234d7e25be07f8afca4bcff8e4eca67bd7b" translate="yes" xml:space="preserve">
          <source>HasMany</source>
          <target state="translated">HasMany</target>
        </trans-unit>
        <trans-unit id="fc80823e85d5baf1626959c05da1c05516e14b37" translate="yes" xml:space="preserve">
          <source>HasMany / BelongsToMany association</source>
          <target state="translated">HasMany / BelongsToMany 협회</target>
        </trans-unit>
        <trans-unit id="bd0422a6e4667f9fd25c225c8354b9031b11095b" translate="yes" xml:space="preserve">
          <source>HasOne</source>
          <target state="translated">HasOne</target>
        </trans-unit>
        <trans-unit id="75d53992a2aa7a9af9fea66c1bb748cdaad23a04" translate="yes" xml:space="preserve">
          <source>HasOne and BelongsTo insert the association key in different models from each other. HasOne inserts the association key in &lt;strong&gt;target&lt;/strong&gt; model whereas BelongsTo inserts the association key in the &lt;strong&gt;source&lt;/strong&gt; model.</source>
          <target state="translated">HasOne 및 Belongs 서로 다른 모델에 연관 키를 삽입합니다. HasOne은 &lt;strong&gt;대상&lt;/strong&gt; 모델에 연관 키를 삽입하는 반면, AssignsTo는 &lt;strong&gt;소스&lt;/strong&gt; 모델 에 연관 키를 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="076c84709ba8c75bd1ff3bf1abc6c06bccb66654" translate="yes" xml:space="preserve">
          <source>HasOne associations are associations where the foreign key for the one-to-one relation exists on the &lt;strong&gt;target model&lt;/strong&gt;.</source>
          <target state="translated">HasOne 연관은 일대일 관계에 대한 외래 키가 &lt;strong&gt;대상 모델&lt;/strong&gt; 에 존재하는 연관 입니다.</target>
        </trans-unit>
        <trans-unit id="b8e63ff3de326026e493f5faa78d9c4bb875ad77" translate="yes" xml:space="preserve">
          <source>Hash of data values to create new record with</source>
          <target state="translated">새로운 레코드를 생성하기위한 데이터 값 해시</target>
        </trans-unit>
        <trans-unit id="16e57d6cfdb6027ca21e69d2c248bf6d7e1e1e5e" translate="yes" xml:space="preserve">
          <source>Having &lt;strong&gt;Player&lt;/strong&gt; as the &lt;strong&gt;source&lt;/strong&gt; and &lt;strong&gt;Team&lt;/strong&gt; as the &lt;strong&gt;target&lt;/strong&gt;</source>
          <target state="translated">갖는 &lt;strong&gt;플레이어&lt;/strong&gt; 는 AS &lt;strong&gt;소스&lt;/strong&gt; 와 &lt;strong&gt;팀&lt;/strong&gt; 은 AS &lt;strong&gt;대상&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="959db0b3adf835aecd4d86bf6cb2c39e5ee972cd" translate="yes" xml:space="preserve">
          <source>Having &lt;strong&gt;Team&lt;/strong&gt; as the &lt;strong&gt;source&lt;/strong&gt; and &lt;strong&gt;Player&lt;/strong&gt; as the &lt;strong&gt;target&lt;/strong&gt;</source>
          <target state="translated">갖는 &lt;strong&gt;팀&lt;/strong&gt; 은 AS &lt;strong&gt;소스&lt;/strong&gt; 와 &lt;strong&gt;플레이어&lt;/strong&gt; 는 AS &lt;strong&gt;대상&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="baf542c6a886f2170e6594b0cd4c2ad52976c234" translate="yes" xml:space="preserve">
          <source>Having options</source>
          <target state="translated">옵션 있음</target>
        </trans-unit>
        <trans-unit id="8421e2a51a8261b6660fa9c0a9fd6e14eb653c86" translate="yes" xml:space="preserve">
          <source>Helper functions for use inside getter and setter definitions</source>
          <target state="translated">게터 및 세터 정의 내부에서 사용하기위한 도우미 함수</target>
        </trans-unit>
        <trans-unit id="24c3d9b4e0e40c927afc8e7965f44190f7b0a7ad" translate="yes" xml:space="preserve">
          <source>Helper method to determine if a instance is &quot;soft deleted&quot;.</source>
          <target state="translated">인스턴스가 &quot;소프트 삭제&quot;되었는지 확인하는 도우미 메서드</target>
        </trans-unit>
        <trans-unit id="15900e9e0261074339464c903170431feba6def9" translate="yes" xml:space="preserve">
          <source>Helper method to determine if a instance is &quot;soft deleted&quot;. This is particularly useful if the implementer renamed the &lt;code&gt;deletedAt&lt;/code&gt; attribute to something different. This method requires &lt;code&gt;paranoid&lt;/code&gt; to be enabled.</source>
          <target state="translated">인스턴스가 &quot;소프트 삭제&quot;되었는지 확인하는 도우미 메서드 이것은 구현 &lt;code&gt;deletedAt&lt;/code&gt; 속성의 이름 을 다른 것으로 바꾼 경우에 특히 유용합니다 . 이 방법을 사용하려면 &lt;code&gt;paranoid&lt;/code&gt; 을 활성화 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="74b5b0e337605288491d3919c18791d4428323a7" translate="yes" xml:space="preserve">
          <source>Here is an example demonstrating use cases of BelongsTo and HasOne.</source>
          <target state="translated">다음은 ContainssTo 및 HasOne의 사용 사례를 보여주는 예입니다.</target>
        </trans-unit>
        <trans-unit id="540ee2aaf7182c6dfc449b18e5accb694e3b0894" translate="yes" xml:space="preserve">
          <source>Here is an example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c526e01d78df0d88e184c85be4505b4a091ed47f" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;deleted&lt;/code&gt; scope is merged with the finder. If we were to pass &lt;code&gt;where: { firstName: 'john', deleted: false }&lt;/code&gt; to the finder, the &lt;code&gt;deleted&lt;/code&gt; scope would be overwritten.</source>
          <target state="translated">여기서 &lt;code&gt;deleted&lt;/code&gt; 범위는 파인더와 병합됩니다. 우리가 통과한다면 &lt;code&gt;where: { firstName: 'john', deleted: false }&lt;/code&gt; 파인더에의 &lt;code&gt;deleted&lt;/code&gt; 범위는 덮어 될 것이다.</target>
        </trans-unit>
        <trans-unit id="0c3147f35fe7dc89058e9ae58c355036031d0914" translate="yes" xml:space="preserve">
          <source>Here we can see that &lt;code&gt;`comment`.`commentableType` = 'image'&lt;/code&gt; was automatically added to the &lt;code&gt;WHERE&lt;/code&gt; clause of the generated SQL. This is exactly the behavior we want.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfa600773b6369b2ffc2b8f9feb2d7c8dc0d9999" translate="yes" xml:space="preserve">
          <source>Here we can see that &lt;code&gt;`tag_taggable`.`taggableType` = 'image'&lt;/code&gt; was automatically added to the &lt;code&gt;WHERE&lt;/code&gt; clause of the generated SQL. This is exactly the behavior we want.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c42c0fb8b9ab6f18defe795bd9f6de91b6aca7b" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;tasks[0].user instanceof User&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. This shows that when Sequelize fetches associated models, they are added to the output object as model instances.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9afa5e334e28c0ce37c5ef76de0154fcbd75e3db" translate="yes" xml:space="preserve">
          <source>Here, our user model is called &lt;code&gt;user&lt;/code&gt;, with a lowercase u - This means that the property in the object should also be &lt;code&gt;user&lt;/code&gt;. If the name given to &lt;code&gt;sequelize.define&lt;/code&gt; was &lt;code&gt;User&lt;/code&gt;, the key in the object should also be &lt;code&gt;User&lt;/code&gt;. Likewise for &lt;code&gt;addresses&lt;/code&gt;, except it's pluralized being a &lt;code&gt;hasMany&lt;/code&gt; association.</source>
          <target state="translated">여기서, 우리의 사용자 모델은 &lt;code&gt;user&lt;/code&gt; 이며, 소문자 u-이것은 객체의 속성도 &lt;code&gt;user&lt;/code&gt; 여야 함을 의미합니다 . &lt;code&gt;sequelize.define&lt;/code&gt; 에 지정된 이름 이 &lt;code&gt;User&lt;/code&gt; 인 경우 개체의 키도 &lt;code&gt;User&lt;/code&gt; 여야합니다 . &lt;code&gt;hasMany&lt;/code&gt; 연관으로 복수화되는 것을 제외하고 는 &lt;code&gt;addresses&lt;/code&gt; 에 대해서도 마찬가지입니다 .</target>
        </trans-unit>
        <trans-unit id="139103af93155175db170f4086701037ce627db7" translate="yes" xml:space="preserve">
          <source>Hierarchies</source>
          <target state="translated">Hierarchies</target>
        </trans-unit>
        <trans-unit id="4c2c702395b304a44afd07f98c51e1749b23060d" translate="yes" xml:space="preserve">
          <source>Historical records / Time travel</source>
          <target state="translated">역사 기록 / 시간 여행</target>
        </trans-unit>
        <trans-unit id="4bd8f3f03a576b2088bd73a2339d07fca1de805d" translate="yes" xml:space="preserve">
          <source>Hooks</source>
          <target state="translated">Hooks</target>
        </trans-unit>
        <trans-unit id="4212538b69426994af61524680ab6c713fab4826" translate="yes" xml:space="preserve">
          <source>Hooks (also known as lifecycle events), are functions which are called before and after calls in sequelize are executed. For example, if you want to always set a value on a model before saving it, you can add a &lt;code&gt;beforeUpdate&lt;/code&gt; hook.</source>
          <target state="translated">후크 (라이프 사이클 이벤트라고도 함)는 시퀀스에서 호출이 실행되기 전후에 호출되는 함수입니다. 예를 들어, 모델을 저장하기 전에 항상 값을 설정하려면 &lt;code&gt;beforeUpdate&lt;/code&gt; 후크를 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="16ec897a4973cc950eb026afaf41aeabc7ba5447" translate="yes" xml:space="preserve">
          <source>Hooks and Transactions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69e818ce65e0ce8f34803157368c0e226e7e2738" translate="yes" xml:space="preserve">
          <source>Hooks firing order</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f00c9b0e6957fcef4079e622b05e8f359ef558dc" translate="yes" xml:space="preserve">
          <source>HostNotFoundError</source>
          <target state="translated">HostNotFoundError</target>
        </trans-unit>
        <trans-unit id="df98405c75e3d2293644f3903f9ba376eecd65dd" translate="yes" xml:space="preserve">
          <source>HostNotReachableError</source>
          <target state="translated">HostNotReachableError</target>
        </trans-unit>
        <trans-unit id="deb41f9eccd872d97cae66101673dc591a3dd320" translate="yes" xml:space="preserve">
          <source>How many rows to delete</source>
          <target state="translated">삭제할 행 수</target>
        </trans-unit>
        <trans-unit id="55c6fc1c78b7f02391f35f14b313aa07ac416870" translate="yes" xml:space="preserve">
          <source>How many rows to undelete (only for mysql)</source>
          <target state="translated">삭제를 취소 할 행 수 (mysql 만 해당)</target>
        </trans-unit>
        <trans-unit id="c74419ff22ba551918695ec2d4d452f7e5aafa8c" translate="yes" xml:space="preserve">
          <source>How many rows to update (only for mysql and mariadb, implemented as TOP(n) for MSSQL; for sqlite it is supported only when rowid is present)</source>
          <target state="translated">업데이트 할 행 수 (mysql 및 mariadb 만 해당, MSSQL의 경우 TOP (n)으로 구현, sqlite의 경우 rowid가있는 경우에만 지원됨)</target>
        </trans-unit>
        <trans-unit id="6ae043fac4f95946de2cb5d70a20b98cbb4b4075" translate="yes" xml:space="preserve">
          <source>How many times a failing query is automatically retried.</source>
          <target state="translated">실패한 쿼리가 자동으로 재 시도되는 횟수입니다.</target>
        </trans-unit>
        <trans-unit id="bcd7ff308853d4934c2fcd304af01bbf8af438f7" translate="yes" xml:space="preserve">
          <source>How many times a failing query is automatically retried. Set to 0 to disable retrying on SQL_BUSY error.</source>
          <target state="translated">실패한 쿼리가 자동으로 재 시도되는 횟수입니다. SQL_BUSY 오류에서 재 시도를 사용하지 않으려면 0으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="cb9871e1bb1811c7e92e66eae26e9dbdc2227fce" translate="yes" xml:space="preserve">
          <source>However, adding &lt;code&gt;hooks: true&lt;/code&gt; explicitly tells Sequelize that optimization is not of your concern and will perform a &lt;code&gt;SELECT&lt;/code&gt; on the associated objects and destroy each instance one by one in order to be able to call the hooks with the right parameters.</source>
          <target state="translated">그러나 &lt;code&gt;hooks: true&lt;/code&gt; 추가하면 Sequelize에 최적화가 중요하지 않다고 알려주고 올바른 매개 변수로 후크를 호출 할 수 있도록 연관된 객체에 대해 &lt;code&gt;SELECT&lt;/code&gt; 를 수행 하고 각 인스턴스를 하나씩 파괴합니다.</target>
        </trans-unit>
        <trans-unit id="a79c1cb05da0ee8017fa6549ca225f03e874cda9" translate="yes" xml:space="preserve">
          <source>However, adding &lt;code&gt;hooks: true&lt;/code&gt; explicitly tells Sequelize that optimization is not of your concern. Then, Sequelize will first perform a &lt;code&gt;SELECT&lt;/code&gt; on the associated objects and destroy each instance, one by one, in order to be able to properly call the hooks (with the right parameters).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0b8790fbcc51501c47abc10ab23a76f589256b5" translate="yes" xml:space="preserve">
          <source>However, by default, &lt;code&gt;bulkCreate&lt;/code&gt; does not run validations on each object that is going to be created (which &lt;code&gt;create&lt;/code&gt; does). To make &lt;code&gt;bulkCreate&lt;/code&gt; run these validations as well, you must pass the &lt;code&gt;validate: true&lt;/code&gt; option. This will decrease performance. Usage example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c58f70dd28133d7c5e6e6a4303ead204cbcfebbe" translate="yes" xml:space="preserve">
          <source>However, defining an alias here has nothing to do with the foreign key names. The names of both foreign keys created in the through table are still constructed by Sequelize based on the name of the models being associated. This can readily be seen by inspecting the generated SQL for the through table in the example above:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1afd8c120c736b4818f048890cf6b0cb6cbcb4ba" translate="yes" xml:space="preserve">
          <source>However, defining the model by ourselves has several advantages. We can, for example, define more columns on our through table:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2b8ea142713d4e18b2a52407b042919ba804f65" translate="yes" xml:space="preserve">
          <source>However, if getters and/or setters are defined for &lt;code&gt;field&lt;/code&gt; they will be invoked, instead of returning the value from &lt;code&gt;dataValues&lt;/code&gt;. Accessing properties directly or using &lt;code&gt;get&lt;/code&gt; is preferred for regular use, &lt;code&gt;getDataValue&lt;/code&gt; should only be used for custom getters.</source>
          <target state="translated">그러나 getter 및 / 또는 setter가 &lt;code&gt;field&lt;/code&gt; 에 대해 정의 된 경우 &lt;code&gt;dataValues&lt;/code&gt; 에서 값을 리턴하는 대신 호출됩니다 . 속성을 직접 액세스하거나 &lt;code&gt;get&lt;/code&gt; 을 사용 하는 것이 정기적으로 사용되는 것이 바람직하며 &lt;code&gt;getDataValue&lt;/code&gt; 는 사용자 정의 getter에만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="d8ad5f5b0cf3bc8e9af3c52f5db3be40f650855b" translate="yes" xml:space="preserve">
          <source>However, if you want only some of the attributes of the through table, you can provide an array with the attributes you want in the &lt;code&gt;attributes&lt;/code&gt; option. For example, if you only want the &lt;code&gt;selfGranted&lt;/code&gt; attribute from the through table:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d191358a866703a8af0d57f25666c38b8499366" translate="yes" xml:space="preserve">
          <source>However, please note that whenever you get back a value that is range you will receive:</source>
          <target state="translated">그러나 범위의 값을 되 찾을 때마다 다음을 받게됩니다.</target>
        </trans-unit>
        <trans-unit id="57ee5980b76ef1fd54e1974afc35c9eaacd378d6" translate="yes" xml:space="preserve">
          <source>However, retrieved range values always come in the form of an array of objects. For example, if the stored value is &lt;code&gt;(&quot;2016-01-01 00:00:00+00:00&quot;, &quot;2016-02-01 00:00:00+00:00&quot;]&lt;/code&gt;, after a finder query you will get:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da602e2f959c68339d173000e21a359c7ce8d0f1" translate="yes" xml:space="preserve">
          <source>However, the above would cause Sequelize to create two foreign keys on the &lt;code&gt;Comment&lt;/code&gt; table: &lt;code&gt;ImageId&lt;/code&gt; and &lt;code&gt;VideoId&lt;/code&gt;. This is not ideal because this structure makes it look like a comment can be attached at the same time to one image and one video, which isn't true. Instead, what we really want here is precisely a polymorphic association, in which a &lt;code&gt;Comment&lt;/code&gt; points to a single &lt;strong&gt;Commentable&lt;/strong&gt;, an abstract polymorphic entity that represents one of &lt;code&gt;Image&lt;/code&gt; or &lt;code&gt;Video&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0b524080e4dd905995f7327b976a6a202e22035" translate="yes" xml:space="preserve">
          <source>However, the code above does not communicate with the database at all (note that it is not even asynchronous)! This is because the &lt;a href=&quot;../class/lib/model.js~model#static-method-build&quot;&gt;&lt;code&gt;build&lt;/code&gt;&lt;/a&gt; method only creates an object that &lt;em&gt;represents&lt;/em&gt; data that &lt;em&gt;can&lt;/em&gt; be mapped to a database. In order to really save (i.e. persist) this instance in the database, the &lt;a href=&quot;../class/lib/model.js~model#instance-method-save&quot;&gt;&lt;code&gt;save&lt;/code&gt;&lt;/a&gt; method should be used:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="971b6559af147ead7fa90d836302f41e54b0377c" translate="yes" xml:space="preserve">
          <source>However, the code above will result in the following error: &lt;code&gt;Cyclic dependency found. documents is dependent of itself. Dependency chain: documents -&amp;gt; versions =&amp;gt; documents&lt;/code&gt;.</source>
          <target state="translated">그러나 위의 코드는 다음과 같은 오류가 발생합니다. &lt;code&gt;Cyclic dependency found. documents is dependent of itself. Dependency chain: documents -&amp;gt; versions =&amp;gt; documents&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="08194b4a0443aab1454ff47d2091a04d2c039f36" translate="yes" xml:space="preserve">
          <source>However, unfortunately the code above will result in the following error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1830eb27febdc5393b268a7772787a91c205863d" translate="yes" xml:space="preserve">
          <source>However, you can specify which attributes you want fetched. This is done with the &lt;code&gt;attributes&lt;/code&gt; option applied inside the &lt;code&gt;through&lt;/code&gt; option of the include. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9226f99dd645a71848cf0585c15059d7de868f4" translate="yes" xml:space="preserve">
          <source>IGNORE</source>
          <target state="translated">IGNORE</target>
        </trans-unit>
        <trans-unit id="8ae3e8381a64e36db57a5344790db89d7de90954" translate="yes" xml:space="preserve">
          <source>IMMEDIATE</source>
          <target state="translated">IMMEDIATE</target>
        </trans-unit>
        <trans-unit id="8f3bb7db433392fa9cd059cb669816e6111bb633" translate="yes" xml:space="preserve">
          <source>INET</source>
          <target state="translated">INET</target>
        </trans-unit>
        <trans-unit id="69c8af3292fb9fef906812e99c9acfa99a66fd97" translate="yes" xml:space="preserve">
          <source>INITIALLY_DEFERRED</source>
          <target state="translated">INITIALLY_DEFERRED</target>
        </trans-unit>
        <trans-unit id="d0a0d37857e35a2dc02ec4fe0c913bf1991b276e" translate="yes" xml:space="preserve">
          <source>INITIALLY_IMMEDIATE</source>
          <target state="translated">INITIALLY_IMMEDIATE</target>
        </trans-unit>
        <trans-unit id="c20ea07e32d25c072a65368c234d6f5a88f4521a" translate="yes" xml:space="preserve">
          <source>INSERT</source>
          <target state="translated">INSERT</target>
        </trans-unit>
        <trans-unit id="0fe37e40e5dab3ac411c2ddca6d21991e811acfa" translate="yes" xml:space="preserve">
          <source>INTEGER</source>
          <target state="translated">INTEGER</target>
        </trans-unit>
        <trans-unit id="06b6ace8ca3f18249e8ba4ea9090c0f34564ce1c" translate="yes" xml:space="preserve">
          <source>Identifier</source>
          <target state="translated">Identifier</target>
        </trans-unit>
        <trans-unit id="1a1bd379d222cf88ec4b5ea4426b87de1dc9cb3d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{ individualHooks: true }&lt;/code&gt; was passed to the call, then each individual hook will also run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9fdf457bfc8e4d5000783186983c15ac6bcde12" translate="yes" xml:space="preserve">
          <source>If a particular field of a model is set to not allow null (with &lt;code&gt;allowNull: false&lt;/code&gt;) and that value has been set to &lt;code&gt;null&lt;/code&gt;, all validators will be skipped and a &lt;code&gt;ValidationError&lt;/code&gt; will be thrown.</source>
          <target state="translated">모델의 특정 필드가 null을 허용하지 않도록 설정되고 ( &lt;code&gt;allowNull: false&lt;/code&gt; ) 해당 값이 &lt;code&gt;null&lt;/code&gt; 로 설정된 경우 모든 유효성 검증 기가 건너 뛰고 &lt;code&gt;ValidationError&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="80d19fa71b3b212078b2af9bb47612878b596815" translate="yes" xml:space="preserve">
          <source>If a single default schema per model is needed, set the &lt;code&gt;options.schema='schema'&lt;/code&gt; parameter during the &lt;code&gt;define()&lt;/code&gt; call for the model.</source>
          <target state="translated">모델 당 단일 기본 스키마가 필요한 경우 모델 의 &lt;code&gt;define()&lt;/code&gt; 호출 중에 &lt;code&gt;options.schema='schema'&lt;/code&gt; 매개 변수를 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="8ec2460c5c0105c3640d21141a54ba2c766998ff" translate="yes" xml:space="preserve">
          <source>If a string is provided, that column is decremented by the value of &lt;code&gt;by&lt;/code&gt; given in options. If an array is provided, the same is true for each column. If and object is provided, each column is decremented by the value given</source>
          <target state="translated">문자열이 제공되면 해당 열은 옵션 &lt;code&gt;by&lt;/code&gt; 지정된 by 값만큼 감소합니다 . 배열이 제공되면 각 열에 대해서도 동일합니다. 및 객체가 제공되면 각 열은 제공된 값만큼 감소합니다.</target>
        </trans-unit>
        <trans-unit id="a038ac481096e063842e82236359d80e84de916c" translate="yes" xml:space="preserve">
          <source>If a string is provided, that column is incremented by the value of &lt;code&gt;by&lt;/code&gt; given in options. If an array is provided, the same is true for each column. If and object is provided, each column is incremented by the value given.</source>
          <target state="translated">문자열이 제공되면 해당 열은 옵션 에 &lt;code&gt;by&lt;/code&gt; 주어진 값만큼 증가합니다 . 배열이 제공되면 각 열에 대해서도 동일합니다. 및 객체가 제공되면 각 열은 주어진 값만큼 증가합니다.</target>
        </trans-unit>
        <trans-unit id="4a7fcb8b0730043f8516c7419f01b231cdd5e908" translate="yes" xml:space="preserve">
          <source>If a transaction was used, then &lt;code&gt;{ transaction: options.transaction }&lt;/code&gt; will ensure it is used again;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15b44897c89a2d595b8b17d6001101f2af7c6a6e" translate="yes" xml:space="preserve">
          <source>If an alias was defined, it will be used instead of the model name to form the method names. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3f8b21413ef2d75f353e547b63ad8a094ceae96" translate="yes" xml:space="preserve">
          <source>If an array is passed, &lt;code&gt;$1&lt;/code&gt; is bound to the 1st element in the array (&lt;code&gt;bind[0]&lt;/code&gt;)</source>
          <target state="translated">배열이 전달되면 &lt;code&gt;$1&lt;/code&gt; 이 배열의 첫 번째 요소에 &lt;code&gt;bind[0]&lt;/code&gt; 됩니다 ( bind [0] )</target>
        </trans-unit>
        <trans-unit id="04ff1e23f5982cac50100dca79c353131b430203" translate="yes" xml:space="preserve">
          <source>If an array is passed, &lt;code&gt;?&lt;/code&gt; will be replaced in the order that they appear in the array</source>
          <target state="translated">배열이 전달되면 &lt;code&gt;?&lt;/code&gt; 배열에 나타나는 순서대로 교체됩니다</target>
        </trans-unit>
        <trans-unit id="b735a91d7f9b5885397dd1ca50581d91513fcb31" translate="yes" xml:space="preserve">
          <source>If an association is aliased (using the &lt;code&gt;as&lt;/code&gt; option), you must specify this alias when including the model. Instead of passing the model directly to the &lt;code&gt;include&lt;/code&gt; option, you should instead provide an object with two options: &lt;code&gt;model&lt;/code&gt; and &lt;code&gt;as&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="021622889c30d11d413d8e307364ba9ff4ad40e3" translate="yes" xml:space="preserve">
          <source>If an association is aliased (using the &lt;code&gt;as&lt;/code&gt; option), you must specify this alias when including the model. Notice how the user's &lt;code&gt;Tool&lt;/code&gt;s are aliased as &lt;code&gt;Instruments&lt;/code&gt; above. In order to get that right you have to specify the model you want to load, as well as the alias:</source>
          <target state="translated">&lt;code&gt;as&lt;/code&gt; 옵션을 사용하여 연결의 별칭이 지정되면 모델을 포함 할 때이 별칭을 지정해야합니다. 사용자 &lt;code&gt;Tool&lt;/code&gt; 가 위의 &lt;code&gt;Instruments&lt;/code&gt; 별칭을 어떻게 사용하는지 주목하십시오 . 이를 위해서는로드 할 모델과 별명을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="b12bd9871828e99247e957c9b710cebf3aa6b4f6" translate="yes" xml:space="preserve">
          <source>If an attempt is made to set &lt;code&gt;null&lt;/code&gt; to a field that does not allow null, a &lt;code&gt;ValidationError&lt;/code&gt; will be thrown &lt;em&gt;without any SQL query being performed&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab4d0ce1426861dbc29aa82ad5a93a5f0a45e8ab" translate="yes" xml:space="preserve">
          <source>If an attribute name of the table contains dots, the resulting objects can become nested objects by setting the &lt;code&gt;nest: true&lt;/code&gt; option. This is achieved with &lt;a href=&quot;https://github.com/mickhansen/dottie.js/&quot;&gt;dottie.js&lt;/a&gt; under the hood. See below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c54b915fccb2e4ddf42da3781b85ba11c94eff3f" translate="yes" xml:space="preserve">
          <source>If an attribute name of the table contains dots, the resulting objects will be nested. This is due to the usage of &lt;a href=&quot;https://github.com/mickhansen/dottie.js/&quot;&gt;dottie.js&lt;/a&gt; under the hood. See below:</source>
          <target state="translated">테이블의 속성 이름에 점이 포함되어 있으면 결과 개체가 중첩됩니다. 이것은 후드 에서 &lt;a href=&quot;https://github.com/mickhansen/dottie.js/&quot;&gt;dottie.js를&lt;/a&gt; 사용하기 때문 입니다. 아래를보십시오 :</target>
        </trans-unit>
        <trans-unit id="7e8f4a0270879aa34288ff325e1734fc57abfc56" translate="yes" xml:space="preserve">
          <source>If an object is passed, &lt;code&gt;$key&lt;/code&gt; is bound to &lt;code&gt;object['key']&lt;/code&gt;. Each key must begin with a non-numeric char. &lt;code&gt;$1&lt;/code&gt; is not a valid key, even if &lt;code&gt;object['1']&lt;/code&gt; exists.</source>
          <target state="translated">객체가 전달되면 &lt;code&gt;$key&lt;/code&gt; 는 &lt;code&gt;object['key']&lt;/code&gt; 에 바인딩됩니다 . 각 키는 숫자가 아닌 문자로 시작해야합니다. &lt;code&gt;object['1']&lt;/code&gt; 이 있어도 &lt;code&gt;$1&lt;/code&gt; 은 유효한 키가 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="6e127f4ede46c56ba8a869fe2aad272d846c5e9a" translate="yes" xml:space="preserve">
          <source>If an object is passed, &lt;code&gt;:key&lt;/code&gt; will be replaced with the keys from that object. If the object contains keys not found in the query or vice versa, an exception will be thrown.</source>
          <target state="translated">객체가 전달되면 &lt;code&gt;:key&lt;/code&gt; 가 해당 객체의 키로 대체됩니다. 개체에 쿼리에서 찾을 수없는 키가 포함 된 경우 또는 그 반대의 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9304ce1affc25db6aa67ee93e8d468669f898fd5" translate="yes" xml:space="preserve">
          <source>If called with a dot.separated key on a JSON/JSONB attribute it will set the value nested and flag the entire object as changed.</source>
          <target state="translated">JSON / JSONB 속성에서 dot.separated 키를 사용하여 호출하면 중첩 된 값을 설정하고 전체 객체가 변경된 것으로 플래그를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="300a90b91f546fafc57ddf54696a6ab280b20fc2" translate="yes" xml:space="preserve">
          <source>If called without a key, returns the previous values for all values which have changed</source>
          <target state="translated">키없이 호출 된 경우 변경된 모든 값의 이전 값을 반환합니다</target>
        </trans-unit>
        <trans-unit id="db0b72801ce4daab0ede65373af164330463fbaa" translate="yes" xml:space="preserve">
          <source>If changed is called with a string it will return a boolean indicating whether the value of that key in &lt;code&gt;dataValues&lt;/code&gt; is different from the value in &lt;code&gt;_previousDataValues&lt;/code&gt;.</source>
          <target state="translated">문자열과 함께 changed가 호출되면 &lt;code&gt;dataValues&lt;/code&gt; 의 해당 키 값이 &lt;code&gt;_previousDataValues&lt;/code&gt; 의 값과 다른지 여부를 나타내는 부울을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b57e7f29c55e30f10a44c4cebddd8704ddabfd60" translate="yes" xml:space="preserve">
          <source>If changed is called without an argument and no keys have changed, it will return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">인수없이 changed가 호출되고 키가 변경되지 않은 경우 &lt;code&gt;false&lt;/code&gt; 가 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="cb8a52b4f780a30671fc27031ceae2a7e48b802e" translate="yes" xml:space="preserve">
          <source>If changed is called without an argument, it will return an array of keys that have changed.</source>
          <target state="translated">인수없이 changed가 호출되면 변경된 키 배열이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="20c37c0197f08cf51e26c1e2044ffa20d35483f5" translate="yes" xml:space="preserve">
          <source>If false do not prepend the query with the search_path (Postgres only)</source>
          <target state="translated">false 인 경우 search_path와 함께 쿼리를 추가하지 마십시오 (Postgres 만 해당)</target>
        </trans-unit>
        <trans-unit id="657ba5fa03244f7aee9eb6c421c8a628fdb8a23e" translate="yes" xml:space="preserve">
          <source>If false, the column will have a NOT NULL constraint, and a not null validation will be run before an instance is saved.</source>
          <target state="translated">false이면 열에 NOT NULL 제약 조건이 있으며 인스턴스가 저장되기 전에 null이 아닌 유효성 검사가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="b7040facc6b4350a46a2def78c5b8c73e7bcb1a8" translate="yes" xml:space="preserve">
          <source>If false, validations won't be run.</source>
          <target state="translated">False이면 유효성 검사가 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="44cd1fb91500ac78a5a510a589057a193ab6aa6d" translate="yes" xml:space="preserve">
          <source>If force is true, any existing functions with the same parameters will be replaced. For postgres, this means using &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; instead of &lt;code&gt;CREATE FUNCTION&lt;/code&gt;. Default is false</source>
          <target state="translated">force가 true이면 동일한 매개 변수를 가진 기존 기능이 대체됩니다. 포스트 그레스의 경우,이 수단을 사용하여 &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; 을 대신 &lt;code&gt;CREATE FUNCTION&lt;/code&gt; . 기본값은 false</target>
        </trans-unit>
        <trans-unit id="6e07f5f6020b14d25df9a8addee707cdd889572f" translate="yes" xml:space="preserve">
          <source>If force is true, each Model will run &lt;code&gt;DROP TABLE IF EXISTS&lt;/code&gt;, before it tries to create its own table</source>
          <target state="translated">force가 true이면 각 모델은 자체 테이블을 작성하기 전에 &lt;code&gt;DROP TABLE IF EXISTS&lt;/code&gt; 를 실행 합니다.</target>
        </trans-unit>
        <trans-unit id="0e59b7682415bc819345577fa12bec6b2f9cba27" translate="yes" xml:space="preserve">
          <source>If freezeTableName is true, sequelize will not try to alter the model name to get the table name. Otherwise, the model name will be pluralized</source>
          <target state="translated">freezeTableName이 true 인 경우 sequelize는 테이블 이름을 얻기 위해 모델 이름을 변경하지 않습니다. 그렇지 않으면 모델 이름이 복수가됩니다</target>
        </trans-unit>
        <trans-unit id="674d7115644f88b378cc58e55b691d817654dfdd" translate="yes" xml:space="preserve">
          <source>If hooks is true then beforeSync, afterSync, beforeBulkSync, afterBulkSync hooks will be called</source>
          <target state="translated">후크가 true이면 beforeSync, afterSync, beforeBulkSync, afterBulkSync 후크가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="2e6f9f406f5bd815e7f824d0bfb0ffc5524dc505" translate="yes" xml:space="preserve">
          <source>If key is given and a field or virtual getter is present for the key it will call that getter - else it will return the value for key.</source>
          <target state="translated">키가 주어지고 키에 대한 필드 또는 가상 게터가 있으면 해당 게터를 호출합니다. 그렇지 않으면 키의 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="128a3eaafb2aa713f5d89656e1b713c3a3e56e43" translate="yes" xml:space="preserve">
          <source>If no key is given, returns all values of the instance, also invoking virtual getters.</source>
          <target state="translated">키가 제공되지 않으면 인스턴스의 모든 값을 반환하고 가상 게터도 호출합니다.</target>
        </trans-unit>
        <trans-unit id="894bd939fc9fbd940725facf4300464356fb6a66" translate="yes" xml:space="preserve">
          <source>If no transaction is passed in the &lt;code&gt;options&lt;/code&gt; object, a new transaction will be created internally, to prevent the race condition where a matching row is created by another connection after the find but before the insert call. However, it is not always possible to handle this case in SQLite, specifically if one transaction inserts and another tries to select before the first one has committed. In this case, an instance of sequelize. TimeoutError will be thrown instead. If a transaction is created, a savepoint will be created instead, and any unique constraint violation will be handled internally.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 오브젝트 에 트랜잭션이 전달되지 않으면 찾기 후 삽입 호출 전에 다른 연결에 의해 일치하는 행이 작성되는 경쟁 조건을 방지하기 위해 내부적으로 새 트랜잭션이 작성됩니다. 그러나 SQLite에서이 경우를 처리하는 것이 항상 가능한 것은 아닙니다. 특히 첫 번째 트랜잭션이 커밋되기 전에 한 트랜잭션이 삽입되고 다른 트랜잭션이 선택하려고하는 경우입니다. 이 경우, 후유증의 인스턴스입니다. 대신 TimeoutError가 발생합니다. 트랜잭션이 생성되면 대신 세이브 포인트가 생성되고 고유 제약 조건 위반이 내부적으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="55f7b072e47da9d3a76ee479789dd9f0b9a7718b" translate="yes" xml:space="preserve">
          <source>If set is called with an object, it will loop over the object, and call set recursively for each key, value pair. If you set raw to true, the underlying dataValues will either be set directly to the object passed, or used to extend dataValues, if dataValues already contain values.</source>
          <target state="translated">set을 객체와 함께 호출하면 객체를 반복하고 각 키, 값 쌍에 대해 반복적으로 set을 호출합니다. raw를 true로 설정하면 기본 dataValues는 전달 된 객체로 직접 설정되거나 dataValues에 이미 값이 포함 된 경우 dataValues를 확장하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="391fbbeca7f5b84a6e11a9f54c2e0f1487c1d4cc" translate="yes" xml:space="preserve">
          <source>If set to true, destroy will SELECT all records matching the where parameter and will execute before / after destroy hooks on each row</source>
          <target state="translated">true로 설정하면 destroy는 where 매개 변수와 일치하는 모든 레코드를 선택하고 각 행에서 destroy 후크 전후에 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="06b008b34268e778c426cab5ae74a85c1075bda2" translate="yes" xml:space="preserve">
          <source>If set to true, dialects that support it will use TRUNCATE instead of DELETE FROM. If a table is truncated the where and limit options are ignored</source>
          <target state="translated">true로 설정하면이를 지원하는 방언은 DELETE FROM 대신 TRUNCATE를 사용합니다. 테이블이 잘 리면 where 및 limit 옵션이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="38d8c40738b16274aefd629da92a6bb29ab47eb3" translate="yes" xml:space="preserve">
          <source>If set to true, field and virtual setters will be ignored</source>
          <target state="translated">true로 설정하면 필드 및 가상 세터가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="27b3827a991183e8f28bbcc85806f70fa71c8f62" translate="yes" xml:space="preserve">
          <source>If set to true, included instances will be returned as plain objects</source>
          <target state="translated">true로 설정하면 포함 된 인스턴스가 일반 객체로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="eb40b80fd32cf8e71525ff0fe2f8efca5a8f93fe" translate="yes" xml:space="preserve">
          <source>If set to true, paranoid models will actually be deleted</source>
          <target state="translated">true로 설정하면 편집증 모델이 실제로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="a720a3ae5cb54b9f1a92c2a8683add3f1fa36c95" translate="yes" xml:space="preserve">
          <source>If set to true, restore will find all records within the where parameter and will execute before / after bulkRestore hooks on each row</source>
          <target state="translated">true로 설정하면 restore는 where 매개 변수 내에서 모든 레코드를 찾고 bulkRestore가 각 행에서 후크 전후에 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="c3f750e72324e6657c8b56d788253264d692f468" translate="yes" xml:space="preserve">
          <source>If set to true, values will ignore field and virtual setters.</source>
          <target state="translated">true로 설정하면 값이 필드 및 가상 세터를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="2a225688455376882530e8dba312211d2bcbc470" translate="yes" xml:space="preserve">
          <source>If set, sequelize will map the attribute name to a different name in the database</source>
          <target state="translated">설정되면, sequelize는 속성 이름을 데이터베이스의 다른 이름에 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="cc207bb584dc6def0a25ec33cd2870eeed91a21b" translate="yes" xml:space="preserve">
          <source>If specified, load the dialect library from this path. For example, if you want to use pg.js instead of pg when connecting to a pg database, you should specify '/path/to/pg.js' here</source>
          <target state="translated">지정된 경우이 경로에서 방언 라이브러리를로드하십시오. 예를 들어, pg 데이터베이스에 연결할 때 pg 대신 pg.js를 사용하려면 여기에 '/path/to/pg.js'를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="5220457eb8ff7b1a3c9c11e68260aadf24c052ae" translate="yes" xml:space="preserve">
          <source>If specified, use this dialect library. For example, if you want to use pg.js instead of pg when connecting to a pg database, you should specify 'require(&quot;pg.js&quot;)' here</source>
          <target state="translated">지정된 경우이 언어 라이브러리를 사용하십시오. 예를 들어, pg 데이터베이스에 연결할 때 pg 대신 pg.js를 사용하려면 여기에 'require ( &quot;pg.js&quot;)'를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="1dae209bc98d06b2e47281691116b5fbe149490d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;paranoid&lt;/code&gt; options is true, the object will not be deleted, instead the &lt;code&gt;deletedAt&lt;/code&gt; column will be set to the current timestamp. To force the deletion, you can pass &lt;code&gt;force: true&lt;/code&gt; to the destroy call:</source>
          <target state="translated">경우 &lt;code&gt;paranoid&lt;/code&gt; 옵션에 해당하는 객체 대신, 삭제되지 않습니다 &lt;code&gt;deletedAt&lt;/code&gt; 의 열이 현재 타임 스탬프로 설정됩니다. 삭제를 강제 실행하려면 destroy 호출에 &lt;code&gt;force: true&lt;/code&gt; 를 전달하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="89216aed70fb8c41aa23d73029989645c25f0d2e" translate="yes" xml:space="preserve">
          <source>If the hook has been called in the process of a transacted operation, this makes sure that your dependent read/write is a part of that same transaction. If the hook is not transacted, you have simply specified &lt;code&gt;{ transaction: null }&lt;/code&gt; and can expect the default behaviour.</source>
          <target state="translated">트랜잭션 조작 프로세스에서 후크가 호출 된 경우 종속 읽기 / 쓰기가 동일한 트랜잭션의 일부인지 확인합니다. 후크가 처리되지 않은 경우, 간단히 &lt;code&gt;{ transaction: null }&lt;/code&gt; 지정 했으며 기본 동작을 예상 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af05f51d4f3f873d18093ece45324c7ce642b8d4" translate="yes" xml:space="preserve">
          <source>If the only thing being specified about a column is its data type, the syntax can be shortened:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2755694b8eb30539d0dbf98759fe01c4187fb45f" translate="yes" xml:space="preserve">
          <source>If this column references another table, provide it here as a Model, or a string</source>
          <target state="translated">이 열이 다른 테이블을 참조하는 경우 여기에 모델 또는 문자열로 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="1c2890cf339691d4d47faf2398abe6e1b023205e" translate="yes" xml:space="preserve">
          <source>If true a unique key will be generated from the foreign keys used (might want to turn this off and create specific unique keys when using scopes)</source>
          <target state="translated">true 인 경우 사용 된 외래 키에서 고유 키가 생성됩니다 (범위를 사용할 때이 키를 끄고 특정 고유 키를 생성 할 수 있음)</target>
        </trans-unit>
        <trans-unit id="2856a473591152d31ef4a0266e32a8671fc7732b" translate="yes" xml:space="preserve">
          <source>If true, append RETURNING &amp;lt;model columns&amp;gt; to get back all defined values; if an array of column names, append RETURNING &amp;lt;columns&amp;gt; to get back specific columns (Postgres only)</source>
          <target state="translated">true 인 경우 RETURNING &amp;lt;모델 열&amp;gt;을 추가하여 정의 된 모든 값을 가져옵니다. 열 이름 배열 인 경우 RETURNING &amp;lt;columns&amp;gt;를 추가하여 특정 열을 가져옵니다 (Postgres 만 해당)</target>
        </trans-unit>
        <trans-unit id="ac32e94080083f62fd15d534737523a9a47f0b0e" translate="yes" xml:space="preserve">
          <source>If true, combined with autoIncrement=true, will use Postgres &lt;code&gt;GENERATED BY DEFAULT AS IDENTITY&lt;/code&gt; instead of &lt;code&gt;SERIAL&lt;/code&gt;. Postgres 10+ only.</source>
          <target state="translated">true 인 경우 autoIncrement = true와 함께 사용 하면 &lt;code&gt;SERIAL&lt;/code&gt; 대신 Postgres &lt;code&gt;GENERATED BY DEFAULT AS IDENTITY&lt;/code&gt; 를 사용 합니다. Postgres 10 이상 만.</target>
        </trans-unit>
        <trans-unit id="4df84c739c5fec04cd33156cf8d026bf97b1a13f" translate="yes" xml:space="preserve">
          <source>If true, converts to a right join if dialect support it. Ignored if &lt;code&gt;include.required&lt;/code&gt; is true.</source>
          <target state="translated">참이면, 방언이 지원하는 경우 오른쪽 조인으로 변환합니다. &lt;code&gt;include.required&lt;/code&gt; 가 true이면 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="3e0dc1c538227d7485952dc6d28c4c1abd9d5955" translate="yes" xml:space="preserve">
          <source>If true, converts to an inner join, which means that the parent model will only be loaded if it has any matching children. True if &lt;code&gt;include.where&lt;/code&gt; is set, false otherwise.</source>
          <target state="translated">true 인 경우 내부 조인으로 변환됩니다. 즉, 상위 모델에 일치하는 하위가있는 경우에만 상위 모델이로드됩니다. &lt;code&gt;include.where&lt;/code&gt; 가 설정되어 있으면 true이고 , 그렇지 않으면 false입니다.</target>
        </trans-unit>
        <trans-unit id="176de8bd8d7d1119cf88871eae854266afc7f65d" translate="yes" xml:space="preserve">
          <source>If true, fetches back auto generated values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81d2e26a6f45fb983320c358ee03e36d4177246b" translate="yes" xml:space="preserve">
          <source>If true, fetches back auto generated values (Postgres only)</source>
          <target state="translated">true 인 경우 자동 생성 된 값을 가져옵니다 (Postgres 만 해당)</target>
        </trans-unit>
        <trans-unit id="27bb8c3ebbed206d133e37533e84b395c0c9105c" translate="yes" xml:space="preserve">
          <source>If true, only non-deleted records will be returned from the join table. If false, both deleted and non-deleted records will be returned. Only applies if through model is paranoid</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9493e0278e049ef4ff4652a3baff31d06e297e09" translate="yes" xml:space="preserve">
          <source>If true, only non-deleted records will be returned. If false, both deleted and non-deleted records will be returned. Only applies if &lt;code&gt;options.paranoid&lt;/code&gt; is true for the model.</source>
          <target state="translated">true 인 경우 삭제되지 않은 레코드 만 반환됩니다. False이면 삭제 된 레코드와 삭제되지 않은 레코드가 모두 반환됩니다. &lt;code&gt;options.paranoid&lt;/code&gt; 가 모델에 해당하는 경우에만 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="8ce8f96e01d05bf135e8ac150e4e97d603a39cd8" translate="yes" xml:space="preserve">
          <source>If true, only non-deleted records will be updated. If false, both deleted and non-deleted records will be updated. Only applies if &lt;code&gt;options.paranoid&lt;/code&gt; is true for the model.</source>
          <target state="translated">true 인 경우 삭제되지 않은 레코드 만 업데이트됩니다. False이면 삭제 된 레코드와 삭제되지 않은 레코드가 모두 업데이트됩니다. &lt;code&gt;options.paranoid&lt;/code&gt; 가 모델에 해당하는 경우에만 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e6c3614407ad68627e43871b206c08231a35fcb2" translate="yes" xml:space="preserve">
          <source>If true, runs a separate query to fetch the associated instances, only supported for hasMany associations</source>
          <target state="translated">true 인 경우 별도의 쿼리를 실행하여 관련 인스턴스를 가져 오며 hasMany 연관에 대해서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="647d7c653d76bc8224e8446161299293bf7a8229" translate="yes" xml:space="preserve">
          <source>If true, sequelize will not try to format the results of the query, or build an instance of a model from the result</source>
          <target state="translated">true 인 경우 sequelize는 쿼리 결과의 형식을 지정하거나 결과에서 모델 인스턴스를 작성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0ba0bbc2d0ad37b59e2f4202a1fa65789943978b" translate="yes" xml:space="preserve">
          <source>If true, the column will get a unique constraint. If a string is provided, the column will be part of a composite unique index. If multiple columns have the same string, they will be part of the same unique index</source>
          <target state="translated">true 인 경우 열에 고유 제한 조건이 적용됩니다. 문자열이 제공되면 열은 복합 고유 인덱스의 일부가됩니다. 여러 열에 동일한 문자열이 있으면 동일한 고유 인덱스의 일부가됩니다.</target>
        </trans-unit>
        <trans-unit id="beb79f16ad3fb0f8cdb6f793480ca423b3cb5429" translate="yes" xml:space="preserve">
          <source>If true, the updatedAt timestamp will not be updated.</source>
          <target state="translated">true이면 updatedAt 타임 스탬프가 업데이트되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d05e957cd328c4b4ff8ea91a8a38cc0b12d2f924" translate="yes" xml:space="preserve">
          <source>If true, this attribute will be marked as primary key</source>
          <target state="translated">true 인 경우이 속성은 기본 키로 표시됩니다</target>
        </trans-unit>
        <trans-unit id="08f9a9c95786ae05c26d607345400a2e23ad1516" translate="yes" xml:space="preserve">
          <source>If true, this column will be set to auto increment</source>
          <target state="translated">true 인 경우이 열은 자동 증분으로 설정됩니다</target>
        </trans-unit>
        <trans-unit id="75c4ea047705366df87e56ce4937449851e86344" translate="yes" xml:space="preserve">
          <source>If true, transforms objects with &lt;code&gt;.&lt;/code&gt; separated property names into nested objects using &lt;a href=&quot;https://github.com/mickhansen/dottie.js&quot;&gt;dottie.js&lt;/a&gt;. For example { 'user.username': 'john' } becomes { user: { username: 'john' }}. When &lt;code&gt;nest&lt;/code&gt; is true, the query type is assumed to be &lt;code&gt;'SELECT'&lt;/code&gt;, unless otherwise specified</source>
          <target state="translated">true 인 경우 객체를로 변환합니다 &lt;code&gt;.&lt;/code&gt; &lt;a href=&quot;https://github.com/mickhansen/dottie.js&quot;&gt;dottie.js를&lt;/a&gt; 사용하여 속성 이름을 중첩 객체로 분리했습니다 . 예를 들어 { 'user.username': 'john'}은 {user : {username : 'john'}}이됩니다. 때 &lt;code&gt;nest&lt;/code&gt; 사실, 질의 유형으로 가정 &lt;code&gt;'SELECT'&lt;/code&gt; 달리 명시되지 않는 한,</target>
        </trans-unit>
        <trans-unit id="2b3c88711448952fca0e35149a0cbc1a827d0bfb" translate="yes" xml:space="preserve">
          <source>If unsure, refer to the API documentation for the method you are using to be sure of the signature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32198f81d975b55d40ec70c7e2308553a94edcba" translate="yes" xml:space="preserve">
          <source>If validation fails, the promise is rejected with an array-like &lt;a href=&quot;http://bluebirdjs.com/docs/api/aggregateerror.html&quot;&gt;AggregateError&lt;/a&gt;</source>
          <target state="translated">유효성 검사가 실패하면 배열과 같은 &lt;a href=&quot;http://bluebirdjs.com/docs/api/aggregateerror.html&quot;&gt;AggregateError로&lt;/a&gt; 약속이 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="32774c05c02ed991fc187042bf3598ef5a7a71e7" translate="yes" xml:space="preserve">
          <source>If validation fails, the promise is rejected with an array-like AggregateError</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b68dbaff22b4a8b9e63dcda5fe1c9794aeaa88b0" translate="yes" xml:space="preserve">
          <source>If we define the pair as recommended, i.e., both &lt;code&gt;Foo.hasOne(Bar)&lt;/code&gt; and &lt;code&gt;Bar.belongsTo(Foo)&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="513b8800efbf168878b3b3a1edc4baee864640f1" translate="yes" xml:space="preserve">
          <source>If we do not define the pair of associations, calling for example just &lt;code&gt;Foo.hasOne(Bar)&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0186aab835641bad03f7589f88e576215349c709" translate="yes" xml:space="preserve">
          <source>If we had not included the transaction option in our call to &lt;code&gt;User.update&lt;/code&gt; in the preceding code, no change would have occurred, since our newly created user does not exist in the database until the pending transaction has been committed.</source>
          <target state="translated">앞의 코드에서 &lt;code&gt;User.update&lt;/code&gt; 호출에 트랜잭션 옵션을 포함시키지 않은 경우 새로 생성 된 사용자가 보류중인 트랜잭션이 커밋 될 때까지 데이터베이스에 존재하지 않으므로 변경이 발생하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="90a638bf427dff29f6667e845137fe18594f70ef" translate="yes" xml:space="preserve">
          <source>If we run the above raw SQL query through Sequelize, we get:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffa3cd7e82aaa3f83dc8bf178240b35d168ceca2" translate="yes" xml:space="preserve">
          <source>If we wanted to involve another field from our model instance in the computation, that is possible and very easy!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af86f00788413950c29544cb321c3012b536084e" translate="yes" xml:space="preserve">
          <source>If you are accepting values directly from the user, it might be beneficial to limit the columns that you want to actually insert. To support this, &lt;code&gt;bulkCreate()&lt;/code&gt; accepts a &lt;code&gt;fields&lt;/code&gt; option, an array defining which fields must be considered (the rest will be ignored).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb6b5c50fe4ab3f465e27baa8bc48b315568f529" translate="yes" xml:space="preserve">
          <source>If you are accepting values directly from the user, it might be beneficial to limit the columns that you want to actually insert.&lt;code&gt;bulkCreate()&lt;/code&gt;accepts an options object as the second parameter. The object can have a &lt;code&gt;fields&lt;/code&gt; parameter, (an array) to let it know which fields you want to build explicitly</source>
          <target state="translated">사용자로부터 직접 값을 수락하는 경우 실제로 삽입하려는 열을 제한하는 것이 좋습니다. &lt;code&gt;bulkCreate()&lt;/code&gt; 는 옵션 객체를 두 번째 매개 변수로 사용합니다. 객체에는 &lt;code&gt;fields&lt;/code&gt; 매개 변수 (배열)가있어 명시 적으로 만들려는 필드를 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="5ac8d819fedae82d2ebf0ab77182ee9f429b9d81" translate="yes" xml:space="preserve">
          <source>If you are running a type of query where you don't need the metadata, for example a &lt;code&gt;SELECT&lt;/code&gt; query, you can pass in a query type to make sequelize format the results:</source>
          <target state="translated">메타 데이터가 필요하지 않은 쿼리 유형 (예 : &lt;code&gt;SELECT&lt;/code&gt; 쿼리)을 실행중인 경우 쿼리 유형을 전달하여 결과 형식을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0bc79231b8537df5d0e0f52b040b420676268d0" translate="yes" xml:space="preserve">
          <source>If you are starting a project from scratch, and your database does not exist yet, Sequelize can be used since the beginning in order to automate the creation of every table in your database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="472f4053e4c19200204ff390506f183cb62d92a5" translate="yes" xml:space="preserve">
          <source>If you are using mixins (such as &lt;code&gt;user.getProfiles()&lt;/code&gt;) instead of finder methods (such as &lt;code&gt;User.findAll()&lt;/code&gt;), you have to use the &lt;code&gt;joinTableAttributes&lt;/code&gt; option instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c6b8f104ce1867c4fbb58c79efc25e166a19332" translate="yes" xml:space="preserve">
          <source>If you are working with the PostgreSQL &lt;code&gt;TIMESTAMP WITHOUT TIME ZONE&lt;/code&gt; and you need to parse it to a different timezone, please use the pg library's own parser:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6462f72311ba7a8cddf624ea0257e29162d1f7f" translate="yes" xml:space="preserve">
          <source>If you are working with the PostgreSQL TIMESTAMP WITHOUT TIME ZONE and you need to parse it to a different timezone, please use the pg library's own parser:</source>
          <target state="translated">시간대없이 PostgreSQL TIMESTAMP를 사용하여 다른 시간대로 구문 분석해야하는 경우 pg 라이브러리의 자체 구문 분석기를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7ee60dd14251d97d9e80017ad46aa8d2aedf7b51" translate="yes" xml:space="preserve">
          <source>If you change the value of some field of an instance, calling &lt;code&gt;save&lt;/code&gt; again will update it accordingly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74ddcd65a25eb03b0ad2ef462e8d2c98a3998a61" translate="yes" xml:space="preserve">
          <source>If you do not want timestamps on your models, only want some timestamps, or you are working with an existing database where the columns are named something else, jump straight on to &lt;a href=&quot;models-definition#configuration&quot;&gt;configuration&lt;/a&gt; to see how to do that.</source>
          <target state="translated">모델에 타임 스탬프를 원하지 않거나 타임 스탬프 만 원하거나 열 이름이 다른 기존 데이터베이스를 사용하는 경우 &lt;a href=&quot;models-definition#configuration&quot;&gt;구성&lt;/a&gt; 으로 바로 이동하여 해당 방법을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="82afc94c4a024c4ee379a3bc5b66fcd1dff91707" translate="yes" xml:space="preserve">
          <source>If you don't want anything from the junction table, you can explicitly provide an empty array to the &lt;code&gt;attributes&lt;/code&gt; option, and in this case nothing will be fetched and the extra property will not even be created:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b70b7dfc0286abead1f89aa2eb01dca13de6982b" translate="yes" xml:space="preserve">
          <source>If you don't want the nested &lt;code&gt;grant&lt;/code&gt; field at all, use &lt;code&gt;attributes: []&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3c5e7d03c6a36a4f0cced22fb56e3a7206de7ed" translate="yes" xml:space="preserve">
          <source>If you have &lt;a href=&quot;https://github.com/Jeff-Lewis/cls-hooked&quot;&gt;CLS&lt;/a&gt; enabled, the transaction will automatically be passed to any query that runs within the callback</source>
          <target state="translated">당신이 경우 &lt;a href=&quot;https://github.com/Jeff-Lewis/cls-hooked&quot;&gt;CLS는&lt;/a&gt; 활성화 된 트랜잭션이 자동으로 콜백 내의 모든 쿼리에 그 실행을 전달합니다</target>
        </trans-unit>
        <trans-unit id="89ecba0f6c4969c1946f16a7277505b83b58a142" translate="yes" xml:space="preserve">
          <source>If you have any general settings that apply to all replicas you do not need to provide them for each instance. In the code above, database name and port is propagated to all replicas. The same will happen for user and password, if you leave them out for any of the replicas. Each replica has the following options:&lt;code&gt;host&lt;/code&gt;,&lt;code&gt;port&lt;/code&gt;,&lt;code&gt;username&lt;/code&gt;,&lt;code&gt;password&lt;/code&gt;,&lt;code&gt;database&lt;/code&gt;.</source>
          <target state="translated">모든 복제본에 적용되는 일반 설정이 있으면 각 인스턴스에 해당 설정을 제공 할 필요가 없습니다. 위 코드에서 데이터베이스 이름과 포트는 모든 복제본으로 전파됩니다. 복제본에 대해 사용자 및 비밀번호를 제외하면 동일한 결과가 발생합니다. 각 복제본에는 &lt;code&gt;host&lt;/code&gt; , &lt;code&gt;port&lt;/code&gt; , &lt;code&gt;username&lt;/code&gt; , &lt;code&gt;password&lt;/code&gt; , &lt;code&gt;database&lt;/code&gt; 옵션이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9bb5e89572ab05d67a9192d69c8e80c0b0d84ee4" translate="yes" xml:space="preserve">
          <source>If you have soft-deleted an instance of a model with &lt;code&gt;paranoid: true&lt;/code&gt;, and would like to undo the deletion, use the &lt;code&gt;restore&lt;/code&gt; method:</source>
          <target state="translated">&lt;code&gt;paranoid: true&lt;/code&gt; 인 모델의 인스턴스를 일시 삭제하고 삭제를 취소하려면 &lt;code&gt;restore&lt;/code&gt; 메소드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="83a275a19fc7524ebcb47eee01b5247c06418a43" translate="yes" xml:space="preserve">
          <source>If you know that a model will always use the same alias in associations, you can provide it when creating the model</source>
          <target state="translated">모델이 항상 같은 별칭을 연결에 사용한다는 것을 알고 있다면 모델을 만들 때 제공 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="3e5032709f3b242affafbbdb7632faacc668689e" translate="yes" xml:space="preserve">
          <source>If you know that a model will always use the same alias in associations, you can provide the singular and plural forms directly to the model itself:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0d51269897d4509e5bc63cdb1763b5e6f2abee2" translate="yes" xml:space="preserve">
          <source>If you log an instance you will notice, that there is a lot of additional stuff. In order to hide such stuff and reduce it to the very interesting information, you can use the&lt;code&gt;get&lt;/code&gt;-attribute. Calling it with the option &lt;code&gt;plain&lt;/code&gt; = true will only return the values of an instance.</source>
          <target state="translated">인스턴스를 기록하면 추가 항목이 많이 있음을 알 수 있습니다. 그러한 것들을 숨기고 매우 흥미로운 정보로 줄이기 위해 &lt;code&gt;get&lt;/code&gt; -attribute를 사용할 수 있습니다 . &lt;code&gt;plain&lt;/code&gt; = true 옵션으로 호출 하면 인스턴스의 값만 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6b08bb3d2e947f978268c076db082fbb034c017e" translate="yes" xml:space="preserve">
          <source>If you need to get your instance in sync, you can use the method&lt;code&gt;reload&lt;/code&gt;. It will fetch the current data from the database and overwrite the attributes of the model on which the method has been called on.</source>
          <target state="translated">인스턴스를 동기화해야하는 경우 &lt;code&gt;reload&lt;/code&gt; 메소드를 사용할 수 있습니다 . 데이터베이스에서 현재 데이터를 가져 와서 메소드가 호출 된 모델의 속성을 겹쳐 씁니다.</target>
        </trans-unit>
        <trans-unit id="2916bd0b55b8aca641a06d58426ff56557b254b3" translate="yes" xml:space="preserve">
          <source>If you only need some of the attributes from the join table, you can provide an array with the attributes you want:</source>
          <target state="translated">조인 테이블의 일부 속성 만 필요한 경우 원하는 속성이있는 배열을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa84e598877d14dc3cb73bc586151be45d2ecb1a" translate="yes" xml:space="preserve">
          <source>If you provide an &lt;code&gt;include&lt;/code&gt; option, the number of matching associations will be counted instead.</source>
          <target state="translated">&lt;code&gt;include&lt;/code&gt; 옵션 을 제공하면 일치하는 연결 수가 대신 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="dc79ee0718628292539287041025f940da4fc450" translate="yes" xml:space="preserve">
          <source>If you really want a hard-deletion and your model is paranoid, you can force it using the &lt;code&gt;force: true&lt;/code&gt; option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dd7ba08316df6d81c8bfdadc29d3cb20a63c77e" translate="yes" xml:space="preserve">
          <source>If you really want to let the query see the soft-deleted records, you can pass the &lt;code&gt;paranoid: false&lt;/code&gt; option to the query method. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b85b7a23d962619602b9a3d66aa5e49f8b2f2fc" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;Model.bulkCreate(...)&lt;/code&gt; with the &lt;code&gt;updateOnDuplicate&lt;/code&gt; option, changes made in the hook to fields that aren't given in the &lt;code&gt;updateOnDuplicate&lt;/code&gt; array will not be persisted to the database. However it is possible to change the &lt;code&gt;updateOnDuplicate&lt;/code&gt; option inside the hook if this is what you want.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d863b772f59c7c1fea122e1663917c43efb011ee" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;Model.bulkCreate(...)&lt;/code&gt; with the &lt;code&gt;updateOnDuplicate&lt;/code&gt; option, changes made in the hook to fields that aren't given in the &lt;code&gt;updateOnDuplicate&lt;/code&gt; array will not be persisted to the database. However it is possible to change the updateOnDuplicate option inside the hook if this is what you want.</source>
          <target state="translated">&lt;code&gt;updateOnDuplicate&lt;/code&gt; 옵션 과 함께 &lt;code&gt;Model.bulkCreate(...)&lt;/code&gt; 를 사용 하면 &lt;code&gt;updateOnDuplicate&lt;/code&gt; 배열에 제공되지 않은 필드에 대한 후크 변경 사항 이 데이터베이스에 유지되지 않습니다. 그러나 원하는 경우 후크 내에서 updateOnDuplicate 옵션을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="afab7da99be65b4a2073f953b17af81dc02a3ed5" translate="yes" xml:space="preserve">
          <source>If you want Sequelize to automatically create the table (or modify it as needed) according to your model definition, you can use the &lt;code&gt;sync&lt;/code&gt; method, as follows:</source>
          <target state="translated">Sequelize가 모델 정의에 따라 테이블을 자동으로 작성하거나 필요에 따라 수정하도록하려면 다음과 같이 &lt;code&gt;sync&lt;/code&gt; 방법을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f75ef969d5f06d081d766c60d1dd21fc30d0d354" translate="yes" xml:space="preserve">
          <source>If you want additional attributes in your join table, you can define a model for the join table in sequelize, before you define the association, and then tell sequelize that it should use that model for joining, instead of creating a new one:</source>
          <target state="translated">조인 테이블에 추가 속성을 원할 경우 연결을 정의하기 전에 순서에 따라 조인 테이블의 모델을 정의한 다음 새 모델을 만드는 대신 조인에 해당 모델을 사용해야한다고 sequelize에 알릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7cb72ec6577efe47bd8b75930fe054e841bde6bc" translate="yes" xml:space="preserve">
          <source>If you want sequelize to handle timestamps, but only want some of them, or want your timestamps to be called something else, you can override each column individually:</source>
          <target state="translated">sequelize가 타임 스탬프를 처리하고 싶지만 그 중 일부만 원하거나 타임 스탬프를 다른 것으로 호출하려는 경우 각 열을 개별적으로 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74c4a96cfc3c11e82bfff2366d0bb19c7c80c963" translate="yes" xml:space="preserve">
          <source>If you want to apply a &lt;code&gt;WHERE&lt;/code&gt; clause in an included model referring to a value from an associated model, you can simply use the &lt;code&gt;Sequelize.col&lt;/code&gt; function, as show in the example below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b777ec494ddce543c16902d51c471905b16fa9a5" translate="yes" xml:space="preserve">
          <source>If you want to apply another scope alongside the default scope, pass the key &lt;code&gt;defaultScope&lt;/code&gt; to &lt;code&gt;.scope&lt;/code&gt;:</source>
          <target state="translated">기본 범위와 함께 다른 범위를 적용하려면 &lt;code&gt;defaultScope&lt;/code&gt; 키 를 &lt;code&gt;.scope&lt;/code&gt; 에 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="0e3d2491ffbe91ae6541c30645933c5644c07ab6" translate="yes" xml:space="preserve">
          <source>If you want to create a belongs to many relationship that does not use the default primary key some setup work is required. You must set the &lt;code&gt;sourceKey&lt;/code&gt; (optionally &lt;code&gt;targetKey&lt;/code&gt;) appropriately for the two ends of the belongs to many. Further you must also ensure you have appropriate indexes created on your relationships. For example:</source>
          <target state="translated">기본 기본 키를 사용하지 않는 많은 관계에 속하려면 일부 설정 작업이 필요합니다. 소속의 두 끝에 대해 &lt;code&gt;sourceKey&lt;/code&gt; (선택적으로 &lt;code&gt;targetKey&lt;/code&gt; )를 적절히 설정해야합니다 . 또한 관계에 대해 적절한 색인을 작성했는지 확인해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f61f98f630678b685e1f3828dff3238a64205ed5" translate="yes" xml:space="preserve">
          <source>If you want to create a shortcut method to a scope on an associated model, you can pass the scoped model to the association. Consider a shortcut to get all deleted posts for a user:</source>
          <target state="translated">연관된 모델의 범위에 대한 바로 가기 메소드를 작성하려는 경우 범위가 지정된 모델을 연관에 전달할 수 있습니다. 사용자에 대해 삭제 된 모든 게시물을 가져 오는 바로 가기를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="3b08f9c79138d7fcde3ec61eeae485a38887f673" translate="yes" xml:space="preserve">
          <source>If you want to emit hooks for each individual record, along with the bulk hooks you can pass &lt;code&gt;individualHooks: true&lt;/code&gt; to the call.</source>
          <target state="translated">각 개별 레코드에 대해 후크를 생성하고 벌크 후크와 함께 &lt;code&gt;individualHooks: true&lt;/code&gt; 후크를 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3b540c12693f5dbf831dc4cc9ca6c1eee425fd4d" translate="yes" xml:space="preserve">
          <source>If you want to modify these, you can pass pool as an options when instantiating Sequelize, as shown above.</source>
          <target state="translated">이를 수정하려면 위와 같이 Sequelize를 인스턴스화 할 때 풀을 옵션으로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32c8896a0675e31aae1b24c2ac3e8559745e143a" translate="yes" xml:space="preserve">
          <source>If you want to set several target instances, but with different attributes you have to set the attributes on the instance, using a property with the name of the through model:</source>
          <target state="translated">여러 대상 인스턴스를 설정하려고하지만 속성이 다른 경우 스루 모델 이름의 속성을 사용하여 인스턴스에서 속성을 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="1ef93ea1c2614431873c694ec0744cd661b60763" translate="yes" xml:space="preserve">
          <source>If you wish to undo a specific seed</source>
          <target state="translated">특정 종자를 취소하려면</target>
        </trans-unit>
        <trans-unit id="1e185b5f7416d1c9609b8910f2c095fe038cc14e" translate="yes" xml:space="preserve">
          <source>If you wish to undo a specific seed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af863edfd5d71d3f8a26804bb152ee2c2da87ad3" translate="yes" xml:space="preserve">
          <source>If you wish to undo all seeds</source>
          <target state="translated">모든 씨앗을 취소하려면</target>
        </trans-unit>
        <trans-unit id="b274488dd01fde2569538eb6ba474aa0f4c286a1" translate="yes" xml:space="preserve">
          <source>If you wish to undo all seeds:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9da777accf0b16f64be8bca9d27fc688c0fd0ba" translate="yes" xml:space="preserve">
          <source>If you wish to undo most recent seed</source>
          <target state="translated">가장 최근의 씨앗을 취소하려면</target>
        </trans-unit>
        <trans-unit id="0fde4c4403536d346f7a881d06d11b078c0a1fc3" translate="yes" xml:space="preserve">
          <source>If you wish to undo the most recent seed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67afe845a624aebd4dd0b36c74cb653944f9def5" translate="yes" xml:space="preserve">
          <source>If you're comfortable with somewhat less strict typing for the attributes on a model, you can save some code by defining the Instance to just extend &lt;code&gt;Model&lt;/code&gt; without any attributes in the generic types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90e2d3d4a47e5a21011e831e9e97b42a42afde35" translate="yes" xml:space="preserve">
          <source>If you're connecting to the database from a single process, you should create only one Sequelize instance. Sequelize will set up a connection pool on initialization. This connection pool can be configured through the constructor's &lt;code&gt;options&lt;/code&gt; parameter (using &lt;code&gt;options.pool&lt;/code&gt;), as is shown in the following example:</source>
          <target state="translated">단일 프로세스에서 데이터베이스에 연결하는 경우 하나의 Sequelize 인스턴스 만 만들어야합니다. Sequelize는 초기화시 연결 풀을 설정합니다. 이 연결 풀은 다음 예제와 같이 생성자의 &lt;code&gt;options&lt;/code&gt; 매개 변수 ( &lt;code&gt;options.pool&lt;/code&gt; 사용 )를 통해 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b2971ed1f13da88526d6bf653a42311360d8cacf" translate="yes" xml:space="preserve">
          <source>If you're here, you might be looking for these topics:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6291ffc47760cc842fcd3a2e455f4f99cfb8ed05" translate="yes" xml:space="preserve">
          <source>If you're using SQLite, you should use the following instead:</source>
          <target state="translated">SQLite를 사용하는 경우 다음을 대신 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="b3a9c13be57776d4bba71a3ea8415ae3e1d14fba" translate="yes" xml:space="preserve">
          <source>If your association is Many-to-Many, you may be interested in firing hooks on the through model when using the &lt;code&gt;remove&lt;/code&gt; call. Internally, sequelize is using &lt;code&gt;Model.destroy&lt;/code&gt; resulting in calling the &lt;code&gt;bulkDestroy&lt;/code&gt; instead of the &lt;code&gt;before/afterDestroy&lt;/code&gt; hooks on each through instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a343e00321955b7beffbdeeb13a0fcb432790e92" translate="yes" xml:space="preserve">
          <source>If your association is of type &lt;code&gt;n:m&lt;/code&gt;, you may be interested in firing hooks on the through model when using the &lt;code&gt;remove&lt;/code&gt; call. Internally, sequelize is using &lt;code&gt;Model.destroy&lt;/code&gt; resulting in calling the &lt;code&gt;bulkDestroy&lt;/code&gt; instead of the &lt;code&gt;before/afterDestroy&lt;/code&gt; hooks on each through instance.</source>
          <target state="translated">연결 유형이 &lt;code&gt;n:m&lt;/code&gt; 인 경우 &lt;code&gt;remove&lt;/code&gt; 호출을 사용할 때 스루 모델의 후크 연결에 관심이있을 수 있습니다 . 내부적 sequelize는 사용 &lt;code&gt;Model.destroy&lt;/code&gt; 를 호출 결과 &lt;code&gt;bulkDestroy&lt;/code&gt; 대신의가 &lt;code&gt;before/afterDestroy&lt;/code&gt; 예를 통해 각 후크.</target>
        </trans-unit>
        <trans-unit id="2e2df5af7499e577204f9c009e4644ef93552d80" translate="yes" xml:space="preserve">
          <source>If your callback succeeds, Sequelize will automatically commit the transaction</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b3adc43ab0c7ab59e41548add8cf8ff2a3b451a" translate="yes" xml:space="preserve">
          <source>If your callback throws, Sequelize will automatically rollback the transaction</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="833407a04cbfb532aa3ab0eb509e48f853b7c95d" translate="yes" xml:space="preserve">
          <source>Ignore duplicate values for primary keys? (not supported by MSSQL or Postgres &amp;lt; 9.5)</source>
          <target state="translated">기본 키의 중복 값을 무시 하시겠습니까? (MSSQL 또는 Postgres &amp;lt;9.5에서는 지원되지 않음)</target>
        </trans-unit>
        <trans-unit id="8781d615fd77be9578225c40ac67b9471394cced" translate="yes" xml:space="preserve">
          <source>Implementation</source>
          <target state="translated">Implementation</target>
        </trans-unit>
        <trans-unit id="0d71bedbf598c6cb2ef567aed0bcbc08631a830d" translate="yes" xml:space="preserve">
          <source>Implementation:</source>
          <target state="translated">Implementation:</target>
        </trans-unit>
        <trans-unit id="d6fbc9d2bdd580e18ed0bc5805dc26db323d6f5f" translate="yes" xml:space="preserve">
          <source>Import</source>
          <target state="translated">Import</target>
        </trans-unit>
        <trans-unit id="b24a78bf1cbe20b658f9d8b812c79312cafb4997" translate="yes" xml:space="preserve">
          <source>Imported model, returned from cache if was already imported</source>
          <target state="translated">가져온 모델, 이미 가져온 경우 캐시에서 반환</target>
        </trans-unit>
        <trans-unit id="42ef05cf1be558b6ed91a4aeffccb1e4cfc64023" translate="yes" xml:space="preserve">
          <source>Imports a model defined in another file.</source>
          <target state="translated">다른 파일에 정의 된 모델을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="4561455fcd06ac6b99fef1b4ec3f086730adf57a" translate="yes" xml:space="preserve">
          <source>Imports a model defined in another file. Imported models are cached, so multiple calls to import with the same path will not load the file multiple times.</source>
          <target state="translated">다른 파일에 정의 된 모델을 가져옵니다. 가져온 모델은 캐시되므로 동일한 경로를 사용하여 여러 번 가져 오면 파일이 여러 번로드되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1eea469975ce5832153c3f8c53c1cabc35e823c1" translate="yes" xml:space="preserve">
          <source>In MySQL and MariaDB, the data types &lt;code&gt;INTEGER&lt;/code&gt;, &lt;code&gt;BIGINT&lt;/code&gt;, &lt;code&gt;FLOAT&lt;/code&gt; and &lt;code&gt;DOUBLE&lt;/code&gt; can be set as unsigned or zerofill (or both), as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc449382c5d7c01bc4ed7505e87c889bf281a9c7" translate="yes" xml:space="preserve">
          <source>In PostGIS, the GeoJSON is parsed using the PostGIS function &lt;code&gt;ST_GeomFromGeoJSON&lt;/code&gt;. In MySQL it is parsed using the function &lt;code&gt;GeomFromText&lt;/code&gt;.</source>
          <target state="translated">PostGIS에서 GeoJSON은 PostGIS 함수 &lt;code&gt;ST_GeomFromGeoJSON&lt;/code&gt; 을 사용하여 구문 분석됩니다 . MySQL에서는 &lt;code&gt;GeomFromText&lt;/code&gt; 함수를 사용하여 구문 분석됩니다 .</target>
        </trans-unit>
        <trans-unit id="fc15714391598577351e70a8f34d6238fcc77cd0" translate="yes" xml:space="preserve">
          <source>In Sequelize 1:1 relationship can be set using HasOne and BelongsTo. They are suitable for different scenarios. Lets study this difference using an example.</source>
          <target state="translated">Sequelize에서 1 : 1 관계는 HasOne 및 BelongsTo를 사용하여 설정할 수 있습니다. 서로 다른 시나리오에 적합합니다. 예제를 사용하여이 차이점을 연구 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="5538e00b3f69bacc6a529e276b7984b8a8b5222c" translate="yes" xml:space="preserve">
          <source>In Sequelize v4, it was possible to specify strings to refer to operators, instead of using Symbols. This is now deprecated and heavily discouraged, and will probably be removed in the next major version. If you really need it, you can pass the &lt;code&gt;operatorAliases&lt;/code&gt; option in the Sequelize constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3906fde18e49860f7af918b0800ba2801110f1bb" translate="yes" xml:space="preserve">
          <source>In Sequelize versions before v5, the default way of defining a model involved using &lt;code&gt;sequelize.define&lt;/code&gt;. It's still possible to define models with that, and you can also add typings to these models using interfaces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab7b81d8aa8f174d8d5b48208d13c8d499bfffc9" translate="yes" xml:space="preserve">
          <source>In Sequelize, eager loading is mainly done by using the &lt;code&gt;include&lt;/code&gt; option on a model finder query (such as &lt;code&gt;findOne&lt;/code&gt;, &lt;code&gt;findAll&lt;/code&gt;, etc).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c95a512d8d01104a5b16a7d3f2d233f18c0f08d" translate="yes" xml:space="preserve">
          <source>In Sequelize, it is possible to define multiple associations between the same models. You just have to define different aliases for them:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="774bb87b46000c449a45f969a8e44a0806f3930d" translate="yes" xml:space="preserve">
          <source>In addition to the type mentioned above, integer, bigint, float and double also support unsigned and zerofill properties, which can be combined in any order: Be aware that this does not apply for PostgreSQL!</source>
          <target state="translated">위에서 언급 한 유형 외에도 integer, bigint, float 및 double은 부호없는 속성과 zerofill 속성을 지원하며 어떤 순서로든 결합 할 수 있습니다. PostgreSQL에는 적용되지 않습니다!</target>
        </trans-unit>
        <trans-unit id="4af5be18db1ad6a1a653687156ac599be363d197" translate="yes" xml:space="preserve">
          <source>In addition to updating a single instance, you can also create, update, and delete multiple instances at once. The functions you are looking for are called</source>
          <target state="translated">단일 인스턴스를 업데이트하는 것 외에도 여러 인스턴스를 한 번에 생성, 업데이트 및 삭제할 수 있습니다. 찾고있는 기능을 호출</target>
        </trans-unit>
        <trans-unit id="3b4cc1fd5220310d89eae1cdb8b77cbdd42fe084" translate="yes" xml:space="preserve">
          <source>In addition, after &lt;code&gt;sequelize.sync&lt;/code&gt;, the column that has &lt;code&gt;allowNull: false&lt;/code&gt; will be defined with a &lt;code&gt;NOT NULL&lt;/code&gt; SQL constraint. This way, direct SQL queries that attempt to set the value to &lt;code&gt;null&lt;/code&gt; will also fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="608a03c2fd0a19b5347676b81f1f4afcab08cd8a" translate="yes" xml:space="preserve">
          <source>In all cases the default foreign key can be overwritten with the &lt;code&gt;foreignKey&lt;/code&gt; option. When the foreign key option is used, Sequelize will use it as-is:</source>
          <target state="translated">모든 경우에 기본 외래 키를 &lt;code&gt;foreignKey&lt;/code&gt; 옵션 으로 덮어 쓸 수 있습니다 . 외래 키 옵션을 사용하면 Sequelize는 그대로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8d1442396eb18b379c62184b1e4b086254375017" translate="yes" xml:space="preserve">
          <source>In all the above examples, Sequelize automatically defined the foreign key names. For example, in the Ship and Captain example, Sequelize automatically defined a &lt;code&gt;captainId&lt;/code&gt; field on the Ship model. However, it is easy to specify a custom foreign key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87e3b464a7b0b4502bc77b6934bf2e4a7e80ae02" translate="yes" xml:space="preserve">
          <source>In all the above examples, you have noticed that the &lt;code&gt;order&lt;/code&gt; option is used at the top-level. The only situation in which &lt;code&gt;order&lt;/code&gt; also works inside the include option is when &lt;code&gt;separate: true&lt;/code&gt; is used. In that case, the usage is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99f55560f4696287997d800d3e9204066e7c2fec" translate="yes" xml:space="preserve">
          <source>In all the examples above, the associations were defined by referencing the primary keys of the involved models (in our case, their IDs). However, Sequelize allows you to define an association that uses another field, instead of the primary key field, to establish the association.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95d034948d56093f4fd3a267db42db031dc3b1e0" translate="yes" xml:space="preserve">
          <source>In case you want to eager load soft deleted records you can do that by setting &lt;code&gt;include.paranoid&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">소프트 삭제 된 레코드를 열망하려는 경우 &lt;code&gt;include.paranoid&lt;/code&gt; 를 &lt;code&gt;false&lt;/code&gt; 로 설정하여이를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8ede833e4fc938a1a4307479c5c672f47f5c435" translate="yes" xml:space="preserve">
          <source>In case you want to eager load soft deleted records you can do that by setting &lt;code&gt;include.paranoid&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="779cd792541f894ff6ecc7d1a09d6d1d76f26c8a" translate="yes" xml:space="preserve">
          <source>In cases where &lt;code&gt;as&lt;/code&gt; has been defined it will be used in place of the target model name.</source>
          <target state="translated">경우 &lt;code&gt;as&lt;/code&gt; 정의되어이 대상 모델 이름 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a6e18661df62cf03ad1b8c1dfaac6d64093d6a9e" translate="yes" xml:space="preserve">
          <source>In cases where you don't need to access the metadata you can pass in a query type to tell sequelize how to format the results. For example, for a simple select query you could do:</source>
          <target state="translated">메타 데이터에 액세스 할 필요가없는 경우 쿼리 형식을 전달하여 결과의 ​​형식을 지정하는 방법을 시퀀스에 전달할 수 있습니다. 예를 들어 간단한 선택 쿼리의 경우 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4aea729d09c224501cfb5032276fe9968a6cefc" translate="yes" xml:space="preserve">
          <source>In contrast, performing updates and deletions involving nested objects is currently not possible. For that, you will have to perform each separate action explicitly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="038d4951b867c417185b9b9bd15b882b51593a33" translate="yes" xml:space="preserve">
          <source>In either case &lt;code&gt;$$&lt;/code&gt; can be used to escape a literal &lt;code&gt;$&lt;/code&gt; sign.</source>
          <target state="translated">두 경우 모두 &lt;code&gt;$$&lt;/code&gt; 를 사용하여 리터럴 &lt;code&gt;$&lt;/code&gt; 기호 를 이스케이프 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fb22fea74b5a18e9648dd5f3f86b3ca5f73fef84" translate="yes" xml:space="preserve">
          <source>In last step you have create a seed file. It's still not committed to database. To do that we need to run a simple command.</source>
          <target state="translated">마지막 단계에서 시드 파일을 작성했습니다. 여전히 데이터베이스에 커밋되지 않았습니다. 그렇게하려면 간단한 명령을 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="555e8f73359937df389576f9575dd78b1cbb04a0" translate="yes" xml:space="preserve">
          <source>In most case you won't need to access &lt;code&gt;namespace.get('transaction')&lt;/code&gt; directly, since all queries will automatically look for a transaction on the namespace:</source>
          <target state="translated">모든 쿼리는 네임 스페이스에서 자동으로 트랜잭션을 찾기 때문에 대부분의 경우 &lt;code&gt;namespace.get('transaction')&lt;/code&gt; 에 직접 액세스 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="0ffa4116223b3446ad2774ab40fc1bea5b948a6e" translate="yes" xml:space="preserve">
          <source>In order to alleviate that, we can pass &lt;code&gt;constraints: false&lt;/code&gt; to one of the associations:</source>
          <target state="translated">이를 완화하기 위해 &lt;code&gt;constraints: false&lt;/code&gt; 중 하나를 연관 중 하나에 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cc83ae9f1cd3ae67a5a6e4bc972a56286990ab33" translate="yes" xml:space="preserve">
          <source>In order to avoid installation bloat for non TS users, you must install the following typing packages manually:</source>
          <target state="translated">TS 사용자가 아닌 사용자를위한 설치 팽창을 피하려면 다음 유형의 패키지를 수동으로 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="d6af6a905ac1e115cb3fd844cc79b49b4cf1c9fa" translate="yes" xml:space="preserve">
          <source>In order to calculate the sum over a specific column of a table, you can use the &lt;code&gt;sum&lt;/code&gt; method.</source>
          <target state="translated">테이블의 특정 열에 대한 합계를 계산하기 위해 &lt;code&gt;sum&lt;/code&gt; 방법을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8941e4a38a8014ed6d514e02dc3ba6197c37e42b" translate="yes" xml:space="preserve">
          <source>In order to connect with a domain account, use the following format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba6b9538578934a76cde7cf0edf5896fb565e928" translate="yes" xml:space="preserve">
          <source>In order to create instances of defined classes just do as follows. You might recognize the syntax if you coded Ruby in the past. Using the &lt;code&gt;build&lt;/code&gt;-method will return an unsaved object, which you explicitly have to save.</source>
          <target state="translated">정의 된 클래스의 인스턴스를 만들려면 다음과 같이하십시오. 과거에 Ruby를 코딩 한 경우 구문을 인식 할 수 있습니다. &lt;code&gt;build&lt;/code&gt; -method를 사용하면 저장되지 않은 객체가 반환되며이를 명시 적으로 저장해야합니다.</target>
        </trans-unit>
        <trans-unit id="cf259232b5059754d2a1edf8525451aaa2799fec" translate="yes" xml:space="preserve">
          <source>In order to decrement values of an instance without running into concurrency issues, you may use &lt;code&gt;decrement&lt;/code&gt;.</source>
          <target state="translated">동시성 문제로 실행하지 않고 인스턴스의 값을 감소하기 위해, 당신은 사용할 수 &lt;code&gt;decrement&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca261ceb2eaf2ec423490304b525cf11f77c0268" translate="yes" xml:space="preserve">
          <source>In order to get Sequelize working nicely together with MySQL, you'll need to install&lt;code&gt;mysql2@^1.5.2&lt;/code&gt;or higher. Once that's done you can use it like this:</source>
          <target state="translated">Sequelize가 MySQL과 잘 작동하게하려면 &lt;code&gt;mysql2@^1.5.2&lt;/code&gt; 이상 을 설치해야합니다 . 완료되면 다음과 같이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d50628c2ff499beb4c82368b3c407f6af0a795fe" translate="yes" xml:space="preserve">
          <source>In order to increment values of an instance without running into concurrency issues, you may use &lt;code&gt;increment&lt;/code&gt;.</source>
          <target state="translated">동시성 문제로 실행하지 않고 인스턴스의 증가 값을 위해, 당신은 사용할 수 &lt;code&gt;increment&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d70c048aa1fe6b43739e632650236176aa7bfa9b" translate="yes" xml:space="preserve">
          <source>In order to increment/decrement values of an instance without running into concurrency issues, Sequelize provides the &lt;a href=&quot;../class/lib/model.js~model#instance-method-increment&quot;&gt;&lt;code&gt;increment&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../class/lib/model.js~model#instance-method-decrement&quot;&gt;&lt;code&gt;decrement&lt;/code&gt;&lt;/a&gt; instance methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ba11c5a40c1858c3524493596d5ef470b235de4" translate="yes" xml:space="preserve">
          <source>In order to study this, we will consider an example in which we have Ships and Captains, and a one-to-one relationship between them. We will allow null on foreign keys (the default), meaning that a Ship can exist without a Captain and vice-versa.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0fde8aaeee3bc4a835c8c347691ddba0cf5ca1b" translate="yes" xml:space="preserve">
          <source>In principle, both options are a valid way to establish a One-To-One relationship between Foo and Bar. However, when we say something like &lt;em&gt;&quot;there is a One-To-One relationship between Foo and Bar&quot;&lt;/em&gt;, it is unclear whether or not the relationship is &lt;em&gt;mandatory&lt;/em&gt; or optional. In other words, can a Foo exist without a Bar? Can a Bar exist without a Foo? The answers to these questions helps figuring out where we want the foreign key column to be.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="149d9edd63e09e594388c8c59f6205a3c7d42014" translate="yes" xml:space="preserve">
          <source>In production, you might want to consider using Migrations instead of calling &lt;code&gt;sync()&lt;/code&gt; in your code. Learn more in the &lt;a href=&quot;migrations&quot;&gt;Migrations&lt;/a&gt; guide.</source>
          <target state="translated">프로덕션에서는 코드에서 &lt;code&gt;sync()&lt;/code&gt; 를 호출하는 대신 마이그레이션을 사용하는 것이 좋습니다 . &lt;a href=&quot;migrations&quot;&gt;마이그레이션&lt;/a&gt; 가이드 에서 자세히 알아보세요 .</target>
        </trans-unit>
        <trans-unit id="a74a7155df00d0a2252e9007a9498cc7f775fb94" translate="yes" xml:space="preserve">
          <source>In short, the name of the field will take the most logical form in each situation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c86642a07888e6db73277af0c0eaac74cefb4e90" translate="yes" xml:space="preserve">
          <source>In the API reference below, add the name of the association to the method, e.g. for &lt;code&gt;User.belongsTo(Project)&lt;/code&gt; the getter will be &lt;code&gt;user.getProject()&lt;/code&gt;.</source>
          <target state="translated">아래의 API 참조에서 메소드에 연관 이름을 추가하십시오 &lt;code&gt;User.belongsTo(Project)&lt;/code&gt; 예 : User.belongsTo (Project)의 경우 getter는 &lt;code&gt;user.getProject()&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cef52cd717c629d67a98f43d7d2a3b36773181e1" translate="yes" xml:space="preserve">
          <source>In the API reference below, add the name of the association to the method, e.g. for &lt;code&gt;User.belongsToMany(Project)&lt;/code&gt; the getter will be &lt;code&gt;user.getProjects()&lt;/code&gt;.</source>
          <target state="translated">아래의 API 참조에서 메소드에 연관 이름을 추가하십시오 &lt;code&gt;User.belongsToMany(Project)&lt;/code&gt; 예 : User.belongsToMany (Project)의 경우 getter는 &lt;code&gt;user.getProjects()&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8b69de6ffb712491cc4ee70ce75bcc223197f419" translate="yes" xml:space="preserve">
          <source>In the API reference below, add the name of the association to the method, e.g. for &lt;code&gt;User.hasMany(Project)&lt;/code&gt; the getter will be &lt;code&gt;user.getProjects()&lt;/code&gt;. If the association is aliased, use the alias instead, e.g. &lt;code&gt;User.hasMany(Project, { as: 'jobs' })&lt;/code&gt; will be &lt;code&gt;user.getJobs()&lt;/code&gt;.</source>
          <target state="translated">아래의 API 참조에서 메소드에 연관 이름을 추가하십시오 &lt;code&gt;User.hasMany(Project)&lt;/code&gt; 예 : User.hasMany (Project)의 경우 getter는 &lt;code&gt;user.getProjects()&lt;/code&gt; 입니다. 연관이 별명 인 경우 별명을 대신 사용하십시오. 예를 들어 &lt;code&gt;User.hasMany(Project, { as: 'jobs' })&lt;/code&gt; 는 &lt;code&gt;user.getJobs()&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b19bcc7ba2b18c1f0e8b5d37540fdada124f6fcc" translate="yes" xml:space="preserve">
          <source>In the API reference below, add the name of the association to the method, e.g. for &lt;code&gt;User.hasOne(Project)&lt;/code&gt; the getter will be &lt;code&gt;user.getProject()&lt;/code&gt;. This is almost the same as &lt;code&gt;belongsTo&lt;/code&gt; with one exception - The foreign key will be defined on the target model.</source>
          <target state="translated">아래 API 참조에서 메소드에 연관 이름을 추가하십시오 &lt;code&gt;User.hasOne(Project)&lt;/code&gt; 예 : User.hasOne (Project)의 경우 getter는 &lt;code&gt;user.getProject()&lt;/code&gt; 입니다. 이것은 거의 동일 &lt;code&gt;belongsTo&lt;/code&gt; 를 한 가지 예외 - 외부 키는 대상 모델에 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="af86acfc1689af9e0f67efadcbe3050977007a0b" translate="yes" xml:space="preserve">
          <source>In the above example we are manually defining a key that references another model. It's not usual to do this, but if you have to, you should use the table name there. This is because the reference is created upon the referencced table name. In the example above, the plural form was used (&lt;code&gt;bars&lt;/code&gt;), assuming that the &lt;code&gt;bar&lt;/code&gt; model was created with the default settings (making its underlying table automatically pluralized).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c81e07a5c991fcdd92d6307e530a80a9f2f6471" translate="yes" xml:space="preserve">
          <source>In the above example, we had the models &lt;code&gt;Image&lt;/code&gt; and &lt;code&gt;Video&lt;/code&gt; being abstractly called &lt;em&gt;commentables&lt;/em&gt;, with one &lt;em&gt;commentable&lt;/em&gt; having many comments. However, one given comment would belong to a single &lt;em&gt;commentable&lt;/em&gt; - this is why the whole situation is a One-to-Many polymorphic association.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02da87402808a84b0a74230cb43a995fdad4b31d" translate="yes" xml:space="preserve">
          <source>In the case of a one-to-many relationship.</source>
          <target state="translated">일대 다 관계의 경우.</target>
        </trans-unit>
        <trans-unit id="5ae509345fb49ae661568fc4744caa7cb1b9656b" translate="yes" xml:space="preserve">
          <source>In the case of many-to-many joins, you are also able to sort by attributes in the through table.</source>
          <target state="translated">다 대다 조인의 경우, 스루 테이블의 속성을 기준으로 정렬 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb6a0758e1c142fc9e84ad288ea850c903fb1ad0" translate="yes" xml:space="preserve">
          <source>In the case of many-to-many relationships, you are also able to sort by attributes in the through table. For example, assuming we have a Many-to-Many relationship between &lt;code&gt;Division&lt;/code&gt; and &lt;code&gt;Department&lt;/code&gt; whose junction model is &lt;code&gt;DepartmentDivision&lt;/code&gt;, you can do:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="317c1f0442c62b94ccf6c9fc8c9140770a26fb3e" translate="yes" xml:space="preserve">
          <source>In the example above we have specified that a user belongs to his profile picture. Conceptually, this might not make sense, but since we want to add the foreign key to the user model this is the way to do it.</source>
          <target state="translated">위의 예에서 사용자는 자신의 프로필 사진에 속하도록 지정했습니다. 개념적으로는 이치에 맞지 않을 수도 있지만, 외래 키를 사용자 모델에 추가하려고하므로 이것이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="3f56aa735b7718af6d0f03509597c23eb6c23af7" translate="yes" xml:space="preserve">
          <source>In the example above, the &lt;code&gt;scope&lt;/code&gt; options (such as &lt;code&gt;scope: { taggableType: 'image' }&lt;/code&gt;) were applied to the &lt;em&gt;through&lt;/em&gt; model, not the &lt;em&gt;target&lt;/em&gt; model, since it was used under the &lt;code&gt;through&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce0b3ed97c0ca3b3cfb4f4a1a06ba62b0ecd8f3c" translate="yes" xml:space="preserve">
          <source>In the examples above, the transaction is still manually passed, by passing &lt;code&gt;{ transaction: t }&lt;/code&gt; as the second argument. To automatically pass the transaction to all queries you must install the &lt;a href=&quot;https://github.com/Jeff-Lewis/cls-hooked&quot;&gt;cls-hooked&lt;/a&gt; (CLS) module and instantiate a namespace in your own code:</source>
          <target state="translated">위의 예에서 트랜잭션은 두 번째 인수로 &lt;code&gt;{ transaction: t }&lt;/code&gt; 를 전달하여 여전히 수동으로 전달됩니다 . 트랜잭션을 모든 쿼리에 자동으로 전달하려면 &lt;a href=&quot;https://github.com/Jeff-Lewis/cls-hooked&quot;&gt;cls-hooked&lt;/a&gt; (CLS) 모듈을 설치하고 고유 코드에서 네임 스페이스를 인스턴스화해야합니다.</target>
        </trans-unit>
        <trans-unit id="2a0dce9e1d09c8edbde67374cb81c49870755238" translate="yes" xml:space="preserve">
          <source>In this document we'll explore what finder methods can do:</source>
          <target state="translated">이 문서에서는 파인더 메소드가 수행 할 수있는 작업을 살펴 ​​봅니다.</target>
        </trans-unit>
        <trans-unit id="613042d1f3606de477403116ad2dde419489b062" translate="yes" xml:space="preserve">
          <source>In this example the name of the postgres range type is &lt;code&gt;SOMETYPE_range&lt;/code&gt; and the name of the underlying postgres datatype is &lt;code&gt;pg_new_type&lt;/code&gt;. The key of &lt;code&gt;subtypes&lt;/code&gt; and &lt;code&gt;castTypes&lt;/code&gt; is the key of the Sequelize datatype &lt;code&gt;DataTypes.SOMETYPE.key&lt;/code&gt;, in lower case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ccb67d5f9158b5bfef3f61c07b44ac9e4f30373" translate="yes" xml:space="preserve">
          <source>In this example the name of the postgres range type is &lt;code&gt;newtype_range&lt;/code&gt; and the name of the underlying postgres datatype is &lt;code&gt;pg_new_type&lt;/code&gt;. The key of &lt;code&gt;subtypes&lt;/code&gt; and &lt;code&gt;castTypes&lt;/code&gt; is the key of the Sequelize datatype &lt;code&gt;DataTypes.NEWTYPE.key&lt;/code&gt;, in lower case.</source>
          <target state="translated">이 예제에서 postgres 범위 유형 의 이름 은 &lt;code&gt;newtype_range&lt;/code&gt; 이고 기본 postgres 데이터 유형의 이름은 &lt;code&gt;pg_new_type&lt;/code&gt; 입니다. 키의 &lt;code&gt;subtypes&lt;/code&gt; 과 &lt;code&gt;castTypes&lt;/code&gt; 는 Sequelize 데이터 유형의 핵심 &lt;code&gt;DataTypes.NEWTYPE.key&lt;/code&gt; 소문자.</target>
        </trans-unit>
        <trans-unit id="35c8c41b915b7cca99bbb0a9dd22f6c0333cde65" translate="yes" xml:space="preserve">
          <source>In this example, we have the models &lt;code&gt;Team&lt;/code&gt; and &lt;code&gt;Player&lt;/code&gt;. We want to tell Sequelize that there is a One-To-Many relationship between them, meaning that one Team has many Players, while each Player belongs to a single Team.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="183bd8588dc52f5cbe2e8f4e490c205e50053f9f" translate="yes" xml:space="preserve">
          <source>In this example, we will create a type called &lt;code&gt;SOMETYPE&lt;/code&gt; that replicates the built-in datatype &lt;code&gt;DataTypes.INTEGER(11).ZEROFILL.UNSIGNED&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f06d44df54aba38c2a1a5e52366770a4c55d5686" translate="yes" xml:space="preserve">
          <source>In this simple case an object fails validation if either latitude or longitude is given, but not both. If we try to build one with an out-of-range latitude and no longitude, &lt;code&gt;raging_bullock_arms.validate()&lt;/code&gt; might return</source>
          <target state="translated">이 간단한 경우 위도 또는 경도가 제공되지만 둘 다가 아닌 경우 객체의 유효성 검사에 실패합니다. 범위를 벗어난 위도와 경도가없는 건물을 만들려고하면 &lt;code&gt;raging_bullock_arms.validate()&lt;/code&gt; 가 반환 될 수 있습니다</target>
        </trans-unit>
        <trans-unit id="529d9ac265aa5c45aa5882637a91c017c2c415d6" translate="yes" xml:space="preserve">
          <source>In this simple case an object fails validation if either latitude or longitude is given, but not both. If we try to build one with an out-of-range latitude and no longitude, &lt;code&gt;somePlace.validate()&lt;/code&gt; might return:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9541234d9fda492dd87e27afb4fb9fb19d8de710" translate="yes" xml:space="preserve">
          <source>In this tutorial you will learn how to setup validations and constraints for your models in Sequelize.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3851d0f94c7be9ec7c5ead977d92fb894f0d89fb" translate="yes" xml:space="preserve">
          <source>In this tutorial you will learn to make a simple setup of Sequelize to learn the basics.</source>
          <target state="translated">이 자습서에서는 기본을 배우기 위해 Sequelize를 간단하게 설정하는 방법을 배웁니다.</target>
        </trans-unit>
        <trans-unit id="df1658fb7bea66f99a24c6472bf5de5a13879256" translate="yes" xml:space="preserve">
          <source>In this tutorial you will learn to make a simple setup of Sequelize.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39611ac13c57239c707052898ea1f9ac93ecacef" translate="yes" xml:space="preserve">
          <source>In this tutorial you will learn what models are in Sequelize and how to use them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f5430a6a9d01363455824822c75737cf9c8f435" translate="yes" xml:space="preserve">
          <source>Include all also supports nested loading:</source>
          <target state="translated">모두 포함은 중첩 로딩도 지원합니다.</target>
        </trans-unit>
        <trans-unit id="ee22d111d4c8367bcfece43e25265c1b1b970179" translate="yes" xml:space="preserve">
          <source>Include options. See &lt;code&gt;find&lt;/code&gt; for details</source>
          <target state="translated">옵션을 포함하십시오. 자세한 내용은 &lt;code&gt;find&lt;/code&gt; 를 참조하십시오</target>
        </trans-unit>
        <trans-unit id="f4eea4e4d711cc1ecb5cda0e5dbfb9571c247ac3" translate="yes" xml:space="preserve">
          <source>Includes are merged recursively based on the models being included. This is a very powerful merge, added on v5, and is better understood with an example.</source>
          <target state="translated">포함은 포함되는 모델을 기반으로 재귀 적으로 병합됩니다. 이것은 v5에 추가 된 매우 강력한 병합이며 예제를 통해 더 잘 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="027827ecd07b15695c7b030f1a2f763df4b19097" translate="yes" xml:space="preserve">
          <source>Including everything</source>
          <target state="translated">모든 것을 포함하여</target>
        </trans-unit>
        <trans-unit id="c00227cf95dc381c6c30d2e5768223f461bcb57c" translate="yes" xml:space="preserve">
          <source>Including soft deleted records</source>
          <target state="translated">소프트 삭제 된 레코드 포함</target>
        </trans-unit>
        <trans-unit id="54a09acba666b3479a71fa90551496293ff3b39c" translate="yes" xml:space="preserve">
          <source>Increment the value of one or more columns.</source>
          <target state="translated">하나 이상의 열 값을 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="787e3b938ace632df3c30ed406921fc264679317" translate="yes" xml:space="preserve">
          <source>Increment the value of one or more columns. This is done in the database, which means it does not use the values currently stored on the Instance. The increment is done using a</source>
          <target state="translated">하나 이상의 열 값을 증가시킵니다. 이는 데이터베이스에서 수행되므로 현재 인스턴스에 저장된 값을 사용하지 않습니다. 증분은</target>
        </trans-unit>
        <trans-unit id="76bdd22b4e3260f69cfe386f60459acba6de3c0d" translate="yes" xml:space="preserve">
          <source>Increment the value of one or more columns. This is done in the database, which means it does not use the values currently stored on the Instance. The increment is done using a &lt;code&gt;SET column = column + X WHERE foo = 'bar'&lt;/code&gt; query. To get the correct value after an increment into the Instance you should do a reload.</source>
          <target state="translated">하나 이상의 열 값을 증가시킵니다. 이는 데이터베이스에서 수행되므로 현재 인스턴스에 저장된 값을 사용하지 않습니다. 증분은 &lt;code&gt;SET column = column + X WHERE foo = 'bar'&lt;/code&gt; 쿼리를 사용하여 수행됩니다 . 인스턴스로 증가한 후 올바른 값을 얻으려면 다시로드해야합니다.</target>
        </trans-unit>
        <trans-unit id="a8ff72a665bb30731770e7705fe338083cf89b76" translate="yes" xml:space="preserve">
          <source>Incrementing</source>
          <target state="translated">Incrementing</target>
        </trans-unit>
        <trans-unit id="a1c24bf8bfe650fa4f84c009ba48a2fd9fc32de2" translate="yes" xml:space="preserve">
          <source>Incrementing and decrementing integer values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60049830fb2701db5de1c9bccb71b67fcbb23036" translate="yes" xml:space="preserve">
          <source>Index Hints</source>
          <target state="translated">색인 힌트</target>
        </trans-unit>
        <trans-unit id="b3ed723d45a3f790a9a9e12a818a0c61a8e14997" translate="yes" xml:space="preserve">
          <source>Index Hints - MySQL/MariaDB only</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea6eb3406625826a6548de806b904dddd5791b5e" translate="yes" xml:space="preserve">
          <source>Index hints &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/index-hints.html&quot;&gt;override the default behavior of the MySQL query optimizer&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15ed187841ecb74c7b628c9d39e663a146a445d1" translate="yes" xml:space="preserve">
          <source>Index hints &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/index-hints.html&quot;&gt;override the default behavior of the mysql query optimizer&lt;/a&gt;.</source>
          <target state="translated">인덱스 힌트 &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/index-hints.html&quot;&gt;는 mysql 쿼리 옵티마이 저의 기본 동작을 무시합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="27bf949a8c6bbf392cd9bbfb0a23ac87298c9ae6" translate="yes" xml:space="preserve">
          <source>Index name</source>
          <target state="translated">색인 이름</target>
        </trans-unit>
        <trans-unit id="d71a6a1e24a92e4c60cd3181a6a50dee24e968c7" translate="yes" xml:space="preserve">
          <source>Index name or list of attributes that in the index</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a9a9e601e879f8a25e6b88cecfaa9477d0b69b6" translate="yes" xml:space="preserve">
          <source>Index operator</source>
          <target state="translated">인덱스 연산자</target>
        </trans-unit>
        <trans-unit id="3db988cf9ae171debdcc20214fccade20a6d5743" translate="yes" xml:space="preserve">
          <source>Index type. Only used by mysql. One of &lt;code&gt;UNIQUE&lt;/code&gt;, &lt;code&gt;FULLTEXT&lt;/code&gt; and &lt;code&gt;SPATIAL&lt;/code&gt;</source>
          <target state="translated">인덱스 타입. mysql에서만 사용됩니다. &lt;code&gt;UNIQUE&lt;/code&gt; , &lt;code&gt;FULLTEXT&lt;/code&gt; 및 &lt;code&gt;SPATIAL&lt;/code&gt; 중 하나</target>
        </trans-unit>
        <trans-unit id="cbd5e44bf0af97c76997bc5bf5b67484d7bd41fd" translate="yes" xml:space="preserve">
          <source>IndexHints</source>
          <target state="translated">IndexHints</target>
        </trans-unit>
        <trans-unit id="f642ee196088372ea886186c6c617515599afd3f" translate="yes" xml:space="preserve">
          <source>Indexes</source>
          <target state="translated">Indexes</target>
        </trans-unit>
        <trans-unit id="d546d086737ecd71ea685f7ecca5e406efe04475" translate="yes" xml:space="preserve">
          <source>Indirect Subclass:</source>
          <target state="translated">간접 서브 클래스 :</target>
        </trans-unit>
        <trans-unit id="5f86be890f5fca505337bd96fadab61d81d1721f" translate="yes" xml:space="preserve">
          <source>Inherited Summary</source>
          <target state="translated">상속 요약</target>
        </trans-unit>
        <trans-unit id="31f1c8a556d0112856c008a3ad8749f41bf60b3f" translate="yes" xml:space="preserve">
          <source>Initialize a model, representing a table in the DB, with attributes and options.</source>
          <target state="translated">속성 및 옵션을 사용하여 DB의 테이블을 나타내는 모델을 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="34082efdebc41766317697316140da8f26c3e107" translate="yes" xml:space="preserve">
          <source>Insert multiple records into a table</source>
          <target state="translated">테이블에 여러 레코드 삽입</target>
        </trans-unit>
        <trans-unit id="7ec8753d3a44c87c9473adfa6c44b60942d04fe3" translate="yes" xml:space="preserve">
          <source>Insert or update a single row.</source>
          <target state="translated">단일 행을 삽입하거나 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="2dd5c9df09dccb9c155c03e0ece1aeed6a35cf5c" translate="yes" xml:space="preserve">
          <source>Insert or update a single row. An update will be executed if a row which matches the supplied values on either the primary key or a unique key is found. Note that the unique index must be defined in your sequelize model and not just in the table. Otherwise you may experience a unique constraint violation, because sequelize fails to identify the row that should be updated.</source>
          <target state="translated">단일 행을 삽입하거나 업데이트하십시오. 기본 키 또는 고유 키의 제공된 값과 일치하는 행을 찾으면 업데이트가 실행됩니다. 고유 인덱스는 테이블뿐만 아니라 시퀀싱 모델에서도 정의해야합니다. 그렇지 않으면 sequelize가 업데이트해야 할 행을 식별하지 못하기 때문에 고유 제약 조건 위반이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fcf41de510c5775db6e05c056c7c1d5562270b3" translate="yes" xml:space="preserve">
          <source>Insert several rows and return all columns (Postgres only):</source>
          <target state="translated">여러 행을 삽입하고 모든 열을 반환합니다 (Postgres 만 해당).</target>
        </trans-unit>
        <trans-unit id="82c27a49773b27db4a4892eb51537165bf561a05" translate="yes" xml:space="preserve">
          <source>Insert several rows and return specific columns (Postgres only):</source>
          <target state="translated">여러 행을 삽입하고 특정 열을 반환합니다 (Postgres 만 해당).</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="e38432618ce4d39079fc324e614d4d92a2815160" translate="yes" xml:space="preserve">
          <source>Installing</source>
          <target state="translated">Installing</target>
        </trans-unit>
        <trans-unit id="738e880dd4e789ec957d300caa68fee228a78956" translate="yes" xml:space="preserve">
          <source>Installing CLI</source>
          <target state="translated">CLI 설치</target>
        </trans-unit>
        <trans-unit id="05cd2d2edbef55f0f40dc901ecbc1b64b01dcaa9" translate="yes" xml:space="preserve">
          <source>Installing the CLI</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccb890bc332682567d34290c45bd65a654e962bd" translate="yes" xml:space="preserve">
          <source>Instance build options</source>
          <target state="translated">인스턴스 빌드 옵션</target>
        </trans-unit>
        <trans-unit id="5ac629af8667053ca02646726c3c988282dc7f26" translate="yes" xml:space="preserve">
          <source>Instance hooks</source>
          <target state="translated">인스턴스 훅</target>
        </trans-unit>
        <trans-unit id="274ad4dd86f2d3421e19dbc845f0539216d205f2" translate="yes" xml:space="preserve">
          <source>InstanceError</source>
          <target state="translated">InstanceError</target>
        </trans-unit>
        <trans-unit id="86d67413e7f102d37a19a41e92518fd07b196a5a" translate="yes" xml:space="preserve">
          <source>Instances</source>
          <target state="translated">Instances</target>
        </trans-unit>
        <trans-unit id="9e8467d590d4be1587eaf02bbcf552bcc1c6e813" translate="yes" xml:space="preserve">
          <source>Instantiate sequelize with name of database, username and password.</source>
          <target state="translated">데이터베이스 이름, 사용자 이름 및 비밀번호로 순서를 인스턴스화하십시오.</target>
        </trans-unit>
        <trans-unit id="d51d3d0b6180f2e7c14a0b2e9f6c9dec8347e6ef" translate="yes" xml:space="preserve">
          <source>Instead of a string, passing a model directly is also supported, and in that case the given model will be used as the junction model (and no model will be created automatically). For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3094ee388cfb121e08aa8acc192a2cdfc0b8210" translate="yes" xml:space="preserve">
          <source>Instead of calling &lt;code&gt;sync()&lt;/code&gt; for every model, you can call &lt;code&gt;sequelize.sync()&lt;/code&gt; which will automatically sync all models.</source>
          <target state="translated">모든 모델 에 대해 &lt;code&gt;sync()&lt;/code&gt; 를 호출하는 대신 &lt;code&gt;sequelize.sync()&lt;/code&gt; 를 호출하면 모든 모델이 자동으로 동기화됩니다.</target>
        </trans-unit>
        <trans-unit id="05580f601b5eaa4bd8a72a894129babf0543db11" translate="yes" xml:space="preserve">
          <source>Instead of setting up the Many-to-Many relationship defined above, what if we did the following instead?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9edcffff4461c9083fbff857f8dcee0f0769cbd4" translate="yes" xml:space="preserve">
          <source>Integer</source>
          <target state="translated">Integer</target>
        </trans-unit>
        <trans-unit id="490af473232b6a93643f272bee98388cd223e9fd" translate="yes" xml:space="preserve">
          <source>Internal Transactions</source>
          <target state="translated">내부 거래</target>
        </trans-unit>
        <trans-unit id="9012b802b5499dddeaa05001c949bbc17d0e16f2" translate="yes" xml:space="preserve">
          <source>Internally, &lt;code&gt;sequelize.define&lt;/code&gt; calls &lt;code&gt;Model.init&lt;/code&gt;, so both approaches are essentially equivalent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d3960679eb413b74946e3c8863bed548577df5d" translate="yes" xml:space="preserve">
          <source>Internally, &lt;code&gt;sequelize.define&lt;/code&gt; calls &lt;code&gt;Model.init&lt;/code&gt;.</source>
          <target state="translated">내부적으로 &lt;code&gt;sequelize.define&lt;/code&gt; 은 Model.init를 호출 &lt;code&gt;Model.init&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a26b8650a9de522981bcafa08f85067a7ddceb6" translate="yes" xml:space="preserve">
          <source>InvalidConnectionError</source>
          <target state="translated">InvalidConnectionError</target>
        </trans-unit>
        <trans-unit id="9211e9fa56459ab7c08f8f8f8b73301a55b7ccfe" translate="yes" xml:space="preserve">
          <source>Is this a new record</source>
          <target state="translated">이것은 새로운 기록입니까</target>
        </trans-unit>
        <trans-unit id="afe7a6e84bced131db798b6f4a5218b8ba604521" translate="yes" xml:space="preserve">
          <source>Is this binary?</source>
          <target state="translated">이 바이너리입니까?</target>
        </trans-unit>
        <trans-unit id="6930c839f5926a5dbc3973abed70a968ebe27fcd" translate="yes" xml:space="preserve">
          <source>Is this new record</source>
          <target state="translated">이 새로운 기록인가요</target>
        </trans-unit>
        <trans-unit id="ff65e83635da6a16fc4326dabfbf055783a3b67f" translate="yes" xml:space="preserve">
          <source>Is unsigned?</source>
          <target state="translated">서명이 없습니까?</target>
        </trans-unit>
        <trans-unit id="e43b3654cb7e64fdddd41aa99284538c43372f9f" translate="yes" xml:space="preserve">
          <source>Is zero filled?</source>
          <target state="translated">0이 채워져 있습니까?</target>
        </trans-unit>
        <trans-unit id="bc950c72cafdb1b72d875b5f0116396b3dcf31bd" translate="yes" xml:space="preserve">
          <source>Isolation levels</source>
          <target state="translated">격리 수준</target>
        </trans-unit>
        <trans-unit id="ceb55c4968b36fcfbb8bfa38dd67ef748266db4a" translate="yes" xml:space="preserve">
          <source>Isolation levels can be set per-transaction by passing &lt;code&gt;options.isolationLevel&lt;/code&gt; to &lt;code&gt;sequelize.transaction&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;options.isolationLevel&lt;/code&gt; 을 &lt;code&gt;sequelize.transaction&lt;/code&gt; 로 전달 하여 트랜잭션별로 격리 레벨을 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7de7da7cce1fe9bf748f458bb4ef7c345ecf4b72" translate="yes" xml:space="preserve">
          <source>Isolation levels can be set per-transaction by passing &lt;code&gt;options.isolationLevel&lt;/code&gt; to &lt;code&gt;sequelize.transaction&lt;/code&gt;. Sequelize uses the default isolation level of the database, you can override this by passing &lt;code&gt;options.isolationLevel&lt;/code&gt; in Sequelize constructor options.</source>
          <target state="translated">&lt;code&gt;options.isolationLevel&lt;/code&gt; 을 &lt;code&gt;sequelize.transaction&lt;/code&gt; 로 전달 하여 트랜잭션별로 격리 레벨을 설정할 수 있습니다 . Sequelize는 데이터베이스의 기본 격리 수준을 사용하므로 Sequelize 생성자 옵션에서 &lt;code&gt;options.isolationLevel&lt;/code&gt; 을 전달하여이를 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f496de06c48426836962ac319b8e34aaa93ebfe2" translate="yes" xml:space="preserve">
          <source>It can be used, for example, to move the where conditions from an included model from the &lt;code&gt;ON&lt;/code&gt; condition to a top-level &lt;code&gt;WHERE&lt;/code&gt; clause.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5908ca9c9e90f7ff830f11cc8c2e2d27ebe810b5" translate="yes" xml:space="preserve">
          <source>It is also possible to define which attributes can be set in the &lt;code&gt;create&lt;/code&gt; method. This can be especially useful if you create database entries based on a form which can be filled by a user. Using that would, for example, allow you to restrict the &lt;code&gt;User&lt;/code&gt; model to set only an username and an address but not an admin flag:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c4c047702785b929a273515b1a82e520030e139" translate="yes" xml:space="preserve">
          <source>It is also possible to define which attributes can be set via the create method. This can be especially very handy if you create database entries based on a form which can be filled by a user. Using that would for example allow you to restrict the &lt;code&gt;User&lt;/code&gt; model to set only a username and an address but not an admin flag:</source>
          <target state="translated">create 메소드를 통해 설정할 수있는 속성을 정의 할 수도 있습니다. 사용자가 채울 수있는 양식을 기반으로 데이터베이스 항목을 작성하는 경우 특히 유용합니다. 예를 들어 &lt;code&gt;User&lt;/code&gt; 모델을 사용하여 사용자 이름과 주소 만 설정하고 관리자 플래그는 설정하지 못하도록 제한 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b0c239eac3353866dc58bd00ecb70b3153364af7" translate="yes" xml:space="preserve">
          <source>It is also possible to enable only one of &lt;code&gt;createdAt&lt;/code&gt;/&lt;code&gt;updatedAt&lt;/code&gt;, and to provide a custom name for these columns:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="458150e56a3d316de3d7363070d164f7fb22c292" translate="yes" xml:space="preserve">
          <source>It is also possible to include scoped models in a scope definition. This allows you to avoid duplicating &lt;code&gt;include&lt;/code&gt;, &lt;code&gt;attributes&lt;/code&gt; or &lt;code&gt;where&lt;/code&gt; definitions. Using the above example, and invoking the &lt;code&gt;active&lt;/code&gt; scope on the included User model (rather than specifying the condition directly in that include object):</source>
          <target state="translated">범위 정의에 범위가 지정된 모델을 포함시킬 수도 있습니다. 이것은 당신이 복제는 피할 수 &lt;code&gt;include&lt;/code&gt; , &lt;code&gt;attributes&lt;/code&gt; 또는 &lt;code&gt;where&lt;/code&gt; 정의합니다. 위의 예제를 사용하고 포함 오브젝트에 직접 조건을 지정하지 않고 포함 된 사용자 모델 에서 &lt;code&gt;active&lt;/code&gt; 범위를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="ddee74f90f8a0f9498567c187f111536a9989a76" translate="yes" xml:space="preserve">
          <source>It is possible to define 'object-property' getters and setter functions on your models, these can be used both for 'protecting' properties that map to database fields and for defining 'pseudo' properties.</source>
          <target state="translated">모델에서 '객체 속성'게터와 세터 함수를 정의 할 수 있습니다. 데이터베이스 필드에 매핑되는 '보호'속성과 '의사'속성을 정의하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2cf42e7c4455442ac5cf3de78fb4007302cbe5bc" translate="yes" xml:space="preserve">
          <source>It is possible to define which attributes should be saved when calling &lt;code&gt;save&lt;/code&gt;, by passing an array of column names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74a71f5d94391e3a53655bde1f0b03cfbba3c3e0" translate="yes" xml:space="preserve">
          <source>It is very important to recognize that sequelize may make use of transactions internally for certain operations such as &lt;code&gt;Model.findOrCreate&lt;/code&gt;. If your hook functions execute read or write operations that rely on the object's presence in the database, or modify the object's stored values like the example in the preceding section, you should always specify &lt;code&gt;{ transaction: options.transaction }&lt;/code&gt;.</source>
          <target state="translated">sequelize가 &lt;code&gt;Model.findOrCreate&lt;/code&gt; 와 같은 특정 작업에 내부적으로 트랜잭션을 사용할 수 있다는 것을 인식하는 것이 매우 중요합니다 . 후크 함수가 데이터베이스에서 오브젝트의 존재에 의존하는 읽기 또는 쓰기 조작을 실행하거나 이전 섹션의 예제와 같이 오브젝트의 저장된 값을 수정하는 경우 항상 &lt;code&gt;{ transaction: options.transaction }&lt;/code&gt; 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8cbe639adc8bf73296a8d97150622ca8fa39f49f" translate="yes" xml:space="preserve">
          <source>It is very important to recognize that sequelize may make use of transactions internally for certain operations such as &lt;code&gt;Model.findOrCreate&lt;/code&gt;. If your hook functions execute read or write operations that rely on the object's presence in the database, or modify the object's stored values like the example in the preceding section, you should always specify &lt;code&gt;{ transaction: options.transaction }&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f7799cf6357af0cca9dd406aa99d1e281329530" translate="yes" xml:space="preserve">
          <source>It support includes. Only the includes that are marked as &lt;code&gt;required&lt;/code&gt; will be added to the count part:</source>
          <target state="translated">지원합니다. &lt;code&gt;required&lt;/code&gt; 것으로 표시된 포함 만 카운트 부분에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="bd69590aa6bbe4480618acdf15708dead6c39e48" translate="yes" xml:space="preserve">
          <source>It works by simply converting the &lt;code&gt;commentableType&lt;/code&gt; string into a call to the correct mixin (either &lt;code&gt;getImage&lt;/code&gt; or &lt;code&gt;getVideo&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2fa0eaed2c83826a4335df13a4096e1512c947c" translate="yes" xml:space="preserve">
          <source>It would be nice to have a simple way to obtain the &lt;em&gt;full name&lt;/em&gt; directly! We can combine the idea of &lt;code&gt;getters&lt;/code&gt; with the special data type Sequelize provides for this kind of situation: &lt;code&gt;DataTypes.VIRTUAL&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01152ec68278f8c0093062867b00c1b97313670b" translate="yes" xml:space="preserve">
          <source>It's also possible to define which attributes should be saved when calling &lt;code&gt;save&lt;/code&gt;, by passing an array of column names. This is useful when you set attributes based on a previously defined object. E.g. if you get the values of an object via a form of a web app. Furthermore this is used internally for &lt;code&gt;update&lt;/code&gt;. This is how it looks like:</source>
          <target state="translated">열 이름 배열을 전달하여 &lt;code&gt;save&lt;/code&gt; 를 호출 할 때 저장해야 할 속성을 정의 할 수도 있습니다 . 이것은 이전에 정의 된 객체를 기반으로 속성을 설정할 때 유용합니다. 예를 들어 웹 앱 형식을 통해 객체의 값을 얻는 경우. 또한 이것은 &lt;code&gt;update&lt;/code&gt; 위해 내부적으로 사용 됩니다 . 이것은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="186c4dfd035ca2147d8122391c159c1157303e72" translate="yes" xml:space="preserve">
          <source>It's also possible to generate complex AND/OR conditions by nesting sets of &lt;code&gt;or&lt;/code&gt; and &lt;code&gt;and&lt;/code&gt;&lt;code&gt;Operators&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;or&lt;/code&gt; 및 &lt;code&gt;and&lt;/code&gt; &lt;code&gt;Operators&lt;/code&gt; 세트를 중첩하여 복잡한 AND / OR 조건을 생성 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ad75613877702555cf316afa651fd68d8ed8a686" translate="yes" xml:space="preserve">
          <source>It's possible to do complex where queries with multiple levels of nested AND, OR and NOT conditions. In order to do that you can use &lt;code&gt;or&lt;/code&gt;, &lt;code&gt;and&lt;/code&gt; or &lt;code&gt;not&lt;/code&gt;&lt;code&gt;Operators&lt;/code&gt;:</source>
          <target state="translated">여러 수준의 중첩 AND, OR 및 NOT 조건을 가진 쿼리를 복잡한 위치에서 수행 할 수 있습니다. 당신이 사용할 수있는 그렇게하기 위해서는 &lt;code&gt;or&lt;/code&gt; , &lt;code&gt;and&lt;/code&gt; 나 &lt;code&gt;not&lt;/code&gt; &lt;code&gt;Operators&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="33734b6b70c0dff634a36534b531693609e70498" translate="yes" xml:space="preserve">
          <source>Its only supported with PostgreSQL.</source>
          <target state="translated">PostgreSQL에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="1f44599e616dde41701858fd22f0b746bfc3570b" translate="yes" xml:space="preserve">
          <source>JSON (SQLite, MySQL, MariaDB and PostgreSQL only)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a54171212861b9d4356ac5edc1e9c7b38716888" translate="yes" xml:space="preserve">
          <source>JSONB</source>
          <target state="translated">JSONB</target>
        </trans-unit>
        <trans-unit id="9cae984f3c9cd02acd6f6c61683bf9608c927849" translate="yes" xml:space="preserve">
          <source>JSONB (PostgreSQL only)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f235f39a2853ef490db9713b7ebbf2012bdcd6a" translate="yes" xml:space="preserve">
          <source>JSONB can be queried in three different ways.</source>
          <target state="translated">JSONB는 세 가지 방법으로 쿼리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="6b46dddcae84eab844147b41df08409aa05a20dc" translate="yes" xml:space="preserve">
          <source>JSONTYPE</source>
          <target state="translated">JSONTYPE</target>
        </trans-unit>
        <trans-unit id="1b6db652a7d2e721c6dbc04c119efa63e9efcd36" translate="yes" xml:space="preserve">
          <source>Just like Sequelize inferred the &lt;code&gt;Op.eq&lt;/code&gt; operator in the first example, here Sequelize inferred that the caller wanted an &lt;code&gt;AND&lt;/code&gt; for the two checks. The code above is equivalent to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90e0091ec5c2d29c031ee3793a2b88d1b8f7e828" translate="yes" xml:space="preserve">
          <source>Just like you use &lt;a href=&quot;https://en.wikipedia.org/wiki/Version_control&quot;&gt;version control&lt;/a&gt; systems such as &lt;a href=&quot;https://en.wikipedia.org/wiki/Git&quot;&gt;Git&lt;/a&gt; to manage changes in your source code, you can use &lt;strong&gt;migrations&lt;/strong&gt; to keep track of changes to the database. With migrations you can transfer your existing database into another state and vice versa: Those state transitions are saved in migration files, which describe how to get to the new state and how to revert the changes in order to get back to the old state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7bddeac6e43c3fc69422d0e6157627a2408995d" translate="yes" xml:space="preserve">
          <source>Just like you use Git / SVN to manage changes in your source code, you can use migrations to keep track of changes to the database. With migrations you can transfer your existing database into another state and vice versa: Those state transitions are saved in migration files, which describe how to get to the new state and how to revert the changes in order to get back to the old state.</source>
          <target state="translated">Git / SVN을 사용하여 소스 코드의 변경 사항을 관리하는 것처럼 마이그레이션을 사용하여 데이터베이스의 변경 사항을 추적 할 수 있습니다. 마이그레이션을 사용하면 기존 데이터베이스를 다른 상태로 또는 그 반대로 전송할 수 있습니다. 이러한 상태 전환은 마이그레이션 파일에 저장됩니다. 마이그레이션 파일은 새 상태로 이동하는 방법과 이전 상태로 돌아 가기 위해 변경 사항을 되 돌리는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="7a005acb56700e9225239e9495e645f1d56cb1fd" translate="yes" xml:space="preserve">
          <source>KEY_SHARE</source>
          <target state="translated">KEY_SHARE</target>
        </trans-unit>
        <trans-unit id="1aad7db5cd6d6405bc949aa858fe80dadf3e960b" translate="yes" xml:space="preserve">
          <source>Keep in mind, the provided range value can &lt;a href=&quot;data-types#range-types&quot;&gt;define the bound inclusion/exclusion&lt;/a&gt; as well.</source>
          <target state="translated">제공된 범위 값은 &lt;a href=&quot;data-types#range-types&quot;&gt;바운드 포함 / 제외&lt;/a&gt; 도 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f136aea4f1c2a2fd3c7128a9df5a17d4667d4079" translate="yes" xml:space="preserve">
          <source>Lazy Loading example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a251ad95f6b7bd7655523b67ea7799fe5cf895ed" translate="yes" xml:space="preserve">
          <source>Learn more in the &lt;a href=&quot;../class/lib/sequelize.js~sequelize#instance-constructor-constructor&quot;&gt;API Reference for the Sequelize constructor&lt;/a&gt;. If you're connecting to the database from multiple processes, you'll have to create one instance per process, but each instance should have a maximum connection pool size of such that the total maximum size is respected. For example, if you want a max connection pool size of 90 and you have three processes, the Sequelize instance of each process should have a max connection pool size of 30.</source>
          <target state="translated">&lt;a href=&quot;../class/lib/sequelize.js~sequelize#instance-constructor-constructor&quot;&gt;Sequelize 생성자 용 API 참조 서&lt;/a&gt; 에서 자세히 알아보십시오 . 여러 프로세스에서 데이터베이스에 연결하는 경우 프로세스 당 하나의 인스턴스를 작성해야하지만 각 인스턴스의 최대 연결 풀 크기는 총 최대 크기를 준수해야합니다. 예를 들어 최대 연결 풀 크기가 90이고 세 개의 프로세스가있는 경우 각 프로세스의 Sequelize 인스턴스의 최대 연결 풀 크기는 30이어야합니다.</target>
        </trans-unit>
        <trans-unit id="a92971ad92078a93938d1d32e8bcf667b401c1d8" translate="yes" xml:space="preserve">
          <source>Let's again use the example of Ships and Captains. Additionally, we will assume that Captain names are unique:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e70630a2a7c6ee7db84c3c444d456846c5656b46" translate="yes" xml:space="preserve">
          <source>Let's assume the following setup:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="485d34bd5489f8e0226bedab13b81d0bca93aff5" translate="yes" xml:space="preserve">
          <source>Let's assume we have an empty database with a &lt;code&gt;User&lt;/code&gt; model which has a &lt;code&gt;username&lt;/code&gt; and a &lt;code&gt;job&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;username&lt;/code&gt; 과 &lt;code&gt;job&lt;/code&gt; 을 가진 &lt;code&gt;User&lt;/code&gt; 모델을 가진 빈 데이터베이스가 있다고 가정 해 봅시다 .</target>
        </trans-unit>
        <trans-unit id="385b4743ceb6a3534da7935e92d609b7f7527dd1" translate="yes" xml:space="preserve">
          <source>Let's assume we have three users, whose ages are 10, 5, and 40.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cce562eca4ce92817d991109132657b7b4e3ad1" translate="yes" xml:space="preserve">
          <source>Let's consider the models Ship and Captain in a simplified form, just to focus on the current topic, as shown below (less fields):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2203a28193ce384212442ecbf1bb9f0fad5d8a3" translate="yes" xml:space="preserve">
          <source>Let's create a model named &lt;code&gt;User&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;User&lt;/code&gt; 라는 모델을 만들어 봅시다 .</target>
        </trans-unit>
        <trans-unit id="f35d6d8183466326bcc0a6d0a3f462695c8d381b" translate="yes" xml:space="preserve">
          <source>Let's create a seed file which will add a demo user to our &lt;code&gt;User&lt;/code&gt; table.</source>
          <target state="translated">&lt;code&gt;User&lt;/code&gt; 테이블에 데모 사용자를 추가 할 seed 파일을 만들어 봅시다 .</target>
        </trans-unit>
        <trans-unit id="3ed6b05acdd3e3db0228fdc3709dee44638806dd" translate="yes" xml:space="preserve">
          <source>Let's fill our tables with some data:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be20a5757d775035047e08bf42879daa6e2f59aa" translate="yes" xml:space="preserve">
          <source>Let's first begin with a basic concept that you will see used in most associations, &lt;strong&gt;source&lt;/strong&gt; and &lt;strong&gt;target&lt;/strong&gt; model. Suppose you are trying to add an association between two Models. Here we are adding a &lt;code&gt;hasOne&lt;/code&gt; association between &lt;code&gt;User&lt;/code&gt; and &lt;code&gt;Project&lt;/code&gt;.</source>
          <target state="translated">먼저 대부분의 연관, &lt;strong&gt;소스&lt;/strong&gt; 및 &lt;strong&gt;대상&lt;/strong&gt; 모델 에서 사용되는 기본 개념으로 시작하겠습니다 . 두 모델 사이에 연관을 추가하려고한다고 가정하십시오. 여기서 &lt;code&gt;User&lt;/code&gt; 와 &lt;code&gt;Project&lt;/code&gt; 사이에 &lt;code&gt;hasOne&lt;/code&gt; 연관을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="1c450eed0e9c2a25ffab9271fad2fadc6b27a9d2" translate="yes" xml:space="preserve">
          <source>Let's introduce the ability to associate a product with many tags. Setting up the models could look like:</source>
          <target state="translated">제품을 여러 태그와 연결하는 기능을 소개하겠습니다. 모델 설정은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="87aac229dd1d4995475dbcc51641de5b2c4552f0" translate="yes" xml:space="preserve">
          <source>Let's modify last example to use &lt;code&gt;underscored&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;underscored&lt;/code&gt; 옵션 을 사용하도록 마지막 예를 수정하겠습니다 .</target>
        </trans-unit>
        <trans-unit id="5a82db14e28117aaba1b3a12ce0a9553639d87b7" translate="yes" xml:space="preserve">
          <source>Let's say the name of the new datatype is &lt;code&gt;pg_new_type&lt;/code&gt; in the postgres database. That name has to be mapped to &lt;code&gt;DataTypes.NEWTYPE&lt;/code&gt;. Additionally, it is required to create a child postgres-specific datatype.</source>
          <target state="translated">postgres 데이터베이스에서 새 데이터 유형의 이름이 &lt;code&gt;pg_new_type&lt;/code&gt; 이라고 가정 해 봅시다 . 이 이름은 &lt;code&gt;DataTypes.NEWTYPE&lt;/code&gt; 에 매핑되어야 합니다. 또한 하위 postgres 관련 데이터 유형을 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="a6248e443874e08a90a46ab93360697f20a4e45c" translate="yes" xml:space="preserve">
          <source>Let's say the name of the new datatype is &lt;code&gt;pg_new_type&lt;/code&gt; in the postgres database. That name has to be mapped to &lt;code&gt;DataTypes.SOMETYPE&lt;/code&gt;. Additionally, it is required to create a child postgres-specific datatype.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae675e319f2445a495259e680916fd666189df3f" translate="yes" xml:space="preserve">
          <source>Let's say we have two models, &lt;code&gt;Foo&lt;/code&gt; and &lt;code&gt;Bar&lt;/code&gt;. We want to establish a One-To-One relationship between Foo and Bar. We know that in a relational database, this will be done by establishing a foreign key in one of the tables. So in this case, a very relevant question is: in which table do we want this foreign key to be? In other words, do we want &lt;code&gt;Foo&lt;/code&gt; to have a &lt;code&gt;barId&lt;/code&gt; column, or should &lt;code&gt;Bar&lt;/code&gt; have a &lt;code&gt;fooId&lt;/code&gt; column instead?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="247cfd48c0ec826e4c2ab834edae66a5287577ad" translate="yes" xml:space="preserve">
          <source>Let's say we wanted to compute via SQL a &lt;code&gt;laughReactionsCount&lt;/code&gt; for each post. We can achieve that with a sub-query, such as the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1923823b143c33ba8663b6d9fba34edbb5682fbc" translate="yes" xml:space="preserve">
          <source>Let's start with an example of a Many-to-Many relationship between &lt;code&gt;User&lt;/code&gt; and &lt;code&gt;Profile&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45a0d37d2635e9d8af766d2643fce24860a449d3" translate="yes" xml:space="preserve">
          <source>Let's start with an example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46dbb18d37841e79a9d96e647e55be1608250c26" translate="yes" xml:space="preserve">
          <source>Let's start with installing CLI, you can find instructions &lt;a href=&quot;https://github.com/sequelize/cli&quot;&gt;here&lt;/a&gt;. Most preferred way is installing locally like this</source>
          <target state="translated">CLI 설치부터 시작하겠습니다 . &lt;a href=&quot;https://github.com/sequelize/cli&quot;&gt;여기에서&lt;/a&gt; 지침을 찾을 수 있습니다 . 가장 선호되는 방법은 다음과 같이 로컬로 설치하는 것입니다</target>
        </trans-unit>
        <trans-unit id="3dc80430a2ae5ef7084165f4e5c699da1d9acc78" translate="yes" xml:space="preserve">
          <source>Library for MariaDB is &lt;code&gt;mariadb&lt;/code&gt;.</source>
          <target state="translated">MariaDB 용 라이브러리는 &lt;code&gt;mariadb&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">MIT 라이센스에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="fa326bf4cc5351dc6d6da0f1e48826f37aa9639a" translate="yes" xml:space="preserve">
          <source>Like One-To-One relationships, &lt;code&gt;ON DELETE&lt;/code&gt; defaults to &lt;code&gt;SET NULL&lt;/code&gt; and &lt;code&gt;ON UPDATE&lt;/code&gt; defaults to &lt;code&gt;CASCADE&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cf0ed70d28c5fe8dd844be088f6f6fd0468718b" translate="yes" xml:space="preserve">
          <source>Like every option for the definition of a model, this setting can also be changed globally with the &lt;code&gt;define&lt;/code&gt; option of the Sequelize constructor:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0f639fe70cb19d3a7d5bb33f35f4fcb35b0d6fb" translate="yes" xml:space="preserve">
          <source>Limit for result</source>
          <target state="translated">결과 한도</target>
        </trans-unit>
        <trans-unit id="1aeadbc7b1706711e989275655be9254c82690d6" translate="yes" xml:space="preserve">
          <source>Limit the joined rows, only supported with include.separate=true</source>
          <target state="translated">include.separate = true로만 지원되는 결합 된 행을 제한하십시오.</target>
        </trans-unit>
        <trans-unit id="fda46d024f6ba85e7193174aeaa7d98a2bd9ca31" translate="yes" xml:space="preserve">
          <source>Limits and Pagination</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6fd3870c86e7422a0146e1e2a052437fb8e51e2" translate="yes" xml:space="preserve">
          <source>Lines</source>
          <target state="translated">Lines</target>
        </trans-unit>
        <trans-unit id="6038611e4627885d1cb51cbde6704232a5114027" translate="yes" xml:space="preserve">
          <source>List all enums (Postgres only)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dab3b0aa2150bf658272546827c1ef560b7cbe7" translate="yes" xml:space="preserve">
          <source>List of attributes to add index on</source>
          <target state="translated">인덱스를 추가 할 속성 목록</target>
        </trans-unit>
        <trans-unit id="3ce91f8ce5685aa3c7ae6bebf7959c99739d2884" translate="yes" xml:space="preserve">
          <source>List of declared variables. Each variable should be an object with string fields &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;name&lt;/code&gt;, and optionally having a &lt;code&gt;default&lt;/code&gt; field as well.</source>
          <target state="translated">선언 된 변수 목록 각 변수는 문자열 필드 &lt;code&gt;type&lt;/code&gt; 과 &lt;code&gt;name&lt;/code&gt; 을 갖는 객체 여야하며 선택적으로 &lt;code&gt;default&lt;/code&gt; 필드도 있습니다.</target>
        </trans-unit>
        <trans-unit id="075dd91e787bf6243a7752780ea0c8bba33ec184" translate="yes" xml:space="preserve">
          <source>List of objects (key/value pairs) to create instances from</source>
          <target state="translated">인스턴스를 생성 할 객체 목록 (키 / 값 쌍)</target>
        </trans-unit>
        <trans-unit id="efd6defff3588a82427cedf6cb66687edafa5f0a" translate="yes" xml:space="preserve">
          <source>List of parameters declared for SQL function</source>
          <target state="translated">SQL 함수에 선언 된 매개 변수 목록</target>
        </trans-unit>
        <trans-unit id="a01e2b9e9c9931427b664651a40032e3447516ac" translate="yes" xml:space="preserve">
          <source>List of records to insert</source>
          <target state="translated">삽입 할 레코드 목록</target>
        </trans-unit>
        <trans-unit id="756dc1b93051a84503f4ee0647cfc663c3af6b9d" translate="yes" xml:space="preserve">
          <source>List of table to skip</source>
          <target state="translated">건너 뛸 테이블 목록</target>
        </trans-unit>
        <trans-unit id="a516eb0d586f3d22305a538c09c709ee6782c824" translate="yes" xml:space="preserve">
          <source>Load further nested related models</source>
          <target state="translated">더 중첩 된 관련 모델로드</target>
        </trans-unit>
        <trans-unit id="59da4a73b5ff707274f5f8bd4f63543247b04f15" translate="yes" xml:space="preserve">
          <source>Lock the selected rows. Possible options are transaction.LOCK.UPDATE and transaction.LOCK.SHARE. Postgres also supports transaction.LOCK.KEY_SHARE, transaction.LOCK.NO_KEY_UPDATE and specific model locks with joins.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c9c5fc6308d5bcf9e048b826209d636266946b5" translate="yes" xml:space="preserve">
          <source>Lock the selected rows. Possible options are transaction.LOCK.UPDATE and transaction.LOCK.SHARE. Postgres also supports transaction.LOCK.KEY_SHARE, transaction.LOCK.NO_KEY_UPDATE and specific model locks with joins. See &lt;a href=&quot;../../transaction#lock&quot;&gt;transaction.LOCK for an example&lt;/a&gt;</source>
          <target state="translated">선택한 행을 잠급니다. 가능한 옵션은 transaction.LOCK.UPDATE 및 transaction.LOCK.SHARE입니다. Postgres는 transaction.LOCK.KEY_SHARE, transaction.LOCK.NO_KEY_UPDATE 및 조인이있는 특정 모델 잠금도 지원합니다. &lt;a href=&quot;../../transaction#lock&quot;&gt;예제는 transaction.LOCK을&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="01175ae5bc13842f1a68f275d49e45971292d2c1" translate="yes" xml:space="preserve">
          <source>Locks</source>
          <target state="translated">Locks</target>
        </trans-unit>
        <trans-unit id="57003616863fe634c645e342ee9080681e419c5f" translate="yes" xml:space="preserve">
          <source>Logging</source>
          <target state="translated">Logging</target>
        </trans-unit>
        <trans-unit id="782833b03e63a64afaf4091b1f757a4976389ff7" translate="yes" xml:space="preserve">
          <source>Logical combinations with operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="381f51fe7d2e48a40efecb0f6ec5b0e10560328f" translate="yes" xml:space="preserve">
          <source>MACADDR</source>
          <target state="translated">MACADDR</target>
        </trans-unit>
        <trans-unit id="fb533649ca2f9e73b11b6bb948adb363f958ac9f" translate="yes" xml:space="preserve">
          <source>MEDIUMINT</source>
          <target state="translated">MEDIUMINT</target>
        </trans-unit>
        <trans-unit id="5e10df029a02645d6284a04ec967bdb813352d80" translate="yes" xml:space="preserve">
          <source>MSSQL</source>
          <target state="translated">MSSQL</target>
        </trans-unit>
        <trans-unit id="9bc51354ceb63788d1d163c25b7f34fd57ef467b" translate="yes" xml:space="preserve">
          <source>MSSQL - Implemented as a single query using &lt;code&gt;MERGE&lt;/code&gt; and &lt;code&gt;WHEN (NOT) MATCHED THEN&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d338a8206f4d51fb083279011e9504adb9b8bc21" translate="yes" xml:space="preserve">
          <source>MSSQL - Implemented as a single query using &lt;code&gt;MERGE&lt;/code&gt; and &lt;code&gt;WHEN (NOT) MATCHED THEN&lt;/code&gt;&lt;strong&gt;Note&lt;/strong&gt; that SQLite returns undefined for created, no matter if the row was created or updated. This is because SQLite always runs INSERT OR IGNORE + UPDATE, in a single query, so there is no way to know whether the row was inserted or not.</source>
          <target state="translated">MSSQL는 - 사용하여 단일 쿼리로 구현 &lt;code&gt;MERGE&lt;/code&gt; 하고 &lt;code&gt;WHEN (NOT) MATCHED THEN&lt;/code&gt; &lt;strong&gt;참고&lt;/strong&gt; 행을 만들거나 업데이트 할 경우 생성에 상관없이 대한 정의되지 않은 그 SQLite는 돌아갑니다. SQLite는 항상 단일 쿼리에서 INSERT OR IGNORE + UPDATE를 실행하기 때문에 행이 삽입되었는지 여부를 알 수있는 방법이 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="956a5f56cb9c9af927343b5e2c11e9cb376ea54d" translate="yes" xml:space="preserve">
          <source>MSSQL - Implemented with MERGE statement</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f72f32142883a0751ac59485e9ed4435c156afa8" translate="yes" xml:space="preserve">
          <source>MSSQL Domain Account</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffc76c03c5b6645c32d955829051a1f79970d940" translate="yes" xml:space="preserve">
          <source>MSSQL does not have a JSON data type, however it does provide some support for JSON stored as strings through certain functions since SQL Server 2016. Using these functions, you will be able to query the JSON stored in the string, but any returned values will need to be parsed seperately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="991df59282ae7659f4a3c3ddbd655d8dab601328" translate="yes" xml:space="preserve">
          <source>MSSQL does not have a JSON data type, however it does provide support for JSON stored as strings through certain functions since SQL Server 2016. Using these functions, you will be able to query the JSON stored in the string, but any returned values will need to be parsed seperately.</source>
          <target state="translated">MSSQL에는 JSON 데이터 형식이 없지만 SQL Server 2016 이후 특정 함수를 통해 문자열로 저장된 JSON을 지원합니다.이 함수를 사용하면 문자열에 저장된 JSON을 쿼리 할 수 ​​있지만 반환 된 값은 모두 필요합니다. 별도로 구문 분석해야합니다.</target>
        </trans-unit>
        <trans-unit id="6703c01658bb865ea0ff8c363ba27924e5404966" translate="yes" xml:space="preserve">
          <source>MSSqlQueryInterface</source>
          <target state="translated">MSSqlQueryInterface</target>
        </trans-unit>
        <trans-unit id="1a90749e4a5e44c43a2bf4e5bc2ac3049b922dc7" translate="yes" xml:space="preserve">
          <source>Make sure you have read the &lt;a href=&quot;assocs&quot;&gt;associations guide&lt;/a&gt; before reading this guide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2b1fa2c3a6d1e1afc6275611ca02b5fdffb139c" translate="yes" xml:space="preserve">
          <source>Managed transaction (auto-callback)</source>
          <target state="translated">관리 트랜잭션 (자동 콜백)</target>
        </trans-unit>
        <trans-unit id="efd23a483237824d33fd7aeb0a683e7d900ced3a" translate="yes" xml:space="preserve">
          <source>Managed transactions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ea330d8bd2304f1ff715165a6ab5db327917663" translate="yes" xml:space="preserve">
          <source>Managed transactions handle committing or rolling back the transaction automatically. You start a managed transaction by passing a callback to &lt;code&gt;sequelize.transaction&lt;/code&gt;.</source>
          <target state="translated">관리 트랜잭션은 트랜잭션 커밋 또는 롤백을 자동으로 처리합니다. &lt;code&gt;sequelize.transaction&lt;/code&gt; 에 콜백을 전달하여 관리 트랜잭션을 시작합니다 .</target>
        </trans-unit>
        <trans-unit id="cf4a88893f31215fb91305e2be0bf2c592abe7d5" translate="yes" xml:space="preserve">
          <source>Managed transactions handle committing or rolling back the transaction automatically. You start a managed transaction by passing a callback to &lt;code&gt;sequelize.transaction&lt;/code&gt;. This callback can be &lt;code&gt;async&lt;/code&gt; (and usually is).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a382444e6e34d9981178bcdc862fa5fcb7b87a2" translate="yes" xml:space="preserve">
          <source>Mandatory versus optional associations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cc59cf8eacc13611e26eb5e7be4726fc40e2011" translate="yes" xml:space="preserve">
          <source>Manipulating the dataset with limit, offset, order and group</source>
          <target state="translated">한계, 오프셋, 순서 및 그룹으로 데이터 세트 조작</target>
        </trans-unit>
        <trans-unit id="4e836fdc2572ab23d5dc8c36bd613ac6b0f82d63" translate="yes" xml:space="preserve">
          <source>Manual</source>
          <target state="translated">Manual</target>
        </trans-unit>
        <trans-unit id="7b28fe193489f8eb6f6c57f32d0833039b082a4e" translate="yes" xml:space="preserve">
          <source>Many model operations in Sequelize allow you to specify a transaction in the options parameter of the method. If a transaction &lt;em&gt;is&lt;/em&gt; specified in the original call, it will be present in the options parameter passed to the hook function. For example, consider the following snippet:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f51460ac150e0ccb3c2cf161d1a8b2874ae7cd94" translate="yes" xml:space="preserve">
          <source>Many-To-Many associations connect one source with multiple targets, while all these targets can in turn be connected to other sources beyond the first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="255edf6f7cad57a7fe58479df122a2f372fd2daa" translate="yes" xml:space="preserve">
          <source>Many-To-Many relationships</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bda986cd10b1abae1d39002fb10d8505215cc8d5" translate="yes" xml:space="preserve">
          <source>Many-to-Many associations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="377bf4b05aa29004e36d9244e2d88732601654cd" translate="yes" xml:space="preserve">
          <source>Many-to-many association with a join table.</source>
          <target state="translated">조인 테이블과 다 대다 연결.</target>
        </trans-unit>
        <trans-unit id="d7204c50e7ff3946b04de7b1b82e6e3402f44d27" translate="yes" xml:space="preserve">
          <source>Many-to-many-to-many relationships and beyond</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2c278e4b750406933592c346d173c2e67747cad" translate="yes" xml:space="preserve">
          <source>Map returned fields to arbitrary names for &lt;code&gt;SELECT&lt;/code&gt; query type.</source>
          <target state="translated">리턴 된 필드를 &lt;code&gt;SELECT&lt;/code&gt; 조회 유형의 임의의 이름으로 맵핑하십시오 .</target>
        </trans-unit>
        <trans-unit id="be596405e95a78e6e3fd716d1f964da33dac24e3" translate="yes" xml:space="preserve">
          <source>Map returned fields to model's fields if &lt;code&gt;options.model&lt;/code&gt; or &lt;code&gt;options.instance&lt;/code&gt; is present. Mapping will occur before building the model instance.</source>
          <target state="translated">&lt;code&gt;options.model&lt;/code&gt; 또는 &lt;code&gt;options.instance&lt;/code&gt; 가있는 경우 반환 된 필드를 모델의 필드에 매핑합니다 . 모델 인스턴스를 작성하기 전에 매핑이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="7f00002bb6ad2eec19a19de8a03c7d6fad15adff" translate="yes" xml:space="preserve">
          <source>MariaDB</source>
          <target state="translated">MariaDB</target>
        </trans-unit>
        <trans-unit id="8f7e6ef50178ceaac3c27a6e48b1989cccb85ff6" translate="yes" xml:space="preserve">
          <source>Mark the include as duplicating, will prevent a subquery from being used.</source>
          <target state="translated">포함을 중복으로 표시하면 하위 쿼리가 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1da7a96c09b4e4634e58cd74016bd7905cd29f3a" translate="yes" xml:space="preserve">
          <source>Match a regex against the database name before syncing, a safety check for cases where force: true is used in tests but not live code</source>
          <target state="translated">동기화하기 전에 데이터베이스 이름과 정규식을 일치 시키십시오 (강제 : true는 테스트에 사용되지만 라이브 코드는 사용되지 않는 경우에 대한 안전 점검).</target>
        </trans-unit>
        <trans-unit id="47f4c6f36bdf82bb2ab12a74bce5359bd3e3baea" translate="yes" xml:space="preserve">
          <source>Maximum number of connection in pool</source>
          <target state="translated">풀의 최대 연결 수</target>
        </trans-unit>
        <trans-unit id="97738b59f60343e4146991bad8d071fcf74e0ab8" translate="yes" xml:space="preserve">
          <source>Member Summary</source>
          <target state="translated">회원 요약</target>
        </trans-unit>
        <trans-unit id="40de0d4de887a374168bf79e72c7aa0fa4594d6e" translate="yes" xml:space="preserve">
          <source>Merging</source>
          <target state="translated">Merging</target>
        </trans-unit>
        <trans-unit id="5646c6f729482a25c89d910db627247645097c06" translate="yes" xml:space="preserve">
          <source>Merging includes</source>
          <target state="translated">병합 포함</target>
        </trans-unit>
        <trans-unit id="8102ea6074090f4681ab70e02ebe6ece740ec91c" translate="yes" xml:space="preserve">
          <source>Method Summary</source>
          <target state="translated">방법 요약</target>
        </trans-unit>
        <trans-unit id="7ee71f3365c47f24bea17f31665feff788530ffb" translate="yes" xml:space="preserve">
          <source>Migration Skeleton</source>
          <target state="translated">마이그레이션 스켈레톤</target>
        </trans-unit>
        <trans-unit id="c32d7ce630147bbc439f44b57c3dd404394c0d9b" translate="yes" xml:space="preserve">
          <source>Migration Storage</source>
          <target state="translated">마이그레이션 스토리지</target>
        </trans-unit>
        <trans-unit id="dca984afd74a0089c1d5a5816e4de2e8d46a60b5" translate="yes" xml:space="preserve">
          <source>Migrations</source>
          <target state="translated">Migrations</target>
        </trans-unit>
        <trans-unit id="fdaa1ef022ef7283a9b451dc1daff1a42f1e129d" translate="yes" xml:space="preserve">
          <source>Minimum number of connection in pool</source>
          <target state="translated">풀의 최소 연결 수</target>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="68c2cc7f0ceaa3e499ecb4db331feb4debbbcc23" translate="yes" xml:space="preserve">
          <source>Model</source>
          <target state="translated">Model</target>
        </trans-unit>
        <trans-unit id="f7df454559e3e51dd82ed08eb44e624585cc847f" translate="yes" xml:space="preserve">
          <source>Model Basics</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ba72d12de465e9cad9bceff0ef74b878438e5dd" translate="yes" xml:space="preserve">
          <source>Model Basics: Data Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c3701236af5fee2b21ede6278c55f7d87ab5faa" translate="yes" xml:space="preserve">
          <source>Model Definition</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfb4a7c9ed8c301f3a5fc24c730323523bf1ad37" translate="yes" xml:space="preserve">
          <source>Model Instances</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3772716291a8cbb522644aacea1786a0d6e479f9" translate="yes" xml:space="preserve">
          <source>Model Querying - Basics</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce9c9978a8a2df228a768a8ded385b6536bc5125" translate="yes" xml:space="preserve">
          <source>Model Querying - Finders</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4142158426158729ca79c5ce805fd286f210430c" translate="yes" xml:space="preserve">
          <source>Model definition</source>
          <target state="translated">모델 정의</target>
        </trans-unit>
        <trans-unit id="d5b42cbdc48b29ec85aa8da6533d3aa5c7e63a91" translate="yes" xml:space="preserve">
          <source>Model hooks</source>
          <target state="translated">모델 고리</target>
        </trans-unit>
        <trans-unit id="0a75c07ee5b0146bfd4157f900acbbac80d86138" translate="yes" xml:space="preserve">
          <source>Model instances operate with the concept of a &lt;code&gt;dataValues&lt;/code&gt; property, which stores the actual values represented by the instance. By default, the values from dataValues can also be accessed directly from the Instance, that is:</source>
          <target state="translated">모델 인스턴스는 인스턴스가 나타내는 실제 값을 저장 하는 &lt;code&gt;dataValues&lt;/code&gt; 속성 의 개념으로 작동 합니다. 기본적으로 dataValues의 값은 인스턴스에서 직접 액세스 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e25e0f1340cca1f16eb599887037699a0de49610" translate="yes" xml:space="preserve">
          <source>Model synchronization</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b86c2670dd4b42d8a914c0eec8b73c34afe4cef4" translate="yes" xml:space="preserve">
          <source>Model to upsert on</source>
          <target state="translated">upsert 할 모델</target>
        </trans-unit>
        <trans-unit id="a07e44c48da57fac1360b4b859e20027ab13a678" translate="yes" xml:space="preserve">
          <source>Model usage</source>
          <target state="translated">모델 사용법</target>
        </trans-unit>
        <trans-unit id="a53b41efe74bb25e6882a6eee3070bdffdb51b7f" translate="yes" xml:space="preserve">
          <source>Model validations allow you to specify format/content/inheritance validations for each attribute of the model.</source>
          <target state="translated">모델 검증을 통해 모델의 각 속성에 대한 형식 / 콘텐츠 / 상속 검증을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21ce518813b59ff7892d35ddffbbfb5e60400474" translate="yes" xml:space="preserve">
          <source>Model validator methods are called with the model object's context and are deemed to fail if they throw an error, otherwise pass. This is just the same as with custom field-specific validators.</source>
          <target state="translated">모델 유효성 검사기 메서드는 모델 개체의 컨텍스트와 함께 호출되며 오류가 발생하면 실패한 것으로 간주하고 그렇지 않으면 전달합니다. 이것은 사용자 정의 필드 별 유효성 검사기와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="02ac210a5e2d429034fe9027e0149e7f0e54c5b1" translate="yes" xml:space="preserve">
          <source>Model validators allow you to specify format/content/inheritance validations for each attribute of the model. Validations are automatically run on &lt;code&gt;create&lt;/code&gt;, &lt;code&gt;update&lt;/code&gt; and &lt;code&gt;save&lt;/code&gt;. You can also call &lt;code&gt;validate()&lt;/code&gt; to manually validate an instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a823acb606efcdb0eb853730193b3ca0d95a9686" translate="yes" xml:space="preserve">
          <source>Model#create for a full explanation of options</source>
          <target state="translated">옵션에 대한 자세한 설명은 Model # create를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8af76ef4fdb319b9698a20f8340797dab906080c" translate="yes" xml:space="preserve">
          <source>Model#get</source>
          <target state="translated">Model#get</target>
        </trans-unit>
        <trans-unit id="3cb30668d05a4e893eb0a96404decd8e56821285" translate="yes" xml:space="preserve">
          <source>Model#reload</source>
          <target state="translated">Model#reload</target>
        </trans-unit>
        <trans-unit id="4f584a3efe16470d969227bf5c8fd863f8da7ead" translate="yes" xml:space="preserve">
          <source>Model#save</source>
          <target state="translated">Model#save</target>
        </trans-unit>
        <trans-unit id="4d5283314738ecf76503ebc98257bde975737cb3" translate="yes" xml:space="preserve">
          <source>Model#set</source>
          <target state="translated">Model#set</target>
        </trans-unit>
        <trans-unit id="7fcf673bb86044c610823a0d2fc30026edfb6398" translate="yes" xml:space="preserve">
          <source>Model#where</source>
          <target state="translated">Model#where</target>
        </trans-unit>
        <trans-unit id="9e763be04a0228a99af47fdea7072bbd2305daba" translate="yes" xml:space="preserve">
          <source>Model-wide validations</source>
          <target state="translated">모델 전체 검증</target>
        </trans-unit>
        <trans-unit id="8253b756d3ad33e6e7017ccdafc1a90fc90f96c7" translate="yes" xml:space="preserve">
          <source>Model.belongsTo</source>
          <target state="translated">Model.belongsTo</target>
        </trans-unit>
        <trans-unit id="454a1355d18fe035a3d709bc71b45145b8aa70a6" translate="yes" xml:space="preserve">
          <source>Model.belongsToMany</source>
          <target state="translated">Model.belongsToMany</target>
        </trans-unit>
        <trans-unit id="338a4bdb9701251c42339f0107d0cab2dfc70bd6" translate="yes" xml:space="preserve">
          <source>Model.build</source>
          <target state="translated">Model.build</target>
        </trans-unit>
        <trans-unit id="e1b94c3211965ce0df3e43428bf03ab75c9411f6" translate="yes" xml:space="preserve">
          <source>Model.findAll</source>
          <target state="translated">Model.findAll</target>
        </trans-unit>
        <trans-unit id="e1b2d659c60c1fcfe515ae54f50c22008b1758d0" translate="yes" xml:space="preserve">
          <source>Model.hasMany</source>
          <target state="translated">Model.hasMany</target>
        </trans-unit>
        <trans-unit id="4c16d25a9fc250497c7ca38d6f46e1f59a466e24" translate="yes" xml:space="preserve">
          <source>Model.hasOne</source>
          <target state="translated">Model.hasOne</target>
        </trans-unit>
        <trans-unit id="fae0e3c371dd4093bef01bf73725ab76001c9cc8" translate="yes" xml:space="preserve">
          <source>Model.increment</source>
          <target state="translated">Model.increment</target>
        </trans-unit>
        <trans-unit id="098dd694d5c2ce27262982062cf5e8f57cabde98" translate="yes" xml:space="preserve">
          <source>Model.save</source>
          <target state="translated">Model.save</target>
        </trans-unit>
        <trans-unit id="fefb16c53c032c568ad0842061992d2b085291e3" translate="yes" xml:space="preserve">
          <source>Model.schema</source>
          <target state="translated">Model.schema</target>
        </trans-unit>
        <trans-unit id="c9a517d625d0bd2320f055ed68c71f3399c8a1e1" translate="yes" xml:space="preserve">
          <source>Modeling a table</source>
          <target state="translated">테이블 모델링</target>
        </trans-unit>
        <trans-unit id="b8ac15e7b4962a2e2baf204f84d2215049c4ac38" translate="yes" xml:space="preserve">
          <source>Models are stored here under the name given to &lt;code&gt;sequelize.define&lt;/code&gt;</source>
          <target state="translated">모델은 &lt;code&gt;sequelize.define&lt;/code&gt; 에 지정된 이름으로 여기에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="c727fdba9c6de6b2fe8de1b8f77c33c570c5c601" translate="yes" xml:space="preserve">
          <source>Models are the essence of Sequelize. A model is an abstraction that represents a table in your database. In Sequelize, it is a class that extends &lt;a href=&quot;../class/lib/model.js~model&quot;&gt;Model&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd2a29e4791870980efc40189fe35f3704588220" translate="yes" xml:space="preserve">
          <source>Models can be defined in two equivalent ways in Sequelize:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="075942798c880b98382f962a35807f50bbbc83f7" translate="yes" xml:space="preserve">
          <source>Models recap (with minor rename)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04fba751c15248f028f90d7497411d6a81a5899c" translate="yes" xml:space="preserve">
          <source>Models should be defined with the singular form of a word. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc9169ab2687ee0ff11fb74d9665fc408f0ddcdc" translate="yes" xml:space="preserve">
          <source>More examples, &lt;a href=&quot;https://sequelize.org/manual/tutorial/models-definition.html&quot;&gt;Model Definition&lt;/a&gt;</source>
          <target state="translated">더 많은 예제, &lt;a href=&quot;https://sequelize.org/manual/tutorial/models-definition.html&quot;&gt;모델 정의&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b7e49c63d7a388fe61b0e185917e856c5555045a" translate="yes" xml:space="preserve">
          <source>More scopes, defined in the same way as defaultScope above. See &lt;code&gt;Model.scope&lt;/code&gt; for more information about how scopes are defined, and what you can do with them</source>
          <target state="translated">위의 defaultScope와 동일한 방식으로 정의 된 추가 범위 범위 정의 방법 및 범위로 수행 할 수있는 작업에 대한 자세한 내용은 &lt;code&gt;Model.scope&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="06e96031e3182ce6001f4ff143c003c41585330f" translate="yes" xml:space="preserve">
          <source>Most likely the type you are trying to implement is already included in &lt;a href=&quot;data-types&quot;&gt;DataTypes&lt;/a&gt;. If a new datatype is not included, this manual will show how to write it yourself.</source>
          <target state="translated">구현하려는 유형이 &lt;a href=&quot;data-types&quot;&gt;DataTypes에&lt;/a&gt; 이미 포함되어있을 가능성이 높습니다 . 새 데이터 유형이 포함되지 않은 경우이 매뉴얼은 직접 작성하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="a2e042750a218382f40539a75f466ae08b86fd02" translate="yes" xml:space="preserve">
          <source>Most of the methods provided by Sequelize are asynchronous and therefore return Promises. They are all &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Promises&lt;/a&gt; , so you can use the Promise API (for example, using &lt;code&gt;then&lt;/code&gt;, &lt;code&gt;catch&lt;/code&gt;, &lt;code&gt;finally&lt;/code&gt;) out of the box.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="230cf74579a3d48af5a5cd7d6655bb5d75b0b4f5" translate="yes" xml:space="preserve">
          <source>Multiple associations involving the same models</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e58a5e3c53097f103b187782be91e04647ca8ad3" translate="yes" xml:space="preserve">
          <source>Multiple checks can be passed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08972958953b98e98cd5adab4847330ad1dd0d5b" translate="yes" xml:space="preserve">
          <source>Multiple eager loading</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="deaa0c393a6613972aaccbf1fecfdad67aa21e88" translate="yes" xml:space="preserve">
          <source>MySQL</source>
          <target state="translated">MySQL</target>
        </trans-unit>
        <trans-unit id="d9d495ec80ad0df93c05d8abe97089135bb60400" translate="yes" xml:space="preserve">
          <source>MySQL - Implemented as a single query &lt;code&gt;INSERT values ON DUPLICATE KEY UPDATE values&lt;/code&gt;</source>
          <target state="translated">MySQL-단일 쿼리로 구현 &lt;code&gt;INSERT values ON DUPLICATE KEY UPDATE values&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6c61b404af35e65eef2408a54386185fe7cd1608" translate="yes" xml:space="preserve">
          <source>MySQL - Implemented with ON DUPLICATE KEY UPDATE</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e54a5ac6d1edc357120fc2fb5937828673dff167" translate="yes" xml:space="preserve">
          <source>MySQL - Implemented with ON DUPLICATE KEY UPDATE`</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dccbb9f724ea55c302c425254e9a27fbcda76836" translate="yes" xml:space="preserve">
          <source>MySQLQueryInterface</source>
          <target state="translated">MySQLQueryInterface</target>
        </trans-unit>
        <trans-unit id="cd408e0f9d0af499eda4bb5b3feec4a587a895de" translate="yes" xml:space="preserve">
          <source>NOEXPAND</source>
          <target state="translated">NOEXPAND</target>
        </trans-unit>
        <trans-unit id="75b8d58ed5ac16a53fb00f7e374f5a6e16d7f254" translate="yes" xml:space="preserve">
          <source>NOLOCK</source>
          <target state="translated">NOLOCK</target>
        </trans-unit>
        <trans-unit id="969e7d8dee132181523a501a068fec75bded3005" translate="yes" xml:space="preserve">
          <source>NOT</source>
          <target state="translated">NOT</target>
        </trans-unit>
        <trans-unit id="9841c4209305816a8e9adbf24362646952f05b27" translate="yes" xml:space="preserve">
          <source>NOW</source>
          <target state="translated">NOW</target>
        </trans-unit>
        <trans-unit id="a2af9a6115134a71b0d62f68e143c19efff1f954" translate="yes" xml:space="preserve">
          <source>NOWAIT</source>
          <target state="translated">NOWAIT</target>
        </trans-unit>
        <trans-unit id="b26f87d0c59f90fdc5143250b4f83e7b4def44dc" translate="yes" xml:space="preserve">
          <source>NO_KEY_UPDATE</source>
          <target state="translated">NO_KEY_UPDATE</target>
        </trans-unit>
        <trans-unit id="6c2496a022b02739f43ed430676315b0c3b34a08" translate="yes" xml:space="preserve">
          <source>NUMBER</source>
          <target state="translated">NUMBER</target>
        </trans-unit>
        <trans-unit id="42ead8566c2a2f546d0123a49496ab3f43750da0" translate="yes" xml:space="preserve">
          <source>NUMBER#constructor</source>
          <target state="translated">NUMBER#constructor</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="ed585ba39b11c2180b849eb53de424e3c71e081f" translate="yes" xml:space="preserve">
          <source>Name of SQL function to create</source>
          <target state="translated">작성할 SQL 함수의 이름</target>
        </trans-unit>
        <trans-unit id="ec874e4030f9772c022ffc4fd75b709664407142" translate="yes" xml:space="preserve">
          <source>Name of SQL function to drop</source>
          <target state="translated">제거 할 SQL 함수의 이름</target>
        </trans-unit>
        <trans-unit id="1dc36a90ec6c0522dcf70c1022a4f52a8ebd611e" translate="yes" xml:space="preserve">
          <source>Name of table to create</source>
          <target state="translated">작성할 테이블 이름</target>
        </trans-unit>
        <trans-unit id="b1fb57d5dc0386d03765076aea0e86c354422228" translate="yes" xml:space="preserve">
          <source>Name of the constraint. If not specified, sequelize automatically creates a named constraint based on constraint type, table &amp;amp; column names</source>
          <target state="translated">구속 조건의 이름. 지정하지 않으면 sequelize는 제약 조건 유형, 테이블 및 열 이름을 기반으로 명명 된 제약 조건을 자동으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="4f9d1ae98e9da4b2bbe6a3af8fc9c757c82ce573" translate="yes" xml:space="preserve">
          <source>Name of the index. Default is &amp;lt;table&amp;gt;&lt;em&gt;&amp;lt;attr1&amp;gt;&lt;/em&gt;&amp;lt;attr2&amp;gt;</source>
          <target state="translated">색인의 이름입니다. 기본값은 &amp;lt;table&amp;gt; &lt;em&gt;&amp;lt;attr1&amp;gt;&lt;/em&gt; &amp;lt;attr2&amp;gt;입니다.</target>
        </trans-unit>
        <trans-unit id="2caed30fdd66bcf9c63c21b3cf8cfd9c614e4500" translate="yes" xml:space="preserve">
          <source>Name of the schema</source>
          <target state="translated">스키마 이름</target>
        </trans-unit>
        <trans-unit id="8f1c7cb06848b338043704b4b8b6b6387090bb38" translate="yes" xml:space="preserve">
          <source>Naming Strategies</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83417c5bdb0fb8b5e66747ac85c9affcdf83a6c6" translate="yes" xml:space="preserve">
          <source>Naming strategy</source>
          <target state="translated">명명 전략</target>
        </trans-unit>
        <trans-unit id="3eb500441a28691dc9112abeaa042dd559561e1e" translate="yes" xml:space="preserve">
          <source>Native upsert is now supported for all dialects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3dc9c09a90c87b9a68571340476b7334d583546" translate="yes" xml:space="preserve">
          <source>Nested eager loading</source>
          <target state="translated">중첩 된 열망 로딩</target>
        </trans-unit>
        <trans-unit id="a04f6031a8e00febd6c589cf09c4d65ef201ad6b" translate="yes" xml:space="preserve">
          <source>Nested key</source>
          <target state="translated">중첩 키</target>
        </trans-unit>
        <trans-unit id="fb2662973950c773f223cbb622d456ea8595339e" translate="yes" xml:space="preserve">
          <source>Nested object</source>
          <target state="translated">중첩 된 객체</target>
        </trans-unit>
        <trans-unit id="03677879a39a6dfcf623a67df9dc3d5704326271" translate="yes" xml:space="preserve">
          <source>New column name</source>
          <target state="translated">새로운 열 이름</target>
        </trans-unit>
        <trans-unit id="b3cb6c83a2b8014301de948d72605c9b1be9e466" translate="yes" xml:space="preserve">
          <source>New databases versus existing databases</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8708814fcaebc0970f0c7c817ceb87f8487aaf17" translate="yes" xml:space="preserve">
          <source>New name from table</source>
          <target state="translated">테이블에서 새로운 이름</target>
        </trans-unit>
        <trans-unit id="6201a9f7432baaca8091c6a78cc0f9fb26eaa3a1" translate="yes" xml:space="preserve">
          <source>New name of function</source>
          <target state="translated">새로운 기능 이름</target>
        </trans-unit>
        <trans-unit id="ed47500954469451016c880a7f5051ccc16a64cf" translate="yes" xml:space="preserve">
          <source>Newly defined model</source>
          <target state="translated">새로 정의 된 모델</target>
        </trans-unit>
        <trans-unit id="fb17233bc810f24085dbf005a9031819e384f852" translate="yes" xml:space="preserve">
          <source>Next thing: Loading of data with many-to-something associations!</source>
          <target state="translated">다음으로 : 다 대다 연관이있는 데이터로드!</target>
        </trans-unit>
        <trans-unit id="e16b1a945e5b22bb16b245f22dd7211090c45d44" translate="yes" xml:space="preserve">
          <source>Normally this is done on process exit, so you only need to call this method if you are creating multiple instances, and want to garbage collect some of them.</source>
          <target state="translated">일반적으로 이는 프로세스 종료시 수행되므로 여러 인스턴스를 작성하고 일부 인스턴스를 가비지 수집하려는 경우에만이 메소드를 호출하면됩니다.</target>
        </trans-unit>
        <trans-unit id="6176bdae0e6a8e545e326df9313cbff2bf37b4e6" translate="yes" xml:space="preserve">
          <source>Note about &lt;code&gt;allowNull&lt;/code&gt; implementation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ba3b3278c1b05092ca1a7d836a057e742820ee9" translate="yes" xml:space="preserve">
          <source>Note also that the &lt;code&gt;where&lt;/code&gt; option used was converted into a condition for the &lt;code&gt;ON&lt;/code&gt; clause of the &lt;code&gt;INNER JOIN&lt;/code&gt;. In order to obtain a &lt;em&gt;top-level&lt;/em&gt;&lt;code&gt;WHERE&lt;/code&gt; clause, instead of an &lt;code&gt;ON&lt;/code&gt; clause, something different must be done. This will be shown next.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fecfeb74461c5b9959a4931d6c5c7f2c22b668b" translate="yes" xml:space="preserve">
          <source>Note for PostgreSQL</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44df5fc237f6e69bd9d791f7eb38e4498268a792" translate="yes" xml:space="preserve">
          <source>Note for production</source>
          <target state="translated">생산 노트</target>
        </trans-unit>
        <trans-unit id="6c85945356462ad75525821c104b7dfcd213da7d" translate="yes" xml:space="preserve">
          <source>Note how &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;age&lt;/code&gt; are overwritten by &lt;code&gt;scope2&lt;/code&gt;, while &lt;code&gt;firstName&lt;/code&gt; is preserved. The &lt;code&gt;limit&lt;/code&gt;, &lt;code&gt;offset&lt;/code&gt;, &lt;code&gt;order&lt;/code&gt;, &lt;code&gt;paranoid&lt;/code&gt;, &lt;code&gt;lock&lt;/code&gt; and &lt;code&gt;raw&lt;/code&gt; fields are overwritten, while &lt;code&gt;where&lt;/code&gt; is shallowly merged (meaning that identical keys will be overwritten). The merge strategy for &lt;code&gt;include&lt;/code&gt; will be discussed later on.</source>
          <target state="translated">참고 방법 &lt;code&gt;limit&lt;/code&gt; 과 &lt;code&gt;age&lt;/code&gt; 을 덮어 씁니다 &lt;code&gt;scope2&lt;/code&gt; 동안, &lt;code&gt;firstName&lt;/code&gt; 을가 보존됩니다. &lt;code&gt;limit&lt;/code&gt; , &lt;code&gt;offset&lt;/code&gt; , &lt;code&gt;order&lt;/code&gt; , &lt;code&gt;paranoid&lt;/code&gt; , &lt;code&gt;lock&lt;/code&gt; 및 &lt;code&gt;raw&lt;/code&gt; 상태 필드는 덮어있는 &lt;code&gt;where&lt;/code&gt; 얕게 병합 (동일한 키 덮어 것을 의미 함). &lt;code&gt;include&lt;/code&gt; 을 위한 병합 전략은 나중에 설명합니다.</target>
        </trans-unit>
        <trans-unit id="ef9ad9b0ed9a592756067e7688004b19c87f4919" translate="yes" xml:space="preserve">
          <source>Note how we also specified &lt;code&gt;constraints: false&lt;/code&gt; for profile picture. This is because we add a foreign key from user to picture (profilePictureId), and from picture to user (userId). If we were to add foreign keys to both, it would create a cyclic dependency, and sequelize would not know which table to create first, since user depends on picture, and picture depends on user. These kinds of problems are detected by sequelize before the models are synced to the database, and you will get an error along the lines of &lt;code&gt;Error: Cyclic dependency found. 'users' is dependent of itself&lt;/code&gt;. If you encounter this, you should either disable some constraints, or rethink your associations completely.</source>
          <target state="translated">우리는 또한 &lt;code&gt;constraints: false&lt;/code&gt; 어떻게 지정했는지 주목하십시오 : 프로필 사진에는 false . 사용자에서 그림 (profilePictureId)으로, 그림에서 사용자 (userId)로 외래 키를 추가하기 때문입니다. 외래 키를 둘 다 추가하면 순환 종속성이 생성되고 시퀀스는 사용자가 그림에 의존하고 그림이 사용자에 의존하므로 먼저 만들 테이블을 알지 못합니다. 이러한 종류의 문제는 모델이 데이터베이스에 동기화되기 전에 sequelize에 의해 감지되며 &lt;code&gt;Error: Cyclic dependency found. 'users' is dependent of itself&lt;/code&gt; 에 오류 가 발생합니다 . '사용자'는 자신에 의존합니다 . 이 문제가 발생하면 일부 제약 조건을 비활성화하거나 연결을 완전히 다시 생각해야합니다.</target>
        </trans-unit>
        <trans-unit id="eb9144a05775de68ebca958a87e5360db80e40b3" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;attributes&lt;/code&gt; keys of multiple applied scopes are merged in such a way that &lt;code&gt;attributes.exclude&lt;/code&gt; are always preserved. This allows merging several scopes and never leaking sensitive fields in final scope.</source>
          <target state="translated">주 &lt;code&gt;attributes&lt;/code&gt; 여러 응용 범위의 키는 것과 같은 방식으로 병합 &lt;code&gt;attributes.exclude&lt;/code&gt; 가 항상 유지됩니다. 이를 통해 여러 범위를 병합하고 최종 범위에서 민감한 필드를 유출하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d47d21ac5fd749e2af2943107836fa234d97ebce" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;t.commit()&lt;/code&gt; and &lt;code&gt;t.rollback()&lt;/code&gt; were not called directly (which is correct).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="874d8ccb75febf029f664e8d9e1c7124e237a8ea" translate="yes" xml:space="preserve">
          <source>Note that every bar instance eager loaded into the &lt;code&gt;&quot;Bars&quot;&lt;/code&gt; property has an extra property called &lt;code&gt;Foo_Bar&lt;/code&gt; which is the relevant Sequelize instance of the junction model. By default, Sequelize fetches all attributes from the junction table in order to build this extra property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85958c9a7874f5c0d22b6bd6bca1113ce4f88dd0" translate="yes" xml:space="preserve">
          <source>Note that if you are using Sequelize migrations you will need to add the &lt;code&gt;createdAt&lt;/code&gt; and &lt;code&gt;updatedAt&lt;/code&gt; fields to your migration definition:</source>
          <target state="translated">Sequelize 마이그레이션을 사용하는 경우 &lt;code&gt;createdAt&lt;/code&gt; 및 &lt;code&gt;updatedAt&lt;/code&gt; 필드를 마이그레이션 정의 에 추가해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1c0231244df97b5648685a9c3faee3f96323348b" translate="yes" xml:space="preserve">
          <source>Note that in both cases the fields are still &lt;a href=&quot;https://en.wikipedia.org/wiki/Camel_case&quot;&gt;camelCase&lt;/a&gt; in the JavaScript side; this option only changes how these fields are mapped to the database itself. The &lt;code&gt;field&lt;/code&gt; option of every attribute is set to their snake_case version, but the attribute itself remains camelCase.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="107947aedcad482a28cbbd5ea34b917a3cb7b194" translate="yes" xml:space="preserve">
          <source>Note that many model operations in Sequelize allow you to specify a transaction in the options parameter of the method. If a transaction _is_ specified in the original call, it will be present in the options parameter passed to the hook function. For example, consider the following snippet:</source>
          <target state="translated">Sequelize의 많은 모델 작업을 통해 메소드의 옵션 매개 변수에 트랜잭션을 지정할 수 있습니다. 원래 호출에 트랜잭션 _is_이 지정된 경우 후크 함수에 전달 된 옵션 매개 변수에 나타납니다. 예를 들어 다음 스 니펫을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="3081268e8123684cad614d83cfab34d39dc4b655" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;getCommentable&lt;/code&gt; implementation above:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4a2d5cf04ad438df329fae57d33930a1cee82dc" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;this.firstname&lt;/code&gt; and &lt;code&gt;this.lastname&lt;/code&gt; references in the &lt;code&gt;fullName&lt;/code&gt; getter function will trigger a call to the respective getter functions. If you do not want that then use the &lt;code&gt;getDataValue()&lt;/code&gt; method to access the raw value (see below).</source>
          <target state="translated">점을 유의 &lt;code&gt;this.firstname&lt;/code&gt; 및 &lt;code&gt;this.lastname&lt;/code&gt; 언급 &lt;code&gt;fullName&lt;/code&gt; 의 용 게터 기능은 각 게터 함수 호출을 트리거링한다. 원하지 않으면 &lt;code&gt;getDataValue()&lt;/code&gt; 메소드를 사용하여 원시 값에 액세스하십시오 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="c3f41755f136f1dc7c83971f78c9422549830be4" translate="yes" xml:space="preserve">
          <source>Note that the Image -&amp;gt; Comment and Post -&amp;gt; Comment relations define a scope, &lt;code&gt;commentable: 'image'&lt;/code&gt; and &lt;code&gt;commentable: 'post'&lt;/code&gt; respectively. This scope is automatically applied when using the association functions:</source>
          <target state="translated">Image-&amp;gt; Comment 및 Post-&amp;gt; Comment 관계는 각각 &lt;code&gt;commentable: 'image'&lt;/code&gt; 및 &lt;code&gt;commentable: 'post'&lt;/code&gt; 범위를 정의합니다 . 이 범위는 연관 기능을 사용할 때 자동으로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="5fa8504da9276f3d3bcfdfe8be4573399ed5ec4b" translate="yes" xml:space="preserve">
          <source>Note that the SQL query generated above will only fetch users that have at least one tool that matches the condition (of not being &lt;code&gt;small&lt;/code&gt;, in this case). This is the case because, when the &lt;code&gt;where&lt;/code&gt; option is used inside an &lt;code&gt;include&lt;/code&gt;, Sequelize automatically sets the &lt;code&gt;required&lt;/code&gt; option to &lt;code&gt;true&lt;/code&gt;. This means that, instead of an &lt;code&gt;OUTER JOIN&lt;/code&gt;, an &lt;code&gt;INNER JOIN&lt;/code&gt; is done, returning only the parent models with at least one matching children.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="535e728e1c2dd454b34cd31f6c84badc151925a7" translate="yes" xml:space="preserve">
          <source>Note that the Sequelize CLI assumes mysql by default. If you're using another dialect, you need to change the content of the &lt;code&gt;&quot;dialect&quot;&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8525f9489e11bab3b2f21ec11ea967e62892eeb7" translate="yes" xml:space="preserve">
          <source>Note that the above implementation of &lt;code&gt;getTaggables()&lt;/code&gt; allows you to pass an options object to &lt;code&gt;getCommentable(options)&lt;/code&gt;, just like any other standard Sequelize method. This is useful to specify where-conditions or includes, for example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce2721ae384c4dceeeec191b133512aaadb5dcf1" translate="yes" xml:space="preserve">
          <source>Note that the above is not the same as the &lt;em&gt;Default Hooks&lt;/em&gt; mentioned above. That one uses the &lt;code&gt;define&lt;/code&gt; option of the constructor. This one does not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dce9db0adb67b0d47212445f99eda65e1d938661" translate="yes" xml:space="preserve">
          <source>Note that where multiple arguments need to be passed to the built-in validation functions, the arguments to be passed must be in an array. But if a single array argument is to be passed, for instance an array of acceptable strings for &lt;code&gt;isIn&lt;/code&gt;, this will be interpreted as multiple string arguments instead of one array argument. To work around this pass a single-length array of arguments, such as &lt;code&gt;[['foo', 'bar']]&lt;/code&gt; as shown above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f0b731694e383aebdfdb192c03dcf6b1ffbcb0d" translate="yes" xml:space="preserve">
          <source>Note that where multiple arguments need to be passed to the built-in validation functions, the arguments to be passed must be in an array. But if a single array argument is to be passed, for instance an array of acceptable strings for &lt;code&gt;isIn&lt;/code&gt;, this will be interpreted as multiple string arguments instead of one array argument. To work around this pass a single-length array of arguments, such as &lt;code&gt;[['one', 'two']]&lt;/code&gt; as shown above.</source>
          <target state="translated">내장 된 유효성 검사 함수에 여러 인수를 전달해야하는 경우 전달할 인수는 배열에 있어야합니다. 그러나 단일 배열 인수 (예 : &lt;code&gt;isIn&lt;/code&gt; 에 허용되는 문자열 배열)가 전달되는 경우 하나의 배열 인수 대신 여러 문자열 인수로 해석됩니다. 이 문제를 해결하려면 위에 표시된 대로 &lt;code&gt;[['one', 'two']]&lt;/code&gt; 와 같은 단일 길이의 인수 배열을 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="535353d3fd19c1e937c57060bfd7578171ca07de" translate="yes" xml:space="preserve">
          <source>Note that, although &lt;code&gt;SUPERUSER123&lt;/code&gt; was logged above, the value truly stored in the database is still &lt;code&gt;SuperUser123&lt;/code&gt;. We used &lt;code&gt;this.getDataValue(username)&lt;/code&gt; to obtain this value, and converted it to uppercase.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbc26e1ce9a0cfc781a57cf82ff121257ce181f3" translate="yes" xml:space="preserve">
          <source>Note that, in the code above:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="285f98e8d01e4962eff6724b78a3c6724d0931e6" translate="yes" xml:space="preserve">
          <source>Note that:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1185b9e23d98645e5a1756245cb517d46b4d7b2" translate="yes" xml:space="preserve">
          <source>Note the usage of the &lt;a href=&quot;../class/lib/sequelize.js~sequelize#static-method-fn&quot;&gt;&lt;code&gt;sequelize.fn&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../class/lib/sequelize.js~sequelize#static-method-col&quot;&gt;&lt;code&gt;sequelize.col&lt;/code&gt;&lt;/a&gt; methods, which should be used to specify an SQL function call and a table column, respectively. These methods should be used instead of passing a plain string (such as &lt;code&gt;char_length(content)&lt;/code&gt;) because Sequelize needs to treat this situation differently (for example, using other symbol escaping approaches).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7dd5727b419c54ae3dce641926eb1877ae85ef1" translate="yes" xml:space="preserve">
          <source>Note, from the usage of &lt;code&gt;await&lt;/code&gt; in the snippet above, that &lt;code&gt;save&lt;/code&gt; is an asynchronous method. In fact, almost every Sequelize method is asynchronous; &lt;code&gt;build&lt;/code&gt; is one of the very few exceptions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e2083a1e3128e3d36db892d90a3e9c51498a3db" translate="yes" xml:space="preserve">
          <source>Note: Method names</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acc671783544f4659031c39424988278f5682f5d" translate="yes" xml:space="preserve">
          <source>Note: connection pool (production)</source>
          <target state="translated">참고 : 연결 풀 (프로덕션)</target>
        </trans-unit>
        <trans-unit id="8e931cb200d41187609864e64685fc58a6af9a21" translate="yes" xml:space="preserve">
          <source>Note: here, our user model is called &lt;code&gt;user&lt;/code&gt;, with a lowercase &lt;code&gt;u&lt;/code&gt; - This means that the property in the object should also be &lt;code&gt;user&lt;/code&gt;. If the name given to &lt;code&gt;sequelize.define&lt;/code&gt; was &lt;code&gt;User&lt;/code&gt;, the key in the object should also be &lt;code&gt;User&lt;/code&gt;. Likewise for &lt;code&gt;addresses&lt;/code&gt;, except it's pluralized being a &lt;code&gt;hasMany&lt;/code&gt; association.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5fd63a016b678ef7095e9bf7d16779f02fbf986" translate="yes" xml:space="preserve">
          <source>Note: logging instances</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fcf216a4ed0c8139179e6a973305b6ff1175347" translate="yes" xml:space="preserve">
          <source>Note: methods like &lt;code&gt;bulkCreate&lt;/code&gt; do not emit individual hooks by default - only the bulk hooks. However, if you want individual hooks to be emitted as well, you can pass the &lt;code&gt;{ individualHooks: true }&lt;/code&gt; option to the query call. However, this can drastically impact performance, depending on the number of records involved (since, among other things, all instances will be loaded into memory). Examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b97eebd9a45f672b355a29fd52d6abdf68ff7637" translate="yes" xml:space="preserve">
          <source>Note: recall that using &lt;code&gt;as&lt;/code&gt; to change the name of the association will also change the name of the foreign key. Therefore it is recommended to also specify the foreign key(s) involved directly in this case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f17a025ad4dbded90c801ce4da0060642aed6add" translate="yes" xml:space="preserve">
          <source>Note: setting up SQLite</source>
          <target state="translated">참고 : SQLite 설정</target>
        </trans-unit>
        <trans-unit id="40e25156182cc9a047ea365913ca1b7c1bf7c6e2" translate="yes" xml:space="preserve">
          <source>Note: the &lt;code&gt;getShip()&lt;/code&gt; instance method used above is one of the methods Sequelize automatically adds to &lt;code&gt;Captain&lt;/code&gt; instances. There are others. You will learn more about them later in this guide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd919816b3443abb41321a6896d4c72ccca66a20" translate="yes" xml:space="preserve">
          <source>Note: there is also a &lt;em&gt;Super Many-To-Many&lt;/em&gt; relationship, which uses six associations at once, and will be discussed in the &lt;a href=&quot;advanced-many-to-many&quot;&gt;Advanced Many-to-Many relationships guide&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="598ee651f3662bc62e474c319bd8bfacefa4b7fa" translate="yes" xml:space="preserve">
          <source>Notice how in the two examples above, the string provided is inserted verbatim into the query, i.e. column names are not escaped. When you provide a string to order/group, this will always be the case. If you want to escape column names, you should provide an array of arguments, even though you only want to order/group by a single column</source>
          <target state="translated">위의 두 예제에서 제공된 문자열이 쿼리에 그대로 삽입되는 방식을 확인하십시오. 즉, 열 이름이 이스케이프되지 않습니다. 주문 / 그룹에 문자열을 제공 할 때 항상 그렇습니다. 열 이름을 이스케이프하려는 경우 단일 열로만 주문 / 그룹화하려는 경우에도 인수 배열을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="ea75bd7ff48126d9026a71c0c8a132e1bf24ae80" translate="yes" xml:space="preserve">
          <source>Notice how the callback passed to &lt;code&gt;transaction&lt;/code&gt; returns a promise chain, and does not explicitly call &lt;code&gt;t.commit()&lt;/code&gt; nor &lt;code&gt;t.rollback()&lt;/code&gt;. If all promises in the returned chain are resolved successfully the transaction is committed. If one or several of the promises are rejected, the transaction is rolled back.</source>
          <target state="translated">&lt;code&gt;transaction&lt;/code&gt; 전달 된 콜백이 어떻게 약속 체인을 반환하고 &lt;code&gt;t.commit()&lt;/code&gt; 또는 &lt;code&gt;t.rollback()&lt;/code&gt; 명시 적으로 호출 하지 않는지 확인하십시오 . 리턴 된 체인의 모든 약속이 성공적으로 해결되면 트랜잭션이 커미트됩니다. 하나 이상의 약속이 거부되면 트랜잭션이 롤백됩니다.</target>
        </trans-unit>
        <trans-unit id="d7340a668b3a9cce1425f7bbe04ef3dad22c994b" translate="yes" xml:space="preserve">
          <source>Notice how the user's &lt;code&gt;Tool&lt;/code&gt;s are aliased as &lt;code&gt;Instruments&lt;/code&gt; above. In order to get that right you have to specify the model you want to load, as well as the alias:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11f0b22a1229e459ff86618d87a61e6308c98004" translate="yes" xml:space="preserve">
          <source>Notice that the accessor (the &lt;code&gt;Tasks&lt;/code&gt; property in the resulting instance) is plural because the association is many-to-something.</source>
          <target state="translated">연결은 다 대다이기 때문에 접근 자 ( 결과 인스턴스 의 &lt;code&gt;Tasks&lt;/code&gt; 속성)는 복수형입니다.</target>
        </trans-unit>
        <trans-unit id="db89be52a41833866fcb78f0286f7fdf07513336" translate="yes" xml:space="preserve">
          <source>Notice that the accessor (the &lt;code&gt;User&lt;/code&gt; property in the resulting instance) is singular because the association is one-to-something.</source>
          <target state="translated">연결이 일대일이기 때문에 접근 자 ( 결과 인스턴스 의 &lt;code&gt;User&lt;/code&gt; 속성)는 특이합니다.</target>
        </trans-unit>
        <trans-unit id="035e80869f3e64a2811a9a26ef2461fad11e2c9a" translate="yes" xml:space="preserve">
          <source>Notice that the accessor (the &lt;code&gt;tasks&lt;/code&gt; property in the resulting instance) is pluralized since the association is one-to-many.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c9516d33ec61798915ba72e3e7b6dc102e33d33" translate="yes" xml:space="preserve">
          <source>Notice that the outer object is an &lt;code&gt;User&lt;/code&gt;, which has a field called &lt;code&gt;profiles&lt;/code&gt;, which is a &lt;code&gt;Profile&lt;/code&gt; array, such that each &lt;code&gt;Profile&lt;/code&gt; comes with an extra field called &lt;code&gt;grant&lt;/code&gt; which is a &lt;code&gt;Grant&lt;/code&gt; instance. This is the default structure created by Sequelize when eager loading from a Many-to-Many relationship.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4848a0b9c04bb727fb8adec90477785147fef5df" translate="yes" xml:space="preserve">
          <source>Notice that the scoped column (&lt;code&gt;taggable&lt;/code&gt;) is now on the through model (&lt;code&gt;ItemTag&lt;/code&gt;).</source>
          <target state="translated">범위가 지정된 열 ( &lt;code&gt;taggable&lt;/code&gt; )이 이제 관통 모델 ( &lt;code&gt;ItemTag&lt;/code&gt; )에 있습니다.</target>
        </trans-unit>
        <trans-unit id="0cf25bfe98d9e52a1f895ec51fb4362193792880" translate="yes" xml:space="preserve">
          <source>Notice, that the &lt;code&gt;useCLS()&lt;/code&gt; method is on the &lt;em&gt;constructor&lt;/em&gt;, not on an instance of sequelize. This means that all instances will share the same namespace, and that CLS is all-or-nothing - you cannot enable it only for some instances.</source>
          <target state="translated">공지의 것을 &lt;code&gt;useCLS()&lt;/code&gt; 메소드는에 &lt;em&gt;생성자&lt;/em&gt; 하지 sequelize의 인스턴스. 이는 모든 인스턴스가 동일한 네임 스페이스를 공유하고 CLS가 전부 또는 아무것도 없음을 의미하므로 일부 인스턴스에 대해서만 활성화 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e2ed15a30fc301b436665dd5c0c8498b757d5988" translate="yes" xml:space="preserve">
          <source>Now CLI will be able to run ES6/ES7 code from migrations/seeders etc. Please keep in mind this depends upon your configuration of &lt;code&gt;.babelrc&lt;/code&gt;. Please read more about that at &lt;a href=&quot;https://babeljs.io&quot;&gt;babeljs.io&lt;/a&gt;.</source>
          <target state="translated">이제 CLI는 마이그레이션 / 시더 등에서 ES6 / ES7 코드를 실행할 수 있습니다 . 이는 &lt;code&gt;.babelrc&lt;/code&gt; 구성에 따라 다릅니다 . &lt;a href=&quot;https://babeljs.io&quot;&gt;babeljs.io&lt;/a&gt; 에서 자세한 내용을 읽으 십시오 .</target>
        </trans-unit>
        <trans-unit id="0dda3fffe72b1e2fffc081cac72bf40762b93a93" translate="yes" xml:space="preserve">
          <source>Now Sequelize CLI will load &lt;code&gt;config/config.js&lt;/code&gt; for getting configuration options. Since this is a JS file you can have any code executed and export final dynamic configuration file.</source>
          <target state="translated">이제 Sequelize CLI는 구성 옵션을 얻기 위해 &lt;code&gt;config/config.js&lt;/code&gt; 를 로드 합니다. 이 파일은 JS 파일이므로 모든 코드를 실행하고 최종 동적 구성 파일을 내보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6530493050c981b03dea9cac83caf8e5e3c0eff" translate="yes" xml:space="preserve">
          <source>Now edit this file and set correct database credentials and dialect. The keys of the objects (e.g. &quot;development&quot;) are used on &lt;code&gt;model/index.js&lt;/code&gt; for matching &lt;code&gt;process.env.NODE_ENV&lt;/code&gt; (When undefined, &quot;development&quot; is a default value).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95b3edba890e41548c10bf9b3b3625f9aa2f773c" translate="yes" xml:space="preserve">
          <source>Now edit this file and set correct database credentials and dialect. The keys of the objects(ex. &quot;development&quot;) are used on &lt;code&gt;model/index.js&lt;/code&gt; for matching &lt;code&gt;process.env.NODE_ENV&lt;/code&gt; (When undefined, &quot;development&quot; is a default value.).</source>
          <target state="translated">이제이 파일을 편집하고 올바른 데이터베이스 신임 정보 및 방언을 설정하십시오. 객체의 키 (예 : &quot;development&quot;)는 &lt;code&gt;model/index.js&lt;/code&gt; 에서 &lt;code&gt;process.env.NODE_ENV&lt;/code&gt; 와 일치시키기 위해 사용됩니다 (정의되지 않은 경우 &quot;development&quot;가 기본값 임).</target>
        </trans-unit>
        <trans-unit id="8bcf1d33260995a6c3b8643c00cc70d1a34e6ef9" translate="yes" xml:space="preserve">
          <source>Now include &lt;code&gt;babel-register&lt;/code&gt; setup in this file</source>
          <target state="translated">이제이 파일에 &lt;code&gt;babel-register&lt;/code&gt; 설정을 포함 시키십시오</target>
        </trans-unit>
        <trans-unit id="464a349af324240ebd3cbae6fce3308732c7d91a" translate="yes" xml:space="preserve">
          <source>Now let's create &lt;code&gt;.sequelizerc&lt;/code&gt; file, it can include any configuration you may want to change for &lt;code&gt;sequelize-cli&lt;/code&gt; but in addition to that we want it to register babel for our codebase. Something like this</source>
          <target state="translated">이제 &lt;code&gt;.sequelizerc&lt;/code&gt; 파일을 만들어 봅시다. &lt;code&gt;sequelize-cli&lt;/code&gt; 를 위해 변경하고 싶을 뿐 아니라 코드베이스에 babel을 등록하기를 원하는 구성을 포함 할 수 있습니다 . 이 같은</target>
        </trans-unit>
        <trans-unit id="20a6638a8729006ac3616971ef324f0cd3930e50" translate="yes" xml:space="preserve">
          <source>Now let's work with an example config.</source>
          <target state="translated">이제 구성 예를 사용해 봅시다.</target>
        </trans-unit>
        <trans-unit id="aff9acc4bc5c9d94727af20f35602137e8690ce9" translate="yes" xml:space="preserve">
          <source>Now lets change some values and save changes to the database... There are two ways to do that:</source>
          <target state="translated">이제 일부 값을 변경하고 데이터베이스에 변경 사항을 저장하겠습니다. 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4fb15abf10ea3e08624eaff19cd79bb8fba56a4" translate="yes" xml:space="preserve">
          <source>Now our table has been created and saved in database. With migration you can revert to old state by just running a command.</source>
          <target state="translated">이제 테이블이 생성되어 데이터베이스에 저장되었습니다. 마이그레이션을 사용하면 명령을 실행하여 이전 상태로 되돌릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7eefdac723f9c9e20d7294a50068553ae5ca48a" translate="yes" xml:space="preserve">
          <source>Now the Sequelize CLI will load &lt;code&gt;config/config.js&lt;/code&gt; for getting configuration options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="548b3c2a852af460195d73e56956f24676cc3d49" translate="yes" xml:space="preserve">
          <source>Now we can create a product with multiple tags in the following way:</source>
          <target state="translated">이제 다음과 같은 방법으로 여러 태그가있는 제품을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4cffce358a348e77c487f8192d4f0ed8395d638b" translate="yes" xml:space="preserve">
          <source>Now we can do things like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f114dbd008171ea170c4bc3c4396af90c7dda1af" translate="yes" xml:space="preserve">
          <source>Now we should edit this file to insert demo user to &lt;code&gt;User&lt;/code&gt; table.</source>
          <target state="translated">이제이 파일을 편집하여 데모 사용자를 &lt;code&gt;User&lt;/code&gt; 테이블 에 삽입해야 합니다.</target>
        </trans-unit>
        <trans-unit id="bd5005f9263eecf47904d16fa5a892e1856e0801" translate="yes" xml:space="preserve">
          <source>Now we will compare the usage of the last Many-to-Many setup shown above with the usual One-to-Many relationships, so that in the end we conclude with the concept of a &lt;em&gt;&quot;Super Many-to-Many relationship&quot;&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fbb7a53e1f2decb02a350e377272f4a1343c317" translate="yes" xml:space="preserve">
          <source>Now you know how to use &lt;code&gt;.sequelizerc&lt;/code&gt; file. Now let's see how to use this file to use babel with &lt;code&gt;sequelize-cli&lt;/code&gt; setup. This will allow you to write migrations and seeders with ES6/ES7 syntax.</source>
          <target state="translated">이제 &lt;code&gt;.sequelizerc&lt;/code&gt; 파일 사용법을 알았습니다 . 이제이 파일을 사용하여 &lt;code&gt;sequelize-cli&lt;/code&gt; 설정 과 함께 babel을 사용하는 방법을 살펴 보겠습니다 . 이를 통해 ES6 / ES7 구문으로 마이그레이션 및 시드를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa5d7518e3108590d0f1160b265811a870cd538d" translate="yes" xml:space="preserve">
          <source>Now, consider the following four scopes defined on Foo:</source>
          <target state="translated">이제 Foo에 정의 된 다음 네 가지 범위를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="ea3db3e6a1f93a9eda45521737a3cb987f7c434a" translate="yes" xml:space="preserve">
          <source>Now, instead of loading the user that is associated to a given task, we will do the opposite - we will find all tasks associated to a given user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d402f00865adc64ffa0390f1f24af9cf67021987" translate="yes" xml:space="preserve">
          <source>Now, the question is: how to associate them?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3442c2dc57f57bad3870f40d6b154c87dd38302" translate="yes" xml:space="preserve">
          <source>Now, to consider a Many-to-Many polymorphic association, instead of considering comments, we will consider tags. For convenience, instead of calling Image and Video as &lt;em&gt;commentables&lt;/em&gt;, we will now call them &lt;em&gt;taggables&lt;/em&gt;. One &lt;em&gt;taggable&lt;/em&gt; may have several tags, and at the same time one tag can be placed in several &lt;em&gt;taggables&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81b312582560da24be75f76327d01f3d150384b4" translate="yes" xml:space="preserve">
          <source>Now, we are ready for examples of the power of subqueries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4323615f9d1080eaa42714c1a47e9171d6778c7d" translate="yes" xml:space="preserve">
          <source>Now, we want to perform a polymorphic eager loading of the associated commentables for one (or more) comments. We want to achieve something similar to the following idea:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e53821f70ae16079c4a6a64c52a91fae645bc5f" translate="yes" xml:space="preserve">
          <source>Numbers</source>
          <target state="translated">Numbers</target>
        </trans-unit>
        <trans-unit id="5582432c4864632f5e1a23cfc9dcba9e1ce92437" translate="yes" xml:space="preserve">
          <source>OK. So, first of all, let's load all tasks with their associated user.</source>
          <target state="translated">확인. 우선, 모든 작업을 관련 사용자와 함께로드하십시오.</target>
        </trans-unit>
        <trans-unit id="6fb9784f607ff093cd1715b61adeec04b842c2a2" translate="yes" xml:space="preserve">
          <source>OK. So, first of all, let's load all tasks with their associated user:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2883f191bc5ebfdc16c0813eff659b35363ea69b" translate="yes" xml:space="preserve">
          <source>Object</source>
          <target state="translated">Object</target>
        </trans-unit>
        <trans-unit id="524631efa40fbbd074c7d379858504a629448858" translate="yes" xml:space="preserve">
          <source>Object -</source>
          <target state="translated">객체-</target>
        </trans-unit>
        <trans-unit id="7798f73e59ce895af4d9b669167864b8821ca276" translate="yes" xml:space="preserve">
          <source>Object representing a list of table attributes to create</source>
          <target state="translated">작성할 테이블 속성 목록을 나타내는 오브젝트</target>
        </trans-unit>
        <trans-unit id="a7b5e01cccb77400ad2465a66ef4eff96ddff3da" translate="yes" xml:space="preserve">
          <source>Object specifying target table, column name to create foreign key constraint</source>
          <target state="translated">외래 키 제약 조건을 만들기위한 대상 테이블, 열 이름을 지정하는 개체</target>
        </trans-unit>
        <trans-unit id="c785ae6c15b6aed10bfae737959e2db229782bf3" translate="yes" xml:space="preserve">
          <source>Object with multiple variables.</source>
          <target state="translated">여러 변수가있는 객체.</target>
        </trans-unit>
        <trans-unit id="e3816c117ac9693a36bb6ad26b815f39c6a83f3f" translate="yes" xml:space="preserve">
          <source>Observe how the four scopes were merged into one. The includes of scopes are merged based on the model being included. If one scope includes model A and another includes model B, the merged result will include both models A and B. On the other hand, if both scopes include the same model A, but with different options (such as nested includes or other attributes), those will be merged recursively, as shown above.</source>
          <target state="translated">네 가지 스코프가 어떻게 하나로 통합되었는지 관찰하십시오. 범위 포함은 포함되는 모델을 기반으로 병합됩니다. 한 범위에 모델 A가 포함되고 다른 하나에 모델 B가 포함 된 경우 병합 된 결과에는 모델 A와 B가 모두 포함됩니다. 반면, 두 범위에 모두 동일한 모델 A가 포함되지만 옵션이 다른 경우 (중첩 포함 또는 기타 속성) 위와 같이 재귀 적으로 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="934291dd3a055f8d1ebe6a487355ae31c74c8183" translate="yes" xml:space="preserve">
          <source>Observe that Sequelize called the setter automatically, before even sending data to the database. The only data the database ever saw was the already hashed value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="866d795c3e03ac5251b1b9486ccf5594e65835e3" translate="yes" xml:space="preserve">
          <source>Observe that in the example above, we made two queries, only fetching the associated ship when we wanted to use it. This can be especially useful if we may or may not need the ship, perhaps we want to fetch it conditionally, only in a few cases; this way we can save time and memory by only fetching it when necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="355ddd1052f0bbd27e35379c1f9623b46a9df1d9" translate="yes" xml:space="preserve">
          <source>Observe that no operator (from &lt;code&gt;Op&lt;/code&gt;) was explicitly passed, so Sequelize assumed an equality comparison by default. The above code is equivalent to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="607110e8378fd9796e0eb0265780d5188c232e9b" translate="yes" xml:space="preserve">
          <source>Observe that, in both methods above, the table name (&lt;code&gt;Users&lt;/code&gt;) was never explicitly defined. However, the model name was given (&lt;code&gt;User&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5069c0079b2ccec2d921137a8097a76ee6f64f7e" translate="yes" xml:space="preserve">
          <source>Observe that, in the examples above, &lt;code&gt;Sequelize&lt;/code&gt; refers to the library itself while &lt;code&gt;sequelize&lt;/code&gt; refers to an instance of Sequelize, which represents a connection to one database. This is the recommended convention and it will be followed throughout the documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="796dec4a3b7bd0c60bf9804117e49636789a834e" translate="yes" xml:space="preserve">
          <source>Observe the usage of the &lt;code&gt;include&lt;/code&gt; option in the &lt;code&gt;Product.create&lt;/code&gt; call. That is necessary for Sequelize to understand what you are trying to create along with the association.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d9e1c6d254743bd56f18ff13338f3640b6cd888" translate="yes" xml:space="preserve">
          <source>Obtaining the query interface</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ec9751cae190e1dbc9d9b803b5cc2115aae8a88" translate="yes" xml:space="preserve">
          <source>Of course you can also access the instance's data and generate virtual getters:</source>
          <target state="translated">물론 인스턴스 데이터에 액세스하여 가상 게터를 생성 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef0e1f62d7337f2b1182d77e752df8ade90bdfe4" translate="yes" xml:space="preserve">
          <source>Of course you can also define self references with belongsToMany:</source>
          <target state="translated">물론 belongsToMany로 자기 참조를 정의 할 수도 있습니다 :</target>
        </trans-unit>
        <trans-unit id="c3d7707984f636d4a319d5e24e37abbc8d39c65c" translate="yes" xml:space="preserve">
          <source>Of course, the outcome will depend upon your babel configuration (such as in a &lt;code&gt;.babelrc&lt;/code&gt; file). Learn more at &lt;a href=&quot;https://babeljs.io&quot;&gt;babeljs.io&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4677ce1c5e0c4dec82432cd03eb9e4977e1e301" translate="yes" xml:space="preserve">
          <source>Of course, this behavior is easily configurable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6996a110d4fbad998db495e1d5480c250fa89d29" translate="yes" xml:space="preserve">
          <source>Of course, using &lt;code&gt;async&lt;/code&gt; and &lt;code&gt;await&lt;/code&gt; works normally as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb5654b91a94e76ab0d91f9617ed39a9eb1b3449" translate="yes" xml:space="preserve">
          <source>Offset for result</source>
          <target state="translated">결과에 대한 오프셋</target>
        </trans-unit>
        <trans-unit id="6a8127eb43bf543e2cf1dbb0892cd7b8b334689a" translate="yes" xml:space="preserve">
          <source>On success, the callback will be called with this instance. On validation error, the callback will be called with an instance of &lt;code&gt;Sequelize.ValidationError&lt;/code&gt;. This error will have a property for each of the fields for which validation failed, with the error message for that field.</source>
          <target state="translated">성공하면이 인스턴스로 콜백이 호출됩니다. 유효성 검사 오류가 발생하면 &lt;code&gt;Sequelize.ValidationError&lt;/code&gt; 인스턴스로 콜백이 호출됩니다 . 이 오류에는 해당 필드에 대한 오류 메시지와 함께 유효성 검사에 실패한 각 필드에 대한 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1351ee779095a3ab702837d5f4875be94e30e8c5" translate="yes" xml:space="preserve">
          <source>On the other hand, constraints are rules defined at SQL level. The most basic example of constraint is an Unique Constraint. If a constraint check fails, an error will be thrown by the database and Sequelize will forward this error to JavaScript (in this example, throwing a &lt;code&gt;SequelizeUniqueConstraintError&lt;/code&gt;). Note that in this case, the SQL query was performed, unlike the case for validations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6e8712ec2c54c580ef45527e2407d442845c74b" translate="yes" xml:space="preserve">
          <source>On the other hand, if it is set to allow null (with &lt;code&gt;allowNull: true&lt;/code&gt;) and that value has been set to &lt;code&gt;null&lt;/code&gt;, only the built-in validators will be skipped, while the custom validators will still run.</source>
          <target state="translated">반면, null 허용 ( &lt;code&gt;allowNull: true&lt;/code&gt; )으로 설정되고 해당 값이 &lt;code&gt;null&lt;/code&gt; 로 설정된 경우 내장 유효성 검증기만 건너 뛰고 사용자 정의 유효성 검증기는 계속 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="07f665a8c99eed865083f085d98ec8fca0015d7c" translate="yes" xml:space="preserve">
          <source>Once you created an object and got a reference to it, you can delete it from the database. The relevant method is &lt;code&gt;destroy&lt;/code&gt;:</source>
          <target state="translated">객체를 생성하고 이에 대한 참조를 얻으면 데이터베이스에서 객체를 삭제할 수 있습니다. 관련 방법은 &lt;code&gt;destroy&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1f9b5321949a967ef42f55010f8e75dec29c3613" translate="yes" xml:space="preserve">
          <source>Once you have properly configured CLI config file you are ready to create your first migration. It's as simple as executing a simple command.</source>
          <target state="translated">CLI 구성 파일을 올바르게 구성했으면 첫 번째 마이그레이션을 작성할 준비가되었습니다. 간단한 명령을 실행하는 것만 큼 간단합니다.</target>
        </trans-unit>
        <trans-unit id="e69d5be30175ff220d73f4f3f130507d5b0acad9" translate="yes" xml:space="preserve">
          <source>One game has many teams associated to it (the ones that are playing that game);</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5de0806a95c7c387a573daff3380d96ce666e45" translate="yes" xml:space="preserve">
          <source>One team may have participated in many games.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a99024618c2527f3bc655af2bf9a61a350050032" translate="yes" xml:space="preserve">
          <source>One-To-Many associations (hasMany)</source>
          <target state="translated">일대 다 협회 (hasMany)</target>
        </trans-unit>
        <trans-unit id="80b8e313d7e20adeab654b03732c8d3a72861cc7" translate="yes" xml:space="preserve">
          <source>One-To-Many associations are connecting one source with multiple targets, while all these targets are connected only with this single source.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b04078f82acb5642e470ea54f09be546dc7432a7" translate="yes" xml:space="preserve">
          <source>One-To-Many associations are connecting one source with multiple targets. The targets however are again connected to exactly one specific source.</source>
          <target state="translated">일대 다 연결은 하나의 소스를 여러 대상과 연결합니다. 그러나 대상은 다시 정확히 하나의 특정 소스에 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="b5a781b5514ee94996d11452869654e21fc523a3" translate="yes" xml:space="preserve">
          <source>One-To-Many relationships</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="159ce298fdb55c0ace2cae5b9eeddb9085ed1b07" translate="yes" xml:space="preserve">
          <source>One-To-One associations</source>
          <target state="translated">일대일 협회</target>
        </trans-unit>
        <trans-unit id="7ac7134636ef26e8db79e47ff7c804d75176aa8d" translate="yes" xml:space="preserve">
          <source>One-To-One associations are associations between exactly two models connected by a single foreign key.</source>
          <target state="translated">일대일 연관은 단일 외래 키로 연결된 정확히 두 모델 간의 연관입니다.</target>
        </trans-unit>
        <trans-unit id="a6f42f09b773908f656b88977e0de752b08cbfe9" translate="yes" xml:space="preserve">
          <source>One-To-One relationships</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb9ea5ba36ce6f7d9d94e0be6907f913407401de" translate="yes" xml:space="preserve">
          <source>One-to-One and One-to-Many associations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2309e67cc0497393678cf4861e18785cba42982e" translate="yes" xml:space="preserve">
          <source>One-to-many association</source>
          <target state="translated">일대 다 협회</target>
        </trans-unit>
        <trans-unit id="52422157c5551a74edd9efae050fd0cbd45e6b6a" translate="yes" xml:space="preserve">
          <source>One-to-one association</source>
          <target state="translated">일대일 협회</target>
        </trans-unit>
        <trans-unit id="80c2f522b0cc71f97fccf4d0cc3b4b1a1a723e86" translate="yes" xml:space="preserve">
          <source>Only a hook with name param can be removed.</source>
          <target state="translated">이름이 param 인 후크 만 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7c3ed5082d4c21101247c805bae6a1b4e6471d0" translate="yes" xml:space="preserve">
          <source>Only available for Postgres</source>
          <target state="translated">Postgres에서만 사용 가능</target>
        </trans-unit>
        <trans-unit id="78606afd96fe0f52ff679e248222b3ca8c9d2f35" translate="yes" xml:space="preserve">
          <source>Only retry a query if the error matches one of these strings.</source>
          <target state="translated">오류가 이러한 문자열 중 하나와 일치하는 경우에만 쿼리를 다시 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="3e2300fe17116ec50dc76cbd8fba7c82514d27c0" translate="yes" xml:space="preserve">
          <source>Only then the &lt;code&gt;sequelize.transaction&lt;/code&gt; call will settle:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef20bd5977f69845fb3605c4d34d8da2e99079ec" translate="yes" xml:space="preserve">
          <source>Only used by sqlite. Defaults to ':memory:'</source>
          <target state="translated">sqlite에서만 사용됩니다. 기본값은 ': memory :'</target>
        </trans-unit>
        <trans-unit id="72994e2f28b83f1f262ee9b3a2e57ad75ee09f35" translate="yes" xml:space="preserve">
          <source>Only used in conjunction with TRUNCATE. Automatically restart sequences owned by columns of the truncated table.</source>
          <target state="translated">TRUNCATE와 함께 사용해야합니다. 잘린 테이블의 열이 소유 한 시퀀스를 자동으로 다시 시작합니다.</target>
        </trans-unit>
        <trans-unit id="659fa6ab2bfaf4a00c71607875bf9ee544072de3" translate="yes" xml:space="preserve">
          <source>Only used in conjunction with TRUNCATE. Truncates all tables that have foreign-key references to the named table, or to any tables added to the group due to CASCADE.</source>
          <target state="translated">TRUNCATE와 함께 사용해야합니다. 명명 된 테이블 또는 CASCADE로 인해 그룹에 추가 된 테이블에 대한 외래 키 참조가있는 모든 테이블을 자릅니다.</target>
        </trans-unit>
        <trans-unit id="1e5c03c4ca5dbc17c5a6129ff8dbe16f01a71ebd" translate="yes" xml:space="preserve">
          <source>Op</source>
          <target state="translated">Op</target>
        </trans-unit>
        <trans-unit id="8fe26ec471775c33716aff2e25b307500cb8f70b" translate="yes" xml:space="preserve">
          <source>Operator symbols to be used when querying data</source>
          <target state="translated">데이터를 쿼리 할 때 사용되는 연산자 기호</target>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="translated">Operators</target>
        </trans-unit>
        <trans-unit id="7cbeab9a20efe2e2217d5d299f851a542c5447fe" translate="yes" xml:space="preserve">
          <source>Operators Aliases</source>
          <target state="translated">연산자 별칭</target>
        </trans-unit>
        <trans-unit id="72687734b357dface3249321a849ea8462093c98" translate="yes" xml:space="preserve">
          <source>Operators for possible operators __Alias__: _all_ The promise is resolved with an array of Model instances if the query succeeds._</source>
          <target state="translated">가능한 연산자의 연산자 __Alias__ : _all_ 쿼리가 성공하면 약속은 Model 인스턴스 배열로 해결됩니다 ._</target>
        </trans-unit>
        <trans-unit id="09a779d716fb827fb88714d6257f33d91fa93ea1" translate="yes" xml:space="preserve">
          <source>Operators security</source>
          <target state="translated">운영자 보안</target>
        </trans-unit>
        <trans-unit id="778c618117429ef2dedad8c828b71d5371cf6e0f" translate="yes" xml:space="preserve">
          <source>Optimistic Locking</source>
          <target state="translated">낙관적 잠금</target>
        </trans-unit>
        <trans-unit id="6140cd6be492f81e9de5ce4e733267b4f93e5075" translate="yes" xml:space="preserve">
          <source>Optimistic locking allows concurrent access to model records for edits and prevents conflicts from overwriting data. It does this by checking whether another process has made changes to a record since it was read and throws an OptimisticLockError when a conflict is detected.</source>
          <target state="translated">낙관적 잠금을 통해 편집을 위해 모델 레코드에 동시에 액세스 할 수 있으며 충돌로 인한 데이터 덮어 쓰기를 방지 할 수 있습니다. 다른 프로세스가 읽은 이후 레코드를 변경했는지 확인하여 충돌이 감지되면 OptimisticLockError를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="8f677a4471721e62d141c02c1a6189a2cab24531" translate="yes" xml:space="preserve">
          <source>Optimistic locking is disabled by default and can be enabled by setting the &lt;code&gt;version&lt;/code&gt; property to true in a specific model definition or global model configuration. See &lt;a href=&quot;models-definition#configuration&quot;&gt;model configuration&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a45991670c71fc0c7f3eb11ef210b0020884d66a" translate="yes" xml:space="preserve">
          <source>OptimisticLockError</source>
          <target state="translated">OptimisticLockError</target>
        </trans-unit>
        <trans-unit id="1664e83457c5b5ad3dd1a7ec25b5b6fdcdaa8bfb" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;returning: true&lt;/code&gt; will no longer return attributes that are not defined in the model. Old behavior can be achieved by using &lt;code&gt;returning: ['*']&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5182cc6f458b27f798ef769e48426d170adaca6f" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;returning: true&lt;/code&gt; will no longer return attributes that are not defined in the model. Old behavior can be restored by using &lt;code&gt;returning: ['*']&lt;/code&gt;</source>
          <target state="translated">옵션 &lt;code&gt;returning: true&lt;/code&gt; 는 더 이상 모델에 정의되지 않은 속성을 반환하지 않습니다. 다음을 &lt;code&gt;returning: ['*']&lt;/code&gt; 하여 이전 동작을 복원 할 수 있습니다 . [ '*']</target>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="2573f9c5c9739bda23063f4ec6575c5d4fcbe3c1" translate="yes" xml:space="preserve">
          <source>Options passed to &lt;code&gt;target.create&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;target.create&lt;/code&gt; 에 전달 된 옵션</target>
        </trans-unit>
        <trans-unit id="fc281780c58169a65a5387bce961e7af93c4bb24" translate="yes" xml:space="preserve">
          <source>Options passed to &lt;code&gt;target.create&lt;/code&gt; and setAssociation.</source>
          <target state="translated">&lt;code&gt;target.create&lt;/code&gt; 및 setAssociation에 전달 된 옵션</target>
        </trans-unit>
        <trans-unit id="40b503e9df444ee2d315f6badf5d3e76b933fb08" translate="yes" xml:space="preserve">
          <source>Options passed to &lt;code&gt;target.findAll&lt;/code&gt; and &lt;code&gt;update&lt;/code&gt;.</source>
          <target state="translated">옵션에 전달 &lt;code&gt;target.findAll&lt;/code&gt; 및 &lt;code&gt;update&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f7d5ec9760408cef1a3917f12f6c577fe6b6b15" translate="yes" xml:space="preserve">
          <source>Options passed to &lt;code&gt;target.update&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;target.update&lt;/code&gt; 에 전달 된 옵션</target>
        </trans-unit>
        <trans-unit id="5943acc368ef8e8a62d06081b8cac9a14bc7c85f" translate="yes" xml:space="preserve">
          <source>Options passed to &lt;code&gt;target.update&lt;/code&gt;.</source>
          <target state="translated">옵션이 &lt;code&gt;target.update&lt;/code&gt; 로 전달되었습니다 .</target>
        </trans-unit>
        <trans-unit id="6a4f8685a8ba251504870ba17fa94124cb574705" translate="yes" xml:space="preserve">
          <source>Options passed to &lt;code&gt;through.destroy&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;through.destroy&lt;/code&gt; 에 전달 된 옵션</target>
        </trans-unit>
        <trans-unit id="0115f779a0e49b0656989e51e294eb81c64793d7" translate="yes" xml:space="preserve">
          <source>Options passed to &lt;code&gt;through.findAll&lt;/code&gt;, &lt;code&gt;bulkCreate&lt;/code&gt; and &lt;code&gt;update&lt;/code&gt;</source>
          <target state="translated">전달 옵션 &lt;code&gt;through.findAll&lt;/code&gt; , &lt;code&gt;bulkCreate&lt;/code&gt; 및 &lt;code&gt;update&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="26176f8cc30b890f9a9b8e35a52a1de2b863ffe7" translate="yes" xml:space="preserve">
          <source>Options passed to &lt;code&gt;through.findAll&lt;/code&gt;, &lt;code&gt;bulkCreate&lt;/code&gt;, &lt;code&gt;update&lt;/code&gt; and &lt;code&gt;destroy&lt;/code&gt;</source>
          <target state="translated">옵션에 전달 &lt;code&gt;through.findAll&lt;/code&gt; , &lt;code&gt;bulkCreate&lt;/code&gt; , &lt;code&gt;update&lt;/code&gt; 및 &lt;code&gt;destroy&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4a4b33ed3ca527fbd4b9245bafffeee52768cf1a" translate="yes" xml:space="preserve">
          <source>Options passed to create and add</source>
          <target state="translated">작성 및 추가하기 위해 전달 된 옵션</target>
        </trans-unit>
        <trans-unit id="474d03cde40320ee091013efe8d0db26cc7d0b45" translate="yes" xml:space="preserve">
          <source>Options passed to getAssociation and &lt;code&gt;target.save&lt;/code&gt;</source>
          <target state="translated">getAssociation 및 &lt;code&gt;target.save&lt;/code&gt; 에 전달 된 옵션</target>
        </trans-unit>
        <trans-unit id="fee507ed9dc18ea297e1ba8190f5aa49edd68423" translate="yes" xml:space="preserve">
          <source>Options passed to getAssociations</source>
          <target state="translated">getAssociations에 전달 된 옵션</target>
        </trans-unit>
        <trans-unit id="06fee8d775b90a83eb6e0500643ad5937a039f32" translate="yes" xml:space="preserve">
          <source>Options that are passed on to &lt;code&gt;Model.find&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Model.find&lt;/code&gt; 에 전달되는 옵션</target>
        </trans-unit>
        <trans-unit id="ee8bbce524fef6ba7c6dbac58492250221aae721" translate="yes" xml:space="preserve">
          <source>Options that are passed to the validator</source>
          <target state="translated">유효성 검증기에 전달되는 옵션</target>
        </trans-unit>
        <trans-unit id="a2025fe246c877972310ec609eb48f54489ec039" translate="yes" xml:space="preserve">
          <source>Options to describe the scope of the search.</source>
          <target state="translated">검색 범위를 설명하는 옵션.</target>
        </trans-unit>
        <trans-unit id="3f3859dbc9487b25a2b59e3d5cd366d7fb290390" translate="yes" xml:space="preserve">
          <source>Or use the &lt;em&gt;&lt;a href=&quot;#special-methods-mixins-added-to-instances&quot;&gt;special methods/mixins&lt;/a&gt;&lt;/em&gt; available for associated models, which are explained later on this page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bec1ed99ae879b5c4b91ae857a753fb5fb51217b" translate="yes" xml:space="preserve">
          <source>Or you can use a connection string as well with a path:</source>
          <target state="translated">또는 경로와 함께 연결 문자열을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbc9ff5400f0f9e6142729232a25f5dcca1a8793" translate="yes" xml:space="preserve">
          <source>Or, if your callback throws, rejecting with the thrown error</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f1762b33b20d79d93b528934ab2323b45f0b56c" translate="yes" xml:space="preserve">
          <source>Order of Operations</source>
          <target state="translated">작업 순서</target>
        </trans-unit>
        <trans-unit id="d3ed86c1334d74f0ae883f47feef902d83b9d8c6" translate="yes" xml:space="preserve">
          <source>Ordering</source>
          <target state="translated">Ordering</target>
        </trans-unit>
        <trans-unit id="7c3e631356b9b789997f759381378ec61789d79c" translate="yes" xml:space="preserve">
          <source>Ordering Eager Loaded Associations</source>
          <target state="translated">열망하는로드 된 주문 주문</target>
        </trans-unit>
        <trans-unit id="c4074f8dc0dcc50a668d9c0e4f1182abf0d386af" translate="yes" xml:space="preserve">
          <source>Ordering and Grouping</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4c5ce82318e26ae51c29ee1ce6341214a0d8425" translate="yes" xml:space="preserve">
          <source>Ordering eager loaded associations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e6a6f2086bb5fe5dbfd17d8d5f502d48759834b" translate="yes" xml:space="preserve">
          <source>Other</source>
          <target state="translated">Other</target>
        </trans-unit>
        <trans-unit id="522eda5cc722083fbfe57e34a45a7259dc33c472" translate="yes" xml:space="preserve">
          <source>Other Data Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96c2ab3009653c0dea9ef2fbe566de5309b08a8e" translate="yes" xml:space="preserve">
          <source>Other instance to compare against</source>
          <target state="translated">비교할 다른 인스턴스</target>
        </trans-unit>
        <trans-unit id="8d7bf5bf136e81f9388c1f4eca050d6d94e965d7" translate="yes" xml:space="preserve">
          <source>Others</source>
          <target state="translated">Others</target>
        </trans-unit>
        <trans-unit id="7e77ada74a3be01c5d888912daa8e9c03d2a3dd2" translate="yes" xml:space="preserve">
          <source>Otherwise, &lt;code&gt;{ transaction: options.transaction }&lt;/code&gt; will be equivalent to &lt;code&gt;{ transaction: undefined }&lt;/code&gt;, which won't use a transaction (which is ok).</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
