<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="apache_pig">
    <body>
      <group id="apache_pig">
        <trans-unit id="b84bc074a676488f8828fbd4d80a248a56a789fd" translate="yes" xml:space="preserve">
          <source>#reducers = MIN (pig.exec.reducers.max, total input size (in bytes) / bytes per reducer)</source>
          <target state="translated">#reducers = MIN (pig.exec.reducers.max, 총 입력 크기 (바이트) / 리듀서 당 바이트)</target>
        </trans-unit>
        <trans-unit id="8354e8987197f8f3f65048ed50db923e92430c80" translate="yes" xml:space="preserve">
          <source>$ export PATH=/&amp;lt;my-path-to-pig&amp;gt;/pig-n.n.n/bin:$PATH</source>
          <target state="translated">$ 내보내기 PATH = / &amp;lt;my-path-to-pig&amp;gt; / pig-nnn / bin : $ PATH</target>
        </trans-unit>
        <trans-unit id="1b82a3d4debf655b50bc5c4c73a5a0dd099e4e88" translate="yes" xml:space="preserve">
          <source>$x .. $y : projects columns through $y, inclusive</source>
          <target state="translated">$ x .. $ y : $ y를 포함하여 열을 투영합니다.</target>
        </trans-unit>
        <trans-unit id="03acefa58a02d7ca8fdcdc03b8ecfd38423e91d5" translate="yes" xml:space="preserve">
          <source>$x .. : projects columns through end, inclusive</source>
          <target state="translated">$ x .. : 끝까지 포괄적 인 열을 투사합니다.</target>
        </trans-unit>
        <trans-unit id="b7614f84ca9cc1f748809a55e2f814dcb58e3bd9" translate="yes" xml:space="preserve">
          <source>% modulo</source>
          <target state="translated">모듈로 %</target>
        </trans-unit>
        <trans-unit id="57890f589aef66a37b3df37534465aa840218f6f" translate="yes" xml:space="preserve">
          <source>%declare</source>
          <target state="translated">%declare</target>
        </trans-unit>
        <trans-unit id="8c2129f753dea3ef6b0e2a86035f15e9888c2973" translate="yes" xml:space="preserve">
          <source>%default</source>
          <target state="translated">%default</target>
        </trans-unit>
        <trans-unit id="9d559fca6624781de64da3cbf87e5383409959c7" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2007&amp;ndash;2017 Apache Software Foundation</source>
          <target state="translated">&amp;copy; 2007&amp;ndash;2017 Apache Software Foundation</target>
        </trans-unit>
        <trans-unit id="908c1e177a8633826af2fa31bee5cd04a08abf18" translate="yes" xml:space="preserve">
          <source>&amp;gt;, &amp;lt;</source>
          <target state="translated">&amp;gt;, &amp;lt;</target>
        </trans-unit>
        <trans-unit id="361700fbe012c3cd2d8045945a221334e0df1bb7" translate="yes" xml:space="preserve">
          <source>&amp;gt;=, &amp;lt;=</source>
          <target state="translated">&amp;gt; =, &amp;lt;=</target>
        </trans-unit>
        <trans-unit id="839e4a2006b278a93c4dc0f1936567078302c3f3" translate="yes" xml:space="preserve">
          <source>&amp;hellip;</source>
          <target state="translated">&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="cb90cc32b7213ab9e55be03ebc7a77f06b9dac38" translate="yes" xml:space="preserve">
          <source>&amp;ndash;brief</source>
          <target state="translated">&amp;ndash;brief</target>
        </trans-unit>
        <trans-unit id="258bc41b6c768b10dbdcc12de44876c94cc4d5a7" translate="yes" xml:space="preserve">
          <source>&amp;ndash;dot, -xml</source>
          <target state="translated">&amp;ndash;dot, -xml</target>
        </trans-unit>
        <trans-unit id="5e4178c0b6636e6d29b88558269d8aa070ea2e67" translate="yes" xml:space="preserve">
          <source>&amp;ndash;out</source>
          <target state="translated">&amp;ndash;out</target>
        </trans-unit>
        <trans-unit id="3f3ffbed51fb277f882a75b339836f5a8bf721b4" translate="yes" xml:space="preserve">
          <source>&amp;ndash;param param_name = param_value</source>
          <target state="translated">&amp;ndash;param param_name = param_value</target>
        </trans-unit>
        <trans-unit id="ae5db2e46d0ffbbc371cf2bc9c453145fd0f1515" translate="yes" xml:space="preserve">
          <source>&amp;ndash;param_file file_name</source>
          <target state="translated">&amp;ndash;param_file file_name</target>
        </trans-unit>
        <trans-unit id="d85cc3b3555449ad3b192323c6c68d87071cb8e0" translate="yes" xml:space="preserve">
          <source>&amp;ndash;script</source>
          <target state="translated">&amp;ndash;script</target>
        </trans-unit>
        <trans-unit id="0bde4f85858da8acb95649c50ff3d43b6ad2fc34" translate="yes" xml:space="preserve">
          <source>' 123.142| a27e0'</source>
          <target state="translated">'123.142 | a27e0 '</target>
        </trans-unit>
        <trans-unit id="b19d05d1e1a23c54003f9d95179a5e2325369cf7" translate="yes" xml:space="preserve">
          <source>' 1234567| 1234567|yay '</source>
          <target state="translated">'1234567 | 1234567 | yay '</target>
        </trans-unit>
        <trans-unit id="91764d4adf3000598466380065cbcd0e6bafd7b4" translate="yes" xml:space="preserve">
          <source>'%,+10d|%(06d'</source>
          <target state="translated">'%,+10d|%(06d'</target>
        </trans-unit>
        <trans-unit id="d815e6fad62bb57cb575daa45061351efe14eaa5" translate="yes" xml:space="preserve">
          <source>'%2$5d: %3$6s %1$3s %2$4x (%&amp;lt;4X)'</source>
          <target state="translated">'% 2 $ 5d : % 3 $ 6s % 1 $ 3s % 2 $ 4x (% &amp;lt;4X)'</target>
        </trans-unit>
        <trans-unit id="5240a0080138a24ae8ac0984ec6f2132643601f1" translate="yes" xml:space="preserve">
          <source>'%8.3f|%6x'</source>
          <target state="translated">'%8.3f|%6x'</target>
        </trans-unit>
        <trans-unit id="72c632a8ce86d13c49294287d5cf12dff3cf0481" translate="yes" xml:space="preserve">
          <source>'%8s'</source>
          <target state="translated">'%8s'</target>
        </trans-unit>
        <trans-unit id="1b4f133ce3ea53bc23dd7f4e25e520c06b3f4aab" translate="yes" xml:space="preserve">
          <source>'%8s|%-8s'</source>
          <target state="translated">'%8s|%-8s'</target>
        </trans-unit>
        <trans-unit id="3fa42c40482b85e2c0f35aa3a15f03303a92d428" translate="yes" xml:space="preserve">
          <source>'%8s|%8d|%-8s'</source>
          <target state="translated">'%8s|%8d|%-8s'</target>
        </trans-unit>
        <trans-unit id="f563aca661821c80339687a3ca588a58c69ffa37" translate="yes" xml:space="preserve">
          <source>'+1,234,567|(0123)'</source>
          <target state="translated">'+1,234,567|(0123)'</target>
        </trans-unit>
        <trans-unit id="96c34a355bbed7760577054ca9061b6277211788" translate="yes" xml:space="preserve">
          <source>'/dir' is the log directory, enclosed in single quotes.</source>
          <target state="translated">'/ dir'은 작은 따옴표로 묶은 로그 디렉토리입니다.</target>
        </trans-unit>
        <trans-unit id="f0cc6434da610d54f160966ae2c017de3b1b47bf" translate="yes" xml:space="preserve">
          <source>'48879: wheres the beef (BEEF)'</source>
          <target state="translated">'48879 : 쇠고기가있는 곳 (BEEF)'</target>
        </trans-unit>
        <trans-unit id="44a42a07c6841e44060d913108730700b1510a85" translate="yes" xml:space="preserve">
          <source>'Launch Time: %14d %s'</source>
          <target state="translated">'시작 시간 : % 14d % s'</target>
        </trans-unit>
        <trans-unit id="c988e426c095dadaedc8ad9347fadc684110d460" translate="yes" xml:space="preserve">
          <source>'Launch Time: 1400164132000 2014-05-15 09:28:52 -0500'</source>
          <target state="translated">'시작 시간 : 1400164132000 2014-05-15 09:28:52 -0500'</target>
        </trans-unit>
        <trans-unit id="35922f9416fbaa4859976e6eecc5d77264345de1" translate="yes" xml:space="preserve">
          <source>'also'</source>
          <target state="translated">'also'</target>
        </trans-unit>
        <trans-unit id="e8daba181bbe359260b9411ccb426da7417bd463" translate="yes" xml:space="preserve">
          <source>'bloom'</source>
          <target state="translated">'bloom'</target>
        </trans-unit>
        <trans-unit id="8f9218d9334ec3272b7d6a6c5c138a2284b3f5a9" translate="yes" xml:space="preserve">
          <source>'character'</source>
          <target state="translated">'character'</target>
        </trans-unit>
        <trans-unit id="e20107e960ea9ae34308d02dc456faceeb2afac0" translate="yes" xml:space="preserve">
          <source>'collected'</source>
          <target state="translated">'collected'</target>
        </trans-unit>
        <trans-unit id="5b396fe22d540019bc2a9738eaec648006a89c08" translate="yes" xml:space="preserve">
          <source>'columns'</source>
          <target state="translated">'columns'</target>
        </trans-unit>
        <trans-unit id="57fb7269bc41023a0d0170630f4a2ad71c89ef25" translate="yes" xml:space="preserve">
          <source>'data'</source>
          <target state="translated">'data'</target>
        </trans-unit>
        <trans-unit id="6826a145d5c6bc40518f7e21bdc7295ce35adb9e" translate="yes" xml:space="preserve">
          <source>'data' - data source you supply</source>
          <target state="translated">'data'-제공 한 데이터 소스</target>
        </trans-unit>
        <trans-unit id="ebac0126859784e6a20fac73243ca635a21a9eae" translate="yes" xml:space="preserve">
          <source>'dfs_path#dfs_file' &amp;ndash; A file path/file name on the distributed file system, enclosed in single quotes. Example: '/mydir/mydata.txt#mydata.txt'</source>
          <target state="translated">'dfs_path # dfs_file'&amp;ndash; 작은 따옴표로 묶인 분산 파일 시스템의 파일 경로 / 파일 이름입니다. 예 : '/mydir/mydata.txt#mydata.txt'</target>
        </trans-unit>
        <trans-unit id="58b85ead5d5e764aa92eac8c40857bfbe91d853c" translate="yes" xml:space="preserve">
          <source>'directory'</source>
          <target state="translated">'directory'</target>
        </trans-unit>
        <trans-unit id="6df7222fbd791dffe3b3bdd1bd98ab462653678a" translate="yes" xml:space="preserve">
          <source>'field_delimiter'</source>
          <target state="translated">'field_delimiter'</target>
        </trans-unit>
        <trans-unit id="bf922bbf59a5b5434ed0583ed872eeacfb110098" translate="yes" xml:space="preserve">
          <source>'hello world'</source>
          <target state="translated">'안녕하세요 세계'</target>
        </trans-unit>
        <trans-unit id="6d4c00a4227dcd62a6f2231b50aa34a4b50184e4" translate="yes" xml:space="preserve">
          <source>'ignored'</source>
          <target state="translated">'ignored'</target>
        </trans-unit>
        <trans-unit id="47842e7b618acc1f3b0ec46dfc1e4335522aa3d8" translate="yes" xml:space="preserve">
          <source>'merge'</source>
          <target state="translated">'merge'</target>
        </trans-unit>
        <trans-unit id="409adf4b6224f54dd72bf63f203cd21876bd38e2" translate="yes" xml:space="preserve">
          <source>'merge-sparse'</source>
          <target state="translated">'merge-sparse'</target>
        </trans-unit>
        <trans-unit id="474906e5cc1c33034fbd1bd40f746897c47f5478" translate="yes" xml:space="preserve">
          <source>'newChar'</source>
          <target state="translated">'newChar'</target>
        </trans-unit>
        <trans-unit id="a9c02a751a3a5f2dce8ccf12cc0bf8c29395fc9f" translate="yes" xml:space="preserve">
          <source>'options'</source>
          <target state="translated">'options'</target>
        </trans-unit>
        <trans-unit id="c9f3e3870e7865a73e1c751e735640935d548383" translate="yes" xml:space="preserve">
          <source>'path' &amp;ndash; A file path, enclosed in single quotes.</source>
          <target state="translated">'path'&amp;ndash; 작은 따옴표로 묶인 파일 경로입니다.</target>
        </trans-unit>
        <trans-unit id="0f4aa02f5b798bfd9cf80f92632f8ad7c724b78b" translate="yes" xml:space="preserve">
          <source>'regExp'</source>
          <target state="translated">'regExp'</target>
        </trans-unit>
        <trans-unit id="2e3a923d2c0aa0107a3099cde9f1699e90610d47" translate="yes" xml:space="preserve">
          <source>'replicated'</source>
          <target state="translated">'replicated'</target>
        </trans-unit>
        <trans-unit id="046ec40f11932a3023cf2f0ea16ca8a5cfd78ffa" translate="yes" xml:space="preserve">
          <source>'skewed'</source>
          <target state="translated">'skewed'</target>
        </trans-unit>
        <trans-unit id="0d88981c63826b2051c6aaa5bf241a2b92319fc0" translate="yes" xml:space="preserve">
          <source>'the'</source>
          <target state="translated">'the'</target>
        </trans-unit>
        <trans-unit id="e915535c8608bfca6fd04435a5ce76664c623de5" translate="yes" xml:space="preserve">
          <source>'wheres'</source>
          <target state="translated">'wheres'</target>
        </trans-unit>
        <trans-unit id="398fb2729af979d6e0d1c12380a474f98febe9fb" translate="yes" xml:space="preserve">
          <source>'yay'</source>
          <target state="translated">'yay'</target>
        </trans-unit>
        <trans-unit id="9a67501b22a9905639b8643c1edcd14ff72b3574" translate="yes" xml:space="preserve">
          <source>'|'</source>
          <target state="translated">'|'</target>
        </trans-unit>
        <trans-unit id="fcc44c6b16970e2ea8b6be7d616d2f134c07fc31" translate="yes" xml:space="preserve">
          <source>( )</source>
          <target state="translated">()</target>
        </trans-unit>
        <trans-unit id="0b28ef9233a1991e063fea55a1ce650c452f636f" translate="yes" xml:space="preserve">
          <source>( , )</source>
          <target state="translated">()</target>
        </trans-unit>
        <trans-unit id="c04a2000fc6f7a6d6b355d435a2298a628fe43a3" translate="yes" xml:space="preserve">
          <source>( field [, field &amp;hellip;] )</source>
          <target state="translated">(field [, field&amp;hellip;])</target>
        </trans-unit>
        <trans-unit id="85ffee67e61bc27da2626f54fca1c6fe2214f5c6" translate="yes" xml:space="preserve">
          <source>('noschema') - Ignores a stored schema during the load.</source>
          <target state="translated">( 'noschema')-로드 중 저장된 스키마를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="a6e4c4739702e96fa8fda705bcbd816807d98136" translate="yes" xml:space="preserve">
          <source>('schema') - Stores the schema of the relation using a hidden JSON file.</source>
          <target state="translated">( 'schema')-숨겨진 JSON 파일을 사용하여 관계의 스키마를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="64077f633a4a3165188fe44112889500bb0f4c28" translate="yes" xml:space="preserve">
          <source>('tagFile') - Add a first column indicates the input file name of the record.</source>
          <target state="translated">( 'tagFile')-첫 번째 열 추가는 레코드의 입력 파일 이름을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="707fec08471ca58a36122bc998b5a92cb66f8307" translate="yes" xml:space="preserve">
          <source>('tagPath') - Add a first column indicates the input path of the record.</source>
          <target state="translated">( 'tagPath')-첫 번째 열 추가는 레코드의 입력 경로를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="33819d9fa2a488c4e068cabc3a12819e356958bf" translate="yes" xml:space="preserve">
          <source>('tagsource') - (deprecated, Use tagPath instead) Add a first column indicates the input file of the record.</source>
          <target state="translated">( 'tagsource')-(더 이상 사용되지 않음, 대신 tagPath 사용) 첫 번째 열 추가는 레코드의 입력 파일을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="65d8418825adb7b1f445e27a844b3d81c85c497f" translate="yes" xml:space="preserve">
          <source>(-auths|--authorizations) auth1,auth2... A comma-separated list of Accumulo authorizations to use when reading data from Accumulo. Defaults to the empty set of authorizations (none).</source>
          <target state="translated">(-auths | --authorizations) auth1, auth2 ... Accumulo에서 데이터를 읽을 때 사용할 쉼표로 구분 된 Accumulo 권한 목록입니다. 비어있는 인증 세트가 기본값입니다 (없음).</target>
        </trans-unit>
        <trans-unit id="4547bf44d2584bca294f34a301d5aed4a9023501" translate="yes" xml:space="preserve">
          <source>(-buff|--mutation-buffer-size) num_bytes The number of bytes to buffer when writing data to Accumulo. A higher value requires more memory</source>
          <target state="translated">(-buff | --mutation-buffer-size) num_bytes 데이터를 Accumulo에 쓸 때 버퍼링 할 바이트 수. 값이 클수록 더 많은 메모리가 필요합니다</target>
        </trans-unit>
        <trans-unit id="69dcb5dfd200bb39e92ba827cbd88847e59099e1" translate="yes" xml:space="preserve">
          <source>(-c|--caster) LoadStoreCasterImpl An implementation of a LoadStoreCaster to use when serializing types into Accumulo, usually AccumuloBinaryConverter or UTF8StringConverter, defaults to UTF8StorageConverter.</source>
          <target state="translated">(-c | --caster) LoadStoreCasterImpl 유형을 Accumulo (일반적으로 AccumuloBinaryConverter 또는 UTF8StringConverter)로 직렬화 할 때 사용할 LoadStoreCaster 구현의 기본값은 UTF8StorageConverter입니다.</target>
        </trans-unit>
        <trans-unit id="89c00a4a8d40e1d5c41075c668f8f6bf631b0c37" translate="yes" xml:space="preserve">
          <source>(-e|--end) end_row The Accumulo row to read until, inclusive</source>
          <target state="translated">(-e | --end) end_row 다음을 포함 할 때까지 읽을 누적 행입니다.</target>
        </trans-unit>
        <trans-unit id="59d2aaf21ef16550cfab736139deba271e19159f" translate="yes" xml:space="preserve">
          <source>(-iw|--ignore-whitespace) (true|false) Should whitespace be stripped from the column specification, defaults to true</source>
          <target state="translated">(-iw | --ignore-whitespace) (true | false) 열 스펙에서 공백을 제거해야하는 경우 기본값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="c23dcfcc497cfc54dd400a3cd36ac9535f1bf514" translate="yes" xml:space="preserve">
          <source>(-ml|--max-latency) milliseconds Maximum time in milliseconds before data is flushed to Accumulo.</source>
          <target state="translated">(-ml | --max-latency) 밀리 초 데이터가 Accumulo로 플러시되기 전의 최대 시간 (밀리 초)입니다.</target>
        </trans-unit>
        <trans-unit id="819ede110371f977a75f3cfb5217eecbffb5aa14" translate="yes" xml:space="preserve">
          <source>(-sep|--separator) str The separator character used when parsing the column specification, defaults to comma (,)</source>
          <target state="translated">(-sep | --separator) str 열 스펙을 구문 분석 할 때 사용되는 분리 문자이며 기본값은 쉼표 (,)입니다.</target>
        </trans-unit>
        <trans-unit id="ffff0d810ba3fd01fa78a9961a3f0394718aa971" translate="yes" xml:space="preserve">
          <source>(-s|--start) start_row The Accumulo row to begin reading from, inclusive</source>
          <target state="translated">(-s | --start) start_row 다음을 포함하여 읽기 시작하는 누적 행</target>
        </trans-unit>
        <trans-unit id="0a07a2173d3041f590cb67fb0929d19671261e8e" translate="yes" xml:space="preserve">
          <source>(-wt|--write-threads) num_threads The number of threads used to write data to Accumulo.</source>
          <target state="translated">(-wt | --write-threads) num_threads Accumulo에 데이터를 쓰는 데 사용되는 스레드 수.</target>
        </trans-unit>
        <trans-unit id="c33f5d82526c37a5dae951c41fccd6373bc6e28d" translate="yes" xml:space="preserve">
          <source>(1, abc, (2,4,6) )</source>
          <target state="translated">(1, abc, (2,4,6))</target>
        </trans-unit>
        <trans-unit id="4c788c5802d34f8e492f60a2bf82ab0169d15037" translate="yes" xml:space="preserve">
          <source>(19, 2, 1)</source>
          <target state="translated">(19, 2, 1)</target>
        </trans-unit>
        <trans-unit id="9ae62fb3b0901fbd9fbbb025453d4ed5aec094ba" translate="yes" xml:space="preserve">
          <source>(Optional) Keyword</source>
          <target state="translated">(선택 사항) 키워드</target>
        </trans-unit>
        <trans-unit id="16e4b97da01caf45c8b7b6d7ee52973e6900493a" translate="yes" xml:space="preserve">
          <source>(Optional) The data type, bag (case insensitive).</source>
          <target state="translated">(선택 사항) 데이터 유형 백 (대소 문자 구분).</target>
        </trans-unit>
        <trans-unit id="aaf9402d66813fda98b4382a697c78a850e195e1" translate="yes" xml:space="preserve">
          <source>(Optional) The data type, map (case insensitive).</source>
          <target state="translated">(선택 사항) 데이터 유형, 맵 (대소 문자 구분).</target>
        </trans-unit>
        <trans-unit id="946e3030d29202cff5f23f8c949098b0ad53c7b8" translate="yes" xml:space="preserve">
          <source>(Optional) The data type, tuple (case insensitive).</source>
          <target state="translated">(선택 사항) 데이터 유형, 튜플 (대소 문자 구분).</target>
        </trans-unit>
        <trans-unit id="b31286b3dce5bf3075a8d89c14b6436198d21482" translate="yes" xml:space="preserve">
          <source>(Optional) The datatype (all types allowed, bytearray is the default).</source>
          <target state="translated">(선택 사항) 데이터 유형 (모든 유형이 허용되며 바이트 배열이 기본값 임)</target>
        </trans-unit>
        <trans-unit id="6bce15fc7dd55172e94bd36ecc729becb1e1e7c1" translate="yes" xml:space="preserve">
          <source>(Optional) The simple data type assigned to the field.</source>
          <target state="translated">(선택 사항) 필드에 지정된 단순 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="1c758c5d1b9d431b160d178e19be47d96d290c18" translate="yes" xml:space="preserve">
          <source>(The exact package of the function can be seen in the javadocs or by navigating the source tree.)</source>
          <target state="translated">(함수의 정확한 패키지는 javadocs에서 또는 소스 트리를 탐색하여 볼 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="01cf24f603ea48bce9ec2b902b123faa0ee90694" translate="yes" xml:space="preserve">
          <source>(These conventions are not strictly adherered to in all examples.)</source>
          <target state="translated">(이러한 규칙은 모든 예에서 엄격하게 준수되지는 않습니다.)</target>
        </trans-unit>
        <trans-unit id="808fed598d0bccb794b1cb63cf2c9148bda07647" translate="yes" xml:space="preserve">
          <source>(alias[:type]) [, (alias[:type]) &amp;hellip;] )</source>
          <target state="translated">(alias [: type]) [, (alias [: type])&amp;hellip;])</target>
        </trans-unit>
        <trans-unit id="720dcff6cf795df27ef6483091a3d7590ac2ff24" translate="yes" xml:space="preserve">
          <source>(condition ? value_if_true : value_if_false)</source>
          <target state="translated">(조건? value_if_true : value_if_false)</target>
        </trans-unit>
        <trans-unit id="1203246c729b523bc762ad3151a230c8e6a06859" translate="yes" xml:space="preserve">
          <source>(data_type)</source>
          <target state="translated">(data_type)</target>
        </trans-unit>
        <trans-unit id="7d347c23c5da4442bb130ec9dcceaaa3d2a39757" translate="yes" xml:space="preserve">
          <source>(null value)</source>
          <target state="translated">(널값)</target>
        </trans-unit>
        <trans-unit id="8f7930a189bfe767e88a931bfaca75789c804203" translate="yes" xml:space="preserve">
          <source>(optional) A comma-separated list of one or more parameters, including IN aliases (Pig relations), enclosed in parentheses, that are referenced in the Pig Latin fragment.</source>
          <target state="translated">(선택 사항) 괄호로 묶인 IN 별명 (Pig 관계)을 포함하여 Pig Latin 단편에서 참조되는 하나 이상의 매개 변수를 쉼표로 구분 한 목록입니다.</target>
        </trans-unit>
        <trans-unit id="b34de9d94056fde530098e42dcbd79ae655521a0" translate="yes" xml:space="preserve">
          <source>(optional) A comma-separated list of one or more return aliases (Pig relations) that are referenced in the Pig Latin fragment. The alias must exist in the macro in the form $&amp;lt;alias&amp;gt;.</source>
          <target state="translated">(선택 사항) Pig Latin 조각에서 참조되는 하나 이상의 리턴 별명 (Pig 관계)을 쉼표로 구분 한 목록입니다. 별명은 $ &amp;lt;alias&amp;gt; 형식으로 매크로에 존재해야합니다.</target>
        </trans-unit>
        <trans-unit id="d061bc7adafe2ff7cf191c5fce83528a8270fae8" translate="yes" xml:space="preserve">
          <source>(optional) LIMIT n is the error threshold where n is an integer value. If not specified, the default error threshold is unlimited.</source>
          <target state="translated">(선택 사항) LIMIT n은 오류 임계 값이며 여기서 n은 정수 값입니다. 지정하지 않으면 기본 오류 임계 값은 무제한입니다.</target>
        </trans-unit>
        <trans-unit id="b9a01920a07aff7d091d8e155590ddb0f7323f1c" translate="yes" xml:space="preserve">
          <source>(see Note 1)</source>
          <target state="translated">(주 1 참조)</target>
        </trans-unit>
        <trans-unit id="896dcd4943e25118777233e9ef86eb6367c10ecd" translate="yes" xml:space="preserve">
          <source>(see Note 2)</source>
          <target state="translated">(주 2 참조)</target>
        </trans-unit>
        <trans-unit id="f7b70ec2c5bfd9a3db969f1b2416c0c7bde1e381" translate="yes" xml:space="preserve">
          <source>* Average values for datatypes bigdecimal and biginteger have precision setting &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/math/MathContext.html#DECIMAL128&quot;&gt;java.math.MathContext.DECIMAL128&lt;/a&gt;.</source>
          <target state="translated">bigdecimal 및 biginteger 데이터 유형의 평균 값은 정밀도 설정 &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/math/MathContext.html#DECIMAL128&quot;&gt;java.math.MathContext.DECIMAL128을&lt;/a&gt; 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="bdb3225ffddb78efe8031c09480f313084e826ce" translate="yes" xml:space="preserve">
          <source>* Average values for datatypes bigdecimal and biginteger have precision setting &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/math/MathContext.html#DECIMAL128&quot;&gt;java.math.MathContext.DECIMAL128&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af1e263a7139945e63effc6e56412fb991495ef8" translate="yes" xml:space="preserve">
          <source>* bytearray cast as this data type</source>
          <target state="translated">*이 데이터 유형으로 바이트 배열 캐스트</target>
        </trans-unit>
        <trans-unit id="3033ad6201baa25536a80a82f0cfa9f5ecb01fa3" translate="yes" xml:space="preserve">
          <source>*Cast as chararray (the second argument must be chararray)</source>
          <target state="translated">* chararray로 캐스팅 (두 번째 인수는 chararray 여야 함)</target>
        </trans-unit>
        <trans-unit id="60b62004da064c683dec0fb25cd28876d76e3be6" translate="yes" xml:space="preserve">
          <source>+ , -, *, /</source>
          <target state="translated">+,-, *, /</target>
        </trans-unit>
        <trans-unit id="3bc15c8aae3e4124dd409035f32ea2fd6835efc9" translate="yes" xml:space="preserve">
          <source>-</source>
          <target state="translated">-</target>
        </trans-unit>
        <trans-unit id="5d02601bffacd2105503e37e01a04a407a4368a6" translate="yes" xml:space="preserve">
          <source>-- A</source>
          <target state="translated">-- ㅏ</target>
        </trans-unit>
        <trans-unit id="21310c32ec263e8cc48d962e92d6cd0552124742" translate="yes" xml:space="preserve">
          <source>-- B</source>
          <target state="translated">-B</target>
        </trans-unit>
        <trans-unit id="470f42987324b24643e8151603ab9a5323e9e9cb" translate="yes" xml:space="preserve">
          <source>-- C</source>
          <target state="translated">-- 씨</target>
        </trans-unit>
        <trans-unit id="9576082ab0d756bcf56b66a307b1923c401d3aed" translate="yes" xml:space="preserve">
          <source>-- D</source>
          <target state="translated">-D</target>
        </trans-unit>
        <trans-unit id="51b228bdb7ca01f4446bffa6326411c3117f249c" translate="yes" xml:space="preserve">
          <source>-- E</source>
          <target state="translated">-전자</target>
        </trans-unit>
        <trans-unit id="d3740ebc400e39246cc1fdb59de5b279ecc6d795" translate="yes" xml:space="preserve">
          <source>-- F</source>
          <target state="translated">-F</target>
        </trans-unit>
        <trans-unit id="8fa98e831fdcdb1854265221f2ae1442aa4bae80" translate="yes" xml:space="preserve">
          <source>-- G</source>
          <target state="translated">-G</target>
        </trans-unit>
        <trans-unit id="b092bab87e859629d39abe4bab778d611f0f9c17" translate="yes" xml:space="preserve">
          <source>-- H</source>
          <target state="translated">-H</target>
        </trans-unit>
        <trans-unit id="0c57e98f156fb0819bcae0cb2fa079c1fd392508" translate="yes" xml:space="preserve">
          <source>-- I</source>
          <target state="translated">-나는</target>
        </trans-unit>
        <trans-unit id="b6a10e6560adad9cc8ff96dfcebd73d7046d0f65" translate="yes" xml:space="preserve">
          <source>-- J</source>
          <target state="translated">-- 제이</target>
        </trans-unit>
        <trans-unit id="adbe5a11f97bd4b5e64b0376fe039de97b1d60ba" translate="yes" xml:space="preserve">
          <source>-- K</source>
          <target state="translated">-K</target>
        </trans-unit>
        <trans-unit id="287ce060e435fae54470fb36aa477b9eac3600b8" translate="yes" xml:space="preserve">
          <source>-- L</source>
          <target state="translated">-L</target>
        </trans-unit>
        <trans-unit id="e0b1c441ef66810390e7262bf40ea39315e08b67" translate="yes" xml:space="preserve">
          <source>-- M</source>
          <target state="translated">-- 미디엄</target>
        </trans-unit>
        <trans-unit id="f67163d33a828b2aa831c72267389325d7d6d062" translate="yes" xml:space="preserve">
          <source>-- N</source>
          <target state="translated">-N</target>
        </trans-unit>
        <trans-unit id="790fcf9d53cd3b5c5847f118522955d9df7506b8" translate="yes" xml:space="preserve">
          <source>-- O</source>
          <target state="translated">-오</target>
        </trans-unit>
        <trans-unit id="7b3cbe2efc6cebcc91c4bbe7d09784895cf0a43d" translate="yes" xml:space="preserve">
          <source>-- P</source>
          <target state="translated">-P</target>
        </trans-unit>
        <trans-unit id="302638a98248ac94f4c782d4909cf72a029e7b5f" translate="yes" xml:space="preserve">
          <source>-- Q</source>
          <target state="translated">-Q</target>
        </trans-unit>
        <trans-unit id="d02abae9f95aa2adad1b4af30b014bb78e484da7" translate="yes" xml:space="preserve">
          <source>-- R</source>
          <target state="translated">-R</target>
        </trans-unit>
        <trans-unit id="b3d986b0e790a5a9f97b50ae3a08fd4b59e5dc81" translate="yes" xml:space="preserve">
          <source>-- S</source>
          <target state="translated">-S</target>
        </trans-unit>
        <trans-unit id="75b916182ff38c15d1aef40cd272d5e6280eee0d" translate="yes" xml:space="preserve">
          <source>-- T</source>
          <target state="translated">-T</target>
        </trans-unit>
        <trans-unit id="083005d0b826fb6b574352c1135906b86ad4e037" translate="yes" xml:space="preserve">
          <source>-- U</source>
          <target state="translated">-U</target>
        </trans-unit>
        <trans-unit id="7c676a83d68f6524185b0eabe9a87e3f26dd221b" translate="yes" xml:space="preserve">
          <source>-- V, W, X, Y, Z</source>
          <target state="translated">-V, W, X, Y, Z</target>
        </trans-unit>
        <trans-unit id="c64e9a434c40338f3ad302302cd44198e0c430bb" translate="yes" xml:space="preserve">
          <source>--blockPadding or -p Sets whether the HDFS blocks are padded to prevent stripes from straddling blocks. Default is true.</source>
          <target state="translated">--blockPadding 또는 -p 스트라이프가 블록을 넘어 가지 않도록 HDFS 블록을 채울지 여부를 설정합니다. 기본값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="5744a2eaa1353d9fab34212994410800eec8f1fe" translate="yes" xml:space="preserve">
          <source>--bufferSize or -b Set the size of the memory buffers used for compressing and storing the stripe in memory. Default is 262144 (256K).</source>
          <target state="translated">--bufferSize 또는 -b 메모리에 스트라이프를 압축하고 저장하는 데 사용되는 메모리 버퍼의 크기를 설정합니다. 기본값은 262144 (256K)입니다.</target>
        </trans-unit>
        <trans-unit id="ef43851e4cabc5b6e092aa3945d0c3201f601039" translate="yes" xml:space="preserve">
          <source>--compress or -c Sets the generic compression that is used to compress the data. Valid codecs are: NONE, ZLIB, SNAPPY, LZO. Default is ZLIB.</source>
          <target state="translated">--compress 또는 -c 데이터를 압축하는 데 사용되는 일반 압축을 설정합니다. 유효한 코덱은 NONE, ZLIB, SNAPPY, LZO입니다. 기본값은 ZLIB입니다.</target>
        </trans-unit>
        <trans-unit id="94ff914633724c687b4980632ab042cf69ca3ee2" translate="yes" xml:space="preserve">
          <source>--rowIndexStride or -r Set the distance between entries in the row index. Default is 10000.</source>
          <target state="translated">--rowIndexStride 또는 -r 행 인덱스의 항목 간 거리를 설정합니다. 기본값은 10000입니다.</target>
        </trans-unit>
        <trans-unit id="c9fe994cc59cef5c2d9f8f78dfdcc0cccf25c82e" translate="yes" xml:space="preserve">
          <source>--stripeSize or -s Set the stripe size for the file. Default is 268435456(256 MB).</source>
          <target state="translated">--stripeSize 또는 -s 파일의 스트라이프 크기를 설정합니다. 기본값은 268435456 (256MB)입니다.</target>
        </trans-unit>
        <trans-unit id="391d38c95d43ffe3981b0b8579556319cbd270a6" translate="yes" xml:space="preserve">
          <source>--version or -v Sets the version of the file that will be written</source>
          <target state="translated">--version 또는 -v 쓸 파일의 버전을 설정합니다</target>
        </trans-unit>
        <trans-unit id="0138c87e8acdcbde843ff9f154dc418938ce1d03" translate="yes" xml:space="preserve">
          <source>-2.0</source>
          <target state="translated">-2.0</target>
        </trans-unit>
        <trans-unit id="fb577e8696531b61725340924385bb06e7beb102" translate="yes" xml:space="preserve">
          <source>-2.5</source>
          <target state="translated">-2.5</target>
        </trans-unit>
        <trans-unit id="d2c2a7e0e223546832dc13ef80bdeb56ddbd8109" translate="yes" xml:space="preserve">
          <source>-3.0</source>
          <target state="translated">-3.0</target>
        </trans-unit>
        <trans-unit id="95c5182f6f2c251672072292284f7f3d6d521ef4" translate="yes" xml:space="preserve">
          <source>-3.15</source>
          <target state="translated">-3.15</target>
        </trans-unit>
        <trans-unit id="1e0c9478f3b2635e10bd8ac468c92d72bfab8840" translate="yes" xml:space="preserve">
          <source>-3.2</source>
          <target state="translated">-3.2</target>
        </trans-unit>
        <trans-unit id="45b8a6840bb8afc51af4722ac4f6478c14ead1b6" translate="yes" xml:space="preserve">
          <source>-3.25</source>
          <target state="translated">-3.25</target>
        </trans-unit>
        <trans-unit id="03619b00f2bd2736ab8b5bf4c5113f9529ffd538" translate="yes" xml:space="preserve">
          <source>-3.3</source>
          <target state="translated">-3.3</target>
        </trans-unit>
        <trans-unit id="d21c8da96d025738b6599ae52debd5f3ab89d93f" translate="yes" xml:space="preserve">
          <source>-3.5</source>
          <target state="translated">-3.5</target>
        </trans-unit>
        <trans-unit id="867216daf8b64b72e4fbd6d417049af17f3bb2eb" translate="yes" xml:space="preserve">
          <source>-4.0</source>
          <target state="translated">-4.0</target>
        </trans-unit>
        <trans-unit id="c246d2ec063ba7a8f15a5647390d54600709321b" translate="yes" xml:space="preserve">
          <source>-allowrecursive or -r Specify whether to allow recursive schema definitions (the default is to throw an exception if Pig encounters a recursive schema). When reading objects with recursive definitions, Pig will translate Avro records to schema-less tuples; the Pig Schema for the object may not match the data exactly.</source>
          <target state="translated">-allowrecursive 또는 -r 재귀 스키마 정의를 허용할지 여부를 지정합니다 (기본적으로 Pig에 재귀 스키마가 있으면 예외가 발생 함). 재귀 정의가있는 개체를 읽을 때 Pig는 Avro 레코드를 스키마가없는 튜플로 변환합니다. 개체의 돼지 스키마가 데이터와 정확히 일치하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bac9f5e661479ffc42be73be3c2ad86f9415f0de" translate="yes" xml:space="preserve">
          <source>-caching=numRows Number of rows to cache (faster scans, more memory)</source>
          <target state="translated">-caching = numRows 캐시 할 행 수 (빠른 스캔, 더 많은 메모리)</target>
        </trans-unit>
        <trans-unit id="839aae606e2ee9a0217e95b460866360542b6a52" translate="yes" xml:space="preserve">
          <source>-caster=(HBaseBinaryConverter|Utf8StorageConverter) Class name of Caster to use to convert values (default=Utf8StorageConverter). The default caster can be overridden with the pig.hbase.caster config param. Casters must implement LoadStoreCaster.</source>
          <target state="translated">-caster = (HBaseBinaryConverter | Utf8StorageConverter) 값을 변환하는 데 사용할 캐스터의 클래스 이름 (기본값 = Utf8StorageConverter). 기본 캐스터는 pig.hbase.caster config 매개 변수로 재정의 할 수 있습니다. 캐스터는 LoadStoreCaster를 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="c70a084bd786ca9d8790715a53eeda7454e77fc8" translate="yes" xml:space="preserve">
          <source>-debug</source>
          <target state="translated">-debug</target>
        </trans-unit>
        <trans-unit id="d3a3fe690834323f65f02ab61d261211145c5b14" translate="yes" xml:space="preserve">
          <source>-delim=delimiter Column delimiter in columns list (default is whitespace)</source>
          <target state="translated">-delim = delimiter 열 목록의 열 구분 기호 (기본값은 공백)</target>
        </trans-unit>
        <trans-unit id="199bf7c2c523e991afced8c6af4397701a77a93d" translate="yes" xml:space="preserve">
          <source>-doublecolons or -d Specify how to handle Pig schemas that contain double-colons when writing data in Avro format. (When you join two bags in Pig, Pig will automatically label the fields in the output Tuples with names that contain double-colons). If you select this option, AvroStorage will translate names with double colons into names with double underscores.</source>
          <target state="translated">-doublecolons 또는 -d Avro 형식으로 데이터를 쓸 때 이중 콜론이 포함 된 Pig 스키마를 처리하는 방법을 지정하십시오. Pig에서 두 개의 백을 결합하면 Pig는 출력 튜플의 필드에 이중 콜론이 포함 된 이름으로 자동 레이블을 지정합니다. 이 옵션을 선택하면 AvroStorage는 이중 콜론이있는 이름을 이중 밑줄이있는 이름으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="0948a01132cf9925f1b7f201a6b5ac2554068690" translate="yes" xml:space="preserve">
          <source>-dryrun</source>
          <target state="translated">-dryrun</target>
        </trans-unit>
        <trans-unit id="fad314515c14be88faa7ae060a5e73c1321d9cce" translate="yes" xml:space="preserve">
          <source>-examplefile exampleFile or -e exampleFile Specify the input (or output) schema using another Avro file as an example. Pig assumes that the file is located on the default filesystem, but you may use and explicity URL to specify the location. Pig expects this to be an Avro data file.</source>
          <target state="translated">-examplefile exampleFile 또는 -e exampleFile 다른 Avro 파일을 예로 사용하여 입력 (또는 출력) 스키마를 지정하십시오. Pig는 파일이 기본 파일 시스템에 있다고 가정하지만 URL을 명시 적으로 사용하여 위치를 지정할 수 있습니다. Pig는이 파일이 Avro 데이터 파일 일 것으로 예상합니다.</target>
        </trans-unit>
        <trans-unit id="20c9a30a1e6c6730e825c4ff2ed853a6380fb6e3" translate="yes" xml:space="preserve">
          <source>-gt=minKeyVal Return rows with a rowKey greater than minKeyVal</source>
          <target state="translated">-gt = minKeyVal minKeyVal보다 큰 rowKey를 가진 행을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="cd85475b2c2f1ec4e37452eed716e76b77e9140b" translate="yes" xml:space="preserve">
          <source>-gte=minKeyVal Return rows with a rowKey greater than or equal to minKeyVal</source>
          <target state="translated">-gte = minKeyVal minKeyVal보다 크거나 같은 rowKey를 가진 행을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="90c09c139af87c2a49d69974602eae3db88d9b68" translate="yes" xml:space="preserve">
          <source>-help [properties]</source>
          <target state="translated">-help [속성]</target>
        </trans-unit>
        <trans-unit id="85fdf11feb9b9dcd8e9d7514f0e9b7bd8e9b5ba4" translate="yes" xml:space="preserve">
          <source>-ignoreWhitespace=(true|false) When delim is set to something other than whitespace, ignore spaces when parsing column list (default=true)</source>
          <target state="translated">-ignoreWhitespace = (true | false) delim이 공백 이외의 값으로 설정된 경우 열 목록을 구문 분석 할 때 공백을 무시하십시오 (기본값 = true).</target>
        </trans-unit>
        <trans-unit id="1e4f7a57a90c618a6e6239c230622d9df62402a5" translate="yes" xml:space="preserve">
          <source>-includeTimestamp=Record will include the timestamp after the rowkey on store (rowkey, timestamp, ...)</source>
          <target state="translated">-includeTimestamp = 기록은 상점에서 행키 이후의 타임 스탬프를 포함합니다 (rowkey, timestamp, ...)</target>
        </trans-unit>
        <trans-unit id="9980a7079250ae9969134cf554cd89f97988f19c" translate="yes" xml:space="preserve">
          <source>-includeTombstone=Record will include a tombstone marker on store after the rowKey and timestamp (if included) (rowkey, [timestamp,] tombstone, ...)</source>
          <target state="translated">-includeTombstone = 기록에는 rowKey 및 타임 스탬프 (포함 된 경우) (행키, [타임 스탬프,] 툼 스톤, ...) 이후에 툼 스톤 마커가 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="a4f6c2d3d295fa9ff1afc24c47326d0dc2c822ca" translate="yes" xml:space="preserve">
          <source>-limit=numRowsPerRegion Max number of rows to retrieve per region</source>
          <target state="translated">-limit = numRowsPerRegion 리 전당 검색 할 최대 행 수</target>
        </trans-unit>
        <trans-unit id="419026f260451118ea2b2c02d11eacc9ccd30b64" translate="yes" xml:space="preserve">
          <source>-loadKey=(true|false) Load the row key as the first value in every tuple returned from HBase (default=false)</source>
          <target state="translated">-loadKey = (true | false) HBase에서 반환 된 모든 튜플에서 첫 번째 값으로 행 키를로드합니다 (기본값 = false).</target>
        </trans-unit>
        <trans-unit id="3ddebb4c27f3d11f8daa7a4f184015a06cfa9af7" translate="yes" xml:space="preserve">
          <source>-lt=maxKeyVal Return rows with a rowKey less than maxKeyVal</source>
          <target state="translated">-lt = maxKeyVal maxKeyVal보다 적은 rowKey를 가진 행을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="2323271e0b70309b823a9b7771477870ccfd98a9" translate="yes" xml:space="preserve">
          <source>-lte=maxKeyVal Return rows with a rowKey less than or equal to maxKeyVal</source>
          <target state="translated">-lte = maxKeyVal rowKey가 maxKeyVal보다 작거나 같은 행을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="1b9ee341031d5a1c01542913be07f7f8e02c56db" translate="yes" xml:space="preserve">
          <source>-maxTimestamp=timestamp Return cell values that have a creation timestamp less than this value</source>
          <target state="translated">-maxTimestamp = timestamp 작성 시간 소인이이 값보다 작은 셀 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="710cec49eff8e7d5b744a055ac18eb502f32c8e9" translate="yes" xml:space="preserve">
          <source>-minTimestamp=timestamp Return cell values that have a creation timestamp greater or equal to this value</source>
          <target state="translated">-minTimestamp = timestamp 작성 시간 소인이이 값보다 크거나 같은 셀 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="d868a680affb6ad2c7e2392566b6adc4e3201dea" translate="yes" xml:space="preserve">
          <source>-n</source>
          <target state="translated">-n</target>
        </trans-unit>
        <trans-unit id="fd011dafc765fe0d74fc65335c1654bb9d2c3d3b" translate="yes" xml:space="preserve">
          <source>-namespace nameSpace or -n nameSpace Explicitly specify the namespace field in Avro records when storing data</source>
          <target state="translated">-namespace nameSpace 또는 -n nameSpace 데이터를 저장할 때 Avro 레코드에서 네임 스페이스 필드를 명시 적으로 지정</target>
        </trans-unit>
        <trans-unit id="b9295cf706309698be946ae2d91e966e00bc48b3" translate="yes" xml:space="preserve">
          <source>-noWAL=(true|false) During storage, sets the write ahead to false for faster loading into HBase (default=false). To be used with extreme caution since this could result in data loss (see &lt;a href=&quot;http://hbase.apache.org/book.html#perf.hbase.client.putwal&quot;&gt;http://hbase.apache.org/book.html#perf.hbase.client.putwal&lt;/a&gt;).</source>
          <target state="translated">-noWAL = (true | false) 저장하는 동안 HBase 로의 빠른로드를 위해 미리 쓰기를 false로 설정합니다 (기본값 = false). 데이터 손실이 발생할 수 있으므로 매우주의해서 사용해야합니다 ( &lt;a href=&quot;http://hbase.apache.org/book.html#perf.hbase.client.putwal&quot;&gt;http://hbase.apache.org/book.html#perf.hbase.client.putwal&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="f7e9f682ef8a69f0435c3115a8ea218e89d42ac0" translate="yes" xml:space="preserve">
          <source>-noWAL=(true|false) During storage, sets the write ahead to false for faster loading into HBase (default=false). To be used with extreme caution since this could result in data loss (see &lt;a href=&quot;https://hbase.apache.org/book.html#perf.hbase.client.putwal&quot;&gt;http://hbase.apache.org/book.html#perf.hbase.client.putwal&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="231bd674f37d8ab04044a0c65bae81d8902cb597" translate="yes" xml:space="preserve">
          <source>-param</source>
          <target state="translated">-param</target>
        </trans-unit>
        <trans-unit id="7473d28f54e1185c9fa4707704c85e16d5146571" translate="yes" xml:space="preserve">
          <source>-param_file</source>
          <target state="translated">-param_file</target>
        </trans-unit>
        <trans-unit id="820d82cd308bf40eb8cafd0ba4fd85f75ca0a643" translate="yes" xml:space="preserve">
          <source>-regex=regex Return rows with a rowKey that match this regex on KeyVal</source>
          <target state="translated">-regex = regex KeyVal에서이 정규식과 일치하는 rowKey로 행을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="aec97a5f7305955fe079e3eaca1d93e69507f9df" translate="yes" xml:space="preserve">
          <source>-schemfile schemaFile or -f schemaFile Specify the input (or output) schema from an external file. Pig assumes that the file is located on the default filesystem, but you may use an explicity URL to unambigously specify the location. (For example, if the data was on your local file system in /stuff/schemafile.avsc, you could specify &quot;-f file:///stuff/schemafile.avsc&quot; to specify the location. If the data was on HDFS under /yourdirectory/schemafile.avsc, you could specify &quot;-f hdfs:///yourdirectory/schemafile.avsc&quot;). Pig expects this to be a text file, containing a valid avro schema.</source>
          <target state="translated">-schemfile schemaFile 또는 -f schemaFile 외부 파일에서 입력 (또는 출력) 스키마를 지정하십시오. Pig는 파일이 기본 파일 시스템에 있다고 가정하지만 명시 적 URL을 사용하여 위치를 명확하게 지정할 수 있습니다. 예를 들어, 데이터가 /stuff/schemafile.avsc의 로컬 파일 시스템에있는 경우 &quot;-f file : ///stuff/schemafile.avsc&quot;를 지정하여 위치를 지정할 수 있습니다. 데이터가 HDFS 아래에있는 경우 /yourdirectory/schemafile.avsc, &quot;-f hdfs : ///yourdirectory/schemafile.avsc&quot;를 지정할 수 있습니다. Pig는이 파일이 유효한 avro 스키마를 포함하는 텍스트 파일 일 것으로 예상합니다.</target>
        </trans-unit>
        <trans-unit id="0b6d819cc70da4faf844071ff7af4c9c0723d162" translate="yes" xml:space="preserve">
          <source>-script scriptfile</source>
          <target state="translated">-스크립트 스크립트 파일</target>
        </trans-unit>
        <trans-unit id="e5f7a92036c8a3ad4475cba98efe18a5589a0247" translate="yes" xml:space="preserve">
          <source>-timestamp=timestamp Return cell values that have a creation timestamp equal to this value</source>
          <target state="translated">-timestamp = timestamp 작성 시간 소인이이 값과 동일한 셀 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="ee20aa4ecb0e90f8ba9a91b411c65793672fc3c0" translate="yes" xml:space="preserve">
          <source>.. $x : projects columns $0 through $x, inclusive</source>
          <target state="translated">.. $ x : $ 0부터 $ x까지의 열을 프로젝트</target>
        </trans-unit>
        <trans-unit id="41d1ba36b140ecc878b816d33170613eccc5816c" translate="yes" xml:space="preserve">
          <source>... Pig creates a tuple ($1, $2) and then puts this tuple into the bag</source>
          <target state="translated">... 돼지는 튜플 ($ 1, $ 2)을 만든 다음이 튜플을 가방에 넣습니다.</target>
        </trans-unit>
        <trans-unit id="d9177d1c9a8d4964015a0455cdc508b79ebe8761" translate="yes" xml:space="preserve">
          <source>... neither $1 and $2 are tuples so Pig creates a tuple around each item</source>
          <target state="translated">... $ 1과 $ 2도 튜플이 아니므로 Pig는 각 항목 주위에 튜플을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="40df7953771030769555bdbd81ed4d0564e943c1" translate="yes" xml:space="preserve">
          <source>... since ($1) is treated as $1 (one cannot create a single element tuple using this syntax), {($1), $2} becomes {$1, $2} and Pig creates a tuple around each item</source>
          <target state="translated">... ($ 1)은 $ 1 (이 구문을 사용하여 단일 요소 튜플을 만들 수 없음)로 취급되므로 {($ 1), $ 2}는 {$ 1, $ 2}가되고 Pig는 각 항목 주위에 튜플을 만듭니다</target>
        </trans-unit>
        <trans-unit id="b6589fc6ab0dc82cf12099d1c2d40ab994e8410c" translate="yes" xml:space="preserve">
          <source>0</source>
          <target state="translated">0</target>
        </trans-unit>
        <trans-unit id="38f6d7875e3195bdaee448d2cb6917f3ae4994af" translate="yes" xml:space="preserve">
          <source>0.0</source>
          <target state="translated">0.0</target>
        </trans-unit>
        <trans-unit id="356a192b7913b04c54574d18c28d46e6395428ab" translate="yes" xml:space="preserve">
          <source>1</source>
          <target state="translated">1</target>
        </trans-unit>
        <trans-unit id="f26d9720d0fb719979033c168b54424bbf69918e" translate="yes" xml:space="preserve">
          <source>1. -param</source>
          <target state="translated">1.-매개 변수</target>
        </trans-unit>
        <trans-unit id="48e1c024e47628701999b91e4327d4f495beeb29" translate="yes" xml:space="preserve">
          <source>1000.0</source>
          <target state="translated">1000.0</target>
        </trans-unit>
        <trans-unit id="893bc661e230cfb64b023bb42fb260e811bc6166" translate="yes" xml:space="preserve">
          <source>1230.0</source>
          <target state="translated">1230.0</target>
        </trans-unit>
        <trans-unit id="8262e563b147758c8485a9a15d23ce517ce3c0c4" translate="yes" xml:space="preserve">
          <source>1234.0</source>
          <target state="translated">1234.0</target>
        </trans-unit>
        <trans-unit id="b8598263c20e15f2c6d48a168311717bd1db15eb" translate="yes" xml:space="preserve">
          <source>1234.1789</source>
          <target state="translated">1234.1789</target>
        </trans-unit>
        <trans-unit id="d7667ba5fd3fe586d72df421ece9d8613e2014a2" translate="yes" xml:space="preserve">
          <source>1234.2</source>
          <target state="translated">1234.2</target>
        </trans-unit>
        <trans-unit id="20eabe5d64b0e216796e834f52d61fd0b70332fc" translate="yes" xml:space="preserve">
          <source>1234567</source>
          <target state="translated">1234567</target>
        </trans-unit>
        <trans-unit id="ce08f6ab01f7f2bf601e384cfb46c0063b033c1a" translate="yes" xml:space="preserve">
          <source>19.2 or 1.92e2</source>
          <target state="translated">19.2 또는 1.92e2</target>
        </trans-unit>
        <trans-unit id="d0f14539074951ba456c79df8ad5527383304ca9" translate="yes" xml:space="preserve">
          <source>19.2F or 1.92e2f</source>
          <target state="translated">19.2F 또는 1.92e2f</target>
        </trans-unit>
        <trans-unit id="fa8b83f97eeb1d2618c3bbda47d7e1a61f33dad6" translate="yes" xml:space="preserve">
          <source>192119211921.192119211921BD</source>
          <target state="translated">192119211921.192119211921BD</target>
        </trans-unit>
        <trans-unit id="9d81c25c39b323588b34d0f5e23dc8b05f5af240" translate="yes" xml:space="preserve">
          <source>19211921192119211921BI</source>
          <target state="translated">19211921192119211921BI</target>
        </trans-unit>
        <trans-unit id="e2c24431f4463ab2663692b03ef706ff634893dc" translate="yes" xml:space="preserve">
          <source>1970-01-01T00:00:00.000+00:00</source>
          <target state="translated">1970-01-01T00:00:00.000+00:00</target>
        </trans-unit>
        <trans-unit id="986a7d02f1099dd6aedb70535f087050629d816d" translate="yes" xml:space="preserve">
          <source>19L</source>
          <target state="translated">19L</target>
        </trans-unit>
        <trans-unit id="c97f62de1ba14379f6f017f3dfcbf16fb199d041" translate="yes" xml:space="preserve">
          <source>1|2|3</source>
          <target state="translated">1|2|3</target>
        </trans-unit>
        <trans-unit id="da4b9237bacccdf19c0760cab7aec4a8359010b0" translate="yes" xml:space="preserve">
          <source>2</source>
          <target state="translated">2</target>
        </trans-unit>
        <trans-unit id="e5cd17daae9115cebaf9dc5c99f510b9aa69c7fa" translate="yes" xml:space="preserve">
          <source>2. Command line arguments</source>
          <target state="translated">2. 명령 줄 인수</target>
        </trans-unit>
        <trans-unit id="70142f66475ae2fb33722d8d4750f386ecfefe7b" translate="yes" xml:space="preserve">
          <source>2.0</source>
          <target state="translated">2.0</target>
        </trans-unit>
        <trans-unit id="98a16af997b52cb888232ab5d79a527b0716561c" translate="yes" xml:space="preserve">
          <source>2.4</source>
          <target state="translated">2.4</target>
        </trans-unit>
        <trans-unit id="555a5c5c92b230dccab828d90e89ec66847ab9ce" translate="yes" xml:space="preserve">
          <source>2.5</source>
          <target state="translated">2.5</target>
        </trans-unit>
        <trans-unit id="77de68daecd823babbb58edb1c8e14d7106e83bb" translate="yes" xml:space="preserve">
          <source>3</source>
          <target state="translated">3</target>
        </trans-unit>
        <trans-unit id="bdc1408a91f161dab5a9893d23db3c7095200e1d" translate="yes" xml:space="preserve">
          <source>3.0</source>
          <target state="translated">3.0</target>
        </trans-unit>
        <trans-unit id="a15b1600fed3b04089da4599ba8c2833b5ec7b34" translate="yes" xml:space="preserve">
          <source>3.15</source>
          <target state="translated">3.15</target>
        </trans-unit>
        <trans-unit id="47ffd93865bc60f6431831db2605565dffbb7509" translate="yes" xml:space="preserve">
          <source>3.2</source>
          <target state="translated">3.2</target>
        </trans-unit>
        <trans-unit id="9ca8ee65a3fa3737f6b3f5b0c6055c0e09305294" translate="yes" xml:space="preserve">
          <source>3.25</source>
          <target state="translated">3.25</target>
        </trans-unit>
        <trans-unit id="16205b65128506db2f6e2208c73beef8b29cb850" translate="yes" xml:space="preserve">
          <source>3.25000001</source>
          <target state="translated">3.25000001</target>
        </trans-unit>
        <trans-unit id="a9c68c54449dd45e3ffc6d16d2e2e55125c2895d" translate="yes" xml:space="preserve">
          <source>3.3</source>
          <target state="translated">3.3</target>
        </trans-unit>
        <trans-unit id="c3e66c166813c6ccb5819daf234787040c248650" translate="yes" xml:space="preserve">
          <source>3.5</source>
          <target state="translated">3.5</target>
        </trans-unit>
        <trans-unit id="ae668bebc086179c8fc19ca0dce26efb2d1d55d6" translate="yes" xml:space="preserve">
          <source>32-bit floating point</source>
          <target state="translated">32 비트 부동 소수점</target>
        </trans-unit>
        <trans-unit id="1b6453892473a467d07372d45eb05abc2031647a" translate="yes" xml:space="preserve">
          <source>4</source>
          <target state="translated">4</target>
        </trans-unit>
        <trans-unit id="a33beb1398d687ce56ea092654850e76f54bebb2" translate="yes" xml:space="preserve">
          <source>4.0</source>
          <target state="translated">4.0</target>
        </trans-unit>
        <trans-unit id="31918ec11813e2a958c673c0624094b8c07c76a0" translate="yes" xml:space="preserve">
          <source>4.6</source>
          <target state="translated">4.6</target>
        </trans-unit>
        <trans-unit id="ac3478d69a3c81fa62e60f5c3696165a4e5e6ac4" translate="yes" xml:space="preserve">
          <source>5</source>
          <target state="translated">5</target>
        </trans-unit>
        <trans-unit id="6879ad37f6917f2009f6728dcba67536db7896ad" translate="yes" xml:space="preserve">
          <source>64-bit floating point</source>
          <target state="translated">64 비트 부동 소수점</target>
        </trans-unit>
        <trans-unit id="fe5dbbcea5ce7e2988b8c69bcfdfde8904aabc1f" translate="yes" xml:space="preserve">
          <source>8</source>
          <target state="translated">8</target>
        </trans-unit>
        <trans-unit id="5afd1f791a768e4fdea29f369a3db8f38dd4c8d4" translate="yes" xml:space="preserve">
          <source>:bag</source>
          <target state="translated">:bag</target>
        </trans-unit>
        <trans-unit id="48fd59ec20fdacc3564cab3e69bb0504ec3b2302" translate="yes" xml:space="preserve">
          <source>:map</source>
          <target state="translated">:map</target>
        </trans-unit>
        <trans-unit id="c342e4a1441ee29f7845f390860aeebaa42d9a78" translate="yes" xml:space="preserve">
          <source>:tuple</source>
          <target state="translated">:tuple</target>
        </trans-unit>
        <trans-unit id="a8875b70e6bbb54376004a032f59164d51cae5f2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;basic#bag&quot;&gt;Bag&lt;/a&gt;: enclosed by {}, tuples separated by &quot;,&quot;</source>
          <target state="translated">&lt;a href=&quot;basic#bag&quot;&gt;백&lt;/a&gt; : {}로 묶고 튜플은 &quot;,&quot;으로 구분</target>
        </trans-unit>
        <trans-unit id="9134796c39798e19db424cd1171ca37a96627a52" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;basic#map&quot;&gt;Map&lt;/a&gt;: enclosed by [], items separated by &quot;,&quot;, key and value separated by &quot;#&quot;</source>
          <target state="translated">&lt;a href=&quot;basic#map&quot;&gt;지도&lt;/a&gt; : []로 묶고 &quot;,&quot;로 구분 된 항목, &quot;#&quot;으로 구분 된 키 및 값</target>
        </trans-unit>
        <trans-unit id="d196009f178d92dceb03c39e0bce2d88f19e26c9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;basic#tuple&quot;&gt;Tuple&lt;/a&gt;: enclosed by (), items separated by &quot;,&quot;</source>
          <target state="translated">&lt;a href=&quot;basic#tuple&quot;&gt;튜플&lt;/a&gt; : ()로 묶고 &quot;,&quot;로 구분 된 항목</target>
        </trans-unit>
        <trans-unit id="0d7be44f289c7455584e1a52b664cfaa1ccf2403" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/ErrorHandling.java?view=markup&quot;&gt;ErrorHandling:&lt;/a&gt; This interface allow you to skip bad records in the storer so the storer will not throw exception and terminate the job. You can implement your own error handler by overriding &lt;a href=&quot;http://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/ErrorHandler.java?view=markup&quot;&gt;ErrorHandler&lt;/a&gt; interface, or use predefined error handler: &lt;a href=&quot;http://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/CounterBasedErrorHandler.java?view=markup&quot;&gt;CounterBasedErrorHandler&lt;/a&gt;. ErrorHandling can be turned on by setting the property pig.error-handling.enabled to true in pig.properties. Default is false. CounterBasedErrorHandler uses two settings - pig.error-handling.min.error.records (the minimum number of errors to trigger error handling) and pig.error-handling.error.threshold (percentage of the number of records as a fraction exceeding which error is thrown).</source>
          <target state="translated">&lt;a href=&quot;http://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/ErrorHandling.java?view=markup&quot;&gt;ErrorHandling :&lt;/a&gt; 이 인터페이스를 사용하면 저장 자의 잘못된 레코드를 건너 뛸 수 있으므로 저장자가 예외를 처리하지 않고 작업을 종료하지 않습니다. &lt;a href=&quot;http://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/ErrorHandler.java?view=markup&quot;&gt;ErrorHandler&lt;/a&gt; 인터페이스 를 재정 의하여 고유 한 오류 처리기를 구현 하거나 미리 정의 된 오류 처리기 : &lt;a href=&quot;http://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/CounterBasedErrorHandler.java?view=markup&quot;&gt;CounterBasedErrorHandler를 사용할 수&lt;/a&gt; 있습니다. pig.properties에서 pig.error-handling.enabled 특성을 true로 설정하여 ErrorHandling을 설정할 수 있습니다. 기본값은 false입니다. CounterBasedErrorHandler는 두 가지 설정, 즉 pig.error-handling.min.error.records (오류 처리를 트리거하기위한 최소 오류 수)와 pig.error-handling.error.threshold (오류 수를 초과하는 분수로서의 레코드 수 백분율)를 사용합니다. 던져집니다).</target>
        </trans-unit>
        <trans-unit id="1c39d40a8e650c2ef284f5a3849e62072bfdae2c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/LoadCaster.java?view=markup&quot;&gt;LoadCaster&lt;/a&gt; has methods to convert byte arrays to specific types. A loader implementation should implement this if casts (implicit or explicit) from DataByteArray fields to other types need to be supported.</source>
          <target state="translated">&lt;a href=&quot;http://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/LoadCaster.java?view=markup&quot;&gt;LoadCaster&lt;/a&gt; 에는 바이트 배열을 특정 유형으로 변환하는 메소드가 있습니다. DataByteArray 필드에서 다른 유형으로 캐스트 (암시 적 또는 명시 적)를 지원해야하는 경우 로더 구현에서이를 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="827aa31ae7b3b8158edd560d739d5f474d89c18f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/LoadFunc.java?view=markup&quot;&gt;LoadFunc&lt;/a&gt; abstract class has three main methods for loading data and for most use cases it would suffice to extend it. There are three other optional interfaces which can be implemented to achieve extended functionality:</source>
          <target state="translated">&lt;a href=&quot;http://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/LoadFunc.java?view=markup&quot;&gt;LoadFunc&lt;/a&gt; 추상 클래스에는 데이터를로드하기위한 세 가지 주요 메소드가 있으며 대부분의 경우 데이터를 확장하는 것으로 충분합니다. 확장 된 기능을 달성하기 위해 구현할 수있는 다른 세 가지 선택적 인터페이스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9bfcbd0993bbe599b0d0ce3ec1e775bd94b5ec73" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/LoadMetadata.java?view=markup&quot;&gt;LoadMetadata&lt;/a&gt; has methods to deal with metadata - most implementation of loaders don't need to implement this unless they interact with some metadata system. The getSchema() method in this interface provides a way for loader implementations to communicate the schema of the data back to pig. If a loader implementation returns data comprised of fields of real types (rather than DataByteArray fields), it should provide the schema describing the data returned through the getSchema() method. The other methods are concerned with other types of metadata like partition keys and statistics. Implementations can return null return values for these methods if they are not applicable for that implementation.</source>
          <target state="translated">&lt;a href=&quot;http://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/LoadMetadata.java?view=markup&quot;&gt;LoadMetadata&lt;/a&gt; 에는 메타 데이터를 처리하는 방법이 있습니다. 대부분의 로더 구현은 일부 메타 데이터 시스템과 상호 작용하지 않는 한이를 구현할 필요가 없습니다. 이 인터페이스의 getSchema () 메소드는 로더 구현이 데이터의 스키마를 pig와 다시 통신 할 수있는 방법을 제공합니다. 로더 구현이 DataByteArray 필드가 아닌 실제 유형의 필드로 구성된 데이터를 리턴하는 경우 getSchema () 메소드를 통해 리턴 된 데이터를 설명하는 스키마를 제공해야합니다. 다른 방법은 파티션 키 및 통계와 같은 다른 유형의 메타 데이터와 관련이 있습니다. 구현은 해당 구현에 적용 할 수없는 경우 이러한 메소드에 대해 널 리턴 값을 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="743f80c577129dc8081c6750911c5114a027a6d8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/LoadPredicatePushdown.java?view=markup&quot;&gt;LoadPredicatePushdown&lt;/a&gt; has the methods to push predicates to the loader. It is different than LoadMetadata.setPartitionFilter in that loader may load records which does not satisfy the predicates. In other words, predicates is only a hint. Note this interface is still in development and might change in next version. Currently only OrcStorage implements this interface.</source>
          <target state="translated">&lt;a href=&quot;http://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/LoadPredicatePushdown.java?view=markup&quot;&gt;LoadPredicatePushdown&lt;/a&gt; 에는 술어를 로더로 푸시하는 메소드가 있습니다. 로더가 술어를 만족시키지 않는 레코드를로드 할 수 있다는 점에서 LoadMetadata.setPartitionFilter와 다릅니다. 즉, 술어는 힌트 일뿐입니다. 이 인터페이스는 아직 개발 중이며 다음 버전에서 변경 될 수 있습니다. 현재 OrcStorage 만이 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="c00bdd7fc969477665da1fe9c64c49b8d34bdee3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/LoadPushDown.java?view=markup&quot;&gt;LoadPushDown&lt;/a&gt; has methods to push operations from Pig runtime into loader implementations. Currently only the pushProjection() method is called by Pig to communicate to the loader the exact fields that are required in the Pig script. The loader implementation can choose to honor the request (return only those fields required by Pig script) or not honor the request (return all fields in the data). If the loader implementation can efficiently honor the request, it should implement LoadPushDown to improve query performance. (Irrespective of whether the implementation can or cannot honor the request, if the implementation also implements getSchema(), the schema returned in getSchema() should describe the entire tuple of data.)</source>
          <target state="translated">&lt;a href=&quot;http://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/LoadPushDown.java?view=markup&quot;&gt;LoadPushDown&lt;/a&gt; 에는 Pig 런타임에서 로더 구현으로 작업을 푸시하는 메소드가 있습니다. 현재 Pig는 pushProjection () 메소드 만 호출하여 Pig 스크립트에 필요한 정확한 필드를 로더와 통신합니다. 로더 구현은 요청을 처리하도록 (Pog 스크립트에 필요한 필드 만 리턴) 요청을 승인하지 않도록 (데이터의 모든 필드를 리턴) 선택할 수 있습니다. 로더 구현이 요청을 효율적으로 수행 할 수 있으면 쿼리 성능을 향상시키기 위해 LoadPushDown을 구현해야합니다. (구현이 요청을 받아 들일 수 있는지 여부와 상관없이, 구현이 getSchema ()를 구현하는 경우 getSchema ()에 반환 된 스키마는 전체 데이터 튜플을 설명해야합니다.)</target>
        </trans-unit>
        <trans-unit id="a0b17ad301eb67a444b5fcddda6189e3e22f5cea" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/NonFSLoadFunc.java?view=markup&quot;&gt;NonFSLoadFunc&lt;/a&gt; is a marker interface to indicate that a LoadFunc implementation is not a filesystem loader. This is useful for LoadFunc classes that for example supply queries instead of filesystem pathes to the LOAD operator.</source>
          <target state="translated">&lt;a href=&quot;http://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/NonFSLoadFunc.java?view=markup&quot;&gt;NonFSLoadFunc&lt;/a&gt; 는 LoadFunc 구현이 파일 시스템 로더가 아님을 나타내는 마커 인터페이스입니다. 이는 예를 들어 LOAD 연산자에 대한 파일 시스템 경로 대신 쿼리를 제공하는 LoadFunc 클래스에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="97f0015ba94eeba5c50c16183dd997c7e9bd4a62" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/StoreFunc.java?view=markup&quot;&gt;StoreFunc&lt;/a&gt; abstract class has the main methods for storing data and for most use cases it should suffice to extend it. There is an optional interface which can be implemented to achieve extended functionality:</source>
          <target state="translated">&lt;a href=&quot;http://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/StoreFunc.java?view=markup&quot;&gt;StoreFunc&lt;/a&gt; 추상 클래스에는 데이터를 저장하는 주요 메소드가 있으며 대부분의 경우 데이터를 확장하기에 충분합니다. 확장 된 기능을 달성하기 위해 구현할 수있는 선택적 인터페이스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9133eb98211fd7cfb43e4b1fd6f05bea741bcaa3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/StoreMetadata.java?view=markup&quot;&gt;StoreMetadata:&lt;/a&gt; This interface has methods to interact with metadata systems to store schema and store statistics. This interface is optional and should only be implemented if metadata needs to stored.</source>
          <target state="translated">&lt;a href=&quot;http://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/StoreMetadata.java?view=markup&quot;&gt;StoreMetadata :&lt;/a&gt; 이 인터페이스에는 메타 데이터 시스템과 상호 작용하여 스키마를 저장하고 통계를 저장하는 방법이 있습니다. 이 인터페이스는 선택 사항이며 메타 데이터를 저장해야하는 경우에만 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="f7a6ab9e59514abec0b48b13c7e18ea2dc4b473c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/StoreResources.java?view=markup&quot;&gt;StoreResources:&lt;/a&gt; This interface has methods to put hdfs files or local files to distributed cache.</source>
          <target state="translated">&lt;a href=&quot;http://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/StoreResources.java?view=markup&quot;&gt;StoreResources :&lt;/a&gt; 이 인터페이스에는 hdfs 파일 또는 로컬 파일을 분산 캐시에 저장하는 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8275001363f72a1cde8b1636f4b53d30fc2c1cb" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://tez.apache.org&quot;&gt;Apache Tez&lt;/a&gt; provides an alternative execution engine than MapReduce focusing on performance. By using optimized job flow, edge semantics and container reuse, we see consistent performance boost for both large job and small job.</source>
          <target state="translated">&lt;a href=&quot;http://tez.apache.org&quot;&gt;Apache Tez&lt;/a&gt; 는 성능에 중점을 둔 MapReduce보다 대체 실행 엔진을 제공합니다. 최적화 된 작업 흐름, 엣지 시맨틱 및 컨테이너 재사용을 사용하여 대규모 작업과 소규모 작업 모두에서 일관된 성능 향상을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d31c40f3fecd385e1da4cb57c1a547a7ea687e4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/ErrorHandling.java?view=markup&quot;&gt;ErrorHandling:&lt;/a&gt; This interface allow you to skip bad records in the storer so the storer will not throw exception and terminate the job. You can implement your own error handler by overriding &lt;a href=&quot;https://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/ErrorHandler.java?view=markup&quot;&gt;ErrorHandler&lt;/a&gt; interface, or use predefined error handler: &lt;a href=&quot;https://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/CounterBasedErrorHandler.java?view=markup&quot;&gt;CounterBasedErrorHandler&lt;/a&gt;. ErrorHandling can be turned on by setting the property pig.error-handling.enabled to true in pig.properties. Default is false. CounterBasedErrorHandler uses two settings - pig.error-handling.min.error.records (the minimum number of errors to trigger error handling) and pig.error-handling.error.threshold (percentage of the number of records as a fraction exceeding which error is thrown).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc150506cb63da1efd5b036ac01bcfb2d9f13074" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/LoadCaster.java?view=markup&quot;&gt;LoadCaster&lt;/a&gt; has methods to convert byte arrays to specific types. A loader implementation should implement this if casts (implicit or explicit) from DataByteArray fields to other types need to be supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e221cd3a1af3d51ed5016328cbedda668dc3c06" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/LoadFunc.java?view=markup&quot;&gt;LoadFunc&lt;/a&gt; abstract class has three main methods for loading data and for most use cases it would suffice to extend it. There are three other optional interfaces which can be implemented to achieve extended functionality:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e778a4192860476372948ecb691f0d2aedde8df" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/LoadMetadata.java?view=markup&quot;&gt;LoadMetadata&lt;/a&gt; has methods to deal with metadata - most implementation of loaders don't need to implement this unless they interact with some metadata system. The getSchema() method in this interface provides a way for loader implementations to communicate the schema of the data back to pig. If a loader implementation returns data comprised of fields of real types (rather than DataByteArray fields), it should provide the schema describing the data returned through the getSchema() method. The other methods are concerned with other types of metadata like partition keys and statistics. Implementations can return null return values for these methods if they are not applicable for that implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4752f1138ca0767704510f7b4cbbc6de51efb229" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/LoadPredicatePushdown.java?view=markup&quot;&gt;LoadPredicatePushdown&lt;/a&gt; has the methods to push predicates to the loader. It is different than LoadMetadata.setPartitionFilter in that loader may load records which does not satisfy the predicates. In other words, predicates is only a hint. Note this interface is still in development and might change in next version. Currently only OrcStorage implements this interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="010e202910929fc84c506ec393c98dd074bfe086" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/LoadPushDown.java?view=markup&quot;&gt;LoadPushDown&lt;/a&gt; has methods to push operations from Pig runtime into loader implementations. Currently only the pushProjection() method is called by Pig to communicate to the loader the exact fields that are required in the Pig script. The loader implementation can choose to honor the request (return only those fields required by Pig script) or not honor the request (return all fields in the data). If the loader implementation can efficiently honor the request, it should implement LoadPushDown to improve query performance. (Irrespective of whether the implementation can or cannot honor the request, if the implementation also implements getSchema(), the schema returned in getSchema() should describe the entire tuple of data.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcda22f6a89f0d6e2208e49e42105dbe123d68f0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/NonFSLoadFunc.java?view=markup&quot;&gt;NonFSLoadFunc&lt;/a&gt; is a marker interface to indicate that a LoadFunc implementation is not a filesystem loader. This is useful for LoadFunc classes that for example supply queries instead of filesystem pathes to the LOAD operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ba36350f403c3526d27b1e0d271421cc65839ce" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/StoreFunc.java?view=markup&quot;&gt;StoreFunc&lt;/a&gt; abstract class has the main methods for storing data and for most use cases it should suffice to extend it. There is an optional interface which can be implemented to achieve extended functionality:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea4d26d3820dd48966d48392438bf1a16426182d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/StoreMetadata.java?view=markup&quot;&gt;StoreMetadata:&lt;/a&gt; This interface has methods to interact with metadata systems to store schema and store statistics. This interface is optional and should only be implemented if metadata needs to stored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dbc6c637e7cfecf0d15d30180e6eb5e7de9582c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/StoreResources.java?view=markup&quot;&gt;StoreResources:&lt;/a&gt; This interface has methods to put hdfs files or local files to distributed cache.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="874e6b08968e2ab1b0a8b5742b065972b13b799a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://tez.apache.org&quot;&gt;Apache Tez&lt;/a&gt; provides an alternative execution engine than MapReduce focusing on performance. By using optimized job flow, edge semantics and container reuse, we see consistent performance boost for both large job and small job.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e46bc562894afe7359dce07e14f582b94fe4041" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;start#pl-statements&quot;&gt;Pig Latin statements&lt;/a&gt; work with relations. A relation can be defined as follows:</source>
          <target state="translated">&lt;a href=&quot;start#pl-statements&quot;&gt;돼지 라틴어 진술&lt;/a&gt; 은 관계와 함께 작동합니다. 관계는 다음과 같이 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce247f90b43cda1ce487f24bd8c0a263c12aae38" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: although the Java formatter (and thus this function) offers the %t specifier for date/time elements, it's best avoided: it's cumbersome, the output and timezone handling may differ from what you expect, and it doesn't accept datetime objects from pig. Instead, just prepare dates usint the ToString UDF as shown.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;참고 : Java 포맷터 (및이 함수)는 날짜 / 시간 요소에 % t 지정자를 제공하지만 피하는 것이 가장 좋습니다. 번거롭고 출력 및 시간대 처리가 예상과 다를 수 있으며 날짜 시간 객체를 허용하지 않습니다 돼지에서. 대신, 표시된 것처럼 ToString UDF를 사용하여 날짜를 준비하십시오.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="95b2f66539549c1c26da78ccce34909a84db80af" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;expression&lt;/em&gt; matches &lt;em&gt;string-constant&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;&lt;em&gt;문자열 상수&lt;/em&gt; 와 일치하는 &lt;em&gt;표현식&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e85b2c480f58f647f0bd98112e87a6be883c15f2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;hadoop.security.krb5.keytab&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;hadoop.security.krb5.keytab&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f87e94cb069a92396643cda1720e05e830879c90" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;hadoop.security.krb5.principal&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;hadoop.security.krb5.principal&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2fa49a61088a8c1b5731308fea093116b4ffd0f0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;java.security.krb5.conf&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;java.security.krb5.conf&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6ac1e45e3a58654a06f3162c77fcf0eb032e9e0a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Allowed characters&lt;/strong&gt; Pig schemas may sometimes contain characters like colons (&quot;:&quot;) that are illegal in Avro names.</source>
          <target state="translated">&lt;strong&gt;허용되는 문자&lt;/strong&gt; 돼지 스키마에는 종종 Avro 이름에서 잘못된 콜론 ( &quot;:&quot;)과 같은 문자가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00091b674192e742a0c4fd9112fb56676258ab80" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Ant 1.8&lt;/strong&gt; - &lt;a href=&quot;http://ant.apache.org/&quot;&gt;http://ant.apache.org/&lt;/a&gt; (for builds)</source>
          <target state="translated">&lt;strong&gt;Ant 1.8&lt;/strong&gt; - &lt;a href=&quot;http://ant.apache.org/&quot;&gt;http&lt;/a&gt; : //ant.apache.org/ (빌드 용)</target>
        </trans-unit>
        <trans-unit id="b4d719252a75d81c038080c6f97ba39c88a42e91" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Ant 1.8&lt;/strong&gt; - &lt;a href=&quot;https://ant.apache.org/&quot;&gt;http://ant.apache.org/&lt;/a&gt; (for builds)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c25a6d30270f033c3bd039d8fb352b6cbd8b5071" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Bag Construction&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;부대 건축&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b3f73dfac8f974a3eff636392c0bd9e8413da0e7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Bag Example&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;가방 예&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="870a7ecad884afc7377fdb69b11fd79eb4e1aac2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Batch Mode&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;배치 모드&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="11b6f773d4b899cf4d205666c83816bffd407495" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Bind:&lt;/strong&gt; Resolve the parameters during the bind call.</source>
          <target state="translated">&lt;strong&gt;바인드 :&lt;/strong&gt; 바인드 호출 중 매개 변수를 해결하십시오.</target>
        </trans-unit>
        <trans-unit id="0563539d79a1e2243f69e94abf457c1aa841d0d5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Classifier&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Classifier&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="864e811a53f057658e78bdbd990a7f47373547f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Column family prefix:&lt;/strong&gt; When reading data, this will fetch data from Accumulo Key-Values in the current row whose column family match the given prefix. This will result in a Map being placed into the Tuple. When writing data, a Map is also expected at the given offset in the Tuple whose Keys will be appended to the column family prefix, an empty column qualifier is used, and the Map value will be placed in the Accumulo Value. A valid column family prefix is a literal asterisk (*) in which case the Map Key will be equivalent to the Accumulo column family.</source>
          <target state="translated">&lt;strong&gt;열 패밀리 접두사 :&lt;/strong&gt; 데이터를 읽을 때 열 행이 주어진 접두사와 일치하는 현재 행의 누적 키-값에서 데이터를 가져옵니다. 그러면 맵이 터플에 배치됩니다. 데이터를 쓸 때 키가 열 패밀리 접두사에 추가되고 빈 열 한정자가 사용되는 Tuple의 주어진 오프셋에서 맵이 예상되며 맵 값은 Accumulo Value에 배치됩니다. 유효한 열 패밀리 접두어는 리터럴 별표 (*)이며이 경우 맵 키는 Accumulo 열 패밀리와 같습니다.</target>
        </trans-unit>
        <trans-unit id="b3eed7692af866e2243137f5b284bee14d334cdb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Column qualifier prefix:&lt;/strong&gt; Similar to the column family prefix except it operates on the column qualifier. On reads, Accumulo Key-Values in the same row that match the given column family and column qualifier prefix will be placed into a single Map. On writes, the provided column family from the column specification will be used, the Map key will be appended to the column qualifier provided in the specification, and the Map Value will be the Accumulo Value.</source>
          <target state="translated">&lt;strong&gt;열 한정자 접두사 : 열 한정자에서&lt;/strong&gt; 작동한다는 점을 제외하면 열 패밀리 접두사와 유사합니다. 읽기에서 지정된 열 제품군 및 열 한정자 접두사와 일치하는 동일한 행의 누적 키-값은 단일 맵에 배치됩니다. 쓰기시, 열 스펙에서 제공된 열 패밀리가 사용되며, 스펙에서 제공된 열 규정 자에 맵 키가 추가되며 맵 값은 누적 값이됩니다.</target>
        </trans-unit>
        <trans-unit id="ecbb081e3ce72bba13d9ecbf008d71980ea03e7a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Command Line&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;커맨드 라인&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a98d670edccff0e4121af4a4e5fe34d134803db4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Comments in Scripts&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;스크립트의 주석&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d85745bf3b8216f5930a0e251abc37521080a93b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Compile:&lt;/strong&gt; Compile is a static function on the Pig class and in its simplest form takes a fragment of Pig Latin that defines the pipeline as its input:</source>
          <target state="translated">&lt;strong&gt;컴파일 :&lt;/strong&gt; 컴파일은 Pig 클래스의 정적 함수이며 가장 간단한 형식으로 파이프 라인을 입력으로 정의하는 Pig Latin의 조각을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1588b0f85251359e7c112374b34b83b9a6561bf4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Complex Data Types&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;복잡한 데이터 유형&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9716a94fd7eb50856fe6e9f5141d2d216e91bc3b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Complex Types&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;복잡한 유형&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="24aaa88a5a4ab27e81f0ef805d978692466917a6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Condition A&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;조건 A&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="184c0023d23924ce8243e4dd3934bad392668931" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Condition B&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;조건 B&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0ccfb27cc7c1b0e0d8393a950626994487c394f3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Configuring&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Configuring&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9f9946beee7fef5c387bbef258555f0fc1e90f2c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Constant Example&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;상수 예&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d583721fdee9eda617809d6d5f0932df533809dd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Description&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Description&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ada6187c809ce88890faeed212002675891701db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Embedded Python Example&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;임베디드 파이썬 예제&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1f00e4b16dab8740b9be9691f26d9eb78c4ac38c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Enums&lt;/strong&gt; Avro allows you to define enums to efficiently and abstractly represent categorical variable, but Pig does not.</source>
          <target state="translated">&lt;strong&gt;열거 형&lt;/strong&gt; Avro를 사용하면 범주 형 변수를 효율적이고 추상적으로 나타내도록 열거 형을 정의 할 수 있지만 Pig는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="16bac31fbe05df3ba97ccfb9e03a603c63955b65" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example Implementation&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;구현 예&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bce3f4a409dc0c67054a7e806ad3eecf69f742f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5c3d140c8e464f134cec3b0eebd38bf683f55d62" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Examples&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Examples&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="aa07a12dbe3a7b10f89d3fada2154cdedcf225c8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Exclude&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Exclude&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="766d44462eca7406a9cdef3dc27995752d1043bd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Field/Record Delimiters&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;필드 / 레코드 구분자&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5979cb8b19875b5dfeaab0503ebc729fbc6f4fcf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;File&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;File&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="55e5d0ca1011d6e3ac86e82020831ef352d18ed1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fixed Length Byte Arrays&lt;/strong&gt; Avro allows you to define fixed length byte arrays, but Pig does not.</source>
          <target state="translated">&lt;strong&gt;고정 길이 바이트 배열&lt;/strong&gt; Avro에서는 고정 길이 바이트 배열을 정의 할 수 있지만 Pig는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b2986e9a8f11acf1d3167efc7dc795c85d9a800a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Groovy&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Groovy&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f5c96eb5f46c96767fb943ff94d7bd89e51371f4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Hadoop 2.X&lt;/strong&gt; - &lt;a href=&quot;http://hadoop.apache.org/common/releases.html&quot;&gt;http://hadoop.apache.org/common/releases.html&lt;/a&gt; (You can run Pig with different versions of Hadoop by setting HADOOP_HOME to point to the directory where you have installed Hadoop. If you do not set HADOOP_HOME, by default Pig will run with the embedded version, currently Hadoop 2.7.3.)</source>
          <target state="translated">&lt;strong&gt;하둡 2.X&lt;/strong&gt; - &lt;a href=&quot;http://hadoop.apache.org/common/releases.html&quot;&gt;http://hadoop.apache.org/common/releases.html&lt;/a&gt; (당신은 당신이 하둡을 설치 한 디렉토리를 가리 키도록 HADOOP_HOME을 설정하여 하둡의 다른 버전과 함께 돼지를 실행할 수 있습니다 당신은 HADOOP_HOME을 설정하지 않은 경우. 기본적으로 Pig는 임베드 된 버전 (현재 Hadoop 2.7.3)으로 실행됩니다.)</target>
        </trans-unit>
        <trans-unit id="21f79d6ece8c3bbdaaf02fa5f2c910320286210d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Hadoop 2.X&lt;/strong&gt; - &lt;a href=&quot;https://hadoop.apache.org/common/releases.html&quot;&gt;http://hadoop.apache.org/common/releases.html&lt;/a&gt; (You can run Pig with different versions of Hadoop by setting HADOOP_HOME to point to the directory where you have installed Hadoop. If you do not set HADOOP_HOME, by default Pig will run with the embedded version, currently Hadoop 2.7.3.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a581f929d6ff04a5c40c9d094095507993dd6ea" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How Pig Handles Schema&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;돼지가 스키마를 처리하는 방법&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="831617e8204b3e0783377c2056103288403652ff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Interactive Mode &lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;대화식 모드 &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f0c158d121dd2402f46e37ae90cac07ee7c398a6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Invocation Process&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;호출 프로세스&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a80415760be9c4358b22b7a212dfab8ad1757865" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Java 1.7&lt;/strong&gt; - &lt;a href=&quot;http://java.sun.com/javase/downloads/index.jsp&quot;&gt;http://java.sun.com/javase/downloads/index.jsp&lt;/a&gt; (set JAVA_HOME to the root of your Java installation)</source>
          <target state="translated">&lt;strong&gt;Java 1.7&lt;/strong&gt; - &lt;a href=&quot;http://java.sun.com/javase/downloads/index.jsp&quot;&gt;http&lt;/a&gt; : //java.sun.com/javase/downloads/index.jsp (JAVA_HOME을 Java 설치의 루트로 설정)</target>
        </trans-unit>
        <trans-unit id="45565dc2a4e38dfb88e321711fd07ae8f3e420e7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;JavaScript&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;JavaScript&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d96e75f238c293154cc6cd3a8e3ad55e7555b9f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Known Schema Handling&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;알려진 스키마 처리&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0c6f0f074434fa4debcf3e9fa872bf26f85241ea" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Let Pig Set the Number of Reducers&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;돼지 감속기의 수를 설정하자&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c79e350789ffa976aa4f13f4ba7fcc02a9da4cdc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Literal:&lt;/strong&gt; this is the simplest specification which is a colon-delimited string that maps to a column family and column qualifier. This will read/write a simple scalar from/to Accumulo.</source>
          <target state="translated">&lt;strong&gt;리터럴 :&lt;/strong&gt; 열 계열 및 열 한정자에 매핑되는 콜론으로 구분 된 문자열 인 가장 간단한 사양입니다. Accumulo에서 /으로 간단한 스칼라를 읽거나 씁니다.</target>
        </trans-unit>
        <trans-unit id="c711cb7bb6ac2617e366ffad4bed81f922bf80de" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Load/Store Statements&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;로드 / 저장 문&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="668c155ca345102aaba6691aba86629e65bebb4c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Local Mode&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;로컬 모드&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="115a5670e8cf787355d4e90a58a169dba45a1bdb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Local Mode&lt;/strong&gt; - To run Pig in local mode, you need access to a single machine; all files are installed and run using your local host and file system. Specify local mode using the -x flag (pig -x local).</source>
          <target state="translated">&lt;strong&gt;로컬 모드&lt;/strong&gt; - &lt;strong&gt;로컬 모드&lt;/strong&gt; 에서 Pig를 실행하려면 단일 컴퓨터에 액세스해야합니다. 모든 파일은 로컬 호스트 및 파일 시스템을 사용하여 설치 및 실행됩니다. -x 플래그 (pig -x local)를 사용하여 로컬 모드를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="c645ce0ad4873922bbac93fa3553d53e97e98448" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Macro Definition&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;매크로 정의&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="eaa9d9d7381feb9993ffd8c0e7bcbc5bf954ac37" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Macro Expansion&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;매크로 확장&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="125364bf0136bb94c340e9732e7ad3816be4e9e8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Macro Import&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;매크로 가져 오기&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bd47d2d1891832b1f46294249939daacd12b7d36" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Mandatory&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Mandatory&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="55aaceba23e37d916e01b468b61986944eb4f371" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Map Construction&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;지도 건설&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="aea7becf90d862b8c96ef976f5626d52dd9d6d26" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Map Example&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;지도 예&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8fc7b1ec3162d7ed517b542a326b608b948be7c9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Mapreduce Mode&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;맵리 듀스 모드&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d96a5cdfce7b35735d1d999c3b691250fc32ff84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Mapreduce Mode&lt;/strong&gt; - To run Pig in mapreduce mode, you need access to a Hadoop cluster and HDFS installation. Mapreduce mode is the default mode; you can, &lt;em&gt;but don't need to&lt;/em&gt;, specify it using the -x flag (pig OR pig -x mapreduce).</source>
          <target state="translated">&lt;strong&gt;Mapreduce 모드-Mapreduce 모드&lt;/strong&gt; 에서 Pig를 실행하려면 Hadoop 클러스터 및 HDFS 설치에 액세스해야합니다. Mapreduce 모드가 기본 모드입니다. -x 플래그 (pig OR pig -x mapreduce)를 사용하여 지정할 수 &lt;em&gt;있지만 반드시 그럴 필요는 없습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="6d9141da19ad3c2181f6299bd2e0cee6a596f33e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Matches Example&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;일치 예&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0a3150d01b86051af1c4123018e7b1c710d7b890" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE:&lt;/strong&gt; When using the option &lt;strong&gt;DENSE&lt;/strong&gt;, ties do not cause gaps in ranking values.</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt;&lt;strong&gt;DENSE&lt;/strong&gt; 옵션을 사용하는 경우 순위가 순위 값에 차이가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="caff053422a8bdc60afad9e00a1ff09002dcdaf6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE:&lt;/strong&gt;All paths in these variables are local to the client system starting the actual pig script. This can be run without any special access to the cluster nodes.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 변수의 모든 경로는 실제 pig 스크립트를 시작하는 클라이언트 시스템에 국한됩니다. 이것은 클러스터 노드에 대한 특별한 액세스없이 실행될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ae207711ac29e86ecfa62b02f39e088dfb6a634" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Both the LoadFunc and StoreFunc implementations should use the Hadoop 20 API based classes (InputFormat/OutputFormat and related classes) under the &lt;strong&gt;new&lt;/strong&gt; org.apache.hadoop.mapreduce package instead of the old org.apache.hadoop.mapred package.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; LoadFunc 및 StoreFunc 구현 모두 이전 org.apache.hadoop.mapred 패키지 대신 &lt;strong&gt;새&lt;/strong&gt; org.apache.hadoop.mapreduce 패키지 에서 Hadoop 20 API 기반 클래스 (InputFormat / OutputFormat 및 관련 클래스)를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="78870d3d6b0a9484a8b8dca2ae46d2b8f3dc7f1b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; During the testing/debugging phase of your implementation, you can use DUMP to display results to your terminal screen. However, in a production environment you always want to use the STORE operator to save your results (see &lt;a href=&quot;perf#store-dump&quot;&gt;Store vs. Dump&lt;/a&gt;).</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 구현의 테스트 / 디버깅 단계에서 DUMP를 사용하여 결과를 터미널 화면에 표시 할 수 있습니다. 그러나 프로덕션 환경에서는 항상 STORE 연산자를 사용하여 결과를 저장하려고합니다 ( &lt;a href=&quot;perf#store-dump&quot;&gt;Store vs. Dump&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="895e562e990a0711db3da696565dc2f4d6e636d9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; ORDER BY is NOT stable; if multiple records have the same ORDER BY key, the order in which these records are returned is not defined and is not guarantted to be the same from one run to the next.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; ORDER BY는 안정적이지 않습니다. 여러 레코드에 동일한 ORDER BY 키가있는 경우 이러한 레코드가 리턴되는 순서는 정의되지 않으며 한 실행에서 다음 실행까지 동일하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="4da743e10dc574043b389940ca292b82ba1e4971" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; One exception to the above rule is LIMIT. Starting with Pig 0.9, even if LIMIT comes between GROUP and FOREACH, the combiner will still be used. In this example, the optimizer will push LIMIT above FOREACH but this will not prevent the use of the combiner.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 위 규칙의 한 가지 예외는 LIMIT입니다. Pig 0.9부터 LIMIT가 GROUP과 FOREACH 사이에 있더라도 결합기가 계속 사용됩니다. 이 예에서 옵티마이 저는 LIMIT를 FOREACH 이상으로 푸시하지만 결합기 사용을 막지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="8ad88bd615fb1f186e321950cc0fe9fde548ad79" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Pig automatically chooses the interface that it expects to provide the best performance: Algebraic &amp;gt; Accumulator &amp;gt; Default.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; Pig는 최적의 성능을 제공 할 것으로 기대되는 인터페이스를 자동으로 선택합니다 (대수&amp;gt; 누산기&amp;gt; 기본값).</target>
        </trans-unit>
        <trans-unit id="183977813559360228ae002f15edf2ef8f705a52" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Pig uses Hadoop globbing so the functionality is IDENTICAL. However, when you run from the command line using the Hadoop fs command (rather than the Pig LOAD operator), the Unix shell may do some of the substitutions; this could alter the outcome giving the impression that globing works differently for Pig and Hadoop. For example:</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; Pig는 Hadoop globbing을 사용하므로 기능이 동일합니다. 그러나 Pig LOAD 연산자 대신 Hadoop fs 명령을 사용하여 명령 행에서 실행할 때 Unix 쉘이 일부 대체를 수행 할 수 있습니다. 이것은 결과가 변경되어 Piging과 Hadoop에서 globing이 다르게 작동한다는 인상을 줄 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d3f879ceef97d4f1bfb2973ffa7e17d3437f5951" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Piggy Bank currently supports Java UDFs. Support for Jython and JavaScript UDFs will be added at a later date.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; Piggy Bank는 현재 Java UDF를 지원합니다. Jython 및 JavaScript UDF에 대한 지원은 나중에 추가 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="5c3e44b2a4d061ae9b4449e1f8409d6770fcf286" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Spark local mode is experimental. There are some queries which just error out on bigger data in local mode.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; Spark 로컬 모드는 실험적입니다. 로컬 모드에서 더 큰 데이터에서 오류가 발생하는 쿼리가 있습니다.</target>
        </trans-unit>
        <trans-unit id="13ff27c32be37148d15e2bfa3c3b7305070f40e2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Tez local mode is experimental. There are some queries which just error out on bigger data in local mode.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; Tez 로컬 모드는 실험적입니다. 로컬 모드에서 더 큰 데이터에서 오류가 발생하는 쿼리가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ce361b8bad82567158b8fe3a047f8e8d3cbe477" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The PIG_CLASSPATH can also be used to add any other 3rd party dependencies or resource files a pig script may require. If there is also a need to make the added entries take the highest precedence in the Pig JVM's classpath order, one may also set the env-var PIG_USER_CLASSPATH_FIRST to any value, such as 'true' (and unset the env-var to disable).</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; PIG_CLASSPATH를 사용하여 돼지 스크립트에 필요할 수있는 다른 타사 종속성 또는 리소스 파일을 추가 할 수도 있습니다. Pig JVM의 클래스 경로 순서에서 추가 된 항목을 우선 순위로 두어야하는 경우 env-var PIG_USER_CLASSPATH_FIRST를 'true'와 같은 값으로 설정할 수도 있습니다 (env-var을 설정 해제하여 비활성화) .</target>
        </trans-unit>
        <trans-unit id="8ed8f748eb1080cd104588d317ebde5b4fb93992" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The properties file uses standard Java property file format.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 특성 파일은 표준 Java 특성 파일 형식을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="cbdba850c47e3331e8cbdd7856bdbac0c86640a9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt;&lt;em&gt;Groovy UDFs are an experimental feature.&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt;&lt;em&gt;Groovy UDF는 실험적인 기능입니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c06a2496b794f2adab89afab29e788f8412f5a64" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt;&lt;em&gt;JavaScript UDFs are an experimental feature.&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt;&lt;em&gt;JavaScript UDF는 실험적인 기능입니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a2fb07a88e9cf33355400006e0c53fdc471d293b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt;&lt;em&gt;Ruby UDFs are an experimental feature.&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt;&lt;em&gt;Ruby UDF는 실험적인 기능입니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e42fbe4240560deae4f59c3edc3b41aa2d7beba4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Notes&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Notes&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0921e59b128a6c1bbffa876015afd4d76c9d5b93" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Nullable values&lt;/strong&gt; In Pig, all types are nullable. In Avro, they are not.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;널 입력 &lt;strong&gt;가능 값&lt;/strong&gt; Pig에서는 모든 유형이 널 입력 가능합니다. 아브로에서는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="98888839ac527d9d7b6da918b1f83d5acf0c0c54" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Numeric Example&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;숫자 예&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b846b34df36736959702d437ac75b781737f468b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Optional&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Optional&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1a3e8c098fcdd970e7382f10bbf64c7a2e014036" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pig Scripts&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;돼지 스크립트&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7bdf1ddccb4e6c4031cf7f86002ae55f143c5fbb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pig Statistic&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;돼지 통계&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1fed854abb334670642eb08a38dc28bfc7641e99" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Python 2.7&lt;/strong&gt; - &lt;a href=&quot;http://jython.org/downloads.html&quot;&gt;https://www.python.org&lt;/a&gt; (when using Streaming Python UDFs)</source>
          <target state="translated">&lt;strong&gt;Python 2.7&lt;/strong&gt; - &lt;a href=&quot;http://jython.org/downloads.html&quot;&gt;https&lt;/a&gt; : //www.python.org (스트리밍 Python UDF 사용시)</target>
        </trans-unit>
        <trans-unit id="c7975b4ef8f024abdf4eff330237ea5ef1ed22b8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Python&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Python&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2a019b65ade07a20be180f8e8937a06f90d86346" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Record Provenance&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;기록적인 기록&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="566be72176eaa278d3535a25e25de726d19843bc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Recursive schema definitions&lt;/strong&gt; You cannot define schemas recursively in Pig, but you can define schemas recursively in Avro.</source>
          <target state="translated">&lt;strong&gt;재귀 스키마 정의&lt;/strong&gt; Pig에서는 재귀 &lt;strong&gt;적으로 스키마를 정의&lt;/strong&gt; 할 수 없지만 Avro에서는 재귀 적으로 스키마를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77b3f0d8905b86fb4492ec8d3c26723649af40c3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Regular Join Optimizations&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;정기 조인 최적화&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4a7ad93d7a246903d335205919508cab60dffaa5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Run:&lt;/strong&gt; Bind call returns an instance of &lt;a href=&quot;#BoundScript-Object&quot;&gt;BoundScript object&lt;/a&gt; that can be used to execute the pipeline. The simplest way to execute the pipeline is to call runSingle function. (However, as mentioned later, this works only if a single set of variables is bound to the parameters. Otherwise, if multiple set of variables are bound, an exception will be thrown if runSingle is called.)</source>
          <target state="translated">&lt;strong&gt;실행 :&lt;/strong&gt; 바인드 호출 은 파이프 라인을 실행하는 데 사용할 수있는 &lt;a href=&quot;#BoundScript-Object&quot;&gt;BoundScript 객체&lt;/a&gt; 의 인스턴스를 반환합니다 . 파이프 라인을 실행하는 가장 간단한 방법은 runSingle 함수를 호출하는 것입니다. (나중에 언급 한 것처럼 단일 변수 세트가 매개 변수에 바인드 된 경우에만 작동합니다. 그렇지 않으면 여러 변수 세트가 바인드 된 경우 runSingle이 호출되면 예외가 발생합니다.)</target>
        </trans-unit>
        <trans-unit id="378fc0f1b46427d6e8a56d87753208d6bb71cdcc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Schema Behavior&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;스키마 동작&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="40c7c9f3b36bddd1c3522857cac48d0c8a44ad4a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Schemas&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Schemas&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0da0dc70d7e72681246419f048be48242fe54ad3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Scripts and Distributed File Systems&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;스크립트 및 분산 파일 시스템&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6785c3fc935f096a149904bca0e95418c0d70050" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Self Joins&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;자체 조인&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="345db123796e88e27a2f8e6f980928a20fdae6ba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Shortcuts for Debugging Operators&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;연산자 디버깅을위한 바로 가기&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="26753e7f15e3b320a073f459478d4f98ca647e16" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Simple Data Types&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;간단한 데이터 타입&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="72c3243c9f6733316014648eb5f6af2bfc09371b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Simple Types&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;간단한 유형&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f71edba915a49b7c254c1024aa580e42777e3d5d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Spark Local Mode&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;스파크 로컬 모드&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d7d03ecf4477cb1d33b4216cf566dd7c06866de3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Spark Local Mode&lt;/strong&gt; - To run Pig in spark local mode. It is similar to local mode, except internally Pig will invoke spark runtime engine. Specify Spark local mode using the -x flag (pig -x spark_local).</source>
          <target state="translated">&lt;strong&gt;Spark Local Mode&lt;/strong&gt; - &lt;strong&gt;Spark 로컬 모드&lt;/strong&gt; 에서 Pig를 실행합니다. 내부적으로 Pig가 스파크 런타임 엔진을 호출한다는 점을 제외하면 로컬 모드와 유사합니다. -x 플래그 (pig -x spark_local)를 사용하여 Spark 로컬 모드를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="827c72ceb68dc284becb267fe90177968ea47f0a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Spark Mode&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;스파크 모드&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7b3ca88f4b6e29949d2bb9f42899b24d463c5103" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Spark Mode&lt;/strong&gt; - To run Pig in Spark mode, you need access to a Spark, Yarn or Mesos cluster and HDFS installation. Specify Spark mode using the -x flag (-x spark). In Spark execution mode, it is necessary to set env::SPARK_MASTER to an appropriate value (local - local mode, yarn-client - yarn-client mode, mesos://host:port - spark on mesos or spark://host:port - spark cluster. For more information refer to spark documentation on Master URLs, &lt;em&gt;yarn-cluster mode is currently not supported&lt;/em&gt;). Pig scripts run on Spark can take advantage of the &lt;a href=&quot;http://spark.apache.org/docs/latest/job-scheduling.html#dynamic-resource-allocation&quot;&gt;dynamic allocation&lt;/a&gt; feature. The feature can be enabled by simply enabling &lt;em&gt;spark.dynamicAllocation.enabled&lt;/em&gt;. Refer to spark &lt;a href=&quot;http://spark.apache.org/docs/latest/configuration.html#dynamic-allocation&quot;&gt;configuration&lt;/a&gt; for additional configuration details. In general all properties in the pig script prefixed with &lt;em&gt;spark.&lt;/em&gt; are copied to the Spark Application Configuration. Please note that Yarn auxillary service need to be enabled on Spark for this to work. See Spark documentation for additional details.</source>
          <target state="translated">&lt;strong&gt;스파크 모드&lt;/strong&gt; &amp;ndash; &lt;strong&gt;스파크 모드&lt;/strong&gt; 에서 Pig를 실행하려면 Spark, Yarn 또는 Mesos 클러스터 및 HDFS 설치에 액세스해야합니다. -x 플래그 (-x spark)를 사용하여 Spark 모드를 지정하십시오. Spark 실행 모드에서는 env :: SPARK_MASTER를 적절한 값 (로컬-로컬 모드, 얀-클라이언트-얀-클라이언트 모드, mesos : // host : port-mesos의 spark 또는 spark : // host)로 설정해야합니다. : port-spark cluster. 자세한 내용은 마스터 URL에 대한 spark 설명서를 참조하십시오 ( &lt;em&gt;원사 클러스터 모드는 현재 지원되지 않음&lt;/em&gt; ). Spark에서 실행되는 Pig 스크립트는 &lt;a href=&quot;http://spark.apache.org/docs/latest/job-scheduling.html#dynamic-resource-allocation&quot;&gt;동적 할당&lt;/a&gt; 기능 을 활용할 수 있습니다 . &lt;em&gt;spark.dynamicAllocation.enabled를&lt;/em&gt; 활성화하여 기능을 활성화 할 수 있습니다 . 스파크 &lt;a href=&quot;http://spark.apache.org/docs/latest/configuration.html#dynamic-allocation&quot;&gt;구성&lt;/a&gt; 참조추가 구성 세부 사항. 일반적으로 pig 스크립트의 모든 속성은 접두사가 붙습니다 &lt;em&gt;. &lt;/em&gt;Spark 애플리케이션 구성으로 복사됩니다. Spark에서 원사 보조 서비스를 사용하도록 설정해야합니다. 자세한 내용은 Spark 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c9ccc9581e987fbee69af5e74b768a02cef55e73" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Spark Mode&lt;/strong&gt; - To run Pig in Spark mode, you need access to a Spark, Yarn or Mesos cluster and HDFS installation. Specify Spark mode using the -x flag (-x spark). In Spark execution mode, it is necessary to set env::SPARK_MASTER to an appropriate value (local - local mode, yarn-client - yarn-client mode, mesos://host:port - spark on mesos or spark://host:port - spark cluster. For more information refer to spark documentation on Master URLs, &lt;em&gt;yarn-cluster mode is currently not supported&lt;/em&gt;). Pig scripts run on Spark can take advantage of the &lt;a href=&quot;https://spark.apache.org/docs/latest/job-scheduling.html#dynamic-resource-allocation&quot;&gt;dynamic allocation&lt;/a&gt; feature. The feature can be enabled by simply enabling &lt;em&gt;spark.dynamicAllocation.enabled&lt;/em&gt;. Refer to spark &lt;a href=&quot;https://spark.apache.org/docs/latest/configuration.html#dynamic-allocation&quot;&gt;configuration&lt;/a&gt; for additional configuration details. In general all properties in the pig script prefixed with &lt;em&gt;spark.&lt;/em&gt; are copied to the Spark Application Configuration. Please note that Yarn auxillary service need to be enabled on Spark for this to work. See Spark documentation for additional details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8f01b3481595886c0396e8cd5a35875048c8bd9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Specialized Join Optimizations&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;전문화 된 조인 최적화&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1c3ecb950c0d80d33d45f0509799549cd474aeb0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;String Example&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;문자열 예&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="57552505bbaf1203868ac7ee94a0bc41f69133fb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Syntax&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Syntax&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="47339e1b34675340d6e331474ca2045939e2603d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Tez Local Mode&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;테즈 로컬 모드&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dbf40aa5c34af4001d58b8077d25952a2aa6c1c5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Tez Local Mode&lt;/strong&gt; - To run Pig in tez local mode. It is similar to local mode, except internally Pig will invoke tez runtime engine. Specify Tez local mode using the -x flag (pig -x tez_local).</source>
          <target state="translated">&lt;strong&gt;테즈 로컬 모드&lt;/strong&gt; - &lt;strong&gt;테즈 로컬 모드&lt;/strong&gt; 에서 Pig를 실행합니다. 내부적으로 Pig가 tez 런타임 엔진을 호출한다는 점을 제외하면 로컬 모드와 유사합니다. -x 플래그 (pig -x tez_local)를 사용하여 Tez 로컬 모드를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="deedb084c8b1c54ca293842df2f7429b02af87bf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Tez Mode&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;테즈 모드&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4dc42d4e8d987c38d04e4cde02a1ff3d700053af" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Tez Mode&lt;/strong&gt; - To run Pig in Tez mode, you need access to a Hadoop cluster and HDFS installation. Specify Tez mode using the -x flag (-x tez).</source>
          <target state="translated">&lt;strong&gt;Tez 모드-Tez 모드&lt;/strong&gt; 에서 Pig를 실행하려면 Hadoop 클러스터 및 HDFS 설치에 액세스해야합니다. -x 플래그 (-x tez)를 사용하여 Tez 모드를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="2d52f13cea96c3b5a3d0d430c90cf5210a996c3d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Transitive&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Transitive&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="121030792e9d4344d7373728507fb717d6efb51d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Tuple Construction&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;튜플 건설&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="64658a75f44cafa6b41cf819b573f71bb770279b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Tuple Example&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;튜플 예&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="93bb70e447d639b8255c29ca23df9c59d81e254f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Tuple/Bag Example&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;튜플 / 백 예제&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7b263a234ef49fbec4f0bddc1fdaa96ca3dc0f00" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Turning On Off&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;켜기&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="769d187f6703a2cf987ebb9df7aeab0b87dc8c65" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UDF&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;UDF&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="038fc17b15b3d49aec4624b9b504a8b20442d98a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Unions&lt;/strong&gt; In Avro, you can define an object that may be one of several different types (including complex types such as records). In Pig, you cannot.</source>
          <target state="translated">&lt;strong&gt;Union&lt;/strong&gt; Avro에서는 여러 유형 (레코드와 같은 복잡한 유형 포함) 중 하나 일 수있는 개체를 정의 할 수 있습니다. 돼지에서는 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="99c2ef3c7fc7318afccb414ba88eed5ac9c194bf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Unknown Schema Handling&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;알 수없는 스키마 처리&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2deb448968a26d13e858672fad6a7f4acb658a58" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You Set the Number of Reducers&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;당신은 감속기의 수를 설정&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7eb894f72d04a4d3d1210581d0fd36b6ec2c3f1a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;from / to&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;에서부터&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c9c017cc3d527394e40fd3471b360b54105339b7" translate="yes" xml:space="preserve">
          <source>==, !=</source>
          <target state="translated">==,! =</target>
        </trans-unit>
        <trans-unit id="900f8b38b05989605df65663e5e3869aab5eb789" translate="yes" xml:space="preserve">
          <source>? :</source>
          <target state="translated">? :</target>
        </trans-unit>
        <trans-unit id="bd778007b41ac3d4d1bd76259c9a22ad43debe17" translate="yes" xml:space="preserve">
          <source>? : bincond</source>
          <target state="translated">? : bincond</target>
        </trans-unit>
        <trans-unit id="a164c212592b671696739f9fedc2ac63fbd663ae" translate="yes" xml:space="preserve">
          <source>@OutputSchema annotation - Defines the schema for a UDF in a format that Pig understands.</source>
          <target state="translated">@OutputSchema 주석-Pig가 이해하는 형식으로 UDF의 스키마를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="f5c7976a098cb2c4f489bd53fab8063063d3c1c0" translate="yes" xml:space="preserve">
          <source>@OutputSchemaFunction annotation - Defines the name of a function which will return the schema at runtime according to the input schema.</source>
          <target state="translated">@OutputSchemaFunction 주석-입력 스키마에 따라 런타임에 스키마를 반환하는 함수의 이름을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="0acdc81cb7d03987748d5844dd817c0af23a4c35" translate="yes" xml:space="preserve">
          <source>A DUMP statement to view results or a STORE statement to save the results.</source>
          <target state="translated">결과를보기위한 DUMP 문 또는 결과를 저장하기위한 STORE 문.</target>
        </trans-unit>
        <trans-unit id="fc10a1c8854f199631d091c6ae7f90fa493ee487" translate="yes" xml:space="preserve">
          <source>A FLATTEN example on a map type. Here we load an integer and map (of integer values) into A. Then m gets flattened, and finally we are filtering the result to only include tuples where the value among the un-nested map entries was 5.</source>
          <target state="translated">지도 유형의 FLATTEN 예입니다. 여기에 정수와 정수 (정수 값)를 A에로드합니다 .m은 평평 해지 며 마지막으로 중첩되지 않은 맵 항목 중 값이 5 인 튜플 만 포함하도록 결과를 필터링합니다.</target>
        </trans-unit>
        <trans-unit id="176a8a86c5ab3106e52877b646afc861c4687569" translate="yes" xml:space="preserve">
          <source>A JSON string specifying the Avro schema for the input. You may specify an explicit schema when storing data or when loading data. When you manually provide a schema, Pig will use the provided schema for serialization and deserialization. This means that you can provide an explicit schema when saving data to simplify the output (for example by removing nullable unions), or rename fields. This also means that you can provide an explicit schema when reading data to only read a subset of the fields in each record.</source>
          <target state="translated">입력에 대한 Avro 스키마를 지정하는 JSON 문자열입니다. 데이터를 저장하거나 데이터를로드 할 때 명시 적 스키마를 지정할 수 있습니다. 스키마를 수동으로 제공하면 Pig는 직렬화 및 역 직렬화에 제공된 스키마를 사용합니다. 즉, 데이터를 저장할 때 명시 적으로 스키마를 제공하여 출력을 단순화하거나 (예 : nullable union 제거) 필드 이름을 바꿀 수 있습니다. 또한 데이터를 읽을 때 각 레코드의 필드 하위 집합 만 읽도록 명시 적 스키마를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e332ef5c3c73256cd007b96814120edf0e03417d" translate="yes" xml:space="preserve">
          <source>A LOAD statement to read data from the file system.</source>
          <target state="translated">파일 시스템에서 데이터를 읽는 LOAD 문</target>
        </trans-unit>
        <trans-unit id="cf4263ec5274d2ad3102cb19162b06b62ceca905" translate="yes" xml:space="preserve">
          <source>A Pig relation is a bag of tuples. A Pig relation is similar to a table in a relational database, where the tuples in the bag correspond to the rows in a table. Unlike a relational table, however, Pig relations don't require that every tuple contain the same number of fields or that the fields in the same position (column) have the same type.</source>
          <target state="translated">돼지 관계는 튜플 가방입니다. Pig 관계는 관계형 데이터베이스의 테이블과 유사하며 백의 튜플은 테이블의 행에 해당합니다. 그러나 관계형 테이블과 달리 Pig 관계에서는 모든 튜플에 동일한 수의 필드가 포함되거나 동일한 위치 (열)의 필드가 동일한 유형을 가질 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="88ccfbb3e4e52feb93893efc6371ff86017c0c69" translate="yes" xml:space="preserve">
          <source>A bag can have duplicate tuples.</source>
          <target state="translated">가방에는 중복 튜플이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1f16eb0492c370e5370429596edac14ed6cd1fe" translate="yes" xml:space="preserve">
          <source>A bag can have tuples with differing numbers of fields. However, if Pig tries to access a field that does not exist, a null value is substituted.</source>
          <target state="translated">가방에는 필드 수가 다른 튜플이있을 수 있습니다. 그러나 Pig가 존재하지 않는 필드에 액세스하려고하면 널값이 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="6f8521244c87cb3af718188d8f6a098268049836" translate="yes" xml:space="preserve">
          <source>A bag can have tuples with fields that have different data types. However, for Pig to effectively process bags, the schemas of the tuples within those bags should be the same. For example, if half of the tuples include chararray fields and while the other half include float fields, only half of the tuples will participate in any kind of computation because the chararray fields will be converted to null.</source>
          <target state="translated">백에는 데이터 유형이 다른 필드가있는 튜플이있을 수 있습니다. 그러나 Pig가 백을 효과적으로 처리하려면 해당 백 내의 튜플 스키마가 동일해야합니다. 예를 들어, 튜플의 절반이 chararray 필드를 포함하고 다른 절반이 float 필드를 포함하는 경우, chararray 필드가 널로 변환되므로 튜플의 절반 만 모든 종류의 계산에 참여합니다.</target>
        </trans-unit>
        <trans-unit id="78a789cd025135ec18d7229a62fcfd40e62e517e" translate="yes" xml:space="preserve">
          <source>A bag is a collection of tuples</source>
          <target state="translated">가방은 튜플 모음입니다</target>
        </trans-unit>
        <trans-unit id="9b3ff876ca8f1ec6dc0eba29ed972e95f11919a7" translate="yes" xml:space="preserve">
          <source>A bag is a collection of tuples.</source>
          <target state="translated">가방은 튜플 모음입니다.</target>
        </trans-unit>
        <trans-unit id="c3015eec6d30d7cec33a4f2bdf4ba3f4a2a4bfaf" translate="yes" xml:space="preserve">
          <source>A bag of arbitrary values. They will each be cast to chararray if they are not already.</source>
          <target state="translated">임의의 값의 백. 그들은 아직 chararray에 캐스트되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fc5a5e7e8c2484e2d91d19bdb3591f22b69c49b0" translate="yes" xml:space="preserve">
          <source>A boolean expression could look like this:</source>
          <target state="translated">부울 표현식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f2c611f29733d338bcda486238e8a7596d15b727" translate="yes" xml:space="preserve">
          <source>A boolean expression.</source>
          <target state="translated">부울 식입니다.</target>
        </trans-unit>
        <trans-unit id="357c708ad8cda5f307fbd1428a25ea6cad9cbbcd" translate="yes" xml:space="preserve">
          <source>A boolean flag to indicate whether to include or exclude matching columns</source>
          <target state="translated">일치하는 열을 포함할지 또는 제외 할지를 나타내는 부울 플래그</target>
        </trans-unit>
        <trans-unit id="4f78aa61153d723da36c98c77496c1d4385825fd" translate="yes" xml:space="preserve">
          <source>A challenge of running a large shared system is to make sure system resources are used efficiently. One aspect of this challenge is detecting runaway processes that are no longer making progress. Pig uses a heartbeat mechanism for this purpose. If any of the tasks stops sending a heartbeat, the system assumes that it is dead and kills it.</source>
          <target state="translated">대규모 공유 시스템을 실행하는 데 따른 과제는 시스템 리소스를 효율적으로 사용하는 것입니다. 이 과제의 한 측면은 더 이상 진행되지 않는 런 어웨이 프로세스를 감지하는 것입니다. Pig는이 목적으로 하트 비트 메커니즘을 사용합니다. 작업 중 하나라도 하트 비트 전송을 중지하면 시스템은 하트 비트 전송을 중지 한 것으로 간주합니다.</target>
        </trans-unit>
        <trans-unit id="2bc8a66aa62c2d099984eb270116071e45cee648" translate="yes" xml:space="preserve">
          <source>A chararray value to place between elements of the bag; defaults to underscore '_'.</source>
          <target state="translated">백의 요소들 사이에 놓일 chararray 값; 밑줄 '_'이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="2b89fe3b97d713d8051572f342459b450aeaac4f" translate="yes" xml:space="preserve">
          <source>A column transformation function such as ABS can be applied to an algebraic function SUM.</source>
          <target state="translated">ABS와 같은 열 변환 함수는 대수 함수 SUM에 적용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a6030e5cfc250824dc5f0603ae6aafed7739982" translate="yes" xml:space="preserve">
          <source>A comma-separated list of &quot;columns&quot; to read data from to write data to. Each of these columns can be considered one of three different types:</source>
          <target state="translated">데이터를 쓸 데이터를 읽을 쉼표로 구분 된 &quot;열&quot;목록입니다. 이러한 각 열은 세 가지 유형 중 하나로 간주 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b1e2b3b81bc48b5c62a2a45324df879808f9ae0" translate="yes" xml:space="preserve">
          <source>A comma-separated list of input directories for the job.</source>
          <target state="translated">작업에 대한 쉼표로 구분 된 입력 디렉토리 목록.</target>
        </trans-unit>
        <trans-unit id="f5d413a422b9f1eaeb611b6ddf5eeb8c2856bdde" translate="yes" xml:space="preserve">
          <source>A comma-separated list of output directories in the map phase of the job.</source>
          <target state="translated">작업의 맵 단계에서 쉼표로 구분 된 출력 디렉토리 목록.</target>
        </trans-unit>
        <trans-unit id="61793d8bd9e33c28cc217bbc7c2cb6a7eea07441" translate="yes" xml:space="preserve">
          <source>A comma-separated list of output directories in the reduce phase of the job.</source>
          <target state="translated">작업 감소 단계에서 쉼표로 구분 된 출력 디렉토리 목록.</target>
        </trans-unit>
        <trans-unit id="0000e651d4527588b9f8db3518abee606b9a87dc" translate="yes" xml:space="preserve">
          <source>A comma-separated list of parent job ids.</source>
          <target state="translated">쉼표로 구분 된 상위 작업 ID 목록.</target>
        </trans-unit>
        <trans-unit id="f385c6438eb9f52462767534cd6f16e64c841cab" translate="yes" xml:space="preserve">
          <source>A command enclosed in back ticks.</source>
          <target state="translated">백틱으로 둘러싸인 명령.</target>
        </trans-unit>
        <trans-unit id="805ad49a4f19334a85355ad5ba2ae54de725bdd4" translate="yes" xml:space="preserve">
          <source>A command, including the arguments, enclosed in back tics (where a command is anything that can be executed).</source>
          <target state="translated">백틱으로 묶인 인수를 포함한 명령 (명령은 실행할 수있는 항목)</target>
        </trans-unit>
        <trans-unit id="fa07b9464335d65a750e09b372bec9feda2d1916" translate="yes" xml:space="preserve">
          <source>A common error when using the star expression is shown below. In this example, the programmer really wants to count the number of elements in the bag in the second field: COUNT($1).</source>
          <target state="translated">별표 식을 사용할 때 일반적인 오류는 다음과 같습니다. 이 예에서 프로그래머는 실제로 두 번째 필드 인 COUNT ($ 1)에서 백의 요소 수를 계산하려고합니다.</target>
        </trans-unit>
        <trans-unit id="00bcc083976f535ab664d9214c52cc951dbaaaa2" translate="yes" xml:space="preserve">
          <source>A complete embedded example is shown below.</source>
          <target state="translated">완전한 임베디드 예제가 아래에 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="efb82d6054ee066b9551951d6694c109106e25b9" translate="yes" xml:space="preserve">
          <source>A constant in this form creates a bag.</source>
          <target state="translated">이 형식의 상수는 백을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="7d497ad618d11858535b2beb1fc2e6cd06f73c25" translate="yes" xml:space="preserve">
          <source>A constant in this form creates a map.</source>
          <target state="translated">이 형식의 상수는지도를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="cccd14b67f74f165bd674879862dbf10b7ad6938" translate="yes" xml:space="preserve">
          <source>A constant in this form creates a tuple.</source>
          <target state="translated">이 형식의 상수는 튜플을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="75d9df6342dbade45a131080b88fd6819b3f9cc2" translate="yes" xml:space="preserve">
          <source>A datetime object.</source>
          <target state="translated">날짜 / 시간 객체</target>
        </trans-unit>
        <trans-unit id="0ae14d48b464ce700e4a965788d019e60256c87d" translate="yes" xml:space="preserve">
          <source>A few examples are shown here:</source>
          <target state="translated">몇 가지 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="123892d269860ca6277fac81e102b37a4f829230" translate="yes" xml:space="preserve">
          <source>A field can be explicitly cast. Once cast, the field remains that type (it is not automatically cast back). In this example $0 is explicitly cast to int.</source>
          <target state="translated">필드를 명시 적으로 캐스트 할 수 있습니다. 캐스트되면 필드는 해당 유형으로 유지됩니다 (자동 캐스트되지는 않음). 이 예에서 $ 0은 명시 적으로 int로 캐스트됩니다.</target>
        </trans-unit>
        <trans-unit id="9fb8f35ba0661fba10d6dea09d707281921f8995" translate="yes" xml:space="preserve">
          <source>A field expression.</source>
          <target state="translated">필드 표현식.</target>
        </trans-unit>
        <trans-unit id="aa706d0814dbebff53da84a0b6f4417c372e46eb" translate="yes" xml:space="preserve">
          <source>A field in the relation. The field must be a simple type.</source>
          <target state="translated">관계의 필드. 필드는 단순 유형이어야합니다.</target>
        </trans-unit>
        <trans-unit id="fc6008145aef0c2d224ac6e17ef87405f8e0aae8" translate="yes" xml:space="preserve">
          <source>A field is a piece of data.</source>
          <target state="translated">필드는 데이터 조각입니다.</target>
        </trans-unit>
        <trans-unit id="9fc3f28e237313cf02898f477a2ffb09e078f79e" translate="yes" xml:space="preserve">
          <source>A kerberos keytab file is essentially a Kerberos specific form of the password of a user.</source>
          <target state="translated">kerberos 키탭 파일은 기본적으로 Kerberos 비밀번호 형식의 사용자 비밀번호입니다.</target>
        </trans-unit>
        <trans-unit id="e50ea98d727e7931c82262bdd217d56cbe1687cc" translate="yes" xml:space="preserve">
          <source>A list of Pig features used in the job.</source>
          <target state="translated">작업에 사용 된 Pig 기능 목록.</target>
        </trans-unit>
        <trans-unit id="e74c6ddf175f65dbe2e4bdca1ce68dadc7beeb50" translate="yes" xml:space="preserve">
          <source>A list of Pig features used in the script.</source>
          <target state="translated">스크립트에 사용 된 Pig 기능 목록입니다.</target>
        </trans-unit>
        <trans-unit id="7a41d00d81bdc1022b0ad1c528ff69e5cead1c42" translate="yes" xml:space="preserve">
          <source>A list of qualified HBase columns to read data from or store data to. The column family name and column qualifier are seperated by a colon (:). Only the columns used in the Pig script need to be specified. Columns are specified in one of three different ways as described below.</source>
          <target state="translated">데이터를 읽거나 저장할 데이터의 정규화 된 HBase 열 목록입니다. 열 제품군 이름과 열 한정자는 콜론 (:)으로 구분됩니다. Pig 스크립트에 사용 된 열만 지정하면됩니다. 열은 아래 설명과 같이 세 가지 방법 중 하나로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="7e902cecd9fe37236e0a773e727afcda3c69c7c8" translate="yes" xml:space="preserve">
          <source>A macro can be expanded inline using the macro expansion syntax. Note the following:</source>
          <target state="translated">매크로 확장 구문을 사용하여 매크로를 인라인으로 확장 할 수 있습니다. 다음에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="26ec494aec36a86f5f8adce5c0fc7d143ece7d7d" translate="yes" xml:space="preserve">
          <source>A macro can be imported from another Pig script (see &lt;a href=&quot;#import-macros&quot;&gt;IMPORT (macros)&lt;/a&gt;). Splitting your macros from your main Pig script is useful for making reusable code.</source>
          <target state="translated">다른 Pig 스크립트에서 매크로를 가져올 수 있습니다 ( &lt;a href=&quot;#import-macros&quot;&gt;IMPORT (매크로)&lt;/a&gt; 참조 ). 기본 Pig 스크립트에서 매크로를 분할하면 재사용 가능한 코드를 만드는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b57cbfcc1c2582caa6daa9ade7e0d13404ec7d35" translate="yes" xml:space="preserve">
          <source>A macro definition can appear anywhere in a Pig script as long as it appears prior to the first use. A macro definition can include references to other macros as long as the referenced macros are defined prior to the macro definition. Recursive references are not allowed.</source>
          <target state="translated">매크로 정의는 처음 사용하기 전에 Pig 스크립트의 어느 곳에 나 나타날 수 있습니다. 매크로 정의는 매크로 정의 전에 참조 된 매크로가 정의되어있는 한 다른 매크로에 대한 참조를 포함 할 수 있습니다. 재귀 참조는 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="61ee17df67479872c2ed93a2dbdbd9d5a6ddcab0" translate="yes" xml:space="preserve">
          <source>A map is a set of key value pairs.</source>
          <target state="translated">맵은 키 값 쌍 세트입니다.</target>
        </trans-unit>
        <trans-unit id="64c4816cd933b8f5cb3f45e8d353c336cba9b835" translate="yes" xml:space="preserve">
          <source>A map is a set of key/value pairs.</source>
          <target state="translated">맵은 키 / 값 쌍의 집합입니다.</target>
        </trans-unit>
        <trans-unit id="7258ee67ce78101192682e230e31fa604d28ae22" translate="yes" xml:space="preserve">
          <source>A map key must be a chararray; a map value can be any data type</source>
          <target state="translated">맵 키는 문자 배열이어야합니다. 지도 값은 모든 데이터 유형이 될 수 있습니다</target>
        </trans-unit>
        <trans-unit id="ea91ea858a83135a8f6c28648c84329d418aab67" translate="yes" xml:space="preserve">
          <source>A mathematical expression can be applied to one or more algebraic functions.</source>
          <target state="translated">수학적 표현은 하나 이상의 대수 함수에 적용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78eea890b003b34b759f5a34593b5a6f2500ee5a" translate="yes" xml:space="preserve">
          <source>A more general version of run allows to run one or more pipelines concurrently. In this case, a list of PigStats results is returned &amp;ndash; one for each pipeline run. The example in the previous section shows how to make use of this call.</source>
          <target state="translated">보다 일반적인 버전의 실행은 하나 이상의 파이프 라인을 동시에 실행할 수 있습니다. 이 경우 각 파이프 라인 실행에 대해 하나씩 PigStats 결과 목록이 반환됩니다. 이전 섹션의 예는이 호출을 사용하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="e295e6d6a3ffbde864687ddea682e20bf2956303" translate="yes" xml:space="preserve">
          <source>A new directory named pigtmp is created. This directory contains the &lt;a href=&quot;#pig-tutorial-files&quot;&gt;Pig Tutorial Files&lt;/a&gt;. These files work with Hadoop 0.20.2 and include everything you need to run &lt;a href=&quot;#pig-script-1&quot;&gt;Pig Script 1&lt;/a&gt; and &lt;a href=&quot;#pig-script-2&quot;&gt;Pig Script 2&lt;/a&gt;.</source>
          <target state="translated">pigtmp라는 새 디렉토리가 작성됩니다. 이 디렉토리에는 &lt;a href=&quot;#pig-tutorial-files&quot;&gt;Pig Tutorial Files가&lt;/a&gt; 있습니다. 이 파일은 Hadoop 0.20.2에서 작동하며 &lt;a href=&quot;#pig-script-1&quot;&gt;Pig Script 1&lt;/a&gt; 및 &lt;a href=&quot;#pig-script-2&quot;&gt;Pig Script 2&lt;/a&gt; 를 실행하는 데 필요한 모든 것을 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="1ec79c8f12d7cfa8a4c0dbb7e5b1a9c872182a01" translate="yes" xml:space="preserve">
          <source>A note on error handling. The ABS class covers the case of the bytearray which means the data has not been converted yet to its actual type. This is why a null value is returned when NumberFormatException is encountered. However, the IntAbs function is only called if the data is already of type Integer which means it has already been converted to the real type and bad format has been dealt with. This is why an exception is thrown if the input can't be cast to Integer.</source>
          <target state="translated">오류 처리에 대한 참고 사항. ABS 클래스는 바이트 배열의 경우를 다루며, 이는 데이터가 아직 실제 유형으로 변환되지 않았 음을 의미합니다. 이것이 NumberFormatException이 발생할 때 널값이 리턴되는 이유입니다. 그러나 IntAbs 함수는 데이터가 이미 Integer 유형 인 경우에만 호출됩니다. 즉, 이미 실제 유형으로 변환되어 잘못된 형식이 처리되었음을 의미합니다. 입력을 정수로 캐스트 할 수없는 경우 예외가 발생하는 이유입니다.</target>
        </trans-unit>
        <trans-unit id="d03fc0d0f769947694fc2093551afb4b86056066" translate="yes" xml:space="preserve">
          <source>A number of user frameworks do automated generation of Pig Latin.</source>
          <target state="translated">많은 사용자 프레임 워크가 Pig Latin의 자동 생성을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="a6e2301f77615d08b4da72bd79f32e7a3180c1c6" translate="yes" xml:space="preserve">
          <source>A parameter file will contain one line per parameter. Empty lines are allowed. Perl-style (#) comment lines are also allowed. Comments must take a full line and # must be the first character on the line. Each parameter line will be of the form: param_name = param_value. White spaces around = are allowed but are optional.</source>
          <target state="translated">매개 변수 파일에는 매개 변수 당 한 줄이 포함됩니다. 빈 줄이 허용됩니다. 펄 스타일 (#) 주석 행도 허용됩니다. 주석은 전체 줄을 사용해야하며 #은 줄의 첫 번째 문자 여야합니다. 각 매개 변수 행은 param_name = param_value 형식입니다. = 주위의 공백은 허용되지만 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="9a80c66616e2e3d13f4f497b2278fca443b5377a" translate="yes" xml:space="preserve">
          <source>A parameter value can take two forms:</source>
          <target state="translated">매개 변수 값은 두 가지 형식을 취할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4cb6f167a7abc0d4b5a30f71078daf483e975dc6" translate="yes" xml:space="preserve">
          <source>A piece of data. A field can be any data type (including tuple and bag).</source>
          <target state="translated">데이터 조각. 필드는 모든 데이터 유형 (튜플 및 백 포함)이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="773df31dce963b022a5020f1fe3dbf0d199647d3" translate="yes" xml:space="preserve">
          <source>A pig script. The pig script must be the last element in the Pig command line.</source>
          <target state="translated">돼지 대본. pig 스크립트는 Pig 명령 행에서 마지막 요소 여야합니다.</target>
        </trans-unit>
        <trans-unit id="e71379a6a039d724c1d8c024de32066cf65477b5" translate="yes" xml:space="preserve">
          <source>A prefix to pluck by or an regex pattern to pluck by</source>
          <target state="translated">뽑는 접두사 또는 뽑는 정규식 패턴</target>
        </trans-unit>
        <trans-unit id="5d1f61995d0f6b0ce09cf58ea2762ca7f9e00600" translate="yes" xml:space="preserve">
          <source>A registered script can contain multiple UDFs. UDFs can be static or instance methods, an instance of the enclosing class will be created as needed. Only methods for which a return schema is defined will be available in Pig.</source>
          <target state="translated">등록 된 스크립트는 여러 UDF를 포함 할 수 있습니다. UDF는 정적 또는 인스턴스 메소드 일 수 있으며, 필요에 따라 포함 클래스의 인스턴스가 작성됩니다. 리턴 스키마가 정의 된 메소드 만 Pig에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0908c688432cd2bb95c6f2a292b64c6e12e4032" translate="yes" xml:space="preserve">
          <source>A relation is a bag (more specifically, an outer bag).</source>
          <target state="translated">관계는 가방 (보다 구체적으로 외부 가방)입니다.</target>
        </trans-unit>
        <trans-unit id="8a8b0e4e4d4aa24a006794196d25b13e7e321432" translate="yes" xml:space="preserve">
          <source>A schema using the AS keyword (see &lt;a href=&quot;#schemas&quot;&gt;Schemas&lt;/a&gt;).</source>
          <target state="translated">AS 키워드를 사용하는 스키마 ( &lt;a href=&quot;#schemas&quot;&gt;스키마&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="fb733569248750ef6b316dc0b2d77175e9afd541" translate="yes" xml:space="preserve">
          <source>A schema using the AS keyword, enclosed in parentheses (see &lt;a href=&quot;#schemas&quot;&gt;Schemas&lt;/a&gt;).</source>
          <target state="translated">괄호로 묶인 AS 키워드를 사용하는 스키마 ( &lt;a href=&quot;#schemas&quot;&gt;스키마&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="16ab13290716636d04ae6a214e78385503fe56c4" translate="yes" xml:space="preserve">
          <source>A sequence of characters enclosed in single or double quotes. In this case the unquoted version of the value is used during substitution. Quotes within the value can be escaped with the backslash character ( \ ). Single word values that don't use special characters such as % or = don't have to be quoted.</source>
          <target state="translated">작은 따옴표 나 큰 따옴표로 묶은 일련의 문자. 이 경우 인용되지 않은 값의 값이 대체 중에 사용됩니다. 값 내의 따옴표는 백 슬래시 문자 (\)로 이스케이프 할 수 있습니다. % 또는 =와 같은 특수 문자를 사용하지 않는 단일 단어 값은 인용 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6339def20ad688dbc7bf13779b1d0b02e4d45332" translate="yes" xml:space="preserve">
          <source>A series of &quot;transformation&quot; statements to process the data.</source>
          <target state="translated">데이터를 처리하기위한 일련의 &quot;변환&quot;문.</target>
        </trans-unit>
        <trans-unit id="0c4ca1a84660a949e797751322cd717761766ea0" translate="yes" xml:space="preserve">
          <source>A set of key value pairs.</source>
          <target state="translated">키 값 쌍 세트.</target>
        </trans-unit>
        <trans-unit id="3fabc69c75464c67bc0be9c6ee42ba3bf511f291" translate="yes" xml:space="preserve">
          <source>A simple JavaScript UDF (udf.js) is shown here.</source>
          <target state="translated">간단한 JavaScript UDF (udf.js)가 여기에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="893bcf27c1bda8dc1237532d1016c3ca6ca31273" translate="yes" xml:space="preserve">
          <source>A single element enclosed in parens ( ) like (5) is not considered to be a tuple but rather an arithmetic operator.</source>
          <target state="translated">(5)와 같이 괄호 ()로 묶인 단일 요소는 튜플이 아니라 산술 연산자로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="45e1bab3a48891e766dd4ee748ee1488f7b38530" translate="yes" xml:space="preserve">
          <source>A special case of the best fit approach is handling data without a schema specified. The type for this data is interpreted as bytearray. Since the type of the data is not known, there is no way to choose a best fit version. The only time a cast is performed is when the function table contains only a single entry. This works well to maintain backward compatibility.</source>
          <target state="translated">가장 적합한 접근법의 특별한 경우는 스키마를 지정하지 않고 데이터를 처리하는 것입니다. 이 데이터의 유형은 바이트 배열로 해석됩니다. 데이터 유형을 알 수 없으므로 가장 적합한 버전을 선택할 수있는 방법이 없습니다. 캐스트가 수행되는 유일한 시간은 함수 테이블에 단일 항목 만 포함 된 경우입니다. 이것은 이전 버전과의 호환성을 유지하는 데 효과적입니다.</target>
        </trans-unit>
        <trans-unit id="616cd130501bb5fbe2871164a72f110820800df4" translate="yes" xml:space="preserve">
          <source>A string expression could look like this, where a and b are both chararrays:</source>
          <target state="translated">문자열 표현식은 다음과 같습니다. 여기서 a와 b는 모두 chararray입니다.</target>
        </trans-unit>
        <trans-unit id="5f40dad9fe6a338932233afc916151bad711fa2f" translate="yes" xml:space="preserve">
          <source>A string that contains space-separated options (&quot;optionA valueA -optionB valueB -optionC valueC&quot;)</source>
          <target state="translated">공백으로 구분 된 옵션이 포함 된 문자열 ( &quot;optionA valueA -optionB valueB -optionC valueC&quot;)</target>
        </trans-unit>
        <trans-unit id="3ea25cfc46e65e38049a2267e71c9872c2fb297c" translate="yes" xml:space="preserve">
          <source>A string that contains space-separated options (&amp;lsquo;-optionA valueA -optionB valueB -optionC &amp;rsquo;)</source>
          <target state="translated">공백으로 구분 된 옵션을 포함하는 문자열 ( '-optionA valueA -optionB valueB -optionC')</target>
        </trans-unit>
        <trans-unit id="35f565f1db59ef2251de20669a5d2050311259a8" translate="yes" xml:space="preserve">
          <source>A string that contains space-separated options (&amp;lsquo;-optionA valueA -optionB valueB -optionC &amp;rsquo;). Current options are only applicable with STORE operation and not for LOAD.</source>
          <target state="translated">공백으로 구분 된 옵션이 포함 된 문자열 ( '-optionA valueA -optionB valueB -optionC'). 현재 옵션은 STORE 조작에만 적용되며 LOAD에는 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1ea2f5a75b6ad1becc766903e2365acce6d41f1b" translate="yes" xml:space="preserve">
          <source>A string that contains space-separated options (&amp;lsquo;-optionA=valueA -optionB=valueB -optionC=valueC&amp;rsquo;)</source>
          <target state="translated">공백으로 구분 된 옵션이 포함 된 문자열 ( '-optionA = valueA -optionB = valueB -optionC = valueC')</target>
        </trans-unit>
        <trans-unit id="facce09053a818f2592ad9007001c4fd45de86e6" translate="yes" xml:space="preserve">
          <source>A string that contains space-separated options ('optionA optionB optionC')</source>
          <target state="translated">공백으로 구분 된 옵션이 포함 된 문자열 ( 'optionA optionB optionC')</target>
        </trans-unit>
        <trans-unit id="ae060f37ac2d2a0cc1a625c5fb7e8df41de2f7d0" translate="yes" xml:space="preserve">
          <source>A sub-use case of automated generation is conditional code generation. Different processing might be required based on whether this is weekday or a weekend.</source>
          <target state="translated">자동화 된 생성의 하위 사용 사례는 조건부 코드 생성입니다. 이것이 주중인지 주말인지에 따라 다른 처리가 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a67a8fe703ac46c47cbd5b59a50e4f1763e716de" translate="yes" xml:space="preserve">
          <source>A tuple (see Tuple Schema).</source>
          <target state="translated">튜플 (튜플 스키마 참조)</target>
        </trans-unit>
        <trans-unit id="63c1f1d1e983ff5188b8f3db7772ebceddb8e07a" translate="yes" xml:space="preserve">
          <source>A tuple can contain fields of any data type</source>
          <target state="translated">튜플은 모든 데이터 유형의 필드를 포함 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="e4609821d15f67129c64cc09ba74d9fdbc210998" translate="yes" xml:space="preserve">
          <source>A tuple expression. This is the group key or key field. If the result of the tuple expression is a single field, the key will be the value of the first field rather than a tuple with one field. To group using multiple keys, enclose the keys in parentheses:</source>
          <target state="translated">튜플 식. 그룹 키 또는 키 필드입니다. 튜플 표현식의 결과가 단일 필드 인 경우 키는 하나의 필드가있는 튜플이 아니라 첫 번째 필드의 값이됩니다. 여러 키를 사용하여 그룹화하려면 키를 괄호로 묶습니다.</target>
        </trans-unit>
        <trans-unit id="d315affd83b8669f2ec958297a627223d6067676" translate="yes" xml:space="preserve">
          <source>A tuple is an ordered set of fields.</source>
          <target state="translated">튜플은 정렬 된 필드 집합입니다.</target>
        </trans-unit>
        <trans-unit id="98b20221c08a9f19dd0d020d5df9d9e408df795a" translate="yes" xml:space="preserve">
          <source>A tuple is enclosed in parentheses ( ).</source>
          <target state="translated">튜플은 괄호 ()로 묶습니다.</target>
        </trans-unit>
        <trans-unit id="3367986d800b6d8c7dd0d197a276a527451920b5" translate="yes" xml:space="preserve">
          <source>A tuple may be assigned to more than one relation.</source>
          <target state="translated">튜플은 둘 이상의 관계에 할당 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9075ce8ecf14e4ba1991fe6a511755e285ba1eff" translate="yes" xml:space="preserve">
          <source>A tuple may not be assigned to any relation.</source>
          <target state="translated">튜플은 어떤 관계에도 할당 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="edb3bf6931fd4997cd09560122dce45699a6a483" translate="yes" xml:space="preserve">
          <source>A tuple.</source>
          <target state="translated">튜플.</target>
        </trans-unit>
        <trans-unit id="1407730f7daac97bc524c2ae142070d2aa103c1e" translate="yes" xml:space="preserve">
          <source>A typical test.py looks like this:</source>
          <target state="translated">전형적인 test.py는 다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="b299a842bb72461f708b9f6f8cd8932a22cf444a" translate="yes" xml:space="preserve">
          <source>ABS</source>
          <target state="translated">ABS</target>
        </trans-unit>
        <trans-unit id="048e2664c9354295e54b349d5db850129a42e2fb" translate="yes" xml:space="preserve">
          <source>ABS(expression)</source>
          <target state="translated">ABS(expression)</target>
        </trans-unit>
        <trans-unit id="f47f10ba5ea545caa0a421972fc7fe1f9c136d03" translate="yes" xml:space="preserve">
          <source>ACOS</source>
          <target state="translated">ACOS</target>
        </trans-unit>
        <trans-unit id="a932d7782cdda17aad5092ecd4134612c9b80aeb" translate="yes" xml:space="preserve">
          <source>ACOS(expression)</source>
          <target state="translated">ACOS(expression)</target>
        </trans-unit>
        <trans-unit id="6b42874e3cd20771d93096ec5ce36307a1f2ba14" translate="yes" xml:space="preserve">
          <source>ALL</source>
          <target state="translated">ALL</target>
        </trans-unit>
        <trans-unit id="c2f934cb8cab6c1b3af0d4f2fdd824eabafb6bf4" translate="yes" xml:space="preserve">
          <source>AND</source>
          <target state="translated">AND</target>
        </trans-unit>
        <trans-unit id="b8931af0442bf3cfe6e5ca97340930a428af0354" translate="yes" xml:space="preserve">
          <source>API change</source>
          <target state="translated">API 변경</target>
        </trans-unit>
        <trans-unit id="d00bb3f3b7c7b8815b6dcf237dd16aab9744eca8" translate="yes" xml:space="preserve">
          <source>AS</source>
          <target state="translated">AS</target>
        </trans-unit>
        <trans-unit id="eaffec78401451424652480dc382235348ce1b66" translate="yes" xml:space="preserve">
          <source>ASC</source>
          <target state="translated">ASC</target>
        </trans-unit>
        <trans-unit id="f19e5c9ef1b1dea16be6bcc72d835cd9e7afcc13" translate="yes" xml:space="preserve">
          <source>ASIN</source>
          <target state="translated">ASIN</target>
        </trans-unit>
        <trans-unit id="cb81e8dc30e50bf9341d5b3dc90da44d34f4b391" translate="yes" xml:space="preserve">
          <source>ASIN(expression)</source>
          <target state="translated">ASIN(expression)</target>
        </trans-unit>
        <trans-unit id="a3a5eee11eff02ce7d4eb6baf308a0819841a071" translate="yes" xml:space="preserve">
          <source>ASSERT</source>
          <target state="translated">ASSERT</target>
        </trans-unit>
        <trans-unit id="405a2f957e74aa844d8005a6ad35cdae3f66b5fe" translate="yes" xml:space="preserve">
          <source>ASSERT alias BY expression [, message];</source>
          <target state="translated">ASSERT 별명 BY 표현식 [, 메시지];</target>
        </trans-unit>
        <trans-unit id="0e3ba08070893718cd81942a382b31503c5b0d40" translate="yes" xml:space="preserve">
          <source>ATAN</source>
          <target state="translated">ATAN</target>
        </trans-unit>
        <trans-unit id="9f5502491ddc49820674d54a656fbc1059435282" translate="yes" xml:space="preserve">
          <source>ATAN(expression)</source>
          <target state="translated">ATAN(expression)</target>
        </trans-unit>
        <trans-unit id="1e822fce89fdee36d7476135922e827796665f61" translate="yes" xml:space="preserve">
          <source>AVG</source>
          <target state="translated">AVG</target>
        </trans-unit>
        <trans-unit id="cc413ad48ffd82510d01c5456e9960d443f127a5" translate="yes" xml:space="preserve">
          <source>AVG(expression)</source>
          <target state="translated">AVG(expression)</target>
        </trans-unit>
        <trans-unit id="e89f6bfc8c281a94aafa7d499a6c1938370c93fe" translate="yes" xml:space="preserve">
          <source>AVG, MIN, MAX, SUM, COUNT</source>
          <target state="translated">AVG, MIN, MAX, SUM, COUNT</target>
        </trans-unit>
        <trans-unit id="688b5ed88ded7fc740b351bceeeb3aa33c240741" translate="yes" xml:space="preserve">
          <source>About Auto-Ship</source>
          <target state="translated">자동 배송 정보</target>
        </trans-unit>
        <trans-unit id="33dddcfcf9e988deaabaf262ebe4517d04940220" translate="yes" xml:space="preserve">
          <source>About Cache</source>
          <target state="translated">캐시 정보</target>
        </trans-unit>
        <trans-unit id="1764db62d3d61ccbef1be09dd8cc27bbc797bd16" translate="yes" xml:space="preserve">
          <source>About Data Guarantees</source>
          <target state="translated">데이터 보증 정보</target>
        </trans-unit>
        <trans-unit id="490856f088148164781b72756cd1bb8de8961230" translate="yes" xml:space="preserve">
          <source>About Input and Output for Streaming</source>
          <target state="translated">스트리밍 입력 및 출력 정보</target>
        </trans-unit>
        <trans-unit id="c330f41d323af212e32c40208bd8dc127a6c335e" translate="yes" xml:space="preserve">
          <source>About Ship</source>
          <target state="translated">선박에 대하여</target>
        </trans-unit>
        <trans-unit id="3a355c192bdd7f52b6199943ee1cf5204478f8e0" translate="yes" xml:space="preserve">
          <source>Acceptable values (case insensitive): very_low, low, normal, high, very_high</source>
          <target state="translated">허용되는 값 (대소 문자 구분) : 매우 낮음, 낮음, 보통, 높음, 매우 높음</target>
        </trans-unit>
        <trans-unit id="80f3cc503e6f9433ac35d59bedfa29091958f4aa" translate="yes" xml:space="preserve">
          <source>Accepts no arguments or accepts some combination of strings, ints, longs, doubles, floats, or arrays with these same types</source>
          <target state="translated">인수가 없거나 문자열, 정수, long, double, float 또는 이와 동일한 유형의 배열 조합을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="827ac1ff22b445d7dc284c306314ec9e45637678" translate="yes" xml:space="preserve">
          <source>Access input schema inside EvalFunc</source>
          <target state="translated">EvalFunc 내부의 액세스 입력 스키마</target>
        </trans-unit>
        <trans-unit id="a5c6285b2607f6eac866d9e76869ecd05921656a" translate="yes" xml:space="preserve">
          <source>Accessing Functions</source>
          <target state="translated">기능에 액세스</target>
        </trans-unit>
        <trans-unit id="83fc869b8dfebec1ad8537cadadb36ddd351acfa" translate="yes" xml:space="preserve">
          <source>Accessing a field that does not exist in a tuple.</source>
          <target state="translated">튜플에 존재하지 않는 필드에 액세스</target>
        </trans-unit>
        <trans-unit id="6f2a8ef4e2c793a0970ebbc1884144240edb8f43" translate="yes" xml:space="preserve">
          <source>Accumulator Interface</source>
          <target state="translated">누산기 인터페이스</target>
        </trans-unit>
        <trans-unit id="91000928d3d1a3f0bc3141391cf6779603b61e84" translate="yes" xml:space="preserve">
          <source>AccumuloStorage</source>
          <target state="translated">AccumuloStorage</target>
        </trans-unit>
        <trans-unit id="fd52c22fc515f9f913aeead4863415621666ea8d" translate="yes" xml:space="preserve">
          <source>AccumuloStorage has the functionality to store or fetch data from Accumulo. Its goal is to provide a simple, widely applicable table schema compatible with Pig's API. Each Tuple contains some subset of the columns stored within one row of the Accumulo table, which depends on the columns provided as an argument to the function. If '*' is provided, all columns in the table will be returned. The second argument provides control over a variety of options that can be used to change various properties.</source>
          <target state="translated">AccumuloStorage에는 Accumulo에서 데이터를 저장하거나 가져 오는 기능이 있습니다. 그 목표는 Pig의 API와 호환되는 간단하고 광범위하게 적용 가능한 테이블 스키마를 제공하는 것입니다. 각 Tuple에는 Accumulo 테이블의 한 행에 저장된 열의 일부 서브 세트가 포함되어 있으며 이는 함수에 대한 인수로 제공된 열에 따라 다릅니다. '*'가 제공되면 테이블의 모든 열이 반환됩니다. 두 번째 인수는 다양한 속성을 변경하는 데 사용할 수있는 다양한 옵션을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="e39526d6417e24040a60b14ef1dc27adfa4ca744" translate="yes" xml:space="preserve">
          <source>AccumuloStorage(['columns'[, 'options']])</source>
          <target state="translated">AccumuloStorage ([ '열'[, '옵션']])</target>
        </trans-unit>
        <trans-unit id="026092b14552a1dba55662ba35fa94a02ba85151" translate="yes" xml:space="preserve">
          <source>Add /pig-n.n.n/bin to your path. Use export (bash,sh,ksh) or setenv (tcsh,csh). For example:</source>
          <target state="translated">경로에 / pig-nnn / bin을 추가하십시오. 내보내기 (bash, sh, ksh) 또는 setenv (tcsh, csh)를 사용하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fff0e4e06b6e4951bebdf68e6f56d5c80c559956" translate="yes" xml:space="preserve">
          <source>Add a standalone utility that reads test configurations and generates a test report.</source>
          <target state="translated">테스트 구성을 읽고 테스트 보고서를 생성하는 독립형 유틸리티를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="770af2537bc246afc476bc49910562b1ada227e6" translate="yes" xml:space="preserve">
          <source>Add pig.jar to your ClassPath: export CLASSPATH=$CLASSPATH:/path/to/pig.jar</source>
          <target state="translated">ClassPath에 pig.jar를 추가하십시오. export CLASSPATH = $ CLASSPATH : /path/to/pig.jar</target>
        </trans-unit>
        <trans-unit id="d0e63264a1549aaad7af31b38b59ef58d2efa69a" translate="yes" xml:space="preserve">
          <source>Add the notion of workspaces for each test.</source>
          <target state="translated">각 테스트에 대한 작업 공간 개념을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="ebc1acc42ec21ba0feacb30430a752b73b122400" translate="yes" xml:space="preserve">
          <source>AddDuration</source>
          <target state="translated">AddDuration</target>
        </trans-unit>
        <trans-unit id="99cd110176a3fb3ff89934ae9fb2463d2d8166f2" translate="yes" xml:space="preserve">
          <source>AddDuration(datetime, duration)</source>
          <target state="translated">AddDuration (날짜 / 시간)</target>
        </trans-unit>
        <trans-unit id="1719dd6213fee3044c8ed159419ae9c826fd25ac" translate="yes" xml:space="preserve">
          <source>AddForEach</source>
          <target state="translated">AddForEach</target>
        </trans-unit>
        <trans-unit id="ea3e4bece31a50648fa25abff664db81d479d76b" translate="yes" xml:space="preserve">
          <source>Additionally, JAR files stored in local file systems can be specified as a glob pattern using &amp;ldquo;*&amp;rdquo;. Pig will search for matching jars in the local file system, either the relative path (relative to your working directory) or the absolute path. Pig will pick up all JARs that match the glob.</source>
          <target state="translated">또한 로컬 파일 시스템에 저장된 JAR 파일은&amp;ldquo;*&amp;rdquo;를 사용하여 glob 패턴으로 지정할 수 있습니다. Pig는 로컬 파일 시스템에서 상대 경로 (작업 디렉토리에 상대적인) 또는 절대 경로와 일치하는 jar을 검색합니다. Pig는 글로브와 일치하는 모든 JAR을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="0e467e1a630374f0b9e445ee4d3f531f7ff90e1f" translate="yes" xml:space="preserve">
          <source>Additionally, if the schema option is specified, a &quot;.pig_headers&quot; file is created in the output directory. This file simply lists the delimited aliases. This is intended to make export to tools that can read files with header lines easier (just cat the header to your data).</source>
          <target state="translated">또한 스키마 옵션이 지정되면 &quot;.pig_headers&quot;파일이 출력 디렉토리에 작성됩니다. 이 파일은 단순히 구분 된 별명을 나열합니다. 이것은 헤더 행이있는 파일을보다 쉽게 ​​읽을 수있는 도구로 내보내기위한 것입니다 (헤더를 데이터로 분류).</target>
        </trans-unit>
        <trans-unit id="56c4f9b02bc11176ae7a383c22de55f892454d8e" translate="yes" xml:space="preserve">
          <source>Additionally, suppose that you don't need the value of the field &quot;marketingPlans.&quot; (That's a good thing, because AvroStorage doesn't know how to translate that Avro schema to a Pig schema). To load only the fieds &quot;label&quot; and &quot;value&quot; into Pig, you can manually specify the schema passed to AvroStorage:</source>
          <target state="translated">또한 &quot;marketingPlans&quot;필드의 값이 필요하지 않다고 가정하십시오. AvroStorage는 해당 Avro 스키마를 Pig 스키마로 변환하는 방법을 모르기 때문에 좋은 일입니다. Fieds &quot;label&quot;및 &quot;value&quot;만 Pig에로드하기 위해 AvroStorage에 전달 된 스키마를 수동으로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8be3d1264310c3b8c848d4b90d5206179a40cc4" translate="yes" xml:space="preserve">
          <source>Administration</source>
          <target state="translated">Administration</target>
        </trans-unit>
        <trans-unit id="0d7049ed333121f6ad65eac902c5a2d1cec948e8" translate="yes" xml:space="preserve">
          <source>Advanced Topics</source>
          <target state="translated">고급 주제</target>
        </trans-unit>
        <trans-unit id="3411e1274464dc23220433c0c18601550e837de3" translate="yes" xml:space="preserve">
          <source>After JOIN, COGROUP, CROSS, or FLATTEN operations, the field names have the orginial alias and the disambiguate operator ( :: ) prepended in the schema. The disambiguate operator is used to identify field names in case there is a ambiguity.</source>
          <target state="translated">JOIN, COGROUP, CROSS 또는 FLATTEN 조작 후 필드 이름에는 스키마에 원래 별명과 명확한 연산자 (::)가 붙습니다. 명확성 연산자는 모호성이있는 경우 필드 이름을 식별하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c2212bb5b31f6c651e515ed01848b43575e405bf" translate="yes" xml:space="preserve">
          <source>After running native.jar's MapReduce/Tez job, load back the data from outputLocation into alias1 using loadFunc as schema.</source>
          <target state="translated">native.jar의 MapReduce / Tez 작업을 실행 한 후 loadFunc를 스키마로 사용하여 outputLocation의 데이터를 alias1로 다시로드하십시오.</target>
        </trans-unit>
        <trans-unit id="558d7aad6e94b62a3c3d222979b260b60b6db7d2" translate="yes" xml:space="preserve">
          <source>Aggregate Functions</source>
          <target state="translated">집계 함수</target>
        </trans-unit>
        <trans-unit id="5dc88dea8bd727663907c1cebd466dc8714656dd" translate="yes" xml:space="preserve">
          <source>Aggregate functions are another common type of eval function. Aggregate functions are usually applied to grouped data, as shown in this script:</source>
          <target state="translated">집계 함수는 또 다른 일반적인 유형의 평가 함수입니다. 이 스크립트에 표시된 것처럼 집계 함수는 일반적으로 그룹화 된 데이터에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="7679232959289bbae9adf1bd0901f5e7caaed60f" translate="yes" xml:space="preserve">
          <source>Algebraic Interface</source>
          <target state="translated">대수 인터페이스</target>
        </trans-unit>
        <trans-unit id="2a985458724fdd6d4d45335864f403da7085d78b" translate="yes" xml:space="preserve">
          <source>Algebraic UDFs are declared using three annotations, @AlgebraicInitial, @AlgebraicIntermed and @AlgebraicFinal which are to annotate methods that correspond to the initial, intermed and final steps of an Algebraic UDF. Those annotations have a single parameter which is the name of the Algebraic UDF that will be available in Pig. The methods annotated with @AlgebraicInitial and @AlgebraicIntermed accept a Tuple as parameter and return a Tuple. The return type of the method annotated with @AlgebraicFinal will determine the return type of the Algebraic UDF. Here is an example of an Algebraic UDF named 'sum' defined in Groovy:</source>
          <target state="translated">대수 UDF는 대수 UDF의 초기, 상호 작용 및 최종 단계에 해당하는 메소드에 주석을 달 수있는 @AlgebraicInitial, @AlgebraicIntermed 및 @AlgebraicFinal의 세 가지 주석을 사용하여 선언됩니다. 이러한 주석에는 Pig에서 사용할 수있는 대수 UDF의 이름 인 단일 매개 변수가 있습니다. @AlgebraicInitial 및 @AlgebraicIntermed로 주석이 달린 메소드는 Tuple을 매개 변수로 승인하고 Tuple을 리턴합니다. @AlgebraicFinal로 주석이 달린 메소드의 리턴 유형은 대수 UDF의 리턴 유형을 판별합니다. 다음은 Groovy에 정의 된 'sum'이라는 대수 UDF의 예입니다.</target>
        </trans-unit>
        <trans-unit id="b6edd45e987f0ed0d85e74746d2a6d3e95dcd545" translate="yes" xml:space="preserve">
          <source>All Pig and Hadoop properties can be set, either in the Pig script or via the Grunt command line.</source>
          <target state="translated">모든 Pig 및 Hadoop 속성은 Pig 스크립트 또는 Grunt 명령 줄을 통해 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d08a8676a973b43456513906eacd72c45acef6f" translate="yes" xml:space="preserve">
          <source>All Pig-specific classes are available &lt;a href=&quot;http://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/data/&quot;&gt; here&lt;/a&gt;.</source>
          <target state="translated">모든 돼지 관련 클래스는 &lt;a href=&quot;http://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/data/&quot;&gt;여기에서&lt;/a&gt; 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4a25b830ba6d0f5f7ab3d9dd8c90173750a7e162" translate="yes" xml:space="preserve">
          <source>All Pig-specific classes are available &lt;a href=&quot;https://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/data/&quot;&gt; here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bda14f8ed880d576aea6acd30f152878e631a85" translate="yes" xml:space="preserve">
          <source>All clauses are optional.</source>
          <target state="translated">모든 조항은 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="52866c68b176a22bffc55098219cfb2139614a29" translate="yes" xml:space="preserve">
          <source>All data types have corresponding &lt;a href=&quot;#schemas&quot;&gt;schemas&lt;/a&gt;.</source>
          <target state="translated">모든 데이터 유형에는 해당 &lt;a href=&quot;#schemas&quot;&gt;스키마가&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a94a083db09fe10617ef778dd6b946b8778998f" translate="yes" xml:space="preserve">
          <source>All other loaders must implement IndexableLoadFunc.</source>
          <target state="translated">다른 모든 로더는 IndexableLoadFunc를 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="37204ac26327fe13d3535221456cf819261dca6e" translate="yes" xml:space="preserve">
          <source>All other loaders must implement {IndexableLoadFunc}.</source>
          <target state="translated">다른 모든 로더는 {IndexableLoadFunc}를 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="1649736238965cf6cbe3f1ce8176b0809769d17f" translate="yes" xml:space="preserve">
          <source>All properties that Pig collects, including Hadoop properties, are available to any UDF via the UDFContext object. To get access to the properties, you can call the getJobConf method.</source>
          <target state="translated">Hadoop 속성을 포함하여 Pig가 수집하는 모든 속성은 UDFContext 개체를 통해 모든 UDF에서 사용할 수 있습니다. 특성에 액세스하기 위해 getJobConf 메소드를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34e9ee473e55595434c70943d0294704e486295a" translate="yes" xml:space="preserve">
          <source>All three APIs (compile, bind, run) discussed in the previous section have several versions depending on what you are trying to do.</source>
          <target state="translated">이전 섹션에서 설명한 세 가지 API (컴파일, 바인드, 실행)에는 수행하려는 작업에 따라 여러 버전이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9189f01c84538aeb8fe2058b57efd08869ddf98" translate="yes" xml:space="preserve">
          <source>Allowed operations are CROSS, DISTINCT, FILTER, FOREACH, LIMIT, and ORDER BY.</source>
          <target state="translated">허용되는 작업은 CROSS, DISTINCT, FILTER, FOREACH, LIMIT 및 ORDER BY입니다.</target>
        </trans-unit>
        <trans-unit id="064fef4cada996e33dcdd96986591f596a362700" translate="yes" xml:space="preserve">
          <source>Allows multiple outputs from a job. This way some results can be stored as a side-effect of the main job. This is also necessary to make the previous item work.</source>
          <target state="translated">작업에서 여러 출력을 허용합니다. 이런 식으로 일부 결과는 주 작업의 부작용으로 저장 될 수 있습니다. 이전 항목을 작동시키는 데에도 필요합니다.</target>
        </trans-unit>
        <trans-unit id="e12692334c3c5525a0d48b6d1b5840b8921a6aea" translate="yes" xml:space="preserve">
          <source>Allows multiple split branches to be carried on to the combiner/reducer. This reduces the amount of IO again in the case where multiple branches in the split can benefit from a combiner run.</source>
          <target state="translated">결합기 / 감쇄기로 여러 분할 분기를 수행 할 수 있습니다. 이렇게하면 분할의 여러 분기가 결합기 실행의 이점을 얻을 수있는 경우 IO의 양이 다시 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="48bab0518d388537ab6c75f976fe1bbfd92fac6d" translate="yes" xml:space="preserve">
          <source>Allows the user to specify a string prefix, and then filter for the columns in a relation that begin with that prefix or match that regex pattern. Optionally, include flag 'false' to filter for columns that do not match that prefix or match that regex pattern</source>
          <target state="translated">사용자가 문자열 접두사를 지정한 다음 해당 접두사로 시작하거나 해당 정규식 패턴과 일치하는 관계의 열을 필터링 할 수 있습니다. 선택적으로 접두사와 일치하지 않거나 해당 정규 표현식 패턴과 일치하지 않는 열을 필터링하려면 플래그 'false'를 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="9ffc1e1be5812001859ce766748be490fbad1908" translate="yes" xml:space="preserve">
          <source>Allows you to use a custom converter to perform the casting.</source>
          <target state="translated">캐스팅을 수행하기 위해 사용자 정의 변환기를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="09dd0087984c1a05a19bdd64fef04e19d4e9f25f" translate="yes" xml:space="preserve">
          <source>Also note that direct-fetch doesn't support UDFs that interact with the distributed cache. You can check if the query can be fetched by running EXPLAIN. You should see &quot;No MR jobs. Fetch only.&quot; in the MapReduce part of the plan.</source>
          <target state="translated">또한 직접 가져 오기는 분산 캐시와 상호 작용하는 UDF를 지원하지 않습니다. EXPLAIN을 실행하여 쿼리를 가져올 수 있는지 확인할 수 있습니다. &quot;MR 작업 없음. 가져 오기만&quot;이 표시되어야합니다. 계획의 MapReduce 부분에서.</target>
        </trans-unit>
        <trans-unit id="c54969d703b7d67d8a437c8561c518e2a75e6f1a" translate="yes" xml:space="preserve">
          <source>Also note that relations are unordered which means there is no guarantee that tuples are processed in any particular order. Furthermore, processing may be parallelized in which case tuples are not processed according to any total ordering.</source>
          <target state="translated">또한 관계가 정렬되지 않았으므로 튜플이 특정 순서로 처리된다는 보장이 없습니다. 또한, 튜플은 임의의 총 순서에 따라 처리되지 않는 처리가 병렬화 될 수있다.</target>
        </trans-unit>
        <trans-unit id="806ef2702e2ab9811c86f77f15cb4642d9ef6f34" translate="yes" xml:space="preserve">
          <source>Also note that the flatten of empty bag will result in that row being discarded; no output is generated. (See also &lt;a href=&quot;perf#nulls&quot;&gt;Drop Nulls Before a Join&lt;/a&gt;.)</source>
          <target state="translated">또한 빈 백을 평평하게하면 해당 행이 폐기됩니다. 출력이 생성되지 않습니다. ( &lt;a href=&quot;perf#nulls&quot;&gt;조인 전에 널 삭제를&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="691f430062ab748248a00dd18ab1311dbf9993e2" translate="yes" xml:space="preserve">
          <source>Also see &lt;a href=&quot;#bag-schema&quot;&gt;bag schemas&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#bag-schema&quot;&gt;백 스키마&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1aed7d8b239aabc38e2f28d25738b44c15bad97d" translate="yes" xml:space="preserve">
          <source>Also see &lt;a href=&quot;#map-schema&quot;&gt;map schemas&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#map-schema&quot;&gt;맵 스키마&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ea1ec2dbc255a96cf9b9ff7dbfe8524bfecf7324" translate="yes" xml:space="preserve">
          <source>Also see &lt;a href=&quot;#tuple-schema&quot;&gt;tuple schemas&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#tuple-schema&quot;&gt;튜플 스키마&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3778d1438a9ce1bf5b5fb3e8222569f3f2b06c51" translate="yes" xml:space="preserve">
          <source>Also, note that lines 9-10 check if the input data is null or empty and if so returns null.</source>
          <target state="translated">또한 9-10 행은 입력 데이터가 null인지 또는 비어 있는지 확인하고 그렇다면 null을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fab33a082c3999c94a272db6a8fd55630557a897" translate="yes" xml:space="preserve">
          <source>Alternatively, use the PARALLEL clause to set the number of reducers at the operator level. (In a script, the value set via the PARALLEL clause will override any value set via &quot;set default parallel.&quot;) You can include the PARALLEL clause with any operator that starts a reduce phase: &lt;a href=&quot;basic#cogroup&quot;&gt;COGROUP&lt;/a&gt;, &lt;a href=&quot;basic#cross&quot;&gt;CROSS&lt;/a&gt;, &lt;a href=&quot;basic#distinct&quot;&gt;DISTINCT&lt;/a&gt;, &lt;a href=&quot;basic#group&quot;&gt;GROUP&lt;/a&gt;, &lt;a href=&quot;basic#join-inner&quot;&gt;JOIN (inner)&lt;/a&gt;, &lt;a href=&quot;basic#join-outer&quot;&gt;JOIN (outer)&lt;/a&gt;, and &lt;a href=&quot;basic#order-by&quot;&gt;ORDER BY&lt;/a&gt;. PARALLEL clause can also be used with &lt;a href=&quot;basic#union&quot;&gt;UNION&lt;/a&gt; if Tez is the execution mode. It will turn off the union optimization and introduce an extra reduce step. Though it will have slightly degraded performance due to the extra step, it is very useful for controlling the number of output files.</source>
          <target state="translated">또는 PARALLEL 절을 사용하여 운전자 레벨에서 감속기 수를 설정하십시오. 스크립트에서 PARALLEL 절을 통해 설정된 값은 &quot;set default parallel&quot;을 통해 설정된 값을 겹쳐 씁니다. 감소 단계를 시작하는 모든 연산자에 PARALLEL 절을 포함시킬 수 있습니다. &lt;a href=&quot;basic#cogroup&quot;&gt;COGROUP&lt;/a&gt; , &lt;a href=&quot;basic#cross&quot;&gt;CROSS&lt;/a&gt; , &lt;a href=&quot;basic#distinct&quot;&gt;DISTINCT&lt;/a&gt; , &lt;a href=&quot;basic#group&quot;&gt;GROUP&lt;/a&gt; , &lt;a href=&quot;basic#join-inner&quot;&gt;JOIN ( inner)&lt;/a&gt; , &lt;a href=&quot;basic#join-outer&quot;&gt;JOIN (outer)&lt;/a&gt; 및 &lt;a href=&quot;basic#order-by&quot;&gt;ORDER BY&lt;/a&gt; 입니다. PARALLEL 절은 &lt;a href=&quot;basic#union&quot;&gt;UNION&lt;/a&gt; 과 함께 사용할 수도 있습니다Tez가 실행 모드 인 경우 통합 최적화를 끄고 추가 축소 단계를 도입합니다. 추가 단계로 인해 성능이 약간 저하되지만 출력 파일 수를 제어하는 ​​데 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="69cb19b42c32df761a2636d74ed20f44de653689" translate="yes" xml:space="preserve">
          <source>An aggregate function is an eval function that takes a bag and returns a scalar value. One interesting and useful property of many aggregate functions is that they can be computed incrementally in a distributed fashion. We call these functions algebraic. COUNT is an example of an algebraic function because we can count the number of elements in a subset of the data and then sum the counts to produce a final output. In the Hadoop world, this means that the partial computations can be done by the map and combiner, and the final result can be computed by the reducer.</source>
          <target state="translated">집계 함수는 백을 가져오고 스칼라 값을 반환하는 평가 함수입니다. 많은 집계 함수의 흥미롭고 유용한 속성 중 하나는 분산 방식으로 점진적으로 계산할 수 있다는 것입니다. 우리는이 함수들을 대수적이라고 부릅니다. COUNT는 대수 함수의 예입니다. 데이터 하위 집합의 요소 수를 계산 한 다음 그 수를 합산하여 최종 출력을 생성 할 수 있기 때문입니다. 하둡 세계에서 이것은 부분 계산이 맵과 컴 바이 너에 의해 수행 될 수 있고 최종 결과는 감속기에 의해 계산 될 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0805876187d13609e894b7732a388f570576b930" translate="yes" xml:space="preserve">
          <source>An algebraic function (COUNT) can be applied to another algebraic function (Distinct), but only the inner function is computed using the combiner.</source>
          <target state="translated">대수 함수 (COUNT)는 다른 대수 함수 (고유)에 적용될 수 있지만 결합기를 사용하여 내부 함수 만 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="d69e1629242857af79f46c3d7216edf3c504a19a" translate="yes" xml:space="preserve">
          <source>An arithmetic expression could look like this:</source>
          <target state="translated">산술 표현식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="210a656d0292e76bf7c2058d0781388d76953727" translate="yes" xml:space="preserve">
          <source>An asterisk can be used when requesting columns to group a collection of columns into a single Map instead of enumerating each column.</source>
          <target state="translated">열을 요청하여 각 열을 열거하는 대신 열 컬렉션을 단일 맵으로 그룹화 할 때 별표를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a0c24392d1b0e9eb921b05502a349cd0a705946" translate="yes" xml:space="preserve">
          <source>An collection of tuples.</source>
          <target state="translated">튜플 모음.</target>
        </trans-unit>
        <trans-unit id="39693f8f0517c3a65c4a9ef6a91ee2eb5b035429" translate="yes" xml:space="preserve">
          <source>An error that affects a particular row but is not likely to impact other rows. An example of such an error would be a malformed input value or divide by zero problem. A reasonable handling of this situation would be to emit a warning and return a null value. ABS function in the next section demonstrates this approach. The current approach is to write the warning to stderr. Eventually we would like to pass a logger to the UDFs. Note that returning a NULL value only makes sense if the malformed value is of type bytearray. Otherwise the proper type has been already created and should have an appropriate value. If this is not the case, it is an internal error and should cause the system to fail. Both cases can be seen in the implementation of the ABS function in the next section.</source>
          <target state="translated">특정 행에는 영향을 주지만 다른 행에는 영향을 미치지 않는 오류입니다. 이러한 오류의 예로는 잘못된 입력 값 또는 0으로 나누기 문제가 있습니다. 이 상황을 합리적으로 처리하려면 경고를 표시하고 null 값을 반환해야합니다. 다음 섹션의 ABS 기능은 이러한 접근 방식을 보여줍니다. 현재 접근 방식은 stderr에 경고를 작성하는 것입니다. 결국 로거를 UDF에 전달하려고합니다. NULL 값을 반환하면 잘못된 값이 bytearray 유형 인 경우에만 의미가 있습니다. 그렇지 않으면 적절한 유형이 이미 작성되었으며 적절한 값을 가져야합니다. 그렇지 않은 경우 내부 오류이므로 시스템이 실패해야합니다. 다음 섹션의 ABS 기능 구현에서 두 경우 모두를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0cd1516fe911149160db59890452732b5e2a6012" translate="yes" xml:space="preserve">
          <source>An error that affects the entire processing and is not likely to succeed on retry. An example of such a failure is the inability to open a lookup file because of file permission problems. Pig currently does not have a way to handle this case. Hadoop does not have a way to handle this case either. It will be handled the same way as 2 above.</source>
          <target state="translated">전체 처리에 영향을 미치고 재 시도에 성공하지 못하는 오류입니다. 이러한 실패의 예는 파일 권한 문제점으로 인해 찾아보기 파일을 열 수 없다는 것입니다. 현재 돼지는이 사례를 처리 할 방법이 없습니다. 하둡은이 경우를 처리 할 방법이 없습니다. 위의 2와 같은 방식으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="967c63764b50c00375304e8099e75b4305349fab" translate="yes" xml:space="preserve">
          <source>An error that affects the entire processing but can succeed on retry. An example of such a failure is the inability to open a lookup file because the file could not be found. This could be a temporary environmental issue that can go away on retry. A UDF can signal this to Pig by throwing an IOException as with the case of the ABS function below.</source>
          <target state="translated">전체 처리에 영향을 주지만 다시 시도하면 성공할 수있는 오류입니다. 이러한 실패의 예는 파일을 찾을 수 없기 때문에 찾아보기 파일을 열 수 없다는 것입니다. 재 시도 할 수있는 일시적인 환경 문제 일 수 있습니다. UDF는 아래 ABS 기능의 경우와 같이 IOException을 발생시켜 Pig에이를 신호 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c671b53983026588d1938407ddc3de8e6856bd34" translate="yes" xml:space="preserve">
          <source>An expression (angle) whose result is double.</source>
          <target state="translated">결과가 double 인 표현식 (각도)입니다.</target>
        </trans-unit>
        <trans-unit id="c9e4df25bc57aba5b36b1b839a0569311b438ce5" translate="yes" xml:space="preserve">
          <source>An expression (angle) whose result is type double.</source>
          <target state="translated">결과가 double 유형 인 표현식 (각도)입니다.</target>
        </trans-unit>
        <trans-unit id="34362c9801db95fc8c055765b1da467af4914b94" translate="yes" xml:space="preserve">
          <source>An expression of any datatype.</source>
          <target state="translated">모든 데이터 유형의 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="4fc0fa3f4fe236ad28967f716a6952b3a7c81fc4" translate="yes" xml:space="preserve">
          <source>An expression of any type supported by a map.</source>
          <target state="translated">지도에서 지원하는 모든 유형의 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="ece4a77a3b89bedc3071dbf7c155d7da07d70cca" translate="yes" xml:space="preserve">
          <source>An expression of type chararray.</source>
          <target state="translated">chararray 유형의 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="42a8feb3e66b92f42778a9de0016b381b22e3f74" translate="yes" xml:space="preserve">
          <source>An expression whose result is chararray.</source>
          <target state="translated">결과가 chararray 인 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="ba786e4184ca6343b0a6e324a36c27158438e550" translate="yes" xml:space="preserve">
          <source>An expression whose result is double.</source>
          <target state="translated">결과가 두 배인 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="c52877c34bec316f436408639ece24176492a8d3" translate="yes" xml:space="preserve">
          <source>An expression whose result is type double.</source>
          <target state="translated">결과가 double 유형 인 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="a11171646dd15e0f1209e9712d7c28ef95fc4194" translate="yes" xml:space="preserve">
          <source>An expression whose result is type float or double.</source>
          <target state="translated">결과가 float 또는 double 유형 인 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="c0aba735aad143557cbcf9d3bbaf934e342bb32c" translate="yes" xml:space="preserve">
          <source>An expression whose result is type float or double: the value to round.</source>
          <target state="translated">결과가 float 또는 double 유형 인 표현식 : 반올림 할 값입니다.</target>
        </trans-unit>
        <trans-unit id="d22e0b7fe056a1ea2d5b90df4e080286cb68143b" translate="yes" xml:space="preserve">
          <source>An expression whose result is type int: the number of digits to preserve.</source>
          <target state="translated">결과가 int 유형 인 표현식 : 보존 할 자릿수입니다.</target>
        </trans-unit>
        <trans-unit id="2cf7168250f4690cfc1d60fce85ae211a8712e25" translate="yes" xml:space="preserve">
          <source>An expression whose result type is chararray.</source>
          <target state="translated">결과 유형이 chararray 인 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="03e19ffa091a2ba8f7b346539a078dde90838a58" translate="yes" xml:space="preserve">
          <source>An expression with any data type.</source>
          <target state="translated">모든 데이터 유형의 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="dc2b013b87b4b0d7155358437bda24d123807360" translate="yes" xml:space="preserve">
          <source>An expression with data type bag.</source>
          <target state="translated">데이터 유형 백이 포함 된 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="ea370334a331e3ac767cc1cd26be558b05622a83" translate="yes" xml:space="preserve">
          <source>An expression with data type chararray.</source>
          <target state="translated">데이터 유형이 chararray 인 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="94c6f06360525978f6d07d0a2fa998ecab7775e4" translate="yes" xml:space="preserve">
          <source>An expression with data types chararray, int, long, float, double, bigdecimal, biginteger or bytearray.</source>
          <target state="translated">데이터 유형이 chararray, int, long, float, double, bigdecimal, biginteger 또는 bytearray 인 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="6d6c12b91e08f1f340872f9a49bc0e394534ff74" translate="yes" xml:space="preserve">
          <source>An expression with data types int, long, float, double, bigdecimal, biginteger or bytearray cast as double.</source>
          <target state="translated">int, long, float, double, bigdecimal, biginteger 또는 bytearray 데이터 유형이 double로 캐스트 된 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="ad8fff138056250741bdacef839aa859b39fa658" translate="yes" xml:space="preserve">
          <source>An expression with data types int, long, float, double, bigdecimal, biginteger, chararray, datetime or bytearray.</source>
          <target state="translated">데이터 유형이 int, long, float, double, bigdecimal, biginteger, chararray, datetime 또는 bytearray 인 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="a7f9bff8ef6f7d974fa3d734046ee5ffaf3f7777" translate="yes" xml:space="preserve">
          <source>An expression.</source>
          <target state="translated">표현.</target>
        </trans-unit>
        <trans-unit id="3295f86fff394718d50bc82eb94253ddd288cff2" translate="yes" xml:space="preserve">
          <source>An import list allows you to specify the package to which a UDF or a group of UDFs belong, eliminating the need to qualify the UDF on every call. An import list can be specified via the udf.import.list Java property on the Pig command line:</source>
          <target state="translated">가져 오기 목록을 사용하면 UDF 또는 UDF 그룹이 속하는 패키지를 지정할 수 있으므로 모든 호출에서 UDF를 규정 할 필요가 없습니다. Pig 명령 행에서 udf.import.list Java 특성을 통해 가져 오기 목록을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80e3fd7b2689b2c3d038821e417fb5dfa497cfdb" translate="yes" xml:space="preserve">
          <source>An inner bag is enclosed in curly brackets { }.</source>
          <target state="translated">내부 백은 중괄호 {}로 묶습니다.</target>
        </trans-unit>
        <trans-unit id="693f60586d103d91f5f3717ca5c57273ad72b04b" translate="yes" xml:space="preserve">
          <source>An optional Pig schema, in single quotes.</source>
          <target state="translated">작은 따옴표로 묶인 선택적인 Pig 스키마.</target>
        </trans-unit>
        <trans-unit id="944be749678e444ff5201cf9c6a7c4515f2f4bea" translate="yes" xml:space="preserve">
          <source>An optional field delimiter (in single quotes).</source>
          <target state="translated">선택적 필드 구분 기호 (작은 따옴표로 묶음).</target>
        </trans-unit>
        <trans-unit id="1b7935e0eed0aa803238947279893cdc1f875850" translate="yes" xml:space="preserve">
          <source>An optional int specifying the &lt;a href=&quot;https://en.wikipedia.org/wiki/Rounding#Tie-breaking&quot;&gt;rounding mode&lt;/a&gt;, according to the &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/constant-values.html#java.math&quot;&gt;constants Java provides&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/constant-values.html#java.math&quot;&gt;Java가 제공&lt;/a&gt; 하는 상수 에 따라 &lt;a href=&quot;https://en.wikipedia.org/wiki/Rounding#Tie-breaking&quot;&gt;반올림 모드를&lt;/a&gt; 지정하는 선택적 int 입니다.</target>
        </trans-unit>
        <trans-unit id="ed96ea4a9718fcaa197ebf9c97b7049da685a8bb" translate="yes" xml:space="preserve">
          <source>An optional int specifying the &lt;a href=&quot;https://en.wikipedia.org/wiki/Rounding#Tie-breaking&quot;&gt;rounding mode&lt;/a&gt;, according to the &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/constant-values.html#java.math&quot;&gt;constants Java provides&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c32b691b62f2bb36a75dd1e0cc784a9ca0b27fa" translate="yes" xml:space="preserve">
          <source>An optional pig property, pig.artifacts.download.location, can be used to configure the location where the artifacts should be downloaded. By default, they will be downloaded to ~/.groovy/grapes</source>
          <target state="translated">선택적인 pig 속성 인 pig.artifacts.download.location을 사용하여 아티팩트를 다운로드 할 위치를 구성 할 수 있습니다. 기본적으로 ~ / .groovy / grapes에 다운로드됩니다.</target>
        </trans-unit>
        <trans-unit id="29406927dd05c601019129d39195cf563a3a71de" translate="yes" xml:space="preserve">
          <source>An ordered set of fields.</source>
          <target state="translated">정렬 된 필드 세트.</target>
        </trans-unit>
        <trans-unit id="a697ce9cc8667c8e9256c8d32cb413cc810723e1" translate="yes" xml:space="preserve">
          <source>And then later:</source>
          <target state="translated">그리고 나중에 :</target>
        </trans-unit>
        <trans-unit id="25a2393aee7f5620498ac5ea27ab157a66cb664a" translate="yes" xml:space="preserve">
          <source>And this is example will return the bag {(04),(06),(96)}.</source>
          <target state="translated">이 예는 가방 {(04), (06), (96)}을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4e079119492128433a02329dfb9cc26741a84e7c" translate="yes" xml:space="preserve">
          <source>Another FLATTEN example.</source>
          <target state="translated">다른 FLATTEN 예제입니다.</target>
        </trans-unit>
        <trans-unit id="921cba366b298341f786269fa4eaf0ae09edfbec" translate="yes" xml:space="preserve">
          <source>Another FLATTEN example. Here, relations A and B both have a column x. When forming relation E, you need to use the :: operator to identify which column x to use - either relation A column x (A::x) or relation B column x (B::x). This example uses relation A column x (A::x).</source>
          <target state="translated">다른 FLATTEN 예제입니다. 여기서 관계 A와 B는 모두 열 x를 갖습니다. 관계 E를 형성 할 때 :: 연산자를 사용하여 관계 A 열 x (A :: x) 또는 관계 B 열 x (B :: x) 중 사용할 열 x를 식별해야합니다. 이 예에서는 관계 A 열 x (A :: x)를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="001e252a8c894f76e6bf2c456886080d47877255" translate="yes" xml:space="preserve">
          <source>Another FLATTEN example. Note that for the group '4' in C, there are two tuples in each bag. Thus, when both bags are flattened, the cross product of these tuples is returned; that is, tuples (4, 2, 6), (4, 3, 6), (4, 2, 9), and (4, 3, 9).</source>
          <target state="translated">다른 FLATTEN 예제입니다. C의 그룹 '4'에 대해 각 백에 두 개의 튜플이 있습니다. 따라서 두 백이 모두 평평 해지면이 튜플의 교차 생성물이 반환됩니다. 즉, 튜플 (4, 2, 6), (4, 3, 6), (4, 2, 9) 및 (4, 3, 9)입니다.</target>
        </trans-unit>
        <trans-unit id="4c7cf35f72fe11575ffec87c3c1ef4467f04181a" translate="yes" xml:space="preserve">
          <source>Another datetime object.</source>
          <target state="translated">다른 날짜 / 시간 개체</target>
        </trans-unit>
        <trans-unit id="22a26eedee58a28b2a4bb5da4392d6e156c497e6" translate="yes" xml:space="preserve">
          <source>Another sub-use case of automated generation is parallel execution of identical pipelines. You may have a single pipeline that you would like to run multiple data sets through in parallel. In the example below, the pipeline is run for the US, the UK, and Brazil.</source>
          <target state="translated">자동 생성의 또 다른 사용 사례는 동일한 파이프 라인의 병렬 실행입니다. 여러 데이터 세트를 병렬로 실행하려는 단일 파이프 라인이있을 수 있습니다. 아래 예에서 파이프 라인은 미국, 영국 및 브라질에 대해 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="be4fd2a45a4a97838cca0fc2c220e0db4ff1d9a2" translate="yes" xml:space="preserve">
          <source>Any Pig built in function.</source>
          <target state="translated">모든 내장 돼지 기능.</target>
        </trans-unit>
        <trans-unit id="1fc5c8e707150babdf31c148f74771b73558ea37" translate="yes" xml:space="preserve">
          <source>Any Pig data type (simple data types, complex data types)</source>
          <target state="translated">모든 Pig 데이터 유형 (단순 데이터 유형, 복합 데이터 유형)</target>
        </trans-unit>
        <trans-unit id="978a0d3c49e4c7b4d7faab089cc1f60749699746" translate="yes" xml:space="preserve">
          <source>Any Pig operator (arithmetic, comparison, null, boolean, dereference, sign, and cast)</source>
          <target state="translated">모든 Pig 연산자 (산술, 비교, 널, 부울, 역 참조, 부호 및 캐스트)</target>
        </trans-unit>
        <trans-unit id="217db132921e6ed0e5f9ca5f5859747c8c8a56ac" translate="yes" xml:space="preserve">
          <source>Any alias in the macro which isn't visible from the outside will be prefixed with a macro name and suffixed with an instance id to avoid namespace collision.</source>
          <target state="translated">외부에서 볼 수없는 매크로의 별칭에는 네임 스페이스 충돌을 피하기 위해 매크로 이름이 접두사로 추가되고 인스턴스 ID가 접미사로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="aaa582ad4ff05655888d6013ae0db9001b4c9c31" translate="yes" xml:space="preserve">
          <source>Any arbitrary, supported expression.</source>
          <target state="translated">지원되는 임의의 표현</target>
        </trans-unit>
        <trans-unit id="67dea04a8f04ddfb2fcaee33d42031f57acec54e" translate="yes" xml:space="preserve">
          <source>Any data type (the defaults to bytearray).</source>
          <target state="translated">모든 데이터 유형 (기본값은 바이트 배열)입니다.</target>
        </trans-unit>
        <trans-unit id="9df503ae42e921806aef9bda780b3d2b8d44c696" translate="yes" xml:space="preserve">
          <source>Any expression whose result is a bag. The elements of the bag should be data type int, long, float, double, bigdecimal, biginteger or bytearray.</source>
          <target state="translated">결과가 가방 인 모든 표현. 백의 요소는 int, long, float, double, bigdecimal, biginteger 또는 bytearray 데이터 유형이어야합니다.</target>
        </trans-unit>
        <trans-unit id="c42f940f3857fa4714f1ddb489fba3700db28181" translate="yes" xml:space="preserve">
          <source>Any expression whose result is type int, long, float, or double.</source>
          <target state="translated">결과가 int, long, float 또는 double 유형 인 모든 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="91010de1c13dcbe35e5c061770b45010829785f9" translate="yes" xml:space="preserve">
          <source>Any expression.</source>
          <target state="translated">모든 표현.</target>
        </trans-unit>
        <trans-unit id="e46d35adbc33471df9ea52bc60bef0f8c80a974b" translate="yes" xml:space="preserve">
          <source>Any numeric constant with decimal point (for example, 1.5) and/or exponent (for example, 5e+1) is treated as double unless it ends with the following characters:</source>
          <target state="translated">소수점 (예 : 1.5) 및 / 또는 지수 (예 : 5e + 1)가있는 숫자 상수는 다음 문자로 끝나지 않으면 이중으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="44b795c8279d6454f909869d7f6b987a7d1c123b" translate="yes" xml:space="preserve">
          <source>Any script is parsed in it's entirety before it is sent to execution. Since the current directory can change throughout the script any path used in LOAD or STORE statement is translated to a fully qualified and absolute path.</source>
          <target state="translated">모든 스크립트는 실행으로 전송되기 전에 전체적으로 구문 분석됩니다. 현재 디렉토리는 스크립트 전체에서 변경 될 수 있으므로 LOAD 또는 STORE 문에 사용 된 모든 경로는 정규화 된 절대 경로로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="890e506eab3c3d925aba8460d8fc6909e6882d47" translate="yes" xml:space="preserve">
          <source>Any user defined function (UDF) written in Java.</source>
          <target state="translated">Java로 작성된 모든 사용자 정의 함수 (UDF).</target>
        </trans-unit>
        <trans-unit id="7bc6dcbf97ce0a62c707a5a72faafb18f81f14d8" translate="yes" xml:space="preserve">
          <source>Anything else raises an exception</source>
          <target state="translated">다른 것은 예외를 일으킨다</target>
        </trans-unit>
        <trans-unit id="a5b4633f9cbbf1d5c5705da6d697c8f62f6a09cb" translate="yes" xml:space="preserve">
          <source>Apache Pig</source>
          <target state="translated">아파치 돼지</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="19f7be188fcad099f30afd0f2632c2e15d9c72df" translate="yes" xml:space="preserve">
          <source>Arguments used in a LOAD statement that have a scheme other than &quot;hdfs&quot; or &quot;file&quot; will not be expanded and passed to the LoadFunc/Slicer unchanged.</source>
          <target state="translated">&quot;hdfs&quot;또는 &quot;file&quot;이외의 스키마가있는 LOAD 문에 사용 된 인수는 확장되지 않고 LoadFunc / Slicer로 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6104f39ed22a2cd32e98536a3447a01c4b9f4781" translate="yes" xml:space="preserve">
          <source>Arithmetic Operators</source>
          <target state="translated">산술 연산자</target>
        </trans-unit>
        <trans-unit id="8b1cddd81446aceacf0965fa8356eacfc8d03688" translate="yes" xml:space="preserve">
          <source>Arithmetic Operators and More</source>
          <target state="translated">산술 연산자 등</target>
        </trans-unit>
        <trans-unit id="03bd73bb9f926b446db6e64bb7da8e17432f7d7c" translate="yes" xml:space="preserve">
          <source>Arithmetic operators:</source>
          <target state="translated">산술 연산자 :</target>
        </trans-unit>
        <trans-unit id="80a7a2594f7366489b3672da894029029c5b05d9" translate="yes" xml:space="preserve">
          <source>As a consequence running a pig script on a kerberos secured hadoop cluster limits the running time to at most the remaining validity time of these kerberos tickets. When doing really complex analytics this may become a problem as the job may need to run for a longer time than these ticket times allow.</source>
          <target state="translated">결과적으로 kerberos 보안 hadoop 클러스터에서 pig 스크립트를 실행하면 실행 시간이이 kerberos 티켓의 나머지 유효 시간으로 제한됩니다. 실제로 복잡한 분석을 수행하는 경우 이러한 티켓 시간이 허용하는 시간보다 작업을 더 오래 실행해야하므로 문제가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04879c2a61706a1f2d9777f3617aacfcdad08476" translate="yes" xml:space="preserve">
          <source>As noted, nulls can be the result of an operation. These operations can produce null values:</source>
          <target state="translated">언급 된 바와 같이, 널은 연산의 결과 일 수 있습니다. 이러한 작업은 null 값을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb2a8f02938afb551dcbe8fdd7976802309c4d2a" translate="yes" xml:space="preserve">
          <source>As noted, nulls can occur naturally in the data. If nulls are part of the data, it is the responsibility of the load function to handle them correctly. Keep in mind that what is considered a null value is loader-specific; however, the load function should always communicate null values to Pig by producing Java nulls.</source>
          <target state="translated">언급 한 바와 같이, 데이터에서 자연스럽게 널이 발생할 수 있습니다. 널이 데이터의 일부인 경우 올바르게 처리하는 것은로드 기능의 책임입니다. 널값으로 간주되는 것은 로더마다 다릅니다. 그러나로드 함수는 항상 Java 널을 생성하여 널 값을 Pig와 통신해야합니다.</target>
        </trans-unit>
        <trans-unit id="90b97e17cddeb6c1a70a69c4c9fb04528a8278f6" translate="yes" xml:space="preserve">
          <source>As noted, the fields in a tuple can be any data type, including the complex data types: bags, tuples, and maps.</source>
          <target state="translated">언급 한 바와 같이, 튜플의 필드는 복잡한 데이터 유형 (가방, 튜플 및 맵)을 포함한 모든 데이터 유형이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61510ad4a1b483d9b8760f068d0f56567869aa9a" translate="yes" xml:space="preserve">
          <source>As part of a command line.</source>
          <target state="translated">명령 줄의 일부로.</target>
        </trans-unit>
        <trans-unit id="c849c8ea4cee323f844d5e9b104ac35d107c29b4" translate="yes" xml:space="preserve">
          <source>As shown above, with a few exceptions Pig can infer the schema of a relationship up front. You can examine the schema of particular relation using &lt;a href=&quot;test#describe&quot;&gt;DESCRIBE&lt;/a&gt;. Pig enforces this computed schema during the actual execution by casting the input data to the expected data type. If the process is successful the results are returned to the user; otherwise, a warning is generated for each record that failed to convert. Note that Pig does not know the actual types of the fields in the input data prior to the execution; rather, Pig determines the data types and performs the right conversions on the fly.</source>
          <target state="translated">위와 같이 몇 가지 예외를 제외하고 Pig는 관계의 스키마를 미리 유추 할 수 있습니다. &lt;a href=&quot;test#describe&quot;&gt;DESCRIBE를&lt;/a&gt; 사용하여 특정 관계의 스키마를 검사 할 수 있습니다 . Pig는 입력 데이터를 예상 데이터 유형으로 캐스트하여 실제 실행 중에이 계산 된 스키마를 시행합니다. 프로세스가 성공하면 결과가 사용자에게 반환됩니다. 그렇지 않으면 변환에 실패한 각 레코드에 대해 경고가 생성됩니다. Pig는 실행 전에 입력 데이터에서 실제 필드 유형을 알지 못합니다. 오히려 Pig는 데이터 형식을 결정하고 올바른 변환을 즉시 수행합니다.</target>
        </trans-unit>
        <trans-unit id="6e709810b011330ebd0676f7d7de0173d4923b8a" translate="yes" xml:space="preserve">
          <source>As shown in the examples below, you can use ILLUSTRATE to review a relation or an entire Pig script.</source>
          <target state="translated">아래 예에 표시된 것처럼 ILLUSTRATE를 사용하여 관계 또는 전체 Pig 스크립트를 검토 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f2d230c53a81ee68e467d510700d608baa6779e" translate="yes" xml:space="preserve">
          <source>As shown in this example when you assign names to fields (using the AS schema clause) you can still refer to the fields using positional notation. However, for debugging purposes and ease of comprehension, it is better to use field names.</source>
          <target state="translated">이 예에 표시된 것처럼 (AS 스키마 절을 사용하여) 필드에 이름을 지정할 때 여전히 위치 표기법을 사용하여 필드를 참조 할 수 있습니다. 그러나 디버깅 목적과 이해하기 쉽도록 필드 이름을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="db677636bc6e605a4bc57d0950b0b51ad9d9f929" translate="yes" xml:space="preserve">
          <source>As the case with runSingle, a set of Java Properties or a property file can be passed to the call.</source>
          <target state="translated">runSingle의 경우와 같이 Java 특성 세트 또는 특성 파일을 호출에 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5eedc0d0584315378e1685648914295652f1e014" translate="yes" xml:space="preserve">
          <source>As with early projection, in most cases it is beneficial to apply filters as early as possible to reduce the amount of data flowing through the pipeline.</source>
          <target state="translated">초기 프로젝션과 마찬가지로 대부분의 경우 파이프 라인을 통해 흐르는 데이터 양을 줄이기 위해 가능한 빨리 필터를 적용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="acf60e2b7279f879ddcbeae131ad493aad66eb3a" translate="yes" xml:space="preserve">
          <source>As you can see in the example below, this is very similar to the output schema definition in the Swap function. One difference is that instead of reusing input schema, we create a brand new field schema to represent the tokens stored in the bag. The other difference is that the type of the schema created is BAG (not TUPLE).</source>
          <target state="translated">아래 예제에서 볼 수 있듯이 이는 스왑 함수의 출력 스키마 정의와 매우 유사합니다. 한 가지 차이점은 입력 스키마를 재사용하는 대신 백에 저장된 토큰을 나타내는 새로운 필드 스키마를 생성한다는 것입니다. 다른 차이점은 작성된 스키마 유형이 BAG (TUPLE 아님)입니다.</target>
        </trans-unit>
        <trans-unit id="6dd763f730ac055b413d379bc6a1deb86e3f18f7" translate="yes" xml:space="preserve">
          <source>Assert a condition on the data.</source>
          <target state="translated">데이터에 조건을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="72a84963b5100d98fa29133871f582f97171e51b" translate="yes" xml:space="preserve">
          <source>Assigns an alias to a UDF or streaming command.</source>
          <target state="translated">UDF 또는 스트리밍 명령에 별명을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="22ae620ea591268623e10bb00a68850ef5411704" translate="yes" xml:space="preserve">
          <source>At runtime, Tez adjust vertex parallelism dynamically based on the input data volume of the vertex. Note currently Tez can only decrease the parallelism dynamically not increase. So in step 1 and 2, Pig overestimate the parallelism</source>
          <target state="translated">런타임시 Tez는 정점의 입력 데이터 볼륨을 기반으로 정점 병렬 처리를 동적으로 조정합니다. 현재 Tez는 병렬 처리를 동적으로 늘리지 않고 줄일 수만 있습니다. 1 단계와 2 단계에서 Pig는 병렬 처리를 과대 평가합니다.</target>
        </trans-unit>
        <trans-unit id="1f292143d23b3b6e8deb436ffedfbe3691c76f80" translate="yes" xml:space="preserve">
          <source>Auto Local Mode</source>
          <target state="translated">자동 로컬 모드</target>
        </trans-unit>
        <trans-unit id="c05f16de6c69f8e34fa012e8ac0bd27013d3f37e" translate="yes" xml:space="preserve">
          <source>Automated Pig Latin Generation</source>
          <target state="translated">자동 돼지 라틴 세대</target>
        </trans-unit>
        <trans-unit id="f50b65cb2d9cf1587f20cc17099ef1d0a0694dbb" translate="yes" xml:space="preserve">
          <source>Automatic parallelism</source>
          <target state="translated">자동 병렬 처리</target>
        </trans-unit>
        <trans-unit id="8882830c81669a6304872e4991c4350381f5484a" translate="yes" xml:space="preserve">
          <source>AvroStorage</source>
          <target state="translated">AvroStorage</target>
        </trans-unit>
        <trans-unit id="2c276dd5a0812dd59c7b1e51251655518f6b77b2" translate="yes" xml:space="preserve">
          <source>AvroStorage stores and loads data from Avro files. Often, you can load and store data using AvroStorage without knowing much about the Avros serialization format. AvroStorage will attempt to automatically translate a pig schema and pig data to avro data, or avro data to pig data.</source>
          <target state="translated">AvroStorage는 Avro 파일에서 데이터를 저장하고로드합니다. 종종 Avros 직렬화 형식에 대해 많이 몰라도 AvroStorage를 사용하여 데이터를로드하고 저장할 수 있습니다. AvroStorage는 돼지 스키마 및 돼지 데이터를 avro 데이터로 또는 avro 데이터를 돼지 데이터로 자동 변환하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="32931d8fb64c41f2dd70472c880c9cc493a17fed" translate="yes" xml:space="preserve">
          <source>AvroStorage will translate this to the Avro schema</source>
          <target state="translated">AvroStorage는이를 Avro 스키마로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="3522a2f4906b64de7b765845424795b246eb4c92" translate="yes" xml:space="preserve">
          <source>AvroStorage(['schema|record name'], ['options'])</source>
          <target state="translated">AvroStorage ([ '스키마 | 레코드 이름'], [ '옵션'])</target>
        </trans-unit>
        <trans-unit id="eb218a8539c7342f43e836950bb701112da9e2f7" translate="yes" xml:space="preserve">
          <source>B = GROUP A ALL;</source>
          <target state="translated">B = 그룹 A 모두;</target>
        </trans-unit>
        <trans-unit id="418f4817f0e84b121282e541eda28b4c1ea356a4" translate="yes" xml:space="preserve">
          <source>B = GROUP A BY (key1,key2);</source>
          <target state="translated">B = 그룹 A BY (key1, key2);</target>
        </trans-unit>
        <trans-unit id="e250a6fbb702237f17fd7fdd6856965d006b2b2e" translate="yes" xml:space="preserve">
          <source>B = GROUP A BY f1;</source>
          <target state="translated">B = GROUP A BY f1;</target>
        </trans-unit>
        <trans-unit id="b14097536db7430e5fb8567a9ea4cd709d96f686" translate="yes" xml:space="preserve">
          <source>BD or bd in which case it is assigned type BigDecimal (for example, 12345678.12345678BD)</source>
          <target state="translated">BD 또는 bd 인 경우 BigDecimal 유형 (예 : 12345678.12345678BD)이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="b676a049c2b4b642ab7910b4ba1dcd493813d54a" translate="yes" xml:space="preserve">
          <source>BOSNYABAL</source>
          <target state="translated">BOSNYABAL</target>
        </trans-unit>
        <trans-unit id="fe32d598143386838f0a56cf1f52612b9269a98a" translate="yes" xml:space="preserve">
          <source>BOS_NYA_BAL</source>
          <target state="translated">BOS_NYA_BAL</target>
        </trans-unit>
        <trans-unit id="d3f662cc77b3cae96cc441e9ddc30da08a72415c" translate="yes" xml:space="preserve">
          <source>BOS|NYA|BAL</source>
          <target state="translated">BOS|NYA|BAL</target>
        </trans-unit>
        <trans-unit id="64c3f5e89864d5e803ba483fadc3c80068321744" translate="yes" xml:space="preserve">
          <source>BY</source>
          <target state="translated">BY</target>
        </trans-unit>
        <trans-unit id="fd4a1f65749d89056abcaeac3722a7b7a8fe75a1" translate="yes" xml:space="preserve">
          <source>Backward Compatibility</source>
          <target state="translated">하위 호환성</target>
        </trans-unit>
        <trans-unit id="ef6155a5eccf4717deb734d482cb9f59d873fb8a" translate="yes" xml:space="preserve">
          <source>Bag</source>
          <target state="translated">Bag</target>
        </trans-unit>
        <trans-unit id="49d390666ee5f9c31c1da5c0f493d58a41258216" translate="yes" xml:space="preserve">
          <source>Bag Schemas</source>
          <target state="translated">백 스키마</target>
        </trans-unit>
        <trans-unit id="1010b8b2eb340a1d5a8871eaf78edf295b32c6b6" translate="yes" xml:space="preserve">
          <source>Bag dereferencing can be done by name (bag.field_name) or position (bag.$0). If a set of fields are dereferenced (bag.(name1, name2) or bag.($0, $1)), the expression represents a bag composed of the specified fields.</source>
          <target state="translated">백 역 참조는 이름 (bag.field_name) 또는 위치 (bag. $ 0)로 수행 할 수 있습니다. 필드 세트가 역 참조되는 경우 (bag. (name1, name2) 또는 bag. ($ 0, $ 1)), 표현식은 지정된 필드로 구성된 bag을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="aeec0cc90259f65e36bea15200294f37f5af27c4" translate="yes" xml:space="preserve">
          <source>BagToString</source>
          <target state="translated">BagToString</target>
        </trans-unit>
        <trans-unit id="aa25c39849add586db84531c827f1e6e41eb4056" translate="yes" xml:space="preserve">
          <source>BagToString creates a single string from the elements of a bag, similar to SQL's GROUP_CONCAT function. Keep in mind the following:</source>
          <target state="translated">BagToString은 백의 요소에서 SQL의 GROUP_CONCAT 함수와 유사한 단일 문자열을 작성합니다. 다음을 명심하십시오.</target>
        </trans-unit>
        <trans-unit id="c5638dc5f797ac1efe44a952e3873eb31c5aa8cf" translate="yes" xml:space="preserve">
          <source>BagToString(vals, delimiter)</source>
          <target state="translated">BagToString (vals, delimiter)</target>
        </trans-unit>
        <trans-unit id="7cc817fe26a9f93ad9a1352d61aced211bab05d5" translate="yes" xml:space="preserve">
          <source>BagToString(vals:bag [, delimiter:chararray])</source>
          <target state="translated">BagToString (vals : bag [, 분리 문자 : chararray])</target>
        </trans-unit>
        <trans-unit id="cdd596ce5991ef8e9aa895a166dc8b016020ea23" translate="yes" xml:space="preserve">
          <source>BagToTuple</source>
          <target state="translated">BagToTuple</target>
        </trans-unit>
        <trans-unit id="148cb3b1cb4a6cb08389277afb45ce738be66b38" translate="yes" xml:space="preserve">
          <source>BagToTuple creates a tuple from the elements of a bag. It removes only the first level of nesting; it does not recursively un-nest nested bags. Unlike FLATTEN, BagToTuple will not generate multiple output records per input record.</source>
          <target state="translated">BagToTuple은 가방 요소에서 튜플을 만듭니다. 첫 번째 수준의 중첩 만 제거합니다. 중첩 된 가방을 재귀 적으로 풀지 않습니다. FLATTEN과 달리 BagToTuple은 입력 레코드 당 여러 개의 출력 레코드를 생성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0f341f2d6b6d4286104bc0819855cf8bf670f5d0" translate="yes" xml:space="preserve">
          <source>BagToTuple(expression)</source>
          <target state="translated">BagToTuple(expression)</target>
        </trans-unit>
        <trans-unit id="c40ffaad461d0b3df48aa6832b6a4ee0ebc50c40" translate="yes" xml:space="preserve">
          <source>Bags are disordered unless you explicitly apply a nested ORDER BY operation as demonstrated below. A nested FOREACH will preserve ordering, letting you order by one combination of fields then project out just the values you'd like to concatenate.</source>
          <target state="translated">아래에 설명 된대로 중첩 된 ORDER BY 작업을 명시 적으로 적용하지 않으면 백에 장애가 발생합니다. 중첩 된 FOREACH는 순서를 유지하므로 한 필드 조합으로 주문한 다음 연결하려는 값만 투영 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2e4de2aeab971065d2712f291e9a19b5c68ba50" translate="yes" xml:space="preserve">
          <source>Bags can be of arbitrary size, while strings in Java cannot: you will either exhaust available memory or exceed the maximum number of characters (about 2 billion). One of the worst features a production job can have is thresholding behavior: everything will seem nearly fine until the data size of your largest bag grows from nearly-too-big to just-barely-too-big.</source>
          <target state="translated">가방은 임의의 크기 일 수 있지만 Java의 문자열은 사용할 수 없습니다. 사용 가능한 메모리를 모두 사용하거나 최대 문자 수 (약 20 억)를 초과합니다. 생산 작업이 가질 수있는 최악의 기능 중 하나는 임계 값 동작입니다. 가장 큰 가방의 데이터 크기가 너무 큰 것에서 너무 큰 것까지 커질 때까지 모든 것이 거의 괜찮아 보입니다.</target>
        </trans-unit>
        <trans-unit id="bdacb6f01627f60551e03a34d7bdd90e363f5861" translate="yes" xml:space="preserve">
          <source>Bags have two forms: outer bag (or relation) and inner bag.</source>
          <target state="translated">가방은 두 가지 형태가 있습니다 : 외부 백 (또는 관계형)과 내부 백.</target>
        </trans-unit>
        <trans-unit id="b67dda013697f0f9bfaf42e872c02ae3d9c9da7b" translate="yes" xml:space="preserve">
          <source>Bags of Tuples</source>
          <target state="translated">튜플의 가방</target>
        </trans-unit>
        <trans-unit id="63cf7dab63810a51b8c15ba646b1894701a7fbb9" translate="yes" xml:space="preserve">
          <source>Bags subtraction, SUBTRACT(bag1, bag2) = bags composed of bag1 elements not in bag2</source>
          <target state="translated">가방 빼기, SUBTRACT (bag1, bag2) = bag2에없는 bag1 요소로 구성된 가방</target>
        </trans-unit>
        <trans-unit id="a0fa542d40e090bdd331d620ba960b68717b80f4" translate="yes" xml:space="preserve">
          <source>Basic usage of CUBE and ROLLUP operation combined</source>
          <target state="translated">CUBE 및 ROLLUP 작업의 기본 사용법</target>
        </trans-unit>
        <trans-unit id="0e99a3b747071dcc806ccc77b33e132a42bde5c9" translate="yes" xml:space="preserve">
          <source>Basic usage of CUBE operation</source>
          <target state="translated">CUBE 작업의 기본 사용법</target>
        </trans-unit>
        <trans-unit id="cf12cbbcd3288d2414dbcadce62afe0bfb92f39f" translate="yes" xml:space="preserve">
          <source>Basic usage of ROLLUP operation</source>
          <target state="translated">ROLLUP 조작의 기본 사용법</target>
        </trans-unit>
        <trans-unit id="8b6d8cb0fe44b1ea97c8dffd9944957e48ec1ad8" translate="yes" xml:space="preserve">
          <source>Batch Mode</source>
          <target state="translated">배치 모드</target>
        </trans-unit>
        <trans-unit id="e7f94f7bfabdfdabdaf4925e4a430639526f615c" translate="yes" xml:space="preserve">
          <source>Because the log file only contains queries for a single day, we are only interested in the hour. The excite query log timestamp format is YYMMDDHHMMSS. Call the ExtractHour UDF to extract the hour (HH) from the time field.</source>
          <target state="translated">로그 파일에는 하루에 대한 쿼리 만 포함되므로 시간에만 관심이 있습니다. 여기 쿼리 로그 타임 스탬프 형식은 YYMMDDHHMMSS입니다. 시간 필드에서 시간 (HH)을 추출하려면 ExtractHour UDF를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="d5790a6c7ab6af9eec7c14c03a21d3af3cba7457" translate="yes" xml:space="preserve">
          <source>Because the log file only contains queries for a single day, we are only interested in the hour. The excite query log timestamp format is YYMMDDHHMMSS. Call the ExtractHour UDF to extract the hour from the time field.</source>
          <target state="translated">로그 파일에는 하루에 대한 쿼리 만 포함되므로 시간에만 관심이 있습니다. 여기 쿼리 로그 타임 스탬프 형식은 YYMMDDHHMMSS입니다. 시간 필드에서 시간을 추출하려면 ExtractHour UDF를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="68d617dccdb378ed22fc2da9ed3a1747f7a04c4b" translate="yes" xml:space="preserve">
          <source>Before submiting a DAG, Pig estimate parallelism of each vertex statically based on the input file size of the DAG and the complexity of the pipeline of each vertex</source>
          <target state="translated">DAG를 제출하기 전에 Pig는 DAG의 입력 파일 크기와 각 정점의 파이프 라인 복잡도를 기반으로 각 정점의 병렬성을 정적으로 추정합니다.</target>
        </trans-unit>
        <trans-unit id="e4cba249be79fb483be03e01c74d8ae5fd152fe5" translate="yes" xml:space="preserve">
          <source>Before the type system was available in Pig, all values for the purpose of arithmetic calculations were assumed to be doubles as the safest choice. However, this is not very efficient if the data is actually of type integer or long. (We saw about a 2x slowdown of a query when using double where integer could be used.) Now that Pig supports types we can take advantage of the type information and choose the function that is most efficient for the provided operands.</source>
          <target state="translated">Pig에서 유형 시스템을 사용할 수 있기 전에 산술 계산을위한 모든 값이 가장 안전한 선택의 두 배로 가정되었습니다. 그러나 데이터가 실제로 정수 유형이거나 긴 경우에는 매우 효율적이지 않습니다. 정수를 사용할 수있는 double을 사용할 때 쿼리 속도가 2 배 느려지는 것을 알았습니다. 이제 Pig는 유형을 지원하므로 유형 정보를 활용하고 제공된 피연산자에 가장 효율적인 함수를 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e11e5b36796c77a490bbf41ea86918f4da66a328" translate="yes" xml:space="preserve">
          <source>Begin with the &lt;a href=&quot;start&quot;&gt;Getting Started&lt;/a&gt; guide which shows you how to set up Pig and how to form simple Pig Latin statements. When you are ready to start writing your own scripts, review the &lt;a href=&quot;basic&quot;&gt;Pig Latin Basics&lt;/a&gt; manual to become familiar with the Pig Latin operators and the supported data types.</source>
          <target state="translated">Pig를 설정하는 방법과 간단한 Pig Latin 문을 작성하는 방법을 보여주는 &lt;a href=&quot;start&quot;&gt;시작&lt;/a&gt; 안내서로 시작하십시오 . 자체 스크립트 작성을 시작할 준비가되면 &lt;a href=&quot;basic&quot;&gt;Pig Latin Basics&lt;/a&gt; 매뉴얼을 검토 하여 Pig Latin 연산자 및 지원되는 데이터 유형에 익숙해 지십시오.</target>
        </trans-unit>
        <trans-unit id="3ab0be3f93d8d722278121e74cf7b35c0bf4473f" translate="yes" xml:space="preserve">
          <source>BigDecimal</source>
          <target state="translated">BigDecimal</target>
        </trans-unit>
        <trans-unit id="2b64c290fd2bfc4444117f69d1817cb3b5546b05" translate="yes" xml:space="preserve">
          <source>BigDecimal: bigdecimal</source>
          <target state="translated">BigDecimal : BigDecimal</target>
        </trans-unit>
        <trans-unit id="92438720ccb09a8bc6b241c5b27a00fb72144c25" translate="yes" xml:space="preserve">
          <source>BigInteger</source>
          <target state="translated">BigInteger</target>
        </trans-unit>
        <trans-unit id="06802a83746ed515cb7bdb4d5fe59d7d5634e1fa" translate="yes" xml:space="preserve">
          <source>BigInteger: biginteger</source>
          <target state="translated">BigInteger : Biginteger</target>
        </trans-unit>
        <trans-unit id="798c6979dab113281cfd52bfcf3dc3e219ec5cd6" translate="yes" xml:space="preserve">
          <source>BigIntegers can be specified by supplying BI or bi at the end of the number (for example, 123456789123456BI)</source>
          <target state="translated">숫자 끝에 BI 또는 bi를 제공하여 BigInteger를 지정할 수 있습니다 (예 : 123456789123456BI)</target>
        </trans-unit>
        <trans-unit id="16a7e0acfeabb86108ee3a692200b773118cac32" translate="yes" xml:space="preserve">
          <source>BinStorage</source>
          <target state="translated">BinStorage</target>
        </trans-unit>
        <trans-unit id="f6966b28a7841f8f76aa5394237429397c64ffa0" translate="yes" xml:space="preserve">
          <source>BinStorage does not track data lineage. When Pig uses BinStorage to move data between MapReduce jobs, Pig can figure out the correct cast function to use and apply it. However, as shown in the example below, when you store data using BinStorage and then use a separate Pig Latin script to read data (thus loosing the type information), it is your responsibility to correctly cast the data before storing it using BinStorage.</source>
          <target state="translated">BinStorage는 데이터 연계를 추적하지 않습니다. Pig가 BinStorage를 사용하여 MapReduce 작업간에 데이터를 이동하면 Pig는 올바른 캐스트 기능을 사용하여 적용 할 수 있습니다. 그러나 아래 예에서와 같이 BinStorage를 사용하여 데이터를 저장 한 다음 별도의 Pig Latin 스크립트를 사용하여 데이터를 읽으면 (형식 정보가 손실 됨) BinStorage를 사용하여 저장하기 전에 데이터를 올바르게 캐스트해야합니다.</target>
        </trans-unit>
        <trans-unit id="f3ac853a4785dc7e2df3f4836ae07b53c5387435" translate="yes" xml:space="preserve">
          <source>BinStorage supports multiple locations (files, directories, globs) as input.</source>
          <target state="translated">BinStorage는 여러 위치 (파일, 디렉토리, 글로브)를 입력으로 지원합니다.</target>
        </trans-unit>
        <trans-unit id="7fd99832c48b48f8c885e9f9d3afe52e1a804201" translate="yes" xml:space="preserve">
          <source>BinStorage works with data that is represented on disk in machine-readable format. BinStorage does NOT support &lt;a href=&quot;#handling-compression&quot;&gt;compression&lt;/a&gt;.</source>
          <target state="translated">BinStorage는 디스크에 기계가 읽을 수있는 형식으로 표시되는 데이터와 함께 작동합니다. BinStorage는 &lt;a href=&quot;#handling-compression&quot;&gt;압축을&lt;/a&gt; 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e0ca567886380d6457cde112726183a82a8a0418" translate="yes" xml:space="preserve">
          <source>BinStorage()</source>
          <target state="translated">BinStorage()</target>
        </trans-unit>
        <trans-unit id="dcba2ac0accedbd7acc44d5f5c535e4f1460c6c2" translate="yes" xml:space="preserve">
          <source>Bincond operator &amp;ndash; If a Boolean subexpression results in null value, the resulting expression is null (see the interactions above for Arithmetic operators)</source>
          <target state="translated">Bincond 연산자 &amp;ndash; 부울 하위 표현식의 결과 널값이되면 결과 표현식이 널입니다 (산술 연산자에 대한 위의 상호 작용 참조).</target>
        </trans-unit>
        <trans-unit id="83a9e49fc4cb9ac64b7028f07d9d3339609981c4" translate="yes" xml:space="preserve">
          <source>Bind</source>
          <target state="translated">Bind</target>
        </trans-unit>
        <trans-unit id="621327102b26f2c05119b691501a4935cc0c4aee" translate="yes" xml:space="preserve">
          <source>Blacklisting</source>
          <target state="translated">Blacklisting</target>
        </trans-unit>
        <trans-unit id="3ef84d550fdc4824a3f8f451fbfb6aa5b226f219" translate="yes" xml:space="preserve">
          <source>Bloom</source>
          <target state="translated">Bloom</target>
        </trans-unit>
        <trans-unit id="2bf2475a7e51b3f4e7460fe10ff06c734dde772d" translate="yes" xml:space="preserve">
          <source>Bloom Joins</source>
          <target state="translated">블룸 조인</target>
        </trans-unit>
        <trans-unit id="b490f863ec5ddf6a529c1515f94de24bf143f902" translate="yes" xml:space="preserve">
          <source>Bloom filters are a common way to select a limited set of records before moving data for a join or other heavy weight operation.</source>
          <target state="translated">블룸 필터는 조인 또는 기타 중량 작업을 위해 데이터를 이동하기 전에 제한된 레코드 세트를 선택하는 일반적인 방법입니다.</target>
        </trans-unit>
        <trans-unit id="6199fda5d8e5b6974f14a88bff44fb40a2fd7a8c" translate="yes" xml:space="preserve">
          <source>Bloom filters are a common way to select a limited set of records before moving data for a join or other heavy weight operation. For example, if one wanted to join a very large data set L with a smaller set S, and it was known that the number of keys in L that will match with S is small, building a bloom filter on S and then applying it to L before the join can greatly reduce the number of records from L that have to be moved from the map to the reduce, thus speeding the join.</source>
          <target state="translated">블룸 필터는 조인 또는 기타 중량 작업을 위해 데이터를 이동하기 전에 제한된 레코드 세트를 선택하는 일반적인 방법입니다. 예를 들어, 매우 큰 데이터 세트 L을 더 작은 세트 S와 결합시키고 L과 S와 일치하는 키의 수가 적다는 것을 알고 있다면 S에 블룸 필터를 구축 한 다음 적용합니다. 결합 전 L은 맵에서 감소로 이동해야하는 L에서 레코드 수를 크게 줄여서 결합 속도를 높일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f7de4ab07c18ddb23242e06d699dc853ecbf88b" translate="yes" xml:space="preserve">
          <source>Bloom join cannot be used with a FULL OUTER join.</source>
          <target state="translated">블룸 조인은 FULL OUTER 조인과 함께 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3402188725ecf0e99a3b7622b1bea669f836310b" translate="yes" xml:space="preserve">
          <source>Bloom join is a special type of join where a bloom filter is constructed using join keys of one relation and used to filter records of the other relations before doing a regular hash join. The amount of data sent to the reducers will be a lot less depending up on the numbers of records that are filtered on the map side. Bloom join is very useful in cases where the number of matching records between relations in a join are comparatively less compared to the total records allowing many to be filtered before the join. Before bloom join was added as a type of join, same functionality was achieved by users by using the &lt;a href=&quot;func#bloom&quot;&gt;builtin bloom udfs&lt;/a&gt; which is not as efficient and required more lines of code as well. Currently bloom join is only implemented in Tez execution mode. Builtin bloom udfs have to be used for other execution modes.</source>
          <target state="translated">블룸 조인은 블룸 필터가 한 관계의 조인 키를 사용하여 구성되고 일반 해시 조인을 수행하기 전에 다른 관계의 레코드를 필터링하는 데 사용되는 특수한 조인 유형입니다. 리듀서로 전송되는 데이터의 양은 맵 측에서 필터링되는 레코드 수에 따라 훨씬 줄어 듭니다. 블룸 조인은 조인에서 관계 간의 일치하는 레코드 수가 총 레코드에 비해 상대적으로 적어 조인 전에 많은 항목을 필터링 할 수있는 경우에 매우 유용합니다. 블룸 조인을 조인 유형으로 추가하기 전에 &lt;a href=&quot;func#bloom&quot;&gt;내장 된 블룸&lt;/a&gt; UDF를 사용하여 사용자가 동일한 기능을 수행했습니다.효율적이지 않고 더 많은 코드 줄이 필요합니다. 현재 블룸 조인은 Tez 실행 모드에서만 구현됩니다. 다른 실행 모드에는 내장 블룸 UDF를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="24edee0641f1bfe2fe2ec8534168d935eca3807b" translate="yes" xml:space="preserve">
          <source>Bloom(String filename)</source>
          <target state="translated">Bloom (문자열 파일 이름)</target>
        </trans-unit>
        <trans-unit id="b76ff4906f33c2dd97ddd929b9662ba8cac6174c" translate="yes" xml:space="preserve">
          <source>Boolean</source>
          <target state="translated">Boolean</target>
        </trans-unit>
        <trans-unit id="c9ac379f83771407fb1e0d78aaf3f7b5adc6706f" translate="yes" xml:space="preserve">
          <source>Boolean Expressions</source>
          <target state="translated">부울 식</target>
        </trans-unit>
        <trans-unit id="04967741c4271ee06f12a1e39acd461f02a1a16a" translate="yes" xml:space="preserve">
          <source>Boolean Operators</source>
          <target state="translated">부울 연산자</target>
        </trans-unit>
        <trans-unit id="091731d1019107954174fd671f6f0856846a3d19" translate="yes" xml:space="preserve">
          <source>Boolean expressions can be made up of UDFs that return a boolean value or boolean operators (see &lt;a href=&quot;#boolops&quot;&gt;Boolean Operators&lt;/a&gt;).</source>
          <target state="translated">부울 표현식은 부울 값 또는 부울 연산자를 리턴하는 UDF로 구성 될 수 있습니다 ( &lt;a href=&quot;#boolops&quot;&gt;부울 연산자&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="ea6b1479c901a03bee4e9fb9ba5b1453d7e79a83" translate="yes" xml:space="preserve">
          <source>Boolean: boolean</source>
          <target state="translated">부울 : 부울</target>
        </trans-unit>
        <trans-unit id="0786cdff946e6084c50bb7df6cacd8ed965599fa" translate="yes" xml:space="preserve">
          <source>Booleans</source>
          <target state="translated">Booleans</target>
        </trans-unit>
        <trans-unit id="a6cf6d57143ef14b17087bc22ec2482f83d734d7" translate="yes" xml:space="preserve">
          <source>BoundScript Object</source>
          <target state="translated">바운드 스크립트 객체</target>
        </trans-unit>
        <trans-unit id="9018f72a5c3300106fde6c868932df7c498dbece" translate="yes" xml:space="preserve">
          <source>Build Pig</source>
          <target state="translated">돼지 만들기</target>
        </trans-unit>
        <trans-unit id="d3ba812ccb5dd02574b7c52a54aacf2301a5acc7" translate="yes" xml:space="preserve">
          <source>Build PigUnit</source>
          <target state="translated">PigUnit 구축</target>
        </trans-unit>
        <trans-unit id="d591aaecacb795ebd8be527e5fc80e792afab062" translate="yes" xml:space="preserve">
          <source>Build the code from the top directory: ant</source>
          <target state="translated">최상위 디렉토리에서 코드를 빌드하십시오. ant</target>
        </trans-unit>
        <trans-unit id="81f7e17cef88c9c7b63a31e2aee2051c6cd1d181" translate="yes" xml:space="preserve">
          <source>Build the jar file: from directorytrunk/contrib/piggybank/java run ant. This will generate piggybank.jar in the same directory.</source>
          <target state="translated">jar 파일을 빌드하십시오. directorytrunk / contrib / piggybank / java run ant에서. 동일한 디렉토리에 piggybank.jar가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="1fcd4fe2c3b6a15d7346329d03946183a5901801" translate="yes" xml:space="preserve">
          <source>BuildBloom(String hashType, String mode, String vectorSize, String nbHash)</source>
          <target state="translated">BuildBloom (문자열 해시 유형, 문자열 모드, 문자열 벡터 크기, 문자열 nbHash)</target>
        </trans-unit>
        <trans-unit id="18d161572120aa5ca2385817a4e05895af0e67ae" translate="yes" xml:space="preserve">
          <source>Built In Functions</source>
          <target state="translated">내장 함수</target>
        </trans-unit>
        <trans-unit id="17cb53c0f37443e9bf0f83632c45f7852961389a" translate="yes" xml:space="preserve">
          <source>But suppose that you knew that the label and value fields would never be null. You could define a more precise schema manually using a statement like:</source>
          <target state="translated">그러나 레이블 및 값 필드가 널이 아님을 알고 있다고 가정하십시오. 다음과 같은 명령문을 사용하여보다 정확한 스키마를 수동으로 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d1cc7e0f77e2a5963510dde7238148f8ad8afa3" translate="yes" xml:space="preserve">
          <source>But you can supply your own delimiter</source>
          <target state="translated">그러나 당신은 당신의 자신의 구분자를 제공 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="1bf4bb3fc488eb4c7a42b70d8ec7e1bfd59f5df0" translate="yes" xml:space="preserve">
          <source>By default Pig determines the number of reducers to use for a given job based on the size of the input to the map phase. The input data size is divided by the pig.exec.reducers.bytes.per.reducer parameter value (default 1GB) to determine the number of reducers. The maximum number of reducers for a job is limited by the pig.exec.reducers.max parameter (default 999).</source>
          <target state="translated">기본적으로 Pig는 맵 단계에 대한 입력 크기에 따라 주어진 작업에 사용할 감속기 수를 결정합니다. 입력 데이터 크기는 pig.exec.reducers.bytes.per.reducer 매개 변수 값 (기본값 1GB)으로 나누어 감속기 수를 결정합니다. 작업의 최대 감속기 수는 pig.exec.reducers.max 매개 변수 (기본값 999)에 의해 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="15ae52a6cf38c6b857919c8bd2af0f5e7c1426fc" translate="yes" xml:space="preserve">
          <source>By default, TOP function uses descending order. But it can be configured via DEFINE statement.</source>
          <target state="translated">기본적으로 TOP 함수는 내림차순을 사용합니다. 그러나 DEFINE 문을 통해 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95ee4b93ca14cb6f7558f6c77dacf5c78a6fd34b" translate="yes" xml:space="preserve">
          <source>By default, when you use AvoStorage to load data, AvroStorage will use depth first search to find a valid Avro file on the input path, then use the schema from that file to load the data. When you use AvroStorage to store data, AvroStorage will attempt to translate the Pig schema to an equivalent Avro schema. You can manually specify the schema by providing an explicit schema in Pig, loading a schema from an external schema file, or explicitly telling Pig to read the schema from a specific avro file.</source>
          <target state="translated">기본적으로 AvoStorage를 사용하여 데이터를로드 할 때 AvroStorage는 깊이 우선 검색을 사용하여 입력 경로에서 유효한 Avro 파일을 찾은 다음 해당 파일의 스키마를 사용하여 데이터를로드합니다. AvroStorage를 사용하여 데이터를 저장하면 AvroStorage는 Pig 스키마를 동등한 Avro 스키마로 변환하려고 시도합니다. Pig에 명시 적 스키마를 제공하거나 외부 스키마 파일에서 스키마를로드하거나 Pig에 특정 avro 파일에서 스키마를 읽도록 명시 적으로 지시하여 스키마를 수동으로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43462d8dcc25cc369fc5cad9b2008c7bfd6fcd44" translate="yes" xml:space="preserve">
          <source>By doing this, you will save HDFS space used to store the intermediate data used by PIG and potentially improve query execution speed. In general, the more intermediate data that is generated, the more benefits in storage and speed that result.</source>
          <target state="translated">이렇게하면 PIG에서 사용하는 중간 데이터를 저장하는 데 사용되는 HDFS 공간이 절약되고 쿼리 실행 속도가 향상 될 수 있습니다. 일반적으로 생성되는 중간 데이터가 많을수록 스토리지 및 속도면에서 더 많은 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="eff5d4cb9e452b26a3350ae0f6563ef4d317404c" translate="yes" xml:space="preserve">
          <source>Byte array (blob)</source>
          <target state="translated">바이트 배열 (블롭)</target>
        </trans-unit>
        <trans-unit id="703c04b3340bb6eafd886e786bbcc0167a8aedf6" translate="yes" xml:space="preserve">
          <source>Byte/Short/Integer: int</source>
          <target state="translated">바이트 / 짧은 / 정수 : int</target>
        </trans-unit>
        <trans-unit id="8e5fdab92dece79d7629d6d901687613ddc6ab5a" translate="yes" xml:space="preserve">
          <source>Bytes</source>
          <target state="translated">Bytes</target>
        </trans-unit>
        <trans-unit id="a02c3ced7d025da788df0e0ae6e66393935dc19d" translate="yes" xml:space="preserve">
          <source>CACHE &amp;ndash; Keyword.</source>
          <target state="translated">캐시 &amp;ndash; 키워드.</target>
        </trans-unit>
        <trans-unit id="9c1f8ee66330cd6444ad9ea2348aac5325942c63" translate="yes" xml:space="preserve">
          <source>CACHE('dfs_path#dfs_file' [, 'dfs_path#dfs_file' &amp;hellip;])</source>
          <target state="translated">CACHE ( 'dfs_path # dfs_file'[, 'dfs_path # dfs_file'&amp;hellip;])</target>
        </trans-unit>
        <trans-unit id="25dda59efbde37867474c7ac7817ae014d55e581" translate="yes" xml:space="preserve">
          <source>CASE : case</source>
          <target state="translated">사례 : 사례</target>
        </trans-unit>
        <trans-unit id="4bddb81b0ec047b396813830c096a95d9aa92f5e" translate="yes" xml:space="preserve">
          <source>CASE WHEN THEN ELSE END</source>
          <target state="translated">그렇지 않은 경우 사례</target>
        </trans-unit>
        <trans-unit id="d593a77520938048562134b083ee21f384cf86fa" translate="yes" xml:space="preserve">
          <source>CASE [ WHEN condition THEN value ]+ [ ELSE value ]? END</source>
          <target state="translated">CASE [조건이있을 때] + [ELSE 값]? 종료</target>
        </trans-unit>
        <trans-unit id="f84cf943477b79a70b16eb09c9c33707a500055f" translate="yes" xml:space="preserve">
          <source>CASE expression [ WHEN value THEN value ]+ [ ELSE value ]? END</source>
          <target state="translated">CASE 식 [WHEN 값 THEN 값] + [ELSE 값]? 종료</target>
        </trans-unit>
        <trans-unit id="1264e7eb4b20dc6000ef45c1c07db793592dd224" translate="yes" xml:space="preserve">
          <source>CBRT</source>
          <target state="translated">CBRT</target>
        </trans-unit>
        <trans-unit id="809670dc236157cba7e20398211c3208180791ab" translate="yes" xml:space="preserve">
          <source>CBRT(expression)</source>
          <target state="translated">CBRT(expression)</target>
        </trans-unit>
        <trans-unit id="47f02b51c01ebeac5cb6c70853e77684359bf494" translate="yes" xml:space="preserve">
          <source>CEIL</source>
          <target state="translated">CEIL</target>
        </trans-unit>
        <trans-unit id="cb33f60eca542bac46d5f3d17cbb4d964a664066" translate="yes" xml:space="preserve">
          <source>CEIL(expression)</source>
          <target state="translated">CEIL(expression)</target>
        </trans-unit>
        <trans-unit id="57238007cd7bef289664d41bd9c8598b4f1baefc" translate="yes" xml:space="preserve">
          <source>CEIL(x)</source>
          <target state="translated">CEIL(x)</target>
        </trans-unit>
        <trans-unit id="d9a1d355384a14bc732d4a7b06d0dd9368c26935" translate="yes" xml:space="preserve">
          <source>COGROUP</source>
          <target state="translated">COGROUP</target>
        </trans-unit>
        <trans-unit id="61d2357ea1cf20b65e598094448e91d1a48634c3" translate="yes" xml:space="preserve">
          <source>COGROUP, GROUP, JOIN</source>
          <target state="translated">공동 그룹, 그룹, 가입</target>
        </trans-unit>
        <trans-unit id="19079cc7f1267e0ab6f98c7f86edde6822ec26eb" translate="yes" xml:space="preserve">
          <source>CONCAT</source>
          <target state="translated">CONCAT</target>
        </trans-unit>
        <trans-unit id="a4df178f52eff1f27c82ed99784d7505359ccd79" translate="yes" xml:space="preserve">
          <source>CONCAT (expression, expression, [...expression])</source>
          <target state="translated">CONCAT (표현, 표현, [... 표현])</target>
        </trans-unit>
        <trans-unit id="9edf4f88e9dd701e66a0cb283875180b8f59ff3d" translate="yes" xml:space="preserve">
          <source>COS</source>
          <target state="translated">COS</target>
        </trans-unit>
        <trans-unit id="9cdcd6fb1f83c73bcbe631361f3bdb402bbaeca2" translate="yes" xml:space="preserve">
          <source>COS(expression)</source>
          <target state="translated">COS(expression)</target>
        </trans-unit>
        <trans-unit id="d1ed328c0d6ea0ce10316f1a6e51f6251cbb1ed9" translate="yes" xml:space="preserve">
          <source>COSH</source>
          <target state="translated">COSH</target>
        </trans-unit>
        <trans-unit id="1a52483f1cfe58f112bf651bfb837988fd694b54" translate="yes" xml:space="preserve">
          <source>COSH(expression)</source>
          <target state="translated">COSH(expression)</target>
        </trans-unit>
        <trans-unit id="e2bf90245c3eae70b50309837f6647c1f83fdf58" translate="yes" xml:space="preserve">
          <source>COUNT</source>
          <target state="translated">COUNT</target>
        </trans-unit>
        <trans-unit id="92e0c4f41f3a6b19ae2d9280ba49c3f2b0b08c6b" translate="yes" xml:space="preserve">
          <source>COUNT implements Algebraic interface which looks like this:</source>
          <target state="translated">COUNT는 다음과 같은 대수 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="63bf32efa3f79b5efeeafde859ce2bd68cc2940a" translate="yes" xml:space="preserve">
          <source>COUNT(expression)</source>
          <target state="translated">COUNT(expression)</target>
        </trans-unit>
        <trans-unit id="63abfdfedef17ad1caed7b55497d12fdc08598d1" translate="yes" xml:space="preserve">
          <source>COUNT_STAR</source>
          <target state="translated">COUNT_STAR</target>
        </trans-unit>
        <trans-unit id="84180b26541e787dbead7274fe837ebfc06fa2d3" translate="yes" xml:space="preserve">
          <source>COUNT_STAR includes NULL values in the count computation (unlike &lt;a href=&quot;#count&quot;&gt;COUNT&lt;/a&gt;, which ignores NULL values).</source>
          <target state="translated">COUNT_STAR는 카운트 계산에 NULL 값을 포함합니다 (NULL 값 을 무시하는 &lt;a href=&quot;#count&quot;&gt;COUNT&lt;/a&gt; 와 달리 ).</target>
        </trans-unit>
        <trans-unit id="9589b5312bee6763bef809f91a5689bcc422b2cf" translate="yes" xml:space="preserve">
          <source>COUNT_STAR(expression)</source>
          <target state="translated">COUNT_STAR(expression)</target>
        </trans-unit>
        <trans-unit id="7ea4fbcff919d74664df2b3abbe9c64927134ca1" translate="yes" xml:space="preserve">
          <source>CROSS</source>
          <target state="translated">CROSS</target>
        </trans-unit>
        <trans-unit id="d8cf38a47dfe68117b445e7444d00b2e58cce5ca" translate="yes" xml:space="preserve">
          <source>CROSS is an expensive operation and should be used sparingly.</source>
          <target state="translated">CROSS는 비용이 많이 드는 작업이므로 드물게 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="d4669b26661226d1080b57113a2265ca0df06a9c" translate="yes" xml:space="preserve">
          <source>CUBE</source>
          <target state="translated">CUBE</target>
        </trans-unit>
        <trans-unit id="f4113d57bab7aef4717841180b5549f01039bdc3" translate="yes" xml:space="preserve">
          <source>Cache Archive</source>
          <target state="translated">캐시 아카이브</target>
        </trans-unit>
        <trans-unit id="897a9f8e3d8fd1a7d212189812735fee2110b172" translate="yes" xml:space="preserve">
          <source>Calculates a &quot;popularity&quot; score for the n-gram.</source>
          <target state="translated">n- 그램에 대한 &quot;인기&quot;점수를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="7633fb83abb82cb5b7dce0eb512f33705f2b961c" translate="yes" xml:space="preserve">
          <source>Call the NGramGenerator UDF to compose the n-grams of the query.</source>
          <target state="translated">쿼리의 n- 그램을 작성하려면 NGramGenerator UDF를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="78ebe38efd79c381fef993c9ecdc3beffd7d8a29" translate="yes" xml:space="preserve">
          <source>Call the NonURLDetector UDF to remove records if the query field is empty or a URL.</source>
          <target state="translated">조회 필드가 비어 있거나 URL 인 경우 레코드를 제거하려면 NonURLDetector UDF를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="85686575d015c46036845dba435ad378e6074f9c" translate="yes" xml:space="preserve">
          <source>Call the ToLower UDF to change the query field to lowercase.</source>
          <target state="translated">조회 필드를 소문자로 변경하려면 ToLower UDF를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="26057558c8d1ceba1dfb290d88fd8159c1794732" translate="yes" xml:space="preserve">
          <source>Case Sensitivity</source>
          <target state="translated">대소 문자 구분</target>
        </trans-unit>
        <trans-unit id="686547c3088245230a160a7e0634a13586de3914" translate="yes" xml:space="preserve">
          <source>Case insensitive.</source>
          <target state="translated">대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7873929ddf881b1609b1a6c7da8b0957fe7f0e65" translate="yes" xml:space="preserve">
          <source>Case operator is equivalent to nested bincond operators.</source>
          <target state="translated">대소 문자 연산자는 중첩 된 bincond 연산자와 같습니다.</target>
        </trans-unit>
        <trans-unit id="5a95ed2864a76fc66062c5a7f51b3cb5c4d55c8a" translate="yes" xml:space="preserve">
          <source>Cast Operators</source>
          <target state="translated">캐스트 연산자</target>
        </trans-unit>
        <trans-unit id="97ba68fc56a3efba444f7c6353ffce14d1fabcb2" translate="yes" xml:space="preserve">
          <source>Cast operator</source>
          <target state="translated">캐스트 연산자</target>
        </trans-unit>
        <trans-unit id="c1d4be38e660193f2a954b1b03baad03fc56e532" translate="yes" xml:space="preserve">
          <source>Cast operators enable you to cast or convert data from one type to another, as long as conversion is supported (see the table above). For example, suppose you have an integer field, myint, which you want to convert to a string. You can cast this field from int to chararray using (chararray)myint.</source>
          <target state="translated">캐스트 연산자를 사용하면 변환이 지원되는 한 데이터를 한 유형에서 다른 유형으로 캐스트하거나 변환 할 수 있습니다 (위 표 참조). 예를 들어, 문자열로 변환하려는 정수 필드 myint가 있다고 가정하십시오. (chararray) myint를 사용하여이 필드를 int에서 chararray로 캐스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89afc7b02dce461eaab47536c34f98ce6705a599" translate="yes" xml:space="preserve">
          <source>Casting Relations to Scalars</source>
          <target state="translated">스칼라로 캐스팅 관계</target>
        </trans-unit>
        <trans-unit id="5561df78f96adb1b06bdd9dea00c3303d27015f0" translate="yes" xml:space="preserve">
          <source>Casting a null from one type to another type results in a null.</source>
          <target state="translated">한 유형에서 다른 유형으로 널을 캐스트하면 널이됩니다.</target>
        </trans-unit>
        <trans-unit id="3ffa70fc7594317492de738b40cad1f05ef27d5a" translate="yes" xml:space="preserve">
          <source>Changes the query field to lowercase.</source>
          <target state="translated">쿼리 필드를 소문자로 변경합니다.</target>
        </trans-unit>
        <trans-unit id="31e8f5b3a2fdbea62cb054aefa879f03617f38c2" translate="yes" xml:space="preserve">
          <source>Changes the sign of a positive or negative number.</source>
          <target state="translated">양수 또는 음수의 부호를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="995e5af086c799345cfff79290263b12e1c170e6" translate="yes" xml:space="preserve">
          <source>Character array (string) in Unicode UTF-8 format</source>
          <target state="translated">유니 코드 UTF-8 형식의 문자 배열 (문자열)</target>
        </trans-unit>
        <trans-unit id="951d999693844d2e216141efd80ff1eb9e3c4348" translate="yes" xml:space="preserve">
          <source>Check out the Pig code from SVN: svn co http://svn.apache.org/repos/asf/pig/trunk</source>
          <target state="translated">SVN에서 Pig 코드를 확인하십시오. svn co http://svn.apache.org/repos/asf/pig/trunk</target>
        </trans-unit>
        <trans-unit id="05d0a08eb4af8e7cfbcd5ebe464f2237e2c7f507" translate="yes" xml:space="preserve">
          <source>Check the existing javadoc to make sure that the function does not already exist as described in &lt;a href=&quot;#piggbank-access&quot;&gt;Accessing Functions&lt;/a&gt;.</source>
          <target state="translated">기존 javadoc을 점검하여 함수 &lt;a href=&quot;#piggbank-access&quot;&gt;액세스에&lt;/a&gt; 설명 된대로 함수가 이미 존재하지 않는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="b3dc9b8a00e2c52bd36be51e1b203feb64473349" translate="yes" xml:space="preserve">
          <source>Checkout UDF code: svn co http://svn.apache.org/repos/asf/pig/trunk/contrib/piggybank</source>
          <target state="translated">Checkout UDF 코드 : svn co http://svn.apache.org/repos/asf/pig/trunk/contrib/piggybank</target>
        </trans-unit>
        <trans-unit id="7aefc9de31fb7e8c4933ea3e3c5d5d7e8a0b3a38" translate="yes" xml:space="preserve">
          <source>Checkout the UDF code as described in &lt;a href=&quot;#piggbank-access&quot;&gt;Accessing Functions&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#piggbank-access&quot;&gt;기능 액세스에&lt;/a&gt; 설명 된대로 UDF 코드를 점검하십시오 .</target>
        </trans-unit>
        <trans-unit id="a8d0b4551d8ddf813fb85312a542c3dad06cd59d" translate="yes" xml:space="preserve">
          <source>Checks if a bag or map is empty.</source>
          <target state="translated">가방이나지도가 비어 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="eb097bdcbbf411e7f4af2f1e5646a166f52b5036" translate="yes" xml:space="preserve">
          <source>Classpath in Mapreduce Mode</source>
          <target state="translated">Mapreduce 모드의 클래스 경로</target>
        </trans-unit>
        <trans-unit id="d3691764851cad68ba80ad5e8fe636a4af2dcc0b" translate="yes" xml:space="preserve">
          <source>Clean up static variable in Tez</source>
          <target state="translated">Tez에서 정적 변수 정리</target>
        </trans-unit>
        <trans-unit id="5834db4b5dbea1c44492f8e208898a50ddfaaf1a" translate="yes" xml:space="preserve">
          <source>Clear the screen of Pig grunt shell and position the cursor at top of the screen.</source>
          <target state="translated">Pig grunt shell의 화면을 지우고 화면 상단에 커서를 놓습니다.</target>
        </trans-unit>
        <trans-unit id="1605056e4d309d49c970e63742a296cacc017c71" translate="yes" xml:space="preserve">
          <source>Column family prefix</source>
          <target state="translated">열 패밀리 접두사</target>
        </trans-unit>
        <trans-unit id="6d2e354ebe34ad6f8bf96f940f53151619e5e5a9" translate="yes" xml:space="preserve">
          <source>Column qualifier prefix</source>
          <target state="translated">열 한정자 접두사</target>
        </trans-unit>
        <trans-unit id="62838716e79a18596cfb80d0354b1ce8922b29bf" translate="yes" xml:space="preserve">
          <source>ColumnMapKeyPrune</source>
          <target state="translated">ColumnMapKeyPrune</target>
        </trans-unit>
        <trans-unit id="7ad7b7e1f056d8d1b6641e11e697052b7dab5bbf" translate="yes" xml:space="preserve">
          <source>ColumnMapKeyPrune also prunes unused map keys:</source>
          <target state="translated">ColumnMapKeyPrune은 또한 사용하지 않는 맵 키를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="8e3426653ed5a4705972948dec8a797240d9caf1" translate="yes" xml:space="preserve">
          <source>Combine Small Input Files</source>
          <target state="translated">작은 입력 파일 결합</target>
        </trans-unit>
        <trans-unit id="0bce653fb6ea1bc8b2ca15bcd7b72428b469c9fc" translate="yes" xml:space="preserve">
          <source>Combined Scripts</source>
          <target state="translated">결합 된 스크립트</target>
        </trans-unit>
        <trans-unit id="3254c0b1a1ded638067647659a40da16ce9b17fd" translate="yes" xml:space="preserve">
          <source>Combiner</source>
          <target state="translated">Combiner</target>
        </trans-unit>
        <trans-unit id="3087d5b48dbbe1194c6a9ba8039bb27fbcb4c7c5" translate="yes" xml:space="preserve">
          <source>Command line parameters and parameter files can be combined with command line parameters taking precedence.</source>
          <target state="translated">명령 행 매개 변수 및 매개 변수 파일을 우선하여 명령 행 매개 변수와 결합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3f7989370db1b8dddf391028455f4397eb24f47" translate="yes" xml:space="preserve">
          <source>Command line parameters are scanned in the order they are specified on the command line.</source>
          <target state="translated">명령 행 매개 변수는 명령 행에 지정된 순서대로 스캔됩니다.</target>
        </trans-unit>
        <trans-unit id="3e538a3732da323f6fc16be62970890cf4658d57" translate="yes" xml:space="preserve">
          <source>Common problems you may encounter are discussed below.</source>
          <target state="translated">발생할 수있는 일반적인 문제는 아래에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="dff8a6afef85ec10d66c35b1251c91c74754f7f3" translate="yes" xml:space="preserve">
          <source>Compares two Strings ignoring case considerations.</source>
          <target state="translated">대소 문자 고려 사항을 무시하고 두 문자열을 비교합니다.</target>
        </trans-unit>
        <trans-unit id="762fdd5e70e9fc418d3b09b86c28c19b3631e485" translate="yes" xml:space="preserve">
          <source>Compares two fields in a tuple.</source>
          <target state="translated">튜플에서 두 필드를 비교합니다.</target>
        </trans-unit>
        <trans-unit id="25acda77b0bc6b058bd349dd6f4a271e2a967bfe" translate="yes" xml:space="preserve">
          <source>Comparison Operators</source>
          <target state="translated">비교 연산자</target>
        </trans-unit>
        <trans-unit id="74f6692abeb3fa3be0bec25d2d0078edbe627529" translate="yes" xml:space="preserve">
          <source>Comparison operator:</source>
          <target state="translated">비교 연산자 :</target>
        </trans-unit>
        <trans-unit id="a7de33d110c915ab8e665813e77fafb72e84afb2" translate="yes" xml:space="preserve">
          <source>Comparison operators:</source>
          <target state="translated">비교 연산자 :</target>
        </trans-unit>
        <trans-unit id="c2f3e610efaad31893ca9eea02ebda3f70c91261" translate="yes" xml:space="preserve">
          <source>Compile</source>
          <target state="translated">Compile</target>
        </trans-unit>
        <trans-unit id="24fb061736c9186cc8f4cbd2cad61077bfa37e6b" translate="yes" xml:space="preserve">
          <source>Compile returns an instance of Pig object. This object can have certain values undefined. For example, you may want to define a pipeline without yet specifying the location of the input to the pipeline. The parameter will be indicated by a dollar sign followed by a sequence of alpha-numeric or underscore characters. Values for these parameters must be provided later at the time bind() is called on the Pig object. To call run() on a Pig object without all parameters being bound is an error.</source>
          <target state="translated">컴파일은 Pig 객체의 인스턴스를 반환합니다. 이 객체는 정의되지 않은 특정 값을 가질 수 있습니다. 예를 들어, 파이프 라인에 대한 입력 위치를 지정하지 않고 파이프 라인을 정의 할 수 있습니다. 이 매개 변수는 달러 기호와 일련의 영숫자 또는 밑줄 문자로 표시됩니다. 이 매개 변수의 값은 나중에 Pig 오브젝트에서 bind ()가 호출 될 때 제공되어야합니다. 모든 매개 변수를 바인딩하지 않고 Pig 객체에서 run ()을 호출하는 것은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="627c1a6bdf5bd4629f68282cc75c4e809c5d6b7f" translate="yes" xml:space="preserve">
          <source>Compile time evaluation</source>
          <target state="translated">컴파일 시간 평가</target>
        </trans-unit>
        <trans-unit id="99d4b8d0504f4971618f493ddedfe35c280300ef" translate="yes" xml:space="preserve">
          <source>Complex Pig scripts often generate many MapReduce jobs. To help you debug a script, Pig prints a summary of the execution that shows which relations (aliases) are mapped to each MapReduce job.</source>
          <target state="translated">복잡한 Pig 스크립트는 종종 많은 MapReduce 작업을 생성합니다. 스크립트 디버깅을 돕기 위해 Pig는 각 MapReduce 작업에 매핑되는 관계 (별칭)를 보여주는 실행 요약을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="64ce6788069d471cb2587d25c88affda9be267c5" translate="yes" xml:space="preserve">
          <source>Complex constants (either with or without values) can be used in the same places scalar constants can be used; that is, in FILTER and GENERATE statements.</source>
          <target state="translated">스칼라 상수를 사용할 수있는 동일한 위치에서 값이 있거나없는 복합 상수를 사용할 수 있습니다. 즉, FILTER 및 GENERATE 문에서.</target>
        </trans-unit>
        <trans-unit id="da4b23da53c3777ef41bc61293ffe5bcaa9ae12a" translate="yes" xml:space="preserve">
          <source>Complex data types include tuples, bags, and maps.</source>
          <target state="translated">복잡한 데이터 유형에는 튜플, 백 및 맵이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="e1431ea749e26770a721b743da55fc3888913734" translate="yes" xml:space="preserve">
          <source>Composes n-grams from the set of words.</source>
          <target state="translated">단어 집합에서 n- 그램을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="b5866bc1caf631ef6db627a15b013b81de2a00dd" translate="yes" xml:space="preserve">
          <source>Compress the Results of Intermediate Jobs</source>
          <target state="translated">중간 작업 결과 압축</target>
        </trans-unit>
        <trans-unit id="68d75c42f435c8631700579b9fd79cb3ac445482" translate="yes" xml:space="preserve">
          <source>Computes the average of the numeric values in a single-column bag.</source>
          <target state="translated">단일 열 백에서 숫자 값의 평균을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="2891cdf3a7692be59069c53ade96eed02e6b052c" translate="yes" xml:space="preserve">
          <source>Computes the cross product of two or more relations.</source>
          <target state="translated">둘 이상의 관계의 곱을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="bd19f2c54d768fb8e894978a41490a6071e2852c" translate="yes" xml:space="preserve">
          <source>Computes the maximum of the numeric values or chararrays in a single-column bag. MAX requires a preceding GROUP ALL statement for global maximums and a GROUP BY statement for group maximums.</source>
          <target state="translated">단일 열 백에서 숫자 값 또는 chararray의 최대 값을 계산합니다. MAX에는 글로벌 최대 값에 대한 선행 GROUP ALL 문과 그룹 최대 값에 대한 GROUP BY 문이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="781e2392f3673570db0e16ae2bf362595259d92d" translate="yes" xml:space="preserve">
          <source>Computes the minimum of the numeric values or chararrays in a single-column bag. MIN requires a preceding GROUP&amp;hellip; ALL statement for global minimums and a GROUP &amp;hellip; BY statement for group minimums.</source>
          <target state="translated">단일 열 백에서 숫자 값 또는 chararray의 최소값을 계산합니다. MIN에는 글로벌 최소값에 대한 선행 GROUP&amp;hellip; ALL 문과 그룹 최소값에 대한 GROUP&amp;hellip; BY 문이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="16fe1b8bf8ba65afe18482bd4a429a620d0e0085" translate="yes" xml:space="preserve">
          <source>Computes the number of elements based on any Pig data type.</source>
          <target state="translated">모든 Pig 데이터 유형을 기반으로 요소 수를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="259bbcb53d11033429cbe9b733a0d1065b5342cf" translate="yes" xml:space="preserve">
          <source>Computes the number of elements in a bag.</source>
          <target state="translated">백의 요소 수를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="3aa74f97eceaf3621205a5024fb680e6a7db859a" translate="yes" xml:space="preserve">
          <source>Computes the sum of the numeric values in a single-column bag. SUM requires a preceding GROUP ALL statement for global sums and a GROUP BY statement for group sums.</source>
          <target state="translated">단일 열 백에서 숫자 값의 합계를 계산합니다. SUM에는 전역 합계에 대한 선행 GROUP ALL 문과 그룹 합계에 대한 GROUP BY 문이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="e8f8fa9f1a5b634b2d8293cd0be4ea93bbbd6448" translate="yes" xml:space="preserve">
          <source>Computes the union of two or more relations.</source>
          <target state="translated">둘 이상의 관계의 합집합을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="953552ec4f49eb511470710579c3441f038a5f81" translate="yes" xml:space="preserve">
          <source>Concatenate the elements of a Bag into a chararray string, placing an optional delimiter between each value.</source>
          <target state="translated">Bag의 요소를 chararray 문자열로 연결하고 각 값 사이에 선택적 구분 기호를 배치하십시오.</target>
        </trans-unit>
        <trans-unit id="a50fa4950df193ca79197772974f2603f8ce2edf" translate="yes" xml:space="preserve">
          <source>Concatenates two or more expressions of identical type.</source>
          <target state="translated">동일한 유형의 둘 이상의 표현식을 연결합니다.</target>
        </trans-unit>
        <trans-unit id="368834630d459ecc51471d8ef1eb3550a7af82cb" translate="yes" xml:space="preserve">
          <source>Conditional Compilation</source>
          <target state="translated">조건부 컴파일</target>
        </trans-unit>
        <trans-unit id="5506eb6161a07356d96e91770d25d5a0f22200ef" translate="yes" xml:space="preserve">
          <source>Conditions</source>
          <target state="translated">Conditions</target>
        </trans-unit>
        <trans-unit id="fa731f861f1790542d39cd4d3d9051ad447d6b05" translate="yes" xml:space="preserve">
          <source>ConstantCalculator</source>
          <target state="translated">ConstantCalculator</target>
        </trans-unit>
        <trans-unit id="0f386d7e7881b32fa39cb7b62bdb15c0f3a4c0e1" translate="yes" xml:space="preserve">
          <source>Constants</source>
          <target state="translated">Constants</target>
        </trans-unit>
        <trans-unit id="edfe3fe416801e37cd88da5d0aa29057e9570fab" translate="yes" xml:space="preserve">
          <source>Continuing on, as shown in these FOREACH statements, we can refer to the fields in relation B by names &quot;group&quot; and &quot;A&quot; or by positional notation.</source>
          <target state="translated">계속해서이 FOREACH 문에 표시된대로 이름 &quot;group&quot;및 &quot;A&quot;또는 위치 표기법으로 관계 B의 필드를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="977e646d358c075361c97abc9a3e0c6ada79f4f2" translate="yes" xml:space="preserve">
          <source>Contributing Functions</source>
          <target state="translated">기여 함수</target>
        </trans-unit>
        <trans-unit id="49551177d73377982310b6a218929215d8146939" translate="yes" xml:space="preserve">
          <source>Control Structures</source>
          <target state="translated">제어 구조</target>
        </trans-unit>
        <trans-unit id="fa84f17a51b78d2a399b863b5b81838719cacf24" translate="yes" xml:space="preserve">
          <source>Convention</source>
          <target state="translated">Convention</target>
        </trans-unit>
        <trans-unit id="61856b8c17a4ff32006fe4b7dcc6f96f253b2120" translate="yes" xml:space="preserve">
          <source>Conventions</source>
          <target state="translated">Conventions</target>
        </trans-unit>
        <trans-unit id="2cab06ba1537b5cc789203048031500739aba455" translate="yes" xml:space="preserve">
          <source>Conventions for the syntax and code examples in the Pig Latin Reference Manual are described here.</source>
          <target state="translated">Pig Latin Reference Manual의 구문 및 코드 예제에 대한 규칙이 여기에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e80186bff955c4164f424d4ecf5aaac946a57e2" translate="yes" xml:space="preserve">
          <source>Convergence</source>
          <target state="translated">Convergence</target>
        </trans-unit>
        <trans-unit id="22447a2051656e9276e43737bf5f0a8427386d68" translate="yes" xml:space="preserve">
          <source>Converts all characters in a string to lower case.</source>
          <target state="translated">문자열의 모든 문자를 소문자로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="7b8ad8e1965955c62208647c53052185b418e7ea" translate="yes" xml:space="preserve">
          <source>Converts key/value expression pairs into a map.</source>
          <target state="translated">키 / 값 표현식 쌍을 맵으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="3c2ffc1a844c6412131a6457d870f19e04553a50" translate="yes" xml:space="preserve">
          <source>Converts one or more expressions to type bag.</source>
          <target state="translated">하나 이상의 표현식을 유형 백으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="63af98fd9dd364c1de90448bc37db4a35e74f2b0" translate="yes" xml:space="preserve">
          <source>Converts one or more expressions to type tuple.</source>
          <target state="translated">하나 이상의 표현식을 튜플 형식으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="e9173acc8f1bf681298ed4d60389c6d410b1ec34" translate="yes" xml:space="preserve">
          <source>Converts the first character in a string to lower case.</source>
          <target state="translated">문자열의 첫 문자를 소문자로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="0f2d67238eb128cd82a6b5504d7f63755693a7c1" translate="yes" xml:space="preserve">
          <source>Copy the excite.log.bz2 file from the pigtmp directory to the HDFS directory.</source>
          <target state="translated">exctmp.log.bz2 파일을 pigtmp 디렉토리에서 HDFS 디렉토리로 복사하십시오.</target>
        </trans-unit>
        <trans-unit id="e47e20a3c28f97f025c467edd8cb6db0cc5647dc" translate="yes" xml:space="preserve">
          <source>Copy the pigtutorial.tar.gz file from the Pig tutorial directory to your local directory.</source>
          <target state="translated">pig tutorial 디렉토리에서 pigtutorial.tar.gz 파일을 로컬 디렉토리로 복사하십시오.</target>
        </trans-unit>
        <trans-unit id="637b1d6e93e8819232e74cc78c253d76277bc676" translate="yes" xml:space="preserve">
          <source>Create a keytab file for the required principal.</source>
          <target state="translated">필요한 프린시 펄에 대한 키탭 파일을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="301276d5509597c6ddb83ad5dd55f70c0d4cc532" translate="yes" xml:space="preserve">
          <source>Create the pigtutorial.tar.gz file:</source>
          <target state="translated">pigtutorial.tar.gz 파일을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="69f2e4721ddacc3cb4e8c926ed22929260d61e42" translate="yes" xml:space="preserve">
          <source>Cube operation</source>
          <target state="translated">큐브 작업</target>
        </trans-unit>
        <trans-unit id="624cfb768588cc250267271458d02acc69e0d625" translate="yes" xml:space="preserve">
          <source>Cube operation computes aggregates for all possbile combinations of specified group by dimensions. The number of group by combinations generated by cube for n dimensions will be 2^n.</source>
          <target state="translated">큐브 작업은 차원별로 지정된 그룹의 모든 가능한 조합에 대한 집계를 계산합니다. n 차원에 대해 큐브에 의해 생성 된 조합 별 그룹 수는 2 ^ n입니다.</target>
        </trans-unit>
        <trans-unit id="8730f2d8696397fb442457096c2e2d0b979ac422" translate="yes" xml:space="preserve">
          <source>Curly brackets also used to indicate the bag data type. In this case &amp;lt;&amp;gt; is used to indicate required items.</source>
          <target state="translated">백 데이터 유형을 나타내는 데 중괄호도 사용됩니다. 이 경우 &amp;lt;&amp;gt;는 필수 항목을 나타내는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d76638bb5e5a5dcea4aaad2d039008b89ce724ac" translate="yes" xml:space="preserve">
          <source>Curly brackets enclose two or more items, one of which is required.</source>
          <target state="translated">중괄호는 두 개 이상의 항목을 묶으며 그 중 하나가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="d540c0153415895b0c20d227be79ff67ee364edb" translate="yes" xml:space="preserve">
          <source>CurrentTime</source>
          <target state="translated">CurrentTime</target>
        </trans-unit>
        <trans-unit id="cb9e8cac8fed135531ead79ae1738ee31ac3cf44" translate="yes" xml:space="preserve">
          <source>CurrentTime()</source>
          <target state="translated">CurrentTime()</target>
        </trans-unit>
        <trans-unit id="eab62ff4ba3b96fc5558c305eea6a9e9c8f3e5fc" translate="yes" xml:space="preserve">
          <source>Currently known issue in Tez mode includes:</source>
          <target state="translated">Tez 모드에서 현재 알려진 문제는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5887ff6e46804d97dd9b7b75fc79747d7f14d67a" translate="yes" xml:space="preserve">
          <source>Currently supported options are:</source>
          <target state="translated">현재 지원되는 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4e812292848afafa52d8add6ebd5b7c49b1a9528" translate="yes" xml:space="preserve">
          <source>Currently the MonitoredUDF annotation works with regular and Algebraic UDFs, but has no effect on UDFs that run in the Accumulator mode.</source>
          <target state="translated">현재 MonitoredUDF 주석은 일반 및 대수 UDF에서 작동하지만 누산기 모드에서 실행되는 UDF에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f921824fdfdf7e03a63178393f8baf604b41f5ba" translate="yes" xml:space="preserve">
          <source>Currently this feature is only available in Python and Groovy. You can pass command line arguments (the arguments after the script file name) to Python. These will become sys.argv in Python and will be passed as main's arguments in Groovy. For example: pig script.py student.txt. The corresponding script is:</source>
          <target state="translated">현재이 기능은 Python 및 Groovy에서만 사용할 수 있습니다. 명령 행 인수 (스크립트 파일 이름 다음의 인수)를 Python에 전달할 수 있습니다. 이것들은 파이썬에서 sys.argv가되고 Groovy에서 main의 인수로 전달됩니다. 예 : pig script.py student.txt 해당 스크립트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e6c94e160e2bf6558bdc7676f9ae7bc4156ecd4c" translate="yes" xml:space="preserve">
          <source>Currently, &lt;a href=&quot;http://pig.apache.org/docs/r0.13.0/api/org/apache/pig/PigServer.html&quot;&gt;PigServer&lt;/a&gt; is the main interface for embedding Pig in Java. PigServer can now be instantiated from multiple threads. (In the past, PigServer contained references to static data that prevented multiple instances of the object to be created from different threads within your application.) Please note that PigServer is NOT thread safe; the same object can't be shared across multiple threads.</source>
          <target state="translated">현재 &lt;a href=&quot;http://pig.apache.org/docs/r0.13.0/api/org/apache/pig/PigServer.html&quot;&gt;PigServer&lt;/a&gt; 는 Pig를 Java로 임베드하기위한 기본 인터페이스입니다. 여러 스레드에서 PigServer를 인스턴스화 할 수 있습니다. 과거에는 PigServer에 정적 데이터에 대한 참조가 포함되어있어 응용 프로그램 내의 다른 스레드에서 객체의 여러 인스턴스를 만들 수 없었습니다. PigServer는 스레드로부터 안전하지 않습니다. 동일한 객체를 여러 스레드에서 공유 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="51b6657e6963a591aeb3a066fd9921d2abc46dfc" translate="yes" xml:space="preserve">
          <source>Currently, &lt;a href=&quot;https://pig.apache.org/docs/r0.13.0/api/org/apache/pig/PigServer.html&quot;&gt;PigServer&lt;/a&gt; is the main interface for embedding Pig in Java. PigServer can now be instantiated from multiple threads. (In the past, PigServer contained references to static data that prevented multiple instances of the object to be created from different threads within your application.) Please note that PigServer is NOT thread safe; the same object can't be shared across multiple threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02caba8f873739ed6f4c7591b34e98a0607b6f51" translate="yes" xml:space="preserve">
          <source>Currently, TextLoader support for compression is limited.</source>
          <target state="translated">현재 압축에 대한 TextLoader 지원은 제한되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="318696e8c8efe2f664baf3bea3674ed8dfbdc815" translate="yes" xml:space="preserve">
          <source>Currently, dynamic invokers can be used for any static function that:</source>
          <target state="translated">현재 동적 호출자는 다음과 같은 정적 함수에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e668d12c6fda6f044eb4fa7943e937b63474896c" translate="yes" xml:space="preserve">
          <source>Currently, the following expressions in filter condition are supported in OrcStorage predicate pushdown: &amp;gt;, &amp;gt;=, &amp;lt;, &amp;lt;=, ==, !=, between, in, and, or, not. The missing expressions are: is null, is not null, matches.</source>
          <target state="translated">현재 필터 조건의 다음 표현식은 OrcStorage 술어 푸시 다운에서 지원됩니다.&amp;gt;,&amp;gt; =, &amp;lt;, &amp;lt;=, ==,! =, between, in 및 / 또는 not. 누락 된 표현식은 다음과 같습니다. null, null이 아닌 일치.</target>
        </trans-unit>
        <trans-unit id="1a29c0a9e5d031b1085dd3a49cebd323e159b0e8" translate="yes" xml:space="preserve">
          <source>DEFINE</source>
          <target state="translated">DEFINE</target>
        </trans-unit>
        <trans-unit id="db5c52e0d4fd4b266e123f0b9518c6fa49bfd979" translate="yes" xml:space="preserve">
          <source>DEFINE (UDFs, streaming)</source>
          <target state="translated">DEFINE (UDF, 스트리밍)</target>
        </trans-unit>
        <trans-unit id="47098d98335487ff8abc5d411606d97845151cea" translate="yes" xml:space="preserve">
          <source>DEFINE (macros)</source>
          <target state="translated">DEFINE (매크로)</target>
        </trans-unit>
        <trans-unit id="37a1eb443102b7b089c0f64ff5340898151d69e1" translate="yes" xml:space="preserve">
          <source>DEFINE alias {function | [`command` [input] [output] [ship] [cache] [stderr] ] };</source>
          <target state="translated">DEFINE 별명 {함수 | [`명령`[입력] [출력] [배] [캐시] [stderr]]};</target>
        </trans-unit>
        <trans-unit id="81860fd533b669c61bbb6f9a452a60cdb977890f" translate="yes" xml:space="preserve">
          <source>DEFINE macro_name (param [, param ...]) RETURNS {void | alias [, alias ...]} { pig_latin_fragment };</source>
          <target state="translated">DEFINE macro_name (param [, param ...]) RETURNS {void | alias [, alias ...]} {pig_latin_fragment};</target>
        </trans-unit>
        <trans-unit id="2651b57a220f2da95ee1649bca8e73943bc51729" translate="yes" xml:space="preserve">
          <source>DEFINE pluck PluckTuple(expression1)</source>
          <target state="translated">DEFINE pluck PluckTuple (표현식 1)</target>
        </trans-unit>
        <trans-unit id="d6a2cdc14717a24c8f160a66d554e96fbf5253d3" translate="yes" xml:space="preserve">
          <source>DEFINE pluck PluckTuple(expression1,expression3)</source>
          <target state="translated">DEFINE pluck PluckTuple (표현식 1, 표현식 3)</target>
        </trans-unit>
        <trans-unit id="27e6d727f2ae73b64299de676750d1aa1a7118e7" translate="yes" xml:space="preserve">
          <source>DENSE</source>
          <target state="translated">DENSE</target>
        </trans-unit>
        <trans-unit id="b5093023417eb749513563ec16d8c0c821aa5aff" translate="yes" xml:space="preserve">
          <source>DESC</source>
          <target state="translated">DESC</target>
        </trans-unit>
        <trans-unit id="188157101620ef8e467f19e0555258980540195c" translate="yes" xml:space="preserve">
          <source>DESCRIBE</source>
          <target state="translated">DESCRIBE</target>
        </trans-unit>
        <trans-unit id="9e0c6496d66c7c2f5e60dd3deb1b4aee138e422b" translate="yes" xml:space="preserve">
          <source>DESCRIBE alias;</source>
          <target state="translated">DESCRIBE 별칭;</target>
        </trans-unit>
        <trans-unit id="57c5f0062f55cff8d03b995b7e05c75422cf906f" translate="yes" xml:space="preserve">
          <source>DIFF</source>
          <target state="translated">DIFF</target>
        </trans-unit>
        <trans-unit id="3e501da6395fefc753e5db5f257720642ed93bc4" translate="yes" xml:space="preserve">
          <source>DIFF (expression, expression)</source>
          <target state="translated">DIFF (표현, 표현)</target>
        </trans-unit>
        <trans-unit id="45b1a3f093ba639c208b0bbbbe6cad9eff65396f" translate="yes" xml:space="preserve">
          <source>DISTINCT</source>
          <target state="translated">DISTINCT</target>
        </trans-unit>
        <trans-unit id="fac3a6812b938bfbdd2af221e2fba7ec856f466e" translate="yes" xml:space="preserve">
          <source>DUMP</source>
          <target state="translated">DUMP</target>
        </trans-unit>
        <trans-unit id="ae047c69b00835a1dbea01b5925b1a8da787ed07" translate="yes" xml:space="preserve">
          <source>DUMP Example: In this script, because the DUMP command is interactive, the multi-query execution will be disabled and two separate jobs will be created to execute this script. The first job will execute A &amp;gt; B &amp;gt; DUMP while the second job will execute A &amp;gt; B &amp;gt; C &amp;gt; STORE.</source>
          <target state="translated">DUMP 예 :이 스크립트에서 DUMP 명령은 대화식이므로 다중 쿼리 실행이 비활성화되고이 스크립트를 실행하기 위해 두 개의 개별 작업이 작성됩니다. 첫 번째 작업은 A&amp;gt; B&amp;gt; DUMP를 실행하고 두 번째 작업은 A&amp;gt; B&amp;gt; C&amp;gt; STORE를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="b06a59121fdc297727ca0e563052e200bd1b5c81" translate="yes" xml:space="preserve">
          <source>DUMP alias;</source>
          <target state="translated">덤프 별칭;</target>
        </trans-unit>
        <trans-unit id="c18842877f84be9bb3ae10673c4e60242f22c160" translate="yes" xml:space="preserve">
          <source>Data Types</source>
          <target state="translated">데이터 타입</target>
        </trans-unit>
        <trans-unit id="a613ab48f9dbf476990d61c14dd7fccb247d38bf" translate="yes" xml:space="preserve">
          <source>Data Types and More</source>
          <target state="translated">데이터 유형 및 기타</target>
        </trans-unit>
        <trans-unit id="23446d02d05e3bff5023dc4ecfec6cc7f6e70e66" translate="yes" xml:space="preserve">
          <source>Data can be easily stored into Accumulo.</source>
          <target state="translated">Accumulo에 데이터를 쉽게 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b03b1ef32dfb01490ddc83856cd403fb3ea217a" translate="yes" xml:space="preserve">
          <source>Data guarantees are determined based on the position of the streaming operator in the Pig script.</source>
          <target state="translated">데이터 보증은 Pig 스크립트에서 스트리밍 연산자의 위치에 따라 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="f563a15979c632fb30405fcee54d6700f10ec3eb" translate="yes" xml:space="preserve">
          <source>Data must be sorted on join keys in ascending (ASC) order on both sides.</source>
          <target state="translated">결합 키에서 데이터는 양쪽에서 오름차순 (ASC)으로 정렬되어야합니다.</target>
        </trans-unit>
        <trans-unit id="0c8a8b0eb65289ca0fcc97c9145d0dd3f5f2dc46" translate="yes" xml:space="preserve">
          <source>Data must be sorted on the COGROUP key for all tables in ascending (ASC) order.</source>
          <target state="translated">모든 테이블에 대해 COGROUP 키에서 데이터를 정렬해야합니다 (ASC).</target>
        </trans-unit>
        <trans-unit id="b920e2760550288f045935f0f4c601e019ed9342" translate="yes" xml:space="preserve">
          <source>Data must be sorted on the group key.</source>
          <target state="translated">그룹 키에서 데이터를 정렬해야합니다.</target>
        </trans-unit>
        <trans-unit id="b531b100948493c432b4f859e23a9d0be864fb75" translate="yes" xml:space="preserve">
          <source>Data must come directly from either a Load or an Order statement.</source>
          <target state="translated">데이터는 Load 또는 Order 문에서 직접 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="ee503fe5765b8d9456bf21def7f9e06d2b12ebb6" translate="yes" xml:space="preserve">
          <source>Data type</source>
          <target state="translated">데이터 형식</target>
        </trans-unit>
        <trans-unit id="b6be514c02654c4ded06230fc9559da237b0aa77" translate="yes" xml:space="preserve">
          <source>Data types</source>
          <target state="translated">자료형</target>
        </trans-unit>
        <trans-unit id="420d73810fe91851b37b6aaea508d4be91440655" translate="yes" xml:space="preserve">
          <source>Data: 10.5 or 10.5e2 or 10.5E2</source>
          <target state="translated">데이터 : 10.5 또는 10.5e2 또는 10.5E2</target>
        </trans-unit>
        <trans-unit id="5d55d8842e6d4ddd33b3a4dc2b7348a0f6e21e38" translate="yes" xml:space="preserve">
          <source>Data: 10.5F or 10.5f or 10.5e2f or 10.5E2F</source>
          <target state="translated">데이터 : 10.5F 또는 10.5f 또는 10.5e2f 또는 10.5E2F</target>
        </trans-unit>
        <trans-unit id="550e21eb7624cc089723132c6fd48e2922464452" translate="yes" xml:space="preserve">
          <source>Data: 10L or 10l</source>
          <target state="translated">데이터 : 10L 또는 10l</target>
        </trans-unit>
        <trans-unit id="5d428a9e9434002587a4ced1162533883987acd3" translate="yes" xml:space="preserve">
          <source>DataBag</source>
          <target state="translated">DataBag</target>
        </trans-unit>
        <trans-unit id="a59017c0e45cc7c49c56f753986f692cf80abc8b" translate="yes" xml:space="preserve">
          <source>DataBag: groovy.lang.Tuple containing the bag's size and an iterator on its content</source>
          <target state="translated">DataBag : groovy.lang. 가방의 크기와 내용에 반복자가 포함 된 튜플</target>
        </trans-unit>
        <trans-unit id="38c02c12462122bc5c052482d4e054143f653806" translate="yes" xml:space="preserve">
          <source>DataByteArray</source>
          <target state="translated">DataByteArray</target>
        </trans-unit>
        <trans-unit id="f1e5baf5ecc3589631088c40cbdd43061976ed8f" translate="yes" xml:space="preserve">
          <source>DateTime</source>
          <target state="translated">DateTime</target>
        </trans-unit>
        <trans-unit id="5293c89bb39e5e6e7f097951d91979e6f1d86206" translate="yes" xml:space="preserve">
          <source>Datetime Functions</source>
          <target state="translated">날짜 / 시간 함수</target>
        </trans-unit>
        <trans-unit id="28abd9ebb583f719f469cf8b089dff7c2737f644" translate="yes" xml:space="preserve">
          <source>DaysBetween</source>
          <target state="translated">DaysBetween</target>
        </trans-unit>
        <trans-unit id="ccc020a8a93ecc4010715150524628b029891725" translate="yes" xml:space="preserve">
          <source>DaysBetween(datetime1, datetime2)</source>
          <target state="translated">DaysBetween (datetime1, datetime2)</target>
        </trans-unit>
        <trans-unit id="dc8ddcb8f432e266948e934dd1279e8d988439f8" translate="yes" xml:space="preserve">
          <source>Debugging Pig Latin</source>
          <target state="translated">돼지 라틴어 디버깅</target>
        </trans-unit>
        <trans-unit id="6b567a67a520d2b8d2255f8877aedde30629e28a" translate="yes" xml:space="preserve">
          <source>Declare and default preprocessors statements are processed in the order they appear in the Pig script.</source>
          <target state="translated">선언 및 기본 전 처리기 명령문은 Pig 스크립트에 나타나는 순서대로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="12d8d1c37aa68dabcbab3f94878efdedc365a181" translate="yes" xml:space="preserve">
          <source>Decorators and Schemas</source>
          <target state="translated">데코레이터와 스키마</target>
        </trans-unit>
        <trans-unit id="0c634bbd5d12b6fa75cf4d332c05c57f913458d4" translate="yes" xml:space="preserve">
          <source>Default (no path specified): Stdout</source>
          <target state="translated">기본값 (경로가 지정되지 않음) : Stdout</target>
        </trans-unit>
        <trans-unit id="ef592af26d4de7c410c674b0e8ad3b58c465236a" translate="yes" xml:space="preserve">
          <source>Define Macro</source>
          <target state="translated">매크로 정의</target>
        </trans-unit>
        <trans-unit id="ae12133020835fd1fa7151717b3d44632da8a936" translate="yes" xml:space="preserve">
          <source>Defines a Pig macro.</source>
          <target state="translated">Pig 매크로를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="e470b7139fcd28a3e03c5dc98122c30f121e0ce7" translate="yes" xml:space="preserve">
          <source>Defining Aliases</source>
          <target state="translated">별칭 정의</target>
        </trans-unit>
        <trans-unit id="49ea420eea2cb023561b07d1dc69d39170ef2c11" translate="yes" xml:space="preserve">
          <source>Depending on your data, this can produce significant time savings. In queries similar to the example shown here we have seen total time drop by 50%.</source>
          <target state="translated">데이터에 따라 시간을 크게 절약 할 수 있습니다. 여기에 표시된 예와 유사한 쿼리에서 총 시간이 50 % 단축되었습니다.</target>
        </trans-unit>
        <trans-unit id="e46f5a56840e9e701c6ee35a24db7905e085d29f" translate="yes" xml:space="preserve">
          <source>Depending on your use case, it might be more efficient (improve performance) to split your script into multiple scripts.</source>
          <target state="translated">사용 사례에 따라 스크립트를 여러 스크립트로 분할하는 것이 더 효율적일 수 있습니다 (성능 향상).</target>
        </trans-unit>
        <trans-unit id="50e48bbb1c0b046f6807b6caf07160a8d7d3194b" translate="yes" xml:space="preserve">
          <source>Depends on the type of the pig script, PigRunner.run() returns a particular subclass of PigStats: SimplePigStats(MapReduce/local mode), TezPigScriptStats(Tez/Tez local mode) or EmbeddedPigStats(embedded script). SimplePigStats contains a map of JobStats which capture the stats for each MapReduce job of the Pig script. TezPigScriptStats contains a map of TezDAGStats which capture the stats for each Tez DAG of the Pig script, and TezDAGStats contains a map of TezVertexStats which capture the stats for each vertex within the Tez DAG. Depending on the execution type, EmbeddedPigStats contains a map of SimplePigStats or TezPigScriptStats, which captures the Pig job launched in the embeded script.</source>
          <target state="translated">pig 스크립트의 유형에 따라 PigRunner.run ()은 PigPass의 특정 서브 클래스를 반환합니다 : SimplePigStats (MapReduce / local 모드), TezPigScriptStats (Tez / Tez 로컬 모드) 또는 EmbeddedPigStats (내장 스크립트). SimplePigStats에는 Pig 스크립트의 각 MapReduce 작업에 대한 통계를 캡처하는 JobStats 맵이 포함되어 있습니다. TezPigScriptStats에는 Pig 스크립트의 각 Tez DAG에 대한 통계를 캡처하는 TezDAGStats 맵이 포함되어 있으며 TezDAGStats에는 Tez DAG 내의 각 정점에 대한 통계를 캡처하는 TezVertexStats 맵이 포함되어 있습니다. 실행 유형에 따라 EmbeddedPigStats에는 포함 된 스크립트에서 시작된 Pig 작업을 캡처하는 SimplePigStats 또는 TezPigScriptStats 맵이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8fe26f0a1f051f7a142a5f998121a4e0010e37b3" translate="yes" xml:space="preserve">
          <source>Dereference Operators</source>
          <target state="translated">역 참조 연산자</target>
        </trans-unit>
        <trans-unit id="f3ae6d2a1a3085eafb48a97da248afe3ba9d68fd" translate="yes" xml:space="preserve">
          <source>Dereference operators:</source>
          <target state="translated">역 참조 연산자 :</target>
        </trans-unit>
        <trans-unit id="9911fee20b5aaa559aca77a9a6a79b8db52c6dcf" translate="yes" xml:space="preserve">
          <source>Dereferencing a field that does not exist.</source>
          <target state="translated">존재하지 않는 필드를 참조 해제합니다.</target>
        </trans-unit>
        <trans-unit id="05d40cd98e3c6ce36506012b8866501887b993bb" translate="yes" xml:space="preserve">
          <source>Dereferencing a key that does not exist in a map. For example, given a map, info, containing [name#john, phone#5551212] if a user tries to use info#address a null is returned.</source>
          <target state="translated">맵에 존재하지 않는 키를 참조 해제합니다. 예를 들어, 사용자가 info # address를 사용하려고하면 [name # john, phone # 5551212]를 포함하는 맵 info가 제공된 경우 null이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="12694f0bfa56b7c3938cc2d9f85eb6164fff117d" translate="yes" xml:space="preserve">
          <source>Description.</source>
          <target state="translated">Description.</target>
        </trans-unit>
        <trans-unit id="b7d58206966807abc4cf52b41bb0063d3e834bea" translate="yes" xml:space="preserve">
          <source>Diagnostic Operators</source>
          <target state="translated">진단 연산자</target>
        </trans-unit>
        <trans-unit id="8192f73bbbcd6111aa0de8cb1a47466d986f3b4c" translate="yes" xml:space="preserve">
          <source>Direct Fetch</source>
          <target state="translated">직접 가져 오기</target>
        </trans-unit>
        <trans-unit id="79fd89c2c4112d9de06e0aa0b120f053561c7fd8" translate="yes" xml:space="preserve">
          <source>Direct fetch is turned on by default. To turn it off set the property opt.fetch to false or start Pig with the &quot;-N&quot; or &quot;-no_fetch&quot; option.</source>
          <target state="translated">직접 가져 오기는 기본적으로 켜져 있습니다. 이 기능을 끄려면 opt.fetch 속성을 false로 설정하거나 &quot;-N&quot;또는 &quot;-no_fetch&quot;옵션을 사용하여 Pig를 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="cf4e895a3163aa6a86d2c00a1b4ec996c7c44a75" translate="yes" xml:space="preserve">
          <source>Disabling Pig commands and operators</source>
          <target state="translated">Pig 명령 및 연산자 비활성화</target>
        </trans-unit>
        <trans-unit id="59edcadf119397cd39c85c9145fd465540155dda" translate="yes" xml:space="preserve">
          <source>Disambiguate Operator</source>
          <target state="translated">명확성 연산자</target>
        </trans-unit>
        <trans-unit id="223c147d34dd515b6939e9f57fe33a7f1c239980" translate="yes" xml:space="preserve">
          <source>Display the list of statements used so far.</source>
          <target state="translated">지금까지 사용한 명령문 목록을 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="dd7f32ac051745520b4ab9e5bad7a75f9743bb57" translate="yes" xml:space="preserve">
          <source>Display: 10.5 or 1050.0</source>
          <target state="translated">디스플레이 : 10.5 또는 1050.0</target>
        </trans-unit>
        <trans-unit id="17af24325f073623a658df534863082a31ac4ed3" translate="yes" xml:space="preserve">
          <source>Display: 10.5F or 1050.0F</source>
          <target state="translated">디스플레이 : 10.5F 또는 1050.0F</target>
        </trans-unit>
        <trans-unit id="4c7750a3673c72c2605b8c74d8ea58c532ebc514" translate="yes" xml:space="preserve">
          <source>Display: 10L</source>
          <target state="translated">디스플레이 : 10L</target>
        </trans-unit>
        <trans-unit id="37587b4b68b4cee4d9e477f01d258dd78c0cdc9f" translate="yes" xml:space="preserve">
          <source>Displays a step-by-step execution of a sequence of statements.</source>
          <target state="translated">일련의 명령문 실행을 단계별로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="ad5eca33faa70fec6c13a56261a8c51a60b529fe" translate="yes" xml:space="preserve">
          <source>Displays execution plans.</source>
          <target state="translated">실행 계획을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="683edc20e26b4410808f8710ea2a283c87f67133" translate="yes" xml:space="preserve">
          <source>Divides the query string into a set of words.</source>
          <target state="translated">쿼리 문자열을 단어 집합으로 나눕니다.</target>
        </trans-unit>
        <trans-unit id="50a314209c54751015d5ea87733dbccc98864d31" translate="yes" xml:space="preserve">
          <source>Division by zero</source>
          <target state="translated">0으로 나누기</target>
        </trans-unit>
        <trans-unit id="a3fcfd6528d1296343b8cb0ac31626d0fb096d1a" translate="yes" xml:space="preserve">
          <source>Does not eliminate duplicate tuples.</source>
          <target state="translated">중복 튜플을 제거하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="35033055ad4cd5083100c925a16666fa6c40a106" translate="yes" xml:space="preserve">
          <source>Does not ensure (as databases do) that all tuples adhere to the same schema or that they have the same number of fields. In a typical scenario, however, this should be the case; therefore, it is the user's responsibility to either (1) ensure that the tuples in the input relations have the same schema or (2) be able to process varying tuples in the output relation.</source>
          <target state="translated">(데이터베이스처럼) 모든 튜플이 동일한 스키마를 준수하거나 필드 수가 동일한 지 확인하지 않습니다. 그러나 일반적인 시나리오에서는이 경우에 해당합니다. 따라서 (1) 입력 관계의 튜플이 동일한 스키마를 갖도록하거나 (2) 출력 관계에서 다양한 튜플을 처리 할 수있는 것은 사용자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="aa01c38c463d8a846f6a6ab94094f754227474a4" translate="yes" xml:space="preserve">
          <source>Does not expand nested plans (presenting a smaller graph for overview).</source>
          <target state="translated">중첩 된 계획을 확장하지 않습니다 (개요를 위해 더 작은 그래프 표시).</target>
        </trans-unit>
        <trans-unit id="e0be83eb8780dc9b54cc61d5b72ac15f2d8c78fd" translate="yes" xml:space="preserve">
          <source>Does not preserve the order of tuples. Both the input and output relations are interpreted as unordered bags of tuples.</source>
          <target state="translated">튜플의 순서를 유지하지 않습니다. 입력 및 출력 관계는 정렬되지 않은 튜플 백으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="ae413c0cd3f131157c474ace5bdc984cc71e12bf" translate="yes" xml:space="preserve">
          <source>Dot mode: outputs a format that can be passed to the dot utility for graphical display &amp;ndash; will generate a directed-acyclic-graph (DAG) of the plans in any supported format (.gif, .jpg ...).</source>
          <target state="translated">도트 모드 : 그래픽 표시를 위해 도트 유틸리티에 전달할 수있는 형식을 출력합니다. 지원되는 형식 (.gif, .jpg ...)으로 계획의 DAG (Directed-Acyclic-graph)를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="81581597044514bf54d4f97266022fc991f3915e" translate="yes" xml:space="preserve">
          <source>Double</source>
          <target state="translated">Double</target>
        </trans-unit>
        <trans-unit id="d7bf818139b86b7cebcedb6f2c0907edb4481864" translate="yes" xml:space="preserve">
          <source>Double: double</source>
          <target state="translated">더블 : 더블</target>
        </trans-unit>
        <trans-unit id="ec9b7a41b2f61d68a5d4935c6113ecf84c1ea895" translate="yes" xml:space="preserve">
          <source>Doubles</source>
          <target state="translated">Doubles</target>
        </trans-unit>
        <trans-unit id="025f4906d477361f65965110efc6755036aa20e0" translate="yes" xml:space="preserve">
          <source>Downcasts may cause loss of data. For example casting from long to int may drop bits.</source>
          <target state="translated">다운 캐스트로 인해 데이터가 손실 될 수 있습니다. 예를 들어 long에서 int로 캐스팅하면 비트가 떨어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2aec89caaf73c4362631396ddfd96dc27ff2460" translate="yes" xml:space="preserve">
          <source>Download Pig</source>
          <target state="translated">돼지 다운로드</target>
        </trans-unit>
        <trans-unit id="d7dd3c4f9a6e46519046904bc1fc66f03a9197ba" translate="yes" xml:space="preserve">
          <source>Download a recent stable release from one of the Apache Download Mirrors (see &lt;a href=&quot;http://hadoop.apache.org/pig/releases.html&quot;&gt; Pig Releases&lt;/a&gt;).</source>
          <target state="translated">Apache Download Mirrors 중 하나에서 최신의 안정적인 릴리스를 다운로드하십시오 ( &lt;a href=&quot;http://hadoop.apache.org/pig/releases.html&quot;&gt;Pig Releases&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="d234374728a38e543cf313cbfab70ceffe5deefa" translate="yes" xml:space="preserve">
          <source>Download a recent stable release from one of the Apache Download Mirrors (see &lt;a href=&quot;https://hadoop.apache.org/pig/releases.html&quot;&gt; Pig Releases&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd03b608df33917f12d718470a1eef5b7a7abaad" translate="yes" xml:space="preserve">
          <source>Drop Nulls Before a Join</source>
          <target state="translated">조인 전에 널 삭제</target>
        </trans-unit>
        <trans-unit id="bc14456af28e8d7c882ba667709785fbff1f2a77" translate="yes" xml:space="preserve">
          <source>Dumps or displays results to screen.</source>
          <target state="translated">화면에 결과를 덤프하거나 표시합니다.</target>
        </trans-unit>
        <trans-unit id="fe28381d7027a0d463ca2e132e77bf65c1682eb9" translate="yes" xml:space="preserve">
          <source>Dynamic Invokers</source>
          <target state="translated">동적 호출자</target>
        </trans-unit>
        <trans-unit id="4c426d8a199ec97cecd0d9a542b753470d8dd1f0" translate="yes" xml:space="preserve">
          <source>ENDSWITH</source>
          <target state="translated">ENDSWITH</target>
        </trans-unit>
        <trans-unit id="b806d421471fc8fb427219b0c2d21fe0709843ea" translate="yes" xml:space="preserve">
          <source>ENDSWITH(string, testAgainst)</source>
          <target state="translated">ENDSWITH (문자열, testAgainst)</target>
        </trans-unit>
        <trans-unit id="6c208e949d20bfe95e6078574b9fd17442f7496b" translate="yes" xml:space="preserve">
          <source>EXP</source>
          <target state="translated">EXP</target>
        </trans-unit>
        <trans-unit id="204b7118bc2897a1c86021078101de6f72009872" translate="yes" xml:space="preserve">
          <source>EXP(expression)</source>
          <target state="translated">EXP(expression)</target>
        </trans-unit>
        <trans-unit id="4f7eee905948e6076168f8edbc3bf97ae8823930" translate="yes" xml:space="preserve">
          <source>EXPLAIN</source>
          <target state="translated">EXPLAIN</target>
        </trans-unit>
        <trans-unit id="0b9bacfcf67ad598af9b4a504b7da25498937ebc" translate="yes" xml:space="preserve">
          <source>EXPLAIN [&amp;ndash;script pigscript] [&amp;ndash;out path] [&amp;ndash;brief] [&amp;ndash;dot] [-xml] [&amp;ndash;param param_name = param_value] [&amp;ndash;param_file file_name] alias;</source>
          <target state="translated">EXPLAIN [&amp;ndash;script pigscript] [&amp;ndash;out path] [&amp;ndash;brief] [-dot] [-xml] [&amp;ndash;param param_name = param_value] [&amp;ndash;param_file file_name] 별명;</target>
        </trans-unit>
        <trans-unit id="b1a30cd38e60158ede3f14b24e952f341522f5d0" translate="yes" xml:space="preserve">
          <source>Each UDF must extend the EvalFunc class and implement all necessary functions there.</source>
          <target state="translated">각 UDF는 EvalFunc 클래스를 확장하고 필요한 모든 기능을 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="81829c855f89e82bbedba7c71bd0080d52d1cbf7" translate="yes" xml:space="preserve">
          <source>Each clause can be specified at most once (for example, multiple inputs are not allowed)</source>
          <target state="translated">각 절은 최대 한 번만 지정할 수 있습니다 (예 : 여러 입력이 허용되지 않음)</target>
        </trans-unit>
        <trans-unit id="1464064fa90628942c50b4b706e05c7f812c35c1" translate="yes" xml:space="preserve">
          <source>Either a fixed length byte array, or a union of a fixed length array and null</source>
          <target state="translated">고정 길이 바이트 배열이거나 고정 길이 배열의 합집합</target>
        </trans-unit>
        <trans-unit id="ab6c2b236c7e87a46d973b5bb952c8a1f7664fdd" translate="yes" xml:space="preserve">
          <source>Either a map, or a union of a map and null</source>
          <target state="translated">지도 또는지도와 null의 합집합</target>
        </trans-unit>
        <trans-unit id="3428bc806d12855def09e17ffd788a2dd34ae3c2" translate="yes" xml:space="preserve">
          <source>Either a record type, or a union or a record and null</source>
          <target state="translated">레코드 유형 또는 공용체 또는 레코드 및 널</target>
        </trans-unit>
        <trans-unit id="f4831437145730ff496f3eed3b26868c4db0aadc" translate="yes" xml:space="preserve">
          <source>Either an array, or a union of an array and null</source>
          <target state="translated">배열이거나 배열과 null의 합집합</target>
        </trans-unit>
        <trans-unit id="7e0441516776faa9acca8b82d7eeb42b546bcc77" translate="yes" xml:space="preserve">
          <source>Either an enum or a union of an enum and null</source>
          <target state="translated">열거 형 또는 열거 형과 null의 합집합</target>
        </trans-unit>
        <trans-unit id="ad38961ef4e875951f8ce4ede61aad8b0dc77349" translate="yes" xml:space="preserve">
          <source>Elements are type-converted for you (but see examples below)</source>
          <target state="translated">요소는 당신을 위해 유형 변환됩니다 (그러나 아래 예를 참조하십시오)</target>
        </trans-unit>
        <trans-unit id="9dc92a43c704fdadda8fb8bd302195cf437a7f6d" translate="yes" xml:space="preserve">
          <source>Embedded Pig - Java</source>
          <target state="translated">임베디드 돼지-Java</target>
        </trans-unit>
        <trans-unit id="f07ea53b10ce749125487b5f541b85ba2b8d7877" translate="yes" xml:space="preserve">
          <source>Embedded Pig - Python, JavaScript and Groovy</source>
          <target state="translated">임베디드 돼지-Python, JavaScript 및 Groovy</target>
        </trans-unit>
        <trans-unit id="b8f58cbd1f6800cc4aca49950202fd6b576e92c2" translate="yes" xml:space="preserve">
          <source>Embedded Pig is supported in batch mode only, not interactive mode. You can request that embedded Pig be used by adding the --embedded option to the Pig command line. If this option is passed as an argument, that argument will refer to the language Pig is embedded in, either Python, JavaScript or Groovy. If no argument is specified, it is taken to refer to the reference implementation for Python.</source>
          <target state="translated">Embedded Pig는 대화식 모드가 아닌 배치 모드에서만 지원됩니다. Pig 명령 행에 --embedded 옵션을 추가하여 내장 Pig를 사용하도록 요청할 수 있습니다. 이 옵션이 인수로 전달되면 해당 인수는 Pig가 Python, JavaScript 또는 Groovy에 포함 된 언어를 나타냅니다. 인수가 지정되지 않으면 Python에 대한 참조 구현을 참조하는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="63b23423da0d5105a8f26d78ee99c5ecee4af49a" translate="yes" xml:space="preserve">
          <source>EmbeddedPigStats</source>
          <target state="translated">EmbeddedPigStats</target>
        </trans-unit>
        <trans-unit id="d09ac2b5f58d53e3199eae3523616ba8fdd81fbc" translate="yes" xml:space="preserve">
          <source>EmbeddedPigStats is a new class that extends PigStats. EmbeddedPigStats will return null for methods not listed in the proposal below.</source>
          <target state="translated">EmbeddedPigStats는 PigStats를 확장하는 새로운 클래스입니다. EmbeddedPigStats는 아래 제안에 나열되지 않은 메서드에 대해 null을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8d0920803010bc7aa65d5671c3ad28307291d655" translate="yes" xml:space="preserve">
          <source>Empty bag is valid: {}</source>
          <target state="translated">빈 가방이 유효합니다 : {}</target>
        </trans-unit>
        <trans-unit id="1cb06319fea0194ec50c25ba093150b83826059b" translate="yes" xml:space="preserve">
          <source>Empty map is valid: []</source>
          <target state="translated">빈지도가 유효합니다 : []</target>
        </trans-unit>
        <trans-unit id="3dbf74f9b11580ca050c433c4ce8228f55286416" translate="yes" xml:space="preserve">
          <source>Empty tuple is valid: ()</source>
          <target state="translated">빈 튜플은 유효합니다 : ()</target>
        </trans-unit>
        <trans-unit id="f3104dd45718e6d1ac6a03b91ae67193ae8361f0" translate="yes" xml:space="preserve">
          <source>Enums</source>
          <target state="translated">Enums</target>
        </trans-unit>
        <trans-unit id="b5a0f7a582db1f50e0815dc3c3cc7b123b0721df" translate="yes" xml:space="preserve">
          <source>EqualsIgnoreCase</source>
          <target state="translated">EqualsIgnoreCase</target>
        </trans-unit>
        <trans-unit id="30954b8c72a70034765f9c86d3c8904449fe48f1" translate="yes" xml:space="preserve">
          <source>EqualsIgnoreCase(string1, string2)</source>
          <target state="translated">EqualsIgnoreCase (문자열 1, 문자열 2)</target>
        </trans-unit>
        <trans-unit id="5fff1f56919b006049c274c6c76fbbe56470ee4c" translate="yes" xml:space="preserve">
          <source>Error Handling</source>
          <target state="translated">오류 처리</target>
        </trans-unit>
        <trans-unit id="08a9ae7c33953daf46a17c3b87dd4aa32cb48bdd" translate="yes" xml:space="preserve">
          <source>Error message when assertion fails.</source>
          <target state="translated">어설 션이 실패하면 오류 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="dae8e194b5eb34f03b0d0a18f0d07616af0eb2cb" translate="yes" xml:space="preserve">
          <source>Eval Functions</source>
          <target state="translated">평가 함수</target>
        </trans-unit>
        <trans-unit id="a751214a3b2a040cbf416d2610a48a7fbbdc2491" translate="yes" xml:space="preserve">
          <source>Eval is the most common type of function. It can be used in FOREACH statements as shown in this script:</source>
          <target state="translated">평가는 가장 일반적인 유형의 함수입니다. 이 스크립트에 표시된대로 FOREACH 문에서 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9af9812b93bc28ed1594d51f1f72928b79d73e22" translate="yes" xml:space="preserve">
          <source>Every Pig script will be compiled into 1 or more Tez DAG (typically 1). Every Tez DAG consists of a number of vertices and and edges connecting vertices. For example, a simple join involves 1 DAG which consists of 3 vertices: load left input, load right input and join. Do an &lt;a href=&quot;test#explain&quot;&gt;explain&lt;/a&gt; in Tez mode will show you the DAG Pig script compiled into.</source>
          <target state="translated">모든 Pig 스크립트는 하나 이상의 Tez DAG (일반적으로 1)로 컴파일됩니다. 모든 Tez DAG는 많은 정점과 정점을 연결하는 모서리로 구성됩니다. 예를 들어, 단순 결합에는 왼쪽 입력로드, 오른쪽 입력로드 및 결합의 3 개의 정점이 구성되는 1 개의 DAG가 포함됩니다. 마십시오 &lt;a href=&quot;test#explain&quot;&gt;설명&lt;/a&gt; 당신에게로 컴파일 된 DAG 돼지 스크립트를 표시합니다 TEZ 모드.</target>
        </trans-unit>
        <trans-unit id="e0794e8808789abe3fda6668b6c3fa7bc6b85f64" translate="yes" xml:space="preserve">
          <source>Every even element (value-expression) can be of any type supported by a map.</source>
          <target state="translated">모든 짝수 요소 (값 표현)는 맵에서 지원하는 모든 유형일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="034c3e8fa655445e95ff288bdb0a93f8642a4d83" translate="yes" xml:space="preserve">
          <source>Every odd element (key-expression) must be a chararray since only chararrays can be keys into the map</source>
          <target state="translated">chararray 만 맵의 키가 될 수 있기 때문에 모든 홀수 요소 (키 표현)는 chararray 여야합니다.</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="10dc3b2e2f7430ac6a06249e62e2a09943a0ac11" translate="yes" xml:space="preserve">
          <source>Example - Relation</source>
          <target state="translated">예-관계</target>
        </trans-unit>
        <trans-unit id="3d7290c4a531231054e9016df90fb299e8bfd58f" translate="yes" xml:space="preserve">
          <source>Example - Script</source>
          <target state="translated">예-스크립트</target>
        </trans-unit>
        <trans-unit id="8ef2e1210c47909b18d1b60b9c30a0116c39a246" translate="yes" xml:space="preserve">
          <source>Example 1:</source>
          <target state="translated">예 1 :</target>
        </trans-unit>
        <trans-unit id="e11895e8b0e4fd9700bfd1eef21691b78b345f1b" translate="yes" xml:space="preserve">
          <source>Example 2:</source>
          <target state="translated">예 2 :</target>
        </trans-unit>
        <trans-unit id="54f85e3dc3dd2c0b4767af56afba3c384c1b45de" translate="yes" xml:space="preserve">
          <source>Example Scripts</source>
          <target state="translated">스크립트 예</target>
        </trans-unit>
        <trans-unit id="51f2ed478ac1a0f9ac0956fb53ca2c0db26af096" translate="yes" xml:space="preserve">
          <source>Example using DISTINCT:</source>
          <target state="translated">DISTINCT를 사용하는 예 :</target>
        </trans-unit>
        <trans-unit id="0bc3dadc9c5ecd0199ac2fbdc9862a27c595bed2" translate="yes" xml:space="preserve">
          <source>Example using GROUP BY - GENERATE:</source>
          <target state="translated">GROUP BY-GENERATE를 사용하는 예 :</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="3f456e178b3eed928d6116b4511ee436e9586416" translate="yes" xml:space="preserve">
          <source>Example: Accessing a field that does not exist in a tuple</source>
          <target state="translated">예 : 튜플에 존재하지 않는 필드에 액세스</target>
        </trans-unit>
        <trans-unit id="3a35a21a18a9561f0551f205567b8c0da8ad240e" translate="yes" xml:space="preserve">
          <source>Example: Applying Functions</source>
          <target state="translated">예 : 기능 적용</target>
        </trans-unit>
        <trans-unit id="b0036a0911cb7b14e81e5c4edb97c8876c419a89" translate="yes" xml:space="preserve">
          <source>Example: DEFINE with STREAM</source>
          <target state="translated">예 : STREAM을 사용한 DEFINE</target>
        </trans-unit>
        <trans-unit id="697eeea680629a44cbf3fc5e3d70460bf410e1fc" translate="yes" xml:space="preserve">
          <source>Example: Data Guarantees</source>
          <target state="translated">예 : 데이터 보증</target>
        </trans-unit>
        <trans-unit id="2b44f8b519359304a6a86acef4e4ff979e8ac932" translate="yes" xml:space="preserve">
          <source>Example: Flatten</source>
          <target state="translated">예 : 전개</target>
        </trans-unit>
        <trans-unit id="b5a345acd0702631e315c1037d1ac7cda62aa7e6" translate="yes" xml:space="preserve">
          <source>Example: Inner Bag</source>
          <target state="translated">예 : 이너 백</target>
        </trans-unit>
        <trans-unit id="e6db9f3e22e770cb882c1a60d1569bac9510e7d1" translate="yes" xml:space="preserve">
          <source>Example: Nested Block</source>
          <target state="translated">예 : 중첩 블록</target>
        </trans-unit>
        <trans-unit id="f63e688cbd3f19df08a536c53c891aea5508ca6e" translate="yes" xml:space="preserve">
          <source>Example: Nested Projection</source>
          <target state="translated">예 : 중첩 투영</target>
        </trans-unit>
        <trans-unit id="cf41ef4f72f1e624c37c38499dcd5955dbb37ba0" translate="yes" xml:space="preserve">
          <source>Example: Outer Bag</source>
          <target state="translated">예 : 외부 가방</target>
        </trans-unit>
        <trans-unit id="5059ad18be2d8e9fda54534792e319900ff7faa9" translate="yes" xml:space="preserve">
          <source>Example: PARTITION BY</source>
          <target state="translated">예 : PARTITION BY</target>
        </trans-unit>
        <trans-unit id="410a817acfb69db123be8875ba904348c91af435" translate="yes" xml:space="preserve">
          <source>Example: Projection</source>
          <target state="translated">예 : 투영</target>
        </trans-unit>
        <trans-unit id="b43180fdcf3879c7d50507f764592c9d1dcabf01" translate="yes" xml:space="preserve">
          <source>Example: Schema</source>
          <target state="translated">예 : 스키마</target>
        </trans-unit>
        <trans-unit id="fe142d2645d18e2bfc6839f4cdf713292f8274c4" translate="yes" xml:space="preserve">
          <source>Example: Schemas</source>
          <target state="translated">예 : 스키마</target>
        </trans-unit>
        <trans-unit id="6af48524a399d2a3397701b0e3e6c91b7f9eeae4" translate="yes" xml:space="preserve">
          <source>Example: X = JOIN A BY fieldA, B BY fieldB, C BY fieldC;</source>
          <target state="translated">예 : X = A BY 필드 A, B BY 필드 B, C BY 필드 C에 가입;</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="62d99e06cf09db44be6d93ffd5bffdc689e4b88f" translate="yes" xml:space="preserve">
          <source>Examples: DEFINE a function</source>
          <target state="translated">예 : 함수 정의</target>
        </trans-unit>
        <trans-unit id="3df6621b42ea94e7fdf3378d68254408a4f5a066" translate="yes" xml:space="preserve">
          <source>Examples: Input/Output</source>
          <target state="translated">예 : 입력 / 출력</target>
        </trans-unit>
        <trans-unit id="74ac88b71af2599cb5ce99c45ed31fc7e9447d91" translate="yes" xml:space="preserve">
          <source>Examples: Logging</source>
          <target state="translated">예 : 로깅</target>
        </trans-unit>
        <trans-unit id="37f3ef42e9702eae2cd231255b6fcad266852122" translate="yes" xml:space="preserve">
          <source>Examples: Ship/Cache</source>
          <target state="translated">예 : 선박 / 캐시</target>
        </trans-unit>
        <trans-unit id="0563a4f30398c5cae92a4adaa4da100e6c9fd68f" translate="yes" xml:space="preserve">
          <source>Execute the following command (using either script1-hadoop.pig or script2-hadoop.pig):</source>
          <target state="translated">script1-hadoop.pig 또는 script2-hadoop.pig를 사용하여 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="4c82ded2a8821d22b497de5e5eb18a8a066f24ce" translate="yes" xml:space="preserve">
          <source>Execute the following command (using either script1-local.pig or script2-local.pig).</source>
          <target state="translated">script1-local.pig 또는 script2-local.pig를 사용하여 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="701fcbd76ef3e23ccdf3671baf9cb2b29d828e2d" translate="yes" xml:space="preserve">
          <source>Executes native MapReduce/Tez jobs inside a Pig script.</source>
          <target state="translated">Pig 스크립트 내에서 기본 MapReduce / Tez 작업을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="b43bb7f8a4a52f8aa1d713b0b45feb59391843c8" translate="yes" xml:space="preserve">
          <source>Execution Modes</source>
          <target state="translated">실행 모드</target>
        </trans-unit>
        <trans-unit id="5aceb19ceb6ddd597f2b6f0d9d93affc009dd5b2" translate="yes" xml:space="preserve">
          <source>Expand Macro</source>
          <target state="translated">매크로 확장</target>
        </trans-unit>
        <trans-unit id="6efd5a6d8d675b7fc9d93213867fed8fefa09b74" translate="yes" xml:space="preserve">
          <source>Explicit and Implicit Splits</source>
          <target state="translated">명시 적 및 암시 적 분할</target>
        </trans-unit>
        <trans-unit id="2b8eb6b1bf81787fd6e0e66cdda074e83ab1d197" translate="yes" xml:space="preserve">
          <source>Explicitly specify a column family and column qualifier (e.g., user_info:id). This will produce a scalar in the resultant tuple.</source>
          <target state="translated">열 패밀리 및 열 규정자를 명시 적으로 지정하십시오 (예 : user_info : id). 결과 튜플에 스칼라가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="ae5fccd8dcd8fc317f8edfc8259af86cd2967a29" translate="yes" xml:space="preserve">
          <source>Expressions</source>
          <target state="translated">Expressions</target>
        </trans-unit>
        <trans-unit id="a557d3ee4d2a42021dd41d68f5a11ae8eb396bad" translate="yes" xml:space="preserve">
          <source>Expressions are written in conventional mathematical infix notation and are adapted to the UTF-8 character set. Depending on the context, expressions can include:</source>
          <target state="translated">표현식은 일반적인 수학적 접두사 표기법으로 작성되며 UTF-8 문자 세트에 맞게 조정됩니다. 컨텍스트에 따라 표현식은 다음을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5616c8c2195c2678f23a833731af4cad68a2a4bd" translate="yes" xml:space="preserve">
          <source>Extra parameters required for the mapreduce/tez job (enclosed in back tics).</source>
          <target state="translated">mapreduce / tez 작업에 필요한 추가 매개 변수 (백틱으로 묶임).</target>
        </trans-unit>
        <trans-unit id="6bc777926b5ba3dcf78bfee3835dae2308ed3f05" translate="yes" xml:space="preserve">
          <source>ExtractHour</source>
          <target state="translated">ExtractHour</target>
        </trans-unit>
        <trans-unit id="84d771d63be156bd53ecc910bcb8c18212afa821" translate="yes" xml:space="preserve">
          <source>Extracts the hour from the record.</source>
          <target state="translated">레코드에서 시간을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="edc5934c34a6fd02ae10fbbb8d31675eb97581a4" translate="yes" xml:space="preserve">
          <source>FILTER</source>
          <target state="translated">FILTER</target>
        </trans-unit>
        <trans-unit id="c499647bae6c677b9a3c4bb597fd5546660e92b0" translate="yes" xml:space="preserve">
          <source>FILTER is commonly used to select the data that you want; or, conversely, to filter out (remove) the data you don&amp;rsquo;t want.</source>
          <target state="translated">FILTER는 일반적으로 원하는 데이터를 선택하는 데 사용됩니다. 또는 반대로 원하지 않는 데이터를 필터링 (제거)합니다.</target>
        </trans-unit>
        <trans-unit id="0b095f48705c5f6e20064ac184328d4387402c64" translate="yes" xml:space="preserve">
          <source>FILTER operator &amp;ndash; If a filter expression results in null value, the filter does not pass them through (if X is null, !X is also null, and the filter will reject both).</source>
          <target state="translated">FILTER 연산자 &amp;ndash; 필터 표현식의 결과로 널값이 발생하면 필터가이를 통과하지 않습니다 (X가 널이면! X도 널이며 필터는 둘 다 거부 함).</target>
        </trans-unit>
        <trans-unit id="e4a528cf2255ca946eb38878b29504cf8ac21255" translate="yes" xml:space="preserve">
          <source>FLOOR</source>
          <target state="translated">FLOOR</target>
        </trans-unit>
        <trans-unit id="aebf8cadfda1bc0f7b1b3f50b1a7baa8878aa1fb" translate="yes" xml:space="preserve">
          <source>FLOOR(expression)</source>
          <target state="translated">FLOOR(expression)</target>
        </trans-unit>
        <trans-unit id="0e885ae6bed342524b3fee50a05c92acd3a0dd1b" translate="yes" xml:space="preserve">
          <source>FLOOR(x)</source>
          <target state="translated">FLOOR(x)</target>
        </trans-unit>
        <trans-unit id="124a9e3bb4d391c6224a470002a2e3cd4f74357f" translate="yes" xml:space="preserve">
          <source>FOREACH</source>
          <target state="translated">FOREACH</target>
        </trans-unit>
        <trans-unit id="30e4f3291f513bda1a3ad50d5289add3052b4089" translate="yes" xml:space="preserve">
          <source>FOREACH&amp;hellip;GENERATE block used with a relation (outer bag). Use this syntax:</source>
          <target state="translated">FOREACH&amp;hellip; GENERATE 블록은 관계 (외부 백)와 함께 사용됩니다. 이 구문을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="72edf56876746682dba2c95ad67320178cbe6181" translate="yes" xml:space="preserve">
          <source>FOREACH...GENERATE works with relations (outer bags) as well as inner bags:</source>
          <target state="translated">FOREACH ... GENERATE는 내부 가방뿐만 아니라 관계 (외부 가방)와 함께 작동합니다.</target>
        </trans-unit>
        <trans-unit id="cc0a745dcfb4d3d66417f75affb8f4b428e7e18f" translate="yes" xml:space="preserve">
          <source>FULL</source>
          <target state="translated">FULL</target>
        </trans-unit>
        <trans-unit id="25a97648b467d15a300e307b49c00111052f51f8" translate="yes" xml:space="preserve">
          <source>Fetching will be disabled in case of:</source>
          <target state="translated">다음과 같은 경우 가져 오기가 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="d807d95c65337dde23a31f2c1524f3765ecaba40" translate="yes" xml:space="preserve">
          <source>Field Delimiters &amp;ndash; For load and store statements the default field delimiter is the tab character ('\t'). You can use other characters as field delimiters, but separators such as ^A or Ctrl-A should be represented in Unicode (\u0001) using UTF-16 encoding (see Wikipedia &lt;a href=&quot;http://en.wikipedia.org/wiki/ASCII&quot;&gt;ASCII&lt;/a&gt;, &lt;a href=&quot;http://en.wikipedia.org/wiki/Unicode&quot;&gt;Unicode&lt;/a&gt;, and &lt;a href=&quot;http://en.wikipedia.org/wiki/UTF-16&quot;&gt;UTF-16&lt;/a&gt;).</source>
          <target state="translated">필드 구분 기호 &amp;ndash;로드 및 저장 명령문의 경우 기본 필드 구분 기호는 탭 문자 ( '\ t')입니다. 다른 문자를 필드 구분 기호로 사용할 수 있지만 ^ A 또는 Ctrl-A와 같은 구분 기호는 UTF-16 인코딩을 사용하여 유니 코드 (\ u0001)로 표시되어야합니다 (Wikipedia &lt;a href=&quot;http://en.wikipedia.org/wiki/ASCII&quot;&gt;ASCII&lt;/a&gt; , &lt;a href=&quot;http://en.wikipedia.org/wiki/Unicode&quot;&gt;Unicode&lt;/a&gt; 및 &lt;a href=&quot;http://en.wikipedia.org/wiki/UTF-16&quot;&gt;UTF-16 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="4fae8568081ffa8569d8bf8ee4c82d0a67f158e1" translate="yes" xml:space="preserve">
          <source>Field Delimiters &amp;ndash; For load and store statements the default field delimiter is the tab character ('\t'). You can use other characters as field delimiters, but separators such as ^A or Ctrl-A should be represented in Unicode (\u0001) using UTF-16 encoding (see Wikipedia &lt;a href=&quot;https://en.wikipedia.org/wiki/ASCII&quot;&gt;ASCII&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Unicode&quot;&gt;Unicode&lt;/a&gt;, and &lt;a href=&quot;https://en.wikipedia.org/wiki/UTF-16&quot;&gt;UTF-16&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="374a1e5dfd50fed6437e37f52b3bae37ab7b6490" translate="yes" xml:space="preserve">
          <source>Field Expressions</source>
          <target state="translated">필드 표현식</target>
        </trans-unit>
        <trans-unit id="ae5d0e582f486d86311de55d8644b345c8408038" translate="yes" xml:space="preserve">
          <source>Field expressions represent a field or a &lt;a href=&quot;#deref&quot;&gt;dereference operator&lt;/a&gt; applied to a field.</source>
          <target state="translated">필드 표현식은 필드 또는 필드에 적용된 &lt;a href=&quot;#deref&quot;&gt;역 참조 연산자를&lt;/a&gt; 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="c0428878bc1bcd810085d4c965f1a3a7f4343d4d" translate="yes" xml:space="preserve">
          <source>Field value (for the first tuple)</source>
          <target state="translated">필드 값 (첫 번째 튜플의 경우)</target>
        </trans-unit>
        <trans-unit id="e20249433ec90ba379bbe66cfb9fd25db96d6981" translate="yes" xml:space="preserve">
          <source>Fields are referred to by positional notation or by name (alias).</source>
          <target state="translated">필드는 위치 표기법 또는 이름 (별칭)으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f774215e137925e9255faaa3183859520af80b72" translate="yes" xml:space="preserve">
          <source>File containing the serialized Bloom filter.</source>
          <target state="translated">직렬화 된 Bloom 필터를 포함하는 파일입니다.</target>
        </trans-unit>
        <trans-unit id="93aa561d8701c13f16d05bd4e43e7315d3e7c664" translate="yes" xml:space="preserve">
          <source>Files are imported based on either (1) the given file path or (2) the import path specified via the Pig property pig.import.search.path. If a file path is given, whether absolute or relative to the current directory (starting with . or ..), the import path will be ignored.</source>
          <target state="translated">파일은 (1) 지정된 파일 경로 또는 (2) Pig 속성 pig.import.search.path를 통해 지정된 가져 오기 경로를 기반으로 가져옵니다. . 또는 ..로 시작하는 현재 디렉토리에 대해 절대적이든 상대적이든 파일 경로가 제공되면 가져 오기 경로는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="4fdb33c78eb94348ce6978c25d2f7a8f9152dcf9" translate="yes" xml:space="preserve">
          <source>Filter Early and Often</source>
          <target state="translated">조기 및 종종 필터링</target>
        </trans-unit>
        <trans-unit id="e720612049130d6284d05140463bcdc10c1e72a4" translate="yes" xml:space="preserve">
          <source>Filter Functions</source>
          <target state="translated">필터 기능</target>
        </trans-unit>
        <trans-unit id="8f1406b0246513c436f07bab6331594509d8ed43" translate="yes" xml:space="preserve">
          <source>Filter condition will be pushed to loader if loader supports</source>
          <target state="translated">로더가 지원하는 경우 필터 조건이 로더로 푸시됩니다.</target>
        </trans-unit>
        <trans-unit id="7f633d97a0a71ddf2a15cc5f74cd46a0c2698332" translate="yes" xml:space="preserve">
          <source>Filter condition will be pushed to loader if loader supports (Usually the loader is partition aware, such as HCatLoader)</source>
          <target state="translated">로더가 지원하는 경우 필터 조건이 로더로 푸시됩니다 (일반적으로 로더는 HCatLoader와 같이 파티션을 인식합니다)</target>
        </trans-unit>
        <trans-unit id="e1a1687f221901fbe8d4d0e7c5995a0972f7583e" translate="yes" xml:space="preserve">
          <source>Filter functions are eval functions that return a boolean value. Filter functions can be used anywhere a Boolean expression is appropriate, including the FILTER operator or bincond expression.</source>
          <target state="translated">필터 함수는 부울 값을 반환하는 평가 함수입니다. 필터 함수는 FILTER 연산자 또는 bincond 표현식을 포함하여 부울 표현식이 적절한 곳에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f7c11ab7613ce99c03c40c65a2aaf2ded8f2f9b" translate="yes" xml:space="preserve">
          <source>FilterLogicExpressionSimplifier is an exception to the above. The rule is disabled by default, and enabled by setting the pig.exec.filterLogicExpressionSimplifier pig property to true.</source>
          <target state="translated">FilterLogicExpressionSimplifier는 위의 예외입니다. 규칙은 기본적으로 비활성화되어 있으며 pig.exec.filterLogicExpressionSimplifier pig 속성을 true로 설정하면 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="cb5f0c73d84fb9247ba7cb76103e4c1e309fbcaa" translate="yes" xml:space="preserve">
          <source>Finally, use Pig's &lt;a href=&quot;cmds&quot;&gt;Shell and Utility Commands&lt;/a&gt; to run your programs and Pig's expanded &lt;a href=&quot;test&quot;&gt;Testing and Diagnostics&lt;/a&gt; tools to examine and/or debug your programs.</source>
          <target state="translated">마지막으로 Pig 's &lt;a href=&quot;cmds&quot;&gt;Shell 및 Utility Commands&lt;/a&gt; 를 사용하여 프로그램을 실행하고 Pig의 확장 된 &lt;a href=&quot;test&quot;&gt;테스트 및 진단&lt;/a&gt; 도구를 사용하여 프로그램을 검사 및 / 또는 디버깅하십시오.</target>
        </trans-unit>
        <trans-unit id="f3da40b3f71164397fe3120b6c24e8b03a2e827f" translate="yes" xml:space="preserve">
          <source>Finally, use of the combiner is influenced by the surrounding environment of the GROUP and FOREACH statements.</source>
          <target state="translated">마지막으로 결합기의 사용은 GROUP 및 FOREACH 문의 주변 환경에 영향을받습니다.</target>
        </trans-unit>
        <trans-unit id="a182325e7336b6a52b850d6513b5f50d62b61fe5" translate="yes" xml:space="preserve">
          <source>Finally, you might want to run the same pipeline in parallel with a different set of parameters, for instance for multiple dates. In this case, bind function, needs to be passed a list of maps with each element of the list containing parameters for a single invocation. In the example below, the pipeline is run for the US, the UK, and Brazil.</source>
          <target state="translated">마지막으로 예를 들어 여러 날짜와 같은 다른 매개 변수 세트와 함께 동일한 파이프 라인을 실행하려고 할 수 있습니다. 이 경우 바인드 함수에는 단일 호출에 대한 매개 변수를 포함하는 목록의 각 요소가있는 맵 목록이 전달되어야합니다. 아래 예에서 파이프 라인은 미국, 영국 및 브라질에 대해 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="a25e71892063d65a033f3c33dcca775bbfdb92f4" translate="yes" xml:space="preserve">
          <source>First Field</source>
          <target state="translated">첫 필드</target>
        </trans-unit>
        <trans-unit id="560d697bd54184feb3c2cb3d326bd367f1a41b37" translate="yes" xml:space="preserve">
          <source>First, Pig logs all successful and failed store commands. Store commands are identified by output path. At the end of execution a summary line indicates success, partial failure or failure of all store commands.</source>
          <target state="translated">먼저, Pig는 성공 및 실패한 모든 저장 명령을 기록합니다. 저장 명령은 출력 경로로 식별됩니다. 실행이 끝나면 요약 행에 모든 상점 명령의 성공, 부분 실패 또는 실패가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="20a2a4ea19330a7bcdfeda7fda48635712f05747" translate="yes" xml:space="preserve">
          <source>Fixes</source>
          <target state="translated">Fixes</target>
        </trans-unit>
        <trans-unit id="1bee076d0b032b0f981cab5ee327b40018d08a48" translate="yes" xml:space="preserve">
          <source>Flag. Use this option when the parameter is included in a file.</source>
          <target state="translated">깃발. 매개 변수가 파일에 포함 된 경우이 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b65c220252ee8c3948884ddb5a0fb687bd1853aa" translate="yes" xml:space="preserve">
          <source>Flag. Use this option when the parameter is included in the command line.</source>
          <target state="translated">깃발. 매개 변수가 명령 행에 포함 된 경우이 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="bf4fb89dc7a529ffed7973390c4e2155eaf060d2" translate="yes" xml:space="preserve">
          <source>Flag. With this option, the script is not run and a fully substituted Pig script is produced in the current working directory named original_script_name.substituted</source>
          <target state="translated">깃발. 이 옵션을 사용하면 스크립트가 실행되지 않고 original_script_name.substituted라는 현재 작업 디렉토리에 완전히 대체 된 Pig 스크립트가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="d1ad90d7d1074df811fb1d08292716f5b962eb4a" translate="yes" xml:space="preserve">
          <source>Flag. With this option, the script is run and a fully substituted Pig script is produced in the current working directory named original_script_name.substituted</source>
          <target state="translated">깃발. 이 옵션을 사용하면 스크립트가 실행되고 original_script_name.substituted라는 현재 작업 디렉토리에 완전히 대체 된 Pig 스크립트가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="6cca07ce0ccc662626ad643025241c3624e56e0a" translate="yes" xml:space="preserve">
          <source>Flatten Operator</source>
          <target state="translated">연산자를 평평하게</target>
        </trans-unit>
        <trans-unit id="64435fd82de7b1d614dfb9844848a48b14c6cd2c" translate="yes" xml:space="preserve">
          <source>Float</source>
          <target state="translated">Float</target>
        </trans-unit>
        <trans-unit id="45662d4964281ef83d8669c1e17a8c98baf3c297" translate="yes" xml:space="preserve">
          <source>Float: float</source>
          <target state="translated">플로트 : 플로트</target>
        </trans-unit>
        <trans-unit id="c9fdb9f56bbed11dccf6a43b0581d80890cf2517" translate="yes" xml:space="preserve">
          <source>Floats</source>
          <target state="translated">Floats</target>
        </trans-unit>
        <trans-unit id="f77b87119e6a7c491f744846107d414afef865cd" translate="yes" xml:space="preserve">
          <source>For Boolean subexpressions, note the results when nulls are used with these operators:</source>
          <target state="translated">부울 하위 표현식의 경우 다음 연산자와 함께 null을 사용하면 결과에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="2be41e1d991863bbc437c7de08ee19b60419ab6a" translate="yes" xml:space="preserve">
          <source>For Example 2, adds an implicit split to transform the query to Example 1. This eliminates the processing of A' multiple times.</source>
          <target state="translated">예 2의 경우 쿼리를 예 1로 변환하기 위해 암시 적 분할을 추가합니다. 이렇게하면 A '가 여러 번 처리되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="835dfa89a788bfff1ac53650a84f02ab699062dc" translate="yes" xml:space="preserve">
          <source>For GROUP/COGROUP, the project-to-end form of project-range is not allowed.</source>
          <target state="translated">GROUP / COGROUP의 경우 프로젝트-종료 형식의 프로젝트 범위는 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="676025c95c5e8f034607e031bb2f47fe1513d2c9" translate="yes" xml:space="preserve">
          <source>For GROUP/COGROUP, you can't include a star expression in a GROUP BY column.</source>
          <target state="translated">GROUP / COGROUP의 경우 GROUP BY 열에 별표를 포함 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="aa631d796822d8569da8d125a68d480ce975ef15" translate="yes" xml:space="preserve">
          <source>For ORDER BY, if you have project-star as ORDER BY column, you can&amp;rsquo;t have any other ORDER BY column in that statement.</source>
          <target state="translated">ORDER BY의 경우 프로젝트 별이 ORDER BY 열인 경우 해당 명령문에 다른 ORDER BY 열을 가질 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d2834709d8b275ce9b152eb158483358816d9c0a" translate="yes" xml:space="preserve">
          <source>For ORDER BY, the project-to-end form of project-range is supported only as the last sort column.</source>
          <target state="translated">ORDER BY의 경우 프로젝트-종료 형식의 프로젝트 범위는 마지막 정렬 열로만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="8f1475f652154b21d775e5801ec1c3d92d95a9c8" translate="yes" xml:space="preserve">
          <source>For a detailed discussion of nulls see &lt;a href=&quot;#nulls&quot;&gt;Nulls and Pig Latin&lt;/a&gt;.</source>
          <target state="translated">null에 대한 자세한 내용은 &lt;a href=&quot;#nulls&quot;&gt;Nulls 및 Pig Latin을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a6199a767a8156e35cf7d0323c162d32263a9e97" translate="yes" xml:space="preserve">
          <source>For a function to be algebraic, it needs to implement Algebraic interface that consist of definition of three classes derived from EvalFunc. The contract is that the exec function of the Initial class is called once and is passed the original input tuple. Its output is a tuple that contains partial results. The exec function of the Intermed class can be called zero or more times and takes as its input a tuple that contains partial results produced by the Initial class or by prior invocations of the Intermed class and produces a tuple with another partial result. Finally, the exec function of the Final class is called and produces the final result as a scalar type.</source>
          <target state="translated">함수가 대수적이기 위해서는 EvalFunc에서 파생 된 3 가지 클래스의 정의로 구성된 대수 인터페이스를 구현해야합니다. 계약은 Initial 클래스의 exec 함수가 한 번 호출되고 원래 입력 튜플이 전달된다는 것입니다. 출력은 부분 결과를 포함하는 튜플입니다. Intermed 클래스의 exec 함수는 0 번 이상 호출 될 수 있으며 초기 클래스 또는 Intermed 클래스의 사전 호출에 의해 생성 된 부분 결과를 포함하는 튜플을 입력으로 사용하고 다른 부분 결과를 가진 튜플을 생성합니다. 마지막으로 Final 클래스의 exec 함수가 호출되어 최종 결과를 스칼라 형식으로 생성합니다.</target>
        </trans-unit>
        <trans-unit id="7492ab87722922ae84f0b30cbe8f9673835c3f10" translate="yes" xml:space="preserve">
          <source>For a sample input tuple (car, 2012, midwest, ohio, columbus, 4000), the above query with cube and rollup operation will output</source>
          <target state="translated">샘플 입력 튜플 (car, 2012, midwest, ohio, columbus, 4000)의 경우 큐브 및 롤업 작업이있는 위의 쿼리가 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="28f76a725822abdab65b5650c2916c0517db3dec" translate="yes" xml:space="preserve">
          <source>For a sample input tuple (car, 2012, midwest, ohio, columbus, 4000), the above query with cube operation will output</source>
          <target state="translated">샘플 입력 튜플 (car, 2012, midwest, ohio, columbus, 4000)의 경우 위의 큐브 작업 쿼리가 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="ea529d2335219745cfd2023bd9ab59cbffd6b14a" translate="yes" xml:space="preserve">
          <source>For a sample input tuple (car, 2012, midwest, ohio, columbus, 4000), the above query with rollup operation will output</source>
          <target state="translated">샘플 입력 튜플 (car, 2012, midwest, ohio, columbus, 4000)의 경우 롤업 작업이있는 위의 쿼리가 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="0cbdfa0cb7a62b6a7cfadb5ef5ff81cbd2f4a3dc" translate="yes" xml:space="preserve">
          <source>For an example see &lt;a href=&quot;http://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/builtin/CONCAT.java?view=markup&quot;&gt;CONCAT&lt;/a&gt;.</source>
          <target state="translated">예를 들어 &lt;a href=&quot;http://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/builtin/CONCAT.java?view=markup&quot;&gt;CONCAT&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7489f98899cc95cdbf7d21e8d834a2eeb0dba5a7" translate="yes" xml:space="preserve">
          <source>For an example see &lt;a href=&quot;https://svn.apache.org/viewvc/pig/trunk/src/org/apache/pig/builtin/CONCAT.java?view=markup&quot;&gt;CONCAT&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cd221174816b0dafbc774cf220e7c75e294e4c8" translate="yes" xml:space="preserve">
          <source>For bags, every element is put in the bag; if the element is not a tuple Pig will create a tuple for it:</source>
          <target state="translated">가방의 경우 모든 요소를 ​​가방에 넣습니다. 요소가 튜플이 아닌 경우 Pig는 튜플을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="2372fb8c6515d6b56d293e2841be669278e86343" translate="yes" xml:space="preserve">
          <source>For bags, the situation becomes more complicated. When we un-nest a bag, we create new tuples. If we have a relation that is made up of tuples of the form ({(b,c),(d,e)}) and we apply GENERATE flatten($0), we end up with two tuples (b,c) and (d,e). When we remove a level of nesting in a bag, sometimes we cause a cross product to happen. For example, consider a relation that has a tuple of the form (a, {(b,c), (d,e)}), commonly produced by the GROUP operator. If we apply the expression GENERATE $0, flatten($1) to this tuple, we will create new tuples: (a, b, c) and (a, d, e).</source>
          <target state="translated">가방의 경우 상황이 더 복잡해집니다. 우리는 가방을 꺼낼 때 새로운 튜플을 만듭니다. ({(b, c), (d, e)}) 형식의 튜플로 구성된 관계가 있고 GENERATE flatten ($ 0)을 적용하면 두 개의 튜플 (b, c)과 (d, e). 가방에서 중첩 수준을 제거 할 때 때때로 교차 제품이 발생합니다. 예를 들어, GROUP 연산자에 의해 일반적으로 생성되는 양식 (a, {(b, c), (d, e)})의 튜플이있는 관계를 고려하십시오. GENERATE $ 0, flatten ($ 1) 표현식을이 튜플에 적용하면 (a, b, c) 및 (a, d, e)와 같은 새 튜플을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="91312518d63ae9ef625aa1b55bf27f4e9da987e8" translate="yes" xml:space="preserve">
          <source>For batch mode execution, the entire script is first parsed to determine if intermediate tasks can be combined to reduce the overall amount of work that needs to be done; execution starts only after the parsing is completed (see the &lt;a href=&quot;test#explain&quot;&gt;EXPLAIN&lt;/a&gt; operator and the &lt;a href=&quot;cmds#run&quot;&gt;run&lt;/a&gt; and &lt;a href=&quot;cmds#exec&quot;&gt;exec&lt;/a&gt; commands).</source>
          <target state="translated">일괄 처리 모드 실행의 경우, 전체 스크립트를 먼저 구문 분석하여 수행해야하는 전체 작업량을 줄이기 위해 중간 태스크를 결합 할 수 있는지 판별합니다. 구문 분석이 완료된 후에 만 ​​실행이 시작됩니다 ( &lt;a href=&quot;test#explain&quot;&gt;EXPLAIN&lt;/a&gt; 연산자 및 &lt;a href=&quot;cmds#run&quot;&gt;run&lt;/a&gt; 및 &lt;a href=&quot;cmds#exec&quot;&gt;exec&lt;/a&gt; 명령 참조).</target>
        </trans-unit>
        <trans-unit id="b8e8565c02cd6d0adf7e03bd5126b7a679abf46b" translate="yes" xml:space="preserve">
          <source>For cache archive to work, your test environment needs to have the cache archive options specified by Java properties or in an additional XML configuration in its CLASSPATH.</source>
          <target state="translated">캐시 아카이브가 작동하려면 테스트 환경에 Java 특성 또는 CLASSPATH의 추가 XML 구성에 지정된 캐시 아카이브 옵션이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="18da20d994e9bde64442c462b27be66a24a6c8f8" translate="yes" xml:space="preserve">
          <source>For clarity of your script, you might choose to split your projects into several steps for instance:</source>
          <target state="translated">스크립트를 명확하게하기 위해 프로젝트를 여러 단계로 나눌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1800d452d4c715d00865e8d76e04934a0d18725" translate="yes" xml:space="preserve">
          <source>For comparison, see the &lt;a href=&quot;#exec&quot;&gt;exec&lt;/a&gt; command. Both the run and exec commands are useful for debugging because you can modify a Pig script in an editor and then rerun the script in the Grunt shell without leaving the shell. Also, both commands promote Pig script modularity as they allow you to reuse existing components.</source>
          <target state="translated">비교는 &lt;a href=&quot;#exec&quot;&gt;exec&lt;/a&gt; 명령을 참조하십시오 . run 및 exec 명령은 편집기에서 Pig 스크립트를 수정 한 다음 쉘을 떠나지 않고 Grunt 쉘에서 스크립트를 다시 실행할 수 있기 때문에 디버깅에 유용합니다. 또한 두 명령 모두 기존 구성 요소를 재사용 할 수 있으므로 Pig 스크립트 모듈성을 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="420cb33169b061b107fef980597874b521b5d581" translate="yes" xml:space="preserve">
          <source>For comparison, see the &lt;a href=&quot;#run&quot;&gt;run&lt;/a&gt; command. Both the exec and run commands are useful for debugging because you can modify a Pig script in an editor and then rerun the script in the Grunt shell without leaving the shell. Also, both commands promote Pig script modularity as they allow you to reuse existing components.</source>
          <target state="translated">비교는 &lt;a href=&quot;#run&quot;&gt;run&lt;/a&gt; 명령을 참조하십시오 . exec 및 run 명령은 편집기에서 Pig 스크립트를 수정 한 다음 쉘을 떠나지 않고 Grunt 쉘에서 스크립트를 다시 실행할 수 있기 때문에 디버깅에 유용합니다. 또한 두 명령 모두 기존 구성 요소를 재사용 할 수 있으므로 Pig 스크립트 모듈성을 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="9a70c16c98ef223c0647c824bfeed22855751dc5" translate="yes" xml:space="preserve">
          <source>For each group, identify the hour in which this n-gram is used with a particularly high frequency. Call the ScoreGenerator UDF to calculate a &quot;popularity&quot; score for the n-gram.</source>
          <target state="translated">각 그룹에 대해이 n-gram이 특히 높은 빈도로 사용되는 시간을 식별하십시오. n- 그램에 대한 &quot;인기&quot;점수를 계산하려면 ScoreGenerator UDF를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="5fa035064ec1e452c1fe723f98a13eacd5ac6d30" translate="yes" xml:space="preserve">
          <source>For example, ENDSWITH ('foobar', 'foo') will false, whereas ENDSWITH ('foobar', 'bar') will return true.</source>
          <target state="translated">예를 들어 ENDSWITH ( 'foobar', 'foo')는 false 인 반면 ENDSWITH ( 'foobar', 'bar')는 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="190542a62b49ce761df23241df59522132799b50" translate="yes" xml:space="preserve">
          <source>For example, STARTSWITH ('foobar', 'foo') will true, whereas STARTSWITH ('foobar', 'bar') will return false.</source>
          <target state="translated">예를 들어 STARTSWITH ( 'foobar', 'foo')는 true 인 반면 STARTSWITH ( 'foobar', 'bar')는 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="53818d83a11438a77f0a5d06b5b0ac5f08dfc953" translate="yes" xml:space="preserve">
          <source>For example, given the string (open:source:software), STRSPLIT (string, ':',2) will return ((open,source:software)) and STRSPLIT (string, ':',3) will return ((open,source,software)).</source>
          <target state="translated">예를 들어 문자열 (open : source : software)이 주어진 경우 STRSPLIT (string, ':', 2)는 ((open, source : software))를 반환하고 STRSPLIT (string, ':', 3)은 (( 오픈 소스 소프트웨어)).</target>
        </trans-unit>
        <trans-unit id="94e60e5b8b6a53f99613a8546bf1c2006321f801" translate="yes" xml:space="preserve">
          <source>For example, given the string (open:source:software), STRSPLITTOBAG (string, ':',2) will return {(open),(source:software)} and STRSPLITTOBAG (string, ':',3) will return {(open),(source),(software)}.</source>
          <target state="translated">예를 들어 문자열 (open : source : software)을 지정하면 STRSPLITTOBAG (string, ':', 2)는 {(open), (source : software)}를 반환하고 STRSPLITTOBAG (string, ':', 3)는 {(오픈 소스 소프트웨어)}.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
