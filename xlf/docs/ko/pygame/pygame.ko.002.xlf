<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="pygame">
    <body>
      <group id="pygame">
        <trans-unit id="1391ad48d197026110ac01ea3efe7be3ed4732d5" translate="yes" xml:space="preserve">
          <source>Returns True if the drive is currently paused.</source>
          <target state="translated">드라이브가 현재 일시 중지 된 경우 True를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="87d895dcffc685c27125c126348ef5c510316ad2" translate="yes" xml:space="preserve">
          <source>Returns True if the joystick module is initialized.</source>
          <target state="translated">조이스틱 모듈이 초기화 된 경우 True를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="eab831fc7ce3195af4e23bcead6d53f3648fecce" translate="yes" xml:space="preserve">
          <source>Returns True if the scrap module is currently initialized.</source>
          <target state="translated">스크랩 모듈이 현재 초기화 된 경우 True를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e163a962653501d49211b5f07bd9cf5e11f1c850" translate="yes" xml:space="preserve">
          <source>Returns True if the vector has length == 1. Otherwise it returns False.</source>
          <target state="translated">벡터의 길이가 = 1이면 True를, 그렇지 않으면 False를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a5216c74a740035e372b5e11a705c5bce52ac33b" translate="yes" xml:space="preserve">
          <source>Returns True when the Sprite belongs to one or more Groups.</source>
          <target state="translated">Sprite가 하나 이상의 그룹에 속하는 경우 True를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2ac602b3f5a2718822a437c51507ec6437482916" translate="yes" xml:space="preserve">
          <source>Returns True when the display is active on the display</source>
          <target state="translated">디스플레이가 디스플레이에서 활성화되면 True를 반환합니다</target>
        </trans-unit>
        <trans-unit id="06d1dc47fa4d7c06392b15b03839e387c7964a9f" translate="yes" xml:space="preserve">
          <source>Returns True when the music stream is actively playing. When the music is idle this returns False.</source>
          <target state="translated">음악 스트림이 현재 재생 중이면 True를 반환합니다. 음악이 유휴 상태이면 False를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4c4fd3616c12cfe65001a9261ee7dad27f4c5a24" translate="yes" xml:space="preserve">
          <source>Returns a &lt;a href=&quot;#pygame.mask.Mask&quot;&gt;&lt;code&gt;Mask&lt;/code&gt;&lt;/a&gt;, the same size as this mask, containing the overlapping set bits between this mask and &lt;code&gt;othermask&lt;/code&gt;.</source>
          <target state="translated">이 마스크와 &lt;code&gt;othermask&lt;/code&gt; 마스크 사이의 겹치는 세트 비트를 포함하는,이 마스크와 같은 크기 의 &lt;a href=&quot;#pygame.mask.Mask&quot;&gt; &lt;code&gt;Mask&lt;/code&gt; &lt;/a&gt; 를 돌려 줍니다 .</target>
        </trans-unit>
        <trans-unit id="4717669a2eaaf5a5b7e6008c85cb5bd967f66297" translate="yes" xml:space="preserve">
          <source>Returns a &lt;a href=&quot;rect#pygame.Rect&quot;&gt;&lt;code&gt;Rect&lt;/code&gt;&lt;/a&gt; instance containing the width and height of the text's bounding box and the position of the text's origin. The origin is useful in aligning separately rendered pieces of text. It gives the baseline position and bearing at the start of the text. See the &lt;a href=&quot;#pygame.freetype.Font.render_to&quot;&gt;&lt;code&gt;render_to()&lt;/code&gt;&lt;/a&gt; method for an example.</source>
          <target state="translated">텍스트 경계 상자의 너비와 높이 및 텍스트 원점의 위치를 ​​포함 하는 &lt;a href=&quot;rect#pygame.Rect&quot;&gt; &lt;code&gt;Rect&lt;/code&gt; &lt;/a&gt; 인스턴스를 반환합니다 . 원점은 별도로 렌더링 된 텍스트 조각을 정렬하는 데 유용합니다. 텍스트의 시작 부분에 기준 위치와 방위를 제공합니다. 예제 는 &lt;a href=&quot;#pygame.freetype.Font.render_to&quot;&gt; &lt;code&gt;render_to()&lt;/code&gt; &lt;/a&gt; 메소드를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9dc42caa4b4b87049e198f52fcfa585f68c4471e" translate="yes" xml:space="preserve">
          <source>Returns a Color which is a linear interpolation between self and the given Color in RGBA space. The second parameter determines how far between self and other the result is going to be. It must be a value between 0 and 1 where 0 means self and 1 means other will be returned.</source>
          <target state="translated">RGBA 공간에서 자신과 지정된 색 사이의 선형 보간 인 Color를 반환합니다. 두 번째 매개 변수는 결과와 자아 사이의 거리를 결정합니다. 0과 1 사이의 값이어야합니다. 여기서 0은 자체를 의미하고 1은 다른 것이 반환됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="91f99e481788e311050f8e39bea5b79b28df9e16" translate="yes" xml:space="preserve">
          <source>Returns a Rect based on the size of the mask</source>
          <target state="translated">마스크의 크기를 기준으로 Rect를 반환</target>
        </trans-unit>
        <trans-unit id="1e0ea56de75649f16e965154a619026e04565ba8" translate="yes" xml:space="preserve">
          <source>Returns a True value when the Overlay is hardware accelerated. If the platform does not support acceleration, software rendering is used.</source>
          <target state="translated">오버레이가 하드웨어 가속 될 때 True 값을 반환합니다. 플랫폼이 가속을 지원하지 않으면 소프트웨어 렌더링이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bcee523242c227761d522310f04e39bda918f226" translate="yes" xml:space="preserve">
          <source>Returns a Vector which is a linear interpolation between self and the given Vector. The second parameter determines how far between self an other the result is going to be. It must be a value between 0 and 1 where 0 means self an 1 means other will be returned.</source>
          <target state="translated">자체와 주어진 Vector 사이의 선형 보간 인 Vector를 반환합니다. 두 번째 매개 변수는 자기 자신과 결과가 얼마나 멀리 떨어져 있는지를 결정합니다. 0과 1 사이의 값이어야합니다. 여기서 0은 self 1은 다른 1은 반환됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="fc852d1b3ea7af035ddc695a461ed25100b479d4" translate="yes" xml:space="preserve">
          <source>Returns a Vector which is a linear interpolation between self and the given Vector. The second parameter determines how far between self and other the result is going to be. It must be a value between 0 and 1 where 0 means self and 1 means other will be returned.</source>
          <target state="translated">자체와 주어진 Vector 사이의 선형 보간 인 Vector를 반환합니다. 두 번째 매개 변수는 결과와 자아 사이의 거리를 결정합니다. 0과 1 사이의 값이어야합니다. 여기서 0은 자체를 의미하고 1은 다른 것이 반환됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="53b9186d34d7ae8b553b01757047fad5ca2131d6" translate="yes" xml:space="preserve">
          <source>Returns a list of all the fonts available on the system. The names of the fonts will be set to lowercase with all spaces and punctuation removed. This works on most systems, but some will return an empty list if they cannot find fonts.</source>
          <target state="translated">시스템에서 사용 가능한 모든 글꼴 목록을 반환합니다. 모든 공백과 문장 부호가 제거 된 상태에서 글꼴 이름이 소문자로 설정됩니다. 대부분의 시스템에서 작동하지만 글꼴을 찾을 수없는 경우 빈 목록을 반환하는 시스템도 있습니다.</target>
        </trans-unit>
        <trans-unit id="96f88dd82832b48461079d2b69ce092fef77f23e" translate="yes" xml:space="preserve">
          <source>Returns a list of all the indices that contain rectangles that collide with the Rect. If no intersecting rectangles are found, an empty list is returned.</source>
          <target state="translated">Rect와 충돌하는 사각형을 포함하는 모든 인덱스의 목록을 반환합니다. 교차하는 사각형이 없으면 빈 목록이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d5a54bde23be34f37a9a7cd60ad398681297f45f" translate="yes" xml:space="preserve">
          <source>Returns a list of all the key and value pairs that intersect with the calling Rect object. If no collisions are found an empty list is returned. If &lt;code&gt;use_values&lt;/code&gt; is 0 (default) then the dict's keys will be used in the collision detection, otherwise the dict's values will be used.</source>
          <target state="translated">호출 Rect 객체와 교차하는 모든 키 및 값 쌍의 목록을 반환합니다. 충돌이 없으면 빈 목록이 반환됩니다. 경우 &lt;code&gt;use_values&lt;/code&gt; 는 다음 DICT의 키가 충돌 감지에 사용됩니다 0 (기본값) 그렇지 않으면 DICT의 값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="30d4e18a7f9538e5296b524c4ec865bb4dd460cd" translate="yes" xml:space="preserve">
          <source>Returns a list of bounding rects of connected components</source>
          <target state="translated">연결된 컴포넌트의 경계 사각형 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fba727078a0bee9d0922b79bbd7ef71f9de5e0c1" translate="yes" xml:space="preserve">
          <source>Returns a list of masks of connected components</source>
          <target state="translated">연결된 컴포넌트의 마스크 목록을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="6b9bc8a17d4875d1997dd5800b202506fa4d0885" translate="yes" xml:space="preserve">
          <source>Returns a list of points of the outline of the first connected component encountered in the mask. To find a connected component, the mask is searched per row (left to right) starting in the top left corner.</source>
          <target state="translated">마스크에서 처음으로 연결된 구성 요소의 윤곽선 점 목록을 반환합니다. 연결된 컴포넌트를 찾으려면 왼쪽 상단에서 시작하여 행마다 (왼쪽에서 오른쪽으로) 마스크를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="d73e73227f12b3d01d4d9e9f0dd00dd3f5d92ed8" translate="yes" xml:space="preserve">
          <source>Returns a list of points outlining an object</source>
          <target state="translated">객체의 윤곽을 나타내는 점의 목록을 반환</target>
        </trans-unit>
        <trans-unit id="3bec6432e0be31425d7947ceea7b04e3e493b4f6" translate="yes" xml:space="preserve">
          <source>Returns a list of tuple records, one for each point size supported. Each tuple containing the point size, the height in pixels, width in pixels, horizontal ppem (nominal width) in fractional pixels, and vertical ppem (nominal height) in fractional pixels.</source>
          <target state="translated">지원되는 각 포인트 크기마다 하나씩 튜플 레코드 목록을 반환합니다. 포인트 크기, 픽셀 높이, 픽셀 너비, 분수 픽셀의 가로 ppem (공칭 너비) 및 분수 픽셀의 세로 ppem (공칭 높이)를 포함하는 각 튜플.</target>
        </trans-unit>
        <trans-unit id="d408af2a5e7c8a367023371cd79d8d48166a5666" translate="yes" xml:space="preserve">
          <source>Returns a mask containing a connected component</source>
          <target state="translated">연결된 컴포넌트를 포함하는 마스크를 반환</target>
        </trans-unit>
        <trans-unit id="927dce75ca08f02dee9ccc8b2ab685ee7fe756d7" translate="yes" xml:space="preserve">
          <source>Returns a mask of the overlapping set bits</source>
          <target state="translated">겹치는 세트 비트의 마스크를 돌려줍니다</target>
        </trans-unit>
        <trans-unit id="33126ac4c1c18e12f7e2ad341436537e827f2720" translate="yes" xml:space="preserve">
          <source>Returns a new &lt;a href=&quot;rect#pygame.Rect&quot;&gt;&lt;code&gt;pygame.Rect()&lt;/code&gt;&lt;/a&gt; object based on the size of this mask. The rect's default position will be &lt;code&gt;(0, 0)&lt;/code&gt; and its default width and height will be the same as this mask's. The rect's attributes can be altered via &lt;a href=&quot;rect#pygame.Rect&quot;&gt;&lt;code&gt;pygame.Rect()&lt;/code&gt;&lt;/a&gt; attribute keyword arguments/values passed into this method. As an example, &lt;code&gt;a_mask.get_rect(center=(10, 5))&lt;/code&gt; would create a &lt;a href=&quot;rect#pygame.Rect&quot;&gt;&lt;code&gt;pygame.Rect()&lt;/code&gt;&lt;/a&gt; based on the mask's size centered at the given position.</source>
          <target state="translated">이 마스크의 크기에 따라 새로운 &lt;a href=&quot;rect#pygame.Rect&quot;&gt; &lt;code&gt;pygame.Rect()&lt;/code&gt; &lt;/a&gt; 객체를 반환합니다 . rect의 기본 위치는 &lt;code&gt;(0, 0)&lt;/code&gt; 이며 기본 너비와 높이는이 마스크와 동일합니다. rect의 속성은 이 메소드에 전달 된 &lt;a href=&quot;rect#pygame.Rect&quot;&gt; &lt;code&gt;pygame.Rect()&lt;/code&gt; &lt;/a&gt; 속성 키워드 인수 / 값을 통해 변경 될 수 있습니다 . 예를 들어, &lt;code&gt;a_mask.get_rect(center=(10, 5))&lt;/code&gt; 는 주어진 위치를 중심으로 마스크의 크기를 기준으로 &lt;a href=&quot;rect#pygame.Rect&quot;&gt; &lt;code&gt;pygame.Rect()&lt;/code&gt; &lt;/a&gt; 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="5745f6944816d291edeacbb8470a7032818620f9" translate="yes" xml:space="preserve">
          <source>Returns a new &lt;a href=&quot;surface#pygame.Surface&quot;&gt;&lt;code&gt;Surface&lt;/code&gt;&lt;/a&gt;, with the text rendered to it in the color given by 'fgcolor'. If no foreground color is given, the default foreground color, &lt;a href=&quot;#pygame.freetype.Font.fgcolor&quot;&gt;&lt;code&gt;fgcolor&lt;/code&gt;&lt;/a&gt; is used. If &lt;code&gt;bgcolor&lt;/code&gt; is given, the surface will be filled with this color. When no background color is given, the surface background is transparent, zero alpha. Normally the returned surface has a 32 bit pixel size. However, if &lt;code&gt;bgcolor&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt; and anti-aliasing is disabled a monochrome 8 bit colorkey surface, with colorkey set for the background color, is returned.</source>
          <target state="translated">텍스트를 'fgcolor'로 지정된 색상으로 렌더링 하여 새 &lt;a href=&quot;surface#pygame.Surface&quot;&gt; &lt;code&gt;Surface&lt;/code&gt; 를&lt;/a&gt; 반환합니다 . 전경색을 지정하지 않으면 기본 전경색 인 &lt;a href=&quot;#pygame.freetype.Font.fgcolor&quot;&gt; &lt;code&gt;fgcolor&lt;/code&gt; &lt;/a&gt; 가 사용됩니다. 경우 &lt;code&gt;bgcolor&lt;/code&gt; 주어 표면이 색으로 채워집니다. 배경색을 지정하지 않으면 표면 배경이 투명하고 알파가 없습니다. 일반적으로 반환 된 표면의 크기는 32 비트입니다. 그러나 &lt;code&gt;bgcolor&lt;/code&gt; 가 &lt;code&gt;None&lt;/code&gt; 이고 앤티 앨리어싱이 비활성화 된 경우 배경색 에 대해 컬러 키가 설정된 단색 8 비트 컬러 키 표면이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="53c7d2c0d898fdcaafc910ef264146645fbc5911" translate="yes" xml:space="preserve">
          <source>Returns a new Surface that shares its pixels with its new parent. The new Surface is considered a child of the original. Modifications to either Surface pixels will effect each other. Surface information like clipping area and color keys are unique to each Surface.</source>
          <target state="translated">새 부모와 픽셀을 공유하는 새 Surface를 반환합니다. 새로운 Surface는 원본의 자식으로 간주됩니다. 표면 픽셀 중 하나를 수정하면 서로 영향을줍니다. 클리핑 영역 및 색상 키와 같은 표면 정보는 각 표면에 고유합니다.</target>
        </trans-unit>
        <trans-unit id="1ede8859e79b9a54a816f6d64413f8ce088b1c1b" translate="yes" xml:space="preserve">
          <source>Returns a new copy of the mask</source>
          <target state="translated">마스크의 새로운 사본을 반환</target>
        </trans-unit>
        <trans-unit id="efbbfbf88262cbb41c7ba54960bd656e17d622f2" translate="yes" xml:space="preserve">
          <source>Returns a new rectangle covering the entire surface. This rectangle will always start at (0, 0) with a width and height the same size as the image.</source>
          <target state="translated">전체 표면을 덮는 새 사각형을 반환합니다. 이 사각형은 항상 이미지와 같은 크기의 너비와 높이로 (0, 0)에서 시작합니다.</target>
        </trans-unit>
        <trans-unit id="abd625a3e63c85c4ab917087ad1d4421b89cc74a" translate="yes" xml:space="preserve">
          <source>Returns a new rectangle having the same position and size as the original.</source>
          <target state="translated">원본과 위치 및 크기가 같은 새 사각형을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c625a4889a07aa2e68bea0bedf32464049ff7009" translate="yes" xml:space="preserve">
          <source>Returns a new rectangle that completely covers the area of the two provided rectangles. There may be area inside the new Rect that is not covered by the originals.</source>
          <target state="translated">제공된 두 사각형의 영역을 완전히 덮는 새 사각형을 반환합니다. 새 사각형 안에는 원본이 포함되지 않은 영역이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="97616062256282196aae359fad10b42c9433b791" translate="yes" xml:space="preserve">
          <source>Returns a new rectangle that is cropped to be completely inside the argument Rect. If the two rectangles do not overlap to begin with, a Rect with 0 size is returned.</source>
          <target state="translated">인수 Rect 안에 완전히 오려 자른 새 사각형을 반환합니다. 두 사각형이 겹치지 않으면 0 크기의 사각형이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d38ba1868e383605230d8541db1351a130fbf047" translate="yes" xml:space="preserve">
          <source>Returns a new rectangle that is moved and resized to fit another. The aspect ratio of the original Rect is preserved, so the new rectangle may be smaller than the target in either width or height.</source>
          <target state="translated">다른 사각형에 맞게 이동 및 크기 조정 된 새 사각형을 반환합니다. 원본 Rect의 종횡비가 유지되므로 새 사각형이 폭 또는 높이에서 대상보다 작을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="655dee10629b28d442f1dc5b007cefac9003c3fd" translate="yes" xml:space="preserve">
          <source>Returns a new rectangle that is moved by the given offset. The x and y arguments can be any integer value, positive or negative.</source>
          <target state="translated">지정된 오프셋만큼 이동 한 새 사각형을 반환합니다. x 및 y 인수는 양수 또는 음수의 정수 값일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad68b7d74805485080074dd8c2a09ec8489c0c0a" translate="yes" xml:space="preserve">
          <source>Returns a new rectangle that is moved to be completely inside the argument Rect. If the rectangle is too large to fit inside, it is centered inside the argument Rect, but its size is not changed.</source>
          <target state="translated">인수 Rect 안에 완전히 들어가도록 이동 된 새 사각형을 반환합니다. 사각형이 너무 커서 내부에 맞지 않으면 Rect 인수 내부의 중심에 있지만 크기는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="71424d84ad2861d95c5232bc5235d1fb3349745c" translate="yes" xml:space="preserve">
          <source>Returns a new rectangle with the size changed by the given offset. The rectangle remains centered around its current center. Negative values will shrink the rectangle. Note, uses integers, if the offset given is too small(&amp;lt; 2 &amp;gt; -2), center will be off.</source>
          <target state="translated">주어진 오프셋에 의해 크기가 변경된 새 사각형을 반환합니다. 사각형은 현재 중심을 중심으로 유지됩니다. 음수 값은 사각형을 축소합니다. 주어진 오프셋이 너무 작 으면 (&amp;lt;2&amp;gt; -2) 정수를 사용합니다. 중심이 꺼집니다.</target>
        </trans-unit>
        <trans-unit id="8fc707f164d4ff4c27353264da59967743c4744b" translate="yes" xml:space="preserve">
          <source>Returns a new vector that has length == 1 and the same direction as self.</source>
          <target state="translated">길이가 = 1이고 자체와 방향이 같은 새 벡터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="332b184c7ec7c7d46cfe6748b68be5d724054a1b" translate="yes" xml:space="preserve">
          <source>Returns a new vector that points in the direction as if self would bounce of a surface characterized by the given surface normal. The length of the new vector is the same as self's.</source>
          <target state="translated">주어진 표면 법선에 의해 특징 지워지는 표면을 자체적으로 튕기는 것처럼 방향을 가리키는 새 벡터를 반환합니다. 새로운 벡터의 길이는 자기 길이와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="147e21b4be5cc23ede3dd9112b3f7061be32d517" translate="yes" xml:space="preserve">
          <source>Returns a sequence of boolean values representing the state of every key on the keyboard. Use the key constant values to index the array. A True value means the that button is pressed.</source>
          <target state="translated">키보드의 모든 키 상태를 나타내는 일련의 부울 값을 반환합니다. 키 상수 값을 사용하여 배열을 색인화하십시오. True 값은 해당 버튼을 눌렀 음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="95938454942eb46523896b6b465797636f935128" translate="yes" xml:space="preserve">
          <source>Returns a sequence of booleans representing the state of all the mouse buttons. A true value means the mouse is currently being pressed at the time of the call.</source>
          <target state="translated">모든 마우스 버튼의 상태를 나타내는 일련의 부울을 반환합니다. 참 값은 통화시 마우스를 현재 누르고 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="c1f089c40f91cc03475f68cbc7b2267b7155761b" translate="yes" xml:space="preserve">
          <source>Returns a set of current Surface features. Each feature is a bit in the flags bitmask. Typical flags are &lt;code&gt;HWSURFACE&lt;/code&gt;, &lt;code&gt;RLEACCEL&lt;/code&gt;, &lt;code&gt;SRCALPHA&lt;/code&gt;, and &lt;code&gt;SRCCOLORKEY&lt;/code&gt;.</source>
          <target state="translated">현재 Surface 지형지 물 집합을 반환합니다. 각 기능은 플래그 비트 마스크의 비트입니다. 일반적인 플래그는 &lt;code&gt;HWSURFACE&lt;/code&gt; , &lt;code&gt;RLEACCEL&lt;/code&gt; , &lt;code&gt;SRCALPHA&lt;/code&gt; 및 &lt;code&gt;SRCCOLORKEY&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="24ddc13e0c2d399e164027c48db02c80b9b69301" translate="yes" xml:space="preserve">
          <source>Returns a single event from the queue. If the event queue is empty an event of type &lt;code&gt;pygame.NOEVENT&lt;/code&gt; will be returned immediately. The returned event is removed from the queue.</source>
          <target state="translated">큐에서 단일 이벤트를 리턴합니다. 이벤트 큐가 비어 있으면 &lt;code&gt;pygame.NOEVENT&lt;/code&gt; 유형의 이벤트가 즉시 반환됩니다. 리턴 된 이벤트가 큐에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="1cdbcc9b62d7932be0264efbfe8f7d5de9c65bb1" translate="yes" xml:space="preserve">
          <source>Returns a single event from the queue. If the queue is empty this function will wait until one is created. The event is removed from the queue once it has been returned. While the program is waiting it will sleep in an idle state. This is important for programs that want to share the system with other applications.</source>
          <target state="translated">큐에서 단일 이벤트를 리턴합니다. 대기열이 비어 있으면이 기능은 대기열이 생성 될 때까지 기다립니다. 이벤트가 리턴되면 큐에서 제거됩니다. 프로그램이 대기하는 동안 유휴 상태에서 휴면 상태가됩니다. 이것은 다른 응용 프로그램과 시스템을 공유하려는 프로그램에 중요합니다.</target>
        </trans-unit>
        <trans-unit id="c1e7162a5c20360c71414f7fd7760c48587239a9" translate="yes" xml:space="preserve">
          <source>Returns a single integer representing a bitmask of all the modifier keys being held. Using bitwise operators you can test if specific shift keys are pressed, the state of the capslock button, and more.</source>
          <target state="translated">보유하고있는 모든 수정 자 키의 비트 마스크를 나타내는 단일 정수를 반환합니다. 비트 단위 연산자를 사용하면 특정 Shift 키가 눌 렸는지, Capslock 버튼의 상태 등을 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac10ef84ee28fd75903f90104a1d3cddb7bf0f5c" translate="yes" xml:space="preserve">
          <source>Returns a string representing the name (in CapWords style) of the given event type.</source>
          <target state="translated">주어진 이벤트 유형의 이름 (CapWords 스타일)을 나타내는 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6435538ecdf0a1e53d50107eee00c9c7a2943f19" translate="yes" xml:space="preserve">
          <source>Returns a surface with the mask drawn on it</source>
          <target state="translated">마스크가 그려진 표면을 반환</target>
        </trans-unit>
        <trans-unit id="4de127495372d2a95bfb7f4736dfc81ae8d86f90" translate="yes" xml:space="preserve">
          <source>Returns a tuple (r, phi) where r is the radial distance, and phi is the azimuthal angle.</source>
          <target state="translated">r이 방사상 거리이고 phi가 방위각 인 튜플 (r, phi)을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fe71c2162286c74c0e82a179425b102537179bd5" translate="yes" xml:space="preserve">
          <source>Returns a tuple (r, theta, phi) where r is the radial distance, theta is the inclination angle and phi is the azimuthal angle.</source>
          <target state="translated">튜플 (r, theta, phi)을 반환합니다. 여기서 r은 반경 거리, theta는 경사 각도, phi는 방위각입니다.</target>
        </trans-unit>
        <trans-unit id="4898286fa2feac3b6df4acf64a17933cd70358e0" translate="yes" xml:space="preserve">
          <source>Returns a vector which has the same length as self but is rotated counterclockwise around the x-axis by the given angle in degrees.</source>
          <target state="translated">self와 길이는 같지만 x 각도를 기준으로 주어진 각도로 시계 반대 방향으로 회전하는 벡터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="41e9ce5d262a330111e51452ac7abc2bd3d1cf7b" translate="yes" xml:space="preserve">
          <source>Returns a vector which has the same length as self but is rotated counterclockwise around the x-axis by the given angle in radians.</source>
          <target state="translated">self와 길이는 같지만 x 축을 중심으로 주어진 각도로 시계 반대 방향으로 회전하는 벡터를 반환합니다 (라디안).</target>
        </trans-unit>
        <trans-unit id="92c14be1f8a9d3246d48eae4a613e88724d48add" translate="yes" xml:space="preserve">
          <source>Returns a vector which has the same length as self but is rotated counterclockwise around the y-axis by the given angle in degrees.</source>
          <target state="translated">self와 길이는 같지만 주어진 각도 (도)로 y 축 주위에서 시계 반대 방향으로 회전하는 벡터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6211f2fc8e1b8d7c5ae093ea8fd82597036cb254" translate="yes" xml:space="preserve">
          <source>Returns a vector which has the same length as self but is rotated counterclockwise around the y-axis by the given angle in radians.</source>
          <target state="translated">self와 길이는 같지만 주어진 각도 (라디안)만큼 y 축 주위에서 시계 반대 방향으로 회전하는 벡터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="81e70dfc89431c7df89d78ad1505072ab6efcddc" translate="yes" xml:space="preserve">
          <source>Returns a vector which has the same length as self but is rotated counterclockwise around the z-axis by the given angle in degrees.</source>
          <target state="translated">self와 길이는 같지만 z 각도를 기준으로 주어진 각도로 시계 반대 방향으로 회전하는 벡터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="661c5bfd21d68a6188f455e02e3e24d0db4276d5" translate="yes" xml:space="preserve">
          <source>Returns a vector which has the same length as self but is rotated counterclockwise around the z-axis by the given angle in radians.</source>
          <target state="translated">self와 길이는 같지만 z 축을 중심으로 주어진 각도로 반 시계 방향으로 회전 한 벡터를 라디안 단위로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="43f72c7e1da131a4af98bfcd2dabcc35ca02b06b" translate="yes" xml:space="preserve">
          <source>Returns a vector which has the same length as self but is rotated counterclockwise by the given angle in degrees around the given axis.</source>
          <target state="translated">self와 길이는 같지만 주어진 축을 중심으로 주어진 각도만큼 시계 반대 방향으로 회전하는 벡터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6a784b1464218de1dbc29c68cd2fed73cf74e835" translate="yes" xml:space="preserve">
          <source>Returns a vector which has the same length as self but is rotated counterclockwise by the given angle in degrees.</source>
          <target state="translated">self와 길이는 같지만 주어진 각도로 시계 반대 방향으로 회전하는 벡터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="280fb2507800423bcb04b7573f032dd446b90e21" translate="yes" xml:space="preserve">
          <source>Returns a vector which has the same length as self but is rotated counterclockwise by the given angle in radians around the given axis.</source>
          <target state="translated">self와 길이는 같지만 주어진 축을 중심으로 지정된 각도만큼 시계 반대 방향으로 회전하는 벡터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="37e833eb25e31eb58cdc2d99755136c3ce9367f9" translate="yes" xml:space="preserve">
          <source>Returns a vector which has the same length as self but is rotated counterclockwise by the given angle in radians.</source>
          <target state="translated">self와 길이는 같지만 주어진 각도만큼 시계 반대 방향으로 회전 한 벡터를 라디안 단위로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8963a66dfcc299ae95a965855714a07d19c8117d" translate="yes" xml:space="preserve">
          <source>Returns all sprites from a layer, ordered by how they where added. It uses linear search and the sprites are not removed from layer.</source>
          <target state="translated">레이어의 모든 스프라이트를 추가 한 위치에 따라 순서대로 반환합니다. 선형 검색을 사용하며 스프라이트는 레이어에서 제거되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0f7fc64c6c1790e6d24ef075e8e8b2ad0f3b64bb" translate="yes" xml:space="preserve">
          <source>Returns both the current track and time of that track. This method works when the drive is either playing or paused.</source>
          <target state="translated">현재 트랙과 해당 트랙의 시간을 모두 반환합니다. 이 방법은 드라이브가 재생 중이거나 일시 중지되었을 때 작동합니다.</target>
        </trans-unit>
        <trans-unit id="645c3e36c1f142f317d4011dd9567fb987a2c4c4" translate="yes" xml:space="preserve">
          <source>Returns byte offsets for each array dimension.</source>
          <target state="translated">각 배열 차원에 대한 바이트 오프셋을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5509345d43d641c02e2eb909dd99130c2a271574" translate="yes" xml:space="preserve">
          <source>Returns first point on the mask where the masks collided, or None if there was no collision.</source>
          <target state="translated">마스크가 충돌 한 마스크의 첫 번째 지점을 반환하거나 충돌이 없으면 None을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7d1930e57f00532a47643cc561d66b8417f91be6" translate="yes" xml:space="preserve">
          <source>Returns the &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;Y&lt;/code&gt; position of the mouse cursor. The position is relative the the top-left corner of the display. The cursor position can be located outside of the display window, but is always constrained to the screen.</source>
          <target state="translated">마우스 커서 의 &lt;code&gt;X&lt;/code&gt; 및 &lt;code&gt;Y&lt;/code&gt; 위치를 반환합니다 . 위치는 디스플레이의 왼쪽 상단을 기준으로합니다. 커서 위치는 표시 창 외부에있을 수 있지만 항상 화면에 제한되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3fba7f4f4feb888d1e3874985d548c522d0cdc6" translate="yes" xml:space="preserve">
          <source>Returns the Ansi Note name for a midi number.</source>
          <target state="translated">미디 번호의 Ansi Note 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e7924223f0c14e3248020da8fc7d30cbedf3c193" translate="yes" xml:space="preserve">
          <source>Returns the amount of movement in &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;Y&lt;/code&gt; since the previous call to this function. The relative movement of the mouse cursor is constrained to the edges of the screen, but see the virtual input mouse mode for a way around this. Virtual input mode is described at the top of the page.</source>
          <target state="translated">이 함수에 대한 이전 호출 이후 &lt;code&gt;X&lt;/code&gt; 및 &lt;code&gt;Y&lt;/code&gt; 의 이동량을 반환합니다 . 마우스 커서의 상대적 이동은 화면의 가장자리로 제한되어 있지만 가상 마우스 입력 모드를 참조하십시오. 가상 입력 모드는 페이지 상단에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="526cd589e75ad52066ab0f637619af4f2c9f12c0" translate="yes" xml:space="preserve">
          <source>Returns the angle between self and the given vector.</source>
          <target state="translated">자기 벡터와 주어진 벡터 사이의 각도를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3b2d0618c18378cb2de658f882754ff5f6b2594b" translate="yes" xml:space="preserve">
          <source>Returns the array size.</source>
          <target state="translated">배열 크기를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="946c5919b64a47482b9a7da980bc7bb7559d45c2" translate="yes" xml:space="preserve">
          <source>Returns the bitmasks used to isolate each color in a mapped integer.</source>
          <target state="translated">각 색상을 매핑 된 정수로 분리하는 데 사용되는 비트 마스크를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8426b7efe99c9f0e0c75f8c9b721dbb00c1605f0" translate="yes" xml:space="preserve">
          <source>Returns the byte order of the SDL library. It returns &lt;code&gt;1234&lt;/code&gt; for little endian byte order and &lt;code&gt;4321&lt;/code&gt; for big endian byte order.</source>
          <target state="translated">SDL 라이브러리의 바이트 순서를 리턴합니다. 리틀 엔디안 바이트 순서의 경우 &lt;code&gt;1234&lt;/code&gt; 를, 빅 엔디안 바이트 순서의 경우 &lt;code&gt;4321&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="890750b90c4ab7842c531dbbc36cea1f6b3ef9cf" translate="yes" xml:space="preserve">
          <source>Returns the byte size of a pixel array item</source>
          <target state="translated">픽셀 배열 항목의 바이트 크기를 반환합니다</target>
        </trans-unit>
        <trans-unit id="dab086fcd4142077e68e16ccfbfd65e9c69fd818" translate="yes" xml:space="preserve">
          <source>Returns the centroid of the set bits</source>
          <target state="translated">설정된 비트의 중심을 반환</target>
        </trans-unit>
        <trans-unit id="0b0e6b2e773d18066f4fee36eac7a67bc111d620" translate="yes" xml:space="preserve">
          <source>Returns the convolution of this mask with another mask</source>
          <target state="translated">이 마스크와 다른 마스크의 컨벌루션을 반환합니다</target>
        </trans-unit>
        <trans-unit id="92e25f544b5f725e94bb32eab89843c9807e9a99" translate="yes" xml:space="preserve">
          <source>Returns the current dimensions of the images being captured by the camera. This will return the actual size, which may be different than the one specified during initialization if the camera did not support that size.</source>
          <target state="translated">카메라에서 캡처중인 이미지의 현재 크기를 반환합니다. 카메라가 해당 크기를 지원하지 않는 경우 실제 크기를 반환합니다. 이는 초기화 중에 지정된 크기와 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7dc950050309f7ce16f23706340ebaa5e945f09" translate="yes" xml:space="preserve">
          <source>Returns the current position of a joystick axis. The value will range from -1 to 1 with a value of 0 being centered. You may want to take into account some tolerance to handle jitter, and joystick drift may keep the joystick from centering at 0 or using the full range of position values.</source>
          <target state="translated">조이스틱 축의 현재 위치를 반환합니다. 값의 범위는 -1에서 1 사이이며 값은 0입니다. 지터를 처리하기 위해 약간의 공차를 고려할 수 있으며 조이스틱 드리프트는 조이스틱이 0의 중심에 오거나 전체 범위 값을 사용하지 못하게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2ff425d925c6602a76108a5f24c3280ca0d6471" translate="yes" xml:space="preserve">
          <source>Returns the current position of a position hat. The position is given as two values representing the &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;Y&lt;/code&gt; position for the hat. (0, 0) means centered. A value of -1 means left/down and a value of 1 means right/up: so (-1, 0) means left; (1, 0) means right; (0, 1) means up; (1, 1) means upper-right; etc.</source>
          <target state="translated">위치 모자의 현재 위치를 반환합니다. 위치는 모자 의 &lt;code&gt;X&lt;/code&gt; 및 &lt;code&gt;Y&lt;/code&gt; 위치를 나타내는 두 개의 값으로 제공됩니다 . (0, 0)은 중심을 의미합니다. -1의 값은 왼쪽 / 아래를 의미하고 1의 값은 오른쪽 / 위를 의미합니다. 따라서 (-1, 0)은 왼쪽을 의미합니다. (1, 0)은 옳은 것을 의미합니다. (0, 1)은 의미합니다. (1, 1)은 오른쪽 상단을 의미합니다. 기타</target>
        </trans-unit>
        <trans-unit id="03b0335335dfb0ebaf3b23cef848f766cc31d0b8" translate="yes" xml:space="preserve">
          <source>Returns the current state of a joystick button.</source>
          <target state="translated">조이스틱 버튼의 현재 상태를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="831cc397eb327a982adb1c277070fd496191a98f" translate="yes" xml:space="preserve">
          <source>Returns the current volume for the mixer. The value will be between 0.0 and 1.0.</source>
          <target state="translated">믹서의 현재 볼륨을 반환합니다. 값은 0.0과 1.0 사이입니다.</target>
        </trans-unit>
        <trans-unit id="14b2c72f8de8736e2e32739a64e26b0201444eea" translate="yes" xml:space="preserve">
          <source>Returns the currently existing locks for the Surface.</source>
          <target state="translated">Surface에 대해 현재 존재하는 잠금을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a727767608c9d98a3e8dcfdf80faa48a341705e8" translate="yes" xml:space="preserve">
          <source>Returns the default pixel size, in dots per inch, for the module. The default is 72 DPI.</source>
          <target state="translated">모듈의 기본 픽셀 크기를 인치당 도트 수로 반환합니다. 기본값은 72 DPI입니다.</target>
        </trans-unit>
        <trans-unit id="b9f3d9bc865f903e85ab7cb8e78d71918ce6a7b7" translate="yes" xml:space="preserve">
          <source>Returns the dimensions needed to render the text. This can be used to help determine the positioning needed for text before it is rendered. It can also be used for wordwrapping and other layout effects.</source>
          <target state="translated">텍스트를 렌더링하는 데 필요한 치수를 반환합니다. 텍스트를 렌더링하기 전에 필요한 위치를 결정하는 데 도움이됩니다. 워드 랩핑 및 기타 레이아웃 효과에도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61455e113b03894c34b484783d3d428d2d8305af" translate="yes" xml:space="preserve">
          <source>Returns the event type to be sent every time the Channel finishes playback of a Sound. If there is no endevent the function returns &lt;code&gt;pygame.NOEVENT&lt;/code&gt;.</source>
          <target state="translated">채널이 사운드 재생을 마칠 때마다 전송 될 이벤트 유형을 반환합니다. 종료 이벤트가 없으면 함수는 &lt;code&gt;pygame.NOEVENT&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="7185499a8b5ccaecf8da172d33a00560c1b6de78" translate="yes" xml:space="preserve">
          <source>Returns the event type to be sent every time the music finishes playback. If there is no endevent the function returns &lt;code&gt;pygame.NOEVENT&lt;/code&gt;.</source>
          <target state="translated">음악 재생이 끝날 때마다 전송되는 이벤트 유형을 반환합니다. 종료 이벤트가 없으면 함수는 &lt;code&gt;pygame.NOEVENT&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="eeed792db8b2095ce85f860a5ff382b3116f604c" translate="yes" xml:space="preserve">
          <source>Returns the first key and value pair that intersects with the calling Rect object. If no collisions are found, &lt;code&gt;None&lt;/code&gt; is returned. If &lt;code&gt;use_values&lt;/code&gt; is 0 (default) then the dict's keys will be used in the collision detection, otherwise the dict's values will be used.</source>
          <target state="translated">호출 Rect 객체와 교차하는 첫 번째 키와 값 쌍을 반환합니다. 충돌이 없으면 &lt;code&gt;None&lt;/code&gt; 이 반환됩니다. 경우 &lt;code&gt;use_values&lt;/code&gt; 는 다음 DICT의 키가 충돌 감지에 사용됩니다 0 (기본값) 그렇지 않으면 DICT의 값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0c92ee9d41aa30c98e7f4cd25870e57d8f892327" translate="yes" xml:space="preserve">
          <source>Returns the first point of intersection encountered between this mask and &lt;code&gt;othermask&lt;/code&gt;. A point of intersection is 2 overlapping set bits.</source>
          <target state="translated">이 마스크와 &lt;code&gt;othermask&lt;/code&gt; 마스크 사이의 첫 번째 교차점을 반환합니다 . 교차점은 2 개의 겹치는 세트 비트입니다.</target>
        </trans-unit>
        <trans-unit id="051e563a5b40c76db4f8d1e4545796d8c2ab3bae" translate="yes" xml:space="preserve">
          <source>Returns the full path to a font file on the system. If bold or italic are set to true, this will attempt to find the correct family of font.</source>
          <target state="translated">시스템에서 글꼴 파일의 전체 경로를 반환합니다. 굵게 또는 기울임 꼴이 true로 설정된 경우 올바른 글꼴 모음을 찾으려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="8540246238779bce0c3bc02e2718627cbc193af5" translate="yes" xml:space="preserve">
          <source>Returns the glyph metrics for each character in &lt;em&gt;text&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;text의&lt;/em&gt; 각 문자에 대한 글리프 메트릭을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="e19c80d0933536223648e26a8406a64e0e442d81" translate="yes" xml:space="preserve">
          <source>Returns the height of the font. This is the average value of all glyphs in the font. It is not adjusted for strong or rotation.</source>
          <target state="translated">폰트의 높이를 돌려줍니다. 글꼴에있는 모든 글리프의 평균값입니다. 강하거나 회전하도록 조정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="51100732e7ae34aa7b666e8ac231082fc6149ef9" translate="yes" xml:space="preserve">
          <source>Returns the integer &lt;code&gt;ID&lt;/code&gt; that represents this device. This is the same value that was passed to the &lt;code&gt;Joystick()&lt;/code&gt; constructor. This method can safely be called while the Joystick is not initialized.</source>
          <target state="translated">이 장치를 나타내는 정수 &lt;code&gt;ID&lt;/code&gt; 를 리턴합니다 . &lt;code&gt;Joystick()&lt;/code&gt; 생성자 에 전달 된 것과 동일한 값입니다 . 조이스틱이 초기화되지 않은 상태에서이 메소드를 안전하게 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a4bae030006b9173a41557148fd55d3b46e99a6" translate="yes" xml:space="preserve">
          <source>Returns the integer id that was used to create the &lt;code&gt;CD&lt;/code&gt; instance. This method can work on an uninitialized &lt;code&gt;CD&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CD&lt;/code&gt; 인스턴스 를 작성하는 데 사용 된 정수 ID를 리턴합니다 . 이 방법은 초기화되지 않은 &lt;code&gt;CD&lt;/code&gt; 에서 작동 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5f3fba4a39b60b1c8bd5691e565fed7262937545" translate="yes" xml:space="preserve">
          <source>Returns the normalized &lt;code&gt;RGBA&lt;/code&gt; values of the Color as floating point values.</source>
          <target state="translated">Color 의 표준화 된 &lt;code&gt;RGBA&lt;/code&gt; 값을 부동 소수점 값으로 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="5450fac9727900f76f5ef81718ab6faea9ccfd72" translate="yes" xml:space="preserve">
          <source>Returns the normalized RGBA values of the Color.</source>
          <target state="translated">Color의 표준화 된 RGBA 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8e2484136e9fde22092dc33e255d51d8b390d9de" translate="yes" xml:space="preserve">
          <source>Returns the number of available displays. This is always 1 if &lt;a href=&quot;pygame#pygame.get_sdl_version&quot;&gt;&lt;code&gt;pygame.get_sdl_version()&lt;/code&gt;&lt;/a&gt; returns a major version number below 2.</source>
          <target state="translated">사용 가능한 디스플레이 수를 반환합니다. &lt;a href=&quot;pygame#pygame.get_sdl_version&quot;&gt; &lt;code&gt;pygame.get_sdl_version()&lt;/code&gt; &lt;/a&gt; 2 이하의 메이저 버전 번호를 반환 하면 항상 1 입니다.</target>
        </trans-unit>
        <trans-unit id="ef2b8bfdf9bdf0219ad686d146f30a9878c1b87e" translate="yes" xml:space="preserve">
          <source>Returns the number of bits used to represent each pixel. This value may not exactly fill the number of bytes used per pixel. For example a 15 bit Surface still requires a full 2 bytes.</source>
          <target state="translated">각 픽셀을 나타내는 데 사용되는 비트 수를 반환합니다. 이 값은 픽셀 당 사용 된 바이트 수를 정확하게 채우지 않을 수 있습니다. 예를 들어 15 비트 Surface에는 여전히 전체 2 바이트가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a30e0e83ebc38bc9594633ae6836be0b3f6228a0" translate="yes" xml:space="preserve">
          <source>Returns the number of currently active playback channels.</source>
          <target state="translated">현재 활성화 된 재생 채널 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="30402fce859539e9fbd2b24831c4fe6efb6881b5" translate="yes" xml:space="preserve">
          <source>Returns the number of dimensions.</source>
          <target state="translated">차원 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8721c2461fd1ab16b825e813f5409f15ee3ec6da" translate="yes" xml:space="preserve">
          <source>Returns the number of input axes are on a Joystick. There will usually be two for the position. Controls like rudders and throttles are treated as additional axes.</source>
          <target state="translated">조이스틱에있는 입력 축의 개수를 반환합니다. 그 위치에는 보통 두 가지가 있습니다. 러더 및 스로틀과 같은 컨트롤은 추가 축으로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="1c53996dc4cb3bae2900993e89978800a38dbf78" translate="yes" xml:space="preserve">
          <source>Returns the number of joystick hats on a Joystick. Hat devices are like miniature digital joysticks on a joystick. Each hat has two axes of input.</source>
          <target state="translated">조이스틱의 조이스틱 모자 수를 반환합니다. 모자 장치는 조이스틱의 소형 디지털 조이스틱과 같습니다. 각 모자에는 두 개의 입력 축이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4a25c2a6fa247502c2a9c7bfc3ecc4e3fc12997" translate="yes" xml:space="preserve">
          <source>Returns the number of joysticks.</source>
          <target state="translated">조이스틱 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7af98eefa2571dbfc626898c849c6166d84fea30" translate="yes" xml:space="preserve">
          <source>Returns the number of overlapping set bits</source>
          <target state="translated">겹치는 세트 비트 수를 반환</target>
        </trans-unit>
        <trans-unit id="ca17165f8785af46a54a1e91b2dda01d7273aae7" translate="yes" xml:space="preserve">
          <source>Returns the number of overlapping set bits between between this mask and &lt;code&gt;othermask&lt;/code&gt;.</source>
          <target state="translated">이 마스크와 &lt;code&gt;othermask&lt;/code&gt; 마스크 사이의 겹치는 세트 비트 수를 돌려줍니다 .</target>
        </trans-unit>
        <trans-unit id="826f17cffa1dd545699b76fbe77fed68b296eb46" translate="yes" xml:space="preserve">
          <source>Returns the number of pushable buttons on the joystick. These buttons have a boolean (on or off) state.</source>
          <target state="translated">조이스틱의 푸시 버튼 수를 반환합니다. 이 버튼은 부울 (켜기 또는 끄기) 상태입니다.</target>
        </trans-unit>
        <trans-unit id="42177b5cfc9dd78e0e461163f1d922c3ec1e1e23" translate="yes" xml:space="preserve">
          <source>Returns the number of set bits</source>
          <target state="translated">설정된 비트 수를 반환</target>
        </trans-unit>
        <trans-unit id="47c18b23183e00a8c31ca500d31de1ac033dcbe3" translate="yes" xml:space="preserve">
          <source>Returns the number of trackball devices on a Joystick. These devices work similar to a mouse but they have no absolute position; they only have relative amounts of movement.</source>
          <target state="translated">조이스틱의 트랙볼 장치 수를 반환합니다. 이 장치는 마우스와 유사하게 작동하지만 절대 위치는 없습니다. 그들은 상대적으로 움직임이 있습니다.</target>
        </trans-unit>
        <trans-unit id="05896c5a283afb6439a611f31bea52e4bbe1e413" translate="yes" xml:space="preserve">
          <source>Returns the orientation of the set bits</source>
          <target state="translated">설정된 비트의 방향을 반환</target>
        </trans-unit>
        <trans-unit id="98791cc4d573c8e171a477f00685e70a8da64f1b" translate="yes" xml:space="preserve">
          <source>Returns the parent Surface of a subsurface. If this is not a subsurface then &lt;code&gt;None&lt;/code&gt; will be returned.</source>
          <target state="translated">하위 표면의 부모 표면을 반환합니다. 이것이 서브 서피스가 아닌 경우 &lt;code&gt;None&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3c46f28af6e3e27938fad3e24cb62d0b1257ec91" translate="yes" xml:space="preserve">
          <source>Returns the parent Surface of a subsurface. If this is not a subsurface then this surface will be returned.</source>
          <target state="translated">하위 표면의 부모 표면을 반환합니다. 이것이 지표면이 아닌 경우이 지표면이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="5a242ac2d63c6cebb880fe3540ea5afe8c102e05" translate="yes" xml:space="preserve">
          <source>Returns the pixel shifts need to convert between each color and a mapped integer.</source>
          <target state="translated">각 색과 매핑 된 정수간에 변환해야하는 픽셀 이동을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="53f1636ff01f7d0d90a0b5f0f5178caae27af7e1" translate="yes" xml:space="preserve">
          <source>Returns the point of intersection</source>
          <target state="translated">교차점을 반환</target>
        </trans-unit>
        <trans-unit id="583895de604543e5b66fc0fd5311dbe4162badb1" translate="yes" xml:space="preserve">
          <source>Returns the red, green, and blue color values for a single index in a Surface palette. The index should be a value from 0 to 255.</source>
          <target state="translated">표면 팔레트에서 단일 인덱스의 빨강, 녹색 및 파랑 색상 값을 반환합니다. 인덱스는 0에서 255 사이의 값이어야합니다.</target>
        </trans-unit>
        <trans-unit id="f9384bcf4fbbebe7cfb59f87d479c62cc406a491" translate="yes" xml:space="preserve">
          <source>Returns the relative movement of a joystick button. The value is a x, y pair holding the relative movement since the last call to get_ball.</source>
          <target state="translated">조이스틱 버튼의 상대적 이동을 반환합니다. 값은 ax, y 쌍이며 get_ball에 대한 마지막 호출 이후 상대 이동을 보유합니다.</target>
        </trans-unit>
        <trans-unit id="3588c83f08000717194ef9f4e39675229368ef81" translate="yes" xml:space="preserve">
          <source>Returns the size of the mask</source>
          <target state="translated">마스크의 크기를 반환</target>
        </trans-unit>
        <trans-unit id="ffbb393f6be3a6532ebf62c498ad68ff50fd13e7" translate="yes" xml:space="preserve">
          <source>Returns the size of the window initialized with &lt;code&gt;pygame.set_mode()&lt;/code&gt;. This may differ from the size of the display surface if &lt;code&gt;SCALED&lt;/code&gt; is used.</source>
          <target state="translated">&lt;code&gt;pygame.set_mode()&lt;/code&gt; 초기화 된 창의 크기를 반환합니다 . &lt;code&gt;SCALED&lt;/code&gt; 를 사용하는 경우 디스플레이 표면의 크기와 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="57e047f18f1f3a11e7570ab8982f9cd4a9cc2e68" translate="yes" xml:space="preserve">
          <source>Returns the smallest rectangular region that contains all the pixels in the surface that have an alpha value greater than or equal to the minimum alpha value.</source>
          <target state="translated">알파 값이 최소 알파 값 이상인 표면의 모든 픽셀을 포함하는 가장 작은 사각형 영역을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ebeb4c07dd7c5f0fed46b0fb43c51a75209c1af2" translate="yes" xml:space="preserve">
          <source>Returns the system name for this joystick device. It is unknown what name the system will give to the Joystick, but it should be a unique name that identifies the device. This method can safely be called while the Joystick is not initialized.</source>
          <target state="translated">이 조이스틱 장치의 시스템 이름을 반환합니다. 시스템이 조이스틱에 어떤 이름을 부여할지는 알 수 없지만 장치를 식별하는 고유 한 이름이어야합니다. 조이스틱이 초기화되지 않은 상태에서이 메소드를 안전하게 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c67475aec14c238c58a47851567bf16887b0015" translate="yes" xml:space="preserve">
          <source>Returns the three version numbers of the SDL library. This version is built at compile time. It can be used to detect which features may or may not be available through pygame.</source>
          <target state="translated">SDL 라이브러리의 세 가지 버전 번호를 반환합니다. 이 버전은 컴파일 타임에 빌드됩니다. 파이 게임을 통해 사용 가능하거나 사용 불가능한 기능을 감지하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e32647ce767aefeb21fca2bed239129891ea5030" translate="yes" xml:space="preserve">
          <source>Returns the title and icontitle for the display Surface. These will often be the same value.</source>
          <target state="translated">디스플레이 표면의 제목과 아이콘 제목을 반환합니다. 이들은 종종 같은 가치가 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="4efe8758f61703cb67bc354d4fa863e21f514778" translate="yes" xml:space="preserve">
          <source>Returns the union of one rectangle with a sequence of many rectangles.</source>
          <target state="translated">하나의 사각형과 여러 사각형의 시퀀스의 합집합을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dbd47fc8e0d672b9f06254e1670bfd802f1b1195" translate="yes" xml:space="preserve">
          <source>Returns the version of the FreeType library in use by this module.</source>
          <target state="translated">이 모듈에서 사용중인 FreeType 라이브러리의 버전을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="eb0936e704509bd2cb73233d9c9d4cb3c994d2f7" translate="yes" xml:space="preserve">
          <source>Returns true if any portion of either rectangle overlap (except the top+bottom or left+right edges).</source>
          <target state="translated">사각형의 일부가 겹치면 (위쪽 + 아래쪽 또는 왼쪽 + 오른쪽 가장자리 제외) true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e6f0a2faedf4cf141b38cd8f53883447cab1231a" translate="yes" xml:space="preserve">
          <source>Returns true if the given point is inside the rectangle. A point along the right or bottom edge is not considered to be inside the rectangle.</source>
          <target state="translated">주어진 점이 사각형 안에 있으면 true를 반환합니다. 오른쪽 또는 아래쪽 가장자리를 따르는 점은 사각형 안에있는 것으로 간주되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d22708f40b69cd60faefa28e997c391c0a22e0bc" translate="yes" xml:space="preserve">
          <source>Returns true when pygame is receiving mouse input events (or, in windowing terminology, is &quot;active&quot; or has the &quot;focus&quot;).</source>
          <target state="translated">파이 게임이 마우스 입력 이벤트를 받거나 창 용어로 &quot;활성&quot;또는 &quot;포커스&quot;가있는 경우 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="cfa2d12e892f28e7e562bd3c17d23ec7590d4956" translate="yes" xml:space="preserve">
          <source>Returns true when the argument is completely inside the Rect.</source>
          <target state="translated">인수가 Rect 내부에 완전히있을 때 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7749fcf802c472b6c2f5bd0556805e456ffd5674" translate="yes" xml:space="preserve">
          <source>Returns:</source>
          <target state="translated">Returns:</target>
        </trans-unit>
        <trans-unit id="83ecbbd4aeb59245e554c1ecad063cb1e9866f75" translate="yes" xml:space="preserve">
          <source>Rotates the vector counterclockwise around the given axis by the given angle in degrees. The length of the vector is not changed.</source>
          <target state="translated">주어진 각도를 기준으로 주어진 축을 중심으로 벡터를 시계 반대 방향으로 회전합니다. 벡터의 길이는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="896834438df7949c9af5755dba0c5f73aa383b0a" translate="yes" xml:space="preserve">
          <source>Rotates the vector counterclockwise around the given axis by the given angle in radians. The length of the vector is not changed.</source>
          <target state="translated">주어진 각도를 기준으로 주어진 각도를 기준으로 벡터를 시계 반대 방향으로 회전합니다 (라디안). 벡터의 길이는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a6ffaf8fd68f3a1f98db90595005d71661aeda26" translate="yes" xml:space="preserve">
          <source>Rotates the vector counterclockwise around the x-axis by the given angle in degrees. The length of the vector is not changed.</source>
          <target state="translated">주어진 각도로 x 축을 중심으로 벡터를 시계 반대 방향으로 회전합니다. 벡터의 길이는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="297501e081341d16c4f9d397e1bfdf99fa4f87ec" translate="yes" xml:space="preserve">
          <source>Rotates the vector counterclockwise around the x-axis by the given angle in radians. The length of the vector is not changed.</source>
          <target state="translated">주어진 각도 (라디안)로 x 축을 중심으로 벡터를 시계 반대 방향으로 회전합니다. 벡터의 길이는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="659ab2d9971799b06182977deb9bc07def80fa44" translate="yes" xml:space="preserve">
          <source>Rotates the vector counterclockwise around the y-axis by the given angle in degrees. The length of the vector is not changed.</source>
          <target state="translated">주어진 각도 (도)로 y 축을 중심으로 벡터를 시계 반대 방향으로 회전합니다. 벡터의 길이는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e42da80d52bc78a4d0d291a7b13a6a0f1028a860" translate="yes" xml:space="preserve">
          <source>Rotates the vector counterclockwise around the y-axis by the given angle in radians. The length of the vector is not changed.</source>
          <target state="translated">주어진 각도 (라디안)로 y 축을 중심으로 벡터를 시계 반대 방향으로 회전합니다. 벡터의 길이는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4127aca7f93fcca0032f781578a02f12d67054b8" translate="yes" xml:space="preserve">
          <source>Rotates the vector counterclockwise around the z-axis by the given angle in degrees. The length of the vector is not changed.</source>
          <target state="translated">주어진 각도로 z 축을 중심으로 벡터를 시계 반대 방향으로 회전합니다. 벡터의 길이는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3069756c3f4702d99853839e4202b3cd7b5b187b" translate="yes" xml:space="preserve">
          <source>Rotates the vector counterclockwise around the z-axis by the given angle in radians. The length of the vector is not changed.</source>
          <target state="translated">지정된 각도 (라디안)로 z 축 주위에서 벡터를 시계 반대 방향으로 회전합니다. 벡터의 길이는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="264b0c56e0b60e2304565f0eeb05c9694db07039" translate="yes" xml:space="preserve">
          <source>Rotates the vector counterclockwise by the given angle in degrees. The length of the vector is not changed.</source>
          <target state="translated">주어진 각도로 벡터를 시계 반대 방향으로 회전합니다. 벡터의 길이는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="990ce2f6aa6be69ca3b53150ac84ea8a4079b5ec" translate="yes" xml:space="preserve">
          <source>Rotates the vector counterclockwise by the given angle in radians. The length of the vector is not changed.</source>
          <target state="translated">주어진 각도로 벡터를 시계 반대 방향으로 회전합니다 (라디안). 벡터의 길이는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="31cb782b75c6a47844325704446f10fe4b9cb278" translate="yes" xml:space="preserve">
          <source>Run the pygame unit test suite</source>
          <target state="translated">파이 게임 유닛 테스트 스위트 실행</target>
        </trans-unit>
        <trans-unit id="6669d39e4b1e7c849bbc972989c143f791571f0f" translate="yes" xml:space="preserve">
          <source>SDL maintains an internal error message. This message will usually be given to you when &lt;a href=&quot;#pygame.error&quot;&gt;&lt;code&gt;pygame.error()&lt;/code&gt;&lt;/a&gt; is raised, so this function will rarely be needed.</source>
          <target state="translated">SDL은 내부 오류 메시지를 유지합니다. 이 메시지는 일반적으로 &lt;a href=&quot;#pygame.error&quot;&gt; &lt;code&gt;pygame.error()&lt;/code&gt; &lt;/a&gt; 가 발생할 때 제공 되므로이 함수는 거의 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="366a0050ea250c82a84dcb2d20613ffe584f8adc" translate="yes" xml:space="preserve">
          <source>Same as for the &lt;a href=&quot;#pygame.sprite.Group&quot;&gt;&lt;code&gt;pygame.sprite.Group&lt;/code&gt;&lt;/a&gt;. You can specify some additional attributes through kwargs:</source>
          <target state="translated">&lt;a href=&quot;#pygame.sprite.Group&quot;&gt; &lt;code&gt;pygame.sprite.Group&lt;/code&gt; &lt;/a&gt; 과 동일합니다 . kwargs를 통해 몇 가지 추가 속성을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6dfe59e53b6ccac14355b15b26f1cd7003a77d41" translate="yes" xml:space="preserve">
          <source>Same as pygame.sprite.Group</source>
          <target state="translated">pygame.sprite.Group과 동일</target>
        </trans-unit>
        <trans-unit id="88df7f3d2235c41d6c850445bc5299694d17b23b" translate="yes" xml:space="preserve">
          <source>Same as the &lt;code&gt;Rect.clamp()&lt;/code&gt; method, but operates in place.</source>
          <target state="translated">&lt;code&gt;Rect.clamp()&lt;/code&gt; 메서드 와 동일 하지만 제대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="09de271bff16a453d8e56a0c46735b9a43f0f13d" translate="yes" xml:space="preserve">
          <source>Same as the &lt;code&gt;Rect.inflate()&lt;/code&gt; method, but operates in place.</source>
          <target state="translated">&lt;code&gt;Rect.inflate()&lt;/code&gt; 메서드 와 동일 하지만 제대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="09952e8ff863d129afdceafed9ce1be7b6f88c46" translate="yes" xml:space="preserve">
          <source>Same as the &lt;code&gt;Rect.move()&lt;/code&gt; method, but operates in place.</source>
          <target state="translated">&lt;code&gt;Rect.move()&lt;/code&gt; 메서드 와 동일 하지만 제대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="44f93f9f874bda2c23b6199627f0d1f623aa5be3" translate="yes" xml:space="preserve">
          <source>Same as the &lt;code&gt;Rect.union()&lt;/code&gt; method, but operates in place.</source>
          <target state="translated">&lt;code&gt;Rect.union()&lt;/code&gt; 메소드 와 동일 하지만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="f815d9a342487287c615b1f32ce886f302123865" translate="yes" xml:space="preserve">
          <source>Saving images only supports a limited set of formats. You can save to the following formats.</source>
          <target state="translated">이미지 저장은 제한된 형식 세트 만 지원합니다. 다음 형식으로 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe1d7e9ed771748a0e9d96dcc605b88ec14bb44a" translate="yes" xml:space="preserve">
          <source>Scales the vector so that it has the given length. The direction of the vector is not changed. You can also scale to length 0. If the vector is the zero vector (i.e. has length 0 thus no direction) an ZeroDivisionError is raised.</source>
          <target state="translated">주어진 길이를 갖도록 벡터 크기를 조정합니다. 벡터의 방향은 바뀌지 않습니다. 길이를 0으로 조정할 수도 있습니다. 벡터가 0 인 벡터 (즉, 길이가 0이므로 방향이없는 경우)는 ZeroDivisionError가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a4646e8db8830da4f2ae2ee8d1e9b82ea14195ee" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#pygame.Surface.get_offset&quot;&gt;&lt;code&gt;get_offset()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#pygame.Surface.get_parent&quot;&gt;&lt;code&gt;get_parent()&lt;/code&gt;&lt;/a&gt; to learn more about the state of a subsurface.</source>
          <target state="translated">&lt;a href=&quot;#pygame.Surface.get_offset&quot;&gt; &lt;code&gt;get_offset()&lt;/code&gt; &lt;/a&gt; 표면 상태에 대한 자세한 내용은 get_offset () 및 &lt;a href=&quot;#pygame.Surface.get_parent&quot;&gt; &lt;code&gt;get_parent()&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c9aabf9fc218b677db2bcba067885b457f961fb9" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#pygame.freetype.init&quot;&gt;&lt;code&gt;pygame.freetype.init()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#pygame.freetype.init&quot;&gt; &lt;code&gt;pygame.freetype.init()&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9b1ff29fdf8a340ca39bf56a92f0b12efbdb3808" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#pygame.mask.Mask.connected_component&quot;&gt;&lt;code&gt;connected_component()&lt;/code&gt;&lt;/a&gt; for details on how a connected component is calculated.</source>
          <target state="translated">연결된 구성 요소를 계산하는 방법에 대한 자세한 내용 은 &lt;a href=&quot;#pygame.mask.Mask.connected_component&quot;&gt; &lt;code&gt;connected_component()&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f8765b1069dfd14dc87d04881a178fc0ff1d0d57" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#pygame.midi.get_default_input_id&quot;&gt;&lt;code&gt;get_default_input_id()&lt;/code&gt;&lt;/a&gt; for usage details.</source>
          <target state="translated">사용법에 대한 자세한 내용은 &lt;a href=&quot;#pygame.midi.get_default_input_id&quot;&gt; &lt;code&gt;get_default_input_id()&lt;/code&gt; &lt;/a&gt; 를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="2fc114e6dac161ffe236681c259548575b835ed4" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;surfarray#pygame.surfarray.blit_array&quot;&gt;&lt;code&gt;pygame.surfarray.blit_array()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;surfarray#pygame.surfarray.blit_array&quot;&gt; &lt;code&gt;pygame.surfarray.blit_array()&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="867e6f21651ce24623037d6aa4598350071ec3f5" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#pygame.freetype.Font.fixed_sizes&quot;&gt;&lt;code&gt;fixed_sizes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#pygame.freetype.Font.get_sizes&quot;&gt;&lt;code&gt;get_sizes()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#pygame.freetype.Font.fixed_sizes&quot;&gt; &lt;code&gt;fixed_sizes&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#pygame.freetype.Font.get_sizes&quot;&gt; &lt;code&gt;get_sizes()&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f9322c3f77cf1598736347389d81830b257317eb" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;draw#module-pygame.draw&quot;&gt;&lt;code&gt;pygame.draw&lt;/code&gt;&lt;/a&gt; module for alternative draw methods.</source>
          <target state="translated">대체 그리기 방법 은 &lt;a href=&quot;draw#module-pygame.draw&quot;&gt; &lt;code&gt;pygame.draw&lt;/code&gt; &lt;/a&gt; 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="08dc1fcefb4c78077b5adb994cb69bbb65b068c2" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;gfxdraw#module-pygame.gfxdraw&quot;&gt;&lt;code&gt;pygame.gfxdraw&lt;/code&gt;&lt;/a&gt; module for alternative draw methods.</source>
          <target state="translated">대체 그리기 방법 은 &lt;a href=&quot;gfxdraw#module-pygame.gfxdraw&quot;&gt; &lt;code&gt;pygame.gfxdraw&lt;/code&gt; &lt;/a&gt; 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b2025478a8db43103e409cfaac54b9ee471e5bb0" translate="yes" xml:space="preserve">
          <source>See the &lt;code&gt;CD.get_numtracks()&lt;/code&gt; and &lt;code&gt;CD.get_track_audio()&lt;/code&gt; to find tracks to playback.</source>
          <target state="translated">재생할 트랙을 찾으 려면 &lt;code&gt;CD.get_numtracks()&lt;/code&gt; 및 &lt;code&gt;CD.get_track_audio()&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e1149ff1ad2ac7f1f793735e259c85035fc99577" translate="yes" xml:space="preserve">
          <source>See the &lt;code&gt;pygame.cursor&lt;/code&gt; module for help creating default and custom masks for the system cursor.</source>
          <target state="translated">시스템 커서에 대한 기본 및 사용자 정의 마스크를 만드는 데 도움이 필요 하면 &lt;code&gt;pygame.cursor&lt;/code&gt; 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e80156958de37fa181ba8cb585adb7d3b9b26e2d" translate="yes" xml:space="preserve">
          <source>See the &lt;code&gt;pygame.image.frombuffer()&lt;/code&gt; method for a potentially faster way to transfer images into pygame.</source>
          <target state="translated">이미지를 파이 게임으로 전송할 수있는 더 빠른 방법 은 &lt;code&gt;pygame.image.frombuffer()&lt;/code&gt; 메소드를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ceba48575a0c4d72d1222e1b31babbb5a0534320" translate="yes" xml:space="preserve">
          <source>See the Surface object documentation for more information about colors and pixel formats.</source>
          <target state="translated">색상 및 픽셀 형식에 대한 자세한 내용은 Surface 객체 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="48a421cd4b7e4c8ff033f69eb84ee8965856a342" translate="yes" xml:space="preserve">
          <source>See the threshold tests for a full of examples: &lt;a href=&quot;https://github.com/pygame/pygame/blob/master/test/transform_test.py&quot;&gt;https://github.com/pygame/pygame/blob/master/test/transform_test.py&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/pygame/pygame/blob/master/test/transform_test.py&quot;&gt;https://github.com/pygame/pygame/blob/master/test/transform_test.py&lt;/a&gt; 예제를 보려면 임계 값 테스트를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1ae5ee617f5b1586507919a9d0aa1e64ce11d4c1" translate="yes" xml:space="preserve">
          <source>Select an instrument.</source>
          <target state="translated">악기를 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="9bf879754c49d8428868ae0a489bfb2f470b51e6" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;GL_MULTISAMPLESAMPLES&lt;/code&gt; to a value above 0 to control the amount of anti-aliasing. A typical value is 2 or 3.</source>
          <target state="translated">앤티 앨리어싱 양을 제어하려면 &lt;code&gt;GL_MULTISAMPLESAMPLES&lt;/code&gt; 를 0보다 큰 값으로 설정하십시오 . 일반적인 값은 2 또는 3입니다.</target>
        </trans-unit>
        <trans-unit id="d4e6f8beacda3626b00d46bf14e60dea3c716652" translate="yes" xml:space="preserve">
          <source>Set an event type to appear on the event queue every given number of milliseconds. The first event will not appear until the amount of time has passed.</source>
          <target state="translated">주어진 밀리 초마다 이벤트 유형이 이벤트 큐에 나타나도록 설정하십시오. 첫 번째 이벤트는 시간이 지날 때까지 나타나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="84813f7033de91fc85d49c21f47f6288300863e5" translate="yes" xml:space="preserve">
          <source>Set the &lt;code&gt;RGBA&lt;/code&gt; or mapped integer color value for a single pixel. If the Surface does not have per pixel alphas, the alpha value is ignored. Setting pixels outside the Surface area or outside the Surface clipping will have no effect.</source>
          <target state="translated">단일 픽셀에 대해 &lt;code&gt;RGBA&lt;/code&gt; 또는 매핑 된 정수 색상 값을 설정하십시오 . Surface에 픽셀 당 알파가 없으면 알파 값이 무시됩니다. 표면 영역 외부 또는 표면 클리핑 외부의 픽셀을 설정해도 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="8874097d04b4b4d80f4ed855143fa70d333f21fb" translate="yes" xml:space="preserve">
          <source>Set the current alpha value for the Surface. When blitting this Surface onto a destination, the pixels will be drawn slightly transparent. The alpha value is an integer from 0 to 255, 0 is fully transparent and 255 is fully opaque. If &lt;code&gt;None&lt;/code&gt; is passed for the alpha value, then alpha blending will be disabled, including per-pixel alpha.</source>
          <target state="translated">Surface의 현재 알파 값을 설정하십시오. 이 표면을 대상에 블리 팅하면 픽셀이 약간 투명하게 그려집니다. 알파 값은 0에서 255 사이의 정수이고 0은 완전히 투명하며 255는 완전히 불투명합니다. 알파 값에 [ &lt;code&gt;None&lt;/code&gt; 이 전달 되면 픽셀 별 알파를 포함하여 알파 블렌딩이 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="0b6d7eb46fc8981e96e47a30140d4ef58b0293e6" translate="yes" xml:space="preserve">
          <source>Set the current color key for the Surface. When blitting this Surface onto a destination, any pixels that have the same color as the colorkey will be transparent. The color can be an &lt;code&gt;RGB&lt;/code&gt; color or a mapped color integer. If &lt;code&gt;None&lt;/code&gt; is passed, the colorkey will be unset.</source>
          <target state="translated">Surface의 현재 색상 키를 설정하십시오. 이 표면을 대상에 블리 팅 할 때 컬러 키와 동일한 색상을 가진 모든 픽셀은 투명합니다. 색상은 &lt;code&gt;RGB&lt;/code&gt; 색상이거나 매핑 된 색상 정수일 수 있습니다. 경우 &lt;code&gt;None&lt;/code&gt; 전달되지, 컬러 키가 해제 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="f83972e29843b1127bf16fb5932b27bdee9bf4dc" translate="yes" xml:space="preserve">
          <source>Set the current mouse position to arguments given. If the mouse cursor is visible it will jump to the new coordinates. Moving the mouse will generate a new &lt;code&gt;pygame.MOUSEMOTION&lt;/code&gt; event.</source>
          <target state="translated">현재 마우스 위치를 지정된 인수로 설정하십시오. 마우스 커서가 보이면 새로운 좌표로 점프합니다. 마우스를 움직이면 새로운 &lt;code&gt;pygame.MOUSEMOTION&lt;/code&gt; 이벤트 가 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="130bdd2ed29c986b66167860f5e16802a0f004f5" translate="yes" xml:space="preserve">
          <source>Set the current window caption</source>
          <target state="translated">현재 창 캡션 설정</target>
        </trans-unit>
        <trans-unit id="951f2cffe9bd1ea3a3339b219fcda0e6dcddbe7c" translate="yes" xml:space="preserve">
          <source>Set the default pixel size in dots per inch for the module</source>
          <target state="translated">모듈의 기본 픽셀 크기를 인치당 도트 수로 설정</target>
        </trans-unit>
        <trans-unit id="346e157768d85e60959927a03cf26827da4e4b48" translate="yes" xml:space="preserve">
          <source>Set the default pixel size, in dots per inch, for the module. If the optional argument is omitted or zero the resolution is reset to 72 DPI.</source>
          <target state="translated">모듈의 기본 픽셀 크기를 인치당 도트 수로 설정하십시오. 선택적 인수를 생략하거나 0으로 설정하면 해상도가 72 DPI로 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="cebae23395ef259bbb5f78a9d4034db8257792c1" translate="yes" xml:space="preserve">
          <source>Set the display color palette for indexed displays</source>
          <target state="translated">인덱스 디스플레이에 대한 디스플레이 색상 표 설정</target>
        </trans-unit>
        <trans-unit id="f411436edac6076bafcf39b2a9d518981bbcedf7" translate="yes" xml:space="preserve">
          <source>Set the full palette for an 8-bit Surface. This will replace the colors in the existing palette. A partial palette can be passed and only the first colors in the original palette will be changed.</source>
          <target state="translated">8 비트 Surface에 대한 전체 팔레트를 설정하십시오. 기존 팔레트의 색상이 바뀝니다. 부분 팔레트를 전달할 수 있으며 원래 팔레트의 첫 번째 색상 만 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="c9d2f0a4a4f08a3e44712d271ca1e2f1a17b7a7f" translate="yes" xml:space="preserve">
          <source>Set the location for the overlay. The overlay will always be shown relative to the main display Surface. This does not actually redraw the overlay, it will be updated on the next call to &lt;code&gt;Overlay.display()&lt;/code&gt;.</source>
          <target state="translated">오버레이의 위치를 ​​설정하십시오. 오버레이는 항상 주 디스플레이 표면을 기준으로 표시됩니다. 실제로 오버레이를 다시 그리지는 않지만 다음에 &lt;code&gt;Overlay.display()&lt;/code&gt; 호출하면 업데이트됩니다 .</target>
        </trans-unit>
        <trans-unit id="3f943f84d25c6b060e3daee9f0d99bdad9e6eab6" translate="yes" xml:space="preserve">
          <source>Set the number of elements in the Color to 1,2,3, or 4.</source>
          <target state="translated">색상의 요소 수를 1,2,3 또는 4로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="d516ab9a8bdbcf3f19e27e9022ed590704a3c87f" translate="yes" xml:space="preserve">
          <source>Set the palette value for a single entry in a Surface palette. The index should be a value from 0 to 255.</source>
          <target state="translated">표면 팔레트에서 단일 항목의 팔레트 값을 설정하십시오. 인덱스는 0에서 255 사이의 값이어야합니다.</target>
        </trans-unit>
        <trans-unit id="35f2dcf1fc45e63cae26c3ffc0c65d27a93226b4" translate="yes" xml:space="preserve">
          <source>Set the red, green, and blue gamma ramps with an explicit lookup table. Each argument should be sequence of 256 integers. The integers should range between 0 and 0xffff. Not all systems and hardware support gamma ramps, if the function succeeds it will return True.</source>
          <target state="translated">명시 적 조회 테이블을 사용하여 빨강, 녹색 및 파랑 감마 램프를 설정합니다. 각 인수는 256 개의 정수 시퀀스 여야합니다. 정수는 0에서 0xffff 사이 여야합니다. 모든 시스템 및 하드웨어가 감마 램프를 지원하는 것은 아닙니다. 기능이 성공하면 True를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="aad1c8d9ce4db2cb6edd7313b30ce5eb71feec96" translate="yes" xml:space="preserve">
          <source>Set the red, green, and blue gamma values on the display hardware. If the green and blue arguments are not passed, they will both be the same as red. Not all systems and hardware support gamma ramps, if the function succeeds it will return True.</source>
          <target state="translated">디스플레이 하드웨어에서 빨강, 녹색 및 파랑 감마 값을 설정하십시오. 녹색 및 파란색 인수가 전달되지 않으면 모두 빨간색과 동일합니다. 모든 시스템 및 하드웨어가 감마 램프를 지원하는 것은 아닙니다. 기능이 성공하면 True를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5c49e527241aee9a50beb39917ae87e6b01cd730" translate="yes" xml:space="preserve">
          <source>Set the transparent colorkey</source>
          <target state="translated">투명 컬러 키 설정</target>
        </trans-unit>
        <trans-unit id="ca271397bb2e796bd12ec15b170470e9fce99c70" translate="yes" xml:space="preserve">
          <source>Set the volume (loudness) of a playing sound. When a channel starts to play its volume value is reset. This only affects the current sound. The value argument is between 0.0 and 1.0.</source>
          <target state="translated">연주 음의 음량 (음량)을 설정하십시오. 채널이 재생을 시작하면 볼륨 값이 재설정됩니다. 이것은 현재 사운드에만 영향을줍니다. 값 인수는 0.0과 1.0 사이입니다.</target>
        </trans-unit>
        <trans-unit id="641b73b4fe62c63c8070723994006d8226a135ac" translate="yes" xml:space="preserve">
          <source>Set the volume of the music playback. The value argument is between 0.0 and 1.0. When new music is loaded the volume is reset.</source>
          <target state="translated">음악 재생 음량을 설정하십시오. 값 인수는 0.0과 1.0 사이입니다. 새 음악이로드되면 볼륨이 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="fce27605725323d2811d1b5225fe364a2e59465d" translate="yes" xml:space="preserve">
          <source>Set to 1 to require hardware acceleration, or 0 to force software render. By default, both are allowed.</source>
          <target state="translated">하드웨어 가속을 요구하려면 1로 설정하고 소프트웨어 렌더링을 강제하려면 0으로 설정하십시오. 기본적으로 둘 다 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="65715e35b4468893b92a154e926866c449c517b4" translate="yes" xml:space="preserve">
          <source>Set to &lt;code&gt;False&lt;/code&gt; to do monochrome rendering. This should provide a small speed gain and reduce cache memory size.</source>
          <target state="translated">흑백 렌더링을 수행 하려면 &lt;code&gt;False&lt;/code&gt; 로 설정하십시오 . 이는 작은 속도 게인을 제공하고 캐시 메모리 크기를 줄여야합니다.</target>
        </trans-unit>
        <trans-unit id="0125476cd4b610484c4960084b30950462187532" translate="yes" xml:space="preserve">
          <source>Set to &lt;code&gt;True&lt;/code&gt; to add kerning between character pairs, if supported by the font, when positioning glyphs.</source>
          <target state="translated">글리프를 배치 할 때 글꼴에서 지원하는 경우 문자 쌍 사이에 자간을 추가 하려면 &lt;code&gt;True&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="8329a7e58d59d8535e4ffbaa6b4988ca9fbfa024" translate="yes" xml:space="preserve">
          <source>Set to &lt;code&gt;True&lt;/code&gt; to switch to a vertical text layout. The default is &lt;code&gt;False&lt;/code&gt;, place horizontally.</source>
          <target state="translated">세로 텍스트 레이아웃으로 전환 하려면 &lt;code&gt;True&lt;/code&gt; 로 설정하십시오 . 기본값은 &lt;code&gt;False&lt;/code&gt; 이며 가로로 배치합니다.</target>
        </trans-unit>
        <trans-unit id="3842bd5e7a22f8fa09f015cf4c7e59c81131d4d2" translate="yes" xml:space="preserve">
          <source>Sets all bits in the mask to 0.</source>
          <target state="translated">마스크의 모든 비트를 0으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="37fa79fd8c6f1bf5002c3413b31ce8718c6cbb29" translate="yes" xml:space="preserve">
          <source>Sets all bits in the mask to 1.</source>
          <target state="translated">마스크의 모든 비트를 1로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="29d4c848583e98356ad467ee4cfb74482811157b" translate="yes" xml:space="preserve">
          <source>Sets all bits to 0</source>
          <target state="translated">모든 비트를 0으로 설정</target>
        </trans-unit>
        <trans-unit id="861802777334b4c90980136bf5769ecceddd59ff" translate="yes" xml:space="preserve">
          <source>Sets all bits to 1</source>
          <target state="translated">모든 비트를 1로 설정</target>
        </trans-unit>
        <trans-unit id="d6decb66c5937054dabbd6ca82be516ee98840fd" translate="yes" xml:space="preserve">
          <source>Sets coordinates x and y in place.</source>
          <target state="translated">좌표 x와 y를 제자리에 설정합니다.</target>
        </trans-unit>
        <trans-unit id="9a069a77f22061f0084edab6f17ac40ea6843714" translate="yes" xml:space="preserve">
          <source>Sets coordinates x, y, and z in place.</source>
          <target state="translated">좌표 x, y 및 z를 제자리에 설정합니다.</target>
        </trans-unit>
        <trans-unit id="c8ad3ad8fc020e99ed818ea73ce7b28ce1bd7bd1" translate="yes" xml:space="preserve">
          <source>Sets smoothscale acceleration. Takes a string argument. A value of 'GENERIC' turns off acceleration. 'MMX' uses &lt;code&gt;MMX&lt;/code&gt; instructions only. 'SSE' allows &lt;code&gt;SSE&lt;/code&gt; extensions as well. A value error is raised if type is not recognized or not supported by the current processor.</source>
          <target state="translated">부드러운 스케일 가속을 설정합니다. 문자열 인수를 취합니다. 'GENERIC'값은 가속을 끕니다. 'MMX'는 &lt;code&gt;MMX&lt;/code&gt; 명령어 만 사용합니다. 'SSE'는 &lt;code&gt;SSE&lt;/code&gt; 확장도 허용 합니다. 유형이 현재 프로세서에서 인식되지 않거나 지원되지 않으면 값 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2fb4bae3a85a3746db615fce418f90518b09074f" translate="yes" xml:space="preserve">
          <source>Sets the OpenGL profile to one of these values:</source>
          <target state="translated">OpenGL 프로파일을 다음 값 중 하나로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="4d72121dc706e7abe98b23fb601b3aec5eb0c4b8" translate="yes" xml:space="preserve">
          <source>Sets the access mode for the clipboard. This is only of interest for X11 environments where clipboard modes &lt;code&gt;pygame.SCRAP_SELECTION&lt;/code&gt; (for mouse selections) and &lt;code&gt;pygame.SCRAP_CLIPBOARD&lt;/code&gt; (for the clipboard) are available. Setting the mode to &lt;code&gt;pygame.SCRAP_SELECTION&lt;/code&gt; in other environments will not change the mode from &lt;code&gt;pygame.SCRAP_CLIPBOARD&lt;/code&gt;.</source>
          <target state="translated">클립 보드의 액세스 모드를 설정합니다. 이것은 클립 보드 모드 &lt;code&gt;pygame.SCRAP_SELECTION&lt;/code&gt; (마우스 선택의 경우) 및 &lt;code&gt;pygame.SCRAP_CLIPBOARD&lt;/code&gt; (클립 보드의 경우)를 사용할 수 있는 X11 환경에서만 유용합니다. 로 모드 설정 &lt;code&gt;pygame.SCRAP_SELECTION&lt;/code&gt; 을 다른 환경에서 것은에서 모드 변경되지 않습니다 &lt;code&gt;pygame.SCRAP_CLIPBOARD&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="1cbc82a0aa7cca7915863050eaea6196302e2b77" translate="yes" xml:space="preserve">
          <source>Sets the array system to be used for sound arrays</source>
          <target state="translated">사운드 배열에 사용될 배열 시스템을 설정합니다</target>
        </trans-unit>
        <trans-unit id="8c801b485392e8c718268510a210cec86e134ee6" translate="yes" xml:space="preserve">
          <source>Sets the array system to be used for surface arrays</source>
          <target state="translated">표면 배열에 사용될 배열 시스템을 설정합니다</target>
        </trans-unit>
        <trans-unit id="9ed404d9fd69c58f241afe881ed0cd740d168570" translate="yes" xml:space="preserve">
          <source>Sets the bit at the given position</source>
          <target state="translated">주어진 위치에서 비트를 설정합니다</target>
        </trans-unit>
        <trans-unit id="acf49ffaed87a5d816267334e218e6cdcc45aa98" translate="yes" xml:space="preserve">
          <source>Sets the clipboard access mode.</source>
          <target state="translated">클립 보드 액세스 모드를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="64cdc57a0f70cfca7a50b20afef5e7f39949fc97" translate="yes" xml:space="preserve">
          <source>Sets the coordinates of the vector.</source>
          <target state="translated">벡터의 좌표를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="b905141608a3d799fd3e4a678fa76559247bbc6c" translate="yes" xml:space="preserve">
          <source>Sets the number of available channels for the mixer. The default value is 8. The value can be increased or decreased. If the value is decreased, sounds playing on the truncated channels are stopped.</source>
          <target state="translated">믹서에 사용 가능한 채널 수를 설정합니다. 기본값은 8입니다. 값을 늘리거나 줄일 수 있습니다. 값이 감소하면 잘린 채널에서 재생되는 사운드가 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="6f5df933a5c2852c74bffd9e7b2da92bd074ee35" translate="yes" xml:space="preserve">
          <source>Sets the runtime icon the system will use to represent the display window. All windows default to a simple pygame logo for the window icon.</source>
          <target state="translated">시스템이 표시 창을 나타내는 데 사용할 런타임 아이콘을 설정합니다. 모든 창은 기본적으로 창 아이콘에 대한 간단한 파이 게임 로고로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="f6e63f56dc44fc2770ebd74b244f66fca4ce5feb" translate="yes" xml:space="preserve">
          <source>Sets x and y from a polar coordinates tuple.</source>
          <target state="translated">극좌표 튜플에서 x와 y를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="2120758c569612d761c27be79b7cd541aca14db6" translate="yes" xml:space="preserve">
          <source>Sets x and y from a tuple (r, phi) where r is the radial distance, and phi is the azimuthal angle.</source>
          <target state="translated">튜플 (r, phi)에서 x와 y를 설정합니다. 여기서 r은 반지름 거리이고 phi는 방위각입니다.</target>
        </trans-unit>
        <trans-unit id="c8936de222a50f3882d02097d1f4d34dc052cab1" translate="yes" xml:space="preserve">
          <source>Sets x, y and z from a spherical coordinates 3-tuple.</source>
          <target state="translated">구형 좌표 3 튜플에서 x, y 및 z를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="cb8d2c2879d036f6b63b2efa067bcb09869485e6" translate="yes" xml:space="preserve">
          <source>Sets x, y and z from a tuple (r, theta, phi) where r is the radial distance, theta is the inclination angle and phi is the azimuthal angle.</source>
          <target state="translated">튜플 (r, theta, phi)에서 x, y 및 z를 설정합니다. 여기서 r은 반경 거리, theta는 경사각, phi는 방위각입니다.</target>
        </trans-unit>
        <trans-unit id="6ec41d761be3397ad236ddc39b048427fca35396" translate="yes" xml:space="preserve">
          <source>Shift the surface image in place</source>
          <target state="translated">표면 이미지를 제자리로 이동</target>
        </trans-unit>
        <trans-unit id="bc39ebd55c17a155674a93326ab80b0d21eac728" translate="yes" xml:space="preserve">
          <source>Shows whether or not smoothscale is using &lt;code&gt;MMX&lt;/code&gt; or &lt;code&gt;SSE&lt;/code&gt; acceleration. If no acceleration is available then &quot;GENERIC&quot; is returned. For a x86 processor the level of acceleration to use is determined at runtime.</source>
          <target state="translated">smoothscale이 &lt;code&gt;MMX&lt;/code&gt; 또는 &lt;code&gt;SSE&lt;/code&gt; 가속을 사용하는지 여부를 표시합니다 . 사용 가능한 가속이 없으면 &quot;GENERIC&quot;이 반환됩니다. x86 프로세서의 경우 사용할 가속 수준은 런타임에 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="0a1b43545bec5ef2427f9120c44211606e0dcd2a" translate="yes" xml:space="preserve">
          <source>Shut down the underlying FreeType library.</source>
          <target state="translated">기본 FreeType 라이브러리를 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="8671a50ac40aeae2030c9d691063abec57b22684" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;Clock.get_time()&lt;/code&gt;, but does not include any time used while &lt;code&gt;Clock.tick()&lt;/code&gt; was delaying to limit the framerate.</source>
          <target state="translated">&lt;code&gt;Clock.get_time()&lt;/code&gt; 과 유사 하지만 &lt;code&gt;Clock.tick()&lt;/code&gt; 가 프레임 속도를 제한하기 위해 지연 되는 동안 사용 된 시간은 포함하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="bd755d9b4c8c3e0108b852816b10c0137e29bac1" translate="yes" xml:space="preserve">
          <source>Simple base class for visible game objects.</source>
          <target state="translated">보이는 게임 오브젝트를위한 간단한 기본 클래스.</target>
        </trans-unit>
        <trans-unit id="c4a0755249f40592357fb7f1e85dcc699f0985ad" translate="yes" xml:space="preserve">
          <source>Simple test if a sprite intersects anything in a group.</source>
          <target state="translated">스프라이트가 그룹의 어떤 항목과 교차하는지 간단한 테스트.</target>
        </trans-unit>
        <trans-unit id="47b63538cab6d4bcb8449511f7f471fd843d53d2" translate="yes" xml:space="preserve">
          <source>So far it looks like normal &lt;a href=&quot;event#module-pygame.event&quot;&gt;&lt;code&gt;pygame.event&lt;/code&gt;&lt;/a&gt; is faster by up to two times. So maybe fastevent isn't fast at all.</source>
          <target state="translated">지금까지 일반적인 &lt;a href=&quot;event#module-pygame.event&quot;&gt; &lt;code&gt;pygame.event&lt;/code&gt; &lt;/a&gt; 는 최대 두 배 빠릅니다. 아마도 fastevent는 전혀 빠르지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="b6bf5a7f570190e04cf5de7bf6c4b7e8cb4bc844" translate="yes" xml:space="preserve">
          <source>Some display environments have an option for automatically stretching all windows. When this option is enabled, this automatic stretching distorts the appearance of the pygame window. In the pygame examples directory, there is example code (prevent_display_stretching.py) which shows how to disable this automatic stretching of the pygame display on Microsoft Windows (Vista or newer required).</source>
          <target state="translated">일부 디스플레이 환경에는 모든 창을 자동으로 늘릴 수있는 옵션이 있습니다. 이 옵션이 활성화되면이 자동 스트레칭이 파이 게임 창의 모양을 왜곡합니다. 파이 게임 예제 디렉토리에는 Microsoft Windows에서 파이 게임 디스플레이의 자동 확장을 비활성화하는 방법을 보여주는 예제 코드 (prevent_display_stretching.py)가 있습니다 (Vista 이상 필요).</target>
        </trans-unit>
        <trans-unit id="adc2eea0a5aec8e41aa6f51acb20e4bb29748117" translate="yes" xml:space="preserve">
          <source>Some general information about the Vector2 class.</source>
          <target state="translated">Vector2 클래스에 대한 일반적인 정보입니다.</target>
        </trans-unit>
        <trans-unit id="16c92186f9511633fea45c248866bb9d85644d47" translate="yes" xml:space="preserve">
          <source>Some general information about the Vector3 class.</source>
          <target state="translated">Vector3 클래스에 대한 일반적인 정보입니다.</target>
        </trans-unit>
        <trans-unit id="67cea29c642f8560851a0511ccb90a6d3bdf19f7" translate="yes" xml:space="preserve">
          <source>Some of the transforms are considered destructive. These means every time they are performed they lose pixel data. Common examples of this are resizing and rotating. For this reason, it is better to re-transform the original surface than to keep transforming an image multiple times. (For example, suppose you are animating a bouncing spring which expands and contracts. If you applied the size changes incrementally to the previous images, you would lose detail. Instead, always begin with the original image and scale to the desired size.)</source>
          <target state="translated">일부 변환은 파괴적인 것으로 간주됩니다. 즉, 수행 할 때마다 픽셀 데이터가 손실됩니다. 이것의 일반적인 예는 크기 조정 및 회전입니다. 이러한 이유로 이미지를 여러 번 계속 변형하는 것보다 원래 표면을 다시 변환하는 것이 좋습니다. (예를 들어, 확장 및 축소되는 튀는 스프링에 애니메이션을 적용한다고 가정합니다. 크기 변경을 이전 이미지에 점차적으로 적용하면 세부 사항이 손실됩니다. 대신 항상 원본 이미지로 시작하여 원하는 크기로 조정하십시오.)</target>
        </trans-unit>
        <trans-unit id="75ac1bb90b24b0a03d910062eb9a6d8570ef1583" translate="yes" xml:space="preserve">
          <source>Some platforms require the &lt;a href=&quot;#module-pygame.mixer&quot;&gt;&lt;code&gt;pygame.mixer&lt;/code&gt;&lt;/a&gt; module to be initialized after the display modules have initialized. The top level &lt;code&gt;pygame.init()&lt;/code&gt; takes care of this automatically, but cannot pass any arguments to the mixer init. To solve this, mixer has a function &lt;code&gt;pygame.mixer.pre_init()&lt;/code&gt; to set the proper defaults before the toplevel init is used.</source>
          <target state="translated">일부 플랫폼에서는 디스플레이 모듈이 초기화 된 후 &lt;a href=&quot;#module-pygame.mixer&quot;&gt; &lt;code&gt;pygame.mixer&lt;/code&gt; &lt;/a&gt; 모듈을 초기화 해야합니다 . 최상위 레벨 &lt;code&gt;pygame.init()&lt;/code&gt; 는 이것을 자동으로 처리하지만 믹서 init에 인수를 전달할 수 없습니다. 이 문제를 해결하기 위해 믹서에는 &lt;code&gt;pygame.mixer.pre_init()&lt;/code&gt; 함수가있어 최상위 init를 사용하기 전에 적절한 기본값을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="dde782a0fa2ee593e33705a826cc0f6268354625" translate="yes" xml:space="preserve">
          <source>Some scalable fonts include embedded bitmaps for particular point sizes. This property controls whether or not those bitmap strikes are used. Set it &lt;code&gt;False&lt;/code&gt; to disable the loading of any bitmap strike. Set it &lt;code&gt;True&lt;/code&gt;, the default, to permit bitmap strikes for a non-rotated render with no style other than &lt;a href=&quot;#pygame.freetype.Font.wide&quot;&gt;&lt;code&gt;wide&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#pygame.freetype.Font.underline&quot;&gt;&lt;code&gt;underline&lt;/code&gt;&lt;/a&gt;. This property is ignored for bitmap fonts.</source>
          <target state="translated">일부 확장 가능한 글꼴에는 특정 포인트 크기에 대한 비트 맵이 포함되어 있습니다. 이 속성은 해당 비트 맵 스트라이크 사용 여부를 제어합니다. 이 설정 &lt;code&gt;False&lt;/code&gt; 비트 맵 파업의 로딩을 비활성화 할 수 있습니다. &lt;a href=&quot;#pygame.freetype.Font.wide&quot;&gt; &lt;code&gt;wide&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#pygame.freetype.Font.underline&quot;&gt; &lt;code&gt;underline&lt;/code&gt; &lt;/a&gt; 이외의 스타일이없는 회전되지 않은 렌더에 비트 맵 스트라이크를 허용하려면 기본값으로 &lt;code&gt;True&lt;/code&gt; 로 설정하십시오 . 비트 맵 글꼴의 경우이 속성은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="959fe22cc2b9b2f05e6bf16d3f0e00f821db19b1" translate="yes" xml:space="preserve">
          <source>Some systems do not allow the window icon to change after it has been shown. This function can be called before &lt;code&gt;pygame.display.set_mode()&lt;/code&gt; to create the icon before the display mode is set.</source>
          <target state="translated">일부 시스템에서는 창 아이콘이 표시된 후에 변경되지 않습니다. 이 함수는 &lt;code&gt;pygame.display.set_mode()&lt;/code&gt; 전에 호출 되어 디스플레이 모드가 설정되기 전에 아이콘을 생성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4e70d83f349d4c96bffe756bee790ec52c9e3827" translate="yes" xml:space="preserve">
          <source>Sometimes the black and white color values will be split into two separate &lt;code&gt;XBM&lt;/code&gt; files. You can pass a second maskfile argument to load the two images into a single cursor.</source>
          <target state="translated">때때로 흑백 색상 값이 두 개의 개별 &lt;code&gt;XBM&lt;/code&gt; 파일 로 분할됩니다 . 두 번째 마스크 파일 인수를 전달하여 두 개의 이미지를 단일 커서에로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e178e70d4ee3d058fef49f4635edb3f13d420e8" translate="yes" xml:space="preserve">
          <source>Sound data is made of thousands of samples per second, and each sample is the amplitude of the wave at a particular moment in time. For example, in 22-kHz format, element number 5 of the array is the amplitude of the wave after 5/22000 seconds.</source>
          <target state="translated">사운드 데이터는 초당 수천 개의 샘플로 구성되며 각 샘플은 특정 시점의 웨이브 진폭입니다. 예를 들어, 22kHz 형식에서 배열의 요소 번호 5는 5/22000 초 후 파의 진폭입니다.</target>
        </trans-unit>
        <trans-unit id="1a15c92262fce16e5c0b597ef61d2275360ac276" translate="yes" xml:space="preserve">
          <source>Specific to surface_to_array, a ValueError is raised for target arrays with incorrect shape or item size. A TypeError is raised for an incorrect kind code. Surface specific problems, such as locking, raise a pygame.error.</source>
          <target state="translated">surface_to_array와 관련하여 잘못된 모양 또는 항목 크기를 가진 대상 배열에 대해 ValueError가 발생합니다. 잘못된 종류 코드에 대해 TypeError가 발생합니다. 잠금과 같은 표면 관련 문제로 인해 pygame.error가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="90dd1ff4e2a9189a862e0162b339f463ffb0f4b5" translate="yes" xml:space="preserve">
          <source>Sprites and Groups manage their relationships with the &lt;code&gt;add()&lt;/code&gt; and &lt;code&gt;remove()&lt;/code&gt; methods. These methods can accept a single or multiple targets for membership. The default initializers for these classes also takes a single or list of targets for initial membership. It is safe to repeatedly add and remove the same Sprite from a Group.</source>
          <target state="translated">스프라이트와 그룹은 &lt;code&gt;add()&lt;/code&gt; 및 &lt;code&gt;remove()&lt;/code&gt; 메소드 와의 관계를 관리 합니다. 이 방법은 멤버쉽을 위해 하나 또는 여러 개의 대상을 승인 할 수 있습니다. 이 클래스의 기본 이니셜 라이저는 초기 멤버쉽을위한 단일 또는 대상 목록을 가져옵니다. 그룹에서 동일한 스프라이트를 반복적으로 추가하고 제거하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="a2aff7ee04c3aee433dc0325f847cd0200ec4fef" translate="yes" xml:space="preserve">
          <source>Sprites are not thread safe. So lock them yourself if using threads.</source>
          <target state="translated">스프라이트는 스레드 안전하지 않습니다. 스레드를 사용하는 경우 직접 잠그십시오.</target>
        </trans-unit>
        <trans-unit id="bb95bea8a9de6150b3fa287580cf55bcac365560" translate="yes" xml:space="preserve">
          <source>Start receiving &lt;code&gt;pygame.TEXTEDITING&lt;/code&gt; and &lt;code&gt;pygame.TEXTINPUT&lt;/code&gt; events to handle IME.</source>
          <target state="translated">&lt;code&gt;pygame.TEXTEDITING&lt;/code&gt; 및 &lt;code&gt;pygame.TEXTINPUT&lt;/code&gt; 이벤트 수신을 시작 하여 IME를 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="815f077eae9da0b6c43fb32197ece8219c85ff59" translate="yes" xml:space="preserve">
          <source>Start the playback of the music stream</source>
          <target state="translated">음악 스트림 재생을 시작합니다</target>
        </trans-unit>
        <trans-unit id="50d2d61a25890f4dc6a44494c3e017f0900946e2" translate="yes" xml:space="preserve">
          <source>Stop playback of a channel after fading out the sound over the given time argument in milliseconds.</source>
          <target state="translated">주어진 시간 인수 동안 밀리 초 단위로 사운드를 페이드 아웃 한 후 채널 재생을 중지합니다.</target>
        </trans-unit>
        <trans-unit id="5233bc3aa18a87bc624ed0b3a28edaba5bea2430" translate="yes" xml:space="preserve">
          <source>Stop receiving &lt;code&gt;pygame.TEXTEDITING&lt;/code&gt; and &lt;code&gt;pygame.TEXTINPUT&lt;/code&gt; events to handle IME.</source>
          <target state="translated">IME를 처리하기 위해 &lt;code&gt;pygame.TEXTEDITING&lt;/code&gt; 및 &lt;code&gt;pygame.TEXTINPUT&lt;/code&gt; 이벤트 수신을 중지하십시오 .</target>
        </trans-unit>
        <trans-unit id="fd977b44b7bb0211ba87273fcdc0de5c6d66d7e8" translate="yes" xml:space="preserve">
          <source>Stop sound playback on a channel. After playback is stopped the channel becomes available for new Sounds to play on it.</source>
          <target state="translated">채널에서 사운드 재생을 중지합니다. 재생이 정지되면 새로운 사운드를 재생할 수있는 채널이 생깁니다.</target>
        </trans-unit>
        <trans-unit id="c1df26d4b159f2626202e28961cdf85627234d1c" translate="yes" xml:space="preserve">
          <source>Stops playback of audio from the cdrom. This will also lose the current playback position. This method does nothing if the drive isn't already playing audio.</source>
          <target state="translated">CDROM에서 오디오 재생을 중지합니다. 현재 재생 위치도 잃게됩니다. 이 방법은 드라이브가 이미 오디오를 재생하지 않는 경우 아무 것도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fc080f41578572e4d112d7d5de2ab21c3ab77ab8" translate="yes" xml:space="preserve">
          <source>Stops recording, uninitializes the camera, and closes it. Once a camera is stopped, the below functions cannot be used until it is started again.</source>
          <target state="translated">녹화를 중지하고 카메라를 초기화하지 않고 닫습니다. 카메라가 정지되면 다시 시작할 때까지 아래 기능을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e4cc49fa5bc208b0e12fd648574135e0a7ad9d7c" translate="yes" xml:space="preserve">
          <source>Stops the music playback if it is currently playing.</source>
          <target state="translated">현재 재생중인 음악 재생을 중지합니다.</target>
        </trans-unit>
        <trans-unit id="800bb14ee22aff16baaf0e2272eaa405a5afc20f" translate="yes" xml:space="preserve">
          <source>Subscript slices can also be used to assign to a rectangular subview of the target PixelArray.</source>
          <target state="translated">첨자 슬라이스를 사용하여 대상 PixelArray의 직사각형 하위 뷰에 할당 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="84ce8bbf086432441660921a01514b746c964033" translate="yes" xml:space="preserve">
          <source>Subscript slices can also be used to do fast rectangular pixel manipulations instead of iterating over the x or y axis. The</source>
          <target state="translated">첨자 슬라이스를 사용하여 x 또는 y 축을 반복하는 대신 빠른 직사각형 픽셀 조작을 수행 할 수도 있습니다. 그만큼</target>
        </trans-unit>
        <trans-unit id="88450aff5373e01b987d86b42784170bca688b7c" translate="yes" xml:space="preserve">
          <source>Super quick, super simple application demonstrating the different ways to render fonts with the font module</source>
          <target state="translated">글꼴 모듈을 사용하여 글꼴을 렌더링하는 다양한 방법을 보여주는 매우 빠르고 간단한 응용 프로그램</target>
        </trans-unit>
        <trans-unit id="e5fb15f7e1b2bc15f7fc6a6696af0f84be5714f8" translate="yes" xml:space="preserve">
          <source>Supported &lt;code&gt;color_value&lt;/code&gt; formats:</source>
          <target state="translated">지원되는 &lt;code&gt;color_value&lt;/code&gt; 형식 :</target>
        </trans-unit>
        <trans-unit id="cda05ca6d84a03a6a21fb0309b7a2d8bab187f63" translate="yes" xml:space="preserve">
          <source>Surface</source>
          <target state="translated">Surface</target>
        </trans-unit>
        <trans-unit id="cf5059c906d9e875050b0fb55320ab43e66ae6ed" translate="yes" xml:space="preserve">
          <source>Surface colorspace conversion</source>
          <target state="translated">표면 색 공간 변환</target>
        </trans-unit>
        <trans-unit id="3715d6c467f054b71fa4a0e7605a635288f994d6" translate="yes" xml:space="preserve">
          <source>Surface pixels are stored internally as a single number that has all the colors encoded into it. Use the &lt;a href=&quot;#pygame.Surface.map_rgb&quot;&gt;&lt;code&gt;map_rgb()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#pygame.Surface.unmap_rgb&quot;&gt;&lt;code&gt;unmap_rgb()&lt;/code&gt;&lt;/a&gt; to convert between individual red, green, and blue values into a packed integer for that Surface.</source>
          <target state="translated">표면 픽셀은 모든 색상이 인코딩 된 단일 숫자로 내부적으로 저장됩니다. &lt;a href=&quot;#pygame.Surface.map_rgb&quot;&gt; &lt;code&gt;map_rgb()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#pygame.Surface.unmap_rgb&quot;&gt; &lt;code&gt;unmap_rgb()&lt;/code&gt; &lt;/a&gt; 를 사용하여 개별 빨강, 녹색 및 파랑 값을 해당 Surface에 대한 팩형 정수로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="bda2b5b569cec98c1b3b6526e8a83786f2dc48de" translate="yes" xml:space="preserve">
          <source>Surface._pixels_address</source>
          <target state="translated">Surface._pixels_address</target>
        </trans-unit>
        <trans-unit id="5e089e24aab4558eb96f3aba928a5e91875cb698" translate="yes" xml:space="preserve">
          <source>Surface.blit()</source>
          <target state="translated">Surface.blit()</target>
        </trans-unit>
        <trans-unit id="a9ef5963a7e1b3759021310376c2617ccdbeb891" translate="yes" xml:space="preserve">
          <source>Surface.blits()</source>
          <target state="translated">Surface.blits()</target>
        </trans-unit>
        <trans-unit id="c39cfcbd027fa6809f35d395f16d7392b1d71657" translate="yes" xml:space="preserve">
          <source>Surface.convert()</source>
          <target state="translated">Surface.convert()</target>
        </trans-unit>
        <trans-unit id="1943b37591ca077743320660c15f0f84dcad8136" translate="yes" xml:space="preserve">
          <source>Surface.convert_alpha()</source>
          <target state="translated">Surface.convert_alpha()</target>
        </trans-unit>
        <trans-unit id="06a036f4feacc166636cb9598cab37ce094ac5a1" translate="yes" xml:space="preserve">
          <source>Surface.copy()</source>
          <target state="translated">Surface.copy()</target>
        </trans-unit>
        <trans-unit id="fd8f3f6a096c5e21e95331a8bd9bc24430ee2036" translate="yes" xml:space="preserve">
          <source>Surface.fill()</source>
          <target state="translated">Surface.fill()</target>
        </trans-unit>
        <trans-unit id="f17d296775469f0b7b282e45833e41ef81df62f4" translate="yes" xml:space="preserve">
          <source>Surface.get_abs_offset()</source>
          <target state="translated">Surface.get_abs_offset()</target>
        </trans-unit>
        <trans-unit id="c6a940d22eb2896cddb32a36d90a7e37115e8cd2" translate="yes" xml:space="preserve">
          <source>Surface.get_abs_parent()</source>
          <target state="translated">Surface.get_abs_parent()</target>
        </trans-unit>
        <trans-unit id="3323641ad0f85af454217cde43f540d5d3436f93" translate="yes" xml:space="preserve">
          <source>Surface.get_alpha()</source>
          <target state="translated">Surface.get_alpha()</target>
        </trans-unit>
        <trans-unit id="9bbf7ec1436517e6aeca776c4db117b725802228" translate="yes" xml:space="preserve">
          <source>Surface.get_at()</source>
          <target state="translated">Surface.get_at()</target>
        </trans-unit>
        <trans-unit id="549d69baf975ae7664626755c7fbb481dac5d898" translate="yes" xml:space="preserve">
          <source>Surface.get_at_mapped()</source>
          <target state="translated">Surface.get_at_mapped()</target>
        </trans-unit>
        <trans-unit id="ace4816d15a16e7a0204bf6cfcbd7fed141ff6dc" translate="yes" xml:space="preserve">
          <source>Surface.get_bitsize()</source>
          <target state="translated">Surface.get_bitsize()</target>
        </trans-unit>
        <trans-unit id="0393a8ba771fb215b22f2bf1aaf6f20b4f9f36fd" translate="yes" xml:space="preserve">
          <source>Surface.get_bounding_rect()</source>
          <target state="translated">Surface.get_bounding_rect()</target>
        </trans-unit>
        <trans-unit id="34c55b503a5a33c8d27d95b7855788c226cf76e5" translate="yes" xml:space="preserve">
          <source>Surface.get_buffer()</source>
          <target state="translated">Surface.get_buffer()</target>
        </trans-unit>
        <trans-unit id="76356b539b0236937919fa54738d54db8cb4d3c4" translate="yes" xml:space="preserve">
          <source>Surface.get_bytesize()</source>
          <target state="translated">Surface.get_bytesize()</target>
        </trans-unit>
        <trans-unit id="ad894c9ee70ecda9a5c04e3fe58617ffa3a96ca2" translate="yes" xml:space="preserve">
          <source>Surface.get_clip()</source>
          <target state="translated">Surface.get_clip()</target>
        </trans-unit>
        <trans-unit id="f10727918986fcfe4d38886c1a70b290772b61fb" translate="yes" xml:space="preserve">
          <source>Surface.get_colorkey()</source>
          <target state="translated">Surface.get_colorkey()</target>
        </trans-unit>
        <trans-unit id="65e3f5db8bf3d8931504678d51be401a4b84d8a2" translate="yes" xml:space="preserve">
          <source>Surface.get_flags()</source>
          <target state="translated">Surface.get_flags()</target>
        </trans-unit>
        <trans-unit id="f80a5feb168198fbe72dd738539b7da5d28fa89d" translate="yes" xml:space="preserve">
          <source>Surface.get_height()</source>
          <target state="translated">Surface.get_height()</target>
        </trans-unit>
        <trans-unit id="dbe4ae6cd537da45e78bca3d28f921cf51b21ff2" translate="yes" xml:space="preserve">
          <source>Surface.get_locked()</source>
          <target state="translated">Surface.get_locked()</target>
        </trans-unit>
        <trans-unit id="776fcdfe1c081b032f771f48341a8820ca4df31a" translate="yes" xml:space="preserve">
          <source>Surface.get_locks()</source>
          <target state="translated">Surface.get_locks()</target>
        </trans-unit>
        <trans-unit id="096122e855b1b408da69ec0c54c931757e784ccd" translate="yes" xml:space="preserve">
          <source>Surface.get_losses()</source>
          <target state="translated">Surface.get_losses()</target>
        </trans-unit>
        <trans-unit id="1bcedc232cfc8921f73e9a15f5a3527603cc8902" translate="yes" xml:space="preserve">
          <source>Surface.get_masks()</source>
          <target state="translated">Surface.get_masks()</target>
        </trans-unit>
        <trans-unit id="ad77a3b4f633ae9df95c2f1564e388c8bf40a015" translate="yes" xml:space="preserve">
          <source>Surface.get_offset()</source>
          <target state="translated">Surface.get_offset()</target>
        </trans-unit>
        <trans-unit id="09403a89e13e4c357c0e631538b97f5807feebee" translate="yes" xml:space="preserve">
          <source>Surface.get_palette()</source>
          <target state="translated">Surface.get_palette()</target>
        </trans-unit>
        <trans-unit id="10197bba86ae769361d4c3ff79d2e402fd53ff45" translate="yes" xml:space="preserve">
          <source>Surface.get_palette_at()</source>
          <target state="translated">Surface.get_palette_at()</target>
        </trans-unit>
        <trans-unit id="f34df226dc6db69662ce62ffdac2a1b0a50d9992" translate="yes" xml:space="preserve">
          <source>Surface.get_parent()</source>
          <target state="translated">Surface.get_parent()</target>
        </trans-unit>
        <trans-unit id="8bf4ef4797d8ab2db3108110a6c43f77f7cae900" translate="yes" xml:space="preserve">
          <source>Surface.get_pitch()</source>
          <target state="translated">Surface.get_pitch()</target>
        </trans-unit>
        <trans-unit id="333ae7e4db3b69c95c73c760dde360a1084cc369" translate="yes" xml:space="preserve">
          <source>Surface.get_rect()</source>
          <target state="translated">Surface.get_rect()</target>
        </trans-unit>
        <trans-unit id="c897385af14dc9a925b8e4696ed21b1c843f5db0" translate="yes" xml:space="preserve">
          <source>Surface.get_shifts()</source>
          <target state="translated">Surface.get_shifts()</target>
        </trans-unit>
        <trans-unit id="1113d5b7bb52e084d22ef10209d923c03595fecf" translate="yes" xml:space="preserve">
          <source>Surface.get_size()</source>
          <target state="translated">Surface.get_size()</target>
        </trans-unit>
        <trans-unit id="ef9c23733ce4b112b248210368104afd4c2decc2" translate="yes" xml:space="preserve">
          <source>Surface.get_view()</source>
          <target state="translated">Surface.get_view()</target>
        </trans-unit>
        <trans-unit id="681b3a9b9ed9ca16e4202262a7bc5c224bd49793" translate="yes" xml:space="preserve">
          <source>Surface.get_width()</source>
          <target state="translated">Surface.get_width()</target>
        </trans-unit>
        <trans-unit id="f2419d3ddc63a59e96cb9441eb088371d545f8fa" translate="yes" xml:space="preserve">
          <source>Surface.lock()</source>
          <target state="translated">Surface.lock()</target>
        </trans-unit>
        <trans-unit id="fa49d3d5199b602d4d1d9d1a699bafc9a3f59cbe" translate="yes" xml:space="preserve">
          <source>Surface.map_rgb()</source>
          <target state="translated">Surface.map_rgb()</target>
        </trans-unit>
        <trans-unit id="dc035553d201e4b63b858a970a67125f230bf492" translate="yes" xml:space="preserve">
          <source>Surface.mustlock()</source>
          <target state="translated">Surface.mustlock()</target>
        </trans-unit>
        <trans-unit id="96f95a389bb4c01eaac234a3177d64be325a1253" translate="yes" xml:space="preserve">
          <source>Surface.scroll()</source>
          <target state="translated">Surface.scroll()</target>
        </trans-unit>
        <trans-unit id="e53b6eb6664356ea904858cb276a06bfe28aafbd" translate="yes" xml:space="preserve">
          <source>Surface.set_alpha()</source>
          <target state="translated">Surface.set_alpha()</target>
        </trans-unit>
        <trans-unit id="68e4d5355d335fe8e63a6800ec856072df4d61ef" translate="yes" xml:space="preserve">
          <source>Surface.set_at()</source>
          <target state="translated">Surface.set_at()</target>
        </trans-unit>
        <trans-unit id="baad6f6905cbfa1897136a800da4410e3a5067e2" translate="yes" xml:space="preserve">
          <source>Surface.set_clip()</source>
          <target state="translated">Surface.set_clip()</target>
        </trans-unit>
        <trans-unit id="feb6288f14c13d6b19c027b17de7846b3029f226" translate="yes" xml:space="preserve">
          <source>Surface.set_colorkey()</source>
          <target state="translated">Surface.set_colorkey()</target>
        </trans-unit>
        <trans-unit id="408bb2363f67f820a38d9dd162c0169a5a0d5951" translate="yes" xml:space="preserve">
          <source>Surface.set_masks()</source>
          <target state="translated">Surface.set_masks()</target>
        </trans-unit>
        <trans-unit id="e0d6c1ac87f1ba5b1515aa1bab53c3c5397ee1ee" translate="yes" xml:space="preserve">
          <source>Surface.set_palette()</source>
          <target state="translated">Surface.set_palette()</target>
        </trans-unit>
        <trans-unit id="ff37f362dae70310bb2dbb538a5d25b2924056fa" translate="yes" xml:space="preserve">
          <source>Surface.set_palette_at()</source>
          <target state="translated">Surface.set_palette_at()</target>
        </trans-unit>
        <trans-unit id="ee1a1dd308435c7521cb681c766d1098e2f5b3c0" translate="yes" xml:space="preserve">
          <source>Surface.set_shifts()</source>
          <target state="translated">Surface.set_shifts()</target>
        </trans-unit>
        <trans-unit id="c3cc7fc7a470e2ceaec4d1e4ddd2c0f3622aeef5" translate="yes" xml:space="preserve">
          <source>Surface.subsurface()</source>
          <target state="translated">Surface.subsurface()</target>
        </trans-unit>
        <trans-unit id="db684479e960bc776c78130817242949707e3c09" translate="yes" xml:space="preserve">
          <source>Surface.unlock()</source>
          <target state="translated">Surface.unlock()</target>
        </trans-unit>
        <trans-unit id="2fd81a6e9d1d57696e3e8affc3885d16ded525a5" translate="yes" xml:space="preserve">
          <source>Surface.unmap_rgb()</source>
          <target state="translated">Surface.unmap_rgb()</target>
        </trans-unit>
        <trans-unit id="28028ac1abcca8a132028eb678df604c1b3d9db5" translate="yes" xml:space="preserve">
          <source>Surfaces can also reference sections of other Surfaces. These are created with the &lt;a href=&quot;#pygame.Surface.subsurface&quot;&gt;&lt;code&gt;subsurface()&lt;/code&gt;&lt;/a&gt; method. Any change to either Surface will effect the other.</source>
          <target state="translated">표면은 다른 표면의 섹션을 참조 할 수도 있습니다. 이들은 &lt;a href=&quot;#pygame.Surface.subsurface&quot;&gt; &lt;code&gt;subsurface()&lt;/code&gt; &lt;/a&gt; 메소드 로 작성됩니다 . 두 Surface 중 하나를 변경하면 다른 Surface에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="a52cd3fbb4c197ed9fca961ee72ea2e3312886eb" translate="yes" xml:space="preserve">
          <source>Surfaces can have many extra attributes like alpha planes, colorkeys, source rectangle clipping. These functions mainly effect how the Surface is blitted to other Surfaces. The blit routines will attempt to use hardware acceleration when possible, otherwise they will use highly optimized software blitting methods.</source>
          <target state="translated">표면에는 알파 평면, 색상 키, 소스 사각형 클리핑과 같은 많은 추가 속성이있을 수 있습니다. 이러한 기능은 주로 Surface가 다른 Surface에 어떻게 블리 팅되는지에 영향을줍니다. 블리트 루틴은 가능한 경우 하드웨어 가속을 사용하려고 시도하고 그렇지 않으면 고도로 최적화 된 소프트웨어 블리 팅 방법을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="35285afc18b9cd56f18c1136cd4c7f86049930bf" translate="yes" xml:space="preserve">
          <source>Surfaces should not remain locked for more than necessary. A locked Surface can often not be displayed or managed by pygame.</source>
          <target state="translated">표면이 필요 이상으로 잠겨져 있으면 안됩니다. 잠긴 Surface는 종종 파이 게임에서 표시하거나 관리 할 수 ​​없습니다.</target>
        </trans-unit>
        <trans-unit id="eeb71db3b87b4858c54869111081aadd508f1cc3" translate="yes" xml:space="preserve">
          <source>Switch between fullscreen and windowed displays</source>
          <target state="translated">전체 화면과 창 디스플레이 간 전환</target>
        </trans-unit>
        <trans-unit id="3f139291efcc93744313c9d76fb34536081a4bf0" translate="yes" xml:space="preserve">
          <source>Switches the display window between windowed and fullscreen modes. This function only works under the UNIX X11 video driver. For most situations it is better to call &lt;code&gt;pygame.display.set_mode()&lt;/code&gt; with new display flags.</source>
          <target state="translated">디스플레이 창을 창 모드와 전체 화면 모드 사이에서 전환합니다. 이 기능은 UNIX X11 비디오 드라이버에서만 작동합니다. 대부분의 상황 에서 새로운 표시 플래그를 사용하여 &lt;code&gt;pygame.display.set_mode()&lt;/code&gt; 를 호출하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="4dcce486de303a7861e33e41ce56e25e63840572" translate="yes" xml:space="preserve">
          <source>Takes a sequence of midi events and returns list of pygame events.</source>
          <target state="translated">일련의 미디 이벤트를 가져와 파이 게임 이벤트 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0b8c82621fd3ebeb069ba08fd01f5eb20425c6f5" translate="yes" xml:space="preserve">
          <source>Takes a sequence of surfaces and returns a surface with average colors from each of the surfaces.</source>
          <target state="translated">일련의 표면을 가져 와서 각 표면에서 평균 색상의 표면을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="838c6ecd496a4b16223593c8405218ab4e1d6f08" translate="yes" xml:space="preserve">
          <source>Temporarily stop audio playback on the &lt;code&gt;CD&lt;/code&gt;. The playback can be resumed at the same point with the &lt;code&gt;CD.resume()&lt;/code&gt; method. If the &lt;code&gt;CD&lt;/code&gt; is not playing this method does nothing.</source>
          <target state="translated">&lt;code&gt;CD&lt;/code&gt; 에서 오디오 재생을 일시적으로 중지합니다 . &lt;code&gt;CD.resume()&lt;/code&gt; 메소드 를 사용하여 같은 시점에서 재생을 다시 시작할 수 있습니다 . 경우 &lt;code&gt;CD&lt;/code&gt; 는 이 방법이 재생되지 않는 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1a2fa15ff3759dc5009ddb345260f8a63359ba43" translate="yes" xml:space="preserve">
          <source>Temporarily stop playback of the music stream. It can be resumed with the &lt;code&gt;pygame.mixer.music.unpause()&lt;/code&gt; function.</source>
          <target state="translated">음악 스트림 재생을 일시적으로 중지합니다. &lt;code&gt;pygame.mixer.music.unpause()&lt;/code&gt; 함수 로 다시 시작할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="57ff428ec96c2d3da8848188e3449a25a8437733" translate="yes" xml:space="preserve">
          <source>Temporarily stop the playback of sound on a channel. It can be resumed at a later time with &lt;code&gt;Channel.unpause()&lt;/code&gt;</source>
          <target state="translated">채널에서 사운드 재생을 일시적으로 중지합니다. &lt;code&gt;Channel.unpause()&lt;/code&gt; 를 사용하여 나중에 다시 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="118e497e172fa9c5167e76315faf7e7e6bc14153" translate="yes" xml:space="preserve">
          <source>Test if the &lt;code&gt;pygame.joystick.init()&lt;/code&gt; function has been called.</source>
          <target state="translated">&lt;code&gt;pygame.joystick.init()&lt;/code&gt; 함수가 호출되었는지 테스트하십시오 .</target>
        </trans-unit>
        <trans-unit id="4b346d87f5a7cacd11616284270e74b6f7348477" translate="yes" xml:space="preserve">
          <source>Test if the cdrom module is initialized or not. This is different than the &lt;code&gt;CD.init()&lt;/code&gt; since each drive must also be initialized individually.</source>
          <target state="translated">cdrom 모듈이 초기화되었는지 테스트하십시오. 각 드라이브도 개별적으로 초기화해야하므로 &lt;code&gt;CD.init()&lt;/code&gt; 와 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="0f36cd13a58eabd7f901827413cec701c2362c1f" translate="yes" xml:space="preserve">
          <source>Test if the font module is initialized or not.</source>
          <target state="translated">글꼴 모듈이 초기화되었는지 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="dfa2defec0f898975d785529f98fb2e219ef796d" translate="yes" xml:space="preserve">
          <source>Test if this &lt;code&gt;CDROM&lt;/code&gt; device is initialized. This is different than the &lt;code&gt;pygame.cdrom.init()&lt;/code&gt; since each drive must also be initialized individually.</source>
          <target state="translated">이 &lt;code&gt;CDROM&lt;/code&gt; 장치가 초기화 되었는지 테스트하십시오 . 각 드라이브도 개별적으로 초기화해야하므로 &lt;code&gt;pygame.cdrom.init()&lt;/code&gt; 와 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="cf05d2ac14477c53947a47f5cb0e1922e4dfce85" translate="yes" xml:space="preserve">
          <source>Test whether the rectangle collides with any in a sequence of rectangles. The index of the first collision found is returned. If no collisions are found an index of -1 is returned.</source>
          <target state="translated">사각형이 일련의 사각형과 충돌하는지 테스트합니다. 발견 된 첫 번째 충돌 색인이 리턴됩니다. 충돌이 없으면 인덱스 -1이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="19e997ac9d15ed27129faae262cd4e8b6b9f6683" translate="yes" xml:space="preserve">
          <source>Tested on Windows XP SP2 Athlon, and FreeBSD.</source>
          <target state="translated">Windows XP SP2 Athlon 및 FreeBSD에서 테스트되었습니다.</target>
        </trans-unit>
        <trans-unit id="0736c7415a483c3fe36dc31432735b0a3fc834a2" translate="yes" xml:space="preserve">
          <source>Tests are run in a randomized order if the randomize argument is True or a seed argument is provided. If no seed integer is provided then the system time is used.</source>
          <target state="translated">randomize 인수가 True이거나 seed 인수가 제공된 경우 테스트는 무작위 순서로 실행됩니다. 시드 정수가 제공되지 않으면 시스템 시간이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d9fd8fe70b3335b0501f5bd1069db29573fcaea1" translate="yes" xml:space="preserve">
          <source>Tests for collision between two sprites, by testing if their bitmasks overlap. If the sprites have a &quot;mask&quot; attribute, that is used as the mask, otherwise a mask is created from the sprite image. Intended to be passed as a collided callback function to the *collide functions. Sprites must have a &quot;rect&quot; and an optional &quot;mask&quot; attribute.</source>
          <target state="translated">비트 마스크가 겹치는 지 테스트하여 두 스프라이트 간의 충돌을 테스트합니다. 스프라이트에 &quot;마스크&quot;속성이 있으면 마스크로 사용되며, 그렇지 않으면 스프라이트 이미지에서 마스크가 생성됩니다. 충돌 콜백 함수로 * collide 함수에 전달되었습니다. 스프라이트에는 &quot;rect&quot;및 선택적인 &quot;mask&quot;속성이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="6bdc1be0a258b007dc02dc19431927738c5e13b9" translate="yes" xml:space="preserve">
          <source>Tests for collision between two sprites, by testing to see if two circles centered on the sprites overlap. If the sprites have a &quot;radius&quot; attribute, that is used to create the circle, otherwise a circle is created that is big enough to completely enclose the sprites rect as given by the &quot;rect&quot; attribute. Intended to be passed as a collided callback function to the *collide functions. Sprites must have a &quot;rect&quot; and an optional &quot;radius&quot; attribute.</source>
          <target state="translated">스프라이트 중심의 두 원이 겹치는 지 테스트하여 두 스프라이트 간의 충돌을 테스트합니다. 스프라이트에 원을 만드는 데 사용되는 &quot;반지름&quot;속성이있는 경우 &quot;rect&quot;속성에 지정된대로 스프라이트 rect를 완전히 둘러싸기에 충분한 원이 만들어집니다. 충돌 콜백 함수로 * collide 함수에 전달되었습니다. 스프라이트에는 &quot;rect&quot;및 선택적인 &quot;radius&quot;속성이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="afa8f70d9d75b033735222276b897d3452c4b294" translate="yes" xml:space="preserve">
          <source>Tests for collision between two sprites. Uses the pygame rect colliderect function to calculate the collision. Intended to be passed as a collided callback function to the *collide functions. Sprites must have a &quot;rect&quot; attributes.</source>
          <target state="translated">두 스프라이트 간의 충돌을 테스트합니다. 파이 게임 rect colliderect 함수를 사용하여 충돌을 계산합니다. 충돌 콜백 함수로 * collide 함수에 전달되었습니다. 스프라이트에는 &quot;rect&quot;속성이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="ebcead4996ea99dbb38dd2535b272d2c7e18ef66" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;display#module-pygame.display&quot;&gt;&lt;code&gt;pygame.display&lt;/code&gt;&lt;/a&gt; module contains flags like &lt;code&gt;HWSURFACE&lt;/code&gt; used by &lt;a href=&quot;display#pygame.display.set_mode&quot;&gt;&lt;code&gt;pygame.display.set_mode()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;display#module-pygame.display&quot;&gt; &lt;code&gt;pygame.display&lt;/code&gt; 의&lt;/a&gt; 모듈은 같은 플래그를 포함 &lt;code&gt;HWSURFACE&lt;/code&gt; 가 에서 사용 &lt;a href=&quot;display#pygame.display.set_mode&quot;&gt; &lt;code&gt;pygame.display.set_mode()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fe7b3b2ac46fba0ce68ee50100bc32936037e158" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;event#module-pygame.event&quot;&gt;&lt;code&gt;pygame.event&lt;/code&gt;&lt;/a&gt; module contains the various event types.</source>
          <target state="translated">&lt;a href=&quot;event#module-pygame.event&quot;&gt; &lt;code&gt;pygame.event&lt;/code&gt; 의&lt;/a&gt; 모듈은 다양한 이벤트 유형이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="588a196ff36fe9fcad1c039b5493431645af12b2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;key#module-pygame.key&quot;&gt;&lt;code&gt;pygame.key&lt;/code&gt;&lt;/a&gt; module lists the keyboard constants and modifiers (&lt;code&gt;K_&lt;/code&gt;* and &lt;code&gt;MOD_&lt;/code&gt;*) relating to the &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;mod&lt;/code&gt; attributes of the &lt;code&gt;KEYDOWN&lt;/code&gt; and &lt;code&gt;KEYUP&lt;/code&gt; events.</source>
          <target state="translated">&lt;a href=&quot;key#module-pygame.key&quot;&gt; &lt;code&gt;pygame.key&lt;/code&gt; 의&lt;/a&gt; 모듈 목록 키보드 상수와 수식 ( &lt;code&gt;K_&lt;/code&gt; * 및 &lt;code&gt;MOD_&lt;/code&gt; *)에 관련된 &lt;code&gt;key&lt;/code&gt; 와 &lt;code&gt;mod&lt;/code&gt; 의 속성 &lt;code&gt;KEYDOWN&lt;/code&gt; 과 &lt;code&gt;KEYUP&lt;/code&gt; 이벤트.</target>
        </trans-unit>
        <trans-unit id="653902c12de99f9c897405f0288c3c1aee906fa2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;surface#pygame.Surface&quot;&gt;&lt;code&gt;Surface&lt;/code&gt;&lt;/a&gt; which returned the &lt;a href=&quot;#pygame.BufferProxy&quot;&gt;&lt;code&gt;BufferProxy&lt;/code&gt;&lt;/a&gt; object or the object passed to a &lt;a href=&quot;#pygame.BufferProxy&quot;&gt;&lt;code&gt;BufferProxy&lt;/code&gt;&lt;/a&gt; call.</source>
          <target state="translated">&lt;a href=&quot;surface#pygame.Surface&quot;&gt; &lt;code&gt;Surface&lt;/code&gt; &lt;/a&gt; 반환 &lt;a href=&quot;#pygame.BufferProxy&quot;&gt; &lt;code&gt;BufferProxy&lt;/code&gt; 의&lt;/a&gt; 객체 또는 전달 된 객체 &lt;a href=&quot;#pygame.BufferProxy&quot;&gt; &lt;code&gt;BufferProxy&lt;/code&gt; 의&lt;/a&gt; 전화를.</target>
        </trans-unit>
        <trans-unit id="eeeaebdb112125c126441f92f344a49957e05f31" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;surface#pygame.Surface.fill&quot;&gt;&lt;code&gt;pygame.Surface.fill()&lt;/code&gt;&lt;/a&gt; method works just as well for drawing filled rectangles and can be hardware accelerated on some platforms with both software and hardware display modes.</source>
          <target state="translated">&lt;a href=&quot;surface#pygame.Surface.fill&quot;&gt; &lt;code&gt;pygame.Surface.fill()&lt;/code&gt; &lt;/a&gt; 메소드는 채워진 사각형을 그리는 단지뿐만 아니라 작동하고 모두 소프트웨어 및 하드웨어 디스플레이 모드 일부 플랫폼에서 하드웨어 가속이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8fa079c574e96771ca208572c54b25b7f83d59d3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;time#module-pygame.time&quot;&gt;&lt;code&gt;pygame.time&lt;/code&gt;&lt;/a&gt; module defines &lt;code&gt;TIMER_RESOLUTION&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;time#module-pygame.time&quot;&gt; &lt;code&gt;pygame.time&lt;/code&gt; 의&lt;/a&gt; 모듈을 정의 &lt;code&gt;TIMER_RESOLUTION&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="fd06a2da59c4376a72c94dc7b9d20f2d06ab9f0c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CD&lt;/code&gt; object is not initialized, you can only call &lt;code&gt;CD.get_id()&lt;/code&gt; and &lt;code&gt;CD.get_name()&lt;/code&gt; on an uninitialized drive.</source>
          <target state="translated">&lt;code&gt;CD&lt;/code&gt; 의 객체 만 호출 할 수 있습니다, 초기화되지 않습니다 &lt;code&gt;CD.get_id()&lt;/code&gt; 와 &lt;code&gt;CD.get_name()&lt;/code&gt; 초기화되지 않은 드라이브에.</target>
        </trans-unit>
        <trans-unit id="b741578f7251b33e653fdeecee16432688a115db" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CMY&lt;/code&gt; representation of the Color. The &lt;code&gt;CMY&lt;/code&gt; components are in the ranges &lt;code&gt;C&lt;/code&gt; = [0, 1], &lt;code&gt;M&lt;/code&gt; = [0, 1], &lt;code&gt;Y&lt;/code&gt; = [0, 1]. Note that this will not return the absolutely exact &lt;code&gt;CMY&lt;/code&gt; values for the set &lt;code&gt;RGB&lt;/code&gt; values in all cases. Due to the &lt;code&gt;RGB&lt;/code&gt; mapping from 0-255 and the &lt;code&gt;CMY&lt;/code&gt; mapping from 0-1 rounding errors may cause the &lt;code&gt;CMY&lt;/code&gt; values to differ slightly from what you might expect.</source>
          <target state="translated">색상 의 &lt;code&gt;CMY&lt;/code&gt; 표현입니다. &lt;code&gt;CMY&lt;/code&gt; 의 성분이이 범위에있는 &lt;code&gt;C&lt;/code&gt; = 0, 1, &lt;code&gt;M&lt;/code&gt; = [0, 1] &lt;code&gt;Y&lt;/code&gt; = [0, 1]. 모든 경우에 설정된 &lt;code&gt;RGB&lt;/code&gt; 값에 대해 절대적으로 정확한 &lt;code&gt;CMY&lt;/code&gt; 값을 반환하지는 않습니다 . &lt;code&gt;RGB&lt;/code&gt; 로 인해 0-255 매핑과 0-1 반올림 오류 의 &lt;code&gt;CMY&lt;/code&gt; 매핑으로 인해 &lt;code&gt;CMY&lt;/code&gt; 값이 예상과 약간 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f01ee4c3ac292bdf8998b3d48e3430ecb4ca1d17" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Color&lt;/code&gt; class represents &lt;code&gt;RGBA&lt;/code&gt; color values using a value range of 0 to 255 inclusive. It allows basic arithmetic operations &amp;mdash; binary operations &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;//&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, and unary operation &lt;code&gt;~&lt;/code&gt; &amp;mdash; to create new colors, supports conversions to other color spaces such as &lt;code&gt;HSV&lt;/code&gt; or &lt;code&gt;HSL&lt;/code&gt; and lets you adjust single color channels. Alpha defaults to 255 (fully opaque) when not given. The arithmetic operations and &lt;code&gt;correct_gamma()&lt;/code&gt; method preserve subclasses. For the binary operators, the class of the returned color is that of the left hand color object of the operator.</source>
          <target state="translated">&lt;code&gt;Color&lt;/code&gt; 클래스 나타내는 &lt;code&gt;RGBA&lt;/code&gt; 의 0 ~ 255의 값을 포함 범위를 사용하여 컬러 값. 기본 산술 연산-이진 연산 &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;//&lt;/code&gt; , &lt;code&gt;%&lt;/code&gt; 및 단항 연산 &lt;code&gt;~&lt;/code&gt; 을 통해 새 색상을 만들 거나 &lt;code&gt;HSV&lt;/code&gt; 또는 다른 색상 공간으로의 변환을 지원합니다. &lt;code&gt;HSL&lt;/code&gt; 과 단일 색상 채널을 조정할 수 있습니다. 지정하지 않으면 알파의 기본값은 255 (완전히 불투명)입니다. 산술 연산과 &lt;code&gt;correct_gamma()&lt;/code&gt; 메소드는 서브 클래스를 보존합니다. 이진 연산자의 경우 반환되는 색의 클래스는 연산자의 왼쪽 색 개체의 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="4d69d8b1c0942df726c578ebc917a458e49eabdf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HSLA&lt;/code&gt; representation of the Color. The &lt;code&gt;HSLA&lt;/code&gt; components are in the ranges &lt;code&gt;H&lt;/code&gt; = [0, 360], &lt;code&gt;S&lt;/code&gt; = [0, 100], &lt;code&gt;V&lt;/code&gt; = [0, 100], A = [0, 100]. Note that this will not return the absolutely exact &lt;code&gt;HSL&lt;/code&gt; values for the set &lt;code&gt;RGB&lt;/code&gt; values in all cases. Due to the &lt;code&gt;RGB&lt;/code&gt; mapping from 0-255 and the &lt;code&gt;HSL&lt;/code&gt; mapping from 0-100 and 0-360 rounding errors may cause the &lt;code&gt;HSL&lt;/code&gt; values to differ slightly from what you might expect.</source>
          <target state="translated">색상 의 &lt;code&gt;HSLA&lt;/code&gt; 표현입니다. &lt;code&gt;HSLA&lt;/code&gt; 의 성분이이 범위에있는 &lt;code&gt;H&lt;/code&gt; = [0, 360], &lt;code&gt;S&lt;/code&gt; =을 [0, 100], &lt;code&gt;V&lt;/code&gt; = [0, 100], A = [0, 100]. 모든 경우에 설정된 &lt;code&gt;RGB&lt;/code&gt; 값에 대해 절대적으로 정확한 &lt;code&gt;HSL&lt;/code&gt; 값을 반환하지는 않습니다 . 인해 &lt;code&gt;RGB&lt;/code&gt; 0-255 RGB 매핑 &lt;code&gt;HSL&lt;/code&gt; 0-100 및 0-360 HSL 매핑 오류로 인해 &lt;code&gt;HSL&lt;/code&gt; 값이 예상과 약간 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a9d499e63af834109b4a7ef273b6175fe2b74bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HSVA&lt;/code&gt; representation of the Color. The &lt;code&gt;HSVA&lt;/code&gt; components are in the ranges &lt;code&gt;H&lt;/code&gt; = [0, 360], &lt;code&gt;S&lt;/code&gt; = [0, 100], &lt;code&gt;V&lt;/code&gt; = [0, 100], A = [0, 100]. Note that this will not return the absolutely exact &lt;code&gt;HSV&lt;/code&gt; values for the set &lt;code&gt;RGB&lt;/code&gt; values in all cases. Due to the &lt;code&gt;RGB&lt;/code&gt; mapping from 0-255 and the &lt;code&gt;HSV&lt;/code&gt; mapping from 0-100 and 0-360 rounding errors may cause the &lt;code&gt;HSV&lt;/code&gt; values to differ slightly from what you might expect.</source>
          <target state="translated">색상 의 &lt;code&gt;HSVA&lt;/code&gt; 표현입니다. &lt;code&gt;HSVA&lt;/code&gt; 의 성분이이 범위에있는 &lt;code&gt;H&lt;/code&gt; = [0, 360], &lt;code&gt;S&lt;/code&gt; =을 [0, 100], &lt;code&gt;V&lt;/code&gt; = [0, 100], A = [0, 100]. 모든 경우에 설정된 &lt;code&gt;RGB&lt;/code&gt; 값에 대해 절대적으로 정확한 &lt;code&gt;HSV&lt;/code&gt; 값을 반환하지는 않습니다 . 인해 &lt;code&gt;RGB&lt;/code&gt; 0-255 RGB 매핑과 0-100 및 0-360 의 &lt;code&gt;HSV&lt;/code&gt; 매핑 오류로 인해 &lt;code&gt;HSV&lt;/code&gt; 값이 예상과 약간 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="29c6f75b4ab834f821220344e3710f482c0ebd61" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;I1I2I3&lt;/code&gt; representation of the Color. The &lt;code&gt;I1I2I3&lt;/code&gt; components are in the ranges &lt;code&gt;I1&lt;/code&gt; = [0, 1], &lt;code&gt;I2&lt;/code&gt; = [-0.5, 0.5], &lt;code&gt;I3&lt;/code&gt; = [-0.5, 0.5]. Note that this will not return the absolutely exact &lt;code&gt;I1I2I3&lt;/code&gt; values for the set &lt;code&gt;RGB&lt;/code&gt; values in all cases. Due to the &lt;code&gt;RGB&lt;/code&gt; mapping from 0-255 and the &lt;code&gt;I1I2I3&lt;/code&gt; mapping from 0-1 rounding errors may cause the &lt;code&gt;I1I2I3&lt;/code&gt; values to differ slightly from what you might expect.</source>
          <target state="translated">색상 의 &lt;code&gt;I1I2I3&lt;/code&gt; 표현입니다. &lt;code&gt;I1I2I3&lt;/code&gt; 성분 범위에 &lt;code&gt;I1&lt;/code&gt; = [0, 1], &lt;code&gt;I2&lt;/code&gt; = [-0.5, 0.5], &lt;code&gt;I3&lt;/code&gt; = [-0.5, 0.5]. 모든 경우에 설정된 &lt;code&gt;RGB&lt;/code&gt; 값에 대해 절대적으로 정확한 &lt;code&gt;I1I2I3&lt;/code&gt; 값을 반환하지는 않습니다 . 0-255 의 &lt;code&gt;RGB&lt;/code&gt; 매핑과 0-1 반올림 오류 의 &lt;code&gt;I1I2I3&lt;/code&gt; 매핑으로 인해 &lt;code&gt;I1I2I3&lt;/code&gt; 값이 예상과 약간 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b05b44d1f74253505326687cdccaf2d5ef71cb98" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OPENGL&lt;/code&gt; flags are:</source>
          <target state="translated">&lt;code&gt;OPENGL&lt;/code&gt; 플래그는 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="cb36be5793ec962901fb530a98bb27a6e2676ef6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;STYLE_OBLIQUE&lt;/code&gt; and &lt;code&gt;STYLE_STRONG&lt;/code&gt; styles are for scalable fonts only. An attempt to set either for a bitmap font raises an AttributeError. An attempt to set either for an inactive font, as returned by &lt;code&gt;Font.__new__()&lt;/code&gt;, raises a RuntimeError.</source>
          <target state="translated">&lt;code&gt;STYLE_OBLIQUE&lt;/code&gt; 및 &lt;code&gt;STYLE_STRONG&lt;/code&gt; 스타일은 확장 가능한 글꼴 만 제공됩니다. 비트 맵 글꼴을 설정하려고하면 AttributeError가 발생합니다. &lt;code&gt;Font.__new__()&lt;/code&gt; 에서 반환 한 비활성 글꼴을 설정하려고 하면 RuntimeError가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fb14d3d2e1f9a52db17e4abb0986f12629b911f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;arraytype&lt;/code&gt; parameter is deprecated; passing any value besides 'numpy' will raise ValueError.</source>
          <target state="translated">그만큼 &lt;code&gt;arraytype&lt;/code&gt; 의 매개 변수는 사용되지 않습니다; 'numpy'이외의 값을 전달하면 ValueError가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b97390dfd8b7a8a692c7d462b45695888c8ba5eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;buffer_size&lt;/code&gt; specifies the number of output events to be buffered waiting for output. In some cases (see below) PortMidi does not buffer output at all and merely passes data to a lower-level API, in which case buffersize is ignored.</source>
          <target state="translated">그만큼 &lt;code&gt;buffer_size&lt;/code&gt; 지정은 출력 이벤트의 수는 출력을 기다리고 버퍼링합니다. 경우에 따라 (아래 참조) PortMidi는 출력을 전혀 버퍼링하지 않고 하위 레벨 API로 데이터를 전달합니다.이 경우 버퍼 크기가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="f2cdc4c8411e094e173c93d50b2a4bce373add50" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;every&lt;/code&gt; optional parameter skips set bits in the outline. For example, setting it to 10 would return a list of every 10th set bit in the outline.</source>
          <target state="translated">그만큼 &lt;code&gt;every&lt;/code&gt; 선택적 파라미터 스킵 윤곽에 비트를 설정. 예를 들어, 10으로 설정하면 개요에서 10 번째 세트 비트마다 목록이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="63ce71ccebe1baab80bb8abd0b218269f609f47e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pygame.JOYAXISMOTION&lt;/code&gt; events will be in the range from -1.0 to 1.0. A value of 0.0 means the axis is centered. Gamepad devices will usually be -1, 0, or 1 with no values in between. Older analog joystick axes will not always use the full -1 to 1 range, and the centered value will be some area around 0. Analog joysticks usually have a bit of noise in their axis, which will generate a lot of rapid small motion events.</source>
          <target state="translated">그만큼 &lt;code&gt;pygame.JOYAXISMOTION&lt;/code&gt; 의 이벤트는 -1.0에서 1.0의 범위에있을 것입니다. 값이 0.0이면 축이 중앙에 있음을 의미합니다. 게임 패드 장치는 일반적으로 -1, 0 또는 1 사이에 값이 없습니다. 구형 아날로그 조이스틱 축이 항상 -1에서 1까지의 전체 범위를 사용하는 것은 아니며 중심 값은 0 부근의 일부 영역입니다.</target>
        </trans-unit>
        <trans-unit id="509464bccf93f78b790ab07cfa88f6454c4dc1e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pygame.JOYBALLMOTION&lt;/code&gt; event will be sent when the trackball is rolled. It will report the amount of movement on the trackball.</source>
          <target state="translated">그만큼 &lt;code&gt;pygame.JOYBALLMOTION&lt;/code&gt; 의 트랙볼을 압연 할 때 이벤트가 전송됩니다. 트랙볼의 이동량을보고합니다.</target>
        </trans-unit>
        <trans-unit id="e6baf86c9195177b32c223e98ba4f70c4f7fabc2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pygame.JOYHATMOTION&lt;/code&gt; event is generated when the hat changes position. The position attribute for the event contains a pair of values that are either -1, 0, or 1. A position of (0, 0) means the hat is centered.</source>
          <target state="translated">그만큼 &lt;code&gt;pygame.JOYHATMOTION&lt;/code&gt; 의 모자의 위치가 변경 될 때 이벤트가 생성된다. 이벤트의 위치 속성에는 -1, 0 또는 1 인 값 쌍이 포함됩니다. (0, 0)의 위치는 모자가 중앙에 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="9fcd57a94c891863dbe25c2d375a5f28cadb77e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pygame.KEYDOWN&lt;/code&gt; event has additional attributes &lt;code&gt;unicode&lt;/code&gt; and &lt;code&gt;scancode&lt;/code&gt;. &lt;code&gt;unicode&lt;/code&gt; represents a single character string that is the fully translated character entered. This takes into account the shift and composition keys. &lt;code&gt;scancode&lt;/code&gt; represents the platform-specific key code. This could be different from keyboard to keyboard, but is useful for key selection of weird keys like the multimedia keys.</source>
          <target state="translated">&lt;code&gt;pygame.KEYDOWN&lt;/code&gt; 의 이벤트는 추가 속성을 가지고 &lt;code&gt;unicode&lt;/code&gt; 및 &lt;code&gt;scancode&lt;/code&gt; . &lt;code&gt;unicode&lt;/code&gt; 는 완전히 번역 된 문자 인 단일 문자열을 나타냅니다. 이것은 shift 및 composition 키를 고려합니다. &lt;code&gt;scancode&lt;/code&gt; 는 플랫폼 별 키 코드를 나타냅니다. 이것은 키보드마다 다를 수 있지만 멀티미디어 키와 같은 이상한 키의 키 선택에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="e2c6289af66aafdf09b2506b4c795307b20e812c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pygame.freetype&lt;/code&gt; module is a replacement for &lt;a href=&quot;font#module-pygame.font&quot;&gt;&lt;code&gt;pygame.font&lt;/code&gt;&lt;/a&gt;. It has all of the functionality of the original, plus many new features. Yet is has absolutely no dependencies on the SDL_ttf library. It is implemented directly on the FreeType 2 library. The &lt;code&gt;pygame.freetype&lt;/code&gt; module is not itself backward compatible with &lt;a href=&quot;font#module-pygame.font&quot;&gt;&lt;code&gt;pygame.font&lt;/code&gt;&lt;/a&gt;. Instead, use the &lt;code&gt;pygame.ftfont&lt;/code&gt; module as a drop-in replacement for &lt;a href=&quot;font#module-pygame.font&quot;&gt;&lt;code&gt;pygame.font&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pygame.freetype&lt;/code&gt; 의 모듈을 대신 &lt;a href=&quot;font#module-pygame.font&quot;&gt; &lt;code&gt;pygame.font&lt;/code&gt; &lt;/a&gt; . 원본의 모든 기능과 많은 새로운 기능이 있습니다. 그러나 SDL_ttf 라이브러리에 의존하지 않습니다. FreeType 2 라이브러리에서 직접 구현됩니다. &lt;code&gt;pygame.freetype&lt;/code&gt; 의 모듈은 이전 버전과 호환되지 자체 &lt;a href=&quot;font#module-pygame.font&quot;&gt; &lt;code&gt;pygame.font&lt;/code&gt; &lt;/a&gt; . 대신 &lt;code&gt;pygame.ftfont&lt;/code&gt; 모듈을 pygame.font 의 드롭 인 대체품으로 사용 &lt;a href=&quot;font#module-pygame.font&quot;&gt; &lt;code&gt;pygame.font&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="68d9892e7b265646c25dafc2b590bf645a088a5d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pygame.pixelcopy&lt;/code&gt; module contains functions for copying between surfaces and objects exporting an array structure interface. It is a backend for &lt;a href=&quot;surfarray#module-pygame.surfarray&quot;&gt;&lt;code&gt;pygame.surfarray&lt;/code&gt;&lt;/a&gt;, adding NumPy support. But pixelcopy is more general, and intended for direct use.</source>
          <target state="translated">&lt;code&gt;pygame.pixelcopy&lt;/code&gt; 의 모듈 배열 구조 인터페이스를 내보내기 표면과 객체 간의 복사하기위한 기능을 포함한다. NumPy 지원을 추가하여 &lt;a href=&quot;surfarray#module-pygame.surfarray&quot;&gt; &lt;code&gt;pygame.surfarray&lt;/code&gt; &lt;/a&gt; 의 백엔드입니다 . 그러나 픽셀 복사는보다 일반적이며 직접 사용하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="e76bd5bb88487ac6d5dda1d13ee660ddd3f9f9ec" translate="yes" xml:space="preserve">
          <source>The Bayer to &lt;code&gt;RGB&lt;/code&gt; function is based on:</source>
          <target state="translated">바이엘 &lt;code&gt;RGB&lt;/code&gt; 로 기능은 다음을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="e2ea9199853e3921b34ce1ab35df45f99d163c76" translate="yes" xml:space="preserve">
          <source>The BufferProxy class supports subclassing, instance variables, and weak references.</source>
          <target state="translated">BufferProxy 클래스는 서브 클래 싱, 인스턴스 변수 및 약한 참조를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="d73f48f2ae5a0d092af0eb8e7085e00a74776000" translate="yes" xml:space="preserve">
          <source>The Channel object can be used to get fine control over the playback of Sounds. A channel can only playback a single Sound at time. Using channels is entirely optional since pygame can manage them by default.</source>
          <target state="translated">Channel 객체를 사용하여 사운드 재생을 미세하게 제어 할 수 있습니다. 채널은 한 번에 하나의 사운드 만 재생할 수 있습니다. 파이 게임은 기본적으로 채널을 관리 할 수 ​​있으므로 채널 사용은 전적으로 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="ca77a3de38cf5f88bd53a60bed51073721ce104a" translate="yes" xml:space="preserve">
          <source>The Group does not keep sprites in any order, so the draw order is arbitrary.</source>
          <target state="translated">그룹은 스프라이트를 어떤 순서로도 유지하지 않으므로 그리기 순서는 임의적입니다.</target>
        </trans-unit>
        <trans-unit id="008bc7b20623f4dffdace410196b9bc7e0a956f9" translate="yes" xml:space="preserve">
          <source>The GroupSingle container only holds a single Sprite. When a new Sprite is added, the old one is removed.</source>
          <target state="translated">GroupSingle 컨테이너는 단일 Sprite 만 보유합니다. 새로운 Sprite가 추가되면 기존 Sprite가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="dc50ec942b21d232aaa5a87679f8f6717b592423" translate="yes" xml:space="preserve">
          <source>The Joystick must be initialized to get most of the information about the controls. While the Joystick is initialized the pygame event queue will receive events from the Joystick input.</source>
          <target state="translated">컨트롤에 대한 대부분의 정보를 얻으려면 조이스틱을 초기화해야합니다. 조이스틱이 초기화되는 동안 파이 게임 이벤트 큐는 조이스틱 입력으로부터 이벤트를 수신합니다.</target>
        </trans-unit>
        <trans-unit id="8167473ae164886d46a56d3d69b313955158cee6" translate="yes" xml:space="preserve">
          <source>The Joystick object allows you to get information about the types of controls on a joystick device. Once the device is initialized the pygame event queue will start receiving events about its input.</source>
          <target state="translated">조이스틱 객체를 사용하면 조이스틱 장치의 컨트롤 유형에 대한 정보를 얻을 수 있습니다. 장치가 초기화되면 파이 게임 이벤트 큐는 입력에 대한 이벤트를 받기 시작합니다.</target>
        </trans-unit>
        <trans-unit id="4f861167fa87847ee1a4863ff4aa736ffef3b4a4" translate="yes" xml:space="preserve">
          <source>The Mercurial node identifier of the repository checkout from which this package was built. If the identifier ends with a plus sign '+' then the package contains uncommitted changes. Please include this revision number in bug reports, especially for non-release pygame builds.</source>
          <target state="translated">이 패키지가 작성된 저장소 체크 아웃의 Mercurial 노드 ID입니다. 식별자가 더하기 부호 '+'로 끝나면 패키지에 커밋되지 않은 변경 사항이 포함됩니다. 특히 비 릴리스 파이 게임 빌드의 경우 버그 보고서에이 개정 번호를 포함 시키십시오.</target>
        </trans-unit>
        <trans-unit id="3bbd312d7aaa6490e3a4debbe9ead95134437131" translate="yes" xml:space="preserve">
          <source>The Overlay format determines the type of pixel data used. Not all hardware will support all types of overlay formats. Here is a list of available format types:</source>
          <target state="translated">오버레이 형식에 따라 사용되는 픽셀 데이터 유형이 결정됩니다. 모든 하드웨어가 모든 유형의 오버레이 형식을 지원하는 것은 아닙니다. 사용 가능한 형식 유형 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="38ca2d56b301cfac59c2be3e9d72fd058798976e" translate="yes" xml:space="preserve">
          <source>The Overlay objects provide support for accessing hardware video overlays. Video overlays do not use standard &lt;code&gt;RGB&lt;/code&gt; pixel formats, and can use multiple resolutions of data to create a single image.</source>
          <target state="translated">오버레이 객체는 하드웨어 비디오 오버레이 액세스를 지원합니다. 비디오 오버레이는 표준 &lt;code&gt;RGB&lt;/code&gt; 픽셀 형식을 사용하지 않으며 여러 해상도의 데이터를 사용하여 단일 이미지를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="868f7a2a6f95538f4477017eed3c47028dd7d14e" translate="yes" xml:space="preserve">
          <source>The Overlay objects represent lower level access to the display hardware. To use the object you must understand the technical details of video overlays.</source>
          <target state="translated">오버레이 개체는 디스플레이 하드웨어에 대한 낮은 수준의 액세스를 나타냅니다. 개체를 사용하려면 비디오 오버레이의 기술적 세부 사항을 이해해야합니다.</target>
        </trans-unit>
        <trans-unit id="ead749b7ae04c7a19e2902afb299b9e7bbdc72fc" translate="yes" xml:space="preserve">
          <source>The PixelArray wraps a Surface and provides direct access to the surface's pixels. A pixel array can be one or two dimensional. A two dimensional array, like its surface, is indexed [column, row]. Pixel arrays support slicing, both for returning a subarray or for assignment. A pixel array sliced on a single column or row returns a one dimensional pixel array. Arithmetic and other operations are not supported. A pixel array can be safely assigned to itself. Finally, pixel arrays export an array struct interface, allowing them to interact with &lt;a href=&quot;pixelcopy#module-pygame.pixelcopy&quot;&gt;&lt;code&gt;pygame.pixelcopy&lt;/code&gt;&lt;/a&gt; methods and NumPy arrays.</source>
          <target state="translated">PixelArray는 Surface를 감싸고 표면의 픽셀에 직접 액세스 할 수 있도록합니다. 픽셀 어레이는 1 차원 또는 2 차원 일 수있다. 표면과 같이 2 차원 배열이 색인화됩니다 [열, 행]. 픽셀 배열은 하위 배열을 반환하거나 할당을 위해 슬라이싱을 지원합니다. 단일 열 또는 행에 슬라이스 된 픽셀 배열은 1 차원 픽셀 배열을 반환합니다. 산술 및 기타 연산은 지원되지 않습니다. 픽셀 배열을 안전하게 할당 할 수 있습니다. 마지막으로 픽셀 배열은 배열 구조체 인터페이스를 내보내 &lt;a href=&quot;pixelcopy#module-pygame.pixelcopy&quot;&gt; &lt;code&gt;pygame.pixelcopy&lt;/code&gt; &lt;/a&gt; 메소드 및 NumPy 배열과 상호 작용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="25cee5d170344b87554a3f7c919d65dd427264f6" translate="yes" xml:space="preserve">
          <source>The Rect functions that change the position or size of a Rect return a new copy of the Rect with the affected changes. The original Rect is not modified. Some methods have an alternate &quot;in-place&quot; version that returns None but effects the original Rect. These &quot;in-place&quot; methods are denoted with the &quot;ip&quot; suffix.</source>
          <target state="translated">Rect의 위치 나 크기를 변경하는 Rect 함수는 영향을받는 변경 사항과 함께 Rect의 새 복사본을 반환합니다. 원본 Rect는 수정되지 않습니다. 일부 메소드에는 대체 &quot;in-place&quot;버전이 있으며 None을 리턴하지만 원래 Rect에는 영향을줍니다. 이러한 &quot;in-place&quot;방법은 &quot;ip&quot;접미사로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="34e163ffd47ca50cd0a5b757d3580b6fc549ef34" translate="yes" xml:space="preserve">
          <source>The Rect object has several virtual attributes which can be used to move and align the Rect:</source>
          <target state="translated">Rect 객체에는 Rect를 이동하고 정렬하는 데 사용할 수있는 몇 가지 가상 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="efe1c9945344d61b409c10c29100d59b89b4a1cf" translate="yes" xml:space="preserve">
          <source>The Sound can be loaded from an &lt;code&gt;OGG&lt;/code&gt; audio file or from an uncompressed &lt;code&gt;WAV&lt;/code&gt;.</source>
          <target state="translated">사운드는 &lt;code&gt;OGG&lt;/code&gt; 오디오 파일 또는 압축되지 않은 &lt;code&gt;WAV&lt;/code&gt; 에서 로드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f1ea78534450ebd13266311e40dbf6f8f828450c" translate="yes" xml:space="preserve">
          <source>The Sound object represents actual sound sample data. Methods that change the state of the Sound object will the all instances of the Sound playback. A Sound object also exports an array interface, and, for Python 2.6 or later, a new buffer interface.</source>
          <target state="translated">Sound 객체는 실제 사운드 샘플 데이터를 나타냅니다. Sound 객체의 상태를 변경하는 메소드는 모든 Sound 재생 인스턴스가됩니다. Sound 객체는 또한 배열 인터페이스와 Python 2.6 이상의 경우 새 버퍼 인터페이스를 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="c50aeaed4f2ad5174753423dec31d2396f1e7ee6" translate="yes" xml:space="preserve">
          <source>The Sprite class is intended to be used as a base class for the different types of objects in the game. There is also a base Group class that simply stores sprites. A game could create new types of Group classes that operate on specially customized Sprite instances they contain.</source>
          <target state="translated">Sprite 클래스는 게임에서 다양한 유형의 오브젝트에 대한 기본 클래스로 사용됩니다. 스프라이트를 간단히 저장하는 기본 Group 클래스도 있습니다. 게임은 포함 된 특별히 사용자 지정된 Sprite 인스턴스에서 작동하는 새로운 유형의 Group 클래스를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb1fc92c63ef839801ffaec0d6a6059978b00c91" translate="yes" xml:space="preserve">
          <source>The Sprite is removed from all the Groups that contain it. This won't change anything about the state of the Sprite. It is possible to continue to use the Sprite after this method has been called, including adding it to Groups.</source>
          <target state="translated">스프라이트는 스프라이트를 포함하는 모든 그룹에서 제거됩니다. 스프라이트 상태에 대해서는 아무 것도 변경하지 않습니다. 스프라이트를 그룹에 추가하는 것을 포함하여이 메소드가 호출 된 후에도 스프라이트를 계속 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e299009e66eca407d98d40ef8799bfe2cd5dd54" translate="yes" xml:space="preserve">
          <source>The Sprites in the Group are not ordered, so drawing and iterating the Sprites is in no particular order.</source>
          <target state="translated">그룹의 스프라이트는 순서가 없으므로 스프라이트 그리기 및 반복은 특별한 순서가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="23e1edc6c4426acdce85bb5987a9f8477dd5b9c1" translate="yes" xml:space="preserve">
          <source>The Surface returned will be of the dimensions required to hold the text. (the same as those returned by Font.size()). If an empty string is passed for the text, a blank surface will be returned that is one pixel wide and the height of the font.</source>
          <target state="translated">반환 된 표면은 텍스트를 유지하는 데 필요한 치수입니다. (Font.size ()에서 반환 된 것과 동일) 텍스트에 빈 문자열이 전달되면 너비가 1 픽셀이고 글꼴 높이 인 빈 표면이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="65d7938ccb060f4e712d8ba53d6da701cef2b206" translate="yes" xml:space="preserve">
          <source>The Surface that gets returned can be drawn to like a regular Surface but changes will eventually be seen on the monitor.</source>
          <target state="translated">반환되는 Surface는 일반 Surface처럼 그릴 수 있지만 변경 사항은 결국 모니터에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="820a2f2fb6d97dfb55d32ce9f38c8030a3d3c609" translate="yes" xml:space="preserve">
          <source>The Surface the PixelArray was created for.</source>
          <target state="translated">PixelArray가 생성 된 Surface입니다.</target>
        </trans-unit>
        <trans-unit id="95d6409ff5a87fab15249cac49c0d094e9395cd8" translate="yes" xml:space="preserve">
          <source>The Surface this array references will remain locked for the lifetime of the array.</source>
          <target state="translated">이 어레이가 참조하는 Surface는 어레이 수명 동안 잠금 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="7d3b2559d41e52142232ca12b4de874d7e137acc" translate="yes" xml:space="preserve">
          <source>The Surface this references will remain locked for the lifetime of the array (see the &lt;a href=&quot;surface#pygame.Surface.lock&quot;&gt;&lt;code&gt;pygame.Surface.lock()&lt;/code&gt;&lt;/a&gt; - lock the Surface memory for pixel access method).</source>
          <target state="translated">이 참조가 참조 할 Surface는 배열의 수명 동안 고정 된 상태로 유지됩니다 ( &lt;a href=&quot;surface#pygame.Surface.lock&quot;&gt; &lt;code&gt;pygame.Surface.lock()&lt;/code&gt; &lt;/a&gt; -픽셀 액세스 방법을 위해 Surface 메모리 잠그기).</target>
        </trans-unit>
        <trans-unit id="7707ceae5a4123b3a1e50db13f637a3ce801a2c7" translate="yes" xml:space="preserve">
          <source>The alpha value of the Color.</source>
          <target state="translated">색상의 알파 값입니다.</target>
        </trans-unit>
        <trans-unit id="a8a71b621f2199f0696f0dd88b6f7d8a9a948e7a" translate="yes" xml:space="preserve">
          <source>The amount by which a font glyph's size is enlarged for the strong or wide transformations, as a fraction of the untransformed size. For the wide style only the horizontal dimension is increased. For strong text both the horizontal and vertical dimensions are enlarged. A wide style of strength 0.08333 ( 1/12 ) is equivalent to the &lt;a href=&quot;font#pygame.font.Font&quot;&gt;&lt;code&gt;pygame.font.Font&lt;/code&gt;&lt;/a&gt; bold style. The default is 0.02778 ( 1/36 ).</source>
          <target state="translated">변형되지 않은 크기의 일부로 글꼴 글리프의 크기가 강하거나 넓은 변형에 대해 확대되는 양입니다. 넓은 스타일의 경우 가로 치수 만 증가합니다. 강한 텍스트의 경우 가로 및 세로 크기가 모두 확대됩니다. 강도 0.08333 (1/12)의 넓은 스타일은 &lt;a href=&quot;font#pygame.font.Font&quot;&gt; &lt;code&gt;pygame.font.Font&lt;/code&gt; &lt;/a&gt; 굵은 스타일 과 같습니다 . 기본값은 0.02778 (1/36)입니다.</target>
        </trans-unit>
        <trans-unit id="46e5ab9e11e8ee1310b74f5b65e393ea84b9f751" translate="yes" xml:space="preserve">
          <source>The area covered by a Rect does not include the right- and bottom-most edge of pixels. If one Rect's bottom border is another Rect's top border (i.e., rect1.bottom=rect2.top), the two meet exactly on the screen but do not overlap, and &lt;code&gt;rect1.colliderect(rect2)&lt;/code&gt; returns false.</source>
          <target state="translated">Rect가 적용되는 영역에는 픽셀의 가장 오른쪽 및 맨 아래 가장자리가 포함되지 않습니다. 한 Rect의 아래쪽 테두리가 다른 Rect의 위쪽 테두리 인 경우 (예 : rect1.bottom = rect2.top) 두 화면은 정확히 만나지 만 겹치지 않으며 &lt;code&gt;rect1.colliderect(rect2)&lt;/code&gt; 는 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c16ea20dfeaf91d6c49baa315c0c308efdfff99c" translate="yes" xml:space="preserve">
          <source>The array element type as a length 3 string. The first character gives byteorder, '&amp;lt;' for little-endian, '&amp;gt;' for big-endian, and '|' for not applicable. The second character is the element type, 'i' for signed integer, 'u' for unsigned integer, 'f' for floating point, and 'V' for an chunk of bytes. The third character gives the bytesize of the element, from '1' to '9' bytes. So, for example, &quot;&amp;lt;u4&quot; is an unsigned 4 byte little-endian integer, such as a 32 bit pixel on a PC, while &quot;|V3&quot; would represent a 24 bit pixel, which has no integer equivalent.</source>
          <target state="translated">배열 요소 유형은 길이 3 문자열입니다. 첫 번째 문자는 바이트 순서, 리틀 엔디안의 경우 '&amp;lt;', 빅 엔디안의 경우 '&amp;gt;'및 '|' 적용되지 않습니다. 두 번째 문자는 요소 유형, 부호있는 정수의 경우 'i', 부호없는 정수의 경우 'u', 부동 소수점의 경우 'f', 바이트 청크의 경우 'V'입니다. 세 번째 문자는 '1'에서 '9'바이트까지 요소의 바이트 크기를 나타냅니다. 예를 들어, &quot;&amp;lt;u4&quot;는 PC의 32 비트 픽셀과 같은 부호없는 4 바이트 리틀 엔디안 정수이고 &quot;| V3&quot;은 정수와 동등한 24 비트 픽셀을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="927a3e14cde61733f692118bcf28842e255ed722" translate="yes" xml:space="preserve">
          <source>The array struct interface exposes an array's data in a standard way. It was introduced in NumPy. In Python 2.7 and above it is replaced by the new buffer protocol, though the buffer protocol is still a work in progress. The array struct interface, on the other hand, is stable and works with earlier Python versions. So for now the array struct interface is the predominate way pygame handles array introspection.</source>
          <target state="translated">배열 구조체 인터페이스는 표준 방식으로 배열의 데이터를 노출합니다. NumPy에서 소개되었습니다. Python 2.7 이상에서는 새로운 버퍼 프로토콜로 대체되지만 버퍼 프로토콜은 여전히 ​​진행중인 작업입니다. 반면에 배열 구조체 인터페이스는 안정적이며 이전 Python 버전에서 작동합니다. 따라서 지금은 struct 배열 인터페이스가 파이 게임이 배열 내성을 처리하는 주된 방법입니다.</target>
        </trans-unit>
        <trans-unit id="9ba217b5edead57cf382a361962cfbe0c46c39f2" translate="yes" xml:space="preserve">
          <source>The arrays are indexed by the &lt;code&gt;X&lt;/code&gt; axis first, followed by the &lt;code&gt;Y&lt;/code&gt; axis. Arrays that treat the pixels as a single integer are referred to as 2D arrays. This module can also separate the red, green, and blue color values into separate indices. These types of arrays are referred to as 3D arrays, and the last index is 0 for red, 1 for green, and 2 for blue.</source>
          <target state="translated">배열은 &lt;code&gt;X&lt;/code&gt; 축으로 먼저 색인 된 다음 &lt;code&gt;Y&lt;/code&gt; 축 으로 색인됩니다 . 픽셀을 단일 정수로 취급하는 배열을 2D 배열이라고합니다. 이 모듈은 빨강, 녹색 및 파랑 색 값을 별도의 인덱스로 분리 할 수도 있습니다. 이러한 유형의 배열을 3D 배열이라고하며 마지막 인덱스는 빨강의 경우 0, 초록의 경우 1, 파랑의 경우 2입니다.</target>
        </trans-unit>
        <trans-unit id="ab076dbfaf23a94ec9e1b92d83870bc803bc8ea4" translate="yes" xml:space="preserve">
          <source>The axis number must be an integer from zero to get_numaxes()-1.</source>
          <target state="translated">축 번호는 0에서 get_numaxes ()-1 사이의 정수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="3695fda650eab7201f9908807084f52434e4b503" translate="yes" xml:space="preserve">
          <source>The background is usually a Surface image the same dimensions as the destination Surface. However, it can also be a callback function that takes two arguments; the destination Surface and an area to clear. The background callback function will be called several times each clear.</source>
          <target state="translated">배경은 일반적으로 대상 표면과 치수가 같은 표면 이미지입니다. 그러나 두 개의 인수를 취하는 콜백 함수일 수도 있습니다. 대상 표면과 지울 영역. 백그라운드 콜백 함수는 매번 여러 번 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="a24fc5e6979f65180d21417a6e9a73ca5e66b1f4" translate="yes" xml:space="preserve">
          <source>The ball number must be an integer from zero to get_numballs()-1.</source>
          <target state="translated">볼 번호는 0에서 get_numballs ()-1 사이의 정수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="5132ff265b241e64e6d6e2a0a8de03434707ae0d" translate="yes" xml:space="preserve">
          <source>The base class for visible game objects. Derived classes will want to override the &lt;code&gt;Sprite.update()&lt;/code&gt; and assign a &lt;code&gt;Sprite.image&lt;/code&gt; and &lt;code&gt;Sprite.rect&lt;/code&gt; attributes. The initializer can accept any number of Group instances to be added to.</source>
          <target state="translated">보이는 게임 오브젝트의 기본 클래스입니다. 파생 클래스는 &lt;code&gt;Sprite.update()&lt;/code&gt; 를 재정의하고 &lt;code&gt;Sprite.image&lt;/code&gt; 및 &lt;code&gt;Sprite.rect&lt;/code&gt; 특성을 할당 하려고 합니다. 이니셜 라이저는 추가 할 그룹 인스턴스를 원하는 수만큼 수용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4a2e1c04a6bdefe984a29de0dd8467a4c0e92bd" translate="yes" xml:space="preserve">
          <source>The basic Sprite class can draw the Sprites it contains to a Surface. The &lt;code&gt;Group.draw()&lt;/code&gt; method requires that each Sprite have a &lt;code&gt;Surface.image&lt;/code&gt; attribute and a &lt;code&gt;Surface.rect&lt;/code&gt;. The &lt;code&gt;Group.clear()&lt;/code&gt; method requires these same attributes, and can be used to erase all the Sprites with background. There are also more advanced Groups: &lt;code&gt;pygame.sprite.RenderUpdates()&lt;/code&gt; and &lt;code&gt;pygame.sprite.OrderedUpdates()&lt;/code&gt;.</source>
          <target state="translated">기본 Sprite 클래스는 포함 된 Sprite를 Surface에 그릴 수 있습니다. &lt;code&gt;Group.draw()&lt;/code&gt; 메소드는, 각각의 스프가 있어야 &lt;code&gt;Surface.image&lt;/code&gt; 의 속성과 &lt;code&gt;Surface.rect&lt;/code&gt; 를 . &lt;code&gt;Group.clear()&lt;/code&gt; 메소드는 이러한 동일한 속성을 필요로하고, 배경으로 모든 스프라이트를 삭제할 수 있습니다. &lt;code&gt;pygame.sprite.RenderUpdates()&lt;/code&gt; 및 &lt;code&gt;pygame.sprite.OrderedUpdates()&lt;/code&gt; 와 같은 고급 그룹도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="66224d729ef9da1c3ddf5b176505cf0cc02b5b89" translate="yes" xml:space="preserve">
          <source>The blue value of the Color.</source>
          <target state="translated">색상의 파란색 값입니다.</target>
        </trans-unit>
        <trans-unit id="037a2fac7048fe729be15256742e71533643e2d4" translate="yes" xml:space="preserve">
          <source>The bounding box min_x, max_y, min_y, and max_y values are returned as grid-fitted pixel coordinates of type int. The advance values are float values.</source>
          <target state="translated">경계 상자 min_x, max_y, min_y 및 max_y 값은 int 유형의 격자 맞춤 픽셀 좌표로 반환됩니다. 사전 값은 부동 값입니다.</target>
        </trans-unit>
        <trans-unit id="1838e23302c621f03113a9827398d5f0e4cdc509" translate="yes" xml:space="preserve">
          <source>The buffer argument controls the number of internal samples used in the sound mixer. The default value should work for most cases. It can be lowered to reduce latency, but sound dropout may occur. It can be raised to larger values to ensure playback never skips, but it will impose latency on sound playback. The buffer size must be a power of two (if not it is rounded up to the next nearest power of 2).</source>
          <target state="translated">buffer 인수는 사운드 믹서에 사용되는 내부 샘플 수를 제어합니다. 대부분의 경우 기본값이 작동합니다. 대기 시간을 줄이기 위해 낮출 수 있지만 사운드 드롭 아웃이 발생할 수 있습니다. 재생이 절대로 건너 뛰지 않도록 더 큰 값으로 올릴 수 있지만 사운드 재생시 대기 시간이 부과됩니다. 버퍼 크기는 2의 거듭 제곱이어야합니다 (그렇지 않은 경우 다음 가장 가까운 거듭 제곱 2로 올림).</target>
        </trans-unit>
        <trans-unit id="465bc2a0c053c22a269945e9d021b8ac7a2de4df" translate="yes" xml:space="preserve">
          <source>The buffer data as a &lt;code&gt;str&lt;/code&gt;/&lt;code&gt;bytes&lt;/code&gt; object. Any gaps in the exported data are removed.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; / &lt;code&gt;bytes&lt;/code&gt; 객체 로서의 버퍼 데이터 . 내 보낸 데이터의 간격이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="f23763a8d8a8472f656e1951dc4e671cd99ac91d" translate="yes" xml:space="preserve">
          <source>The calculations are done using the font's default size in points. Optionally you may specify another point size with the &lt;em&gt;size&lt;/em&gt; argument.</source>
          <target state="translated">글꼴의 기본 크기를 포인트 단위로 계산합니다. 선택적으로 &lt;em&gt;size&lt;/em&gt; 인수로 다른 포인트 크기를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="48acbdb933d1ef83080b1cd9eb38e26080ba8e4b" translate="yes" xml:space="preserve">
          <source>The caller should immediately close the output port; this call may result in transmission of a partial midi message. There is no abort for Midi input because the user can simply ignore messages in the buffer and close an input device at any time.</source>
          <target state="translated">호출자는 즉시 출력 포트를 닫아야합니다. 이 호출은 부분 미디 메시지를 전송할 수 있습니다. 사용자는 버퍼의 메시지를 무시하고 언제든지 입력 장치를 닫을 수 있기 때문에 Midi 입력에 대한 중단이 없습니다.</target>
        </trans-unit>
        <trans-unit id="848bf5c1d0d6a3c5ba62340af85afe8864ca2dda" translate="yes" xml:space="preserve">
          <source>The cdrom module manages the &lt;code&gt;CD&lt;/code&gt; and &lt;code&gt;DVD&lt;/code&gt; drives on a computer. It can also control the playback of audio CDs. This module needs to be initialized before it can do anything. Each &lt;code&gt;CD&lt;/code&gt; object you create represents a cdrom drive and must also be initialized individually before it can do most things.</source>
          <target state="translated">cdrom 모듈은 컴퓨터 의 &lt;code&gt;CD&lt;/code&gt; 및 &lt;code&gt;DVD&lt;/code&gt; 드라이브를 관리 합니다. 오디오 CD 재생을 제어 할 수도 있습니다. 이 모듈은 무엇이든하기 전에 초기화해야합니다. 생성하는 각 &lt;code&gt;CD&lt;/code&gt; 개체는 cdrom 드라이브를 나타내며 대부분의 작업을 수행하기 전에 개별적으로 초기화해야합니다.</target>
        </trans-unit>
        <trans-unit id="3aa74b414bf35d3adc88bb60a0554b23613c1237" translate="yes" xml:space="preserve">
          <source>The channels argument is used to specify whether to use mono or stereo. 1 for mono and 2 for stereo.</source>
          <target state="translated">channels 인수는 모노 또는 스테레오 사용 여부를 지정하는 데 사용됩니다. 모노의 경우 1, 스테레오의 경우 2</target>
        </trans-unit>
        <trans-unit id="c43ff1075bf220e440b503e959bb5e769406a0b3" translate="yes" xml:space="preserve">
          <source>The clipping area is always restricted to the area of the Surface itself. If the clip rectangle is too large it will be shrunk to fit inside the Surface.</source>
          <target state="translated">클리핑 영역은 항상 표면 자체의 영역으로 제한됩니다. 클립 사각형이 너무 크면 Surface 내부에 맞도록 축소됩니다.</target>
        </trans-unit>
        <trans-unit id="10a8f3f529a049de5f077eb7ccac2c0b26a47db2" translate="yes" xml:space="preserve">
          <source>The collided argument is a callback function used to calculate if two sprites are colliding. It should take two sprites as values and return a bool value indicating if they are colliding. If collided is not passed, then all sprites must have a &quot;rect&quot; value, which is a rectangle of the sprite area, which will be used to calculate the collision.</source>
          <target state="translated">충돌 인수는 두 개의 스프라이트가 충돌하는지 계산하는 데 사용되는 콜백 함수입니다. 두 개의 스프라이트를 값으로 가져와 충돌 여부를 나타내는 부울 값을 반환해야합니다. 충돌이 전달되지 않으면 모든 스프라이트에는 &quot;정확한&quot;값이 있어야합니다.이 값은 스프라이트 영역의 사각형이며 충돌을 계산하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4e835ae0dc84efe0e1eeb7b0b34eed50ab5a7bb9" translate="yes" xml:space="preserve">
          <source>The collided argument is a callback function used to calculate if two sprites are colliding. it should take two sprites as values, and return a bool value indicating if they are colliding. If collided is not passed, all sprites must have a &quot;rect&quot; value, which is a rectangle of the sprite area, which will be used to calculate the collision.</source>
          <target state="translated">충돌 인수는 두 개의 스프라이트가 충돌하는지 계산하는 데 사용되는 콜백 함수입니다. 두 개의 스프라이트를 값으로 가져와 충돌 여부를 나타내는 부울 값을 반환해야합니다. 충돌이 전달되지 않으면 모든 스프라이트에는 &quot;정확한&quot;값이 있어야합니다.이 값은 스프라이트 영역의 사각형이며 충돌을 계산하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c4c4cab777020d2f28a3e7f96d1796c0cf71cec5" translate="yes" xml:space="preserve">
          <source>The color argument can be either a &lt;code&gt;RGB&lt;/code&gt; sequence, a &lt;code&gt;RGBA&lt;/code&gt; sequence or a mapped color index. If using &lt;code&gt;RGBA&lt;/code&gt;, the Alpha (A part of &lt;code&gt;RGBA&lt;/code&gt;) is ignored unless the surface uses per pixel alpha (Surface has the &lt;code&gt;SRCALPHA&lt;/code&gt; flag).</source>
          <target state="translated">색상 인수는 &lt;code&gt;RGB&lt;/code&gt; 시퀀스, &lt;code&gt;RGBA&lt;/code&gt; 시퀀스 또는 매핑 된 색상 인덱스 일 수 있습니다. &lt;code&gt;RGBA&lt;/code&gt; 를 사용하는 경우 표면에서 픽셀 당 알파를 사용하지 않는 한 알파 ( &lt;code&gt;RGBA&lt;/code&gt; 의 일부 )는 무시됩니다 (표면에 &lt;code&gt;SRCALPHA&lt;/code&gt; 플래그가 있음).</target>
        </trans-unit>
        <trans-unit id="fe2843229e1d77bcf15910fd97404d0863d1bb33" translate="yes" xml:space="preserve">
          <source>The colorkey will be ignored if the Surface is formatted to use per pixel alpha values. The colorkey can be mixed with the full Surface alpha value.</source>
          <target state="translated">Surface가 픽셀 당 알파 값을 사용하도록 포맷 된 경우 컬러 키가 무시됩니다. 컬러 키는 전체 표면 알파 값과 혼합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="acf65a2acc922f83019c5fdff72441dae6da8574" translate="yes" xml:space="preserve">
          <source>The converted Surface will have no pixel alphas. They will be stripped if the original had them. See &lt;a href=&quot;#pygame.Surface.convert_alpha&quot;&gt;&lt;code&gt;convert_alpha()&lt;/code&gt;&lt;/a&gt; for preserving or creating per-pixel alphas.</source>
          <target state="translated">변환 된 Surface에는 픽셀 알파가 없습니다. 원본에 있으면 제거됩니다. 픽셀 당 알파를 유지하거나 만들 &lt;a href=&quot;#pygame.Surface.convert_alpha&quot;&gt; &lt;code&gt;convert_alpha()&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7cfc3cabd145c5395effcba4ad5abb977c45639e" translate="yes" xml:space="preserve">
          <source>The coordinates for Rect objects are all integers. The size values can be programmed to have negative values, but these are considered illegal Rects for most operations.</source>
          <target state="translated">Rect 객체의 좌표는 모두 정수입니다. 크기 값은 음수 값을 갖도록 프로그래밍 할 수 있지만 대부분의 작업에서 잘못된 사각형으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="7b73097e6374457eeb842df97cea5e85500ed4f7" translate="yes" xml:space="preserve">
          <source>The coordinates of a vector can be retrieved or set using attributes or subscripts:</source>
          <target state="translated">벡터의 좌표는 속성 또는 아래 첨자를 사용하여 검색하거나 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d5afa5e941828bdd5ff1e160ffc4faf32681786" translate="yes" xml:space="preserve">
          <source>The created callable tests for collision between two sprites, by testing to see if two circles centered on the sprites overlap, after scaling the circles radius by the stored ratio. If the sprites have a &quot;radius&quot; attribute, that is used to create the circle, otherwise a circle is created that is big enough to completely enclose the sprites rect as given by the &quot;rect&quot; attribute. Intended to be passed as a collided callback function to the *collide functions. Sprites must have a &quot;rect&quot; and an optional &quot;radius&quot; attribute.</source>
          <target state="translated">저장된 반지름으로 원의 반지름을 조정 한 후 스프라이트를 중심으로 두 개의 원이 겹치는 지 테스트하여 두 개의 스프라이트 간 충돌에 대한 호출 가능 테스트를 생성했습니다. 스프라이트에 원을 만드는 데 사용되는 &quot;반지름&quot;속성이있는 경우 &quot;rect&quot;속성에 지정된대로 스프라이트 rect를 완전히 둘러싸기에 충분한 원이 만들어집니다. 충돌 콜백 함수로 * collide 함수에 전달되었습니다. 스프라이트에는 &quot;rect&quot;및 선택적인 &quot;radius&quot;속성이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="aa7215611a622e2a6268a469275bf9823f550e99" translate="yes" xml:space="preserve">
          <source>The current algorithm searches the overlapping area in &lt;code&gt;sizeof(unsigned long int) * CHAR_BIT&lt;/code&gt; bit wide column blocks (the value of &lt;code&gt;sizeof(unsigned long int) * CHAR_BIT&lt;/code&gt; is platform dependent, for clarity it will be referred to as &lt;code&gt;W&lt;/code&gt;). Starting at the top left corner it checks bits 0 to &lt;code&gt;W - 1&lt;/code&gt; of the first row (&lt;code&gt;(0, 0)&lt;/code&gt; to &lt;code&gt;(W - 1, 0)&lt;/code&gt;) then continues to the next row (&lt;code&gt;(0, 1)&lt;/code&gt; to &lt;code&gt;(W - 1, 1)&lt;/code&gt;). Once this entire column block is checked, it continues to the next one (&lt;code&gt;W&lt;/code&gt; to &lt;code&gt;2 * W - 1&lt;/code&gt;). This is repeated until it finds a point of intersection or the entire overlapping area is checked.</source>
          <target state="translated">현재 알고리즘은 &lt;code&gt;sizeof(unsigned long int) * CHAR_BIT&lt;/code&gt; 비트 너비 열 블록 에서 겹치는 영역을 검색합니다 (sizeof (unsigned long int) * CHAR_BIT 의 값 은 플랫폼에 따라 &lt;code&gt;sizeof(unsigned long int) * CHAR_BIT&lt;/code&gt; 므로 명확성을 기하기 위해 &lt;code&gt;W&lt;/code&gt; 라고 함 ). 왼쪽 상단에서 시작 하여 첫 번째 행의 비트 0 ~ &lt;code&gt;W - 1&lt;/code&gt; ( &lt;code&gt;(0, 0)&lt;/code&gt; ~ &lt;code&gt;(W - 1, 0)&lt;/code&gt; )을 확인한 후 다음 행 ( &lt;code&gt;(0, 1)&lt;/code&gt; ~ &lt;code&gt;(W - 1, 1)&lt;/code&gt; ). 이 전체 열 블록이 확인되면 다음 열 블록으로 계속 진행됩니다 ( &lt;code&gt;W&lt;/code&gt; - &lt;code&gt;2 * W - 1&lt;/code&gt; ). 교차점을 찾거나 전체 겹치는 영역을 확인할 때까지이 과정이 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="36a6e9bb73aa7340d002ba1b20dba0e71cb91323" translate="yes" xml:space="preserve">
          <source>The cursorfile and maskfile arguments can either be filenames or file-like object with the readlines method.</source>
          <target state="translated">cursorfile 및 maskfile 인수는 readlines 메소드를 사용하여 파일 이름 또는 파일 유사 오브젝트 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="88fce1a1f08031cc28b249cce64323640d5c83cb" translate="yes" xml:space="preserve">
          <source>The default 'P' kind code does a direct raw integer pixel (mapped) value copy to a 2D array and a 'RGB' pixel component (unmapped) copy to a 3D array having shape (w, h, 3). For an 8 bit colormap surface this means the table index is copied to a 2D array, not the table value itself. A 2D array's item size must be at least as large as the surface's pixel byte size. The item size of a 3D array must be at least one byte.</source>
          <target state="translated">기본 'P'종류 코드는 직접 원시 정수 픽셀 (매핑 된) 값을 2D 배열로 복사하고 'RGB'픽셀 구성 요소 (매핑되지 않은)를 모양 (w, h, 3)의 3D 배열로 복사합니다. 8 비트 컬러 맵 표면의 경우 이는 테이블 인덱스 자체가 아니라 테이블 인덱스가 2D 배열로 복사됨을 의미합니다. 2D 배열의 항목 크기는 표면의 픽셀 바이트 크기 이상이어야합니다. 3D 배열의 항목 크기는 1 바이트 이상이어야합니다.</target>
        </trans-unit>
        <trans-unit id="fd03b49497bc3828b569ac9834caabc1e4c24107" translate="yes" xml:space="preserve">
          <source>The default Color length is 4. Colors can have lengths 1,2,3 or 4. This is useful if you want to unpack to r,g,b and not r,g,b,a. If you want to get the length of a Color do &lt;code&gt;len(acolor)&lt;/code&gt;.</source>
          <target state="translated">기본 색상 길이는 4입니다. 색상의 길이는 1,2,3 또는 4입니다. r, g, b, a가 아닌 r, g, b로 압축을 풀려는 경우에 유용합니다. Color의 길이를 얻으려면 &lt;code&gt;len(acolor)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="208a21adc816465fe73b4b6eabe79b6833b01171" translate="yes" xml:space="preserve">
          <source>The default implementation of this method does nothing; it's just a convenient &quot;hook&quot; that you can override. This method is called by &lt;code&gt;Group.update()&lt;/code&gt; with whatever arguments you give it.</source>
          <target state="translated">이 메소드의 기본 구현은 아무 것도 수행하지 않습니다. 무시할 수있는 편리한 &quot;후크&quot;입니다. 이 메소드는 &lt;code&gt;Group.update()&lt;/code&gt; 의해 주어진 인수와 함께 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="7cfdc9520e5148ef46b405e0c8b09b9412f98f35" translate="yes" xml:space="preserve">
          <source>The default point size used in rendering</source>
          <target state="translated">렌더링에 사용되는 기본 포인트 크기</target>
        </trans-unit>
        <trans-unit id="3c81de7a014387b48a8da92c47a4667b0c0bec14" translate="yes" xml:space="preserve">
          <source>The difference between the music playback and regular Sound playback is that the music is streamed, and never actually loaded all at once. The mixer system only supports a single music stream at once.</source>
          <target state="translated">음악 재생과 일반 사운드 재생의 차이점은 음악이 스트리밍되고 실제로 한 번에 모두로드되지 않는다는 것입니다. 믹서 시스템은 한 번에 하나의 음악 스트림 만 지원합니다.</target>
        </trans-unit>
        <trans-unit id="fa0e4e9b74c10e9e30f57bc52cf63b2ac2c408d7" translate="yes" xml:space="preserve">
          <source>The display argument is new with pygame 1.9.5.</source>
          <target state="translated">표시 인수는 pygame 1.9.5의 새로운 기능입니다.</target>
        </trans-unit>
        <trans-unit id="e788367b568a8922126d27af9ee36c7229c673d3" translate="yes" xml:space="preserve">
          <source>The display index 0 means the default display is used.</source>
          <target state="translated">표시 색인 0은 기본 표시가 사용됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="e244f9480f561a52629b7be6430b11e3eb5d9f9b" translate="yes" xml:space="preserve">
          <source>The dokill argument is a bool. If set to True, all Sprites that collide will be removed from the Group.</source>
          <target state="translated">dokill 논쟁은 바보입니다. True로 설정하면 충돌하는 모든 Sprite가 그룹에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="ced455f0e1abc8a6d677760c7552dbfa7978c22a" translate="yes" xml:space="preserve">
          <source>The event queue contains &lt;a href=&quot;#pygame.event.EventType&quot;&gt;&lt;code&gt;pygame.event.EventType&lt;/code&gt;&lt;/a&gt; event objects. There are a variety of ways to access the queued events, from simply checking for the existence of events, to grabbing them directly off the stack. The event queue also offers some simple filtering which can slightly help performance by blocking certain event types from the queue. Use &lt;a href=&quot;#pygame.event.set_allowed&quot;&gt;&lt;code&gt;pygame.event.set_allowed()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#pygame.event.set_blocked&quot;&gt;&lt;code&gt;pygame.event.set_blocked()&lt;/code&gt;&lt;/a&gt; to change this filtering. By default, all event types can be placed on the queue.</source>
          <target state="translated">이벤트 큐는 &lt;a href=&quot;#pygame.event.EventType&quot;&gt; &lt;code&gt;pygame.event.EventType&lt;/code&gt; &lt;/a&gt; 이벤트 객체를 포함 합니다. 단순히 이벤트가 있는지 확인하는 것부터 스택에서 직접 이벤트를 가져 오는 것까지 대기열에있는 이벤트에 액세스하는 다양한 방법이 있습니다. 이벤트 큐는 또한 간단한 필터링을 제공하여 큐에서 특정 이벤트 유형을 차단하여 성능을 약간 향상시킬 수 있습니다. &lt;a href=&quot;#pygame.event.set_allowed&quot;&gt; &lt;code&gt;pygame.event.set_allowed()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#pygame.event.set_blocked&quot;&gt; &lt;code&gt;pygame.event.set_blocked()&lt;/code&gt; &lt;/a&gt; 사용하십시오.이 필터링을 변경 를 사용하십시오. 기본적으로 모든 이벤트 유형을 큐에 배치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4404877cfc5b31272fe0e651293564dbc5c838de" translate="yes" xml:space="preserve">
          <source>The event queue gets &lt;code&gt;pygame.KEYDOWN&lt;/code&gt; and &lt;code&gt;pygame.KEYUP&lt;/code&gt; events when the keyboard buttons are pressed and released. Both events have a key attribute that is a integer ID representing every key on the keyboard.</source>
          <target state="translated">이벤트 큐는 &lt;code&gt;pygame.KEYDOWN&lt;/code&gt; 및 &lt;code&gt;pygame.KEYUP&lt;/code&gt; 을받습니다.키보드 버튼을 눌렀다 이벤트가 발생합니다. 두 이벤트 모두 키보드의 모든 키를 나타내는 정수 ID 인 키 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="574fb7f997dda0d53a48813138b90732179dcd08" translate="yes" xml:space="preserve">
          <source>The event queue has an upper limit on the number of events it can hold (128 for standard SDL 1.2). When the queue becomes full new events are quietly dropped. To prevent lost events, especially input events which signal a quit command, your program must regularly check for events and process them. To speed up queue processing use &lt;a href=&quot;#pygame.event.set_blocked&quot;&gt;&lt;code&gt;pygame.event.set_blocked()&lt;/code&gt;&lt;/a&gt; to limit which events get queued.</source>
          <target state="translated">이벤트 큐에는 보유 할 수있는 이벤트 수에 대한 상한이 있습니다 (표준 SDL 1.2의 경우 128). 큐가 가득 차면 새 이벤트가 자동으로 삭제됩니다. 손실 된 이벤트, 특히 종료 명령을 알리는 입력 이벤트를 방지하려면 프로그램에서 정기적으로 이벤트를 확인하고 처리해야합니다. 대기열 처리 속도를 높이려면 &lt;a href=&quot;#pygame.event.set_blocked&quot;&gt; &lt;code&gt;pygame.event.set_blocked()&lt;/code&gt; &lt;/a&gt; 를 사용하여 대기열에 넣을 이벤트를 제한하십시오.</target>
        </trans-unit>
        <trans-unit id="b236e77df5e01be0c6fab9ad38ac0b7d6615dfdc" translate="yes" xml:space="preserve">
          <source>The event queue needs to be pumped frequently for some of the methods to work. So call one of pygame.event.get, pygame.event.wait, or pygame.event.pump regularly.</source>
          <target state="translated">일부 방법이 작동하려면 이벤트 큐를 자주 펌핑해야합니다. 따라서 pygame.event.get, pygame.event.wait 또는 pygame.event.pump 중 하나를 정기적으로 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="31661069e153b103cc6ba5d9b4bcd9c0264fa6ed" translate="yes" xml:space="preserve">
          <source>The event type identifier is in between the values of &lt;code&gt;NOEVENT&lt;/code&gt; and &lt;code&gt;NUMEVENTS&lt;/code&gt;. User defined events should have a value in the inclusive range of &lt;code&gt;USEREVENT&lt;/code&gt; to &lt;code&gt;NUMEVENTS - 1&lt;/code&gt;. It is recommended all user events follow this system.</source>
          <target state="translated">이벤트 유형 ID는 &lt;code&gt;NOEVENT&lt;/code&gt; 및 &lt;code&gt;NUMEVENTS&lt;/code&gt; 값 사이에 있습니다 . 사용자 정의 이벤트는 &lt;code&gt;NUMEVENTS - 1&lt;/code&gt; 범위의 &lt;code&gt;USEREVENT&lt;/code&gt; 을 가져야 합니다. 모든 사용자 이벤트가이 시스템을 따르는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="abce96617763247463fa4e8824dca25f2a0abd6a" translate="yes" xml:space="preserve">
          <source>The event will be queued every time the music finishes, not just the first time. To stop the event from being queued, call this method with no argument.</source>
          <target state="translated">이벤트는 처음이 아니라 음악이 끝날 때마다 대기합니다. 이벤트가 큐에 들어 가지 않게하려면 인수없이이 메소드를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="93d21f058988c0eb3ae397d295b73cebdb6a23a0" translate="yes" xml:space="preserve">
          <source>The exporting object. It can be used to keep the parent object alive while its buffer is visible.</source>
          <target state="translated">내보내기 개체 버퍼가 표시되는 동안 부모 개체를 활성 상태로 유지하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c394eac2eaf002443710fbd16940d7ca8de3f13c" translate="yes" xml:space="preserve">
          <source>The fade_ms argument will make the sound start playing at 0 volume and fade up to full volume over the time given. The sample may end before the fade-in is complete.</source>
          <target state="translated">fade_ms 인수는 사운드가 0 볼륨에서 재생을 시작하고 주어진 시간 동안 최대 볼륨까지 페이드되도록합니다. 페이드 인이 완료되기 전에 샘플이 종료 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="27e212efaac7ce2aac5d2990561660cde8cfe88d" translate="yes" xml:space="preserve">
          <source>The flags argument controls which type of display you want. There are several to choose from, and you can even combine multiple types using the bitwise or operator, (the pipe &quot;|&quot; character). If you pass 0 or no flags argument it will default to a software driven window. Here are the display flags you will want to choose from:</source>
          <target state="translated">flags 인자는 원하는 디스플레이 유형을 제어합니다. 선택할 수있는 몇 가지가 있으며 비트 또는 연산자 (파이프 &quot;|&quot;문자)를 사용하여 여러 유형을 결합 할 수도 있습니다. 0 또는 no flags 인수를 전달하면 소프트웨어 구동 창으로 기본 설정됩니다. 선택할 디스플레이 플래그는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e361d9850c0dc7cb34db39884c91951ce428efe8" translate="yes" xml:space="preserve">
          <source>The floor division, &lt;code&gt;//&lt;/code&gt;, and modulus, &lt;code&gt;%&lt;/code&gt;, operators do not raise an exception for division by zero. Instead, if a color, or alpha, channel in the right hand color is 0, then the result is 0. For example:</source>
          <target state="translated">바닥 나누기 &lt;code&gt;//&lt;/code&gt; 및 모듈러스 &lt;code&gt;%&lt;/code&gt; 는 0으로 나누기 예외를 발생시키지 않습니다. 대신 오른쪽 색상의 색상 또는 알파 채널이 0이면 결과는 0입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="830bd7068fc405816a1ad38a34811e921831ac40" translate="yes" xml:space="preserve">
          <source>The following describes the usage details for this function and the &lt;a href=&quot;#pygame.midi.get_default_output_id&quot;&gt;&lt;code&gt;get_default_output_id()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">다음은이 함수의 사용법과 &lt;a href=&quot;#pygame.midi.get_default_output_id&quot;&gt; &lt;code&gt;get_default_output_id()&lt;/code&gt; &lt;/a&gt; 대한 설명입니다. 함수 .</target>
        </trans-unit>
        <trans-unit id="e59851ace828364f9a0ce501b05f339776000558" translate="yes" xml:space="preserve">
          <source>The following event types will be generated by the joysticks</source>
          <target state="translated">조이스틱으로 다음과 같은 이벤트 유형이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="dd274a851562a8c52d18ffd9adb65af4b9d6f163" translate="yes" xml:space="preserve">
          <source>The following example will play music by Bach six times, then play music by Mozart once:</source>
          <target state="translated">다음 예제는 Bach의 음악을 6 번 재생 한 다음 Mozart의 음악을 한 번 재생합니다.</target>
        </trans-unit>
        <trans-unit id="28411c503a9a63f81600ddc2e42efabb8effc24d" translate="yes" xml:space="preserve">
          <source>The following strings can be converted into cursor bitmaps with &lt;code&gt;pygame.cursors.compile()&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;pygame.cursors.compile()&lt;/code&gt; 사용하여 다음 문자열을 커서 비트 맵으로 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4d26b6dccd4b0652aaf2f060443f56f494464755" translate="yes" xml:space="preserve">
          <source>The following variables are cursor bitmaps that can be used as cursor:</source>
          <target state="translated">다음 변수는 커서로 사용할 수있는 커서 비트 맵입니다.</target>
        </trans-unit>
        <trans-unit id="8143d0ede221b53fb253eac45e7316271fcea3b6" translate="yes" xml:space="preserve">
          <source>The font module allows for rendering TrueType fonts into a new Surface object. It accepts any UCS-2 character ('u0001' to 'uFFFF'). This module is optional and requires SDL_ttf as a dependency. You should test that &lt;a href=&quot;#module-pygame.font&quot;&gt;&lt;code&gt;pygame.font&lt;/code&gt;&lt;/a&gt; is available and initialized before attempting to use the module.</source>
          <target state="translated">글꼴 모듈을 사용하면 트루 타입 글꼴을 새 Surface 개체로 렌더링 할 수 있습니다. UCS-2 문자 ( 'u0001'- 'uFFFF')를 허용합니다. 이 모듈은 선택 사항이며 종속성으로 SDL_ttf가 필요합니다. 모듈을 사용하기 전에 &lt;a href=&quot;#module-pygame.font&quot;&gt; &lt;code&gt;pygame.font&lt;/code&gt; &lt;/a&gt; 가 사용 가능하고 초기화 되었는지 테스트해야 합니다.</target>
        </trans-unit>
        <trans-unit id="85d4f8e638add2a8a8185f3220480090efbb5a82" translate="yes" xml:space="preserve">
          <source>The font name can actually be a comma separated list of font names to try. If none of the given names are found, None is returned.</source>
          <target state="translated">글꼴 이름은 실제로 쉼표로 구분 된 글꼴 이름 목록 일 수 있습니다. 주어진 이름이 없으면 None이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="989ff17585882ea23234a45d935162bd432bd11f" translate="yes" xml:space="preserve">
          <source>The font's style flags</source>
          <target state="translated">폰트의 스타일 플래그</target>
        </trans-unit>
        <trans-unit id="7772d8948f9f30e3e879426d58a313e0f37e8fa2" translate="yes" xml:space="preserve">
          <source>The format argument is a string of one of the following values. Note that only 8-bit Surfaces can use the &quot;P&quot; format. The other formats will work for any Surface. Also note that other Python image packages support more formats than pygame.</source>
          <target state="translated">format 인수는 다음 값 중 하나의 문자열입니다. 8 비트 표면 만 &quot;P&quot;형식을 사용할 수 있습니다. 다른 형식은 모든 Surface에서 작동합니다. 또한 다른 Python 이미지 패키지는 파이 게임보다 더 많은 형식을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="d5ee4b8fe089e804d5f5364b92e1de0a181feb0b" translate="yes" xml:space="preserve">
          <source>The given event types are allowed to appear on the event queue. By default, all event types can be placed on the queue. It is safe to enable an event type multiple times.</source>
          <target state="translated">주어진 이벤트 유형은 이벤트 큐에 표시 될 수 있습니다. 기본적으로 모든 이벤트 유형을 큐에 배치 할 수 있습니다. 이벤트 유형을 여러 번 활성화하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="1e0101992fc611d7b1ec2db970412b9ed13ad6a1" translate="yes" xml:space="preserve">
          <source>The given event types are not allowed to appear on the event queue. By default all events can be placed on the queue. It is safe to disable an event type multiple times.</source>
          <target state="translated">주어진 이벤트 유형이 이벤트 큐에 표시 될 수 없습니다. 기본적으로 모든 이벤트는 큐에 배치 될 수 있습니다. 이벤트 유형을 여러 번 비활성화하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="fd8d89769c04c22f7aa416376a6ab8b91c061c2d" translate="yes" xml:space="preserve">
          <source>The glyph metrics are returned as a list of tuples. Each tuple gives metrics of a single character glyph. The glyph metrics are:</source>
          <target state="translated">글리프 메트릭은 튜플 목록으로 반환됩니다. 각 튜플은 단일 문자 글리프의 메트릭을 제공합니다. 글리프 메트릭은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e9d1dea07d37d20134989613dba9c2f28c1fbe07" translate="yes" xml:space="preserve">
          <source>The green value of the Color.</source>
          <target state="translated">색상의 녹색 값입니다.</target>
        </trans-unit>
        <trans-unit id="456be96f77280baedbee583f1741200179a5a91c" translate="yes" xml:space="preserve">
          <source>The groups are designed for high efficiency in removing and adding Sprites to them. They also allow cheap testing to see if a Sprite already exists in a Group. A given Sprite can exist in any number of groups. A game could use some groups to control object rendering, and a completely separate set of groups to control interaction or player movement. Instead of adding type attributes or bools to a derived Sprite class, consider keeping the Sprites inside organized Groups. This will allow for easier lookup later in the game.</source>
          <target state="translated">이 그룹은 스프라이트를 제거하고 추가 할 때 효율성을 높이도록 설계되었습니다. 또한 Sprite가 그룹에 이미 있는지 확인하기 위해 저렴한 테스트를 수행 할 수 있습니다. 주어진 Sprite는 여러 그룹에 존재할 수 있습니다. 게임은 일부 그룹을 사용하여 오브젝트 렌더링을 제어하고 완전히 분리 된 그룹 세트를 사용하여 상호 작용 또는 플레이어 이동을 제어 할 수 있습니다. 파생 된 Sprite 클래스에 형식 특성 또는 부울을 추가하는 대신 Sprite를 체계적인 그룹 내에 유지하는 것이 좋습니다. 게임 후반에 더 쉽게 조회 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fd1e768eb55bd06f6fdc07a307c79a3406594d0" translate="yes" xml:space="preserve">
          <source>The hat number must be between 0 and get_numhats()-1.</source>
          <target state="translated">모자 번호는 0과 get_numhats ()-1 사이 여야합니다.</target>
        </trans-unit>
        <trans-unit id="29746be3c9ea5faaf19937f32ce938e13e504e7a" translate="yes" xml:space="preserve">
          <source>The image module contains functions for loading and saving pictures, as well as transferring Surfaces to formats usable by other packages. .</source>
          <target state="translated">이미지 모듈에는 사진을로드 및 저장하고 Surface를 다른 패키지에서 사용할 수있는 형식으로 전송하는 기능이 포함되어 있습니다. .</target>
        </trans-unit>
        <trans-unit id="4621a08301a145e01d91851501606779ef8bf25d" translate="yes" xml:space="preserve">
          <source>The image module is a required dependency of pygame, but it only optionally supports any extended file formats. By default it can only load uncompressed &lt;code&gt;BMP&lt;/code&gt; images. When built with full image support, the &lt;code&gt;pygame.image.load()&lt;/code&gt; function can support the following formats.</source>
          <target state="translated">이미지 모듈은 파이 게임의 필수 종속성이지만 확장 파일 형식 만 선택적으로 지원합니다. 기본적으로 압축되지 않은 &lt;code&gt;BMP&lt;/code&gt; 이미지 만로드 할 수 있습니다. 완전한 이미지 지원으로 빌드되면 &lt;code&gt;pygame.image.load()&lt;/code&gt; 함수는 다음 형식을 지원할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd2074fb6d81837d927a5332c6696d4c9e28bd5a" translate="yes" xml:space="preserve">
          <source>The input example shows how to translate midi input to pygame events.</source>
          <target state="translated">입력 예제는 미디 입력을 파이 게임 이벤트로 변환하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="c45419a78bd5024c47747cce180d114126bfb964" translate="yes" xml:space="preserve">
          <source>The joystick module manages the joystick devices on a computer. Joystick devices include trackballs and video-game-style gamepads, and the module allows the use of multiple buttons and &quot;hats&quot;. Computers may manage multiple joysticks at a time.</source>
          <target state="translated">조이스틱 모듈은 컴퓨터의 조이스틱 장치를 관리합니다. 조이스틱 장치에는 트랙볼 및 비디오 게임 스타일 게임 패드가 포함되며이 모듈을 사용하면 여러 개의 버튼과 &quot;모자&quot;를 사용할 수 있습니다. 컴퓨터는 한 번에 여러 개의 조이스틱을 관리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="ac32794594354ad8bf0472b453f1f7a0b0377c62" translate="yes" xml:space="preserve">
          <source>The keyboard also has a list of modifier states that can be assembled by bitwise-ORing them together.</source>
          <target state="translated">키보드에는 또한 비트 단위 OR로 조합하여 조립할 수있는 수정 자 상태 목록이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4518f8f87c2d9b81e2fc1287180be2bdd535b13" translate="yes" xml:space="preserve">
          <source>The kind argument is the length 1 string '0', '1', '2', '3', 'r', 'g', 'b', or 'a'. The letters are case insensitive; 'A' will work as well. The argument can be either a Unicode or byte (char) string. The default is '2'.</source>
          <target state="translated">kind 인수는 길이 1 문자열 '0', '1', '2', '3', 'r', 'g', 'b'또는 'a'입니다. 문자는 대소 문자를 구분하지 않습니다. 'A'도 잘 작동합니다. 인수는 유니 코드 또는 바이트 (char) 문자열 일 수 있습니다. 기본값은 '2'입니다.</target>
        </trans-unit>
        <trans-unit id="9999e493747fad23ca45e116be68db93b1a30c05" translate="yes" xml:space="preserve">
          <source>The layers number must exist, it is not checked.</source>
          <target state="translated">레이어 번호가 존재해야하며 확인되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="734b79f99795c4f4431c93237e837cef0f5b7a65" translate="yes" xml:space="preserve">
          <source>The length of each array dimension as a tuple of integers. The length of the tuple is the number of dimensions in the array.</source>
          <target state="translated">각 배열 차원의 길이는 정수의 튜플입니다. 튜플의 길이는 배열의 차원 수입니다.</target>
        </trans-unit>
        <trans-unit id="5b6170043ae94c70bacaf447370be02a72717895" translate="yes" xml:space="preserve">
          <source>The linked and compile version numbers should be the same.</source>
          <target state="translated">연결된 버전과 컴파일 버전은 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="ff0fe2aead0b88fc46e258fd4c047bb9602db711" translate="yes" xml:space="preserve">
          <source>The list contains tuples for each character, which contain the minimum &lt;code&gt;X&lt;/code&gt; offset, the maximum &lt;code&gt;X&lt;/code&gt; offset, the minimum &lt;code&gt;Y&lt;/code&gt; offset, the maximum &lt;code&gt;Y&lt;/code&gt; offset and the advance offset (bearing plus width) of the character. [(minx, maxx, miny, maxy, advance), (minx, maxx, miny, maxy, advance), ...]. None is entered in the list for each unrecognized character.</source>
          <target state="translated">이 목록에는 각 문자에 대한 튜플이 포함되며 여기에는 최소 &lt;code&gt;X&lt;/code&gt; 오프셋, 최대 &lt;code&gt;X&lt;/code&gt; 오프셋, 최소 &lt;code&gt;Y&lt;/code&gt; 오프셋, 최대 &lt;code&gt;Y&lt;/code&gt; 가 포함됩니다 오프셋 및 진행 오프셋 (베어링 플러스 너비)이 포함됩니다. [(minx, maxx, miny, maxy, advance), (minx, maxx, miny, maxy, advance), ...]. 인식 할 수없는 각 문자에 대해 목록에 아무 것도 입력되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0584fd8513f89a40217ccf8ebc3db4de8b547862" translate="yes" xml:space="preserve">
          <source>The loops argument controls how many times the sample will be repeated after being played the first time. A value of 5 means that the sound will be played once, then repeated five times, and so is played a total of six times. The default value (zero) means the Sound is not repeated, and so is only played once. If loops is set to -1 the Sound will loop indefinitely (though you can still call &lt;code&gt;stop()&lt;/code&gt; to stop it).</source>
          <target state="translated">loops 인수는 샘플이 처음 재생 된 후 샘플이 반복되는 횟수를 제어합니다. 값이 5이면 사운드가 한 번 재생 된 다음 5 번 반복되므로 총 6 번 재생됩니다. 기본값 (0)은 소리가 반복되지 않으므로 한 번만 재생됨을 의미합니다. 루프가 -1로 설정되면 사운드는 무한정 반복됩니다 (하지만 &lt;code&gt;stop()&lt;/code&gt; 을 호출 하여 중지 할 수는 있음).</target>
        </trans-unit>
        <trans-unit id="6e143cd390d2cb7058029d59dabf1448a8e784d0" translate="yes" xml:space="preserve">
          <source>The loops argument controls the number of repeats a music will play. &lt;code&gt;play(5)&lt;/code&gt; will cause the music to played once, then repeated five times, for a total of six. If the loops is -1 then the music will repeat indefinitely.</source>
          <target state="translated">loops 인수는 음악이 반복 할 횟수를 제어합니다. &lt;code&gt;play(5)&lt;/code&gt; 는 음악을 한 번 재생 한 다음 총 6 번 반복하여 5 번 반복합니다. 루프가 -1이면 음악이 무한정 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="74a18d5275f82f3e902ca3955e6ce2fa7d197ca5" translate="yes" xml:space="preserve">
          <source>The loops argument has the same meaning as in &lt;code&gt;Sound.play()&lt;/code&gt;: it is the number of times to repeat the sound after the first time. If it is 3, the sound will be played 4 times (the first time, then three more). If loops is -1 then the playback will repeat indefinitely.</source>
          <target state="translated">loops 인수는 &lt;code&gt;Sound.play()&lt;/code&gt; 와 동일한 의미를 갖 습니다. 처음 이후에 사운드를 반복하는 횟수입니다. 3이면 사운드가 4 번 재생됩니다 (처음에는 3 번). 루프가 -1이면 재생이 무한정 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="f9769521f53478bda6c16f5c307d6df693d072b7" translate="yes" xml:space="preserve">
          <source>The maxtime argument can be used to stop playback after a given number of milliseconds.</source>
          <target state="translated">maxtime 인수는 지정된 밀리 초 후에 재생을 중지하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d03756736c6491cb26402b0e52f66c5a49e5d1dd" translate="yes" xml:space="preserve">
          <source>The methods &lt;a href=&quot;#pygame.mask.Mask.overlap&quot;&gt;&lt;code&gt;overlap()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pygame.mask.Mask.overlap_area&quot;&gt;&lt;code&gt;overlap_area()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pygame.mask.Mask.overlap_mask&quot;&gt;&lt;code&gt;overlap_mask()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pygame.mask.Mask.draw&quot;&gt;&lt;code&gt;draw()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pygame.mask.Mask.erase&quot;&gt;&lt;code&gt;erase()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#pygame.mask.Mask.convolve&quot;&gt;&lt;code&gt;convolve()&lt;/code&gt;&lt;/a&gt; use an offset parameter to indicate the offset of another mask's top left corner from the calling mask's top left corner. The calling mask's top left corner is considered to be the origin &lt;code&gt;(0, 0)&lt;/code&gt;. Offsets are a tuple or list of 2 integer values &lt;code&gt;(x_offset, y_offset)&lt;/code&gt;. Positive and negative offset values are supported.</source>
          <target state="translated">&lt;a href=&quot;#pygame.mask.Mask.overlap_area&quot;&gt; &lt;code&gt;overlap_area()&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#pygame.mask.Mask.overlap&quot;&gt; &lt;code&gt;overlap()&lt;/code&gt; &lt;/a&gt; , duplicate_area () , &lt;a href=&quot;#pygame.mask.Mask.overlap_mask&quot;&gt; &lt;code&gt;overlap_mask()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#pygame.mask.Mask.draw&quot;&gt; &lt;code&gt;draw()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#pygame.mask.Mask.erase&quot;&gt; &lt;code&gt;erase()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#pygame.mask.Mask.convolve&quot;&gt; &lt;code&gt;convolve()&lt;/code&gt; &lt;/a&gt; 메서드 는 오프셋 마스크를 사용하여 호출 마스크의 왼쪽 상단 모서리에서 다른 마스크의 왼쪽 상단 모서리의 오프셋을 나타냅니다. 호출 마스크의 왼쪽 상단은 원점 &lt;code&gt;(0, 0)&lt;/code&gt; 간주됩니다 . 오프셋은 튜플 또는 2 개의 정수 값 &lt;code&gt;(x_offset, y_offset)&lt;/code&gt; 목록입니다 . 양수 및 음수 오프셋 값이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="6f2908fb3a195a7249c215a54378d7c6c26ed9e0" translate="yes" xml:space="preserve">
          <source>The metrics are adjusted for the current rotation, strong, and oblique settings.</source>
          <target state="translated">메트릭은 현재 회전, 강하고 비스듬한 설정에 맞게 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="72dd4dfc8506ee65e0c09f0dd7fca1071844a81a" translate="yes" xml:space="preserve">
          <source>The midi module can send output to midi devices and get input from midi devices. It can also list midi devices on the system.</source>
          <target state="translated">미디 모듈은 미디 장치로 출력을 보내고 미디 장치에서 입력을받을 수 있습니다. 또한 시스템의 미디 장치를 나열 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a96b4863a9d9d72ad4f3cd1a1373ff6ddd436ffb" translate="yes" xml:space="preserve">
          <source>The midi module supports real and virtual midi devices.</source>
          <target state="translated">미디 모듈은 실제 및 가상 미디 장치를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="0099f18f9321d4c4d1ef2f78d193e49602a4c2c3" translate="yes" xml:space="preserve">
          <source>The mixer also has a special streaming channel. This is for music playback and is accessed through the &lt;a href=&quot;music#module-pygame.mixer.music&quot;&gt;&lt;code&gt;pygame.mixer.music&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">믹서에는 또한 특별한 스트리밍 채널이 있습니다. 음악 재생 용이며 &lt;a href=&quot;music#module-pygame.mixer.music&quot;&gt; &lt;code&gt;pygame.mixer.music&lt;/code&gt; &lt;/a&gt; 모듈을 통해 액세스 합니다.</target>
        </trans-unit>
        <trans-unit id="612013d57c9974f7c119cf7d9a0dd1dbbc7d2d9d" translate="yes" xml:space="preserve">
          <source>The mixer can reserve any number of channels that will not be automatically selected for playback by Sounds. If sounds are currently playing on the reserved channels they will not be stopped.</source>
          <target state="translated">믹서는 사운드로 재생하기 위해 자동으로 선택되지 않는 채널 수를 예약 할 수 있습니다. 예약 된 채널에서 현재 사운드가 재생되고 있으면 중지되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="da418d3868013fe8a8a80725d3df378ec2128cf0" translate="yes" xml:space="preserve">
          <source>The mixer module has a limited number of channels for playback of sounds. Usually programs tell pygame to start playing audio and it selects an available channel automatically. The default is 8 simultaneous channels, but complex programs can get more precise control over the number of channels and their use.</source>
          <target state="translated">믹서 모듈에는 사운드 재생을위한 제한된 수의 채널이 있습니다. 일반적으로 프로그램은 파이 게임에게 오디오 재생을 시작하도록 지시하고 사용 가능한 채널을 자동으로 선택합니다. 기본값은 8 개의 동시 채널이지만 복잡한 프로그램은 채널 수와 사용을보다 정확하게 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba44d0d416f8dc002e181c3a53a18c8c2927ffd6" translate="yes" xml:space="preserve">
          <source>The mixer module must be initialized like other pygame modules, but it has some extra conditions. The &lt;code&gt;pygame.mixer.init()&lt;/code&gt; function takes several optional arguments to control the playback rate and sample size. Pygame will default to reasonable values, but pygame cannot perform Sound resampling, so the mixer should be initialized to match the values of your audio resources.</source>
          <target state="translated">믹서 모듈은 다른 파이 게임 모듈과 같이 초기화되어야하지만 추가 조건이 있습니다. &lt;code&gt;pygame.mixer.init()&lt;/code&gt; 함수는 재생 속도와 샘플 크기를 제어하는 여러 가지 옵션 인수를 사용합니다. 파이 게임은 기본적으로 적당한 값으로 설정되지만 파이 게임은 사운드 리샘플링을 수행 할 수 없으므로 오디오 리소스의 값과 일치하도록 믹서를 초기화해야합니다.</target>
        </trans-unit>
        <trans-unit id="9a081d88c5d2080c05b9b3382d89177f33e5c566" translate="yes" xml:space="preserve">
          <source>The module includes several standard cursors. The &lt;code&gt;pygame.mouse.set_cursor()&lt;/code&gt; function takes several arguments. All those arguments have been stored in a single tuple you can call like this:</source>
          <target state="translated">이 모듈에는 여러 표준 커서가 포함되어 있습니다. &lt;code&gt;pygame.mouse.set_cursor()&lt;/code&gt; 함수는 여러 인수를 취합니다. 이러한 모든 인수는 다음과 같이 호출 할 수있는 단일 튜플에 저장되었습니다.</target>
        </trans-unit>
        <trans-unit id="123be804b588b604571c451527161f00283ea1ea" translate="yes" xml:space="preserve">
          <source>The most useful flags to pass will be &lt;code&gt;pygame.HWSURFACE&lt;/code&gt;, &lt;code&gt;pygame.DOUBLEBUF&lt;/code&gt;, and maybe &lt;code&gt;pygame.FULLSCREEN&lt;/code&gt;. The function will return 0 if these display flags cannot be set.</source>
          <target state="translated">전달할 가장 유용한 플래그는 &lt;code&gt;pygame.HWSURFACE&lt;/code&gt; , &lt;code&gt;pygame.DOUBLEBUF&lt;/code&gt; 및 &lt;code&gt;pygame.FULLSCREEN&lt;/code&gt; 입니다. 이 디스플레이 플래그를 설정할 수 없으면이 함수는 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bc676a5ae816cfac8aa68674024ba3316545c060" translate="yes" xml:space="preserve">
          <source>The mouse functions can be used to get the current state of the mouse device. These functions can also alter the system cursor for the mouse.</source>
          <target state="translated">마우스 기능은 마우스 장치의 현재 상태를 얻는 데 사용될 수 있습니다. 이러한 기능은 마우스의 시스템 커서를 변경할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="810b32d00afc3982f9ba75aa19daa874bd2ebc69" translate="yes" xml:space="preserve">
          <source>The music module is closely tied to &lt;a href=&quot;mixer#module-pygame.mixer&quot;&gt;&lt;code&gt;pygame.mixer&lt;/code&gt;&lt;/a&gt;. Use the music module to control the playback of music in the sound mixer.</source>
          <target state="translated">음악 모듈은 &lt;a href=&quot;mixer#module-pygame.mixer&quot;&gt; &lt;code&gt;pygame.mixer&lt;/code&gt; &lt;/a&gt; 와 밀접하게 연결되어 있습니다. 사운드 모듈에서 음악 재생을 제어하려면 음악 모듈을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d5908df365dca27ef8ff5af1b1f89a84dad53262" translate="yes" xml:space="preserve">
          <source>The new Surface will inherit the palette, color key, and alpha settings from its parent.</source>
          <target state="translated">새로운 Surface는 부모의 팔레트, 색상 키 및 알파 설정을 상속합니다.</target>
        </trans-unit>
        <trans-unit id="c4c1b0a7c3c98698269b2f430cf406c49ed5eb71" translate="yes" xml:space="preserve">
          <source>The new copy will have the same class as the copied surface. This lets as Surface subclass inherit this method without the need to override, unless subclass specific instance attributes also need copying.</source>
          <target state="translated">새 사본은 복사 된 표면과 동일한 클래스를 갖습니다. 서브 클래스 특정 인스턴스 속성도 복사 할 필요가 없다면 Surface 서브 클래스는이 메소드를 재정의 할 필요없이 상속 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a65ceae8906d006af75ddc5c6bb2932d08cb8e9d" translate="yes" xml:space="preserve">
          <source>The next operation will be performed elementwise.</source>
          <target state="translated">다음 작업은 요소별로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="6f8dfc5dabced9313776c66a7dabd8aebcb8d131" translate="yes" xml:space="preserve">
          <source>The number of milliseconds that passed between the previous two calls to &lt;code&gt;Clock.tick()&lt;/code&gt;.</source>
          <target state="translated">이전 두 호출 사이에서 &lt;code&gt;Clock.tick()&lt;/code&gt; 전달 된 시간 (밀리 초 ) 입니다.</target>
        </trans-unit>
        <trans-unit id="921bda2cb77ad23a8350bab9431640aea2a04e94" translate="yes" xml:space="preserve">
          <source>The number of pixels that are within the 'threshold' in 'surf' compared to either 'search_color' or</source>
          <target state="translated">'surf'에서 'threshold'내에있는 'search_color'또는</target>
        </trans-unit>
        <trans-unit id="eb84148fc172ba86a793be129ed819841202836b" translate="yes" xml:space="preserve">
          <source>The number of the first device with a substring that matches the string exactly is returned. For example, if the string in the registry is &quot;USB&quot; and device 1 is named &quot;In USB MidiSport 1x1&quot;, then that will be the default input because it contains the string &quot;USB&quot;.</source>
          <target state="translated">문자열과 정확히 일치하는 부분 문자열이있는 첫 번째 장치의 번호가 반환됩니다. 예를 들어 레지스트리의 문자열이 &quot;USB&quot;이고 장치 1의 이름이 &quot;In USB MidiSport 1x1&quot;인 경우 문자열 &quot;USB&quot;가 포함되어 있기 때문에 기본 입력이됩니다.</target>
        </trans-unit>
        <trans-unit id="6e1fdb4958f6335eb447ed1f4ea6df4d5038056e" translate="yes" xml:space="preserve">
          <source>The number of valid bytes of data exported. For discontinuous data, that is data which is not a single block of memory, the bytes within the gaps are excluded from the count. This property is equivalent to the &lt;code&gt;Py_buffer&lt;/code&gt; C struct &lt;code&gt;len&lt;/code&gt; field.</source>
          <target state="translated">내 보낸 유효한 데이터 바이트 수입니다. 불연속 데이터, 즉 단일 메모리 블록이 아닌 데이터의 경우 간격 내의 바이트가 카운트에서 제외됩니다. 이 프로퍼티는 &lt;code&gt;Py_buffer&lt;/code&gt; C 구조체 &lt;code&gt;len&lt;/code&gt; 필드 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="f749e3c5115c1ee1c0bde8398710521b1c1a678c" translate="yes" xml:space="preserve">
          <source>The oblique style is only supported for scalable (outline) fonts. An attempt to set this style on a bitmap font will raise an AttributeError. If the font object is inactive, as returned by &lt;code&gt;Font.__new__()&lt;/code&gt;, setting this property raises a RuntimeError.</source>
          <target state="translated">오블 리크 스타일은 확장 가능한 (개요) 글꼴에만 지원됩니다. 비트 맵 글꼴에서이 스타일을 설정하려고하면 AttributeError가 발생합니다. Font 객체가 비활성 상태 인 경우 &lt;code&gt;Font.__new__()&lt;/code&gt; 에서 반환 한대로이 속성을 설정하면 RuntimeError가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f598cefc9c8fde71c0de87d3e50d0d463858dd2c" translate="yes" xml:space="preserve">
          <source>The optional &lt;em&gt;resolution&lt;/em&gt; argument sets the pixel size, in dots per inch, for use in scaling glyphs for this Font instance. If 0 then the default module value, set by &lt;a href=&quot;#pygame.freetype.init&quot;&gt;&lt;code&gt;init()&lt;/code&gt;&lt;/a&gt;, is used. The Font object's resolution can only be changed by re-initializing the Font instance.</source>
          <target state="translated">선택적 &lt;em&gt;해상도&lt;/em&gt; 인수는이 Font 인스턴스의 글리프 스케일링에 사용하기 위해 픽셀 크기를 인치당 도트 수로 설정합니다. 0이면 &lt;a href=&quot;#pygame.freetype.init&quot;&gt; &lt;code&gt;init()&lt;/code&gt; &lt;/a&gt; 의해 설정된 기본 모듈 값 이 사용됩니다. Font 객체의 해상도는 Font 인스턴스를 다시 초기화해야만 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f530be39b4e762388d8ce5a02a580a4d1e533f12" translate="yes" xml:space="preserve">
          <source>The optional &lt;em&gt;ucs4&lt;/em&gt; argument, an integer, sets the default text translation mode: 0 (False) recognize UTF-16 surrogate pairs, any other value (True), to treat Unicode text as UCS-4, with no surrogate pairs. See &lt;a href=&quot;#pygame.freetype.Font.ucs4&quot;&gt;&lt;code&gt;Font.ucs4&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">선택적 &lt;em&gt;ucs4&lt;/em&gt; 인수 인 정수는 기본 텍스트 변환 모드를 설정합니다. 0 (False) 서로 다른 값 (True) 인 UTF-16 서로 게이트 쌍을 인식하여 서로 게이트 쌍없이 유니 코드 텍스트를 UCS-4로 처리합니다. &lt;a href=&quot;#pygame.freetype.Font.ucs4&quot;&gt; &lt;code&gt;Font.ucs4&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c29dceb7ce7bef4470f16fa2eb330a5b75134755" translate="yes" xml:space="preserve">
          <source>The optional flags argument can be set to &lt;code&gt;pygame.RLEACCEL&lt;/code&gt; to provide better performance on non accelerated displays. An &lt;code&gt;RLEACCEL&lt;/code&gt; Surface will be slower to modify, but quicker to blit as a source.</source>
          <target state="translated">선택적 flags 인수는 &lt;code&gt;pygame.RLEACCEL&lt;/code&gt; 로 설정하여 가속되지 않은 디스플레이에서 더 나은 성능을 제공 할 수 있습니다 . &lt;code&gt;RLEACCEL&lt;/code&gt; 의 표면이 소스로 블릿에 빨리 수정 느려질 수 있지만 것입니다.</target>
        </trans-unit>
        <trans-unit id="4e70dad67a7ebe854621c9046290083515e304ad" translate="yes" xml:space="preserve">
          <source>The origin of the display, where x = 0 and y = 0, is the top left of the screen. Both axes increase positively towards the bottom right of the screen.</source>
          <target state="translated">x = 0 및 y = 0 인 디스플레이의 원점은 화면의 왼쪽 상단입니다. 두 축 모두 화면 오른쪽 하단으로 양수로 증가합니다.</target>
        </trans-unit>
        <trans-unit id="7e015749346d132fd4d81efd6d1951e2d392410f" translate="yes" xml:space="preserve">
          <source>The output example shows how to translate mouse clicks or computer keyboard events into midi notes. It implements a rudimentary button widget and state machine.</source>
          <target state="translated">출력 예제는 마우스 클릭 또는 컴퓨터 키보드 이벤트를 미디 노트로 변환하는 방법을 보여줍니다. 기본적인 버튼 위젯과 상태 머신을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="0faf082c7adb675a60c75e25f409de87052b1d5b" translate="yes" xml:space="preserve">
          <source>The overlay objects are always visible, and always show above the regular display contents.</source>
          <target state="translated">오버레이 객체는 항상 표시되며 항상 일반 표시 내용 위에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="7794711bb9a6e9a1269cd63f884b90b844509b95" translate="yes" xml:space="preserve">
          <source>The physical buffer start address and a read-only flag as a length 2 tuple. The address is an integer value, while the read-only flag is a bool&amp;mdash;&lt;code&gt;False&lt;/code&gt; for writable, &lt;code&gt;True&lt;/code&gt; for read-only.</source>
          <target state="translated">물리적 버퍼 시작 주소 및 길이 2 튜플로서의 읽기 전용 플래그. 주소는 정수 값이고 읽기 전용 플래그는 부울 입니다. 쓰기 가능하면 &lt;code&gt;False&lt;/code&gt; , 읽기 전용 이면 &lt;code&gt;True&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b5487dbb3bc59d337c8ffa6a5e672842d1d8e79a" translate="yes" xml:space="preserve">
          <source>The pixel format can be controlled by passing the bit depth or an existing Surface. The flags argument is a bitmask of additional features for the surface. You can pass any combination of these flags:</source>
          <target state="translated">비트 심도 또는 기존 Surface를 전달하여 픽셀 형식을 제어 할 수 있습니다. flags 인자는 표면에 대한 추가 기능의 비트 마스크입니다. 이 플래그들의 조합을 전달할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="2322e9b5a33c7c1ca835b58396daa909c4a82dc2" translate="yes" xml:space="preserve">
          <source>The pygame display can actually be initialized in one of several modes. By default, the display is a basic software driven framebuffer. You can request special modules like hardware acceleration and OpenGL support. These are controlled by flags passed to &lt;code&gt;pygame.display.set_mode()&lt;/code&gt;.</source>
          <target state="translated">파이 게임 디스플레이는 실제로 여러 모드 중 하나로 초기화 될 수 있습니다. 기본적으로 디스플레이는 기본 소프트웨어 기반 프레임 버퍼입니다. 하드웨어 가속 및 OpenGL 지원과 같은 특수 모듈을 요청할 수 있습니다. 이것들은 &lt;code&gt;pygame.display.set_mode()&lt;/code&gt; 전달 된 플래그에 의해 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="37391a0bd3e84daec2e21c3c705550a233506fac" translate="yes" xml:space="preserve">
          <source>The pygame math module currently provides Vector classes in two and three dimensions, Vector2 and Vector3 respectively.</source>
          <target state="translated">파이 게임 수학 모듈은 현재 2 차원과 3 차원으로 각각 Vector2와 Vector3의 Vector 클래스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9cb858fd458742e0121a058a94e9c193ee8d7737" translate="yes" xml:space="preserve">
          <source>The pygame package does not import &lt;code&gt;freetype&lt;/code&gt; automatically when loaded. This module must be imported explicitly to be used.</source>
          <target state="translated">파이 게임 패키지는 가져 오지 않습니다 &lt;code&gt;freetype&lt;/code&gt; 로드 할 때 자동으로. 이 모듈을 사용하려면 명시 적으로 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="7b06e5adc247132456cccb6fd96dca2be6b23ff1" translate="yes" xml:space="preserve">
          <source>The pygame package represents the top-level package for others to use. Pygame itself is broken into many submodules, but this does not affect programs that use pygame.</source>
          <target state="translated">파이 게임 패키지는 다른 사람들이 사용할 수있는 최상위 패키지를 나타냅니다. 파이 게임 자체는 여러 하위 모듈로 나뉘어 있지만 파이 게임을 사용하는 프로그램에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b373b2b94a87c61633f0c2426bf90b87f1739d03" translate="yes" xml:space="preserve">
          <source>The pygame.gfxdraw module differs from the draw module in the API it uses, and also the different functions available to draw. It also wraps the primitives from the library called SDL_gfx, rather than using modified versions.</source>
          <target state="translated">pygame.gfxdraw 모듈은 사용하는 API의 draw 모듈과 다른 기능을 제공합니다. 또한 수정 된 버전을 사용하지 않고 SDL_gfx라는 라이브러리에서 프리미티브를 랩핑합니다.</target>
        </trans-unit>
        <trans-unit id="6fc04ebe0d2835e8aa96c12d6358f4feb300d92e" translate="yes" xml:space="preserve">
          <source>The red value of the Color.</source>
          <target state="translated">색상의 빨간색 값입니다.</target>
        </trans-unit>
        <trans-unit id="8529a080543def59f110363ee04879fbb0b38117" translate="yes" xml:space="preserve">
          <source>The return rectangle is the area of the affected pixels, excluding any pixels outside the destination Surface, or outside the clipping area.</source>
          <target state="translated">반환 사각형은 대상 표면 외부 또는 클리핑 영역 외부의 픽셀을 제외한 영향을받는 픽셀의 영역입니다.</target>
        </trans-unit>
        <trans-unit id="b698f381848f2fc3f76f413645520088218d01a1" translate="yes" xml:space="preserve">
          <source>The return value cursor_args can be passed directly to the &lt;code&gt;pygame.mouse.set_cursor()&lt;/code&gt; function.</source>
          <target state="translated">반환 값 cursor_args는 &lt;code&gt;pygame.mouse.set_cursor()&lt;/code&gt; 함수에 직접 전달 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b0e27eb92222d5746e21e8c10d8e8640a6cc6e10" translate="yes" xml:space="preserve">
          <source>The return value is a rectangle giving the size and position of the rendered text within the surface.</source>
          <target state="translated">반환 값은 표면 내에서 렌더링 된 텍스트의 크기와 위치를 제공하는 사각형입니다.</target>
        </trans-unit>
        <trans-unit id="ecef11ce5adef4b4bee2e2d9b73e7b92eaa39a68" translate="yes" xml:space="preserve">
          <source>The return value is a tuple: the new surface and the bounding rectangle giving the size and origin of the rendered text.</source>
          <target state="translated">반환 값은 튜플입니다. 새 표면 및 렌더링 된 텍스트의 크기와 원점을 제공하는 경계 사각형입니다.</target>
        </trans-unit>
        <trans-unit id="111a48808b5fb964f795c892640f6edb150e03b1" translate="yes" xml:space="preserve">
          <source>The returned Rect list should be passed to &lt;code&gt;pygame.display.update()&lt;/code&gt;. This will help performance on software driven display modes. This type of updating is usually only helpful on destinations with non-animating backgrounds.</source>
          <target state="translated">반환 된 Rect리스트는 &lt;code&gt;pygame.display.update()&lt;/code&gt; 로 전달되어야합니다 . 이것은 소프트웨어 구동 디스플레이 모드에서 성능을 향상시키는 데 도움이됩니다. 이 유형의 업데이트는 일반적으로 애니메이션이 아닌 배경이있는 대상에서만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="84f7898284ffd83878fd50c3c8c91d640263e33c" translate="yes" xml:space="preserve">
          <source>The returned Surface will contain the same color format, colorkey and alpha transparency as the file it came from. You will often want to call &lt;code&gt;Surface.convert()&lt;/code&gt; with no arguments, to create a copy that will draw more quickly on the screen.</source>
          <target state="translated">반환 된 Surface에는 파일과 동일한 색상 형식, 컬러 키 및 알파 투명도가 포함됩니다. 화면에 더 빨리 그릴 사본을 만들기 위해 인수없이 &lt;code&gt;Surface.convert()&lt;/code&gt; 를 호출하는 경우가 종종 있습니다.</target>
        </trans-unit>
        <trans-unit id="06fd2ce0cfa6de20bb79ca8a87331a56db21bd3e" translate="yes" xml:space="preserve">
          <source>The same as the &lt;code&gt;Rect.unionall()&lt;/code&gt; method, but operates in place.</source>
          <target state="translated">&lt;code&gt;Rect.unionall()&lt;/code&gt; 메서드 와 동일 하지만 제대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="e13d8d5a4aeb9142f8599a6b14e6479599afce74" translate="yes" xml:space="preserve">
          <source>The scaled ascent of the font in pixels</source>
          <target state="translated">픽셀 단위의 글꼴 크기 조정</target>
        </trans-unit>
        <trans-unit id="74c1f2bb44bae26edc4e54c9667f81d03360ab6a" translate="yes" xml:space="preserve">
          <source>The scaled bounding box height of the font in pixels</source>
          <target state="translated">폰트의 스케일 바운딩 박스의 높이 (픽셀 단위)</target>
        </trans-unit>
        <trans-unit id="01e7c186250f238874e2440a957eaa81753e18bb" translate="yes" xml:space="preserve">
          <source>The scaled descent of the font in pixels</source>
          <target state="translated">픽셀 단위의 폰트 크기 조정</target>
        </trans-unit>
        <trans-unit id="99abed56a28bee582004055d999861e5c442e26f" translate="yes" xml:space="preserve">
          <source>The scaled height of the font in pixels</source>
          <target state="translated">폰트의 스케일 높이 (픽셀 단위)</target>
        </trans-unit>
        <trans-unit id="3cb3a65de526c606c0c62cd7657c57f64a35db33" translate="yes" xml:space="preserve">
          <source>The scrap module is currently only supported for Windows, X11 and Mac OS X. On Mac OS X only text works at the moment - other types may be supported in future releases.</source>
          <target state="translated">스크랩 모듈은 현재 Windows, X11 및 Mac OS X에서만 지원됩니다. Mac OS X에서는 현재 텍스트 만 작동합니다. 이후 릴리스에서는 다른 유형이 지원 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af4337720e727f69e1d4b79bd11c650e0a3ca719" translate="yes" xml:space="preserve">
          <source>The scrap module is for transferring data to/from the clipboard. This allows for cutting and pasting data between pygame and other applications. Some basic data (MIME) types are defined and registered:</source>
          <target state="translated">스크랩 모듈은 클립 보드와 데이터를주고받는 데 사용됩니다. 이를 통해 파이 게임과 다른 응용 프로그램간에 데이터를 잘라 붙여 넣을 수 있습니다. 일부 기본 데이터 (MIME) 유형이 정의되고 등록됩니다.</target>
        </trans-unit>
        <trans-unit id="6b7e4d78a5526e87e80c73de6f12832218547b97" translate="yes" xml:space="preserve">
          <source>The scrap module requires &lt;a href=&quot;display#pygame.display.set_mode&quot;&gt;&lt;code&gt;pygame.display.set_mode()&lt;/code&gt;&lt;/a&gt; be called before being initialized.</source>
          <target state="translated">스크랩 모듈은 초기화하기 전에 &lt;a href=&quot;display#pygame.display.set_mode&quot;&gt; &lt;code&gt;pygame.display.set_mode()&lt;/code&gt; &lt;/a&gt; 를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="f959f7beb05fca77e86a81859884588e5e3a2666" translate="yes" xml:space="preserve">
          <source>The size and format image must compute the exact same size as the passed string buffer. Otherwise an exception will be raised.</source>
          <target state="translated">크기 및 형식 이미지는 전달 된 문자열 버퍼와 정확히 동일한 크기를 계산해야합니다. 그렇지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c273b32fdd0d85f6a47b420fb8b5a7b6ae3ef166" translate="yes" xml:space="preserve">
          <source>The size argument is a pair of numbers representing the width and height. The flags argument is a collection of additional options. The depth argument represents the number of bits to use for color.</source>
          <target state="translated">size 인수는 너비와 높이를 나타내는 숫자 쌍입니다. flags 인수는 추가 옵션의 모음입니다. 심도 인수는 색상에 사용할 비트 수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="49fc4649bbffe9820c9508e7efe16289710dddd1" translate="yes" xml:space="preserve">
          <source>The size argument represents how many bits are used for each audio sample. If the value is negative then signed sample values will be used. Positive values mean unsigned audio samples will be used. An invalid value raises an exception.</source>
          <target state="translated">size 인수는 각 오디오 샘플에 사용되는 비트 수를 나타냅니다. 값이 음수이면 부호있는 샘플 값이 사용됩니다. 양수 값은 서명되지 않은 오디오 샘플이 사용됨을 의미합니다. 유효하지 않은 값은 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="5410cd41bcb7ced66440ef6bb80957746923e119" translate="yes" xml:space="preserve">
          <source>The size, in bytes, of the exported buffer.</source>
          <target state="translated">내 보낸 버퍼의 크기 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="11ed2a6a4ffda60e436822510a32aa824fc6dc44" translate="yes" xml:space="preserve">
          <source>The starting address of the surface's raw pixel bytes.</source>
          <target state="translated">표면의 원시 픽셀 바이트의 시작 주소입니다.</target>
        </trans-unit>
        <trans-unit id="54751895485e5ebfee878f68f95f779e8cd3703d" translate="yes" xml:space="preserve">
          <source>The starting position argument controls where in the music the song starts playing. The starting position is dependent on the format of music playing. &lt;code&gt;MP3&lt;/code&gt; and &lt;code&gt;OGG&lt;/code&gt; use the position as time (in seconds). &lt;code&gt;MOD&lt;/code&gt; music it is the pattern order number. Passing a startpos will raise a NotImplementedError if it cannot set the start position</source>
          <target state="translated">시작 위치 인수는 음악에서 노래 재생이 시작되는 위치를 제어합니다. 시작 위치는 음악 재생 형식에 따라 다릅니다. &lt;code&gt;MP3&lt;/code&gt; 및 &lt;code&gt;OGG&lt;/code&gt; 는 위치를 시간 (초)으로 사용합니다. &lt;code&gt;MOD&lt;/code&gt; 음악은 패턴 주문 번호입니다. 시작 위치를 전달하면 시작 위치를 설정할 수없는 경우 NotImplementedError가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d1ad96d38049e18a9d5cc2812d234ece95b0c0ac" translate="yes" xml:space="preserve">
          <source>The state of the font's oblique style flag</source>
          <target state="translated">폰트의 오블 리크 스타일 플래그 상태</target>
        </trans-unit>
        <trans-unit id="01d72d2dd075b2b3444f5f165b64c94566cc560d" translate="yes" xml:space="preserve">
          <source>The state of the font's strong style flag</source>
          <target state="translated">글꼴의 강력한 스타일 플래그 상태</target>
        </trans-unit>
        <trans-unit id="d04466b2d9d7476877e3cf428246e747465a31d4" translate="yes" xml:space="preserve">
          <source>The state of the font's underline style flag</source>
          <target state="translated">폰트의 밑줄 스타일 플래그의 상태</target>
        </trans-unit>
        <trans-unit id="fece8987ce6044fab6652a81f0b4ba5ca3915c12" translate="yes" xml:space="preserve">
          <source>The state of the font's wide style flag</source>
          <target state="translated">글꼴의 넓은 스타일 플래그 상태</target>
        </trans-unit>
        <trans-unit id="41b3f506a9930584e756721d227b74fd4591c126" translate="yes" xml:space="preserve">
          <source>The strength associated with the strong or wide font styles</source>
          <target state="translated">강력하거나 넓은 글꼴 스타일과 관련된 강도</target>
        </trans-unit>
        <trans-unit id="aeeffe21aa580c7e7d56e438629e39e0859d0b83" translate="yes" xml:space="preserve">
          <source>The strength style is only supported for scalable (outline) fonts. An attempt to set this property on a bitmap font will raise an AttributeError. If the font object is inactive, as returned by &lt;code&gt;Font.__new__()&lt;/code&gt;, assignment to this property raises a RuntimeError.</source>
          <target state="translated">강도 스타일은 확장 가능 (개요) 글꼴에만 지원됩니다. 비트 맵 글꼴에서이 속성을 설정하려고하면 AttributeError가 발생합니다. Font 객체가 비활성 상태 인 경우 &lt;code&gt;Font.__new__()&lt;/code&gt; 에서 반환 한대로이 속성에 할당하면 RuntimeError가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="061351928b127ee692f8088eb0c9ad9854176551" translate="yes" xml:space="preserve">
          <source>The strings are not validated, and improperly sized strings could crash the program.</source>
          <target state="translated">문자열의 유효성이 검사되지 않았으며 크기가 잘못된 문자열로 인해 프로그램이 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0909cb2289160c179558bf431791b31b1cc8b4d2" translate="yes" xml:space="preserve">
          <source>The surface is locked only when an exposed interface is accessed. For new buffer interface accesses, the surface is unlocked once the last buffer view is released. For array interface and old buffer interface accesses, the surface remains locked until the BufferProxy object is released.</source>
          <target state="translated">노출 된 인터페이스에 액세스 한 경우에만 표면이 잠 깁니다. 새로운 버퍼 인터페이스 액세스의 경우 마지막 버퍼 뷰가 해제되면 표면이 잠금 해제됩니다. 어레이 인터페이스 및 이전 버퍼 인터페이스 액세스의 경우 BufferProxy 객체가 해제 될 때까지 표면이 잠겨 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ced80d380e2dade0f055937269469c62b19e570" translate="yes" xml:space="preserve">
          <source>The surface_to_array function copies pixels from a Surface object to a 2D or 3D array. Depending on argument &lt;code&gt;kind&lt;/code&gt; and the target array dimension, a copy may be raw pixel value, RGB, a color component slice, or colorkey alpha transparency value. Recognized &lt;code&gt;kind&lt;/code&gt; values are the single character codes 'P', 'R', 'G', 'B', 'A', and 'C'. Kind codes are case insensitive, so 'p' is equivalent to 'P'. The first two dimensions of the target must be the surface size (w, h).</source>
          <target state="translated">surface_to_array 함수는 Surface 객체의 픽셀을 2D 또는 3D 배열로 복사합니다. 인수 &lt;code&gt;kind&lt;/code&gt; 및 대상 배열 차원에 따라 복사본은 원시 픽셀 값, RGB, 색상 구성 요소 슬라이스 또는 색상 키 알파 투명도 값일 수 있습니다. 인식되는 &lt;code&gt;kind&lt;/code&gt; 값은 단일 문자 코드 'P', 'R', 'G', 'B', 'A'및 'C'입니다. 종류 코드는 대소 문자를 구분하지 않으므로 'p'는 'P'와 같습니다. 대상의 처음 두 치수는 표면 크기 (w, h) 여야합니다.</target>
        </trans-unit>
        <trans-unit id="3dc86cefc0dc0faebdde54f8d38707d0e734e6fb" translate="yes" xml:space="preserve">
          <source>The text can only be a single line: newline characters are not rendered. Null characters ('x00') raise a TypeError. Both Unicode and char (byte) strings are accepted. For Unicode strings only UCS-2 characters ('u0001' to 'uFFFF') are recognized. Anything greater raises a UnicodeError. For char strings a &lt;code&gt;LATIN1&lt;/code&gt; encoding is assumed. The antialias argument is a boolean: if true the characters will have smooth edges. The color argument is the color of the text [e.g.: (0,0,255) for blue]. The optional background argument is a color to use for the text background. If no background is passed the area outside the text will be transparent.</source>
          <target state="translated">텍스트는 한 줄만 가능합니다. 줄 바꿈 문자는 렌더링되지 않습니다. 널 문자 ( 'x00')는 TypeError를 발생시킵니다. 유니 코드 및 문자 (바이트) 문자열이 모두 허용됩니다. 유니 코드 문자열의 경우 UCS-2 문자 ( 'u0001'~ 'uFFFF') 만 인식됩니다. 더 큰 것은 UnicodeError를 발생시킵니다. 문자 스트링의 경우 &lt;code&gt;LATIN1&lt;/code&gt; 인코딩이 가정됩니다. 앤티 앨리어스 인수는 부울입니다. true 인 경우 문자의 가장자리가 부드럽습니다. 색상 인수는 텍스트의 색상입니다 (예 : 파란색의 경우 (0,0,255)). 선택적 배경 인수는 텍스트 배경에 사용할 색상입니다. 배경이 전달되지 않으면 텍스트 외부 영역이 투명 해집니다.</target>
        </trans-unit>
        <trans-unit id="987ad050b9a78f2b19d74bb118af4ab7246e6bec" translate="yes" xml:space="preserve">
          <source>The time is reset to 0 when the &lt;a href=&quot;#module-pygame.midi&quot;&gt;&lt;code&gt;pygame.midi&lt;/code&gt;&lt;/a&gt; module is initialized.</source>
          <target state="translated">&lt;a href=&quot;#module-pygame.midi&quot;&gt; &lt;code&gt;pygame.midi&lt;/code&gt; &lt;/a&gt; 모듈이 초기화 되면 시간이 0으로 재설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="25666ca14cb0f1224b0eed140843f32edf77be8e" translate="yes" xml:space="preserve">
          <source>The two angle arguments are given in radians and indicate the start and stop positions of the arc. The arc is drawn in a counterclockwise direction from the &lt;code&gt;start_angle&lt;/code&gt; to the &lt;code&gt;stop_angle&lt;/code&gt;.</source>
          <target state="translated">두 개의 각도 인수는 라디안으로 표시되며 호의 시작 및 정지 위치를 나타냅니다. 아크는에서 반 시계 방향으로 그려진 &lt;code&gt;start_angle&lt;/code&gt; 받는 &lt;code&gt;stop_angle&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ae95db6c0ad42e0474dae065290aea6a2e42852b" translate="yes" xml:space="preserve">
          <source>The type argument will be the event id sent to the queue. This can be any valid event type, but a good choice would be a value between &lt;code&gt;pygame.locals.USEREVENT&lt;/code&gt; and &lt;code&gt;pygame.locals.NUMEVENTS&lt;/code&gt;. If no type argument is given then the Channel will stop sending endevents.</source>
          <target state="translated">type 인수는 큐에 전송 된 이벤트 ID입니다. 유효한 이벤트 유형이 될 수 있지만 &lt;code&gt;pygame.locals.USEREVENT&lt;/code&gt; 와 &lt;code&gt;pygame.locals.NUMEVENTS&lt;/code&gt; 사이의 값을 선택하는 것이 좋습니다 . 유형 인수가 제공되지 않으면 채널은 종료 이벤트 전송을 중지합니다.</target>
        </trans-unit>
        <trans-unit id="7503d3b6b58fa2b41235b8cadc7df6ae73e8c13c" translate="yes" xml:space="preserve">
          <source>The unscaled ascent of the font in font units</source>
          <target state="translated">폰트 단위로 폰트의 크기가 조절되지 않은 상승</target>
        </trans-unit>
        <trans-unit id="52c228a8b53861821a7651791ba3d4de34a3fd03" translate="yes" xml:space="preserve">
          <source>The unscaled descent of the font in font units</source>
          <target state="translated">폰트 단위로 폰트의 비 스케일 하강</target>
        </trans-unit>
        <trans-unit id="b20c86f3121c32aca6536a844cede43510d2a717" translate="yes" xml:space="preserve">
          <source>The unscaled height of the font in font units</source>
          <target state="translated">폰트 단위의 폰트의 크기 조정되지 않은 높이</target>
        </trans-unit>
        <trans-unit id="f82b239d7911ea75e1754e3bd6f95bef350a614d" translate="yes" xml:space="preserve">
          <source>The user should first determine the available device ID by using the supplied application &quot;testin&quot; or &quot;testout&quot;.</source>
          <target state="translated">사용자는 먼저 제공된 응용 프로그램 &quot;testin&quot;또는 &quot;testout&quot;을 사용하여 사용 가능한 장치 ID를 결정해야합니다.</target>
        </trans-unit>
        <trans-unit id="c7f1901f94aa510b7935486fa3eb50304275d709" translate="yes" xml:space="preserve">
          <source>The width and height arguments control the size for the overlay image data. The overlay image can be displayed at any size, not just the resolution of the overlay.</source>
          <target state="translated">너비 및 높이 인수는 오버레이 이미지 데이터의 크기를 제어합니다. 오버레이 이미지는 오버레이 해상도뿐만 아니라 모든 크기로 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7fa272175cfe7bfdc8265a42e024518256236e45" translate="yes" xml:space="preserve">
          <source>The width of the strings must all be equal and be divisible by 8. An example set of cursor strings looks like this</source>
          <target state="translated">문자열의 너비는 모두 같아야하고 8로 나눌 수 있어야합니다. 커서 문자열의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="392e65d90f2bd066dec984ad59255f12f958b0e5" translate="yes" xml:space="preserve">
          <source>The xxxx_test submodules of the tests package are unit test suites for individual parts of pygame. Each can also be run as a main program. This is useful if the test, such as cdrom_test, is interactive.</source>
          <target state="translated">테스트 패키지의 xxxx_test 하위 모듈은 파이 게임의 개별 부분에 대한 단위 테스트 스위트입니다. 각각은 기본 프로그램으로 실행할 수도 있습니다. cdrom_test와 같은 테스트가 대화식 인 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="f04d138c146511fd6571850b95925a3043994107" translate="yes" xml:space="preserve">
          <source>There are important things that must be dealt with internally in the event queue. The main window may need to be repainted or respond to the system. If you fail to make a call to the event queue for too long, the system may decide your program has locked up.</source>
          <target state="translated">이벤트 큐에서 내부적으로 처리해야하는 중요한 사항이 있습니다. 주 창을 다시 칠하거나 시스템에 응답해야 할 수도 있습니다. 이벤트 큐를 너무 오랫동안 호출하지 않으면 시스템이 프로그램이 잠 겼음을 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bf73bbade4625c49225a1c3dc7a539f1d7cc3c6" translate="yes" xml:space="preserve">
          <source>There are many keyboard constants, they are used to represent keys on the keyboard. The following is a list of all keyboard constants:</source>
          <target state="translated">많은 키보드 상수가 있으며 키보드의 키를 나타내는 데 사용됩니다. 다음은 모든 키보드 상수 목록입니다.</target>
        </trans-unit>
        <trans-unit id="6d5cb66369277b3d1abfa10f309967928df80da0" translate="yes" xml:space="preserve">
          <source>There are several collision tests between other rectangles. Most python containers can be searched for collisions against a single Rect.</source>
          <target state="translated">다른 사각형 사이에는 몇 가지 충돌 테스트가 있습니다. 대부분의 파이썬 컨테이너는 단일 Rect에 대한 충돌을 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53b89fade169e3fa0572ca2240c7e65d43bcc21c" translate="yes" xml:space="preserve">
          <source>There are several ways to run the examples. First they can be run as stand-alone programs. Second they can be imported and their &lt;code&gt;main()&lt;/code&gt; methods called (see below). Finally, the easiest way is to use the python -m option:</source>
          <target state="translated">예제를 실행하는 방법에는 여러 가지가 있습니다. 먼저 독립형 프로그램으로 실행할 수 있습니다. 두 번째로 가져오고 &lt;code&gt;main()&lt;/code&gt; 메소드를 호출 할 수 있습니다 (아래 참조). 마지막으로 가장 쉬운 방법은 python -m 옵션을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8f8a40e9bd68019a696a736ef90fe4661558a8d4" translate="yes" xml:space="preserve">
          <source>There are three types of transparency supported in pygame: colorkeys, surface alphas, and pixel alphas. Surface alphas can be mixed with colorkeys, but an image with per pixel alphas cannot use the other modes. Colorkey transparency makes a single color value transparent. Any pixels matching the colorkey will not be drawn. The surface alpha value is a single value that changes the transparency for the entire image. A surface alpha of 255 is opaque, and a value of 0 is completely transparent.</source>
          <target state="translated">파이 게임에서는 3 가지 유형의 투명도 (컬러 키, 표면 알파 및 픽셀 알파)가 지원됩니다. 표면 알파는 컬러 키와 혼합 될 수 있지만 픽셀 당 알파가있는 이미지는 다른 모드를 사용할 수 없습니다. 컬러 키 투명도는 단일 색상 값을 투명하게 만듭니다. 컬러 키와 일치하는 픽셀은 그려지지 않습니다. 표면 알파 값은 전체 이미지의 투명도를 변경하는 단일 값입니다. 255의 표면 알파는 불투명하고 0의 값은 완전히 투명합니다.</target>
        </trans-unit>
        <trans-unit id="ce4b29356a3acf855edbf14eee7131b45fadd31e" translate="yes" xml:space="preserve">
          <source>There is a special property, &lt;code&gt;GroupSingle.sprite&lt;/code&gt;, that accesses the Sprite that this Group contains. It can be None when the Group is empty. The property can also be assigned to add a Sprite into the GroupSingle container.</source>
          <target state="translated">이 그룹에 포함 된 Sprite에 액세스 하는 특수 속성 &lt;code&gt;GroupSingle.sprite&lt;/code&gt; 가 있습니다. 그룹이 비어 있으면 None이 될 수 있습니다. Sprite를 GroupSingle 컨테이너에 추가하도록 속성을 할당 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2f1cfa5d89fb20efb4144a8d48837af9e4f37df" translate="yes" xml:space="preserve">
          <source>There is no need to use this method if not using the convenience method by the same name in the Group class.</source>
          <target state="translated">Group 클래스에서 같은 이름으로 편리한 메소드를 사용하지 않는 경우이 메소드를 사용할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5b34ad6806452847087833243ebba6c3360991de" translate="yes" xml:space="preserve">
          <source>There is no way to get the return value from the &lt;code&gt;Sprite.update()&lt;/code&gt; methods.</source>
          <target state="translated">&lt;code&gt;Sprite.update()&lt;/code&gt; 메서드 에서 반환 값을 가져올 수있는 방법이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="662bfe880a28afb01b3f72fcfb8360f53b609634" translate="yes" xml:space="preserve">
          <source>There is support for pixel access for the Surfaces. Pixel access on hardware surfaces is slow and not recommended. Pixels can be accessed using the &lt;a href=&quot;#pygame.Surface.get_at&quot;&gt;&lt;code&gt;get_at()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#pygame.Surface.set_at&quot;&gt;&lt;code&gt;set_at()&lt;/code&gt;&lt;/a&gt; functions. These methods are fine for simple access, but will be considerably slow when doing of pixel work with them. If you plan on doing a lot of pixel level work, it is recommended to use a &lt;a href=&quot;pixelarray#pygame.PixelArray&quot;&gt;&lt;code&gt;pygame.PixelArray&lt;/code&gt;&lt;/a&gt;, which gives an array like view of the surface. For involved mathematical manipulations try the &lt;a href=&quot;surfarray#module-pygame.surfarray&quot;&gt;&lt;code&gt;pygame.surfarray&lt;/code&gt;&lt;/a&gt; module (It's quite quick, but requires NumPy.)</source>
          <target state="translated">Surface에 대한 픽셀 액세스가 지원됩니다. 하드웨어 표면에서의 픽셀 액세스는 느리고 권장되지 않습니다. &lt;a href=&quot;#pygame.Surface.get_at&quot;&gt; &lt;code&gt;get_at()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#pygame.Surface.set_at&quot;&gt; &lt;code&gt;set_at()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 픽셀에 액세스 할 수 있습니다 . 이러한 방법은 간단한 액세스에는 적합하지만 픽셀 작업을 할 때는 상당히 느립니다. 픽셀 수준의 작업을 많이 할 계획이라면 표면과 같은 배열을 제공하는 &lt;a href=&quot;pixelarray#pygame.PixelArray&quot;&gt; &lt;code&gt;pygame.PixelArray&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다 . 관련된 수학적 조작을 위해서는 &lt;a href=&quot;surfarray#module-pygame.surfarray&quot;&gt; &lt;code&gt;pygame.surfarray&lt;/code&gt; &lt;/a&gt; 모듈을 사용해보십시오 (꽤 빠르지 만 NumPy가 필요합니다).</target>
        </trans-unit>
        <trans-unit id="806ea95746ccd6cda50687157e15f6f7841e6909" translate="yes" xml:space="preserve">
          <source>There may be a brief pause while the drive is initialized. Avoid &lt;code&gt;CD.init()&lt;/code&gt; if the program should not stop for a second or two.</source>
          <target state="translated">드라이브가 초기화되는 동안 잠시 일시 중지 될 수 있습니다. 프로그램이 1-2 초 동안 중지되지 않아야하는 경우 &lt;code&gt;CD.init()&lt;/code&gt; 피하십시오 .</target>
        </trans-unit>
        <trans-unit id="10efdd4393e9de03f85772fc659f9ee4b735c8fe" translate="yes" xml:space="preserve">
          <source>These constants may be found on the FreeType constants module. Optionally, the default style can be modified or obtained accessing the individual style attributes (underline, oblique, strong).</source>
          <target state="translated">이 상수는 FreeType 상수 모듈에서 찾을 수 있습니다. 선택적으로, 기본 스타일은 개별 스타일 속성 (밑줄, 기울기, 강한)에 액세스하여 수정하거나 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="97f27dac82353cf683a16f1ec7f4a0250a626b71" translate="yes" xml:space="preserve">
          <source>These examples should help get you started with pygame. Here is a brief rundown of what you get. The source code for these examples is in the public domain. Feel free to use for your own projects.</source>
          <target state="translated">이 예제는 파이 게임을 시작하는 데 도움이됩니다. 다음은 당신이 얻는 것에 대한 간략한 요약입니다. 이 예제의 소스 코드는 공개 도메인에 있습니다. 자신의 프로젝트에 자유롭게 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b10ebe9e3260b5fd9cfdd25372e38d26be44efe3" translate="yes" xml:space="preserve">
          <source>These functions temporarily lock the surface they are operating on. Many sequential drawing calls can be sped up by locking and unlocking the surface object around the draw calls (see &lt;a href=&quot;surface#pygame.Surface.lock&quot;&gt;&lt;code&gt;pygame.Surface.lock()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;surface#pygame.Surface.unlock&quot;&gt;&lt;code&gt;pygame.Surface.unlock()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">이 기능은 작동중인 표면을 일시적으로 잠급니다. 많은 연속 그리기 호출은 그리기 호출 주위의 표면 객체를 잠 그거나 잠금 해제하여 속도를 높일 수 있습니다 ( &lt;a href=&quot;surface#pygame.Surface.lock&quot;&gt; &lt;code&gt;pygame.Surface.lock()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;surface#pygame.Surface.unlock&quot;&gt; &lt;code&gt;pygame.Surface.unlock()&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="542d36ff5284a7b81accc8d4367b28e879056894" translate="yes" xml:space="preserve">
          <source>They support the following numerical operations: vec+vec, vec-vec, vec*number, number*vec, vec/number, vec//number, vec+=vec, vec-=vec, vec*=number, vec/=number, vec//=number. All these operations will be performed elementwise. In addition vec*vec will perform a scalar-product (a.k.a. dot-product). If you want to multiply every element from vector v with every element from vector w you can use the elementwise method: &lt;code&gt;v.elementwise() * w&lt;/code&gt;</source>
          <target state="translated">vec + vec, vec-vec, vec * number, number * vec, vec / number, vec // number, vec + = vec, vec- = vec, vec * = number, vec / = number와 같은 수치 연산을 지원합니다. , vec // = 숫자. 이 모든 작업은 요소별로 수행됩니다. 또한 vec * vec는 스칼라 곱 (일명 도트 곱)을 수행합니다. 벡터 v의 모든 요소에 벡터 w의 모든 요소를 ​​곱하려면 &lt;code&gt;v.elementwise() * w&lt;/code&gt; 메서드를 사용할 수 있습니다. v.elementwise () * w</target>
        </trans-unit>
        <trans-unit id="ebd7056339b3a80cd825f17856f73ce924bb53bc" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;pygame.masks&lt;/code&gt; demo will display multiple moving sprites bouncing off each other. More than one sprite image can be provided.</source>
          <target state="translated">이 &lt;code&gt;pygame.masks&lt;/code&gt; 데모는 서로 움직이는 여러 개의 스프라이트를 표시합니다. 하나 이상의 스프라이트 이미지가 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb90dc9b29bf3cb581c77c9fbf46d01fb349ce29" translate="yes" xml:space="preserve">
          <source>This allows the application to reserve a specific number of channels for important sounds that must not be dropped or have a guaranteed channel to play on.</source>
          <target state="translated">이를 통해 응용 프로그램은 떨어 뜨리거나 보장 된 채널을 재생해서는 안되는 중요한 사운드를 위해 특정 수의 채널을 예약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c71d3c17a15ca22b2d10857b401824a40c7ddcb" translate="yes" xml:space="preserve">
          <source>This call cannot be used on &lt;code&gt;pygame.OPENGL&lt;/code&gt; displays and will generate an exception.</source>
          <target state="translated">이 호출은 &lt;code&gt;pygame.OPENGL&lt;/code&gt; 사용할 수 없습니다. OPENGL이 표시되고 예외가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="b30556212f957004f6f795ffc1c5d659a10ece08" translate="yes" xml:space="preserve">
          <source>This can be useful for collision detection. An approximate collision normal can be found by calculating the gradient of the overlapping area through the finite difference.</source>
          <target state="translated">충돌 감지에 유용합니다. 유한 차분을 통해 겹치는 영역의 기울기를 계산하여 대략적인 충돌 법선을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="377031aacfe1732064fd06aa79afa03e628d06bc" translate="yes" xml:space="preserve">
          <source>This can flip a Surface either vertically, horizontally, or both. Flipping a Surface is non-destructive and returns a new Surface with the same dimensions.</source>
          <target state="translated">이것은 표면을 수직, 수평 또는 둘 다 뒤집을 수 있습니다. 지표면 뒤집기는 비파괴 적이며 동일한 치수의 새 지표면을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="eaec9fd591189ba31d5fcdb43494cc8fbf4ddb48" translate="yes" xml:space="preserve">
          <source>This can only work on 24-bit or 32-bit Surfaces.</source>
          <target state="translated">24 비트 또는 32 비트 Surface에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="8fee96b00092cc2af12e433abafa7f75e0cafae2" translate="yes" xml:space="preserve">
          <source>This can only work on 32-bit Surfaces with a per-pixel alpha value.</source>
          <target state="translated">이것은 픽셀 당 알파 값을 가진 32 비트 표면에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="841d1e75c9215395911791ee48817428167b0797" translate="yes" xml:space="preserve">
          <source>This causes pygame to signal (by means of the event queue) when the music is done playing. The argument determines the type of event that will be queued.</source>
          <target state="translated">이로 인해 음악 재생이 완료되면 파이 게임이 (이벤트 대기열을 통해) 신호를 보냅니다. 인수는 대기 할 이벤트 유형을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="8b55f87a2309af3ba709bc571f81ce8f6546ef47" translate="yes" xml:space="preserve">
          <source>This class derives from &lt;code&gt;pygame.sprite.RenderUpdates()&lt;/code&gt;. It maintains the order in which the Sprites were added to the Group for rendering. This makes adding and removing Sprites from the Group a little slower than regular Groups.</source>
          <target state="translated">이 클래스는 &lt;code&gt;pygame.sprite.RenderUpdates()&lt;/code&gt; 에서 파생됩니다 . 스프라이트가 렌더링을 위해 그룹에 추가 된 순서를 유지합니다. 이로 인해 그룹에서 스프라이트를 추가 및 제거하면 일반 그룹보다 약간 느려집니다.</target>
        </trans-unit>
        <trans-unit id="ec651399b3e13eb57a41d4603a3502e39f262489" translate="yes" xml:space="preserve">
          <source>This class is an alias to &lt;code&gt;pygame.sprite.Group()&lt;/code&gt;. It has no additional functionality.</source>
          <target state="translated">이 클래스는 &lt;code&gt;pygame.sprite.Group()&lt;/code&gt; 의 별칭 입니다. 추가 기능이 없습니다.</target>
        </trans-unit>
        <trans-unit id="e231cf327394b8f59c78572613135a2a06403bb5" translate="yes" xml:space="preserve">
          <source>This class is derived from &lt;code&gt;pygame.sprite.Group()&lt;/code&gt;. It has an extended &lt;code&gt;draw()&lt;/code&gt; method that tracks the changed areas of the screen.</source>
          <target state="translated">이 클래스는 &lt;code&gt;pygame.sprite.Group()&lt;/code&gt; 에서 파생됩니다 . 화면의 변경된 영역을 추적 하는 확장 &lt;code&gt;draw()&lt;/code&gt; 메서드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="362338c8a17b34d4034e5cb63db4bb3733c4cc3b" translate="yes" xml:space="preserve">
          <source>This closes resources like files for any music that may be loaded.</source>
          <target state="translated">로드 할 수있는 음악 파일과 같은 리소스가 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="4e207b20f37a44580f27fcbfa11f12902aad7894" translate="yes" xml:space="preserve">
          <source>This creates a new Surface with the specified text rendered on it. pygame provides no way to directly draw text on an existing Surface: instead you must use &lt;code&gt;Font.render()&lt;/code&gt; to create an image (Surface) of the text, then blit this image onto another Surface.</source>
          <target state="translated">지정된 텍스트를 렌더링하여 새 Surface를 만듭니다. pygame은 기존 Surface에 직접 텍스트를 그리는 방법을 제공하지 않습니다. 대신 &lt;code&gt;Font.render()&lt;/code&gt; 를 사용하여 텍스트의 이미지 (Surface)를 만든 다음이 이미지를 다른 Surface에 블리 팅 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a26fc04b03abce1762a4a060e7c858992f83ed72" translate="yes" xml:space="preserve">
          <source>This cursors module contains functions for loading and decoding various cursor formats. These allow you to easily store your cursors in external files or directly as encoded python strings.</source>
          <target state="translated">이 커서 모듈에는 다양한 커서 형식을로드하고 디코딩하는 기능이 있습니다. 이를 통해 커서를 외부 파일에 또는 인코딩 된 파이썬 문자열로 직접 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1517c60092323a7ac60d090f9bceee4d4a759669" translate="yes" xml:space="preserve">
          <source>This example shows a scrollable image that has a zoom factor of eight. It uses the &lt;a href=&quot;surface#pygame.Surface.scroll&quot;&gt;&lt;code&gt;Surface.scroll()&lt;/code&gt;&lt;/a&gt; function to shift the image on the display surface. A clip rectangle protects a margin area. If called as a function, the example accepts an optional image file path. If run as a program it takes an optional file path command line argument. If no file is provided a default image file is used.</source>
          <target state="translated">이 예는 확대 / 축소 비율이 8 인 스크롤 가능한 이미지를 보여줍니다. &lt;a href=&quot;surface#pygame.Surface.scroll&quot;&gt; &lt;code&gt;Surface.scroll()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 디스플레이 표면에서 이미지를 이동합니다. 클립 사각형은 여백 영역을 보호합니다. 함수로 호출되면이 예제는 선택적 이미지 파일 경로를 허용합니다. 프로그램으로 실행되는 경우 선택적 파일 경로 명령 행 인수가 사용됩니다. 파일이 제공되지 않으면 기본 이미지 파일이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c24bea595f257d21c2c8bbacdd85f15d5b3fbb07" translate="yes" xml:space="preserve">
          <source>This example was created in a quick comparison with the BlitzBasic gaming language. Nonetheless, it demonstrates a quick 8-bit setup (with colormap).</source>
          <target state="translated">이 예제는 BlitzBasic 게임 언어와 빠른 비교로 작성되었습니다. 그럼에도 불구하고, 빠른 8 비트 설정 (컬러 맵 사용)을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="24b7d4e5c1fc9b657d365093e597a52e29790976" translate="yes" xml:space="preserve">
          <source>This exception is raised whenever a pygame or SDL operation fails. You can catch any anticipated problems and deal with the error. The exception is always raised with a descriptive message about the problem.</source>
          <target state="translated">파이 게임 또는 SDL 작업이 실패 할 때마다이 예외가 발생합니다. 예상되는 문제를 파악하고 오류를 처리 할 수 ​​있습니다. 예외는 항상 문제에 대한 설명 메시지와 함께 발생합니다.</target>
        </trans-unit>
        <trans-unit id="34c4af18aba9fc33e3fd1dfee62e4c5b222713ba" translate="yes" xml:space="preserve">
          <source>This function can only be called once per Python session. It is not reentrant.</source>
          <target state="translated">이 함수는 Python 세션 당 한 번만 호출 할 수 있습니다. 재진입되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4ed17c9a3799878ebdb6166142a69bd35bb9a4c7" translate="yes" xml:space="preserve">
          <source>This function closes the &lt;code&gt;freetype&lt;/code&gt; module. After calling this function, you should not invoke any class, method or function related to the &lt;code&gt;freetype&lt;/code&gt; module as they are likely to fail or might give unpredictable results. It is safe to call this function even if the module hasn't been initialized yet.</source>
          <target state="translated">이 기능은 &lt;code&gt;freetype&lt;/code&gt; 모듈을 닫습니다 . 이 함수를 호출 한 후에는 &lt;code&gt;freetype&lt;/code&gt; 모듈과 관련된 클래스, 메소드 또는 함수 가 실패하거나 예측할 수없는 결과를 낼 수 있으므로 호출해서는 안됩니다 . 모듈이 아직 초기화되지 않은 경우에도이 함수를 호출하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="7636870ebe240c28409ec4a4065a78954ff79d9d" translate="yes" xml:space="preserve">
          <source>This function has no effect on a Surface with more than 8-bits per pixel.</source>
          <target state="translated">이 기능은 픽셀 당 8 비트 이상인 Surface에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e8d7e0fb1933064e880da282556835d8ad87f38d" translate="yes" xml:space="preserve">
          <source>This function initializes the underlying FreeType library and must be called before trying to use any of the functionality of the &lt;code&gt;freetype&lt;/code&gt; module.</source>
          <target state="translated">이 함수는 기본 FreeType 라이브러리를 초기화하며 &lt;code&gt;freetype&lt;/code&gt; 모듈 의 기능을 사용하기 전에 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="52b9dc729ad90156c3c1cfb38aaaf116ea8119b1" translate="yes" xml:space="preserve">
          <source>This function is called automatically by &lt;code&gt;pygame.init()&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;pygame.init()&lt;/code&gt; 의해 자동으로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="f1331f18d7dee1c831b996ece8920900fad885b6" translate="yes" xml:space="preserve">
          <source>This function is like an optimized version of &lt;code&gt;pygame.display.flip()&lt;/code&gt; for software displays. It allows only a portion of the screen to updated, instead of the entire area. If no argument is passed it updates the entire Surface area like &lt;code&gt;pygame.display.flip()&lt;/code&gt;.</source>
          <target state="translated">이 함수는 소프트웨어 디스플레이에 최적화 된 &lt;code&gt;pygame.display.flip()&lt;/code&gt; 버전과 같습니다 . 전체 영역 대신 화면의 일부만 업데이트 할 수 있습니다. 인수가 전달되지 않으면 &lt;code&gt;pygame.display.flip()&lt;/code&gt; 과 같이 전체 Surface 영역을 업데이트합니다 .</target>
        </trans-unit>
        <trans-unit id="ec049e470d73a3318a990fde9a1d5fdaa508b112" translate="yes" xml:space="preserve">
          <source>This function is not necessary if your program is consistently processing events on the queue through the other &lt;a href=&quot;#module-pygame.event&quot;&gt;&lt;code&gt;pygame.event&lt;/code&gt;&lt;/a&gt; functions.</source>
          <target state="translated">프로그램이 다른 &lt;a href=&quot;#module-pygame.event&quot;&gt; &lt;code&gt;pygame.event&lt;/code&gt; &lt;/a&gt; 함수를 통해 큐의 이벤트를 지속적으로 처리하는 경우에는이 함수가 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7af92c20e0ebdb7c5ac70fb974aba5babe3fd96e" translate="yes" xml:space="preserve">
          <source>This function is provided for pygame testing and debugging.</source>
          <target state="translated">이 기능은 파이 게임 테스트 및 디버깅을 위해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="4e0bc9ffea77f880d5242b58aa57db08e74ce6bd" translate="yes" xml:space="preserve">
          <source>This function is provided for pygame testing and debugging. If smoothscale causes an invalid instruction error then it is a pygame/SDL bug that should be reported. Use this function as a temporary fix only.</source>
          <target state="translated">이 기능은 파이 게임 테스트 및 디버깅을 위해 제공됩니다. smoothscale에서 잘못된 명령어 오류가 발생하면 이는 pygame / SDL 버그이며보고해야합니다. 이 기능은 임시 수정으로 만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9866c0b7432f52d3bf71ec3f33d2cd10c641d3f7" translate="yes" xml:space="preserve">
          <source>This function is used in encoding file paths. Keyword arguments are supported.</source>
          <target state="translated">이 기능은 파일 경로를 인코딩하는 데 사용됩니다. 키워드 인수가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="9e2774edb94a7f3e828777cb950a5f6a22b98928" translate="yes" xml:space="preserve">
          <source>This function is used to encode file paths in pygame. Encoding is to the codec as returned by &lt;code&gt;sys.getfilesystemencoding()&lt;/code&gt;. Keyword arguments are supported.</source>
          <target state="translated">이 함수는 파이 게임에서 파일 경로를 인코딩하는 데 사용됩니다. 인코딩은 &lt;code&gt;sys.getfilesystemencoding()&lt;/code&gt; 반환 한 코덱에 대한 것 입니다. 키워드 인수가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="043fdef2d252c9dba9bc250c234c02817bab3ac3" translate="yes" xml:space="preserve">
          <source>This function returns a list of possible sizes for a specified color depth. The return value will be an empty list if no display modes are available with the given arguments. A return value of -1 means that any requested size should work (this is likely the case for windowed modes). Mode sizes are sorted from biggest to smallest.</source>
          <target state="translated">이 함수는 지정된 색 농도에 가능한 크기 목록을 반환합니다. 주어진 인수에 사용 가능한 디스플레이 모드가없는 경우 반환 값은 빈 목록이됩니다. 반환 값 -1은 요청 된 크기가 작동 함을 의미합니다 (윈도우 모드의 경우). 모드 크기는 가장 큰 것에서 가장 작은 것까지 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="810b0c5a1e7e21b0699c1e25d30412e1fa104d1e" translate="yes" xml:space="preserve">
          <source>This function should only be called in the thread that initialized &lt;a href=&quot;display#module-pygame.display&quot;&gt;&lt;code&gt;pygame.display&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;display#module-pygame.display&quot;&gt; &lt;code&gt;pygame.display&lt;/code&gt; &lt;/a&gt; 를 초기화 한 스레드에서만 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="bbeba874cabac347f91819f8621bd77c5e817a79" translate="yes" xml:space="preserve">
          <source>This function takes arguments similar to &lt;code&gt;pygame.image.tostring()&lt;/code&gt;. The size argument is a pair of numbers representing the width and height. Once the new Surface is created you can destroy the string buffer.</source>
          <target state="translated">이 함수는 &lt;code&gt;pygame.image.tostring()&lt;/code&gt; 과 비슷한 인수를 취 합니다. size 인수는 너비와 높이를 나타내는 숫자 쌍입니다. 새로운 Surface가 생성되면 문자열 버퍼를 파괴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="354e37bea0915e450d80807680d3d19e8dcbb744" translate="yes" xml:space="preserve">
          <source>This function uses the same arguments as &lt;code&gt;pygame.display.set_mode()&lt;/code&gt;. It is used to determine if a requested display mode is available. It will return 0 if the display mode cannot be set. Otherwise it will return a pixel depth that best matches the display asked for.</source>
          <target state="translated">이 함수는 &lt;code&gt;pygame.display.set_mode()&lt;/code&gt; 와 같은 인수를 사용합니다 . 요청 된 디스플레이 모드가 사용 가능한지를 판별하는 데 사용됩니다. 디스플레이 모드를 설정할 수 없으면 0을 반환합니다. 그렇지 않으면 요청한 디스플레이와 가장 일치하는 픽셀 깊이를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="256013e2480a9f38c603f546321d37734d29521d" translate="yes" xml:space="preserve">
          <source>This function will create a display Surface. The arguments passed in are requests for a display type. The actual created display will be the best possible match supported by the system.</source>
          <target state="translated">이 기능은 디스플레이 표면을 만듭니다. 전달 된 인수는 표시 유형에 대한 요청입니다. 실제로 생성 된 디스플레이는 시스템에서 지원하는 최상의 일치 항목이됩니다.</target>
        </trans-unit>
        <trans-unit id="e5b74a31fcb8668af821d2b3740f0c9344a5e73c" translate="yes" xml:space="preserve">
          <source>This function will temporarily lock and unlock the Surface as needed.</source>
          <target state="translated">이 기능은 필요에 따라 Surface를 일시적으로 잠 그거나 잠금 해제합니다.</target>
        </trans-unit>
        <trans-unit id="bc0c6bf8e0d0cb15e5573a4ec53f5812af9dd8a0" translate="yes" xml:space="preserve">
          <source>This function will temporarily lock the Surface as pixels are copied (see the &lt;a href=&quot;surface#pygame.Surface.lock&quot;&gt;&lt;code&gt;pygame.Surface.lock()&lt;/code&gt;&lt;/a&gt; - lock the Surface memory for pixel access method).</source>
          <target state="translated">이 함수는 픽셀이 복사 될 때 Surface를 일시적으로 잠급니다 ( &lt;a href=&quot;surface#pygame.Surface.lock&quot;&gt; &lt;code&gt;pygame.Surface.lock()&lt;/code&gt; &lt;/a&gt; -픽셀 액세스 방법을 위해 Surface 메모리 잠그기).</target>
        </trans-unit>
        <trans-unit id="c2cd97274febd20a209e1c930af0c48906747d0f" translate="yes" xml:space="preserve">
          <source>This function will temporarily lock the Surface as pixels are copied.</source>
          <target state="translated">이 기능은 픽셀이 복사 될 때 표면을 일시적으로 잠급니다.</target>
        </trans-unit>
        <trans-unit id="260f654a4c517dbc4f880f873e65a56bd12d2ebd" translate="yes" xml:space="preserve">
          <source>This function will temporarily lock the Surface as the new values are copied.</source>
          <target state="translated">이 기능은 새로운 값이 복사 될 때 Surface를 일시적으로 잠급니다.</target>
        </trans-unit>
        <trans-unit id="515087e301fc607ede35770021c9af6285160121" translate="yes" xml:space="preserve">
          <source>This gets the number of milliseconds that the music has been playing for. The returned time only represents how long the music has been playing; it does not take into account any starting position offsets.</source>
          <target state="translated">음악 재생 시간 (밀리 초)을 가져옵니다. 반환 된 시간은 음악 재생 시간을 나타냅니다. 시작 위치 오프셋을 고려하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c564830c827768ab21dd2abd75ff21180bd2226e" translate="yes" xml:space="preserve">
          <source>This group is fully compatible with &lt;a href=&quot;#pygame.sprite.Sprite&quot;&gt;&lt;code&gt;pygame.sprite.Sprite&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 그룹은 &lt;a href=&quot;#pygame.sprite.Sprite&quot;&gt; &lt;code&gt;pygame.sprite.Sprite&lt;/code&gt; &lt;/a&gt; 와 완벽하게 호환됩니다 .</target>
        </trans-unit>
        <trans-unit id="7591ae0a4b3e4908326e616ff04531c52b825d4b" translate="yes" xml:space="preserve">
          <source>This group requires &lt;a href=&quot;#pygame.sprite.DirtySprite&quot;&gt;&lt;code&gt;pygame.sprite.DirtySprite&lt;/code&gt;&lt;/a&gt; or any sprite that has the following attributes:</source>
          <target state="translated">이 그룹에는 &lt;a href=&quot;#pygame.sprite.DirtySprite&quot;&gt; &lt;code&gt;pygame.sprite.DirtySprite&lt;/code&gt; &lt;/a&gt; 또는 다음 속성을 가진 스프라이트가 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="944481970748fc27dab848ee3bc94731ea873925" translate="yes" xml:space="preserve">
          <source>This is a combined scale and rotation transform. The resulting Surface will be a filtered 32-bit Surface. The scale argument is a floating point value that will be multiplied by the current resolution. The angle argument is a floating point value that represents the counterclockwise degrees to rotate. A negative rotation angle will rotate clockwise.</source>
          <target state="translated">이것은 스케일과 회전 변환이 결합 된 것입니다. 결과 Surface는 필터링 된 32 비트 Surface입니다. scale 인수는 현재 해상도를 곱한 부동 소수점 값입니다. 각도 인수는 시계 반대 방향으로 회전하는 부동 소수점 값입니다. 음의 회전 각도는 시계 방향으로 회전합니다.</target>
        </trans-unit>
        <trans-unit id="15f4e83adef80e578ea6374a3d3ec9e9a4e1f7ac" translate="yes" xml:space="preserve">
          <source>This is a more featureful method of getting a &lt;a href=&quot;#pygame.mask.Mask&quot;&gt;&lt;code&gt;Mask&lt;/code&gt;&lt;/a&gt; from a surface.</source>
          <target state="translated">이것은 표면에서 &lt;a href=&quot;#pygame.mask.Mask&quot;&gt; &lt;code&gt;Mask&lt;/code&gt; &lt;/a&gt; 를 얻는 더 유용한 방법입니다 .</target>
        </trans-unit>
        <trans-unit id="b49b0fd826cd2e6106d42f496e3f78abc03f62fa" translate="yes" xml:space="preserve">
          <source>This is a stress test for the fastevents module.</source>
          <target state="translated">이것은 fastevents 모듈에 대한 스트레스 테스트입니다.</target>
        </trans-unit>
        <trans-unit id="5d5a22667c796f66adf57a91363ad677d9e42bfd" translate="yes" xml:space="preserve">
          <source>This is an in place operation that directly affects the pixels of the PixelArray.</source>
          <target state="translated">이는 PixelArray의 픽셀에 직접 영향을주는 인플레 이스 작업입니다.</target>
        </trans-unit>
        <trans-unit id="b81d900f1917cc1c0e602c1d387c321c63e189b3" translate="yes" xml:space="preserve">
          <source>This is not needed for normal pygame usage.</source>
          <target state="translated">일반적인 파이 게임 사용에는 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="92d7d7f37ffaadc943ea996958135efe3219a87b" translate="yes" xml:space="preserve">
          <source>This is not quality 'ui' code at all, but you can see how to implement very non-interactive status displays, or even a crude text output control.</source>
          <target state="translated">이것은 품질 'ui'코드가 아니지만 매우 비 대화식 상태 표시 또는 원치 않는 텍스트 출력 제어를 구현하는 방법을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="273c04dcd5f9205cff220ca41a4f5a53417f7455" translate="yes" xml:space="preserve">
          <source>This is particularly difficult under Windows.</source>
          <target state="translated">이것은 Windows에서 특히 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="f06ff1d9d9e29605faa6c8b5d7c4392faa9668ed" translate="yes" xml:space="preserve">
          <source>This is the full and final example from the Pygame Tutorial, &quot;How Do I Make It Move&quot;. It creates 10 objects and animates them on the screen.</source>
          <target state="translated">이것은 Pygame Tutorial, &quot;How To I Make It Move&quot;의 전체 예제입니다. 10 개의 객체를 생성하고 화면에 애니메이션을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="3b8b7554c09fd5d8beb4478ba06bf2539a688b6b" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;surface#pygame.Surface.get_bytesize&quot;&gt;&lt;code&gt;Surface.get_bytesize()&lt;/code&gt;&lt;/a&gt; for the pixel array's surface.</source>
          <target state="translated">픽셀 배열의 표면에 대한 &lt;a href=&quot;surface#pygame.Surface.get_bytesize&quot;&gt; &lt;code&gt;Surface.get_bytesize()&lt;/code&gt; &lt;/a&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="08370d8c399fece3b373c55371473782e72d758f" translate="yes" xml:space="preserve">
          <source>This is the version represented as a string. It can contain a micro release number as well, e.g. &lt;code&gt;'1.5.2'&lt;/code&gt;</source>
          <target state="translated">이것은 문자열로 표시되는 버전입니다. 마이크로 릴리즈 번호도 포함 할 수 있습니다 (예 : &lt;code&gt;'1.5.2'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b66e0ebe873bcb25b0954c415de607659360d6f9" translate="yes" xml:space="preserve">
          <source>This is true when the display window has keyboard focus from the system. If the display needs to ensure it does not lose keyboard focus, it can use &lt;code&gt;pygame.event.set_grab()&lt;/code&gt; to grab all input.</source>
          <target state="translated">디스플레이 창에 시스템의 키보드 포커스가있는 경우에 해당됩니다. 디스플레이가 키보드 포커스를 잃지 않도록해야하는 경우, &lt;code&gt;pygame.event.set_grab()&lt;/code&gt; 를 사용 하여 모든 입력을 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3d9dd5958ba5a87111bf42f37ff05ac0ca81d19f" translate="yes" xml:space="preserve">
          <source>This is usually used for placing &lt;code&gt;pygame.USEREVENT&lt;/code&gt; events on the queue. Although any type of event can be placed, if using the system event types your program should be sure to create the standard attributes with appropriate values.</source>
          <target state="translated">일반적으로 대기열에 &lt;code&gt;pygame.USEREVENT&lt;/code&gt; 이벤트 를 배치하는 데 사용 됩니다. 모든 유형의 이벤트를 배치 할 수 있지만 시스템 이벤트 유형을 사용하는 경우 프로그램은 적절한 값으로 표준 속성을 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="4331a4c66d324826ca9e1f88093ee16fa839d423" translate="yes" xml:space="preserve">
          <source>This loads cursors for a simple subset of &lt;code&gt;XBM&lt;/code&gt; files. &lt;code&gt;XBM&lt;/code&gt; files are traditionally used to store cursors on UNIX systems, they are an ASCII format used to represent simple images.</source>
          <target state="translated">&lt;code&gt;XBM&lt;/code&gt; 파일 의 간단한 서브 세트에 대한 커서를로드 합니다. &lt;code&gt;XBM&lt;/code&gt; 파일은 일반적으로 UNIX 시스템에서 커서를 저장하는 데 사용되며 간단한 이미지를 나타내는 데 사용되는 ASCII 형식입니다.</target>
        </trans-unit>
        <trans-unit id="822fa508c7a24bb18dfc2588a9977f7f34a5e53f" translate="yes" xml:space="preserve">
          <source>This method implicitly locks the Surface. The lock will be released when the returned &lt;a href=&quot;bufferproxy#pygame.BufferProxy&quot;&gt;&lt;code&gt;pygame.BufferProxy&lt;/code&gt;&lt;/a&gt; object is garbage collected.</source>
          <target state="translated">이 방법은 표면을 암시 적으로 잠급니다. 반환 된 &lt;a href=&quot;bufferproxy#pygame.BufferProxy&quot;&gt; &lt;code&gt;pygame.BufferProxy&lt;/code&gt; &lt;/a&gt; 객체가 가비지 수집 되면 잠금이 해제됩니다 .</target>
        </trans-unit>
        <trans-unit id="b5da2768224d102b2e80d558a57ede059399cb0e" translate="yes" xml:space="preserve">
          <source>This method is called automatically by &lt;code&gt;pygame.init()&lt;/code&gt;. It initializes the font module. The module must be initialized before any other functions will work.</source>
          <target state="translated">이 메소드는 &lt;code&gt;pygame.init()&lt;/code&gt; 의해 자동으로 호출됩니다 . 폰트 모듈을 초기화합니다. 다른 기능이 작동하기 전에 모듈을 초기화해야합니다.</target>
        </trans-unit>
        <trans-unit id="747923ecfe705a3666906159cf1df760b4909f58" translate="yes" xml:space="preserve">
          <source>This method is for explicitly closing the PixelArray, and releasing a lock on the Suface.</source>
          <target state="translated">이 메소드는 PixelArray를 명시 적으로 닫고 Suface에서 잠금을 해제하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="a584fc94654d213a8e5114723c98ef3213351f08" translate="yes" xml:space="preserve">
          <source>This method is intended for pygame unit testing. It unlikely has any use in an application.</source>
          <target state="translated">이 방법은 파이 게임 단위 테스트를위한 것입니다. 응용 프로그램에서 사용할 가능성이 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="562f15e89dd731767233ca4b82ad4d9825291905" translate="yes" xml:space="preserve">
          <source>This method is most useful when working in a window. By contrast, in full-screen mode, this method always returns true.</source>
          <target state="translated">이 방법은 창에서 작업 할 때 가장 유용합니다. 반대로 전체 화면 모드에서이 메서드는 항상 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c931ce2399b15b31259d9199be99f0ba2ded2f98" translate="yes" xml:space="preserve">
          <source>This method returns a new view of the pixel array with the rows and columns swapped. So for a (w, h) sized array a (h, w) slice is returned. If an array is one dimensional, then a length 1 x dimension is added, resulting in a 2D pixel array.</source>
          <target state="translated">이 메소드는 행과 열이 바뀐 픽셀 배열의 새보기를 리턴합니다. 따라서 (w, h) 크기 배열의 경우 (h, w) 슬라이스가 반환됩니다. 배열이 1 차원 인 경우 길이 1 x 차원이 추가되어 2D 픽셀 배열이됩니다.</target>
        </trans-unit>
        <trans-unit id="95952eb8cdb93efd5b49d8fa2c59ec0210890842" translate="yes" xml:space="preserve">
          <source>This method should be called once per frame. It will compute how many milliseconds have passed since the previous call.</source>
          <target state="translated">이 메소드는 프레임 당 한 번씩 호출해야합니다. 이전 호출 이후 몇 밀리 초가 경과했는지 계산합니다.</target>
        </trans-unit>
        <trans-unit id="f466de58a1b74c4728fc79e07b1e959c2b51aaa9" translate="yes" xml:space="preserve">
          <source>This module also contains a few cursors as formatted strings. You'll need to pass these to &lt;code&gt;pygame.cursors.compile()&lt;/code&gt; function before you can use them. The example call would look like this:</source>
          <target state="translated">이 모듈에는 형식화 된 문자열로 몇 개의 커서가 있습니다. 이것을 사용하기 전에 &lt;code&gt;pygame.cursors.compile()&lt;/code&gt; 함수 에 전달해야 합니다. 예제 호출은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b3fc7a045db49d594712362f6fddb5bf86abf002" translate="yes" xml:space="preserve">
          <source>This module contains classes for loading Sound objects and controlling playback. The mixer module is optional and depends on SDL_mixer. Your program should test that &lt;a href=&quot;#module-pygame.mixer&quot;&gt;&lt;code&gt;pygame.mixer&lt;/code&gt;&lt;/a&gt; is available and initialized before using it.</source>
          <target state="translated">이 모듈에는 Sound 객체를로드하고 재생을 제어하는 ​​클래스가 포함되어 있습니다. 믹서 모듈은 옵션이며 SDL_mixer에 따라 다릅니다. 프로그램은 &lt;a href=&quot;#module-pygame.mixer&quot;&gt; &lt;code&gt;pygame.mixer&lt;/code&gt; &lt;/a&gt; 가 사용 가능하고 초기화 되었는지 테스트해야 합니다.</target>
        </trans-unit>
        <trans-unit id="34454c1fea983baa287038fcba37957a96cc0995" translate="yes" xml:space="preserve">
          <source>This module contains functions for dealing with the keyboard.</source>
          <target state="translated">이 모듈에는 키보드를 다루는 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4d16723c7230856f50649d3949104b34c9b25c3" translate="yes" xml:space="preserve">
          <source>This module contains several simple classes to be used within games. There is the main Sprite class and several Group classes that contain Sprites. The use of these classes is entirely optional when using pygame. The classes are fairly lightweight and only provide a starting place for the code that is common to most games.</source>
          <target state="translated">이 모듈은 게임 내에서 사용되는 몇 가지 간단한 클래스를 포함합니다. 기본 Sprite 클래스와 Sprite를 포함하는 여러 Group 클래스가 있습니다. 파이 게임을 사용할 때이 클래스의 사용은 전적으로 선택 사항입니다. 클래스는 매우 가벼우 며 대부분의 게임에 공통적 인 코드의 시작 위치 만 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7783b25a709c67b6010c11f4d9bd2309871340ba" translate="yes" xml:space="preserve">
          <source>This module contains various constants used by pygame. Its contents are automatically placed in the pygame module namespace. However, an application can use &lt;code&gt;pygame.locals&lt;/code&gt; to include only the pygame constants with a &lt;code&gt;from
pygame.locals import *&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 파이 게임이 사용하는 다양한 상수를 포함합니다. 그 내용은 파이 게임 모듈 네임 스페이스에 자동으로 배치됩니다. 그러나 애플리케이션은 &lt;code&gt;pygame.locals&lt;/code&gt; 를 사용 하여 &lt;code&gt;from pygame.locals import *&lt;/code&gt; 와 함께 파이 게임 상수 만 포함 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b47936cfa09589ff90c9882bfe4cdcfd4276d99d" translate="yes" xml:space="preserve">
          <source>This module is automatically imported into the pygame package and can be used to check which version of pygame has been imported.</source>
          <target state="translated">이 모듈은 pygame 패키지로 자동으로 가져 오기되며 어떤 버전의 pygame을 가져 왔는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="028601a8d9a0e5a27d2071e72fbc350dc9e7305b" translate="yes" xml:space="preserve">
          <source>This module offers control over the pygame display. Pygame has a single display Surface that is either contained in a window or runs full screen. Once you create the display you treat it as a regular Surface. Changes are not immediately visible onscreen; you must choose one of the two flipping functions to update the actual display.</source>
          <target state="translated">이 모듈은 파이 게임 디스플레이를 제어합니다. 파이 게임은 창에 포함되어 있거나 전체 화면으로 실행되는 단일 디스플레이 표면을 가지고 있습니다. 디스플레이를 생성하면 일반 Surface로 취급합니다. 변경 사항은 화면에 즉시 표시되지 않습니다. 실제 디스플레이를 업데이트하려면 두 반전 기능 중 하나를 선택해야합니다.</target>
        </trans-unit>
        <trans-unit id="a90d076b0a2a8788e178ed37e2a983274529b157" translate="yes" xml:space="preserve">
          <source>This more closely resembles a port of the &lt;code&gt;SDL&lt;/code&gt; Aliens demo. The code is a lot simpler, so it makes a better starting point for people looking at code for the first times. These blitting routines are not as optimized as they should/could be, but the code is easier to follow, and it plays quick enough.</source>
          <target state="translated">이것은 &lt;code&gt;SDL&lt;/code&gt; Aliens 데모 포트와 매우 유사합니다 . 코드는 훨씬 단순하므로 처음으로 코드를 보는 사람들에게 더 나은 출발점이됩니다. 이러한 블리 팅 루틴은 원하는만큼 최적화되지는 않았지만 코드를 따라 가기 쉽고 빠르게 재생됩니다.</target>
        </trans-unit>
        <trans-unit id="6c12277fb80bf770b5ae14a6867843afe0c914c3" translate="yes" xml:space="preserve">
          <source>This really only has an effect on simple images with solid colors. On photographic and antialiased images it will look like a regular unfiltered scale.</source>
          <target state="translated">이것은 단색의 단순한 이미지에만 영향을 미칩니다. 사진 및 앤티 앨리어싱 된 이미지에서는 일반 필터링되지 않은 스케일처럼 보입니다.</target>
        </trans-unit>
        <trans-unit id="cc78fb089509f3e9bbb4a9e990db1c60b1993401" translate="yes" xml:space="preserve">
          <source>This returns the Channel object for the channel that was selected.</source>
          <target state="translated">선택된 채널의 Channel 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="47fb8fe407d72808cb0933eb2e0f660d648401fd" translate="yes" xml:space="preserve">
          <source>This returns the actual number of milliseconds used.</source>
          <target state="translated">사용 된 실제 밀리 초 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="41c82121a21750435865d772d7c1828d21c287e8" translate="yes" xml:space="preserve">
          <source>This sets the position in the music file where playback will start. The meaning of &quot;pos&quot;, a float (or a number that can be converted to a float), depends on the music format. For &lt;code&gt;MOD&lt;/code&gt; files, it is the integer pattern number in the module. For &lt;code&gt;OGG&lt;/code&gt; it the absolute position, in seconds, from the beginning of the sound. For &lt;code&gt;MP3&lt;/code&gt; files, it is the relative position, in seconds, from the current position. For absolute positioning in an &lt;code&gt;MP3&lt;/code&gt; file, first call &lt;a href=&quot;#pygame.mixer.music.rewind&quot;&gt;&lt;code&gt;rewind()&lt;/code&gt;&lt;/a&gt;. Other file formats are unsupported. Newer versions of SDL_mixer have better positioning support than earlier. An SDLError is raised if a particular format does not support positioning.</source>
          <target state="translated">음악 파일에서 재생이 시작될 위치를 설정합니다. 플로트 (또는 플로트로 변환 할 수있는 숫자) 인 &quot;pos&quot;의 의미는 음악 형식에 따라 다릅니다. 들어 &lt;code&gt;MOD&lt;/code&gt; 의 파일, 그것은 모듈의 정수 패턴 번호입니다. 용 &lt;code&gt;OGG&lt;/code&gt; 사운드의 시작으로부터 초에서 절대 위치. 들어 &lt;code&gt;MP3&lt;/code&gt; 의 파일, 현재 위치에서 초 상대적인 위치는이다. &lt;code&gt;MP3&lt;/code&gt; 파일 에서 절대 위치를 지정하려면 먼저 &lt;a href=&quot;#pygame.mixer.music.rewind&quot;&gt; &lt;code&gt;rewind()&lt;/code&gt; &lt;/a&gt; 호출하십시오 . 다른 파일 형식은 지원되지 않습니다. 최신 버전의 SDL_mixer는 이전보다 더 나은 위치 지정 지원을 제공합니다. 특정 형식이 위치 지정을 지원하지 않으면 SDLError가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="87bd72de83c3ce74bb6fc33e71e3fd0566232d10" translate="yes" xml:space="preserve">
          <source>This sets the rectangle used for typing with an IME. It controls where the candidate list will open, if supported.</source>
          <target state="translated">IME로 입력하는 데 사용되는 사각형을 설정합니다. 지원되는 경우 후보 목록을 열 위치를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="bd8bd28d8d0e5ae5ae4a2d15083004db0c7fddb0" translate="yes" xml:space="preserve">
          <source>This simple example is derived from the line-by-line tutorial that comes with pygame. It is based on a 'popular' web banner. Note there are comments here, but for the full explanation, follow along in the tutorial.</source>
          <target state="translated">이 간단한 예제는 파이 게임과 함께 제공되는 라인 별 자습서에서 파생됩니다. '인기있는'웹 배너를 기반으로합니다. 여기에 의견이 있지만 전체 설명을 보려면 튜토리얼을 따르십시오.</target>
        </trans-unit>
        <trans-unit id="555dc3adbb47e5fc51a5204a946bed1aeafffec0" translate="yes" xml:space="preserve">
          <source>This started off as a port of the &lt;code&gt;SDL&lt;/code&gt; demonstration, Aliens. Now it has evolved into something sort of resembling fun. This demonstrates a lot of different uses of sprites and optimized blitting. Also transparency, colorkeys, fonts, sound, music, joystick, and more. (PS, my high score is 117! goodluck)</source>
          <target state="translated">이것은 &lt;code&gt;SDL&lt;/code&gt; 데모, Aliens 의 포트로 시작되었습니다 . 이제는 비슷한 재미로 발전했습니다. 이것은 스프라이트의 다양한 사용과 최적화 된 블리 팅을 보여줍니다. 또한 투명도, 컬러 키, 글꼴, 사운드, 음악, 조이스틱 등이 있습니다. (PS, 내 높은 점수는 117입니다! goodluck)</target>
        </trans-unit>
        <trans-unit id="e0e9ca3b1bdc920d399422d01dc5acdda8a00494" translate="yes" xml:space="preserve">
          <source>This uses pyportmidi for now, but may use its own bindings at some point in the future. The pyportmidi bindings are included with pygame.</source>
          <target state="translated">이것은 현재 pyportmidi를 사용하지만 나중에 언젠가는 자체 바인딩을 사용할 수 있습니다. 파이 포르 미디 바인딩은 파이 게임에 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="84e008716889e5210408374523cefec4fe72cbd8" translate="yes" xml:space="preserve">
          <source>This value is different than the per pixel Surface alpha. For a surface with per pixel alpha, blanket alpha is ignored and &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="translated">이 값은 픽셀 당 표면 알파와 다릅니다. 픽셀 당 알파가있는 표면의 경우 블랭킷 알파가 무시되고 &lt;code&gt;None&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="81041ec327a2999bf4390030dcb5e99272540680" translate="yes" xml:space="preserve">
          <source>This value is digital, &lt;code&gt;i.e.&lt;/code&gt;, each coordinate can be -1, 0 or 1 but never in-between.</source>
          <target state="translated">이 값은 디지털입니다. &lt;code&gt;i.e.&lt;/code&gt; , 각 좌표는 -1, 0 또는 1 일 수 있지만 그 사이에는 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bbd610ff534b10d32a22638b26ae7ef80a742faf" translate="yes" xml:space="preserve">
          <source>This value is not needed for normal pygame usage.</source>
          <target state="translated">일반적인 파이 게임 사용에는이 값이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2fc848ccc1e0d0f3a7a211d2dc2cb9026f888f0b" translate="yes" xml:space="preserve">
          <source>This versatile function can be used for find colors in a 'surf' close to a 'search_color' or close to colors in a separate 'search_surf'.</source>
          <target state="translated">이 다목적 기능은 'search_color'에 가까운 'surf'에서 색상을 찾거나 별도의 'search_surf'에있는 색상에 가까운 색상을 찾는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79cc1b603e28c4baa02eabef3723650cb810597a" translate="yes" xml:space="preserve">
          <source>This version information can easily be compared with other version numbers of the same format. An example of checking pygame version numbers would look like this:</source>
          <target state="translated">이 버전 정보는 동일한 형식의 다른 버전 번호와 쉽게 비교할 수 있습니다. 파이 게임 버전 번호를 확인하는 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="64304014d2d2fd277f64c37eaf12b16598bf88e6" translate="yes" xml:space="preserve">
          <source>This will begin playback of a Sound on a specific Channel. If the Channel is currently playing any other Sound it will be stopped.</source>
          <target state="translated">특정 채널에서 사운드 재생이 시작됩니다. 채널이 현재 다른 사운드를 재생중인 경우 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="dda232c63309e5038713c85a0f1c4c9e77632e9a" translate="yes" xml:space="preserve">
          <source>This will change the video display color palette for 8-bit displays. This does not change the palette for the actual display Surface, only the palette that is used to display the Surface. If no palette argument is passed, the system default palette will be restored. The palette is a sequence of &lt;code&gt;RGB&lt;/code&gt; triplets.</source>
          <target state="translated">8 비트 디스플레이의 비디오 디스플레이 색상 팔레트가 변경됩니다. 실제 디스플레이 표면의 팔레트는 변경되지 않고 표면을 표시하는 데 사용되는 팔레트 만 변경됩니다. 팔레트 인수가 전달되지 않으면 시스템 기본 팔레트가 복원됩니다. 팔레트는 일련의 &lt;code&gt;RGB&lt;/code&gt; 3 색입니다.</target>
        </trans-unit>
        <trans-unit id="c47215687eae802f8dd4f3a538511fb60cd54702" translate="yes" xml:space="preserve">
          <source>This will fade out the volume on all active channels over the time argument in milliseconds. After the sound is muted the playback will stop.</source>
          <target state="translated">시간 인수에 따른 모든 활성 채널의 볼륨이 밀리 초 단위로 사라집니다. 소리가 나지 않으면 재생이 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="a1342f56f2383f0f39b6745c3d0aa6213748d89b" translate="yes" xml:space="preserve">
          <source>This will find and return an inactive Channel object. If there are no inactive Channels this function will return &lt;code&gt;None&lt;/code&gt;. If there are no inactive channels and the force argument is &lt;code&gt;True&lt;/code&gt;, this will find the Channel with the longest running Sound and return it.</source>
          <target state="translated">비활성 채널 개체를 찾아 반환합니다. 비활성 채널이 없으면이 함수는 &lt;code&gt;None&lt;/code&gt; 을 반환 합니다. 비활성 채널이없고 force 인수가 &lt;code&gt;True&lt;/code&gt; 인 경우 가장 긴 사운드가 실행되는 채널을 찾아 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6b022d965c0bb2469248d35d9d711244e1848cb3" translate="yes" xml:space="preserve">
          <source>This will find collisions between all the Sprites in two groups. Collision is determined by comparing the &lt;code&gt;Sprite.rect&lt;/code&gt; attribute of each Sprite or by using the collided function if it is not None.</source>
          <target state="translated">그러면 두 그룹의 모든 Sprite간에 충돌이 발생합니다. 충돌은 각 Sprite 의 &lt;code&gt;Sprite.rect&lt;/code&gt; 속성을 비교 하거나 None이 아닌 경우 충돌 함수를 사용하여 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="abde0e3dd30aa6287fa5c89156f08cb38eb2225d" translate="yes" xml:space="preserve">
          <source>This will flip the width or height of a rectangle if it has a negative size. The rectangle will remain in the same place, with only the sides swapped.</source>
          <target state="translated">네거티브 크기의 사각형의 너비 또는 높이를 뒤집습니다. 사각형은 같은면에 유지되며 면만 교체됩니다.</target>
        </trans-unit>
        <trans-unit id="761f03a08168afde7f0d96ae1fba886a14a0ea1f" translate="yes" xml:space="preserve">
          <source>This will get all the messages and remove them from the queue. If a type or sequence of types is given only those messages will be removed from the queue.</source>
          <target state="translated">모든 메시지를 가져와 대기열에서 제거합니다. 유형 또는 일련의 유형이 제공되면 해당 메시지 만 큐에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="a706189c02015712d20187a23a95afe33fd2186a" translate="yes" xml:space="preserve">
          <source>This will load a music filename/file object and prepare it for playback. If a music stream is already playing it will be stopped. This does not start the music playing.</source>
          <target state="translated">음악 파일 이름 / 파일 객체가로드되고 재생 준비가됩니다. 음악 스트림이 이미 재생중인 경우 중지됩니다. 음악 재생이 시작되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d467459d1ad7e4bb1a21416e7601c17e3f14865f" translate="yes" xml:space="preserve">
          <source>This will load a sound file and queue it. A queued sound file will begin as soon as the current sound naturally ends. Only one sound can be queued at a time. Queuing a new sound while another sound is queued will result in the new sound becoming the queued sound. Also, if the current sound is ever stopped or changed, the queued sound will be lost.</source>
          <target state="translated">사운드 파일을로드하고 큐에 넣습니다. 대기중인 사운드 파일은 현재 사운드가 자연스럽게 종료되는 즉시 시작됩니다. 한 번에 하나의 사운드 만 대기 할 수 있습니다. 다른 사운드가 대기하는 동안 새 사운드를 대기 시키면 새 사운드가 대기 된 사운드가됩니다. 또한 현재 사운드가 중지되거나 변경된 경우 대기중인 사운드가 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="47de4afad0125858e1c928be2e6c19421da73056" translate="yes" xml:space="preserve">
          <source>This will only work on Surfaces that have 24-bit or 32-bit formats. Lower pixel formats cannot be referenced.</source>
          <target state="translated">24 비트 또는 32 비트 형식의 Surface에서만 작동합니다. 낮은 픽셀 형식은 참조 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="61357361764937aeaabd8c55df0059b1ef7fc4f3" translate="yes" xml:space="preserve">
          <source>This will open the cdrom drive and eject the cdrom. If the drive is playing or paused it will be stopped.</source>
          <target state="translated">CDROM 드라이브가 열리고 CDROM이 나옵니다. 드라이브가 재생 중이거나 일시 중지 된 경우 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="a3f5c06a69e806da7c0405e3da84285494648d46" translate="yes" xml:space="preserve">
          <source>This will play the loaded music stream. If the music is already playing it will be restarted.</source>
          <target state="translated">로드 된 음악 스트림이 재생됩니다. 음악이 이미 재생 중이면 다시 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="a89bdbacf4499cb7f34c2a2507bb6cdc49f8bdd0" translate="yes" xml:space="preserve">
          <source>This will resume all active sound channels after they have been paused.</source>
          <target state="translated">일시 정지 된 후 모든 활성 사운드 채널이 재개됩니다.</target>
        </trans-unit>
        <trans-unit id="224618de7c9dca78560410dc97665d480ba9d150" translate="yes" xml:space="preserve">
          <source>This will resume the playback of a music stream after it has been paused.</source>
          <target state="translated">음악 스트림이 일시 정지 된 후에 재생을 다시 시작합니다.</target>
        </trans-unit>
        <trans-unit id="6bb37bc5d0e80097b44411734f5ec9ed46f1d2ec" translate="yes" xml:space="preserve">
          <source>This will return a new image that is double the size of the original. It uses the AdvanceMAME Scale2X algorithm which does a 'jaggie-less' scale of bitmap graphics.</source>
          <target state="translated">원본 크기의 두 배인 새 이미지가 반환됩니다. 'jaggie-less'스케일 비트 맵 그래픽을 수행하는 AdvanceMAME Scale2X 알고리즘을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="2c80a280425290ab3a0f848989830f92e5e3713d" translate="yes" xml:space="preserve">
          <source>This will return the affected Surface area.</source>
          <target state="translated">영향을받는 표면 영역을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ca58cb14ea228c038f9e3f402d1a6febec0c384d" translate="yes" xml:space="preserve">
          <source>This will run much faster than &lt;a href=&quot;#pygame.image.fromstring&quot;&gt;&lt;code&gt;pygame.image.fromstring()&lt;/code&gt;&lt;/a&gt;, since no pixel data must be allocated and copied.</source>
          <target state="translated">픽셀 데이터를 할당하고 복사하지 않아야하므로 &lt;a href=&quot;#pygame.image.fromstring&quot;&gt; &lt;code&gt;pygame.image.fromstring()&lt;/code&gt; &lt;/a&gt; 보다 훨씬 빠르게 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="d922c6e0e38cc1f29ce30958bf6f7f04774019f9" translate="yes" xml:space="preserve">
          <source>This will save your Surface as either a &lt;code&gt;BMP&lt;/code&gt;, &lt;code&gt;TGA&lt;/code&gt;, &lt;code&gt;PNG&lt;/code&gt;, or &lt;code&gt;JPEG&lt;/code&gt; image. If the filename extension is unrecognized it will default to &lt;code&gt;TGA&lt;/code&gt;. Both &lt;code&gt;TGA&lt;/code&gt;, and &lt;code&gt;BMP&lt;/code&gt; file formats create uncompressed files.</source>
          <target state="translated">Surface를 &lt;code&gt;BMP&lt;/code&gt; , &lt;code&gt;TGA&lt;/code&gt; , &lt;code&gt;PNG&lt;/code&gt; 또는 &lt;code&gt;JPEG&lt;/code&gt; 이미지로 저장 합니다. 파일 이름 확장자가 인식되지 않으면 기본적으로 &lt;code&gt;TGA&lt;/code&gt; 로 설정됩니다 . &lt;code&gt;TGA&lt;/code&gt; 및 &lt;code&gt;BMP&lt;/code&gt; 파일 형식 모두 압축되지 않은 파일을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="365cc3bbbf945901e3bd3cfc1063249c90ec8423" translate="yes" xml:space="preserve">
          <source>This will set the playback volume (loudness) for this Sound. This will immediately affect the Sound if it is playing. It will also affect any future playback of this Sound.</source>
          <target state="translated">이 사운드의 재생 음량 (음량)이 설정됩니다. 재생중인 경우 즉시 사운드에 영향을줍니다. 이 사운드의 향후 재생에도 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="5b783d27bbe3d199da412ab261531453d6d326cf" translate="yes" xml:space="preserve">
          <source>This will shut down the entire display module. This means any active displays will be closed. This will also be handled automatically when the program exits.</source>
          <target state="translated">전체 디스플레이 모듈이 종료됩니다. 이것은 모든 활성 디스플레이가 닫히는 것을 의미합니다. 이것은 프로그램이 종료 될 때 자동으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="7fd9f3c23ebb71be56731e7ed42265b0dbf37a55" translate="yes" xml:space="preserve">
          <source>This will stop all playback of all active mixer channels.</source>
          <target state="translated">모든 활성 믹서 채널의 모든 재생이 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="0a34e3c3b05c87292fca941db99ed876dda96e39" translate="yes" xml:space="preserve">
          <source>This will stop playback of the sound after fading it out over the time argument in milliseconds. The Sound will fade and stop on all actively playing channels.</source>
          <target state="translated">시간 인수에 따라 밀리 초 단위로 페이드 아웃 된 후 사운드 재생이 중지됩니다. 모든 활성 채널에서 소리가 사라지고 멈 춥니 다.</target>
        </trans-unit>
        <trans-unit id="2272a4b65b71774cd9e229a28bf21800a3276d66" translate="yes" xml:space="preserve">
          <source>This will stop the music playback after it has been faded out over the specified time (measured in milliseconds).</source>
          <target state="translated">지정된 시간 (밀리 초 단위) 동안 페이드 아웃 된 음악 재생이 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="935ca9d3a597a5e2db0ce0eec9cfdb4a984a0d15" translate="yes" xml:space="preserve">
          <source>This will stop the playback of this Sound on any active Channels.</source>
          <target state="translated">활성 채널에서이 사운드의 재생이 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="a7ec44792f19f8ded35b1dc362521922d6cd2990" translate="yes" xml:space="preserve">
          <source>This will temporarily stop all playback on the active mixer channels. The playback can later be resumed with &lt;code&gt;pygame.mixer.unpause()&lt;/code&gt;</source>
          <target state="translated">활성 믹서 채널에서 모든 재생이 일시적으로 중지됩니다. 나중에 &lt;code&gt;pygame.mixer.unpause()&lt;/code&gt; 하여 재생을 다시 시작할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="85297d7eaf2f5c8ed21411772f855f9c28a926fd" translate="yes" xml:space="preserve">
          <source>This will uninitialize &lt;a href=&quot;#module-pygame.mixer&quot;&gt;&lt;code&gt;pygame.mixer&lt;/code&gt;&lt;/a&gt;. All playback will stop and any loaded Sound objects may not be compatible with the mixer if it is reinitialized later.</source>
          <target state="translated">&lt;a href=&quot;#module-pygame.mixer&quot;&gt; &lt;code&gt;pygame.mixer&lt;/code&gt; &lt;/a&gt; 초기화가 취소 됩니다. 나중에 다시 초기화하면 모든 재생이 중지되고로드 된 사운드 객체가 믹서와 호환되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a1d699c29cbee6600bfe16b296690cc25ea7021" translate="yes" xml:space="preserve">
          <source>This will uninitialize a Joystick. After this the pygame event queue will no longer receive events from the device.</source>
          <target state="translated">조이스틱이 초기화되지 않습니다. 이 후 파이 게임 이벤트 큐는 더 이상 장치로부터 이벤트를받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2d0fc10d5c67e7eec21032e75521bcaf2e807e0f" translate="yes" xml:space="preserve">
          <source>This will update the contents of the entire display. If your display mode is using the flags &lt;code&gt;pygame.HWSURFACE&lt;/code&gt; and &lt;code&gt;pygame.DOUBLEBUF&lt;/code&gt;, this will wait for a vertical retrace and swap the surfaces. If you are using a different type of display mode, it will simply update the entire contents of the surface.</source>
          <target state="translated">전체 디스플레이의 내용이 업데이트됩니다. 디스플레이 모드가 &lt;code&gt;pygame.HWSURFACE&lt;/code&gt; 및 &lt;code&gt;pygame.DOUBLEBUF&lt;/code&gt; 플래그를 사용하는 경우 수직 복귀 를 대기하고 표면을 교체합니다. 다른 유형의 디스플레이 모드를 사용하는 경우 단순히 표면의 전체 내용을 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="a0071554de884125971ba88499367973317a8acd" translate="yes" xml:space="preserve">
          <source>This will work on any type of Surface format. If the image has no colorkey a solid opaque array will be returned.</source>
          <target state="translated">이것은 모든 유형의 Surface 형식에서 작동합니다. 이미지에 컬러 키가 없으면 단색 불투명 배열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="2a3440fad6cb1b6aee924a7bc1686f5774d5d2ee" translate="yes" xml:space="preserve">
          <source>Threading note: each of the functions releases the GIL during the C part of the call.</source>
          <target state="translated">스레딩 노트 : 각 함수는 호출의 C 부분 동안 GIL을 해제합니다.</target>
        </trans-unit>
        <trans-unit id="d983797092c4a9ad56e0267458ee8ac6805c6269" translate="yes" xml:space="preserve">
          <source>Thumbnail generation with scaling is an example of what you can do with pygame.</source>
          <target state="translated">스케일링을 통한 썸네일 생성은 파이 게임으로 할 수있는 일의 예입니다.</target>
        </trans-unit>
        <trans-unit id="e7e605ad582cfe450cd1c0ab63c38ad1d9901c30" translate="yes" xml:space="preserve">
          <source>Time is measured relative to the time source indicated by time_proc. Timestamps are absolute, not relative delays or offsets.</source>
          <target state="translated">시간은 time_proc로 표시된 시간 소스를 기준으로 측정됩니다. 타임 스탬프는 절대적이며 상대적 지연 또는 오프셋이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="57c7f3342a0c86c35c80b16b6684278e3ddd69f3" translate="yes" xml:space="preserve">
          <source>Times in pygame are represented in milliseconds (1/1000 seconds). Most platforms have a limited time resolution of around 10 milliseconds. This resolution, in milliseconds, is given in the &lt;code&gt;TIMER_RESOLUTION&lt;/code&gt; constant.</source>
          <target state="translated">파이 게임의 시간은 밀리 초 (1/1000 초)로 표시됩니다. 대부분의 플랫폼은 약 10 밀리 초의 제한된 시간 해상도를 갖습니다. 이 해상도 (밀리 초)는 &lt;code&gt;TIMER_RESOLUTION&lt;/code&gt; 상수로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="8b91fb7d788f5133bde758775fee273c9f21f71c" translate="yes" xml:space="preserve">
          <source>Timestamps will be ignored if latency = 0</source>
          <target state="translated">대기 시간이 0이면 타임 스탬프가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="f1b37e6146a5141e30bafbb3d229257e39547b52" translate="yes" xml:space="preserve">
          <source>To access most of the Joystick methods, you'll need to &lt;code&gt;init()&lt;/code&gt; the Joystick. This is separate from making sure the joystick module is initialized. When multiple Joysticks objects are created for the same physical joystick device (i.e., they have the same &lt;code&gt;ID&lt;/code&gt; number), the state and values for those Joystick objects will be shared.</source>
          <target state="translated">대부분의 조이스틱 메소드에 액세스하려면 조이스틱을 &lt;code&gt;init()&lt;/code&gt; 해야합니다 . 조이스틱 모듈을 초기화하는 것과는 별개입니다. 동일한 물리적 조이스틱 장치에 대해 여러 개의 조이스틱 객체가 생성되면 (즉, 동일한 &lt;code&gt;ID&lt;/code&gt; 번호 를 가짐 ) 해당 조이스틱 객체의 상태와 값이 공유됩니다.</target>
        </trans-unit>
        <trans-unit id="b5dc0957ca08524e0577a49ee384f01cec3bd910" translate="yes" xml:space="preserve">
          <source>To disable the timer for an event, set the milliseconds argument to 0.</source>
          <target state="translated">이벤트 타이머를 비활성화하려면 milliseconds 인수를 0으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="e0af22e36a39233ddca45b5b3accdbd435a3170c" translate="yes" xml:space="preserve">
          <source>To draw an anti aliased and filled shape, first use the aa* version of the function, and then use the filled version. For example</source>
          <target state="translated">앤티 앨리어싱되고 채워진 모양을 그리려면 먼저 aa * 버전의 함수를 사용한 다음 채워진 버전을 사용하십시오. 예를 들어</target>
        </trans-unit>
        <trans-unit id="d94b0a65c29602c81f62f54cdf735462700ee644" translate="yes" xml:space="preserve">
          <source>To get a note to play immediately, send MIDI info with timestamp read from function Time</source>
          <target state="translated">음표를 즉시 재생하려면 타임 스탬프가있는 MIDI 정보를 Time 함수에서 읽습니다.</target>
        </trans-unit>
        <trans-unit id="653ad1649616f3252faa4728e01913cedbcdb706" translate="yes" xml:space="preserve">
          <source>To get the state of various input devices, you can forego the event queue and access the input devices directly with their appropriate modules: &lt;a href=&quot;mouse#module-pygame.mouse&quot;&gt;&lt;code&gt;pygame.mouse&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;key#module-pygame.key&quot;&gt;&lt;code&gt;pygame.key&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;joystick#module-pygame.joystick&quot;&gt;&lt;code&gt;pygame.joystick&lt;/code&gt;&lt;/a&gt;. If you use this method, remember that pygame requires some form of communication with the system window manager and other parts of the platform. To keep pygame in sync with the system, you will need to call &lt;a href=&quot;#pygame.event.pump&quot;&gt;&lt;code&gt;pygame.event.pump()&lt;/code&gt;&lt;/a&gt; to keep everything current. Usually, this should be called once per game loop. Note: Joysticks will not send any events until the device has been initialized.</source>
          <target state="translated">다양한 입력 장치의 상태를 얻으려면 이벤트 대기열을 포기하고 &lt;a href=&quot;mouse#module-pygame.mouse&quot;&gt; &lt;code&gt;pygame.mouse&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;key#module-pygame.key&quot;&gt; &lt;code&gt;pygame.key&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;joystick#module-pygame.joystick&quot;&gt; &lt;code&gt;pygame.joystick&lt;/code&gt; &lt;/a&gt; 모듈을 사용하여 입력 장치에 직접 액세스하십시오 . 이 방법을 사용하는 경우 pygame은 시스템 창 관리자 및 플랫폼의 다른 부분과 통신해야합니다. 파이 게임을 시스템과 동기화 상태로 유지하려면 모든 것을 최신 상태로 유지하려면 &lt;a href=&quot;#pygame.event.pump&quot;&gt; &lt;code&gt;pygame.event.pump()&lt;/code&gt; &lt;/a&gt; 를 호출해야합니다 . 일반적으로 게임 루프 당 한 번 호출해야합니다. 참고 : 조이스틱은 장치가 초기화 될 때까지 이벤트를 보내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bf44c770d4e1946754ddc5ef380d76f79fe3c707" translate="yes" xml:space="preserve">
          <source>To skip drawing the set bits, both &lt;code&gt;setsurface&lt;/code&gt; and &lt;code&gt;setcolor&lt;/code&gt; must be &lt;code&gt;None&lt;/code&gt;. The &lt;code&gt;setsurface&lt;/code&gt; parameter defaults to &lt;code&gt;None&lt;/code&gt;, but &lt;code&gt;setcolor&lt;/code&gt; defaults to a color value and therefore must be set to &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">세트 비트 그리기를 건너 뛰려면 &lt;code&gt;setsurface&lt;/code&gt; 와 &lt;code&gt;setcolor&lt;/code&gt; 가 모두 &lt;code&gt;None&lt;/code&gt; 이어야합니다 . &lt;code&gt;setsurface&lt;/code&gt; 의 에 매개 변수의 기본값은 &lt;code&gt;None&lt;/code&gt; 하지만, &lt;code&gt;setcolor&lt;/code&gt; 색상 값 기본값 따라서는 설정해야합니다 &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf4d4873bf33d501d8b9d21d87b923a0f1222e2c" translate="yes" xml:space="preserve">
          <source>To skip drawing the unset bits, both &lt;code&gt;unsetsurface&lt;/code&gt; and &lt;code&gt;unsetcolor&lt;/code&gt; must be &lt;code&gt;None&lt;/code&gt;. The &lt;code&gt;unsetsurface&lt;/code&gt; parameter defaults to &lt;code&gt;None&lt;/code&gt;, but &lt;code&gt;unsetcolor&lt;/code&gt; defaults to a color value and therefore must be set to &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">설정되지 않은 비트 그리기를 건너 뛰려면 &lt;code&gt;unsetsurface&lt;/code&gt; 및 &lt;code&gt;unsetcolor&lt;/code&gt; 가 모두 &lt;code&gt;None&lt;/code&gt; 이어야합니다 . &lt;code&gt;unsetsurface&lt;/code&gt; 에 매개 변수의 기본값은 &lt;code&gt;None&lt;/code&gt; 하지만 &lt;code&gt;unsetcolor&lt;/code&gt; 색상 값 기본값 따라서는 설정해야합니다 &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46ec9df86271893bda2e9a8e81030fd2397d8405" translate="yes" xml:space="preserve">
          <source>To specify both the interface and the device name in the registry, separate the two with a comma and a space. The string before the comma must be a substring of the &quot;interf&quot; string and the string after the space must be a substring of the &quot;name&quot; name string in order to match the device. e.g.:</source>
          <target state="translated">레지스트리에서 인터페이스와 장치 이름을 모두 지정하려면 둘을 쉼표와 공백으로 구분하십시오. 쉼표 앞의 문자열은 &quot;interf&quot;문자열의 하위 문자열이어야하며 공백 뒤의 문자열은 장치와 일치하도록 &quot;name&quot;이름 문자열의 하위 문자열이어야합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="4206da10b7cf84dc271ec053758de89250f4047d" translate="yes" xml:space="preserve">
          <source>To use the &lt;a href=&quot;freetype#module-pygame.freetype&quot;&gt;&lt;code&gt;pygame.freetype&lt;/code&gt;&lt;/a&gt; based &lt;code&gt;pygame.ftfont&lt;/code&gt; as &lt;a href=&quot;#module-pygame.font&quot;&gt;&lt;code&gt;pygame.font&lt;/code&gt;&lt;/a&gt; define the environment variable PYGAME_FREETYPE before the first import of &lt;a href=&quot;pygame#module-pygame&quot;&gt;&lt;code&gt;pygame&lt;/code&gt;&lt;/a&gt;. Module &lt;code&gt;pygame.ftfont&lt;/code&gt; is a &lt;a href=&quot;#module-pygame.font&quot;&gt;&lt;code&gt;pygame.font&lt;/code&gt;&lt;/a&gt; compatible module that passes all but one of the font module unit tests: it does not have the UCS-2 limitation of the SDL_ttf based font module, so fails to raise an exception for a code point greater than 'uFFFF'. If &lt;a href=&quot;freetype#module-pygame.freetype&quot;&gt;&lt;code&gt;pygame.freetype&lt;/code&gt;&lt;/a&gt; is unavailable then the SDL_ttf font module will be loaded instead.</source>
          <target state="translated">용도에 &lt;a href=&quot;freetype#module-pygame.freetype&quot;&gt; &lt;code&gt;pygame.freetype&lt;/code&gt; &lt;/a&gt; 기반 &lt;code&gt;pygame.ftfont&lt;/code&gt; 을 같이 &lt;a href=&quot;#module-pygame.font&quot;&gt; &lt;code&gt;pygame.font&lt;/code&gt; 이&lt;/a&gt; 의 첫 번째 가져 오기 전에 환경 변수 PYGAME_FREETYPE를 정의 &lt;a href=&quot;pygame#module-pygame&quot;&gt; &lt;code&gt;pygame&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;pygame.ftfont&lt;/code&gt; 모듈 은 &lt;a href=&quot;#module-pygame.font&quot;&gt; &lt;code&gt;pygame.font&lt;/code&gt; &lt;/a&gt; 호환 모듈로, 폰트 모듈 단위 테스트 중 하나를 모두 통과합니다. SDL_ttf 기반 폰트 모듈의 UCS-2 제한이 없으므로 코드 포인트에 대한 예외를 발생시키지 않습니다. 'uFFFF'보다. 경우 &lt;a href=&quot;freetype#module-pygame.freetype&quot;&gt; &lt;code&gt;pygame.freetype&lt;/code&gt; 는&lt;/a&gt; 사용할 수 없습니다 다음 SDL_ttf 글꼴 모듈 대신로드됩니다.</target>
        </trans-unit>
        <trans-unit id="36be7610d89cb295d2f4762d34558c4e70e7b884" translate="yes" xml:space="preserve">
          <source>True, Pixels within threshold are changed.</source>
          <target state="translated">사실, 임계 값 내의 픽셀이 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="15ea0cf1a86c14148b84d52f032d20c30175e530" translate="yes" xml:space="preserve">
          <source>Turn a note off in the output stream. The note must already be on for this to work correctly.</source>
          <target state="translated">출력 스트림에서 음표를 끕니다. 이 기능이 제대로 작동하려면 메모가 이미 켜져 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="4d78486076704ab22dfd95c8113eb0275a8f1c83" translate="yes" xml:space="preserve">
          <source>Turn a note on in the output stream. The note must already be off for this to work correctly.</source>
          <target state="translated">출력 스트림에서 메모를 켭니다. 이 기능이 제대로 작동하려면 메모가 이미 꺼져 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="143002fdfa7a936c6ed8e58ba31141b1dc456edb" translate="yes" xml:space="preserve">
          <source>Unfiltered counterclockwise rotation. The angle argument represents degrees and can be any floating point value. Negative angle amounts will rotate clockwise.</source>
          <target state="translated">필터링되지 않은 반 시계 방향 회전. 각도 인수는 각도를 나타내며 임의의 부동 소수점 값이 될 수 있습니다. 음의 각도는 시계 방향으로 회전합니다.</target>
        </trans-unit>
        <trans-unit id="0c701e3c65df60be38626ab391cba582eaea585c" translate="yes" xml:space="preserve">
          <source>Uninitialize a drive for use. Call this when your program will not be accessing the drive for awhile.</source>
          <target state="translated">사용하기 위해 드라이브를 초기화하지 마십시오. 프로그램이 잠시 동안 드라이브에 액세스하지 않을 때 이것을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="b26117f02a4c66394c71eacbc0953c96c3f5d62c" translate="yes" xml:space="preserve">
          <source>Uninitialize all pygame modules that have previously been initialized. When the Python interpreter shuts down, this method is called regardless, so your program should not need it, except when it wants to terminate its pygame resources and continue. It is safe to call this function more than once as repeated calls have no effect.</source>
          <target state="translated">이전에 초기화 한 모든 파이 게임 모듈을 초기화 해제합니다. 파이썬 인터프리터가 종료되면이 메소드는 관계없이 호출되므로 파이 게임 리소스를 종료하고 계속하려는 경우를 제외하고는 프로그램에서 필요하지 않습니다. 반복되는 호출은 효과가 없으므로이 기능을 두 번 이상 호출하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="aa02abfef768fa6445717f5e5ad24c85d51b46e7" translate="yes" xml:space="preserve">
          <source>Uninitialize the cdrom module. After you call this any existing &lt;code&gt;CD&lt;/code&gt; objects will no longer work.</source>
          <target state="translated">cdrom 모듈을 초기화 해제하십시오. 이것을 호출하면 기존 &lt;code&gt;CD&lt;/code&gt; 객체가 더 이상 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dd19f983d6a4ef0787c8a44dd67ad09269391a64" translate="yes" xml:space="preserve">
          <source>Uninitialize the display module</source>
          <target state="translated">디스플레이 모듈을 초기화하지 마십시오</target>
        </trans-unit>
        <trans-unit id="398f19c78371b676c1b3e5ac90cb787b8081ea6c" translate="yes" xml:space="preserve">
          <source>Uninitialize the joystick module.</source>
          <target state="translated">조이스틱 모듈을 초기화하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="d13e29c03a05d9580a963197a5987463865f6c3e" translate="yes" xml:space="preserve">
          <source>Uninitialize the joystick module. After you call this any existing joystick objects will no longer work.</source>
          <target state="translated">조이스틱 모듈을 초기화하지 마십시오. 이것을 호출하면 기존 조이스틱 객체가 더 이상 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d1c2434e402ea60d8371962edbdc4254e6691111" translate="yes" xml:space="preserve">
          <source>Uninitializes the &lt;a href=&quot;#module-pygame.midi&quot;&gt;&lt;code&gt;pygame.midi&lt;/code&gt;&lt;/a&gt; module. If &lt;a href=&quot;#pygame.midi.init&quot;&gt;&lt;code&gt;pygame.midi.init()&lt;/code&gt;&lt;/a&gt; was called to initialize the &lt;a href=&quot;#module-pygame.midi&quot;&gt;&lt;code&gt;pygame.midi&lt;/code&gt;&lt;/a&gt; module, then this function will be called automatically when your program exits.</source>
          <target state="translated">&lt;a href=&quot;#module-pygame.midi&quot;&gt; &lt;code&gt;pygame.midi&lt;/code&gt; &lt;/a&gt; 모듈을 초기화하지 않습니다 . 경우 &lt;a href=&quot;#pygame.midi.init&quot;&gt; &lt;code&gt;pygame.midi.init()&lt;/code&gt; &lt;/a&gt; 초기화하기 위해 호출 된 &lt;a href=&quot;#module-pygame.midi&quot;&gt; &lt;code&gt;pygame.midi&lt;/code&gt; 의&lt;/a&gt; 모듈을,이 기능이 자동으로 할 때 프로그램이 종료를 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="b8154c04a77fd9ff19c426c1190336b74d83caec" translate="yes" xml:space="preserve">
          <source>Unless rotating by 90 degree increments, the image will be padded larger to hold the new size. If the image has pixel alphas, the padded area will be transparent. Otherwise pygame will pick a color that matches the Surface colorkey or the topleft pixel value.</source>
          <target state="translated">90 도씩 회전하지 않으면 새로운 크기를 유지하기 위해 이미지가 더 크게 채워집니다. 이미지에 픽셀 알파가 있으면 채워진 영역이 투명 해집니다. 그렇지 않으면 pygame은 Surface 컬러 키 또는 왼쪽 상단 픽셀 값과 일치하는 색상을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="fc2a3c5e7f65d37b3d811f09b989e46f63595933" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;a href=&quot;#pygame.Surface.convert&quot;&gt;&lt;code&gt;convert()&lt;/code&gt;&lt;/a&gt; method, the pixel format for the new image will not be exactly the same as the requested source, but it will be optimized for fast alpha blitting to the destination.</source>
          <target state="translated">&lt;a href=&quot;#pygame.Surface.convert&quot;&gt; &lt;code&gt;convert()&lt;/code&gt; &lt;/a&gt; 메서드 와 달리 새 이미지의 픽셀 형식은 요청 된 소스와 정확히 같지 않지만 대상에 빠른 알파 블리 팅을 위해 최적화됩니다.</target>
        </trans-unit>
        <trans-unit id="5f8a599fde7d1b89b4b145567df803da311a1321" translate="yes" xml:space="preserve">
          <source>Unload the currently loaded music to free up resources</source>
          <target state="translated">현재로드 된 음악을 언로드하여 리소스를 확보하십시오.</target>
        </trans-unit>
        <trans-unit id="fef26a5c9845c77d399676fbb344fd94d1d28b62" translate="yes" xml:space="preserve">
          <source>Unlock the Surface pixel data after it has been locked. The unlocked Surface can once again be drawn and managed by pygame. See the &lt;a href=&quot;#pygame.Surface.lock&quot;&gt;&lt;code&gt;lock()&lt;/code&gt;&lt;/a&gt; documentation for more details.</source>
          <target state="translated">Surface 픽셀 데이터가 잠긴 후에 잠금을 해제합니다. 파이 게임으로 잠금 해제 된 Surface를 다시 한 번 그려서 관리 할 수 ​​있습니다. 자세한 내용은 &lt;a href=&quot;#pygame.Surface.lock&quot;&gt; &lt;code&gt;lock()&lt;/code&gt; &lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="40a0b1b647f2da6d4c5b14e33cd05c3cd5f158a9" translate="yes" xml:space="preserve">
          <source>Unpause a paused &lt;code&gt;CD&lt;/code&gt;. If the &lt;code&gt;CD&lt;/code&gt; is not paused or already playing, this method does nothing.</source>
          <target state="translated">일시 정지 된 &lt;code&gt;CD&lt;/code&gt; 를 일시 정지 해제하십시오 . 경우 &lt;code&gt;CD&lt;/code&gt; 가 일시 정지되거나 이미 재생되지 않는,이 메소드는 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a6d4c2ffc40f9d1f29463494a77c29c7bcecf833" translate="yes" xml:space="preserve">
          <source>Update portions of the screen for software displays</source>
          <target state="translated">소프트웨어 디스플레이 화면 일부 업데이트</target>
        </trans-unit>
        <trans-unit id="9b9a29b16a87dfab8c7901b9a2d8eb85c095e72e" translate="yes" xml:space="preserve">
          <source>Update the full display Surface to the screen</source>
          <target state="translated">전체 디스플레이 화면을 화면으로 업데이트</target>
        </trans-unit>
        <trans-unit id="5d4929543b73688563f7da0074ada08c29b142d3" translate="yes" xml:space="preserve">
          <source>Used internally (read-only)</source>
          <target state="translated">내부적으로 사용 (읽기 전용)</target>
        </trans-unit>
        <trans-unit id="2554c87e2588e7bf1790d5d08347dd7da034158a" translate="yes" xml:space="preserve">
          <source>Used to indicate if any data exists.</source>
          <target state="translated">데이터가 존재하는지 여부를 나타내는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0150a1d513a8de19c4b51f9687ac9c364a09e506" translate="yes" xml:space="preserve">
          <source>Useful for fast pixel perfect collision detection. A mask uses 1 bit per-pixel to store which parts collide.</source>
          <target state="translated">빠른 픽셀 완벽한 충돌 감지에 유용합니다. 마스크는 픽셀 당 1 비트를 사용하여 충돌하는 부분을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="92624dfdcfcc53890a92c50c134e873a352be96b" translate="yes" xml:space="preserve">
          <source>User defined types can be used, but the data might not be accessible by other applications unless they know what data type to look for. Example: Data placed into the clipboard by &lt;code&gt;pygame.scrap.put(&quot;my_data_type&quot;, byte_data)&lt;/code&gt; can only be accessed by applications which query the clipboard for the &lt;code&gt;&quot;my_data_type&quot;&lt;/code&gt; data type.</source>
          <target state="translated">사용자 정의 유형을 사용할 수 있지만 어떤 데이터 유형을 찾아야하는지 알지 못하면 다른 응용 프로그램에서 데이터에 액세스 할 수 없습니다. 예 : &lt;code&gt;pygame.scrap.put(&quot;my_data_type&quot;, byte_data)&lt;/code&gt; 의해 클립 보드에 배치 된 데이터 는 클립 보드에 &lt;code&gt;&quot;my_data_type&quot;&lt;/code&gt; 데이터 유형 을 쿼리하는 응용 프로그램에서만 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3f4f2fb6db824aa501228a26a8a8ae7cf3e69eb5" translate="yes" xml:space="preserve">
          <source>Uses one of two different algorithms for scaling each dimension of the input surface as required. For shrinkage, the output pixels are area averages of the colors they cover. For expansion, a bilinear filter is used. For the x86-64 and i686 architectures, optimized &lt;code&gt;MMX&lt;/code&gt; routines are included and will run much faster than other machine types. The size is a 2 number sequence for (width, height). This function only works for 24-bit or 32-bit surfaces. An exception will be thrown if the input surface bit depth is less than 24.</source>
          <target state="translated">필요에 따라 입력 표면의 각 치수를 스케일링하기 위해 두 가지 다른 알고리즘 중 하나를 사용합니다. 수축의 경우 출력 픽셀은 해당 색상의 면적 평균입니다. 확장을 위해 이중 선형 필터가 사용됩니다. x86-64 및 i686 아키텍처의 경우 최적화 된 &lt;code&gt;MMX&lt;/code&gt; 루틴이 포함되며 다른 시스템 유형보다 훨씬 빠르게 실행됩니다. 크기는 (너비, 높이)에 대한 2 개의 숫자 시퀀스입니다. 이 기능은 24 비트 또는 32 비트 표면에서만 작동합니다. 입력 표면 비트 깊이가 24보다 작 으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="00e71b17b34c089f11cdab0acd032f88c60efa36" translate="yes" xml:space="preserve">
          <source>Uses sndarray and NumPy to create offset faded copies of the original sound. Currently it just uses hardcoded values for the number of echoes and the delay. Easy for you to recreate as needed.</source>
          <target state="translated">sndarray 및 NumPy를 사용하여 원본 사운드의 오프셋 페이드 복사본을 만듭니다. 현재 에코 수와 지연 시간에 하드 코딩 된 값만 사용합니다. 필요에 따라 쉽게 다시 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b2e6c52972e55bee2be2fd950b2a80b59b22c17" translate="yes" xml:space="preserve">
          <source>Using PyOpenGL and pygame, this creates a spinning 3D multicolored cube.</source>
          <target state="translated">PyOpenGL과 파이 게임을 사용하여 회전하는 3D 멀티 컬러 큐브를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="eaf5a72b9b155f85a6d94689d194dfd6fb24b2cb" translate="yes" xml:space="preserve">
          <source>Usually the depth argument is not passed, but some platforms can support multiple display depths. If passed it will hint to which depth is a better match.</source>
          <target state="translated">일반적으로 깊이 인수는 전달되지 않지만 일부 플랫폼은 여러 디스플레이 깊이를 지원할 수 있습니다. 통과하면 어느 깊이가 더 잘 일치하는지 암시합니다.</target>
        </trans-unit>
        <trans-unit id="f0100a25ff398d99737ba3b915338d0cb334ee3e" translate="yes" xml:space="preserve">
          <source>We're always on the lookout for more examples and/or example requests. Code like this is probably the best way to start getting involved with python gaming.</source>
          <target state="translated">우리는 항상 더 많은 예제 및 / 또는 예제 요청을 찾고 있습니다. 이와 같은 코드는 아마도 파이썬 게임에 참여하기 시작하는 가장 좋은 방법 일 것입니다.</target>
        </trans-unit>
        <trans-unit id="53be1b49a60a3a6c5dacc6395a128964d8e6c40e" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#pygame.freetype.Font.render_to&quot;&gt;&lt;code&gt;render_to()&lt;/code&gt;&lt;/a&gt; is called with the same font properties ― &lt;a href=&quot;#pygame.freetype.Font.size&quot;&gt;&lt;code&gt;size&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pygame.freetype.Font.style&quot;&gt;&lt;code&gt;style&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pygame.freetype.Font.strength&quot;&gt;&lt;code&gt;strength&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pygame.freetype.Font.wide&quot;&gt;&lt;code&gt;wide&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pygame.freetype.Font.antialiased&quot;&gt;&lt;code&gt;antialiased&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pygame.freetype.Font.vertical&quot;&gt;&lt;code&gt;vertical&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pygame.freetype.Font.rotation&quot;&gt;&lt;code&gt;rotation&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pygame.freetype.Font.kerning&quot;&gt;&lt;code&gt;kerning&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#pygame.freetype.Font.use_bitmap_strikes&quot;&gt;&lt;code&gt;use_bitmap_strikes&lt;/code&gt;&lt;/a&gt; ― as &lt;a href=&quot;#pygame.freetype.Font.get_rect&quot;&gt;&lt;code&gt;get_rect()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pygame.freetype.Font.render_to&quot;&gt;&lt;code&gt;render_to()&lt;/code&gt;&lt;/a&gt; will use the layout calculated by &lt;a href=&quot;#pygame.freetype.Font.get_rect&quot;&gt;&lt;code&gt;get_rect()&lt;/code&gt;&lt;/a&gt;. Otherwise, &lt;a href=&quot;#pygame.freetype.Font.render_to&quot;&gt;&lt;code&gt;render_to()&lt;/code&gt;&lt;/a&gt; will recalculate the layout if called with a text string or one of the above properties has changed after the &lt;a href=&quot;#pygame.freetype.Font.get_rect&quot;&gt;&lt;code&gt;get_rect()&lt;/code&gt;&lt;/a&gt; call.</source>
          <target state="translated">경우 &lt;a href=&quot;#pygame.freetype.Font.render_to&quot;&gt; &lt;code&gt;render_to()&lt;/code&gt; &lt;/a&gt; - 동일한 폰트 속성이라고 &lt;a href=&quot;#pygame.freetype.Font.size&quot;&gt; &lt;code&gt;size&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#pygame.freetype.Font.style&quot;&gt; &lt;code&gt;style&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#pygame.freetype.Font.strength&quot;&gt; &lt;code&gt;strength&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#pygame.freetype.Font.wide&quot;&gt; &lt;code&gt;wide&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#pygame.freetype.Font.antialiased&quot;&gt; &lt;code&gt;antialiased&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#pygame.freetype.Font.vertical&quot;&gt; &lt;code&gt;vertical&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#pygame.freetype.Font.rotation&quot;&gt; &lt;code&gt;rotation&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#pygame.freetype.Font.kerning&quot;&gt; &lt;code&gt;kerning&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#pygame.freetype.Font.use_bitmap_strikes&quot;&gt; &lt;code&gt;use_bitmap_strikes&lt;/code&gt; &lt;/a&gt; 등 - &lt;a href=&quot;#pygame.freetype.Font.get_rect&quot;&gt; &lt;code&gt;get_rect()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#pygame.freetype.Font.render_to&quot;&gt; &lt;code&gt;render_to()&lt;/code&gt; &lt;/a&gt; 에 의해 계산 된 레이아웃을 사용 &lt;a href=&quot;#pygame.freetype.Font.get_rect&quot;&gt; &lt;code&gt;get_rect()&lt;/code&gt; &lt;/a&gt; . 그렇지 않으면, &lt;a href=&quot;#pygame.freetype.Font.render_to&quot;&gt; &lt;code&gt;render_to()&lt;/code&gt; &lt;/a&gt; 는 텍스트 문자열로 호출되거나 &lt;a href=&quot;#pygame.freetype.Font.get_rect&quot;&gt; &lt;code&gt;get_rect()&lt;/code&gt; &lt;/a&gt; 호출 후 위의 속성 중 하나가 변경된 경우 레이아웃을 다시 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="73c88abf27af077842bf012e31e14961e1829927" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#pygame.quit&quot;&gt;&lt;code&gt;pygame.quit()&lt;/code&gt;&lt;/a&gt; is called, all registered quit functions are called. Pygame modules do this automatically when they are initializing, so this function will rarely be needed.</source>
          <target state="translated">때 &lt;a href=&quot;#pygame.quit&quot;&gt; &lt;code&gt;pygame.quit()&lt;/code&gt; &lt;/a&gt; 호출되면 등록 된 모든 함수가 호출 종료합니다. 파이 게임 모듈은 초기화 할 때 자동으로이를 수행하므로이 기능은 거의 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a98d91d979f16ff5b8f24cff39116acb9d707fa4" translate="yes" xml:space="preserve">
          <source>When a Sound is queued on a Channel, it will begin playing immediately after the current Sound is finished. Each channel can only have a single Sound queued at a time. The queued Sound will only play if the current playback finished automatically. It is cleared on any other call to &lt;code&gt;Channel.stop()&lt;/code&gt; or &lt;code&gt;Channel.play()&lt;/code&gt;.</source>
          <target state="translated">사운드가 채널에 대기하면 현재 사운드가 끝난 직후에 재생이 시작됩니다. 각 채널은 한 번에 하나의 사운드 만 대기 할 수 있습니다. 대기중인 사운드는 현재 재생이 자동으로 완료된 경우에만 재생됩니다. &lt;code&gt;Channel.stop()&lt;/code&gt; 또는 &lt;code&gt;Channel.play()&lt;/code&gt; 에 대한 다른 호출에서 지워집니다 .</target>
        </trans-unit>
        <trans-unit id="5a958df5f8336cf009e716a923094a068cd92343" translate="yes" xml:space="preserve">
          <source>When an endevent is set for a channel, it will send an event to the pygame queue every time a sound finishes playing on that channel (not just the first time). Use &lt;code&gt;pygame.event.get()&lt;/code&gt; to retrieve the endevent once it's sent.</source>
          <target state="translated">채널에 대한 종료 이벤트가 설정되면 해당 채널에서 사운드가 처음으로 종료 될 때마다 파이 게임 대기열에 이벤트를 보냅니다. &lt;code&gt;pygame.event.get()&lt;/code&gt; 을 사용 하여 종료 이벤트가 전송되면 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="92c9caa6a5e91415ac1de292fcc11d0021628493" translate="yes" xml:space="preserve">
          <source>When assigning to a range of of pixels, a non tuple sequence of colors or a PixelArray can be used as the value. For a sequence, the length must match the PixelArray width.</source>
          <target state="translated">픽셀 범위에 할당 할 때 튜플이 아닌 색상 시퀀스 또는 PixelArray를 값으로 사용할 수 있습니다. 시퀀스의 경우 길이는 PixelArray 너비와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="1cf1b3b6f37a30a0645a03a30f38e563e74b45f4" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;pygame.display.set_mode()&lt;/code&gt; with the &lt;code&gt;pygame.OPENGL&lt;/code&gt; flag, Pygame automatically handles setting the OpenGL attributes like color and double-buffering. OpenGL offers several other attributes you may want control over. Pass one of these attributes as the flag, and its appropriate value. This must be called before &lt;code&gt;pygame.display.set_mode()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pygame.OPENGL&lt;/code&gt; 플래그로 &lt;code&gt;pygame.display.set_mode()&lt;/code&gt; 를 호출하면 Pygame은 색상 및 이중 버퍼링과 같은 OpenGL 속성 설정을 자동으로 처리합니다. OpenGL은 제어 할 수있는 몇 가지 다른 속성을 제공합니다. 이러한 속성 중 하나를 플래그 및 적절한 값으로 전달하십시오. &lt;code&gt;pygame.display.set_mode()&lt;/code&gt; 전에 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3e1d6c0d2b132436b7f832505de73d0340ba6f72" translate="yes" xml:space="preserve">
          <source>When compiled with SDL2, pygame has these additional events and their attributes.</source>
          <target state="translated">SDL2로 컴파일하면 파이 게임에는 이러한 추가 이벤트와 해당 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="27caf06875001946a68deea0b8ac81c38493ab39" translate="yes" xml:space="preserve">
          <source>When enabled, all rendered fonts will include an underline. The underline is always one pixel thick, regardless of font size. This can be mixed with the bold and italic modes.</source>
          <target state="translated">활성화하면 렌더링 된 모든 글꼴에 밑줄이 포함됩니다. 밑줄은 글꼴 크기에 관계없이 항상 한 픽셀 두께입니다. 이것은 볼드체와 이탤릭체 모드와 혼합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="007f91b3a48fafbe920fac66095abc716e61ff09" translate="yes" xml:space="preserve">
          <source>When pygame is initialized the key repeat is disabled.</source>
          <target state="translated">파이 게임이 초기화되면 키 반복이 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="64b9c7a8ab3da525236c9ea5619ff144721e8d04" translate="yes" xml:space="preserve">
          <source>When requesting fullscreen display modes, sometimes an exact match for the requested size cannot be made. In these situations pygame will select the closest compatible match. The returned surface will still always match the requested size.</source>
          <target state="translated">전체 화면 표시 모드를 요청하는 경우 요청한 크기와 정확히 일치하지 않는 경우가 있습니다. 이러한 상황에서 파이 게임은 가장 가까운 호환 가능한 경기를 선택합니다. 반환 된 표면은 여전히 ​​요청 된 크기와 항상 일치합니다.</target>
        </trans-unit>
        <trans-unit id="50193ec41c8e2ccba142b0671ddef6c82c6fe9a0" translate="yes" xml:space="preserve">
          <source>When running click on a black triangle to move one pixel in the direction the triangle points. Or use the arrow keys. Close the window or press &lt;code&gt;ESC&lt;/code&gt; to quit.</source>
          <target state="translated">실행할 때 검은 색 삼각형을 클릭하여 삼각형이 가리키는 방향으로 한 픽셀을 이동하십시오. 또는 화살표 키를 사용하십시오. 창 을 닫거나 &lt;code&gt;ESC&lt;/code&gt; 를 눌러 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="e6600580c1178c8be398922cf0703e21bd250450" translate="yes" xml:space="preserve">
          <source>When subclassing the Sprite, be sure to call the base initializer before adding the Sprite to Groups. For example:</source>
          <target state="translated">Sprite를 서브 클래 싱 할 때 Sprite를 그룹에 추가하기 전에 기본 이니셜 라이저를 호출하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d328d2cb2f68e0de9008b97d671137a356b26a06" translate="yes" xml:space="preserve">
          <source>When the display is iconified &lt;code&gt;pygame.display.get_active()&lt;/code&gt; will return False. The event queue should receive a &lt;code&gt;ACTIVEEVENT&lt;/code&gt; event when the window has been iconified.</source>
          <target state="translated">디스플레이가 아이콘 &lt;code&gt;pygame.display.get_active()&lt;/code&gt; 는 False를 반환합니다. 윈도우가 아이콘 &lt;code&gt;ACTIVEEVENT&lt;/code&gt; 이벤트 큐에 ACTIVEEVENT 이벤트 가 수신되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="16c0992ed18e766b571f8df74acfadfff78ed089" translate="yes" xml:space="preserve">
          <source>When the display mode is set, several events are placed on the pygame event queue. &lt;code&gt;pygame.QUIT&lt;/code&gt; is sent when the user has requested the program to shut down. The window will receive &lt;code&gt;pygame.ACTIVEEVENT&lt;/code&gt; events as the display gains and loses input focus. If the display is set with the &lt;code&gt;pygame.RESIZABLE&lt;/code&gt; flag, &lt;code&gt;pygame.VIDEORESIZE&lt;/code&gt; events will be sent when the user adjusts the window dimensions. Hardware displays that draw direct to the screen will get &lt;code&gt;pygame.VIDEOEXPOSE&lt;/code&gt; events when portions of the window must be redrawn.</source>
          <target state="translated">디스플레이 모드가 설정되면 파이 게임 이벤트 큐에 여러 이벤트가 배치됩니다. &lt;code&gt;pygame.QUIT&lt;/code&gt; 는 사용자가 프로그램 종료를 요청했을 때 전송됩니다. 디스플레이는 입력 포커스를 얻거나 잃을 때 &lt;code&gt;pygame.ACTIVEEVENT&lt;/code&gt; 이벤트를 수신 합니다. &lt;code&gt;pygame.RESIZABLE&lt;/code&gt; 플래그로 디스플레이를 설정 하면 사용자가 창 크기를 조정할 때 &lt;code&gt;pygame.VIDEORESIZE&lt;/code&gt; 이벤트가 전송됩니다. 화면에 직접 그리는 하드웨어 디스플레이 는 창의 일부를 다시 그려야 할 때 &lt;code&gt;pygame.VIDEOEXPOSE&lt;/code&gt; 이벤트 를받습니다 .</target>
        </trans-unit>
        <trans-unit id="207480272ec92ccc027fcda32955f5974c9347a3" translate="yes" xml:space="preserve">
          <source>When the display mode is set, the event queue will start receiving mouse events. The mouse buttons generate &lt;code&gt;pygame.MOUSEBUTTONDOWN&lt;/code&gt; and &lt;code&gt;pygame.MOUSEBUTTONUP&lt;/code&gt; events when they are pressed and released. These events contain a button attribute representing which button was pressed. The mouse wheel will generate &lt;code&gt;pygame.MOUSEBUTTONDOWN&lt;/code&gt; and &lt;code&gt;pygame.MOUSEBUTTONUP&lt;/code&gt; events when rolled. The button will be set to 4 when the wheel is rolled up, and to button 5 when the wheel is rolled down. Whenever the mouse is moved it generates a &lt;code&gt;pygame.MOUSEMOTION&lt;/code&gt; event. The mouse movement is broken into small and accurate motion events. As the mouse is moving many motion events will be placed on the queue. Mouse motion events that are not properly cleaned from the event queue are the primary reason the event queue fills up.</source>
          <target state="translated">디스플레이 모드가 설정되면 이벤트 큐가 마우스 이벤트 수신을 시작합니다. 마우스 버튼은 &lt;code&gt;pygame.MOUSEBUTTONDOWN&lt;/code&gt; 및 &lt;code&gt;pygame.MOUSEBUTTONUP&lt;/code&gt; 이벤트를 눌렀다 놓으면 생성 됩니다. 이 이벤트에는 어떤 버튼을 눌렀는지 나타내는 버튼 속성이 포함됩니다. 마우스 휠은 &lt;code&gt;pygame.MOUSEBUTTONUP&lt;/code&gt; 때 &lt;code&gt;pygame.MOUSEBUTTONDOWN&lt;/code&gt; 및 pygame.MOUSEBUTTONUP 이벤트를 생성 합니다. 휠이 롤업되면 버튼이 4로 설정되고 휠이 롤 다운되면 버튼 5로 설정됩니다. 마우스를 움직일 때마다 &lt;code&gt;pygame.MOUSEMOTION&lt;/code&gt; 이 생성됩니다.행사. 마우스 움직임은 작고 정확한 모션 이벤트로 나뉩니다. 마우스가 움직이면서 많은 모션 이벤트가 큐에 배치됩니다. 이벤트 큐에서 올바르게 정리되지 않은 마우스 모션 이벤트는 이벤트 큐가 채워지는 주요 이유입니다.</target>
        </trans-unit>
        <trans-unit id="aba60d79ca4c423c83fa6a90777a8e005b6acc04" translate="yes" xml:space="preserve">
          <source>When the keyboard repeat is enabled, keys that are held down will generate multiple &lt;code&gt;pygame.KEYDOWN&lt;/code&gt; events. The delay is the number of milliseconds before the first repeated &lt;code&gt;pygame.KEYDOWN&lt;/code&gt; will be sent. After that another &lt;code&gt;pygame.KEYDOWN&lt;/code&gt; will be sent every interval milliseconds.</source>
          <target state="translated">키보드 반복이 활성화되면 누른 키는 여러 개의 &lt;code&gt;pygame.KEYDOWN&lt;/code&gt; 이벤트를 생성 합니다. 지연 시간은 첫 번째 반복 된 &lt;code&gt;pygame.KEYDOWN&lt;/code&gt; 이 전송 되기 전의 밀리 초 입니다. 그 후 다른 &lt;code&gt;pygame.KEYDOWN&lt;/code&gt; 이 밀리 초마다 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="234974c46b88afc432155e45215ce1246867af1c" translate="yes" xml:space="preserve">
          <source>When the keyboard repeat is enabled, keys that are held down will generate multiple &lt;code&gt;pygame.KEYDOWN&lt;/code&gt; events. The delay is the number of milliseconds before the first repeated &lt;code&gt;pygame.KEYDOWN&lt;/code&gt; will be sent. After that another &lt;code&gt;pygame.KEYDOWN&lt;/code&gt; will be sent every interval milliseconds. If no arguments are passed the key repeat is disabled.</source>
          <target state="translated">키보드 반복이 활성화되면 누른 키는 여러 개의 &lt;code&gt;pygame.KEYDOWN&lt;/code&gt; 이벤트를 생성 합니다. 지연 시간은 첫 번째 반복 된 &lt;code&gt;pygame.KEYDOWN&lt;/code&gt; 이 전송 되기 전의 밀리 초 입니다. 그 후 다른 &lt;code&gt;pygame.KEYDOWN&lt;/code&gt; 이 밀리 초마다 전송됩니다. 인수가 전달되지 않으면 키 반복이 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="9a913036795b62d29ddee6d24a058a0fde62143d" translate="yes" xml:space="preserve">
          <source>When the mouse cursor is visible, it will be displayed as a black and white bitmap using the given bitmask arrays. The size is a sequence containing the cursor width and height. Hotspot is a sequence containing the cursor hotspot position. xormasks is a sequence of bytes containing the cursor xor data masks. Lastly is andmasks, a sequence of bytes containing the cursor bitmask data.</source>
          <target state="translated">마우스 커서가 표시되면 지정된 비트 마스크 배열을 사용하여 흑백 비트 맵으로 표시됩니다. 크기는 커서 너비와 높이를 포함하는 시퀀스입니다. 핫스팟은 커서 핫스팟 위치를 포함하는 시퀀스입니다. xormasks는 커서 xor 데이터 마스크를 포함하는 일련의 바이트입니다. 마지막으로 andmasks는 커서 비트 마스크 데이터를 포함하는 일련의 바이트입니다.</target>
        </trans-unit>
        <trans-unit id="8bb86a1cb2b64afdff340c46264282308b12195a" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;width&lt;/code&gt; values &lt;code&gt;&amp;gt; 1&lt;/code&gt; refer to the &lt;code&gt;width&lt;/code&gt; notes of &lt;a href=&quot;#pygame.draw.line&quot;&gt;&lt;code&gt;line()&lt;/code&gt;&lt;/a&gt; for details on how thick lines grow.</source>
          <target state="translated">&lt;code&gt;width&lt;/code&gt; 값 &lt;code&gt;&amp;gt; 1&lt;/code&gt; 사용할 때 굵은 선이 자라는 방법에 대한 자세한 내용 은 &lt;a href=&quot;#pygame.draw.line&quot;&gt; &lt;code&gt;line()&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;width&lt;/code&gt; 메모를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f00c0c6e3360a6e0cc81ceedd8ac79da8cbfbe56" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;width&lt;/code&gt; values &lt;code&gt;&amp;gt; 1&lt;/code&gt;, lines will grow as follows.</source>
          <target state="translated">&lt;code&gt;width&lt;/code&gt; 값 &lt;code&gt;&amp;gt; 1&lt;/code&gt; 사용하면 선이 다음과 같이 커집니다.</target>
        </trans-unit>
        <trans-unit id="3a9a8b76960c49816895e202d96bfe947ec2000c" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;width&lt;/code&gt; values &lt;code&gt;&amp;gt; 1&lt;/code&gt;, the edge lines will grow outside the original boundary of the polygon. For more details on how the thickness for edge lines grow, refer to the &lt;code&gt;width&lt;/code&gt; notes of the &lt;a href=&quot;#pygame.draw.line&quot;&gt;&lt;code&gt;pygame.draw.line()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">사용시 &lt;code&gt;width&lt;/code&gt; 값 &lt;code&gt;&amp;gt; 1&lt;/code&gt; , 에지 라인은 다각형의 원래 경계 밖에 성장할 것이다. 가장자리 선의 두께가 증가하는 방법에 대한 자세한 내용 은 &lt;a href=&quot;#pygame.draw.line&quot;&gt; &lt;code&gt;pygame.draw.line()&lt;/code&gt; &lt;/a&gt; 함수 의 &lt;code&gt;width&lt;/code&gt; 노트를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c8b4bfd9ca6f5f1926abe6af14111e3f8cd80e36" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;width&lt;/code&gt; values &lt;code&gt;&amp;gt; 1&lt;/code&gt;, the edge lines will grow outside the original boundary of the rect. For more details on how the thickness for edge lines grow, refer to the &lt;code&gt;width&lt;/code&gt; notes of the &lt;a href=&quot;#pygame.draw.line&quot;&gt;&lt;code&gt;pygame.draw.line()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">사용시 &lt;code&gt;width&lt;/code&gt; 값 &lt;code&gt;&amp;gt; 1&lt;/code&gt; , 에지 선은 RECT의 원래 경계 밖에 성장할 것이다. 가장자리 선의 두께가 증가하는 방법에 대한 자세한 내용 은 &lt;a href=&quot;#pygame.draw.line&quot;&gt; &lt;code&gt;pygame.draw.line()&lt;/code&gt; &lt;/a&gt; 함수 의 &lt;code&gt;width&lt;/code&gt; 노트를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="071266a1bae66015cbdb936d5146b33917919984" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;width&lt;/code&gt; values &lt;code&gt;&amp;gt; 1&lt;/code&gt;, the edge lines will only grow inward from the original boundary of the &lt;code&gt;rect&lt;/code&gt; parameter.</source>
          <target state="translated">사용하는 경우 &lt;code&gt;width&lt;/code&gt; 값 &lt;code&gt;&amp;gt; 1&lt;/code&gt; , 엣지 라인 만의 원래 경계로부터 안쪽으로 성장할 것입니다 &lt;code&gt;rect&lt;/code&gt; 매개 변수입니다.</target>
        </trans-unit>
        <trans-unit id="240f19d508be40edc5add13b88eee8c36330e051" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;width&lt;/code&gt; values &lt;code&gt;&amp;gt; 1&lt;/code&gt;, the edge lines will only grow inward.</source>
          <target state="translated">사용하는 경우 &lt;code&gt;width&lt;/code&gt; 값 &lt;code&gt;&amp;gt; 1&lt;/code&gt; , 에지 라인은 안쪽으로 성장할 것입니다.</target>
        </trans-unit>
        <trans-unit id="dfead8dbd2a67a7c0da6a3c3e400e52c8766c198" translate="yes" xml:space="preserve">
          <source>When using allowedchanges=0 it will convert the samples at runtime to match what the hardware supports. For example a sound card may not support 16bit sound samples, so instead it will use 8bit samples internally. If AUDIO_ALLOW_FORMAT_CHANGE is supplied, then the requested format will change to the closest that SDL2 supports.</source>
          <target state="translated">allowedchanges = 0을 사용하면 런타임에 하드웨어가 지원하는 것과 일치하도록 샘플을 변환합니다. 예를 들어 사운드 카드는 16 비트 사운드 샘플을 지원하지 않을 수 있으므로 내부적으로 8 비트 샘플을 사용합니다. AUDIO_ALLOW_FORMAT_CHANGE가 제공되면 요청 된 형식이 SDL2가 지원하는 가장 가까운 형식으로 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="5b6c4a5c6d2983e8787916e7d32f2889fef6e72e" translate="yes" xml:space="preserve">
          <source>When using an &lt;code&gt;pygame.OPENGL&lt;/code&gt; display mode this will perform a gl buffer swap.</source>
          <target state="translated">사용시 &lt;code&gt;pygame.OPENGL&lt;/code&gt; 의 표시 모드를 이것은 GL 완충액 교환을 수행한다.</target>
        </trans-unit>
        <trans-unit id="b36abcc5860b812d617f913d0a2f37ce706f623e" translate="yes" xml:space="preserve">
          <source>When you &lt;code&gt;import pygame&lt;/code&gt; all available pygame submodules are automatically imported. Be aware that some of the pygame modules are considered &lt;em&gt;optional&lt;/em&gt;, and may not be available. In that case, pygame will provide a placeholder object instead of the module, which can be used to test for availability.</source>
          <target state="translated">&lt;code&gt;import pygame&lt;/code&gt; 을 임포트 하면 사용 가능한 모든 파이 게임 서브 모듈이 자동으로 임포트됩니다. 파이 게임 모듈 중 일부는 &lt;em&gt;옵션&lt;/em&gt; 으로 간주 되며 사용하지 못할 수 있습니다. 이 경우 pygame은 모듈 대신 자리 표시 자 객체를 제공하여 가용성을 테스트하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="082ce43a8fe09f171722fdfca1e6e602330f0063" translate="yes" xml:space="preserve">
          <source>When you create Joystick objects using &lt;code&gt;Joystick(id)&lt;/code&gt;, you pass an integer that must be lower than this count.</source>
          <target state="translated">&lt;code&gt;Joystick(id)&lt;/code&gt; 사용하여 Joystick 객체를 만들 때이 개수보다 작아야하는 정수를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="bc73b4b660e66cedc86246bbdec310b682ea9928" translate="yes" xml:space="preserve">
          <source>When your program runs in a windowed environment, it will share the mouse and keyboard devices with other applications that have focus. If your program sets the event grab to &lt;code&gt;True&lt;/code&gt;, it will lock all input into your program.</source>
          <target state="translated">프로그램이 창 환경에서 실행되면 마우스 및 키보드 장치가 포커스가있는 다른 응용 프로그램과 공유됩니다. 프로그램이 이벤트 잡기를 &lt;code&gt;True&lt;/code&gt; 로 설정하면 프로그램에 대한 모든 입력을 잠급니다.</target>
        </trans-unit>
        <trans-unit id="bb56ec6e7d94b80e496bfc16ed378b38c0f90747" translate="yes" xml:space="preserve">
          <source>Whether to enable multisampling anti-aliasing. Defaults to 0 (disabled).</source>
          <target state="translated">멀티 샘플링 앤티 앨리어싱을 사용할지 여부입니다. 기본값은 0 (비활성화)입니다.</target>
        </trans-unit>
        <trans-unit id="74029c1b74694a4b2918df0e69ac58daf4c72c2a" translate="yes" xml:space="preserve">
          <source>While debugging and experimenting, you can print an event object for a quick display of its type and members. The function &lt;a href=&quot;#pygame.event.event_name&quot;&gt;&lt;code&gt;pygame.event.event_name()&lt;/code&gt;&lt;/a&gt; can be used to get a string representing the name of the event type.</source>
          <target state="translated">디버깅 및 실험하는 동안 이벤트 객체를 인쇄하여 해당 유형 및 멤버를 빠르게 표시 할 수 있습니다. &lt;a href=&quot;#pygame.event.event_name&quot;&gt; &lt;code&gt;pygame.event.event_name()&lt;/code&gt; &lt;/a&gt; 함수 는 이벤트 타입의 이름을 나타내는 문자열을 얻는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c48a00bdaf622f5ea82aabcb49baba6e6339d4c8" translate="yes" xml:space="preserve">
          <source>While it is possible to design sprite and group classes that don't derive from the Sprite and AbstractGroup classes below, it is strongly recommended that you extend those when you add a Sprite or Group class.</source>
          <target state="translated">아래 Sprite 및 AbstractGroup 클래스에서 파생되지 않는 스프라이트 및 그룹 클래스를 디자인 할 수 있지만 Sprite 또는 Group 클래스를 추가 할 때 클래스를 확장하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="5452d905e5ef27bc27b029b5e0d8c1398fb1fe26" translate="yes" xml:space="preserve">
          <source>Width must be a multiple of 8, and the mask arrays must be the correct size for the given width and height. Otherwise an exception is raised.</source>
          <target state="translated">너비는 8의 배수 여야하며 마스크 배열은 주어진 너비와 높이에 맞는 크기 여야합니다. 그렇지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b8c2ec8cce6279a6d7c0892bc51dd20a0d9c5713" translate="yes" xml:space="preserve">
          <source>Will pause for a given number of milliseconds. This function sleeps the process to share the processor with other programs. A program that waits for even a few milliseconds will consume very little processor time. It is slightly less accurate than the &lt;code&gt;pygame.time.delay()&lt;/code&gt; function.</source>
          <target state="translated">주어진 밀리 초 동안 일시 중지됩니다. 이 기능은 프로세서를 다른 프로그램과 공유하기 위해 프로세스를 휴면 상태로 만듭니다. 심지어 몇 밀리 초를 기다리는 프로그램은 프로세서 시간을 거의 소비하지 않습니다. &lt;code&gt;pygame.time.delay()&lt;/code&gt; 함수 보다 약간 덜 정확 합니다.</target>
        </trans-unit>
        <trans-unit id="435b52c94e99316b2d3169a20c12e16adb5de54a" translate="yes" xml:space="preserve">
          <source>Will pause for a given number of milliseconds. This function will use the processor (rather than sleeping) in order to make the delay more accurate than &lt;code&gt;pygame.time.wait()&lt;/code&gt;.</source>
          <target state="translated">주어진 밀리 초 동안 일시 중지됩니다. 이 함수는 &lt;code&gt;pygame.time.wait()&lt;/code&gt; 보다 지연을 더 정확하게하기 위해 (잠자기 대신) 프로세서를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="612a9ffde80f8128252602c3dcf63ed5e8e0c954" translate="yes" xml:space="preserve">
          <source>With the use of a virtual midi patch cord the output and input examples can be run as separate processes and connected so the keyboard output is displayed on a console.</source>
          <target state="translated">가상 미디 패치 코드를 사용하면 출력 및 입력 예제를 별도의 프로세스로 실행하고 연결할 수 있으므로 키보드 출력이 콘솔에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="758830ba85e49689fd1a0fd534f71e95b3206c17" translate="yes" xml:space="preserve">
          <source>Write raw bytes to object buffer.</source>
          <target state="translated">원시 바이트를 객체 버퍼에 씁니다.</target>
        </trans-unit>
        <trans-unit id="eede40789a892dd168e96c5e08614a5a969dfa8e" translate="yes" xml:space="preserve">
          <source>Writes a timestamped system-exclusive midi message.</source>
          <target state="translated">타임 스탬프 된 시스템 전용 미디 메시지를 씁니다.</target>
        </trans-unit>
        <trans-unit id="f30c4dfea3f142345477a615d574110526940848" translate="yes" xml:space="preserve">
          <source>Writes series of MIDI information in the form of a list.</source>
          <target state="translated">일련의 MIDI 정보를 목록 형식으로 씁니다.</target>
        </trans-unit>
        <trans-unit id="c31caf9bb4310a803402fc149323cfb0a190a2fc" translate="yes" xml:space="preserve">
          <source>You can also run the examples in the python interpreter by calling each modules main() function.</source>
          <target state="translated">각 모듈 main () 함수를 호출하여 Python 인터프리터에서 예제를 실행할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7daba2756b35a1c4beb9a540b88f06f2a1134c3e" translate="yes" xml:space="preserve">
          <source>You can call the &lt;code&gt;Joystick.get_name()&lt;/code&gt; and &lt;code&gt;Joystick.get_id()&lt;/code&gt; functions without initializing the Joystick object.</source>
          <target state="translated">Joystick 객체를 초기화하지 않고도 &lt;code&gt;Joystick.get_name()&lt;/code&gt; 및 &lt;code&gt;Joystick.get_id()&lt;/code&gt; 함수를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a6dea066107a5bf8841eb28c4490e391763db599" translate="yes" xml:space="preserve">
          <source>You can create a &lt;code&gt;CD&lt;/code&gt; object for each cdrom on the system. Use &lt;code&gt;pygame.cdrom.get_count()&lt;/code&gt; to determine how many drives actually exist. The id argument is an integer of the drive, starting at zero.</source>
          <target state="translated">시스템의 각 CDROM에 대해 &lt;code&gt;CD&lt;/code&gt; 오브젝트를 작성할 수 있습니다 . &lt;code&gt;pygame.cdrom.get_count()&lt;/code&gt; 를 사용 하여 실제로 존재하는 드라이브 수를 결정 하십시오 . id 인수는 0부터 시작하는 드라이브의 정수입니다.</target>
        </trans-unit>
        <trans-unit id="195567619ff480ed28b3e00d87bd0f426a60edb0" translate="yes" xml:space="preserve">
          <source>You can find where the example files are installed by using the following commands inside the python interpreter.</source>
          <target state="translated">파이썬 인터프리터 내부에서 다음 명령을 사용하여 예제 파일이 설치된 위치를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54ce7806be52df2093d3a5a2e8b2a066dbd0c68c" translate="yes" xml:space="preserve">
          <source>You can load fonts from the system by using the &lt;code&gt;pygame.font.SysFont()&lt;/code&gt; function. There are a few other functions to help lookup the system fonts.</source>
          <target state="translated">&lt;code&gt;pygame.font.SysFont()&lt;/code&gt; 함수를 사용하여 시스템에서 글꼴을로드 할 수 있습니다 . 시스템 글꼴을 찾는 데 도움이되는 몇 가지 다른 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="492f06dd02d66d0863c6d0c18b975c51913ade68" translate="yes" xml:space="preserve">
          <source>You can pass any surface, but most systems want a smaller image around 32x32. The image can have colorkey transparency which will be passed to the system.</source>
          <target state="translated">어떤 표면이든 통과 할 수 있지만 대부분의 시스템은 32x32 정도의 작은 이미지를 원합니다. 이미지는 시스템에 전달되는 색상 키 투명도를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2312b41265ffe65573d13e6929ba12cfa4c4bedd" translate="yes" xml:space="preserve">
          <source>You can pass keyword argument values to this function. These named values will be applied to the attributes of the Rect before it is returned. An example would be &lt;code&gt;mysurf.get_rect(center=(100, 100))&lt;/code&gt; to create a rectangle for the Surface centered at a given position.</source>
          <target state="translated">키워드 인수 값을이 함수에 전달할 수 있습니다. 이러한 명명 된 값은 반환되기 전에 Rect의 속성에 적용됩니다. 예를 들어 &lt;code&gt;mysurf.get_rect(center=(100, 100))&lt;/code&gt; 은 주어진 위치를 중심으로하는 Surface의 사각형을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="f4ba405ae05d32b893ab0bfc3795f06f95cdb168" translate="yes" xml:space="preserve">
          <source>You can pass the background too. If a background is already set, then the bgd argument has no effect.</source>
          <target state="translated">당신도 배경을 전달할 수 있습니다. 배경이 이미 설정되어 있으면 bgd 인수가 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="08568134400815390dc06703ce5cbeb5539e8253" translate="yes" xml:space="preserve">
          <source>You can pass the function a single rectangle, or a sequence of rectangles. It is more efficient to pass many rectangles at once than to call update multiple times with single or a partial list of rectangles. If passing a sequence of rectangles it is safe to include None values in the list, which will be skipped.</source>
          <target state="translated">단일 사각형 또는 일련의 사각형에 함수를 전달할 수 있습니다. 단일 또는 부분 사각형 목록으로 여러 번 업데이트를 호출하는 것보다 많은 사각형을 한 번에 전달하는 것이 더 효율적입니다. 일련의 사각형을 전달하면 목록에 없음 값을 포함시키는 것이 안전합니다.이 값은 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="be5f6a34c1cfd58af567ec8b2e327f25417d0544" translate="yes" xml:space="preserve">
          <source>You can set the default layer through kwargs using 'default_layer' and an integer for the layer. The default layer is 0.</source>
          <target state="translated">'default_layer'와 레이어의 정수를 사용하여 kwargs를 통해 기본 레이어를 설정할 수 있습니다. 기본 레이어는 0입니다.</target>
        </trans-unit>
        <trans-unit id="d09dcd55769641dc5772bcdc60c6a6ce0dc430fb" translate="yes" xml:space="preserve">
          <source>You may want to initialize the different modules separately to speed up your program or to not use modules your game does not require.</source>
          <target state="translated">프로그램 속도를 높이거나 게임에 필요하지 않은 모듈을 사용하지 않으려면 다른 모듈을 별도로 초기화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f01fba577edd634e491fea58f6581fccdb5eba50" translate="yes" xml:space="preserve">
          <source>You should consider creating a mask for your sprite at load time if you are going to check collisions many times. This will increase the performance, otherwise this can be an expensive function because it will create the masks each time you check for collisions.</source>
          <target state="translated">충돌을 여러 번 확인하려는 경우로드시 스프라이트 마스크를 만드는 것을 고려해야합니다. 이렇게하면 성능이 향상됩니다. 그렇지 않으면 충돌을 확인할 때마다 마스크가 생성되므로 값 비싼 기능이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04682854a0f672e3eb5f6eee5626ac4f8183a2a2" translate="yes" xml:space="preserve">
          <source>You should use &lt;code&gt;os.path.join()&lt;/code&gt; for compatibility.</source>
          <target state="translated">호환성을 위해 &lt;code&gt;os.path.join()&lt;/code&gt; 을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4d7663637c72179cdbf49a644d9c9282957652c7" translate="yes" xml:space="preserve">
          <source>_sdl2.touch</source>
          <target state="translated">_sdl2.touch</target>
        </trans-unit>
        <trans-unit id="b34cd2076c7f2e690352696dcb011ee06ac78653" translate="yes" xml:space="preserve">
          <source>_sdl2.touch.get_device()</source>
          <target state="translated">_sdl2.touch.get_device()</target>
        </trans-unit>
        <trans-unit id="aed7922f8ae1e7897115e8b49f4fd841db89da4a" translate="yes" xml:space="preserve">
          <source>_sdl2.touch.get_finger()</source>
          <target state="translated">_sdl2.touch.get_finger()</target>
        </trans-unit>
        <trans-unit id="9ab0344844e35a9678b0486c8414fbca6f4db2ff" translate="yes" xml:space="preserve">
          <source>_sdl2.touch.get_num_devices()</source>
          <target state="translated">_sdl2.touch.get_num_devices()</target>
        </trans-unit>
        <trans-unit id="3f016052e246606d37c1415d234bb0ed3a02e5ab" translate="yes" xml:space="preserve">
          <source>_sdl2.touch.get_num_fingers()</source>
          <target state="translated">_sdl2.touch.get_num_fingers()</target>
        </trans-unit>
        <trans-unit id="045b09fe2605a2a0871c0a29b99e16232f5066b9" translate="yes" xml:space="preserve">
          <source>a 2-Dimensional Vector</source>
          <target state="translated">2 차원 벡터</target>
        </trans-unit>
        <trans-unit id="c29f71825c72ca571fcd530f88649ddb3a87290d" translate="yes" xml:space="preserve">
          <source>a 3-Dimensional Vector</source>
          <target state="translated">3 차원 벡터</target>
        </trans-unit>
        <trans-unit id="509c83e0199c17d0afe133aceb780b2e45941a8b" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;#pygame.mask.Mask&quot;&gt;&lt;code&gt;Mask&lt;/code&gt;&lt;/a&gt; object (same size as this mask) with the largest connected component from this mask, if this mask has no bits set then an empty mask will be returned</source>
          <target state="translated">&lt;a href=&quot;#pygame.mask.Mask&quot;&gt; &lt;code&gt;Mask&lt;/code&gt; &lt;/a&gt; 이 마스크를 설정 한 다음 어떤 비트가없는 경우,이 오브젝트로부터 마스크 최대 연결된 구성 요소 (이 마스크와 동일 사이즈), 빈 마스크 반환 될</target>
        </trans-unit>
        <trans-unit id="cd4b2d5a8ca7b75aa50b3b13f35d8f0bc99157f8" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;#pygame.mask.Mask&quot;&gt;&lt;code&gt;Mask&lt;/code&gt;&lt;/a&gt; with the &lt;code&gt;(i - offset[0], j - offset[1])&lt;/code&gt; bit set, if shifting &lt;code&gt;othermask&lt;/code&gt; (such that its bottom right corner is at &lt;code&gt;(i, j)&lt;/code&gt;) causes it to overlap with this mask</source>
          <target state="translated">다른 &lt;a href=&quot;#pygame.mask.Mask&quot;&gt; &lt;code&gt;Mask&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;othermask&lt;/code&gt; (오른쪽 하단 모서리가 &lt;code&gt;(i, j)&lt;/code&gt; )이 마스크와 겹치는 경우 &lt;code&gt;(i - offset[0], j - offset[1])&lt;/code&gt; 비트가 설정된 마스크</target>
        </trans-unit>
        <trans-unit id="4195ec516035c31073bcfb49d9725b5606a6a789" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;color#pygame.Color&quot;&gt;&lt;code&gt;pygame.Color&lt;/code&gt;&lt;/a&gt; object</source>
          <target state="translated">&lt;a href=&quot;color#pygame.Color&quot;&gt; &lt;code&gt;pygame.Color&lt;/code&gt; 의&lt;/a&gt; 객체</target>
        </trans-unit>
        <trans-unit id="9a6e7034b36cf49ad20d5937b713a5f32f8b0a18" translate="yes" xml:space="preserve">
          <source>a coordinate tuple indicating the centroid of the mask, it will return &lt;code&gt;(0, 0)&lt;/code&gt; if the mask has no bits set</source>
          <target state="translated">마스크의 중심을 나타내는 좌표 튜플 . 마스크에 비트가 설정되어 있지 않은 경우는 &lt;code&gt;(0, 0)&lt;/code&gt; 돌려줍니다</target>
        </trans-unit>
        <trans-unit id="c05460d0bf0be0cbd94b448a6237073996277073" translate="yes" xml:space="preserve">
          <source>a list containing a &lt;a href=&quot;#pygame.mask.Mask&quot;&gt;&lt;code&gt;Mask&lt;/code&gt;&lt;/a&gt; object for each connected component, an empty list is returned if the mask has no bits set</source>
          <target state="translated">연결된 각 구성 요소에 대한 &lt;a href=&quot;#pygame.mask.Mask&quot;&gt; &lt;code&gt;Mask&lt;/code&gt; &lt;/a&gt; 객체를 포함하는 목록. 마스크에 비트가 설정되어 있지 않으면 빈 목록이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ed75cb4c95f649365b2b6609456560764c2d59f4" translate="yes" xml:space="preserve">
          <source>a list containing a bounding rect for each connected component, an empty list is returned if the mask has no bits set</source>
          <target state="translated">연결된 각 구성 요소에 대한 경계 사각형을 포함하는 목록. 마스크에 비트가 설정되어 있지 않으면 빈 목록이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="af6d7c4c532a769079fd92e4d7ff6b31d6eeb560" translate="yes" xml:space="preserve">
          <source>a list of points outlining the first connected component encountered, an empty list is returned if the mask has no bits set</source>
          <target state="translated">첫 번째로 연결된 컴포넌트를 나타내는 포인트 목록. 마스크에 비트가 설정되어 있지 않으면 빈 목록이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="458a5f528cd11e2da7ae1e4cd59f903e7f61852b" translate="yes" xml:space="preserve">
          <source>a list of rects of the areas changed if &lt;code&gt;doreturn&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, otherwise &lt;code&gt;None&lt;/code&gt;</source>
          <target state="translated">경우 지역의 구형의 목록이 변경 &lt;code&gt;doreturn&lt;/code&gt; 이 없는 &lt;code&gt;True&lt;/code&gt; , 그렇지 않으면 &lt;code&gt;None&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c988e1d030d8972ec73f8013772e377e7ad7f172" translate="yes" xml:space="preserve">
          <source>a new &lt;a href=&quot;#pygame.mask.Mask&quot;&gt;&lt;code&gt;Mask&lt;/code&gt;&lt;/a&gt; object with its bits scaled from this mask</source>
          <target state="translated">이 마스크로부터 스케일 된 비트를 가지는 새로운 &lt;a href=&quot;#pygame.mask.Mask&quot;&gt; &lt;code&gt;Mask&lt;/code&gt; &lt;/a&gt; 객체</target>
        </trans-unit>
        <trans-unit id="466e08585cd68c7593c0bcc8133fff991e449acc" translate="yes" xml:space="preserve">
          <source>a new &lt;a href=&quot;rect#pygame.Rect&quot;&gt;&lt;code&gt;pygame.Rect()&lt;/code&gt;&lt;/a&gt; object based on the size of this mask with any &lt;a href=&quot;rect#pygame.Rect&quot;&gt;&lt;code&gt;pygame.Rect()&lt;/code&gt;&lt;/a&gt; attribute keyword arguments/values applied to it</source>
          <target state="translated">&lt;a href=&quot;rect#pygame.Rect&quot;&gt; &lt;code&gt;pygame.Rect()&lt;/code&gt; &lt;/a&gt; 속성 키워드 인수 / 값이 적용된 이 마스크의 크기에 기반한 새로운 &lt;a href=&quot;rect#pygame.Rect&quot;&gt; &lt;code&gt;pygame.Rect()&lt;/code&gt; &lt;/a&gt; 객체</target>
        </trans-unit>
        <trans-unit id="b83cd9240180b28546f32be8debdf2328cf6a1a6" translate="yes" xml:space="preserve">
          <source>a new copy of this mask, the new mask will have the same width, height, and set/unset bits as the original</source>
          <target state="translated">이 마스크의 새로운 복사본, 새로운 마스크는 원본과 동일한 너비, 높이 및 설정 / 설정 해제 비트를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="c04f012b381215ce8c69648168791969880780a9" translate="yes" xml:space="preserve">
          <source>a newly created &lt;a href=&quot;#pygame.Color&quot;&gt;&lt;code&gt;Color&lt;/code&gt;&lt;/a&gt; object</source>
          <target state="translated">새롭게 작성된 &lt;a href=&quot;#pygame.Color&quot;&gt; &lt;code&gt;Color&lt;/code&gt; &lt;/a&gt; 객체</target>
        </trans-unit>
        <trans-unit id="992f6e67d43d7e9b1f349ce6dfa96780bc4924e4" translate="yes" xml:space="preserve">
          <source>a newly created &lt;a href=&quot;#pygame.mask.Mask&quot;&gt;&lt;code&gt;Mask&lt;/code&gt;&lt;/a&gt; object</source>
          <target state="translated">새롭게 작성된 &lt;a href=&quot;#pygame.mask.Mask&quot;&gt; &lt;code&gt;Mask&lt;/code&gt; &lt;/a&gt; 객체</target>
        </trans-unit>
        <trans-unit id="caae2c627f2eedb9c7d1284225235819ac19db57" translate="yes" xml:space="preserve">
          <source>a newly created &lt;a href=&quot;#pygame.mask.Mask&quot;&gt;&lt;code&gt;Mask&lt;/code&gt;&lt;/a&gt; object from the given surface</source>
          <target state="translated">지정된 표면으로부터 새롭게 작성된 &lt;a href=&quot;#pygame.mask.Mask&quot;&gt; &lt;code&gt;Mask&lt;/code&gt; &lt;/a&gt; 객체</target>
        </trans-unit>
        <trans-unit id="d3a80d2b12717e2bf127959d48d9bd6f62023e03" translate="yes" xml:space="preserve">
          <source>a newly created &lt;a href=&quot;#pygame.mask.Mask&quot;&gt;&lt;code&gt;Mask&lt;/code&gt;&lt;/a&gt; with the overlapping bits set</source>
          <target state="translated">겹치는 비트 세트 로 새롭게 작성된 &lt;a href=&quot;#pygame.mask.Mask&quot;&gt; &lt;code&gt;Mask&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1986681024db3f8c5ae8af77370ef77e1ec0fda5" translate="yes" xml:space="preserve">
          <source>a rect bounding the changed pixels, if nothing is drawn the bounding rect's position will be the &lt;code&gt;center&lt;/code&gt; parameter value (float values will be truncated) and its width and height will be 0</source>
          <target state="translated">변경된 픽셀의 경계의 경계. 아무것도 그려지지 않은 경우 경계의 위치는 &lt;code&gt;center&lt;/code&gt; 파라미터 값이되고 (부동 값은 절단됩니다) 폭과 높이는 0이됩니다</target>
        </trans-unit>
        <trans-unit id="154c9163ee2d4ad126198e0c393d2cd40d9f5bce" translate="yes" xml:space="preserve">
          <source>a rect bounding the changed pixels, if nothing is drawn the bounding rect's position will be the &lt;code&gt;start_pos&lt;/code&gt; parameter value (float values will be truncated) and its width and height will be 0</source>
          <target state="translated">변경된 픽셀의 경계의 경계. 아무것도 그려지지 않은 경우 경계의 위치는 &lt;code&gt;start_pos&lt;/code&gt; 파라미터 치 (float 치는 잘립니다)가되고, 폭과 높이는 0이됩니다</target>
        </trans-unit>
        <trans-unit id="a9fdbd3a19b74742b2a30280c2360dc5a795c286" translate="yes" xml:space="preserve">
          <source>a rect bounding the changed pixels, if nothing is drawn the bounding rect's position will be the position of the first point in the &lt;code&gt;points&lt;/code&gt; parameter (float values will be truncated) and its width and height will be 0</source>
          <target state="translated">변경된 픽셀의 경계의 경계. 아무것도 그려지지 않은 경우 경계의 직위 위치는 &lt;code&gt;points&lt;/code&gt; 파라미터 내의 최초의 포인트의 위치가됩니다 (float 치는 잘립니다). 폭과 높이는 0이됩니다</target>
        </trans-unit>
        <trans-unit id="715b2fd3e786fa94bebaa61f16e214ef9d196e58" translate="yes" xml:space="preserve">
          <source>a rect bounding the changed pixels, if nothing is drawn the bounding rect's position will be the position of the given &lt;code&gt;rect&lt;/code&gt; parameter and its width and height will be 0</source>
          <target state="translated">변경된 픽셀의 경계의 경계. 아무것도 그려지지 않은 경우 경계 의 직각 위치는 지정된 &lt;code&gt;rect&lt;/code&gt; 파라미터 의 위치가 되고 폭과 높이는 0이됩니다</target>
        </trans-unit>
        <trans-unit id="b097cdad2bb22993f3ac79870727f68826f1be17" translate="yes" xml:space="preserve">
          <source>access the clipboard</source>
          <target state="translated">클립 보드에 액세스</target>
        </trans-unit>
        <trans-unit id="095f1b5bca3d55d0798fbe86e9f4d7e6e206548c" translate="yes" xml:space="preserve">
          <source>acquires a buffer object for the pixels of the Surface.</source>
          <target state="translated">Surface의 픽셀에 대한 버퍼 객체를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="d9682917c91073336dce8aa0b8ba927964283b07" translate="yes" xml:space="preserve">
          <source>actual time used in the previous tick</source>
          <target state="translated">이전 진드기에 사용 된 실제 시간</target>
        </trans-unit>
        <trans-unit id="4a27e8dd1b66774937b57f0e28fc9360f041c2e3" translate="yes" xml:space="preserve">
          <source>add Sprites to this Group</source>
          <target state="translated">이 그룹에 스프라이트 추가</target>
        </trans-unit>
        <trans-unit id="f496a4c3518abea1ee62ed488f38829dd488ca2b" translate="yes" xml:space="preserve">
          <source>add a sprite or sequence of sprites to a group</source>
          <target state="translated">스프라이트 또는 스프라이트 시퀀스를 그룹에 추가</target>
        </trans-unit>
        <trans-unit id="0b8f684c0111b63113da4f6b438ed98b32d51f08" translate="yes" xml:space="preserve">
          <source>add the sprite to groups</source>
          <target state="translated">스프라이트를 그룹에 추가</target>
        </trans-unit>
        <trans-unit id="a80218305609331ae67652e676ed365c9f3b0031" translate="yes" xml:space="preserve">
          <source>allow the use of embedded bitmaps in an outline font file</source>
          <target state="translated">개요 글꼴 파일에 포함 된 비트 맵 사용 허용</target>
        </trans-unit>
        <trans-unit id="7193cac64d5d136d6ee717382c201a9284ec3f78" translate="yes" xml:space="preserve">
          <source>an &lt;code&gt;(RGB)&lt;/code&gt; triplet (tuple/list)</source>
          <target state="translated">&lt;code&gt;(RGB)&lt;/code&gt; 트리플렛 (튜플 /리스트)</target>
        </trans-unit>
        <trans-unit id="f27de829d82be70d81cabe8e1833cef80b653221" translate="yes" xml:space="preserve">
          <source>an &lt;code&gt;(RGBA)&lt;/code&gt; quadruplet (tuple/list)</source>
          <target state="translated">&lt;code&gt;(RGBA)&lt;/code&gt; 네개 (튜플 /리스트)</target>
        </trans-unit>
        <trans-unit id="d2e9d8d1e621806825775f51d33dafb004726d32" translate="yes" xml:space="preserve">
          <source>an integer value that has been mapped to the surface's pixel format (see &lt;a href=&quot;surface#pygame.Surface.map_rgb&quot;&gt;&lt;code&gt;pygame.Surface.map_rgb()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;surface#pygame.Surface.unmap_rgb&quot;&gt;&lt;code&gt;pygame.Surface.unmap_rgb()&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">표면의 픽셀 형식에 매핑 된 정수 값 ( &lt;a href=&quot;surface#pygame.Surface.map_rgb&quot;&gt; &lt;code&gt;pygame.Surface.map_rgb()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;surface#pygame.Surface.unmap_rgb&quot;&gt; &lt;code&gt;pygame.Surface.unmap_rgb()&lt;/code&gt; &lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="1c86b92870adce9cd4a78718538e907a5bfc8dbd" translate="yes" xml:space="preserve">
          <source>arguments:</source>
          <target state="translated">arguments:</target>
        </trans-unit>
        <trans-unit id="c135242ef015efaf95cb82996eb9653da1955e61" translate="yes" xml:space="preserve">
          <source>array struct interface</source>
          <target state="translated">배열 구조체 인터페이스</target>
        </trans-unit>
        <trans-unit id="7b954c77fa80e517fd882da84311de6007f3ae80" translate="yes" xml:space="preserve">
          <source>begin sound playback</source>
          <target state="translated">소리 재생 시작</target>
        </trans-unit>
        <trans-unit id="d79c632ce0c8f5def07536708f4073478a72e2d5" translate="yes" xml:space="preserve">
          <source>being able to use PixelArray as a context manager for cleanup.</source>
          <target state="translated">정리를 위해 컨텍스트 관리자로 PixelArray를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5562b65e03f29a1203bd0a4c8ee66f7a3a4ccca" translate="yes" xml:space="preserve">
          <source>blendmode = 0</source>
          <target state="translated">블렌드 모드 = 0</target>
        </trans-unit>
        <trans-unit id="fffd8ce65a2da27bc0496d71715928fdbded725a" translate="yes" xml:space="preserve">
          <source>blit the Sprite images</source>
          <target state="translated">스프라이트 이미지를 블리트</target>
        </trans-unit>
        <trans-unit id="f50a65a36bbef1de2e1c2815d0c8735a9b89b5b4" translate="yes" xml:space="preserve">
          <source>blit the Sprite images and track changed areas</source>
          <target state="translated">Sprite 이미지를 블리 팅하고 변경된 영역을 추적</target>
        </trans-unit>
        <trans-unit id="5039d155a71c0a5f7a2b2654ad49cb7ee47a8980" translate="yes" xml:space="preserve">
          <source>bool</source>
          <target state="translated">bool</target>
        </trans-unit>
        <trans-unit id="832b704698f3f315f291018c644150f02dedfff8" translate="yes" xml:space="preserve">
          <source>both of these are useful for when working without reference counting (pypy).</source>
          <target state="translated">이 두 가지 모두 참조 횟수 (pypy)없이 작업 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="f1ecd344be980bd88c6d4a3d876d7ef102af411d" translate="yes" xml:space="preserve">
          <source>brings the sprite to front layer</source>
          <target state="translated">스프라이트를 프론트 레이어로 가져옵니다</target>
        </trans-unit>
        <trans-unit id="c784c00eb02ce67f0e2b98ae91aafa680bddfb82" translate="yes" xml:space="preserve">
          <source>broadcasting for a length 1 dimension</source>
          <target state="translated">길이 1 차원 방송</target>
        </trans-unit>
        <trans-unit id="e53c2ea1fe4bd2b78bf4723c7c155a578e020a25" translate="yes" xml:space="preserve">
          <source>buffer</source>
          <target state="translated">buffer</target>
        </trans-unit>
        <trans-unit id="6c235ac5c96d55ebbce4dc279e5d72bbb171447c" translate="yes" xml:space="preserve">
          <source>bytes or str or None</source>
          <target state="translated">바이트 또는 str 또는 없음</target>
        </trans-unit>
        <trans-unit id="d0d739fb0b484f71bd13f769059e51b61d3650c3" translate="yes" xml:space="preserve">
          <source>calculates the Euclidean distance to a given vector.</source>
          <target state="translated">주어진 벡터까지의 유클리드 거리를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="0e78cc540258e3a48e66a92890563ac47a1f54bf" translate="yes" xml:space="preserve">
          <source>calculates the Euclidean length of the vector which follows from the Pythagorean theorem: &lt;code&gt;vec.length()&lt;/code&gt; == &lt;code&gt;math.sqrt(vec.x**2 + vec.y**2 + vec.z**2)&lt;/code&gt;</source>
          <target state="translated">피타고라스 정리에서 나오는 벡터의 유클리드 길이를 계산합니다. &lt;code&gt;vec.length()&lt;/code&gt; == &lt;code&gt;math.sqrt(vec.x**2 + vec.y**2 + vec.z**2)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1188f9ff4591f4529cefa224b248c2b49d1ed8d9" translate="yes" xml:space="preserve">
          <source>calculates the Euclidean length of the vector which follows from the Pythagorean theorem: &lt;code&gt;vec.length()&lt;/code&gt; == &lt;code&gt;math.sqrt(vec.x**2 + vec.y**2)&lt;/code&gt;</source>
          <target state="translated">피타고라스 정리에서 나오는 벡터의 유클리드 길이를 계산합니다. &lt;code&gt;vec.length()&lt;/code&gt; == &lt;code&gt;math.sqrt(vec.x**2 + vec.y**2)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a7b5a7d387fd99c00f13acd0adc3c12ef34ba301" translate="yes" xml:space="preserve">
          <source>calculates the Euclidean length of the vector which follows from the Pythagorean theorem: &lt;code&gt;vec.length_squared()&lt;/code&gt; == vec.x**2 + vec.y**2 + vec.z**2 This is faster than &lt;code&gt;vec.length()&lt;/code&gt; because it avoids the square root.</source>
          <target state="translated">피타고라스 정리에 따르는 벡터의 유클리드 길이를 계산합니다. &lt;code&gt;vec.length_squared()&lt;/code&gt; == vec.x ** 2 + vec.y ** 2 + vec.z ** 2 이것은 &lt;code&gt;vec.length()&lt;/code&gt; 보다 빠릅니다. 그것은 제곱근을 피하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="ffc86c72a7d130bce76bccf6f6d9c8bd45860c54" translate="yes" xml:space="preserve">
          <source>calculates the Euclidean length of the vector which follows from the Pythagorean theorem: &lt;code&gt;vec.length_squared()&lt;/code&gt; == vec.x**2 + vec.y**2 This is faster than &lt;code&gt;vec.length()&lt;/code&gt; because it avoids the square root.</source>
          <target state="translated">피타고라스 정리를 따르는 벡터의 유클리드 길이를 계산합니다. &lt;code&gt;vec.length_squared()&lt;/code&gt; == vec.x ** 2 + vec.y ** 2 이것은 제곱근을 피하기 때문에 &lt;code&gt;vec.length()&lt;/code&gt; 보다 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="003ca99998e19c2b025bdf03d509a53cf5ced4dc" translate="yes" xml:space="preserve">
          <source>calculates the angle to a given vector in degrees.</source>
          <target state="translated">주어진 벡터에 대한 각도를도 단위로 계산합니다.</target>
        </trans-unit>
        <trans-unit id="8519e80f42547bd46623688b644be9770a678765" translate="yes" xml:space="preserve">
          <source>calculates the cross- or vector-product</source>
          <target state="translated">교차 또는 벡터 곱을 계산합니다</target>
        </trans-unit>
        <trans-unit id="1916fb2437e8c2a67eb2feb9808b5a54994a5a5e" translate="yes" xml:space="preserve">
          <source>calculates the cross-product.</source>
          <target state="translated">교차 곱을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="23fc600e790cb9495f3b43fbbdd5de532aa467db" translate="yes" xml:space="preserve">
          <source>calculates the dot- or scalar-product with the other vector</source>
          <target state="translated">다른 벡터로 점 또는 스칼라 곱을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="8eced427b65b937e6fc252328044a3986a45cbc0" translate="yes" xml:space="preserve">
          <source>calculates the magnitude of the vector which follows from the theorem: &lt;code&gt;vec.magnitude()&lt;/code&gt; == &lt;code&gt;math.sqrt(vec.x**2 + vec.y**2 + vec.z**2)&lt;/code&gt;</source>
          <target state="translated">정리에서 나오는 벡터의 크기를 계산합니다. &lt;code&gt;vec.magnitude()&lt;/code&gt; == &lt;code&gt;math.sqrt(vec.x**2 + vec.y**2 + vec.z**2)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c382ad6bd9bc584f129dda4d6629ef37e612f60f" translate="yes" xml:space="preserve">
          <source>calculates the magnitude of the vector which follows from the theorem: &lt;code&gt;vec.magnitude()&lt;/code&gt; == &lt;code&gt;math.sqrt(vec.x**2 + vec.y**2)&lt;/code&gt;</source>
          <target state="translated">정리에서 나오는 벡터의 크기를 계산합니다. &lt;code&gt;vec.magnitude()&lt;/code&gt; == &lt;code&gt;math.sqrt(vec.x**2 + vec.y**2)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c169ff444c6e05a5baf8dc33bd6986bcc5bf00a9" translate="yes" xml:space="preserve">
          <source>calculates the magnitude of the vector which follows from the theorem: &lt;code&gt;vec.magnitude_squared()&lt;/code&gt; == vec.x**2 + vec.y**2 + vec.z**2 This is faster than &lt;code&gt;vec.magnitude()&lt;/code&gt; because it avoids the square root.</source>
          <target state="translated">정리에서 다음 벡터의 크기를 계산한다 &lt;code&gt;vec.magnitude_squared()&lt;/code&gt; == vec.x ** ** vec.y 2 + 2 + 2 vec.z **이 빠르고보다 &lt;code&gt;vec.magnitude()&lt;/code&gt; 그 때문에 제곱근을 피합니다.</target>
        </trans-unit>
        <trans-unit id="d6d084610c422c86cd25fc622759576fd2f636f1" translate="yes" xml:space="preserve">
          <source>calculates the magnitude of the vector which follows from the theorem: &lt;code&gt;vec.magnitude_squared()&lt;/code&gt; == vec.x**2 + vec.y**2 This is faster than &lt;code&gt;vec.magnitude()&lt;/code&gt; because it avoids the square root.</source>
          <target state="translated">정리에서 오는 벡터의 크기를 계산합니다. &lt;code&gt;vec.magnitude_squared()&lt;/code&gt; == vec.x ** 2 + vec.y ** 2 이것은 제곱근을 피하기 때문에 &lt;code&gt;vec.magnitude()&lt;/code&gt; 보다 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="51515aeef095c353e09d7b97d43dfcfbfd4938ee" translate="yes" xml:space="preserve">
          <source>calculates the squared Euclidean distance to a given vector.</source>
          <target state="translated">주어진 벡터까지의 제곱 유클리드 거리를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="a45e0c8207b480b706f1eef93aed018730a41551" translate="yes" xml:space="preserve">
          <source>calculates the third component of the cross-product.</source>
          <target state="translated">교차 곱의 세 번째 구성 요소를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="d153c9964309047804658cbd5d054566c373f95e" translate="yes" xml:space="preserve">
          <source>call the update method on contained Sprites</source>
          <target state="translated">포함 된 Sprite에서 update 메소드 호출</target>
        </trans-unit>
        <trans-unit id="251e382f763507ea6307d25d17991870392a43c4" translate="yes" xml:space="preserve">
          <source>camera</source>
          <target state="translated">camera</target>
        </trans-unit>
        <trans-unit id="b9f650f8d62a27f4fc7eedf200b04022d9f7093e" translate="yes" xml:space="preserve">
          <source>camera.Camera</source>
          <target state="translated">camera.Camera</target>
        </trans-unit>
        <trans-unit id="1a8831346478727e3209ec0f04cf9506908e1519" translate="yes" xml:space="preserve">
          <source>camera.Camera.get_controls()</source>
          <target state="translated">camera.Camera.get_controls()</target>
        </trans-unit>
        <trans-unit id="7c1395080ca30e4dc51acbb311b7c1fdde326508" translate="yes" xml:space="preserve">
          <source>camera.Camera.get_image()</source>
          <target state="translated">camera.Camera.get_image()</target>
        </trans-unit>
        <trans-unit id="fc2de6ff9ad8eac09b6ac6fd38a0b089352e3eb7" translate="yes" xml:space="preserve">
          <source>camera.Camera.get_raw()</source>
          <target state="translated">camera.Camera.get_raw()</target>
        </trans-unit>
        <trans-unit id="1d8c02525fec9d56e278dcfb1c73fea42af21c07" translate="yes" xml:space="preserve">
          <source>camera.Camera.get_size()</source>
          <target state="translated">camera.Camera.get_size()</target>
        </trans-unit>
        <trans-unit id="56ea797ec3e932aab347d361c800b0f2d9cc030d" translate="yes" xml:space="preserve">
          <source>camera.Camera.query_image()</source>
          <target state="translated">camera.Camera.query_image()</target>
        </trans-unit>
        <trans-unit id="5bdc5dbdbaf70c2a477dc84a590e9006c9303e04" translate="yes" xml:space="preserve">
          <source>camera.Camera.set_controls()</source>
          <target state="translated">camera.Camera.set_controls()</target>
        </trans-unit>
        <trans-unit id="5da2e87bae0f6640465c76a8caa8206f4e8e46b4" translate="yes" xml:space="preserve">
          <source>camera.Camera.start()</source>
          <target state="translated">camera.Camera.start()</target>
        </trans-unit>
        <trans-unit id="739d3f6fe899961af28647e0dd76762e5cc8230d" translate="yes" xml:space="preserve">
          <source>camera.Camera.stop()</source>
          <target state="translated">camera.Camera.stop()</target>
        </trans-unit>
        <trans-unit id="208bba6196d02287e7bba2e85317dfdcce44645f" translate="yes" xml:space="preserve">
          <source>camera.colorspace()</source>
          <target state="translated">camera.colorspace()</target>
        </trans-unit>
        <trans-unit id="8ce8eab1e6ef0a11fd6c8ddb302e58d2e499e9a5" translate="yes" xml:space="preserve">
          <source>camera.list_cameras()</source>
          <target state="translated">camera.list_cameras()</target>
        </trans-unit>
        <trans-unit id="76b3983dc9f9c9635bf3043f9a5dc0a83e9956ef" translate="yes" xml:space="preserve">
          <source>captures an image as a Surface</source>
          <target state="translated">이미지를 표면으로 캡처</target>
        </trans-unit>
        <trans-unit id="2425ee73fee27ce14704c111e0c42defe495e3c5" translate="yes" xml:space="preserve">
          <source>cdrom</source>
          <target state="translated">cdrom</target>
        </trans-unit>
        <trans-unit id="9acafb2ada97f6cd3239ad66f94f695b44008f88" translate="yes" xml:space="preserve">
          <source>cdrom.CD</source>
          <target state="translated">cdrom.CD</target>
        </trans-unit>
        <trans-unit id="ea222f09797ee3aaec951304e80cbc64a6064c15" translate="yes" xml:space="preserve">
          <source>cdrom.CD.eject()</source>
          <target state="translated">cdrom.CD.eject()</target>
        </trans-unit>
        <trans-unit id="dbb46babf5ce0dafb2547861f5f8f27e6223b7d0" translate="yes" xml:space="preserve">
          <source>cdrom.CD.get_all()</source>
          <target state="translated">cdrom.CD.get_all()</target>
        </trans-unit>
        <trans-unit id="0db36e13541b9cfb131291d48713f952ee57067c" translate="yes" xml:space="preserve">
          <source>cdrom.CD.get_busy()</source>
          <target state="translated">cdrom.CD.get_busy()</target>
        </trans-unit>
        <trans-unit id="8db6b12ec9e2cce80512070e5c917c6232631160" translate="yes" xml:space="preserve">
          <source>cdrom.CD.get_current()</source>
          <target state="translated">cdrom.CD.get_current()</target>
        </trans-unit>
        <trans-unit id="a8cc7c86812c4d8f5caefc4557182e1643a66102" translate="yes" xml:space="preserve">
          <source>cdrom.CD.get_empty()</source>
          <target state="translated">cdrom.CD.get_empty()</target>
        </trans-unit>
        <trans-unit id="75913b0f93a2d797e9d937f7d279b188360855e7" translate="yes" xml:space="preserve">
          <source>cdrom.CD.get_id()</source>
          <target state="translated">cdrom.CD.get_id()</target>
        </trans-unit>
        <trans-unit id="e1e8d1f01a34a2906ec875458ab3ba801469418a" translate="yes" xml:space="preserve">
          <source>cdrom.CD.get_init()</source>
          <target state="translated">cdrom.CD.get_init()</target>
        </trans-unit>
        <trans-unit id="625bed5cfb1b72d41ac10fdf51bbdc9b10e603f8" translate="yes" xml:space="preserve">
          <source>cdrom.CD.get_name()</source>
          <target state="translated">cdrom.CD.get_name()</target>
        </trans-unit>
        <trans-unit id="1becf018b14d7a6e6cb06a1911290b843dfd8c2c" translate="yes" xml:space="preserve">
          <source>cdrom.CD.get_numtracks()</source>
          <target state="translated">cdrom.CD.get_numtracks()</target>
        </trans-unit>
        <trans-unit id="b5b41cb8d9b73146d58bd7cbb1cfc732dbe6d494" translate="yes" xml:space="preserve">
          <source>cdrom.CD.get_paused()</source>
          <target state="translated">cdrom.CD.get_paused()</target>
        </trans-unit>
        <trans-unit id="52913290fdc00c36dd2271794f49e6178f053fcf" translate="yes" xml:space="preserve">
          <source>cdrom.CD.get_track_audio()</source>
          <target state="translated">cdrom.CD.get_track_audio()</target>
        </trans-unit>
        <trans-unit id="40dc97267c3331ee8097486b10f4fde5490b883d" translate="yes" xml:space="preserve">
          <source>cdrom.CD.get_track_length()</source>
          <target state="translated">cdrom.CD.get_track_length()</target>
        </trans-unit>
        <trans-unit id="bca44c0230b664955200bac9e7e564b689662baa" translate="yes" xml:space="preserve">
          <source>cdrom.CD.get_track_start()</source>
          <target state="translated">cdrom.CD.get_track_start()</target>
        </trans-unit>
        <trans-unit id="58a344ea82f99428773a531ad45f685780c37a3d" translate="yes" xml:space="preserve">
          <source>cdrom.CD.init()</source>
          <target state="translated">cdrom.CD.init()</target>
        </trans-unit>
        <trans-unit id="a9ef43b3dfdbeac4b15e86267f01a5f05439edf6" translate="yes" xml:space="preserve">
          <source>cdrom.CD.pause()</source>
          <target state="translated">cdrom.CD.pause()</target>
        </trans-unit>
        <trans-unit id="7af6be3eb6fbff85a3f1e268e426bed0fc129522" translate="yes" xml:space="preserve">
          <source>cdrom.CD.play()</source>
          <target state="translated">cdrom.CD.play()</target>
        </trans-unit>
        <trans-unit id="389da60f3535b1842e5d047a115cda2245d9a859" translate="yes" xml:space="preserve">
          <source>cdrom.CD.quit()</source>
          <target state="translated">cdrom.CD.quit()</target>
        </trans-unit>
        <trans-unit id="1c86c852ea6172d866c51f822c65943f7a96e3de" translate="yes" xml:space="preserve">
          <source>cdrom.CD.resume()</source>
          <target state="translated">cdrom.CD.resume()</target>
        </trans-unit>
        <trans-unit id="0a47c155e3e47836fd0a76d70c7b92b0b0468e1b" translate="yes" xml:space="preserve">
          <source>cdrom.CD.stop()</source>
          <target state="translated">cdrom.CD.stop()</target>
        </trans-unit>
        <trans-unit id="a612d0b5d59fa907c714fce025430f076313bfd6" translate="yes" xml:space="preserve">
          <source>cdrom.get_count()</source>
          <target state="translated">cdrom.get_count()</target>
        </trans-unit>
        <trans-unit id="e4ba407cbb788538d38140c66d6fbc8de6b0f88f" translate="yes" xml:space="preserve">
          <source>cdrom.get_init()</source>
          <target state="translated">cdrom.get_init()</target>
        </trans-unit>
        <trans-unit id="d622373219e31cc54270a3ab77cd21f5646e486e" translate="yes" xml:space="preserve">
          <source>cdrom.init()</source>
          <target state="translated">cdrom.init()</target>
        </trans-unit>
        <trans-unit id="a48c65cdb3458bec3efb912633dbc21e4109b3c3" translate="yes" xml:space="preserve">
          <source>cdrom.quit()</source>
          <target state="translated">cdrom.quit()</target>
        </trans-unit>
        <trans-unit id="e95c31f035b0597448e2de8df4aaa7a7c52fc78b" translate="yes" xml:space="preserve">
          <source>change the pixel format of an image</source>
          <target state="translated">이미지의 픽셀 형식을 변경</target>
        </trans-unit>
        <trans-unit id="65550e2ade3aec4050ba783f25b57dff84195e05" translate="yes" xml:space="preserve">
          <source>change the pixel format of an image including per pixel alphas</source>
          <target state="translated">픽셀 당 알파를 포함하여 이미지의 픽셀 형식을 변경</target>
        </trans-unit>
        <trans-unit id="777af723a0484fcc025f2b9b5f8ef542bc5d3245" translate="yes" xml:space="preserve">
          <source>changes camera settings if supported by the camera</source>
          <target state="translated">카메라가 지원하는 경우 카메라 설정을 변경합니다</target>
        </trans-unit>
        <trans-unit id="719ce07618d4301ddd25eea05a4c8f171adbae61" translate="yes" xml:space="preserve">
          <source>changes the layer of the sprite</source>
          <target state="translated">스프라이트의 레이어를 변경</target>
        </trans-unit>
        <trans-unit id="b363bc4317aac956f2299dc06bbd061a10bacd78" translate="yes" xml:space="preserve">
          <source>check if text will be rendered bold</source>
          <target state="translated">텍스트가 굵게 표시되는지 확인</target>
        </trans-unit>
        <trans-unit id="57aecf7d79932282efeefd0ae7b3a0f27e957572" translate="yes" xml:space="preserve">
          <source>check if text will be rendered with an underline</source>
          <target state="translated">밑줄로 텍스트가 렌더링되는지 확인</target>
        </trans-unit>
        <trans-unit id="2356303e4a7052ab5b1584b2db1df4a52b9d702c" translate="yes" xml:space="preserve">
          <source>check if the Joystick is initialized</source>
          <target state="translated">조이스틱이 초기화되었는지 확인</target>
        </trans-unit>
        <trans-unit id="b0ddd6cf1ab6ead75341fe6f33c6dd8de3c56eda" translate="yes" xml:space="preserve">
          <source>check if the channel is active</source>
          <target state="translated">채널이 활성화되어 있는지 확인</target>
        </trans-unit>
        <trans-unit id="b3b8e6b103df7e535fe0a9c8791da2eb33ae00c8" translate="yes" xml:space="preserve">
          <source>check if the display is receiving mouse input</source>
          <target state="translated">디스플레이가 마우스 입력을 받고 있는지 확인</target>
        </trans-unit>
        <trans-unit id="02625d5691ee2daef0e27523d34b59a91efbb98c" translate="yes" xml:space="preserve">
          <source>check if the music stream is playing</source>
          <target state="translated">음악 스트림이 재생 중인지 확인</target>
        </trans-unit>
        <trans-unit id="b2b029c0ad83241d8052c4a937993fc4b979cbc4" translate="yes" xml:space="preserve">
          <source>check if the text will be rendered italic</source>
          <target state="translated">텍스트가 기울임 꼴로 렌더링되는지 확인</target>
        </trans-unit>
        <trans-unit id="e98070d64e30a4c6920a2a1fa94555b5f9723697" translate="yes" xml:space="preserve">
          <source>checks if a frame is ready</source>
          <target state="translated">프레임이 준비되었는지 확인</target>
        </trans-unit>
        <trans-unit id="a0a9a70989f0f7670fd947413e1b85e3d78fe2b8" translate="yes" xml:space="preserve">
          <source>class to manage a cdrom drive</source>
          <target state="translated">CDROM 드라이브를 관리하는 클래스</target>
        </trans-unit>
        <trans-unit id="b7ff3f9b0a5929f90ecc02ec580db8e10edb0cdf" translate="yes" xml:space="preserve">
          <source>clip the area where to draw. Just pass None (default) to reset the clip</source>
          <target state="translated">그릴 영역을 자릅니다. 클립을 재설정하려면 없음 (기본값)을 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="0ca049e6543b0f8b48305d6c7b2518b970302fcc" translate="yes" xml:space="preserve">
          <source>close() method was added. For explicitly cleaning up.</source>
          <target state="translated">close () 메소드가 추가되었습니다. 명시 적으로 정리합니다.</target>
        </trans-unit>
        <trans-unit id="eeeef85c28b9a57e63ea9296066ba1ee432d23ea" translate="yes" xml:space="preserve">
          <source>closes a midi stream, flushing any pending buffers.</source>
          <target state="translated">미디 스트림을 닫고 보류중인 버퍼를 비 웁니다.</target>
        </trans-unit>
        <trans-unit id="8c2c4a39dd41c200902f0e1747c804b1cdf0842e" translate="yes" xml:space="preserve">
          <source>collided callables:</source>
          <target state="translated">충돌 콜 러블 :</target>
        </trans-unit>
        <trans-unit id="9ff4ffc8c10c22075260b0062efbc5c7088aeda5" translate="yes" xml:space="preserve">
          <source>color value (see note below for the supported formats)</source>
          <target state="translated">색상 값 (지원되는 형식은 아래 참고 참조)</target>
        </trans-unit>
        <trans-unit id="b38b41ea0aa9a03e9e3a0a3e788af062f98752a8" translate="yes" xml:space="preserve">
          <source>compute the clock framerate</source>
          <target state="translated">클럭 프레임 레이트를 계산</target>
        </trans-unit>
        <trans-unit id="194550a965f81e41cb39331ab88a81ccd568ea02" translate="yes" xml:space="preserve">
          <source>control how held keys are repeated</source>
          <target state="translated">홀드 키 반복 방법 제어</target>
        </trans-unit>
        <trans-unit id="6bb9b7240d945a92ec08af3afd81f13e44277c1b" translate="yes" xml:space="preserve">
          <source>control if text is rendered with an underline</source>
          <target state="translated">밑줄로 텍스트를 렌더링할지 제어</target>
        </trans-unit>
        <trans-unit id="46c14b42ae2c58af17395cc992810934af5df374" translate="yes" xml:space="preserve">
          <source>control the sharing of input devices with other applications</source>
          <target state="translated">다른 응용 프로그램과 입력 장치의 공유 제어</target>
        </trans-unit>
        <trans-unit id="69d843d67b348766b36c5f47b31ffc3d64fb6bbd" translate="yes" xml:space="preserve">
          <source>control where the overlay is displayed</source>
          <target state="translated">오버레이가 표시되는 위치를 제어</target>
        </trans-unit>
        <trans-unit id="aaaa9c0e221a0d28b9b74484750db3ef90ffc79b" translate="yes" xml:space="preserve">
          <source>control which events are allowed on the queue</source>
          <target state="translated">큐에서 허용되는 이벤트 제어</target>
        </trans-unit>
        <trans-unit id="411f345bf52c64b8f8fb316343169be632839098" translate="yes" xml:space="preserve">
          <source>controls the position of the candidate list</source>
          <target state="translated">후보 목록의 위치를 ​​제어합니다</target>
        </trans-unit>
        <trans-unit id="45ec855d4d99978d674d11efab61fa0bd54cce53" translate="yes" xml:space="preserve">
          <source>convert a color into a mapped color value</source>
          <target state="translated">색상을 매핑 된 색상 값으로 변환</target>
        </trans-unit>
        <trans-unit id="1f8bc34faf8446ca519f8538893cef58900e3ef3" translate="yes" xml:space="preserve">
          <source>convert a mapped integer color value into a Color</source>
          <target state="translated">매핑 된 정수 색 값을 색으로 변환</target>
        </trans-unit>
        <trans-unit id="9b034c81b27e752ffa4c395226aadfe9527ac24d" translate="yes" xml:space="preserve">
          <source>convert an array into a Sound object</source>
          <target state="translated">배열을 Sound 객체로 변환</target>
        </trans-unit>
        <trans-unit id="f1c8e095552f484428fce694bea3b5fbd0869de6" translate="yes" xml:space="preserve">
          <source>converts midi events to pygame events</source>
          <target state="translated">미디 이벤트를 파이 게임 이벤트로 변환</target>
        </trans-unit>
        <trans-unit id="0520d57f1bc6fac68371ffcf49b8ac55620e87b3" translate="yes" xml:space="preserve">
          <source>copy Sound samples into an array</source>
          <target state="translated">사운드 샘플을 배열로 복사</target>
        </trans-unit>
        <trans-unit id="9cd4fa0177a4908d79508dda4bcfa9498593f74d" translate="yes" xml:space="preserve">
          <source>copy an array object to a surface</source>
          <target state="translated">배열 객체를 표면에 복사</target>
        </trans-unit>
        <trans-unit id="d8a10209ba6e354fdd0938a16c32d8100015b52f" translate="yes" xml:space="preserve">
          <source>copy an array to another array, using surface format</source>
          <target state="translated">표면 형식을 사용하여 배열을 다른 배열로 복사</target>
        </trans-unit>
        <trans-unit id="7209279f0286787539ebf03a8d0b01b3b6d9741e" translate="yes" xml:space="preserve">
          <source>copy surface pixels to an array object</source>
          <target state="translated">표면 픽셀을 배열 객체에 복사</target>
        </trans-unit>
        <trans-unit id="446aa633941f9d89160bf859627697f1ba7d45fb" translate="yes" xml:space="preserve">
          <source>copy the rectangle</source>
          <target state="translated">사각형을 복사</target>
        </trans-unit>
        <trans-unit id="f9afd77ff150a7d0bfae334e001c2732a1c0619c" translate="yes" xml:space="preserve">
          <source>correct negative sizes</source>
          <target state="translated">올바른 음수 크기</target>
        </trans-unit>
        <trans-unit id="d98e2381b725dd74da2eb36c61afbbfd1907d0b1" translate="yes" xml:space="preserve">
          <source>count how many times this Sound is playing</source>
          <target state="translated">이 소리가 몇 번이나 재생되는지 세어보세요</target>
        </trans-unit>
        <trans-unit id="938dd10d49b5387d767e0a42031dee71d9b63d7d" translate="yes" xml:space="preserve">
          <source>create a Font object from the system fonts</source>
          <target state="translated">시스템 글꼴에서 Font 객체를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="8471d4c628e546ce61460a51f039360ff15319ba" translate="yes" xml:space="preserve">
          <source>create a new Font object from a file</source>
          <target state="translated">파일에서 새로운 Font 객체를 생성</target>
        </trans-unit>
        <trans-unit id="7045288a355113272bf7978ffc4ff6d2f996b97d" translate="yes" xml:space="preserve">
          <source>create a new Surface that shares data inside a string buffer</source>
          <target state="translated">문자열 버퍼 내에서 데이터를 공유하는 새로운 Surface를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="883fd277ebdb8a60a0be47af58b7191503ae9072" translate="yes" xml:space="preserve">
          <source>create a new copy of a Surface</source>
          <target state="translated">Surface의 새 복사본을 만듭니다</target>
        </trans-unit>
        <trans-unit id="7109d1d82f1d236d2b6b35943e599956824d804f" translate="yes" xml:space="preserve">
          <source>create a new event object</source>
          <target state="translated">새로운 이벤트 객체를 생성</target>
        </trans-unit>
        <trans-unit id="80171673c3aa35aaa28619b10e1de8a64f03ee0c" translate="yes" xml:space="preserve">
          <source>create a new surface that references its parent</source>
          <target state="translated">부모를 참조하는 새 표면을 만듭니다</target>
        </trans-unit>
        <trans-unit id="75e2ce9cdad41cd23055672176f0d11bb53e4106" translate="yes" xml:space="preserve">
          <source>create an object to help track time</source>
          <target state="translated">시간을 추적하는 데 도움이되는 개체 만들기</target>
        </trans-unit>
        <trans-unit id="a82be337a92986b664588cc1bc0931641d35a311" translate="yes" xml:space="preserve">
          <source>create binary cursor data from simple strings</source>
          <target state="translated">간단한 문자열에서 이진 커서 데이터 생성</target>
        </trans-unit>
        <trans-unit id="a1cad0e41ee788a0d610ca8f108c81c2c493b23f" translate="yes" xml:space="preserve">
          <source>create new Surface from a string buffer</source>
          <target state="translated">문자열 버퍼에서 새로운 Surface 생성</target>
        </trans-unit>
        <trans-unit id="701d522dc4b57684ed67a26054543b86fd3a8c5c" translate="yes" xml:space="preserve">
          <source>crops a rectangle inside another</source>
          <target state="translated">다른 안에 직사각형을 자르다</target>
        </trans-unit>
        <trans-unit id="5a4836c8f21401443ee42603a3c769adf56dc26d" translate="yes" xml:space="preserve">
          <source>cursors</source>
          <target state="translated">cursors</target>
        </trans-unit>
        <trans-unit id="b94ee83877098932be5392b22e11cc679e78ef17" translate="yes" xml:space="preserve">
          <source>cursors.compile()</source>
          <target state="translated">cursors.compile()</target>
        </trans-unit>
        <trans-unit id="afdf01ece29baf13747a118b43975a7b57085a4d" translate="yes" xml:space="preserve">
          <source>cursors.load_xbm()</source>
          <target state="translated">cursors.load_xbm()</target>
        </trans-unit>
        <trans-unit id="5f6ac66d5e7594526ae8540ce24e20cf2b49895b" translate="yes" xml:space="preserve">
          <source>data (byte string in python 3 or str in python 2) for the given type identifier or &lt;code&gt;None&lt;/code&gt; if no data for the given type is available</source>
          <target state="translated">주어진 유형 식별자에 대한 데이터 (python 3의 바이트 문자열 또는 python 2의 str) 또는 주어진 유형에 대한 데이터가 없으면 &lt;code&gt;None&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b1b647cde97287beb889d5191aa5087254372a26" translate="yes" xml:space="preserve">
          <source>default foreground color</source>
          <target state="translated">기본 전경색</target>
        </trans-unit>
        <trans-unit id="6fd6b989b39dea3be6bf59c5d9fccec6bcedca4d" translate="yes" xml:space="preserve">
          <source>demonstrate the various surface.fill method blend options</source>
          <target state="translated">다양한 surface.fill 메소드 블렌드 옵션을 시연</target>
        </trans-unit>
        <trans-unit id="dcdf51bc7f4621a23a4f206733198c5330f00492" translate="yes" xml:space="preserve">
          <source>determine the amount of space needed to render text</source>
          <target state="translated">텍스트를 렌더링하는 데 필요한 공간을 결정</target>
        </trans-unit>
        <trans-unit id="d84a4529022f7e340d6ac2a8b7ef2335a362a361" translate="yes" xml:space="preserve">
          <source>determine which modifier keys are being held</source>
          <target state="translated">보유하고있는 수정 자 키 결정</target>
        </trans-unit>
        <trans-unit id="04aad306a487c69097c7d81cb73ebd35e7c05974" translate="yes" xml:space="preserve">
          <source>dirty = 1</source>
          <target state="translated">더러운 = 1</target>
        </trans-unit>
        <trans-unit id="59b189070af751d4e93a749ccffb4ccfd2de7ab5" translate="yes" xml:space="preserve">
          <source>display</source>
          <target state="translated">display</target>
        </trans-unit>
        <trans-unit id="5e93802e0ec161689df22c290cf9814e70b68e4c" translate="yes" xml:space="preserve">
          <source>display a vertical gradient</source>
          <target state="translated">세로 그라데이션을 표시</target>
        </trans-unit>
        <trans-unit id="e52a78787d5fbcd3b9b5f0efed12baf66b0137c8" translate="yes" xml:space="preserve">
          <source>display an animated 3D cube using OpenGL</source>
          <target state="translated">OpenGL을 사용하여 애니메이션 3D 큐브 표시</target>
        </trans-unit>
        <trans-unit id="6cb04cdc36f34197ddbb5f6b1c56cc8adb9a96a7" translate="yes" xml:space="preserve">
          <source>display an animated liquid effect</source>
          <target state="translated">애니메이션 액체 효과 표시</target>
        </trans-unit>
        <trans-unit id="929212fa8212357f481d82287ceb5cc2c8f6f9a9" translate="yes" xml:space="preserve">
          <source>display animated objects on the screen</source>
          <target state="translated">애니메이션 객체를 화면에 표시</target>
        </trans-unit>
        <trans-unit id="bd608ee023fdfaa8229fa3d7df87dbcaacf1aa4e" translate="yes" xml:space="preserve">
          <source>display multiple images bounce off each other using collision detection</source>
          <target state="translated">충돌 감지를 사용하여 여러 이미지가 서로 바운스 표시</target>
        </trans-unit>
        <trans-unit id="017d7b1439e5b855effa30ad1679d5b3742357c9" translate="yes" xml:space="preserve">
          <source>display pygame events</source>
          <target state="translated">파이 게임 이벤트 표시</target>
        </trans-unit>
        <trans-unit id="838b5cb3453ec84b241c3c9e5f42ab22c35b2034" translate="yes" xml:space="preserve">
          <source>display two different custom cursors</source>
          <target state="translated">서로 다른 두 개의 사용자 정의 커서 표시</target>
        </trans-unit>
        <trans-unit id="090988c359ae4dfdbb60df5c2ca9431f1eea604e" translate="yes" xml:space="preserve">
          <source>display various pixelarray generated effects</source>
          <target state="translated">다양한 픽셀 배열 생성 효과 표시</target>
        </trans-unit>
        <trans-unit id="5ec8e74ded2abbee9768bf6ef67253537de6eddc" translate="yes" xml:space="preserve">
          <source>display video captured live from an attached camera</source>
          <target state="translated">연결된 카메라에서 실시간으로 캡처 한 비디오 표시</target>
        </trans-unit>
        <trans-unit id="7d6e4bec30a33895f83d864bde1b5926cdc43130" translate="yes" xml:space="preserve">
          <source>display.Info()</source>
          <target state="translated">display.Info()</target>
        </trans-unit>
        <trans-unit id="05f9040c19eb182c381d6f5d07679382a62d9ad6" translate="yes" xml:space="preserve">
          <source>display.flip()</source>
          <target state="translated">display.flip()</target>
        </trans-unit>
        <trans-unit id="5be6eb712342ebb5f17b469a9f4db268727934e0" translate="yes" xml:space="preserve">
          <source>display.get_active()</source>
          <target state="translated">display.get_active()</target>
        </trans-unit>
        <trans-unit id="d7dffe1d449f766afd94ade7f9aba2bf6c61e437" translate="yes" xml:space="preserve">
          <source>display.get_caption()</source>
          <target state="translated">display.get_caption()</target>
        </trans-unit>
        <trans-unit id="aa618884d31d49ac6756f0256a403824d8213d94" translate="yes" xml:space="preserve">
          <source>display.get_driver()</source>
          <target state="translated">display.get_driver()</target>
        </trans-unit>
        <trans-unit id="f72dd1bb05fdd9cdcedb9592e57544b3d852c9fc" translate="yes" xml:space="preserve">
          <source>display.get_init()</source>
          <target state="translated">display.get_init()</target>
        </trans-unit>
        <trans-unit id="f7bb581502e21e940a57ce7b53e2805a7c29280c" translate="yes" xml:space="preserve">
          <source>display.get_num_displays()</source>
          <target state="translated">display.get_num_displays()</target>
        </trans-unit>
        <trans-unit id="14c1cdf7bb9d369cd85c9638b74b63ba3dc0b023" translate="yes" xml:space="preserve">
          <source>display.get_surface()</source>
          <target state="translated">display.get_surface()</target>
        </trans-unit>
        <trans-unit id="362d72e1c8a6a914d0501a409a4d476452f5d859" translate="yes" xml:space="preserve">
          <source>display.get_window_size()</source>
          <target state="translated">display.get_window_size()</target>
        </trans-unit>
        <trans-unit id="1fcffece018153d552c519c8ce62aa0c4783a581" translate="yes" xml:space="preserve">
          <source>display.get_wm_info()</source>
          <target state="translated">display.get_wm_info()</target>
        </trans-unit>
        <trans-unit id="1ddd794348a052e0dfd42fe1be142a45e6265391" translate="yes" xml:space="preserve">
          <source>display.gl_get_attribute()</source>
          <target state="translated">display.gl_get_attribute()</target>
        </trans-unit>
        <trans-unit id="7e59d9cd15c65a5d55c187dee32a25e9b656338f" translate="yes" xml:space="preserve">
          <source>display.gl_set_attribute()</source>
          <target state="translated">display.gl_set_attribute()</target>
        </trans-unit>
        <trans-unit id="dfad74e79ca665134aac8b67223c408281e5110a" translate="yes" xml:space="preserve">
          <source>display.iconify()</source>
          <target state="translated">display.iconify()</target>
        </trans-unit>
        <trans-unit id="1506622ea64bb89631c5aefa594d2a8f2c64aacd" translate="yes" xml:space="preserve">
          <source>display.init()</source>
          <target state="translated">display.init()</target>
        </trans-unit>
        <trans-unit id="8f29f4fe2760ba147b00f7bbe42c20d94649e1dd" translate="yes" xml:space="preserve">
          <source>display.list_modes()</source>
          <target state="translated">display.list_modes()</target>
        </trans-unit>
        <trans-unit id="8461d49834bc97f8c893869081322aae8cefa6b9" translate="yes" xml:space="preserve">
          <source>display.mode_ok()</source>
          <target state="translated">display.mode_ok()</target>
        </trans-unit>
        <trans-unit id="591b27727c43ddf3a6cc81de579ffb45e61fc259" translate="yes" xml:space="preserve">
          <source>display.quit()</source>
          <target state="translated">display.quit()</target>
        </trans-unit>
        <trans-unit id="77a64e9c4b33880137d1e390df4ff6a12ee3be56" translate="yes" xml:space="preserve">
          <source>display.set_caption()</source>
          <target state="translated">display.set_caption()</target>
        </trans-unit>
        <trans-unit id="827a3282afdbbf4ddc915425999acce5761efa28" translate="yes" xml:space="preserve">
          <source>display.set_gamma()</source>
          <target state="translated">display.set_gamma()</target>
        </trans-unit>
        <trans-unit id="bb17ca634b79ab226ca65d7f827d0d98b1ea92c8" translate="yes" xml:space="preserve">
          <source>display.set_gamma_ramp()</source>
          <target state="translated">display.set_gamma_ramp()</target>
        </trans-unit>
        <trans-unit id="4732228f68f8dbda20fcd1820a36b5340a158d42" translate="yes" xml:space="preserve">
          <source>display.set_icon()</source>
          <target state="translated">display.set_icon()</target>
        </trans-unit>
        <trans-unit id="71fccfdf5fe3e6b5d15fd46312e4f1f03e4aeaeb" translate="yes" xml:space="preserve">
          <source>display.set_mode()</source>
          <target state="translated">display.set_mode()</target>
        </trans-unit>
        <trans-unit id="c1f225bfe476aaaa5da1f950ab9dfd9417a24b86" translate="yes" xml:space="preserve">
          <source>display.set_palette()</source>
          <target state="translated">display.set_palette()</target>
        </trans-unit>
        <trans-unit id="091d5acc082461e005ab117efb66cc7a7c256d3b" translate="yes" xml:space="preserve">
          <source>display.toggle_fullscreen()</source>
          <target state="translated">display.toggle_fullscreen()</target>
        </trans-unit>
        <trans-unit id="25b78cc3017a7f66022318df6d1fc1b79def43ff" translate="yes" xml:space="preserve">
          <source>display.update()</source>
          <target state="translated">display.update()</target>
        </trans-unit>
        <trans-unit id="3feff39992ea069458532ffd37e7d7e92fd9d4a2" translate="yes" xml:space="preserve">
          <source>does the sprite belong to any groups</source>
          <target state="translated">스프라이트가 모든 그룹에 속합니까?</target>
        </trans-unit>
        <trans-unit id="76a4e12c213db0acb3ebeb6524fba72cbdcba716" translate="yes" xml:space="preserve">
          <source>draw</source>
          <target state="translated">draw</target>
        </trans-unit>
        <trans-unit id="afad61e7452f85d53249212a583cd1356e43b612" translate="yes" xml:space="preserve">
          <source>draw a B&amp;eacute;zier curve</source>
          <target state="translated">베 지어 곡선 그리기</target>
        </trans-unit>
        <trans-unit id="2b775f0ca91b78b8b0cdad8e70b2a057cb66ac5e" translate="yes" xml:space="preserve">
          <source>draw a background over the Sprites</source>
          <target state="translated">스프라이트 위에 배경을 그리다</target>
        </trans-unit>
        <trans-unit id="fedaddfe6747e5d28f89b4b4582de6b15bd1f220" translate="yes" xml:space="preserve">
          <source>draw a box</source>
          <target state="translated">상자를 그리다</target>
        </trans-unit>
        <trans-unit id="679e63b3a4d811db5607f8a35d0d1c5dfff96051" translate="yes" xml:space="preserve">
          <source>draw a circle</source>
          <target state="translated">원을 그리다</target>
        </trans-unit>
        <trans-unit id="d017e0c6fc5cdf11de80d51ac98ced5d384a9f07" translate="yes" xml:space="preserve">
          <source>draw a filled circle</source>
          <target state="translated">채워진 원을 그리다</target>
        </trans-unit>
        <trans-unit id="a7a9de7477bf57172f914622c8efa8905ad99c86" translate="yes" xml:space="preserve">
          <source>draw a filled ellipse</source>
          <target state="translated">채워진 타원을 그리다</target>
        </trans-unit>
        <trans-unit id="830ab454938ae6835f38d0ce51d31123dc641098" translate="yes" xml:space="preserve">
          <source>draw a filled polygon</source>
          <target state="translated">채워진 다각형 그리기</target>
        </trans-unit>
        <trans-unit id="4d94a91dc3f8868dfc6fdcbf1eb7040ce8a5d441" translate="yes" xml:space="preserve">
          <source>draw a filled trigon</source>
          <target state="translated">채워진 삼각대를 그리다</target>
        </trans-unit>
        <trans-unit id="3060e66ce3a43383a9ca2d7d96ee4c27a927f190" translate="yes" xml:space="preserve">
          <source>draw a horizontal line</source>
          <target state="translated">수평선을 그리다</target>
        </trans-unit>
        <trans-unit id="830d138c70aa9e15a07c492968ca00d32a9349f2" translate="yes" xml:space="preserve">
          <source>draw a line</source>
          <target state="translated">선을 그리다</target>
        </trans-unit>
        <trans-unit id="53c356d6e6bfd0181fe38266ddfe627b5fefe22c" translate="yes" xml:space="preserve">
          <source>draw a pie</source>
          <target state="translated">파이를 그리다</target>
        </trans-unit>
        <trans-unit id="bd993e179724e13344ac6c3e3cfd568cdb17f709" translate="yes" xml:space="preserve">
          <source>draw a polygon</source>
          <target state="translated">다각형을 그리다</target>
        </trans-unit>
        <trans-unit id="783ea670297f0450709da81520f7f451bd9ee338" translate="yes" xml:space="preserve">
          <source>draw a rectangle</source>
          <target state="translated">직사각형을 그리다</target>
        </trans-unit>
        <trans-unit id="f408317d90764b9c97574bde016775d4c625dfc6" translate="yes" xml:space="preserve">
          <source>draw a straight antialiased line</source>
          <target state="translated">앤티 앨리어싱 된 직선 그리기</target>
        </trans-unit>
        <trans-unit id="7a5eca96a0a6fb18cd1cfd29314ce63ccea4b6ac" translate="yes" xml:space="preserve">
          <source>draw a straight line</source>
          <target state="translated">직선을 그리다</target>
        </trans-unit>
        <trans-unit id="e48626f008c56af018a22d10b91698f83b7e1b51" translate="yes" xml:space="preserve">
          <source>draw a textured polygon</source>
          <target state="translated">질감이있는 다각형 그리기</target>
        </trans-unit>
        <trans-unit id="6c97d4febace9991c95c671e85f2f3c1ebc25615" translate="yes" xml:space="preserve">
          <source>draw a triangle</source>
          <target state="translated">삼각형을 그리다</target>
        </trans-unit>
        <trans-unit id="60eb853ed38f719bd1f0ea1018cbb5efca926ff6" translate="yes" xml:space="preserve">
          <source>draw a vertical line</source>
          <target state="translated">세로선을 그리다</target>
        </trans-unit>
        <trans-unit id="21d258f565f0342129663b1a55cbf2bc1f31d224" translate="yes" xml:space="preserve">
          <source>draw all sprites in the right order onto the passed surface.</source>
          <target state="translated">통과 한 표면에 모든 스프라이트를 올바른 순서로 그립니다.</target>
        </trans-unit>
        <trans-unit id="1d1bb1c71af1ce43a6f8d415d5359dba5922e3ad" translate="yes" xml:space="preserve">
          <source>draw an anti-aliased circle</source>
          <target state="translated">앤티 앨리어싱 된 원 그리기</target>
        </trans-unit>
        <trans-unit id="7ae21e94a4b53b8aa10466f9edcf850b2cf38895" translate="yes" xml:space="preserve">
          <source>draw an anti-aliased ellipse</source>
          <target state="translated">앤티 앨리어싱 된 타원 그리기</target>
        </trans-unit>
        <trans-unit id="0e75a2ad1ff65657de407a0dec34fe654f67cdea" translate="yes" xml:space="preserve">
          <source>draw an anti-aliased polygon</source>
          <target state="translated">앤티 앨리어싱 된 다각형 그리기</target>
        </trans-unit>
        <trans-unit id="26bcda22096fbb9e74dcd0e210a208a4341584e7" translate="yes" xml:space="preserve">
          <source>draw an anti-aliased triangle</source>
          <target state="translated">앤티 앨리어싱 삼각형 그리기</target>
        </trans-unit>
        <trans-unit id="7314727296de78eea16a1db871b877cec5168f08" translate="yes" xml:space="preserve">
          <source>draw an arc</source>
          <target state="translated">호를 그리다</target>
        </trans-unit>
        <trans-unit id="13d5af871efe70b826030f541879010fe1786ceb" translate="yes" xml:space="preserve">
          <source>draw an ellipse</source>
          <target state="translated">타원을 그리다</target>
        </trans-unit>
        <trans-unit id="cdb22f7ee70d091f8e4394bbca7ff53534a17ba2" translate="yes" xml:space="preserve">
          <source>draw an elliptical arc</source>
          <target state="translated">타원형 호를 그리다</target>
        </trans-unit>
        <trans-unit id="fd6876d4dfb85c1fe06a71375054f37f7b80c796" translate="yes" xml:space="preserve">
          <source>draw many images onto another</source>
          <target state="translated">많은 이미지를 다른 이미지로 그리다</target>
        </trans-unit>
        <trans-unit id="17331b3b4a960dd354c1999578e16bc7dd1db4c3" translate="yes" xml:space="preserve">
          <source>draw multiple contiguous straight antialiased line segments</source>
          <target state="translated">여러 개의 연속 된 직선 앤티 앨리어싱 선분 그리기</target>
        </trans-unit>
        <trans-unit id="c2fde5cf2ba9aa5d6b186cc45f640011214e6f06" translate="yes" xml:space="preserve">
          <source>draw multiple contiguous straight line segments</source>
          <target state="translated">여러 개의 연속 된 직선 세그먼트를 그립니다.</target>
        </trans-unit>
        <trans-unit id="f75b5310c5a89223d500a05f54a1c756ee3939df" translate="yes" xml:space="preserve">
          <source>draw one image onto another</source>
          <target state="translated">한 이미지를 다른 이미지로 그리다</target>
        </trans-unit>
        <trans-unit id="dac4a108833954b49d432f49499b88cf34fb203c" translate="yes" xml:space="preserve">
          <source>draw text on a new Surface</source>
          <target state="translated">새로운 표면에 텍스트를 그리다</target>
        </trans-unit>
        <trans-unit id="f1c9a8847a3fc3ccd99e73e4dc88515c582bfa2a" translate="yes" xml:space="preserve">
          <source>draw.aaline()</source>
          <target state="translated">draw.aaline()</target>
        </trans-unit>
        <trans-unit id="4b9f3c9da6556c3939d82cb6d1db4893a9b557c5" translate="yes" xml:space="preserve">
          <source>draw.aalines()</source>
          <target state="translated">draw.aalines()</target>
        </trans-unit>
        <trans-unit id="7af2f8714f2e376d02a9339da929bc3cb5006aa8" translate="yes" xml:space="preserve">
          <source>draw.arc()</source>
          <target state="translated">draw.arc()</target>
        </trans-unit>
        <trans-unit id="700c91859acf7117355cd136a3be4ec0559c1582" translate="yes" xml:space="preserve">
          <source>draw.circle()</source>
          <target state="translated">draw.circle()</target>
        </trans-unit>
        <trans-unit id="eba98fc72581702ef09aa8a7fa06727d5fe128ac" translate="yes" xml:space="preserve">
          <source>draw.ellipse()</source>
          <target state="translated">draw.ellipse()</target>
        </trans-unit>
        <trans-unit id="a0354da7222a3149abfd0b1cc2bb987a1642843d" translate="yes" xml:space="preserve">
          <source>draw.line()</source>
          <target state="translated">draw.line()</target>
        </trans-unit>
        <trans-unit id="36f60e21abaf91fc347311c938a754bf990e94b9" translate="yes" xml:space="preserve">
          <source>draw.lines()</source>
          <target state="translated">draw.lines()</target>
        </trans-unit>
        <trans-unit id="6ec5b4d36a3c26b168d0c8b6120e2021c505db90" translate="yes" xml:space="preserve">
          <source>draw.polygon()</source>
          <target state="translated">draw.polygon()</target>
        </trans-unit>
        <trans-unit id="be5e15d239f7ee365b96b23ff562549ca2850fd3" translate="yes" xml:space="preserve">
          <source>draw.rect()</source>
          <target state="translated">draw.rect()</target>
        </trans-unit>
        <trans-unit id="714d1ff0c64c1a4679bb3214b18120890a59975a" translate="yes" xml:space="preserve">
          <source>duplicate the Group</source>
          <target state="translated">그룹을 복제</target>
        </trans-unit>
        <trans-unit id="58f8cd308df92dfc4b71778e8a2df89019d5bb2f" translate="yes" xml:space="preserve">
          <source>eg:</source>
          <target state="translated">eg:</target>
        </trans-unit>
        <trans-unit id="c70659bbd1c89ad8e36a34f346311a47d971982b" translate="yes" xml:space="preserve">
          <source>eject or open the cdrom drive</source>
          <target state="translated">CDROM 드라이브 꺼내기 또는 열기</target>
        </trans-unit>
        <trans-unit id="33ac2262d6515d1b7b5aa0f2dd7d364788628917" translate="yes" xml:space="preserve">
          <source>enable fake rendering of bold text</source>
          <target state="translated">굵은 텍스트의 가짜 렌더링 사용</target>
        </trans-unit>
        <trans-unit id="df0046c471dd91ef6cd5f3679ae0d140e4b04b89" translate="yes" xml:space="preserve">
          <source>enable fake rendering of italic text</source>
          <target state="translated">기울임 꼴 텍스트의 가짜 렌더링 사용</target>
        </trans-unit>
        <trans-unit id="af1095aca19f17f164174138f2163254c37e250e" translate="yes" xml:space="preserve">
          <source>encode_file_path()</source>
          <target state="translated">encode_file_path()</target>
        </trans-unit>
        <trans-unit id="78d5aef436c87b129212cd9ce1969e3471a080bf" translate="yes" xml:space="preserve">
          <source>encode_string()</source>
          <target state="translated">encode_string()</target>
        </trans-unit>
        <trans-unit id="80abaf9db559d778d66e722ad83c206a508194ac" translate="yes" xml:space="preserve">
          <source>encoding (string): If present, encoding to use. The default is &lt;code&gt;'unicode_escape'&lt;/code&gt;.</source>
          <target state="translated">인코딩 (문자열) :있는 경우 사용할 인코딩입니다. 기본값은 &lt;code&gt;'unicode_escape'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="11f9578d05e6f7bb58a3cdd00107e9f4e3882671" translate="yes" xml:space="preserve">
          <source>error</source>
          <target state="translated">error</target>
        </trans-unit>
        <trans-unit id="6f931a56c0aaecff57fbbd8c5ce04783e20c33c1" translate="yes" xml:space="preserve">
          <source>errors (string): If given, how to handle unencodable characters. The default is &lt;code&gt;'backslashreplace'&lt;/code&gt;.</source>
          <target state="translated">errors (string) : 주어진 경우 불가피한 문자를 처리하는 방법. 기본값은 &lt;code&gt;'backslashreplace'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1a9f04f9359b545e9a7c5f35f26817bb488590a9" translate="yes" xml:space="preserve">
          <source>etype (exception type): If given, the exception type to raise for an encoding error. The default is &lt;code&gt;UnicodeEncodeError&lt;/code&gt;, as returned by &lt;code&gt;PyUnicode_AsEncodedString()&lt;/code&gt;.</source>
          <target state="translated">etype (예외 유형) : 주어진 경우 인코딩 오류에 대해 발생하는 예외 유형입니다. &lt;code&gt;PyUnicode_AsEncodedString()&lt;/code&gt; 의해 반환되는 기본값은 &lt;code&gt;UnicodeEncodeError&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3183d82bcfa992eca74def9ea4163a6ab470cb6f" translate="yes" xml:space="preserve">
          <source>etype (exception type): If given, the exception type to raise for an encoding error. The default is &lt;code&gt;UnicodeEncodeError&lt;/code&gt;, as returned by &lt;code&gt;PyUnicode_AsEncodedString()&lt;/code&gt;. For the default encoding and errors values there should be no encoding errors.</source>
          <target state="translated">etype (예외 유형) : 주어진 경우 인코딩 오류에 대해 발생하는 예외 유형입니다. &lt;code&gt;PyUnicode_AsEncodedString()&lt;/code&gt; 의해 반환되는 기본값은 &lt;code&gt;UnicodeEncodeError&lt;/code&gt; 입니다. 기본 인코딩 및 오류 값의 경우 인코딩 오류가 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="5006ed0248a019713b762563076292379daf07b4" translate="yes" xml:space="preserve">
          <source>event</source>
          <target state="translated">event</target>
        </trans-unit>
        <trans-unit id="c79f10fef38ce0b381942d1212141d5e1671ccef" translate="yes" xml:space="preserve">
          <source>event attribute dictionary</source>
          <target state="translated">이벤트 속성 사전</target>
        </trans-unit>
        <trans-unit id="f855babc3bead7d49821c502c90671669f223287" translate="yes" xml:space="preserve">
          <source>event type identifier.</source>
          <target state="translated">이벤트 유형 식별자.</target>
        </trans-unit>
        <trans-unit id="a829859728eb43644e92d3abe50d7ab54ff1b18a" translate="yes" xml:space="preserve">
          <source>event.Event()</source>
          <target state="translated">event.Event()</target>
        </trans-unit>
        <trans-unit id="0cbab9584ecf70e3a63fa4b79c910f43ff6bf420" translate="yes" xml:space="preserve">
          <source>event.EventType</source>
          <target state="translated">event.EventType</target>
        </trans-unit>
        <trans-unit id="2068050b35651cdc694d23b4d95d67de31b7874a" translate="yes" xml:space="preserve">
          <source>event.EventType.__dict__</source>
          <target state="translated">event.EventType.__dict__</target>
        </trans-unit>
        <trans-unit id="2c6eb06156a6a96754cb84ef33e7af735c1ab4cd" translate="yes" xml:space="preserve">
          <source>event.EventType.type</source>
          <target state="translated">event.EventType.type</target>
        </trans-unit>
        <trans-unit id="5016693bd5d916420a19367294f8a29902576360" translate="yes" xml:space="preserve">
          <source>event.clear()</source>
          <target state="translated">event.clear()</target>
        </trans-unit>
        <trans-unit id="ae3167631bd7b46b90262a7bd47db63d41dffa8c" translate="yes" xml:space="preserve">
          <source>event.custom_type()</source>
          <target state="translated">event.custom_type()</target>
        </trans-unit>
        <trans-unit id="4900f5b239f294564abbde168e8c2411e86d9df2" translate="yes" xml:space="preserve">
          <source>event.event_name()</source>
          <target state="translated">event.event_name()</target>
        </trans-unit>
        <trans-unit id="77b36cdfdf41b387af63e39ecde24722bed3eb81" translate="yes" xml:space="preserve">
          <source>event.get()</source>
          <target state="translated">event.get()</target>
        </trans-unit>
        <trans-unit id="487dea6c284b36fdba4cb4e245f4b0330f76afe4" translate="yes" xml:space="preserve">
          <source>event.get_blocked()</source>
          <target state="translated">event.get_blocked()</target>
        </trans-unit>
        <trans-unit id="e668129b9b38847f2fb66fde5109d0d117ada478" translate="yes" xml:space="preserve">
          <source>event.get_grab()</source>
          <target state="translated">event.get_grab()</target>
        </trans-unit>
        <trans-unit id="541f866ed9f9a4c964f3160129aef0316eb308cc" translate="yes" xml:space="preserve">
          <source>event.peek()</source>
          <target state="translated">event.peek()</target>
        </trans-unit>
        <trans-unit id="954f692e1a791e0db3436874f0b4a93876ff4636" translate="yes" xml:space="preserve">
          <source>event.poll()</source>
          <target state="translated">event.poll()</target>
        </trans-unit>
        <trans-unit id="b4da3f8e564fa70b1b75a2139dd496a4168b6fbc" translate="yes" xml:space="preserve">
          <source>event.post()</source>
          <target state="translated">event.post()</target>
        </trans-unit>
        <trans-unit id="d5e489f99f16d6a09cf2fd4b671775397097431f" translate="yes" xml:space="preserve">
          <source>event.pump()</source>
          <target state="translated">event.pump()</target>
        </trans-unit>
        <trans-unit id="c4bcb3ec1393b09960de6cef12f7344b9dcdfb53" translate="yes" xml:space="preserve">
          <source>event.set_allowed()</source>
          <target state="translated">event.set_allowed()</target>
        </trans-unit>
        <trans-unit id="d93fcf562ec4fa98e024650cfb615872ec98b2c8" translate="yes" xml:space="preserve">
          <source>event.set_blocked()</source>
          <target state="translated">event.set_blocked()</target>
        </trans-unit>
        <trans-unit id="90c8c472a51d2253be2f8791cc9a4ca5fa7214df" translate="yes" xml:space="preserve">
          <source>event.set_grab()</source>
          <target state="translated">event.set_grab()</target>
        </trans-unit>
        <trans-unit id="00416324ccbaf39d6b0ff26755c23b1b3f81184c" translate="yes" xml:space="preserve">
          <source>event.wait()</source>
          <target state="translated">event.wait()</target>
        </trans-unit>
        <trans-unit id="b58d80edf0d9a5f19d17ce43b0b4205bab0262a4" translate="yes" xml:space="preserve">
          <source>example:</source>
          <target state="translated">example:</target>
        </trans-unit>
        <trans-unit id="99345ce680cd3e48acdb9ab4212e4bd9bf9358b7" translate="yes" xml:space="preserve">
          <source>examples</source>
          <target state="translated">examples</target>
        </trans-unit>
        <trans-unit id="de6970982c7c840dde3a23891494413a35f56d9c" translate="yes" xml:space="preserve">
          <source>examples as a package is new to pygame 1.9.0. But most of the examples came with pygame much earlier.</source>
          <target state="translated">패키지로서의 예제는 pygame 1.9.0의 새로운 기능입니다. 그러나 대부분의 예제는 파이 게임과 훨씬 일찍 제공되었습니다.</target>
        </trans-unit>
        <trans-unit id="948050a9307099c9061acc7f05fc5deba7109ef2" translate="yes" xml:space="preserve">
          <source>examples.aliens.main()</source>
          <target state="translated">examples.aliens.main()</target>
        </trans-unit>
        <trans-unit id="68abfa18aa7bbf9b9d44444acc718b3ce25498c3" translate="yes" xml:space="preserve">
          <source>examples.arraydemo.main()</source>
          <target state="translated">examples.arraydemo.main()</target>
        </trans-unit>
        <trans-unit id="441e9f75cd3f181fb9742062316ec88740c61c39" translate="yes" xml:space="preserve">
          <source>examples.blend_fill.main()</source>
          <target state="translated">examples.blend_fill.main()</target>
        </trans-unit>
        <trans-unit id="673ba43322e8292c6ae14c4a7ed7cd3e4cd79895" translate="yes" xml:space="preserve">
          <source>examples.blit_blends.main()</source>
          <target state="translated">examples.blit_blends.main()</target>
        </trans-unit>
        <trans-unit id="576fd5e6a87594782af2a1c70dc69b7c7b69330c" translate="yes" xml:space="preserve">
          <source>examples.camera.main()</source>
          <target state="translated">examples.camera.main()</target>
        </trans-unit>
        <trans-unit id="cd392f55292265a2198ca45e9a67f26cf4e6d129" translate="yes" xml:space="preserve">
          <source>examples.chimp.main()</source>
          <target state="translated">examples.chimp.main()</target>
        </trans-unit>
        <trans-unit id="a679311be23618083bffd31886a2bd85720613b4" translate="yes" xml:space="preserve">
          <source>examples.cursors.main()</source>
          <target state="translated">examples.cursors.main()</target>
        </trans-unit>
        <trans-unit id="0109f18e17c849d428f6401fcf8ed6e4f923d3d2" translate="yes" xml:space="preserve">
          <source>examples.eventlist.main()</source>
          <target state="translated">examples.eventlist.main()</target>
        </trans-unit>
        <trans-unit id="619deb24c3abb5fb49ca14cd30211d5b6d4b9f83" translate="yes" xml:space="preserve">
          <source>examples.fastevents.main()</source>
          <target state="translated">examples.fastevents.main()</target>
        </trans-unit>
        <trans-unit id="70d53dc2c1419b16254343a2b7ff9977e6b031f6" translate="yes" xml:space="preserve">
          <source>examples.fonty.main()</source>
          <target state="translated">examples.fonty.main()</target>
        </trans-unit>
        <trans-unit id="aafc5ef81c6215d5645162feaf99a8a5331188c6" translate="yes" xml:space="preserve">
          <source>examples.freetype_misc.main()</source>
          <target state="translated">examples.freetype_misc.main()</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
