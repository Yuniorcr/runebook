<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="jest">
    <body>
      <group id="jest">
        <trans-unit id="25a40503253892e6560d8d5c69a4720093cc2ba6" translate="yes" xml:space="preserve">
          <source>More information on how snapshot testing works and why we built it can be found on the &lt;a href=&quot;https://jestjs.io/blog/2016/07/27/jest-14.html&quot;&gt;release blog post&lt;/a&gt;. We recommend reading &lt;a href=&quot;http://benmccormick.org/2016/09/19/testing-with-jest-snapshots-first-impressions/&quot;&gt;this blog post&lt;/a&gt; to get a good sense of when you should use snapshot testing. We also recommend watching this &lt;a href=&quot;https://egghead.io/lessons/javascript-use-jest-s-snapshot-testing-feature?pl=testing-javascript-with-jest-a36c4074&quot;&gt;egghead video&lt;/a&gt; on Snapshot Testing with Jest.</source>
          <target state="translated">스냅 샷 테스트의 작동 방식과 구축 이유에 대한 자세한 내용은 &lt;a href=&quot;https://jestjs.io/blog/2016/07/27/jest-14.html&quot;&gt;릴리스 블로그 게시물&lt;/a&gt; 에서 확인할 수 있습니다 . 스냅 샷 테스트를 언제 사용해야하는지 잘 이해하려면 &lt;a href=&quot;http://benmccormick.org/2016/09/19/testing-with-jest-snapshots-first-impressions/&quot;&gt;이 블로그 게시물&lt;/a&gt; 을 읽는 것이 좋습니다 . 또한 Jest의 Snapshot Testing 에서이 &lt;a href=&quot;https://egghead.io/lessons/javascript-use-jest-s-snapshot-testing-feature?pl=testing-javascript-with-jest-a36c4074&quot;&gt;에그 헤드 비디오&lt;/a&gt; 를 시청하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="5f58721cb66c8644aaf7f808a07bb173fa203cd2" translate="yes" xml:space="preserve">
          <source>Most commonly this is being caused by conflicting Promise implementations. Consider replacing the global promise implementation with your own, for example &lt;code&gt;global.Promise = jest.requireActual('promise');&lt;/code&gt; and/or consolidate the used Promise libraries to a single one.</source>
          <target state="translated">가장 일반적으로 충돌하는 Promise 구현으로 인해 발생합니다. 글로벌 약속 구현을 자신의 것으로 대체하십시오 &lt;code&gt;global.Promise = jest.requireActual('promise');&lt;/code&gt; 예 : global.Promise = jest.requireActual ( 'promise'); 사용 된 Promise 라이브러리를 단일 라이브러리로 통합합니다.</target>
        </trans-unit>
        <trans-unit id="d5fa9ec15923cf5a4447d89705061f4895a3a460" translate="yes" xml:space="preserve">
          <source>Most likely your glob patterns are not matching any files. Refer to the &lt;a href=&quot;https://github.com/jonschlinkert/micromatch&quot;&gt;micromatch&lt;/a&gt; documentation to ensure your globs are compatible.</source>
          <target state="translated">글로브 패턴이 파일과 일치하지 않을 가능성이 높습니다. 글로브가 호환되는지 확인 하려면 &lt;a href=&quot;https://github.com/jonschlinkert/micromatch&quot;&gt;마이크로 매치&lt;/a&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b70aff9a2e6d1a508cc94211f970a06aadb07a7f" translate="yes" xml:space="preserve">
          <source>Most real-world examples actually involve getting ahold of a mock function on a dependent component and configuring that, but the technique is the same. In these cases, try to avoid the temptation to implement logic inside of any function that's not directly being tested.</source>
          <target state="translated">대부분의 실제 예는 실제로 종속 구성 요소에서 모의 ​​함수를 잡고 구성하는 것과 관련이 있지만 기술은 동일합니다. 이 경우 직접 테스트되지 않은 함수 내부에서 논리를 구현하려는 유혹을 피하십시오.</target>
        </trans-unit>
        <trans-unit id="1743857a25bf614f38c27b820f8398e3eb15e127" translate="yes" xml:space="preserve">
          <source>Most ways of comparing numbers have matcher equivalents.</source>
          <target state="translated">숫자를 비교하는 대부분의 방법에는 일치하는 것이 있습니다.</target>
        </trans-unit>
        <trans-unit id="07d9d7323ef86fe85fd1d7687235aac297bdcdee" translate="yes" xml:space="preserve">
          <source>Next, let's configure Jest to gracefully handle asset files such as stylesheets and images. Usually, these files aren't particularly useful in tests so we can safely mock them out. However, if you are using CSS Modules then it's better to mock a proxy for your className lookups.</source>
          <target state="translated">다음으로 스타일 시트 및 이미지와 같은 자산 파일을 정상적으로 처리하도록 Jest를 구성하겠습니다. 일반적으로 이러한 파일은 테스트에 특히 유용하지 않으므로 안전하게 조롱 할 수 있습니다. 그러나 CSS 모듈을 사용하는 경우 className 조회를 위해 프록시를 조롱하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="0cd213a32f05bcc17b41830bc252640d32af3383" translate="yes" xml:space="preserve">
          <source>No default</source>
          <target state="translated">기본값 없음</target>
        </trans-unit>
        <trans-unit id="069541cf8be1f0d43b5c179ab178c1af971111c3" translate="yes" xml:space="preserve">
          <source>No, as of Jest 20, snapshots in Jest are not automatically written when Jest is run in a CI system without explicitly passing &lt;code&gt;--updateSnapshot&lt;/code&gt;. It is expected that all snapshots are part of the code that is run on CI and since new snapshots automatically pass, they should not pass a test run on a CI system. It is recommended to always commit all snapshots and to keep them in version control.</source>
          <target state="translated">아니요, Jest 20부터 Jest가 &lt;code&gt;--updateSnapshot&lt;/code&gt; 을 명시 적으로 전달하지 않고 CI 시스템에서 실행될 때 Jest의 스냅 샷이 자동으로 작성되지 않습니다 . 모든 스냅 샷은 CI에서 실행되는 코드의 일부일 것으로 예상되며 새 스냅 샷은 자동으로 전달되므로 CI 시스템에서 테스트 실행을 통과해서는 안됩니다. 항상 모든 스냅 샷을 커밋하고 버전 관리를 유지하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="2c8a846eddb8681ebf180cd4b3a87cddb1fe5a15" translate="yes" xml:space="preserve">
          <source>None of these forms is particularly superior to the others, and you can mix and match them across a codebase or even in a single file. It just depends on which style you feel makes your tests simpler.</source>
          <target state="translated">이러한 형식 중 어느 것도 특히 다른 형식보다 우수하지 않으며 코드베이스 또는 단일 파일에서 혼합하여 사용할 수 있습니다. 그것은 당신이 느끼는 스타일에 따라 테스트가 더 간단 해집니다.</target>
        </trans-unit>
        <trans-unit id="593dc274bf37fc96d1260b84eb4792e03219586d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;column&lt;/code&gt; is 0-indexed while &lt;code&gt;line&lt;/code&gt; is not.</source>
          <target state="translated">참고 &lt;code&gt;column&lt;/code&gt; 동안 0 인덱스입니다 &lt;code&gt;line&lt;/code&gt; 없습니다.</target>
        </trans-unit>
        <trans-unit id="7fbb94ab3f435207f3668ea824069ffb13ba8524" translate="yes" xml:space="preserve">
          <source>Note that the mock can't be an arrow function because calling &lt;code&gt;new&lt;/code&gt; on an arrow function is not allowed in JavaScript. So this won't work:</source>
          <target state="translated">JavaScript에서는 화살표 함수에서 &lt;code&gt;new&lt;/code&gt; 를 호출 할 수 없으므로 mock은 화살표 함수가 될 수 없습니다 . 그래서 이것은 작동하지 않습니다 :</target>
        </trans-unit>
        <trans-unit id="35e09d6f70cb52a597a44fb09de97ecc2bafcf55" translate="yes" xml:space="preserve">
          <source>Note that the top-level &lt;code&gt;beforeEach&lt;/code&gt; is executed before the &lt;code&gt;beforeEach&lt;/code&gt; inside the &lt;code&gt;describe&lt;/code&gt; block. It may help to illustrate the order of execution of all hooks.</source>
          <target state="translated">최상위 레벨 &lt;code&gt;beforeEach&lt;/code&gt; 는 &lt;code&gt;describe&lt;/code&gt; 블록 내에서 &lt;code&gt;beforeEach&lt;/code&gt; 이전에 실행 됩니다. 모든 후크의 실행 순서를 설명하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dab00f8f32e989ec35b0b0ca3de5a6325b1623eb" translate="yes" xml:space="preserve">
          <source>Note that using &lt;code&gt;v8&lt;/code&gt; is considered experimental. This uses V8's builtin code coverage rather than one based on Babel. It is not as well tested, and it has also improved in the last few releases of Node. Using the latest versions of node (v14 at the time of this writing) will yield better results.</source>
          <target state="translated">&lt;code&gt;v8&lt;/code&gt; 을 사용하는 것은 실험적인 것으로 간주됩니다. 이것은 Babel을 기반으로하는 것이 아니라 V8의 내장 코드 커버리지를 사용합니다. 잘 테스트되지 않았으며 Node.js의 마지막 몇 릴리스에서도 개선되었습니다. 최신 버전의 노드 (이 글 작성 당시 v14)를 사용하면 더 나은 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5317a3a7e7d23a56315a8874c449817c31ad8a0c" translate="yes" xml:space="preserve">
          <source>Note that, if you specify a global reference value (like an object or array) here, and some code mutates that value in the midst of running a test, that mutation will &lt;em&gt;not&lt;/em&gt; be persisted across test runs for other test files. In addition the &lt;code&gt;globals&lt;/code&gt; object must be json-serializable, so it can't be used to specify global functions. For that you should use &lt;code&gt;setupFiles&lt;/code&gt;.</source>
          <target state="translated">여기에 객체 또는 배열과 같은 전역 참조 값을 지정하고 일부 코드가 테스트를 실행하는 동안 해당 값을 변경하면 해당 테스트는 다른 테스트 파일에 대한 테스트 실행 동안 유지 &lt;em&gt;되지 않습니다&lt;/em&gt; . 또한 &lt;code&gt;globals&lt;/code&gt; 객체는 json 직렬화 가능해야하므로 전역 함수를 지정하는 데 사용할 수 없습니다. 이를 위해서는 &lt;code&gt;setupFiles&lt;/code&gt; 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2b104c13194e34da09ed53bf72fc268a0c3110ad" translate="yes" xml:space="preserve">
          <source>Note that, if you specify a global reference value (like an object or array) here, and some code mutates that value in the midst of running a test, that mutation will &lt;em&gt;not&lt;/em&gt; be persisted across test runs for other test files. In addition, the &lt;code&gt;globals&lt;/code&gt; object must be json-serializable, so it can't be used to specify global functions. For that, you should use &lt;code&gt;setupFiles&lt;/code&gt;.</source>
          <target state="translated">여기에서 전역 참조 값 (예 : 객체 또는 배열)을 지정하고 일부 코드가 테스트를 실행하는 동안 해당 값을 변경하는 경우 해당 변경 은 다른 테스트 파일에 대한 테스트 실행 동안 지속 &lt;em&gt;되지 않습니다&lt;/em&gt; . 또한 &lt;code&gt;globals&lt;/code&gt; 객체는 json-serializable이어야하므로 전역 함수를 지정하는 데 사용할 수 없습니다. 이를 위해서는 &lt;code&gt;setupFiles&lt;/code&gt; 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="edc786612e42a25f8f3750696a48a69840f36cd3" translate="yes" xml:space="preserve">
          <source>Note that, since you are still testing promises, the test is still asynchronous. Hence, you will need to &lt;a href=&quot;asynchronous#promises&quot;&gt;tell Jest to wait&lt;/a&gt; by returning the unwrapped assertion.</source>
          <target state="translated">약속을 테스트하고 있기 때문에 테스트는 여전히 비동기 적입니다. 따라서 래핑되지 않은 어설 션을 반환하여 &lt;a href=&quot;asynchronous#promises&quot;&gt;Jest에게 기다리도록 지시&lt;/a&gt; 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9794622b767437b0ecae517257f9db04f7adf32d" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; is a special token that gets replaced by Jest with the root of your project. Most of the time this will be the folder where your &lt;code&gt;package.json&lt;/code&gt; is located unless you specify a custom &lt;code&gt;rootDir&lt;/code&gt; option in your configuration.</source>
          <target state="translated">참고 : &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; 은 프로젝트의 루트로 Jest로 대체되는 특수 토큰입니다. 구성에 사용자 정의 &lt;code&gt;rootDir&lt;/code&gt; 옵션 을 지정하지 않으면 대부분의 경우 &lt;code&gt;package.json&lt;/code&gt; 이 있는 폴더가 됩니다.</target>
        </trans-unit>
        <trans-unit id="628dafac3ccff711682a19552f96e64d7e9e0c0e" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;.toEqual&lt;/code&gt; won't perform a &lt;em&gt;deep equality&lt;/em&gt; check for two errors. Only the &lt;code&gt;message&lt;/code&gt; property of an Error is considered for equality. It is recommended to use the &lt;code&gt;.toThrow&lt;/code&gt; matcher for testing against errors.</source>
          <target state="translated">참고 : &lt;code&gt;.toEqual&lt;/code&gt; 은 두 가지 오류에 대해 &lt;em&gt;심도 평등&lt;/em&gt; 검사를 수행하지 않습니다 . Error 의 &lt;code&gt;message&lt;/code&gt; 속성 만 동일한 것으로 간주됩니다. 오류 테스트를 위해 &lt;code&gt;.toThrow&lt;/code&gt; 매처 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="7613acf3a264c0259c7e5490495960bb2558a069" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;babel-jest&lt;/code&gt; is automatically installed when installing Jest and will automatically transform files if a babel configuration exists in your project. To avoid this behavior, you can explicitly reset the &lt;code&gt;transform&lt;/code&gt; configuration option:</source>
          <target state="translated">참고 : &lt;code&gt;babel-jest&lt;/code&gt; 는 Jest를 설치할 때 자동으로 설치되며 프로젝트에 babel 구성이있는 경우 파일을 자동으로 변환합니다. 이 동작을 피하기 위해 &lt;code&gt;transform&lt;/code&gt; 구성 옵션을 명시 적으로 재설정 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d063b0b7dc564c8180bc1b9d7afb5ca825c92c4b" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;test.concurrent&lt;/code&gt; is considered experimental - see &lt;a href=&quot;https://github.com/facebook/jest/labels/Area%3A%20Concurrent&quot;&gt;here&lt;/a&gt; for details on missing features and other issues</source>
          <target state="translated">참고 : &lt;code&gt;test.concurrent&lt;/code&gt; 는 실험적인 것으로 간주 됩니다. 누락 된 기능 및 기타 문제에 대한 자세한 내용 은 &lt;a href=&quot;https://github.com/facebook/jest/labels/Area%3A%20Concurrent&quot;&gt;여기&lt;/a&gt; 를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="a1bf41dd30024dc8f6a9cf73cdb3281441a7c127" translate="yes" xml:space="preserve">
          <source>Note: For more complex webpack configurations, you may also want to investigate projects such as: &lt;a href=&quot;https://github.com/istarkov/babel-plugin-webpack-loaders&quot;&gt;babel-plugin-webpack-loaders&lt;/a&gt;.</source>
          <target state="translated">참고 :보다 복잡한 웹팩 구성의 경우 &lt;a href=&quot;https://github.com/istarkov/babel-plugin-webpack-loaders&quot;&gt;babel-plugin-webpack-loaders&lt;/a&gt; 와 같은 프로젝트를 조사 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e5ee4f891332fe29d99fc8b7113be07b4978e5d9" translate="yes" xml:space="preserve">
          <source>Note: If a &lt;strong&gt;promise is returned&lt;/strong&gt; from &lt;code&gt;test&lt;/code&gt;, Jest will wait for the promise to resolve before letting the test complete. Jest will also wait if you &lt;strong&gt;provide an argument to the test function&lt;/strong&gt;, usually called &lt;code&gt;done&lt;/code&gt;. This could be handy when you want to test callbacks. See how to test async code &lt;a href=&quot;asynchronous#callbacks&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">참고 : &lt;code&gt;test&lt;/code&gt; 에서 &lt;strong&gt;약속이 반환&lt;/strong&gt; 되면 Jest는 테스트가 완료되기 전에 약속이 해결 될 때까지 기다립니다. Jest는 일반적으로 &lt;code&gt;done&lt;/code&gt; 이라고 &lt;strong&gt;하는 테스트 함수에 인수를 제공하면&lt;/strong&gt; 대기합니다 . 콜백을 테스트 할 때 유용 할 수 있습니다. &lt;a href=&quot;asynchronous#callbacks&quot;&gt;여기에서&lt;/a&gt; 비동기 코드를 테스트하는 방법을 참조 하십시오 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f2c9e685037a098f7ab5cab7e553edaf0c09711f" translate="yes" xml:space="preserve">
          <source>Note: In order to mock properly, Jest needs &lt;code&gt;jest.mock('moduleName')&lt;/code&gt; to be in the same scope as the &lt;code&gt;require/import&lt;/code&gt; statement.</source>
          <target state="translated">참고 : Jest가 제대로 조롱하려면 &lt;code&gt;jest.mock('moduleName')&lt;/code&gt; 이 &lt;code&gt;require/import&lt;/code&gt; 문과 같은 범위에 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="9fc7ec9481edc4a64cc4cee9fd0a5b4e7d421cf5" translate="yes" xml:space="preserve">
          <source>Note: Jest caches files to speed up test execution. If you updated .babelrc and Jest is still not working, try running Jest with &lt;code&gt;--no-cache&lt;/code&gt;.</source>
          <target state="translated">참고 : Jest는 파일을 캐시하여 테스트 실행 속도를 높입니다. .babelrc를 업데이트했는데 Jest가 여전히 작동하지 않으면 &lt;code&gt;--no-cache&lt;/code&gt; 로 Jest를 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="18499d47a5d29c4202e6b0823b51b2cc1f3a7091" translate="yes" xml:space="preserve">
          <source>Note: Jest documentation uses &lt;code&gt;yarn&lt;/code&gt; commands, but &lt;code&gt;npm&lt;/code&gt; will also work. You can compare &lt;code&gt;yarn&lt;/code&gt; and &lt;code&gt;npm&lt;/code&gt; commands in the &lt;a href=&quot;https://yarnpkg.com/en/docs/migrating-from-npm#toc-cli-commands-comparison&quot;&gt;yarn docs, here&lt;/a&gt;.</source>
          <target state="translated">참고 : Jest 문서는 &lt;code&gt;yarn&lt;/code&gt; 명령을 사용 하지만 &lt;code&gt;npm&lt;/code&gt; 도 작동합니다. &lt;a href=&quot;https://yarnpkg.com/en/docs/migrating-from-npm#toc-cli-commands-comparison&quot;&gt;얀 문서&lt;/a&gt; 에서 &lt;code&gt;yarn&lt;/code&gt; 및 &lt;code&gt;npm&lt;/code&gt; 명령을 비교할 수 있습니다 ( 여기) .</target>
        </trans-unit>
        <trans-unit id="5cff4d7445c3ba40f87a1439f00a6eba64d370e9" translate="yes" xml:space="preserve">
          <source>Note: The snapshot is directly scoped to the data you render &amp;ndash; in our example it's &lt;code&gt;&amp;lt;Link /&amp;gt;&lt;/code&gt; component with page prop passed to it. This implies that even if any other file has missing props (Say, &lt;code&gt;App.js&lt;/code&gt;) in the &lt;code&gt;&amp;lt;Link /&amp;gt;&lt;/code&gt; component, it will still pass the test as the test doesn't know the usage of &lt;code&gt;&amp;lt;Link /&amp;gt;&lt;/code&gt; component and it's scoped only to the &lt;code&gt;Link.react.js&lt;/code&gt;. Also, Rendering the same component with different props in other snapshot tests will not affect the first one, as the tests don't know about each other.</source>
          <target state="translated">참고 : 스냅 샷은 렌더링하는 데이터에 직접 범위가 지정됩니다.이 예에서는 페이지 소품이 전달 된 &lt;code&gt;&amp;lt;Link /&amp;gt;&lt;/code&gt; 구성 요소입니다. 이것은 다른 파일 에 &lt;code&gt;&amp;lt;Link /&amp;gt;&lt;/code&gt; 구성 요소에 소품 (Say, &lt;code&gt;App.js&lt;/code&gt; ) 이 누락 되어도 테스트에서 &lt;code&gt;&amp;lt;Link /&amp;gt;&lt;/code&gt; 구성 요소 의 사용법을 알지 못하고 범위가 지정되어 있기 때문에 테스트를 통과한다는 것을 의미합니다 &lt;code&gt;Link.react.js&lt;/code&gt; 에만 있습니다. 또한 다른 스냅 샷 테스트에서 다른 소품으로 동일한 구성 요소를 렌더링하면 테스트가 서로를 알지 못하므로 첫 번째 구성 요소에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6496fae13ef766903ec9c79181224c2df30885e8" translate="yes" xml:space="preserve">
          <source>Note: The snapshot is directly scoped to the data you render &amp;ndash; in our example the &lt;code&gt;&amp;lt;Link /&amp;gt;&lt;/code&gt; component with &lt;code&gt;page&lt;/code&gt; prop passed to it. This implies that even if any other file has missing props (Say, &lt;code&gt;App.js&lt;/code&gt;) in the &lt;code&gt;&amp;lt;Link /&amp;gt;&lt;/code&gt; component, it will still pass the test as the test doesn't know the usage of &lt;code&gt;&amp;lt;Link /&amp;gt;&lt;/code&gt; component and it's scoped only to the &lt;code&gt;Link.react.js&lt;/code&gt;. Also, Rendering the same component with different props in other snapshot tests will not affect the first one, as the tests don't know about each other.</source>
          <target state="translated">참고 : 스냅 샷은 렌더링하는 데이터로 직접 범위가 지정됩니다.이 예에서는 &lt;code&gt;page&lt;/code&gt; 소품이 전달 된 &lt;code&gt;&amp;lt;Link /&amp;gt;&lt;/code&gt; 구성 요소입니다 . 이는 다른 파일이 &lt;code&gt;&amp;lt;Link /&amp;gt;&lt;/code&gt; 구성 요소에 누락 된 소품 (Say, &lt;code&gt;App.js&lt;/code&gt; ) 이 있어도 테스트가 &lt;code&gt;&amp;lt;Link /&amp;gt;&lt;/code&gt; 구성 요소 의 사용법을 모르고 범위가 지정되어 있기 때문에 여전히 테스트를 통과 함을 의미합니다. &lt;code&gt;Link.react.js&lt;/code&gt; 에만 해당됩니다 . 또한 다른 스냅 샷 테스트에서 서로 다른 소품으로 동일한 구성 요소를 렌더링하는 것은 테스트가 서로에 대해 알지 못하기 때문에 첫 번째 테스트에 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="866607a189359968f5ff8b001676f89035486e7b" translate="yes" xml:space="preserve">
          <source>Note: This function is not available when using modern fake timers implementation</source>
          <target state="translated">참고 :이 기능은 최신 가짜 타이머 구현을 사용할 때는 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d58fe2211cffb9e77307ff7a8d198bd500bab696" translate="yes" xml:space="preserve">
          <source>Note: This function is only available when using modern fake timers implementation</source>
          <target state="translated">참고 :이 기능은 최신 가짜 타이머 구현을 사용할 때만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a20c17aceb39b181c11f8ff4c0ad0c423d32862" translate="yes" xml:space="preserve">
          <source>Note: Use &lt;code&gt;maxConcurrency&lt;/code&gt; in configuration to prevents Jest from executing more than the specified amount of tests at the same time</source>
          <target state="translated">참고 : 구성에서 &lt;code&gt;maxConcurrency&lt;/code&gt; 를 사용하여 Jest가 지정된 양 이상의 테스트를 동시에 실행하지 못하도록합니다.</target>
        </trans-unit>
        <trans-unit id="d9f87616f2342dfb53f7c81b06d94dec773c92c7" translate="yes" xml:space="preserve">
          <source>Note: You must wrap the code in a function, otherwise the error will not be caught and the assertion will fail.</source>
          <target state="translated">참고 : 함수에서 코드를 래핑해야합니다. 그렇지 않으면 오류가 발생하지 않고 어설 션이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="6eb20dc9b8a75cec38d02e8f54a09a224da2b36c" translate="yes" xml:space="preserve">
          <source>Note: the &lt;code&gt;--runInBand&lt;/code&gt; cli option makes sure Jest runs test in the same process rather than spawning processes for individual tests. Normally Jest parallelizes test runs across processes but it is hard to debug many processes at the same time.</source>
          <target state="translated">참고 : &lt;code&gt;--runInBand&lt;/code&gt; cli 옵션은 Jest가 개별 테스트를위한 프로세스를 생성하지 않고 동일한 프로세스에서 테스트를 실행하도록합니다. 일반적으로 Jest는 여러 프로세스에서 테스트 실행을 병렬화하지만 많은 프로세스를 동시에 디버깅하기는 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="96194ed3517159111cf9532affab238e70f5eef6" translate="yes" xml:space="preserve">
          <source>Note: the &lt;code&gt;--runInBand&lt;/code&gt; cli option makes sure Jest runs the test in the same process rather than spawning processes for individual tests. Normally Jest parallelizes test runs across processes but it is hard to debug many processes at the same time.</source>
          <target state="translated">참고 : &lt;code&gt;--runInBand&lt;/code&gt; cli 옵션은 Jest가 개별 테스트에 대한 프로세스를 생성하는 대신 동일한 프로세스에서 테스트를 실행하도록합니다. 일반적으로 Jest는 여러 프로세스에서 테스트 실행을 병렬화하지만 동시에 많은 프로세스를 디버깅하기는 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="4023ed8bfb6fa137e2322c83d2fb6a7bdccaa7cc" translate="yes" xml:space="preserve">
          <source>Note: the defaultResolver passed as an option is the Jest default resolver which might be useful when you write your custom one. It takes the same arguments as your custom one, e.g. &lt;code&gt;(request, options)&lt;/code&gt;.</source>
          <target state="translated">참고 : 옵션으로 전달 된 defaultResolver는 사용자 정의를 작성할 때 유용 할 수있는 Jest 기본 해결 프로그램입니다. 사용자 정의 인수와 동일한 인수를 사용합니다 &lt;code&gt;(request, options)&lt;/code&gt; 예 : (request, options)) .</target>
        </trans-unit>
        <trans-unit id="84a5108cffe44c788bf001c5788a68bdfb2e0028" translate="yes" xml:space="preserve">
          <source>Note: the defaultResolver passed as options is the jest default resolver which might be useful when you write your custom one. It takes the same arguments as your custom one, e.g. (request, options).</source>
          <target state="translated">참고 : 옵션으로 전달 된 defaultResolver는 사용자 정의 솔루션을 작성할 때 유용한 jest 기본 리졸버입니다. 예를 들어 (요청, 옵션)과 같은 사용자 지정 인수와 동일한 인수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="08a800e5165f53b98f96928e40e168f030f156c8" translate="yes" xml:space="preserve">
          <source>Note: the function that throws an exception needs to be invoked within a wrapping function otherwise the &lt;code&gt;toThrow&lt;/code&gt; assertion will fail.</source>
          <target state="translated">참고 : 예외를 발생시키는 함수는 래핑 함수 내에서 호출되어야합니다. 그렇지 않으면 &lt;code&gt;toThrow&lt;/code&gt; 어설 션이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="63519bb0bd54e1b894cccdf4f3af7852ef618bb7" translate="yes" xml:space="preserve">
          <source>Note: the nth argument must be positive integer starting from 1.</source>
          <target state="translated">참고 : n 번째 인수는 1부터 시작하는 양의 정수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="dc782aff0e671f43d928b262fb2a1ad60df35d44" translate="yes" xml:space="preserve">
          <source>Notice that Proxy is enabled in Node 6 by default. If you are not on Node 6 yet, make sure you invoke Jest using &lt;code&gt;node --harmony_proxies node_modules/.bin/jest&lt;/code&gt;.</source>
          <target state="translated">프록시는 기본적으로 노드 6에서 활성화되어 있습니다. 아직 Node 6에 있지 않은 경우 &lt;code&gt;node --harmony_proxies node_modules/.bin/jest&lt;/code&gt; 를 사용하여 Jest를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="97d92ee85a42081babf70348e9395eeb01e66cc8" translate="yes" xml:space="preserve">
          <source>Now imagine an implementation of &lt;code&gt;request.js&lt;/code&gt; that goes to the network and fetches some user data:</source>
          <target state="translated">이제 네트워크로 가서 일부 사용자 데이터를 가져 오는 &lt;code&gt;request.js&lt;/code&gt; 의 구현을 상상해보십시오 .</target>
        </trans-unit>
        <trans-unit id="bb60cb13af7d9fd41f600f4cb00d4bff107937d6" translate="yes" xml:space="preserve">
          <source>Now let's use React's test renderer and Jest's snapshot feature to interact with the component and capture the rendered output and create a snapshot file:</source>
          <target state="translated">이제 React의 테스트 렌더러 및 Jest의 스냅 샷 기능을 사용하여 컴포넌트와 상호 작용하고 렌더링 된 출력을 캡처하고 스냅 샷 파일을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="7ce0f103deaf5dc6dbc56bf66214617663420f57" translate="yes" xml:space="preserve">
          <source>Now let's write a test for our async functionality.</source>
          <target state="translated">이제 비동기 기능에 대한 테스트를 작성하겠습니다.</target>
        </trans-unit>
        <trans-unit id="4759fbb62123d73c1226706f0f4d34666a8582b0" translate="yes" xml:space="preserve">
          <source>Now that Jest knows how to process our files, we need to tell it how to &lt;em&gt;find&lt;/em&gt; them. For webpack's &lt;code&gt;modulesDirectories&lt;/code&gt;, and &lt;code&gt;extensions&lt;/code&gt; options there are direct analogs in Jest's &lt;code&gt;moduleDirectories&lt;/code&gt; and &lt;code&gt;moduleFileExtensions&lt;/code&gt; options.</source>
          <target state="translated">Jest는 파일을 처리하는 방법을 알고 있으므로 파일을 &lt;em&gt;찾는&lt;/em&gt; 방법을 알려야 합니다. webpack의 &lt;code&gt;modulesDirectories&lt;/code&gt; 및 &lt;code&gt;extensions&lt;/code&gt; 옵션의 경우 Jest의 &lt;code&gt;moduleDirectories&lt;/code&gt; 및 &lt;code&gt;moduleFileExtensions&lt;/code&gt; 옵션 에 직접 아날로그가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5a5de53298548d7d54ae3ca8e892f7df5aa2243" translate="yes" xml:space="preserve">
          <source>Now we write our test. Note that we need to explicitly tell that we want to mock the &lt;code&gt;fs&lt;/code&gt; module because it&amp;rsquo;s a core Node module:</source>
          <target state="translated">이제 테스트를 작성합니다. 우리는 &lt;code&gt;fs&lt;/code&gt; 모듈이 핵심 노드 모듈이기 때문에 fs 모듈 을 조롱하고 싶다고 명시 적으로 말해야합니다 .</target>
        </trans-unit>
        <trans-unit id="46a5c027241fe1614d4396220914efc2314503e5" translate="yes" xml:space="preserve">
          <source>Now, every time the snapshot test case runs, &lt;code&gt;Date.now()&lt;/code&gt; will return &lt;code&gt;1482363367071&lt;/code&gt; consistently. This will result in the same snapshot being generated for this component regardless of when the test is run.</source>
          <target state="translated">이제 스냅 샷 테스트 사례가 실행될 때마다 &lt;code&gt;Date.now()&lt;/code&gt; 는 &lt;code&gt;1482363367071&lt;/code&gt; 을 일관되게 반환 합니다. 그러면 테스트 실행시기에 관계없이이 구성 요소에 대해 동일한 스냅 샷이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="f5e6490929905f7bc8af5ccef9bf48f8668b1460" translate="yes" xml:space="preserve">
          <source>Now, in order to test this method without actually hitting the API (and thus creating slow and fragile tests), we can use the &lt;code&gt;jest.mock(...)&lt;/code&gt; function to automatically mock the axios module.</source>
          <target state="translated">이제 API에 실제로 &lt;code&gt;jest.mock(...)&lt;/code&gt; 방법을 테스트하여 느리고 취약한 테스트를 만들기 위해 jest.mock (...) 함수를 사용하여 자동으로 Axios 모듈을 조롱 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7e53821f70ae16079c4a6a64c52a91fae645bc5f" translate="yes" xml:space="preserve">
          <source>Numbers</source>
          <target state="translated">Numbers</target>
        </trans-unit>
        <trans-unit id="8d3eb6284bfb714ab8ca96c009bf8ad9c4fc7252" translate="yes" xml:space="preserve">
          <source>Object types are checked to be equal. e.g. A class instance with fields &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; will not equal a literal object with fields &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">객체 유형이 같은지 확인합니다. 필드 예 클래스 인스턴스 및 &lt;code&gt;b&lt;/code&gt; 필드 오브젝트 리터럴 동일하지 않을 및 &lt;code&gt;b&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f2176a8ab6b1e30ac16f60c568568a437d540248" translate="yes" xml:space="preserve">
          <source>Often there are fields in the object you want to snapshot which are generated (like IDs and Dates). If you try to snapshot these objects, they will force the snapshot to fail on every run:</source>
          <target state="translated">스냅 샷하려는 객체에 생성되는 필드 (예 : ID 및 날짜)가 종종 있습니다. 이러한 객체의 스냅 샷을 만들려고하면 실행 시마다 스냅 샷이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="6ffecdf0087875891dd611103daecc4d8bcf8763" translate="yes" xml:space="preserve">
          <source>Often this is useful when you want to clean up a mock's usage data between two assertions.</source>
          <target state="translated">두 어설 션간에 모의 사용 데이터를 정리하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="79cd3f6e68b0a9656087292d49bbeda556ae6d96" translate="yes" xml:space="preserve">
          <source>Often while writing tests you have some setup work that needs to happen before tests run, and you have some finishing work that needs to happen after tests run. Jest provides helper functions to handle this.</source>
          <target state="translated">종종 테스트를 작성하는 동안 테스트를 실행하기 전에 수행해야하는 설정 작업이 있고 테스트를 실행 한 후에 수행해야하는 마무리 작업이 있습니다. Jest는이를 처리하는 도우미 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4f3d546a97573ddf0fe581d729e6b000ed006545" translate="yes" xml:space="preserve">
          <source>Oftentimes, you'll want to set this to &lt;code&gt;'src'&lt;/code&gt; or &lt;code&gt;'lib'&lt;/code&gt;, corresponding to where in your repository the code is stored.</source>
          <target state="translated">종종 저장소에서 코드가 저장된 위치에 해당하는 &lt;code&gt;'src'&lt;/code&gt; 또는 &lt;code&gt;'lib'&lt;/code&gt; 로 설정하려고 할 것 입니다.</target>
        </trans-unit>
        <trans-unit id="c12f3f3ee865af90cac56dabeb84091b38861136" translate="yes" xml:space="preserve">
          <source>On occasion there are times where the automatically generated mock the module system would normally provide you isn't adequate enough for your testing needs. Normally under those circumstances you should write a &lt;a href=&quot;manual-mocks&quot;&gt;manual mock&lt;/a&gt; that is more adequate for the module in question. However, on extremely rare occasions, even a manual mock isn't suitable for your purposes and you need to build the mock yourself inside your test.</source>
          <target state="translated">때로는 자동으로 생성 된 모의 모듈 시스템이 테스트 요구에 적합하지 않은 경우가 있습니다. 일반적으로 이러한 상황에서는 해당 모듈에 더 적합한 &lt;a href=&quot;manual-mocks&quot;&gt;수동 모형&lt;/a&gt; 을 작성해야합니다 . 그러나 매우 드문 경우이지만 수동 모의조차도 귀하의 목적에 적합하지 않으며 테스트 내부에 모의를 구축해야합니다.</target>
        </trans-unit>
        <trans-unit id="ccd4436c2d3d88fb5477ef92425da0b5c05ebca6" translate="yes" xml:space="preserve">
          <source>On occasion, there are times where the automatically generated mock the module system would normally provide you isn't adequate enough for your testing needs. Normally under those circumstances you should write a &lt;a href=&quot;manual-mocks&quot;&gt;manual mock&lt;/a&gt; that is more adequate for the module in question. However, on extremely rare occasions, even a manual mock isn't suitable for your purposes and you need to build the mock yourself inside your test.</source>
          <target state="translated">경우에 따라 자동으로 생성 된 모의 모듈 시스템이 일반적으로 제공하는 테스트 요구 사항에 충분하지 않은 경우가 있습니다. 일반적으로 이러한 상황에서는 해당 모듈에 더 적합한 &lt;a href=&quot;manual-mocks&quot;&gt;수동 모의&lt;/a&gt; 를 작성해야합니다 . 그러나 매우 드문 경우지만 수동 모의도 목적에 적합하지 않으며 테스트 내에서 직접 모의를 빌드해야합니다.</target>
        </trans-unit>
        <trans-unit id="1833be118eff717aa421c7c29043719c42065791" translate="yes" xml:space="preserve">
          <source>Once we mock the module we can provide a &lt;code&gt;mockResolvedValue&lt;/code&gt; for &lt;code&gt;.get&lt;/code&gt; that returns the data we want our test to assert against. In effect, we are saying that we want &lt;code&gt;axios.get('/users.json')&lt;/code&gt; to return a fake response.</source>
          <target state="translated">모듈을 모의하면 테스트에서 주장 할 데이터를 반환하는 &lt;code&gt;.get&lt;/code&gt; 에 대한 &lt;code&gt;mockResolvedValue&lt;/code&gt; 를 제공 할 수 있습니다 . 실제로 우리는 &lt;code&gt;axios.get('/users.json')&lt;/code&gt; 이 가짜 응답을 반환하기를 원한다고 말합니다 .</target>
        </trans-unit>
        <trans-unit id="eef0b229d34fbb64b6540632318f3fdbaa2280e6" translate="yes" xml:space="preserve">
          <source>Once we mock the module we can provide a &lt;code&gt;mockResolvedValue&lt;/code&gt; for &lt;code&gt;.get&lt;/code&gt; that returns the data we want our test to assert against. In effect, we are saying that we want axios.get('/users.json') to return a fake response.</source>
          <target state="translated">모듈을 조롱하면 테스트 할 대상 데이터를 반환하는 &lt;code&gt;.get&lt;/code&gt; 에 대한 &lt;code&gt;mockResolvedValue&lt;/code&gt; 를 제공 할 수 있습니다 . 실제로 axios.get ( '/ users.json')이 가짜 응답을 반환하기를 원한다고 말하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0fd8cdd8b9b5a8885d7339d6a566088a20fe3d5" translate="yes" xml:space="preserve">
          <source>Once you enter Interactive Snapshot Mode, Jest will step you through the failed snapshots one test at a time and give you the opportunity to review the failed output.</source>
          <target state="translated">대화 형 스냅 샷 모드로 들어가면 Jest는 실패한 스냅 샷을 한 번에 하나씩 테스트하여 실패한 출력을 검토 할 수있는 기회를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7ffee35fa0cdfd66f92f9f207350deb369bb338b" translate="yes" xml:space="preserve">
          <source>Once you're finished, Jest will give you a summary before returning back to watch mode:</source>
          <target state="translated">완료되면 Jest가 시계 모드로 돌아 가기 전에 요약 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="04e3f29cab1cd3970d5e34742e1c9209c2a454b6" translate="yes" xml:space="preserve">
          <source>Once you've learned about the matchers that are available, a good next step is to check out how Jest lets you &lt;a href=&quot;asynchronous&quot;&gt;test asynchronous code&lt;/a&gt;.</source>
          <target state="translated">사용 가능한 매처에 대해 배운 후에는 Jest에서 &lt;a href=&quot;asynchronous&quot;&gt;비동기 코드&lt;/a&gt; 를 테스트 할 수있는 방법을 확인하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="911829cb001fba297a8440e3959d077dc4ad2675" translate="yes" xml:space="preserve">
          <source>One example when this is useful is when you want to mock a module differently within the same file:</source>
          <target state="translated">이것이 유용한 경우의 예는 동일한 파일 내에서 모듈을 다르게 조롱하려는 경우입니다.</target>
        </trans-unit>
        <trans-unit id="44d433b060d5be5e5cb29585b03e7a39cbe16040" translate="yes" xml:space="preserve">
          <source>One of the files matching the &lt;code&gt;./src/reducers/**/*.js&lt;/code&gt; glob has less than 90% statement coverage.</source>
          <target state="translated">&lt;code&gt;./src/reducers/**/*.js&lt;/code&gt; glob와 일치하는 파일 중 하나의 명령문 적용 범위는 90 % 미만입니다.</target>
        </trans-unit>
        <trans-unit id="33de0273fb385ef534431d972ca028ab9fae9e00" translate="yes" xml:space="preserve">
          <source>One or more subsequent rows of data supplied as template literal expressions using &lt;code&gt;${value}&lt;/code&gt; syntax.</source>
          <target state="translated">&lt;code&gt;${value}&lt;/code&gt; 구문을 사용하여 템플리트 리터럴 표현식으로 제공된 하나 이상의 후속 데이터 행 .</target>
        </trans-unit>
        <trans-unit id="cfce43d345326fcdf5172027f076645beb3b6bbb" translate="yes" xml:space="preserve">
          <source>One such situation can arise if we intentionally change the address the Link component in our example is pointing to.</source>
          <target state="translated">예제에서 링크 구성 요소가 가리키는 주소를 의도적으로 변경하면 이러한 상황이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c3971f2be369ec67c710b4572f1ea126ad557a5" translate="yes" xml:space="preserve">
          <source>One-Time Setup</source>
          <target state="translated">일회성 설정</target>
        </trans-unit>
        <trans-unit id="883b26a66c75d25a769cffa672f3388d833b2cc4" translate="yes" xml:space="preserve">
          <source>Only the &quot;it is raining&quot; test will run in that test file, since it is run with &lt;code&gt;test.only&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;test.only&lt;/code&gt; 로 실행되므로 &quot;비가 내리고 있습니다&quot;테스트 만 해당 테스트 파일에서 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="00991593a9f4d31e6c4dd6dbb447ea1e1f468c00" translate="yes" xml:space="preserve">
          <source>Only the &quot;it is raining&quot; test will run, since the other test is run with &lt;code&gt;test.skip&lt;/code&gt;.</source>
          <target state="translated">다른 테스트는 &lt;code&gt;test.skip&lt;/code&gt; 으로 실행되므로 &quot;비가 내리고 있습니다&quot;테스트 만 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="749db9a1ae125917392d1a5146e4c6d00c14a9d3" translate="yes" xml:space="preserve">
          <source>Optionally, you can provide &lt;code&gt;steps&lt;/code&gt;, so it will run &lt;code&gt;steps&lt;/code&gt; amount of next timeouts/intervals.</source>
          <target state="translated">선택적으로 &lt;code&gt;steps&lt;/code&gt; 를 제공 할 수 있으므로 다음 시간 초과 / 간격 &lt;code&gt;steps&lt;/code&gt; 를 실행 합니다 .</target>
        </trans-unit>
        <trans-unit id="920bdedd844899cd5664de8cfd74adb5d459a38e" translate="yes" xml:space="preserve">
          <source>Optionally, you can provide a &lt;code&gt;timeout&lt;/code&gt; (in milliseconds) for specifying how long to wait before aborting. &lt;em&gt;Note: The default timeout is 5 seconds.&lt;/em&gt;</source>
          <target state="translated">선택적으로 중단 전에 대기 시간을 지정 하기위한 &lt;code&gt;timeout&lt;/code&gt; (밀리 초)를 제공 할 수 있습니다 . &lt;em&gt;참고 : 기본 시간 제한은 5 초입니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4bf57bdba6d591e8cfd0266e8b8c0a594cbd7d55" translate="yes" xml:space="preserve">
          <source>Optionally, you can provide a &lt;code&gt;timeout&lt;/code&gt; (in milliseconds) for specifying how long to wait for each row before aborting. &lt;em&gt;Note: The default timeout is 5 seconds.&lt;/em&gt;</source>
          <target state="translated">선택적으로 중단하기 전에 각 행을 기다리는 시간을 지정 하기위한 &lt;code&gt;timeout&lt;/code&gt; (밀리 초)를 제공 할 수 있습니다 . &lt;em&gt;참고 : 기본 시간 제한은 5 초입니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="5c52bc127f7b5826340dcf7c16bf51e0c271179b" translate="yes" xml:space="preserve">
          <source>Or &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;&lt;code&gt;npm&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">또는 &lt;a href=&quot;https://www.npmjs.com/&quot;&gt; &lt;code&gt;npm&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="d89d40959e0d933e8af9e53128924505cd140e00" translate="yes" xml:space="preserve">
          <source>Or &lt;a href=&quot;https://www.npmjs.com/package/jest&quot;&gt;&lt;code&gt;npm&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">또는 &lt;a href=&quot;https://www.npmjs.com/package/jest&quot;&gt; &lt;code&gt;npm&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="371316f168eab595bc4ea7391514a4fa0fe1808f" translate="yes" xml:space="preserve">
          <source>Or if you'd like to create your own manual mock, you can do something like this:</source>
          <target state="translated">또는 자신의 수동 모의를 만들고 싶다면 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e431292d05ab6b8e395a562d7c86a6ac7fe933b" translate="yes" xml:space="preserve">
          <source>Or through JavaScript:</source>
          <target state="translated">또는 JavaScript를 통해 :</target>
        </trans-unit>
        <trans-unit id="6885f402c4ee1de5eff12b5e007bf6c788da9b3e" translate="yes" xml:space="preserve">
          <source>Or through TypeScript (if &lt;code&gt;ts-node&lt;/code&gt; is installed):</source>
          <target state="translated">또는 TypeScript를 통해 ( &lt;code&gt;ts-node&lt;/code&gt; 가 설치된 경우) :</target>
        </trans-unit>
        <trans-unit id="49a0778a7a6879004009864ebf95b81c7e7732d5" translate="yes" xml:space="preserve">
          <source>Order of execution of describe and test blocks</source>
          <target state="translated">설명 및 테스트 블록의 실행 순서</target>
        </trans-unit>
        <trans-unit id="489864adf35b7b6f389f08017e013d2e99fa910a" translate="yes" xml:space="preserve">
          <source>Otherwise, please see our &lt;a href=&quot;getting-started#using-typescript&quot;&gt;Getting Started&lt;/a&gt; guide for to get setup with TypeScript.</source>
          <target state="translated">그렇지 않으면 TypeScript로 설정하려면 &lt;a href=&quot;getting-started#using-typescript&quot;&gt;시작&lt;/a&gt; 안내서 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e9a3dd308dd30f061fa22d50cb21bc2220dcf9c9" translate="yes" xml:space="preserve">
          <source>Our mocked class will need to provide any member functions (&lt;code&gt;playSoundFile&lt;/code&gt; in the example) that will be called during our tests, or else we'll get an error for calling a function that doesn't exist. But we'll probably want to also spy on calls to those methods, to ensure that they were called with the expected parameters.</source>
          <target state="translated">우리의 조롱 된 클래스는 테스트 중에 호출 될 멤버 함수 ( 예 : &lt;code&gt;playSoundFile&lt;/code&gt; ) 를 제공해야 합니다. 그렇지 않으면 존재하지 않는 함수를 호출하면 오류가 발생합니다. 그러나 우리는 아마도 메소드가 예상 매개 변수로 호출되도록하기 위해 해당 메소드에 대한 호출을 감시하려고 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="bfc5a5b4ca8f80ee77043098ef9ffc04d559ec8c" translate="yes" xml:space="preserve">
          <source>Place a &lt;code&gt;debugger;&lt;/code&gt; statement in any of your tests, and then, in your project's directory, run:</source>
          <target state="translated">장소 &lt;code&gt;debugger;&lt;/code&gt; 테스트 중 하나에 명령문을 작성한 다음 프로젝트 디렉토리에서 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="2d313b13f95b5bdfa47176161df9d9aac0aea191" translate="yes" xml:space="preserve">
          <source>Please keep in mind that the resulting configuration must be JSON-serializable.</source>
          <target state="translated">결과 구성은 JSON 직렬화 가능해야합니다.</target>
        </trans-unit>
        <trans-unit id="af206380956fb62af6fa59d92f109cd9641063d0" translate="yes" xml:space="preserve">
          <source>Please note that if you use arrow functions in your classes, they will &lt;em&gt;not&lt;/em&gt; be part of the mock. The reason for that is that arrow functions are not present on the object's prototype, they are merely properties holding a reference to a function.</source>
          <target state="translated">수업에서 화살표 기능을 사용 하면 모의 기능에 포함 &lt;em&gt;되지 않습니다&lt;/em&gt; . 그 이유는 화살표 함수가 객체의 프로토 타입에 존재하지 않고 단지 함수에 대한 참조를 보유한 속성 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="15c438f6772aa6520819506e7fbe99852dd87fd5" translate="yes" xml:space="preserve">
          <source>Plugins can be customized via your Jest configuration.</source>
          <target state="translated">플러그인은 Jest 구성을 통해 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="93e78b672f965eb7c8293baebd2be38d992a6655" translate="yes" xml:space="preserve">
          <source>Preset configuration</source>
          <target state="translated">사전 설정 구성</target>
        </trans-unit>
        <trans-unit id="bfb26311747a6131c77f1e75e89e1da90925579c" translate="yes" xml:space="preserve">
          <source>Presets may also be relative filesystem paths.</source>
          <target state="translated">사전 설정은 상대 파일 시스템 경로 일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="86d670142d92672ef1ecead31bfb2615a86fbfe5" translate="yes" xml:space="preserve">
          <source>Presets may also be relative to filesystem paths.</source>
          <target state="translated">사전 설정은 파일 시스템 경로와 관련 될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="33521f1e271c7d1369654933da9149112fe4281c" translate="yes" xml:space="preserve">
          <source>Prevent tests from printing messages through the console.</source>
          <target state="translated">테스트가 콘솔을 통해 메시지를 인쇄하지 못하게합니다.</target>
        </trans-unit>
        <trans-unit id="0507f30be4f8c196c99ce7be2cba62397164f331" translate="yes" xml:space="preserve">
          <source>Prevents Jest from executing more than the specified amount of tests at the same time. Only affects tests that use &lt;code&gt;test.concurrent&lt;/code&gt;.</source>
          <target state="translated">Jest가 지정된 양보다 많은 테스트를 동시에 실행하지 못하게합니다. &lt;code&gt;test.concurrent&lt;/code&gt; 를 사용하는 테스트에만 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="7719ba43ff57b175fbd95f647e624ca1e3e38f9d" translate="yes" xml:space="preserve">
          <source>Print debugging info about your Jest config.</source>
          <target state="translated">Jest 구성에 대한 디버깅 정보를 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="169d23ffa6beb8bf0a8b932fddc3a716b615997f" translate="yes" xml:space="preserve">
          <source>Print your Jest config and then exits.</source>
          <target state="translated">Jest 구성을 인쇄 한 다음 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="a45ae5d1d90ee0d31bb43f56d9dee1beb6b5a14a" translate="yes" xml:space="preserve">
          <source>Prints the test results in JSON. This mode will send all other test output and user messages to stderr.</source>
          <target state="translated">테스트 결과를 JSON으로 인쇄합니다. 이 모드는 다른 모든 테스트 출력 및 사용자 메시지를 stderr로 보냅니다.</target>
        </trans-unit>
        <trans-unit id="b1d472e424c03ff52490d1edc8a0e23f95babb92" translate="yes" xml:space="preserve">
          <source>Promises</source>
          <target state="translated">Promises</target>
        </trans-unit>
        <trans-unit id="d3f60bcc6f5c4f59593f0501aca5c6e1a0e647d3" translate="yes" xml:space="preserve">
          <source>Property Matchers</source>
          <target state="translated">속성 매처</target>
        </trans-unit>
        <trans-unit id="4d1f996aa17807ebebdb5143b01f86f170d5bea6" translate="yes" xml:space="preserve">
          <source>React</source>
          <target state="translated">React</target>
        </trans-unit>
        <trans-unit id="b305ac456a0fe1de47f68c0f2dcb4be5edf55137" translate="yes" xml:space="preserve">
          <source>React 16 triggers these warnings due to how it checks element types, and the mocked module fails these checks. Your options are:</source>
          <target state="translated">React 16은 요소 유형을 확인하는 방법으로 인해 이러한 경고를 트리거하며, 모의 모듈은 이러한 확인에 실패합니다. 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="695d1116170755340f94ec3beb1f24f668859e58" translate="yes" xml:space="preserve">
          <source>Recommended config names:</source>
          <target state="translated">권장 구성 이름 :</target>
        </trans-unit>
        <trans-unit id="1a5dd83d686967dbee491e598c66e203e42c8bea" translate="yes" xml:space="preserve">
          <source>Redux</source>
          <target state="translated">Redux</target>
        </trans-unit>
        <trans-unit id="db1c784524e1b54011a95823026161f7c8517fe0" translate="yes" xml:space="preserve">
          <source>Reference</source>
          <target state="translated">Reference</target>
        </trans-unit>
        <trans-unit id="84641ce3545468aef6d9992e246ecc28023bd7fa" translate="yes" xml:space="preserve">
          <source>Removes any pending timers from the timer system.</source>
          <target state="translated">타이머 시스템에서 보류중인 타이머를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="571be88936b979291213a8fc1300d3eb34583940" translate="yes" xml:space="preserve">
          <source>Render as a custom element. DOM &quot;custom elements&quot; aren't checked for anything and shouldn't fire warnings. They are lowercase and have a dash in the name.</source>
          <target state="translated">사용자 정의 요소로 렌더링하십시오. DOM &quot;custom elements&quot;는 아무것도 확인되지 않으며 경고를 발생시키지 않아야합니다. 그것들은 소문자이며 이름에 대시가 있습니다.</target>
        </trans-unit>
        <trans-unit id="456b6bb3ce6f2e6632c5f1e8d9ca1d06e7f178b9" translate="yes" xml:space="preserve">
          <source>Render as text. This way you won't see the props passed to the mock component in the snapshot, but it's straightforward:</source>
          <target state="translated">텍스트로 렌더링하십시오. 이런 식으로 소품이 스냅 샷의 모의 컴포넌트로 전달되는 것을 볼 수는 없지만 간단합니다.</target>
        </trans-unit>
        <trans-unit id="1e70132872e75d10f3ccbb11c8b73d9f202669fd" translate="yes" xml:space="preserve">
          <source>Rendered snapshot:</source>
          <target state="translated">렌더링 된 스냅 샷 :</target>
        </trans-unit>
        <trans-unit id="3cd1c22168650ecd82a31a115bed21a42399c269" translate="yes" xml:space="preserve">
          <source>Repeating Setup For Many Tests</source>
          <target state="translated">많은 테스트를위한 설정 반복</target>
        </trans-unit>
        <trans-unit id="5add9c1dfb47ec8100a0659f89d63ed952ac6c86" translate="yes" xml:space="preserve">
          <source>Replacing the mock using &lt;a href=&quot;mock-function-api#mockfnmockimplementationfn&quot;&gt;&lt;code&gt;mockImplementation()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;mock-function-api#mockfnmockimplementationoncefn&quot;&gt;&lt;code&gt;mockImplementationOnce()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;mock-function-api#mockfnmockimplementationfn&quot;&gt; &lt;code&gt;mockImplementation()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;mock-function-api#mockfnmockimplementationoncefn&quot;&gt; &lt;code&gt;mockImplementationOnce()&lt;/code&gt; &lt;/a&gt; 사용하여 mock 교체</target>
        </trans-unit>
        <trans-unit id="19baff0fd9598875b3df0c02954246d178653887" translate="yes" xml:space="preserve">
          <source>Resets all information stored in the &lt;a href=&quot;#mockfnmockcalls&quot;&gt;&lt;code&gt;mockFn.mock.calls&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#mockfnmockinstances&quot;&gt;&lt;code&gt;mockFn.mock.instances&lt;/code&gt;&lt;/a&gt; arrays.</source>
          <target state="translated">&lt;a href=&quot;#mockfnmockcalls&quot;&gt; &lt;code&gt;mockFn.mock.calls&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#mockfnmockinstances&quot;&gt; &lt;code&gt;mockFn.mock.instances&lt;/code&gt; &lt;/a&gt; 배열에 저장된 모든 정보를 재설정합니다 .</target>
        </trans-unit>
        <trans-unit id="9c4baf164f97d04496389992c7c5da13fbb245ae" translate="yes" xml:space="preserve">
          <source>Resets the module registry - the cache of all required modules. This is useful to isolate modules where local state might conflict between tests.</source>
          <target state="translated">필요한 모든 모듈의 캐시 인 모듈 레지스트리를 재설정합니다. 이는 로컬 상태가 테스트간에 충돌 할 수있는 모듈을 격리하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="4ee7cc0bddf7c5a4ef8549ea7c38c8d601b2255d" translate="yes" xml:space="preserve">
          <source>Resets the state of all mocks. Equivalent to calling &lt;a href=&quot;mock-function-api#mockfnmockreset&quot;&gt;&lt;code&gt;.mockReset()&lt;/code&gt;&lt;/a&gt; on every mocked function.</source>
          <target state="translated">모든 모의 상태를 재설정합니다. 모든 조롱 된 함수에서 &lt;a href=&quot;mock-function-api#mockfnmockreset&quot;&gt; &lt;code&gt;.mockReset()&lt;/code&gt; &lt;/a&gt; 을 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="46554c07d0e0360541685d38d9047e14f0a0601e" translate="yes" xml:space="preserve">
          <source>Respect Browserify's &lt;a href=&quot;https://github.com/substack/browserify-handbook#browser-field&quot;&gt;&lt;code&gt;&quot;browser&quot;&lt;/code&gt; field&lt;/a&gt; in &lt;code&gt;package.json&lt;/code&gt; when resolving modules. Some modules export different versions based on whether they are operating in Node or a browser.</source>
          <target state="translated">모듈을 확인할 때 &lt;code&gt;package.json&lt;/code&gt; 에서 Browserify의 &lt;a href=&quot;https://github.com/substack/browserify-handbook#browser-field&quot;&gt; &lt;code&gt;&quot;browser&quot;&lt;/code&gt; 필드&lt;/a&gt; 를 존중하십시오 . 일부 모듈은 노드에서 작동하는지 브라우저에서 작동하는지에 따라 다른 버전을 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="27aceef5796ab8d68aed06c602f37330d5a900d4" translate="yes" xml:space="preserve">
          <source>Restores all mocks back to their original value. Equivalent to calling &lt;a href=&quot;mock-function-api#mockfnmockrestore&quot;&gt;&lt;code&gt;.mockRestore()&lt;/code&gt;&lt;/a&gt; on every mocked function. Beware that &lt;code&gt;jest.restoreAllMocks()&lt;/code&gt; only works when the mock was created with &lt;code&gt;jest.spyOn&lt;/code&gt;; other mocks will require you to manually restore them.</source>
          <target state="translated">모든 모형을 원래 값으로 복원합니다. 모든 조롱 된 함수에서 &lt;a href=&quot;mock-function-api#mockfnmockrestore&quot;&gt; &lt;code&gt;.mockRestore()&lt;/code&gt; &lt;/a&gt; 를 호출하는 것과 같습니다 . 그주의 &lt;code&gt;jest.restoreAllMocks()&lt;/code&gt; 모의가 작성된 시점에만 작동 &lt;code&gt;jest.spyOn&lt;/code&gt; ; 다른 모형은 수동으로 복원해야합니다.</target>
        </trans-unit>
        <trans-unit id="8ddb9b055cad613e29453fa554de9f36c7d6c8dd" translate="yes" xml:space="preserve">
          <source>Retry with &lt;a href=&quot;cli#--cache&quot;&gt;&lt;code&gt;--no-cache&lt;/code&gt;&lt;/a&gt;. Jest caches transformed module files to speed up test execution. If you are using your own custom transformer, consider adding a &lt;code&gt;getCacheKey&lt;/code&gt; function to it: &lt;a href=&quot;https://github.com/facebook/relay/blob/58cf36c73769690f0bbf90562707eadb062b029d/scripts/jest/preprocessor.js#L56-L61&quot;&gt;getCacheKey in Relay&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;cli#--cache&quot;&gt; &lt;code&gt;--no-cache&lt;/code&gt; 로&lt;/a&gt; 다시 시도하십시오 . Jest는 변환 된 모듈 파일을 캐시하여 테스트 실행 속도를 높입니다. 고유 한 사용자 정의 변환기를 사용하는 경우 &lt;code&gt;getCacheKey&lt;/code&gt; 함수를 추가 하십시오 (예 : &lt;a href=&quot;https://github.com/facebook/relay/blob/58cf36c73769690f0bbf90562707eadb062b029d/scripts/jest/preprocessor.js#L56-L61&quot;&gt;getCacheKey in Relay)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="156ec26504d2692465a0d8ff00489f7b36d9fa41" translate="yes" xml:space="preserve">
          <source>Returns a boolean (or &lt;code&gt;Promise&amp;lt;boolean&amp;gt;&lt;/code&gt; for handling asynchronous operations) to specify if a test should be run or not.</source>
          <target state="translated">테스트 실행 여부를 지정 하는 부울 (또는 비동기 작업 처리를위한 &lt;code&gt;Promise&amp;lt;boolean&amp;gt;&lt;/code&gt; )을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5d66ba4a66cb6cf526e2e08e5bcc4265e970107d" translate="yes" xml:space="preserve">
          <source>Returns a mock module instead of the actual module, bypassing all checks on whether the module should be required normally or not.</source>
          <target state="translated">모듈의 정상적인 필요 여부에 대한 모든 검사를 무시하고 실제 모듈 대신 모의 모듈을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9da978b2f0e20c11e4aa75b10631e43a25e02ab4" translate="yes" xml:space="preserve">
          <source>Returns a new, unused &lt;a href=&quot;mock-function-api&quot;&gt;mock function&lt;/a&gt;. Optionally takes a mock implementation.</source>
          <target state="translated">사용되지 않은 새로운 &lt;a href=&quot;mock-function-api&quot;&gt;mock 함수를&lt;/a&gt; 반환 합니다 . 선택적으로 모의 구현을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="a1acf18173b267510a46851d55a523216adab36c" translate="yes" xml:space="preserve">
          <source>Returns the &lt;code&gt;jest&lt;/code&gt; object for chaining.</source>
          <target state="translated">체이닝을위한 &lt;code&gt;jest&lt;/code&gt; 객체를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="d08519e49635fb031179ab7f05284949daef9383" translate="yes" xml:space="preserve">
          <source>Returns the actual module instead of a mock, bypassing all checks on whether the module should receive a mock implementation or not.</source>
          <target state="translated">모듈이 모의 구현을 받아야하는지 여부에 대한 모든 검사를 무시하고 모의 대신 실제 모듈을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2add96bbc9e9900cf433a5f2ebe6d67cb4660cf1" translate="yes" xml:space="preserve">
          <source>Returns the mock name string set by calling &lt;code&gt;mockFn.mockName(value)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mockFn.mockName(value)&lt;/code&gt; 을 호출하여 설정된 모의 이름 문자열을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="dd9336539157509732381e95d2e9b2f4ceef9877" translate="yes" xml:space="preserve">
          <source>Returns the number of fake timers still left to run.</source>
          <target state="translated">여전히 실행중인 가짜 타이머 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b1b392607deaf29a7e81453e069b7c07a32a6b18" translate="yes" xml:space="preserve">
          <source>Run</source>
          <target state="translated">Run</target>
        </trans-unit>
        <trans-unit id="641d1b198a65bb1bd4728078175e361d73f060b6" translate="yes" xml:space="preserve">
          <source>Run &lt;code&gt;yarn test&lt;/code&gt; to run tests with Jest.</source>
          <target state="translated">&lt;code&gt;yarn test&lt;/code&gt; 를 실행하여 Jest로 테스트 를 실행 하십시오 .</target>
        </trans-unit>
        <trans-unit id="7306d688c7598b3d294777df07da99e3d93d653c" translate="yes" xml:space="preserve">
          <source>Run All Timers</source>
          <target state="translated">모든 타이머 실행</target>
        </trans-unit>
        <trans-unit id="30ad8b68bab570303d35cefd0d73cf6056dbfc2d" translate="yes" xml:space="preserve">
          <source>Run Pending Timers</source>
          <target state="translated">보류 타이머 실행</target>
        </trans-unit>
        <trans-unit id="c89b3947b20f77096b75ca74d8fccf7526f1872b" translate="yes" xml:space="preserve">
          <source>Run all tests (default):</source>
          <target state="translated">모든 테스트를 실행하십시오 (기본값).</target>
        </trans-unit>
        <trans-unit id="02b363bdd7980fccab5552af0568d148195655d4" translate="yes" xml:space="preserve">
          <source>Run all tests affected by file changes in the last commit made. Behaves similarly to &lt;code&gt;--onlyChanged&lt;/code&gt;.</source>
          <target state="translated">마지막 커밋에서 파일 변경의 영향을받는 모든 테스트를 실행하십시오. &lt;code&gt;--onlyChanged&lt;/code&gt; 와 유사하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="52304e948d18e9a280f733e321f8b5e058bbed9d" translate="yes" xml:space="preserve">
          <source>Run only the tests of the specified projects. Jest uses the attribute &lt;code&gt;displayName&lt;/code&gt; in the configuration to identify each project. If you use this option, you should provide a &lt;code&gt;displayName&lt;/code&gt; to all your projects.</source>
          <target state="translated">지정된 프로젝트의 테스트 만 실행하십시오. Jest는 구성의 &lt;code&gt;displayName&lt;/code&gt; 속성을 사용하여 각 프로젝트를 식별합니다. 이 옵션을 사용하는 경우 모든 프로젝트에 &lt;code&gt;displayName&lt;/code&gt; 을 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="fbcaa420e9fe3c70be68c6d8ee7d82ab5720e907" translate="yes" xml:space="preserve">
          <source>Run only the tests that were specified with a pattern or filename:</source>
          <target state="translated">패턴 또는 파일 이름으로 지정된 테스트 만 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="92d791c05598e8218af4368bc378173046cea720" translate="yes" xml:space="preserve">
          <source>Run only the tests that were specified with their exact paths.</source>
          <target state="translated">정확한 경로로 지정된 테스트 만 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="23686a3a58e4a1259f35510a9d0252c4f6745f24" translate="yes" xml:space="preserve">
          <source>Run tests from one or more projects, found in the specified paths; also takes path globs. This option is the CLI equivalent of the &lt;a href=&quot;configuration#projects-arraystring--projectconfig&quot;&gt;&lt;code&gt;projects&lt;/code&gt;&lt;/a&gt; configuration option. Note that if configuration files are found in the specified paths, &lt;em&gt;all&lt;/em&gt; projects specified within those configuration files will be run.</source>
          <target state="translated">지정된 경로에있는 하나 이상의 프로젝트에서 테스트를 실행하십시오. 경로 globs도 필요합니다. 이 옵션은 &lt;a href=&quot;configuration#projects-arraystring--projectconfig&quot;&gt; &lt;code&gt;projects&lt;/code&gt; &lt;/a&gt; 구성 옵션에 해당하는 CLI 입니다. 지정된 경로에 구성 파일이 있으면 해당 구성 파일 내에 지정된 &lt;em&gt;모든&lt;/em&gt; 프로젝트가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="f9ddd0d105f6204c8e90c3adf874ea7bc2b26987" translate="yes" xml:space="preserve">
          <source>Run tests related to &lt;code&gt;path/to/fileA.js&lt;/code&gt; and &lt;code&gt;path/to/fileB.js&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;path/to/fileA.js&lt;/code&gt; 및 &lt;code&gt;path/to/fileB.js&lt;/code&gt; 와 관련된 테스트를 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="2de5d0d69fc805a58b350e937e2690429d2970e2" translate="yes" xml:space="preserve">
          <source>Run tests related to changed files based on hg/git (uncommitted files):</source>
          <target state="translated">hg / git (커밋되지 않은 파일)를 기반으로 변경된 파일과 관련된 테스트를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="a44ae954d1ab8ef98e8adfe8b4785726ef8e4670" translate="yes" xml:space="preserve">
          <source>Run tests that match this spec name (match against the name in &lt;code&gt;describe&lt;/code&gt; or &lt;code&gt;test&lt;/code&gt;, basically).</source>
          <target state="translated">이 스펙 이름과 일치하는 테스트를 실행하십시오 ( 기본적으로 &lt;code&gt;describe&lt;/code&gt; 또는 &lt;code&gt;test&lt;/code&gt; 의 이름과 일치 ).</target>
        </trans-unit>
        <trans-unit id="3250ade6678b3bc2a1ae0933ebec438d66c4c65a" translate="yes" xml:space="preserve">
          <source>Run tests with specified reporters. &lt;a href=&quot;configuration#reporters-arraymodulename--modulename-options&quot;&gt;Reporter options&lt;/a&gt; are not available via CLI. Example with multiple reporters:</source>
          <target state="translated">지정된 기자와 함께 테스트를 실행하십시오. CLI를 통해 &lt;a href=&quot;configuration#reporters-arraymodulename--modulename-options&quot;&gt;리포터 옵션&lt;/a&gt; 을 사용할 수 없습니다. 여러 기자가있는 예 :</target>
        </trans-unit>
        <trans-unit id="1e9d71147bb217981f158928624c5b13a6be2ead" translate="yes" xml:space="preserve">
          <source>Run watch mode:</source>
          <target state="translated">시계 모드 실행 :</target>
        </trans-unit>
        <trans-unit id="6317e775f03f11757290b5bce78a11c48721ccd6" translate="yes" xml:space="preserve">
          <source>Running from command line</source>
          <target state="translated">명령 줄에서 실행</target>
        </trans-unit>
        <trans-unit id="3d642ff91fd7ebdca37f4b2895153e438af4b378" translate="yes" xml:space="preserve">
          <source>Running from the command line</source>
          <target state="translated">명령 줄에서 실행</target>
        </trans-unit>
        <trans-unit id="437a88c377620b15b1bd26b6489ffe7cf9e58772" translate="yes" xml:space="preserve">
          <source>Runs a function after all the tests in this file have completed. If the function returns a promise or is a generator, Jest waits for that promise to resolve before continuing.</source>
          <target state="translated">이 파일의 모든 테스트가 완료된 후 기능을 실행합니다. 함수가 약속을 반환하거나 생성자 인 경우 Jest는 계속 진행하기 전에 해당 약속이 해결 될 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="50450676d930383c48d2ec3efefa163347c39da6" translate="yes" xml:space="preserve">
          <source>Runs a function after each one of the tests in this file completes. If the function returns a promise or is a generator, Jest waits for that promise to resolve before continuing.</source>
          <target state="translated">이 파일의 각 테스트가 완료된 후 기능을 실행합니다. 함수가 약속을 반환하거나 생성자 인 경우 Jest는 계속 진행하기 전에 해당 약속이 해결 될 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="44b753442cff11f6ed337230a6a654b466728c0d" translate="yes" xml:space="preserve">
          <source>Runs a function before any of the tests in this file run. If the function returns a promise or is a generator, Jest waits for that promise to resolve before running tests.</source>
          <target state="translated">이 파일의 테스트가 실행되기 전에 함수를 실행합니다. 함수가 약속을 반환하거나 생성자 인 경우 Jest는 테스트를 실행하기 전에 해당 약속이 해결 될 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="57284652d7931aab5ea782fa00d26cf2b4c59502" translate="yes" xml:space="preserve">
          <source>Runs a function before each of the tests in this file runs. If the function returns a promise or is a generator, Jest waits for that promise to resolve before running the test.</source>
          <target state="translated">이 파일의 각 테스트가 실행되기 전에 기능을 실행합니다. 함수가 약속을 반환하거나 생성기 인 경우 Jest는 테스트를 실행하기 전에 해당 약속이 해결 될 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="8886a35ac5b619bcc55c828058cdaa29e97376a1" translate="yes" xml:space="preserve">
          <source>Runs failed tests n-times until they pass or until the max number of retries is exhausted. This only works with &lt;a href=&quot;https://github.com/facebook/jest/tree/master/packages/jest-circus&quot;&gt;jest-circus&lt;/a&gt;!</source>
          <target state="translated">실패한 테스트를 통과 할 때까지 또는 최대 재시도 횟수가 끝날 때까지 n 번 실패한 테스트를 실행합니다. 이것은 &lt;a href=&quot;https://github.com/facebook/jest/tree/master/packages/jest-circus&quot;&gt;jest-circus&lt;/a&gt; 에서만 작동합니다 !</target>
        </trans-unit>
        <trans-unit id="b2614c8f6a2b7cb20f551e055799e18e1ea7d981" translate="yes" xml:space="preserve">
          <source>Runs tests related to the changes since the provided branch or commit hash. If the current branch has diverged from the given branch, then only changes made locally will be tested. Behaves similarly to &lt;code&gt;--onlyChanged&lt;/code&gt;.</source>
          <target state="translated">제공된 분기 또는 커밋 해시 이후의 변경 사항과 관련된 테스트를 실행합니다. 현재 분기가 지정된 분기에서 분기 된 경우 로컬에서 변경된 사항 만 테스트됩니다. &lt;code&gt;--onlyChanged&lt;/code&gt; 와 유사하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="f2884236a5a7d1409f769ed84cceee98770e2aba" translate="yes" xml:space="preserve">
          <source>Runs tests related to the changes since the provided branch. If the current branch has diverged from the given branch, then only changes made locally will be tested. Behaves similarly to &lt;code&gt;--onlyChanged&lt;/code&gt;.</source>
          <target state="translated">제공된 분기 이후 변경 사항과 관련된 테스트를 실행합니다. 현재 분기가 지정된 분기에서 분기 된 경우 로컬에서 변경 한 사항 만 테스트됩니다. &lt;code&gt;--onlyChanged&lt;/code&gt; 와 유사하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="fdee9094809cabf1a25af1ca3211f475ddc04a54" translate="yes" xml:space="preserve">
          <source>Runs tests related to the current changes and the changes made in the last commit. Behaves similarly to &lt;code&gt;--onlyChanged&lt;/code&gt;.</source>
          <target state="translated">현재 변경 사항 및 마지막 커밋에서 작성된 변경 사항과 관련된 테스트를 실행합니다. &lt;code&gt;--onlyChanged&lt;/code&gt; 와 유사하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="ea13653cdec671f745362f34fcd64c3406b64c75" translate="yes" xml:space="preserve">
          <source>Scoped modules can be mocked by creating a file in a directory structure that matches the name of the scoped module. For example, to mock a scoped module called &lt;code&gt;@scope/project-name&lt;/code&gt;, create a file at &lt;code&gt;__mocks__/@scope/project-name.js&lt;/code&gt;, creating the &lt;code&gt;@scope/&lt;/code&gt; directory accordingly.</source>
          <target state="translated">범위가 지정된 모듈의 이름과 일치하는 디렉토리 구조에서 파일을 작성하여 범위가 지정된 모듈을 조롱 할 수 있습니다. 예를 들어 &lt;code&gt;@scope/project-name&lt;/code&gt; 이라는 범위가 지정된 모듈을 모의하려면 &lt;code&gt;__mocks__/@scope/project-name.js&lt;/code&gt; 에 파일을 작성하고 그에 따라 &lt;code&gt;@scope/&lt;/code&gt; 디렉토리를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="cbc636498e1c269635cd060804fe4bc4c5cc9f77" translate="yes" xml:space="preserve">
          <source>Scoping</source>
          <target state="translated">Scoping</target>
        </trans-unit>
        <trans-unit id="211a5b2321ab26457503f06cb4dc7556791fc7d0" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;configuration#snapshotserializers-arraystring&quot;&gt;configuring Jest&lt;/a&gt; for more information.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;configuration#snapshotserializers-arraystring&quot;&gt;Jest 구성&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="efddd22422ff36c5396f782f1486c33090e561a7" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/DynamoDB.html#createTable-property&quot;&gt;Create Table API&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/DynamoDB.html#createTable-property&quot;&gt;테이블 API 생성을&lt;/a&gt; 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="f34a9c66618a8a38e77218fa386d8ca82390118e" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://github.com/shelfio/jest-dynamodb&quot;&gt;documentation&lt;/a&gt; for details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://github.com/shelfio/jest-dynamodb&quot;&gt;설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d0f8c5b32a609f4f0cc5792e1d82420240d67f10" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://github.com/shelfio/jest-mongodb&quot;&gt;documentation&lt;/a&gt; for details (configuring MongoDB version, etc).</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://github.com/shelfio/jest-mongodb&quot;&gt;설명서&lt;/a&gt; 를 참조하십시오 (MongoDB 버전 구성 등).</target>
        </trans-unit>
        <trans-unit id="85e1678b6936236b6f910c2ee40e764fd5fd5efb" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://github.com/smooth-code/jest-puppeteer&quot;&gt;documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/smooth-code/jest-puppeteer&quot;&gt;설명서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ac033bc12bf7544e09b943fc85a55ee0e0eb5bb2" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://jestjs.io/help.html&quot;&gt;Help&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://jestjs.io/help.html&quot;&gt;도움말을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4bd8f6623cb0bd7f5cbd56dab7f5f02bfe1b459a" translate="yes" xml:space="preserve">
          <source>See &lt;code&gt;automock&lt;/code&gt; section of &lt;a href=&quot;configuration#automock-boolean&quot;&gt;configuration&lt;/a&gt; for more information</source>
          <target state="translated">자세한 내용 은 &lt;a href=&quot;configuration#automock-boolean&quot;&gt;구성의 &lt;/a&gt; &lt;code&gt;automock&lt;/code&gt; 섹션 을 참조하십시오</target>
        </trans-unit>
        <trans-unit id="b6f206289cb851ace292e1546d209054802eb0c9" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#testregex-string--arraystring&quot;&gt;&lt;code&gt;testRegex&lt;/code&gt; [string | array&amp;lt;string&amp;gt;]&lt;/a&gt;, but note that you cannot specify both options.</source>
          <target state="translated">참조 &lt;a href=&quot;#testregex-string--arraystring&quot;&gt; &lt;code&gt;testRegex&lt;/code&gt; [문자열 | array &amp;lt;string&amp;gt;]&lt;/a&gt; 이지만 두 옵션을 모두 지정할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="94efbf6a114ebb2635afd14dc7211a7f961c8a16" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;https://github.com/jonschlinkert/micromatch&quot;&gt;micromatch&lt;/a&gt; package for details of the patterns you can specify.</source>
          <target state="translated">지정할 수있는 패턴에 대한 자세한 내용은 &lt;a href=&quot;https://github.com/jonschlinkert/micromatch&quot;&gt;마이크로 매치&lt;/a&gt; 패키지를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="532a50a063dc36d0a8534a18dcaf4a0125d0cb62" translate="yes" xml:space="preserve">
          <source>Set the current system time used by fake timers. Simulates a user changing the system clock while your program is running. It affects the current time but it does not in itself cause e.g. timers to fire; they will fire exactly as they would have done without the call to &lt;code&gt;jest.setSystemTime()&lt;/code&gt;.</source>
          <target state="translated">가짜 타이머에 사용되는 현재 시스템 시간을 설정합니다. 프로그램이 실행되는 동안 사용자가 시스템 시계를 변경하는 것을 시뮬레이션합니다. 현재 시간에 영향을 주지만 그 자체로 타이머가 실행되는 것은 아닙니다. &lt;code&gt;jest.setSystemTime()&lt;/code&gt; 호출하지 않고했던 것과 똑같이 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="615ea98380b0e9ec8f2989a621cea9a7e764e463" translate="yes" xml:space="preserve">
          <source>Set the default timeout interval for tests and before/after hooks in milliseconds.</source>
          <target state="translated">테스트 및 후크 전 / 후 후크의 기본 시간 초과 간격을 밀리 초 단위로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="7ef9a41019d98dcd7087734f625109563be77315" translate="yes" xml:space="preserve">
          <source>Set the default timeout interval for tests and before/after hooks in milliseconds. This only affects the test file from which this function is called.</source>
          <target state="translated">테스트 및 이전 / 이후 후크에 대한 기본 제한 시간 간격 (밀리 초)을 설정합니다. 이것은이 함수가 호출되는 테스트 파일에만 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="4c094b57443ef1dac1663cfc0d2869275b9ac2e1" translate="yes" xml:space="preserve">
          <source>Sets the path to the &lt;a href=&quot;https://prettier.io/&quot;&gt;&lt;code&gt;prettier&lt;/code&gt;&lt;/a&gt; node module used to update inline snapshots.</source>
          <target state="translated">인라인 스냅 샷을 업데이트하는 데 사용되는 &lt;a href=&quot;https://prettier.io/&quot;&gt; &lt;code&gt;prettier&lt;/code&gt; &lt;/a&gt; 노드 모듈 의 경로를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="03632ef1c76d8a3790f3ba38329aa3105012b7ef" translate="yes" xml:space="preserve">
          <source>Setting this value to &lt;code&gt;fake&lt;/code&gt; allows the use of fake timers for functions such as &lt;code&gt;setTimeout&lt;/code&gt;. Fake timers are useful when a piece of code sets a long timeout that we don't want to wait for in a test.</source>
          <target state="translated">이 값을 &lt;code&gt;fake&lt;/code&gt; 로 설정하면 &lt;code&gt;setTimeout&lt;/code&gt; 과 같은 기능에 가짜 타이머를 사용할 수 있습니다 . 가짜 타이머는 코드 조각이 테스트에서 기다리기를 원하지 않는 긴 시간 초과를 설정할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="ef5d59a2f86331bc4671ba4a54ae325b17ae045f" translate="yes" xml:space="preserve">
          <source>Setting this value to &lt;code&gt;legacy&lt;/code&gt; or &lt;code&gt;fake&lt;/code&gt; allows the use of fake timers for functions such as &lt;code&gt;setTimeout&lt;/code&gt;. Fake timers are useful when a piece of code sets a long timeout that we don't want to wait for in a test.</source>
          <target state="translated">이 값을 &lt;code&gt;legacy&lt;/code&gt; 또는 &lt;code&gt;fake&lt;/code&gt; 로 설정하면 &lt;code&gt;setTimeout&lt;/code&gt; 과 같은 함수에 대해 가짜 타이머를 사용할 수 있습니다 . 가짜 타이머는 코드 조각이 테스트에서 기다리지 않으려는 긴 시간 제한을 설정할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="cdd7bb2816b7a8f88bce0e47be39943bc369516b" translate="yes" xml:space="preserve">
          <source>Setup</source>
          <target state="translated">Setup</target>
        </trans-unit>
        <trans-unit id="5f07ec3fe4ba8082e43fef02f2b4d5d1a2a1d466" translate="yes" xml:space="preserve">
          <source>Setup and Teardown</source>
          <target state="translated">설정 및 해체</target>
        </trans-unit>
        <trans-unit id="24b1a600607b12b94694aa1cdc63d96c8b7a540d" translate="yes" xml:space="preserve">
          <source>Setup with Create React App</source>
          <target state="translated">React 앱 만들기로 설정</target>
        </trans-unit>
        <trans-unit id="9e9d9e60fd56a1f1ea8ea643530acaeb4d062997" translate="yes" xml:space="preserve">
          <source>Setup without Create React App</source>
          <target state="translated">React 앱을 만들지 않고 설정</target>
        </trans-unit>
        <trans-unit id="822b3a2435ec58cb5bc9376be9ad2eeac55edc92" translate="yes" xml:space="preserve">
          <source>Should snapshot files be committed?</source>
          <target state="translated">스냅 샷 파일을 커밋해야합니까?</target>
        </trans-unit>
        <trans-unit id="492eafbaea4c259f43100935024f5e3a182f7170" translate="yes" xml:space="preserve">
          <source>Should your plugin attempt to overwrite a reserved key, Jest will error out with a descriptive message, something like:</source>
          <target state="translated">플러그인이 예약 된 키를 덮어 쓰려고하면 Jest는 다음과 같은 설명 메시지를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="bd51fd0dd8cd830d4a42fc531c55cdfccd2ac812" translate="yes" xml:space="preserve">
          <source>Show the help information, similar to this page.</source>
          <target state="translated">이 페이지와 유사한 도움말 정보를 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="fb22048fa6d1f11cbc46a0377600ca142853ad0a" translate="yes" xml:space="preserve">
          <source>Similarly webpack's &lt;code&gt;resolve.root&lt;/code&gt; option functions like setting the &lt;code&gt;NODE_PATH&lt;/code&gt; env variable, which you can set, or make use of the &lt;code&gt;modulePaths&lt;/code&gt; option.</source>
          <target state="translated">마찬가지로 webpack의 &lt;code&gt;resolve.root&lt;/code&gt; 옵션은 &lt;code&gt;NODE_PATH&lt;/code&gt; env 변수 설정과 같은 기능을 수행합니다.이 변수는 설정하거나 &lt;code&gt;modulePaths&lt;/code&gt; 옵션을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7adebe990936d6de8e229a12d896004b38f87428" translate="yes" xml:space="preserve">
          <source>Similarly, webpack's &lt;code&gt;resolve.root&lt;/code&gt; option functions like setting the &lt;code&gt;NODE_PATH&lt;/code&gt; env variable, which you can set, or make use of the &lt;code&gt;modulePaths&lt;/code&gt; option.</source>
          <target state="translated">마찬가지로 webpack의 &lt;code&gt;resolve.root&lt;/code&gt; 옵션은 &lt;code&gt;NODE_PATH&lt;/code&gt; env 변수를 설정하는 것과 같이 작동합니다.이 변수는 설정하거나 &lt;code&gt;modulePaths&lt;/code&gt; 옵션을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c1b6800d4211e291c95387e4b2e79446e622a4f0" translate="yes" xml:space="preserve">
          <source>Since Jest 22.1.0+, the &lt;code&gt;jest.spyOn&lt;/code&gt; method takes an optional third argument of &lt;code&gt;accessType&lt;/code&gt; that can be either &lt;code&gt;'get'&lt;/code&gt; or &lt;code&gt;'set'&lt;/code&gt;, which proves to be useful when you want to spy on a getter or a setter, respectively.</source>
          <target state="translated">Jest 22.1.0+ 이후로, &lt;code&gt;jest.spyOn&lt;/code&gt; 메소드는 &lt;code&gt;'get'&lt;/code&gt; 또는 &lt;code&gt;'set'&lt;/code&gt; 일 수있는 &lt;code&gt;accessType&lt;/code&gt; 의 선택적 세 번째 인수를 가져옵니다 . 이는 getter 또는 setter를 각각 스파이하려고 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="4f8bae34a73e1f4213cb283f5a11b822ba4dc217" translate="yes" xml:space="preserve">
          <source>Since the later describes exactly what's expected in the output, it's more clear to see when it's wrong:</source>
          <target state="translated">나중에 출력에서 ​​예상되는 내용을 정확하게 설명하므로 언제 잘못되었는지 더 명확하게 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9678530810438e60dd8aa3f6aa12c28ea2f3f1c" translate="yes" xml:space="preserve">
          <source>Since we just updated our component to point to a different address, it's reasonable to expect changes in the snapshot for this component. Our snapshot test case is failing because the snapshot for our updated component no longer matches the snapshot artifact for this test case.</source>
          <target state="translated">다른 주소를 가리 키도록 구성 요소를 방금 업데이트 했으므로이 구성 요소의 스냅 샷이 변경 될 것으로 예상됩니다. 업데이트 된 구성 요소의 스냅 샷이이 테스트 케이스의 스냅 샷 아티팩트와 더 이상 일치하지 않으므로 스냅 샷 테스트 케이스가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="540cf57482add7abae948ebe3f5722e703011e20" translate="yes" xml:space="preserve">
          <source>Since we'd like our tests to avoid actually hitting the disk (that's pretty slow and fragile), we create a manual mock for the &lt;code&gt;fs&lt;/code&gt; module by extending an automatic mock. Our manual mock will implement custom versions of the &lt;code&gt;fs&lt;/code&gt; APIs that we can build on for our tests:</source>
          <target state="translated">실제로 디스크에 부딪히는 것을 피하기 위해 테스트를 원하기 때문에 (매우 느리고 깨지기 쉬운) 자동 모의를 확장 하여 &lt;code&gt;fs&lt;/code&gt; 모듈에 대한 수동 모의를 만듭니다 . 수동 모의는 테스트를 위해 구축 할 수 있는 사용자 정의 버전의 &lt;code&gt;fs&lt;/code&gt; API를 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="66842e9da141137fe7352a0a53d93d8d95043a5c" translate="yes" xml:space="preserve">
          <source>Snapshot Test</source>
          <target state="translated">스냅 샷 테스트</target>
        </trans-unit>
        <trans-unit id="cdf5126870db570bc7f1db0845f8a4e0d4d3ae76" translate="yes" xml:space="preserve">
          <source>Snapshot Testing</source>
          <target state="translated">스냅 샷 테스트</target>
        </trans-unit>
        <trans-unit id="89df76fc07cdab1a593d1520d1e485a89eaa0758" translate="yes" xml:space="preserve">
          <source>Snapshot Testing with Jest</source>
          <target state="translated">Jest를 사용한 스냅 샷 테스트</target>
        </trans-unit>
        <trans-unit id="133546ab2de371a152f49c68a57605cf66823f74" translate="yes" xml:space="preserve">
          <source>Snapshot Testing with Mocks, Enzyme and React 16</source>
          <target state="translated">Mocks, 효소 및 반응을 이용한 스냅 샷 테스트 16</target>
        </trans-unit>
        <trans-unit id="5a16d1671f06c1b79f4ca90da446bf86ec30018f" translate="yes" xml:space="preserve">
          <source>Snapshot files must always represent the current state of the modules they are covering. Therefore, if you are merging two branches and encounter a conflict in the snapshot files, you can either resolve the conflict manually or update the snapshot file by running Jest and inspecting the result.</source>
          <target state="translated">스냅 샷 파일은 항상 해당 모듈의 현재 상태를 나타내야합니다. 따라서 두 개의 브랜치를 병합하고 스냅 샷 파일에서 충돌이 발생하면 Jest를 실행하고 결과를 검사하여 충돌을 수동으로 해결하거나 스냅 샷 파일을 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2f67f68de52f1c63bdae4635f588faaa8a269e7" translate="yes" xml:space="preserve">
          <source>Snapshot testing and visual regression testing are two distinct ways of testing UIs, and they serve different purposes. Visual regression testing tools take screenshots of web pages and compare the resulting images pixel by pixel. With Snapshot testing values are serialized, stored within text files, and compared using a diff algorithm. There are different trade-offs to consider and we listed the reasons why snapshot testing was built in the &lt;a href=&quot;https://jestjs.io/blog/2016/07/27/jest-14.html#why-snapshot-testing&quot;&gt;Jest blog&lt;/a&gt;.</source>
          <target state="translated">스냅 샷 테스트와 시각적 회귀 테스트는 UI를 테스트하는 두 가지 다른 방법이며 서로 다른 용도로 사용됩니다. 시각적 회귀 테스트 도구는 웹 페이지의 스크린 샷을 찍고 결과 이미지를 픽셀 단위로 비교합니다. Snapshot 테스트를 통해 값이 직렬화되고 텍스트 파일 내에 저장되며 diff 알고리즘을 사용하여 비교됩니다. 고려해야 할 다른 절충 사항이 있으며 &lt;a href=&quot;https://jestjs.io/blog/2016/07/27/jest-14.html#why-snapshot-testing&quot;&gt;Jest 블로그&lt;/a&gt; 에서 스냅 샷 테스트가 작성된 이유를 나열했습니다 .</target>
        </trans-unit>
        <trans-unit id="67c5ace60d5fc8adf8135b3fa0469ad4f55990c3" translate="yes" xml:space="preserve">
          <source>Snapshot testing is only one of more than 20 assertions that ship with Jest. The aim of snapshot testing is not to replace existing unit tests, but to provide additional value and make testing painless. In some scenarios, snapshot testing can potentially remove the need for unit testing for a particular set of functionalities (e.g. React components), but they can work together as well.</source>
          <target state="translated">스냅 샷 테스트는 Jest와 함께 제공되는 20 개가 넘는 주장 중 하나 일뿐입니다. 스냅 샷 테스트의 목표는 기존 단위 테스트를 대체하는 것이 아니라 추가 가치를 제공하고 테스트를 수월하게하는 것입니다. 일부 시나리오에서 스냅 샷 테스트는 특정 기능 세트 (예 : React 컴포넌트)에 대한 단위 테스트의 필요성을 제거 할 수 있지만 함께 작동 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d78cced32db30f3bf1c92f37bcc6a46c7cbbb0b3" translate="yes" xml:space="preserve">
          <source>Snapshot tests are a very useful tool whenever you want to make sure your UI does not change unexpectedly.</source>
          <target state="translated">UI가 예기치 않게 변경되지 않도록하려면 스냅 샷 테스트가 매우 유용한 도구입니다.</target>
        </trans-unit>
        <trans-unit id="46a65a578f3ba45c38c2f4b67393d191767bfc07" translate="yes" xml:space="preserve">
          <source>Snapshots are a fantastic tool for identifying unexpected interface changes within your application &amp;ndash; whether that interface is an API response, UI, logs, or error messages. As with any testing strategy, there are some best-practices you should be aware of, and guidelines you should follow, in order to use them effectively.</source>
          <target state="translated">스냅 샷은 인터페이스가 API 응답, UI, 로그 또는 오류 메시지인지에 관계없이 응용 프로그램 내에서 예기치 않은 인터페이스 변경을 식별하는 환상적인 도구입니다. 다른 테스트 전략과 마찬가지로 효과적으로 사용하기 위해 알아야 할 모범 사례와 따라야 할 지침이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c478e2f51e8e2add8d79e6f37e7ed46eb64562f2" translate="yes" xml:space="preserve">
          <source>Sometimes it happens (especially in React Native or TypeScript projects) that 3rd party modules are published as untranspiled. Since all files inside &lt;code&gt;node_modules&lt;/code&gt; are not transformed by default, Jest will not understand the code in these modules, resulting in syntax errors. To overcome this, you may use &lt;code&gt;transformIgnorePatterns&lt;/code&gt; to allow transpiling such modules. You'll find a good example of this use case in &lt;a href=&quot;tutorial-react-native#transformignorepatterns-customization&quot;&gt;React Native Guide&lt;/a&gt;.</source>
          <target state="translated">때때로 (특히 React Native 또는 TypeScript 프로젝트에서) 타사 모듈이 트랜스 파일되지 않은 것으로 게시되는 경우가 있습니다. &lt;code&gt;node_modules&lt;/code&gt; 내부의 모든 파일 은 기본적으로 변환되지 않으므로 Jest는 이러한 모듈의 코드를 이해하지 못하여 구문 오류가 발생합니다. 이를 극복하기 위해 &lt;code&gt;transformIgnorePatterns&lt;/code&gt; 를 사용하여 이러한 모듈을 트랜스 파일 할 수 있습니다 . &lt;a href=&quot;tutorial-react-native#transformignorepatterns-customization&quot;&gt;React Native Guide&lt;/a&gt; 에서이 사용 사례의 좋은 예를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f682ce988a8d01605c894c6eb3963ca0cc76e8b" translate="yes" xml:space="preserve">
          <source>Sometimes it happens (especially in React Native or TypeScript projects) that 3rd party modules are published as untranspiled. Since all files inside &lt;code&gt;node_modules&lt;/code&gt; are not transformed by default, Jest will not understand the code in these modules, resulting in syntax errors. To overcome this, you may use &lt;code&gt;transformIgnorePatterns&lt;/code&gt; to whitelist such modules. You'll find a good example of this use case in &lt;a href=&quot;tutorial-react-native#transformignorepatterns-customization&quot;&gt;React Native Guide&lt;/a&gt;.</source>
          <target state="translated">때로는 타사 모듈이 변환되지 않은 상태로 게시되는 경우 (특히 React Native 또는 TypeScript 프로젝트에서) 발생합니다. &lt;code&gt;node_modules&lt;/code&gt; 내의 모든 파일 은 기본적으로 변환되지 않으므로 Jest는 이러한 모듈의 코드를 이해하지 못하므로 구문 오류가 발생합니다. 이를 극복하기 위해 &lt;code&gt;transformIgnorePatterns&lt;/code&gt; 를 사용 하여 해당 모듈을 화이트리스트에 추가 할 수 있습니다 . 이 유스 케이스의 좋은 예는 &lt;a href=&quot;tutorial-react-native#transformignorepatterns-customization&quot;&gt;React Native Guide&lt;/a&gt; 에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2b30ccb8fda73d533a0e969bafd118c24c88742" translate="yes" xml:space="preserve">
          <source>Sometimes you need to provide a more complex manual mock. For example if you'd like to forward the prop types or static fields of a native component to a mock, you can return a different React component from a mock through this helper from jest-react-native:</source>
          <target state="translated">때로는 더 복잡한 수동 모형을 제공해야합니다. 예를 들어 네이티브 구성 요소의 prop 유형 또는 정적 필드를 모의 객체로 전달하려면 jest-react-native의이 도우미를 통해 모의 다른 리 액트 구성 요소를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="695c0e7e9d729e27f87cadca0070a18d74fc0abb" translate="yes" xml:space="preserve">
          <source>Sort test path alphabetically.</source>
          <target state="translated">테스트 경로를 알파벳순으로 정렬하십시오.</target>
        </trans-unit>
        <trans-unit id="e68b54695ab9a614c999727da57981ffa8733914" translate="yes" xml:space="preserve">
          <source>Specifies notification mode. Requires &lt;code&gt;notify: true&lt;/code&gt;.</source>
          <target state="translated">알림 모드를 지정합니다. &lt;code&gt;notify: true&lt;/code&gt; 필요 : true .</target>
        </trans-unit>
        <trans-unit id="3484b5172e046d75121af3f84a8f20757a6f1353" translate="yes" xml:space="preserve">
          <source>Specify preset in your Jest configuration:</source>
          <target state="translated">Jest 구성에서 사전 설정을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="072147ce4032ecb883aadc972685fb5dc5cab93b" translate="yes" xml:space="preserve">
          <source>Spying on methods of our class</source>
          <target state="translated">우리 수업의 방법을 감시</target>
        </trans-unit>
        <trans-unit id="3e66bbc94f94d5c9febbf71967e8a53cc9c379f0" translate="yes" xml:space="preserve">
          <source>Spying on the constructor</source>
          <target state="translated">생성자 감시</target>
        </trans-unit>
        <trans-unit id="024a38d0b03fcbf63acc93daff4e631c67675d3b" translate="yes" xml:space="preserve">
          <source>Starting from react-native version 0.38, a Jest setup is included by default when running &lt;code&gt;react-native init&lt;/code&gt;. The following configuration should be automatically added to your package.json file:</source>
          <target state="translated">react-native 버전 0.38부터는 &lt;code&gt;react-native init&lt;/code&gt; 를 실행할 때 Jest 설정이 기본적으로 포함됩니다 . package.json 파일에 다음 구성이 자동으로 추가되어야합니다.</target>
        </trans-unit>
        <trans-unit id="1991c5175326e4c289d97fffe85eadf0791dd3bd" translate="yes" xml:space="preserve">
          <source>Static ES6 module imports are hoisted to the top of the file, so instead we have to import them dynamically using &lt;code&gt;import()&lt;/code&gt;.</source>
          <target state="translated">정적 ES6 모듈 가져 오기는 파일 맨 위로 가져 오므로 &lt;code&gt;import()&lt;/code&gt; 사용하여 동적으로 가져와야합니다 .</target>
        </trans-unit>
        <trans-unit id="28f738d61989d25363252d6dd69c2b75719b7de9" translate="yes" xml:space="preserve">
          <source>Still unresolved?</source>
          <target state="translated">여전히 해결되지 않습니까?</target>
        </trans-unit>
        <trans-unit id="6c6f5518d1fa80f650e491adb2e489a09a7f982c" translate="yes" xml:space="preserve">
          <source>Still, there are cases where it's useful to go beyond the ability to specify return values and full-on replace the implementation of a mock function. This can be done with &lt;code&gt;jest.fn&lt;/code&gt; or the &lt;code&gt;mockImplementationOnce&lt;/code&gt; method on mock functions.</source>
          <target state="translated">그럼에도 불구하고 반환 값을 지정하는 기능을 넘어서 모의 함수의 구현을 완전히 대체하는 것이 유용한 경우가 있습니다. 이것은 &lt;code&gt;jest.fn&lt;/code&gt; 또는 mock 함수 의 &lt;code&gt;mockImplementationOnce&lt;/code&gt; 메소드 로 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3816c4beac471c733eed1d91c213f8c2b6a29262" translate="yes" xml:space="preserve">
          <source>Strings</source>
          <target state="translated">Strings</target>
        </trans-unit>
        <trans-unit id="bcc358b3aaafb093f4a2baf42f0160bfb2bfd061" translate="yes" xml:space="preserve">
          <source>Suppose we have a class that fetches users from our API. The class uses &lt;a href=&quot;https://github.com/axios/axios&quot;&gt;axios&lt;/a&gt; to call the API then returns the &lt;code&gt;data&lt;/code&gt; attribute which contains all the users:</source>
          <target state="translated">API에서 사용자를 가져 오는 클래스가 있다고 가정합니다. 클래스는 &lt;a href=&quot;https://github.com/axios/axios&quot;&gt;axios&lt;/a&gt; 를 사용 하여 API를 호출 한 다음 모든 사용자를 포함 하는 &lt;code&gt;data&lt;/code&gt; 속성 을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="3a4bc60f3a09d9eb5a73886f79212b0e558b15ec" translate="yes" xml:space="preserve">
          <source>Syntactic sugar function for:</source>
          <target state="translated">다음을위한 구문 설탕 기능 :</target>
        </trans-unit>
        <trans-unit id="ae135cb4bf99d2d69cbac3f5fd417c5399be204b" translate="yes" xml:space="preserve">
          <source>Test environment options that will be passed to the &lt;code&gt;testEnvironment&lt;/code&gt;. The relevant options depend on the environment. For example you can override options given to &lt;a href=&quot;https://github.com/tmpvar/jsdom&quot;&gt;jsdom&lt;/a&gt; such as &lt;code&gt;{userAgent: &quot;Agent/007&quot;}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;testEnvironment&lt;/code&gt; 로 전달 될 테스트 환경 옵션 . 관련 옵션은 환경에 따라 다릅니다. 예를 들어 &lt;code&gt;{userAgent: &quot;Agent/007&quot;}&lt;/code&gt; 과 같이 &lt;a href=&quot;https://github.com/tmpvar/jsdom&quot;&gt;jsdom에&lt;/a&gt; 제공된 옵션을 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c29c26bd3478b20af1cf0e7c6178529d8355ed9c" translate="yes" xml:space="preserve">
          <source>Test environment options that will be passed to the &lt;code&gt;testEnvironment&lt;/code&gt;. The relevant options depend on the environment. For example, you can override options given to &lt;a href=&quot;https://github.com/jsdom/jsdom&quot;&gt;jsdom&lt;/a&gt; such as &lt;code&gt;{userAgent: &quot;Agent/007&quot;}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;testEnvironment&lt;/code&gt; 에 전달 될 테스트 환경 옵션입니다 . 관련 옵션은 환경에 따라 다릅니다. 예를 들어 &lt;code&gt;{userAgent: &quot;Agent/007&quot;}&lt;/code&gt; 과 같이 &lt;a href=&quot;https://github.com/jsdom/jsdom&quot;&gt;jsdom에&lt;/a&gt; 제공된 옵션을 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b55666a28ff3618a6bc88a5a3086460692f20399" translate="yes" xml:space="preserve">
          <source>Test files are normally ignored from collecting code coverage. With this option, you can overwrite this behavior and include otherwise ignored files in code coverage.</source>
          <target state="translated">테스트 파일은 일반적으로 코드 커버리지 수집에서 무시됩니다. 이 옵션을 사용하면이 동작을 덮어 쓰고 그렇지 않으면 무시되는 파일을 코드 범위에 포함시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32a2b6bfc1cb248afcfe7c96a42e9a946326cac4" translate="yes" xml:space="preserve">
          <source>Test files run inside a &lt;a href=&quot;https://nodejs.org/api/vm.html&quot;&gt;vm&lt;/a&gt;, which slows calls to global context properties (e.g. &lt;code&gt;Math&lt;/code&gt;). With this option you can specify extra properties to be defined inside the vm for faster lookups.</source>
          <target state="translated">테스트 파일은 &lt;a href=&quot;https://nodejs.org/api/vm.html&quot;&gt;vm&lt;/a&gt; 내에서 실행 되므로 전역 컨텍스트 속성 (예 : &lt;code&gt;Math&lt;/code&gt; )에 대한 호출 속도가 느려집니다 . 이 옵션을 사용하면 빠른 검색을 위해 vm 내에 정의 할 추가 속성을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da102bd566881f332f6aa321d898e870666704cb" translate="yes" xml:space="preserve">
          <source>Testing Asynchronous Code</source>
          <target state="translated">비동기 코드 테스트</target>
        </trans-unit>
        <trans-unit id="b4b91ec445494c8e5c6d2ecedd86aa56ac5179b5" translate="yes" xml:space="preserve">
          <source>Testing React Apps</source>
          <target state="translated">반응 형 앱 테스트</target>
        </trans-unit>
        <trans-unit id="5987105ad86879109c74631bcc686434d71992ae" translate="yes" xml:space="preserve">
          <source>Testing React Native Apps</source>
          <target state="translated">반응 네이티브 앱 테스트</target>
        </trans-unit>
        <trans-unit id="225fc2b10e9a9ea9b701c17da2b76bad93c7b747" translate="yes" xml:space="preserve">
          <source>Testing Web Frameworks</source>
          <target state="translated">웹 프레임 워크 테스트</target>
        </trans-unit>
        <trans-unit id="b228c0a462e4fbc62499ce73feb2a8eb75c4bd39" translate="yes" xml:space="preserve">
          <source>Tests are Extremely Slow on Docker and/or Continuous Integration (CI) server.</source>
          <target state="translated">Docker 및 / 또는 CI (Continuous Integration) 서버에서 테스트 속도가 매우 느립니다.</target>
        </trans-unit>
        <trans-unit id="c2d1541959da20e20096a585a0538d9010954c98" translate="yes" xml:space="preserve">
          <source>Tests are Failing and You Don't Know Why</source>
          <target state="translated">테스트가 실패하고 이유를 모른다</target>
        </trans-unit>
        <trans-unit id="3c8e525d4231c4190be70b1ad66cd616c6e2aa0f" translate="yes" xml:space="preserve">
          <source>Tests must be defined synchronously for Jest to be able to collect your tests.</source>
          <target state="translated">Jest가 테스트를 수집 할 수 있도록 테스트를 동기식으로 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="ba7f8377fd3129e903838676530e75e431a41733" translate="yes" xml:space="preserve">
          <source>That module can also contain a &lt;code&gt;getCacheKey&lt;/code&gt; function to generate a cache key to determine if the logic has changed and any cached artifacts relying on it should be discarded.</source>
          <target state="translated">해당 모듈에는 &lt;code&gt;getCacheKey&lt;/code&gt; 함수가 포함되어 로직이 변경되었는지 여부를 판별하기 위해 캐시 키를 생성하고 이에 의존하는 캐시 된 아티팩트를 버려야합니다.</target>
        </trans-unit>
        <trans-unit id="11a78e492a9e9e7ac361c24117bfb5e811bddb35" translate="yes" xml:space="preserve">
          <source>That's all there is to it! You can even update the snapshots with &lt;code&gt;--updateSnapshot&lt;/code&gt; or using the &lt;code&gt;u&lt;/code&gt; key in &lt;code&gt;--watch&lt;/code&gt; mode.</source>
          <target state="translated">그게 다야! &lt;code&gt;--updateSnapshot&lt;/code&gt; 을 사용하거나 &lt;code&gt;--watch&lt;/code&gt; 모드 에서 &lt;code&gt;u&lt;/code&gt; 키를 사용하여 스냅 샷을 업데이트 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa64459e4e03b6885bddfefb159ed4eb86b6825b" translate="yes" xml:space="preserve">
          <source>That's it! webpack is a complex and flexible tool, so you may have to make some adjustments to handle your specific application's needs. Luckily for most projects, Jest should be more than flexible enough to handle your webpack config.</source>
          <target state="translated">그게 다야! webpack은 복잡하고 유연한 도구이므로 특정 응용 프로그램의 요구를 처리하기 위해 약간의 조정이 필요할 수 있습니다. 운 좋게도 대부분의 프로젝트에서 Jest는 웹팩 구성을 처리 할 수있을만큼 유연해야합니다.</target>
        </trans-unit>
        <trans-unit id="7c3361ad0e93e6bc1e1c3de2667211b364b378cd" translate="yes" xml:space="preserve">
          <source>The 4 ways to create an ES6 class mock</source>
          <target state="translated">ES6 클래스 모형을 만드는 4 가지 방법</target>
        </trans-unit>
        <trans-unit id="95c25a4fa34143b1216d44b01d41f9f29688f727" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;configuration#clearmocks-boolean&quot;&gt;&lt;code&gt;clearMocks&lt;/code&gt;&lt;/a&gt; configuration option is available to clear mocks automatically between tests.</source>
          <target state="translated">&lt;a href=&quot;configuration#clearmocks-boolean&quot;&gt; &lt;code&gt;clearMocks&lt;/code&gt; 의&lt;/a&gt; 구성 옵션은 테스트 사이에 자동으로 모의 객체를 취소 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06c017e6536e5d9f6110e8d0080ca094a5e9ea11" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;configuration#modulenamemapper-objectstring-string&quot;&gt;&lt;code&gt;moduleNameMapper&lt;/code&gt;&lt;/a&gt; can be used to map a module path to a different module. By default the preset maps all images to an image stub module but if a module cannot be found this configuration option can help:</source>
          <target state="translated">&lt;a href=&quot;configuration#modulenamemapper-objectstring-string&quot;&gt; &lt;code&gt;moduleNameMapper&lt;/code&gt; 는&lt;/a&gt; 다른 모듈에 모듈 경로를 매핑하는 데 사용할 수 있습니다. 기본적으로 사전 설정은 모든 이미지를 이미지 스텁 모듈에 매핑하지만 모듈을 찾을 수없는 경우이 구성 옵션이 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7bf3050b5718b4b2d1e33abd9a62cda9462e096" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;configuration#modulenamemapper-objectstring-string--arraystring&quot;&gt;&lt;code&gt;moduleNameMapper&lt;/code&gt;&lt;/a&gt; can be used to map a module path to a different module. By default the preset maps all images to an image stub module but if a module cannot be found this configuration option can help:</source>
          <target state="translated">&lt;a href=&quot;configuration#modulenamemapper-objectstring-string--arraystring&quot;&gt; &lt;code&gt;moduleNameMapper&lt;/code&gt; 는&lt;/a&gt; 다른 모듈에 모듈 경로를 매핑하는 데 사용할 수 있습니다. 기본적으로 사전 설정은 모든 이미지를 이미지 스텁 모듈에 매핑하지만 모듈을 찾을 수없는 경우이 구성 옵션이 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4d9df38ccbce3dc2ed35e993bc8900c35030ec6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;configuration#restoremocks-boolean&quot;&gt;&lt;code&gt;restoreMocks&lt;/code&gt;&lt;/a&gt; configuration option is available to restore mocks automatically between tests.</source>
          <target state="translated">&lt;a href=&quot;configuration#restoremocks-boolean&quot;&gt; &lt;code&gt;restoreMocks&lt;/code&gt; 의&lt;/a&gt; 구성 옵션은 테스트 사이에 자동으로 모의 객체를 복원 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de8e5c7bbe65466e0240efdae7e25dee3a9f754c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;configuration#transformignorepatterns-arraystring&quot;&gt;&lt;code&gt;transformIgnorePatterns&lt;/code&gt;&lt;/a&gt; option can be used to specify which files shall be transformed by Babel. Many react-native npm modules unfortunately don't pre-compile their source code before publishing.</source>
          <target state="translated">&lt;a href=&quot;configuration#transformignorepatterns-arraystring&quot;&gt; &lt;code&gt;transformIgnorePatterns&lt;/code&gt; 의&lt;/a&gt; 옵션은 파일이 바벨에 의해 변형된다 지정하는 데 사용할 수 있습니다. 불행히도 많은 반응 네이티브 npm 모듈은 게시하기 전에 소스 코드를 미리 컴파일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f1fd9f27ef141c8e346e850781739fd26da2e8bd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;configuration#transformignorepatterns-arraystring&quot;&gt;&lt;code&gt;transformIgnorePatterns&lt;/code&gt;&lt;/a&gt; option can be used to whitelist or blacklist files from being transformed with Babel. Many react-native npm modules unfortunately don't pre-compile their source code before publishing.</source>
          <target state="translated">&lt;a href=&quot;configuration#transformignorepatterns-arraystring&quot;&gt; &lt;code&gt;transformIgnorePatterns&lt;/code&gt; 의&lt;/a&gt; 옵션은 바벨로 전환되는 화이트리스트 또는 블랙리스트 파일을 사용할 수 있습니다. 불행히도 많은 반응 네이티브 npm 모듈은 게시하기 전에 소스 코드를 사전 컴파일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5fcd870eb6449696a26dbe9a35105b1b3f0eb6a3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;./src/api/very-important-module.js&lt;/code&gt; file has less than 100% coverage.</source>
          <target state="translated">&lt;code&gt;./src/api/very-important-module.js&lt;/code&gt; 파일이 100 % 미만의 범위를 가지고있다.</target>
        </trans-unit>
        <trans-unit id="a4b1bdae91ac8b4ba9e5526619539ee09ec8ff0b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;./src/components&lt;/code&gt; directory has less than 40% branch or statement coverage.</source>
          <target state="translated">&lt;code&gt;./src/components&lt;/code&gt; 의 디렉토리는 40 % 미만의 지점 또는 문 범위를 가지고있다.</target>
        </trans-unit>
        <trans-unit id="afcc7bfb1a0f92aed03ab154b1ea46d01fb61f0c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expect.assertions(2)&lt;/code&gt; call ensures that both callbacks actually get called.</source>
          <target state="translated">&lt;code&gt;expect.assertions(2)&lt;/code&gt; 콜 보장하지만 모두 콜백 실제로 전화를받을 것이다.</target>
        </trans-unit>
        <trans-unit id="8801cb3154dc90b6dabeb0f8d6adc04b7c96a994" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expect.hasAssertions()&lt;/code&gt; call ensures that the &lt;code&gt;prepareState&lt;/code&gt; callback actually gets called.</source>
          <target state="translated">&lt;code&gt;expect.hasAssertions()&lt;/code&gt; 호출 보장하지만이 있음을 &lt;code&gt;prepareState&lt;/code&gt; 의 콜백은 실제로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="6c3326411c984dac96e58b8dd16be60c0de3724a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;expect&lt;/code&gt; function is used every time you want to test a value. You will rarely call &lt;code&gt;expect&lt;/code&gt; by itself. Instead, you will use &lt;code&gt;expect&lt;/code&gt; along with a &quot;matcher&quot; function to assert something about a value.</source>
          <target state="translated">&lt;code&gt;expect&lt;/code&gt; 기능을 사용하면 값을 테스트 할 때마다 사용됩니다. 당신은 그 자체로 거의 &lt;code&gt;expect&lt;/code&gt; 하지 않습니다 . 대신, &quot;매치 (matcher)&quot;함수와 함께 &lt;code&gt;expect&lt;/code&gt; 를 사용 하여 값에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="6594bb5f273e5a4f7094c361061889db4f707818" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extract&lt;/code&gt; function should return an iterable (&lt;code&gt;Array&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt;, etc.) with the dependencies found in the code.</source>
          <target state="translated">&lt;code&gt;extract&lt;/code&gt; 함수는 반복 가능한 (돌려 &lt;code&gt;Array&lt;/code&gt; , &lt;code&gt;Set&lt;/code&gt; 코드 검색된 의존성 등).</target>
        </trans-unit>
        <trans-unit id="5539a986bbbbf8c351471c1981c9549b0ae07121" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jest&lt;/code&gt; command line runner has a number of useful options. You can run &lt;code&gt;jest --help&lt;/code&gt; to view all available options. Many of the options shown below can also be used together to run tests exactly the way you want. Every one of Jest's &lt;a href=&quot;configuration&quot;&gt;Configuration&lt;/a&gt; options can also be specified through the CLI.</source>
          <target state="translated">&lt;code&gt;jest&lt;/code&gt; 명령 행 주자 유용한 옵션이 있습니다. &lt;code&gt;jest --help&lt;/code&gt; 를 실행 하여 사용 가능한 모든 옵션을 볼 수 있습니다. 아래 표시된 많은 옵션을 함께 사용하여 원하는 방식으로 테스트를 실행할 수도 있습니다. Jest의 모든 &lt;a href=&quot;configuration&quot;&gt;구성&lt;/a&gt; 옵션은 CLI를 통해 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8cb0dc4d98327301d27ed47332b5824609aeec5f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jest&lt;/code&gt; object is automatically in scope within every test file. The methods in the &lt;code&gt;jest&lt;/code&gt; object help create mocks and let you control Jest's overall behavior.</source>
          <target state="translated">&lt;code&gt;jest&lt;/code&gt; 대상은 모든 테스트 파일 내의 범위에 자동입니다. &lt;code&gt;jest&lt;/code&gt; 객체 의 메소드는 모의 객체를 생성하고 Jest의 전반적인 동작을 제어 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="71d9b4d1b6d2fe2af134fea43560b4e2597cb34d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jest&lt;/code&gt; object is automatically in scope within every test file. The methods in the &lt;code&gt;jest&lt;/code&gt; object help create mocks and let you control Jest's overall behavior. It can also be imported explicitly by via &lt;code&gt;import {jest} from '@jest/globals'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;jest&lt;/code&gt; 대상은 모든 테스트 파일 내의 범위에 자동입니다. &lt;code&gt;jest&lt;/code&gt; 객체 의 메서드는 모의를 만드는 데 도움이되며 Jest의 전반적인 동작을 제어 할 수 있습니다. &lt;code&gt;import {jest} from '@jest/globals'&lt;/code&gt; 통해 명시 적으로 가져올 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b7b8cc683ede161fc025b891451a1f71de3a0d36" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mockImplementation&lt;/code&gt; method is useful when you need to define the default implementation of a mock function that is created from another module:</source>
          <target state="translated">&lt;code&gt;mockImplementation&lt;/code&gt; 의 다른 모듈에서 생성 된 모의 기능의 기본 구현을 정의 할 때 방법은 유용하다 :</target>
        </trans-unit>
        <trans-unit id="f414ca5debc72d67a32f4e6f4214b85eb7903c2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;value&lt;/code&gt; property contains the value that was thrown or returned. &lt;code&gt;value&lt;/code&gt; is undefined when &lt;code&gt;type === 'incomplete'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; 속성을 던져 또는 반환 된 값을 포함합니다. &lt;code&gt;type === 'incomplete'&lt;/code&gt; 경우 &lt;code&gt;value&lt;/code&gt; 이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="60ae20badadde4a0ac472d6382213bf5645d769e" translate="yes" xml:space="preserve">
          <source>The Chrome Developer Tools will be displayed, and a breakpoint will be set at the first line of the Jest CLI script (this is done to give you time to open the developer tools and to prevent Jest from executing before you have time to do so). Click the button that looks like a &quot;play&quot; button in the upper right hand side of the screen to continue execution. When Jest executes the test that contains the &lt;code&gt;debugger&lt;/code&gt; statement, execution will pause and you can examine the current scope and call stack.</source>
          <target state="translated">Chrome 개발자 도구가 표시되고 Jest CLI 스크립트의 첫 번째 줄에 중단 점이 설정됩니다 (이것은 개발자 도구를 열 시간을 갖기 전에 Jest가 실행되지 않도록하기위한 것입니다) . 실행을 계속하려면 화면 오른쪽 상단에있는 &quot;재생&quot;버튼 모양의 버튼을 클릭하십시오. Jest가 &lt;code&gt;debugger&lt;/code&gt; 문 이 포함 된 테스트를 실행하면 실행이 일시 중지되고 현재 범위 및 호출 스택을 검사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdefcc002eddfb7f6c28f9c7a1871357f57fe794" translate="yes" xml:space="preserve">
          <source>The Jest Object</source>
          <target state="translated">농담 개체</target>
        </trans-unit>
        <trans-unit id="af5336b9f0d6a51b49389a0b7ed3fd6e4c3872c6" translate="yes" xml:space="preserve">
          <source>The Jest preset built into &lt;code&gt;react-native&lt;/code&gt; comes with a few default mocks that are applied on a react-native repository. However some react-native components or third party components rely on native code to be rendered. In such cases, Jest's manual mocking system can help to mock out the underlying implementation.</source>
          <target state="translated">&lt;code&gt;react-native&lt;/code&gt; 에 내장 된 Jest 사전 설정 에는 react-native 저장소에 적용되는 몇 가지 기본 모형이 제공됩니다. 그러나 일부 반응 네이티브 구성 요소 또는 타사 구성 요소는 기본 코드를 사용하여 렌더링됩니다. 이러한 경우 Jest의 수동 조롱 시스템은 기본 구현을 조롱하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e84d67c7006e50386362acd2af1cef9b46290e6c" translate="yes" xml:space="preserve">
          <source>The Jest preset built into &lt;code&gt;react-native&lt;/code&gt; comes with a few default mocks that are applied on a react-native repository. However, some react-native components or third party components rely on native code to be rendered. In such cases, Jest's manual mocking system can help to mock out the underlying implementation.</source>
          <target state="translated">&lt;code&gt;react-native&lt;/code&gt; 에 내장 된 Jest 프리셋 은 react-native 저장소에 적용되는 몇 가지 기본 모의와 함께 제공됩니다. 그러나 일부 반응 네이티브 구성 요소 또는 타사 구성 요소는 렌더링 할 네이티브 코드에 의존합니다. 이러한 경우 Jest의 수동 조롱 시스템은 기본 구현을 조롱하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2453c12b4a4f24fbc05ce1e4c46073678639c15d" translate="yes" xml:space="preserve">
          <source>The Jest watch plugin system provides a way to hook into specific parts of Jest and to define watch mode menu prompts that execute code on key press. Combined, these features allow you to develop interactive experiences custom for your workflow.</source>
          <target state="translated">Jest watch 플러그인 시스템은 Jest의 특정 부분에 연결하고 키를 누를 때 코드를 실행하는 watch 모드 메뉴 프롬프트를 정의하는 방법을 제공합니다. 이러한 기능을 결합하면 워크 플로에 맞는 대화식 환경을 개발할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9caca20f4fce1e72a9edd33743ac65377cd25c74" translate="yes" xml:space="preserve">
          <source>The argument to &lt;code&gt;expect&lt;/code&gt; should be the value that your code produces, and any argument to the matcher should be the correct value. If you mix them up, your tests will still work, but the error messages on failing tests will look strange.</source>
          <target state="translated">&lt;code&gt;expect&lt;/code&gt; 되는 인수 는 코드에서 생성하는 값이어야하며 매처에 대한 모든 인수는 올바른 값이어야합니다. 그것들을 섞어도 테스트는 여전히 작동하지만 테스트 실패에 대한 오류 메시지는 이상하게 보일 것입니다.</target>
        </trans-unit>
        <trans-unit id="8cc68f24cef4585983c9f185a90ee734f90aa8ae" translate="yes" xml:space="preserve">
          <source>The class may optionally expose a &lt;code&gt;handleTestEvent&lt;/code&gt; method to bind to events fired by &lt;a href=&quot;https://github.com/facebook/jest/tree/master/packages/jest-circus&quot;&gt;&lt;code&gt;jest-circus&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">클래스는 선택적으로 &lt;code&gt;handleTestEvent&lt;/code&gt; 메소드를 노출시켜 jest &lt;a href=&quot;https://github.com/facebook/jest/tree/master/packages/jest-circus&quot;&gt; &lt;code&gt;jest-circus&lt;/code&gt; &lt;/a&gt; 가 시작한 이벤트에 바인딩 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="421f185691a20ea0fadf51a0d254c03ed3247afa" translate="yes" xml:space="preserve">
          <source>The class may optionally expose an asynchronous &lt;code&gt;handleTestEvent&lt;/code&gt; method to bind to events fired by &lt;a href=&quot;https://github.com/facebook/jest/tree/master/packages/jest-circus&quot;&gt;&lt;code&gt;jest-circus&lt;/code&gt;&lt;/a&gt;. Normally, &lt;code&gt;jest-circus&lt;/code&gt; test runner would pause until a promise returned from &lt;code&gt;handleTestEvent&lt;/code&gt; gets fulfilled, &lt;strong&gt;except for the next events&lt;/strong&gt;: &lt;code&gt;start_describe_definition&lt;/code&gt;, &lt;code&gt;finish_describe_definition&lt;/code&gt;, &lt;code&gt;add_hook&lt;/code&gt;, &lt;code&gt;add_test&lt;/code&gt; or &lt;code&gt;error&lt;/code&gt; (for the up-to-date list you can look at &lt;a href=&quot;https://github.com/facebook/jest/tree/master/packages/jest-types/src/Circus.ts&quot;&gt;SyncEvent type in the types definitions&lt;/a&gt;). That is caused by backward compatibility reasons and &lt;code&gt;process.on('unhandledRejection', callback)&lt;/code&gt; signature, but that usually should not be a problem for most of the use cases.</source>
          <target state="translated">클래스는 선택적으로 비동기 &lt;code&gt;handleTestEvent&lt;/code&gt; 메서드를 노출하여 &lt;a href=&quot;https://github.com/facebook/jest/tree/master/packages/jest-circus&quot;&gt; &lt;code&gt;jest-circus&lt;/code&gt; 에&lt;/a&gt; 의해 발생한 이벤트에 바인딩 할 수 있습니다 . 일반적으로 &lt;code&gt;jest-circus&lt;/code&gt; 테스트 러너는 &lt;strong&gt;다음 이벤트를 제외하고 &lt;/strong&gt; &lt;code&gt;handleTestEvent&lt;/code&gt; 에서 반환 된 promise 가 충족 될 때까지 일시 중지 &lt;strong&gt;합니다&lt;/strong&gt; . &lt;code&gt;start_describe_definition&lt;/code&gt; , &lt;code&gt;finish_describe_definition&lt;/code&gt; , &lt;code&gt;add_hook&lt;/code&gt; , &lt;code&gt;add_test&lt;/code&gt; 또는 &lt;code&gt;error&lt;/code&gt; (최신 목록의 &lt;a href=&quot;https://github.com/facebook/jest/tree/master/packages/jest-types/src/Circus.ts&quot;&gt;경우 유형 정의&lt;/a&gt; ). 이는 이전 버전과의 호환성 이유 및 &lt;code&gt;process.on('unhandledRejection', callback)&lt;/code&gt; 서명으로 인해 발생 하지만 일반적으로 대부분의 사용 사례에서 문제가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="505efbd4b63a11e029fe3900fcf34d5ab8217315" translate="yes" xml:space="preserve">
          <source>The code for this example is available at &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/async&quot;&gt;examples/async&lt;/a&gt;.</source>
          <target state="translated">이 예제의 코드는 &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/async&quot;&gt;examples / async&lt;/a&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="61f42c40ba4012116e65e0172c4574798fdcc3a1" translate="yes" xml:space="preserve">
          <source>The code for this example is available at &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/enzyme&quot;&gt;examples/enzyme&lt;/a&gt;.</source>
          <target state="translated">이 예제의 코드는 &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/enzyme&quot;&gt;examples / enzyme&lt;/a&gt; 에서 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="4e772aeae1e1e3865bc4cf9718bec60261ce607b" translate="yes" xml:space="preserve">
          <source>The code for this example is available at &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/jquery&quot;&gt;examples/jquery&lt;/a&gt;.</source>
          <target state="translated">이 예제의 코드는 &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/jquery&quot;&gt;examples / jquery&lt;/a&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3e7eb572425bcca3655b70ad564fc1692cbc457f" translate="yes" xml:space="preserve">
          <source>The code for this example is available at &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/manual-mocks&quot;&gt;examples/manual-mocks&lt;/a&gt;.</source>
          <target state="translated">이 예제의 코드는 &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/manual-mocks&quot;&gt;examples / manual-mocks&lt;/a&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d0665793600a54f70d63deadff14baccb32f7bff" translate="yes" xml:space="preserve">
          <source>The code for this example is available at &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/react-native&quot;&gt;examples/react-native&lt;/a&gt;.</source>
          <target state="translated">이 예제의 코드는 &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/react-native&quot;&gt;examples / react-native&lt;/a&gt; 에서 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="9347a0f5e3be6b1f8c7f0c4795c7b215bb18ebd4" translate="yes" xml:space="preserve">
          <source>The code for this example is available at &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/react-testing-library&quot;&gt;examples/react-testing-library&lt;/a&gt;.</source>
          <target state="translated">이 예제의 코드는 &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/react-testing-library&quot;&gt;examples / react-testing-library에서 사용 가능&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="b032ec230190e1c4fc446fee9c02430a5dbbd77b" translate="yes" xml:space="preserve">
          <source>The code for this example is available at &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/snapshot&quot;&gt;examples/snapshot&lt;/a&gt;.</source>
          <target state="translated">이 예제의 코드는 &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/snapshot&quot;&gt;examples / snapshot&lt;/a&gt; 에서 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="dc4f949fe92e0d8c8e3b3a03859bac8aa481d502" translate="yes" xml:space="preserve">
          <source>The code for this example is available at &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/timer&quot;&gt;examples/timer&lt;/a&gt;.</source>
          <target state="translated">이 예제의 코드는 &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/timer&quot;&gt;examples / timer&lt;/a&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f12a555ea8e1761a86877b27341850cacd56ac73" translate="yes" xml:space="preserve">
          <source>The community around Jest is working hard to make the testing experience even greater.</source>
          <target state="translated">Jest 주변의 커뮤니티는 테스트 경험을 더욱 향상시키기 위해 열심히 노력하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="7585ea7c7f78a15b022764598b8197c90e7876b0" translate="yes" xml:space="preserve">
          <source>The directory where Jest should output its coverage files.</source>
          <target state="translated">Jest가 적용 범위 파일을 출력해야하는 디렉토리입니다.</target>
        </trans-unit>
        <trans-unit id="376f21d7672ef7ba555cd8e4de07656368d480d0" translate="yes" xml:space="preserve">
          <source>The directory where Jest should store its cached dependency information.</source>
          <target state="translated">Jest가 캐시 된 종속성 정보를 저장해야하는 디렉토리입니다.</target>
        </trans-unit>
        <trans-unit id="b455adf26e8057d7ba70aa7e64159f9222cf09e6" translate="yes" xml:space="preserve">
          <source>The easiest way to debug Jest tests in &lt;a href=&quot;https://www.jetbrains.com/webstorm/&quot;&gt;WebStorm&lt;/a&gt; is using &lt;code&gt;Jest run/debug configuration&lt;/code&gt;. It will launch tests and automatically attach debugger.</source>
          <target state="translated">&lt;a href=&quot;https://www.jetbrains.com/webstorm/&quot;&gt;WebStorm&lt;/a&gt; 에서 Jest 테스트를 디버깅하는 가장 쉬운 방법 은 &lt;code&gt;Jest run/debug configuration&lt;/code&gt; 입니다. 테스트를 시작하고 자동으로 디버거를 연결합니다.</target>
        </trans-unit>
        <trans-unit id="9c5fa79dfce65458f929b1ce12610301e9cf3865" translate="yes" xml:space="preserve">
          <source>The example mock shown here uses &lt;a href=&quot;jest-object#jestcreatemockfrommodulemodulename&quot;&gt;&lt;code&gt;jest.createMockFromModule&lt;/code&gt;&lt;/a&gt; to generate an automatic mock, and overrides its default behavior. This is the recommended approach, but is completely optional. If you do not want to use the automatic mock at all, you can export your own functions from the mock file. One downside to fully manual mocks is that they're manual &amp;ndash; meaning you have to manually update them any time the module they are mocking changes. Because of this, it's best to use or extend the automatic mock when it works for your needs.</source>
          <target state="translated">여기에 표시된 예제 mock은 &lt;a href=&quot;jest-object#jestcreatemockfrommodulemodulename&quot;&gt; &lt;code&gt;jest.createMockFromModule&lt;/code&gt; &lt;/a&gt; 을 사용하여 자동 mock을 생성하고 기본 동작을 재정의합니다. 이것은 권장되는 접근 방식이지만 완전히 선택 사항입니다. 자동 모의를 전혀 사용하지 않으려면 모의 파일에서 자신의 함수를 내보낼 수 있습니다. 완전 수동 모의에 대한 한 가지 단점은 수동이라는 것입니다. 즉, 모의 모듈이 변경 될 때마다 수동으로 업데이트해야합니다. 이 때문에 필요에 따라 자동 모의를 사용하거나 확장하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="ecbe9621df2404d5fbb33e2600044e0b27c47481" translate="yes" xml:space="preserve">
          <source>The example mock shown here uses &lt;a href=&quot;jest-object#jestgenmockfrommodulemodulename&quot;&gt;&lt;code&gt;jest.genMockFromModule&lt;/code&gt;&lt;/a&gt; to generate an automatic mock, and overrides its default behavior. This is the recommended approach, but is completely optional. If you do not want to use the automatic mock at all, you can export your own functions from the mock file. One downside to fully manual mocks is that they're manual &amp;ndash; meaning you have to manually update them any time the module they are mocking changes. Because of this, it's best to use or extend the automatic mock when it works for your needs.</source>
          <target state="translated">여기에 표시된 모의 예제는 &lt;a href=&quot;jest-object#jestgenmockfrommodulemodulename&quot;&gt; &lt;code&gt;jest.genMockFromModule&lt;/code&gt; &lt;/a&gt; 을 사용하여 자동 모의를 생성하고 기본 동작을 대체합니다. 이것은 권장되는 접근 방법이지만 완전히 선택 사항입니다. 자동 모의를 전혀 사용하지 않으려면 모의 파일에서 자신의 기능을 내보낼 수 있습니다. 완전 수동 모의 한 가지 단점은 수동 모의입니다. 즉 모의 모듈이 변경 될 때마다 수동으로 갱신해야합니다. 이 때문에 필요에 따라 자동 목을 사용하거나 확장하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="2508586aa35287e8b27df6e110475235bd694e90" translate="yes" xml:space="preserve">
          <source>The exit code Jest returns on test failure.</source>
          <target state="translated">테스트 실패시 종료 코드 Jest가 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e4a4a43d898d3af6802055c9164972d36548014d" translate="yes" xml:space="preserve">
          <source>The first argument is the test name; the second argument is a function that contains the expectations to test. The third argument (optional) is &lt;code&gt;timeout&lt;/code&gt; (in milliseconds) for specifying how long to wait before aborting. &lt;em&gt;Note: The default timeout is 5 seconds.&lt;/em&gt;</source>
          <target state="translated">첫 번째 인수는 테스트 이름입니다. 두 번째 인수는 테스트 할 기대치를 포함하는 함수입니다. 세 번째 인수 (선택 사항)는 중단 전에 대기 시간을 지정하기위한 &lt;code&gt;timeout&lt;/code&gt; (밀리 초)입니다. &lt;em&gt;참고 : 기본 시간 제한은 5 초입니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2bbf7bf0829c4a7923096dc1c283c4faad2abdf7" translate="yes" xml:space="preserve">
          <source>The first argument is the test name; the second argument is an asynchronous function that contains the expectations to test. The third argument (optional) is &lt;code&gt;timeout&lt;/code&gt; (in milliseconds) for specifying how long to wait before aborting. &lt;em&gt;Note: The default timeout is 5 seconds.&lt;/em&gt;</source>
          <target state="translated">첫 번째 인수는 테스트 이름입니다. 두 번째 인수는 테스트 할 기대치를 포함하는 비동기 함수입니다. 세 번째 인수 (선택 사항)는 중단하기 전에 대기 할 시간을 지정하는 &lt;code&gt;timeout&lt;/code&gt; (밀리 초)입니다. &lt;em&gt;참고 : 기본 제한 시간은 5 초입니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6838de5b16cb59f34f7a719f1e8d3453345e067e" translate="yes" xml:space="preserve">
          <source>The first time this test is run, Jest creates a &lt;a href=&quot;https://github.com/facebook/jest/blob/master/examples/snapshot/__tests__/__snapshots__/link.react.test.js.snap&quot;&gt;snapshot file&lt;/a&gt; that looks like this:</source>
          <target state="translated">이 테스트가 처음 실행될 때 Jest 는 다음과 같은 &lt;a href=&quot;https://github.com/facebook/jest/blob/master/examples/snapshot/__tests__/__snapshots__/link.react.test.js.snap&quot;&gt;스냅 샷 파일&lt;/a&gt; 을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="1492463266cc80f52fcf093c60f36ae239754aca" translate="yes" xml:space="preserve">
          <source>The following example contains a &lt;code&gt;houseForSale&lt;/code&gt; object with nested properties. We are using &lt;code&gt;toHaveProperty&lt;/code&gt; to check for the existence and values of various properties in the object.</source>
          <target state="translated">다음 예제에는 중첩 특성 이있는 &lt;code&gt;houseForSale&lt;/code&gt; 오브젝트가 있습니다. 우리는 &lt;code&gt;toHaveProperty&lt;/code&gt; 를 사용 하여 객체의 다양한 속성의 존재와 값을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="6b2cf0dc88bf9d13b702ff5e6f3622ae5afb3db3" translate="yes" xml:space="preserve">
          <source>The following examples will assume you have an understanding of how &lt;a href=&quot;es6-class-mocks&quot;&gt;Jest mock classes work with JavaScript&lt;/a&gt;.</source>
          <target state="translated">다음 예제에서는 &lt;a href=&quot;es6-class-mocks&quot;&gt;Jest 모의 클래스가 JavaScript에서 작동&lt;/a&gt; 하는 방식을 이해하고 있다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="30789d18cf6d3429a995f05a497818957e194817" translate="yes" xml:space="preserve">
          <source>The following examples will assume you have an understanding of how &lt;a href=&quot;mock-functions&quot;&gt;Jest mock functions work with JavaScript&lt;/a&gt;.</source>
          <target state="translated">다음 예제에서는 &lt;a href=&quot;mock-functions&quot;&gt;Jest 모의 함수가 JavaScript에서 작동&lt;/a&gt; 하는 방식을 이해하고 있다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="a7f734d3eeaab81fca3e29f3523738b60fc7cd77" translate="yes" xml:space="preserve">
          <source>The following is a visualization of the default regex:</source>
          <target state="translated">다음은 기본 정규식의 시각화입니다.</target>
        </trans-unit>
        <trans-unit id="47cef9c94451278775edf865a9789b6d6b64cf3f" translate="yes" xml:space="preserve">
          <source>The following keys for built-in functionality &lt;strong&gt;can be overwritten&lt;/strong&gt; :</source>
          <target state="translated">내장 기능에 대한 다음 키를 &lt;strong&gt;덮어 쓸 수 있습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="d021e17efe498d997940dd70ef8fa277b5a2e9cd" translate="yes" xml:space="preserve">
          <source>The function being tested adds an event listener on the &lt;code&gt;#button&lt;/code&gt; DOM element, so we need to set up our DOM correctly for the test. Jest ships with &lt;code&gt;jsdom&lt;/code&gt; which simulates a DOM environment as if you were in the browser. This means that every DOM API that we call can be observed in the same way it would be observed in a browser!</source>
          <target state="translated">테스트되는 함수는 &lt;code&gt;#button&lt;/code&gt; DOM 요소 에 이벤트 리스너를 추가 하므로 테스트를 위해 DOM을 올바르게 설정해야합니다. Jest 는 브라우저에있는 것처럼 DOM 환경을 시뮬레이션하는 &lt;code&gt;jsdom&lt;/code&gt; 과 함께 제공됩니다 . 이것은 우리가 호출하는 모든 DOM API가 브라우저에서 관찰되는 것과 같은 방식으로 관찰 될 수 있음을 의미합니다!</target>
        </trans-unit>
        <trans-unit id="6596e95c4d26bf49becdf01cb51e6fc651959a04" translate="yes" xml:space="preserve">
          <source>The function should either return a path to the module that should be resolved or throw an error if the module can't be found.</source>
          <target state="translated">이 함수는 해결해야 할 모듈의 경로를 반환하거나 모듈을 찾을 수 없으면 오류를 발생시켜야합니다.</target>
        </trans-unit>
        <trans-unit id="aab58f520069315bb0a84d63dee876237963ccad" translate="yes" xml:space="preserve">
          <source>The glob patterns Jest uses to detect test files. By default it looks for &lt;code&gt;.js&lt;/code&gt;, &lt;code&gt;.jsx&lt;/code&gt;, &lt;code&gt;.ts&lt;/code&gt; and &lt;code&gt;.tsx&lt;/code&gt; files inside of &lt;code&gt;__tests__&lt;/code&gt; folders, as well as any files with a suffix of &lt;code&gt;.test&lt;/code&gt; or &lt;code&gt;.spec&lt;/code&gt; (e.g. &lt;code&gt;Component.test.js&lt;/code&gt; or &lt;code&gt;Component.spec.js&lt;/code&gt;). It will also find files called &lt;code&gt;test.js&lt;/code&gt; or &lt;code&gt;spec.js&lt;/code&gt;.</source>
          <target state="translated">Jest가 테스트 파일을 탐지하기 위해 사용하는 glob 패턴. 기본적 으로 &lt;code&gt;__tests__&lt;/code&gt; 폴더 내의 &lt;code&gt;.js&lt;/code&gt; , &lt;code&gt;.jsx&lt;/code&gt; , &lt;code&gt;.ts&lt;/code&gt; 및 &lt;code&gt;.tsx&lt;/code&gt; 파일과 접미사가 &lt;code&gt;.test&lt;/code&gt; 또는 &lt;code&gt;.spec&lt;/code&gt; 인 파일 (예 : &lt;code&gt;Component.test.js&lt;/code&gt; 또는 &lt;code&gt;Component.spec.js&lt;/code&gt; )을 찾습니다. . &lt;code&gt;test.js&lt;/code&gt; 또는 &lt;code&gt;spec.js&lt;/code&gt; 라는 파일도 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1723fc61e3e4203902e2769fce84e0f47e6816e8" translate="yes" xml:space="preserve">
          <source>The goal is to make it easy to review snapshots in pull requests, and fight against the habit of regenerating snapshots when test suites fail instead of examining the root causes of their failure.</source>
          <target state="translated">목표는 풀 요청에서 스냅 샷을 쉽게 검토하고, 테스트 스위트가 실패의 근본 원인을 검사하는 대신 실패 할 때 스냅 샷을 다시 생성하는 습관과 싸우는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2689ebeac189b738f558285371fec779e8a24bfd" translate="yes" xml:space="preserve">
          <source>The jest-community org maintains an &lt;a href=&quot;https://github.com/jest-community/awesome-jest&quot;&gt;awesome-jest&lt;/a&gt; list of great projects and resources related to Jest, this includes all projects not just the ones in the jest-community org.</source>
          <target state="translated">농담 - 지역 사회 조직이 유지 &lt;a href=&quot;https://github.com/jest-community/awesome-jest&quot;&gt;멋진-농담&lt;/a&gt; 농담에 관련된 중대한 프로젝트와 자원의 목록을, 이것은 농담 - 지역 사회 조직의 장치뿐 아니라 모든 프로젝트가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="327140711518544eb69d91ed359d0f86086c942f" translate="yes" xml:space="preserve">
          <source>The manual mock equivalent of this would be:</source>
          <target state="translated">이에 상응하는 수동 모의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="968ed8d3094b9f92af942c92765f9081682130bf" translate="yes" xml:space="preserve">
          <source>The module factory function passed to &lt;code&gt;jest.mock(path, moduleFactory)&lt;/code&gt; can be a HOF that returns a function*. This will allow calling &lt;code&gt;new&lt;/code&gt; on the mock. Again, this allows you to inject different behavior for testing, but does not provide a way to spy on calls.</source>
          <target state="translated">&lt;code&gt;jest.mock(path, moduleFactory)&lt;/code&gt; 전달 된 모듈 팩토리 함수 는 함수 *를 리턴하는 HOF 일 수 있습니다. 이렇게하면 모의에서 &lt;code&gt;new&lt;/code&gt; 전화를 걸 수 있습니다. 다시 말하지만 테스트를 위해 다른 동작을 주입 할 수는 있지만 전화를 감시 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="4376614c6f08aa0261023a608b95c6492b8e9525" translate="yes" xml:space="preserve">
          <source>The most common asynchronous pattern is callbacks.</source>
          <target state="translated">가장 일반적인 비동기 패턴은 콜백입니다.</target>
        </trans-unit>
        <trans-unit id="0274127a2409aa50ab0b03082620b24a366d505d" translate="yes" xml:space="preserve">
          <source>The most common use of this API is for specifying the module a given test intends to be testing (and thus doesn't want automatically mocked).</source>
          <target state="translated">이 API의 가장 일반적인 용도는 주어진 테스트에서 테스트하려는 모듈을 지정하는 것입니다 (따라서 자동 조롱하고 싶지 않음).</target>
        </trans-unit>
        <trans-unit id="6cba2620d821c40d1a35b89d6a989fe10a704a0f" translate="yes" xml:space="preserve">
          <source>The most useful ones are &lt;code&gt;matcherHint&lt;/code&gt;, &lt;code&gt;printExpected&lt;/code&gt; and &lt;code&gt;printReceived&lt;/code&gt; to format the error messages nicely. For example, take a look at the implementation for the &lt;code&gt;toBe&lt;/code&gt; matcher:</source>
          <target state="translated">가장 유용한 것은 &lt;code&gt;matcherHint&lt;/code&gt; , &lt;code&gt;printExpected&lt;/code&gt; 및 &lt;code&gt;printReceived&lt;/code&gt; 이며 오류 메시지를 멋지게 형식화합니다. 예를 들어, &lt;code&gt;toBe&lt;/code&gt; 매처 의 구현을 살펴보십시오 .</target>
        </trans-unit>
        <trans-unit id="e952463962a1b689236ab9f6e17c97ccd482a4f3" translate="yes" xml:space="preserve">
          <source>The native timer functions (i.e., &lt;code&gt;setTimeout&lt;/code&gt;, &lt;code&gt;setInterval&lt;/code&gt;, &lt;code&gt;clearTimeout&lt;/code&gt;, &lt;code&gt;clearInterval&lt;/code&gt;) are less than ideal for a testing environment since they depend on real time to elapse. Jest can swap out timers with functions that allow you to control the passage of time. &lt;a href=&quot;https://www.youtube.com/watch?v=QZoJ2Pt27BY&quot;&gt;Great Scott!&lt;/a&gt;</source>
          <target state="translated">기본 타이머 함수 (예 : &lt;code&gt;setTimeout&lt;/code&gt; , &lt;code&gt;setInterval&lt;/code&gt; , &lt;code&gt;clearTimeout&lt;/code&gt; , &lt;code&gt;clearInterval&lt;/code&gt; )는 실시간 경과 시간에 의존하므로 테스트 환경에 적합하지 않습니다. Jest는 시간의 흐름을 제어 할 수있는 기능으로 타이머를 교체 할 수 있습니다. &lt;a href=&quot;https://www.youtube.com/watch?v=QZoJ2Pt27BY&quot;&gt;그레이트 스캇!&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0c7bd0e4ffc67ba49a20c3a2e181946f66fdd8b6" translate="yes" xml:space="preserve">
          <source>The next time you run Jest, &lt;code&gt;tree&lt;/code&gt; will be evaluated, and a snapshot will be written as an argument to &lt;code&gt;toMatchInlineSnapshot&lt;/code&gt;:</source>
          <target state="translated">다음에 Jest를 실행하면 &lt;code&gt;tree&lt;/code&gt; 가 평가되고 스냅 샷이 &lt;code&gt;toMatchInlineSnapshot&lt;/code&gt; 에 대한 인수로 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="5b848fe1137b4b9b68da4deb8ef3d11d697c37f6" translate="yes" xml:space="preserve">
          <source>The next time you run the tests, the rendered output will be compared to the previously created snapshot. The snapshot should be committed along code changes. When a snapshot test fails, you need to inspect whether it is an intended or unintended change. If the change is expected you can invoke Jest with &lt;code&gt;jest -u&lt;/code&gt; to overwrite the existing snapshot.</source>
          <target state="translated">다음에 테스트를 실행하면 렌더링 된 출력이 이전에 생성 된 스냅 샷과 비교됩니다. 코드 변경 사항에 따라 스냅 샷을 커밋해야합니다. 스냅 샷 테스트가 실패하면 의도 된 변경인지 의도하지 않은 변경인지 검사해야합니다. 변경이 예상되면 &lt;code&gt;jest -u&lt;/code&gt; 를 사용 하여 Jest를 호출 하여 기존 스냅 샷을 덮어 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c0aa57bf091fdb92d54cdb2b0d3bc7f67e93ff89" translate="yes" xml:space="preserve">
          <source>The next time you run the tests, the rendered output will be compared to the previously created snapshot. The snapshot should be committed along with code changes. When a snapshot test fails, you need to inspect whether it is an intended or unintended change. If the change is expected you can invoke Jest with &lt;code&gt;jest -u&lt;/code&gt; to overwrite the existing snapshot.</source>
          <target state="translated">다음에 테스트를 실행할 때 렌더링 된 출력이 이전에 생성 된 스냅 샷과 비교됩니다. 코드 변경과 함께 스냅 샷을 커밋해야합니다. 스냅 샷 테스트가 실패하면 의도 한 변경인지 의도하지 않은 변경인지 검사해야합니다. 변경이 예상되는 경우 &lt;code&gt;jest -u&lt;/code&gt; 와 함께 Jest를 호출 하여 기존 스냅 샷을 덮어 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="84d0785b2c19153a1443fb7a2b373d5989af5d74" translate="yes" xml:space="preserve">
          <source>The number of seconds after which a test is considered as slow and reported as such in the results.</source>
          <target state="translated">테스트가 느린 것으로 간주되어 결과에보고되는 시간 (초)입니다.</target>
        </trans-unit>
        <trans-unit id="a31eaed7b5b436b050c922084e63b820147d0c79" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;numDigits&lt;/code&gt; argument has default value &lt;code&gt;2&lt;/code&gt; which means the criterion is &lt;code&gt;Math.abs(expected - received) &amp;lt; 0.005&lt;/code&gt; (that is, &lt;code&gt;10 ** -2 / 2&lt;/code&gt;).</source>
          <target state="translated">선택적 &lt;code&gt;numDigits&lt;/code&gt; 인수의 기본값은 &lt;code&gt;2&lt;/code&gt; 입니다. 이는 기준이 &lt;code&gt;Math.abs(expected - received) &amp;lt; 0.005&lt;/code&gt; (즉, &lt;code&gt;10 ** -2 / 2&lt;/code&gt; -2/2) 임을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="64715c706a809e691edcf14fa2f1881885671388" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;numDigits&lt;/code&gt; argument limits the number of digits to check &lt;strong&gt;after&lt;/strong&gt; the decimal point. For the default value &lt;code&gt;2&lt;/code&gt;, the test criterion is &lt;code&gt;Math.abs(expected - received) &amp;lt; 0.005&lt;/code&gt; (that is, &lt;code&gt;10 ** -2 / 2&lt;/code&gt;).</source>
          <target state="translated">선택적 &lt;code&gt;numDigits&lt;/code&gt; 인수 는 소수점 &lt;strong&gt;뒤에서&lt;/strong&gt; 확인할 자릿수를 제한합니다 . 기본값 &lt;code&gt;2&lt;/code&gt; 의 경우 테스트 기준은 &lt;code&gt;Math.abs(expected - received) &amp;lt; 0.005&lt;/code&gt; (즉, &lt;code&gt;10 ** -2 / 2&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="fb0899f14809b1bdd6ebd980d7e7260be1575887" translate="yes" xml:space="preserve">
          <source>The order in which the mappings are defined matters. Patterns are checked one by one until one fits. The most specific rule should be listed first.</source>
          <target state="translated">매핑이 정의 된 순서가 중요합니다. 패턴은 하나가 맞을 때까지 하나씩 점검됩니다. 가장 구체적인 규칙이 먼저 나열되어야합니다.</target>
        </trans-unit>
        <trans-unit id="5b6e6db2c1f69ef0831d7bfa5c2ddb80fbc9eeba" translate="yes" xml:space="preserve">
          <source>The order in which the mappings are defined matters. Patterns are checked one by one until one fits. The most specific rule should be listed first. This is true for arrays of module names as well.</source>
          <target state="translated">매핑이 정의되는 순서가 중요합니다. 패턴이 맞을 때까지 하나씩 확인합니다. 가장 구체적인 규칙이 먼저 나열되어야합니다. 모듈 이름의 배열에도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="4c5b04e8fcaf70465aadc92771f5000507ea04a5" translate="yes" xml:space="preserve">
          <source>The path to a module that can resolve test&amp;lt;-&amp;gt;snapshot path. This config option lets you customize where Jest stores snapshot files on disk.</source>
          <target state="translated">test &amp;lt;-&amp;gt; 스냅 샷 경로를 확인할 수있는 모듈의 경로입니다. 이 구성 옵션을 사용하면 Jest가 디스크에서 스냅 샷 파일을 저장하는 위치를 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af95718edc02b7821b4e9e81772f5338985c3a20" translate="yes" xml:space="preserve">
          <source>The path to a module that runs some code to configure or set up the testing framework before each test. Beware that files imported by the setup script will not be mocked during testing.</source>
          <target state="translated">각 테스트 전에 테스트 프레임 워크를 구성하거나 설정하기 위해 일부 코드를 실행하는 모듈의 경로입니다. 설정 스크립트로 가져온 파일은 테스트 중에 조롱되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4431569135edde52cd7dc8cd910c15a768e3e1b1" translate="yes" xml:space="preserve">
          <source>The pattern or patterns Jest uses to detect test files. By default it looks for &lt;code&gt;.js&lt;/code&gt;, &lt;code&gt;.jsx&lt;/code&gt;, &lt;code&gt;.ts&lt;/code&gt; and &lt;code&gt;.tsx&lt;/code&gt; files inside of &lt;code&gt;__tests__&lt;/code&gt; folders, as well as any files with a suffix of &lt;code&gt;.test&lt;/code&gt; or &lt;code&gt;.spec&lt;/code&gt; (e.g. &lt;code&gt;Component.test.js&lt;/code&gt; or &lt;code&gt;Component.spec.js&lt;/code&gt;). It will also find files called &lt;code&gt;test.js&lt;/code&gt; or &lt;code&gt;spec.js&lt;/code&gt;. See also &lt;a href=&quot;#testmatch-arraystring&quot;&gt;&lt;code&gt;testMatch&lt;/code&gt; [array&amp;lt;string&amp;gt;]&lt;/a&gt;, but note that you cannot specify both options.</source>
          <target state="translated">Jest가 테스트 파일을 탐지하는 데 사용하는 패턴입니다. 기본적 으로 &lt;code&gt;__tests__&lt;/code&gt; 폴더 내의 &lt;code&gt;.js&lt;/code&gt; , &lt;code&gt;.jsx&lt;/code&gt; , &lt;code&gt;.ts&lt;/code&gt; 및 &lt;code&gt;.tsx&lt;/code&gt; 파일과 접미사가 &lt;code&gt;.test&lt;/code&gt; 또는 &lt;code&gt;.spec&lt;/code&gt; 인 파일 (예 : &lt;code&gt;Component.test.js&lt;/code&gt; 또는 &lt;code&gt;Component.spec.js&lt;/code&gt; )을 찾습니다. . &lt;code&gt;test.js&lt;/code&gt; 또는 &lt;code&gt;spec.js&lt;/code&gt; 라는 파일도 찾을 수 있습니다 . &lt;a href=&quot;#testmatch-arraystring&quot;&gt; &lt;code&gt;testMatch&lt;/code&gt; &lt;/a&gt; [array &amp;lt;string&amp;gt;] 도 참조하십시오 . 그러나 두 옵션을 모두 지정할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="ac24fd9dddf51302b5efc36ff27838314425a460" translate="yes" xml:space="preserve">
          <source>The preset sets up the environment and is very opinionated and based on what we found to be useful at Facebook. All of the configuration options can be overwritten just as they can be customized when no preset is used.</source>
          <target state="translated">사전 설정은 환경을 설정하고 의견이 많으며 Facebook에서 유용하다고 생각한 내용을 기반으로합니다. 사전 설정을 사용하지 않을 때 사용자 정의 할 수있는 것처럼 모든 구성 옵션을 덮어 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac31d1cab716f57b4c0ab81a14ecb8cc6af7f1f3" translate="yes" xml:space="preserve">
          <source>The problem is that the test will complete as soon as &lt;code&gt;fetchData&lt;/code&gt; completes, before ever calling the callback.</source>
          <target state="translated">문제는 콜백을 호출하기 전에 &lt;code&gt;fetchData&lt;/code&gt; 가 완료되는 즉시 테스트가 완료된다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="9c9c92c829ae1b54b1e9c5e404efb1cc15d27456" translate="yes" xml:space="preserve">
          <source>The projects feature can also be used to run multiple configurations or multiple &lt;a href=&quot;#runner-string&quot;&gt;runners&lt;/a&gt;. For this purpose you can pass an array of configuration objects. For example, to run both tests and ESLint (via &lt;a href=&quot;https://github.com/jest-community/jest-runner-eslint&quot;&gt;jest-runner-eslint&lt;/a&gt;) in the same invocation of Jest:</source>
          <target state="translated">프로젝트 기능을 사용하여 여러 구성 또는 여러 &lt;a href=&quot;#runner-string&quot;&gt;러너&lt;/a&gt; 를 실행할 수도 있습니다 . 이를 위해 구성 객체 배열을 전달할 수 있습니다. 예를 들어, 동일한 Jest 호출에서 테스트와 ESLint (jest &lt;a href=&quot;https://github.com/jest-community/jest-runner-eslint&quot;&gt;-runner-eslint&lt;/a&gt; 통해)를 모두 실행하려면 다음을 수행 하십시오.</target>
        </trans-unit>
        <trans-unit id="891a6640064d264d47e092465eed82ba702c8606" translate="yes" xml:space="preserve">
          <source>The projects feature can also be used to run multiple configurations or multiple &lt;a href=&quot;#runner-string&quot;&gt;runners&lt;/a&gt;. For this purpose, you can pass an array of configuration objects. For example, to run both tests and ESLint (via &lt;a href=&quot;https://github.com/jest-community/jest-runner-eslint&quot;&gt;jest-runner-eslint&lt;/a&gt;) in the same invocation of Jest:</source>
          <target state="translated">프로젝트 기능을 사용하여 여러 구성 또는 여러 &lt;a href=&quot;#runner-string&quot;&gt;러너&lt;/a&gt; 를 실행할 수도 있습니다 . 이를 위해 구성 개체의 배열을 전달할 수 있습니다. 예를 들어 Jest의 동일한 호출에서 테스트와 ESLint (jest &lt;a href=&quot;https://github.com/jest-community/jest-runner-eslint&quot;&gt;-runner-eslint&lt;/a&gt; 를 통해)를 모두 실행하려면 :</target>
        </trans-unit>
        <trans-unit id="d777c2e867accda0c769689ff6458c1a1f2898ad" translate="yes" xml:space="preserve">
          <source>The root directory that Jest should scan for tests and modules within. If you put your Jest config inside your &lt;code&gt;package.json&lt;/code&gt; and want the root directory to be the root of your repo, the value for this config param will default to the directory of the &lt;code&gt;package.json&lt;/code&gt;.</source>
          <target state="translated">Jest가 테스트 및 모듈 내에서 스캔해야하는 루트 디렉토리. Jest 설정을 &lt;code&gt;package.json&lt;/code&gt; 안에 넣고 루트 디렉토리를 리포지토리 의 루트로 설정 하려는 경우이 구성 매개 변수의 값은 기본적으로 &lt;code&gt;package.json&lt;/code&gt; 디렉토리입니다 .</target>
        </trans-unit>
        <trans-unit id="a722fbdccf79dd6f0ade849e2e9aba5e205e8984" translate="yes" xml:space="preserve">
          <source>The second argument can be used to specify an explicit module factory that is being run instead of using Jest's automocking feature:</source>
          <target state="translated">두 번째 인수는 Jest의 자동 조롱 기능을 사용하는 대신 실행중인 명시 적 모듈 팩토리를 지정하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea2159726c801a056456ea23b7ba004e04675c0c" translate="yes" xml:space="preserve">
          <source>The simplest way to test a value is with exact equality.</source>
          <target state="translated">값을 테스트하는 가장 간단한 방법은 정확한 평등입니다.</target>
        </trans-unit>
        <trans-unit id="89fdf05ff2117139335a3d62f43a887b7ae92045" translate="yes" xml:space="preserve">
          <source>The snapshot artifact should be committed alongside code changes, and reviewed as part of your code review process. Jest uses &lt;a href=&quot;https://github.com/facebook/jest/tree/master/packages/pretty-format&quot;&gt;pretty-format&lt;/a&gt; to make snapshots human-readable during code review. On subsequent test runs Jest will compare the rendered output with the previous snapshot. If they match, the test will pass. If they don't match, either the test runner found a bug in your code (in this case, it's &lt;code&gt;&amp;lt;Link&amp;gt;&lt;/code&gt; component) that should be fixed, or the implementation has changed and the snapshot needs to be updated.</source>
          <target state="translated">스냅 샷 아티팩트는 코드 변경과 함께 커밋되고 코드 검토 프로세스의 일부로 검토되어야합니다. Jest는 &lt;a href=&quot;https://github.com/facebook/jest/tree/master/packages/pretty-format&quot;&gt;예쁜 형식&lt;/a&gt; 을 사용하여 코드 검토 중에 스냅 샷을 사람이 읽을 수있게 만듭니다. 후속 테스트 실행시 Jest는 렌더링 된 출력을 이전 스냅 샷과 비교합니다. 일치하면 테스트를 통과합니다. 일치하지 않으면 테스트 러너 가 수정해야 할 버그 (이 경우 &lt;code&gt;&amp;lt;Link&amp;gt;&lt;/code&gt; 구성 요소) 에서 버그를 발견 했거나 구현이 변경되어 스냅 샷을 업데이트해야합니다.</target>
        </trans-unit>
        <trans-unit id="1a331b33d493c1f842342392e5e84852aa3f9212" translate="yes" xml:space="preserve">
          <source>The snapshot artifact should be committed alongside code changes, and reviewed as part of your code review process. Jest uses &lt;a href=&quot;https://github.com/facebook/jest/tree/master/packages/pretty-format&quot;&gt;pretty-format&lt;/a&gt; to make snapshots human-readable during code review. On subsequent test runs, Jest will compare the rendered output with the previous snapshot. If they match, the test will pass. If they don't match, either the test runner found a bug in your code (in the &lt;code&gt;&amp;lt;Link&amp;gt;&lt;/code&gt; component in this case) that should be fixed, or the implementation has changed and the snapshot needs to be updated.</source>
          <target state="translated">스냅 샷 아티팩트는 코드 변경과 함께 커밋되고 코드 검토 프로세스의 일부로 검토되어야합니다. Jest는 코드 검토 중에 사람이 읽을 수있는 스냅 샷을 만들기 위해 &lt;a href=&quot;https://github.com/facebook/jest/tree/master/packages/pretty-format&quot;&gt;pretty-format&lt;/a&gt; 을 사용합니다 . 후속 테스트 실행에서 Jest는 렌더링 된 출력을 이전 스냅 샷과 비교합니다. 일치하면 테스트를 통과합니다. 일치하지 않는 경우 테스트 실행기 가 수정해야하는 코드 ( 이 경우 &lt;code&gt;&amp;lt;Link&amp;gt;&lt;/code&gt; 구성 요소)에서 버그를 발견 했거나 구현이 변경되어 스냅 샷을 업데이트해야합니다.</target>
        </trans-unit>
        <trans-unit id="451807d753aa7848105f4c86ff05582eb86d15a2" translate="yes" xml:space="preserve">
          <source>The test environment that will be used for testing. The default environment in Jest is a browser-like environment through &lt;a href=&quot;https://github.com/jsdom/jsdom&quot;&gt;jsdom&lt;/a&gt;. If you are building a node service, you can use the &lt;code&gt;node&lt;/code&gt; option to use a node-like environment instead.</source>
          <target state="translated">테스트에 사용될 테스트 환경입니다. Jest의 기본 환경은 &lt;a href=&quot;https://github.com/jsdom/jsdom&quot;&gt;jsdom을&lt;/a&gt; 통한 브라우저와 유사한 환경 입니다. 노드 서비스를 빌드하는 경우 대신 &lt;code&gt;node&lt;/code&gt; 옵션을 사용하여 노드와 유사한 환경을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="93bd3296b403f0c79b1219e068c720003979038e" translate="yes" xml:space="preserve">
          <source>The test environment that will be used for testing. The default environment in Jest is a browser-like environment through &lt;a href=&quot;https://github.com/tmpvar/jsdom&quot;&gt;jsdom&lt;/a&gt;. If you are building a node service, you can use the &lt;code&gt;node&lt;/code&gt; option to use a node-like environment instead.</source>
          <target state="translated">테스트에 사용될 테스트 환경. Jest의 기본 환경은 &lt;a href=&quot;https://github.com/tmpvar/jsdom&quot;&gt;jsdom을&lt;/a&gt; 통한 브라우저와 유사한 환경 입니다. 노드 서비스를 빌드하는 경우 &lt;code&gt;node&lt;/code&gt; 옵션을 사용하여 대신 노드와 유사한 환경을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="83a5c50498cba1f5866a682bd859dafc3028b89d" translate="yes" xml:space="preserve">
          <source>The test environment used for all tests. This can point to any file or node module. Examples: &lt;code&gt;jsdom&lt;/code&gt;, &lt;code&gt;node&lt;/code&gt; or &lt;code&gt;path/to/my-environment.js&lt;/code&gt;.</source>
          <target state="translated">모든 테스트에 사용 된 테스트 환경. 이것은 모든 파일 또는 노드 모듈을 가리킬 수 있습니다. 예 : &lt;code&gt;jsdom&lt;/code&gt; , &lt;code&gt;node&lt;/code&gt; 또는 &lt;code&gt;path/to/my-environment.js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0d4908fe8da50856a80634fb387ecf713015308b" translate="yes" xml:space="preserve">
          <source>The test for this function will look this way:</source>
          <target state="translated">이 기능에 대한 테스트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="73d8c22714027dd5317a0ccf3a9114cb6f10cf4c" translate="yes" xml:space="preserve">
          <source>The test runner module must export a function with the following signature:</source>
          <target state="translated">테스트 실행기 모듈은 다음 서명이있는 함수를 내 보내야합니다.</target>
        </trans-unit>
        <trans-unit id="29baec25ad18f1066c1ae3baa55f05cb1bcb3277" translate="yes" xml:space="preserve">
          <source>The third argument can be used to create virtual mocks &amp;ndash; mocks of modules that don't exist anywhere in the system:</source>
          <target state="translated">세 번째 인수는 시스템의 어디에도 존재하지 않는 모듈 모의 가상 모의를 만드는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06b3722bc66e669d036905e4f6b2a5bdde949a1d" translate="yes" xml:space="preserve">
          <source>The transform script was changed or Babel was updated and the changes aren't being recognized by Jest?</source>
          <target state="translated">변환 스크립트가 변경되었거나 Babel이 업데이트되었으며 Jest에서 변경 사항을 인식하지 못합니까?</target>
        </trans-unit>
        <trans-unit id="ca9dbda065b378b7864401a6ebb986bd5f6ee7e2" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;.rejects&lt;/code&gt; helper works like the &lt;code&gt;.resolves&lt;/code&gt; helper. If the promise is fulfilled, the test will automatically fail.</source>
          <target state="translated">&lt;code&gt;.rejects&lt;/code&gt; 등 작동 도우미 &lt;code&gt;.resolves&lt;/code&gt; 의 도우미. 약속이 이행되면 테스트는 자동으로 실패합니다.</target>
        </trans-unit>
        <trans-unit id="5b03b539d200edd998532b7ea7db20e6e130b6ab" translate="yes" xml:space="preserve">
          <source>The&lt;code&gt;.rejects&lt;/code&gt; helper works like the &lt;code&gt;.resolves&lt;/code&gt; helper. If the promise is fulfilled, the test will automatically fail. &lt;code&gt;expect.assertions(number)&lt;/code&gt; is not required but recommended to verify that a certain number of &lt;a href=&quot;expect#expectassertionsnumber&quot;&gt;assertions&lt;/a&gt; are called during a test. It is otherwise easy to forget to &lt;code&gt;return&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt; the &lt;code&gt;.resolves&lt;/code&gt; assertions.</source>
          <target state="translated">&lt;code&gt;.rejects&lt;/code&gt; 등 작동 도우미 &lt;code&gt;.resolves&lt;/code&gt; 의 도우미. 약속이 충족되면 테스트가 자동으로 실패합니다. &lt;code&gt;expect.assertions(number)&lt;/code&gt; 는 필수는 아니지만 테스트 중에 특정 개수의 &lt;a href=&quot;expect#expectassertionsnumber&quot;&gt;어설 션&lt;/a&gt; 이 호출 되는지 확인하는 것이 좋습니다 . 그것은을 잊지 그렇지 않으면 쉽게 &lt;code&gt;return&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; &lt;code&gt;.resolves&lt;/code&gt; 의 주장을.</target>
        </trans-unit>
        <trans-unit id="eb453830c3d6aec96f0b7405572bb292c7ef9964" translate="yes" xml:space="preserve">
          <source>Then add &lt;code&gt;@babel/preset-typescript&lt;/code&gt; to the list of presets in your &lt;code&gt;babel.config.js&lt;/code&gt;.</source>
          <target state="translated">그런 다음 &lt;code&gt;babel.config.js&lt;/code&gt; 의 사전 설정 목록에 &lt;code&gt;@babel/preset-typescript&lt;/code&gt; 를 추가 하십시오 .</target>
        </trans-unit>
        <trans-unit id="70a1108a97f09cf114548ba44e232397dc6dda32" translate="yes" xml:space="preserve">
          <source>Then all your className lookups on the styles object will be returned as-is (e.g., &lt;code&gt;styles.foobar === 'foobar'&lt;/code&gt;). This is pretty handy for React &lt;a href=&quot;snapshot-testing&quot;&gt;Snapshot Testing&lt;/a&gt;.</source>
          <target state="translated">그런 다음 styles 객체의 모든 className 조회는있는 그대로 반환됩니다 (예 : &lt;code&gt;styles.foobar === 'foobar'&lt;/code&gt; ). 이것은 React &lt;a href=&quot;snapshot-testing&quot;&gt;Snapshot Testing에&lt;/a&gt; 매우 편리합니다 .</target>
        </trans-unit>
        <trans-unit id="7fd2e2b8e86105641b83aa873750ac3f07a7e6d6" translate="yes" xml:space="preserve">
          <source>Then attach VS Code's debugger using the following &lt;code&gt;launch.json&lt;/code&gt; config:</source>
          <target state="translated">그런 다음 다음 &lt;code&gt;launch.json&lt;/code&gt; 구성을 사용하여 VS Code의 디버거를 연결하십시오 .</target>
        </trans-unit>
        <trans-unit id="e2ebdb0fca325019ed94f96f98ebfc6dc5ffe770" translate="yes" xml:space="preserve">
          <source>Then we need a custom Test Environment for puppeteer</source>
          <target state="translated">그런 다음 인형을위한 맞춤형 테스트 환경이 필요합니다</target>
        </trans-unit>
        <trans-unit id="91f5afaec66d498efbeae8c4a2a41bd0c4feb389" translate="yes" xml:space="preserve">
          <source>Then you will see warnings in the console:</source>
          <target state="translated">그런 다음 콘솔에 경고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e559c23353ae644c58d965edecd0976830cfc4b2" translate="yes" xml:space="preserve">
          <source>Then, create a file named &lt;code&gt;sum.test.js&lt;/code&gt;. This will contain our actual test:</source>
          <target state="translated">그런 다음 &lt;code&gt;sum.test.js&lt;/code&gt; 라는 파일을 작성하십시오 . 여기에는 실제 테스트가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="490b7879f324bbb8130b919839cb28e4ee52a87d" translate="yes" xml:space="preserve">
          <source>There are a number of helpful tools exposed on &lt;code&gt;this.utils&lt;/code&gt; primarily consisting of the exports from &lt;a href=&quot;https://github.com/facebook/jest/tree/master/packages/jest-matcher-utils&quot;&gt;&lt;code&gt;jest-matcher-utils&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;this.utils&lt;/code&gt; 에는 주로 jest &lt;a href=&quot;https://github.com/facebook/jest/tree/master/packages/jest-matcher-utils&quot;&gt; &lt;code&gt;jest-matcher-utils&lt;/code&gt; &lt;/a&gt; 의 내보내기로 구성된 유용한 도구가 많이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce3ddc7ca2ed0e64f9ff4f568a1875d4a36fac12" translate="yes" xml:space="preserve">
          <source>There are also scenarios where you might have a recursive timer -- that is a timer that sets a new timer in its own callback. For these, running all the timers would be an endless loop&amp;hellip; so something like &lt;code&gt;jest.runAllTimers()&lt;/code&gt; is not desirable. For these cases you might use &lt;code&gt;jest.runOnlyPendingTimers()&lt;/code&gt;:</source>
          <target state="translated">재귀 타이머가있는 시나리오도 있습니다. 즉, 자체 콜백에서 새 타이머를 설정하는 타이머입니다. 이를 위해 모든 타이머를 실행하는 것은 무한 루프입니다. 따라서 &lt;code&gt;jest.runAllTimers()&lt;/code&gt; 와 같은 것은 바람직하지 않습니다. 이 경우 &lt;code&gt;jest.runOnlyPendingTimers()&lt;/code&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8062c6b456eff0aa9aea644bdb6882897bba1ab7" translate="yes" xml:space="preserve">
          <source>There are multiple ways to debug Jest tests with &lt;a href=&quot;https://code.visualstudio.com&quot;&gt;Visual Studio Code's&lt;/a&gt; built in &lt;a href=&quot;https://code.visualstudio.com/docs/nodejs/nodejs-debugging&quot;&gt;debugger&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://code.visualstudio.com&quot;&gt;Visual Studio Code의&lt;/a&gt; 내장 &lt;a href=&quot;https://code.visualstudio.com/docs/nodejs/nodejs-debugging&quot;&gt;디버거를 사용&lt;/a&gt; 하여 Jest 테스트를 디버깅하는 방법에는 여러 가지가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a0eee51d034df763b8fd5499614ddfe4723acc15" translate="yes" xml:space="preserve">
          <source>There are multiple ways to debug Jest tests with &lt;a href=&quot;https://code.visualstudio.com&quot;&gt;Visual Studio Code's&lt;/a&gt; built-in &lt;a href=&quot;https://code.visualstudio.com/docs/nodejs/nodejs-debugging&quot;&gt;debugger&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://code.visualstudio.com&quot;&gt;Visual Studio Code의&lt;/a&gt; 기본 제공 &lt;a href=&quot;https://code.visualstudio.com/docs/nodejs/nodejs-debugging&quot;&gt;디버거를 사용&lt;/a&gt; 하여 Jest 테스트를 디버깅하는 방법에는 여러 가지가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2f73f9113b29102310bf6ae603463dfb6eed9cda" translate="yes" xml:space="preserve">
          <source>There are times where you only want Jest to search in a single sub-directory (such as cases where you have a &lt;code&gt;src/&lt;/code&gt; directory in your repo), but prevent it from accessing the rest of the repo.</source>
          <target state="translated">Jest가 단일 하위 디렉토리 (예 : 리포지토리에 &lt;code&gt;src/&lt;/code&gt; 디렉토리 가있는 경우)에서만 검색하도록하려는 경우가 있지만 나머지 리포지토리에는 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0b73bd505ade591eff51524741c24e46983c0ab6" translate="yes" xml:space="preserve">
          <source>There are two ways to mock functions: Either by creating a mock function to use in test code, or writing a &lt;a href=&quot;manual-mocks&quot;&gt;&lt;code&gt;manual mock&lt;/code&gt;&lt;/a&gt; to override a module dependency.</source>
          <target state="translated">함수를 모의하는 두 가지 방법이 있습니다. 테스트 코드에 사용할 모의 함수를 작성하거나 모듈 종속성을 대체하기 위해 &lt;a href=&quot;manual-mocks&quot;&gt; &lt;code&gt;manual mock&lt;/code&gt; &lt;/a&gt; 를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb812ec7da9105ae82712a4e1f280b3919c21f67" translate="yes" xml:space="preserve">
          <source>There is a less verbose way using &lt;code&gt;resolves&lt;/code&gt; to unwrap the value of a fulfilled promise together with any other matcher. If the promise is rejected, the assertion will fail.</source>
          <target state="translated">사용 방법 자세한 덜이 &lt;code&gt;resolves&lt;/code&gt; 다른 정규와 성취 약속 함께 값 랩을 해제 할 수 있습니다. 약속이 거부되면 어설 션이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="d3bc98afc16f0c3f67ba16dbd3f93d1dbca283cf" translate="yes" xml:space="preserve">
          <source>There is an alternate form of &lt;code&gt;test&lt;/code&gt; that fixes this. Instead of putting the test in a function with an empty argument, use a single argument called &lt;code&gt;done&lt;/code&gt;. Jest will wait until the &lt;code&gt;done&lt;/code&gt; callback is called before finishing the test.</source>
          <target state="translated">이 문제 를 해결 하는 다른 형태의 &lt;code&gt;test&lt;/code&gt; 가 있습니다. 빈 인수가있는 함수에 테스트를 넣는 대신 &lt;code&gt;done&lt;/code&gt; 이라는 단일 인수를 사용하십시오 . Jest는 테스트가 완료되기 전에 &lt;code&gt;done&lt;/code&gt; 콜백이 호출 될 때까지 기다립니다 .</target>
        </trans-unit>
        <trans-unit id="38513f64442e40688964ff51c98714e3662f0ad9" translate="yes" xml:space="preserve">
          <source>There's a caveat around snapshot testing when using Enzyme and React 16+. If you mock out a module using the following style:</source>
          <target state="translated">Enzyme 및 React 16+를 사용할 때 스냅 샷 테스트에는주의해야합니다. 다음 스타일을 사용하여 모듈을 조롱하는 경우 :</target>
        </trans-unit>
        <trans-unit id="45969bbe3aaa0e36ec651be5c3c1e2bc6f21618e" translate="yes" xml:space="preserve">
          <source>There's no need to load any dependencies.</source>
          <target state="translated">종속성을로드 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="feaa8cf5e94e8af347c21dcc253b06efd78e08cf" translate="yes" xml:space="preserve">
          <source>There's no need to load any dependencies. Puppeteer's &lt;code&gt;page&lt;/code&gt; and &lt;code&gt;browser&lt;/code&gt; classes will automatically be exposed</source>
          <target state="translated">종속성을로드 할 필요가 없습니다. 인형의 &lt;code&gt;page&lt;/code&gt; 와 &lt;code&gt;browser&lt;/code&gt; 클래스가 자동으로 노출됩니다</target>
        </trans-unit>
        <trans-unit id="205f02d2ffd73f73e820d056d16ae760c3445b0d" translate="yes" xml:space="preserve">
          <source>These helper functions and properties can be found on &lt;code&gt;this&lt;/code&gt; inside a custom matcher:</source>
          <target state="translated">이 도우미 기능과 특성에서 찾을 수 있습니다 &lt;code&gt;this&lt;/code&gt; 사용자 지정 정규 내부 :</target>
        </trans-unit>
        <trans-unit id="6b60550c5bbaa39ef042c5fe44f0a413fa65b5bf" translate="yes" xml:space="preserve">
          <source>These matchers are sugar for common forms of inspecting the &lt;code&gt;.mock&lt;/code&gt; property. You can always do this manually yourself if that's more to your taste or if you need to do something more specific:</source>
          <target state="translated">이 매처는 &lt;code&gt;.mock&lt;/code&gt; 속성 을 검사하는 일반적인 형태의 설탕입니다 . 그것이 당신의 취향에 더 가깝거나 더 구체적인 것을 해야하는 경우 항상 수동으로 직접 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d8fa2963a415398720fb864829eb323209ccbff" translate="yes" xml:space="preserve">
          <source>These mock members are very useful in tests to assert how these functions get called, instantiated, or what they returned:</source>
          <target state="translated">이 모의 멤버는 테스트에서 이러한 함수의 호출, 인스턴스화 또는 반환 된 내용을 확인하는 데 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="421ccddd05618e2071d86e6bbbe14f0b2076576e" translate="yes" xml:space="preserve">
          <source>These options let you control Jest's behavior in your &lt;code&gt;package.json&lt;/code&gt; file. The Jest philosophy is to work great by default, but sometimes you just need more configuration power.</source>
          <target state="translated">이 옵션을 사용하면 &lt;code&gt;package.json&lt;/code&gt; 파일 에서 Jest의 동작을 제어 할 수 있습니다 . Jest 철학은 기본적으로 훌륭하게 작동하는 것이지만 때로는 더 많은 구성 기능이 필요할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="fcaea31195ac296456fff13bc787d5eef5067d3d" translate="yes" xml:space="preserve">
          <source>These pattern strings match against the full path. Use the &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; string token to include the path to your project's root directory to prevent it from accidentally ignoring all of your files in different environments that may have different root directories.</source>
          <target state="translated">이 패턴 문자열은 전체 경로와 일치합니다. &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; 문자열 토큰을 사용 하여 프로젝트의 루트 디렉토리 경로를 포함하여 다른 루트 디렉토리가있는 다른 환경의 모든 파일을 실수로 무시하지 않도록하십시오.</target>
        </trans-unit>
        <trans-unit id="17b10be41180956fbf5d08f1f6d6c3f7a2db71c5" translate="yes" xml:space="preserve">
          <source>These pattern strings match against the full path. Use the &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; string token to include the path to your project's root directory to prevent it from accidentally ignoring all of your files in different environments that may have different root directories. Example: &lt;code&gt;[&quot;&amp;lt;rootDir&amp;gt;/build/&quot;, &quot;&amp;lt;rootDir&amp;gt;/node_modules/&quot;]&lt;/code&gt;.</source>
          <target state="translated">이 패턴 문자열은 전체 경로와 일치합니다. &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; 문자열 토큰을 사용 하여 프로젝트의 루트 디렉토리 경로를 포함하여 다른 루트 디렉토리가있는 다른 환경의 모든 파일을 실수로 무시하지 않도록하십시오. 예 : &lt;code&gt;[&quot;&amp;lt;rootDir&amp;gt;/build/&quot;, &quot;&amp;lt;rootDir&amp;gt;/node_modules/&quot;]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="005b28d7accf90e223dee1c8e7ebc452b6213877" translate="yes" xml:space="preserve">
          <source>These pattern strings match against the full path. Use the &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; string token to include the path to your project's root directory to prevent it from accidentally ignoring all of your files in different environments that may have different root directories. Example: &lt;code&gt;[&quot;&amp;lt;rootDir&amp;gt;/build/&quot;]&lt;/code&gt;.</source>
          <target state="translated">이 패턴 문자열은 전체 경로와 일치합니다. &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; 문자열 토큰을 사용 하여 프로젝트의 루트 디렉토리 경로를 포함하여 다른 루트 디렉토리가있는 다른 환경의 모든 파일을 실수로 무시하지 않도록하십시오. 예 : &lt;code&gt;[&quot;&amp;lt;rootDir&amp;gt;/build/&quot;]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b61d73386d7f1dedf935b736a15ddf6e38555ac" translate="yes" xml:space="preserve">
          <source>These patterns match against the full path. Use the &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; string token to include the path to your project's root directory to prevent it from accidentally ignoring all of your files in different environments that may have different root directories. Example: &lt;code&gt;[&quot;&amp;lt;rootDir&amp;gt;/node_modules/&quot;]&lt;/code&gt;.</source>
          <target state="translated">이 패턴은 전체 경로와 일치합니다. &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; 문자열 토큰을 사용 하여 프로젝트의 루트 디렉토리 경로를 포함하여 다른 루트 디렉토리가있는 다른 환경의 모든 파일을 실수로 무시하지 않도록하십시오. 예 : &lt;code&gt;[&quot;&amp;lt;rootDir&amp;gt;/node_modules/&quot;]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c464bdbe395120d407822fbb18f9738c9a02965a" translate="yes" xml:space="preserve">
          <source>Third-party plugins are also forbidden to overwrite a key reserved already by another third-party plugin present earlier in the configured plugins list (&lt;code&gt;watchPlugins&lt;/code&gt; array setting). When this happens, you&amp;rsquo;ll also get an error message that tries to help you fix that:</source>
          <target state="translated">타사 플러그인은 이미 구성된 플러그인 목록 ( &lt;code&gt;watchPlugins&lt;/code&gt; 배열 설정) 에있는 다른 타사 플러그인이 이미 예약 한 키를 덮어 쓰는 것이 금지되어 있습니다. 이 경우 문제를 해결하는 데 도움이되는 오류 메시지가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="ea26b0157e1130ece50df7d1c6b1515a7cc72eba" translate="yes" xml:space="preserve">
          <source>This allows your test file to import the actual &lt;code&gt;Response&lt;/code&gt; object from &lt;code&gt;node-fetch&lt;/code&gt;, rather than a mocked version. This means the test will now pass correctly.</source>
          <target state="translated">이를 통해 테스트 파일은 모의 버전이 아닌 &lt;code&gt;node-fetch&lt;/code&gt; 에서 실제 &lt;code&gt;Response&lt;/code&gt; 객체 를 가져올 수 있습니다 . 이것은 이제 테스트가 올바르게 통과한다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="6c57d62e399034f0a7b381de3e7d5f645f9ad504" translate="yes" xml:space="preserve">
          <source>This ensures that a value matches the most recent snapshot. Check out &lt;a href=&quot;snapshot-testing&quot;&gt;the Snapshot Testing guide&lt;/a&gt; for more information.</source>
          <target state="translated">이를 통해 값이 가장 최근 스냅 샷과 일치합니다. 확인 &lt;a href=&quot;snapshot-testing&quot;&gt;스냅 샷 테스트 가이드&lt;/a&gt; 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="dac9e840fc23ac31d800f8538975040bb9ecac74" translate="yes" xml:space="preserve">
          <source>This example also shows how you can nest multiple asymmetric matchers, with &lt;code&gt;expect.stringMatching&lt;/code&gt; inside the &lt;code&gt;expect.arrayContaining&lt;/code&gt;.</source>
          <target state="translated">또한이 예를 보여줍니다 방법을 중첩 할 수 여러 비대칭 매처 (matcher)와 &lt;code&gt;expect.stringMatching&lt;/code&gt; 내부 &lt;code&gt;expect.arrayContaining&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b58eb0d982c4ebd2168b0b47532f786470fd666" translate="yes" xml:space="preserve">
          <source>This example configuration will run Jest in the root directory as well as in every folder in the examples directory. You can have an unlimited amount of projects running in the same Jest instance.</source>
          <target state="translated">이 예제 구성은 예제 디렉토리의 모든 폴더와 루트 디렉토리에서 Jest를 실행합니다. 동일한 Jest 인스턴스에서 무제한의 프로젝트를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07d5008923646b5de183b191e7806d1642e368f2" translate="yes" xml:space="preserve">
          <source>This is a deep-equality function that will return &lt;code&gt;true&lt;/code&gt; if two objects have the same values (recursively).</source>
          <target state="translated">이 함수는 두 개체의 값이 같은 경우 (재귀 적으로) &lt;code&gt;true&lt;/code&gt; 를 반환하는 심도 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="8787606ea91f4fa45b63964dfe671fe216f1f18b" translate="yes" xml:space="preserve">
          <source>This is especially useful for checking arrays or strings size.</source>
          <target state="translated">이것은 배열 또는 문자열 크기를 확인할 때 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="daedbdf3b3c492eb985c9a318c876db267766311" translate="yes" xml:space="preserve">
          <source>This is how &lt;code&gt;createMockFromModule&lt;/code&gt; will mock the following data types:</source>
          <target state="translated">이것이 &lt;code&gt;createMockFromModule&lt;/code&gt; 이 다음 데이터 유형을 모의하는 방법 입니다.</target>
        </trans-unit>
        <trans-unit id="df6bb81a22b9aea2dc501ec88e58677f39b608e1" translate="yes" xml:space="preserve">
          <source>This is how &lt;code&gt;genMockFromModule&lt;/code&gt; will mock the following data types:</source>
          <target state="translated">&lt;code&gt;genMockFromModule&lt;/code&gt; 이 다음 데이터 유형을 조롱하는 방법 입니다.</target>
        </trans-unit>
        <trans-unit id="3773feba2fd857753eb4d289910186bb5075a5d0" translate="yes" xml:space="preserve">
          <source>This is just a taste. For a complete list of matchers, check out the &lt;a href=&quot;expect&quot;&gt;reference docs&lt;/a&gt;.</source>
          <target state="translated">이것은 단지 맛입니다. 매처의 전체 목록은 &lt;a href=&quot;expect&quot;&gt;참조 문서를&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="b91b6036665a31c72c932de515d167cc3324bf18" translate="yes" xml:space="preserve">
          <source>This is often useful for synchronously executing setTimeouts during a test in order to synchronously assert about some behavior that would only happen after the &lt;code&gt;setTimeout()&lt;/code&gt; or &lt;code&gt;setInterval()&lt;/code&gt; callbacks executed. See the &lt;a href=&quot;timer-mocks&quot;&gt;Timer mocks&lt;/a&gt; doc for more information.</source>
          <target state="translated">이는 &lt;code&gt;setTimeout()&lt;/code&gt; 또는 &lt;code&gt;setInterval()&lt;/code&gt; 콜백이 실행 된 후에 만 발생하는 일부 동작에 대해 동 기적으로 주장하기 위해 테스트 중에 setTimeouts를 동 기적으로 실행하는 데 유용합니다 . 자세한 내용은 &lt;a href=&quot;timer-mocks&quot;&gt;Timer mocks&lt;/a&gt; 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b7d7c1519ae2cf4a773f1afd649832547d401f24" translate="yes" xml:space="preserve">
          <source>This is often useful if you want to clean up some global setup state that is shared across tests.</source>
          <target state="translated">테스트 전체에서 공유되는 일부 전역 설정 상태를 정리하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="f38502aacbc947736082f8a6708a41145ca79655" translate="yes" xml:space="preserve">
          <source>This is often useful if you want to clean up some temporary state that is created by each test.</source>
          <target state="translated">각 테스트에서 생성 된 임시 상태를 정리하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="f0881bf0bef2a66191cfe13dc0ddb9fc67b1b880" translate="yes" xml:space="preserve">
          <source>This is often useful if you want to reset some global state that will be used by many tests.</source>
          <target state="translated">이것은 많은 테스트에서 사용될 일부 글로벌 상태를 재설정하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="c9eaf0b51489505b8e52db0ac5e52495ccfe19ba" translate="yes" xml:space="preserve">
          <source>This is often useful if you want to set up some global state that will be used by many tests.</source>
          <target state="translated">많은 테스트에서 사용될 전역 상태를 설정하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="72cca58df7454651ff7a323dceaea7ab640b298b" translate="yes" xml:space="preserve">
          <source>This is useful for scenarios such as one where the module being tested schedules a &lt;code&gt;setTimeout()&lt;/code&gt; whose callback schedules another &lt;code&gt;setTimeout()&lt;/code&gt; recursively (meaning the scheduling never stops). In these scenarios, it's useful to be able to run forward in time by a single step at a time.</source>
          <target state="translated">이는 테스트중인 모듈이 콜백이 다른 &lt;code&gt;setTimeout()&lt;/code&gt; 재귀 적으로 예약하는 &lt;code&gt;setTimeout()&lt;/code&gt; 예약하는 시나리오와 같은 시나리오에 유용합니다 (예약은 절대 멈추지 않음). 이 시나리오에서는 한 번에 한 단계 씩 시간을 앞당길 수있는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3a5ea63e8ffdad93e9fef81bb115e6f5cff87758" translate="yes" xml:space="preserve">
          <source>This is useful for some commonly used 'utility' modules that are almost always used as implementation details almost all the time (like underscore/lo-dash, etc). It's generally a best practice to keep this list as small as possible and always use explicit &lt;code&gt;jest.mock()&lt;/code&gt;/&lt;code&gt;jest.unmock()&lt;/code&gt; calls in individual tests. Explicit per-test setup is far easier for other readers of the test to reason about the environment the test will run in.</source>
          <target state="translated">이는 거의 항상 거의 항상 구현 세부 사항으로 사용되는 (일반적으로 밑줄 / 대시 등) 일부 '유틸리티'모듈에 유용합니다. 일반적으로이 목록을 최대한 작게 유지 하고 개별 테스트에서 항상 명시적인 &lt;code&gt;jest.mock()&lt;/code&gt; / &lt;code&gt;jest.unmock()&lt;/code&gt; 호출을 사용하는 것이 가장 좋습니다 . 테스트 당 다른 환경의 독자가 테스트를 실행할 환경에 대해 추론하기 위해 테스트 별 설정이 훨씬 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="511f2fbaf8920a0608d26d5165905f63a5d73c88" translate="yes" xml:space="preserve">
          <source>This is useful when you want to completely reset a &lt;em&gt;mock&lt;/em&gt; back to its initial state. (Note that resetting a &lt;em&gt;spy&lt;/em&gt; will result in a function with no return value).</source>
          <target state="translated">&lt;em&gt;모의&lt;/em&gt; 를 초기 상태 로 완전히 재설정하려는 경우에 유용합니다 . ( &lt;em&gt;스파이&lt;/em&gt; 를 재설정하면 반환 값이없는 함수가 생성됩니다).</target>
        </trans-unit>
        <trans-unit id="c8d37ce85710fb471d0b215386de8769da78ab05" translate="yes" xml:space="preserve">
          <source>This is useful when you want to create a &lt;a href=&quot;manual-mocks&quot;&gt;manual mock&lt;/a&gt; that extends the automatic mock's behavior.</source>
          <target state="translated">자동 모의 동작을 확장 하는 &lt;a href=&quot;manual-mocks&quot;&gt;수동 모의&lt;/a&gt; 를 만들 때 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="d837db43e33775ed71a2885c71c5a5602ed7202b" translate="yes" xml:space="preserve">
          <source>This is useful when you want to mock functions in certain test cases and restore the original implementation in others.</source>
          <target state="translated">이는 특정 테스트 사례에서 함수를 모방하고 다른 구현에서 원래 구현을 복원하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="990db4730f558f16c2dc74a09c332aa10da16053" translate="yes" xml:space="preserve">
          <source>This is usually useful when you have a scenario where the number of dependencies you want to mock is far less than the number of dependencies that you don't. For example, if you're writing a test for a module that uses a large number of dependencies that can be reasonably classified as &quot;implementation details&quot; of the module, then you likely do not want to mock them.</source>
          <target state="translated">이것은 모의하려는 종속성 수가 원하지 않는 종속성의 수보다 훨씬 적은 시나리오가있을 때 유용합니다. 예를 들어, 모듈의 &quot;구현 세부 사항&quot;으로 합리적으로 분류 될 수있는 많은 수의 종속성을 사용하는 모듈에 대한 테스트를 작성하는 경우이를 모방하고 싶지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2cd58fa126aba532c56c9309e162bd465bef920f" translate="yes" xml:space="preserve">
          <source>This isn't required - you can write the &lt;code&gt;test&lt;/code&gt; blocks directly at the top level. But this can be handy if you prefer your tests to be organized into groups.</source>
          <target state="translated">필요하지 않습니다 . 최상위 레벨에서 직접 &lt;code&gt;test&lt;/code&gt; 블록을 작성할 수 있습니다 . 그러나 테스트를 그룹으로 구성하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="bc38e9460c76ac869bfb97b729c4bebd9601d3e9" translate="yes" xml:space="preserve">
          <source>This matcher also accepts a string, which it will try to match:</source>
          <target state="translated">이 매처는 또한 문자열을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="35176ec62e10ad24d9e5bf5b4f422f755d6dc150" translate="yes" xml:space="preserve">
          <source>This means, if any timers have been scheduled (but have not yet executed), they will be cleared and will never have the opportunity to execute in the future.</source>
          <target state="translated">즉, 예약 된 타이머가 있지만 아직 실행되지 않은 타이머는 지워지고 나중에 실행할 기회가 없습니다.</target>
        </trans-unit>
        <trans-unit id="688cc7c951b98d9e176b0ce89e8ee57961515438" translate="yes" xml:space="preserve">
          <source>This option allow comments in &lt;code&gt;package.json&lt;/code&gt;. Include the comment text as the value of this key anywhere in &lt;code&gt;package.json&lt;/code&gt;.</source>
          <target state="translated">이 옵션은 &lt;code&gt;package.json&lt;/code&gt; 에 주석을 허용 합니다 . &lt;code&gt;package.json&lt;/code&gt; 어딘가에 주석 텍스트를이 키의 값으로 포함하십시오 .</target>
        </trans-unit>
        <trans-unit id="e53db60be3e9be7e40274cb356ffc5b833ed548f" translate="yes" xml:space="preserve">
          <source>This option allows comments in &lt;code&gt;package.json&lt;/code&gt;. Include the comment text as the value of this key anywhere in &lt;code&gt;package.json&lt;/code&gt;.</source>
          <target state="translated">이 옵션은 &lt;code&gt;package.json&lt;/code&gt; 의 주석을 허용 합니다 . &lt;code&gt;package.json&lt;/code&gt; 의 모든 위치에이 키의 값으로 주석 텍스트를 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="50f12b52eb11d088de9a4fec28160df38ac92acd" translate="yes" xml:space="preserve">
          <source>This option allows the use of a custom dependency extractor. It must be a node module that exports an object with an &lt;code&gt;extract&lt;/code&gt; function. E.g.:</source>
          <target state="translated">이 옵션을 사용하면 사용자 정의 종속성 추출기를 사용할 수 있습니다. &lt;code&gt;extract&lt;/code&gt; 기능이 있는 오브젝트를 내보내는 노드 모듈이어야합니다 . 예 :</target>
        </trans-unit>
        <trans-unit id="7387fe3f611db301893ec5bf7cc4bbe625475ab6" translate="yes" xml:space="preserve">
          <source>This option allows the use of a custom global setup module which exports an async function that is triggered once before all test suites. This function gets Jest's &lt;code&gt;globalConfig&lt;/code&gt; object as a parameter.</source>
          <target state="translated">이 옵션을 사용하면 모든 테스트 스위트 전에 한 번 트리거되는 비동기 기능을 내보내는 사용자 정의 글로벌 설정 모듈을 사용할 수 있습니다. 이 함수는 Jest의 &lt;code&gt;globalConfig&lt;/code&gt; 객체를 매개 변수로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="f462a8db0f13013cff3f25a99166d1df5cc7a9d9" translate="yes" xml:space="preserve">
          <source>This option allows the use of a custom global teardown module which exports an async function that is triggered once after all test suites. This function gets Jest's &lt;code&gt;globalConfig&lt;/code&gt; object as a parameter.</source>
          <target state="translated">이 옵션을 사용하면 모든 테스트 스위트 후에 한 번 트리거되는 비동기 함수를 내보내는 사용자 정의 글로벌 분류 모듈을 사용할 수 있습니다. 이 함수는 Jest의 &lt;code&gt;globalConfig&lt;/code&gt; 객체를 매개 변수로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="38a9ab5d714461ae4a524d403260c43d23431747" translate="yes" xml:space="preserve">
          <source>This option allows the use of a custom resolver. This resolver must be a node module that exports a function expecting a string as the first argument for the path to resolve and an object with the following structure as the second argument:</source>
          <target state="translated">이 옵션을 사용하면 사용자 지정 해결 프로그램을 사용할 수 있습니다. 이 리졸버는 해결해야 할 경로의 첫 번째 인수로 문자열을 예상하는 함수를 내보내고 두 번째 인수로 다음 구조를 가진 객체를 내보내는 노드 모듈이어야합니다.</target>
        </trans-unit>
        <trans-unit id="840ac7a9f3696ee6876dcc9f096bc867ff39672e" translate="yes" xml:space="preserve">
          <source>This option allows the use of a custom results processor. This processor must be a node module that exports a function expecting an object with the following structure as the first argument and return it:</source>
          <target state="translated">이 옵션을 사용하면 사용자 정의 결과 프로세서를 사용할 수 있습니다. 이 프로세서는 첫 번째 인수로 다음 구조를 가진 객체를 기대하는 함수를 내보내고 반환하는 노드 모듈이어야합니다.</target>
        </trans-unit>
        <trans-unit id="5252ecd1f3fe162f8ab624586087da822d3f2adb" translate="yes" xml:space="preserve">
          <source>This option allows the use of a custom test runner. The default is jasmine2. A custom test runner can be provided by specifying a path to a test runner implementation.</source>
          <target state="translated">이 옵션을 사용하면 사용자 지정 테스트 실행기를 사용할 수 있습니다. 기본값은 jasmine2입니다. 테스트 실행기 구현에 대한 경로를 지정하여 사용자 지정 테스트 실행기를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="551495954b791bddca5765dca30e41d9a29511c6" translate="yes" xml:space="preserve">
          <source>This option allows use of a custom test runner. The default is jasmine2. A custom test runner can be provided by specifying a path to a test runner implementation.</source>
          <target state="translated">이 옵션을 사용하면 사용자 정의 테스트 러너를 사용할 수 있습니다. 기본값은 jasmine2입니다. 테스트 러너 구현에 대한 경로를 지정하여 사용자 정의 테스트 러너를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44d88dc72d1af311d80a8540431e21118807550c" translate="yes" xml:space="preserve">
          <source>This option allows you to use a custom runner instead of Jest's default test runner. Examples of runners include:</source>
          <target state="translated">이 옵션을 사용하면 Jest의 기본 테스트 러너 대신 사용자 정의 러너를 사용할 수 있습니다. 러너의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f5d6d08e3a74b9984da0a1564cf8f546a76f4a82" translate="yes" xml:space="preserve">
          <source>This option allows you to use a custom sequencer instead of Jest's default. &lt;code&gt;sort&lt;/code&gt; may optionally return a Promise.</source>
          <target state="translated">이 옵션을 사용하면 Jest의 기본값 대신 사용자 지정 시퀀서를 사용할 수 있습니다. &lt;code&gt;sort&lt;/code&gt; 는 선택적으로 약속을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c90ce340f3088fe9972394e67acc0935ff513e5d" translate="yes" xml:space="preserve">
          <source>This option allows you to use a custom watch plugins. Read more about watch plugins &lt;a href=&quot;watch-plugins&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">이 옵션을 사용하면 맞춤 시계 플러그인을 사용할 수 있습니다. 워치 플러그인에 대한 자세한 내용은 &lt;a href=&quot;watch-plugins&quot;&gt;여기를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="01827b8a7366fbc8b3065a863a5d386474ea1e78" translate="yes" xml:space="preserve">
          <source>This option allows you to use custom watch plugins. Read more about watch plugins &lt;a href=&quot;watch-plugins&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">이 옵션을 사용하면 맞춤 시계 플러그인을 사용할 수 있습니다. &lt;a href=&quot;watch-plugins&quot;&gt;여기에서&lt;/a&gt; 시계 플러그인에 대해 자세히 알아 보세요 .</target>
        </trans-unit>
        <trans-unit id="8a29c38f33c668ab5c982f199af3ff02856c863a" translate="yes" xml:space="preserve">
          <source>This option sets the URL for the jsdom environment. It is reflected in properties such as &lt;code&gt;location.href&lt;/code&gt;.</source>
          <target state="translated">이 옵션은 jsdom 환경의 URL을 설정합니다. &lt;code&gt;location.href&lt;/code&gt; 와 같은 속성에 반영됩니다 .</target>
        </trans-unit>
        <trans-unit id="d6bd84ad18e9b644594d518b7f4d72e5c10823c4" translate="yes" xml:space="preserve">
          <source>This option tells Jest that all imported modules in your tests should be mocked automatically. All modules used in your tests will have a replacement implementation, keeping the API surface.</source>
          <target state="translated">이 옵션은 Jest에게 테스트에서 가져온 모든 모듈이 자동으로 조롱되어야 함을 알려줍니다. 테스트에 사용 된 모든 모듈은 대체 구현으로 API 표면을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="98e2dcf1f1c275210f7dbe5eb1535d1ff6f9f4c3" translate="yes" xml:space="preserve">
          <source>This shouldn't normally be your option of choice as useful warnings could be lost. However, in some cases, for example when testing react-native's components we are rendering react-native tags into the DOM and many warnings are irrelevant. Another option is to swizzle the console.warn and suppress specific warnings.</source>
          <target state="translated">유용한 경고를 잃을 수 있으므로 일반적으로 선택하지 마십시오. 그러나 예를 들어 반응 네이티브의 구성 요소를 테스트 할 때 반응 네이티브 태그를 DOM에 렌더링하고 많은 경고는 관련이 없습니다. 또 다른 옵션은 콘솔을 쓸어 넘기고 특정 경고를 표시하지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="360362a3cbe9313d68d1cf19949c3804d1f4ed87" translate="yes" xml:space="preserve">
          <source>This test used &lt;code&gt;expect&lt;/code&gt; and &lt;code&gt;toBe&lt;/code&gt; to test that two values were exactly identical. To learn about the other things that Jest can test, see &lt;a href=&quot;using-matchers&quot;&gt;Using Matchers&lt;/a&gt;.</source>
          <target state="translated">이 테스트에서는 &lt;code&gt;expect&lt;/code&gt; 및 &lt;code&gt;toBe&lt;/code&gt; 를 사용하여 두 값이 정확히 동일한 지 테스트했습니다. Jest가 테스트 할 수있는 다른 사항에 대해 알아 보려면 &lt;a href=&quot;using-matchers&quot;&gt;Matchers 사용을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e6e9bf3c4c1c53fe256faefd1ca6b822f3ed81ba" translate="yes" xml:space="preserve">
          <source>This will add a line in the watch mode menu &lt;em&gt;(&lt;code&gt;&amp;rsaquo; Press s to do something.&lt;/code&gt;)&lt;/em&gt;</source>
          <target state="translated">시계 모드 메뉴에 줄이 추가됩니다 &lt;em&gt;( &lt;code&gt;&amp;rsaquo; Press s to do something.&lt;/code&gt; ).&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5f973bafbc6c9d08f6e504faea0ed8253ab2995f" translate="yes" xml:space="preserve">
          <source>This will be used to configure minimum threshold enforcement for coverage results. Thresholds can be specified as &lt;code&gt;global&lt;/code&gt;, as a &lt;a href=&quot;https://github.com/isaacs/node-glob#glob-primer&quot;&gt;glob&lt;/a&gt;, and as a directory or file path. If thresholds aren't met, jest will fail. Thresholds specified as a positive number are taken to be the minimum percentage required. Thresholds specified as a negative number represent the maximum number of uncovered entities allowed.</source>
          <target state="translated">적용 범위 결과에 대한 최소 임계 값 시행을 구성하는 데 사용됩니다. 임계 값은 &lt;code&gt;global&lt;/code&gt; , &lt;a href=&quot;https://github.com/isaacs/node-glob#glob-primer&quot;&gt;glob&lt;/a&gt; 및 디렉토리 또는 파일 경로 로 지정할 수 있습니다 . 임계 값이 충족되지 않으면 jest가 실패합니다. 양수로 지정된 임계 값은 필요한 최소 백분율로 간주됩니다. 음수로 지정된 임계 값은 허용 된 최대 발견 된 엔티티 수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="57f790c5005121416e8c2fd8ea8acb72b8b2e025" translate="yes" xml:space="preserve">
          <source>This will be used to configure the behavior of &lt;code&gt;jest-haste-map&lt;/code&gt;, Jest's internal file crawler/cache system. The following options are supported:</source>
          <target state="translated">이것은 Jest의 내부 파일 크롤러 / 캐시 시스템 인 &lt;code&gt;jest-haste-map&lt;/code&gt; 의 동작을 구성하는 데 사용됩니다 . 다음 옵션이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="9b781fa5a1c5086d94b94b3ea9ed32876793c2c2" translate="yes" xml:space="preserve">
          <source>This will collect coverage information for all the files inside the project's &lt;code&gt;rootDir&lt;/code&gt;, except the ones that match &lt;code&gt;**/node_modules/**&lt;/code&gt; or &lt;code&gt;**/vendor/**&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;**/node_modules/**&lt;/code&gt; 또는 &lt;code&gt;**/vendor/**&lt;/code&gt; 와 일치 하는 파일을 제외하고 프로젝트 &lt;code&gt;rootDir&lt;/code&gt; 내의 모든 파일에 대한 적용 범위 정보가 수집됩니다 .</target>
        </trans-unit>
        <trans-unit id="90cf7fb35e518c105a5552c6219ed3a42ba97b15" translate="yes" xml:space="preserve">
          <source>This will let us inspect usage of our mocked class, using &lt;code&gt;SoundPlayer.mock.calls&lt;/code&gt;: &lt;code&gt;expect(SoundPlayer).toHaveBeenCalled();&lt;/code&gt; or near-equivalent: &lt;code&gt;expect(SoundPlayer.mock.calls.length).toEqual(1);&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;SoundPlayer.mock.calls&lt;/code&gt; 를 사용하여 조롱 된 클래스의 사용을 검사 할 수 있습니다 . &lt;code&gt;expect(SoundPlayer).toHaveBeenCalled();&lt;/code&gt; 또는 거의 동등한 : &lt;code&gt;expect(SoundPlayer.mock.calls.length).toEqual(1);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="209071c8d9163c6dfec4225f989d2e729c2933ea" translate="yes" xml:space="preserve">
          <source>This will override default reporters:</source>
          <target state="translated">기본 기자를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="1ce9f7467129f03386e85416d9a79207d3f3cd66" translate="yes" xml:space="preserve">
          <source>This will print something like this:</source>
          <target state="translated">다음과 같이 인쇄됩니다 :</target>
        </trans-unit>
        <trans-unit id="0128c1ff802183c48e311ffffeefd6c4c9feb5e7" translate="yes" xml:space="preserve">
          <source>This will render the component as &lt;code&gt;&amp;lt;Video {...props} /&amp;gt;&lt;/code&gt; with all of its props in the snapshot output. See also &lt;a href=&quot;tutorial-react#snapshot-testing-with-mocks-enzyme-and-react-16&quot;&gt;caveats around Enzyme and React 16&lt;/a&gt;.</source>
          <target state="translated">그러면 컴포넌트가 &lt;code&gt;&amp;lt;Video {...props} /&amp;gt;&lt;/code&gt; 되고 모든 소품이 스냅 샷 출력에 표시됩니다. &lt;a href=&quot;tutorial-react#snapshot-testing-with-mocks-enzyme-and-react-16&quot;&gt;Enzyme과 React 16의주의 사항&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="031037a615f9d64385b25800b6c16eb718e695ad" translate="yes" xml:space="preserve">
          <source>This will run Jest in a Node process that an external debugger can connect to. Note that the process will pause until the debugger has connected to it.</source>
          <target state="translated">외부 디버거가 연결할 수있는 노드 프로세스에서 Jest를 실행합니다. 디버거가 연결될 때까지 프로세스가 일시 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="ff1252de72d76270d68e2df9f8a951026c2b21af" translate="yes" xml:space="preserve">
          <source>This will throw &lt;strong&gt;&lt;em&gt;TypeError: _soundPlayer2.default is not a constructor&lt;/em&gt;&lt;/strong&gt;, unless the code is transpiled to ES5, e.g. by &lt;code&gt;@babel/preset-env&lt;/code&gt;. (ES5 doesn't have arrow functions nor classes, so both will be transpiled to plain functions.)</source>
          <target state="translated">이 발생합니다 &lt;strong&gt;&lt;em&gt;형식 오류를 : _soundPlayer2.default 생성자 아닌&lt;/em&gt;&lt;/strong&gt; 코드에 의해 예를 들어 ES5에 transpiled하지 않는 한, &lt;code&gt;@babel/preset-env&lt;/code&gt; . (ES5에는 화살표 함수 나 클래스가 없으므로 둘 다 일반 함수로 변환됩니다.)</target>
        </trans-unit>
        <trans-unit id="a06ab4358a87cc38d323a6fe966b85af4c53ee66" translate="yes" xml:space="preserve">
          <source>This will use custom reporter in addition to default reporters that Jest provides:</source>
          <target state="translated">Jest가 제공하는 기본 리포터 외에도 사용자 정의 리포터를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="5c615ded93f646fc52958cfb01c7b4ab285ef4d0" translate="yes" xml:space="preserve">
          <source>This works if &lt;code&gt;window.matchMedia()&lt;/code&gt; is used in a function (or method) which is invoked in the test. If &lt;code&gt;window.matchMedia()&lt;/code&gt; is executed directly in the tested file, Jest reports the same error. In this case, the solution is to move the manual mock into a separate file and include this one in the test &lt;strong&gt;before&lt;/strong&gt; the tested file:</source>
          <target state="translated">&lt;code&gt;window.matchMedia()&lt;/code&gt; 가 테스트에서 호출 된 함수 (또는 메소드)에서 사용되는 경우 작동합니다 . 경우 &lt;code&gt;window.matchMedia()&lt;/code&gt; 테스트 파일을 직접 실행, 농담 같은 오류를보고합니다. 이 경우 해결 방법은 수동 모형을 별도의 파일로 옮기고 테스트 된 파일 &lt;strong&gt;보다 먼저&lt;/strong&gt; 테스트 &lt;strong&gt;에 포함&lt;/strong&gt; 시키는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0bce8231bb2ded7244230db592d5f3864c807820" translate="yes" xml:space="preserve">
          <source>Timer Mocks</source>
          <target state="translated">타이머 cks</target>
        </trans-unit>
        <trans-unit id="4cf1b54b003a59c279d1ba0b615a8a5f3459ca8c" translate="yes" xml:space="preserve">
          <source>Tips</source>
          <target state="translated">Tips</target>
        </trans-unit>
        <trans-unit id="2ae1e08337e0c3fff9724e42846cabe84620ef36" translate="yes" xml:space="preserve">
          <source>To add a key to the watch menu, implement the &lt;code&gt;getUsageInfo&lt;/code&gt; method, returning a key and the prompt:</source>
          <target state="translated">감시 메뉴에 키를 추가하려면 &lt;code&gt;getUsageInfo&lt;/code&gt; 메소드를 구현하여 키와 프롬프트를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="47b39578e06150847a8bca907a560548f45db25e" translate="yes" xml:space="preserve">
          <source>To attach the built-in debugger, run your tests as aforementioned:</source>
          <target state="translated">내장 디버거를 연결하려면 위에서 설명한대로 테스트를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="ecb87b5a4ec9578d9ae035bd9525d7f9a0bbc2d6" translate="yes" xml:space="preserve">
          <source>To automatically launch and attach to a process running your tests, use the following configuration:</source>
          <target state="translated">테스트를 실행하는 프로세스를 자동으로 시작하고 연결하려면 다음 구성을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8ef0aac5dc160f7cae3d13500ae91ad9928ac0f1" translate="yes" xml:space="preserve">
          <source>To build your own please visit the &lt;a href=&quot;tutorial-react#custom-transformers&quot;&gt;Custom Transformer&lt;/a&gt; section</source>
          <target state="translated">직접 제작하려면 &lt;a href=&quot;tutorial-react#custom-transformers&quot;&gt;맞춤형 변압기&lt;/a&gt; 섹션을 방문 하십시오</target>
        </trans-unit>
        <trans-unit id="aacf02378e2b38f25b6b3e4a83d574f8e35ceb32" translate="yes" xml:space="preserve">
          <source>To clear the record of calls to the mock constructor function and its methods, we call &lt;a href=&quot;mock-function-api#mockfnmockclear&quot;&gt;&lt;code&gt;mockClear()&lt;/code&gt;&lt;/a&gt; in the &lt;code&gt;beforeEach()&lt;/code&gt; function:</source>
          <target state="translated">모의 생성자 함수에 대한 호출과 그 방법의 기록을 지우려면, 우리는 전화 &lt;a href=&quot;mock-function-api#mockfnmockclear&quot;&gt; &lt;code&gt;mockClear()&lt;/code&gt; &lt;/a&gt; 에서 &lt;code&gt;beforeEach()&lt;/code&gt; 기능 :</target>
        </trans-unit>
        <trans-unit id="bbcbbcf6e6e23076d275df0fe406a4a0a2189298" translate="yes" xml:space="preserve">
          <source>To compare floating point numbers, you can use &lt;code&gt;toBeGreaterThan&lt;/code&gt;. For example, if you want to test that &lt;code&gt;ouncesPerCan()&lt;/code&gt; returns a value of more than 10 ounces, write:</source>
          <target state="translated">부동 소수점 숫자를 비교하기 위해 &lt;code&gt;toBeGreaterThan&lt;/code&gt; 을 사용할 수 있습니다 . 예를 들어, &lt;code&gt;ouncesPerCan()&lt;/code&gt; 이 10 온스 이상의 값을 반환 하는지 테스트하려면 다음 과 같이 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="f788e1ff5eca8835f05697583466e13f0b6a83d4" translate="yes" xml:space="preserve">
          <source>To compare floating point numbers, you can use &lt;code&gt;toBeGreaterThanOrEqual&lt;/code&gt;. For example, if you want to test that &lt;code&gt;ouncesPerCan()&lt;/code&gt; returns a value of at least 12 ounces, write:</source>
          <target state="translated">부동 소수점 숫자를 비교하기 위해 &lt;code&gt;toBeGreaterThanOrEqual&lt;/code&gt; 을 사용할 수 있습니다 . 예를 들어, &lt;code&gt;ouncesPerCan()&lt;/code&gt; 12 온스 이상의 값을 반환 하는지 테스트하려면 다음 과 같이 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="3630a179a57250195ccd7b5b31b4f9f6faacbab0" translate="yes" xml:space="preserve">
          <source>To compare floating point numbers, you can use &lt;code&gt;toBeLessThan&lt;/code&gt;. For example, if you want to test that &lt;code&gt;ouncesPerCan()&lt;/code&gt; returns a value of less than 20 ounces, write:</source>
          <target state="translated">부동 소수점 숫자를 비교하기 위해 &lt;code&gt;toBeLessThan&lt;/code&gt; 을 사용할 수 있습니다 . 예를 들어, &lt;code&gt;ouncesPerCan()&lt;/code&gt; 이 20 온스 미만의 값을 반환 하는지 테스트하려면 다음 과 같이 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="7bc35d8ccb0dac837113cbb13a4a6a626da1b19b" translate="yes" xml:space="preserve">
          <source>To compare floating point numbers, you can use &lt;code&gt;toBeLessThanOrEqual&lt;/code&gt;. For example, if you want to test that &lt;code&gt;ouncesPerCan()&lt;/code&gt; returns a value of at most 12 ounces, write:</source>
          <target state="translated">부동 소수점 숫자를 비교하기 위해 &lt;code&gt;toBeLessThanOrEqual&lt;/code&gt; 을 사용할 수 있습니다 . 예를 들어, &lt;code&gt;ouncesPerCan()&lt;/code&gt; 최대 12 온스의 값을 반환 하는지 테스트하려면 다음 과 같이 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="8488371ee9451e1b8abe49379e43d2abac066b15" translate="yes" xml:space="preserve">
          <source>To connect your watch plugin to Jest, add its path under &lt;code&gt;watchPlugins&lt;/code&gt; in your Jest configuration:</source>
          <target state="translated">watch 플러그인을 Jest에 연결하려면 Jest 구성의 &lt;code&gt;watchPlugins&lt;/code&gt; 아래에 해당 경로를 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="c020af932b115a7543d8e80249a02617ab77e279" translate="yes" xml:space="preserve">
          <source>To debug in Google Chrome (or any Chromium-based browser), open your browser and go to &lt;code&gt;chrome://inspect&lt;/code&gt; and click on &quot;Open Dedicated DevTools for Node&quot;, which will give you a list of available node instances you can connect to. Click on the address displayed in the terminal (usually something like &lt;code&gt;localhost:9229&lt;/code&gt;) after running the above command, and you will be able to debug Jest using Chrome's DevTools.</source>
          <target state="translated">Chrome (또는 Chromium 기반 브라우저)에서 디버깅하려면 브라우저를 열고 &lt;code&gt;chrome://inspect&lt;/code&gt; 로 이동하여 &quot;노드 전용 DevTools 열기&quot;를 클릭하면 연결할 수있는 사용 가능한 노드 인스턴스 목록이 표시됩니다. . 위 명령을 실행 한 후 터미널에 표시된 주소 (보통 &lt;code&gt;localhost:9229&lt;/code&gt; 와 같은 )를 클릭하면 Chrome의 DevTools를 사용하여 Jest를 디버깅 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b40318402328b187f84e5d748dc7567c2272d612" translate="yes" xml:space="preserve">
          <source>To enable async/await in your project, install &lt;a href=&quot;https://babeljs.io/docs/en/babel-preset-env&quot;&gt;&lt;code&gt;@babel/preset-env&lt;/code&gt;&lt;/a&gt; and enable the feature in your &lt;code&gt;babel.config.js&lt;/code&gt; file.</source>
          <target state="translated">프로젝트에서 async / await를 활성화하려면 &lt;a href=&quot;https://babeljs.io/docs/en/babel-preset-env&quot;&gt; &lt;code&gt;@babel/preset-env&lt;/code&gt; &lt;/a&gt; 설치 하고 &lt;code&gt;babel.config.js&lt;/code&gt; 파일 에서 기능을 활성화 하십시오.</target>
        </trans-unit>
        <trans-unit id="302ab4340db66b28bf4eeafaae3f85ad66b05f81" translate="yes" xml:space="preserve">
          <source>To ensure that a manual mock and its real implementation stay in sync, it might be useful to require the real module using &lt;a href=&quot;jest-object#jestrequireactualmodulename&quot;&gt;&lt;code&gt;jest.requireActual(moduleName)&lt;/code&gt;&lt;/a&gt; in your manual mock and amending it with mock functions before exporting it.</source>
          <target state="translated">수동 모의와 실제 구현이 동기화 상태를 유지하도록하려면 수동 모의에서 &lt;a href=&quot;jest-object#jestrequireactualmodulename&quot;&gt; &lt;code&gt;jest.requireActual(moduleName)&lt;/code&gt; &lt;/a&gt; 을 사용하여 실제 모듈을 요구하고 내보내기 전에 모의 함수로 수정하는 것이 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d68306f89da229b2b38be29155f82cf63d2fefff" translate="yes" xml:space="preserve">
          <source>To get around problems like this, Jest provides the &lt;code&gt;jest.requireActual&lt;/code&gt; helper. To make the above test work, make the following change to the imports in the test file:</source>
          <target state="translated">이와 같은 문제를 해결하기 위해 Jest는 &lt;code&gt;jest.requireActual&lt;/code&gt; 도우미를 제공합니다 . 위의 테스트를 수행하려면 테스트 파일에서 가져 오기를 다음과 같이 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="11fabe8d8570a5bb7d31d77eddfbad12fd7006ea" translate="yes" xml:space="preserve">
          <source>To handle key press events from the key returned by &lt;code&gt;getUsageInfo&lt;/code&gt;, you can implement the &lt;code&gt;run&lt;/code&gt; method. This method returns a &lt;code&gt;Promise&amp;lt;boolean&amp;gt;&lt;/code&gt; that can be resolved when the plugin wants to return control to Jest. The &lt;code&gt;boolean&lt;/code&gt; specifies if Jest should rerun the tests after it gets the control back.</source>
          <target state="translated">&lt;code&gt;getUsageInfo&lt;/code&gt; 가 리턴 한 키에서 키 누르기 이벤트를 처리하기 위해 &lt;code&gt;run&lt;/code&gt; 메소드를 구현할 수 있습니다 . 이 메소드는 플러그인이 Jest로 제어를 리턴하려고 할 때 해결할 수 있는 &lt;code&gt;Promise&amp;lt;boolean&amp;gt;&lt;/code&gt; 을 리턴합니다. &lt;code&gt;boolean&lt;/code&gt; 는 제어 등을 얻을 후 농담 경우 지정은 테스트를 다시 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="90daa538926bb277438f39b2435beb57540f0d66" translate="yes" xml:space="preserve">
          <source>To inject nested object values use you can supply a keyPath i.e. &lt;code&gt;$variable.path.to.value&lt;/code&gt;</source>
          <target state="translated">중첩 된 객체 값을 주입하기 위해 keyPath, 즉 &lt;code&gt;$variable.path.to.value&lt;/code&gt; 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="970630451f28f37da628f2cf8fe84113808b5a54" translate="yes" xml:space="preserve">
          <source>To make a dependency explicit instead of implicit, you can call &lt;a href=&quot;expect#expectaddsnapshotserializerserializer&quot;&gt;&lt;code&gt;expect.addSnapshotSerializer&lt;/code&gt;&lt;/a&gt; to add a module for an individual test file instead of adding its path to &lt;code&gt;snapshotSerializers&lt;/code&gt; in Jest configuration.</source>
          <target state="translated">암시 적 대신에 명시 적으로 종속성을 만들려면 &lt;a href=&quot;expect#expectaddsnapshotserializerserializer&quot;&gt; &lt;code&gt;expect.addSnapshotSerializer&lt;/code&gt; &lt;/a&gt; 를 호출 하여 Jest 구성에서 &lt;code&gt;snapshotSerializers&lt;/code&gt; 에 경로를 추가하는 대신 개별 테스트 파일에 대한 모듈을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7cd5137812be95f283926c769870dc2156199426" translate="yes" xml:space="preserve">
          <source>To make this work with Jest you need to update your Jest configuration with this: &lt;code&gt;&quot;transform&quot;: {&quot;\\.js$&quot;: &quot;path/to/custom-transformer.js&quot;}&lt;/code&gt;.</source>
          <target state="translated">Jest에서이 작업을 수행하려면 &lt;code&gt;&quot;transform&quot;: {&quot;\\.js$&quot;: &quot;path/to/custom-transformer.js&quot;}&lt;/code&gt; Jest 구성을 업데이트해야합니다 .</target>
        </trans-unit>
        <trans-unit id="579190d7cd820daa4fd8a13a589227f7e2eaf9e7" translate="yes" xml:space="preserve">
          <source>To resolve this, we will need to update our snapshot artifacts. You can run Jest with a flag that will tell it to re-generate snapshots:</source>
          <target state="translated">이 문제를 해결하려면 스냅 샷 아티팩트를 업데이트해야합니다. 스냅 샷을 다시 생성하라는 플래그로 Jest를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce42fc860995230ab9f043725c3815bd5aecd9d4" translate="yes" xml:space="preserve">
          <source>To test this function, we can use a mock function, and inspect the mock's state to ensure the callback is invoked as expected.</source>
          <target state="translated">이 함수를 테스트하기 위해 mock 함수를 사용하고 mock의 상태를 검사하여 콜백이 예상대로 호출되는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fe8e22ac596d3e8399b1774c9a6d272aedb50d5" translate="yes" xml:space="preserve">
          <source>To transform your existing tests, navigate to the project containing the tests and run:</source>
          <target state="translated">기존 테스트를 변환하려면 테스트가 포함 된 프로젝트로 이동하여 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="aa8c2a8d1b80b426924e3a346cf5aa28210292b8" translate="yes" xml:space="preserve">
          <source>To use &lt;a href=&quot;http://babeljs.io/&quot;&gt;Babel&lt;/a&gt;, install required dependencies via &lt;code&gt;yarn&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://babeljs.io/&quot;&gt;Babel&lt;/a&gt; 을 사용하려면 &lt;code&gt;yarn&lt;/code&gt; 을 통해 필요한 종속성을 설치하십시오 .</target>
        </trans-unit>
        <trans-unit id="4946751d041e4c3281bd74994c81b3a3ffb0fde6" translate="yes" xml:space="preserve">
          <source>To use &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt;, install required dependencies via &lt;code&gt;yarn&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt; 을 사용하려면 &lt;code&gt;yarn&lt;/code&gt; 을 통해 필요한 종속성을 설치하십시오 .</target>
        </trans-unit>
        <trans-unit id="45ff297d04a3d2c50427a66fd27f8359258dbfcd" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;my-serializer-module&lt;/code&gt; as a serializer, configuration would be as follows:</source>
          <target state="translated">&lt;code&gt;my-serializer-module&lt;/code&gt; 을 직렬 변환기로 사용하려면 다음과 같이 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="244873608d8f270057c41ef22dd861ecd2f588e8" translate="yes" xml:space="preserve">
          <source>To use snapshot testing inside of your custom matcher you can import &lt;code&gt;jest-snapshot&lt;/code&gt; and use it from within your matcher.</source>
          <target state="translated">사용자 정의 매처 내에서 스냅 샷 테스트를 사용하려면 &lt;code&gt;jest-snapshot&lt;/code&gt; 을 가져 와서 매처 내에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24551f54e6dc91a01a872c5230741bbe5ab3d386" translate="yes" xml:space="preserve">
          <source>To use this class as your custom environment, refer to it by its full path within the project. For example, if your class is stored in &lt;code&gt;my-custom-environment.js&lt;/code&gt; in some subfolder of your project, then the annotation might looke like this:</source>
          <target state="translated">이 클래스를 사용자 지정 환경으로 사용하려면 프로젝트 내 전체 경로로 참조하십시오. 예를 들어 클래스가 프로젝트의 일부 하위 폴더에 있는 &lt;code&gt;my-custom-environment.js&lt;/code&gt; 에 저장되어있는 경우 주석은 다음과 같을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d8bcde3184680e702bef641e43c9e47fee12e79" translate="yes" xml:space="preserve">
          <source>To write a test-runner, export a class with which accepts &lt;code&gt;globalConfig&lt;/code&gt; in the constructor, and has a &lt;code&gt;runTests&lt;/code&gt; method with the signature:</source>
          <target state="translated">테스트 실행기를 작성하려면 생성자에서 &lt;code&gt;globalConfig&lt;/code&gt; 를 허용 하고 서명 이있는 &lt;code&gt;runTests&lt;/code&gt; 메소드 가있는 클래스를 내보내십시오 .</target>
        </trans-unit>
        <trans-unit id="7e7fbc811015943c1c30e7ceeea8b05c76a8ee58" translate="yes" xml:space="preserve">
          <source>To:</source>
          <target state="translated">To:</target>
        </trans-unit>
        <trans-unit id="2aa91be80e98aceeddfc910352453386480fb849" translate="yes" xml:space="preserve">
          <source>Tool for extracting and parsing the comments at the top of a JavaScript file. Exports various functions to manipulate the data inside the comment block.</source>
          <target state="translated">JavaScript 파일 맨 위에서 주석을 추출하고 구문 분석하는 도구입니다. 주석 블록 내부의 데이터를 조작하기 위해 다양한 기능을 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="b2489dcd056dffceaf32fcd13112faa56f6733de" translate="yes" xml:space="preserve">
          <source>Tool for identifying modified files in a git/hg repository. Exports two functions:</source>
          <target state="translated">git / hg 저장소에서 수정 된 파일을 식별하는 도구입니다. 두 가지 기능을 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="bba6cd68031555a8aa461d4b5c0878aad6420744" translate="yes" xml:space="preserve">
          <source>Tool for validating configurations submitted by users. Exports a function that takes two arguments: the user's configuration and an object containing an example configuration and other options. The return value is an object with two attributes:</source>
          <target state="translated">사용자가 제출 한 구성을 검증하는 도구입니다. 사용자의 구성과 예제 구성 및 기타 옵션을 포함하는 객체라는 두 가지 인수를 취하는 함수를 내 보냅니다. 리턴 값은 두 가지 속성을 가진 오브젝트입니다.</target>
        </trans-unit>
        <trans-unit id="49e105a4ea6033c274af2894a4fcb5d0e03e7eb5" translate="yes" xml:space="preserve">
          <source>Tool for visualizing changes in data. Exports a function that compares two values of any type and returns a &quot;pretty-printed&quot; string illustrating the difference between the two arguments.</source>
          <target state="translated">데이터의 변화를 시각화하기위한 도구. 모든 유형의 두 값을 비교하는 함수를 내보내고 두 인수의 차이를 나타내는 &quot;꽤 인쇄 된&quot;문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="285ec850c11d78bac10f6bfa31b69a37f1b257c9" translate="yes" xml:space="preserve">
          <source>Troubleshooting</source>
          <target state="translated">Troubleshooting</target>
        </trans-unit>
        <trans-unit id="9a02428b2ce5edfe4a952ba3e66ede7b538c678d" translate="yes" xml:space="preserve">
          <source>Truthiness</source>
          <target state="translated">Truthiness</target>
        </trans-unit>
        <trans-unit id="6bce18334982e1e09a6fddd7fb83bd243818a5bd" translate="yes" xml:space="preserve">
          <source>Try running Jest with &lt;a href=&quot;cli#--watchman&quot;&gt;&lt;code&gt;--no-watchman&lt;/code&gt;&lt;/a&gt; or set the &lt;code&gt;watchman&lt;/code&gt; configuration option to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;cli#--watchman&quot;&gt; &lt;code&gt;--no-watchman&lt;/code&gt; 으로&lt;/a&gt; Jest를 실행 하거나 &lt;code&gt;watchman&lt;/code&gt; 구성 옵션을 &lt;code&gt;false&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="c5c112e63b4110470aacee270c74bf17085f1c78" translate="yes" xml:space="preserve">
          <source>Try using the debugging support built into Node. Note: This will only work in Node.js 8+.</source>
          <target state="translated">Node에 내장 된 디버깅 지원을 사용해보십시오. 참고 : 이것은 Node.js 8 이상에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="d4a86cb946d4af4766f6a695502b64f3ea0cd58b" translate="yes" xml:space="preserve">
          <source>TypeScript</source>
          <target state="translated">TypeScript</target>
        </trans-unit>
        <trans-unit id="88ebf4f8084b9e64c1280cb83273c9798bb6700b" translate="yes" xml:space="preserve">
          <source>Uh oh, something went wrong? Use this guide to resolve issues with Jest.</source>
          <target state="translated">어, 뭔가 잘못 됐어? 이 안내서를 사용하여 Jest 관련 문제를 해결하십시오.</target>
        </trans-unit>
        <trans-unit id="aed4821821385ee1bab0a8cb0c2780d5e1b4df72" translate="yes" xml:space="preserve">
          <source>Unresolved Promises</source>
          <target state="translated">해결되지 않은 약속</target>
        </trans-unit>
        <trans-unit id="bb0295c9e03b394a6c931085d1d4692dabdf5136" translate="yes" xml:space="preserve">
          <source>Updating Snapshots</source>
          <target state="translated">스냅 샷 업데이트</target>
        </trans-unit>
        <trans-unit id="53431747077771927601efb2109e96aa6b694e10" translate="yes" xml:space="preserve">
          <source>Usage is similar to the module factory function, except that you can omit the second argument from &lt;code&gt;jest.mock()&lt;/code&gt;, and you must import the mocked method into your test file, since it is no longer defined there. Use the original module path for this; don't include &lt;code&gt;__mocks__&lt;/code&gt;.</source>
          <target state="translated">사용법은 &lt;code&gt;jest.mock()&lt;/code&gt; 에서 두 번째 인수를 생략 할 수 있다는 점을 제외하고 모듈 팩토리 함수와 유사 합니다. 더 이상 정의되지 않은 모의 메소드를 테스트 파일로 가져와야합니다. 이를 위해 원래 모듈 경로를 사용하십시오. &lt;code&gt;__mocks__&lt;/code&gt; 는 포함하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="3b944d8872fd4ee30de2cd74c68ff456d47e22c9" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; string token to refer to &lt;a href=&quot;#rootdir-string&quot;&gt;&lt;code&gt;rootDir&lt;/code&gt;&lt;/a&gt; value if you want to use file paths.</source>
          <target state="translated">파일 경로를 사용 하려면 &lt;code&gt;&amp;lt;rootDir&amp;gt;&lt;/code&gt; 문자열 토큰을 사용하여 &lt;a href=&quot;#rootdir-string&quot;&gt; &lt;code&gt;rootDir&lt;/code&gt; &lt;/a&gt; 값 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="965fbdc0ee9e136c141ea84e0657f2fdfba937b0" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;--watchAll=false&lt;/code&gt; to explicitly disable the watch mode. Note that in most CI environments, this is automatically handled for you.</source>
          <target state="translated">사용 &lt;code&gt;--watchAll=false&lt;/code&gt; 를 명시 적으로 비활성화 시계 모드로. 대부분의 CI 환경에서 이는 자동으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="271c57d8c405fa9198756ec5064bbb4c3a46ab5a" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.rejects&lt;/code&gt; to unwrap the reason of a rejected promise so any other matcher can be chained. If the promise is fulfilled the assertion fails.</source>
          <target state="translated">거부 된 약속의 이유를 풀려면 다른. 매치를 연결할 수 있도록 &lt;code&gt;.rejects&lt;/code&gt; 를 사용하십시오 . 약속이 이행되면 어설 션이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="ff4d09b1ab22e18857563408d1fce004b2fe79a8" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toBe&lt;/code&gt; to compare primitive values or to check referential identity of object instances. It calls &lt;code&gt;Object.is&lt;/code&gt; to compare values, which is even better for testing than &lt;code&gt;===&lt;/code&gt; strict equality operator.</source>
          <target state="translated">&lt;code&gt;.toBe&lt;/code&gt; 를 사용 하여 기본 값을 비교하거나 오브젝트 인스턴스의 참조 ID를 확인하십시오. 값을 비교하기 위해 &lt;code&gt;Object.is&lt;/code&gt; 를 호출 하여 &lt;code&gt;===&lt;/code&gt; 완전 항등 연산자 보다 테스트에 더 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="67ef92856838e5751e399698b48aa87c7d8163a4" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toBeDefined&lt;/code&gt; to check that a variable is not undefined. For example, if you want to check that a function &lt;code&gt;fetchNewFlavorIdea()&lt;/code&gt; returns &lt;em&gt;something&lt;/em&gt;, you can write:</source>
          <target state="translated">&lt;code&gt;.toBeDefined&lt;/code&gt; 를 사용 하여 변수가 정의되지 않았 는지 확인하십시오. 예를 들어, &lt;code&gt;fetchNewFlavorIdea()&lt;/code&gt; 함수 가 &lt;em&gt;뭔가를&lt;/em&gt; 리턴 하는지 확인하려면 &lt;em&gt;다음&lt;/em&gt; 과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f81a87ad40dde8019daa6911a9c4296bf8a5d015" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toBeFalsy&lt;/code&gt; when you don't care what a value is and you want to ensure a value is false in a boolean context. For example, let's say you have some application code that looks like:</source>
          <target state="translated">값이 무엇인지 상관하지 않고 부울 컨텍스트에서 값이 false인지 확인하려는 경우 &lt;code&gt;.toBeFalsy&lt;/code&gt; 를 사용하십시오 . 예를 들어 다음과 같은 응용 프로그램 코드가 있다고 가정 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="50aa6948737b4375185feeebf13f13dbe3451e19" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toBeInstanceOf(Class)&lt;/code&gt; to check that an object is an instance of a class. This matcher uses &lt;code&gt;instanceof&lt;/code&gt; underneath.</source>
          <target state="translated">&lt;code&gt;.toBeInstanceOf(Class)&lt;/code&gt; 를 사용 하여 객체가 클래스의 인스턴스인지 확인하십시오. 이 매처는 아래 &lt;code&gt;instanceof&lt;/code&gt; 를 사용 합니다 .</target>
        </trans-unit>
        <trans-unit id="93a0ac0f3d847ffa6b85c3555bc23bce0abae9d2" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toBeNaN&lt;/code&gt; when checking a value is &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">값을 확인할 때 &lt;code&gt;.toBeNaN&lt;/code&gt; 을 사용 하면 &lt;code&gt;NaN&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5e05d177a2e90b6b046b4b02a5621b8f26893024" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toBeTruthy&lt;/code&gt; when you don't care what a value is and you want to ensure a value is true in a boolean context. For example, let's say you have some application code that looks like:</source>
          <target state="translated">값이 무엇인지 상관하지 않고 부울 컨텍스트에서 값이 true인지 확인하려는 경우 &lt;code&gt;.toBeTruthy&lt;/code&gt; 를 사용하십시오 . 예를 들어 다음과 같은 응용 프로그램 코드가 있다고 가정 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="c167d5affa8fa782feb54d90f30b85615f390e75" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toBeUndefined&lt;/code&gt; to check that a variable is undefined. For example, if you want to check that a function &lt;code&gt;bestDrinkForFlavor(flavor)&lt;/code&gt; returns &lt;code&gt;undefined&lt;/code&gt; for the &lt;code&gt;'octopus'&lt;/code&gt; flavor, because there is no good octopus-flavored drink:</source>
          <target state="translated">변수가 정의되지 않았 &lt;code&gt;.toBeUndefined&lt;/code&gt; 확인 하려면 .toBeUndefined 를 사용하십시오 . 예를 들어, 함수 문어 맛 음료가 없기 때문에 &lt;code&gt;bestDrinkForFlavor(flavor)&lt;/code&gt; 함수 가 &lt;code&gt;'octopus'&lt;/code&gt; 맛에 대해 &lt;code&gt;undefined&lt;/code&gt; 을 반환 하는지 확인하려는 경우 :</target>
        </trans-unit>
        <trans-unit id="a934298864a7697607ca428a7e4d71c72de7efbf" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toContain&lt;/code&gt; when you want to check that an item is in an array. For testing the items in the array, this uses &lt;code&gt;===&lt;/code&gt;, a strict equality check. &lt;code&gt;.toContain&lt;/code&gt; can also check whether a string is a substring of another string.</source>
          <target state="translated">항목이 배열에 있는지 확인 하려면 &lt;code&gt;.toContain&lt;/code&gt; 을 사용하십시오 . 배열의 항목을 테스트하기 위해 엄격한 평등 검사 인 &lt;code&gt;===&lt;/code&gt; 를 사용합니다 . &lt;code&gt;.toContain&lt;/code&gt; 은 문자열이 다른 문자열의 하위 문자열인지 확인할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd36fedc663beba2df99e661929cac1ca55d82a9" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toContainEqual&lt;/code&gt; when you want to check that an item with a specific structure and values is contained in an array. For testing the items in the array, this matcher recursively checks the equality of all fields, rather than checking for object identity.</source>
          <target state="translated">특정 구조와 값을 가진 항목이 배열에 포함되어 있는지 확인 하려면 &lt;code&gt;.toContainEqual&lt;/code&gt; 을 사용하십시오 . 배열의 항목을 테스트하기 위해이 매처는 오브젝트 ID를 확인하지 않고 모든 필드의 동등성을 재귀 적으로 점검합니다.</target>
        </trans-unit>
        <trans-unit id="2892f11bab4090104beb941f4d3d44f139cd4a21" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toEqual&lt;/code&gt; to compare recursively all properties of object instances (also known as &quot;deep&quot; equality). It calls &lt;code&gt;Object.is&lt;/code&gt; to compare primitive values, which is even better for testing than &lt;code&gt;===&lt;/code&gt; strict equality operator.</source>
          <target state="translated">&lt;code&gt;.toEqual&lt;/code&gt; 을 사용 하여 객체 인스턴스의 모든 속성 ( &quot;심각한&quot;평등이라고도 함)을 재귀 적으로 비교합니다. 원시 값을 비교하기 위해 &lt;code&gt;Object.is&lt;/code&gt; 를 호출 하므로 &lt;code&gt;===&lt;/code&gt; 완전 항등 연산자 보다 테스트에 더 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="22f31877b97035b92fb10441a1a3485e65903b49" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toHaveBeenCalled&lt;/code&gt; to ensure that a mock function got called.</source>
          <target state="translated">&lt;code&gt;.toHaveBeenCalled&lt;/code&gt; 를 사용 하여 모의 함수가 호출되었는지 확인 하십시오 .</target>
        </trans-unit>
        <trans-unit id="dfcaf02f56b10c94ecc202b3c8d9087baccb5181" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toHaveBeenCalledTimes&lt;/code&gt; to ensure that a mock function got called exact number of times.</source>
          <target state="translated">&lt;code&gt;.toHaveBeenCalledTimes&lt;/code&gt; 를 사용 하여 모의 함수가 정확한 횟수를 호출했는지 확인 하십시오 .</target>
        </trans-unit>
        <trans-unit id="6c8d2793887755a171ad2f5be4f1a01fc5c6e2d5" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toHaveBeenCalledWith&lt;/code&gt; to ensure that a mock function was called with specific arguments.</source>
          <target state="translated">&lt;code&gt;.toHaveBeenCalledWith&lt;/code&gt; 를 사용 하여 특정 인수로 모의 함수를 호출했는지 확인 하십시오 .</target>
        </trans-unit>
        <trans-unit id="4be0de20431e47e5724878c19b00a0321ac838e1" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toHaveLastReturnedWith&lt;/code&gt; to test the specific value that a mock function last returned. If the last call to the mock function threw an error, then this matcher will fail no matter what value you provided as the expected return value.</source>
          <target state="translated">mock 함수가 마지막으로 반환 한 특정 값을 테스트 하려면 &lt;code&gt;.toHaveLastReturnedWith&lt;/code&gt; 를 사용하십시오 . mock 함수에 대한 마지막 호출에서 오류가 발생하면 예상 한 반환 값으로 제공 한 값에 관계없이이 매 처가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="7001ece11621c6dd7371042298806dcb68ab8bdd" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toHaveLength&lt;/code&gt; to check that an object has a &lt;code&gt;.length&lt;/code&gt; property and it is set to a certain numeric value.</source>
          <target state="translated">&lt;code&gt;.toHaveLength&lt;/code&gt; 를 사용 하여 객체에 &lt;code&gt;.length&lt;/code&gt; 속성이 있고 특정 숫자 값으로 설정 되어 있는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="4a20c538c65f701e8900dd32f27f93e926fbf397" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toHaveNthReturnedWith&lt;/code&gt; to test the specific value that a mock function returned for the nth call. If the nth call to the mock function threw an error, then this matcher will fail no matter what value you provided as the expected return value.</source>
          <target state="translated">&lt;code&gt;.toHaveNthReturnedWith&lt;/code&gt; 를 사용 하여 mock 함수가 n 번째 호출에 대해 리턴 한 특정 값을 테스트하십시오. mock 함수에 대한 n 번째 호출에서 오류가 발생하면 예상 한 반환 값으로 제공 한 값에 관계없이이 매 처가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="bc794bedf39c69791593b20f2971ba46bf591e64" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toHaveProperty&lt;/code&gt; to check if property at provided reference &lt;code&gt;keyPath&lt;/code&gt; exists for an object. For checking deeply nested properties in an object you may use &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Property_accessors&quot;&gt;dot notation&lt;/a&gt; or an array containing the keyPath for deep references.</source>
          <target state="translated">&lt;code&gt;.toHaveProperty&lt;/code&gt; 를 사용 하여 제공된 참조 &lt;code&gt;keyPath&lt;/code&gt; 의 특성 이 오브젝트에 존재 하는지 확인하십시오 . 객체에 깊이 중첩 된 속성을 확인 하기 위해 깊은 참조를 위해 &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Property_accessors&quot;&gt;점 표기법&lt;/a&gt; 또는 keyPath가 포함 된 배열을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5c5db22f649bb5e433fce75313e71f348fcdbe60" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toHaveReturnedTimes&lt;/code&gt; to ensure that a mock function returned successfully (i.e., did not throw an error) an exact number of times. Any calls to the mock function that throw an error are not counted toward the number of times the function returned.</source>
          <target state="translated">&lt;code&gt;.toHaveReturnedTimes&lt;/code&gt; 를 사용 하여 mock 함수가 정확한 횟수만큼 성공적으로 리턴 (즉, 오류를 발생시키지 않았는지)하십시오. 오류를 발생시키는 모의 함수에 대한 호출은 함수가 리턴 한 횟수에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="00cc15ef74e3e3bbb9d04e26768f906229227777" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toHaveReturnedWith&lt;/code&gt; to ensure that a mock function returned a specific value.</source>
          <target state="translated">mock 함수가 특정 값을 반환하도록 하려면 &lt;code&gt;.toHaveReturnedWith&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="3403bfc7d77f929d8284a0b531fb242672320cf2" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toMatch&lt;/code&gt; to check that a string matches a regular expression.</source>
          <target state="translated">&lt;code&gt;.toMatch&lt;/code&gt; 를 사용 하여 문자열이 정규식과 일치하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="6aa577eec7c4f8e335bb974a5ba8a04b9b825d62" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toMatchObject&lt;/code&gt; to check that a JavaScript object matches a subset of the properties of an object. It will match received objects with properties that are &lt;strong&gt;not&lt;/strong&gt; in the expected object.</source>
          <target state="translated">&lt;code&gt;.toMatchObject&lt;/code&gt; 를 사용 하여 JavaScript 객체가 객체 속성의 하위 집합과 일치하는지 확인하십시오. 수신 된 개체를 예상 개체에 &lt;strong&gt;없는&lt;/strong&gt; 속성과 일치 시킵니다.</target>
        </trans-unit>
        <trans-unit id="43d74a2c2c927835dbc06a10fe0a834ecd3cf583" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toStrictEqual&lt;/code&gt; to test that objects have the same types as well as structure.</source>
          <target state="translated">&lt;code&gt;.toStrictEqual&lt;/code&gt; 을 사용 하여 객체의 유형과 구조가 동일한 지 테스트 하십시오 .</target>
        </trans-unit>
        <trans-unit id="60e9ea675b7707c4a125a8d5da6124d2b7dfa82a" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toThrow&lt;/code&gt; to test that a function throws when it is called. For example, if we want to test that &lt;code&gt;drinkFlavor('octopus')&lt;/code&gt; throws, because octopus flavor is too disgusting to drink, we could write:</source>
          <target state="translated">&lt;code&gt;.toThrow&lt;/code&gt; 를 사용 하여 함수가 호출 될 때 발생하는지 테스트합니다. 예를 들어, 우리가 &lt;code&gt;drinkFlavor('octopus')&lt;/code&gt; 가 던지는 지를 테스트하고 싶다면 문어 맛이 너무 역겨워서 다음 과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8835c8692fc22c521a477117dec692aecc544e4" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toThrowErrorMatchingInlineSnapshot&lt;/code&gt; to test that a function throws an error matching the most recent snapshot when it is called.</source>
          <target state="translated">&lt;code&gt;.toThrowErrorMatchingInlineSnapshot&lt;/code&gt; 을 사용 하여 함수가 가장 최근의 스냅 샷이 호출 될 때 일치하는 오류가 발생하는지 테스트 하십시오 .</target>
        </trans-unit>
        <trans-unit id="8656cd1667dc531479d8b4cb204dd90a1579844f" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;.toThrowErrorMatchingSnapshot&lt;/code&gt; to test that a function throws an error matching the most recent snapshot when it is called.</source>
          <target state="translated">&lt;code&gt;.toThrowErrorMatchingSnapshot&lt;/code&gt; 을 사용 하여 함수가 호출 될 때 가장 최근의 스냅 샷과 일치하는 오류가 발생하는지 테스트 하십시오 .</target>
        </trans-unit>
        <trans-unit id="0440b25bd05f6a2e3c56826df198b652d25c12c6" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;describe.each&lt;/code&gt; if you keep duplicating the same test suites with different data. &lt;code&gt;describe.each&lt;/code&gt; allows you to write the test suite once and pass data in.</source>
          <target state="translated">다른 데이터로 동일한 테스트 스위트를 계속 복제하는 경우 &lt;code&gt;describe.each&lt;/code&gt; 를 사용하십시오 . &lt;code&gt;describe.each&lt;/code&gt; 를 사용하면 테스트 스위트를 한 번 작성하고 데이터를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef60fa41c287f5e40cf5103947099b8fe473bb0e" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;describe.only.each&lt;/code&gt; if you want to only run specific tests suites of data driven tests.</source>
          <target state="translated">특정 데이터 구동 테스트 세트 만 실행 하려면 &lt;code&gt;describe.only.each&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="cedc27af374f9505722e2e0748157f331b8c1a04" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;describe.skip.each&lt;/code&gt; if you want to stop running a suite of data driven tests.</source>
          <target state="translated">일련의 데이터 기반 테스트 실행을 중지 하려면 &lt;code&gt;describe.skip.each&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="d406a9d711b46330782be9bc2cb621080a4ae6f6" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;react-test-renderer&lt;/code&gt;. The test renderer doesn't care about element types and will happily accept e.g. &lt;code&gt;SomeComponent&lt;/code&gt;. You could check snapshots using the test renderer, and check component behavior separately using Enzyme.</source>
          <target state="translated">&lt;code&gt;react-test-renderer&lt;/code&gt; 를 사용하십시오 . 테스트 렌더러는 요소 유형에 신경 쓰지 않으며 예를 들어 &lt;code&gt;SomeComponent&lt;/code&gt; 를 행복하게 받아들 입니다. 테스트 렌더러를 사용하여 스냅 샷을 확인하고 Enzyme을 사용하여 구성 요소 동작을 개별적으로 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e3d957c7581b38a6f6d9efe05f990ae9f8f779c" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;resolves&lt;/code&gt; to unwrap the value of a fulfilled promise so any other matcher can be chained. If the promise is rejected the assertion fails.</source>
          <target state="translated">사용 &lt;code&gt;resolves&lt;/code&gt; 다른 정규은 체인 될 수 있도록 이행 약속의 값 랩을 해제 할 수 있습니다. 약속이 거부되면 어설 션이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="1345114e2fd1c60a6d60edc7450f9a4afadae484" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;test.concurrent.each&lt;/code&gt; if you keep duplicating the same test with different data. &lt;code&gt;test.each&lt;/code&gt; allows you to write the test once and pass data in, the tests are all run asynchronously.</source>
          <target state="translated">다른 데이터로 동일한 테스트를 계속 복제하는 경우 &lt;code&gt;test.concurrent.each&lt;/code&gt; 를 사용하십시오 . &lt;code&gt;test.each&lt;/code&gt; 를 사용하면 테스트를 한 번 작성하고 데이터를 전달할 수 있으며 테스트는 모두 비동기 적으로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="0ef6514f1b68a3a68401c341c0da426d04e4aa20" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;test.concurrent.only.each&lt;/code&gt; if you want to only run specific tests with different test data concurrently.</source>
          <target state="translated">다른 테스트 데이터가있는 특정 테스트 만 동시에 실행 하려면 &lt;code&gt;test.concurrent.only.each&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="263222bc2f899a0d715a6fab20c766f111044fc2" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;test.concurrent.skip.each&lt;/code&gt; if you want to stop running a collection of asynchronous data driven tests.</source>
          <target state="translated">비동기 데이터 기반 테스트의 실행을 중지 하려면 &lt;code&gt;test.concurrent.skip.each&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="6e28dd2d14db9066d63653631068e696eab675f0" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;test.concurrent&lt;/code&gt; if you want the test to run concurrently.</source>
          <target state="translated">테스트를 동시에 실행 하려면 &lt;code&gt;test.concurrent&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="3afb7e6906f2b3257d85cde9c36efa5c6e5bcbfc" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;test.each&lt;/code&gt; if you keep duplicating the same test with different data. &lt;code&gt;test.each&lt;/code&gt; allows you to write the test once and pass data in.</source>
          <target state="translated">다른 데이터로 동일한 테스트를 계속 반복하는 경우 &lt;code&gt;test.each&lt;/code&gt; 를 사용하십시오 . &lt;code&gt;test.each&lt;/code&gt; 를 사용하면 테스트를 한 번 작성하고 데이터를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ed7e082f3c3b04fc36bc3b9da1fb4c701925c6d" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;test.only.each&lt;/code&gt; if you want to only run specific tests with different test data.</source>
          <target state="translated">다른 테스트 데이터로 특정 테스트 만 실행 하려면 &lt;code&gt;test.only.each&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="9a662231e654755bb86491a61d19bfda30bf8dea" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;test.skip.each&lt;/code&gt; if you want to stop running a collection of data driven tests.</source>
          <target state="translated">데이터 구동 테스트 콜렉션 실행을 중지 하려면 &lt;code&gt;test.skip.each&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="04f44ceaa0fcfd12976de28307ac74bab48f40fa" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;test.todo&lt;/code&gt; when you are planning on writing tests. These tests will be highlighted in the summary output at the end so you know how many tests you still need todo.</source>
          <target state="translated">테스트 작성을 계획 할 때는 &lt;code&gt;test.todo&lt;/code&gt; 를 사용하십시오 . 이 테스트는 마지막에 요약 출력에서 ​​강조 표시되므로 여전히 수행해야 할 테스트 수를 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72b53cf691901a7f6c7db879139a7d5cc2a021bd" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;toBeCloseTo&lt;/code&gt; to compare floating point numbers for approximate equality.</source>
          <target state="translated">&lt;code&gt;toBeCloseTo&lt;/code&gt; 를 사용 하여 거의 같은지 부동 소수점 수를 비교합니다.</target>
        </trans-unit>
        <trans-unit id="67135d0a79cc68d7ce480429610bb2f2628671fa" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;toBeGreaterThan&lt;/code&gt; to compare &lt;code&gt;received &amp;gt; expected&lt;/code&gt; for number or big integer values. For example, test that &lt;code&gt;ouncesPerCan()&lt;/code&gt; returns a value of more than 10 ounces:</source>
          <target state="translated">&lt;code&gt;toBeGreaterThan&lt;/code&gt; 을 사용 하여 &lt;code&gt;received &amp;gt; expected&lt;/code&gt; 숫자 또는 큰 정수 값에 대해 예상 됨을 비교 하십시오 . 예를 들어 &lt;code&gt;ouncesPerCan()&lt;/code&gt; 이 10 온스 이상의 값을 반환 하는지 테스트합니다 .</target>
        </trans-unit>
        <trans-unit id="3930db7617a0eec776a6b70b86ff9f67aaf7165d" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;toBeGreaterThanOrEqual&lt;/code&gt; to compare &lt;code&gt;received &amp;gt;= expected&lt;/code&gt; for number or big integer values. For example, test that &lt;code&gt;ouncesPerCan()&lt;/code&gt; returns a value of at least 12 ounces:</source>
          <target state="translated">&lt;code&gt;toBeGreaterThanOrEqual&lt;/code&gt; 을 사용 하여 숫자 또는 큰 정수 값에 대해 &lt;code&gt;received &amp;gt;= expected&lt;/code&gt; 값 을 비교 하십시오 . 예를 들어 &lt;code&gt;ouncesPerCan()&lt;/code&gt; 최소 12 온스의 값을 반환 하는지 테스트합니다 .</target>
        </trans-unit>
        <trans-unit id="2c60b4cd3422307c10fbc69a5ebc0d409a25e545" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;toBeLessThan&lt;/code&gt; to compare &lt;code&gt;received &amp;lt; expected&lt;/code&gt; for number or big integer values. For example, test that &lt;code&gt;ouncesPerCan()&lt;/code&gt; returns a value of less than 20 ounces:</source>
          <target state="translated">&lt;code&gt;toBeLessThan&lt;/code&gt; 을 사용 하여 숫자 또는 큰 정수 값에 대해 &lt;code&gt;received &amp;lt; expected&lt;/code&gt; 값 을 비교 하십시오 . 예를 들어 &lt;code&gt;ouncesPerCan()&lt;/code&gt; 이 20 온스 미만의 값을 반환 하는지 테스트합니다 .</target>
        </trans-unit>
        <trans-unit id="98ee9741a4bceeea1bf6f12bd38538086556426e" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;toBeLessThanOrEqual&lt;/code&gt; to compare &lt;code&gt;received &amp;lt;= expected&lt;/code&gt; for number or big integer values. For example, test that &lt;code&gt;ouncesPerCan()&lt;/code&gt; returns a value of at most 12 ounces:</source>
          <target state="translated">사용하다 &lt;code&gt;toBeLessThanOrEqual&lt;/code&gt; 을 하여 숫자 또는 큰 정수 값에 대해 &lt;code&gt;received &amp;lt;= expected&lt;/code&gt; 값 을 비교 . 예를 들어 &lt;code&gt;ouncesPerCan()&lt;/code&gt; 최대 12 온스의 값을 반환 하는지 테스트합니다 .</target>
        </trans-unit>
        <trans-unit id="67497066b431f7970b52aff03e2267c3031fe3af" translate="yes" xml:space="preserve">
          <source>Use it in your Jest config file like this:</source>
          <target state="translated">다음과 같이 Jest 구성 파일에서 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="759c0eb81e3b691ac63ce62826c9faeffd303147" translate="yes" xml:space="preserve">
          <source>Use jest-dynamodb Preset</source>
          <target state="translated">jest-dynamodb 사전 설정 사용</target>
        </trans-unit>
        <trans-unit id="7194dde7b6fdc7725f8efc98a8775cd0fe57fa0a" translate="yes" xml:space="preserve">
          <source>Use jest-mongodb Preset</source>
          <target state="translated">jest-mongodb 사전 설정 사용</target>
        </trans-unit>
        <trans-unit id="d6629ac509cad69b4360ba597e78efb90888b162" translate="yes" xml:space="preserve">
          <source>Use jest-puppeteer Preset</source>
          <target state="translated">jest-puppeteer 프리셋 사용</target>
        </trans-unit>
        <trans-unit id="8859f21b394eb7bddbe02c98d39f3c5d61b96c00" translate="yes" xml:space="preserve">
          <source>Use this configuration option to add custom reporters to Jest. A custom reporter is a class that implements &lt;code&gt;onRunStart&lt;/code&gt;, &lt;code&gt;onTestStart&lt;/code&gt;, &lt;code&gt;onTestResult&lt;/code&gt;, &lt;code&gt;onRunComplete&lt;/code&gt; methods that will be called when any of those events occurs.</source>
          <target state="translated">이 구성 옵션을 사용하여 Jest에 사용자 정의 리포터를 추가하십시오. 사용자 정의 리포터는 해당 이벤트가 발생할 때 호출되는 &lt;code&gt;onRunStart&lt;/code&gt; , &lt;code&gt;onTestStart&lt;/code&gt; , &lt;code&gt;onTestResult&lt;/code&gt; , &lt;code&gt;onRunComplete&lt;/code&gt; 메소드를 구현하는 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="0ce722d28dd2ac22869f544554814473ced27729" translate="yes" xml:space="preserve">
          <source>Useful to create async mock functions that will always reject:</source>
          <target state="translated">항상 거부하는 비동기 모의 함수를 만드는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="82fe22471a3c89a8a884379e2a589a9b9393684f" translate="yes" xml:space="preserve">
          <source>Useful to mock async functions in async tests:</source>
          <target state="translated">비동기 테스트에서 비동기 함수를 조롱하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="4d6f5093469250351be715bab11328d708148671" translate="yes" xml:space="preserve">
          <source>Useful to resolve different values over multiple async calls:</source>
          <target state="translated">여러 비동기 호출에서 다른 값을 해결하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="8386651610226fd04ae64f938ef5bbd0efe279f3" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;describe.skip&lt;/code&gt; is often a cleaner alternative to temporarily commenting out a chunk of tests.</source>
          <target state="translated">&lt;code&gt;describe.skip&lt;/code&gt; 을 사용 하는 것은 종종 테스트 덩어리를 일시적으로 주석 처리하는보다 확실한 대안입니다.</target>
        </trans-unit>
        <trans-unit id="8da013e9c1193b5fd4e55adc4f5c72966bc2f345" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;jest.doMock()&lt;/code&gt; with ES6 imports requires additional steps. Follow these if you don't want to use &lt;code&gt;require&lt;/code&gt; in your tests:</source>
          <target state="translated">ES6 가져 오기와 함께 &lt;code&gt;jest.doMock()&lt;/code&gt; 을 사용 하려면 추가 단계가 필요합니다. 테스트에서 &lt;code&gt;require&lt;/code&gt; 를 사용하지 않으려면 다음을 수행 하십시오.</target>
        </trans-unit>
        <trans-unit id="5b7ceb252455569b8991c8fe4bfba034672b82cf" translate="yes" xml:space="preserve">
          <source>Using Babel</source>
          <target state="translated">바벨 사용</target>
        </trans-unit>
        <trans-unit id="ad353105ab08c29227ad5d0775b29687a1b718c7" translate="yes" xml:space="preserve">
          <source>Using Matchers</source>
          <target state="translated">매처 사용</target>
        </trans-unit>
        <trans-unit id="8c578fdee5f39cae171b3ae3dc5e52be3eb3db63" translate="yes" xml:space="preserve">
          <source>Using TypeScript</source>
          <target state="translated">TypeScript 사용</target>
        </trans-unit>
        <trans-unit id="e2b797adce82409b798a1e85b5f20128645a30c7" translate="yes" xml:space="preserve">
          <source>Using a mock function</source>
          <target state="translated">모의 함수 사용</target>
        </trans-unit>
        <trans-unit id="fdad49cc59429141e7cc6464244c820172f9da4a" translate="yes" xml:space="preserve">
          <source>Using exact equality with floating point numbers is a bad idea. Rounding means that intuitive things fail. For example, this test fails:</source>
          <target state="translated">부동 소수점 숫자에 정확한 동등성을 사용하는 것은 좋지 않습니다. 반올림은 직관적 인 일이 실패 함을 의미합니다. 예를 들어이 테스트는 실패합니다.</target>
        </trans-unit>
        <trans-unit id="3dfac5af5bd078779708abe2d31733f55ae203b9" translate="yes" xml:space="preserve">
          <source>Using parcel</source>
          <target state="translated">소포 사용</target>
        </trans-unit>
        <trans-unit id="d56e8185a2d6c77ca4726dcd2b55295a60bd2572" translate="yes" xml:space="preserve">
          <source>Using webpack</source>
          <target state="translated">웹팩 사용</target>
        </trans-unit>
        <trans-unit id="a5bf7b56e0fe9da5b66e110d7867887929aa794f" translate="yes" xml:space="preserve">
          <source>Using with DynamoDB</source>
          <target state="translated">DynamoDB와 함께 사용</target>
        </trans-unit>
        <trans-unit id="ad43d620306250954a4a631c111cb745bc0804de" translate="yes" xml:space="preserve">
          <source>Using with ES module imports</source>
          <target state="translated">ES 모듈 가져 오기와 함께 사용</target>
        </trans-unit>
        <trans-unit id="44be8a58330b5c23182d2274fdfd6efbdf4e83a9" translate="yes" xml:space="preserve">
          <source>Using with MongoDB</source>
          <target state="translated">MongoDB와 함께 사용</target>
        </trans-unit>
        <trans-unit id="785e92a5d24055ece246e1162c6d740443f3f058" translate="yes" xml:space="preserve">
          <source>Using with npm scripts</source>
          <target state="translated">npm 스크립트와 함께 사용</target>
        </trans-unit>
        <trans-unit id="094d8ae70af4304a0d4b4a837d18e1de8f8424c0" translate="yes" xml:space="preserve">
          <source>Using with puppeteer</source>
          <target state="translated">꼭두각시와 함께 사용</target>
        </trans-unit>
        <trans-unit id="62915756095c500af390187568578de70abf9244" translate="yes" xml:space="preserve">
          <source>Using with webpack</source>
          <target state="translated">웹팩과 함께 사용</target>
        </trans-unit>
        <trans-unit id="2f6a259c826a5d9735d5a64063f1b31e207c2685" translate="yes" xml:space="preserve">
          <source>Using with webpack 2</source>
          <target state="translated">웹팩 2와 함께 사용</target>
        </trans-unit>
        <trans-unit id="e92e8a4901b69fac997e23f82569d015987ccae6" translate="yes" xml:space="preserve">
          <source>Using with yarn</source>
          <target state="translated">원사와 함께 사용</target>
        </trans-unit>
        <trans-unit id="41c1155f49d57702ee239db81113c543bd9591e4" translate="yes" xml:space="preserve">
          <source>Usually you wouldn't check code using &lt;code&gt;test.only&lt;/code&gt; into source control - you would use it for debugging, and remove it once you have fixed the broken tests.</source>
          <target state="translated">일반적 으로 소스 제어에서 &lt;code&gt;test.only&lt;/code&gt; 를 사용하여 코드를 검사하지 않습니다. 디버깅에 코드를 사용 하고 깨진 테스트를 수정하면 코드를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="8bd43b7ad188ce8c3bb9691452ec856dcccbc84c" translate="yes" xml:space="preserve">
          <source>Vue.js</source>
          <target state="translated">Vue.js</target>
        </trans-unit>
        <trans-unit id="4af321d3223afd7ac8763fbd38707f1b871aa01e" translate="yes" xml:space="preserve">
          <source>Warning: If we want to mock Node's core modules (e.g.: &lt;code&gt;fs&lt;/code&gt; or &lt;code&gt;path&lt;/code&gt;), then explicitly calling e.g. &lt;code&gt;jest.mock('path')&lt;/code&gt; is &lt;strong&gt;required&lt;/strong&gt;, because core Node modules are not mocked by default.</source>
          <target state="translated">경고 : 우리는 노드의 핵심 모듈 조롱하려는 경우 (예 : &lt;code&gt;fs&lt;/code&gt; 또는 &lt;code&gt;path&lt;/code&gt; ), 다음 명시 적으로 예를 들어, 호출 &lt;code&gt;jest.mock('path')&lt;/code&gt; 됩니다 &lt;strong&gt;필요한&lt;/strong&gt; 핵심 노드 모듈이 기본적으로 조롱하지 않기 때문에.</target>
        </trans-unit>
        <trans-unit id="d0993b420d1ece1c116d94df1eb882929103aacb" translate="yes" xml:space="preserve">
          <source>Watch Menu Integration</source>
          <target state="translated">시계 메뉴 통합</target>
        </trans-unit>
        <trans-unit id="77162c2c5b3f4537b5a429cc13193176c9944f13" translate="yes" xml:space="preserve">
          <source>Watch Plugin Interface</source>
          <target state="translated">플러그인 인터페이스보기</target>
        </trans-unit>
        <trans-unit id="730cb1589addfecd42b5dc91914d54090940dd7b" translate="yes" xml:space="preserve">
          <source>Watch Plugins</source>
          <target state="translated">플러그인보기</target>
        </trans-unit>
        <trans-unit id="1b41755710b08ba989fe2719763a7cc16cd093cd" translate="yes" xml:space="preserve">
          <source>Watch files for changes and rerun all tests when something changes. If you want to re-run only the tests that depend on the changed files, use the &lt;code&gt;--watch&lt;/code&gt; option.</source>
          <target state="translated">변경 사항이 있는지 파일을 관찰하고 변경 사항이있을 때 모든 테스트를 다시 실행하십시오. 변경된 파일에 의존하는 테스트 만 다시 실행하려면 &lt;code&gt;--watch&lt;/code&gt; 옵션을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0f500e5f9a091c5d91b9402809c2e1bfb82401f3" translate="yes" xml:space="preserve">
          <source>Watch files for changes and rerun tests related to changed files. If you want to re-run all tests when a file has changed, use the &lt;code&gt;--watchAll&lt;/code&gt; option instead.</source>
          <target state="translated">파일이 변경되었는지 확인하고 변경된 파일과 관련된 테스트를 다시 실행하십시오. 파일이 변경되었을 때 모든 테스트를 다시 실행하려면 &lt;code&gt;--watchAll&lt;/code&gt; 옵션을 대신 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="6a33b701f8666961875a562f2fa71a7405de7c06" translate="yes" xml:space="preserve">
          <source>Watch mode also enables to specify the name or path to a file to focus on a specific set of tests.</source>
          <target state="translated">감시 모드를 사용하면 특정 테스트 세트에 중점을 둘 파일의 이름 또는 경로를 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="acd93772ed153d854aedd488090f5c82e983b44d" translate="yes" xml:space="preserve">
          <source>Watch plugin YourFaultyPlugin attempted to register key &lt;code&gt;q&lt;/code&gt;, that is reserved internally for quitting watch mode. Please change the configuration key for this plugin.</source>
          <target state="translated">Watch 플러그인 YourFaultyPlugin이 키 등록을 시도했습니다. &lt;code&gt;q&lt;/code&gt; 이 감시 모드를 종료하기 위해 내부적으로 예약 q . 이 플러그인의 구성 키를 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="aff9902a15b762dc90c7266ccddd98d2b3f64e24" translate="yes" xml:space="preserve">
          <source>Watch plugin YourFaultyPlugin attempted to register key &lt;q&gt;, that is reserved internally for quitting watch mode. Please change the configuration key for this plugin.&lt;/q&gt;</source>
          <target state="translated">감시 플러그인 YourFaultyPlugin &lt;q&gt;이 감시 모드 종료를 위해 내부적으로 예약&lt;/q&gt; 된 키 등록을 시도했습니다 &lt;q&gt;. 이 플러그인의 구성 키를 변경하십시오.&lt;/q&gt;</target>
        </trans-unit>
        <trans-unit id="a673577265e6ead99e3c23f76e5f29409c5b7d10" translate="yes" xml:space="preserve">
          <source>Watch plugins YourFaultyPlugin and TheirFaultyPlugin both attempted to register key</source>
          <target state="translated">플러그인 YourFaultyPlugin 및 TheyFaultyPlugin이 키 등록을 시도했습니다.</target>
        </trans-unit>
        <trans-unit id="570ca6efbd4ac29fbe2679f4f54ef1e9c4dfefbc" translate="yes" xml:space="preserve">
          <source>Watch plugins YourFaultyPlugin and TheirFaultyPlugin both attempted to register key &lt;code&gt;x&lt;/code&gt;. Please change the key configuration for one of the conflicting plugins to avoid overlap.</source>
          <target state="translated">Watch plugins YourFaultyPlugin 및 TheyFaultyPlugin 모두 키 등록을 시도했습니다. &lt;code&gt;x&lt;/code&gt; . 겹치지 않도록 충돌하는 플러그인 중 하나의 키 구성을 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="1a8e0b7b820fac76887499e0730014073b6942fc" translate="yes" xml:space="preserve">
          <source>Watchman Issues</source>
          <target state="translated">경비원 문제</target>
        </trans-unit>
        <trans-unit id="58ed43a0f07990c616800d6e405003e52deb7101" translate="yes" xml:space="preserve">
          <source>We are mocking &lt;code&gt;fetchCurrentUser.js&lt;/code&gt; so that our test doesn't make a real network request but instead resolves to mock data locally. This ensures that our test can complete in milliseconds rather than seconds and guarantees a fast unit test iteration speed.</source>
          <target state="translated">우리는 조롱하는 &lt;code&gt;fetchCurrentUser.js&lt;/code&gt; 을 우리의 테스트는 실제 네트워크 요청을하지 않도록하는 대신 로컬 모의 데이터를 해결합니다. 이를 통해 테스트가 초 단위가 아닌 밀리 초 단위로 완료 될 수 있으며 빠른 단위 테스트 반복 속도가 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="39fcaf5408d64ca526faacb5d58f9141c191b735" translate="yes" xml:space="preserve">
          <source>We call &lt;code&gt;jest.mock('../request')&lt;/code&gt; to tell Jest to use our manual mock. &lt;code&gt;it&lt;/code&gt; expects the return value to be a Promise that is going to be resolved. You can chain as many Promises as you like and call &lt;code&gt;expect&lt;/code&gt; at any time, as long as you return a Promise at the end.</source>
          <target state="translated">&lt;code&gt;jest.mock('../request')&lt;/code&gt; 를 호출 하여 Jest에게 수동 모의를 사용하도록 지시합니다. &lt;code&gt;it&lt;/code&gt; 반환 값이 해결 될 것입니다 약속이 될 것으로 기대하고있다. 마지막에 약속을 반환하는 한 언제든지 원하는 만큼 약속을 연결하고 전화를 걸 &lt;code&gt;expect&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="69b678bb69e79c49e5b0a08e85e9a17993259892" translate="yes" xml:space="preserve">
          <source>We could test this error gets thrown in several ways:</source>
          <target state="translated">이 오류가 여러 가지 방식으로 발생하는지 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0bd52959384de0efc9e324b40ef0a059ef8e64cd" translate="yes" xml:space="preserve">
          <source>We have to specify the &lt;code&gt;__esModule: true&lt;/code&gt; property (see the &lt;a href=&quot;#jestmockmodulename-factory-options&quot;&gt;&lt;code&gt;jest.mock()&lt;/code&gt;&lt;/a&gt; API for more information).</source>
          <target state="translated">&lt;code&gt;__esModule: true&lt;/code&gt; 속성 을 지정해야합니다 (자세한 내용은 &lt;a href=&quot;#jestmockmodulename-factory-options&quot;&gt; &lt;code&gt;jest.mock()&lt;/code&gt; &lt;/a&gt; API 참조).</target>
        </trans-unit>
        <trans-unit id="58e30d514b365fc2673e994c86e9d1067f92cb36" translate="yes" xml:space="preserve">
          <source>We recommend placing the extensions most commonly used in your project on the left, so if you are using TypeScript, you may want to consider moving &quot;ts&quot; and/or &quot;tsx&quot; to the beginning of the array.</source>
          <target state="translated">프로젝트에서 가장 일반적으로 사용되는 확장명을 왼쪽에 배치하는 것이 좋습니다. 따라서 TypeScript를 사용하는 경우 &quot;ts&quot;및 / 또는 &quot;tsx&quot;를 배열의 시작 부분으로 이동하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="49cfe85b5d9f91e87c2bb6c4919d6422b42d36a2" translate="yes" xml:space="preserve">
          <source>We'll use a contrived example of a class that plays sound files, &lt;code&gt;SoundPlayer&lt;/code&gt;, and a consumer class which uses that class, &lt;code&gt;SoundPlayerConsumer&lt;/code&gt;. We'll mock &lt;code&gt;SoundPlayer&lt;/code&gt; in our tests for &lt;code&gt;SoundPlayerConsumer&lt;/code&gt;.</source>
          <target state="translated">사운드 파일을 재생하는 클래스 인 &lt;code&gt;SoundPlayer&lt;/code&gt; 와 그 클래스를 사용하는 소비자 클래스 인 &lt;code&gt;SoundPlayerConsumer&lt;/code&gt; 를 사용합니다 . &lt;code&gt;SoundPlayer&lt;/code&gt; Consumer 테스트에서 &lt;code&gt;SoundPlayerConsumer&lt;/code&gt; 조롱 합니다.</target>
        </trans-unit>
        <trans-unit id="7a570bfe57d90629aa64647c14bb9b9299f88f21" translate="yes" xml:space="preserve">
          <source>We've told Jest to ignore files matching a stylesheet or image extension, and instead, require our mock files. You can adjust the regular expression to match the file types your webpack config handles.</source>
          <target state="translated">Jest는 스타일 시트 또는 이미지 확장자와 일치하는 파일을 무시하고 대신 모의 파일이 필요하다고 지시했습니다. 웹팩 구성이 처리하는 파일 유형과 일치하도록 정규식을 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e27e07bef6adeae0276f0cd001319eb48d71a2c" translate="yes" xml:space="preserve">
          <source>What is the performance of snapshot testing regarding speed and size of the generated files?</source>
          <target state="translated">생성 된 파일의 속도 및 크기와 관련하여 스냅 샷 테스트의 성능은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="3bc8902ad3e552d6e229d9ad2fb118f5b3735490" translate="yes" xml:space="preserve">
          <source>What's the difference between snapshot testing and visual regression testing?</source>
          <target state="translated">스냅 샷 테스트와 시각적 회귀 테스트의 차이점은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="18c42c157f8a61af5c55926418fd204e7a9c5be1" translate="yes" xml:space="preserve">
          <source>When Jest runs your test to collect the &lt;code&gt;test&lt;/code&gt;s it will not find any because we have set the definition to happen asynchronously on the next tick of the event loop.</source>
          <target state="translated">농담이 수집하는 테스트를 실행하면 &lt;code&gt;test&lt;/code&gt; 들 우리는 이벤트 루프의 다음 틱에 비동기 적으로 발생하는 정의를 설정했기 때문에 그것은 어떤을 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="66a712f9c4762f8fb45d196c8b569be5ba0595bc" translate="yes" xml:space="preserve">
          <source>When a conflict happens</source>
          <target state="translated">충돌이 발생했을 때</target>
        </trans-unit>
        <trans-unit id="6ddcfa27c2af8b12d25959aeb81f42c8a1e31340" translate="yes" xml:space="preserve">
          <source>When a manual mock exists for a given module, Jest's module system will use that module when explicitly calling &lt;code&gt;jest.mock('moduleName')&lt;/code&gt;. However, when &lt;code&gt;automock&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, the manual mock implementation will be used instead of the automatically created mock, even if &lt;code&gt;jest.mock('moduleName')&lt;/code&gt; is not called. To opt out of this behavior you will need to explicitly call &lt;code&gt;jest.unmock('moduleName')&lt;/code&gt; in tests that should use the actual module implementation.</source>
          <target state="translated">지정된 모듈에 대해 수동 모의가 존재하면 Jest의 모듈 시스템은 &lt;code&gt;jest.mock('moduleName')&lt;/code&gt; 을 명시 적으로 호출 할 때 해당 모듈을 사용합니다 . 그러나 &lt;code&gt;automock&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 로 설정 되면 &lt;code&gt;jest.mock('moduleName')&lt;/code&gt; 이 호출되지 않아도 자동으로 작성된 모의 대신 수동 모의 구현이 사용됩니다 . 이 동작을 선택 해제하려면 실제 모듈 구현을 사용해야하는 테스트에서 &lt;code&gt;jest.unmock('moduleName')&lt;/code&gt; 을 명시 적으로 호출 해야합니다.</target>
        </trans-unit>
        <trans-unit id="f71f327fabbf5c0637780926759d884ef99d4c6f" translate="yes" xml:space="preserve">
          <source>When an assertion fails, the error message should give as much signal as necessary to the user so they can resolve their issue quickly. You should craft a precise failure message to make sure users of your custom assertions have a good developer experience.</source>
          <target state="translated">어설 션이 실패하면 오류 메시지가 사용자에게 필요한만큼 많은 신호를 보내서 문제를 빠르게 해결할 수 있어야합니다. 사용자 지정 어설 ​​션 사용자에게 개발자 환경이 양호하도록 정확한 실패 메시지를 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="92e3cf49c2e3a6035ec045cc54417bfd2ccb1023" translate="yes" xml:space="preserve">
          <source>When mocking time, &lt;code&gt;Date.now()&lt;/code&gt; will also be mocked. If you for some reason need access to the real current time, you can invoke this function.</source>
          <target state="translated">시간을 조롱 할 때 &lt;code&gt;Date.now()&lt;/code&gt; 도 조롱됩니다. 어떤 이유로 실시간으로 액세스해야하는 경우이 함수를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d8bace675f1044daa5589643fe0fa171a34a422" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;projects&lt;/code&gt; configuration is provided with an array of paths or glob patterns, Jest will run tests in all of the specified projects at the same time. This is great for monorepos or when working on multiple projects at the same time.</source>
          <target state="translated">때 &lt;code&gt;projects&lt;/code&gt; 구성 경로 또는 글로브 패턴의 배열을 구비하고, 농담이 동시에 지정된 모든 프로젝트에서 테스트를 실행한다. 이는 단일 프로젝트 또는 여러 프로젝트에서 동시에 작업 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="000d78fbd56ae8d851f29ec24ab5707f75357361" translate="yes" xml:space="preserve">
          <source>When the mocked function runs out of implementations defined with &lt;code&gt;mockImplementationOnce&lt;/code&gt;, it will execute the default implementation set with &lt;code&gt;jest.fn&lt;/code&gt; (if it is defined):</source>
          <target state="translated">mocked 함수에 &lt;code&gt;mockImplementationOnce&lt;/code&gt; 로 정의 된 구현이 &lt;code&gt;jest.fn&lt;/code&gt; (정의 된 경우)으로 설정된 기본 구현을 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="af9f009231011568611cfa6e9ad01b0075f8a8f9" translate="yes" xml:space="preserve">
          <source>When the mocked function runs out of implementations defined with mockImplementationOnce, it will execute the default implementation set with &lt;code&gt;jest.fn(() =&amp;gt; defaultValue)&lt;/code&gt; or &lt;code&gt;.mockImplementation(() =&amp;gt; defaultValue)&lt;/code&gt; if they were called:</source>
          <target state="translated">모의 함수에 mockImplementationOnce로 정의 된 구현이 &lt;code&gt;jest.fn(() =&amp;gt; defaultValue)&lt;/code&gt; 경우 호출 된 경우 jest.fn (() =&amp;gt; defaultValue) 또는 &lt;code&gt;.mockImplementation(() =&amp;gt; defaultValue)&lt;/code&gt; 설정된 기본 구현을 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="efd67d9a5d58ddfafd6576c76e2d2b45c6a9f072" translate="yes" xml:space="preserve">
          <source>When this API is called, all pending macro-tasks and micro-tasks will be executed. If those tasks themselves schedule new tasks, those will be continually exhausted until there are no more tasks remaining in the queue.</source>
          <target state="translated">이 API가 호출되면 보류중인 모든 매크로 작업과 마이크로 작업이 실행됩니다. 해당 작업 자체가 새 작업을 예약하면 대기열에 남아있는 작업이 더 이상 없을 때까지 계속 소진됩니다.</target>
        </trans-unit>
        <trans-unit id="a158c79d89cb2f08512d4bfd3dd789cc435d27dc" translate="yes" xml:space="preserve">
          <source>When this API is called, all pending micro-tasks that have been queued via &lt;code&gt;process.nextTick&lt;/code&gt; will be executed. Additionally, if those micro-tasks themselves schedule new micro-tasks, those will be continually exhausted until there are no more micro-tasks remaining in the queue.</source>
          <target state="translated">이 API가 호출되면 &lt;code&gt;process.nextTick&lt;/code&gt; 을 통해 대기중인 모든 보류중인 마이크로 태스크 가 실행됩니다. 또한 이러한 마이크로 태스크 자체가 새로운 마이크로 태스크를 예약하는 경우 대기열에 남은 마이크로 태스크가 더 이상 없을 때까지 계속 소진됩니다.</target>
        </trans-unit>
        <trans-unit id="de6b8c35376469c436481e4abc3ac0840d106da8" translate="yes" xml:space="preserve">
          <source>When this API is called, all timers are advanced by &lt;code&gt;msToRun&lt;/code&gt; milliseconds. All pending &quot;macro-tasks&quot; that have been queued via &lt;code&gt;setTimeout()&lt;/code&gt; or &lt;code&gt;setInterval()&lt;/code&gt;, and would be executed within this time frame will be executed. Additionally if those macro-tasks schedule new macro-tasks that would be executed within the same time frame, those will be executed until there are no more macro-tasks remaining in the queue, that should be run within &lt;code&gt;msToRun&lt;/code&gt; milliseconds.</source>
          <target state="translated">이 API가 호출되면 모든 타이머는 &lt;code&gt;msToRun&lt;/code&gt; 밀리 초 단위 로 진행됩니다 . &lt;code&gt;setTimeout()&lt;/code&gt; 또는 &lt;code&gt;setInterval()&lt;/code&gt; 통해 대기 하고이 시간 내에 실행되는 모든 보류중인 &quot;매크로 작업&quot; 이 실행됩니다. 또한 해당 매크로 작업이 동일한 시간 프레임 내에서 실행될 새 매크로 작업을 예약하는 경우 대기열에 남아있는 매크로 작업이 더 이상 없을 때까지 실행 &lt;code&gt;msToRun&lt;/code&gt; 밀리 초 내에 실행되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="6a3d81ee3b01c0089e78905262e5dca231d9597b" translate="yes" xml:space="preserve">
          <source>When this API is called, all timers are advanced by &lt;code&gt;msToRun&lt;/code&gt; milliseconds. All pending &quot;macro-tasks&quot; that have been queued via &lt;code&gt;setTimeout()&lt;/code&gt; or &lt;code&gt;setInterval()&lt;/code&gt;, and would be executed within this time frame will be executed. Additionally, if those macro-tasks schedule new macro-tasks that would be executed within the same time frame, those will be executed until there are no more macro-tasks remaining in the queue, that should be run within &lt;code&gt;msToRun&lt;/code&gt; milliseconds.</source>
          <target state="translated">이 API가 호출되면 모든 타이머가 &lt;code&gt;msToRun&lt;/code&gt; 밀리 초 단위 로 진행됩니다 . &lt;code&gt;setTimeout()&lt;/code&gt; 또는 &lt;code&gt;setInterval()&lt;/code&gt; 통해 대기열에 추가 되었으며이 기간 내에 실행될 모든 보류중인 &quot;매크로 작업&quot; 이 실행됩니다. 또한 이러한 매크로 작업이 동일한 시간 프레임 내에 실행될 새로운 매크로 작업을 예약하는 경우 대기열에 더 이상 매크로 작업이 남아 있지 않을 때까지 실행되어야합니다. &lt;code&gt;msToRun&lt;/code&gt; 밀리 초 .</target>
        </trans-unit>
        <trans-unit id="e9dca7721cf62aeb16db42f482a108cce06f06d2" translate="yes" xml:space="preserve">
          <source>When this option is provided, Jest will assume it is running in a CI environment. This changes the behavior when a new snapshot is encountered. Instead of the regular behavior of storing a new snapshot automatically, it will fail the test and require Jest to be run with &lt;code&gt;--updateSnapshot&lt;/code&gt;.</source>
          <target state="translated">이 옵션이 제공되면 Jest는 CI 환경에서 실행 중이라고 가정합니다. 새 스냅 샷이 나타날 때 동작이 변경됩니다. 새 스냅 샷을 자동으로 저장하는 일반적인 동작 대신 테스트에 실패하고 Jest를 &lt;code&gt;--updateSnapshot&lt;/code&gt; 과 함께 실행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ea2ae246f66a28582d68b56f98e9832a105b042f" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;babel-jest&lt;/code&gt;, calls to &lt;code&gt;mock&lt;/code&gt; will automatically be hoisted to the top of the code block. Use this method if you want to explicitly avoid this behavior.</source>
          <target state="translated">&lt;code&gt;babel-jest&lt;/code&gt; 를 사용할 때 &lt;code&gt;mock&lt;/code&gt; 호출 은 자동으로 코드 블록의 맨 위에 호이스트됩니다. 이 동작을 명시 적으로 피하려면이 방법을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="18b0443351a14618ca1bcb5f6aa3542dc98f4cfe" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;babel-jest&lt;/code&gt;, calls to &lt;code&gt;unmock&lt;/code&gt; will automatically be hoisted to the top of the code block. Use this method if you want to explicitly avoid this behavior.</source>
          <target state="translated">사용하는 경우 &lt;code&gt;babel-jest&lt;/code&gt; , 호출 &lt;code&gt;unmock&lt;/code&gt; 은 자동으로 코드 블록의 상단에 게양된다. 이 동작을 명시 적으로 피하려면이 방법을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f978d44fe3f641d915d3d23a0599b90ede804e61" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;--config&lt;/code&gt; option, the JSON file must not contain a &quot;jest&quot; key:</source>
          <target state="translated">&lt;code&gt;--config&lt;/code&gt; 옵션을 사용할 때 JSON 파일에는 &quot;jest&quot;키가 포함되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="04fedd264e30315e94d0bfc357d0d1a8b0ecd6f0" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;factory&lt;/code&gt; parameter for an ES6 module with a default export, the &lt;code&gt;__esModule: true&lt;/code&gt; property needs to be specified. This property is normally generated by Babel / TypeScript, but here it needs to be set manually. When importing a default export, it's an instruction to import the property named &lt;code&gt;default&lt;/code&gt; from the export object:</source>
          <target state="translated">기본 내보내기와 함께 ES6 모듈 의 &lt;code&gt;factory&lt;/code&gt; 매개 변수를 사용하는 경우 &lt;code&gt;__esModule: true&lt;/code&gt; 특성을 지정해야합니다. 이 속성은 일반적으로 Babel / TypeScript에 의해 생성되지만 여기서 수동으로 설정해야합니다. 기본 내보내기를 가져올 때 내보내기 객체에서 &lt;code&gt;default&lt;/code&gt; 라는 속성을 가져 오는 지침입니다 .</target>
        </trans-unit>
        <trans-unit id="2d001438addabfdc9a62c0bd086018e034d25a28" translate="yes" xml:space="preserve">
          <source>When we require that module in our tests, explicitly calling &lt;code&gt;jest.mock('./moduleName')&lt;/code&gt; is &lt;strong&gt;required&lt;/strong&gt;.</source>
          <target state="translated">우리는 우리의 테스트에서 해당 모듈, 명시 적으로 호출 필요할 때 &lt;code&gt;jest.mock('./moduleName')&lt;/code&gt; 됩니다 &lt;strong&gt;필요&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="703ab40aa1656fee5bd7fb985cc5ca7e7af24578" translate="yes" xml:space="preserve">
          <source>When you are debugging a large test file, you will often only want to run a subset of tests. You can use &lt;code&gt;.only&lt;/code&gt; to specify which tests are the only ones you want to run in that test file.</source>
          <target state="translated">큰 테스트 파일을 디버깅 할 때는 종종 테스트 하위 집합 만 실행하려고합니다. &lt;code&gt;.only&lt;/code&gt; 를 사용하여 해당 테스트 파일에서 실행할 테스트 만 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7d76e8040b92fed0c690e41513159f4832164a34" translate="yes" xml:space="preserve">
          <source>When you are maintaining a large codebase, you may sometimes find a test that is temporarily broken for some reason. If you want to skip running this test, but you don't want to delete this code, you can use &lt;code&gt;test.skip&lt;/code&gt; to specify some tests to skip.</source>
          <target state="translated">큰 코드베이스를 유지 관리하는 경우 때때로 어떤 이유로 일시적으로 중단 된 테스트를 찾을 수 있습니다. 이 테스트 실행을 건너 뛰고 싶지만이 코드를 삭제하지 않으려면 &lt;code&gt;test.skip&lt;/code&gt; 를 사용하여 건너 뛸 테스트를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8d417a3cdc1c802c0f3ae5fcb03331fd9db749a0" translate="yes" xml:space="preserve">
          <source>When you need to recreate a complex behavior of a mock function such that multiple function calls produce different results, use the &lt;code&gt;mockImplementationOnce&lt;/code&gt; method:</source>
          <target state="translated">여러 함수 호출이 다른 결과를 생성하도록 모의 함수의 복잡한 동작을 다시 작성해야하는 경우 &lt;code&gt;mockImplementationOnce&lt;/code&gt; 메소드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0933ea7e8d1f77a530a24c9128f18fb45e5eb8fc" translate="yes" xml:space="preserve">
          <source>When you run &lt;code&gt;jest&lt;/code&gt; with an argument, that argument is treated as a regular expression to match against files in your project. It is possible to run test suites by providing a pattern. Only the files that the pattern matches will be picked up and executed. Depending on your terminal, you may need to quote this argument: &lt;code&gt;jest &quot;my.*(complex)?pattern&quot;&lt;/code&gt;. On Windows, you will need to use &lt;code&gt;/&lt;/code&gt; as a path separator or escape &lt;code&gt;\&lt;/code&gt; as &lt;code&gt;\\&lt;/code&gt;.</source>
          <target state="translated">인수와 함께 &lt;code&gt;jest&lt;/code&gt; 를 실행하면 해당 인수는 프로젝트의 파일과 일치하는 정규식으로 처리됩니다. 패턴을 제공하여 테스트 스위트를 실행할 수 있습니다. 패턴과 일치하는 파일 만 선택되어 실행됩니다. 터미널에 따라 &lt;code&gt;jest &quot;my.*(complex)?pattern&quot;&lt;/code&gt; 인수를 인용해야 할 수도 있습니다 . Windows에서는 &lt;code&gt;/&lt;/code&gt; 를 경로 구분 기호로 사용하거나 이스케이프 &lt;code&gt;\&lt;/code&gt; as &lt;code&gt;\\&lt;/code&gt; 를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="68715485bd1666aefca572f144099e2aa37bff4b" translate="yes" xml:space="preserve">
          <source>When you run &lt;code&gt;yarn test&lt;/code&gt; or &lt;code&gt;jest&lt;/code&gt;, this will produce an output file like this:</source>
          <target state="translated">&lt;code&gt;yarn test&lt;/code&gt; 또는 &lt;code&gt;jest&lt;/code&gt; 를 실행하면 다음 과 같은 출력 파일이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="a48c34ee84029428f3840a2f252c786c6d129c3b" translate="yes" xml:space="preserve">
          <source>When you're writing tests, you often need to check that values meet certain conditions. &lt;code&gt;expect&lt;/code&gt; gives you access to a number of &quot;matchers&quot; that let you validate different things.</source>
          <target state="translated">테스트를 작성할 때 종종 값이 특정 조건을 충족하는지 확인해야합니다. &lt;code&gt;expect&lt;/code&gt; 는 다른 것들을 검증 할 수있는 수많은 &quot;매칭&quot;에 액세스 할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="1895f1fdbdf511f9d8c3b27d739559dc512e7472" translate="yes" xml:space="preserve">
          <source>Whether to use &lt;a href=&quot;https://facebook.github.io/watchman/&quot;&gt;&lt;code&gt;watchman&lt;/code&gt;&lt;/a&gt; for file crawling.</source>
          <target state="translated">사용 여부 &lt;a href=&quot;https://facebook.github.io/watchman/&quot;&gt; &lt;code&gt;watchman&lt;/code&gt; &lt;/a&gt;파일 크롤링에 감시자.</target>
        </trans-unit>
        <trans-unit id="6727f0146af0d44b58e9f9d090e4a61fff19955d" translate="yes" xml:space="preserve">
          <source>Whether to use &lt;a href=&quot;https://facebook.github.io/watchman/&quot;&gt;&lt;code&gt;watchman&lt;/code&gt;&lt;/a&gt; for file crawling. Defaults to &lt;code&gt;true&lt;/code&gt;. Disable using &lt;code&gt;--no-watchman&lt;/code&gt;.</source>
          <target state="translated">파일 크롤링에 &lt;a href=&quot;https://facebook.github.io/watchman/&quot;&gt; &lt;code&gt;watchman&lt;/code&gt; &lt;/a&gt; 를 사용할지 여부 . 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다. 사용 중지 &lt;code&gt;--no-watchman&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35131e0d0e9059a4bd01bbcebb7af6e82ca76302" translate="yes" xml:space="preserve">
          <source>Whether to use the cache. Defaults to true. Disable the cache using &lt;code&gt;--no-cache&lt;/code&gt;. &lt;em&gt;Note: the cache should only be disabled if you are experiencing caching related problems. On average, disabling the cache makes Jest at least two times slower.&lt;/em&gt;</source>
          <target state="translated">캐시 사용 여부 기본값은 true입니다. &lt;code&gt;--no-cache&lt;/code&gt; cache를 사용하여 캐시를 비활성화하십시오 . &lt;em&gt;참고 : 캐싱 관련 문제가 발생하는 경우에만 캐시를 비활성화해야합니다. 평균적으로 캐시를 비활성화하면 Jest가 최소 두 배 느려집니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="83164f909bcd8fc7ba78df4e824b24177b294067" translate="yes" xml:space="preserve">
          <source>Whether to use watchman for file crawling. Defaults to true. Disable using &lt;code&gt;--no-watchman&lt;/code&gt;.</source>
          <target state="translated">파일 크롤링에 watchman을 사용할지 여부 기본값은 true입니다. &lt;code&gt;--no-watchman&lt;/code&gt; 사용을 비활성화하십시오 .</target>
        </trans-unit>
        <trans-unit id="a1d2275b123b75427db7b2987318a2d50b013b7a" translate="yes" xml:space="preserve">
          <source>While Jest is most of the time extremely fast on modern multi-core computers with fast SSDs, it may be slow on certain setups as our users &lt;a href=&quot;https://github.com/facebook/jest/issues/1395&quot;&gt;have&lt;/a&gt;&lt;a href=&quot;https://github.com/facebook/jest/issues/1524#issuecomment-260246008&quot;&gt;discovered&lt;/a&gt;.</source>
          <target state="translated">Jest는 SSD가 빠른 최신 멀티 코어 컴퓨터에서 대부분 매우 빠르지 만 사용자 &lt;a href=&quot;https://github.com/facebook/jest/issues/1395&quot;&gt;가 &lt;/a&gt;&lt;a href=&quot;https://github.com/facebook/jest/issues/1524#issuecomment-260246008&quot;&gt;발견 한&lt;/a&gt; 특정 설정에서는 속도가 느릴 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5c1e359c575a75195c82ced579ca21229a1a43b9" translate="yes" xml:space="preserve">
          <source>While we generally recommend using the same version of every Jest package, this workaround will allow you to continue using the latest version of Jest with Babel 6 for now.</source>
          <target state="translated">일반적으로 모든 Jest 패키지의 동일한 버전을 사용하는 것이 좋지만이 해결 방법을 통해 현재 Babel 6과 함께 최신 버전의 Jest를 계속 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ab9c7998614f26e4eb6805b1167e05ce5311b6e" translate="yes" xml:space="preserve">
          <source>Will result in this error:</source>
          <target state="translated">이 오류가 발생합니다 :</target>
        </trans-unit>
        <trans-unit id="5924ea10aaabb62ee9bc1364ab2d6c8d39fa4316" translate="yes" xml:space="preserve">
          <source>With all the things set up, we can now write our tests like this:</source>
          <target state="translated">모든 것이 설정되면 다음과 같이 테스트를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f75c7b6834fbac10e18f4c82ab03776229eb74e2" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;configuration#globalsetup-string&quot;&gt;Global Setup/Teardown&lt;/a&gt; and &lt;a href=&quot;configuration#testenvironment-string&quot;&gt;Async Test Environment&lt;/a&gt; APIs, Jest can work smoothly with &lt;a href=&quot;https://aws.amazon.com/dynamodb/&quot;&gt;DynamoDB&lt;/a&gt;.</source>
          <target state="translated">으로 &lt;a href=&quot;configuration#globalsetup-string&quot;&gt;글로벌 설치 / 해체&lt;/a&gt; 및 &lt;a href=&quot;configuration#testenvironment-string&quot;&gt;비동기 테스트 환경&lt;/a&gt; API는, 농담이 원활하게 작업 할 수 &lt;a href=&quot;https://aws.amazon.com/dynamodb/&quot;&gt;DynamoDB의&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="09d67fc0b64d61790fbe51d618d9c01a71c9767f" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;configuration#globalsetup-string&quot;&gt;Global Setup/Teardown&lt;/a&gt; and &lt;a href=&quot;configuration#testenvironment-string&quot;&gt;Async Test Environment&lt;/a&gt; APIs, Jest can work smoothly with &lt;a href=&quot;https://github.com/GoogleChrome/puppeteer&quot;&gt;puppeteer&lt;/a&gt;.</source>
          <target state="translated">으로 &lt;a href=&quot;configuration#globalsetup-string&quot;&gt;글로벌 설치 / 해체&lt;/a&gt; 및 &lt;a href=&quot;configuration#testenvironment-string&quot;&gt;비동기 테스트 환경&lt;/a&gt; API는, 농담이 원활하게 작업 할 수 있습니다 &lt;a href=&quot;https://github.com/GoogleChrome/puppeteer&quot;&gt;인형&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="efe0a1fdb2d38cad4bc73937febc9018ab5dfa08" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;configuration#globalsetup-string&quot;&gt;Global Setup/Teardown&lt;/a&gt; and &lt;a href=&quot;configuration#testenvironment-string&quot;&gt;Async Test Environment&lt;/a&gt; APIs, Jest can work smoothly with &lt;a href=&quot;https://www.mongodb.com/&quot;&gt;MongoDB&lt;/a&gt;.</source>
          <target state="translated">으로 &lt;a href=&quot;configuration#globalsetup-string&quot;&gt;글로벌 설치 / 해체&lt;/a&gt; 및 &lt;a href=&quot;configuration#testenvironment-string&quot;&gt;비동기 테스트 환경&lt;/a&gt; API는, 농담이 원활하게 작업 할 수 &lt;a href=&quot;https://www.mongodb.com/&quot;&gt;MongoDB를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e7a7d359c8bb23694d685fdf6e2b5cde46a49ff3" translate="yes" xml:space="preserve">
          <source>Write test results to a file when the &lt;code&gt;--json&lt;/code&gt; option is also specified. The returned JSON structure is documented in &lt;a href=&quot;configuration#testresultsprocessor-string&quot;&gt;testResultsProcessor&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;--json&lt;/code&gt; 옵션도 지정 하면 테스트 결과를 파일에 씁니다 . 리턴 된 JSON 구조는 &lt;a href=&quot;configuration#testresultsprocessor-string&quot;&gt;testResultsProcessor에&lt;/a&gt; 문서화되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="391b1a9608423cb9c4d16a7886b9e07fab1acb00" translate="yes" xml:space="preserve">
          <source>Write tests</source>
          <target state="translated">테스트 작성</target>
        </trans-unit>
        <trans-unit id="694bf05e5891dd2e709b08f7b1d50372246946ee" translate="yes" xml:space="preserve">
          <source>Write your test</source>
          <target state="translated">테스트 작성</target>
        </trans-unit>
        <trans-unit id="94ba98a24cca1fad5979f2e2b8b87aa24d441f8b" translate="yes" xml:space="preserve">
          <source>Writing tests using the &lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt; syntax is also possible. Here is how you'd write the same examples from before:</source>
          <target state="translated">&lt;code&gt;async&lt;/code&gt; / &lt;code&gt;await&lt;/code&gt; 구문을 사용한 테스트 작성 도 가능합니다. 이전과 동일한 예제를 작성하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="13442293f45d32c9c4218756254e61b25c456f59" translate="yes" xml:space="preserve">
          <source>Yes, all snapshot files should be committed alongside the modules they are covering and their tests. They should be considered part of a test, similar to the value of any other assertion in Jest. In fact, snapshots represent the state of the source modules at any given point in time. In this way, when the source modules are modified, Jest can tell what changed from the previous version. It can also provide a lot of additional context during code review in which reviewers can study your changes better.</source>
          <target state="translated">예, 모든 스냅 샷 파일은 해당 모듈 및 테스트와 함께 커밋되어야합니다. Jest의 다른 주장 값과 유사한 테스트의 일부로 간주해야합니다. 실제로 스냅 샷은 특정 시점의 소스 모듈 상태를 나타냅니다. 이런 식으로 소스 모듈이 수정되면 Jest는 이전 버전에서 변경된 내용을 알 수 있습니다. 또한 코드 검토 중에 검토자가 변경 사항을 더 잘 연구 할 수있는 많은 추가 컨텍스트를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5059d1df734052fa39f05d1a230ebef9c450fdf6" translate="yes" xml:space="preserve">
          <source>Yes, as well as with any other test.</source>
          <target state="translated">예, 다른 테스트에서도 가능합니다.</target>
        </trans-unit>
        <trans-unit id="933a2cbd693a2fc8e1c7cc9d0a79a6433195d072" translate="yes" xml:space="preserve">
          <source>You avoid limits to configuration that might cause you to eject from &lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;create-react-app&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/facebookincubator/create-react-app&quot;&gt;create-react-app&lt;/a&gt; 에서 꺼내는 구성에 대한 제한을 피하십시오 .</target>
        </trans-unit>
        <trans-unit id="406cbbf63f4fe22d5b8ccaa5240411c1502ac6c2" translate="yes" xml:space="preserve">
          <source>You can also hook up puppeteer from scratch. The basic idea is to:</source>
          <target state="translated">꼭두각시를 처음부터 연결할 수도 있습니다. 기본 아이디어는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="35aff70317c576091536adc5e1a43d87f6a53f1b" translate="yes" xml:space="preserve">
          <source>You can also nest &lt;code&gt;describe&lt;/code&gt; blocks if you have a hierarchy of tests:</source>
          <target state="translated">테스트 계층 구조가있는 경우 &lt;code&gt;describe&lt;/code&gt; 블록을 중첩 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ecbf1217eb1b7413e5ac5532b9f18df62cd10cea" translate="yes" xml:space="preserve">
          <source>You can also pass an array of objects, in which case the method will return true only if each object in the received array matches (in the &lt;code&gt;toMatchObject&lt;/code&gt; sense described above) the corresponding object in the expected array. This is useful if you want to check that two arrays match in their number of elements, as opposed to &lt;code&gt;arrayContaining&lt;/code&gt;, which allows for extra elements in the received array.</source>
          <target state="translated">객체 배열을 전달할 수도 있습니다.이 경우 메서드는 수신 된 배열의 각 객체가 위에서 설명한 &lt;code&gt;toMatchObject&lt;/code&gt; 의미에서 예상되는 배열의 해당 객체 와 일치하는 경우에만 true를 반환합니다 . 이것은 수신 된 배열에서 추가 요소를 허용 하는 &lt;code&gt;arrayContaining&lt;/code&gt; 과 달리 두 배열이 요소 수에서 일치하는지 확인하려는 경우에 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="33e631cdb46e5194143ae6343251d5d4abeebe0e" translate="yes" xml:space="preserve">
          <source>You can also test for the opposite of a matcher:</source>
          <target state="translated">매처의 반대를 테스트 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="766ae758010f2b190e41fbbc693bc28b84e8247c" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;.resolves&lt;/code&gt; matcher in your expect statement, and Jest will wait for that promise to resolve. If the promise is rejected, the test will automatically fail.</source>
          <target state="translated">expect 문에서 &lt;code&gt;.resolves&lt;/code&gt; 매처를 사용할 수도 있으며 Jest는 해당 약속이 해결 될 때까지 기다립니다. 약속이 거부되면 테스트는 자동으로 실패합니다.</target>
        </trans-unit>
        <trans-unit id="c23acb6b8a75eb059d0bf1a92f11f8a674f5b5ac" translate="yes" xml:space="preserve">
          <source>You can call &lt;code&gt;expect.addSnapshotSerializer&lt;/code&gt; to add a module that formats application-specific data structures.</source>
          <target state="translated">&lt;code&gt;expect.addSnapshotSerializer&lt;/code&gt; 를 호출 하여 애플리케이션 별 데이터 구조를 형식화하는 모듈을 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b0148d2ae9957ac3475428862737e46004f4bc04" translate="yes" xml:space="preserve">
          <source>You can check if an array or iterable contains a particular item using &lt;code&gt;toContain&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;toContain&lt;/code&gt; 을 사용하여 배열 또는 반복 가능한 항목에 특정 항목이 포함되어 있는지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2d51d93712488643fb65c1c14ffe4c74aaa71d14" translate="yes" xml:space="preserve">
          <source>You can check strings against regular expressions with &lt;code&gt;toMatch&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;toMatch&lt;/code&gt; 사용 하여 정규 표현식과 비교 하여 문자열을 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e25edb586f40e9238795e2ba9b6c0d4c65291a8a" translate="yes" xml:space="preserve">
          <source>You can cherry pick specific features of Jest and use them as standalone packages. Here's a list of the available packages:</source>
          <target state="translated">Jest의 특정 기능을 체리 선택하여 독립형 패키지로 사용할 수 있습니다. 사용 가능한 패키지 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="42fd15afca8b3c0e27f3602b1bb8b499e91c1c6b" translate="yes" xml:space="preserve">
          <source>You can collect coverage from those files with setting &lt;code&gt;forceCoverageMatch&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;forceCoverageMatch&lt;/code&gt; 설정으로 해당 파일에서 적용 범위를 수집 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0087ca484c125dc235349950ec51d13f3336f610" translate="yes" xml:space="preserve">
          <source>You can combine &lt;code&gt;async&lt;/code&gt; and &lt;code&gt;await&lt;/code&gt; with &lt;code&gt;.resolves&lt;/code&gt; or &lt;code&gt;.rejects&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;async&lt;/code&gt; 와 &lt;code&gt;await&lt;/code&gt; 를 &lt;code&gt;.resolves&lt;/code&gt; 또는 &lt;code&gt;.rejects&lt;/code&gt; 와 결합 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d20f2b42e97c65aaef925a2c6a3961d0c033857b" translate="yes" xml:space="preserve">
          <source>You can create your own module that will be used for setting up the test environment. The module must export a class with &lt;code&gt;setup&lt;/code&gt;, &lt;code&gt;teardown&lt;/code&gt; and &lt;code&gt;runScript&lt;/code&gt; methods. You can also pass variables from this module to your test suites by assigning them to &lt;code&gt;this.global&lt;/code&gt; object &amp;ndash; this will make them available in your test suites as global variables.</source>
          <target state="translated">테스트 환경을 설정하는 데 사용할 고유 한 모듈을 만들 수 있습니다. 모듈은 &lt;code&gt;setup&lt;/code&gt; , &lt;code&gt;teardown&lt;/code&gt; 및 &lt;code&gt;runScript&lt;/code&gt; 메소드가 있는 클래스를 내 보내야 합니다. &lt;code&gt;this.global&lt;/code&gt; 객체에 변수를 할당하여이 모듈에서 테스트 스위트로 변수를 전달할 수도 있습니다. 그러면 테스트 스위트에서 변수를 글로벌 변수로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ef2f94dd57c5898c7b5cdef5978ab020627b6d9" translate="yes" xml:space="preserve">
          <source>You can match properties against values or against matchers.</source>
          <target state="translated">값이나 매처에 대해 속성을 일치시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8d7a47b61e8074001017d01760195a44daa7d92" translate="yes" xml:space="preserve">
          <source>You can optionally provide a name for your mock functions, which will be displayed instead of &quot;jest.fn()&quot; in test error output. Use this if you want to be able to quickly identify the mock function reporting an error in your test output.</source>
          <target state="translated">선택적으로 테스트 오류 출력에서 ​​&quot;jest.fn ()&quot;대신 표시되는 모의 함수의 이름을 제공 할 수 있습니다. 테스트 출력에서 ​​오류를보고하는 모의 함수를 신속하게 식별하려면이를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="62ba1633de645d2b4f3bdc636d51dbe0464a51e7" translate="yes" xml:space="preserve">
          <source>You can optionally provide a name for your mock functions, which will be displayed instead of &quot;jest.fn()&quot; in the test error output. Use this if you want to be able to quickly identify the mock function reporting an error in your test output.</source>
          <target state="translated">테스트 오류 출력에서 ​​&quot;jest.fn ()&quot;대신 표시 될 모의 함수 이름을 선택적으로 제공 할 수 있습니다. 테스트 출력에서 ​​오류를보고하는 모의 함수를 빠르게 식별 할 수 있도록하려면 이것을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="141547ac2059520c584383a103038c5f0023150f" translate="yes" xml:space="preserve">
          <source>You can pass configuration to a transformer like &lt;code&gt;{filePattern: ['path-to-transformer', {options}]}&lt;/code&gt; For example, to configure babel-jest for non-default behavior, &lt;code&gt;{&quot;\\.js$&quot;: ['babel-jest', {rootMode: &quot;upward&quot;}]}&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;{filePattern: ['path-to-transformer', {options}]}&lt;/code&gt; 와 같은 변환기에 구성을 전달할 수 있습니다 . 예를 들어, 기본이 아닌 동작에 대해 babel-jest를 구성하려면 &lt;code&gt;{&quot;\\.js$&quot;: ['babel-jest', {rootMode: &quot;upward&quot;}]}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="800cb883045942cfd5bb4081f8af395b4c78910d" translate="yes" xml:space="preserve">
          <source>You can provide an optional &lt;code&gt;hint&lt;/code&gt; string argument that is appended to the test name. Although Jest always appends a number at the end of a snapshot name, short descriptive hints might be more useful than numbers to differentiate &lt;strong&gt;multiple&lt;/strong&gt; snapshots in a &lt;strong&gt;single&lt;/strong&gt;&lt;code&gt;it&lt;/code&gt; or &lt;code&gt;test&lt;/code&gt; block. Jest sorts snapshots by name in the corresponding &lt;code&gt;.snap&lt;/code&gt; file.</source>
          <target state="translated">테스트 이름에 추가 된 선택적 &lt;code&gt;hint&lt;/code&gt; 문자열 인수를 제공 할 수 있습니다 . 농담은 항상 스냅 샷 이름의 끝에 숫자를 추가하지만 숫자를 구별하는 것보다, 짧은 설명 힌트 더 유용 할 수 있습니다 &lt;strong&gt;여러&lt;/strong&gt; A의 스냅 샷을 &lt;strong&gt;하나의 &lt;/strong&gt; &lt;code&gt;it&lt;/code&gt; 또는 &lt;code&gt;test&lt;/code&gt; 블록. Jest는 해당 &lt;code&gt;.snap&lt;/code&gt; 파일 에서 이름별로 스냅 샷을 정렬 합니다.</target>
        </trans-unit>
        <trans-unit id="4cc4d175319a45a401106b9809e576146487b0b9" translate="yes" xml:space="preserve">
          <source>You can provide an optional &lt;code&gt;propertyMatchers&lt;/code&gt; object argument, which has asymmetric matchers as values of a subset of expected properties, &lt;strong&gt;if&lt;/strong&gt; the received value will be an &lt;strong&gt;object&lt;/strong&gt; instance. It is like &lt;code&gt;toMatchObject&lt;/code&gt; with flexible criteria for a subset of properties, followed by a snapshot test as exact criteria for the rest of the properties.</source>
          <target state="translated">수신 된 값이 &lt;strong&gt;객체&lt;/strong&gt; 인스턴스 인 &lt;strong&gt;경우&lt;/strong&gt; 예상되는 속성의 하위 집합 값으로 비대칭 매 처가 있는 선택적 &lt;code&gt;propertyMatchers&lt;/code&gt; 객체 인수를 제공 할 수 있습니다 . 속성의 하위 집합에 대한 유연한 기준을 가진 &lt;code&gt;toMatchObject&lt;/code&gt; 와 유사 하며 나머지 속성에 대한 정확한 기준으로 스냅 샷 테스트가 이어집니다.&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="342a9b14684325992d5ff139401436ae7682dd1a" translate="yes" xml:space="preserve">
          <source>You can provide an optional &lt;code&gt;value&lt;/code&gt; argument to compare the received property value (recursively for all properties of object instances, also known as deep equality, like the &lt;code&gt;toEqual&lt;/code&gt; matcher).</source>
          <target state="translated">수신 된 특성 값을 비교 하기 위해 선택적 &lt;code&gt;value&lt;/code&gt; 인수를 제공 할 수 있습니다 ( &lt;code&gt;toEqual&lt;/code&gt; 매처 와 같이 깊은 동등성이라고도 알려진 오브젝트 인스턴스의 모든 특성에 대해 재귀 적으로 ).</target>
        </trans-unit>
        <trans-unit id="ecc5cea913bac7656555fb5571fc70b6c18f354b" translate="yes" xml:space="preserve">
          <source>You can provide an optional argument to test that a specific error is thrown:</source>
          <target state="translated">특정 오류가 발생하는지 테스트하기 위해 선택적 인수를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0387678f500b8dabacd6ece5ed81ebc2dad87e6" translate="yes" xml:space="preserve">
          <source>You can read more about &lt;code&gt;jest-changed-files&lt;/code&gt; in the &lt;a href=&quot;https://github.com/facebook/jest/blob/master/packages/jest-changed-files/README.md&quot;&gt;readme file&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/facebook/jest/blob/master/packages/jest-changed-files/README.md&quot;&gt;readme 파일&lt;/a&gt; 에서 &lt;code&gt;jest-changed-files&lt;/code&gt; 에 대한 자세한 내용을 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a117882f05bee0eb2692567e191ce66d663578e1" translate="yes" xml:space="preserve">
          <source>You can read more about &lt;code&gt;jest-docblock&lt;/code&gt; in the &lt;a href=&quot;https://github.com/facebook/jest/blob/master/packages/jest-docblock/README.md&quot;&gt;readme file&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/facebook/jest/blob/master/packages/jest-docblock/README.md&quot;&gt;readme 파일&lt;/a&gt; 에서 &lt;code&gt;jest-docblock&lt;/code&gt; 에 대한 자세한 내용을 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="46c165debafb7322f712fc6e454196637356e378" translate="yes" xml:space="preserve">
          <source>You can read more about &lt;code&gt;jest-validate&lt;/code&gt; in the &lt;a href=&quot;https://github.com/facebook/jest/blob/master/packages/jest-validate/README.md&quot;&gt;readme file&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/facebook/jest/blob/master/packages/jest-validate/README.md&quot;&gt;readme 파일&lt;/a&gt; 에서 &lt;code&gt;jest-validate&lt;/code&gt; 에 대한 자세한 내용을 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2867c6d937c4005f8963139f59e55ad836a6852b" translate="yes" xml:space="preserve">
          <source>You can read more about &lt;code&gt;jest-worker&lt;/code&gt; in the &lt;a href=&quot;https://github.com/facebook/jest/blob/master/packages/jest-worker/README.md&quot;&gt;readme file&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/facebook/jest/blob/master/packages/jest-worker/README.md&quot;&gt;readme 파일&lt;/a&gt; 에서 &lt;code&gt;jest-worker&lt;/code&gt; 에 대한 자세한 내용을 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d429e36c0ed20b800a39f032d046273b4cea53be" translate="yes" xml:space="preserve">
          <source>You can read more about &lt;code&gt;pretty-format&lt;/code&gt; in the &lt;a href=&quot;https://github.com/facebook/jest/blob/master/packages/pretty-format/README.md&quot;&gt;readme file&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/facebook/jest/blob/master/packages/pretty-format/README.md&quot;&gt;readme 파일&lt;/a&gt; 에서 &lt;code&gt;pretty-format&lt;/code&gt; 에 대한 자세한 내용을 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f91698c99b451b48fdef94d8133ba660ee4beb14" translate="yes" xml:space="preserve">
          <source>You can replace all of the above mocks in order to change the implementation, for a single test or all tests, by calling &lt;code&gt;mockImplementation()&lt;/code&gt; on the existing mock.</source>
          <target state="translated">기존 모의에서 &lt;code&gt;mockImplementation()&lt;/code&gt; 을 호출하여 단일 테스트 또는 모든 테스트에 대한 구현을 변경하기 위해 위의 모의를 모두 바꿀 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="563bf00a2d98bb36c45fffa7a2f6aab090a1748e" translate="yes" xml:space="preserve">
          <source>You can retrieve Jest's default options to expand them if needed:</source>
          <target state="translated">필요한 경우 Jest의 기본 옵션을 검색하여 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31bd27fefd08851ca3968f0ceda8045022a66264" translate="yes" xml:space="preserve">
          <source>You can run Jest directly from the CLI (if it's globally available in your &lt;code&gt;PATH&lt;/code&gt;, e.g. by &lt;code&gt;yarn global add jest&lt;/code&gt; or &lt;code&gt;npm install jest --global&lt;/code&gt;) with a variety of useful options.</source>
          <target state="translated">CLI에서 Jest를 직접 실행할 수 있습니다 ( 예를 들어 &lt;code&gt;yarn global add jest&lt;/code&gt; 또는 &lt;code&gt;npm install jest --global&lt;/code&gt; 등으로 &lt;code&gt;PATH&lt;/code&gt; 에서 전역 적으로 사용 가능한 경우 ).</target>
        </trans-unit>
        <trans-unit id="bef775ff4d1e2656f1b8b8b28d2f88eef6be39e0" translate="yes" xml:space="preserve">
          <source>You can see an example of using Jest with TypeScript in our &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/typescript&quot;&gt;GitHub repository&lt;/a&gt;.</source>
          <target state="translated">TypeScript와 함께 Jest를 사용하는 예는 &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/typescript&quot;&gt;GitHub 저장소&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f225c905306c2c0014f6ff2fdd68b6007152b521" translate="yes" xml:space="preserve">
          <source>You can try out this functionality by cloning the &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/snapshot&quot;&gt;snapshot example&lt;/a&gt;, modifying the &lt;code&gt;Link&lt;/code&gt; component, and running Jest.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples/snapshot&quot;&gt;스냅 샷 예제&lt;/a&gt; 복제 , &lt;code&gt;Link&lt;/code&gt; 구성 요소 수정 및 Jest를 실행 하여이 기능을 시도 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a5ed2e627ad2f097c8fe5c0666910c34f57925f1" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;describe.only&lt;/code&gt; if you want to run only one describe block:</source>
          <target state="translated">하나의 describe 블록 만 실행하려는 경우 &lt;code&gt;describe.only&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="221b7b5d130528a59256d65bc2c5c5ab8c11adbb" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;describe.skip&lt;/code&gt; if you do not want to run a particular describe block:</source>
          <target state="translated">특정 describe 블록을 실행하지 않으려면 &lt;code&gt;describe.skip&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="29de8e17dc9a604ab72ee70bda29920afbd2d460" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;expect.extend&lt;/code&gt; to add your own matchers to Jest. For example, let's say that you're testing a number utility library and you're frequently asserting that numbers appear within particular ranges of other numbers. You could abstract that into a &lt;code&gt;toBeWithinRange&lt;/code&gt; matcher:</source>
          <target state="translated">&lt;code&gt;expect.extend&lt;/code&gt; 를 사용 하여 Jest에 자신의 매처를 추가 할 수 있습니다 . 예를 들어, 숫자 유틸리티 라이브러리를 테스트하고 있고 숫자가 다른 숫자의 특정 범위 내에 나타나는 경우가 자주 있다고 가정합니다. 이를 &lt;code&gt;toBeWithinRange&lt;/code&gt; 매 처로 추상화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ce0b3ff83dde595fbf23f5b27e23e12d03a726e9" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;jest.MockedClass&lt;/code&gt; to represent a class that has been replaced by a Jest mock.</source>
          <target state="translated">당신이 사용할 수있는 &lt;code&gt;jest.MockedClass&lt;/code&gt; 를 하여 Jest 모의로 대체 된 클래스를 나타낼 .</target>
        </trans-unit>
        <trans-unit id="883638c32cfdbaf6b10f47ce10c2b95fc3e1af40" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;jest.MockedFunction&lt;/code&gt; to represent a function that has been replaced by a Jest mock.</source>
          <target state="translated">당신이 사용할 수있는 &lt;code&gt;jest.MockedFunction&lt;/code&gt; 을 하여 Jest mock으로 대체 된 함수를 나타낼 .</target>
        </trans-unit>
        <trans-unit id="414d019cf0872729a505b6b1f50111cb1ce5b29d" translate="yes" xml:space="preserve">
          <source>You can use an &lt;a href=&quot;https://github.com/keyanzhang/identity-obj-proxy&quot;&gt;ES6 Proxy&lt;/a&gt; to mock &lt;a href=&quot;https://github.com/css-modules/css-modules&quot;&gt;CSS Modules&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/keyanzhang/identity-obj-proxy&quot;&gt;ES6 프록시&lt;/a&gt; 를 사용하여 &lt;a href=&quot;https://github.com/css-modules/css-modules&quot;&gt;CSS 모듈&lt;/a&gt; 을 조롱 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e0ca37e74baa1f002bba25e20997f296e5781557" translate="yes" xml:space="preserve">
          <source>You can use it instead of a literal value:</source>
          <target state="translated">리터럴 값 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c085c131693a018bbc7ee86b6ff86c3192e859b0" translate="yes" xml:space="preserve">
          <source>You could comment the test out, but it's often a bit nicer to use &lt;code&gt;test.skip&lt;/code&gt; because it will maintain indentation and syntax highlighting.</source>
          <target state="translated">테스트를 주석 처리 할 수는 있지만 들여 쓰기와 구문 강조를 유지하기 때문에 &lt;code&gt;test.skip&lt;/code&gt; 을 사용하는 것이 더 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="5359ed25529846e45ba23e420d5b9e5c6713de18" translate="yes" xml:space="preserve">
          <source>You could write &lt;code&gt;expect(bestDrinkForFlavor('octopus')).toBe(undefined)&lt;/code&gt;, but it's better practice to avoid referring to &lt;code&gt;undefined&lt;/code&gt; directly in your code.</source>
          <target state="translated">당신은 쓸 수 있습니다 &lt;code&gt;expect(bestDrinkForFlavor('octopus')).toBe(undefined)&lt;/code&gt; 하지만, 참조 피하기 위해 좋은 연습입니다 &lt;code&gt;undefined&lt;/code&gt; 코드에서 직접.</target>
        </trans-unit>
        <trans-unit id="1ba59aa451c75435f919998f9ebfc1c5a8dd95b2" translate="yes" xml:space="preserve">
          <source>You could write &lt;code&gt;expect(fetchNewFlavorIdea()).not.toBe(undefined)&lt;/code&gt;, but it's better practice to avoid referring to &lt;code&gt;undefined&lt;/code&gt; directly in your code.</source>
          <target state="translated">&lt;code&gt;expect(fetchNewFlavorIdea()).not.toBe(undefined)&lt;/code&gt; 작성할 수 있지만 코드에서 직접 &lt;code&gt;undefined&lt;/code&gt; 를 참조하지 않는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="88ed689c2ae9512a449e124212b726dc5d4e0c96" translate="yes" xml:space="preserve">
          <source>You have to run &lt;code&gt;yarn add --dev @testing-library/react&lt;/code&gt; to use react-testing-library.</source>
          <target state="translated">react-testing-library를 사용 하려면 &lt;code&gt;yarn add --dev @testing-library/react&lt;/code&gt; 를 실행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c2580df5ede4388981be8693d0eb04cda44e78ad" translate="yes" xml:space="preserve">
          <source>You have to run &lt;code&gt;yarn add --dev enzyme&lt;/code&gt; to use Enzyme. If you are using a React version below 15.5.0, you will also need to install &lt;code&gt;react-addons-test-utils&lt;/code&gt;.</source>
          <target state="translated">Enzyme을 사용 하려면 &lt;code&gt;yarn add --dev enzyme&lt;/code&gt; 를 실행해야합니다 . 15.5.0 이하의 React 버전을 사용하는 경우 &lt;code&gt;react-addons-test-utils&lt;/code&gt; 도 설치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7ab8163799282eb2cd2bcd483eb50ba23a2e1feb" translate="yes" xml:space="preserve">
          <source>You make the dependency explicit instead of implicit.</source>
          <target state="translated">종속성을 암시 적이 아닌 명시 적으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="08d47da002fb02d0ffc5edc25d616083fbc6a387" translate="yes" xml:space="preserve">
          <source>You may also want to install the &lt;a href=&quot;https://www.npmjs.com/package/@types/jest&quot;&gt;&lt;code&gt;@types/jest&lt;/code&gt;&lt;/a&gt; module for the version of Jest you're using. This will help provide full typing when writing your tests with TypeScript.</source>
          <target state="translated">당신은 또한 설치할 수 있습니다 &lt;a href=&quot;https://www.npmjs.com/package/@types/jest&quot;&gt; &lt;code&gt;@types/jest&lt;/code&gt; &lt;/a&gt;사용중인 Jest 버전에 대한 @ types / jest 모듈. 이것은 TypeScript로 테스트를 작성할 때 완전한 타이핑을 제공하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="0c38db17ba138256cbd5a96be8f1e6dc538f5fa8" translate="yes" xml:space="preserve">
          <source>You may not care what &lt;code&gt;getErrors&lt;/code&gt; returns, specifically - it might return &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;, or &lt;code&gt;0&lt;/code&gt;, and your code would still work. So if you want to test there are no errors after drinking some La Croix, you could write:</source>
          <target state="translated">당신은 무엇을 걱정하지 않을 수 있습니다 &lt;code&gt;getErrors&lt;/code&gt; 그것을 반환 할 수 있습니다 - 특히, 수익을 &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;null&lt;/code&gt; , 또는 &lt;code&gt;0&lt;/code&gt; , 및 코드 작업 여전히 것. 따라서 La Croix를 마신 후에 오류가 없는지 테스트하려면 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c89edf49de3c63952efdcc592f2e40d0e91b763b" translate="yes" xml:space="preserve">
          <source>You may not care what &lt;code&gt;thirstInfo&lt;/code&gt; returns, specifically - it might return &lt;code&gt;true&lt;/code&gt; or a complex object, and your code would still work. So if you want to test that &lt;code&gt;thirstInfo&lt;/code&gt; will be truthy after drinking some La Croix, you could write:</source>
          <target state="translated">&lt;code&gt;thirstInfo&lt;/code&gt; 가 리턴 하는 것을 신경 쓰지 않을 수도 있습니다. 특히 &lt;code&gt;true&lt;/code&gt; 또는 복잡한 객체를 리턴 할 수 있으며 코드는 여전히 작동합니다. 따라서 La Croix를 마신 후 &lt;code&gt;thirstInfo&lt;/code&gt; 가 진실한지 테스트 하려면 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17b4764286d414a473eaaf4d566a76ce25182294" translate="yes" xml:space="preserve">
          <source>You should use the matcher that most precisely corresponds to what you want your code to be doing.</source>
          <target state="translated">코드에서 수행하려는 작업과 가장 정확하게 일치하는 매처를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="7f37219870fbd51ab28f12639a113236e2ba5334" translate="yes" xml:space="preserve">
          <source>You will find a number of example test cases in the &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples&quot;&gt;&lt;code&gt;examples&lt;/code&gt;&lt;/a&gt; folder on GitHub. You can also learn from the excellent tests used by the &lt;a href=&quot;https://github.com/facebook/react/tree/master/packages/react/src/__tests__&quot;&gt;React&lt;/a&gt;, &lt;a href=&quot;https://github.com/facebook/relay/tree/master/packages/react-relay/__tests__&quot;&gt;Relay&lt;/a&gt;, and &lt;a href=&quot;https://github.com/facebook/react-native/tree/master/Libraries/Animated/src/__tests__&quot;&gt;React Native&lt;/a&gt; projects.</source>
          <target state="translated">GitHub 의 &lt;a href=&quot;https://github.com/facebook/jest/tree/master/examples&quot;&gt; &lt;code&gt;examples&lt;/code&gt; &lt;/a&gt; 폴더에 여러 예제 테스트 사례가 있습니다. 또한 &lt;a href=&quot;https://github.com/facebook/react/tree/master/packages/react/src/__tests__&quot;&gt;React&lt;/a&gt; , &lt;a href=&quot;https://github.com/facebook/relay/tree/master/packages/react-relay/__tests__&quot;&gt;Relay&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/facebook/react-native/tree/master/Libraries/Animated/src/__tests__&quot;&gt;React Native&lt;/a&gt; 프로젝트에서 사용하는 뛰어난 테스트를 통해 배울 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d7eb67e376c7a0795313a9464135b5632741a836" translate="yes" xml:space="preserve">
          <source>Your &lt;code&gt;package.json&lt;/code&gt; should look something like this (where &lt;code&gt;&amp;lt;current-version&amp;gt;&lt;/code&gt; is the actual latest version number for the package). Please add the scripts and jest configuration entries:</source>
          <target state="translated">귀하의 &lt;code&gt;package.json&lt;/code&gt; 이 같은 것을 보일 것입니다 (여기서 &lt;code&gt;&amp;lt;current-version&amp;gt;&lt;/code&gt; 패키지의 실제 최신 버전 번호입니다). 스크립트 및 jest 구성 항목을 추가하십시오 :</target>
        </trans-unit>
        <trans-unit id="ec89bd1c5f68c024aeca6e9e14636486318a74fe" translate="yes" xml:space="preserve">
          <source>Your test will want to mock the &lt;code&gt;fetch&lt;/code&gt; function so that we can be sure that it gets called without actually making the network request. However, you'll also need to mock the return value of &lt;code&gt;fetch&lt;/code&gt; with a &lt;code&gt;Response&lt;/code&gt; (wrapped in a &lt;code&gt;Promise&lt;/code&gt;), as our function uses it to grab the created user's ID. So you might initially try writing a test like this:</source>
          <target state="translated">테스트는 실제로 네트워크 요청을하지 않고도 호출 함수를 호출 할 수 있도록 &lt;code&gt;fetch&lt;/code&gt; 함수 를 모방하려고합니다 . 그러나, 당신은 또한의 반환 값 조롱해야합니다 &lt;code&gt;fetch&lt;/code&gt; 로모그래퍼 &lt;code&gt;Response&lt;/code&gt; (A에 싸여 &lt;code&gt;Promise&lt;/code&gt; 우리의 기능은 생성 된 사용자의 ID를 잡기 위해 그것을 사용하기 때문에,). 따라서 처음에는 다음과 같이 테스트를 작성해 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1175cedc7032117d3657edf28dbe7bb9385d7c5c" translate="yes" xml:space="preserve">
          <source>Your tests should be deterministic. Running the same tests multiple times on a component that has not changed should produce the same results every time. You're responsible for making sure your generated snapshots do not include platform specific or other non-deterministic data.</source>
          <target state="translated">테스트는 결정 론적이어야합니다. 변경되지 않은 구성 요소에서 동일한 테스트를 여러 번 실행하면 매번 동일한 결과가 생성됩니다. 생성 된 스냅 샷에 플랫폼 별 또는 기타 비 결정적 데이터가 포함되지 않도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="2f17fc980285f8ffe0be9e33ef7152af13254fe8" translate="yes" xml:space="preserve">
          <source>afterAll()</source>
          <target state="translated">afterAll()</target>
        </trans-unit>
        <trans-unit id="fb268a1811f730c2067165b083e360322d72f477" translate="yes" xml:space="preserve">
          <source>afterEach()</source>
          <target state="translated">afterEach()</target>
        </trans-unit>
        <trans-unit id="9ad6d2fa2c7de85e6b6dd37cd6a886c8f07ad319" translate="yes" xml:space="preserve">
          <source>async-to-gen</source>
          <target state="translated">async-to-gen</target>
        </trans-unit>
        <trans-unit id="bd90b357192cd27b16a70b7698bb14ee20cba402" translate="yes" xml:space="preserve">
          <source>awesome-jest</source>
          <target state="translated">awesome-jest</target>
        </trans-unit>
        <trans-unit id="d09b0fbfb51ee1470bcc585dd8ce8dfa55e488df" translate="yes" xml:space="preserve">
          <source>beforeAll()</source>
          <target state="translated">beforeAll()</target>
        </trans-unit>
        <trans-unit id="c70978f19975e8b38cf044b33e31fad2d272183a" translate="yes" xml:space="preserve">
          <source>beforeEach()</source>
          <target state="translated">beforeEach()</target>
        </trans-unit>
        <trans-unit id="740e438d6d95b968c3b9aaa798d54c124e64790b" translate="yes" xml:space="preserve">
          <source>close puppeteer with Global Teardown</source>
          <target state="translated">글로벌 테어 다운으로 인형을 닫습니다</target>
        </trans-unit>
        <trans-unit id="53cdcf56a867665dc933b593cb499286aadcbc80" translate="yes" xml:space="preserve">
          <source>connect to puppeteer from each Test Environment</source>
          <target state="translated">각 테스트 환경에서 인형극에 연결</target>
        </trans-unit>
        <trans-unit id="25509aa65c3b573b5425ab6624df82134524f006" translate="yes" xml:space="preserve">
          <source>default: &lt;code&gt;undefined&lt;/code&gt;</source>
          <target state="translated">기본값 : &lt;code&gt;undefined&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c8244e80092f3c12d77f6dd509da0f653409320b" translate="yes" xml:space="preserve">
          <source>describe()</source>
          <target state="translated">describe()</target>
        </trans-unit>
        <trans-unit id="398a5e26f7d6ff23078ffbb871957ca77291b3e7" translate="yes" xml:space="preserve">
          <source>describe.each()</source>
          <target state="translated">describe.each()</target>
        </trans-unit>
        <trans-unit id="4f24a48da5c59a6bd3845bdb54350e1d1d0ee38d" translate="yes" xml:space="preserve">
          <source>describe.only()</source>
          <target state="translated">describe.only()</target>
        </trans-unit>
        <trans-unit id="f11fce8c9ed55e7be7b2cbcc6e46f524b949f14e" translate="yes" xml:space="preserve">
          <source>describe.only.each()</source>
          <target state="translated">describe.only.each()</target>
        </trans-unit>
        <trans-unit id="c3382b09895d6af2c9e821d96ad003e58d4b96de" translate="yes" xml:space="preserve">
          <source>describe.skip()</source>
          <target state="translated">describe.skip()</target>
        </trans-unit>
        <trans-unit id="2c446c6cd1bf47770ef8c7d1bd166c465eedf771" translate="yes" xml:space="preserve">
          <source>describe.skip.each()</source>
          <target state="translated">describe.skip.each()</target>
        </trans-unit>
        <trans-unit id="fcf239e7993ef571d39b364c0de3fda8a3ae0c81" translate="yes" xml:space="preserve">
          <source>error class: error object is &lt;strong&gt;instance of&lt;/strong&gt; class</source>
          <target state="translated">오류 클래스 : 오류 개체는 클래스의 &lt;strong&gt;인스턴스입니다&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7851c6709a8adac9e962eee4f13a4ff8d35c84c6" translate="yes" xml:space="preserve">
          <source>error object: error message is &lt;strong&gt;equal to&lt;/strong&gt; the message property of the object</source>
          <target state="translated">오류 개체 : 오류 메시지는 &lt;strong&gt;동일한&lt;/strong&gt; 객체의 속성 메시지</target>
        </trans-unit>
        <trans-unit id="a00f641af4b4bd382b037a5599ec8c6bd2a58a7a" translate="yes" xml:space="preserve">
          <source>eslint-plugin-jest</source>
          <target state="translated">eslint-plugin-jest</target>
        </trans-unit>
        <trans-unit id="3aede15b1d5d318f2bf628e79d06cd5ec821f235" translate="yes" xml:space="preserve">
          <source>expect()</source>
          <target state="translated">expect()</target>
        </trans-unit>
        <trans-unit id="c531f8f49210f5c5cc7e56c0bcf8809390d60182" translate="yes" xml:space="preserve">
          <source>expect.addSnapshotSerializer()</source>
          <target state="translated">expect.addSnapshotSerializer()</target>
        </trans-unit>
        <trans-unit id="73052babf147d5ab7087790cf489001a5fe6adef" translate="yes" xml:space="preserve">
          <source>expect.any()</source>
          <target state="translated">expect.any()</target>
        </trans-unit>
        <trans-unit id="041f3593b4cfc38ec52995cb888e8d017339e912" translate="yes" xml:space="preserve">
          <source>expect.anything()</source>
          <target state="translated">expect.anything()</target>
        </trans-unit>
        <trans-unit id="b1648f49219a878c2221460718595da8c398b8b3" translate="yes" xml:space="preserve">
          <source>expect.arrayContaining()</source>
          <target state="translated">expect.arrayContaining()</target>
        </trans-unit>
        <trans-unit id="07105ad3d99570c6ffdfd4ccea4770093ccd6589" translate="yes" xml:space="preserve">
          <source>expect.assertions()</source>
          <target state="translated">expect.assertions()</target>
        </trans-unit>
        <trans-unit id="cf206af29db6d448d19d0b2896ed0f7be77ca4b2" translate="yes" xml:space="preserve">
          <source>expect.extend()</source>
          <target state="translated">expect.extend()</target>
        </trans-unit>
        <trans-unit id="bef0c4a5294c45e4f23630650c298423d2b0033a" translate="yes" xml:space="preserve">
          <source>expect.hasAssertions()</source>
          <target state="translated">expect.hasAssertions()</target>
        </trans-unit>
        <trans-unit id="a4b4f299cc5121ba5bb42d780d793dd0d208d5d1" translate="yes" xml:space="preserve">
          <source>expect.not.arrayContaining()</source>
          <target state="translated">expect.not.arrayContaining()</target>
        </trans-unit>
        <trans-unit id="cd369cc867e384fabaa81e31b91e2ec5e06cb648" translate="yes" xml:space="preserve">
          <source>expect.not.objectContaining()</source>
          <target state="translated">expect.not.objectContaining()</target>
        </trans-unit>
        <trans-unit id="c3e51c2efa41f651e0f4da6911e099a7e6ae1ca4" translate="yes" xml:space="preserve">
          <source>expect.not.stringContaining()</source>
          <target state="translated">expect.not.stringContaining()</target>
        </trans-unit>
        <trans-unit id="1146b5bca92b76c491171096be15657da9f28d46" translate="yes" xml:space="preserve">
          <source>expect.not.stringMatching()</source>
          <target state="translated">expect.not.stringMatching()</target>
        </trans-unit>
        <trans-unit id="a323da51fabb3d791f0b36ac04909baab7f19868" translate="yes" xml:space="preserve">
          <source>expect.objectContaining()</source>
          <target state="translated">expect.objectContaining()</target>
        </trans-unit>
        <trans-unit id="05a9b81e11194231b386c00515a14089ffa1ab48" translate="yes" xml:space="preserve">
          <source>expect.stringContaining()</source>
          <target state="translated">expect.stringContaining()</target>
        </trans-unit>
        <trans-unit id="64a818d5f4128d542c68ad3e5b52cf9cb07239c5" translate="yes" xml:space="preserve">
          <source>expect.stringMatching()</source>
          <target state="translated">expect.stringMatching()</target>
        </trans-unit>
        <trans-unit id="5b53271817c17d31475c2601f79c760d8c18c932" translate="yes" xml:space="preserve">
          <source>in &lt;code&gt;toEqual&lt;/code&gt; or &lt;code&gt;toBeCalledWith&lt;/code&gt;</source>
          <target state="translated">에 &lt;code&gt;toEqual&lt;/code&gt; 또는 &lt;code&gt;toBeCalledWith&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="14fdeea7a02add9f25f4b254a8109cebfb41a968" translate="yes" xml:space="preserve">
          <source>jest</source>
          <target state="translated">jest</target>
        </trans-unit>
        <trans-unit id="399f3e6c7d355276f40f586cacf83580961e34e9" translate="yes" xml:space="preserve">
          <source>jest --bail</source>
          <target state="translated">농담-보석금</target>
        </trans-unit>
        <trans-unit id="7728f73469dcbf23ae8e337f07d557f5387051c2" translate="yes" xml:space="preserve">
          <source>jest --cache</source>
          <target state="translated">jest-캐시</target>
        </trans-unit>
        <trans-unit id="a4aa246751c414496487d54530974546f8e2e1a7" translate="yes" xml:space="preserve">
          <source>jest --changedFilesWithAncestor</source>
          <target state="translated">jest-변경된 파일</target>
        </trans-unit>
        <trans-unit id="e4435b17b912dad78333d9c715e558d3c202ab34" translate="yes" xml:space="preserve">
          <source>jest --changedSince</source>
          <target state="translated">농담 --changedSince</target>
        </trans-unit>
        <trans-unit id="b5261799c92dd14f3365e36279542409dc1f4470" translate="yes" xml:space="preserve">
          <source>jest --ci</source>
          <target state="translated">농담 --ci</target>
        </trans-unit>
        <trans-unit id="18b3b63f5ed9f4cb059fbdfa287a7092d2bd46c8" translate="yes" xml:space="preserve">
          <source>jest --clearCache</source>
          <target state="translated">농담 --clearCache</target>
        </trans-unit>
        <trans-unit id="6b45786c23204e16069d34c716fc3df38b6aa6b3" translate="yes" xml:space="preserve">
          <source>jest --collectCoverageFrom</source>
          <target state="translated">jest --collectCoverageFrom</target>
        </trans-unit>
        <trans-unit id="16739578c7f61b7a8f8542434d00d6ab09963e57" translate="yes" xml:space="preserve">
          <source>jest --colors</source>
          <target state="translated">농담-색상</target>
        </trans-unit>
        <trans-unit id="16996765a63984335bd12471e86885562b954705" translate="yes" xml:space="preserve">
          <source>jest --config</source>
          <target state="translated">jest --config</target>
        </trans-unit>
        <trans-unit id="ecd47d28d6d16f7e198f7bb676071b8de7aa625f" translate="yes" xml:space="preserve">
          <source>jest --coverage</source>
          <target state="translated">농담</target>
        </trans-unit>
        <trans-unit id="200e04fecf37753c77869affc65b05074a843073" translate="yes" xml:space="preserve">
          <source>jest --debug</source>
          <target state="translated">농담-디버그</target>
        </trans-unit>
        <trans-unit id="d0896a807b1438960db7baa7a96cc00d29eb6fbf" translate="yes" xml:space="preserve">
          <source>jest --detectOpenHandles</source>
          <target state="translated">jest --detectOpenHandles</target>
        </trans-unit>
        <trans-unit id="1edb0e7b6eaef88efb6ed9a604136e0b2dc3df91" translate="yes" xml:space="preserve">
          <source>jest --env</source>
          <target state="translated">농담 --env</target>
        </trans-unit>
        <trans-unit id="8a0f943b937dcd72c06bfe59afe73fb4a1f31d48" translate="yes" xml:space="preserve">
          <source>jest --errorOnDeprecated</source>
          <target state="translated">jest --errorOn</target>
        </trans-unit>
        <trans-unit id="451e3f27037c6eaedc5c0ee1528d6ecd3860ad73" translate="yes" xml:space="preserve">
          <source>jest --expand</source>
          <target state="translated">농담-확장</target>
        </trans-unit>
        <trans-unit id="75a8e4a783be5089515d60538e7e8125cdd33fe3" translate="yes" xml:space="preserve">
          <source>jest --findRelatedTests</source>
          <target state="translated">jest --find 관련 테스트</target>
        </trans-unit>
        <trans-unit id="4959c728768cddd33ed24149b8756c30f1461b6c" translate="yes" xml:space="preserve">
          <source>jest --forceExit</source>
          <target state="translated">jest --forceExit</target>
        </trans-unit>
        <trans-unit id="e7042ae5c15d17e9dfb626d3b992b070a2b33ac3" translate="yes" xml:space="preserve">
          <source>jest --help</source>
          <target state="translated">농담-도움말</target>
        </trans-unit>
        <trans-unit id="2b44f9af93a63dbc353bdbb59b8977473460ea15" translate="yes" xml:space="preserve">
          <source>jest --init</source>
          <target state="translated">jest --init</target>
        </trans-unit>
        <trans-unit id="b472735c07ba84430b5dcc73a9578211df4a2c7a" translate="yes" xml:space="preserve">
          <source>jest --json</source>
          <target state="translated">농담 --json</target>
        </trans-unit>
        <trans-unit id="67842930eb4c451f524a5334d5d9987f944c0b62" translate="yes" xml:space="preserve">
          <source>jest --lastCommit</source>
          <target state="translated">jest --lastCommit</target>
        </trans-unit>
        <trans-unit id="5ef4898fedf76393b34edae0c0c9eb5f9becbdb5" translate="yes" xml:space="preserve">
          <source>jest --listTests</source>
          <target state="translated">jest --list 테스트</target>
        </trans-unit>
        <trans-unit id="68a8e8c37228016d5b69d8f98bc9033444f6dcfc" translate="yes" xml:space="preserve">
          <source>jest --logHeapUsage</source>
          <target state="translated">jest --logHeapUsage</target>
        </trans-unit>
        <trans-unit id="34e1461f0465c9780fed87f508481d93f147883c" translate="yes" xml:space="preserve">
          <source>jest --maxConcurrency</source>
          <target state="translated">jest --maxConcurrency</target>
        </trans-unit>
        <trans-unit id="ff2ced6c82113057178b44c26a4df8d1cfcde5ad" translate="yes" xml:space="preserve">
          <source>jest --maxWorkers</source>
          <target state="translated">농담 --maxWorkers</target>
        </trans-unit>
        <trans-unit id="8c8c93cffedf5f51fbf6769d1b9f4b08296e0a72" translate="yes" xml:space="preserve">
          <source>jest --noStackTrace</source>
          <target state="translated">jest --noStackTrace</target>
        </trans-unit>
        <trans-unit id="07fe4de480c74eb982dfd2fc1ffabbc5e8000f9a" translate="yes" xml:space="preserve">
          <source>jest --notify</source>
          <target state="translated">농담-알림</target>
        </trans-unit>
        <trans-unit id="777939208a77b6ed85265bb3541e0aaf5212fbb3" translate="yes" xml:space="preserve">
          <source>jest --onlyChanged</source>
          <target state="translated">jest --only 변경</target>
        </trans-unit>
        <trans-unit id="39d9ffe9fc23f87610839ef7d3409e4bdcaeb08c" translate="yes" xml:space="preserve">
          <source>jest --outputFile</source>
          <target state="translated">jest --outputFile</target>
        </trans-unit>
        <trans-unit id="709a7d88446a6c333c370abdc7cbc81e5007aeb4" translate="yes" xml:space="preserve">
          <source>jest --passWithNoTests</source>
          <target state="translated">jest --passWithNoTests</target>
        </trans-unit>
        <trans-unit id="c01b9e323723244523c23d1edd20bbd8fa1fad8b" translate="yes" xml:space="preserve">
          <source>jest --projects</source>
          <target state="translated">jest-프로젝트</target>
        </trans-unit>
        <trans-unit id="28ccc63c68da10265b442f6ddb719c32cb336d21" translate="yes" xml:space="preserve">
          <source>jest --reporters</source>
          <target state="translated">농담-기자</target>
        </trans-unit>
        <trans-unit id="64629dd6eadf22a13bedf72b140ffb326b3adf10" translate="yes" xml:space="preserve">
          <source>jest --runInBand</source>
          <target state="translated">jest --runInBand</target>
        </trans-unit>
        <trans-unit id="6d7004d9e45fbe7afc81b68d019a0999a9bc0c7c" translate="yes" xml:space="preserve">
          <source>jest --runTestsByPath</source>
          <target state="translated">jest --runTestsByPath</target>
        </trans-unit>
        <trans-unit id="096d835c379fd03e494f9bdb3bd4cbf0d83b2f71" translate="yes" xml:space="preserve">
          <source>jest --setupTestFrameworkScriptFile</source>
          <target state="translated">jest --setupTestFrameworkScriptFile</target>
        </trans-unit>
        <trans-unit id="940e5b5b259afe41c7f972448e3b14ae829486ab" translate="yes" xml:space="preserve">
          <source>jest --showConfig</source>
          <target state="translated">jest --showConfig</target>
        </trans-unit>
        <trans-unit id="a19e9fb882999e3c40b7635bba97bd9c793f3561" translate="yes" xml:space="preserve">
          <source>jest --silent</source>
          <target state="translated">농담</target>
        </trans-unit>
        <trans-unit id="3116d8e92505df6e40aa26ca10c8d3a5aefaf6af" translate="yes" xml:space="preserve">
          <source>jest --testLocationInResults</source>
          <target state="translated">jest --testLocationInResults</target>
        </trans-unit>
        <trans-unit id="8a07b564f31bb6e6c96720d77231a8a1e45f39e3" translate="yes" xml:space="preserve">
          <source>jest --testNamePattern</source>
          <target state="translated">jest --testNamePattern</target>
        </trans-unit>
        <trans-unit id="4de2b306577ed62d6f8717e3427fffb985e1b43b" translate="yes" xml:space="preserve">
          <source>jest --testPathIgnorePatterns</source>
          <target state="translated">jest --testPathIgnorePatterns</target>
        </trans-unit>
        <trans-unit id="c6d599e9db1d5b8b8b9b1e34af131cc7a609574c" translate="yes" xml:space="preserve">
          <source>jest --testPathPattern</source>
          <target state="translated">jest --testPathPattern</target>
        </trans-unit>
        <trans-unit id="f1e05395a90bfd20cc69363133868bb63d439c51" translate="yes" xml:space="preserve">
          <source>jest --testRunner</source>
          <target state="translated">jest --testRunner</target>
        </trans-unit>
        <trans-unit id="a107d7a62c0faae9d219c603e662cbdfb1168139" translate="yes" xml:space="preserve">
          <source>jest --testSequencer</source>
          <target state="translated">jest --test 시퀀서</target>
        </trans-unit>
        <trans-unit id="c7ef133f2b7dc919c3ad71da9cce4c6ffd6cd868" translate="yes" xml:space="preserve">
          <source>jest --testTimeout</source>
          <target state="translated">jest --testTimeout</target>
        </trans-unit>
        <trans-unit id="855f8a66c2044d0c0aa8ce263401b44fa1019b06" translate="yes" xml:space="preserve">
          <source>jest --updateSnapshot</source>
          <target state="translated">jest --updateSnapshot</target>
        </trans-unit>
        <trans-unit id="4ea12447858a50cdd5c983e5da4ab87dbdf7bf88" translate="yes" xml:space="preserve">
          <source>jest --useStderr</source>
          <target state="translated">농담 --useStderr</target>
        </trans-unit>
        <trans-unit id="f073ca0513417405f3d24492d3c2e48be87f71de" translate="yes" xml:space="preserve">
          <source>jest --verbose</source>
          <target state="translated">농담-자세한</target>
        </trans-unit>
        <trans-unit id="8144cdc86e9d7837063cedb0371d26f3eec4e393" translate="yes" xml:space="preserve">
          <source>jest --version</source>
          <target state="translated">농담-버전</target>
        </trans-unit>
        <trans-unit id="24a92c60d5aa0d0bc0a04e89176cbe3de81ca593" translate="yes" xml:space="preserve">
          <source>jest --watch</source>
          <target state="translated">농담-시계</target>
        </trans-unit>
        <trans-unit id="4a0c8c57a84aa98a2040ae7e753c42a9d15607d0" translate="yes" xml:space="preserve">
          <source>jest --watchAll</source>
          <target state="translated">농담 --watchAll</target>
        </trans-unit>
        <trans-unit id="8357ee4077e5c430d196688e7e00e4f2b5298f39" translate="yes" xml:space="preserve">
          <source>jest --watchman</source>
          <target state="translated">농담-파수꾼</target>
        </trans-unit>
        <trans-unit id="8dac8b8cbde7c22969d69a11d630521076ff0471" translate="yes" xml:space="preserve">
          <source>jest-changed-files</source>
          <target state="translated">jest-changed-files</target>
        </trans-unit>
        <trans-unit id="b54512fd3b9795a4772b2657ce0156724195ce07" translate="yes" xml:space="preserve">
          <source>jest-codemods</source>
          <target state="translated">jest-codemods</target>
        </trans-unit>
        <trans-unit id="4d0ba9791c912565a89e87ec93cd71cdc4b75579" translate="yes" xml:space="preserve">
          <source>jest-diff</source>
          <target state="translated">jest-diff</target>
        </trans-unit>
        <trans-unit id="fae57be3b9d4c6db0129364d146af1ae34bc4571" translate="yes" xml:space="preserve">
          <source>jest-docblock</source>
          <target state="translated">jest-docblock</target>
        </trans-unit>
        <trans-unit id="33815f7eafadf66bdf82b692a5d7500e04bdcf17" translate="yes" xml:space="preserve">
          <source>jest-extended</source>
          <target state="translated">jest-extended</target>
        </trans-unit>
        <trans-unit id="7a5cb26800c7666578e96bedb106ca6c76db8288" translate="yes" xml:space="preserve">
          <source>jest-get-type</source>
          <target state="translated">jest-get-type</target>
        </trans-unit>
        <trans-unit id="9930457414d8318490b519406b0d01e0c0af9388" translate="yes" xml:space="preserve">
          <source>jest-validate</source>
          <target state="translated">jest-validate</target>
        </trans-unit>
        <trans-unit id="74459ea621c5c89c1a6a8777f420f08a699ce618" translate="yes" xml:space="preserve">
          <source>jest-worker</source>
          <target state="translated">jest-worker</target>
        </trans-unit>
        <trans-unit id="b5268823984999cb437a77b35d87876782899202" translate="yes" xml:space="preserve">
          <source>jest.advanceTimersByTime()</source>
          <target state="translated">jest.advanceTimersByTime()</target>
        </trans-unit>
        <trans-unit id="4f84712675c1d51a3df5e0c8bc41ac8a5291b5b5" translate="yes" xml:space="preserve">
          <source>jest.advanceTimersToNextTimer()</source>
          <target state="translated">jest.advanceTimersToNextTimer()</target>
        </trans-unit>
        <trans-unit id="926befda6fecbd4a52674619f3af9b0e7f68fc1e" translate="yes" xml:space="preserve">
          <source>jest.clearAllMocks()</source>
          <target state="translated">jest.clearAllMocks()</target>
        </trans-unit>
        <trans-unit id="4222fbb57b1accc14807b98d10122439d4ff5022" translate="yes" xml:space="preserve">
          <source>jest.clearAllTimers()</source>
          <target state="translated">jest.clearAllTimers()</target>
        </trans-unit>
        <trans-unit id="c805b56432a104b93bac2f37dc3d95d0ee13d1ef" translate="yes" xml:space="preserve">
          <source>jest.disableAutomock()</source>
          <target state="translated">jest.disableAutomock()</target>
        </trans-unit>
        <trans-unit id="37431f3778ecbfb714d3adbd0be802b5c721c30f" translate="yes" xml:space="preserve">
          <source>jest.doMock()</source>
          <target state="translated">jest.doMock()</target>
        </trans-unit>
        <trans-unit id="e1eb654d0e6f9a86254eb54aacafc37839145bc6" translate="yes" xml:space="preserve">
          <source>jest.dontMock()</source>
          <target state="translated">jest.dontMock()</target>
        </trans-unit>
        <trans-unit id="96a8a03defe83d958b13a8db1048b48645fd3459" translate="yes" xml:space="preserve">
          <source>jest.enableAutomock()</source>
          <target state="translated">jest.enableAutomock()</target>
        </trans-unit>
        <trans-unit id="63706588ece2fbb5ee1cbc26ed3cd9b3394a2aa3" translate="yes" xml:space="preserve">
          <source>jest.fn()</source>
          <target state="translated">jest.fn()</target>
        </trans-unit>
        <trans-unit id="5219ae476b088f3b68bcaf6bf0a3ebfe1cd29904" translate="yes" xml:space="preserve">
          <source>jest.genMockFromModule()</source>
          <target state="translated">jest.genMockFromModule()</target>
        </trans-unit>
        <trans-unit id="def17227de8f296f563b72986222dc177bb11d6d" translate="yes" xml:space="preserve">
          <source>jest.getTimerCount()</source>
          <target state="translated">jest.getTimerCount()</target>
        </trans-unit>
        <trans-unit id="124a77d3e596a96e5e22131aaf874ab0b85168bc" translate="yes" xml:space="preserve">
          <source>jest.isMockFunction()</source>
          <target state="translated">jest.isMockFunction()</target>
        </trans-unit>
        <trans-unit id="f59381d1be107811c5f127861c8b25779aac8d08" translate="yes" xml:space="preserve">
          <source>jest.isolateModules()</source>
          <target state="translated">jest.isolateModules()</target>
        </trans-unit>
        <trans-unit id="7fa6adb6c9fe552d5205372a422e3d7869a09385" translate="yes" xml:space="preserve">
          <source>jest.mock()</source>
          <target state="translated">jest.mock()</target>
        </trans-unit>
        <trans-unit id="ea788268b388e4e34786b83b59c434649a2880ba" translate="yes" xml:space="preserve">
          <source>jest.requireActual()</source>
          <target state="translated">jest.requireActual()</target>
        </trans-unit>
        <trans-unit id="eb1640f83eb73de04420583fd51286a6f8f26358" translate="yes" xml:space="preserve">
          <source>jest.requireMock()</source>
          <target state="translated">jest.requireMock()</target>
        </trans-unit>
        <trans-unit id="d6eb5ae9749a1f0bfe615e87dae5660439f11371" translate="yes" xml:space="preserve">
          <source>jest.resetAllMocks()</source>
          <target state="translated">jest.resetAllMocks()</target>
        </trans-unit>
        <trans-unit id="f5adc7f97ed3055597a83e098ddd8044c1732177" translate="yes" xml:space="preserve">
          <source>jest.resetModules()</source>
          <target state="translated">jest.resetModules()</target>
        </trans-unit>
        <trans-unit id="3fafd64547192fe4a73efe5ad2a0deadac3f3422" translate="yes" xml:space="preserve">
          <source>jest.restoreAllMocks()</source>
          <target state="translated">jest.restoreAllMocks()</target>
        </trans-unit>
        <trans-unit id="a948703e7207e3be8661bf6365a632c32226671e" translate="yes" xml:space="preserve">
          <source>jest.retryTimes()</source>
          <target state="translated">jest.retryTimes()</target>
        </trans-unit>
        <trans-unit id="b8ce73ec4b14b469bb28764f3a8c3d19e82ac7b6" translate="yes" xml:space="preserve">
          <source>jest.runAllImmediates()</source>
          <target state="translated">jest.runAllImmediates()</target>
        </trans-unit>
        <trans-unit id="53af7c8ab5fc7e913ecfb6a326b3610f64160176" translate="yes" xml:space="preserve">
          <source>jest.runAllTicks()</source>
          <target state="translated">jest.runAllTicks()</target>
        </trans-unit>
        <trans-unit id="bdd7917ff7ed9b0c8f251b4ed7bfa4aaf2b6152b" translate="yes" xml:space="preserve">
          <source>jest.runAllTimers()</source>
          <target state="translated">jest.runAllTimers()</target>
        </trans-unit>
        <trans-unit id="5f8881d3c2fa2e3c3978c63711cfc41587308941" translate="yes" xml:space="preserve">
          <source>jest.runOnlyPendingTimers()</source>
          <target state="translated">jest.runOnlyPendingTimers()</target>
        </trans-unit>
        <trans-unit id="115ea6be6949d8073195cf40a89a2c53d963f31a" translate="yes" xml:space="preserve">
          <source>jest.setMock()</source>
          <target state="translated">jest.setMock()</target>
        </trans-unit>
        <trans-unit id="e38a82fd2d18d144fa8049c3a4042f3947d71db8" translate="yes" xml:space="preserve">
          <source>jest.setTimeout()</source>
          <target state="translated">jest.setTimeout()</target>
        </trans-unit>
        <trans-unit id="4a21c582c06cb9f55c32d6a0da8083dbef2d04a4" translate="yes" xml:space="preserve">
          <source>jest.spyOn()</source>
          <target state="translated">jest.spyOn()</target>
        </trans-unit>
        <trans-unit id="e51942569d340db8459bde0b3a57da7a3ae5bd19" translate="yes" xml:space="preserve">
          <source>jest.unmock()</source>
          <target state="translated">jest.unmock()</target>
        </trans-unit>
        <trans-unit id="7bdcc5f2e0051948cd9175cbfd47b9f3a5c8a112" translate="yes" xml:space="preserve">
          <source>jest.useFakeTimers()</source>
          <target state="translated">jest.useFakeTimers()</target>
        </trans-unit>
        <trans-unit id="567a022c7ff0ed1eeecf66243bfb760f39f98839" translate="yes" xml:space="preserve">
          <source>jest.useRealTimers()</source>
          <target state="translated">jest.useRealTimers()</target>
        </trans-unit>
        <trans-unit id="d6c73ed242e8279bf8b5008c49164ea76ecca716" translate="yes" xml:space="preserve">
          <source>launch &amp;amp; file the websocket endpoint of puppeteer with Global Setup</source>
          <target state="translated">Global Setup으로 puppeteer의 websocket 엔드 포인트를 시작 및 제출</target>
        </trans-unit>
        <trans-unit id="c5534dc1bf91cfa3f571372cc1df1fde4778c65c" translate="yes" xml:space="preserve">
          <source>matching the files that coverage info needs to be collected from.</source>
          <target state="translated">적용 범위 정보를 수집해야하는 파일과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="bdaf39bbe2e8ce24d626e5d939f2687b7925a111" translate="yes" xml:space="preserve">
          <source>mockFn.getMockName()</source>
          <target state="translated">mockFn.getMockName()</target>
        </trans-unit>
        <trans-unit id="76ba86f80a3975694b82876ec035c67727b880ce" translate="yes" xml:space="preserve">
          <source>mockFn.mock.calls</source>
          <target state="translated">mockFn.mock.calls</target>
        </trans-unit>
        <trans-unit id="b8f5e098751b2e1a0b0c994fa0e253d7b6667585" translate="yes" xml:space="preserve">
          <source>mockFn.mock.instances</source>
          <target state="translated">mockFn.mock.instances</target>
        </trans-unit>
        <trans-unit id="37a607803e67bc8f0e277c4bad07d899cb8e68ee" translate="yes" xml:space="preserve">
          <source>mockFn.mock.results</source>
          <target state="translated">mockFn.mock.results</target>
        </trans-unit>
        <trans-unit id="d7884cf2e18f52e2befafea1329cc93891d01d0e" translate="yes" xml:space="preserve">
          <source>mockFn.mockClear()</source>
          <target state="translated">mockFn.mockClear()</target>
        </trans-unit>
        <trans-unit id="b1a1dc73ee86a9db45f473726c03a5d44e7d6e00" translate="yes" xml:space="preserve">
          <source>mockFn.mockImplementation()</source>
          <target state="translated">mockFn.mockImplementation()</target>
        </trans-unit>
        <trans-unit id="705599d736e3f800c387b8732532a981208d86f3" translate="yes" xml:space="preserve">
          <source>mockFn.mockImplementationOnce()</source>
          <target state="translated">mockFn.mockImplementationOnce()</target>
        </trans-unit>
        <trans-unit id="b15f7560dc442cfe559991bd028b3593dbedcfa3" translate="yes" xml:space="preserve">
          <source>mockFn.mockName()</source>
          <target state="translated">mockFn.mockName()</target>
        </trans-unit>
        <trans-unit id="cbee5a4253c363dd81a99f99a7171fe30ca56500" translate="yes" xml:space="preserve">
          <source>mockFn.mockRejectedValue()</source>
          <target state="translated">mockFn.mockRejectedValue()</target>
        </trans-unit>
        <trans-unit id="f0f879d05ce665721a5b420f915a6b799a9261b3" translate="yes" xml:space="preserve">
          <source>mockFn.mockRejectedValueOnce()</source>
          <target state="translated">mockFn.mockRejectedValueOnce()</target>
        </trans-unit>
        <trans-unit id="6379aa11d6a3d7b94b0cabd0ea38f28a5ac0a66b" translate="yes" xml:space="preserve">
          <source>mockFn.mockReset()</source>
          <target state="translated">mockFn.mockReset()</target>
        </trans-unit>
        <trans-unit id="e5f5a2cc9780e616fb57bcbabbb5e1b492e59a7c" translate="yes" xml:space="preserve">
          <source>mockFn.mockResolvedValue()</source>
          <target state="translated">mockFn.mockResolvedValue()</target>
        </trans-unit>
        <trans-unit id="a610c3278d44712a00c28aba1ba0a5f4c56f4602" translate="yes" xml:space="preserve">
          <source>mockFn.mockResolvedValueOnce()</source>
          <target state="translated">mockFn.mockResolvedValueOnce()</target>
        </trans-unit>
        <trans-unit id="93b4b4162d3f8f9f6743942f1582c22d36cf0434" translate="yes" xml:space="preserve">
          <source>mockFn.mockRestore()</source>
          <target state="translated">mockFn.mockRestore()</target>
        </trans-unit>
        <trans-unit id="b89668bf6eee3709904c8e914501f15481a0ec32" translate="yes" xml:space="preserve">
          <source>mockFn.mockReturnThis()</source>
          <target state="translated">mockFn.mockReturnThis()</target>
        </trans-unit>
        <trans-unit id="8406d4374df6cedb0774c198a5e18305079be058" translate="yes" xml:space="preserve">
          <source>mockFn.mockReturnValue()</source>
          <target state="translated">mockFn.mockReturnValue()</target>
        </trans-unit>
        <trans-unit id="91d18268f60b6021a577b531532180c54eed125c" translate="yes" xml:space="preserve">
          <source>mockFn.mockReturnValueOnce()</source>
          <target state="translated">mockFn.mockReturnValueOnce()</target>
        </trans-unit>
        <trans-unit id="110fd2eef67d470b905e3f770bc78bf0e48c4532" translate="yes" xml:space="preserve">
          <source>moduleNameMapper</source>
          <target state="translated">moduleNameMapper</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="f398e82965b003d86545395906bc58c426a160f4" translate="yes" xml:space="preserve">
          <source>or the following for Windows:</source>
          <target state="translated">또는 Windows의 경우 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="2e4e9d9ce9649c8da277337be899d54f4b10f016" translate="yes" xml:space="preserve">
          <source>pretty-format</source>
          <target state="translated">pretty-format</target>
        </trans-unit>
        <trans-unit id="b41c94dc77a8359c700e959dbc3271747436b9b8" translate="yes" xml:space="preserve">
          <source>react-testing-library</source>
          <target state="translated">react-testing-library</target>
        </trans-unit>
        <trans-unit id="6096aad9326ad51aa7277852583cdbbd0063c505" translate="yes" xml:space="preserve">
          <source>regular expression: error message &lt;strong&gt;matches&lt;/strong&gt; the pattern</source>
          <target state="translated">정규식 : 오류 메시지 가 패턴 &lt;strong&gt;과 일치&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="564cb4d408b58135c97baa36f450885bf9df5afd" translate="yes" xml:space="preserve">
          <source>renamed from &lt;code&gt;runTimersToTime&lt;/code&gt; to &lt;code&gt;advanceTimersByTime&lt;/code&gt; in Jest &lt;strong&gt;22.0.0&lt;/strong&gt;</source>
          <target state="translated">Jest &lt;strong&gt;22.0.0&lt;/strong&gt; 에서 &lt;code&gt;runTimersToTime&lt;/code&gt; 에서 &lt;code&gt;advanceTimersByTime&lt;/code&gt; 으로 이름이 변경되었습니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b081d67ddd0df4286abac590611b195d5398dfcd" translate="yes" xml:space="preserve">
          <source>renamed in Jest &lt;strong&gt;22.0.0+&lt;/strong&gt;</source>
          <target state="translated">Jest &lt;strong&gt;22.0.0 이상&lt;/strong&gt; 에서 이름이 변경되었습니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="694331c0b9e2b5401cd9005a2f8016a7f0913ff5" translate="yes" xml:space="preserve">
          <source>renamed in Jest &lt;strong&gt;26.0.0+&lt;/strong&gt;</source>
          <target state="translated">Jest &lt;strong&gt;26.0.0+&lt;/strong&gt; 에서 이름이 변경되었습니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fa765d3c5cf61960d9c86c450acc1e2d6113a622" translate="yes" xml:space="preserve">
          <source>rewrite &lt;code&gt;expect(received).not.toBe(expected)&lt;/code&gt; as &lt;code&gt;expect(Object.is(received, expected)).toBe(false)&lt;/code&gt;</source>
          <target state="translated">다시 &lt;code&gt;expect(received).not.toBe(expected)&lt;/code&gt; 등 &lt;code&gt;expect(Object.is(received, expected)).toBe(false)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="12ee99b45418f1c182987feaff420ab1c0a53144" translate="yes" xml:space="preserve">
          <source>rewrite &lt;code&gt;expect(received).not.toEqual(expected)&lt;/code&gt; as &lt;code&gt;expect(received.equals(expected)).toBe(false)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;expect(received).not.toEqual(expected)&lt;/code&gt; 을 &lt;code&gt;expect(received.equals(expected)).toBe(false)&lt;/code&gt; 다시 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="648a633ae93664b145f1de2382bce78296d0d025" translate="yes" xml:space="preserve">
          <source>rewrite &lt;code&gt;expect(received).toBe(expected)&lt;/code&gt; as &lt;code&gt;expect(Object.is(received, expected)).toBe(true)&lt;/code&gt;</source>
          <target state="translated">다시 &lt;code&gt;expect(received).toBe(expected)&lt;/code&gt; 등 &lt;code&gt;expect(Object.is(received, expected)).toBe(true)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d4f197332e08a233e78868954dc8a7424597d992" translate="yes" xml:space="preserve">
          <source>rewrite &lt;code&gt;expect(received).toEqual(expected)&lt;/code&gt; as &lt;code&gt;expect(received.equals(expected)).toBe(true)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;expect(received).toEqual(expected)&lt;/code&gt; 을 &lt;code&gt;expect(received.equals(expected)).toBe(true)&lt;/code&gt; 다시 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="98551bd9aa53f809816b1e04556754e5dbd233c3" translate="yes" xml:space="preserve">
          <source>setupFiles</source>
          <target state="translated">setupFiles</target>
        </trans-unit>
        <trans-unit id="cab3c689753017d9ed1c9833b41212afcceb0268" translate="yes" xml:space="preserve">
          <source>string: error message &lt;strong&gt;includes&lt;/strong&gt; the substring</source>
          <target state="translated">문자열 : 오류 메시지 에 하위 문자열이 &lt;strong&gt;포함됨&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1a13bd67d53c6ca5d0ba854cc1c6d8e1dc4db3cb" translate="yes" xml:space="preserve">
          <source>test()</source>
          <target state="translated">test()</target>
        </trans-unit>
        <trans-unit id="96bc193802c9de785826750faae2c6bc85cbfbb8" translate="yes" xml:space="preserve">
          <source>test.each()</source>
          <target state="translated">test.each()</target>
        </trans-unit>
        <trans-unit id="5d3becd10c06347f68018bdfb99aca7f0ac8047e" translate="yes" xml:space="preserve">
          <source>test.only()</source>
          <target state="translated">test.only()</target>
        </trans-unit>
        <trans-unit id="ab30dfd5db9a31603c2e47fbd6881ec8dab86d26" translate="yes" xml:space="preserve">
          <source>test.only.each()</source>
          <target state="translated">test.only.each()</target>
        </trans-unit>
        <trans-unit id="1176e40f403020d9366a6b52b73ff551f31b1814" translate="yes" xml:space="preserve">
          <source>test.skip()</source>
          <target state="translated">test.skip()</target>
        </trans-unit>
        <trans-unit id="f1d908eaf6e6e7fa35622b4b43d6a8af1a3c660e" translate="yes" xml:space="preserve">
          <source>test.skip.each()</source>
          <target state="translated">test.skip.each()</target>
        </trans-unit>
        <trans-unit id="74875a7933e712e5381bd416043bfb0b6616a91e" translate="yes" xml:space="preserve">
          <source>test.todo()</source>
          <target state="translated">test.todo()</target>
        </trans-unit>
        <trans-unit id="f4cea10a1c0dc3c50965ee387dece60500be5cff" translate="yes" xml:space="preserve">
          <source>to match a property in &lt;code&gt;objectContaining&lt;/code&gt; or &lt;code&gt;toMatchObject&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;objectContaining&lt;/code&gt; 또는 &lt;code&gt;toMatchObject&lt;/code&gt; 의 속성과 일치</target>
        </trans-unit>
        <trans-unit id="b1d3d79ec58192bdcdaff5e0ab0b7fbca133543f" translate="yes" xml:space="preserve">
          <source>to match an element in &lt;code&gt;arrayContaining&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;arrayContaining&lt;/code&gt; 의 요소와 일치</target>
        </trans-unit>
        <trans-unit id="3556cfc1ba0721081f3f93c076211e40ef1a22b9" translate="yes" xml:space="preserve">
          <source>transformIgnorePatterns customization</source>
          <target state="translated">transformIgnorePatterns 사용자 정의</target>
        </trans-unit>
        <trans-unit id="fc220be1ad7bd8b6a9feda6f6ba1285b333e98e2" translate="yes" xml:space="preserve">
          <source>vscode-jest</source>
          <target state="translated">vscode-jest</target>
        </trans-unit>
        <trans-unit id="5218cb6aea807d0d643ecaa0be3719b154b08685" translate="yes" xml:space="preserve">
          <source>webpack 2 offers native support for ES modules. However, Jest runs in Node, and thus requires ES modules to be transpiled to CommonJS modules. As such, if you are using webpack 2, you most likely will want to configure Babel to transpile ES modules to CommonJS modules only in the &lt;code&gt;test&lt;/code&gt; environment.</source>
          <target state="translated">webpack 2는 ES 모듈을 기본적으로 지원합니다. 그러나 Jest는 노드에서 실행되므로 ES 모듈을 CommonJS 모듈로 변환해야합니다. 따라서 웹팩 2를 사용하는 경우 &lt;code&gt;test&lt;/code&gt; 환경 에서만 ES 모듈을 CommonJS 모듈로 변환하도록 Babel을 구성하려고 합니다.</target>
        </trans-unit>
        <trans-unit id="5ebedacdf66fa11ed6c1f1cd9d9b0e19efbf3b58" translate="yes" xml:space="preserve">
          <source>you can use:</source>
          <target state="translated">당신이 사용할 수있는:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
